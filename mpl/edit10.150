TITLE EDIT10 

SUBTTL DEFINITIONS

;TEMPORARY EDITOR FOR THE DISK--WORKS BY RECOPYING
;DEVICES USED

	LOC 137
	150	;VERSION NUMBER
	RELOC

RPGNAM==<SIXBIT /RPG/>


STANSW==0	;ON FOR STANFORD TYPE PPNS, ETC
TEMPSW==1	;GIVES TEMPCOR UUO FEATURE

TTY==1
IN==2
OUT==3
LPT==4
ALTDV==5	;THE OTHER INPUT DEVICE (COPY AND TRANSFER)
CTL==6	;READ DSK FOR COMMAND FILE
CTL2==7	;FOR DELETING COMMAND FILE

;ACS USED

FL=0	;FLAG REGISTER
T1=1	;TEMP REGISTERS
T2=2
T3=3
T4=4
T5=5

FL2=11
ALTP=12		;POINTER FOR ALTER MODE
CS=13	;CHARACTER TABLE BITS
SINDEX=14	;LINE TO FIND, USED ALSO BY THE VARIOUS ROUTINES
PNTR=15		;POINTS AT CURRENT PLACE IN BUFFER
C=16		;CHARACTER RETURNED HERE BY GNCH
P=17		;PUSHDOWN LIST

;FLAGS  (RIGHT HALF)

BOF==1		;NOW ON FIRST RECORD OF FILE
EOF==2		;HAVE READ END OF FILE BUT NOT NECESSARILY BUT IN BUFFER
EOF2==4		;LAST WORD OF FILE IS IN CURRENT BUFFER
ADDL==10	;USED IN COMMAND SCANNING--LINE NUMBER + INC
SUBL==20	;LINE NUMBER - INC
IDF==40		;SCAN HAS SEEN AN IDENTIFIER
NUMF==100	;SCAN HAS SEEN A NUMBER
TERMF==200	;SCAN SAW A TERMINATOR (LF OR ALTMODE)
LINSN==400	;THE COMMAND INPUT ROUTINES SAW A LINE NUMBER
PGSN==1000	;THEY SAW A PAGE NUMBER
RENSN==2000	;REENTER SEEN FROM CONSOLE
ORDF==4000	;LINES OUT OF ORDER (USED BY NUMBER)
BGSN==10000	;BIGGEST PAGE HAS BEEN SEEN
M37F==20000	;THIS IS A MODEL 37
CNTF==40000	;COMMAND USING !
DPYF==100000	;THIS IS A III DISPLAY
READOF==200000	;THIS FILE IS BEING USED IN READ ONLY MODE
EXTOG==400000	;ON FOR SHORT ERROR MESSAGES

;FLAGS (LEFT HALF)

NEGF==1		;SEARCH HAS SEEN A 
DEMCHR==2	;SEARCH MUST SEE ANOTHER CHARACTER
ASSMF==4	;SEARCH HAS ASSUMED SEARCH CONTINUATION
ALTSRF==10	;HE WANTS TO DO A SEARCH AND EDIT
NUMSRF==20	;HE ONLY WANTS NUMBERS OF LINES FOUND
ARBITG==40	;WE ARE DOING  CURRENTLY, DO NOT ALLOW ANOTHER
EXCTSR==100	;WANTS TO SEARCH EXACTLY (NOT IGNORE CASE)
COPFIL==200	;WE ARE COPYING FROM ANOTHER FILE
ISCOP==400	;WE ARE DOING A COPY
NOPRN==1000	;DO NOT PRINT WHILE DOING SUBSTITUTE
DECID==2000	;ALLOW USER TO DECIDE IF LINE IS OK
EXCTS1==4000	;ANOTHER EXACT SEARCH FLAG FOR SUBS
QMODF==10000	;DO NOT TREAT ? AS A SPECIAL CASE ON INPUT
GCOM==20000	;DOING A G COMMAND INSTEAD OF E
SRCOP==40000	;DOING A SEARCH OF SECOND FILE
TRANFL==100000	;THIS IS A TRANSFER COMMAND WHICH HAS DELETED LINES
TECOF==200000	;THIS IS A TECO FILE
FSTOPF==400000	;THIS IS THE FIRST READ OP ON THIS FILE

;FLAGS IN FL2 (RIGHT)

STARF==1	;WE HAVE SEEN A * FOR THE LAST LINE
RUBF==2		;WE ARE DOING RUBOUT IN INTRA-LINE EDIT
ALTDUP==4	;DUPLEX CHARACTERS IN ALTER MODE
RUBF2==10	;DOING DELETE TYPE RUBOUT IN ALTER MODE
RPGFLG==20	;READ IN RPG MODE
TEMPFL==40	;READ A TEMP CORE FILE
NEWFL==100	;NEW FILE NAME SEEN BY END CODE
SVIT==200	;DOING A W INSTEAD OF AN E
STOPI==400	;FLAG SET TO STOP INSERT AFTER THIS LINE (END WITH ALTMODE)
CTOEQF==1000	;IN COPY(TRANSFER) WE ARE TRYING TO INSERT ON TOP OF A LINE
SUPOFL==2000	;SUPRESS OUTPUT (* AND SEQ NUMS) WHILE READING @ FILE
CBFUS==4000	;LPTBUF IN USE FOR READING @ FILE
SUPN==10000	;SUPPRESS LINE NUMBERS ON INDIVIDUAL COMMANDS
ASUPN==20000	;SUPPRESS LINE NUMBERS ON ALL OCCURANCES
SVIT2==40000	;Z COMMAND, SELECT NEW FILE
RPGALT==40000	;ACCEPT 175 AS ALTMODE FROM RPG

;LEFT HALF FLAGS IN FL2
RSW==1	;/R SEEN IN NAME READ
SSW==2	;/S SEEN ON NAME READ
SRFND==4	;FOUND SOMETHING ON A F OR S COMMAND
KEPSQF==10	;USE FIRST CHRS AS SEQ NUM IF TECO AND THERE
PRT37==20	;HE SAID PRINTER HAS 96 CHRS
CTLUFL==40	;CONTROL U USED IN A MODE (FOR SUBS)
BSW==100	;/B SEEN IN NAME READ
BMOD==200	;BASIC MODE, SPECIAL HANDELING
BINS==400	;B INSTEAD OF I IN ALTER MODE (CAN INSERT CR)
NOCTLU==1000	;DO NOT ALLOW CONTROL U (EXCEPT CLEAR LINE) IN INSERT
ORCHR==2000	;INSIDE AN OR IN MATCH
MATEOL==4000	;ALL STRINGS MATCH AGAINS END OF LINE

EXTERNAL JOBFF,JOBREL,JOBSYM,JOBDDT,JOBAPR,JOBSA,JOBREN,JOBOPC

OPDEF ERROR [1B8]	;ERROR UUOS FATAL ERROR
OPDEF NERROR [2B8]	;NON-FATEL ERROR
OPDEF RERROR [3B8]	;PRINT MESSAGE AND RETURN
OPDEF PERROR [4B8]	;PRINT MSG AND DO A POPJ P,

;ERROR NUMBERS

NUMR==0

DEFINE ERRORS (A)
<IRP A
<NUMR==NUMR+1
A==NUMR
>>

ERRORS <ICN,DIE,DDE,ILC,ILUUO,LTL,NLN,NSP,ORDER,UNA,ILR>
ERRORS <WAR,TMS,STL,ISS,ILFMT,NSG,FNF,DNA,NEC,IRS,STC,ITD>
ERRORS <NNN,NMF,IBN>

SRBLG==^D200	;NUMBER OF CHRS ALLOWED IN SEARCH STRING
SRNUM==6	;NUMBER OF SEARCH STRINGS ALLOWED
MXWPL==^D30	;MAX NUMBER OF WORDS PER LINE
IFN STANSW,<%LPP==^D52>
IFE STANSW,<%LPP==^D58>
BUFSIZ==^D65	;NUMBER OF CHRS ALLOWED IN A BUFFER
DSKTAB==-1	;THE TABLE NUMBER TO USE
SUBTTL RPG LOADER

HISEG

CREFIT:	OUTSTR [ASCIZ /
/]
	MOVEI T1,RPGR
	HRLI	T1,1
	RUN T1,	;RUN UUO
ARRAY RPGBUF[3],RPGUNM[2]

	DEFINE MCXOR (A,B)
	<A!B-A&B>

SUBTTL CHARACTER TABLES




;A CHARACTER TABLE FOR USE ON TYPE IN AND TYPE OUT

;FLAGS USED IN CHARACTER TABLE

OPF==10		;THIS IS A SPECIAL CHARACTER
SNUMF==4	;THIS IS PART OF A NUMBER
LETF==2		;THIS IS A LETTER
TERM==1		;THIS IS A TERMINATOR
M37==400000	;THIS CHR IS PRINTED AS ITSELF ON MODEL 37
NSEPF==200000	;THIS IS NOT A SEPERATOR (USED ON $,%,AND.)
DEFINE CHRS (FLAGS,PALT,INALT,RH)
<BYTE (4) FLAGS (7) PALT,INALT(18)RH>

CTBL:	0
	CHRS OPF,"!","",""
	CHRS OPF,42,"",""
	CHRS OPF,"#",3,3
	CHRS OPF,"$",4,4
	CHRS OPF,"%",5,5
	CHRS OPF,"&",6,6
	CHRS OPF,"'",7,7
	CHRS OPF,"(",10,10
	0
	CHRS OPF!TERM,0,12,12
	CHRS OPF,0,13,13
	CHRS OPF,0,14,14
	0
	CHRS OPF,")",16,16
	CHRS OPF,"*",17,17
	CHRS OPF,"+",20,20
	CHRS OPF,<",">,21,21
	CHRS OPF,"-",22,22
	CHRS OPF,".",23,23
	CHRS OPF,"/",24,24
	CHRS OPF,"0",25,25
	CHRS OPF,"1",26,26
	CHRS OPF,"2",27,27
	CHRS OPF,"9",30,30
	CHRS OPF,"6",31,31
	CHRS OPF,"4",32,32
	CHRS OPF,"=",33,33
	CHRS OPF,"<",34,34
	CHRS OPF,\">",35,35
	CHRS OPF,"7",36,36
	CHRS OPF,"8",37,37
	0
	CHRS OPF,0,1,"!"
	CHRS OPF,0,2,42
	CHRS OPF,0,3,"#"
	CHRS OPF,0,4,"$"+NSEPF
	CHRS OPF,0,5,"%"+NSEPF
	CHRS OPF,0,6,"&"
	CHRS OPF,0,7,47
	CHRS OPF,0,10,"("
	CHRS OPF,0,16,")"
	CHRS OPF,0,17,"*"
	CHRS OPF,0,20,"+"
	CHRS OPF,0,21,<",">
	CHRS OPF,0,22,"-"
	CHRS OPF,0,23,"."+NSEPF
	CHRS OPF,0,24,"/"
	CHRS SNUMF,0,25,20
	CHRS SNUMF,0,26,21
	CHRS SNUMF,0,27,22
	CHRS SNUMF,0,176,23
	CHRS SNUMF,0,32,24
	CHRS SNUMF,0,"5",25
	CHRS SNUMF,0,31,26
	CHRS SNUMF,0,36,27
	CHRS SNUMF,0,37,30

	CHRS SNUMF,0,30,31
	CHRS OPF,0,174,":"
	CHRS OPF,0,<";">,<";">
	CHRS OPF,0,34,"<"
	CHRS OPF,0,33,"="

	CHRS OPF,0,35,">"
	CHRS OPF,"?","?","?"
	CHRS OPF,0,140,"@"
XXZ=101
REPEAT ^D26,<CHRS LETF,0,XXZ+40,XXZ-40
XXZ=XXZ+1>
	CHRS OPF,0,173,"["
	CHRS OPF,0,"\","\"
	CHRS OPF,0,175,"]"
	CHRS OPF,0,"^","^"
	CHRS OPF,0,"=","="
	CHRS OPF,100,140,140
XXZ=141
REPEAT ^D26,<CHRS LETF,XXZ-40,XXZ,XXZ-100
XXZ=XXZ+1>
	CHRS OPF,"[",173,173+M37
	CHRS OPF,":",174,174+M37
	CHRS OPF!TERM,<"]">,175,175+M37
	CHRS OPF,"3",176,176+M37
	CHRS OPF,"\",177,177
	CHRS OPF!TERM,0,0,200
	CHRS OPF,0,0,201

SUBTTL SCANNER

GNCHL:	PUSHJ P,GNCTOT	;GET A CHARACTER
	CAIL C,240
	JRST	[SUBI C,240
		JRST GNCHB]
	CAIE C,4	;TREAT ^D SAME AS ALTMODE FOR TYMEX
	CAIN C,33	;CONVERT ALTMODE TO 200 TO DISTINGUISH FROM
	MOVEI C,200	;LEFT CURLY BRACKET
	CAIN C,"B"-100	;IS IT A CONTROL B
	JRST BUFUSE
	CAIN C,"R"-100	;CONVERT CONTROL R
	MOVEI C,201	;TO 201
	TLNE FL,QMODF	;SHOULD WE TREAT ? SPECIALLY
	JRST GNCHB	;NO
	CAIN C,"?"	;SHOULD WE USE ALTERNATE CHR SET?
	JRST GNCHA	;YES
GNCHB:	JUMPE C,GNCHL	;IGNORE NULLS
	MOVE CS,CTBL(C)	;GET CHARACTER TABLE BITS
	TLNE CS,LETF_16	;CHECK TO SEE IF A LETTER
	TDC C,CASEBT	;USE UPPER/LOWER INFO
	POPJ P,		;NO, JUST RETURN
GNCHA:	PUSHJ P,GNCTOT	;GET THE CHR AFTER ?
	SKIPE CTBL(C)	;NO CHANGE FOR NULL,SPACE, TAB, CRET
	MOVS C,CTBL(C)	;GET THE ALTERNATE CHR FROM CHR TABLE
	ANDI C,177	;ONLY THE CHR BITS
	JRST GNCHB	;GO CHECK THINGS
GNCHD:	SOSG	RPGBUF+2	;CHECK FOR BUFFER EMPTY
	JRST RPGMTY
RPGMTD:	IBP RPGBUF+1	;ADVANCE POINTER
	MOVE C,@RPGBUF+1	;AND CHECK FOR LINE NUMBER
	TRNE C,1
	JRST LINNUM
	LDB	C,RPGBUF+1	;GET CHAR
	JUMPE C,GNCHD	;IGNORE NULL CHARACTERS
	AOS (P)		;USUALL SKIP A TTCALL
	TRNE FL2,RPGALT	;IF NOT ACTUALLY RPG (COMMAND)
	CAIE C,175	;OR NOT A 175
	POPJ	P,		;TRA 4,4
	MOVEI C,33	;CHANGE TO 33
	POPJ P,

GNCHQ:	SOSG TIBUF+2	;ANY INPUT LEFT??
	IN TTY,0	;NO READ SOME
	SKIPA		;READ WAS OK
	CLOSE TTY,0	;BAD READ, CLOSE TTY FOR EOF
	ILDB C,TIBUF+1
	TRNN FL,DPYF
	ANDI C,177
	POPJ P,

BUFCLS:	SETZM BUFPTR#	;NO MORE BUFFER READING
GNCTOT:	SKIPE BUFPTR
	JRST BUFGRD	;GO GET A CHR FROM THE BUFFER
	TRNE FL2,RPGFLG
	PUSHJ P,GNCHD	;READ ONE, USUALLY SKIPS
	JRST GNCHQ	;GET ONE FROM THE TTY
	POPJ P,		;IF GNCHD SKIPPED

BUFGRD:	ILDB C,BUFPTR	;GET A CHR
	JUMPE C,BUFCLS	;FINISHED
	CAIN C,200
	JRST	[OUTCHI "$"
		POPJ P,]
	OUTCHR C	;ECHO IT
	POPJ P,

BUFUSE:	SETSTS TTY,202	;IF READING FROM TTY DO NOT ECHO
	PUSHJ P,RD1CHR	;READ 1 CHR (RPG BUFFER OR TTY)
	SETSTS TTY,2	;TURN ECHO BACK ON
	PUSHJ P,BUFSET	;SET UP BUFFER POINTER
	JRST GNCHL	;AND GET A CHR FROM IT

RPGMTY:	IFN TEMPSW,<TRNE FL2,TEMPFL	;IF TEMPSW
	JRST OFRPG	;TURN IT OFF>
	INPUT CTL,0
	STATO CTL,760000	;CHECK FOR ERROR OR EOF
	JRST RPGMTD	;ALL OK
OFRPG:	IFE TEMPSW,<TRZ FL2,RPGFLG!RPGALT!SUPOFL!CBFUS	;RESET FLAG>
	IFN TEMPSW,<TRZ FL2,RPGFLG!RPGALT!SUPOFL!CBFUS!TEMPFL>
	RELEASE CTL,0	;GET RID OF CHANEL
	SKIPE LIBUF
	POPJ P,		;NOT COMMAND, RETURN
	OUTSTR [ASCIZ /
/]
	MOVEI CS,[ASCIZ /*/]
	OUTSTR (CS)
	MOVEM CS,LIBUF
	POPJ P,		;AND RETURN

LINNUM:	CAMN C,PGMK	;PAGES ARE SPECIAL
	JRST	[AOS RPGPG	;NEXT PAGE
		IBP RPGBUF+1
		IBP RPGBUF+1
		MOVNI C,7
		JRST RPGO2]
	MOVEM C,RPGLN	;SAVE LINE NUMBER
	MOVNI C,5	;SKIP TAB AND NUMBER
RPGO2:	ADDM C,RPGBUF+2
	AOS RPGBUF+1
	JRST GNCHD	;TRY AGAIN

GNCH:	SOSG GNCCNT#	;ARE THERE ANY MORE LEFT?
	JRST GNCNL	;NO
	ILDB C,GNCPTR#
	JUMPE C,GNCH
	MOVE CS,CTBL(C)	;GET CHARACTER BITS
	POPJ P,

GNCNL:	SKIPE C,GNCLST#	;IS THERE A SPECIAL CHR (ALTMODE)
	JRST GNCLD	;YES, RETURN IT
	MOVEM 17,GCLSAV+17	;SAVE ACS
	MOVEI 17,GCLSAV
	BLT 17,GCLSAV+16
	MOVE 17,GCLSAV+17
	PUSHJ P,INPLIN
	 TDZA T1,T1	;FOR NON-SKIP RETURN, CLEAR COUNT
	TRZE FL2,STOPI	;OR NON-SKIP WITH STOPI ON
	JRST	[MOVEI T2,200
		MOVEM T2,GNCLST	;SAVE SPECIAL CHR
		JRST .+1]
	IMULI T1,5
	MOVEM T1,GNCCNT
	MOVEM FL2,GCLSAV+FL2
	MOVEM FL,GCLSAV+FL	;FLAG REGISTERS STAY CHANGED
	MOVSI 17,GCLSAV
	BLT 17,17	;RESTORE ACS
	SETZM LIBUF	;CLEAR PROMPT IN CASE CALLED AGAIN
	MOVE C,[POINT 7,LIBUF+1,6]
	MOVEM C,GNCPTR
	SKIPN GNCLST	;IN CASE OF ALTMODE
	JRST GNCH	;GO
GNCHL1:	ILDB CS,C	;WE MUST REMOVE THE CRLF
	CAIE CS,15
	JRST GNCHL1
	MOVEI CS,0
	DPB CS,C
	IDPB CS,C
	JRST GNCH

ARRAY GCLSAV[20]	;SAVE ACS

GNCHGT:MOVEM T1,LIBUF	;CALLED TO START PROCESS. PROMPT IN T1
	SETZM TIBUF+2	;FORCE LINE READ
	SETZM GNCCNT
	SETZM SAVCHR
	SETZM GNCLST
	POPJ P,

GNCLD:	SETZM GNCLST
	MOVE CS,CTBL(C)
	POPJ P,

SCAN:	TRZ FL,TERMF!NUMF!IDF	;RESET FLAGS
	SKIPE CS,SAVCHR	;CHECK TO SEE IF WE LEFT ONE LAST TIME
	JRST SL1	;YES, IT MUST BE A DELIMITER
SL10:	PUSHJ P,GNCH	;GET A CHR
	JUMPE CS,SL10	;CHECK FOR TAB, SPACE, AND IGNORE
	JUMPL CS,SL1	;SPECIAL CHARACTER?
	MOVE T3,[POINT 6,ACCUM]	;SET TO SAVE IDENT
	SETZM ACCUM
	TLNE CS,SNUMF_16	;CHECK FOR NUMBER
	JRST SNUM1	;AND GO RACING OFF TO NUMBER ROUTINE
SL2P:	TRO FL,IDF	;IT IS AN IDENT
SL2:	TLNE T3,770000	;HAVE WE STORED ENOUGH?
	IDPB CS,T3	;NO, STORE ANOTHER (RH OF CHR TABLE HAS SIXBIT)
	PUSHJ P,GNCH	;CONTINUE
	JUMPG CS,SL2	;CHECK FOR ANOTHER NUMBER OR LETTER
SOK1:	MOVEM CS,SAVCHR	;SAVE THE CHARACTER (MUST BE A SPECIAL CHR)
	MOVEI C,0	;ZERO IN C FOR NUMBERS AND IDNETS
	POPJ P,

SL1:	HRRZ C,CS	;FOR SPECIAL CHARACTERS, RETURN RH OF CTABLE
	TLNE CS,TERM_16	;CHECK FOR TERMINATOR
	TRO FL,TERMF	;AND SET FLAG
	ANDI C,377	;GET RID OF EXTRA BITS
	SETZM SAVCHR	;ZERO SAVCHR FOR LATER
	CAIE C,"."	;CHECK FOR .
	POPJ P,		;NO RETURN
	MOVE T1,CLN	;SET UP FOR CURRENT LINE AND PAGE
	MOVE T2,CPGL
	TRO FL,NUMF	;CALL IT A NUMBER
	POPJ P,

SNUM1:	SETZB T1,T2	;SET NUMBER ACCUMS TO 0
SN1A:	TLNE T3,770000	;WILL STORE THE SIXBIT FOR FILE NAMES
	IDPB CS,T3	;BUT ONLY IF LESS THAN 6
SN1B:	LSH T1,7	;ACCUMULATE ASCII IN T1
	IOR T1,C
	IMULI T2,^D10	;DECIMAL IN T2
	ADDI T2,-"0"(C)
	PUSHJ P,GNCH	;GET NEXT AND CONTINUE
	JUMPLE CS,SOK2	;CHECK FOR END OF NUMBER

	TLNN CS,SNUMF_16	;CHECK FOR NUMBER
	JRST SL2P	;MUST BE AN IDENT
	JRST SN1A	;CONTINUE SCANNING NUMBER
SOK2:	TRO FL,NUMF	;IT WAS A NUMBER
	LSH T1,1	;CONVERT TO LINE NUMBER
	IOR T1,[<ASCII /00000/>+1]
	JRST SOK1	;SAVE DELIM AND RETURN
SUBTTL PLACE FINDING ROUTINES

;FIND-- PAGE TO FIND IS IN DPG. NUMBER TO FIND IS IN SINDEX.
;LOADS T1 WITH THE LINE NUMBER FOUND
;IF NO EXACT MATCH WILL FIND NEXT HIGHER NUMBER OR A PAGE MARK.

FIND:	MOVE T1,DPG	;GET THE DESIRED PAGE
	CAMLE T1,CPG	;IS IT GREATER THAN THE PAGE WE ARE ON
	JRST FWDPG	;YES, SEARCH FORWARD FOR PAGE
	CAML T1,CPG	;IS IT THE SAME AS THE CURRENT PAGE?
	JRST FEQPG	;YES, JUST SEARCH FOR LINE NUMER
	SUBI PNTR,1	;BACK UP A LITTLE (IN CASE POINTED AT PAGE MARK)
FIND1:	SKIPN T1,(PNTR)	;GET THE WORD, BUT WATCH FOR START OF BUFFER
	JRST FINDHD	;WILL HAVE TO FINISH COPY AND START OVER
	CAME T1,PGMK	;IS IT A PAGE MARK?
	SOJA PNTR,FIND1	;CONTINUE SEARCHING
	SOS T1,CPG	;DECREASE THE PAGE WE ARE NOW ON
	CAME T1,DPG	;IS IT THE RIGHT ONE YET?
	SOJA PNTR,FIND1	;NO, KEEP SEARCHING
	SUBI PNTR,1	;BACK OVER PAGE MARK
FIND2:	SKIPN T1,(PNTR)	;PICK UP WORD AND CHECK FOR START OF BUFFER
	JRST FINDHD	;HAVE TO DO IT THE HARD WAY
	TRNN T1,1	;IS IT A SEQUENCE NUMBER?
	SOJA PNTR,FIND2	;NO, CONTINUE SEARCH
	CAMN T1,PGMK	;IS IT PERHAPS A PAGE MARK?
	AOJA PNTR,FNDFW1	;YES, GO FORWARD A LINE AND RETURN IT
	CAMGE SINDEX,T1	;IS THE LINE WE WANT GREATER OR EQUAL TO THIS ONE
	SOJA PNTR,FIND2	;NO, KEEP UP THE GOOD WORK
	CAMN SINDEX,T1	;EXACT MATCH?
	POPJ P,		;YES, RETURN
	JRST FNDFW1	;GO FORWARD A LINE TO GET NEXT LARGER
FEQPG:	SKIPN T1,(PNTR)	;CHECK THE WORD WE ARE POINTING AT
	JRST FNDFOO	;MUST BE POINTING AT END OF BUFFER OR BUFFER EMPTY
	CAMN T1,PGMK	;IS IT A PAGE MARK?
	SOJA PNTR,FIND2	;MUST BE ONE AT END OF PAGE, SEARCH BACKWARDS
FEQPG1:	CAMGE SINDEX,T1	;COMPARE TO LINE WE WANT
	JRST FIND2	;WANT A SMALLER ONE, SEARCH BACK
	JRST FNDFW1	;SEARCH FORWARD

FWDPG:	SKIPN T1,(PNTR)	;SEARCH FORWARD FOR PAGE
	JRST FNXRCP	;END OF BUFFER, GET A NEW ONE
	CAME T1,PGMK	;FOUND A PAGE MARK?
	AOJA PNTR,FWDPG	;NO, CONTINUE
	AOS T1,CPG	;ADVANCE CURRENT PAGE COUNT
	CAME T1,DPG	;AND SEE IF WE ARE THER YET
	AOJA PNTR,FWDPG	;NUTS, LOOK SOME MORE
	ADDI PNTR,1	;ADVANCE BEYOND PAGE MARK
FNDFW1:
FIND3:	SKIPN T1,(PNTR)	;LOOK FOR LINE
	JRST FNXRC	;END OF RECORD, GET A NEW ONE
	TRNN T1,1
	AOJA PNTR,FIND3	;NOT LINE NUMBER
	CAMN T1,PGMK	;PAGE MARK
	POPJ P,		;RETURN IT, IT IS BEST MATCH WE CAN FIND
	CAMLE SINDEX,T1	;ARE WE THERE YET?
	AOJA PNTR,FIND3	;NO, CONTINUE SEARCH
	POPJ P,		;YES, FINALLY

FNDFOO:	CAMN PNTR,BUFP	;ARE WE POINTED TO START OF BUFFER
	JRST FDFOO1	;YES, BUFFER MUST BE EMPTY
	SUBI PNTR,1	;NO, MUST HAVE BEEN AT END OF BUFFER
FDFOO2:	SKIPN T1,(PNTR)	;GET WORD
	ERROR ICN	;MUST BE CONFUSED, THERE SHOULD BE A LINE NUMBER
	TRNN T1,1	;SEARCH FOR LINE NUMBER
	SOJA PNTR,FDFOO2	;KKEP LOOKING
	CAMN T1,PGMK	;IS IT A PAGE MARK
	AOJA PNTR,FNDFW1	;YES, SEARCH FORWARD
	JRST FEQPG1	;GO DO SOMETHING WITH IT
FDFOO1:	TRNE FL,EOF2	;ARE WE AT END OF FILE?
	JRST FINDHD	;WILL HAVE TO TRY FROM START
	PUSHJ P,GETN	;GET THE NEXT BUFFER
	JRST FEQPG

FNXRCP:	TRNE FL,EOF2	;AR WE AT END OF FILE
	JRST FNX1	;YES, JUST RESET BGPG AND LOOK AGAIN
	PUSHJ P,GETN	;GET THE NEXT BUFFER
	JRST FWDPG	;AND CONTINUE SEARCH
FNX1:	MOVE T1,CPG	;SET BGPG TO CURRENT PAGE
	MOVEM T1,BGPG
	TRO FL,BGSN	;RECORD THAT LARGEST PAGE SEEN
	MOVEI T1,0	;RETURN 0 FOR EOF
	POPJ P,

FNXRC:	TRNE FL,EOF2	;ARE WE AT END OF FILE
	JRST FNX1	;YES, GIVE HIM BACK THE 0
	PUSHJ P,GETN	;NO, GET THE NEXT BUFFER
	JRST FIND3	;AND CONTINUE LOOKING FOR LINE

FINDHD:	TRNE FL,BOF	;ARE WE AT THE START OF THE FILE
	JRST FNDFST	;YES, CAN NOT GO BACK JUST GIVE FIRST LINE OF FILE
	MOVE PNTR,BUFP	;IN CASE WE RUN OUT OF DSK POINT AT BUFFER
	TRNE FL,READOF	;DON'T BOTHER IN READ ONLY MODE
	JRST READIT	;SKIP THIS STUFF IF ONLY READING
	PUSHJ P,OCOMPL	;COMPLETE THE COPY
READIT:	TLNE FL,COPFIL	;IS THIS A COPY
	JRST FINDH4	;YES, DON'T RELEASE IN AND OUT
	RELEASE IN,0	;RELEASE IO DEVICES
	RELEASE OUT,0
	INIT IN,14	;AND GET THEM BACK
	SIXBIT /DSK/
	IBUF
	JRST NODSK	;WHERE DID THE DISK GO, IT WAS HARE BEFORE
	INIT OUT,14
	SIXBIT /DSK/
	XWD OBUF,0
	JRST NODSK
	MOVE T1,BUFHD	;SET UP JOBFF TO ESTABLISH BUFFERS
	MOVEM T1,JOBFF
	INBUF IN,2
	OUTBUF OUT,2
	TRNE FL,READOF	;ARE WE IN READ ONLY MODE?
	JRST FINDH2	;SET TO POINT TO ORIGINAL NAME AGAIN
	MOVE T1,EDNAM
	MOVEM T1,NAMO
	MOVEM T1,NAMI
	MOVSI T1,'TMP'	;AND EXTENSION
	MOVEM T1,NAMO+1
	MOVEM T1,NAMI+1
	SETZM NAMO+2
	SETZM NAMO+3
	SETZM NAMI+3
	LOOKUP IN,NAMI	;GET THAT FILE
	JRST EDFLIN	;BUT IT JUST PUT ONE THERE
	ENTER OUT,NAMO
	JRST EDFLIN	;SOME OTHER BASTARD MUST BE USING IT

FINDH3:	SETZM WC	;WC STARTS OUT 0
	TRZ FL,EOF!EOF2	;NOT AT EOF YET
	TRO FL,BOF	;BUT ARE AT START OF FILE
	TLO FL,FSTOPF	;SET FOR FIRST OP
	TLZ FL,TECOF	;BUT NOT TECO
	MOVEI T1,1	;SET UP INPUT PAGE IN CASE OF
	MOVEM T1,INPG	;ORDER OR LTL ERRORS ON INPUT
	SETZM SVWD
	SETZM OLDLIN	;USED IN CHECKING INPUT ORDER OF LINES
	PUSHJ P,FILLBF	;FILL UP THE BUFFER
	MOVEI T1,1
	MOVEM T1,CPG	;START ON PAGE 1
	JRST FIND	;AND GO LOOKING

FNDFST:	MOVE T1,@BUFP	;GET FIRST WORD
FNDFS1:	MOVE PNTR,BUFP	;SET TO START OF WORLD
	POPJ P,		;AND DISMISS

FINDH4:	RELEASE ALTDV,0	;LET GO OF ALTERNATE DEVICE
	INIT ALTDV,14
	SIXBIT /DSK/
	ALTBF
	JRST NODSK
	MOVE T1,SVJRL2
	MOVEM T1,JOBFF
	INBUF ALTDV,2	;ALL SET UP
FINDH2:	MOVE T1,ORGNAM	;SET TO ORIGINAL NAME
	MOVEM T1,NAMI
	MOVE T1,ORGEXT
	MOVEM T1,NAMI+1
	MOVE T1,ORGPPN	;ALSO SAME PPN
	MOVEM T1,NAMI+3
	TLNE FL,COPFIL
	JRST FINDH5
	LOOKUP IN,NAMI
	JRST NOFIL	;NO FKLE THERE START OVER
	JRST FINDH3	;GO ON
FINDH5:	LOOKUP ALTDV,NAMI
	JRST NOFIL
	JRST FINDH3


;FIND THE NEXT LINE, PAGE MARK, ETC.

FINDN1:	SKIPN T1,(PNTR)
	JRST FINDN2
	TRNN T1,1
FINDN:	AOJA PNTR,FINDN1
	POPJ P,		;RETURN THE LINE

FINDN2:	TRNE FL,EOF2	;IS IT EOF?
	POPJ P,		;YES, RETURN PRESENT T1 (0 FOR EOF)
	PUSHJ P,GETN	;GET NEXFER
	JRST FINDN1	;GO LOOK SOME MORE

FINDZ1:	SKIPN T1,(PNTR)	;AS FINDN BUT STOPS AT END OF RECORD
	POPJ P,
	TRNN T1,1	;LINE NUMBER?
FINDZ:	AOJA PNTR,FINDZ1
	POPJ P,

;FIND THE PREVIOUS LINE

FINDB1:	SKIPN T1,(PNTR)	;WATCH OUT FOR START OF BUFFER
	JRST FINDB2
	TRNN T1,1	;LINE NUMBER?
FINDB:	SOJA PNTR,FINDB1	;TRY AGAIN
	CAMN T1,PGMK	;TEST FOR PAGE MARK
	SOS CPG		;NOW ON PREVIOUS PAGE
	POPJ P,		;RETURN LINE NUMBER

FINDB2:	TRNE FL,BOF	;AT START OF FILE?
	JRST FNDFS1	;YES, GO GET THE FIRST LINE OF FILE
	MOVE T1,1(PNTR)	;GET THE FIRST LINE ON THIS PAGE
	TRNN T1,1	;MAKE SURE THERE IS ONE THERE
	ERROR ICN	;NO, WE ARE CONFUSED
	PUSH P,SINDEX	;SAVE (CALLER MAY NEED IT)
	MOVE SINDEX,T1
	PUSHJ P,FINDHD	;THIS WILL WORK AND WE WILL HAVE A LITTLE SPACE BEFORE
	POP P,SINDEX	;GET THIS BACK
	SOJA PNTR,FINDB1	;GO LOOK BACK AGAIN
SUBTTL BUFFER HANDLING ROUTINES

OCOMPL:	MOVE T1,WC	;GET CURRENT WORD COUNT
	ADD T1,BUFP	;TURN IT INTO A POINTER
	PUSHJ P,DUMP	;DUMP DUMPS BUFFER FROM BUFP TO (T1)
	SETZM WC	;TELL IT NO CURRENT WORD COUNT
	TRNE FL,EOF2	;ALL DONE?
	POPJ P,
	PUSHJ P,FILLBF	;FILL UP INPUT BUFFER
	JRST OCOMPL	;AND GO DUMP THIS ONE TOO

GETWD:	TRNE FL,EOF
	JRST RTEOF	;RETURN 0 IF EOF
	TLNE FL,COPFIL	;IN A COPY, WE GET FROM SOMEWHERE ELSE
	JRST COPGET
	SOSG IBUF+2	;CHECK FOR MORE WORDS
	JRST GETDO	;NO, GET SOME BY INPUT
GETWD1:	ILDB T3,IBUF+1	;PICK UP A WORD
	JUMPE T3,GETWD	;IGNORE 0 WORDS
	POPJ P,		;RETURN
GETDO:	INPUT IN,0
	STATO IN,760000	;CHECK FOR ERRORS AND EOF
	JRST GETWD1
	STATZ IN,740000	;ERROR?
	ERROR DIE	;YES, INPUT ERROR
	TRO FL,EOF	;NO, MUST BE EOF
RTEOF:	MOVEI T3,0	;RETURN 0
	POPJ P,

OUTWD:	SOSG OBUF+2	;CHECK WORDS LEFT
	PUSHJ P,OUTDO
OUTWD1:	IDPB T3,OBUF+1	;OUTPUT IT
	POPJ P,		;AND RETURN
OUTDO:	OUTPUT OUT,0
	STATO OUT,760000	;CHECK FOR ERRORS
	POPJ P,
	ERROR DDE	;YES, GIVE ERROR AND BOMB OUT

DUMP:	MOVE T2,BUFP	;DUMP BUFFER FROM BUFP TO (T1)
	CAMGE T2,T1	;CHECK TO SEE IF WE ARE DUMPINF ANYTHING
	TRZ FL,BOF	;IF SO TURN OFF BOF
	TRNN FL,READOF	;RETURN IF READ ONLY MODE
DUMP1:	CAML T2,T1	;MORE TO DO?
	POPJ P,	;NO, RETURN
	PUSH P,T1	;SAVE FOR LATER
	MOVEI T1,1(T2)	;FIND END OF THIS LINE
DUMP3:	SKIPN T3,(T1)	;ANY OLD END WILL DO
	JRST DUMP2
	TRNN T3,1	;SUCH AS A LINE NUMBER
	AOJA T1,DUMP3	;NOT YET
DUMP2:	SUB T1,T2	;GET LENGTH
	CAML T1,OBUF+2	;WILL IT FIT?
	PUSHJ P,OUTDO	;NO, DUMP CURRENT BUFFER
DUMP4:	MOVE T3,(T2)	;PICK UP WORD
	PUSHJ P,OUTWD
	ADDI T2,1	;ADVANCE POINTER
	SOJG T1,DUMP4	;AND CHECK COUNT
	POP P,T1
	JRST DUMP1	;GO CHECK FOR END

GETN:	MOVE T1,WC	;GET THE NEXT BUFFER. FIND CURRENT WORD COUNT
	CAMGE T1,HLFWC	;GREATER THAN HALF OF MAX POSSIBLE?
	JRST FILLBF	;NO, JUST REFILL BUFFER
	ASH T1,-1	;YES, TAKE HALF OF IT
	ADD T1,BUFP	;CONVERT TO POINTER
GETN1:	SKIPN T2,(T1)	;LOOK FOR A WORD BOUNDARY
	JRST NOWFL	;WE ARE HERE?
	TRNN T2,1	;SEQUENCE NUMBER?
	SOJA T1,GETN1
NOWFL:	PUSHJ P,DUMP	;DUMP IT
	MOVE T2,T1	;COPY POINTER
	SUB T2,BUFP	;AND FIND OUT HOW MANY DUMPED
	SUB PNTR,T2	;ADJUST POINTER
	EXCH T2,WC	;CALC NEW WORD COUNT
	SUBB T2,WC
	ADD T2,BUFP	;GET POINTER TO END OF BUFFER
	HRLS T1		;SET UP BLT
	HRR T1,BUFP
	BLT T1,(T2)
	JRST FILLBF	;AND FINISH FILLIN BUFFER

FILLBF:	MOVE T1,WC	;GET WORD COUNT
	ADD T1,BUFP	;AND CONVERT TO POINTER TO END OF BUFFER
FILBF3:	CAML T1,FILPT	;FULL ENOUGH?
	POPJ P,		;YES, RETURN
	TLNE FL,TECOF	;SPECIAL READING FOR TECO FILES
	JRST RDTECO
	HRLI T1,-MXWPL-2	;GET A COUNT FOR MAX LINE SIZE
	SKIPN T3,SVWD	;SEE IF THERE IS A WORD LEFT FROM LAST TIME
	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,SNEOF	;MUST BE EOF
	TLZE FL,FSTOPF	;IF FIRST OP
	JRST CKTECO	;CHECK FOR TECO FILE
NOTECO:	MOVEM T3,SVWD2#	;SAVE FOR SEQUENCE CHECK
	JRST FILBF4	;GO PUT IT AWAY
FILBF1:	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,FILBF2	;0 WORD MUST BE EOF
	TRNE T3,1	;CHECK FOR SEQNUM
	JRST FILBF2	;YES, FINISH PUTTING IT IN
FILBF4:	MOVEM T3,(T1)	;PUT IN THIS WORD
	AOS WC		;AND ADVANCE WORD COUNT
	AOBJN T1,FILBF1	;ADVANCE POINTER AND CHECK COUNT
	JRST INLTL	;LINE IS TOO LONG
FILBF2:	MOVEM T3,SVWD	;SAVE THIS WORD
FILBF0:	SETZM (T1)	;MAKE SURE OF A ZERO WORD
	HRRZS T1	;ELIMINATE COUNT INFO
	MOVE T3,SVWD2	;CHECK ON ORDER OF INPUT LINES
	CAMN T3,PGMK	;WAS IT A PAGE MARK?
	SETZM OLDLIN	;RESET LINE LAST INPUT
	CAMG T3,OLDLIN	;CHECK FOR CORRECT ORDER
	JRST OUTOFO	;LINES ARE OUT OF ORDER
FILBF5:	MOVEM T3,OLDLIN	;SAVE FOR LATER
	CAMN T3,PGMK	;ADVANCE INPUT PAGE
	AOS INPG
	SKIPE SVWD	;CHECK TO SEE IF WAS EOF
	JRST FILBF3	;AND TRY FOR MORE
SNEOF:	SETZM (T1)	;MAKE SURE OF ZERO WORD
	TRO FL,EOF2	;SET EOF FLAG
	MOVE T1,INPG	;GET INPUT PAGE
	MOVEM T1,BGPG	;AND SET LARGEST PAGE
	TRO FL,BGSN
	SETZM SVWD	;ALSO ZERO EXTRA WORD
	POPJ P,		;AND RETURN

INLTL:	PUSHJ P,GETWD	;FIND THE END OF THE LINE ON INPUT
	JUMPE T3,INLTL2	;THIS IS IT
	TRNN T3,1	;OR MAYBE THIS
	JRST INLTL	;KEEP LOOKING
INLTL2:	MOVEM T3,SVWD	;SAVE IT
	PUSH P,T1	;SAVE POINTER TO END OF IT
	SUBI T1,2	;LAST PART THAT IS IN THE LINE
	MOVEI T2,<BYTE (21)0(7)15,12>	;A CRLF
	DPB T2,[POINT 15,(T1),35]	;MAKE SURE IT ENDS PROPERLY
INLTL1:	SKIPN T2,(T1)	;NOW LOOK FOR THE START OF IT
	ERROR ICN	;SOMETHING HAS GONE WRONG, THERE IS NO LINE #
	TRNN T2,1	;START?
	SOJA T1,INLTL1	;NO, TRY AGAIN
	MOVE T2,INPG	;PRINT HIM THE CURRENT PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR LTL	;AND THE ERROR MESSAGE
	POP P,T1	;RESTORE POINTER TO END
	SOS WC	;GET WORD COUNT CORRECTED
	SOJA T1,FILBF0	;AND CONTINUE FILL

OUTOFO:	PUSH P,T1	;SAVE THE POINTER
	PUSH P,T3	;SAVE T3 ALSO
	SUBI T1,1	;GET BACK INTO LINE
OUTOF1:	SKIPN T2,(T1)	;LOOK FOR START OF LINE
	ERROR ICN	;HORRIBLE CONFUSION
	TRNN T2,1	;CHECK FOR SEQ NUM
	SOJA T1,OUTOF1	;NOPE, TRY SOME MORE
	MOVE T2,INPG	;PRINT HIM THE PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR ORDER	;GIVE HIM SOMETHING TO THINK ABOUT
	POP P,T3	;RESTORE
	POP P,T1	;GET SET TO GO ON
	JRST FILBF5	;GO

CKTECO:	TRNE T3,1	;CHECK FOR A LINE NUMBER
	JRST NOTECO	;NO ITS NOT A TECO FILE
	TLO FL,TECOF	;SET WARNING FLAG
	TLNE FL,COPFIL	;IS IT ANOTHER FILE?
	JRST CKTEC2	;SPECIAL CHECK
	SETSTS IN,0	;SET FOR CHAR AT A TIME INPUT
	MOVSI T3,(<POINT 7,0>)
	HLLM T3,IBUF+1	;SET INPUT BYTE POINTER
	MOVEI T3,5	;COMVERT TO CHRS
	IMULM T3,IBUF+2
	AOS IBUF+2	;AND COMPENSATE FOR THINKING WE TOOK ONE

RDTECO:HRRZM T1,TMPT1#	;SAVE THIS FOR A WHILE
	MOVEI T3,1(T1)	;ZERO OUT A FEW WORDS
	HRL T3,T1
	SETZM (T1)
	BLT T3,MXWPL(T1)
	ADDI T1,1	;THIS IS WHERE CHRS SHOULD BE PUT
	PUSH P,T1	;SAVE
	TLNE FL2,KEPSQF	;IF KEEPING SEQ NUMBERS
	JRST RDSEQ	;GO WORK ON THEM
TBRST:	MOVE T1,SVWD	;LAST LINE NUMBER
	MOVE T2,[<ASCII /00010/>+1]
	PUSHJ P,ASCIAD
	CAMGE T1,[<ASCII /00010/>+1]	;CHECK WAR
	JRST INSPG1	;FORCE PAGE INSERT
BKSEQ:	MOVEM T1,SVWD	;SAVE FOR LATER
	MOVEM T1,SVWD2	;AND FOR ORDER CHECK
	EXCH T1,(P)	;GET OLD T1 BACK AND SAVE NUMBER
	MOVSI T2,(<BYTE (7) 11>)	;PUT IN A TAB
	MOVEM T2,(T1)
	MOVEI T2,MXWPL*5-2	;COUNT
	HRLI T1,(<POINT 7,0,6>)
	TLNE FL2,KEPSQF	;IF IN THAT MODE
	JRST LP1A	;WE KNOW WE HAVE STARTED A LINE
LINL1:	PUSHJ P,GETWD	;NEXT CHR
	CAIN T3,15
	JRST LINL1	;IGNORE RETURNS
	CAIN T3,14
	JRST IPGMK	;GO PUT IN A PAGE MARK
	JUMPE T3,EOF1	;MUST BE END OF FILE
LP1A:	POP P,-1(T1)	;PUT NUMBER IN PROPER PLACE
	JRST LP1	;AND READ MORE OF LINE
CLP:	PUSHJ P,GETWD
LP1:	CAIN T3,15	;IGNORE RETURNS
	JRST CLP
	CAIE T3,0	;FOR EOF
	CAIN T3,12	;OR LINE FEED
	JRST LINFD	;GO PUT IN RETURN LINE FEED
	IDPB T3,T1	;ELSE DEPOSTI
	SOJG T2,CLP	;HAVE WE RUN OUT
	ADD T1,[XWD 700,0]	;BACK UP POINTER
	TLZ FL,TECOF	;USE THE ABSENCE AS A FLAG
	PUSHJ P,GETWD
	CAIE T3,12
	JUMPN T3,.-2
LINFD:	MOVEI T3,15
	IDPB T3,T1
	MOVEI T3,12
	IDPB T3,T1
	MOVEI T1,1(T1)
	MOVE T3,T1
	SUB T3,TMPT1	;GET COUNT
	ADDM T3,WC
	TLOE FL,TECOF	;IF OFF WE HAD A LTL ERR
	JRST FILBF0	;THIS WILL FINISH UP
	PUSH P,T1	;SET UP FOR LTL CODE
	AOS WC
	AOS (P)
	SOJA T1,INLTL1
RDSQPG:	REPEAT 2,<PUSHJ P,GETWD>	;BYPASS PAGE MARK STUFF
INSPG1:	POP P,T1
	SKIPA
IPGMK:	POP P,T2	;GET RID OF IT
	MOVEI T3,1	;SO IT WILL NOT BE EOF
	MOVEM T3,SVWD	;SO WE START OVER
	MOVE T3,PGMK
	MOVEM T3,SVWD2
	MOVEM T3,-1(T1)
	MOVEI T2,2
	ADDM T2,WC
	MOVE T3,[BYTE (7) 15,15,14]
	MOVEM T3,(T1)
	AOJA T1,FILBF0	;DONE
EOF1:	POP P,T2	;CLEAR STACK
	SOJA T1,SNEOF
RDSEQ:	MOVE T1,["0000"]	;SET TO READ SEQUENCE NUMBER
RDSEQ1:	PUSHJ P,GETWD
	CAIN T3," "
	JRST RDPGSQ	;GO WORRY ABOUT PAGE MARKS
	CAIG T3,"9"	;CHECK FOR DIGIT
	CAIGE T3,"0"
	JRST SKPTB	;NO
	LSH T1,7	;MOVE OTHERS OVER
	IOR T1,T3	;AND PUT IN THE NEW ONE
	JRST RDSEQ1	;BACK FOR MORE
SKPTB:	CAME T1,["0000"]	;HAVE WE PUT ANY IN?
	JRST ISNUM	;YES, A NUMBER WAS SEEN
	TLZ FL2,KEPSQF	;FORGET IT
	JRST TBRST	;GET BACK IN THE SWING OF THINGS
ISNUM:	LSH T1,1
	IORI T1,1	;TURN INTO A SEQ NUM
	CAIN T3,11	;LOOK AT EXTRA CHARACTER
	PUSHJ P,GETWD	;IF TAB TAKE AS THE TAB IN SEQ NUM
	JRST BKSEQ	;GO ON WITH THE LINE
RDPGSQ:	CAME T1,["0000"]	;ANYTHING SEEN YET?
	JRST SKPTB	;YES, NOT A PAGE MARK
RDPG1:	LSH T1,7
	IOR T1,T3
	PUSHJ P,GETWD
	CAIN T3," "
	JRST RDPG1
	LSH T1,1
	IORI T1,1
	CAME T1,PGMK
	JRST TBRST	;UGH
	JRST RDSQPG	;ALL WELL AND GOOD
SUBTTL RANGE SPECIFIER READERS

;ROUTINE TO GET ONE LINE NUMBER FROM INPUT STREAM. HANDLES + AND -

GETLS:	PUSHJ P,SCAN
GETL:	TRZ FL,LINSN!ADDL!SUBL
	TRZ FL2,STARF
	CAIN C,"*"
	JRST DOLST
	TRZN FL,NUMF
	POPJ P,		;SCAN DID NOT SEE A NUMBER RETURN (CALLER CAN GIVER ERR)
	MOVEM T1,HILN	;SAVE THE NUMBER HERE
GETL1:	TRO FL,LINSN	;SET A FLAG TO SAY WE SAW THE LINE
	PUSHJ P,SCAN	;SCAN FOR + OR -
	CAIN C,"+"
	JRST ADDNUM
	CAIE C,"-"
	POPJ P,		;NEITHER
	TROA FL,SUBL	;SET SUBTRACT FLAG
ADDNUM:	TRO FL,ADDL	;SET ADD FLAG
	PUSHJ P,SCAN	;SCAN ANOTHER
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;ANYTHING ELSE IS ILLEGAL
	MOVEM T2,SVINC	;SAVE IT
	JRST SCAN	;RETURN AFTER SCANNING ONE MORE
DOLST:	TRO FL2,STARF
	JRST GETL1

;ROUTINE TO RESOLVE THE + AND - IN THE LINE NUMBER. WE MUST WAIT
;UNTIL THE PAGE HAS BEEN DEFINED BEFORE DOING THIS

ADDSUB:	MOVE SINDEX,HILN	;GET THE NUMBER
	MOVE T1,HIPG	;GET THE REQUIRED PAGE
	MOVEM T1,DPG	;AND SET IT AS THE DESIRED ONE
	TRNN FL2,STARF
	JRST DOAS
	MOVE SINDEX,[<ASCII /99999/>+1]	;FIND A BIG LINE
	PUSHJ P,FIND
	CAME T1,[<ASCII /99999/>+1]	;IF ITS THERE ITS LAST
	PUSHJ P,FINDB		;ELSE BACK UP
	SKIPE T1		;CHECK TO SEE IF EMPTY PAGE
	CAMN T1,PGMK
	SKIPA
	MOVE SINDEX,T1	;OK, USE ONE FOUND, ELSE LEAVE BIG
DOAS:	TRZE FL,ADDL	;DID WE WANT TO ADD?
	JRST ADLIN	;YES, GO ADD
	TRZN FL,SUBL	;OR SUBTRACT?
CPOPJ:	POPJ P,	;NO, RETURN
	PUSHJ P,FIND	;GET THE DESIRED LINE
SUBL1:	SOSGE SVINC	;DO WE WANT TO GO BACK STILL FARTHER
	POPJ P,		;NO, ALL DONE
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	SKIPE T1	;0 MUST BE AT START OF BUFFER, QUIT
	CAMN T1,PGMK	;WAS IT A PAGE MARK?
	POPJ P,		;YES, AS FAR AS WE GO, SINDEX HAS CORRECT NUMBER
	MOVE SINDEX,T1	;THIS WILL DO
	JRST SUBL1	;GO TRY FOR MORE
ADLIN:	PUSHJ P,FIND	;GET DESIRED LINE
	CAME T1,PGMK	;WAS IT A PAGE MARK?
	JUMPN T1,ADLIN1	;OR 0 (I.E. END OF FILE)
	POPJ P,		;RETURN WITH ORIGINAL NUMBER
ADLIN1:	CAME T1,HILN	;SEE IF AN EXACT MATCH
	SOS SVINC	;IF NO, ALREADY ARE +1
	MOVE SINDEX,T1	;GET THE WORD WE HAVE FOUND
ADLIN2:	SOSGE SVINC	;NEED TO GO FURTHER
	POPJ P,		;NO, RETURN RESULTS
	PUSHJ P,FINDN	;GET THE NEXT LINE IN SEQUENCE
	CAME T1,PGMK	;PAGE MARK?
	JUMPN T1,.+2	;OR EOF
	POPJ P,		;YES, RETURN
	MOVE SINDEX,T1	;ACCEPT NEW NUMBER
	JRST ADLIN2	;AND LOOK FOR MORE

;ROUTINE GETS A FULL SEQ NUMBER OF FORM A/B

GETLAS:	PUSHJ P,SCAN
GETLA:	PUSHJ P,GETL	;GET THE LINE NUMBER PART
	TRZ FL,PGSN	;NO PAGE SEEN YET
	CAIE C,"/"	;IS THIS A PAGE COMMING?
	JRST NOPG	;NO, A LINE NUMBER AT MOST
	PUSHJ P,SCAN	;YES, GET THE PAGE NUMBER
	CAIN C,"*"	;HANDLE /*
	JRST	[PUSHJ P,GETBIG
		MOVEM T1,T2	;FOR GETSPG
		JRST GETSPG]	;SCAN FOR + AND -
	SKIPLE T2	;NUMBERS < OR = 0 LOSE
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;LOSE LOSE
GETSPG:	TRO FL,PGSN	;YEP, WE SAW IT
	MOVEM T2,HIPG	;SAVE THAT NUMBER
	PUSHJ P,SCAN	;CHECK FOR + OR -
	CAIN C,"+"
	JRST PGPLS
	CAIE C,"-"
	JRST NOPG	;NO, GO DO ADSUB ON LINE NUMBER
	PUSHJ P,SCAN	;GET THE NUMBER
	TRZN FL,NUMF	;MUST BE A NUMBER
	NERROR ILC
	MOVE T1,HIPG
	SUB T1,T2
	MOVEM T1,HIPG	;FILL IN NUMBER
NOPGA:	PUSHJ P,SCAN	;SCAN PAST NUMBER
NOPG:	TRNN FL,LINSN!PGSN	;DID WE SEE A LINE OR A PAGE?
	NERROR ILC	;NO, SOMETHING IS WRONG
	PUSH P,T1	;SAVE (HAVE ALREADY SCANNED)
	PUSH P,T2
	PUSHJ P,ADDSUB	;TAKE CARE OF + AND - FOR LINE
	POP P,T2
	POP P,T1
	MOVEM SINDEX,HILN	;SAVE RESULT
	POPJ P,		;AND RETURN

PGPLS:	PUSHJ P,SCAN	;GET NUMBER TO ADD
	TRZN FL,NUMF	;A NUMBER?
	NERROR ILC	;NO, NERROR
	ADDM T2,HIPG	;ADD IT IN
	JRST NOPGA	;AND CLEAN UP

;ROUTINE SETS HIPG IN CASE NONE SEEN BY GETLA, THEN CALLS GETLA

GET1S:	PUSHJ P,SCAN
GET1:	MOVE T3,CPGL
	MOVEM T3,HIPG
	JRST GETLA
GET10S:PUSHJ P,SCAN
GET10:	MOVE T3,[ASCII /00000/]	;SET HILN IN CASE NOT SEEN
	MOVEM T3,HILN
	JRST GET1

;GET A PAIR OF FORM A/B,C/D LOLN IS SET BY CALLER BEFORE CALL

GET2S:	PUSHJ P,SCAN
GET2:	TRZ FL,CNTF	;NOT A ! COMMAND
	PUSHJ P,GET1	;GET A LINE AND PAGE NUMBER PAIR
	MOVE T3,HIPG	;NOW SET LOWER PAGE TO THE ONE SEEN
	MOVEM T3,LOPG
	MOVE T3,HILN	;RESET LOW LINE IS A NUMBER SEEN
	TRNE FL,LINSN
	MOVEM T3,LOLN
GET2HF:MOVE T3,[<ASCII /99999/>+1]	;SET UP A LARGE NUMBER
	TRNN FL,LINSN	;IF NO LINE NUMBER SEEN
	MOVEM T3,HILN
	TRZ FL,PGSN	;SO DELETE CAN DETECT A SECOND PAGE SPEC
	CAIN C,"!"	;IS IT A ! COMMAND?
	JRST GET2CT	;GO TAKE CARE OF IT
	CAIE C,":"	;CHECK FOR SECOND SET
	POPJ P,		;NOPE, RETURN
	MOVEM T3,HILN	;SET HILN ANYWAY
	JRST GETLAS	;AND GO GET THE SECOND PAIR

GET2CT:	TRO FL,CNTF	;SET THE APPROPRIATE FLAG
	PUSHJ P,SCAN	;THERE SHOULD BE A NUMBER HERE
	TRNN FL,NUMF
	NERROR ILC	;LOSE
	MOVEM T2,SVCNT	;HANG ON TO IT
	JRST SCAN	;SCAN NEXT AND RETURN

SUBTTL INITIALIZE


INTEGER DPG,HILN,HIPG,LOLN,LOPG,SVINC,SVCNT,OCNT,NCNT,SRCALP,RPGLN,RPGPG
ARRAY TMPBF[2],ORGUSR,TMPUSR[2]

;HERE IS THE INITIALIZE CODE

STPT:	JRST RPGNO	;NOT RPG MODE
	MOVEI T1,STPT	;RESET JOBSA
	HRRM T1,JOBSA
	RESET	;TO SET JOBFF
	IFN TEMPSW,<HRRZ T1,JOBFF
	MOVEI T2,-1(T1)
	HRLI T2,-200
	MOVEM T2,TMPBF+1	;SET UP WHERE TO READ
	MOVSI T2,(<SIXBIT /EDT/>)
	MOVEM T2,TMPBF
	HRRM T1,RPGBUF+1	;AND FOR INPUT POINTER
	ADDI T1,200	;CHECK SIZE
	CAMLE T1,JOBREL	;ENOUGH ROOM??
	JRST	[IORI T1,1777
		CORE T1,
		JRST RPGNO
		JRST RPGYST]
RPGYST:	MOVE T1,[XWD 2,TMPBF]
	CAIN 17,525252	;FLAG FROM FAIL ETC
	JRST EDCMP	;SPECIAL THING TO EDIT
	TMPCOR T1,
	JRST TRYDSK	;NOT THERE
	ADDM T1,JOBFF
	IMULI T1,5	;GET NUMBER OF CHRS
	ADDI T1,1	;BECAUSE OF SOSG PROBLEMS
	MOVEM T1,RPGBUF+2
	HRLI T1,(<POINT 7,0>)
	HLLM T1,RPGBUF+1
	MOVEI FL2,TEMPFL!RPGALT!RPGFLG	;SET TO READ
	JRST RPGRT1>
TRYDSK:	INIT	CTL,1		;GET DISK FOR COMMAND FILE
	SIXBIT	/DSK/		;...
	XWD	0,RPGBUF	;...
	JRST	RPGNO
	MOVEI	T1,0		;PPN FOR THIS JOB
	PJOB T1,
	MOVEI	T4,3
RPGLUP:	IDIVI	T1,12		;JOB NO. IN DECIMAL
	ADDI	T2,20		;SIXBIT
	LSHC	T2,-6		;ACS T1,T2,T3 CONTIGUOUS
	SOJG	T4,RPGLUP
	HRRI	T3,'EDT'	;FILE NAME
	MOVEM	T3,NAMI
	MOVSI	T3,'TMP'	;FILENAMEXTENSION
	MOVEM	T3,NAMI+1
	SETZM	NAMI+3		;READ FROM THIS PPN
	LOOKUP	CTL,NAMI		;IS FILE THERE?
	JRST	RPGNO		;NOT FOUND
	INIT	CTL2,1		;FIND FILE AGAIN
	SIXBIT	/DSK/		;...
	0
	JRST	RPGNO		;MISSING
	SETZM	NAMI+3		;INSURE THIS PPN
	LOOKUP	CTL2,NAMI		;IS IT THERE?
	JRST	RPGNO		;NOPE, STOLEN
	SETZM	NAMI		;FLUSH IT
	RENAME	CTL2,NAMI		;...
	JRST	RPGNO		;UNFLUSHABLE
	RELEASE	16,		;HAPPINESS
	INPUT	CTL,		;READ COMMAND FILE
	MOVEI FL2,RPGFLG!RPGALT
RPGRT1:	IBP	RPGBUF+1	;IGNORE "S" FOR LINED
	SOS	RPGBUF+2	;COUNT DOWN TOO
IFE STANSW,<	MOVSI	FL,QMODF	;? IS NOT SPECIAL>
IFN STANSW,<	MOVSI	FL,0		;CLEAR ALL FLAGS>
	JRST RPGRET

EDCMP:	MOVE T1,JOBFF	;T1,T2, BETTER NOT BE 11-17
	HRLI T1,(POINT 7,0)
	MOVEM T1,RPGBUF+1
	SETZM RPGBUF+2	;NO CHRS YET
	MOVE P,[IOWD 40,PDL]
	MOVE T3,14
	AOS RPGBUF+2
	AOS RPGBUF+2
	IBP T1
	PUSHJ P,SXMEM	;STORE FILE NAME
	JUMPE 13,EDCNXT	;NO EXTENSION
	MOVEI T2,"."
	PUSHJ P,MEMCHR
	MOVE T3,13
	PUSHJ P,SXMEM
EDCNXT:	JUMPE 11,EDCNPP	;NO PPN
	MOVEI T2,"["
	PUSHJ P,MEMCHR
	HLRZ T2,11
	PUSHJ P,OCTMEM
	MOVEI T2,","
	PUSHJ P,MEMCHR
	HRRZ T2,11
	PUSHJ P,OCTMEM
	MOVEI T2,"]"
	PUSHJ P,MEMCHR
EDCNPP:	PUSHJ P,MEMCRL
	MOVEI T2,"P"
	PUSHJ P,MEMCHR
	MOVE T3,15
	TRZ T3,1
ASCLP:	MOVEI T2,0
	LSHC T2,7
	PUSHJ P,MEMCHR
	JUMPN T3,ASCLP
	MOVEI T2,"/"
	PUSHJ P,MEMCHR
	MOVE T2,16
	PUSHJ P,DECMEM
	PUSHJ P,MEMCRL
	MOVEI T1,1(T1)
	MOVEM T1,JOBFF
	MOVEI FL2,TEMPFL!RPGALT!RPGFLG
	JRST RPGRT1

DECMEM:	MOVEI T4,^D10
NUMMEM:	IDIVI T2,(T4)
	HRLM T3,(P)
	SKIPE T2
	PUSHJ P,NUMMEM
	HLRZ T2,(P)
	ADDI T2,"0"
MEMCHR:	IDPB T2,T1
	AOS RPGBUF+2
	POPJ P,

OCTMEM:	MOVEI T4,10
	JRST NUMMEM

SXMEM:	MOVEI T2,0
	LSHC T2,6
	ADDI T2," "
	PUSHJ P,MEMCHR
	JUMPN T3,SXMEM
	POPJ P,

MEMCRL:	MOVEI T2,15
	PUSHJ P,MEMCHR
	MOVEI T2,12
	JRST MEMCHR

RPGNO:	MOVEI FL2,0	;GET RPGFLG OFF
	RESET
IFN STANSW,<	MOVEI FL,0	;CLEAR FLAG REGISTER>
IFE STANSW,<	MOVSI FL,QMODF	;SET FOR ? IS NOT SPECIAL>
RPGRET:	MOVE T1,[JSR ERRHD]	;SET UP UUO HANDLER
	MOVEM T1,41
	MOVEI T1,PDLOV	;SET UP A PDLOV TRAP
	MOVEM T1,JOBAPR
	MOVEI T1,200000	;SET FOR PDLOV ONLY
	APRENB T1,
	SETZM SAVCHR
IFN STANSW,<INIT TTY,401	;NO DUPLEX BUCKY BITS>
IFE STANSW,<INIT TTY,2	;SET UP TTY FOR NO ALTMODE DUPLEXING>
	SIXBIT /TTY/
	XWD TOBUF,TIBUF
	EXIT	;LOSE BIG
	INIT IN,14
	SIXBIT /DSK/	;DISK FOR INPUT AND OUTPUT
	XWD 0,IBUF
	JRST NODSK
	INIT OUT,14
	SIXBIT /DSK/
	XWD OBUF,0
	JRST NODSK	;WE ARE IN TROUBLE
	INBUF TTY,2
	OUTBUF TTY,2	;SET UP TELETRIPE BUFFERS
	MOVE T1,JOBFF	;NOW SAVE JOBFF
	MOVEM T1,BUFHD#	;FOR LATER RECOPY OPERATIONS
	INBUF IN,2	;GET DISK BUFFERS SET UP
	OUTBUF OUT,2
	MOVE T1,JOBFF
	SETZM (T1)	;SAVE A ZERO WORD
	ADDI T1,1	;NEXT ONE STARTS
	MOVEM T1,BUFP#	;START OF THE BUFFER
	MOVE P,[IOWD 40,PDL]
	MOVE T1,[XWD ODATA,SQBUF]
	BLT T1,SQBUF+ODLN-1	;SET UP DATA AREA
	TRNE FL2,SVIT
	JRST RPGR1
	TRNE FL2,RPGFLG
	JRST RPGR2
	OUTSTR [ASCIZ /
/]
	MOVEI T1,[ASCIZ /FILE = /]
	PUSHJ P,GNCHGT

RPGR2:	PUSHJ P,SCAN
	CAIN C,"@"	;READ RPG FILE??
	JRST	[PUSHJ P,ATCOM	;TRY TO FIND IT
		JRST STPT	;GIVE UP
		JRST RPGR2]
	MOVEI T1,ORGUSR	;SET A PLACE FOR USER NAME TO GO
	PUSHJ P,READNM	;GET A FILE NAME
	JRST ILFN	;IFFEGAL FORMAT
	TLNE FL2,SSW!BSW	;ALSO SET KEEP SEQUENCE IN /B
	TLO FL2,KEPSQF	;SET KEEP SEQUENCE NUMBER FLAG
	TLNE FL2,BSW	;IF /B MODE
	TLO FL2,BMOD	;SET BASIC MODE
	MOVE T1,NAMI
	MOVEM T1,ORGNAM#
	MOVE T1,NAMI+1
	MOVEM T1,ORGEXT#
	MOVE T1,NAMI+3
	MOVEM T1,ORGPPN#
	TLNE FL2,RSW
	TRO FL,READOF
CKTRM2:	TRNN FL,TERMF	;IS IT A TERMINATOR?
	JRST ILFN
RPGR1:	SETZM NAMO
	MOVE T1,[XWD NAMO,NAMO+1]
	BLT T1,NAMO+3
	DATE T1,	;GET CURRENT DATE
	TIMER T2,	;AND TIME IN TICKS
	LSH T1,^D21	;USE TO MAKE A STRANGE NAME
	IOR T1,T2
	MOVEM T1,EDNAM#	;SAVE FOR LATER
	MOVEM T1,NAMO
	MOVSI T1,'TMP'
	MOVEM T1,NAMO+1
	HRRZ T1,JOBFF
	ADDI T1,2000
	IORI T1,1777
	CAMLE T1,JOBREL
	CORE T1,
	JFCL

	MOVE T1,JOBREL	;FIND THE END OF CORE
	MOVEM T1,CORTOP#
	SUBI T1,2*MXWPL+2	;LEAVE SPACE FOR A COUPLE OF LINES
	MOVEM T1,FILPT#		;THIS IS HOW FAR TO FILL THE BUFFER
	MOVE T1,CORTOP	;NOW FIND THE SIZE
	SUB T1,BUFP
	MOVE T2,T1	;GET A COPY
	SUBI T2,MXWPL+1	;WHEN TO START DUMPING
	MOVEM T2,MAXWC#
	ASH T1,-1	;TAKE HALF OF IT
	MOVEM T1,HLFWC#	;SAVE THAT FIGURE
	TRNE FL2,SVIT	;IF DOING A W
	JRST NOSV1	;SKIP SOME ITITIALIZE
	MOVNI T1,1
	GETLCH T1
	TLNE T1,20	;IS LC SPECIFIED?
	TRO FL,M37F
	HRROI T1,15
	AUXCAL T1,T1
	 JFCL
	CAIN T1,5
	TRO FL,DPYF
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,CLN#	;SET UP THE CURRENT LINE
	MOVE T1,[<ASCII /00100/>+1]	;AND CURRENT INCREMENT
	MOVEM T1,INCR#
	MOVEM T1,TINCR#	;USED BY INSERT SO TEMP INCS WORK
	MOVEM T1,IINCR#
	MOVEM T1,CURINS#	;CURRENT PLACE TO INSERT IF NO ARGS TO I
	MOVEI T1,NSEPF		;SET UP SEPERATOR FLAG
	MOVEM T1,SEPFLG#	;TO SAY $,%,AND . ARE NOT SEPERATORS
	SETZM NOCERR#	;FLAG TO SAY DON'T STOP ON COMMAND FILE ERRORS
NOSV1:	MOVEI T1,1	;AND THE CURRENT PAGE
	MOVEM T1,CPG#
	TRNE FL2,SVIT
	JRST NOSV1A
	MOVEM T1,CPGL#
	MOVEM T1,IPG#		;CURRENT PAGE TO INSERT ON
NOSV1A:	MOVE PNTR,BUFP	;SET THE BUFFER POINTER
	MOVE T1,[BYTE (7) 15,15,15,15,15]
	MOVEM T1,LIBUF+MXWPL+2
	MOVEI T1,RENLOC
	MOVEM T1,JOBREN		;SET UP FOR REENTER
	MOVEI T1,1	;SET INPUT PAGE
	MOVEM T1,INPG#
	SETZM SVWD#	;O WORDS WAITING
	SETZM OLDLIN#	;UESD FOR ORDER CHECKING ON INPUT
	SETZM WC#	;ZERO WORD COUNT FOR START
	TRNE FL2,SVIT2
	JRST NOSV2A
	TRNE FL2,SVIT
	JRST NOSV2
	SETZM CASEBT#	;0 FOR LETTERS AS UPPER CASE 40 FOR LOWER
	SETZM SRPNT	;NO SEARCH STRING YET
	SETZM R1PNT	;ALSO REPLACE STRINGS
	SETZM R2PNT
NOSV2A:	CAIE C,175	;RPG ONLY KNOWS ABOUT 175 FOR CREATE
	CAIN C,200	;IS IT ALTMODE
	JRST CREAT
	MOVSI T1,1	;SET BIG PAGE LARGE FOR NOW
	MOVEM T1,BGPG#
NOSV2:	LOOKUP IN,NAMI
	JRST NOFIL	;IT IS NOT THERE
	MOVE T1,NAMI+2	;SAVE THE PROTECTION
	AND T1,[XWD 777000,0]	;JUST PROTECTION
	MOVEM T1,ORGPRT#	;THE REST IS IGNORED ON RENAME
	TRNE FL,READOF
	JRST NOENT	;DO NOT ENTER
	ENTER OUT,NAMO
	JRST EDFLIN	;SOME OTHER BASTARD IS USING IT
NOENT:	TRO FL,BOF	;IS AT START OF FILE
	TLO FL,FSTOPF	;FIRST OP
	PUSHJ P,FILLBF	;AND FILL UP THE BUFFER
	JRST COMND	;GET A COMMAND AND DO IT

IFN STANSW,<
RJUST:	MOVE T1,ACCUM#
RJUST1:	TRNE T1,77	;IS THERE ANYTHING THERE?
	POPJ P,		;YES, IT IS RIGHT JUSTIFIED IN LEFT HALF
	LSH T1,-6	;MOVE IT OVER
	JRST RJUST1	;WE KNOW THERE IS SOMETHING THERE>
IFE STANSW,<
RJUST:	MOVE T3,ACCUM#	;GET THE SIXBIT
	MOVEI T1,0
RJUST1:	MOVEI T2,0
	LSHC T2,6
	CAIL T2,'0'	;CHECK FOR OCTAL DIGIT
	CAILE T2,'7'
	POPJ P,
	LSH T1,3
	IORI T1,-'0'(T2)
	JUMPN T3,RJUST1	;DONE IF NULLS LEFT
	AOS (P)
	POPJ P,	;SKIP RETURN FOR ALL OK>

PDLOV:	NERROR STC

RENLOC:	TRO FL,RENSN	;MARK AS SEEN
	SETZM BUFPTR
	JRST @JOBOPC	;AND GO BACK TO WHAT WE WERE DOING

READNM:	SETZM (T1)	;FIRST WORD OF PLACE TO PUT USER NAME
	SETZM 1(T1)
	MOVEM T1,PPNPT#	;SAVE IT FOR READING USER NAME
	SETZM NAMI
	MOVE T1,[XWD NAMI,NAMI+1]
	BLT T1,NAMI+3	;CLEAR AREA
	TLZ FL2,RSW!SSW!BSW
	CAIN C,"("
	JRST RDUSR	;READ A USER NAME
RDNM1:	TRNN FL,IDF!NUMF	;IS IT AND IDENT
	POPJ P,		;ERROR RETURN
	MOVE T1,ACCUM
	MOVEM T1,NAMI
	PUSHJ P,SCAN
	CAIN C,"["	;CHECK FOR PPN
	JRST SETPPN
	CAIE C,"."
	JRST CKTERM
	PUSHJ P,SCAN	;THIS SHOULD BE AN EXTENSION
	TRNN FL,IDF!NUMF
	POPJ P,
	MOVE T1,ACCUM	;GET IT
	HLLZM T1,NAMI+1	;AND PUT IT IN THE EXTENSION FIELD
	PUSHJ P,SCAN
	CAIE C,"["	;NOW LOOK FOR PPN
	JRST CKTERM
SETPPN:	PUSHJ P,SCAN
	TRNN FL,IDF!NUMF
	POPJ P,
	PUSHJ P,RJUST	;RIGHT JUSTIFY IT
IFE STANSW,<	POPJ P,		;NON-SKIP RETURN IF NOT OCTAL>
	HRLZM T1,NAMI+3
	PUSHJ P,SCAN
	CAIE C,","
	POPJ P,
	PUSHJ P,SCAN
	TRNN FL,IDF!NUMF
	POPJ P,
	PUSHJ P,RJUST
IFE STANSW,<	POPJ P,		;LOSE>
	HRRM T1,NAMI+3
	PUSHJ P,SCAN
	CAIE C,"]"
	POPJ P,
	PUSHJ P,SCAN
CKTERM:	CAIE C,"/"	;CHECK FOR READ ONLY MODE
	JRST CPOPJ1	;ALL OK
	PUSHJ P,SCAN
	TRNN FL,IDF
	POPJ P,
	MOVS T1,ACCUM
	CAIN T1,'B  '
	TLO FL2,BSW	;SAY B SEEN
	CAIN T1,'R  '
	TLO FL2,RSW
	CAIN T1,'S  '
	TLO FL2,SSW
	PUSHJ P,SCAN
	TLNE FL2,RSW!SSW!BSW
	AOS (P)
	POPJ P,

RDUSR:	MOVE T1,PPNPT
	MOVEM T1,NAMI+3	;SET POINTER TO IT
	HRLI T1,(<POINT 6,0>)	;MAKE BYTE POINTER
	MOVEI T2,^D12	;12 CHRS IN A USER NAME
RDUSR1:	PUSHJ P,GNCH
	CAIN C,")"
	JRST ENDUSR	;ALL DONE
	TLNE CS,TERM_16
	POPJ P,		;ERROR READING FILE NAME
	SOJL T2,RDUSR1	;TOO MANY CHRS, IGNORE
	IDPB CS,T1
	JRST RDUSR1

ENDUSR:	PUSHJ P,SCAN	;SCAN NEXT THING
	JRST RDNM1	;AND GO BACK TO READING


;CREATE A NEW FILE

CREAT:	LOOKUP IN,NAMI	;SEE IF THERE IS ONE OF THAT NAME
	JRST CRTOK	;NO, ALL IS WELL
	OUTSTR [ASCIZ /
FILE ALREADY EXISTS! DELETE (Y OR N)
/]
WTCRT:
	PUSHJ P,OFRPG	;TURN IT OFF
	INCHWL T1	;GET A CHR
	CLRBFI	;FLUS THE BUFFER AFTER READING
	ANDI T1,177	;GET RID OF BUCKY BITS
	CAIE T1,"y"
	CAIN T1,"Y"	;IS IT YES?
	JRST CRTOK	;GO TO WORK
	CAIN T1,"n"
	CAIN T1,"N"	;IF NO, START OVER
	JRST STPT
	OUTSTR [ASCIZ /
TYPE Y OR N
*/]
	JRST WTCRT	;HE JUST DOESN'T LEARN
CRTOK:	ENTER OUT,NAMO	;GO DO THE OUTPUT
	JRST EDFLIN	;FOOBAZ
	SETZM (PNTR)	;ZERO FIRST WORD OF BUFFER
	TRZ FL,READOF	;CREAT AND READOF ARE NOT POSSIBLE
	TRO FL,BOF!EOF!EOF2	;SAY AT START AND NO MORE TO READ
	MOVE T1,[XWD 12,16]	;GET STANDARD PROTECTION
	GETTAB T1,
	 MOVSI T1,047000
	MOVEM T1,ORGPRT		;SET A STANDARD FOR CREATE
	MOVEI T1,1	;SET BGPG
	MOVEM T1,BGPG
	TRNE FL2,RPGFLG
	JRST CRTINS
	OUTSTR [ASCIZ /
/]
	JRST COMND	;AT LAST

ARRAY LOBUF,TIBUF,TOBUF,OBUF,IBUF[3],NAMI,NAMO[4],PDL[40]
PGMK:	<ASCII /     />+1
ARRAY LIBUF[MXWPL+3],LIBUF2[MXWPL+2],LPTBUF[203*2+1]
ODATA:
	DEFINE CODIT (LAB,COD)
<%A%A==.
	COD
LVAR
ARRAY LAB[.-%A%A]
LVAR>		;GENERATE NAMED ARRAYS IN ORDER AND PROPER SIZE

CODIT(SQBUF,<0
ASCIZ /	/>)
CODIT(LINOUT,<0
ASCIZ ./.>)
CODIT(ERRHD,<0
JRST ERRHD1>)
CODIT(ASCZ1,ASCII /INC1=/)
CODIT(PRNTO1,<0
	ASCIZ /
/>)
CODIT(ASCIZ2,ASCII/INC2=/)
CODIT(PRNTO2,<0
	ASCIZ /
/>)
	CODIT (RPGR,<SIXBIT /SYS/
RPGNAM
0
0
0
0>)
ODLN==.-ODATA
SUBTTL ERROR ROUTINES

EDFLIN:	OUTSTR [ASCIZ /
TEMPORARY EDIT FILE IN USE. I GIVE UP
/]
	EXIT

NODSK:	OUTSTR [ASCIZ /
NO DISK AVAILABLE. PLEASE CHECK THE DISK YOU HAVE REQUESTED
/]
	EXIT

NOFIL:	OUTSTR [ASCIZ /
FILE NOT FOUND/]
	JRST STPT
ILFN:	OUTSTR [ASCIZ /
ILLEGAL FILE SPECIFICATION/]
	JRST STPT


ERRHD1:	MOVEM T1,SVT1E#	;SAVE T1 IN CASE OF RERROR
	SETZM BUFPTR	;NO MORE BUFFER STUFF
	HRRZ T1,40	;PICK UP THE ERROR NUMBER
	SKIPE T1
	CAILE T1,NUMR
	ERROR ILUUO	;WRONG ERROR, CALL SELF
	MOVEM T1,SVERN#	;SAVE FOR =ERROR COMMAND
	PUSHJ P,OUTER	;PRINT THE ERROR MSG
	TRNE FL2,RPGFLG	;IF IN RPG MODE
	PUSHJ P,[TRNE FL2,SUPOFL	;IF OUTPUT NOT SUP
		SKIPN T1,RPGLN	;OR NO LINE NUMBER
		JRST RPGERR	;JUST SHUT HIM OFF
		MOVEM T1,LINOUT
		OUTSTR LINOUT
		PUSH P,T2
		PUSH P,T3	;SAVE SO ERROR DESTROYS NOTHING
		MOVEI T3,OCHR
		AOS T1,RPGPG
		PUSHJ P,DECPR	;PRINT PAGE NUMBER
		POP P,T3
		POP P,T2
		OUTSTR [ASCIZ /
/]
		JRST RPGERR]
ERRCON:	LDB T1,[POINT 9,40,8]	;GET UUO
	CAILE T1,NUMTYP
	ERROR ILUUO	;IT WAS ILLEGAL
	XCT ERND(T1)	;DO GOOD THING
	JRST @ERRHD	;RERROR WILL FALL THROUGH XCT AND RETURN
	POPJ P,		;FOR PERROR

RPGERR:	SKIPE NOCERR
	JRST ERRCON	;HAS SET FLAG FOR CONTINUE
	JRST OFRPG	;GO TURN COMMAND FILE OFF

ERND:	ERROR ILUUO	;0 IS AN ERROR
	HALT	;DIE
	JRST COMND	;GO ON
	MOVE T1,SVT1E	;RERROR- RESTORE T1
	SKIPA T1,SVT1E	;RESTORE T1 AND SKIP TO POPJ
NUMTYP=.-ERND	;TYPES OF ERRORS

OUTER:	TRNN FL,EXTOG	;WHICH MODE?
OUTER1:	SKIPA T1,ETBL-1(T1)	;ENTER HERE FROM =ERROR
	HLRZ T1,ETBL-1(T1)
	OUTSTR [ASCIZ /
*/]
	OUTSTR (T1)
	OUTSTR [ASCIZ /*
/]
	POPJ P,

DEFINE ERMS (A,B)
<RELOC ETBL+A-1
	XWD [ASCIZ /A/],[ASCIZ /B/]
>

ETBL:	ERMS ICN,INTERNAL CONFUSION
	ERMS DIE,DEVICE INPUT ERROR
	ERMS DDE,DEVICE OUTPUT ERROR
	ERMS ILC,ILLEGAL COMMAND
	ERMS ILUUO,ILLEGAL UUO
	ERMS LTL,LINE TOO LONG
	ERMS NLN,<NO SUCH LINE(S)>
	ERMS NSP,NO SUCH PAGE
	ERMS ORDER,OUT OF ORDER
	ERMS UNA,DEVICE NOT AVAILABLE
	ERMS ILR,ILLEGAL REPLACEMENT
	ERMS WAR,WRAP AROUND
	ERMS TMS,TOO MANY STRINGS
	ERMS STL,STRING TOO LONG
	ERMS ISS,ILLEGAL SEARCH STRING
	ERMS ILFMT,ILLEGAL LINE FORMAT
	ERMS NSG,NO STRING GIVEN
	ERMS FNF,FILE NOT FOUND
	ERMS DNA,DISK NOT AVAILABLE
	ERMS NEC,INSUFFICIENT CORE AVAILABLE
	ERMS IRS,ILLEGAL REPLACEMENT STRING
	ERMS STC,SEARCH STRING TOO COMPLEX
	ERMS ITD,ILLEGAL TRANSFER DESTINATION
	ERMS NNN,NO NEXT LINE
	ERMS NMF,NO MATCH FOUND
	ERMS IBN,ILLEGAL BUFFER

	RELOC ETBL+NUMR

SUBTTL COMMAND DECODER

;HERE IS THE COMMAND DECODER AND DISPATCHER

COMNDA:	TRNN FL2,RPGFLG	;IF NOT IN RPG MODE
	JRST COMND	;JUST GO ON
COMNDB:	PUSHJ P,GNCH	;LOOK FOR THE LINE FEED
	TRNN FL2,RPGFLG	;JUST IN CASE
	JRST COMND
	CAIE C,12
	JRST COMNDB
COMND:	SETZM SAVCHR#	;SCAN SHOULD GET RESET AT THIS POINT
IFN STANSW,<SETSTS TTY,401>
IFE STANSW,<SETSTS TTY,2	;JUST IN CASE DUPLEXING IS OFF>
	TLNE FL,SRCOP	;THIS CASE IS SPECIAL SINCE WE
	SKIPA P,COPDL	;SHOULD NOT DESTROY SAVED ITEMS
	MOVE P,[IOWD 40,PDL]	;ALSO PDL (IN CASE OF ERRORS)
	TLNE FL,SRCOP
	JRST NOCPCK	;DO NOT GET OUT OF COPY MODE
	TLZE FL,ISCOP	;IN COPY MODE?
	JRST COPDON	;YES, DO SPECIAL CLEAR OUT
NOCPCK:	TRNE FL2,RPGFLG!SUPN!ASUPN
	TDZA T1,T1	;NO PROMPT
	MOVEI T1,[ASCIZ /*/]
	PUSHJ P,GNCHGT	;FORCE READING OF NEW LINE
	TRZ FL2,SVIT!SVIT2!SUPN	;NOT ANY MORE
	MOVE C,INCR
	MOVEM C,TINCR	;RESET TEMP INCREMENT
CMND1:	PUSHJ P,GNCH	;READ A CHARACTER
COMPOS:	CAIE C,15
	JUMPE CS,CMND1	;IGNORE SPACES ETC
	TLNE CS,LETF_16	;CHECK TO SEE IF LETTER
	TRZ C,40	;AND CONVERT TO UPPER CASE
	TRZ FL,RENSN	;JUST IN CASE SOMEONE LEFT IT ON
	MOVE T1,[XWD -CMDLG,CMD1]
	PUSHJ P,ISRCH
	NERROR ILC	;NOT THERE
	TLNE T1,RBIT	;IS IT READ ONLY PERMITTED?
	TRNN FL,READOF	;AND READ ONLY MODE
	SKIPA
	NERROR ILC	;READ ONLY AND NOT PERMITTED
	TLNE T1,BBIT	;IS IT SPECIAL BASIC
	TLNN FL2,BMOD	;AND BASIC MODE
	JRST (T1)	;NO, GO
	OUTSTR [ASCIZ /
COMMAND MAY CHANGE STATEMENT NUMBERS. TYPE Y TO PERFORM ANYWAY
/]
	INCHWL T2
	CLRBFI	;FLUSH BUFFER
	ANDI T2,177
	CAIE T2,"y"
	CAIN T2,"Y"
	JRST (T1)	;IT WAS A Y
	OUTSTR [ASCIZ /
COMMAND IGNORED
/]
	JRST COMND

ISRCH:	LDB T3,[POINT 8,(T1),17]	;GET COMMAND LETTER
	CAME T3,C	;IS IT THE ONE?
	AOBJN T1,ISRCH
	JUMPGE T1,CPOPJ	;EXIT ON NOT FOUND
	MOVE T1,(T1)	;GET COMMAND EXTRY
	AOS (P)
	POPJ P,

RBIT==400000
BBIT==200000

DEFINE TBCOD(A,B,C)
<XWD <IFDIF <> <C>,<C+>A>,B>

CMD1:	TBCOD "P",PRINT
	TBCOD 15,COMNDA
	TBCOD "E",ENDIT
	TBCOD "I",INSERT,RBIT
	TBCOD "D",DELETE,RBIT
	TBCOD "M",MARK,RBIT!BBIT
	TBCOD "N",NUMBER,RBIT!BBIT
	TBCOD "A",ALTER,RBIT
	TBCOD "_",SET
	TBCOD "=",GIVE
	TBCOD "L",LIST
	TBCOD "R",REPLAC,RBIT
	TBCOD "F",SEARCH
	TBCOD 12,NXTLIN
	TBCOD 200,BAKLIN
	TBCOD "C",COPY,RBIT
	TBCOD "S",SUBST,RBIT
	TBCOD "G",GEND
	TBCOD "X",XPAND,RBIT
	TBCOD "J",JOIN,RBIT
	TBCOD "T",TRANS,RBIT!BBIT
	TBCOD "W",SVCOD
	TBCOD "@",ATSIN
	TBCOD "U",SETGO
	TBCOD "B",BUFCOD
	TBCOD <";">,CMNT
	TBCOD "Z",NFLCMD
CMDLG==.-CMD1

SUBTTL CMNT

CMNT:	TRNN FL2,RPGFLG
	JRST COMND
CMNTLP:	PUSHJ P,GNCH
	PUSHJ P,OCHR
	CAIE C,12
	JRST CMNTLP
	JRST COMND


SUBTTL PRINT

PRINT:	SETZM LOLN	;AS A FLAG IN CASE OF /C OR /A,/C
	PUSHJ P,SCAN	;SEE WHAT IS THERE
	CAIE	C,","	;IS THIS A COMMA SWITCH?
	JRST	PRNT5		;NO, LOOK FOR OTHERS
	PUSHJ	P,SCAN		;YES, SCAN PAST IT
	TRO	FL2,SUPN	;ASSUME IT WAS ,N
	PUSHJ	P,SCAN		;LOOK FOR OTHERS
PRNT5:	TRNE FL,TERMF	;IF NOTHING
	JRST	[MOVE T1,CLN	;THEN P.!16
		MOVEM T1,LOLN
		MOVE T1,CPGL
		MOVEM T1,LOPG
		MOVEI T1,20
		MOVEM T1,SVCNT
		TRO FL,CNTF	;THE ! FLAG
		JRST PRCNT]
	PUSHJ P,GET2	;GO READ THOSE NUMBERS
	CAIE	C,","		;IS  THERE A COMMA?
	JRST	PRNT6		;NO
	PUSHJ	P,SCAN		;YES, GET IT
	TRO	FL2,SUPN	;ASSUME ,N
	PUSHJ	P,SCAN		;GET NEXT THING
PRNT6:	TRNN FL,TERMF	;DID IT END WITH A TERMINATOR
	NERROR ILC	;NO, ILLEGAL
PRCNT:	TRZ FL,LINSN	;USE THIS AS A FLAG TO CHECK FOR NULL RANGE
RPGPRN:MOVE T1,LOPG	;FIND THE FIRST LINE WANTED
	MOVEM T1,DPG	;SET IT AS THE ONE WE WANT
	MOVE SINDEX,LOLN	;PICK UP THE LINE
	PUSHJ P,FIND	;GO GET IT
	SKIPE LOLN	;DID WE WANT TO PRINT AN ENTIRE PAGE
	JRST PRNT1	;NO, GO CHECK BOUNDS
	MOVE T2,CPG	;WHICH ONE ARE WE ON
	MOVEM T2,CPGL
	PUSHJ P,PGPRN	;PRINT THE PAGE HEADER
	TRO FL,LINSN	;THIS CAN COUNT AS A LINE
PRNT1:	PUSHJ P,ONMOV	;CHECK TO SEE IF STILL IN RANGE
	JRST EPRNT	;NO, END
	TRO FL,LINSN	;WE HAVE SEEN ONE
	CAMN T1,PGMK	;IS IT A PAGE MARK?
	JRST PRNT3	;YES, DO SOMETHING SPECIAL
	MOVEM T1,CLN
	MOVEM T2,CPGL	;SAVE PAGE TOO
	MOVE T1,PNTR	;GET THE POINTER TO IT
	PUSHJ P,OUTLIN	;AND PRINT
PRNT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	JRST PRNT1	;AND CONTINUE
PRNT3:	MOVEM T2,CPGL
	PUSHJ P,PGPRN	;GO PRINT A PAGE HEADER
	AOS CPG
	MOVE T2,[<ASCII /00000/>+1]
	MOVEM T2,CLN	;SET LINE TO FIRST ON THAT PAGE
	JRST PRNT4	;AND CONTINUE
EPRNT:	TRZN FL,LINSN!RENSN	;DID WE PRINT SOMETHING
	NERROR NLN	;NO, ERROR
	JRST COMND	;YES, RETURN FOR COMMAND

;CHECK TO SEE IF OUT OF LIMITS SKIP RETURN IF OK
ONMOV:	JUMPE T1,CPOPJ	;0, MUST BE EOF SO ALL DONE
	TRNE FL,RENSN	;IF REENTER FLAG SET
	POPJ P,		;THEN CONSIDER RANGE AS ENDED
	MOVE T2,CPG	;GET THE CURRENT PAGE
	CAMN T1,PGMK	;ARE WE AT A PAGE MARK?
	ADDI T2,1	;YES, TREAT AS NEXT PAGE
	TRNE FL,CNTF	;IS THIS A ! TYPE COMMAND?
	JRST ONCNT
	CAMLE T2,HIPG	;HOW DOES IT COMPAGE WITH UPPER LIMIT
	POPJ P,		;HIGHER, ALL DONE
	CAME T1,PGMK	;IF PAGE MARK, DO NOT COMPARE LINE
	CAME T2,HIPG	;OR IF NOT ON LAST PAGE
	SKIPA
	CAMG T1,HILN	;ARE WE OUT OF LINES?
	AOS (P)	;SKIP RETURN ALL OK
	POPJ P,		;GO

ONCNT:	CAMN T1,PGMK	;DO NOT COUNT PAGE MARKS
	SKIPG SVCNT	;IF PAGE MARK, GIVE UP IF DONE
	SOSL SVCNT	;ARE WE OUT
	AOS (P)		;SKIP RETURN FOR OK
	POPJ P,


PGPRN:	OUTSTR [ASCIZ /
PAGE /]
	PUSHJ P,DPRNT	;PRINT THE NUMBER IN T2
	OUTSTR [ASCIZ /
/]
	POPJ P,

;THE USUAL NUMBER PRINTER

DPRNT:	IDIVI T2,^D10
	HRLM T3,(P)
	SKIPE T2
	PUSHJ P,DPRNT
	HLRZ C,(P)
	ADDI C,"0"
	OUTCHR C
	POPJ P,

;CHARACTER OUTPUT

OCHR:	MOVE CS,CTBL(C)	;GET THE MAJIC BITS
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TDC C,CASEBT	;AND CHANGE CASE AS NECESSARY
	TRNE FL,DPYF	;IS IT A DISPLAY
	JRST OCH2	;YES, JUST PRINT
	PUSH P,C	;SAVE THE CHARACTER
	LDB C,[POINT 7,CTBL(C),10]	;GET PRINT EQUIV.
	JUMPE C,OCH1	;NONE, PRINT ORIGINAL
	TDNE CS,[XWD LETF_16,M37]	;IS THIS A LETTER OR SPECIAL
	TRNN FL,M37F	;AND A MODEL 37
	SKIPA
	JRST OCH1	;THEN PRINT NORMALLY
	MOVEM C,(P)	;SAVE IN STACK
	OUTCHI "?"
OCH1:	POP P,C		;GET THE CHR TO PRINT
OCH2:	OUTCHR C
	POPJ P,		;AND RETURN

OUTLIN:	TRNE	FL2,SUPN!ASUPN	;SUPPRESSING LINE NUMBERS?
	AOS	T1		;YES, SKIP THE NUMBER
	HRLI T1,(<POINT 7,0>)	;GET SET TO PRINT A LINE
	TRNE	FL2,SUPN!ASUPN	;ALSO SKIP
	IBP	T1		;TAB WHICH FOLLOWS
OUTL1:	ILDB C,T1	;GET A CHR
	PUSHJ P,OCHR	;AND PRINT IT
	CAIE C,12	;IS IT LINE FEED
	JRST OUTL1	;NO, CONTINUE
	POPJ P,
SUBTTL END ROUTINE

;CODE TO FINISH OFF EDIT

NFLCMD:	TROA FL2,SVIT2	;SAVE AND SELECT NEW FILE
SVCOD:	TROA FL2,SVIT	;THE W COMMAND
ENDIT:	TLNN FL2,BMOD	;IN /B MODE E IS SAME AS G
	TLZA FL,GCOM
GEND:	TLO FL,GCOM
END0:	TLNE FL,SRCOP
	JRST DSCOP	;FINISH UP THE COPY COMMAND
	TRNE FL,READOF	;IF READ ONLY
	JRST ENDEND
	TRZ FL2,NEWFL	;SET TO WANTS SAME OLD PROGRAM
	MOVE T1,ORGNAM	;GET THE ORIGINAL NAME
	MOVEM T1,NAMI	;GET SET UP
	MOVE T1,ORGEXT	;AND EXTENSION
	HLLZM T1,NAMI+1
	PUSHJ P,GNCH	;READ ONE CHR
	SKIPN CS	;ERROR IF NOT A BLANK CHR
	PUSHJ P,NSCAN	;GET A NAME
	NERROR ILC	;SKIPS IF NO ERRORS
	PUSHJ P,OCOMPL	;FINISH COPY
END7:	CLOSE IN,0	;AND CLOSE FILES
	CLOSE OUT,0
	SETZM NAMI+3	;ZERO PPN
	LOOKUP IN,NAMI	;GET IT
	JRST	[HRRZ T1,NAMI+1	;GET ERROR TYPE
		CAIN T1,0	;IF OTHER THAN NOT FOUND
		JRST END3	;NOT FOUND OK
		JRST FIU]	;ASSUME PROTECTION
	TRNN FL2,NEWFL	;IS THIS A NEW FILE?
	JRST END4	;NO, WE SHOULD HAVE FOUND IT
	OUTSTR [ASCIZ /
FILE ALREADY EXISTS! DELETE (Y OR N)
*/]
ENDA1:
	PUSHJ P,OFRPG
	INCHWL T1	;GET ANSWER
	CLRBFI
	ANDI T1,177
	CAIE T1,"y"
	CAIN T1,"Y"
	JRST END4
	CAIE T1,"n"
	CAIN T1,"N"
	JRST END8	;GET A NEW NAME
	OUTSTR [ASCIZ /
TYPE Y OR N
*/]
	JRST ENDA1
END4:	SETZM NAMI	;DELETE THE LOSER
	SETZM NAMI+3
	RENAME IN,NAMI
	JRST FIU
END3:
END5:	MOVE T1,EDNAM	;GET THE OUTPUT
	MOVEM T1,NAMO
	MOVSI T1,(<SIXBIT /TMP/>)
	MOVEM T1,NAMO+1
	SETZM NAMO+3
	LOOKUP OUT,NAMO
	JRST EDFLIN	;GIVE UP
	MOVE T1,ORGNAM	;SET TO DESIRED NAME
	MOVEM T1,NAMO
	MOVE T1,ORGEXT
	MOVEM T1,NAMO+1
	SETZM NAMO+3
	MOVE T1,ORGPRT
	MOVEM T1,NAMO+2		;SET UP TO GIVE SAME PROTECTION
	RENAME OUT,NAMO
	JRST INFCNF
ENDEND:	CLOSE OUT,0
	RELEASE OUT,0
	CLOSE IN,0
	RELEASE IN,0
	TRNE FL2,SVIT!SVIT2
	JRST	[RELEASE IN,0
		RELEASE OUT,0	;SIMULATE CALLI BUT FOR @ FILE
		RELEASE TTY,0
		HLRZ T1,JOBSA
		MOVEM T1,JOBFF
		TLZ FL,TECOF
		TRZ FL,BOF!EOF!EOF2
		TRNN FL,READOF
		SETZM ORGPPN	;TURN OF PPN IN NOT READ ONLY
		MOVE T1,ORGNAM
		MOVEM T1,NAMI
		MOVE T1,ORGEXT
		MOVEM T1,NAMI+1
		MOVE T1,ORGPPN	;JUST IN CASE
		MOVEM T1,NAMI+3
		JRST RPGRET]	;GO
	TLNN FL,GCOM
	EXIT
	JRST CREFIT
NSCAN:	PUSHJ P,SCAN	;SEE IF HE WANTS TO GIVE IT A NEW NAME
	TRNE FL,TERMF	;TERMINATOR?
	JRST CPOPJ1	;DO SKIP RETURN
	TLNE FL2,BMOD	;A NAME NOT PERMITTED IN /B MODE
	POPJ P,
	MOVEI T1,TMPUSR
	PUSHJ P,READNM	;GET A FILE NAME
	POPJ P,
	TLNE FL2,RSW!SSW!BSW
	POPJ P,
	SKIPN NAMI+3	;ALSO PPN
	TRNN FL,TERMF
	POPJ P,
	TRO FL2,NEWFL
	MOVE T1,NAMI	;SET AS NAME
	MOVEM T1,ORGNAM
	MOVE T1,NAMI+1
	MOVEM T1,ORGEXT
	JRST CPOPJ1
END8:	OUTSTR [ASCIZ /
/]
END6:	MOVEI T1,[ASCIZ /NAME=/]
	PUSHJ P,GNCHGT
	PUSHJ P,NSCAN
	SKIPA
	JRST END7
	OUTSTR [ASCIZ /
?????
/]
	JRST END6	;YOU'RE GOING TO DO IT OVER AND OVER UNTIL
			;YOU GET IT RIGHT
FIU:	OUTSTR [ASCIZ /
FILE IN USE OR PROTECTED. TRY ANOTHER NAME
/]
	PUSHJ P,OFRPG
	JRST END8
INFCNF:	OUTSTR [ASCIZ /
SOMEONE ELSE EDITING THIS FILE. PICK ANOTHER NAME.
/]
	PUSHJ P,OFRPG
	JRST END8
SUBTTL SOME GENERAL PURPOSE STUFF

;SOME MORE GENERAL ROUTINES

INPLIN:	SKIPE LIBUF	;ZERO FOR NO PROMPT
	OUTSTR @LIBUF
	TRZ FL2,STOPI
	TLOA FL2,NOCTLU		;SET FLAG SO THAT LINE FEED CAN GET THROUGH
RDLIN:	TLZA FL2,NOCTLU		;LINE FEED MEANS CRLF IN THIS MODE
	TDZA C,C		;SET NULL AS FIRST CHARACTER
	MOVEI C,11	;FIRST CHR IS TAB
	SETZM LIBUF+1	;READ IN A LINE. FIRST ZERO INPUT BUFFER
	MOVE T1,[XWD LIBUF+1,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1
	MOVE T1,[POINT 7,LIBUF+1]	;SET UP POINTER
	MOVEI T2,5*MXWPL-2	;SET FOR AVAILABLE SPACE
	JRST RDL3
RDL0:	TLZ FL2,NOCTLU		;CLEAR FLAG WHEN RETURN IS SEEN (REAL CRLF)
RDL1:	PUSHJ P,GNCHL	;GET ANOTHER CHARACTER
	CAIN C,15	;IGNORE RETURN
	JRST RDL0
	CAIN C,12	;LINE FEED IS THE ONLY PROPER END
	JRST RDL2
	CAIN C,201
	JRST CTLR	;CONTROL R
	CAIN C,200	;ALTMODE IS A SPECIAL CASE
	JRST	[TLZ FL2,NOCTLU	;SO WE DON'T THINK A LINE FEED
		CAIN T2,5*MXWPL-3	;ANYTHING TYPED?
		JRST RDL4
		TRO FL2,STOPI	;YES, SET FLAG SO THIS ONE GETS IN
		JRST RDL2]	;TREAT AS CRLF
RDL3:	IDPB C,T1	;PUT IT IN THE BUFFER
	SOJGE T2,RDL1	;CHECK FOR OVERFLOW AND CONTINUE
	RERROR LTL	;LINE IS TOO LONG
	SKIPA T1,[POINT 7,LIBUF+1]	;JUST SET CRLF
RDL2:	AOS (P)		;SKIP RETURN (ENTER BELOW WITH ALTMODE)
RDL4:	MOVEI C,15	;PUT IN A CR-LF
	TLNN FL2,NOCTLU	;SO THAT LINE FEED GETS THROUGH
	IDPB C,T1
	MOVEI C,12
	IDPB C,T1
	HRRZS T1	;NOW GET THE SIZE
	SUBI T1,LIBUF-1
	POPJ P,		;AND RETURN

CTLR:	MOVEI C,15
	IDPB C,T1
	MOVEI C,12
	IDPB C,T1	;FILL IN END OF LINE
	HRRZS T1
	SUBI T1,LIBUF-1
	MOVEM T1,OCNT
	OUTSTR [ASCIZ /
/]
	PUSHJ P,STAL1
	TLC FL2,CTLUFL!NOCTLU	;REVERSE NORMAL SETTINGS
	PUSHJ P,ALTN1	;GO ALTER LINE
	 JRST CTLRA	;NON-SKIP RETURN, LIKE ALTMODE
CTLR1:	SETZM OCNT	;CLEAR THIS
	HRRZ T1,NCNT
	JRST CPOPJ1

CTLRA:	LDB T1,[POINT 7,LIBUF+1,13]	;GET FIRST CHR
	CAIE T1,15
	JRST	[TRO FL2,STOPI
		JRST CTLR1]	;SOMETHING LIKE ALTMODE BEFORE
	POPJ P,		;TAKE NON-SKIP RETURN FOR ALTMODE

GETLTH:	MOVE T1,PNTR	;GET THE LENGTH OF THE LINE POINTED AT
	ADDI T1,1
GETLN1:	SKIPN T2,(T1)	;ANY END IS GOOD ENOUGH
	JRST GETLN2
	TRNN T2,1	;SEQ-NUM?
	AOJA T1,GETLN1
GETLN2:	SUB T1,PNTR	;FIND LENGTH
	POPJ P,		;AND RETURN

OUTSN:	MOVEM T1,SQBUF	;PUT IT IN SPACE FOLLOWED BY A TAB
	TRNN FL2,ASUPN	;SUPPRESS LINE NUMBERS
	OUTSTR SQBUF
	POPJ P,

ASCIAD:	AND T2,K2A	;CONVERT TO NUMBERS
	IOR T1,K4A	;MAKE SURE THIS IS IN DIGIT FORM
	ADD T1,K1A	;GET EACH DIGIT IN RANGE 166 TO 177 FOR CARRY
	ADD T2,T1	;SUM
	AND T2,K3A	;GET RID OF 100 BITS IF THERE
	MOVE T1,K4A	;FIND OUT WHICH ONES NEED SUBTRACTING
	AND T1,T2
	ASH T1,-3	;CONVIENIENTLY THEY NEED 6 SUBTRACTED
	SUBM T2,T1	;SO DO IT
	IOR T1,K4A	;AND RECONVERT TO DIGITS
	POPJ P,		;WE HAVE ADDED THE ASCII IN T1 AND T2 RESULT IN T1

K1A:	BYTE (7) 106,106,106,106,106
K2A:	BYTE (7) 17,17,17,17,17
K3A:	BYTE (7) 77,77,77,77,77
K4A:	<ASCII /00000/>+1
K5A:	BYTE (7) 7,7,7,7,7
K6A:	BYTE (1) 1 (7) 77,77,77,77,77
K7A:	BYTE (1) 0 (7) 106,106,106,106,106

ASCAV:	AND T2,K2A
	IOR T1,K4A	;THIS ROUTINE AVERAGES 2 ASCII NUMERS
	LSH T1,-1
	ADD T1,K7A	;IT WORKS MOSTLY BY MAJIC
	LSH T2,-1
	ADD T2,T1
	AND T2,K6A
	MOVE T1,T2
	ANDCM T1,K3A
	AND T2,K3A
	MOVE T3,T2
	LSH T3,-3
	AND T3,K2A
	AND T2,K5A
	SUB T2,T3
	LSH T1,-4
	ADD T2,T1
	LSH T1,-2
	ADD T2,T1
	IOR T2,K4A
	POPJ P,

;CHECK TO SEE IF BUFFER TOO FULL AND DUMP IF NEEDED

FILLB:	MOVE T1,WC	;GET WORD COUNT
FILLB3:	CAMGE T1,MAXWC	;AND COMPARE WITH MAX PERMISSIBLE
	POPJ P,		;OK, SO RETURN
	MOVE T1,BUFP	;GET BUFFER POINTER
	ADDI T1,1
FILLB1:	SKIPN T2,(T1)	;FIND END OF FIRST LINE
	JRST FILLB2
	TRNN T2,1
	AOJA T1,FILLB1
FILLB2:	PUSHJ P,NOWFL	;PART OF GETN WILL DUMP AND ADJUST POINTERS
	JRST FILLB	;SEE IF IN LIMITS NOW

;INSERT A LINE (IN LIBUF) INTO PLACE POINTED AT BY PNTR
;WORD COUNT OF OLD LINE IN OCNT. OF NEW LINE IN NCNT

INSED:	MOVE T1,NCNT	;SEE HOW THE COUNTS DIFFER
	SUB T1,OCNT
	JUMPE T1,NOBLT	;THEY ARE SAME, NO MOVING NECESSARY
	JUMPG T1,BBLT	;NEW IS LARGER, BLT WILL NOT DO
	MOVE T2,PNTR	;SET UP BLT POINTER FROM PNTR+OCNT
	ADD T2,OCNT
	HRLS T2
	HRR T2,PNTR	;TO PNTR+NCNT
	ADD T2,NCNT
	ADDB T1,WC	;ADJUST WC TO OLD WORD COUNT +NCNT-OCNT
	ADD T1,BUFP	;LAST TRANSFERED IS BUFP+WC+NCNT-OCNT
	BLT T2,(T1)
NOBLT:	SKIPN T1,NCNT	;CHECK FOR 0 NEW COUNT (WE ARE DELETING)
	POPJ P,		;IF SO DONE
	MOVE T2,PNTR	;GET THE POINTER POSITION FOR BLT
	HRLI T2,LIBUF	;FROM LIBUF TO PNTR
	ADD T1,PNTR	;STOP AT PNTR+NCNT-1
	BLT T2,-1(T1)
	POPJ P,		;AND ALL DONE
BBLT:	MOVE T2,BUFP	;FAKE BACKWARDS BLT FROM BUFP+WC
	ADD T2,WC
	ADDB T1,WC	;TO BUFP+WC+NCNT-OCNT (ALSO FIX WC)
	ADD T1,BUFP
BBLT1:	CAMGE T2,PNTR	;STOP HERE (COULD STOP SOONER BUT THIS IS EASIER)
	JRST NOBLT	;AND GO MOVE IN NEW STUF
	MOVE T3,(T2)	;TRANSFER A WORD
	MOVEM T3,(T1)
	SUBI T1,1
	SOJA T2,BBLT1	;AND KEEP IT UP
SUBTTL INSERT ROUTINE

;INSERT A LINE

CRTINS:
	MOVEI T1,1	;SET UP TO START INSERTING AT LINE 100 PAGE 1
	MOVEM T1,HIPG
	MOVE T1,[<ASCII /00100/>+1]
	MOVEM T1,HILN
	JRST INSGO	;AND AWAY WE GO

INSERT:PUSHJ P,SCAN
	TRNE FL,TERMF	;CHECK FOR NO ARGUMENTS
	JRST	[MOVE T1,IPG
		MOVEM T1,HIPG
		MOVE T1,CURINS
		MOVEM T1,HILN
		MOVE T1,IINCR	;REMEMBERED INCREMENT
		MOVEM T1,TINCR
		JRST INSGO]	;GO BACK TO INSERTING WHERE YOU WERE
	PUSHJ P,GET10	;GET ONE LINE/PAGE NUMBER
	TRNN FL,LINSN	;WAS A LINE NUMBER SEEN
	NERROR ILC	;ERROR IF NOT
	CAIE C,","	;IF A COMMA, SET INCREMENT
	CAIN C,";"	;ALSO ALLOW ;
	SKIPA
	JRST NOINC	;NO, KEEP OLD ONE
	PUSH P,C	;SAVE IT FOR LATER
	PUSHJ P,SCAN	;GET THE NUMBER
	TRNE FL,NUMF	;WAS IT A NUMBER?
	CAMN T1,[<ASCII /00000/>+1]	;DO NOT PERMIT 0 INCR
	NERROR ILC	;HE WAS CONFUSED
	POP P,C	;GET ACTUAL CHR BACK
	CAIN C,","	;SET INCR ONLY IF COMMA
	MOVEM T1,INCR	;SET INCREMENT
	MOVEM T1,TINCR	;BUT ALWAYS SET TINCR
	PUSHJ P,SCAN	;SCAN PAST IT
NOINC:	TRNN FL,TERMF	;TERMINATOR?
	NERROR ILC	;LOSE
INSGO:	MOVE T1,HIPG	;GET THE PAGE TO GO TO
	MOVEM T1,DPG	;AND SET IT UP
	MOVE SINDEX,HILN	;ALSO LINE
	PUSHJ P,FIND	;GO GET UM
	MOVE T2,CPG	;DEMAND CORRECT PAGE MATCH
	CAME T2,HIPG
	NERROR NSP
	TRZ FL2,STOPI	;CLEAR FLAG
	CAMN T1,HILN	;ARE THEY MATCHING?
	JRST FIXINL	;GO MAKE UP A LINE NUMBER
INSLP:	SETZM OCNT
	MOVE T1,HILN	;TELL HIM THE LINE HE IS INSERTING
	MOVEM T1,LIBUF	;AND PUT IT IN THE BUFFER
	TRNN FL2,SUPOFL		;NOT IF READING @ FILE
	PUSHJ P,OUTSN	;PUT IT OUT
	PUSHJ P,RDLIN	;READ A LINE
	JRST LVINS	;YES, GET OUT OF INSERT MODE
	MOVEM T1,NCNT	;HERE IS THE COUNT OF THE NEW ONE
	PUSHJ P,INSED	;GO INSERT
	PUSHJ P,FINDN	;MOVE UP A LINE
	PUSHJ P,FILLB	;AND DUMP SOME IF NECESSARY
	MOVE T1,CPG	;SET CURRENT LINE AND PAGE TO LAST
	MOVEM T1,CPGL	;ONE REALLY INSERTED
	MOVE T1,HILN
	MOVEM T1,CLN
	TRNE FL2,STOPI	;IF FLAG HAS GOTTEN SET
	JRST LVINS	;THEN QUIT
	MOVE T2,TINCR	;GET NEXT LINE TO INSERT
	PUSHJ P,ASCIAD
	CAMG T1,TINCR	;HAVE WE WRAPED AROUND
	JRST COMND	;YES, STOP
	MOVEM T1,HILN	;STORE FOR REFERENCE
ENTINS:SKIPN T1,(PNTR)	;GET THE LINE POINTED TO
	JRST INSLP	;ALWAYS INSERT AT END OF FILE
	CAME T1,PGMK	;OR AT END OF PAGE
	CAMLE T1,HILN	;HAVE WE FOUND A MATCH OR PASSED OVER A LINE?
	JRST INSLP	;NO, INSERT
	JRST COMND	;RETURN TO COMMAND
LVINS:	MOVE T1,HILN
	MOVEM T1,CURINS		;SET PLACE TO INSERT NEXT TIME
	MOVE T1,CPG
	MOVEM T1,IPG
	MOVE T1,TINCR	;SAVE INCREMENT FOR LATER I COMMAND
	MOVEM T1,IINCR
LEVINS:TRNN FL2,SUPOFL
	OUTSTR [ASCIZ /
/]
	JRST COMND
FIXINL:	MOVE T2,TINCR	;SET TO ADD INCR
	PUSHJ P,ASCIAD	;ADD
	PUSH P,T1	;SAVE RESULT
	PUSHJ P,FINDN	;GET THE NEXT ONE
	POP P,T2
	CAMG T2,HILN	;IS THERE A WAR PROBLEM
	JRST INCBAD		;YES, WE MUST TRY TO COMPUTE ONE
	JUMPE T1,INCOK	;END OF FILE, ANY INC IS OK
	CAME T1,PGMK	;ALSO OK IF A PAGE MARK
	CAMGE T2,T1	;OR IN CORRECT ORDER
	JRST INCOK
INCBAD:	CAME T1,PGMK
	SKIPN T1
	MOVE T1,[<ASCII /9999:/>+1]	;ONE OVER THE TOP OF THE WORLD
	MOVE T2,HILN	;GET CURRENT
	PUSHJ P,ASCAV	;FIND AVERAGE
	CAME T2,HILN	;THERE MAY HAVE ONLY BEEN A DIF OF 1
	JRST INCOK	;ALL IS WELL
	NERROR ILR
INCOK:	MOVEM T2,HILN
	JRST INSLP
SUBTTL DELETE ROUTINE

;DELETA A LINE, A NUMBER OF LINES, OR A PAGE MARK

DELETE:SETZM LOLN	;JUST AS A START
	PUSHJ P,GET2S	;GET TWO PAGE-LINE PAIRS
	TRNN FL,PGSN	;ONLY ON IF A SECOND PAGE SPEC
DELT1:	TRNN FL,TERMF	;CHECK FOR TERMINATOR
	NERROR ILC
	TRZN FL,LINSN	;LINE NUMBER SEEN?
	JRST DELPG	;NO, MUST BE /A. DELETE PAGE MARK A
	MOVE T1,HIPG	;GET THE PAGE NUMBER
	MOVEM T1,DPG
	MOVE SINDEX,LOLN	;AND LINE
	PUSHJ P,FIND
DELT2:	CAME T1,PGMK	;ARE WE AT A PAGE MARK?
	PUSHJ P,ONMOV	;CHECK FOR RANGE
	JRST DELEND
	MOVEM T1,CLN	;MARK AS CURRENT LINE
	MOVE T1,CPG	;YES, SET CURRENT PAGE
	MOVEM T1,CPGL
	TRO FL,LINSN	;AND ALSO THAT WE DID SOMETHING
	PUSHJ P,DODEL	;GO DO A LINE DELETE
	PUSHJ P,FINDN1	;FIND NEXT BUT ACCEPT LINE IF ALREADY THERE
	JRST DELT2	;GO DO NEXT

DELEND:	TRNN FL,LINSN!RENSN	;DID WE SEE ANYTHING?
	NERROR NLN	;NO, GIVE ERROR
	MOVE T1,CPG	;YES, SET CURRENT PAGE
	MOVEM T1,CPGL
	JRST COMND	;AND GET NEXT COMMAND

DELPG:	MOVE T1,HIPG	;GET THE DESIRED PAGE TO DELETE
	MOVEM T1,DPG	;SET IT
	SOJLE T1,DELER	;DO NOT TRY PAGE 1
	MOVEI SINDEX,0	;GUARENTEED TO FIND LINE IMMEDIATELY AFTER PAGE MARK
	PUSHJ P,FIND	;GET IT
	MOVE T2,CPG	;CHECK FOR MATCH
	CAME T2,HIPG
DELER:	NERROR NSP	;NO SUCH PAGE
	PUSHJ P,FINDB	;GO BACK ONE
	CAME T1,PGMK	;IS IT A PAGE MARK?
	ERROR ICN	;CONFUSED, GIVE FATEL ERROR
	PUSHJ P,FINDB	;BACK UP
	CAMN T1,PGMK
	AOS CPG		;FINDB HAS DEC THIS AND WE WILL GO FWD
	MOVEM T1,SVWD3	;AND SAVE PREVIOUS LINE
	SKIPE T1	;IF 0 THEN START OF FILE, DON'T ADVANCE
	PUSHJ P,FINDN	;BACK TO WHERE WE WERE
	MOVEI T1,2	;COUNT IS 2
	MOVEM T1,OCNT
	SETZM NCNT	;AND NEW IS 0
	PUSHJ P,INSED
	SOS BGPG	;MAX PAGE IS NOW 1 LOWER
	SOS INPG
	PUSHJ P,FINDN1	;GET THE NEXT LINE
	JUMPE T1,COMND	;IF EOF THERE IS NO ORDER ERROR
	CAMN T1,PGMK	;OR IF A PAGE MARK
	JRST COMND
	EXCH T1,SVWD3#
	JUMPE T1,COMND	;START OF FILE, ALL OK
	CAME T1,PGMK	;ANOTHER PAGE MARK
	CAMGE T1,SVWD3	;CHECK THE ORDER
	JRST COMND	;ALL OK
	NERROR ORDER	;ALL WRONG
SUBTTL INSERT PAGE MARK

;INSERT A PAGE MARK AT DESIGNATED LINE

MARK:	SETZM HILN	;IN CASE OF /A
	PUSHJ P,GET1S	;GET ONE LINE/PAGE NUMBER
	TRNN FL,TERMF	;CHECK FOR TERMINATOR
	NERROR ILC
	MOVE T1,HIPG	;GO LOOK FOR IT
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;AND THE LINE
	PUSHJ P,FIND	;GET IT
	MOVE T1,CPG
	CAME T1,HIPG	;PAGE MUST MATCH
	NERROR NSP	;MUST MATCH
	AOS T1,CPG	;WILL BE ON HIGHER PAGE WHEN DONE
	MOVEM T1,CPGL	;SET UP LOGICAL PAGE
	AOS BGPG	;THERE IS NOW ONE MORE
	AOS INPG
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,CLN	;FIRST LINE ON THAA PAGE
	MOVE T1,PGMK	;PUT A PAGE MARK IN LIBUF
	MOVEM T1,LIBUF
	MOVE T1,[BYTE (7) 15,15,14]	;TEXT OF A PAGE MARK
	MOVEM T1,LIBUF+1
	SETZM OCNT	;THIS IS A STRAIGHT INSEET
	MOVEI T1,2	;OF 2 WORDS
	MOVEM T1,NCNT
	PUSHJ P,INSED	;GO DO IT
	PUSHJ P,FINDN	;SINCE FILLB MAY WANT TO DUMP THIS LINE
	PUSHJ P,FILLB
	JRST COMND	;ALL DONE
SUBTTL RENUMBER

;RENUMBER SELECTED LINES

NUMBER:PUSHJ P,SCAN	;GET THE RENUMBER INCREMENT
	TRNE FL,NUMF	;WAS IT A NUMBER
	CAMN T1,[<ASCII /00000/>+1]	;NO 0 RENUMBER INCR
	NERROR ILC
	MOVEM T1,REINC#	;THE INCREMENT TO USE
	MOVEM T1,INCST#	;LINE TO START WITH
	PUSHJ P,SCAN	;SCAN PAST NUMBER
	CAIE C,","	;AND CHECK FOR COMMA
	NERROR ILC	;LOSE
	SETZM LOLN	;GET THIS SET TO START THINGS OFF
	PUSHJ P,GET2S	;GET A RANGE
	CAIE C,","	;SEE IF THERE IS A FOURTH ARGUMENT
	JRST NUMBL	;NO
	PUSHJ P,SCAN	;YES, GET IT
	TRNN FL,NUMF	;IS IT A NUMBER?
	NERROR ILC	;HE WOULD HAVE BEEN BETTER OFF WITHOUT IT
	MOVEM T1,INCST	;USS AS STARTING NUMBER
	PUSHJ P,SCAN	;SCAN PAST IT
NUMBL:	TRNN FL,TERMF	;ENDS PROPERLY?
	NERROR ILC	;LOSE
	MOVE T1,LOPG	;GET PLACE TO START
	MOVEM T1,DPG
	MOVE SINDEX,LOLN	;AND LINE
	PUSHJ P,FIND	;GET IT
	TRZ FL,LINSN!ORDF	;SET TO NONE SEEN AND NO ORDER ERROR
	PUSHJ P,FINDB	;BACK UP AND SEE HOW ORDER LOOKS
	JUMPE T1,NUMB5	;START OF FILE IT MUST BE OK
	CAME T1,PGMK	;ALSO IF A PAGE MARK
	CAMGE T1,INCST	;OR IF IN CORRECT ORDER
	SKIPA
	TRO FL,ORDF	;WRONG SET FLAG
NUMB5:	PUSHJ P,FIND	;GET THE CORRECT LINE BACK
NUMB2:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST NUMB3
	CAMN T1,PGMK	;PAGE MARK?
	JRST NUMB4	;SPECIAL TREATMENT
	MOVE T1,INCST	;GET STAATING NUMBER
	MOVE T2,REINC	;AND INCREMENT
	TRON FL,LINSN	;WAS A LINE SEEN?
	JRST FSTLIN	;NO, FIRST ONE IS SPECIAL
	PUSHJ P,ASCIAD	;SKIP THIS THE FFRST TIME
	CAMGE T1,REINC	;HAVE WE WRAPED
	JRST	[RERROR WAR	;TELL HIM HE LOST
		MOVE T2,CPG	;PRINT THE PAGE
		PUSHJ P,PGPRN
		JRST .+1]	;RETURN
FSTLIN:	MOVEM T1,INCST	;SAVE FOR NEXT LINE
	MOVEM T1,CLN	;AND THE CURRENT LINE
	MOVEM T1,(PNTR)	;PUT IT IN
	MOVE T1,CPG
	MOVEM T1,CPGL	;REMEMBER THIS PAGE
	PUSHJ P,FINDN	;GET NEXT
	JRST NUMB2	;AND GO RANGE CHECK

NUMB3:	TRNN FL,LINSN!RENSN	;DONE, WAS THERE SOMETHING THERE?
	NERROR NLN	;NO,  NULL RANGE ERROR
	TRNE FL,ORDF	;WAS THERE AN ORDER ERROR?
	NERROR ORDER	;YES, FLAG IT
	JUMPE T1,COMND	;CHECK TO SEE IF LOSAGE NOW
	CAME T1,PGMK
	CAMLE T1,INCST
	JRST COMND
	NERROR ORDER

NUMB4:	AOS T1,CPG		;NOW ON A HIGHER PAGE
	MOVEM T1,CPGL	;REMEMBER IT
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,CLN	;SET TO FIRST LINE ON PAGE
	TRO FL,LINSN	;WE SAW ONE
	SETZM INCST	;START OVER ON NUMBERS
	PUSHJ P,FINDN	;PAGE MARK, GET THE NEXT LINE
	JRST NUMB2
SUBTTL ALTER COMMAND

ALTER:	SETZM LOLN	;FOR START OF PAGE
	PUSHJ P,GET2S	;GET THE RANGE
	TRNN FL,TERMF	;CHECK FOR PROPER END
	NERROR ILC	;UNEND
	MOVE T1,LOPG	;START TO PROCESS
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GO GET IT
	TRZ FL,LINSN	;NOT SEEN YET
ALT1:	PUSHJ P,ONMOV	;CHECK FOR IN RANGE
	JRST ALT2	;NO, FINISH UP
	TRO FL,LINSN	;WE DID SEE SOMETHING
	CAMN T1,PGMK	;CHEC FOR A PAGE
	JRST ALT3	;DO NNT TRY TO CHANGE THIS
	MOVEM T1,CLN	;NOW, IN CASE WE SAID ALTMODE
	MOVE T1,CPG	;SAME FOR PAGE
	MOVEM T1,CPGL
	PUSHJ P,ALTLIN	;GO DO THE ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;GO INSERT
ALT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	PUSHJ P,FILLB	;AND CHECK FOR BUFFER OVERFLOW
	MOVE T1,(PNTR)	;GET LINE FOR ONMOV
	JRST ALT1	;CONTINUE LOOP
ALT3:	AOS T2,CPG	;WE ARE ON A LATER PAGE NOW
	MOVEM T2,CPGL	;SAVE AS .
	PUSHJ P,PGPRN	;PRINT HIM A MESSAGE
	MOVE T1,[<ASCII /00000/>+1]	;SET TO FIRST? LINE
	MOVEM T1,CLN	;FOR .
	JRST ALT4	;CONTINUE PAST IT
ALT2:	TRNN FL,LINSN!RENSN	;WAS THERE ANYTHING THERE?
	NERROR NLN	;NO, GIVE ERROR
	JRST COMND	;GO

INTEGER SVALTP,DDTINP
ALTLIN:PUSHJ P,SETALT	;SET UP LINE FOR ALTERATION
ALTN1:
ALTLP2:	MOVEI T2,0	;ZERO REPEAT COUNT
ALTLP:	TRZ FL2,ALTDUP	;TURN DUPLEXING BACK OFF
	PUSHJ P,GNCH1	;GET ON CHR IN DDT SUBMODE
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TRZ C,40	;AND CONVERT TO UPPER CASE
	CAIG C,"9"
	CAIGE C,"0"
	SKIPA
	JRST ALTDG	;SPECIAL CHACK ON DIGITS
	MOVE T1,[XWD -ALTLG,ALTAB1]
	PUSHJ P,ISRCH	;GO FIND THE INSTRUCTION
	JRST	[OUTCHI 7	;NOT A LEGAL ONE
		SETZM BUFPTR
		JRST ALTLP2]
	PUSHJ P,(T1)
	JRST ALTLP2
	JRST ALTLP	;ALTMKN AND ALTTXT COME HERE WITH T2 LOADED

ALTAB1:	TBCOD " ",ALTSP
	TBCOD "M",ALTMLT
	TBCOD "I",ALTIN
	TBCOD "D",ALTDL
	TBCOD "S",ALTSR
	TBCOD "K",ALTKL
	TBCOD "Q",ALTALT
	TBCOD 12,ALTFN
	TBCOD "C",ALTCN
	TBCOD 177,ALTBS
	TBCOD "U"-100,ALTCU
	TBCOD "R",ALTRP
	TBCOD "L",ALTLN
	TBCOD "P",PRINTA
	TBCOD "J",JOINA
	TBCOD "X",ALTXPG
	TBCOD "W",ALTWDS
	TBCOD "F",ALTSR
	TBCOD "B",BALTIN
	TBCOD "<",ALTLC
	TBCOD ">",ALTUC
	TBCOD "N",ALTMKN
	TBCOD "T",ALTTXT
	TBCOD "E",ALTXCH
	TBCOD 15,CPOPJ	;FAKE CRLF
ALTLG==.-ALTAB1

SETALT:	SETZM LIBUF	;ZERO OUT INTERNAL LINE BUFFER
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET POINTER TO TRANSFER
	MOVE T2,PNTR
	MOVE T3,(T2)	;GET THE FIRST WORD (SEQ NUM)
	JRST SALT3
SALT2:	SKIPE T3,(T2)	;PICK UP A WORD AND CHECK FOR 0
	TRNE T3,1	;CHECK FOR SEQ NTM
	JRST SALT1	;END OF THIS LINE
SALT3:	MOVEM T3,(T1)	;SAVE IT AWAY
	ADDI T1,1	;INCREMENT POINTERS
	AOJA T2,SALT2
SALT1:	SUBI T1,LIBUF	;GET COUNT OF OLD LINE
	HRRZM T1,OCNT	;AND SAVE IT FOR INSED
STAL1:	TLZ FL2,NOCTLU	;ALLOW CONTROL U
	TLO FL2,CTLUFL	;SET FLAG SO INSCR AND J WORK
STAL2:	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP POINTER
	SETZM ALTCNT	;SO FAR WE ARE 0 CHRS INTO LINE
IFN STANSW,<SETSTS TTY,601>
IFE STANSW,<SETSTS TTY,202	;TURN OFF DUPLEXING>
	TRZ FL2,RUBF!ALTDUP!RUBF2	;TURN OFF IN RUBOUT FALG AND NO DUPLEXING
	SETZM ALTFLG	;NOTHING INSERTED SO FAR
	MOVE T1,LIBUF	;PRINT LINE NUMBER AND TAB
	TLNE T1,-1	;SEE IF THIS IS A POINTER
	JRST OUTSN
	OUTSTR (T1)
	POPJ P,
	DEFINE OFFRUB
<	TRZE FL2,RUBF2
	OUTSTR [ASCII /\\/]
	TRZE FL2,RUBF
	OUTCHR ["\"]>
	DEFINE ONRUB
<	TRNE FL,DPYF
	JRST .+5	;IGNORE FOR DPY
	TRZE FL2,RUBF2
	OUTSTR [ASCII /\\/]
	TRON FL2,RUBF
	OUTCHR ["\"]>

GNCH1A:	PUSHJ P,RD1CHR
IFN STANSW,<ANDI C,177>
	CAIN C,"B"-100
	JRST RD1BST
	CAIE C,33	;NEVER DUPLEX ALTMODE
GNCH1C:	TRNN FL2,ALTDUP	;AND NOT UNLESS DESIRED
	POPJ P,
	CAIE C,12	;NOT LINE FEED
	CAIN C,15	;OR RETURN
	POPJ P,
	CAIN C,177	;AND FINALLY IGNORE RUBOUT
	POPJ P,
	OFFRUB		;IF WE ARE DUPLEXING WE ARE NOT DELETING
	CAIE C,4	;DON'T PUT OUT EOT
	OUTCHR C	;TYPE
	POPJ P,

GNCH1:	PUSHJ P,GNCH1A	;GET A CHR IN DDT MODE
	CAIL C,240
	JRST	[SUBI C,240
		JRST GNCH1B]
	CAIE C,4		;TREAT ^D AS ALTMODE FRO TYMEX
	CAIN C,33	;CONVERT ALTMODE TO 200
	MOVEI C,200
	TLNN FL,QMODF
	CAIE C,"?"	;CHECK FOR QUESTION MARK
	JRST GNCH1B	;NO, THIS CHR IS OK
	PUSHJ P,GNCH1A	;GET ANOTHER
	SKIPE CTBL(C)	;IF 0 HN CTBL, KEEP IT
	MOVS C,CTBL(C)	;GET ALTERNATE CODE
	ANDI C,177	;GET RID OF EXTRA BITS
GNCH1B:	MOVE CS,CTBL(C)	;LOAD CS
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TDC C,CASEBT	;AND APPLY CASE CONVERRION
	POPJ P,		;ALL DONE

RD1CLS:	SETZM BUFPTR
RD1CHR:	SKIPE BUFPTR
	JRST RD1BUF
	TRNE FL2,RPGFLG
	PUSHJ P,GNCHD
	INCHRW C
	TRNN FL,DPYF
	ANDI C,177
	POPJ P,

RD1BUF:	ILDB C,BUFPTR
	JUMPE C,RD1CLS
	POPJ P,

RD1BST:	PUSHJ P,RD1CHR
	PUSHJ P,BUFSET
	JRST GNCH1A	;AND GET THE NEXT CHR

ALTDG:	IMULI T2,^D10	;ACCUMULATE REPEAT COUNT
	ADDI T2,-"0"(C)
	JRST ALTLP	;SPECIAL RETURN FROM HERE

ALTSP:	MOVEI T3,OCHR	;ROUTINE TO CALL FOR SPACE
ALTMVC:	OFFRUB	;COMMON ADVANCE POINTER CODE, SPACE, LC, UC
ALTMC1:	LDB C,ALTP	;GET THE CHR WE ARE POINTING AT
	CAIN C,15	;IF RETURN THEN AS FAR AS CAN GO
	POPJ P,		;SO QUIT
	PUSHJ P,(T3)	;DO IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTMC1	;DO CORRECT NUMBER OF TIMES
	POPJ P,

BALTIN: TLOA FL2,BINS		;SET FLAG TO ALLOW INS CR
ALTIN:	TLZ FL2,BINS
	TRO FL2,ALTDUP	;TURN ON DUPLEXING
	MOVEM T2,ALTINC	;SAVE IN CASE HE INSERTS A RETURN
ALTIN1:	PUSHJ P,GNCH1	;GET A CHARACTER
	CAIN C,15	;IGNORE RETURN
	JRST ALTIN1
	CAIN C,12	;FINISH ON LINE FEED OR ALTMODE
	JRST INSCR	;GO INSERT A CRLF
	CAIN C,200
	POPJ P,		;GO AWAY
	CAIN C,177	;CHECK FOR BACKSPACE
	JRST ALTIBS	;AND DELETE CHR TO LEFT
	MOVE T3,ALTP	;GET SET TO SHIFT THINGS
	PUSH P,ALTCNT	;SAVE THIS FOR LATER
	LDB T1,T3	;GET CHR FROM LINE
ALTIN2:	DPB C,T3	;SHIFT LINE
	JUMPE C,ALTIN3	;DONE
	AOS ALTCNT	;COUNT IT
	ILDB C,T3
	DPB T1,T3
	JUMPE T1,ALTIN3	;DONE
	AOS ALTCNT	;COUNT
	ILDB T1,T3
	JRST ALTIN2
ALTIN3:	MOVE T2,ALTCNT	;SEE IF OVERFLOW HAPPENED
	CAIL T2,MXWPL*5
	NERROR LTL	;YES
	POP P,ALTCNT	;RESTORE OLD COUNT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	JRST ALTIN1	;GO GET MORE


INTEGER ALTINC

INSCR:	OFFRUB
	OUTSTR [ASCIZ /
/]
	TLNE FL2,BINS
	TLNN FL2,CTLUFL	;OFF ONLY IF FROM S(MANY) AND NO CTLU
	JRST	[RERROR ILC	;GIVE ERROR
		JRST NOINCA]	;AND DO NOT INSERT
	SKIPN T1,ALTINC	;DID HE SPECIFY AN INCREMENT?
	SKIPA T3,INCR	;NO, USE STANDARD
	PUSHJ P,ASCON	;CONVERT TO ASCII
	MOVE T1,T3	;FIND THE NEW LINE NUMBER
	MOVE T2,LIBUF	;CURRENT ONE
	PUSHJ P,ASCIAD	;ADD
	PUSH P,T1	;SAVE RESULT
	PUSHJ P,FINDN	;GET THE NEXT ONE
	POP P,T2
	CAMG T2,LIBUF	;IS THERE A WAR PROBLEM
	JRST INCBDA		;YES, WE MUST TRY TO COMPUTE ONE
	JUMPE T1,INCOKA	;END OF FILE, ANY INC IS OK
	CAME T1,PGMK	;ALSO OK IF A PAGE MARK
	CAMGE T2,T1	;OR IN CORRECT ORDER
	JRST INCOKA
INCBDA:	CAME T1,PGMK
	SKIPN T1
	MOVE T1,[<ASCII /9999:/>+1]	;ONE OVER THE TOP OF THE WORLD
	MOVEM T2,LIBUF2	;SAVE IN CASE NOTHING WILL WORK
	MOVE T2,LIBUF	;GET CURRENT
	PUSHJ P,ASCAV	;FIND AVERAGE
	CAME T2,LIBUF	;THERE MAY HAVE ONLY BEEN A DIF OF 1
	JRST INCOKA	;ALL IS WELL
	RERROR ORDER	;TELL HIM
	PUSHJ P,FINDB		;GET BACK WHERE WE BELONG
NOINCA:	PUSHJ P,ERCOR		;TYPE OUT LINE TO CURRENT POINT
	JRST ALTIN1		;AND CONTINUE INSERT
INCOKA:	MOVEM T2,LIBUF2	;SAVE IT
	MOVEM T2,CLN	;AND SET AS CURRENT LINE
	PUSHJ P,FINDB	;BACK UP TO WHERE WE BELONG
	MOVE T1,[XWD LIBUF+1,LIBUF2+1]
	BLT T1,LIBUF2+MXWPL+1	;SAVE OLD BUFFER
	PUSH P,ALTP	;SAVE POINTER
	MOVEI C,15
	DPB C,ALTP	;AND TERMINATE THIS LINE
	MOVEI C,12
	IDPB C,ALTP
	MOVEI C,0	;FILL OUT LINE WITH NULLS
INSC2A:	TLNN ALTP,760000
	JRST INSC3A
	IDPB C,ALTP
	JRST INSC2A
INSC3A:	SUBI ALTP,LIBUF-1	;FIND COUNT
	HRRZM ALTP,NCNT
	PUSHJ P,INSED	;REPLACE OLD LINE
	PUSHJ P,FINDN	;MOVE UP TO NEXT
	PUSHJ P,FILLB	;AND DUMP IF OVERFLOW
	SETZM OCNT	;THIS IS A NEW LINE GOING IN
	MOVE T1,LIBUF2	;MOVE LINE NUMBER OVER
	MOVEM T1,LIBUF
	SETZM LIBUF+1
	MOVE T1,[XWD LIBUF+1,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1	;ZERO OUT REST
	POP P,T2	;RESTORE POINTER TO REST OF LINE
	MOVE ALTP,[POINT 7,LIBUF+1]	;DEST POINTER
	ADD T2,[70000000000+LIBUF2-LIBUF]	;ADJUST INPUT POINTER
	MOVEI C,11	;AND SET UP THE TAB
MOVNEW:	IDPB C,ALTP
	CAIN C,12
	JRST DONNEW	;FINISHED MOVING REST OF LINE
	ILDB C,T2	;PICK UP ONE
	JRST MOVNEW
DONNEW:	SUBI ALTP,LIBUF-1	;GET COUNT
	HRRZS ALTP
	MOVEM ALTP,NCNT
	PUSH P,ALTP	;AND SAVE
	PUSHJ P,INSED	;INSERT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP FOR ALTER
	SETZM ALTCNT
	POP P,OCNT	;SET FOR OLD COUNT
	MOVE T1,LIBUF
	PUSHJ P,OUTSN
	SETOM ALTFLG	;WE HAVE INSERTED AND ALTALT SHOULD CALL FILLB
	JRST ALTIN1	;AND CONTINUE INSERTING
	POPJ P,
ALTIBS:	MOVEI T2,0	;SET COUNT TO 0
	MOVEM ALTP,SVALTP	;SAVE POINTER
	PUSHJ P,ALTBS	;DO A BACKSPACE
	EXCH ALTP,SVALTP	;GET BACK AND SAVE CURRENT
	PUSHJ P,ALTDL3	;DELETE THAT CHR
	JRST ALTIN1	;GET MORE
INTEGER ALTFLG

ALTDL:	MOVEM ALTP,SVALTP	;SAVE CURRENT POINTER POSITHON
	MOVEI T3,0
ALTDL1:	LDB C,ALTP	;GET CURRENT CHR
	CAIN C,15	;AT END OF LINE?
	JRST ALTDL5	;YES, GO FINISH OFF
	CAILE T2,3	;FEWER THAN 3 MORE TO DELETE
	JRST ALTDL6
	TRNE FL,DPYF
	AOJA T3,ALTDL7
	PUSH P,C
	MOVEI C,"\"
	TRNN FL2,RUBF2
	PUSHJ P,OCHR
	TRZE FL2,RUBF
	PUSHJ P,OCHR
	TRON FL2,RUBF2
	PUSHJ P,OCHR
	POP P,C
ALTDL7:	PUSHJ P,OCHR
ALTDL6:	IBP ALTP	;ADVANCE POINTER
	SOJG T2,ALTDL1	;CHECK COUNT AND CONTINUE
ALTDL5:	SKIPLE T3
	OUTCHI 10
	SOJG T3,.-1
ALTDL3:	MOVE T3,SVALTP	;GET BACK POINTER
ALTDL4:	LDB C,ALTP	;MOVE LINE DOWN
	DPB C,T3
	JUMPE C,ALTDL2	;DONE?
	IBP ALTP	;ADVANCE POINTERS
	IBP T3
	JRST ALTDL4
ALTDL2:	MOVE ALTP,SVALTP	;RESTORE POINTER AGAIN
	POPJ P,		;AND LEAVE

PRINTA:	PUSH P,ALTCNT#	;SAVE CURRENT COUNT
	PUSHJ P,ALTLN	;PRINTA REST OF LINE AND START OVER
	POP P,T2	;GET BACK COUNT
	CAILE T2,0	;AND SPACE IF NOT 0
	JRST ALTSP
	POPJ P,

ALTSR:	OFFRUB
	PUSHJ P,ALTCS	;CALL COMMON SEARCH ROUTINE
	JUMPN T2,ALTSP
	POPJ P,

ALTCS:	PUSHJ P,GNCH1
	PUSH P,[0]
	PUSH P,T2
	MOVEI T2,1	;CREATE A REPEAT COUNT
	LDB T3,ALTP	;CHEC TO SEE IF AT END OF LINE
	CAIN T3,15
	JRST BPOPJ
	MOVE T1,ALTP	;GET A COPY OF THE POINTER
ALTCS1:	ILDB T3,T1	;GET A CHARACTER
	CAIN T3,15
	JRST BPOPJ
	CAME T3,C
	AOJA T2,ALTCS1	;ELSE KEEP COUNT AND KEEP LOOKING
	ADDM T2,-1(P)
	MOVEI T2,1
	SOSLE (P)
	JRST ALTCS1
	JRST T2POP2

ALTKL:	PUSHJ P,ALTCS
	JUMPN T2,ALTDL
	POPJ P,

BPOPJ:	OUTCHI 7
	SETZM BUFPTR	;ALSO CLEAR BUFFER STUFF
T2POP2:	POP P,T2
T2POPJ:	POP P,T2	;NEED TO CLEAR STACK
	POPJ P,

ALTLC:	JSP T3,ALTMVC	;LOAD T3 AND GET TO COMMON CURSOR MOVE ROUTINE
	CAIG C,"Z"	;FUNCTION TO PERFORM
	CAIGE C,"A"
	JRST OCHR
	ADDI C,40
	DPB C,ALTP
	JRST OCHR

ALTUC:	JSP T3,ALTMVC
	CAIG C,"z"	;TEST FOR LOWER CASE
	CAIGE C,"a"
	JRST OCHR
	SUBI C,40
	DPB C,ALTP
	JRST OCHR

ALTMKN:	PUSHJ P,ALTCS
	JUMPN T2,CPOPJ1
	POPJ P,		;NOTHING JUST RETURN

ALTTXC:	PUSH P,[0]
	PUSH P,T2	;SAVE COUNT
	MOVE T3,[POINT 7,MULBUF]
	MOVEI T1,MXWPL*5
RDLP:	PUSHJ P,GNCH1
	CAIN C,200
	JRST FINRD	;DONE ON ALTMODE
	CAIN C,15
	JRST RDLP	;IGNORE CR
	CAIN C,12
	JRST BPOPJ	;GIVE ERROR
	IDPB C,T3
	SOJG T1,RDLP
	JRST BPOPJ	;TOO LONG A STRING

FINRD:	CAIE T1,MXWPL*5	;DID WE SEE ANY?
	JRST FINRD1	;YES
	ILDB C,T3	;MUST STILL POINT TO START
	JUMPE C,BPOPJ	;SHOULD NOT BE NULL
	JRST MULCNT	;USE OLD STRING
FINRD1:	MOVEI C,0
	IDPB C,T3
MULCNT:	MOVEI T2,1
	LDB C,ALTP
	CAIN C,15
	JRST BPOPJ
	MOVE T1,ALTP	;SET TO SAVE POINTER IN CASE WRONG
MULSR2:	LDB T3,[POINT 7,MULBUF,6]	;FIRST CHR
	JUMPE T3,BPOPJ	;NULL STRING IS ERROR
MULCS1:	ILDB C,T1
	CAIN C,15
	JRST BPOPJ
	CAME C,T3
	AOJA T2,MULCS1	;CONTINUE SEARCH FOR FIRST LETTER
	MOVEM T1,MULP2#	;SAVE STRING POINTER TO START
	MOVE T3,[POINT 7,MULBUF,6]
	MOVEM T3,MULP1#
MULSRC:	ILDB T3,MULP1
	JUMPE T3,MULFND	;FOUND IT
	ILDB C,MULP2	;CHEC WITH REGULAR STRING
	CAME C,T3
	AOJA T2,MULSR2
	JRST MULSRC	;CONTINUE CHECKING

MULFND:	ADDM T2,-1(P)
	MOVEI T2,1	;TRY AGAIN IF MULTIPLE COUNT
	SOSLE (P)
	JRST MULSR2	;MORE
	JRST T2POP2	;DONE

ARRAY MULBUF[MXWPL]

ALTMLT:	OFFRUB
	PUSHJ P,ALTTXC
	JUMPN T2,ALTSP
	POPJ P,

ALTTXT:	PUSHJ P,ALTTXC
	JUMPN T2,CPOPJ1
	POPJ P,

ALTXCH:	MOVE T3,ALTP
	LDB T1,T3
	ILDB C,T3
	CAIE T1,15
	CAIN C,15
	JRST XCHBEL
	DPB T1,T3	;INTERCHANGE
	DPB C,ALTP
	PUSH P,T2
	MOVEI T2,2
	PUSHJ P,ALTSP
	POP P,T2
	SOJG T2,ALTXCH	;WHO KNOWS WHY HE WOULD SAY THAT
	POPJ P,

XCHBEL:	OUTCHI 7
	SETZM BUFPTR
	POPJ P,


ALTWS:	MOVEI T2,0	;GET NUMBER OF LEADING SPACES TO SKIP
	MOVE T1,ALTP	;COPY POINTER
	LDB T3,T1	;CHECK FOR END OF LINE
SPLOP:	CAIN T3,15
	JRST ALTSP	;GO SPACE REQUIRED NUMBER
	SKIPE CTBL(T3)	;TAB OR SPACE
	JRST SKPNSP	;GO SKIP NON-SEPERATORS
	ILDB T3,T1	;GET NEXT
	AOJA T2,SPLOP	;COUNT AND CONTINUE
SKPNSP:	JUMPE T2,GETNSP	;IF NO SPACES
	PUSH P,T3
	PUSHJ P,ALTSP	;DON'T SKIP OVER THEM
	POP P,T3
GETNSP:	MOVEI T2,0	;RESET COUNT
NSPLP:	SKIPG T3,CTBL(T3)	;IF LETTER
	TDNE T3,SEPFLG	;OR NONSEPERATOR
	AOJA T2,CHRADV	;THEN COUNT CHR AND ADVANCE TO NEXT
	JUMPN T3,CPOPJ	;IF NOT SPACE OR TAB, STOP NOW
	ADDI T2,1	;COUNT THIS SPACE
FSPLP:	ILDB T3,T1	;SKIP OVER TRAILNING SPACES
	CAIE T3,15	;CEEP WATCHING FOR END OF LINE
	SKIPE CTBL(T3)	;IF END OR NOT SPACE(TAB)
	POPJ P,	;GIVE UP
	AOJA T2,FSPLP	;ELSE GO ON
CHRADV:	ILDB T3,T1	;NXT
	CAIE T3,15	;CHECK FOR END
	JRST NSPLP	;ONWARD
	POPJ P,		;STOP ON END

ALTWDS:	PUSH P,T2	;SAVE REPEAT COUNT
	PUSHJ P,ALTWS
	PUSHJ P,ALTSP
	POP P,T2
	SOJG T2,ALTWDS
	POPJ P,

ALTXPG:PUSH P,T2
	PUSHJ P,ALTWS
	PUSHJ P,ALTDL
	POP P,T2
	SOJG T2,ALTXPG
	MOVEI T2,0
	JRST ALTIN	;GO DO INSERT


ALTALT:	TLNE FL2,NOCTLU
	JRST ALTFNN	;SPECIAL FINISH IF FROM RDLIN
	OFFRUB
	SKIPN ALTFLG	;SHOULD WE DO A FILLB?
	JRST ALTAL1
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;YES, WE HAVE INSERTED SOMETHING
ALTAL1:IFN STANSW,<SETSTS TTY,401>
IFE STANSW,<SETSTS TTY,2	;DUMPLEXING BACK ON>
	JRST T2POPJ	;AND RETURN

ALTFNN:SOS -1(P)	;FOR NON-SKIP RETURN
ALTFN:	OFFRUB
	MOVEI T2,1000	;FINISH UP LINE
	PUSHJ P,ALTSP	;BY PRINTING A LARGE NUMBER OF SPCAES
	OUTSTR [ASCIZ /
/]
IFN STANSW,<SETSTS TTY,401>
IFE STANSW,<SETSTS TTY,2	;GET OUT OF NON-DUPLEX MODE>
ALTFN1:	ILDB C,ALTP	;LOOK ONE CHR OVER
	CAIE C,12	;THIS SHOULD BE THE LINE FEED
	NERROR ILFMT	;SOMETHING IS WRONG
	MOVEI C,0	;ZERO REMAINDER OF LINE
ALTFN2:	TLNN ALTP,760000	;ALL DONE?
	JRST ALTFN3	;YES
	IDPB C,ALTP	;NO, PUT IN ANOTHER 0
	JRST ALTFN2
ALTFN3:	SUBI ALTP,LIBUF-1	;GET SIZE OF NEW LINE
	HRRZM ALTP,NCNT	;AND SAVE FOR INSED
	AOS -1(P)	;SET FOR SKIP RETURN
	POP P,T1	;GET RID OF THE EXTRA CALL
	POPJ P,		;RETURN TO CALLER OF ALTLIN

ALTCU:	OFFRUB
	OUTSTR [ASCIZ /^U
/]
	TLNE FL2,NOCTLU
	JRST ALTCU1	;THIS ONE IS DIFFERENT
	TLO FL2,CTLUFL	;SET TO SAY WE DID A CONTROL U
	JRST SETALT	;GO RESTART LINE AND FORGET EDIT SO FAR

ALTCU1:	SETZM LIBUF+1
	MOVE T1,[XWD LIBUF+1,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,1
	MOVEM T1,OCNT
	MOVE T1,LIBUF
	TLNE T1,-1	;SEE IF WE START WITH TAB
	SKIPA T1,[BYTE (7) 11,15,12]
	MOVE T1,[BYTE (7) 0,15,12]
	MOVEM T1,LIBUF+1
	JRST STAL2

ALTRP:	PUSHJ P,ALTDL	;REPLACE IS DELETE THEN INSERT
	MOVEI T2,0
	JRST ALTIN

ALTCN:	OFFRUB
	TRO FL2,ALTDUP	;TURN ON DUPLEXING
ALTCN2:	LDB C,ALTP	;AT END OF LINE?
	CAIN C,15
	POPJ P,		;YES, STOP
ALTCN1:	PUSHJ P,GNCH1	;GET A CHARACTER
	CAIE C,177	;DO NOT LET HIM INSERT A RUBOUT
	CAIN C,12	;IGNORE CRET
	JRST ALTCN1
	CAIE C,200	;STOP ON ALTMODE AND LINE FEED
	CAIN C,15
	POPJ P,
	DPB C,ALTP	;REPLACE IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTCN2	;CONTINUE
	POPJ P,

JOINA:	OFFRUB
	TLNN FL2,CTLUFL	;AS FOR INSERT CRLF
	JRST	[RERROR ILC
		JRST ERCOR]	;DO NOT LET HIM
	PUSHJ P,FINDN	;GO SEE IF NEXT LINE IS REALLY THERE
	CAME T1,PGMK
	SKIPN T1
	JRST ILCER	;MAKE IT ILLEGAL IF NO LINE THERE
	MOVEM T1,LIBUF2	;SAVE ITS NUMBER
	SETZM LIBUF2+1
	MOVE T1,[XWD LIBUF2+1,LIBUF2+2]
	BLT T1,LIBUF2+MXWPL+1	;CLEAR OUT REST OF BUFFER
	PUSH P,ALTP	;SAVE POINTER TO THIS LINE
	ADD ALTP,[XWD 70000,0]	;BACK IT UP
	MOVE T2,[POINT 7,LIBUF2+1]
	MOVEI C,11
	MOVEI T1,6	;COUNT THE CHARACTERS
MOVLIN:	IDPB C,T2
	ILDB C,ALTP
	CAIE C,15	;END OF LINE?
	AOJA T1,MOVLIN	;KEEP COUNT
	MOVEI ALTP,1(PNTR)	;GET POINTER TO SECOND LINE
	HRLI ALTP,(<POINT 7,0,6>)
TRN1:	ILDB C,ALTP
	IDPB C,T2
	ADDI T1,1
	CAIL T1,MXWPL*5+6	;CHECK SIZE
	JRST LTLER
	CAIE C,12
	JRST TRN1	;NOT DONE YET
	EXCH T2,(P)	;SAVE OUTPUT POINTER AND GET OLD ALTP BACK
	SUBI ALTP,-1(PNTR)	;GET OLD COUNT OF SECOND LINE
	PUSH P,ALTP	;AND SAVE IT
	MOVEI C,15	;FINISH CURRENT LINE
	DPB C,T2
	MOVEI C,12
	IDPB C,T2
	MOVEI C,0
INSC2:	TLNN T2,760000
	JRST INSC3	;FILL WITH NULLS
	IDPB C,T2
	JRST INSC2
INSC3:	SUBI T2,LIBUF-1	;GET COUNT
	HRRZM T2,NCNT
	PUSHJ P,FINDB	;BACK UP TO POINT TO IT
	PUSHJ P,INSED
	PUSHJ P,FINDN
	PUSHJ P,FILLB
	POP P,OCNT	;OLD CONT
	HRRZS OCNT
	POP P,ALTP	;GET OUTPUT POINTER BACK
	SUBI ALTP,LIBUF2-1
	HRRZM ALTP,NCNT
	MOVE T1,[XWD LIBUF2,LIBUF]
	BLT T1,LIBUF+MXWPL+1
	PUSHJ P,INSED
	SETOM ALTFLG	;MARK AS NEED TO DO FILLB
	MOVE T1,NCNT	;GET THE COUNT JUST USED
	MOVEM T1,OCNT	;AND SET AS THE OLD COUNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP
	SETZM ALTCNT
	OUTSTR [ASCIZ /
/]
	MOVE T1,LIBUF
	MOVEM T1,CLN	;SET UP CURRENT LINE
	JRST OUTSN	;AND PRINT NUMBER

LTLER:	RERROR LTL
	POP P,ALTP	;RESTORE ALTP
	SKIPA
ILCER:	RERROR NNN
	PUSHJ P,FINDB	;MOVE BACK TO RIGHT PLACE
ERCOR:	PUSH P,ALTCNT	;SAVE COUNT
	SETZM ALTCNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET BACK TO START
	PUSHJ P,ALTCBS	;PRINT LINE NUMBER
	POP P,T2	;COUNT
	JUMPN T2,ALTSP	;AND SPACE OVER
	POPJ P,		;NO SPACES TO DO

ALTBS:	CAMN ALTP,[POINT 7,LIBUF+1,13]	;ARE WE AT START OF LINE
	JRST ALTCBS	;YES, GIVE CR/LF AND SEQ NUMBER
	ONRUB
	SUBI ALTP,1	;BACKSPACE POINTER
	REPEAT 3,<IBP ALTP>
	ILDB C,ALTP
	TRNE FL,DPYF
	MOVEI C,10
	PUSHJ P,OCHR
	SOS ALTCNT	;DECREASE COUNT
	SOJG T2,ALTBS	;MORE,MORE
	POPJ P,

ALTCBS:	OFFRUB
	OUTSTR [ASCIZ /
/]
	MOVE T1,LIBUF	;ALSO PRINT SEQ NUM
	TLNE T1,-1
	JRST OUTSN
	OUTSTR (T1)	;PUT OUT THE PROMPT STRING
	POPJ P,

ALTLN:	MOVEI T2,1000	;FINISH PRINTING THE LINE
	PUSHJ P,ALTSP
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;POINTER TO START
	SETZM ALTCNT	;RESET COUNT
	JRST ALTCBS	;AND PRETEND A BACKSPACE
SUBTTL THE = COMMAND

SET:	PUSHJ P,SCAN	;GET THE THING TO SET TO
	TRNN FL,IDF	;MUST BE AN IDENT
	NERROR ILC
	PUSH P,ACCUM	;SAVE IT
	PUSHJ P,SCAN	;AND CHECK FOR TERMINATOR
	TRNN FL,TERMF
	NERROR ILC
	MOVE T3,[XWD -TBLGST,TABST]	;SET FOR SEARCH ROUTINE
	PUSHJ P,TBLCK	;FIN IT
	NERROR ILC	;LOSE BIG
	XCT TABJ-TABST(T3)	;EXECUTE THE CORRECT INSTR
	JRST COMND	;FOR THOSE WHICH JUST SET A BIT
SETLOW:	MOVEI T2,40	;SET FOR LOWER CASE
	MOVEM T2,CASEBT	;SET UP CASE
	JRST COMND
SETNSP:	MOVEI T2,NSEPF
	MOVEM T2,SEPFLG
	JRST COMND
SETM37:	TROA FL,M37F
SETDPY:	TRZA FL,M37F	;=DPY AND =M37 SET 2 FLAGS
	TRZA FL,DPYF
	TRO FL,DPYF
	JRST COMND

DEFINE TABLE
<X UPPER,<SETZM CASEBT>
X LOWER,<JRST SETLOW>
X M33,<TRZ FL,M37F!DPYF>
X M37,<JRST SETM37>
X DPY,<JRST SETDPY>
X NOVICE,<TRZ FL,EXTOG>
X EXPERT,<TRO FL,EXTOG>
X C128,<TLZ FL,QMODF>
X C64,<TLO FL,QMODF>
X SEPERATOR,<SETZM SEPFLG>
X NONSEPERATOR,<JRST SETNSP>
X P96,<TLO FL2,PRT37>
X P64,<TLZ FL2,PRT37>
X ERSTOP,<SETZM NOCERR>
X ERGO,<SETOM NOCERR>
>
TABST:	DEFINE X(A,B)
<	<SIXBIT /A/>
>
	TABLE
	TBLGST=.-TABST

TABJ:	DEFINE X(A,B)
<B
>
	TABLE

TBLCK:	MOVE T1,(P)	;GET RETURN ADR
	EXCH T1,-1(P)	;AND CHANGE WITH STORED IDENT
	MOVEM T1,(P)
	SETCMI T2,0	;SET T2 TO ALL 1S
	LSH T1,6
	LSH T2,-6	;FIND NUMBER OF CHRS
	JUMPN T1,.-2
	MOVEI T4,0	;LAST PARTIAL MATCH FOUND
MNLP:	MOVE T1,(T3)	;GET NEXT TEST WORD
	CAMN T1,(P)	;IF EXACT MATCH
	JRST TPOPJ1	;THEN GO
	ANDCM T1,T2	;GET ONLY THE IMPORTANT LETTERS
	CAME T1,(P)
	JRST ONLP	;TRY AGAIN
	JUMPN T4,TPOPJ	;IF ANY OTHERS, GIVE UP
	HRRZ T4,T3	;ELSE REMEMBER IT
ONLP:	AOBJN T3,MNLP
	SKIPE T3,T4	;GET BACK REMEMBERED ON (IF THERE)
TPOPJ1:	AOS -1(P)		;SKIP RETURN IF FOUND
TPOPJ:	POP P,T1	;LOSE THE SAVE IDENT
	POPJ P,

SUBTTL = COMMAND

GIVE:	PUSHJ P,SCAN	;FIND OUT WHAT HE WANTS TO KNOW
	CAIN C,"."	;CURRENT LINE/PAGE?
	JRST GVDOT	;YES
	TRNN FL,IDF	;IF NOT, MUST BE AN IDENT
	NERROR ILC
	PUSH P,ACCUM	;SAVE IT
	PUSHJ P,SCAN	;CHECK FOR TERM
	TRNN FL,TERMF
	NERROR ILC
	MOVE T3,[XWD -TBLG,TABGV]	;SET FOR SCANNER
	PUSHJ P,TBLCK
	NERROR ILC	;NOT FOUND
	XCT TABJG-TABGV(T3)	;DO INSTR
GETBIG:	TRNE FL,BGSN	;HAVE WE SEEN THAT PAGE
	JRST GVBG1	;YES, ALL IS OK
	MOVSI T1,1	;WILL HAVE TO SEARCH FOR IT
	MOVEM T1,DPG
	MOVEI SINDEX,0
	PUSHJ P,FIND
	TRNN FL,BGSN	;SHOULD HAVE SEEN IT NOW
	ERROR ICN	;WE ARE IN TROUBLE
GVBG1:	MOVE T1,BGPG	;GET IT
	POPJ P,

GVBIG:	PUSHJ P,GETBIG
GIV2:	MOVEI T3,OCHR	;ROUTINE FOR DECIMAL PRINTER TO OUTPUT TO
	PUSHJ P,DECPR	;PRINT DECIMAL
GIV1:	OUTSTR [ASCIZ /
/]
	JRST COMND

GVCASE:	TRNE FL,DPYF
	OUTSTR [ASCIZ /DISPLAY /]
	TRNE FL,M37F
	OUTSTR [ASCIZ /MODEL 37 /]
	SKIPN SEPFLG
	OUTSTR [ASCIZ /SEPERATOR /]
	TLNE FL,QMODF
	OUTSTR [ASCIZ /C64 /]
	SKIPE NOCERR
	OUTSTR [ASCIZ /NO STOP /]
	MOVEI T1,[ASCIZ /LOWER
/]
	SKIPN CASEBT
	MOVEI T1,[ASCIZ /UPPER
/]
	OUTSTR (T1)	;PRINT CURRENT CASE
	JRST COMND
GIVER:	SKIPE T1,SVERN
	PUSHJ P,OUTER1
	JRST COMND
DEFINE TABLE
< X ERROR,<JRST GIVER>
X CASE,<JRST GVCASE>
X STRING,<JRST GVSTR>
X INC,<JRST GVINC>
X BIG,<JRST GVBIG>
>
TABGV:	DEFINE X(A,B)
<<SIXBIT /A/>
>
	TABLE
	TBLG=.-TABGV
TABJG:	DEFINE X(A,B)
<B
>
	TABLE

GVINC:	MOVE T1,INCR	;GET CURRENT INCREMENT
	PUSHJ P,OUTSN	;GO PRINT IT
	JRST GIV1	;AND A CRRET

GVDOT:	PUSHJ P,SCAN	;SEE IF A TERMINATOR IS THERE
	TRNN FL,TERMF
	NERROR ILC	;NO TERMINATOR
	MOVE T1,CLN	;GET CURRENT LINE
	MOVEM T1,LINOUT
	OUTSTR LINOUT
	MOVE T1,CPGL	;AND CURRENT PAGE
	JRST GIV2	;|O TO IT


DECPR:	IDIVI T1,^D10	;THE USUAL DECIMAL PRINTER
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,DECPR
	HLRZ C,(P)
	ADDI C,"0"
	JRST (T3)	;EXCEPT HAS ARBITRARY OUTPUT ROUTINE

GVSTR:	MOVEI T1,SRPNT	;GET THE POINTER TO POINTER BLOCK
	HRLI T1,-SRNUM	;SET COUNT
	OUTSTR [ASCIZ /	SEARCH:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R2PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	SUBSTITUTE:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R1PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	FOR:
/]
	PUSHJ P,GVSTR3
	JRST COMND
GVSTR3:	SKIPN T2,(T1)	;IS THERE ONE THERE?
	POPJ P,		;NO, DONE
GVSTR2:	ILDB C,T2	;NEXT CHR
	JUMPE C,GVSTR1	;DONE
	PUSHJ P,OCHR	;PRINT IT
	JRST GVSTR2	;AND CONTINUE
GVSTR1:	OUTSTR [ASCIZ /
/]
	AOBJN T1,GVSTR3	;IF THERE IS ONE
	POPJ P,

SUBTTL LIST COMMAND

LIST:	SETZM LOLN	;FOR START OF PAGE
	PUSHJ P,SCAN	;GET SOME INFORMATION
	TRNN FL,TERMF	;JUST A TERMINATOR
	JRST LIST7	;NO, GO LOOK FOR A COMMAND STRING
	MOVEI T1,1	;LIST ENTIRE FILE
	MOVEM T1,LOPG
	MOVSI T1,1	;FROM 1 TO IMPOSSIBLY HIGH
	MOVEM T1,HIPG
	TRZ FL,CNTF	;MAKE SURE THAT THIS FLAG IS OFF
	JRST LIST8	;GO START WORK
LIST7:	PUSHJ P,GET2	;HAVE ALREADY SCANNED, GET 2 NUMBERS
	TRNN FL,TERMF	;END OK?
	NERROR ILC
LIST8:	TRZ FL,LINSN	;NONE SEEN YET
	INIT LPT,100	;GET IT
	SIXBIT /LPT/
	XWD LOBUF,0
	NERROR UNA	;CAN NOT GET IT
	TRNE FL2,CBFUS	;HAS @ GRABBED THE BUFFER
	JRST	[MOVE T1,JOBREL	;NUTS! GRAB CORE
		ADDI T1,1
		MOVEM T1,JOBFF
		ADDI T1,1777
		CORE T1,
		JRST	[RELEASE LPT,0
			NERROR NEC]
		OUTBUF LPT,1
		MOVE T2,JOBREL
		SUBI T2,1777
		EXCH T2,JOBFF
		SUB T2,JOBFF
		MOVEI T1,2000
		JRST GOTCOR]
	MOVEI T1,LPTBUF
	MOVEM T1,JOBFF
	OUTBUF LPT,1	;ASK FOR ONE BUFFER
	MOVEI T2,LPTBUF	;FIND OUT HOW BIG IT IS
	EXCH T2,JOBFF
	SUBI T2,LPTBUF	;THE SIZE
	MOVEI T1,203*2+1	;THE SPACE RESERVED FOR IT
GOTCOR:	IDIV T1,T2	;GET NUMBER THAT WILL FIT THERE
	OUTBUF LPT,(T1)	;AND ASK FOR THAT MANY
	MOVE T1,[XWD PGHS,PGHD]	;GET A COPY OF THE BLANK HEADER
	BLT T1,PGHD+10
	MOVE ALTP,[POINT 7,PGHD,27]	;START TO FILL IT
	MOVEI T3,6	;6 CHRS IN FILE NAME
	MOVE T2,ORGNAM	;USE THE ORIGINAL NAME
	PUSHJ P,PRTSX	;PUT IT IN THE HEADER
	SKIPN T2,ORGEXT	;GET THE EXTENSION
	JRST LIST1	;NONE THERE, IGNORE
	MOVEI T1,"."	;A DOT BETWEEN
	IDPB T1,ALTP
	MOVEI T3,3	;ONLY 3 CHRS HERE
	PUSHJ P,PRTSX
LIST1:	MOVE ALTP,[POINT 7,PGHD+3]	;TIME+DATE (ALTP IS FREE)
	DATE T1,	;GET DATE
	IDIVI T1,^D31	;LEAVES DAY IN T2
	PUSH P,T2	;SAVE IT
	IDIVI T1,^D12	;LEAVES MONTH IN T2 YEAR IN T1
	EXCH T1,(P)	;SAVE YEAR
	PUSH P,MOTAB(T2)	;AND MONTH
	ADDI T1,1	;GET DAY (MUST ADD 1)
	MOVEI T3,HDOCH	;PLACE FOR DECPR TO PUT THINGS
	PUSHJ P,DECPR

	MOVEI T1,"-"	;SEPERATE
	IDPB T1,ALTP
	POP P,T2	;THE MONTH
	MOVEI T3,3	;3 CHRS
	PUSHJ P,PRTSX
	MOVEI T3,HDOCH
	MOVEI T1,"-"
	IDPB T1,ALTP
	POP P,T1	;THE YEAR
	ADDI T1,^D64	;CONVERT TO REAL YEAR
	PUSHJ P,DECPR
	IBP ALTP	;SKIP OVER A SPACE
	TIMER T1,	;GET THE TIME
	IDIVI T1,^D60000	;CONVERT TO MINUTES
	IDIVI T1,^D60	;NOW TO HOURS
	PUSH P,T2	;SAVE MINUTES
	PUSHJ P,DECPR	;PRINT
	MOVEI T1,":"
	IDPB T1,ALTP
	POP P,T1	;GET MINUTES BACK
	MOVEI T2,"0"	;MAKE SURE THERE ARE 2 DIGITS
	CAIG T1,^D9
	IDPB T2,ALTP
	PUSHJ P,DECPR
	SETZM LOGPG#	;LOGICAL PAGE TO 0
	MOVE T1,LOPG	;GET SET TO PRINT
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GO FIND IT
	SETZM LSTCNT#	;COUNT OF NUMBER OF LINES PER PAGE
LST2:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST LST6	;FINISH UP
	TRO FL,LINSN	;YEP, WE HAVE SEEN ONE
	CAMN T1,PGMK	;CHECK FOR PAGE MARK AND HANDLE SPECIAL
	JRST LST4
	MOVEM T1,CLN	;THE CURRENT LINE
	MOVE T1,CPG	;REMEMBER PAGE
	MOVEM T1,CPGL
	MOVEI T2,0	;COUNT OF NUMBER OF CHRS SEEN
	SOSG LSTCNT	;CHECK TO SEE IF RUN OUT
	PUSHJ P,HDPRNT	;AND PRINT HEADING
	MOVE T1,PNTR	;GET THE POINTER
	HRLI T1,(<POINT 7,0>)	;AND SET UP BYTE POINTER
LST3:	ILDB C,T1	;GET CHR
	CAIG C,14
	CAIGE C,11
	SKIPA
	XCT GTAB-11(C)
	LDB CS,[POINT 7,CTBL(C),10]	;THE ALT CHR
	JUMPE CS,LST5	;NONE, PRINT ORIGINAL
	TLNN FL2,PRT37	;IS THIS A 96 CHR PRINTER??
	TDZA T3,T3	;NO T3=0
	MOVE T3,[XWD LETF_16,M37]	;TEST FOR CHRS TO PRINT AS THEY ARE
	TDNE T3,CTBL(C)	;SEE IF THEY ARE ON
	JRST LST5	;YES, PRINT AS THEY ARE
	MOVEI C,"?"
	PUSHJ P,POCHR
	ADDI T2,1
	MOVE C,CS	;AND THEN OTHER FORM
LST5:	PUSHJ P,POCHR	;PRINT IT
	AOJA T2,LST3	;COUNT AND CONTINUE

	DEFINE FORC (ARG,VAL,TXT)
<	DEFINE %FMAC (ARG)
<TXT>
IRP VAL,<%FMAC (VAL)>>

MOTAB:	FORC ( Q,<JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>,<
	SIXBIT /Q/
>)

PGHS:	ASCII /				          	/
	ASCII /               /
	BYTE (7) 40,40,40,40,15
	ASCIZ /PAGE /

ARRAY PGHD[11]

LFD:	PUSHJ P,POCHR	;PRINT IT
	PUSHJ P,FINDN	;GET NEXT
	JRST LST2	;AND GO

TAB:	ADDI T2,10
	ANDCMI T2,7
	PUSHJ P,POCHR
	JRST LST3

FFD:	PUSHJ P,POCHR	;FORM FEED GETS A HEADING
	PUSHJ P,HDPRNT
	JRST LST3

VTB:	PUSHJ P,POCHR
	MOVE T3,LSTCNT
	CAIG T3,<%LPP+2>/3
	JRST	[PUSHJ P,HDPRNT
		JRST LST3]
	CAIG T3,<2*<%LPP+2>>/3
	MOVEI T3,<%LPP+2>/3
	CAIL T3,<2*<%LPP+2>>/3
	MOVEI T3,<2*<%LPP+2>>/3
	MOVEM T3,LSTCNT
	JRST LST3

LST4:	MOVEI C,14	;PRINT A FORM FEED
	SOSLE LSTCNT	;BUT ONLY IF WE ARE NOT ALREADY THERE
	PUSHJ P,POCHR
	AOS T1,CPG	;GET PAGE CORRECTLY
	MOVEM T1,CPGL
	SETZM LOGPG	;ZERO LOGICAL PAGE AGAIN
	MOVEI T2,0	;THIS MUST BE ZERO SO GET IT THAT WAY
	PUSHJ P,HDPRNT	;PRINT A HEADER
	AOS LSTCNT	;INCREASE BY 1 TO MAKE IT COME OUT RIGHT
	PUSHJ P,FINDN	;ADVANCE
	JRST LST2	;AND CONTINUE

LST6:	RELEAS LPT,0	;GET RID OF IT
	TRNE FL2,CBFUS
	JRST	[MOVE T1,JOBREL
		SUBI T1,2000
		CORE T1,
		JFCL	;GIVE BACK THE EXTRA CORE
		JRST .+1]
	TRNN FL,LINSN!RENSN	;WERE ANY SEEN?
	NERROR NLN	;NO, ERROR
	JRST COMND	;AND GET MORE COMMANDS

POCHR:	SOSG LOBUF+2	;ROOM FOR MORE?
	OUTPUT LPT,0
	IDPB C,LOBUF+1
	POPJ P,

HDPRNT:	PUSH P,T1	;SAVE POINTER
	MOVEI C,15	;GET TO LEFT OF PAGE
	PUSHJ P,POCHR
	MOVE T1,[POINT 7,PGHD]	;GET SET TO PRINT HEADER
HDPR1:	ILDB C,T1	;GET A CHARACTER
	JUMPE C,HDPR2	;DONE?
	PUSHJ P,POCHR	;PRINT IT
	JRST HDPR1	;CONTINUE
HDPR2:	PUSH P,T2	;SAVE CHARACTER COUNT
	MOVE T1,CPG	;GET CURRENT PAGE
	MOVEI T3,POCHR	;WHERE TO PRINT IT
	PUSHJ P,DECPR	;PRINT
	MOVEI C,"-"
	PUSHJ P,POCHR
	AOS T1,LOGPG	;GET NEXT LOGICAL PAGE
	PUSHJ P,DECPR
	MOVEI C,15	;NOW RET AND 2 LFDS
	PUSHJ P,POCHR
	MOVEI C,12
	PUSHJ P,POCHR
	PUSHJ P,POCHR
	MOVEI T1,%LPP	;RESET LINE COUNT
	MOVEM T1,LSTCNT
	POP P,T2	;GET BACK COUNT OF CHRS
	JUMPE T2,TPOPJ	;IF 0 THEN ALL OK
	MOVE T3,T2	;GET COPY
	MOVEI C," "	;PRINT CORRECT NUMBER OF SPACES
	PUSHJ P,POCHR
	SOJG T3,.-1
	POP P,T1	;RESTORE POINTER
	POPJ P,

PRTSX:	MOVEI T1,0	;SET TO RECIEVE A CHR
	LSHC T1,6	;GQT ONE
	ADDI T1,40	;CONVERT
	IDPB T1,ALTP	;PUT IN HEADER
	SKIPE T2	;ONLY SPACES LEFT?
	SOJG T3,PRTSX	;OR COUNT RUN OUT?
	POPJ P,		;RETURN

HDOCH:	IDPB C,ALTP	;PUT CHRS FROM DECPR INTO HEADER
	POPJ P,

GTAB:	JRST TAB
	JRST LFD
	JRST VTB
	JRST FFD

SUBTTL REPLACE COMMAND


REPLAC:SETZM LOLN	;I REALLY SHOULD PUT THIS ELSEWHERE
	PUSHJ P,GET2S	;WHAT DO WE WANT TO REPLACE?
	CAIE C,","	;HE CAN SPECIFY INCREMENT TOO
	CAIN C,";"	;ALSO ;
	SKIPA
	JRST CKTRMR	;BUT HE DIDN'T, LOOK FOR TERMINATOR
	PUSH P,C	;SAVE FOR LATER
	PUSHJ P,SCAN	;GET INCR
	TRNE FL,NUMF	;WHICH MUST BE A NUMBER
	CAMN T1,[<ASCII /00000/>+1]	;NOT 0 FOR INCR
	NERROR ILC
	POP P,C		;CHECK FOR , OR ;
	CAIN C,","	;AND STORE INCR ONLY IF ,
	MOVEM T1,INCR
	MOVEM T1,TINCR	;BUT ALWAYS TINCR
	PUSHJ P,SCAN	;SCAN PAST
CKTRMR:	TRNN FL,PGSN	;WAS A SECOND PAGE GIVEN?
	TRNN FL,TERMF	;OR PERHAPS NO TERMINATOR
	NERROR ILC
	MOVE T1,LOPG	;FIND START OF THE WORLD
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;WE WILL ALSO USE LOLN FOR START OF INSERT
	SKIPN LOLN	;IN CASE HE SAID /A OR SOMETHING
	MOVEM T1,LOLN	;USE START OF PAGE
	MOVE T2,CPG	;GET CURRENT PAGE
	CAME T2,LOPG	;AND FIND OUT IF ITS THE ONE WE WANT
	NERROR NSP
	TRZ FL2,STOPI
NEXT:	CAME T1,PGMK	;PAGE MARK STOPS THE WORLD
	PUSHJ P,ONMOV	;CHECK RANGE
	JRST GOINS	;OUT OF THINGS TO DELETE, INSERT
	PUSHJ P,DODEL	;DELETE A LINE
	SKIPE T1,(PNTR)	;ARE WE AT END OF BUFFER
	JRST NEXT	;NO
NEXT1:	MOVE T1,WC	;SEE IF ROOM TO INSERT
	ADD T1,BUFP
	CAML T1,FILPT
	JRST NXTBF	;TOO FULL, GET NEXT BUFFER AND DELETE
	SETZM OCNT	;INSERT A FRESH LINE
	MOVE T1,LOLN	;THE LINE TO INSERT
	MOVEM T1,LIBUF
	TRNN FL2,SUPOFL
	PUSHJ P,OUTSN
	PUSHJ P,RDLIN	;GET ONE
	JRST FINDL	;LINE TOO LONG ERROR
	MOVEM T1,NCNT	;SET UP NEW COUNT
	PUSHJ P,INSED	;INSERT
	PUSHJ P,FINDZ	;GET NEXT LINE, BUT NOT IN NEW BUFFER
	MOVE T1,CPG	;SET UP .
	MOVEM T1,CPGL
	MOVE T1,LOLN
	MOVEM T1,CLN
	TRNE FL2,STOPI
	JRST FINDL	;HE SAID ALTMODE
	MOVE T2,TINCR	;FIND NEXT LINE
	PUSHJ P,ASCIAD
	CAMG T1,TINCR	;CHECK FOR WRAP AROUND
	JRST FINDEL
	MOVEM T1,LOLN	;AND SAVE IT
	JRST NEXT1	;CHECK TO SEE IF INSERT OR DELETE IN ORDER

DODEL:	SETZM NCNT	;NEW IS 0
	PUSHJ P,GETLTH	;OLD LENGTH
	MOVEM T1,OCNT
	JRST INSED	;GO INSERT AND RETUNR

GOINS:	SKIPE T2,LOLN	;IS THERE REALLY ONE THERE?
	CAMN T2,PGMK
	JRST COMND	;TRIED TO REPLACE BLANK PAGE
	MOVEM T2,HILN	;SET UP FOR INSERT
	JRST ENTINS	;AND JUMP INTO THE MIDDLE OF IT

FINDL:	MOVE T1,LOLN
	MOVEM T1,CURINS
	MOVE T1,CPG
	MOVEM T1,IPG
	MOVE T1,TINCR
	MOVEM T1,IINCR	;SAVE IT
FINDEL:	PUSHJ P,FINDN1	;GET THE NEXT LINE
	CAME T1,PGMK	;QUIT IF PAGE MARK
	PUSHJ P,ONMOV	;OR IF OUT OF RANGE
	JRST LEVINS
	PUSHJ P,DODEL	;DELETE IT
	JRST FINDEL

NXTBF:	PUSHJ P,FINDN1	;GET TO A NEW BUFFER IF NECESSARY
	JRST NEXT	;AND PROCEED TO NEXT

SUBTTL COMMON SEARCH ROUTINES FOR F AND S

COMMENT ! SOME COMMON ROUTINES FOR SEARCHING FILES!

COMMENT ! THIS ROUTINE GENERATES CODE FOR FINDING A MATCH
FOR THE FIRST CHARACTER OF A SEARCH STRING. THE POINTER
TO A SET OF BYTE POINTERS FOR SEARCH STRINGS IS IN T1 !


CODSR:	MOVEI T2,CODEBF	;SET UP POINTER TO PLACETO PUT CODE
	MOVEI ALTP,0	;THE NUMBER OF THE CURRENT STRING
	TLO FL2,MATEOL	;CHECK FOR EOF FORCING
	HRLI T1,-SRNUM	;THE NUMBER OF STRINGS
CODS5:	TLZ FL,NEGF!DEMCHR	;TURN OFF THE  SEEN FLAG
	MOVE T3,(T1)	;GET A POINTER
	JUMPE T3,ENDCOD	;A ZERO BYTE POINTER IS END OF CODE
READCH:	ILDB C,T3	;PICK UP A CHARACTER IN STRING
	JUMPE C,ISSERR	;GO GIVE HIM AN ERROR MESSAGE
			;IF NULL STRING OR NEEDS MORE CHRS
	CAIN C,""	;FORCE TO START OF LINE
	JRST ANYNT	;YES
	TLZ FL2,MATEOL	;NO, RESET FLAG
	CAIN C,""	;BUT NOT
	JRST READCH	;JUST READ NEXT
	CAIN C,""	;OR
	SOJA T2,[SOJA T2,COMXCT]	;JUST SAY A MATCH
	CAIN C,""	;ARBITRARY NUMBER OF SOMETHING
	JRST ARBIT
	CAIN C,""	;ANY CHARACTER
	JRST ANY
	CAIN C,""	;NOT THIS ONE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;WE REALLY JEED IT
		JRST READCH]
	CAIN C,"|"	;SEPERATOR
	JRST SEP
	CAIN C,""	;QUOTE THE NEXT CHARACTER
	JRST QUOTE
COMLET:	MOVE CS,CTBL(C)	;GET THE MAJIC BITS
	TLNN FL,EXCTS1!EXCTSR	;IS THIS AN EXACT SEARCH?
	TLNN CS,LETF_16	;OR NOT A LETTER
	JRST NORMCR	;YES JUST THE TEST
	HRLI C,(<CAIE C,>)	;DO A CAIE
	MOVEM C,(T2)
	XOR C,[MCXOR (<<CAIN 40>>,<<CAIE>>)]	;AND TEST FOR OTHER CASE
	MOVEM C,1(T2)
	TLNE FL,NEGF	; THAT CHR
	JRST GENSKP	;GENERATE A SKIPA
COMXCT:	MOVE C,[XCT JSPR]	;THE CALL TO SEARCH FURTHER
	DPB ALTP,[POINT 4,C,12]	;AC FIELD GIVES STRING NUMBER
	MOVEM C,2(T2)
	ADDI T2,3	;ADVANCE OUTPUT POINTER
ENDSTR:	ADDI ALTP,1	;NEXT STRING
	AOBJN T1,CODS5	;IF ANY
ENDCOD:	MOVE C,[JRST COMSRT]	;A RETURN
	MOVEM C,(T2)
	POPJ P,

SEP:	MOVE C,[SKIPG CS,CTBL(C)]	;GET BITS
	MOVEM C,(T2)
	MOVE C,[TDNE CS,SEPFLG]	;CHECK FOR %,$,OR .
	MOVEM C,1(T2)
	TLNE FL,NEGF	;SKIPA IN NORMAL CASE
	JRST COMXCT
GENSKP:	MOVSI C,(<SKIPA>)
	MOVEM C,2(T2)
	AOJA T2,COMXCT	;SO XCT WILL GO IN RIGHT PLACE

QUOTE:	ILDB C,T3	;GET NEXT CHR
	JUMPE C,ISSERR	;END OF STRING IS ILLEGAL
	JRST COMLET	;TREAT AS NORMAL CHARACTER

NORMCR:	HRLI C,(<CAIN C,>)	;EXACT OR NOT LETTER
	TLNE FL,NEGF
	TLC C,(MCXOR (<<CAIN>>,<<CAIE>>))	;USE OTHER TEST
NORMC1:	MOVEM C,(T2)
	SOJA T2,COMXCT	;MAKE THE XCT GO IN RIGHT PL@CE

ANYNT:	TLO FL,NEGF	;JUST TURN ON FLAG TO GEN CORRECT CODE
ANY:	MOVE C,[CAIE C,15]	; IS 15
	TLNE FL,NEGF
	TLC C,(MCXOR (<<CAIN>>,<<CAIE>>))
	JRST NORMC1

ARBIT:	ILDB C,T3	;GET NEXT
	CAIN C,""	;JUST CHECK VALIDITY
	JRST ARBIT
	CAIE C,""	;THESE ARE VERY HARRY, JUST LET
	CAIN C,""	;THE REAL ROUTINE DO IT
	SOJA T2,[SOJA T2,COMXCT]
	CAIN C,""
	ILDB C,T3
	JUMPE C,ISSERR	;END OF STRING ERROR
	JRST READCH	;LOOK FOR FIRST OTHER CHR

JSPR:	JSP T1,SRCRET	;CALL CONTINUE SEARCH

ARRAY CODEBF[4*SRNUM+2]

;READ INTHE STRING TO SEARCH FOR
;T3 HAS PLACE TO PUT POINTERS T1 A BYTE POINTER FOR STRINGS

SSTRNG:MOVEI T2,SRBLG	;THE PERMISSIBLE LENGTH
	HRLI T3,-SRNUM	;T3 HAS POINTER TO PLACE BYTE POINTERS
SSTR0:	MOVEM T1,SVPT	;SAVE THE POINTER FOR END OF STRING
SSTR1:	PUSHJ P,GNCH	;GET A CHR
	CAIN C,200	;ALTMODE TERMINATES
	JRST SSTEND
	CAIN C,15	;IGNORE RETURNS
	JRST SSTR1
	CAIN C,12	;LINE FEED IS END OF ONE STRING
	JRST SSTR2
	IDPB C,T1	;PUT IN OUTPUT STRING
	SOJG T2,SSTR1
SSTR3:	RERROR STL	;THE STRING WAS TOO LONG
SSTR4:	HRLZ T1,T3	;ZERO OUT FIRST POINTER
	MOVNS T1
	ADDI T1,-SRNUM(T3)	;FIND START
	SETZM (T1)
	JRST COMND
SSTR2:	CAMN T1,SVPT	;NULL STRING?
	JRST	[HLRZ C,T3	;FIRST ONE?
		CAIE C,-SRNUM	;WELL?
		JRST .+1	;NO
		MOVEI C,12	;RETURN A LINE FEED
		POPJ P,]
RETSTR:MOVEI C,0	;TERMINATE STRING WITH 0
	IDPB C,T1
	SOJLE T2,SSTR3
	MOVE C,SVPT	;SET UP POINTER
	MOVEM C,(T3)
	AOBJN T3,SSTR0	;IF ROOM FOR MORE, GET THEM
	RERROR TMS	;TOO MANY GIVEN
	JRST SSTR4
SSTEND:	CAIN T2,SRBLG	;DID WE SEE ANY?
	POPJ P,		;NO, RETURN
	MOVEI C,0	;YES, TERMINATE LAST
	IDPB C,T1
	MOVE T1,SVPT
	MOVEM T1,(T3)	;SET POINTER
	MOVEM T3,STRNUM	;SAVE NUMBER OF LAST STRING
SSTR5:	AOBJP T3,CPOPJ1	;ZERO OUT OTHER POINTERS
	SETZM (T3)
	JRST SSTR5
INTEGER SVPT
INTEGER STRNUM

;THE SEARCH ITSELF

COMSRC:MOVEM T2,BUFSAV#	;SAVE THE POINTER TO STRINGS
	MOVNI T3,1	;THE COUNT OF HOW FAR INTO LINE WE ARE
	MOVEI ALTP,1(PNTR)	;SET BYTE POINTER
	HRLI ALTP,(<POINT 7,0,6>)
	MOVEI C,15	;START WITH A LINE DELIMITER
	JRST CODEBF	;GO SCAN
COMSRT:	TLNE FL2,MATEOL	;IS IT A FORCED LINE MATCH
	POPJ P,		;YES, THEN EXIT NOW
	ILDB C,ALTP	;WE RETURN HERE IF NO MATCH FOR THIS ONE
	CAIE C,15	;DONE?
	AOJA T3,CODEBF	;NO, GO ON
	POPJ P,		;YES, NON-MATCH RETUNR

SRCRET:PUSH P,T1	;SAVE THE RETURN ADDRESS
	PUSH P,ALTP	;AND THE STRING POINTER
	PUSH P,C	;AND THE CHARACTER
	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	ADD T1,BUFSAV	;POINT TO BYTE POINTER
	SKIPN T1,(T1)	;GET IT
	ERROR ICN	;THERE SHOULD BE ONE THERE
	MOVE T2,[POINT 7,ARBBUF]	;SET UP ARBIT MATCH
	MOVEI T4,MXWPL*^D10	;POINTER AND COUNT
	SETZM ARBCNT	;THE NUMBER OF ARBITRARY MATCHES SEEN
	TLZ FL,ARBITG	;OFF AT START
	PUSHJ P,LINMAT	;GO CHECK FOR MATCH
	JRST LOSE	;WE LOSE, CONTINUE SCAN
	MOVEM ALTP,SRCALP	;POINTER TO END OF STRING
	POP P,C	;RESTORE
	POP P,ALTP
	POP P,T1
CPOPJ1:AOS (P)	;SKIP RETURN
	POPJ P,
LOSE:	POP P,C	;RESTORE
	POP P,ALTP
	POPJ P,	;AND CONTINUE SEARCH

NXTCHR:	CAIN C,12	;WAS THAT LAST OF LINE?
	POPJ P,	;YES, LOSE 
	ILDB C,ALTP	;NO, TRY NEXT
LINMAT:	PUSHJ P,CHRMAT	;CHECK FOR MATCH
	POPJ P,	;NONE, RETURN
	CAIE CS,0	;IS SO ALL DONE
	JRST NXTCHR	;NO, TRY MORE
	JRST CPOPJ1	;SKIP RETURN

CHRMAT:TLZ FL,NEGF!DEMCHR	;NO  SEEN AND CHR CAN BE 0
REDCHM:	ILDB CS,T1	;GET NEXT
	JUMPE CS,MATCH	;END OF STRING IS USUALLY GOOD
	CAIN CS,""	;CHEC FOR NEGATE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;MUST BE FOLLOWED BY A CHR
		JRST REDCHM]
	CAIN CS,"|"	;SEPERATOR?
	JRST SEPMT
	CAIN CS,""	;ARBITMRARY NUMBER
	JRST ARBITM
	CAIN CS,""	;ANYMT?
	JRST ANYMT
	CAIN CS,""	;BUT NOT
	JRST BUTNOT
	CAIN CS,""	;OR
	JRST LOKOR
	CAIN CS,""	;END OF LINE MATCH
	JRST ANYNMT	;NOT ANY MATCH
	CAIN CS,""	;QUOTE NEXT?
	JRST	[ILDB CS,T1
		JUMPN CS,.+1	;MUST HAVE ONE THERE
		NERROR ISS]	;ELSE ILLEGAL
	CAMN C,CS	;ARE THEY THE SAME
	JRST ISTRU1	;YES, CHECK NEGF
	MOVE T5,CTBL(CS)	;GET BITS
	TLNN FL,EXCTS1!EXCTSR	;EXACT?
	TLNN T5,LETF_16	;OR NOT LET
	JRST ISFALS	;NO MATCH
	XORI CS,40	;CHECK OTHER CASE
	CAMN C,CS
	JRST ISTRU1
	JRST ISFALS	;LOSE

MATCH:	TLNE FL,DEMCHR	;DID WE NEED A CHARACTER THERE?
ISSERR:NERROR ISS	;YES, ILLEGAL STRING
	JRST CPOPJ1	;OK RETURN

ANYNMT:	TLC FL,NEGF	;JUST REVERSE FLAG
ANYMT:	CAIE C,15
	JRST ISTRU	;YES THIS IS ANYMT CHR
ISFALS:	TLNN FL,NEGF
	POPJ P,		;ERROR, DO NOT STORE STRING INFO
	CAIN C,15	;IS IT A RETURN
	AOSA T4	;ADJUST COUNT AND ENTER A NULL STRING
	IDPB C,T2	;SAVE IN ARBITM
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2	;COUNT THEM
	JUMPLE T4,ILFMTR	;THIS LINE MUST HAVE ILLEGAL FORMAT
	AOSA ARBCNT	;ONE MORE SEEN
ISFAL1:	TLNE FL,NEGF	;WAS NEG FLAG ON?
	AOS (P)	;YES, A MATCH
	POPJ P,

SEPMT:	SKIPG T5,CTBL(C)
	TDNE T5,SEPFLG
	JRST ISFALS	;NOT A SEPMT
ISTRU:	CAIN C,15
	AOSA T4
	IDPB C,T2	;SAVE CHR
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2
	JUMPLE T4,ILFMTR
	AOS ARBCNT
ISTRU1:	TLNN FL,NEGF	;NEGATE?
	AOS (P)	;NO, MATCH
	POPJ P,

ILFMTR:	MOVE T2,CPG	;GIVE HIM AN ERROR MESSAGE AND PAGE
	PUSHJ P,PGPRN	;AND LINE
	MOVE T1,(PNTR)
	PUSHJ P,OUTSN
	NERROR ILFMT

BUTNOT:	TLNE FL,NEGF	;DO NOT ALLOW NEGATIVE BUTNOT
	NERROR ISS
	PUSH P,T2
	PUSH P,ARBCNT	;SAVE IN CASE OF MATCH
	TLO FL,DEMCHR	;MUST BE ANOTHER CHR THERE
	PUSHJ P,REDCHM	;CHECK FOR MATCH
	 JRST BUTNTE	;REAL FAILURE BUT MUST FINISH
	TLZ FL,NEGF	;IN CASE IT GOT TURNED ON AGAIN
	TLO FL,DEMCHR	;MAKE SURE SOMETHING THERE
	PUSHJ P,REDCHM
LOKORD:	 TLZA FL,NEGF	;GOOD RETURN. MAKE SURE FLAG OFF
	JRST POPERR	;IF SECOND MATCHES, ERROR
	POP P,ARBCNT
	POP P,T2	;RESTORE BEFORE DOING ARBIT STORE
	JRST ISTRU	;NOW THAT WE KNOW NEG FLAG IS OFF

BUTNTE:	TLO FL,DEMCHR
	PUSHJ P,REDCHM
	 TLZA FL,NEGF	;JUST WANTED TO READ
	TLZ FL,NEGF
POPERR:	POP P,ARBCNT
	POP P,T2	;FIX STACK
	POPJ P,

LOKOR:	TLOE FL2,ORCHR	;IS THIS THE SECOND TIME
	JRST	[TLZ FL2,ORCHR	;YES, CLEAR FLAG
		AOS (P)	;AND TAKE UNUSUAL, DOUBLE SKIP RETURN
		JRST CPOPJ1]
	PUSH P,T2
	PUSH P,ARBCNT
	TLNE FL,NEGF	;ALLOW NEGATIVE
	JRST LOKORN	;BUT HANDLE DIFFERENTLY
LOKOR1:	TLZ FL,NEGF
	TLO FL,DEMCHR	;NEED A CHR
	PUSHJ P,REDCHM
	 JRST LOKOR1	;DID NOT FIND A MATCH HERE
LOKOR2:	 TLOA FL,DEMCHR	;FOUND A MATCH. SKIP SPECIAL RETURN
	JRST POPERR	;END OF OR, NO MATCH, REAL FAILURE
	PUSHJ P,REDCHM	;KEEP GOING TILL END
	 JRST LOKOR2	;DON'T CARE IF FAILURE OR SUCCESS
	 JRST LOKOR2
	JRST LOKORD	;FINISHED, RESET FLAG AND STORE

LOKORN:	TLZ FL,NEGF	;THIS IS NOT OR
	TLO FL,DEMCHR
	PUSHJ P,REDCHM
	 JRST LOKORN	;OK AS LONG AS IT KEEPS FAILING
	 SKIPA	;ERROR IF IT EVER SUCCEEDS
	JRST LOKORD	;DONE, ALL FAILED, TAKE GOOD RETURN

LOKORE:	TLO FL,DEMCHR	;JUST READ UNTIL END
	PUSHJ P,REDCHM
	 JRST LOKORE
	 JRST LOKORE
	JRST POPERR

ARBITM:	TLNN FL,DEMCHR	;NO MEANING TO DEMAND A CHARACTER
	TLOE FL,ARBITG	;ARE WE SEEING 
	NERROR ISS	;YES, ILLEGAL STRING
	PUSH P,T1	;SAVE SEARCH POINTER
	MOVEI T5,0	;SET ARBITMRARY STRING TO NULL
	IDPB T5,T2
	SOJLE T4,ILFMTR
	AOS ARBCNT
	PUSH P,ARBCNT	;SAVE IN CASE WE COME BACK WITH NO MATCH
	PUSH P,T2
	PUSH P,T4
	PUSH P,C
	CAIN C,12	;IF SO, WE ARE ALREADY TOO FAR
	JRST PROCED	;BUT MAY BE END OF STRING SO MATCH
CHKTHS:	TLO FL,DEMCHR	;NEED A CHARACTER NOW
	PUSHJ P,REDCHM	;CALL SELF RECURSIVELY
	JRST PROCED	;THIS COULD NOT MATCH JUST SCAN ON
	MOVE T2,-3(P)	;RESTORE ARBITM COUNT
	MOVEM T2,ARBCNT
	MOVE T4,-1(P)	;AND ARBITM CHR COUNT
	MOVE T2,-2(P)	;AND POINTER
	PUSH P,ALTP	;SAVE CHR POINTER
	TLZ FL,ARBITG	;CAN SEE ANOTHER  NOW
	PUSHJ P,LINMAT	;A MATCH
	JRST RECUR	;NO, TRY FOR ANOTHER OF THAT CHR
	SUB P,[XWD 7,7]	;GET ALL THAT JUNK OFF STACK
	JRST CPOPJ1 	;AND RETURN TO CALLER OF LINMAT
RECUR:	POP P,ALTP	;GET BACK POINTER
	POP P,C	;AND CHR
	MOVE T4,-2(P)	;RESTORE COUNT
	MOVEM T4,ARBCNT
	POP P,T4
	POP P,T2	;ALSO CHR COUNTER AND POINTER
	DPB C,T2	;PUT IN THAT CHR
	MOVEI T5,0	;AN@ TERMINATOR
	IDPB T5,T2
	SOJLE T4,ILFMTR
	PUSH P,T2
	PUSH P,T4	;RESAVE
	MOVE T1,-3(P)	;RESTORE SEARCH POINTER
	ILDB C,ALTP	;GET ANOTHER CHR
	PUSH P,C	;SAV IT
	TLZ FL,NEGF	;TURN THIS OFF FOR RECURSION
	CAIE C,12	;END OF WORLD?
	JRST CHKTHS
	SUB P,[XWD 5,5]	;RECUCE STACK
	POPJ P,	;AND ERROR RET
PROCED:	TLZ FL,ARBITG!NEGF	;JUST GO ON
	POP P,C
	POP P,T4
	POP P,T2
	POP P,ARBCNT
	POP P,(P)	;GET RID OF EXTRA POINTER
	JRST CHRMAT	;CONTINUE MATCH SCANNING
ARRAY ARBBUF[MXWPL*2+1]
INTEGER ARBCNT
SUBTTL FIND COMMAND (SEARCHES)

;DO A SEARCH OF A FILE

SEARCH:TLZ FL,ASSMF	;CLEAR ALL FLAGS
	TLZ FL2,SRFND
	SETZM LOLN	;JUST LIKE EVERYONE ELSE HAS TO
	SETZM SRCNT	;START WITH ZERO
	MOVE T1,[POINT 7,SRBUF]	;SET UP BYTE POINTER
	MOVEI T3,SRPNT	;AND POINTER TO BYTE POINTER TABLE
	PUSHJ P,SSTRNG	;GET A SEARCH STRING
	JRST	[SKIPN SRPNT	;WAS STRING SET?
		NERROR NSG	;NO, TELL HIM
		CAIN C,12
		JRST ASSMD1	;SPECIAL CONTINUE MODE
		JRST .+1]	;YES, USE OLD ONE
	TLZ FL,NUMSRF!ALTSRF!EXCTSR	;CLEAR FLAGS
	PUSHJ P,SCAN	;CHECK FOR WHAT COMES AFTER
	TRNN FL,TERMF	;IF TERMINATOR
	CAIN C,","	;OR ,
	JRST ASSMDT	;SET UP LIMITS SPECIALLY
	CAIE C,"!"
	CAIN C,":"
	JRST ASSMDT	;LET HIM SPECIFY 2ND HALF OF RANGE
	PUSHJ P,GET2	;ELSE CALL USUAL LIMIT ROUTINE
SRC4:	MOVE T1,HILN	;SAVE END OF RANGE
	MOVEM T1,SRHILN
	MOVE T1,HIPG
	MOVEM T1,SRHIPG
	CAIE C,","	;ANY MORE ARGUMENTS?
	JRST SRC1	;NO, CHECK TERMINATOR AND PROCEED
	PUSHJ P,SCAN	;YES, SEE WHAT IT IS
	TRNN FL,IDF	;SHOULD BE IDENT OR NUMBER
	JRST SRC2	;NOT IDENT, CHECK FOR NUMBER OF SEARCHES
	MOVS T1,ACCUM	;GET THE IDENT
	CAIN T1,'N  '	;AND FIND OUT WHAT IT IS
	TLO FL,NUMSRF
	CAIN T1,'A  '
	TLO FL,ALTSRF	;FIRST CHECK FOR A OR N
	TRNE FL,READOF	;IF READ ONLY AND ALTER
	TLNN FL,ALTSRF
	SKIPA
	NERROR ILC	;WE DO NOT PERMIT IT
	TLNN FL,NUMSRF!ALTSRF	;WAS IT EITHER?
	JRST SRC3	;NO, CHECK E
	PUSHJ P,SCAN	;CONTINUE LOOKING
	CAIE C,","
	JRST SRC1	;NO MORE ARGUMENTS
	PUSHJ P,SCAN	;WELL WHAT KIND IS THIS ONE?
	TRNN FL,IDF	;MORE IDENTS?
	JRST SRC2	;NO, MUST BE NUMBER OF SEARCHES
	MOVS T1,ACCUM
SRC3:	CAIE T1,'E  '
	NERROR ILC	;NO, HE MUST HAVE MADE A MISTAKE
	TLO FL,EXCTSR	;YES, REMEMBER IT
	PUSHJ P,SCAN	;AND CHECK FOR MORE
	CAIE C,","
	JRST SRC1	;NO MORE
	PUSHJ P,SCAN	;ONLY ONE THING IT CAN BE NOW
SRC2:	TRNN FL,NUMF
	NERROR ILC	;NOPE, LOSE
	MOVEM T2,SRCNT	;SAVE AS COUNT OF LINES TO FIND
	PUSHJ P,SCAN	;GET TERMINATOR (WE HOPE)
SRC1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT THIS DOSNT
SRCH1A:	MOVEI T1,SRPNT	;GET POINTER TO STRINGS
	PUSHJ P,CODSR	;AND GENERATE CODE

	MOVE T1,LOPG	;GET SET TO HUNT IT
	MOVEM T1,DPG
	MOVEM T1,SRPG	;FLAG TO SAY IF WE SHOULD PRINT PAGE
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;NO LINES YET
ONSRC:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST ENDSRC	;DONE
	TLZE FL,ASSMF	;FIRST TIME AND WANT .+1?
	JRST	[CAME T1,LOLN	;IS THERE EXACT MATCH?
		JRST .+1	;NO, THIS IS .+1
		AOS SVCNT	;PRETEND WE DIDNT SEE IT
		JRST SRNXT]	;AND TAKE NEXT
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;PAGES ARE SPECIAL
	JRST SRCPAG	;SO TAKE GOOD CARE OF THEM
	MOVEI T2,SRPNT	;POINTER TO STRINGS
	PUSHJ P,COMSRC	;GO SEARCH THIS LINE
	JRST SRNXT	;LOSER
	TLO FL2,SRFND
	MOVEM T3,SVCCNT	;SAVE AWAY THE CHARACTER COUNT
	MOVE T2,CPG	;GET CURRENT PAGE
	CAME T2,SRPG	;AND SEE IF WE SHOULD PRINT IT
	PUSHJ P,PGPRN	;YES
	MOVE T2,CPG	;NOW SET IT AS CURRENT
	MOVEM T2,CPGL
	MOVEM T2,SRPG	;ALSO RESET FLAG
	MOVE T2,(PNTR)	;ALSO SET LINE
	MOVEM T2,CLN
	TLNE FL,ALTSRF	;ARE WE GOING TO EDIT?
	JRST SRCALT	;YES, GO SET THINGS UP
	TLNE FL,NUMSRF	;DO WE WANT ONLY LINE NUMBERS?
	JRST SRCNUM	;YES
	MOVE T1,PNTR	;GO PRINT LINE
	PUSHJ P,OUTLIN
SRNXTC:	SOSG SRCNT	;HAVE WE FOUND ENOUGH
	JRST COMND	;YES, GIVE UP (WE HAVE SEEN AT LEAST ONE)
SRNXT:	PUSHJ P,FINDN	;GET NEXT LINE TO LOOK A
	JRST ONSRC
SRCNUM:	MOVE T1,(PNTR)	;PRINT SEQUENCE NUMBER
	PUSHJ P,OUTSN
	OUTSTR [ASCIZ /
/]
	JRST SRNXTC	;AND GO
ENDSRC:	TRZN FL,LINSN!RENSN	;DID WE SEE ONE?
	NERROR NLN	;NULL RANGE
	TLNE FL2,SRFND
	JRST COMND	;GO
	SETOM SRHIPG	;FLAG NEG AS FLAG TO RESTART
	NERROR NMF
SRCPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST SRNXT	;AND PROCEED

SRCALT:	PUSHJ P,SETALT	;SET THINGS UP
	SKIPLE T2,SVCCNT#	;GET COUNT (DO NOT CALL IF 0
	PUSHJ P,ALTSP	;SPACE OVER CORRECTLY
	PUSHJ P,ALTN1	;GO ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;MAKE SURE WE HAVE NOT GOTTEN TOO BIG
	MOVE T1,(PNTR)	;GET POINTER BACK
	SOSG SRCNT
	JRST COMND	;DONE
	JRST ONSRC	;GO ON

ASSMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASSMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN	;SET THINGS UP FOR . TO INFINITY
	MOVEM T1,LOLN
	MOVEM T1,HILN	;AS GOOD AS ANYTHING WITH THE PAGE WE WILL
	MOVE T1,CPGL	;USE
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPC	;YES
	CAIE C,":"	;IF A : OR !
	CAIN C,"!"
	JRST HALFSP	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST SRC4	;BACK INTO THINGS

HALFSP:	MOVEM T1,HIPG	;SET TOP AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST SRC4	;AND GO

NOSPC:	MOVE T1,SRHILN
	MOVEM T1,HILN	;PUT BACK END
	MOVE T1,SRHIPG
	MOVEM T1,HIPG
	JUMPGE T1,SRCH1A
	OUTSTR [ASCIZ /
RESTARTING FROM START OF FILE
/]
	MOVSI T1,377777
	MOVEM T1,HIPG
	MOVEM T1,SRHIPG
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,LOLN
	MOVEI T1,1
	MOVEM T1,LOPG
	TLZ FL,ASSMF
	JRST SRCH1A	;AND GO

INTEGER SRHIPG,SRHILN,SRCNT,SRPG
ARRAY SRBUF[SRBLG/5+2]
ARRAY SRPNT[SRNUM]
SUBTTL ALTMODE AND LINE FEED COMMANDS

NXTLIN:MOVE T1,CPGL	;REALLY FIND THE CURRENT LINE
	MOVEM T1,DPG
	MOVE SINDEX,CLN
	PUSHJ P,FIND
	CAMN T1,CLN	;DID WE REALLY FIND IT
	PUSHJ P,FINDN	;YES, GET NEXT ELSE WE ALREADY HAVE IT
	JUMPE T1,[NERROR NLN]	;EOF AND NOT FOUND
	OUTSTR [BYTE (7) 15]
NXTL1:	CAMN T1,PGMK	;IS THIS A PAGE MARK?
	JRST NXTPG	;TREAT SPECIALLY
	MOVEM T1,CLN	;SET AS CURRENT
	MOVE T1,PNTR	;GET THE CURRENT POINTE
	PUSHJ P,OUTLIN	;AND PRINT
	JRST COMND	;DONE
NXTPG:	AOS T2,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T2,CPGL
	PUSHJ P,PGPRN	;TELL HIM
	PUSHJ P,FINDN	;FIND A LINE ON IT
	JUMPN T1,NXTL1	;THERE IS ONE THERE, PRINT IT
	MOVE T1,[ASCIZ /00000/]	;END OF FILE, SET TO THAT PAGE
	MOVEM T1,CLN
	JRST COMND

BAKLIN:MOVE T1,CPGL	;FIND CURRENT
	MOVEM T1,DPG
	MOVE SINDEX,CLN
	PUSHJ P,FIND
	TRNE FL,BOF	;IF NOT AT START OF FILE
	CAME PNTR,BUFP	;OR NOT AT START OF BUFFER
	SKIPA
	NERROR NLN
	OUTSTR [ASCIZ /
/]
BAK1:	PUSHJ P,FINDB
	CAMN T1,PGMK
	JRST PRVPAG	;TELL HIM WE CROSSED A PAGE BOUNDARY
	MOVEM T1,CLN	;SET AS CURRENT
	MOVE T1,PNTR
	PUSHJ P,OUTLIN
	JRST COMND
PRVPAG:	MOVE T2,CPG
	MOVEM T2,CPGL
	PUSHJ P,PGPRN
	TRNE FL,BOF	;CHECK FOR START OF WORLD
	CAME PNTR,BUFP
	JRST BAK1	;OK, BACK UP SOME MOR
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,CLN
	JRST COMND
SUBTTL COPY AND TRANSFER COMMANDS

TRANS:	SETZM RMPG#	;FLAG WHICH WORRYS ABOUT FINDB NOT RETURNING
	TLOA FL,TRANFL	;SET AS TRANSFER COMMAND
COPY:	TLZ FL,TRANFL	;JUST TO MAKE SURE
	SETZM LOLN	;A GOOD THING TO DO
	SETZM SVJRL2	;NO SECOND JOBREL SAVED
	PUSHJ P,GET10S	;GET PLACE TO PUT LINES
	MOVE T1,HIPG	;STORE IT AWAY FOR LATER
	MOVEM T1,DESTPG
	MOVE T1,HILN
	MOVEM T1,DESTLN
	CAIN C,"="	;DOES HE WANT TO COME FROM ANOTHER FILE?
	JRST ALTFIL	;YES
	TLZ FL,COPFIL	;NO, MAKE SURE FLAG IS OFF
COPY1:
	CAIE C,","	;SHOULD BE COMMA EVEN IF FROM ALTFIL
	NERROR ILC	;HE MUST SAY WHERE TO PUT IT
COPY1A:	PUSHJ P,GET2S	;GO GET PLACE TO FIND LINES
	MOVE T1,INCR	;SEV INCREMENT AS CURRENT
	MOVEM T1,FINCR
	SETZM SINCR	;SET NO SECOND INCREMENT
	CAIE C,","	;CHECK FOR MORE ARGUMENTS
	JRST CKTRMC	;NO, LOOK FOR TERMINATOR
	PUSHJ P,SCAN
	CAME T1,[<ASCII /00000/>+1]	;AVOID 0 INCREMENTS
	TRNN FL,NUMF	;SHOULD BE INCREMENT, MUST BE NUMBER
	NERROR ILC
	MOVEM T1,FINCR
	PUSHJ P,SCAN
	CAIE C,","
	JRST CKTRMC
	PUSHJ P,SCAN
	CAME T1,[<ASCII /00000/>+1]
	TRNN FL,NUMF
	NERROR ILC
	MOVEM T1,SINCR
	PUSHJ P,SCAN
CKTRMC:	TRNN FL,TERMF
	NERROR ILC	;DID NOT END PROPERLY, LOSE
	PUSHJ P,SETCOP	;SET UP BUFFER AREA FOR COPY
	MOVE T1,LOPG	;LOOK FOR SOURCE
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND

	TRZ FL,LINSN	;AND NO LINES
	TLNN FL,TRANFL	;IS THIS A TRANSFER COMMAND?
	JRST GOCOP	;NO, IGNORE ALL THIS SPECIAL STUFF
	HRRZM ALTP,STARTD	;SAVE THE START OF DELETED CODE
	HRRZM ALTP,ENDD	;AND THE END
	MOVE T1,CPG	;GET THE PAGE ON WHICH DELETION STARTS
	MOVEM T1,TRANST	;AND SAVE IT
	SKIPN -1(PNTR)	;ARE WE AT THE START OF THE BUFFER
	TRNN FL,BOF	;AND OF THE WORLD
	SKIPA
	JRST BEGFIL	;YES, DO NOT LOOK BACK
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	CAMN T1,PGMK	;A PAGE IS SPECIAL
	JRST SPCPG
	MOVEM T1,BOTLIN	;SAVE IT FOR LATER
	PUSHJ P,FINDN	;GO FORWARD AGAIN
	JRST GOCOP
SPCPG:	SKIPE LOLN	;DO WE INTEND TO ABSORD THIS ONE
	JRST BEGFIS	;MOVE FORWARD AND RECORD
	SKIPN -1(PNTR)	;CHECK FOR START OF WORLD AGAIN
	TRNN FL,BOF
	SKIPA
	JRST BEGFIS
	PUSHJ P,FINDB	;BACK UP
	AOS CPG		;FIX PAGE COUNT
	PUSH P,T1	;SAVE THAT LINE
	PUSHJ P,FINDN
	PUSHJ P,FINDN	;AND GO BACK WHERE WE BELONG
	POP P,T1	;GET LINE NUMBER BACK
	CAMN T1,PGMK	;THERE'S THAT PAGE AGAIN
	JRST BEGFIA
	MOVEM T1,BOTLIN	;SAVE LINE NUMBER
	JRST GOCOP
BEGFIS:	AOSA CPG
BEGFIA:	AOSA CPG
BEGFIF:	PUSHJ P,FINDN
BEGFIL:	SETOM BOTLIN	;A VERY SMALL NUMBER
GOCOP:	SETZM PGDELS	;TOTAL NUMBER OF PAGES DELETED IS 0
	SKIPE LOLN	;DID HE ASK FOR THE WHOLE PAGE
	JRST NOISTP	;NO
	MOVE T1,PGMK	;YES, PUT IN THE PAGE MARK
	MOVEM T1,1(ALTP)
	MOVE T1,[BYTE (7) 15,15,14]
	MOVEM T1,2(ALTP)
	HRRZM ALTP,LSTPG
	ADD ALTP,[XWD 2,2]
	SETZM NLIN1	;NO LINES ON FIRST PAGE
	TLNN FL,TRANFL	;IS THIS A TRANSFER
	JRST NOISTP	;NO, START TRANSFER OF DATA
	MOVE T1,CPG	;CHECK TO SEE IF WE SHOULD REALLY DELETE
	CAIN T1,1	;NOT IF PAGE 1
	JRST RSTSTP
	PUSHJ P,FINDB	;GET THAT PAGE
	SETZM NCNT	;DELETE
	MOVEI T1,2
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE WE ARE AT THE LINE WE WERE AT
	AOS CPG		;KEEP COUNT STRAIGHT
	AOSA PGDELS	;ONE DELETED
RSTSTP:	HRRZM ALTP,STARTD	;RESET START IF NONE DELETED
	HRRZM ALTP,ENDD	;RESET END

NOISTP:	MOVE T1,(PNTR)	;MAKE SURE WE HAVE THAT JUNK BACK
ONCOPY:	PUSHJ P,ONMOV	;STILL IN RANGE?
	JRST ENDCOP	;NO, START INSERTING
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;IS IT A PAGE?
	JRST MOVPG	;YES, TREAT SPECIAL
MOVLNC:	MOVE T1,PNTR	;START TRANSFER
	PUSHJ P,COPLIN	;NOW MOVE THE LINE
	TLNN FL,TRANFL	;IS THIS TRANSFER?
	JRST NXTLCP	;NO, DON'T DELETE
	HRRZM ALTP,ENDD	;SAVE END OF DELETED TEXT
	SETZM NCNT
	SUBI T1,-1(PNTR)	;GET LENGTH
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE A LINE IS THERE
	SKIPA		;SKIP THE FINDN
NXTLCP:	PUSHJ P,FINDN	;YES, GET NEXT
	AOS NLIN2	;ONE MORE LINE
	JRST ONCOPY

MOVPG:	AOS CPG	;WE ARE ON NEXT PAGE
	MOVE T1,NLIN2
	SKIPGE NLIN1	;PUT ON FIRST PAGE IF NOT SOME ALREADY THERE
	MOVEM T1,NLIN1
	SETZM NLIN2
	HRRZM ALTP,LSTPG	;SAVE RECORD OF WHERE SEEN
	AOS PGDELS	;RECORD ONE MORE PAGE DELETED
	JRST MOVLNC	;NOW MOVE IT

ENDCOP:	SETZM 1(ALTP)	;MAKE SURE THERG IS AN END FLAG THERE
	TRNE FL,RENSN	;DID WE EXIT BECAUSE OF
	JRST COMND	;REENTER?? THEN GET OUT,(ON COPY, TRANS WILL HAPPEN)
	TRNN FL,LINSN	;WERE THERE ANY THERE?
	NERROR NLN	;NO LOSE
	TLZE FL,COPFIL	;ARE WE COMMING OFF A FILE
	PUSHJ P,RSCOP	;YES, RESET POINTERS
	MOVE T1,DESTPG	;LOOK FOR DESTINATION
	MOVEM T1,DPG

	TLNN FL,TRANFL	;IS IT A TRANSFER?
	JRST DOINS1	;NO, PUT THE COPIED TEXT IN
	SETZM PGINSD	;NO EXTRA PAGE MARK INSERTED YET
	SKIPN T2,(PNTR)	;ARE WE AT EOF
	JRST NOPGIN	;YES, DO NOT INSERT A PAGE MARK
	CAME T2,PGMK	;ALSO NOT IF PAGE MARK
	CAMLE T2,BOTLIN	;OR GREATER THAN LINE LEFT OVER
	SKIPA
	SETOM PGINSD	;WE WILL HAVE TO INSERT ONE
NOPGIN:	MOVN T2,PGDELS	;GET MINUS NUMBER OF PAGES DELETED
	SUB T2,PGINSD	;ONE LESS IF A PAGE MARK INSERTED
	CAMGE T1,TRANST	;(T1 HAS DEST. PAGE) IF SMALLER THAN START
	JRST DOSUB	;EVERYTHING IS OK
	CAMN T1,TRANST	;IS IT SAME?
	JRST DSEQTR	;SPECIAL CHECK REQUIRED
	CAMGE T1,CPG	;INSIDE RANGE DELETED?
	NERROR ITD	;LOSE BIG
	CAMN T1,CPG	;SAME AS TOP PAGE?
	JRST DSEQCP
	ADDM T2,DESTPG	;ADJUST PGE WE ARE TO FIND
	ADDM T2,DPG
DOSUB:	ADDM T2,CPG	;ADJUST FOR REMOVED PAGES
	ADDM T2,INPG
	ADDM T2,BGPG
	MOVEM T2,RMPGCH#	;REMEMBER AMOUNT ADDED
	SKIPN PGINSD	;SEE IF WE WANT TO INSERT ONE
	JRST DOINS1
	MOVE T1,PGMK
	MOVEM T1,LIBUF
	MOVE T1,[BYTE (7) 15,15,14]
	MOVEM T1,LIBUF+1
	SETZM OCNT
	MOVEI T1,2
	MOVEM T1,NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN	;ADVANCE OVER IT
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	OUTSTR [ASCIZ /PAGE MARK INSERTED TO PREVENT ORDER ERROR
/]
	JRST DOINS1
ALLSAM:	SKIPN LOLN
	SKIPE PGINSD	;IF DID NOT DELETE PAGE OR INSERTED ONE
	JRST DOSUB	;ALL OK
	SKIPE T1,(PNTR)	;ELSE MUST BE IN UPPER PART
	CAMN T1,PGMK
	NERROR ITD	;THERE IS NO UPPER PART
	CAMLE T1,DESTLN
	NERROR ITD
	SOS T1,DESTPG	;THIS WILL BE ON A LOWER PAGE
	MOVEM T1,DPG
	JRST DOSUB

DSEQTR:	CAMN T1,CPG	;IS IT ALL ON SAME PAGE?
	JRST ALLSAM	;YES, SPECIAL CHECKING
	SKIPN LOLN	;DID WE START WITH A PAGE
	NERROR ITD	;YES, LOSE
	SKIPE PGINSD	;WAS THERE A PAGE INSERTED?
	JRST DOSUB	;YES, ALL OK
	SKIPE T1,(PNTR)	;FIND OUT WHAT THE NEXT LINE IS
	CAMN T1,PGMK
	JRST DOSUB	;THIS WILL BE OK
	CAMG T1,DESTLN	;SEE IF WE ARE IN TROUBLE
	NERROR ITD
	JRST DOSUB	;OK
DSEQCP:	SKIPE PGINSD	;WAS ONE INSERTED
	JRST AOSTRA	;SET PAGE PROPERLY
	MOVE T1,DESTLN
	CAMG T1,BOTLIN
	NERROR ITD
	SKIPA T1,TRANST
AOSTRA:	AOS T1,TRANST
	MOVEM T1,DESTPG
	MOVEM T1,DPG	;ALSO SET THIS
	JRST DOSUB
DOINS1:	MOVEM PNTR,RMPTR#	;IN CASE FIND DOES NOT RETURN
	MOVE SINDEX,CPG
	MOVEM SINDEX,RMPG
	MOVE SINDEX,DESTLN
	PUSHJ P,FIND
	MOVE T1,CPG
	CAME T1,DESTPG	;PAGES MUST MATCH
	JRST	[TLNN FL,TRANFL
		NERROR NSP
		MOVE T1,PGMK
		MOVEM T1,LIBUF
		MOVE T1,[BYTE (7) 15,15,14]
		MOVEM T1,LIBUF+1
		SETZM OCNT
		MOVEI T1,2
		MOVEM T1,NCNT
		PUSHJ P,INSED
		PUSHJ P,FINDN
		PUSHJ P,FILLB
		AOS CPG
		AOS INPG
		AOS BGPG
		OUTSTR [ASCIZ /TEXT INSERTED AT END OF FILE
/]
		MOVE T1,CPG
		JRST .+1]
	MOVEM T1,CPGL	;SET THIS AS CURRENT PAGE
	MOVE T1,DESTLN	;GET THE PAGE NUMBER TO PUT OUT
	MOVEM T1,CLN	;AND THIS AS CURRENT LINE
	MOVEM T1,SVLNUM
	CAME T1,(PNTR)	;IS THIS WHERE WE ARE GOING TO INSERT?
	JRST NONEQI	;NO, DO NOT WORRY
	SKIPGE NLIN1	;ONE MORE LINE(TO MAKE INC SMALLER)
	AOSA NLIN2	;BUT ONLY ON CORRECT NUMBER
	AOS NLIN1
	PUSHJ P,FINDN	;MOVE FORWARD A LINE
	TRO FL2,CTOEQF	;AND SET FLAG SO WE DO ASCIAD FOR FIRST
NONEQI:	MOVE ALTP,SVJRL	;POINT TO START OF LINES TO COPY
	TLZ FL,TRANFL	;THIS FLAG NO LONGER NEEDED

	SKIPE T3,(PNTR)	;GET NEXT LINE AFTER THE INSERT
	CAMN T3,PGMK
	JRST	[MOVEI T1,^D100000	;USE HIGH NUMBER IF NONE THERE
		JRST SETHIC]
	PUSHJ P,NUMCON	;CONVERT ASCID TO NUMBER
SETHIC:	MOVEM T1,HIGH1	;SAVE FOR LATER
	MOVE T3,DESTLN	;GET NUMBER OF FIRST LINE TO BE INSERTED
	PUSHJ P,NUMCON
	MOVEM T1,DESTN	;SAVE IT TOO
	SKIPGE NLIN1	;DID WE SEE ANY PAGE MARKS?
	JRST ONSET	;NO, ONLY ONE INC TO WORRY ABOUT
	SKIPE SINCR	;WAS A SECOND INCREMENT GIVEN?
	JRST DOSINC	;YES
	SKIPE T3,(PNTR)
	CAMN T3,PGMK	;ARE THERE ANY LINES AFTER IT
	JRST OKINC2	;NO, OK TO LEAVE LINES AS THEY ARE
DOSINC:	MOVE T1,HIGH1	;CALCULATE MAX POSSIBLE INCREMENT
	AOS T2,NLIN2	;WICH WILL NOT RUIN ORDER
	IDIV T1,T2
	JUMPE T1,ORDSEC	;THERE IS NO POSSIBLE GOOD ONE
	CAIL T1,^D100000	;A VERY LARGE ONE IS POSSIBLE
	JRST OKINC2	;SO JUST USE THE ONE GIVEN
	PUSHJ P,ASCON	;CONVERT TO ASCID
	SKIPN SINCR	;WAS THERE AN INC GIVEN?
	JRST	[MOVE T1,LSTLN	;GET THE HIGHEST LINE PICKED UP
		CAML T1,(PNTR)	;SEE IF IT IS OK
		JRST ONST3	;NO
		JRST OKINC2]
	CAML T3,SINCR	;SEE IF ONE GIVEN IS OK
	JRST OKINC2	;YES
ONST3:	MOVEM T3,SINCR	;NO, STORE CALCULATED
ONST2:	MOVEM T3,PRNTO2	;AND TELL HIM
	OUTSTR ASCIZ2
OKINC2:	MOVEI T1,^D100000	;FIND A SUITABLE FIRST INCREMENT
	SUB T1,DESTN
	SKIPN NLIN1	;WERE THERE ANY?
	JRST INSL2A	;NO, ALL IS OK
	IDIV T1,NLIN1	;GET USABLE ONE
	JUMPE T1,ORDCP2	;NONE POSSIBLE
	CAIL T1,^D100000
	JRST INSL2A	;ALL OK
	PUSHJ P,ASCON	;CONVER
	CAML T3,FINCR	;IS ONE GIVEN SMALLER?
	JRST INSL2A	;YES, ALL OK
	MOVEM T3,FINCR
	JRST ONST1	;LET HIM KNOW

ONSET:	SKIPG NLIN2	;WERE THERE ANY?
	JRST INSL2A	;ALL OK
	MOVE T1,HIGH1
	SUB T1,DESTN
	IDIV T1,NLIN2	;CALCULATE INCREMENT
	JUMPE T1,ORDCOP	;NONE POSSIBLE
	CAIL T1,^D100000
	JRST INSL2A	;VERY BIG, ALL OK
	PUSHJ P,ASCON
	CAML T3,FINCR	;IS ONE GIVEN SMALLER?
	JRST INSL2A
	MOVEM T3,FINCR
ONST1:	MOVEM T3,PRNTO1	;PUT IN IN PRINT POSITION
	OUTSTR ASCZ1
	JRST INSL2A	;HE HAS BEEN TOLD

ORDCP2:	SKIPA T3,[ASCII /WAR  /]
ORDCOP:	MOVE T3,[ASCII /ORDER/]
	JRST ONST1

ORDSEC:	MOVE T3,[ASCII /ORDER/]
	JRST ONST2

ASCON:	MOVSI T3,400000	;WILL BECOME LOW ORDER BIT
ASCO2:	IDIVI T1,^D10
	ADDI T2,"0"
	LSHC T2,-7
	TRNN T3,1	;HAS IT GOTTEN THERE?
	JRST ASCO2
	POPJ P,

NUMCON:MOVEI T1,0
	TRZ T3,1	;GET RID OF LOW ORDER BIT
NUMC1:	MOVEI T2,0
	LSHC T2,7
	IMULI T1,^D10
	ADDI T1,-"0"(T2)
	JUMPN T3,NUMC1
	POPJ P,

INSL2A:	TRZN FL2,CTOEQF	;IF FLAG
	JRST INSL2	;FLAG WILL FALL THROUGH AND DO ASCIAD

INSLN:	MOVE T2,FINCR	;GENERATE NEW SEQUENCE NUMBER
	SKIPN T1,SVLNUM	;BUT ONLY IF WE ARE SUPPOSED TO
	JRST INSL2
	PUSHJ P,ASCIAD
	MOVEM T1,SVLNUM	;PUT EITHER NGW OR 0 BACK
INSL2:	SETZM LIBUF	;ZERO OUT PLACE TO PUT LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET UP OUTPUT POINTER
	SKIPN T2,1(ALTP)	;AT END?
	JRST INSDON	;FINISHED
INS1:	MOVEM T2,(T1)	;PUT IT AWAY
	ADDI ALTP,1	;NEXT
	SKIPN T2,1(ALTP)	;CHECK FOR END OF LING
	JRST DOINS
	TRNN T2,1	;BY EITHER METHOD
	AOJA T1,INS1	;GO ON WITH TRANSFER
DOINS:	SUBI T1,LIBUF-1	;GET COUNT
	MOVEM T1,NCNT	;AND SET AS NEW
	SETZM OCNT	;OLD IS ZERO
	MOVE T1,LIBUF	;GET SEQ NUM
	CAMN T1,PGMK	;CHECK FOR PAGE
	JRST INSPG	;AND DO SPECIAL
	SKIPN T1,SVLNUM	;IF A NON-ZERO NUMBER THEN REPLACE
	MOVE T1,LIBUF
	MOVEM T1,LIBUF
NOINCR:	MOVEM T1,CLN	;SET AS CURRENV LINE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN	;GET NEXT
	PUSHJ P,FILLB	;AND DUMP IF NEEDED
	JRST INSLN	;GO PUT IN MORE

INSPG:	AOS T3,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T3,CPGL	;SET AS CURRENV
	MOVE T1,[<ASCII /00000/>+1]	;SET TO SAY LINE 0
	AOS BGPG	;ONE MORE PAGE IN FILE
	AOS INPG
	SETZM SVLNUM	;DO NOT DO ANY MORE SEQUENCE REPLACEMENT
	MOVEI T2,-2(ALTP)	;SINCE WE HAVE ALREADY GONE PAST
	CAMN T2,LSTPG	;UNLESS STARTING LAST PAGE
	SKIPN T3,SINCR	;ANF SECOND SEQUENCE NUMBER GIVEN
	JRST NOINCR
	MOVEM T3,FINCR	;SET UP INCREMENT
	MOVEI T3,1	;AND RESTART NUMBERING
	MOVEM T3,SVLNUM
	JRST NOINCR

INSDON:

COPDON:RELEASE ALTDV,0	;JUST FOR GOOD MEASURE
	TLZE FL,COPFIL	;ARE WE COPYING FROM A FILE (ERRORS ONLY)
	PUSHJ P,RSCOP	;YES, CLEAN UP POINTERS
	TLZ FL,ISCOP	;RESET COPY FLAG
	TLNN FL,TRANFL	;IF TRANSFER, WE MUST REINSERT
	JRST COPD1	;NO
	MOVE ALTP,STARTD
	SKIPN T1,RMPG	;DID WE BOMB OUT ON A FIND
	JRST REINXT	;NO, ALL OK
	MOVEM T1,CPG	;THIS IS WHERE WE SHOULD BE
	MOVE PNTR,RMPTR	;AND POINTER INTO BUFFER (HAS NOT CHANGED)
	MOVN T1,RMPGC#	;NUMBER TO ADD
	ADDM T1,CPG
	ADDM T1,INPG
	ADDM T1,BGPG
	SKIPN PGINSD	;DID WE INSERT A PAGE MARK??
	JRST REINXT	;NO
	MOVEI T1,2	;GET READY TO DELETE IT
	MOVEM T1,OCNT
	SETZM NCNT
	PUSHJ P,FINDB	;BACK UP TO IT
	AOS CPG		;SINCE FINDB WILL DECREMENT IT
COMMENT * THIS LINE MUST BE IN BUFFER BECAUSE OF A FINDB
WE DID BACK AT THE START TO SEE IF A PAGE MARK WAS NEEDED*
	PUSHJ P,INSED	;DELETE IT
REINXT:	MOVEI T1,LIBUF
	CAMN ALTP,ENDD
	JRST COPD1	;ALL DONE
	MOVE T2,1(ALTP)
	JRST REINWD
REINS:	MOVE T2,1(ALTP)
	CAME ALTP,ENDD
	TRNE T2,1
	JRST ENDLIN	;DONE WITH THIS LINE
REINWD:	MOVEM T2,(T1)
	ADDI T1,1
	AOJA ALTP,REINS
ENDLIN:	SETZM OCNT
	SUBI T1,LIBUF
	MOVEM T1,NCNT
	PUSHJ P,INSED	;INSERT LINE
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	JRST REINXT
COPD1:	SKIPN T1,SVJRL2	;USE THIS IF SET
	MOVE T1,SVJRL	;ELSE THIS
	CORE T1,	;TO RESTORE PROPER AMOUNT OF CORE
	ERROR ICN	;THIS SHOULD NEVER HAPPEN
	JRST COMND	;FINISH UP

ALTFIL:	TLNE FL,TRANFL	;ANOTHER FILE IS NOT LEGAL IN TRANSFER
	NERROR ILC
	PUSHJ P,SCAN
	MOVEI T1,COPUSR
	PUSHJ P,READNM
	NERROR ILC
	TLNE FL2,RSW!BSW
	NERROR ILC
DONNAM:	MOVE T1,JOBREL	;SET THINGS UP
	MOVEM T1,SVJRL2
	ADDI T1,4000	;ASK FOR 1 K FOR BUFFERS
	TLO FL,ISCOP	;TELL THE WORLD WHAT WE HAVE DONE
	CORE T1,	;IS IT THERE?
	NERROR NEC
	MOVE T1,SVJRL2	;POINT BUFFERS TO RIGHT PLACE
	MOVEM T1,JOBFF
	INIT ALTDV,14	;GET IT
	SIXBIT /DSK/
	ALTBF
	NERROR DNA	;MAYBE ITS HEREDITARY
	PUSH P,NAMI+3	;SAVE THIS BEFORE THE LOOKUP DESTROYS IT
	LOOKUP ALTDV,NAMI
	NERROR FNF
	INBUF ALTDV,2	;GET BUFFER SPACE
	MOVE T1,ORGPPN	;SAVE OLD NAMES
	EXCH T1,(P)	;AND REPLACE BY NEW
	MOVEM T1,ORGPPN	;IN CASE WE HAVE TO BACK UP
	MOVE T1,NAMI
	PUSH P,ORGNAM
	MOVEM T1,ORGNAM
	HLLZ T1,NAMI+1
	PUSH P,ORGEXT
	MOVEM T1,ORGEXT

	MOVE T1,JOBREL
	SUBI T1,2*MXWPL+2	;SET UP THE VARIOUS POINTERS
	PUSH P,FILPT	;SEE STPT FOR MORE INFO
	MOVEM T1,FILPT
	MOVEI T1,1
	PUSH P,CPGL
	MOVEM T1,CPGL
	MOVE T1,[<ASCII /00000/>+1]
	PUSH P,CLN
	MOVEM T1,CLN
	MOVE T1,JOBFF
	SETZM (T1)
	ADDI T1,1
	PUSH P,BUFP
	MOVEM T1,BUFP
	MOVE T1,JOBREL
	SUB T1,BUFP
	MOVE T2,T1
	SUBI T2,MXWPL+1
	PUSH P,MAXWC
	MOVEM T2,MAXWC
	ASH T1,-1
	PUSH P,HLFWC
	MOVEM T1,HLFWC
	MOVEI T1,1
	PUSH P,CPG
	PUSH P,INPG
	MOVEM T1,CPG
	MOVEM T1,INPG
	PUSH P,PNTR
	MOVE PNTR,BUFP
	PUSH P,SVWD
	SETZM SVWD
	PUSH P,OLDLIN
	SETZM OLDLIN
	PUSH P,WC
	SETZM WC
	MOVSI T1,1
	PUSH P,BGPG
	MOVEM T1,BGPG
	MOVE T1,FL	;SAVE SELECTED FLAGS
	AND T1,[XWD TECOF+FSTOPF,READOF!BOF!EOF!EOF2!BGSN]
	PUSH P,T1
	TRZ FL,EOF!EOF2
	TRO FL,READOF!BOF
	TLZ FL,TECOF
	TLO FL,FSTOPF
	MOVEM P,COPDL	;SAVE PDL FOR LATER
	TLO FL,COPFIL	;WE ARE USING OTHER FILE POINTERS
	PUSHJ P,FILLBF
	TLNN FL2,SSW
	JRST COPY1

	TRNN FL,TERMF	;MUST END HERE
	NERROR ILC
	TLO FL,SRCOP	;SET THINGS UP
	JRST COMND	;AND GO GET COMMANDS

DSCOP:	TLZ FL,SRCOP	;TURN IT OFF
	MOVEI T1,[ASCIZ /SOURCE LINES=/]
	SETZM LOLN	;THIS MAY HAVE GOTTEN RESET
	PUSHJ P,GNCHGT
	JRST COPY1A	;GO GET REST OF COMMAND STRING

RSCOP:	POP P,T2
	MOVE P,COPDL	;GET PDL BACK
	POP P,T1
	TRZ FL,READOF!BOF!EOF!EOF2!BGSN	;RESTORE SELECTED FLAGS
	TLZ FL,TECOF!FSTOPF
	IOR FL,T1
	POP P,BGPG
	POP P,WC
	POP P,OLDLIN
	POP P,SVWD
	POP P,PNTR
	POP P,INPG
	POP P,CPG
	POP P,HLFWC
	POP P,MAXWC
	POP P,BUFP
	POP P,CLN
	POP P,CPGL
	POP P,FILPT
	POP P,ORGEXT	;GET NAMES BACK
	POP P,ORGNAM
	POP P,ORGPPN
	JRST (T2)	;NOW RETURN

COPGET:SOSG ALTBF+2	;GET A WORD FROM COPY FILE
	JRST GETDOC
GETWC1:	ILDB T3,ALTBF+1
	JUMPE T3,COPGET
	POPJ P,
GETDOC:	INPUT ALTDV,0
	STATO ALTDV,760000
	JRST GETWC1
	STATZ ALTDV,740000
	ERROR DIE
	TRO FL,EOF
	MOVEI T3,0
	POPJ P,


CKTEC2:SETSTS ALTDV,0
	MOVSI T3,(<POINT 7,0>)
	HLLM T3,ALTBF+1
	MOVEI T3,5
	IMULM T3,ALTBF+2
	AOS ALTBF+2
	JRST RDTECO
INTEGER BOTLIN,PGDELS,STARTD,ENDD,TRANST,PGINSD,DESTLN
INTEGER DESTPG,FINCR,SINCR,SVLNUM,LSTPG,SVJRL,HIGH1,NLIN1
INTEGER NLIN2,DESTN,LSTLN
ARRAY COPUSR[2]

ARRAY ALTBF[3]
INTEGER SVJRL2,COPDL

SETCOP:	SETOM NLIN1	;LINES ON FIRST PAGE
	SETZM NLIN2	;LINES ON LAST PAGE
	TLO FL,ISCOP	;SO WE WILL DO SPECIAL RESET IF ERROR
	MOVE ALTP,JOBREL	;SET UP SAVE POINTER
	MOVEM ALTP,SVJRL	;SO WE CAN RESET IT
	MOVEI T1,2000(ALTP)	;ASK FOR ANOTHER 1K
	CORE T1,
	NERROR NEC	;ALL OUT, GIVE UP
	HRLI ALTP,-2000	;SET COUNT OF HOW MUCH IS THERE
	SETZM LSTPG	;HAVE SEEN NO PAGES YET
	TRZ FL2,CTOEQF	;HE HAVE NOT YET TRIED TO INSERT ON A LINE
	POPJ P,		;NOW ALL SET UP

;THIS ROUTINE MOVES A LINE TO THE BUFFER AREA
;T1 POINTS TO THE LINE

COPLIN:	MOVE T2,(T1)	;PICK UP FIRST WORD (SEQ NUM)
	MOVEM T2,LSTLN	;SAVE FOR INC CALC
TRLIN:	MOVEM T2,1(ALTP)	;PUT LINE AWAY
	AOBJP ALTP,RESTCR	;NEED MORE CORE?
TRLIN1:	SKIPN T2,1(T1)	;END OF LING?
	POPJ P,
	TRNN T2,1
	AOJA T1,TRLIN	;NO MOVE NEXT WORD
	POPJ P,		;FINISHED

RESTCR:	MOVE T2,JOBREL	;GET END
	ADDI T2,2000
	CORE T2,	;GET MORE
	NERROR NEC
	HRLI ALTP,-2000
	JRST TRLIN1	;AND CONTINUE

SUBTTL SUBSTITUTE COMMAND (REPLACES THINGS)
	;ALSO KNOWN AS SUBSTITUTE
SUBST:	TLZ FL,ASSMF	;DO NOT ASSUME ANYTHING YET
	TLZ FL2,SRFND
	SETZM LOLN	;A GOOD THING
	MOVSI T1,37777	;SET COUNT LARGE
	MOVEM T1,RPCNT
	MOVE T1,[POINT 7,R1BUF]
	MOVEI T3,R1PNT
	PUSHJ P,SSTRNG	;THIS CODE IS JUST LIKE SEARCH
	JRST	[SKIPE R2PNT	;BOTH STRINGS MUST HAVE BEEN GIVEN
		SKIPN R1PNT
		NERROR NSG	;ELSE THERE HAS BEEN AN ERROR
		CAIN C,12	;CHECK FOR JUST A CRRET
		JRST ASMD1S	;AND DO A CONTINUE
		JRST NOSTR]	;THERE IS NO STRING
	MOVE T1,[POINT 7,R2BUF]	;GET STRING TO REPLACE BY
	MOVEI T3,R2PNT
	PUSHJ P,SSTRNG
	JRST	[CAIN C,12
		JRST	[PUSH P,[.]	;SET UP RETURN
			JRST RETSTR]	;AND READ MORE (FISRT NULL)
		MOVEM T1,R2PNT	;NULL STRING MEANS DELETE
		MOVEI T2,0	;SO SET A REAL NULL STRING
		IDPB T2,T1
		SETZM RSTRCT	;1 (NULL) SUBS STRING
		JRST NOSTR]
	HRRZ T3,STRNUM
	SUBI T3,R2PNT	;GENERATE NUMBER OF REPLACEMENT STRINGS
	MOVEM T3,RSTRCT	;AND SAVE FOR LATER
NOSTR:	TLZ FL,NOPRN!DECID!EXCTS1	;CLEAR FLAGS
	PUSHJ P,SCAN	;AND START LOOKING FOR MORE JUNK
	TRNN FL,TERMF	;NOTHING
	CAIN C,","	;OR JUST A COMMA
	JRST ASMDTS	;THEN SEARCH FROM HERE TO ETERNITY
	CAIE C,"!"	;HE ONLY WANTS TO GIVE A STOPPING POINT
	CAIN C,":"
	JRST ASMDTS
	PUSHJ P,GET2	;GO GET A RANGE
REP4:	MOVE T1,HILN	;SAVE FOR POSSIBLE CONTINUE
	MOVEM T1,RPHILN
	MOVE T1,HIPG
	MOVEM T1,RPHIPG
	CAIE C,","	;IS THERE MORE?
	JRST REP1	;NO
	PUSHJ P,SCAN	;SEE WHAT IT IS
	TRNN FL,IDF	;POSSIBLY AN IDENT
	JRST REP2	;NO MAYBE A NUMBER OF TIMES
	MOVS T1,ACCUM
	CAIN T1,'N  '
	TLO FL,NOPRN	;SET FOR NO PRINTING
	CAIN T1,'D  '
	TLO FL,DECID	;HE WANTS TO BE ABLE TO DECIDE
	TLNN FL,DECID!NOPRN	;IF NEITHER
	JRST REP3	;THEN TRY FOR E SWITCH
	PUSHJ P,SCAN	;SEE IF THERE IS MORE
	CAIE C,","
	JRST REP1	;END OF LINE

	PUSHJ P,SCAN	;LOOK FOR STILL MORE
	TRNN FL,IDF
	JRST REP2
	MOVS T1,ACCUM
REP3:	CAIE T1,'E  '	;IS IT THE EXACT SEARCH SWITCH
	NERROR ILC	;NO, LOSAGE
	TLO FL,EXCTS1
	PUSHJ P,SCAN	;ONE LAST TRY
	CAIE C,","
	JRST REP1	;GO CHECK TERMINATOR
	PUSHJ P,SCAN	;ONLY ONE THING LEFT
REP2:	TRNN FL,NUMF
	NERROR ILC	;BUT IT WAS NOT
	MOVEM T2,RPCNT	;SAVE IT AWAY
	PUSHJ P,SCAN
REP1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT NOT THIS ONE
REP1A:	MOVEI T1,R1PNT	;GET THE SEARCH CODE
	PUSHJ P,CODSR
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVEM T1,RPPG	;FOR PRINT OUTS
	SETZM EXTCOR#	;AMOUNT OF EXTRA CORE WE HAVE
	SETZM NUMLIN#	;NUMBER OF EXTRA LINES INSETED
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GET THAT LIN
	TRZ FL,LINSN	;NOTHING YET
ONREP:	PUSHJ P,ONMOV	;CHECK FOR STILL IN RANGE
	JRST ENDREP	;FINALLY
	TLZE FL,ASSMF	;SHOULD WE START WITH .+1
	JRST 	[CAME T1,LOLN	;IS IT THE ONE WE ASKED FOR
		JRST .+1	;NO, USE IT
		AOS SVCNT	;JUST IN CASE A ! TYPE OF RANGE
		JRST RPNXT]
	TRO FL,LINSN	;THIS LINE IS GOOD ENOUGH
	CAMN T1,PGMK
	JRST RPPAG	;GO TAKE CARE OF PAGE MARKS
	MOVEI T2,R1PNT	;DO THE SEARCH
	PUSHJ P,COMSRC
	JRST RPNXT
	TLO FL2,SRFND
	SKIPGE T3	;PROTECT AGAINS  KILLING TAB
	IBP ALTP
	PUSH P,T3	;SAVE COUNT OF HOW FAR INTO LINE
	MOVE T3,(PNTR)	;SET UP CURRENT LINE
	MOVEM T3,CLN
	MOVE T3,CPG
	MOVEM T3,CPGL
	MOVE T2,[XWD LIBUF,LIBUF+1]	;CLEAR IT OUT
	SETZM LIBUF
	BLT T2,LIBUF+MXWPL+1	;WE WILL DO REPLACE HERE

	MOVE T2,PNTR	;GET THE POINTER TO THE LINE
	MOVE T3,(T2)	;PICK UP THE FIRST WORD
	MOVEI T4,0	;THE PLACE TO PUT IT
	JRST SALT3S	;TRANSFER
SALT2S:	SKIPE T3,(T2)
	TRNE T3,1	;IS IT THE END OF THE LINE
	JRST SALT1S
SALT3S:	MOVEM T3,LIBUF(T4)	;PUT IT AWAY
	MOVEM T3,LIBUF2(T4)	;ALSO PUT IT IN THE SECOND BUFFER
	ADDI T4,1
	AOJA T2,SALT2S

SALT1S:	MOVEM T4,OCNT
	POP P,CCNT	;GET THE NUMBER OF CHRS INTO LINE
	SKIPGE CCNT	;MUST BE 0
	SETZM CCNT
	SUBI ALTP,(PNTR)	;CONVERT POINTER TO LIBUF
	ADD ALTP,[XWD 70000,LIBUF]	;AND BACK UP ONE
	MOVEI T4,LIBUF2
	SUBI T4,(PNTR)
	ADDM T4,SRCALP		;CONVERT POINTER TO SECOND BUFFER
NXTRPL:	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	CAMLE T1,RSTRCT	;IS IT LARGER
	MOVE T1,RSTRCT	;THEN USE LAST
	MOVE T1,R2PNT(T1)
	SETZM PARNUM#	;FOR AUTO INDEXING PARTIAL DESIGNATOR
	SETZM RESCPT#	;RESCAN POINTER
	SOS SRCALP	;MUST REALLY BACK IT UP SO LDB WORKS
	REPEAT 4,<IBP SRCALP>
REPSTR:	ILDB C,T1	;GET THE NEXT CHR
	JUMPE C,ENDRP	;THE END OF THE REPLACE STRING
	CAIN C,""	;DOES HE WANT ONE OF THE PARTIAL THINGS
	JRST PARSTR	;YES, GO HANDLE THAT
	CAIN C,""	;CHECK FOR QUOTING NEXT CHR
	JRST INSQT
	CAIN C,""	;AN ALPHA
	JRST INCPAR
	CAIN C,""	;INSERT CRLF
	JRST INSCRS
	CAIN C,""	;SET RESCAN POINT
	JRST SETRSC
PUTSTR:	IDPB C,ALTP	;PUT IN THE REPLACEMENT
	AOS C,CCNT	;ADVANCE COUNT
	CAIL C,MXWPL*5	;CHECK AGAINST MAX
	NERROR LTL	;AND LOSE
	JRST REPSTR

SETRSC:	SKIPE RESCPT
	NERROR IRS	;NOT MORE THAN 1 AT A TIME
	MOVEM ALTP,RESCPT
	MOVE C,CCNT
	MOVEM C,RESCNT#	;AND SAVE COUNT
	JRST REPSTR

DORSCN:	MOVE ALTP,RESCNT
	MOVEM ALTP,CCNT
	MOVE ALTP,RESCPT
	POPJ P,

ENDRP:	PUSH P,ALTP
	PUSH P,CCNT
	LDB C,SRCALP	;HAVE WE BY ANY CHANCE
	CAIN C,15	;BYPASSED THE RETURN
	SKIPA		;YES, PUT IT IN NOW
ELTRN:	ILDB C,SRCALP	;GET NEXT CHR
	IDPB C,ALTP	;PUT IT IN
	AOS T3,CCNT
	CAIL T3,MXWPL*5
	NERROR LTL
	CAIE C,12
	JRST ELTRN
DNTRN:	PUSHJ P,ZRIT	;ZERO OUT REST OF WORD
	SUBI ALTP,LIBUF-1
	HRRZS ALTP
	MOVEM ALTP,NCNT	;SET SIZE OF NEW LINE
	MOVE C,[XWD LIBUF,LIBUF2]
	BLT C,LIBUF2+MXWPL-1	;MOVE TO SECOND BUFFER
	POP P,CCNT
	POP P,ALTP
	SKIPE RESCPT
	PUSHJ P,DORSCN	;SET UP FOR THE RESCAN
	SOS T3,CCNT
	ADDI ALTP,LIBUF2
	SUBI ALTP,LIBUF	;CONVER TO POINT TO BUF2
	MOVEM ALTP,SRCALP
	ILDB T1,SRCALP
	CAIE T1,12
	PUSHJ P,COMSRT
	JRST FINLIN	;DONE
	CAIL T3,MXWPL*5
	NERROR LTL
	MOVEM T3,CCNT
	SUBI ALTP,LIBUF2
	ADD ALTP,[XWD 70000,LIBUF]
	JRST NXTRPL
FINLIN:	SKIPE NUMLIN	;IF ANY EXTRA INSERTED
	PUSHJ P,TRANHS	;FINISH UP TRANSFER TO HIGH CORE
	TLNE FL,NOPRN	;DID HE WANT PRINTING SUPRESSED
	JRST NOPLIN
	MOVE T2,CPG	;GET THIS PAGE
	CAMN T2,RPPG	;IS IT ONE WE STARTED ON
	JRST NOPPRN	;YES, DO NOT PRINT 'PAGE #'
	MOVEM T2,RPPG	;SAVE FOR NEXT TIME
	PUSHJ P,PGPRN
NOPPRN:	SKIPE NUMLIN	;EXTRA INSERTED?
	JRST MANYPR	;SPECIAL PRINT NEEDED
	MOVEI T1,LIBUF	;PRINT THE LINE
	PUSHJ P,OUTLIN
DCDCK:	TLNN FL,DECID	;DOES HE WANT THE OPTION OF SAYING NO
	JRST NOPLIN	;NO, INSERT IT
	INCHRW T1
	ANDI T1,177
	OUTSTR [ASCIZ /
/]
	CAIE T1,"e"	;EITHER CASE
	CAIN T1,"E"	;DOES HE WANT OUT
	JRST ENDREP	;YES, QUIT
	CAIE T1,"a"	;IF AN A
	CAIN T1,"A"
	JRST ALTR	;GO DO AN ALTER ON IT
	CAIE T1,"Y"
	CAIN T1,"y"
	JRST NOPLIN	;HE SAID YES
	CAIE T1,"g"
	CAIN T1,"G"
	TLZA FL,DECID	;TURN OFF ,D FEATURE
	JRST RPNXT1	;DID NOT SAY ANYTHING RCOGNIZABLE
NOPLIN:	SKIPE NUMLIN	;MANY IS SPECIAL AGAIN
	JRST INSMNY
NOPLN2:	PUSHJ P,INSED	;ANYTHING ELSE IS OK
	PUSHJ P,FINDN	;GET NEXT
	PUSHJ P,FILLB	;IN CASE IT GOT LONGER
	SOSG RPCNT	;SEE IF OUT OF COUNT
	JRST COMND
	MOVE T1,(PNTR)	;GET POINTER BACK
	JRST ONREP
ZRIT:	MOVEI T3,0	;ZERO OUT REST OF THIS LINE
DOZER:	TLNN ALTP,760000	;POINTER AT END OF LINE?
	POPJ P,
	IDPB T3,ALTP
	JRST DOZER
	POPJ P,

ASMD1S:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASMDTS:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN
	MOVEM T1,LOLN	;SET FOR HERE TO ETERNITY
	MOVEM T1,HILN
	MOVE T1,CPGL
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPCS
	CAIE C,":"	;IF A : OR A !
	CAIN C,"!"
	JRST HLFSPS	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST REP4	;ONWARD
HLFSPS:	MOVEM T1,HIPG	;SET TO AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST REP4	;AND GO

NOSPCS:	MOVE T1,RPHIPG
	MOVEM T1,HIPG
	MOVE T1,RPHILN
	MOVEM T1,HILN
	JRST REP1A

ALTR:	SKIPE NUMLIN
	JRST ALTMNY
	PUSHJ P,STAL1	;SET UP ALTER MODE (ALREADY HAVE LINE IN LIBUF)
	PUSHJ P,ALTN1	;DO THE ALTER
	JRST ENDREP	;IF Q THEN SAME AS E EARLIER
	JRST NOPLIN	;GO PUT THE LINE IN

INSCRS:	SKIPE RESCPT	;ANY RESCAN POINT YET?
	NERROR IRS	;CAN NOT RESCAN A PREVIOUS LINE
	MOVEI C,15	;PUT IN THE CRLF
	IDPB C,ALTP
	AOS CS,CCNT
	CAIL CS,MXWPL*5-1
	NERROR LTL
	MOVEI C,12
	IDPB C,ALTP
	PUSHJ P,ZRIT	;FINISH OUT THE WORD
	SUBI ALTP,LIBUF-1	;GET THE SIZE
	HRRZS ALTP
	MOVEM ALTP,NCNT
	PUSH P,TRNHRT	;SET UP A RETURN ADRESS
TRANHI:	EXCH ALTP,EXTCOR	;SEE HOW MUCH CORE IS FREE
	SUBB ALTP,EXTCOR	;MINUS THE AMOUNT WE NEED
	JUMPGE ALTP,HAVCOR	;ENOUGH
	PUSHJ P,GETCOR	;GET MORE
HAVCOR:	MOVE ALTP,TOPLNS	;PLACE TO PUT IT
	HRLI ALTP,LIBUF
	MOVE T3,NCNT
	ADDB T3,TOPLNS
	BLT ALTP,-1(T3)
	AOS NUMLIN	;WE HAVE PUT A LINE INTO HIGH CORE
	MOVE ALTP,[POINT 7,LIBUF+1,6]	;RESET POINTER
	SETZM CCNT	;RESET POSITION COUNT
TRNHRT:	POPJ P,REPSTR	;ADRS IS USED TO SET RETURN

GETCOR:	TLOE FL,ISCOP	;HAVE WE BEEN HERE BEFORE?
	JRST ADCOR	;YES, JUST GET A LITTLE MORE
	TLZ FL,COPFIL!TRANFL	;EXTRA FLAGS SHOULD BE OFF
	MOVE T3,JOBREL
	MOVEM T3,SVJRL2		;SAVE IT
	ADDI T3,1
	MOVEM T3,TOPLNS#	;SAVE HERE AS PLACE TO PUT LINES
	MOVEM T3,SVHPTR#	;SAVE FOR START OF HIGH CORE
ADCOR:	MOVEI T3,2000
	ADDM T3,EXTCOR		;GETTING THIS MUCH
	ADD T3,JOBREL	;HERE IS WHERE WE WANT THE END OF CORE
	CORE T3,
	NERROR NEC	;LOSE BIG
	POPJ P,	;GOT IT

TRANHS:	AOS ALTP,NCNT	;GIVE ONE EXTRA WORD
	SETZM LIBUF-1(ALTP)	;AND MAKE SURE IT IS 0
	PUSHJ P,TRANHI	;MOVE INTO HIGH CORE
	MOVE T3,(PNTR)	;GET THE LINE NUMBER
	PUSHJ P,NUMCON	;CONVERT TO NUMBER
	MOVEM T1,LOWLN#
	PUSHJ P,FINDN
	SKIPE T1	;IF EOF
	CAMN T1,PGMK	;OR PAGE MARK
	JRST	[MOVEI T1,^D100000	;A BIG NUMBER
		JRST SETHI]
	MOVE T3,T1
	PUSHJ P,NUMCON	;THE AMOUNT OF SPACE
SETHI:	SUB T1,LOWLN
	IDIV T1,NUMLIN	;THE NUMBER OF LINES WHICH MUST FIT
	JUMPE T1,[RERROR ORDER	;WILL NOT FIT
		JRST USEINC]
	PUSHJ P,ASCON	;CONVERT TO AN ASCII NUMBER
	CAMLE T3,INCR	;IF SMALLER THAN INCR USE IT
USEINC:	MOVE T3,INCR	;ELSE INCR
	MOVEM T3,SVINC
	PUSHJ P,FINDB	;BACK WHERE WE BELONG
	MOVE T1,(PNTR)
	MOVEM PNTR,SVPTR#	;SAVE POINTER
	SKIPA PNTR,SVHPTR#	;POINTER TO START OF HIGH CORE
NXTLN:	POP P,T1	;GET BACK SAVED T1
	MOVEM T1,(PNTR)
	MOVE T2,SVINC	;CALC NEXT
	PUSHJ P,ASCIAD
	PUSH P,T1	;SAVE IT
	PUSHJ P,FINDZ	;FIND NEXT LINE OR ZERO
	JUMPN T1,NXTLN	;ANOTHER TO GO
	POP P,T1	;JUST GET IT BACK (PNTR CHANGED FOR FINDZ)
	MOVE PNTR,SVPTR	;GET BACK ORIGINAL POINTER
	POPJ P,	;AND GET OUT

MANYPR:	MOVE PNTR,SVHPTR	;GET START OF HIGH CORE
MANY1:	MOVEI T1,(PNTR)
	PUSHJ P,OUTLIN	;PRINT IT
	PUSHJ P,FINDZ	;NEXT OR 0 (AT END)
	JUMPN T1,MANY1
	MOVE PNTR,SVPTR	;RESTORE
	JRST DCDCK	;CHECK ON DECISION

ALTMNY:	MOVE PNTR,SVHPTR
	MOVE T1,OCNT	;COUNT FOR ORIGINAL LIN
	MOVEM T1,SVOCNT#	;SAVE IT
NXTALT:	PUSHJ P,SETALT	;THIS WILL GET IT FROM HIGH CORE INTO LIBUF
	PUSH P,PNTR	;SAVE THE ONE INTO HIGH CORE
	MOVE PNTR,SVPTR	;AND POINT INTO LOW IN CASE OF ERROR OR ^U
	TLZ FL2,CTLUFL	;NO ^U YET
	PUSHJ P,ALTN1	;GO DO ALTER
	JRST ENDREP	;A Q GETS US OUT
	TLNE FL2,CTLUFL
	JRST NOPLN1	;A ^U GOES BACK TO ORIGINAL LINE
	MOVE ALTP,JOBREL
	SUB ALTP,SVJRL2
	SUB ALTP,EXTCOR	;FIND THE "WORD COUNT" FOR HIGH CORE
	MOVE T1,OCNT	;THIS WAS SET BY ALTER
	SUB T1,NCNT	;AND SO WAS THIS
	ADDB T1,EXTCOR	;IS THERE ROOM??
	JUMPGE T1,.+2
	PUSHJ P,GETCOR	;NO, GET MORE
	MOVE T4,SVHPTR
	EXCH T4,BUFP	;SET UP THINGS FOR INSED
	EXCH ALTP,WC
	POP P,PNTR	;POINT TO HIGH CORE
	PUSHJ P,INSED
	MOVEM ALTP,WC	;RESET
	MOVEM T4,BUFP
	PUSHJ P,FINDZ	;NEXT OR 0
	JUMPN T1,NXTALT
	MOVE PNTR,SVPTR	;RESTORE POINTER TO LOW CORE
	MOVE T1,SVOCNT	;RESTORE
	MOVEM T1,OCNT
	JRST NOPLIN	;GO

NOPLN1:	POP P,T1	;ADJUST STACK THE ^U RESET OCNT
	PUSHJ P,ENDCRI	;GET RID OF EXTRA CORE (SORT OF)
	JRST NOPLIN	;THIS WILL REINSERT ORIGINAL AS MODIFIED

ENDCRI:	MOVE T1,JOBREL
	SUB T1,SVJRL2
	MOVEM T1,EXTCOR	;RESET AMOUNT THERE
	SETZM NUMLIN
	MOVE T1,SVHPTR
	MOVEM T1,TOPLNS	;IN CASE THERE IS ANOTHER INSERT CRLF
	POPJ P,

INSMNY:	MOVE ALTP,SVHPTR
INMOR:	SETZM NCNT
	MOVEI T3,LIBUF
	MOVE T1,(ALTP)	;GET FIRST WORD OF LINE
	JRST INLN2	;AN PUT IT DOWN
NXINMY:	SKIPN T1,(ALTP)
	JRST LSTTRN	;LAST ONE
	TRNE T1,1
	JRST INLN	;FOUND NEXT LINE
INLN2:	MOVEM T1,(T3)
	AOS NCNT
	ADDI T3,1
	AOJA ALTP,NXINMY
INLN:	PUSHJ P,INSED
	PUSHJ P,FINDN
	PUSHJ P,FILLB
	SETZM OCNT	;ALL AFTER FIRST ARE JUST INSERTS
	JRST INMOR
LSTTRN:	PUSHJ P,ENDCRI
	JRST NOPLN2	;GO INSERT IT, THEN DONE

INSQT:	ILDB C,T1	;GET NEXT CHR
	JUMPN C,PUTSTR	;MUST NOT BE 0
	NERROR IRS	;THIS STRING IS ILLEGAL

PARSTR:	MOVEI CS,0	;FIND OUT THE NUMBER
PARST1:	ILDB C,T1	;GET A CHR
	CAIN C,""	;CHECK FOR END
	JRST ENDNUM
	CAIL C,"0"	;MUST BE A DIGIT
	CAILE C,"9"
	NERROR IRS
	IMULI CS,^D10	;CONVERT
	ADDI CS,-"0"(C)
	JRST PARST1
INCPAR:	AOS CS,PARNUM	;GET THE NEXT ONE IN LINE
ENDNUM:	CAILE CS,0
	CAMLE CS,ARBCNT	;IS IT IN RANGE
	NERROR IRS	;NO SUCH PARTIAL STRING
	MOVE T4,[POINT 7,ARBBUF]	;START LOOKING FOR IT
	SOJLE CS,FNDRST	;STARTS WITH STRING 1
NXTST:	ILDB C,T4
	JUMPN C,NXTST	;0 IS END OF A PARTIAL STRING
	SOJG CS,NXTST	;LOOK FOR CORRECT STRING
FNDRST:	ILDB C,T4	;NOW INSERT THAT STRING
	JUMPE C,REPSTR	;GO FINISH THE REPLACEMENT STRING
	IDPB C,ALTP
	AOS C,CCNT
	CAIL C,MXWPL*5
	NERROR LTL
	JRST FNDRST

RPNXT1:	SOSG RPCNT
	JRST COMND
RPNXT:	PUSHJ P,FINDN
	JRST ONREP	;CONTINUE LOOKING AT LINES

ENDREP:	TRZN FL,LINSN!RENSN	;WERE THERE ANY?
	NERROR NLN
	TLNN FL2,SRFND
	NERROR NMF
	JRST COMND

RPPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST RPNXT


INTEGER RPPG,RPCNT,RPHILN,RPHIPG,CCNT,RSTRCT
ARRAY R1BUF,R2BUF[SRBLG/5+2]

ARRAY R1PNT,R2PNT[SRNUM]
SUBTTL @ COMMAND

ATSIN:	PUSHJ P,ATCOM
	JRST COMND
	JRST COMND	;GET RPG FILE STARTED

ATCOM:	PUSHJ P,SCAN
	MOVEI T1,TMPUSR
	PUSHJ P,READNM	;GET A NAME
	PERROR ILC	;WE LOSE ERROR AND RETURN TO CALLER
	TLNE FL2,RSW!BSW!SSW	;NO SWITCHES
	PERROR ILC
	RELEASE CTL,0	;RELEASE OLD ONE
	MOVEI T1,LPTBUF	;SET UP BUFFER
	MOVEM T1,JOBFF
	INIT CTL,1
	SIXBIT /DSK/
	RPGBUF
	PERROR DNA	;LOSE
	INBUF CTL,2
	TRO FL2,RPGFLG	;NOW WILL RELEASE IF NOT FOUND
	LOOKUP CTL,NAMI
	PERROR FNF	;NOT THERE
	TRO FL2,SUPOFL!CBFUS	;BUFFER IN USE AND NO OUTPUT
	SETZM RPGPG
	SETZM RPGLN
	AOS (P)	;SKIP RETURN
	POPJ P,


SUBTTL B (BUFFER COMMAND)

ARRAY BUFSTR [^D10*<BUFSIZ/4+1>]

BUFCOD:	PUSHJ P,SCAN	;GET THE BUFFER NUMBER
	TRNE FL,NUMF
	JRST BUFFIL	;B <NUMBER> FILL BUFFER
	TRNN FL,IDF
	NERROR ILC
	MOVS T1,ACCUM
	CAIN T1,'P  '
	JRST BUFPRT	;BP PRINT
	CAIN T1,'I  '
	JRST BUFINS	;INSERT
	CAIN T1,'C  '
	JRST BUFCOP	;COPY
	CAIN T1,'T  '	;TRAASFER
	JRST BUFTRN
	NERROR ILC	;ELSE ILLEGAL

BUFTRN:	TLOA FL,TRANFL	;IT IS A TRANSFER (DELETE)
BUFCOP:	TLZ FL,TRANFL	;NOT A TRANSFER (NO DELETE)
	PUSHJ P,SCAN
	PUSHJ P,GNIPTR	;MAKE A POINTER FROM BUFFER NUMBER
	PUSH P,ALTP
	PUSHJ P,SCAN
	CAIE C,","	;SOURCE RANGE SHOULD COME NOW
	NERROR ILC
	SETZM LOLN
	PUSHJ P,GET2S
	TRNN FL,TERMF
	NERROR ILC
	TRZ FL,LINSN
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GET TO FIRST LINE

BCPLP:	PUSHJ P,ONMOV	;IS THIS ONE IN RANGE?
	JRST BCPDON	;NO, FINISHED
	CAMN T1,PGMK
	JRST BCPPAG	;GO HANDLE IT
	MOVEM T1,CLN
	MOVE T1,CPG
	MOVEM T1,CPGL	;SET .
	MOVEI T1,1(PNTR)
	HRLI T1,(POINT 7,0,6)	;SET UP BYTE POINTER
	POP P,T3	;POINTER TO STRING SPACE
	TRNE FL2,RUBF
	JRST BCPSTR	;COPY STRING
	TROE FL,LINSN	;IS THIS THE FIRST TIME?
	JRST BCPLN2	;NO
	MOVEI T2,BUFSIZ	;FIRST TIME
	TRZ FL2,CTOEQF	;USE THIS FLAG FOR NO CRLF TO INSERT
BCPLN1:	ILDB C,T1
	CAIN C,15
	JRST BCPLNE	;END OF LINE
	CAIN C,""	;CHECK FOR QUOTE (TO PUT IN LF)
	JRST BCPLNQ
BCPLN3:	IDPB C,T3
	SOJGE T2,BCPLN1	;CONTINUE
BCPERR:	MOVEI C,0
	DPB C,T3	;STORE AN END
	NERROR STL	;AND GIVE ERROR

BCPLNE:	PUSH P,T2	;SAVE COUNT
	PUSH P,T3	;AND BYTE POINTER
	MOVEI C,0
	IDPB C,T3	;TERMINATE IN CASE LAST
BCPELN:	TLNN FL,TRANFL	;IS THIS A TRANSFER
	JRST BCPNXT	;NO, JUST GET NEXT LINE
	PUSHJ P,DODEL	;DELETE IT
	PUSHJ P,FINDN1	;AND GET NEXT
	JRST BCPLP	;AND CONTINUE

BCPPAG:	TLZ FL,TRANFL	;STOP DELETE ON A PAGE MARK
BCPNXT:	PUSHJ P,FINDN
	JRST BCPLP

BCPLNQ:	ILDB C,T1	;GET NEXT CHR
	CAIN C,15	;IS IT A CR
	JRST BCPLNF	;YES, A LINE FEED SHOULD BE THERE
	PUSH P,C	;NO SAVE IT
	MOVEI C,""
	IDPB C,T3
	SOJL T2,BCPERR	;TOO MANY
	POP P,C
	JRST BCPLN3	;AND GO STORE IT

BCPLNF:	TRO FL2,CTOEQF	;SET FLAG THAT NO CRLF IS NEEDED
	MOVEI C,12
	IDPB C,T3
	SOJL T2,BCPERR
	JRST BCPLNE	;AND FINISH LINE

BCPLN2:	POP P,T2	;RESTORE COUNT
	TRZE FL2,CTOEQF	;DO WE NEED TO GEN A CRLF
	JRST BCPLN1
	MOVEI C,15
	IDPB C,T3	;STORE THE CR
	SOJL T2,BCPERR
	MOVEI C,12
	IDPB C,T3
	SOJL T2,BCPERR
	JRST BCPLN1

BCPSTR:	TROE FL,LINSN	;IS THIS THE FIRST
	JRST BCPST2	;NO
	HLRZ T4,T3	;GET BUFFER AREA
	CAIN T4,R2BUF
	TROA FL2,CTOEQF	;THIS IS SPECAIL
	TRZA FL2,CTOEQF
	SETOM RSTRCT	;NEED TO COUNT
	HRLI T4,(POINT 7,0)
	HRLI T3,-SRNUM	;NUMBER TO LOOK AT
	MOVE T2,T3
	SETZM (T2)
	AOBJN T2,.-1	;ZERO ALL OF THEM
	MOVEI T2,SRBLG	;AND GET MAX LENGTH
BCPST0:	MOVEM T4,(T3)	;STORE POINTER

BCPST1:	ILDB C,T1
	CAIN C,15
	JRST BCPST1	;IGNORE
	CAIN C,12
	JRST BCPSTE	;END OF LINE
	IDPB C,T4	;STORE IT
	SOJG T2,BCPST1	;CONTINUE IF ROOM
BCPST3:	RERROR STL	;TOO LONG
BCPST4:	HLRZ T1,T3
	MOVNS T1
	ADDI T1,-SRNUM(T3)	;GET POINTER TO ORIGINAL
	SETZM (T1)	;AND ZERO
	JRST COMND	;QUIT

BCPSTE:	MOVEI C,0
	IDPB C,T4
	SOJLE T2,BCPST3	;OUT OF ROOM
	PUSH P,T2	;SAVE COUNT
	PUSH P,T4	;AND BYTE POINTER
	PUSH P,T3
	TRNE FL2,CTOEQF
	AOS RSTRCT	;COUNT ONE MORE
	JRST BCPELN	;AND WORRY ABOUT NEXT LINE

BCPST2:	POP P,T4	;RESTORE POINTER
	POP P,T2	;AND COUNT
	AOBJN T3,BCPST0
	RERROR TMS	;TOO MANY STRINGS
	JRST BCPST4

BCPDON:	TRNN FL,LINSN
	NERROR NLN
	JRST COMND

BUFINS:	PUSHJ P,SCAN	;SHOULD BE A NUMBER HERE
	PUSHJ P,GNIPTR	;POINTER INCLUDING STRINGS
	PUSH P,ALTP	;SAVE POINTER
	PUSHJ P,SCAN
	CAIE C,","
	NERROR ILC
	PUSHJ P,GET10S	;READ DESTINATION
	MOVE T1,HIPG
	MOVEM T1,DESTPG
	MOVE T1,HILN
	MOVEM T1,DESTLN	;AND SET UP FOR THE INSERT
	CAIE C,","
	JRST BUFIN1	;NO INCREMENT
	PUSHJ P,SCAN
	TRNE FL,NUMF
	CAMN T1,[<ASCII /00000/>+1]	;MUST BE NUMBER AND NOT 0 INCR
	NERROR ILC
	MOVEM T1,FINCR
	PUSHJ P,SCAN
	JRST BUFIN2	;SHOULD HAVE THE TERMINATOR BY NOW
BUFIN1:	MOVE T1,INCR
	MOVEM T1,FINCR
BUFIN2:	TRNN FL,TERMF
	NERROR ILC
	PUSHJ P,SETCOP	;SET UP TO STORE LINES
	POP P,T3	;RESTORE POINTER
	TRZ FL,LINSN
	TLZ FL,COPFIL!TRANFL	;RESET FLAGS
	JUMPG T3,BUFIST	;FROM A STRING
	PUSHJ P,BUFLN1	;COPY ONE LINE TO BUFFER AREA
	 JRST ENDCOP	;THAT WAS THE END
	JRST .-2	;MORE TO GO, CONTINUE

BUFIST:	MOVE T4,T3	;SET UP AOBJN POINTER TO BYTE POINTERS
	HRLI T4,-SRNUM
BUFIS2:	SKIPN T3,(T4)
	JRST ENDCOP	;DONE
	PUSHJ P,BUFLN1
	 JFCL		;NORMALLY ENDS WITH A NULL
	AOBJN T4,BUFIS2
	JRST ENDCOP

BUFLN1:	MOVEI T1,1
	MOVEM T1,LIBUF	;FAKE LINE NUMBER
	SETZM LIBUF+1
	MOVE T1,[LIBUF+1,,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1
	MOVE T1,[POINT 7,LIBUF+1]
	MOVEI C,11
	IDPB C,T1
	MOVEI T2,MXWPL*5-2	;MAX SIZE OF A LINE
BUFLN2:	ILDB C,T3
	JUMPE C,BUFLNE	;END
	CAIN C,200
	MOVEI C,33	;CONVERT ALTMODE
	CAIN C,15
	JRST BUFLCR	;NORMAL LINE END
	CAIN C,12
	JRST BUFLLF	;ENDS WITH LINE FEED
	SOJGE T2,.+2
	NERROR LTL
	IDPB C,T1	;STORE CHR
	JRST BUFLN2	;AND CONTINUE

BUFLNE:	MOVEI C,15	;PUT THE CRLF IN
	JRST BUFCR2

BUFLCR:	IBP T3		;ADVANCE 1 FOR THE LINE FEED
BUFCR1:	AOS (P)	;SET FOR SKIP RETURN
BUFCR2:	IDPB C,T1	;STORE THE CHR
	MOVEI C,12
	IDPB C,T1	;AND A LINE FEED
	TRO FL,LINSN
	MOVEI T1,LIBUF
	AOS NLIN2
	JRST COPLIN	;PUT IN BUFFER AREA

BUFLLF:	MOVEI C,""	;PUT IN A QUOTE
	IDPB C,T1
	MOVEI C,15	;THEN CRLF
	JRST BUFCR1

GNIPTR:	TRNE FL,NUMF	;MUST BE A NUMBER
	CAILE T2,^D12	;AND 0-12
	NERROR ILC
	CAIGE T2,^D10
	TRZA FL2,RUBF	;NOT STRING
	TROA FL2,RUBF
	JRST GENPTR	;HANDLE 0-9 NORMALLY
	MOVE ALTP,BUFINT-^D10(T2)
	POPJ P,

BUFINT:	SRBUF,,SRPNT
	R2BUF,,R2PNT
	R1BUF,,R1PNT

BUFPRT:	PUSHJ P,GENPTS
	PUSHJ P,SCAN
	TRNN FL,TERMF
	NERROR ILC
PRTBUF:	ILDB C,ALTP
	JUMPE C,PRTBF1
	CAIN C,200
	MOVEI C,"$"
	PUSHJ P,OCHR
	JRST PRTBUF

PRTBF1:	OUTPUT TTY,0
	OUTSTR [ASCIZ /
/]
	JRST  COMND

BUFFIL:	PUSHJ P,GENPTR
	PUSHJ P,SCAN
	TRNN FL,TERMF
	NERROR ILC
	MOVEI SINDEX,BUFSIZ
BUFFL2:	PUSHJ P,GNCH
	JUMPE CS,.-1
	PUSH P,C	;SAVE CHR
BUFFL3:	PUSHJ P,GNCH
	CAMN C,(P)
	JRST BUFSTP
	IDPB C,ALTP
	SOJG SINDEX,BUFFL3
	PUSHJ P,GNCH
	CAMN C,(P)
	JRST .-2
BUFSTP:	MOVEI C,0
	IDPB C,ALTP
	POP P,C
	JRST COMND

GENPTS:	PUSHJ P,SCAN
	TRNN FL,NUMF
	NERROR ILC
GENPTR:	SKIPL T2
	CAILE T2,^D9
	NERROR ILC	;NUMBER OUT OF RANGE
SETBP2:	IMULI T2,<BUFSIZ/4+1>
	MOVEI ALTP,BUFSTR(T2)
	HRLI ALTP,(POINT 8,0)
	POPJ P,

BUFSET:	SETZM BUFPTR	;IN CASE OF ERROR
	CAIG C,"9"
	CAIGE C,"0"
	NERROR IBN	;ILLEGAL BUFFER
	PUSH P,T2
	PUSH P,ALTP
	MOVEI T2,-"0"(C)
	PUSHJ P,SETBP2	;GET POINTER TO IT
	MOVEM ALTP,BUFPTR
	POP P,ALTP
	POP P,T2
	POPJ P,		;ANF]D FINISHED

SUBTTL U COMMAND
SETGO:	PUSHJ P,SCAN
	MOVEI T1,TMPUSR
	PUSHJ P,READNM
	NERROR ILC
	TRNE FL,TERMF	;MUST BE END OF STRING
	TLNE FL2,BSW!RSW!SSW	;NO / SWITCHES PERMITTED
	NERROR ILC
	MOVE T1,NAMI
	MOVEM T1,RPGR+1
	HLLZ T1,NAMI+1
	MOVEM T1,RPGR+2
	MOVSI T1,'DSK'
	MOVEM T1,RPGR
	SETZM RPGR+4
	SKIPN NAMI+3
	JRST COMND
	DMOVE T1,@NAMI+3
	DMOVEM T1,RPGUNM
	MOVEI T1,RPGUNM
	MOVEM T1,RPGR+4
	JRST COMND
SUBTTL XPAND COMMAND


XPAND:	SETZM LOLN	;AS USUAL, A GOOD THING
	PUSHJ P,GET2S	;THE RANGE
	TRNN FL,TERMF
	NERROR ILC
	TRZ FL,LINSN
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
XPND1:	PUSHJ P,ONMOV	;STILL IN RANGE?
	JRST EXPEND
	TRO FL,LINSN
	CAMN T1,PGMK	;IGNORE THESE
	JRST PAGE
	MOVEM T1,CLN
	MOVE T1,CPG
	MOVEM T1,CPGL	;SET LINE AND PAGE
	PUSHJ P,SETALT	;SET THINGS UP
	MOVSI T2,1	;A LARGE COUNT
	PUSHJ P,ALTSP	;SPACES
	MOVEI T2,0
	PUSHJ P,ALTIN	;DO THE INSERT
	PUSHJ P,ALTN1	;FINISH INTA LINE EDIT
	JRST LEVINS	;IN CASE OF ALTMODE
	PUSHJ P,INSED	;PUT IN CHANGED LINE
EXPND2:	PUSHJ P,FINDN
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	MOVE T1,(PNTR)	;GET BACK NEXT LINE
	JRST XPND1
PAGE:	AOS T2,CPG
	MOVEM T2,CPGL
	PUSHJ P,PGPRN	;SEE ALTER COMMAND
	MOVE T1,[<ASCII /00000/>+1]
	MOVEM T1,CLN
	JRST EXPND2
EXPEND:	TRNN FL,LINSN!RENSN
	NERROR NLN
	JRST COMND
SUBTTL JOIN COMMAND


JOIN:	SETZM HILN	;GET ONLY ONE LINE
	PUSHJ P,GET1S
	TRNN FL,TERMF
	NERROR ILC
	MOVE T1,HIPG
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;FIND THE CORRECT LINE
	PUSHJ P,FIND
	MOVE T2,CPG
	MOVE T1,(PNTR)
	CAMN T2,HIPG
	CAME T1,HILN
	NERROR NLN
	MOVEM T2,CPGL
	MOVEM T1,CLN
	SETZM LIBUF	;TO ELIMINATE GARBAGE AT END OF LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVE T2,PNTR	;GET THE POINTER TO THE LINE
	MOVE T3,(T2)	;PICK UP THE FIRST WORD
	MOVEI T4,LIBUF	;THE PLACE TO PUT IT
	JRST SALT3J	;TRANSFER
SALT2J:	SKIPE T3,(T2)
	TRNE T3,1	;IS IT THE END OF THE LINE
	JRST SALT1J
SALT3J:	MOVEM T3,(T4)	;PUT IT AWAY
	ADDI T4,1
	AOJA T2,SALT2J

SALT1J:	HRRZ T1,T4
	SUBI T1,LIBUF
	MOVEM T1,OCNT
	IMULI T1,5	;GET COUNT OF CHRS
	SUBI T1,6	;WE WILL HAVE TO FIND THE TRUE END
	SUBI T4,2
	HRLI T4,(<POINT 7,0,27>)	;SET UP POINTER
FEND1:	ILDB T2,T4
	CAIE T2,15
	AOJA T1,FEND1
	PUSH P,T1
	PUSHJ P,FINDN	;GET THE LINE TO JOIN IT TO
	CAME T1,PGMK
	SKIPN T1
	NERROR NNN	;NO LINE THERE TO CONNECT TO
	POP P,T2	;COUNT
	MOVEI T1,1(PNTR)
	HRLI T1,(<POINT 7,0,6>)	;SET TO POINT THERE
	ADD T4,[XWD 70000,0]
TRN1J:	ILDB T3,T1
	IDPB T3,T4
	ADDI T2,1
	CAIL T2,MXWPL*5+6
	NERROR LTL
	CAIE T3,12
	JRST TRN1J

	SUBI T1,-1(PNTR)
	PUSH P,OCNT
	HRRZM T1,OCNT	;SIZE OF OLD SECOND LINE
	SETZM NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDB	;BACK UP
	POP P,OCNT	;GET ITS SIZE
	SUBI T4,LIBUF-1
	HRRZM T4,NCNT
	PUSHJ P,INSED
	JRST COMND
LVAR
END STPT
rf