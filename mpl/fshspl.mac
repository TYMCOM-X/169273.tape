TITLE FSHSPL - SPOOL CREF LISTINGS ONTO MICROFICHE

.version==6	;/aaa 4/2/79 add option for translate/notranslate
;.version==5		;SDD 1/7/78 more elaborate non-standard chars
			;	(pages 1,3,51,52 (trnset,trnstb))

P=17	;PDL POINTER
LPOS=16		;LINE POSITION ON OUTPUT FOR TAB SIMULATION
C=15		;CHARACTER
PAGS=14	;NUMBER OF PAGES LEFT
VLN==13		;VERTICAL LINE NUUMBER FOR TITLES
TCC==12		;CHARACTER NUMBER FOR TITLES
HDTS==11	;HORIZONTAL DOT NUMBER FOR TITLES
CP=10	;CO-ROUTINE PDL
ACCUM=7	;'ACCUM' AC FOR STRING MANIPULATION
VTAB=6	;EXECUTION POINTER



FL=0	;FLAG REGISTER
T1=1		;TEMPS
T2=2
T3=3
T4=4

LNSPAG==^D63
BIGLIN==^D144
SMLLIN==^D132
UFDBLN==1000/5*2	;UFD BUFFER SIZE - MAKE BIG ENOUGH SO THAT
			; MONITOR ONLY READS IN EACH PAGE OF UFD ONCE

IFN UFDBLN/2*2-UFDBLN,<PRINTX UFDBLN MUST BE AN EVEN NUMBER.>

UFD==1		;CHANNEL FOR UFD
TAP==2		;FOR TAPE
FIL==3		;FOR FILE
CMD==4	;COMMAND FILE
CMDS==5		;SPOOL COMMAND FILE
OFLD==6		;FOR OUTVAR CONSTRUCT

ARRAY CPDL,PDL[40],CIBUF,CHR,FILBF,TAPBF[3],GLBLOC[^D18]
ARRAY LINTAB[LNSPAG],USRNM,USRNMC[2]
ARRAY FILNAM[2],CMDBUF[200],TTLBUF[^D28],TTLCPT[7]
	ARRAY TRNSTB[200]		;working translation table
ARRAY DMOBUF[3],UFDDAT[UFDBLN]
FILEXT==FILNAM+1

EXTERNAL JOBFF,JOBREL
GETPPN==2	;GETTAB FOR PPN

TAPSIZ==<<^D<<BIGLIN+3>*LNSPAG>+3+3+3>/4>*4
FR.WLD==1	;WILD FIELD IN FILE NAME SOMEWHERE
FR.ATF==2	;FROM INDIRECT FILE

JOBVER==137
INTERNAL JOBVER

	LOC JOBVER
	.version
	RELOC

	DEFINE FOR (ARG,STRT,END,TXT)
<	DEFINE %FMAC (ARG)
	<TXT>
	%%FX==STRT
	REPEAT END-STRT+1,<%FMAC (\%%FX)
	%%FX==%%FX+1>
>


STPT:	RESET
	MOVE P,[IOWD 40,PDL]
	INIT TAP,14
	SIXBIT /DSK/
	TAPBF,,0
	JRST DSKNA

	MOVE T1,[XWD TRNSET,TRNSTB]	;Set up the translation table
	BLT  T1,TRNSTB+177		;for all possible ASCII values

	MOVEI T1,(POINT 8,0,35)
	HRLM T1,TAPBF+1	;RESET BYTE SIZE
	SETZM LINK#		;POINTER TO LINKED LIST OF FILES
	MOVEI FL,0
xlatq:	outstr [asciz/
output pure ascii? (Y or N): /]
	pushj p,gnch
	caie c,"y"
	cain c,"Y"
	 jrst [setom xlatf#	;flag says to TAPOU2 & friends to
		jrst xlat1]	;skip TRNSTB translation
	setzm xlatf	;do the conversion from ASCII to TRNSTB(ascii)
	outstr [asciz/
(using Zytron translation)/]
xlat1:	pushj p,gnch	;now eat the <cr> <lf>
	caie c,12
	jrst xlat1
COPSEL:	OUTSTR [ASCIZ /
COPIES /]
	PUSHJ P,NUMRD
	CAIG T1,10
	CAIGE T1,1
	JRST COPSEL
	MOVEM T1,COPNUM#
NUMSEL:	OUTSTR [ASCIZ !
MAX NUMBER OF FILES/FICHE !]
	PUSHJ P,NUMRD
	CAIG T1,6
	CAIGE T1,1	;MUST BE BETWEEN 1 AND 3
	JRST NUMSEL
	MOVEM T1,MAXFSH#
	OUTSTR [ASCIZ /
GLOBAL TITLE /]
	SETZM GLBLOC
	MOVE T1,[POINT 7,GLBLOC+1]
	MOVEI T2,^D80
GETGLB:	PUSHJ P,GNCH
	CAIGE C," "
	JRST GOTGLB
	IDPB C,T1
	AOS GLBLOC
	SOJG T2,GETGLB
GOTGLB:	MOVEI T2,0
	IDPB T2,T1
	MOVSS GLBLOC
	MOVEI T1,^D18
	HRRM T1,GLBLOC
	PUSHJ P,WTLF
	SETZM TTLADN#	;WHAT TO ADD TO FISH NUMBER FOR TITLEE
	OUTSTR [ASCIZ /
START NUMBERING AT /]
	PUSHJ P,NUMRD
	MOVEM T1,TTLADN
	PUSHJ P,WTLF
NOADL:	PUSHJ P,GETFMT
	INIT FIL,0
	SIXBIT /DSK/
	FILBF
	 JRST DSKNA
	OUTSTR [ASCIZ /
FILE NAMES: /]
	MOVEI C," "	;PRIME FOR READING
	SETZM FSTNAM#
	SETZM UFDNM+2
FNLP:	PUSHJ P,NAMSCN	;SCAN FOR A NAME
	 JRST NAMDON	;FINISHED
	SKIPN FILUSR	;IS THERE A USER NAME?
	JRST FNNUS	;NO
	SKIPE FSTNAM	;IS THIS THE FIRST TIME?
	JRST USRERR	;NO, ERROR
	MOVEI T1,USRNM
	MOVEM T1,UFDNM+2	;SET IT UP
FNNUS:	SETOM FSTNAM
	PUSHJ P,GETLNK	;GET A CORE BLOCK
	MOVE T1,FILNAM
	PUSHJ P,MAKMSK	;GENERATE A MASK
	DMOVEM T1,1(T4)	;AND STORE
	SKIPN T1,FILEXT
	MOVSI T1,'LST'	;ASSUME LIST
	HLLZS T1	;CLEAR RIGHT HALF (USED FOR SKIPE TEST)
	PUSHJ P,MAKMSK
	HLLOS T2	;MAKE RIGHT HALF UNIMPORTANT
	DMOVEM T1,3(T4)
	MOVE T1,LINK
	MOVEM T1,(T4)
	MOVEM T4,LINK
	JRST FNLP
NAMDON:	PUSHJ P,WTLF

	SKIPN LINK
	JRST NOFLS	;NO FILE NAMES SEEN
	SETOM NFSN#	;NUMBER OF FILES SEEN (-1)
	INIT UFD,17
	SIXBIT /DSK/
	0
	 JRST DSKNA
	SKIPE UFDNM+2
	JRST OTHUFD
	HRROI T1,GETPPN
	GETTAB T1,
	 JRST NOUFD	;CAN NOT READ UFD IF GETTAB FAILS
	MOVEM T1,UFDNM+2
OTHUFD:	LOOKUP UFD,UFDNM
	 JRST NOUFD	;CAN NOT FIND IT. LOOK FOR REQUESTED FILES
	SETZM	UFDCCL	;CLEAR OUT FIRST LOC TO CLEAR IN CHANIO BLOCK
	MOVE	T1,[UFDCCL,,UFDCCL+1]
	BLT	T1,UFDCLS	;CLEAR TO LAST LOC TO CLEAR IN CHANIO BLOCK SO THAT WE
				; START FROM THE BEGINNING OF UFD
	SETZM FLINK#	;THIS IS THE 'FOUND' FILES LINK
UFDSRC:	PUSHJ P,RDUFD	;GET FILENAME AND EXT IN T1 AND T2
	 JRST UFDEOF	;DONE
	MOVEM T1,FILNAM	;SAVE NAME AND EXTENSION
	HLLZM T2,FILEXT
	MOVE T1,LINK	;SET TO START LOOKING
UFDCMP:	MOVE T2,FILNAM
	ANDCM T2,2(T1)	;MASK APPROPRIATELY
	CAME T2,1(T1)	;AND SEE IF IT MATCHES
	JRST UFDCMN	;NO COMPARE, TRY AGAIN
	MOVE T2,FILEXT
	ANDCM T2,4(T1)
	CAME T2,3(T1)	;SAME FOR EXTENSION
	JRST UFDCMN
	PUSHJ P,GETLNK
	DMOVE T1,FILNAM
	DMOVEM T1,1(T4)
	SETZM 3(T4)	;NOT LOOKED AT YET
	MOVEI T2,FLINK
ALPSRT:	HRRZ T3,(T2)
	JUMPE T3,LNKHER	;LINK IT IN HERE END OF CHAIN
	CAMG T1,1(T3)	;ALPHA ON FILE NAME
	JRST LNKHER
	MOVE T2,T3
	JRST ALPSRT	;CONTINUE

LNKHER:	HRLM T2,(T4)	;PUT IN A BACK LINK
	HRRM T3,(T4)	;AND A FORWARD LINK
	HRRM T4,(T2)	;LINK TIS TO PREVIOUS
	SKIPE T3	;AND IF THERE IS A NEXT
	HRLM T4,(T3)	;BACK LINK TO IT
	AOS NFSN	;ONE MORE SEEN
	JRST UFDSRC
UFDCMN:	MOVE T1,(T1)	;NOT THIS ONE, TRY THE NEXT
	JUMPN T1,UFDCMP	;TRY ANOTHER REQUEST
	JRST UFDSRC	;THIS ONE IS NOT WANTED

UFDEOF:	SKIPGE NFSN	;WERE ANY SEEN
	JRST NOFLS	;NO

	SETZM GRPLNK#	;NO GROUPING INFORMATION
	SETZM GRPPNT#	;POINTER TO GROUP BEING SPOOLED
	MOVE T1,MAXFSH
	CAIE T1,1	;IF ONLY ONE PER FYSH
	SKIPG NFSN	;OR ONLY ONE FILE
	JRST SPLFSH	;THEN GO SPOOL THE FYSH
	OUTSTR [ASCIZ /
GROUPING: /]
GRPGT2:	SETZB T4,USEFIL#	;FLAG AS NOTHING YET
	MOVEI C,40	;GET US STARTED ON A LINK
GRPGET:	CAIGE C,40	;ARE WE AT THE END OF THE LINE?
	JRST GRPFN1	;YES, FINISHED WITH THIS GROUPING
	MOVE T1,[POINT 6,FILNAM]
	SETZM FILNAM
	PUSHJ P,SCNIDS	;SCAN FOR A NAME
	CAIN C,"!"
	SETOM USEFIL	;USE NAMES FOR GROUPING NOT TITLES
	SKIPN T1,FILNAM
	JRST GRPFN1	;NOTHING THERE, ASSUME END OF LINE
	JUMPN T4,GRPGT1	;WE ALREADY HAVE THE LINK
	PUSHJ P,GETLNK
	MOVE T3,MAXFSH
	MOVNI T3,1(T3)	;ONE EXTRA FOR THE ZERO AT THE END
	HRLS T3
	HRRI T3,1(T4)	;ALL SET
GRPGT1:	MOVEM T1,(T3)
	PUSHJ P,SCNSPL
	AOBJN T3,GRPGET	;CONTINUE READING NAMES IN THIS LIST
	PUSHJ P,WTLF	;TOO MANY NAMES
	OUTSTR [ASCIZ /
TOO MANY NAMES IN LINE STARTING WITH /]
	MOVE T2,1(T4)
	PUSHJ P,OUTSIX
	OUTSTR [ASCIZ /
/]
	JRST GRPGT2

GRPFN1:	JUMPE T4,GENTTL	;NOW MUST CHECK TITLES ON FILE NAME
	SETZM (T3)	;CLEAR LAST IN LIST
	MOVE T1,GRPLNK
	MOVEM T4,GRPLNK
	MOVEM T1,(T4)
	PUSHJ P,WTLF	;FINISH OFF LINE
	JRST GRPGT2	;AND CONTINUE

GENTTL:	PUSHJ P,WTLF
	SKIPE USEFIL
	JRST SPLFSH	;DO NOT NEED TITLES
	HRRZ T4,FLINK	;START LOOKING FOR TITLES
GENTL1:	PUSHJ P,REDTTL
	HRRZ T4,(T4)	;NEXT ON CHAIN
	JUMPN T4,GENTL1	;TRY IT
	JRST SPLFSH	;NONE THERE, START MAKING FISH

GNTNXL:	CAIE C,14	;ALSO GO ON FORM FEED
	CAIN C,12	;WAIT FOR THE END OF LINE (BLANK LINE ETC)
	JRST GNTRDF	;AND START READING NEXT ONE
	PUSHJ P,RDFIL
	 JRST GNTEOF
	JRST GNTNXL

REDTTL:	DMOVE T1,1(T4)	;NAME AND EXT
	DMOVEM T1,FILNM+2
	MOVE T1,UFDNM+2	;GET PPN
	MOVEM T1,FILNM+1
	LOOKUP FIL,FILNM
	 JRST GNTEOF	;JUST PRETEND AN EARLY EOF (NO NAME)
	MOVE T1,[POINT 6,3(T4)]	;SET TO STORE NAME
GNTRDF:	PUSHJ P,RDFIL
	 JRST GNTEOF	;END OF FILE
	CAILE C,40	;WAIT FOR SPACE OR OTHER CONTROL
	TLNN T1,770000	;OR TOO MANY CHARACTERS
	JRST GNTEOL	;AND SAY LINE FINISHED
	CAIL C,140
	TRZA C,100
	SUBI C,40
	IDPB C,T1
	JRST GNTRDF	;CONTINUE

GNTEOL:	SKIPN 3(T4)	;WAS A TITLE SEEN?
	JRST GNTNXL	;NO, TRY NEXT LINE
GNTEOF:	SETZM 4(T4)	;SAY PAGES NOT CHECKED. ALSO IF NOT TITLE ANYWHERE
	CLOSE FIL,
	POPJ P,

SPLFSH:	SETZM FILOPN#	;FILE IS NOT OPEN YET
	SETZM DMOOPN#
	SETZM TOTFSH#	;NUMBER OF FISH OUTPUT
	SETZM TOTCST#	;TOTAL COST
	MOVE T1,COPNUM
	MOVE T1,CMDNAM-1(T1)	;GET APPROPRIATE SPOOL FILE NAME
	MOVSI T2,'MFC'
	DMOVEM T1,FILCNM+2
	INIT CMDS,16
	SIXBIT /DSK/
	0
	 JRST DSKNA
	SKIPE DEBFLG
	JRST SELFSH
RTYLOK:	LOOKUP CMDS,FILCNM
	 JRST NOCMF	;NO COMMAND FILE THERE YET
	ENTER CMDS,FILCNM
	 JRST INUSE
GOTENT:	UGETF CMDS,T2
	HRRZS T2
	JUMPE T2,FILMTY
	USETI CMDS,(T2)
	INPUT CMDS,CMDSCM	;READ
	MOVSI T1,-200
ENFLP:	SKIPN CMDBUF(T1)
	JRST CMDEND
	AOBJN T1,.+1
	AOBJN T1,ENFLP
FILMTY:	MOVSI T1,-200
	SETZM CMDBUF
	MOVE T2,[CMDBUF,,CMDBUF+1]
	BLT T2,CMDBUF+177
	SKIPA
CMDEND:	USETO CMDS,(T2)	;FORCE OUTPUT HERE
	MOVEM T1,CMDPTR#	;SAVE POINTER
	JRST SELFSH	;SELECT A FISH

INUSE:	HRRZ T1,FILCNM+3
	CAIE T1,3	;IS IT IN USE?
	JRST CMDFAL
	OUTSTR [ASCIZ /
SPOOL FILE IN USE...WAITING
/]
WAITLP:	MOVEI T1,5
	SLEEP T1,
	ENTER CMDS,FILCNM
	 JRST WAITLP
	JRST GOTENT

NOCMF:	ENTER CMDS,FILCNM
	 JRST CMDFAL
	CLOSE CMDS,0
	JRST RTYLOK

CMDNAM:	FOR (I,1,10,<SIXBIT /MFSC'I/>)

FILCNM:	3
	USR
	0
	0

	USR==0		;USE USER'S OWN DIRECTORY.
REPEAT 0,<
USR:	SIXBIT /SPOOLING/
	0
>;END REPEAT 0

CMDSCM:	IOWD 200,CMDBUF
	0

CMDFAL:	OUTSTR [ASCIZ /
CAN NOT ACCESS SPOOL FILES/]
	EXIT

	DEFINE READ (A,%Q)
<RDNUM==0
RDSPC==0
RDSTR==0
RDVAR==0
RDID==0
RDEOL==0
RDTOT==-1
RDFIN==%Q
RDRV==0

	IFE NOSCN,<PUSHJ P,SCAN>
	IFN NOSCN,<PUSHJ P,CPOPJ	;TO MARK STACK>
	IRP A,<CALLIT (READ2,A)>
	IFE RDTOT,<IFGE RDRV,<CAIE T1,RDLST
				IFE NOERR,<JRST SCNERR>
				IFN NOERR,<JRST RDFIN>
			IFE <RDRV-1>,<JRST RDDST>
			IFE <RDRV-2>,<RD%MAC>>
		IFL RDRV,<CAIN T1,RDLST
			RD%MAC
			IFE NOERR,<JRST SCNERR>
			IFN NOERR,<JRST RDFIN>
			IFE <RDRV+1>,<JRST RDDST>>>
	IFL RDTOT,<PRINTX READ ERROR NO ARGUMENT>
	IFG RDTOT,<JRST @[READ3 (<NUM,SPC,STR,VAR,ID,EOL>)](T1)>
%Q:
	NOERR==0
	NOSCN==0>

NOERR==0
NOSCN==0
	DEFINE CREAD(A)
<NOSCN==1
	READ (<A>)>

	DEFINE EREAD (A)
<NOERR==1
	READ (<A>)>

	DEFINE ECREAD (A)
<NOERR==1
NOSCN==1
	READ (<A>)>

	DEFINE READ3 (A)
<IRP A,<IFN RD'A,<IFG RD'A,<RD'A>
			IFL RD'A,<[RD%'A]>>
	IFE RD'A,<IFN NOERR,<RDFIN>
		IFE NOERR,<SCNERR>>
>>

	DEFINE CALLIT (A,B)
<	A (B)>

	DEFINE READ2 (TYPE,ARG)
<	RM.'TYPE (<ARG>)
>

	DEFINE RM.NUM (ARG)
<IFN RDNUM,<PRINTX ERROR IN NUM MULTIPLE CALL>
	RDLST==0
	RDTOT==RDTOT+1
IFDIF <ARG>,<NX>,<RDRV==1
		RDDST==ARG
		RDNUM==ARG>
IFIDN <ARG>,<NX>,<RDNUM==RDFIN>>

	DEFINE RM.STR (ARG)
<IFN RDSTR,<PRINTX ERROR IN STR MULTIPLE CALL>
	RDLST==2
	RDTOT==RDTOT+1
IFDIF <ARG>,<NX>,<RDRV==1
		RDDST==ARG
		RDSTR==ARG>
IFIDN <ARG>,<NX>,<RDSTR==RDFIN>>

	DEFINE RM.VAR (ARG)
<IFN RDVAR,<PRINTX ERROR IN VAR MULTIPLE CALL>
	RDLST==3
	RDTOT==RDTOT+1
IFDIF <ARG>,<NX>,<RDRV==1
		RDDST==ARG
		RDVAR==ARG>
IFIDN <ARG>,<NX>,<RDVAR==RDFIN>>

	DEFINE RM.EOL (ARG)
<IFN RDEOL,<PRINTX ERROR IN EOL MULTIPLE CALL>
	RDLST==5
	RDTOT==RDTOT+1
IFDIF <ARG>,<NX>,<RDRV==1
		RDDST==ARG
		RDEOL==ARG>
IFIDN <ARG>,<NX>,<RDEOL==RDFIN>>

	DEFINE RM.SPC (ARG)
<IFN RDSPC,<PRINTX ERROR IN SPC MULTIPLE CALL>
	RDLST==1
	RDTOT==RDTOT+1
	RDSPC==-1
	%%X==-1
	IRP ARG,<%%X==%%X+1>
	IFE %%X,<IRP ARG,<CALLIT (MLRD4,ARG)>>
	IFN %%X,<DEFINE RD%SPC
			<RD%COM (MLRD1,<ARG>)>
		RDRV==2
		DEFINE RD%MAC
			<RD%SPC>>>

	DEFINE MLRD4 (A,B)
<	DEFINE RD%SPC
 <	MLRD1 (A,B)
	IFN NOERR,<JRST RDFIN>
	IFE NOERR,<JRST SCNERR>>
	DEFINE RD%MAC
<	CAIE C,"A">
IFDIF <B>,<NX>,<RDRV==-1
	RDDST==B>
IFIDN <B>,<NX>,<RDRV==-2>>

	DEFINE RD%COM (MAC,ARG)
<IRP ARG,<CALLIT (MAC,ARG)>
	IFN NOERR,<JRST RDFIN>
	IFE NOERR,<JRST SCNERR>>

	DEFINE RM.ID (ARG)
<IFN RDID,<PRINTX ERROR IN ID MULTIPLE CALL>
	RDLST==4
	RDTOT==RDTOT+1
	RDID==-1
	%%X==-1
	IRP ARG,<%%X==%%X+1>
	IFE %%X,<IRP ARG,<CALLIT (MLRD3,ARG)>>
	IFN %%X,<DEFINE RD%ID
			<RD%COM (MLRD2,<ARG>)>
		RDRV==2
		DEFINE RD%MAC
			<RD%ID>>>


	DEFINE MLRD3 (A,B)
<	DEFINE RD%ID
 <	MLRD2 (A,B)
	IFN NOERR,<JRST RDFIN>
	IFE NOERR,<JRST SCNERR>>
	DEFINE RD%MAC
<	CAIE T2,.'A>
IFDIF <B>,<NX>,<RDRV==-1
	RDDST==B>
IFIDN <B>,<NX>,<RDRV==-2>>


	DEFINE MLRD1 (A,B)
<	CAIN C,"A"
IFDIF <B>,<NX>,<JRST B>
IFIDN <B>,<NX>,<JRST RDFIN>
>

	DEFINE MLRD2 (A,B)
<	CAIN T2,.'A
IFDIF <B>,<NX>,<JRST B>
IFIDN <B>,<NX>,<JRST RDFIN>
>

;HERE IS THE SCANNER FOR USE WITH THE ABOVE MACROS

SCAN:	SKIPN C,SAVCHR
SCAN1:	PUSHJ P,GNCH	;MAY HAVE TO SAVE ONE FROM LAST ID
	CAIE C," "	;IGNORE SPACES
	CAIN C,15	;AND RETURNS
	JRST SCAN1
	CAIN C,11
	JRST SCAN1
	CAIN C,12
	JRST SCNEOL	;LINE FEED TRANSLATES TO THE EOL CHR
	CAIN C,";"
	JRST NXTLIN	;AND ; GOES TO NEXT LINE
	CAIL C,140
	SUBI C,40	;CONVERT TO UPPER CASE
	CAIG C,"9"
	CAIGE C,"0"
	JRST NOTNUM	;NOT A NUMBER
	MOVEI T2,-"0"(C)	;GET NUMBER STARTED
	MOVEI T1,0	;NUMBER TYPE IS 0
SCANN1:	PUSHJ P,GNCH
	CAIG C,"9"
	CAIGE C,"0"
	JRST FINNUM	;END OF THE NUMBER
	IMULI T2,^D10
	ADDI T2,-"0"(C)
	JRST SCANN1

FINNUM:	MOVEM C,SAVCHR	;SAVE EXTRA CHR
	POPJ P,

SCNEOL:	SETZM SAVCHR	;NOTHING SAVED NOT
	MOVEI T1,5
	POPJ P,

NXTLIN:	PUSHJ P,GNCH
	CAIE C,12
	JRST NXTLIN	;WAIT FOR A LINE FEED TO COME
	JRST SCAN1	;THEN CONTINUE SCAN

NOTNUM:	CAIE C,"'"
	CAIN C,42	; """ quote.
	JRST SCNSTR	;THIS IS A STRING
	CAIG C,"Z"
	CAIGE C,"A"
	JRST SCNSPC	;MUST BE A SPECAIL CHARACTER

;HERE WE ARE SCANNING AN IDENTIFIER
	MOVE T1,[POINT 6,ACCUMT#]	;GET SET TO READ IT
	SETZM ACCUMT
SCNID7:	SUBI C,40
	TLNE T1,770000
	IDPB C,T1	;IGNORE EXTRA CHARACTERS
	PUSHJ P,GNCH
	CAIL C,140
	SUBI C,40
	CAIG C,"Z"
	CAIGE C,"0"
	JRST FINID	;CAN NOT BE PART OF AN ID
	CAIGE C,"A"
	CAIG C,"9"
	JRST SCNID7	;STILL PART OF ID
FINID:	MOVEM C,SAVCHR	;SAVE EXTRA CHR
	MOVSI T2,-IDNUM	;GET SET TO SCAN
	MOVE T1,ACCUMT
	CAME T1,IDTAB(T2)
	AOBJN T2,.-1
	JUMPL T2,GOTID	;IT WAS, RESERVED WORD
	MOVSI T2,-VARNUM
	CAME T1,VARTAB(T2)
	AOBJN T2,.-1
	JUMPGE T2,ILLID	;NOT RECOGNIZED
	MOVSI T1,%V.USE
	IORM T1,VARTB2(T2)
	MOVEI T1,3	;A VARIABLE
	HRRZS T2	;THIS IS THE VARIABLE NUMBER
	POPJ P,

GOTID:	MOVEI T1,4
	HRRZS T2
	POPJ P,

SCNSPC:	MOVEI T1,1
	SETZM SAVCHR	;NOTHING SAVED
	POPJ P,

SCNSTR:	MOVEM C,SAVSTR#	;REMEMBER DELIMITER
	MOVEI T2,MAXCHR	;MAX NUMBER OF CHRS
	MOVE T1,[POINT 7,STRACM]	;STRING ACCUMTULATOR
SCNST1:	PUSHJ P,GNCH
	CAMN C,SAVSTR
	JRST FINSTR	;END
	IDPB C,T1
	SOJGE T2,SCNST1
	OUTSTR [ASCIZ /
STRING TOO LONG/]
	JRST SCNER1

FINSTR:	MOVEI C,0
	IDPB C,T1
	MOVEI T1,MAXCHR
	SUB T1,T2
	PUSHJ P,GETSTR	;TRANSFER TO STRING SPACE
	MOVEI T1,2
	SETZM SAVCHR
	POPJ P,

;STRING CONTROL ROUTINES

MAXCHR==^D80
STRSVN==<MAXCHR+^D10>/5
ARRAY STRACM[<MAXCHR+5>/5],STRLNK[STRSVN]

EXTERNAL JOBFF,JOBREL

GETSTR:	PUSH P,T3
	PUSH P,T1
	PUSHJ P,GETSWD	;GET WORDS FOR STRING
	MOVE T2,T3
	ADD T1,T3
	ADDI T3,1
	HRLI T3,STRACM
	BLT T3,(T1)	;MOVE WORDS TO NEW AREA
	POP P,T1
	HRLM T1,(T2)
	POP P,T3
	POPJ P,

GETWDS:	CAIG T1,STRSVN	;IS IT TOO BIG
	SKIPN T3,STRLNK-1(T1)	;OR NONE RECLAIMED
	JRST NEWWDS	;GEN FROM FREE CORE
	PUSH P,(T3)
	POP P,STRLNK-1(T1)	;RESET LINK
	POPJ P,		;AND FINISHED
NEWWDS:	MOVE T3,JOBFF	;PUT IT HERE
	MOVE T2,T1
	ADD T2,T3
	MOVEM T2,JOBFF
	CAMG T2,JOBREL
	POPJ P,
	IORI T2,1777
	CORE T2,
	 JRST NOCOR	;NOT ENOUGH CORE
	POPJ P,

GIVSTR:	PUSH P,T1	;POINTER IS IN T2
	HRRZ T1,(T2)	;GET NUMBER OF WORDS
	HRRZS T2
	PUSHJ P,GIVWDS
	POP P,T1
	POPJ P,

GIVWDS:	CAILE T1,STRSVN
	POPJ P,
	HRRZS T2
	EXCH T2,STRLNK-1(T1)
	MOVEM T2,@STRLNK-1(T1)
	POPJ P,

GETSWD:	ADDI T1,^D10
	IDIVI T1,5
	PUSHJ P,GETWDS
	MOVEM T1,(T3)
	POPJ P,

ILLID:	OUTSTR [ASCIZ /
UNRECOGNIZABLE IDENTIFIER /]
	MOVE T2,ACCUMT
	PUSHJ P,OUTSIX
	EXIT

SCNERR:	OUTSTR [ASCIZ /
SCAN ERROR, EXPECTED
/]
	HRRZ T4,1(P)	;THIS IS THE CALL TO SCAN
	HLRZ T3,(T4)
	ANDI T3,777000
	CAIN T3,(JRST)	;EXAMINE TYPE OF CALL
	JRST SERJST	;AND PRINT APPROPRIATELY
	CAIN T3,(CAIN)
	JRST SERCAN
	HRRZ T3,(T4)	;GET THE TYPE EXPECTED
	CAIN T3,1
	JRST SCNER3	;SPECIAL CHR
	CAIN T3,4
	JRST SCNER4	;OR ID
	OUTSTR @SERTAB(T3)	;PRINT NUMBER ETC
SCNER2:	OUTSTR [ASCIZ /
FOUND /]
	CAIN T1,1
	JRST SCNR2A
	CAIN T1,4
	JRST SCNR2B
	OUTSTR @SERTAB(T1)
	JRST SCNER1	;AND PRINT REST OF LINE

SCNR2A:	OUTCHR C	;PRINT THE SPECIAL CHR
	JRST SCNER1

SCNR2B:	MOVE T2,IDTAB(T2)	;GET THE ID
	PUSHJ P,OUTSIX
	JRST SCNER1

SERTAB:	[ASCIZ /NUMBER/]
	[0]
	[ASCIZ /STRING/]
	[ASCIZ /VARIABLE/]
	[0]
	[ASCIZ /END OF LINE/]

SCNER3:	ADDI T4,1
	PUSHJ P,SERSPC
	JRST SCNER2

SCNER4:	ADDI T4,1
	PUSHJ P,SERIDS	;PRINT IDS
	JRST SCNER2

SERSPC:	HRRZ T3,(T4)
	OUTCHR T3
	ADDI T4,2
	HLRZ T3,(T4)
	CAIN T3,(JRST)
	POPJ P,
	OUTSTR [ASCIZ /
/]
	JRST SERSPC

SERIDS:	PUSH P,T1
	PUSH P,T2
SERID2:	HRRZ T3,(T4)
	MOVE T2,IDTAB(T3)
	PUSHJ P,OUTSIX
	ADDI T4,2
	HLRZ T3,(T4)
	CAIN T3,(JRST)
	JRST	[POP P,T2
		POP P,T1
		POPJ P,]
	OUTSTR [ASCIZ /
/]
	JRST SERID2

SERCAN:	HRRZ T3,(T4)
	CAIE T3,1
	JRST SERCN1	;MUST BE ID
	HRRZ T3,1(T4)
	OUTCHR T3
	JRST SCNER2

SERCN1:	PUSH P,T1
	PUSH P,T2
	HRRZ T3,1(T4)
	MOVE T2,IDTAB(T3)
	PUSHJ P,OUTSIX
	POP P,T2
	POP P,T1
	JRST SCNER2

SERJST:	HRRZ T4,(T4)
	HRLI T4,-6
	SETZM SNTFLG#
SERJS1:	HRRZ T3,(T4)
	CAIE T3,SCNERR
	JRST SERJS2
SERJS5:	AOBJN T4,SERJS1
	JRST SCNER2

SERJS2:	SKIPE SNTFLG
	OUTSTR [ASCIZ /
/]
	SETOM SNTFLG
	HLRO T3,T4
	ADDI T3,6
	CAIN T3,1
	JRST SERJS3	;SPECIAL CHR
	CAIN T3,4
	JRST SERJS4	;ID
	OUTSTR @SERTAB(T3)
	JRST SERJS5

SERJS3:	PUSH P,T4
	HRRZ T4,(T4)
	PUSHJ P,SERSPC
	POP P,T4
	JRST SERJS5

SERJS4:	PUSH P,T4
	HRRZ T4,(T4)
	PUSHJ P,SERIDS
	POP P,T4
	JRST SERJS5

SCNER1:	OUTSTR [ASCIZ /, REMAINDER OF LINE FOLLOWS
/]
	PUSHJ P,GNCH
	OUTCHR C
	CAIE C,12
	JRST .-3
	TRNE FL,FR.ATF	;IF NOT FROM A FILE
	SKIPN T1,ATFLIN	;OR NO LINE
	EXIT	;THE DONE
	OUTSTR [ASCIZ /
/]
	MOVEI T2,0
	OUTSTR T1
	OUTCHI "/"
	AOS T1,ATFPAG
	PUSHJ P,OUTDEC
	EXIT

;HERE IS THE VARIABLE DEFINITION AREA

%V.DEF==400000	;DEFINED
%V.KEP==200000	;KEEP VAR AT END OF PAGE
%V.KPO==100000	;KEEP VAR AT END OF OVERFLOW PAGE
%V.PRS==40000	;PRESENT. SOME TITLES, ETC. MAY NOT BE
%V.USE==20000	;VARIABLE IN USE (MOSTLY FOR TITLES)
%V.DUP==10000	;FOR 'DUPLICATE' STRINGS. ONLY IN ACCUM
%V.KPF==4000	;KEEP VAR ON BROKEN FICHE

	RADIX 10
VARTAB:	PHASE 0
	FOR (I,1,50,<SIXBIT /VAR'I/>)
OUTVNM==.
	SIXBIT /OUTVAR/
	VVNUM==.
TTLBLK:! FOR (I,1,6,<SIXBIT /TITLE'I/>)
FILBLK:! FOR (I,1,6,<SIXBIT /FILE'I/>)
EXTBLK:! FOR (I,1,6,<SIXBIT /EXT'I/>)
TTLHLD:! SIXBITLE/
FILHLD:! SIXBIT /FILE/
EXTHLD:! SIXBIT /EXT/
LOCHLD:! SIXBIT /LOC/
BRKHLD:! SIXBIT /BREAKN/
FCHHLD:! SIXBIT /FICHEN/
GLBHLD:! SIXBIT /GLOBAL/
DAYHLD:! SIXBIT /DAY/
MONHLD:! SIXBIT /MONTH/
MNNHLD:! SIXBIT /MONTHN/
MN3HLD:! SIXBIT /MON3/
YERHLD:! SIXBIT /YEAR/
	VARNUM==.
	DEPHASE

VARTB2:	REPEAT VVNUM,<0>
	REPEAT <VARNUM-VVNUM>,<%V.DEF,,0>
	RADIX 8

;HERE IS THE ID TABLE

	DEFINE X (A)
<.'A:!	<SIXBIT /A/>>

IDTAB:	PHASE 0
	X TEXT
	X DELETE
	X AFTER
	X FIRST
	X INDEX
	X LAST
	X LINE
	X OVERFLOW
	X PAGE
	X BLANK
	X FOR
	X ITEM
	X ON
	X SCAN
	X START
	X STOP
	X CHARACTERS
	X NUMBER
	X SKIP
	X END
	X FICHE
	X KEEP
	X CENTER
	X HEADING
	X CLEAR
	X IF
	X IFNO
	X LOCATE
	X NO
	X RIGHT
	X SIZE
	X SUPRESS
	X UNCHANGED
	X NONE
	X INDENT
	X NFILE
	X FRAMES
	X GROUP
	X LINES
	X REVERSE
	X TLINE
	X DEBUG
	X CHANGE
	X IFDIF
	X IFEQ
IDNUM==.
	DEPHASE

COMMENT ;

THE READ MACRO GENERATES CODE TO SCAN AND CHECK VALUES RETURNED
BY THE SCAN ROUTINES. THESE VALUES ARE
T1=TYPE OF VALUE SEEN
0	NUMBER IN T2
1	SPECIAL CHARACTER IN C
2	STRING, STRING POINTER IN T2
3	VARIABLE, VARIABLE NUMBER IN T2
4	RESERVED WORD (IDENT), RESERVED WORD NUMBER IN T2
5	END OF LINE

THE ARGUMENTS TO READ ARE A SERIES OF DISPATCH CODES IN <>
I.E. <DSP1,DSP2,DSP3>
EACH DISPATCH IS FOR A GIVEN TYPE OF SCAN ARGUMENT AND SPECIFIES
AN ADDRESS TO GO TO. EACH DISPATCH IS <TYPE,ADDRESS> THE TYPES
ARE  NUM,SPC,STR,VAR,ID,EOL IN THE ORDER ABOVE. THE ADDRESS NX
IS THE ADDRESS AFTER THE READ MACRO.

FOR SPC AND ID, FURTHER CHECKING IS DONE ON THE EXACT VALUE.
THE ADDRESS IS REPLACED WITH A SET OF DISPATCHES IN <>
EACH DISPATCH CONTAINS THE SPECIAL CHARACTER (OR IDENT) AND AN
ADDRESS AS    <SPC,<<#,SHARP>,<!,EXPL>,<%,PERC>>>

IF NO MATCH IS FOUND, THE ROUTINE SCNERR IS GONE TO

THERE ARE THREE VARIANTS OF READ

CREAD	DO NOT SCAN, JUST CHECK CURRENT VALUES
EREAD	GO TO NX INSTEAD OF SCNERR ON NO MATCH
ECREAD	DO NOT SCAN, GO TO NX IF NO MATCH FOUND

THERE IS A TABLE CALLED VARTB2 WITH ONE ENTRY FOR EACH VARIABLE.

THE LEFT HALF HAS FLAGS
%V.DEF (BIT 0) VARIABLE DEFINED IN TEXT SECTION
%V.KEP	KEEP THIS VARIABLE AT THE END OF THIS PAGE
%V.KPF	KEEP THIIS VARIABLE AT THE END OF A FICHE BREAK
%V.KPO	KEEP THIS VARIABLE AT THE END OF AN OVERFLOW PAGE
%V.PRS	THERE IS A VALUE PRESENT IN THE RIGHT HALF
%V.USE	THE VARIABLE IS IN USE (MOSTLY FOR TITLE INFO)

THE RIGHT HALF HAS THE VALUE
IF THE VARIABLE IS A NUMBER, THE NUMBER
IF THE VARIABLE IS A STRING, THE STRING POINTER

A STRING POIINTER POINTS TO A BLOCK WITH THE FOLLOWING FORMAT:
WORD 0 LEFT HALF HAS THE NUMBER OF CHARACTERS
WORD 0 RIGHT HALF HAS THE NUMBER OF WORDS IN THE BLOCK
WORD 1-N HAVE THE CHARACTERS TERMINATED BY A NULL

THE TEXT SCAN STRUCTURE GENERATED HAS A LINKED LIST FOR
EACH LINE. THERE IS A TABLE OF ALL LINE HEADERS CALLED LSCTAB.
EACH ENTRY HAS THE FOLLOWING FORM:

WORD 0 LH. POINTER TO THE PARAMETER BLOCK FOR TEXT EXTRACTION
	RH. NEXT SCAN LIST ENTRY

THE PARAMETER BLOCK IS
WORD 0 LH. TYPE OF ENTRY
	RH. THE NUMBER OF THE VARIABLE TO BE FILLED IN

TYPES:
0 AND 1 ARE SCAN TYPES 0 ALWAYS SCAN, 1 SCAN IF %V.PRS NOT SET

WORD 1 IS AN AOBJN PNTR TO THE FIRST CONTROL WORD
WORD 2 THE COUNT OF THE NUMBER OF STRINGS (USED TO GET THE OFFSET
	TO THE SECOND CONTROL WORD

THE CONTROL WORD FORMAT IS
WORD 1 RH ALWAYS A STRING POINTER TO THE STRING TO LOOK FOR
WORD 1 LH ACTION CODE IF STRING FOUND

ACTIONS:
0	WORD 2 RH IS A STRING POINTER TO SET VAR FROM
1	READ NUMBER
2	READ NUMBER SKIP BLANKS
3	READ CHRS
4	READ CHRS SKIP BLANKS
5	READ CHRS STOP BLANK
6	READ CHRS SKIP BLANKS STOP BLANK
7	READ CHRS STOP AFTER ITEM
10	READ CHRS SKIP BLANKS STOP AFTER ITEM

FOR 3-10 WORD 2 IS NUMBER OF CHRS

BACK TO PARAMETER BLOCKS, TYPE 2-17 ARE TEXT TO READ
2,4,6 ARE ALWAYS SCAN. 3,5,7 ARE SCAN IF %V.PRS NOT SET

2,3	READ N CHRS
4,5	READ N CHRS STOP ON BLANK
6,7	READ N CHRS STOP AFTER ITEM
12-17 ARE CORRESPONDING ONES BUT SKIP BLANKS FIRST

WORD 1 HAS START POS IN LH, NUMBER OF CHRS IN RH.

THE PARAMATER BLOCKS ARE ORDERED WITH ALL SCAN BLOCKS FIRST
THE ALL TEXT BLOCKS ORDERED BY STARTING POSITION.

THE DEFINITIONS OF THE AREAS ARE

#TEXT

<TXD1>:=<TXD2>|<TXD2><TXD1>
<TXD2>:=<VNAM>=<TXD3><EOL>
<TXD3>:=LINE <LSPEC><TXTSPC>|<STRINGV>
<LSPEC>:=<NUMBER>|LAST|LAST AFTER <NUMBER>|FIRST AFTER <NUMBER>
<TXTSPC>:=<SCNSPC>|<TXT1SPC>
<TXT1SPC>:=START <NUMBER> <SKPSPC> FOR <NUMBER> <STPSPC>
<STPSPC>:=|STOP AFTER ITEM|STOP ON BLANK
<SCNSPC>:=SCAN <MSTSPC>
<MSTSPC>:=<SSTSPC>|<SSTSPC>!<MSTSPC>
<SSTSPC>:=<STRING><ACTSPC>
<ACTSPC>:=<SKPSPC> NUMBER|<SKPSPC> CHARACTERS <NUMBER><STPSPC>
	|=<STRING>
<SKPSPC>:=|SKIP BLANK

#PAGE

<PAG1>:=<PAG2>|<PAG2><PAG1>
<PAG2>:=KEEP <VNAM> <EOL>

#OVERFLOW PAGE

<PAGO1>:=<PAGO2>|<PAGO2><PAGO1>
<PAGO2>:=<PAGO3>|<PAG2>
<PAGO3>:=BLANK <NUMBER>

#INDEX

<ISC1>:=<HDSPC><ISC2>|<ISC2>|NONE
<HDSPC>:=HEADING <STRING><EOL>
<ISC2>:=NO CLEAR <EOL> <ISC3>|<ISC3>
<ISC3>:=<ISC4>|<ISC4><ISC3>
<ISC4>:=<LITEM><EOL>|<STRING><EOL>|LOCATE <NUMBER><EOL>
<LITEM>:=ITEM <NUMBER> SIZE <NUMBER><STRINGV><JSTITM><CLRRQ1><MODE>
<CLRRQ1>:=|<CLRRQ2>|<CLRRQ2><CLRRQ1>
<CLRRQ2>:=CHANGE CLEARS ITEM <NUMBER>
<JSTITM>:=|RIGHT|CENTER
<MODE>:=|SUPRESS UNCHANGED|INDENT UNCHANGED <NUMBER>
<STRINGV>:=<STRINGV1>|<STRINGV1>+<STRINGV>
<STRINGV1>:=<STRNGV2>|<STRNGV1> START <NUMBER> FOR <NUMBER>
	|<STRNGV1> DELETE BLANK
<STRINGV2>:=<VNAM>|<STRINGI>|<STRING>|INDEX ITEM <NUMBER> PAGE <NUMBER>
<STRINGI>:=IF <STRINGV> [ <STRINGV> ]
	|IFNO <STRINGV> [ <STRINGV> ]
	| IFEQ <STRINGV> <STRINGV> [ <STRINGV> ]
	| IFDIF <STRINGV> <STRINGV> [ <STRINGV> ]

#FICHE

<TT1>:= REVERSE <EOL> <TT2>|<TT2>
<TT2>:=<TT3>|<TT3><TT2>
<TT3>:=<DEFNI><CDEF>
<DEFNI>:=GROUP <DEFNI1><EOL>
<DEFNI1>:=<DEFNI2>|<DEFNI2><DEFNI1>
<DEFNI2>:=<DEFNI3>|IF <STRINGV> [ <DEFNI1> ] 
	| IFNO <STRINGV> [ <DEFNI1> ]
	| IFEQ <STRINGV> <STRINGV> [ <DEFNI1> ]
	| IFDIF <STRINGV> <STRINGV> [ <DEFNI1> ]
<DEFNI3>:=|FRAMES <NUMBER>|CHARACTERS <NUMBER>|LINES <NUMBER>

<CDEF:=<CDEF1>|<CDEF1><CDEF>
<CDEF1>:=TLINE <NUMBER> <TLNDF>
<TLNDF>:=|<TLNDF1>|<TLNDF1><TLNDF>
<TLNDF1>:=SIZE <NUMBER><STRINGV><JSTITM><EOL>

#NFILE

<TT1>

#OVERFLOW FICHE

<TT1>
;

;HERE TO START COMPILING FORMAT INFO

GETFMT:	OUTSTR [ASCIZ /
FORMAT INFORMATION /]
	SETZM SAVCHR#
	SETZM STRLNK	;NO RECOVERED CORE
	MOVE T1,[STRLNK,,STRLNK+1]
	BLT T1,STRLNK+STRSVN-1
	SETZM LINTAB
	MOVE T1,[LINTAB,,LINTAB+1]
	BLT T1,LINTAB+LNSPAG-1
	SETZM VARTB2	;CLEAR VARIABLES
	MOVE T1,[VARTB2,,VARTB2+1]
	BLT T1,VARTB2+VVNUM-1
	MOVSI T1,%V.DEF
	MOVEM T1,VARTB2+VVNUM
	MOVE T1,[VARTB2+VVNUM,,VARTB2+VVNUM+1]
	BLT T1,VARTB2+VARNUM-1
	MOVEI VTAB,IDXVAR
	PUSHJ P,INIVAR
	MOVEI VTAB,TTLVAR
	PUSHJ P,INIVAR	;INITIALLIZE ACTION STUFF
	MOVEI VTAB,VARVAR
	PUSHJ P,INIVAR
	MOVEI VTAB,IDGVAR
	PUSHJ P,INIVAR
	MOVEI VTAB,TTOVAR
	PUSHJ P,INIVAR
	MOVEI VTAB,NFLVAR
	PUSHJ P,INIVAR
	SETZM OVFBLK#	;NUMBER OF BLANK LINES ON OVERFLOW
	SETZM IDXTTL#	;TITLE FOR INDEX
	SETZM IDXPRS#	;DO WE WANT AN INDEX (0=YES)
	SETZM IDXCLR#	;DO BLANK LINES IN INDEX FORCE VARS TO CHANGE
	SETZM NEDTTL#	;DO NOT NEED TITLES
	SETZM IDXBLK
	MOVE T1,[IDXBLK,,IDXBLK+1]	;MAKE SURE ITS CLEARED
	BLT T1,IDXBLK+^D<207*10>-1

	MOVE T1,[%V.PRS,,GLBLOC]
	SKIPE GLBLOC	;ARE THERE ANY CHRS THERE?
	IORM T1,VARTB2+GLBHLD	;YES, SET AS THERE
	DATE T1,
	IDIVI T1,^D31
	PUSH P,T2	;SAVE DAY
	IDIVI T1,^D12
	PUSH P,T2	;SAVE MONTH
	ADDI T1,^D1964
	MOVE T3,[POINT 7,YEARLC+1]
	PUSHJ P,DECCOR	;MOVE IT INTO CORE
	
	MOVE T1,[%V.DEF!%V.PRS,,YEARLC]
	MOVEM T1,VARTB2+YERHLD
	POP P,T1
	MOVE T2,MN3TAB(T1)
	MOVEM T2,VARTB2+MN3HLD
	MOVE T2,MONTAB(T1)
	MOVEM T2,VARTB2+MONHLD
	ADDI T1,1
	MOVEI T2,1
	CAIL T1,^D10
	MOVEI T2,2	;NUMBER OF DIGITS
	HRLZM T2,MNNLOC
	MOVEI T2,2
	HRRM T2,MNNLOC
	MOVE T3,[POINT 7,MNNLOC+1]
	PUSHJ P,DECCOR
	MOVE T1,[%V.DEF!%V.PRS,,MNNLOC]
	MOVEM T1,VARTB2+MNNHLD
	POP P,T1
	ADDI T1,1
	MOVEI T2,1
	CAIL T1,^D10
	MOVEI T2,2
	HRLZM T2,DAYLOC
	MOVEI T2,2
	HRRM T2,DAYLOC
	MOVE T3,[POINT 7,DAYLOC+1]
	PUSHJ P,DECCOR
	MOVE T1,[%V.DEF!%V.PRS,,DAYLOC]
	MOVEM T1,VARTB2+DAYHLD
	JRST FSTLOP	;GO


YEARLC:	4,,0
	0
ARRAY DAYLOC,MNNLOC[2]

DECCOR:	SETZM (T3)
DECCR1:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,DECCR1
	HLRZ T1,(P)
	ADDI T1,"0"
	IDPB T1,T3
	POPJ P,

	DEFINE XCNT (A)
<%%CNT==0
IRPC A,<%%CNT==%%CNT+1>
	%V.DEF!%V.PRS,,[%%CNT,,0
		ASCIZ /A/]
>
	DEFINE XRP (A)
<IRP A,<XCNT A>>

MONTAB:	XRP <JANUARY,FEBRUARY,MARCH,APRIL,MAY,JUNE,JULY,AUGUST>
	XRP <SEPTEMBER,OCTOBER,NOVEMBER,DECEMBER>

MN3TAB:	XRP <JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>

FSTLOP:	READ <<EOL,FSTLOP>,<SPC,<<#,NX>>>>
FSTLP1:	READ <<ID,<<FICHE,RDTTL>,<NFILE,RDNFIL>,<TEXT,RTXT>,<END,ENDSPC>,<PAGE,RDPG>,<OVERFLOW,RDOVF>,<INDEX,RDIDX>>>>

RTXT:	READ (<<EOL,NX>>)	;SHOULD BE EOL
	MOVEI VTAB,VARVAR	;GET SET UP TO SORE VARIABLE INFO
RTXT1:	READ <<EOL,RTXT1>,<VAR,NX>,<SPC,<<#,FSTLP1>>>>
	MOVEM T2,VRBNUM#	;FOUND A VARIABLE
	SKIPGE VARTB2(T2)	;MUST NOT BE DEFINED
	JRST MULDEF
	READ <<SPC,<<=,NX>>>>
	READ <<STR,VARSPC>,<VAR,VARSPC>,<ID,<<IF,VARSPC>,<IFNO,VARSPC>,<LINE,NX>>>>
	READ <<NUM,LNUM>,<ID,<<LAST,LLST>,<FIRST,NX>>>>
	READ <<ID,<<AFTER,NX>>>>
	READ <<NUM,NX>>
	HRLI T2,(3B1)	;FLAG AS FIRST AFTER
	JRST LNUM	;AND GO STORE

LLST:	READ <<ID,<<AFTER,NX>>>>
	READ <<NUM,NX>>
	HRLI T2,(1B0)
LNUM:	MOVEM T2,LNUMS#	;SAVE NUMBER
	READ <<ID,<<START,NX>,<SCAN,SCNTSP>>>>
	MOVEI T1,2
	PUSHJ P,GETWDS	;NEED A 2 WORD BLOCK
	READ <<NUM,NX>>
	HRLM T2,1(T3)	;STORE START POSITION
	READ <<ID,<<FOR,NX>,<SKIP,LINSKP>>>>
	HRRZM (T3)		;WILL NOT BE A SKIP BLANK
LNMFOR:	READ <<NUM,NX>>
	HRRM T2,1(T3)	;AND SIZE
	PUSHJ P,STPSPC	;SEE IF A STOP SPEC (T4 IS LOADED)
	ADDI T4,1
	LSH T4,1
	HRLZS T4
	ADDM T4,(T3)	;TURNS INTO TYPE
	CREAD (<<EOL,NX>>)
LNKLIN:	MOVSI T2,%V.DEF
	MOVE T1,VRBNUM
	HRRM T1,(T3)
	IORM T2,VARTB2(T1)	;AND FLAG VARIABLE
	MOVE T1,LNUMS	;NOW LINK IN
	MOVSI T2,1
	TLNE T1,(1B1)
	ADDM T2,(T3)	;IN CASE OF FIRST AFTER
	TLNN T1,(1B0)
	JRST SNGLN	;JUST ONE LINE
	MOVEI T4,LNSPAG
	SUBI T4,(T1)
	MOVNS T4
	HRLS T4
	HRRI T4,1(T1)	;SET UP AOBJN PTR
	HRRZ T1,T4
	PUSHJ P,LNKSNG
	AOBJN T4,.-2
	JRST RTXT1	;FINISHED

SNGLN:	HRRZS T1
	PUSHJ P,LNKSNG
	JRST RTXT1

LINSKP:	READ <<ID,<<BLANK,NX>>>>
	MOVEI T4,10
	HRLM T4,(T3)
	READ <<ID,<<FOR,LNMFOR>>>>

VARMAX==^D60	;SPACE FOR EACH 'ACTION' LIST
ARRAY TTOVAR,NFLVAR,IDXVAR,TTLVAR,VARVAR,IDGVAR[VARMAX+2]

INIVAR:	MOVEI T1,VARMAX*5-1
	MOVEM T1,1(VTAB)
	MOVEI T1,2(VTAB)
	HRLI T1,(POINT 7,0)
	MOVEM T1,(VTAB)
	POPJ P,

ENDSPC:	MOVEI T1,0
	IDPB T1,IDXVAR	;PUT IN TERMINATE CODE
	IDPB T1,TTLVAR
	IDPB T1,VARVAR
	IDPB T1,IDGVAR
	IDPB T1,NFLVAR
	SKIPN TTOVAR+2
	MOVEI T1,%.UNT	;NO OVERFLOW SPEC., USE NORMAL MODE
	IDPB T1,TTOVAR
	MOVSI T1,%V.USE
	TDNE T1,VARTB2+TTLHLD
	SETOM NEDTTL
	MOVSI T2,-6
	TDNE T1,VARTB2+TTLBLK(T2)	;SEE IF NEED TITLES FOR ANYTHING
	SETOM NEDTTL
	AOBJN T2,.-2
	SETZM DEBFLG#	;DEBUG NOT WANTED
	READ <<EOL,CPOPJ>,<ID,<<DEBUG,NX>>>>
	SETOM DEBFLG	;YES IT IS
	MOVEI T1,(POINT 7,0,35)
	HRLM T1,TAPBF+1	;RESET BYTES FOR DEBUG
	READ <<EOL,NX>>
	POPJ P,

;OVERFLOW INFORMATION

RDOVF:	READ <<ID,<<FICHE,OVFFCH>,<PAGE,NX>>>>
	READ <<EOL,NX>>
RDOPG1:	READ <<EOL,RDOPG1>,<SPC,<<#,FSTLP1>>>,<ID,<<KEEP,NX>,<BLANK,RDOVBL>>>>
RDOPG3:	READ <<VAR,NX>>
	MOVSI T1,%V.KPO	;WANT TO KEEP THIS VARIABLE
	IORM T1,VARTB2(T2)
	READ <<EOL,RDOPG1>,<SPC,<<<<,>>,RDOPG3>>>>
RDOPG2:	READ <<EOL,RDOPG1>>

RDOVBL:	READ <<NUM,NX>>
	CAIL T2,LNSPAG-2
	JRST OVFPLG	;TOO BIG
	MOVEM T2,OVFBLK
	JRST RDOPG2

OVFPLG:	OUTSTR [ASCIZ /
OVERFLOW PAGE, BLANK SPECIFICATION TOO LARGE, IGNORED
/]
	JRST RDOPG2

RDPG:	READ <<EOL,NX>>
RDPG1:	READ <<EOL,RDPG1>,<SPC,<<#,FSTLP1>>>,<ID,<<KEEP,NX>>>>
RDPG3:	READ <<VAR,NX>>
	MOVSI T1,%V.KEP
	IORM T1,VARTB2(T2)
	READ <<EOL,RDPG1>,<SPC,<<<<,>>,RDPG3>>>>

;HERE TO CHECK FOR STOP SPEC. NO ERROR ON SCAN (POSSIBLY NULL)
;RETURNS T4=0 IF NULL, =1 IF STOP ON BLANK, =2 IF STOP AFTER ITEM

STPSPC:	EREAD <<ID,<<STOP,STPS1>>>>
	MOVEI T4,0	;MUST BE NULL
	POPJ P,

STPS1:	READ <<ID,<<ON,NX>,<AFTER,STPAFT>>>>
	READ <<ID,<<BLANK,NX>>>>
	MOVEI T4,1
	JRST SCAN	;EXIT THROUGH SCAN SO ONE EXTRA ALWAYS THERE

STPAFT:	READ <<ID,<<ITEM,NX>>>>
	MOVEI T4,2
	JRST SCAN

;LINK IN A LINE. LINE NUMBER IN T1

LNKSNG:	CAIL T1,0
	CAILE T1,LNSPAG
	JRST BADNUM	;BAD LINE NUMBER
	PUSH P,T1
	PUSH P,T3
	MOVEI T1,1
	PUSHJ P,GETWDS	;GET A LINK BLOCK
	POP P,T2
	HRLZM T2,(T3)	;POINT TO THE ONE WE WERE GIVEN
	HLRZ T1,1(T2)	;POSSIBLY START LOC
	MOVEM T1,SVSTRT#
	HLRZ T2,(T2)	;GET TYPE
	POP P,T1	;LINE NUMBER
	CAIG T2,1
	JRST LNKSTR	;SCAN BLOCK, LINK AT START
	MOVEI T2,LINTAB-1(T1)
LNKON1:	HRRZ T1,(T2)	;NEXT POINTER
	JUMPE T1,LNKEND	;LINK AT END OF LIST
	PUSH P,T4
	HLRZ T1,(T1)	;GET BLOCK
	HLRZ T4,(T1)
	CAIG T4,1
	JRST LNKON	;CONTINUE SEARCH
	HLRZ T4,1(T1)
	CAMGE T4,SVSTRT
	JRST LNKON	;CONTINUE SEARCH
	POP P,T4
	HRRZ T1,(T2)
LNKNOW:	HRRM T1,(T3)
LNKEND:	HRRM T3,(T2)
	HLRZ T3,(T3)	;RESTORE T3
	POPJ P,

LNKON:	POP P,T4
	HRRZ T2,(T2)	;POINT TO NEXT
	JRST LNKON1	;AND CONTINUE

LNKSTR:	MOVEI T2,LINTAB-1(T1)
	HRRZ T1,(T2)
	JRST LNKNOW

MXSCG==^D20	;MAX NUMBER OF STRINGS IN A SCAN STATEMENT
ARRAY SCNACM,SCNAC2[MXSCG]

SCNTSP:	MOVSI T4,-MXSCG	;SET UP AOBJN PTR TO READ
MORTSC:	READ <<STR,NX>>
	HRRZM T2,SCNACM(T4)	;SAVE STRING TO SCAN FOR
	READ <<SPC,<<=,NX>>>,<ID,<<SKIP,SCNSKP>,<NUMBER,SCNRDN>,<CHARACTERS,SCNRDC>>>>
	READ <<STR,NX>>
	HRRZM T2,SCNAC2(T4)	;STORE STRING TO SET VARIABLE TO
MORSC1:	READ <<SPC,<<!,NX>>>,<EOL,SCNRDY>>
MORSC2:	AOBJN T4,MORTSC	;MORE STRINGS, READ ANOTHER
	OUTSTR [ASCIZ /
TOO MANY SCAN STRINGS/]
	JRST SCNER1

;HERE ON A SKIP BLANKS

SCNSKP:	READ <<ID,<<BLANK,NX>>>>
	MOVEI T1,1
	HRLM T1,SCNACM(T4)	;BUMP BY 1 FOR BLANK SKIP
	READ <<ID,<<NUMBER,NX>,<CHARACTERS,SCNRDC>>>>
SCNRDN:	MOVSI T1,1
	ADDM T1,SCNACM(T4)	;SETS TO 1 OR 2 FOR NUMBER
	JRST MORSC1	;AND CHECK FOR MORE
SCNRDC:	READ <<NUM,NX>>
	MOVEM T2,SCNAC2(T4)	;STORE NUMBER OF CHRS TO READ
	PUSH P,T4	;SAVE AOBJN PNTR
	PUSHJ P,STPSPC	;LOOK FOR STOP ON ITEM ETC.
	AOS T3,T4
	POP P,T4
	LSH T3,1
	ADDI T3,1	;3 FOR NOTH, 5 FOR BLANK, 7 FOR ITEM
	MOVSS T3
	ADDM T3,SCNACM(T4)	;ADD IN (POSSIBLE 1 FOR BLANK SKIP)
	CREAD <<SPC,<<!,MORSC2>>>,<EOL,NX>>

;HERE WHEN WE HAVE FINISHED SCANNING SCAN INFORMATION

SCNRDY:	HRRZ T1,T4	;NUMBER WE HAVE (-1)
	LSH T1,2	;2 WORDS PER ENTRY
	ADDI T1,5	;PLUS SOME HEADERS
	PUSHJ P,GETWDS
	SETZM (T3)	;TYPE 0 (OR POSSIBLY 1)
	MOVEI T1,1(T4)
	MOVEM T1,2(T3)	;COUNT
	MOVNS T1
	HRLZS T1
	HRRI T1,3(T3)	;HERE SEARCH POINTERS WILL GO
	MOVEM T1,1(T3)
	MOVEI T4,0	;NOW MOVE INFO TO FREE CORE
	MOVE T2,1(T3)	;PUT STRINGS HERE
MOVSC1:	MOVE T1,SCNACM(T4)
	MOVEM T1,(T2)
	ADDI T4,1
	AOBJN T2,MOVSC1
	HRRI T4,0
	MOVE T2,2(T3)
	ADD T2,1(T3)	;TO GET AN AOBJN POINTER
MOVSC2:	MOVE T1,SCNAC2(T4)
	MOVEM T1,(T2)
	ADDI T4,1
	AOBJN T2,MOVSC2
	JRST LNKLIN	;LINK IN THE LINE


VARSPC:	MOVSI T3,%V.DEF
	MOVE T4,VRBNUM
	IORM T3,VARTB2(T4)	;MAKE THIS ONE DEFINED
	PUSHJ P,STRNVS	;GENERATE CODE FOR IF'S ETC.
	CREAD <<EOL,NX>>
	MOVEI T1,%.STR
	PUSHJ P,STORE
	HRRZ T1,VRBNUM
	PUSHJ P,STORE	;NOW STORE IN VARIABLE TABLE
	JRST RTXT1

UNDFV:	OUTSTR [ASCIZ /
UNDEFINED VARIABLE /]
	JRST MULDF1

STORE:	IDPB T1,(VTAB)
	SOSL 1(VTAB)
	POPJ P,
	OUTSTR [ASCIZ /
EXPRESSION COMPLEXITY EXCEEDED/]
	JRST SCNER1

RDNFIL:	MOVEI VTAB,NFLVAR	;#NFILE, READ A TITLE SPEC
	MOVEI T1,%.ITS		;INIT TITLE SMALL
	JRST RDTTL0

OVFFCH:	READ <<ID,<<PAGE,OVFPG>>>,<EOL,NX>>
	SKIPA VTAB,[TTOVAR]
RDTTL:	MOVEI VTAB,TTLVAR
	MOVEI T1,%.ITB
RDTTL0:	SKIPE 2(VTAB)
	JRST MULTTL	;MULTIPLE TITLE SPEC
	PUSHJ P,STORE

RDTTL1:	READ <<EOL,RDTTL1>,<ID,<<REVERSE,NX>,<GROUP,TTLGRP>>>>
	READ <<EOL,NX>>
	MOVEI T1,%.TLR
	PUSHJ P,STORE
RDTGRP:	READ <<EOL,RDTGRP>,<ID,<<GROUP,NX>>>,<SPC,<<#,FSTLP1>>>>
TTLGRP:	SETZM LVFLG
	PUSHJ P,DEFNI	;GENERATE FRAMES ETC.

;NOW READ THE FRAME INFORMATION

	SETOM PBKCNT
TTTLN:	READ <<EOL,TTTLN>,<ID,<<TLINE,NX>,<GROUP,FINTL4>>>,<SPC,<<#,FINTL5>>>>
TTTLN0:	READ <<NUM,NX>>
	CAIG T2,5
	CAIGE T2,1
	JRST BADLNN	;WRONG NUMBER
	MOVEM T2,TTLLSV#	;SAVE LINE NUMBER
	SETOM CAT2FG#

TTLTL2:	READ <<EOL,TTLTL2>,<ID,<<SIZE,NX>,<TLINE,FINTL3>,<GROUP,FINTL1>>>,<SPC,<<#,FINTL2>>>>
	SKIPGE CAT2FG
	JRST TTLTL3	;NOTHING SEEN YET
	MOVEI T1,%.FIL	;NEED TO GET THIS ONE TO THE RIGHT SIZE
	PUSHJ P,STORE
	HRRZ T1,TTLSSV	;SIZE DESIRED
	PUSHJ P,STORE
	MOVEI T1,%.CAT
	SKIPLE CAT2FG	;ANYTHING SAVED YET?
	PUSHJ P,STORE	;YES, GENERATE A CAT
	MOVEI T1,%.SAV
	PUSHJ P,STORE	;AND SAVE
TTLTL3:	READ <<NUM,NX>>
	CAIG T2,^D80
	CAIGE T2,1
	JRST BADTSZ	;ILLEGAL SIZE
	MOVEM T2,TTLSSV#
	PUSHJ P,STRNVP	;READ THE STRING
	AOS CAT2FG	;SAY STORED OR AC LOADED OR WHATEVER
	CREAD <<EOL,TTLTL2>,<ID,<<CENTER,TTLCTJ>,<RIGHT,TTLRTJ>>>>

TTLCTJ:	MOVEI T1,%.CTJ
	SKIPA
TTLRTJ:	MOVEI T1,%.RTJ
	PUSHJ P,STORE
	MOVE T1,TTLSSV
	PUSHJ P,STORE
	READ <<EOL,TTLTL2>>

FINTL3:	PUSHJ P,TFNGEN	;SEEN TLINE AGAIN, FINISH UP
	JRST TTTLN0

TFNGEN:	MOVEI T1,%.CAT	;GET SET TO GEN A CONCAT
	SKIPLE CAT2FG	;IF NEEDED
	PUSHJ P,STORE
	MOVEI T1,%.STL
	PUSHJ P,STORE	;STORE THE LINE INFO
	SOS T1,TTLLSV
	JRST STORE

FINTL1:	PUSHJ P,TFNGEN	;SEEN A NEW GROUP STMT
FINTL4:	MOVEI T1,%.TLO	;NEED TO OUTPUT
	PUSHJ P,STORE
	JRST TTLGRP

FINTL2:	PUSHJ P,TFNGEN	;AND A #
FINTL5:	MOVEI T1,%.TLO	;THESE DIFFER ONLY IN WHERE THEY GO
	PUSHJ P,STORE
	JRST FSTLP1

BADCHN:	OUTSTR [ASCIZ /
ILLEGAL NUMBER OF CHARACTERS IN TITLE/]
	JRST SCNER1

BADFMN:	OUTSTR [ASCIZ /
ILLEGAL NUMBER OF FRAMES IN TITLE/]
	JRST SCNER1

BADIPG:	OUTSTR [ASCIZ /
ILLEGAL INDEX ITEM PAGE NUMBER/]
	JRST SCNER1

BADLNN:	OUTSTR [ASCIZ /
ILLEGAL NUMBER OF LINES IN TITLE/]
	JRST SCNER1

BADTSZ:	OUTSTR [ASCIZ /
ILLEGAL FIELD SIZE IN TITLE/]
	JRST SCNER1

MULTTL:	OUTSTR [ASCIZ /
MULTIPLE TITLE DEFINITION/]
	JRST SCNER1

DEFNI:	READ <<EOL,FINDFI>,<SPC,<<],FINDI2>>>,<ID,<
<FRAMES,DFIFRM>,<CHARACTERS,NX>,<LINES,DFINSN>,
<IFDIF,DFIIFD>,<IFEQ,DFIIFE>,<IF,DFIIF>,<IFNO,DFIIFN>>>>
	READ <<NUM,NX>>
	CAIG T2,5
	CAIGE T2,1
	JRST BADCHN
	MOVEI T1,%.TSC	;SET CHRS
COMDFS:	PUSHJ P,STORE
	HRRZ T1,T2
	PUSHJ P,STORE
	JRST DEFNI

DFIFRM:	READ <<NUM,NX>>
	CAIG T2,^D16
	CAIGE T2,0
	JRST BADFMN
	MOVEI T1,%.TSF
	JRST COMDFS

DFINSN:	READ <<NUM,NX>>
	CAIG T2,5
	CAIGE T2,0
	JRST BADLNN
	MOVEI T1,%.TSL
	JRST COMDFS

FINDI2:	SOSL LVFLG
	POPJ P,
	JRST SQBERR

FINDFI:	SKIPE LVFLG
	JRST SQBERR
	POPJ P,

DFIIFE:	PUSHJ P,IFEGEN
	JRST DFIIFC
DFIIFD:	PUSHJ P,IFDGEN
	JRST DFIIFC
DFIIFN:	PUSHJ P,IFNGEN
	JRST DFIIFC
DFIIF:	PUSHJ P,IFGEN
DFIIFC:	PUSHJ P,DEFNI
	PUSHJ P,CLNIF	;GENERATE THE SKIP COUNT FOR THE IF STMT.
	JRST DEFNI	;AND CONTINUE

OVFPG:	READ <<EOL,NX>>
OVFPG1:	READ <<EOL,OVFPG1>,<SPC,<<#,FSTLP1>>>,<ID,<<KEEP,NX>>>>
OVFPG2:	READ <<VAR,NX>>
	MOVSI T1,%V.KPF
	IORM T1,VARTB2(T2)
	READ <<EOL,OVFPG1>,<SPC,<<<<,>>,OVFPG2>>>>

;GET INFORMATION FOR THE INDEX GENERATION

RDIDX:	READ <<EOL,NX>>
	SKIPN IDXPRS	;OR IF HE SAID NO
	SKIPE IDGVAR+2
	JRST MULIDX	;MULTIPLY DEFINEED
	SETZM IDXLEN#	;ACCUMULATES LENGTH OF INDEX BLOCK
	SETZM IDXITN#	;LAS ITEM NUMBER (MUST BE IN ORDER)
	MOVEI VTAB,IDGVAR
	MOVEI T1,%.IDB
	PUSHJ P,STORE

RDIDX1:	READ <<EOL,RDIDX1>,<STR,IDXSTR>,<SPC,<<#,FINIDX>>>,<ID,<<LOCATE,IDXLOC>,<ITEM,IDXITM>,<NONE,IDXNON>,<NO,IDXNCL>,<HEADING,NX>>>>

;HE WANTS A HEADING

	SKIPE IDXTTL
	JRST MULIDX	;MORE THAN ONE
	READ <<STR,NX>>
	MOVEM T2,IDXTTL
IDXEOL:	READ <<EOL,RDIDX1>>

MULIDX:	OUTSTR [ASCIZ /
MULTIPLE INDEX SPECIFICATION/]
	JRST SCNER1

IDXNCL:	READ <<ID,<<CLEAR,NX>>>>
	SETOM IDXCLR
	JRST IDXEOL

IDXNON:	MOVEI VTAB,IDGVAR
	PUSHJ P,INIVAR
	MOVEI VTAB,IDXVAR
	PUSHJ P,INIVAR
	SETO IDXPRS	;NO INDEX INFO
	READ <<EOL,NX>>
	JRST FSTLOP	;WAIT FOR NEW SECTION START

IDXSTR:	MOVEI VTAB,IDGVAR	;GET SET TO GENERATE
	PUSHJ P,IDXLSI	;GENERATE A LOAD STRING IMMEDIATE
	MOVEI T1,%.IDO
	PUSHJ P,STORE
	HLRZ T1,(T2)
	PUSHJ P,STORE
	HLRZ T1,(T2)
	ADDB T1,IDXLEN	;ACCUMULATE LENGTH
	CAIL T1,^D30
	JRST IDXOVF	;TOO BIG
	JRST IDXEOL	;DONE

IDXLSI:	MOVEI T1,%.LSI	;LOAD STRING IMMEDIATE
	PUSHJ P,STORE
	LDB T1,[POINT 7,T2,35]
	PUSHJ P,STORE
	LDB T1,[POINT 7,T2,28]
	PUSHJ P,STORE
	LDB T1,[POINT 7,T2,21]
	JRST STORE	;FINISH STORING ADDRESS INFORMATION

IDXLOC:	MOVEI VTAB,IDGVAR
	MOVEI T1,%.ILC
	PUSHJ P,STORE
	READ <<NUM,NX>>
	HRRZ T1,T2
	PUSHJ P,STORE
	SUBI T2,1	;ONE SMALLER
	CAIGE T1,^D30
	CAMGE T2,IDXLEN	;MUST NO BACK UP
	JRST IDXOVF
	MOVEM T2,IDXLEN	;RESET
	JRST IDXEOL

IDXOVF:	OUTSTR [ASCIZ /
OVERFLOW IN INDEX SPECIFICATION OR INCORRECT LOCATE STATEMENT/]
	JRST SCNER1

IDXITM:	READ <<NUM,NX>>
	CAIG T2,^D10
	CAIG T2,0
	JRST BADINM	;BAD INDEX NUMBER
	SUBI T2,1
	CAMGE T2,IDXITN
	JRST BADINM	;MUST GET PROGRESSIVLY LARGER
	MOVEM T2,IDXITN
	READ <<ID,<<SIZE,NX>>>>
	READ <<NUM,NX>>
	MOVEM T2,IDXSIZ#
	ADDB T2,IDXLEN
	CAILE T2,^D30
	JRST IDXOVF	;OVERFLOW
	MOVEI VTAB,IDGVAR
	MOVEI T1,%.LDI	;LOAD ITEM
	PUSHJ P,STORE
	MOVE T1,IDXITN
	PUSHJ P,STORE
	MOVEI VTAB,IDXVAR	;GET SET TO GEN
	PUSHJ P,STRNVP	;CALL THE GENERAL STRING ROUTINE
	SOSL LVFLG	;CHECK ON IF LEVEL
	JRST SQBERR	;[]'S DO NOT MATCH
	CREAD <<EOL,IDXOUT>,<ID,<<SUPRESS,IDXSUP>,<INDENT,IDXIND>,
<CHANGE,CHGCLI>,<RIGHT,IDXRTJ>,<CENTER,NX>>>>
	MOVEI T1,%.CTJ	;CENTER JUSTIFY
IDXJST:	PUSHJ P,STORE
	MOVE T1,IDXSIZ
	PUSHJ P,STORE
CHGCIC:	READ <<EOL,IDXOUT>,<ID,<<CHANGE,CHGCLI>,<SUPRESS,IDXSUP>,<INDENT,IDXIND>>>>
IDXOUT:	MOVEI VTAB,IDGVAR	;INDEX OUTPUT FOR PRINT
	MOVEI T1,%.IDO
	PUSHJ P,STORE
IDXOT1:	MOVE T1,IDXSIZ
	PUSHJ P,STORE
	MOVEI VTAB,IDXVAR
	MOVEI T1,%.IDS	;STORE
	PUSHJ P,STORE
	MOVE T1,IDXITN
	PUSHJ P,STORE
	JRST RDIDX1	;GO TO NEXT THING

IDXRTJ:	MOVEI T1,%.RTJ
	JRST IDXJST	;COMMON JUSTIFY

FINIDX:	MOVEI VTAB,IDGVAR
	MOVEI T1,%.IDR	;INDEX PREPEAT FOR OUTPUT
	PUSHJ P,STORE
	JRST FSTLP1


BADINM:	OUTSTR [ASCIZ /
BAD ITEM NUMBER IN INDEX/]
	JRST SCNER1

CHGCLI:	READ <<ID,<<CLEAR,NX>>>>
	READ <<ID,<<ITEM,NX>>>>
	READ <<NUM,NX>>
	CAIG T2,^D10
	CAIGE T2,0
	JRST BADINM	;BADD ITEM NUMBER
	MOVEI VTAB,IDGVAR
	MOVEI T1,%.CCL
	PUSHJ P,STORE
	MOVE T1,IDXITN
	PUSHJ P,STORE
	SOS T1,T2
	PUSHJ P,STORE	;SOTRE CHANGE CMND, ITEM TO COMPARE, ITEM TO CLEAR
	JRST CHGCIC	;AND CONTINUE

IDXSUP:	READ <<ID,<<UNCHANGED,NX>>>>
	MOVEI VTAB,IDGVAR
	MOVEI T1,%.IOS	;OUTPUT POSSIBLE SUPRESSED
	PUSHJ P,STORE
	JRST IDXCMP

IDXIND:	READ <<ID,<<UNCHANGED,NX>>>>
	MOVEI T1,%.IOI	;INDENT UNCHANGED
	MOVEI VTAB,IDGVAR
	PUSHJ P,STORE
	READ <<NUM,NX>>
	MOVE T1,T2
	PUSHJ P,STORE
	ADDB T2,IDXLEN	;COUNT INENTATION INTO LENGTH
	CAILE T2,^D30
	JRST IDXOVF	;TOO BIG
IDXCMP:	MOVE T1,IDXITN
	PUSHJ P,STORE	;COMPARE
	READ <<EOL,IDXOT1>>

;HERE IS THE GENEARL STRING ROUTINE

STRNVP:	PUSHJ P,SCAN
STRNVS:	SETZM CATFLG#	;CONCAT NEEDED (NO SCAN IF START HERE)
	SETZM LVFLG#	;LEVEL FLAG
	SKIPA	;SKIP THE SCAN
STRNGV:	PUSHJ P,SCAN
	CREAD <<STR,NX>,<VAR,STNGVR>,<ID,<
<IFEQ,STRIFE>,<IFDIF,STRIFD>,<IF,STRIF>,<IFNO,STRIFN>,<INDEX,STVIDX>>>>
	PUSHJ P,IDXLSI	;GENERATE LOAD STRING IMED
COMRD:	EREAD <<SPC,<<+,STVCAT>,<],FINSQB>>>,<ID,<<DELETE,STVDBL>,<START,STVSBS>>>>
	SKIPE LVFLG
	JRST SQBERR	;SHOULD BE AT MATCHING END
CATGEN:	SKIPN CATFLG	;GEN  A CAT CMD IF NEEDED
	POPJ P,		;NOT NEEDED
	PUSH P,T1
	MOVEI T1,%.CAT
	PUSHJ P,STORE
	POP P,T1
	POPJ P,

STVCAT:	PUSHJ P,CATGEN	;CAT IF NEEDED
	MOVEI T1,%.SAV	;SAVE ACCUM
	PUSHJ P,STORE	;FOR NEXT CAT
	SETOM CATFLG
	JRST STRNGV	;AND GO


STVDBL:	READ <<ID,<<BLANK,NX>>>>
	MOVEI T1,%.DTB	;DELET TRAILING BLANKS
	PUSHJ P,STORE
	JRST COMRD

STNGVR:	SKIPL VARTB2(T2)
	JRST UNDFV
	MOVEI T1,%.LDV
	PUSHJ P,STORE
	HRRZ T1,T2
	PUSHJ P,STORE
	JRST COMRD	;NOT A SUBSTRING OPERATION
STVSBS:	MOVEI T1,%.SUB
	PUSHJ P,STORE
	READ <<NUM,NX>>
	HRRZ T1,T2
	PUSHJ P,STORE
	READ <<ID,<<FOR,NX>>>>
	READ <<NUM,NX>>
	HRRZ T1,T2
	PUSHJ P,STORE
	JRST COMRD

STVIDX:	READ <<ID,<<ITEM,NX>>>>
	READ <<NUM,NX>>
	CAIG T2,^D10
	CAIGE T2,1
	JRST BADINM	;INCORRECT NUMBER
	MOVEM T2,STVIXN#	;SAVE IT
	READ <<ID,<<PAGE,NX>>>>
	READ <<NUM,NX>>
	CAIG T2,^D207
	CAIGE T2,1
	JRST BADIPG
	SUBI T2,^D208
	MOVNS T2	;CONVERT TO INTERNAL (208-EXTERNAL)
	PUSH P,T2	;SAVE IT
	MOVEI T1,%.LPI
	PUSHJ P,STORE
	LDB T1,[POINT 7,(P),28]
	PUSHJ P,STORE	;STORE HIGH ORDER PART OF PAGE
	POP P,T1
	PUSHJ P,STORE	;LOW ORDER PART OF PAGE NUMBER
	SOS T1,STVIXN
	PUSHJ P,STORE
	JRST COMRD

STRIFE:	PUSHJ P,IFEGEN
	JRST STRIFC
STRIFD:	PUSHJ P,IFDGEN
	JRST STRIFC
STRIFN:	PUSHJ P,IFNGEN
	JRST STRIFC
STRIF:	PUSHJ P,IFGEN
STRIFC:	PUSH P,CATFLG
	PUSHJ P,STRNGV
	SKIPN (P)	;IF SAVED CAT FLAG IS 0
	PUSHJ P,CATGEN	;GEN CAT IF NEEDED
	POP P,CATFLG
	PUSHJ P,CLNIF	;FINISH UP IF WITH SKIP COUNT
	JRST COMRD	;CONTINUE

FINSQB:	SOSL LVFLG
	POPJ P,		;OK
SQBERR:	OUTSTR [ASCIZ /
MISMATCH OF []'S IN IF/]
	JRST SCNER1

IFGEN:	SKIPA T1,[%.IF]
IFNGEN:	MOVEI T1,%.IFN
	PUSH P,T1	;SAVE OPERATION
	PUSH P,CATFLG
	PUSH P,LVFLG
	PUSHJ P,STRNVP	;GEN CODE TO GET STRING IN ACCUM
IFGN3:	CREAD <<SPC,<<[,NX>>>>
	POP P,LVFLG
	POP P,CATFLG	;READ TO START REDING BODY
	POP P,T1
	PUSHJ P,STORE	;STORE OPERATION
	PUSHJ P,STORE	;SKIP COUNT WILL GO HERE
	MOVE T1,1(VTAB)	;SAVE COUNT
	EXCH T1,(P)
	PUSH P,(VTAB)	;AND BYTE POINTER
	AOS LVFLG	;ONE LEVEL DEEPER
	JRST (T1)	;RETURN ADDRESS HERE AFTER EXCH

CLNIF:	POP P,T1	;RETURN ADDRESS
	POP P,T2	;BYTE POINTER FOR SKIP COUNT
	EXCH T1,(P)	;NOW T1=OLD COUNT, RETURN ON PDL
	SUB T1,1(VTAB)	;COUNT DIFFERENCE
	DPB T1,T2	;STORE SKIP
	POPJ P,

IFEGEN:	SKIPA T1,[%.IFE]
IFDGEN:	MOVEI T1,%.IFD
	PUSH P,T1	;SAVE OPEARATION AGAIN
	PUSH P,CATFLG
	PUSH P,LVFLG
	PUSHJ P,STRNVP	;JUST LIKE BEFORE
	PUSH P,T1	;WHAT WE HAVE SCANNED
	MOVEI T1,%.SAV
	PUSHJ P,STORE	;GENERATE A SAVE TO SAVE THAT STR
	POP P,T1	;PART OF SCANNED INFO
	PUSHJ P,STRNVS	;ANOTHER STRING, NO INITIAL SCAN
	JRST IFGN3	;AND FINISH AS BEFORE

;SOME MORE SCAN ERROR ROUTINES

MULDEF:	OUTSTR [ASCIZ /
MULTIPLE VARIABLE DEFINITION /]
MULDF1:	MOVE T2,VARTAB(T2)
	PUSHJ P,OUTSIX
	EXIT

BADNUM:	OUTSTR [ASCIZ /
BAD LINE NUMBER IN TEXT SECTION/]
	JRST SCNER1

;HERE TO SELECT A FISH. SELFS1 FOR CONTINUATION

SELFSH:	SETZM BRKFLG#	;NOT BROKEN ACROSS FISH
	SETZM BKEFLG#	;DO NOT DELETE VARIABLES ON BREAK
SELFS1:	MOVEI PAGS,^D207	;NUMBER OF PAGES WE CAN OUTPUT
	SETOM NUMTTL#	;NO FILES YES
	SKIPE IDXPRS
	MOVEI PAGS,^D208	;CAN USE 208 PAGES IF NO INDEX
	SETZM OUTREC#	;NUMBER OF OUTPUT RECORD
	MOVEI T1,TAPSIZ
	MOVEM T1,TAPCNT#	;SET COUNT SO WE KNOW WHATS THERE
	SETZM TOTCRS#	;NO CHRS IN THIS FISH
	MOVEI T1,^D14
	MOVEM T1,FRMCNC#	;TO SKIP THE TITLE PAGES
	SKIPE BRKFLG	;IS THIS A CONTINUATION?
	JRST CNTFIL	;YES
	SKIPE T1,GRPPNT	;ARE WE PROCESSING A GROUP
	JRST SELGRP	;YES
	SKIPN T1,GRPLNK	;IS THERE GROUPING TO DO?
	JRST SELLNK	;NO, GET NEXT FILE FROM LIST
	HRRZM T1,GRPPNT	;SET UP FOR GROUP
	MOVE T2,(T1)
	HRRZM T2,GRPLNK	;ADVANCE POINTER
	JRST SELGRP	;AND GE A FILE

CNTFIL:	MOVE T4,CURFLP	;GET POINTER
	SETOM NUMTTL
	JRST CNTFL2

;SELECT A FILE TO PROCESS

SELFIL:	SKIPN T1,GRPPNT
	JRST SELLNK	;NOT PROCESSING A GROUP, GET FILE FROM LIST
SELGRP:	SKIPN T1,1(T1)	;IS THERE ANOTHER FILE THERE?
	JRST SELGRF	;NO, FINISHED
	AOS GRPPNT
	HRRZ T4,FLINK
	JUMPE T4,SELGRE	;NO FILE THERE, ERROR
SELGRS:	SKIPE USEFIL
	JRST	[CAMN T1,1(T4)	;CHECK FOR FILE NAME
		JRST FNDFIL
		JRST NFDFIL]
	CAMN T1,3(T4)
	JRST FNDFIL	;FOUND ONE
NFDFIL:	HRRZ T4,(T4)
	JUMPN T4,SELGRS

SELGRE:	OUTSTR [ASCIZ /
CAN NOT FIND /]
	MOVE T2,GRPPNT
	MOVE T2,(T2)
	PUSHJ P,OUTSIX
	OUTSTR [ASCIZ /
/]
	JRST SELFIL	;CONTINUE

SELGRF:	SETZM GRPPNT	;OUT OF GROUP
	SKIPE FILOPN
	PUSHJ P,CLSFSH	;IF WE HAVE SOMETHING, CLOSE IT
	JRST SELFSH	;AND GET READY FOR ANOTHER

SELLNK:	HRRZ T4,FLINK
	JUMPN T4,FNDFIL	;GOT IT
	SKIPE FILOPN
	PUSHJ P,CLSFSH
	OUTSTR [ASCIZ /
TOTAL FICHE /]
	MOVE T1,TOTFSH
	PUSHJ P,OUTDEC
	OUTSTR [ASCIZ /
ESTIMATED COST $ /]
	SKIPN DEBFLG
	OUTPUT CMDS,CMDSCM	;CLOSE UP COMMAND FILE
	CLOSE CMDS,
	MOVE T1,COPNUM
	SUBI T1,1
	IMUL T1,TOTFSH	;NUMBER OF COPIES
	IMULI T1,^D200	;20 CENTS/FICHE
	MOVE T2,TOTCST
	IMULI T2,^D15
	ADD T1,T2
	ADDI T1,5
	IDIVI T1,^D10
	IDIVI T1,^D100
	PUSH P,T2
	PUSHJ P,OUTDEC
	OUTCHI "."
	POP P,T1
	CAIGE T1,^D10
	OUTCHI "0"
	PUSHJ P,OUTDEC
	OUTSTR [ASCIZ /
/]
	EXIT

FNDFIL:	MOVEM T4,CURFLP#	;SAVE POINTER
	SKIPN NEDTTL
	JRST FNDFL1	;DO NOT NEED TITLE
	SKIPN 3(T4)
	PUSHJ P,REDTTL	;GET THE TITLE IF NECESSARY
FNDFL1:	DMOVE T1,1(T4)
	DMOVEM T1,FILNM+2
	MOVE T1,UFDNM+2
	MOVEM T1,FILNM+1	;SET PPN
	LOOKUP FIL,FILNM
	 JRST FILDON	;TREAT LIKE END OF FILE
	SETOM PBKCNT#	;NOT A PAGE BREAK
CNTFL2:	MOVE T2,3(T4)
	MOVEI T3,TTLPOS
	HRLI T3,%V.PRS
	MOVEM T3,VARTB2+TTLHLD
	PUSHJ P,GENSIX
	PUSHJ P,DUPSTR
	HRLI T3,%V.PRS
	AOS T1,NUMTTL
	MOVEM ACCUM,VARTB2+TTLBLK(T1)
	MOVE T2,1(T4)	;FILE NAME
	MOVEI T3,FILPOS
	HRLI T3,%V.PRS
	MOVEM T3,VARTB2+FILHLD
	PUSHJ P,GENSIX
	PUSHJ P,DUPSTR
	HRLI T3,%V.PRS
	MOVE T1,NUMTTL
	MOVEM ACCUM,VARTB2+FILBLK(T1)	;FILE NAME GENERATED
	HLLZ T2,2(T4)	;EXTENSION
	MOVEI T3,EXTPOS
	HRLI T3,%V.PRS
	MOVEM T3,VARTB2+EXTHLD
	PUSHJ P,GENSIX	;GENERATE THE STRING
	PUSHJ P,DUPSTR
	HRLI T3,%V.PRS
	MOVE T1,NUMTTL
	MOVEM ACCUM,VARTB2+EXTBLK(T1)
	SKIPN FILOPN
	PUSHJ P,GENOTF
	SETOM FRAMED#	;WE SHOUD SKIP ONE FRAME ADVANCE
	PUSHJ P,CLSFRM	;FINISH PREVIOUS PAGE
	MOVEI VTAB,NFLVAR
	PUSHJ P,VARXCT
	SKIPN BRKFLG
	SETOM STRFIL#	;THIS IS THE START OF A FILE (IGNORE BLANK PAGE)
	JUMPG PAGS,FSHPAG
	JRST NOPGS	;NO ROOM FOR THIS FILE

GENSIX:	HRLI T3,(POINT 7,0,35)
	MOVEI T1,3
	HRLZM T1,(T3)	;SET SIZE
	MOVE ACCUM,T3
GENSX1:	MOVEI T1,0
	LSHC T1,6
	JUMPE T1,GENSXF
	ADDI T1," "
	IDPB T1,T3
	AOS (ACCUM)
	JRST GENSX1
GENSXF:	IDPB T1,T3	;T1 HAS 0
	MOVSS (ACCUM)
	POPJ P,

ARRAY TTLPOS,FILPOS,EXTPOS,LOCPOS[3]

GENOTF:	DATE T2,
	TIMER T1,
	DPB T2,[POINT 14,T1,16]
	SKIPE DEBFLG
	JRST	[MOVE T1,[SIXBIT /FSHDEB/]
		MOVEM T1,FILOPN	;IN EITHER CASE MAKE IT LOOK OPEN
		SKIPL DEBFLG	;IF -1 REALLY OPEN
		POPJ P,
		MOVNS DEBFLG	;SET TO +1 DEBUG FILE OPEN
		MOVEI T2,0
		JRST .+2]
	MOVEI T2,USR
	MOVEM T2,FILONM+1
	MOVSI T2,'MFS'	;GENERATE A TITLE
	DMOVEM T1,FILONM+2
	MOVEM T1,FILOPN	;SAVE NAME
	ENTER TAP,FILONM
	 JRST ENTFL
	OUTPUT TAP,	;DO ONE DUMMY OUTPUT
	HRRZ T1,FILONM+3
	SKIPN DEBFLG	;OLD OK IN DEBUG MODE
	TRNN T1,400000
	POPJ P,	;NEW FILE
	CLOSE TAP,40	;DO NOT OVERWRITE OLD FILE
	JRST GENOTF

FILONM:	3
	USR
	0
	0

ENTFL:	HRRZ T1,FILONM+3
	CAIN T1,3
	JRST GENOTF	;IN USE, TRY ANOTHER
	OUTSTR [ASCIZ /
CAN NOT OPEN SPOOL FILE/]
	EXIT

;READ A CHARACTER
GNCH:	TRNE FL,FR.ATF	;IS THIS AN INDIRECT FILE
	JRST GNCHAT	;YES
	INCHWL C	;JUST READ A CHR
	CAIE C,"@"	;UNLESS ITS AN @
	POPJ P,
	PUSH P,FILNAM
	PUSH P,FILEXT
	PUSH P,FILUSR
	PUSH P,USRNM
	PUSH P,USRNM+1
	PUSH P,T1
	PUSHJ P,NAMSCN	;AND READ A FILE NAME
	 JRST NOCMD1
	PUSHJ P,WTLF
	TRO FL,FR.ATF
	INIT CMD,0
	SIXBIT /DSK/
	CIBUF
	JRST DSKNA
	DMOVE T2,FILNAM
	SKIPN T3
	MOVSI T3,'CMD'
	DMOVEM T2,FILNM+2
	DMOVE T2,USRNM
	DMOVEM T2,USRNMC	;MOVE USER NAME (JUST IN CASE)
	SKIPE T2,FILUSR	;IS THERE ONE FOR THIS USER
	MOVEI T2,USRNMC	;YES, POINT TO THIS USER NAME
	MOVEM T2,FILNM+1
	LOOKUP CMD,FILNM
	 JRST NOCMD
	POP P,T1
	POP P,USRNM+1
	POP P,USRNM
	POP P,FILUSR
	POP P,FILEXT
	POP P,FILNAM
	SETZM ATFLIN#
	SETZM ATFPAG#
GNCHAT:	SOSG CIBUF+2
	IN CMD,
	JRST GNCAT1
	TRZ FL,FR.ATF
	RELEASE CMD,
	JRST GNCH	;READ FROM NEW SOURCE

GNCAT1:	IBP CIBUF+1
	MOVE C,@CIBUF+1
	TRNN C,1
	JRST GNCAT2
	CAMN C,[<ASCII /     />+1]	;PAGE NUMBER?
	JRST	[AOS ATFPAG	;YES, NEW PAGE
		MOVE C,[<ASCII /00000/>+1]
		JRST .+1]
	MOVEM C,ATFLIN
	AOS CIBUF+1	;SKIP LINE NUMBER
	IBP CIBUF+1
	MOVNI C,6
	ADDM C,CIBUF+2
GNCAT2:	LDB C,CIBUF+1
	CAIE C,0
	CAIN C,15
	JRST GNCHAT
	CAIN C,14
	JRST GNCHAT	;IGNORE FORM FEED ALSO
	POPJ P,

NOCMD1:	PUSHJ P,WTLF
NOCMD:	TRZ FL,FR.ATF
	POP P,T1
	POP P,USRNM+1
	POP P,USRNM
	POP P,FILUSR
	POP P,FILEXT
	POP P,FILNAM
	OUTSTR [ASCIZ /
COMMAND FILE NOT AVAILABLE
/]
	RELEASE CMD,
	JRST GNCH

NAMSCN:	CAIGE C,40
	POPJ P,
	PUSHJ P,SCNSPS	;SKIP SPACES
	SETZM FILUSR#	;NO USER NAME
	CAIN C,"("	;IF USER NAME SPECIFIED
	PUSHJ P,RDUID	;READ IT
	MOVE T1,[POINT 6,FILNAM]
	SETZM FILNAM
	PUSHJ P,SCNID	;READ ONE
	SKIPN FILNAM
	POPJ P,		;NOTHING THERE
	SETZM FILEXT
	AOS (P)
	PUSHJ P,SCNSPL
	CAIE C,"."
	POPJ P,	;NO EXTENSION
	MOVEI T1,-1
	MOVEM T1,FILEXT
	MOVE T1,[POINT 6,FILEXT]
	PUSHJ P,SCNIDS
	JRST SCNSPL

SCNID:	CAIE C," "
	JRST SCNID1
SCNIDS:	PUSHJ P,GNCH
	JRST SCNID

SCNID1:	CAIL C,140
	SUBI C,40
	CAIE C,"*"
	CAIN C,"#"
	JRST SCNID2
	CAIG C,"Z"
	CAIGE C,"0"
	POPJ P,
	CAIGE C,"A"
	CAIG C,"9"
	SKIPA
	POPJ P,
SCNID2:	SUBI C,40
	TLNE T1,770000
	IDPB C,T1
	PUSHJ P,GNCH
	JRST SCNID1

SCNSPL:	CAIE C," "
	POPJ P,
SCNSPS:	PUSHJ P,GNCH
	JRST SCNSPL

RDUID:	MOVEI T1,USRNM
	MOVEM T1,FILUSR
	SETZM USRNM
	SETZM USRNM+1
	PUSH P,T2
	MOVEI T2,^D12
	MOVE T1,[POINT 6,USRNM]
RDUID1:	PUSHJ P,GNCH
	CAIN C,")"
	JRST	[POP P,T2
		JRST GNCH]
	CAIGE C,40
	JRST	[POP P,T2
		POPJ P,]
	SOJL T2,RDUID1
	CAIL C,140
	TRZA C,100
	SUBI C,40	;CONVERT TO SIXBIT CHR
	IDPB C,T1	;AND STORE
	JRST RDUID1

WTLF:	CAIN C,12
	POPJ P,
	PUSHJ P,GNCH
	JRST WTLF

NUMRD:	MOVEI C," "
	MOVEI T1,0
	PUSHJ P,SCNSPL	;GET TO THE FIRST NON-BLANK
RDNM1:	CAIG C,"9"
	CAIGE C,"0"
	JRST WTLF
	IMULI T1,^D10
	ADDI T1,-"0"(C)
	PUSHJ P,GNCH
	JRST RDNM1


CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,

GETLNK:	MOVEI T4,10	;GET 10 WORDS
	ADDB T4,JOBFF
	CAMG T4,JOBREL
	JRST GETLK2	;IT WILL FIT
	IORI T4,1777
	CORE T4,
	 JRST NOCOR	;IT WILL NOT FIT
	MOVE T4,JOBFF
GETLK2:	SUBI T4,10
	POPJ P,

MAKMSK:	CAMN T1,[SIXBIT /*/]
	JRST	[TRO FL,FR.WLD	;SET FOR WILD CARD
		MOVEI T1,0	;ANYTHING IS OK THERE
		MOVNI T2,1
		POPJ P,]
	MOVEI T2,0	;NO MAKS FOR NOW
	MOVSI T3,770000	;ONE CHR MASK
	PUSH P,T1
	XOR T1,[SIXBIT /######/]	;SEE WHERE THE #'S ARE
MAKMS1:	TDNE T1,T3
	JRST MAKMS2	;NOT A #
	TRO FL,FR.WLD	;WILD CARD
	IOR T2,T3	;SET IN MASK
	ANDCAM T3,(P)	;AND CLEAR THE # FROM WORD
MAKMS2:	LSH T3,-6
	JUMPN T3,MAKMS1
	POP P,T1
	POPJ P,

RDUFD:	SOSL	T1,UFDCCN	;GET CURRENT COUNT, DECREMENT
	JRST	HAVSWT		;WAS SOMETHING LEFT
	MOVE	T1,[33,,UFD]	;NOTHING LEFT, GET MORE
	CHANIO	T1,UFDCIO	;DATA
	  POPJ	P,		;SORRY, NONE LEFT
	JRST	RDUFD		;GO SEE IF THERE'S REALLY ANY THERE
HAVSWT:	ASH	T1,1		;TWO WORDS PER ENTRY
	DMOVE	T1,UFDDAT(T1)	;GET NAME IN T1, EXT IN T2
	JRST	CPOPJ1		;AND GIVE SKIP RETURN

UFDCIO:	-UFDBLN,,UFDDAT		;-LENGTH OF UFD DATA,,ADDRESS OF BUFFER
	SIXBIT /*/		;LOOK FOR ANY FILE
	SIXBIT /*/
UFDCCL:				;FIRST LOCATION TO CLEAR ON INIT
UFDCCT:	BLOCK	1		;CONTROL BITS
UFDCMW:	BLOCK	1		;MONITOR WORD
UFDCSN:	BLOCK	1		;STARTING NAME
UFDCSE:	BLOCK	1		;STARTING EXTENSION
UFDCCN:	BLOCK	1		;COUNT OF ENTRIES RETURNED

	UFDCLS==.-1		;LAST LOCATION TO CLEAR ON INIT

TRNSET:
;;;	Translation table indexed by 7-bit ASCII code
;;;		[initial values]
;;;	entries are 1 of two flavors:
;;;	1) normal contains the 8-bit extended fiche printer code
;;;	   to use for the corresponding ASCII character
;;;	2) same as (1) except that the sign bit (B0) is turned on
;;;	   which means that this translation should be complained
;;;	   about when first encountered, (the bit is then cleared
;;;	   and the entry becomes a type 1 entry).
;;;

;;;FOR (I,0,6,<1B0+200+"#">)	157
;null	darrow	alpha	beta	AND	NOT	epsilon	pi
	1B0+000				;NUL 00 (use black box)
	1B0+202				;SOH 01 (use down arrow)
	1B0+100				;STX 02 (use alpha)
	1B0+101				;ETX 03 (use beta)
	1B0+007				;EOT 04 (use and?)
	1B0+156				;ENQ 05 (use not)
	1B0+104				;ACK 06 (use epsilon)
	1B0+110				;BEL 07 (use pi)

;;;FOR (I,10,11,<1B0+200+"#">)	215	FOR (I,13,17,<1B0+200+"#">)
;lambda	tab	lf	vt	ff	cr	inf	lsigma
	1B0+106				;BS  10 (use lambda)
	1B0+141				;TAB 11 (use therefore dots)
	    215				;LF  12 (uses record mark *)
	1B0+112				;VT  13 (use psi)
	1B0+213				;FF  14 (use english pound)
	1B0+207				;CR  15 (use C/R)
	1B0+151				;SO  16 (use infinity)
	1B0+147				;SI  17 (use partial)

;;;FOR (I,20,27,<1B0+200+"#">)
;setopn	setcls	INTER	UNION	forany	exists	XOR	SWAP
	1B0+161				;DLE 20 (use 2-rail fence)
	1B0+162				;DC1 21 (use 3-rail fence)
	1B0+132				;DC2 22 (use -/o)
	1B0+131				;DC3 23 (use +/o)
	1B0+115				;DC4 24 (use angstrom)
	1B0+114				;NAK 25 (use A|E)
	1B0+153				;SYN 26 (use target)
	1B0+017				;ETB 27 (use section)

;;;FOR (I,30,37,<1B0+200+"#">)
;under*	rarrow	tilde*	neq	leq	geq	EQV	OR
	1B0+337				;CAN 30 (use underline)
	1B0+203				;EM  31 (use right arrow)
	1B0+377				;SUB 32 (use backwards tilde)
	1B0+134				;ESC 33 (use not equal)
	1B0+135				;FS  34 (use less or equal)
	1B0+136				;GS  35 (use greater or equal)
	1B0+137				;RS  36 (use congruent)
	1B0+102				;US  37 (use gamma)


;and now all printing characters (up to rubout='177)
	FOR (I,40,57,<I+200>)		;	 (" " through "/")
	    116				;"0" 060 (uses slashed 0*)
	FOR (I,61,135,<I+200>)		;	 ("1" through "]")
	    201				;"^" 136 (uses up arrow*)
	    204				;"_" 137 (uses back arrow*)

	FOR (I,140,176,200+I)		;	 ("`" through "~")
	1B0+167				;DEL 177 (use open box)

;GET CHR FROM INPUT FILE

RDFIL:	SKIPL PBKCNT
	JRST	[SOSGE PBKCNT
		SKIPA C,PBKCHR	;GET CHR
		MOVEI C,12	;ELSE FORCE LF
		JRST CPOPJ1]
	SOSG FILBF+2
	IN FIL,0
	JRST RDFIL2
	STATZ FIL,20000
	POPJ P,		;EOF
	OUTSTR [ASCIZ /
ERROR READING FILE /]
	PUSHJ P,PRTNAM
	OUTSTR [ASCIZ / ERROR IGNORED
/]
	SETSTS FIL,0	;CLEAR ERROR BITS
RDFIL2:	ILDB C,FILBF+1
	JUMPE C,RDFIL	;IGNORE NULLS
	CAIN C,15	;AND RETURNS
	JRST RDFIL
	JRST CPOPJ1

TAPOU3:	ADDI LPOS,1
	SKIPE DEBFLG
	POPJ P,
TAPOU7:	CAIN C," "
	JRST TAPSPS	;COMPRESS ENDING SPACES
	SKIPE SPCCNT
	JRST TAPSP2
TAPOU8:	CAIN C,12
	JRST TAPCR	;ALL THIS SO WE CAN SKIP BLANK LINES
	SKIPE TAPCRC
	JRST TAPC42	;MAKE UP SOME BLANK LINES
TAPCR1:	SKIPN TAPFRM	;DO WE NEED FORMAT CONTROL?
	JRST TAPCR4	;YES
TAPCR5:	PUSH P,T2
	SKIPE DEBFLG
	JRST	[MOVE T2,C
		CAIE C,12
		JRST TAPOUA	;GO
		MOVEI T2,15
		PUSHJ P,TAPOUB
		MOVEI T2,12
		JRST TAPOUA]	;DO RIGHT THING WITH RETURN
	skipge xlatf	;check whether translation desired..
	 jrst [move t2,c		;nope, put out pure ascii
		jrst tapou1]
	SKIPGE T2,TRNSTB(C)	;TRANSLATE CHR
	 jrst [OUTSTR [ASCIZ /
UNTRANSLATABLE CHARACTER /]
		PUSH P,T1
		MOVE T1,C
		PUSHJ P,OUTOCT
		OUTSTR [ASCIZ / IN FILE /]
		PUSHJ P,PRTNAM
		OUTSTR [ASCIZ /  [USING /]
		HRRZ	T1,TRNSTB(C)
		PUSHJ	P,OUTOCT
		OUTSTR [ASCIZ / FROM NOW ON]
/]
		POP P,T1
		HRRZS	T2,TRNSTB(C)
		JRST TAPOU1]
TAPOU1:	SOSGE TAPCNT
	JRST BADBUF	;LOSE IF RECORD TOO LARGE
TAPOUA:	SOSL TAPBF+2
	JRST TAPOU0	;JUST OUTPUT CHR (OUTPUT DONE FIRST
	AOS OUTREC
	OUT TAP,
	JRST TAPOUA	;OUTPUT AND COUNT NOW
OUTERR:	OUTSTR [ASCIZ /
OUTPUT ERROR/]
ABTOUT:	CLOSE TAP,40	;DO NOT WRITE IT
	OUTSTR [ASCIZ /, FILE /]
	PUSHJ P,PRTNAM
	EXIT
TAPOU0:	IDPB T2,TAPBF+1
	POP P,T2
	POPJ P,


BADBUF:	OUTSTR [ASCIZ /
TAPE BUFFER TOO SMALL/]
	JRST ABTOUT

FILBKP:	AOS FILBF+2		;COMPENSATE FOR EXTRA READ
	SOS FILBF+1		;BACK UP A FULL WORD
	REPEAT 4,<IBP FILBF+1>	;AND FORWARD 4 CHRS
	POPJ P,

TAPOUC:	SKIPE DEBFLG
	POPJ P,
TAPOUB:	PUSH P,T2
	JRST TAPOUA

TAPOU2:	SKIPN DEBFLG
	JRST TAPOU8
	POPJ P,

TAPCR:	SKIPE TAPFRM	;IS THIS JUST NORMAL FORMAT AND NOT OUTPUT?
	JRST TAPCR5	;NO, REALLY PUT OUT THE CR
	AOS TAPCRC	;YES COUNT
	POPJ P,

TAPC42:	PUSH P,C	;SAVE CHR
TAPCR3:	MOVEI C," "
	PUSHJ P,TAPCR5	;PUT OUT SOME BLANK LINES
	PUSHJ P,TAPCR5
	MOVEI C,12
	PUSHJ P,TAPCR5
	SOSLE TAPCRC
	JRST TAPCR3
	SETZM TAPCRC	;JUST TO MAKE SURE
	POP P,C
	JRST TAPCR1	;AND CONTINUE

TAPCR4:	SKIPE DEBFLG
	JRST TAPCR6
	PUSH P,C	;WE NEED STANDARD FORMAT CONTROL
	MOVEI C," "
	PUSHJ P,TAPCR5
	PUSHJ P,TAPCR5
	POP P,C
TAPCR6:	SETOM TAPFRM	;ITS OUT NOW
	JRST TAPCR5

TAPSPS:	AOS SPCCNT
	POPJ P,

TAPSP2:	CAIN C,12
	JRST TAPSP3	;JUST ONES AT END OF LINE TO DELETE
	PUSH P,C	;SAV CHR
	MOVEI C," "
	PUSHJ P,TAPOU8
	SOSLE SPCCNT
	JRST .-2	;PUT OUT REQUIRED NUMBER OF SPACE
	POP P,C
TAPSP3:	SETZM SPCCNT
	JRST TAPOU8	;NOW PUT OUT THE CHR

FSHPAG:	SETOM RCDLIN#	;HERE TO DO ONE PAGE OF STUFF
	PUSHJ P,SETLOC
NXTLNP:	MOVEI LPOS,1	;START HERE
	SETZM SPCCNT#	;SPACE SUPRESS COUNT
	SETOM FLASH#	;NEED A FORM FLASH
	PUSHJ P,RDFIL
	 JRST FILDON	;EOF
	CAIN C,14
	JRST FPDON	;END OF PAGE
	SETZM STRFIL	;NOT THE START OF A FILE ANY MORE
NXTL1:	AOS T1,RCDLIN
	CAIL T1,LNSPAG
	JRST FPBRK	;EXCEEDING LINES PER PAGE
	MOVE T4,LINTAB(T1)
	PUSHJ P,INILIN	;INITIALIZE CO-ROUTINE STRUCTURE
COPLIN:	CAIN C,11	
	JRST COPTAB	;WORRY ABOUT TAB
COPLN3:	PUSHJ P,[POPJ CP,]	;CALL IT
	CAIN C,12
	JRST NXTLNP	;FINISHED THIS LINE
	PUSHJ P,RDFIL
	 JRST FRCEOF
	CAIN C,14
	JRST FRCPAG
	JRST COPLIN

FRCEOF:	MOVEI C,12
	PUSHJ P,[POPJ CP,]
	JRST FILDON

FRCPAG:	MOVEI C,12
	PUSHJ P,[POPJ CP,]
	JRST FPDON

COPTAB:	MOVEI C," "
	TRNN LPOS,7	;SEE IF NEXT POS IS A TAB STOP
	JRST COPLN3	;YES, JUST TREAT TAB AS SPACE
	PUSHJ P,[POPJ CP,]	;CALL
	JRST COPTAB	;AND DO MORE

FPBRK:	MOVEM C,PBKCHR#
	MOVSI T1,%V.KPO
	PUSHJ P,CLSPAG	;FINISH UP A PAGE
	MOVE T1,OVFBLK
	MOVEM T1,PBKCNT
	SOJG PAGS,FSHPAG
	JRST NOPGS	;JUST RAN OUT

;CLOSE OUT A PAGE

CLSPAG:	PUSH P,T1	;SAVE CALL
	MOVEI VTAB,VARVAR
	PUSHJ P,VARXCT
	MOVEI VTAB,IDXVAR
	PUSHJ P,VARXCT
	MOVE T2,VARTB2+OUTVNM
	TLNE T2,%V.PRS
	PUSHJ P,DMPOST
PAGCL2:	MOVSI T1,-VVNUM
PAGCLR:	MOVE T2,VARTB2(T1)
	TLZE T2,%V.PRS
	TDNE T2,(P)
	SKIPA
	PUSHJ P,CLRVAR
	AOBJN T1,PAGCLR
	POP P,T1
	POPJ P,

PAGCL1:	PUSH P,T1
	JRST PAGCL2	;SKIP ACTION STUFF

SETLOC:	MOVE T1,[4,,3]
	MOVEM T1,LOCPOS	;SET UP CELL
	MOVE T1,[ASCII /    /]
	MOVEM T1,LOCPOS+1
	MOVEI T1,^D207
	SUB T1,PAGS
	IDIVI T1,^D13
	ADDI T2,"B"
	DPB T2,[POINT 7,LOCPOS+1,6]
	ADDI T1,1
	IDIVI T1,^D10
	JUMPE T1,LOCST2
	ADDI T1,"0"
	DPB T1,[POINT 7,LOCPOS+1,20]
LOCST2:	ADDI T2,"0"
	DPB T2,[POINT 7,LOCPOS+1,27]
	MOVE T1,[%V.PRS,,LOCPOS]
	MOVEM T1,VARTB2+LOCHLD
	POPJ P,

DMPOST:	SKIPE DMOOPN
	JRST DMPOS2	;ALREADY OPEN
	INIT OFLD,1
	SIXBIT /DSK/
	DMOBUF,,0
	JRST DSKNA
	ENTER OFLD,DMONAM
	 JRST NOOFL	;CAN NOT ENTER
	SETOM DMOOPN
DMPOS2:	HRLI T2,(POINT 7,0)
	ADDI T2,1	;POINT TO WORD WITH TEXT
DMPOS3:	ILDB T1,T2
	JUMPE T1,DMPOS4	;FINISH UP
	PUSHJ P,DMOCHR
	JRST DMPOS3

DMPOS4:	MOVEI T1,15
	PUSHJ P,DMOCHR
	MOVEI T1,12
DMOCHR:	SOSG DMOBUF+2
	OUTPUT OFLD,
	IDPB T1,DMOBUF+1
	POPJ P,

DMONAM:	3
	0
	SIXBIT /FSHDMP/
	SIXBIT /MFS/

VARXCT:	ADDI VTAB,2
	HRLI VTAB,(POINT 7,0)	;GENERATE BYTE POINTER
VARXEC:	ILDB T1,VTAB
	XCT .+1(T1)
	PHASE 0
%.STP:!	POPJ P,
%.LDV:!	JRST LDVAR	;LOAD VARIABLE
%.STR:!	JRST STRVAR	;STORE VARIABLE
%.SUB:!	JRST SUBSTR	;SUBSTRING OPERATION
%.LSI:!	JRST LSIXCT	;LOAD STRING IMMEDIATE
%.CAT:!	JRST CATXCT	;CONCAT
%.IF:!	JRST IFXCT	;IF
%.IFN:!	JRST IFNXCT	;IF NOT
%.LDI:!	JRST LDIXCT	;LOAD INDEX ITEM
%.RTJ:!	JRST RTJXCT	;RIGHT JUSTIFY
%.CTJ:!	JRST CTJXCT	;CENTER JUSTIFY
%.IDS:!	JRST IDSXCT	;IDNEX STORE
%.SAV:!	JRST SAVXCT	;SAVE ACCUM (FOR CAT)
%.IDB:!	JRST IDBXCT	;START OF INDEX GENERATION
%.IDO:!	JRST IDOXCT	;OUTPUT ACCUM TO INDEX
%.IDR:!	JRST IDRXCT	;INDEX REPEAT
%.ILC:!	JRST ILCXCT	;LOCATE
%.IOI:!	JRST IOIXCT	;INDENT UNCHANGED
%.IOS:!	JRST IOSXCT	;SUPRESS UNCHANGED
%.ITB:!	JRST ITBXCT	;INITIALIZE TITLE LARGE (HEADING)
%.TLR:!	JRST TLRXCT	;REVERSE TITLE (BLACK ON WHITE)
%.TLO:!	JRST TLOXCT	;DO THE TITLE OUTPUT
%.TSC:!	JRST TSCXCT	;SET NUMBER OF CHRS/FRAME
%.TSF:!	JRST TSFXCT	;SET NUMBER OF FRAMES IN GROUP
%.TSL:!	JRST TSLXCT	;SET NUMBER OF LINES IN GROUP
%.ITS:!	JRST ITSXCT	;INITIALIZE TITLE SMALL (INSIDE PAGE)
%.STL:!	JRST STLXCT	;STORE LINE OF TITLE INFO
%.FIL:!	JRST FILXCT	;MAKE TITLE STRING HAVE RIGHT NUMBER OF CHRS
%.UNT:!	JRST UNTXCT	;USE NORMAL TITLE (FOR TTOVAR IF EMPTY)
%.IFE:!	JRST IFEXCT	;IF STRINGS ARE THE SAME DO
%.IFD:!	JRST IFDXCT	;IF STRINGS ARE DIFFERENT DO
%.LPI:!	JRST LPIXCT	;LOAD INDEX VARIABLE FOR SPECIFIED PAGE
%.CCL:	JRST CCLXCT	;CLEAR ITEM ON OTHER ITEM CHANGE
%.DTB:	JRST DELTRB	;DELETE TRAILING BLANKS FROM ACUM
	DEPHASE

ITSXCT:	MOVEI T1,^D132
	MOVNI T2,1
	JRST ITBXC1
ITBXCT:	MOVEI T1,^D144	;LARGE TITLE SIZE
	MOVEI T2,^D16
ITBXC1:	MOVEM T2,REMFRM#	;NUMBER OF FRAMES LEFT
	MOVEM T1,TFMPOS#
	MOVEI T1," "
	MOVEI T2,"X"
	DMOVEM T1,TTLSP	;SAVE FOR NORMAL OR REVERSE TITLES
	MOVEI T1,1
	MOVEM T1,NUMFRM#	;1 FRAM (DEFAULTS)
	MOVEI T1,7
	MOVEM T1,HMLT#	;HORIZONTAL MULT=7 (3 CHRS)
	MOVEI T1,^D10
	MOVEM T1,CHRSPC#	;SPACEING 10
	MOVEI T1,3
	MOVEM T1,TTLCRS#
	MOVEI T1,1
	MOVEM T1,NTLNS#	;1 LINE
	MOVEI T1,6
	MOVEM T1,VMLT#
	SETZM TLNSAV	;CLEAR LINE SAVE FLAGS
	MOVE T1,[TLNSAV,,TLNSAV+1]
	BLT T1,TLNSAV+4
	JRST VARXEC

ARRAY TTLSP[2],TLNSAV,PTRTTB[5]

TSLXCT:	ILDB T1,VTAB	;NUMBER OF LINES/FRAME
	MOVEM T1,NTLNS
	MOVE T1,VSPTAB(T1)	;ALSO SET VERTICAL REPEAT
	MOVEM T1,VMLT
	JRST VARXEC

VSPTAB:	DEC 6,6,3,2,1,1

TSCXCT:	ILDB T1,VTAB	;NUMBER OF CHRS/FRAME
	MOVEM T1,TTLCRS
	MOVE T2,CSPCHR(T1)	;SET SPACING
	MOVEM T2,CHRSPC
	MOVE T2,HSPTAB(T1)
	MOVEM T2,HMLT	;AND MULTIPLIER
	JRST VARXEC

CSPCHR:	DEC 27,27,15,10,8,5
HSPTAB:	DEC 23,23,11,7,5,4

TSFXCT:	ILDB T1,VTAB	;SET NUMBER OF FRAMES IN GROUP
	MOVEM T1,NUMFRM
	JRST VARXEC

TLRXCT:	MOVEI T1,"X"
	MOVEI T2," "
	DMOVEM T1,TTLSP
	JRST VARXEC	;SET FOR REVERSE TITLING

UNTXCT:	MOVEI VTAB,TTLVAR	;IN TTOVAR IF EMPTY, USE TTLVAR
	JRST VARXCT

FILXCT:	ILDB T4,VTAB	;GET DESIRED SIZE
	MOVE T1,T4
	PUSHJ P,GETSWD
	HRLM T4,(T3)	;GET STRING SPACE FOR THAT MANY
	TLNN ACCUM,%V.PRS
	JRST GENSPS	;ITS NOT THERE, JUST GEN SPACES
	HLRZ T1,(ACCUM)	;GET SIZE OF STRING
	CAMN T1,T4	;SAME?
	JRST	[MOVE T2,T3
		PUSHJ P,GIVSTR	;GET RID OF THE SPACE WE GOT
		JRST VARXEC]	;AND FINISH UP
	CAML T1,T4
	JRST FILSUB	;NEED A SUBSTRING TYPE OPERATION
	SUB T4,T1	;THIS IS THE NUMBER OF SPACES NEEDED
	PUSH P,T3	;SAVE POINTER TO NEW SPACE
	PUSH P,T4	;SAVE NUMBER OF SPACES NEEDED
	MOVEI T1,1(ACCUM)
	PUSHJ P,TRNST1	;MOVE THE STRING
	POP P,T4
	MOVEI T1,STRBLK	;ALSO THE SPACES
	PUSHJ P,TRNST0
FILFN1:	MOVEI T2,0
	IDPB T2,T3	;MAKE SURE OF TERMINATION
	MOVE T2,ACCUM
	TLNN T2,%V.DUP	;ITS A DUP, DON'T GIVE BACK
	PUSHJ P,GIVSTR
FILFIN:	POP P,ACCUM
	HRLI ACCUM,%V.PRS
	JRST VARXEC

GENSPS:	PUSH P,T3
	MOVEI T1,STRBLK
	PUSHJ P,TRNST3
	JRST FILFIN	;FINISH UP

FILSUB:	PUSH P,T3
	MOVEI T1,1(ACCUM)
	PUSHJ P,TRNST3	;MOVE DESIRED CHRS
	JRST FILFN1

STLXCT:	ILDB T4,VTAB
	MOVE T2,TLNSAV(T4)
	TLNE T2,%V.PRS
	PUSHJ P,GIVSTR
	TLNE ACCUM,%V.DUP	;IS IT A DUP?
	PUSHJ P,DUPSTR	;YES, COPY IT
	MOVEM ACCUM,TLNSAV(T4)
	JRST VARXEC

LPIXCT:	PUSH P,PAGS
	ILDB T1,VTAB	;HIGH ORDER PART OF PAGE NUMBER
	ILDB PAGS,VTAB
	DPB T1,[POINT 7,PAGS,28]	;STORE IN PAGE REGISTER
	ILDB T1,VTAB
	MOVE ACCUM,@IDXPNT(T1)	;LOAD INDEX
	TLNE ACCUM,%V.PRS
	TLO ACCUM,%V.DUP
	POP P,PAGS
	JRST VARXEC

TLOXCT:	SKIPN NUMFRM
	JRST TLOCLN	;NOTHING TO PUT OUT, JUST CLEAN UP
	MOVSI T4,-5
TLOPTS:	MOVE T1,TLNSAV(T4)	;GET POINTER
	TLNN T1,%V.PRS
	TDZA T1,T1	;IF NOTHING THERE SET TO 0
	HRLI T1,(POINT 7,0,6)	;ELSE SET BYTE POINTER
	ADDI T1,1	;SIZE FIELD WILL BE ZERO IF ABSENT
	MOVEM T1,PTRTTB(T4)
	AOBJN T4,TLOPTS
	MOVE T1,NUMFRM
	MOVEM T1,NUMFRH#	;SET NUMBER OF FRAMES
TLOPT1:	SKIPN REMFRM
	JRST FRMERR	;OUTPUT TOO MANY FRAMES
	PUSHJ P,TTLCNT
	SKIPG REMFRM
	JRST	[PUSHJ P,CLSFRM	;INTERNAL TITLE FRAME
		SKIPE DEBFLG
		PUSHJ P,TAPCFR	;GET A FORM FEED GENERATED
		SOJLE PAGS,TLOCLN
		JRST TLOPT2]
	SETZM TAPCRC#	;NO SAVE BLANK LINES
	SETOM TAPFRM#	;AND NO STARDARD CONTROL NEEDED
	MOVEI C,"A"
	PUSHJ P,TAPOU2
	MOVEI C,"X"
	SOSG REMFRM	;EXCEPT FOR LAST
	MOVEI C,"W"
	PUSHJ P,TAPOU2
	PUSHJ P,TAPCFR
TLOPT2:	SOSLE NUMFRH
	JRST TLOPT1
TLOCLN:	MOVSI T4,-5
TLOCL1:	MOVEI T2,0
	EXCH T2,TLNSAV(T4)
	TLNE T2,%V.PRS
	PUSHJ P,GIVSTR
	AOBJN T4,TLOCL1
	JRST VARXEC

FRMERR:	OUTSTR [ASCIZ /
INCORRECT NUMBER OF TITLE FRAMES/]
	JRST ABTOUT

IDBXCT:	SETOM IDXRLN#	;THIS IS THE LINE POSITION
	SETOM IDXFST#	;THE FIRST LINE, NO SPACE
	MOVEM VTAB,IDBVTB#	;SAVE POINTER FOR REPEAT
	MOVEI PAGS,^D207
	PUSHJ P,SAVCLR	;CLEAR SAVED INDEX INFORMATION
	SKIPN IDXTTL
	JRST IDXNOH
	MOVEI T1,4
	MOVEM T1,LCNT#
IDXHDO:	MOVEI T4,^D32
	SETZM IDXLEN
	MOVE ACCUM,IDXTTL
	PUSHJ P,IDXASC
	MOVEI T4,^D32
	SUB T4,IDXLEN
	JUMPE T4,IDXHO1
	MOVEI ACCUM,STRBLK-1
	PUSHJ P,IDXASC
IDXHO1:	SOSLE LCNT
	JRST IDXHDO
IDXNOH:	MOVEI C,12
	PUSHJ P,IDXWRT
IDX10L:	MOVEI T1,^D10
	MOVEM T1,LCNT
	SKIPN IDXCLR
	PUSHJ P,SAVCLR
	MOVEI C,12
	PUSHJ P,IDXWRT
IDX1L:	SETZM IDXLEN
	MOVEI T1,4
	MOVEM T1,ITMCNT#	;SAVE POSITION ON LINE
	JRST VARXEC	;CONTINUE WITH EXECUTION

;HERE IS THE REPEAT POINT

IDRXCT:	MOVEI T4,^D32
	SUB T4,IDXLEN
	JUMPLE T4,IDRXC1
	MOVEI C," "
	PUSHJ P,IDXWRT
	SOJG T4,.-1
IDRXC1:	SETZM IDXLEN
	MOVE VTAB,IDBVTB
	SUBI PAGS,^D52
	SOSLE ITMCNT
	JRST	[JUMPLE PAGS,IDRXCT	;DO NOT DO NEG ONES
		JRST VARXEC]
	ADDI PAGS,^D208	;COMPENSATE FOR SUBTRACT
	MOVEI T3,4
IDXCOP:	MOVEI T4,^D9
	JUMPLE PAGS,IDXCP7
	MOVE T1,@IDXPNT(T4)
	MOVEM T1,@IDXSPT-1(T3)
	SOJGE T4,.-2
IDXCP7:	SUBI PAGS,^D52	;COPY ITEMS TO SAVE LOCS
	SOJG T3,IDXCOP
	MOVEI C,12
	PUSHJ P,IDXWRT
	ADDI PAGS,^D207
	CAIG PAGS,^D155
	POPJ P,
	SOSLE LCNT
	JRST IDX1L
	JRST IDX10L

IDOXCT:	ILDB T4,VTAB
	TLNN ACCUM,%V.PRS
	JRST IDOXC1	;JUST SPACES
	HLRZ T1,(ACCUM)
	CAMLE T4,T1
	MOVE T4,T1
	PUSHJ P,IDXASC
	LDB T4,VTAB
	HLRZ T1,(ACCUM)
	SUB T4,T1
	JUMPLE T4,VARXEC
IDOXC1:	MOVEI ACCUM,STRBLK-1
	PUSHJ P,IDXASC
	JRST VARXEC

IDXASC:	MOVEI T1,1(ACCUM)
	HRLI T1,(POINT 7,0)
IDXST1:	ILDB C,T1
	JUMPE C,CPOPJ
	PUSHJ P,IDXWRT
	SOJG T4,IDXST1
	POPJ P,

IOSXCT:	ILDB T4,VTAB	;GET THE ITEM NUMBER TO COMPARE
	MOVE T3,ITMCNT
	MOVE T4,@IDXSPT-1(T3)
	PUSHJ P,IDXCPR
	 MOVEI ACCUM,0	;THEY MATCH
	JRST IDOXCT

IDXCPR:	TLNN ACCUM,%V.PRS
	JRST IDXCP1	;NO ACCUM
	TLNN T4,%V.PRS
	JRST CPOPJ1	;CAN NOT MATCH
	HLRZ T3,(T4)
	HLRZ T2,(ACCUM)
	CAME T2,T3
	JRST CPOPJ1	;THEY DO NOT MATCH
	MOVEI T1,1(T4)
	HRLI T1,(POINT 7,0)
	MOVEI T2,1(ACCUM)
	HRLI T2,(POINT 7,0)
IDXCP2:	ILDB T3,T1
	ILDB T4,T2
	CAME T3,T4
	JRST CPOPJ1	;NO MATCH
	JUMPN T3,IDXCP2
	POPJ P,	;END OF STRING AND MATCH

IDXCP1:	TLNE T4,%V.PRS
	AOS (P)		;NO ACCUM BUT SAVE CELL
	POPJ P,		;OR BOTH MISSING

IOIXCT:	ILDB T4,VTAB
	MOVE T3,ITMCNT
	MOVE T4,@IDXSPT-1(T3)
	PUSHJ P,IDXCPR
	 SKIPA
	JRST	[IBP VTAB
		JRST IDOXCT]
	ILDB T4,VTAB	;SPACES TO SKIP
	PUSH P,ACCUM
	MOVEI ACCUM,STRBLK-1
	PUSHJ P,IDXASC
	POP P,ACCUM
	JRST IDOXCT

ILCXCT:	ILDB T4,VTAB
	SUBI T4,1
	SUB T4,IDXLEN
	JUMPLE T4,VARXEC
	MOVEI ACCUM,STRBLK-1
	PUSHJ P,IDXASC
	JRST VARXEC	;GET TO A CERTAIN POSITION

	ARRAY IDXSAV[^D<10*4>]
IDXSPT:	FOR (I,0,3,<IDXSAV+I*^D10(T4)>)

SAVCLR:	SETZM IDXSAV
	MOVE T1,[IDXSAV,,IDXSAV+1]
	BLT T1,IDXSAV+^D39
	POPJ P,

DELTRB:	TLNN ACCUM,%V.PRS
	JRST VARXEC		;NOTHING THERE
	HLRZ T4,(ACCUM)	;NUMBER OF CHRS
	MOVEI T3,1(ACCUM)
	HRLI T3,(POINT 7,0)
	MOVE T1,T4	;FIRST NON-BLANK CHARACTER
DELTR1:	SOJL T4,DELTR2
	ILDB T2,T3
	JUMPE T2,DELTR2
	CAIE T2," "
	MOVE T1,T4
	JRST DELTR1

DELTR2:	JUMPE T1,VARXEC	;ENTIRE STRING
	HLRZ T4,(ACCUM)
	SUBB T4,T1	;THIS IS THE NUMBER OF CHRS
	PUSH P,T1
	PUSHJ P,GETSWD
	POP P,T4
	HRLM T4,(T3)
	MOVEI T1,1(ACCUM)
	PUSH P,T3
	ADDI T3,1
	HRLI T3,(POINT 7,0)
	PUSHJ P,TRNST0
	MOVEI T1,0
	IDPB T1,T3
	MOVE T2,ACCUM
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
	POP P,ACCUM
	HRLI ACCUM,%V.PRS
	JRST VARXEC

IDXWRT:	SKIPGE IDXRLN
	JRST IDWLN0	;FIRST LINE, NO SPACEING
	SKIPG IDXRLN
	JRST IDWLN1	;NEED CARRAIGE CONTROL
IDXWR3:	CAIN C,12
	SETZM IDXRLN	;NEED CARRAIGE CONTROL NEXT TIME
	AOS IDXLEN
	JRST TAPOU7

IDWLN1:	SETZM TAPFRM	;STANDARD FORM NEEDED
IDWL11:	AOS IDXRLN
	SETZM SPCCNT	;JUST TO MAKE SURE (START OF LINE
	JRST IDXWR3	;MIGHT BE A BLANK LINE

IDWLN0:	PUSH P,C
	SETZM TAPCRC	;NON SAVE
	SETOM TAPFRM	;AND NONSTANDARD
	MOVEI C,"-"
	PUSHJ P,TAPOU2
	MOVEI C," "
	PUSHJ P,TAPOU2	;FORM FLASH
	MOVEI C,12
	PUSHJ P,TAPOU2
	SETZM IDXRLN	;ONLY GO THROUGH HERE ONCE
	MOVEI C,"+"
	PUSHJ P,TAPOU2
	MOVEI C," "
	PUSHJ P,TAPOU2
	POP P,C
	JRST IDWL11

LSIXCT:	ILDB T1,VTAB
	DPB T1,[POINT 7,ACCUM,35]
	ILDB T1,VTAB
	DPB T1,[POINT 7,ACCUM,28]
	ILDB T1,VTAB
	DPB T1,[POINT 7,ACCUM,21]
	HRLI ACCUM,%V.DUP!%V.PRS	;ALL LOADED
	JRST VARXEC

CATXCT:	POP P,T4	;RESTORE SAVE STRING
	TLNN ACCUM,%V.PRS	;IS ACCUM THRE?
	SKIPA ACCUM,T4	;NO USE T4
	TLNN T4,%V.PRS	;ACCUM THERE, IS OTHER STRING?
	JRST VARXEC	;ONE STRING IS NULL
	HLRZ T1,(ACCUM)
	HLRZ T2,(T4)
	ADD T1,T2
	CAILE T1,MAXCHR
	JRST LNGSTR	;STRING TOO LONG
	PUSH P,T1	;SAVE TOTAL NUMBER OF CHRS
	PUSHJ P,GETSWD	;GET SPACE FOR NEW STRING
	POP P,T2
	HRLM T2,(T3)	;STORE SIZE
	PUSH P,T3	;SAVE POINTER
	PUSH P,T4	;SAVE POINTER TO FIRST STRING
	MOVEI T1,1(T4)
	PUSHJ P,TRNST1	;MOVE FIRST STRING
	MOVEI T1,1(ACCUM)
	PUSHJ P,TRNSTR
	MOVEI T1,0
	IDPB T1,T3
	MOVE T2,ACCUM
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
	POP P,T2	;FIRST STRING
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
	POP P,ACCUM	;;POINTER TO CAT STRING
	HRLI ACCUM,%V.PRS
	JRST VARXEC

TRNST1:	ADDI T3,1
	HRLI T3,(POINT 7,0)
TRNSTR:	HLRZ T4,-1(T1)
TRNST0:	HRLI T1,(POINT 7,0)
TRNST2:	ILDB T2,T1
	JUMPE T2,CPOPJ
	IDPB T2,T3
	SOJG T4,TRNST2
	POPJ P,

TRNST3:	ADDI T3,1
	HRLI T3,(POINT 7,0)
	JRST TRNST0

LNGSTR:	OUTSTR [ASCIZ /
CONCATINATED STRING TOO LONG/]
	JRST ABTOUT

RTJXCT:	ILDB T4,VTAB	;SIZE
	TLNN ACCUM,%V.PRS
	JRST VARXEC	;NONE THERE
	HLRZ T1,(ACCUM)
	CAML T1,T4
	JRST VARXEC	;STRING >=SPACE
	SUB T4,T1	;NUMBER OF SPACES TO USE
JSTCOM:	HLRZ T1,(ACCUM)	;CHRS IN STRING
	ADD T1,T4
	PUSH P,T1
	PUSHJ P,GETSWD
	POP P,T1
	HRLM T1,(T3)
	PUSH P,T3
	MOVEI T1,STRBLK
	PUSHJ P,TRNST3	;MOOE SOME SPACES
	MOVEI T1,1(ACCUM)
	PUSHJ P,TRNSTR	;AND THE CHRS
	MOVEI T1,0
	IDPB T1,T3
	MOVE T2,ACCUM
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
	POP P,ACCUM	;THE ADJUSTED STRING
	HRLI ACCUM,%V.PRS
	JRST VARXEC

CTJXCT:	ILDB T4,VTAB	;SIZE
	TLNN ACCUM,%V.PRS
	JRST VARXEC
	HLRZ T1,(ACCUM)
	CAML T1,T4
	JRST VARXEC
	SUB T4,T1
	LSH T4,-1	;NUMBER OF SPACES TO THE LEFT
	JRST JSTCOM	;COMMON CODE

STRBLK:	REPEAT <MAXCHR+4>/5,<ASCII /     />

IFXCT:	TLNN ACCUM,%V.PRS	;IS THERE ANYTHING THERE?
	JRST IFSKP1		;NO, SKIP SOME CODE
IFNSKP:	MOVE T2,ACCUM		;DO NOT SKIP BUT CLEAR ACCUM
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
IFNSK1:	IBP VTAB	;NO SKIP NO CLEAR ACCUM
	JRST VARXEC

IFNXCT:	TLNN ACCUM,%V.PRS	;THIS IS THE OPPOSITE OF ABOVE
	JRST IFNSK1		;NOTHING THERE, DO NOT SKIP
IFSKIP:	MOVE T2,ACCUM	;CLEAR ACCUM AND SKIP
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR
IFSKP1:	ILDB T1,VTAB
	IDIVI T1,5
	ADD VTAB,T1
	MOVEI ACCUM,0	;ANSWER IS NULL STRING
	JUMPE T2,VARXEC	;NO BYTES TO SKIP
	IBP VTAB	;SKIP BYTE
	SOJG T2,.-1	;AND COUNNT
	JRST VARXEC

IFEXCT:	POP P,T4	;SAVED STRING
	PUSHJ P,IDXCPR	;COMPARE WITH ACCUM
	 JRST IFNSK2	;SAME, DO NOT SKIP
IFSKP2:	PUSHJ P,CLNIFN	;POSSIBLY RETURN SPACE FOR T4
	TLNN ACCUM,%V.PRS
	JRST IFSKP1	;NO NNEED TO CLEAR ACC
	JRST IFSKIP	;CLEAR AC AND SKIP

IFDXCT:	POP P,T4	;OPPOSITE
	PUSHJ P,IDXCPR
	 JRST IFSKP2	;SKIIP, SAME
IFNSK2:	PUSHJ P,CLNIFN
	TLNN ACCUM,%V.PRS
	JRST IFNSK1
	JRST IFNSKP

CLNIFN:	TLNE T4,%V.PRS	;IS THERE SOMETHING THERE
	TLNE T4,%V.DUP	;WHICH IS NOT A COPY
	POPJ P,		;NO
	MOVE T2,T4
	JRST GIVSTR	;YES, RETURN SPACE

CCLXCT:	ILDB T4,VTAB	;CHECK FOR ITEM CHANGE
	MOVE T3,ITMCNT
	MOVE T4,@IDXSPT-1(T3)
	PUSHJ P,IDXCPR
	 JRST IFNSK1	;SAME, SKIP ITEM # TO CLEAR
	MOVE T3,ITMCNT
	ILDB T4,VTAB	;NUMBER TO CLEAR
	SETZM @IDXSPT-1(T3)
	JRST VARXEC	;SO WILL PRINT NEXT TIME

	ARRAY IDXBLK[^D<10*207>]
IDXPNT:	FOR (I,0,^D9,<IDXBLK+I*^D207-1(PAGS)>)

SAVXCT:	PUSH P,ACCUM
	MOVEI ACCUM,0
	JRST VARXEC

LDIXCT:	ILDB T1,VTAB	;ITEM NUMBER TO LOAD
	MOVE ACCUM,@IDXPNT(T1)
	TLNE ACCUM,%V.PRS	;DO NOT SET DUUP BIT IF NOT THERE
	TLO ACCUM,%V.DUP
	JRST VARXEC

IDSXCT:	TLNN ACCUM,%V.PRS	;IS THERE SOMETHING THERE?
	JRST IDSXC1	;NO
	TLZE ACCUM,%V.DUP
	PUSHJ P,DUPSTR
IDSXC1:	ILDB T1,VTAB
	MOVEM ACCUM,@IDXPNT(T1)
	JRST VARXEC

LDVAR:	ILDB T1,VTAB	;GET THE VARIABLE NUMBER
	MOVE ACCUM,VARTB2(T1)
	TLNE ACCUM,%V.PRS
	TLO ACCUM,%V.DUP	;SET DUPLICATE NEEDED FLAG
	JRST VARXEC		;AND CONTINUE

STRVAR:	ILDB T1,VTAB	;VARIABLE TO STORE INTO
	TLNN ACCUM,%V.PRS
	JRST	[PUSHJ P,CLRVAR
		JRST VARXEC]	;NONE THERE, GE T RID OF OLD
	TLZN ACCUM,%V.DUP
	JRST STRVR1	;IF NOT DUP, CAN NOT BE SAME AS OLD
	CAMN ACCUM,VARTB2(T1)
	JRST VARXEC	;SAME, DO NOTHING
	PUSHJ P,DUPSTR	;DUPLICATE
	LDB T1,VTAB
STRVR1:	PUSHJ P,CLRVAR
	HRRM ACCUM,VARTB2(T1)
	MOVSI T2,%V.PRS
	IORM T2,VARTB2(T1)
	JRST VARXEC

SUBSTR:	ILDB T1,VTAB	;GET START
	ILDB T2,VTAB	;AND SIZE
	SOJL T1,BADSUB	;0 IS TOO SMALL
	TLNN ACCUM,%V.PRS
	JRST VARXEC	;NOTHING THERE, NOTHING TO DO
	HLRZ T4,(ACCUM)	;NUMBER OF CHRS IN AC
	SUB T4,T1
	JUMPLE T4,[MOVEI ACCUM,0	;NOTHING WILL BE LEFT
		JRST VARXEC]
	CAMLE T4,T2	;GET SMALLER OF REMAINDER AND DESIRED
	MOVE T4,T2
	PUSH P,T1	;SAVE START POS
	MOVE T1,T4
	PUSHJ P,GETSWD
	HRLM T4,(T3)	;SET SIZES
	MOVEI T1,1(ACCUM)
	HRLI T1,(POINT 7,0)
	POP P,T2	;NUMBER TO SKIP
	SKIPE T2	;IN CASE 0
	IBP T1
	SOJG T2,.-1	;NOW T1 IS CORRECT
	PUSH P,ACCUM
	MOVE ACCUM,T3
	HRLI ACCUM,%V.PRS	;SET UP STRING THERE
	ADDI T3,1
	HRLI T3,(POINT 7,0)
	PUSHJ P,TRNST2	;MOVE STRING
	MOVEI T2,0
	IDPB T2,T3	;TERMINATE STRING
	POP P,T2
	TLNN T2,%V.DUP
	PUSHJ P,GIVSTR	;NOT DUPLICATE, REMOVE
	JRST VARXEC

BADSUB:	OUTSTR [ASCIZ /
SUBSTRING OPERATION STARTING FROM POSITION 0/]
	JRST ABTOUT

;INITIALIZE THE COROUTINE STRUCTURE FOR GETTING INFO FROM LINES

INILIN:	MOVE CP,[IOWD 40,CPDL]
INILN2:	JUMPE T4,INITAP	;FINISHED WITH THIS STUFF, START TAPE
	HLRZ T3,(T4)	;POINTER TO TEXT PARAMETER BLOCK
	HLRZ T1,(T3)	;TYPE
	TRNN T1,1
	JRST NOVCK	;ODD TYPES ARE ONY IF NOT YET SET
	HRRZ T2,(T3)	;VARIABLE NUMBER
	MOVE T2,VARTB2(T2)
	TLNE T2,%V.PRS
	JRST NXTINI	;IT IS THERE, JUST TRY NEXT
NOVCK:	CAIG T1,1
	JRST INISCN	;IT IS A SCAN BLOCK
	MOVE T4,(T4)
	MOVEM T4,WTPTR#	;WAIT FOR THIS ONE TO COME AROUND
	HLRZ T1,1(T3)
	MOVEM T1,WTCNT#	;THE COUNT TO WAIT FOR
	PUSHJ P,INITAP
	PUSHJ CP,[POPJ P,]	;UP RETURN
TXSCWT:	CAMN LPOS,WTCNT
	JRST TXPFND	;FOUND THE RIGHT PLACE
	PUSHJ P,[POPJ CP,]	;DOWN
	PUSHJ CP,[POPJ P,]	;AND BACK UP
	JRST TXSCWT	;CONTINNUE

NXTINI:	HRRZ T4,(T4)
	JRST INILN2	;CONTINUE SETTING UP

TXPFND:	CAIN C,12
	POPJ CP,	;JUST FORGET IT
	HLRZ T4,WTPTR	;POINT TO CONTROL BLOCK
	HRRZ T1,1(T4)	;NUMBER TO READ
	PUSHJ P,GETSWD
	MOVSS (T3)
	PUSH P,T3	;SAVE STRING BLOCK POINTER
	MOVEI T1,4
	PUSHJ P,GETWDS
	MOVEM T4,3(T3)	;POINTER TO CONTROL BLOCK
	POP P,T1
	MOVEM T1,1(T3)	;POINTER TO STRING BLOCK
	ADDI T1,1
	HRLI T1,(POINT 7,0)
	MOVEM T1,(T3)	;BYTE POINTER TO STORE CHRS
	HRRZ T1,1(T4)
	MOVEM T1,2(T3)	;CHR COUNT
VPRS1:	HRRZ T4,WTPTR	;IS THERE MORE?
	JUMPE T4,TXPSTR	;NO

	MOVE T1,(T4)
	MOVEM T1,WTPTR
	HLRZ T4,T1	;THIS POINTS TO A CONTROL BLOCK
	HLRZ T1,(T4)
	TRNN T1,1
	JRST NOVCK2	;DOES NOT HAVE TO BE ABSENT
	HRRZ T1,(T4)
	MOVE T1,VARTB2(T1)
	TLNE T1,%V.PRS	;IS IT PRESENT
	JRST VPRS1	;YES, FORGET IT
NOVCK2:	HLRZ T1,1(T4)
	MOVEM T1,WTCNT
	PUSH CP,[TXSCWT]	;WAIT FOR ANOTHER
TXPSTR:	MOVE T1,3(T3)
	HLRZ T1,(T1)	;THIS IS THE TYPE
	LSH T1,-1	;LOW ORDER BIT IS JUST IF PRESENT BIT
	JRST @.+1(T1)
	JFCL	;0,1, NEVER HAPPENS
	TXTRD	;2,3, JUST READ
	TXTRDB	;4,5, STOP ON BLANK
	TXTRDI	;6,7, STOP ON ITEM
	JFCL	;10,11 NEVER HAPPENS
	TXBRD	;11,12 SKIP BLANK READ
	TXBRDB	;13,14 SKIP BLANK STOP ON BLANK
	TXBRDI	;15,16 SKIP BLANK STOP ON ITEM

TXTRD:	IDPB C,(T3)
	AOS @1(T3)	;COUNT CHR
	SOSG 2(T3)
	JRST TXRFIN	;DONE
	PUSH P,T3
	PUSHJ P,[POPJ CP,]
	POP P,T3
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]
	POP CP,T3
	CAIE C,12	;THIS MEANS WE ARE DONE
	JRST TXTRD
TXRFIN:	MOVEI T1,0
	IDPB T1,(T3)
	MOVSS @1(T3)
TXRFN1:	MOVE T4,3(T3)
	HRRZ T1,(T4)	;TYPE
	MOVSI T2,%V.PRS
	TDNE T2,VARTB2(T1)
	PUSHJ P,CLRVAR	;GET RID OF IT
	IORM T2,VARTB2(T1)
	MOVE T2,1(T3)
	HRRM T2,VARTB2(T1)
TXRFN2:	HRRZ T2,T3
	MOVEI T1,4
	PUSHJ P,GIVWDS
	POPJ CP,

TXBRD:	PUSHJ P,SKPSP2
	JRST TXTRD
TXBRDB:	PUSHJ P,SKPSP2
	JRST TXTRDB
TXBRDI:	PUSHJ P,SKPSP2
	JRST TXTRDI

SKPSP2:	CAIE C," "
	POPJ P,		;ALL BLANKS SKIPPED
	SOSG 2(T3)
	JRST SKPSP3	;FINISHED NOW
	PUSH P,T3
	PUSHJ P,[POPJ CP,]
	REPEAT 2,<POP P,T3
	PUSH CP,T3>
	PUSHJ CP,[POPJ P,]
	POP CP,T3
	PUSH P,T3
	POP CP,T3
	CAIE C,12
	JRST SKPSP2	;NOT END OF LINE
SKPSP3:	POP P,T1	;GET RID OF EXTRA RETURN
	JRST TXRFIN	;AND FINISH

TXTRDB:	CAIN C," "
	JRST TXRFN3
	IDPB C,(T3)
	AOS @1(T3)
	SOSG 2(T3)
	JRST TXRFIN
	PUSH P,T3
	PUSHJ P,[POPJ CP,]
	POP P,T3
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]
	POP CP,T3
	CAIE C,12
	JRST TXTRDB
	JRST TXRFIN

TXTRDI:	CAIE C," "
	JRST TXTRDB	;ON FIRST NON-BLANK BECOMES STOP BLANK
	IDPB C,(T3)
	AOS @1(T3)
	SOSG 2(T3)
	JRST TXRFN4
	PUSH P,T3
	PUSHJ P,[POPJ CP,]
	POP P,T3
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]
	POP CP,T3
	CAIE C,12
	JRST TXTRDI
	JRST TXRFIN

;T1 POINTS TO A VARIABLE , REMOVE POINTER AND RECLEAM SPACE
CLRVAR:	PUSH P,T2
	PUSH P,T1
	MOVE T2,VARTB2(T1)
	TLNE T2,%V.PRS
	PUSHJ P,GIVSTR
	MOVSI T2,%V.PRS
	POP P,T1
	ANDCAM T2,VARTB2(T1)	;CLEAR PRESENT FLAG
	POP P,T2
	POPJ P,

TXRFN3:	HRRZ T1,@1(T3)	;JUST IN CASE NO CHRS SEEN
	JUMPN T1,TXRFIN	;CHRS SEEN, FINISH
TXRFN4:	HRRZ T2,1(T3)
	MOVSS (T2)
	PUSHJ P,GIVSTR	;RETURN STRING
	JRST TXRFN2	;AND CONTROL BLOCK

INISCN:	PUSH P,T4	;SAVE CONTINUATION POINTER
	MOVE T4,T3
	MOVE T1,2(T4)	;GET NUMBER OF STRINGS
	LSH T1,1	;NEED TWO WORDS PER
	ADDI T1,7	;PLUS 3 WORDS OF CONTROL+2 EXTRA STRINGSS
	PUSH P,T1
	PUSHJ P,GETWDS
	POP P,T1
	MOVEM T4,(T3)	;POINTER TO CONTROL BLOCK
	HRLM T1,(T3)	;AND COUNT (FOR RECLAIMING
	HRLZ T1,2(T4)	;COUNT
	ADD T1,[3,,0]
	MOVNS T1	;NEGATIVE
	HRRI T1,2(T3)	;POINT TO WORK AREA -1
	MOVEM T1,2(T3)
	ADDI T1,1	;REAL FIRST WORK SPOT
	HRRZM T1,1(T3)	;NO PARTIAL SCANS YET
	POP P,T4	;RESTORE POINTER
	PUSH P,T3	;AND SAVE THE CONTROL BLOCK POINTER
	PUSHJ P,NXTINI	;CONTINUE
SCNFND:	POP P,T3
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]	;UP RETURN
	POP CP,T3
	SKIPL T4,1(T3)
	JRST SCOFIN	;NO PARTIALLY SCANNED STRINGS
SCNOLD:	ILDB T1,(T4)	;NEXT CHR
	JUMPE T1,SCNGOT	;FOUND A MATCH
	CAMN T1,C
	JRST SCNOL1	;IT IS THE SAME, CONTINUE
	CAIG T1,"Z"
	CAIGE T1,"A"	;IF STRING IS UPPER CASE
	JRST SCNDIE	;NO, NON-MATCH
	CAIE C,40(T1)	;IF UPPER CASE, MATCH EITHER
	JRST SCNDIE
SCNOL1:	AOBJN T4,SCNOLD	;CONTINUE

SCOFIN:	CAIN C,12
	JRST SCNABT
	HRRZ T4,(T3)	;GET POINTER TO REAL CONTROL BLOCK
	MOVE T4,1(T4)	;AOBJN POINTER TO STRIN POINTERS
SCNNWC:	HRRZ T1,(T4)
	ADDI T1,1
	HRLI T1,(POINT 7,0)
	ILDB T2,T1
	CAMN T2,C
	JRST SCNNEW	;FOUND A POSSIBLE MATCH, SET UP
	CAIG T2,"Z"
	CAIGE T2,"A"
	JRST SCNNWS	;NOT AN UPPER CASE LETTER
	CAIN C,40(T2)	;UPPER CASE MATCHES EITHER
	JRST SCNNEW
SCNNWS:	AOBJN T4,SCNNWC	;SEE IF MORE
	PUSH P,T3
	PUSHJ P,[POPJ CP,]	;DOWN CALL
	JRST SCNFND	;AND CONTINUE

;GENERATE A NEW PARTIAL STRING BLOCK

SCNNEW:	MOVE T2,2(T3)	;WHERE TO PUT IT
	AOBJP T2,SCNOVF	;UNLESS OUT OF ROOM
	MOVEM T1,(T2)	;STORE BYTE POINTER
	MOVEM T2,2(T3)
	MOVSI T1,-1
	ADDM T1,1(T3)	;UPDATE POINTER TO PARTIALS
	HRRZ T1,(T3)
	ADD T2,2(T1)	;HERE IS WHERE TO PUT THE STRING NUMBER
	MOVN T1,1(T1)	;FIND THE STRING NUMBER  THIS PNTR-ORG
	ADD T1,T4
	HRRZM T1,2(T2)
	JRST SCNNWS	;AND LOOK FOR MORE MATCHES

SCNABT:	HRRZ T2,T3	;GIVE BACK THE CONTROL BLOCK
	HLRZ T1,(T2)
	PUSHJ P,GIVWDS
	POPJ CP,	;AND CONTINUE DOWN

;HERE WHEN A PARTIAL MATCH FAILS

SCNDIE:	MOVN T1,[1,,1]
	ADDB T1,2(T3)	;THERE IS NOW ONE MORE WORD FOR PARTIALS
	MOVE T2,1(T1)	;GET THE LAST ONE
	MOVEM T2,(T4)	;AND OVERWRITE THIS ONE
	HRRZ T2,(T3)
	HRRZ T2,2(T2)	;THIS IS THE COUNT
	ADD T1,T2	;PLACE TO GET TO STRING NUMBER FROM
	ADD T2,T4	;WHERE TO PUT IT (STRING NUMBER OF FAILED)
	MOVE T1,3(T1)
	MOVEM T1,2(T2)
	MOVSI T1,1
	ADDM T1,1(T3)	;ADJUST AOBJN PTR TO OLD STRINGS
	SOJA T4,SCNOL1	;AND LOOK AT NEXT (KEEP COUNT, ADJUST POS TO SAME AFTER AOBJN)

SCNOVF:	OUTSTR [ASCIZ /
STRING SCAN OVERFLOW, TOO COMPLEX/]
	JRST ABTOUT

NUMMAX==^D15	;MAX NUMBER OF CHRS IN A NUMBER

;HERE WHEN WE FINALLY FIND THE MATCH

SCNGOT:	HRRZ T2,T3	;GET READY TO GIVE BACK THE CONTROL BLOCK
	HRRZ T3,(T3)	;POINT TO THE REAL SCAN CONTROL BLOCK
	ADD T4,2(T3)	;POINT TO THE STRING NUMBER BLOCK
	MOVE T4,2(T4)	;GET STRING NUMBER
	ADD T4,1(T3)	;POINT TO STRING POINTER, TYPE
	HLRZ T1,(T2)	;GET CONTROL SIZE
	PUSHJ P,GIVWDS	;AND RETURN IT
	HLRZ T1,(T4)	;GET TYPE
	ADD T4,2(T3)	;POINT TO THE SECOND CONTROL TYPE
	HRL T3,(T4)	;SAVE CHR CNT, ETC. IN T3
	XCT .+1(T1)
	JRST SETSTR	;JUST A STRING
	JRST SCNNUM	;SCAN A NUMBER
	JRST SCNNMB	;SAME BUT SKIP BLANKS
	JRST SCNC	;READ SOME CHRS
	JRST SCNCB	;AND SKIP BLANKS
	JRST SCNB	;SCAN TO BLANK
	JRST SCNBB	;SAME BUT SKIP BLANKS FIRST
	JRST SCNI	;SCAN TO ITEM
	JRST SCNIB	;SAME

SETSTR:	HLRZ ACCUM,T3	;GET STRING POINTER HERE
	PUSH P,T3
	PUSHJ P,DUPSTR	;DUPLICATE IT
	MOVEI T1,4
	PUSHJ P,GETWDS
	POP P,3(T3)	;POINT TO CONTROL BLOCK
	HRRZM ACCUM,1(T3)	;AND STRING
	JRST TXRFN1	;GO FINISH UP

DUPSTR:	HRRZ T1,(ACCUM)	;GET COUNT
	PUSHJ P,GETWDS
	HRL T1,ACCUM
	HRR T1,T3
	HRRZ T2,(ACCUM)
	ADD T2,T3
	BLT T1,-1(T2)
	HRRZ ACCUM,T3
	HRLI ACCUM,%V.PRS	;DEFINATELY THERE
	POPJ P,

SCNCB:	PUSHJ P,CHKSP	;CHECK FOR SPACES
	 POPJ CP,	;RAN OUT OF LINE, JUST FORGET IT
SCNC:	PUSH P,[TXTRD]	;WHERE TO READ
	JRST SCNCM	;OFF TO COMMON ROUTINE
SCNBB:	PUSHJ P,CHKSP
	 POPJ CP,
SCNB:	PUSH P,[TXTRDB]
	JRST SCNCM
SCNIB:	PUSHJ P,CHKSP
	 POPJ CP,
SCNI:	PUSH P,[TXTRDI]
SCNCM:	CAIN C,12
	JRST	[POP P,T1
		POPJ CP,]	;NOTHING REALLY TO DO
	PUSH P,T3	;SAVE POINTER TO CONTROL BLOCK
	HLRZ T1,T3	;GET COUNT
	PUSHJ P,GETSWD
	MOVSS (T3)
	PUSH P,T3	;SAVE STRING SPACE POINTER
	MOVEI T1,4
	PUSHJ P,GETWDS
	POP P,T1	;THE STRING SPACE POINTER
	HRRZM T1,1(T3)
	ADDI T1,1
	HRLI T1,(POINT 7,0)
	MOVEM T1,(T3)
	POP P,T1	;THIS HAS COUNT AND POINTER
	HRRZM T1,3(T3)
	HLRZM T1,2(T3)	;COUNT
	POPJ P,		;DISPATCH ADDRESS WAS PUSHED

CHKSP:	CAIN C,12
	POPJ P,
	CAIE C," "
	JRST CPOPJ1	;ALL SPACES DONE
	PUSH P,T3	;SAVE POINTER
	PUSHJ P,[POPJ CP,]
	POP P,T3
	PUSH CP,T3
	POP P,T3	;REALLY A RETURN ADDRESS
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]
	POP CP,T3	;RETURN ADRS AGAIN
	PUSH P,T3
	POP CP,T3
	JRST CHKSP	;AND GO CHECK

SCNNMB:	PUSHJ P,CHKSP
	 POP CP,
SCNNUM:	HRLI T3,NUMMAX	;ENOUGH SPACE FOR NUMBERS
	PUSH P,[TXTRN]
	JRST SCNCM

TXTRN:	CAIG C,"9"
	CAIGE C,"0"
	JRST TXRFIN
	IDPB C,(T3)
	AOS @1(T3)
	SOSG 2(T3)
	JRST TXRFIN
	PUSH P,T3
	PUSHJ P,[POPJ CP,]
	POP P,T3
	PUSH CP,T3
	PUSHJ CP,[POPJ P,]
	POP CP,T3
	CAIE C,12
	JRST TXTRN
	JRST TXRFIN	;DONE

INITAP:	PUSHJ CP,[POPJ P,]	;NO REAL INI TO DO
	PUSH P,C	;BUT SOME SPECIAL STUFF FOR FIRST CALL
	SKIPE RCDLIN
	JRST NOFRAM
	SKIPN FRAMED
	PUSHJ P,CLSFRM
	SETZM FRAMED
	SETOM TAPFRM
	SETZM TAPCRC	;JUST TO MAKE SURE
	SKIPN FLASH
	JRST NOFLSH	;DO NOT WANT FORM FLASH
	MOVEI C,"-"
	PUSHJ P,TAPOU2
	MOVEI C," "
	PUSHJ P,TAPOU2
	MOVEI C,12
	PUSHJ P,TAPOU2
	SETZM FLASH	;NOT WANTED ANY MORE
NOFLSH:	MOVEI C,"+"
	PUSHJ P,TAPOU2
	MOVEI C," "
	PUSHJ P,TAPOU2	;CARRAIGE CONTROL INFORMATION
	SKIPA
NOFRAM:	SETZM TAPFRM	;STANDARD NEEDED
	POP P,C
	PUSHJ P,TAPOU3
	PUSHJ CP,[POPJ P,]
	JRST .-2

FILDON:	MOVSI T1,%V.KEP
	PUSHJ P,CLSPAG	;FINISHED UP A PAGE
	MOVE T4,CURFLP	;GET THE CURRENT POINTER
	SKIPE NUMTTL
	OUTCHI ","	;IF NOT FIRST
	PUSHJ P,OUTNAM	;TELL HIM THE NAME
	MOVE T1,(T4)
	HLRZ T2,T1
	HRRM T1,(T2)	;UNLINK FILE
	TRNE T1,777777
	HRLM T2,(T1)
	SKIPE BRKFLG	;IS THIS ONE BROKEN?
	SOJA PAGS,DONBRK	;YES, WE ARE FINISHED
	MOVE T1,NUMTTL
	ADDI T1,1
	CAML T1,MAXFSH
	SOJA PAGS,DONFSH	;NO MORE ROOM ON THIS FISH
	SKIPE DEBFLG
	JRST ONREC	;SKIP BREAK STUFF
	SETOM TAPFRM
	SETZM TAPCRC
	MOVEI C,"+"	;NEED TO GET TO A WORD BOUNDARY
	PUSHJ P,TAPOU2	;PUT IN A BLANK LINE WITH NO SPACING
EVNLP:	MOVEI C," "
	PUSHJ P,TAPOU2
	MOVEI T1,TAPSIZ+1
	SUB T1,TAPCNT
	TRNE T1,3
	JRST EVNLP	;NOT THERE YET
	MOVEI C,12
	PUSHJ P,TAPOU2	;END LINE. NOW EVEN
	MOVEI T2,0	;GET SET TO DO A SKIP RECORD OP
	SKIPN TAPBF+2
	JRST ONREC
REPEAT 4,<PUSHJ P,TAPOUC>
	AOS @TAPBF+1
	AOS @TAPBF+1
ONREC:	OUT TAP,
	SKIPA
	JRST OUTERR
	AOS T1,OUTREC
	MOVEM T1,LSTOUP#
	MOVE T1,TOTCRS
	MOVEM T1,PRVCRS#	;SAVE FOR BACKUP
	SOJLE PAGS,DONFSH	;OUT OF PAGES
	MOVEM PAGS,PRVPAG#
	JRST SELFIL

DONBRK:	OUTCHI "-"	;LET HIM KNOW ITS PART
	AOS T1,BRKFLG
	PUSHJ P,OUTDEC
DONFSH:	PUSHJ P,CLSFSH	;FINIIH UP THE FISH
	JRST SELFSH	;CAN CONTINUE

;HERE WHEN FINISHED WITH A PAGE

FPDON:	SKIPE STRFIL
	JRST FSHPAG	;IGNORE BLANK PAGE AT START
	MOVSI T1,%V.KEP
	PUSHJ P,CLSPAG	;FINISH UP THE CURRENT PAGE
	SOJG PAGS,FSHPAG
NOPGS:	SKIPG NUMTTL	;IS THERE ONLY ONE ON THIS PAGE?
	JRST BRKLST	;YES, BREAK THE LISTING
NOPGS1:	MOVE PAGS,PRVPAG
	PUSHJ P,CLRIDV	;CLEAR INDEX VARIABLES
	MOVE PAGS,PRVPAG
	SOS T4,NUMTTL
	MOVEI T1,TTLBLK+1(T4)
	PUSHJ P,CLRVAR
	MOVEI T1,EXTBLK+1(T4)	;GET RID OF TITLE ETC.
	PUSHJ P,CLRVAR
	MOVEI T1,FILBLK+1(T4)
	PUSHJ P,CLRVAR
	HRLZ T1,VARTB2+TTLBLK(T4)
	HRRI T1,TTLPOS
	BLT T1,TTLPOS+2
	HRLZ T1,VARTB2+FILBLK(T4)
	HRRI T1,FILPOS
	BLT T1,FILPOS+2
	HRLZ T1,VARTB2+EXTBLK(T4)
	HRRI T1,EXTPOS
	BLT T1,EXTPOS+2
	AOS LSTOUP
	SKIPN DEBFLG
	USETO TAP,@LSTOUP
	MOVE T1,PRVCRS
	MOVEM T1,TOTCRS
	MOVEI T1,TAPSIZ
	MOVEM T1,TAPCNT
	PUSHJ P,CLSFSH
	SKIPN GRPPNT
	JRST SELFSH	;START A NEW FISH
	SOS GRPPNT	;REDO THIS ONE
	OUTSTR [ASCIZ /
CAN NOT FIT FILE /]
	MOVE T4,CURFLP
	PUSHJ P,OUTNAM
	OUTSTR [ASCIZ / ON FICHE
/]
	JRST SELFSH

BRKLST:	MOVE T4,CURFLP	;PRINT NAME
	PUSHJ P,OUTNAM
	OUTCHI "-"
	AOS T1,BRKFLG
	PUSHJ P,OUTDEC
	SETOM BKEFLG
	PUSHJ P,CLSFSH	;FINISH UP
	
	JRST SELFS1	;AND CONTINUE


CLSROW:	SETOM TAPFRM
	SETZM TAPCRC
	MOVEI C,"A"
	PUSHJ P,TAPOU2
	MOVEI C,"X"
	PUSHJ P,TAPOU2
	JRST TAPCLR

CLSFSH:	SKIPN FILOPN
	POPJ P,
	OUTSTR [ASCIZ /
/]
	SKIPE IDXPRS
	JRST CLSNOI	;DO NOT WANT INDEX
CLSFS1:	CAIGE PAGS,^D12
	JRST CLSFSF	;NEED SOME CLOSE FRAMES
	PUSHJ P,CLSROW
	SUBI PAGS,^D13
	JUMPGE PAGS,CLSFS1
	JRST CLSFS2

CLSFSF:	MOVEI T1,100
	MOVEM T1,FRMCNC	;JUST IN CASE
	PUSHJ P,CLSFRM
	SOJGE PAGS,.-1

;NOW GENERATE THE INDEX BLOCK

CLSFS2:	MOVEI VTAB,IDGVAR
	PUSHJ P,VARXCT
CLSNOI:	SETOM TAPFRM
	SETZM TAPCRC
	MOVEI C,"A"
	PUSHJ P,TAPOU2
	MOVEI C,"R"
	PUSHJ P,TAPOU2	;RESET FOR TITLE
	PUSHJ P,TAPCFR

ARRAY FCHPOS,BRKPOS[4]

;NOW GENERATE THE TITLE

	MOVE T1,BRKFLG
	MOVEI T4,BRKPOS
	PUSHJ P,NUMGEN
	MOVEM T4,VARTB2+BRKHLD	;SET UP
	MOVEI T4,FCHPOS
	AOS T1,TOTFSH
	ADD T1,TTLADN
	PUSHJ P,NUMGEN	;GENERATE FICHEN AND BREAKN
	MOVEM T4,VARTB2+FCHHLD
	MOVEI VTAB,TTLVAR
	SKIPE BRKFLG
	MOVEI VTAB,TTOVAR
	SETOM REMFRM
	PUSHJ P,VARXCT
	SKIPE REMFRM	;MUST HAVE CORRECT NUMBER
	JRST FRMERR
	MOVEI PAGS,^D207
	PUSHJ P,CLRIDV
	SKIPN BKEFLG
	TDZA T1,T1
	MOVSI T1,%V.KPF	;TREAT LIKE END OF PAGE
	PUSHJ P,PAGCL1	;CLEAR VARIABLES
	SETZM BKEFLG
	MOVSI T1,-^D18
	HRRI T1,TTLBLK
	MOVE T2,VARTB2(T1)
	TLZE T2,%V.PRS
	PUSHJ P,CLRVAR
	AOBJN T1,.-3
	SKIPE DEBFLG
	JRST	[SETZM FILOPN	;FILE NO LONGER OPEN
		POPJ P,]	;AT LEAST AS FAR AS NEEDING CLOSE
	MOVEI T2,0
	REPEAT 4,<PUSHJ P,TAPOUC>
	MOVEI T1,3
	ADDM T1,@TAPBF+1
	CLOSE TAP,
	MOVE T1,CMDPTR
	MOVE T2,FILOPN
	MOVEM T2,CMDBUF(T1)	;STORE NAME
	MOVE T2,TOTCRS
	MOVEM T2,CMDBUF+1(T1)	;AND CHRS USED
	SETZM FILOPN	;NOT OPEN NOW
	AOBJN T1,.+1
	AOBJN T1,CMDNOT	;NOT END, NO OUTPUT NEEDED
	OUTPUT CMDS,CMDSCM	;OUTPUT RECORD
	SETZM CMDBUF
	MOVE T1,[CMDBUF,,CMDBUF+1]	;CLEAR BUFFER FOR NEXT TIME
	BLT T1,CMDBUF+177
	MOVSI T1,-200
CMDNOT:	MOVEM T1,CMDPTR
	POPJ P,

NUMGEN:	MOVE T3,[POINT 7,1(T4)]
	SETZM (T4)
	PUSHJ P,NUMGN1
	MOVSS (T4)	;SIZE
	HRLI T4,%V.PRS
	POPJ P,

NUMGN1:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,NUMGN1
	HLRZ T1,(P)
	ADDI T1,"0"
	IDPB T1,T3
	AOS (T4)	;COUNT CHRS
	POPJ P,

CLRIDV:	MOVSI T4,-^D10
CLRIV1:	MOVE T2,@IDXPNT(T4)
	TLZE T2,%V.PRS
	PUSHJ P,GIVSTR
	SETZM @IDXPNT(T4)
	AOBJN T4,CLRIV1	;10 ITEMS PER PAGE
	SOJG PAGS,CLRIDV	;FOR ALL PAGES
	POPJ P,

CLSFRM:	SETOM TAPFRM
	SETZM TAPCRC
	MOVEI C,"A"
	PUSHJ P,TAPOU2
	SOSG FRMCNC	;CHECK FORM COUNT
	JRST SKPFRM	;AND SKIP THE EXTRA FRAME
TAPSPC:	MOVEI C," "
	PUSHJ P,TAPOU2
TAPCLR:	SKIPE DEBFLG
	JRST TAPCR2	;DONE IF DEBUGGING
	MOVEI T1,TAPSIZ+1
	SUB T1,TAPCNT	;GET NUMBER OUTPUT (+1 FOR COMMING RECORD MARK)
	CAILE T1,^D18	;IF NOT ENOUGH
	TRNE T1,3
	JRST TAPSPC	;NOT ENOUGH CHRS IN REC OR NOT MULT OF 4
	ADDI T1,^D1201	;ACCOUNT FOR GAP
	ADDM T1,TOTCRS
	MOVEI C,12
	PUSHJ P,TAPOU2
	MOVEI T2,0
	REPEAT 4,<PUSHJ P,TAPOUC>	;PUT OUT A 0 WORD
	AOS @TAPBF+1	;REALLY 1
	MOVEI T1,TAPSIZ
	MOVEM T1,TAPCNT
TAPCR2:	AOS TOTCST	;ONE MORE PAGE
	MOVEI C,"+"	;FOR CALLER
	POPJ P,

SKPFRM:	PUSHJ P,TAPSPC	;FINISH THIS FRAME
	MOVEI C,^D14
	MOVEM C,FRMCNC	;RESET COUNT
	JRST CLSFRM	;AND CLOSE OUT

TAPCFR:	SKIPN DEBFLG
	JRST TAPCLR
	MOVEI C,14
	PUSHJ P,TAPOU7
	SETZM SPCCNT
	JRST TAPCR2

TTLCNT:	SETOM TAPFRM
	SETZM TAPCRC
	MOVEI C,"X"
	PUSHJ P,TAPOU2		;GENERATE TITLE MODE
	MOVEI C," "
	PUSHJ P,TAPOU2
	MOVEI C,12
	PUSHJ P,TAPOU2
	MOVEI T1,LNSPAG
	MOVEM T1,TTLNS#	;SET NUMBER OF LINES
	MOVEI C,"+"
	SKIPN T4,NTLNS	;GET NUMBER OF LINES
	JRST TTLCL1	;IF ZERO, DON'T OUTPUT ANYTHING
	MOVNS T4
	HRLZS T4
TTLLGN:	MOVE T1,PTRTTB(T4)	;GET POINTER
	PUSHJ P,FRM1	;GEN A FRAME WORTH
	MOVEM T1,PTRTTB(T4)	;STORE THE RETURNED POINTER
	MOVEI C," "	;FOR NEXT TIME (CALL TO SPCLIN)
	AOBJN T4,TTLLGN
TTLCLR:	SKIPN TTLNS	;ALL LINES OUT?
	POPJ P,		;YES
	MOVEI C," "
TTLCL1:	PUSHJ P,SPCLIN	;NO GEN BLANK LINE
	JRST TTLCLR	;AND CONTINUE

;GENERATE ONE TITLE LINE

FRM1:	SETZM TTLBUF
	PUSH P,T4	;SAVE CALLERS T4
	PUSH P,C
	MOVE T2,[TTLBUF,,TTLBUF+1]
	BLT T2,TTLBUF+^D27	;CLEAR THE BIT TABLE
	MOVE TCC,TTLCRS	;GET NUMBER PERMITTED
	MOVE T2,[TTLOPT,,TTLCPT]
	BLT T2,TTLCPT+6	;SET UP BYTE POINTERS FOR EACH CHR LINE
FRM2:	LDB T2,T1	;GET A BYTE
	JUMPE T2,GOTTL	;END OF STRING, GENERATE
	IBP T1		;SET TO READ NEXT NEXT TIME
	PUSHJ P,GENTC	;GENERATE A CHACTER
	SOJG TCC,FRM2	;CONTINUE IF MORE ALLOWED

GOTTL:	POP P,C
	PUSHJ P,SPCLIN	;A LINE OF SPACES
	MOVEI VLN,7	;SEVEL LINES PER CHR
GOTTL1:	MOVE T4,VMLT
GOTTL3:	MOVE T3,TTLOPT-1(VLN)	;GET POINTER TO START OF THIS LINE
	MOVE HDTS,TFMPOS
	SETZM TAPFRM
	SETZM SPCCNT	;JUST TO MAKE SURE
GOTTL2:	ILDB C,T3
	MOVE C,TTLSP(C)
	PUSHJ P,TAPOU7
	SOJG HDTS,GOTTL2	;CONTINUE
	PUSHJ P,OUTCRL	;FINISH LINE
	SOJG T4,GOTTL3	;REPEAT FOR THE MULT FACTOR
	SOJG VLN,GOTTL1	;T3 POINTS TO CORRECT PLACE
	POP P,T4	;SAVE FOR CALLER
	MOVEI C," "
SPCLIN:	CAIN C," "
	JRST	[SETZM TAPFRM
		JRST SPCLN2]
	SETOM TAPFRM
	PUSHJ P,TAPOU2	;C LOADED WITH FIRST FORMAT CHR
	MOVEI C," "
	PUSHJ P,TAPOU2
SPCLN2:	MOVE VLN,TFMPOS
	MOVE C,TTLSP
	PUSHJ P,TAPOU7
	SOJG VLN,.-1
OUTCRL:	MOVEI C,12
	SOS TTLNS	;ONE LESS LINE
	JRST TAPOU7

GENTC:	ADD T2,[POINT 1,CTTLB]	;BYTE POINTER FOR CHR
	MOVEI VLN,7	;7 LINES OF CHR
GENTC1:	MOVE T3,TTLCPT-1(VLN)
	IBP T3
	IBP T3		;STARTS WITH 2 SPACES
	MOVEI HDTS,5	;THE 5 BITS OF CHR
GENTC2:	ILDB C,T2
	MOVE T4,HMLT
	IDPB C,T3
	SOJG T4,.-1
	SOJG HDTS,GENTC2
	MOVE T4,CHRSPC
	IBP T3
	SOJG T4,.-1	;THEN MORE SPACES
	MOVEM T3,TTLCPT-1(VLN)	;PUT BACK FOR NXT CHR
	SOJG VLN,GENTC1	;AND CONTINUE
	POPJ P,

TTLOPT:	FOR (I,0,6,<POINT 1,TTLBUF+I*4>)

CTTLB:	BLOCK 41
	143061400614	;!
	245000000000	;"
	005330155200	;#
	352643426534	;$
	614421042306	;%
	212242126232	;&
	022100000000	;'
	022102040404	;(
	202020410420	;)
	002167670400	;*
	002047620400	;+
	614104		;COMMA
	7600000		;DASH
	306		;PERIOD
	421042000	;SLASH
	350635346134	;0
	106041020434	;1
	350413502076
	350411406134
	043124574204
	770360204174
	350207506134
	760420420410
	350613506134
	350613604102
	003060030600	;:
	143001430210	;;
	042104040404	;<
	000370174000	;=
	202020210420	;>
	350421020010	;?
	350413326630	;@
	105214376142	;A
	750617506174
	350604102134
	744512245174
	770207502076
	770207502040
	370205706134
	430617706142
	342041020434
	020410306134
	431246122242
	410204102076
	435655306142
	434654706142
	350614306134
	750617502040
	350614326232
	750617522242
	350603406134
	762041020410
	430614306134
	430612450410
	430614326534
	430521052142
	430521020410
	760421042076
	710204102070	;[
	010101010100	;\
	160410204116	;]
	002165220410	;^
	002107640400	;_
	0
	105214376142	;A
	750617506174
	350604102134
	744512245174
	770207502076
	770207502040
	370205706134
	430617706142
	342041020434
	020410306134
	431246122242
	410204102076
	435655306142
	434654706142
	350614306134
	750617502040
	350614326232
	750617522242
	350603406134
	762041020410
	430614306134
	430612450410
	430614326534
	430521052142
	430521020410
	760421042076
	BLOCK 5

OUTSIX:	MOVEI T1,0
	LSHC T1,6
	OUTCHI " "(T1)
	JUMPN T2,OUTSIX
	POPJ P,

OUTDEC:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTDEC
	HLRZ T1,(P)
	OUTCHI "0"(T1)
	POPJ P,

OUTNAM:	SKIPE T2,3(T4)	;IF THERE IS A TITLE
	JRST OUTSIX	;PRINT IT
	MOVE T2,1(T4)
	PUSHJ P,OUTSIX
	HLLZ T2,2(T4)
	JUMPE T2,CPOPJ	;ELSE THE FILE ANME AND POSSIBLY EXTENSION
	OUTCHI "."
	JRST OUTSIX

;ERROR ROUTINES

DSKNA:	OUTSTR [ASCIZ /
DISK NOT AVAILABLE/]
	EXIT

NOUFD:	OUTSTR [ASCIZ /
CAN NOT READ UFD/]
	EXIT

PRTNAM:	PUSH P,T1
	PUSH P,T2
	MOVE T2,FILNM+2
	PUSHJ P,OUTSIX
	POP P,T2
	POP P,T1
	POPJ P,

FILNM:	3
	0
	0
	0

UFDNM:	3
	1,,1
	0
	SIXBIT /UFD/

NOCOR:	OUTSTR [ASCIZ /
INSUFFICIENT CORE AVAILABLE/]
	EXIT


TAPOPN:	0
	0
	TAPBF,,0

NOTAP:	OUTSTR [ASCIZ /
CAN NOT ASSIGN TAPE/]
	EXIT

NOOFL:	OUTSTR [ASCIZ /
CAN NOT ENTER OUTPUT DUMP FILE/]
	EXIT

OUTOCT:	IDIVI T1,10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ T1,(P)
	OUTCHI "0"(T1)
	POPJ P,

NOFLS:	OUTSTR [ASCIZ /
NO INPUT FILES/]
	EXIT

USRERR:	OUTSTR [ASCIZ /
MORE THAN ONE USER NAME SPECIFIED/]
	EXIT

	END STPT
    /@u