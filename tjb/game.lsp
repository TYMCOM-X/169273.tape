; THIS IS THE HEART OF MY DUNGEON SYSTEM.  THE BASIC IDEA IS THAT THINGS
; CARRY ALL OF THE IMPORTANT INFORMATION AROUND WITH THEM (INCLUDING VERBS)
; ON THEIR PROPERTY LISTS.  EVERYTHING IS ASSUMED TO HAVE CERTAIN PROPERTIES:
;    STREN  -  A MEASURE OF THE WEIGHT THAT THEY CAN CARRY (ALSO THE AMOUNT
;		 OF FORCE THAT THEY CAN RESIST).
;    WEIGH  -  THE TOTAL WEIGHT OF THE OBJECT (INCLUDING CONTENTS)
;    I-VOL  -  THE HOLDING CAPACITY (VOLUME) (IN CUBIC INCHES)
;    O-VOL  -  THE ACTUAL OUTSIDE VOLUME (IN CUBIC INCHES)
;    LONG   -  THE LENGTH OF THE OBJECT (IN INCHES)
;    WIDE   -  THE WIDTH
;    DEEP   -  THE DEPTH.  IT IS ASSUMED THAT LONG >= WIDE >= DEEP.
;                          NOTE THAT DEEP=0 => SHARP!
;    FLAGS  -  A 36-BIT WORD FULL OF FLAGS.  DEFINE WHATEVER YOU LIKE!
;		 (IF YOU LEAVE IT OUT, A 0 WILL BE ASSUMED)
;              I HAVE %OPEN% %TRANSPARENT% %LOCKED% AND MAY NEED OTHERS.
;    NAME   -  A QUOTED LIST CONTAINING A SHORT NAME (FIRST LETTER CAPITAL)
;    DESC   -  EVALUATES TO A LIST SUITABLE FOR TELL (THE FUNCTION)
;		NOTE THAT COND'S AND APPEND'S ARE ESPECIALLY USEFUL.
;
;  EVERYTHING IS ASSUMED TO HAVE ONE OF THE TWO FOLLOWING:
;    IN     -  THE OBJECT WHOSE CONTENTS I AM A MEMBER OF     OR
;    PART   -  THE OBJECT WHICH I AM A PART OF
;  GOING UP THESE **MUST** EVENTUALLY STOP AT AN OBJECT.
;
;  THE FOLLOWING ARE OPTIONAL, BUT SHOULD BE USED RATHER THAN SOMETHING 
;  ELSE INTENDED FOR THE SAME THING:
;    HOLDS  -  A LIST OF THE INTERNAL NAMES OF THE CONTENTS OF THE OBJECT
;    PARTS  -  A LIST OF THE INTERNAL NAMES OF THE COMPONENTS OF THE OBJECT
;    VERBS  -  A LIST OF DOTTED-PAIRS
;		CAR=THE WORD WHICH WILL MATCH (ONLY ONE)
;		CDR=THE ACTION TO TAKE. WILL BE EVAL'D IF CAR MATCHES THE VERB.
;		YOU MAY RECOGNISE THESE AS A-LIST LIKE CONSTRUCTS.
;		NOTE THAT ALL OF THE GENERALITY OF LISP IS AVAILABLE HERE!!
;
;  ANY OTHER PROPERTIES YOU WANT ARE FINE.  YOU NEED TO MAKE YOUR VERBS
;  AWARE OF THEM.
;
;  THE REMAINDER OF THE FILE IS A COLLECTION OF SOME OF THE BASICS NEEDED.
(PRINC '"Now loading FAEMAR. Please be patient.")

(DECIMAL)

(DEFPROP ALLFNS T SPECIAL) (DEFPROP ALLVALUES T SPECIAL)
(SETQ ALLFNS (SETQ ALLVALUES NIL))

; ENTER ADDS THINGS TO THE BEGINNING OF LISTS IF NOT ALREADY THERE:
(DE ENTER (X L)
  (COND ((MEMBER X L) L)
	(T (CONS X L))))

; REDEFINE %DEFIN TO KEEP A LIST OF NAMES OF DEFINED FUNCTIONS:
(DE %DEFIN (X V F P)
  (PROG (R)
	(SETQ R (COND ( (GETL X '(EXPR FEXPR SUBR FSUBR LSUBR MACRO))
			(LIST X 'Redefined) )
		      ( T X )))
	(SETQ ALLFNS (ENTER X ALLFNS))
	(PUTPROP X (NCONC (LIST (QUOTE LAMBDA) V) F) P)
	(RETURN R)))

; DV IS A LOT LIKE SETQ, BUT KEEPS A LIST OF NAMES OF VARS IN ALLVALUES:
(DF DV (%%L)
    (PROG2 (SETQ ALLVALUES (ENTER (CAR %%L) ALLVALUES))
	   (SET (CAR %%L) (EVAL (CADR %%L)))))

(DEFPROP !X T SPECIAL)

; SPECIAL KEEPS A LIST OF SPECIALS IN THE FIRST ARG AND DECLARES THE
;  REST OF THE LIST TO BE SPECIALS:
(DF SPECIAL (!X)
  (MAPC (FUNCTION
	 (LAMBDA (L) (SET (CAR !X) (ENTER L (EVAL (CAR !X))))
		     (PUTPROP L T 'SPECIAL))))
	(CDR !X)))

(SETQ SPECIALS (SETQ ALLDEFS (SETQ ALLFNS (SETQ ALLVALUES NIL))))

(SPECIAL SPECIALS
	 %OPEN% %TRANSPARENT% %OPENABLE% %LOCKED% %EDIBLE% %VISITED%
	 %BREAKABLE% PLAYER INFIN VERBS OBJECT INDIRECT OBJECTS %MSG
	 COUNTERS %N %THING %ADJ %FINAL %AVAIL DETERMINERS LINE VERB PREP
	 PREPOSITIONS ALLDEFS ALLVALUES UNIVERSE %BURNABLE% DIR ADJECTIVES)

;  INFIN IS USED SPECIALLY IN ADD AND SUBTRACT (HOPEFULLY NEVER OVERFLOWS)
(DV INFIN 1.7014118E+38)

(DV %OPEN% 1) (DV %TRANSPARENT% 2) (DV %OPENABLE% 4) (DV %EDIBLE% 8)
(DV %LOCKED% 16) (DV %VISITED% 32) (DV %BREAKABLE% 64) (DV %BURNABLE% 128)

; DT IS USED TO LOAD PROPERTY LISTS.
;  IT TAKES THE FIRST THING AND MAKES AN ATOM WITH THAT NAME AND VALUE.
;   IT THEN GRABS THINGS IN LISTS OF PROP-NAME FOLLOWED BY VALUE AND
;   STUFFS THEM ONTO THE PROPERTY-LIST OF THE THING IT CREATED.
(DF DT (%LIST)
 (PROG (%NAME)
   (SETQ %NAME (SET (CAR %LIST) (CAR %LIST)))
   (SETQ ALLDEFS (ENTER %NAME ALLDEFS))
   (PUTPROP %NAME 0.0 'I-VOL)
A  (COND( (NULL (SETQ %LIST (CDR %LIST))) (GO B) )
	( (EQ (CAAR %LIST) 'IN)
	  (PUTPROP (CADAR %LIST)
		   (ENTER %NAME (GET (CADAR %LIST) 'HOLDS))
		   'HOLDS) )
	( (EQ (CAAR %LIST) 'PART)
	  (PUTPROP (CADAR %LIST)
		   (ENTER %NAME (GET (CADAR %LIST) 'PARTS))
		   'PARTS) )
	( (EQ (CAAR %LIST) 'ADJ)
	  (SETQ ADJECTIVES
		(REMOVE-DUPLICATES (CONS (EVAL (CADAR %LIST))
					 ADJECTIVES))) ))
   (PUTPROP %NAME (EVAL (CADAR %LIST)) (CAAR %LIST))
   (GO A)
B  (COND( (NULL (GET %NAME 'O-VOL))
	  (PUTPROP %NAME
		   (MULTIPLY (GET %NAME 'LONG)
			     (MULTIPLY (GET %NAME 'WIDE)
				       (GET %NAME 'DEEP)))
		   'O-VOL) ))
   (COND( (GET %NAME 'IN)
	  (PROG (%DAD)
	    (SETQ %DAD %NAME)
       LOOP (COND( (SETQ %DAD (GET %DAD 'IN))
		   (PUTPROP %DAD
			    (SUBTRACT (GET %DAD 'I-VOL)
				      (GET %NAME 'O-VOL))
			    'I-VOL)
		   (PUTPROP %DAD
			    (SUBTRACT (GET %DAD 'STREN)
				      (GET %NAME 'WEIGH))
			    'STREN)
		   (GO LOOP) ))) ))
   (RETURN %NAME)))

; DECODE TAKES ATOMS AND TRIES TO PUT THEM INTO A FORM THAT DT (ABOVE)
;  WILL LIKE IF IT SEES.  SHOULD BE USEFUL FOR DUMPING THE DATA-BASE.
;  SPRINT WILL HELP MAKE THINGS LOOK NICE.
(DE DECODE (%THING)
  (PROG (%LIST1 %LIST2)
    (COND( (NOT(ATOM %THING)) (RETURN NIL) ))
    (SETQ %LIST2 (CDR %THING))
  A (COND( (NULL %LIST2)
	   (RETURN (APPEND (LIST 'DT %THING) %LIST1)) )
	 ( (NOT (OR (EQ (CAR %LIST2) 'VALUE)
		    (EQ (CAR %LIST2) 'PNAME)))
	   (SETQ %LIST1 (CONS (LIST (CAR %LIST2)
				    (COND( (ATOM (CADR %LIST2))
					   (CADR %LIST2) )
					 ( T
					   (LIST 'QUOTE (CADR %LIST2)) )))
			      %LIST1))) )
    (SETQ %LIST2 (CDDR %LIST2))
    (GO A)))

; MULTIPLY UNDERSTANDS INFIN AND SHOULDN'T OVERFLOW VERY OFTEN.
(DE MULTIPLY (%X %Y)
  (COND( (OR (EQ %X INFIN) (EQ %Y INFIN)) INFIN )
       ( T (TIMES %X %Y) )))

; DR (DEFINE ROOM) TRIES TO MAKE ALL OF THE APPROPRIATE ASSUMPTIONS ABOUT
;  ROOMS, AND MAKES SURE THAT ROOMS HAVE INSIDE-VOLUMES AND ARE PART
;  OF THE UNIVERSE.
(DF DR (%LIST)
  (PROG (%NAME)
    (SETQ %NAME (SET (CAR %LIST) (CAR %LIST)))
    (SETQ ALLDEFS (ENTER %NAME ALLDEFS))
    (PUTPROP %NAME INFIN 'STREN)
    (PUTPROP %NAME INFIN 'WEIGH)
    (PUTPROP %NAME INFIN 'O-VOL)
    (PUTPROP %NAME INFIN 'LONG)
    (PUTPROP %NAME INFIN 'WIDE)
    (PUTPROP %NAME INFIN 'DEEP)
    (PUTPROP %NAME UNIVERSE 'PART)
    (PUTPROP UNIVERSE (ENTER %NAME (GET UNIVERSE 'PARTS)) 'PARTS)
  A (COND( (NULL (SETQ %LIST (CDR %LIST))) (GO B) )
	 ( (EQ (CAAR %LIST) 'ADJ)
	   (SETQ ADJECTIVES
		 (REMOVE-DUPLICATES (CONS (EVAL (CADAR %LIST))
					  ADJECTIVES))) ))
    (PUTPROP %NAME (EVAL (CADAR %LIST)) (CAAR %LIST))
    (GO A)
  B (COND( (NULL (GET %NAME 'I-VOL))
	   (PUTPROP %NAME INFIN 'I-VOL) ))
    (RETURN %NAME)))

; IS LOOKS AT FLAG WORDS AND OR'S THEM WITH BIT PATTERNS.
;  IF ANY OF THEM WERE ON IT RETURNS T ELSE NIL.
(DE GETNUM (I P)
  (PROG (%TEMP)
    (RETURN (COND( (NOT(NUMBERP(SETQ %TEMP (GET I P)))) 0. )
		 ( T  %TEMP ) ))))

(DE IS (%THING %BITS)
  (COND ((EQ 0 (BOOLE 1 %BITS (GETNUM %THING 'FLAGS))) NIL)
	(T)))

(DE SET-FLAG (%BITS %THING)
  (PUTPROP %THING (BOOLE 7 %BITS (GETNUM %THING 'FLAGS)) 'FLAGS))

(DE RESET-FLAG (%BITS %THING)
  (PUTPROP %THING (BOOLE 2 %BITS (GETNUM %THING 'FLAGS)) 'FLAGS))

(DE SHARP (%THING) (NOT (GREATERP (GET %THING 'DEEP) 0)) )

; WHERE IS USEFUL FOR FOLLOWING OWNERSHIP CHAINS UPWARD.
;    IT LOOKS FOR AN "IN" PROPERTY AND RETURNS THAT  OR 
;    IT LOOKS FOR A "PART" PROPERTY AND RETURNS THAT.
;    HENCE (CADR (WHERE THING)) IS THE "FATHER" OF THING.
(DE WHERE (%THING)
  (COND ( (NOT (ATOM %THING)) (WHERE (CADR %THING)) )
	( (GET %THING 'IN)
	  (LIST 'IN (GET %THING 'IN)) )
	( (GET %THING 'PART)
	  (LIST 'PART (GET %THING 'PART)) )
	( T
	  (LIST NIL NIL) ) ) )

; HERE IS JUST WHERE THE PLAYER IS.
(DE HERE NIL (GET 'PLAYER 'IN))

; DELETE IS A PERFECTLY USEFUL FUNCTION THAT SHOULD HAVE BEEN HERE.
;   IT RETURNS A LIST WHICH IS JUST LIKE THE INPUT LIST EXCEPT THAT
;   ALL OCCURRENCES OF THING HAVE BEEN ELIMINATED.
(DE DELETE (%THING %LIST)
  (COND ( (NULL %LIST) NIL )
	( (EQUAL %THING (CAR %LIST)) (DELETE %THING (CDR %LIST)) )
	( T (CONS (CAR %LIST) (DELETE %THING (CDR %LIST))) )))

; TELL PRINTS OUT THE TEXT, CHECKING FOR LINE LENGTH AND SPECIAL THINGS:
;   %NULL% PRINTS NOTHING, %NS% SUPPRESSES THE SPACE BETWEEN OBJECTS, AND
;   %CRLF% IS A NEWLINE.
(DE TELL (%TEXT)
  (PROG (%O)
  A (COND( (NULL %TEXT) (RETURN) ))
    (SETQ %O (CAR %TEXT))
    (COND( (EQUAL %O '%NULL%)
	   (RETURN) )
	 ( (EQUAL %O '%CRLF%)
	   (TERPRI) (GO B) )
	 ( (AND (CDR %TEXT)
		(EQUAL (CADR %TEXT) '%NS%)
		(GREATERP (CHRCT) (FLATSIZE %O)))
	   (PRINC %O) (SETQ %TEXT (CDR %TEXT)) (GO B) )
	 ( (AND (CDR %TEXT)
		(EQUAL (CADR %TEXT) '%NS%))
	   (TERPRI) (PRINC %O) (SETQ %TEXT (CDR %TEXT)) (GO B) )
	 ( (GREATERP (CHRCT) (FLATSIZE %O))
	   (PRINC %O) )
	 ( T (TERPRI) (PRINC %O) ) )
    (TYO 32)
  B (SETQ %TEXT (CDR %TEXT))
    (GO A) ))

; TAB IS USED BY *INVENT TO PRINT A SPECIFIED NUMBER OF SPACES
(DE TAB (%N)
  (COND ( (EQ 0 %N) NIL )
	( (TYO 32) (TAB (SUB1 %N)) )))

; DESCRIBE RECURSIVELY PRINTS THE DESCRIPTIONS (SEE ABOVE ON PROP NAMES)
;    OF OBJECTS. IF THEY ARE OPEN OR TRANSPARENT, THEN THEIR CONTENTS
;    ARE ALSO DESCRIBED.
(DE DESCRIBE (%THING)
  (PROG (%LIST)
    (COND ( (NULL %THING) (RETURN '(%NULL%)) )
	  ( (NOT (GET %THING 'DESC)) (RETURN '(%NULL%)) )
	  ( (NOT (IS %THING %VISITED%))
	    (TELL (EVAL (GET %THING 'DESC))) ))
             ; NOTE THAT EVAL'ING ALLOWS THE DESCRIPTION TO CHANGE.
    (COND ( (IS %THING (PLUS %OPEN% %TRANSPARENT%))
	    (SETQ %LIST (APPEND (GET %THING 'PARTS) (GET %THING 'HOLDS))) )
	  ( T  (SETQ %LIST (GET %THING 'PARTS)) ))
    (MAPC (FUNCTION
	    (LAMBDA (%O) (COND ( (GET %O 'DESC) (DESCRIBE %O) )) ))
	  %LIST)
    (RETURN '(%NULL%))))

; OPEN WILL TRY TO OPEN ANYTHING.  CHECKS ARE MADE FOR OPENABLE AND
;   LOCKED FIRST, THEN THE OPEN BIT OF THE FLAGS WORD IS TURNED ON.
;   A MESSAGE IS RETURNED, BUT CAN BE IGNORED IF YOU WANT.
(DE OPEN NIL
  (SETQ DIR 'open)
  (COND ( (NOT (IS OBJECT %OPENABLE%))
	  '(I don't know how to open such a thing/.) )
	( (IS OBJECT %OPEN%) '(It is already open/.) )
	( (IS OBJECT %LOCKED%) '(It is locked/.) )
	( INDIRECT '(I don't understand that/.) )
	( (OBJECT-ACTION) )
	( T
	  (COND( (MOVE OBJECT PLAYER)
		 (TELL '(/( %NS% Taken/. /) %CRLF%)) ))
	  (SET-FLAG %OPEN% OBJECT)
	  (PUTPROP OBJECT
		   (ENTER 'open (DELETE 'close (GET OBJECT 'ADJ)))
		   'ADJ)
	  (TELL (APPEND (GET OBJECT 'NAME) '(%NS% : opened/.)))
	  (COND( (GET OBJECT 'HOLDS)
		 (PUTPROP OBJECT (GET OBJECT 'INVENT) 'TEMP)
		 (REMPROP OBJECT 'INVENT)
		 (TELL (*INVENT OBJECT 0))
		 (PUTPROP OBJECT (GET OBJECT 'TEMP) 'INVENT)
		 (REMPROP OBJECT 'TEMP) ))
	  '(%NULL%) )))

; CLOSE IS VERY SIMILAR TO OPEN. IT DOESN'T CHECK THE LOCKED BIT BECAUSE
;   IT IS ASSUMED TO HAVE BEEN TURNED OFF IN ORDER TO OPEN.
(DE CLOSE NIL
  (SETQ DIR 'close)
  (COND ( (NOT (IS OBJECT %OPENABLE%))
	  '(I don't know how to close such a thing/.) )
	( INDIRECT '(I don't understand that/.) )
	( (OBJECT-ACTION) )
	( T
	  (COND( (MOVE OBJECT PLAYER)
		 (TELL '(/( %NS% Taken/. /)  %CRLF%)) ))
	  (RESET-FLAG %OPEN% OBJECT)
	  (PUTPROP OBJECT
		   (ENTER 'close (DELETE 'open (GET OBJECT 'ADJ)))
		   'ADJ)
	  (APPEND (GET OBJECT 'NAME) '(%NS% : closed/.)))))

; TAKE PUTS THE OBJECT MENTIONED TO THE PLAYERS HOLDINGS. SEE MOVE.
(DE TAKE NIL
  (SETQ DIR 'take)
  (COND ( (MEMQ OBJECT (GET PLAYER 'HOLDS))
	  '(You already have it/.) )
	( (AND INDIRECT
	       (MEMQ PREP '(on from in upon within)))
	  (COND( (OBJECT-ACTION) )
	       ( (NOT (MEMQ OBJECT (*AVAIL INDIRECT)))
	  	 '(It is not there/.) )
	       ( (MOVE OBJECT PLAYER)
		 (APPEND (GET OBJECT 'NAME) '(%NS% : taken/.)) )
	       ( T %MSG ) ) )
	( INDIRECT '(I don't understand that/.) )
	( (OBJECT-ACTION) )
	( (MOVE OBJECT PLAYER)
	  (APPEND (GET OBJECT 'NAME) '(%NS% : taken/.)) )
	( T %MSG ) ))

; DROP PUTS SOMETHING FROM THE PLAYERS HOLDINGS INTO THE PLAYERS
;   CONTAINER.  IF MOVE WAS USED TO GET IT, THE MOVE HERE CAN'T FAIL.
(DE DROP NIL
  (SETQ DIR 'drop)
  (COND ( (NOT (MEMQ OBJECT (*AVAIL PLAYER)))
  	  '(You aren't carrying it/.) )
	( (AND INDIRECT
	       (MEMQ PREP '(in on upon within into onto)))
	  (COND( (OBJECT-ACTION) )
	       ( (MOVE OBJECT INDIRECT)
		 (APPEND (GET OBJECT 'NAME) '(%NS% : dropped/.)) )
	       ( T  %MSG )) )
	( INDIRECT '(I don't understand that/.) )
	( (OBJECT-ACTION) )
	( (MOVE OBJECT (HERE))
	  (APPEND (GET OBJECT 'NAME) '(%NS% : dropped/.)) )
	( T %MSG ) ))

; AVAILABLE IS A PREDICATE WHICH TELLS IF SOMETHING IS IN THE
;   PLAYERS "REACH", THAT IS, IN THE PLAYER'S POSSESSION (AND VISIBLE)
;   OR SOMEWHERE IN THE CURRENT ROOM.  IT KEEPS GOING DOWN OPEN THINGS AS
;   FAR AS IT CAN.
(DE AVAILABLE (%THING) (MEMQ %THING (*AVAIL (HERE))))

; *AVAIL RETURNS A LIST OF THE AVAILABLE THINGS.
;   IT LOOKS ALL THE WAY DOWN THROUGH OPEN AND TRANSPARENT THINGS.
(DE *AVAIL (%PLACE)
  (PROG (%LIST)
    (COND( (NULL %PLACE) (RETURN NIL) )
	 ( (IS %PLACE (PLUS %OPEN% %TRANSPARENT%))
	   (SETQ %LIST (APPEND (GET %PLACE 'HOLDS) (GET %PLACE 'PARTS))) )
	 ( T  (SETQ %LIST (GET %PLACE 'PARTS)) ))
    (RETURN (REMOVE-DUPLICATES (APPEND %LIST
				       (LIST %PLACE)
				       (APPLY (FUNCTION APPEND)
					      (MAPCAR (FUNCTION *AVAIL)
						      %LIST)))))))

(DE REMOVE-DUPLICATES (%LIST)
  (COND( (NULL %LIST) NIL )
       ( (MEMBER (CAR %LIST) (CDR %LIST)) (REMOVE-DUPLICATES (CDR %LIST)) )
       ( T  (CONS (CAR %LIST) (REMOVE-DUPLICATES (CDR %LIST))) )))

; *MOVE IS THE FRONT END FOR MOVE (WHICH IS REALLY A PREDICATE).
(DE *MOVE NIL
 (PROG (%TEMP)
  (COND( (NULL OBJECT) (RETURN '(Move what?)) )
       ( (NULL INDIRECT)
	 (RETURN (APPEND '(Where shall I move the)
			 (DOWNSHIFT OBJECT)
			 '(%NS% ?))) )
       ( (NOT (MEMQ OBJECT (*AVAIL PLAYER)))
	 (COND( (MOVE OBJECT PLAYER)
		(TELL '( /( %NS% Taken/. %NS% /) %CRLF%)) )
	      ( T  (RETURN %MSG) )) ) )
  (COND( (SETQ %TEMP (OBJECT-ACTION))
	 (RETURN %TEMP) )
       ( (MOVE OBJECT INDIRECT)
	 (RETURN '(OK/.)) )
       ( T  
	 (RETURN %MSG)))))

(DE LOOK NIL
 (PROG (%TEMP)
  (SETQ DIR 'look)
  (COND( (AND (NULL OBJECT)
	      (NULL INDIRECT))
	 (TELL (GET (HERE) 'NAME))
	 (COND( (GET (HERE) 'LOOK) (TELL (EVAL (GET (HERE) 'LOOK))) ))
	 (RESET-FLAG %VISITED% (HERE))
	 (TERPRI)
	 (TELL (DESCRIBE (HERE)))
	 (SET-FLAG %VISITED% (HERE))
	 (RETURN '(%NULL%)) )
       ( (AND (NULL OBJECT)
	      (EQ PREP 'at))
	 (COND( (SETQ %TEMP (OBJECT-ACTION))
		(RETURN %TEMP) )
	      ( (MOVE INDIRECT PLAYER)
		(TELL '( /( %NS% Taken/. %NS% /) %CRLF%)) ))
	 (COND( (GET INDIRECT 'LOOK)
		(RETURN (EVAL (GET INDIRECT 'LOOK))) )
	      ( T  (RETURN (APPEND '(I see nothing special about the)
				   (DOWNSHIFT INDIRECT) '(%NS% /.))) )) )
       ( (NULL INDIRECT)
	 (COND( (SETQ %TEMP (OBJECT-ACTION))
		(RETURN %TEMP) )
	      ( (MOVE OBJECT PLAYER)
		(TELL '( /( %NS% Taken/. %NS% /) %CRLF%)) ))
	 (COND( (GET OBJECT 'LOOK)
		(RETURN (EVAL (GET OBJECT 'LOOK))) )
	      ( T  (RETURN (APPEND '(I see nothing special about the)
				   (DOWNSHIFT OBJECT) '(%NS% /.))) )) )
       ( (NOT (IS INDIRECT %TRANSPARENT%))
	 (RETURN (APPEND '(How does one look through a)
			 (DOWNSHIFT INDIRECT) '(%NS% ?))) )
       ( (SETQ %TEMP (OBJECT-ACTION))
	 (RETURN %TEMP) )
       ( (GET OBJECT 'LOOK)
	 (RETURN (EVAL (GET OBJECT 'LOOK))) )
       ( T
	 (RETURN (APPEND '(I see nothing special about the)
		 (DOWNSHIFT OBJECT) '(%NS% /.))) ))))

; THIS IS A GLOBAL THAT WILL CONTAIN A LIST OF COUNTERS (AS THEY ARE
;   NEEDED).  DO WILL WALK DOWN THE LIST, DECREMENTING THE COUNTERS AND
;   EVAL'ING THE OTHER HALVES. FORM IS ( (COUNTER.WHAT-TO-DO) ... )
;   THE COUNTER GETS TO ZERO, THE WHOLE THING IS REMOVED FROM THE LIST.
(DV COUNTERS NIL)

; OBJECT-ACTION SEARCHES THE OBJECTS INVOLVED FOR VERBS. FIRST THE INDIRECT
;   OBJECT IS SEARCHED, IF NOTHING HAPPENS THERE, THE DIRECT OBJECT IS
;   SEARCHED. IF NEITHER WANT TO DO ANYTHING, RETURN NIL. OTHERWISE RETURN
;   WHATEVER THEY RETURNED.
(DE OBJECT-ACTION NIL
  (PROG (%TEMP)
    (COND ( (AND INDIRECT
		 (SETQ %TEMP (ASSOC (*FIVE* DIR) (GET INDIRECT 'VERBS)))
		 (SETQ %TEMP (EVAL (CDR %TEMP))))
	    (RETURN %TEMP) )
; ABOVE: ASSOC IS USED TO SEARCH THE INDIRECT OBJECT'S VERB LIST.
	  ( (AND OBJECT
		 (SETQ %TEMP (ASSOC (*FIVE* DIR) (GET OBJECT 'VERBS)))
		 (SETQ %TEMP (EVAL (CDR %TEMP))))
	    (RETURN %TEMP) )
; ABOVE: SEARCH THE INDIRECT OBJECT'S VERB LIST.
	  ( T (RETURN NIL) )) ) )

; %MSG IS THE PLACE WHERE THE MESSAGE RETURNED FROM ADD-THING IS STASHED.
;  IF MOVE FAILS, YOU HAVE THE CHOICE OF PRINTING OUT %MSG OR NOT.
(DV %MSG NIL)

; MOVE IS THE REAL WORK-HORSE OF THE DATA-STRUCTURE ROUTINES.
;  **NOTE** IT IS A PREDICATE (RETURNS T OR NIL)! IT MERELY TELLS YOU
;  IF THE THING THAT YOU ARE TRYING SUCCEEDED. IF IT RETURNS NIL, THE
;  GLOBAL %MSG CONTAINS THE ERROR MESSAGE THAT IT CREATES.
;
;  MOVE DOES THE WORK TO ENSURE THAT VOLUMES AND STRENGTHS ARE ALL CHANGED
;  CORRECTLY.  THERE ARE 3 CASES:
;	1) THE DESTINATION IS A SON OF THE START.
;		ADD THE THING ALL THE WAY ON DOWN TO THE DESTINATION BUT
;		DON'T ADJUST THE START.
;	2) THE START IS A SON OF THE DESTINATION.
;		REMOVE THE THING FROM THE START ALL THE WAY TO THE DESTINATION
;		BUT DON'T ADJUST THE DESTINATION.
;	3) THE START AND DESTINATION HAVE A COMMON FATHER.
;		REMOVE FROM THE START ALL THE WAY (BUT NOT INCLUDING) THE
;		FATHER AND ADD FROM (BUT NOT INCLUDING) DAD DOWN TO DEST.
(DE MOVE (%THING %DEST)
  (PROG (%START %DAD %HERE %STOP)
    (SETQ DIR 'move)
    (COND( (NULL %THING) 
	   (SETQ %MSG '(What do you want to move?)) (RETURN NIL) )
	 ( (NULL %DEST)
	   (SETQ %MSG '(Where do you want to move it to?)) (RETURN NIL) )
	 ( (EQUAL %DEST (SETQ %START (CADR (WHERE %THING))))
	   (SETQ %MSG '(It is already there/.)) (RETURN NIL) )
	 ( (SETQ %STOP (OBJECT-ACTION))
	   (SETQ %MSG %STOP) (RETURN NIL) ( (IS-SON %DEST %START)
	   (SETQ %DAD %START) )		; CASE 1.
	 ( (IS-SON %START %DEST)
	   (SETQ %DAD %DEST) )		; CASE 2.
	 ( T
	   (PROG NIL			; CASE 3. FIND THE COMMON FATHER.
	     (SETQ %HERE %START)	;  START UPWARD FROM START.
	   A (COND( (IS-SON %DEST %HERE) (GO B) ))
	     (SETQ %HERE (CADR (WHERE %HERE)))
	     (GO A)
	   B (SETQ %DAD %DEST)		; AND UPWARD FROM DESTINATION.
	   C (COND( (IS-SON %START %DAD) (GO D) ))
	     (SETQ %DAD (CADR (WHERE %DAD)))
	     (GO C)
	   D (COND( (IS-SON %HERE %DAD) (SETQ %DAD %HERE) )))))
; ABOVE: THE THREE CLAUSES SET THE CORRECT FATHER.
    (SETQ %HERE %START)			; REMOVE UP TO DAD.
  A (COND( (IS-SON %DAD %HERE) (GO B) ))
    (REMOVE-THING %THING %HERE)
    (SETQ %HERE (CADR (WHERE %HERE)))
    (GO A)
  B (SETQ %HERE %DEST)			; ADD FROM DEST UP TO DAD.
  C (COND( (IS-SON %DAD %HERE)
	   (COND( (GET %THING 'PART)	; DONE: MOVE THE THING.
		  (REMPROP %THING 'PART)
		  (PUTPROP %START (DELETE %THING (GET %START 'PARTS)) 'PARTS) )
		( T
		  (PUTPROP %START (DELETE %THING (GET %START 'HOLDS)) 'HOLDS)))
	   (PUTPROP %THING %DEST 'IN)
	   (PUTPROP %DEST (APPEND (GET %DEST 'HOLDS) (LIST %THING)) 'HOLDS)
	   (RETURN T))
	 ( (SETQ %MSG (ADD-THING %THING %HERE)) ; ADD-THING RETURNS MESSAGE
	   (GO D) ))			; IF FAILURE, BACK IT OUT!
    (SETQ %HERE (CADR (WHERE %HERE)))
    (GO C)
; BELOW: FIX UP THE MESSAGE AND BACK OUT THE ADJUSTMENTS.
;  NEEDED TO ENSURE THAT EVERYTHING STAYS COPASETIC.
  D (SETQ %STOP %HERE)
    (SETQ %HERE %START)
  E (COND( (EQUAL %HERE %DAD) (GO F) ))
    (ADD-THING %THING %HERE)		; CAN'T FAIL CAUSE JUST REMOVED!
    (SETQ %HERE (CADR (WHERE %HERE)))
    (GO E)
  F (SETQ %HERE %DEST)
  G (COND( (EQUAL %HERE %STOP) (RETURN NIL) ))
    (REMOVE-THING %THING %HERE)
    (GO G) ))

; INVENTORY PRINTS THE CONTENTS OF THE PLAYER AS LONG AS THEY ARE VISIBLE.
;  AN OBJECT WITHOUT A DESCRIPTION IS INVISIBLE AS ARE OBJECTS WITHIN
;  OTHER OBJECTS WHICH ARE THEMSELVES CLOSED.
(DE INVENTORY NIL
  (COND( (NULL (GET PLAYER 'HOLDS))
	 '(You are empty handed/.) )
       ( T  (TELL '(You are carrying:))
	    (MAPC (FUNCTION (LAMBDA (%O) (*INVENT %O 0)))
		  (GET PLAYER 'HOLDS))
	    '(%NULL%) )))

(DE *INVENT (%THING %N)
  (PROG (%LIST)
    (COND( (NULL %THING) (RETURN '(%NULL%)) )
	 ( (GET %THING 'INVENT)
	   (TERPRI) (TAB %N) (TELL (EVAL (GET %THING 'INVENT))) ))
    (COND( (NOT(IS %THING (PLUS %OPEN% %TRANSPARENT%))) (RETURN '(%NULL%)) ))
    (COND( (EVAL (CONS (FUNCTION OR)
		       (MAPCAR (FUNCTION (LAMBDA (%O) (GET %O 'INVENT)))
			       (SETQ %LIST (GET %THING 'HOLDS)))))
	   (TERPRI) (TAB %N)
	   (TELL (APPEND '(The) (DOWNSHIFT %THING) '(contains:)))
	   (MAPC (FUNCTION (LAMBDA (%O) (*INVENT %O (PLUS %N 3))))
		 %LIST) ))
    (RETURN '(%NULL%))))

(DE DONT-KNOW NIL
  (APPEND '(I don't know the word ' %NS%) (LIST DIR) '(%NS% '/.)))

; ADD-THING DOES THE CHECKING FOR FIT (SEE MOVE). IT IS A KIND OF REVERSE
;   PREDICATE: RETURNS NIL IF IT FIT, AND A MESSAGE OTHERWISE.
(DE ADD-THING (%THING %PLACE)
  (PROG (%WEIGHT %STRENGTH %T-VOL %P-VOL)
    (COND( (NOT(IS %PLACE %OPEN%))		; LOOK FOR SHARP THINGS
	   (COND( (NOT (SHARP %THING))
		  (RETURN (APPEND (GET %PLACE 'NAME) '(%NS% : not open/.))) )
		( (GREATERP (GET %THING 'STREN) (GET %PLACE 'STREN))
		  (SETQ %T-VOL 'cut) (SETQ %P-VOL %PLACE) )
		( (GREATERP (GET PLAYER 'STREN) (GET %THING 'STREN))
		  (SETQ %T-VOL 'break) (SETQ %P-VOL %THING) )
		( T
		  (RETURN (APPEND (GET %PLACE 'NAME) '(%NS% : too tough/.))) ))
	   (COND( (IS %P-VOL %BREAKABLE%)
		  (SETQ %WEIGHT OBJECT)
		  (SETQ OBJECT %P-VOL)
		  (COND( (NOT (SETQ %P-VOL (ASSOC %T-VOL VERBS)))
			 (SETQ DIR %T-VOL)
			 (RETURN (DONT-KNOW)) ))
		  (SETQ OBJECT %WEIGHT)
		  (RETURN '(%NULL%)) )
		( T
		  (RETURN (APPEND (GET %P-VOL 'NAME) '(%NS% : won't)
				  (LIST %T-VOL))) )) )
	( (GREATERP (SETQ %WEIGHT (GET %THING 'WEIGH))
		    (SETQ %STRENGTH (GET %PLACE 'STREN)))
	  (COND( (IS %PLACE %BREAKABLE%)
		 (SETQ %WEIGHT OBJECT)
		 (SETQ OBJECT %P-VOL)
		 (*BREAK)
		 (SETQ OBJECT %WEIGHT)
		 (RETURN '(%NULL%)) )
		( T
		  (RETURN (APPEND (GET %THING 'NAME)
			  '(%NS% : too heavy/.))) )) )
	( (GREATERP (SETQ %T-VOL (GET %THING 'O-VOL))
		    (SETQ %P-VOL (GET %PLACE 'I-VOL)))
	  (COND( (AND (IS %PLACE %BREAKABLE%)
		      (SHARP %THING))
		 (SETQ %WEIGHT OBJECT)
		 (SETQ OBJECT %P-VOL)
		 (CUT)
		 (SETQ OBJECT %WEIGHT)
		 (RETURN '(%NULL%)) )
		( T
		  (RETURN (APPEND (GET %PLACE 'NAME)
			  '(%NS% : no room left/.))) )) )
	( (GREATERP (GET %THING 'LONG) (GET %PLACE 'LONG))
	  (COND( (AND (IS %PLACE %BREAKABLE%)
		      (SHARP %THING)
		      (SETQ %STRENGTH (ASSOC 'cut (GET %PLACE 'VERBS))))
		 (SETQ %WEIGHT OBJECT)
		 (SETQ OBJECT %P-VOL)
		 (TELL (EVAL (CDR %STRENGTH)))
		 (SETQ OBJECT %WEIGHT)
		 (RETURN '(%NULL%)) )
	       ( T
		 (RETURN (APPEND (GET %THING 'NAME)
				 '(%NS% : won't fit/.))) )) ) )
    (PUTPROP %PLACE (SUBTRACT %STRENGTH %WEIGHT) 'STREN)
    (PUTPROP %PLACE (SUBTRACT %P-VOL %T-VOL) 'I-VOL)
    (RETURN NIL)))

; REMOVE-THING MAKES THE REMOVAL ADJUSTMENTS.
(DE REMOVE-THING (%THING %PLACE)
  (PROG NIL
    (PUTPROP %PLACE (ADD (GET %PLACE 'STREN) (GET %THING 'WEIGH)) 'STREN)
    (PUTPROP %PLACE (ADD (GET %PLACE 'I-VOL) (GET %THING 'O-VOL)) 'I-VOL)
    (RETURN NIL)))


; IS-SON IS A LOT LIKE *AVAIL, BUT DOESN'T CHECK FOR OPEN OR TRANSPARENT.
(DE IS-SON (%THING %PLACE)
  (PROG (%LIST)
    (COND( (NULL %PLACE) (RETURN NIL) )
	 ( (EQUAL %THING %PLACE) (RETURN T) )
	 ( (MEMBER %THING
		   (SETQ %LIST (APPEND (GET %PLACE 'HOLDS)
				       (GET %PLACE 'PARTS))))
	   (RETURN T) )
	 ( T (RETURN (EVAL (CONS (FUNCTION OR)
				 (MAPCAR (FUNCTION
					   (LAMBDA (%O) (IS-SON %THING %O)))
					 %LIST))))))))

; ADD KNOWS ABOUT INFIN.  SHOULD NEVER OVERFLOW.
(DE ADD (%X %Y)
  (COND( (OR (EQUAL %X INFIN) (EQUAL %Y INFIN)) INFIN )
       ( T (*PLUS %X %Y) )))

; SUBTRACT KNOWS ABOUT INFIN.
(DE SUBTRACT (%X %Y)
  (COND( (EQUAL %X INFIN) INFIN )
       ( T (*DIF %X %Y) )))

; MOVE-TO PUTS THE PLAYER IN A NEW ROOM, IF POSSIBLE.  IT CLOSES THE OLD
;   ROOM AND OPENS THE NEW ROOM SO THAT *AVAIL WORKS RIGHT.
(DE MOVE-TO (%PLACE)
  (PROG (%TEMP)
    (SETQ %TEMP (HERE))
    (SET-FLAG %OPEN% %PLACE)
    (COND( (MOVE PLAYER %PLACE) 
	   (COND( (GET %PLACE 'INIT) (EVAL (GET %PLACE 'INIT)) ))
	   (TELL (GET %PLACE 'NAME))
	   (COND( (OR (NOT (IS %PLACE %VISITED%))
		      (APPLY (FUNCTION APPEND)
			     (MAPCAR
			       (FUNCTION (LAMBDA (%O) (GET %O 'DESC)))
			       (APPEND (GET %PLACE 'PARTS)
				       (GET %PLACE 'HOLDS)))))
		  (TERPRI) ))
; ALL THAT JUST TO KEEP FROM BLANK LINES!
	   (TELL (DESCRIBE %PLACE))
	   (RESET-FLAG %OPEN% %TEMP)
	   (SET-FLAG %VISITED% %PLACE)
	   (RETURN '(%NULL%)) )
         ( T
	   (RESET-FLAG %OPEN% %PLACE)
	   (RETURN %MSG) ) ) ) )

; IS-OBJECT IS USED TO CHECK AND SEE IF A WORD REPRESENTS A KNOWN OBJECT.
;   THE KEY IS AN A-LIST OF PAIRS: (word.(THING1 ... THINGN)).
;   THIS LIST IS SEARCHED BY ASSOC AND THE CDR IS INTERSECTED WITH *AVAIL.
;   THE RESULT IS A LIST OF ALL THE THINGS CALLED BY THAT WORD THAT ARE
;   AVAILABLE.
(DE IS-OBJECT (%THING)
  (PROG (%FINAL %TEMP %AVAIL)
    (COND( (NULL %THING) (RETURN NIL) )	; THIS SEEMS TO BE THE PLACE
					; TO DO DEFAULTS (FROM FRAME?)
	 ( (MEMQ (CAR %THING) DETERMINERS)
	   (SETQ %THING (CDR %THING)) )); STRIP OFF A DETERMINER
    (COND( (NULL %THING)
	   (TELL '(I don't understand that/.))
	   (RETURN '%ERR%) )
	 ( (NOT (SETQ %AVAIL
		      (ASSOC (*FIVE* (CAR (LAST %THING))) OBJECTS)))
	   (TELL (APPEND '(I don't know the word ' %NS%)
			 (LAST %THING) '(%NS% '/.)))
	   (RETURN '%ERR%) )
	 ( (NULL (SETQ %AVAIL (INTERSECT (CDR %AVAIL)
					(*AVAIL (HERE)))))
	   (TELL (APPEND '(I see no) %THING '(here/.)))
	   (RETURN '%ERR%) )
	 ( T (RETURN
	      (PROG NIL
	       (SETQ %TEMP (REVERSE (CDR (REVERSE %THING))))
	       (COND( (NULL %TEMP)
		      (SETQ %FINAL %AVAIL)
		      (GO DONE) ))
	       (MAPC
	         (FUNCTION (LAMBDA (%ADJ)
			    (MAPC
			      (FUNCTION (LAMBDA (%OBJ)
				          (COND( (MEMQ (*FIVE* %ADJ)
						       (GET %OBJ 'ADJ))
					         (SETQ %FINAL
						       (ENTER %OBJ %FINAL)) )
					       ( T
					         (SETQ %FINAL
						    (DELETE %OBJ %FINAL)) ))))
			      %AVAIL)))
	         %TEMP)
          DONE (COND( (NULL (SETQ %FINAL (REMOVE-DUPLICATES %FINAL)))
		      (TELL (APPEND '(I see no) %THING '(here/.)))
		      (RETURN '%ERR%) )
		    ( (GREATERP (LENGTH %FINAL) 1)	; SHOULD APPLY ANY
							; RESTRICTIONS HERE.
		      (TELL (APPEND '(Which) %THING '(shall I use?)))
		      (RETURN '%ERR%) )
		    ( T
		      (RETURN (CAR %FINAL)) )) ))))))

; PARSE TRIES TO BREAK A COMMAND AT A PREPOSITION. THE FIRST WORD IS ASSUMED
;   TO BE THE VERB, EVERYTHING UP TO THE PREP IS THE DIRECT OBJECT,
;   EVERYTHING AFTER THE PREP IS THE INDIRECT OBJECT.
(DE PARSE (LINE)
  (PROG NIL
    (COND( (EQUAL LINE '(again)) (RETURN T) ))
    (SETQ VERB (CAR LINE))	; THIS NEEDS TO BE CHECKED VERSUS
				; A LIST OF VERBS (PERHAPS W/ FRAMES).
				; REMEMBER "SAY" AND "GO" W/ VARIANTS.
    (COND( (NOT(SETQ VERB (ASSOC (*FIVE* VERB) VERBS)))
	   (SETQ DIR (CAR LINE))
	   (TELL (DONT-KNOW))
	   (RETURN '%ERR%) ))
    (SETQ DIR (CAR VERB))	; REMEMBER THE ACTUAL COMMAND WORD
    (SETQ VERB (CDR VERB))	; STRIP OF THE MATCHER WORD
    (SETQ LINE (CDR LINE))
    (SETQ INDIRECT (SETQ OBJECT (SETQ PREP NIL)))
  A (COND( (NULL LINE)		; NO PREP WAS FOUND
	   (COND( (EQ (SETQ OBJECT (IS-OBJECT OBJECT)) '%ERR%)
		  (RETURN (SETQ OBJECT NIL)) )
		( T (RETURN T) )) )
	 ( (MEMQ (CAR LINE) PREPOSITIONS)	; FOUND A PREP, SPLIT LINE
	   (SETQ PREP (CAR LINE))
	   (COND( (EQ (SETQ OBJECT (IS-OBJECT OBJECT)) '%ERR%)
		  (RETURN (SETQ OBJECT NIL)) )
		( (EQ (SETQ INDIRECT (IS-OBJECT (CDR LINE))) '%ERR%)
		  (RETURN (SETQ INDIRECT NIL)) )
		( T (RETURN T) )) ))
    (SETQ OBJECT (APPEND OBJECT (LIST (CAR LINE))))
    (SETQ LINE (CDR LINE))
    (GO A) ))

(DV DETERMINERS '(a an the this that these those))

(DV PREPOSITIONS '(abaft aboard about above across after against along
  alongside amid among amongst around as astride at athwart atop before
  behind beneath beside besides between betwixt beyond by below in on with
  into upon out over of to for from through past under towards off toward
  throughout using within) )

(DV ADJECTIVES '(north south east west open close locke) )

; INTERSECT TAKES THE INTERSECTION OF TWO LISTS.
(DE INTERSECT (%LIST1 %LIST2)
  (PROG (%RESULT)
  A (COND( (NULL %LIST1) (RETURN %RESULT) )
	 ( (MEMQ (CAR %LIST1) %LIST2)
	   (SETQ %RESULT (ENTER (CAR %LIST1) %RESULT)) ))
    (SETQ %LIST1 (CDR %LIST1))
    (GO A)))

; GETLINE IS A TRY AT AN INPUT ROUTINE.  IT DOWNSHIFTS CAPITALS SO THAT IT
;   ALWAYS RETURNS A LIST OF LOWER CASE WORDS.
(DE GETLINE NIL
  (PROG (%C %W %M)
  A (COND( (AND(GREATERP (SETQ %C (TYI)) 64.)
	       (LESSP %C 91.))		; DOWNSHIFT UPPERCASE
	   (SETQ %W (APPEND %W (LIST (ASCII (PLUS %C 32))))))
	 ( (AND(GREATERP %C 96.)
	       (LESSP %C 123.))		; LEAVE LOWERCASE UNTOUCHED
	   (SETQ %W (APPEND %W (LIST (ASCII %C)))) )
	 ( (EQUAL %C 46.)		; A PERIOD
	   (COND( %W (RETURN (APPEND %M (LIST (READLIST %W)))) )
		( %M (RETURN %M) )
		( T  (RETURN '(nothing)) )) )
	 ( (EQUAL %C 44.)		; A COMMA
;	   (SETQ %M (APPEND %M (LIST (READLIST %W)) '(%C%)))
	   (COND( %W  (SETQ %M (APPEND %M (LIST (READLIST %W)))) ))
	   (SETQ %W NIL) )
	 ( (EQUAL %C 13.)		; A RETURN
	   (TYI)			; STRIP OFF THE LF
	   (COND( %W (RETURN (APPEND %M (LIST (READLIST %W)))) )
		( %M (RETURN %M) )
		( T  (RETURN '(nothing)) )) )
	 ( T
	   (COND( %W (SETQ %M (APPEND %M (LIST (READLIST %W)))) ))
	   (SETQ %W NIL) ) )
    (GO A) ) )

; START IS JUST A LOOP AROUND THE EXECUTOR.
(DE START NIL
  (PROG NIL
    (TYI) (TYI)
    (LINELENGTH 72)
    (TELL '(%CRLF% Good Luck! %CRLF% %CRLF%))
    (SETQ OBJECT (SETQ INDIRECT (SETQ PREP NIL)))
    (TELL (LOOK))
    (SET-FLAG %VISITED% (HERE))
; MAKE SURE THAT THE STARTING ROOM IS VISITED
    (TERPRI)
  A (COND( (PARSE (GETLINE)) (TELL (EVAL VERB)) ))
    (MAPC (FUNCTION
	    (LAMBDA (%O) (COND( (GREATERP (EVAL (CAR %O)) 0)
				(EVAL (CDR %O))
				(SET (CAR %O)
				     (SUB1 (EVAL (CAR %O)))) )
			      ( T  (SETQ COUNTERS (DELETE %O COUNTERS)) ))))
	  COUNTERS)
; ABOVE: MAPC CDR'S DOWN THE COUNTER LIST.
    (TERPRI)
    (GO A)))

(DSKINQ (LAP.FNS))

(DE D (%N) (ADD1 (RAN %N)))

(DE PCT (%N) (LESSP (D 100) %N))

(DF ONE-OF (%LIST)
  (PROG (%TEMP)
    (COND( (NULL %LIST) (RETURN NIL) ))
    (SETQ %TEMP (RAN (LENGTH %LIST)))
  A (COND( (EQ %TEMP 0) (RETURN (EVAL (CAR %LIST))) ))
    (SETQ %TEMP (SUB1 %TEMP))
    (SETQ %LIST (CDR %LIST))
    (GO A) ))

; DOWNSHIFT GRABS THE NAME OF A THING AND DOWNSHIFTS THE FIRST
;   CHARACTER OF EACH WORD.
(DE DOWNSHIFT (%THING)
  (MAPCAR
    (FUNCTION
      (LAMBDA (%O)
	(READLIST (CONS (PROG (%C) (RETURN
			  (COND( (EQ (SETQ %C (CAR (EXPLODE %O))) 'A) 'a )
			       ( (EQ %C 'B) 'b ) ( (EQ %C 'C) 'c )
			       ( (EQ %C 'D) 'd ) ( (EQ %C 'E) 'e )
			       ( (EQ %C 'F) 'f ) ( (EQ %C 'G) 'g )
			       ( (EQ %C 'H) 'h ) ( (EQ %C 'I) 'i )
			       ( (EQ %C 'J) 'j ) ( (EQ %C 'K) 'k )
			       ( (EQ %C 'L) 'l ) ( (EQ %C 'M) 'm )
			       ( (EQ %C 'N) 'n ) ( (EQ %C 'O) 'o )
			       ( (EQ %C 'P) 'p ) ( (EQ %C 'Q) 'q )
			       ( (EQ %C 'R) 'r ) ( (EQ %C 'S) 's )
			       ( (EQ %C 'T) 't ) ( (EQ %C 'U) 'u )
			       ( (EQ %C 'V) 'v ) ( (EQ %C 'W) 'w )
			       ( (EQ %C 'X) 'x ) ( (EQ %C 'Y) 'y )
			       ( (EQ %C 'Z) 'z ) ( T %C ))))
			(CDR (EXPLODE %O))))))
    (LAST (GET %THING 'NAME))))

(DE *FIVE* (%THING)
  (COND( (GREATERP (FLATSIZE %THING) 5)
	 (PROG (%LIST)
	   (RETURN
	     (READLIST (CONS (CAR (SETQ %LIST (EXPLODE %THING)))
			     (CONS (CADR %LIST)
				   (CONS (CADDR %LIST)
					 (CONS (CADDDR %LIST)
					       (NCONS (CAR(CDDDDR %LIST)))))))
       ) ) ) )
       ( T  %THING )))

(DE EAT NIL
 (PROG2
  (SETQ DIR 'eat)
  (COND( (NULL OBJECT) '(Eat what?) )
       ( (AND PREP
	      (NOT (MEMQ PREP '(with using))))
	 '(I don't understand that/.) )
       ( (AND INDIRECT
	      (NOT (MEMQ INDIRECT (GET PLAYER 'HOLDS))))
	 (APPEND '(You need to take the) (DOWNSHIFT INDIRECT) '(first/.)) )
       ( (NOT (IS OBJECT %EDIBLE%))
	 (ONE-OF (APPEND '(I am afraid that the) (DOWNSHIFT OBJECT)
			 '(won't agree with you/.))
		 '(I think that I am going to be sick/.)
		 '(What a revolting idea/.)
		 (APPEND '(The) (DOWNSHIFT OBJECT) '(looks inedible/.))) )
       ( (OBJECT-ACTION) )
       ( T
	 (TELL (APPEND '(Thank you/. The) (DOWNSHIFT OBJECT)
		       '(was delicious/.)))
	 (MOVE OBJECT UNIVERSE)
	 '(%NULL%) ))))

(DE CUT NIL
 (PROG2
  (SETQ DIR 'cut)
  (COND( (NULL OBJECT) '(Cut what?) )
       ( (AND PREP
	      (NOT (MEMQ PREP '(with using))))
	 '(I don't understand that/.) )
       ( (NULL INDIRECT) '(With what?) )
       ( (NOT (SHARP INDIRECT))
	 (APPEND '(You can't cut with the) (DOWNSHIFT INDIRECT) '(%NS% /.)) )
       ( (NOT (IS OBJECT %BREAKABLE%))
	 (ONE-OF '(It is beyond your power to do that/.)
		 (APPEND '(The) (DOWNSHIFT OBJECT) '(can't be cut/.))
		 (APPEND '(The) (DOWNSHIFT OBJECT) '(is tougher than it
		 	 looks/. Nothing happens/.))
		 '(Your blows are ineffective/. It is unharmed/.)) )
       ( (OBJECT-ACTION) )
       ( T (*BREAK) ))))

(DE *BREAK NIL
 (PROG2
  (SETQ DIR 'break)
  (COND( (NULL OBJECT) '(Break what?) )
       ( (AND PREP
	      (NOT (MEMQ PREP '(with using))))
	 '(I don't understand that/.) )
       ( (NOT (IS OBJECT %BREAKABLE%))
	 (ONE-OF '(It is beyond your power to do that/.)
		 (APPEND '(The) (DOWNSHIFT OBJECT) '(is unbreakable/.))
		 (APPEND '(The) (DOWNSHIFT OBJECT) '(is tougher than it
		 	 looks/. Nothing happens/.))
		 '(Your blows are ineffective/. It is unharmed/.)) )
       ( (OBJECT-ACTION) )
       ( T
	 (MAPC (FUNCTION (LAMBDA (%O) 
			   (PROG2
			     (MOVE %O (HERE))
			     (TELL (APPEND '(%CRLF%) (EVAL (GET %O 'INVENT))
					   '(falls out/.))))))
			 (GET OBJECT 'HOLDS))
	 (RESET-FLAG %BREAKABLE% OBJECT)
	 (SET-FLAG %OPEN% OBJECT)
	 (PUTPROP OBJECT (ENTER 'broke (GET OBJECT 'ADJ)) 'ADJ)
	 '(%NULL%) ))))

(DT UNIVERSE (STREN INFIN) (WEIGH INFIN) (I-VOL INFIN) (LONG INFIN)
	     (WIDE INFIN) (DEEP INFIN) (FLAGS %OPEN%) )

(DECIMAL)

(DSKINQ FAEMAR)

(RAN INFIN)

(PROG NIL
      (TYO 27)
      (TYO 72)
      (TYO 27)
      (TYO 74)
      (RETURN
	(TELL '(Done! %CRLF%))))
   K~D