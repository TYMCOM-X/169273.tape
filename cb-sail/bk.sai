Begin "BLOCK"
require "(sailib)sail.def" source!file;
define eif="ELSE IF";

Define Byte(S,a,b,c,d,e,f,g,Name)=
    "(((((('"&"a Lsh S + '"&"b) Lsh S + '"&"c) Lsh S + '"&"d)
   Lsh S + '"&"e) Lsh S + '"&"f) Lsh S + '"&"g)";
require null!delimiters;
Preset!With

    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "00"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "01"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "02"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "03"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "04"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "05"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "06"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "07"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "10"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "11"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "12"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "13"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "14"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "15"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "16"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "17"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "20"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "21"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "22"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "23"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "24"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "25"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "26"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "27"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "30"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "31"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "32"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "33"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "34"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "35"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "36"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  "37"),
    BYTE(5, 00, 00, 00, 00, 00, 00, 00,  " "),
    BYTE(5, 04, 04, 04, 04, 04, 00, 04,  "!"),
    BYTE(5, 12, 12, 00, 00, 00, 00, 00,  "Quote"),
    BYTE(5, 12, 12, 37, 12, 37, 12, 12,  "#"),
    BYTE(5, 04, 17, 24, 37, 05, 36, 04,  "$"),
    BYTE(5, 31, 31, 02, 04, 10, 23, 23,  "%"),
    BYTE(5, 10, 24, 10, 24, 23, 22, 15,  "&"),
    BYTE(5, 06, 02, 04, 00, 00, 00, 00,  "'"),
    BYTE(5, 04, 10, 20, 20, 20, 10, 04,  "("),
    BYTE(5, 04, 02, 01, 01, 01, 02, 04,  ")"),
    BYTE(5, 00, 25, 16, 33, 16, 25, 00,  "*"),
    BYTE(5, 00, 04, 04, 37, 04, 04, 00,  "+"),
    BYTE(5, 00, 00, 00, 00, 00, 06, 02,  ","),
    BYTE(5, 00, 00, 00, 37, 00, 00, 00,  "-"),
    BYTE(5, 00, 00, 00, 00, 00, 06, 06,  "."),
    BYTE(5, 00, 00, 01, 02, 04, 10, 20,  "/"),
    BYTE(5, 16, 21, 23, 25, 31, 21, 16,  "0"),
    BYTE(5, 04, 14, 04, 04, 04, 04, 16,  "1"),
    BYTE(5, 16, 21, 01, 02, 04, 10, 37,  "2"),
    BYTE(5, 16, 21, 01, 02, 01, 21, 16,  "3"),
    BYTE(5, 22, 22, 22, 37, 02, 02, 02,  "4"),
    BYTE(5, 37, 20, 34, 02, 01, 21, 16,  "5"),
    BYTE(5, 16, 20, 20, 36, 21, 21, 16,  "6"),
    BYTE(5, 37, 01, 01, 02, 04, 10, 20,  "7"),
    BYTE(5, 16, 21, 21, 16, 21, 21, 16,  "8"),
    BYTE(5, 16, 21, 21, 17, 01, 01, 16,  "9"),
    BYTE(5, 00, 06, 06, 00, 06, 06, 00,  ":"),
    BYTE(5, 00, 06, 06, 00, 06, 06, 02,  ";"),
    BYTE(5, 02, 04, 10, 20, 10, 04, 02,  "<"),
    BYTE(5, 00, 00, 37, 00, 37, 00, 00,  "="),
    BYTE(5, 10, 04, 02, 01, 02, 04, 10,  ">"),
    BYTE(5, 16, 21, 01, 02, 04, 00, 04,  "?"),
    BYTE(5, 16, 21, 27, 25, 25, 23, 10,  "@"),
    BYTE(5, 16, 21, 21, 21, 37, 21, 21,  "A"),
    BYTE(5, 36, 21, 21, 36, 21, 21, 36,  "B"),
    BYTE(5, 17, 20, 20, 20, 20, 20, 17,  "C"),
    BYTE(5, 36, 21, 21, 21, 21, 21, 36,  "D"),
    BYTE(5, 37, 20, 20, 36, 20, 20, 37,  "E"),
    BYTE(5, 37, 20, 20, 36, 20, 20, 20,  "F"),
    BYTE(5, 17, 20, 20, 20, 27, 21, 16,  "G"),
    BYTE(5, 21, 21, 21, 37, 21, 21, 21,  "H"),
    BYTE(5, 16, 04, 04, 04, 04, 04, 16,  "I"),
    BYTE(5, 01, 01, 01, 01, 21, 21, 16,  "J"),
    BYTE(5, 21, 21, 22, 34, 22, 21, 21,  "K"),
    BYTE(5, 20, 20, 20, 20, 20, 20, 37,  "L"),
    BYTE(5, 21, 33, 25, 21, 21, 21, 21,  "M"),
    BYTE(5, 21, 21, 31, 25, 23, 21, 21,  "N"),
    BYTE(5, 16, 21, 21, 21, 21, 21, 16,  "O"),
    BYTE(5, 36, 21, 21, 36, 20, 20, 20,  "P"),
    BYTE(5, 16, 21, 21, 21, 25, 22, 15,  "Q"),
    BYTE(5, 36, 21, 21, 36, 24, 22, 21,  "R"),
    BYTE(5, 17, 20, 20, 16, 01, 01, 36,  "S"),
    BYTE(5, 37, 04, 04, 04, 04, 04, 04,  "T"),
    BYTE(5, 21, 21, 21, 21, 21, 21, 37,  "U"),
    BYTE(5, 21, 21, 21, 21, 21, 12, 04,  "V"),
    BYTE(5, 21, 21, 21, 21, 25, 33, 21,  "W"),
    BYTE(5, 21, 21, 12, 04, 12, 21, 21,  "X"),
    BYTE(5, 21, 21, 12, 04, 04, 04, 04,  "Y"),
    BYTE(5, 37, 01, 02, 04, 10, 20, 37,  "Z"),
    BYTE(5, 14, 10, 10, 10, 10, 10, 14,  "["),
    BYTE(5, 00, 00, 20, 10, 04, 02, 01,  "\"),
    BYTE(5, 06, 02, 02, 02, 02, 02, 06,  "]"),
    BYTE(5, 00, 04, 16, 25, 04, 04, 00,  "^"),
    BYTE(5, 00, 04, 10, 37, 10, 04, 00,  "_"),
    BYTE(5, 14, 10, 04, 00, 00, 00, 00,  "`"),
    BYTE(5, 00, 16, 01, 17, 21, 23, 15,  "a"),
    BYTE(5, 20, 20, 20, 36, 21, 21, 16,  "b"),
    BYTE(5, 00, 00, 16, 20, 20, 20, 16,  "c"),
    BYTE(5, 01, 01, 01, 17, 21, 21, 16,  "d"),
    BYTE(5, 00, 14, 22, 22, 34, 20, 16,  "e"),
    BYTE(5, 06, 11, 10, 36, 10, 10, 10,  "f"),
    BYTE(5, 00, 16, 21, 21, 17, 01, 36,  "g"),
    BYTE(5, 20, 20, 20, 34, 22, 22, 22,  "h"),
    BYTE(5, 00, 04, 00, 04, 04, 04, 16,  "i"),
    BYTE(5, 02, 00, 02, 02, 02, 22, 14,  "j"),
    BYTE(5, 20, 22, 24, 30, 34, 22, 21,  "k"),
    BYTE(5, 10, 10, 10, 10, 10, 10, 06,  "l"),
    BYTE(5, 00, 00, 32, 25, 25, 25, 25,  "m"),
    BYTE(5, 00, 00, 24, 32, 22, 22, 22,  "n"),
    BYTE(5, 00, 00, 16, 21, 21, 21, 16,  "o"),
    BYTE(5, 00, 14, 22, 22, 34, 20, 20,  "p"),
    BYTE(5, 00, 14, 22, 22, 16, 02, 02,  "q"),
    BYTE(5, 00, 00, 26, 11, 10, 10, 10,  "r"),
    BYTE(5, 00, 16, 20, 14, 02, 22, 14,  "s"),
    BYTE(5, 00, 10, 36, 10, 10, 10, 06,  "t"),
    BYTE(5, 00, 00, 22, 22, 22, 22, 16,  "u"),
    BYTE(5, 00, 00, 21, 21, 21, 12, 04,  "v"),
    BYTE(5, 00, 00, 21, 21, 21, 25, 12,  "w"),
    BYTE(5, 00, 00, 21, 12, 04, 12, 21,  "x"),
    BYTE(5, 00, 00, 21, 12, 04, 04, 10,  "y"),
    BYTE(5, 00, 36, 02, 04, 10, 20, 36,  "z"),
    BYTE(5, 06, 10, 10, 20, 10, 10, 06,  "{"),
    BYTE(5, 04, 04, 04, 04, 04, 04, 04,  "|"),
    BYTE(5, 14, 02, 02, 01, 02, 02, 14,  "}"),
    BYTE(5, 00, 00, 10, 25, 02, 00, 00,  "~"),
    BYTE(5, 37, 37, 37, 37, 37, 37, 37,  "Del");

    Own Integer Safe Array Characters[0:'177];

require unstack!delimiters;
boolean procedure edit(reference string on,off;
			reference integer char, letsep;
			integer pattern;
			string array text;
			procedure BlockOne);
begin
	integer i,line;
	string s;
on_"@ "; off_ ". ";
while true 
   do begin	integer ch;
	arrclr(text);
	letsep_0; BlockOne; letsep_1; 
	for i_repeats(7) do print(crlf&":", i, #ht, text[i] );
	do begin print(crlf,"go: "); s_inchwl; end
	 until !skip!=#esc or length(s) neq 0;
	while 0<!skip!<#sp and not(#ht<!skip! leq #cr)
	   do if !skip!=#esc then return(length(s)=0)
				else s_ s & !skip! & inchwl;
	if (ch_lop(s))="?" then print("
Type <ESC> to save, X<ESC> to abort, 
 +<letters> to `OR' in letters,
 -<letters> to `CLEAR' letters,
 *<letters> to `MASK' with letters,
 %<letters> to `XOR' in letters,
 :# <ch> <ch> <ch> <ch> <ch> to replace a line (ch=. or @)
 #=<octal> to directly supply the octal for a line,
or @ to show the current value.")
	eif ch="+" or ch="-" or ch="*" 
	 then begin integer x,v; x_ 0; v_ characters[char]; 
		do x_x lor characters[lop(s)] until length(s)=0;
		characters[char]_ case ch of (["+"] v lor x, 
				["*"] v land x, ["-"] v land lnot x);
	      end
	eif ch="%"
	 then begin integer x; x_ characters[char]; 
		do x_x xor characters[lop(s)] until length(s)=0;
		characters[char]_ x;
	      end
	eif ch=":"
	 then begin	integer line,obp;
		line_intscan(s,!skip!);
		obp_ point(1,characters[char], 30-5*line );
		while ch_lop(s)
		 do if ch="." then idpb(0,obp)
		   eif ch="@" then idpb(1,obp);
	      end
	eif "@" = ch
	 then begin		integer i,op;
		op_ point(5,characters[char],5);
		print(" BYTE(5, ", cvos(ldb(op)) );
		for i_repeats(6) do print(",",cvos(ildb(op)));
		print(", char'", cvos(char), ")" );
	      end
	eif "0" leq ch leq "6" and lop(s)="="
	 then dpb( cvo(s), point(5,characters[char],5*("7"-ch)))
	else print("Try `?'"); 
      end;
end;
string s,spaces;
integer maxlen, letSep, width, filstep;
width_2; letSep_1;
maxLen_ 80-width*(5+letSep);
while true
   do begin	string safe array text[0:6];
		string on,off;
		integer ch,l,b,i;
	procedure BlockOne;
	  begin	integer w,l,b;
	    w_characters[ch];
	    for l_repeats(7) 
	     do begin
		for b_repeats(5) 
		  do text[l]_ text[l] & (if (w_w lsh 1)<0 
					then on else off);
		for b_repeats(letSep) do text[l]_ text[l] & off;
		end;
	  end;
	off_null;
	for i_repeats(width) do off_ off & " ";
	print("Print: "); s_inchwl;
			 while 0<!skip!<#sp and not(#ht<!skip! leq #cr)
				do s_ s & !skip! & inchwl;
	if equ(s,"/HELP") then print(" /EDIT, /EXIT, /HELP, /READ, or /DUMP ")
	eif equ(s,"/DUMP") 
	  then begin integer eof; open(1,"DSK",'17, 0,0, 0,0,eof);
		do begin print("Dump onto binary file: ");
			enter(1,inchwl,eof);
		   end until not eof;
		arryout(1,characters[0],'200);
		release(1);
		print("...Done ");
	      end
	eif equ(s,"/FILE")
	  then begin integer eof; open(1,"DSK",0, 0,2, 0,0,eof);
		do begin print("Dump onto Ascii file: ");
			enter(1,inchwl,eof);
		   end until not eof;
		setformat(-2,0);
		For filstep_0 step 1 until '177 do
	        begin	integer i,op;
		    op_ point(5,characters[filstep],5);
		    cprint(1,"    BYTE(5, ", cvos(ldb(op)) );
		    for i_repeats(6) do cprint(1,", ",cvos(ildb(op)));
		    cprint(1,",  """,if filstep < '40 then cvos(filstep)
				 else cvastr(filstep lsh 29), """),",'15&'12);
		end;
		release(1);
		print("...Done ");
	      end
	eif equ(s,"/READ") 
	  then begin integer eof; open(1,"DSK",'17, 0,0, 0,0,eof);
		print("Dump in binary from file: ");
		lookup(1,inchwl,eof);
		if eof then print("Sorry, cannot find it, try again.")
		 else begin arryin(1,characters[0],'200);
			print("Yum, Yum, That was tasty.");
		      end;
		release(1);
	      end
	eif equ(s,"/EXIT") then call(0,"EXIT")
	eif equ(s,"/EDIT")
	 then begin	integer pattern;
		print("Start with `XOR' of: "); s_inchwl;
			 while 0<!skip!<#sp and not(#ht<!skip! leq #cr)
			 and #esc neq !skip!
				do s_ s & !skip! & inchwl;
		pattern_characters[lop(s)];
		while length(s) do pattern_ pattern 
					xor characters[lop(s)];
		print("Call it character: ");
		characters[ch_inchrw] Swap pattern;
		if not edit(on,off,ch,letsep,pattern,text,BlockOne)
		 then begin
			print("Ok, no replacement done"); 
			characters[ch] Swap pattern;
		      end
		 else print("You just defined a new " & ch);
		s_""" " & ch & " "" it is!";
	      end;
	if length(s)=0 then done;
	arrclr(text);
	while ch_lop(s) 
	do begin
	    on_ ch; for i_repeats(width-1) do on_ on & ch;
	    BlockOne;
	    if length(text[0]) geq maxLen
	     then begin 
		    for l_repeats(7) do print(crlf,text[l]);
		    arrclr(text);
		    print(crlf);
		  end;
	   end;
	if length(text[0]) then for l_repeats(7) do print(crlf,text[l]);
	print(crlf);
      end;

End "BLOCK";
 