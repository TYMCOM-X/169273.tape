	.TITLE	LNKD   - LINK TYPE D - RSX-11 AND RSTS-11 HOST INTERFACE
	.SBTTL	LNKD   - NEXILIS/JRG

	XLPAR			;DON'T LIST PARAMETER FILES

	CODE

;THIS MODULE IMPLEMENTS THE GENERALIZED CHARACTER LEVEL HOST INTERFACE
;  PROTOCOL USING THE DR11-C/DRV11 16 BIT PARALLEL INTERFACE

;THE INTERFACE USED PROVIDES FOR TRANSFER OF 16 BIT WORDS UNDER PROGRAM
;  CONTROL.  THE FOLLOWING BIT-LEVEL PROTOCOL IS USED:
;	COMMAND WORD:
;	  BIT  15   = SET IF THIS IS A SINGLE DATA CHARACTER, CLEAR IF THIS
;			THIS IS A COMMAND OR FUNCTION OR DATA STRING
;	  BITS 14-8 = SOCKET NUMBER
;  IF BIT 15 IS SET:
;	  BITS 7- 0 = DATA CHARACTER
;  IF BIT 15 IS CLEAR:
;	  BIT  7    = SET IF THIS IS A COMMAND OR FUNCTION, CLEAR IF DATA
;			STRING
;  IF BIT 7 IS SET:
;	  BIT  6    = SET IF THIS IS A FUNCTION, CLEAR IF COMMAND
;	  BITS 5- 0 = COMMAND CODE IF COMMAND; BYTE COUNT IF FUNCTION
;  IF BIT 7 IS CLEAR:
;	  BITS 6- 0 = CHARACTER COUNT
;  THE FIRST DATA BYTE IN A FUNCTION SPECIFIES THE FUNCTION.
;  A COMMAND IS COMPLETELY CONTAINED IN A SINGLE - NO DATA FOLLOWS IT.
;  A FUNCTION OR DATA STRING IS FOLLOWED BY SOME NUMBER OF DATA BYTES AS
;    SPECIFIED BY THE COUNT IN THE FIRST WORD.  DATA BYTES ARE SEND TWO PER
;    WORD.  IF AN ODD NUMBER ARE REQUIRED, THE EXTRA BYTE IS SENT, BUT ITS
;    CONTENTS IS UNDEFINED AND MUST BE IGNORED.
	.PAGE
;DEFINE DEFAULT FOR DEBUG SWITCH

.IIF NDF ..DEBG  ..DEBG=!0

;DEFINE HOST FUNCTION CODES - THESE CODES ARE SENT IN THE FIRST DATA BYTE OF
;  A FUNCTION

.HFCON=!1		;CONNECTION REQUEST
.HFACK=!2		;CONNECTION ACK
.HFNAK=!3		;CONNECTION NAK
.HFDIS=!4		;DISCONNECT
.HFKIL=!5		;KILL CONNECTION
.HFCDP=!6		;CHANGE TERMINAL PARAMETERS (SET AND READ)
.HFSDP=!7		;SET TERMINAL PARAMETERS
.HFADP=!10		;ACCESS TERMINAL PARAMETERS
.HFRDP=!11		;REPORT TERMINAL PARAMETERS
.HFDCN=!12		;DEVICE CONTROL
.HFDST=!13		;DEVICE STATUS
.HFRCR=!14		;Reconnect request
.HFRCC=!15		;Reconnect control
.HFBIN=!16		;Output binary characters
.HFBAD=!77		;ILLEGAL FUNCTION!

;DEFINE HOST COMMAND CODES - THESE CODES ARE SENT IN BITS 5-0 OF THE INITIAL
;  DATA WORD

.HCRST=!0		;RESET INTERFACE
.HCRSA=!1		;RESET ACK
.HCPOK=!2		;POKE
.HCSTP=!3		;STOP OUTPUT
.HCRSM=!4		;RESUME OUTPUT
.HCSII=!5		;SOCKET IS IDLE
.HCSIA=!6		;SOCKET IS ACTIVE
.HCDAK=!7		;DISCONNECT ACK
.HCHIN=!10		;HARD INTERRUPT
.HCSIN=!11		;SOFT INTERRUPT
.HCOSA=!12		;OUTPUT SUPPRESS ACK
.HCOPS=!13		;OUTPUT SUPPRESS
.HCOPH=!14		;OUTPUT HOLD
.HCOPA=!15		;OUTPUT ALLOW
.HCKIL=!16		;Kill connection (reason = .ERILD)
.HCCON=!17		;Continue output
.HCFHI=!20		;Force hard interrupt
.HCREQ=!21		;Request (yellow ball)
.HCRSP=!22		;Response (orange ball)
.HCBRK=!23		;Break received or request
.HCRQC=!24		;Request buffer clear
.HCSTR=!25		;Status request
.HCFLR=!26		;Force line retype

;DEFINE BITS FOR THE DR11 STATUS REGISTER

$DVENB=!000140		;INTERRUPT ENABLE
$DVACP=!000002		;BIT TO SET TO ACCEPT INPUT
$DVOUT=!000001		;BIT TO SET TO FLAG OUTPUT AVAILABLE

;DEFINE SERVICE REQUEST BITS (FOR DDLDRQ)

$RQINP=!02		;REQUEST INPUT SERVICE
$RQOUT=!04		;REQUEST OUTPUT SERVICE

;DEFINE INPUT STATE VALUES

.ISWAT=!0		;WAITING FOR MAIN PROGRAM ACTION
.ISIDL=!1		;IDLE (READY FOR INPUT)
.ISWRD=!2		;WAITING FOR NEXT DATA WORD
.ISRST=!3		;RESET (IGNORE ALL EXCEPT POKE AND RESET COMMANDS)
	.PAGE
	.SBTTL	LKDINI - INITIALIZATION

;SUBROUTINE TO INITIALIZE THE HOST INTERFACE ROUTINES
;	CALL	LKDINI

LKDINI::MOV	#DDLDCZ#,R1		;GET NUMBER OF WORDS TO CLEAR
	MOV	#DDLDFC#,R2		;GET FIRST WORD TO CLEAR
	ADD	R4,R2
2$:	CLR	(R2)+			;CLEAR THIS PART OF THE DDB
	SOB	R1,2$
	CLR	@DDLDSR#(R4)		;DOES THIS INTERFACE EXIST?
	NXMJMP	NOLINK#			;NO-GO MARK IT THAT WAY!
	MOV	#$D1DWN,DDSTS1#(R4)	;YES-INDICATE LINK IS DOWN
	TBBN	100000,@DDLDSR#(R4),10$	;IF THIS BIT IS ON THE OTHER SIDE IS
					;NOT INITIALIZED PROPERLY OR THE CABLE IS HANGING
	MOV	#$DVENB,@DDLDSR#(R4)	;ENABLE THE INTERFACE
10$:	MOVB	#.ISRST,DDLDIS#(R4)	;INITIALIZE INPUT STATE
.IF NE ..DEBG
	MOV	#DBRING,DBRNGP		;SET UP DEBUG RING
	MOV	#-1,DBRNGP-2
	MOV	#-1,DBRNGE
.ENDC	;.IF NE ..DEBG
LKDINS::RETURN				;THATS ALL

;SUBROUTINE TO PUT LINK INTO LOAD MODE - THIS IS ILLEGAL FOR A HOST INTERFACE!
;	CALL	LKDLOD
;	C:SET = ERROR (C IS ALWAYS SET!)

LKDLOD::SEC				;INDICATE ERROR (CAN'T LOAD A HOST!)
	RETURN
	.PAGE
	.SBTTL	LKDIIN - INPUT INTERRUPT ROUTINE

;HERE FROM CODE IN COMMON ON INPUT READY INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKDIn:	PUSH	R4		;SAVE R4
;		MOV	#LKDn$,R4	;GET ADDRESS OF DDB
;		JMP	LKDIIN		;GO TO COMMON ROUTINE

LKDIIN::BIC	#$DVACP,@DDLDSR#(R4)	;CLEAR THE HARDWARE FLAG
	PUSH	R0			;SAVE ANOTHER AC
	MOVB	DDLDIS#(R4),R0		;GET INPUT STATE
.IF NE ..DEBG
	MOV	R0,@DBRNGP		;STORE IN DEBUG RING
	ADD	#2,DBRNGP		;BUMP POINTER
	MOV	@DDLDIR#(R4),@DBRNGP	;STORE DATA IN DEBUG RING
	ADD	#2,DBRNGP		;BUMP POINTER
	CMP	#DBRNGE,DBRNGP		;AT END OF RING?
	BHI	2$			;NO
	MOV	#DBRING,DBRNGP		;YES-RESET POINTER
2$:
.ENDC	;.IF NE ..DEBG
	ASL	R0
	ADD	R0,PC			;DISPATCH ON THE INPUT STATE
	BR	INPWAT			;.ISWAT = 0 - INPUT IS WAITING FOR
					;		MAIN PROGRAM LEVEL
	BR	INPIDL			;.ISIDL = 1 - INPUT IS IDLE
	BR	INPDAT			;.ISDAT = 2 - WAITING FOR DATA WORD
;	BR	INPRST			;.ISRST = 3 - RESET

;HERE WHEN WAITING FOR RESET

INPRST:	MOV	@DDLDIR#(R4),R0		;GET DATA WORD
	CMP	#.HCRST+200,R0		;IS IT A RESET COMMAND FOR SOCKET 0?
	BEQ	2$			;YES
	CMP	#.HCRSA+200,R0		;OR A RESET ACK?
	BNE	ZAPLNK			;NO-THIS MAKES US VERY UNHAPPY!
2$:	CLRB	DDLDIS#(R4)		;YES-CLEAR INPUT STATE
	BR	INPID2			;AND GO PROCESS THE COMMAND

;HERE WHEN EXPECTING A DATA WORD

INPDAT:	MOV	@DDLDIR#(R4),@DDLDIP#(R4);GET DATA
	DECB	DDLDIC#(R4)		;REDUCE THE WORD COUNT
	BLE	INPDON			;IF FINISHED NOW
	ADD	#2,DDLDIP#(R4)		;MORE TO GET-BUMP POINTER
INPACP:	BIS	#$DVACP+$DVENB,@DDLDSR#(R4);ACCEPT THE INPUT
INPDSM:	POP	R0			;RESTORE AC'S
	POP	R4
	RTI				;DISMISS INTERRUPT

;HERE WHEN FINISHED DOING INPUT - NOTIFY MAIN PROGRAM LEVEL

INPDON:	CLRB	DDLDIS#(R4)		;SET NEW INPUT STATE
	BISB	#$RQINP,DDLDRQ#(R4)	;REQUEST INPUT SERVICE
	BR	INPDSM			;AND DISMISS INTERRUPT

;HERE IF INPUT IS IDLE NOW

INPIDL:	MOV	@DDLDIR#(R4),R0		;GET THE DATA WORD
INPID2:	MOV	R0,DDLDIX#(R4)		;STORE DATA IN DDB
	BLE	INPDON			;IF JUST SINGLE CHARACTER INPUT OR IF
					;  ALL 0, WHICH IS AN ERROR!)
	TSTB	R0			;IS THIS START OF DATA STRING?
	BMI	2$			;NO-ITS A FUNCTION OR COMMAND
	BIC	#^C177,R0		;YES-GET BYTE COUNT
	BR	4$

2$:	TBBE	100,R0,INPDON		;THATS ALL IF COMMAND
	BIC	#^C77,R0		;FUNCTION-GET BYTE COUNT
4$:	MOVB	R0,DDLDCC#(R4)		;STORE IT
	INC	R0			;CHANGE TO WORD COUNT (ROUND UP)
	ASRB	R0
	MOVB	R0,DDLDIC#(R4)		;STORE WORD COUNT
	CMPB	#PKCMAX/2,R0		;VALID WORD COUNT?
	BLO	ZAPLNK			;NO-SERIOUS ERROR!
	PUSH	R1			;SAVE R1
	MAKPKT	1			;GET A PACKET
	BCC	10$			;IF GOT ONE
	RSTOP	NPA			;[NO PACKET AVAILABLE]

10$:	MOV	R1,DDLDIK#(R4)		;STORE ADDRESS OF PACKET
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLDIP#(R4)		;STORE POINTER
	POP	R1			;RESTORE R1
	INCB	DDLDIS#(R4)		;BUMP INPUT STATE
	BR	INPACP			;AND DISMISS INTERRUPT FOR NOW

;HERE IF GET INPUT INTERRUPT WHILE WAITING FOR MAIN PROGRAM LEVEL TO PROCESS
;  SOME INPUT - THIS IS AN ERROR SINCE WE HAVE NOT YET ACCEPTED THE LAST
;  INPUT WORD!

INPWAT:	INC	DDERSI#(R4)		;COUNT THE FUNNY INTERRUPT!
	BR	INPDSM			;AND TRY TO CONTINUE (PROBABLY WE ARE
					;  TOO SICK TO CONTINUE AT THIS POINT!)

;HERE IF HAVE BAD COUNT

ZAPLNK:	CLR	DDLDIX#(R4)		;CLEAR THE ARGUMENT WORD
	BIC	#$DVENB,@DDLDSR#(R4)	;DISABLE THE INTERFACE
	BR	INPDON			;AND PASS IT TO MAIN PROGRAM LEVEL
	.PAGE
	.SBTTL	LKDOIN - OUTPUT INTERRUPT ROUTINE

;HERE FROM CODE IN COMMON ON OUTPUT DONE INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKDOn:	PUSH	R4		;SAVE R4
;		MOV	$HSn$,R4	;GET ADDRESS OF DDB
;		JMP	LKDOIN		;GO TO COMMON ROUTINE

LKDOIN::BIC	#$DVOUT,@DDLDSR#(R4)	;CLEAR THE OUTPUT FLAG
.IF NE ..DEBG
	MOVB	DDLDOC#(R4),@DBRNGP	;STORE COUNT IN DEBUG RING
	INC	DBRNGP			;BUMP POINTER
	MOVB	#-1,@DBRNGP		;FLAG THIS AS OUTPUT DATA
	INC	DBRNGP			;BUMP POINTER
	MOV	@DDLDOR#(R4),@DBRNGP	;STORE DATA IN RING
	ADD	#2,DBRNGP		;BUMP POINTER
	CMP	#DBRNGE,DBRNGP		;BEYOND END OF RING?
	BHI	2$			;NO
	MOV	#DBRING,DBRNGP		;YES-RESET POINTER
2$:
.ENDC	;.IF NE ..DEBG
	DECB	DDLDOC#(R4)		;ANYMORE TO OUTPUT?
	BLT	OUTDON			;NO
	MOV	@DDLDOP#(R4),@DDLDOR#(R4);YES-OUTPUT DATA WORD
	ADD	#2,DDLDOP#(R4)		;BUMP OUTPUT POINTER
	BIS	#$DVOUT+$DVENB,@DDLDSR#(R4);MAKE IT VISIBLE
OUTDSM:	POP	R4			;RESTORE AC
	RTI				;AND DISMISS

;HERE IF FINISHED WITH THIS PACKET

OUTDON:	BISB	#$RQOUT,DDLDRQ#(R4)	;REQUEST OUTPUT SERVICE
	BR	OUTDSM			;AND DISMISS
	.PAGE
	.SBTTL	LRSUM - SUBROUTINE TO RESUME INPUT FROM HOST

;SUBROUTINE CALLED WHEN ADDITIONAL INPUT CAN BE ACCEPTED FROM A HOST
;	C(SD) = ADDRESS OF SDB
;	CALL	LDRSUM

LDRSUM::TSTB	SDSOC(SD)		;FOR WILD SOCKET?
	BEQ	RTN001			;YES-FORGET IT!
	MOV	#.HCRSM+200,R0		;GET COMMAND
	CJMP	SNDHCM			;SEND IT AND RETURN
	.PAGE
	.SBTTL	LDMAIN   - MAIN PROGRAM ROUTINE

;SUBROUTINE CALLED ONCE EACH TIME THROUGH THE MAIN PROGRAM LOOP

	MAINXX	LDMAIN

LDMAIN:	MOV	#LKDDDB#,R4		;GET FIRST TYPE D LINK DDB
LDMAI1:	MOVB	DDLDRQ#(R4),R0		;GET REQUEST
	ADD	R0,PC			;DISPATCH ON IT
	BR	LDMAI2			;       = 00 - NO REQUEST
	BR	LDINPD			;$RQINP = 02 - INPUT REQUEST
	BR	LDXOUT			;$RQOUT = 04 - OUTPUT REQUEST
	BR	LDINPD			;       = 06

;HERE IF OUTPUT IS DONE

LDXOUT:	JMP	LDOUTD			;GO TO THE OUTPUT ROUTINE

;HERE IF NO REQUEST FOR THIS DDB

LDMAI2:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE D LINK DDB
	BNE	LDMAI1			;CONTINUE IF ANOTHER
RTN001:	RETURN				;FINISHED
	.PAGE
;HERE IF INPUT IS DONE

LDINPD:	BICB	#$RQINP,DDLDRQ#(R4)	;CLEAR THE INPUT REQUEST
	MOVB	#40.,DDLDTM#(R4)	;START THE MESSAGE TIMER
	MOV	DDLDIX#(R4),R0		;GET FIRST INPUT WORD
	BPL	LDINP1			;IF NOT SINGLE CHARACTER
	MAKPKT	1			;GET A PACKET
	BCC	2$
	RSTOP	NPA			;[NO PACKET AVAILABLE]

2$:	MOVB	R0,PKDATA(R1)		;STORE CHARACTER IN PACKET
	MOVB	#1,PKCNT(R1)		;SET COUNT
	BIC	#100000,R0		;REMOVE JUNK
	BR	LDINP2			;CONTINUE

;HERE IF NOT SINGLE CHARACTER

LDINP1:	BEQ	LDSIC0			;ZERO IS ILLEGAL HERE!
	MOV	DDLDIK#(R4),R1		;GET ADDRESS OF INPUT PACKET
	CLR	DDLDIK#(R4)		;CLEAR POINTER
	TSTB	R0
	BMI	LDINP3			;IF NOT DATA STRING
	MOVB	R0,PKCNT(R1)		;STORE BYTE COUNT
	BNE	LDINP2			;OK IF NOT ZERO
	FREPKT				;GIVE UP THE PACKET
LDSIC0:	JMP	LDSICK			;ZERO IS A BAD ERROR!

LDINP2:	CLRB	PKTYPE(R1)		;INDICATE DATA PACKET
	SWAB	R0			;GET SOCKET NUMBER
	MOVB	R0,PKSOC(R1)		;STORE SOCKET NUMBER
	JMP	LDINP9			;CONTINUE

;HERE IF NOT DATA PACKET

LDINP3:	TBBE	100,R0,LDINP4		;IS THIS A HOST FUNCTION?
	JMP	LDINP6			;YES-GO HANDLE IT

;HERE IF HOST COMMAND

LDINP4:	BIC	#^C77,R0		;GET COMMAND VALUE
	CMP	#MAXHSC,R0		;VALID COMMAND?
	BLO	LDSIC0			;NO-BIG TROUBLE!
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE COMMAND
LDIHCD:	BR	HXREST			;.HCRST =  0 - RESET INTERFACE
	BR	HXRESA			;.HCRSA =  1 - RESET ACK
	BR	LDDON0			;.HCPOK =  2 - POKE
	BR	HXSTOP			;.HCSTP =  3 - STOP OUTPUT
	BR	HXRSUM			;.HCRSM =  4 - RESUME OUTPUT
	BR	HXSIID			;.HCSII =  5 - SOCKET IS IDLE
	BR	HXSIAC			;.HCSIA =  6 - SOCKET IS ACTIVE
	BR	HXDACK			;.HCDAK =  7 - DISCONNECT ACK
	BR	HXFNPK			;.HCHIN = 10 - HARD INTERRUPT
	BR	HXFNPK			;.HCSIN = 11 - SOFT INTERRUPT
	BR	HXFNPK			;.HCOSA = 12 - OUTPUT SUPPRESS ACK
	BR	HXFNPK			;.HCOPS = 13 - OUTPUT SUPPRESS
	BR	HXFNPK			;.HCOPH = 14 - OUTPUT HOLD
	BR	HXFNPK			;.HCOPA = 15 - OUTPUT ALLOW
	BR	HXKILL			;.HCKIL = 16 - KILL CONNECTION (REASON
					;		 = .ERILD)
	BR	HXFNPK			;.HCCON = 17 - CONTINUE OUTPUT
	BR	HXFNPK			;.HCFHI = 20 - FORCE HARD INTERRUPT
	BR	HXFNPK			;.HCREQ = 21 - Request (yellow ball)
	BR	HXFNPK			;.HCRSP = 22 - Response (orange ball)
	BR	HXFNPK			;.HCBRK = 23 - Bread received or request
	BR	HXFNPK			;.HCRQC = 24 - Request buffer clear
	BR	HXFNPK			;.HCSTR = 25 - Status request
	BR	HXFNPK			;.HCFLR = 26 - Force line retype
MAXHSC=!<.-LDIHCD>/2-1

;HERE FOR KILL CONNECTION COMMAND - HOST USES THIS COMMAND TO RESPOND TO
;  A .HCSIA ON AN IDLE SOCKET BECAUSE IT IS EASIER THAT USING .HFKIL!

HXKILL:	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	LDDON0			;FORGET IT IF CAN'T GET ONE!
	MOV	#<.PTKIL*400>+1,PKCNT(R1);STORE TYPE AND COUNT
	MOVB	#.ERILD,PKDATA(R1)	;STORE ERROR CODE AS DATA
	BR	HXFNP2			;CONTINUE

;HERE FOR COMMANDS WHICH GENERATE A FUNCTION TYPE PACKET (.PTFUN, .PTINT, OR
;  .PTEAT)

HXFNPK:	MAKPKT	1			;GET A PACKET
	BCS	HXFAIL			;IF CAN'T GET ONE!
	MOVB	DDLDIX#(R4),R0		;GET COMMAND AGAIN
	BIC	#^C77,R0
	MOVB	CMDPKT(R0),PKTYPE(R1)	;STORE PACKET TYPE IN PACKET
	MOVB	CMDFNC(R0),PKDATA(R1)	;STORE FUNCTION CODE IN PACKET
	MOVB	#1,PKCNT(R1)		;PACKET CONTAINS 1 BYTE
HXFNP2:	MOVB	DDLDIX#+1(R4),PKSOC(R1)	;PUT SOCKET NUMBER IN PACKET
	BR	HXSIX2			;CONTINUE

;HERE IF CAN'T GET PACKET FOR CONTROL PACKET

HXFAIL:	RSTOP	NPA			;[CAN'T GET PACKET]

;HERE FOR "DISCONNECT ACK" COMMAND

HXDACK:	MAKPKT	1			;Get a packet
	BCS	HXFAIL			;Do something better later
	MOV	#.PTDAK*400,PKCNT(R1)	;Make into Disconnect ACK packet
	BR	HXFNP2			;Go send it

;HERE FOR "SOCKET IS ACTIVE" COMMAND

HXSIAC:	MOV	#.SPSIA*400+1,R0	;GET PACKET TYPE AND COUNT
	BR	HXSIXX			;CONTINUE

;HERE FOR "SOCKET IS IDLE" COMMAND

HXSIID:	MOV	#.SPSII*400+1,R0	;GET PACKET TYPE AND COUNT
HXSIXX:	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	LDDON0			;FORGET IT IF CAN'T GET A PACKET!
	MOV	R0,PKCNT(R1)		;STORE PACKET TYPE AND COUNT
	CLRB	PKSOC(R1)		;SOCKET = 0
	MOVB	DDLDIX#+1(R4),PKDATA(R1);STORE SOCKET NUMBER AS DATA BYTE
HXSIX2:	CALL	MOVPKT#			;SEND THE PACKET
	BR	LDDON0			;THATS ALL

;HERE FOR "RESUME OUTPUT" COMMAND

HXRSUM:	CALL	FNDSDB			;SETUP SD
	BCS	BADSOC			;IF ERROR
	BIC	#$S1HLD,SDSTS1#(SD)	;INDICATE CAN DO OUTPUT NOW
	MOV	SDPKDH#(SD),R1		;ANYTHING TO OUTPUT NOW?
	BEQ	LDDONE			;NO
	CALL	LKPOKE#			;YES-START OUTPUT
LDDON0:	BR	LDDONE			;FINISHED

;HERE FOR "STOP OUTPUT" COMMAND

HXSTOP:	CALL	FNDSDB			;SETUP SD
	BCS	BADSOC			;IF ERROR
	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE NO MORE OUTPUT
	BR	LDDONE			;THATS IT!
	.PAGE
;HERE FOR "RESET" COMMAND - THIS COMMAND IS SENT BY THE HOST WHEN IT FIRST
;  COMES UP AND EVERY 10 SECONDS AFTER THAT UNTIL WE RESPOND WITH A "RESET"
;  COMMAND.  IT IS ALSO SENT IN PLACE OF A "POKE" WHENEVER THE HOSTS THINKS
;  WE ARE DOWN.

HXREST:	TSTB	DDLDIX#+1(R4)		;IS THIS COMMAND ON THE WILD SOCKET?
	BNE	LDSICK			;NO-BAD ERROR!
	TBBE	$D1DWN,DDSTS1#(R4),LDSICK;GO DOWN IF UP NOW
	BIC	#$DVOUT,@DDLDSR#(R4)	;DOWN-SEND BACK A "RESET ACK"
	MOV	#.HCRSA+200,R0
	CALL	LKDSTQ			;AND FALL INTO RESET ACK ROUTINE

;HERE FOR "RESET ACK" COMMAND

HXRESA:	TSTB	DDLDIX#+1(R4)		;IS THIS COMMAND ON THE WILD SOCKET?
	BNE	LDSICK			;NO-BAD ERROR!
	TBBE	$D1DWN,DDSTS1#(R4),LDDONE;IS THIS HOST DOWN NOW?
	CALL	LNKUP#			;YES-BUT NOT ANY MORE!
	MOVB	#40.,DDLDTM#(R4)	;Start the message timer
	BR	LDDONE			;THATS ALL

;HERE IF SOCKET NUMBER IS BAD AND WE DETECT IT HERE (ONLY HAPPENS FOR COMMANDS
;  - OTHERWISE IT WILL BE DETECTED BY MOVPKT)

BADSOX:	FREPKT				;GIVE UP THE PACKET
BADSOC:	INC	DDERIS#(R4)		;COUNT THE ERROR
	RSTOP	BSN			;[BAD SOCKET NUMBER] *** DEBUG ONLY ***
	BR	LDDONE			;THATS ALL

;HERE FOR SERIOUS ERROR - "DOWN" THE LINK AND DISABLE IT FOR 10 SECONDS

LDSICX:	FREPKT				;GIVE UP THE PACKET
LDSICK:	CALL	LKDDWN			;PUT IT DOWN
	BR	LDDON2			;THATS ALL!
	.PAGE
;HERE FOR HOST FUNCTION FROM THE HOST

LDINP6:	BIC	#^C77,R0		;REMOVE JUNK FROM BYTE COUNT
	MOVB	R0,PKCNT(R1)		;STORE BYTE COUNT
	MOVB	PKDATA(R1),R0		;GET FUNCTION CODE
	CMP	#HFCMAX,R0		;LEGAL VALUE?
	BLOS	LDSICX			;NO-LOOSE BIG!
	MOVB	HFCFNC(R0),R2		;YES-GET FUNCTION PACKET FUNCTION VALUE
	BEQ	4$			;IF NOT FUNCTION PACKET
	MOVB	R2,PKDATA(R1)		;STORE FUNCTION VALUE
	BR	LDINP7			;CONTINUE

;HERE IF THIS HOST FUNCTION DOES NOT GENERATE A FUNCTION TYPE PACKET

4$:	PUSH	R0			;SAVE HOST FUNCTION VALUE
	CLR	R2			;GET BYTE COUNT
	BISB	PKCNT(R1),R2
	MOV	R1,R0			;COPY ADDRESS
	ADD	#PKDATA,R0		;POINT TO FIRST DATA BYTE
	MOV	R0,R3			;COPY ADDRESS
	INC	R0			;POINT TO SECOND DATA BYTE
6$:	MOVB	(R0)+,(R3)+		;MOVE IT ALL UP A BYTE!
	SOB	R2,6$			;LOOP
	DECB	PKCNT(R1)		;FIX UP THE BYTE COUNT
	POP	R0			;RESTORE FUNCTION
LDINP7:	MOVB	HFCPKT(R0),R0		;GET PACKET TYPE
	BEQ	LDSICX			;IF ERROR
	BPL	2$			;DOES THIS FUNCTION IMPLY RESUME?
	PUSH	R0			;YES-SAVE FUNCTION
	CALL	FNDSDB			;FIND THE SDB FOR THE SOCKET
	POP	R0			;RESTORE FUNCTION
	BCS	BADSOX			;IF BAD SOCKET NUMBER
	BIC	#$S1HLD,SDSTS1#(SD)	;CLEAR THE FLAG
	BIC	#^C177,R0		;REMOVE JUNK FROM THE PACKET TYPE
2$:	MOVB	R0,PKTYPE(R1)		;STORE PACKET TYPE
	MOVB	DDLDIX+1(R4),PKSOC(R1)	;STORE SOCKET NUMBER
LDINP9:	JSR	PC,MOVPKT#		;SEND THE PACKET
	TST	SD			;VALID SOCKET?
	BEQ	BADSOC			;NO!
	TSTB	SDSOC#(SD)		;YES-IS THIS THE WILD SOCKET?
	BEQ	LDDONE			;YES-DON'T DO FLOW CONTROL STUFF
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;NO-DO WE WANT MORE INPUT NOW?
	BHIS	2$			;YES
	BIS	#$S1STP,SDSTS1#(SD)	;NO-INDICATE WE HAVE STOPPED HIM
	BR	LDDONE

2$:	BIC	#$S1STP,SDSTS1#(SD)	;YES-INDICATE WE LET HIM CONTINUE
	MOV	#.HCRSM+200,R0		;GET HOST COMMAND = RESUME
	CALL	SNDHCM			;SEND COMMAND TO HOST
LDDONE:	MOVB	#.ISIDL,DDLDIS#(R4)	;SET NEW INPUT STATE
	BIS	#$DVACP+$DVENB,@DDLDSR#(R4);ACCEPT THE LAST INPUT WORD
LDDON2:	BITB	#$RQOUT,DDLDRQ#(R4)	;IS THERE AN OUTPUT REQUEST NOW?
	BNE	LDOUTD			;YES-GO SERVICE IT
	JMP	LDMAI2			;NO-FINISHED WITH THIS DDB FOR NOW
	.PAGE
;HERE WHEN OUTPUT IS FINISHED

LDOUTD:	BICB	#$RQOUT,DDLDRQ#(R4)	;CLEAR OUTPUT REQUEST
	MOV	DDLDOK#(R4),R1		;DO WE HAVE AN OUTPUT PACKET?
	BEQ	LDOUT1			;NO-GO ON
	CLR	DDLDOK#(R4)		;YES-CLEAR POINTER
	MOV	DDLDOZ#(R4),SD		;GET ASSOCIATED SDB
	CALL	GIVPKT#			;GIVE UP THE PACKET
LDOUT1:	MOV	DDLKFH#(R4),SD		;ANY SPECIAL COMMANDS TO SEND?
	BNE	LDOUT7			;YES-GO DO THAT
	CALL	NXTPKT#			;NO-GET NEXT PACKET TO SEND
	BCS	LDOUT8			;IF NONE THERE
	BEQ	10$			;IF SUPERVISORY PACKET
	CALL	DECPCN#			;REDUCE SENDER'S COUNT
	CALL	REMOVE#			;REMOVE PACKET FROM DST LIST
4$:	CALL	LKDSTR			;START OUTPUT
6$:	JMP	LDMAI2			;THATS ALL FOR NOW

;HERE IF SUPERVISORY PACKET

10$:	CALL	LKDST0			;START OUTPUT
	BR	6$			;THATS ALL

;HERE FROM NXTPKT IF NXTPKT FINDS ANY SDB'S IN THE FLAG LIST - THIS IS
;  IMPOSSIBLE SINCE WE PROCESS THE FLAG OURS AND DON'T CALL NXTPKT
;  UNLESS THE FLAG IS EMPTY!!

LDOUTX::RSTOP	FNE			;[FLAG LIST NOT EMPTY]

;HERE WITH SPECIAL COMMAND TO SEND

LDOUT7:	MOV	SDLKFL#(SD),DDLKFH#(R4)	;REMOVE SDB FROM LIST
	BNE	2$			;IF LIST NOT EMPTY NOW
	CLR	DDLKFT#(R4)		;EMPTY-CLEAR TAIL POINTER
2$:	CLR	R0
	BISB	SDFCNT#(SD),R0		;GET COMMAND
	CLRB	SDFCNT#(SD)
	MOVB	SDSOC#(SD),R2
	CLRB	DDLDOC#(R4)		;CLEAR OUTPUT COUNT
	CALL	LKDSTW			;SEND IT
	JMP	LDMAI2			;THATS ALL

;HERE IF NOTHING TO OUTPUT NOW

LDOUT8:	BIC	#$D1ACT,DDSTS1#(R4)	;INDICATE OUTPUT NOT ACTIVE NOW
	JMP	LDMAI2			;FINISHED HERE
	.PAGE
;SUBROUTINE TO SEND COMMAND TO HOST
;	C(R0) = COMMAND CODE
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	SNDHCM

SNDHCM:	TBBN	$D1ACT,DDSTS1#(R4),SNDHC2;IS DEVICE ACTIVE NOW?
	MOVB	SDSOC#(SD),R2
	SWAB	R2
	BIS	R2,R0
LKDSTQ:	CLRB	DDLDOC#(R4)		;NO-CLEAR OUTPUT COUNT
	BR	LKDSTX			;AND GO START OUTPUT

;HERE IF DEVICE IS ACTIVE NOW

SNDHC2:	TSTB	SDFCNT#(SD)		;ALREADY WAITING TO SEND A COMMAND?
	BNE	2$			;YES
	MOV	DDLKFT#(R4),R2		;NO-GET CURRENT TAIL OF LIST
	BEQ	2$			;IF LIST IS EMPTY
	MOV	SD,SDLKFL#(R2)		;NOT EMPTY-LINK TO END
	BR	3$			;CONTINUE

2$:	MOV	SD,DDLKFH#(R4)		;EMPTY LIST-STORE NEW HEAD POINTER
3$:	MOV	SD,DDLKFT#(R4)		;UPDATE TAIL POINTER
	CLR	SDLKFL#(SD)		;CLEAR FORWARD LINK
4$:	MOVB	R0,SDFCNT#(SD)		;STORE DATA TO SEND
	RETURN				;FINISHED
	.PAGE
;SUBROUTINE TO START OUTPUT TO HOST
;	C(R1) = ADDRESS OF PACKET TO SEND
;	C(SD) = ADDRESS OF SDB
;	C(R4) = ADDRESS OF ADB
;	CALL	LKDSTR
;	C:CLR  ALWAYS (SINCE THIS ROUTINE ALWAYS STARTS OUTPUT WHEN CALLED!)

LKDSTR::CALL	LKDST0			;Start output
	MOV	SDPKDH#(SD),R1		;Is there another packet to output?
	BEQ	6$			;No-finished here
	CALL	CHKRSP#			;Yes-can we send it now?
	BMI	6$			;No
	CALL	LKPOK0#			;Yes-put this SDB on the send list
6$:	CLC				;Be safe and clear C here again!
	RETURN				;Finished

;Next level subroutine to start output-does everything except put the socket
;  back in the send list!

LKDST0:	PUSHB	SDSOC(SD)		;SAVE SOCKET NUMBER ON THE STACK
	BEQ	LKDWLD			;IF FOR WILD SOCKET
LKDST1:	MOV	R1,R3			;COPY ADDRESS
	ADD	#PKDATA,R3		;POINT TO FIRST DATA BYTE
	CLR	R2			;GET BYTE COUNT FROM PACKET
	BISB	PKCNT(R1),R2
	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	BEQ	LKDST5			;IF DATA PACKET
	MOVB	PKTFNC(R0),R0		;GET HOST COMMAND OR FUNCTION
	BNE	LKDST2			;IF NOT FUNCTION PACKET
	MOVB	PKDATA(R1),R0		;GET FUNCTION CODE
	CMP	R0,#FNCFMX		;LEGAL VALUE?
	BLOS	2$			;YES
	MOV	#FNCFMX,R0		;NO-GIVE THE HOST A BAD FUNCTION!
2$:	MOVB	FNCFNC(R0),R0		;GET CORRESPONDING HOST COMMAND OR
					;  FUNCTION
	BMI	LKDSTA			;IF COMMAND
	BR	LKDST3			;CONTINUE

;HERE IF WE HAVE A PACKET WHICH IS NOT A FUNCTION TYPE PACKET (.PTFUN, .PTINT,
;  OR .PTEAT) WHICH GENERATES A HOST FUNCTION.  WE MUST MOVE EVERYTHING
;  DOWN 1 BYTE TO MAKE ROOM FOR THE FUNCTION CODE!

LKDST2:	BMI	LKDSTA			;IF COMMAND
	PUSH	R0			;SAVE HOST FUNCTION VALUE
	MOV	R1,R0			;COPY PACKET ADDRESS
	ADD	#PKDATA,R0		;POINT TO FIRST DATA BYTE
	ADD	R2,R0			;POINT TO LAST DATA BYTE + 1
	MOV	R0,R3			;COPY ADDRESS
	INC	R3			;POINT TO LAST DATA BYTE + 2
2$:	MOVB	-(R0),-(R3)		;COPY DATA BYTE
	SOB	R2,2$			;LOOP
	INCB	PKCNT(R1)		;FIX UP THE COUNT
	POPB	PKDATA(R1)		;STORE HOST FUNCTION VALUE
	MOVB	PKCNT(R1),R2		;GET MODIFIED COUNT
	BR	LKDST4

;HERE IF THIS IS A FUNCTION TYPE PACKET - WE ALREADY HAVE A HOLE FOR THE
;  HOST FUNCTION VALUE

LKDST3:	MOVB	R0,PKDATA(R1)		;STORE FUNCTION
LKDST4:	MOV	R2,R0			;COPY COUNT
	BIS	#300,R0			;INDICATE HOST FUNCTION
	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE SHOULD WAIT FOR RESUME
					;  COMMAND FROM HOST BEFORE DOING MORE
					;  OUTPUT
	BR	LKDST8			;CONTINUE

;HERE IF HOST COMMAND (A HOST COMMAND IS SENT COMPLETE IN THE INITIAL DATA
;  WORD - NOTHING FOLLOWING IT)

LKDSTA:	BIC	#^C377,R0		;REMOVE JUNK
	BR	LKDST6			;CONTINUE

;HERE IF DATA PACKET

LKDST5:	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE SHOULD WAIT FOR RESUME
					;  COMMAND FROM HOST BEFORE DOING MORE
					;  OUTPUT
	CMP	#1,R2			;JUST ONE CHARACTER?
	BNE	LKDST7			;NO-GO ON
	MOV	#100000,R0		;YES-SET FLAG BIT
	BISB	PKDATA(R1),R0		;GET THE CHARACTER
LKDST6:	PUSH	R0			;SAVE DATA WORD
	CALL	GIVPKT			;GIVE UP THE PACKET
	POP	R0			;RESTORE DATA WORD
	CLR	R2			;CLEAR COUNT (NOTHING FOLLOWS)
	BR	LKDST9			;CONTINUE

;HERE IF HAVE MORE THAN ONE CHARACTER TO SEND

LKDST7:	MOV	R2,R0			;COPY BYTE COUNT
LKDST8:	INC	R2			;GET WORD COUNT (ROUND UP)
	ASR	R2
	MOV	R1,DDLDOK#(R4)		;STORE PACKET ADDRESS
	ADD	#PKDATA,R1		;POINT TO FIRST BYTE
	MOV	R1,DDLDOP#(R4)		;STORE OUTPUT POINTER
	MOV	SD,DDLDOZ#(R4)		;STORE SDB ADDRESS
LKDST9:	MOVB	R2,DDLDOC#(R4)		;STORE WORD COUNT
	POPB	R2			;GET SOCKET NUMBER
LKDSTW:	SWAB	R2			;GET IN THE RIGHT PLACE
	BIS	R2,R0			;MERGE WITH COMMAND OR STRING COUNT
LKDSTX:	BIS	#$D1ACT,DDSTS1#(R4)	;INDICATE OUTPUT IS ACTIVE
LKDSTY:	MOV	R0,@DDLDOR#(R4)		;OUTPUT THE WORD
	CLC				;MAKE SURE C IS CLEAR
	BIS	#$DVOUT+$DVENB,@DDLDSR#(R4);MAKE IT VISIBLE
	RETURN				;FINISHED

;HERE IF PACKET IS FOR WILD SOCKET

LKDWLD:	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE PACKET TYPE
	BR	LKDST1			;.SPRSP =  0 - RESPONSE (IMPOSSIBLE)
	BR	LKDST1			;.SPCON =  1 - CONNECTION REQUEST
	BR	LKDST1			;.SPACK =  2 - CONNECT ACK
	BR	LKDST1			;.SPNAK =  3 - CONNECT NAK
	BR	LKDSII			;.SPSII =  4 - SOCKET IS IDLE
	BR	LKDSIA			;.SPSIA =  5 - SOCKET IS ACTIVE

;HERE FOR SOCKET IS IDLE PACKET FOR WILD SOCKET

LKDSII:	MOV	#.HCSII+200,R0		;GET HOST FUNCTION
	BR	LKDSI2			;CONTINUE

;HERE FOR SOCKET IS ACTIVE PACKET FOR WILD SOCKET

LKDSIA:	MOV	#.HCSIA+200,R0		;GET HOST FUNCTION
LKDSI2:	MOVB	PKDATA(R1),(SP)		;PUT SOCKET NUMBER ON THE STACK
	BR	LKDST6			;CONTINUE
	.PAGE
;SUBROUTINE TO FIND ADDRESS OF SDB FOR SOCKET
;	C(R4) = ADDRESS OF DDB
;	CALL	FNDSDB
;	C:SET = ILLEGAL SOCKET NUMBER
;	C(R4) = UNCHANGED
;	C(SD) = ADDRESS OF SDB

FNDSDB:	MOVB	DDLDIX#+1(R4),SD	;GET SOCKET NUMBER
	BEQ	FNDSD2			;IF WILD SOCKET
	CMPB	DDSOC#(R4),SD		;VALID SOCKET NUMBER?
	BLO	RTNCS7			;NO-GIVE ERROR RETURN
	ASL	SD			;YES
	ADD	DDSX#(R4),SD
	MOV	-(SD),SD		;GET ADDRESS OF SDB FOR SOCKET
RTNCC7:	CLC				;INDICATE GOOD RETURN
	RETURN

;HERE IF WILD SOCKET

FNDSD2:	MOV	DDWLD#(R4),SD		;GET WILD DDB
	BR	RTNCC7

RTNCS7:	SEC
	RETURN
	.PAGE
;SUBROUTINE TO MARK THIS INTERFACE AS DOWN
;	CALL	LKDDWN

LKDDWN:	CLR	@DDLDSR#(R4)		;DISABLE THE INTERFACE
	CLR	@DDLDOR#(R4)		;CLEAN UP OUR END
	MOV	DDLDOK#(R4),R1		;DO WE HAVE AN OUTPUT PACKET
	BEQ	2$			;NO-GO ON
	CLR	DDLDOK#(R4)		;YES
	MOV	DDLDOZ#(R4),SD		;GET ASSOCIATED SDB
	CALL	GIVPKT#			;GIVE UP THE PACKET
2$:	MOV	DDLDIK#(R4),R1		;DO WE HAVE AN INPUT PACKET?
	BEQ	4$			;NO
	CLR	DDLDIK#(R4)		;YES
	FREPKT				;GIVE IT UP
4$:	CLRB	DDLDOC#(R4)		;CLEAR OUTPUT COUNT
	MOVB	#.ISRST,DDLDIS#(R4)	;SET INPUT INTERRUPT STATE
	CLRB	DDLDRQ#(R4)		;CLEAR SERVICE REQUEST BITS
	CLRB	DDLDTM#(R4)		;CLEAR MESSAGE TIMER
	CLRB	DDLDTD#(R4)		;CLEAR DATA TIMER
	BIC	#$D1ACT,DDSTS1#(R4)	;CLEAR ACTIVE FLAG
	CALL	LNKDWN#			;MARK AS DOWN AT LINK LEVEL
	BIS	#$D1DIS,DDSTS1#(R4)	;INDICATE DISABLED
	MOV	R4,SD			;SD IS THE ONLY REGISTER SAVED BY TIMREQ
	MOV	#JIFX10#,R0		;WAIT FOR 10 SECONDS
	MOV	#LKDRDY,R1		;Get the routine address
	CALL	TIMREQ#
	BCC	RTN004			;WAIT IF TIMER REQUEST WORKED
LKDRDY:	CLR	@DDLDSR#(SD)		;MAKE SURE INTERRUPT BITS ARE CLEAR
	BIC	#$D1DIS,DDSTS1#(SD)	;NOT DISABLED NOW
	TBBE	100000,@DDLDSR#(SD),10$	;SEE IF OTHER SIDE IS READY
	CMP	#-1,@DDLDIR#(SD)	;IS THE CABLE HANGING LOOSE
	BEQ	RTN004			;YES, DON'T TURN ON INTERRUPTS	
10$:	BIS	#$DVENB,@DDLDSR#(SD)	;ENABLE THE HARDWARE
RTN004:	RETURN				;FINISHED
	.PAGE
	.SBTTL	LKDSEC - ONCE-A-SECOND ROUTINES

;SUBROUTINE ONCE-A-SECOND AT MAIN PROGRAM LEVEL
;	CALL	LKDSEC

	ONCSEC	LKDSEC

LKDSEC:	MOV	#LKDDDB#,R4		;GET FIRST TYPE D DDB
1$:	TBBN	$D1UNV!$D1DIS,DDSTS1#(R4),20$;SHOULD WE USE THIS INTERFACE?
	TSTB	DDLDTD#(R4)		;YES-IS THE DATA TIMER ACTIVE?
	BEQ	4$			;NO-GO ON
	DECB	DDLDTD#(R4)		;YES-HAS IT RUN OUT?
	BLE	6$			;YES
4$:	TSTB	DDLDTM#(R4)		;IS THE MESSAGE TIMER ACTIVE?
	BEQ	20$			;NO
	DECB	DDLDTM#(R4)		;YES-HAS IT RUN OUT YET?
	BGT	20$			;N0
6$:	TBBN	$NSNOT,NODSTS#,20$	;SHOULD WE TIME IT OUT?
	CALL	LKDDWN			;YES-WE ARE DOWN!
20$:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE D LINK DDB
	BNE	1$			;CONTINUE IF ANOTHER ONE
	DECB	LKDTNS			;TIME FOR EVERY TEN SECONDS STUFF?
	BGT	RTN009			;NO-FINISHED HERE
	MOVB	10.,LKDTNS		;YES-RESET COUNTER
	MOV	#LKDDDB#,R4		;GET FIRST DDB
22$:	TBBN	$D1DIS,DDSTS1#(R4),26$	;SKIP THIS IF DISABLED
	TBBN	$D1DWN,DDSTS1#(R4),24$	;IF HOST IS DOWN

;HERE IF HOST IS UP

	TBBN	$D1ACT,DDSTS1#(R4),26$	;NOTHING NEEDED IF ACTIVE
	MOV	#.HCPOK+200,R0		;NOT ACTIVE-SEND POKE COMMAND
	CALL	LKDSTQ
	BR	26$			;CONTINUE

;HERE IF HOST IS DOWN

24$:	BIC	#$DVOUT,@DDLDSR#(R4)	;SEND RESET COMMAND
	CMP	#-1,@DDLDIR#(R4)	;DOES THE OTHER END LOOK OK
	BEQ	26$			;NO, LOOKS LIKE CABLE HANGING LOOSE
	MOV	#.HCRST+200,R0
	CLRB	DDLDOC#(R4)
	CALL	LKDSTY
26$:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE D DDB
	BNE	22$			;CONTINUE IF MORE
RTN009:	RETURN				;FINISHED
	.PAGE
	.SBTTL	DATA

	PURE

;TABLE WHICH GIVES NETWORK PACKET FOR EACH HOST FUNCTION

HFCPKT:	.BYTE	0		;       =  0 - ILLEGAL
	.BYTE	.PTCON		;.HFCON =  1 - CONNECTION REQUEST
	.BYTE	.PTACK+200	;.HFACK =  2 - CONNECT ACK
	.BYTE	.PTNAK+200	;.HFNAK =  3 - CONNECT NAK
	.BYTE	.PTDIS		;.HFDIS =  4 - DISCONNECT
	.BYTE	.PTKIL		;.HFKIL =  5 - KILL CONNECTION
	.BYTE	.PTFUN		;.HFCDP =  6 - CHANGE TERMINAL PARAMETERS
	.BYTE	.PTFUN		;.HFSDP =  7 - SET TERMINAL PARAMETERS
	.BYTE	.PTINT		;.HFADP = 10 - ACCESS TERMINAL PARAMETERS
	.BYTE	.PTINT		;.HFRDP = 11 - REPORT TERMINAL PARAMETERS
	.BYTE	.PTFUN		;.HFDCN = 12 - DEVICE CONTROL
	.BYTE	.PTFUN		;.HFDST = 13 - DEVICE STATUS
	.BYTE	.PTRCR		;.HFRCR = 14 - Reconnect request
	.BYTE	.PTFUN		;.HFRCC = 15 - Reconnect control
	.BYTE	.PTFUN		;.HFBIN = 16 - Output binary characters
HFCMAX=!.-HFCPKT

;TABLE WHICH GIVES NETWORK FUNCTION PACKET FUNCTION CODE FOR EACH HOST FUNCTION

HFCFNC:	.BYTE	0		;       =  0 - ILLEGAL
	.BYTE	0		;.HFCON =  1 - CONNECTION REQUEST
	.BYTE	0		;.HFACK =  2 - CONNECT ACK
	.BYTE	0		;.HFNAK =  3 - CONNECT NAK
	.BYTE	0		;.HFDIS =  4 - DISCONNECT
	.BYTE	0		;.HFKIL =  5 - KILL CONNECTION
	.BYTE	.FNCDP		;.HFCDP =  6 - CHANGE TERMINAL PARAMETERS
	.BYTE	.FNSDP		;.HFSDP =  7 - SET TERMINAL PARAMETERS
	.BYTE	.FNADP		;.HFADP = 10 - ACCESS TERMINAL PARAMETERS
	.BYTE	.FNRDP		;.HFRDP = 11 - REPORT TERMINAL PARAMETERS
	.BYTE	.FNDCN		;.HFDCN = 12 - DEVICE CONTROL
	.BYTE	.FNDST		;.HFDST = 13 - DEVICE STATUS
	.BYTE	0		;.HFRCR = 14 - Reconnect request
	.BYTE	.FNRCC		;.HFRCC = 15 - Reconnect control
	.BYTE	.FNBIN		;.HFBIN = 16 - Output binary characters

;TABLE WHICH GIVES HOST FUNCTION CODE WHICH CORRESPONDS TO EACH PACKET TYPE
;  IF THE ENTRY IS 0, THE PACKET IS A FUNCTION TYPE PACKET AND WE MUST LOOK
;  AT THE FIRST DATA BYTE IN THE PACKET TO DETERMINE THE HOST FUNCTION CODE
;  (SEE TABLE FNCFNC)

PKTFNC:	.BYTE	0		;.PTDAT =  0 - DATA
	.BYTE	.HFCON		;.PTCON =  1 - CONNECTION REQUEST
	.BYTE	.HFACK		;.PTACK =  2 - CONNECTION ACK
	.BYTE	.HFNAK		;.PTNAK =  3 - CONNECTION NAK
	.BYTE	0		;.PTFUN =  4 - FUNCTION
	.BYTE	0		;.PTINT =  5 - INTERRUPT FUNCTION
	.BYTE	0		;.PTEAT =  6 - EAT FUNCTION
	.BYTE	.HFDIS		;.PTDIS =  7 - DISCONNECT
	.BYTE	.HFKIL		;.PTKIL = 10 - KILL CONNECTION
	.BYTE	.HCDAK+200	;.PTDAK = 11 - DISCONNECT ACK
	.BYTE	.HFRCR		;.PTRCR = 12 - Reconnect request

;TABLE WHICH GIVES HOST FUNCTION CODE WHICH CORRESPONDS TO EACH FUNCTION
;  PACKET FUNCTION

FNCFNC:	.BYTE	0		;       =  0 - ILLEGAL
	.BYTE	.HCHIN+200	;.FNHIN =  1 - HARD INTERRUPT
	.BYTE	.HCSIN+200	;.FNSIN =  2 - SOFT INTERRUPT
	.BYTE	.HCOSA+200	;.FNOSA =  3 - OUTPUT SUPPRESS ACK
	.BYTE	.HCOPS+200	;.FNOPS =  4 - OUTPUT SUPPRESS
	.BYTE	.HCOPH+200	;.FNOPH =  5 - OUTPUT HOLD
	.BYTE	.HCOPA+200	;.FNOPA =  6 - OUTPUT ALLOW
	.BYTE	.HFCDP		;.FNCDP =  7 - CHANGE DEVICE PARAMETERS
	.BYTE	.HFSDP		;.FNSDP = 10 - SET DEVICE PARAMETERS
	.BYTE	.HFADP		;.FNADP = 11 - ACCESS DEVICE PARAMETERS
	.BYTE	.HFRDP		;.FNRDP = 12 - REPORT DEVICE PARAMETERS
	.BYTE	.HFDCN		;.FNDCN = 13 - DEVICE CONTROL
	.BYTE	.HFDST		;.FNDST = 14 - DEVICE STATUS
	.BYTE	.HFBAD		;.FNADS = 15 - Access device status
	.BYTE	.HCCON+200	;.FNCON = 16 - Continue output
	.BYTE	.HFBAD		;.FNFHI = 17 - Force hard interrupt
	.BYTE	.HFBAD		;.FNDEM = 20 - Deferred echo mode control
	.BYTE	.HFBAD		;.FNRQD = 21 - Request disconnect
	.BYTE	.HCRQC+200	;.FNRQC = 22 - Request buffer clear
	.BYTE	.HCREQ+200	;.FNREQ = 23 - Request (yellow ball)
	.BYTE	.HCRSP+200	;.FNRSP = 24 - Response (orange ball)
	.BYTE	.HFBAD		;.FNGRN = 25 - Green ball
	.BYTE	.HFBAD		;.FNRED = 26 - Red ball
	.BYTE	.HFBAD		;.FNLST = 27 - Lost data indication
	.BYTE	.HFBAD		;.FNLSX = 30 - Reflected lost data indication
	.BYTE	.HCBRK+200	;.FNBRK = 31 - Break received or request
	.BYTE	.HFBAD		;.FNHNG = 32 - Hang up request
	.BYTE	.HFBAD		;.FNXHG = 33 - Hard hang up request
	.BYTE	.HFRCC		;.FNRCC = 34 - Reconnect control
	.BYTE	.HFBAD		;.FNXGB = 35 - Special character gobbler
	.BYTE	.HCSTR+200	;.FNSRQ = 36 - Status request
	.BYTE	.HFBAD		;.FNCLI = 37 - Clear login mode
	.BYTE	.HFBIN		;.FNBIN = 40 - Output binary characters
	.BYTE	.HCFLR+200	;.FNFLR = 41 - Force line retype
	.BYTE	.HFBAD		;	     - Illegal function
FNCFMX=!.-FNCFNC-1

;TABLE WHICH GIVES THE NETWORK PACKET TYPE WHICH CORRESPONDES TO A HOST
;  COMMAND - ALL ENTRIES IN THIS TABLE ARE FOR SOME TYPE OF FUNCTION PACKET
;  (.PTFUN, .PTINT, OR .PTEAT)

CMDPKT=.-10
	.BYTE	.PTEAT		;.HCHIN = 10 - HARD INTERRUPT
	.BYTE	.PTFUN		;.HCSIN = 11 - SOFT INTERRUPT
	.BYTE	.PTEAT		;.HCOSA = 12 - OUTPUT SUPPRESS ACK
	.BYTE	.PTINT		;.HCOPS = 13 - OUTPUT SUPPRESS
	.BYTE	.PTINT		;.HCOPH = 14 - OUTPUT HOLD
	.BYTE	.PTINT		;.HCOPA = 15 - OUTPUT ALLOW
	.BYTE	0		;.HCKIL = 16 - KILL CONNECTION
	.BYTE	.PTINT		;.HCCON = 17 - CONTINUE OUTPUT
	.BYTE	.PTEAT		;.HCFHI = 20 - FORCE HARD INTERRUPT
	.BYTE	.PTFUN		;.HCREQ = 21 - Request (yellow ball)
	.BYTE	.PTFUN		;.HCRSP = 22 - Response (ornage ball)
	.BYTE	.PTFUN		;.HCBRK = 23 - Break received or request
	.BYTE	.PTFUN		;.HCRQC = 24 - Request buffer clear
	.BYTE	.PTINT		;.HCSTR = 25 - Status request
	.BYTE	.PTFUN		;.HCFLR = 26 - Force line retype

;TABLE WHICH GIVES THE NETWORK FUNCTION PACKET FUNCTION CODE WHICH CORRESPONDES
;  TO A HOST COMMAND

CMDFNC=.-10
	.BYTE	.FNHIN		;.HCHIN = 10 - HARD INTERRUPT
	.BYTE	.FNSIN		;.HCSIN = 11 - SOFT INTERRUPT
	.BYTE	.FNOSA		;.HCOSA = 12 - OUTPUT SUPPRESS ACK
	.BYTE	.FNOPS		;.HCOPS = 13 - OUTPUT SUPPRESS
	.BYTE	.FNOPH		;.HCOPH = 14 - OUTPUT HOLD
	.BYTE	.FNOPA		;.HCOPA = 15 - OUTPUT ALLOW
	.BYTE	0		;.HCKIL = 16 - KILL CONNECTION
	.BYTE	.FNCON		;.HCCON = 17 - CONTINUE OUTPUT
	.BYTE	.FNFHI		;.HCFHI = 20 - FORCE HARD INTERRUPT
	.BYTE	.FNREQ		;.HCREQ = 21 - Request (yellow ball)
	.BYTE	.FNRSP		;.HCRSP = 22 - Response (orange ball)
	.BYTE	.FNBRK		;.HCRSP = 23 - Break received or request
	.BYTE	.FNRQC		;.HCRQC = 24 - Request buffer clear
	.BYTE	.FNSRQ		;.HCSTR = 25 - Status request
	.BYTE	.FNFLR		;.HCFLR = 26 - Force line retype

	.EVEN
	.PAGE
	IMPURE

LKDTNS:	.WORD	0		;TEN SECOND COUNTER

;THE DEBUG RING!

.IF NE ..DEBG

DBRNGP:	.WORD	0			;POINTER
	.WORD	-1			;EASY TO SEE "BEGINNING OR RING" FLAG
DBRING:	.BLKW	1000			;THE RING
DBRNGE:	.WORD	-1			;EASY TO SEE "END OF RING" FLAG

.ENDC	;.IF NE ..DEBG
	.END
   ~F0u+