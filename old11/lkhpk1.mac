	.TITLE	LKHPK1 - LINK H - TYMSHARE T.201 PROTOCOL - PACKET LEVEL ROUTINES
	.SBTTL	LKHPK1 - Nexilis/JRG


	XLPAR
.HLIST=!1
	CODE

;DEFINE SYMBOLS FOR SOME UNUSED STANDARD ENTRIES

LKHSTR==!0
LKHLOD==!0

	.SBTTL	LKHINI - DDB INITALIZATION SUBROUTINE

;THIS SUBROUTINE IS CALLED BY THE START-UP ROUTINE IN EXEC TO INITIALIZE OUR
;  DDB'S - CALLED ONCE FOR EACH DDB - WE LOOP IN THIS ROUTINE FOR THE LDB'S
;	C(R4) = ADDRESS OF DDB
;	CALL	LKHINI

LKHINI::MOV	#DDLHFC#,R0		;CLEAR IMPURE PART OF DDB
	ADD	R4,R0
	MOV	#DDLHCZ#,R2
2$:	CLR	(R0)+
	SOB	R2,2$
	MOV	DDLHNN#(R4),DDLHSM#(R4)	;COPY NODE NUMBER INTO SUPERVISOR AREA
	MOV	VERLOC#,DDLHSM#+2(R4)	;ALSO SOFTWARE VERSION NUMBER
	MOV	CRSCNT#,DDLHSM#+10(R4)	;AND NODE CRASH COUNT
	MOV	DDLHLD#(R4),R3		;GET FIRST LDB
	MOV	#DDLHSM#+<65*2>,R2	;INIT POINTERS FOR SETTING SUPERVISOR
	ADD	R4,R2			;  TABLES
	MOV	#1000,R0
4$:	MOV	R0,-100(R2)		;STORE DUMMY PERMUTER TABLE POINTER
	MOVB	LDHCHN#(R3),R1		;CALCULATE NEXT PERMUTER TABLE
	ADD	R1,R0			;  ADDRESS
	PUSH	R0			;save the permuter table pointer
	MOVB	LDHGRP#(R3),R0		;GET NUMBER OF 8 LINE GROUPS
	ASR	R0			;CHANGE TO NUMBER OF 16 LINE GROUPS
	MOV	R0,-40(R2)		;STORE IN SUPERVISOR TABLE
	MOV	LDHNBR#(R3),(R2)+	;STORE NEIGHBOR NUMBER FOR THIS LINE
	PUSH	R2			;SAVE OUR POINTERS
	MOV	#LDHFCL#,R0		;CLEAR COMMON INPURE PART OF LDB
	ADD	R3,R0
	MOV	#LDHCSZ#,R2
10$:	CLR	(R0)+
	SOB	R2,10$
11$:	MOV	LDHNXT#(R3),R0		; Get pointer to next LDB
	BEQ	14$			; No more LDBs
12$:	CMP	LDHSTX#(R3),LDHSTX#(R0)	; Is this the same type LDB?
	BEQ	14$			; Yes
	MOV	LDHNXT#(R0),R0		; Get pointer to next LDB
	BNE	12$			; Check LDB if there is one
14$:	MOV	R0,LDHNXS#(R3)		; Save it away
	CALL	@LDHINX#(R3)		;INITIALIZE THE LDB
	POP	R2
	POP	R0			;RESTORE OUR POINTERS
	MOV	LDHNXT#(R3),R3		;STEP TO NEXT LDB
	BNE	4$			;CONTINUE IF MORE
.IF EQ ..SAT
	MOV	#DDLHHD,R0		;MAKE POINTER TO THE HOST DESCRIPTORS
	ADD	R4,R0
	MOV	#4,R2			;SET COUNTER
20$:	BIC	#100000,(R0)+		;CLEAR THE ANSWERED BIT
	MOV	#-1,(R0)+		;INDICATE HOST IS DOWN
	SOB	R2,20$			;CONTINUE IF MORE
.ENDC
	RETURN				;FINISHED
	.PAGE
	.SBTTL	LKHINS - SDB INITALIZATION SUBROUTINE

;THIS SUBROUTINE IS CALLED BY THE START-UP ROUTINE IN EXEC TO INITIALIZE OUR
;  SDB'S - CALLED ONCE FOR EACH SDB
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	LKHINS

LKHINS::MOV	#SDLHFC#,R2		;CLEAR IMPURE PART OF SDB
	ADD	SD,R2
	MOV	#SDLHCZ#,R0
2$:	CLR	(R2)+
	SOB	R0,2$
.IF EQ ..SAT
	MOVB	#377,SDLHBF#(SD)
.ENDC
RTN001:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LHRSUM - RESUME SUBROUTINE

;SUBROUTINE CALLED WHEN LINKED SOCKET IS READY TO RECEIVE AGAIN AFTER BEING
;  STOPPED
;	C(SD) = ADDRESS OF SDB
;	C(R4) = ADDRESS OF DDB
;	CALL	LHRSUM

;  THIS SUBROUTINE IS NOT USED BY THE TYPE H LINK SINCE FLOW CONTROL IS DONE
;  FOR ALL SOCKETS AT A REGULAR INTERVAL (1/2 SECOND).

LHRSUM::RETURN				;NOTHING NEEDED HERE!
	.PAGE
	.SBTTL	LHPOKE - POKE SUBROUTINE

;THIS SUBROUTINE IS CALLED BY SNDPKT WHEN A PACKET IS SENT TO AN IDLE SOCKET
;	C(R1) = ADDRESS OF PACKET TO SEND (PACKET IS ON DST LIST)
;	C(R4) = ADDDRES OF DDB
;	C(SD) = ADDDRES OF SDB FOR PACKET
;	CALL	LHPOKE

LHPOKE::MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	CMP	SDACNT#(SD),#2		;CAN WE SEND NORMAL PACKETS NOW?
	BGE	4$			;YES
	TSTB	TYPTBL(R0)		;NO-SHOULD THIS PACKET BE SENT ANYWAY?
	BPL	RTN001			;NO-FORGET IT FOR NOW!
4$:	MOV	SDLHLD#(SD),R3		;OK TO SEND PACKET-GET LDB ADDRESS
	BNE	6$			;GO ON IF HAVE ONE NOW
	ASL	R0			;NO LDB-DISPATCH ON PACKET TYPE
	CALL	@NEWDSP(R0)		;Call routine for the packet
	MOV	SDPKDH#(SD),R1		;Any more packets now?
	BNE	LHPOKE			;Yes-go process next one
	RETURN				;Nope-finished for now

;HERE IF HAVE LDB LINKED TO THIS SDB

6$:	CMP	#-1,SDLKLK#(SD)		;ALREADY IN THE SEND LIST?
	BNE	LKHBGN			;YES
	MOV	LDHXLT#(R3),R2		;NO-LINK THIS SDB TO THE TAIL OF THE SEND
	BEQ	10$			;  LIST FOR THIS LDB
	MOV	SD,SDLKLK#(R2)
	BR	11$

10$:	MOV	SD,LDHXLH#(R3)
11$:	MOV	SD,LDHXLT#(R3)
	CLR	SDLKLK#(SD)
LKHBGN::TBBN	$L1BSY,LDHST1#(R3),RTN001;IS THIS LINE BUSY NOW?
	PUSH	R4			;LHDSTX@ DOWE NOT RESPECT R4
	CALL	@LDHSTX#(R3)		;NO-GO START IT UP (THIS ROUTINE WILL
					;  CALL US AT FILFRM)
	POP	R4
	RETURN
	.PAGE
;BIT TABLE INDEXED ON PACKET TYPE - SIGN BIT OF BYTE IF SET IF PACKET SHOULD BE
;  BE SENT EVEN IF SOCKET IS BEING HELD

	PURE

TYPTBL:	.BYTE	000		;.PTDAT =  0 - DATA PACKET
	.BYTE	200		;.PTCON =  1 - CONNECTION REQUEST
	.BYTE	200		;.PTACK =  2 - CONNECT ACK
	.BYTE	200		;.PTNAK =  3 - CONNECT NAK
	.BYTE	000		;.PTFUN =  4 - FUNCTION
	.BYTE	200		;.PTINT =  5 - INTERRUPT
	.BYTE	200		;.PTEAT =  6 - EAT
	.BYTE	000		;.PTDIS =  7 - DISCONNECT
	.BYTE	200		;.PTKIL = 10 - KILL CONNECTION
	.BYTE	200		;.PTDAK = 11 - DISCONNECT ACK

;PACKET TYPE DISPATCH TABLE FOR "NEW CIRCUITS"

	.EVEN
NEWDSP:	.WORD	NEWDAT		;.PTDAT =  0 - DATA PACKET
	.WORD	NEWCON		;.PTCON =  1 - CONNECTION REQUEST
.IF EQ ..SAT
	.WORD	NEWACK		;.PTACK =  2 - CONNECT ACK
	.WORD	NEWNAK		;.PTNAK =  3 - CONNECT NAK
.IFF
	.WORD	NEWZAP
	.WORD	NEWZAP
.ENDC
	.WORD	NEWFUN		;.PTFUN =  4 - FUNCTION
	.WORD	NEWFUN		;.PTINT =  5 - INTERRUPT
	.WORD	NEWZAP		;.PTEAT =  6 - EAT
	.WORD	NEWKIL		;.PTDIS =  7 - DISCONNECT
	.WORD	NEWKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	NEWDAK		;.PTDAK = 11 - DISCONNECT ACK

	CODE
	.PAGE
	.SBTTL	NEWCON - Connection request on inactive SDB (new circuit)

;HERE FOR CONNECTION REQUEST ON "NEW CIRCUIT"

NEWCON:
	TST	DDLHUP#(R4)		;DO WE HAVE AN UPSTREAM LINE?
	BNE	2$			;YES-GO ON
1$:	MOV	#.ERGWD,R0		;NO-GET ERROR CODE
	BR	NEWCO9			;AND REFUSE THE CONNECTION


;HERE IF HAVE A PATH TO THE SUPERVISOR NOW

2$:	TSTB	PKDATA+27(R1)		;Is this a supervisory connection?
	BMI	1$			;Yes-THIS CAN HAPPEN IN A NETWORK WITH 
					;MULTIPLE GATEWAYS
	CLR	SDLHS1#(SD)		;INIT THE STATUS WORD
	CALL	REMOVE#			;Remove packet from DST list

.IF EQ ..SAT
;IF WE HAVE BASE SUPPORT WE MUST HANDLE "AUX-CIRCUIT" CONNECTIONS (THIS IS
;  ONE WHERE A PASSWORD WILL NOT BE REQUIRED) AND MUST ALLOCATE A BUFFER
;  NUMBER SINCE THE POOL OF BUFFER NUMBERS IS SHARED BETWEEN US AND THE
;  TYMNET SUPERVISOR!

	BITB	#020,PKDATA+35(R1)	;SHOULD THIS BE AN AUX CIRCUIT?
	BNE	NEWAUX			;YES
	MOV	DDLHBF#(R4),R0		;GET BASE OF BUFFER TABLE
	SUB	#2,R0
	MOV	DDLHNH#(R4),R2		;GET NUMBER OF HOSTS
3$:	MOV	DDLHSH#(R4),R3		;CALCULATE NUMBER OF TERMINAL BUFERS
	SUB	DDLHPH#(R4),R3		;  IN THIS PART OF THE TABLE
	SUB	#2,R3
	ADD	DDLHPH#(R4),R0		;POINT TO FIRST TERMINAL BUFFER IN
	ADD	#2,R0			;  THIS PART
4$:	TSTB	(R0)+			;IS THIS BUFFER FREE?
	BEQ	5$			;YES-GO USE IT
	SOB	R3,4$			;NO-MORE IN THIS PART OF TABLE?
	SOB	R2,3$			;NO-MORE PARTS TO CHECK?
	MOV	#.ERNSA,R0		;NO-SAY NO SOCKETS AVAILABLE
	BR	NEWCO9			;GO FAIL

;HERE WITH BUFFER WE CAN USE

5$:	MOVB	SDSOC#(SD),-(R0)	;GRAB THIS BUFFER
	SUB	DDLHBF#(R4),R0		;GET BUFFER NUMBER
	MOVB	R0,SDLHBF#(SD)		;REMEMBER THE BUFFER NUMBER
.ENDC
	BIS	#$H1CRD,SDLHS1#(SD)	;ASSUME CR DELAY FLAG SHOULD BE SET
	CALL	TYNGTT#			;GET TYMNET TERMINAL TYPE CODE
	BNE	6$			;CHECK FOR NON-TERMINAL TYPE
	MOV	#12.,R0			;DECLARE 1200 BAUD CIRCUIT
6$:	CMP	#4,R0			;SHOULD CR DELAY BE SET?
	BNE	8$			;YES
	BIC	#$H1CRD,SDLHS1#(SD)	;NO-CLEAR IT
8$:	CMP	#8.,R0			;IS THIS A SELECTRIC?
	BEQ	10$			;YES
	CMP	#9.,R0			;MAYBE
	BNE	12$			;NO
10$:	BIS	#$H1SEL,SDLHS1#(SD)	;YES-REMEMBER THAT
12$:	BITB	#002,PKDATA+35(R1)	;LOCAL COPY TERMINAL?
	BEQ	18$			;NO
	BIS	#$H1LCT,SDLHS1#(SD)	;YES-REMEMBER THAT
18$:	BITB	#040,PKDATA+35(R1)	;DOES HIS COMMAND DECODER HANDLE LOGIN
					;  STRINGS?
	BEQ	20$			;NO
	BIS	#$H1TCD,SDLHS1#(SD)	;YES-REMEMBER THAT
20$:
.IF EQ ..SAT
	PUSH	R1			;SAVE ADDRESS OF CONNECT PACKET
	MAKPKT	.PLSTP#			;GET ANOTHER PACKET
	BCS	30$			;COULDN'T GET ONE - HANDLE ERROR
	POP	SDLHSC#(SD)		;REMEMBER ADDRESS OF CONNECT PACKET
.ENDC
	BIS	#100,R0			;MAGIC FOR THE SUPERVISOR!
	CALL	SNDCMS			;SEND "TERMINAL TYPE" TO SUPERVISOR
	MOV	#77777,SDACNT#(SD)	;TURN OFF "BACK-PRESSURE" SO WILL
					;  ACCEPT THE LOG-IN STRING
	MOV	#P.TYMS*400+155,R2	;ACCEPT THE CONNECTION
	CLR	R0
	CALL	ACCEPT#
	BIT	#^C200,THOST#		;Is there a terminal host
	BEQ	NEWCDN			;No, skip this stuff
	PUSH	#.SMMS6*10000		;SR1
	CLR	R1			;GET BUFFER NUMBER FOR SR2
.IF EQ ..SAT
	BISB	SDLHBF#(SD),R1
.IFF
	BISB	SDSOC#(SD),R1
.ENDC
	SWAB	R1			;POSITION IN OTHER HALF OF WORD
	ASR	R1			;POSITION BUFFER NUMBER
	BIS	#100000+.S6OHN,R1	;SET IN ORIGINATING HOST MESSAGE
	PUSH	R1			;SR2
	PUSH	THOST#			;SR3 = TERMINAL HOST
	SWAB	(SP)			;THOST IS IN TYMNET II FORMAT
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	BR	NEWCDN			;REDUCE HIS PACKET COUNT AND RETURN

.IF EQ	..SAT
30$:	POP	R1			;RECOVER CONNECT PKT IF NO MORE PACKETS
	MOV	#.ERBFF,R0		;ERROR = BUFFER FULL
.ENDC
NEWCO9:	CALL	REFUSE#			;REFUSE THE CONNECTION
	CJMP	FRESOC#


;HERE TO BUILD AN AUX CIRCUIT

.IF EQ ..SAT
NEWAUX:	MOV	R1,SDLHSC#(SD)		;Save the connect packet
	CALL	FNDHST			;FIND THE SRC HOST IN OUR TABLE
	  BR	NEWPNF			;IF NOT THERE!
	ADD	R4,R0			;PLUS BASE OF DDB
	TST	DDLHXS#(R0)		;ARE WE BUSY WITH AN AUX-CIRCUIT NOW?
	BEQ	NEWAU4			;NO-GO ON
NEWPNF:	MOV	#.ERCRF,R0		;YES-FAIL!!!!!
	BR	NEWCO9

NEWAU4:	MOV	SD,DDLHXS#(R0)		;SAVE SDB ADDRESS
	MOVB	DDLHXP#(R0),SDLHBF#(SD)	;POINT TO THE SPECIAL AUX-PORT
	PUSH	#.SMMS5*10000		;SR1
	PUSH	DDLHXP#(R0)		;SR2
	PUSH	#.S5AUX*400		;SR3
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	BIS	#$H1AUX,SDLHS1#(SD)	;INDICATE THIS IS AN AUX CIRCUIT
	MOV	#JIFX60#,R0		;SET 60 SECOND TIMER
	MOV	#LKHATO#,R1
	CALL	TIMREQ#
.ENDC
NEWCDN:	CJMP	DECPCN#			;REDUCE HIS PACKET COUNT AND RETURN
	.PAGE
	.SBTTL	NEWACK - Connect ACK on unused SDB (new circuit)

;Here for a CONNECT ACK packet - this should only get here for a supervisory
;  connection

.IF EQ ..SAT

NEWACK:	TBBN	$H1SPR,SDLHS1#(SD),2$	;Is this a supervisory connection?
	JMP	NEWZAP			;No

2$:	PUSHB	PKDATA+1(R1)		;Save flag byte
	CALL	JNKPKT#			;Give up the packet
	MOV	#77777,SDACNT#(SD)	;ACCEPT INPUT
	MOV	SDLHVH#(SD),R0		;GET INDEX AGAIN
	CMP	#10,DDLHHY#(R4)
	BNE	4$
	ASR	R0
4$:	ADD	R4,R0			;PLUS BASE OF DDB
	PUSH	R0			;Save it for a while
	PUSH	#.SMMDR*10000		;SR1
	MOV	DDLHPH#(R4),R2		;NUMBER OF AVAILABLE HOST PORTS
	MOV	R2,DDLHHD#+2(R0)	;STORE IN HOST DESCRIPTOR IN DDB
	ASHI	6,R2			;MAKE INTO SR2 DATA
	BIS	#100002,R2
	PUSH	R2			;SR2
	BIC	#100000,DDLHHD#(R0)	;Assume host not answered
	MOV	DDLHHD#(R0),R2		;GET HOST NUMBER
	MOV	R2,SDLHVL#(SD)		;SAVE FOR LATER USE
	SUB	R4,R0
	SWAB	R0			;CHANGE TO "HOST ARRAY NUMBER"
	ASHI	2,R0			;AND POSITION IT FOR SR3
	BIS	R0,R2			;MERGE WITH HOST NUMBER
	PUSH	R2			;SR3
	CALL	SNDSPR#			;SEND MESSAGE TO SUPERVISOR
	POP	R0			;Restore index
	TSTB	(SP)+			;Is the host answered now?
	BPL	90$			;No-finished now
	BIS	#100000,DDLHHD#(R0)	;Yes-remember that
	CJMP	NWSANS			;And go tell the supervisor
90$:	RETURN

;Here for connect NAK packet on "new circuit"

NEWNAK:	CALL	JNKPKT#			;Give up the packet
	TBBE	$H1SPR,SDLHS1#(SD),4$	;Is this a supervisory connection?
	CALL	LKHNKL			;Yes-clean it up
4$:	CJMP	FRESOC#			;Give up the socket and return

.ENDC
	.PAGE
	.SBTTL	NEWDAT - Handle data packet on new circuit

;HERE FOR DATA PACKET ON "NEW CIRCUIT"

NEWDAT:	TBBN	$S1JNK,SDSTS1#(SD),NEWIGN;SHOULD WE JUNK THIS PACKET?
	MOVB	PKPNT(R1),R2		;NO-MAKE POINTER TO DATA IN PACKET
	BNE	1$
	INC	R2
	INCB	PKPNT(R1)
1$:	ADD	#PKDATA-1,R2
	ADD	R1,R2
2$:	DECB	PKCNT(R1)		;MORE THERE?
	BLT	NEWIGN			;NO
	INCB	PKPNT(R1)
21$:	MOVB	(R2)+,R0		;YES-GET BYTE
	BIC	#^C177,R0		;ONLY 7 BITS

;	DELETE THE FOLLOWING LINES TO LET CONTROLS THROUGH TO THE SUP
;	CMP	#10,R0			;IS IT A SPECIAL CODE?
;	BHI	2$			;YES-IGNORE IT! (SHOULD NEVER SEE THESE
					;  CONTROL CHARACTERS HERE!)

	CMP	#';,R0			;IS IT A SEMI-COLON?
	BEQ	10$			;YES
	CMP	#CR,R0			;OR A CR?
	BEQ	10$			;YES
	CMP	#ESC,R0			;NO-IS IT ESCAPE?
	BEQ	50$			;YES
	CMP	#BS,R0			;Check for CTL-H
	BNE	3$			;NO
	TBBN	$H2PWM,SDLHS2#(SD),3$	;YES - BUT DONT DO ANYTHING SPECIAL IF IN PASSWORD
	BIS	#$H1LCT,SDLHS1#(SD)	;REMEMBER THAT
3$:	DECB	PKCNT(R1)		;DO WE HAVE ANOTHER CHARACTER IN THE PACKET
	BGE	4$			;YES- SEND THE PAIR
	CALL	SNDCMS			;NO-SEND CHARACTER TO SUPERVISOR
	BR	NEWIGN			;AND GIVE UP THE PACKET
4$:	INCB	PKPNT(R1)		;INCREMENT PACKET POINTER
	BICB	#200,(R2)		;CLEAR THE PARITY BIT
	CMPB	#';,(R2)		;CHECK FOR SEMI-COLON
	BEQ	8$			;YES, SEND SINGLE LOGIN CHAR
	CMPB	#CR,(R2)		;CHECK FOR CR
	BEQ	8$			;YES, JUST SEND IT
	CMPB	#ESC,(R2)		;CHECK FOR ESCAPE
	BEQ	8$			;YES, SEND JUST IT
	CMPB	#BS,(R2)		;Check for CTL-H
	BNE	6$			;NO
	TBBN	$H2PWM,SDLHS2#(SD),6$	;YES - BUT DONT DO ANYTHING SPECIAL IF IN PASSWORD
	BIS	#$H1LCT,SDLHS1#(SD)	;YES-REMEMBER THAT
6$:	CALL	SNDLIP			;SEND THE LOGIN PAIR
	BR	2$			;CHECK FOR NEXT PAIR
8$:	CALL	SNDCMS			;SEND PREVIOUSLY FOUND CHARACTER
	BR	21$			;GO HANDLE TERMINATING CHAR

;HERE WITH SEMI-COLON OR CR

10$:
.IF EQ ..SAT
	TST	SDLHSC#(SD)		;YES-DO WE STILL HAVE A SAVED CONNECT?
	BEQ	50$			;NO-GO ON
	PUSH	R0			;YES-SAVE CURRENT STATE
	PUSH	R1
	PUSH	R2
	MOV	SDLHSC#(SD),R1		;POINT TO SAVED CONNECT PACKET
	TSTB	PKDATA+2(R1)		;DO WE HAVE A DST EXTENSION?
	BEQ	40$			;NO-FORGET THIS JUNK
	MOV	#':,R0			;YES-SEND A COLON TO THE SUPERVISOR
	MOVB	PKDATA+1(R1),R2		;POINT TO DST EXTENSION
	ADD	R1,R2
	ADD	#PKDATA+24,R2
11$:	CALL	SNDLIP			;SEND THE : AND THE FIRST CHARACTER OF THE DEST
	DECB	PKDATA+2(R1)		;MORE THERE?
	BLE	40$			;NO- FINISHUP
	MOVB	(R2)+,R0		;GET CHARACTER
	DECB	PKDATA+2(R1)		;DEC COUNTER
	BGT	11$			;GO ON IF THERE ARE MORE CHARACTERS TO SEND
	CALL	SNDCMS			;SEND THE SINGLE CHARACTER TO SUPERVISOR
40$:	FREPKT				;FINISHED-GIVE UP THE CONNECT PACKET
	CLR	SDLHSC#(SD)
	POP	R2			;RESTORE STATE
	POP	R1
	POP	R0			;RESTORE NEXT CHARACTER
.ENDC
50$:	CALL	SNDCMS			;SEND IT TO THE SUPERVISOR
	BIC	#$H1INX,SDLHS1#(SD)	;INDICATE NOT EXPECTING INPUT NOW
	CLR	SDACNT#(SD)		;HOLD THIS SOCKET FOR NOW
	TSTB	PKCNT(R1)		;ANYTHING LEFT IN THE PACKET?
	BEQ	NEWIGN			;NO-GO GIVE UP THE EMPTY PACKET
RTN002:	RETURN				;YES-RETURN FOR NOW

;HERE TO GIVE UP THE INPUT PACKET - EITHER BECAUSE WE ARE FINISHED PROCESSING
;  IT OR BECAUSE WE WANT TO IGNORE IT

NEWIGN:	CJMP	JNKPKT#			;Give up the packet and return
	.PAGE
	.SBTTL	NEWFUN - Handle function packet on a new circuit
;HERE FOR FUNCTION OR INTERRUPT PACKET

NEWFUN:	TSTB	PKCNT(R1)		;ANY DATA THERE?
	BLE	NEWIGN			;No-ignore it
	MOVB	PKDATA(R1),R0		;Yes-get function type
	CMP	#.FNGRN,R0		;Is it a green ball?
	BEQ	NEWGRN			;Yes-go handle it
.IF EQ ..SAT
	CMP	#.FNREQ,R0		;Is it a yellow ball?
	BEQ	NEWYEL			;Yes
	CMP	#.FNRQC,R0		;Is this a "Request buffer clear"?
	BNE	2$			;No-go on
	CJMP	ACKOPS#			;Yes-go acknowledge it

2$:	CMP	#.FNDCN,R0		;IS THIS A "DEVICE CONTROL" FUNCTION?
	BEQ	NEWSPF			;YES-THIS IS SPECIAL
.ENDC
	CMP	#.FNOSA,R0		;YES-IS IT AN "OUTPUT SUPPRESS ACK"
	BNE	NEWIGN			;NO-IGNORE IT
	BIC	#$S1JNK,SDSTS1(SD)	;YES-CLEAR THE JUNK BIT
	BR	NEWIGN			;AND GOTO NEWIGN TO GIVE IT UP

;HERE FOR GREEN BALL

NEWGRN:	TBBN	$H1INX,SDLHS1#(SD),NEWRTN;JUST BOUNCE IT BACK IF EXPECTING INPUT
	BIS	#$H1GBR,SDLHS1#(SD)	;NOT EXPECTING INPUT-REMEMBER THE
	BR	NEWIGN			;  BALL FOR LATER

;Here for yellow ball - just echo back a orange ball

.IF EQ ..SAT
NEWYEL:	MOVB	#.FNRSP,PKDATA(R1)	;Change it to an orange ball
	CJMP	PKTRTN#			;And send the packet back
.ENDC

;HERE FOR "DEVICE CONTROL" FUNCTION - THIS IS USED ONLY ON SUPERVISORY
;  CONNECTIONS TO PASS DATA BETWEEN A TYMSHARE HOST AND THE TYMNET GATEWAY

.IF EQ ..SAT
NEWSPF:	PUSHB	PKDATA+1(R1)		;Save sub-type
	CALL	JNKPKT#			;Give up the packet
	POPB	R0			;Get sub-type
	CMP	R0,#MAXSPF		;LEGAL VALUE?
	BHI	RTN002			;NO-IGNORE IT
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;YES-DISPATCH ON IT
	BR	NWSSHT		;.SFSHT =  0 - HOST IS SHUT
	BR	NWSANS		;.SFANS =  1 - HOST IS ANSWERED
	BR	NWSSAD		;.SFSAD =  2 - HOST SAD BITS
	BR	NWSTOD		;.SFTOD =  3 - TIME OF DAY REQUEST
	BR	NWSRHK		;.SFRHK =  4 - REPORT HOST KEY
	BR	NWSHOP		;.SFHOP =  5 - HOST OUT OF PORTS
;	BR	NWSHHP		;.SFHHP =  6 - HOST HAS PORTS
MAXSPF=!6

;HERE FOR .SFHHP = 6 - HOST HAS PORTS

NWSHHP:	PUSH	#.SMMS6*10000		;SR1
	PUSH	#100000+.S6HHP		;SR2
NWSSHA:	MOV	SDLHVH#(SD),R0		;GET THE HOST INDEX(0,4,10,14)
	CMP	#10,DDLHHY#(R4)		;CHECK FOR TWO HOST NODE
	BNE	10$			;NOT ONE
	ASR	R0			;CONVERT 10 TO 4 OR 0 TO 0
10$:;	ROR	R0			;POSITION HOST ARRAY IN TOP OF REGISTER
;	ROR	R0
;	ROR	R0
	SWAB	R0			;PUT INDEX IN UPPER NIBBLE
	ASHI	4,R0			;SHIFT INDEX TO TOP TWO BITS
;	BIC	#37777,R0		;CLEAR ANY JUNK
	BIS	SDLHVL#(SD),R0		;PUT IN HOST NUMBER
	PUSH	R0			;PUT ON STACK
	BR	NWSSND			;SHIP IT OFF TO SUP

;HERE FOR .SFHOP = 5 - HOST OUT OF PORTS

NWSHOP:	PUSH	#.SMMS6*10000		;SR1
	PUSH	#100000+.S6HOP		;SR2
	BR	NWSSHA			;SET HOST ARRAY AND HOST

;HERE FOR .SFHHP = 4 REPORT HOST KEY

NWSRHK:	PUSH	#.SMMS6*10000		;SR1
	MOVB	PKDATA+2(R1),R0		;GET HOST KEY
	SWAB	R0			;PUT IN CORRECT HALF
	CLRB	R0
	ROR	R0
	SEC				;SET CARRY BIT TO SET HIGH BIT
	ROR	R0			;HOST KEY IS NOW CORRECTLY POSITIONED
	BIS	#100000!.S6RPK,R0	;PUT IN HOST KEY CODE
	PUSH	R0
	BR	NWSSHA

;HERE FOR .SFTOD = 3 - TIME REQUEST

NWSTOD:	PUSH	#.SMMS6*10000		;SR1
	PUSH	#.S6TOD!100000		;SR2
	PUSH	#0			;SR3
	BR	NWSSND			;SEND REQUEST TO SUP

;HERE FOR .SFSAD = 2 - HOST SAD BITS

NWSSAD:	PUSH	#.SMMDR*10000		;SR1
	MOV	SDLHVL#(SD),R0		;GET HOST NUMBER
	ASHI	6,R0			;POSITION IT FOR SR2
	BIS	#100000!.S3UNH,R0	;PUT IN CODE FOR UNHAPPY HOST
	PUSH	R0			;SR2
	PUSH	PKDATA+4(R1)		;SR3 (THE SAD BITS)
	BR	NWSSND			;CONTINUE

;HERE FOR .SFANS = 1 - HOST IS ANSWERED

NWSANS:	MOV	#3001,R0		;GET VALUE FOR SR3
	BR	NWSASS			;CONTINUE

;HERE FOR .SFSHT = 0 - HOST IS SHUT

NWSSHT:	MOV	#3000,R0		;GET VALUE FOR SR3
NWSASS:	PUSH	#.SMMS5*10000		;SR1
	PUSH	SDLHVL#(SD)		;SR2
	PUSH	R0			;SR3
	MOV	SDLHVH#(SD),R0		;FIND HOST DESCRIPTOR
	CMP	#10,DDLHHY#(R4)
	BNE	2$
	ASR	R0
2$:	ADD	R4,R0
	BIC	#100000,DDLHHD#(R0)	;ASSUME SHUT
	TBBE	1,(SP),NWSSND		;RIGHT?
	BIS	#100000,DDLHHD#(R0)	;NO-IT IS ANSWERED
NWSSND:	CALL	SNDSPR#			;SEND TO SUPERVISOR
	RETURN				;FINISHED (DO NOT CHANGE THIS TO CJMP!)
.ENDC		;.IF EQ ..SAT

;HERE FOR UNACCEPTABLE PACKET ON "NEW CIRCUIT"

NEWZAP:	MOV	#.CCZAP,R0		;SEND ZAPPER TO THE SUPERVISOR
	CALL	LKHSCM
	CALL	SETKIL#			;CHANGE PACKET INTO A KILL PACKET
N:	CJMP	PKTRTN#			;AND SEND IT BACK AND RETURN
	.PAGE
	.SBTTL	NEWKIL - Handle disconnect or kill on new circuit

;HERE FOR DISCONNECT OR KILL PACKET ON "NEW CIRCUIT"

NEWKIL:
	CALL	FINDIS#
.IF EQ ..SAT
	TBBN	$H1SPR,SDLHS1#(SD),NEWKLS;IS THIS A SUPERVISORY CONNECTION?
.ENDC
	MOV	#.CCZAP,R0		;NO-SEND A ZAPPER TO THE SUPERVISOR
;	CJMP	LKHSCM
;****	added 5/28/81 to release buffer block assignments (the cause of
;	"bisy circuits"/dre
	CALL	LKHSCM			; TO TERMINATE LOGIN SEQUENCE
	CJMP	CLRCIR#			;CLEAN UP ANY JUNK LEFT

;HERE TO DISCONNECT A SUPERVISORY CONNECTION

.IF EQ ..SAT

NEWKLS:	PUSH	#.SMMDR*10000		;SR1
	PUSH	#100002			;SR2
	PUSH	SDLHVL#(SD)		;SR3
	MOV	SDLHVH#(SD),R0		;GET INDEX
	CMP	#10,R0
	BNE	2$
	ASR	R0
2$:	SWAB	R0
	ASHI	2,R0
	BIS	#100000,R0		;INDICATE HOST IS DOWN
	BIS	R0,(SP)
	CALL	SNDSPR#			;SEND TO SUPERVISOR
LKHNKL::MOV	SDLHVH#(SD),R0		;GET INDEX
	CMP	#10,DDLHHY#(R4)
	BNE	2$
	ASR	R0
2$:	ADD	R4,R0
	MOV	#-1,DDLHHD+2(R0)	;INDICATE HOST DOWN
	BIC	#100000,DDLHHD(R0)	;AND NOT ANSWERED
	MOV	SDLHVH#(SD),R0
	ADD	R4,R0
4$:	CLR	DDLHSS#(R0)		;CLEAR POINTER BACK TO THE SDB
	CLR	SDLHVH#(SD)		;AND CLEAR SOME SDB DATA
	CLR	SDLHVL#(SD)
	RETURN

.ENDC		;.IF EQ ..SAT

;HERE FOR DISCONNECT ACK PACKET ON "NEW CIRCUIT"

NEWDAK:	CALL	JNKPKT#			;GIVE UP THE PACKET
	CALL	CLRCIR#			;CLEAN UP ANY JUNK
	CJMP	FRESOC#			;FREE THE SOCKET AND RETURN
	.PAGE
	.SBTTL	FILFRM - Fill a frame - Flow control record

;THIS SUBROUTINE IS CALLED BY THE FRAME LEVEL ROUTINES WHENEVER IT IS READY TO
;  TRANSMIT A FRAME
;	C(R2) = ADDRESS OF FRAME BUFFER
;	C(R3) = ADDRESS OF LDB
;	CALL	FILFRM
;	C(R2) = ADDRESS OF FIRST BYTE NOT USED

FILFRM::MOV	#60.,LKHLFT		;INITIALIZE NUMBER OF BYTES AVAILABLE
	TBBE	$L1FLW,LDHST1#(R3),FILSPR;TIME FOR FLOW CONTROL RECORD?

;HERE TO GENERATE FLOW CONTROL RECORD

FILFLW:	BIC	#$L1FLW,LDHST1#(R3)	;CLEAR FLOW CONTROL REQUEST
	MOV	LDHSDB#(R3),R1		;POINT TO SDB TABLE
	MOVB	LDHGRP#(R3),R0		;GET NUMBER OF 8 BIT HALF-GROUPS
	PUSH	R3			;Save R3
	CLR	R3			;Assume we are low on packets
	CMP	PKFCNT#,#40.		;Are we low?
	BLO	2$			;YES-go on
.IF NE ..SAT
	MOV	#3,R3			;Allow 3 packets if TYMSAT
.IFF
	MOV	#4,R3			;Allow 4 packets if TYMBAS
.ENDC
2$:	MOVB	R0,(R2)+		;STORE AS BYTE COUNT
	MOVB	#1,(R2)+		;STORE CHANNEL NUMBER IN RECORD HEADER
	PUSH	R0			;AND SAVE IT ON THE STACK
	ADD	#2,R0			;REDUCE AMOUNT LEFT IN FRAME
	SUB	R0,LKHLFT
	MOV	R2,FILSVA		;REMEMBER ADDRESS OF FIRST DATA WORD
4$:	CLR	R0			;Clear a byte
	CMP	PKFCNT#,#10.		;Are we very low on packets?
	BLO	12$			;Yes-don't set any bits!
	MOV	#8.,R4			;No-get bit count
6$:	ASL	R0			;SHIFT ONE BIT
	MOV	(R1)+,SD		;GET NEXT SDB
	BEQ	10$			;IF NONE THERE
	CMPB	R3,SDPCNT#(SD)		;ARE WE READY FOR MORE ON THIS SDB?
	BLT	10$			;NO
	CMPB	#.SSCON,SDSTS1#(SD)	;MAYBE-IS IT FULLY CONNECTED?
	BGT	10$			;NO
	INC	R0			;YES-SET ITS BIT
10$:	SOB	R4,6$			;MORE BITS FOR THIS BYTE?
12$:	MOVB	R0,(R2)+		;NO-STORE BYTE IN RECORD
	DEC	(SP)			;NEED ANY MORE BYTES?
	BGT	4$			;YES
	TST	(SP)+			;NO-FIX UP THE STACK
	BISB	#300,@FILSVA		;SET BITS FOR CHANNELS 0 AND 1 (WE ARE
					;  ALWAYS READY FOR SUPERVISOR AND FLOW
					;  CONTROL RECORDS!)
	POP	R3			;Restore R3
					;FALL INTO FILSPR
	.PAGE
	.SBTTL	FILSPR - Fill a frame - Supervisor record

;HERE TO PROCESS ANY SUPERVISOR MESSAGES THAT HAVE BEEN QUEUED FOR THIS LINE

FILSPR:	MOV	LDHSLH#(R3),R1		;ANY SUPERVISOR MESSAGES QUEUED?
	BEQ	FILZAP			;NO-GO SEE IF NEED TO ZAP SOMEONE
	MOV	R2,FILSVA		;YES-REMEMBER ADDRESS FOR BYTE COUNT
	INC	R2			;BUMP POINTER PAST COUNT BYTE
	CLR	FILCNT			;CLEAR COUNT
	CLRB	(R2)+			;STORE CHANNEL NUMBER IN FRAME
	SUB	#2,LKHLFT		;ACCOUNT FOR THE RECORD HEADER
2$:	MOV	(R1)+,(R2)		;COPY THE SUPERVISOR MESSAGE
	SWAB	(R2)+
	MOV	(R1)+,(R2)
	SWAB	(R2)+
	MOV	(R1)+,(R2)
	SWAB	(R2)+
	ADD	#6,FILCNT		;BUMP THE COUNT
	SUB	#6,LKHLFT		;AND REDUCE SPACE LEFT IN FRAME
	CMP	LDHSLT#(R3),R1		;END OF LIST?
	BEQ	4$			;YES
	BIT	#77,R1			;NO-END OF PACKET?
	BNE	12$			;NO-CONTINUE
4$:	DEC	R1			;YES-POINT TO START OF PACKET
	BIC	#77,R1
	PUSH	(R1)			;SAVE ADDRESS OF NEXT MESSAGE
	FREPKT				;GIVE UP THE PACKET
	POP	R1			;GET ADDRESS OF NEXT MESSAGE
	BEQ	14$			;IF NOTHING ELSE THERE
12$:	CMP	#6,LKHLFT		;ROOM FOR ANOTHER ONE?
	BLE	2$			;YES

;HERE WHEN FINISHED SENDING SUPERVISOR MESSAGES, EITHER BECAUSE THERE ARE NO 
;  MORE QUEUED OR BECAUSE WE HAVE FILLED THE FRAME

14$:	MOV	R1,LDHSLH#(R3)		;UPDATE HEAD POINTER
	BNE	16$			;IS THE LIST EMPTY NOW?
	CLR	LDHSLT#(R3)		;YES-CLEAR TAIL POINTER
16$:	MOVB	FILCNT,@FILSVA		;PUT COUNT INTO RECORD HEADER
					;AND FALL INTO FILZAP
	.PAGE
	.SBTTL	FILZAP - Fill a frame - Circuit Zappers

;HERE TO PROCESS REQUESTS TO ZAP A CHANNEL

FILZAP:	MOV	LDHZLH#(R3),R1		;ANY REQUESTS?
	BEQ	FILPKT			;NO-GO PROCESS OUTPUT PACKETS
2$:	SUB	#3,LKHLFT		;YES-ROOM FOR A 1 BYTE RECORD?
	BLT	6$			;NO-STOP FOR THIS TIME
	MOVB	#1,(R2)+		;YES-BYTE COUNT = 1
	ASR	R1			;GET CHANNEL NUMBER
	MOVB	R1,(R2)+		;PUT IN RECORD HEADER
	MOVB	#.CCZAP,(R2)+		;CIRCUIT ZAPPER
	ASL	R1			;GET NEXT REQUEST
	ADD	LDHSDB#(R3),R1
	BIC	#1,R1
	BNE	2$			;CONTINUE IF HAVE ANOTHER
6$:	MOV	R1,LDHZLH#(R3)		;FINISHED-UPDATE HEAD POINTER
	BNE	FILPKT			;IF LIST NOT EMPTY NOW
	CLR	LDHZLT#(R3)		;EMPTY-CLEAR TAIL POINTER
					;FALL INTO FILPKT
	.PAGE
	.SBTTL	FILPKT - Fill a frame - Process output packets

;HERE TO PROCESS OUTPUT PACKETS

FILPKT:	CMP	#4,LKHLFT		;ROOM FOR A 2 BYTE RECORD?
	BGT	1$			;NO-THATS ALL FOR THIS FRAME
	MOV	LDHXLH#(R3),SD		;YES-ANY SOCKETS QUEUED?
	BNE	10$			;YES-GO ON

;HERE WHEN NOTHING MORE LEFT TO PUT IN THE FRAME OR WHEN THE FRAME IS
;  FULL - BEFORE WE RETURN WITH THIS FRAME TO SEND, WE MUST CHECK TO SEE
;  IF WE QUEUED SOME SUPERVISOR MESSAGES FOR THE UPSTREAM LINE WHILE WE
;  WERE FILLING THIS PACKET (IF THIS IS THE UPSTREAM LINE, THIS IS NOT
;  NECESSARY!) - IF WE DID QUEUE SOME, WE WILL START OUTPUT FOR THE
;  UPSTREAM LINE BEFORE WE RETURN WITH THIS FRAME

1$:	MOV	LDHDDB#(R3),R4		;GET ADDRESS OF DDB
	MOV	DDLHUP#(R4),R0		;GET UPSTREAM LINE LDB
	BEQ	4$			;FINISHED IF NONE
	CMP	R0,R3			;IS THIS THE UPSTREAM LINE?
	BEQ	4$			;YES-NOTHING MORE NEEDED
	TST	LDHSLH#(R0)		;ANY SUPERVISOR MESSAGES WAITING?
	BEQ	4$			;NO
	TBBN	$L1BSY,LDHST1#(R0),4$	;YES-IS THE LINE BUSY?
	PUSH	R3			;NO-START IT UP NOW
	PUSH	R4			;LDHSTX@ DOES NOT RESPECT R4
	MOV	R0,R3
	PUSH	R2
	CALL	@LDHSTX#(R3)
	POP	R2
	POP	R4
	POP	R3
4$:	RETURN				;FINISHED HERE

;HERE IF MORE ROOM IN THE FRAME AND A SOCKET(S) IS QUEUED FOR OUTPUT

10$:	MOV	SDPKDH#(SD),R1		;GET PACKET TO SEND
	BEQ	DONSDB			;IF FALSE ALARM!
	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	ASL	R0			;FOR WORD INDEXING
	JMP	@FILDSP(R0)		;DISPATCH ON THE PACKET TYPE

;PACKET TYPE DISPATCH TABLE

	PURE
	.EVEN

FILDSP:	.WORD	FILDAT		;.PTDAT =  0 - DATA PACKET
	.WORD	FILCON		;.PTCON =  1 - CONNECTION REQUEST
.IF EQ ..SAT
	.WORD	FILACK		;.PTACK =  2 - CONNECT ACK
	.WORD	FILNAK		;.PTNAK =  3 - CONNECT NAK
.IFF
	.WORD	DONPKT		;.PTACK =  2 - CONNECT ACK
	.WORD	DONPKT		;.PTNAK =  3 - CONNECT NAK
.ENDC
	.WORD	FILFUN		;.PTFUN =  4 - FUNCTION
	.WORD	FILFUN		;.PTINT =  5 - INTERRUPT
	.WORD	FILEAT		;.PTEAT =  6 - EAT
	.WORD	FILDIS		;.PTDIS =  7 - DISCONNECT
	.WORD	FILKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	FILDAK		;.PTDAK = 11 - DISCONNECT ACK

	CODE
	.PAGE
	.SBTTL	FILDAT - Fill a frame - Data packets for existing circuit

;HERE FOR DATA PACKET

FILDAT:	TBBN	$S1JNK,SDSTS1#(SD),DONPKT;SHOULD WE IGNORE THIS PACKET?
	CALL	SETPNT			;SETUP R4, FILSVA, FILCNT AND START OF LOGICAL RECORD
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),FILDA2;Go on if protocol conversion not needed
	PUSH	R3			;Must respect R3 here
	CALL	LHOTPC#			;Do protocol conversion
	  BR	NOROOX			;If ran out of space in the frame
	  BR	STPSDX			;If ran out of send-ahead count
	POP	R3			;Restore R3
	BR	DONREC			;If ran out of data in the packet
.ENDC

FILDA2:	DEC	SDACNT#(SD)		;Reduce send-ahead count
	BLT	STPSDB			;Stop him if he has sent enough
	MOVB	(R4)+,R0		;Get data byte
	CALL	LKHBYO			;Store byte in the frame
	  BR	STRCNT			;If frame was full
	INCB	PKPNT(R1)		;Bump pointer
	DECB	PKCNT(R1)		;Reduce count
	BGT	FILDA2			;Continue if more there
	BR	DONREC			;No more data-go finish up

;HERE IF FRAME IS FULL - MUST STOP NOW BUT WE LEAVE THE SDB ON THE SEND LIST
;  SO WE WILL CONTINUE WITH IT NEXT TIME

.IF NE ..TPC
NOROOX:	POP	R3			;Restore R3
.ENDC
STRCNT:	MOV	FILCNT,R0		;GET BYTE COUNT
	BNE	2$			;MAKE SURE REALLY OUTPUT SOMETHING!
	SUB	#2,R2			;OPPS-RESET POINTER
	ADD	#2,LKHLFT		;AND COUNT
	RETURN				;THATS ALL

2$:	MOVB	R0,@FILSVA		;STORE BYTE COUNT
.IF EQ ..SAT
	ADD	R0,SDLHO1#(SD)		;UPDATE OUTPUT CHARACTER COUNT
	ADC	SDLHO2#(SD)
.ENDC
	RETURN

;HERE WHEN FINISHED EMPTYING THE PACKET

DONREC:	CALL	STRCNT			;STORE BYTE COUNT
DONPKT:	TST	R1			;Do we still have a packet?
	BEQ	DONSDB			;No-go on
	PUSH	R2			;FINISHED WITH THE PACKET-GIVE IT UP
	PUSH	R3
	CALL	JNKPKT#
DONPK9:	POP	R3
	POP	R2
	BR	DONSDB			;CONTINUE

;HERE IF MUST STOP OUTPUT FOR THIS SDB BECAUSE ITS SEND-AHEAD COUNT RAN OUT

.IF NE ..TPC
STPSDX:	POP	R3
.ENDC
STPSDB:	CALL	STRCNT			;STORE BYTE COUNT IN ROECORD
DONSDB:	MOV	SDLKLK#(SD),LDHXLH#(R3)	;TAKE THE SDB OUT OF THE SEND LIST
	BNE	2$			;LIST EMPTY NOW?
	CLR	LDHXLT#(R3)		;YES-CLEAR TAIL POINTER
2$:	MOV	#-1,SDLKLK#(SD)		;INDICATE NOT IN LIST
	TST	SDPKDH#(SD)		;More to send now?
.IF EQ ..TPC
	BEQ	10$			;No
.IFF
	BNE	3$			;Yes-go on
	TBBE	$H1GBP,SDLHS1#(SD),10$	;No-is a green ball pending?
	BIC	#$H1GBP,SDLHS1#(SD)	;Yes-but any longer!
	MOV	#.FNGRN,R0		;Send back a green ball
	CALL	BALBCK#
.ENDC
3$:	CMP	SDACNT#(SD),#2		;CAN THIS SOCKET SEND MORE NOW?
	BLT	10$			;NO
	MOV	LDHXLT#(R3),R0		;YES-LINK TO END OF SEND LIST
	BEQ	4$
	MOV	SD,SDLKLK#(R0)
	BR	5$

4$:	MOV	SD,LDHXLH#(R3)
5$:	MOV	SD,LDHXLT#(R3)
	CLR	SDLKLK#(SD)
10$:	JMP	FILPKT			;CONTINUE

;	Routine to setup frame building pointers

SETPNT:	MOV	R2,FILSVA		;REMEMBER ADDRESS OF BYTE COUNT
	INC	R2			;BUMP POINTER PAST COUNT BYTE
	MOVB	SDLHCN#(SD),(R2)+	;PUT CHANNEL NUMBER IN HEADER
	SUB	#2,LKHLFT		;ACCOUNT FOR THE HEADER BYTES
	CLR	FILCNT			;CLEAR BYTE COUNT FOR RECORD
	MOVB	PKPNT(R1),R4		;POINT TO FIRST DATA BYTE
	BNE	4$
	INC	R4
	INCB	PKPNT(R1)
4$:	ADD	#PKDATA-1,R4		;BUILD DIRECT POINTER TO DATA IN R4
	ADD	R1,R4
	RETURN

	.SBTTL	FILCON - Fill a frame - Connect packet

;HERE FOR CONNECT PACKET

FILCON:	FSTOP	ILP			;[ILLEGAL PACKET TYPE] - THIS IS
					;  PROCESSED LONG BEFORE IT GETS HERE!
	.PAGE
	.SBTTL	FILACK - Fill a frame - Connect ACK packet for in use circuit

;HERE FOR CONNECT ACK PACKET

.IF EQ ..SAT

FILACK:	PUSHB	PKDATA+1(R1)		;Save the flag byte
	PUSH	R2			;Save some AC's
	PUSH	R3
.IF NE ..TPC
	BITB	#100,PKDATA+1(R1)	;Does he want deferred echo mode?
	BNE	10$			;Yes-this is easy!
	MOVB	PKDATA+2(R1),R0		;No-get terminal profile
	BLE	10$			;We can't help him if no profile!
	CMP	#P..MAX+1,R0		;Or if its illegal! (remember 1 is 
	BLO	10$			;       added to profile code.)
	SUB	#12.,LKHLFT		;Room for a 10 byte record now?
	BGE	2$			;OK-go on
	POP	R3			;No room-wait until later
	POP	R4
	TST	(SP)+			;Clean off stack
	RETURN				;Give up on this packet

2$:	BIS	#$H1TPC,SDLHS1#(SD)	;Indicate need protocol conversion
	BIC	#$T1ECH,SDLHT1#(SD)	;Assume no echo wanted
	BITB	#010,PKDATA+1(R1)	;Right?
	BNE	4$			;Yes
	BIS	#$T1ECH,SDLHT1(SD)	;No
4$:	PUSH	R1			;Save another AC
	DEC	R0			;Store the profile bits
	ASL	R0
	MOV	TPFBTS#(R0),SDLHT5#(SD)
	MOVB	TPFLFH#(R0),SDLHT2#(SD)
	MOV	#PRFPNT#+2,R1		;Copy other profile parameters
	MOV	#PRFSIZ#-1,R2
	MOV	#SDTRLP#+1,R3
	CALL	CPYPRM#
	POP	R1
	MOVB	TPFDFS#(R0),SDLHBS#(SD)	;Store the break set bits
10$:
.ENDC
	CALL	JNKPKT#			;Give up the ACK packet
	POP	R3
	POP	R2
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),12$;Want terminal protocol conversion?
	MOVB	#10.,(R2)+		;Yes-store byte count
	MOVB	SDLHCN#(SD),(R2)+	;Store channel number
	MOV	#.PCSBT!.QBECN,R0	;Echo control function
	BIT	#$T1ECH,SDLHT1#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBELC,R0	;Echo LF after CR function
	BIT	#$T2ELC,SDLHT2#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBECL,R0	;Echo CR after LF function
	BIT	#$T2ECL,SDLHT2#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBRXE,R0	;Reverse X-enable function
	BIT	#$T4HOE,SDLHT4#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBXEN,R0	;X-enable function
	BIT	#$T4HIE,SDLHT4#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
12$:
.ENDC
	POP	R0			;Get the flag byte
	MOV	SDLHSC#(SD),R1		;ANY DATA TO SEND?
	BEQ	50$			;NO-FINISHED
	CLR	SDLHSC#(SD)		;YES-CLEAR THE POINTER
	PUSH	(R1)			;Save linked packet
	TBBN	040,R0,14$		;Should we send the login string?
	FREPKT				;Junk the login string
13$:	POP	R1			;Get linked pointer
	BEQ	50$			;Nothing there - we are finished
	PUSH	(R1)			;Save linked packet
14$:	CALL	LKHSPK#			;Send it
	BR	13$			;Check next packet

50$:	JMP	DONSDB			;Finished

.ENDC

;Subroutine called from above to store terminal parameter function into the
;  frame buffer
;	Z:set = value should be 0
;	Z:clr = value should be 1
;	C(R0) = function
;	CALL	PUTTFN

.IF NE ..TPC

PUTTFN:	BEQ	2$			;Go on if value should be 0
	INC	R0			;Make it 1
2$:	MOVB	#.CCPRE,(R2)+		;Store prefix code
	MOVB	R0,(R2)+		;Store function and value
	RETURN				;Thats all

.ENDC
	.PAGE
	.SBTTL	FILEAT - EAT PACKETS

;HERE FOR EAT PACKETS

FILEAT:
.IF EQ ..SAT
	TSTB	PKCNT(R1)		;Empty eat packet?
	BEQ	2$			;Yes-it always generates a gobbler
	CMPB	#.FNOSA,PKDATA(R1)	;No-output suppress ACK?
	BEQ	FILFUN			;Yes-does not generate a gobbler
2$:	SUB	#3,LKHLFT		;No-reduce amount left in frame
	MOVB	#1,(R2)+		;Store byte count
	MOVB	SDLHCN#(SD),(R2)+	;Store channel number
	MOVB	#.CCGBL,(R2)+		;Store data byte
	MOVB	#.PTINT,PKTYPE(R1)	;Change packet type to function in
					;  case we must re-do this
.ENDC

	.SBTTL	FILFUN - FILL A FRAME - FUNCTION AND INTERRUPT PACKETS

;HERE FOR FUNCTION OR INTERRUPT PACKET

FILFUN:	TSTB	PKCNT(R1)		;At least one data byte?
	BLE	DONP2T			;No-ignore it
	MOVB	PKDATA(R1),R0		;Yes-get function
	ASL	R0			;FOR WORD INDEXING
	CMP	#FNCMAX,R0		;LEGAL FUNCTION?
	BLO	DONP2T			;NO-IGNORE IT
	JMP	@FNCDSP(R0)		;YES-DISPATCH ON THE FUNCTION

;FUNCTION DISPATCH TABLE

	PURE

	.EVEN
FNCDSP:	.WORD	DONPKT		;.FNNUL =  0 - NULL
	.WORD	FNCOPS		;.FNHRD =  1 - HARD INTERRUPT
	.WORD	DONPKT		;.FNSFT =  2 - SOFT INTERRUPT
	.WORD	FNCOSA		;.FNOSA =  3 - OUTPUT SUPPRESS ACK
	.WORD	FNCOPS		;.FNOPS =  4 - OUTPUT SUPPRESS
	.WORD	DONPKT		;.FNOPH =  5 - HOLD OUTPUT
	.WORD	DONPKT		;.FNOPA =  6 - ALLOW OUTPUT
	.WORD	FNCCDP		;.FNCDP =  7 - CHANGE DEVICE PARAMETERS
	.WORD	FNCSDP		;.FNSDP = 10 - SET DEVICE PARAMETERS
	.WORD	FNCADP		;.FNADP = 11 - ACCESS DEVICE PARAMETERS
	.WORD	FNCSDP		;.FNRDP = 12 - REPLY WITH DEVICE PARAMETERS
	.WORD	DONPKT		;.FNDCN = 13 - DEVICE CONTROL
	.WORD	DONPKT		;.FNDST = 14 - DEVICE STATUS
	.WORD	DONPKT		;.FNADS = 15 - ACCESS DEVICE STATUS
	.WORD	DONPKT		;.FNCON = 16 - CONTINUE OUTPUT (^Q)
	.WORD	DONPKT		;.FNFHI = 17 - FORCE HARD INTERRUPT
	.WORD	FNCDEM		;.FNDEM = 20 - DEFERRED ECHO MODE CONTROL
	.WORD	FNCRQD		;.FNRQD = 21 - REQUEST DISCONNECT
	.WORD	FNCOPS		;.FNRQC = 22 - REQUEST BUFFER CLEAR
	.WORD	FNCREQ		;.FNREQ = 23 - REQUEST (YELLOW BALL)
	.WORD	FNCRSP		;.FNRSP = 24 - RESPONSE (ORANGE BALL)
	.WORD	FNCGRN		;.FNGRN = 25 - GREEN BALL
	.WORD	FNCRED		;.FNRED = 26 - RED BALL
	.WORD	FNCLST		;.FNLST = 27 - LOST DATA INDICATION (BLACK BALL)
	.WORD	FNCLSX		;.FNLSX = 30 - REFLECTED LOST DATA INDICATION
				;		 (GRAY BALL)
	.WORD	FNCBRK		;.FNBRK = 31 - BREAK RECEIVED OR REQUEST
	.WORD	FNCHNG		;.FNHNG = 32 - HANG UP REQUEST
	.WORD	FNCXHG		;.FNXHG = 33 - HARRD HANG UP REQUEST
	.WORD	DONPKT		;.FNRCC = 34 - Reconnect control
.IF NE ..TPC
	.WORD	FNCXGB		;.FNXGB = 35 - Character gobbler
	.WORD	DONPKT		;.FNSRQ = 36 - Status request
	.WORD	DONPKT		;.FNCLI = 37 - Clear login mode
	.WORD	FNCBIN		;.FNBIN = 40 - Output binary characters
	.WORD	FNCFLR		;.FNFLR = 41 - Force line re-type
.ENDC
FNCMAX=!.-FNCDSP

	CODE
	.PAGE
;HERE FOR .FNHRD, .FNOSA, OR .FNRQC - ANY FUNCTION WHICH REQUIRES .FNOSA REPLY

FNCOPS:	PUSH	R2			;Save valuable AC's
	PUSH	R3
	CALL	ACKOPS#			;Call common routine
	JMP	DONPK9			;Thats all

;HERE FOR .FNOSA - OUTPUT SUPPRESS ACK

FNCOSA:	BIC	#$S1JNK,SDSTS1#(SD)	;CLEAR THE JUNK BIT
DONP2T:	JMP	DONPKT			;Thats all

;HERE FOR .FNDEM = 20 - DEFERED ECHO MODE CONTROL

FNCDEM:	MOV	#.CCEDE,R0		;ASSUME WANT TO ENTER DEFERED ECHO
	TSTB	PKDATA+1(R1)		;RIGHT?
	BNE	CHRONE			;YES
	MOV	#.CCLDE,R0		;NO-SHOULD LEAVE
	BR	CHRONE			;GO SEND CHARACTER

;HERE FOR .FNRQD = 21 - REQUEST DISCONNECT

FNCRQD:
	PUSH	R2
	PUSH	R3
	CALL	REMOVE#			;REMOVE IT FROM THE DESTINATION LIST
	CLR	(R1)			;CLEAR THE LINK FIELD, PLAY IT SAFE.
	PUSH	R1			;SAVE PKT. POINTER
	CALL	DECPCN#			;DECREMENT SENDER'S PKT COUNT
	POP	R1			;RETRIVE PKT. PTR. TO SEND KILL PACKET.

	MOV	#.ERREQ,R0		;MAKE A KILL PACKET
	CALL	SETKIL#
	CALL	LKHSPK#
	POP	R3
	POP	R2
;---
; By this time, there should be a Disconnect Ack packet queued on the 
;  Destination List of this socket (by (PKT2)SNDKIL module).  It is changed 
;  to a Disconnect packet here and branch to FILDIS so that a yellow ball 
;  will be sent to TYMNET and a zapper sent after an orange ball is bounced 
;  back.
;---
	MOV	SDPKDH#(SD),R1		;A PACKET ON THE DESTINATION LIST ?
	BNE	10$			;YES, BRANCH

	MOV	#.ERREQ,-(SP)		;NO, MUST BE LOW ON FREE PACKETS
	JMP	FILKL2			;WE WILL JUST SEND A ZAPPER
10$:
	MOV	#<.PTDIS*400+1>,PKCNT(R1) ;CHANGE IT TO DISCONNECT WITH REASON
	MOVB	#.ERREQ,PKDATA(R1)
	JMP	FILDIS			;

;HERE FOR .FNREQ = 23 - REQUEST (YELLOW BALL)

FNCREQ:	MOV	#<.PCCON!.CIYEL>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO			;CONTINUE

;HERE FOR .FNRSP = 24 - RESPONSE (ORANGE BALL)

FNCRSP:	MOV	#<.PCCON!.CIORG>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO			;CONTINUE

;HERE FOR .FNGRN = 25 - GREEN BALL

FNCGRN:	MOV	#.CCGRN,R0		;GET CHARACTER TO SEND
	BR	CHRONE

;HERE FOR .FNRED = 26 - RED BALL

FNCRED:	MOV	#.CCRED,R0		;GET CHARACTER TO SEND
CHRONE:	SUB	#3,LKHLFT		;REDUCE AMOUNT LEFT IN FRAME
	MOVB	#1,(R2)+		;STORE BYTE COUNT
	MOVB	SDLHCN#(SD),(R2)+	;STORE CHANNEL NUMBER
	DEC	SDACNT#(SD)		;REDUCE SEND-AHEAD COUNT
	BR	CHRTW2			;GO STORE DATA AND FINISH UP
	.PAGE
;HERE FOR .FNLST = 27 - LOST DATA INDICATION (BLACK BALL)

FNCLST:	MOV	#<.PCCON!.CIBLK>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNLSX = 30 - REFLECTED LOST DATA INDICATION (GRAY BALL)

FNCLSX:	MOV	#<.PCCON!.CIGRY>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNBRK = 31 - BREAK RECEIVED OR REQUEST

FNCBRK:	MOV	#<.PCCON!.CIBRK>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNHNG = 32 - HANG UP REQUEST

FNCHNG:	MOV	#<.PCCON!.CIHNG>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNXHG = 33 - HARD HANG UP REQUEST

FNCXHG:	MOV	#<.PCCON!.CITRH>*400+.CCPRE,R0;GET CHARACTERS TO SEND
CHRTWO:	SUB	#4,LKHLFT		;REDUCE AMOUNT LEFT IN FRAME
	MOVB	#2,(R2)+		;STORE BYTE COUNT
	MOVB	SDLHCN#(SD),(R2)+	;STORE CHANNEL NUMBER
	MOVB	R0,(R2)+		;STORE FIRST CHARACTER
	SWAB	R0			;STORE SECOND CHARACTER
CHRTW2:	MOVB	R0,(R2)+
DONP4T:	JMP	DONPKT			;THATS ALL
	.PAGE
;Here for special character gobbler function - this function is used by the
;  terminal protocol converter to handle the hard interrupt and output suppress
;  characters.  This function is sent back to the TYMNET port (see PKTSLF)
;  in an EAT packet.  When received (here) we send a character gobbler to
;  TYMNET, followed by the echo of the character typed (3rd byte in the
;  packet) and send a hard interrupt function or an output suppress function
;  the other way (away from TYMNET)

.IF NE ..TPC

FNCXGB:	SUB	#7,LKHLFT		;Room for 7 bytes?
	BGE	2$			;Yes-go on
	JMP	STRCNT			;No-wait until next time

2$:	MOVB	#5,(R2)+		;Store 5 character data record
	MOVB	SDLHCN#(SD),(R2)+
	MOVB	#.CCGBL,(R2)+		;First is a character gobbler
	MOVB	#'^,(R2)+		;Next is "^X CR LF", where X is the
	MOVB	PKDATA+1(R1),(R2)	;  control character from the packet
	BISB	#100,(R2)+
	MOVB	#CR,(R2)+
	MOVB	#LF,(R2)+
	MOV	#.FNHIN*400+.PTEAT,R0	;Assume hard interrupt
	TSTB	PKDATA+2(R1)		;Right?
	BNE	4$			;Yes
	MOV	#.FNOPS*400+.PTINT,R0	;No-its output suppress
4$:	MOVB	#2,PKCNT(R1)		;Fix up the packet
	MOVB	R0,PKTYPE(R1)
	SWAB	R0
	MOVB	R0,PKDATA(R1)
	PUSH	R2
	PUSH	R3
	CALL	PKTRTN#			;Send it
	POP	R3
	POP	R2
	JMP	DONSDB			;Thats all

.ENDC
	.PAGE
;Here for .FNBIN = 40 - Output binary character

.IF NE ..TPC
FNCBIN:	TSTB	PKPNT(R1)		;Is this the first call for this packet
	BNE	10$			;No - skip tweek of pkpnt
	INCB	PKPNT(R1)		;Add bias required by SETPNT
	TST	SDACNT#(SD)		;Check send ahead count
	BEQ	10$			;No room - remove packet from send list
	INCB	PKPNT(R1)		;Skip over function subcode
	DECB	PKCNT(R1)		;Deduct function subcode from count
	CALL	SETPNT			;SETUP R4, FILSVA, FILCNT AND START OF LOGICAL RECORD
	JMP	FILDA2			;Continue
10$:	JMP	DONSDB			;Remove SDB from send list
.ENDC

;Here for .FNFLR = 41 - Force line re-type

.IF NE ..TPC
FNCFLR:	PUSH	R2
	PUSH	R3
	CALL	JNKPKT#			;Give up the packet
	CALL	LHIRE2#			;Re-echo the current input line
	JMP	DONPK9			;Thats all
.ENDC
	.PAGE
	.SBTTL	FNCSDP - Fill a frame - Terminal parameter functions

;Here for .FNSDP = 10 or .FNRDP = 12 - Set or Reply with device parameters

FNCSDP:	PUSH	#-1			;Indicate should change value but not
	BR	FNCTPR			;  report anything

;Here for .FNCDP = 7, Change device parameters

FNCCDP:	PUSH	#1			;Indicate should change value and
	BR	FNCTPR			;  report new value

;Here for .FNADP = 11 - Access device parameters

FNCADP:	CLR	-(SP)			;Indicate should not change value but
					;  should report current value
FNCTPR:	MOV	R2,FILSVA		;SAVE ADDRESS FOR BYTE COUNT
	INC	R2			;BUMP POINTER PAST COUNT BYTE
	MOVB	SDLHCN#(SD),(R2)+	;PUT CHANNEL NUMBER IN RECORD
	SUB	#2,LKHLFT		;ACCOUNT FOR THE HEADER
	CLR	FILCNT			;INITIALIZE THE BYTE COUNT
	MOVB	PKPNT(R1),R4		;GET POINTER INTO PACKET
	BNE	2$			;GO ON IF WE'VE USED THIS PACKET BEFORE
	INCB	PKPNT(R1)		;NEW PACKET-FIX UP THE POINTER
	DECB	PKCNT(R1)		;AND THE COUNT
	ASRB	PKCNT(R1)
	INC	R4
	CLRB	PKSEQ(R1)
2$:	ASL	R4			;MAKE POINTER
	ADD	R1,R4
	ADD	#PKDATA-1,R4
TPRNXT:	CMP	SDACNT#(SD),#2		;CAN WE SEND MORE NOW?
	BGE	2$			;YES
	TST	(SP)+			;NO-FIX UP THE STACK
	JMP	STPSDB			;AND STOP THIS SDB

2$:	CMP	#4,LKHLFT		;Room for 2 more character pairs?
	BLE	4$			;YES
	TSTB	PKCNT(R1)		;NO-ANY MORE LEFT IN PACKET?
	BEQ	5$			;NO
	TST	(SP)+			;YES-FIX UP THE STACK POINTER
	JMP	STRCNT			;AND STOP THIS

4$:	DECB	PKCNT(R1)		;MORE THERE?
	BGE	20$			;YES
5$:	TST	(SP)+			;NO-FINISHED-FIX UP THE STACK
.IF NE ..TPC
	MOVB	PKSEQ(R1),R0		;Need to send something back?
	BEQ	14$			;No-continue
	ASL	R0			;Yes-calculate byte count
	INC	R0
	MOVB	R0,PKCNT(R1)		;Store byte count
	MOVB	#.FNRDP,PKDATA(R1)	;Change to "Reply with parameters" function
	PUSH	R2			;Send it back
	PUSH	R3
	CALL	PKTRTN#
	POP	R3
	POP	R2
	CLR	R1			;Indicate no packet now
.ENDC
14$:
.IF NE ..TPC
	TSTB	SDLHBS#(SD)		;Break on all character?
	BMI	15$			;Yes
	TSTB	SDLHIL#(SD)		;No-input buffer limit in effect?
	BEQ	16$			;No-go on
	CMPB	SDLHIL#(SD),SDLHIC#(SD)	;Yes-is the buffer too big now?
	BHI	16$			;No
15$:	PUSH	R1			;Yes-must forward everything here!
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CALL	SNDTRP#
	POP	R4
	POP	R3
	POP	R2
	POP	R1
.ENDC
16$:	JMP	DONREC			;And go finish up

;Here for next parameter-value pair

20$:	MOVB	(R4)+,R0		;GET PARAMETER
	BIC	#^C177,R0		;Just 7 bits
	INCB	PKPNT(R1)		;Bump pointer
	CMP	#MAXTPR,R0		;VALID PARAMETER?
	BLOS	TPRSKP			;NO-SKIP IT!
	MOVB	TPRDSP(R0),R0		;YES-GET DISPATCH OFFSET
	BIC	#^C377,R0
	ASL	R0			;CHANGE TO WORD OFFSET
	ADD	R0,PC			;GO TO ROUTINE FOR PARAMETER
TPRBAS:
	.PAGE
;TERMINAL PARAMETER DISPATCH TABLE

	.MACRO	DSP  ADDR
.IF NB ADDR
	.BYTE	<ADDR-TPRBAS>/2
.IFF
	.BYTE	<TPRSKP-TPRBAS>/2
.ENDC
	.ENDM

.IF NE ..TPC
	.MACRO	DSPTPC  ADDR
	DSP	ADDR
	.ENDM
.IFF
	.MACRO	DSPTPC  ADDR
	DSP
	.ENDM
.ENDC

	PURE

TPRDSP:	DSP			;	=   0 - ILLEGAL
	DSPTPC	TPRCIC		;.TPCIC =   1 - COMMAND INTERRUPT CHARACTER
	DSP	TPRECH		;.TPECH =   2 - ECHO CONTROL
	DSPTPC	TPRBST		;.TPBST =   3 - BREAK SET
	DSPTPC	TPRITD		;.TPITD =   4 - IDLE TIMER DELAY
	DSP			;.TPTAP =   5 - "PAPER TAPE" MODE
	DSPTPC	TPRNMC		;.TPNMC =   6 - NETWORK MESSAGE CONTROL
	DSPTPC	TPRBRK		;.TPBRK =   7 - BREAK HANDLING
	DSP			;.TPPRF =  10 - TERMINAL PROFIL
	DSP	TPRRAT		;.TPRAT =  11 - BAUD RATE
	DSPTPC	TPRWID		;.TPWID =  12 - LINE WIDTH
	DSP			;.TPLEN =  13 - PAGE LENGTH
	DSP	TPROHE		;.TPOHE =  14 - OUTPUT HOLD ENABLE
	DSPTPC	TPRHIC		;.TPHIC =  15 - HARD INTERRUPT CHARACTER
	DSPTPC	TPRSIC		;.TPSIC =  16 - SOFT INTERRUPT CHARACTER
	DSPTPC	TPROSC		;.TPOSC =  17 - OUTPUT SUPPRESS CHARACTER
	DSPTPC	TPRDEL		;.TPDEL =  20 - DELETE CHARACTER
	DSPTPC	TPRLDC		;.TPLDC =  21 - LINE DELETE CHARACTER
	DSPTPC	TPRLRC		;.TPLRC =  22 - LINE RETYPE CHARACTER
	DSPTPC	TPRSHT		;.TPSHT =  23 - SIMULATE HORIZONTAL TAB
	DSPTPC	TPRSVT		;.TPSVT =  24 - SIMULATE VERTICAL TAB
	DSPTPC	TPRSFF		;.TPSFF =  25 - SIMULATE FORM FEED
	DSP	TPRMCD		;.TPMCD =  26 - MIN/MAX C.R. DELAY
	DSP	TPRFCD		;.TPFCD =  27 - FIXED C.R. DELAY
	DSP	TPRVCD		;.TPVCD =  30 - VARIABLE C.R. DELAY
	DSP	TPRLFD		;.TPLFD =  31 - LINE FEED DELAY
	DSP			;.TPHTD =  32 - HORIZONTAL TAB DELAY
	DSP			;.TPVTD =  33 - VERTICAL TAB DELAY
	DSP			;.TPFFD =  34 - FIXED FORM FEED DELAY
	DSP			;.TPVFD =  35 - VARIABLE FORM FEED DELAY
	DSP			;.TPBSD =  36 - BACKSPACE DELAY
	DSP	TPXLFI		;.TPLFI =  37 - LINE FEED INSERSION  *08/14/80 JWR*
	DSP	TPXCRI		;.TPCRI =  40 - CARRIAGE RETURN INSERSION *08/14/80 JWR*
	DSPTPC	TPRIMI		;.TPIMI =  41 - Image mode input
	DSPTPC	TPRIMO		;.TPIMO =  42 - Image mode output
	DSPTPC	TPRXLI		;.TPXLI =  43 - XLATE LOWER CASE INPUT
	DSPTPC	TPRXLO		;.TPXLO =  44 - XLATE LOWER CASE OUTPUT
	DSPTPC	TPRBDE		;.TPBDE =  45 - BACKSPACE DELETE ENABLE
	DSPTPC	TPREDB		;.TPEDB =  46 - ECHO DELETE CHAR. AS BACKSPACE
	DSPTPC	TPRXBD		;.TPXBD =  47 - EXTENDED DELETE ECHO
	DSP	TPRLCP		;.TPLCP =  50 - LOCAL COPY
	DSP			;.TPBC1 =  51 - 1ST ADDITIONAL BREAK CHARACTER
	DSP			;.TPBC2 =  52 - 2ND ADDITIONAL BREAK CHARACTER
	DSP			;.TPOPT =  53 - OUTPUT PENDING TIMER
	DSPTPC	TPRCCE		;.TPCCE =  54 - CONTROL CHARACTER ECHO
	DSPTPC	TPRESC		;.TPESC =  55 - "ESC" CHARACTER ECHO CONTROL
	DSPTPC	TPRCHS		;.TPCHS =  56 - Convert high spec char to "ESC"
	DSP			;.TPTYP =  57 - TERMINAL TYPE
	DSPTPC	TPRESQ		;.TPESQ =  60 - ESC SEQUENCE CONTROL
	DSP			;	=  61 - Not assigned
	DSPTPC	TPRFCR		;.TPFCR =  62 - ALLOW FREE CR/LF
	DSP			;	=  63 - NOT ASSIGNED
	DSP	TPRTRN		;.TPTRN =  64 - TRANSPARENCY MODE
	DSP	TPRADM		;.TPADM =  65 - ALTERNATE DEVICE MODE
	DSP	TPRIRT		;.TPIRT =  66 - INPUT BAUD RATE
	DSP	TPRORT		;.TPORT =  67 - OUTPUT BAUD RATE
	DSP	TPRIHE		;.TPIHE =  70 - INPUT HOLD ENABLE
	DSP	TPRKAT		;.TPKAT =  71 - KATAKANA
	DSP	TPRPAR		;.TPPAR =  72 - PARITY CONTROL
	DSPTPC	TPRALF		;.TPALF =  73 - AUTO-LINE FEED
	DSP			;.TPVTS =  74 - VERTICAL TAB SPACING
	DSP	TPXCRD		;.TPBLT =  75 - BELT PRINTER CONTROL
	DSP	TPXEHT		;.TPEHT =  76 - ECHO HORIZONTAL TAB
	DSP			;.TPSRC =  77 - Status request character
	DSP	TPXEBS		;.TPEBS = 100 - Echo backspace
	DSPTPC	TPXSCE		;.TPSCE = 101 - Suppress control char echo
	DSPTPC	TPXIBL		;.TPIBL = 102 - Input buffer limit
	DSP			;.TPTOB = 103 - Terminate output on break (TYMNET)
	DSP			;.TPECE = 104 - Echo ESC local (TYMNET)
	DSP			;.TPQMD = 105 - "Q" Mode (TYMCOM-370 3270 emulation)
	DSPTPC	TPXSOP		;.TPSOP = 106 - Suppress output(X.3 parameter))
	DSPTPC	TPXEDT		;.TPEDT = 107 - Line editing enable(X.3 parameter))
MAXTPR=!.-TPRDSP

	CODE
	.PAGE
;Define macro to generate instruction to pick up bit and SDB offset for a
;  status bit

.IF NE ..TPC
	.MACRO	GETBIT  BIT,OFFSET
.IF LT BIT-400
	MOV	#BIT*400+OFFSET'#,R0
.IFF
	MOV	#BIT+1+OFFSET'#,R0
.ENDC
	.ENDM

.ENDC

;HERE FOR ILLEGAL TERMINAL PARAMETER

TPRSKP:	INC	R4			;BUMP POINTER PAST VALUE
	BR	TPRNXT			;FINISHED WITH THIS PARAMETER

;HERE FOR TERMINAL PARAMETER .TPCIC = 1 - COMMAND INTERRUPT CHARACTER

.IF	NE	..TPC
TPRCIC:
	MOV	#SDLHCI#,R0
	BR	TPRNXV
.ENDC

;HERE FOR TERMINAL PARAMETER .TPECH = 2 - ECHO CONTROL

TPRECH:
.IF NE ..TPC
	TST	(SP)			;Access parameter ?
	BEQ	2$			;Yes, go on w/o changing bit setting
	BIS	#$T1ECH,SDLHT1#(SD)	;Assume he wants to echo
	BITB	#1,(R4)			;Right?
	BNE	2$			;Yes
	BIC	#$T1ECH,SDLHT1#(SD)	;No-clear our flag
.ENDC
2$:	MOV	#.QBECN,R0		;GET TYMNET CODE
	JMP	TPRBIT			;CONTINUE

;Here for terminal parameter .TPBST = 3 - Break set

.IF NE ..TPC
TPRBST:	MOV	#SDLHBS#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPITD = 4 - Idle time delay

.IF NE ..TPC
TPRITD:
	TST	(SP)			;Should the value be changed?
	BEQ	5$			;No, go on.
	MOV	#SDLHT6#,R0		;Yes, change the idle time down counter
	ADD	SD,R0
	MOVB	(R4),(R0)
5$:	MOV	#SDLHIT#,R0		;Get SDB offset for idle timer
	BR	TPRNXV
.ENDC

;Here for terminal parameter .TPBRK = 7 - Procedure on break

.IF NE ..TPC
TPRBRK:	MOV	#SDLHPB#,R0
	BR	TPRNXV
.ENDC

;Here for terminal parameter .TPNMC = 6 - Network message control

.IF NE ..TPC
TPRNMC:	GETBIT	$T5NMC,SDLHT5
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPWID = 12 - Line width

.IF NE ..TPC
TPRWID:	MOV	#SDLHLW#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPOHE = 14 - OUTPUT HOLD ENABLE

TPROHE:	MOV	#.QBRXE,R0		;GET TYMNET CODE
	JMP	TPRBIT			;CONTINUE
	.PAGE
;Here for terminal parameter .TPHIC = 15 - Hard interrupt character

.IF NE ..TPC
TPRHIC:	MOV	#SDLHHI#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPSIC = 16 - Soft interrupt character

.IF NE ..TPC
TPRSIC:	MOV	#SDLHSI#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPOSC = 17 - Output suppress character

.IF NE ..TPC
TPROSC:	MOV	#SDLHSO#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPDEL = 20 - Delete character

.IF NE ..TPC
TPRDEL:	MOV	#SDLHDL#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPLDC = 21 - Line delete character

.IF NE ..TPC
TPRLDC:	MOV	#SDLHLX#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC
	.PAGE
;Here for terminal parameter .TPLRC = 22 - Line retype character

.IF NE ..TPC
TPRLRC:	MOV	#SDLHRE#,R0		;Get SDB offset
TPRNXV:	ADD	SD,R0			;Get address of value in SDB
	TST	(SP)			;Should we change the value?
	BEQ	4$			;No-go on
	MOVB	(R4),(R0)		;Yes-change it
	TST	(SP)			;Should we report the value?
	BMI	10$			;No-finished with this one
4$:	PUSH	R3			;Free up another AC
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	MOVB	-1(R4),PKDATA+1(R3)	;Copy parameter
	MOVB	(R0),PKDATA+2(R3)	;Copy value
	INCB	PKSEQ(R1)		;Bump pointer
	POP	R3
10$:	INC	R4			;Bump pointer
	JMP	TPRNXT			;Thats all
.ENDC
	.PAGE

;Here for terminal parameter .TPSHT = 23 - Simulate horizontal tab

.IF NE ..TPC
TPRSHT:	GETBIT	$T4HTS,SDLHT4		;Get bit and SDB offset
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPSVT = 24 - Simulate vertical tab

.IF NE ..TPC
TPRSVT:	GETBIT	$T4VTS,SDLHT4		;Get bit and SDB offset
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPSFF = 25 - Simulate form feed

.IF NE ..TPC
TPRSFF:	GETBIT	$T4FFS,SDLHT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPMCD = 26 - MIN/MAX C.R. DELAY

TPRMCD:	PUSH	#.PCPMC			;GET TYMNET CODE
	BR	TPRFNF			;GO APPLY "FUNCTION F"

;HERE FOR TERMINAL PARAMETER .TPFCD = 27 - FIXED C.R. DELAY

TPRFCD:	PUSH	#.PCPMB			;GET TYMNET CODE
	BR	TPRVAL			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPVCD = 30 - VARIABLE C.R. DELAY

TPRVCD:	PUSH	#.PCPMA			;GET TYMNET CODE
TPRVAL:	MOVB	(R4)+,R0		;GET VALUE
	CMP	#17,R0			;CAN WE HANDLE THIS VALUE?
	BHIS	TPRPOP			;YES
	MOV	#17,R0			;NO-DO THE BEST WE CAN
	BR	TPRPOP

;HERE FOR TERMINAL PARAMETER .TPLFD = 31 - LINE FEED DELAY

TPRLFD:	PUSH	#.PCPMD			;GET TYMNET CODE
TPRFNF:	MOVB	(R4)+,R0		;GET VALUE
	TST	-2(SP)			;SET OR ACCESS?
	BEQ	6$			;ACCESS-DON'T BOTHER WITH "FUNCTION-F"
	CALL	TYNFIV#			;SET-APPLY INVERSE OF "FUNCTION-F"
	BR	TPRPOP			;CONTINUE

;HERE IF FUNCTION IS ACCESS

6$:	POP	R0			;GET FUNCTION
	BR	TPRPO2			;CONTINUE
	.PAGE
;Here for terminal parameter .TPIMO = 41 - Image mode output

.IF NE ..TPC
TPRIMO:	BIC	#$T2CRO,SDLHT2#(SD)	;Clear CR was output last flag
	GETBIT	$T1IMO,SDLHT1		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPIMI = 42 - Image mode input

.IF NE ..TPC
TPRIMI:	GETBIT	$T1IMI,SDLHT1		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC
	.PAGE
;Here for terminal parameter .TPXLI = 43 - Xlate lower case input

.IF NE ..TPC
TPRXLI:	GETBIT	$T5LCI,SDLHT5		;Get bit and SDB offset
	BR	TPRINV			;Continue
.ENDC

;Here for terminal parameter .TPXLO = 44 - Xlate lower case output

.IF NE ..TPC
TPRXLO:	GETBIT	$T5LCO,SDLHT5		;Get bit and SDB offset
	BR	TPRINV			;Continue
.ENDC

;Here for terminal parameter .TPBDE = 45 - Backspace delete enable

.IF NE ..TPC
TPRBDE:	GETBIT	$T5BDE,SDLHT5		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPEDB = 46 - Echo delete character as backspace

.IF NE ..TPC
TPREDB:	GETBIT	$T4EDB,SDLHT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPXBD = 47 - Extended delete echo

.IF NE ..TPC
TPRXBD:	GETBIT	$T4XBE,SDLHT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC
	.PAGE
;HERE FOR TERMINAL PARAMETER .TPLCP = 50 - LOCAL COPY

TPRLCP:
.IF NE ..TPC
	BIC	#$T4LCP,SDLHT4#(SD)	;Assume not local copy
	BITB	#1,(R4)			;Right?
	BEQ	2$			;Yes
	BIS	#$T4LCP,SDLHT4#(SD)	;No-set our bit
.ENDC
2$:	MOV	#.QBHDP,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;Here for terminal parameter .TPCCE = 54 - Control character echo control

.IF NE ..TPC
TPRCCE:	GETBIT	$T5ECC,SDLHT5		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPESC = 55 - "ESC" character echo control

.IF NE ..TPC
TPRESC:	GETBIT	$T5EED,SDLHT5		;Get bit and SDB offset
TPRN2B:	BR	TPRNXB			;Continue
.ENDC

;Here for terminal parameter .TPCHS = 56 - Convert high special chrs to "ESC"

.IF NE ..TPC
TPRCHS:	GETBIT	$T4HSP,SDLHT4		;Get bit and SDB offset
	BR	TPRNXB
.ENDC

;Here for terminal parameter .TPFCR = 62 - Allow free CR/LF

.IF NE ..TPC
TPRFCR:	GETBIT	$T4NFC,SDLHT4		;Get bit and SDB offset
TPRINV:	COMB	(R4)			;Invert the value
	PUSH	R4			;Indicate should invert returned value
	BR	TPRNX2			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPTRN = 64 - TRANSPARANCY MODE CONTROL

TPRTRN:	MOV	#<.PCCON+.CILTR>*400+<.PCCON+.CIETR>,R0;GET POSSIBLE VALUES
	BR	TPRCTL			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPADM = 65 - ALTERNATE DEVICE MODE CONTROL

TPRADM:	MOV	#<.PCCON+.CILAD>*400+<.PCCON+.CIEAD>,R0;GET POSSIBLE VAUES
TPRCTL:	TST	(SP)			;ACCESS OR SET?
	BNE	2$			;No-OK
	JMP	TPRSKP			;Yes-thats wrong!

2$:	BITB	#1,(R4)+		;SET-TEST VALUE
	BNE	TPRSTR			;OK IF 1
	SWAB	R0			;GET ALTERNATE CODE IF 0
	BR	TPRSTR

;HERE FOR TERMINAL PARAMETER .TPIRT = 66 - INPUT BAUD RATE

TPRIRT:;CALL	TPSIRT			;HANDLE THE INPUT BAUD RATE
;	INC	R4			;BUMP POINTER
;	BR	TPRNXT			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPRAT = 11 - BAUD RATE (SETS BOTH INPUT AND OUTPUT
;  RATES)

TPRRAT:;CALL	TPSIRT			;FIRST HANDLE THE INPUT BAUD RATE
					;FALL INTO OUTPUT BAUD RATE ROUTINE

;HERE FOR TERMINAL PARAMETER .TPORT = 67 - OUTPUT BAUD RATE

TPRORT:	PUSH	#.PCOBR			;GET TYMNET CODE
	MOVB	(R4)+,R0		;GET RATE
	BIC	#^C177,R0		;Just 7 bits
	CMP	#MAXRNT#,R0		;LEGAL RATE?
	BHIS	2$			;YES
	MOV	#MAXRNT#,R0		;NO
2$:	MOVB	TYNRNT#(R0),R0		;GET TYMNET RATE CODE
TPRPOP:	BIS	(SP)+,R0		;MERGE IN REST OF VALUE
	TST	(SP)			;SET OR ACCESS?
	BNE	TPRSTR			;SET
TPRPO2:	ASHI	-4,R0			;ACCESS-GET IN RIGHT PLACE
	BIS	#.PCQFL,R0		;ADD OTHER BITS
	BR	TPRSTR			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPIHE = 70 - INPUT HOLD ENABLE

TPRIHE:	MOV	#.QBXEN,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPKAT = 71 - KATAKANA MODE CONTROL

TPRKAT:	MOV	#.QBKAT,R0		;GET TYMNET CODE
TPRBIT:	BITB	#1,(R4)+		;SHOULD THE BIT BE SET?
	BEQ	TPRQSB			;NO
	INC	R0			;YES-SET IT
	BR	TPRQSB

;HERE FOR TERMINAL PARAMETER .TPPAR = 72 - PARITY CONTROL

TPRPAR:	MOVB	(R4)+,R0		;GET DATA BYTE
	TBBE	100,R0,2$		;DO WE REALLY WANT TO CHANGE PARITY?
	JMP	TPRNXT			;NO

2$:	ASR	R0			;YES-GET NEW VALUE
	ASR	R0
	BIC	#^C1,R0
	BIS	#.QBPAR,R0		;ADD TYMNET CODE
TPRQSB:	TST	(SP)			;SET OR ACCESS?
	BEQ	2$
	BIS	#.PCSBT,R0		;SET
	BR	TPRSTR

2$:	BIS	#.PCQBT,R0		;ACCESS
	BR	TPRSTR

;Here for terminal parameter .TPALF = 73 - Auto line feed

.IF NE ..TPC
TPRALF:	GETBIT	$T4ALF,SDLHT4		;GET BIT AND SDB OFFSET
	BR	TPRNXB			;CONTINUE
.ENDC

;HERE TO STORE TERMINAL PARAMETER INTO RECORD IN THE FRAME

TPRSTR:	CALL	TPSSTR			;Store parameter byte
	JMP	TPRNXT			;Continue

;Bridges for out-of-range routines!!

TPXCRD:	BR	TPRCRD
TPXEHT:	BR	TPREHT
TPXEBS:	BR	TPREBS
.IF NE  ..TPC
TPXSCE:	BR	TPRSCE
TPXSOP:	BR	TPRSOP
TPXEDT:	BR	TPREDT
.ENDC
TPXLFI:	BR	TPRLFI
TPXCRI:	BR	TPRCRI
.IF NE ..TPC
TPXIBL:	BR	TPRIBL
.ENDC
	.PAGE
;Here for terminal parameter .TPESQ = 60 - ESC sequence control

.IF NE ..TPC
TPRESQ:	GETBIT	$T5ESQ,SDLHT5		;Get bit and SDB offset
TPRNXB:	CLR	-(SP)			;Indicate value not inverted
TPRNX2:	PUSH	R2			;Free up an AC
	MOV	R0,R2			;Seperate bit and offset
	SWAB	R2
	BIC	#^C377,R0
	ADD	SD,R0			;Get address of bit
	TST	4(SP)			;Want to change the bit?
	BEQ	6$			;No-go on
	RORB	(R4)			;Yes-get new value into C
	BCS	2$			;Should we set it?
	BICB	R2,(R0)			;No-clear it
	BR	4$

2$:	BISB	R2,(R0)			;Yes-set it
4$:	TST	4(SP)			;Should we report the current value?
	BMI	20$			;No-go on
6$:	PUSH	R3			;Yes-free up another AC
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	ADD	#PKDATA+1,R3
	MOVB	-1(R4),(R3)+		;Copy parameter
	CLRB	(R3)			;Assume should return 0
	BITB	R2,(R0)			;Right?
	BEQ	12$			;Yes
	INCB	(R3)			;No-return 1
12$:	TSTB	4(SP)			;Should value be inverted?
	BEQ	14$			;No
	COMB	(R3)			;Yes-do that
	BICB	#^C1,(R3)
14$:	INCB	PKSEQ(R1)		;Increment return pointer
	POP	R3			;Restore register
20$:	POP	R2
	TST	(SP)+			;Remove flag from the stack
	INC	R4			;Bump pointer
	JMP	TPRNXT			;Thats all
.ENDC
	.PAGE

;Here for terminal parameter .TPBLT = 75 - Belt printer control (Tymnet
;  CR delay parameter)

TPRCRD:	COMB	(R4)			;Invert the value
	BIS	#$H1CRD,SDLHS1#(SD)	;Assume set
	BITB	#1,(R4)			;Right?
	BNE	2$			;Yes
	BIC	#$H1CRD,SDLHS1#(SD)	;No
2$:	MOV	#.QBCRD,R0		;Get Tymnet code
	BR	TPRBIT			;Continue

;HERE FOR TERMINAL PARAMETER .TPEHT = 76 - ECHO HORIZONTAL TAB

TPREHT:	MOV	#.QBECI,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;Here for terminal parameter .TPEBS = 77 - Echo backspace

TPREBS:	MOV	#.QBECH,R0		;GET TYMNET CODE
	BR	TPRBIT			;Continue
	.PAGE
;Here for terminal parameter .TPSCE = 101 - Suppress control character echo

.IF NE ..TPC
TPRSCE:	GETBIT	$T5SCE,SDLHT5		;Get bit and SDB offset
	BR	TPRNXB			;Continue
.ENDC

;Here for terminal parameter .TPIBL = 102 - Input buffer limit

.IF NE ..TPC
TPRIBL:	MOV	#SDLHIL#,R0		;Get SDB offset
	JMP	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPSOP = 106 - Suppress output

.IF NE ..TPC 
TPRSOP:	GETBIT	$S1JNK,SDSTS1
	BR	TPRNXB
.ENDC

;Here for terminal parameters .TPEDT = 107 - Line editing enable

.IF NE ..TPC
TPREDT:	GETBIT	$T5EDT,SDLHT5
	BR	TPRNXB
.ENDC

;HERE FOR TERMINAL PARAMETER .TPLFI = 37 - LINE FEED INSERSION

TPRLFI:
.IF NE ..TPC
	PUSH	R3			;Free up an AC
	TST	2(SP)			;Should we change anything?
	BEQ	4$			;No-go on
	MOVB	(R4),R0			;Yes-get new bits
	MOV	R0,R3			;Copy them
	ASHI	-4,R3			;Make mask
	COM	R3
	BIC	#^C17,R3
	BIC	R3,SDLHT2#(SD)		;Clear bits we are changing
	COM	R3
	BICB	R3,R0			;Remove extra bits
	BISB	R0,SDLHT2#(SD)		;Set desired bits
4$:	MOVB	SDLHT2#(SD),R0		;Get bits
	BIC	#^C17,R0		;Only 4 bits
	CALL	RTNINB			;Return the bits
	POP	R3			;Restore AC
.ENDC
	MOV	#.QBECL,R0		;Get tymnet code
	BR	TPREXX			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPCRI = 40 - CARRIAGE RETURN INSERSION

TPRCRI:
.IF NE ..TPC
	PUSH	R3			;Free up another AC
	TST	2(SP)			;Should we change anything here?
	BEQ	4$			;No-go on
	MOVB	(R4),R0			;Yes-get new bits
	MOV	R0,R3			;Copy them
	COM	R3			;Make into mask
	BIC	#^C160,R3
	BIC	R3,SDLHT2#(SD)		;Clear the bits we are changing
	ASHI	4,R0			;Position the bits
	COM	R3			;Remove any we are not changing
	BICB	R3,R0
	BISB	R0,SDLHT2#(SD)		;Set any bits we want to set
4$:	MOVB	SDLHT2#(SD),R0		;Get current bits
	ASHI	-4,R0			;In the right place
	BIC	#^C7,R0			;Only 3 bits
	CALL	RTNINB			;Return them
	POP	R3			;Restore AC
.ENDC
	MOV	#.QBELC,R0		;Get tymnet code
TPREXX:	BITB	#100,(R4)		;Are we changing the one TYMNET cares
					;  about?
	BEQ	2$			;Yes-go on
	JMP	TPRSKP			;No-forget it!

2$:	BITB	#4,(R4)+		;Should the bit be set?
	BEQ	4$			;No
	INC	R0			;YES
4$:	JMP	TPRQSB			;CONTINUE
	.PAGE
	.SBTTL	FILNAK - Fill a frame - Connect NAK packet

;HERE FOR CONNECT NAK PACKET

.IF EQ ..SAT
FILNAK:	PUSHB	PKDATA(R1)		;GET ERROR CODE
	PUSH	R2			;GIVE UP THE PACKET
	PUSH	R3
	CALL	JNKPKT#
	POP	R3
	POP	R2
	CALL	FRESOC			;CLEAN UP THE IN USE BIT
	BR	FILKL2			;CONTINUE
.ENDC

	.SBTTL	FILDIS - Fill a frame - Disconnect packet

;HERE FOR DISCONNECT PACKET

FILDIS:	TBBN	$H1DTP,SDLHS1#(SD),10$
	SUB	#4,LKHLFT		;Account for 4 byte record?
;	BGE	4$			;Yes
;	JMP	STRCNT			;No-can't do it this time!

4$:	BIS	#$H1DTP,SDLHS1#(SD)	;Yes-indicate we have a disconnect pending
	MOVB	#2,(R2)+		;Store byte count
	MOVB	SDLHCN#(SD),(R2)+	;Store channel number
	MOVB	#.CCPRE,(R2)+		;Store prefix character
	MOVB	#.PCCON!.CIYEL,(R2)+	;Store yellow ball character
10$:	CLR	SDACNT#(SD)		;Stop output
	JMP	DONSDB			;Thats all (when we get the orange
					;  ball back we will change the
					;  disconnect packet to a kill packet
					;  and process it!)

	.SBTTL	FILKIL - Fill a frame - Kill packet (on existing circuit)

;HERE FOR KILL CONNECTION PACKET

FILKIL:
.IF EQ ..SAT
	PUSHB	PKDATA(R1)		;GET ERROR CODE
.ENDC
	PUSH	R2
	PUSH	R3
	CALL	FINDIS#			;Finish processing the Disconnect or
					;  Kill packet
	POP	R3
	POP	R2
FILKL2:	SUB	#3,LKHLFT		;NEED 3 BYTES FOR THIS ONE
	MOVB	#1,(R2)+
	MOVB	SDLHCN#(SD),(R2)+	;PUT CHANNEL NUMBER IN RECORD
	MOVB	#.CCZAP,(R2)+		;STORE A CIRCUIT ZAPPER
	CLR	SDACNT#(SD)		;CLEAR THE SEND-AHEAD COUNT FOR THE SDB
.IF EQ ..SAT
	MOV	#.S7OCZ*10000,R0	;ASSUME NOT HERE DUE TO HOST DOWN
	CMPB	#.ERHSD,(SP)+		;RIGHT?
	BNE	2$			;YES-REPORT HOST ZAP AS REASON
	MOV	#.S7OCH*10000,R0	;NO-SET HOST DOWN AS REASON
2$:
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR#			;AND BREAK THE CIRCUIT
	JMP	FILPKT			;THATS ALL

	.SBTTL	FILDAK - Fill a frame - Disconnect ACK packet (on existing curcuit)

;HERE FOR DISCONNECT ACK PACKET

FILDAK:	PUSH	R2			;SAVE OUR STATE
	PUSH	R3
	CALL	JNKPKT#			;GIVE UP THE PACKET
.IF EQ ..SAT
	MOV	#.S7OCU*10000,R0	;GET REASON
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR#			;BREAK THE CIRCUIT
	CALL	FRESOC#			;GIVE UP THE SOCKET
	POP	R3			;RESTORE OUR STATE
	POP	R2
	JMP	FILPKT			;THATS ALL
	.PAGE
	.SBTTL	Subroutines used by terminal parameter routine

;Subroutine to handle input baud rate parameter
;	CALL	TPSIRT
.IF NE 0
TPSIRT:	MOVB	(R4),R0			;Get value
	BIC	#^C177,R0		;Just 7 bits
	CMP	#MAXRNT#,R0		;Legal value?
	BHIS	2$			;Yes
	MOV	#MAXRNT#,R0		;No-use highest legal value
2$:	MOVB	TYNRNT#(R0),R0		;Get Tymnet value
	TBBE	$H1CRD,SDLHS1#(SD),4$	;Is the CR delay flag set?
	BIS	#10,R0			;Yes
4$:	BIS	#.PCCIR,R0		;Put in the function bits
.ENDC					;Fall into TPSSTR to store byte

;Subroutine to store terminal parameter byte in output frame
;	C(R0) = Byte to store
;	CALL	TPSSTR

TPSSTR:	SUB	#2,LKHLFT		;Reduce amount left in frame
	SUB	#2,SDACNT#(SD)		;Reduce send-ahead count for the SDB
	ADD	#2,FILCNT		;Increase record byte count
	MOVB	#.CCPRE,(R2)+		;Store prefix character
	MOVB	R0,(R2)+		;Store data character
	RETURN				;Finished

;Subroutine to return 3 or 4 bits
;	C(R0) = New value for bits
;	C(R1) = Address of packet
;	C(R4) = Pointer to current parameter in packet
;	CALL	RTNINB

RTNINB:	TST	4(SP)			;Should we return anything?
	BMI	10$			;No-forget it!
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	ADD	#PKDATA+1,R3
	MOVB	-1(R4),(R3)+		;Copy parameter
	MOVB	(R4),(R3)		;Copy value
	BICB	#17,(R3)		;Clear low 4 bits
	BISB	R0,(R3)			;Put in new bits
	INCB	PKSEQ(R1)		;Bump pointer
10$:	RETURN				;Return
	.PAGE
	.SBTTL	LKHBYO - Store data byte in output frame

;Subroutine to store byte in frame buffer - if value of byte is less than
;  10 an escape code is stored before it
;	C(R0) = byte to store
;	CALL	LKHBYO
;	  failure return, byte not stored
;	normal return

LKHBYO::CMP	#10,R0			;IS IT ONE OF THE SPECIAL CODES?
	BLOS	LKHBY2			;NO-GO ON
	SUB	#2,LKHLFT		;YES-DO WE HAVE ROOM FOR 2 BYTES?
	BLT	RTN009			;No-give error return
	ADD	#2,FILCNT		;Yes-increase byte count
	DEC	SDACNT(SD)		;And reduce send-ahead count to account
					;  for the extra byte
	CLRB	(R2)+			;Insert escape
	BR	LKHBY4			;Continue

;HERE FOR NORMAL CHARACTER

LKHBY2:	DEC	LKHLFT			;Reduce space left in frame
	BLT	RTN009			;If no room for character
	INC	FILCNT			;Increase byte count
LKHBY4:	MOVB	R0,(R2)+		;STORE DATA BYTE IN FRAME
	ADD	#2,(SP)			;Give skip return
RTN009:	RETURN
	.PAGE
	.SBTTL	FNDHST - FIND SOURCE HOST

;SUBROUTINE TO FIND SOURCE HOST FOR A CONNECT PACKET
;	C(R1) = ADDRESS OF CONNECT PACKET
;	CALL	FNDHST
;	  ERROR RETURN - UNKNOWN HOST
;	NORMAL RETURN
;	C(R0) = INDEX * 2

.IF EQ ..SAT

FNDHST:	MOV	R1,R2			;POINT TO SRC NAME
	ADD	#PKDATA+16,R2
	CALL	XXRD50#			;CONVERT TO RADIX 50
	PUSH	R0
	CALL	XXRD50#
	PUSH	R0
	MOV	#DDLHDH#,R0		;POINT TO TABLE IN THE DDB
	ADD	R4,R0
	MOV	#4,R2			;SCAN ALL THE SLOTS FOR THIS FUNCTION
2$:	CMP	(R0)+,2(SP)		;THIS ONE?
	BEQ	4$			;MAYBE
	TST	(R0)+			;NO-BUMP POINTER
	BR	6$			;CONTINUE

4$:	CMP	(R0)+,(SP)		;CHECK 2ND HALF
	BEQ	10$			;THIS IS IT!
6$:	SOB	R2,2$			;CONTINUE IF MORE TO CHECK
	BR	12$			;NOT THERE-GIVE ERROR RETURN

;HERE WITH MATCH ON NAME

10$:	SUB	R4,R0			;GET INDEX
	SUB	#DDLHDH#+4,R0
	ASR	R0
	ADD	#2,4(SP)		;GIVE GOOD RETURN
12$:	ADD	#4,SP			;FIX UP THE STACK POINTER
	RETURN				;RETURN

.ENDC		;.IF EQ ..SAT
	.PAGE
	.SBTTL	SNDCMS - SEND TWO LOGIN CHARACTERS TO SUPERVISOR

;	C(R0) = FIRST OF TWO CHARACTERS TO SEND
;	C(R2) = POINTER TO SECOND CHAR
;	CALL	SNDLIP
;  R1 IS RESPECTED
;  R0 IS DESTROYED AND R2 IS INCREMENTED TO POINT TO NEXT CHARACTER

SNDLIP:	PUSH	R1			;RESPECT R1
	BIC	#77400,R0		;CLEAR 7 BITS IN UPPER BYTE
	SWAB	R0			;PUT FIRST CHARACTER IN UPPER HALF
	BISB	(R2)+,R0		;SET IN SECOND CHAR (WITHOUT SIGN EXTENSION)
	BIS	#100200,R0		;SET 8TH BIT IN BOTH CHARACTERS
	PUSH	#.SMLIP*10000		;SET LOGIN PAIR CODE
	BR	SNDCM1			;CONTINUE WITH SENDING REST OF MESSAGE


	.SBTTL	SNDCMS - SEND SINGLE LOGIN CHARACTER TO SUPERVISOR

;	C(R0) = CHARACTER TO SEND
;	CALL	SNDCMS
;  R1 AND R2 ARE RESPECTED

SNDCMS:	BIC	#^C177,R0		;ONLY SEND 7 BITS
	BIS	#200,R0			;BUT WITH THE 8TH BIT SET!
LKHSCM::PUSH	R1			;RESPECT R1
	PUSH	#.SMLGC*10000		;SR1
SNDCM1:	CLR	R1			;GET BUFFER NUMBER FOR SR2
.IF EQ ..SAT
	BISB	SDLHBF#(SD),R1
.IFF
	BISB	SDSOC#(SD),R1
.ENDC
	ASL	R1
.IF EQ ..SAT
	TBBE	$H1AUX,SDLHS1#(SD),4$	;IS THIS AN AUX-CIRCUIT?
	INC	R1			;YES-MAKE THE BUFFER NUMBER ODD!
.ENDC
4$:	PUSH	R1			;SR2
	PUSH	R0			;SR3 = CHARACTER(S)
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	POP	R1			;RESTORE R1
	RETURN				;AND RETURN
	.PAGE
	.SBTTL	DATA

;IMPURE DATA

	IMPURE
	.EVEN

FILSVA:	.WORD	0		;ADDRESS OF BYTE COUNT FOR RECORD
LKHLFT::.WORD	0		;NUMBER OF BYTES LEFT IN FRAME
FILCNT:	.WORD	0		;BYTE COUNT FOR CURRENT RECORD

;Pure data

	PURE
	.EVEN			;Need this to make sure its even!

	.END

  
k`