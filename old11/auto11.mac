	.TITLE	AUTO11  - AUTO BAUD ROUTINES FOR TYPE 11
	.SBTTL	AUTO11  - NEXILIS/JRG
;	Sampling clock: 9600 baud, sync mode
;	Funny output  : 1200 baud, restricted speed= 10 cps
;	Auto baud detect tables: primary table 11, secondary tables 20-40

	xlpar	;do't list parameter file
	code
;These auto-baud detect routines use a SCC type Async Interface as a high
;  speed clock for timing detect events.

;DEFINE OFFSETS FOR AUTO-BAUD TABLE
;
IDFLAG=0		;TERMINAL ID FLAG
MASK  =2		;MASK OF DON'T CARE BIT
MATCH =3		;MATCH CHAR
FRAME =4		;FRAMING FLAG
RATE  =5		;RESULT BAUD RATE
TYPE  =6		;..     TERMINAL TYPE,EG,CRTA,TRMG...
CODE  =7		;..     TERMINAL CODE,EG,ASC,EBCDIC...
INDEX =6		;SAME LOCATION OF TYPE, WHEN RATE=0
			; THIS BYTE SHOWS THE SECONDARY TABLE INDEX
COUNT =7		;SAME LOCATION OF CODE, WHEN RATE=0
			; THIS BYTE SHOWS THE REPEATED SEARCH TIMES
			; OF THE SAME SECONDARY TABLE
	IMPURE
FLG:		.WORD	0	;flag to let only one terminal
				;use SAVZON
SAVZOC:		.WORD	0
SAVZ2::		.WORD	0
SAVZON::	.BLKW	200
SAVZ1=.
	CODE

;SUBROUTINE TO INITIALIZE AUTO-BAUD DETECT ROUTINE
;	C(R1) = ADDRESS OF 2ND WORD IN DETECT TABLE
;	C(SD) = ADDRESS OF SDB
;	CALL	AINI11

AINI11::
;+--KS401
	TST	FLG		;are we the first?
	BNE	22$		;ne, no
	INC	FLG		;else, prohibit other to use
	CLR	SAVZOC
	MOV	#SAVZON,SAVZ2
	PUSH	R1
	MOV	#SAVZON,R0
	MOV	#200,R1
21$:	DEC	(R0)+
	SOB	R1,21$
	POP	R1
22$:
;---KS401
	MOV	#CHKRAT,SDTRC1#(SD)	;STORE INITIAL DISPATCH
	MOV	(R1),R1			;GET SAMPLING RATE
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);Store it in the SDB
	BISB	R1,SDTRS3#(SD)
	BISB	R1,SDTRS3#+1(SD)
	MOV	#.LFSET,R0		;Setup the interface hardware
	CALL	TRMFNC#
	CALL	RESSCC			;Reset SCC
	TBBN	$T0HWR,SDTRS0#(SD),30$	;HARD WIRED TERMINAL?
	MOV	#JIFX20#,R0		;NO-ALLOW 20 SECONDS FOR DETECT
	MOV	#BRDTMO#,R1
	CALL	TIMREQ#
30$:	MOV	#BAUDMS,SDTRIP#(SD)	;YES-SETUP FOR FUNNY OUTPUT
	CLR	SDTRC3#(SD)
	JMP	OUTFNY			;BEGIN FUNNY OUTPUT

RESSCC:	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GET ADB ADDRESS
	MOV	#SCCLE1,R0		;GET COUNT OF INITILIZATION BYTES
	MOV	#SCCINI,R1		;MAKE POINTER TO INITILIZATION DATA
10$:	MOVB	(R1)+,@ADGCON#(R4)	;MOVE DATA TO CONTROL REGISTER
	SOB	R0,10$			;CONTINUE UNTIL END
	POP	R4
	RETURN


	PURE
SCCINI:	.BYTE	3,300			;TURN OFF RX ENABLE TO FLUSH DATA BUFFER
	.BYTE	6,377			;SET UP SYNC REGISTERS
	.BYTE	7,377
	.BYTE	14.,43			;START DPLL, LEAVING ON BR GENERATOR
	.BYTE	3,321			;RX ENABLE
SCCLE1=	.-SCCINI
	CODE
	.PAGE
;SUBROUTINE TO RESET AUTO-DETECT ROUTINE - THIS IS A HARD RESET IN THAT THE
;  "FUNNY CHARACTER" OUTPUT IS STOPPED IMMEDIATELY, EVEN IF IS IN THE MIDDLEE
;  OF A CHARACTER!  WHEN THIS SUBROUTINE RETURNS, ALL SHARED WORDS IN THE
;  TERMINAL SDB ARE CLEAR.
;	CALL	ARST11

ARST11::
	CLR	SDTRIP#(SD)		;CLEAR THE POINTER
ARST1A:
	MOV	#HAVRAT,R1		;KILL ALL POSSIBLE TIMERS
	CALL	TIMKIL#
	MOV	#OUTFNY,R1
	CALL	TIMKIL#
	MOV	#SECTMO,R1
	CALL	TIMKIL#
	MOV	#BRDTMO#,R1
	CJMP	TIMKIL#

	.PAGE
;HERE WHEN DETECT CHARACTER RECEIVED WHEN DETECT CODE IS IDLE
;	C(R0) = CHARACTER
;	C(R1) = BAUD RATE CODE
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKRAT

CHKRAT:
	ASL	R1			;WORD INDEXING	
	MOV	ATOTXX#(R1),R3		;GET POINTER TO TABLE
	ADD	#6,R3			;POINT TO FIRST ENTRY of 8-byte record
	BR	AUTO0			;CONTINUE

;HERE WITH DETECT CHARACTER WHEN EXPECTING SECONDARY CHARACTER
;	C(R0) = CHARACTER
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKSND

CHKSND:
	PUSH	R0			;RESPECT R0
	MOV	#SECTMO,R1		;CLEAR POSSIBLE TIMER
	CALL	TIMKIL#
	POP	R0			;RESTORE R0
	CLR	R2			;HAVE TO CLEAR R2
	MOVB	SDTRC2#(SD),R2		;GET SECONDARY TABLE INDEX
	MOV	SECTBL#(R2),R3		;GET ADDRESS OF SECONDARY TABLE
AUTO0:
	CMP	#CHKSND,SDTRC1#(SD)	;ARE WE SCANNING A SECONDARY TABLE?
	BNE	4$			;NO-GO ON
	BIT	IDFLAG(R3),SDTRC5#(SD)	;CHECK TERMINAL ID
	BEQ	AUTO4			;EQ, NOT THIS ENTRY, TRY NEXT

;HERE IF WE ARE MATCH OF TERMINAL ID FOR THIS ENTRY

4$:
	MOV	R0,R2			;COPY CHARACTER
	BICB	MASK(R3),R2		;REMOVE DON'T CARE BITS
	CMPB	MATCH(R3),R2		;THIS ONE?
	BEQ	AUTO8			;YES
AUTO4:
	ADD	#10,R3			;BUMP TO NEXT ENTRY
	CMPB	#377,(R3)		;MORE THERE?
	BNE	AUTO0			;YES-CONTINUE
	MOV	#RTN002,SDTRC1#(SD)	;CHANGE DISPATCH SO WILL IGNORE INPUT
					;  FOR A WHILE
	MOV	#SECTMO,R1		;DELAY FOR 1/2 SECOND
	MOV	#JIFO2#,R0
	CJMP	TIMREQ#
SECTMO:
	CALL	RESSCC			;RESET SCC FOR NEW DETECT
	MOV	#CHKRAT,SDTRC1#(SD)	;RESET DETECT DISPATCH
RTN002:	RETURN

;HERE WITH MATCH ON THE CHARACTER

AUTO8:
;	MOVB	FRAME(R3),R1		;GET FLAGS
;	BPL	AUTO9			;GO ON IF DON'T CARE ABOUT FRAMING
;	TBBN	100,R1,14$		;SHOULD THERE BE A FRAMING ERROR?
;	TST	R0			;NO-WAS THERE ONE?
;	BMI	AUTO4			;YES-NOT A MATCH!
;	BR	AUTO9			;NO-GO ON

;HERE IF SHOULD HAVE A FRAMING ERROR

;14$:	TST	R0			;WAS THERE A FRAMING ERROR?
;	BPL	AUTO4			;NO-NO MATCH!

;HERE WITH MATCH ON EVERYTHING

AUTO9:
	CLR	R1			;FOR SAVETY
	MOVB	RATE(R3),R1			;YES-GET RATE
	SWAB	R1			;IN BOTH HALVES
	BISB	RATE(R3),R1
	BNE	22$			;GO ON IF FINISHED NOW
;
; HERE WITH EVERYTHING MATCH EXCEPT RATE(R3)=0
;
	MOVB	COUNT(R3),R1		;NEED TO REPEAT THIS TABLE?
	BEQ	19$			;EQ, NO NEED, TRY NEXT TABLE
	DECB	R1			;NE, MAYBE 1?
	BEQ	19$			;EQ, NO NEED, TRY NEXT TABLE
					;COUNT(R3)>=2
	TSTB	SDTRC2#+1(SD)		;FIRST SEARCH OF TABLE?
	BNE	18$			;NE, NOT FIRST
					;SRTRC2#+1(R3)=0, FIRST SEARCH
	MOVB	R1,SDTRC2#+1(SD)	;SAVE COUNTER
	BR	10$			;WAITING FOR NEXT CHAR.
18$:					;NOT FIRST
	DECB	SDTRC2#+1(SD)		;DO WE FINISH?
	BGT	10$			;GT, NOT YET
;
;HERE WE NEED CHANGE ANOTHER SECONDARY TABLE
;
19$:
	MOVB	INDEX(R3),SDTRC2#(SD)	;SAVE INDEX FOR SECONDARY TABLE
	CLRB	SDTRC2#+1(SD)		;INITIAL THE SAVE COUNT
	MOV	IDFLAG(R3),SDTRC5#(SD)	;SAVE TERMINAL ID FLAG
10$:	MOV	#CHKSND,SDTRC1#(SD)	;CHANGE DISPATCH FOR SECONDARY STUFF
	MOV	#10.,R0			;GET TIMEOUT TIME
	MOV	#SECTMO,R1		;AND TIMEOUT ADDRESS
	CJMP	TIMREQ#			;START TIMER AND LEAVE

;HERE WHEN RATE IS FINALLY KNOWN

22$:
	PUSH	R3			;SAVE POINTER
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);STORE RATE IN SDB
	BIS	R1,SDTRS3#(SD)
	MOV	SDTRIP#(SD),R0		;ARE WE OUTPUTING A MESSAGE?
	BEQ	24$			;NO
	MOVB	#-40,SDTRC3#+1(SD)	;;SET STATE TO STOP AFTER CURRENT BYTE
24$:	CALL	ARST1A			;CLEAR ALL POSSIBLE TIMERS
	POP	R3
	MOVB	TYPE(R3),R0		;GET TERMINAL TYPE
	BMI	26$			;IF SHOULD NOT SET IT
	PUSH	R3
	CALL	SETTTP#			;SETUP THE TERMINAL TYPE PARAMETERS
	  NOP				;Should not fail!
	POP	R3
26$:
	MOVB	CODE(R3),SDTRXC#(SD)	;STORE CODE IN THE SDB
	MOV	#.LFSET,R0
	CALL	TRMFNC#
	MOV	#RTN002,SDTRC1#(SD)	;CHANGE DISPATCH SO WILL IGNORE INPUT
					;  FOR A WHILE
	MOV	#HAVRAT,R1		;DELAY FOR 1/2 SECOND
	MOV	#JIFO2#,R0
	CJMP	TIMREQ#

;HERE 1/2 SECOND AFTER BAUD RATE IS DETERMINED

HAVRAT:
	CALL	ARST11			;MAKE SURE ALL TIMERS ARE CLEAR
	CJMP	BRDRDY#			;CONTINUE

	.PAGE
	.SBTTL	AUTO11  - FUNNY OUTPUT ROUTINE

;Funny output routine - this routine is entered directly from the output
;  done interrupt from the SCC.  No registers have
;  been saved.
;This subroutine uses several terminal sdb words for its data.  These are
;  words which are used by the terminal service for other things, but this
;  is OK since they are only used for input or for command mode.  Since this
;  routine is only active when in baud detect state, there is no possible
;  conflict (we hope).
;    THESE WORDS ARE USED AS FOLLOWS:
;	C(SDTRIP(SD))   = POINTER TO CURRENT OUTPUT BYTE (WORD)
;	C(SDTRC3(SD))   = BIT MASK FOR OUTPUT STREAM (BYTE)
;	C(SDTRC3+1(SD)) = OUTPUT STATE COUNTER (BYTE)
;			 =1, MEANS 10 BYTES OUTPUT DONE
;			 =2, MEANS 0.1 SECOND REACHED BEFORE 10-BYTE-DONE
;			  = -40,    AUTO BAUD ALREADY DETECTED
;				    NO MORE FUNNY OUTPUT
;	C(SDTRC4(SD)= COUNTER FOR THREE

OUTFNY:					;DO FUNNY OUTPUT
	MOV	#33,SDTXGP#(SD)		;FOR IMPROVE PERFORMANCE
					;OF FUNNY OUTPUT
	TST	SDTRIP#(SD)		;
	BEQ	OUTDON
	TSTB	@SDTRIP#(SD)		; STILL SOMETHING TO OUTPUT?
	BEQ	OUTDON			;EQ, NO MORE
					;ELSE, YES
	CMPB	#-40,SDTRC3#+1(SD)	;ARE WE BEING STOPPED?
	BEQ	OUTDON			;EQ, YES
					;
	CLRB	SDTRC3#+1(SD)		;CLEAR FLAG
	MOV	#OUTFNY,R1		;GOTO OUTFNY, AFTER .1 SECOND
	MOV	#JIFO10#,R0		;UNTIL NEXT TENTH SECOND
;	MOV	#5,R0		;UNTIL NEXT TENTH SECOND
	CALL	TIMREQ#			;MARK TIME FOR TENTH SECOND
;
; HERE WE OUTPUT 5 BYTES(4800-BAUD) AS ONE 1200-BAUD CHAR.
;
	MOV	#1$,SDTROD#(SD)		;AFTER START-BIT GOTO 1$
	MOVB	@SDTRIP#(SD),R0		;GET THE BYTE TO OUTPUT
	ASL	R0			;ONLY RIGHTMOST BIT AND START BIT
	JMP	STUFFO			;GO OUTPUT START BIT AND BIT 0
1$:					;NEXT ARE 7-BIT DATA AND STOP BIT
	MOV	#2$,SDTROD#(SD)		;OUPUT DONE, GOTO 2$
	MOVB	@SDTRIP#(SD),R0		;GET THE BYTE TO OUTPUT AGAIN
	ASR	R0			;KICK OFF THE RIGHTMOST BIT
	BIS	#200,R0			;WELCOME STOP BIT
	MOV	#3,SDTRC4#(SD)		;STILL 3 BYTES TO OUTPUT
	MOVB	R0,SDTRC3#(SD)		;SAVE IT
	BR	STUFFO			;GO OUTPUT BIT 1 AND 2
2$:
	DEC	SDTRC4#(SD)		;FINISHED?
	BLE	8$			;EQ, YES, DONE
	MOVB	SDTRC3#(SD),R0		;GET THE OUTPUT BYTE
	ASR	R0			;SHIFT 2 BITS
	ASR	R0			;
	MOVB	R0,SDTRC3#(SD)		;SAVE IT AGAIN
	BR	STUFFO			;GO OUTPUT NEXT 2 BITS
;
;HERE IS THE ROUTINE, AFTER OUTPUT EVERY FIVE BYTES(4800 BAUD)
; FINISHED OUTPUT ONE CHAR.(1200 BAUD)
;
8$:	
	MOV	#9$,SDTROD#(SD)		;JUST FOR SURE
	INC	SDTRIP#(SD)		;ADVANCE OUTBUF POINTER
	RETURN				;AFTER .1SEC, OUTFNY WILL START
					;A NEW OUTPUT(5 BYTES)
;
;+--KS401
9$:	INC	SAVZOC			
	MOV	SAVZ2,R0
	MOV	SDTRIP#(SD),R1
	DEC	R1
	MOV	R1,(R0)+
	MOVB	@R1,(R0)+
	MOVB	SDSOC#(SD),(R0)+
	MOV	R0,SAVZ2
	RETURN				
;---KS401

;HERE IF NO MORE FUNNY OUTPUT
;
OUTDON:
	CLR	SDTXGP#(SD)		;CLEAR BACK
	CLR	SDTRIP#(SD)		;CLEAR WORK AREA
	CLR	SDTRC3#(SD)		;
	CLR	SDTRC4#(SD)		;
	MOV	#OUTIDL#,SDTROD#(SD)	;DON'T COME HERE ANYMORE
	RETURN
;
; SUBROUTINES OF FUNNY OUTPUT
;
STUFFO:
	CMPB	#-40,SDTRC3#+1(SD)	;ARE WE BEING STOPPED?
	BEQ	OUTDON			;EQ, YES
	BIC	#^C3,R0			;TWO BITS AT A TIME
	MOVB	TABLE4(R0),R0		;TRANSFER 2-BIT TO 8-BIT
	BIS	#$T1ACX,SDTRS1#(SD)	;CLAIM WAITING FOR OUTPUT DONE
	MOV	SDTXGP#(SD),R1		;SPEEDUP THE FUNNY OUTPUT
;	CLR 	R1			;NO PACKET TO OUTPUT
	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GO OUTPUT 1 BYTE
	CALL	@(R4)			;THEN, WAITING FOR OUTPUT DONE
	POP	R4
	RETURN

	.PAGE



;DEFINE MACRO WHICH GENERATES THE PARITY BIT FOR A CHARACTER

	.MACRO	CHAR  CCC
CC=!CCC
$M=!1
$X=!0
	.REPT	7
.IF NE CC&$M
  $X=!$X+1
.ENDC
$M=!$M*2
	.ENDR
.IF NE $X&1
  CC=!CC!200
.ENDC
	.BYTE	CC
	.ENDM

;GENERATE THE BIT STRING FOR THE MESSAGES WITH EVEN PARITY

BAUDMS:	.BYTE	377,377,377,377,377,377,377 ;START OFF WITH 7 DELS
	CHAR	CR
	CHAR	LF
	.BYTE	377,377,377,377		;ALLOW FOR SLOW CARRIAGE RETURN
	.IRPC	C,<please type your terminal identifier >
.IF NB C
	CHAR	''C
.IFF
	CHAR	SPA
.ENDC
	.ENDM
BAUDME:	.BYTE	0,0
TABLE4:	.BYTE	0,17,360,377		;RELATIVE TO 00,01,10,11
	.EVEN
	.END
 