	.TITLE	LNKF2  - Interrupt routines for Tymshare host with KMC11
	.SBTTL	LNKF2  - Nexilis/JRG

	XLPAR			;DON'T LIST PARAMETER FILES
	CODE

	.SBTTL	LNKF2  - Input interrupt routine

;HERE FROM CODE IN COMMON ON INPUT READY INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFIn:	PUSH	R4		;SAVE R4
;		MOV	#LKFn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFIIN		;GO TO COMMON ROUTINE

LKFIN2::BIC	#$DVACP,@DDLFSR#(R4)	;CLEAR THE HARDWARE FLAG
	PUSH	R0			;SAVE ANOTHER AC
	PUSH	R1			;OR 2
	MOV	@DDLFIR#(R4),R0		;GET DATA WORD
	MOVB	DDLFIS#(R4),R1		;GET INPUT STATE
.IF NE ..BUG
	MOV	R0,@DBRNGP		;STORE DATA IN DEBUG RING
	ADD	#2,DBRNGP		;BUMP POINTER
	CMP	#DBRNGE,DBRNGP		;AT END OF RING?
	BHI	2$			;NO
	MOV	#DBRING,DBRNGP		;YES-RESET POINTER
.ENDC
2$:	ASL	R1
	JMP	@INPDSP(R1)		;DISPATCH ON THE INPUT STATE

;INPUT STATE DISPATCH TABLE

	PURE

INPDSP:	.WORD	INPIDL			;.ISIDL =  0 - INPUT IS IDLE
	.WORD	INPDAT			;.ISDAT =  1 - WAITING FOR DATA WORD
	.WORD	INPMSG			;.ISMSG =  2 - WAITING FOR MESSAGE
	.WORD	INPWAT			;.ISWAT =  3 - INPUT IS WAITING FOR
					;		 MAIN PROGRAM LEVEL
	.WORD	BADIST			;.ISIDX =  4 - Illegal
	.WORD	BADIST			;.ISDAX =  5 - Illegal
	.WORD	BADIST			;.ISMSX =  6 - Illegal
	.WORD	INPRST			;.ISRST =  7 - Reset
	.WORD	INPBLK			;.ISIDB = 10 - Block mode data
	.WORD	BADIST			;.ISDAB = 11 - Illegal
	.WORD	BADIST			;.ISMSB = 12 - Illegal

	CODE

;Here for illegal input state

BADIST:	FSTOP	BIS			;[Bad Input State - illegal input state
					;  value for type F link]

;HERE IF INPUT IS IDLE NOW

INPIDL:	MOV	R0,DDLFIX#(R4)		;NO-STORE DATA IN DDB
	BMI	INPID4			;IF DATA MESSAGE
	SWAB	R0
	CMPB	#MAXMSG#,R0		;NO-VALID MESSAGE?
	BGE	INPID3			;YES
INPID2:	CLR	R0			;NO!
	CLRB	DDLFIX#+1(R4)
INPID3:	BIC	#^C177,R0		;REMOVE JUNK
	MOVB	MSGLEN#(R0),DDLFIC#(R4)	;STORE WORD COUNT
	BNE	5$			;GO ON IF NOT FINISHED NOW
	JMP	INPDON			;FINISHED!

5$:	MOV	#DDLFIX#+2,R0		;GET POINTER TO MESSAGE BUFFER
	ADD	R4,R0
	MOV	R0,DDLFIP#(R4)
	MOVB	#.ISMSG,DDLFIS#(R4)	;SET NEW INPUT STATE
	JMP	INPACP			;AND DISMISS

;HERE IF DATA STRING

INPID4:	SWAB	R0
	BIC	#^C177,R0		;GET BYTE COUNT
	MOV	R0,DDLFCC#(R4)		;STORE BYTE COUNT
	INC	R0			;CHANGE TO WORD COUNT
	ASR	R0
	MOV	R0,DDLFIC#(R4)		;STORE WORD COUNT
	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFIK#(R4)		;STORE ADDRESS OF PACKET
	MOV	R1,DDLFIQ#(R4)
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)	;STORE COUNT IN PACKET
	INCB	DDLFIS#(R4)		;BUMP INPUT STATE
	BR	INPACP			;AND DISMISS INTERRUPT FOR NOW

;HERE WHEN EXPECTING DATA WORD FOR BLOCK MODE

INPBLK:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFBW#(R4)		;STORE IN PACKET
	DEC	DDLFBC#(R4)		;MORE COMING?
	BLE	INPBDN			;NO-FINISHED WITH THIS
	DECB	DDLFBY#(R4)		;YES-MORE ROOM IN THIS PACKET?
	BEQ	2$			;NO
	ADD	#2,DDLFBW#(R4)		;YES-JUST BUMP POINTER
	BR	INPACP			;AND DISMISS

;HERE IF MUST START A NEW PACKET

2$:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFBQ#(R4)		;LINK TO PREVIOUS PACKET
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;POINT TO START OF DATA
	MOV	R1,DDLFBW#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;RESET COUNT
	BR	INPACP			;AND DISMISS

;HERE WHEN BLOCK MODE IS FINISHED

INPBDN:	BICB	#^C3,DDLFIS#(R4)	;RESTORE THE STATE
	BISB	#$RQBLK,DDLFRQ#(R4)	;REQUEST MAIN PROGRAM SERVICE
	BR	INPDSM			;AND DISMISS

;HERE WHEN WAITING FOR RESET

INPRST:	SWAB	R0
	CMPB	#.MSBRK,R0		;IS IT THE "POKE" MESSAGE?
	BEQ	INPID2			;YES-THATS ILLEGAL HERE!
	CMPB	#.MSHSI,R0		;IS IT "SPECIFY HOST PORTS"?
	BNE	INPACP			;NO-IGNORE IT!
	CLRB	DDLFIS#(R4)		;YES-CHANGE STATE
	SWAB	R0			;RESTORE DATA WORD
	JMP	INPIDL			;AND GO PROCESS THE MESSAGE

;HERE WHEN EXPECTING A DATA WORD

INPDAT:	SWAB	R0			;GET BYTES IN RIGHT ORDER!
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
	DECB	DDLFIC#(R4)		;REDUCE THE WORD COUNT
	BEQ	INPDON			;IF FINISHED NOW
	DECB	DDLFPC#(R4)		;MORE TO GET-WILL IT FIT IN THE CURRENT
					;  PACKET?
	BEQ	INPDA6			;NO-GO GET ANOTHER PACKET
INPDA4:	ADD	#2,DDLFIP#(R4)		;BUMP POINTER
INPACP:	MOV	#$DVACP+$DVENB+4000,R0	;SETUP COUNT AND DR11 BITS
	BIS	R0,@DDLFSR#(R4)		;ACCEPT THE INPUT
2$:	TBBE	$DVRDY,@DDLFSR#(R4),4$	;Has the KMC seen this yet?
.IF EQ ..TST
	SOB	R0,2$			;No-wait for a while (but not too long!)
.IFF
	BR	2$
.ENDC
4$:	BIC	#$DVACP,@DDLFSR#(R4)
INPDSM:	POP	R1			;RESTORE AC'S
	POP	R0
	POP	R4
	RTI				;DISMISS INTERRUPT

;HERE IF MUST ALLOCATE ANOTHER PACKET FOR A LONG DATA MESSAGE

INPDA6:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFIQ#(R4)		;LINK IN THE NEW PACKET
	MOV	R1,DDLFIQ#(R4)		;SAVE ITS ADDRESS
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)
	BR	INPACP			;GO FINISH UP

;HERE WHEN EXPECTING AN ARGUMENT WORD FOR A CONTROL MESSAGE


INPMSG:	SWAB	R0			;NO-PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
INPMS2:	DECB	DDLFIC#(R4)		;EXPECTING MORE?
	BGT	INPDA4			;YES
					;NO-FALL INTO INPDON

;HERE WHEN FINISHED DOING INPUT - NOTIFY MAIN PROGRAM LEVEL

INPDON:	MOVB	#.ISWAT,DDLFIS#(R4)	;SET NEW INPUT STATE
	BISB	#$RQINP,DDLFRQ#(R4)	;REQUEST INPUT SERVICE
	BR	INPDSM			;AND DISMISS INTERRUPT

;HERE IF GET INPUT INTERRUPT WHILE WAITING FOR MAIN PROGRAM LEVEL TO PROCESS
;  SOME INPUT - THIS IS AN ERROR SINCE WE HAVE NOT YET ACCEPTED THE LAST
;  INPUT WORD!

INPWAT:	INC	DDERSI#(R4)		;COUNT THE FUNNY INTERRUPT!
	BR	INPDSM			;AND TRY TO CONTINUE (PROBABLY WE ARE
					;  TOO SICK TO CONTINUE AT THIS POINT!)
	.PAGE
;SUBROUTINE TO GET A PACKET FOR INPUT INTERRUPT ROUTINE
;	CALL	MAKPKI
;	C(R1) = ADDRESS OF PACKET
;  WARNING *** WHEN CALLED THE STACK MUST BE SET UP AS FOLLOWS:
;	C((SP))    = SAVED C(R1)
;	C((SP)-2)  = SAVED C(R0)
;	C((SP)-4)  = SAVED C(R4)
;	C((SP)-6)  = INTERRUPT RETURN ADDRESS
;	C((SP)-10) = INTERRUPT RETURN PSW

MAKPKI:	MAKPKT	.PLOPT#			;GET A PACKET
	BCS	2$			;If none available
	RETURN				;Finished if got one

;Here if no packet is available now

2$:	TST	DDLFXR#(R4)		;NONE AVAILABLE-ARE WE RECOVERING NOW?
	BEQ	4$			;NO-OK
	FSTOP	PWE			;[PACKET WAIT ERROR]

4$:	POP	DDLFX1#(R4)		;SAVE RETURN ADDRESS
	MOV	#INTRCV,DDLFXR#(R4)	;STORE ADDRESS OF RECOVERY ROUTINE
	BR	INPDSM			;AND GIVE UP FOR NOW!

;HERE AT MAIN PROGRAM LEVEL WHEN HAVE A PACKET AVAILABLE

INTRCV:	SETPSW	DDLFPL#(R4)		;RAISE TO INTERRUPT LEVEL
	MOV	(SP),R0			;GET RETURN ADDRESS
	CLR	(SP)			;PUT FAKE PSW ON THE STACK
	PUSH	R0			;THEN THE RETURN ADDRESS
	PUSH	R4			;THEN R4
	SUB	#4,SP			;THEN 2 GRABBAGE WORDS
	JMP	@DDLFX1#(R4)		;CONTINUE WHERE WE LEFT OFF!
	.PAGE
	.SBTTL	LNKF2  - Output interrupt routine

;HERE FROM CODE IN COMMON ON OUTPUT DONE INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFOn:	PUSH	R4		;SAVE R4
;		MOV	$HSn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFOIN		;GO TO COMMON ROUTINE

LKFOU2::BIC	#$DVOUT,@DDLFSR#(R4)	;CLEAR THE OUTPUT FLAG
	PUSH	R0			;SAVE ANOTHER AC
	ADD	DDLFOS#(R4),PC		;DISPATCH ON OUTPUT STATE
	BR	LFONRM			;.OSNRM = 0 - NORMAL OUTPUT
	BR	LFOHLD			;.OSHLD = 2 - OUTPUT HELD BLOCK DATA
	BR	LFOBLK			;.OSODD = 4 - OUTPUT NON-ALLIGNED DATA
;	BR	LKOBMO			;.OSBMI = 6 - Block output requested

;Here after sending first word to request block mode output from host

LKOBMO:	MOVB	#.ISIDB,DDLFIS#(R4)	;Update the input state (remember that
					;  the KMC in the host is a half-duplex
					;  device!!!)
	PUSH	R1			;SAVE ANOTHER REGISTER
	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFBK#(R4)		;STORE ITS ADDRESS
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;POINT TO FIRST DATA  BYTE
	MOV	R1,DDLFBW#(R4)		;STORE DATA POINTER
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;INITIALIZE COUNT
	POP	R1			;RESTORE REGISTER
	CLR	DDLFOS#(R4)		;Fix up the output state
					;Fall into normal output routine

;HERE FOR NORMAL OUTPUT

LFONRM:	DECB	DDLFOC#(R4)		;ANY MORE TO OUTPUT?
	BLT	OUTDON			;NO
	MOV	@DDLFOP#(R4),R0		;YES-GET WORD
	ADD	#2,DDLFOP#(R4)		;BUMP OUTPUT POINTER
OUTPTX:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
OUTPTI:	PUSH	R0			;SAVE AWAY DATA
	MOV	#4000,R0		;Set counter
2$:	TBBE	$DVDON,@DDLFSR#(R4),4$	;Has the KMC seen our bit yet?
.IF EQ ..TST
;	DEC	HNGCNT			;No-wait for a while
;	BGT	2$			;But not too long!
	SOB	R0,2$			;No-wait for a while - But not too long!
	TST	(SP)+
	BR	OUTDON			;Too long-forget it!!
.IFF
	BR	2$
.ENDC

4$:;	MOV	R0,@DDLFOR#(R4)		;OUTPUT IT
	POP	@DDLFOR#(R4)		;OUTPUT IT
	BIS	#$DVOUT+$DVENB,@DDLFSR#(R4);MAKE IT VISIBLE
OUTDSM:	POP	R0			;RESTORE AC'S
	POP	R4
	RTI				;AND DISMISS


;HERE TO OUTPUT NON-ALLIGNED DATA

LFOBLK:	DECB	DDLFOC#(R4)		;MORE TO OUTPUT?
	BLT	OUTDON			;NO
	CLR	R0			;YES-GET THE WORD TO OUTPUT
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	SWAB	R0
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	BR	OUTPTI			;AND GO OUTPUT IT

;HERE TO OUTPUT 2ND WORD OF THE BLOCK MODE HOLD BUFFER

LFOHLD:	CLR	DDLFOS#(R4)		;ASSUME ALLIGNED
	BIT	#1,DDLFOP#(R4)		;IS THE FOLLOWING OUTPUT WORD ALLIGNED?
	BEQ	2$			;YES
	MOV	#.OSODD,DDLFOS#(R4)	;NO-MUST DO IT THE HARD WAY!
2$:	MOV	DDLFOZ#(R4),R0		;GET ADDRESS OF SDB
	MOV	SDLFVH#+2(R0),R0	;GET WORD TO OUTPUT
	BR	OUTPTX			;AND GO OUTPUT IT

;HERE IF FINISHED WITH THIS MESSAGE

OUTDON:	BISB	#$RQOUT,DDLFRQ#(R4)	;REQUEST OUTPUT SERVICE
	BR	OUTDSM			;AND DISMISS

; LKFENB -SUBROUTINE TO ENABLE THE DR11

LKFENB:: TBBE	$DVDON,@DDLFSR#(R4),10$	;IS THE INTERFACE IN GOOD CONDITION
	CMP	#-1,@DDLFIR#(R4)	;NO, AND IS THE CABLE HANGING LOOSE
	BEQ	20$			;YES, DON'T ENABLE IT
10$:	MOV	#$DVENB,@DDLFSR#(R4)	;ENABLE THE INTERFACE
	ADD	#2,(SP)			;SKIP RETURN ON ENABLE
20$:	RETURN				;THATS ALL

; LKFDII - DISABLE THE DR11 INTERFACE

LKFDII:: CLR	@DDLFSR#(R4)		;DISABLE THE INTERFACE
	RETURN

; LKFACP - ACCEPT THE LAST WORD OF A BLOCK AND ENABLE FOR MORE DATA

LKFACP:: BIS	#$DVACP+$DVENB,@DDLFSR#(R4);ACCEPT THE LAST INPUT WORD
;	TBBE	$D0KMC,(R4),10$		;GO ON IF NOT KMC
	CLR	R2			;KMC-WAIT UNTIL HE CLEARS HIS BIT
4$:	TBBE	$DVRDY,@DDLFSR#(R4),6$
.IF EQ ..TST
	SOB	R2,4$
.IFF
	BR	4$
.ENDC
6$:	BIC	#$DVACP,@DDLFSR#(R4)
	RETURN

;LKFSTO - START AN OUTPUT SEQUENCE

LKFSTO::; TBBE	$D0KMC,(R4),4$		;GO ON IF NOT KMC
	MOV	#20000,R2		;KMC-set counter
2$:	TBBE	$DVDON,@DDLFSR#(R4),4$	;Has the host seen his bit yet?
.IF EQ ..TST
	SOB	R2,2$			;No-wait for a while!
.IFF
	BR	2$
.ENDC
4$:	MOV	R0,@DDLFOR#(R4)		;OUTPUT THE WORD
	BIS	#$DVOUT+$DVENB,@DDLFSR#(R4);MAKE IT VISIBLE
	RETURN

;LKFCLR - CLEAR OUR BITS IN THE DR11C

LKFCLR:: BIC	#$DVACP!$DVOUT,@DDLFSR#(R4);CLEAR THE HARDWARE FLAG BITS
	RETURN

	.END
  