	.TITLE	LKHPK3 - LINK H - TYMSHARE T.201 PROTOCOL - PACKET LEVEL ROUTINES
	.SBTTL	LKHPK3 - Nexilis/JRG

	XLPAR
.HLIST=!1
	CODE

	.SBTTL	EMPFRM - EMPTY A FRAME - DATA RECORDS
;
;	call FREPKT when orange ball is received and disconnect is
;		pending				6/29/81
;
;HERE WITH DATA RECORD

LKHDAT::INC	SD			;FIX UP THE CHANNEL NUMBER
	CMPB	LDHCHN#(R3),SD		;LEGAL CHANNEL NUMBER?
	BHI	1$			;YES-GO ON
	MOV	#.EFBCN,R0		;NO-ERROR = BAD CHANNEL NUMBER
	INC	DDERIS#(R4)		;COUNT THER ERROR
	JMP	BADFRM#			;GO SNIP LINE

1$:	ASL	SD			;YES-FIX IT FOR WORD INDEXING
	ADD	LDHSDB#(R3),SD		;FIND CORRESPONDING SDB
	MOV	(SD),SD
	BEQ	2$			;IF NONE LINKED
	BIT	#1,SD			;REALLY A SDB?
	BEQ	4$			;YES
2$:	ADD	R0,R2			;NO-JUST IGNORE THE DATA
	BR	DATDN4

;HERE WITH SDB CORRESPONDING TO THE CHANNEL

4$:	PUSH	R0			;PUT BYTE COUNT ON THE STACK
.IF EQ ..SAT
	ADD	R0,SDLHI1#(SD)		;UPDATE INPUT CHARACTER COUNT
	ADC	SDLHI2#(SD)
.ENDC
DATLP1:	DEC	(SP)			;MORE THERE?
	BMI	DATDN3			;NO-FINISHED
DATLP2:	MOVB	(R2)+,R0		;YES-GET NEXT BYTE
DATLP3:	CMP	#10,R0			;SPECIAL?
	BHI	DATSP4			;YES
DATLP4:
.IF NE ..TPC
	TBBN	$H1TPC,SDLHS1#(SD),DATLP6;Don't get a packet here if doing
					 ;  terminal protocol conversion
.ENDC
	CALL	LKHNPK#			;Get a packet
	CLRB	PKTYPE(R1)		;Make into a data packet
	ADD	#PKDATA,R1		;POINT TO FIRST DATA BYTE
DATLP6:
.IF EQ ..SAT
	TBBE	$H1PRJ,SDLHS1#(SD),20$	;IS THIS A PROJECT CODE CHARACTER?
	PUSH	R0			;Yes-save the character
	BIC	#^C177,R0		;JUST 7 BITS
	TSTB	SDLHPC#(SD)		;IS 1ST SLOT EMPTY?
	BNE	4$			;NO
	MOVB	R0,SDLHPC#(SD)		;YES-STORE CHARACTER
	BR	10$			;AND CONTINUE

4$:	TSTB	SDLHPC#+1(SD)		;IS 2ND SLOT EMPTY?
	BNE	6$			;NO
	MOVB	R0,SDLHPC#+1(SD)	;YES-STORE CHARACTER
	BR	10$			;CONTINUE

6$:	PUSH	R0			;SAVE THIS CHARACTER
	CALL	SNDPRJ			;SEND 3 CHARACTERS TO THE SUPERVISOR
	POP	R0			;RESTORE CHARACTER
	CMP	#40.,SDLHI1#(SD)	;Do we have more than 40 chars of project code
	BLO	12$			;Yes, terminate accumulation of pc
10$:	CMP	#CR,R0			;IS THIS THE END OF THE PROJECT CODE?
	BLOS	12$			;YES
	CMP	#';,R0			;MAYBE, is it a semi-colon?
	BNE	16$			;No-go on
12$:	BIC	#$H1PRJ,SDLHS1#(SD)	;INDICATE NO MORE PROJECT CODE!
	TST	SDLHPC#(SD)		;ANY LEFT UNSENT?
	BEQ	16$			;NO-ALL FINISHED WITH THIS
	CLR	R0			;YES-CLEAR OUT 3RD CHARACTER
	CALL	SNDPRJ			;AND SEND 1 OR 2 CHARACTERS
16$:	POP	R0			;Restore character

	.IF NE ..TPC
; FOR HOSTS THAT DO NO USE TYMSHARE HOST-BASE PROTOCOL (SUCH AS RSX, RSTS
;  OR HOSTS USING X.25), THE PROJECT CODE ENTERED ON THE "PLEASE LOG IN"
;  IS DISCARDED HERE
	TST	SDLHSC#(SD)		;IS THERE A SAVED CONNECT PACKET
	BNE	DATLP9			;YES, DISCARD THIS CHARACTER.
	.ENDC

20$:
.ENDC
.IF NE ..TPC
	TBBN	$H1TPC,SDLHS1#(SD),30$	;Doing terminal protocol conversion?
.ENDC
	MOVB	R0,(R1)+		;No-just store byte
.IF NE ..TPC
	BR	DATLP9			;Continue

30$:	PUSH	R2			;Save frame pointer
        PUSH    R3                      ;ADDED JWR 11-19-80, FOR CYTROL.
                                        ;***********PATCH***************
	CALL	LHITPC#			;Do the work
        POP     R3                      ;*********ALSO ADDED JWR********
                                        ;END OF CYTROL PATCH.
	POP	R2			;Restore frame pointer
	CLR	R1			;Remember no packet to send
.ENDC
DATLP9:	DEC	(SP)			;MORE?
	BMI	DATDN1			;NO-FINISHED
	MOVB	(R2)+,R0		;YES-GET NEXT DATA BYTE
	CMP	#10,R0			;SPECIAL
	BLOS	DATLP6			;No-continue
	BR	DATSP1			;Yes

;HERE WHEN FINISHED

DATDN1:	TST	R1			;NULL PACKET POINTER?
.IF NE	..TPC
	BNE	DATDN2			;NO - DO REGULAR STUFF
	TBBE	$H1TPC,SDLHS1#(SD),DATDN3 ;SKIP THIS NOT DOING TPC
	CMPB	#200,SDLHBS#(SD)	;CHECK FOR DELAYED BREAK SET
	BNE	DATDN3			;EVERYTHING IS OK THEN
	CALL	SNDTPK			;SEND DATA PACKETS ON THEIR WAY
	BR	DATDN3
.IFF
	BEQ	DATDN3			;YES - DON'T TRY TO SEND IT
.ENDC
DATDN2:	CALL	SNDTYM			;SEND PENDING PACKET
DATDN3:	TST	(SP)+			;FIX UP THE STACK
DATDN4:	JMP	LKHNXT#			;CONTINUE WITH THE FRAME
	.PAGE
;HERE FOR SPECIAL CHARACTER CODE WHEN DATA PACKET IS BEING BUILT

DATSP1:	TST	R0			;IS THIS AN ESCAPE CODE?
	BNE	DATSP3			;NO-GO ON
DATSP2:	DEC	(SP)			;YES-DO WE HAVE ANOTHER BYTE?
	BMI	BADCPR			;No-this is very serious!
	MOVB	(R2)+,R0		;Yes-get next byte
.IF EQ ..TPC
	BR	DATLP6			;CONTINUE
.IFF
	TBBE	$H1TPC,SDLHS1#(SD),DATLP6;Continue if doing TPC
	BIC	#77,R1			;POINT TO HEAD OF PACKET IF ANY
	BEQ	DATLP6			;NO PACKET - CONTINUE
	FREPKT				;GIVE UP THE PACKET
	BR	DATLP6
.ENDC

DATSP3:	PUSH	R0			;SAVE THE CODE
.IF NE	..TPC
	TST	R1
	BEQ	20$			;FINISH PACKETS OFF
	TBBE	$H1TPC,SDLHS1#(SD),10$	;SKIP THIS IF NOT DOING TPC
	CALL	SNDTPK			;SEND TERMINAL PACKET
	BR	20$
10$:
.ENDC
	CALL	SNDTYM			;SEND THE DATA PACKET
20$:	POP	R0			;RESTORE CODE
DATSP4:	CALL	LKHNPK#			;Get a packet
	MOVB	#.PTFUN,PKTYPE(R1)	;Make into a function packet
	ADD	#PKDATA,R1		;Point to first byte
	MOV	#24.,PARCNT		;INITIALIZE TERMINAL PARAMETER COUNT
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE SPECIAL CHARACTER
	BR	ESCAPE			;.CCESC = 0 - ESCAPE
	BR	PREFXC			;.CCPRE = 1 - PREFIX
	BR	GOBBLR			;.CCGBL = 2 - GOBBLER
	BR	ZAPPER			;.CCZAP = 3 - ZAPPER
	BR	LEVDEM			;.CCLDE = 4 - LEAVE DEFERED ECHO MODE
	BR	GRNBAL			;.CCGRN = 5 - GREEN BALL
	BR	REDBAL			;.CCRED = 6 - RED BALL
	BR	ENTDEM			;.CCEDE = 7 - ENTER DEFERED ECHO MODE

;Here for escape character if do not currently have packet

ESCAPE:	CLRB	PKTYPE-PKDATA(R1)	;CHANGE TO A DATA PACKET
	BR	DATSP2			;CONTINUE

;HERE IF CHARACTER PAIR IS SPLIT AT THE END OF A RECORD

BADCPR:	DEC	R1
	BIC	#77,R1			;Point to start of packet
	FREPKT				;Give it back
	TST	(SP)+			;FIX UP THE STACK POINTER
	MOV	#.EFCPS,R0		;ERROR = CHARACTER PAIR SPLIT
	TST	(SP)+			;Fix up the stack
	INC	DDERSZ#(R4)		;Count the error
	JMP	BADFRM#			;GO SNIP LINE
	.PAGE
;HERE FOR ENTER DEFERED ECHO MODE CHARACTER

ENTDEM:
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),4$	;If not doing protocol conversion
	BIC	#$T4LEM,SDLHT4#(SD)	;Indicate not local echo mode
	BR	LKHJPK			;Continue
.ENDC

4$:	PUSH	#1*400+.FNDEM		;GET TWO BYTES FOR PACKET
	BR	PKTTWO			;CONTINUE

;HERE FOR LEAVE DEFERED ECHO MODE CHARACTER

LEVDEM:
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),4$	;If not doing protocol conversion
	BIS	#$T4LEM,SDLHT4#(SD)	;Indicate local echo mode
	BR	LKHJPK			;Continue
.ENDC

4$:	PUSH	#0*400+.FNDEM		;GET TWO BYTES FOR PACKET
PKTTWO:	PUSH	#2			;BYTE COUNT = 2
	JMP	PKTFNX			;CONTINUE

;HERE FOR RED BALL CHARACTER

REDBAL:
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),10$	;Go on if not doing protocol conversion
	BIC	#$H1GBP,SDLHS1#(SD)	;Green ball no longer pending if it was
	MOV	#.FNRED,R0		;Echo back a red ball
	BR	PKTBCK
.ENDC

10$:	PUSH	#.FNRED			;GET SINGLE BYTE FOR PACKET
	BR	PKTO2E			;CONTINUE

;HERE FOR GREEN BALL CHARACTER

GRNBAL:
.IF NE ..TPC
	TBBE	$H1TPC,SDLHS1#(SD),GRNBA4;If not doing protocol conversion
	TBBN	$T1DEA,SDLHT1#(SD),LKHJPK;Ignore this if delete echo is active
	TST	SDPKDH#(SD)		;Any output pending now?
	BEQ	GRNBA2			;No
	BIS	#$H1GBP,SDLHS1#(SD)	;Yes-indicate green ball is pending
LKHJPK:	BIC	#77,R1			;Point to beginning of packet
	FREPKT				;Give up the packet
	JMP	DATLP1			;Continue

;Here if no output for this socket

GRNBA2:	MOV	#.FNGRN,R0		;Echo back the green ball
PKTBCK:	BIC	#77,R1			;POINT TO START OF PACKET
	CALL	BALBC2			;Send the ball back to ourselves!
	JMP	DATLP1			;Thats all
.ENDC

GRNBA4:	PUSH	#.FNGRN			;GET SINGLE BYTE FOR PACKET
PKTO2E:	JMP	PKTONE			;CONTINUE

;HERE FOR CHARACTER GOBBLER CHARACTER

GOBBLR:	BIC	#77,R1			;Point to start of packet
	MOV	#.PTEAT*400+1,PKCNT(R1)	;MAKE THIS A 1 BYTE EAT PACKET
	CLRB	PKDATA(R1)		;FUNCTION = NULL
SNDPKY:	CALL	LKHSPK			;SEND THE PACKET
	JMP	DATLP1			;CONTINUE

PREFXC:	BR	PREFXX			;HANDLE PREFIX CHAR

;HERE FOR CIRCUIT ZAPPER CHARACTER

ZAPPER:	TBBE	$H1DTP,SDLHS1#(SD),10$	;DO WE HAVE A DISCONNECT PENDING
	MOV	SDPKDH#(SD),R0		;YES - GET SAVED PACKET POINTER
	BEQ	10$			;NO SAVED PACKET?????
	CMPB	#.PTDIS,PKTYPE(R0)	;IS IT A DISCONNECT
	BNE	10$			;NO - VERY STRANGE?????
	JMP	ORGBAL			;TREAT LIKE ORANGE BALL
10$:	PUSH	R1
.IF EQ ..SAT
	MOV	#.S7OCU*10000,R0	;GET REASON FOR ZAP
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR#			;BREAK THE CIRCUIT TO TYMNET
	POP	R1
	BIC	#77,R1			;Point to start of packet
	MOV	#.ERREQ,R0		;NEXNET REASON = "REQUEST"
	CALL	SETKIL#			;SETUP THE PACKET
	BR	SNDPKY			;GO SEND IT AND CONTINUE
	.PAGE
;HERE FOR PREFIX CHARACTER

PREFXX:	DEC	(SP)			;IS THERE ANOTHER CHARACTER?
	BLT	BADCPR			;NO-BIG TROUBLE!!
	CLR	R0			;GET NEXT CHARACTER
	BISB	(R2),R0
PREFX2:	TST	PARCNT			;ROOM FOR MORE PARAMETERS IN THIS PACKET?
	BGT	PREFX4			;YES-GO ON
PREFX3:	CALL	SNDTYM			;NO-SEND THE PACKET
	ADD	#1,(SP)			;PUT BACK THE LAST 2 CHARACTERS
	DEC	R2
	JMP	DATLP2			;AND GO PROCESS THE REST FROM THE TOP

PREFX4:	ASHI	-4,R0			;GET SUBTYPE
	ASL	R0			;FOR WORD INDEXING
	PUSH	R0			;Stack the index
	MOVB	(R2)+,R0		;Get low order bits back
	ADD	(SP)+,PC		;DISPATCH ON THE SUBTYPE
	BR	ECHCON		;.PCECH =   0 - ECHO CONTROL (OLD STYLE)
	BR	INPRAT		;.PCCIR =  20 - CR delay flag and input baud
				;		  rate (old style)
	BR	CONDNX		;	=  40 - ILLEGAL
	BR	CONDNX		;	=  60 - ILLEGAL
	BR	PARAMD		;.PCPMD = 100 - PARAMETER D
	BR	PARAMC		;.PCPMC = 120 - PARAMETER C
	BR	PARAMB		;.PCPMB = 140 - PARAMETER B
	BR	PARAMA		;.PCPMA = 160 - PARAMETER A
	BR	OUTRAT		;.PCOBR = 200 - OUTPUT BAUD RATE
	BR	QRYFLD		;.PCQFL = 220 - QUERY FIELD
	BR	QRYBIT		;.PCQBT = 240 - QUERY BIT
	BR	QRYBIT		;	= 260 - QUERY BIT
	BR	SETBIT		;.PCSBT = 300 - SET BIT
	BR	SETBIT		;	= 320 - SET BIT
	BR	CONDNX		;	= 340 - ILLEGAL
	JMP	CONINF		;.PCCON = 360 - CONTROL INFORMATION

CONDNX:	JMP	CONDON

;HERE FOR SUBTYPE .PCECH = 0 - ECHO CONTROL (OLD STYLE)

ECHCON:	PUSH	#.TPECH*400		;GET TERMINAL PARAMETER FOR ECHOING
	TBBE	$ECECO,R0,2$		;SHOULD ECHOING BE ON?
	INC	(SP)			;YES
2$:	PUSH	#.TPSHT*400		;GET HORIZONTAL TAB PARAMETER
	TBBE	$ECECI,R0,4$		;SHOULD IT BE SET?
	INC	(SP)			;YES
4$:	PUSH	#.TPCRI*400		;GET CARRIAGE RETURN INSERSION PARAMETER
	TBBE	$ECELC,R0,6$		;SHOULD IT BE SET?
	BIS	#4,(SP)			;YES
6$:	PUSH	#.TPLFI*400		;GET LINE FEED INSERSION PARAMETER
	TBBE	$ECECL,R0,10$		;SHOULD IT BE SET?
	BIS	#4,(SP)			;YES
10$:	MOV	#4,R0			;GET COUNT
	BR	PARSN1			;CONTINUE

;Here for subtype .PCCIR = 020 - Set/report CR delay flag and input baud rate
;  (old style)

INPRAT:	PUSH	#.TPBLT*400		;Get first terminal parameter
	TBBN	$ECCRD,R0,2$		;Check value
	INC	(SP)			;Set it
2$:	PUSH	#.TPIRT*400		;Get second terminal parameter
	BIC	#^C$ECIBR,R0		;Just 3 bits
	MOVB	TYNRTN#(R0),(SP)	;Get Nexilis baud rate code
	MOV	#2,R0			;Get number of parameters
	BR	PARSN1			;Continue

;HERE FOR SUBTYPE .PCPMD = 100 - SET/REPORT PARAMETER D

PARAMD:	PUSH	#.TPLFD*400		;GET CORRESPONDING TERMINAL PARAMETER
	BR	PARAM2			;CONTINUE

;HERE FOR SUBTYPE .PCPMC = 120 - SET/REPORT PARAMETER C

PARAMC:	PUSH	#.TPMCD*400		;GET CORRESPONDING TERMINAL PARAMETER
PARAM2:	BIC	#^C17,R0		;VALUE IF 4 BITS
	MOVB	TYNFNF#(R0),(SP)	;APPLY "FUNCTION F"
	BR	PARSND			;Continue

;HERE FOR SUBTYPE .PCPMB = 140 - SET/REPORT PARAMETER B

PARAMB:	PUSH	#.TPFCD*400		;GET CORRESPONDING TERMINAL PARAMETER
	BR	PARAM3			;CONTINUE

;HERE FOR SUBTYPE .PCPMA = 160 - SET/REPORT PARAMETER A

PARAMA:	PUSH	#.TPVCD*400		;GET CORRESPONDING TERMINAL PARAMETER
PARAM3:	BIC	#^C17,R0		;VALUE IS 4 BITS
PARAM4:	MOVB	R0,(SP)			;STORE VALUE ON THE STACK
	BR	PARSND			;CONTINUE

;HERE FOR SUBTYPE .PCOBR = 200 - SET/REPORT OUTPUT BAUD RATE

OUTRAT:	PUSH	#.TPORT*400		;GET TERMINAL PARAMETER
	BIC	#^C17,R0		;JUST 4 BITS
	MOVB	TYNRTN#(R0),(SP)	;GET NEXILIS BAUD RATE CODE
	BR	PARSND			;Continue
	.PAGE
;HERE FOR SUBTYPE .PCQFL = 220 - QUERY FIELD

QRYFLD:	BIC	#^C17,R0		;ONLY 4 BITS
	CLR	-(SP)
	MOVB	FLDTBL(R0),1(SP)	;GET CORRESPONDING TERMINAL PARAMETER
	BR	QRYSND			;CONTINUE

;TABLE TO CONVERT TO TERMINAL PARAMETER

	PURE

FLDTBL:	.BYTE	0		;	=  0 - ILLEGAL
	.BYTE	0		;	=  1 - ILLEGAL
	.BYTE	0		;	=  2 - ILLEGAL
	.BYTE	.TPIRT		;	=  3 - INPUT BAUD RATE
	.BYTE	.TPLFD		;.QFPMD =  4 - PARAMETER D
	.BYTE	.TPMCD		;.QFPMC =  5 - PARAMETER C
	.BYTE	.TPFCD		;.QFPMB =  6 - PARAMETER B
	.BYTE	.TPVCD		;.QFPMA =  7 - PARAMETER A
	.BYTE	.TPORT		;.QFOBR = 10 - OUTPUT BAUD RATE
	.BYTE	0		;	= 11 - ILLEGAL
	.BYTE	0		;	= 12 - ILLEGAL
	.BYTE	0		;	= 13 - ILLEGAL
	.BYTE	0		;	= 14 - ILLEGAL
	.BYTE	0		;	= 15 - ILLEGAL
	.BYTE	0		;	= 16 - ILLEGAL
	.BYTE	0		;	= 17 - ILLEGAL

	CODE

;HERE FOR SUBTYPE .PCQBT = 240 - QUERY BIT

QRYBIT:	BIC	#^C36,R0		;JUST 4 BITS
	ASR	R0
	CLR	-(SP)
	MOVB	BITTPR(R0),1(SP)	;GET CORRESPONDING TERMINAL CODE
QRYSND:	BEQ	QRYBAD			;IF ILLEGAL
	BIS	#100000,(SP)		;Indicate should not change parameter
	BR	PARSND			;CONTINUE

;HERE FOR SUBTYPE .PCSBT = 300 - SET/REPORT BIT

SETBIT:	BIC	#^C37,R0		;ONLY 4 BITS
	ROR	R0
	PUSH	R0			;MAKE A HOLE ON THE STACK WITHOUT
					;  CHANGING C !!!!!
	MOVB	BITTPR(R0),1(SP)	;GET TERMINAL PARAMETER ON THE STACK
	BEQ	QRYBAD			;IF ILLEGAL
	MOVB	BITTRU(R0),(SP)		;ASSUME VALUE IS 1
	BCS	PARSND			;IF IT WAS
	MOVB	BITFLS(R0),(SP)		;NO-ITS = 0
	BR	PARSND

;HERE IF ERROR

QRYBAD:	TST	(SP)+			;FIX UP THE STACK
	JMP	CONDON			;CONTINUE

;TABLES TO CONVERT TO TERMINAL PARAMETER

	PURE

	.MACRO	TBL
	XX	.TPECH,  0,  1	;.QBECN =  0 - ECHO CONTROL
	XX	.TPEHT,  0,  1	;.QBECI =  2 - ECHO CONTROL-I
	XX	.TPLFI,  0,  4	;.QBECL =  4 - ECHO CR WITH LF
	XX	.TPCRI,  0,  4	;.QBELC =  6 - ECHO LF WITH CR::RUBOUT
	XX	.TPLCP,  0,  1	;.QBHDP = 10 - HALF DUPLEX
	XX	.TPPAR,  0,  4	;.QBPAR = 12 - PARITY
	XX	.TPIHE,  0,  1	;.QBXEN = 14 - XON/OFF ENABLE
	XX	.TPBLT,  1,  0	;.QBCRD = 16 - CR DELAY FLAG
	XX	.TPEBS,  0,  1	;.QBECH = 20 - ECHO CONTROL-H
	XX	.TPOHE,  0,  1	;.QBRXE = 22 - REVERSE X-ENABLE
	XX	.TPKAT,  0,  1	;.QBKAT = 24 - KATAKANA
	XX	.TPTOB,	 0,  1	;	= 26 - TERMINATE OUTPUT ON BREAK
	XX	.TPECE,	 0,  1	;	= 30 - ECHO ESCAPE MODE
	XX	.TPQMD,	 0,  1	;	= 32 - "Q" MODE FOR 3270 TERMINAL EMULATION
	XX			;	= 34 - ILLEGAL
	XX			;	= 36 - ILLEGAL
	.ENDM

;GENERATE TABLE OF NEXILIS TERMINAL PARAMETERS

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	PAR
.IFF
	.BYTE	0
.ENDC
	.ENDM

BITTPR:	TBL

;GENERTE TABLE OF PARAMETER VALUES USED WHEN TYMSHARE VALUE IS 0

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	FLS
.ENDC
	.ENDM

BITFLS:	TBL

;GENERATE TABLE OF PARAMETER VALUES USED WHEN TYMSHARE VALUE IS 1

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	TRU
.ENDC
	.ENDM

BITTRU:	TBL

	CODE
	.PAGE
;HERE TO SEND A "REPLY WITH" OR "SET" PARAMETER FUNCTION DEPENDING ON THE
;  DIRECTION

PARSND:	MOV	#1,R0			;GET COUNT

;Here when all ready to generate a terminal parameter function packet
;	C(R0)      = FUNCTION FOR PACKET
;	C(R0)      = NUMBER OF PARAMETER PAIRS
;	C(C(SP))   = FIRST PARAMETER PAIR
;	C(C(SP)+2) = SECOND PARAMETER PAIR
;	.....

PARSN1:	TBBN	71,R1,4$		;Is this first parameter for the packet?
	MOVB	#.FNRDP,(R1)		;YES-assume should be report parameters
	CMPB	#.IDTR#,SDSDID#(SD)	;Are we connected to a terminal?
	BNE	2$			;No
	MOVB	#.FNCDP,(R1)		;Yes-should be change parameters
2$:	INC	R1			;Bump pointer
4$:	DEC	PARCNT			;COUNT THIS PARAMETER PAIR
	MOVB	1(SP),(R1)+		;Store parameter in packet
	POPB	(R1)+			;Store value in packet
	SOB	R0,4$			;CONTINUE IF MORE
CONDON:	DEC	(SP)			;ANY MORE CHARACTERS THERE?
	BPL	2$			;YES
	JMP	DATDN2			;Continue

2$:	MOVB	(R2)+,R0		;GET NEXT CHARACTER
	CMP	#1,R0			;PREFIX CHARACTER?
	BNE	5$			;NO
	DEC	(SP)			;Is there another character?
	BPL	3$			;Yes-go on
	JMP	BADCPR			;No-this is serious!

3$:	CLR	R0			;Get next character
	BISB	(R2),R0
	CMP	R0,#360			;Another terminal parameter?
	BHIS	6$			;No
	JMP	PREFX2			;Yes-go process it

5$:	DEC	(SP)
6$:	JMP	PREFX3
	.PAGE
;HERE FOR SUBTYPE .PCCON = 360 - CONTROL INFORMATION

CONINF:	BIC	#^C17,R0		;ONLY 4 BITS
	ASL	R0			;FOR WORD INDEXING
	JMP	@CONDSP(R0)		;Dispatch on the code

;Dispatch table for control information

	PURE

CONDSP:	.WORD	HNGCHR		;.CIHNG =  0 - HANG CHARACTER
	.WORD	TRNHNG		;.CITRH =  1 - TURNAROUND HANG CHARACTER
	.WORD	ENTTRN		;.CIETR =  2 - ENTER TRANSPARANCY MODE
	.WORD	LEVTRN		;.CILTR =  3 - LEAVE TRANSPARANCY MODE
	.WORD	ENTADM		;.CIEAD =  4 - ENTER ALTERNATE DEVICE MODE
	.WORD	LEVADM		;.CILAD =  5 - LEAVE ALTERNATE DEVICE MODE
	.WORD	CONDON		;	=  6 - ILLEGAL
	.WORD	CONDON		;	=  7 - ILLEGAL
	.WORD	CONDON		;	= 10 - ILLEGAL
	.WORD	CONDON		;	= 11 - ILLEGAL
	.WORD	CONDON		;	= 12 - ILLEGAL
	.WORD	HAVBRK		;.CIBRK = 13 - BREAK DETECTED
	.WORD	GRYBAL		;.CIGRY = 14 - GRAY BALL
	.WORD	BLKBAL		;.CIBLK = 15 - BLACK BALL
	.WORD	ORGBAL		;.CIORG = 16 - ORANGE BALL
	.WORD	YELBAL		;.CIYEL = 17 - YELLOW BALL

	CODE

;HERE FOR CODE .CIHNG = 0 - HANG CHARACTER

HNGCHR:	PUSH	#.FNHNG			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CITRH = 1 - TURNAROUND HANG CHARACTER

TRNHNG:	PUSH	#.FNXHG			;GET FUNCTION
	BR	PKTONE

;HERE FOR CODE .CIETR = 2 - ENTER TRANSPARANCY MODE

ENTTRN:	PUSH	#.TPTRN*400+1		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CILTR = 3 - LEAVE TRANSPARANCY MODE

LEVTRN:	PUSH	#.TPTRN*400+0		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CIEAD = 4 - ENTER ALTERNATE DEVICE MODE

ENTADM:	PUSH	#.TPADM*400+1		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CILAD = 5 - LEAVE ALTERNATE DEVICE MODE

LEVADM:	PUSH	#.TPADM*400+0		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CIBRK = 13 - BREAK DETECTED

HAVBRK:	PUSH	#.FNBRK			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIBRY = 14 - GRAY BALL

GRYBAL:	PUSH	#.FNLSX			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIBLK = 15 - BLACK BALL

BLKBAL:	PUSH	#.FNLST			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIORG = 16 - ORANGE BALL

ORGBAL:	TBBE	$H1DTP,SDLHS1#(SD),10$	;Is a disconnect pending?
	BIC	#77,R1			;YES, POINTS TO BEGINING OF THE PACKET
	FREPKT				;free the packet allocated
	MOV	SDPKDH#(SD),R1		;Get the packet on the Dest_List
	BEQ	10$			;No packet - verry strange
	CMPB	#.PTDIS,PKTYPE(R1)	;Is it a disconnect packet?
	BNE	10$			;No-someone is very mixed up!
	MOVB	#.PTKIL,PKTYPE(R1)	;Change it to a kill packet
	MOV	#77777,SDACNT#(SD)	;Allow output now
	PU
	PUSH	R3
	CALL	LHPOKE#			;Wake up the output side 
	POP	R3
	POP	R2
	JMP	DATLP1			;Thats all

10$:	PUSH	#.FNRSP			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIYEL = 17 - YELLOW BALL

YELBAL:	PUSH	#.FNREQ			;GET FUNCTION
PKTONE:	PUSH	#1			;GET BYTE COUNT
PKTFNX:	BIC	#77,R1			;Point to beginning of packet
	MOVB	#.PTFUN,PKTYPE(R1)	;THIS IS A FUNCTION PACKET
	POPB	PKCNT(R1)		;STORE COUNT
	POP	PKDATA(R1)		;STORE DATA
	JMP	SNDPKY			;SEND IT AND CONTINUE
	.PAGE
	.SBTTL	LKHTNS - 10 times a second routine

;THIS SUBROUTINE IS CALLED 10 TIMES A SECOND (WE REALLY ONLY NEED IT 2 TIMES A
;  SECOND, BUT THE EXEC DOES NOT DO THINGS AT THAT RATE!)
;	CALL	LKHTNS
;***********************************************************************
;
;	Modified 9/3/82 to handle X.3 idle timer data forwarding
;
;***********************************************************************

	TNHSEC	LKHTNS

LKHTNS:
	DECB	HLFCNT			;TIME TO DO SOMETHING HERE?
	BGT	40$			;NO-NOTHING THIS TIME   **  Mod 9/3/82
	MOVB	#5,HLFCNT		;YES-RESET COUNTER
	MOV	#LKHDDB#,R4		;POINT TO FIRST DDB
2$:	TBBN	$D1UNV!$D1OFF,DDSTS1#(R4),35$ ;SKIP THIS DDB IF OFF
	MOV	DDLHLD#(R4),R3		;POINT TO FIRST LDB
3$:	BIS	#$L1FLW!$L1BSY,LDHST1#(R3) ;INIDCATE TIME FOR FLOW CONTROL RECORD
4$:	TST	LKH256			;TIME FOR EVERY-256-SECONDS STUFF?
	BGT	30$			;NO-GO ON
	TBBN	$L1UNV!$L1DWN,LDHST1#(R3),30$ ;IS THIS LINE UP
	MOV	#ERRTBS,R0		;YES-POINT TO ERROR TABLE
10$:	MOV	(R0)+,R2		;GET OFFSET FOR WORD WHICH CONTAINS
					; COMPARISON VALUE
	BEQ	20$			;IF FINISHED
	ADD	R3,R2			;PLUS BASE OF LDB
	PUSH	(R2)			;SAVE VALUE ON STACK
	MOV	(R0)+,R1		;GET OFFSET FOR ERROR COUNTER 
	ADD	R3,R1			;PLUS OFFSET OF LDB
	MOV	(R1),R2			;GET ERROR COUNTER VALUE
	CLR	(R1)			;CLEAR ERROR COUNTER
	MOV	(R0)+,R1		;GET MULTIPLIER
	MUL	R2,R1			;FORM ERROR COUNTER * FACTOR
	CMP	R1,(SP)			;COMPARE TO THRESHOLD
	BLOS	14$			;GO ON IF NOT OVER THE THRESHOLD
					;REPORT IT IF TOO BIG
	ASL	R2			;POSITION FOR 40 SERIES MESSAGE
	MOV	(SP),R1			;GET THE NUMBER OF PACKETS
	BIC	#77,R1			;CLEAR JUNK IN PACKET COUNT
	BEQ	14$			;SKIP MESSAGE IF LESS THAN 64 PACKETS
	PUSH	R0			;SAVE THE BASE REGISTER FOR LATER
	PUSH	#.SMMDR*10000		;SR1 (popped by sndspr)
	MOV	(R0),R0			;GET MESSAGE TEMPLATE
	BIT	#40,R0			;IS IT A 40 SERIES MESSAGE
	BNE	11$			;YES - ADD IN PACKET COUNT
	ASHI	5,R2			;POSITION OCCURANCE COUNT FOR LOOPBACK
	BR	12$			;DO LOOPBACK MESSAGE
11$:	BIS	R1,R0			;SET IN COUNT/64
12$:	PUSH	R0			;SR2
	BIC	#17,R2			;MAKE ROOM FOR LINE NUMBER
	BISB	LDHLNO#(R3),R2		;PUT IN LINE NUMBER
	PUSH	R2			;SR3
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	POP	R0			;RESTORE BASE REGISTER
14$:	CMP	(R0)+,(SP)+		;ADVANCE TO NEXT TABLE ENTRY AND CLEAN UP STACK
	BR	10$			;CONTINUE
20$:	CLR	LDPKOT#(R3)		;CLEAR THE PACKET OUT COUNTER
	CLR	LDPKIN#(R3)		;CLEAR THE PACKET IN COUNTER

30$:	MOV	LDHNXT#(R3),R3		;STEP TO NEXT LDB
	BNE	3$			;CONTINUE IF MORE
35$:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT DDB
	BNE	2$			;CONTINUE IF MORE
	DEC	LKH256			;DECREMENT 256 SECOND COUNTER
	BGE	40$			;TIME TO RESET IT?    *** Mod 9/3/82
	MOV	#512.,LKH256		;YES-DO THAT

;*******************************************************************
;
; 	Code added below to handle X.3 idle timer.
;
;*******************************************************************

40$:
	.IF	NE	..TPC
	MOV	#LKHDDB#,R4
42$:
	MOV	DDLHLD#(R4),R3		;GET THE 1ST LDB
43$:
	MOV	LDHSDB#(R3),R1		;R1 -> SDB TABLE
	MOVB	LDHCHN#(R3),R2		;GET NUMBER # OF CHANNELS
					;THIS NUMBER MUST BE <=127 ***
;	ASHI	3,R2			; # OF GROUPS * 8 = # OF CHANNELS
47$:
	MOV	(R1)+,SD		;GET NEXT SDB ADDRESS 
	BEQ	62$			;BRANCH IF CHANNEL NOT USED
	PUSH	R1			;SAVE TABLE POINTER
	MOVB	SDLHT6#(SD),R0		;GET THE RUNNING IDLE TIMER.
	BEQ	60$			;BRANCH IF IT IS NOT ACTIVE
	TBBN	$T5EDT,SDLHT5#(SD),60$	; OR IF LINE-EDITING IS ENABLED.
	DECB	R0			;OTHERWISE COUNT IT DOWN
	BEQ	50$			;BRANCH IF TIME IS UP.
	DECB	R0			;DECREMENT THE TIME AGAIN IF IT ISN'T
50$:
	MOVB	R0,SDLHT6#(SD)		;SAVE THE UPDATED IDLE TIMER
	BNE	60$
	CALL	SNDTPK			;SEND THE TERMINAL PACKET
					; IT SAVES R2 AND R3
					;AND IDLE TIMER WILL BE RESTARTED
					; WHEN DATA COME IN AGAIN
60$:
	POP	R1			;GET SDB TABLE POINTER AGAIN
62$:
	SOB	R2,47$			;LOOP IF MORE SDB TO TEST
	MOV	LDHNXT#(R3),R3		;TRY NEXT LDB
	BNE	43$			;BRANCH BACK IF THERE IS ONE
	MOV	DDLKNS#(R4),R4		;TRY NEXT DDB (E.G. TYMNET & BUBBNET)
	BNE	42$			;BRANCH IF THERE IS ONE
	
	.ENDC				;THAT'S ALL, FOLKS (ALL FOR TPC ONLY)
	
RTN009:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LKHPK3 - LKHSEC - Once a second routine

;This subroutine is called once a second (we really only need it once a
;  minute!)
;	CALL	LKHSEC

	ONCSEC	LKHSEC

LKHSEC:	TST	ZAPCNT			;IS THE ZAP COUNTER ACTIVE?
	BEQ	LKHMIN			;NO
	DEC	ZAPCNT			;YES-COUNT IT DOWN
	BGT	LKHMIN			;DID IT RUN OUT?
	CALL	ZAPBUF#			;YES-ZAP A BUFFER
	  NOP				;DON'T WORRY IF IT FAILED!
	MOV	#3,ZAPCNT		;DO THIS AGAIN IN 3 SECONDS IF CAN'T
					;  DO OUTPUT NOW!
LKHMIN:
.IF EQ ..SAT
	DECB	LKHMNC			;Time to do something here?
	BGT	RTN011			;No-nothing this time
	MOVB	#60.,LKHMNC		;Yes-reset counter
	MOV	#LKHDDB#,R4		;Point to first type H DDB
2$:	TST	DDLHUP#(R4)		;Has this link been "taken over"?
	BEQ	24$			;No-skip it
	MOV	R4,R3			;Yes-initialize index
	MOVB	DDLHNH#(R4),R2		;And count
4$:	TST	DDLHSS#(R3)		;Does this connection exist now?
	BNE	20$			;Yes-go on
	TST	DDLHDH#(R3)		;No-is this slot in use?
	BEQ	20$			;No
	PUSH	R2			;Yes
	PUSH	R3
	CALL	GRBSDB#			;Get an SDB
	BCS	17$			;Forget it if none available now!
	MAKPKT	.PLSTP#			;Get a packet
	BCC	5$			;Go on if got one
	CALL	FRESOC#			;Opps-give back the SDB
	BR	17$			;And forget it for now!

;Here with SDB and packet

5$:	BIS	#$H1SPR,SDLHS1#(SD)	;Indicate supervisory connection
	MOV	SD,DDLHSS#(R3)		;REMEMBER THIS SDB
	SUB	R4,R3			;CALCULATE INDEX
	MOV	R3,SDLHVH#(SD)		;Save it for later use
	MOV	R1,R2			;Clear the packet
	MOV	#30,R0
6$:	CLR	(R2)+
	SOB	R0,6$
	PUSH	R4			;Save registers
	PUSH	R1
	MOV	4(SP),R4		;Point to host name
	ADD	#DDLHDH#,R4
	ADD	#PKDATA+6,R1
	CALL	RD50XX#			;Put name into connect packet
	CALL	RD50XX#
	POP	R1			;Restore registers
	POP	R4
	MOVB	#200,PKDATA+27(R1)	;Indicate supervisory connection
	MOV	#.PTCON*400+37,PKCNT(R1);Store packet type and count
	CALL	TYMCON#			;Finish making the connect packet and
					;  send it
17$:	POP	R3			;Restore registers
	POP	R2
20$:	ADD	DDLHHY#(R4),R3		;Bump pointer
	SOB	R2,4$			;Continue if more to do here
24$:	MOV	DDLKNS#(R4),R4		;Step to next type H link
	BNE	2$			;Continue if more
.ENDC
RTN011:	RETURN				;Thats all
	.PAGE
	.SBTTL	SNDTYM - SEND DATA PACKET INTO NODE

;	C(R1) = CURRENT POINTER INTO PACKET BEING BUILT
;	CALL	SNDTYM
;  R2 AND R3 ARE RESPECTED

SNDTYM::MOV	R1,R0			;CALCULATE SIZE OF PACKET
	DEC	R1			;IN CASE THE PACKET IS FULL!
	BIC	#77,R1			;POINT TO START OF PACKET
	SUB	R1,R0
	SUB	#PKDATA,R0
	BNE	2$			;Go on if packet not empty
	FREPKT				;Empty-just give it back!
	RETURN				;And return

2$:	MOVB	R0,PKCNT(R1)		;Store count
LKHSPK::
.IF EQ	..SAT
	MOV	SDLHSC#(SD),R0		;GET SAVED PACKET POINTER IF ANNY
	BNE	10$			;SAVING DATA BECAUSE CIRCUIT NOT COMPLETE
.ENDC
	PUSH	R2			;SAVE VALUABLE REGISTERS
	PUSH	R3
	INCB	SDPCNT#(SD)
	CALL	SNDPKT#			;SEND THE PACKET
	POP	R3			;RESTORE REGISTERS
	POP	R2
	RETURN				;AND RETURN
.IF EQ	..SAT
5$:	MOV	(R0),R0			;TRACE DOWN LINK TO NEXT PACKET
10$:	TST	(R0)			;LINKED TO ANOTHER PACKET
	BNE	5$			;YES
	MOV	R1,(R0)			;LINK IN THIS PACKET
	RETURN
.ENDC

; SNDTPK - SEND OFF TERMINAL PACKETS FORMED BY PUTCHR

.IF NE	..TPC
SNDTPK:	PUSH	R3			;SAVE THE LDB POINTER
	PUSH	R2			;SAVE THE INPUT FRAME POINTER
	CALL	SNDTRP#			;SEND THE PACKETS ON THEIR WAY
	POP	R2
	POP	R3
	RETURN
.ENDC
	.PAGE
	.SBTTL	SNDPRJ - SEND PROJECT CODE CHARACTER TO SUPERVISOR

;SUBROUTINE TO SEND 3 PROJECT CODE CHARACTERS TO THE SUPERVISOR
;	C(R0) = 3RD CHARACTER
;	CALL	SNDPRJ

.IF EQ ..SAT

SNDPRJ:	MOV	LDHDDB#(R3),R4		;MAKE SURE R4 IS RIGHT!
	PUSH	R1			;SAVE R1
	PUSH	R0
	CALL	SPRINV#			;SEE IF WE SHOULD SEND INVOICE NUMBER
	 BR	 10$			;INVOICE NOT SET OR NO SUP
	MOV	(SP),R0			;RESTORE R0
	PUSH	#.SMACC*10000		;SR1
	PUSH	#.S7PRJ*10000		;SR2
	MOVB	SDLHPC#(SD),(SP)	;PUT 1ST CHARACTER INTO SR2
	MOVB	R0,SDLHPC#(SD)		;STORE 3RD CHARACTER FOR SR3
	PUSH	SDLHPC#(SD)		;SR3
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	CLR	SDLHPC#(SD)		;CLEAR THE CHARACTERS WE HAVE SENT
10$:	POP	R0
	POP	R1			;RESTORE R1
	RETURN				;THATS ALL

.ENDC
	.PAGE
	.SBTTL	Send ball back to TYMnet

;Subroutine to send a ball back to TYMnet
;	C(R0) = Function value for ball
;	CALL	BALBCK

BALBCK::MAKPKT	.PLSTP#			;Get a packet
	BCS	BALBC4			;Oh-well
BALBC2:	MOV	#.PTFUN*400+1,PKCNT(R1)	;Make into 1 byte function packet
	MOVB	R0,PKDATA(R1)		;Store function value
	PUSH	R2			;Save valuable AC's
	PUSH	R3
	CALL	PKTSLF#			;Send the packet back to us
	POP	R3			;Restore AC's
	POP	R2
BALBC4:	RETURN				;And return
	.PAGE
	.SBTTL	DATA

;PURE DATA

	PURE
	.EVEN

;GENERATE TABLE FOR ERROR REPORTING ROUTINE

ERRTBS:	.WORD	LDPKIN#,LDHERC#,64.,100040	;CHECKSUM ERRORS
	.WORD	LDPKIN#,LDHERB#,1,100021	;LOOPBACK ERRORS
	.WORD	LDPKIN#,LDHERS#,8.,100042	;RETRANSMISSIONS RECEIVED
	.WORD	LDPKOT#,LDHERX#,8.,100041	;RETRANSMISSIONS SENT
	.WORD	0

;IMPURE DATA

	IMPURE
	.EVEN

PARCNT:	.WORD	0		;TERMINAL PARAMETER COUNT
HLFCNT:	.WORD	0		;HALF SECOND COUNTER
LKH256:	.WORD	0		;256 SECOND COUNTER
ZAPCNT::.WORD	0		;BUFFER ZAP TIMER/COUNTER
.IF EQ ..SAT
  LKHMNC::.WORD	0		;Minute counter
.ENDC

	.END
   OŸ