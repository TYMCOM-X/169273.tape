	.TITLE	ONCROM   - ONCE-ONLY ROUTINES

	XLPAR				;DON'T LIST PARAMETER FILE


	.SBTTL	ONCROM   - ONCE-ONLY ENTRY POINTS

	.PSECT	ONCE,RW,I,LCL,REL,CON



; ENTRY POINT FOR ONCE-ONLY


ONCXDT::!

;NORMAL ENTRY POINT FOR ONCE-ONLY - GET HERE FROM THE JMP INSTR IN LOCATION 400

ONCNRM::!
ONCE0:	RESET				;RESET THE WORLD
	MOV	#STKBGN#,SP		;SET STACK POINTER
;+--KS301
	BR	SETCTY			;GO SET CONSOLE BAUD RATE
GOODM:	.ASCIZ	<CR><LF><LF>" RAM DIAGNOSTIC OK "
BM1:	.ASCIZ	<CR><LF><LF>" BAD   RAM   AT   "
BM2:	.ASCIZ	<CR><LF>" EXPECTED  VALUE= "
BM3:	.ASCIZ	<CR><LF>" ACTUAL    VALUE= "
	.EVEN
DIABA1:					;BAD MEMORY ENTRY
	MOV	R1,R2			;SAVE EXPECTED VALUE
	BR 	DIABA2			
DIABAD:					;BAD MEMORY  ENTRY
	MOV	@R0,R2			;SAVE EXPECTED VALUE
DIABA2:
	MOV	@R1,R3			;SAVE ACTUAL    VALUE
	PUSH	R1			;SAVE BAD ADDRESS
	MOV	#BM1,R1			;TYPE BAD RAM AT
	CALL	CTYSTR#			;OUTPUT A STRING
	POP	R1			;RESTORE R1
	CALL	CTYOCT#			;OUTPUT THE ADDRESS BAD
	MOV	#BM2,R1			;TYPE EXPECTED VALUE=
	CALL	CTYSTR#			;OUTPUT  A STRING
	MOV	R2,R1			;GET EXPECTED VALUE
	CALL	CTYOCT#			;OUTPUT IT
	MOV	#BM3,R1			;TYPE ACTUAL    VALUE
	CALL	CTYSTR#			;OUTPUT  A STRING
	MOV	R3,R1			;GET ACTUAL    VALUE
	CALL	CTYOCT#			;OUTPUT IT
	BR	.			;HALT THE SYSTEM
SETCTY:					;SET CONSOLE TO 300 BAUD
	MOV	#CTYXSR#+2,R0		;Console Control Register
	CLR	@R0			;Point to reg zero
	MOVB	#9.,@R0			;Point at reset register
	MOVB	#100,R2			;Put reset channel B command in reg
	BIT	#10,R0			;Is ths channel A or B
	BNE	2$			;Channel B
	ASLB	R2			;Convert to reset channel A command
2$:	MOVB	R2,@R0 			;Reset channel
	MOV	#ASGRAT,R1		;POINT TO FIRST ENTRY IN TABLE
	MOV	#SCCINI,R2		;POINT TO INITAILIZATION SEQUENCE
	PUSH	#INILEN
10$:	MOVB	(R2)+,@R0
	MOVB	(R1)+,@R0		;SET BITS IN THE HARDWARE
	DEC	(SP)
	BGT	10$			;CONTINUE IF MORE TO GO
	TST	(SP)+			;Clear the stack

; HERE FOR RAM DIAGNOSTIC
DIAMEM:					;DIAgnostic memory

; HERE CHECK ADDRESS
	MOV	#PKTBGN#,R1		;PKTBGN ALSO RAM STARTING ADDRESS
9$:
	MOV	R1,(R1)			;MOVE ADDRESS TO SELF
	TST	(R1)+			;INCREMENT BY 2
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	9$			;HI, CONTINUE
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
11$:
	CMP	R1,@R1			;MATCH?
	BNE	DIABA1			;NE, BAD MEMORY
	TST	(R1)+			;ADD 2
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	11$			;HI, CONTINUE

; HERE CHECK PATTERNS
	MOV	#DIAPAT,R0		;PATTERN START->R0
	MOV	#DIASIZ,R2		;SIZE IN BYTE
	ASR	R2			;NOW IN WORDS
7$:
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
5$:
	MOV	@R0,(R1)+		;MOVE THE PATTERN
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	5$			;HI, CONTINUE
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
3$:
	CMP	@R0,@R1			;COMPARE IT
	BNE	DIABAD			;NE, BAD MEMORY
	TST	(R1)+			;INCREMENT BY 2
	CMP	#170000,R1		;DON'T EXCEED RAM HIGH
	BHI	3$			;HI, NOT YET
	TST	(R0)+			;ELSE, NEXT PATTERN
	SOB	R2,7$			;LOOP UNTIL R2=0

; HERE WE HAVE GOOD RAM
	MOV	#GOODM,R1		;LET EVERYBODY KNOW
	CALL	CTYSTR#			;DO CONSOLE OUTPUT
;---KS301
	SETPSW	#340			;MAKE SURE NO INTERRUPTS NOW
	MOV	#170000,R0		;GET HIGH END OF MEMORY
	MOV	#PDATND#,R1		;GET START OF MEMORY TO INITIALIZE
	SUB	R1,R0			;GET LENGTH OF INITAILIZED MEMORY
	ASR	R0			;CONVERT TO WORDS
2$:	CLR	(R1)+			;CLEAR PURE DATA AREA
	SOB	R0,2$
	CMP	#50,CRSCNT#		;CHECK CRASH COUNT
	BHI	4$			;BR IF REASONABLE
	CLR	CRSCNT#			;RESET IT OTHERWISE
4$:	MOV	#167400,R0		;ROM version starts at 167400
16$:	MOV	#4.,R3			;SETUP 4 GROUPS
	MOV	#TRPER0#,SD		;POINT TO ROUTINE FOR FIRST GROUP
20$:	MOV	#16.,R1			;SET COUNT


30$:	MOV	#137,(R0)+		;Store jump instruction
	MOV	SD,(R0)+		;Store address
	SOB	R1,30$			;Continue if more to set
40$:	ADD	#TRPERX#,SD		;POINT TO ROUTINE FOR NEXT GROUP
	SOB	R3,20$			;CONTINUE IF MORE TO DO

;FOLLOWING ROUTINE SETS UP ALL INTERRUPT VECTORS.  NO VECTORS ARE SET AT LOAD
;  TIME SO AS NOT TO MIX UP THE MONITOR!  INSTEAD A TABLE, "VECTBL" IS BUILT
;  WHICH SPECIFIES EACH INTERRUPT VECTOR.  THIS TABLE CONTAINS WORD TRIPLETS
;  WITH THE FIRST WORD CONTAINING THE LOCATION OF THE VECTOR AND THE SECOND
;  THE ADDRESS OF THE INTERRUPT ROUTINE FOR THE VECTOR.  THE THIRD WORD
;  CONTAINS THE PRIORITY LEVEL FOR THE INTERRUPT.

44$:	MOV	#VECTBL#,R1		;SET POINTER
	MOV	#167402,R2		;Yes-get offset for "soft" vectors
SETVEC:	MOV	(R1)+,R0		;GET LOCATION OF VECTOR
	ADD	R2,R0			;Add in the offset
	MOV	(R1)+,(R0)+		;STORE ADDRESS OF INTERRUPT ROUTINE
	MOV	(R1)+,R3		;Get interrupt level
2$:	CMP	#VECEND#,R1		;FINISHED?
	BNE	SETVEC			;NO-CONTINUE
					;YES
	.PAGE
	.SBTTL	ONCROM   - DETERMINE MEMORY SIZE

;THE FOLLOWING CODE DETERMINES THE AMOUNT OF MEMORY WE HAVE BY ATTEMPTING TO
;  READ THE WORD JUST BEYOND EACH 4K WORD BOUNDRY

MEMLOP:
	MOV	#PKTBGN#-10000,R3	;INITIALIZE POINTER
MEMLP1:	ADD	#10000,R3		;BUMP POINTER TO NEXT 2K BLOCK
	TST	(R3)			;TRY TO READ MEMORY
	NXMJMP	MEMTOP			;WHERE TO GO IF NO MORE MEMORY
	CMP	#160000,R3		;CHECK FOR END
	BHI	MEMLP1			;NOT YET

;GET HERE WHEN WE HAVE FOUND THE TOP OF MEMORY

MEMTOP:	SUB	#PKTBGN#,R3		;GET ACTUAL AMOUNT OF RAM SPACE
	ADD	#PDATA#-160100,R3	;ADD IN FALCON LOCAL MEMORY PACKET SPACE
	CLR	R2			;GET NUMBER OF PACKETS
	DIV	#PKTWDS*2,R2
	MOV	R2,NUMPKT#		;STORE IT FOR LATER
	.PAGE
; SCATTERLOAD INITIALIZATION INFO IN MEMORY
	
	MOV	#INIDAT#,R0		;Point to initilization data
10$:	CMP	R0,#INIDND#		;At end yet?
	BHIS	20$			;Yes
	MOV	(R0)+,@(R0)+		;Store data in address
	BR	10$

; DO BYTE DATA NEXT
20$:	MOV	#INIBYT#,R0
30$:	CMP	R0,#INIBND#		;Are we at the end yet
	BHIS	40$			;Yes
	MOV	(R0)+,R1		;Get the data
	MOVB	R1,@(R0)+		;Move data byte to destination
	BR	30$
40$:

;	here for possible timer setup

	CMP	#174000,#CTYRBF#	;Is this a FALCON board
	BNE	STRT4			;Yes, don't initialize the CIO
	TST	177014			;Read the csr to make sure we are
					;in reset state or state zero
	CLR	177016			;Now we are in state 0 or 1
	TST	177014			;now we are for sure in state 0
	MOV	#CIOINI,R0		;Point to initilization block
	MOV	#CIOLEN,R1
50$:	MOVB	(R0)+,177016		;Send bytes of control info to CIO
	SOB	R1,50$
	MOV	#LKIDDB#,R0		;Point to link I DDB
;	CMP	DDLINN#(R0),#2351	;Is the right thing?
;	BNE	STRT3			;No
	CLR	R1
	BISB	177004,R1		;Get port B
	ASRB	R1			;Shift off PB0
	SWAB	R1			;Put bytes in correct halves
	BISB	177010,R1		;Get port A data
	BIT	#10000,R1		;Was the high bit on
	BEQ	54$			;No
	BIS	#4000,R1		;Yes, put in proper place
54$:	BIC	#170000,R1		;Clear out any junk
	BEQ	STRT3			;Skip if nothing in switches
	CMP	R1,#2010		;See if legal node number
	BLO	STRT3			;Not legal if less than 2010
	MOV	R1,DDLINN#(R0)		;Yes, save node number
	ADD	#528.-2010,R1		;Calculate kernel host
	BIS	#^H8000,R1		;Set escape bit
	SWAB	R1			;Put in sup order
	MOV	R1,KERHST#		;Tuck away
STRT3:	MOV	DDLINN#(R0),R1		;Get the node number
	MOV	#4,R0			;Form count of digits
	MOV	#THSNOD#,R2		;Point to result array
	ASHI	4,R1			;Shift off junk
60$:	CLR	R3			;Clear result reg
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	ADD	#'0,R3			;Convert  to ASCII
	MOVB	R3,(R2)+		;Deposit into name
	SOB	R0,60$			;Continue

;HERE TO START NODE


STRT4:	CLR	CKSFLG#			;CLEAR CHECKSUM FLAG
	JMP	START#			;GO START THE NODE

	CODE
	VECTOR	110,CLKINT,7		;Set up vector for possible clock interrupt

CLKINT:	TST	177014			;MAKE SURE WE ARE OK
	MOVB	#14,177016		;point to register 14 in CIO
	MOVB	#46,177016		;Reset interrupt under service
	JMP	@100			;Continue porcessing interrupt

CODTOP::!				;HIGHEST LOCATION WHICH EVER CONTAINS
					;  CODE (USED IN ERROR FOR NXM CHECK)
	PURE
;	THIS IS THE CIO PROGRAM.  IT USERS COUNTER 3 AND PROGRAMS IT WITH A
;	COUNT OF 20480. (1.2288MHZ/60HZ).  THE EXTERNAL COUNT ENABLE IS 0 AND
;	THEREFORE THE INPUT IS ONE HALF OF THE CIO PCLK INPUT.
;	COUNTER 1 IS PROGRAMMED TO PROVIDE A "75 BAUD" (ACTUALLY 64*75) CLOCK
;	FOR 1200/75 SPLIT BAUD.

CIOINI:	.BYTE	0,1,0			;RESET CHIP AND RETURN TO STATE ZERO
	.BYTE	32,40.,33,0		;SET UP THE DOWN COUNTERS FOR CT3
	.BYTE	26,0,27,128.		;CT1
	.BYTE	36,302			;SET CONTINOUS TIMER MODE AND SQUARE
	.BYTE	34,302			;OUTPUT FOR CT3 AND CT1
	.BYTE	4,110			;SET INTERRUPT VECTOR TO 110
	.BYTE	43,377			;SET PORT A AS INPUT PORT
	.BYTE	53,356			;SET UP PORT B'S INPUT BITS
	.BYTE	6,16			;SET UP PORT C'S INPUT BITS
	.BYTE	1,327			;ENABLE COUNTER 1,2,3 AND PORTS
	.BYTE	14,306			;SET INTERRUPT ENABLE AND TURN ON CT3
	.BYTE	12,6			;TURN ON CT1
	.BYTE	0,200			;MASTER INTERRUPT ENABLE
CIOLEN=	.-CIOINI
;+--KS301

	PURE
SCCINI:	.BYTE	24,3,25,11.,12.,13.,5,14.
INILEN=	.-SCCINI
	.EVEN
ASGRAT:	.BYTE	304,300,342,120
	.WORD	<19200./300.>-2		; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	352,203			;enable tx, set clock, baud source
	.EVEN
DIAPAT:					;RAM DIAGNOSTIC PATTERNS
	.BYTE	360,017
	.BYTE	155,222
	.BYTE	044,333
	.BYTE	125,377
	.BYTE	000,232
	.BYTE	000,000
DIASIZ=.-DIAPAT
;---KS301
	.EVEN
	.ASECT
.=	0
	RSTOP	BRZ

ADDR=	167404
COND=	1
	.REPT	4
	.WORD	ADDR
	.WORD	340+COND
ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.ENDR

	.WORD	ONCXDT			;Power down/up vector
	.WORD	340

ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.REPT	73

	.WORD	ADDR
	.WORD	340+COND
ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.ENDR
COPNOT:	.ASCII	/COPYRIGHT 1983, TYMSHARE INC., CUPERTINO CA./
.=	500	;PUT A NOTICE IN EACH ROM
	.ASCII	/CCOOPPYYRRIIGGHHTT  11998833,,  /
	.ASCII	/TTYYMMSSHHAARREE  IINNCC..,,  CCUUPPEERRTTIINNOO  CCAA../

	.END
   