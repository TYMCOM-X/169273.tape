	.TITLE	LKHPK2 - LINK H - TYMSHARE T.201 PROTOCOL - PACKET LEVEL ROUTINES
	.SBTTL	LKHPK2 - Nexilis/JRG

	XLPAR
.HLIST=!1


	CODE

	.SBTTL	EMPFRM - Empty a frame - Entry from line level routine

;Subroutine to empty a T.201 frame.  This subroutine is called by the line
;  level module whenever a frame is received.
;	C(R0) = Number of data bytes in frame
;	C(R2) = Address of frame buffer
;	C(R3) = Address of LDB for line
;	CALL	EMPFRM
;	  error return, frame not completely processed
;	normal return, frame completely processed and ready to be "ACK'ed"

EMPFRM::MOV	LDHDDB#(R3),R4		;setup R4 as the DDB pointer
	MOV	LDHSPC#(R3),R1		;Get recovery address
	BEQ	EMPFR1			;Go on if recovery not needed now
	CLR	LDHSPC#(R3)		;Clear the address
	PUSH	LDHSFC#(R3)		;Put frame byte count on the stack
	PUSH	LDHSRC#(R3)		;And the record byte count
	MOV	LDHSSD#(R3),SD		;RESTORE SD
	MOV	LDHSR2#(R3),R0		;Get low order 6 bits for R2
	BIC	#^C77,R0
	BIC	#77,R2
	BIS	R0,R2			;Point to right place in the frame
	MOV	LDHSR0#(R3),R0		;Restore R0
	PUSH	R1			;Put return address for LKHNPK on the
					;  stack and fall into LKHNPK

	.SBTTL	LKHNPK - Get a packet

;Subroutine to get a packet - does not return until one if available!
;  **** WARNING ****  This subroutine must be called at the proper stack level!
;	C(C(SP)+4) = Return address for EMPFRM call
;	C(C(SP)+2) = Frame byte count
;	C(C(SP)+0) = Record byte count
;	CALL	LKHNPK
;	C(R1) = Address of packet

LKHNPK::MAKPKT	.PLSTP#			;Get a packet
	BCC	RTN001			;Just return if got one

	CALL	ZAPBUF#			; ZAP A BUFFER IF NOT
	  BR	1$			; COULDN'T ZAP
	BR	LKHNPK			; TRY AGAIN IF BUFFER ZAPPED

;**************************************************************************

1$:	PUSH	R0
	MOV	#40,R0			;COPY THE FRAME WE ARE PROCESSING
	MOV	#FRMXXX,R1
	PUSH	R2
	BIC	#77,R2
2$:	MOV	(R2)+,(R1)+
	SOB	R0,2$
	POP	R2
	POP	R0

	IMPURE
FRMXXX::.BLKW	40
	CODE

;**************************************************************************


;If no packets are available, the record and frame byte counts are saved in
;  the LDB and the error return from EMPFRM is given

	MOVB	#10.,ZAPCNT#		;NONE AVAILABLE-START ZAP COUNTER
	POP	LDHSPC#(R3)		;Save return address
	POP	LDHSRC#(R3)		;Save record byte count
	POP	LDHSFC#(R3)		;Save frame byte count
	MOV	SD,LDHSSD#(R3)		;SAVE SD
	MOV	R2,LDHSR2#(R3)		;Save R2
	MOV	R0,LDHSR0#(R3)		;And save R0
RTN001:	RETURN				;And give error return from EMPFRM
	.PAGE
	.SBTTL	EMPFRM - Empty a frame - dispatch on record type

;Here when really ready to process the frame

EMPFR1:	PUSH	R0			;PUT COUNT ON THE STACK
LKHNXT::SUB	#2,(SP)			;ANY MORE THERE?
	BGT	10$			;YES
	TST	(SP)+			;NO-FIX UP THE STACK
	ADD	#2,(SP)			;GIVE GOOD RETURN
	CLRB	ZAPCNT#			;CLEAR THE ZAP COUNTER
	MOV	DDLHUP#(R4),R0		;GET UPSTREAM LINE LDB ADDRESS
	BEQ	4$			;IF NONE
	TST	LDHSLH#(R0)		;ANY SUPERVISOR MESSAGES QUEUED?
	BEQ	4$			;NO
	TBBN	$L1BSY,LDHST1#(R0),4$	;YES-IS THE LINE BUSY NOW?
	PUSH	R3			;NO-START IT UP
	PUSH	R4			;LDHSTX@ DOES NOT RESPECT R4
	MOV	R0,R3
	CALL	@LDHSTX#(R3)
	POP	R4
	POP	R3
4$:	RETURN				;AND RETURN

;HERE IF FRAME NOT EMPTY YET

10$:	CLR	R0			;PREPARE R0 TO RECEIVE BYTE COUNT
	BISB	(R2)+,R0		;GET BYTE COUNT
	CLR	SD			;PREPARE SD TO RECEIVE CHANNEL NUMBER
	BISB	(R2)+,SD		;GET CHANNEL NUMBER
	SUB	R0,(SP)			;ACCOUNT FOR THE DATA
	BLT	12$			;MAKE SURE COUNTS ARE OK
	DEC	SD			;CHECK FOR SPECIAL CHANNEL
	BLT	SPRREC			;IF SUPERVISOR RECORD (CHANNEL 0)
	BEQ	FLWREC			;IF FLOW CONTROL RECORD (CHANNEL 1)
	JMP	LKHDAT#			;IF DATA RECORD

12$:	MOV	#.EFRL0,R0		;REASON = RECORD LENGTH = 0 (THIS IS
					;  NOT REALLY RIGHT HERE BUT ITS THE
					;  CLOSEST WE CAN GET!
	JMP	BADFR0			;GO FAIL
	.PAGE
	.SBTTL	EMPFRM - Empty a frame - Flow control record

;HERE WITH FLOW CONTROL RECORD

FLWREC:	CMPB	LDHGRP#(R3),R0		;IS THIS RECORD THE RIGHT LENGTH?
	BEQ	1$			;YES-GO ON
	MOV	#.EFILF,R0		;REASON = ILLEGAL FLOW CONTROL LENGTH
	JMP	BADFR0			;GO SNIP THE LINE

1$:	CLR	REQCNT			;CLEAR COUNTER
	PUSH	R4			;Respect R4
	PUSH	R0			;PUT COUNT ON THE STACK
	MOV	LDHSDB#(R3),R4		;POINT TO LIST OF SDB'S
2$:	MOVB	(R2)+,R0		;GET A BYTE OF BITS
	COM	R0			;COMPLEMENT IT SO FUNNY TEST BELOW WILL
					;  WORK!
	PUSH	#8.			;STACK BIT COUNT
4$:	ROLB	R0			;TEST THE NEXT BIT
	MOV	(R4)+,SD		;GET SDB THAT CORRESPONDS TO THE BIT
	BLOS	10$			;GO ON IF NONE OR IF BIT NOT SET (NOTE:
					;  MOV DOES NOT CHANGE C WHICH ROLB SET
					;  ACCORDING TO THE BIT WE ARE TESTING;
					;  THIS BRANCHES IF C IS SET OR IF Z IS
					;  SET!)
	PUSH	R0			;BIT WAS SET-FREE UP AN AC
	MOVB	SDLHSP#(SD),R0		;GET LINE SPEED
	MOV	SPDTBL(R0),SDACNT#(SD)	;RESET SEND-AHEAD COUNT
	TST	SDPKDH#(SD)		;DOES IT HAVE ANYTHING TO SEND NOW?
	BEQ	9$			;NO
	CMP	#-1,SDLKLK#(SD)		;YES-ALREADY IN THE LIST?
	BNE	9$			;YES-NOTHING MORE NEEDED HERE
	MOV	LDHXLT#(R3),R0		;NO-PUT THIS SDB ON THE SEND LIST
	BEQ	5$
	MOV	SD,SDLKLK#(R0)
	BR	6$

5$:	MOV	SD,LDHXLH#(R3)
6$:	MOV	SD,LDHXLT#(R3)
	CLR	SDLKLK#(SD)
	INC	REQCNT			;INDICATE SOMETHING TO DO FOR THIS LINE
9$:	POP	R0			;RESTORE R0
10$:	DEC	(SP)			;FINISHED WITH THIS WORD?
	BGT	4$			;NO-CONTINUE
	TST	(SP)+			;YES-FIX UP THE STACK
	DEC	(SP)			;MORE WORDS TO PROCESS?
	BGT	2$			;YES-CONTINUE
	TST	(SP)+			;NO-FIX UP THE STACK
	TST	REQCNT			;DID WE START UP ANYONE?
	BEQ	20$			;NO
	PUSH	R2			;YES-POKE THE LINE IF ITS IDLE NOW
	CALL	LKHBGN#
	POP	R2
20$:	POP	R4			;RESTORE R4
	BR	LKHNXT			;CONTINUE WITH THE FRAME

;LINE SPEED TABLE

	PURE

	.EVEN
SPDTBL:	.WORD	16.		; 0 - 32 CHARACTERS PER SECOND
	.WORD	80.		; 1 - 160 CHARACTERS PER SECOND
	.WORD	256.		; 2 - 512 CHARACTERS PER SECOND
	.WORD	1024.		; 3 - 2048 CHARACTERS PER SECOND

	CODE
	.PAGE
	.SBTTL	EMPFRM - EMPTY A FRAME - SUPERVISOR RECORD

;HERE WITH SUPERVISOR RECORD

SPRREC:	PUSH	R0			;PUT BYTE COUNT ON THE STACK
SPRRE1:	TST	LKHPPK			;Do we have a reserve packet now?
	BNE	6$			;Yes-go on
	CALL	LKHNPK			;No-get one now
	MOV	R1,LKHPPK		;Store address of reserve packet
6$:	SPRWRD	R0			;Get SR1
	TST	R0			;CHECK DIRECTION
	BMI	MSGUP			;IF UPSTREAM MESSAGE
	MOV	R0,R1			;DOWNSTREAM-SEPERATE NODE NUMBER
	BIC	#^C7777,R1
	CMP	DDLHNN#(R4),R1		;THIS NODE?
	BNE	MSGDWN			;NO-GO SEND IT DOWNSTREAM
	ASHI	-12.,R0			;GET MESSAGE TYPE
	ASL	R0			;AS WORD INDEX
	JMP	@SPRDSP(R0)		;DISPATCH ON THE MESSAGE TYPE

;DISPATCH TABLE FOR SUPERVISOR MESSAGE TYPES

	PURE
	.EVEN

SPRDSP:	.WORD	TAKOVR		;.SMTKO = 0 - TAKE OVER
	.WORD	PUTCBF		;.SMPCB = 1 - PUT CHARACTER INTO BUFFER
	.WORD	CHGPMT		;.SMCPT = 2 - CHANGE PERMUTER TABLE ENTRY
	.WORD	CHGMEM		;.SMCMM = 3 - CHANGE MEMORY OR MISCELLANEOUS
	.WORD	REDMEM		;.SMRDM = 4 - READ MEMORY
.IF EQ ..SAT
	.WORD	LGISTS		;.SMLGI = 5 - LOGIN STATUS
	.WORD	SPRTOD		;.SMTOD = 6 - SPUERVISOR TIME-OF-DAY
	.WORD	INVOIC		;.SMINV = 7 - INVOICE NUMBER
.IFF
	.WORD	BADSPR
	.WORD	BADSPR
	.WORD	BADSPR
.ENDC

	CODE
	.PAGE
;HERE TO SEND SUPERVISOR MESSAGE UP-STREAM

MSGUP:	SPRWRD	R1			;SR2
	TST	DDLHUP#(R4)		;CHECK FOR NO UPSTREAM LINE
	BEQ	10$			;NO UPSTREAM LINE - SEND UNTAKER BACK
	PUSH	R0			;SR1
	PUSH	R1
	SPRWRD	R0			;SR3
	PUSH	R0
	CALL	SNDUP			;SEND TO SUPERVISOR
	JMP	NXTSPR			;THATS ALL
10$:	SPRWRD	R1			;THROW AWAY SR3
	BIC	#170000,R0		;TURN R0 INTO AN UNTAKER
	PUSH	R0			;SR0
	PUSH	#22277
	PUSH	DDLHNN#(R4)		;PUSH OUR NODE NUMBER ONTO THE STACK
	CALL	SNDLIN			;RETURN TO SENDER...
	JMP	NXTSPR			;GO GET NEXT ONE

;HERE TO SEND SUPERVISOR MESSAGE DOWN-STREAM

MSGDWN:	PUSH	R0			;SR1
	SPRWRD	R0			;SR2
	PUSH	R0
	SPRWRD	R0			;SR3
	PUSH	R0
	CALL	SNDDWN			;SEND DOWN-STREAM
	JMP	NXTSPR			;THATS ALL
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMTKO = 0 - TAKE OVER OR UNTAKER

;	TAKE OVER FORMAT
;	SR2 = (10) 0555 (6) SUPERVISOR NUMBER
;	SR3 = (16) SUPERVISOR TYPE
;		0 - DOES NOT ACCEPT TYPE 4 OR 6 COMPRESSED MESSAGES
;		1 - ACCEPTS TYPE 4 AND 6 MESSAGES
;
;	UNTAKER FORMAT
;	SR2 = (16) 022277
;	SR3 = (16) NNNNNN		;NUMBER OF NODE THAT DETECTED THE ERROR

TAKOVR:	SPRWRD	SD			;GET SR2
	CMP	#22277,SD		;CHECK FOR UNTAKER MESSAGE
	BEQ	UNTAKR			;GO DO IT
	MOV	SD,R0
	BIC	#^C177700,R0
	CMP	#55500,R0
	BNE	TAKOV9			;IGNORE MESSAGE IF NOT RIGHT!
	MOV	SD,R0			;GET SUPERVISOR NUMBER
	BIC	#^C77,R0
;	CMPB	DDLHSN#(R4),R0		;SAME AS CURRENT SUPERVISOR?
;	BNE	2$			;NO-GO ON
;	CMP	DDLHUP#(R4),R3		;YES-OVER SAME LINE AS BEFORE?
;	BNE	TAKOV9			;NO-IGNORE IT!!!
2$:	MOVB	R0,DDLHSN#(R4)		;YES-STORE SUPERVISOR NUMBER
	MOVB	1(R2),DDLHTY#(R4)	;SAVE SUPERVISOR TYPE
.IF EQ	..SAT
	CLR	DDLHVH#(R4)		;MAKE SURE ACCOUNTING DOESN'T GET IT
	CLR	DDLHVL#(R4)
.ENDC
	PUSH	R3			;SAVE LDB ADDRESS FOR THIS LINE
	PUSH	R1			;SAVE R1 WHICH CONTAINS NODE NUMBER FOR SR1
	PUSH	SD			;SR2
	PUSH	R2			;SAVE R2
	CALL	CLRSUP			;CLEAR ALL SUPERVISOR DIALOGS
	MOV	(SP),R2			;RESTORE R2
	CLR	(SP)			;SR3 = 0
	CALL	SNDUP			;SEND MESSAGE TO CURRENT SUPERVISOR
	MOV	(SP),R3			;RESTORE ADDRESS OF OUR LDB
	MOV	R3,DDLHUP#(R4)		;SET UPSTREAM SWITCH TO NEW SUPERVISOR
	CLR	(SP)			;SEND MESSAGE TYPE 0 TO NEW SUPERVISOR
	PUSH	DDLHTR#(R4)		;GET SR2 WORD
;	BIS	#20000,(SP)		;SET SMART NODE BIT
	PUSH	VERLOC#			;SR3 = SOFTWARE VERSION
	CALL	SNDSPR			;SEND TO NEW SUPERVISOR
.IF EQ ..SAT
	MOVB	#10.,LKHMNC#		;TRY TO MAKE SUPERVISORY CONNECTIONS
					;  IN 10 SECONDS

; PERFORM BUFFER TABLE CONSISTANCY CHECK

	MOV	DDLHBF#(R4),R0		;POINT TO BEGINING OF LIST
	MOV	#377,R1			;GET COUNT OF PORTS
10$:	CLR	SD
	BISB	(R0)+,SD		;GET SOCKET NUMBER FOR PORT
	BEQ	20$			;NONE ASSIGNED
	CMPB	SD,DDSOC#(R4)		;IS IT IN RANGE
	BHI	18$			;NO, CLEAR THE CELL
	ASL	SD			;PREPARE FOR WORD INDEXING
	ADD	DDSX#(R4),SD		;POINT TO SDB TABLE +2
	MOV	-(SD),SD		;GET SDB
	TSTB	SDSTS1#(SD)		;IS THIS SOCKET ACTIVE
	BEQ	18$			;NO, CLEAR THE POINTER
	PUSHB	SDLHBF#(SD)		;SAVE PORT NUMBER IN SDB
	MOV	R0,SD			;COPY PORT INDEX POINTER
	SUB	DDLHBF#(R4),SD		;GET PORT NUMBER +1
	DEC	SD
	CMPB	SD,(SP)+		;CHECK FOR CORRESPONDING PORT NUMBER
	BEQ	20$			;MATCH
18$:	CLRB	-1(R0)			;CLEAR BAD PORT NUMBER
20$:	SOB	R1,10$			;CONTINUE
.ENDC

TAKOV9:	JMP	IGNSP3			;THATS ALL FOR THIS ONE
	.PAGE

;	HANDLE UNTAKER MESSAGE

UNTAKR:	CMP	DDLHUP#(R4),R3		;IS IT OUT UPSTREAM LINE?
	BNE	TAKOV9			;NO, WE HAVE TO IGNORE IT
	PUSH	R3			;SAVE LDB BECAUSE CLRSUP SMASHES IT
	PUSH	R2
	CALL	CLRSUP			;CLEAR ALL SUPERVISORY CONNECTIONS
	POP	R2
	POP	R3
	CLRB	DDLHSN#(R4)		;CLEAR OUR SUPERVISOR
	CLR	DDLHUP#(R4)		;CLEAR UP CONNECTION
	BR	TAKOV9			;GO TO NEXT MESSAGE


;	CLEAR ALL SUPERVISORY CONNECTIONS

CLRSUP:	PUSH	R3			;SAVE CURRENT LDB
	MOV	DDLHLD#(R4),R3		;SCAN ALL LDB'S
4$:	CALL	CLRSPR			;AND CLEAR THEIR SUPERVISOR OUTPUT LISTS
	CMP	DDLHUP#(R4),R3		;IS THIS THE CURRENT SUP LDB
	BEQ	6$			;YES - SKIP THIS LDB
	CMP	R3,(SP)			;IS THIS THE SOURCE OF THE CLEARING
	BEQ	6$			;DON'T TELL HIM SOMETHING HE ALREADYS KNOWS
	PUSH	LDHNBR#(R3)		;SEND TO NEIGHBOR
	PUSH	#22277
	PUSH	DDLHNN#(R4)		;PUSH OUR NODE NUMBER ONTO THE STACK
	CALL	SNDLIN			;SEND A MESSAGE DOWN THE LINE
	MOVB	#<TIME.D*3>,LDHTDT#(R3)	;START TIMER TO SEND LINE DOWN MESSAGE
6$:	MOV	LDHNXT#(R3),R3		;STEP TO NEXT
	BNE	4$
	POP	R3			;GET BACK LDB
;	CJMP	CLRNEW			;DISCONNECT ALL SDB'S WHICH ARE WAITING
					;  FOR THE SUPERVISOR

;SUBROUTINE TO DISCONNECT ALL SOCKETS WAITING FOR SUPERVISOR RESPONSE
;	AND CIRCUIT BUILDING IN PROGRESS
;	C(R4) = ADDRESS OF DDB
;	CALL	CLRNEW

CLRNEW:	MOV	DDSX#(R4),R0		;POINT TO SX TABLE
	CLR	R2			;GET NUMBER OF SOCKETS
	BISB	DDSOC#(R4),R2
2$:	MOV	(R0)+,SD		;GET NEXT SDB
	TSTB	SDSTS1#(SD)		;CONNECTED?
.IF NE	..SAT
	BEQ	10$			;NO
.IFF
	BNE	4$			;YES, CONTINUE CHECKOUT
	CLR	R1
	BISB	SDLHBF#(SD),R1		;GIVE UP THIS BUFFER
	CMP	#377,R1			;IF WE HAVE ONE
	BEQ	7$			;UNUSED - SO DON'T FOUL THINGS UP
	MOVB	#377,SDLHBF#(SD)	;CLEAR BUFFER NUMBER IN SDB
	ADD	DDLHBF#(R4),R1		;POINT TO BUFFER TABLE
	CMPB	SDSOC#(SD),(R1)		;IS IT STILL POINTING TO US
	BNE	7$			;NO - SO DON`T FOUL THINGS UP  MORE
	CLRB	(R1)			;FREE UP THIS BUFFER
7$:	CLR	SDLHLD#(SD)		;Clear linked ldb in case we got that far
	CALL	CLRSDV#			;CLEAR ANY POSSIBLE DES LIST
	CALL	FRESOC#
	MOVB	SDLHCN#(SD),R1		;GET POSSIBLE CHANNEL NUMBER
	BEQ	10$			;FORGET IT IF NONE
	ASL	R1			;CONVERT TO OFFSET
	ADD	LDHSDB#(R3),R1		;CALC ADDRESS OF SDB FOR CHANNEL
	CMP	(R1),SD			;DOES IT POINT TO US?
	BNE	10$			;NO
	CLR	(R1)			;YES, CLEAR IT OUT
	BR	10$
.ENDC
4$:	TST	SDLHLD#(SD)		;YES-DOES IT HAVE A CHANNEL?
	BNE	10$			;YES, IT MUST BE A FULL CONNECTION
.IF EQ ..SAT
	TBBN	$H1SPR,SDLHS1#(SD),10$	;IS THIS A SUPERVISORY SDB?
.ENDC
	PUSH	R0
	PUSH	R2
	CLR	SDLHS1#(SD)
	MOV	#.S7OCU*10000!.ERSPR,R0	;REASON = SUPERVISOR ERROR
	CALL	KILSUB			;Kill the connection
	POP	R2			;RESTORE R2
	POP	R0			;RESTORE R0
10$:	SOB	R2,2$			;CONTINUE IF MORE TO DO
.IF EQ ..SAT
	MOV	#DDLHXS,R0		;POINT TO LIST OF AUX-CIRCUIT SDB'S
	ADD	R4,R0
	MOV	#4,R1			;GET NUMBER OF PSEUDO PORTS TO SCAN
12$:	MOV	(R0),SD			;GET SDB ADDRESS
	BEQ	14$			;IF NONE
	PUSH	R0			;SAVE REGISTERS
	PUSH	R1
	MOV	#LKHATO,R1		;KILL TIMER
	CALL	TIMKIL#
	POP	R1			;RESTORE REGISTERS
	POP	R0
14$:	CLR	(R0)+			;CLEAR POINTER
	SOB	R1,12$			;CONTINUE IF MORE TO CHECK
.ENDC
	RETURN				;RETURN WHEN FINISHED
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMPCB = 1 - PUT CHARACTER INTO BUFFER
;	SR2 = (16) BUFFER NUMBER
;	SR3 = (8) FIRST CHARACTER (8) SECOND CHARACTER

PUTCBF:	SPRWRD	SD			;GET BUFFER NUMBER
	CALL	GETSDB			;GET SDB ADDRESS
	BCC	2$			;OK-GO ON
1$:	JMP	BADSP3			;IF CAN'T DO IT, LET EVERYONE KNOW

2$:
.IF EQ ..SAT				;ONLY NEED THIS IF HAVE BASE SUPPORT
	TBBE	$H1XD1!$H1XD2,SDLHS1#(SD),14$;GO ON IF NOT BUILDING CIRCUIT
	TBBN	$H1XD2,SDLHS1#(SD),10$	;GO ON IF EXPECTING 2ND BYTE PAIR
	CALL	LKHRPK			;FIRST BYTE PAIR-GET A PACKET
	PUSH	R3			;FREE UP A REGISTER
	MOV	R1,SDLHSC#(SD)		;SAVE ADDRESS OF PACKET
	MOV	R1,R3			;CLEAR THE PACKET
	MOV	#37,R0
3$:	CLR	(R3)+
	SOB	R0,3$
	MOV	#.PTCON*400+37,PKCNT(R1);SET PACKET TYPE AND BYTE COUNT
	MOVB	(R2)+,R0		;GET TYMNET TERMINAL TYPE
	BIT	#40,R0			;CHECK FOR HALF DUPLEX
	BEQ	35$			;NOT HALF DUPLEX
	MOVB	#2,PKDATA+35(R1)	;SET HALF DUPLEX BIT
35$:	BIC	#^C37,R0		;ONLY 5 BITS
	CMP	R0,#MAXTYT		;VALID TYPE?
	BLO	4$			;YES
	MOV	#12.,R0			;NO - PICK A SAFE TYPE
4$:	TST	R0			;REALLY A TERMINAL?
	BEQ	6$			;NO
	MOVB	#.IDTR#,PKDATA+14(R1)	;YES
6$:	MOVB	TYNTYR(R0),PKDATA+34(R1);STORE TERMINAL BAUD RATE
.IF EQ ..TPC
	MOVB	TYNTYT(R0),PKDATA+33(R1);STORE TERMINAL TYPE
.IFF
	MOVB	TYNTYT(R0),R0		;Get terminal type
	MOVB	R0,PKDATA+33(R1)	;Store it in the connect packet
	ASL	R0			;Get terminal type bits in case we need
	MOV	TTPBTS#(R0),SDLHT4#(SD)	;  them later!
	CLR	SDLHT1#(SD)		;Reset all SDLHT1 bit flags.
	MOVB	TTPWID#(R0),SDLHLW#(SD)	;Get line width too
.ENDC
	MOVB	(R2)+,77(R1)		;REMEMBER HIGH BYTE OF NODE NUMBER
	BIS	#$H1XD2,SDLHS1#(SD)	;BUMP STATE
	POP	R3			;RESTORE R3
;8$:	JMP	NXTSPR			;THATS ALL
	BR	28$

;HERE IF EXPECTING LOW 6 BITS OF NODE NUMBER AND PORT NUMBER

10$:	MOV	SDLHSC#(SD),R1		;GET ADDRESS OF CONNECT PACKET
	BNE	12$			;FOR DEBUGGING
	FSTOP	NCP			;[NO CONNECT PACKET SAVED]

12$:	MOVB	(R2)+,76(R1)		;GET LOW BYTE OF NODE NUMBER
	MOV	76(R1),R0		;GET NODE NUMBER
	ROLB	R0			;POSITION IT IN LEFT 12 BITS IN WORD
	ROLB	R0
	ROL	R0
	ROL	R0
	PUSH	R3			;FREE UP A REGISTER
	PUSH	R4			;OR 2
	MOV	R1,R4
	ADD	#PKDATA+16,R4		;POINT TO START OF SRC NAME
	MOV	#4,R3			;SET COUNTER
	CALL	PUTNUM			;PUT NODE NUMBER INTO THE PACKET
	MOVB	(R2)+,R0		;GET REMOTE PORT NUMBER
	BIC	#^C177,R0		;ONLY 7 BITS
	MOVB	R0,PKDATA+15(R1)	;STORE AS SRC SOCKET
	POP	R4			;FINISHED-RESTORE DDB ADDRESS
	POP	R3			;RESTORE R3
	BIC	#$H1XD1!$H1XD2,SDLHS1#(SD);RESET STATE
	BR	28$			;FINISHED

;HERE IF NOT EXPECTING FIRST 2 MESSAGES FOR A CIRCUIT

14$:	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SOCKET CONNECTED NOW?
	BEQ	20$			;YES-THIS IS EASY!
	MOV	SDLHSC#(SD),R1		;GET ADDRESS OF SAVED PACKET
	BEQ	1$			;VERY STRANGE!
	CMPB	#.SSCFP,SDSTS1#(SD)	;IS A CONNECTION PENDING NOW?
	BEQ	16$			;YES-THIS IS THE DATA PACKET
	MOV	(R1),R1			;NO-DATA PACKET IS LINKED TO THE CONNECT
					;  PACKET
	BNE	16$			;GO ON IF HAVE A DATA PACKET NOW
	CALL	LKHRPK			;GET A PACKET
	CLR	PKCNT(R1)		;CLEAR TYPE AND COUNT
	MOV	R1,@SDLHSC#(SD)		;LINK TO CONNECT PACKET
16$:	MOVB	PKCNT(R1),R0		;GET COUNT
	ADD	R1,R0			;RELOCATE TO PACKET
	ADD	#PKDATA,R0
	MOVB	(R2)+,(R0)+		;STORE FIRST CHARACTER
	INCB	PKCNT(R1)		;BUMP COUNT
	MOVB	(R2)+,(R0)+		;STORE SECOND CHARACTER
	INCB	PKCNT(R1)		;BUMP COUNT
	BR	28$			;THATS ALL

20$:
.IFF					;IF DO NOT HAVE BASE SUPPORT
	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SOCKET CONNECTED NOW?
	BNE	1$			;NO-ERROR!
.ENDC

	CALL	LKHRPK			;Get a packet
	MOVB	(R2)+,R0		;GET FIRST DATA BYTE
	CMPB	#.CCPRE,R0		;IS IT A PREFIX CODE?
	BEQ	30$			;YES-GO HANDLE THAT
	MOVB	R0,PKDATA(R1)		;NO-STORE IN PACKET
	MOVB	(R2)+,PKDATA+1(R1)	;STORE 2ND BYTE IN PACKET
	MOV	#2,PKCNT(R1)		;MAKE INTO 2 BYTE DATA PACKET
	CALL	LKHSPK#			;SEND THE PACKET
28$:	JMP	NXTSPR			;THATS ALL

;HERE IF FIRST CHARACTER IS A PREFIX CHARACTER

30$:	MOVB	(R2)+,R0		;GET NEXT CHARACTER
	CMPB	#360,R0			;IS THIS A HANG CHARACTER?
	BEQ	32$			;YES
	FREPKT				;NO-GIVE UP THE PACKET
	BR	28$			;THATS ALL!

;HERE FOR A HANG CHARACTER

32$:	JMP	ZAPCI1			;GO DO A ZAP CIR
	.PAGE
;TYMNET TERMINAL TYPE TO NEXILIS TERMINAL TYPE AND BAUD RATE TABLES

.IF EQ ..SAT

	PURE

	.MACRO	XXX
	XX	AUX ,300	;  0 - HOST (AUX CIRCUIT)
	XX	CRT ,300	;  1 - 300 BAUD, TIC = A
	XX	TRMC,300	;  2 - 300 BAUD, TIC = C
	XX	TRME,300	;  3 - 300 BAUD, TIC = E
	XX	TRMG,300	;  4 - 300 BAUD, TIC = G
	XX	TRMB,150	;  5 - 150 BAUD, TIC = B
	XX	TRMC,150	;  6 - 150 BAUD, TIC = C
	XX	TRMJ,150	;  7 - 150 BAUD, TIC = J
	XX	SEL ,300X	;  8 - 300 BAUD, SELECTRIC
	XX	SEL ,134X	;  9 - 134 BAUD, SELECTRIC
	XX	CRT ,110	; 10 - 110 BAUD, TIC = D
	XX	2780,300	; 11 - 2780 ?
	XX	CRTA,1200	; 12 - 1200 BAUD, TIC = A
	XX	CRTA,300	; 13 - Borroughs polled
	XX	AUX ,300	; 14 - AUX through gateway
	XX	BAUD,50		; 15 - Baudot
	XX	CRTA,2400	; 16 - 2400 BAUD
	XX	3270,300	; 17 - 3270
	XX	3270,300	; 18 - 3270 Printer
	XX	CRTA,4800	; 19 - 4800 BAUD
	XX	CRTA,9600	; 20 - 9600 BAUD
	XX	CRTA,1200	; 21 - MULTIPLEXED PVC
	XX	AUDIO,300	; 22 - AUDIO RESPONSE UNIT
	XX	CRTA,1200	; 23 - 75/1200 BAUD TERMINALS
	XX	3270,300	; 24 - SDLC
	XX	TRM	; 25 - TRANSACTION TERMINALS
	XX	AUX,300		; 26 - "HOST ORIENTED"
	.ENDM

;GENERATE TYMNET TERMINAL TYPE TO NEXILIS TERMINAL TYPE TABLE

	.MACRO	XX  TYPE,RATE
.IF NB TYPE
	.BYTE	T.'TYPE
.IFF
	.BYTE	0
.ENDC
	.ENDM

TYNTYT:	XXX
MAXTYT=!.-TYNTYT

;GENERATE TYMNET TERMINAL TYPE TO NEXILIS BAUD RATE TABLE

	.MACRO	XX  TYPE,RATE
.IF NB RATE
	.BYTE	R.'RATE
.IFF
	.BYTE	0
.ENDC
	.ENDM

TYNTYR:	XXX

	CODE

.ENDC		;.IF EQ ..SAT
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMCPT = 2 - CHANGE PERMUTER TABLE ENTRY
;	SR2 = (6) LINE (10) CHANNEL
;	SR3 = (2) SPEED (14) BUFFER NUMBER

CHGPMT:	PUSH	R3			;RESPECT OUR LDB POINER
	MOVB	(R2),R0			;GET LINE NUMBER
	ASHI	-2,R0
	BIC	#^C77,R0
	CMP	#20,R0			;IS THIS FOR AN INTERNAL CIRCUIT?
	BEQ	2$			;YES-FAKE IT FOR NOW!
	MOV	DDLHLD#(R4),R3		;GET FIRST LDB
1$:	DEC	R0			;THIS ONE?
	BLT	4$			;YES
	MOV	LDHNXT#(R3),R3		;NO-ADVANCE TO NEXT LDB
	BNE	1$			;CONTINUE IF MORE
	POP	R3			;BAD LINE NUMBER-REJECT THE MESSAGE
	JMP	BADSPR

;HERE FOR INTERNAL CIRCUIT

2$:	PUSH	#.SMMDR*10000		;SEND ACK TO SUP
	PUSH	#100000+.S3PTA
	ADD	#2,R2
	SPRWRD	SD
	PUSH	SD
	BIC	#^C776,SD		;REMOVE JUNK FROM THE BUFFER NUMBER
	CALL	GETSDB			;GET CORRESPONDING SDB
	BCS	3$			;IF NONE
	TBBN	$H1INC!$H1AUX,SDLHS1#(SD),3$ ;GO ON IF NOT TERMINAL CONNECTION
	MOV	#.ERHNA,R0		;TERMINAL-SEND A KILL
	CALL	MAKKIL#
	CALL	LKHSPK
	CALL	CLRCIR			;CLEAN UP LINK TO TYMNET
3$:	CALL	SNDSPR
	POP	R3			;RESTORE R3
	JMP	NXTSPR			;THATS ALL!

;HERE FOR NORMAL CASE OF GOOD LINE AND EXTERAL CALL WITH R3 POINTING
;	 TO LDB FOR THE LINE WE WANT TO CHANGE

4$:	SPRWRD	R0			;GET CHANNEL NUMBER
	BIC	#^C1777,R0
	PUSH	R0			;SAVE FOR LATER
	ASL	R0			;IS THIS CHANNEL IN USE NOW?
	ADD	LDHSDB#(R3),R0
	MOV	(R0),SD
	BEQ	20$			;NO-GO ON (THIS IS THE USUAL CASE)

;HERE IF THE CHANNEL WE ARE TO CHANGE IS NOT FREE

	PUSH	R2
	PUSH	R0
	ROR	SD			;REALLY IN USE?
	BCC	10$			;YES
6$:	ADD	#6,SP			;NO-FIX UP THE STACK (WILL ONLY GET
					;  HERE WHEN THERE IS A ZAP REQUEST
					;  PENDING FOR THIS LINE - THIS CAN
					;  HAPPEN IF THE SUPERVISOR IS VERY
					;  FAST AFTER REQUESTING THAT A CIRCUIT
					;  BE ZAPPED - THIS IS VERY UNLIKELY
					;  AND IT DOES NOT SEEM TO BE WORTH THE
					;  RISK OF INTERDUCING BUGS TO TRY TO
					;  HANDLE IT RIGHT!  THE USER WILL MOST
					;  LIKELY TRY AGAIN!)
	POP	R3			;RESTORE LDB POINTER
	JMP	BADSP3			;AND REJECT THE MESSAGE

;HERE IF REALLY LINKED TO AN SDB NOW

10$:	ROL	SD			;FIX UP SD
	CLR	SDLHLD#(SD)		;CLEAR LINK TO LDB
	MOV	#.S7OCU*10000!.ERISP,R0	;ERROR = ILLEGAL SEQUENCE OF PACKETS
	CALL	KILSUB			;Kill the circuit
	POP	R0
	POP	R2
	CLR	(R0)			;CLEAR POINTER FOR CHANNEL
20$:	SPRWRD	SD			;GET BUFFER NUMBER
	PUSH	SD			;SAVE WORD FOR LATER
	BIC	#^C776,SD		;REMOVE JUNK
	MOV	SD,R1			;COPY BUFFER NUMBER
	CALL	GETSDB			;GET THE CORRESPONDING SDB
.IF EQ ..SAT
	BCC	26$			;GO ON IF FOUND ONE
	PUSH	R0			;THIS MUST BE FOR AN AUX-CIRCUIT
	MOV	R1,R0			;GET HOST ARRAY NUMBER FROM THE
	BIC	#^C600,R0
	ASHI	-6,R0			;  BUFFER NUMBER
	ADD	R4,R0			;POINT TO DATA IN DDB
	MOV	DDLHXS#(R0),SD		;GET AUX-CIRCUIT SDB
	BNE	22$			;GO ON IF HAVE ONE
21$:	TST	(SP)+			;FAIL IF NONE!
	BR	32$

22$:	CMPB	DDLHXP#(R0),SDLHBF#(SD)	;HAVE WE SET UP THIS CIRCUIT YET?
	BNE	21$			;YES-SOMEONE IS VERY MIXED UP!
	POP	R0			;RESTORE R0
	ASR	R1			;NO-STORE ACTUAL PORT NUMBER IN SDB
	MOVB	R1,SDLHBF#(SD)
.IFF
	BCS	32$			;FAIL IF NONE THERE IF TYMSAT
.ENDC
26$:	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SDB CONNECTED?
	BEQ	30$			;YES-GO ON
	TBBE	$H1INC,SDLHS1#(SD),32$	;NO-IS AN INCOMING CONNECT PENDING?
30$:	TST	SDLHLD#(SD)		;YES-IS THIS SDB LINKED TO AN LDB NOW?
	BEQ	34$			;NO-ALL IS FINE
32$:	ADD	#4,SP			;YES-FIX UP THE STACK
	POP	R3			;RESTORE LDB POINTER
	JMP	BADSPX			;AND GO REJECT THE SUPERVISOR COMMAND

;HERE IF SDB IS CONNECTED BUT IS NOT ASSOCIATED WITH A LINE OR IS NOT BUT
;  AN INCOMING CONNECT IS PENDING

34$:	MOV	SD,(R0)			;LINK SDB TO LDB
	MOV	R3,SDLHLD#(SD)		;LINK LDB TO SDB
	MOVB	2(SP),SDLHCN#(SD)	;ALSO STORE CHANNEL ON LINE
	MOV	(SP),R0			;GET THE CIRCUIT SPEED CODE
	ROL	R0
	ROL	R0
	ROL	R0
	BIC	#^C3,R0
	ASL	R0
	MOVB	R0,SDLHSP#(SD)		;AND SAVE IT IN THE SDB
36$:	CLR	SDACNT#(SD)		;DON'T SEND ANYTHING UNTIL HE SAYS TO
	POP	R0			;RESTORE SR3
	MOV	#.SMMDR*10000,(SP)	;SEND PERMUTER TABLE CHANGE ACK
	PUSH	#100000+.S3PTA
	PUSH	R0
	CALL	SNDSPR
	POP	R3			;RESTORE CURRENT LDB
	TBBN	$H1INC,SDLHS1#(SD),40$	;IS AN INCOMING CONNECT PENDING?
	CALL	LKHRPK			;NO-GET A PACKET
	MOV	#.PTFUN*400+1,PKCNT(R1)	;MAKE IT A 1 BYTE FUNCTION PACKET
	MOV	#.FNCLI,PKDATA(R1)	;CLEAR LOGIN MODE
	CALL	LKHSPK#			;SEND IT
	TBBE	$H1GBR,SDLHS1#(SD),40$	;HAVE WE SEEN A GREEN BALL?
	BIC	#$H1GBR,SDLHS1#(SD)	;YES
	MOV	#.FNGRN,R0
	CALL	BALBCK#			;SEND GREEN BALL ON TO NEXT GUY
40$:	JMP	NXTSPR			;THATS ALL!
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMCMM = 3 - CHANGE MEMORY OR MISCELLANEOUS
;  IF CHANGE MEMORY
;	SR2 = (1) 0 (15) ADDRESS TO CHANGE
;	SR3 = (16) NEW VALUE
;  IF MISCELLANEOUS
;	SR2 = (1) 1 (9) NOT USED (6) SUB-TYPE
;	SR3 = DEPENDS ON SUB-TYPE

CHGMEM:	SPRWRD	R0			;GET SR2
	TST	R0
	BMI	MISCEL			;IF MISCELLANEOUS FUNCTION

;HERE IF HE REALLY WANTS TO CHANGE OUR MEMORY
;	SR2 = (1)0 (15)WORD ADDRESS
;	SR3 = (16) NEW VALUE

	CMP	#10000,R0		;Does he want to change real PDP-11
					;  memory?
	BLOS	10$			;Yes-go do that
	SUB	#100,R0			;DOES HE WANT TO CHANGE A LOW ADDRESS?
	BLT	4$			;YES-HE CAN'T DO THAT!
	CMP	#104,R0			;IS IT TOO HIGH?
	BGE	6$			;NO-GO ON
4$:	JMP	BADSP3			;YES-THATS OFF LIMITS TOO!

6$:	CMP	#3,R0			;CHECK FOR DOWNSTREAM LINE
	BNE	7$
	MOVB	1(R2),R1		;GET THE LINE NUMBER (+1)
	PUSH	R3			;SAVE CURRENT LDB ADDRESS
	MOV	DDLHLD#(R4),R3		;GET FIRST LDB ADDRESS
65$:	MOV	R3,DDLHDW#(R4)		;SAVE AS DOWNSTREAM LINE LDB
	BEQ	66$			;END OF LIST, MUST BE BAD LINE NUMBER 
	DEC	R1			;DINK COUNTER
	BLE	66$			;FOUND THE LINE
	MOV	LDHNXT#(R3),R3		;POINT TO NEXT LDB
	BR	65$			;CONTINUE SEARCHING
66$:	POP	R3			;RESTORE LDB ADDRESS AND CONTINUE
7$:	ASL	R0			;CHANGE TO BYTE OFFSET FROM 100
	ADD	R4,R0			;RELOCATE TO DDB
	MOVB	(R2)+,DDLHSM#+1(R0)	;Store new value
	MOVB	(R2)+,DDLHSM#(R0)
8$:	JMP	NXTSPR			;FINISHED

;Here if changing real PDP-11 memory location

10$:	CLC				;Get actual address
	ROL	R0
	SUB	#20000,R0
	MOVB	(R2)+,1(R0)		;Store first byte
	NXMJMP	12$			;Be safe!
12$:	MOVB	(R2)+,(R0)		;Store second byte
	NXMJMP	14$
14$:	BR	8$

;HERE IF OPERATION FOR .SMCMM IS NOT CHANGE MEMORY

MISCEL:	MOV	R0,R1			;SAVE SR2 FOR THOSE FUNCTIONS THAT NEED IT
	BIC	#^C77,R0		;JUST 6 BITS
	CMP	#17,R0			;VALID FUNCTION?
	BGT	2$			;YES
	JMP	BADSP3			;NO

2$:	ASL	R0			;FOR WORD INDEXING
	JMP	@MISDSP(R0)		;DISPATCH ON THE SUB-TYPE

;DISPATCH TABLE FOR SUB-TYPE FOR MESSAGE TYPE .SMCMM

	PURE

	.EVEN
MISDSP:	.WORD	LGICRS		;.S3LCR =  0 - LOGIN CHARACTER RESPONSE
	.WORD	BADSP3		;	=  1 - ILLEGAL
	.WORD	BADSP3		;	=  2 - ILLEGAL
	.WORD	BADSP3		;	=  3 - ILLEGAL
	.WORD	CLRBUF		;.S3CBF =  4 - CLEAR BUFFER
	.WORD	ZAPCIR		;	=  5 - ZAP CIRCUIT
	.WORD	BADSP3		;	=  6 - ILLEGAL
	.WORD	BADSP3		;	=  7 - ILLEGAL
	.WORD	IGNSP3		;	= 10 - HOST REJECTION
	.WORD	IGNSP3		;	= 11 - ACK LINEOUT REPORT
	.WORD	IGNSP3		;.S3SCT = 12 - SET CONGESTION TIMEOUT
	.WORD	BADSP3		;	= 13 - ILLEGAL
	.WORD	GOBOOT#		;.S3BOT = 14 - GO TO BOOTSTRAP
	.WORD	BADSP3		;.S3DOU = 15 - ILLEGAL
	.WORD	SPEEDS		;.S3RLS = 16 - REPORT LINE SPEEDS
	.WORD	BADSP3		;.S3DLD = 17 - DOWNLOAD NEIGHBOR

	CODE

;HERE FOR SUB-TYPE .S3LCR = 0 - LOGIN CHARACTER RESPONSE
;	SR2 = (1) 1 (9) EXTENDED ERROR CODE (6) 0
;	SR3 = (3) FLAG BITS (10) PORT NUMBER (3) MESSAGE NUMBER

LGICRS:	PUSH	R1			;SAVE SR2
	SPRWRD	SD			;GET SR3
	PUSH	SD			;STACK IT FOR LATER
	ASHI	-3,SD			;GET BUFFER NUMBER OVER 2
	BIC	#^C377,SD
	CALL	GETSD2			;GET SDB
	BCC	2$			;GO ON IF OK
	CMP	(SP)+,(SP)+		;IF ERROR, FIX UP THE STACK
	JMP	BADSPX			;AND CONTINUE

2$:	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SDB CONNECTED?
	BEQ	4$			;YES-GO ON
	MOV	#.CCZAP,R0		;NO-SEND A ZAPPER TO THE SUPERVISOR
	CALL	LKHSCM#
	CMP	(SP)+,(SP)+		;IF ERROR, FIX UP THE STACK
	JMP	NXTSPR			;AND CONTINUE

4$:	TBBE	020000,(SP),10$		;WANT TO CLEAR OUTPUT BUFFER?
	MAKPKT	.PLSTP#			;YES-SEND EAT PACKET
	BCS	10$
	MOV	#.PTEAT*400+1,PKCNT(R1)
	CLRB	PKDATA(R1)
	CALL	LKHSPK#
10$:	BIS	#$H2PWM,SDLHS2#(SD)	;ASSUME DEFAULT OF PASSWORD ENTRY
	TBBE	040000,(SP),20$		;WANT TO ENABLE ECHOING?
	BIC	#$H2PWM,SDLHS2#(SD)	;YES - CLEAR PASSWORD ENTRY MODE
	MAKPKT	.PLSTP#
	BCS	20$
	MOV	#.PTFUN*400+3,PKCNT(R1)
	MOV	#.TPECH*400+.FNSDP,PKDATA(R1)
	MOVB	#1,PKDATA+2(R1)
	CALL	LKHSPK#
20$:	TBBE	100000,(SP),30$		;WANT TO CLEAR INPUT BUFFER?
	PUSH	R2			;YES-SAVE OUR SPECIAL AC'S
	PUSH	R3
	CALL	CLRINP#			;AND DO IT!
	POP	R3
	POP	R2
30$:	POP	R0			;GET MESSAGE NUMBER
	POP	R1			;GET POSSIBLE EXTENDED CODE
	BIC	#^C7,R0
	CMP	#7,R0			;EXTENDED ERROR MESSAGE ?
	BNE	301$
	ROL	R1			;SHIFT EXTENDED ERROR CODE INTO POSITION
	ROL	R1
	CLRB	R1			;CLEAR LOWER BYTE
	SWAB	R1			;WE NOW HAVE THE ERROR INDEX
	SUB	#10,R1			;SCALE ERROR CODE
	MOV	#ERRSUP,R0		;POINT TO DEFAULT MESSAGE
	CMP	#13,R1			;TEST AGAINST MAX ERROR CODE
	BLT	302$			;OUT OF RANGE - USE SUPERR MSG
	ASL	R1
	MOV	EXERR(R1),R0		;POINT TO ERROR MESSAGE
302$:	CALL	SNDMSG			;SEND THIS MESSAGE TO THE OTHER END
	MOV	#7,R0			;RESTORE ERROR CODE
301$:
.IF EQ ..SAT
	MOVB	ERRTBL(R0),R1		;GET ERROR CODE
	BEQ	31$			;IF NO ERROR CODE
	TBBE	$H1TCD,SDLHS1#(SD),31$	;OR IF NOT TYMNET COMMAND DECODER
	PUSH	R1			;SAVE ERROR CODE
	MOV	#.CCZAP,R0		;SEND A ZAPPER TO THE SUPERVISOR
	CALL	LKHSCM#
	POP	R0			;RESTORE ERROR CODE
	CALL	LKHRPK			;GET A PACKET
	MOV	#.PTDIS*400,PKCNT(R1)	;MAKE INTO A DISCONNECT PACKET
	CALL	SETEPK#
	CALL	LKHSPK#			;AND SEND IT
	BR	LGIC40			;THATS ALL
.ENDC

;HERE IF WANT TO SEND MESSAGE FROM HERE

31$:	ASL	R0			;FIX IT UP FOR WORD ADDRESSING
	MOV	MSGPNT(R0),R0		;GET ADDRESS OF MESSAGE
	BEQ	LGIC36			;GO ON IF NO MESSAGE
32$:	CALL	SNDMSG
	TSTB	@R0			;ARE WE ASKING FOR HIS PASSWORD?
	BNE	LGIC36			;NO-GO ON
	TBBE	$H1LCT,SDLHS1#(SD),LGIC36;YES-IS THIS A LOCAL COPY TERMINAL?
	MOV	#PWMASK,R0		;YES-TYPE A MASK
	TBBE	$H1SEL,SDLHS1#(SD),32$	;IS IT A SELECTRIC?
	MOV	#SLMASK,R0		;YES-USE RIGHT MASK
	BR	32$

;HERE WHEN FINISHED WITH TEXT

LGIC36:	BIS	#$H1INX,SDLHS1#(SD)	;INDICATE EXPECTING INPUT NOW
	MOV	#77777,SDACNT#(SD)	;ACCEPT OUTPUT NOW
	TBBE	$H1GBR,SDLHS1#(SD),10$	;HAVE WE SEEN A GREEN BALL?
	BIC	#$H1GBR,SDLHS1#(SD)	;YES
	CALL	LKHRPK			;SEND HIM A GREEN BALL
	MOV	#.PTFUN*400+1,PKCNT(R1)
	MOVB	#.FNGRN,PKDATA(R1)
	CALL	LKHSPK#
10$:	MOV	SDPKDH#(SD),R1		;ANYTHING PENDING?
	BEQ	LGIC40			;NO-FINISHED HERE
	PUSH	R2			;YES-SAVE VALUABLE AC'S
	PUSH	R3
	CALL	LHPOKE#			;START THINGS UP AGAIN
	POP	R3
	POP	R2
LGIC40:	JMP	NXTSPR			;THATS ALL

SNDMSG:
32$:	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	LGIC36			;WE TRIED!
	CLRB	PKTYPE(R1)		;MAKE IT A DATA PACKET
	ADD	#PKDATA,R1		;POINT TO DATA AREA
34$:	MOVB	(R0)+,(R1)+		;COPY MESSAGE
	BEQ	35$			;IF END OF STRING
	TBBN	77,R1,34$		;CONTINUE IF PACKET NOT FULL
	PUSH	R0			;FULL-SEND THE PACKET
	CALL	SNDTYM#
	POP	R0
	BR	32$			;GET ANOTHER PACKET AND CONTINUE

;HERE AT END OF STRING

35$:	PUSH	R0			;SAVE THE POINTER TO THE STRING
	DEC	R1			;FIX UP POINTER TO THE PACKET
	CALL	SNDTYM#			;SEND THE DATA PACKET
	POP	R0
	RETURN

;MESSAGE TABLES FOR .S3LCR

	PURE

	.EVEN
MSGPNT:	.WORD	0		; 0 - NO MESSAGE
	.WORD	MSG001		; 1 - "please log in: "
	.WORD	MSG002		; 2 - "error, type username: "
	.WORD	MSG003		; 3 - "error, type password: "
	.WORD	MSG004		; 4 - "username: "
	.WORD	MSG005		; 5 - "password: "
	.WORD	0		; 6 - ILLEGAL
	.WORD	0		; 7 - ILLEGAL

EXERR:	.WORD	MSG010		; 10 - "please see your rep..."
	.WORD	MSG011		; 11 - "bad mud"
	.WORD	MSG012		; 12 - "circuits busy"
	.WORD	MSG013		; 13 - "host not available"
	.WORD	MSG014		; 14 - "host out of ports"
	.WORD	MSG015		; 15 - " host down"
	.WORD	MSG016		; 16 - "host shut"
	.WORD	MSG017		; 17 - "try again in 2 minutes"
	.WORD	MSG020		; 20 - "access not permited"
	.WORD	MSG021		; 21 - "No host specified"
	.WORD	MSG022		; 22 - "bad host number"
	.WORD	MSG023		; 23 - "mud error"


;MESSAGE TEXT STRINGS - ALL STRINGS END IN A ZERO BYTE - IF A STRING ENDS IN
;  TWO ZERO BYTES, A PASSWORD MASK IS TYPED AFTER THE STRING IF FOR A LOCAL
;  COPY TERMINAL (NOTE: THE MASK IS OUTPUT USING THE SAME CODE AS THE STRINGS,
;  THUS IT MUST BE FOLLOWED BY A SINGLE ZERO BYTE UNLESS WE WANT TO OUTPUT IT
;  FOREVER!)

PWMASK:	.ASCII	<CR><LF><377><377>	;THIS IS THE PASSWORD MASK
	.ASCII	"###############"<CR><377><377>
	.ASCII	"+++++++++++++++"<CR><377><377>
	.ASCIZ	"OOOOOOOOOOOOOOO"<CR>
	.BYTE	1			;THIS IS NOT A PASSWORD REQUEST

SLMASK:	.ASCII	"###############"	;PASSWORD MASK FOR SELECTRICS
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.ASCII	"+++++++++++++++"
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.ASCII	"OOOOOOOOOOOOOOO"
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.BYTE	0			;WARNING-NEXT BYTE MUST NOT BE 0!
	.BYTE	1			;THIS IS NOT A PASSWORD REQUEST

MSG001:	.ASCIZ	<CR><LF>"please log in: "
MSG002:	.ASCIZ	<CR><LF>"error, type user name: "
MSG003:	.ASCIZ	<CR><LF>"error, type password: "
	.BYTE	0			;THIS FLAGS THAT A PASSWORD MASK MAY BE
					;  NEEDED NEXT
MSG004:	.ASCIZ	<CR><LF>"user name: "
MSG005:	.ASCIZ	<CR><LF>"password: "
	.BYTE	0			;THIS FLAGS THAT A PASSWORD MASK MAY BE
					;  NEEDED NEXT
MSG010:	.ASCII	<CR><LF>"please see your representative"
	.ASCIZ	<CR><LF>"if you are having trouble logging in"
MSG011:	.ASCIZ	<CR><LF>"bad mud"
MSG012:	.ASCIZ	<CR><LF>"circuits busy"
MSG013:	.ASCIZ	<CR><LF>"host not available thru network"
MSG014:	.ASCIZ	<CR><LF>"host out of ports"
MSG015:	.ASCIZ	<CR><LF>"host down"
MSG016:	.ASCIZ	<CR><LF>"host shut"
MSG017:	.ASCIZ	<CR><LF>"try again in 2 minutes"
MSG020:	.ASCIZ	<CR><LF>"access not permitted"
MSG021:	.ASCIZ	<CR><LF>"no host specified"
MSG022:	.ASCIZ	<CR><LF>"bad host number"
MSG023:	.ASCIZ	<CR><LF>"mud error"
ERRSUP:	.ASCIZ	<CR><LF>"unknown network error"

;TABLE OF NETWORK ERROR CODES FOR SPECIAL MESSAGES - USED WHEN CONNECTED TO
;  A TYMNET MODE COMMAND DECODER

.IF EQ ..SAT
ERRTBL:	.BYTE	0		; 0 - NO MESSAGE
	.BYTE	.ERREQ		; 1 - "please log in: "
	.BYTE	.ERUNE		; 2 - "error, type username: "
	.BYTE	0		; 3 - "error, type password: "
	.BYTE	.ERREQ		; 4 - "username: "
	.BYTE	0		; 5 - "password: "
	.BYTE	0		; 6 - ILLEGAL
	.BYTE	.ERREQ		; 7 - EXTENDED ERROR - HANDLED EARLIER
.ENDC

	CODE
	.PAGE
;HERE FOR SUB-TYPE .S3CBF = 4 - CLEAR BUFFER
;	SR2 = (16) 100004
;	SR3 = (16) BUFFER NUMBER

CLRBUF:	SPRWRD	SD			;GET BUFFER NUMBER
	CLC				;GET DIRECTION BIT IN C, SOCKET IN SD
	ROR	SD
	ROR	R0			;REMEMBER DIRECTION IN SIGN BIT OF R0
	CALL	GETSD2			;GET THE SDB
	BCS	10$			;IF NONE
	CMPB	#.SSCON,SDSTS1#(SD)	;IS THE SOCKET CONNECTED?
	BNE	10$			;NO-FORGET THIS
	CALL	LKHRPK			;GET A PACKET
	MOV	#.PTEAT*400+1,PKCNT(R1)	;MAKE INTO A NULL FUNCTION EAT PACKET
	CLRB	PKDATA(R1)
	TST	R0			;WHICH DIRECTION?
	BMI	4$			;AWAY FROM NETWORK
	MOV	(SD),SD			;TOWARD NETWORK-POINT TO LINKED SDB
4$:	PUSH	R4			;MAKE SURE R4 IS PRESERVED
	CALL	LKHSPK#			;SEND THE PACKET
	POP	R4
10$:	JMP	NXTSPR			;THATS ALL
	.PAGE
;HERE FOR SUB-TYPE 4 - ZAP CIRCUIT
;	SR2 = (16) 100005
;	SR3 = (16) BUFFER NUMBER

ZAPCIR:	SPRWRD	SD			;GET BUFFER NUMBER
	CALL	GETSDB			;GET THE SDB
	BCS	ZAPCI2			;IF NONE
ZAPCI1:	MOV	#.ERSVR,R0		;REPORT THIS AS A SUPERVISOR REQUEST
	CALL	SETDIS#
	CALL	LKHSPK#
.IF EQ ..SAT
	MOV	#.S7OCZ*10000,R0	;GET REASON IF THIS IS A BASE
.ENDC
	CALL	BRKCIR			;BREAK CONNECTION TO TYMNET!
ZAPCI2:	JMP	NXTSPR			;THATS ALL
	.PAGE
;HERE FOR SUB-TYPE .S3RLS = 14 - REPORT LINE SPEEDS
;	SR2 = (16) 100016
;	SR3 = NOT USED

SPEEDS:	PUSH	R3			;SAVE R3
	MOV	DDLHLD#(R4),R3		;POINT TO FIRST LDB
2$:	MOVB	LDHSPD#(R3),R0		;GET LINE SPEED
	ASHI	6,R0			;PUT IN RIGHT PLACE
	BIS	#100000!.S3LES,R0	;ADD OTHER JUNK
	TBBE	$L0SAT,LDHST0#(R3),3$	;SKIP IF NORMAL LINK
	BIS	#$BIT14,R0		;SET WINDOW SIZE 8 BIT
3$:	PUSH	#.SMMDR*10000		;SR1
	PUSH	R0			;SR2
	MOVB	LDHLNO#(R3),R0		;GET LINE NUMBER
	PUSH	R0			;SR3
	CALL	SNDSPR			;SEND TO CURRENT SUPERVISOR
	TBBE	$RESET,LDHST2#(R3),4$	;CHECK FOR LINE IN RESET STATE
	PUSH	#.SMMDR*10000		;SR1
	PUSH	#100305			;SR2-SAY LINE IS MARKING
	MOVB	LDHLNO#(R3),R0		;GET THE LINE NUMBER
	PUSH	R0			;SR3
	CALL	SNDSPR
4$:	MOV	LDHNXT#(R3),R3		;STEP TO NEXT LINE
	BNE	2$			;CONTINUE IF MORE
	POP	R3			;RESTORE R3
	TST	(R2)+			;FIX UP R2
	JMP	NXTSPR			;THATS ALL
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMRDM = 4 - READ MEMORY
;	SR2 = (16) FIRST ADDRESS
;	SR3 = (16) SECOND ADDRESS

REDMEM:	SPRWRD	R0			;GET FIRST ADDRESS HE WANTS
	SPRWRD	R1			;GET SECOND ADDRESS HE WANTS
	PUSH	R1			;SAVE FOR LATER
	TST	R0
	BMI	10$			;HANDLE EXTENDED RANGE DIFFERENT
	CALL	READSM			;PROCESS THE FIRST ADDRESS
	CALL	SNDDAT			;SEND DATA TO SUP
	POP	R0			;GET BACK ADDRESS
	CALL	READSM			;PROCESS THE SECOND ADDRESS
	CALL	SNDDAT			;SEND DATA TO SUP
	JMP	NXTSPR			;FINISHED

10$:	BIC	#100000,R0		;MAKE SURE HIGH BIT IS CLEAR
15$:	CMP	R0,(SP)			;TEST CURRENT ADDRESS AGAINST ENDING
	BHI	30$			;ALL DONE
	CALL	READSM			;GET DATA ITEM
	CMP	#-1,R0			;COMPRESSED DATA?
	BNE	60$			;NO
	CMP	R1,(SP)			;CHECK FOR LAST ADDRESS
	BEQ	60$			;ALL DONE
	PUSH	R1			;YES - SAVE THE STARTING ADDRESS
20$:	MOV	R1,R0			;GET ADDRESS
	INC	R0			;GO FOR NEXT ADDRESS
	CALL	READSM			;GET THE DATA
	CMP	#-1,R0			;WAS IT -1
	BNE	50$			;NOT COMPRESSED DATA
	CMP	R1,2(SP)		;CHECK FOR ENDING ADDRESS
	BLO	20$			;NOT DONE YET
	POP	R0			;GET START OF BLOCK
	CALL	SNDCMP			;SEND COMPRESSED DATA BLOCK
30$:	POP	R0			;POP ENDING ADDRESS
	JMP	NXTSPR
50$:	POP	SD			;GET BACK STARTING ADDRESS
	PUSH	R0			;SAVE NON -1 DATA
	PUSH	R1			;SAVE ADDRESS
	DEC	R1			;POINT TO PREVIOUS ADDRESS
	MOV	SD,R0			;STARTING ADDRESS
	CALL	SNDCMP
	POP	R1			;GET BACK ADDRESS
	POP	R0			;GET BACK DATA	
60$:	PUSH	R1
	CALL	SNDDAT			;SEND DATA TO SUP
	POP	R0			;GET ADDRESS
	INC	R0			;POINT TO NEXT DATUM
	BR	15$			;GO GET NEXT DATA

;SUBROUTINE TO READ MEMORY FOR SUPERVISOR
;	C(R0) = ADDRESS TO READ
;	CALL	READSM
;	 RETURNS C(R0) DATA READ
;		 C(R1) ADDRESS
READSM:	PUSH	R0			;REMEMBER THE ADDRESS
	CMP	#10000,R0		;Does he want a real PDP-11 location?
	BHI	2$			;No
	SUB	#10000,R0		;Yes-get actual address
	CLC
	ROL	R0
	MOV	(R0),R0			;GET CONTENTS
	NXMJMP	14$			;IN CASE HE GIVES US A BAD ADDRESS!
	BR	16$			;OK-GO RETURN CONTENTS

;HERE IF NOT READING PDP-11 MEMORY SPACE

2$:	CMP	#100,R0			;IS IT IN THE NORMAL SUPERVISOR AREA?
	BLOS	6$			;MAYBE
	CMP	#4,R0			;NO-IS IT THE NODE DESCRIPTOR?
	BNE	4$			;NO-CHECK FOR CRASH ADDRESS REQUEST
	MOV	DDLHND#(R4),R0		;YES-GET IT
	BR	16$			;CONTINUE

4$:	CMP	#3,R0			;IS IT THE CRASH ADDRESS REQUEST
	BNE	14$			;NO- REPORT ZERO
	MOV	#SAVEEC#+20000,R0	;BUILD POINTER TO CRASH SAVE AREA
	CLC				;PREPARE TO ROTATE
	ROR	R0			;CONVERT TO WORD ADDRESS
	BR	16$			;CONTINUE

6$:	CMP	R0,DDLHMX#(R4)		;CHECK HIGH LIMIT
	BHI	10$			;NO-GO CHECK SOME MORE
	ASL	R0			;YES-CHANGE TO WORD OFFSET
	ADD	R4,R0			;RELOCATE TO THE DDB
	MOV	DDLHSM#-200(R0),R0	;GET CONTENTS
	BR	16$			;CONTINUE

;HERE IF ADDRESS IS NOT IN THE NORMAL SUPERVISOR AREA-SEE IF IT POINTS TO ONE
;  OF THE DUMMY PERMUTER TABLES

10$:	CMP	#1000,R0		;DUMMY PERMUTER TABLES START AT 1000
	BHI	14$			;NOPE!
	PUSH	R3			;SAVE ADDRESS OF CURRENT LDB
	SUB	#1000,R0		;GET OFFSET IN TABLES
	MOV	DDLHLD#(R4),R3		;SCAN LDB'S
11$:	CLR	R1			;GET NUMBER OF CHANNELS ON THIS LINE
	BISB	LDHCHN#(R3),R1
	SUB	R1,R0			;DOES IT POINT TO THIS LINE?
	BLT	12$			;YES
	MOV	LDHNXT#(R3),R3		;NO-STEP TO NEXT LDB
	BNE	11$			;CONTINUE IF MORE THERE
	POP	R3			;NO MORE-GIVE HIM -1!
	BR	15$

;HERE WITH PROPER LDB

12$:	ADD	R1,R0			;RESTORE CHANNEL NUMBER
	MOV	LDHSDB#(R3),SD		;GET ADDRESS OF SDB TABLE FOR THIS LINE
	POP	R3			;RESTORE R3
	ASL	R0			;SEE IF A SDB IS LINKED
	ADD	SD,R0
	MOV	(R0),SD
	BEQ	15$			;NO-CONTENTS IS -1
	MOVB	SDLHSP#(SD),R0		;YES-GET SPEED BYTE
	ASHI	4,R0
	SWAB	R0			;IN THE RIGHT PLACE (ALMOST)
.IF EQ ..SAT
	BISB	SDLHBF#(SD),R0		;GET BUFFER NUMBER OVER 2
.IFF
	BISB	SDSOC#(SD),R0
.ENDC
	ROL	R0			;FIX IT UP
	BR	16$			;GO SEND IT

;HERE IF SHOULD RETURN 0 AS CONTENTS

14$:	CLR	R0			;GET 0
	BR	16$			;CONTINUE

;HERE IF SHOULD RETURN -1 AS CONTENTS

15$:	MOV	#-1,R0			;GET -1
16$:	POP	R1			;GET ADDRESS
	RETURN

SNDDAT:	PUSH	#.SMMDR*10000		;SR1
	PUSH	R1			;SR2 = ADDRESS
	PUSH	R0			;SR3 = DATA
	CALL	SNDSPR			;SEND TO SUPERVISOR AND RETURN (NOTE:
	RETURN				;  BECAUSE OF THE FUNNY WAY SNDSPR USES
					;  THE STACK, THIS CALL/RETURN PAIR
					;  CANNOT BE REPLACED WITH A CJMP!!)


SNDCMP:	PUSH	#.SMMS6*10000		;SR1
	PUSH	R0			;SR2 = ADDRESS
	PUSH	R1			;SR3 = ADDRESS
	CALL	SNDSPR			;SEND TO SUPERVISOR AND RETURN (NOTE:
	RETURN				;  BECAUSE OF THE FUNNY WAY SNDSPR USES
					;  THE STACK, THIS CALL/RETURN PAIR
					;  CANNOT BE REPLACED WITH A CJMP!!)
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMLGI = 5 - LOGIN STATUS
;	SR2 = DEPENDS ON SUB-TYPE
;	SR3 = (8) SUB-TYPE (8) DEPENDS ON SUB-TYPE

.IF EQ ..SAT

LGISTS:	SPRWRD	SD			;GET SR2
	SPRWRD	R0			;GET SR3
	SWAB	R0			;GET TYPE IN RIGHT HALF
	CMPB	#.S5IIS,R0		;TYPE = .S5IIS?
	BEQ	LGIIIS			;YES
	JMP	LGIEIL			;NO - TRY THE NEXT ONE

;HERE FOR SUB-TYPE .S5IIS = 5 - INTERNALLY INITIATED LOGIN STATUS
;  THIS MESSAGE HAS TWO USES:
;    ACKNOWLEDGEMENT TO A REQUEST TO BUILD AN AUX-CIRCUIT
;	SR2 = (8) 0 (8) KEY
;	SR3 = (8) 5 (8) 0
;    TERMINATION OF AUX-CIRCUIT BUILDING DIALOG
;	SR2 = (8) 200 (8) KEY
;	SR3 = (8) 5 (8) ERROR CODE
;     WHERE ERROR CODE IS DEFINED AS FOLLOWS:
;	0 = NO ERROR (NORMAL TERMINATION)
;	1 = FORMAT ERROR IN LOGIN STRING
;	2 = USER NAME ERROR
;	3 = MUD ERROR
;	4 = SYSTEM UNAVAILABLE
;	5 = COMMAND REJECT
;	6 = TIME OUT
;	7 = UNDEFINED
;	8 = OUT OF ORGINATING PROTS
;	9 = REQUEST NOT HONORED (AUX CIRCUIT QUEUE FULL)

LGIIIS:	PUSH	R0			;SAVE THE ERROR CODE
	MOV	R4,R0			;COPY DDB POINTER
	MOV	#4,R1			;SET COUNTER TO NUMBER OF PSEUDO-PORTS
2$:	CMPB	DDLHXP#(R0),SD		;THIS ONE?
	BEQ	4$			;YES
	ADD	#2,R0			;NO-BUMP POINTER
	SOB	R1,2$			;CONTINUE IF MORE TO CHECK
3$:	POP	R0			;NO MORE-FIX UP THE STACK
	BR	LGIERR			;ERROR

4$:	MOV	SD,R1			;COPY SR2
	MOV	DDLHXS#(R0),SD		;GET CURRENT AUX-CIRCUIT SDB
	BEQ	3$			;ERROR IF NONE
	PUSH	R1
	TBBE	100000,R1,5$		;IS THIS THE FINAL MESSAGE?
	CLR	DDLHXS#(R0)		;YES-CLEAR AUX-CIRCUIT POINTER
	PUSH	R2			;CLEAR TIMER
	PUSH	R3
	MOV	#LKHATO,R1
	CALL	TIMKIL#
	POP	R3
	POP	R2
	BR	6$
5$:	PUSH	#.SMMS5*10000		;SEND A MISC MESSAGE
	PUSH	DDLHHD#(R0)		;PUT IN HOST NUMBER
	PUSH	DDLHXP#(R0)		;PUT IN KEY
	BIS	#.S5AHO*400,(SP)	;PUT IN MESSAGE TYPE
	CALL	SNDSPR			;SEND OFF TO SUP
6$:	POP	R1
	POP	R0			;RESTORE ERROR CODE
	SWAB	R0			;GET ERROR CODE IN RIGHT PLACE
	BIC	#^C377,R0
	CMP	R0,#ERCMAX		;KNOWN VALUE?
	BLOS	10$			;YES
	MOV	#ERCMAX,R0		;NO
10$:	TBBN	100000,R1,20$		;FINAL MESSAGE?
	CMPB	#.SSCTP,SDSTS1#(SD)	;NO-IS A CONNECTION PENDING?
	BNE	LGIERR			;NO-ERROR
	CALL	LKHRPK			;YES-GET A PACKET
	MOV	#77777,SDACNT#(SD)	;TURN OFF BACKPRESSURE SO WILL ACCEPT
					;  THE LOGIN STRING
	PUSH	R2			;SAVE THE IMPORTANT REGISTERS
	PUSH	R3
	MOVB	ERCTBL(R0),R0		;GET NEXILIS ERROR CODE
	BNE	14$			;IF ERROR
	MOV	#P.TYMS*400+155,R2	;OK-ACCEPT THE CONNECTION
	CLR	R0
	CALL	ACCEPT#
	BR	16$			;CONTINUE

;HERE IF ERROR

14$:	CALL	REFUSE#			;REFUSE THE CONNECTION
	MOV	#.S7OCU*10000,R0	;GET REASON
	CALL	BRKCIR
16$:	POP	R3			;RESTORE REGISTERS
	POP	R2
	BR	24$			;CONTINUE

;HERE FOR SECOND MESSAGE WHICH TERMINATES THE LOGIN SEQUENCE FOR AUX CIRCUITS

20$:	CMPB	#.SSCON,SDSTS1#(SD)	;CONNECTED NOW?
	BNE	LGIERR			;NO-ERROR
	TST	SDLHLD#(SD)		;ARE WE LINKED TO A LINE?
	BNE	21$			;YES-ALL IS OK
	MOV	#.ERHNA,R0		;NO-MUST BE TRYING TO BUILD INTERNAL CIRCUIT
	BR	22$			;SO LOOSE!

21$:	MOVB	ERCTBL(R0),R0		;YES-GET NEXILIS ERROR CODE
	BEQ	23$			;OK
22$:	CALL	MAKKIL#			;Error-make a Kill packet
	CALL	LKHSPK#			;Send it
	CALL	CLRCIR			;Be safe and break possible link to
	BR	24$			;  Tymnet (should not be one here!)

23$:	CALL	LKHRPK			;GET A PACKET
	MOV	#.PTFUN*400+1,PKCNT(R1)	;MAKE INTO A 1 BYTE FUNCTION PACKET
	MOVB	#.FNCLI,PKDATA(R1)	;FUNCTION = CLEAR LOGIN MODE
	CALL	LKHSPK#			;SEND IT
24$:	JMP	NXTSPR			;THATS ALL
LGIERR:	JMP	BADSPX			;NO-ERROR!



;HERE ON AUX-CIRCUIT BUILDING TIME-OUT

LKHATO::MOV	#DDLHXS#,R0		;POINT TO TABLE IN THE DDB
	MOV	SDDDB#(SD),R4
	ADD	R4,R0
	MOV	#4,R1			;SCAN ALL HOSTS
2$:	CMP	(R0)+,SD		;THIS ONE?
	BEQ	4$			;YES
	SOB	R1,2$			;NO-MORE?
	FSTOP	BAX			;[BAD AUX-CIRCUIT DATA]

4$:	CLR	-(R0)			;CLEAR THE POINTER
	CALL	LKHRPK			;GET A NEW PACKET
	MOV	#.ERTIM,R0		;REPORT TIMEOUT ERROR
	CALL	REFUSE#			;NAK THE CIRCUIT REQUEST
	CJMP	CLRCIR

;TABLE TO TRANSLATE FROM TYMNET ERROR CODES TO NEXILIS ERROR CODES

	PURE

ERCTBL:	.BYTE	0		; 0 - NO ERROR
	.BYTE	.ERFER		; 1 - FORMAT ERROR
	.BYTE	.ERUNE		; 2 - USER NAME ERROR
	.BYTE	.ERMUD		; 3 - MUD ERROR
	.BYTE	.ERHNA		; 4 - SYSTEM UNAVAILABLE
	.BYTE	.ERCRJ		; 5 - COMMAND REJECT
	.BYTE	.ERTIM		; 6 - TIME-OUT
	.BYTE	.ERPRV		; 7 - ACCESS BARRED
	.BYTE	.EROOP		; 8 - OUT OF ORIGINATING PORTS
	.BYTE	.ERAQF		; 9 - REQUEST NOT HONORED (AUX CIRCUIT QUEUE
				;	FULL)
	.BYTE	.ERSPR		;   - UNDEFINED ERROR
ERCMAX=!.-ERCTBL-1

	CODE
.ENDC
	.PAGE
;HERE FOR SUB-TYPE .S5EIL = 11 - EXTERNALLY INITIATED LOGIN
;  THIS MESSAGE IS USED WHEN A CIRCUIT IS BEING BUILT TO THIS NODE FROM TYMNET
;  WHEN THIS MESSAGE IS RECEIVED THE "PERMUTER" TABLES HAVE ALREADY BEEN SETUP
;  AND THE LOGIN STRING HAS BEEN PLACED INTO THE BUFFER USING A TYPE 1 MESSAGE.

.IF EQ ..SAT

LGIEIL:	CMPB	#.S5IIL,R0		;TYPE = .S5IIL?
	BEQ	LGIIIL			;YES
	CMPB	#.S5EIL,R0		;TYPE = .S5EIL?
	BNE	BADS2X			;NO - REPORT ERROR
	BIC	#^C377,SD		;REMOVE JUNK
	CALL	GETSD2			;FIND THE SDB
	BCS	BADS2X			;SHOULD HAVE ONE BY NOW!!
	TST	SDLHLD#(SD)		;ARE LINKED TO A LINE NOW?
	BNE	10$			;YES-GO ON
	CALL	BRKCR2			;NO-GIVE IT ALL UP (MUST BE TRYING TO
					;  BUILD AN INTERNAL CIRCUT)

;	THE FOLLOWING LINE INSERTED TO FIX SOCKETS BUSY...DRE  11/04/80
	CALL	FRESOC#			;FREE UP THE SOCKET
	BR	20$

10$:	MOV	SDLHSC#(SD),R1		;GET SAVED CONNECT PACKET
	BEQ	BADS2X			;SHOULD HAVE ONE!!
	MOV	(R1),SDLHSC#(SD)	;POINT TO LINKED DATA PACKET (IF ANY)
	PUSH	R2			;PRESERVE R2
	PUSH	R3			;AND R3
	PUSH	R1			;SAVE REGISTERS WE WILL USE
	PUSH	R4
	MOVB	SDLHBF#(SD),R0		;GET BUFFER NUMBER
	BIC	#^C300,R0		;GET JUST "HOST SELECT" BITS
	ASHI	-4,R0			;IN THE RIGHT PLACE
	ADD	R0,R4			;FIND THE NAME OF THE DST
	ADD	#DDLHDH#,R4
	ADD	#PKDATA+6,R1		;PLACE TO PUT THE DST
	CALL	RD50XX#			;PUT DST INTO THE CONNECT PACKET
	CALL	RD50XX#
	POP	R4			;RESTORE REGISTERS
	POP	R1
	BISB	#060,PKDATA+35(R1)	;STORE FLAG BITS (INDICATE THAT THE
					;  LOGIN STRING IS AVAILABLE AND THAT
					;  THE PASSWORD HAS BEEN CHECKED)
	MOV	#<13*400+200>,PKDATA(R1);STORE CONNECT HEADER
	MOVB	#377,PKDATA+24(R1)	;STORE PRIV. LEVEL
	MOVB	#4,PKDATA+31(R1)	;STORE PACKET COUNT MAX
	INCB	SDPCNT#(SD)		;AND SEND IT
	CALL	SNDPKT#
	POP	R3			;RESTORE R3
	POP	R2			;AND R2
20$:	JMP	NXTSPR			;THATS ALL

BADS2X:	JMP	BADSPX

.ENDC
	.PAGE
;HERE FOR SUB-TYPE .S5IIL = 12 - INTERNALLY INITIATED LOGIN
;  THIS MESSAGE IS SENT AFTER AN AUX-CIRCUIT HAS BEEN BUILT ON THE CHANNEL
;  WHICH UAS ALLOCATED BY THE SUPERVISOR FOR THE AUX-CIRCUIT.  IT INDICATES THAT
;  THE CIRCUIT HAS BEEN BUILT AND IS NOW USABLE.  IT IS SEND BEFORE
; THE LOGIN TERMINATION (SUBTYPE 5) MESSAGE.

.IF EQ ..SAT

LGIIIL:	PUSH	SD			;SAVE HOST AND PORT NUMBERS
	SWAB	R0			;GET KEY
	MOV	R0,SD
	BIC	#^C377,SD
	CALL	GETSD2			;FIND THE SDB
	POP	R0			;RESTORE PORT NUMBER
	BCS	10$			;FORGET IF NONE!
	BIC	#^C377,R0		;GET JUST PORT NUMBER
	MOVB	R0,SDLHBF#(SD)		;STORE AS BUFFER NUMBER OVER 2
	ADD	DDLHBF#(R4),R0		;INDEX INTO THE HOST BUFFER TABLE
	MOVB	SDSOC#(SD),(R0)		;LINK THE OTHER WAY TOO
	TST	SDLHLD#(SD)		;DO WE HAVE A LINE NOW?
	BNE	10$			;YES-ALL IS JUST FINE
	MOV	#.ERHNA,R0		;NO-MUST BE TRYING TO BUILD INTERNAL
	CALL	MAKKIL#			;  CIRCUIT-FAIL!
	CALL	LKHSPK#
	CALL	BRKCR2
10$:	JMP	NXTSPR			;THATS ALL

.ENDC
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMTOD = 6 - SUPERVISOR TIME-OF-DAY
;	SR2 = (16) TIME HIGH WORD
;	SR3 = (16) TIME LOW WORD

.IF EQ ..SAT

SPRTOD:	SPRWRD	R0			;GET DATA AND STACK IT
	PUSH	R0
	SPRWRD	R0
	PUSH	R0
	MOV	#DDLHSS#,R0		;POINT TO TABLE OF SUPERVISORY SDB'S
	ADD	R4,R0
	MOV	DDLHNH#(R4),R1		;SCAN ONLY THE HOST TABLE ENTRIES THAT EXIST
2$:	MOV	(R0)+,SD		;GET SDB
	BEQ	10$			;IF NONE IN THIS SLOT
	PUSH	R0			;SAVE REGISTERS
	PUSH	R1
	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	6$			;OH WELL-WE TRIED!
	MOV	#.PTFUN*400+6,PKCNT(R1)	;STORE TYPE AND COUNT
	MOV	#.SFTIM*400+.FNDCN,PKDATA(R1);STORE FIRST TWO BYTES
	MOV	6(SP),PKDATA+2(R1)	;STORE FIRST TIME WORD
	MOV	4(SP),PKDATA+4(R1)	;STORE SECOND TIME WORD
	INCB	SDPCNT#(SD)
	CALL	LKHSPK#			;SEND THE PACKET
6$:	POP	R1			;RESTORE REGISTERS
	POP	R0
10$:	TST	(R0)+
	SOB	R1,2$			;CONTINUE IF MORE TO DO
	ADD	#4,SP			;FIX UP THE STACK
	BR	NXTSPR			;FINISHED

.ENDC
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMINV = 7 - INVOICE NUMBER
;	SR2 = (8) PORT NUMBER (8) INVOICE NUMBER HIGH 8 BITS
;	SR3 = (16) INVOICE NUMBER LOW 16 BITS
;
;	THIS IS THE FIRST MESSAGE OF AN EXTERNAL CALL SEQUENCE
;	IF THIS IS A BASE WE ASSIGN AN INDEX IN THE HOST BUFFER TABLE
;	TO CORRESPOND PORT NUMBERS (AND CORRESPONDINGLY, BUFFER NUMBERS)
;	WITH SDBS.

.IF EQ ..SAT

INVOIC:	SPRWRD	SD			;GET PORT AND HIGH BYTE OF INVOICE #
	PUSH	SD			;SAVE FOR LATER
	SWAB	SD			;GET JUST PORT #
	BIC	#^C377,SD
	MOV	#DDLHXP#,R0		;POINT TO TABLE OF AUX-PORTS
	ADD	R4,R0
	MOV	#4,R1			;SET COUNTER TO NUMBER OF PSEUDO PORTS
1$:	CMP	(R0)+,SD		;THIS ONE?
;	BEQ	2$			;YES-IGNORE THIS MESSAGE
	BNE	3$			;NO, CONTINUE SEARCH
2$:	TST	(SP)+			;YES-FIX UP THE STACK
	BR	IGNSP3			;AND IGNORE AUX BUILDING MESSAGE
3$:	SOB	R1,1$			;CONTINUE IF MORE TO CHECK
	ADD	DDLHBF#(R4),SD		;INDEX INTO THE HOST BUFFER TABLE
	TSTB	(SD)			;IS THIS PORT IN USE?
	BEQ	10$			;NO-GO ON
	BISB	(SD),R1			;YES - CHECK FOR SOURCE OR DEST
	ASL	R1			;CONVERT FOR WORD INDEXING
	MOV	-(R1),SD		;GET THE SDB
	TBBN	$H1INC,SDLHS1#(SD),14$	;REJECT MESSAGE IF INCOMING ON EXISTING BUFFER
	BR	2$			;IGNORE MESSAGE ON OUTGOING CALL	


;HERE IF "HOST" PORT IS FREE

10$:	PUSH	SD			;SAVE INDEX INTO BUFFER TABLE
	CALL	GRBSDB#			;GET A SDB (AND SET IN USE)
	BCC	20$			;GO ON IF GOT ONE
	TST	(SP)+			;YES-FIX UP THE STACK
14$:	TST	(SP)+			;YES-FIX UP THE STACK
;	ADD	#4,SP			;OTHERWISE REJECT THE MESSAGE!
	BR	BADSP3

;HERE WITH SDB

20$:	POP	R0			;GET BUFFER TABLE POINTER
	MOVB	SDSOC#(SD),(R0)		;STORE SOCKET NUMBER IN BUFFER TABLE
	SUB	DDLHBF#(R4),R0		;GET "PORT NUMBER" AGAIN
	MOVB	R0,SDLHBF#(SD)		;STORE IN SDB
	MOV	#$H1XD1!$H1INC!$H1PRJ,SDLHS1#(SD);INITIALIZE THE STATUS BITS
	POPB	SDLHVH#(SD)		;STORE HIGH BYTE OF INVOICE NUMBER
	SPRWRD	SDLHVL#(SD)		;GET LOW BYTES OF INVOICE NUMBER
	CLR	SDLHO2#(SD)		;Clear output character count
	CLR	SDLHO1#(SD)
	CLR	SDLHI2#(SD)		;CLEAR INPUT CHARACTER COUNT
	CLR	SDLHI1#(SD)
	CLR	SDLHPC#(SD)		;CLEAR PROJECT CODE BUFFER
	CALL	RPTCN2			;PUT IN TIMER REQUEST
	BR	NXTSPR			;FINISHED

;HERE WHEN TIMER REQUEST FOR ACCOUNTING RUNS OUT

RPTCNT:	MOV	#JIFM10#,R0		;PUT IN A NEW TIMER REQUEST
	MOV	#RPTCN1,R1		;FOR 10 MINUTES FROM NOW
	CJMP	TIMREQ#			;THATS ALL
RPTCN1:	MOV	SDDDB#(SD),R4		;GET ADDRESS OF DDB
	MOV	#.S7OCC*10000,R0	;GET REASON
	CALL	ACOUNT			;TELL THE SUPERVISOR
RPTCN2:	MOV	#JIFM10#,R0		;PUT IN A NEW TIMER REQUEST
	MOV	#RPTCNT,R1		;FOR 10 MINUTES FROM NOW
	CJMP	TIMREQ#			;THATS ALL

.ENDC
	.PAGE
;HERE IF GET BAD MESSAGE FROM THE SUPERVISOR
;	C(R2) = ADDRESS OF NEXT WORD AFTER SR3 WORD IN MESSAGE

BADSPX:	SUB	#2,R2			;FIX UP R2

;HERE IF GET BAD MESSAGE FROM THE SUPERVISOR
;	C(R2) = ADDRESS OF SR3 WORD IN MESSAGE IN FRAME BUFFER

BADSP3:	SUB	#2,R2			;FIX UP R2

;HERE FOR ERROR IF R2 POINTS TO SR2 WORD

BADSPR:	PUSH	#.SMREJ*10000		;SR1 = FUNCTION
	PUSHB	1(R2)			;SR2 = BAD SR2
	MOVB	(R2),1(SP)
	PUSHB	-(R2)			;SR3 = BAD SR1
	MOVB	-(R2),1(SP)
	CALL	SNDSPR			;SEND REJECT TO SUPERVISOR
	PUSH	#.SMREJ*10000		;SR1 = FUNCTION
	PUSHB	5(R2)			;SR2 = BAD SR3
	MOVB	4(R2),1(SP)
	PUSHB	1(R2)			;SR3 = BAD SR1
	MOVB	(R2)+,1(SP)
	CALL	SNDSPR			;SEND REJECT TO SUPERVISOR
	INC	R2			;BUMP POINTER
IGNSPR:	ADD	#2,R2			;BUMP POINTER TO NEXT MESSAGE
IGNSP3:	ADD	#2,R2
					;AND FALL INTO NXTSPR

;HERE WHEN FINISHED WITH A SUPERVISOR MESSAGE

NXTSPR:	SUB	#6,(SP)			;REDUCE CHARACTER COUNT FOR RECORD
	BLE	2$			;IF FINISHED
	JMP	SPRRE1			;IF MORE IN RECORD

2$:	BLT	20$			;IF COUNT WAS BAD!
	TST	(SP)+			;FIX UP THE STACK
	JMP	LKHNXT			;AND GO PROCESS NEXT RECORD

;HERE IF LENGTH OF SUPERVISOR RECORD WAS NOT A MULTIPLE OF 6 CHARACTERS

20$:	MOV	#.EFILS,R0		;ERROR = ILLEGAL LENGTH FOR SUPERVISOR
					;  MESSAGE
					;Fall into BADFRM

;HERE IF FATAL ERROR IN FRAME (BAD CHANNEL NUMBER, BAD COUNT, ETC.)
;	C(R0) = ERROR CODE WORD FOR SR2

BADFR0:	TST	(SP)+			;FIX UP THE STACK
BADFRM::INC	LDERBD#(R3)		;COUNT THE ERROR
	MOV	LDHDDB#(R3),R4		;Get the DDB
	INC	DDERPC#(R4)		;COUNT IT AS A DEVICE ERROR
	PUSH	R0			;SAVE ERROR CODE
	MOV	#100505,R0		;TELL SUP NO GOOD RECORDS FOUND
	CALL	LKHDWN			;TAKE IT DOWN!
	POP	R0			;RESTORE ERROR CODE
	PUSH	#.SMMDR*10000		;SR1
	PUSH	R0			;SR2
	MOVB	LDHLNO#(R3),R0		;GET LINE NUMBER
	PUSH	R0			;SR3
	CALL	SNDSPR			;SEND MESSAGE TO SUPERVISOR
	RETURN				;THATS ALL
	.PAGE
	.SBTTL	SNDDWN - SEND SUPERVISOR MESSAGE DOWN-STREAM

;	PUSH	SR1
;	PUSH	SR2
;	PUSH	SR3
;	CALL	SNDDWN

SNDDWN:	PUSH	R3			;SAVE CURRENT LDB ADDRESS
	MOV	DDLHDW#(R4),R3		;GET DOWN-STREAM LINE
	BR	SNDUP2			;CONTINUE

	.SBTTL	SNDDWN - SEND INTERNODE MESSAGE OVER ARBITRARY LINK

;	MOV	#LDB,R3
;	PUSH	SR1
;	PUSH	SR2
;	PUSH	SR3
;	CALL	SNDLIN

SNDLIN:	PUSH	R3			;SAVE CURRENT LDB ADDRESS
	BR	SNDUP2			;CONTINUE

	.SBTTL	SNDSPR - ORIGINATE SUPERVISOR MESSAGE

;	PUSH	SR1			;C(SR1) = MESSAGE TYPE * 10000
;	PUSH	SR2
;	PUSH	SR3
;	CALL	SNDSPR

SNDSPR::BIS	DDLHNN#(R4),6(SP)	;PUT NODE NUMBER INTO SR1
					;FALL INTO SNDUP

	.SBTTL	SNDUP  - SEND SUPERVISOR MESSAGE UP-STREAM

;	PUSH	SR1
;	PUSH	SR2
;	PUSH	SR3
;	CALL	SNDUP

;SUPERVISOR MESSAGES ARE BUFFERED USING A LIST OF PACKETS FOR EACH T.201 LINE.
;  MESSAGES ARE PACKED 10 PER PACKET.  THE FIRST WORD OF EACH PACKET IS USED AS
;  A LINK WORD, THE SECOND WORD IS UNUSED TO MAKE THE LAST MESSAGE IN THE PACKET
;  ALLIGN WITH THE END OF THE PACKET.  THE FOLLOWING POINTERS ARE USED IN THE
;  LDB:
;	LDHSLH = SUPERVISOR LIST HEAD POINTER (TAKER POINTER)
;	LDHSLT = SUPERVISOR LIST TAIL POINTER (PUTTER POINTER)
;  POINTERS POINT TO THE NEXT 6 BYTE SPACE IN A PACKET.  THE FACT THAT PACKETS
;  ALWAYS BEGIN MODULO 100 IS USED TO DETERMINE WHEN THE END OF A PACKET HAS
;  BEEN REACHED.  WHEN THE LIST IS EMPTY, NO PACKETS ARE ALLOCATED AND THE HEAD
;  AND TAIL POINTERS ARE 0.

SNDUP:	BIS	#100000,6(SP)		;SET UPSTREAM INDICATOR
	PUSH	R3			;SAVE CURRENT LDB ADDRESS
	MOV	DDLHUP#(R4),R3		;POINT TO CURRENT UPSTREAM LINE
SNDUP2:	BEQ	2$			;FORGET IT IF NONE!
	MOV	LDHSLT#(R3),R1		;GET CURRENT POINTER
	BNE	3$			;IF LIST NOT EMPTY
	MOV	#LDHSLH#,R1		;EMPTY-POINT TO HEAD POINTER
	ADD	R3,R1
	BR	4$			;CONTINUE

;HERE IF CANNOT SEND MESSAGE FOR SOME REASON - JUST RETURN WITH NO ERROR
;  INDICATION!!

1$:	TST	(SP)+			;Fix up the stack
2$:	POP	R3			;RESTORE R3
	POP	R0			;GET RETURN ADDRESS
	ADD	#6,SP			;FIX UP THE STACK
	JMP	(R0)			;And return

;HERE IF LIST IS NOT EMPTY

3$:	BIT	#77,R1			;NOT EMPTY-IS CURRENT PACKET FULL?
	BNE	10$			;NO-GO ON
	SUB	#100,R1			;YES-POINT TO START OF PACKET
4$:	PUSH	R1			;SAVE ADDRESS
5$:	MAKPKT	.PLSPR#			;GET ANOTHER PACKET
	BCC	6$			;GO ON IF GOT ONE
	CALL	ZAPBUF#			;NONE AVAILABLE-ZAP A BUFFER!
	  BR	1$			;NOTHING TO ZAP-FORGET IT! (WE TRIED
					;  REAL HARD!)
	BR	5$			;SHOULD HAVE SPACE NOW-TRY AGAIN

;HERE WITH A PACKET

6$:	ADD	#4,R1			;POINT TO FIRST BUFFER
	MOV	R1,@(SP)+		;LINK TO PREVIOUS PACKET
	MOV	R1,LDHSLT#(R3)		;UPDATE TAIL POINTER
10$:	ADD	#6,LDHSLT#(R3)		;BUMP TAIL POINTER
14$:	POP	R3			;RESTORE CURRENT LDB ADDRESS
	POP	R0			;GET RETURN ADDRESS
	ADD	#6,R1			;POINT TO END OF MESSAGE BUFFER
	POP	-(R1)			;STORE MESSAGE IN BUFFER
	POP	-(R1)
	POP	-(R1)
	JMP	(R0)			;RETURN
	.PAGE

	.SBTTL	BRKCIR - BREAK CONNECTION BETWEEN SDB AND LINE

;SUBROUTINE TO BREAK THE CONNECTION BETWEEN A CHANNEL ON A TYMNET LINE AN AN SDB
;	C(R0) = REASON CODE (ONLY IF BASE SUPPORT)
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	BRKCIR

BRKCIR::
.IF EQ ..SAT
	TBBE	$H1AUX!$H1INC,SDLHS1#(SD),CLRCIR;If this connection is from a
						;  terminal
	TBBN	$H1AUX,SDLHS1#(SD),BRKCR4;IF AUX CIRCUIT
	CALL	ACOUNT			;INCOMING CIRCUIT-SEND THE ACCOUNTING
					;  DATA
BRKCR2:	MOV	#RPTCNT,R1		;CLEAR ACCOUNTING TIMER
	CALL	TIMKIL#
	MOV	#RPTCN1,R1		;CLEAR ACCOUNTING TIMER
	CALL	TIMKIL#
BRKCR4:	CLR	SDLHVL#(SD)		;CLEAR THE INVOICE NUMBER
	CLR	SDLHVH#(SD)
	PUSH	#.SMMDR*10000		;SEND MESSAGE TO SUPERVISOR
	PUSH	#100000			;SR2
	CLR	R0			;GET BUFFER NUMBER FOR SR3
	BISB	SDLHBF#(SD),R0
	ASL	R0
	PUSH	R0
	CALL	SNDSPR
.ENDC
CLRCIR::
.IF EQ ..SAT
	CLR	R0
	BISB	SDLHBF#(SD),R0		;GIVE UP THIS BUFFER
	CMP	#377,R0			;IF WE HAVE ONE
	BEQ	7$			;UNUSED - SO DON'T FOUL THINGS UP
	MOVB	#377,SDLHBF#(SD)	;CLEAR BUFFER NUMBER IN SDB
	ADD	DDLHBF#(R4),R0		;POINT TO BUFFER TABLE
	CMPB	SDSOC#(SD),(R0)		;IS IT STILL POINTING TO US
	BNE	7$			;NO - BUT DON`T FOUL THINGS UP  MORE
	CLRB	(R0)			;FREE UP THIS BUFFER
7$:	MOV	SDLHSC#(SD),R1		;ANY PACKETS SAVED?
	BEQ	16$			;NO
	CLR	SDLHSC#(SD)		;YES-CLEAR POINTER
12$:	PUSH	(R1)			;SAVE NEXT ONE
	FREPKT				;GIVE UP THIS ONE
	POP	R1			;GET NEXT
	BNE	12$			;IF MORE
.ENDC
16$:	PUSH	R3			;Save current LDB
	MOV	SDLHLD#(SD),R3		;Get LDB for this socket
	BNE	20$			;Go on if have one
	CMP	#-1,SDLKLK#(SD)		;None-make sure not in send list!
	BEQ	34$			;OK
	FSTOP	BSL			;[Bad Send List]

20$:	CLR	SDLHLD#(SD)		;UNLINK
	MOVB	SDLHCN#(SD),R0		;GET CHANNEL NUMBER
	ASL	R0			;FIND ADDRESS OF LINK TO SDB
	ADD	LDHSDB#(R3),R0
	CMP	(R0),SD			;FOR DEBUGGING!
	BEQ	22$
	FSTOP	ISD			;[Incorrect SDB Address]

22$:	CLR	(R0)			;UNLINK
	CMP	#-1,SDLKLK#(SD)		;IS THIS SDB IN THE SEND LIST?
	BEQ	34$			;NO-FINISHED
	PUSH	R2			;YES-FREE UP ANOTHER AC
	MOV	#LDHXLH#,R0		;MAKE DUMMY PRED. POINTER
	SUB	#SDLKLK#,R0
	ADD	R3,R0
25$:	MOV	SDLKLK#(R0),R2		;GET NEXT IN LIST
	CMP	R2,SD			;THIS ONE?
	BEQ	26$			;YES
	MOV	R2,R0			;NO-CONTINUE SEARCHING
	BNE	25$			;IT MUST BE ON THE LIST!!
	FSTOP	BSL			;[BAD SEND LIST]

26$:	MOV	SDLKLK#(SD),SDLKLK#(R0)	;REMOVE FROM LIST
	BNE	30$			;GO ON IF THIS WAS NOT LAST IN LIST
	TST	LDHXLH#(R3)		;LAST-WAS IT THE ONLY ONE?
	BNE	27$			;NO
	CLR	R0			;YES-CLEAR POINTER
27$:	MOV	R0,LDHXLT#(R3)		;UPDATE TAIL POINTER
30$:	MOV	#-1,SDLKLK#(SD)
	POP	R2			;RESTORE R2
34$:	CLR	SDLHS1#(SD)		;CLEAR THE SOCKET STATUS WORD
	POP	R3			;Restore LDB address
	MOV	(SP),SDDBUG#(SD)	;Save return address to help find *'s
	RETURN				;FINISHED
	.PAGE
	.SBTTL	ACOUNT - SEND ACCOUNTING DATA TO SUPERVISOR

;SUBROUTINE TO SEND ACCOUNTING MESSAGES TO SUPERVISOR TO REPORT CHARACTER COUNTS
;	C(R0) = REASON CODE
;	CALL	ACOUNT

.IF EQ ..SAT

ACOUNT:;	TST	DDLHUP#(R4)		;Do we have an upstream line?
;	BEQ	2$			;No-forget this stuff!
	PUSH	R0			;SAVE REASON
	CALL	SPRINV			;SEND INVOICE NO# IF NECESSARY
	 BR	 10$			;CONDITIONS FOR SENDING REST OF ACCOUNTING NOT RIGHT
;	MOV	SDLHVH#(SD),R0		;GET HIGH PART OF INVOICE NUMBER
;	BNE	4$			;GO ON IF NON-ZERO
;	TST	SDLHVL#(SD)		;ZERO-IS IT ALL ZERO?
;	BNE	4$			;NO-GO ON
;	TST	(SP)+			;YES-FIX UP THE STACK
;2$:	RETURN				;AND FORGET ABOUT THIS!

;HERE IF HAVE NON-ZERO INVOICE NUMBER

;4$:	PUSH	#.SMACC*10000		;SR1
;	BIC	#177400,R0		;CLEAR UPPER BYTE
;	BIS	#.S7INV*10000,R0	;PUT IN MESSAGE SUB-TYPE
;	PUSH	R0			;SR2
;	PUSH	SDLHVL#(SD)		;SR3
;	CALL	SNDSPR			;SEND INVOICE NUMBER TO SUPERVISOR
	PUSH	#.SMACC*10000		;SR1
	MOV	SDLHI2#(SD),R0		;GET HIGH PART OF INPUT CHARACTER COUNT
	BIC	#170000,R0
	BIS	#.S7ICC*10000,R0	;PUT IN MESSAGE SUB-TYPE
	PUSH	R0			;SR2
	PUSH	SDLHI1#(SD)		;SR3
	CALL	SNDSPR			;SEND INPUT CHARACTER COUNT TO SPR
	MOV	SDLHO2#(SD),R0		;GET HIGH PART OF OUTPUT CHARACTER COUNT
	BIC	#170000,R0
	BIS	(SP),R0			;PUT IN MESSAGE SUB-TYPE
	MOV	#.SMACC*10000,(SP)	;SR1
	PUSH	R0			;SR2
	PUSH	SDLHO1#(SD)		;SR3
	CALL	SNDSPR			;SEND OUTPUT CHARACTER COUNT TO SPR
	RETURN				;!!! DO NOT CHANGE TO CJMP !!!
10$:	TST	(SP)+			;YES-FIX UP THE STACK
	RETURN				;AND FORGET ABOUT THIS!

;SEND INVOICE NUMBER TO SUP ACCOUNTING

SPRINV:: TST	DDLHUP#(R4)		;Do we have an upstream line?
	BEQ	2$			;No-forget this stuff!
	MOV	SDLHVH#(SD),R0		;GET HIGH PART OF INVOICE NUMBER
	BNE	4$			;GO ON IF NON-ZERO
	TST	SDLHVL#(SD)		;ZERO-IS IT ALL ZERO?
	BNE	4$			;NO-GO ON
2$:	RETURN				;AND FORGET ABOUT THIS!

;HERE IF HAVE NON-ZERO INVOICE NUMBER

4$:	CMP	R0,DDLHVH#(R4)		;IS THIS THE PREVIOUS INVOICE NUMBER SENT?
	BNE	6$			;NO
	CMP	SDLHVL#(SD),DDLHVL#(R4)	;MAYBE - IS THE PART THE SAME
	BEQ	10$			;YES, SKIP SENDING INVOICE AGAIN
6$:	MOV	R0,DDLHVH#(R4)		;INDICATE THIS WAS THE LAST INVOICE SENT
	MOV	SDLHVL#(SD),DDLHVL#(R4)
	PUSH	#.SMACC*10000		;SEND TYPE 7 ACOUNTING MESSAGE AS SR1
	BIC	#177400,R0		;CLEAR UPPER BYTE
	BIS	#.S7INV*10000,R0	;PUT IN INVOICE MESSAGE SUB-TYPE
	PUSH	R0			;SR2 (UPPER 16 BITS OF INVOICE)
	PUSH	SDLHVL#(SD)		;SR3
	CALL	SNDSPR			;SEND INVOICE NUMBER TO SUPERVISOR
10$:	ADD	#2,(SP)			;SUCCESS RETURN
	RETURN
.ENDC
	.PAGE
	.SBTTL	CLRSPR - CLEAR SUPERVISOR MESSAGE LIST FOR LINE

;SUBROUTINE TO CLEAR OUT THE SUPERVISOR MESSAGE LIST FOR A LINE
;	C(R3) = ADDRESS OF LDB
;	C(R4) = ADDRESS OF DDB
;	CALL	CLRSPR

CLRSPR:	MOV	LDHSLH#(R3),R1		;GET HEAD POINTER
	BEQ	RTN012			;NOTHING TO DO IF LIST IS EMPTY
2$:	BIC	#77,R1			;POINT TO BEGINNING OF PACKET
	PUSH	(R1)			;SAVE LINK
	FREPKT				;GIVE UP THE PACKET
	POP	R1			;GET NEXT PACKET
	BNE	2$			;CONTINUE IF MORE TO GIVE UP
	CLR	LDHSLH#(R3)		;FINISHED-CLEAR HEAD AND TAIL POINTERS
	CLR	LDHSLT#(R3)
RTN012:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	QUEZAP - QUEUE REQUEST FOR CIRCUIT ZAPPER

;SUBROUTINE TO QUEUE A CIRCUIT ZAPPER FOR A CHANNEL NOT ASSOCIATED WITH A SDB
;	C(R0) = CHANNEL NUMBER
;	C(R3) = ADDRESS OF LDB
;	CALL	QUEZAP
;  R2 IS DESTROYED
.IF NE	0
QUEZAP:	ASL	R0			;GET CHANNEL * 2
	MOV	LDHZLT#(R3),R2		;LIST ENTRIES ARE CHANNEL*2+1 AND ARE
	BEQ	4$			;  LINKED THRU THE LDHSDB TABLE
	ADD	LDHSDB#(R3),R2
	MOV	R0,(R2)
	INC	(R2)
	BR	5$

4$:	MOV	R0,LDHZLH#(R3)
5$:	MOV	R0,LDHZLT#(R3)
	RETURN
.ENDC

;Subroutine to get reserve packet
;	CALL	LKHRPK
;	C(R1) = Address of packeet

LKHRPK:	MOV	LKHPPK,R1		;Get address of reserve packet
	BNE	4$			;OK if have one
	FSTOP	NRP			;[No Reserve Packet] This should never
					;  happen since this routine is never
					;  called more than once for each
					;  supervisor record!

4$:	CLR	LKHPPK			;Clear pointer
	RETURN				;And return
	.PAGE
	.SBTTL	PUTNUM - PUT OCTAL NUMBER INTO PACKET AS STRING

;SUBROUTINE TO CONVERT OCTAL NUMBER TO STRING AND STORE STRING IN A PACKET
;	C(R0) = NUMBER TO CONVERT LEFT JUSTIFIED
;	C(R1) = ADDRESS OF START OF PACKET
;	C(R3) = NUMBER OF CHARACTERS TO CONVERTS
;	C(R4) = POINTER FOR STORING CHARACTERS
;	CALL	PUTNUM
;	C(R4) = UPDATED POINTER

PUTNUM:	ROL	R0			;GET HIGH ORDER BIT INTO C
4$:	ROL	R0			;GET NEXT OCTAL DIGIT IN LOW 3 BITS
	ROL	R0
	ROL	R0
	BIT	#7,R0			;IS IT NON-0?
	BNE	6$			;YES-GO ON
	SOB	R3,4$			;NO-CONTINUE IF NOT LAST DIGIT
6$:	MOVB	R0,(R4)			;STORE DIGIT
	BICB	#370,(R4)		;CHANGE INTO ASCII NUMBER
	BISB	#'0,(R4)+
	ROL	R0			;GET NEXT DIGIT
	ROL	R0
	ROL	R0
	DEC	R3			;MORE TO DO?
	BGT	6$			;YES-CONTINUE
	RETURN				;FINISHED
	.PAGE
	.SBTTL	GETSDB - FIND SDB

;THIS SUBROUTINE IS CALLED BY THE ROUTINES WHICH PROCESS SUPERVISOR MESSAGES
;  WHICH INSERT DATA CHARACTERS INTO A BUFFER
;	C(SD) = BUFFER NUMBER
;	CALL	GETSDB
;	C:SET = ERROR (BAD BUFFER NUMBER, SDB NOT CONNECTED, ETC.)
;	C(SD) = ADDRESS OF SDB
;  ALL REGISTERS EXCEPT SD ARE PRESERVED

GETSDB:	ASR	SD			;GET "PORT" NUMBER
GETSD2:

.IF EQ ..SAT
;IF WE HAVE BASE SUPPORT THERE IS A TABLE (WHOSE ADDRESS IS IN DDLHBF) WHICH
;  IS INDEXED BY BUFFER NUMBER OVER 2 WHICH CONTAINS THE SOCKET NUMBER WHICH
;  CORRESPONDS TO THE BUFFER.  THIS CORRESPONDENCE MUST BE DYNAMIC SINCE
;  BUFFERS ARE ALLOCATED BY THIS ROUTINE WHEN A CONNECTION IS FROM A TERMINAL
;  AND BY TYMNET WHEN A CONNECTION IS FOR AN "AUX-CIRCUIT" AND WHEN A
;  CONNECTION IS FROM TYMNET.

	ADD	DDLHBF#(R4),SD		;INDEX INTO BUFFER TABLE
	MOVB	(SD),SD			;GET CORRESPONDING SOCKET NUMBER
	BEQ	10$			;ERROR IF NONE ASSIGNED
	BIC	#^C377,SD

.IFF
;IF WE DO NOT HAVE BASE SUPPORT ONLY THIS MODULE ALLOCATES BUFFER NUMBERS.
;  IN CASE WE JUST USE 2 TIMES THE SOCKET NUMBER AS THE BUFFER NUMBER AND
;  NO BUFFER TABLE IS NEEDED.

	CMPB	SD,DDSOC#(R4)		;LEGAL SOCKET NUMBER?
	BHI	10$			;NO

.ENDC
	ASL	SD			;ADJUST FOR WORD INDEXING
	ADD	DDSX#(R4),SD		;FIND SDB
	MOV	-(SD),SD
	RETURN				;RETURN

;HERE IF ERROR

10$:	SEC				;INDICATE ERROR
	RETURN				;AND RETURN
	.PAGE
	.SBTTL	LKHUP  - UP A TYMSHARE LINK

LKHUP::	BIC	#$L1DWN,LDHST1#(R3)	;INDICATE LINE IS UP NOW
	BIC	#$D1DWN,DDSTS1#(R4)	;INDICATE DEVICE IS UP (SORT OF)
	MOV	LDHDDB#(R3),R4		;Get address of DDB
	INCB	DDLHNU#(R4)		;INCREASE COUNT OF UP LINES
	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LKHDWN - DOWN A TYMSHARE LINK

;THIS SUBROUTINE DOES MUCH THE SAME THING AS LNKDWN IN LNK BUT CANNOT USE LNKDWN
;  SINCE IT WOULD DOWN THE ENTIRE LINK - HERE WE JUST WANT TO KILL THOSE
;  CONNECTIONS ASSOCATIATED WITH ONE OF OUR LINES
;
;	C(R0) = Error code
;		a) 1ccc05 , where ccc is an error code for line down
;		b) 100c04, where c is a line speed code as in report line speeds
;			(c is inserted by this routine)
;	C(R3) = Address of LDB for line
;	CALL	LKHDWN

LKHDWN:: PUSH	R0			;Save error code
	MOV	LDHDDB#(R3),R4		;Get address of DDB
	CALL	CLRSPR			;Clear the supervisor list for this line
	CMP	DDLHUP#(R4),R3		;Was this the upstream line?
	BNE	5$			;No
	CLR	DDLHUP#(R4)		;Yes-don't have an upstream line now!
	CLRB	DDLHSN#(R4)
	CALL	CLRSUP			;Clean up any connection waiting for the
					;  supervisor and tell other neighbors
	BR	6$			;Finish up
5$:	MOV	(SP),R0			;Get the error code
	BIT	#77002,R0		;Check for any junk bits
	BNE	56$			;Must not have a valid reason
	PUSH	#.SMMDR*10000		;SR1
	BIT	#1,R0			;Line reset or line out?
	BNE	55$			;Line out message
	MOV	LDHSPD#(R3),R1		;Get line speed code
	ASHI	6,R1			;Position speed code
	BIS	R1,R0			;Insert speed code
55$:	PUSH	R0			;Insert message
	MOVB	LDHLNO#(R3),R0		;Get line number
	PUSH	R0
	CALL	SNDSPR			;Send off to the sup
56$:	CMP	DDLHDW#(R4),R3		;Was this the downstream line?
	BNE	6$			;No
	CLR	DDLHDW#(R4)		;Yes-don't have a downstream line now!
6$:	CLR	LDHZLH#(R3)		;Clear the zap list head and tail
	CLR	LDHZLT#(R3)		;  pointers
	POP	R0			;Clean up stack
.PAGE
;Now disconnect all circuits using this line

	MOV	LDHSDB#(R3),R0		;Point to SDB list
	PUSHB	LDHCHN#(R3)		;Get number of lines
10$:	MOV	(R0),SD			;Get SDB
	BEQ	20$			;Go on if none
	BIT	#1,SD			;Really a SDB?
	BNE	20$			;No
	PUSH	R0			;Yes-save pointer
.IF EQ ..SAT
	MOV	#.S7OCU*10000!.ERSPR,R0	;Get reason for zap
.IFF
	CLR	R0
.ENDC
	CALL	KILSUB			;Kill the connection
	POP	R0
20$:	CLR	(R0)+			;Make sure SDB table entry is clear
	DECB	(SP)			;More to do?
	BNE	10$			;Yes-continue
	TST	(SP)+			;No-fix up the stack
	TBBN	$L1DWN,LDHST1#(R3),30$	;Already flaged as down?
	BIS	#$L1DWN,LDHST1#(R3)	;No - indicate this line is down
	MOV	LDHDDB#(R3),R4		;Get address of DDB
	DECB	DDLHNU#(R4)		;Reduce count of up lines
	BGT	30$			;Go on if still have line(s) up
	BIS	#$D1DWN,DDSTS1#(R4)	;Declare the device to be down
	CLRB	DDLHNU#(R4)		;Just to be safe!!
30$:	CJMP	@LDHDWX#(R3)		;Return thru the frame level routine


;Subroutine called from LKHDWN to kill a connection
;	C(R0) = Supervisor message type + Nexilis error code
;	CALL	KILSUB

KILSUB:	PUSH	R1			;Respect R1
	PUSH	R0			;Save Nexilis error code
	BIC	#377,R0			;Remove junk
	CALL	BRKCIR			;Break the circuit to Tymnet
	POPB	R0			;Restore Nexilis error code
	CALL	MAKKIL#			;Make a Kill packet
	CALL	LKHSPK#			;Send the kill packet
	POP	R1			;Restore R1
	RETURN				;And return
	.PAGE
	.SBTTL	Data

;Impure data

	IMPURE
	.EVEN

REQCNT:	.WORD	0		;REQUEST COUNTER
LKHPPK:	.WORD	0		;Address of reserve packet

;Pure data

	PURE
	.EVEN			;Make sure its even!!!

	.END

  @
&