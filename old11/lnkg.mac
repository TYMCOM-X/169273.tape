.TITLE	LNKG		- Link type G (SNAP protocol on DUV-11/DUP-11)
.SBTTL	LNKG		- Definitions

	XLPAR				; Don't list parameter file

;-----
; Macro to return from interrupt (RTI) after restoring R0 and R4
;-----
.MACRO	RTI04
	MOV	(SP)+,R0
	MOV	(SP)+,R4
	RTI
.ENDM

;-----
; Bit assignments for general use
;-----
$BIT00	=! ^B0000000000000001
$BIT01	=! ^B0000000000000010
$BIT02	=! ^B0000000000000100
$BIT03	=! ^B0000000000001000
$BIT04	=! ^B0000000000010000
$BIT05	=! ^B0000000000100000
$BIT06	=! ^B0000000001000000
$BIT07	=! ^B0000000010000000
$BIT08	=! ^B0000000100000000
$BIT09	=! ^B0000001000000000
$BIT10	=! ^B0000010000000000
$BIT11	=! ^B0000100000000000
$BIT12	=! ^B0001000000000000
$BIT13	=! ^B0010000000000000
$BIT14	=! ^B0100000000000000
$BIT15	=! ^B1000000000000000

;-----
; Flags (in DDLGFG field of DDB - link type G flag word)
;-----
$DLE	=! $BIT00			; DLE seen (for input DLE sequences)
$CRC	=! $BIT01			; Reading the 2 CRC bytes
$REJ	=! $BIT02			; Input is in reject condition
$CMDR	=! $BIT03			; CMDR condition exists on this side
$TIMER	=! $BIT04			; Time-out recovery is in progress
$IBUSY	=! $BIT05			; This side of link is busy
$OBUSY	=! $BIT06			; Other end of link is busy
$ABORT	=! $BIT07			; Abort this output frame
$ICPF	=! $BIT08			; Poll bit was set on input command
$OCPF	=! $BIT09			; Final bit should be set in output cmd
$FRXMT	=! $BIT10			; This output frame is retransmission
$REXMT	=! $BIT11			; Retransmit 1st frame on transmit ring
$RR	=! $BIT12			; Pending RR response for info frame
$SYNCH	=! $BIT13			; Need to synchronize link
$SARM1	=! $BIT14			; Sending first SARM
$DISC1	=! $BIT15			; Sending first DISC

;-----
; Flags (in DDLGF2 field of DDB - link type G 2nd flag word
;-----
$IRMA	=! $BIT11			; IRMA timer flag for lost interrupts
$RUA	=! $BIT12			; Link needs to receive UA for SARM
$XUA	=! $BIT13			; Link needs to send UA to SARM
$RESET	=! $BIT14			; Link has been reset after cold start
$RDISC	=! $BIT15			; Resetting link with DISC (not SARM)

;-----
; Bit test and set values
;-----
$INFO	=! $BIT00			; Bit 0 of frame control byte
$SUPV	=! $BIT01			; Bit 1 of frame control byte
$PFBIT	=! $BIT04			; Bit 4 of frame control byte

$RSTRP	=! $BIT08			; Receiver control strip synch bit
$RSRCH	=! $BIT04			; Receiver control search for synch bit

$XSMSG	=! $BIT08			; Transmitter data start of message bit
$XMSTR	=! $BIT08			; Transmitter control master reset bit
$XSEND	=! $BIT04			; Transmitter control send bit

;-----
; Constants - base for modulus arithmetic
;-----
.MODN	=! 10				; Modulus (base) for arithmetic on
					;   V(R), V(S), N(R), N(S)
;-----
; Bit masks
;-----
$MASKN	=! ^C<.MODN-1>			; Bit clear mask for isolating (e.g.
					;   performing modulus arithmetic on)
					;   V(R), V(S), N(R), N(S)
;-----
; Constants - initialization values for the device registers
;-----
.PRDUV	=! <3*$BIT12>!<3*$BIT10>!SYN	; DUV-11 parameter reg initial value:
					;   Intern synch, 8-bit, SYN synch
.PRDUP	=! $BIT15!$BIT09!SYN		; DUP-11 parameter reg initial value:
					;   DEC mode, CRC inhib, SYN synch
.RINIT	=! $BIT08!$BIT06!$BIT04!$BIT02!$BIT01 ; Receiver cntl reg init value:
					;   Strip synch, Rec int enable, Search
					;   synch, Req to send, Data term rdy
.XINIT	=! $BIT06			; Xmitter control reg initial value:
					;   Xmit int enable
;-----
; Constants - timer duration values
;-----
.T3	=! 10.				; Idle output RR frame timer duration
.T4	=! 60.				; Reject condition timer duration
.T5	=! 60.				; Command reject timer duration
.T6	=! 60.				; Idle input take-dowm timer duration

;-----
; Constants - shift counts
;-----
.SHFNR	=! 5				; Shift count to right justify N(R)

;-----
; Constants - frame control byte values
;-----
.SARM	=! 17				; Set Asynchronous Response Mode cmd
.DISC	=! 103				; DISConnect command
.UA	=! 143				; Unnumbered Acknowledge response
.CMDR	=! 207				; CoMmanD Reject response

.RR	=! 1				; Receive Ready supervisory response
.RNR	=! 5				; Receive Not Ready supv response
.REJ	=! 11				; REJect supervisory response

;-----
; Constants - input detected error status values
;-----
ER.IGN	=! 0				; Return after discarding frame
ER.OVF	=! 2				; Frame overflow
ER.UND	=! 4				; Frame underflow
ER.IVF	=! 6				; Invalid frame format
ER.INR	=! 10				; Invalid N(R)
ER.NIA	=! 12				; No info field allowed
ER.STO	=! 14				; Start output after dicarding frame
ER.RST	=! 16				; Reset link after discarding frame

;-----
; Constants - CMDR (CoMmanD Reject response) reasons
;-----
.CRSNW	=! $BIT03			; CMDR reason W (invalid control byte)
.CRSNX	=! $BIT02			; CMDR reason X (info fld not allowed)
.CRSNY	=! $BIT01			; CMDR reason Y (frame overflow)
.CRSNZ	=! $BIT00			; CMDR reason Z (invalid N(R))

;-----
; Constants - size parameters
;-----
.P1MAX	=! PKCMAX+3			; Maximum # bytes in 1st info field pkt

.SHSYN	=! 3				; # synch bytes for short frame synch
.LNSYN	=! 12.				; # synch bytes for long synch (init,
					;   reset link)
.NPADS	=! 4				; # of pad bytes at end of frame

;---------------------------------------;
.IF NE ..BUG				;
					;
	IMPURE				;
LKGPUT::.WORD	0			;
LKGRNG::.BLKW	100			;
LKGEOR:					;
					;
.ENDC					;
;---------------------------------------;
	CODE
.PAGE
.SBTTL	LNKG   - LKGISV	- Input interrupt handler
;-----
; LKGISV - Processes input interrupts from the DUV-11/DUP-11 interface
;
; The following code has been executed to get here:
;	<input ready interrupt>
;	PUSH	R4			; Save R4
;	MOV	<address of DDB>,R4	; R4 --> DDB of link needing service
;	JMP	LKGISV			; Go to common input interrupt routine
;-----
LKGISV::PUSH	R0			; Save R0
	MOV	@DDLGRB#(R4),R0		; Get byte from interface
	BPL	1$			; If no error, process  byte
	INC	DDEROR#(R4)		; Bump overrun error count
	BR	IABORT			; Might as well abort this input frame

1$:	BIC	#$RSTRP,@DDLGRS#(R4)	; Clear device strip synch

	TBBN	$CRC,DDLGFG#(R4),ICCRC	; CRC bytes always computed into CRC
	TBBN	$DLE,DDLGFG#(R4),LKGIS1	; If DLE seen flag set, check DLE seq.

	CMPB	R0,#DLE			; This byte == DLE?
	BNE	ICCRC			; No - go calculate CRC-16 for byte
	BIS	#$DLE,DDLGFG#(R4)	; Yes - set DLE seen flag
	RTI04				; Return from interrupt
;-----
; Here to check for <DLE><STX>
;-----
LKGIS1:	BIC	#$DLE,DDLGFG#(R4)	; Clear DLE seen flag
	CMPB	R0,#STX			; Byte == STX?
	BNE	LKGIS2			; No

	TST	DDLGIF#(R4)		; In middle of previous frame?
	BEQ	1$			; No

	INC	DDERCS#(R4)		; Yes - bump checksum error count
	BR	IABOR1			; Discard frame info field

1$:	CLR	DDLGCI#(R4)		; Clear input CRC
	MOVB	DDLGK3#(R4),DDLGIK#(R4)	; Set frame byte count to maximum
	MOVB	#ER.UND,DDLGIZ#(R4)	; Init input status to underflow
	MOV	#IADDR,DDLGIS#(R4)	; Input state <-- frame address byte
	RTI04				; Return from interrupt
;-----
; Here to check for <DLE><ETX>
;-----
LKGIS2:	TST	DDLGIS#(R4)		; Input active?
	BEQ	ISPURI			; No - spurious interrupt

	CMPB	R0,#ETX			; Byte == ETX?
	BNE	LKGIS3			; No - bypass
	MOV	#IENDTR,DDLGIS#(R4)	; Input state <-- end transparency
	BR	ICCRC			; Go calculate CRC
;-----
; Here to check for <DLE><SYN>, <DLE><DLE>, and frame abort (<DLE><???>)
;-----
LKGIS3:	CMPB	R0,#SYN			; Byte == SYN?
	BEQ	RTI000			; Yes - ignore it
	CMPB	R0,#DLE			; Byte == DLE?
	BNE	IABORT			; No - abort flag - abort frame
;-----
; Here to calculate partial CRC-16 for input byte
;-----
ICCRC:	TST	DDLGIS#(R4)		; Input active?
	BEQ	ISPURI			; No - spurious interrupt

	PUSH	R0			; Save registers
	PUSH	R1

	MOV	DDLGCI#(R4),R1		; Get old partial CRC
	XOR	R1,R0			; XOR old CRC and new byte
	BIC	#177400,R0		; Clear high byte
	ASL	R0			; Convert to word index
	MOV	CRCTAB#(R0),R0		; Get modifier word
	CLRB	R1			; Clear low byte of old CRC
	SWAB	R1			; Move high byte of old CRC to low
	XOR	R0,R1			; XOR modifier and old CRC
	MOV	R1,DDLGCI#(R4)		; Save new partial CRC

	POP	R1			; Restore registers
	POP	R0

	JMP	@DDLGIS#(R4)		; Dispatch to correct input state

;-----
; Here on unexpected interrupt when input is idle (spurious interrupt)
;-----
ISPURI:	INC	DDERSI#(R4)		; Bump spurious interrupt count

;-----
; Here to abort input frame
;-----
IABORT:	TST	DDLGIF#(R4)		; Information field?
	BEQ	ISYNCH			; If no info field, search for synch

IABOR1:	PUSH	R1			; Save R1
	MOV	DDLGIF#(R4),R1		; Get 1st packet address
	CLR	DDLGIF#(R4)		; Clear packet list header

1$:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	1$			; Continue until whole list freed

	POP	R1			; Restore R1

;-----
; Here to establish character synchronization over the link
;-----
ISYNCH:	BIC	#$RSRCH,@DDLGRS#(R4)	; Clear receiver search synch bit
	BIS	#<$RSRCH!$RSTRP>,@DDLGRS#(R4) ; Set synch search & strip synch
	CLR	DDLGIS#(R4)		; Clear input state (go idle)
	BIC	#<$DLE!$CRC>,DDLGFG#(R4); Clear frame transparency flags

;-----
; Here to return from interrupt level
;-----
RTI000:	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Protocol input states - frame address & control bytes
;-----
; Here on frame address byte input
;-----
IADDR:	MOV	#ICNTL,DDLGIS#(R4)	; Input state <-- frame control byte
	MOVB	R0,DDLGIA#(R4)		; Save the address byte
	RTI04				; Return from interrupt

;-----
; Here on frame control byte input
;-----
ICNTL:	MOV	#IINF0,DDLGIS#(R4)	; Input state <-- 1st byte of info fld
	MOVB	R0,DDLGIX#(R4)		; Save control byte
	CLRB	DDLGIZ#(R4)		; Frame format OK so far
	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Protocol input states - frame information field
;-----
; Here on first byte of information field
;-----
IINF0:	MOV	#IINFO,DDLGIS#(R4)	; Input state <-- rest of info field
	MOV	#DDLGIF#,DDLGIP#(R4)	; Let new packet code set 1st pkt ptr
	ADD	R4,DDLGIP#(R4)		;   by setting "link" of current to 1st
	MOV	#PKTYPE,DDLGIB#(R4)	; Start putting bytes into pkt type
	MOVB	#.P1MAX,DDLGIC#(R4)	; 1st pkt has more bytes (incl. header)
	BR	INEWP1			; Merge with new packet code

;-----
; Here to get a new packet for additional information field bytes
;-----
INEWPK:	MOV	#PKDATA,DDLGIB#(R4)	; Start putting bytes into pkt data
	MOVB	#PKCMAX,DDLGIC#(R4)	; Init packet byte counter

INEWP1:	PUSH	R1			; Save R1
	MAKPKT	.PLSTP#			; Get a free packet
	BCC	INEWP2			; Got a packet ==> go initialize it
;-----
; No packets available for frame information field bytes
;-----
IBUSY:	INC	DDERNP#(R4)		; Bump "No Packets Available" count
	BR	IABORT			; Go clean up & re-synch the interface

;-----
; Here to initialize new packet for information field bytes
;-----
INEWP2:	MOV	R1,@DDLGIP#(R4)		; Set link to new packet
	MOV	R1,DDLGIP#(R4)		; Save link to new current packet
	ADD	R1,DDLGIB#(R4)		; Init packet byte pointer
	MOVB	#PKCMAX,PKCNT(R1)	; Set full packet count
	CLRB	PKTYPE(R1)		; Clear packet type
	CLRB	PKSOC(R1)		; Clear packet socket number
	CLRB	PKSEQ(R1)		; Clear packet sequence number
	POP	R1			; Restore R1

;-----
; Here to input a byte of the information field
;-----
IINFO:	TSTB	DDLGIK#(R4)		; Check frame byte count
	BNE	1$			; Still room left - stuff byte

	MOVB	#ER.OVF,DDLGIZ#(R4)	; Frame status <-- overflow
	BR	IABORT			; Go clean up & re-synch the interface

1$:	TSTB	DDLGIC#(R4)		; Check packet byte count
	BEQ	INEWPK			; Packet full ==> get new packet

	MOVB	R0,@DDLGIB#(R4)		; Put byte into packet
	INC	DDLGIB#(R4)		; Bump byte pointer
	DECB	DDLGIK#(R4)		; Bump frame byte count
	DECB	DDLGIC#(R4)		; Bump packet byte count
	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Protocol input states - end frame & verify CRC
;-----
; Here to end transparency
;-----
IENDTR:	MOV	#ICRC1,DDLGIS#(R4)	; Input state <-- CRC byte 1
	BIS	#$CRC,DDLGFG#(R4)	; Next bytes are CRC bytes
	TST	DDLGIF#(R4)		; Information field?
	BEQ	1$			; If no info field, return (RTI)

	CLR	R0			; Clear residue in register
	BISB	DDLGIC#(R4),R0		; Get # of bytes until packet full
	NEG	R0			; Negate # bytes until full
	ADD	#PKCMAX,R0		; PKCMAX-(#bytes until full)=#bytes
	ADD	#PKCNT,DDLGIP#(R4)	; Point pkt ptr at PKCNT to store count
	MOVB	R0,@DDLGIP#(R4)		; Store packet byte counter in packet
1$:	RTI04				; Return from interrupt

;-----
; Here on CRC byte 1
;-----
ICRC1:	MOV	#ICRC2,DDLGIS#(R4)	; Input state <-- CRC byte 2
	RTI04				; Return from interrupt

;-----
; Here on CRC byte 2 - end frame, verify, and send to main if CRC ok
;-----
ICRC2:	BIC	#$CRC,DDLGFG#(R4)	; Got 2nd CRC byte
	TST	DDLGCI#(R4)		; Input CRC result == 0?
	BEQ	IMSEND			; Yes - frame assumed to be good
	INC	DDERCS#(R4)		; Bump checksum error count (CRC error)
	JMP	IABORT			; CRC result non-zero ==> discard frame

;-----
; Here to insert frame into input-to-main ring
;-----
IMSEND:	MOV	DDLGQP#(R4),R0		; Get input done ring putter
	MOV	DDLGIF#(R4),(R0)+	; Store info field packet list header
	MOVB	DDLGIX#(R4),(R0)+	; Store frame control byte
	MOVB	DDLGIZ#(R4),(R0)+	; Store input to main status byte
	CMP	R0,DDLGQE#(R4)		; End of ring?
	BLO	1$			; No
	MOV	DDLGQB#(R4),R0		; Yes - reset putter to start of ring
1$:	CMP	R0,DDLGQT#(R4)		; Ring full?
	BNE	2$			; No - go resynch device
	INC	DDEROR#(R4)		; Yes - bump overrun error count
	JMP	IABORT			; Throw this frame away

2$:	MOV	R0,DDLGQP#(R4)		; Update ring putter

;---------------------------------------;
.IF NE ..BUG				;
					;
	MOV	LKGPUT,R0		; Get debug ring putter
	MOVB	DDLGIX#(R4),(R0)+	; Save input control byte
	MOVB	#-1,(R0)+		; Flag as input byte
	MOV	UPTIME#,(R0)+		; Store uptime timer
	CMP	R0,#LKGEOR		; End of ring?
	BLO	47$			; No
	MOV	#LKGRNG,R0		; Yes
47$:	MOV	R0,LKGPUT		; Update putter
					;
.ENDC					;
;---------------------------------------;

	CLR	DDLGIF#(R4)		; Clear packet list pointer
	JMP	ISYNCH			; Go resynch device
.PAGE
.SBTTL	LNKG   - LKGOSV	- Output interrupt handler
;-----
; LKGOSV - Processes output interrupts from the DUV-11/DUP-11 interface
;
; The following code has been executed to get here:
;	<output done interrupt>
;	PUSH	R4
;	MOV	<address of DDB>,R4
;	JMP	LKGOSV
;-----
LKGOSV::PUSH	R0			; Save R0
	BIS	#$IRMA,DDLGF2#(R4)	; Set IRMA timer flag
	MOV	DDLGOS#(R4),R0		; Get output state - output active?
	BEQ	ONEXTF			; No - check for new frame to send
	JMP	(R0)			; Yes - dispatch to output state
;-----
; Here to find next frame to send (if there is one)
;-----
ONEXTF:	TBBN	<$RUA!$XUA>,DDLGF2#(R4),ONEXT1 ; Bypass if not info xfr phase
	BIC	#$ABORT,DDLGFG#(R4)	; Clear abort flag (not sending yet)
	TBBN	$TIMER,DDLGFG#(R4),1$	; If timer recovery, don't send info
	CMP	DDLGLN#(R4),DDLGLT#(R4)	; Info frames pending?
	BNE	OFINFO			; Yes - send info frame
	BR	2$			; Go check for pending RR frame

1$:	TBBN	$REXMT,DDLGFG#(R4),OFRXMT ; If retransmit flag set, retransmit
					;   1st frame on transmit ring
2$:	TBBN	$RR,DDLGFG#(R4),OFRR	; If pending RR response for info frame
					;   go send RR (or RNR if input busy)
ONEXT1:	MOVB	DDLGCM#(R4),DDLGOX#(R4)	; Get pending command - anything there?
	BNE	OFCMND			; Yes - send command frame
	MOVB	DDLGAK#(R4),DDLGOX#(R4)	; Get pending ACK - anything there?
	BNE	OFRESP			; Yes - send response frame
;-----
; Here to go idle when there is no frame to output
;-----
OFIDLE:	TST	DDLGPX#(R4)		; DUP-11 or DU-11/DUV-11?
	BMI	1$			; Skip if DUP-11

	BIC	#$XSEND,@DDLGXS#(R4)	; Clear tranmitter send (idle w/marks)

1$:	CLR	DDLGOS#(R4)		; Clear output state (go inactive)
RTI001:	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Set up for response frame (RR, RNR, REJ, UA, CMDR)
;-----
; Here to begin sending response frame
;-----
OFRESP:	CLRB	DDLGAK#(R4)		; Clear pending response function
	CMPB	DDLGOX#(R4),#.UA	; Unnumbered Acknowledge response?
	BEQ	OFRESX			; Yes
;-----
; Make sure all is well before sending a supervisory response frame
;-----
	BIC	#$RR,DDLGFG#(R4)	; Clear RR pending flag
	TBBN	<$RUA!$XUA>,DDLGF2#(R4),OFIDLE ; Go idle if not info xfr phase
	TBBE	$CMDR,DDLGFG#(R4),OFSUPV; If not CMDR state, send supervisory
;-----
; Begin sending CMDR frame
;-----
OFCMDR:	MOVB	#.CMDR,DDLGOX#(R4)	; Frame control byte <-- CMDR
	MOV	#OINFCR,DDLGOI#(R4)	; Info fld dispatch <-- CMDR info fld
	BR	OFRAME			; Start sending frame

;-----
; Here when received frames to be ACK'd and no info frame to piggyback ACK
;-----
OFRR:	BIC	#$RR,DDLGFG#(R4)	; Clear RR pending flag
	MOVB	#.RR,DDLGOX#(R4)	; Frame control byte <-- RR
;	TBBE	$IBUSY,DDLGFG#(R4),OFSUPV ; Input busy?
;	MOVB	#.RNR,DDLGOX#(R4)	; Yes - frame control byte <-- RNR

;-----
; Here to get N(R) for supervisory frame and finish setup
;-----
OFSUPV:	MOVB	DDLGVR#(R4),R0		; Get V(R) for supervisory frame
	ASHI	.SHFNR,R0		; Shift into N(R) position
	BISB	R0,DDLGOX#(R4)		; Put N(R) into control byte

;-----
; Here to set frame address and information field dispatch then start sending
;-----
OFRESX:	MOV	#OENDTR,DDLGOI#(R4)	; Info fld dispatch <-- no info fld
	MOVB	DDLGXR#(R4),DDLGOA#(R4)	; Frame address <-- outgoing response
	TBBE	$ICPF,DDLGFG#(R4),OFRAME; Should Final bit be set?
	BIC	#$ICPF,DDLGFG#(R4)	; Yes - clear input cmd Poll bit flag
	BISB	#$PFBIT,DDLGOX#(R4)	; Set Final bit in response frame
	BR	OFRAME			; Start sending frame
.PAGE
.SBTTL	LNKG		- Set up for command frame (SARM, DISC, information)
;-----
; Here to prepare to retransmit 1st info frame on transmit ring
;-----
OFRXMT:	BIC	#$REXMT,DDLGFG#(R4)	; Clear retransmit flag
	BIS	#$FRXMT,DDLGFG#(R4)	; Flag this frame is retransmission
	MOVB	DDLGK1#(R4),DDLGT1#(R4)	; Reset timer T1
	MOV	@DDLGLH#(R4),DDLGOF#(R4); Get ptr to 1st frame on transmit ring
	BNE	1$			; Ok if something is there
	FSTOP	ZPR			; [Zero Packet list in Retransmission]

1$:	MOVB	DDLGNR#(R4),DDLGOX#(R4)	; Control byte N(S) <-- stored N(R)
	BR	OFINF1			; Merge with info frame setup code

;-----
; Here for setup to send an information frame
;-----
OFINFO:	TBBE	$ICPF,DDLGFG#(R4),1$	; Was cmd frame read with Poll bit set?
	TBBN	$RR,DDLGFG#(R4),OFRR	; Yes - if it was info, send RR w/F bit

1$:	BIC	#$FRXMT,DDLGFG#(R4)	; Flag this frame not a retransmission
	MOV	@DDLGLN#(R4),DDLGOF#(R4); Get ptr to next frame to send
	MOVB	DDLGVS#(R4),DDLGOX#(R4)	; Put into N(S) of control byte

OFINF1:	ASLB	DDLGOX#(R4)		; Position N(S) in control byte
	MOV	#OINF0,DDLGOI#(R4)	; Info fld dispatch <-- info frame kind
	MOVB	DDLGVR#(R4),R0		; Get V(R)
	ASHI	.SHFNR,R0		; Position N(R) for control byte
	BISB	R0,DDLGOX#(R4)		; Put N(R) into control byte
	BR	OFCMN1			; Merge with end of command frame setup

;-----
; Here to begin sending command frame
;-----
OFCMND:	CLRB	DDLGCM#(R4)		; Clear pending command function
	MOV	#OENDTR,DDLGOI#(R4)	; Info fld dispatch <-- no info fld

OFCMN1:	MOVB	DDLGXC#(R4),DDLGOA#(R4)	; Frame address <-- outgoing command
	TBBE	$OCPF,DDLGFG#(R4),OFRAME; Send frame if P/F bit should be clear
	BIC	#$OCPF,DDLGFG#(R4)	; Clear output cmd frame Poll bit flag
	BISB	#$PFBIT,DDLGOX#(R4)	; Set Poll bit in frame control byte
;-----
; Drop through into beginning of frame output code...
;-----
.SBTTL	LNKG		- Protocol output states - start sending frame
;-----
; Here to start a new output frame - send frame synch, start of transparency,
; address, and control bytes - <frame synch><DLE><STX><address><control>
;-----
OFRAME:	MOV	#OFRSYN,DDLGOS#(R4)	; Output state <-- send frame synch
	CLR	DDLGCO#(R4)		; Initialize CRC-16 for this frame

	MOVB	#.SHSYN,DDLGOC#(R4)	; Output byte count <-- short synch
	TBBE	$SYNCH,DDLGFG#(R4),1$	; Should extra synch bytes be sent?
	BIC	#$SYNCH,DDLGFG#(R4)	; Yes - clear long synch flag
	MOVB	#.LNSYN,DDLGOC#(R4)	; Byte count <-- long synch string

1$:	TST	DDLGPX#(R4)		; DUP-11 or DU-11/DUV-11?
	BMI	OFRSYN			; Skip if DUP-11

	BIS	#$XSEND,@DDLGXS#(R4)	; DU-11 or DUV-11 - set send bit
;-----
; Here to send a frame synch byte
;-----
OFRSYN:	DECB	DDLGOC#(R4)		; Bump byte count
	BMI	OFRDLE			; When done, send <DLE><STX>
	MOV	#<$XSMSG!SYN>,@DDLGXB#(R4) ; Send <SYN> byte & start msg
	RTI04				; Return from interrupt

;-----
; Here to send <DLE> byte before <STX> (start of transparency)
;-----
OFRDLE:	MOV	#OFRSTX,DDLGOS#(R4)	; Output state <-- send <STX> byte
	MOVB	#DLE,@DDLGXB#(R4)	; Send <DLE> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to send <STX> byte to start frame transparency
;-----
OFRSTX:	MOV	#OADDR,DDLGOS#(R4)	; Output state <-- frame address byte
	MOVB	#STX,@DDLGXB#(R4)	; Send <STX> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to output frame address byte
;-----
OADDR:	MOV	#OCNTL,DDLGOS#(R4)	; Output state <-- frame control byte
	CLR	R0			; Clear residue
	BISB	DDLGOA#(R4),R0		; Get frame address byte
	JMP	OTRANS			; Output byte with transparency

;-----
; Here to output frame control byte
;-----
OCNTL:	MOV	DDLGOI#(R4),DDLGOS#(R4)	; Output state <-- info field (if any)
	CLR	R0			; Clear residue
	BISB	DDLGOX#(R4),R0		; Get frame control byte
	JMP	OTRANS			; Output byte with transparency

;-----
; **** NOTE ****
;
; Next output state is the beginning of the information field...  Only 2 frame
; formats have information fields: information command frame and CMDR response
; frame...  The other frame formats (SARM, DISC, UA, RR, RNR, REJ) are not
; allowed information fields...  When frame output is initialized at ONEXTF,
; the frame information field dispatch location is placed in the DDB (DDLGOI)
; depending on frame format...  This is one of: OINF0 (1st byte of information
; command frame information field), OINFCR (1st byte of CMDR response frame
; information field), or OENDTR (end transparency - i.e. no information field)
;-----
.PAGE
.SBTTL	LNKG		- Protocol output states - information frame info field
;-----
; Here to begin output of information frame info field
;-----
OINF0:	MOV	#OINFO,DDLGOS#(R4)	; Output state <-- rest of info field
	MOV	DDLGOF#(R4),R0		; Get 1st packet pointer
	BNE	1$			; Ok if something is there
	FSTOP	ZPL			; [Zero Packet List]

1$:	MOV	R0,DDLGOP#(R4)		; Save current packet pointer
	MOV	R0,DDLGOB#(R4)		; Init packet byte pointer
	ADD	#PKTYPE,DDLGOB#(R4)	; Start taking bytes from packet type
	MOVB	PKCNT(R0),R0		; Get packet byte count
	ADD	#<PKDATA-PKTYPE>,R0	; 1st packet has more bytes
	MOVB	R0,DDLGOC#(R4)		; Store length of 1st packet
	BR	OINFO			; Go send 1st information field byte

;-----
; Here to get a new packet for additional information field bytes
;-----
ONEWPK:	MOV	@DDLGOP#(R4),R0		; Get link to new current packet
	BEQ	OINFET			; Quit if end of packet list

	MOV	R0,DDLGOP#(R4)		; Save current packet pointer
	MOV	R0,DDLGOB#(R4)		; Init packet byte pointer
	ADD	#PKDATA,DDLGOB#(R4)	; Start taking bytes from pkt data
	MOVB	PKCNT(R0),DDLGOC#(R4)	; Get packet byte count

;-----
; Here to send an information field byte
;-----
OINFO:	TBBN	$ABORT,DDLGFG#(R4),OABORT ; If time to abort, go do it
	TSTB	DDLGOC#(R4)		; Any bytes left in packet?
	BEQ	ONEWPK			; No - get next packet

	CLR	R0			; Clear residue
	BISB	@DDLGOB#(R4),R0		; Get byte from packet
	INC	DDLGOB#(R4)		; Bump byte pointer
	DECB	DDLGOC#(R4)		; Bump packet byte count
	JMP	OTRANS			; Output byte with transparency

;-----
; Here to end info frame info field and update V(S)
;-----
OINFET:	BIC	#$RR,DDLGFG#(R4)	; Clear RR pending flag
	TSTB	DDLGT1#(R4)		; Timer T1 set?
	BNE	1$			; Yes - don't reset it
	MOVB	DDLGK1#(R4),DDLGT1#(R4)	; No - set it
	MOV	#XXINFO,DDLGTX#(R4)	; Timer expire state <-- sending info
1$:	TBBE	$FRXMT,DDLGFG#(R4),2$	; If not retransmission, bump V(S)
	BIC	#$FRXMT,DDLGFG#(R4)	; Retransmission - clear flag
	BR	OENDTR			; Go finish frame output

2$:	INCB	DDLGVS#(R4)		; Bump V(S)
	BICB	#$MASKN,DDLGVS#(R4)	; Perform modulus addition
	ADD	#2,DDLGLN#(R4)		; Bump next-frame-to-send pointer
	CMP	DDLGLN#(R4),DDLGLE#(R4)	; End of ring?
	BLO	OENDTR			; No - go end transparency
	MOV	DDLGLB#(R4),DDLGLN#(R4)	; Yes - reset next frame pointer
	BR	OENDTR			; Go end transparency

;-----
; Here to abort output frame
;-----
OABORT:	MOV	#OABOR1,DDLGOS#(R4)	; Output state <-- send <EOT>
	MOVB	#DLE,@DDLGXB#(R4)	; Send <DLE> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to complete frame abort
;-----
OABOR1:	MOV	#OPAD1,DDLGOS#(R4)	; Output state <-- send pad byte
	BIC	#<$ABORT!$FRXMT>,DDLGFG(R4) ; Clear abort and retransmitted
					;   frame flags
	MOVB	#EOT,@DDLGXB#(R4)	; Send <EOT> byte w/o CRC calc
	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Protocol output states - CMDR frame information field
;-----
; Here to begin information field of CMDR frame
;-----
OINFCR:	MOV	#OCVRVS,DDLGOS#(R4)	; Output state <-- send V(R) and V(S)
	CLR	R0			; Clear residue
	BISB	DDLGCX#(R4),R0		; Get bad control byte
	BR	OTRANS			; Output byte with transparency

;-----
; Here to send V(R) and V(S) in CMDR info field
;-----
OCVRVS:	MOV	#OCRSN,DDLGOS#(R4)	; Output state <-- send CMDR reason
	CLR	R0			; Clear residue
	BISB	DDLGVR#(R4),R0		; Get V(R)
	ASHI	<.SHFNR-1>,R0		; Partially align V(R)
	BISB	DDLGVS#(R4),R0		; Get V(S)
	ASL	R0			; Align V(R) and V(S)
	BR	OTRANS			; Output byte with transparency

;-----
; Here to send CMDR reason in CMDR frame info field
;-----
OCRSN:	MOV	#OENDTR,DDLGOS#(R4)	; Output state <-- end transparency
	CLR	R0			; Clear residue
	BISB	DDLGCR#(R4),R0		; Get CMDR reason
	BR	OTRANS			; Output byte with transparency
.PAGE
.SBTTL	LNKG		- Protocol output states - <DLE><ETX>, CRC, pad byte
;-----
; Here to end transparency
;-----
OENDTR:	MOV	#OENDT1,DDLGOS#(R4)	; Output state <-- send <ETX>
	MOVB	#DLE,@DDLGXB#(R4)	; Send <DLE> byte w/o CRC calc

;---------------------------------------;
.IF NE ..BUG				;
					;
	MOV	LKGPUT,R0		; Get debug ring putter
	MOVB	DDLGOX#(R4),(R0)+	; Save output control byte
	CLRB	(R0)+			; Flag as output byte
	MOV	UPTIME#,(R0)+		; Store uptime timer
	CMP	R0,#LKGEOR		; End of ring?
	BLO	47$			; No
	MOV	#LKGRNG,R0		; Yes
47$:	MOV	R0,LKGPUT		; Update putter
					;
.ENDC					;
;---------------------------------------;

	RTI04				; Return from interrupt
;-----
; Here to send <ETX>
;-----
OENDT1:	MOV	#OCRC1,DDLGOS#(R4)	; Output state <-- send CRC byte 1
	MOV	#ETX,R0			; Send <ETX>
	BR	OCCRC			; Go calc CRC and send byte

;-----
; Here to send CRC byte 1
;-----
OCRC1:	MOV	#OCRC2,DDLGOS#(R4)	; Output state <-- send CRC byte 2
	MOVB	DDLGCO#(R4),@DDLGXB#(R4); Send CRC byte 1
	RTI04				; Return from interrupt

;-----
; Here to send CRC byte 2
;-----
OCRC2:	MOV	#OPAD,DDLGOS#(R4)	; Output state <-- send pad byte
	MOVB	DDLGCO#+1(R4),@DDLGXB#(R4) ; Send CRC byte 2
	RTI04				; Return from interrupt

;-----
; Here to send pad bytes following frame
;-----
OPAD:	MOVB	#.T3,DDLGT3#(R4)	; Reset idle link RR frame timer
OPAD1:	MOV	#OPADN,DDLGOS#(R4)	; Output state <-- mark byte string
	MOVB	#.NPADS,DDLGOC#(R4)	; Init mark byte count

OPADN:	DECB	DDLGOC#(R4)		; Decrease mark byte count
	BMI	1$			; All done - send last mark byte

	MOVB	#377,@DDLGXB#(R4)	; Send mark byte
	RTI04				; Return from interrupt


1$:	MOV	#ONEXTF,DDLGOS#(R4)	; Output state <-- next frame to send
	MOV	#377,@DDLGXB#(R4)	; Send pad byte & clear start msg bit
	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Protocol output states - CRC & send byte to device
;-----
; Here to perform transparent byte output - double each <DLE> byte
;-----
OTRANS:	CMPB	R0,#DLE			; Byte == <DLE>?
	BNE	OCCRC			; No - calculate CRC and send byte
	MOV	DDLGOS#(R4),DDLGTS#(R4)	; Save output state
	MOV	#OTRAN1,DDLGOS#(R4)	; Output state <-- duplicate <DLE> byte
	MOVB	R0,@DDLGXB#(R4)		; Send 1st <DLE> w/o CRC calc
	RTI04				; Return from interrupt
;-----
; Here to send 2nd <DLE> byte for transparency
;-----
OTRAN1:	MOV	DDLGTS#(R4),DDLGOS#(R4)	; Restore output state to normal
	MOV	#DLE,R0			; Get 2nd <DLE> byte

;-----
; Here to calculate partial CRC-16 for output byte
;-----
OCCRC:	MOVB	R0,@DDLGXB#(R4)		; Send byte accross interface

	PUSH	R1			; Save register

	MOV	DDLGCO#(R4),R1		; Get old partial CRC
	XOR	R1,R0			; XOR old CRC and new byte
	BIC	#177400,R0		; Clear high byte
	ASL	R0			; Convert to word index
	MOV	CRCTAB#(R0),R0		; Get modifier word
	CLRB	R1			; Clear low byte of old CRC
	SWAB	R1			; Move high byte of old CRC to low
	XOR	R0,R1			; XOR modifier and old CRC
	MOV	R1,DDLGCO#(R4)		; Save new partial CRC

	POP	R1			; Restore register

	RTI04				; Return from interrupt
.PAGE
.SBTTL	LNKG		- Main program level entry points
;-----
; LKGINI - Subroutine to initialize the DDB
;
; Linkage:
;	C(R4) = address of DDB
;	CALL	LKGINI
;-----
LKGINI::CLR	@DDLGXB#(R4)		; Does device exist?
	NXMJMP	NOLINK#			; No

	TBBN	$XSMSG,@DDLGXB#(R4),1$	; DU-11 if bit not affected
	MOV	#$XSMSG,@DDLGXB#(R4)	; DUP-11 or DUV-11?
	TBBE	$XSMSG,@DDLGXB#(R4),1$	; DUV-11 if bit not affected

	MOV	#.PRDUP,DDLGPX#(R4)	; DUP-11 - get parameter reg init val
	BR	2$

1$:	MOV	#.PRDUV,DDLGPX#(R4)	; DU-11/DUV-11 get param reg init val

2$:	MOV	#$D1DWN,DDSTS1#(R4)	; Indicate link down - once a second

	MOV	#DDLGCZ#,R1		;GET NUMBER OF WORDS TO CLEAR
	MOV	#DDLGFC#,R2		; Set pointer to first word to clear
	ADD	R4,R2			; Set pointer into DDB

3$:	CLR	(R2)+			; Clear word
	SOB	R1,3$			; Continue until all words clear

	MOV	DDLGQB#(R4),DDLGQP#(R4)	; Init input to main ring putter
	MOV	DDLGQB#(R4),DDLGQT#(R4)	; Init taker
	MOV	DDLGLB#(R4),DDLGLH#(R4)	; Init transmit ring head pointer
	MOV	DDLGLB#(R4),DDLGLN#(R4)	; Init Xmit ring next-to-send ptr
	MOV	DDLGLB#(R4),DDLGLT#(R4)	; Init transmit ring tail pointer
	MOV	#$RDISC,DDLGF2#(R4)	; Start resetting link with DISC

;---------------------------------------;
.IF NE ..BUG				;
					;
	MOV	#LKGRNG,LKGPUT		; Init debug ring putter
					;
.ENDC					;
;---------------------------------------;

	RETURN				; Return to caller

;-----
; LKGINS - Subroutine to initialize device dependent part of SBD
;
; Linkage:
;	C(SD) = address of SDB
;	CALL	LKGINS
;-----
LKGINS::MOV	#SDLGCZ#,R1		;GET NUMBER OF WORDS TO CLEAR
	MOV	#SDLGFC#,R2		; Set pointer to first word to clear
	ADD	SD,R2			; Set pointer into DDB

1$:	CLR	(R2)+			; Clear word
	SOB	R1,1$			; Continue until all words clear

	RETURN				; Return to caller

;-----
; LKGMAI - main loop entry point to link type G protocol (SNAP)
;-----
	MAINXX	LKGMAI

LKGMAI:	MOV	#LKGDDB#,R4		; Get 1st type G link DDB
;-----
; Check link for input activity
;-----
LKGMA1:	TBBN	$D1UNV,DDSTS1#(R4),LKGMA3 ; If link hardware not there, check
					;   next type G link
	CMP	DDLGQP#(R4),DDLGQT#(R4)	; Something in input done ring?
	BEQ	LKGMA2			; No - check for new frames to send
	CALL	MINPUT			; Yes - get input frame
;-----
; Check link for new frames to send
;-----
LKGMA2:	TBBE	$D1ACT,DDSTS1#(R4),LKGMA3 ; Check next link if device inactive
	CMPB	DDLGVT#(R4),DDLGK0#(R4)	; Device active - room in Xmit ring?
	BHIS	LKGMA3			; No - check output state
	CALL	LKGNXT#			; Yes - get next packet to send and
					;   start output if idle
;-----
; Advance to next type G link
;-----
LKGMA3:	MOV	DDLKNS#(R4),R4		; Get next type G link DDB
	BNE	LKGMA1			; If another link, check for activity

	RETURN				; All done - return to caller

;-----
; LKGLOD - called to down-line load across link
;-----
LKGLOD::
	FSTOP	NIY			; [Not Implemented Yet]
.PAGE
.SBTTL	LNKG		- Main level frame input verification and completion
;-----
; Here when activity detected on input side (frame has been read)
;-----
MINPUT:	MOV	DDLGQT#(R4),R0		; Get input done ring taker
	MOV	(R0)+,DDLGMF#(R4)	; Get packet list header
	MOVB	(R0)+,DDLGMX#(R4)	; Get frame control byte
	MOVB	(R0)+,R2		; Get frame status byte
	CMP	R0,DDLGQE#(R4)		; Beyond end of ring?
	BLO	1$			; No
	MOV	DDLGQB#(R4),R0		; Yes - reset ring taker
1$:	MOV	R0,DDLGQT#(R4)		; Update taker

	TST	R2			; Error detected on frame input?
	BEQ	MINPOK			; No - frame input ok

	INC	DDERSZ#(R4)		; Size error detected at interrupt level
;-----
; Here to discard and take action on bad input frames
;-----
MINBAD:	MOV	DDLGMF#(R4),R1		; Yes - get packet list ptr
	BEQ	2$			; Nothing to free
	CLR	DDLGMF#(R4)		; Clear packet list pointer

1$:	PUSH	(R1)			; Store forward packet pointer
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward pointer
	BNE	1$			; Continue until packet list free

2$:	JMP	@MIERDT(R2)		; Dispatch to error code
;-----
; Input error dispatch table
;-----
	PURE
	.EVEN
MIERDT:	.WORD	RTN000			; ER.IGN =  0 ignore this frame
	.WORD	ERROVF			; ER.OVF =  2 frame overflow
	.WORD	ERRIVF			; ER.UND =  4 frame underflow
	.WORD	ERRIVF			; ER.IVF =  6 invalid frame
	.WORD	RTN000			; ER.INR = 10 invalid N(R) (ignore now)
	.WORD	ERRNIA			; ER.NIA = 12 no info field allowed
	.WORD	STARTO			; ER.STO = 14 start output
	.WORD	LRESET			; ER.RST = 16 reset the link
	CODE

;-----
; Here if no error status reported from input
;-----
MINPOK:	MOVB	#.T6,DDLGT6#(R4)	; Start idle input take-down timer
	BITB	#$INFO,DDLGMX#(R4)	; Information frame?
	BEQ	1$			; Yes - go do flow control
	BITB	#$SUPV,DDLGMX#(R4)	; Supervisory frame?
	BNE	MIUNUM			; No - check unnumbered frame

	TST	DDLGMF#(R4)		; Yes - information field?
	BEQ	1$			; No - go do flow control
	MOV	#ER.NIA,R2		; Yes - none allowed with supervisory
	BR	MINBAD			; Discard this frame

1$:	BIC	#<$SARM1!$DISC1>,DDLGFG#(R4) ; Clear 1st SARM & 1st DISC flags
	TBBN	<$RUA!$XUA>,DDLGF2#(R4),MINBAD ; Ignore if not info xfr phase
	JMP	MACKNR			; Go perform flow control update
					;   (free acknowledged frames)
;-----
; Here to complete input of unnumbered command/response frame
;-----
MIUNUM:	MOVB	DDLGMX#(R4),R0		; Get frame control byte
	BIC	#<177400!$PFBIT>,R0	; Clear Poll/Final bit

	CMPB	R0,#.SARM		; Set Asynchronous Response Mode?
	BEQ	MIUCMD			; Yes
	BIC	#$SARM1,DDLGFG#(R4)	; No - clear 1st SARM flag

	CMPB	R0,#.DISC		; DISConnect?
	BEQ	MIUCMD			; Yes
	BIC	#$DISC1,DDLGFG#(R4)	; No - clear 1st DISC flag

	CMPB	R0,#.UA			; Unnumbered Acknowledge?
	BEQ	MIUA			; Yes

	CMPB	R0,#.CMDR		; CoMmanD Reject?
	BEQ	MICMDR			; Yes

	MOV	#ER.IVF,R2		; Unrecognized command/response
	BR	MINBAD			; DIscard this frame & process error

;-----
; Here on CMDR unnumbered response frame
;-----
MICMDR:	MOV	#ER.RST,R2		; Indicate link must be reset
	BR	MINBAD			; Go reset link

;-----
; Here on unnumbered commands (SARM or DISC)
;-----
MIUCMD:	TST	DDLGMF#(R4)		; Information field?
	BEQ	1$			; No

	MOV	#ER.NIA,R2		; Yes - none allowed
	BR	MINBAD			; Discard frame & process error

1$:	BITB	#$PFBIT,DDLGMX#(R4)	; Poll bit set in command frame?
	BEQ	2$			; No
	BIS	#$ICPF,DDLGFG#(R4)	; Yes - flag it
2$:	MOVB	#.UA,DDLGAK#(R4)	; Pending ACK <-- UA
	CALL	STARTO			; Start output if idle

	BIC	#$CMDR,DDLGFG#(R4)	; Clear command reject condition
	CLRB	DDLGT5#(R4)		; Clear CMDR condition timer

	CMPB	R0,#.SARM		; Is this a SARM?
	BNE	MIDISC			; No - it is a DISC

;-----
; Here on SARM unnumbered frame
;-----
MISARM:	CLRB	DDLGVR#(R4)		; V(R) <-- 0
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT>,DDLGFG#(R4) ; Clear flags
	CLRB	DDLGT4#(R4)		; Clear reject condition timer
	BIC	#$XUA,DDLGF2#(R4)	; Indicate this side Xmitted UA for SARM
	TBBN	$RUA,DDLGF2#(R4),2$	; Need to send SARM?
	TBBN	$SARM1,DDLGFG#(R4),2$	; Is this a 1st SARM?
	CALL	MOSARM			; Yes - send SARM to init other side

2$:	BIS	#$SARM1,DDLGFG#(R4)	; Set received 1st SARM flag
	TBBN	<$RUA!$XUA>,DDLGF2#(R4),3$ ; Bypass if not info xfr phase now
	CJMP	RSTLKG#			; Go restart the link

3$:
	CMP	DDLGLN#(R4),DDLGLT#(R4)	; Frames waiting to be sent?
	BEQ	RTN000			; No
	CJMP	STARTO			; Yes - try to start output

;-----
; Here on DISC unnumbered frame
;-----
MIDISC:	TBBE	$RUA,DDLGF2#(R4),1$	; Skip if not waiting for UA to SARM
	JMP	MOSARM			; Make sure other side gets SARM

1$:	CALL	LKGDWN			; Declare link down
	TBBN	$RUA,DDLGF2#(R4),2$	; Bypass if waiting for UA to SARM
	TBBN	$DISC1,DDLGFG#(R4),2$	; Is this a 1st DISC?
	TBBE	$D0PRI,DDSTS0#(R4),2$	; Yes - is this side a DTE?
	CALL	MODISC			; No - send DISC frame

2$:	BIS	#$DISC1,DDLGFG#(R4)	; Set received 1st DISC flag
	BIS	#$XUA,DDLGF2#(R4)	; Indicate now in disconnected phase
	BIC	#$RUA,DDLGF2#(R4)	; Indicate SARM should be sent
RTN000:	RETURN				; Return to main

;-----
; Here on UA unnumbered response frame
;-----
MIUA:	TST	DDLGMF#(R4)		; Information field?
	BEQ	1$			; No - OK
	MOV	#ER.NIA,R2		; Yes - none allowed
	JMP	MINBAD			; Discard this frame & process error

1$:	BIC	#$OBUSY,DDLGFG#(R4)	; Indicate other side of link not busy
	MOV	DDLGUR#(R4),R0		; Anyone waiting for UA response?
	BEQ	RTN000			; No - return
	CLR	DDLGUR#(R4)		; Yes - clear UA input wait dispatch
	JMP	(R0)			; Dispatch to UA wait code
;-----
; Here when UA received after SARM sent
;-----
URSARM:	CLRB	DDLGT1#(R4)		; Stop timer T1
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Reset retransmission counter
	CLRB	DDLGVS#(R4)		; V(S) <-- 0
	CLRB	DDLGNR#(R4)		; Clear last N(R) received
	BIC	#$RUA,DDLGF2#(R4)	; Indicate this side got UA for SARM
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT>,DDLGFG#(R4) ; Clear flags
	CLRB	DDLGT4#(R4)		; Clear reject condition timer
	TBBN	<$RUA!$XUA>,DDLGF2#(R4),RTN000 ; Return if not info xfr phase
	CJMP	RSTLKG#			; Restart link if now info xfr phase
;-----
; Here when UA received after DISC sent
;-----
URDISC:	CALL	LKGDWN			; Declare link down
	CLRB	DDLGT1#(R4)		; Stop timer T1
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Reset retransmission counter
	BIC	#$RDISC,DDLGF2#(R4)	; Now reset link with SARMs
	CJMP	MOSARM			; Send a SARM to initiate the link

;-----
; Here to free packets held by acknowledged frames on transmit ring
;-----
MACKNR:	MOV	DDLGLH#(R4),R0		; Get frame transmit ring header

	MOVB	DDLGMX#(R4),R2		; Get frame control byte
	ASHI	-.SHFNR,R2		; Right justify N(R)
	BIC	#$MASKN,R2		; Isolate N(R)

	CMPB	R2,DDLGNR#(R4)		; Any frames to acknowledge?
	BEQ	MACKN3			; No
;-----
; Here to free a frame from the frame transmit ring
;-----
MACKN1:	CMPB	DDLGNR#(R4),DDLGVS#(R4)	; Trying to free unsent frame?
	BEQ	MIERNR			; Yes - new N(R) is bad
	MOV	(R0),R1			; Maybe - get info fld pkt list header
	BEQ	MIERNR			; Yes - new N(R) is bad

	BIC	#$REXMT,DDLGFG#(R4)	; New ACK - don't do retransmission

	SETPSW	DDLGPL#(R4)		; Raise to interrupt level
	CLR	(R0)+			; Clear packet pointer from Xmit ring
	CMP	R0,DDLGLE#(R4)		; End of ring?
	BLO	1$			; No
	MOV	DDLGLB#(R4),R0		; Yes - reset ring pointer
1$:	MOV	R0,DDLGLH#(R4)		; Update head pointer
	CLRPSW				; Lower to main program level

	DECB	DDLGVT#(R4)		; Decrease transmit ring frame count
	INCB	DDLGNR#(R4)		; Bump stored N(R)
	BICB	#$MASKN,DDLGNR#(R4)	; Perform modulus addition

;-----
; Here to free packets from frame transmit ring when frames acknowledged
;-----
MACKN2:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	MACKN2			; Continue until all packets free

	CMPB	DDLGNR#(R4),R2		; Stored N(R) == new N(R)?
	BNE	MACKN1			; No - continue until all frames freed

;-----
; All frames acknowledged and freed from ring
;-----
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Reset retransmission counter

	MOVB	DDLGK1#(R4),DDLGT1#(R4)	; Something ACK'd - reset timer T1
	TSTB	DDLGVT#(R4)		; Anything left in ring?
	BNE	MACKN3			; Yes

	CLRB	DDLGT1#(R4)		; No - clear timer T1
	BIC	#$TIMER,DDLGFG#(R4)	; Clear timer state when nothing left

;-----
; Here after frames acknowledged and packets freed
;-----
MACKN3:	CLR	R3			; Clear residue
	BISB	DDLGMX#(R4),R3		; Get frame control byte

	TBBE	$INFO,R3,MIINFO		; Go process info frame
	TBBE	$PFBIT,R3,MISUPV	; Go process SUPV if Final bit clear

	BIC	#$TIMER,DDLGFG#(R4)	; Clear timer recovery condition
	MOVB	R2,DDLGVS#(R4)		; V(S) <-- N(R) of supervisory frame
	MOV	R0,DDLGLN#(R4)		; Next to send pointer <-- head of ring
;-----
; Here to complete supervisory frame input
;-----
MISUPV:	ASR	R3			; Make word index of SUPV function
	BIC	#$MASKN,R3		; Isolate supervisory function
	JMP	@MISUDT(R3)		; Dispatch on supervisory function
;-----
; Input supervisory function dispatch table
;-----
	PURE
	.EVEN
MISUDT:	.WORD	MIRR			; Receive Ready
	.WORD	MIRNR			; Receive Not Ready
	.WORD	MIREJ			; REJect
	.WORD	MIERSU			; Undefined supervisory function
	CODE
;-----
; Here on RNR supervisory response frame
;-----
MIRNR:	BIS	#$OBUSY,DDLGFG#(R4)	; Indicate other side of link busy
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Reset retransmission counter
	RETURN				; Return to caller
;-----
; Here on REJ supervisory response frame
;-----
MIREJ:	TBBN	$TIMER,DDLGFG#(R4),MIRR1; Don't change V(S) if in timer state
	BIS	#$ABORT,DDLGFG#(R4)	; Abort info frame if sending one
	MOVB	R2,DDLGVS#(R4)		; V(S) <-- N(R) received
	MOV	R0,DDLGLN#(R4)		; Set next frame pointer to 1st frame
;-----
; Here on RR supervisory response frame
;-----
MIRR:	BIC	#$OBUSY,DDLGFG#(R4)	; Indicate other side of link not busy
	TSTB	DDLGVT#(R4)		; Info frames in ring?
	BEQ	MIRR1			; No - return
	CJMP	STARTO			; Yes - try to start output if idle

MIRR1:	RETURN				; Return to caller

;-----
; Here on N(R) errors (trying to ACK unsent or already ACK'd frames)
;-----
MIERNR:
;	BITB	#$INFO,DDLGMX#(R4)	; Information frame?
;	BNE	MIERSU			; No - SUPV with bad N(R) - reset link
	INC	DDERPC#(R4)		; Bump protocol error count
	MOV	#ER.INR,R2		; Declare N(R) error
	JMP	MINBAD			; Discard frame & process error
;-----
; Here on undefined supervisory function in control byte
;-----
MIERSU:	INC	DDERPC#(R4)		; Bump protocol error count
	MOV	#ER.RST,R2		; Declare link must be reset
	JMP	MINBAD			; Discard frame & reset link

;-----
; Here to complete information frame input
;-----
MIINFO:	TBBE	$PFBIT,R3,1$		; Poll bit set in info frame?
	BIS	#$ICPF,DDLGFG#(R4)	; Yes - flag incoming command w/Poll bit

1$:	ASR	R3			; Right justify N(S)
	BIC	#$MASKN,R3		; Isolate N(S)
	CMPB	R3,DDLGVR#(R4)		; Is this the next expected frame?
	BEQ	4$			; Yes

	MOV	#ER.STO,R2		; No - flag start output after frame
					;   is discarded
	TBBN	$REJ,DDLGFG#(R4),2$	; Skip if already in reject condition

	BIS	#$REJ,DDLGFG#(R4)	; Set reject condition flag
	MOVB	#.T4,DDLGT4#(R4)	; Start reject condition timer
	MOVB	#.REJ,DDLGAK#(R4)	; Pending ACK <-- REJ
	JMP	MINBAD			; Discard frame & send REJ frame

2$:	TBBE	$ICPF,DDLGFG#(R4),3$	; Poll bit set in this frame?
	BIS	#$RR,DDLGFG#(R4)	; Yes - send RR frame w/Final bit set
	JMP	MINBAD			; Discard frame & send RR frame

3$:	CLR	R2			; Flag this frame should be ignored
	JMP	MINBAD			; Discard frame

4$:	BIC	#$REJ,DDLGFG#(R4)	; Clear reject condition
	CLRB	DDLGT4#(R4)		; Clear reject condition timer

	MOVB	DDLGVR#(R4),R0		; Get V(R)
	INC	R0			; Bump V(R)
	BIC	#$MASKN,R0		; Perform modulus arithmetic
	MOVB	R0,DDLGVR#(R4)		; Update V(R)

	BIS	#$RR,DDLGFG#(R4)	; Indicate pending RR frame
	CALL	STARTO			; Start output if idle

	MOV	DDLGMF#(R4),R1		; Get packet list - anything there?
	BEQ	5$			; No - must have been ignored or bad

	CLR	DDLGMF#(R4)		; Clear packet list pointer
	CJMP	LKGMOV#			; Translate & send packets into node

5$:	RETURN				; Return to main loop
.PAGE
.SBTTL	LNKG		- Main level error states (causes for sending CMDR)
;-----
; Here if frame format error or unknown command/response in control byte
;-----
ERRIVF:	MOVB	#.CRSNW,DDLGCR#(R4)	; Set CMDR reason W (invalid cntl byte)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if frame had information field when not allowed to have one
;-----
ERRNIA:	MOVB	#<.CRSNW!.CRSNX>,DDLGCR#(R4) ; Set CMDR reasons W and X (bad
					;   cntl byte, info field not allowed)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if frame overflowed (too many bytes)
;-----
ERROVF:	MOVB	#.CRSNY,DDLGCR#(R4)	; Set CMDR reason Y (overflow)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if N(R) (frame receive number) was bad
;-----
ERRINR:	MOVB	#.CRSNZ,DDLGCR#(R4)	; Set CMDR reason Z (invalid N(R))
;	BR	MOCMDR			; Go send CMDR frame

;-----
; Here to send a CMDR frame
;-----
MOCMDR:	CLRB	DDLGT1#(R4)		; Clear timer T1
	BIC	#$TIMER,DDLGFG#(R4)	; Clear timer recovery flag

	MOVB	DDLGMX#(R4),DDLGCX#(R4)	; Save bad control byte
	BIS	#<$CMDR!$ABORT>,DDLGFG#(R4) ; Abort current output frame and
					;   set CoMmanD Reject condition
	MOVB	#.T5,DDLGT5#(R4)	; Set command reject condition timer
	MOVB	#.CMDR,DDLGAK#(R4)	; Pending response <-- 1st CMDR

.SBTTL	LNKG   - STARTO/LKGSTO - Start output INTERRUPT SERVICE if idle
;-----
; Here to start output if output is idle
;
; **** WARNING ****
;
; This label MUST be entered with nothing added to the stack - it assumes
; that the return address is on the top of the stack...
;-----
LKGSTO::				; Global entry point for STARTO
STARTO:	SETPSW	DDLGPL#(R4)		;RAISE PROCESSOR LEVEL
	PUSH	(SP)			; Duplicate return addr on stack
	CLR	2(SP)			; Clear PSW on stack

	TST	DDLGOS#(R4)		; Output in progress?
	BEQ	1$			; No - fake an output done interrupt
	RTI				; Yes - let output do it when finished

1$:	PUSH	R4			; Push contents of R4 to simulate what
					;   happens at device interrupt handler
	PUSH	R0			; Push contents of R0 to simulate what
					;   happens at common interrupt handler
	JMP	ONEXTF			; Transfer to output interrupt service
					;   to start output frame
.PAGE
.SBTTL	LNKG		- Once a second routines (and reset link routine)
;-----
; LKGSEC - Once a second entry point
;-----
	ONCSEC	LKGSEC

LKGSEC:	MOV	#LKGDDB#,R4		; Get base DDB pointer

LKGSE1:	TBBN	$D1UNV,DDSTS1#(R4),LKGSE2 ; If device not there, check next DDB
	TBBE	$D1DWN,DDSTS1#(R4),1$	; If link UP, CHECK TIMERS
	TBBE	$RESET,DDLGF2#(R4),47$	; If link down & needs reset, do it
					;   after this, timers should do it
;-----
; Here to check IRMA timer for lost output interrupts
;-----
1$:	TBBE	$IRMA,DDLGF2#(R4),2$	; If IRMA clear, maybe lost interrupt
	BIC	#$IRMA,DDLGF2#(R4)	; IRMA bit set - clear it
	BR	3$			; Check next timer

;-----
; IRMA bit clear - if output active, interrupt lost for 1 second
;-----
2$:	TST	DDLGOS#(R4)		; Output idle?
	BEQ	3$			; Yes

	SETPSW	DDLGPL#(R4)		;RAISE PROCESSOR TO INTERRUPT LEVEL
	CLR	-(SP)			; Push clear PSW
	PUSH	#3$			; Push return address
	PUSH	R4			; Simulate what happens at interrupt
	CJMP	LKGOSV			; Go process fake interrupt

;-----
; Check timer T1 (non-response timer)
;-----
3$:	TSTB	DDLGT1#(R4)		; Timer T1 set for this link?
	BEQ	4$			; No - check OTHER TIMERS
	DECB	DDLGT1#(R4)		; Yes - decrement timer count
	BNE	4$			; If time left, check other timers
;-----
; Timer T1 expired for a link
;-----
	TST	DDLGTX#(R4)		; Anyone want to recover this?
	BEQ	4$			; No - check other timers
;-----
; Call one of the timer T1 recovery routines:
;	XXSARM - unacknowledged SARM frame transmitted
;	XXDISC - unacknowledged DISC frame transmitted
;	XXINFO - unacknowledged information frame(s) transmitted
;-----
	CALL	@DDLGTX#(R4)		; CALL timer recovery routine

;-----
; Here to check idle input take-down timer
;-----
4$:	TSTB	DDLGT6#(R4)		; Idle input take-down timer set?
	BEQ	5$			; No - check next timer
	DECB	DDLGT6#(R4)		; Yes - count down
	BEQ	47$			; Reset link if timer expires

;-----
; Check information transfer state timers - start with idle link RR frame timer
;-----
5$:	TBBN	<$RUA!$XUA>,DDLGF2#(R4),LKGSE2 ; Check next link if not info
					;   xfr phase
	TSTB	DDLGT3#(R4)		; Idle link RR frame timer set?
	BEQ	6$			; No - check next timer
	DECB	DDLGT3#(R4)		; Yes - decrement timer count
	BNE	6$			; If still time left, check next timer
	BIS	#$RR,DDLGFG#(R4)	; Set RR frame pending flag
	CALL	STARTO			; Start output if idle
;-----
; Check reject condition timer
;-----
6$:	TSTB	DDLGT4#(R4)		; Reject condition timer set?
	BEQ	7$			; No - check next timer
	DECB	DDLGT4#(R4)		; Yes - decrement timer count
	BEQ	47$			; Timer expired - reset link
;-----
; Check command reject condition timer
;-----
7$:	TSTB	DDLGT5#(R4)		; Command reject condition timer set?
	BEQ	LKGSE2			; No - check next link
	DECB	DDLGT5#(R4)		; Yes - decrement timer count
	BNE	LKGSE2			; If time left, check next link
;-----
; Reset the link and advance to next type G link
;-----
47$:	CALL	LRESET			; Timer expired - reset link

;-----
; Here to get next type G link DDB
;-----
LKGSE2:	MOV	DDLKNS#(R4),R4		; Get next type G link DDB
	BNE	LKGSE1			; Continue if more links
	RETURN				; Return to once-a-second processing

;-----
; Here to send SARM frame
;-----
MOSARM:	CALL	LKGDWN			; Declare link down
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Init retransmission count
	MOV	#URSARM,DDLGUR#(R4)	; UA input wait <-- SARM awaiting UA
	MOV	#XXSARM,DDLGTX#(R4)	; Timer expire state <-- sending SARM
	BIS	#$RUA,DDLGF2#(R4)	; Flag this side needs UA to SARM
;-----
; Here to recover if timer T1 expires while waiting for UA after sending SARM
;-----
XXSARM:	DECB	DDLGN2#(R4)		; Bump retransmit count
	BPL	1$			; Haven't sent SARM N2 times yet
	BIS	#$RDISC,DDLGF2#(R4)	; Have sent SARM N2 times - send DISC
	BR	LRESET			; Reset link if transmitted N2 times
1$:	MOVB	#.SARM,DDLGCM#(R4)	; Output command pending <-- SARM
	MOVB	DDLGK1#(R4),DDLGT1#(R4)	; Set timer T1
	BR	STARTO			; Start output if possible and return

;-----
; Here to send DISC frame
;-----
MODISC:	CALL	LKGDWN			; Declare link down
	MOVB	DDLGK2#(R4),DDLGN2#(R4)	; Init retransmission count
	MOV	#URDISC,DDLGUR#(R4)	; UA input wait <-- DISC awaiting UA
	MOV	#XXDISC,DDLGTX#(R4)	; Timer expire state <-- sending DISC
	BIS	#$XUA,DDLGF2#(R4)	; Flag this side needs to send UA for
					;   SARM before info xfr phase
	BIC	#$RUA,DDLGF2#(R4)	; Indicate SARM should be sent
;-----
; Here to recover if timer T1 expires while waiting for UA after sending DISC
;-----
XXDISC:	DECB	DDLGN2#(R4)		; Bump retransmit count
	BMI	LRESET			; Reset link if DISC sent N2 times
	MOVB	#.DISC,DDLGCM#(R4)	; Output command pending <-- DISC
	MOVB	DDLGK1#(R4),DDLGT1#(R4)	; Set timer T1
	CJMP	STARTO			; Start output if possible and return

;-----
; Here to recover if timer T1 expires after sending information frame
;-----
XXINFO:	TSTB	DDLGVT#(R4)		; Anything in ring to retransmit?
	BNE	1$			; Yes - go do it
	INC	DDLGBX#(R4)		; No - bump bad retransmission count
	BIC	#$TIMER,DDLGFG#(R4)	; Clear timer recovery state
	RETURN				; Return to caller

1$:	DECB	DDLGN2#(R4)		; Bump retransmit count
	BLE	LRESET			; Reset link if transmitted N2 times

	BIS	#<$ABORT!$REXMT!$OCPF!$TIMER>,DDLGFG#(R4)
					;   Abort info frame output, retransmit
					;   1st frame on Xmit ring w/ Poll bit,
					;   timer recovery in progress
	INC	DDERRX#(R4)		; Bump retransmission count
	CJMP	STARTO			; Start output if possible and return

;-----
; Here to try to set up (or reset) the link for communication
;-----
LRESET:	BIS	#$RESET,DDLGF2#(R4)	; Flag link has been reset since start
					;   (timers should do the resetting now)
	SETPSW	DDLGPL#(R4)		;RAISE PROCESSOR PRIORITY LEVEL
	CLR	@DDLGXS#(R4)		; Clear transmitter status/control reg

;-----
; Reset the device
;-----
	MOV	#$XMSTR,@DDLGXS#(R4)	; Master reset device

	CLR	DDLGIS#(R4)		; Clear input state while waiting for
					;   device to stabilize after reset
	CLR	DDLGOS#(R4)		; Clear output state

	MOV	DDLGPX#(R4),@DDLGPR#(R4); Initialize device parameter register
	MOV	#.RINIT,@DDLGRS#(R4)	; Initialize receiver control/status
	MOV	#.XINIT,@DDLGXS#(R4)	; Init transmitter control/status reg

	TST	DDLGPX#(R4)		; DUP-11 or DU-11/DUV-11?
	BPL	1$			; Skip if DU-11/DUV-11

	BIS	#$XSEND,@DDLGXS#(R4)	; Set DUP-11 send bit
	MOV	#<377!$XSMSG>,@DDLGXB#(R4) ; Init DUP-11 to send mark

1$:	CLRPSW				; Lower processor priority level

	BIS	#$SYNCH,DDLGFG#(R4)	; Set long synch flag

	BIC	#$DISC1,DDLGFG#(R4)	; Clear received 1st DISC flag
	BR	MODISC			; Go send a DISC
.PAGE
.SBTTL	LNKG   - LKGDWN - Subroutine to declare link down & clean up
;-----
; LKGDWN - Subroutine to reset link sockets (declare link down)
;
; Linkage:
;	C(R4) = Address of DDB
;	CALL	LKGDWN
;
; Unpreserved registers:
;	R0, R2, SD
;-----
LKGDWN::CALL	LNKDWN#			; Declare link down
	BIC	#$D1ACT,DDSTS1#(R4)	; Declare link inactive
	MOVB	DDLGVS#(R4),DDLGNR#(R4)	; Reset last N(R) received
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT!$CMDR>,DDLGFG#(R4) ; Clear flags
	CLRB	DDLGT3#(R4)		; Clear idle output RR frame timer
	CLRB	DDLGT4#(R4)		; Clear reject condition timer
	CLRB	DDLGT5#(R4)		; Clear command reject condition timer
	CLRB	DDLGT6#(R4)		; Clear idle input take-down timer

	MOV	DDSX#(R4),R0		; Get 1st SX table entry addr
	MOVB	DDSOC#(R4),R2		; Get # sockets on link

1$:	MOV	(R0)+,SD		; Get SDB address
	CLR	SDLGS1#(SD)		; Clear packet level status word
	CLRB	SDLGVR#(SD)		; Clear last P(R) received for socket
	CLRB	SDLGPR#(SD)		; Clear P(R) for socket
	CLRB	SDLGPS#(SD)		; Clear P(S) for socket
	CLRB	SDACNT#(SD)		; Clear send ahead count for socket
	CLRB	SDFCNT#(SD)		; Clear flag count (# RR pkts pending)
	CLRB	SDLGRR#(SD)		; Clear pending RR pkt count
	SOB	R2,1$			; Continue until all sockets reset

	TSTB	DDLGVT#(R4)		; Anything left in transmit ring?
	BEQ	6$			; No - check send back list

	SETPSW	DDLGPL#(R4)		;RAISE PROCESSOR PRIORITY LEVEL
	MOV	DDLGLH#(R4),R0		; Get Xmit ring head pointer

2$:	MOV	(R0),R1			; Get frame packet list pointer
	BEQ	4$			; No packets on list (shouldn't happen)

3$:	PUSH	(R1)			; Store forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward pointer
	BNE	3$			; Continue until all packets freed

4$:	CLR	(R0)+			; Clear packet list head pointer
	CMP	R0,DDLGLE#(R4)		; End of ring?
	BLO	5$			; No
	MOV	DDLGLB#(R4),R0		; Yes - reset ring pointer
5$:	CMP	R0,DDLGLT#(R4)		; Freed all lists from xmit ring?
	BNE	2$			; No - continue until all lists freed

	CLRB	DDLGVT#(R4)		; Clear transmit ring frame counter
	CLRB	DDLGT1#(R4)		; Clear timer (can't retransmit if link
					;   down & nothing in ring)
	MOV	R0,DDLGLH#(R4)		; Update head pointer
	MOV	R0,DDLGLN#(R4)		; Update next-to-send pointer
	BISB	#$ABORT,DDLGFG#(R4)	; Abort output frame if sending
	CLRPSW				; Lower processor priority level

6$:	MOV	DDLGAH#(R4),R1		; Get send back list head
	BEQ	8$			; Bypass if nothing there

7$:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	7$			; Continue until list freed

	CLR	DDLGAH#(R4)		; Clear send back list head
	CLR	DDLGAT#(R4)		; Clear send back list tail

8$:	RETURN				; Return to caller

	.END
  s@