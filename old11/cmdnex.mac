	.TITLE	CMDNEX - STANDARD NEXILIS TERMINAL COMMAND DECODER ROUTINES
	.SBTTL	CMDNEX - Nexilis/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

	CODE

;DEFINE MACRO FOR INLINE MESSAGES

	.MACRO	INLMES  MES
	CALL	INLOUT#
	.ASCIZ	MES
	.EVEN
	.ENDM

;GENERATE COMMAND DECODER ENTRY TABLE

	PURE

NEXENT::.WORD	NEXCMD		;.CXCMD =  0 - ENTER COMMAND LEVEL
	.WORD	NEXCMD		;.CXCIN =  2 - COMMAND INTERRUPT
	.WORD	NEXECL		;.CXECL =  4 - END OF COMMAND LINE
	.WORD	NEXRST		;.CXRST =  6 - RESET COMMAND DECODER
	.WORD	NEXACK		;.CXACK = 10 - CONNECT ACK PACKET
	.WORD	NEXNAK		;.CXNAK = 12 - CONNECT NAK PACKET
	.WORD	NEXDIS		;.CXDIS = 14 - DISCONNECT PACKET
	.WORD	NEXDAK		;.CXDAK = 16 - DISCONNECT ACK PACKET

	CODE
	.PAGE
;HERE TO ENTER NETWORK COMMAND LEVEL
;	ENTRY INDEX = .CXCMD

NEXCMD:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
	MOVB	#100,SDTRBS#(SD)	;FORCE COMMAND MODE BREAK SET
	BIS	#$T1CMD!$T1ECM,SDTRS1#(SD);Indicate command mode
	TBBN	$T3TRM,SDTRS3#(SD),CMDMO4;SHOULD WE ASK HIM FOR HIS TERMINAL
					 ;  TYPE NOW?
CMDMO1:	TSTB	SDSTS1#(SD)		;CONNECTED NOW?
	BNE	CMDMO3			;YES
	TBBN	$T3ACA,SDTRS3#(SD),CMDMO3;NO-HAVE WE ATTEMPTED TO CONNECT YET?
	BIS	#$T3ACA,SDTRS3#(SD)	;NO-BUT WE HAVE NOW!

;HERE IF WANT TO START AUTO-CONNECT SEQUENCE NOW

CMDATO:	MOVB	SDTRS0#+1(SD),R0	;DO WE HAVE A HOST CONNECT LIST?
	BIC	#^C<$T0HCL/400>,R0
	BEQ	CMDMO3			;NO-GO ON
	JMP	ATOCON			;YES-GO TRY TO CONNECT

;HERE IF REALLY WANT TO STAY AT NETWORK COMMAND LEVEL

CMDMO3:	TBBN	$T0CMD,SDTRS0#(SD),2$	;Can we be at command level?
	JMP	NEXHNG			;No-he looses!

;Here if network command is allowed for this terminal

2$:	INLMES	<<CR><LF>"Network Command Level (">
	MOV	#THSNOD#,R1		;GET ADDRESS OF NODE NAME
	CALL	OUTSTR#			;TYPE IT
	INLMES	<")"<CR><LF>>		;END THE LINE
CMDMO4:	BIC	#$T1SOP,SDTRS1#(SD)	;CLEAR OUTPUT SUPPRESS FLAG
	TBBN	$T1CMD,SDTRS1#(SD),CMDMO5;GO ON IF STAYING IN COMMAND MODE
	MOV	#OUTGET#,SDTROD#(SD)	;LEAVING COMMAND MODE-RESET OUTPUT DONE
					;  DISPATH ADDRESS
	MOVB	SDTRBX#(SD),SDTRBS#(SD)	;RESTORE BREAK SET
	JMP	OUTGET#			;AND LEAVE!

;HERE IF STAYING IN COMMAND MODE

CMDMO5:	TBBN	$T3TRM,SDTRS3#(SD),2$	;SHOULD WE ASK FOR THE TERMINAL TYPE?
	INLMES	<<CR><LF>"="<RA>>	;NO-TYPE THE NORMAL PROMPT
	BR	4$			;CONTINUE

2$:	INLMES	<<CR><LF>"Terminal = ">	;YES-TYPE SPECIAL PROMPT
4$:	BIC	#$T3ECL,SDTRS3#(SD)
	TST	SDTRCP#(SD)		;ANY COMMANDS READY NOW?
	BNE	CMDBR0			;YES-GO PROCESS ONE
	BIS	#$T6CMW,SDTRS6#(SD)	;NO-INDICATE READY FOR COMMAND NOW
CMDMO7:	MOV	#INPGET#,SDTROD#(SD)	;RESET OUTPUT DISPATCH VECTOR
	TBBE	$T4SEL,SDTRS4#(SD),2$	;2741 TERMINAL?
	JMP	ENBKEY#			;YES-GO ENABLE ITS KEYBOARD

2$:	JMP	INPGET#			;NO-THATS ALL
	.PAGE
;HERE ON END OF LINE WHEN IN COMMAND MODE
;	ENTRY INDEX = .CXECL

NEXECL:	BIC	#$T3ECL,SDTRS3#(SD)	;INDICATE NOT END OF LINE
	TBBN	$T6PND,SDTRS6#(SD),EATLIN;Ignore if handshake is pending!
	TBBE	$T6CMW,SDTRS6#(SD),RTN002;FORGET IT IF NOT EXPECTING COMMAND
	BIC	#$T1SOP,SDTRS1#(SD);CLEAR SOME BITS
	BIC	#$T6CMW,SDTRS6#(SD)
CMDBR0:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
	BIC	#$T1ACT!$T1ACX,SDTRS1#(SD)
CMDBR1:	TBBE	$T3TRM,SDTRS3#(SD),2$	;ARE WE ASKING FOR TERMINAL TYPE?
	JMP	NEXTRM			;YES

2$:	CALL	GETATM			;NO-GET COMMAND ATOM
	TST	R2			;NULL ATOM?
	BNE	4$			;NO-GO ON
	TST	R0			;YES-NULL LINE?
	BNE	SYNERR			;NO-ERROR
	BR	CMDMO4			;YES-IGNORE IT

;HERE IF NOT NULL ATOM

4$:	MOV	#CMDTBX#,R1		;INDEX FOR COMMAND TABLE
6$:	CMP	R2,CMDTB1#-2(R1)	;THIS ONE?
	BEQ	CMDHAV			;IF MATCH
10$:	DEC	R1			;STEP TO NEXT ENTRY
	SOB	R1,6$			;CONTINUE IF MORE TO CHECK
	INLMES	<"? No such command"<CR><LF>>
CMDBR5:	CALL	EATLIN			;Eat rest of command line
	BR	CMDMO4

;HERE WITH MATCH ON COMMAND ATOM

CMDHAV:	TST	R0			;END OF LINE?
	BEQ	CMDBR6			;YES-OK
	CMP	#SPA,R0			;NO-SPACE?
	BEQ	CMDBR6			;YES-THATS OK TOO
					;NO-FALL INTO SYNTAX ERROR ROUTINE

;HERE ON SYNTAX ERROR IN COMMAND

SYNERR:	INLMES	<"? Syntax error"<CR><LF>>
	BR	CMDBR5

;HERE IF ATOM TERMINATED CORRECTLY

CMDBR6:	JMP	@CMDTBD#-2(R1)		;DISPATCH TO COMMAND ROUTINE
	.PAGE
	.SBTTL	CMDNEX - Connect command

;HERE FOR CONNECT COMMAND FROM TERMINAL

NEXCON::TST	(SD)			;ARE WE ALREADY CONNECTED?
	BEQ	2$			;NO-GO ON
	INLMES	<"? Already connected"<CR><LF>>
	BR	CMDBR5			;FAIL

2$:	CLR	SDTRC4#(SD)		;INDICATE NOT AUTO-CONNECT
CMDCN2:	CLR	R0			;GET FLAG BITS
	CALL	CMDCON#			;CALL COMMON SUBROUTINE FOR CONNECT
	ADD	R1,PC			;DISPATCH ON THE RETURN INDEX
	 BR	SYNERR			; IF SYNTAX ERROR
	 BR	BADDEV			; IF BAD DEVICE NAME
	 BR	NOSP2C			; IF NO PACKET AVAILABLE
	 BR	ATOCON			; IF NULL ARGUMENT
EATLIN:	CALL	GETCMC#			;Eat the rest of the line
RTN002:	  RETURN			;If end of line
	BR	EATLIN			;Continue if more there

;HERE IF BAD DEVICE NAME GIVEN

BADDEV:	INLMES	<"? No such device"<CR><LF>>
	BR	CMDBR5

;HERE IF NO PACKET WAS AVAILABLE

NOSP2C:	JMP	NOSPAC
	.PAGE
	.SBTTL	CMDNEX - Process auto-connect sequence

;HERE TO START AUTO-CONNECT SEQUENCE

ATOCON:	MOV	HCLTBL#-2(R0),SDTRC4#(SD);POINT TO START OF LIST

;HERE TO CONTINUE AUTO-CONNECT SEQUENCE AFTER FAILURE

ATOCN2:	TSTB	@SDTRC4#(SD)		;ANY MORE?
	BNE	CMDCN2			;YES-CONTINUE
					;NO-TELL HIM ABOUT IT
	INLMES	<<CR><LF>"? Cannot connect to host system"<CR><LF>>
	JMP	CMDNK8			;Continue
	.PAGE
	.SBTTL	CMDNEX - RESET COMMAND DECODER

;HERE TO RESET COMMAND DECODER
;	ENTRY INDEX = .CXRST

NEXRST:	MOV	#HUNGUP,R1		;CLEAR POSSIBLE TIMER
	CJMP	TIMKIL#			;AND RETURN
	.PAGE
	.SBTTL	CMDNEX - Process Connect ACK packet

;HERE FOR CONNECT ACK PACKET
;	ENTRY INDEX = .CXACK

NEXACK:	TBBN	$T0SIM,SDTRS0#(SD),CMDAC3;SHOULD WE TYPE THIS MESSAGE?
	INLMES	<"Connected to socket ">;YES
	MOV	SDTRC4#(SD),R1		;GET SOCKET NUMBER
	BEQ	2$			;IF NO SOCKET NUMBER GIVEN!
	CALL	OUTDEC#			;OUTPUT AS DECIMAL VALUE
	BR	CMDAC3			;CONTINUE

;HERE IF NO SOCKET NUMBER GIVEN IN THE ACK PACKET

2$:	INLMES	<"???">
CMDAC3:	BIC	#$T1CMD!$T1ECM,SDTRS1#(SD);LEAVE COMMAND MODE
	MOVB	SDTRBX#(SD),SDTRBS#(SD)	;MAKE CURRENT BREAK SET THE ACTIVE
					;  BREAK SET
	CALL	ENDLIN#
	JMP	CMDBR5			;CONTINUE
	.PAGE
	.SBTTL	CMDNEX - Process Connect NAK packet

;HERE FOR CONNECT NAK PACKET
;	ENTRY INDEX = .CXNAK

NEXNAK:	TST	SDTRC4#(SD)		;ARE WE USING A HOST CONNECT LIST?
	BEQ	2$			;NO-GO ON
	CALL	JNKCPX#			;YES-JUNK THE NAK PACKET
	BR	ATOCN2			;AND CONTINUE WITH THE HOST CONNECT LIST

2$:	BIC	#$S1HLD,SDSTS1#(SD)	;DON'T HOLD OUTPUT NOW
	BIC	#$T3RDC,SDTRS3#(SD)	;INDICATE THIS IS NOT A DISCONNECT!
	TBBN	$T0SFM,SDTRS0#(SD),CMDNK6;If no message wanted
	INLMES	<"? Cannot connect - ">
CMDNK0:	CALL	GETCTL#			;GET REASON FOR FAILURE
	BCS	CMDNK2			;THERE SHOULD BE ONE!
	MOV	R0,SDTRC4#(SD)		;SAVE CODE
CMDNK1:	INLMES	<"Reason = ">
	MOV	SDTRC4#(SD),R1		;RESTORE CODE
	CALL	OUTDEC#			;TYPE THE VALUE OF THE CODE
	INLMES	<": ">
	MOV	SDTRC4#(SD),R0		;GET CODE FOR THE LAST TIME!
	ASL	R0			;FOR WORD INDEXING
	CMP	#CONERX#,R0		;DO WE HAVE A MESSAGE FOR THIS ONE?
	BHI	2$			;YES-GO ON
	CLR	R0			;No-just type some question marks!
2$:	MOV	CONERM#(R0),R1		;GET ADDRESS OF MESSAGE
	CALL	OUTSTR#			;TYPE IT
CMDNK2:	INLMES	<" (">
CMDNK3:	CALL	GETCTL#			;GET NODE NAME WHERE ERROR OCCURED
	BCS	CMDNK5			;IF FINISHED
	CALL	OUTCH0			;OUTPUT CHARACTER
	BR	CMDNK3			;CONTINUE

;HERE AFTER OUTPUTING NAME OF NODE WHICH REPORTED THE PROBLEM

CMDNK5:	INLMES	<")"<CR><LF>>
CMDNK6:	CALL	JNKCPX#			;GIVE UP THE NAK OR DISCONNECT PACKET
	TBBE	$T3RDC,SDTRS3#(SD),CMDNK8;Go on if not here due to disconnect
	MOV	#.PTDAK,R0		;Get a Disconnect ACK packet
	CALL	CTLPKX#
	BCS	1$			;We tried!
	CALL	SNDPKT#			;Send the packet
1$:	TBBN	$S1BC2,SDSTS1#(SD),NEXHNG;Always hang him up if he was connected
					 ;  to
	TBBE	$T0ACD,SDTRS0#(SD),CMDNK8;Does he want auto-connect here?
	MOV	SDTRC4#(SD),R0		;Yes-get reason for the disconnect
	CALL	CHKREA			;Was it a normal disconnect?
	  BR	CMDNK9			;No-try again!
CMDNK8:	TBBE	$T0CMX,SDTRS0#(SD),NEXHNG;Yes-should he stay at command level?
	JMP	NEXCMD			;Yes

	.SBTTL	CMDNEX - RELEASE COMMAND

;HERE FOR RELEASE COMMAND

NEXHNG::MOV	#JIFO2#,R0		;DELAY A HALF SECOND
	MOV	#HUNGUP#,R1		;AND THEN HANG HIM UP
	CJMP	TIMREQ#

CMDNK9:	JMP	CMDATO
	.PAGE
	.SBTTL	CMDNEX - Process Disconnect and Kill packets

;Here for Disconnect or Kill connection packet after initial processing in CMDS
;	Entry index = .CXDIS

NEXDIS:	BIS	#$T3RDC,SDTRS3#(SD)	;INDICATE HAVE RECEIVED DISCONNECT
	TBBN	$T0SFM,SDTRS0#(SD),CMDNK6;Should we type a message?
	CALL	GETCTL#			;Maybe-get reason
	BCS	CMDNK2			;There should be one!
	CALL	CHKREA			;Check the reason
	  BR	10$			;Abnormal reason-always print message
	TBBN	$T0SIM,SDTRS0#(SD),CMDNK6;Does he want "informative" messages?
10$:	MOV	R0,SDTRC4#(SD)		;Yes-save error code
	INLMES	<<CR><LF><CR><LF>"*** Disconnected *** ">
	BR	CMDNK1			;CONTINUE WITH COMMON CODE

	.SBTTL	CMDNEX - Process Disconnect ACK packet

;HERE FOR DISCONNECT ACK PACKET
;	ENTRY INDEX = .CXDAK

NEXDAK:	INLMES	<"Disconnected"<CR><LF>>
CMDDA2:	CALL	JNKCPX#			;GIVE UP THE PACKET
	JMP	CMDBR5			;CONTINUE
	.PAGE
	.SBTTL	CMDNEX - Disconnect command

NEXDCN::TST	(SD)			;CONNECTED NOW?
	BNE	CMDDC1			;YES-GO ON
CMDDC0:	INLMES	<"? Not connected"<CR><LF>>
	JMP	CMDBR5

;HERE IF HAVE A CONNECTION NOW

CMDDC1:	CALL	MAKDSC#			;DISCONNECT
	BCS	NOSPAC			;IF CAN'T GET A PACKET
	RETURN

;HERE IF CAN'T MAKE PACKET

NOSPAC:	BIC	#$T6PND,SDTRS6#(SD)	;CLEAR BIT
	BIS	#$T1CMD!$T1ECM,SDTRS1#(SD);MAKE SURE STAY IN COMMAND MODE
	MOVB	#100,SDTRBS#(SD)
	INLMES	<"? Buffer space full"<CR><LF>>
	JMP	CMDBR5
	.PAGE
	.SBTTL	CMDNEX - Resume command

NEXRSM::TST	(SD)			;CONNECTED NOW?
	BEQ	CMDDC0			;NO-ERROR
	MOV	#.PTINT,R0		;YES-MAKE INTERRUPT PACKET
	CALL	CTLPKT#
	BCS	NOSPAC			;IF NO SPACE!
	MOV	#.FNOPA,R0		;FUNCTION = OUTPUT ALLOW
	CALL	CTLSTE#			;STORE FUNCTION AND SEND PACKET
	JMP	CMDAC3			;GO LEAVE COMMAND MODE
	.PAGE
	.SBTTL	CMDNEX - Terminal command

;THIS COMMAND ACCEPTS A TERMINAL TYPE AND A TERMINAL PROFILE AS ARGUMENTS
;  AND SETS THE TYPE AND PROFILE PARAMETERS ACCORDINGLY

NEXTRM::CALL	GETATX			;GET NEXT ATOM
	TST	R0			;VALID STOPPER?
	BEQ	CMDTR1			;YES
	CMP	#',,R0
	BEQ	CMDTR1			;YES
SYNE3R:	JMP	SYNERR			;NO

CMDTR1:	PUSH	R0			;SAVE STOPPER CHARACTER
	TST	R2			;NULL ATOM?
	BNE	1$			;NO
	MOVB	SDTRTT#(SD),R0		;YES-GET DEFAULT TERMINAL TYPE
	BR	CMDTR5			;CONTINUE

1$:	MOV	#T..MAX*2+2,R0		;GET INDEX FOR TABLE
2$:	CMP	R2,TTPNM1#-2(R0)	;THIS ONE?
	BEQ	4$			;MAYBE
3$:	DEC	R0			;NO
	SOB	R0,2$		;CONTINUE SEARCH IF MORE THERE
	TST	(SP)+			;FIX UP THE STACK
	INLMES	<"? No such terminal type"<CR><LF>>
	BR	CMDB5B			;FAIL

;HERE WITH MATCH ON FIRST PART OF TERMINAL TYPE NAME

4$:	CMP	R3,TTPNM2#-2(R0)	;REALLY THIS ONE?
	BNE	3$			;NO-CONTINUE
	ASR	R0			;YES-FIX UP THE INDEX
	DEC	R0
CMDTR5:	CALL	SETTTP#			;SET TERMINAL TYPE PARAMETERS
	  NOP				;Should not fail!
	TST	(SP)+			;END OF LINE?
	BEQ	TRMDON			;YES-FINISHED
	CALL	GETATX			;GET ANOTHER ATOM
	TST	R0			;ANYTHING AFTER IT?
	BNE	SYNE3R			;YES-COMPLAIN
	TST	R2			;OK-NULL ATOM?
	BEQ	TRMDON			;YES-FINISHED
	MOV	#P..MAX*2+2,R0		;NO-GET INDEX FOR TABLE
12$:	CMP	TPFNM1#-2(R0),R2	;THIS ONE?
	BEQ	14$			;YES
13$:	DEC	R0			;NO
	SOB	R0,12$			;CONTINUE IF MORE TO CHECK
	INLMES	<"? No such terminal profile"<CR><LF>>
	BR	CMDB5B			;FAIL

;HERE WITH MATCH ON FIRST PART OF PROFILE NAME

14$:	CMP	TPFNM2#-2(R0),R3	;REALLY THIS ONE?
	BNE	13$			;NO-CONTINUE CHECKING
	ASR	R0			;YES-FIX UP THE INDEX
	DEC	R0
	CALL	SETPRF#			;SET PROFILE PARAMETERS
	  NOP				;Should not fail!
TRMDON:	TBBE	$T3TRM,SDTRS3#(SD),CMDMX0;WERE WE ASKING FOR TERMINAL TYPE?
	BIC	#$T3TRM,SDTRS3#(SD)	;YES-CLEAR TERMINAL QUESTION FLAG
	JMP	CMDMO3			;AND GO TELL HIM WHO WE ARE
	.PAGE
	.SBTTL	CMDNEX - Parameter command

NEXPAR::CALL	GETATM			;GET NEXT ATOM
	TST	R2			;NULL ATOM?
	BNE	2$			;NO-GO ON
	JMP	DSPPAR			;YES-GO DISPLAY ALL PARAMETERS

2$:	MOV	#CMDTSX#,R4		;GET INDEX FOR TABLE
4$:	CMP	R2,CMDTS1#-2(R4)	;THIS ONE?
	BEQ	CMDSE4			;IF MATCH
	DEC	R4			;STEP TO NEXT ENTRY
	SOB	R4,4$			;CONTINUE IF MORE TO CHECK
	INLMES	<"? No such settable parameter"<CR><LF>>
CMDB5B:	JMP	CMDBR5			;GO CLEAN UP

;HERE WITH MATCH ON PARAMETER NAME

CMDSE4:	MOVB	CMDIDX#-2(R4),R0	;GET DISPATCH INDEX
	JMP	@DSPSET#(R0)		;DISPATCH TO ROUTINE FOR PARAMETER

;HERE FOR PARAMETERS WHICH SET BITS "ON" OR "OFF"

SETBIT::CALL	GETATM			;GET NEXT ATOM
	TST	R0			;END OF LINE?
	BNE	SYNE4R			;NO-ERROR
	TST	R2			;ANY ARGUMENT GIVEN?
	BEQ	SETBI2			;NO-GO OUTPUT CURRENT VALUE
	MOVB	CMDTST#-2(R4),R1	;GET OFFSET OF BYTE
	ADD	SD,R1			;PLUS ADDRESS OF SDB
	TST	R3			;MUST BE 3 CHARACTERS OR LESS
	BNE	SYNE4R
	CMP	#^RON ,R2		;DID HE SAY "ON"?
	BEQ	SETBON			;YES
	CMP	#^ROFF,R2		;DID HE SAY "OFF"?
	BNE	SYNE4R			;NO-ERROR
SETBOF:	BICB	CMDTSB#-2(R4),(R1)	;YES-CLEAR BIT IN TABLE
CMDMX0:	JMP	CMDMO4			;CONTINUE

;HERE TO SET BIT

SETBON:	BISB	CMDTSB-2(R4),(R1)	;SET BIT IN TABLE
	BR	CMDMX0			;FINISHED

;HERE TO OUTPUT CURRENT VALUE (ON OR OFF)

SETBI2:	CALL	SETOUT			;OUTPUT INITIAL STUFF
	BITB	CMDTSB-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTONO			;OUTPUT "ON" OR "OFF"
	BR	SETCH9			;GO FINISH UP

;HERE FOR PARAMETERS WHICH SET BITS FOR "REAL" OR "SIMULATED"

SETSIM::CALL	GETATM			;GET NEXT ATOM
SETSI1:	TST	R0			;END OF LINE?
	BNE	SYNE4R			;NO-ERROR
	TST	R2			;WAS ARGUMENT GIVEN?
	BEQ	SETSI4			;NO
	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE
	ADD	SD,R1			;PLUS SDB ADDRESS
	CMP	#^RREA,R2		;DID HE SAY "REAL"?
	BNE	SETSI2			;NO
	TST	R3			;OK IF ONLY 3 CHARACTERS
	BEQ	SETBOF
	CMP	#^RL  ,R3		;MAYBE
	BEQ	SETBOF			;YES
SYNE4R:	JMP	SYNERR			;NO-ERROR

;HERE IF HE DID NOT SAY "REAL"

SETSI2:	CMP	#^RSIM,R2		;DID HE SAY "SIMULATED"?
	BNE	SYNE4R			;NO-ERROR
	TST	R3			;OK IF ONLY 3 CHARACTERS
	BEQ	SETBON
	CMP	#^RULA,R3		;MAYBE
	BEQ	SETBON			;YES
	BR	SYNE4R			;NO-ERROR

;HERE TO TYPE CURRENT VALUE (REAL OR SIMULATED)

SETSI4:	CALL	SETOUT			;DO INITIAL OUTPUT
	BITB	CMDTSB-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTSMR			;OUTPUT "SIMULATED" OR "REAL"
	BR	SETCH9			;CONTINUE

;HERE FOR PARAMETER WHICH SETS NUMBERIC VALUE

SETVAL::CALL	GETDEC#			;GET VALUE
	BCS	SETVA6			;IF NO VALUE GIVEN
SETVA2:	TST	R0			;END OF LINE?
	BNE	SYNE4R			;NO-ERROR
	MOVB	CMDTST-2(R4),R3		;GET OFFSET OF BYTE
	ADD	SD,R3			;PLUS ADDRESS OF SDB
	MOVB	R1,(R3)			;STORE VALUE
	BR	CMDMX0			;FINISHED

;HERE IF NO VALUE GIVEN

SETVA6:	TST	R0			;END OF LINE?
	BNE	SYNE4R			;NO-ERROR
	CALL	SETOUT			;DO INITIAL OUTPUT
	MOVB	(R1),R1			;GET VALUE
	BIC	#^C377,R1		;REMOVE JUNK
	CALL	OUTDEC#			;OUTPUT IT
	BR	SETCH9			;GO FINISH UP

;HERE FOR PARAMETER WHICH SETS A CHARACTER

SETCHR::CALL	SETCSB			;DO MOST OF THE WORK
	BCS	SYNE4R			;IF ERROR
	BEQ	SETCH3			;IF NO CHARACTER GIVEN
SETCH2:	MOVB	R0,(R1)			;STORE CHARACTER
	BR	CMDMY0			;FINISHED

;HERE FOR PARAMETER WHICH SETS A CHARACTER WHICH MUST BE A CONTROL CHARACTER

SETCCH::CALL	SETCSB			;DO MOST OF THE WORK
	BCS	SYNE4R			;IF ERROR
	BEQ	SETCH3			;FINISHED IF NO CHARACTER GIVEN
	CMP	#SPA,R0			;DID HE GIVE USE A CONTROL CHARACTER?
	BGT	SETCH2			;YES-GO STORE IT
	INLMES	<"? Must be control character"<CR><LF>>
	JMP	CMDBR5			;CONTINUE

;HERE IF NO CHARACTER GIVEN - TYPE CURRENT CHARACTER

SETCH3:	CALL	SETOUT			;OUTPUT INITIAL STUFF
	MOVB	(R1),R0			;GET CHARACTER
	CALL	OUTCXX			;OUTPUT CHARACTER
SETCH9:	CALL	ENDLIN#
CMDMY0:	JMP	CMDMO4			;FINISHED
	.PAGE
;SUBROUTINE TO DO MOST OF THE WORK FOR PARAMETERS WHICH SET A CHARACTER
;	CALL	SETCSB
;	Z:CLR = CHARACTER TYPED, C(R0) = CHARACTER
;	Z:SET = NO CHARACTER TYPED, C(R4) = INDEX FOR PARAMETER
;	C:SET = SYNTAX ERROR

SETCSB:	CALL	EATBLK#			;GET NEXT NON-BLANK CHARACTER
	BEQ	RTN005			;IF NO CHARACTER GIVEN
	CMP	#'^,R0			;IS HE SPECIFYING A CONTROL CHARACTER?
	BNE	SETCS4			;NO-GO ON
	CALL	GETCMC#			;YES-GET NEXT CHARACTER
	  BR	2$			;If end of line
	BR	SETCS2			;GO ON IF HAVE ANOTHER

2$:	MOV	#'^,R0			;END OF LINE-NOT CONTROL CHARACTER!
	BR	SETCS5			;CONTINUE

;HERE TO CHANGE PRINTING CHARACTER TO CONTROL CHARACTER

SETCS2:	CMP	#140,R0			;LOWER CASE CHARACTER?
	BGT	SETCS3			;NO-GO ON
	BIC	#40,R0			;YES-CHANGE TO UPPER CASE
SETCS3:	CMP	#'A,R0			;VALID CONTROL CHARACTER?
	BGT	RTNCS5			;NO-ERROR
	CMP	#'_,R0			;MAYBE
	BLT	RTNCS5			;NO
	BIC	#100,R0			;YES-CHANGE TO CONTROL CHARACTER
SETCSX:	PUSH	R0			;SAVE THE CHARACTER
SETCX2:	CALL	GETCMC#			;TRY TO GET NEXT CHARACTER
	  BR	SETCS6			;OK if end of line
	BR	SETCS8

SETCS6:	POP	R0			;RESTORE CHARACTER
SETCS5:	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE
	ADD	SD,R1			;PLUS SDB ADDRESS
	CLC				;MAKE SURE C IS CLEAR
RTN005:	RETURN				;RETURN (Z IS CLEAR)

;HERE IF NORMAL PRINTING CHARACTER

SETCS4:	PUSH	R0			;SAVE THE CHARACTER
	CALL	GETAT0			;GET ATOM FROM NEXT CHARACTERS
	TST	R2			;NULL ATOM?
	BEQ	SETCX2			;YES-MUST HAVE BEEN NON-LETTER
	TST	R0			;END OF LINE NEXT?
	BNE	SETCS8			;NO-ERROR
	MOV	R2,R1			;YES-JUST ONE LETTER?
	CLR	R0
	DIV	#3100,R0
	TST	R1
	BEQ	SETCX2			;YES
	MOV	R4,(SP)			;SAVE R4
	MOV	#CMXDEX#,R4		;INIT INDEX
2$:	CMP	CMXDE1#-2(R4),R2	;THIS ONE?
	BEQ	SETCS9			;YES
	DEC	R4			;DECREMENT INDEX
	SOB	R4,2$			;CONTINUE IF MORE TO CHECK
SETCS8:	TST	(SP)+			;FIX UP THE STACK
RTNCS5:	SEC				;SET C
	RETURN

;HERE WITH MATCH ON ATOM

SETCS9:	MOVB	CMXDEL#-2(R4),R0	;GET CHARACTER
	POP	R4			;RESTORE R4
	BR	SETCS5			;CONTINUE
	.PAGE
;SUBROUTINE TO OUTPUT PARAMETER NAME FOLLOWED BY " = "
;	C(R4) = INDEX FOR COMMAND TABLES
;	CALL	SETOUT
;	C(R1) = ADDRESS OF DATA TABLE FOR PARAMETER
;	C(R4) = UNCHANGED

SETOUT:	POP	SDTRC2#(SD)		;SAVE RETURN ADDRESS
	MOVB	R4,SDTRC4#(SD)		;SAVE INDEX
	MOV	CMDTS1-2(R4),R1		;TYPE PARAMETER
	CALL	OUTRDX
	INLMES	<" = ">
	MOVB	SDTRC4#(SD),R4		;RESTORE INDEX
	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE CONTAINING CHAR
	ADD	SD,R1			;PLUS SDB ADDRESS
	JMP	@SDTRC2#(SD)		;RETURN

SYNE5R:	JMP	SYNERR
	.PAGE
;HERE TO DISPLAY ALL PARAMETER VALUES

DSPPAR:	TST	R0			;END OF LINE?
	BNE	SYNE5R			;NO-ERROR
	INLMES	<<CR><LF>"Terminal type = ">
	MOVB	SDTRCT#(SD),R0		;GET TERMINAL TYPE
	ASL	R0
	MOV	TTPNM1#(R0),R1		;GET FIRST 3 CHARACTERS
	CALL	OUTRDX			;OUTPUT THEM
	MOVB	SDTRCT#(SD),R0		;GET TYPE AGAIN
	ASL	R0
	MOV	TTPNM2#(R0),R1		;GET SECOND 3 CHARACTERS
	CALL	OUTRDX			;OUTPUT THEM
	INLMES	<<CR><LF><CR><LF>"Terminal tyrameters"<CR><LF>>
	MOV	#2,SDTRC4#(SD)		;INITIALIZE INDEX
CMDPA1:	CMP	#PRFPAR#+2,SDTRC4#(SD)	;IS THIS FIRST PROFILE PARAMETER?
	BNE	CMDPA2			;NO-GO ON
	INLMES	<<CR><LF><CR><LF>"Terminal profile parameters"<CR><LF>>
CMDPA2:	MOVB	SDTRC4#(SD),R4		;GET INDEX
	CALL	SETOUT			;DO FIRST PART
	MOVB	CMDIDX#-2(R4),R2	;GET DISPATCH ADDRESS
	JMP	@DSPPRT#(R2)		;GO OUTPUT VALUE

;HERE TO OUTPUT PARAMETER AS "ON" OR "OFF"

PARBIT::BITB	CMDTSB#-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTONO			;OUTPUT "ON" OR "OFF"
	BR	PARFIN			;CONTINUE

;HERE TO OUTPUT VALUE AS "REAL" OR "SIMULATED"

PARSIM::BITB	CMDTSB#-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTSMR			;OUTPUT "REAL" OR "SIMULATED"
	BR	PARFIN			;CONTINUE

;HERE TO OUTPUT VALUE AS DECIMAL VALUE

PARVAL::MOVB	(R1),R1			;GET VALUE
	BIC	#^C377,R1		;REMOVE JUNK
	CALL	OUTDEC#			;OUTPUT IT
	BR	PARFIN			;CONTINUE

;HERE TO OUTPUT VALUE AS ASCII CHARACTER

PARCHR::MOVB	(R1),R0			;GET CHARACTER
	CALL	OUTCXX			;OUTPUT THE CHARACTER
PARFIN:	ADD	#2,SDTRC4#(SD)		;INCREMENT INDEX
	CMP	#CMDTSX,SDTRC4#(SD)	;FINISHED YET?
	BLT	CMDPA5			;YES-GO ON
	MOV	#20.,R4			;GET FIELD SIZE
	CALL	ENDFLD			;END THIS FIELD
	BR	CMDPA1			;CONTINUE

;HERE WHEN FINISHED

CMDPA5:	CALL	ENDLIN#
	JMP	CMDMO4
	.PAGE
	.SBTTL	CMDNEX - Command processor subroutines

;Subroutine to check for normal Disconnect or NAK reason code
;	C(R0) = reason code
;	CALL	CHKREA
;	  return if abnormal reason
;	return if normal reason

CHKREA:	CMPB	#.ERREQ,R0		;Is this a normal reason?
	BEQ	4$			;Yes
	CMPB	#.ERTRM,R0
	BEQ	4$
	CMPB	#.ERRLS,R0
	BNE	10$			;No!
4$:	ADD	#2,(SP)			;Yes-give skip return
10$:	RETURN

;SUBROUTINE TO TERMINATE FIELD FOR PARAMETER COMMAND
;	C(R4) = SIZE OF FIELD
;	CALL	ENDFLD

ENDFLD:	CLR	R0			;GET POSITION ON LINE
	BISB	SDTRHP#(SD),R0
	MOV	R0,R3			;COPY IT
	CLR	R2			;CALCULATE END OF FIELD
	DIV	R4,R2
	INC	R2
	MUL	R4,R2
	CLR	R1			;GET LINE WIDTH
	BISB	SDTRLW#(SD),R1
	BNE	2$			;IF WIDTH SET
	MOV	#72.,R1			;DEFAULT IS 72.
2$:	SUB	R4,R1			;WILL ANOTHER FIELD FIT?
	CMP	R3,R1
	BGT	14$			;NO
	SUB	R3,R0			;YES-CALCULATE NUMBER OF SPACES NEEDED
	POP	SDTRC3#(SD)		;SAVE RETURN ADDRESS
	MOV	R0,SDTRC2#(SD)		;SAVE COUNT
	MOV	#10$,SDTROD#(SD)	;SET OUTPUT DISPATCH
10$:	INC	SDTRC2#(SD)		;NEED MORE?
	BGT	OUTDON			;NO-FINISHED
	MOV	#SPA,R0			;YES-GET A SPACE
	BR	OUTCH1			;AND GO OUTPUT IT

;HERE IF ANOTHER FIELD WILL NOT FIT ON THIS LINE

14$:	JMP	ENDLIN#			;END THE LINE
	.PAGE
;SUBROUTINE TO OUTPUT ONE WORD AS 3 RADIX-50 CHARACTERS
;	C(R1) = WORD TO OUTPUT
;	CALL	OUTRDX

OUTRDX:	POP	SDTRC3#(SD)		;SAVE RETURN ADDRESS
	TST	R1			;NULL ITEM?
	BEQ	OUTDON			;YES-DO NOTHING!
	CLR	R0			;DIVIDE
	DIV	#50,R0			;TO GET 3RD CHARACTER
	MOVB	R1,SDTRC1#+1(SD)	;SAVE 3RD CHARACTER
	MOV	R0,R1			;DIVIDE
	CLR	R0			;TO GET 2ND CHARACTER
	DIV	#50,R0
	MOVB	R1,SDTRC1#(SD)		;SAVE 2ND CHARACTER
	CALL	OUTCHX			;OUTPUT 1ST CHARACTER
	MOVB	SDTRC1#(SD),R0		;GET 2ND CHARACTER
	BEQ	OUTDON			;FINISHED IF SPACE
	CALL	OUTCHX			;OUTPUT 2ND CHARACTER
	MOVB	SDTRC1#+1(SD),R0	;GET 3RD CHARACTER
	BEQ	OUTDON			;FINISHED IF SPACE
	CALL	OUTCHX			;OUTPUT 3RD CHARACTER
OUTDON:	BIC	#$T1ACT!$T1ACX,SDTRS1#(SD);CLEAR OUTPUT ACTIVE FLAG
	JMP	@SDTRC3#(SD)		;RETURN
	.PAGE
;SUBROUTINE TO OUTPUT "ON" OR "OFF"
;	Z:SET = OUTPUT "OFF"
;	Z:CLR = OUTPUT "ON"
;	CALL	OUTONO

OUTONO:	BEQ	OUTON2			;IF BIT NOT SET
	MOV	#MSBTON,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;HERE IF BIT IS SET

OUTON2:	MOV	#MSBTOF,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;SUBROUTINE TO OUTPUT "REAL" OR "SIMULATED"
;	Z:SET = OUTPUT "REAL"
;	Z:CLR = OUTPUT "SIMULATED"
;	CALL	OUTSMR

OUTSMR:	BEQ	OUTSM2			;IF BIT NOT SET
	MOV	#MSBTSM,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;HERE IF BIT IS NOT SET

OUTSM2:	MOV	#MSBTRL,R1		;GET ADDRESS OF MESSAGE
OUTSR1:	JMP	OUTSTR#			;AND GO OUTPUT IT
	.PAGE
;SUBROUTINE TO OUTPUT SINGLE CHARACTER WHICH MAY BE CONTROL CHARACTER
;	C(R0) = CHARACTER TO OUTPUT
;	CALL	OUTCXX

OUTCXX:	POP	SDTRC3#(SD)		;STORE RETURN ADDRESS
	CMP	#DEL,R0			;IS IT RUBOUT?
	BEQ	OUTCX4			;YES
	CMP	#SPA,R0			;IS IT A PRINTING CHARACTER?
	BLT	OUTCX1			;YES
	BEQ	OUTCX2			;IF IT IS A SPACE
	MOV	R0,SDTRC2#(SD)		;CONTROL CHARACTER-STORE CHARACTER
	BEQ	OUTCX6			;IF NULL
	INLMES	<"^">
	MOV	SDTRC2#(SD),R0		;RESTORE CHARACTER
	BIS	#100,R0			;CHANGE TO PRINTING CHARACTER
OUTCX1:	CALL	OUTCH0			;OUTPUT IT
	BR	OUTDON			;AND RETURN

;HERE IF CHARACTER IS SPACE

OUTCX2:	MOV	#SPAMES,R1		;GET MESSAGE
	BR	OUTCX7			;AND OUTPUT IT

;HERE IF CHARACTER IS RUB-OUT

OUTCX4:	MOV	#RUBMES,R1		;GET MESSAGE
	BR	OUTCX7			;AND OUTPUT IT

;HERE IF CHARACTER IS NULL (NO CHARACTER STORED)

OUTCX6:	MOV	#NULMES,R1		;GET MESSAGE
OUTCX7:	JMP	OUTST1#			;AND OUTPUT IT

;SUBROUTINE TO OUTPUT RADIX-50 CHARACTER
;	C(R0) = CHARACTER TO OUTPUT
;	CALL	OUTCHX

OUTCHX:	CMP	#33,R0			;Convert to ASCII valuee
	BGT	3$			;If letter
	BEQ	1$			;If $
	CMP	#35,R0
	BNE	2$			;If number of period
	MOV	#66,R0			;If undefined character (convert to ?)
1$:	SUB	#11,R0
2$:	SUB	#56,R0
3$:	ADD	#100,R0
					;Fall into OUTCH0

;SUBROUTINE TO OUTPUT SINGLE CHARACTER
;	C(R0) = ASCII CHARACTER TO OUTPUT
;	CALL	OUTCH0

OUTCH0:	POP	SDTROD#(SD)		;SET OUTPUT DONE DISPATCH ADDRESS
OUTCH1:	JMP	OUTCHR#			;AND GO START OUTPUT
	.PAGE
;SUBROUTINE TO FETCH COMMAND ATOM
;	CALL	GETATM		;ENTER AT GETATX IF WANT DIGITS TOO
;	C(R2) = FIRST HALF OF ATOM (RADIX-50)
;	C(R3) = SECOND HALF OF ATOM (RADIX-50)

GETATM:	MOV	(PC)+,-(SP)		;SET WORD NON-0 AS FLAG THAT WE DO NOT
					;  WANT DIGITS - THIS SKIPS NEXT INSTR.
GETATX:	CLR	-(SP)			;CLEAR WORD AS FLAG THAT WE WANT DIGITS
	CALL	EATBLK#			;SKIP PAST LEADING BLANKS
	POP	R2			;GET FLAG WORD INTO R2
GETAT0:	CALL	GETX5A			;CONVERT FIRST CHARACTER TO RADIX-50
	CALL	GETAT5			;GET FIRST ATOM
	BCC	GETAT1			;CONTINUE IF MORE
	MOV	R3,R2			;FINISHED-STORE 1ST HALF IN RIGHT PLACE
	CLR	R3			;CLEAR 2ND HALF
RTN007:	RETURN				;RETURN

;HERE IF THERE ARE MORE THAN 3 CHARACTERS IN THE ATOM

GETAT1:	PUSH	R3			;SAVE 1ST PART OF ATOM
	CALL	GETX50			;GET FIRST CHARACTER
	CALL	GETAT5			;GET 2ND PART OF ATOM
	BCS	GETAT3			;IF FINISHED
GETAT2:	CALL	GETX50			;MORE THERE-EAT NEXT CHARACTER
	BCC	GETAT2			;LOOP IF MORE TO EAT
GETAT3:	POP	R2			;RESTORE FIRST PART OF ATOM
	RETURN				;RETURN

;SUBROUTINE USED BY GETATM TO FETCH EACH HALF OF THE ATOM
;	C(R0) = RADIX 50 CODE FOR FIRST CHARACTER
;	C(R2) = 0 IF WANT DIGITS, NON-0 IF DO NOT
;	CALL	GETAT5
;	C(R0) = TERMINATING CHARACTER IF LESS THAN 3 CHARACTERS
;	C(R2) = UNCHANGED
;	C(R3) = RADIX-50 PACKED OUTPUT
;	C:SET = ATOM CONTAINS 3 CHARACTERS OR LESS

GETAT5:	BCS	GETAT6			;IF INVALID CHARACTER
	MOV	R0,R3			;GET IN RIGHT AC
	MUL	#<50*50>,R3		;GET CHARACTER IN RIGHT PLACE
	CALL	GETX50			;GET NEXT CHARACTER
	BCS	RTN007			;IF INVALID CHARACTER
	MUL	#50,R0			;PUT IN RIGHT PLACE IN THE WORD
	ADD	R1,R3			;ADD IN
	CALL	GETX50			;GET LAST CHARACTER
	BCS	RTN007			;IF INVALID CHARACTER
	ADD	R0,R3			;ADD IN CHARACTER
RTNCC7:	CLC
	RETURN				;RETURN

;HERE IF THIS PART OF ATOM IS NULL

GETAT6:	CLR	R3
RTNCS7:	SEC
	RETURN

;SUBROUTINE USED BY GETATM TO FETCH CHARACTER AS RADIX-50 VALUE
;	C(R2) = 0 IF WANT DIGITS, NON-0 IF DO NOT
;	CALL	GETX50
;	C(R0) = CHARACTER (RADIX-50 VALUE IF VALID RADIX-50 CHARACTER, ASCII
;		  VALUE OTHERWISE)
;	C:SET = NOT VALID RADIX-50 CHARACTER

GETX50:	PUSH	R3			;SAVE R3
	PUSH	R2			;AND R2
	CALL	GETCMC#			;GET CHARACTER
	  CLR	R0			;If end of line
	POP	R2			;RESTORE R2
	POP	R3			;AND R3
GETX5A:	TST	R0
	BEQ	RTNCS7			;IF NOTHING THERE
	CMP	#140,R0			;LOWER CASE?
	BGT	GETX5B			;NO-GO ON
	BIC	#40,R0			;YES-MAKE UPPER CASE
GETX5B:	CMP	#'A,R0			;IS IT A LETTER?
	BGT	GETX5C			;NO
	CMP	#'Z,R0			;MAYBE
	BLT	RTNCS7			;NO
	BIC	#^C77,R0		;YES-CONVERT TO RADIX-50 CODE
	BR	RTNCC7			;CLEAR C AND RETURN

;HERE IF NOT A LETTER

GETX5C:	TST	R2			;DO WE WANT DIGITS?
	BNE	RTNCS7			;NO
	CMP	#'0,R0			;YES-IS THIS A DIGIT?
	BGT	RTNCS7			;NO
	CMP	#'9,R0			;MAYBE
	BLT	RTNCS7			;NO
	SUB	#22,R0			;YES-CONVERT TO RADIX-50
	BR	RTNCC7			;AND RETURN
	.PAGE
	.SBTTL	CMDNEX - Text strings

	PURE

MSBTON:	.ASCIZ	"On"
MSBTOF:	.ASCIZ	"Off"
MSBTRL:	.ASCIZ	"Real"
MSBTSM:	.ASCIZ	"Sim"
SPAMES:	.ASCIZ	"Space"
RUBMES:	.ASCIZ	"Rubout"
NULMES:	.ASCIZ	"None"
	.EVEN

	.END
                                                                                                                                                                                                                                                                                                                                                          @@G¡