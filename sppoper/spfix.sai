BEGIN "SpFix"

external integer !skip!;
let r!p=record!pointer, a!c=any!class;

external boolean rpgsw;

REQUIRE "(SAILIB)EXTEND.REQ" SOURCE!FILE;
REQUIRE "CMDPRO.HDR" SOURCE!FILE;
REQUIRE "CMDPRO" LOAD!MODULE;

REQUIRE "CHNREC.HDR" SOURCE!FILE;
REQUIRE "CHNREC" LOAD!MODULE;


REQUIRE 4001 NEW!ITEMS;
REQUIRE 4001 PNAMES;

COMMENT SPOOL file maintenance tool.
	Needs work, commenting & documentation.
;

REQUIRE '003000 VERSION;

REQUIRE "<><>" DELIMITERS;

COMMENT  MainVer will allow compiling of the main version to be used by
         Spool Maintainer from SPPOPER, and also the more limited version
         to be used by Operations and Systems Resources from UTIL. ;

DEFINE Debug = <FALSE>,
       MainVer = <TRUE>,
       !bit(x) = <(1 lsh (35-(x)))>;

ifc Debug
   thenc DEFINE SplDir = <"(SPPOPER)">,
		BatDir = <"(SPPOPER)">;
   elsec DEFINE SplDir = <"(SPOOL)">,
		BatDir = <"(*1BATCH)">;
endc

COMMENT File names for the main data base files and their backups--
	excludes those names that depend on month and/or system;

DEFINE	GdfFile		= <SplDir & "SPOOL.GDF">,
	GdfBak		= <SplDir & "SPOOL.GBK">,
	NewGdfFile	= <SplDir & "SPOOL.GNW">,
	TmpGdfFile	= <SplDir & "GDF.TMP">,
	LostGdfFile	= <SplDir & "LOST.GDF">,
	BadGdfFile	= <SplDir & "BAD.GDF">,
	FdfFile		= <SplDir & "SPOOL.FDF">,
	FdfBak		= <SplDir & "SPOOL.FBK">,
	NewFdfFile	= <SplDir & "SPOOL.FNW">,
	TmpFdfFile	= <SplDir & "FDF.TMP">,
	OldFdfFile	= <SplDir & "OLD.FDF">,
	LostFdfFile	= <SplDir & "LOST.FDF">,
	BadFdfFile	= <SplDir & "BAD.FDF">,
	MapFile		= <SplDir & "SPOOL.MAP">,
	MapBak		= <SplDir & "SPOOL.MBK">,
	NewMapFile	= <SplDir & "SPOOL.MNW">,
	CenFile		= <SplDir & "SPLCNT">,
	RemFile		= <SplDir & "REMCNT">,
	TapFile		= <SplDir & "SPOOL.TAP">,
	ParFile		= <BatDir & "PARCHG.DAT">,
	ParNew		= <BatDir & "PARCHG.NEW">,
	SplFile		= <BatDir & "SPLCHG.DAT">,
	SplNew		= <BatDir & "SPLCHG.NEW">,
	NewLogFile	= <SplDir & "SPOOL.LOG">,
	TmpLogFile	= <SplDir & "SPLLOG.TMP">,
        CompFile        = <SplDir & "SPLCOM.FIL">,
        Spooltap        = <SplDir & "SPOOL.TAP">;

DEFINE	Crlf   = <('15&'12)>,	Crlf2	= <('15&'12&'15&'12)>,
	Spaces = <"                                        ">,
	Easy   = <SIMPLE>,	Eif	= <ELSE IF>,
	Inc(x) = <x_1+x>,	AllRdNo	= <'047>,
	!      = <COMMENT>,	DSCR = <COMMENT>,
	KLUDGE = <COMMENT>,	Calli!Gettab = <'41>,
	!XWD(A,B) = <((A lsh 18) lor (B land '777777))>;


LET	r!c = RECORD!CLASS,	r!p = RECORD!POINTER,
	n!r = NULL!RECORD;

KLUDGE  Expansions, fixups, other stuff this needs:
	Some of the "hardwired" things here could be parameterized.
	Needs some more cleaning up.
	Additions needed:
	1) Add print routines to allow user to examine records.
	2) Add routines to search for & examine particular requests.
	3) NEEDS EXTERNAL DOCUMENTATION!!!!
;
r!p(Chan) OldLogPtr,NewLogPtr,TmpLogPtr;	! For log files;
string LogFilNam;				! also for log files;
integer var;
boolean DidClean;				! Do Clean only once;


simple procedure LicenseCheck;
DSCR Checks to be sure SPFIX or the user of SPFIX has WF license set.
;
BEGIN  integer UserLic;
DEFINE  !GTLIC = <-'20>,
	LC!WF = <'2000000>;
	
    UserLic _ calli(!xwd(-1,!GTLIC),calli!Gettab);
    if (UserLic land LC!WF = 0) then
      BEGIN
      print( "Need WF license to continue.",crlf);
      calli(0,'12);		! Exit;
      END;
END;

! ****  Utility Procedures ****;

Easy boolean procedure Affirm(string Prompt);
DSCR prints Prompt on the terminal and then asks for a yes or
     no response (a yes response is anything beginning with y
     and a no is anything beginning with n).
     Note that only the first character of the user's input is
     checked.  This allows responses like 'yep' or 'no way' or
     'yas'.
     It is assumed that a TTYUP(true) has been done.
;
BEGIN "Affirm" string Reply;
while true do
  BEGIN
    print(Crlf, prompt, " [Yes or No] *");
    if (Reply_inchwl) = "Y"
      then return(true)
      eif Reply = "N"
        then return(false);
  END;
END "Affirm";


Easy boolean procedure Confirm( String Prompt);
DSCR prints Prompt on the terminal and asks for confirmation.  Returns
     TRUE if user inputs a null string or anything beginning with "Y"
     and otherwise returns FALSE.
;
BEGIN "Confirm" String CReply;
CReply_null;
print(Crlf, prompt, " [CONFIRM] ");
if not length(CReply_inchwl) or (CReply="Y")
  then return(true)
  else return(false);
END "Confirm";


integer array DateBuf[0:2];  ! For use with DATE UUO;

preload!with
"JAN", "FEB", "MAR", "APR", "MAY", "JUN",
"JUL", "AUG", "SEP", "OCT", "NOV", "DEC";
string array Month[1:12];


simple string procedure PrintDate(integer DecDat);
DSCR Presumes that the argument is a date in DEC format and returns a
     string in the form dd-mon-yy.
;
BEGIN "PrintDate"
if DecDat<0 then return(null);		! An obviously bad argument;
return(cvs((DecDat mod 31) + 1) & "-" &
       Month[((DecDat div 31) mod 12) + 1] & "-" &
       cvs(((DecDat div 31) div 12) + 64) );
END "PrintDate";


simple string procedure PrintTime;
DSCR Prints the date and time in DateBuf in the format
     dd-mmm-yy hh:mm.
;
BEGIN integer TmpHr, TmpMin;
TmpHr_DateBuf[1] div (3600*60);
TmpMin_(DateBuf[1] div 3600) mod 60;
return( cvs((DateBuf[0] mod 31) + 1) & "-" &
	Month[((DateBuf[0] div 31) mod 12) + 1] & "-" &
	cvs(((DateBuf[0] div 31) div 12) + 64) & " " &
	(if TmpHr > 9 then null else "0") &
	cvs(TmpHr) & ":" &
	(if TmpMin > 9 then null else "0") &
	cvs(TmpMin) );
END;


simple string procedure SetTime;
DSCR Sets DateBuf to contain the current date and time.  If less than
     5 sec. past midnight, get date again to make sure we got it right.
;
BEGIN
DateBuf[0]_calli(1,'14);
If (DateBuf[1]_calli(1,'22)) leq 300
  then DateBuf[0]_calli(1,'14);
END;


integer PurgeDate;  ! Set to DEC date for 1st day of preceeding month;
integer CurDate;    ! Set to current DEC date;
integer CurMon;     ! Set to current month number (0-12);
integer CurYear;    ! Set to current year number (2 digits);
integer TimeZone;   ! Set to user's time zone (monitor format);
integer PrivWd;     ! Set to user's privelige word (see the YAMM);
integer Six!Sysno;  ! Set to system number as RIGHT-justified sixbit;
string SysNo;       ! Set to system number;
string SysCity;     ! Set to name of city in which system is located;
string VerNum;	    ! Set to be the program version number;


simple procedure Set!Params;
DSCR This procedure initializes the above globals at run-time.
     A phase 2 initialization procedure.
;
BEGIN integer PartDate, PurgeYear, PurgeMonth;
      string SysWhere;
SetTime;			! Set current date and time in DateBuf;
! Now get user's time zone.  This is stored in bits 2-7 of the user's
  privelige word;
PrivWd_Calli('777777000006,'41);
TimeZone_(PrivWd land '176000000000) lsh -28;

CurDate_DateBuf[0];		! Save current DEC date;
PartDate_CurDate div 31;
PurgeMonth_PartDate mod 12;	! This is current month-1;
CurMon_PurgeMonth+1;		! The current month;
CurYear_(PartDate div 12) + 64;	! Set the current year;
if PurgeMonth=0			! Now set the purge year;
  then BEGIN PurgeYear_(PartDate div 12)-1; PurgeMonth_12; END
  else PurgeYear_PartDate div 12;
PurgeDate_((PurgeYear*12)+(PurgeMonth-1))*31;
SysNo_cvastr(calli('11,'41))[1 to 4];	! Sys loc and number;
SysWhere_lop(SysNo);			! Sets both SysWhere and SysNo;
if SysNo[inf to inf]="-"
  then SysNo_SysNo[1 to inf-1]
  else SysNo_SysNo[2 to 3];		! Kludge for 3-digit system nos;
Six!SysNo_cvsix(SysNo) lsh -24; 	! Note:  right-justified sixbit;
if SysWhere="C"
  then SysCity_"Cupertino"
  else if SysWhere="H" then SysCity_"Houston"
  else if SysWhere="V" then SysCity_"Valley Forge"
  else if SysWhere="P" then SysCity_"Paris"
  else if SysWhere="F" then SysCity_"Fremont"
  else if SysWhere="D" then SysCity_"Dallas"
  else if SysWhere="L" then SysCity_"Lockheed"
  else if SysWhere="S" then SysCity_"Experimental Machine Room"
  else SysCity_"LIMBO";			! Letter code not known;


! Set program version number:  Major version number is the first 3
  octal digits of low order half of .JBVER and minor ver. num is the
  next 3 octal digits.;
VerNum _ cvos((memory['137] land '777000) lsh -9) & "." &
	 cvos(memory['137] land '777);
END;

require set!Params initialization[2];

integer procedure Yesterday;
DSCR Gets the current date (DEC-format), converts it to days since begin
     of 1964, subtracts a day, converts it back to DEC format, and
     returns it.  All of this hair to permit properly backing up on the
     1st day of the month.
;
BEGIN "Yesterday"	integer array TmpDat[0:2];
TmpDat[0]_calli(1,'14);			! Get Current date DEC-style;
TmpDat[1]_1;				! Just after midnight;
TmpDat[2]_((TimeZone) lsh 18) lor
	  TimeZone lor '400000;		! To convert to standard-style;
calli(location(TmpDat[0]),-'55);	! Do the conversion;
TmpDat[0]_TmpDat[0]-1;			! Subtract a day;
TmpDat[2]_((Timezone lor '400000) lsh 18) lor
          Timezone;			! To convert to DEC;
calli(location(TmpDat[0]),-'55);	! Do the conversion;
RETURN(TmpDat[0]);
END "Yesterday";

procedure AlternateSys;
DSCR In the rare case that Spool is installed using a different system
number than that on the system, this procedure allows the use of spfix;

  BEGIN
  print(crlf2,"Read system number as: ");
  Sysno_Clean(inchwl);
  Six!SysNo_cvsix(SysNo) lsh -24;
  END;

procedure Bye!Bye;
begin
! Finish up with new log file and either append it to the old one
  or make it the old one;

setprint(NewLogFile,"F");
print(CrLf2);					! Just to the log file;
setprint(NewLogFile,"T");			! Close the log file;
LogFilNam_SplDir & "SPLLOG." & Month[CurMon];
NewLogPtr_Opn!Read(NewLogFile,m.binary,false);
if NewLogPtr neq n!r
then begin
OldLogPtr_Opn!Read(LogFilNam,m.binary,false);
if OldLogPtr = n!r
  then BEGIN
	 rename(File[NewLogPtr],LogFilNam,AllRdNo,Flag[NewLogPtr]);
	 All!Release;
       END
  else BEGIN
	 TmpLogPtr_Opn!Write(TmpLogFile,m.binary,false);
         if TmpLogPtr neq n!r
         then begin
	 inout(File[OldLogPtr],File[TmpLogPtr],-1);
	 inout(File[NewLogPtr],File[TmpLogPtr],-1);
	 rename(File[OldLogPtr],null,AllRdNo,Flag[OldLogPtr]);
	 rename(File[TmpLogPtr],LogFilNam,AllRdNo,Flag[TmpLogPtr]);
	 rename(File[NewLogPtr],null,AllRdNo,Flag[NewLogPtr]);
	 All!Release;
         end;
       END;
end;
calli(0, '12);		! Exit without further adieu;
end;
procedure ErrorExit (string Why);
DSCR this procedure is called whenever there is a fatal error while executing
     a command. The fatal error message is only output to the log file, if
     this is being run from UTIL by an operator.
;

begin
  All!Release;
  ifc  not MainVer thenc
  SetPrint (NewLogFile, "F");	! just to the log file; 
  endc
  print ("Fatal: ", Why, crlf);
  ifc not MainVer thenc
  BEGIN
  SetPrint (NewLogFile, "B");	! go back to TTY too;
  print (" Can not continue !", crlf,
	 "Please call the TYMCOM-X Support Line : (408) 446-6709", crlf);
  END;
  endc
  Bye!Bye;			! of course we want to close up the log file;
end;
DSCR Constr and DynStr are "magical" string procedures coded (by Scott
     Daniels) for efficiency.  Unless you are a SAIL Wizard, leave them
     alone!  Constr is very efficient, but dangerous.  Use it only for
     VERY temporary strings.
;

simple string procedure blowup( integer count, bytepointer );
begin usererr(count,1,"Constr got a bad length!!"); return(null); end;

simple string procedure constr( integer count, byte!pointer );
start!code	define a=1, sp='16,p='17;
		external integer x33;
	skipl	a,count;
	cail	a,'400000;
	 jrst	blowup;
	push	sp,a;
	push	sp,byte!pointer;
	sub	p,x33;
	jrst	@3(p);
end;


string internal simple procedure dynstr( integer count, byte!pointer );
return( ("@"&constr(count,byte!pointer))[2 to inf] );
! **** Macros and procedures that define the structure of the spool
       and accounting records  ****;

DEFINE GdfFormat = <
start!gd
  $binary(  0,  5,  6,status) ##
   $binary( 0, 35, 30,Req!Num) ##
    $binary(0, 17, 12,system!six) ##
    $binary(0, 35, 18,batch!number!six) ##
  $binary(  1,  9, 10,nofiles) ##
   $binary( 1, 17,  8,indent) ##
   $bintim( 1, 35, 18,request!time) ##
  $ganuun(  2, 35, 36,request!aun) ##
  $bindat(  3, 17, 18,request!date) ##
   $binary( 3, 19,  2,fullcase) ##
   $binary( 3, 20,  1,heading) ##
   $binary( 3, 26,  6,print!count) ##
   $binary( 3, 27,  1,transfer!request) ##
   $binary( 3, 28,  1,quest) ##
   $binary( 3, 29,  1,fortran!conversion) ##
   $binary( 3, 30,  1,double!space) ##
   $binary( 3, 32,  2,where!completed) ##
   $binary( 3, 35,  3,destination) ##
  $binary(  4, 17, 18,pages) ##
   $binary( 4, 26,  9,max!char!line!out) ##
   $binary( 4, 35,  9,print!location) ##
  $binary(  5,  2,  3,paper!size) ##
   $binary( 5,  5,  3,parts) ##
   $binary( 5,  8,  3,decollate) ##
   $binary( 5, 11,  3,delivery) ##
   $binary( 5, 12,  1,customer) ##
   $binary( 5, 14,  2,charge!other) ##
   $binary( 5, 15,  1,katakana) ##
   $binary( 5, 17,  2,spare) ##
   $bindat( 5, 35, 18,lines!per!page) ##
  $sixbit(  6,  0,  4,rname) ##
  $sixbit( 10,  0,  1,project) ##
  $sixbit( 11,  0,  1,project2) ##
  $sixbit( 12,  0,  4,telephone) ##
  $ganuun( 16, 35, 36,charge!aun) ##
  $binary( 17,  8,  9,max!copies!per!file) ##
   $binary(17, 17,  9,charged!district) ##
   $bindat(17, 35, 18,completion!date) ##
  $asciiw( 18,  0,  5,transfer!location) ##
  $sixbit( 23,  0,  1,request!user) ##
  $sixbit( 24,  0,  1,request!user2) ##
  $sixbit( 25,  0,  1,charge!user) ##
  $sixbit( 26,  0,  1,charge!user2) ##
  $binary( 27, 35, 36,word!octal!33) ##
  $binary( 28, 35, 36,free!word!1) ##
  $binary( 29, 35, 36,free!word!2) ##
  $binary( 30, 35, 36,free!word!3) ##
  $binary( 31,  0,  1,top!of!form) ##
  $binary( 31,  1,  1,half!page) ##
  $binary( 31,  2,  1,third!page) ##
  $binary( 31,  3,  1,sixth!page) ##
  $binary( 31,  4,  1,overprint) ##
  $binary( 31,  5,  1,next!line) ##
  $binary( 31,  6,  1,second!line) ##
  $binary( 31,  7,  1,third!line) ##
  $binary( 31,  8,  1,skip!line) ##
  $binary( 31,  9,  1,skip!2lines) ##
  $sixbit( 32,  0, 40,delivery!address) ##
  $asciiw( 72,  0, 28,additional!delivery) ##
  $asciiw(100,  0, 28,special!forms)
end!gd>;

DEFINE FdfFormat = <
start!fd
  $binary(  0,  5,  6,copies) ##
   $binary( 0, 35, 30,Req!Num) ##
    $binary(0, 17, 12,system!six) ##
    $binary(0, 35, 18,batch!number!six) ##
  $sixbit(  1,  0,  1,fname) ##
  $binary(  2, 17, 18,dext) ##
   $binary( 2, 35, 18,fext) ##
  $ganuun(  3, 35, 36,request!aun) ##
  $sixbit(  4,  0,  1,owner1) ##
  $binary(  5,  2,  3,paper!size) ##
   $binary( 5,  5,  3,parts) ##
   $binary( 5,  8,  3,decollate) ##
   $binary( 5, 11,  3,delivery) ##
   $binary( 5, 12,  1,customer) ##
   $binary( 5, 14,  2,charge!other) ##
   $binary( 5, 15,  1,katakana) ##
   $binary( 5, 17,  2,spare) ##
   $bindat( 5, 35, 18,request!date) ##
  $binary(  6, 14, 15,pages) ##
   $binary( 6, 35, 21,char!xmit) ##
  $sixbit(  7,  0,  1,owner2)
end!fd >;

DEFINE MapFormat = <
start!md
  $binary(  0, 11, 12,pages) ##
   $binary( 0, 14,  3,paper!size) ##
   $binary( 0, 17,  3,parts) ##
   $binary( 0, 23,  6,status) ##
   $binary( 0, 25,  2,destination) ##
   $binary( 0, 35, 10,batch!number)
end!md >;

DEFINE AccountFormat = <
start!acc
  $asciic(     0,     0,     5,  Req!Num)  ##
    $asciic(   0,     0,     2,  Status)  ##
    $asciic(   0,     2,     3,  Num)     ##
  $asciic(     1,     0,     4,  Date!in)  ##
    $asciic(   1,     4,     4,  Time!in)  ##
    $asciic(   2,     3,    12,  name)  ##
  $asciic(     5,     0,     6,  gan)  ##
    $asciic(   6,     1,     6,  aun) ##
    $asciic(   7,     2,     3,  district) ##
  $asciic(     8,     0,    12,  proj!code) ##
    $asciic(  10,     2,     1,  customer)  ##
      $asciic(10,     3,     2,  Type) ##
  $asciic(    11,     0,     6,  vol) ##
    $asciic(  12,     1,     4,  Tap!Cvt) ##
    $asciic(  12,     1,     2,  Parts) ##
    $asciic(  12,     3,     1,  Burst) ##
    $asciic(  12,     4,     1,  not!used) ##
    $asciic(  12,     1,     9,  xmitted) ##
  $asciic(    13,     0,     5,  Delivery) ##
    $asciic(  14,     0,     7,  Tap!Buy) ##
    $asciic(  15,     2,     6,  date!done) ##
    $asciic(  16,     3,     2,  end!mark)
end!acc >;
! Arrays used as buffers to hold records from the data bases;

DEFINE GdSiz = <128>, FdSiz = <8>, MapSiz = <1>;

own safe integer array MapBuf[0:(MapSiz-1)];
own safe integer array FdfBuf[0:(FdSiz-1)];
own safe integer array GdfBuf[0:(GdSiz-1)];

DEFINE AccSiz = <17>;

own safe integer array AccBuf, CopyAcc[0:(AccSiz-1)];

DEFINE	$binary=<mak$nam>,	$bintim=<mak$nam>,
	$bindat=<mak$nam>,	$ganuun=<mak$nam>,
	$asciiw=<mak$nam$c>,	$asciic=<mak$nam$c>,
	$sixbit=<mak$nam$c>;

DEFINE	##=<,>, end!gd=<;>, end!fd=<;>, end!md=<;>, end!acc=<;>;

DEFINE	start!gd=< REDEFINE mak$nam(i,b,s,name)=<pg.>&<name>;
		   REDEFINE mak$nam$c(i,b,s,name)=
			     <pg.>&<name>&<, pg.>&<name>&<.cnt>;
		   integer >,
	start!fd=< REDEFINE mak$nam(i,b,s,name)=<pf.>&<name>;
		   REDEFINE mak$nam$c(i,b,s,name)=
			     <pf.>&<name>&<, pf.>&<name>&<.cnt>;
		   integer >,
	start!md=< REDEFINE mak$nam(i,b,s,name)=<pm.>&<name>;
		   REDEFINE mak$nam$c(i,b,s,name)=
			     <pm.>&<name>&<, pm.>&<name>&<.cnt>;
		   integer >,
	start!acc=< REDEFINE mak$nam(i,b,s,name)=<acc.>&<name>;
		    REDEFINE mak$nam$c(i,b,s,name)=
			     <acc.>&<name>&<, acc.>&<name>&<.cnt>;
		   integer >;

GdfFormat;
FdfFormat;
MapFormat;
AccountFormat;			! now global pointer variables are made;
simple procedure Setup!Pointers;
DSCR This creates byte pointers into the various arrays used as buffers
     to hold the spool and accounting records.  Where appropriate, it
     also sets integers containing counts of the number of bytes in the
     fields.
     It is a phase 0 initialization procedure.
;
BEGIN "SetupPointers" integer Base;

DEFINE	##=<;>,
	$binary(index, bit, size,name)=<$pv(name)_Base+
		(index + ((((35-bit) lsh 6)+size) lsh 24))>,
	$bintim(index, bit, d.18,=<$pv(name)_Base+
		(index + ((((35-bit) lsh 6)+  18) lsh 24))>,
	$bindat(index, bit, d.18,name)=<$pv(name)_Base+
		(index + ((((35-bit) lsh 6)+  18) lsh 24))>,
	$ganuun(index,d.35, d.36,name)=<$pv(name)_Base+
		(index + (36 lsh 24))>,
	$asciiw(index, d.0,words,name)=<$pv(name)_Base+
		(index + (36 lsh 24));
		$pvc(name)_words>,
	$asciic(index, byte,chars,name)=<$pv(name)_Base+
		(index + ((((36-(7*byte)) lsh 6) + 7) lsh 24));
		$pvc(name)_chars>,
	$sixbit(index, d.0,words,name)=<$pv(name)_Base+
		(index + (36 lsh 24));
		$pvc(name)_words>,
	$sixbitc(index, byte,chars,name)=<$pv(name)_Base+
		(index + ((((36-(6*byte)) lsh 6) + 6) lsh 24));
		$pvc(name)_chars>;

DEFINE	start!fd=< REDEFINE $pv(name)=<pf.>&<name>;
		   REDEFINE $pvc(name)=<pf.>&<name>&<.cnt>;
		   Base_location(FdfBuf[0]);
		 >,
	start!gd=< REDEFINE $pv(name)=<pg.>&<name>;
		   REDEFINE $pvc(name)=<pg.>&<name>&<.cnt>;
		   Base_location(GdfBuf[0]);
		 >,
	start!md=< REDEFINE $pv(name)=<pm.>&<name>;
		   REDEFINE $pvc(name)=<pm.>&<name>&<.cnt>;
		   Base_location(MapBuf[0]);
		 >,
	start!acc=< REDEFINE $pv(name)=<acc.>&<name>;
		    REDEFINE $pvc(name)=<acc.>&<name>&<.cnt>;
		    Base_location(AccBuf[0]);
		  >;

GdfFormat;
FdfFormat;
MapFormat;
AccountFormat;				! that sets up the pointers;
END "SetupPointers";

REQUIRE Setup!Pointers initialization[0];
r!p(Chan) GdfPtr, FdfPtr, MapPtr, BatPtr, CenPtr, RemPtr;
integer GdfCnt, FdfCnt;

boolean procedure SeizeFiles;
DSCR This procedure opens the files that need to be made busy when
     fixing up SPLCNT and REMCNT.  If it fails to get some file, the
     user is asked if he wants to try again.  If no, return False.
     Otherwise try again.  If all needed files are opened, return TRUE.
;
while true do
  BEGIN "Seize"
    GdfPtr_FdfPtr_CenPtr_RemPtr_MapPtr_n!r;	! In case we try twice;
    if ((GdfPtr_Opn!Update(GdfFile,m.binary,false)) neq n!r) and
       ((FdfPtr_Opn!Update(FdfFile,m.binary,false)) neq n!r) and
       ((CenPtr_Opn!Update(CenFile,m.binary,false)) neq n!r) and
       ((RemPtr_Opn!Update(RemFile,m.binary,false)) neq n!r) and
       ((MapPtr_Opn!Update(MapFile,m.binary,false)) neq n!r) 
      then return(True)
      else All!Release;
    if not affirm("do you want to try again?") then return(false);
  END "Seize";


Easy boolean procedure Read!Gdf;
DSCR Reads a record from the GDF file to GdfBuf.
     Returns TRUE if there are more records in the file.
;
BEGIN
arryin(File[GdfPtr], GdfBuf[0], GdSiz);
Inc(GdfCnt);
return(not Eof[GdfPtr]);
END;


Easy boolean procedure Read!Fdf;
DSCR Reads a record from the FDF file, depositing it in FdfBuf.
     Returns TRUE if there are more records in the file.
;
BEGIN
arryin(File[FdfPtr], FdfBuf[0], FdSiz);
Inc(FdfCnt);
return(not Eof[FdfPtr]);
END;
! The array QuickGdf contains pointers to some key info we need
  about the Gdf records.  We have to assume that the file could
  be quite large and so we cannot hope (in general) to be able to
  read it into core.  The scheme used here allows us to dynamically
  allocate the necessary storage as we go along.

  QuickGdf files the info by request number, with a chain of
  GdfLink records to handle cases where there are Gdf records
  with the same request number.
;

r!c FdfNames ( integer TheName, TheExt; r!p(FdfNames) NextNam);
r!c GdfLink ( integer i$date, i$files;
	      r!p(gdfLink) NxtL; r!p(FdfNames) TopName);

r!p(GdfLink) array QuickGdf[0:999];


boolean procedure Set!Info(integer Data, Request, Date);
DSCR Look for a GdfLink record that matches the request number and
     date.  If found, store Data in its i$files field and return
     True.  But if there is no match, create a new record with the
     given request number, date, and data.  File it and return false.
;
BEGIN r!p(GdfLink) TmpLink;
TmpLink_QuickGdf[Request];
while TmpLink neq n!r do
  if date = GdfLink:i$date[TmpLink]		! found a match;
    then BEGIN GdfLink:i$files[TmpLink]_Data; return(true); END
    else TmpLink_GdfLink:NxtL[TmpLink];		! look at next rec;

! if we get here we didn't find a match;
TmpLink_New!Record(GdfLink);
GdfLink:NxtL[TmpLink]_QuickGdf[Request];	! Add the chain to it;
QuickGdf[Request]_TmpLink;			! And make it the top;
GdfLink:i$date[TmpLink]_Date;			! Save the date;
GdfLink:i$files[TmpLink]_Data;			! And data;
return(false);				  ! Tell caller we created one;
END;


boolean procedure Set!GdfInf(integer data);
DSCR Reads the current GDF record in GdfBuf and calls set!info using
     its request number and date.
;
return( set!info( data, 
	cvd( cv6str( ldb(pg.batch!number!six) lsh 18 ) ),
	ldb(pg.request!date)));


boolean procedure Set!FdfInf(integer data);
DSCR Reads the current FDF record in FdfBuf and calls set!info using
     its request number and date.
;
return( set!info( data, 
	cvd( cv6str( ldb(pf.batch!number!six) lsh 18 ) ),
	ldb(pf.request!date)));
integer procedure Read!Info( integer Request, Date );
DSCR Returns information stored by get!info.
     Assumes that something is very wrong if we don't find it.
;
BEGIN r!p(GdfLink) TmpLink;
TmpLink_QuickGdf[Request];
while TmpLink neq n!r do
  if date = GdfLink:i$date[TmpLink]
    then return(GdfLink:i$files[TmpLink])
    else TmpLink_GdfLink:NxtL[TmpLink];
ErrorExit( "attempt to read non-existent information" );
END;


easy integer procedure Read!GdfInf;
return( Read!Info( 
		cvd(cv6str(ldb(pg.batch!number!six) lsh 18)),
		ldb(pg.request!date) ) );


easy integer procedure Read!FdfInf;
return( Read!Info( 
		cvd(cv6str(ldb(pf.batch!number!six) lsh 18)),
		ldb(pf.request!date) ) );
boolean procedure Inc!FilCnt;
DSCR Use the current FDF record.  Search for a matching GDF
     record.  If found, increment its i$files count and return
     false.  If not found, return true.  Also keep track of some
     counters along the way.
;
BEGIN r!p(GdfLink) TmpLink; integer Date, Request;
Date_ldb( pf.request!date );	! date of request for file print;
request_cvd( cv6str( ldb(pf.batch!number!six) lsh 18 ) );

TmpLink_QuickGdf[Request];

while TmpLink neq n!r do
  BEGIN r!p(FdfNames) TmpNamPtr,NewNamPtr;
    if date = GdfLink:i$date[TmpLink]
      then BEGIN integer CName,CExt;		! We found a match;
	     CName_ldb(pf.fname);		! The file name;
	     CExt_ldb(pf.dext);			! Extension (on SPOOL);
	     TmpNamPtr_GdfLink:TopName[TmpLink];
	     while TmpNamPtr neq n!r do
	       BEGIN
	         if (CName = FdfNames:TheName[TmpNamPtr]) and
		    (CExt = FdfNames:TheExt[TmpNamPtr])
		   then return(true)		! Duplicate FDF rec;
		   else TmpNamPtr_FdfNames:NextNam[TmpNamPtr];
	       END;
	   ! If we get here, we have found a genuinely new record;
	     NewNamPtr_new!record(FdfNames);
	     FdfNames:TheName[NewNamPtr]_CName;
	     FdfNames:TheExt[NewNamPtr]_CExt;
	     FdfNames:NextNam[NewNamPtr]_GdfLink:TopName[TmpLink];
	     GdfLink:TopName[TmpLink]_NewNamPtr;
	     Inc(GdfLink:i$files[TmpLink]);
	     return(false);
           END;
    TmpLink_GdfLink:NxtL[TmpLink];
  END;

return(true);			! Tell caller we did not find it;
END;

Integer Pgs;    ! In order to have this value available for Compare!pages;

integer procedure count!chars;
DSCR Searches the FDF file for the records that match the one
     currently in GdfBuf and returns the number of characters
     in that request.
     Complains if it cannot find all of the FDF records and/or
     if the number of pages shown in the FDF records does not
     match the total in the GDF record.
;
BEGIN "Count!Chars" integer Chars, FilCnt, TheDate, TheNum;
if FdfPtr=n!r then FdfPtr_Opn!Read(FdfFile,m.binary);
Chars_Pgs_0;
FilCnt_ldb(pg.nofiles);
TheDate_ldb(pg.request!date);
TheNum_ldb(pg.Req!Num);
useti(File[FdfPtr],ldb(pg.free!word!1));  ! First block with a rec;

while Read!Fdf do
  BEGIN "GetCount"
    if (TheDate=ldb(pf.request!date)) and (TheNum=ldb(pf.Req!Num))
      then BEGIN
	     Chars_Chars+ldb(pf.Char!Xmit);
	     Pgs_Pgs+ldb(pf.pages);
	     FilCnt_FilCnt-1;
	   END;
    if FilCnt=0 then done "GetCount";
  END "GetCount";

! Now see if things look right;
KLUDGE This works right as currently used in the accounting stuff,
       BUT it won't in general--need to figure out something better
       at some point.
;
if FilCnt neq 0
  then print(Crlf2,"Bad file count for the following entry:  ",
	     FilCnt, " missing FDF records.");
if Pgs neq ldb(pg.pages)
  then print(Crlf2, "The following entry shows ", Pgs, " in the FDF");

return(Chars);
END "Count!Chars";
! Macros for the various spool request statuses;

DEFINE Pending   = <0>,		Hold              = <1>,
       Transfer  = <2>,		InProcess 	  = <3>,
       Tape      = <4>,		Tape.done 	  = <5>,
       Completed = <6>,		Completed.Deleted = <7>,
       Canceled  = <8>;


Easy BOOLEAN PROCEDURE Status.is(integer What.Stat);
DSCR This procedure returns TRUE if the status field of the
     request currently in GdfBuf is the same as that of the
     status passed as the argument to the procedure and returns
     FALSE otherwise.
;
return( ldb(pg.status) = What.Stat );


Easy integer procedure map!file!word;
DSCR Construct a new entry for SPOOL.MAP using the record in
     GdfBuf.  Deposit it in MapBuf and return it.
;
BEGIN
dpb( ldb(pg.pages),				     pm.pages );
dpb( ldb(pg.paper!size),			     pm.paper!size );
dpb( ldb(pg.parts),				     pm.parts );
dpb( ldb(pg.status),				     pm.status );
dpb( ldb(pg.destination),			     pm.destination );
dpb( cvd(cv6str( ldb(pg.batch!number!six) lsh 18 )), pm.batch!number );
return(MapBuf[0]);
END;
r!c MapMatches (integer BlkNum; r!p(MapMatches) NxtMatch);

r!p(MapMatches) procedure Search!Map(integer TheReq);
DSCR Searches the SPOOL.MAP file for entries that match the
     given request number.  Each time a match is found
     create a new MapMatches record, set BlkNum to be the
     block number of that request in the GDF file and make the
     new record the top of the list that we are returning.
     Returns the null!record if no matches found.
     Note that the list returned will have the most recent request
     first.
     This procedure opens and closes the map file using the
     global MapPtr--so it had better not be open outside
     this procedure.  To help detect such a snafu, MapPtr
     is set to be the null!record before returning.
;
BEGIN "SearchMap" integer HowMany,WrdCnt,TheWord;
		  r!p(MapMatches) TopMatch, OldMatch;
if 0 geq TheReq geq 1000
  then BEGIN
	 print(Crlf,"Bad argument (", TheReq, ") passed to ",
	       "Search!Map (a program bug).");
	 return(n!r);
       END;
TopMatch_OldMatch_n!r;
MapPtr_Opn!Read(MapFile,m.binary);
HowMany_wordin(File[MapPtr]);
for WrdCnt_1 step 1 until '20 do TheWord_wordin(File[MapPtr]);
for WrdCnt_1 step 1 until HowMany do
  BEGIN
    MapBuf[0]_wordin(File[MapPtr]);
    if ldb(pm.batch!number) = TheReq
      then BEGIN
	     TopMatch_new!record(MapMatches);
	     MapMatches:NxtMatch[TopMatch]_OldMatch;
	     OldMatch_TopMatch;
	     MapMatches:BlkNum[TopMatch]_WrdCnt;
	   END;
  END;
One!Release(MapPtr);
return(TopMatch);
END "SearchMap";
ifc MainVer thenc
procedure Set!GdfToDone;
DSCR Resets the staus on the current GDF record and writes it out.
     NOTE THE FOLLOWING SPECIAL ASSUMPTIONS:
	1.  The GDF file is already open and pointed to by GdfPtr.
	2.  The global variable GdfCnt points to the block containing
	    the GDF record we want to change.
	3.  GdfBuf already contains the record we want to change--
	    EXACTLY as we want it except for the status.
	4.  The procedure is being called under circumstances where
	    we are just processing a single request and where we want
	    to alter the GDF file as quickly as possible--if these
	    conditions are not met, this procedure is an excruciatingly
	    slow way to reset the status.
     SIDE-EFFECTS:  If MapPtr or GdfFile were in use upon entry
		    they will NOT be on exit.
;
BEGIN integer TmpStat; r!p(Chan) NewMapPtr;
if (TmpStat_ldb(pg.status) = Tape)
  then dpb(Tape.Done,pg.status)
  eif TmpStat neq Completed.Deleted
     then dpb(Completed,pg.status);

One!Release(MapPtr);
One!Release(GdfPtr);
while (MapPtr=n!r) or (GdfPtr=n!r) do
  BEGIN "Grab!GdfPtr"
    MapPtr_Opn!Update(MapFile,m.binary,false);
    if MapPtr = n!r
      then if Confirm("Try again?")
	     then continue "Grab!GdfPtr"
	     else done "Grab!GdfPtr";
    GdfPtr_Opn!Update(GdfFile,m.binary,false);
    if (GdfPtr neq n!r) or not Confirm("Try again?")
      then done "Grab!GdfPtr"
      else One!Release(MapPtr);
  END "Grab!GdfPtr";
if GdfPtr=n!r
  then BEGIN
	 One!Release(MapPtr);		! Make sure it's closed;
	 print(Crlf,"WARNING!! Status of GDF record was not reset!");
	 return;
       END;
NewMapPtr_Opn!Write(NewMapFile,m.binary);
TmpStat_GdfCnt+'20;
useti(File[MapPtr],1);
inout(File[MapPtr],File[NewMapPtr],TmpStat);
wordout(File[NewMapPtr],Map!File!Word);
TmpStat_wordin(File[MapPtr]);			! Throw away old word;
inout(File[MapPtr],File[NewMapPtr],-1); ! Copy rest of file;
rename(File[MapPtr],null,AllRdNo,Flag[MapPtr]);
One!Release(MapPtr);
rename(File[NewMapPtr],MapFile,AllRdNo,
       Flag[NewMapPtr]_0);
if Flag[NewMapPtr] neq 0
  then ErrorExit("Could not rename SPOOL.MNW to be SPOOL.MAP!");
One!Release(NewMapPtr);
useto(File[GdfPtr],GdfCnt);
arryout(File[GdfPtr],GdfBuf[0],GdSiz);
One!Release(GdfPtr);
print(Crlf,"Status has been reset on the GDF record.");
END;
endc
DEFINE MaxPrinter = <99>;		! Largest printer no. in use;

procedure FixCounts;
DSCR This is the procedure that rebuilds the files SPLCNT and REMCNT
     from the information contained in SPOOL.GDF.  For each GDF
     record, if it has a status between 0 and 4 (inclusive) it
     is considered to be a pending request of some kind and the
     appropriate counter is incremented.  Then the new count files
     are written.
;
BEGIN "FixCounts" integer CenCnt, Cnt3;
		  integer array RemCnt[0:MaxPrinter];
if not SeizeFiles then return;
while not eof[GdfPtr] do
  BEGIN "Readon" integer Stat;
    arrclr(gdfbuf);  ! To see if we can avoid that last empty buffer;
    arryin(File[GdfPtr], GdfBuf[0], GdSiz);
    if ((stat_ldb(pg.status)) geq 0) and (stat leq 4)
      then BEGIN integer where,site;
	     if (where_ldb(pg.destination)) = 1
	       then inc(cencnt)
	       eif where = 2
		 then BEGIN
		        if (site_ldb(pg.print!location)) < 0 or
			   (site > MaxPrinter)
			  then print(Crlf, "Bad printer number=",site,
				     ".  Request NOT counted.")
			  else inc(remcnt[site]);
		      END;
	    END;
  END "Readon";

wordout(File[CenPtr], CenCnt);

! Turn on the sign bit for each printer to force PJ to move the data;
for cnt3_0 step 1 until MaxPrinter do
  RemCnt[Cnt3]_'400000000000 lor RemCnt[cnt3];

arryout(File[RemPtr], RemCnt[0], MaxPrinter+1);

All!Release;
END "FixCounts";
DSCR The following three procedures are to find and print information for
     requests in the GDF file that have a status of pending more than 10
     days old, or a status of tape or process more than 3 days old.  To
     avoid printing requests with a default date, pending requests more than
     300 days old are not printed.
;



simple string procedure CVS.L (integer VAL);
BEGIN   string RESULT;
	integer W, D;
  GETFORMAT(W, D);
  SETFORMAT(-2, D);
  RESULT_CVS(VAL);
  SETFORMAT(W, D);
  RETURN(RESULT);
END;


simple procedure Print!Old (string What!Stat);
BEGIN
  print (cvxstr(ldb(pg.Req!Num))[2 to 6], "  ");
  if length(PrintDate(ldb(pg.request!date))) < 9 then
    print (" ");
  print (PrintDate(ldb(pg.request!date)), "  ", What!Stat, "  ");
  if ldb(pg.destination) = 1 then
    print ("CEN")
  else if ldb(pg.destination) = 2 then
    print ("R", CVS.L(ldb(pg.print!location)));
  print ("  ", cv6str(ldb(pg.request!user)),
         cv6str(ldb(pg.request!user2)), CRLF);
  RETURN;
END;



procedure Print!Pending;
BEGIN "PrintPending" boolean Old!Pend;
		      string PendStat;
  Old!Pend_false;
  GdfPtr_Opn!Read(GdfFile, m.binary);
  if GdfPtr = n!r then
    BEGIN
    ALL!RELEASE;
    print(CRLF, "CAN'T OPEN SPOOL.GDF", CRLF);
    RETURN;
    END
  else print (CRLF, "SPOOL.GDF opened.  Checking for old requests.",
	      CRLF);
  print ("REQUEST    DATE   STAT  LOC   USERNAME", CRLF2);
  while Read!Gdf do
    if Status.is(Pending) and 300 geq (CurDate-ldb(pg.request!date)) geq 11 then
      BEGIN
      PendStat_"PEND";
      Print!Old(PendStat);
      Old!Pend_true;
      END
    else if Status.is(Tape) and (CurDate-ldb(pg.request!date)) geq 4 then
      BEGIN
      PendStat_"TAPE";
      Print!Old(PendStat);
      Old!Pend_true;
      END
    else if Status.is(InProcess) and (CurDate-ldb(pg.request!date)) geq 4 then
      BEGIN
      PendStat_"PROC";
      Print!Old(PendStat);
      Old!Pend_true;
      END;
  if not Old!Pend then
    print ("No old requests pending.", CRLF);
  One!Release(GdfPtr);
END "PrintPending";
procedure SpoolClean;
DSCR this routine will automatically remove all listing files on the SPOOL
     directory that no longer belong there.  
    
     SpoolClean scans the gdf and fdf making a list of pnames of files that
     have yet to be printed.  It then reads the SPOOL ufd and makes a delete
     list of all files with numberic extensions that are not in the pnames
     list.  Lastly the files are deleted with a rename.
;
BEGIN "SpoolClean" 	string DelFilNam, Name, Ext, DirNam;
			own integer array LukBlk[0:5];
			integer UfdChan, SpChan, ThePPN, UfdFlag, TotCnt;
			integer ZapDat,CompDat,StuckFil,StuckReq;
			integer BlkCnt,SpFlag;
			boolean FirstTime;
			r!p (Chan) DelFilPtr;
			r!p (any!class) UfDat;
			itemvar FilNam;
                        r!c DelFiles (string DelName; r!p (DelFiles) NextDel);
                        r!p (DelFiles) FirstDel, Temp;



if DidClean then 
BEGIN
print("Clean already done.",crlf);
RETURN;
END
else DidClean_TRUE;             ! Once is plenty;

if not SeizeFiles then RETURN;	! Freeze the data base;
print(CrLf,"Scanning the SPOOL data base...");
TotCnt_CompDat_0;
GdfCnt_0;			! Init the count of no. of GDF recs;
ZapDat_Yesterday;
FirstDel _ n!r;

print(CrLf,"Will not keep files for requests completed before ",
      PrintDate(ZapDat));

while Read!Gdf do
  BEGIN "MakeNames" 		! Find the files to keep;
        integer NumFil,TheReq,TheDat,ItmFlg;  itemvar OldNam;
    if (GdfBuf[0]=0) or (ldb(pg.status) geq Completed.Deleted) or
       ((NumFil_ldb(pg.nofiles)) = 0)
      then continue "MakeNames";
    if GdfBuf['34] leq 0 then GdfBuf['34]_1;	! Check FDF pointer;
    TheReq_ldb(pg.req!num);
    TheDat_ldb(pg.request!date);
    useti(File[FdfPtr],ldb(pg.free!word!1));
if (CompDat_ldb(pg.completion!date)<ZapDat) and
   (ldb(pg.status) geq Tape.Done) then continue "MakeNames";
    FdfCnt_0;
    while Read!Fdf do
      BEGIN "GetNames" string SavNam;
        if (TheDat=ldb(pf.request!date)) and (TheReq=ldb(pf.Req!Num))
          then BEGIN
                 SavNam_cvxstr(ldb(pf.fname)) &
			cv6str(ldb(pf.dext) lsh 18);
		 OldNam_cvsi(SavNam,ItmFlg);
		 if ItmFlg
		   then BEGIN
		          OldNam_NEW;
			  new!pname(OldNam,SavNam);
			  NumFil_NumFil-1;
			  inc(TotCnt);
			END;
		 if NumFil leq 0 then done "GetNames";
	       END;
      END "GetNames";
    if NumFil neq 0
      then print(Crlf,"Damage at '",cvos((GdfCnt-1)*'200),":  request",
		 cvxstr(TheReq)," is missing ",NumFil," files!");
  END "MakeNames";

print(CrLf,"Found ",TotCnt, " files to keep.");
TotCnt_0;					! We use it again;

DEFINE PhoneyNam = <"\.\">;

open( UfdChan_getchan,"dsk", '17,0,0, 0,0,0 );
lookup(UfdChan, SplDir & PhoneyNam, UfdFlag);	! Expected to fail;
close(UfdChan);
fileinfo(LukBlk);				! but we do get a PPN;
ThePPN_ LukBlk[3];
LukBlk[0]_4;					! Now set up for UFD;
LukBlk[1]_ 1 lsh 18 + 1;
LukBlk[2]_ ThePPN;
LukBlk[3]_ cvsix("UFD");
LukBlk[4]_ 0;
chnior( UfdChan, LukBlk[0], 4 );
if not !skip! then ErrorExit("Can't read UFD for " & SplDir);

UfDat_ iniufr( "*", "*", UfdChan, 15, 1 );	! Look at all files;
setprint(newLogFile,"F");                       ! Just to the log file;
FirstTime_true;
while nxtufr( LukBlk, UfDat )			! One by one;
  do BEGIN integer IntTst1,IntTst2,IntTst3,NoNameExists;
	   string OurName,DelFilNam;
       LukBlk[1]_LukBlk[1] land '777777000000;
       OurName_cvxstr(LukBlk[0])&cv6str(LukBlk[1]);
       FilNam_cvsi(OurName,NoNameExists);
       if NoNameExists
         then BEGIN
	        IntTst1_LukBlk[1] lsh -18;
		IntTst2_IntTst1 land '7777;
		IntTst3_IntTst1 land   '77;
		if ('202020 leq IntTst1 leq '313131) and
		   (  '2020 leq IntTst2 leq   '3131) and
	      	   (    '20 leq IntTst3 leq     '31)
 	  	  then BEGIN
			 if FirstTime then
			   BEGIN
                           FirstTime_false;
                           print(Crlf2,"The following files ",
                             "were deleted:",CrLf);
                           END
			   else  print(",	");
			 if (totcnt mod 4) = 0
			   then  print(CrLf);
                         DelFilNam _ OurName[1 to 6]&"."&OurName[7 to 9];
		         print(DelFilNam);

                         Temp _ NEW!RECORD (Delfiles);
                         DelFiles:NextDel[temp] _ FirstDel;
                         FirstDel _ Temp;
                         DelFiles:DelName [temp] _ DelFilNam;
		         Inc(totcnt);
		       END;
	      END;
     END;

! Now to delete the files;

open(SpChan_getchan,"dsk",0,0,0,0,0,0);

while temp neq n!r do
  BEGIN
      lookup(SpChan, SplDir&DelFiles:DelName [temp], SpFlag);
      if SpFlag 
        then print("?can't find file: ",crlf)
        else rename(SpChan,NULL,0,0);
      Temp _ DelFiles:NextDel [Temp]
  END;
release(SpChan);
release(UfdChan);
All!Release;
setprint(NewLogFile,"B");		! Print on TTY also;
print(CrLf2,TotCnt," files were deleted.");
END "SpoolClean";
DSCR The following 6 procedures are to do the monthly repair work to get
     rid of all bad records in the SPOOL.GDF and SPOOL.FDF files.
;


simple boolean procedure Need.Lic;
DSCR Checks to be sure that either SPFIX or the user has GD and SY license
     set so repairs can be made.
;
BEGIN  integer UserLic;
  DEFINE  !GTLIC = <-'20>,
	  LC!SY = <'40000000000>,
	  LC!GD = <'20000000000>;

  UserLic _ calli(!XWD(-1,!GTLIC),calli!Gettab);
  if ((UserLic land LC!SY = 0) or (UserLic land LC!GD = 0)) then
    BEGIN
    print ("Need SY and GD license to do repairs.", crlf);
    return(TRUE);
    END
  else return(FALSE);
END;


DEFINE  SppDir = <"(SPPOPER)">, AllRunRun = <'055>;
ifc Debug
  thenc DEFINE SpoolDir = <"(SPOOL)">;
  elsec DEFINE SpoolDir = <"(SYS)">;
endc
string NewSpool;
DEFINE
  OldSpool = <SpoolDir & "SPOOL.SAV">,
  OldFake = <SppDir & "FAKSPO.SAV">;


simple boolean procedure RunningSpool;
!
!	Return true if someone is running SPOOL.
!
;
begin
  integer
    Loop,
    Status;

  define
    !GTFPN     = <-'25>		! File PPN;,
    !GTNSW     = <'12>		! Table '12 for Gettab;,
    !NSHJB     = <'20>		! Item '20  for Gettab;,
    FromSpool  = <calli(!xwd(Loop, !GTFPN), calli!gettab) = SpoolPPN>,
    GetStatus  = <calli(!xwd(Loop, 0), calli!gettab)>,
    HighestJob = <calli(!xwd(!NSHJB, !GTNSW), calli!gettab)>,
    IsAssigned = <Status land !bit(3)>,
    IsRunning  = <Status land !bit(0)>,
    IsWaiting  = <Status land !bit(22)>,
    IsSpool    = <cvsix("SPOOL") = calli(!xwd(Loop, 3), calli!gettab)>,
    SpoolPPN   = <!xwd(1, '133677)>;

  for Loop _ HighestJob step -1 until 1 do
  begin
    Status _ GetStatus;

    ifcr DEBUG thenc
      if (IsAssigned and IsSpool and FromSpool)
      then begin 	
	     if ( IsRunning and (not IsWaiting) )   ! this is to trap the 
						      runnable jobs which
						      are not waiting for
						      oper action;
	       or ( (not IsRunning) and IsWaiting ) ! this is to trap the
						      famous OW state in
						      which the job is NOT
						      runnable and is waiting
						      for oper action;
		then return(true);
	   end; 
    elsec
      if (IsAssigned and IsSpool)
      then begin
	     if ( IsRunning and (not IsWaiting) )
	       or ( (not IsRunning) and IsWaiting ) then return(true);
	   end;
    endc
  end;

  return(false);
end;


procedure Disable.Spool;
DSCR This procedure is to rename (SYS)SPOOL.SAV so repairs can be done.
;
BEGIN r!p(Chan) TmpPtr;
  NewSpool _ SppDir & "SPOOL.SAV";
  TmpPtr_Opn!Read(OldSpool, m.binary);
  rename(File[TmpPtr], NewSpool, AllRunRun, Flag[TmpPtr]_0);
  if Flag[TmpPtr] neq 0
    then
      begin
 	NewSpool _ SppDir & "CSPOOL.SAV";
        rename(File[TmpPtr], NewSpool, AllRunRun, Flag[TmpPtr]_0);
        if Flag[TmpPtr] neq 0 
 	  then ErrorExit ("Was not able to rename SPOOL.SAV")
	  else print (CRLF,"(SPPOPER)SPOOL.SAV exists",crlf,
		    "(SYS)SPOOL.SAV has been renamed to (SPPOPER)CSPOOL.SAV",
		    crlf);
      end;
  One!Release(TmpPtr);

  TmpPtr_Opn!Read(OldFake, m.binary);
  rename(File[TmpPtr], OldSpool, AllRunRun, Flag[TmpPtr]_0);
  if Flag[TmpPtr] neq 0 then BEGIN
    TmpPtr_Opn!Read(OldSpool, m.binary);
    rename(File[TmpPtr], OldFake, AllRunRun, Flag[TmpPtr]_0);
    ErrorExit ("Was not able to rename FAKSPO.SAV");
    END;
  One!Release(TmpPtr);
END;

procedure Enable.Spool;
DSCR This procedure renames SPOOL back to (SYS) when spool maintenance
     is done.
;
BEGIN r!p(Chan) TmpPtr;
  print (CRLF, "Enabling SPOOL . . . ");
  TmpPtr_Opn!Read(OldSpool, m.binary);
  rename(File[TmpPtr], OldFake, AllRunRun, Flag[TmpPtr]_0);
  if Flag[TmpPtr] neq 0
    then ErrorExit ("Was not able to rename SPOOL.SAV back to (SYS)");
  One!Release(TmpPtr);

  TmpPtr_Opn!Read(NewSpool, m.binary);
  rename(File[TmpPtr], OldSpool, AllRunRun, Flag[TmpPtr]_0);
  if Flag[TmpPtr] neq 0
    then ErrorExit ("Was not able to rename FAKSPO.SAV back to (SYS)");
  One!Release(TmpPtr);
  print ("Enabled.", CRLF);
END;

simple boolean procedure Aux!Circuit;
DSCR Checks to see if SPFIX is being run by an aux circuit.
;
BEGIN
  DEFINE !GTLOG = <-'24>;
  return(0 = calli(!XWD(-1,!GTLOG),Calli!Gettab) land ('17 lsh 24));
END;

  

procedure FixRequests;
DSCR This is the largest and most complex procedure in the program.
     It reads the SPOOL.GDF and SPOOL.FDF files, removing old and
     bad records and making new files with only current good requests.
     It also makes a new SPOOL.MAP file.
;
BEGIN "FixReq" integer GoodGdfCnt,GoodFdfCnt,
		       lose!min,win!min,lose!max,win!max;

DEFINE Calli!Sleep = <'31>;

if Need.Lic then return;

print ("Checking the status of SPOOL . . . ");
if RunningSpool then
while RunningSpool do		
  BEGIN
  if (not Aux!Circuit) and
	 confirm ("Someone is running SPOOL. Wait 15 seconds?") then
    BEGIN
    print ("Sleeping . . . ");
    calli(15, Calli!Sleep);
    print ("Awake!")
    END
  else 
    begin
    if aux!circuit then print("Someone is running SPOOL. Try again later.");
    return;
    end;
  END;

print (". . . No one running SPOOL",CRLF);

print ("Disabling SPOOL . . . ");
Disable.Spool;
print ( "SPOOL disabled.", CRLF);


SetTime;
lose!min_win!min_'377777777777;
lose!max_win!max_-1;
arrclr(QuickGdf);
print(Crlf,"Beginning SPOOL data base repair at ",PrintTime,".");

DSCR First scan the GDF file, Discarding any old or obviously bad
     records as we go.  For each entry that looks OK, make a GdfLink
     record for it (filed by request number in QuickGdf).  As the
     records are created they are given the NEGATIVE of the number of
     files in the request.  This permits easy detection of missing or
     excess FDF records for each request.
     Then scan the FDF file, removing any records for which we do not
     have a corresponding GdfLink record (request no. and date must
     match), so we remove old and obviously bad records as we go.
     Finally, examine the GdfLink records, marking those that don't have
     the proper number of Fdf records so that we can remove them on the
     second pass.
;
BEGIN "Pass1" r!p(Chan) TmpGdfPtr,BadGdfPtr,TmpFdfPtr,BadFdfPtr;
	      r!p(GdfLink) GdfRec;
	      integer Req;
GdfCnt_GoodGdfCnt_0;
GdfPtr_   Opn!Read( GdfFile,   m.binary);
TmpGdfPtr_Opn!Write(TmpGdfFile,m.binary);
BadGdfPtr_Opn!Write(BadGdfFile,m.binary);
print(Crlf,"Beginning pass 1:",CrLf,"  Scanning the GDF file... ");

if EOF[GdfPtr] then
  BEGIN
  Enable.Spool;
  All!Release;
  END
else while Read!Gdf do
  BEGIN integer FilNum,ReqDat;
    FilNum_ldb(pg.Nofiles);
    Req_cvd(cv6str(ldb(pg.batch!number!six) lsh 18));
    ReqDat_ldb(pg.request!date);
    if ReqDat<PurgeDate
      then arryout(File[BadGdfPtr],GdfBuf[0],GdSiz)
    eif (FilNum=0) or (ldb(pg.status)>Canceled) or
        (ldb(pg.system!six) neq Six!SysNo) or
        (Req leq 0) or (Req > 999)
      then BEGIN
 	     print(CrLf,"    DAMAGE:  Bad 1st word = ",
		   cvxstr(GdfBuf[0])," (block ",GdfCnt,")");
	     arryout(File[BadGdfPtr],GdfBuf[0],GdSiz);
	   END
    eif Set!Info(-FilNum,Req,ldb(pg.request!date))
      then BEGIN
	     print(Crlf,"    DAMAGE:  Duplicate GDF record for #",
		   cvxstr(ldb(pg.req!num))," (block ",GdfCnt,")" );
	     arryout(File[BadGdfPtr],GdfBuf[0],GdSiz);
	   END
      else BEGIN
	     win!min_win!min min ldb(pg.request!date);
	     win!max_win!max max ldb(pg.request!date);
	     arryout(File[TmpGdfPtr],GdfBuf[0],GdSiz);
	     if ldb(pg.print!location) > MaxPrinter
	       then print(Crlf,"    WARNING:  Bad printer loc=",
			  ldb(pg.print!location)," for #",
		   	  cvxstr(ldb(pg.req!num))," (block ",GdfCnt,
			  ")" );
	   END;
  END;
All!Release;
print(Crlf,"  Scanning the FDF file... ");

FdfCnt_GoodFdfCnt_0;
FdfPtr_   Opn!Read( FdfFile,   m.binary);
TmpFdfPtr_Opn!Write(TmpFdfFile,m.binary);
BadFdfPtr_Opn!Write(BadFdfFile,m.binary);

while Read!Fdf do
  if FdfBuf[0] and not Inc!FilCnt
    then BEGIN
	   Inc(GoodFdfCnt);
	   arryout(File[TmpFdfPtr],FdfBuf[0],FdSiz);
	 END
    else BEGIN
	   arryout(File[BadFdfPtr],FdfBuf[0],FdSiz);
	   if ldb(pf.request!date) geq PurgeDate
	     then BEGIN		      ! Complain about bad current recs;
		    lose!min_lose!min min ldb(pf.request!date);
		    lose!max_lose!max max ldb(pf.request!date);
!		    print(Crlf, "    DAMAGE:  Bad or duplicate record ",
			  "for ",cvxstr(ldb(pf.req!num))," (rec #",
			  FdfCnt," in FDF file)" );
		  END;
	  END;
All!Release;

! Stop the processing right here if we do not have any good records;
if win!max < 0 then BEGIN
  print (CRLF, "Fatal error. ");
  Enable.Spool;
  if Aux!Circuit then BEGIN
    print ("ALL RECORDS BAD!!", CRLF);
    return;
    END
  else ErrorExit("ALL RECORDS BAD!!");
  END;

print(Crlf,"  Scanning the internal records...");

for Req_0 step 1 until 999 do
  BEGIN
    GdfRec_QuickGdf[req];
    while GdfRec neq n!r do
      BEGIN
        if GdfLink:i$files[GdfRec] neq 0
	  then BEGIN
		 lose!min_lose!min min ldb(pg.request!date);
		 lose!max_lose!max max ldb(pg.request!date);
		 GdfLink:i$files[GdfRec]_-1;		! Mark as bad;
	         print(Crlf,"    DAMAGE:  request #", Req, ", dated ",
		       PrintDate(GdfLink:i$date[GdfRec]),
		       " is missing ", -GdfLink:i$files[GdfRec],
		       " FDF records.");
	       END
	  else Inc(GoodGdfCnt);
	GdfLink:TopName[GdfRec]_n!r;			! Not needed;
        GdfRec_GdfLink:NxtL[GdfRec];
      END;
  END;

! Another check to make sure that we have some good records;
if (GoodGdfCnt leq 0) or (GoodFdfCnt leq 0) then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  if Aux!Circuit then BEGIN
    print("NO GOOD RECORDS FOUND!!");
    return;
    END
  else ErrorExit("No good records found!!");
  END;

print(Crlf,"  Pass 1 statistics:",
      Crlf,"    Scanned ", GdfCnt-1, " GDF records and found ",
      GoodGdfCnt," good ones.",
      Crlf,"    Scanned ", FdfCnt-1, " FDF records, and saved ",
      GoodFdfCnt, " for Pass 2.",
      Crlf,"    Dates on the good records ranged from ",
      PrintDate(Win!Min), " to ", PrintDate(Win!Max), ".");
if lose!max > 0
  then BEGIN
	 print(Crlf, "    Dates on the bad records ranged from ",
	       PrintDate(Lose!Min), " to ", 
	       PrintDate(Lose!Max), ".");
       END
  else print(Crlf, "    No bad records detected.");

END "Pass1";


DSCR On the 2nd pass we scan the FDF file first, discarding any records
     associated with GDF records that had a bad file count.  We set
     the i$files entry for a good GDF record to be the block number of
     the first FDF record for that request in the new file.
     Then we scan the GDF file, making sure that each request is
     actually a good one.  We make the MAP file as we go.
;
BEGIN "Pass2" integer Status,DelDat,Temp;
	      r!p(Chan) LostGdfPtr,NewGdfPtr,LostFdfPtr,NewFdfPtr,
			NewMapPtr;

FdfCnt_GoodFdfCnt_0;
FdfPtr_Opn!Read(TmpFdfFile,m.binary);
LostFdfPtr_Opn!Write(LostFdfFile,m.binary);
NewFdfPtr_Opn!Write(NewFdfFile,m.binary);
print(CrLf2,"Beginning pass 2...",CrLf,"  Scanning FDF file...");

while Read!Fdf do
  if (Status_Read!FdfInf) < 0
    then arryout(File[LostFdfPtr],FdfBuf[0],FdSiz)
    else BEGIN
	   if Status=0 and not Set!FdfInf((GoodFdfCnt div 16)+1) then BEGIN
	     print (CRLF, "Fatal error.  ");
	     Enable.Spool;
	     if Aux!Circuit then BEGIN
	       print("SET!FDFINF CAN'T FIND A REC THAT READ!FDFINF JUST ",
		     "FOUND!!", CRLF);
	       return;
	       END
	     else ErrorExit("Set!FdfInf can't find a rec that Read!FdfInf "
			& "just found!!");
	     END;
	   Inc(GoodFdfCnt);	      ! Do the Inc AFTER the Set!FdfInf;
	   arryout(File[NewFdfPtr],FdfBuf[0],FdSiz)
	 END;
All!Release;

print(CrLf,"  Scanning GDF file...");
GdfPtr_Opn!Read(TmpGdfFile,m.binary);
LostGdfPtr_Opn!Write(LostGdfFile,m.binary);
NewGdfPtr_Opn!Write(NewGdfFile,m.binary);
NewMapPtr_Opn!Write(NewMapFile,m.binary);
! Now write out the 1st 20 words of the new MAP file;
wordout(File[NewMapPtr], GoodGdfCnt);	! Number of GDF recs we have;
SetTime;
wordout(File[NewMapPtr], DateBuf[0]);	! Date of last monthly update;
wordout(File[NewMapPtr], DateBuf[0]);	! Date of last daily update;
for temp_3 step 1 until '20 do wordout(File[NewMapPtr],0);

GdfCnt_GoodGdfCnt_0;			! Reinit counts--AFTER writing
					! first words of Map file;
DelDat_Yesterday;			! Set date for file delete;

while Read!Gdf do
  if (Status_Read!GdfInf) > 0
    then BEGIN integer PntStat,DatDone;
	   GdfBuf['34]_Status;
	   if ( ((PntStat_ldb(pg.status))=tape.Done) or
	                              (PntStat=Completed) )     and
	      ((DatDone_ldb(pg.Completion!Date))<DelDat) and
	      (DatDone > 0)
	     then dpb(Completed.Deleted,pg.status);
	   arryout(File[NewGdfPtr],GdfBuf[0],GdSiz);
	   wordout(File[NewMapPtr],map!file!word);
	   Inc(GoodGdfCnt);
         END
    else BEGIN
           if Status neq -1 then BEGIN
	     print (CRLF, "Fatal error.  ");
	     Enable.Spool;
	     if Aux!Circuit then BEGIN
	     print("VERY BAD STATUS FOR A GDF RECORD (A BUG)", CRLF);
	     return;
	     END
	     else ErrorExit("Very bad status for a GDF record (a bug)");
	     END;
	   arryout(File[LostGdfPtr],GdfBuf[0],GdSiz);
	 END;
All!Release; 

arrclr(QuickGdf);	! No longer needed, so make recs garbage-
			  collectable;
GdfCnt_-1+GdfCnt;
if GdfCnt=GoodGdfCnt
  then print(CrLf,"    All ",GdfCnt," GDF records were used.")
  else print(CrLf,"    Discarded ",GdfCnt-GoodGdfCnt," of the ",GdfCnt,
	     " GDF records.");
FdfCnt_-1+FdfCnt;
if FdfCnt=GoodFdfCnt
  then print(CrLf,"    All ",FdfCnt," FDF records were used.")
  else print(CrLf,"    Discarded ",FdfCnt-GoodFdfCnt," of the ",FdfCnt,
	     " FDF records.");
END "Pass2";

! The 3rd and final check to make sure that we have good files;
if (GoodGdfCnt leq 0) or (GoodFdfCnt leq 0) then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  if Aux!Circuit then BEGIN
    print("NO USABLE RECORDS LEFT AFTER END OF PASS 2!!");
    return;
    END
  else ErrorExit("NO USABLE RECORDS LEFT AFTER END OF PASS 2!!");
  END;

BEGIN "SplRename" r!p(Chan) TmpPtr, OldPtr;
! The final step is to rename the old data base files to be the backups
  and the newly-created files to be the current data base files.  ;
print(CrLf2,"Renaming files, wait... ");
OldPtr_Opn!Read(GdfBak,m.binary,False);     ! OK if it fails;
if OldPtr neq n!r			    ! It exists, so delete it;
  then rename(File[OldPtr],"",AllRdNo,Flag[OldPtr]);
TmpPtr_Opn!Read(GdfFile,m.binary);
rename(File[TmpPtr],GdfBak,AllRdNo,Flag[TmpPtr]_0);
if Flag[TmpPtr] neq 0 then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.GDF");
  END;
All!Release;
OldPtr_Opn!Read(FdfBak,m.binary,False);     ! OK if it fails;
if OldPtr neq n!r			    ! It exists, so delete it;
  then rename(File[OldPtr],"",AllRdNo,Flag[OldPtr]);
TmpPtr_Opn!Read(FdfFile,m.binary);
rename(File[TmpPtr],FdfBak,AllRdNo,Flag[TmpPtr]_0);
if Flag[TmpPtr] neq 0 then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.FDF");
  END;
All!Release;

OldPtr_Opn!Read(MapBak,m.binary,False);     ! OK if it fails;
if OldPtr neq n!r			    ! It exists, so delete it;
  then rename(File[OldPtr],"",AllRdNo,Flag[OldPtr]);
TmpPtr_Opn!Read(MapFile,m.binary,False);    ! OK if it fails;
if TmpPtr neq n!r
  then rename(File[TmpPtr],MapBak,AllRdNo,
	      Flag[TmpPtr]_0);
if (TmpPtr neq n!r) and (Flag[TmpPtr] neq 0) then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.MAP");
  END;
All!Release;

TmpPtr_Opn!Read(NewGdfFile,m.binary);
rename(File[TmpPtr],GdfFile,AllRdNo,Flag[TmpPtr]_0);
if Flag[TmpPtr] neq 0 then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.GNW");
  END;
One!Release(TmpPtr);
TmpPtr_Opn!Read(NewFdfFile,m.binary);
rename(File[TmpPtr],FdfFile,AllRdNo,Flag[TmpPtr]_0);
if Flag[TmpPtr] neq 0 then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.FNW");
  END;
One!Release(TmpPtr);

TmpPtr_Opn!Read(NewMapFile,m.binary);
rename(File[TmpPtr],MapFile,AllRdNo,Flag[TmpPtr]_0);
if Flag[TmpPtr] neq 0 then BEGIN
  print (CRLF, "Fatal error.  ");
  Enable.Spool;
  ErrorExit("Was not able to rename SPOOL.MNW");
  END;
One!Release(TmpPtr);

All!Release;
print("done!!");
END "SplRename";


print(Crlf,"Updating SPLCNT and REMCNT, wait... ");
FixCounts;			! Fix up counts in SPLCNT and REMCNT;
print("done!!");

print(Crlf,"Cleaning the SPOOL directory, wait... ");
SpoolClean;

Enable.Spool;

SetTime;
print(Crlf2,"Data base repair completed at ", PrintTime);
END "FixReq";
ifc MainVer thenc
! **** Accounting file globals and routines begin here ****;

preload!with
"0-ILLEGAL      ", "Spool (Center) ", "Card Read      ", 
"Card Punch     ", "Tape Read      ", "Tape Write     ", 
"6-ILLEGAL      ", "Tape Conversion", "Affiliate Tapes",
"Listing        ", "Remote Part 1  ", "Spool (Remote) ",
"Tape Purchase  ", "Postage Charge ", "14-            ",
"               ", "16-not used    ", "17-not used    ",
"18-not used    ", "19-not used    ", "20-not used    ";
string array JobType[0:20];

r!p(Chan) AccFile;
r!p(Chan) NewAccFile;
integer AccCnt;
string BatName;			! Name of monthly batch file;

! This macro simplifies setting up the print statements.
  Note that pntacc(X) simply expands into constr(acc.X.cnt,acc.X);
DEFINE pntacc(X) = <constr(acc.> & <X> & <.cnt,acc.> & <X> & <)>;
DEFINE NotProcessed = <03>;		! Accounting status macro;

Easy boolean procedure Read!Acc;
DSCR Reads a record from the monthly batch file and deposits it
     in AccBuf.  Keeps track of number of records seen.  Returns
     TRUE if there are more records in the file.
;
BEGIN
arryin(File[AccFile], AccBuf[0], AccSiz);
Inc(AccCnt);
return(not EOF[AccFile]);
END;

simple procedure Set!BatName;
DSCR Sets the global string BatName to be the name of the monthly
     batch accounting file
;
BatName_BatDir & "BAT0" & SysNo & "." & Month[CurMon];
endc
ifc MainVer thenc
DSCR The following three procedures are to total all page and character counts
     from customer requests completed before the purge date that have not been
     charged off by the operators with rcharge and bcharge.;

simple string procedure AccDatePrint(integer AccDate);
DSCR Prints dates received in accounting file format returning a string
     in the form dd-mon-yy.
;
BEGIN "AccDatePrint"

string AccDateString;
integer AccMonth;
if AccDate <0 then return(null);         ! An obviously bad argument;
AccDateString_cvs(AccDate);
AccMonth_cvd(AccDateString[3 to 4]);
return(AccDateString[5 to 6] & "-" & Month[AccMonth] & "-" & 
    AccDateString[1 to 2]);
END "AccDatePrint";
endc

ifc MainVer thenc
procedure NotCharged(String AccFileName);
BEGIN  "NotChg"

integer IsCustReq, PageCount, CharCount,Date!min,Date!max,OldCount;
string DateComp;  integer array DistCount[0:999];
arrclr(DistCount);
PageCount_CharCount_OldCount_0;
Date!min_'377777777777;
Date!max_-1;

While TRUE do
  BEGIN "OpnAccFl"
  If (AccFile_Opn!Read(AccFileName, m.binary, false)) neq n!r then
    done "OpnAccFl";
  print (crlf,"Cannot open file.");
  return;
  END "OpnAccFl";

While Read!Acc do
    BEGIN  "CustReqCount"
    integer YearComp, MonthComp,AccStatus;
    IsCustReq_cvd(PntAcc(Customer));
    DateComp_dynstr(acc.Date!Done.cnt,acc.Date!Done);
    YearComp_cvd(DateComp[1 to 2]);
    MonthComp_cvd(DateComp[3 to 4]);
    AccStatus_cvd(PntAcc(Status));

    If AccStatus geq NotProcessed and
 (YearComp < CurYear or MonthComp < CurMon) and IsCustReq then
      BEGIN  "RecordCount"
      integer RecordType,PgCnt,ChCnt;
      PgCnt_ChCnt_0;

      If ((RecordType_cvd(PntAcc(Type))) = 1) or (RecordType = 11) then
         BEGIN
         PageCount_PageCount + (PgCnt_cvd(PntAcc(Vol)));
         inc(OldCount);
         if cvd(DateComp) > 0 then     ! Some accounting records have 0 dates;
           Date!min_Date!min min cvd(DateComp);
         Date!max_Date!max max cvd(DateComp);
         inc(DistCount[cvd(PntAcc(district))]);
         END
      else if RecordType = 10 then
        CharCount_CharCount + (ChCnt_cvd(PntAcc(xmitted)));
      END  "RecordCount";

  END  "CustReqCount";


 If Date!max < 0 then
    print (crlf2,"No old records found.")
  else

    BEGIN  integer i,OldWidth,OldDigits;

      print (crlf2,OldCount," old records found.");
      print (crlf,"Completion dates range from ",AccDatePrint(Date!min),
          " to ",AccDatePrint(Date!max),".");
      print (crlf2,"Total pages not charged: ",PageCount);
      if CharCount neq 0 then
        print (crlf,"Total characters not charged: ",CharCount);
      print(crlf2,"  District   Count",crlf,"  --------   -----",crlf);

      getformat(OldWidth,OldDigits);
      setformat(8,0);
      for i_1 step 1 until 999 do
         if DistCount[i] > 0 then
           print(crlf,i,DistCount[i]);
      setformat(OldWidth,OldDigits);		! back to the old values;

      print (crlf);
     END;

One!Release(AccFile);

END "NotChg";
endc

ifc MainVer thenc
procedure Unprocessed;
BEGIN

print (crlf2,crlf,
  "Report of unprocessed BCHARGE customer requests on System ",Sysno,":");
NotCharged(ParFile);

print (crlf2,crlf,
"Report of unprocessed RCHARGE customer requests on System ", Sysno,":");
NotCharged(SplFile);

END;
endc
ifc MainVer thenc

simple procedure print!charge;
DSCR Used to print info contained in AccBuf.
     The other words depend on the job type and so are
     handled elsewhere.
     THIS PROCEDURE ASSUMES THAT THE FILE HAS BEEN PREPROCESSED:
	1.  The customer field is either 0 or 1.
	2.  The Job Type is legal.
	3.  Each job type 10 record is immediately followed in the
	    file by a job type 11 record.
	4.  The record looks "reasonable", i.e. error checking
	    has already been done, so all we do is print it.
;
BEGIN "AccPrint" integer JobKind, Tmp;
		 string Timesub, Submitted, WhenDone;
! First look up job type--if 10, copy AccBuf into CopyAcc and return.
  We will print it when we find the job type 11 for it.;
JobKind_cvd(PntAcc(Type));
if JobKind=10
  then BEGIN arrblt(CopyAcc[0],AccBuf[0],AccSiz); Return; End;

! Pick up the dates so that we can pretty-print them;
TimeSub_dynstr(acc.Time!In.cnt,acc.Time!In);
Submitted_dynstr(acc.Date!In.cnt,acc.Date!In);
Submitted_Submitted[3 to 4] & "-" & Month[cvd(Submitted[1 to 2])] &
           " " & TimeSub[1 to 2] & ":" & TimeSub[3 to 4];
WhenDone_dynstr(acc.Date!Done.cnt,acc.Date!Done);
WhenDone_WhenDone[5 to 6] & "-" & Month[cvd(WhenDone[3 to 4])] &
	    "-" & WhenDone[1 to 2];
cprint(var, crlf2,
      "Request #", SysNo,  PntAcc(Num), "	",
      "		", JobType[cvd(PntAcc(Type))],
      if cvd(PntAcc(Customer))=1 then "	(Customer)" else null, Crlf,
      "Submitted:     ", Submitted, "	", "Completed:	", 
      WhenDone, Crlf,
      "Name:          ", PntAcc(Name),
      "	District:	", PntAcc(District), Crlf,
      "Project code:  ", PntAcc(Proj!Code),
      "	PPN:		", cvd(PntAcc(Gan)), ",", cvd(PntAcc(Aun)),
      Crlf);

! Now print the job-specific information;

case JobKind of
  BEGIN
    [1]  cprint(var,  cvd(PntAcc(vol)), " pages",
		if (tmp_cvd(PntAcc(parts)))=0
		  then " SPECIAL FORM"
		  eif tmp>1 then ", " & cvs(tmp) & "-part paper"
		     else " ",
		if cvd(PntAcc(Burst))=1
		  then " (decollated)" else null,
		if (tmp_cvd(PntAcc(Delivery)))>0
		  then Crlf & "Delivery Charge:  " & cvs(tmp)
		  else null);
   [2]
    [3]  cprint(var,  cvd(PntAcc(Vol)), " cards processed.",
	        if (tmp_cvd(PntAcc(Delivery)))>0
	   	  then "		Delivery Charge:  " & cvs(tmp)
		  else null);
   [4]
    [5]  cprint(var,  cvd(PntAcc(Vol)), " files processed.",
	 	if (tmp_cvd(PntAcc(Delivery)))>0
	   	  then "	Delivery Charge:  " & cvs(tmp)
		  else null);
    [7]  cprint(var,  cvd(PntAcc(Vol)), " files processed.", "	",
	        if (tmp_cvd(PntAcc(Tap!Cvt)))>0
		  then cvs(tmp) & " tapes converted.	" else null,
	        if (tmp_cvd(PntAcc(Delivery)))>0
	   	  then "		Delivery Charge:  " & cvs(tmp)
		  else null);
    [8]  cprint(var,  cvd(PntAcc(Vol))*100, " characters processed.	",
	        if (tmp_cvd(PntAcc(Tap!Buy)))>0
		  then cvs(tmp) & " tapes purchased.	" else null,
	        if (tmp_cvd(PntAcc(Delivery)))>0
	   	  then "Delivery Charge:  " & cvs(tmp) else null);
    [9]  cprint(var,  cvd(PntAcc(Vol)), " pages (",
		cvd(PntAcc(Xmitted)),
		" characters) printed.");
   [11]  BEGIN integer SwapCnt;
	       cprint(var,  cvd(PntAcc(Vol)), " pages ",
		      if (tmp_cvd(PntAcc(parts)))=0
		        then "SPECIAL FORMS"
		        eif tmp>1 then cvs(tmp) & "-part paper"
		        else null,
		      if cvd(PntAcc(Burst))=1
			then " (decollated)" else null);
	       tmp_cvd(PntAcc(Delivery));  ! Save for later use;
	       for swapcnt_11 step 1 until 15 do
		 AccBuf[SwapCnt] swap CopyAcc[SwapCnt];
	       cprint(var,  Crlf, cvd(PntAcc(Tap!Buy)), " files (",
		      cvd(PntAcc(Xmitted)), " characters) printed.",
		      if tmp>0
			then Crlf & "Delivery Charge:  " & cvs(tmp)
			else null);
                for swapcnt_11 step 1 until 15 do
		 AccBuf[SwapCnt] swap CopyAcc[SwapCnt];
         END;
   [12]  cprint(var,  cvd(PntAcc(Tap!Buy)), " files printed.	",
	        if (tmp_cvd(PntAcc(Delivery)))>0
	   	  then "		Delivery Charge:  " & cvs(tmp)
	   	  else null);
   [13]  cprint(var,  Crlf, "Delivery Charge:  ", cvd(PntAcc(Delivery)));
   else
  END;
END "AccPrint";
endc
ifc MainVer thenc
procedure acct!print;
DSCR Prints out the information in the monthly batch accounting
     file.
;
BEGIN
Set!BatName;
AccFile_Opn!Read(BatName,m.binary);
AccCnt_0;
setprint(NewLogFile,"F");			! No output to TTY;
while Read!Acc do print!charge;
setprint(NewLogFile,"B");			! Back to TTY too;
All!Release;
print(crlf2, "Scanned ",AccCnt, " records.",crlf2,
"Monthly batch accounting file information printed in log file.");
END;
endc


ifc MainVer thenc

Simple Procedure StrStf(string s; integer bytptr);
BEGIN 
While length(s) do
  idpb(lop(s), bytptr);
END;
endc
ifc MainVer thenc

DSCR
The following two procedures are used to compare the number of pages and the
number of characters that are in the Gdf and Fdf file records with those of
the accounting file records (currently the monthly Batch file, Parchg.dat, and 
Splchg.dat).  To do this, the Gdf file is read into the array QuickGdf, which
contains pointers to a record class called FdfNames. Ordinarilly, this record 
class contains fields for the file name and extension of the Fdf records for the
Gdf record with the same request date and #.  As each Gdf record is read into
the array, the routine IncFilCnt is called, which takes the fields pf.fname and
pf.dext from the Fdf buffer and places them into the record class fields
FdfNames: TheName and TheExt.  Since the filename has no purpose in these 
routines, and since the construct is already there and available for use,
the fields pf.fname and pf.dext are replaced by the page and char counts from 
Fdf records (determined by count!chars), which are then picked
up by IncFilCnt and placed into the array QuickGdf.  In order not to create too
much confusion about this, the fields have been appropriately renamed.
        
After the QuickGdf array has been set up, each accounting file is opened and
a routine is called which compares the character and page count fields.  If they
match, then all is well.  If they do not, then the appropriate information
concerning the request is printed.  At the end of the accounting routine,
statistics are printed to show how much the character and page
counts (in the accounting files) are off from the Spool files.

This is done in order to indicate how much revenue Tymshare is losing or
gaining as a result of a suspected bug in Spool that in some instances will not
report the correct number of pages or characters to the accounting files.
Accounting records are changed by the procedures to match spool records.
;





Integer cuschr, gcchcnt, bcchcnt, xcchr, cntacc, bpacc, bcacc, bccacc, bicacc,
bipacc, bcpacc, cuspag, inhpag, inhchr, gcpgcnt, bcpgcnt, xcpag, xipag, xichr,
badchcnt, badpgcnt, totpag, totchr, gichcnt, bichcnt, gipgcnt, bipgcnt,
ocpgcnt, oipgcnt, occhcnt, oichcnt, ovrpgcnt, ovrchcnt, 
CFflag, CFchan;

DEFINE
        CountCom        = <FdfNames>,
        TopCount        = <TopName>,
        PageCnt         = <TheExt>,
        CharCnt         = <TheName>,
        Pa.count        = <pf.dext>,
        Ch.count        = <pf.fname>;

endc



ifc MainVer thenc

Procedure Compare!AccFile(String AccFilnam);
  
While TRUE do
BEGIN "CompareFiles"
  arrclr(AccBuf); arrclr(CopyAcc);
  badchcnt_badpgcnt_bpacc_bcacc_cntacc_xcpag_xipag_cuspag_cuschr_inhchr_0;
  inhpag_gcchcnt_bcchcnt_xcchr_xichr_totchr_gichcnt_bichcnt_bipacc_bcpacc_0;
  bicacc_bccacc_totpag_gcpgcnt_bcpgcnt_gipgcnt_bipgcnt_ocpgcnt_oipgcnt_0;
  occhcnt_oichcnt_ovrpgcnt_ovrchcnt_0;
  If ((AccFile_Opn!Read(AccFilnam, m.binary, false)) = n!r) or
    ((NewAccFile_Opn!Write(AccFilnam, m.binary, false)) = n!r)
    then done "CompareFiles";
  
  cprint(var, crlf2, crlf2, "Beginning compare of ", AccFilnam,
  " against the Spool data base ... ", crlf);
  
  While Read!Acc do
    BEGIN "AccRec" r!p(GdfLink) TmpLink;
      Integer date, request, gdate;
      request_cvd(PntAcc(Num));
      TmpLink_QuickGdf[request];
  
      While TmpLink neq n!r do
        BEGIN "GdfRec" r!p(CountCom) TmpPtr; string day;
          gdate_GdfLink:i$date[TmpLink];
          If 10 > date_((gdate mod 31) + 1) 
            then day_("0" & cvs(date))
            else day_cvs(date);
          date_cvd(cvs(((gdate div 31) mod 12) + 1) & day);
          If cvd(PntAcc(Date!in)) = date

            then BEGIN "FdfRec" integer nochars, nopages, type, cust, ccnt,
              ocnt, width, digits;
              TmpPtr_GdfLink:TopCount[TmpLink];
              type_cvd(PntAcc(Type));
              cust_cvd(PntAcc(Customer));
              Case type of BEGIN [1] [11]
          
                BEGIN "ComPag" integer pcnt;
                  Inc(cntacc);
                  nopages_cvd(PntAcc(vol));
                  pcnt_CountCom:PageCnt[TmpPtr];
                  If (nopages neq pcnt) or ((type = 11) and (ccnt neq -1))
          
                    then BEGIN "PrtPag"
                      print!charge;
                      cprint(var, crlf, "Gdf pages: ", pcnt, crlf);
                      If type = 11
                        then cprint(var, "Fdf chars: ", ocnt, crlf);
                    END "PrtPag";

                  If nopages neq pcnt

                    then BEGIN "BadPag"
                    getformat(width,digits);
                    setformat(6,0);
                    StrStf(cvs(pcnt), acc.vol);
                    setformat(width,digits);
                      If cust = 1

                        then BEGIN "BpgCus"
                          If ((pcnt-nopages) > 0)
                            then bcpgcnt_bcpgcnt+pcnt-nopages
                            else ocpgcnt_ocpgcnt+nopages-pcnt;
                          xcpag_xcpag+nopages;
                          Inc(bcpacc);
                        END "BpgCus"

                        Else BEGIN "BpgInh"
                          If ((pcnt-nopages) > 0)
                            then bipgcnt_bipgcnt+pcnt-nopages
                            else oipgcnt_oipgcnt+nopages-pcnt;
                          xipag_xipag+nopages;
                          Inc(bipacc);
                        END "BpgInh";
              
                    END "BadPag"

                    else BEGIN "GudPag"
                      If cust = 1
                        then gcpgcnt_gcpgcnt+nopages
                        else gipgcnt_gipgcnt+nopages;
                    END "GudPag";

                END "ComPag";
          
              [10]
          
                BEGIN "ComChr" 
                  nochars_cvd(PntAcc(xmitted));
                  ocnt_ccnt_CountCom:CharCnt[TmpPtr];
                  print!charge;
                  If nochars neq ccnt

                    then BEGIN "BadChr"
                      getformat(width,digits);
                      setformat(9,0);
                      StrStf(cvs(ccnt), acc.xmitted);
                      setformat(width,digits);
                      If cust = 1

                        then BEGIN "BchCus"
                          If ((ccnt-nochars) > 0)
                            then bcchcnt_bcchcnt+ccnt-nochars
                            else occhcnt_occhcnt+nochars-ccnt;
                          xcchr_xcchr+nochars;
                          Inc(bccacc);
                        END "BchCus"

                        Else BEGIN "BchInh"
                          If ((ccnt-nochars) > 0)
                            then bichcnt_bichcnt+ccnt-nochars
                            else oichcnt_oichcnt+nochars-ccnt;
                          xichr_xichr+nochars;
                          Inc(bicacc);
                        END "BchInh";
            

                    END "BadChr"
            
                    Else BEGIN "GudChr"
                      ccnt_-1;
                      If cust = 1
                        then gcchcnt_gcchcnt+nochars
                        else gichcnt_gichcnt+nochars;
                      END "GudChr";

                END "ComChr";
              else 	! done with FefRec;
              END;
              
            END "FdfRec";
            
          TmpLink_GdfLink:Nxtl[TmpLink];

        END "GdfRec";
            
      Arryout(File[NewAccFile],AccBuf[0],AccSiz);
            
    END "AccRec";
            
  cuspag_gcpgcnt+bcpgcnt+xcpag;
  inhpag_gipgcnt+bipgcnt+xipag;
  totpag_cuspag+inhpag;
  badpgcnt_bcpgcnt+bipgcnt;
  ovrpgcnt_ocpgcnt+oipgcnt;
  bpacc_bipacc+bcpacc;

  cuschr_gcchcnt+bcchcnt+xcchr;
  inhchr_gichcnt+bichcnt+xichr;
  totchr_cuschr+inhchr;
  badchcnt_bcchcnt+bichcnt;
  ovrchcnt_occhcnt+oichcnt;
  bcacc_bicacc+bccacc;

  cprint (var,
crlf2, cntacc, " records were found in ", AccFilnam, crlf, 
" to compare against the Spool data base. ", crlf2);

  If cntacc then cprint(var,
bpacc, " records were found with bad page counts. ", crlf);

  If bpacc then cprint(var,
"Total page count should have been ", totpag,
".", crlf, "        Customer: ", cuspag, " pages,    Inhouse: ",
inhpag, " pages.", crlf);

  If badpgcnt then cprint(var,
"There were ", badpgcnt, " pages not charged. ", crlf,
"        Customer: ", bcpgcnt, " pages,    Inhouse: ", bipgcnt, " pages.", crlf);

  If ovrpgcnt then cprint(var,
"There were ", ovrpgcnt, " pages overcharged. ", crlf, "        Customer: ",
ocpgcnt, " pages,        Inhouse: ", oipgcnt, " pages. ", crlf);

  If cntacc then cprint(var,
crlf, bcacc, " records were found with bad character counts. ", crlf);

  If bcacc then cprint(var,
"Total character count should have been ", totchr, ".", crlf,
"        Customer: ", cuschr, " chars,    Inhouse : ", inhchr, " chars.", crlf);

  If badchcnt then cprint(var,
"There were ", badchcnt, " characters not charged. ", crlf,
"        Customer: ", bcchcnt, " chars,    Inhouse: ", bichcnt, " chars. ",crlf);

  If ovrchcnt then cprint(var,
"There were ", ovrchcnt, " chars overcharged. ", crlf, "        Customer: ",
occhcnt, " chars,        Inhouse: ", oichcnt, " chars. ", crlf);

  One!Release(AccFile);

END "CompareFiles";
endc

            
ifc MainVer thenc
Simple Procedure Compare!Pages;

BEGIN "OpenFiles"
  
  print(crlf,"Beginning compare...");
  GdfPtr_Opn!Read(GdfFile,m.binary);
  FdfPtr_Opn!Read(FdfFile,m.binary);


  setprint(NewLogFile,"S");               ! Suppress output to this file;
  open(CFchan_getchan,"dsk",0,0,1,0,0,0);    ! Send output to another file;
  enter(CFchan, CompFile, CFflag);
  var_CFchan;
  
  While Read!Gdf do
    BEGIN "BldGdf" integer data, req;
      req_cvd(cv6str(ldb(pg.Req!Num) lsh 6));
      If Set!GdfInf(data_ldb(pg.nofiles))
        then cprint(var, crlf, "#DAMAGE to Gdf record request # ", req)
    
        Else BEGIN "DepFdf" integer chs;
          chs_count!chars;
          Dpb(chs,Ch.count);
          Dpb(Pgs,Pa.count);
          If Inc!FilCnt     
            then cprint(var, crlf, "GdfLink record not found for request # ", req);
        END "DepFdf";
  
    END "BldGdf";
  
  Set!BatName;
  Compare!AccFile(BatName);
  Compare!AccFile(SplFile);
  Compare!AccFile(ParFile);
  
  
release(CFchan,0);                        ! Close the output file;
var_-1;
setprint(NewLogFile,"B");               ! Output back to way it was;
print ("Done!!",crlf2,
    "Accounting records corrected; report in (spool)splcom.fil.",crlf);

END "OpenFiles";
endc


ifc MainVer thenc
boolean procedure Charge!It(string OldOne,NewOne; boolean WantRemote);
DSCR Assumes that we have an accounting record in AccBuf (plus one in
     CopyAcc if WantRemote is true).  OldOne is opened, copied to
     NewOne.  If OldOne is busy, the user is asked if he wants to
     try again.  The charge is appended to NewOne, OldOne is
     deleted, and NewOne is renamed to be OldOne.
;
BEGIN "Charge!" r!p(Chan) OldFile, NewFile;
OldFile_NewFile_n!r;
while true do
  BEGIN "GrabIt"
    OldFile_Opn!Update(OldOne,m.binary,false);
    if OldFile neq n!r then done "GrabIt";
    if not Confirm("Try again?") then return(false);
  END "GrabIt";
NewFile_Opn!Write(NewOne,m.binary);
inout(File[OldFile],File[NewFile],-1);
if WantRemote
  then arryout(File[NewFile],CopyAcc[0],AccSiz);
arryout(File[NewFile],AccBuf[0],AccSiz);
rename(File[OldFile],null,AllRdNo,Flag[OldFile]);
rename(File[NewFile],OldOne,AllRdNo,Flag[NewFile]_0);
if Flag[NewFile] neq 0
  then ErrorExit("Unable to rename " & NewOne & " to be " & OldOne);
One!Release(NewFile);
One!Release(OldFile);
return(true);
END "Charge!";
endc
ifc MainVer thenc
boolean procedure Make!Charge(boolean OneByOne(false));
DSCR Reads the record in GdfBuf and creates a charge record in
     AccBuf (and CopyAcc if we are dealing with a remote request).
     If OneByOne is true we are charging single requests by hand and
     so we show the user the charge and ask for confirmation before
     making it.  In this case we also close the accounting files so
     that we have them open for the minimum length of time.
     IT IS ASSUMED THAT THE RECORD IN GdfBuf HAS ALREADY BEEN CHECKED
     TO SEE THAT IT HAS A REASONABLE FORMAT.
;
BEGIN "MakeCharge" boolean IsRemote, NeedDelivery;
		integer Leng, Ptr, Temp;  string Info;

! The following macro copies the ASCII string contained in Info into
  the field of the accounting record indicated by X.  Info is padded
  with leading spaces as needed. ;
DEFINE Write$Acc(X)=
  <Info_Spaces[1 to (acc.>&<X>&<.cnt-length(Info))] & Info;
  Ptr_acc.>&<X>&<;
  for Leng_1 step 1 until acc.>&<X>&<.cnt do
    idpb(lop(Info),Ptr);>;

IsRemote_ldb(pg.destination)=2;
NeedDelivery_6 neq ldb(pg.delivery) neq 1;

! Begin by writing the fields that do not depend on job type;

Info _ if NeedDelivery then "03" else Sysno;
Write$Acc(Status);

Info_cvxstr(ldb(pg.batch!number!six) lsh 18);
Write$Acc(Num);

Temp_ldb(pg.Request!Date);
Info_cvs(((Temp div 31) mod 12) + 1);
if length(Info)=1 then Info _ "0" & Info;
Temp_(Temp mod 31)+1;
if Temp leq 9 then Info_Info&"0";
Info_Info & cvs(Temp);
Write$Acc(Date!In);

Temp_ldb(pg.Request!Time);
Info_cvs(Temp div 60);
if length(Info)=1 then Info_"0"&Info;
Temp_Temp mod 60;
if Temp leq 9 then Info_Info & "0";
Info _ Info & cvs(Temp);
Write$Acc(Time!In);

Info_cvxstr(ldb(pg.Charge!User)) & cvxstr(ldb(pg.Charge!User2));
Write$Acc(Name);

Info_cvos(ldb(pg.charge!aun) lsh -18);
Write$Acc(Gan);
Info_cvos(ldb(pg.charge!aun) land '777777);
Write$Acc(Aun);

Info_cvs(ldb(pg.Charged!District));
Write$Acc(District);

Info_cvxstr(ldb(pg.Project)) & cvxstr(ldb(pg.Project2));
Write$Acc(Proj!Code);

Info_cvs(ldb(pg.Customer));
Write$Acc(Customer);

! If there is a good completion date use it,
  otherwise use the current date. ;
if (Temp_ldb(pg.completion!date)) leq 0 then Temp_CurDate;
Info_cvs(((Temp div 31) div 12)+64);
if length(Info)=1 then Info _ "0" & Info;
if (((Temp div 31) mod 12)+1) leq 9 then Info_Info & "0";
Info_Info & cvs(((Temp div 31) mod 12)+1);
if (Temp_(Temp mod 31)+1) leq 9 then Info_Info & "0";
Info_Info & cvs(Temp);
Write$Acc(Date!Done);

Info_Crlf;
Write$Acc(End!Mark);

! If this is a remote request, make the job type 10 record;

If IsRemote
  then BEGIN
	 Info_"10";
	 Write$Acc(Type);
	 Info_Null;
	 Write$Acc(Vol);		! Write spaces;
	 Info_cvs(Count!Chars);		! Count!Chars is a procedure;
	 Write$Acc(Xmitted);
	 Info_cvs(ldb(pg.NoFiles));
	 Write$Acc(Tap!Buy);
	 arrblt(CopyAcc[0], AccBuf[0], AccSiz);
	 Ptr_acc.Vol;
	 for Leng_1 step 1 until 22 do	! Clear job type 10 data;
	   idpb(" ",Ptr);
       END;

! Now do the job-specific fields for types 1 or 11;

Info _ if IsRemote then "11" else " 1";
Write$Acc(Type);

Info_cvs(ldb(pg.pages));
Write$Acc(Vol);

Info_cvs(ldb(pg.Parts));
Write$Acc(Parts);

Info_cvs(ldb(pg.decollate));
Write$Acc(Burst);

Info _ if NeedDelivery then " " else "0";
Write$Acc(Delivery);

Info_"";
Write$Acc(Tap!Buy);		! Set unused field to spaces;

if OneByOne
  then BEGIN
	 if NeedDelivery and Affirm("Do you know the delivery charge?")
	   then BEGIN String DelChg; integer xint;
		  print("Enter it (in cents) *");
		  if (0 > (xint_cvd(DelChg_Clean(inchwl)))) or
		     (xint > 10000)
		    then print(Crlf,"Bad Charge!!  Use B/Rcharge!")
		    else BEGIN
			   info_DelChg;
			   Write$Acc(Delivery);
			   NeedDelivery_false;
			 END;
	        END;
       END;

Print!Charge;

if OneByOne
  then BEGIN string OldFilNam, NewFilNam;
	 if not Confirm("Charge it?") then return(false);  ! No charge;
	 if NeedDelivery
	   then BEGIN
		  if IsRemote
		    then BEGIN
			   OldFilNam_SplFile;
			   NewFilNam_SplNew;
			 END
		    else BEGIN
			   OldFilNam_ParFile;
			   NewFilNam_ParNew;
		         END;
		 END
	    else BEGIN
		   Set!BatName;
		   OldFilNam_BatName;
		   NewFilNam_BatDir & "BAT" & SysNo & ".NEW";
		 END;
	 if not Charge!It(OldFilNam,NewFilNam,IsRemote)
	   then return(false);
       END;
return(true);
END "MakeCharge";
endc
ifc MainVer thenc
boolean procedure Find!Gdf;
DSCR Prompts the user for a request number and a user name.  Searches
     the GDF file for a match.  If it finds a match, it prints the
     date and asks the user if this is the desired request.  If
     user says no and we are not at end of file, see if can find
     another match.  Return false if anything seems too wrong.
     If the user confirms a match, check the GDF record to see if it
     looks reasonable.  If it's OK, find the matching FDF records.
     If there are problems, ask the user what to do:
     s/he can supply a new file count, page count, and (if a remote
     request) character count.
     Returns true if we find a match and everything is set up OK.
;
BEGIN "FindGdf" integer ReqDate, FilCnt, PagCnt, FFilCnt, FPagCnt;
		integer Tmp, BatNum, User1, User2;
		string InReq; r!p(MapMatches) MapList;
InReq_null;

while true do
  BEGIN "GetNum"
    print(Crlf,"Request number *");
    InReq_Clean(inchwl);
    if not length(InReq) then return(false);
    if (length(InReq) neq 5) or (1 > cvd(InReq[3 for 3]) > 999) or
       (not equ(InReq[1 to 2],SysNo))
      then BEGIN
	     print(Crlf,"Enter ", SysNo, " followed by a 3-digit ",
		   "number (e.g. ", SysNo, "001).  Try again.");
	     continue "GetNum";
	   END;
    done "GetNum";
  END "GetNum";

! Save the request number as RIGHT-justified sixbit for search;
BatNum_cvsix(InReq) lsh -6;

if GdfPtr=n!r
  then GdfPtr_Opn!Read(GdfFile,m.binary);
MapList_Search!Map(cvd(InReq[3 for 3]));
while MapList neq n!r do
  BEGIN "ConfirmMatch"
    useti(File[GdfPtr],MapMatches:BlkNum[MapList]);
    arryin(File[GdfPtr],GdfBuf[0],GdSiz);
    if not BatNum = ldb(pg.Req!Num)
      then ErrorExit("Map file is out of sync with the GDF file!" & Crlf &
	         "Repair the SPOOL data base and try again.");
    if Confirm(Crlf & cv6str(ldb(pg.Request!User)) &
	       cv6str(ldb(pg.Request!User2)) & " from " &
	       PrintDate(ReqDate_ldb(pg.Request!Date)) & "?")
       then done "ConfirmMatch";
    MapList_MapMatches:NxtMatch[MapList];
  END "ConfirmMatch";
if MapList=n!r
  then BEGIN
	 print(Crlf,"No match found.");
	 return(false);
       END;
GdfCnt_MapMatches:BlkNum[MapList];	! For use in Set!GdfToDone;

! Now check status of request and if it is not Process or Tape, do not 
! continue unless confirmed;

if not Status.Is(Tape) and not Status.Is(InProcess) then 
  BEGIN
  if Status.Is(Pending) then
     print(Crlf,"WARNING:  This is a pending request!")
  eif Status.Is(Tape.Done) then
    print(Crlf,"WARNING:  GDF says this is a completed tape request!")
  eif Status.Is(Completed) then
     print(Crlf,"WARNING:  This is a completed request! ")
  eif Status.Is(Completed.Deleted) then
   print(Crlf,"WARNING:  This is a completed request! ")
  eif Status.Is(Canceled) then
      print(Crlf,"WARNING:  GDF says this is a canceled request!")
  eif Status.Is(Transfer) then
      print(Crlf,"WARNING:  GDF says this is a transfer request!")
  eif Status.Is(Hold) then
          print(Crlf,"WARNING:  GDF says this request is on hold!");

  if Confirm("Stop?") then return(false)
  END;

if ldb(pg.charge!user) = 0
  then BEGIN
	 print(Crlf,"No name for charged user!",
	       Crlf,"Submitted by:  ", cvxstr(ldb(pg.request!user)),
	       cvxstr(ldb(pg.request!user2)));
         if Confirm("Bill the submittor?")
	   then BEGIN
		  GdfBuf['31]_GdfBuf['27];
		  GdfBuf['32]_GdfBuf['30];
		END
	   else return(false);
       END;

if (Tmp_ldb(pg.charged!district)) > 300
  then BEGIN
	 print(Crlf,"Bad district for charged user!");
	 if Affirm("Do you know the proper district?")
	   then BEGIN integer NewDist;
		  print("New District *");
		  if (NewDist_cvd(Clean(inchwl))) < 0 or
		     (NewDist) > 300
		    then return(false)
		    else GdfBuf['21]_(GdfBuf['21] land '777000777777)
				       lor (NewDist lsh 18);
	        END
	   else return(false);
       END;

if GdfBuf['34] leq 0 then GdfBuf['34]_1;	! Check FDF pointer;

! Now check the FDF file--verify the number of pages and make sure
  all the FDF records are there -- if not, correct the number of
  files.;
FilCnt_ldb(pg.nofiles);
PagCnt_ldb(pg.pages);

if FdfPtr=n!r
  then FdfPtr_Opn!Read(FdfFile,m.binary);
FFilCnt_FPagCnt_0;

useti(File[FdfPtr],ldb(pg.free!word!1));

while read!fdf do
  BEGIN "CountIt";
    if (ReqDate = ldb(pf.request!date)) and (BatNum=ldb(pf.Req!Num))
      then BEGIN
	     FPagCnt_FPagCnt+ldb(pf.pages);
	     FFilCnt_FFilCnt+ldb(pf.Char!Xmit);
	     FilCnt_FilCnt-1;
	   END;
    if FilCnt = 0 then Done "CountIt";
  END "CountIt";

if FilCnt > 0
  then BEGIN
	 print(Crlf, "Missing ", FilCnt, " FDF records.");
	 if Affirm("Continue anyway?")
	   then dpb(ldb(pg.nofiles)-FilCnt,pg.nofiles)
	   else return(false);
       END;

if (PagCnt_ldb(pg.pages)) neq FPagCnt
  then BEGIN
	 print(Crlf,"Page counts disagree:  GDF says ", PagCnt,
	       " while FDF says ", FPagCnt, ".");
	 if Affirm("Do you want to use the maximum?")
	   then PagCnt_PagCnt max FPagCnt
	   else PagCnt_PagCnt min FPagCnt;
	 dpb(PagCnt,pg.pages);
       END;

if ldb(pg.decollate) > 1 then dpb(1,pg.decollate); ! Set to want burst;

! Things are checked out now, so return true to say that we're ready;
return(true);
END "FindGdf";
endc
ifc MainVer thenc
procedure Statistics;

DSCR This counts statistics on fields in the GFD and prints a report in
the spool log, separating the counts for customer and in house requests.

The first macro defines the text for the printout, and the count to be
incremented that will be printed out with the text.

To add a field, both the text and count need to be added to this macro
and the condition statement added below.
;
BEGIN

DEFINE Option!Count = 0;

DEFINE OpList = <
!Name(IndentCnt,"Indent")
!Name(FullCnt,"Full Case")
!Name(HeadCnt,"Heading")
!Name(Cop1Cnt,  "Copies: 1")
!Name(CopMulCnt,"        Multiple")
!Name(QuestCnt,"Quest")
!Name(TransCnt,"Transfer")
!Name(FortranCnt,"Fortran")
!Name(TopFormCnt,"    1 - Top of Form")
!Name(HalfPageCnt,"    2 - 1/2 Page")
!Name(ThirdPageCnt,"    3 - 1/3 Page")
!Name(SixthPageCnt,"    / - 1/6 Page")
!Name(OverprintCnt,"    + - Overprint")
!Name(NextLineCnt,"    * - Next Line")
!Name(SecondLineCnt,"    comma - 2nd Line")
!Name(ThirdLineCnt,"    . - 3rd Line")
!Name(DblSpCnt,"    0 - Double Space")
!Name(TriSpCnt,"    - - Triple Space")
!Name(DoubleCnt,"Double Space")
!Name(CenComCnt,"Completed at: Center")
!Name(RemComCnt,"              Remote")
!Name(CenPrCnt,"Print at: Center")
!Name(RemPrCnt,"          Remote")
!Name(SmallCnt,"Paper size: Small")
!Name(LargeCnt,spaces[1 to 12] & "Large")
!Name(TtyCnt,spaces[1 to 12] & "Tty")
!Name(SpecialCnt,spaces[1 to 12] & "Special")
!Name(SmWhiteCnt,spaces[1 to 12] & "Small White")
!Name(LgWhiteCnt,spaces[1 to 12] & "Large White")
!Name(Part0Cnt,"Forms: 0 Parts")
!Name(Part1Cnt,"       1 Part")
!Name(Part2Cnt,"       2 Parts")
!Name(Part3Cnt,"       3 Parts")
!Name(Part4Cnt,"       4 Parts")
!Name(DecollateCnt,"Decollate")
!Name(USMailCnt,"Delivery: US Mail")
!Name(PickCnt, "          Pickup")
!Name(CourierCnt, "          Courier")
!Name(SpDelCnt, "          Sp. Delivery")
!Name(AirExCnt, "          Air Express")
!Name(OfficeCnt, "          Inter-office")
!Name(KataCnt,"Katakana")
!Name(LinesCnt,"Lines per Page")
!Name(ChargeCnt,"Charge Other")
!Name(SameUsername,"Req/Charge Username Same")
!Name(DifUsername,"    Username Different")
!Name(SameGan,"Req/Charge Gan/UUN  Same")
!Name(DifGan,"    Gan/UUN  Different")
>;
DEFINE !Name(x,y) = <
   REDEFINE Option!Count = Option!Count + 1;
   DEFINE x = Option!Count;
>;
OpList
REDEFINE !Name(x,y) = <
  ,y
>;

! Macros for options with varying responses;

DEFINE  Center   = <1>,           Remote   = <2>,
        Small    = <1>,           Large    = <2>,
        Tty      = <3>,           Special  = <4>,
        SmallWhite = <5>,         LargeWhite  = <6>,
        USMail   = <0>,           Pickup   = <1>,
        Courier  = <2>,           SpecialDelivery = <3>,
        AirExpress = <5>,         InterOffice = <6>;

! Macro to increment appropriate counts;

DEFINE StatCount(z) = <
if IsInHouse then inc(InHouse[z]) else inc(Customer[z]) >;

preload!with "unknown"
    OpList;
own string array Options[0:Option!Count];

! Separate arrays are set up for in house and customer requests, and
boolean IsInHouse is defined in order to compile statistics separately;

integer array InHouse,Customer[1:Option!Count];
integer line,InHouseCnt,CustomerCnt,LastDigits,LastWidth;
boolean IsInHouse;        

arrclr(InHouse);
arrclr(Customer);
InHouseCnt_CustomerCnt_0;

! To print out nicely text lines are padded with spaces to column 25;

for line_1 step 1 until Option!count do
  Options[line]_Options[line] & spaces[1 for 25 - length(Options[line])];

print (Crlf,"Compiling statistics...");

GdfPtr_Opn!Read(GdfFile,m.binary);

while Read!Gdf do
  BEGIN  "CompileStatistics"
  if ldb(pg.customer) = 0 then         
    BEGIN
    IsInHouse_TRUE;
    inc(InHouseCnt)
    END
  else
    BEGIN
    IsInHouse_FALSE;
    inc(CustomerCnt)
    END;

  if ldb(pg.fullcase) = 1 then StatCount(FullCnt);
  if ldb(pg.heading) = 1 then StatCount(HeadCnt);
  if ldb(pg.quest) = 1 then StatCount(QuestCnt);
  if ldb(pg.transfer!request) = 1 then StatCount(TransCnt);

  if ldb(pg.fortran!conversion) = 1 then

    BEGIN "FortranOp"
    StatCount(FortranCnt);
    if ldb(pg.top!of!form) = 1 then StatCount(TopFormCnt);
    if ldb(pg.half!page) = 1 then StatCount(HalfPageCnt);
    if ldb(pg.third!page) = 1 then StatCount(ThirdPageCnt);
    if ldb(pg.sixth!page) = 1 then StatCount(SixthPageCnt);
    if ldb(pg.overprint) = 1 then StatCount(OverprintCnt);
    if ldb(pg.next!line) = 1 then StatCount(NextLineCnt);
    if ldb(pg.second!line) = 1 then StatCount(SecondLineCnt);
    if ldb(pg.third!line) = 1 then StatCount(ThirdLineCnt);
    if ldb(pg.skip!line) = 1 then StatCount(DblSpCnt);
    if ldb(pg.skip!2lines) = 1 then StatCount(TriSpCnt);
    END "FortranOp";
    

  if ldb(pg.double!space) = 1 then StatCount(DoubleCnt);
  if ldb(pg.decollate) = 1 then StatCount(decollateCnt);
  if ldb(pg.katakana = 1) then StatCount(KataCnt);

  if ldb(pg.print!count) = 1 then StatCount(Cop1Cnt)
     else StatCount(CopMulCnt);

  if ldb(pg.charge!other) = 1 then StatCount(ChargeCnt);
  if (ldb(pg.indent) > 0) then StatCount(IndentCnt);
  if ldb(pg.where!completed) = Center then StatCount(CenComCnt);
  if ldb(pg.where!completed) = Remote then StatCount(RemComCnt);
  if ldb(pg.destination) = Center then StatCount(CenPrCnt);
  if ldb(pg.destination) = Remote then StatCount(RemPrCnt);

  case ldb(pg.paper!size) of BEGIN
    [Small]        StatCount(SmallCnt);
    [Large]        StatCount(LargeCnt);
    [Tty]          StatCount(TtyCnt);
    [Special]      StatCount(SpecialCnt);
    [SmallWhite]   StatCount(SmWhiteCnt);
    [LargeWhite]   StatCount(LgWhiteCnt)  END;

  case ldb(pg.parts) of BEGIN
    [0]  Statcount(Part0Cnt);
    [1]  StatCount(Part1Cnt); 
    [2]  StatCount(Part2Cnt); 
    [3]  StatCount(Part3Cnt); 
    [4]  StatCount(Part4Cnt)      END;

  case ldb(pg.delivery) of BEGIN
    [USMail]           StatCount(USMailCnt);
    [Pickup]           StatCount(PickCnt);
    [Courier]          StatCount(CourierCnt);
    [SpecialDelivery]  StatCount(SpDelCnt);
    [AirExpress]       StatCount(AirExCnt);
    [InterOffice]      StatCount(OfficeCnt)   END;
    
  if (ldb(pg.paper!size) = Small and ldb(pg.lines!per!page) neq 45) or
   ((ldb(pg.paper!size) = Large or ldb(pg.paper!size) = tty) and
    ldb(pg.lines!per!page) neq 60) then StatCount(LinesCnt);

  if ldb(pg.request!user) = ldb(pg.charge!user) and
     ldb(pg.request!user2) = ldb(pg.charge!user2) then
     StatCount(SameUsername)
  else StatCount(DifUsername);

  if ldb(pg.request!aun) = ldb(pg.charge!aun) then StatCount(SameGan)
  else StatCount(DifGan);

 END;  "CompileStatistics"

All!Release;

print ("Done!");

print (Crlf,"Scanned ",GdfCnt - 1," records.");
print (Crlf2,"Statistics for System ",SysNo," ",PrintTime,":");
print (Crlf2,"      OPTION                 IN HOUSE  CUSTOMER  COMBINED");
print (Crlf,"      ======                 ========  ========  ========",Crlf);

getformat(LastWidth,LastDigits);
setformat(10,0);

for line_1 step 1 until Option!Count do
  print(Crlf,Options[line],InHouse[line],Customer[line],
    InHouse[line] + Customer[line]);

print(Crlf2,
  "NUMBER OF RECORDS        ",InHouseCnt,CustomerCnt,InHouseCnt + CustomerCnt,
    Crlf);

setformat(LastWidth,LastDigits);		! back to the old values;

END;
endc
ifc MainVer thenc

procedure Charge!Spool;
DSCR Asks for a request number.  If everything looks ok, builds and
     writes an accounting record.  Handle with care!!
;
BEGIN boolean DidOne;

GdfPtr_FdfPtr_n!r;

while true do
  BEGIN "ChargeLoop"
    arrclr(GdfBuf); arrclr(FdfBuf);
    arrclr(AccBuf,cvasc("     "));
    arrclr(CopyAcc,cvasc("     "));
    if Find!Gdf and Make!Charge(true)
      then BEGIN
	     print(Crlf, "Charged!");
	     if ldb(pg.status) < tape.done then DidOne_true;
	     Set!GdfToDone;
	   END;
    if not Confirm("Do another?") then done "ChargeLoop";
  END "ChargeLoop";

All!Release;
if DidOne
  then BEGIN
	 print(Crlf,"Updating SPLCNT and REMCNT.  Wait...");
	 FixCounts;
       END;
END;
endc
simple procedure Do!Help;
BEGIN "Help"
ifc MainVer thenc
print("
CHARGE		Use this command to clear the charges on a request
		that is stuck in 'PROC' status.  Be sure that it
		actually has been completed!

CLEAN		Use this to DELETE unwanted files on the (SPOOL)
		directory.  

COMPARE         Use this command to compare the number of pages and
                characters in SPOOL records and accounting records.
                Accounting records will be corrected, and report
                written in (SPOOL)SPLCOM.FIL.

HELP		Repeat this message.

PENDING		Finds old requests in GDF (Pending status and over
		10 days old, or tape or process status and over 3
		days old).


");
if not Confirm("There is more.  Continue?") then return;
print("

PRINT		Prints out charges contained in the monthly batch
		file.  Primarily useful for debugging SPOOL/BATCH.

QUIT		Graceful exit from the program.  If you exit some
		other way, you will not get the log file properly
		updated.  In this case, see the file (SPOOL)SPOOL.LOG.

REPAIR		Use this to rebuild SPOOL's data base.  

STATISTICS      This prints out statistics from the GDF file for use
                in debugging or analyzing SPOOL.

UNPROCESSED     Totals page and character counts for unprocessed
                accounting records older than purge date for customer
                requests.  Any amounts represent lost revenue due to 
                operators not charging off requests.");
elsec
print("
CLEAN		Use this to DELETE unwanted files on the (SPOOL)
		directory.  

HELP		Repeat this message.

QUIT		Graceful exit from the program.  If you exit some
		other way, you will not get the appropriate files
		properly updated.

REPAIR		Use this to rebuild SPOOL's data base.");
endc
Confirm("Type any character to continue");
END "Help";
! ******************   T O P  O F  P R O G R A M *******************;



DSCR Handle the following macros with care.

     Com!List is a list of pairs, in the form <command name>,<action>.
     The <action> must be suitable for inclusion as an entry in a case
     statement.  The result will be semicolon & [n] <action> for the
     appropriate n.  If <action> is not a simple SAIL statement, enclose
     it in BEGIN/END.

     Com!Str is used to preload the string array containing the command
     names, and Com!Case becomes the body of a case statement.  

     WARNINGS:  (1) Command names must be typed in UPPER case and appear
	            in alphabetical order.
		(2) No command can be a proper substring of another
		    (though they can have a common initial substring).
;

ifc MainVer thenc
DEFINE Com!List = <(> & <
CHARGE (REQUEST),Charge!Spool,
CLEAN (DIRECTORY),SpoolClean,
COMPARE (PAGES),Compare!Pages,
HELP,Do!Help,
PENDING (REQUESTS),Print!Pending,
PRINT (CHARGES),Acct!Print,
QUIT,Bye!Bye,
REPAIR (DATABASE),FixRequests,
STATISTICS (PRINT),Statistics,
UNPROCESSED (CHARGES),Unprocessed 
		  > & <)>;
elsec
DEFINE Com!List = <(> & <
CLEAN (DIRECTORY),SpoolClean,
HELP,Do!Help,
QUIT,Bye!Bye,
REPAIR (DATABASE),FixRequests
		  > & <)>;
endc
! NO "," allowed after the last entry in the above list ;

DEFINE Com!Str  = <>,
       Com!Case = <>,
       Com!Cnt  = 0;

FORLC xxx = Com!List
  DOC <
	REDEFINE Com!Cnt = Com!Cnt+1;
	IFC Com!Cnt MOD 2 = 1 THENC
	  REDEFINE Com!Str = CVMS( Com!Str ) & <, "> & <xxx> & <">;
	ELSEC
	  REDEFINE The!Com!Cnt = Com!Cnt DIV 2;
	  REDEFINE Com!Case = CVMS( Com!Case ) & <; [> & 
			      	CVS( The!Com!Cnt ) & <] > & <xxx>;
	ENDC
  > ENDC

IFC Com!Cnt MOD 2 = 0 THENC REDEFINE Com!Cnt = Com!Cnt DIV 2;
  ELSEC REQUIRE CrLf & "Command list error!! FIX IT!!" MESSAGE;
ENDC

REQUIRE CrLf & "Found " & CVS( Com!Cnt ) & " commands." & CrLf MESSAGE;

! We don't want the leading chars on Com!Str and Com!Case, so lop them;

REDEFINE Com!Str = CVMS( Com!Str )[2 TO INF];
REDEFINE Com!Case = CVMS( Com!Case )[2 TO INF];

PRELOAD!WITH Com!Str;
STRING ARRAY Commands[ 1 : Com!Cnt ];

var_-1;
ttyup(true);		! Force input from terminal to be upper case;

DidClean_FALSE;
require LicenseCheck initialization;

setprint(NewLogFile,"B");		! Make a log file;

! Print a herald giving the program name, system number, and time;

PRINT(Crlf, "SPOOL Data Base ",
      ifc not MainVer thenc "Operations ", endc
         "Maintenance Tool, v. ", VerNum,
      ifc Debug thenc " [DEBUGGING VERSION]", endc Crlf,
      "System ", SysNo, " (", SysCity, ")    ", PrintTime, Crlf);

if rpgsw then AlternateSys;	! Different system number needed;

while true do
  BEGIN "GetOption" integer OurCmd;
      if (OurCmd_GetCmd("Option (? for help) *",Commands)) > 0
	then case OurCmd of BEGIN Com!Case END;
  END "GetOption";


require " end of program" message;
END "SpFix"
    require " reading too far!!" message; .
    c{x