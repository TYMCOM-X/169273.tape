	TITLE 	SSDISK:  DISK PERFORMANCE (INCLUDING ERRORS)
	IF1 <PRINTX SSDISK>
	MAINSW==0

;  EXTERNAL SUBROUTINES

	EXTERN	CRLF	;PRINTS CRLF SEQUENCE (SSIO)
	EXTERN	D%DECN,D%MSG,D%MSGD,D%MSGN,D%MSGO	;DISK ERROR REPORTING (SSDSPL)
	EXTERN	D%UNCK	;DISK ERROR REPORTING (SSDSPL)
	EXTERN	GETUDB	;(SSDSPL)
	EXTERN	MSG	;MESSAGE PRINTING (SSIO)
	EXTERN	PRTBIT,BITTL	;(SSDSPL)
	EXTERN	RDX10	;PRINT DECIMAL - FREE FORM (SSIO)
	EXTERN	SIXBP	;PRINT SIXBIT MESSAGE (SSIO)
	EXTERN	SPACE	;PRINT SPACE (SSIO)
	EXTERN	TAB	;PRINT A TAB (SSIO)
	EXTERN	TYO	;PRINT A CHARACTER ON TERMINAL (SSIO)

;  EXTERNAL LOCATIONS

	EXTERN	CURFS			;(SSLOW)
	EXTERN	DBLOCK,DSKBLK,PRCCNT	;(SSLOW)
	EXTERN	PSP1,PSP2,PSP3,PSPSW	;(SSLOW)
	EXTERN	SCNTIM,STWONM,TMPDSK	;(SSLOW)
	EXTERN	UNIBLK			;(SSLOW)
	EXTERN	UDTAB,UDTBL		;(SSDSPL)

;  GLOBAL SUBROUTINES

	INTERN	DP,DP7,FLUN4D,PSPCK

;CALL AS:	PUSHJ	P,DP
DP:	MOVEI M,[ASCIZ .
.]
	PUSHJ P,MSG
	SETZM	DBLOCK+1
	PUSHJ	P,REDUDB	;SEE IF UUO WILL FAIL.
	JRST	DP7		;YES - DON'T PRINT HEADINGS.
	SKIPN	DEVIOS+DBLOCK	;DOES USER HAVE LICENSE?
	JRST	DP7
	TLO	F,FL.LP1	;SET FLAG FOR FIRST TRY.
	JRST	[MOVEI M,[ASCIZ .Disk devices:
Unit or file-structure
	Free	   BUFFERED	     DUMP	   MONITOR	Seeks
	Blocks	Reads	Writes	Reads	Writes	Reads	Writes
.]
	PUSHJ P,MSG
	JRST	.+1]

DP7:	SETZM	CURFS		;ENTER HERE FOR PSP COMMAND
IFN FTSTR,<	SETZM	STWONM		;INC WHEN UNIT W/O STR FOUND
	SETZM	SCNTIM		;2ND TIMEW AROUND FLAG>

FLFSL:IFN FTSTR,<	SKIPE	SCNTIM		;SKIP IF NOT ON 2ND TIME
	JRST	FILEXI		;EXIT LOOP>
	MOVE A,CURFS
	SYSSTR	A,
	  JFCL
IFN FTSTR,<	JUMPE A,[SKIPN STWONM	;SKIP IF UNIT W/O STR FOUND
		JRST	FILEXI	;NO-QUIT
		SETOM SCNTIM	;NO WE ARE ON THAT LOOP
		MOVEI M,[ASCIZ /
Units not in any file structure:
/]
		SKIPN PSPSW ; SKIP IF PSP COMMAND
		PUSHJ P,MSG
		SETZM CURFS
		JRST FLUNL]	;CONTINUE LOOP
>;ASSEMBLE ABOVE IF STRUCTURE NOT IN STR LIST GIVEN


IFE FTSTR,<	JUMPE	A,FILEXI	;ALL DONE OR NONE>
	MOVEM A,CURFS
	PUSHJ P,SIXBP		;TYPE STRUCTURE NAME
	MOVEI	CH,":"
	PUSHJ	P,TYO		;TYPE :
	PUSHJ P,TAB
	MOVE A,CURFS
	MOVEM A,DSKBLK
	MOVE A,[XWD DSKBKL,DSKBLK]	;SET FOR DISK CHARACTERISTICS UUO
	DSKCHR	A,		;FOR THE STRUCTURE FIRST
	  JRST FILEXI	;SHOULDNT FAIL
	MOVE N,DSKBLK+.STTAL	;GET BLOCKS LEFT
	PUSHJ P,RDX10		;ON STR
	PUSHJ P,CRLF		;END OF STRUCTURE

;UNIT STUFF HERE
;LOOP TO READ IN STRUCTURE NAMES
	TLZE	F,FL.LP1	;NEED TO READ UDB?
	JRST	FLUNL1		;NO - ALREADY DID.
	SETZM	DBLOCK+1	;0 = JUST STARTED WORK

; MAIN LOOP TO READ UNITS
FLUNL:
FLOOP:	PUSHJ	P,REDUDB	;READ THE UDB.
	JRST	FLFSL		;NOPE.
	JRST	FLUNL1		;OK - CONTINUE.

REDUDB:	MOVEI	A,2
	MOVEM	A,DBLOCK	;FUNCTION NO. 2
	MOVE	A,[DBLOCK+2,,DBLOCK+3]
	SETZM	DBLOCK+2	;ZERO OUT DISK DATA BLOCK B4 USE
	BLT	A,DBLOCK+LN.UDB-1	;AS SO
	MOVE	A,[LN.UDB,,DBLOCK]
	SYSDVF	A,		;ASK MONITOR NICELY....
	  JRST	REDUD2		;OOPS
	HRRZ	A,DBLOCK+3+UNICHR
	MOVEM	A,BPCUNI#	;BLOCKS PER CYLINDER
	LDB	A,[POINT 9,DBLOCK+3+UNICHR,17]
	MOVEM	A,BPTUNI#	;BLOCKS PER TRACK
	LDB	A,[POINT 8,DBLOCK+3+UNICHR,8]
	JUMPN	A,REDUD1	;NON-ZERO, JOE PUT IT IN
	MOVEI	A,1		;DEFAULT IS BLOCKS
	SKIPGE	DBLOCK+3+UNICHR	;SIGN BIT SAYS IN PAGES
	  MOVEI	A,4		;FORMATTED IN PAGES
REDUD1:	MOVEM	A,BPRUNI#	;BLOCKS PER RECORD
	AOS	(P)
REDUD2:	POPJ	P,


; CHECK DEVIOS FOR BEING = 0, IN WHICH CASE USER HAS
; INSUFFICIENT LICENSE TO GRAB THE DATA BLOCK
FLUNL1:	SKIPN	DEVIOS+DBLOCK	;IS DEVIOS = 0 ?
	  JRST	FLFSL		;YES, GET NEXT UNIT-THIS BAD
	SKIPN	DBLOCK+1	;DID WE GET ANYTHING
	  JRST	FLFSL		;NO.. BYE BYE BYE

;READ IN DSK CHRS
	MOVE	A,DBLOCK+1	;GET STR NAME
	MOVEM	A,DSKBLK	;DEV NAME
	MOVE	A,[DSKBKL,,DSKBLK]
	DSKCHR	A,
	  SETZM	DSKBLK+.STNAM	;NO ST NAME HERE
	MOVEM	A,DSKBLK		;SAVE STATES WORD
	MOVEI	D,DBLOCK+3	;SET UP INDEXED POINTER

;CHECK TO SEE IF THIS IS THE STRUCTURE WE NEED
FLUNL2:	SKIPN	A,DSKBLK+.STNAM	;(A)=STRNAM, SKIP IF NOT NULL
	  SETOM	STWONM		;SET STR W/O NAME FOUND SW
	CAME	A,CURFS		;SAME AS CURRENT FILE STR?
	  JRST	FLOOP

FLUN3:	TLZ	F,FL.DEV	;RESET PSP HEADING SWITCH
	MOVEM	D,UNIBLK	;SAVE UNIT DATA BLOCK ADDR
	MOVE	A,DSKBLK+.UNPHY	;PHYSICAL NAME
	MOVEM	A,PSP1		;SAVE NAME FOR PSP COMMAND
	MOVE	A,DSKBLK+.UNLOG	;LOGICAL NAME
	MOVEM	A,PSP3		;SAVE FOR PACK ID PRINTOUT
	MOVE	A,UNIHID(D)	;GET PACK ID
	MOVEM	A,PSP2		;SAVE PACK ID
	SKIPE	PSPSW		;SKIP=NO PSP COMMAND
	  JRST	FLUN4		;PSP--SKIP PACK ID UNLESS ER
	PUSHJ	P,IDPNT		;TYPE OUT I.D.
	PUSHJ	P,CRLF		;AND A CARRIAGE-RETURN
	MOVE	N,DSKBLK+.UNTAL	;TOTAL BLOCKS LEFT ON THIS PACK
	PUSHJ	P,TAB
	PUSHJ	P,RDX10

	MOVSI	C,-UDTBL
FLUNL3:	HRRZ	A,UDTAB(C)
	PUSHJ	P,GETUDB
	HLRE	A,UDTAB(C)
	JUMPE	A,FLUNLA
	JUMPL	A,FLDIFF
	ADD	A,UNIBLK
	MOVE	A,(A)
	ADD	N,A
	JRST	FLUNLA

FLDIFF:	MOVNS	A
	ADD	A,UNIBLK
	MOVE	A,(A)
	SUB	N,A
FLUNLA:	PUSHJ	P,TAB
	PUSHJ	P,RDX10
	AOBJN	C,FLUNL3


FLUN2:	PUSHJ P,CRLF
	TLZ F,FL.NBK+FL.DEV
	HLLZ A,DSKBLK
	TLZ A,BITMSK
	JUMPE A,FLUN4
	PUSHJ P,SPACE
	TLO F,FL.NBK
	MOVSI C,-BITTL
FLBTL:	SKIPGE A
	PUSHJ P,PRTBIT
	LSH A,1
	AOBJN C,FLBTL


COMMENT !
WAY DISK ERROR INFORMATION WORKS
1. 'PRCCNT' CONTAINS THE NUMBER OF TABLES LEFT ON THE STACK
   WHENEVER TABLES (SEE #2 BELOW) REACH END, PRCCNT IS DECREMENTED.
   IF IT GOES FROM 1 TO 0, DISK ERROR REPRTING IS DONE.
   WHEN A TABLE SPECIFIES TO 'GOSUB' TO ANOTHER TABLE, PRCCNT
	IS INCREMENTED AND SOMETHING ELSE PUT ON THE STACK.
2. STACK IS SET UP AS FOLLOWS:
   0(P)=LENGTH OF TABLES, -1(P)=ADR OF XCT TO SET UP N,
   -2(P)=ADR OF XCT TO MASSAGE N, -3(P)=ADR OF XCT TO SET UP M
   -4(P)=ADR OF XCT TO CALL OUTPUT SUBROUTINE.
   WHILE GOING THROUGH THE TABLES, IF LH(-3(P)) IS 0, THIS IS
   NOT A GOSUB BUT AN ERRLIST CALL.  IF LH(-3(P)) IS # 0,
   A GOSUB IS SPECIFIED.  PRCCNT IS INCREMENTED, AND THE FOLLOWING
   INFORMATION IS PUT ON THE STACK:
   -1(P) - ADR OF INST TABLE TO GOSUB TO
   -2(P) - ADR OF MASSAGE TABLE TO GOSUB TO
   -3(P) - LH - LENGTH OF TABLE TO GOSUB TO
           RH - ADR OF MESSAGE TABLE TO GOSUB TO
   -4(P) - ADR OF ROUTINE TABLE TO GOSUB TO
!
FLUN4:	PUSH	P,[DSK13]	;SET UP INITIAL STACK PTRS
	PUSH	P,[DSK12]
	PUSH	P,[DSK11]
	PUSH	P,[DSK10]
	PUSH	P,[DSK1L]
	MOVEI	C,1
	MOVEM	C,PRCCNT	;INITIAL STACK COUNTER

FLUN4A:	SOSGE	C,0(P)		;ANYTHING LEFT THIS TABLE?
	JRST	FLUN4B		;NO, CHECK FOR NEXT TABLE
	HRRZ	A,-3(P)		;GET MSG ADR
	ADD	A,C
	HLRZ	A,@A		;LH OF MSG TABLE, GOSUB ADR?
	JUMPN	A,FLUN4C	;IF LH OF MSG ADR#0, GOSUB TBL
	MOVEI	D,DBLOCK+3	;D HAS BASE ADR OF UDB
	HRRZ	A,-1(P)		;ADR OF INST TO LOAD UP N
	ADD	A,C
	XCT	@A
	HRRZ	A,-2(P)		;ADR OF INST TO MASSAGE N
	ADD	A,C
	XCT	@A
	HRRZ	A,-3(P)		;ADR OF DATA TO PUT IN M
	ADD	A,C
	MOVE	M,@A
	HRRZ	A,-4(P)		;ADR OF INST TO PUT OUT N
	ADD	A,C
	XCT	@A
	JRST	FLUN4A		;LOOP...

; HERE WHEN AN GOSUB TABLE WANTS TO BEGIN
FLUN4C:	HRRZ	A,-4(P)
	ADD	A,C
	PUSH	P,@A
	HRRZ	B,-4(P)
	ADD	B,C
	HRRZ	A,@B
	PUSH	P,A
	HRRZ	A,-4(P)
	ADD	A,C
	PUSH	P,@A
	HRRZ	A,-4(P)
	ADD	A,C
	PUSH	P,@A
	HLRZ	A,@B
	PUSH	P,A
	AOS	PRCCNT
	JRST	FLUN4A

; HERE WHEN AN GOSUB TABLE WANTS TO END, BUMB DOWN
; PDL BY 1 (FOR THE PUSHJ TO ROUTINE) AND REMOVE GOSUB
; TABLE FROM PDL
FLUN4D:	POP	P,C		;REMOVE PUSHJ

; HERE WHEN A TABLE IS FINISHED (IN FLUN4A)
; BUMP DOWN PDL BY 5 TO REMOVE CURRENT TABLE AND CHECK PRCCNT
; FOR POSSIBLE MORE TABLES
FLUN4B:	SUB	P,[5,,5]	;REMOVE ELEMENTS FROM STACK
	SOSLE	PRCCNT		;MORE TABLES???
	JRST	FLUN4A		;YES, RETURN FROM GOSUB TABLE
; HERE WHEN DONE WITH DISK ERROR STUFF
	TLNE F,FL.NBK+FL.DEV
	PUSHJ P,CRLF
	JRST	FLUNL		;CONTINUE SCAN


;TYPE OUT PACK I.D. WITH PSP1 AND PSP2 SET
IDPNT:	MOVE	A,PSP1		;PACK NAME
	PUSHJ	P,SIXBP
	MOVEI	CH,"("
	PUSHJ	P,TYO
	MOVE	A,PSP3		;GET LOGICAL NAME
	JUMPE	A,.+4		;IF NULL DONT PRINT IT
	PUSHJ	P,SIXBP		;TYPE IT OUT
	MOVEI	CH,":"		;SEPARATOR
	PUSHJ	P,TYO		;TYPE IT
	MOVE	A,PSP2		;PACK NAME IN 6BIT
	PUSHJ	P,SIXBP
	MOVEI	M,[ASCIZ /):/]
	PUSHJ	P,MSG
	POPJ	P,		;RETURN

;HERE TO SEE IF PSP COMMAND. IF SO, TYPE OUT THE
;PACK ID AND SPACE, SET HAD SWITCH, AND RETURN
PSPCK:	SKIPN	PSPSW		;IN PSP COMMAND?
	POPJ	P,		;NO-RETURN
	TLOE	F,FL.DEV	;RESET SWITCH FOR HEADING
	POPJ	P,		;NO-RETURN
	PUSH	P,A		;SAVE A
	PUSH	P,M		;SAVE M
	PUSH	P,C		;SAVE C
	PUSHJ	P,IDPNT		;TYPE OUT I.D.
	PUSHJ	P,SPACE		;TYPE OUT A SPACE
	POP	P,C		;GET C BACK
	POP	P,M		;GET M BACK
	POP	P,A		;GET A BACK
	POPJ	P,

;HERE TO EXIT DISK PERFORMANCE
FILEXI:	POPJ	P,		;RETURN

	SUBTTL	DISK ERROR INFO TABLES

COMMENT !
MACRO 'ERRLIST' IS PUT TOGETHER AS FOLLOWS:

	ERRLIST	GET.VALUE, SET.VALUE, MSG.TITLE, PROCESS

WHERE:
	AUTOMATICALLY,
	  AC 'D' HAS ADDRESS OF BASE OF UDB WE ARE LOOKING AT
GET.VALUE = INSTRUCTION WHICH WILL BE XCT'ED - THE RESULT OF WHICH
	SHOULD SET UP AC 'N' TO HAVE THE NEXT DSK ERROR NO.
SET.VALUE = INSTRUCTION WHICH WILL BE XCT'ED - FOR MODIFYING AC
	'N' WITH SUCH AS ANDI, LDB, ETC.
MSG.TITLE = ASCII TEXT WHICH WILL BE MADE AS LITERL, THE ADDRESS
	OF WHICH IS LOADED INTO AC 'M'
PROCESS = A ROUTINE CALL OR SOMETHING WHICH PROCESSES POSSIBLE
	INFORMATION SET UP IN AC 'N' AND 'M' BY THIS ERRLIST.

ERROR TABLE 'DSK1' IS THE INITIAL TABLE SET UP BY THE DISK
ERROR REPORTING CODE.  IT CAN GOSUB TO OTHER TABLES.

MACRO 'ERRUNIT' IS PUT TOGETHER AS 'ERRUNIT <UNIT-NO>'
OCCURING ANYWHERE IN A DSK.TAB.BITS TABLE, IF THE CURRENT
UNIT BEING LOOKED AT IS NOT A TYPE 'UNIT-NO' UNIT, THE
CURRENT TABLE WILL BE TERMINATED. (BY JRST FLUN4B)

MACRO 'ERRMSG' IS PUT TOGETHER AS 'ERRMSG <MESSAGE>'
AND SIMPLY PUTS OUT THE INDICATED MESSAGE ALWAYS.
(USING D%MSG)

MACRO 'ERRGOSUB' IS PUT TOGETHER AS FOLLOWS:

	ERRGOSUB TABLE

WHERE:
TABLE = NAME OF A TABLE SET UP BY DSK.ERR.TABLE
THIS TABLE WILL BE 'GOSUBED' TO.  WHEN IT NATURALLY END,
OR WHEN A JRST TO FLUN4B IS DONE, A RETURN TO THE TABLE
THAT CALLED THE GOSUB TABLE WILL OCCUR.

REMEMBER... ALL TABLES ARE SCANNED IN REVERSE (BOTTOM-TO-TOP) ORDER.
!

; MACRO TO EXPAND A TABLE WITH ERRLIST/ERRCALL MACRO'S
; CALL IS:
;	DSK.GEN.TAB(TABLE NAME-UP TO 5 CHARS)
; USES MACRO 'DSK.TAB.BITS' TO HAVE CALLS
; GENERATES TABLES WITH FOLLOWING ADDRESSES:
; TABLENAME'0 - XCT TABLE TO LOAD N
; TABLENAME'1 - XCT TABLE TO MASSAGE N
; TABLENAME'2 - ADDRESS TABLE TO MESSAGE FOR 'M'
; TABLENAME'3 - SUBROUTINE TO CALL BY XCT
; TABLENAME'L - LENGTH OF TABLES, FOR SEARCHES

DEFINE DSK.GEN.TAB(TBNAME)<OFF.LIST
	DEFINE ERRLIST(A1,A2,A3,A4)<A1>
	DEFINE ERRGOSUB(A1)<A1'0>
	DEFINE ERRMSG(A1)<JFCL>
	DEFINE ERRUNIT(A1)<LDB N,[POINT 6,UNIDES(D),26]>
	TBNAME'0: DSK.TAB.BITS
	TBNAME'L==.-TBNAME'0
	DEFINE ERRLIST(A1,A2,A3,A4)<A2>
	DEFINE ERRGOSUB(A1)<A1'1>
	DEFINE ERRMSG(A1)<JFCL>
	DEFINE ERRUNIT(A1)<MOVEI N1,'A1>
	TBNAME'1: DSK.TAB.BITS
	DEFINE ERRLIST(A1,A2,A3,A4)<[ASCIZ /A3/]>
	DEFINE ERRGOSUB(A1)<XWD A1'L,A1'2>
	DEFINE ERRMSG(A1)<[ASCIZ /A1/]>
	DEFINE ERRUNIT(A1)<0>
	TBNAME'2: DSK.TAB.BITS
	DEFINE ERRLIST(A1,A2,A3,A4)<A4>
	DEFINE ERRGOSUB(A1)<A1'3>
	DEFINE ERRMSG(A1)<PUSHJ P,D%MSG>
	DEFINE ERRUNIT(A1)<PUSHJ P,D%UNCK>
	TBNAME'3: DSK.TAB.BITS
ON.LIST>

DEFINE DSK.TAB.BITS <
	ERRLIST	<HLRZ N,UNIHCT(D)>,<JFCL>,< HDEV:>,<PUSHJ P,D%DECN>
	ERRLIST	<HRRZ N,UNIHCT(D)>,<JFCL>,< HDAT:>,<PUSHJ P,D%DECN>
	ERRGOSUB <%4HLB>
	ERRGOSUB <%2HLB>
	ERRGOSUB <%1HLB>
	ERRGOSUB <%4HCI>
	ERRGOSUB <%2HCI>
	ERRGOSUB <%1HCI>
	ERRGOSUB <%4HDI>
	ERRGOSUB <%2HDI>
	ERRGOSUB <%1HDI>
	ERRLIST <HLRZ N,UNISCT(D)>,<JFCL>,< SDEV:>,<PUSHJ P,D%DECN>
	ERRLIST	<HRRZ N,UNISCT(D)>,<JFCL>,< SDAT:>,<PUSHJ P,D%DECN>
	ERRGOSUB <%4SLB>
	ERRGOSUB <%2SLB>
	ERRGOSUB <%1SLB>
	ERRGOSUB <%4SCI>
	ERRGOSUB <%2SCI>
	ERRGOSUB <%1SCI>
	ERRGOSUB <%4SDI>
	ERRGOSUB <%2SDI>
	ERRGOSUB <%1SDI>
	ERRLIST	<MOVE N,UNIECT(D)>,<JFCL>,< RETRIES:>,<PUSHJ P,D%DECN>
	ERRLIST	<LDB N,[POINT 12,UNIMCT(D),11]>,<JFCL>,< SATFAIL:>,<PUSHJ P,D%DECN>
	ERRLIST	<LDB N,[POINT 12,UNIMCT(D),23]>,<JFCL>,< RIBERR:>,<PUSHJ P,D%DECN>
	ERRLIST	<LDB N,[POINT 12,UNIMCT(D),35]>,<JFCL>,< CKSERR:>,<PUSHJ P,D%DECN>
	ERRLIST	<HLRZ N,UNIHNG(D)>,<JFCL>,< THUNG:>,<PUSHJ P,D%DECN>
	ERRLIST	<HRRZ N,UNIHNG(D)>,<JFCL>,< HUNG:>,<PUSHJ P,D%DECN>
ON.LIST>

	DSK.GEN.TAB(DSK1)


; TABLE %4SLB - FOR UNIT 4 SLBN STUFF
DEFINE DSK.TAB.BITS <
	ERRMSG <)>
	ERRLIST	<AOS N,TMPDSK>,<IDIV N,BPRUNI>,< RECORD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,TMPDSK>,<PUSHJ P,[IDIV N,BPTUNI
		MOVEM N1,TMPDSK
		POPJ P,]>,< HEAD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<PUSHJ P,[IDIV N,BPCUNI
		MOVEM N1,TMPDSK
		POPJ P,]>,<CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<JUMPE N,FLUN4B>,< SLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT	<4>
>

	DSK.GEN.TAB(%4SLB)

; TABLE %4HLB - FOR UNIT 4 HLBN STUFF
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<AOS N,TMPDSK>,<IDIV N,BPRUNI>,< RECORD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,TMPDSK>,<PUSHJ P,[IDIV N,BPTUNI
		MOVEM N1,TMPDSK
		POPJ P,]>,< HEAD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<PUSHJ P,[IDIV N,BPCUNI
		MOVEM N1,TMPDSK
		POPJ P,]>,<CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<JUMPE N,FLUN4B>,< HLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT <4>
>

	DSK.GEN.TAB(%4HLB)


; TABLE %4SDI - UNIT TYPE 4 SDATAI
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST <MOVE N,UNISDI(D)>,<PUSHJ P,[CAMN N,[-1]
		JRST [MOVEI M,[ASCIZ / NO SENSE DATA/]
			PJRST D%MSG]
		LDB N1,[POINT 4,N,27]
		CAMLE N1,6	;CHECK IF FORMAT IS WITHIN BOUNDS.
		PUSHJ 	P,[LDB N,[POINT 4,N,31]
			MOVEI M,[ASCIZ /CONDITION HAS NO MESSAGE/]
			POPJ P,]
		CAMG N1,6
		PUSHJ	P,[MOVE N1,%4FMT(N1) ; N1=FORMAT,NOW N1=ADR OF FMT TBL
			LDB N,[POINT 4,N,31]	;N = MSG #
			ADD N1,N ; N1 = ADR OF ADR OF MSG
			MOVE M,(N1)
			POPJ P,]
		PUSHJ P,D%MSG
		POPJ P,]>,<>,JFCL
	ERRLIST	<LDB N,[POINT 6,UNISDI(D),7]>,<PUSHJ P,%DRV3330>,<>,<PUSHJ P,TYO>
	ERRMSG	< DRV:>
	ERRLIST	<LDB N,[POINT 2,UNISDI(D),1]>,<JFCL>,<CTRL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISDI(D)>,<JUMPE N,FLUN4B>,< SDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<4>
>

	DSK.GEN.TAB(%4SDI)

; TABLE %4HDI - UNIT TYPE 4 HDATAI
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,UNIHDI(D)>,<PUSHJ P,[CAMN N,[-1]
		JRST [MOVEI M,[ASCIZ / NO SENSE DATA/]
		PJRST D%MSG]
		LDB N1,[POINT 4,N,27]
		MOVE N1,%4FMT(N1)	;** N1=FORMATNNOW N1=ADR FMT TBL
		LDB N,[POINT 4,N,31]	;** N = MSG #
		ADD N1,N	;** N1 = FMT TBL BASE + MSG NO.
		MOVE M,(N1)	;** M = MESSAGE TO TYPE
		PUSHJ P,D%MSG	;** TYPE MESSAGE
		POPJ P,]>,<>,JFCL
	ERRLIST	<LDB N,[POINT 6,UNIHDI(D),7]>,<PUSHJ P,%DRV3330>,<>,<PUSHJ P,TYO>
	ERRMSG	< DRV:>
	ERRLIST <LDB N,[POINT 2,UNIHDI(D),1]>,<JFCL>,<CTRL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHDI(D)>,<JUMPE N,FLUN4B>,< HDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<4>
>
	DSK.GEN.TAB(%4HDI)


; TABLE %4SCI - FOR UNIT 4 SCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNISOF(D),'BIT]>	;N=A BIT FOOM UNISOF
	ERRMSG	<)>
	ERRLIST	<XX(9)>,<JFCL>,< Write protect>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(10)>,<JFCL>,< Select error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(11)>,<JFCL>,< Control error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(12)>,<JFCL>,< Length error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(13)>,<JFCL>,< Equipment check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< Permanent equipment check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Unit exception>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Attention flag>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(17)>,<JFCL>,< Busy>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Count error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< Unrecoverable data check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Recoverable data check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Invalid track format>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< Memory parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(24)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(25)>,<JFCL>,< Data overrun>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(26)>,<JFCL>,< SA10 sense bytes garbage>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< Protection failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Bus in parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(29)>,<JFCL>,< Bus out parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(30)>,<JFCL>,< Command reject>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNISOF(D)>,<JUMPE N,FLUN4B>,< SCONI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<4>
>
	DSK.GEN.TAB(%4SCI)


; TABLE %4HCI - FOR UNIT 4 HCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNIERR(D),'BIT]>	;N=A BIT FOOM UNIERR
	ERRMSG	<)>
	ERRLIST	<XX(9)>,<JFCL>,< Write protect>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(10)>,<JFCL>,< Select error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(11)>,<JFCL>,< Control error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(12)>,<JFCL>,< Length error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(13)>,<JFCL>,< Equipment check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< Permanent equipment check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Unit exception>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Attention flag>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(17)>,<JFCL>,< Busy>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Count error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< Unrecoverable data check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Recoverable data check>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Invalid track format>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< Memory parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(24)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(25)>,<JFCL>,< Data overrun>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(26)>,<JFCL>,< SA10 sense bytes garbage>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< Protection failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Bus in parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(29)>,<JFCL>,< Bus out parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(30)>,<JFCL>,< Command reject>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNIERR(D)>,<JUMPE N,FLUN4B>,< HCONI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<4>
>
	DSK.GEN.TAB(%4HCI)


; TABLE %2SCI - FOR UNIT 2 SCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNISOF(D),'BIT]>	;N=A BIT FROM UNISOF
	ERRMSG	<)>
	ERRLIST	<XX(29)>,<JFCL>,< Surface address error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Sector address error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< Illegal DATAO>,<PUSHJ P,D%MSGN>
	ERRLIST <XX(26)>,<JFCL>,< Write on read-only pack>,<PUSHJ P,D%MSGN>
	ERRLIST <XX(25)>,<JFCL>,< Not ready>,<PUSHJ P,D%MSGN>
	ET	<XX(24)>,<JFCL>,< Parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Data late>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Power failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< End of cylinder>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Channel terminate word incorrect>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(17)>,<JFCL>,< Disk word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Channel data parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Sector parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< Control word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNISOF(D)>,<JUMPE N,FLUN4B>,< SCONI(>,<PUSHJ P,D%MSGN>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2SCI)

; TABLE %2HCI - FOR UNIT 2 HCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNIERR(D),'BIT]>	;N=A BIT FROM UNIERR
	ERRMSG	<)>
	ERRLIST	<XX(29)>,<JFCL>,< Surface address error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Sector address error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< Illegal DATAO>,<PUSHJ P,D%MSGN>
	ERRLIST <XX(26)>,<JFCL>,< Write on read-only pack>,<PUSHJ P,D%MSGN>
	ERRLIST <XX(25)>,<JFCL>,< Not ready>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(24)>,<JFCL>,< Parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Data late>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Power failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< End of cylinder>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Channel terminate word incorrect>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(17)>,<JFCL>,< Disk word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Channel data parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Sector parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< Control word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNIERR(D)>,<JUMPE N,FLUN4B>,< HCONI(>,<PUSHJ P,D%MSGN>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2HCI)


; TABLE %2SDI - FOR UNIT 2 SDATAI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNISDI(D),'BIT]>
	ERRMSG	<)>
	ERRLIST	<LDB N,[POINT 8,N,34]>,<JFCL>,< ATTN:>,<PUSHJ P,D%DECN>
	ERRLIST	<XX(26)>,<JFCL>,< Bad spot>,<PUSHJ P,D%MSGN>
	ERRLIST	<LDB N,[POINT 5,UNISDI(D),22]>,<JFCL>,< Sector cntr:>,<PUSHJ P,D%DECN>
	ERRLIST	<XX(17)>,<JFCL>,< Write header lockout>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Proection failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Illegal drive>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< File unsafe>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(13)>,<JFCL>,< On-line>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(12)>,<JFCL>,< Heads in position>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(11)>,<JFCL>,< Position failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<JFCL>,<PUSHJ P,[PUSH P,UNISDI(D)	;** CYL #
	LDB N,[POINT 8,(P),10]	;** GET CYL NO.
	MOVEI N1,1B23
	TDNE N1,(P)	;** NEED HIGH-ORDER CYL BIT?
	TRO N,400	;** YES, ADD IT IN
	POP P,N1
	POPJ P,]>,< CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<LDB N,[POINT 3,UNISDI(D),2]>,<JFCL>,<DRV:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISDI(D)>,<JUMPE N,FLUN4B>,< SDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2SDI)

; TABLE %2HDI - FOR UNIT 2 HDATAI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNIHDI(D),'BIT]>
	ERRMSG	<)>
	ERRLIST	<LDB N,[POINT 8,N,34]>,<JFCL>,< ATTN:>,<PUSHJ P,D%DECN>
	ERRLIST	<XX(26)>,<JFCL>,< Bad spot>,<PUSHJ P,D%MSGN>
	ERRLIST	<LDB N,[POINT 5,UNIHDI(D),22]>,<JFCL>,< Sector cntr:>,<PUSHJ P,D%DECN>
	ERRLIST	<XX(17)>,<JFCL>,< Write header lockout>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(16)>,<JFCL>,< Proection failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(15)>,<JFCL>,< Illegal drive>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(14)>,<JFCL>,< File unsafe>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(13)>,<JFCL>,< On-line>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(12)>,<JFCL>,< Heads in position>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(11)>,<JFCL>,< Position failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<JFCL>,<PUSHJ P,[PUSH P,UNIHDI(D)	;** CYL #
	LDB N,[POINT 8,(P),10]	;** GET CYL NO.
	MOVEI N1,1B23
	TDNE N1,(P)	;** NEED HIGH-ORDER CYL BIT?
	TRO N,400	;** YES, ADD IT IN
	POP P,N1
	POPJ P,]>,< CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<LDB N,[POINT 3,UNIHDI(D),2]>,<JFCL>,<DRV:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHDI(D)>,<JUMPE N,FLUN4B>,< HDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2HDI)


; TABLE %2SLB - FOR UNIT 2 SLBN
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,TMPDSK>,<JFCL>,< SECTOR:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,TMPDSK>,<PUSHJ P,[IDIVI N,^D10
		MOVEM N1,TMPDSK
		POPJ P,]>,< HEAD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<PUSHJ P,[IDIVI N,^D200
	MOVEM N1,TMPDSK
	POPJ P,]>,<CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<JUMPE N,FLUN4B>,< SLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2SLB)

; TABLE %2HLB - FOR UNIT 2 HLBN
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,TMPDSK>,<JFCL>,< SECTOR:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,TMPDSK>,<PUSHJ P,[IDIVI N,^D10
		MOVEM N1,TMPDSK
		POPJ P,]>,< HEAD:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<PUSHJ P,[IDIVI N,^D200
	MOVEM N1,TMPDSK
	POPJ P,]>,<CYL:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<JUMPE N,FLUN4B>,< HLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT	<2>
>
	DSK.GEN.TAB(%2HLB)


; TABLE %1SCI - FOR UNIT 1 SCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNISOF,'BIT]>
	ERRMSG	<)>
	ERRLIST	<XX(29)>,<JFCL>,< Data late>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Write on protected track>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(26)>,<JFCL>,< Control word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(25)>,<JFCL>,< Data parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(24)>,<JFCL>,< Device parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< Power failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Not ready>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Track error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Unit error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Channel terminate word incorrect>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNISOF(D)>,<JUMPE N,FLUN4B>,< SCONI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1SCI)

; TABLE %1HCI - FOR UNIT 1 HCONI
DEFINE DSK.TAB.BITS <
	DEFINE XX(BIT)<LDB N,[POINT 1,UNIERR,'BIT]>
	ERRMSG	<)>
	ERRLIST	<XX(29)>,<JFCL>,< Data late>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(28)>,<JFCL>,< Write on protected track>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(27)>,<JFCL>,< No such memory>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(26)>,<JFCL>,< Control word parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(25)>,<JFCL>,< Data parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(24)>,<JFCL>,< Device parity error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(23)>,<JFCL>,< Power failure>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(22)>,<JFCL>,< Not ready>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(21)>,<JFCL>,< Track error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(20)>,<JFCL>,< Unit error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(19)>,<JFCL>,< Search error>,<PUSHJ P,D%MSGN>
	ERRLIST	<XX(18)>,<JFCL>,< Channel terminate word incorrect>,<PUSHJ P,D%MSGN>
	ERRLIST	<MOVE N,UNIERR(D)>,<JUMPE N,FLUN4B>,< HCONI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1HCI)


; TABLE %1SDI - FOR UNIT 1 SDATAI
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,UNISDI(D)>,<PUSHJ P,[PUSH P,N	;** SEC ADR
		LDB N,[POINT 4,(P),31]
		MOVEI M,[ASCIZ / SECTOR:/]
		PUSHJ P,D%MSG
		SKIPE N
		PUSHJ P,RDX10
		POP P,N
		ANDI N,17
		PUSHJ P,RDX10
		POPJ P,]>,<>,<JFCL>
	ERRLIST	<LDB N,[POINT 2,UNISDI(D),27]>,<JFCL>,< UNIT:>,<PUSHJ P,D%MSGO>
	ERRLIST	<LDB N,[POINT 6,UNISDI(D),23]>,<JFCL>,<PARREG:>,<PUSHJ P,D%MSGO>
	ERRLIST	<MOVE N,UNISDI(D)>,<JUMPE N,FLUN4B>,< SDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1SDI)

; TABLE %1HDI - FOR UNIT 1 HDATAI
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,UNIHDI(D)>,<PUSHJ P,[PUSH P,N	;** SEC ADR
		LDB N,[POINT 4,(P),31]
		MOVEI M,[ASCIZ / SECTOR:/]
		PUSHJ P,D%MSG
		SKIPE N
		PUSHJ P,RDX10
		POP P,N
		ANDI N,17
		PUSHJ P,RDX10
		POPJ P,]>,<>,<JFCL>
	ERRLIST	<LDB N,[POINT 2,UNIHDI(D),27]>,<JFCL>,< UNIT:>,<PUSHJ P,D%MSGO>
	ERRLIST	<LDB N,[POINT 6,UNIHDI(D),23]>,<JFCL>,<PARREG:>,<PUSHJ P,D%MSGO>
	ERRLIST	<MOVE N,UNIHDI(D)>,<JUMPE N,FLUN4B>,< HDATAI(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1HDI)


; TABLE %1SLB - UNIT 1 SLBN
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,TMPDSK>,<LSH N,1>,< SECTOR:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<PUSHJ P,[IDIVI N,^D40
		MOVEM N1,TMPDSK
		POPJ P,]>,<TRACK:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNISBN(D)>,<JUMPE N,FLUN4B>,< SLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1SLB)

; TABLE %1HLB - UNIT 1 HLBN
DEFINE DSK.TAB.BITS <
	ERRMSG	<)>
	ERRLIST	<MOVE N,TMPDSK>,<LSH N,1>,< SECTOR:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<PUSHJ P,[IDIVI N,^D40
		MOVEM N1,TMPDSK
		POPJ P,]>,<TRACK:>,<PUSHJ P,D%MSGD>
	ERRLIST	<MOVE N,UNIHBN(D)>,<JUMPE N,FLUN4B>,< HLBN(>,<PUSHJ P,D%MSG>
	ERRUNIT	<1>
>
	DSK.GEN.TAB(%1HLB)

	SUBTTL	DISK ERROR INFO -- ROUTINE FOR DISK ERROR TABLES

; %DRV3330 - N = BITS 2 THRU 7 OF SENSE BYTE 4
; RETURNS, IN 'CH', THE DRIVE DESIGNATION OF THIS DRIVE
%DRV3330: MOVEI	CH,"?"		;PRIME DRIVE WITH ?
	CAIN	N,16		;16 = DRIVE G
	MOVEI	CH,"G"
	CAIN	N,34		;34 = DRIVE E
	MOVEI	CH,"E"
	CAIN	N,52		;52 = DRIVE C
	MOVEI	CH,"C"
	CAIN	N,70		;70 = DRIVE A
	MOVEI	CH,"A"
	CAIN	N,07		;07 = DRIVE H
	MOVEI	CH,"H"
	CAIN	N,25		;25 = DRIVE F
	MOVEI	CH,"F"
	CAIN	N,43		;43 = DRIVE D
	MOVEI	CH,"D"
	CAIN	N,61		;61 = DRIVE B
	MOVEI	CH,"B"
	POPJ	P,		;ALL DONE....


; TABLES FOR 'FORMAT MSGTBL' ON TYPE 4 SDATA/HDATA
%4FMT:	EXP	%4FMT0,%4FMT1,%4FMT2,%4FMT3,%4FMT4,%4FMT5,%4FMT6

; THIS MACRO PILES UP MESSAGES FOR THOSE UNUSED SLOTS AFTER TABLES END
DEFINE %4MESS(CNT)<REPEAT CNT,<[ASCIZ / CONDITION HAS NO MESSAGE!/]>>
; FORMAT 0
%4FMT0:	[ASCIZ / No message/]
	[ASCIZ / Invalid command/]
	[ASCIZ / Invalid sequence/]
	[ASCIZ / CCW count less than required/]
	[ASCIZ / Data value not as required/]
	[ASCIZ / Diagnostic write not permitted by file mask/]
	[ASCIZ / Channel discontinued retry operation/]
	[ASCIZ / Channel returned with incorrect retry CCW/]
	[ASCIZ / 23FD not ready/]
	[ASCIZ / 23FD hard seek check/]
	[ASCIZ / 23FD hard read check/]
	[ASCIZ / Improper alternate-defective track pointer/]
	[ASCIZ / SERDES malfunction - no ST 4's/]
	[ASCIZ / Diagnostic write control code mismatch/]
	[ASCIZ / Control storage busy with microdiagnostic/]
	[ASCIZ / Retry byte count-sector value incorrect/]
	%4MESS(1)

; FORMAT 1
%4FMT1:	[ASCIZ / No message/]
	[ASCIZ / Set target error/]
	[ASCIZ / No write gate at drive/]
	[ASCIZ / No write current sense/]
	[ASCIZ / Transmit cylinder error/]
	[ASCIZ / Transmit head error/]
	[ASCIZ / Transmit difference error/]
	[ASCIZ / File status not as expected/]
	[ASCIZ / Seek error/]
	[ASCIZ / Seek incomplete on retry/]
	[ASCIZ / No interrupt from drive/]
	%4MESS(6)

; FORMAT 2:
%4FMT2:	[ASCIZ / No message/]
	[ASCIZ / ECC P1 or P3 compare failure/]
	[ASCIZ / ECC P2 compare failure/]
	%4MESS(15)

; FORMAT 3 AND FORMAT 6:
%4FMT3:%4FMT6: [ASCIZ / No message/]
	%4MESS(17)

; FORMAT 4
%4FMT4:	[ASCIZ / HA field ECC uncorrectable/]
	[ASCIZ / Count field ECC uncorrectable/]
	[ASCIZ / Key field ECC uncorectable/]
	[ASCIZ / Data field ECC uncorrectable/]
	[ASCIZ / HA field no sync byte found/]
	[ASCIZ / Count field no sync byte found/]
	[ASCIZ / Key field no sync byte found/]
	[ASCIZ / Data field no sync byte found/]
	[ASCIZ / AM detection failure on retry/]
	%4MESS(7)

; FORMAT 5
%4FMT5:	[ASCIZ / HA field correctable/]
	[ASCIZ / Count field correctable/]
	[ASCIZ / Key field correctable/]
	[ASCIZ / Data field correctable/]
	%4MESS(16)

;  CONSTANTS

BITMSK==77

        END
  V!;_Ù