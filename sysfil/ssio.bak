	TITLE	SSIO  :  ASSORTED SUBROUTINES
	IF1 <PRINTX SSIO>
MAINSW==0		;INDICATES NOT THE MAIN PROGRAM


;  EXTERNAL SUBROUTINES

	EXTERN	BOMB.	;HERE ON FATAL ERROR (SYSTAT)
	EXTERN	NOCOR	;CORE UUO FAILURE EXIT (SYSTAT)
	EXTERN	PSYSNO	;PRINTS SYSTEM IDENTIFICATION (SYSCOM)

;  EXTERNAL LOCATIONS

	EXTERN	BOTH	;JOBN+SEGN (SSLOW)
	EXTERN	BUF	;BUFFER FOR READING THE DUL (SSLOW)
	EXTERN	CORMAX	;SIZE OF USER CORE (SSLOW)
	EXTERN	CURPOS	;CURRENT POSITION ON TTY (SSLOW)
	EXTERN	DATE	;TODAY'S DATE (SSLOW)
	EXTERN	DISPLA	;DISPLAY INDICATOR (SSLOW)
	EXTERN	DSKFRE  ;SWAPPING SPACE AVAILABLE (SSLOW
	EXTERN	DSKUSE	;SWAPPING SPACE USED (SSLOW)
	EXTERN	DULOPN	;ONES IF DUL OPEN ON DUL CHANNEDL (SSLOW)
	EXTERN	FLGPOS	;POSITION OF END OF NEXT FIELD (SSLOW)
	EXTERN	FREE	;TEMPORARY JOBFF (SSLOW)
	EXTERN	FSFPPN	;OPERATOR NUMBER (SSLOW)
	EXTERN	JOBFF	;ADDRESS OF 1ST FREE LOC. AFTER LOW SEG. (JOBDAT)
	EXTERN	JOBN	;NUMBER OF JOBS IN SYSTEM (SSLOW)
	EXTERN	JOBREL	;HIGHEST REL. LOC. AVAILABLE TO USER (JOBDAT)
	EXTERN	LASJBF	;SAVE JOBFF ON GA: (SSLOW)
	EXTERN	LASPPN	;PPN OF USER (SSLOW)
	EXTERN	LASPRI	;LUD WORD 3 (SSLOW)
	EXTERN	LASPRV	;LUD WORD 2 (SSLOW)
	EXTERN	LASPTR	;TYO LAST-SPACE-SEEN-SAVED PTR1
	EXTERN	LINCTR	;TYO LINE COUNTER
	EXTERN	LINLOL	;MAX. LOL FOR OUTPUT LINE (SSLOW)
	EXTERN	LQTAB	;LENGTH OF QTAB (SSLOW)
	EXTERN	LUDOPN	;ONES IF LUD OPEN ON LUD CHANNEL (SSLOW)
	EXTERN	MEMNSP	;CORE SPEED (SSLOW)
	EXTERN	MESPC	;USERNAME PRINTING SWITCH (SSLOW)
	EXTERN	NOW	;CURRENT TIME (SSLOW)
	EXTERN	OPR	;NAME OF "OPR" DEVICE (SSLOW)
	EXTERN	PDL	;PUSH-DOWN LIST (SSLOW)
	EXTERN	PTR1	;TYO SCANNER POINTER (SSLOW)
	EXTERN	PTR2	;TYO OUTPUT-LAST-FROM-HERE POINTER (SSLOW)
	EXTERN	QTAB	;(SSLOW)
	EXTERN	SAVCHR	;CHARACTER TO RESCAN (SSLOW)
	EXTERN	SAVPTR	;PCHV OF PTR1 (SSLOW)
	EXTERN	SEGFLG	;-1 IF SEGMENT PRINTING (SSLOW)
	EXTERN	SEGN	;NUMBER OF SEGMENTS IN SYSTEM (SSLOW)
	EXTERN	SEGPTR	;LH=-# OF JOBS, RH=# OF JOBS (SSLOW)
	EXTERN	STATES	;SYSTEM STATES WORD (SSLOW)
	EXTERN	SYSPPN	;PPN OF "SYS" (SSLOW)
	EXTERN	SYSTAP	;NAME OF SYSTEM TAPE (SSLOW)
	EXTERN	TCKSEC	;JIFFIES PER SECOND (SSLOW)
	EXTERN	TEMP	;(SSLOW)
	EXTERN	TISL	;WAIT STATE CODES FOR TI AND SL (SSLOW)
	EXTERN	TYOB	;LIST DEVICE OUTPUT BUFFER POINTERS (SSLOW)
	EXTERN	TYOBUF	;TYO OUTPUT BUFFER (SSLOW)
	EXTERN	TYOFLG	;-1 IF TYO SET UP, ELSE 0 (SSLOW)
	EXTERN	TYOOFL	;TYO OUTPUT OVERFLOW INDICATOR (SSLOW)
	EXTERN	TYOPTR	;BUFFER POINTER FOR TYO (SSLOW)
	EXTERN	UFDLCS	;FOR UFD LOCATOR ON DUL SEARCH (SSLOW)
	EXTERN	ZERHGH	;LAST ADDRESS OF DYNAMIC TABLES (SSLOW)
	EXTERN	ZERLOW	;FIRST ADDRESS OF DYNAMIC TABLES (SSLOW)
	EXTERN	%NODBUFF,NODIOWD ;Buffer for reading (TYMNET)NODES.MAP in SSLOW


;  THE FOLLOWING ARE ALL IN SSLOW

	EXTERN	.CHIO,.CON,.DEV,.DSIO,.DVIOS,.FRM,.PPN
	EXTERN	.PRG,.PRV,.SEGCT,.SGN,.STS,.SWP,.TIM
	EXTERN	.TTY,.TTYN,.TYM,.USRN1,.USRN2
	EXTERN	SVFIELD,%DAY,%MONTH,%YEAR,RESULT,%KEY

;  GLOBAL SUBROUTINES

	INTERN	CLRFLG,CPOPJ,CPOPJ1,CRLF,CMPCNT,DECMSG
	INTERN	DECP2X,DECTAB,DULOUT,FIELD,GA,GETCHR
	INTERN	GETRDC,GETRDX,HIGH06,HIGH6A,HIPSWP,INACTC
	INTERN	LOPSWP,LUDCHK,MSG,MSGDEC,MSGOCT,NOWHO,OCTLRH
	INTERN	PNTPPN,PRNTRU,RDX10,RDX10F,RDX8,RDXN,SEGSCN
	INTERN	SEGSZ,SIXBP,SIXDEC,SPACE,TAB,THISIS,TIME
	INTERN	TCKTIS,TYO,TYOCLR


;  MACRO DEFINITIONS

DEFINE	BOMB(A),<JRST	[JSP	M,BOMB.
			ASCIZ	\A\]>

OPDEF	PJRST [JRST]

	SUBTTL	SUBROUTINES - CPOPJ AND CPOPJ1 - NUMERIC I/O

CPOPJ1:	AOS	(P)		;SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN

; RDX8 - OCTAL OUTPUT, FREE FORM
; CALL WITH N= NUMBER
RDX8:	MOVEI	R,^D8		;OCTAL RADIX
	PJRST	RDXN		;PRINT NO

; RDX10 - DECIMAL OUTPUT, FREE FORM
; CALL WITH N= NUMBER
RDX10:	MOVEI	R,^D10		;DECIMAL RADIX
	PJRST	RDXN		;PRINT NO

; RDXN - SPECIFIC RADIX OUTPUT, FREE FORM
; CALL WITH N= NUMBER  R= RADIX
RDXN:	MOVEI	CH,"-"		;PREPARE TO SIGN NUMBER
	JUMPGE	N,RDXN1		;ALREADY POSITIVE
	PUSHJ	P,TYO		;OUTPUT NO.
	MOVMS	N		;AND MAKE POSITIVE
RDXN1:	JUMPN	N,RDXN2		;SOMETHING THERE - PRINT
	TLNN	F,FL.SZR!FL.BZR	;SEE IF BLANKING OR SUPRESSING
	JRST	RDXN2		;NO--PRINT ONE ZERO
	MOVEI	CH," "		;PREPARE TO BLANK
	TLNN	F,FL.SZR	;SUPRESSING?
	PUSHJ	P,TYO		;NO, OUTPUT SPACE
	POPJ	P,		;RETURN****
RDXN2:	TLZ	F,FL.SZR!FL.BZR	;RESET ZRO SUP FLGS
RDXN3:	IDIVI	N,(R)		;GET NEXT DIGIT
	HRLM	N1,0(P)		;THIS IS THE DEC STANDARD NO. OUTPUTTER
	SKIPE	N		;ANYTHING LEFT?
	PUSHJ	P,RDXN3		;YES, GET ANOTHER
	HLRZ	CH,0(P)		;GET NUMBER
	ADDI	CH,"0"		;CONVERT TO ASCII
	PJRST	TYO		;OUTPUT NUMBER, FINALY RETURNING***

; RDX8F - OCTAL OUTPUT, FIXED FIELD
; CALL WITH N=NUMBER  CH=BIGGEST VALUE
RDX8F:	MOVEI	R,^D8		;OCTAL OUTPUT
	PJRST	RDXNF		;OUTPUT NO

; RDX10F - DECIMAL OUTPUT, FIXED FIELD
; CALL WITH N=NUMBER  CH=BIGGEST VALUE
RDX10F:	MOVEI	R,^D10		;DECIMAL OUTPUT
	PJRST	RDXNF		;OUTPUT NO.

; RDXNF - SPECIFIC RADIX OUTPUT, FIXED FIELD
; CALL WITH N=NUMBER  CH=BIGGEST VALUE  R=RADIX
RDXNF:	IDIVI	CH,(R)		;REPOSITION MASK
	SKIPE	CH		;SEE IF OUT OF PREFIXS
	CAMLE	N,CH		;SEE IF DONES
	JRST	RDXN		;DONE, OUTPUT NUMBER
	PUSH	P,CH		;PRESERVE MASK
	PUSHJ	P,SPACE		;OUTPUT SPACE
	POP	P,CH		;GET BACK CH
	JRST	RDXNF		;AND LOOP...
	SUBTTL	SUBROUTINES -- VARIOUS I-O SUBROUTINES

NOWHO:
	MOVE	CH,@.STS
	TLNE	CH,JLOG		;IF NOT LOGGED IN **,**
	POPJ	P,		;RETURN IF OK
NOWHO1:	SETO	A,		;HIDE IT--CHANGE NAME
	POPJ	P,

ASTSIX:	MOVE	A,[SIXBIT /**,**/]
SP4SIX:	TDNE	A,[-1-77B5]	;SEE IF SHORT NAME
	SKIPE	SEGFLG		;NO--SEE IF SEGMENT MODE
	JRST	TABSIX		;YES--DO TAB THEN PRINT
	MOVEI	N,4		;SPACE 4, THEN SIXBIT
	PUSHJ	P,SPACE
	SOJG	N,.-1
SIXBP:	MOVE	BP,A
SIXBP1:	MOVEI	CH,0
	LSHC	CH,6
	IFN CH-BP+1,<PRINTX BP MUST BE CH+1>
	ADDI	CH,40
	PUSHJ	P,TYO
	JUMPN	BP,SIXBP1
	POPJ	P,0

TABSIX:	PUSHJ	P,TAB		;SEND TAB
	JRST	SIXBP		;THEN SIXBIT MESSAGE
CRLF2:	PUSHJ	P,CRLF
CRLF:	MOVEI	M,[ASCIZ /
/]
MSG:	TLOA	M,440700
MSG1:	PUSHJ	P,TYO
	ILDB	CH,M
	JUMPN	CH,MSG1
	POPJ	P,

PERIOD:	MOVEI	CH,"."
	JRST	TYO

COLON:	TLNE	F,FL.SZR	;DON'T PRINT IF SUPPRESSINGZEROES
	POPJ	P,
	MOVEI	CH,":"
	TLNE	F,FL.BZR	;PRINT BLANK IF BLANKING ZEROES
	MOVEI	CH," "
	JRST	TYO

COMMA:	MOVEI	CH,","
	JRST	TYO

SIXTAB:	PUSHJ	P,SIXBP
TAB:	MOVEI	CH,11
	PJRST	TYO
SPACE:	MOVEI	CH,40
	PJRST	TYO

; STYO - OUTPUT CHAR TO TTY
; IF DISPLAY, AND CR, OUTPUT EREOL FIRST TO CLEAR LINE
; FOR /DPY AND /CONTINUOUS TO WORK
STYO:	TLNE	F,FL.HUSH	;IS THE HUSH BIT SET ??
	POPJ	P,		;YES, DONT OUTPUT ANYTHING
	CAIN	CH,15		;C.R.?
	SKIPN	DISPLA		;IS THIS A DISPLAY?
	JRST	.+2		;NO..
	JRST	[PUSH P,CH	;YES--SAVE CHARACTER
		MOVEI CH,EREOL	;AND PUT OUT ERASE END OF LINE
		PUSHJ P,STYO	;BY CALLING THIS ROUTINE AGAIN
		POP P,CH	;...
		JRST .+1]	;ALL DONE !
	SKIPN	TYOB		;SEE IF TTY SETUP YET
	JRST	TYOTTY		;NO--DO VIA TTCALL
	SOSG	TYOB+2
	OUTPUT	TTY,0
	IDPB	CH,TYOB+1
	POPJ	P,0
TYOTTY:	OUTCHR	CH		;TYPE THE CHARACTER
	POPJ	P,		;RETURN

; TYO - OUTPUT A CHARACTER TO THE TERMINAL
; CH = CHARACTER TO OUTPUT
; OUTPUTS THE CHARACTER GIVEN ON THE TERMINAL.
; THIS ROUTINE DOES BUFFERING AND SPLITTING OF LINES ACCORDING
; TO SPACES FOUND AND LOL OF TTY LINE.
; IF TTY IS NOT OUTPUT DEVICE, LOL IS SET TO 132
; STYO OUTPUTS A CHARACTER IN BUFFERED TTY MODE
; (WHICH THIS DOES AS LINES ARE SPLIT)
TYO:	TLNE	F,FL.HUSH	;NOT SUPPOSED TO OUTPUT ?
	POPJ	P,		;NO OUTPUT, RETURN***
	SKIPE	TYOFLG		;ARE WE SET UP?
	JRST	TYO1		;YES, DONT INIT
	CAIE	CH,15		;CR OR
	CAIN	CH,12		;LF AND NOT INITIALIZED
	PJRST	STYO		;YES,LOOP...
	EXCH	M,TYOPTR	;M<=>TYOPTR
	MOVE	M,[POINT 7,TYOBUF] ;M(JUNK)=PTR TO INITIAL LINE
	EXCH	M,TYOPTR	;M<=>TYOPTR(OLD M)
	SETOM	TYOFLG		;SET SETUP FLAG
TYO1:	CAIN	CH,15		;CARRIAGE RETURN?
	JRST	TYO2		;YES, MUST DO LINE FOLDING TRIP
	IDPB	CH,TYOPTR	;NO CR, STORE CHAR IN BUF
	AOS	CURPOS		;INCREMENT CURRENT POSITION
	SKIPE	TYOOFL		;IF NOSKIP, TYOBUF OVERFLOW
	BOMB	(<TTY I-O buffer (TYOBUF) overflow - SYSTAT line too long>)
	POPJ	P,		;RETURN****

; HERE WHEN CR SEEN, MUST FOLD OUTPUT LINE
TYO2:	PUSH	P,M		;SAVE M FOR TEMP STORAGE
	SETZ	CH,
	IDPB	CH,TYOPTR	;STORE E.O.LIT ON END OF BUF
	SETZM	LINCTR		;RESET WHERE-ON-LINE COUNT
	SETZM	LASPTR		;RESET LAST POINTER SEEN
	MOVE	CH,[POINT 7,TYOBUF]	;POINTER TO BEG OF BUFFER
	MOVEM	CH,PTR1		;RESET FIRST POINTER (SCANNER)
	MOVEM	CH,PTR2		;RESET SECOND POINTER (OUTPUTTER)
	JRST	TYO3A

TYO3:	MOVE	M,PTR1		;GET CURRENT POINTER
	LDB	CH,PTR1		;GET CHAR AT THIS POS
	CAIN	CH," "		;SPACE??
	MOVEM	M,LASPTR	;YES SAVE LAST SPACE SCANNER
TYO3A:	MOVE	M,PTR1
	MOVEM	M,SAVPTR	;ALWAYS SAVE IN SAVPTR
	ILDB	CH,PTR1		;GET NEXT CHAR SCANNED
	JUMPE	CH,TYO5		;E.O.LIT, OUTPUT REST OF LINE
	AOS	M,LINCTR	;INC CURRENT POS ON LINE
	CAMGE	M,LINLOL	;ACROSS LENGTH-OF-LINE?
	JRST	TYO3		;NO, LOOP

; DROP IN HERE TO OUTPUT UP TO LAST SPACE SCANNED, THEN
; GO BACK AND LOOP AGAIN
TYO4:	MOVE	M,SAVPTR	;GET SAVPTR READY
	SKIPN	LASPTR		;LASPTR HAVE ANYTHING?
	MOVEM	M,LASPTR	;NO, GO TO WHERE WE ARE NOW
TYO4A:	ILDB	CH,PTR2
	MOVE	M,PTR2		;SEE IF
	CAMN	M,LASPTR	;ARE WE AT WHERE WE ARE GOING?
	JRST	TYO4B		;YES, THIS LINE FINISHED
	PUSHJ	P,STYO		;REALLY OUTPUT CHARACTER
	JRST	TYO4A		;AND LOOP
TYO4B:	MOVEI	CH,15
	PUSHJ	P,STYO		;OUTPUT CR/LF
	MOVEI	CH,12
	PUSHJ	P,STYO
	MOVEI	CH," "
	PUSHJ	P,STYO
	MOVEI	CH,1
	MOVEM	CH,LINCTR	;RESET LINE COUNTER
	IBP	LASPTR		;INC LAST PLACE SEEN
	MOVE	M,LASPTR
	MOVEM	M,PTR1		;AND RESET PTR1, PTR2=SPACE
	JRST	TYO3		;AND REALLY LOOP

; HERE WHEN E.O.LIT SEEN, DUMP TO END OF LINE
; RESET SETUP FLAG AND RETURN
TYO5:	ILDB	CH,PTR2		;GET NEXT CHAR
	JUMPE	CH,TYO5A	;END, UN-INIT
	PUSHJ	P,STYO		;OUTPUT CHAR
	JRST	TYO5		;LOOP DOING THIS
TYO5A:	MOVEI	CH,15
	PUSHJ	P,STYO		;OUTPUT CR,LF WILL BE FOLLOWING
	SETZM	TYOFLG		;RESET SETUP FLAG
	POP	P,M		;RESTORE M
	POPJ	P,		;RETURN****

; TYOCLR - IF TYO INITED, CAUSES BUFFER TO BE DUMPED
TYOCLR:	SKIPN	TYOFLG		;INITED?
	POPJ	P,		;NO,RETURN****
	SETZ	CH,
	IDPB	CH,TYOPTR	;TERMINATE BUFFER
	MOVE	CH,[POINT 7,TYOBUF]	;PTR TO BUFFER
	MOVEM	CH,TYOPTR
TYOCL1:	ILDB	CH,TYOPTR	;GET NEXT CHAR
	JUMPE	CH,CPOPJ	;IF NULL, DONE, RETURN***
	PUSHJ	P,STYO		;NOT, DUMP CHAR
	JRST	TYOCL1		;LOOP...
	SUBTTL	SUBROUTINES -- FIELD CONTROL SUBROUTINES

;CLRFLD WILL CLEAR THE FIELD INDICATOR, MAKING THE NEXT CALL
;TO FIELD DO NO LINE JUSTIFICATION
CLRFLG:	SETZM	FLGPOS		;FIELD POSITION OF ZERO IS
	MOVEI	CH,1
	MOVEM	CH,CURPOS	;CURRENT POSITION ON TTY
	POPJ	P,

;FIELD
; INPUT: CH = CURRENT WIDTH OF NEW FIELD
; FLGPOS -> CURRENT POSITION WE ARE SUPPOSED TO BE AT
;  IF FLGPOS = 0 -> INITIAL CALL SET FLGPOS
;  IF FLGPOS > 0 -> FIELD UNDERFLOW, EXPAND WITH SPACES
; CURPOS -> CURRENT POSITION WE ARE REALLY AT (AOS CURPOS
;		IS IN TYO)
FIELD:	TLNN	WD,SIGN		;HUSH UP BIT?
	CAMN	WD,HEDFLG	;OR THIS?
	POPJ	P,		;YES-RETURN
	TLNE	F,FL.HUSH	;IS THE HUSH BIT SET ?
	POPJ	P,		;YES, IGNORE THIS..
	SKIPE	FLGPOS		;FIRST FIELD CALL ?
	JRST	FIELD1		;NO
	MOVEM	CH,FLGPOS	;YES--SET FLAG FOR NEXT POSITION
	POPJ	P,		;RETURN

; FIELD1 - HERE WHEN FLGPOS # 0 , SEE HOW MUCH TO EXPAND
;  SUBTRACT CURPOS FROM FLGPOS; IF + THEN SPACE OUT
;  IF NEG. THEN WAIT IN HOLE.
FIELD1:	MOVEM	CH,SVFIELD	;SAVE FIELD SPEC FOR LATER
	MOVE	CH,FLGPOS	;GET POS WE ARE SUPPOSED TO B @
	SUB	CH,CURPOS	;SUBTRACT CURRENT POSITION.
	JUMPE	CH,FIELD2	;0 - THERE, 1 OVERFLOW
	JUMPL	CH,FIELD3	; < 0 OVERFLOW.
; CURPOS IS < FLGPOS SO WE MUST SPACE OUT CH SPACES
FIELD4:	PUSH	P,A		;SAVE A REG.
	MOVE	A,CH		;GET SPACE COUNT.
	PUSHJ	P,SPACE		;SPACE OUT
	SOJG	A,.-1		;LOOP UNTIL COUNT EXAUSTED
	POP	P,A		;RESTORE A REG.
	MOVE	CH,SVFIELD	;GET LAST FIELD SPEC
	ADD	CH,CURPOS	;ADD CURRENT POS->NEW TOP POS
	MOVEM	CH,FLGPOS	;SAVE NEW TOP POSITION
	POPJ	P,		;RETURN

;FIELD2 - HERE WHEN EXACTLY AT POSITION
; THIS MEANS WE MUST OVERFLOW BY 1 SO SUBTRACT 1 FROM CH
FIELD2:	SOS	SVFIELD		;NEW FIELD IS 1 SHORTER
	JRST	FIELD4		;AND SPACE OUT.

;FIELD3 - HAVE OVERFLOWN -CH SPACES SO MUST ADDM CH,SVFIELD
FIELD3:	ADDM	CH,SVFIELD	;SUB FROM NEW FIELD WIDTH
	JRST	FIELD2		;OUTPUT 1 SPACE
	SUBTTL	SUBROUTINES -- LUD READING SUBROUTINE

;SUBROUTINE TO TAKE A USER NAME (AS POINTED TO IN D,J)
;AND SKIP RETURN IF IT IS IN THE LUD, OR NOSKIP RETURN
;IF ITS NOT IN THE LUD
;
; CELL :LASPPN: CONTAINS THE PPN OF THE USER.
; CELL :LASPRV: CONTAINS WORD 2 OF THE USER FROM LUD
; CELL :LASPRI: CONTAINS WORD 3 OF THE USER FROM LUD
;
;****HERE IT IS: MIKE GEARY !! ****
;
LUDCHK:	SKIPN	LUDOPN		;IS THE LUD OPEN
	JRST	CPOPJ		;SORRY ABOUT THAT MIKE
	PUSH	P,J
	PUSH	P,D		;SAVE IT ALL UP
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,F1
	PUSH	P,WD		;SAVE ALL UP
	MOVEI	F1,0
	MOVE	A,[555555555555]
	MOVE	B,[361275431652]
	MOVE	C,[612754316523]
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	XOR	B,C
	XOR	A,B
	TLZ	B,400000
	IDIVI	B,^D887
	MOVE	B,A

;HERE TO READ IN A BLOCK FROM THE LUD.
;CH = THE BLOCK TO READ FROM THE LUD.
SRUS:	PUSHJ	P,RDBLK		;READ A LUD BLOCK
	MOVEI	A,0		;START AT BUF+0

; HERE TO CHECK CURRENT LUD ENTRY FOR THIS USER
; A = POINTER TO CURRENT ENTRY IN LUD BUFFER
SRUSR:	CAME	B,BUF+4(A)	;LOCATOR MATCH LUD ENTRY?
	JRST	NUSER		;NO, LOOP ON.
	MOVE	WD,BUF(A)	;GET THIS LUSER'S PPN
	MOVEM	WD,LASPPN	;SAVE PPN
	MOVE	WD,BUF+2(A)	;GET WORD 2 - LOGIN BITS
	MOVEM	WD,LASPRV	;SAVE THEM
	MOVE	WD,BUF+3(A)	;GET WORD 3 - PRIVILEGE BITS.
	MOVEM	WD,LASPRI	;AND SAVE.
	POP	P,WD
	POP	P,F1
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POP	P,D
	POP	P,J
	JRST	CPOPJ1		;FOUND IT !!

;HERE WHEN DID NOT FIND USER.  RETURNS NOT SKIPPING.
LKLUDE:	POP	P,WD
	POP	P,F1
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POP	P,D
	POP	P,J
	POPJ	P,

;HERE WHEN THE CURRENT ENTRY POINTED TO IN LUD IS NOT
;THE USER WE ARE LOOKING FOR.
;CHECK TO SEE IF THERE IS ANOTHER ENTRY IN THIS BLOCK,
;OR IF WE NEED TO GO TO AN OVERFLOW BLOCK.
;LINK WORD IS:
;	> 0 =	# TO ADD TO CURRENT PTR TO GET
;		TO THE EXT USER LOCATOR IN THIS LUD BLOCK
;	<= 0 =	NEXT BLOCK (#0) OR END OF THIS HASH CHAIN (=0)
NUSER:	SKIPG	CH,BUF+0(A)	;IS NEXT POINTER A BLOCK CHAIN?
	JRST	BLKLNK		;YES, GO TO NEXT LUD BLOCK
	MOVE	CH,BUF+2(A)	;NOT LINK TO BLOCK, LINK TO NX ENTRY
	ANDI	CH,177		;ONLY FIRT 8 BITS VALID
	ADD	A,CH		;ADVANCE BUFFER POINTER (A)
	JRST	SRUSR		;SEARCH FOR USER IN THIS ENTRY.

;HERE WHEN A LINK TO THE NEXT ENTRY IS <= 0
;	0 =	END OF CHAIN. USER NOT FOUND
;	<0 =	BLOCK NUMBER TO READ TO GET NEXT ENTRY
BLKLNK:	JUMPE	CH,LKLUDE	;0 LINK IS END OF CHAIN...
	MOVE	C,CH		;NOT END, C=NX BLOCK TO READ IN CHAIN
	JRST	SRUS		;GO TO READ NEXT BLOCK

; RANDOM NUMBER HASH ROUTINE
; USED TO GENERATE HASH LUD LOCATOR FROM USER NAME.
RND:	ADD	B,D
	ROTC	D,-22
	MOVEI	WD,5
RND1:	MOVE	CH,B(F1)
	MUL	CH,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM	BP,C(F1)
	AOJE	F1,RND2
	MOVNI	F1,1
	TRNE	B,1
	SKIPL	C
	MOVEI	F1,0
	EXCH	A,C
RND2:	SOJG	WD,RND1
	POPJ	P,

;READ IN A BLOCK
RDBLK:	USETI	LUD,1(C)	;SET INPUT TO READ BLK(C)+1
	INPUT	LUD,COM		;INPUT THE BLOCK
	STATO	LUD,760000	;ANY ERRORS DURING READ ?
	POPJ	P,		;NO, RETURN GIVING BLOCK.
	MOVSI	A,-200		;BUFFER WORD COUNT TO ZERO.
	SETZM	BUF(A)		;ZERO THE BUFFER......
	AOBJN	A,.-1		;REPEAT UNTIL 0 BUFFER.
	MOVEI	A,0		;THUS, WILL LOOK LIKE END OF CHAIN.
	POPJ	P,		;RETURN GIVING LAST CHAIN BLOCK
	SUBTTL	SUBROUTINES -- DUL READING SUBROUTINE

;SUBROUTINE TO TAKE A GAN-UNO AND RETURN USER NAME
;ARGS:	A=GAN,,UNO OF USER NAME TO BE PRINTED
;WILL PRINT PPN IN FIELD IF CANNOT FIND DUL ENTRY, ELSE
;WILL PRINT USER NAME IN FIELD.
DULOUT:	SKIPN	DULOPN		;IS THE DUL OPEN?
	PJRST	PNTPPN		;NO--TYPE PPN
	CAMN	A,[-1]		;IS IT HIDDEN ?
	PJRST	PNTPPN		;YES-TYPE PPN
	JUMPLE	A,SP4SIX	;PRINT AS NAME IF SIX BIT
	MOVEM	A,UFDLCS	;SAVE UFD LOCATOR
	IDIVI	A,DULHSH	;COMPUTE PROPER DULL ENTRY
	USETI	DUL,1(B)	;SET TO READ PROPER LOCATION
DULIN:	INPUT	DUL,COM		;READ THE DUL
	JRST	DULOK		;DUL READ
DULCK:	MOVE	A,UFDLCS	;SOMETHING WRONG-PRINT GANUNO
	PJRST	PNTPPN		;TYPE PPN

DULOK:	MOVEI	B,BUF
DULP:	SKIPG	A,(B)
	JRST	DULCK		;SOMETHING WRONG
	CAMN	A,UFDLCS	;DOES IT COMPARE?
	JRST	DULPNT		;YES-PRINT USER NAME
	ADDI	B,3		;NEXT ENTRY
	JRST	DULP

DULPNT:	PUSH	P,C
	PUSH	P,D		;SAVE REGISTERS
	ADDI	B,1		;POINT TO USER NAME
	MOVEI	C,^D12
	HRLI	B,(POINT 6,0)
	MOVEI	D,0
SXLP:	ILDB	CH,B
	SKIPN	MESPC		;ONES=PRINT 12 CHR FIELD,ZERO=NO
	JUMPE	CH,SXPCE	;SPACE
	JUMPN	D,SXPOUT	;OUTPUT SPACES NOW
SXLP2:	ADDI	CH," "
	PUSHJ	P,TYO
SXLP1:	SOJG	C,SXLP
	POP	P,D
	POP	P,C
	POPJ	P,
SXPCE:	AOJA	D,SXLP1
SXPOUT:	MOVEI	CH," "
	PUSHJ	P,TYO
	SOJG	D,SXPOUT
	LDB	CH,B
	JRST	SXLP2
	SUBTTL	SUBROUTINES -- TAKE SNAPSHOT OF T.S. SYSTEM

;PUSHJ HERE, WILL POPJ BACK WHEN DONE
GA:	MOVE	A,XFSFPP	;GET SOME SYSTEM STUFF
	GETTAB	A,
	 SETZ	A,
	SKIPN	A
	MOVE	A,[1,,2]
	MOVEM	A,FSFPPN

	MOVE	A,XOPR		;GET NAME OF "OPR"
	GETTAB	A,
	 SETZ	A,
	MOVEM	A,OPR
	CALLI	A,14		;GET TODAY'S DATE.
	MOVEM	A,DATE		;SAVE TODAY'S DATE
	MOVE	A,XSPPN		;GET SYS: PPN PAIR
	GETTAB	A,
	 SETZ	A,
	SKIPE	A
	MOVEM	A,SYSPPN
	HRLZI	B,LQTAB		;GET Q TABLE NAMES IF WE CAN
	SETZB	C,TISL
QTLP:	HRRZ	A,XSYSTS	;QUEUE TABLE
	HRL	A,B
	GETTAB	A,
	 SETZ	A,
	JUMPE	A,QTLP1
	MOVEM	A,QTAB(B)
	MOVE	D,[POINT 12,QTAB(B)]
	HRLI	C,-3
QTLP2:	ILDB	A,D		;GET NEXT CODE
	CAIN	A,'SL'		;SKIP IF NOT SLEEP
	HRRM	C,TISL		;REMEMBER WAIT STATE CODE FOR SLEEP
	CAIN	A,'TI'		;SKIP IF NOT TI
	HRLM	C,TISL		;REMEMBER CODE FOR TI
	AOBJN	C,QTLP2
	AOBJN	B,QTLP
QTLP1:	MOVE	A,XSTATS
	GETTAB	A,
	 SETZ	A,
	MOVEM	A,STATES
	JUMPE	A,DNTSTO	;DONT OVERRIDE TCKSEC IF GETTAB UUO UNDEFINED
	MOVEI	B,^D60
	TLNE	A,(CLKCYC)
	MOVEI	B,^D50
	MOVEM	B,TCKSEC
	MOVE	A,XSYSTP	;FIND OUT THE NAME OF "SYS:"
	GETTAB	A,
	 SETZ	A,
	CAMN	A,[SIXBIT /DSK/]  ;IF "DSK:",
	MOVEI	A,0		;  CLEAR FOR EASY TESTS LATER
	MOVEM	A,SYSTAP	;STORE AWAY
DNTSTO:	MOVE	A,XMEMNS	;GET CORE SPEED
	GETTAB	A,
	 SETZ	A,
	SKIPE	A
	MOVEM	A,MEMNSP	;DON'T OVERRIDE IF UNDEFINED
;READ TTY STATUS DATA

	MOVE	C,JOBFF
	MOVEM	C,LASJBF

	MOVE	A,XSEGPT
	GETTAB	A,
	 SETZ	A,
	MOVEM	A,SEGPTR
	HLRE	B,A
	MOVNM	B,SEGN
	HRRZM	A,JOBN
	ADD	A,SEGN
	HRRZM	A,BOTH
; NOW, CHECK TO SEE IF SYSTAT HAS ENOUGH TABLE SPACE
	MOVEI	A,MX.JOB		;GET MAX JOBS
	CAMGE	A,JOBN		;ENOUGH ROOM?
	BOMB	(System configuration exceeds SYSTAT table space [MX.JOB])
	HRRZ	B,JOBFF
	MOVEM	B,ZERLOW
	MOVEM	B,FREE
	MOVEI	A,NO.TBL*MX.JOB(B)	; PUT UP CORE TO LIMIT
	CORE	A,
	  JRST	NOCOR		;TROUBLE-PRINT MESSAGE & QUIT
	HRRZ	A,JOBREL
SYS0A:	MOVEM	A,ZERHGH
		@ZERLOW
	MOVE	A,ZERLOW
	HRLS	A
	ADDI	A,1
	BLT	A,@ZERHGH
;HERE TO SET UP ALL-ROUND TABLES
;THESE ARE MANUALLY FUDGED.
	MOVE	A,FREE
	HRRM	A,.TYM		;SET UP TYMNET BUFFER STUFF
	MOVE	A,JOBN		;IN COUNTERS
	ADDB	A,FREE
	HRRM	A,.DVIOS	;DEVIOS WORD FOR JOB
	MOVE	A,JOBN
	ADDB	A,FREE		;INC COUNTERS
	HRRM	A,.USRN1	;PART 1 OF USER NAME
	MOVE	A,JOBN		;CURRENT # JOBS
	ADDB	A,FREE		;INC COUNTERS
	HRRM	A,.USRN2	;PART 2 USER NAME
	MOVE	A,JOBN
	ADDB	A,FREE		;INCLUDE JOB TIME TABLES
	HRRM	A,.TIM		;SET UP BUFFER ADDRESS
	MOVE	A,JOBN
	ADDB	A,FREE		;INC COUNTERS
	HRRM	A,.TTY
	MOVE	A,JOBN		;GET NUMBER OF JOBS
	ADDB	A,FREE		;ADVANCE POINTER
	HRRM	A,.TTYN		;SETUP TABLE OF LINE NUMBERS
IFN FTCONN,<
	MOVE	A,JOBN		;GET JOB NO.
	ADDB	A,FREE		;ADD TO FREE SPACE
	HRRM	A,.CON		;SET CONNECT TIME POINTER
>
IFN FTDSIO,<
	MOVE	A,JOBN		;GET JOB NO.
	ADDB	A,FREE		;ADD TO FREE SPACE
	HRRM	A,.DSIO		;SET CORE ARRAY POINTER>
IFN FTCHIO,<
	MOVE	A,JOBN		;GET JOB NO.
	ADDB	A,FREE		;ADD TO FREE SPACE
	HRRM	A,.CHIO		;SET CORE ARRAY POINTER>
IFN FTFROM,<
	MOVE	A,JOBN
	ADDB	A,FREE
	HRRM	A,.FRM>
IFN FTUSIO,<
	MOVE	A,JOBN
	ADDB	A,FREE		;ADD TO FREE SPACE
	HRRM	A,.USIO		;SET CORE ARRAY POINTER>
	SETOM	(A)		;JOB 0 IS ON NO LINE
	HRRZ	J,JOBN		;SET UP JOB COUNTER
SYS0L:	HRRZ	J,J		;SET UP J
	HRRZ	C,XTTYNO	;GET TTY NAME GIVEN JOB NO.
	HRL	C,J		;C: LH=JOB,RH=-27
	GETTAB	C,		;GET THE TABLE
	SETZ	C,		;FAILED--ASSUME ZERO
	MOVEM	C,@.TTY		;SAVE IN TTY TABLE
TTYCN1:	MOVE	A,[POINT 6,@.TTY,17]
	MOVEI	B,0		;GET TTY NUMBER
TTYCN2:	ILDB	C,A		;GET NEXT DIGIT
	SUBI	C,'0'		;CONVERT TO BINARY
	JUMPL	C,TTYCN3	;EXIT. WHEN DONE
	LSH	B,3		;ADVANCE RESULT
	IOR	B,C		;INCLUDE THIS DIGIT
	TLNE	A,(77B5)	;SEE IF AT END OF WORD
	JRST	TTYCN2		;NO--LOOP FOR MORE
TTYCN3:	MOVEI	A,-1		;SET RIGHT HALF MASK
	MOVEM	B,@.TTYN	;STORE LINE NUMBER AWAY
SYS0Z:	HRRZ	B,XUSRN1
	HRL	B,J
	GETTAB	B,
	SETZ	B,
	MOVEM	B,@.USRN1
	HRRZ	B,XUSRN2
	HRL	B,J
	GETTAB	B,
	SETZ	B,
	MOVEM	B,@.USRN2
IFN FTCONN,<
	HRRZ	B,XCONTM	;CONNECT TIME GETTAB
	HRL	B,J		;GET JOB NO
	GETTAB	B,		;GET THAT TABLE..
	SETZ	B,		;TOO BAD
	MOVEM	B,@.CON		;SAVE CONNECT TIME
>
IFN FTDSIO,<
	HRRZ	B,XJBRCT	;DSK BLOCKS READ
	HRL	B,J		;GET JOB NO.
	GETTAB	B,		;GET TABLE
	SETZ	B,		;TO BAD
	AND	B,[000077,,777777];MASK OUT INCREMENTAL BLOCKS
	MOVEM	B,@.DSIO	;SAVE COUNT
	HRRZ	B,XJBWCT	;DSK BLOCKS WRITTEN
	HRL	B,J		;GET JOB NO.
	GETTAB	B,		;GET TABLE
	SETZ	B,		;TOO BAD
	AND	B,[000077,,777777];MASK OUT INC BLOCKS
	ADDM	B,@.DSIO	;ADD IN WRITE COUNT>
IFN FTCHIO,<
	HRRZ	B,XJBCIN	;CHARS READ
	HRL	B,J		;GET JOB NO
	GETTAB	B,		;GET TABLE
	SETZ	B,		;TOO BAD
	MOVEM	B,@.CHIO		;SAVE CHARACTER IO COUNT
	HRRZ	B,XJBCOT	;CHARS WRITTEN
	HRL	B,J		;GET JOB NO.
	GETTAB	B,		;GET TABLE
	SETZ	B,		;TOO BAD
	ADDM	B,@.CHIO	;ADD IN CHAR COUNT>
IFN FTFROM,<
	HRRZ	B,XFROM
	HRL	B,J
	GETTAB	B,
	SETZ	B,
	MOVEM	B,@.FRM>
IFN FTUSIO,<
	HRRZ	B,XJBUSI	;USETIO COUNT
	HRL	B,J		;GET JOB NO
	GETTAB	B,		;GET TABLE
	SETZ	B,		;TOO BAD
	MOVEM	B,@.USIO	;SAVE COUNT>
	HRRZ	B,XDVIOS	;DEVIOS GETTAB
	HRL	B,@.TTYN	;GET TTY NO.
	GETTAB	B,		;GET THESE FROM GETTAB
	SETZ	B,		;NOT THERE--TYPE ZERO
	MOVEM	B,@.DVIOS	;SAVE IN DVIOS TABLE
	HRRZ	B,XTYMIF	;TYMNET INFO GETTAB
	HRL	B,@.TTYN	;TELETYPE NUMBER
	GETTAB	B,		;GET TABLE
	SETZ	B,		;FAILURE?
	MOVEM	B,@.TYM		;SAVE IN TYMNET TABLE
	HRRZ	B,XJBTIM	;SET UP JOB TIME TABLES
	HRL	B,J		;GET JOB NO.
	GETTAB	B,		;GET INFORMATION
	SETZ	B,		;CANT GET IT  -  PUT IN ZERO
	MOVEM	B,@.TIM		;SET IN TABLE
	SOJG	J,SYS0L
;READ JOB AND SEGMENT STATUS

SYS0X:	MOVE	A,JOBN
	ADDB	A,FREE
	MOVE	B,[XWD -NTAB,TABPTR]
	MOVE	C,(B)
	HRRM	A,(C)
	MOVE	A,JOBN
	IMULI	A,NJOBT
	MOVE	C,SEGN
	IMULI	C,NSEGT
	ADD	A,C
	ADD	A,FREE
	HRRZ	C,JOBREL
	CAIL	C,(A)
	JRST	INIT1
	HRRZS	A
	CORE	A,
	  JRST	NOCOR
INIT1:	MOVE	C,(B)
	HRRZ	J,BOTH
	TLZN	C,SIGN
	HRRZ	J,JOBN
	MOVE	A,FREE
	ADDI	A,(J)
	HRRM	A,1(C)
	HRRZM	A,FREE
	MOVNS	J
	HRLZS	J
INIT2:	MOVS	A,C
	HRLI	A,(J)
	GETTAB	A,
	 SETZ	A,
	MOVEM	A,@0(C)
	AOBJN	J,INIT2
	AOBJN	B,INIT1
	MOVE	A,FREE
	ADD	A,SEGN
	HRRZM	A,FREE
	MOVE	A,.SEGCT
	HRLS	A
	SETZM	(A)
	ADDI	A,1
	BLT	A,@FREE
	MOVE	A,XMEMSZ		;GET SIZE OF USER CORE
	GETTAB	A,
	 SETZ	A,
	JUMPE	A,INIT5		;IF LEVEL-C, USE CORMAX
	MOVE	B,A
	MOVE	A,XSYSSZ
	GETTAB	A,
	 SETZ	A,
	ADDI	A,1777		;ROUND UP
	TRZ	A,1777
	MOVN	A,A
	ADD	A,B		;MEMSIZ-SYSSIZ
	JRST	INIT6
INIT5:	MOVE	A,XCORMX
	GETTAB	A,
	 SETZ	A,
INIT6:	MOVEM	A,CORMAX

; NOW, COMPUTE TOTAL SWAP SPACE AVAILABLE
; EITHER 'XK4SWP' GETTAB OR -FAIL- CORMAX
	MOVE	A,XK4SWP
	GETTAB	A,		;GET SWAP PAGES AVAILABLE
	 SETZ	A,		;ERROR - 0
	JUMPE	A,[MOVE	A,CORMAX ;IF =0, ASSUME VALUE TO
		ASH A,-11	;CONVERT TO PAGES
		JRST .+1]
	MOVEM	A,DSKFRE	;SAVED: TOTAL SWAP SPACE AVAIL
;SET JOBFF TO A GOOD LOCATION
	MOVE	C,FREE
	ADDI	C,100
	MOVEM	C,JOBFF		;RESET JOBFF
	POPJ	P,		;END INITIALIZATION OF TABLES
	SUBTTL	SUBROUTINES -- TICK-TOCK

TCKTIB:	TLOA	F,FL.BZR	;BLANK LEADING ZEROES
TCKTIS:	TLO	F,FL.SZR	;SUPPRESS ZEROES
TCKTIM:	IDIV	A,TCKSEC	;JUNK JIFFIES
	ASH	B,1		;ROUND?
	CAML	B,TCKSEC
	ADDI	A,1		;ROUND-UP
TIME:	PUSH	P,A		;ASVE TIME FOR LATER TEST
	IFGE  FTAMPM,<
	IFE   FTAMPM,<
	MOVSI	B,(CLKCYC)	;GET FLAG FOR 50 HERTZ
	TDNE	B,STATES	; IN STATES WORD
	TRZ	F,FR.DAY	;YES--CLEAR AM/PM REQUEST
>
	TRNE	F,FR.DAY	;SEE IF AM/PM HACK
	CAIGE	A,^D12*^D60*^D60  ;YES--SEE IF PM
	JRST	.+2		;NO--SKIP
	SUBI	A,^D12*^D60*^D60  ;YES--SUBTRACT 12 HOURS
>
	IDIVI	A,^D60*^D60
	IFL   FTAMPM,<
	MOVE	N,A
>
	IFGE  FTAMPM,<
	SKIPN	N,A
	TRNN	F,FR.DAY
	JRST	.+2
	MOVEI	N,^D12
>
	PUSHJ	P,DECP2X
	PUSHJ	P,COLON
	IDIVI	B,^D60
	MOVE	N,B
	PUSHJ	P,DECPR2
	PUSHJ	P,COLON
	MOVE	N,C
	MOVEI	C,DECPR2	;PRESET ROUTINE
	TLZE	F,FL.SZR
	MOVEI	C,RDX10	;IF SUPPRESSING, MAKE SURE WE PRINT SOMETHING
	TLZE	F,FL.BZR
	MOVEI	C,DECP2X	;LIKEWISE FOR BLANKING
	PUSHJ	P,(C)		;PRINT FINAL FIELD
	POP	P,C		;RECOVER ARGUMENT
	IFGE  FTAMPM,<
	MOVEI	M,[ASCIZ / A.M./]
	CAIL	C,^D12*^D60*^D60
	MOVEI	M,[ASCIZ / P.M./]
	TRZE	F,FR.DAY	;SEE IF AM/PM HACK
	JRST	MSG		;YES--OUTPUT SUFFIX
>
	POPJ	P,		;NO--RETURN
	SUBTTL	SUBROUTINES -- TRU PRINTER

;ROUTINE TO PRINT TRU UNITS USED
; CALL WITH TRU TIME IN A.
PRNTRU:
	IDIVI	A,^D100
	IDIVI	A,^D100
	PUSH	P,B
	MOVE	N,A
	MOVEI	CH,^D99999
	PUSHJ	P,RDX10F
	MOVEI	CH,"."
	PUSHJ	P,TYO
	MOVEI	CH,"0"
	MOVE	A,(P)
	CAIGE	A,^D10
	PUSHJ	P,TYO
	POP	P,N
	JRST	RDX10
	SUBTTL	SUBROUTINES -- SAY HELLO

THISIS:
	MOVEI	B,0
CONST:	MOVEI	C,11		;DON'T CHANGE THIS LINE WITHOUT LOOKING AT TAB:!!!!
	PUSHJ	P,CRLF
	PUSHJ	P,PSYSNO
	MOVE	A,XUPTIM
	GETTAB	A,
	 SETZ	A,
	JUMPE	A,TISACC	;CANT GET UP TIME
	PUSH	P,A		;SAVE UP TIME
	MOVEI	M,[ASCIZ / up /]
	PUSHJ	P,MSG
	PUSHJ	P,TCKTIS
	POP	P,A
IFG FTEXCL,<
	MOVEI	CH,"!"		;IF UP MORE THAN FTMAXP HRS TYPE !
	HLRZ	M,A		;CHECK AND SEE
	CAIL	M,FTMAXP	;WELL ??
	PUSHJ	P,TYO		;IT IS - TYPE !
>
TISACC:	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,MSG
	TIMER	A,		;GET ADJUSTED IN TIME OF DAY
	MOVEM	A,NOW		;SAVE FOR LATER
	IFGE  FTAMPM,<
	TRO	F,FR.DAY	;SET FOR DATE AM/PM HACK
>
	PUSHJ	P,TCKTIM
	MOVEI	M,[ASCIZ / on /]
	PUSHJ	P,MSG
	MOVE	A,DATE		;GET TODAY'S DATE
IFE FTDAZE<
;ASSEMBLY FOR STANDARD DEC TYPE DATES
	IDIVI	A,^D31
	MOVEI	N,1(B)
	PUSHJ	P,DECPR2
	IDIVI	A,^D12
	MOVE	B,MONTAB(B)
	MOVEI	C,0
	MOVEI	M,B
	MOVEI	N,^D64(A)
	PUSHJ	P,MSGDEC	;PRINT MESSAGE FOLLOWED BY DECIMAL NO.
>; ASSEMBLE ABOVE FOR DEC TYPE DATE
IFN FTDAZE<
;ASSEMBLY FOR NORMAL DATE AS:   TUE JAN 5, 1973
	IDIVI	A,^D31		;CONVERT (B) INTO DAY
	MOVEI	N,1(B)		;N=REAL DAY AS 1-31
	MOVEM	N,%DAY		;SAVE DAY
	IDIVI	A,^D12		;GET MONTH.
	MOVEM	B,%MONTH	;SAVE IT
	MOVEI	N,^D64(A)	;GET YEAR
	MOVEM	N,%YEAR	;SAVE IT
;NOW, COMPUTE THE DAY.
;FORMULA IS:
;	I=MONTH INDEX (0-11)
;	J=DAY OF MONTH (1-?)
;	K=YEAR (1973-?)
;	L=KEY(I)
;KEY::=	1,32,50,77,79,82,77,80,83,78,81,83
;	IF MOD(K,4) = 0 AND L.LT.60 --: L=L-1
;	L=(K/12+MOD(K,12))+(MOD(K,12)/4)+L
;	MOD(L,7) --: DAY
	SETZM	RESULT		;CLEAR RESULT
	MOVE	A,%MONTH	;GET MONTH INDEX
; GET THE KEY INDEXED BY A
	MOVE	A,[DEC 1,32,60,91,93,96,91,94,97,92,95,97](A)
	ADD	A,%DAY		;ADD IN THE DAY
	MOVEM	A,%KEY		;SAVE KEY.
	MOVE	A,%YEAR		;CHECK FOR LEAP YEAR.
	IDIVI	A,4		;COMPUTE (B) = (K MOD 4)
	MOVE	A,%KEY		;GET KEY
	JUMPN	B,.+3
	CAIG	A,^D60
	SOS	%KEY		;IF MOD(K.4)=0 AND L.LT.50 THEN L=L-1
; COMPUTE: L= (K/12) + (MOD(K,12)) + (MOD(K,12)/4) + L
	MOVE	A,%YEAR		;DIVIDE YEAR BY 12
	IDIVI	A,^D12		;AS SO.
	ADDM	A,RESULT	;ADD IN (K/12)
	ADDM	B,RESULT	;ADD IN (MOD(K,12))
	IDIVI	B,^D4		; TAKE MOD(K,12) / 4
	ADDM	B,RESULT	;ADD IT IN.
	MOVE	A,%KEY
	ADDB	A,RESULT	;ADD IN KEY.
	IDIVI	A,^D7		;COMPUTE MOD(RESULT,7)
	MOVE	B,DAYTAB(B)	;GET THE DAY
	SETZ	C,		;MAKE ASCIZ STRING
	MOVEI	M,B		;B = STRING, M=ADR(B)
	PUSHJ	P,MSG
	MOVE	N,%DAY
	MOVE	B,%MONTH
	MOVE	B,MONTAB(B)
	SETZ	C,0
	MOVEI	M,B
	PUSHJ	P,MSGDEC
	MOVE	N,%YEAR
	MOVEI	N,^D1900(N)	;MAKE IT INTO 19[WHATEVER]
	MOVEI	CH,","
	PUSHJ	P,TYO		;TYPE OUT A  ,
	PUSHJ	P,DECPR2
>; ASSEMBLE ABOVE FOR TYMSHARE TYPE DATE
	PJRST	CRLF
	SUBTTL	SUBROUTINES -- SPECIALIZED I/O ROUTINES

;SUBROUTINE TO PRINT PROJECT PROGRAMMER NUMBER AS A PAIR
;IF ZERO, RETURN
;IF SIGN BIT ON, PRINT IN SIXBIT
;ELSE, PRINT AS PAIR OR OCTAL NUMBERS
;ENTERED WITH PPN TO BE PRINTED IN A
;USES N,R,N1,BP,CH

PNTPPN:	SKIPN	A		;SEE IF NULL
	POPJ	P,		;YES--RETURN
	CAMN	A,[-1]		;SEE IF HIDDEN
	JRST	ASTSIX		;YES--PRINT ASTERISKS
	JUMPLE	A,SP4SIX	;PRINT AS NAME IF SIXBIT
	PUSH	P,A		;SAVE ARGUMENT
	HLRZ	N,A		;GET LEFT HALF
	MOVEI	CH,77777	;SET UP 5 DIGIT SET-UP
	PUSHJ	P,RDX8F	;OUTPUT IN FIXED FORMAT
	PUSHJ	P,COMMA
	PJRST	OCTRH

;PRINT OCTAL AS UNSIGNED HALVES
OCTLRH:	PUSH	P,N
	HLRZ	N,N
	JUMPE	N,OCTRH
	PUSHJ	P,RDX8		;OUTPUT IN OCTAL
	PUSHJ	P,COMMA
OCTRH:	HRRZ	N,(P)
	PUSHJ	P,RDX8		;OUTPUT IN OCTAL
	POP	P,N
	POPJ	P,
;SUBROUTINE TO GET A CH. FROM TTY
;CALL	PUSHJ	P,GETCHR
;	NONE LEFT OR BREAK CH. FOUND
;	GOT A CH. RETURN
;AC WD IS RETURNED WITH THE CH.
;AC F WILL HAVE FL.BRK SET IF BREAK CH. FOUND

GETCHR:	SKIPE	WD,SAVCHR	;SEE IF ALREADY HOLDING CHAR
	JRST	[SETZM	SAVCHR	;YES--CLEAR IT
		 JRST	CPOPJ1]	;AND RETURN IT
	TLNE	F,FL.BRK	;SEE IF ALREADY AT END
	  JRST	FLAGIT		;NONE LEFT
	INCHWL	WD		;GET CHAR AND WAIT LINE MODE
	CAIL	WD,"A"+40	;CHECK LOWER CASE
	CAILE	WD,"Z"+40
	JRST	.+2		;NO
	SUBI	WD,40		;YES
	CAIN	WD,11		;SEE IF TAB
	MOVEI	WD," "		;YES--CHANGE TO SPACE
	CAIG	WD,14		;IS IT LF,VT
	CAIGE	WD,12		; FF OR
	CAIN	WD,33		; ALTMODE?
	JRST	FLAGIT		;YES - NON SKIP RETURN
	CAIG	WD,176		;OTHER KINDS
	CAIGE	WD,175		; OF ALTMODE?
	JRST	CPOPJ1		;NO - SKIP RETURN
FLAGIT:	TLO	F,FL.BRK	;FLAG THAT BREAK FOUND
	POPJ	P,		;NON SKIP RETURN

;GET RADIX INPUT
GETRDC:	TDZA	N,N		;CLEAR ANSWER AND SUCK CHAR
GETRDX:	TDZA	N,N		;CLEAR ANSWER
GETRD1:	PUSHJ	P,GETCHR	;GET NEXT DIGIT
	  JFCL			;IGNORE END
	CAIL	WD,"0"		;SEE IF DIGIT
	CAIL	WD,"0"(R)	; ..
	JRST	[EXCH	WD,SAVCHR	;NO--SAVE FOR NEXT SCAN
		 POPJ	P,]		;RETURN
	IMULI	N,(R)		;YES--ADVANCE RESULT
	ADDI	N,-"0"(WD)	;ADD DIGIT
	JRST	GETRD1		;LOOP FOR MORE
;SUBROUTINE TO DIVIDE A NUMBER IN AC N BY TEMP
;ROUND UP RESULT IF NECESSARY AND PRINT MESSAGE FOLLOWED BY N (%)
;CALL	MOVEM	AC,TEMP
;	MOVE	N,NUMBER TO BE DIVIDED
;	MOVEI	M,[ASCIZ /TEXT/]
;	PUSHJ	P,CMPCNT
;	ALWAYS	RETURN
;ACS N1,N,M,CH & R ARE DESTROYED

CMPCNT:	IMULI	N,^D100
	IDIV	N,TEMP
	LSH	N1,1
	CAML	N1,TEMP
	ADDI	N,1
	PJRST	MSGDEC

; MSGDEP, GO TO MSG, THEN RDX10, THEN SPACE
MSGDEP:	PUSHJ	P,MSG
	PUSHJ	P,RDX10
	PJRST	SPACE

MSGDEC:	PUSHJ	P,MSG
	JRST	RDX10

SIXDEC:	PUSHJ	P,SIXBP
	JRST	RDX10

DECMSG:	PUSHJ	P,RDX10	;OUTPUT DECIMAL
	JRST	MSG		;THEN MESSAGE

MSGOCT:	PUSHJ	P,MSG		;SEND MESSAGE
	JRST	OCTLRH		;THEN OCTAL

DECTAB:	PUSHJ	P,RDX10		;PRINT DECIMAL NO.
	PJRST	TAB		;TAB, RETURN****

DECPR2:	MOVEI	CH,"0"
	TLNE	F,FL.BZR
DECP2X:	MOVEI	CH," "
	CAIG	N,^D9
	TLNE	F,FL.SZR
	PJRST	RDX10
	PUSHJ	P,TYO
	PJRST	RDX10
	SUBTTL	SUBROUTINES -- SEGMENT/TIME CONTROL STUFF

;SUBROUTINE TO COMPUTE THE SIZE OF A HI OR LOW SEGMENT
;ENTERRED WITH J=JOB OR SEGMENT NUMBER;   IF JOB, JS=STATUS
;RETURN     AC N=SIZE IN PAGES
;RESPECTS ALL AC'S

SEGSZ:	MOVE	N,@.SWP		;GET JOB'S SWAPPING DATA
	ANDI	N,777		;GET 8-BIT REQUESTED SIZE
	POPJ	P,

;SUBROUTINE TO CHECK IF A SEGMENT IS INACTIVE
;INACTIVE IS DEFINED AS RUN BIT OFF OR TI OR SL STATE
;ARGS	J=SEGMENT NUMBER IN RH
;NON-SKIP RETURN IF ACTIVE, SKIP RETURN IF INACTIVE

INACTC:	SKIPL	D,@.STS		;SKIP IF RUN BIT ON
	JRST	CPOPJ1		;OFF, INACTIVE
	LDB	D,[POINT 5,D,14];GET WAIT STATE CODE
	HLL	D,TISL		;SET UP FOR TEST
	CAMN	D,TISL		;SKIP IF IT DOES NOT MATCH
	JRST	CPOPJ1		;YES-MATCHES-INACTIVE
	MOVSS	TISL
	HLL	D,TISL
	CAMN	D,TISL
	JRST	CPOPJ1		;GOODBYE
	POPJ	P,		;IS INACTIVE
;SUBROUTINE TO FIND 1ST. JOB USING A SEGMENT
;CALL	MOVE	J,SEGMENT NO.
;	PUSHJ	P,SEGSCN
;	NONE FOUND RETURN
;	FOUND
;AC'S B & C DESTROYED
;AC J IS RESPECTED

SEGSCN:	MOVN	B,JOBN
	HRLZS	B
	HRR	B,.SGN		;PREPARE AOBJN PTR. FOR SCANNING JBTSGN
HIGH06:	HRRZ	C,(B)		;GET SEGMENT NO.
	CAIE	C,(J)		;DOES IT MATCH WITH CURRENT ONE?
HIGH6A:	AOBJN	B,HIGH06	;NO-DO AGAIN
	JUMPL	B,CPOPJ1	;WE HAVE A MATCH?
	POPJ	P,		;NO-NONE FOUND RETURN


; SUBROUTINE TO PRINT MESSAGE AND ADD DSKUSE COUNT
;CALL	MOVE	JS,JOB/HISEG STATUS
;	MOVE	B,CORE SIZE (HI ONLY)
;	MOVSI	A,(SIXBIT .XX.)
;	PUSHJ	P,LOPSWP/HIPSWP
;	ALWAYS GOOD RETURN
;AC'S A,B,BP,CH ARE DESTROYED
;AC JS IS RESPECTED  *******MSG TO BE PRINTED MUSTN'T EXCEED 4 CHS.********

HIPSWP:LOPSWP:	PUSHJ	P,SIXBP	;TYPE OUT SPECIFIED STATE
	MOVE	N,@.SWP		;GET JOB'S SWAPPING DATA
	LSH	N,-^D9		;GET 9-BIT FIELD
	ANDI	N,777
	ADDM	N,DSKUSE	;ADD TO TOTAL SPACE USED ON SWAP DEV
	POPJ	P,		;RETURN****
SUBTTL	TYPNOD - Output node info

	ENTRY	TYPNOD		;Call with word in INFO

TYPNOD:	LDB	NODE,[POINT 6,INFO,27]	;6 low-order bits
	LDB	NODE1,[POINT 6,INFO,19]	;6 high-order bits
	DPB	NODE1,[POINT 6,NODE,29]	;Combine 12 bits
	PUSHJ	P,FNDNOD	;Find node name
	  JRST	TYPND1		;Not there
TYPND2:	PUSHJ	P,MSG		;M points to ASCIZ name
	POPJ	P,		;End of TYPNOD

;Here when node not found in the table - print "**7777**" for node 7777

TYPND1:	MOVEI	M,[ASCIZ /**/]	;Output first 2 asterisks
	PUSHJ	P,MSG
	MOVEI	R,^O10		;Octal radix
	PUSHJ	P,RDXN		;Print node #
	MOVEI	M,[ASCIZ /**/]	;Second set of **
	JRST	TYPND2

; Search for valid node in %NODBUFF - (TYMNET)NODES.MAP
; Assumes nonzero node numbers are monotonically increasing (can have gaps).
; Does not assume that node N is at word 3*N in file (which is possible).
;  Three words per entry:
;    1: Number of node
;  2,3: Up to 10 ASCII characters of node name

FNDNOD:	HRRZS	(P)		;Clear pass-2 flag
FNODE:	MOVEI	N1,0		;Start at beginning of buffer
FNODE2:	CAMN	NODE,%NODBUF(N1);BUFFER .EQ. NODE ?
	 JRST	FNODOK		;Yes, found it
	CAMG	NODE,%NODBUF(N1);Gotten to the right spot in the buffer yet?
	 JRST	FNODE0		;Oops, missed it.  Try again from the beginning
	ADDI	N1,3		;Point to next entry
	CAIL	N1,%NODSIZE	;End of table?
	 JRST	FNODE1		;Yes, try next 3 blocks
	JRST	FNODE2

;Go back to beginning if too far into the file

FNODE0:	SKIPGE	(P)		;If been here already,
	 POPJ	P,		; give up.  Node is not mentioned in file
	USETI	NOD,1		;Go back to the beginning of the file
	HRROS	(P)		;Set flag saying file has been rewound

;Get next record of 3 blocks

FNODE1:	IN	NOD,NODIOWD	;Read 3 blocks of file
	  JRST	FNODE		;No errors
	SKIPGE	(P)		;If EOF and already tried USETI once,
	 POPJ	P,		; give up.  Node is not at end of file
	JRST	FNODE0		;Otherwise rewind and try one more pass

;Here when node found

FNODOK:	MOVEI	M,%NODBUFF+1(N1);Get address of 9 character node name
	SKIPE	(M)		;If name is nonzero,
	 AOS	(P)		; success return
	POPJ	P,		;End of FNDNOD
SUBTTL	CONSTANTS

COM:	IOWD	LN.BUF,BUF	;FOR READING DUL.
	Z			;END OF LIST.

XSEGPT:	XWD	15,11		;LH=-# HIGH SEGS, RH=+# JOBS + NULL JOB
XUPTIM:	XWD	15,12		;JIFFIES SYSTEM HAS BEEN UP
XSYSTS:	XWD	0,25		;SYSTEM QUEUE NAMES (STSTBL)
XCORMX:	XWD	10,12		;LARGEST LEGAL JOB IN WORDS
XSYSSZ:	XWD	12,11		;HIGHEST LOCATION IN MONITOR
XMEMSZ:	XWD	23,12		;SIZE OF PHYSICAL MEMORY IN WORDS
XSTATS:	XWD	17,11		;FEATURES OF SYSTEM WORD
XK4SWP:	XWD	1,15		;K DISK WORDS FOR SWAPPING ALL UNITS
XSPPN:	XWD	1,16		;SYS PPN [1,4]
XMEMNS:	XWD	21,11		;NO. NANOSECONDS/MEMORY CYCLE
XOPR:	XWD	13,11		;NAME OF OPR TTY
XSYSTP:	XWD	7,11		;NAME OF SYSTEM TAPE ("SYS:")
XFSFPP:	XWD	2,16		;OPERATOR (FAILSAFE) NUMBER
XUSRN1:	XWD	0,-22		;USER NAME PART ONE
XUSRN2:	XWD	0,-21		;USER NAME PART TWO
XJBTIM:	XWD	0,4		;RUN TIME GETTAB
XDVIOS:	XWD	0,-31		;DEVIOS WORD
XTYMIF:	XWD	0,-24		;TERMINAL CHARACTERISTICS GETTAB
XTTYNO:	XWD	0,-27		;GET TTY NAME GIVEN JOB NO.
IFN FTCONN,<
XCONTM:	XWD	0,-12		;GET CONNECT TIME TABLE>
IFN FTDSIO,<
XJBRCT:	XWD	0,17		;DSK READS
XJBWCT:	XWD	0,20		;DSK WRITES>
IFN FTCHIO,<
XJBCIN:	XWD	0,-7		;TTY READS
XJBCOT:	XWD	0,-10		;TTY WRITES>
IFN FTFROM,<
XFROM:	XWD	0,-25		;OWNER OF PROGRAM BEING RUN>
DULHSH==^D101	;HASH FOR READING SYS:DUL.SYS
NJOBT==8
NSEGT==7
SIGN=400000		;SIGN BIT.
HEDFLG:	123560,,065321	;NOSPEACH WHEN PUT INTO "WD"

;  TABLES

IFN FTDAZE<
;TABLE OF DAYS
DAYTAB:	ASCIZ/Sat/
	ASCIZ/Sun/
	ASCIZ/Mon/
	ASCIZ/Tue/
	ASCIZ/Wed/
	ASCIZ/Thu/
	ASCIZ/Fri/
>

;TABLE OF MONTHS
MONTAB:	ASCII / Jan /
	ASCII / Feb /
	ASCII / Mar /
	ASCII / Apr /
	ASCII / May /
	ASCII / Jun /
	ASCII / Jul /
	ASCII / Aug /
	ASCII / Sep /
	ASCII / Oct /
	ASCII / Nov /
	ASCII / Dec /

TABPTR:	SIGN+0,,.STS
	SIGN+7,,.SWP
	SIGN+2,,.PPN
	6,,.PRV
	14,,.SGN
	SIGN+3,,.PRG
	SIGN+24,,.DEV
NTAB==.-TABPTR
	XWD	     0,.SEGCT
	SUBTTL	SUBROUTINES -- HACK SUBROUTINES

IFE HACKSW,<OFF.LIST>
IFN HACKSW,<	RADIX 10
DEFINE BDAY (MO,DA,WHO)
<XWD <<MO-1>*^D31+DA-1>,EXP [ASCIZ /WHO/]>
DEFINE SDAY (MO,DA,SALUD)
<XWD SIGN!<<MO-1>*^D31+DA-1>,EXP [ASCIZ /SALUD/]>
BMSG:	ASCIZ	/HAPPY BIRTHDAY /
HAKTAB:
	SDAY (1,1,<HAPPY NEW YEAR>)
	SDAY (7,4,<HAPPY INDEPENDENCE DAY>)
	SDAY (10,12,<HAPPY COLUMBUS DAY>)
	SDAY (12,25,<MERRY CHRISTMAS>)
	SDAY (12,31,<DRIVE CAREFULLY TONIGHT>)

HAKLEN==.-HAKTAB
	RADIX 8
>

	ON.LIST
	END
SIGN=400000	;SIGN BIT.
     @?Iw‘