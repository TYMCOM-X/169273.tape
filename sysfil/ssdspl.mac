        TITLE    SSDSPL:  OPTIONAL DISPLAY PRINTING
        IF1 <PRINTX SSDSPL>
        MAINSW==0         ;INDICATES NOT THE MAIN PROGRAM

;  EXTERNAL SUBROUTINES

	EXTERN	CLRFLG	;CLEARS FIELD INDICATOR (SSIO)
	EXTERN	CMPCNT	;DIVIDE NUMBER AND PRINT MESSAGE (SSIO)
	EXTERN  CPOPJ	;POP RETURN (SSIO)
	EXTERN	CRLF	;OUTPUT CRLF SEQUENCE (SSIO)
	EXTERN	DECMSG	;OUTPUT DECIMAL NUMBER, THEN MESSAGE (SSIO)
	EXTERN	DECP2X	;(IN SSIO)
	EXTERN	DECTAB	;PIRNT DECIMAL NUMBER, TAB (SSIO)
	EXTERN	DULOUT	;DUL READING SUBROUTINE (SSIO)
	EXTERN	FIELD	;FIELD CONTROL (SSIO)
	EXTERN	FLUN4D	;HERE AT END OF GOSUB TABLE (SSDISK)
	EXTERN	HIGH06	;SEGMENT SCANNING (SSIO)
	EXTERN	HIGH6A	;SEGMENT SCANNING (SSIO)
	EXTERN	HIPSWP	;PRINT MESSAGE AND ADD DSKUSE COUNT (SSIO)
	EXTERN	INACTC	;CHECK IF SEGMENT INACTIVE (SSIO)
	EXTERN  MSG	;MESSAGE PRINTING (SSIO)
	EXTERN  MSGDEC	;PRINT MESSAGE, THEN DECIMAL (SSIO)
	EXTERN	MSGOCT	;PRINT MESSAGE, THEN OCTAL (SSIO)
	EXTERN	NOWHO	;(SSIO)
	EXTERN	OCTLRH	;PRINT OCTAL AS UNSIGNED HALVES (SSIO)
	EXTERN	PSPCK	;SEE IF PSP COMMAND (SSDISK)
	EXTERN	RDX10	;PRINT DECIMAL - FREE FORM (SSIO)
	EXTERN	RDX8	;PRINT OCTAL - FREE FORM (SSIO)
	EXTERN	SEGSCN	;SEGMENT SCANNING (SSIO)
	EXTERN	SEGSZ	;COMPUTES SEGMENT SIZE (SSIO)
	EXTERN	SIXBP	;PRINT SIXBIT MESSAGE (SSIO)
	EXTERN	SIXDEC	;PRINT SIXBIT MESSAGE, THEN DECIMAL (SSIO)
	EXTERN	SPACE	;PRINTS A SPACE (SSIO)
	EXTERN	TAB	;PRINTS A TAB (SSIO)
	EXTERN	TYO	;PRINTS A CHARACTER ON TERMINAL (SSIO)
	EXTERN	USESW	;PART OF "USERS" COMMAND (SSCOM)

;  EXTERNAL LOCATIONS

	EXTERN	JOBFF	;ADDRESS OF 1ST FREE LOC. AFTER LOW SEG. (IN JOBDAT)
	EXTERN  JOBVER	;SYSTAT VERSION NUMBER (IN HEADER)

;  GLOBAL SUBROUTINES AND CONSTANTS

	INTERN	D%DECN,D%MSG,D%MSGD,D%MSGN,D%MSGO,D%UNCK
	INTERN	BITTL,GETUDB,PJOBN,PRTBIT,GIVER,SWLPZ
	INTERN	UDTAB,UDTBL,FS,ERREPT,DORMNT,DEVQ
	INTERN	SW,OPNFIL,LPTOPN,HGHSTS,GIVRPS,GIVAPR,GIVSTAT


	SUBTTL	DISPLAY SELECTION -- PRINT HIGH-SEGMENT STATUS

;CALL AS:	PUSHJ	P,HGHSTS
HGHSTS:	LDB	D,DSKLEV
	SETZM	HOMJOB
	SETOM	SEGFLG		;SEG SEGMENT FLAG
	MOVEI	M,[ASCIZ /
Shared segments:
Program	High(P)	Users	Owner
/]
	PUSHJ	P,MSG
	MOVE	J,SEGPTR
	SETZM	CORSAV		;CLEAR COUNTER FOR VIRT. CORE SAVED
HIGH00:	SKIPL	JS,@.STS
	JRST	DUNHGH
	SKIPN	A,@.PRG
	JRST	[MOVE	A,[SIXBIT /(priv)/]
		TLNE	JS,SHRSEG
		MOVE	A,[SIXBIT /(obs)/]
		JRST	.+1]
	PUSHJ	P,SIXBP		;PRINT SIXBIT MSG
	JUMPE	D,HIGH77

HIGH66:	MOVE	A,@.DEV		;USE THE REAL DEVICE NAME
HIGH67:;PUSHJ	P,TABSIX	;TYPE DEVICE NAME
HIGH77:	SKIPN	A,SYSTAP	;SEE IF SYSTEM TAPE IS NOT A DISK
	JRST	HIGH04		;DISK--CHECK PPN
	CAME	A,@.PPN		;COMPARE WITH LEV.C DEVICE
	CAMN	A,@.DEV		;COMPARE WITH LEV.D DEVICE
	JRST	[MOVSI	A,(SIXBIT /SYS/)
		 JRST	HIGH2A]
	SKIPN	A,@.PPN		;NOT SYS, GET DEVICE NAME
	MOVE	A,@.DEV		;FROM TABLES
	JRST	HIGH2A		;AND GO PRINT IT
HIGH04:	MOVE	A,@.PPN
	CAMN	A,SYSPPN	;CUSP HISEG?
	JRST	HIGH2A		;YES-DON'T LOOK FOR DETACHED OWNER
	JUMPN	A,HIGH05
	PUSHJ	P,SEGSCN	;LOOK FOR JOB WITH THIS SEGMENT NO.
	  JRST	HIGH2C
	SKIPGE	B		;PRIVATE HISEG?
	JUMPE	A,[SETOM HOMJOB	;SET JOB AS OWNER FLAG
		SUB	B,.SGN
		HRRZ	N,B
		MOVEM	N,MYHOME		;SAVE HOME
		JRST	HIGH2C]
HIGH05:	JUMPLE	A,HIGH2A	;OWNER MUST BE A DEVICE
	PUSH	P,J		;SAVE CURRENT SEGMENT NO.
	PUSHJ	P,SEGSCN	;FIND 1ST. JOB USING THIS HISEG
	  JRST	NOSEG		;NONE LEFT
	HRRZ	J,B
	SUB	J,.SGN		;GET JOB NO.
	HLRZ	C,@.TTY		;JOB DETACHED?
	CAIN	C,0
	CAME	A,@.PPN		;YES-IS THIS JOB HISEG OWNER?
	SKIPA	J,(P)		;NO-GET HISEG NO. AGAIN
	JRST	GO.ON		;YES-PRINT *'S UNLESS GOD
	AOBJN	P,.+1		;PRETEND WE DID A "PUSHJ"
	SOS	(P)		;DECREMENT PC
	AOBJN	B,HIGH06	;RE-ENTER SUBROUTINE (QUEL HACQUE!)
	POP	P,J		;RESTORE PC IF NO MORE TO CHECK
NOSEG:	POP	P,J		;RESTORE SEGMENT NO.
	JRST	HIGH2A		;PRINT OWNER
GO.ON:	POP	P,J
	PUSHJ	P,NOWHO		;PRINT *'S OR PRJPRG DEPENDING UPON GODLINESS
	JRST	HIGH2A

HIGH2C:	SETZ	A,		;PRINT BLANKS
HIGH2A:	PUSHJ	P,HIGH01
DUNHGH:	SETZM	HOMJOB
	AOBJN	J,HIGH00	;JUMPE IF A HIGH SET LEFT
	POPJ	P,		;RETURN****

HIGH01:
	SKIPN	HOMJOB
	MOVEM	A,MYHOME	;SAVE MY HOME
	PUSHJ	P,TAB
	TLO	F,FL.HSG	;FLAG HI-SEG
	PUSHJ	P,SEGSZ		;COMPUTE SEGMENT SIZE
	MOVE	B,N		;SAVE FOR LATER TEST
	TLNE	F,FL.DOR
	JRST	HIGH4A
	ADDM	N,CORUSE
	PUSHJ	P,SEGSCN	;FIND FIRST USER OF THIS SEG.
	JRST	NOALOW		;NO USERS
	JRST	FSALOW		;SEE IF ACTIVE
NXALOW:	ADD	J,.SGN		;RESTORE SEG PTR
	EXCH	J,B		;RESTORE ORIGINAL J AND B
	PUSHJ	P,HIGH6A	;FIND NEXT USER OF THIS SEG
	JRST	NOALOW		;NO MORE USERS
FSALOW:	EXCH	J,B		;J=PTR TO USER IN SEG TABLE
	SUB	J,.SGN		;J=JOB NO. OF USER
	PUSHJ	P,INACTC	;SKIP IF INACTIVE
	SKIPA	J,B		;ACTIVE, COUNT IT
	JRST	NXALOW		;INACTIVE, CHECK FOR ANOTHER
	ADDM	N,ACTUSE	;COUNT VIRTUAL CORE
NOALOW:	PUSH	P,N
HIGH4A:	PUSHJ	P,DECP2X
	MOVSI	A,(SIXBIT //)
	PUSHJ	P,HIPSWP
	TLNE	F,FL.DOR
	JRST	HIGH4I
	MOVEI	A,(J)
	SUB	A,JOBN
	SOS	N,@.SEGCT
	IMULM	N,(P)
	AOS	N,@.SEGCT
	POP	P,A
	SKIPLE	A		;DON'T ADD TO CORSAV IF 0 OR -VE
	ADDM	A,CORSAV
	PUSHJ	P,TAB
	PUSHJ	P,RDX10
HIGH4I:
	SKIPN	HOMJOB
	JRST	HIGH4H
	PUSHJ	P,TAB
	MOVE	N,MYHOME
	MOVEI	M,[ASCIZ /JOB /]
	PUSHJ	P,MSGDEC
	JRST	CRLF
;IF OWNER =SYS DONE PRINT A THING
HIGH4H:	MOVE	A,@.PPN
	CAMN	A,SYSPPN	;IS IT SYS?
	JRST	HIGHER		;YES--TYPE OUT "SYS"
	MOVE	A,MYHOME	;NO--PRINT OUT HOME
	SETZM	MESPC		;NO TRAILING SPACES
	PUSHJ	P,TAB		;TAB OUT
	PUSHJ	P,DULOUT	;TYPE USER NAME
	JRST	CRLF

;HERE WHEN OWNER IS SYS--TYPE SYS
HIGHER:	MOVSI	A,(SIXBIT /SYS/)
	PUSHJ	P,TAB		;TAB OUT AND SAY "SYS"
	PUSHJ	P,SIXBP		;TYPE OUT "SYS"
	JRST	CRLF		;AND AWAY WE GO
	SUBTTL	DISPLAY SELECTION -- PRINT DORMANT-SEGMENT STATUS

;CALL AS:	PUSHJ	P,DORMNT
DORMNT:	SETZM	HOMJOB
	SETOM	SEGFLG		;SET SEGMENT FLAG
	MOVEI	M,[ASCIZ /
Dormant segments:
Program	High(P)	Owner
/]				;PRE-LOAD 'M' WITH HEADING MESSAGE
	TLZ	F,FL.DEV	;HEADING OUTPUT SYNC FLAG
	MOVE	J,SEGPTR
DOR1:	SETZM	HOMJOB
	SKIPL	JS,@.STS	;SKIP IF SIGN(RUN) BIT SET JBTSTS
	SKIPN	@.PRG		;AND NAME NOT 0, DORMANT.
	JRST	DUNDOR		;SIGN NOT SET OR NAME 0, NEXT

	TLON	F,FL.DEV	;SKIP IF OUTPUT HEADING ALREADY
	PUSHJ	P,MSG		;NOT OUTPUT YET, DO SO NOW
	TLO	F,FL.DOR!FL.DEV
DORMN:	MOVE	A,@.PRG
	PUSHJ	P,SIXBP
	SKIPN	A,SYSTAP	;SEE IF "SYS:" NOT "DSK:"
	JRST	DORMN2		;DISK
	CAME	A,@.PPN		;CHECK LEV.C DEVICE
	CAMN	A,@.DEV		;CHECK LEV.D DEVICE
	JRST	[MOVSI	A,(SIXBIT /SYS/)
		 JRST	DORM2A]
	SKIPN	A,@.PPN
	MOVE	A,@.DEV
	JRST	DORM2A
DORMN2:	JUMPE	D,DORM76

DORM66:	MOVE	A,@.DEV
DORM67:;PUSHJ	P,TABSIX	;TYPE DEVICE NAME OUT
DORM76:	MOVE	A,@.PPN
DORM2A:	PUSHJ	P,HIGH01
DUNDOR:	AOBJN	J,DOR1		;ARE THERE ANY MORE SEGS. TO LOOK AT?

ENDDOR:	POPJ	P,		;RETURN****
	SUBTTL	DISPLAY SELECTION -- PRINT SYSTEM PERFORMANCE STATISTICS

; P014 MONITOR AND UP: ALL CONSTANTS RETURNED IN 'PAGES'
; OF 512 WORDS LONG,  USE   ASH AC,-11  TO CONVERT TO PAGES.
;CALL AS:	PUSHJ	P,GIVSTAT
GIVSTAT: PUSHJ	P,CRLF		;TYPE RETURN
	PUSHJ	P,USESW		;THEN DO USERS COMMAND
	SKIPN	CORMAX		;CAN WE SEE MEMORY STATISTICS?
	POPJ	P,		;NO, RETURN

; PRINT MEMORY AVAILABILITY (45.0)
;
; nK PHYSICAL MEMORY AVAILABLE (MONITOR = nK, USER AREA = nK)
;
	MOVE	N,USRMAX	;TABLE TO GET USER MEM SIZE
	GETTAB	N,		;GET THE TABLE
	SETZ	N,		;ERROR RETURN, SORRY.
        ASH     N,11            ;GET STUFF READY FOR ADD
        MOVEM   N,CORMAX        ;SAVE USER PAGES
        MOVE    N,XSYSSZ        ;GET SIZE OF MONITOR
        GETTAB   N,            ;GET TABLE
        SETZ    N,              ;COULD NOT GET IT
        ADD     N,CORMAX        ;GET TOTAL
	MOVEI	M,[ASCIZ/ Physical pages available (MONITOR = /]
	ASH	N,-11		;CONVERT TO P-CORE
	PUSHJ	P,DECMSG	;PUT OUT DEC NO FOLLOWED W/ MES
	MOVE	N,XSYSSZ	;GET SIZE OF MONITOR
	GETTAB	N,		;GET TABLE
	SETZ	N,		;COULD NOT GET IT.
	MOVEI	M,[ASCIZ /P, User Area = /]
	ASH	N,-11		;CONVERT TO P-CORE
	PUSHJ	P,DECMSG	;OUTPUT IT.
	MOVE	N,CORMAX
	ASH	N,-11		;CONVERT TO P-CORE
	PUSH	P,N		;SAVE N
	MOVEI	M,[ASCIZ /P)
/]
	PUSHJ	P,DECMSG
	POP	P,N		;RESTORE X
	MOVEI	M,[ASCIZ %Virt. memory used (TPU/TPA): %]
	MOVEM	N,TEMP		;SAVE CORMAX
	MOVE	N,CORUSE	;GET TOTAL CORE&SWAP PAGES USED
	MOVEM	N,TEMP1
	PUSHJ	P,MSGDEC
	MOVSI	A,(SIXBIT ./.)
	MOVE	N,TEMP
	PUSHJ	P,SIXDEC
	MOVEI	M,[ASCIZ / = /]
	MOVE	N,TEMP1
	PUSHJ	P,CMPCNT
	MOVEI	M,[ASCIZ /%
/]
	JRST	MSG
	SUBTTL	DISPLAY SELECTION -- PRINT OPEN FILE STATISTICS

;CALL AS:	PUSHJ	P,OPNFIL
OPNFIL:	TLZ	F,FL.DEV	;SINC WITH HEADING

OPNFI2:	SETZM	DBLOCK+1	;NO LOC...START FROM SCRATCH

;READ IN THE DEV NAME AND FIL NAM
DVPGLP:	MOVEI	C,1		;DEVICES BY LOCATION
	MOVEM	C,DBLOCK	;SET IN FUNCTION WORD
	MOVE	C,[LN.UDB,,DBLOCK]	;GET A DATA BLOCK
	CALLI	C,-24
	JRST	OPNFI2		;FAILURE. START FROM SCRATCH
	SKIPN	DBLOCK+1	;IF ZERO THEN END CHAIN
	POPJ	P,		;ALL GONE****
	MOVEI	D,DBLOCK+3	;SET UP D AS INDEX

	MOVE	B,DEVMOD(D)	;DEVMOD
	TRNE	B,600000
	TLNN	B,200000
	JRST	NXDSK
	MOVE	C,DEVBUF(D)
	MOVEM	C,SVMOD
	MOVE	C,DEVCHR(D)	;DEVCHR
	LDB	N,[POINT 7,C,6]
	MOVEM	N,SVJOB		;SAVE JOB NUMBER

;CHECK IF SINGLE JOB SELECTION THEN IF NOT SET IN JOBTBL
;THEN GO TO NEXT ENTRY
	SKIPE	NOHEAD		;IF SKIP THEN NO SING.JOB
	SKIPE	JOBTBL(N)	;SKIP IF INVALID
	JRST	.+2		;O.K.
	JRST	NXDSK		;BAD--QUITTING TIME

	MOVE	J,N
OPNDGD:	MOVE	A,DEVFIL(D)	;DEVFIL
	MOVEM	A,SVFIL
	MOVE	A,DEVEXT(D)	;DEVEXT
	HLLZS	A
	MOVEM	A,SVEXT
	MOVE	A,DEVPPN(D)	;DEVPPN
	MOVEM	A,SVPPN
	MOVE	A,SVPPN
	SKIPN	SVFIL		;NULL FILE NAME?
	JRST	NXDSK		;YES-IGNORE

;IF UFD DO NOT PRINT
	CAME	A,[1,,1]	;MFD DIRECTORY?
	JRST	NOTUFD		;NO-NOT
	MOVS	A,SVEXT
	CAIN	A,(SIXBIT /UFD/);UFD'S ARE IGNORED
	JRST	NXDSK		;IGNORE
;CHECK TO SEE IF ALREADY INSTALLED
NOTUFD:	MOVEI	A,DDBTBL
CHKDSK:	SKIPN	@A	;BLANK?
	JRST	RON	;YES-GO TO IT
	MOVE	B,SVJOB
	CAME	B,0(A)
	JRST	OKDSK
	MOVE	B,SVPPN
	CAME	B,1(A)
	JRST	OKDSK
	MOVE	B,SVFIL
	CAME	B,2(A)
	JRST	OKDSK
	MOVE	B,SVEXT
	CAMN	B,3(A)
	JRST	NXDSK	;FILE ALREADY GIVEN
OKDSK:	ADDI	A,4	;TO NEXT IN CHAIN
	JRST	CHKDSK
RON:	CAIL	A,EDDBTBL	;IS THE TABLE FULL ?
	JRST	RONBY	;YES, DONT ADD ANYTHING
	MOVEM	B,0(A)	;SAVE JOB #
	MOVE	B,SVPPN
	MOVEM	B,1(A)	;SAVE PPN
	MOVE	B,SVFIL
	MOVEM	B,2(A)	;SAVE FILE
	MOVE	B,SVEXT
	MOVEM	B,3(A)	;SAVE EXT
RONBY:	MOVEI	M,[ASCIZ /
/]
	SKIPN	NOHEAD		;SKIP=NO HEADIN
	MOVEI	M,[ASCIZ /
Open disk devices:
Job    File    Page  Mode Owner       Who
/]
	TLON	F,FL.DEV
	PUSHJ	P,MSG

;SET UP FIELD ROUTINE
	PUSHJ	P,CLRFLG	;CLEAR FIELD FLAGS
	MOVEI	CH,^D5		;JOB FIELD WIDTH
	PUSHJ	P,FIELD		;SET IT UP

	MOVE	N,SVJOB
	TRO	F,FR.OVR	;TENTATIVELY SET COLUMN OVERFLOW
	CAIGE	N,^D100		;WIDE JOB NO.?
	TRZ	F,FR.OVR	;NO-CLEAR
	PUSHJ	P,DECP2X	;AND PRINT
	MOVEI	CH,^D11		;FILE NAME FIELD
	PUSHJ	P,FIELD
	MOVE	A,SVFIL
	MOVE	BP,[POINT 6,A]
	MOVEI	B,6		;OUTPUT 6 CHARS
	ILDB	CH,BP
	ADDI	CH,40		;TO ASCII
	PUSHJ	P,TYO		;OUTPUT
	SOJG	B,.-3
	MOVEI	CH," "
	PUSHJ	P,TYO
NOWEXT:	MOVE	A,SVEXT
	MOVE	BP,[POINT 6,A]
	MOVEI	B,3		;OUTPUT 3 CHARS
	ILDB	CH,BP
	ADDI	CH,40
	PUSHJ	P,TYO
	SOJG	B,.-3
;PRINT OUT PAGE NUMBER
	MOVEI	CH,^D6
	PUSHJ	P,FIELD		;FIELD FOR PAGE COLUMN
	MOVE	N,DEVREL(D)	;DEVREL
	LSH	N,1	;NEEDED TO REMOVE BIT 0 FROM FILE
	LSH	N,-1	;BRING BACK WITH BIT REMOVED
        IDIVI   N,4
        SKIPE   N+1
        AOS     N
	PUSHJ	P,RDX10

;PRINT OUT I/O MODE (IN,OUT,IO)
	MOVEI	CH,^D5
	PUSHJ	P,FIELD		;FIELD FOR MODE COLUMN
	SETZ	M,
	MOVE	B,SVMOD
	TLNE	B,-1
	ORI	M,2
	TRNE	B,-1
	ORI	M,1
	MOVEI	M,[	ASCIZ /DUMP/
			ASCIZ /IN  /
			ASCIZ /OUT /
			ASCIZ /UPD /](M)
	PUSHJ	P,MSG		;TYPE OUT MODE

;PRINT OUT OWNER
	MOVEI	CH,^D12
	PUSHJ	P,FIELD
	MOVE	A,SVPPN		;OWNER
	SETZM	MESPC		;I WILL NOT SPACE
	PUSHJ	P,DULOUT
;PUT OUT THE ACTUAL USER NAME IF FILE FROM ANOTHER DIR.
	MOVE	A,@.PPN		;GET PPN OF THIS JOB
	CAMN	A,SVPPN		;IS IT THE SAME 
	JRST	.+5		;YES - PRINT NOTHING
	MOVEI	CH,^D12
	PUSHJ	P,FIELD
	SETZM	MESPC		;-1 = 12 CHR FIELD, 0=NO
	PUSHJ	P,DULOUT
	PUSHJ	P,CRLF
NXDSK:	MOVE	D,DEVSER(D)	;DEVSER
	JRST	DVPGLP
	SUBTTL	DISPLAY SELECTION -- PRINT BUSY DEVICE STATUS

;CALL AS:	PUSHJ	P,DEVQ
DEVQ:	SETZM	DSKDDB		;CLEAR COUNTER OF DISK DDBS
	TLZ	F,FL.DEV	;RESET HEADING SINC FLAG

;SET UP LOOP
DEV1:	MOVEI	JS,^D10000	;PROTECTION AGAINST INF.LOOP (SEE NXTDEV)
	SETZM	DBLOCK+1	;NOTHING CURRENTLY GOING

;MAIN DEV LOOKUP LOOP
DEVLP:	MOVEI	C,1
	MOVEM	C,DBLOCK	;FUNCTION=1: DEVICES BY LOC
	MOVE	C,[LN.UDB,,DBLOCK]
	CALLI	C,-24
	JRST	DEVEND		;FAILURE..START FROM SCRATCH
	SKIPN	DBLOCK+1	;IF ZERO THEN FOO
	JRST	DEVEND		;ALL DONE
	MOVEI	D,DBLOCK+3	;SETUP D AS PROPER INDEX
	MOVE	C,DEVMOD(D)
	MOVE	B,C
	MOVE	C,DEVLOG(D)	;GET LOGICAL NAME
	MOVEM	C,LOGNAM	;SAVE FOR LATER
	MOVE	A,DEVNAM(D)
	MOVE	C,DEVCHR(D)
	TLNE	B,DVDSK		;SEE IF DISK
	AOS	DSKDDB		;YES--COUNT IT
;CONDITIONS FOR DEV PRINTOUT
;1. IF DSK AND LOGICAL NAME=0 THEN IGNORE
;2. IF TTY THEN IGNORE

	TLNE	B,DVTTY		;IS TTY ?
	JRST	NXTDEV		;YES--FORGET

	TLNE	B,DVDSK		;IF SKIP THEN NOT DSK
	SKIPE	DEVLOG(D)	;SKIP IF IT'S NOT A LOG.NAME
	JRST	.+2		;O.K.
	JRST	NXTDEV		;ON TO THE NEW !!


	LDB	N,PJOBN		;GET JOB NUMBER

;CHECK FOR SELECT.JOB SEARCH
	SKIPE	NOHEAD		;IF SKIP THEN NO SNG.JOB
	SKIPE	JOBTBL(N)	;SKIP IF INVALID
	JRST	.+2
	JRST	NXTDEV		;BAD--NEXT DEVICE

	MOVEI	M,[ASCIZ /
Busy devices:
Job Device why     Logical Who
/]
	SKIPE	NOHEAD		;SKIP=NO HEADINGS
	JRST	DEVZA2		;OH WELL-SKIP HEADING
DEVZA1:	TLON	F,FL.DEV
	PUSHJ	P,MSG
	JRST	.+3
DEVZA2:	TLON	F,FL.DEV
	PUSHJ	P,CRLF		;ADJUST HEADINGS
REPEAT 0,<
	MOVEI	CH,"'"		;GET FLAG IN CASE DISK
	TLNE	B,DVDSK		;IS IT DISK?
	PUSHJ	P,TYO		;YES--OUTPUT FLAG FIRST
>;REPEATED OUT - INCLUDE TO PRINT ' FLAG IF USE IS USING DSK

;SET UP FIELD ROUTINE
	PUSHJ	P,CLRFLG	;CLEAR FIELD FLAGS
	MOVEI	CH,^D5		;WIDTH OF JOB FIELD
	PUSHJ	P,FIELD
	LDB	N,PJOBN
	MOVE	J,N		;SET UP J WITH JOB NO. OF DEV
	JUMPE	N,[MOVEI M,[ASCIZ /Det/]
		TRNN B,ASSCON	;SKIP IF 'Det' NOSKIP IF 'Rdy'
		MOVEI M,[ASCIZ /Avl/]
		PUSHJ P,MSG
		JRST AFTJPT]	;PRINT 'DET' INSTEAD OF JOB 0
	PUSHJ	P,DECP2X
AFTJPT:	MOVEI	CH,^D7		;WIDTH OF DEVNAME FIELD
	PUSHJ	P,FIELD		;SET FIELD UP
	PUSHJ	P,SIXBP		;TYPE DEV NAME
	JUMPE	J,DVCRLF	;ALL DONE IF JOB 0 (DET <DEV>)
DVWHY:	MOVEI	CH,^D8		;WIDTH OF WHY COLUMN
	PUSHJ	P,FIELD		;SET UP FIELD
	MOVEI	M,[ASCIZ /as/]
	TRNE	B,ASSCON
	PUSHJ	P,MSG
	TRNN	B,ASSPRG
	JRST	DVLOG
	MOVEI	CH,"+"
	TRNE	B,ASSCON
	PUSHJ	P,TYO
	MOVEI	M,[ASCIZ /init/]
	PUSHJ	P,MSG
DVLOG:	MOVEI	CH,^D8		;WIDTH OF LOGICAL COLUMN
	PUSHJ	P,FIELD
	SKIPE	A,LOGNAM	;NOSKIP IF LOGICAL NAME
	PUSHJ	P,SIXBP		;LOGICAL NAME--PRINT IT
DVUSNM:	MOVEI	CH,^D12		;USER NAME FIELD
	PUSHJ	P,FIELD
	MOVE	A,@.USRN1
	PUSHJ	P,SIXBP
	SKIPE	A,@.USRN2
	PUSHJ	P,SIXBP

DVCRLF:	PUSHJ	P,CRLF
NXTDEV:	SOJG	JS,DEVLP

DEVEND:	SKIPE	NOHEAD		;IF HEADINGS, RETURN
	JRST	DEVFIN		;GOODBYE

DEVZA6:	MOVEI	M,[ASCIZ /
No busy devices
/]
	TLZN	F,FL.DEV
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ / Disk devices opened
/]
	SKIPE	N,DSKDDB	;GET DISK DDB COUNT
	PUSHJ	P,DECMSG	;OUTPUT IT IF THERE ARE ANY
DEVFIN:	POPJ	P,		;RETURN****
	SUBTTL	DISPLAY SELECTION -- PRINT FILE STRUCTURE STATUS

;CALL AS:	PUSHJ	P,FS
FS:	TDZ	A,A
FS1:	SYSSTR	A,
	  JRST	FSFIN		;EXIT. IF UUO FAILURE (LEVEL-C)
	JUMPE	A,FSFIN		;EXIT. WHEN DONE
	TLON	F,FL.DEV	;TYPED THIS HEADING YET?
	PUSHJ	P,CRLF
	PUSHJ	P,SIXBP		;TYPE STRUCTURE NAME
	MOVEI	M,[ASCIZ /: /]
	PUSHJ	P,MSG
	SETZM	DLOC+1		;CLEAR OUT DSKCHR ANSWER AREA
	MOVE	B,[DLOC+1,,DLOC+2]  ;  ..
	BLT	B,DLOC+17	;  ..
	MOVEM	A,DLOC		;STORE F/S NAME
	MOVE	B,[20,,DLOC]	;SETUP DSKCHR POINTER
	DSKCHR	B,		;ASK THE SYSTEM ABOUT IT
	  JRST	FSL		;GIVE UP IF SYSTEM BALKS
	MOVE	N,DLOC+.STTAL	;GET FREE PAGE COUNT
	PUSHJ	P,RDX10
	MOVE	N,TOTUSE        ;GET THE MOUNT COUNT
	MOVEI	M,[ASCIZ / Pages free, /]
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ / users/]
	PUSHJ	P,MSG

; NOW, CHECK THE FOLLOWING BITS
; .UNNNI (1B4) - NO NEW ACCESSES
; .UNSWP (1B5) - SOFTWARE WRITE PROTECTED
; .UNFUS (1B6) - FILE UNSAFE
	MOVEI	M,[ASCIZ/ NO NEW ACCESSES/]
	TLNE	B,(.UNNNI)
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ/ SOFTWARE WRITE PROTECTED/]
	TLNE	B,(.UNSWP)
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ/ FILE UNSAFE/]
	TLNE	B,(.UNFUS)
	PUSHJ	P,MSG
FSL:	PUSHJ	P,CRLF		;GO TO NEW LINE
	JRST	FS1		;LOOP

FSFIN:	POPJ	P,		;RETURN..
	SUBTTL	DISPLAY SELECTION -- PRINT NON-DISK ERROR REPORT

;CALL AS:	PUSHJ	P,ERREPT
ERREPT:	TLZ	F,FL.DEV	;CLEAR TITLE FLAG
	MOVSI	D,-ERRTL1	;SETUP TABLE POINTER

ERRLP1:	MOVE	A,ERRTB1(D)	;GET NEXT GETTAB
	GETTAB	A,
	 SETZ	A,
	JUMPE	A,ERRLX1	;ZERO--EITHER NOT THERE OR NOT USED
	MOVEI	M,[ASCIZ /
/]
	TLON	F,FL.DEV	;SEE IF TITLE DONE YET
	PUSHJ	P,MSG		;OUTPUT TITLE
	MOVE	N,A		;SAVE COUNT
	SKIPGE	M,ERRTM1(D)	;GET MESSAGE
	JRST	ERRLA1		;JUMP IF OCTAL NUMBER
	PUSHJ	P,DECMSG	;OUTPUT DECIMAL NUMBER AND MESSAGE
	JRST	ERRLY1		;JUMP
ERRLA1:	PUSHJ	P,OCTLRH	;OUTPUT OCTAL NUMBER
	PUSHJ	P,MSG		;OUTPUT MESSAGE
ERRLY1:	PUSHJ	P,CRLF		;END LINE
ERRLX1:	AOBJN	D,ERRLP1	;LOOP BACK UNTIL DONE

;NOW, TYPE THE STATUS OF THE UNHAPPY BITS
; GET TAB TABLE 36,,12 RETURNS THE UNHAPPY BITS.
UNHRPT:	MOVSI	D,-UNHLEN	;SET UP (D) TO COUNT THRU UNHTAB
	MOVE	A,XUNHAP	;UNHAPPY GETTAB NUMBER
	GETTAB	A,		;GET THE TABLE
	 SETZ	A,		;ERROR, ZERO IS THE BITS.
UNHRP1:	HLRZ	B,UNHTAB(D)	;GET THE BIT FOR THIS MESSAGE
	TDNN	A,B		;DO THE BITS COMPARE?
	JRST	UNHRP2		;NO, CONTINUE THE SCAN
	MOVEI	M,[ASCIZ/
/]				;PREPARE TO TYPE HEADING(CR)
	TLON	F,FL.DEV	;DEVICE HEADING OUT YET?
	PUSHJ	P,MSG		;NO, TYPE C.R.
	HRRZ	M,UNHTAB(D)	;GET MESSAGE ADDRESS
	PUSHJ	P,MSG		;TYPE THE MESSAGE
	PUSHJ	P,CRLF		;TYPE CAR.RET
UNHRP2:	AOBJN	D,UNHRP1	;LOOP ON ALL BITS

ERRXIT:	POPJ	P,		;RETURN...
	SUBTTL	DATA AREA -- NON-DISK / UNHAPPY TABLES
ERRTB1:
	XWD	24,12
	XWD	25,12
	XWD	27,12
	XWD	30,12
	XWD	31,12
ERRTL1==.-ERRTB1

ERRTM1:
	[ASCIZ / user memory parity errors/]
	[ASCIZ / spurious memory parity errors/]
    1B0+[ASCIZ / address of last memory parity error/]
    1B0+[ASCIZ / contents of last memory parity error/]
    1B0+[ASCIZ / PC of last memory parity error/]

;UNHAPPY BIT TABLES
;UNHTAB CONTAINS A LIST OF BITS IN THE LH AND THE MESSAGE ADDR
;IN THE RH.  USED FOR TYPING SYSTEM UNHAPPY ERRORS.
UNHTAB:	XWD	20,[ASCIZ/No SET OPR done -- no OPR tty/]
	XWD	40,[ASCIZ/Swap Read errors, Parity errors or Disk Off-line/]
	XWD	100,[ASCIZ/Error in Detached Job/]
	XWD	200,[ASCIZ/Remote Peripheral 620 has crashed/]
	XWD	400,[ASCIZ/OPR message on the CTY or CHKPNT terminated/]
	XWD	1000,[ASCstem finished Auto-Restart procedures/]
	XWD	2000,[ASCIZ/There is a problem with a device/]
UNHLEN==.-UNHTAB
IFN FTRPS,<
	SUBTTL	DISPLAY SELECTON -- RPS STATISTICS

GIVRPS:	MOVE	A,SAVLIC	;GET LICENSE BITS
	SETLIC	A,		;RESTORE ORIGINAL LICENSE
	 JFCL			;IGNORE ERROR
; WE NOW HAVE "WC" LICENSE BACK, PROCEED.
	HRLI	N,RPSFLG	;GET STATE WORD FROM 620
	CALLI	N,-54		;AS SO
	JRST	[MOVEI M,[ASCIZ /
Dispatch base is down
/]
		CAIN N,3	;ERROR 3 -- BASE DOWN?
		PUSHJ P,MSG	;YES, SAY SO
		JRST LASRPS]	;ITS DOWN .. RETURN
; CHECK FOR PROPER LICENSE. GETTAB XJBLIC RETURNS:
; LH=FILE LICENSE, RH=JOB LICENSE
; IF SYSTAT.SHR HAS SY OR OP LICENSE (LHBITS 100000+40000)
; THEN ALLOW DISPLAY. IF USER HAS SY OR OP OR WC LICENSE,
; THEN ALLOW THE DISPLAY.
	HRRO	A,XJBLIC	;LICENSE GETTAB
	GETTAB	A,		;GET THE TABLE
	 SETZ	A,		;MISSED.
	TDNE	A,[140000,,540000] ;DOES HE OR WE HAVE THE LIC ?
	JRST	GIVRP1		;ITS OKAY
	POPJ	P,		;NOT, RETURN
GIVRP1:	MOVEI	M,[ASCIZ /
Dispatch base is /]
	PUSHJ	P,MSG		;SAY WHAT BASE IS DOING
	MOVE	M,[
		[ASCIZ /up /]		;0 - UP
		[ASCIZ /shut /]		;1 - SHUT
		[ASCIZ /hanging /]	;2 - HANGING
		[ASCIZ /reloading /]	;3 - RELOADING
		[ASCIZ /crashing  /]](N)
	PUSHJ	P,MSG		;SAY SO
	MOVEI	M,[ASCIZ /(state /]
	PUSH	P,N		;SAVE N
	PUSHJ	P,MSGDEC	;TYPE MSG A DEC NO.
	MOVEI	CH,")"
	PUSHJ	P,TYO		;TYPE CLOSING )
	POP	P,N		;GET BACK N
	CAILE	N,1		;ANYTHING BUT DOWN ?
NO620:	JRST	[PUSHJ P,CRLF
		JRST LASRPS]	;RETURN....
	HRLI	N,RPSVER	;GET VERSION OF CODE
	CALLI	N,-54		;AS SO
	JRST	NO620		;NO 620...
	MOVEI	M,[ASCIZ/ base code version /]
	PUSHJ	P,MSGOCT	;TYPE VERSION NUMBER
	HRLI	N,RPSPFSR	;POWER FAILSAFE RESTART COUNT
	CALLI	N,-54
	JRST	NO620		;FAILS...
	MOVEI	M,[ASCIZ/
PFSR /]
	PUSHJ	P,MSGDEC
	HRLI	N,RPSSTCT
	CALLI	N,-54
	JRST	NO620
	MOVEI	M,[ASCIZ /, STCT /]
	PUSHJ	P,MSGDEC
	HRLI	N,RPSCRCT
	CALLI	N,-54
	JRST	NO620
	MOVEI	M,[ASCIZ /, CRCT /]
	PUSHJ	P,MSGDEC
	HRLI	N,RPSDUMC
	CALLI	N,-54
	JRST	NO620
	MOVEI	M,[ASCIZ /, DUMCT /]
	PUSHJ	P,MSGDEC
	HRLI	N,RPSPRK
	CALLI	N,-54
	JRST	NO620
	MOVEI	M,[ASCIZ/, PEKR /]
	PUSHJ	P,MSGDEC
	HRLI	N,RPSPBK
	CALLI	N,-54
	JRST	NO620
	MOVEI	M,[ASCIZ /, PEDB /]
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ /
Last restart adrs: /]
	PUSHJ	P,MSG
	MOVEI	B,RPSSTK	;GET STACK ADR
STKLOP:	HRLZ	N,B		;GET NEXT ADR TO PRINT
	CALLI	N,-54		;GET IT
	JRST	NO620		;FAILED....
	PUSHJ	P,OCTLRH	;TYPE ADR
	MOVEI	CH,"*"		;PREPARE TO TAG IT
	HRLZI	N,RPSTRT	;GET ADR
	CALLI	N,-54
	JRST	NO620
	CAMN	N,B		;THE SAME ?
	PUSHJ	P,TYO		;YES, PRINT THE *
	ADDI	B,1
	CAIN	B,RPSTRT-1	;ARE WE AT LAST ADR TO LIST?
	JRST	NO620		;DONE .. AT FINISH
	PUSHJ	P,SPACE
	JRST	STKLOP		;LOOP
	PUSHJ	P,CRLF

; HERE TO REDUCE LICENSE FROM WC BACK TO NORMAL SUB-HUMAN
LASRPS:	MOVE	A,SAVLIC	;GET LICENSE BITS
	TLZ	A,%WCLIC	;REMOVE "WC" LICENSE
	SETLIC	A,		;REDUCE LICENSE BACK
	 JFCL			;IGNORE ERROR
	POPJ	P,
>
	SUBTTL	DISPLAY SELECTION -- PRINT SWAPPING STATISTICS

;CALL AS:	PUSHJ	P,SW
SW:	MOVEI M,[ASCIZ \
Swapping devices:
Unit	Reads	Writes	Used/Avail(P)
\]
SWLPZ:	SETZM	DBLOCK+1	;ENTRY FROM PSP

;LOOP TO READ IN INFORMATION
SWLP0:	MOVEI	A,2		;FUNCTION NO. 2
	MOVEM	A,DBLOCK
	MOVE	A,[DBLOCK+2,,DBLOCK+LN.UDB-1]
	SETZM	DBLOCK+2	;ZERO OUT DATA BLOCK
	BLT	A,DBLOCK+LN.UDB-1	; BEFORE USE
	MOVE	A,[LN.UDB,,DBLOCK]
	SYSDVF	A,		;GET MONITOR DATA BLOCK
	JRST	ESW		;TOO BAD
	SKIPN	DEVIOS+DBLOCK	;IS DEVIOS = 0 ?
	JRST	ESW		;YES, NO STATUS FOR THIS LUSER
	SKIPN	DBLOCK+1	;END OF CHAIN ?
	JRST	ESW		;YES
	SKIPE	PSPSW		;WORKING ON A PSP?
	JRST	SWLP2		;YES - SKIP MESSAGE PRINT.
	TLNN	F,FL.LP1	;IF FIRST TIME THROUGH,
	PUSHJ	P,MSG		;PRINT HEADING.
	TLO	F,FL.LP1	;INDICATE HEADING DONE.
SWLP2:	MOVE	A,DBLOCK+1	;MAKE DSKCHR BLOCK FROM DEVNAME
	MOVEM	A,DSKBLK
	MOVE	A,[DSKBKL,,DSKBLK]
	DSKCHR	A,		;GET DEV CHARACTERISTICS
	SETZM	DSKBLK+.STNAM	;FORGET STRUCTURE NAME ON FAIL
	MOVEI	D,DBLOCK+3	;INDEXED POINTER
IFN FTSWPER,<
;GETUDB NEEDS THIS CONSTANT SET BECAUSE OF WAY DISK
;ERROR REPORTING WORKS WITH DISK
	MOVEM	D,UNIBLK	;THIS CONSTANT MUST BE SET
>; ASSEMBLE ABOVE IF SWAPPER ERROR REPORTING

;CHECK TO SEE IF THIS IS ON THE SWAPPER
	MOVE	A,UNIP4S(D)
	ANDI	A,MSKK4S	;MASK IT OUT
	JUMPE	A,SWLP0		;UNIT NOT ON SWAPPER
	TLZ	F,FL.DEV	;RESET HEADING SWITCH

SWLP1:	SKIPE	PSPSW		;WORKING ON A PSP??
	JRST	PSPERC		;YES - SPCL ENTRY
;	MOVE A,UNINAM(D)
;	PUSHJ P,SIXBP
;	PUSHJ P,TAB
;	MOVE A,UNIICT(D)	;GET # OF READS (BLOCKS).
;	ASH	A,-2		;CONVERT TO PAGES.
;	SUB	A,UNIMRC(D)	;SUBTRACT OUT MONITOR READS.
;	MOVE N,A
;	PUSHJ P,DECTAB
;	MOVE A,UNIOCT(D)	;GET # OF WRITES.
;	ASH	A,-2		;CONVERT TO PAGES.
;	SUB	A,UNIMWC(D)	;SUBTRACT OUT MONITOR WRITES.
;	MOVE N,A
;	PUSHJ P,RDX10
;	MOVE A,UNIFKS(D)
;	MOVEM A,N
;	MOVE A,UNIP4S(D)
;	ANDI A,MSKK4S
;	MOVEM A,TEMP
;	SUBB A,N
;	MOVEI M,[ASCIZ /	/]
;	PUSHJ P,PRPCNT
;	JRST	SWLP0		;AND CONTINUE

SWLPY:	IFN FTSWPER,<
;PRINT ERRORS ON THE SWAPPING UNIT -- SAME DDB AS DISK BLOCK
>; ASSEMBLE ABOVE FOR SWAPPERR ERROR REPORTING
	JRST	SWLP0		;NEXT PLEASE

;WORKING ON PSP--FORGET DISK UNITS AND SETTLE ON FHA
PSPERC:	MOVE	A,UNIHID(D)
	MOVEM	A,PSP2		;SAVE PACK I.D.
	MOVE	A,UNINAM(D)
	MOVEM	A,PSP1		;SAVE UNIT NAME
	MOVE	A,UNILOG(D)	;GET LOGICAL NAME
	MOVEM	A,PSP3		;SAVE NAME
	MOVE	A,DSKBLK+.STNAM	;GET NAME OF STR THIS IS IN
	JUMPE	A,SWLPY		;IF ZERO IT'S A SWAPPER
	JRST	SWLP0		;NONZERO-FORGET IT
;HERE WHEN THROUGH WITH SWPPER PUTTER
ESW:	TLZE	F,FL.LP1	;RESET HEADING SWITCH.
	PUSHJ	P,CRLF		;END OF SWAPPING STATISTICS

;HERE TO CHECK FOR SWAP READ ERRORS
SPERS:	MOVE A,XSWPER
	GETTAB	A,
	 SETZ	A,
	JUMPE A,SWFIN
	MOVE D,A
	MOVEI M,[ASCIZ /
Swap errors: /]
	PUSHJ P,MSG
	HLRZ N,D
	PUSHJ P,DECTAB
	MOVEI M,[ASCIZ / CHK/]
	TRZE D,IOIMPM
	PUSHJ P,MSG
	MOVEI M,[ASCIZ / DEV/]
	TRZE D,IODERR
	PUSHJ P,MSG
	MOVEI M,[ASCIZ / DAT/]
	TRZE D,IODTER
	PUSHJ P,MSG
	MOVEI M,[ASCIZ /   Pages Lost: /]
	HRRZ N,D
	PUSHJ P,MSGDEC
	PUSHJ P,CRLF

SWFIN:	POPJ	P,		;RETURN****


;OFFSET IN A GETS CONTENTS INTO N

GETUDB:	ADD A,UNIBLK
	MOVE	A,(A)
	MOVE N,A
	POPJ P,
;ROUTINE TO TYPE OUT MESSAGES FROM BITTAB
; CALL WITH C=INDEX INTO BITTAB
PRTBIT:	MOVEI	M,BITTAB(C)	;GET MESSAGE
	PUSHJ	P,MSG		;TYPE IT OUT
	PJRST	SPACE		;TYPE SPACE, RETURN****

;BITTAB CONTAINS A LIST OF ASCIZ BITS FROM THE UNIDES
;WORD IN THE UDB (DSKCHR AC RETURNS UNIDES)
; ASCIZ 0 FROM BITTAB IS BIT 0 = 1 IN UNIDES
; ASCIZ 1 FROM BITTAB IS BIT 1 = 1 IN UNIDES
; BITMSK= THE MASK OF BITS **TO BE REMOVED, IE, TLZD**
BITTAB:	ASCIZ	/B 0/	;B 0 = ?
	ASCIZ	/OFL/	;B 1 - UNIT OFF LINE
	ASCIZ	/HWP/	;B 2 - UNIT HARDWARE WRITE-PROTECTED
	ASCIZ	/B 3/	;B 3 = ?
	ASCIZ	/NNA/	;B 4 = NO NEW ACCESSES
	ASCIZ	/SWP/	;B 5 = SOFTWARE WRITE PROTECTED
	ASCIZ	/UNS/ ;B 6 = FILE UNSAFE(ALWAYS ON?)
	ASCIZ	/B 7/
	ASCIZ	/B 8/
	ASCIZ	/MSB/	;BIT 9 = MULTIPLE SAT BLOCKS
	ASCIZ	/B10/
BITTL==.-BITTAB

BITMSK==77	;CLEAR 77 LEAVING BITS IN 777700,,0

; UDTAB IS THE TABLE USED TO PRINT THE I/O COUNTS FOR EACH UNIT
; FORMAT IS:
; XWD A,B
; B - UDB(B) IS INITIAL COUNT TO PRINT
; A - 0, IGNORED
; A POSITIVE - ADD UDB(A) TO UDB(B) BEFORE PRINTING
; A NEGATIVE - SUBTRACT UDB(A) FROM UDB(B) BEFORE PRINTING
UDTAB:	XWD 0,UNIBRC
	XWD 0,UNIBWC
	XWD 0,UNIDRC
	XWD 0,UNIDWC
	XWD 0,UNIMRC
	XWD 0,UNIMWC
	XWD UNIMSC,UNIUSC
UDTBL==.-UDTAB

; ROUTINES FOR DISK ERROR REPORTING
; D%DECN - AC 'M' HAS MESSAGE, 'N' HAS DECIMAL NO. TO OUTPUT
; D%OCTN - AC 'M' HAS MESSAGE, 'N' HAS OCTAL NO. TO OUTPUT
; IF N = 0 THEN DO NO ACTION, ELSE CALL MSG, RDXN, RETURN
D%DECN:	JUMPE	N,CPOPJ		;IF ZERO RETURN
	PUSHJ	P,PSPCK		;CHECK TO PRINT OUT UNIT NAME ON PSP
	PUSHJ	P,MSG		;TYPE OUT MESSAGE IN (M)
	PJRST	RDX10		;TYPE NUMBER RETURN****

D%OCTN:	JUMPE	N,CPOPJ		;IF ZERO RETURN
	PUSHJ	P,PSPCK		;CHECK TO PRINT OUT UNIT NAME ON PSP
	PUSHJ	P,MSG		;TYPE OUT MESSAGE IN (M)
	PJRST	RDX8		;TYPE NUMBER RETURN****

; D%MSGN - AC 'M' HAS MESSAGE, 'N' HAS PRINT FLAG
; IF N = 0 THEN DO NO ACTION, ELSE CALL MSG AND RETURN
D%MSGN:	JUMPE	N,CPOPJ		;IF ZERO NO ACTION
	PUSHJ	P,PSPCK		;CHECK FOR PSP COMMAND
	PJRST	MSG		;GO TO MSG, RETURN

; D%UNCK - AC 'N' HAS UNIT NO. OF CURRENT UDB WE ARE
;	LOOKING AT, AC 'N1' HAS UNIT WHICH WE WANT
;	TO USE.  THIS IS FOR A 'GOSUB' TABLE WHICH IS
;	FOR A PARTICULAR UNIT. IF N=N1 THEN THE TABLE IS
;	CONTINUED, IF N#N1 THEN A 'JRST FLUN4D' IS DONE,
;	CAUSING THE GOSUB TABLE TO BE TERMINATED.
D%UNCK:	CAME	N,N1		;ARE THEY THE SAME ?
	JRST	FLUN4D		;NO, TERMINATE GOSUB TABLE
	POPJ	P,		;THE SAME, CONTINUE TABLE

; D%MSG - SAME AS MSG, BUT CALL PSPCK FIRST
D%MSG:	PUSHJ	P,PSPCK		;CHECK PSP COMMAND
	PJRST	MSG		;THEN OUTPUT MESSAGE

; D%MSGD - SAME AS MSGDEC, BUT CALL PSPCK FIRST
; D%MSGO - SAME AS MSGOCT, BUT CALL PSPCK FIRST
D%MSGD:	PUSHJ	P,PSPCK		;CHECK PSP COMMND
	PJRST	MSGDEC		;THEN OUTPUT MESSAGE, NO.
D%MSGO:	PUSHJ	P,PSPCK		;CHECK PSP COMMAND
	PJRST	MSGOCT		;THEN OUT MESSAGE, NO.
IFG FTAPR+FTVERS-1,<SUBTTL	GIVE SYSTAT VERSION AND APR SERIAL NUMBER>
IFG FTAPR-FTVERS,<SUBTTL	GIVE APR SERIAL NUMBER>
IFG FTVERS-FTAPR,<SUBTTL	GIVE SYSTAT VERSION>

IFG FTVERS,<
;GIVE SYSTAT VERSION NUMBER
GIVER:	MOVEI	M,[ASCIZ /Systat /]
	PUSHJ	P,MSG
	HLRZ	N,JOBVER
	ANDI	N,777		;GET TYMSHARE SPEC
	PUSHJ	P,OCTLRH
	MOVEI	CH,"."
	PUSHJ	P,TYO
	MOVE	N,JOBVER
	ANDI	N,777		;GET TYMSHARE RELEASE
	PUSHJ	P,OCTLRH
	MOVEI	CH,"-"
	PUSHJ	P,TYO
	MOVE	N,JOBVER
	LSH	N,-^D3*^D9
	ANDI	N,777
	PUSHJ	P,OCTLRH
	MOVEI	CH,"."
	PUSHJ	P,TYO
	MOVE	N,JOBVER
	LSH	N,-^D9
	ANDI	N,777
	PUSHJ	P,OCTLRH
	PUSHJ	P,CRLF
	POPJ	P,
>

IFG FTAPR,<
;GIVE APR SERIAL NUMBER
GIVAPR:	MOVEI	M,[ASCIZ /APR serial no. /]
	PUSHJ	P,MSG
	MOVE	N,XAPRSN	;GET APR SERIAL NO.
	GETTAB	N,
	JRST	[MOVEI M,[ASCIZ /**CANT FIND OUT**/]
		PUSHJ P,MSG
		POPJ P,]
	PUSHJ	P,RDX10
	PUSHJ	P,CRLF
	POPJ	P,
>
	SUBTTL	/LPT AND /EVERY SWITCHS

LPTOPN:	TLZ	F,FL.RPT	;SET REPEAT FLAG

SYSINI:	INIT	TTY,400000
	SIXBIT	/LPT/
	TYOB,,0
	SKIPA
	JRST	SYSIN1
	TLON	F,FL.RPT
	OUTSTR	[ASCIZ /LPT busy--waiting
/]
	MOVEI	A,5
	SLEEP	A,
	JRST	SYSINI

SYSIN1:	MOVEI	A,TTYBUF	;GET ADR OF TTY BUFFERS
	EXCH	A,JOBFF		;FAKE OUT THE MONITOR
	OUTBUF	TTY,1		;1 OUTPUT BUFFER
	MOVEM	A,JOBFF		;AND RESET JOBFF
	MOVEI	A,^D130		;LOL FOR PRINTER
	MOVEM	A,LINLOL	;SAVE LINE LENGTH
	POPJ	P,		;RETURN FROM SWITCH CALL ROUTINE
;***********************************
;*   TABLES AND CONSTANTS          *
;***********************************

XUNHAP:	XWD	36,12	;UNHAPPY BITS FOR SYSTEM...
XSYSSZ:	XWD	12,11	;HIGHEST LOCATION IN MONITOR
XMEMSZ:	XWD	23,12	;SIZE OF PHYSICAL MEMORY IN WORDS
XSWPER:	XWD	5,13	;SWAP READ/WRITE ERRORS
XAPRSN:	XWD	20,11	;APR SERIAL NUMBER
XJBLIC:	XWD	0,-20	;JBTLIC TABLE
USRMAX: XWD     37,12    ;AVAILABLE USER MEMORY
;MORE MONITOR INTERFACE

PJOBN:	POINT 7,C,6
DSKLEV:	POINT	3,STATES,9
   o8‘