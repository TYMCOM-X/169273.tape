


  
procedure SOFT
%
  SOFT is an interactive procedure used to enter and maintain Transmittal, 
  Product, and ITSR information in the SOFTWARE data base.

  To compile, SOFT requires the following texts for the indicated macros
  and functions:
        TSR.FUNCTIONS   for RECORD.CUR.TSR, TYPE.VALID.TSR.CLASSES,
                            TYPE.SHORT.TSR, TYPE.LONG.TSR, TYPE.TSR.DESC,
                            ACCEPT.TSR.SPECS, GET.UNIQUE.TSR, and FINISH.TSR;
        TRANS.FUNCTIONS for RECORD.CUR.TRANS, TYPE.SHORT.TRANS,
                            TYPE.LONG.TRANS, ACCEPT.TRANS.SPECS, and
                            GET.UNIQUE.TRANS;
        PRODUCT.FUNCTIONS for RECORD.CUR.PROD, SHORT.PRODUCT.LINE,
                            TYPE.FULL.PRODUCT, TYPE.PROD.DESC, 
                            ACCEPT.PROD.SPECS, and GET.UNIQUE.PROD;
        SPEC.PARSER     for BREAK.UP.SPEC.
  For descriptions of the macros and functions, the fields they require, and
  how they are used - see the appropriate text.

  To execute, SOFT requires the following compiled procedures:
        MOD.PROD,
        MOD.TRANS,
        MOD.TSR.
  For descriptions of the procedures and what they require - see the texts of
  the same name.
%

begin
controls for relation concurrent update

controls for procedure separator @cr  %allows commas in versions and desc's%

fields COMMAND.LINE      as '80c'      % Command input Line %
         with prompt ">> ",
       PARAM.NO          as '2n',      % Parameter Number, (array index) %
       FOUND.FLAG        as 'c',       % Instance Found Flag %
       YES.NO            as '3c',      % Yes or No Field %
       CURRENT.MODE      as '15c',     % Current info type in use %

       %  Fields used by GET.UNIQUE.whatevers  %
       FOUND.COUNT       as '3n',      % Number of Instances Found %
       FIRST.NAME.FOUND  as '20c',     % First Product Name Found %
       FIRST.NUM.FOUND   as '8z',      % First ITSR Number Found %
       FIRST.VERSION.FOUND same as PROD.VERSION,
       FIRST.OP.SYS.FOUND same as OP.SYS,
       FIRST.RUN.DIRECTORY.FOUND same as RUN.DIRECTORY,
       FIRST.TRANS.NO.FOUND same as TRANS.NO,

       %  Fields used by ACCEPT.whatever.SPECS  %
       PROD.SPEC         as '40c',     % Product Specification %
       TSR.SPEC          as '30c',     % TSR Specification, Number/Name %
       TRANS.SPEC        as '40c',     % Transmittal Specification %
       ITEM              as '30c',     % An Item of a Specification Line %
       I.QUOTE           as 'c',       % An Item's Quote Indicator %
       SPEC.STATUS       as '-nn',     % Status returned form parsing a Spec %

       % Fields used by ENTER.whatevers %
       TSR.NUM.ENTERED   as '10c',     % TSR Number Entered %
       TRANS.NO.ENTERED  as '10c',     % Transmittal Number Entered %
       DEF.PROGRAMMER same as PROGRAMMER, % Default Programmer %
       DEF.MANAGER same as MANAGER,    % Default Manager %
       DEF.SOURCE.LOCATION same as SOURCE.LOCATION,  % Default Source %
       DEF.UNIT same as UNIT,          % Default Unit %
       DEF.SUPPORT.CLASS same as SUPPORT.CLASS, % Default Support Class %
       DEF.PROD.COMMENT same as PROD.COMMENT, % Default Product Comment %
       DEF.PROD.DOC same as PROD.DOC,  % Default Product Documentation %

       % Fields used by the macro BREAK.UP.SPEC.  For more information %
       % see the text 'SPEC.PARSER'.                                   %
       SYMBOL.INDEX      as 'nn',
       PARAM             as '40c',
       PARAM.INDEX       as 'nn',
       SPEC.INDEX        as 'nnn',
       QUOTE.FLAG        as 'c',
       LEN.SPEC          as 'nnn',
       CHAR              as 'c'

constant MAX.TRANS.SPECS = 4           % Maximum Number of Items in a      %
                                       %   Transmittal  Specification.     %
constant MAX.PROD.SPECS = 4            % Maximum Number of Items in a      %
                                       %   Product Specification.          %
constant MAX.TSR.SPECS = 4             % Maximum Number of Items in a ITSR %
                                       %   Specification.                  %
constant MAX.CMD.ITEMS = 6             % Maximum Number of items in a      %
                                       %   Command Line.                   %

array COMMAND.ARRAY [1 to MAX.CMD.ITEMS]
  data ITEM, I.QUOTE

array TSR.ARRAY [1 to MAX.TSR.SPECS]   % The parsed items of an ITSR Spec. %
  data ITEM, I.QUOTE

array PROD.ARRAY [1 to MAX.PROD.SPECS]  % The parsed items of a Prod. Spec. %
  data ITEM, I.QUOTE

array TRANS.ARRAY [1 to MAX.TRANS.SPECS]  % The parsed items of a Trans. Spec%
  data ITEM, I.QUOTE

relation TEMP.DESC is      % Temporary Description, used in modifications %
  key COUNTER
  data LINE

relation PRODUCT.NAMED is    % List of products entered in one ITSR %
  key PROD.NAME,
      OP.SYS
  data PROD.VERSION,
      RUN.DIRECTORY

source INPUT.COMMAND from terminal free form
  separator "#"            % Separator changed to allow commas %
  input COMMAND.LINE

macro ACCEPT.YES.NO is              % Accepts a yes/no responce, must be %
  begin

  accept YES.NO                     % default or cr = no.                %
  if substr(YES.NO,1,1) = "Y" or "y"
    then let YES.NO = "Y"
    else let YES.NO = "N"
  end
end.macro

include text 'SPEC.PARSER'             %contains macro BREAK.UP.SPEC%
include text "PRODUCT.FUNCTIONS"
include text "TRANS.FUNCTIONS"
include text "TSR.FUNCTIONS"


function USE.CURRENT.AND.SHUFFLE
  % If the second parameter in the command line is quoted or is not    %
  % PRODuct, PROGrammer, Itsr, TSr, or TRansmittal then this function  %
  % will insert the current information mode into the command array.   %
  begin

  let PARAM.NO = MAX.CMD.ITEMS
  while PARAM.NO gt 2 do
    begin
    let ITEM[PARAM.NO] of COMMAND.ARRAY = ITEM[PARAM.NO-1] of COMMAND.ARRAY
    let I.QUOTE[PARAM.NO] of COMMAND.ARRAY=I.QUOTE[PARAM.NO-1] of COMMAND.ARRAY
    let PARAM.NO = PARAM.NO - 1
    end
  % for consistency we'll also do... %
  let ITEM[2] of COMMAND.ARRAY = CURRENT.MODE
  let I.QUOTE[2] of COMMAND.ARRAY = "N"
  end
%end function use current and shuffle %


macro PARSE.COMMAND.LINE is 
  %  The items in the input command line are separated and stored in the %
  % command array.  The current information mode is determined.  Called  %
  % by the mainline.                                                     %
  begin
  % Parse the Command Line into Items %
  BREAK.UP.SPEC(COMMAND.LINE,COMMAND.ARRAY,ITEM,I.QUOTE,1,
                MAX.CMD.ITEMS,SPEC.STATUS)
  % Check for Info Type or Use Current Mode %
  if I.QUOTE[2] of COMMAND.ARRAY = "Y"
    then USE.CURRENT.AND.SHUFFLE
    else conditional on ITEM[2] of COMMAND.ARRAY
         begin
         "               ": nothing
         "I" or "IT" or "ITS" or "ITSR" or "ITSRS" or "TS" or "TSR" or "TSRS":
               let CURRENT.MODE = "TSR"
         "PROD" or"PRODU" or "PRODUC" or "PRODUCT" or "PRODUCTS":  
               let CURRENT.MODE = "PRODUCT"
         "PROG" or "PROGR" or "PROGRA" or "PROGRAM" or "PROGRAMM" or
           "PROGRAMME" or "PROGRAMMER" or "PROGRAMMERS":
               let CURRENT.MODE = "PROGRAMMER"
         "TR" or "TRA" or "TRAN" or "TRANS" or "TRANSM" or "TRANSMI" or
           "TRANSMIT" or "TRANSMITT" or "TRANSMITTA" or "TRANSMITTAL" or
           "TRANSMITTALS": let CURRENT.MODE = "TRANSMITTAL"
         end
         else USE.CURRENT.AND.SHUFFLE

  end % macro...is...begin %
end.macro  % Parse Command Line %


macro TYPE.VALID.OP.SYS is
  % A message that can be used when an invalid OP.SYS is entered. %
  begin
  type "OP.SYS must be 'IX' or 'X' or 'T20' or '370' ",@cr
  end
end.macro


macro TYPE.NO.MODE is
  % An error message displayed by the mainline if a user has not include %
  % an information in the current or any previous command.               %
  begin

  type "There is not a valid information type in your command and no", @cr,
       "current type known.  Use 'Help' for more assistance.", @cr
  end
end.macro


macro RECORD.CUR.PROG is        % record info from current PROGRAMMER.LIST %
  begin

  move PROGRAMMER to C.PROGRAMMER
  end
end.macro


function GET.PRODUCT.SPECS 
  %  The key values are taken from the command array if they are there %
  % or from the current product values.                                %
  begin

  if ITEM[3] of COMMAND.ARRAY eq default
      and I.QUOTE[3] of COMMAND.ARRAY ne "Y"
    then begin
         move C.PROD.NAME to PROD.NAME
         move C.PROD.VERSION to PROD.VERSION
         move C.OP.SYS to OP.SYS
         move C.RUN.DIRECTORY to RUN.DIRECTORY
         end
    else begin
         move ITEM[3] of COMMAND.ARRAY to PROD.NAME
         move ITEM[4] of COMMAND.ARRAY to PROD.VERSION
         move ITEM[5] of COMMAND.ARRAY to OP.SYS
         move ITEM[6] of COMMAND.ARRAY to RUN.DIRECTORY
         end
  end
% end function get product specs %


function GET.TSR.SPECS 
  %  The key values are taken from the command array if they are there %
  % or from the current itsr values.                                   %
  begin

  if ITEM[3] of COMMAND.ARRAY = default
    then begin
         move C.TSR.NUM to TSR.NUM
         move C.PROD.NAME to PROD.NAME
         move C.PROD.VERSION to PROD.VERSION
         move C.OP.SYS to OP.SYS
         move C.RUN.DIRECTORY to RUN.DIRECTORY
         end
    else if ITEM[3] of COMMAND.ARRAY is TSR.NUM
           then begin
                move ITEM[3] of COMMAND.ARRAY as TSR.NUM to TSR.NUM
                move ITEM[4] of COMMAND.ARRAY to PROD.NAME
                move ITEM[5] of COMMAND.ARRAY to OP.SYS
                move ITEM[6] of COMMAND.ARRAY to RUN.DIRECTORY
                end
           else begin
                move default to TSR.NUM
                move ITEM[3] of COMMAND.ARRAY to PROD.NAME
                move ITEM[4] of COMMAND.ARRAY to OP.SYS
                move ITEM[5] of COMMAND.ARRAY to RUN.DIRECTORY
                end
  end
% end function get tsr specs %


function GET.PROG.SPECS 
  %  The key values are taken from the command array if they are there %
  % or from the current programmer values.                             %
  begin

  if ITEM[3] of COMMAND.ARRAY = default
    then begin
         move C.PROGRAMMER to PROGRAMMER
         move default to FIRST.NAME, LAST.NAME
         end
    else if ITEM[4] of COMMAND.ARRAY = default
           then begin
                move ITEM[3] of COMMAND.ARRAY as '4c' to PROGRAMMER
                move default to FIRST.NAME, LAST.NAME
                end
           else begin
                move default to PROGRAMMER
                move ITEM[3] of COMMAND.ARRAY to FIRST.NAME
                move ITEM[4] of COMMAND.ARRAY to LAST.NAME
                end
  end
% end function get prod specs %


function GET.TRANS.SPECS 
  %  The key values are taken from the command array if they are there %
  % or from the current transmittal values.                            %
  begin

  if ITEM[3] of COMMAND.ARRAY = default
    then begin
         move C.TRANS.NO to TRANS.NO
         move C.PROD.NAME to PROD.NAME
         move C.PROD.VERSION to PROD.VERSION
         move C.OP.SYS to OP.SYS
         end
    else if ITEM[3] of COMMAND.ARRAY is TRANS.NO
           then begin
                move ITEM[3] of COMMAND.ARRAY as TRANS.NO to TRANS.NO
                move default to PROD.NAME, PROD.VERSION, OP.SYS
                end
           else begin
                move default to TRANS.NO
                move ITEM[3] of COMMAND.ARRAY to PROD.NAME
                move ITEM[4] of COMMAND.ARRAY to PROD.VERSION
                move ITEM[5] of COMMAND.ARRAY to OP.SYS
                end
  end
% end function get trans specs %




macro TYPE.NAME is
begin

  type "     ", trim(PROGRAMMER), " = ", trim(FIRST.NAME), " ", trim(LAST.NAME), @cr
end
end.macro


function COMPLETE.PRODUCT
  begin

  type "Use 'Enter Product' or 'Modify Product'", @cr
  end
% end function complete product %


function COMPLETE.PROGRAMMER 
  % When implemented this should prompt for all missing first and last %
  % names in PROGRAMMER.LIST.                                          %
  begin

  type "Complete Programmer", @cr
  end
% end function complete programmer %


function COMPLETE.TSR 
  % The user is asked for the information needed to complete an ITSR. %
  % An incomplete ITSR is one that lacks a Fixer, Date Out, and/or    %
  % Time Spent.                                                       %
  % The actual prompting/accepting is done by the macro FINISH.TSR.   %
  begin

  GET.TSR.SPECS
  if (TSR.NUM=default) and (PROD.NAME=default)
    then ACCEPT.TSR.SPECS
  while (TSR.NUM ne default) or (PROD.NAME ne default) do
    begin
    if (TSR.NUM=default) or (PROD.NAME=default) or (OP.SYS=default)
        or (RUN.DIRECTORY=default)
      then GET.UNIQUE.TSR
    if (TSR.NUM ne default) and (PROD.NAME ne default) and (OP.SYS ne default)
        and (RUN.DIRECTORY ne default)
      then begin
           select TSR via key
             then begin
                  TYPE.LONG.TSR
                  FINISH.TSR
                  alter TSR
                  RECORD.CUR.TSR
                  end
             else type "Non-existent ITSR", @cr
           end  %if num and name not default, then...%
    ACCEPT.TSR.SPECS
    end  %while not default do...%
  type @cr           
  end
% end function complete tsr %


function COMPLETE.TRANSMITTAL 
  % If the transmittal specified is not complete the user will be asked %
  % for the information to complete the transmittal.  An incomplete     %
  % transmittal lacks an Archival Date, or if not Archive Only, it may  %
  % lack an Install Date and/or a Memo Date.                            %
  begin

  GET.TRANS.SPECS
  if TRANS.NO=default and PROD.NAME=default
    then ACCEPT.TRANS.SPECS
  while (TRANS.NO ne default) or (PROD.NAME ne default) do
    begin
    if TRANS.NO = default
      then GET.UNIQUE.TRANS
    if TRANS.NO ne default
      then select TRANSMITTAL via key
             then begin
                  TYPE.SHORT.TRANS
                  if (ARCH.ONLY="Y" and ARCHIVAL.DATE ne default) or
                     (ARCH.ONLY="N" and ARCHIVAL.DATE ne default and
                      INSTALL.DATE ne default and MEMO.DATE ne default)
                    then type " Transmittal is Already Complete", @cr
                    else begin
                         if ARCHIVAL.DATE ne default
                           then type " Archived: ", ARCHIVAL.DATE, @cr
                           else begin
                                type " Archival Date as mm/dd/yy: "
                                accept ARCHIVAL.DATE
                                end
                         if ARCH.ONLY ne "Y"
                           then begin
                                if INSTALL.DATE ne default
                                  then type " Installed: ", INSTALL.DATE, @cr
                                  else begin
                                       type " Installation Date as mm/dd/yy: "
                                       accept INSTALL.DATE
                                       end
                                if MEMO.DATE ne default
                                  then type " Memo Date: ", MEMO.DATE, @cr
                                  else begin
                                       type " Memo Date as mm/dd/yy: "
                                       accept MEMO.DATE
                                       end
                                end  %not archive only%
                         alter TRANSMITTAL
                         end  %not complete%
                  RECORD.CUR.TRANS
                  end  %select ...then...%
             else type "Non-existent Transmittal", @cr
    ACCEPT.TRANS.SPECS
    end  %while not default do %
  type @cr
  end
% end function complete transmittal %


function DELETE.PRODUCT 
  % Enables the user to delate a Product that does not have a corresponding %
  % transmittal instance.  The Product description is deleted only if there %
  % are no other versions of the Product with the same operating system     %
  % type.                                                                   %
  begin

  GET.PRODUCT.SPECS
  if PROD.NAME = default
    then ACCEPT.PROD.SPECS
  while PROD.NAME ne default do
    begin
    if (PROD.VERSION = default) or (OP.SYS = default) or
        (RUN.DIRECTORY = default)
      then GET.UNIQUE.PROD
    if PROD.NAME ne default      %if a unique Product was found%
      then begin
           select PRODUCT via key
             then PROCESS.DA.PROD: begin
                  TYPE.FULL.PRODUCT
                  TYPE.PROD.DESC(PROD.NAME of PRODUCT, OP.SYS of PRODUCT,
                    RUN.DIRECTORY of PRODUCT)
                  if TRANS.NO ne default
                    then select TRANSMITTAL where (TRANS.NO = TRANS.NO of
                              PRODUCT)
                           then begin
                                type "This product has an existing ",
                                     "transmittal.", @cr, "To delete this ",
                                     "product please delete the transmittal.",
                                     @cr
                                finish PROCESS.DA.PROD
                                end
                  if SECOND.TRANS.NO ne default
                    then select TRANSMITTAL where (TRANS.NO =
                              SECOND.TRANS.NO of PRODUCT)
                           then begin
                                type "This product has an existing second ",
                                     "transmittal.", @cr, "Please delete ",
                                     "the transmittal before deleting this ",
                                     "product.", @cr
                                finish PROCESS.DA.PROD
                           end
                  type "OK to Delete? "
                  ACCEPT.YES.NO
                  if YES.NO = "Y"
                    then begin
                         delete from PRODUCT via key
                         select PRODUCT where
                               ((PROD.NAME=PROD.NAME of procedure) and
                                (OP.SYS=OP.SYS of procedure))
                           then nothing     %leave description%
                           else delete from PRODUCT.DESC where
                                 ((PROD.NAME=PROD.NAME of procedure) and
                                  (OP.SYS=OP.SYS of procedure) and
                                  (RUN.DIRECTORY=RUN.DIRECTORY of procedure))
                         move default to C.PROD.NAME, C.PROD.VERSION,C.OP.SYS,
                          C.RUN.DIRECTORY, C.TSR.NUM, C.TRANS.NO, C.PROGRAMMER
                         end  %if "Y" then...%
                    else RECORD.CUR.PROD
                  end  %process da prod%
             else type "Non-existent Product", @cr
           end  %prod name not default%
    ACCEPT.PROD.SPECS
    end  %while prod name not default...%
  type @cr
  end
% end function delete product %


function DELETE.PROGRAMMER 
  % When implemented this should allow the to delete after confirmation %
  % an instance from PROGRAMMER.LIST.                                   %
  begin

  type "Delete Programmer", @cr
  end
% end function delete programmer %


function DELETE.TSR 
  % Allows the user to delete an ITSR.  For an ITSR with more than one  %
  % product, only the instance for the product specified is deleted.    %
  % The description is not deleted if there is at least one more product%
  % in the ITSR.                                                        %
  begin
  GET.TSR.SPECS
  if (TSR.NUM=default) and (PROD.NAME=default)
    then ACCEPT.TSR.SPECS
  while (TSR.NUM ne default) or (PROD.NAME ne default) do
    begin
    if (TSR.NUM=default) or (PROD.NAME=default) or (OP.SYS=default) or 
      (RUN.DIRECTORY=default)
      then GET.UNIQUE.TSR
    if (TSR.NUM ne default) and (PROD.NAME ne default) and (OP.SYS ne default)
      and (RUN.DIRECTORY ne default)
      then begin
           select TSR via key
             then begin
                  TYPE.LONG.TSR
                  TYPE.TSR.DESC(TSR.NUM of procedure) 
                  type "OK to Delete? "
                  ACCEPT.YES.NO
                  if YES.NO = "Y"
                    then begin
                         delete from TSR via key
                         select TSR where (TSR.NUM=TSR.NUM of procedure)
                           then nothing % leave description %
                           else delete from TSR.DESC via  
                                            TSR.NUM=TSR.NUM of procedure
                         move default to C.PROD.NAME, C.PROD.VERSION,
                              C.OP.SYS, C.PROGRAMMER, C.TSR.NUM,
                              C.RUN.DIRECTORY
                         end  %if "Y" then...%
                    else RECORD.CUR.TSR
                  end  %select...then begin...%
             else type "Non-existent ITSR", @cr
           end  %if num and name not default, then...%
    ACCEPT.TSR.SPECS
    end  %while not default do...%
  type @cr           
  end
%  end function delete tsr %



macro PROCESS.TRANS.DELETES is
  % Used by DELETE.TRANSMITTAL, this macro will delete a transmittal     %
  % if the same version of the product on the same operating system type %
  % has not been re-transmitted.  If the user confirms the deletion, the %
  % product information may be also deleted.                             %
  DELETING.TRANS:
  begin
  select PRODUCT where (PROD.NAME=C.PROD.NAME and PROD.VERSION=C.PROD.VERSION
    and RUN.DIRECTORY=C.RUN.DIRECTORY and OP.SYS=C.OP.SYS) then
      begin
      if SECOND.TRANS.NO ne default and
        SECOND.TRANS.NO ne C.TRANS.NO  then
          begin
          type "This product has been re-transmitted as #",
               SECOND.TRANS.NO as '6l', ".", @cr,
               "Transmittal #", SECOND.TRANS.NO as '6l',
               " MUST be deleted before #",
               C.TRANS.NO  as '6l', " may be ","deleted.", @cr
          finish DELETING.TRANS
          end
      else begin
        type "OK to Delete? "
        ACCEPT.YES.NO
        if YES.NO = "Y" then
          if SECOND.TRANS.NO ne default and 
            SECOND.TRANS.NO = C.TRANS.NO then
              begin
              move default to SECOND.TRANS.NO
              alter PRODUCT
              end
          else begin
            type "PRODUCT: ", @cr
            TYPE.FULL.PRODUCT
            type "OK to Delete? "
            ACCEPT.YES.NO
            if YES.NO = "Y" then
              begin
              delete from PRODUCT via key
              select PRODUCT where (PROD.NAME=C.PROD.NAME
                  and OP.SYS=C.OP.SYS)
                then nothing  %leave description%
              else delete from PRODUCT.DESC where (PROD.NAME=
                C.PROD.NAME and OP.SYS=C.OP.SYS)
              type "Product Deleted", @cr
              end
            else begin
            move default to TRANS.NO, TRANS.DATE
            alter PRODUCT
            end
          end
        else RECORD.CUR.TRANS
        end % else %
      end  % select PRODUCT %
    else type "No Product Information to Delete", @cr
  delete from TRANSMITTAL via key
  type "Transmittal Deleted", @cr
  move default to C.TRANS.NO, C.PROD.NAME, C.OP.SYS, C.PROD.VERSION, 
            C.TSR.NUM, C.PROGRAMMER, C.RUN.DIRECTORY
  end  %deleteing trans.%
end.macro

function DELETE.TRANSMITTAL
  % This function allows the user to delete a transmittal.  After the   %
  % transmittal has been specified and confirmed, PROCESS.TRANS.DELETES %
  % is used for the deleting of the Transmittal, and Product            %
  begin
  GET.TRANS.SPECS
  if TRANS.NO=default and PROD.NAME=default
    then ACCEPT.TRANS.SPECS
  while (TRANS.NO ne default) or (PROD.NAME ne default) do
    begin
    if TRANS.NO = default
      then GET.UNIQUE.TRANS
    if TRANS.NO ne default then
      select TRANSMITTAL via key then
        begin 
        type "TRANSMITTAL: ", @cr
        TYPE.LONG.TRANS
        RECORD.CUR.TRANS
        end
      else type "Non-existent Transmittal", @cr
    PROCESS.TRANS.DELETES
    ACCEPT.TRANS.SPECS
    end  %while not default do %
  type @cr
  end
% end function delete transmittal %


function CREATE.NEW.PRODUCT
  % Used by ENTER.PRODUCT and ENTER.TRANSMITTAL to record the information %
  % of a new product/version/operating-system-type instance.  If an       %
  % earlier version of the same product and operating system exists, then %
  % default values may be avaiable to the user.  Default values, if any,  %
  % are within the square brackets at the end of the prompt for a field.  %
  % For items that are not required information, that have a default      %
  % value, and for which the user would like to have nothing entered -- a %
  % minus sign (-) entered at the prompt will bypass the default value    %
  % record nothing for the item.                                          %
  % A product description is requested if one does not exist for the      %
  % specified product on the specified operating system.                  %
  begin
    select PRODUCT where (PROD.NAME=PROD.NAME of procedure and 
          OP.SYS=OP.SYS of procedure and RUN.DIRECTORY=
          RUN.DIRECTORY of procedure) sorted descending
      then begin
           move PROGRAMMER to DEF.PROGRAMMER
           move MANAGER to DEF.MANAGER
           move SOURCE.LOCATION to DEF.SOURCE.LOCATION
           move UNIT to DEF.UNIT
           move SUPPORT.CLASS to DEF.SUPPORT.CLASS
           move PROD.COMMENT to DEF.PROD.COMMENT
           move PROD.DOC to DEF.PROD.DOC
           end
      else move default to DEF.PROGRAMMER, DEF.MANAGER, DEF.UNIT,
                DEF.SUPPORT.CLASS, DEF.PROD.COMMENT, DEF.PROD.DOC
    do begin
      type "Programmer [", trim(DEF.PROGRAMMER), "]: "
      accept PROGRAMMER
      let PROGRAMMER = upper.case(PROGRAMMER)
      if PROGRAMMER = default
        then begin
             move DEF.PROGRAMMER to PROGRAMMER
             end
      end
    while PROGRAMMER = default
    do begin
      type "Manager [", trim(DEF.MANAGER), "]: "
      accept MANAGER
      let MANAGER = upper.case(MANAGER)
      if MANAGER = default
        then move DEF.MANAGER to MANAGER
      end
    while MANAGER = default
    do begin
      type "Directory of Source [", trim(DEF.SOURCE.LOCATION), "]: "
      accept SOURCE.LOCATION
      let SOURCE.LOCATION = upper.case(SOURCE.LOCATION)
      if SOURCE.LOCATION = default
        then move DEF.SOURCE.LOCATION to SOURCE.LOCATION
      end
    while SOURCE.LOCATION = default
    do begin
      type "Unit [", trim(DEF.UNIT), "]: "
      accept UNIT
      let UNIT = upper.case(UNIT)
      if UNIT = default
        then move DEF.UNIT to UNIT
      end
    while UNIT = default
    do begin
      type "Support Class [", trim(DEF.SUPPORT.CLASS), "]: "
      accept SUPPORT.CLASS
      let SUPPORT.CLASS = upper.case(SUPPORT.CLASS)
      if SUPPORT.CLASS = default
        then move DEF.SUPPORT.CLASS to SUPPORT.CLASS
      end
    while SUPPORT.CLASS = default
    type "Comment [", trim(DEF.PROD.COMMENT), "]: ", @cr
    accept PROD.COMMENT
    if PROD.COMMENT = default
      then move DEF.PROD.COMMENT to PROD.COMMENT
      else if length(PROD.COMMENT)=1 and substr(PROD.COMMENT,1,1)="-"
             then move default to PROD.COMMENT
    type "Documentation [", trim(DEF.PROD.DOC), "]: ", @cr
    accept PROD.DOC
    if PROD.DOC = default
      then move DEF.PROD.DOC to PROD.DOC
      else if length(PROD.DOC)=1 and substr(PROD.DOC,1,1)="-"
             then move default to PROD.DOC
    insert into PRODUCT
    if PROGRAMMER ne default
      then begin
           move default to LAST.NAME, FIRST.NAME
           insert into PROGRAMMER.LIST
              on duplicate nothing
           end
   RECORD.CUR.PROD
    select PRODUCT.DESC where (PROD.NAME=PROD.NAME of procedure and
        OP.SYS=OP.SYS of procedure and RUN.DIRECTORY=RUN.DIRECTORY
        of procedure)
      then nothing
      else begin
           type "Description (blank line terminates): ", @cr
           accept LINE
           let COUNTER=1
           while LINE ne default do
             begin
             insert into PRODUCT.DESC
             let COUNTER=COUNTER + 1
             accept LINE
             end
           end
  end
%end function create new product %


function GET.PROD.TO.ENTER
  % Prompts the user for the name, version, and operating system if they   %
  % are not known so the product may be entered.  Called by ENTER.PRODUCT. % 
GET.THE.PRODUCT:
  begin

  if PROD.NAME = default
    then ACCEPT.PROD.SPECS
  if PROD.NAME ne default
    then begin
         while PROD.VERSION = default do
           begin
           type "Version of ", trim(PROD.NAME), ": "
           accept PROD.VERSION
           let PROD.VERSION = upper.case(PROD.VERSION)
           end
         while OP.SYS = default do
           begin
           type "Operating System type of ", trim(PROD.NAME), ": "
           accept OP.SYS
           let OP.SYS = upper.case(OP.SYS)
           if OP.SYS illegal then
             begin
             TYPE.VALID.OP.SYS
             let OP.SYS = default
             end
           end
         while RUN.DIRECTORY = default do
           begin
           type "Directory of run version of ", trim(PROD.NAME), ": "
           accept RUN.DIRECTORY
           let  RUN.DIRECTORY = upper.case(RUN.DIRECTORY)
           end
         select PRODUCT via key
           then begin
                type "Product Already Exists", @cr
                  move default to PROD.NAME of procedure,
                  PROD.VERSION of procedure, 
                  OP.SYS of procedure, RUN.DIRECTORY of procedure
                repeat GET.THE.PRODUCT
                end
         end  %prod name not default%
  end  %get the product%
% end function get prod to enter %


function ENTER.PRODUCT 
  % Allows the user to add a product to the data base without the product %
  % coming from a transmittal.  Key values from any current product are   %
  % deleted because the new product must be previously non-existent.      %
  % GET.PROD.TO.ENTER and CREATE.NEW.PRODUCT are used to determine the    %
  % keys of the new product, and to collect and record the new product    %
  % information.                                                          %
  begin

  move default to C.PROD.NAME, C.PROD.VERSION, C.OP.SYS, C.PROGRAMMER,
    C.RUN.DIRECTORY
  GET.PRODUCT.SPECS
  GET.PROD.TO.ENTER
  while PROD.NAME ne default do
    begin
    move default to TRANS.NO, TRANS.DATE, SECOND.TRANS.NO
    CREATE.NEW.PRODUCT
    move default to PROD.NAME, PROD.VERSION, OP.SYS
    GET.PROD.TO.ENTER
    end  %while prod name not default%
  end
% end function enter product %


function ENTER.PROGRAMMER 
% When implemented should add DEF.PROGRAMMER or DEF.PROGRAMMER and First and Last Name to %
% PROGRAMMER.LIST.  Entering just the first and last names should %
% be enough to create the ID.                                     %
begin

move default to C.PROGRAMMER
GET.PROG.SPECS
GET.NAMES:
  begin
  if FIRST.NAME eq default and LAST.NAME eq default then
    begin
    type "Enter first name of programmer: ",@cr
    accept FIRST.NAME
    let FIRST.NAME  = upper.case(FIRST.NAME)
    type "Enter last name of programmer: ",@cr
    accept LAST.NAME
    let LAST.NAME = upper.case(LAST.NAME)
    end
  else nothing
  let DEF.PROGRAMMER = substr(FIRST.NAME,1,3)+substr(LAST.NAME,1,1)
  select PROGRAMMER.LIST where FIRST.NAME eq FIRST.NAME of procedure
      and LAST.NAME eq LAST.NAME of procedure then
    begin
    type "This name is already entered into the database",@cr
    finish GET.NAMES
    end
  else 
    UNIQUE.ID:
    begin
    select PROGRAMMER.LIST where PROGRAMMER eq DEF.PROGRAMMER then 
      begin
      if PROGRAMMER of procedure ne default then
        begin   % try the form of DEF.PROGRAMMER entered by the user %
        let DEF.PROGRAMMER = PROGRAMMER of procedure
        let PROGRAMMER of procedure = default  
        repeat UNIQUE.ID
        end
      type "ID's beginning with '",substr(FIRST.NAME,1,1),
        "' which are not available are: :",@cr
      for each PROGRAMMER.LIST where substr(PROGRAMMER,1,1) eq
            substr(FIRST.NAME of procedure,1,1) do
        type PROGRAMMER," = ",trim(FIRST.NAME),"  ",trim(LAST.NAME),@cr
      move default to DEF.PROGRAMMER
      while DEF.PROGRAMMER eq default do
        begin
        type
          "Please enter a unique, four character designation ",
            "for this programmer: ",
            trim(FIRST.NAME of procedure)," ",
            trim(LAST.NAME of procedure),@cr
        accept DEF.PROGRAMMER
        let DEF.PROGRAMMER = upper.case(DEF.PROGRAMMER)
        end
      repeat UNIQUE.ID
      end % select PROGRAMMER %
    else nothing
    end % UNIQUE.ID %
  insert into PROGRAMMER.LIST using( DEF.PROGRAMMER for PROGRAMMER,
      FIRST.NAME of procedure for FIRST.NAME, 
      LAST.NAME of procedure for LAST.NAME)
  end % GET.NAMES %
type DEF.PROGRAMMER," = ",trim(FIRST.NAME of procedure),
    "  ",trim(LAST.NAME of procedure),@cr
end
% end function enter programmer %

function GET.TSR.NUM
% Used by ENTER.TSR to accept an ITSR number, generate a number, or   %
% allow the user to stop entering ITSRs.  If the user enters a number %
% that is already in use, they must confirm that they want to use an  %
% existing number.                                                    %
GET.NUMBER:
  begin

  if TSR.NUM = default
    then begin
         type "ITSR Number, 'Q' to end: "
         accept TSR.NUM.ENTERED
         end
    else move TSR.NUM as TSR.NUM.ENTERED to TSR.NUM.ENTERED
  if TSR.NUM.ENTERED = default
    then begin
         select TSR sorted descending
           then let TSR.NUM of procedure = TSR.NUM + 1
         else let TSR.NUM = 1
         type "ITSR Number: ", TSR.NUM, @cr
         end
    else if TSR.NUM.ENTERED is TSR.NUM
           then move TSR.NUM.ENTERED as TSR.NUM to TSR.NUM
           else if substr(TSR.NUM.ENTERED,1,1)="h" or "H"
                  then begin
                        type "Enter the ITSR Number if known,", @cr,
                        "Carriage Returned to have it entered for you,",@cr,
                        "'Quit' to stop entering ITSRs,", @cr,
                        "or 'Help' for this message.", @cr
                       repeat GET.NUMBER
                       end
                  else move default to TSR.NUM
  end
% end function get tsr num %


function ENTER.TSR 
  % Used for entering a new ITSR.  If the user includes the product name  %
  % with the Enter Product command, then that is the only product of the  %
  % ITSR.  If a name is not included, the user is prompted for as many    %
  % products as necessary.                                                %
  % If the user is not adding a product to an existing ITSR, the user is  %
  % for the initial ITSR information.                                     %
  begin

  move default to C.TSR.NUM, C.PROD.NAME, C.PROD.VERSION, C.OP.SYS,
    C.RUN.DIRECTORY, C.PROGRAMMER, PROD.NAME
  GET.TSR.SPECS
  GET.TSR.NUM
  while TSR.NUM ne default do
    begin
PROCESS.NEW.TSR:
    begin                              % single product ITSR %
    select TSR where (TSR.NUM=TSR.NUM of procedure)
      then begin
           type "ITSR Number is Already in Use, continue?"
           ACCEPT.YES.NO
           if YES.NO = "N"
             then finish PROCESS.NEW.TSR
           end
    delete from PRODUCT.NAMED all
      if PROD.NAME ne default
      then begin
        type "Product: ", trim(PROD.NAME), @cr 
        if  (OP.SYS ne default) or (RUN.DIRECTORY ne default) then
           begin
           GET.UNIQUE.PROD
           while OP.SYS = default do
             begin
             type "Operating System [", trim(OP.SYS), "]: "
             accept OP.SYS
             let OP.SYS = upper.case(OP.SYS)
             end
           select TSR via key
             then begin
                  type "ITSR Already Exists", @cr
                  finish PROCESS.NEW.TSR
                  end
           type "Version of ", trim(PROD.NAME),": "
           accept PROD.VERSION
           let PROD.VERSION = upper.case(PROD.VERSION)
           type "Run directory of ", trim(PROD.NAME),": "
           accept RUN.DIRECTORY
           let RUN.DIRECTORY = upper.case(RUN.DIRECTORY)
           insert into PRODUCT.NAMED
           end
        end
      else begin                       % multiple product ITSR %
           type "Product: "
           accept PROD.NAME
           if PROD.NAME = default
             then finish PROCESS.NEW.TSR
           let PROD.NAME = upper.case(PROD.NAME)
           while PROD.NAME ne default do
             begin
               do begin
               type "Operating System type of ", trim(PROD.NAME),": "
               accept OP.SYS
               let OP.SYS = upper.case(OP.SYS)
               if OP.SYS illegal then
                 begin
                 TYPE.VALID.OP.SYS
                 let OP.SYS = default
                 end
               end
             while OP.SYS = default
             select TSR via key
               then type "ITSR Already Exists", @cr
               else begin
                 type "Version of ", trim(PROD.NAME),": "
                 accept PROD.VERSION
                 let PROD.VERSION = upper.case(PROD.VERSION)
                 type "Run directory of ", trim(PROD.NAME),": "
                 accept RUN.DIRECTORY
                 let RUN.DIRECTORY = upper.case(RUN.DIRECTORY)
                 insert into PRODUCT.NAMED
                 end
             type "Product (cr if no more): "
             accept PROD.NAME
             let PROD.NAME = upper.case(PROD.NAME)
             end  %while prod.name not default do...%
           end  %if prod.name ne default...else...%
    select TSR where (TSR.NUM=TSR.NUM of procedure)
      then begin                       % existing ITSR %
           move TSR.CLASS to TSR.CLASS of procedure
           move PRIORITY to PRIORITY of procedure
           move DATE.IN to DATE.IN of procedure
           move DATE.OUT to DATE.OUT of procedure
           move PROGRAMMER to PROGRAMMER of procedure
           move TIME.SPENT to TIME.SPENT of procedure
           end
      else begin                       % new ITSR %
           move default to DATE.OUT, PROGRAMMER, TIME.SPENT
           do begin
              type "Date Submitted as mm/dd/yy: "
              accept DATE.IN
              end
           while DATE.IN = default
           do begin
              type "Classification, 3 character abbreviation: "
              accept TSR.CLASS
              let TSR.CLASS = upper.case(TSR.CLASS)
              if TSR.CLASS illegal
                then TYPE.VALID.TSR.CLASSES
              end
           while TSR.CLASS illegal
           do begin
              type "Priority: "
              accept PRIORITY
              end
           while PRIORITY = default
           end  %select...else...%
    for each PRODUCT.NAMED do
      begin
      insert into TSR
      RECORD.CUR.TSR
      end
    select TSR.DESC where (TSR.NUM=TSR.NUM of procedure)
      then nothing
      else begin
           type "Description (blank line terminates): ", @cr
           accept LINE
           let COUNTER = 1
           while LINE ne default do
             begin
             insert into TSR.DESC
             let COUNTER = COUNTER + 1
             accept LINE
             end
           end
    end  %process.new.tsr%
    move default to TSR.NUM
    GET.TSR.NUM
    move default to PROD.NAME     %clear for next enter%
    end  %while not default do...%
  type @cr
  end
% end function enter tsr %


function GET.TRANS.NO.TO.ENTER 
% Used by ENTER.TRANSMITTAL to accept an Trans. number, generate a number, %
% or allow the user to stop entering Transmittals.  If the user enters a   %
% number that is already in use, they are asked for another number.        %
GET.THE.T.NUM:
  begin

  if TRANS.NO = default
    then begin
         type "Transmittal Number ('Q' to end): "
         accept TRANS.NO.ENTERED
         end
    else move TRANS.NO as TRANS.NO.ENTERED to TRANS.NO.ENTERED
  if TRANS.NO.ENTERED = default 
    then begin
    select TRANSMITTAL sorted descending
      then let TRANS.NO of procedure = TRANS.NO + 1
      else let TRANS.NO of procedure = 1
    type "Transmittal Number: ", TRANS.NO, @cr
    end
  else if TRANS.NO.ENTERED is TRANS.NO
           then move TRANS.NO.ENTERED as TRANS.NO to TRANS.NO
           else conditional on upper.case(substr(TRANS.NO.ENTERED,1,1))
                  begin
                  "H": begin
                       type "Enter the Transmittal Number if known,", @cr,
                            "Carriage Return to have it entered for you,",@cr,
                            "'Quit' to stop entering transmittals, ",
                            "or 'Help' for this message.", @cr
                       repeat GET.THE.T.NUM
                       end
                  "Q": begin
                       move default to TRANS.NO, PROD.NAME
                       finish GET.THE.T.NUM
                       end
                  end
                else begin
                     move default to TRANS.NO
                     repeat GET.THE.T.NUM
                     end
  if TRANS.NO ne default
    then select TRANSMITTAL via key
      then begin
           type "Transmittal Already Exists", @cr
           move default to TRANS.NO of PROCEDURE
           repeat GET.THE.T.NUM
           end
  end  %get the t. num%
% end function get trans.no to enter %


function ENTER.TRANSMITTAL 
  % Used for entering a new transmittal.   The user is prompted for the  %
  % required information.  If a product instance already exists, the     %
  % transmittal number and date are added to it; if not, a new product   %
  % created by using CREATE.NEW.PRODUCT which prompts the user for the   %
  % necessary product information.                                       %
  begin

  move default to C.PROD.NAME, C.PROD.VERSION, C.OP.SYS, C.TRANS.NO
  GET.TRANS.SPECS
  GET.TRANS.NO.TO.ENTER
  while TRANS.NO ne default do
    begin
    ENTER.NEW.TRANS:
      begin
      % Any of the product keys may have been entered with the 'enter' %
      % command.  If they were not - they will be requested.           %
      while PROD.NAME = default do
        begin
        type "Product Name: "
        accept PROD.NAME
        let PROD.NAME = upper.case(PROD.NAME)
        end
      while PROD.VERSION = default do
        begin
        type "Version of ", trim(PROD.NAME), ": "
        accept PROD.VERSION 
        let PROD.VERSION = upper.case(PROD.VERSION)
        end
      while OP.SYS = default do
        begin
        type "Operating System type of ", trim(PROD.NAME), ": "
        accept OP.SYS
        let OP.SYS = upper.case(OP.SYS)
        if OP.SYS illegal then
          begin
          TYPE.VALID.OP.SYS
          let OP.SYS = default
          end
        end
      select TRANSMITTAL where (PROD.NAME=PROD.NAME of procedure and
              PROD.VERSION=PROD.VERSION of procedure and 
              OP.SYS=OP.SYS of procedure)
        then begin
             type "A Transmittal Already Exists for this Product, Version, ",
                  "and System.", @cr, "Do you wish to continue? "
             ACCEPT.YES.NO
             if YES.NO ne "Y"
               then finish ENTER.NEW.TRANS
             end
      do begin
        type "Date of Transmittal as mm/dd/yy: "
        accept TRANS.DATE
        end
      while TRANS.DATE = default
      move default to ARCH.ONLY
      do begin
        type "Archive Only (y/n): "
        accept YES.NO
        let YES.NO = upper.case(YES.NO)
        if substr(YES.NO,1,1) = "Y"
          then move "Y" to ARCH.ONLY
          else if substr(YES.NO,1,1) = "N"
                 then move "N" to ARCH.ONLY
        end
      while ARCH.ONLY = default
      if ARCH.ONLY = "N" then
        begin
        type "Run Directory of ", trim(PROD.NAME), ": "
        accept RUN.DIRECTORY
        let RUN.DIRECTORY = upper.case(RUN.DIRECTORY)
        type "Installation date as dd/mm/yy : "
        accept INSTALL.DATE
        end
      select PRODUCT via key
        then if TRANS.NO = default
               then alter PRODUCT using (TRANS.NO of procedure for TRANS.NO,
                         TRANS.DATE of procedure for TRANS.DATE)
               else if SECOND.TRANS.NO = default
                      then alter PRODUCT using (TRANS.NO of procedure for
                                   SECOND.TRANS.NO)
                      else begin
                           type "This product has already been transmitted ",
                                "twice.", @cr,
                                "    Change something and try again!", @cr
                           finish ENTER.NEW.TRANS
                           end
        else CREATE.NEW.PRODUCT
      insert into TRANSMITTAL
      RECORD.CUR.TRANS
      end  %enter new trans.%
    move default to TRANS.NO, PROD.NAME, PROD.VERSION, OP.SYS,RUN.DIRECTORY
    GET.TRANS.NO.TO.ENTER
    end  %while trans.no not default%
  type @cr
  end
% end function enter transmittal %


function LIST.PRODUCT
  % If 'list all' was given, then a short line is displayed for each   %
  % product. If not, all the product information is displayed for each % 
  % qualifing product with a description for each different product/   %
  % operating.  If the command was 'list all' the current product      %
  % information is not changed, otherwise, the last producted listed   %
  % is recorded as the current product.                                %
  begin

  if ITEM[3] of COMMAND.ARRAY = "ALL" and I.QUOTE[3] of COMMAND.ARRAY ne "Y"
    then begin
  TYPE 74*"_",@cr,@cr,
  "     PROD.NAME         OP.SYS                 RUN.DIRECTORY             ",
  @cr,@cr,
  "   PROD.VERSION    TRANS.NO1 TRANS.NO2  UNIT   PRGRMR SUP.CLASS TRANS.DATE",
  @cr,74*"_",@cr
         for each PRODUCT do
           type SHORT.PRODUCT.LINE
         type @cr
         end
    else begin
         GET.PRODUCT.SPECS
         if (PROD.NAME=default) and (PROD.VERSION=default)
             and (OP.SYS=default) and (RUN.DIRECTORY=default)
           then type "No Product Specified", @cr, @cr
           else begin
                move "N" to FOUND.FLAG
                for each PRODUCT where ((PROD.NAME=PROD.NAME of procedure or
                         PROD.NAME of procedure = default)
                    and (PROD.VERSION=PROD.VERSION of procedure or
                         PROD.VERSION of procedure = default)
                    and (OP.SYS=OP.SYS of procedure or
                         OP.SYS of procedure = default)
                    and (RUN.DIRECTORY=RUN.DIRECTORY of procedure or
                         RUN.DIRECTORY of procedure = default))
                    sorted on OP.SYS, PROD.NAME, PROD.VERSION,
                         RUN.DIRECTORY do
                  begin
                  TYPE.FULL.PRODUCT
                  type @cr    
                  if (OP.SYS changing) or (PROD.NAME changing)
                    then begin
                         TYPE.PROD.DESC(PROD.NAME of PRODUCT,
                           OP.SYS of PRODUCT, RUN.DIRECTORY of PRODUCT)
                         type @cr
                         end
                  move "Y" to FOUND.FLAG
                  RECORD.CUR.PROD
                  end
                if FOUND.FLAG = "N"
                  then type "No Products Found", @cr, @cr
               end  %if name = default else... %
         end  %if ALL else ... %
  end
% end function list product %


function LIST.PROGRAMMER
  % If 'list all' was the command, then all programmers are listed,      %
  % otherwise, the one specified , if found, is displayed.  A 'list all' % 
  % will not change the current programmer, normally the last programmer %
  % will become the current programmer.                                  %
  begin

  if ITEM[3] of COMMAND.ARRAY = "ALL"
     and I.QUOTE[3] of COMMAND.ARRAY ne "Y"  then
       begin
       type  74*"_",@cr,@cr,"     PROGRAMMER",@cr,74*"_",@cr
       for each PROGRAMMER.LIST do
         begin
         TYPE.NAME
         type @cr
         end
       end
    else begin
         GET.PROG.SPECS
         move "N" to FOUND.FLAG
         if PROGRAMMER ne default
           then select PROGRAMMER.LIST via key
                  then begin
                       TYPE.NAME
                       type @cr
                       RECORD.CUR.PROG
                       move "Y" to FOUND.FLAG
                       end
                  else nothing
           else if (FIRST.NAME ne default) or (LAST.NAME ne default)
                  then select PROGRAMMER.LIST where
                         (FIRST.NAME=FIRST.NAME of procedure)
                         and (LAST.NAME=LAST.NAME of procedure)
                         then begin
                              TYPE.NAME
                              type @cr
                              RECORD.CUR.PROG
                              move "Y" to FOUND.FLAG
                              end
                         else nothing
                  else begin
                       type "Programmer Unspecified", @cr, @cr
                       move "U" to FOUND.FLAG
                       end
         if FOUND.FLAG = "N"
           then type "Programmer Not Found", @cr, @cr
         end
  end
% end function list programmer %


function LIST.TSR
  % A 'list itsr all' will display a line for every itsr and will %
  % not change the current itsr values.  If not 'list all', any   %
  % ITSR that meets the given specification will be displayed in  %
  % its entirety.  The last ITSR listed will become the current   %
  % ITSR.                                                         %
  begin
  if ITEM[3] of COMMAND.ARRAY = "ALL" and I.QUOTE[3] of COMMAND.ARRAY ne "Y"
    then begin
    type 74*"_",@cr,@cr,
  "     PROD.NAME        TSR.NUM   OP.SYS     PROD.VERSION     PRI   CLASS",
    @cr,@cr,
    "DATE.IN  DATE.OUT               RUN.DIRECTORY                  PRGRMR",
    @cr,74*"_",@cr
    for each TSR do
      begin
      TYPE.SHORT.TSR
      type @cr
      end
    end
  else begin
         GET.TSR.SPECS
         if (TSR.NUM = default) and (PROD.NAME = default)
           then type "Unspecified ITSR", @cr, @cr
           else begin
                move "N" to FOUND.FLAG
                for each TSR where ((TSR.NUM=TSR.NUM of procedure or
                   TSR.NUM of procedure = default) and
                   (PROD.NAME=PROD.NAME of procedure or
                   PROD.NAME of procedure = default) and
                   (OP.SYS=OP.SYS of procedure or
                   OP.SYS of procedure = default) and
                   (RUN.DIRECTORY=RUN.DIRECTORY of procedure or
                   RUN.DIRECTORY of procedure = default)) do
                  begin
                  TYPE.LONG.TSR
                  if TSR.NUM changing
                    then begin
                         TYPE.TSR.DESC(TSR.NUM of TSR)
                         type @cr
                         end
                  move "Y" to FOUND.FLAG
                  RECORD.CUR.TSR
                  end  %for each tsr...begin%
                if FOUND.FLAG = "N"
                  then type "No ITSRs Found", @cr, @cr
                end
         end  %if ALL else ... %
  end
% end function list tsr %


function LIST.TRANSMITTAL 
  % 'List trans all' displays the brief transmittal line for every  %
  % transmittal, and the current transmittal information is not     %
  % changed.  If not 'list all', the full information of the        %
  % transmittals that  meet the specification given with the 'list' %
  % command will be displayed, information from the last transmittal%
  % displayed will become the current transmittal information.      %
  begin

  if ITEM[3] of COMMAND.ARRAY = "ALL" and I.QUOTE[3] of COMMAND.ARRAY ne "Y"
    then begin
    type 74*"_",@cr,@cr,
    "TRANS.NO        PROD.NAME         PROD.VERSION    OP.SYS  TRANS.DATE",
    @cr,74*"_",@cr
    for each TRANSMITTAL do
      begin
      TYPE.SHORT.TRANS
      type @cr
      end
    end
  else begin
         GET.TRANS.SPECS
         if TRANS.NO=default and PROD.NAME=default and PROD.VERSION=default
              and OP.SYS=default
           then type "No Transmittal Specified", @cr, @cr
           else if TRANS.NO ne default
                  then select TRANSMITTAL via key
                         then begin
                              TYPE.LONG.TRANS
                              type @cr
                              RECORD.CUR.TRANS
                              end
                         else type "No Transmittal Found", @cr, @cr
                  else begin
                       move "N" to FOUND.FLAG
                       for each TRANSMITTAL where ((PROD.NAME=PROD.NAME
                            of procedure or PROD.NAME of procedure = default)
                           and (PROD.VERSION=PROD.VERSION of procedure or
                               PROD.VERSION of procedure = default)
                           and (OP.SYS=OP.SYS of procedure or OP.SYS
                               of procedure = default)) do
                         begin
                         TYPE.LONG.TRANS
                         type @cr
                         move "Y" to FOUND.FLAG
                         RECORD.CUR.TRANS
                         end
                       if FOUND.FLAG = "N"
                         then type "No Transmittals Found", @cr, @cr
                       end
         end  %not 'all'%
  end
% end function list transmittal %


function MODIFY.PRODUCT 
  % The specification of a product is obtained from the command line %
  % or the current product informtaion is used if the line contains  %
  % no product specification.  The procedure MOD.PROD is run to allow%
  % the user to make product changes.  Passed to MOD.PROD are the    %
  % product key values retrieved by GET.PRODUCT.SPECS.  Returned by  %
  % MOD.PROD is the information from the current Product.  See the   %
  % text MOD.PROD for more information.                              %
  begin

  GET.PRODUCT.SPECS
  run MOD.PROD (PROD.NAME, PROD.VERSION, OP.SYS, RUN.DIRECTORY)
    accepting (C.PROD.NAME, C.PROD.VERSION, C.OP.SYS, C.RUN.DIRECTORY,
    C.PROGRAMMER, C.TRANS.NO, C.TSR.NUM)
  end
% end function modify product %


function MODIFY.PROGRAMMER 
  % When implemented should allow a PROGRAMMER.LIST instance to be changed. %
  % May or may not require a separate procedure.                            %
  begin

  type "MODIFY Programmer", @cr
  end
% end function modify programmer %


function MODIFY.TSR 
  % The ITSR specification is obtained from the command line or from the %
  % current information if the command line contains no specification.   %
  % The procedure MOD.TSR is run to allow the user to make changes to one%
  % or more ITSRs.  Passed to MOD.TSR are the ITSR key values retrieved  %
  % by GET.TSR.SPECS.  Returned by MOD.TSR is the information from the   %
  % current ITSR.  See the text MOD.TSR for more information.            %
  begin
  GET.TSR.SPECS
  run MOD.TSR (TSR.NUM, PROD.NAME, OP.SYS, RUN.DIRECTORY)
    accepting (C.TSR.NUM, C.PROD.NAME, C.PROD.VERSION, C.OP.SYS, 
      C.RUN.DIRECTORY, C.PROGRAMMER)
  end
% end function modify tsr %


function MODIFY.TRANSMITTAL 
  % The transmittal specification is obtained from the command line if   %
  % it was included, if not, it is obtained from the current transmittal %
  % information.  The procedure MOD.TRANS is used to allow the user to   %
  % one or more transmittals.  Passed to MOD.TRANS are the transmittal   %
  % key values retrieved by GET.TRANS.SPECS.  Returned by MOD.TRANS are  %
  % the vaules from the current transmittal.  See the text MOD.TRANS for %
  % more information.                                                    %
  begin

  GET.TRANS.SPECS
  run MOD.TRANS (TRANS.NO, PROD.NAME)
    accepting (C.TRANS.NO, C.PROD.NAME, C.PROD.VERSION, C.OP.SYS,
               C.RUN.DIRECTORY, C.TSR.NUM)
  end
% end function modify transmittal %


function LIST.OUTSTANDING.TSR 
  % All	ITSRs where the default date has not been entered are listed. %
  % Descriptions are printed for each ITSR.                           %
  begin

  for each TSR where DATE.OUT = default do
    begin
    TYPE.SHORT.TSR
    if TSR.NUM changing
      then begin
           TYPE.TSR.DESC(TSR.NUM of TSR)
           type @cr
           end
    end
  end
% end function list outstanding tsr %


function LIST.OUTSTANDING.TRANS 
  % All transmittals that are either: archive only and have not been   %
  % archived; or not archive only and are missing the archive date, the%
  % memo date or the installation date are displayed.                  %
  begin

  for each TRANSMITTAL where ((ARCHIVAL.DATE = default)
      or (ARCH.ONLY = "N" and (INSTALL.DATE=default or MEMO.DATE=default))) do
    begin
    TYPE.LONG.TRANS
    type @cr
    end
  end
% end function list outstanding trans %


function LIST.OUTSTANDING.PROG 
  % Programmer entries mossing the first name and/or the last name are %
  % listed.                                                            %
  begin

  for each PROGRAMMER.LIST where (FIRST.NAME=DEFAULT or LAST.NAME=default) do
    type PROGRAMMER, '  ', FIRST.NAME, '  ', LAST.NAME, @cr
  type @cr
  end
% end function list outstanding prog %


function DISPLAY.HELP
  begin

  type @cr, "Valid Commands are: ", @cr,
    "  Complete      - Complete a Transmittal or ITSR", @cr,
    "  Delete        - Delete a Product, Transmittal, or ITSR",@cr,
    "  Enter         - Enter a new Product, Transmittal, or ITSR",@cr,
    "  List          - List a Product, Transmittal, ITSR, or Programmer",@cr,
    "  Modify        - Modify a Product, Transmittal, or ITSR",@cr,
    "  Outstanding   - List Outstanding Transmittals or ITSRs",@cr,
    "  Quit or ^Z    - Exit SOFT",@cr,
    "  Help          - This message",@cr,
    @cr
  end
% end function display.help %


%  Begin Procedure Soft %

% The current information kept by SOFT is cleared, and commands are %
% processed until 'Quit' or ^Z is entered.                          %
move default to CURRENT.MODE, C.PROD.NAME, C.PROD.VERSION, C.OP.SYS,
      C.PROGRAMMER, C.TRANS.NO, C.TSR.NUM
PROCESS.COMMANDS:
  begin
  for each INPUT.COMMAND do
    begin
    if COMMAND.LINE = default
      then repeat PROCESS.COMMANDS
    let COMMAND.LINE = upper.case(COMMAND.LINE)
    PARSE.COMMAND.LINE
    conditional on substr(ITEM[1] of COMMAND.ARRAY,1,1)
      begin
      "C": conditional on CURRENT.MODE
             begin
             "PRODUCT": COMPLETE.PRODUCT
             "PROGRAMMER": COMPLETE.PROGRAMMER
             "TSR": COMPLETE.TSR
             "TRANSMITTAL": COMPLETE.TRANSMITTAL
             "           ": TYPE.NO.MODE
             end
           else type "!! UNEXPECTED CONDITION ON COMPLETE !!", @cr,
                     "What is ", CURRENT.MODE, @cr
      "D": conditional on CURRENT.MODE
             begin
             "PRODUCT": DELETE.PRODUCT
             "PROGRAMMER": DELETE.PROGRAMMER
             "TSR": DELETE.TSR
             "TRANSMITTAL": DELETE.TRANSMITTAL
             "           ": TYPE.NO.MODE
             end
           else type "!! UNEXPECTED CONDITION ON DELETE !!", @cr,
                     "What is ", CURRENT.MODE, @cr
      "E": conditional on CURRENT.MODE
             begin
             "PRODUCT": ENTER.PRODUCT
             "PROGRAMMER": ENTER.PROGRAMMER
             "TSR": ENTER.TSR
             "TRANSMITTAL": ENTER.TRANSMITTAL
             "           ": TYPE.NO.MODE
             end
           else type "!! UNEXPECTED CONDITION ON ENTER !!", @cr,
                     "What is ", CURRENT.MODE, @cr
      "H": begin
           DISPLAY.HELP
           end
      "L": conditional on CURRENT.MODE
             begin
             "PRODUCT": LIST.PRODUCT
             "PROGRAMMER": LIST.PROGRAMMER
             "TSR": LIST.TSR
             "TRANSMITTAL": LIST.TRANSMITTAL
             "           ": TYPE.NO.MODE
             end
           else type "!! UNEXPECTED CONDITION ON LIST !!", @cr,
                     "What is ", CURRENT.MODE, @cr
      "M": conditional on CURRENT.MODE
             begin
             "PRODUCT": MODIFY.PRODUCT
             "PROGRAMMER": MODIFY.PROGRAMMER
             "TSR": MODIFY.TSR
             "TRANSMITTAL": MODIFY.TRANSMITTAL
             "           ": TYPE.NO.MODE
             end
           else type "!! UNEXPECTED CONDITION ON MODIFY !!", @cr,
                     "What is ", CURRENT.MODE, @cr
      "O": conditional on CURRENT.MODE
             begin
             "TSR": LIST.OUTSTANDING.TSR
             "TRANSMITTAL": LIST.OUTSTANDING.TRANS
             "PROGRAMMER": LIST.OUTSTANDING.PROG
             end
           else type "'Outstanding' must be for 'ITSR', 'Transmittal', or ",
                     "'Programmer'", @cr
      "Q": Return
      end
    else type "Invalid Command", @cr
    end  % for each ... %
  end  % PROCESS.COMMANDS %
end  % procedure SOFT %
  x  