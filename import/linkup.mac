TITLE	LINKUP	ASYNCHRONOUS INTER-PROCESSOR COMMUNICATIONS
SUBTTL	C.MITCHELL 1976, S. LEAPLINE 1979

;***** THE FOLLOWING ASSEMBLY PARAMETER (TYM10) IS NON-ZERO WHEN RUNNING
;***** ON TYMCOM-X AND ZERO WHEN RUNNING ON TOPS-10 OR TOPS-20

IFNDEF TYM10,<TYM10==-1>

;***** THE FOLLOWING ASSEMBLY PARAMETER (TYMAUX) IS NON-ZERO WHEN USING
;***** TYMNET STYLE AUX-CIRCUITS AND ZERO WHEN USING HARD-WIRE LINES
;***** IT DEFAULTS TO THE VALUE OF TYM10 AT TYMSHARE.

IFNDEF TYMAUX,<TYMAUX==TYM10>

;***** THE FOLLOWING ASSEMBLY PARAMETER (DEC20) IS TO BE EQUAL TO 0 WHEN
;***** RUNNING ON TOPS-10 AND NOT EQUAL TO 0 WHEN RUNNING ON TOPS-20

IFNDEF DEC20,<DEC20==0>
IFE DEC20,<SEARCH UUOSYM>

;***** THE FOLLOWING PARAMETER (T1026) IS ONLY NEEDED WHEN RUNNING ON SYSTEM
;***** 1026 BECAUSE OF A LOCAL PATCH THAT SENDS ^A'S TO ANY LINE THAT IS IN
;***** INPUT WAIT. IF THE ASSEMBLY PARAMETER IS NOT EQUAL TO 0, THEN THE
;***** COMMAND 'SET TTY NO RTE' IS SENT DOWN THE LINE BEFORE LOGGING IN.

IFNDEF T1026,<T1026=0>

IFN DEC20,<SEARCH MONSYM
	.REQUIR SYS:MACREL
	TWO=0>

;***** THE FOLLOWING ARE KNOWN BUGS AND SHORT COMINGS OF 'LINKUP'
;
;	1.	When running on TOPS-20, only a limited set of control
;		characters are passed when going virtual terminal.
;		For example, ^C ^T , are eaten by the TOPS-20 exec.
;
;
;
;
IFN DEC20,<
	LOC	134
.JBINT:: EXP	INTBLK
	RELOC
>;END DEC20


;DEFINE VERSION OF LINKUP

	LNKVER==2	;MAJOR VERSION
	LNKMIN==101	;MINOR VERSION
	LNKEDT==27	;EDIT NUMBER
	LNKWHO==1	;WHO LAST PATCHED, 1=TYMSHARE

	%LNK==<BYTE (3)LNKWHO(9)LNKVER(6)LNKMIN(18)LNKEDT>

	LOC 137

.JBVER:: EXP	%LNK

	RELOC

;***** ACCUMULATOR DEFINITIONS

	F=:0		;FLAGS REGISTER
	AC1=:1		;FOR JSYSS
	AC2=:2		;FOR JSYSS
	A=:3		;USED FOR JSYS AND GENERAL USE
	B=:4		;USED FOR JSYS AND GENERAL USE
	C=:5		;USED FOR CHARACTER INPUT
	D=:6		;AOBJN POINTER
	E=:7		;GENERAL USE--OFTEN AN INDEX
	CRC=:10		;USED TO COMPUTE THE CRC
	T1=:11		;MUST BE CRC+1
	T2=:12		;TEMPORARIES
	T3=:13		;    ,,
	T4=:14		;    ,,
	X=:15		;POINTS TO MACHINE BLOCK
	TIMECH=:16	;TIME LAST CHAR RECEIVED
	P=:17		;PUSH DOWN STACK POINTER


;***** FLAGS HELD IN AC "F" (SHOULD BE AC0)
;***** LEFT HALF OF "F"

	F.OTTY==1		;OUTPUT IS CONSOLE TTY
	F.ITTY==2		;INPUT IS CONSOLE TTY
	F.ODSK==4		;OUTPUT IS TO DISK
	F.IDSK==10		;INPUT IS FROM DSK
	F.OCHN==20		;OUTPUT IS TO DATA CHANNEL
	F.ICHN==40		;INPUT IS FROM DATA CHANNEL
	F.AUTO==100		;AUTO BAUD, ON=NO AUTO BAUD
	F.TALK==4000		;TALKING BETWEEN OPERATOR
	F.JOIN==10000		;JOINED MASTER TO MASTER
	F.STPH==40000		;WE ARE WAITING FOR START
	F.WVRT==100000		;WE HAVE VIRTUAL TTY SUPPORT
	F.HVRT==200000		;HE HAS VIRTUAL TTY SUPPORT
	F.PASS==400000		;WE ARE RUNNING AS PASSIVE

;***** RIGHT HALF OF "F"

	F.ACK==400000		;NEED TO SEND AN ACK
	F.NAK==200000		;NEED TO SEND A NAK
	F.REP==100000		;NEED TO SEND A REP
	F.SLOW==40000		;SLOW UP SENDING
	F.STAK==20000		;NEED TO SEND STACK
	F.LSCH==1000		;RE-USE LAST CHAR DURING INPUT
	F.RDET==400		;REMOTE IS RUNNING DETACHED
	F.USFL==200		;USEFUL WORK DONE DURING LOOP
	F.TTYNH==100		;TTY OUTPUT MUST NOT HANG
	F.GDMS==40		;GOOD MESSAGE TO SEND
	F.TEST==20		;TESTING IN PROGRESS
	F.ZER==1		;SUPPRESS LINES DURING OUTPUT


;***** SYMBOL DEFINITIONS

	SEG==0			;KEEP TRACK OF OUR SEGMENT
	MSLMAX==^D80		;MAXIMUM LENGTH OF MESSAGE
	CTLLEN==^D200		;CONTROL BUFFER LENGTH
	MAXNOD==30		;MAX NUMBER OF NODE ENTRIES
	REPNO==^D100		;NO. OF REPS WITH NO ACK
	MAXTYO==^D70		;MAX NO OF CHARS FOR OUTPUT
	SOH==201		;START OF HEADER
	ENQ==005		;FOR UNNUMBERRED MESSAGES
	ACK==001		;ACKNOWLEDGE
	NAK==002		;NOT ACKNOWLEDGE
	REP==003		;REP
	STRT==006		;START MESSAGE
	STAK==007		;STACK REPLY
	SHT==77			;SHUTDOWN
	SLPTIM==^D300		;MSEC TO HIBERNATE
	REPINT==^D1000		;INTERVAL BETWEEN REPS
	HB.RIO==1B11		;WAKE ON ASYNC I/O COMPLETE
	HB.RTC==1B14		;WAKE ON CHARACTER READY
	HB.RTL==1B13		;WAKE ON LINE READY
	ASCDOT=="."
	ASCATT=="@"
	VRTBRK=="X"-100		;CONTROL X BREAKS VIRT SUPPORT
	ASSPRG==1B19		;PTY ASSIGNED BY PROGRAM
	DVAVAL==40		;PTY AVAILABLE
	BELL==7			;GOOD OLD BELL
	BCT==12			;NUMBER OF OUTPUT BUFFERS
	EOT=4			;FOR PTY SUPPORT

;***** FLAGS IN LEFT HALF OF "C" FOR CHARACTER INPUT

	C.BRK==400000		;BREAK CHAR
	C.NUM==200000		;NUMERIC
	C.ALP==100000		;ALPHABETIC
	C.OCT==40000		;OCTAL
	C.MOVP==20000		;MOVE PAPER CHAR
	C.COL==10000		;COLON
	C.COM==4000		;COMMA
	C.BRAC==2000		;BRACKET
	C.DOT==1000		;DOT
	C.PRC==400		;%
	C.DASH==200		;-

;***** FEATURE TESTS SWITCHES

	IFNDEF	TWO,<TWO==1>	;TWOSEGS IF DEFINED AS 1

	IFE	TYM10,<
	    OPDEF	TRMOP.	[CALLI	116]
	    OPDEF	IONDX.	[CALLI	127]
	>


;***** MACRO DEFINITIONS

	DEFINE	UP<
	XLIST
	IFN	TWO,<
	IFE	SEG,<SEG==1
	LIT
	VAR
	RELOC>>
	LIST>

	DEFINE	DOWN<
	XLIST
	IFN	TWO,<
	IFN	SEG,<SEG==0
	LIT
	VAR
	RELOC>>
	LIST>

DEFINE	SETTTY(A)<
	MOVEI	B,A		;GET TRMOP ARG
	MOVEM	B,SETBLK	;STORE IT
    IFE TYM10,<
	MOVE	B,[XWD 3,SETBLK]
	TRMOP.	B,
	JFCL
    >
    IFN TYM10,<
	HRL	B,SETBLK+1
	AUXCAL	B,SETBLK+2
    >
>

DEFINE	CLRTTY(A)<
	MOVEI	B,A		;GET ARG
	MOVEM	B,CLRBLK	;SET TO CLEAR IT
    IFE TYM10,<
	MOVE	B,[XWD 3,CLRBLK]
	TRMOP.	B,
	JFCL
    >
    IFN TYM10,<
	HRL	B,CLRBLK+1
	AUXCAL	B,CLRBLK+2
    >
>


	DEFINE	TYPE(A)<
	PUSHJ	P,TYPIT		;TYPE STRING
	XLIST
	CAI	[ASCIZ /A/]
	LIST>

	DEFINE	PRINT(A)<
	PUSHJ	P,STNOUT	;PRINT STRING
	XLIST
	CAI	[ASCIZ /A/]
	LIST>

	DEFINE	PRINT1(A)<
	PUSHJ	P,STNOUT	;PRINT IT
	XLIST
	CAI	A
	LIST>

	DEFINE	TYPE1(A)<
	PUSHJ	P,TYPIT		;TYPE IT
	XLIST
	CAI	A
	LIST>

	RELOC	0
	IFN	TWO,<
	TWOSEG
	RELOC	400000
	RELOC	0
	>

;***** INITIALISATION AND STARTUP CODE

	UP
START:	RESET			;THE WORLD
	SETZM	F		;CLEAR FLAGS
START2:	MOVE	P,STACK		;SET UP PUSH DOWN STACK
	PUSHJ	P,TTYIO		;SET FOR TTY IO
IFN DEC20,<
	MOVE	T1,[POINT 8,BIGBUF]
	MOVEM	T1,PUTTER
	MOVEM	T1,TAKER
	TIME
	MOVEM	AC2,TIMDIV	;REMEMBER TIME FACTOR
	SETOM	AC1		;OUR JOB NUMBER
	MOVE	AC2,[-20,,GETJTB]
	SETZM	A
	GETJI
	  JFCL
	MOVE	AC1,GETJTB+1
	TRO	AC1,200000
	MOVEM	AC1,OURINX
	MOVEM	AC1,OURTTY
	>;END CONDITIONAL ON DEC20
IFE DEC20,<
	MOVE	A,[44,,11]
	GETTAB	A,		;GET JIFFIES PER SECOND
	  MOVEI	A,^D50		;EUROPE FOR EVER!!!
	MOVEM	A,TIMDIV
	GETLIN	A,		;GET OUR TTY
	MOVEM	A,OURTTY	;SAVE IT
    IFE TYM10,<
	IONDX.	A,		;GET ITS IOINDX
	  PUSHJ	P,MAKIDX	;MAKE OUR OWN INDEX
    >
    IFN TYM10,<
	MOVEI	A,-1		; AUXCAL USES -1,,FUNCTION
    >
	MOVEM	A,OURINX	;SAVE IT
	>;END CONDITIONAL ON DEC20
	JRST	CMDIN		;GO GET COMMAND

MAKIDX:	HRRZS	A		;GET NUMBER WITHOUT 'TTY'
	SETZ	B,
	TRNE	A,77		;THREE DIGIT TTY ?
	JRST	[MOVEI	C,3
		JRST	SHIFT]
	TRNE	A,7700		;IS IT A TWO DIGIT TTY ?
	JRST	[MOVEI	C,2
		JRST	SHIFT]
	MOVEI	C,1		;HAS TO BE ONE THEN
SHIFT:	LSHC	A,-17		;SHIFT ALL THE BITS OUT
	SETZ	A,
MAKLOP:	LSHC	A,3		;GET THE FIRST 3
	LSH	B,3
	SOJG	C,MAKLOP
MAKID1:	IFE TYM10,<TRO A,200000> ;MAKE UDX
	POPJ	P,

;***** ROUTINE TO GET AND INTERPRET MAIN COMMANDS

CMDIN:	TYPE	<
TYPE "HELP" FOR HELP
*>
	PUSHJ	P,GETSIX	;GET REPLY
	JUMPE	T1,CMDLP1	;IGNORE NULL
	MOVE	A,[STRTDS,,STRTOP]
	PUSHJ	P,SERTAB	;FIND IT
	  MOVEI	B,ILLOP		;MAYBE ILLEGAL
	PUSHJ	P,(B)		;GO DO IT
CMDLP1:	PUSHJ	P,TIDY		;TIDY UP
	JRST	START2

ILLOP:	CAMN	T1,[SIXBIT /PASSIV/] ;ARE WE A RECEIVER?
	JRST	PASSIV		;YES--GO AND RECEIVE!!!
	TYPE	<
Illegal Command-->
	PUSHJ	P,TIDY
HLPOP:	TYPE	<Commands >
	MOVE	E,[STRHPT,,STRTOP] ;ADDRESSES OF TABLES
	JRST	TABLST		;HELP HIM

;***** HERE TO FINISH UP AND RETURN TO MONITOR

SHUTDN:	PUSHJ	P,RELTTY	;RELEASE THE TTY
FINISH:	
IFE DEC20,<EXIT>
IFN DEC20,<TLNN	F,F.PASS	;ARE WE RUNNING PASSIVE ?
	   HALTF		;NO, HALT
	   SETOM  AC1		;MY JOB
	   LGOUT		;LOGOUT...WOO BE TO THOSE WHO CONTINUE
>

;***** ROUTINE TO INITIALISE TTY CHANNEL FOR COMMUNICATIONS
;***** USES ACS "A" AND "B" ONLY
IFE DEC20,<
OPNTTY:	MOVEI	A,ICHN		;SET FOR INPUT
	MOVEM	A,BUFHD
	OPEN	2,OPNBLK	;OPEN CHANNEL D
	  POPJ	P,
	MOVEI	A,CHIBUF	;FOOL MONITOR
	MOVEM	A,.JBFF##	;FOR BUFFER
	INBUF	2,1		;JUST ON
	MOVSI	A,OCHN		;SET FOR OUTPUT
	MOVEM	A,BUFHD		;ADDRESS OF BUFFER RING
	MOVE	B,TTY		;GET TTY NAME
	SETOM	A		;OUR OWN JOB
	REASSI	A,		;ASSIGN IT
	OPEN	3,OPNBLK	;OPEN OUR TTY
	  POPJ	P,		;ERROR
	MOVE	A,TTY		;GET NAME
    IFE TYM10,<
	IONDX.	A,		;GET IOINDX
    >
	  PUSHJ	P,MAKIDX	;MAKE OUR OWN INDEX
	MOVEM	A,IOINDX	;SAVE IT
	MOVEM	A,CLRBLK+1	;INITIALISE TRMOP BLOCK
	MOVEM	A,SETBLK+1
	MOVEM	A,SPDBLK+1	;INITIALISE SPEED BLOCK
	MOVEM	A,DILBLK+1	;AND DIALUP BLOCK
	MOVE	A,[XWD 400000,CHOBUF+1]
	MOVEM	A,OCHN		;SET UP A LARGE BUFFER
	MOVE	A,[POINT 9,0,35]
	MOVEM	A,OCHN+1	;MESSAGE IN ONE BUFFER
	OUTBUF	3,1
	SETZM	NCHAR
	AOS	NCHAR		;FORCE INITIAL OUTPUT
	PUSHJ	P,CHNINI	;SET UP PROPER MODES
	  POPJ	P,		;ERROR
	CLRTTY	(<4>)		;CLEAR OUTPUT BUFFER
	JRST	CPOPJ1		;SKIP RETURN

;***** ROUTINE TO OPEN COMMUNICATIONS CHANNEL FOR INPUT
;***** USES AC "B" ONLY

CHNINI:
    IFN TYM10,<
	seto	b,		; Get the tty characteristics
	getlch	b		; Of your own port
	movem	b,tymtty	; Remember them
	tlo	b,220		; Magic bits NFC!NCM
	setlch	b		; Now setup special ones
	hrroi	b,.Axrvx	; ^S/^Q
	setzm	inirvx		; turn it off and save it
	Auxcal	b,inirvx
	Hrroi	b,.Axcfs	; Now setup port status
	Auxcal	b,io.nee!io.nec!io.fcs!.iobin
	Popj	p,		; Then Return
    > ; END IFN TYM10
    IFE TYM10,<
	SETTTY(<2004>)		;SET SLAVE
	SETTTY(<2013>)		;SET GAG
	SETTTY(<2007>)		;LOCAL COPY
	SETTTY(<2010>)		;NO CRLF
	CLRTTY(<2021>)		;NO Page
	CLRTTY(<2017>)		;NO FILL
	CLRTTY(<2035>)		;NO ACR
    > ; END IFE TYM10
	MOVEI	B,ICHN		;FOR INPUT BUFFER
	MOVEM	B,BUFHD		;SAVE ADDRESS
	OPEN	2,OPNBLK	;OPEN TTY
	  POPJ	P,
    IFE TYM10,<
	CLRTTY	(<2037>)	;NO PIM breakset
    > ; END IFE TYM10
	MOVEI	B,CHIBUF	;ADDRESS OF BUFFER
	MOVEM	B,.JBFF##	;FOOL MONITOR
	INBUF	2,1
	JRST	CPOPJ1		;AND GIVE A SKIP RETURN

;***** ROUTINE TO RELEASE COMMUNICATIONS CHANNEL
;***** USES AC "B" ONLY

RELTTY:
    IFN TYM10,<
	move	b,tymtty	; Remember these characteristics?
	setlch	b		; Now set them back
	hrroi	b,.Axrvx	; ^S/^Q
	push	p,inirvx	; Make sure this doesn't get clobberred
	Auxcal	b,inirvx	; restore it
	pop	p,inirvx	;  ...
	Popj	p,		; Then return
    > ; END IFN TYM10
    IFE TYM10,<
	CLRTTY	(<2004>)	;CLEAR SLAVE
	CLRTTY	(<14>)		;HANG UP THE MODEM
	CLRTTY	(<2013>)	;CLEAR GAG
	CLRTTY	(<2007>)	;CLEAR LOCAL COPY
	CLRTTY	(<2010>)	;CLEAR NO CRLF
	CLRTTY	(<2021>)	;CLEAR Page
	CLRTTY	(<2037>)	;CLEAR PIM
	SETZM	A		;SET TO DEASSIGN TTY
	MOVE	B,TTY		;GET NAME
	REASSI	A,		;GET RID OF IT
    > ; END IFE TYM10
	CLOSE	2,
	CLOSE	3,
	POPJ	P,
;***** ROUTINE TO GET A CHAR FROM THE COMMUNICATION CHANNEL
;***** CHARACTER RETURNED IN "C"--PRESERVES ACS

GETCHR:	SOSG	ICHN+2		;GET CHAR IF SOME THERE
	PUSHJ	P,GETCH2	;GET MORE
	ILDB	C,ICHN+1	;GET CHAR FROM BUFFER
	ANDI	C,377		;GET 8 BITS
	JRST	CPOPJ1		;SKIP RETURN

GETCH2:	IN	2,		;INPUT SOME DATA IF THERE
	POPJ	P,		;GOT SOME
	STATZ	2,IO.ERR!IO.EOF	;ERRORS OR EOF ?
	  JRST	[PUSHJ	P,CHNINI
		JFCL
		JRST	GETCH2]
GETCH3:	POP	P,(P)		;GO UP ONE LEVEL
	POPJ	P,		;RETURN

;***** ROUTINE TO TRANSMIT CHAR OVER COMMUNICATION CHANNEL
;***** SUPPLY CHARACTER IN "T1"--PRESERVES ACS

PUTCHR:	PUSHJ	P,PUTOUT
	EXCH	T1,CLRBLK+2
    IFN TYM10,<
	CLRTTY	(<.AxO8>)
    >
    IFE TYM10,<
	CLRTTY	(<6>)
    >
	EXCH	T1,CLRBLK+2
	POPJ	P,

	SOSG	OCHN+2		;ROOM?
	PUSHJ	P,PUTOUT	;NO
	IDPB	T1,OCHN+1	;STORE CHAR
	AOS	NCHAR		;COUNT CHARS IN BUFFER
	POPJ	P,

;***** ROUTINE TO FORCE OUTPUT OVER COMMUNICATION CHANNEL
;***** PRESERVES ALL ACS

PUTOUT:	PUSH	P,B
    IFE TYM10,<
	MOVE	B,IOINDX	;SEND OUT BUFFER
	MOVEM	B,RPage+1	;SEE IF STOPPED BY XOF
	MOVE	B,[XWD 3,RPage]
	TRMOP.	B,
	  JFCL
	SKIPE	RPage+2		;OK?
	PUSHJ	P,CLTXOF	;NO!!
	POP	P,B
	POPJ	P,
    > ; End IFE TYM10
	SKIPE	NCHAR		;CHARS TO BE OUTPUT?
	OUT	3,
	SKIPA
	HALT	.
	SETZM	NCHAR		;RESET
	POP	P,B		;RESTORE B
	POPJ	P,

CLTXOF:
    IFE TYM10,<
	CLRTTY	(<4>)
	CLRTTY	(<2022>)
    >
	POPJ	P,
>

;***** SAME ROUTINES AS ABOVE BUT FOR DEC20
IFN DEC20,<
;***** ROUTINE TO INITIALISE OUR COMMUNICATIONS CHANNEL

OPNTTY:	MOVE	A,TTY		;GET TTY TO USE
	TLNN	F,F.PASS	;ARE WE RUNNING PASSIVE ?
	PUSHJ	P,MAKIDX	;NO, MAKE IONDX
	MOVEM	A,IOINDX	;SAVE IT AWAY IN A FEW PLACES...
	MOVEM	A,CLRBLK+1	;FOR SOME OF THE TOPS-10 TRMOP.'S
	MOVEM	A,SETBLK+1	;
	MOVEM	A,SPDBLK+1	;
	MOVEM	A,DILBLK+1	;
	TRZ	A,200000	;CLEAR UDX BIT
	HRLZM	A,FILJFN	;JUST A PLACE TO STORE FOR A WHILE
	MOVE	A,[POINT 7,TTYCOL,20]
	MOVE	B,[POINT 3,FILJFN,8]
	MOVEI	AC1,3
OPNTY1:	ILDB	T1,B		;GET A CHARACTER FROM LINE NUMBER
	ADDI	T1,60		;MAKE IT ASCII
	IDPB	T1,A		;PUT IT IN TTY STRING
	SOJG	AC1,OPNTY1

OPNTYZ:	MOVEI	T1,":"		;OUTPUT A COLON
	IDPB	T1,A		;TO TTY STRING
	MOVEI	T1,0		;MAKE ASCIZ
	IDPB	T1,A		;MAKE IT ASCIZ
	SETOM	AC1
	RLJFN			;RELEASE ALL UNOPENED JFN'S
	  JFCL
	MOVE	AC1,[1B17]	;SHORT FORM GTJFN
	HRROI	AC2,TTYCOL	;ADDRESS OF TTY STRING
	GTJFN			;GET A JFN FOR THE TTY
	  ERJMP	CPOPJ		;CAN'T GET IT
	MOVEM	AC1,TTY		;SAVE THE JFN
	DVCHR
	MOVEM	AC1,FILJFN	;SAVE THE DEVICE DESIGNATOR
	ASND			;ASSIGN THE DEVICE
	  ERJMP	CPOPJ
	MOVE	AC1,TTY		;GET TTY JFN BACK
	Setzm	AC2		;NO BITS
	STPAR			;SET THEM
	  ERJMP	CPOPJ		;ERROR
	MOVEI	AC2,TT%WKF!TT%WKN!TT%WKP!TT%WKA
	SFMOD			;WAKE UP ON ALL CHARS
	  ERJMP	CPOPJ		;CANNOT
	SETZM	AC2
	TLNE	F,F.PASS	;ARE WE PASSIVE ?
	DTACH			;YES, GO DETACHED
	MOVE	AC2,[8B5!10B9!1B19!1B20!1B22]
	MOVE	AC1,TTY
	OPENF			;OPEN THE TTY ***SRL***
	  ERJMP	CPOPJ
	MOVE	AC1,[620000,,STRCHR]
	CFORK
	  ERJMP	CPOPJ
	JRST	CPOPJ1


;***** ROUTINE TO RELEASE THE COMMUNICATIONS CHANNEL

RELTTY:	MOVE	AC1,FILJFN		;GET TTY
	RELD			;RELEASE IT
	  JFCL			;TOO BAD
	POPJ	P,

;***** THIS ROUTINE IS THE FORK THAT GETS CHARACTERS FROM THE COMM LINE
;***** AND STORES THEM IN BIGBUF

STRCHR:	MOVE	AC1,TTY			;GET JFN FOR COMM LINE
	BIN				;GET A CHARACTER
	ANDI	AC2,377			;ONLY 8 BITS
	ILDB	AC1,PUTTER
	CAIE	AC1,0
	AOS	OVRFLO			;COUNT THE OVERFLOW
	DPB	AC2,PUTTER		;SAVE THE CHARACTER
	MOVE	T2,[POINT 8,BIGBUF]	;SET FOR RESET
	HRRZ	T1,PUTTER		;GET THE CURRENT ADDRESS
	CAILE	T1,BUFLEM+BIGBUF	;AT END YET ?
	MOVEM	T2,PUTTER		;YES, RESET
	MOVE	AC1,GETJTB		;GET OUR JOB NUMBER
	TWAKE
	  JFCL
	SETOM	CHRFLG			;JUST IN CASE TWAKE DIDN'T WORK
	JRST	STRCHR			;LOOP

;***** ROUTINE TO GET CHARACTERS FROM BIGBUF AND RETURN IT IN 'C'

GETCHR:	PUSH	P,T1
	PUSH	P,T2
	MOVE	T2,TAKER		;GET THE TAKER POINTER
	CAMN	T2,PUTTER		;SAME AS PUTTER ?
	JRST	GETRT1
	SETZM	T1
	ILDB	C,T2			;GET THE NEXT CHARACTR
	DPB	T1,T2			;CLEAR IT OUT
	HRRZ	T1,T2			;GET ADDRESS OF TAKER
	CAILE	T1,BUFLEM+BIGBUF	;AT END YET ?
	MOVE	T2,[POINT 8,BIGBUF]	;RESET THE POINTER
	MOVEM	T2,TAKER		;SAVE IT
	AOS	-2(P)			;SKIP RETURN
GETRT1:	POP	P,T2
	POP	P,T1
	POPJ	P,

;***** ROUTINE TO SEND CHAR IN T1

PUTCHR:	MOVE	AC1,TTY		;GET DEVICE
	MOVE	AC2,T1		;GET CHAR
	BOUT			;SEND IT
	  ERJMP	PUTOUT		;IGNORE ERRORS
PUTOUT:	POPJ	P,		;RETURN
	>;END CONDITIONAL ON DEC20
;***** ROUTINES TO HANDLE THE ASYNCHRONOUS PROTOCOL

;***** MAIN LOOP WHEN RUNNING PROTOCOL

PROTO:	MOVEM	P,PROTP		;SAVE P
	PUSHJ	P,INITPR	;INITIALISE PROTOCOL
	PUSHJ	P,TTYIO
	TLO	F,F.STPH	;SET START PHASE
PRLP1:	PUSHJ	P,LISTEN	;ANYONE THERE ?
	TRZE	F,F.USFL	;KEEP LISTENING IF SOMETHING THERE
	JRST	PRLP1		;GET SOME MORE
	PUSHJ	P,SHOUT		;TALK TO HIM
	TLNN	F,F.PASS	;ARE WE PASSIVE?
	PUSHJ	P,TTYSRV	;CHECK TTY
	TRZE	F,F.USFL	;DID USEFUL WORK?
	JRST	PRLP2		;DO ANOTHER LOOP
IFE DEC20,<
	MOVEI	T1,SLPTIM	;TIME TO HIBERNATE
	HRLI	T1,(HB.RTL!HB.RIO!HB.RTC)	;WAKE ON TTY ACTIVITY
	MOVEI	T2,1		;SLEEP ONE SECOND
	HIBER	T1,
	  SLEEP	T2,		;NASTY!!!!
>;END DEC20
IFN DEC20,<
	SKIPE	CHRFLG		;CHARACTER AVAILABLE ?
	JRST	PRLP2		;YES
	MOVEI	AC1,1
	THIBR
	  JFCL
>;END DEC20
PRLP2:	SETZM	CHRFLG
	SKIPL	NOREPS		;RUN OUT OF REPS?
	JRST	PRLP3		;NO
	TLNE	F,F.PASS	;TOUGH IF MASTER
	JRST	SHUTDN		;YES
	TYPE	<
%%LOST CONNECTION
*>
	JRST	SHUTDN
PRLP3:	MSTIME AC1,
	SUB	AC1,TIMECH	;TIME SINCE LAST CHAR
	CAIG	AC1,REPINT	;TOO LONG?
	JRST	PRLP1		;GO ROUND AGAIN
	TRO	F,F.REP		;SEND A REP
	MSTIME TIMECH,
	JRST	PRLP1		;GO ROUND THE HORN


;***** ROUTINE TO DO ALL OUTPUT UNDER PROTOCOL

SHOUT:	TRZE	F,F.STAK	;SEND STACK?
	JRST	SNDSTK		;YES
	TRZE	F,F.NAK		;SEND NAK?
	JRST	SNDNAK		;YES
	TRZE	F,F.REP		;SEND REP?
	JRST	SNDREP		;YES
	TLNN	F,F.STPH	;START PHASE?
	PUSHJ	P,SNDMES	;SEND ANY MESSAGES
	TRZE	F,F.ACK		;SEND ACK?
	PUSHJ	P,SNDACK	;YES
	POPJ	P,


;ROUTINE TO INTERCEPT ^C 'S. ONLY USED WHEN SUPPORTING VIRTUAL TERMINALS
;AND THE SLAVE TRMOP. UUO FAILS.

INTLOC:	PUSH	P,C
	PUSH	P,AC1
	MOVEM	AC1,TEMP1	;SAVE AC1
	HLRZ	AC1,INTBLK+3	;GET REASN FOR ERROR
	CAIE	AC1,2		;WAS IT A ^C ?
	HALT	.		;NO
	MOVE	AC1,INTBLK+2	;GET RETURN PC
	EXCH	AC1,TEMP1	;RESTORE AC1
	SETZM	INTBLK+2
	TLNN	F,F.WVRT	;ARE WE VIRTUAL ?
	EXIT	1,		;NO
	MOVEI	C,3		;OUTPUT A CONTROL - C
	PUSHJ	P,TRMVRS
	POP	P,AC1
	POP	P,C
	JRSTF	@TEMP1		;RETURN


;***** ROUTINE TO LISTEN TO COMMUNICATIONS LINE FOR INPUT
;***** CHARACTERS. IF NO CHARS ARE PRESENT IN THE INPUT
;***** BUFFER IT MUST BE POSSIBLE TO SUSPEND THE ROUTINE
;***** AND CONTINUE LATER ON. FOR THIS REASON ALL ROUTINES
;***** WHICH REQUEST A CHARACTER MUST HAVE, AS THEIR
;***** ERROR RETURNS A CALL TO "WAIT1". THIS ROUTINE SAVES
;***** "CRC" AND "T2", ADJUSTS THE PC TO RETRY THE INPUT
;***** ROUTINE ON THE NEXT CALL TO "LISTEN" AND RETURNS
;***** TO THE MAIN LOOP.

;***** ENTER HERE AT EACH CYCLE OF THE MAIN LOOP

LISTEN:	MOVE	CRC,CRCSVR	;RESTORE CRC
	MOVE	T2,T2SAVR	;RESTORE T2
	POP	P,WAIPOP	;SAV CALLERS PC
	JRST	@LISTNP		;RETURN TO WHERE WE WERE

;***** ROUTINE TO GET A CHARACTER WITHOUT HANGING IN "TI"
;***** CALLS WAIT1 IF NO CHARS AVAILABLE

INBYTE:	PUSHJ	P,RCVCHR	;GET CHAR
	  PUSHJ	P,WAIT1		;NONE THERE YET
	POPJ	P,		;OK

;***** HERE TO SAVE "CRC","T2", ADJUST THE CALLERS PC
;***** TO RETRY PREVIOUS INSTRUCTION, AND RETURN TO THE
;***** MAIN LOOP.

WAIT1:	MOVEM	CRC,CRCSVR	;SAVE CRC
	MOVEM	T2,T2SAVR	;AND T2
	POP	P,T2		;GET RETURN PC
	SUBI	T2,2		;ADJUST TO RETRY
	HRRZM	T2,LISTNP	;SAVE IT
	JRST	@WAIPOP		;RETURN TO CALLER


;***** ROUTINE TO ANALYZE THE INPUT STREAM OF THE COMMUNICATIONS
;***** CHANNEL. THIS ROUTINE BE CAPABLE OF BEING
;***** SUSPENDED BY USE OF THE "WAIT1" ROUTINE. ALL
;***** PRESERVED INFORMATION IS CARRIED IN CORE OR IN ACS
;***** "CRC" OR "T2".

RCVMES:	SETZM	CRC		;CLEAR CRC
	PUSHJ	P,INBYTE	;GET CHAR
	CAIE	C,ENQ		;UNNUMBERRED MESS?
	CAIN	C,SOH		;FOUND SOH?
	JRST	RECMSN		;OK
BADCHR:	AOS	BADCNT		;COUNT THE BAD CHARS
	ANDI	C,177		;7 BITS ONLY
	CAIN	C,21		;CONTROL Q ?
	SETZM	STPFLG		;YES, CLEAR STOP FLAG
	CAIN	C,23		;CONTROL S ?
	SETOM	STPFLG		;SET STOP FLAG
	JRST	RCVMES		;LOOK FOR MORE
RECMSN:	MOVEM	C,RECCOD	;SAVE CODE
	PUSHJ	P,INBYTE	;GET BYTE
	MOVEM	C,RECCC1	;SAVE BYTE
	PUSHJ	P,INBYTE	;GET BYTE
	MOVEM	C,RECCC2	;SAVE BYTE
	PUSHJ	P,INBYTE	;GET NEXT ONE
	MOVEM	C,RECRFD	;SAVE "R" FIELD
	PUSHJ	P,INBYTE	;GET A BYTE
	MOVEM	C,RECNFD	;THIS IS THE "N" FIELD
	PUSHJ	P,INBYTE	;GET A BYTE
	MOVEM	C,RECAFD	;THIS IS THE STATION
	PUSHJ	P,CHKBCC	;CHECK CRC
	  JRST	BADF1		;BAD
	PUSHJ	P,REPSET	;RESET REP COUNT
	MOVEI	C,SOH		;WHICH TYPE OF MESSAGE?
	TLNN	F,F.STPH	;START PHASE?
	CAME	C,RECCOD	;CHECK
	JRST	CHKMSI		;UNNUMBERRED
	MOVE	C,RECRFD	;GET THE R FIELD
	CAME	C,LSTACK	;PIGGY BACKED ACK?
	PUSHJ	P,ACKFCT	;YES
	MOVE	T2,RECCC2	;GET HIGH ORDER PART OF COUNT
	LSH	T2,10		;SHIFT IT A BIT
	ADD	T2,RECCC1	;GET LOW ORDER PART
	ANDI	T2,37777	;14 BITS
	CAILE	T2,MSLMAX	;TOO MUCH FOR US?
	  JRST	BADF20		;YES
	SETZM	CRC		;RESTART CRC
	MOVN	T2,T2		;GET NEGATIVE NUMBER
	HRLZ	T2,T2		;GET COUNT IN LEFT HALF
	HLLM	T2,RECCC1	;SAVE IT
	HRRI	T2,RECBUF	;GET ADDRESS OF BUFFER
RCVTXT:	PUSHJ	P,INBYTE	;GET A BYTE
	MOVEM	C,(T2)		;SAVE IT
	AOBJN	T2,RCVTXT	;GET NEXT
	PUSHJ	P,CHKBCC	;CHECK REST OF MESAGE
	  JRST	BADF2		;BAD
	JRST	INPBUF		;GO STORE THE BUFFER

;***** HERE TO CLEAN UP AFTER A MESSAGE HAS BEEN RECEIVED.
;***** RESTORES POINTER TO POINT TO "RCVMES" IN READINESS
;***** FOR NEXT MESSAGE

COMMSD:	MOVEI	T1,RCVMES	;REINITIALISE INPUT ROUTINE
	MOVEM	T1,LISTNP	;POINTER
	TRO	F,F.USFL	;SET  FLAG
	JRST	@WAIPOP		;RETURN TO CALLER

;***** ROUTINES TO GET ERROR CODES FOR BAD FORMATS

BADF1:	MOVEI	T1,1		;BCC HEADER ERROR
	JRST	BADFRM		;SEND IT

BADF2:	MOVEI	T1,2		;BCC DATA ERROR
	JRST	BADFRM

BADF3:	MOVEI	T1,3		;BAD REP
	JRST	BADFRM

BADF20:	MOVEI	T1,20		;MESSAGE TOO LONG
	JRST	BADFRM

BADF21:	MOVEI	T1,21		;HEADER FORMAT ERROR
	JRST	BADFRM

BADFRM:	TRO	F,F.NAK		;SET TO NAK MESSAGE
	MOVEM	T1,NAKRES	;SAVE REASON
	JRST	BADCHR		;JUNK CHARS


;***** ROUTINE TO CHECK CRC. RETURNS .+2 IF OK, OR .+1
;***** IF CRC DOES NOT CHECK.

CHKBCC:	PUSHJ	P,RCVBCC	;GET CRC 1
	  PUSHJ	P,WAIT1		;WAIT FOR IT
	LSHC	CRC,-10
	CAME	CRC,C		;CORRECT?
	  POPJ	P,
	LSHC	CRC,10		;GET ORIGINAL CRC
	ANDI	CRC,377		;JUST 8 BITS
	PUSHJ	P,RCVBCC	;GET CRC 2
	  PUSHJ	P,WAIT1
	CAME	CRC,C		;CORRECT?
	  POPJ	P,
	JRST	CPOPJ1		;OK

;***** HERE TO CHECK FOR A CONTROL (UNNUMBERRED) MESSAGE

CHKMSI:	MOVE	C,RECCC1	;GET MESSAGE TYPE
	CAIN	C,STRT		;START UP?
	JRST	RECSTR		;YES
	CAIN	C,STAK		;OR STACK?
	JRST	RECSTK		;YES
	TLNE	F,F.STPH	;START PHASE?
	JRST	BADCHR		;ALL ELSE IS ILLEGAL
	CAIN	C,ACK		;ACK?
	JRST	RECACK		;YES
	CAIN	C,NAK		;NAK?
	JRST	RECNAK		;GET IT
	CAIN	C,REP		;REP?
	JRST	RECREP		;YES
	JRST	BADCHR		;NO!!!


;***** HERE TO CHECK FOR A "REP"

RECREP:	AOS	REPICT
	MOVE	C,RECNFD	;GET "N" FIELD
	CAME	C,LSTREC	;DO WE AGREE ?
	JRST	BADF3		;BAD REP
ACKIT:	TRO	F,F.ACK		;YES--ACK IT
	JRST	COMMSD		;CLEAN UP

;***** HERE TO CHECK FOR A "NAK"

RECNAK:	AOS	NAKICT		;COUNT THEM
	MOVE	C,RECCC2	;GET REASON FOR THE NAK
	MOVEM	C,LASNAK	;SAVE IT
	CAIE	C,22		;OVERFLOWING THE OTHER END ?
	JRST	RECNK2		;NOPE
	MOVE	C,RECRFD	;GET THE LAST MESSAGE NUMBER
	CAMN	C,LSTNAK	;NAKING THE SAME MESSAGE NUMBER ?
	JRST	RECNK1		;YES, NOT RESEND IT AGAIN
	TRO	F,F.SLOW	;SLOW UP A BIT
RECNK2:	MOVE	C,RECRFD	;GET LAST GOOD MESSAGE NUMBER BACK
	MOVEM	C,LSTNAK	;SAVE THE NAKED MESSAGE NUMBER
	MOVEM	C,LSTSNT	;UPDATE MESS NO
	JRST	ACKINC		;GO CLEAN UP

;***** HERE TO DEAL WITH AN "ACK"

RECACK:	AOS	ACKICT		;COUNT THEM
RECNK1:	MOVE	C,RECRFD	;GET "R" FIELD
ACKINC:	CAME	C,LSTACK	;SAME AS BEFORE?
	PUSHJ	P,CLRMES	;CLEAR MESSAGES
	JRST	COMMSD		;CLEAN UP

;***** HERE TO DEAL WITH A "STACK"

RECSTK:	AOS	STKICT		;COUNT THEM
STRSTK:	PUSHJ	P,INITPR	;RE-INIT
	TLNN	F,F.PASS	;PASSIVE?
	TYPE	<
[RESTARTING]
*>
	TLZ	F,F.STPH	;NO LONGER WAITING
	JRST	COMMSD		;CLEAN UP

;***** HERE TO DEAL WITH A "START"

RECSTR:	AOS	STRICT		;COUNT THEM
	MOVE	C,RECCC2	;GET START TYPE
	ANDI	C,77		;SIXBITS
	CAIN	C,SHT		;SHUTDOWN?
	JRST	SHUTDN		;YES
	TRO	F,F.STAK	;SEND STACK
	JRST	COMMSD		;NO--CLEAN UP

;***** ROUTINE TO CLEAR MESSAGES FROM BUFFERS AFTER RECEIPT
;***** OF AN "ACK"

ACKFCT:	AOS	ACKICT		;COUNT ACKS
	AOS	ACKPCT		;COUNT PIGGY BACK ACKS
CLRMES:	MOVEM	C,LSTACK	;UPDATE LAST ACKED
	MOVEI	D,FIRBUF	;POINT TO FIRST BUFFER
CLRLP1:	SKIPG	T1,BUFMES(D)	;GET MESSAGE NUMBER
	JRST	CLRNXT		;NOT IN USE
	MOVEI	T2,BCT		;MAXIMUM OUTSTANDING
CLRLP2:	CAMG	T1,LSTACK	;ACKED?
	JRST	ACKED		;YES
	PUSHJ	P,NXTNUM	;GET NEXT NUMBER
	SOJGE	T2,CLRLP2	;LOOP UP
	JRST	CLRNXT
ACKED:	MOVEI	T1,1(D)		;GET ADDRRESS
	HRL	T1,T1		;COPY IN RIGHT HALF
	AOS	T1		;MAKE A BLT POINTER
	SETZM	1(D)		;CLEAR FIRST ENTRY
	BLT	T1,BUFTOP(D)	;DO ALL
	TRZN	F,F.SLOW	;NEED TO SLOW UP ?
	JRST	CLRNXT		;NO
	AOS	SLOBUF		;COUNT IT
	MOVE	T1,SLOBUF	;GET THE COUNT
	CAIL	T1,BCT		;MAKE SURE WE DON'T DELETE THEM ALL
	JRST	CLRNXT		;THERE'S ONE LEFT
	MOVEI	T1,-1		;MAKE A BIG MESSAGE NUMBER
	HRLS	T1		;BOTH SIDES
	MOVEM	T1,BUFMES(D)	;SAVE THE BIG MESSAGE NUMBER
CLRNXT:	MOVE	D,(D)		;GET LINK
	SKIPN	(D)		;REACHED END?
	POPJ	P,		;ALL DONE
	JRST	CLRLP1		;NO


;***** ROUTINE TO GET A BYTE IN "C" FROM THE COMMUNICATIONS
;***** CHANNEL WITHOUT UPDATING THE CRC.

RCVBCC:	PUSHJ	P,GETCHR	;GET CHAR
	  POPJ	P,		;NONE THERE
	MSTIME TIMECH,	;GET TIME
	JRST	CPOPJ1		;SKIP RETURN

;***** ROUTINE TO GET THE NEXT CHAR IN "C" FROM THE
;***** COMMUNICATIONS CHANNEL UPDATING CRC

RCVCHR:	PUSHJ	P,RCVBCC	;GET A BYTE
	  POPJ	P,		;NONE THERE
	MOVE	T1,C		;GET CHAR
	XOR	T1,CRC		;MAKE AN INDEX
	ANDI	T1,377		;JUST 8 BITS
	LSH	CRC,-10		;SHIFT IT
	XOR	CRC,CRCTAB(T1)
	JRST	CPOPJ1

;***** ROUTINE TO SEND A CHAR IN "T1" AND UPDATE CRC

SNDCHR:	PUSH	P,T1		;SAVE CHAR
	PUSHJ	P,PUTCHR	;SEND IT
	POP	P,T1		;RESTORE CHAR
	XOR	T1,CRC		;COMPUTE CRC
	ANDI	T1,377		;8 BITS
	LSH	CRC,-10		;MOVE IT UP A BIT
	XOR	CRC,CRCTAB(T1)	;LOOK UP TABLE ENTRY
	POPJ	P,


;***** ROUTINE TO INITIALIZE PROTOCOL. CALLED AFTER A
;***** "STACK" HAS BEEN RECEIVED. RESETS ALL POINTERS
;***** AND VARIABLES.

INITPR:	MOVEI	T1,ZEROA	;SET UP TO CLEAR LINE STAT COUNTS
	HRLS	T1		;COPY ADDRESS TO BOTH
	AOS	T1		;MAKE A BLT POINTER
	SETZM	ZEROA		;CLEAR THE FIRST WORD
	BLT	T1,ZEROAE	;CLEAR THEM ALL
	MOVEI	T1,FIRBUF	;GET ADDRESS OF THE FIRST BUFFER
	MOVEI	T2,BCT		;NUMBER OF OUTPUT BUFFERS
BUFZR1:	SETZM	BUFMES(T1)	;CLEAR THE MESSAGE NUMBER
	MOVE	T1,(T1)		;GET THE NEXT BUFFER
	SOJG	T2,BUFZR1	;LOOP UP
	SETZM	LSTNAK		;CLEAR NAK COUNT
	SETZM	LASNAK		;LAST NAK REASON
	SETZM	LSTACK		;FLOAT THE MESSAGE NUMBER
	SETZM	LSTREC		;FOR BOTH ENDS
	SETZM	LSTSNT		;COMPLETELY
	SETZM	BUSY
	SETZM	BUSY+1		;WE ARE NOT BUSY
	SETZM	TNSTXT		;SO DO NOT SEND ANYTHING
	MOVEI	T1,1		;INITIALISE NEXT MESS NO
	MOVEM	T1,NXTMES	;YES
	TRZ	F,F.ACK+F.NAK	;CLEAR SOME FLAGS
	MOVEI	C,377		;GENERATE INITIAL CRC TABLE
CRCNXT:	MOVEI	T2,7		;HERE ONCE FOR EACH BYTE
	MOVE	CRC,C		;GET CURRENT CHAR
CRCSHF:	LSHC	CRC,-1		;SHIFT IT AND 
	SKIPGE	CRC+1		;CHECK RIGHT END BIT
	XORI	CRC,120001	;HERE IF BIT WAS ON
	SOJGE	T2,CRCSHF	;NEXT BIT
	MOVEM	CRC,CRCTAB(C)	;STORE CRC
	SOJGE	C,CRCNXT	;NEXT BYTE
	TRO	F,F.REP+F.TTYNH	;SET TO SEND A REP
	MOVEI	T1,RCVMES	;INITIALISE INPUT ROUTINE
	MOVEM	T1,LISTNP	;POINTER
	PUSHJ	P,TTOINI	;INITIALISE TTY OUTPUT
REPSET:	MOVEI	T1,REPNO	;NO. OF REPS WITHOUT ACK
	MOVEM	T1,NOREPS	;SAVE IT
	POPJ	P,		;RETURN

;***** ROUTINE TO SEND A "NAK"

SNDNAK:	MOVE	T1,NAKRES	;GET REASON FOR NAK
	MOVEM	T1,CC2RES	;SAVE IT
	MOVEI	T2,NAK		;MAKE A NAK
	AOS	NAKOCT		;COUNT THEM
SNDANK:	MOVEM	T2,SNDCC1	;SAVE CODE
	SETZM	CRC		;CLEAR CRC
	PUSHJ	P,SNDENQ	;START WITH AN ENQ
	MOVE	T1,SNDCC1	;GET ACK OR NAK
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,CC2RES	;NEXT CHAR
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,LSTREC	;GET MESSAGE NUMBER RECEIVED
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,LSTSNT	;GET MESSAGE NUMBER SENT
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,OSTNNO	;GET STATION NUMBER
	PUSHJ	P,SNDCHR	;SEND IT
	TRO	F,F.USFL	;WE DID SOMETHING USEFUL
	PUSHJ	P,SNDCRC	;SEND CRC
	JRST	SHOUT		;GO ROUND AGAIN

;***** ROUTINE TO SEND CRC CHECK CHARACTERS

SNDCRC:	ROT	CRC,-10		;GET BCC0
	MOVE	T1,CRC		;SET FOR OUTPUT
	PUSHJ	P,PUTCHR	;SEND IT
	ROT	CRC,10		;GET OTHER HALF
	MOVE	T1,CRC		;AND SET TO SEND IT
	PUSHJ	P,PUTCHR	;SEND IT
	JRST	PUTOUT		;TRANSMIT IT

;***** ROUTINE TO SEND A "REP"

SNDREP:	MSTIME AC1,
	MOVEM	AC1,REPTIM	;SAVE IT
	TLNE	F,F.STPH	;START PHASE?
	JRST	SNDSTR		;SEND START INSTEAD
	SETZM	CC2RES
	MOVEI	T2,REP		;MAKE A REP
	AOS	REPOCT		;COUNT REPS
	SOS	NOREPS
	JRST	SNDANK		;SEND IT

;***** ROUTINE TO SEND AN "ACK"

SNDACK:	MOVEI	T2,ACK		;MAKE AN ACK
	AOS	ACKOCT		;COUNT THEM
	PUSHJ	P,REPSET	;WE HAD A REP
	SETZM	CC2RES		;ZERO THIS WORD
	JRST	SNDANK		;SEND IT

;***** ROUTINE TO SEND A START MESSAGE

SNDSTR:	MOVEI	T2,STRT		;MAKE A START
	SETZM	CC2RES
	AOS	STROCT		;COUNT THEM
	JRST	SNDANK		;SEND MESSAGE

;***** ROUTINE TO SEND A SHUTDOWN MESSAGE

SNDSHT:	MOVEI	T2,STRT		;MAKE A SHUTDOWN MESSAGE
	MOVEI	T1,SHT		;SHUTDOWN
	MOVEM	T1,CC2RES	;SAVE IT
	JRST	SNDANK		;GO SEND IT

;***** ROUTINE TO SEND "STACK"

SNDSTK:	MOVEI	T2,STAK		;MAKE A STACK
	SETZM	CC2RES		;WHY NOT
	AOS	STKOCT		;COUNT THEM
	JRST	SNDANK		;GO DO IT

;***** ROUTINE TO SEND "SOH"

SNDSOH:	MOVEI	T1,SOH		;GET SOH
	JRST	SNDCHR		;SEND IT

;***** ROUTINE TO SEND "ENQ"

SNDENQ:	MOVEI	T1,ENQ		;FOR UNUMBERRED MESSAGES
	JRST	SNDCHR		;DO IT


;***** ROUTINE TO SEND MESSAGES IF ANY. IF THERE IS ANY
;***** INPUT DATA FROM ANY SOURCE A MESSAGE IS FORMED AND
;***** TRANSMITTED. THE TRANSMIT ROUTINE WILL ALSO
;***** RE-TRANSMIT ANY MESSAGES AFTER A "NAK".

SNDMES:	PUSHJ	P,GBFFO		;GET A BUFFER FOR OUTPUT MESS.
	  JRST	SNDLL1		;NONE THERE
	TRZ	F,F.GDMS	;RESET FLAG
	SETZM	(D)		;CLEAR ENTRY IN BUFFER
	MOVE	T2,CNTCHR	;GET COUNT OF TTY CHARS--
	CAIG	T2,^D500	;IN OUTPUT BUFFER. ENOUGH ROOM?
	JRST	SNDLL4		;NO--DONT SEND REQUESTS
	MOVE	T2,[0200,,(D)]	;MAKE A BP
	MOVEI	T1,RECTTY	;DATA REQUESTS FOR TTY
	PUSHJ	P,SND2BT	;SEND UP TO 3 REQUESTS
SNDLL4:	SKIPE	(D)		;ANYTHING THERE?
	TRO	F,F.GDMS	;YES--SET TO SEND MESSAGE
	AOBJN	D,.+1		;SHOULDNT BOMB OUT HERE
	MOVSI	T4,-INPRTC	;DO FOR ALL OUTPUTS
	PUSHJ	P,FILLBF	;GO FILL A BUFFER
	  AOBJN	T4,.-1		;DO FOR ALL
	TRNN	F,F.GDMS	;GOOD MESSAGE?
	JRST	SNDLL1		;NO--DONT BOTHER
	HLRES	D		;GET COUNT OF WORDS
	ADDI	D,MSLMAX	;HOW MANY WORDS?
	MOVEM	D,BUFCNT(E)	;SAVE COUNT
	MOVE	T1,NXTMES	;GET ASSIGNED MESSAGE NUMBER
	MOVEM	T1,BUFMES(E)	;SAVE IT
	PUSHJ	P,NXTNUM	;UPDATE NUMBER
	MOVEM	T1,NXTMES	;AND SAVE IT
	JRST	SNDLL1		;GO SEND MESSAGE


;***** HERE TO LOOK FOR AND TRANSMIT ANY MESSAGES

SNDLL1:	MOVEI	T2,FIRBUF	;POINT TO FIRST BUFFER
	MOVE	T1,LSTSNT	;GET LAST MESSAGE SENT
	PUSHJ	P,NXTNUM	;GET NEXT NUMBER
SNDLL3:	CAME	T1,BUFMES(T2)	;MATCH?
	JRST	SNDLL5		;NO--DO NEXT
	MOVEM	T1,LSTSNT	;UPDATE COUNT
	TRZE	F,F.ACK		;PIGGY BACK ANY ACK
	AOS	ACKOCT		;COUNT ACKS
	SETZM	CRC
	PUSHJ	P,SNDSOH	;START WITH SOH
	MOVE	T1,BUFCNT(T2)	;GET CHAR COUNT
	PUSHJ	P,SNDCHR	;SEND CHAR
	MOVE	T1,BUFCNT(T2)	;GET IT AGAIN
	LSH	T1,-10		;GET TOP BITS
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,LSTREC	;DO THE ACK BIT
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,BUFMES(T2)	;GET OUR NUMBER
	PUSHJ	P,SNDCHR	;SEND IT
	MOVE	T1,OSTNNO	;OUR STATION NUMBER
	PUSHJ	P,SNDCHR	;SEND IT
	PUSHJ	P,SNDCRC	;SEND CRC
	SETZM	CRC		;RESET CRC
	MOVN	D,BUFCNT(T2)	;GET COUNT
	HRLZS	D		;IN LEFT HALF
	HRRI	D,BUFBEG(T2)	;POINT TO BUFFER
SNDLL2:	MOVE	T1,(D)		;GET CHARACTER
	PUSHJ	P,SNDCHR	;SEND IT
	AOBJN	D,SNDLL2	;LOOP UP
	PUSHJ	P,SNDCRC	;SEND CRC
	TRO	F,F.USFL	;DONE USEFUL WORK
	POPJ	P,

SNDLL5:	MOVE	T2,(T2)		;GET NEXT BUFFER
	SKIPN	(T2)		;REACHED END?
	POPJ	P,		;ALL DONE
	JRST	SNDLL3		;NO--LOOP UP


;***** ROUTINE TO SEND UP TO 3 DATA REQUESTS. ENTER WITH
;***** "T1" POINTING TO COUNT OF DATA REQUESTS FOR ITEM
;***** AND "T2" CONTAINING A BYTE POINTER FOR RESULTING
;***** COUNT.

SND2BT:	MOVSI	T3,-3		;MAKE POINTER
SNDBL1:	SKIPG	(T1)		;ANY REQUESTS?
	JRST	SNDBL2		;NO MORE
	SOS	(T1)		;DECREMENT
	AOBJN	T3,SNDBL1	;LOOP UP
SNDBL2:	DPB	T3,T2		;SAV FIELD
	POPJ	P,

;***** ROUTINE TO GET AN OUTPUT BUFFER FOR BUILDING A
;***** MESSAGE TO BE SENT. RETURNS .+1 OF NONE AVAILABLE
;***** OR SKIP RETURN IF ONE FOUND. "E" CONTAINS A POINTER
;***** TO THE HEADER AND "D" CONTAINS AN "AOBJN" POINTER
;***** TO THE DATA AREA.

GBFFO:	MOVEI	E,FIRBUF	;POINT TO FIRST ONE
GBFL2:	SKIPE	BUFMES(E)	;GET MESS NO
	JRST	GBFL1		;NOT FREE
	MOVSI	D,-MSLMAX	;COUNT OF SPACE
	HRRI	D,BUFBEG(E)	;MAKE A POINTER
	JRST	CPOPJ1

GBFL1:	MOVE	E,(E)		;POINT TO NEXT
	SKIPN	(E)		;REACHED END?
	POPJ	P,
	JRST	GBFL2		;LOOP UP


;***** ROUTINE TO FILL THE OUTPUT BUFFER WITH DATA. ENTER WITH
;***** "T4" POINTING TO AN INDEX WITHIN THE "INPBYT" TABLE
;***** CONTAINING THE INPUT ROUTINE TO BE USED. THIS
;***** ROUTINE BUILD SUB-BLOCKS CONTAINING A ONE-WORD
;***** HEADER WITH DEVICE CODE IN BITS 0-2 AND A 5 BIT
;***** COUNT IN BITS 3-7. UP TO 32 CHARACTERS FOLLOW THIS
;***** HEADER. A COUNT OF ZERO MEANS ONE CHARACTER-
;***** A COUNT OF 31 MEANS 32 CHARACTERS.

FILLBF:	HRRZM	D,SAVD		;SAVE CURRENT POINTER
	AOBJN	D,.+2		;RUN OUT?
	JRST	FLLP1		;YES
	SETZM	T3		;MAKE A COUNT
FLLP6:	PUSHJ	P,@INPBYT(T4)	;GET A BYTE
	  JRST	FLLP2		;NONE THERE
	MOVEM	T1,(D)		;SAVE IT
	AOBJN	D,.+2		;RUN OUT OF ROOM?
	JRST	FLLP4		;YES
	CAIL	T3,37		;ROOM IN SUB-BLOCK?
	JRST	FLLP7		;NO
	AOJA	T3,FLLP6	;YES--LOOP UP

FLLP1:	HRROI	D,-1(D)		;ADJUST POINTER
	JRST	CPOPJ1		;AND SKIP RETURN

FLLP2:	JUMPE	T3,FLLP3	;ZERO SUB-BLOCK
	SOS	T3		;ADJUST COUNT
FLLP5:	HRRZ	T1,T4		;GET DEVICE TYPE
	LSH	T1,5		;POSITION IT
	ADD	T3,T1		;ADD IN COUNT
	MOVEM	T3,@SAVD	;SAVE COUNT
	TRO	F,F.GDMS	;SET FLAG
	POPJ	P,

FLLP3:	POP	D,SAVD		;YES--POP ON D!!!!
	POPJ	P,		;RETURN

FLLP4:	PUSHJ	P,FLLP5		;FINISH UP
	JRST	CPOPJ1		;AND SKIP

FLLP7:	PUSHJ	P,FLLP5		;CLEAN UP SUB-BLOCK
	JRST	FILLBF

;***** HERE WHEN WE HAVE RECEIVED A BLOCK OF DATA IN
;***** A NUMBERRED MESSAGE. THIS ROUTINE UNPACKS THE
;***** DATA AND CALLS ROUTINES TO DISPOSE OF IT.

INPBUF:	MOVE	T1,LSTREC	;GET LAST MESSAGE RECEIVED
	PUSHJ	P,NXTNUM	;CONVERT TO NEXT NUMBER
	CAME	T1,RECNFD	;THIS MESSAGE MATCH?
	  JRST	[MOVEI	T1,22
		JRST	BADFRM]
	MOVEM	T1,LSTREC	;UPDATE MESSAGE NO
	TRO	F,F.ACK		;SEND ACK
	HLLZ	D,RECCC1	;GET DATA COUNT
	HRRI	D,RECBUF	;POINT TO BUFFER
	LDB	T3,[0200,,RECBUF] ;GET TTY REQUESTS
	ADDB	T3,TNSTTY	;ADD IT IN
	AOBJN	D,INPBL2	;ADVANCE A WORD
	JRST	COMMSD		;TIDY UP
INPBL2:	LDB	X,[0500,,(D)]	;GET WORD COUNT
	LDB	E,[050300,,(D)]	;GET TYPE BITS
INPBL1:	AOBJN	D,.+2		;SHOULD NOT EXHAUST
	JRST	FATAL		;HELL!!!!!!
	MOVE	T1,(D)		;GET BYTE
	PUSHJ	P,@OUTBYT(E)	;DISPOSE OF IT
	SOJGE	X,INPBL1	;DO ALL CHARS
	AOBJN	D,INPBL2	;DO NEXT SUB-BLOCK
	JRST	COMMSD		;TIDY UP

FATAL:	AOS	MAJERR		;COUNT OCCURRENCES
	JRST	COMMSD		;RETURN

;***** ROUTINE TO COMPUTE THE NEXT VALID MESSAGE NUMBER.
;***** ENTER WITH "T1"=CURRENT MESSAGE NUMBER--RETURN
;***** WITH "T1" CONTAINING THE NEXT VALID MESSAGE NUMBER.

NXTNUM:	AOS	T1		;INCREMENT NUMBER
	CAILE	T1,377		;OVER 8 BITS?
	MOVEI	T1,1		;RESET TO 1
	POPJ	P,

;***** ROUTINES TO DISPOSE OF DATA RECEIVED IN MESSAGES.

;***** ROUTINE TO DISPOSE OF TTY DATA

TTYOBT:	AOS	TTYICT		;COUNT CHARS
	TLNN	F,F.PASS	;ARE WE PASSIVE?
	TLNN	F,F.TALK	;TALKING?
	JRST	PTYPUT		;USE PTY
	PUSHJ	P,TYPOUT	;SEND IT TO THE TTY
	  PUSHJ	P,TTYOUT	;PANIC
	POPJ	P,

;***** ROUTINE TO DISPOSE OF PTY OUTPUT

PTYOBT:	PUSHJ	P,TYPOUT	;TYPE CHAR
	  PUSHJ	P,TTYOUT	;PANIC!!!!
	AOS	TTYICT		;COUNT CHARS
	SOSL	PTCNT		;NEED A REQUEST?
	POPJ	P,		;NO
	AOS	RECTTY		;YES
	MOVEI	T1,^D100	;RESET COUNT
	MOVEM	T1,PTCNT	;OF CHARS
	POPJ	P,

;***** ROUTINE TO CHECK TEST DATA RECEIVED

TSTOBT:	AOS	TSTICT		;COUNT CHARS
TSTOL1:	ILDB	T2,TISBP	;GET EXPECTED CHAR
	JUMPE	T2,TSTOL2	;RESET
	CAMN	T1,T2		;WHAT WE EXPECTED?
	POPJ	P,		;YES
	AOS	TSTERC		;COUNT ERRORS
	POPJ	P,
TSTOL2:	MOVE	T2,TISBPI	;RESET BP
	MOVEM	T2,TISBP	;SAVE IT
	JRST	TSTOL1		;LOOP UP


;***** ROUTINE TO DISPOSE OF TEXT DATA RECEIVED.

TXTOBT:	AOS	TXTICT		;COUNT CHARS
	SKIPN	BUSY		;LEGAL OUTPUT?
	POPJ	P,
	AOS	TXTGCT		;COUNT CHARS
	PUSH	P,T1		;SAVE CHAR
	LSH	T1,-4		;GET TOP 4 BITS
	PUSHJ	P,OBT4BT	;OUTPUT IT
	  JFCL			;ERROR!
	POP	P,T1		;GET CHARACTER BACK
	PUSHJ	P,OBT4BT	;OUTPUT IT
	  JFCL
	POPJ	P,		;OK

;***** ROUTINE TO DISPOSE OF CONTROL INFORMATION RECEIVED

CTLOBT:	AOS	CTLICT		;COUNT CHARS
	SOSG	CTLITC		;ANY ROOM?
	JRST	TOOCTL		;NO!!!
	MOVE	T2,CTLIPT	;GET PUTTER
	MOVEM	T1,(T2)		;SAVE CHAR
	AOS	T2		;BUMP POINTER
	CAIN	T2,CTLIBE	;REACHED END?
	MOVEI	T2,CTLIBF	;RESET
	MOVEM	T2,CTLIPT	;PUT IT BACK
	SKIPE	CTLCNT		;ARE WE IN EXTENDED INFO?
	JRST	CHKCTL		;YES
	TRNE	T1,200		;IS THIS SINGLE CHAR CTL?
	JRST	CTLIN		;YES--PROCESS IT
	MOVEM	T1,CTLCNT	;ELSE IT IS A COUNT
	POPJ	P,		;RETURN

CHKCTL:	SOSG	CTLCNT		;IS THIS THE LAST CHAR?
	JRST	CTLIN		;YES--PROCESS IT
	POPJ	P,		;ELSE-CONTINUE

TOOCTL:	AOS	CTLITC		;RESET POINTER
	AOS	CTLTMC		;COUNT ERRORS
	POPJ	P,


;***** ROUTINES TO GET CHARACTERS TO BE SENT IN MESSAGES.

;***** ROUTINE TO GET CONTROL INFORMATION TO BE SENT.

CTLIBT:	MOVE	T2,CTLOGT	;GET GETTER
	CAMN	T2,CTLOPT	;ANYTHING THERE?
	POPJ	P,		;NO
	MOVE	T1,(T2)		;GET CHAR
	AOS	T2		;BUMP POINTER
	CAIN	T2,CTLOBE	;AT END?
	MOVEI	T2,CTLOBF
	MOVEM	T2,CTLOGT	;RESET
	AOS	CTLOTC		;BUMP COUNT
	AOS	CTLOCT		;COUNT CHARS
	JRST	CPOPJ1		;AND SKIP

;***** ROUTINE TO GET TTY CHARACTERS TO BE SENT

TTYIBT:	TLNE	F,F.PASS	;ARE WE PASSIVE?
	POPJ	P,		;FORGET IT
	MOVE	T2,INCPTG	;GET GETTER
	CAMN	T2,INCPTP	;SAME AS PUTTER?
	POPJ	P,		;NOUGHT TO DO LAD
	MOVE	T1,(T2)		;GET CHAR
	AOS	T2		;BUMP GETTER
	CAIN	T2,INBFTE	;AT END?
	MOVEI	T2,INBFTB	;RESET
	MOVEM	T2,INCPTG	;LAY IT DOWN
	AOS	ICTCHR		;RESET COUNT
	AOS	TTYOCT		;COUNT CHARS
	JRST	CPOPJ1		;AND GIVE A SKIP RETURN

;***** ROUTINE TO GET PTY OUTPUT TO BE SENT.

PTYIBT:	JRST	PTYGET

;***** ROUTINE TO GET TEST DATA TO BE SENT.

TSTIBT:	TRNN	F,F.TEST	;ARE WE TESTING?
	POPJ	P,		;NO
	AOS	TSTOCT		;COUNT CHARS
TSTIL1:	ILDB	T1,TOSBP	;GET CHAR
	JUMPN	T1,CPOPJ1	;SKIP RETURN
	MOVE	T1,TISBPI	;RESET BYTE POINTER
	MOVEM	T1,TOSBP
	JRST	TSTIL1		;LOOP UP


;***** ROUTINE TO GET TEXT DATA

TXTIBT:	SKIPN	BUSY+1		;ARE WE BUSY OUTPUTTING?
	POPJ	P,		;NO--NOTHING TO DO
	SKIPE	FILTSN+1	;VIRGIN FILE?
	JRST	NEWFIL		;GO FIND IT
	SKIPN	TNSTXT		;READY TO SEND?
	POPJ	P,		;NO--DONT SEND ANYTHING
	SKIPE	T1,INERCD	;DID WE GET AN ERROR?
	JRST	GETECD		;YES
	AOS	TXTSCT		;COUNT CHARS
	AOS	TXTOCT		;TWICE
	PUSHJ	P,INDATA	;GET A CHARACTER
	  JRST	CPOPJ1		;SKIP RETURN WITH CHAR IN T1
GETECD:	MOVEI	T1,FINLEN	;GET LENGTH OF MESSAGE
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;HELL!!
	MOVEI	T1,CT.FIN	;SEND CONTROL CHAR
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;HELL!!
	MOVE	T1,INERCD	;GET ERROR CODE
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL
	MOVE	A,[401000,,CHKOUT] ;POINT TO CHECKSUM
FLFNL1:	ILDB	T1,A		;GET 8 BITS
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;CANNOT
	TLNE	A,770000	;MORE?
	JRST	FLFNL1		;LOOP UP
	PUSHJ	P,CLSSND	;CLOSE UP THE FILE
	SETOM	FILTSN+1	;SET FLAG
	SETZM	TNSTXT		;CLEAR REQUESTS
	TLNE	F,F.PASS	;PASSIVE?
	POPJ	P,		;AND NON-SKIP RETURN
	TYPE	<
FINISHED SENDING FILE >
	TYPE1	LCOROT+STGADR	;PRINT IT
	TYPE	<
TO >
	TYPE1	LCHSOT+STGADR
	JRST	SDSTSP		;GO PRINT STATISTICS

;***** ROUTINE TO PRINT DATA TRANSMITTED STATISTICS

SDSTSP:	TYPE	<
DATA TRANSMITTED=>
	MOVE	A,TXTSCT	;GET CHARS
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	< CHARS IN >
	MSTIME	A,
	SUB	A,TMESNT	;GET TIME
	IDIVI	A,^D1000
	PUSH	P,A		;SAVE SECONDS
	IDIVI	A,^D60		;MAKE MINUTES
	CAIL	B,^D30		;ROUND UP?
	ADDI	A,1		;YES
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	< MINUTES (>
	MOVE	A,TXTSCT	;GET CHARS
	POP	P,B		;RESTORE TIME
	IDIV	A,B
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	< CHARS PER SECOND)
>
	POPJ	P,

	FINLEN==6		;NUMBER OF CHARS IN FINUP


;***** HERE TO FIND NEXT FILE WHICH MATCHES THE
;***** OUTPUT FILE SPECIFICATION.

NEWFIL:	PUSHJ	P,NXTSPC	;GET NEXT SPEC WHICH MATCHES
	  JRST	EXHIST		;EXHAUSTED
	MOVEI	A,CT.FLM	;HERE IS MY LOCAL SPEC
	MOVEI	B,LCOROT	;ADDRESS OF OUR SPEC
	PUSHJ	P,FILCTL	;SEND IT
	  JRST	CTLFUL		;CANNOT
	SETZM	FILTSN+1	;CLEAR FLAG
	SETZM	INERCD		;CLEAR ERROR CODE
	POPJ	P,		;WAIT FOR REPLY

;***** HERE WHEN NO MORE FILES TO SEND

EXHIST:	SETZM	FILTSN+1	;CLEAR FLAG
	SETZM	BUSY+1		;BOTH OF THEM
	SETZM	LCOROT+STGADR	;CLEAR STRING
	MOVEI	T1,CT.LDN	;TELL HIM
	PUSHJ	P,CTLPUT	;SEND MESSAGE
	  JRST	NRMCTL		;BOMB!
	TLNN	F,F.PASS
	TYPE	<
[OUTPUT CHANNEL IDLE]
>
	POPJ	P,

;***** ROUTINE TO GET AN 8 BIT BYTE FROM THE INPUT FILE

INDATA:	PUSHJ	P,IBT4BT	;GET FOUR BITS IN T1
	  JRST	EOFIN		;GOT ERROR OR END OF FILE
	PUSH	P,T1		;SAVE BYTE
	PUSHJ	P,IBT4BT	;GET ANOTHER 4 BITS
	  JRST	EOFIN1		;GOT ERROR OR END OF FILE
	POP	P,T2		;RESTORE FIRST BYTE
	LSH	T2,4		;MOVE IT BABY
	IOR	T1,T2		;AND MAKE A BIG ONE
	POPJ	P,		;AND NON-SKIP

;***** HERE ON A FILE ERROR OR EOF

EOFIN1:	MOVEM	T1,INERCD	;SAVE ERROR CODE
	POP	P,T1		;GET ODD FOUR BITS
	LSH	T1,4		;POSITION IT
	POPJ	P,		;AND RETURN

EOFIN:	MOVEM	T1,INERCD	;SAVE ERROR CODE
	JRST	CPOPJ1		;AND SKIP


;***** ROUTINE TO GET A FOUR BIT BYTE

IBT4BT:	MOVE	T1,IBT4BP	;GET BYTE POINTER
	TLNN	T1,770000	;STILL MORE LEFT?
	JRST	IBT4B3		;NO--REFILL IT
IBT4B1:	ILDB	T1,IBT4BP	;GET FOUR BIT BYTE
	JRST	CPOPJ1		;AND SKIP
IBT4B3:	IFE DEC20,<
	SOSG	INCHBF+2	;MORE WORDS?
	JRST	IBT4B4		;GET ONE MORE BLOCK
IBT4B2:	ILDB	AC2,INCHBF+1	;GET 36 BIT BYTE
	>;END DEC20 CONDITIONAL
IFN DEC20,<MOVE	AC1,INPJFN	;GET INPUT JFN
	BIN
	  ERJMP	IBT4B4		;EOF OR ERROR
	>;END DEC20 CONDITIONAL
	MOVEM	AC2,INPWRD	;SAVE IT
	MOVE	T1,[440400,,INPWRD] ;RESET BYTE POINTER
	MOVEM	T1,IBT4BP	;AND SAVE IT
	JRST	IBT4B1		;GO LOOP UP
IFE DEC20,<
IBT4B4:	IN	10,		;GET A BLOCK
	  JRST	IBT4B2		;OK
	STATO	10,40000	;EOF?
	>;END DEC20 CONDITIONAL
IFN DEC20,<
IBT4B4:	CAIE	AC2,IOX4	;EOF?
	>;END DEC20 CONDITIONAL
	SKIPA	T1,[EXP 1]	;NO ERROR
	SETZM	T1		;EOF
	POPJ	P,		;NON-SKIP WITH ERROR CODE

;***** ROUTINE TO OUTPUT A 4 BIT BYTE

OBT4BT:	MOVE	T2,OBT4BP	;GET BYTE POINTER
	TLNN	T2,770000	;MORE ROOM?
	PUSHJ	P,OBT4B3	;NO
OBT4B1:	IDPB	T1,OBT4BP	;SAVE CHARACTER
	JRST	CPOPJ1		;SKIP RETURN
IFE DEC20,<
OBT4B3:	SOSG	OTCHBF+2	;ROOM IN BUFFER?
	JRST	OBT4B4		;NO
OBT4B2:	MOVE	T2,OTPWRD	;GET OUR WORD
	IDPB	T2,OTCHBF+1	;SAVE IT
	>;END OF DEC20 CONDITIONAL
IFN DEC20,<
OBT4B3:	MOVE	AC1,OUTJFN	;OUTPUT JFN
	MOVE	AC2,OTPWRD	;GET WORD TO OUTPUT
	BOUT			;SEND IT
	  ERJMP	OBT4B4		;ERROR
	>;END OF DEC20 CONDITIONAL
	MOVE	T2,[440400,,OTPWRD] ;RESET BYTE POINTER
	MOVEM	T2,OBT4BP	;SAVE IT
	SETZM	OTPWRD
	POPJ	P,		;RETURN
OBT4B4:	IFE DEC20,<
	OUT	11,
	  JRST	OBT4B2		;OK
	>;END DEC20 CONDITIONAL
	POP	P,(P)		;GO UP A LEVEL
	POPJ	P,


;***** HERE TO CLOSE UP FILE

CLSSND:	IFE DEC20,<
	CLOSE	10,		;CLOSE INPUT FILE
	RELEASE	10,
	>;END DEC20 CONDITIONAL
IFN DEC20,<
	MOVE	AC1,INPJFN	;SET TO CLOSE INPUT FILE
	CLOSF
	  JFCL
	SETZM	INPJFN
	>;END DEC20 CONDITIONAL
	POPJ	P,		;AND FINISH

;***** ROUTINE TO CLOSE UP "GET" FILE

CLSGET:	PUSHJ	P,OBT4B3	;WRITE OUT LAST WORD
IFE DEC20,<
	CLOSE	11,		;CLOSE UP
	STATO	11,760000	;ERRORS?
	AOS	(P)		;IF NOT--SKIP
	RELEAS	11,
	POPJ	P,
	>;END DEC20 CONDITIONAL
IFN DEC20,<
	MOVE	AC1,OUTJFN	;SET TO CLOSE OUTPUT FILEOUT
	CLOSF			;DO IT
	  ERJMP	CPOPJ		;ERROR
	SETZM	OUTJFN
	JRST	CPOPJ1
	>;END DEC20 CONDITIONAL
;***** ROUTINE TO GET FILESPEC AND INITIALISE TO SEND
IFE DEC20,<
NXTSPC:	PUSHJ	P,SAVACS	;SAVE THE IMPORTANT ACS
	SKIPN	SNDVED+FILNAM	;BEEN HERE BEFORE?
	JRST	SNDFL1		;NO
	SETZM	SNDVED+FILNAM	;YES--CLEAR US DOWN
	POPJ	P,
SNDFL1:	MOVEI	A,GNOROT	;ADDRESS OF OUR STRING
	PUSHJ	P,RDSTNG	;SET TO READ IT
	MOVEI	X,SNDVED	;ADDRESS OF BLOCK
	PUSHJ	P,FILSPC	;GET FILE SPEC
	  JRST	SNDFLB		;BAD SPEC
	SETZM	INCORE		;RESET INPUT
	OPEN	10,SNDVED	;OPEN DEVICE
	  JRST	SDFLE1
	LOOKUP	10,SNDVED+FILBLK ;FIND FILE
	  JRST	SDFLE2		;NOT THERE
	MOVEI	A,SNDARE	;POINT TO OUR BUFFER
	MOVEM	A,.JBFF##		;FOOL MONITOR
	INBUF	10,2		;TWO OF THEM
	SETZM	TXTSCT		;CLEAR COUNT
	MSTIME	A,		;GET TIME
	MOVEM	A,TMESNT	;SAVE IT
	MOVEI	A,LCOROT	;ADDRESS FOR OUTPUT STRING
	PUSHJ	P,WTSTNG	;GO SET TO WRITE IT
	MOVEI	X,SNDVED	;ADDRESS OF FILE BLOCK
	PUSHJ	P,PNTSPC	;PRINT IT TO CORE
	MOVEI	T1,0		;MAKE ASCIZ
	PUSHJ	P,OUTP
	PRINT	<
SIZE (IN 8 BIT CHARACTERS) >
	MOVE	A,SNDVED+FILLEN ;GET FILE LENGTH
	LSH	A,2		;MULTIPLY BY 4
	MOVE	T1,SNDVED+FILLEN ;GET LENGTH AGAIN
	LSH	T1,-1		;HALVE IT
	ADD	A,T1		;ADD IT IN
	PUSHJ	P,DECPNT	;PRINT IT
	MOVEI	T1,0		;FINISH STRING
	PUSHJ	P,OUTP
	SETZM	IBT4BP		;CLEAR FUDGE BYTE POINTER
	JRST	CPOPJ1		;AND SKIP
>

;***** SAME AS ABOVE BUT FOR TOPS20

IFN DEC20,<
NXTSPC:	PUSHJ	P,SAVACS	;SAVE IMPORTANT AC'S
	SKIPN	LCOROT+STGADR	;ALREADY BEEN HERE ?
	JRST	SNDFL1		;NO, SO GO
	SETZM	LCOROT+STGADR	;CLEAR IT OUT
	POPJ	P,		;RETURN
SNDFL1:	MOVEI	B,LCOROT	;ADDRESS TO WRITE SPEC
	MOVE	C,LSTCHR	;GET LAST CHARACTER
	TLZ	C,C.MOVP	;MAKE SURE WE ARE NOT TIDY
	MOVEM	C,LSTCHR	;SAVE IT
	MOVEI	A,GNOROT	;ADDRESS OF FILE SPEC
	PUSHJ	P,RDSTNG	;SET TO READ FROM CORE
	PUSHJ	P,FILSTG	;WRITE IT TO OUR ADDRESS
	  JFCL			;THIS SHOULD NEVER HAPPEN SINCE WE ARN'T TIDY
	SETZM	INCORE		;RESET WERE WE ARE READING FROM
	MOVE	AC1,[1B17]	;SHORT FORM GTJFN
	HRROI	AC2,LCOROT+STGADR  ;WHERE THE ASCIZ STRING RESIDES
	GTJFN			;GET THE JFN
	  ERJMP	SDFLE2		;NOT THERE ?
	MOVEM	AC1,INPJFN	;SAVE THE JFN
	MOVE	AC2,[^D36B5!10B9!1B19] ;36 BIT IMAGE MODE, READ ACCESS
	OPENF			;OPEN THE FILE
	  ERJMP	SDFLE1		;CAN'T OPEN
	SETZM	TXTSCT		;CLEAR COUNT
	SETZM	IBT4BP		;CLEAR FUDGE BP
	HRROI	AC1,TTYSTG+STGADR
	MOVE	AC2,INPJFN	;GET THE JFN
	MOVE	A,[111110,,000001]
	JFNS			;TRANSLATE TO STRING
	MOVEI	A,TTYSTG	;ADDRESS OF FILE
	PUSHJ	P,RDSTNG	;READ FROM CORE
	MOVEI	B,LCOROT	;WHERE TO PUT IT
	MOVE	C,LSTCHR
	TLZ	C,C.MOVP
	MOVEM	C,LSTCHR
	PUSHJ	P,FILSTG	;WRITE IT TO CORE
	JFCL
	MSTIME	AC1,
	MOVEM	AC1,TMESNT	;SAVE IT
	JRST	CPOPJ1		;SKIP RETURN
>

;***** ROUTINE TO GENERATE LOCAL FILESPEC FOR ENTER
IFE DEC20,<
NEWLIF:	PUSHJ	P,SAVACS	;SAVE SOME ACS
	MOVEI	A,GNORIN	;ADDRESS OF GENERAL SPEC
	PUSHJ	P,RDSTNG	;SET TO READ IT
	MOVEI	X,GETVED	;ADDRESS OF BLOCK FOR FILE
	PUSHJ	P,FILSPC	;GET FILE
	  JRST	GETFLB		;BAD
	SETZM	INCORE
	OPEN	11,GETVED	;OPEN IT
	  JRST	GTFLE1		;CANNOT
	ENTER	11,GETVED+FILBLK ;MAKE FILE
	  JRST	GTFLE2
	MOVEI	A,GETARE	;POINT TO OUR BUFFER
	MOVEM	A,.JBFF##		;FOOL MONITOR
	OUTBUF	11,2		;TWO OF THEM
	MOVE	A,[440400,,OTPWRD] ;SET BYTE POINTER
	MOVEM	A,OBT4BP	;SAVE IT
	SETZM	OTPWRD
	SETZM	TXTGCT		;RESET COUNT
	MSTIME	A,		;GET TIME
	MOVEM	A,TMEGET	;SAVE IT
	MOVEI	A,LCORIN	;ADDRESS OF OUR STRING
	PUSHJ	P,WTSTNG	;SET TO WRITE IT
	MOVEI	X,GETVED	;ADDRESS OF FILE BLOCK
	PUSHJ	P,PNTSPC	;PRINT FILE TO CORE
	MOVEI	T1,0
	PUSHJ	P,OUTP		;MAKE ASCIZ
	JRST	CPOPJ1
>


;***** SAME AS ABOVE BUT FOR TOPS20
IFN DEC20,<
NEWLIF:	PUSHJ	P,SAVACS	;SAVE ACS
	MOVEI	A,GNORIN	;ADDRESS OF FILE SPEC
	PUSHJ	P,RDSTNG	;SET TO READ THE STRING
	MOVE	C,LSTCHR	;GET THE LAST CHARACTER AND MAKE SURE
	TLZ	C,C.MOVP	;THAT WE ARE NOT TIDY
	MOVEM	C,LSTCHR
	MOVEI	B,LCORIN	;ADDRESS TO PUT THE FILE SPEC
	PUSHJ	P,FILSTG	;GET THE STRING
	  JFCL			;NEVER HAPPEN CAPTAIN
	SETZM	INCORE		;CLEAR THE IN CORE INDICATOR
	MOVE	AC1,[1B17]	;SHORT FORM GTJFN
	HRROI	AC2,LCORIN+STGADR
	GTJFN			;GET THE JFN
	  ERJMP	GTFLE1		;CAN'T DO IT ?
	MOVEM	AC1,OUTJFN	;SAVE THE JFN
	MOVE	AC2,[^D36B5!1B0!10B9!1B19!1B20] ;36 BIT IMAGE MODE
	OPENF			;OPEN THE FILE
	  ERJMP	GTFLE2		;SOMETHING IS WRONG
	MOVE	A,[440400,,OTPWRD] ;SET UP BYTE POINTER
	MOVEM	A,OBT4BP	;SAVE IT
	SETZM	OTPWRD
	SETZM	TXTGCT		;CLEAR THE COUNT
	MOVE	AC2,AC1		;JFN TO AC2
	HRROI	AC1,TTYSTG+STGADR
	MOVE	A,[111110,,000001]
	JFNS
	MOVEI	A,TTYSTG
	PUSHJ	P,RDSTNG
	MOVEI	B,LCORIN
	MOVE	C,LSTCHR
	TLZ	C,C.MOVP
	MOVEM	C,LSTCHR
	PUSHJ	P,FILSTG
	JFCL
	MSTIME	AC1,
	MOVEM	AC1,TMEGET	;SAVE IT
	JRST	CPOPJ1		;SKIP RETURN
>

;***** ROUTINE TO SET UP TO INPUT FROM A STRING INSTEAD OF
;***** AN INPUT DEVICE.

RDSTNG:	ADDI	A,2		;POINT TO ACTUAL STRING
	HRLI	A,440700	;MAKE A BP
	MOVEM	A,INCORE	;SAVE IT
	POPJ	P,

;***** ROUTINE TO SET UP TO OUTPUT TO A STRING INSTEAD OF
;***** AN OUTPUT DEVICE.

WTSTNG:	ADDI	A,STGADR	;POINT TO STRING
	HRLI	A,440700	;MAKE A BP
	MOVEM	A,OTCORE	;SAVE IT
	MOVEI	A,-1(A)		;GET ADDRESS OF COUNT
	MOVEM	A,OTCNT		;SAVE IT
	SETZM	(A)		;AND CLEAR IT
	POPJ	P,


;***** HERE WHEN DEVICE NOT AVAILABLE OR FILE NOT THERE

SDFLE2:	SKIPA	T1,[EXP 2]	;FILE NOT THERE
SDFLE1:	MOVEI	T1,1		;DEVICE NOT AVAILABLE
	POPJ	P,		;NON SKIP

;***** HERE WHEN FILESPEC ERROR ON LOOKUP

SNDFLB:	SETZM	INCORE		;RESET
	SETOM	SNDVED+FILNAM	;SET FLAG
	MOVEI	T1,0		;ERROR CODE
	POPJ	P,

;***** HERE WHEN BAD FILESPEC ON ENTER

GETFLB:	SETZM	INCORE		;RESET INPUT
	MOVEI	T1,0		;ERROR CODE
	POPJ	P,

;***** OTHER ERRORS

GTFLE2:	SKIPA	T1,[EXP 2]
GTFLE1:	MOVEI	T1,1
	POPJ	P,


;***** ROUTINE TO PUT CONTROL INFORMATION INTO CONTROL
;***** BUFFER FOR EVENTUAL TRANSMISSION.

CTLPUT:	SOSG	CTLOTC		;ROOM?
	JRST	CTLTOO		;NO
	MOVE	T2,CTLOPT	;GET PUTTER
	MOVEM	T1,(T2)		;SAVE CHAR
	AOS	T2
	CAIN	T2,CTLOBE	;REACHED END?
	MOVEI	T2,CTLOBF	;YES--RESET
	MOVEM	T2,CTLOPT	;AND RESTORE
	JRST	CPOPJ1		;SKIP RETURN

CTLTOO:	AOS	CTLOTC		;RESTORE COUNT
	POPJ	P,

;***** ROUTINE TO GET CONTROL INFORMATION RECEIVED FROM
;***** THE INPUT CONTROL BUFFER.

CTLGET:	MOVE	T2,CTLIGT	;GET GETTER
	CAMN	T2,CTLIPT	;ANYTHING THERE?
	POPJ	P,		;NO
	MOVE	T1,(T2)		;GET CHAR
	AOS	T2
	CAIN	T2,CTLIBE	;AT END?
	MOVEI	T2,CTLIBF	;RESET
	MOVEM	T2,CTLIGT
	AOS	CTLITC		;BUMP COUNT
	JRST	CPOPJ1		;AND SKIP

;***** ROUTINE TO HANDLE CONTROL INFORMATION RECEIVED
;***** IN DATA MESSAGES.

CTLIN:	PUSHJ	P,CTLGET	;GET CHAR
	  POPJ	P,		;NONE THERE?
	TRZE	T1,200		;SINGLE CHAR?
	JRST	CTLDIS		;GO DISPATCH
	SOS	T1		;DECREMENT COUNT
	MOVEM	T1,EXTCTL	;SAVE IT
	PUSHJ	P,CTLGET	;GET CHAR
	  POPJ	P,
	TRZN	T1,200		;CONTROL CHAR?
	POPJ	P,		;BLOODY HELL!!
CTLDIS:	PUSH	P,D		;SAVE AOBJN POINTER
	PUSHJ	P,@CTLTAB(T1)	;DISPATCH ON CONTROL
	POP	P,D
	POPJ	P,


;***** ROUTINE TO CHECK FOR CONSOLE TTY INPUT DURING LINKUP.
;***** THIS COULD BE VIRTUAL TERMINAL SUPPORT OR COMMAND
;***** CHARACTERS FROM THE TERMINAL.

TTYSRV:	PUSHJ	P,TTOSTR	;GO START UP THE TTY
	  JFCL			;FOR GET IT
	TLNE	F,F.WVRT+F.TALK	;VIRTUAL TERMINAL
	JRST	TRMVRT		;YES--SERVICE CHAR
	SKPINL			;LINE TYPED?
	  POPJ	P,		;NOT YET
	JRST	LNKCOM

;***** HERE TO GET DATA FROM VIRTUAL TERMINAL AND QUEUE IT FOR
;***** OUTPUT IN DATA MESSAGES.

TRMVRT:
IFE DEC20,<
	SKPINC			;CHAR THERE?
	POPJ	P,		;NO
	TTCALL	0,C		;GET CHARS DIRECT
>
IFN DEC20,<
	PUSH	P,AC1		;SAVE SOME AC'S
	EXCH	C,AC2
	MOVEI	AC1,.PRIIN	;MY TTY
	SIBE			;ANY CHARACTERS ?
	JRST	TRMVRL
	POP	P,AC1
	EXCH	AC2,C
	POPJ	P,
TRMVRL:	BIN
	  JFCL
	EXCH	AC2,C
	POP	P,AC1
>
TRMVRS:	ANDI	C,177		;JUST 7 BITS
	CAIN	C,VRTBRK	;BREAK CHAR?
	JRST	BRKVRT		;GO BACK TO COMMAND MODE
	PUSHJ	P,VRTIN		;STORE CHAR
	JRST	TTYSRV		;GET NEXT

VRTIN:	SOSG	ICTCHR		;ANY ROOM?
	JRST	BELLIT		;RING BELL
	MOVEM	C,@INCPTP	;SAVE CHAR
	AOS	C,INCPTP	;GET POINTER
	CAIN	C,INBFTE	;REACHED END?
	MOVEI	C,INBFTB	;RESET
	MOVEM	C,INCPTP	;SAVE POINTER
	POPJ	P,

BELLIT:	AOS	ICTCHR		;RESET COUNTER
	MOVEI	C,BELL		;SEND A BELL
	TLNN	F,F.PASS	;ARE WE PASSIVE?
	TTCALL	1,C		;DIRECTLY
	POPJ	P,


;***** HERE TO BREAK FROM "TALK" OR VIRTUAL TERMINAL SUPPORT

BRKVRT:	TLZN	F,F.WVRT	;ARE WE VIRTUAL?
	JRST	TLKBRK		;NO--BREAK TALK
	TYPE	<
[BREAKING FROM VIRTUAL TTY SUPPORT]
*>
	MOVEI	T1,CT.NVT	;NO VIRTUAL
	JRST	BTKBRK		;BREAK IT
TLKBRK:	TLZN	F,F.TALK	;ARE WE TALKING?
	POPJ	P,		;NO!!
	TYPE	<
[BREAKING FROM TTY CONNECTION]
*>
BRKTLK:	MOVEI	T1,CT.NTK	;STOP TALKING
BTKBRK:	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
    IFE TYM10,<
	MOVE	A,[3,,B]	;SET NO SLAVE
	MOVEI	B,2004
	MOVE	C,OURINX	;POINT TO OUR TERMINAL
	SETZM	D		;SET TO CLEAR
	TRMOP.	A,
	  JFCL
    > ; End IFE TYM10
    IFN TYM10,<
	HRROI	A,.AXCFS	; -1,,change-port-status
	Auxcal	A,0		; reset all to clear
    > ; End IFN TYM10
	POPJ	P,

NRMCTL:	TYPE	<
CONTROL BUFFER OVERFLOW!!!!!
>
IFE DEC20,<
	EXIT
>
IFN DEC20,<
	TLNN	F,F.PASS	;ARE WE PASSIVE ?
	HALTF			;NOPE
	SETOM	AC1		;YES, LOGOUT
	LGOUT
>

;***** ROUTINES TO SERVICE THE PTY

;***** ROUTINE TO SEND CHAR IN "T1" TO PTY
PTYPUT:	TLNE	F,F.HVRT	;IS HE VIRTUAL?
	SKIPN	PTYFLG		;GOT PTY?
	POPJ	P,		;NO
	SOSG	PTYOBF+2	;ROOM?
	PUSHJ	P,DUMPT		;NO--MAKE SOME
	IDPB	T1,PTYOBF+1	;SEND CHAR
DUMPT:	OUTPUT	4,		;SEND CHARS
	POPJ	P,		;AND RETURN

;***** ROUTINE TO GET A CHAR FROM THE PTY IF ANY
PTYGET:	TLNE	F,F.HVRT	;IS HE VIRTUAL?
	SKIPN	PTYFLG		;GOT PTY?
	POPJ	P,		;NO
	SOSG	PTYIBF+2	;CHARS THERE?
	PUSHJ	P,GETPT		;NOO-GET SOME
	SOSL	PTCNT		;SEE IF WE CAN SEND
	JRST	PTGOK		;YUP!!
	SKIPGE	TNSTTY		;MORE REQUESTS?
	JRST	REDPTY		;NO
	MOVEI	T1,^D100	;RESET COUNT
	MOVEM	T1,PTCNT
	SOS	TNSTTY		;DECREMENT REQUESTS
PTGOK:	ILDB	T1,PTYIBF+1	;GET CHAR
	JUMPE	T1,PTYGET	;IGNORE NULLS
	CAIN	T1,EOT		;AND EOTS
	JRST	PTYGET		;FOR SOME REASON
	JRST	CPOPJ1		;AND SKIP RETURN

REDPTY:	AOS	PTCNT		;RESET COUNT
	AOS	PTYIBF+2	;BOTH OF THEM
	POPJ	P,

GETPT:	STATO	4,2000		;OUTPUT?
	JRST	PTYPOP		;NO
	INPUT	4,
	SKIPG	PTYIBF+2	;DID WE GET SOME?
PTYPOP:	POP	P,(P)
	POPJ	P,

;***** ROUTINE TO OUTPUT CHAR TO CONSOLE TTY WITHOUT GOING
;***** INTO "TO" WAIT. CHARACTERS ARE PUT INTO A LARGE RING
;***** BUFFER AND THIS IS UNLOADED TO THE TTY IN SMALL
;***** "BURSTS|" SO AS NOT TO HANG THE PROGRAM.

TYPOUT:	SOSG	CNTCHR		;ANY ROOM?
	JRST	BUFFUL		;NO
	PUSH	P,T2		;SAVE A REGISTER OR TWO
	PUSH	P,T3
	IDPB	T1,PUTPTR	;STORE CHAR
	MOVE	T2,[440700,,OTTBUF] ;SET TO RESET
	HRRZ	T1,PUTPTR	;GET ADDRESS
	CAILE	T1,OTTLM+OTTBUF	;REACHED LIMIT?
	MOVEM	T2,PUTPTR	;SAVE IT
TTOSTE:
    IFE TYM10,<		; Let it block for now!
	MOVEI	T1,2		;FUNCTION CODE FOR OUTPUT
	MOVEM	T1,OURBLK	;BUSY
	MOVE	T1,[XWD 2,OURBLK]
	TRMOP.	T1,		;OUTPUT IN PROGRESS?
	  SKIPA			;NO
	JRST	RSTPJ		;SKIP RETURN
    > ; End IFE TYM10
	MOVE	T2,GETPTR	;GET THE POINTER
	MOVEI	T3,MAXTYO	;GET MAX COUNT
TYPLP1:	CAMN	T2,PUTPTR	;REACHED END YET?
	JRST	NOMRCH		;YES
	ILDB	T1,T2		;GET CHAR
	PUSHJ	P,TTYOUT	;TYPE IT
	AOS	CNTCHR		;ALLOW ROOM
	HRRZ	T1,T2		;GET ADDRESS OF BP
	CAILE	T1,OTTLM+OTTBUF	;REACHED END?
	MOVE	T2,[440700,,OTTBUF] ;RESET
	SOJG	T3,TYPLP1	;DO ALL
NOMRCH:	MOVEM	T2,GETPTR	;UPDATE POINTER
RSTPJ:	POP	P,T3		;RESTORE ACS
	POP	P,T2
	JRST	CPOPJ1


;***** HERE TO TRY TO SEND MORE CHARACTERS TO THE CONSOLE

TTOSTR:	PUSH	P,T2
	PUSH	P,T3
	JRST	TTOSTE		;GO AND TRY TO OUTPUT

BUFFUL:	AOS	CNTCHR		;RESET COUNTER
	POPJ	P,		;NON-SKIP RETURN

;***** ROUTINE TO INITIALISE THE TELETYPE OUTPUT BUFFER

TTOINI:	MOVE	T1,[440700,,OTTBUF]
	MOVEM	T1,PUTPTR	;SET GIVER AND TAKER--
	MOVEM	T1,GETPTR	;TO START OF BUFFER
	MOVEI	T1,OTTLM*5	;COUNT OF CHARS
	MOVEM	T1,CNTCHR
	POPJ	P,

;***** GENERAL ROUTINES FOR COMMAND INTERFACE.

;;***** ROUTINE TO GET AN OCTAL NUMBER  IN T1

GETOCT:	SETZM	T1		;CLEAR FOR RESULT
OCTLP:	PUSHJ	P,CHRIN		;GET CHAR
	TLNN	C,C.OCT		;OCTAL?
	POPJ	P,		;NO
	LSH	T1,3
	ADDI	T1,-60(C)	;PUT IN DIGIT
	JRST	OCTLP

;***** ROUTINE TO GET A DECIMAL NUMBER IN "A"

GETNUM:	SETZM	A		;CLEAR FOR RESULT
NUMLP:	PUSHJ	P,CHRIN		;GET CHAR
	TLNE	C,C.BRK		;BREAK?
	POPJ	P,		;ALL DONE
	TLNN	C,C.NUM		;NUMERIC?
	JRST	ERROR3		;NO
	IMULI	A,^D10		;PREPARE FOR RESULT
	ADDI	A,-60(C)	;ADD IN DIGIT
	JRST	NUMLP		;GO ROUND
ERROR3:	TYPE	<
NON-NUMERIC CHAR -- START AGAIN
>
	PUSHJ	P,TIDY		;TIDY UP
	JRST	GETNUM		;GO ROUND AGAIN

;***** ROUTINE TO GET AND JUNK CHARACTERS UNTIL "EOL" FOUND

TIDY:	MOVE	C,LSTCHR	;GET LAST CHAR
TIDLP1:	TLNE	C,C.MOVP	;TIDY ALREADY?
	POPJ	P,		;YES
	PUSHJ	P,CHRIN		;GET NEXT CHAR
	JRST	TIDLP1

;***** ROUTINE TO GET SIX SIXBIT CHARS FROM TTY IN T1

GETSIX:	SETZM	T1		;FOR RESULT
	MOVE	T2,[440600,,T1]	;SET UP BP
SIXLP:	PUSHJ	P,CHRIN		;GET CHAR
	TLNN	C,C.NUM!C.ALP	;ALPHANUMERIC?
	POPJ	P,		;NO
	SUBI	C,40		;SIXBITIT
	TLNE	T2,770000	;ROOM?
	IDPB	C,T2
	JRST	SIXLP


;***** ROUTINE TO GET YES OR NO ANSWER

YESNO:	PUSHJ	P,GETSIX	;GET REPLY
	HLRZS	T1		;IN RIGHT HALF
	CAIN	T1,(SIXBIT /YE/)
	JRST	CPOPJ1
	JUMPE	T1,CPOPJ
	CAIE	T1,(SIXBIT /YES/)
	CAIN	T1,(SIXBIT /Y/)
	JRST	CPOPJ1		;YES--SKIP RETURN
	CAIE	T1,(SIXBIT /NO/)
	CAIN	T1,(SIXBIT /N/)
	POPJ	P,		;NON-SKIP RETURN
	TYPE	<
PLEASE ANSWER YES OR NO :>
	PUSHJ	P,TIDY
	JRST	YESNO

;***** ROUTINE TO INPUT AND ANALYZE CHARACTERS FROM CONSOLE
;***** TTY IN AC "C". TYPE BITS IN LEFT HALF.

CHRIN:	PUSHJ	P,INP		;GET CHAR
	JUMPE	C,CHRIN		;IGNORE NULL
	CAIN	C,15		;CR?
	JRST	CHRIN		;IGNORE IT
	CAIL	C,"0"
	CAILE	C,"9"		;NUMERIC?
	JRST	TRYALP		;NO
	CAIG	C,"7"		;OCTAL?
	TLO	C,C.OCT		;YES
	TLO	C,C.NUM
	JRST	SAVCHR
TRYALP:	CAIL	C,"A"
	CAILE	C,"Z"		;ALPHABETIC?
	JRST	TRYBRK		;NO
	TLO	C,C.ALP
	JRST	SAVCHR
TRYBRK:	CAIN	C,12
	TLO	C,C.BRK!C.MOVP
	CAIE	C,14
	CAIN	C,33		;FF OR ALTMODE?
	TLO	C,C.BRK!C.MOVP
	CAIE	C,40		;SPACE
	CAIN	C,11		;TAB?
	TLO	C,C.BRK
	CAIN	C,"."		;DOT?
	TLO	C,C.DOT
	CAIN	C,","		;COMMA?
	TLO	C,C.COM
	CAIN	C,":"		;COLON
	TLO	C,C.COL
	CAIE	C,"]"
	CAIN	C,"["
	TLO	C,C.BRAC
	CAIN	C,"-"		;DASH?
	TLO	C,C.DASH	;YES
	CAIN	C,"%"		;PERCENT?
	TLO	C,C.PRC		;YES
SAVCHR:	MOVEM	C,LSTCHR	;SAVE CHAR
	POPJ	P,


;***** ROUTINE TO GET DEC10 FORMAT FILESPEC 
;***** ENTER WITH "X" POINTING TO BLOCK TO USE

FILSPC:	SETZB	A,B		;CLEAR FOR RESULT
	SETZB	E,D		;FOR NOW
FILLP:	PUSHJ	P,GETSIX	;GET FIRST ATOM
	TLNN	C,C.COL		;COLON?
	JRST	NOTDEV		;NO
	JUMPN	E,SPCERR	;TWO DEVICES?
	MOVE	E,T1		;ELSE USE IT
	JRST	FILLP		;GO ROUND
NOTDEV:	TLNN	C,C.DOT		;DOT?
	JRST	NOTDOT		;NO
	JUMPN	A,SPCERR	;TWO NAMES?
	MOVE	A,T1		;ELSE USE IT
	TRO	B,777777	;HAVE SEEN A DOT
	JRST	FILLP
NOTDOT:	TLNN	C,C.BRAC	;BRACKET?
	JRST	NOTBRC		;NO
	JUMPE	T1,GETPNN	;IF NO ATOM GO GET PPN-ELSE
	JUMPN	A,GOTNAM	;NAME ALREADY?
	MOVE	A,T1
	JRST	GETPNN
GOTNAM:	TLNE	B,777777	;GOT EXTENSION?
	JRST	SPCERR		;;SOMETHING WRONG
	HLLZ	B,T1
	JRST	GETPNN
NOTBRC:	JUMPE	T1,GDSPC	;FINISH
	JUMPN	A,NAMIN
	MOVE	A,T1
	JRST	GDSPC
NAMIN:	TLNE	B,777777
	JRST	SPCERR
	HLLZ	B,T1
	JRST	GDSPC
GETPNN:	PUSHJ	P,GETOCT	;GET PROJ NUMBER
	HRLZ	D,T1		;IN LH
	TRNN	C,C.COM
	JRST	SPCERR		;NO
	PUSHJ	P,GETOCT	;GET PROG NUMBER
	HRR	D,T1		;OK
	TLNE	C,C.BRAC	;BRACKET?
	JRST	FILLP		;YES
	TLNN	C,C.BRK		;BREAK?
SPCERR:	JRST	TIDY		;ERROR-TIDY UP
GDSPC:	MOVEM	A,FILNAM(X)	;SAVE NAME
	HLLZM	B,FILEXT(X)	;SAVE EXTENSION
	MOVEM	D,FILPPN(X)	;SAVE PPN
	SKIPN	E		;DEVICE SUPPLIED
	MOVSI	E,(SIXBIT /DSK/) ;SUPPLY DEFAULT
	MOVEM	E,FILDEV(X)	;SAVE IT
	SETZM	FILCLR(X)	;CLEAR A WORD
	JRST	CPOPJ1		;AND SKIP


IFE DEC20,<
;***** ROUTINE TO PRINT A DEC10 FORMAT FILESPEC.
;***** ENTER WITH "X" POINTING TO THE FILE BLOCK

PNTSPC:	MOVE	A,FILDEV(X)	;GET DEVICE
	PUSHJ	P,SIXPNT	;PRINT IT
	MOVEI	T1,":"		;PRINT A COLON
	PUSHJ	P,OUTP
	MOVE	A,FILNAM(X)	;GET OUR NAME
	PUSHJ	P,SIXPNT
	MOVEI	T1,"."
	PUSHJ	P,OUTP
	HLLZ	A,FILEXT(X)	;GET EXTENSION
	PUSHJ	P,SIXPNT	;PRINT IT
	MOVEI	T1,"["
	PUSHJ	P,OUTP
	HLRZ	A,FILPPN(X)	;GET PROJECT NUMBER
	PUSHJ	P,OCTPNT
	MOVEI	T1,","
	PUSHJ	P,OUTP		;PRINT IT
	HRRZ	A,FILPPN(X)	;GET PROGRAMMER NUMBER
	PUSHJ	P,OCTPNT
	MOVEI	T1,"]"
	JRST	OUTP
>
;***** ROUTINE TO SAVE THE IMPORTANT ACS

SAVACS:	EXCH	A,(P)		;SAVE A--GET PC
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVEM	A,1(P)		;SAV RETURN PC
	MOVE	A,-4(P)		;RESTORE A
	PUSHJ	P,@1(P)		;RETURN TO MAINSTREAM
	  SKIPA			;NON-SKIP RETURN
	AOS	-5(P)		;SKIP RETURN
	POP	P,E
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,		;RETURN


;***** ROUTINE TO OUTPUT STRING POINTED TO BY "A" TO
;***** CURRENT OUTPUT DEVICE.

OUTFIL:	HRLI	A,440700	;MAKE A BP
LP10:	ILDB	T1,A		;GET CHAR
	JUMPE	T1,CPOPJ	;ALL DONE
	PUSHJ	P,OUTP
	JRST	LP10

;***** ROUTINE TO OUTPUT SIXBIT CHARS IN "A" TO
;***** CURRENT OUTPUT DEVICE.

SIXPNT:	MOVE	T2,[440600,,A]	;SET BP
SIXLPP:	ILDB	T1,T2		;GET CHAR
	JUMPE	T1,CPOPJ
	ADDI	T1,40
	PUSHJ	P,OUTP
	TLNE	T2,770000
	JRST	SIXLPP
	POPJ	P,

;***** ROUTINE TO OUTPUT A NUMBER IN "A" TO
;***** CURRENT OUTPUT DEVICE.

OCTPNT:	SKIPA	T1,[EXP 10]	;OCTAL
DECPNT:	MOVEI	T1,^D10		;DECIMAL
OCTDEC:	IDIV	A,T1
	HRLM	B,(P)		;SAVE REMAINDER
	SKIPE	A
	PUSHJ	P,OCTDEC	;DO MORE
	HLRZ	T1,(P)		;GET CHAR
	ADDI	T1,60
	JRST	OUTP

;***** ROUTINE TO DO GET(T)ABS

TABGET:
IFE DEC20,<GETTAB A,>		;GET HIS REQUIREMENTS
IFN DEC20,<GETAB>
	  SETZM	A		;CLEAR IT DOWN
	POPJ	P,

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;***** ROUTINE TO PRINT TIME AND DAY ETC

TIMDAY:
	PUSHJ	P,TIMEPT
	PRINT	< ON >
	JRST	DATEPT		;END CONDITIONAL ON DEC20

;;***** ROUTINE TO OUTPUT TIME OF DAY

TIMEPT:	MSTIME	C,		;GET TIME IN MILLISECONDS
PTTIME:	IDIVI	C,^D60000	;GET MINUTES
	IDIVI	C,^D60		;GET HOURS
	MOVE	A,C		;FIRST
	PUSHJ	P,DECPNT
	MOVEI	T1,":"
	PUSHJ	P,OUTP
	MOVEI	T1,"0"
	CAIGE	D,^D10
	PUSHJ	P,OUTP
	MOVE	A,D
	JRST	DECPNT

;;***** ROUTINE TO OUTPUT DATE

DATEPT:	DATE	A,		;GET DATE
	IDIVI	A,^D31		;B HAS DAY
	ADDI	B,1
	MOVEM	B,DAY
	IDIVI	A,^D12
	MOVEM	B,MONTH
	MOVEM	A,YEAR
	MOVE	A,DAY		;DAY FIST
	PUSHJ	P,DECPNT	;PRINT IT
	MOVEI	T1,"-"
	PUSHJ	P,OUTP
	MOVE	A,MONTH		;GET MONTH
	MOVE	A,MTHLST(A)
	PUSHJ	P,SIXPNT
	MOVEI	T1,"-"
	PUSHJ	P,OUTP
	MOVE	A,YEAR
	ADDI	A,^D1964
	JRST	DECPNT		;END CONDITIONAL ON DEC20


;***** ROUTINE TO SEARCH A TABLE FOR A MATCH. ENTER WITH
;***** THE COMMAND IN T1, [XWD DISPATCH TABLE,SEARCH TABLE] IN
;***** AC "A", RETURNS NON-SKIP IF NO MATCH--SKIP IF OK
;***** WITH DISPATCH ENTRY IN "B" AND THE TABLE INDEX IN "D".

SERTAB:	SETZB	D,B		;FOR RESULT
	SETOM	T2		;PREPARE MASK
	MOVEI	T3,77		;AND SLIDER
SRTLP1:	TDNE	T1,T3		;CHARACTER THERE?
	JRST	FNDONE		;YES
	TDZ	T2,T3		;CLEAR MASK
	LSH	T3,6		;SHIFT SLIDER
	JUMPN	T3,SRTLP1	;GO ROUND
	POPJ	P,		;NO COMMAND!!
FNDONE:	MOVE	X,(A)		;GET ENTRY
	JUMPE	X,CHECKM	;FINISHED
	CAMN	X,T1		;DIRECT MATCH?
	JRST	DIRMCH		;YES
	AND	X,T2		;TRY ABREVIATION
	CAMN	X,T1		;NOW?
	JRST	FNDMCH		;YES
TABLP:	AOBJP	A,.+1
	AOJA	D,FNDONE
FNDMCH:	JUMPN	B,CPOPJ		;DOUBLE MATCH
	MOVS	B,A		;REMEMBER "A"
	MOVE	E,D		;AND "D"
	JRST	TABLP		;GO ROUND
CHECKM:	JUMPE	B,CPOPJ		;NO MATCH
	SKIPA	D,E		;RESTORE INDEX
DIRMCH:	MOVS	B,A
	MOVE	B,(B)		;GET DISPATCH
	JRST	CPOPJ1

	


;***** ROUTINE TO PRINT HELP MESSAGES. ENTER WITH
;***** AC "E" POINTING TO TABLE IN R.H. AND HELPFUL
;***** MESSAGE TABLE IN L.H.

TABLST:	PUSHJ	P,TTYIO		;SET TTY IO
	TYPE	<AVAILABLE ARE:-
>
LSTLP:	MOVE	A,(E)		;GET ITEM
	JUMPE	A,LSTDUN	;ALL DONE
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB		;SPACE OVER
	HLRZ	A,E		;GET STRING POINTER
	MOVE	A,(A)
	PUSHJ	P,OUTFIL	;PRINT IT
	PUSHJ	P,CRLF
	AOBJN	E,LSTLP		;DO ALL
	JRST	LSTLP		;MAY BE HIGH SEG OR LOW
LSTDUN:	PUSHJ	P,CRLF
	POPJ	P,

;***** ROUTINE TO PRINT A TAB

TAB:	MOVEI	T1,11
	JRST	OUTP		;PRINT IT

;***** ROUTINE TO SEND AN ALTMODE

ALTMOD:	MOVEI	T1,33
	JRST	OUTP

;***** ROUTINE TO PRINT CRLF

CRLF:	TYPE	<
>
	POPJ	P,


;***** ROUTINE TO PRINT STRING AT 1(P) FROM CALL

STNOUT:	PUSH	P,A		;SAVE A
	HRRZ	A,@-1(P)		;GET ADDRESS
	PUSHJ	P,OUTFIL	;PRINT STRING
	POP	P,A
	POPJ	P,

;***** ROUTINE TO TYPE STRING AT 1(P).

TYPIT:	PUSH	P,A		;SAVE A
	PUSH	P,F		;SAVE FLAGS
	PUSHJ	P,TTYOTP	;FORCE TTY OUTPUT
	HRRZ	A,@-2(P)	;ADDRESS OF STRING
	PUSHJ	P,OUTFIL	;TYPE IT
	POP	P,F		;RESTORE FLAGS
	POP	P,A
	POPJ	P,

;***** ROUTINE TO CHECK FOR PARAMETER ON LINE

TSTPAR:	SKIPA	C,LSTCHR	;GET LAST CHAR
IGNCHR:	PUSHJ	P,CHRIN		;GET CHAR
	TLNE	C,C.MOVP	;CLEAN LINE?
	POPJ	P,		;NON-SKIP
	TLNE	C,C.BRK		;BREAK?
	JRST	IGNCHR
	TRO	F,F.LSCH	;RE-USE CHAR
	JRST	CPOPJ1		;SKIP RETURN

;***** CONTROL SERVICE ROUTINES

;***** ROUTINES TO SET AND UNSET FOR TEST OPERATION

CTLSTE:	MOVE	T1,TISBPI	;RESET BYTE POINTERS
	MOVEM	T1,TISBP
	MOVEM	T1,TOSBP	;TWICE
	TROA	F,F.TEST	;SET FLAG
CTLSPE:	TRZ	F,F.TEST	;CLEAR TESTING
	POPJ	P,

;***** ROUTINE TO GET STATISTICS

CTLGST:	MOVEI	T1,STT8BT+1	;GET NUMBER OF 8 BIT BYTES
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	MOVEI	T1,CT.PST	;TELL HIM THE GOOD NEWS
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	MOVE	A,[440400,,ACTSTR] ;POINT TO STATS
	MOVEI	B,STT8BT	;MAKE A COUNT
GSTLP1:	ILDB	T1,A		;GET FOUR BITS
	LSH	T1,4		;MOVE IT
	ILDB	T2,A		;GET NEXT FOUR BITS
	IOR	T1,T2		;MAK A CHAR
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;WHOOPS!!
	SOJG	B,GSTLP1	;LOOP UP
	POPJ	P,

;***** ROUTINE TO BREAK "TALK" LINK. AND VIRTUAL TTY

CTLNTK:	TLZA	F,F.TALK	;CLEAR FLAG FOR TALK
CTLNVT:	TLZA	F,F.HVRT	;HE IS NO LONGER VIRTUAL
	TYPE	<
[BREAKING TTY CONNECTION]
*>
	SETZM	PTCNT		;CLEAR SOME COUNTS
	SETZM	TNSTTY		;TO STOP OUTPUT
	POPJ	P,

;***** ROUTINE TO SETUP "TALK" LINK.

CTLTLK:	TLNN	F,F.PASS	;PASSIVE?
	TLOA	F,F.TALK	;CANNOT
	JRST	BRKTLK		;CANNOT
	TYPE	<
[TTY CONNECTED TO REMOTE OPERATOR]
>
	POPJ	P,


;***** HERE WHEN NO PTYS AVAILABLE AT THE OTHER END

CTLNPY:	TYPE	<
? NO PTYS AVAILABLE FOR VIRTUAL SUPPORT
>
	JRST	BRKVRT		;GO CLEAR US DOWN

;***** ROUTINES TO RECEIVE GENERAL FILESPECS FOR US.

CTLCGM:	TDZA	T4,T4		;SET FLAG FOR "CREATE"
CTLFGM:	MOVEI	T4,1		;SET FLAG FOR "FIND"
	MOVE	B,GSMREC(T4)	;GET ADDRESS TO SAVE IT
	PUSHJ	P,IFLSTG	;GO READ FILE SPEC
	SETOM	FILTSN(T4)	;SET FLAG
	SETOM	BUSY(T4)	;WE ARE NOW BUSY
	POPJ	P,

CTLCGH:	SKIPA	B,[EXP GNHSIN]	;WHERE TO PUT IT
CTLFGH:	MOVEI	B,GNHSOT	;WHERE TO PUT IT
	JRST	IFLSTG		;GET IT

;***** POINTERS TO SPACE FOR GENERAL SPECS

GSMREC:	EXP	GNORIN		;OUR INPUT SPEC
	EXP	GNOROT		;OUR OUTPUT SPEC

;***** ROUTINES TO ABORT DATA TRANSMISSION

CTLABI:	SETZM	BUSY+1		;CLEAR HIS INPUT CHANNEL
	POPJ	P,

CTLABO:	SETZM	BUSY		;CLEAR HIS OUTPUT CHANNEL
	POPJ	P,


;***** ROUTINE TO SET UP FOR VIRTUAL TERMINAL SUPPORT.
CTLVRT:	TLO	F,F.HVRT	;SET FLAG
	TLZ	F,F.TALK	;RESET TALK
	SETZM	PTCNT
	SKIPE	PTYFLG		;DO WE HAVE A PTY?
	POPJ	P,		;YES--RETURN
	SETZM	PTYBLK		;SET FOR ASCII MODE
	SETOM	T1		;THIS IS ALL STOLEN FROM OPSER
	JRST	PTYL1		;TRY GENERIC DEVICE
PTYLL:	MOVEI	T2,(T1)		;LOAD DIGIT
	CAILE	T2,777		;HIGHEST POSSIBLE?
	JRST	NOPTY		;NONE AVAILABLE
	LSHC	T2,-6		;SPLIT DIGITS
	LSH	T2,3		;SHIFT HIGH ORDER BIT BY 3
	LSHC	T2,3		;SHIFT DOUBLE BACK
	LSH	T2,3		;SHIFT HIGH ORDER BY 3
	LSHC	T2,3		;SHIFT DOUBLE BACK
	TRO	T2,202020	;MAKE 6 BIT
	TRNN	T2,570000	;SKIP IF HIGH ORDER NOT 0
	LSH	T2,6		;SHIFT OUT OF XWD
	TRNN	T2,570000	;SKIP IF HIGH ORDER NOT 0
	LSH	T2,6		;SHIFT OUT OF XWD
PTYL1:	HRLI	T2,(SIXBIT /PTY/)
	MOVEM	T2,PTYBLK+1	;STORE IN OPEN BLOCK
	JUMPL	T1,PTYL2	;SKIP CHECK IF FIRST TIME AROUND
	DEVCHR	T2,		;CHECK IT OUT
	JUMPE	T2,NOPTY	;NO MORE
	TLNE	T2,DVAVAL	;SKIP IF NOT AVAILABLE
	TRNE	T2,ASSPRG	;SKIP IF NOT INITED ALREADY
	AOJA	T1,PTYLL	;LOOP UP
PTYL2:	MOVSI	T2,PTYOBF
	HRRI	T2,PTYIBF	;GET BUFFER ADDRESSES
	MOVEM	T2,PTYBLK+2	;SAVE IT
	OPEN	4,PTYBLK	;OPEN DEVICE
	  SKIPA
	JRST	PTYL3		;GOT ONE
	JUMPGE	T1,NOPTY	;NO MORE?
	AOJA	T1,PTYLL	;LOOP UP
PTYL3:	MOVEI	T2,PTOBUF	;ADDRESS OF BUFFER
	MOVEM	T2,.JBFF##
	OUTBUF	4,1		;ONE BUFFER
	MOVEI	T2,PTIBUF
	MOVEM	T2,.JBFF##
	INBUF	4,1		;CREATE IT
	OUTPUT	4,		;SET ALL UP
	OUTPUT	4,		;AND CLEAR UP
	SETOM	PTYFLG		;REMEMBER WE GOT IT
	POPJ	P,		;RETURN
NOPTY:	MOVEI	T1,CT.NPY	;NO PTY AVAILABLE
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	TLZ	F,F.HVRT	;RESET FLAG
	POPJ	P,

;***** ROUTINE TO RECEIVE LOCAL FILESPEC AND FIND
;***** CORRESPONDING FILE

CTLFLM:	MOVEI	B,LCHSIN	;ADDRESS OF HIS SPEC
	PUSHJ	P,IFLSTG	;GO READ IT
	PUSHJ	P,NEWLIF	;GET CORRESPONDING FILESPEC
	  JRST	FILBD1		;BAD SPEC
	MOVEI	A,CT.FLC	;MY CORRESPONDIG SPEC
CTLFL1:	MOVEI	B,LCORIN	;ADDRESS OF SPEC
	PUSHJ	P,FILCTL	;SEND IT
	  JRST	CTLFUL
	TLNE	F,F.PASS	;ARE WE PASSIVE?
	POPJ	P,
	TYPE	<
[RECEIVING FILE >
	TYPE1	LCORIN+STGADR	;GET IT
	TYPE	<
FROM >
	TYPE1	LCHSIN+STGADR
	TYPE	<
STARTED AT >
	PUSHJ	P,TIMDAY;CHANGED FROM[RLD]TIMEPT	;PRINT TIME
	TYPE	<]
>
	POPJ	P,

FILBD1:	MOVEI	A,CT.FLB	;SEND BAD MESSAGE
	JRST	CTLFL1		;GO DO IT

;***** HERE TO RECEIVE THE CORRESPONDING FILE SPEC AND
;***** START FILE TRANSFER.

CTLFLC:	MOVEI	B,LCHSOT	;WHERE TO PUT SPEC
	PUSHJ	P,IFLSTG	;STORE IT
	SETOM	TNSTXT		;START SENDING
	TLNE	F,F.PASS	;PASSIVE?
	POPJ	P,		;AND RETURN
	TYPE	<
[SENDING FILE >
	TYPE1	LCOROT+STGADR	;TYPE IT
	TYPE	<
TO >
	TYPE1	LCHSOT+STGADR
	TYPE	<
STARTED AT >
	PUSHJ	P,TIMDAY;CHANGED FROM[RLD]TIMEPT	;PRINT TIME
	TYPE	<]
>
	POPJ	P,


;***** ROUTINE TO CLOSE UP "GET" FILE

CTLFIN:	PUSHJ	P,CTLGET	;GET ERROR CODE
	  JFCL
	MOVEM	T1,GTERCD	;SAVE IT
	MOVE	A,[401000,,CHKGET] ;GET CHECKSUM
FINFG1:	PUSHJ	P,CTLGET	;GET BYTE
	  JFCL
	IDPB	T1,A		;SAVE IT
	TLNE	A,770000
	JRST	FINFG1		;LOOP UP
	PUSHJ	P,CLSGET	;CLOSE UP FILE
	  JRST	OERCMP		;TROUBLE
	TLNE	F,F.PASS	;PASSIVE?
	POPJ	P,
	TYPE	<
FINISHED RECEIVING FILE >
	TYPE1	LCORIN+STGADR	;PRINT IT
	TYPE	<
FROM >
	TYPE1	LCHSIN+STGADR	;PRINT HIS SPEC
GTSTSP:	TYPE	<
DATA RECEIVED=>
	MOVE	A,TXTGCT	;GET CHARS RECEIVED
	PUSHJ	P,DECPNT	;PRINT THEM
	TYPE	< CHARS IN >
	MSTIME	A,		;GET TIME
	SUB	A,TMEGET	;TIME WHEN STARTED
	IDIVI	A,^D1000	;CONVERT TO SECONDS
	PUSH	P,A		;SAVE TIME
	IDIVI	A,^D60		;CONVERT TO MINUTES
	CAIL	B,^D30		;ROUND UP?
	ADDI	A,1		;YES
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	< MINUTES (>
	MOVE	A,TXTGCT	;GET CHARS
	POP	P,B		;RESTORE TIME
	IDIV	A,B		;GET CHARS/SECOND
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	< CHARS PER SECOND)
>
	POPJ	P,

;***** HERE ON OUTPUT ERROR

OERCMP:	TLNE	F,F.PASS	;PASSIVE?
	POPJ	P,		;YES
	TYPE	<
OUTPUT ERROR
>
	POPJ	P,


;***** HERE TO CLEAR DOWN WHEN NO MORE FILES TO RECEIVE

CTLLDN:	SETZM	BUSY		;NO LONGER BUSY
	SETZM	LCORIN+STGADR
	TLNN	F,F.PASS
	TYPE	<
[INPUT STREAM IDLE]
>
	POPJ	P,

;***** HERE WHEN BAD FILESPEC FOUND AT REMOTE END

CTLFLB:	TYPE	<
[BAD REMOTE FILESPEC]
>
	PUSHJ	P,CLSSND	;CLOSE UP
	JRST	CTLLDN

IFN DEC20,<

;*****ROUTINE TO LOGOUT THE PASSIVE JOB FOR TOPS20

CTLLGO:	TLNN	F,F.PASS	;ARE WE RUNNING PASSIVE ?
	POPJ	P,		;NO, JUST RETURN
	MOVEI	AC1,-1		;SPECIFY THIS JOB
	HRLE	AC1,AC1		;BOTH HALVES
	LGOUT			;LOGOUT--SHOULD NOT RETURN
	JRST	CTLLGO		;OPPS!! IT DID, JUST DO IT AGAIN
>
IFE DEC20,<
CTLLGO:	POPJ	P,
>

;***** ROUTINE TO READ A FILESPEC FROM THE CONTROL BUFFER
;***** AND PUT IT IN THE BLOCK SPECIFIED BY "B"

IFLSTG:	MOVSI	A,440700	;MAKE A BP
	HRRI	A,2(B)		;FOR STRING
	MOVN	D,(B)		;GET MAXIMUM LENGTH
	HRLZ	D,D		;MAKE AOBJN POINTER
IFLLP1:	PUSHJ	P,CTLGET	;GET CHARACTER
	  JRST	SHRTCT		;HUH!!!!
	IDPB	T1,A		;SAVE IT
	SOSG	EXTCTL		;DECREMENT COUNT
	JRST	CTLFN1		;FINISHED
	AOBJN	D,IFLLP1	;LOOP UP
	MOVE	A,JUNKBP	;HELL!! JUNK REST
	AOS	CTLLNG		;COUNT OCCURRENCES
	JRST	IFLLP1

SHRTCT:	AOS	CTLSHT		;SHORT CHANGED!!
CTLFN1:	SETZM	T1		;MAKE ASCIZ
	IDPB	T1,A
	HRRZM	D,1(B)		;SAVE COUNT
	POPJ	P,


;***** I/O ROUTINES DURING COMMAND MODES.

;***** ROUTINE TO INPUT CHARACTER FROM DSK IN "C"

DSKIN:	
IFN DEC20,<PUSH P,AC1
	MOVE	AC1,INPJFN		;GET JFN
	EXCH	C,AC2		;GET CHAR
	BIN
	ERJMP	DSKEOF
	EXCH	C,AC2		;RESET
	POP	P,AC1
	POPJ	P,
INERR:	TYPE	<
INPUT ERROR
>
	HALTF>

IFE DEC20,<SOSG	IBUF+2
	JRST	MOREIN		;GET SOME MORE
INLP:	ILDB	C,IBUF+1
	POPJ	P,
MOREIN:	IN	1,
	JRST	INLP
	STATO	1,740000	;ERROR?
	JRST	DSKEOF		;ALL DONE
	TYPE	<
INPUT ERROR
>
	EXIT>

DSKEOF:	HRRZ	C,INEOF		;GET DISPATCH ADDRESS
	POP	P,(P)		;ADJUST BP
	JRST	(C)		;GO DO IT

;;***** ROUTINE TO OUTPUT CHAR IN "T1" TO DSK

DSKOUT:
IFN DEC20,<PUSH P,AC1
	MOVE	AC1,OUTJFN	;GET JFN
	EXCH	T1,AC2		;GET CHAR
	BOUT
	  ERJMP OUTERR		;ERROR
	EXCH	T1,AC2		;RESET
	POP	P,AC1		;RESTORE
	POPJ	P,
OUTERR:	TYPE	<
OUTPUT ERROR
>
	HALTF>			;END OF DEC20 CONDITIONAL

IFE DEC20,<SOSG	OBUF+2
	JRST	GETMOR
OUTLP:	IDPB	T1,OBUF+1
	POPJ	P,
GETMOR:	OUT	1,
	JRST	OUTLP
	TYPE	<
OUTPUT ERROR
>
	EXIT>		;END OF DEC20 CONDITIONAL

;;***** ROUTINE TO OUTPUT CHAR IN "T1" TO TTY

TTYOUT:
IFE DEC20,<TTCALL 1,T1>
IFN DEC20,<EXCH AC1,T1
	PBOUT
	EXCH	AC1,T1>
	POPJ	P,

;***** ROUTINE TO INPUT FROM TTY INTO "C"

TTYIN:	
IFE DEC20,<TTCALL 4,C>	;GET CHAR IN C
IFN DEC20,<EXCH AC1,C
	PBIN			;GET CHAR
	EXCH	AC1,C>		;RESTORE A
	POPJ	P,

;***** ROUTINE TO OUTPUT TO TRANSMISSION CHANNEL

CHNOUT:	JRST	PUTCHR		;GO SEND CHAR

;***** ROUTINE TO INPUT FROM TRANSMISSION CHANNEL INTO "C".
;***** IF NO CHARACTER AVAILABLE--WAITS 100MS AND RETRIES.

CHNIN:	PUSHJ	P,GETCHR	;GET CHAR
	  JRST	[MOVEI	C,^D100
		IFE DEC20,<
		HRLI	C,(HB.RTC!HB.RTL!HB.RIO)
		>;END DEC20
		JRST	CHNIN1]
	POPJ	P,		;ELSE OK
CHNIN1:	HIBER	C,
	  JFCL
	JRST	CHNIN		;TRY AGAIN

;***** HERE TO INPUT FROM CORE

COREIN:	ILDB	C,INCORE	;GET BYTE IN C
	JUMPN	C,CPOPJ		;AND RETURN IF NON-ZERO
	SETZM	INCORE		;FINISHED THIS STRING
	MOVEI	C,12		;MAKE A LINEFEED
	POPJ	P,		;RETURN

;***** HERE TO OUTPUT TO CORE

COREOT:	IDPB	T1,OTCORE	;OUTPUT CHAR
	AOS	@OTCNT		;COUNT HIS CHARS
	JUMPN	T1,CPOPJ	;RETURN
	SETZM	OTCORE		;ZERO BYTE POINTER
	SOS	@OTCNT		;ADJUST COUNT
	POPJ	P,


;***** ROUTINE TO CHECK AND DIAL THE TELEPHONE IF REQUIRED

DIALUP:	SKIPN	NUMTLY		;TELEPHONE TO DIAL?
	JRST	CPOPJ1
	TYPE	<
TELEPHONE NUMBER IS >
	MOVE	A,NUMTLY	;GET IT
	PUSHJ	P,OUTFIL	;AND TYPE IT
	TYPE	<

Have you ALREADY established the connection? >
	PUSHJ	P,YESNO		;ASK HIM
	  SKIPA	T2,NUMTLY	;NO--AUTO DIAL IT
	JRST	CPOPJ1
    IFN TYM10,<
	TYPE	<
Silly Person!!!!! You know that this doesn't work!!!!
>
	POPJ	P,
    > ; End IFN TYM10
    IFE TYM10,<
	TYPE	<
Attempting to DIAL-UP
>
	MOVE	T3,[440400,,DILBLK+2] ;MAKE BP
DILLP2:	ILDB	T1,T2		;GET DIGIT
	JUMPE	T1,DILLP4	;ALL DONE
	CAIN	T1,"-"		;HYPHEN?
	JRST	DILLP3		;YES--SPECIAL
	MOVEI	T1,-60(T1)	;MAKE OCTAL
DILLP1:	IDPB	T1,T3		;SAVE IT
	JRST	DILLP2		;LOOP UP
DILLP3:	MOVEI	T1,16		;DELAY 15 SECONDS
	JRST	DILLP1		;LOOP UP
DILLP4:	MOVEI	T1,17		;FINISHED
	IDPB	T1,T3		;SAVE IT
	MOVEI	T1,13		;GET CODE
	MOVEM	T1,DILBLK	;SAVE IT
	MOVE	T1,[4,,DILBLK]	;DO TRMOP.
	TRMOP.	T1,
	  JRST	DIALER		;ERROR
	TYPE	<
Number dialed O.K.
>
	JRST	CPOPJ1

DIALER:	PUSH	P,T1		;SAVE ERROR CODE
	TYPE	<
TRMOP. error >
	POP	P,A		;GET ERROR CODE
	PUSHJ	P,DECPNT
	TYPE	< whilst dialing.
>
	POPJ	P,
    > ; End IFE TYM10


;***** COMMANDS DURING MAIN PROTOCOL LOOP

;***** ROUTINE TO GET COMMANDS UNDER LINKUP *****

LNKCOM:	PUSHJ	P,GETSIX	;GET COMMAND
	JUMPE	T1,LNKPMT	;IGNORE NULL
	MOVE	A,[LNKDSP,,LNKOPT] ;GET TABLE ADDRESSES
	PUSHJ	P,SERTAB	;FIND OPTION
	  MOVEI	B,LNKERR	;ILLEGAL
	PUSHJ	P,(B)		;GO DO IT
	PUSHJ	P,TIDY
	TLNN	F,F.WVRT+F.TALK	;IF GOING VIRTUAL TTY
LNKPMT:	TYPE	<
*>
	POPJ	P,

LNKERR:	TYPE	<
ILLEGAL OPTION-->
	PUSHJ	P,TIDY		;TIDY UP
LNKHLP:	TYPE	<OPTIONS >
	MOVE	E,[LNKHPT,,LNKOPT]
	JRST	TABLST


;***** THE "LINKUP & JOINUP" COMMANDS

JOINUP:	TLOA	F,F.JOIN	;JOIN UP
LINKUP:	TLZ	F,F.JOIN	;LINKUP
	PUSHJ	P,TSTPAR	;ANOTHER PARAMETER?
	TYPE	<
WHICH NODE? : >
	PUSHJ	P,TTYDET	;GET NODE NAME
	  JRST	LNKFRC		;FORCED TTY
	MOVEM	T1,NODE		;SAVE IT
	PUSHJ	P,FNDTTY	;GO LOOK FOR AVAILABLE TTY
	  JRST	NOTTY		;NONE AVAILABLE
LNKFRC:	PUSHJ	P,STBLK		;SET UP FOR MACHINE
	  JRST	UNKMAC		;UNKNOWN MACHINE
	PUSHJ	P,OPNTTY	;INITIALISE IT
	  JRST	BADTTY		;CANNOT
	PUSHJ	P,TTYIO		;SET FOR TTY
	PUSHJ	P,DIALUP	;GIVE HIM A CALL
	  JRST	RELTTY		;RELEASE IT
	TLNE	F,F.JOIN	;ARE WE JOINING?
	JRST	LNKJON		;YES--GO START UP
	PUSHJ	P,LOGIN		;GO LOGIN A JOB
	  JRST	BADLOG		;CANNOT
	PUSHJ	P,RUNJOB	;RUN RECEIVER
	  JRST	BADREC		;CANNOT!!
	TRO	F,F.RDET	;SAY REMOTE IS RUNNING DETACHED
	JRST	JONLNK

LNKJON:	MOVE	A,RSPED		;GET RECEIVE SPEED
	PUSHJ	P,SETRCV	;SET IT
	MOVE	A,XSPED		;GET XMIT SPEED
	PUSHJ	P,SETXMT	;SET IT
JONLNK:	PUSHJ	P,TTYIO
	TYPE	<
WAIT FOR "RESTARTING" MESSAGE
(TYPE "HELP" FOR HELP)
*>
	JRST	PROTO		;GO START UP

;***** ROUTINE TO EXIT FROM "LINKUP" STATE

LNKXIT:	TLNN	F,F.JOIN	;IF WE JOINED DONT LOGOFF
	JRST	LNKLGF		;ELSE LOGOFF
	TYPE	<
LINK CONNECTION BROKEN

>
	PUSHJ	P,DELAY3	;LET MESSAGE PRINT
	SKIPA
LNKLGF:	PUSHJ	P,LOGOUT	;LOG OFF
	PUSHJ	P,RELTTY	;RELEASE THE TTY
	MOVE	P,PROTP		;RESTORE P
	POPJ	P,

;***** ROUTINE TO GET STATISTICS

LNKSTS:	MOVEI	T1,STTPNT	;ADDRESS OF STATS PRINT ROUTINE
	MOVEM	T1,STTACT	;SAVE IT
	MOVEI	T1,CT.GST	;CONTROL CODE
LNKCTL:	PUSHJ	P,CTLPUT	;SAVE IT
	  JRST	NRMCTL		;NO ROOM
	JRST	TIDY		;TIDY UP AND RETURN

;***** ROUTINE TO START TESTING THE LINE.

LNKTST:	MOVE	T1,TISBPI	;GET BYTE POINTER
	MOVEM	T1,TISBP	;SET IT UP
	MOVEM	T1,TOSBP	;TWICE
	TRO	F,F.TEST	;SET FLAG
	MOVEI	T1,CT.STE	;START TESTING
	JRST	LNKCTL		;SEND IT

;***** ROUTINE TO STOP TESTING THE LINE.

LNKNTS:	TRZ	F,F.TEST	;REWSET
	MOVEI	T1,CT.SPE	;STOP TEST
	PUSHJ	P,CTLPUT	;SAVE CHAR
	  JRST	NRMCTL		;NO ROOM
	JRST	TIDY		;TIDY UP


;***** ROUTINE TO SET UP VIRTUAL TERMINAL SUPPORT

LNKTYP:	PUSHJ	P,TIDY		;TIDY UP FIRST
	TLO	F,F.WVRT	;SET FLAG
	MOVEI	T1,CT.VRT	;SEND CONTROL MESSAGE
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	TYPE	<
[Supporting Virtual Terminal Circuit]
>
	MOVEI	T1,3		;SEND 3 REQUESTS
	MOVEM	T1,RECTTY
	MOVEI	T1,^D100	;AND SET OUR COUNT UP
	MOVEM	T1,PTCNT
    IFE TYM10,<
	MOVE	A,[XWD 3,B]	;NOW SET SLAVE
	MOVEI	B,2004
	MOVE	C,OURINX	;GET OUR IOINDX
	MOVEI	D,1		;SET IT
	TRMOP.	A,
	  JFCL
    > ; End IFE TYM10
    IFN TYM10,<
	HRROI	A,.AXCFS
	Auxcal	A,1b29!10	; Full character set, binary
    > ; End IFN TYM10
	POPJ	P,

NOVRTP:	TYPE	<
Unable to establish VIRTUAL TERMINAL
>
	JRST	BRKVRT		;BREAK US DOWN AGAIN

;***** ROUTINE TO SET UP TO TALK TO REMOTE OPERATOR.

LNKTLK:	PUSHJ	P,TIDY		;TIDY UP FIRST
	TLO	F,F.TALK	;SET FLAGS
	MOVEI	T1,CT.TLK	;SEND CONTROL
	PUSHJ	P,CTLPUT
	  TLZA	F,F.TALK	;CANNOT
	TYPE	<
[CONNECTING TO REMOTE OPERATOR]
>
	POPJ	P,


;***** ROUTINE TO PRINT STATISTICS

STTPNT:	PUSHJ	P,TTYIO		;MAKE SURE TTYIO
	PUSHJ	P,LNKSTA	;DO STATUS FIRST
	TYPE	<
STATISTICS RECORDED >
	PUSHJ	P,TIMDAY	;PRINT TIME AND DATE

	TYPE	<

	ITEM	      LOCAL	      REMOTE
	----	      -----	      ------
>
	MOVSI	D,-ACTSTP	;MAKE A POINTER
STTLL1:	MOVE	A,STTSTG(D)	;TYPE STRING
	PUSHJ	P,OUTFIL
	MOVE	A,ACTSTR(D)	;GET LOCAL VERSION
	PUSHJ	P,DECPNT	;PRINT IT
	MOVE	A,ACTSTR(D)	;GET NUMBER BACK
	CAMG	A,[EXP ^D99999999] ;VERY LARGE?
	PUSHJ	P,TAB		;THROW UP
	PUSHJ	P,TAB		;AND AGAIN
	MOVE	A,FARSTR(D)	;GET REMOTE VERSION
	PUSHJ	P,DECPNT
	PUSHJ	P,CRLF		;THROW UP AGAIN
	AOBJN	D,STTLL1	;LOOP UP
	TYPE	<
*>
	POPJ	P,

;***** ROUTINE TO DEAL WITH STATISTICS FROM AFAR

CTLPST:	MOVE	A,[440400,,FARSTR] ;SET UP BP
STTINC:	PUSHJ	P,CTLGET	;GET CHAR IN T1
	  JFCL
	LDB	T2,[040400,,T1]	;GET TOP 4 BITS
	IDPB	T2,A		;STORE IT
	LDB	T2,[0400,,T1]	;GET BOTTOM FOUR BITS
	IDPB	T2,A		;STORE IT
	SOSLE	EXTCTL		;ANY MORE?
	JRST	STTINC		;GET NEXT CHAR
	JRST	@STTACT		;GO DO THE NECESSARY


;***** THE "ABORT" COMMAND

LNKABT:	TLNE	C,C.MOVP	;ARE WE TIDY?
	JRST	LNKNRG		;BAD!!
	PUSHJ	P,GETSIX	;GET REPLY
	JUMPE	T1,LNKNRG	;COMPLAIN ABOUT NULL
	MOVE	A,[LNKBRT,,LNKBRC] ;LOOK IT UP
	PUSHJ	P,SERTAB	;FIND IT
	  JRST	LNKNRG		;NOT THERE
	PUSHJ	P,(B)		;DO IT
	JRST	TIDY		;TIDY UP

LNKNRG:	TYPE	<
ARGUMENTS ARE:- "INPUT", "OUTPUT" OR "BOTH"
>
	POPJ	P,

LNKBRC:	SIXBIT	/INPUT/
	SIXBIT	/OUTPUT/
	SIXBIT	/BOTH/
	Z

LNKBRT:	EXP	ABTINP		;ABORT INPUT
	EXP	ABTOUT		;ABORT OUTPUT
	EXP	ABTBTH		;ABORT BOTH

ABTBTH:	PUSHJ	P,ABTOUT	;ABORT OUTPUT
ABTINP:	SETZM	BUSY		;CLEAR BUSY FLAG
	MOVEI	T1,CT.ABI	;SEND CONTROL
	JRST	CLRABT
ABTOUT:	SETZM	BUSY+1		;CLEAR OUTPUT
	MOVEI	T1,CT.ABO	;SEND HIM FLOWERS
CLRABT:	PUSHJ	P,CTLPUT	;GO ON--DONT BE SHY
	  JRST	NRMCTL		;NO ROOM
	POPJ	P,


;***** THE "STATUS" COMMAND

LNKSTA:	TYPE	<
STATUS OF "LINKUP" >
	PUSHJ	P,TIMDAY	;PRINT DATE AND TIME
	TYPE	<

LINKED TO >
	PUSHJ	P,NODEID	;PRINT NODE DETAILS
	  JFCL			;HAS A SKIP RETURN
	TRNE	F,F.TEST	;ARE WE TESTING?
	TYPE	<
!!!!!  TESTING IN PROGRESS  !!!!!>
	TLNN	F,F.JOIN	;MASTER TO MASTER?
	TYPE	<
REMOTE JOB IS RUNNING PASSIVE>
	TLNE	F,F.JOIN	;ELSE
	TYPE	<
LOCAL AND REMOTE JOBS ARE ACTIVE JOBS>
	TLNE	F,F.WVRT	;ARE WE VIRTUAL?
	TYPE	<
LOCAL JOB SUPPORTING VIRTUAL TERMINAL>
	TLNE	F,F.HVRT	;IS HE?
	TYPE	<
REMOTE JOB SUPPORTING VIRTUAL TERMINAL>
	SKIPN	BUSY		;INPUT CHANNEL BUSY?
	JRST	OUTBSY		;NO
	TYPE	<

INPUT DATA CHANNEL ACTIVE
LOCAL GENERAL FILESPEC-- >
	TYPE1	GNORIN+2	;TYPE IT
	TYPE	<
REMOTE GENERAL FILESPEC-- >
	TYPE1	GNHSIN+2	;TYPE IT
	PUSHJ	P,CRLF
	TYPE	<
CURRENTLY INPUTING TO >
	TYPE1	LCORIN+2	;TYPE IT
	TYPE	<
FROM REMOTE FILE >
	TYPE1	LCHSIN+2	;TYPE IT
	TYPE	<
STARTED AT >
	MOVE	C,TMEGET		;GET TIME
	PUSHJ	P,PTTIME	;PRINT IT
	PUSHJ	P,GTSTSP	;PRINT TOTAL SO FAR
	PUSHJ	P,CRLF
	SKIPA
OUTBSY:	TYPE	<
INPUT DATA CHANNEL IDLE>
	SKIPN	BUSY+1		;OUTPUT BUSY?
	JRST	STALP1
	TYPE	<

OUTPUT DATA CHANNEL ACTIVE
LOCAL GENERAL FILESPEC-- >
	TYPE1	GNOROT+2
	TYPE	<
REMOTE GENERAL FILESPEC-- >
	TYPE1	GNHSOT+2
	PUSHJ	P,CRLF
	TYPE	<
CURRENTLY SENDING FILE >
	TYPE1	LCOROT+2	;SEND IT
	TYPE	<
REMOTE FILESPEC >
	TYPE1	LCHSOT+2
	TYPE	<
STARTED AT >
	MOVE	C,TMESNT	;GET TIME
	PUSHJ	P,PTTIME	;PRINT IT
	PUSHJ	P,SDSTSP	;TYPE DETAILS SO FAR
	PUSHJ	P,CRLF
	SKIPA
STALP1:	TYPE	<
OUTPUT DATA CHANNEL IDLE>
	JRST	CRLF


;***** THE "GET" AND "SEND" COMMANDS FOR FILE TRANSFER.

LNKGET:	TDZA	T4,T4		;SET FLAG FOR GET
LNKSND:	MOVEI	T4,1		;SET FLAG FOR SEND
	SKIPE	BUSY(T4)	;ARE WE BUSY?
	JRST	BSYCHN		;YES--TELL HIM
	MOVE	B,GN1SPC(T4)	;GET BP FOR FILESPEC
	PUSHJ	P,FILSTG	;GET FILESPEC
	  JRST	GSNERR		;NO FILESPEC?
	MOVE	B,GN2SPC(T4)	;GET BP FOR FILESPEC
	PUSHJ	P,FILSTG	;GET IT
	  JRST	SMEFSP		;NONE THERE--USE FIRST ONE
	PUSHJ	P,TIDY		;TIDY UP LINE
SNDGEN:	HRRZ	B,REMSPC(T4)	;GET POINTER TO SPEC FOR REMOTE
	HRRZ	A,REMFL1(T4)	;GET CONTROL CHARACTER
	SETOM	BUSY(T4)	;WE ARE NOW BUSY
	SETOM	FILTSN(T4)	;MAY BE A GOOD FLAG
	PUSHJ	P,FILCTL	;SEND CONTROL MESSAGE
	  JRST	CTLFUL		;NO ROOM
	HLRZ	B,REMSPC(T4)	;SEND HIM OUR SPEC
	HLRZ	A,REMFL1(T4)	;FOR HIS INFORMATION
	PUSHJ	P,FILCTL
	  JRST	CTLFUL		;CANNOT
	POPJ	P,		;OK

GSNERR:	TYPE	<
NEEDS FILESPECS
>
	POPJ	P,

CTLFUL:	TYPE	<
UNABLE TO SEND FILESPEC
>
	SETZM	BUSY(T4)	;CLEAR FLAG
	POPJ	P,


;***** HERE TO COPY FILESPECS WHEN ONLY ONE SPECIFIED

SMEFSP:	MOVE	T2,GN1SPC(T4)	;COPY ONE STRING TO THE OTHER
	MOVE	T3,GN2SPC(T4)
	ADDI	T2,2		;BUMP POINTER
	ADDI	T3,2		;AND THE OTHER ONE
	HRLI	T2,440700	;AND MAKE A BYTE POINTER
	HRLI	T3,440700	;COMPLETELY
SMELP1:	ILDB	T1,T2		;GET A BYTE
	IDPB	T1,T3		;COPY IT
	JUMPN	T1,SMELP1	;LOOP UP
	JRST	SNDGEN		;GO SEND IT

BSYCHN:	TYPE	<
CHANNEL ALREADY BUSY IN THAT DIRECTION
>
	JRST	TIDY		;GO TIDY UP

GN1SPC:	EXP	GNORIN		;ADDRESS FOR OUR INPUT SPEC
	EXP	GNOROT		;ADDRESS FOR OUR OUTPUT SPEC

GN2SPC:	EXP	GNHSIN		;ADDRESS FOR HIS INPUT SPEC
	EXP	GNHSOT		;ADDRESS FOR HIS OUTPUT SPEC

REMSPC:	XWD	GNORIN,GNHSIN	;ADDRESS FOR HIS INPUT SPEC
	XWD	GNOROT,GNHSOT	;ADDRESS FOR HIS OUTPUT SPEC

REMFL1:	CT.FGH,,CT.FGM		;HIS LOOKUP GENERAL SPEC
	CT.CGH,,CT.CGM		;HIS CREATE GENERAL SPEC


;***** ROUTINE TO READ A STRING FROM INPUT DEVICE AND STORE IT
;***** IN CORE IN AN ASCIZ STRING. ENTER WITH B POINTING TO
;***** THE DESTINATION BLOCK. WORD ZERO OF THE BLOCK WILL
;***** CONTAIN THE MAXIMUM LENGTH OF THE STRING, WORD ONE
;***** WILL CONTAIN THE ACTUAL LENGTH OF THE STRING AND
;***** THE STRING WILL APPEAR IMMEDIATELY AFTERWARDS.

FILSTG:	MOVN	D,(B)		;GET NEGATIVE COUNT
	HRLZ	D,D		;MAKE AOBJN POINTER
	MOVSI	E,440700	;MAKE A BP
	HRRI	E,2(B)		;IN THE SPECIFIED BLOCK
FLSGL3:	MOVE	C,LSTCHR	;GET OUR LAST CHAR
	TLNE	C,C.MOVP
	POPJ	P,
FLSGL1:	PUSHJ	P,CHRIN		;GET A CHARACTER IN "C"
	TLNE	C,C.BRK		;BREAK CHARACTER?
	JRST	FLSGL2		;YES
	IDPB	C,E		;SAVE CHAR
	AOBJN	D,FLSGL1	;LOOP UP
	TYPE	<
STRING TOO LONG--RETYPE IT
>
	JRST	FILSTG		;RETRY

FLSGL2:	TRZ	C,777777	;CLEAR LAST CHAR
	HRRZM	D,1(B)		;SAVE COUNT
	SKIPN	1(B)		;NULL STRING?
	JRST	FLSGL3		;YES--TRY AGAIN
	IDPB	C,E		;MAKE ASCIZ
	JRST	CPOPJ1		;AND SKIP

;***** ROUTINE TO SEND CONTROL INFORMATION TO REMOTE WITH
;***** FILESPEC TO BE FOUND OR CREATED. ENTER WITH CONTROL
;***** CHARACTER IN "A" AND ADDRESS OF FILESPEC BLOCK IN "B".

FILCTL:	MOVE	T1,CTLOTC	;GET ROOM IN CONTROL BUFFER
	SUB	T1,1(B)		;ENOUGH ROOM?
	JUMPLE	T1,CPOPJ	;NO!
	MOVE	T1,1(B)		;GET CHARACTER COUNT
	AOS	T1		;BUMP TO INCLUDE CTL CHAR
	PUSHJ	P,CTLPUT	;SEND CHAR
	  JRST	NRMCTL		;NO ROOM
	MOVE	T1,A		;GET CONTROL CHAR
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	MOVSI	A,440700	;MAKE BP
	HRRI	A,2(B)		;POINT TO STRING
FLCTL1:	ILDB	T1,A		;GET BYTE
	JUMPE	T1,CPOPJ1	;ALL DONE
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO ROOM
	JRST	FLCTL1		;LOOP UP


;***** FIRST LEVEL COMMANDS

;***** THE "NODES" COMMAND

NODPNT:	PUSHJ	P,READTY	;READ CONFIG FILE
	  JRST	NOTYFL		;NOT THERE
	PUSHJ	P,TTYOTP	;SET FOR OUTPUT TO TTY
TYPALL:	MOVSI	D,-MAXNOD	;SET UP A POINTER
TYPLIN:	TYPE	<
ENTRY	NODE	TTY	MACHINE	INPUT	OUTPUT	STATUS	INUSE
-----	----	---	-------	-----	------	------	-----

>
TTYLP1:	MOVE	A,NODTAB(D)	;GET NODE
	JUMPE	A,CPOPJ		;FINISHED
	HRRZ	A,D		;GET ENTRY NUMBER
	PUSHJ	P,DECPNT	;PRINT IT
	PUSHJ	P,TAB
	MOVE	A,NODTAB(D)	;PRINT NODE
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,TTYTAB(D)	;GET TTY
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,MACHIN(D)	;GET MACHINE TYPE
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB
	MOVE	A,RCVSPD(D)	;INPUT SPEED
	PUSHJ	P,DECPNT
	PUSHJ	P,TAB
	MOVE	A,XMTSPD(D)	;OUTPUT SPEED
	PUSHJ	P,DECPNT
	PUSHJ	P,TAB
	MOVE	A,STATUS(D)	;STATUS
	PUSHJ	P,SIXPNT
	PUSHJ	P,TAB
	MOVE	A,[SIXBIT/FREE/]
	MOVE	T1,TTYTAB(D)	;GET TTY NUMBER
	PUSHJ	P,TTYAVL	;IN USE?
	  MOVE	A,[SIXBIT /BUSY/]
	PUSHJ	P,SIXPNT
	SKIPN	TLYNUM(D)	;ARE WE DIAL UP?
	JRST	TTYLP2		;NO
	TYPE	<
	TELEPHONE NUMBER : >
	MOVE	A,TLYNUM(D)	;GET IT
	PUSHJ	P,OUTFIL
TTYLP2:	PUSHJ	P,CRLF
	AOBJN	D,TTYLP1	;DO ALL
	POPJ	P,


;***** THE "MODIFY" COMMAND TO MODIFY A "LINKUP.SYS" FILE

MODIFY:	PUSHJ	P,READTY	;READ THE FILE
	  TYPE	<
NO LINKUP.SYS ON SYSTEM
>
UPDLP1:	PUSHJ	P,TTYIO		;SET FOR TTY
	TYPE	<
ACTION(TYPE "HELP" FOR HELP) : >
	PUSHJ	P,GETSIX	;GET COMMAND
	JUMPE	T1,UPDLP1
	MOVE	A,[UPDDSP,,UPDCOM]	;GET TABLE OF COMMANDS
	PUSHJ	P,SERTAB	;FIND IT
	  MOVEI	B,UPDERR	;HELP HIM
	PUSHJ	P,(B)		;DO IT
	PUSHJ	P,TIDY
	JRST	UPDLP1		;DO MORE

UPDERR:	TYPE	<
ILLEGAL COMMAND-->
	PUSHJ	P,TIDY
UPDHLP:	TYPE	<COMMANDS >
	MOVE	E,[UPDHPT,,UPDCOM]
	JRST	TABLST


;***** ROUTINE TO INPUT DETAILS ABOUT A COMMUNICATION
;***** CHANNEL DURING THE "MODIFY" COMMAND.

TTYDET:	PUSHJ	P,GETSIX	;GET NAME
	HLRZ	T2,T1		;GET LEFT HALF
	CAIE	T2,(SIXBIT /TTY/) ;FORCING A TTY?
	JRST	CPOPJ1		;NO
	MOVEM	T1,TTY		;SAVE TTYNAME
	PUSHJ	P,TTYAVL	;AVAILABLE?
	  JRST	BUSYTT		;NOT AVAILABLE
	TYPE	<
NODE NAME :>
	PUSHJ	P,GETSIX	;GET REPLY
	MOVEM	T1,NODE
	TYPE	<
MACHINE TYPE :>
	PUSHJ	P,GETSIX
	MOVEM	T1,MACTYP	;SAVE IT
	TYPE	<
INPUT SPEED :>
	PUSHJ	P,GETNUM	;GET REPLY
	MOVEM	A,RSPED
	TYPE	<
OUTPUT SPEED :>
	PUSHJ	P,GETNUM
	MOVEM	A,XSPED
	TYPE	<
TELEPHONE NUMBER :>
	MOVEI	T1,TLYBUF	;POINT TO FREE AREA FOR TELE
	MOVEM	T1,TLYPTR	;-PHONE NUMBER
	PUSHJ	P,TELEIN	;GET IT
	  SETZM	T2		;NONE
	MOVEM	T2,NUMTLY	;SET TELEPHONE NUMBER
	POPJ	P,
BUSYTT:	TYPE	<
TTY NOT AVAILABLE
>
	POP	P,(P)
	POPJ	P,

;***** ROUTINE TO ADD A COMMUNICATION CHANNEL DURING
;***** THE "MODIFY" COMMAND.

ADDTTY:	MOVSI	D,-MAXNOD	;MAKE A POINTER
ADDLP2:	SKIPN	NODTAB(D)	;CHECK ENTRY
	JRST	ADDLP1		;OK
	AOBJN	D,ADDLP2	;LOOP UP
	TYPE	<
TOO MANY NODES
>
	POPJ	P,
ADDLP1:	PUSHJ	P,TSTPAR	;ANY MORE?
	TYPE	<
NODE : >
	PUSHJ	P,GETSIX	;GET NODE NAME
	MOVEM	T1,NODTAB(D)	;SAVE IT
	PUSHJ	P,NODSRT	;GO DO THE MACHINE TYPE
	TYPE	<
TTY NAME : >
	PUSHJ	P,GETTTY	;GET IT
	MOVEM	T1,TTYTAB(D)
	TYPE	<
INPUT SPEED : >
	PUSHJ	P,GETNUM	;GET IT
	MOVEM	A,RCVSPD(D)
	TYPE	<
OUTPUT SPEED : >
	PUSHJ	P,GETNUM
	MOVEM	A,XMTSPD(D)
	TYPE	<
TELEPHONE NUMBER : >
	PUSHJ	P,TELEIN	;GET TELEPHONE NUMBER
	  SETZM	T2		;NONE
	MOVEM	T2,TLYNUM(D)	;SAVE IT
	TYPE	<
STATUS : >
	PUSHJ	P,GETSIX
	MOVEM	T1,STATUS(D)
	POPJ	P,


;***** ROUTINE TO DELETE A COMMUNICATIONS CHANNEL
;***** DURING THE "MODIFY" COMMAND.

DELTTY:	PUSHJ	P,TSTPAR	;ANY MORE?
	TYPE	<
ENTRY NUMBER : >
	PUSHJ	P,GETNUM	;GET NUMBER
	CAIG	A,MAXNOD	;TOO BIG?
	SKIPN	NODTAB(A)	;ENTRY EXIST?
	JRST	NOENT		;NO
	SETZM	TTYTAB(A)	;CLEAR TTY ENTRY
	SETZM	NODTAB(A)	;AND THE NODE
	SETZM	MACHIN(A)
	TYPE	<
DONE
>
	POPJ	P,
NOENT:	TYPE	<
NO ENTRY WITH THAT NUMBER
>
	POPJ	P,

;***** THE "TYPE" COMMAND DURING "MODIFY"

MODTYP:	PUSHJ	P,TSTPAR	;ANY MORE?
	  JRST	TYPALL		;DO ALL
	PUSHJ	P,GETNUM	;GET ARGUMENT
	MOVE	D,A		;COPY IT
	CAIG	D,MAXNOD	;TOO MUCH?
	JRST	TYPLIN		;DO IT
	TYPE	<
OUT OF RANGE
>
	POPJ	P,

;***** ROUTINE TO CHANGE COMMUNICATION CHANNEL PARAMETERS
;***** DURING THE "MODIFY" COMMAND.

CHGTTY:	PUSHJ	P,TSTPAR	;ANY MORE?
	TYPE	<
CHANGE ENTRY :>
	PUSHJ	P,GETNUM	;GET ENTRY NUMBER
	CAIG	A,MAXNOD	;TOO BIG?
	SKIPN	NODTAB(A)	;EXIST?
	JRST	NOENT		;NO
	MOVE	D,A		;COPY NUMBER
	TYPE	<
NODE(>
	MOVE	A,NODTAB(D)	;GET NAME
	PUSHJ	P,SIXPNT	;PRINT IT
	TYPE	<) :>
	PUSHJ	P,GETSIX	;GET IT
	SKIPE	T1		;SUPPLIED?
	MOVEM	T1,NODTAB(D)	;MODIFY IT
	PUSHJ	P,NODSRT	;GET MACHINE TYPE
	TYPE	<
TTY NAME(>
	MOVE	A,TTYTAB(D)	;GET ENTRY
	PUSHJ	P,SIXPNT	;PRINT IT
	TYPE	<) :>
	PUSHJ	P,GETTTY	;GET REPLY
	SKIPE	T1		;SUPPLIED?
	MOVEM	T1,TTYTAB(D)	;SAVE IT
	TYPE	<
INPUT SPEED(>
	MOVE	A,RCVSPD(D)	;GET INPUT SPEED
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	<) :>
	PUSHJ	P,GETNUM	;GET NUMBER
	SKIPE	A
	MOVEM	A,RCVSPD(D)
	TYPE	<
OUTPUT SPEED(>
	MOVE	A,XMTSPD(D)	;GET XMT SPEED
	PUSHJ	P,DECPNT	;PRINT IT
	TYPE	<) :>
	PUSHJ	P,GETNUM	;GET NUMBER
	SKIPE	A
	MOVEM	A,XMTSPD(D)	;SAVE IT
	TYPE	<
TELEPHONE NUMBER(>
	SKIPE	TLYNUM(D)	;ONE THERE?
	MOVE	A,TLYNUM(D)	;TYPE IT
	PUSHJ	P,OUTFIL
	TYPE	<) :>
	PUSHJ	P,TELEIN	;GET IT
	  SKIPA			;NONE SUPPLIED
	MOVEM	T2,TLYNUM(D)	;SAVE IT
	TYPE	<
STATUS(>
	MOVE	A,STATUS(D)	;GET IT
	PUSHJ	P,SIXPNT
	TYPE	<) :>
	PUSHJ	P,GETSIX	;GET IT
	SKIPE	T1
	MOVEM	T1,STATUS(D)	;MODIFY IT
	POPJ	P,

;***** ROUTINE TO GET TELEPHONE NUMBER

TELEIN:	HRLI	T2,440700	;MAKE A BP
	HRR	T2,TLYPTR	;POINT TO FREE SPACE
	TRZ	F,F.ZER		;SET A FLAG
TELLP2:	PUSHJ	P,CHRIN		;GET A CHAR
	TLNN	C,C.NUM		;DIGIT?
	JRST	TELLP1		;NO
TELLP4:	IDPB	C,T2		;SAVE IT
	TRO	F,F.ZER		;SET FLAG
	JRST	TELLP2		;LOOP UP
TELLP1:	TLNN	C,C.MOVP	;LINE FEED?
	JRST	TELLP3		;NO
	TRZN	F,F.ZER		;ANY THERE?
	POPJ	P,		;NO
	SETZM	C		;MAKE ASCIZ
	IDPB	C,T2		;SAVE IT
	AOS	T2		;BUMP POINTER
	EXCH	T2,TLYPTR	;GET START ADDRESS
	HRLI	T2,440700	;MAKE A BP
	JRST	CPOPJ1		;SKIP RETURN
TELLP3:	TLNE	C,C.DASH	;HYPHEN?
	JRST	TELLP4		;GOOD
	PUSHJ	P,TIDY
	TYPE	<
BAD FORMAT-TRY AGAIN
>
	JRST	TELEIN		;RESTART

;***** EXIT FROM THE "MODIFY" COMMAND

UPDEXT:	POP	P,(P)		;ADJUST PUSH POINTER
	PUSHJ	P,WRITTY	;WRITE OUT THE FILE
	TYPE	<
ERROR WRITING FILE
>
	POPJ	P,

;***** ROUTINE TO ASK FOR THE TTY NAME FOR COMMUNICATIONS.

GETTTY:	PUSHJ	P,GETSIX	;GET TTY NAME
	JUMPE	T1,CPOPJ	;NULL NAME
	HLRZ	T2,T1		;GET LEFT HALF
	CAIN	T2,(SIXBIT /TTY/) ;IS IT OK?
	POPJ	P,		;YES
	TYPE	<
PLEASE TYPE TTY AS "TTYNNN" :>
	JRST	GETTTY

;***** ROUTINE TO SET NODE-MACHINE CORRESPONDENCE

NODSRT:	MOVE	A,NODTAB(D)	;GET NODE NAME
	MOVSI	B,-MAXNOD	;MAKE A POINTER
NODLP1:	CAMN	A,NODTAB(B)	;FIND A MATCH?
	JRST	CHKNOD		;YES
NODLP2:	AOBJN	B,NODLP1	;LOKK AT ALL
	TYPE	<
NEW NODE--MACHINE TYPE :>
	PUSHJ	P,GETSIX	;GET REPLY
	MOVEM	T1,MACHIN(D)	;SAVE IT
	POPJ	P,		;RETURN
CHKNOD:	SKIPN	MACHIN(B)	;NULL ENTRY?
	JRST	NODLP2		;YES
	TYPE	<
MACHINE TYPE(>
	MOVE	A,MACHIN(B)	;GET IT
	PUSHJ	P,SIXPNT	;PRINT IT
	TYPE	<) :>
	PUSHJ	P,GETSIX	;GET REPLY
	JUMPN	 T1,CONFND	;NEW TYPE
	MOVE	A,MACHIN(B)	;GET MACHINE TYPE
	MOVEM	A,MACHIN(D)	;MODIFY
	POPJ	P,
CONFND:	MOVSI	B,-MAXNOD	;RESET POINTER
	MOVE	T2,NODTAB(D)	;GET NODE NAME
NODLP3:	CAMN	T2,NODTAB(B)	;MATCH?
	MOVEM	T1,MACHIN(B)	;MODIFY
	AOBJN	B,NODLP3	;LOOP FOR ALL
	POPJ	P,

;***** ASSORTED ERROR MESSAGES.

NOTTY:	TYPE	<
NO TTYS AVAILABLE
>
	POPJ	P,
BADTTY:	TYPE	<
SELECTED TTY COULD NOT BE INITIALISED CORRECTLY
PLEASE INFORM THE SYSTEM MANAGER
>
	JRST	RELTTY
BADLOG:	TYPE	<
UNABLE TO LOGIN A JOB
>
	JRST	LOGOUT
BADREC:	TYPE	<
UNABLE TO RUN RECEIVER PROGRAM AT THE SELECTED NODE
>
	JRST	LOGOUT

UNKMAC:	TYPE	<
UNKNOWN MACHINE TYPE
>
	POPJ	P,


;***** ROUTINE TO LOGIN A JOB ON A DEC10

LGND10:	TYPE	<
PPN : >
	PUSHJ	P,TTYIO		;SET FOR TTY I/O
	PUSHJ	P,GETOCT	;GET FIRST PART
	HRLZ	A,T1		;SAVE IT
	TLNN	C,C.COM		;COMMA?
	JRST	ERRPPN		;BAD
	PUSHJ	P,GETOCT	;GET NEXT PART
	PUSHJ	P,TIDY		;TIDY UP
	HRR	A,T1
	MOVEM	A,PPND10	;SAVE IT
	TYPE	<
PASSWORD : >
	PUSHJ	P,GETSIX	;GET IT
	MOVEM	T1,PASSWD	;SAVE IT
	PUSHJ	P,TIDY		;TIDY UP
	PUSHJ	P,CHNOTP	;SET FOR CHANNEL OUTPUT
	PRINT	<LOGIN >
	HLRZ	A,PPND10	;GET PPN
	PUSHJ	P,OCTPNT
	MOVEI	T1,"/"
	PUSHJ	P,OUTP		;SEND A SLASH
	HRRZ	A,PPND10
	PUSHJ	P,OCTPNT
	MOVEI	T1,15
	PUSHJ	P,OUTP		;SEND CHAR
	PUSHJ	P,DELAY3	;WAIT 3 SECONDS
	MOVE	A,PASSWD	;GET PASSWORD
	PUSHJ	P,SIXPNT	;SEND IT
LOGCOM:	MOVEI	T1,15
	PUSHJ	P,OUTP		;SEND CR
	PUSHJ	P,PUTOUT	;SEND MESSAGE
	PUSHJ	P,TTYIO		;RESET TTY IO
	MOVE	A,PRMT(X)	;GET EXPECTED CHAR
	MOVEM	A,CHRMCH	;SAVE IT
	JRST	CHRLST		;CHECK AND LOG CHARS

ERRPPN:	TYPE	<
INCORRECT FORMAT--TRY AGAIN>
	PUSHJ	P,TIDY
	JRST	LGND10		;GO ROUND AGAIN

;***** ROUTINE TO LOGIN A JOB ON A DEC20

LGND20:	TYPE	<
USER: >
	PUSHJ	P,TTYIO		;SET FOR TTYIO
	MOVEI	B,USESTG	;SPACE FOR USER STRING
	MOVE	C,LSTCHR	;GET LAST CHARACTER
	TLZ	C,C.MOVP	;MAKE SURE NOT TIDY
	MOVEM	C,LSTCHR	;STUFF IT AWAY
	PUSHJ	P,FILSTG	;GET IT
	PUSHJ	P,TIDY		;TIDY UP
	TYPE	<
PASSWORD: >
	MOVEI	B,PASSTG	;SPACE FOR PASSWORD
	MOVE	C,LSTCHR
	TLZ	C,C.MOVP
	MOVEM	C,LSTCHR
	PUSHJ	P,FILSTG	;GET IT
	PUSHJ	P,TIDY		;TIDY UP
	TYPE	<
ACCOUNT: >
	MOVEI	B,ACCSTG	;SPACE FOR ACCOUNT STRING
	MOVE	C,LSTCHR
	TLZ	C,C.MOVP
	MOVEM	C,LSTCHR
	PUSHJ	P,FILSTG	;GET IT
	PUSHJ	P,TIDY		;TIDY UP
	PUSHJ	P,CHNOTP	;SET FOR CHANNEL OUTPUT
	PRINT	<LOGIN >
	PUSHJ	P,ALTMOD	;SEND AN ALTMODE
	PRINT1	USESTG+2	;SEND STRING
	PUSHJ	P,ALTMOD	;SEND AN ALTMOD
	PRINT1	PASSTG+2	;SEND PASSWORD
	PUSHJ	P,ALTMOD	;SEND AN ALTMODE
	PRINT1	ACCSTG+2	;SEND ACCOUNT REF
	JRST	LOGCOM		;THE REST IS THE SAME AS THE 10


;***** ROUTINE TO LOGIN A JOB--CALLS MACHINE-
;***** DEPENDENT ROUTINES.

LOGIN:	MOVE	X,MACADR	;GET ADDRESS OF BLOCK
	PUSHJ	P,WAKEUP	;WAKE LINE UP
	  POPJ	P,		;CANNOT
	TYPE	<
CONNECTED--PLEASE LOGIN
>
	PUSHJ	P,@LGIN(X)	;MACHINE DEPENDENT
	  POPJ	P,		;CANNOT
	JRST	CPOPJ1		;OK

;***** ROUTINE TO LOGOUT A JOB--CALLS MACHINE-
;***** DEPENDENT ROUTINES.

LOGOUT:	MOVE	X,MACADR	;GET MACHINE BLOCK
	TRZ	F,F.TTYNH
	TYPE	<
LOGGING OFF NOW
>
	PUSHJ	P,TYPIT	;TYPE THE STRING
	CAIE	X,BDEC20	;ARE WE LOGGING OUT A DEC-20 ?
	JRST	LGOD10		;NOPE, TOPS-10
	TRNE	F,F.RDET	;IS REMOTE RUNNING DETACHED ?
	JRST	LGOD20		;YES, SET LOGOUT CONTROL MESSAGE
LGOD10:	PUSHJ	P,WINDUP	;GO WIND UP THE PROTO
	PUSHJ	P,CHNOTP	;SET FOR CHANNEL OUTPUT
	MOVE	A,LGOUT(X)	;GET ADDRESS OF STRING
	PUSHJ	P,OUTFIL	;SEND IT
	PUSHJ	P,PUTOUT	;TRANSMIT IT
	MOVE	A,PRMT(X)	;GET PROMPT CHAR
	MOVEM	A,CHRMCH	;SAVE IT
	PUSHJ	P,CHRLST
	  JFCL
	JRST	RELTTY

LGOD20:	PUSHJ	P,SNDSHT
	PUSHJ	P,DELAY2
	MOVEI	T1,CT.LGO	;SEND LOGOUT CONTROL(JOB IS DETACHED)
	PUSHJ	P,CTLPUT	;SEND IT
	  JRST	NRMCTL		;NO MORE ROOM FOR CONTROL
	JRST	RELTTY


;***** ROUTINE TO RUN THIS PROGRAM AT REMOTE MACHINE

RUNJOB:	MOVE	X,MACADR	;GET MACHINE BLOCK
	PUSHJ	P,CHNOTP	;SET FOR CHANNEL OUTPUT
	MOVE	A,RNJOB(X)	;GET STRING TO TYPE
	PUSHJ	P,OUTFIL	;SEND IT
	MOVEI	T1,15		;SEND CR
	PUSHJ	P,OUTP		;SEND IT
	PUSHJ	P,PUTOUT	;TRANSMITIT
	PUSHJ	P,TTYOTP	;TTY OUTPUT
	MOVEI	A,"*"		;GET OUR PROMPT
	MOVEM	A,CHRMCH		;SAVE IT
	PUSHJ	P,CHRLST	;GET INPUT CHAR
	  POPJ	P,		;FAILURE
	PUSHJ	P,CHNOTP	;SET CHANNEL OUTPUT
	MOVE	A,[SIXBIT /PASSIV/]
	PUSHJ	P,SIXPNT	;SEND COMMAND
	MOVEI	T1,15
	PUSHJ	P,OUTP
	PUSHJ	P,PUTOUT	;TRANSMIT CHAR
	MOVEI	A,"#"		;RUNNING PROMPT
	MOVEM	A,CHRMCH
	JRST	CHRLST		;SOAK UP CHARS


;***** ROUTINE TO GET AND LOG CHARACTERS FROM THE
;***** COMMUNICATIONS CHANNEL DURING BOOTSTRAPPING.

CHRLST:	PUSHJ	P,CHNINP	;CHANNEL INPUT
	PUSHJ	P,TTYOTP	;TTY OUTPUT
	TRO	F,F.ZER		;SET TO IGNORE BLANK LINES
	SETZM	CHNLST		;CLEAR LAST CHAR TYPED
OURPMT:	PRINT	<
## >
CHRLP1:	MOVEI	C,^D20		;RESET TIMEOUT COUNT
	MOVEM	C,CHNCNT	;SAVE IT
CHRLP2:	PUSHJ	P,CHNASC	;GET CHAR
	  JRST	CHKLSS		;CHECK LAST CHAR
	ANDI	C,177		;JUST ASCII
	MOVE	T1,C		;COPY IT
	MOVEM	T1,CHNLST	;SAVE IT
	CAIE	T1,177		;RUBOUT?
	CAIN	T1,15		;CR?
	JRST	CHRLP1		;IGNORE IT
	CAIE	T1,12		;LF?
	JRST	NTLF		;NO
	TROE	F,F.ZER		;BLANK LINE?
	JRST	CHRLP1		;IGNORE IT
	JRST	OURPMT		;USE IT
NTLF:	TRZ	F,F.ZER		;CLEAR FLAG
	PUSHJ	P,OUTP		;TYPE IT
	JRST	CHRLP1		;LOOP UP

CHKLSS:	MOVE	C,CHNLST	;GET LAST CHAR
	CAMN	C,CHRMCH	;WHAT WE WANT?
	JRST	CPOPJ1		;YES
	SOSL	CHNCNT		;ELSE COUNT DOWN
	JRST	CHRLP2		;AND LOOP UP
	POPJ	P,		;FAILED


;***** ROUTINE TO SET TTY SPEED ON DEC10

SPDD10:	PUSHJ	P,CHNOTP	;SET FOR CHANNEL OUTPUT
	PRINT	<SET TTY SPEED >
SPDCOM:	MOVE	A,RSPED		;GET RECEIVE SPEED
	PUSHJ	P,DECPNT	;PRINT IT
	MOVEI	T1,40		;THROW A SPACE
	PUSHJ	P,OUTP
	MOVE	A,XSPED
	PUSHJ	P,DECPNT	;PRINT IT
	MOVEI	T1,15		;JUST A CR
	PUSHJ	P,OUTP
	JRST	PUTOUT

;***** ROUTINE TO SET TTY SPEED ON DEC20

SPDD20:	PUSHJ	P,CHNOTP
	PRINT	<TERMINAL SPEED >
	JRST	SPDCOM		;GO DO IT

;***** ROUTINE TO WIND-UP THE OTHER END

WINDUP:	PUSHJ	P,SNDSHT	;SEND PROTOCOL MESSAGE
	PUSHJ	P,DELAY2	;WAIT A SECOND
	PUSHJ	P,CNTRLC	;SEND A ^C
	PUSHJ	P,CNTRLC	;TWO OF THEM
	MOVE	A,PRMT(X)	;GET PROMPT
	MOVEM	A,CHRMCH	;SAVE IT
	PUSHJ	P,CHRLST	;GET AND LOG RESULTS
	  JFCL
	POPJ	P,

;***** ROUTINE TO SET "MACADR" TO POINT TO MACHINE-
;***** DEPENDENT BLOCK.

STBLK:	MOVE	A,[MACBLK,,MACLST]
	MOVE	T1,MACTYP	;GET MACHINE TYPE
	PUSHJ	P,SERTAB	;FIND MACHINE
	  POPJ	P,
	MOVEM	B,MACADR	;SAVE ADDRESS OF BLOCK
	JRST	CPOPJ1

;***** ROUTINE TO TRY TO WAKE UP A LINE

TRYWAK:	PUSHJ	P,CNTRLC	;PUMP A CONTROL C
	PUSHJ	P,CNTRLC	;AND ANOTHER
	PUSHJ	P,CNTRLC	;AND AGAIN
IFN T1026,<
	PUSHJ	P,CHNOTP
	PRINT	<SET TTY NO RTE
>
	PUSHJ	P,CNTRLC
>;END OF 1026 CONDITIONAL
	MOVE	A,PRMT(X)	;GET PROMPT
	MOVEM	A,CHRMCH	;SAVE IT
	JRST	CHRLST		;GET CHARS AND LOG THEM


;***** ROUTINE TO GET A CHAR FROM THE CHANNEL

CHNASC:	MOVEI	C,3		;WAIT TIME
	MOVEM	C,CHNTIM	;INITIALISE
CHNAL1:	PUSHJ	P,GETCHR	;GET CHAR
	  JRST	[MOVEI	C,^D100
		IFE DEC20,<
		HRLI	C,(HB.RTC!HB.RTL!HB.RIO)
		>;END DEC20
		JRST	CHNAL2]
	JRST	CPOPJ1		;GOT CHAR
CHNAL2:	HIBER	C,		;LIKE I SAID--WAIT
	JFCL
	SOSL	CHNTIM		;DECREMENT TIME
	JRST	CHNAL1
	POPJ	P,		;TIME OUT

;***** ROUTINE TO PUMP A CONTROL C DOWN THE CHANNEL

CNTRLC:	MOVE	T1,CNTC(X)	;GET A CONTROL C
	PUSHJ	P,PUTCHR	;SEND IT
	PUSHJ	P,PUTOUT
	JRST	DELAY1		;GO DELAY FOR HALF A SECOND

;***** ROUTINES TO DELAY FOR A WHILE

DELAY1:	SKIPA	T1,[EXP ^D500]	;HALF A SECOND
DELAY2:	MOVEI	T1,^D1000	;ONE SECOND
IFE DEC20,<
	HIBER	T1,		;HIBERNATE
	  JFCL>
IFN DEC20,<
	EXCH	AC1,T1
	DISMS
	EXCH	AC1,T1
>
	POPJ	P,
DELAY3:	MOVEI	T1,^D3000	;3 SECONDS
IFE DEC20,<
	HIBER	T1,
	  JFCL
>
IFN DEC20,<
	EXCH	AC1,T1
	DISMS
	EXCH	AC1,T1
>
	POPJ	P,


;***** ROUTINE TO WAKEUP A LINE *****

WAKEUP:	PUSHJ	P,TRYWAK	;TRY IT AS IT IS
	  JRST	AUTOBD		;CANNOT GET REPLY
GOTCOM:	PUSHJ	P,CHNOTP	;OK--SET CHANNEL OUTPUT
	PUSHJ	P,@SETCOD(X)	;SET SPEED AT REMOTE
	PUSHJ	P,DELAY3	;WAIT
	PUSHJ	P,DELAY2
	PUSHJ	P,DELAY2
	MOVE	A,RSPED		;GET DESIRED RECEIVE SPEED
	PUSHJ	P,SETRCV	;SET IT
	MOVE	A,XSPED		;GET XMT SPEED
	PUSHJ	P,SETXMT	;SET IT
	PUSHJ	P,DELAY2	;WAIT A SECOND
	PUSHJ	P,DELAY2
	PUSHJ	P,DELAY2
	PUSHJ	P,TRYWAK	;TRY AGAIN
	  JRST	WAKEUP		;NO GOOD
	JRST	CPOPJ1

AUTOBD:	MOVSI	D,-MAXSPD	;MAKE A POINTER
AUTLP1:	HLRZ	A,SPDTAB(D)	;GET RECEIVE SPEED
	PUSHJ	P,SETRCV	;SET IT
	HRRZ	A,SPDTAB(D)	;GET XMT
	PUSHJ	P,SETXMT	;SET IT
	PUSHJ	P,TRYWAK	;TRY THE LINE NOW
	  SKIPA			;NO GOOD
	JRST	GOTCOM		;OK
	AOBJN	D,AUTLP1
	POPJ	P,

;***** ROUTINE TO SET BIT TO STOP AUTO BAUDING

NOAUTO:	TLO	F,F.AUTO	;SET IT
	POPJ	P,		;RETURN

;***** ROUTINE TO CLEAR BIT TO START AUTO BAUDING

AUTO:	TLZ	F,F.AUTO	;CLEAR IT
	POPJ	P,

;***** ROUTINE TO SET SPEEDS *****

IFE DEC20,<
SETRCV:	TRNE	F,F.AUTO	;ARE WE DOING AUTO BAUD ?
	POPJ	P,		;NO, JUST RETURN
	PUSHJ	P,GETCOD	;GET CODE FOR SPEED
	MOVEM	A,SPDBLK+2	;SAVE IT
	MOVEI	A,2030		;SET RCV
	JRST	SPDSET
SETXMT:	TRNE	F,F.AUTO	;AUTO BAUD ?
	POPJ	P,		;NO
	PUSHJ	P,GETCOD	;GET CODE
	MOVEM	A,SPDBLK+2
	MOVEI	A,2031		;SET XMT
SPDSET:	MOVEM	A,SPDBLK
	MOVE	A,[XWD 3,SPDBLK]
    IFE TYM10!TYMAUX,<	; Don't even worry about it!
	TRMOP.	A,
	JFCL
    > ; End IFE TYM10!TYMAUX
	POPJ	P,
>
IFN DEC20,<
SETRCV:	TRNE	F,F.AUTO	;AUTO BAUD ?
	POPJ	P,		;NO
	EXCH	B,AC1		;SAVE AC1
	EXCH	AC2,C
	MOVE	AC1,TTY		;GET THE JFN
	MOVEI	AC2,26		;MTOPR CODE FOR SETTING LINE SPEEDS
	HRLS	A
	MTOPR			;AC3 HAS THE LINE SPEED TO SET
	EXCH	AC1,B		;RESTORE AC1
	EXCH	AC2,C		;AND AC2
	POPJ	P,		;RETURN

SETXMT:	TRNE	F,F.AUTO	;AUTO BAUD ?
	POPJ	P,		;NO
	EXCH	AC1,B		;SAVE AC'S
	EXCH	AC2,C		;
	MOVE	AC1,TTY		;GET THE JFN
	MOVEI	AC2,26		;CODE TO SET LINE SPEEDS
	HRLS	A
	MTOPR			;SET IT
	EXCH	AC1,B
	EXCH	AC2,C
	POPJ	P,
>


;***** ROUTINE TO GET CODE RELATING TO SPEED FOR TRMOP. *****

GETCOD:	PUSH	P,D		;SAVE D
	SETZM	D		;SET POINTER
CODLP1:	HLRZ	B,CODSPD(D)	;GET ENTRY
	JUMPE	B,CODEND	;ALL DONE
	CAMGE	B,A		;MATCH?
	AOJA	D,CODLP1
CODEND:	HRRZ	A,CODSPD(D)	;GET CODE
	POP	P,D		;RESTORE D
	POPJ	P,

;***** THE "PASSIV" COMMAND

PASSIV:	TYPE	<
LINKUP running in PASSIVE mode
#>
	MOVEI	A,^D7		;WAIT 7 SECONDS
IFE DEC20,<
	SLEEP	A,
>
IFN DEC20,<
	MOVEI	AC1,^D7000
	DISMS
>
	TLO	F,F.PASS	;FLAG PASSIVE
	MOVE	A,OURTTY	;GET OUR TTY
	MOVEM	A,TTY		;SAVE IT
	PUSHJ	P,OPNTTY	;OPEN CHANNEL D
IFE DEC20,<
	  EXIT			;HELP!!!
>
IFN DEC20,<
	HALTF
>
	JRST	PROTO		;GO START THE PROTOCOL


;***** ROUTINES TO SET FOR INPUT AND OUTPUT *****

DSKINP:	TLZ	F,F.ITTY+F.ICHN	;RESET SOME BITS
	TLO	F,F.IDSK	;SET FOR DSK INPUT
	HRRM	T1,INEOF
	POPJ	P,

DSKOTP:	TLZ	F,F.OTTY+F.OCHN	;RESET SOME BITS
	TLO	F,F.ODSK	;SET FOR DSK OUTPUT
	HLLM	T1,INEOF
	POPJ	P,

TTYINP:	TLZ	F,F.ICHN+F.IDSK	;RESET
	TLO	F,F.ITTY	;TTY INPUT
	HLLZS	INEOF
	POPJ	P,

TTYOTP:	TLZ	F,F.OCHN+F.ODSK	;RESET
	TLO	F,F.OTTY	;TTY OUTPUT
	HRRZS	OUTEOF
	POPJ	P,

CHNINP:	TLZ	F,F.ITTY+F.IDSK
	TLO	F,F.ICHN
	HRRM	T1,INEOF
	POPJ	P,

CHNOTP:	TLZ	F,F.OTTY+F.ODSK
	TLO	F,F.OCHN
	HLLM	T1,OUTEOF
	POPJ	P,

;***** ROUTINE TO SET FOR BOTH I/O *****

TTYIO:	PUSHJ	P,TTYINP	;SET INPUT
	JRST	TTYOTP		;THEN OUTPUT

DSKIO:	PUSHJ	P,DSKINP
	JRST	DSKOTP

CHNIO:	PUSHJ	P,CHNINP
	JRST	CHNOTP

;***** ROUTINE TO DO INPUT *****

INP:	TRZN	F,F.LSCH	;RE-USE LAST CHAR?
	JRST	USENEW		;NO
	MOVE	C,LSTCHR	;YES
	POPJ	P,
USENEW:	SKIPE	INCORE		;TAKING INPUT FROM CORE?
	JRST	COREIN		;YES
	TLNE	F,F.ITTY	;TTY?
	JRST	TTYIN		;YES
	TLNE	F,F.IDSK	;DSK?
	JRST	DSKIN
	JRST	CHNIN		;GET FROM CHANNEL

;***** ROUTINE TO DO OUTPUT *****

OUTP:	SKIPE	OTCORE		;OUTPUT TO CORE?
	JRST	COREOT		;YES
	TRNE	F,F.TTYNH	;TTY NO HANG?
	JRST	SPCTTY		;GO DO IT
	TLNE	F,F.OTTY	;TTY?
	PUSHJ	P,TTYOUT	;YES
	TLNE	F,F.ODSK	;DSK?
	PUSHJ	P,DSKOUT	;DO IT
	TLNE	F,F.OCHN	;CHANNEL?
	JRST	CHNOUT
	POPJ	P,

;***** ROUTINE TO OUTPUT TO TTY WITHOUT GOING INTO TO *****

SPCTTY:	PUSHJ	P,TYPOUT	;TRY TO OUTPUT
	  JFCL			;TO HELL WITH IT
	POPJ	P,

;***** ROUTINE TO LOOKUP A FILE *****

LOOKFL:	
IFE DEC20,<
	OPEN	1,(B)		;OPEN CHANNEL FOR ASCII
	  POPJ	P,
	MOVE	D,3(A)		;GET PPN
	MOVE	B,1(A)		;GET EXTENSION
	MOVE	A,(A)		;AND NAME
	LOOKUP	1,A		;FIND FILE
	  POPJ	P,		;NOT THERE
	JRST	CPOPJ1		;SKIP RETURN
>
IFN DEC20,<
	MOVE	AC1,[1B2!1B17]	;OLD FILE, SHORT FORM GTJFN
LOOKF1:	HRROI	AC2,TRNSPC	;'LINKUP.SYS' FILE SPEC
	GTJFN			;GET A JFN FOR IT
	  ERJMP	CPOPJ		;NOT THERE!!
	MOVEM	AC1,INPJFN	; THE JFN
	MOVE	AC2,[7B5!1B19]
	OPENF			;OPEN THE FILE
	  ERJMP	CPOPJ		;ERROR!!
	JRST	CPOPJ1		;RETURN GOOD
	>

;***** ROUTINE TO ENTER A FILE *****

ENTFIL:	
IFE DEC20,<
	OPEN	1,(B)		;OPEN CHANNEL FOR ASCII
	  POPJ	P,		;CANNOT
	MOVE	D,3(A)		;GET PPN
	MOVE	C,2(A)
	MOVE	B,1(A)		;AND EXTENSION
	MOVE	A,(A)
	ENTER	1,A
	  POPJ	P,
	JRST	CPOPJ1
>
IFN DEC20,<
	MOVE	AC1,[1B0!1B17]
	HRROI	AC2,TRNSPC		;GET FILE SPEC FOR SYS FILE
	GTJFN				;GET A JFN
	  ERJMP	CPOPJ
	MOVEM	AC1,OUTJFN		;SAVE THE JFN
	MOVE	AC2,[7B5!1B19!1B20!1B22]
	OPENF				;OPEN THE FILE
	  ERJMP	CPOPJ
	JRST	CPOPJ1
>

;***** ROUTINE TO CLOSE A FILE *****

CLOSFL:	
IFE DEC20,<
	CLOSE	1,
	STATO	1,740000	;ERROR?
	AOS	(P)		;SKIP RETURN
	RELEAS	1,
	POPJ	P,		;BAD
>
IFN DEC20,<
	SKIPN	AC1,INPJFN	;GET INPUT JFN IF THERE
	SKIPE	AC1,OUTJFN	;OR THE OUTPUT
	CLOSF			;CLOSE AND REALEASE THE JFN
	  ERJMP	CPOPJ		;ERROR
	SETZM	INPJFN		;CLEAR OUT JFN
	SETZM	OUTJFN		;BOTH
	JRST	CPOPJ1		;GOOD RETURN
>

;***** ROUTINE TO CHECK AVAILABILITY OF A TTY *****

TTYAVL:	MOVEM	T1,TSTTTY	;SAVE NAME OF TTY
	OPEN	17,TTYTST	;TRY TO INIT IT
    IFN TYM10,<			;IF TYMNET, THEN SKIP RETURN
	CAMN	T1,[SIXBIT /TYMNET/] ; ELSE SKIP TO "RELEAS"
    >
	AOS	(P)		;GIVE A SKIP RETURN
	RELEAS	17,		;WE DONT WANT IT FOR NOW
	POPJ	P,


;***** ROUTINE TO GET BEST TTY FOR THE JOB *****

FNDTTY:	PUSHJ	P,READTY	;GO READ THE LINKUP.SYS FILE
	  JRST	NOTYFL		;NOT THERE!!!!
	SETZM	TTY		;CLEAR FOR RESULT
	SETZM	RSPED
	SETZM	NUMTLY		;CLEAR TELEPHONE NUMBER
	SETZM	XSPED		;CLEAR SPEEDS
	MOVSI	D,-MAXNOD	;MAKE AN AOBJN POINTER
FNDLP1:	MOVSI	T1,(SIXBIT /UP/);IS IT UP?
	CAME	T1,STATUS(D)	;CHECK FILE
	JRST	NXTNOD		;NO
	MOVE	T1,NODTAB(D)	;GET NODE
	JUMPE	T1,NXTNOD	;IGNORE NULL
	CAME	T1,NODE		;IS IT OK?
	JRST	NXTNOD		;TRY NEXT
	MOVE	T1,TTYTAB(D)	;GET TTY
	PUSHJ	P,TTYAVL	;IS IT AVAILABLE?
	  JRST	NXTNOD		;NO
	MOVE	T2,RCVSPD(D)	;GET RECEIVE SPEED
	CAMGE	T2,RSPED	;FASTER?
	  JRST	NXTNOD
	MOVE	T3,XMTSPD(D)	;GET TRANSMIT SPEED
	CAMGE	T3,XSPED	;FASTER?
	  JRST	NXTNOD		;NO
	MOVEM	T1,TTY		;SAVE TTY
	MOVEM	T2,RSPED	;SAVE SPEEDS
	MOVEM	T3,XSPED	;BOTH OF THEM
	MOVE	T3,MACHIN(D)	;GET MACHINE TYPE
	MOVEM	T3,MACTYP	;SAVE IT
	MOVE	T3,TLYNUM(D)	;GET TELEPHONE NUMBER
	MOVEM	T3,NUMTLY	;SAVE IT
NXTNOD:	AOBJN	D,FNDLP1	;LOOP UP
	SKIPN	TTY		;FIND ONE?
	POPJ	P,
	PUSHJ	P,TTYOTP
	TYPE	<
LINKING TO >
	JRST	NODEID		;GO PRINT UP OUR CHOICE

;***** HERE TO PRINT CONNECTION DETAILS

NODEID:	MOVE	A,MACTYP	;GET MACHINE
	PUSHJ	P,SIXPNT
	TYPE	< AT NODE ">
	MOVE	A,NODE		;GET NODE
	PUSHJ	P,SIXPNT	;PRINT IT
	TYPE	<" USING >
	MOVE	A,TTY		;GET TTY
	PUSHJ	P,SIXPNT
	TYPE	< AT >
	MOVE	A,RSPED		;GET RECEIVE SPEED
	PUSHJ	P,DECPNT
	TYPE	< (INP) >
	MOVE	A,XSPED
	PUSHJ	P,DECPNT
	TYPE	< (OUT)
>
	JRST	CPOPJ1



;***** ROUTINE TO WRITE THE LINKUP.SYS FILE *****

WRITTY:	MOVEI	A,TRNSPC	;GET FILE SPEC
	MOVEI	B,DEVSPC	;AND DEVICE
	PUSHJ	P,ENTFIL	;OPEN IT
	  POPJ	P,		;TROUBLE
	MOVEI	T1,TRNEOF
	MOVEM	P,SAVP		;REMEMBER P FOR EOF
	PUSHJ	P,DSKOTP	;OUTPUT TO DSK
	MOVSI	D,-MAXNOD	;DO ALL
WRTLP1:	MOVE	A,NODTAB(D)	;GET NODE
	JUMPE	A,WRTLP2	;NULL ENTRY
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB
	MOVE	A,MACHIN(D)	;GET MACHINE
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB
	MOVE	A,TTYTAB(D)	;GET TTY
	PUSHJ	P,SIXPNT	;PRINT IT
	PUSHJ	P,TAB
	MOVE	A,RCVSPD(D)
	PUSHJ	P,DECPNT
	PUSHJ	P,TAB
	MOVE	A,XMTSPD(D)
	PUSHJ	P,DECPNT
	PUSHJ	P,TAB
	MOVE	A,STATUS(D)
	PUSHJ	P,SIXPNT
	SKIPN	TLYNUM(D)	;TELEPHONE?
	JRST	WRTLP3		;NO
	PRINT	< %>
	MOVE	A,TLYNUM(D)	;PRINT NUMBER
	PUSHJ	P,OUTFIL	;SEND IT
	PRINT	<%>
WRTLP3:	PRINT	<
>
WRTLP2:	AOBJN	D,WRTLP1
	PUSHJ	P,CLOSFL	;CLOSE UP THE FILE
	POPJ	P,
	JRST	CPOPJ1

NOTYFL:	TYPE	<
NO LINKUP.SYS ON SYSTEM
>
	POPJ	P,

;***** ROUTINE TO READ THE LINKUP.SYS FILE INTO CORE *****

READTY:	MOVEI	A,TRNSPC	;GET FILE SPEC
	MOVEI	B,DEVSPC	;GET DEVICE SPEC
	PUSHJ	P,LOOKFL	;FIND FILE
	  POPJ	P,		;NOT THERE
	MOVEI	T1,TRNEOF
	MOVEM	P,SAVP		;REMEMBER P FOR EOF
	PUSHJ	P,DSKINP	;SET FOR DSK INPUT
	MOVSI	D,-MAXNOD	;MAKE A POINTER
	SETZM	NODTAB
	MOVE	T1,[NODTAB,,NODTAB+1]
	BLT	T1,TRAND	;CLEAR FOR TABLE
	MOVEI	T1,TLYBUF	;ADDRESS FOR TELEPHONE NUMBERS
	MOVEM	T1,TLYPTR
RDLP1:	PUSHJ	P,GETSIX	;GET NODE
	MOVEM	T1,NODTAB(D)	;SAVE IT
	PUSHJ	P,GETSIX	;GET MACHINE TYPE
	MOVEM	T1,MACHIN(D)	;SAVE IT
	PUSHJ	P,GETSIX	;GET TTY NUMBER
	MOVEM	T1,TTYTAB(D)	;SAVE IT
	PUSHJ	P,GETNUM	;GET INPUT SPEED
	MOVEM	A,RCVSPD(D)	;SAVE IT
	PUSHJ	P,GETNUM	;GET OUTPUT SPEED
	MOVEM	A,XMTSPD(D)	;SAVE IT
	PUSHJ	P,GETSIX	;GET STATUS
	MOVEM	T1,STATUS(D)
	TRO	F,F.LSCH	;LOOK AT LAST CHAR AGAIN
RDLP3:	PUSHJ	P,LOOKPC	;FIND %
	  JRST	RDLP2		;FOUND ONE
	TLNN	C,C.MOVP	;LINE FEED?
	JRST	RDLP3		;NO
	JRST	RDLP4		;YES
RDLP2:	HRLI	T1,440700	;MAKE BP
	HRR	T1,TLYPTR	;POINT TO FREE SPACE
RDLP6:	PUSHJ	P,LOOKPC	;FIND %
	  JRST	RDLP5		;FOUND
	IDPB	C,T1		;SAVE CHAR
	JRST	RDLP6		;LOOP UP
RDLP5:	SETZM	C
	IDPB	C,T1		;MAKE ASCIZ
	AOS	T1		;INCREMENT BP
	EXCH	T1,TLYPTR	;GET START ADDRESS
	HRLI	T1,440700	;MAKE BP
	MOVEM	T1,TLYNUM(D)
	PUSHJ	P,TIDY		;IGNORE REST FOR NOW
RDLP4:	AOBJN	D,RDLP1		;LOOP UP
	PUSHJ	P,CLOSFL
	  JFCL			;DONT CARE
	JRST	CPOPJ1

TRNEOF:	MOVE	P,SAVP		;RESET P
	JRST	CLOSFL

LOOKPC:	PUSHJ	P,CHRIN		;GET A CHAR
	TLNN	C,C.PRC		;%?
	AOS	(P)		;SKIP
	POPJ	P,		;RETURN

	DEFINE OPTION <
	XX	HELP,HLPOP,TYPE THIS MESSAGE
	XX	EXIT,FINISH,EXIT TO MONITOR
	XX	LINKUP,LINKUP,LINK TO SPECIFIED NODE
	XX	JOINUP,JOINUP,JOIN MASTER PROGRAM AT NODE.
	XX	MODIFY,MODIFY,MODIFY THE LINKUP.SYS FILE
	XX	NODES,NODPNT,TYPE OUT ALL AVAILABLE TTY CONNECTS
	XX	NOAUTO,NOAUTO,DISABLE AUTO BAUD
	XX	AUTO,AUTO,ENABLE AUTO BAUD(DEFAULT)
	>

	DEFINE XX(A,B,C) <
	SIXBIT	/A/>

;***** TABLE OF COMMANDS *****

STRTOP:	OPTION
	Z

	DEFINE XX(A,B,C)<
	EXP	B>

;***** DISPATCH TABLE FOR ABOVE *****

STRTDS:	OPTION


	DEFINE XX(A,B,C)<
	[ASCIZ /C/] >

;***** HELP TABLE FOR ABOVE *****

STRHPT:	OPTION

;***** MODIFY COMMANDS *****

	DEFINE TABCOM <
	XX	HELP,UPDHLP,TYPE THIS MESSAGE
	XX	EXIT,UPDEXT,WRITE OUT LINKUP.SYS
	XX	ADD,ADDTTY,ADD AN ENTRY TO LINKUP.SYS
	XX	DELETE,DELTTY,DELETE AN ENTRY FROM LINKUP.SYS
	XX	CHANGE,CHGTTY,CHANGE AN ENTRY IN LINKUP.SYS
	XX	TYPE,MODTYP,TYPE AN ENTRY IN LINKUP.SYS
	>

	DEFINE XX(A,B,C)<
	SIXBIT	/A/>

UPDCOM:	TABCOM
	EXP	0		;AT END

	DEFINE XX(A,B,C)<
	EXP	B>

UPDDSP:	TABCOM

	DEFINE XX(A,B,C)<
	[ASCIZ /C/]>

;***** TABLE OF HELP MESSAGES FOR MODIFY *****

UPDHPT:	TABCOM

;***** LINKUP COMMANDS *****

	DEFINE	OPTLNK<
	XX	HELP,LNKHLP,TYPE THIS MESSAGE
	XX	EXIT,LNKXIT,BREAK LINK
	XX	SYSTAT,LNKSTS,GET LINE STATISTICS
	XX	STATUS,LNKSTA,PRINT STATUS OF LINKUP
	XX	TEST,LNKTST,START TESTING LINE
	XX	NOTEST,LNKNTS,STOP TESTING LINE
	XX	TALK,LNKTLK,TALK TO REMOTE MACHINE
	XX	TYPE,LNKTYP,TYPE ON REMOTE MACHINE
	XX	GET,LNKGET,GET FILES FROM REMOTE MACHINE
	XX	SEND,LNKSND,SEND FILES TO REMOTE MACHINE
	XX	ABORT,LNKABT,ABORT DATA TRANSMISSION

	>

	DEFINE	XX(A,B,C)<
	SIXBIT	/A/>

LNKOPT:	OPTLNK
	Z

	DEFINE	XX(A,B,C)<
	EXP	B>

LNKDSP:	OPTLNK

	DEFINE	XX(A,B,C)<
	[ASCIZ /C/]>

LNKHPT:	OPTLNK


;;***** TABLE OF MONTHS FOR DATE ROUTINE *****

	DOWN
MTHLST:	SIXBIT	/JAN/
	SIXBIT	/FEB/
	SIXBIT	/MAR/
	SIXBIT	/APR/
	SIXBIT	/MAY/
	SIXBIT	/JUN/
	SIXBIT	/JUL/
	SIXBIT	/AUG/
	SIXBIT	/SEP/
	SIXBIT	/OCT/
	SIXBIT	/NOV/
	SIXBIT	/DEC/

;***** TABLE OF LEGAL TTY SPEEDS *****

SPDTAB:	XWD	^D110,^D110
	XWD	^D150,^D150
	XWD	^D300,^D300
	XWD	^D600,^D600
	XWD	^D1200,^D1200
	XWD	^D2400,^D2400
	XWD	^D4800,^D4800
	XWD	^D9600,^D9600

	MAXSPD=.-SPDTAB

;***** TABLE OF SPEEDS WITH CODES FOR TRMOP UUO *****

CODSPD:	XWD	^D50,1
	XWD	^D75,2
	XWD	^D110,3
	XWD	^D135,4
	XWD	^D150,5
	XWD	^D200,6
	XWD	^D300,7
	XWD	^D600,10
	XWD	^D1200,11
	XWD	^D1800,12
	XWD	^D2400,13
	XWD	^D4800,14
	XWD	^D9600,15
	0


;***** TABLES FOR MACHINE TYPES *****

	DEFINE	MACS<
	XX	DEC10,BDEC10
	XX	DEC20,BDEC20>

	DEFINE	XX(A,B)<
	SIXBIT	/A/>

MACLST:	MACS
	EXP	0

	DEFINE	XX(A,B)<
	EXP	B>

MACBLK:	MACS


;***** MACHINE DEPENDENT INFORMATION HELD IN BLOCKS *****

	DEFINE	BLKMAC(A,B,C,D,E,F) <
	PHASE 0
LGIN:	EXP	A		;ADDRESS OF LOGIN ROUTINE
LGOUT:	EXP	B		;ADDRESS OF LOGOUT STRING
RNJOB:	EXP	C		;ADDRESS OF RUNJOB STRING
CNTC:	EXP	D		;CONTROL C EQUIVALENT
PRMT:	EXP	E		;PROMPT CHAR
SETCOD:	EXP	F		;ADDRESS OF ROUTINE TO SET SPD

	DEPHASE>

;***** DEC10 BLOCK *****

BDEC10:	BLKMAC	LGND10,LGTD10,RUN10,3,ASCDOT,SPDD10

;***** DEC20 BLOCK *****

BDEC20:	BLKMAC	LGND20,LGTD20,RUN20,3,ASCATT,SPDD20


;***** DISPATCH TABLES FOR INPUT AND OUTPUT ROUTINES *****

OUTBYT:	EXP	CTLOBT		;CONTROL INFO
	EXP	TTYOBT		;TTY OUTPUT
	EXP	PTYOBT		;PTY OUTPUT
	EXP	TXTOBT		;TEXT OUTPUT
	EXP	TSTOBT		;TEST OUTPUT
	EXP	CPOPJ
	EXP	CPOPJ
	EXP	CPOPJ

INPBYT:	EXP	CTLIBT		;CONTROL BYTE
	EXP	TTYIBT		;TTY INPUT
	EXP	PTYIBT		;PTY INPUT
	EXP	TXTIBT		;TEXT INPUT
	EXP	TSTIBT		;TEST INPUT
	EXP	CPOPJ
	EXP	CPOPJ
	EXP	CPOPJ
	INPRTC==5

;***** DISPATCH FOR CONTROL ROUTINES *****

CTLTAB:	PHASE 200
CT.STE:	EXP	CTLSTE		;START TESTING
CT.SPE:	EXP	CTLSPE		;STOP TESTING
CT.GST:	EXP	CTLGST		;GET STATISTICS
CT.PST:	EXP	CTLPST		;PRINT STATISTICS
CT.VRT:	EXP	CTLVRT		;START VIRTUAL
CT.NVT:	EXP	CTLNVT		;STOP VIRTUAL
CT.TLK:	EXP	CTLTLK		;START TALKING
CT.NTK:	EXP	CTLNTK		;STOP TALKING+VIRTUAL
CT.NPY:	EXP	CTLNPY		;NO PTY AVAILABLE FOR TALK
CT.FGM:	EXP	CTLFGM		;GENERAL FILESPEC FOR LOOKUP
CT.CGM:	EXP	CTLCGM		;GENERAL FILESPEC FOR ENTER
CT.FGH:	EXP	CTLFGH		;HIS GENERAL FILESPEC FOR CREATE
CT.CGH:	EXP	CTLCGH		;HIS GENERAL FILESPEC FOR ENTER
CT.ABI:	EXP	CTLABI		;ABORT HIS INPUT CHANNEL
CT.ABO:	EXP	CTLABO		;ABORT HIS OUTPUT CHANNEL
CT.LDN:	EXP	CTLLDN		;ALL FILESPECS FINISHED
CT.FLM:	EXP	CTLFLM		;HERE IS MY LOCAL FILESPEC
CT.FIN:	EXP	CTLFIN		;END OF FILE
CT.FLC:	EXP	CTLFLC		;FILE ACKNOWLEDGE--START UP
CT.FLB:	EXP	CTLFLB		;BAD FILESPEC
CT.LGO:	EXP	CTLLGO		;LOGOUT THIS JOB
	DEPHASE


;;***** LITERALS AND CONSTANTS *****

	DOWN
STACK:	IOWD	30,PDLIST
JUNKBP:	440700,,JUNK
TTYCOL:	ASCII	/TTY/
	Z
	Z
DEVSPC:	EXP	0
	SIXBIT	/DSK/
	XWD	OBUF,IBUF
TRNSPC:	
IFE DEC20,<
	SIXBIT	/LINKUP/
	SIXBIT	/SYS/
	Z
	Z
	>
IFN DEC20,<
	ASCIZ /SYS:LINKUP.SYS/>
RUN10:	ASCIZ /RUN LINKUP/
RUN20:	ASCIZ /LINKUP/
RUN11M:	ASCIZ /
/
RUN11D:	ASCIZ /
/
LGTD10:	ASCIZ %
K/F
%
LGTD20:	ASCIZ /
LOGOUT
/
TISBPI:	440700,,TSTSTG
TSTSTG:	ASCIZ /FUZZY WUZZY WAS A BEAR, FUZZY WUZZY HAD NO HAIR,
SO FUZZY WUZZY WASNT VERY FUZZY WAS HE
/

;***** OUTPUT BUFFERS *****

	DEFINE BUFBLD(%A) <
	PHASE	0
BUFPTR:	EXP	%A
BUFMES:	BLOCK	1
BUFCNT:	BLOCK	1
BUFBEG:	BLOCK	MSLMAX
	BUFTOP=.-1
	DEPHASE
%A:	>

FIRBUF:	REPEAT	BCT,<BUFBLD>
	EXP	0

;***** STATISTICS TABLES

	DEFINE	STATAM	<
	XX	NAKICT,<NAKS RECEIVED		>
	XX	NAKOCT,<NAKS SENT		>
	XX	ACKICT,<ACKS RECEIVED		>
	XX	ACKPCT,< (PIGGY-BACKED)		>
	XX	ACKOCT,<ACKS SENT		>
	XX	BADCNT,<BAD CHARS RECEIVED	>
	XX	STKICT,<RESTARTS		>
	XX	TXTICT,<TEXT CHARS RECEIVED	>
	XX	TTYICT,<TTY CHARS RECEIVED	>
	XX	TSTICT,<TEST CHARS RECEIVED	>
	XX	CTLICT,<CNTRL CHARS RECEIVED	>
	XX	MAJERR,<DATA FORMAT ERRORS	>
	XX	REPICT,<REPS RECEIVED		>
	XX	OVRFLO,<BIGBUF OVERFLOW		>
	XX	SLOBUF,<BUFFERS DELETED(SLOBUF)	>
	>

	DEFINE	XX(A,B)<
	[ASCIZ /B/]>

STTSTG:	STATAM
	
	DOWN

	DEFINE	XX(A,B)<
A:	BLOCK	1>

ZEROA:
ACTSTR:	STATAM
	ACTSTP=.-ACTSTR
	STT8BT=ACTSTP*4+ACTSTP/2
	Z

	DEFINE	XX(A,B)<
	BLOCK	1>

FARSTR:	STATAM
ZEROAE:	Z

;***** STORAGE SPACE *****

	DOWN
CHIBUF:	BLOCK	^D80
CHOBUF:	EXP	0
	XWD	MSLMAX,CHOBUF+1
	BLOCK	MSLMAX

ICHN:	BLOCK	3
OCHN:	BLOCK	3
NCHAR:	BLOCK	1
INEOF:	BLOCK	1
OUTEOF:	BLOCK	1
CRCTAB:	BLOCK	^D256

PTYJFN:	BLOCK	1
FILJFN:	BLOCK	1
SYSJFN:	BLOCK	1
INPJFN:	BLOCK	1
OUTJFN:	BLOCK	1
CHKOUT:	BLOCK	1
CHKINP:	BLOCK	1
CHKGET:	BLOCK	1

TYMTTY:	BLOCK	1
INIRVX:	BLOCK	1

DAY:	BLOCK	1
MONTH:	BLOCK	1
YEAR:	BLOCK	1

LSTCHR:	BLOCK	1
PROTP:	BLOCK	1
STTACT:	BLOCK	1

BUSY:	BLOCK	2
FILTSN:	BLOCK	2
	DEFINE	STGSPC(A,B)<
A:	EXP	^D'B		;NUMBER OF CHARS
	PHASE	1
STGCNT:	BLOCK	1		;SPACE FOR COUNT
STGADR:	BLOCK	^D'B/5+1
	DEPHASE>

	STGSPC	GNORIN,115
	STGSPC	GNOROT,115
	STGSPC	GNHSIN,115
	STGSPC	GNHSOT,115
	STGSPC	LCOROT,115
	STGSPC	LCHSOT,115
	STGSPC	LCORIN,115
	STGSPC	LCHSIN,115
	STGSPC	USESTG,39
	STGSPC	PASSTG,39
	STGSPC	ACCSTG,39
	STGSPC	TTYSTG,80
PDLIST:	BLOCK	50

TIMDIV:	BLOCK	1
DAYTIM:	BLOCK	1
INTERV:	BLOCK	1
INCORE:	BLOCK	1
OTCORE:	BLOCK	1
OTCNT:	BLOCK	1

TISBP:	BLOCK	1
TOSBP:	BLOCK	1

TTYTST:	EXP	0
TSTTTY:	EXP	0
	XWD	0,DUMBUF
DUMBUF:	BLOCK	3
JUNK:	BLOCK	10

PTYFLG:	BLOCK	1
PTYBLK:	BLOCK	3
PTIBUF:	BLOCK	100
PTOBUF:	BLOCK	100
PTYIBF:	BLOCK	3
PTYOBF:	BLOCK	3

TXTGCT:	BLOCK	1
TXTSCT:	BLOCK	1
TMESNT:	BLOCK	1
TMEGET:	BLOCK	1
OBT4BP:	BLOCK	1
OTPWRD:	BLOCK	1
IBT4BP:	BLOCK	1
INPWRD:	BLOCK	1

	DEFINE SPCBLK(A,B,C,D)<
A'VED:	EXP	D		;MODE OF TRANSFER
A'DEV:	PHASE	1		;DEVICE
FILDEV:	BLOCK	1		;DEVICE
	XWD	B,C		;BUFFERS
FILBLK:	EXP	5		;FOR EXTENDED LOOKUP/ENTER
FILPPN:	BLOCK	1
FILNAM:	BLOCK	1
FILEXT:	BLOCK	1
FILCLR:	BLOCK	1
FILLEN:	BLOCK	1
	DEPHASE>

	SPCBLK	(SND,0,INCHBF,14)
	SPCBLK	(GET,OTCHBF,0,14)

SNDARE:	BLOCK	2*203
GETARE:	BLOCK	2*203
OPNBLK:	40000,,2
TTY:	BLOCK	1
BUFHD:	BLOCK	1

RSPED:	BLOCK	1
XSPED:	BLOCK	1
MACTYP:	BLOCK	1
MACADR:	BLOCK	1
NODE:	BLOCK	1
NUMTLY:	BLOCK	1
NODTAB:	BLOCK	MAXNOD
MACHIN:	BLOCK	MAXNOD
TTYTAB:	BLOCK	MAXNOD
XMTSPD:	BLOCK	MAXNOD
RCVSPD:	BLOCK	MAXNOD
STATUS:	BLOCK	MAXNOD
TLYNUM:	BLOCK	MAXNOD
TLYBUF:	BLOCK	40
TLYPTR:	BLOCK	1
	TRAND==.-1

NOREPS:	BLOCK	1
SAVP:	BLOCK	1		;PLACE TO SAV P
SAVD:	BLOCK	1
CHNLST:	BLOCK	1
CHNTIM:	BLOCK	1
CHNCNT:	BLOCK	1
CHRMCH:	BLOCK	1

REPOCT:	BLOCK	1
TXTOCT:	BLOCK	1
TTYOCT:	BLOCK	1
STKOCT:	BLOCK	1
STRICT:	BLOCK	1
STROCT:	BLOCK	1
TSTOCT:	BLOCK	1
CTLOCT:	BLOCK	1
TSTERC:	BLOCK	1
CTLTMC:	BLOCK	1
CTLLNG:	BLOCK	1
CTLSHT:	BLOCK	1

REPTIM:	BLOCK	1

CRCSVR:	BLOCK	1
WAIPOP:	BLOCK	1
T2SAVR:	BLOCK	1
LISTNP:	BLOCK	1

FILRTN:	BLOCK	1
PUTPTR:	BLOCK	1
GETPTR:	BLOCK	1
CNTCHR:	BLOCK	1
OTTBUF:	BLOCK	^D200
	OTTLM=.-OTTBUF-2

PUTTER:	BLOCK	1
TAKER:	BLOCK	1
IFN DEC20,<
BIGBUF:	BLOCK	^D200
	BUFLEM=.-BIGBUF-2
>
ICTCHR:	EXP	INBFTE-INBFTB
INCPTP:	EXP	INBFTB
INCPTG:	EXP	INBFTB
INBFTB:	BLOCK	200
	INBFTE==.

CC2RES:	BLOCK	1
NAKRES:	BLOCK	1
LSTREC:	BLOCK	1
LSTSNT:	BLOCK	1
LSTACK:	BLOCK	1
NXTMES:	BLOCK	1
OSTNNO:	BLOCK	1
HSTNNO:	BLOCK	1

RECCOD:	BLOCK	1
RECCC1:	BLOCK	1
RECCC2:	BLOCK	1
RECRFD:	BLOCK	1
RECNFD:	BLOCK	1
RECAFD:	BLOCK	1
RECBUF:	BLOCK	MSLMAX

SNDCC1:	BLOCK	1

IBTCNT:	BLOCK	1
INERCD:	BLOCK	1
INCHBF:	BLOCK	3
OTCHBF:	BLOCK	3
GTERCD:	BLOCK	1

TNSTTY:	BLOCK	1
TNSTXT:	BLOCK	1

PTCNT:	BLOCK	1
RECTTY:	BLOCK	1
RECTXT:	BLOCK	1

TXTRTS:	BLOCK	1

CTLIBF:	BLOCK	CTLLEN
	CTLIBE==.
CTLOBF:	BLOCK	CTLLEN
	CTLOBE==.
CTLIPT:	EXP	CTLIBF
CTLIGT:	EXP	CTLIBF
CTLOPT:	EXP	CTLOBF
CTLOGT:	EXP	CTLOBF
CTLOTC:	EXP	CTLLEN-1
CTLITC:	EXP	CTLLEN-1
CTLCNT:	BLOCK	1
EXTCTL:	BLOCK	1

UUOLOC:	BLOCK	1

PPND10:	BLOCK	1
PASSWD:	BLOCK	1

SKPBLK:	0
IOINDX:	200000

RPage:	1022
	200000
	0

OURBLK:	BLOCK	1
OURINX:	BLOCK	1
OURTTY:	BLOCK	1

CLRBLK:	EXP	0
	EXP	0
	EXP	0

SETBLK:	EXP	0
	EXP	0
	EXP	1

SPDBLK:	EXP	0
	EXP	0
	EXP	0

DILBLK:	BLOCK	4

OBUF:	BLOCK	3
IBUF:	BLOCK	3
TEMP1:	Z
INTBLK:	XWD	4,INTLOC
	XWD	0,2
	Z
	Z
GETJTB:	BLOCK	22
STPFLG:	Z
LASNAK:	Z
NAKCNT:	Z
CHRFLG:	Z
LSTNAK:	Z
PAT..:	BLOCK	100

	END	START
3@~5