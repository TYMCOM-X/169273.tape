UNIVERSAL	CARL  --  PDP-10   MACRO DEFINITION FILE
SUBTTL		WRITTEN BY CARL BALTRUNAS	VERSION %2


.DIRECTIVE	.NOBIN		;DO NOT CREATE CARL.REL
.DIRECTIVE	.XTABM		;ELIMINATE LEADING TRAILING TABS


	SEARCH	MACTEN,JOBDAT,UUOSYM,SCNMAC

PASS2				;MAKE SURE NOT HAVETO DO IT TWICE


COMMENT	_

THIS UNIVERSALFILE CONTAINS THE FOLLOWING DIRECTORY OF MACROS
WITH EACH MACRO ON A SEPARATE PAGE EXCEPT WHERE SIMILAR SEGMENTS
OF A MACRO APPEAR TOGETHER TO FORM TWO OR FOUR DIFFERENT MACROS.

	ACCUMULATOR DEFINITIONS

_
SUBTTL	ACCUMULATOR DEFINITIONS


	F=0			;FLAG VARIABLE
	T0=0			;DESTROYABLE TEMPORARY, WHEN NOT A FLAG

	T1=1			;GENERAL PURPOSE TEMPORARY
	T2=T1+1			;SAME AS T1, BUT NEXT TO IT
	T3=T2+1			;  REALLY 4 ALL TOGETHER
	T4=T3+1			;  'CANNOT DO MUCH WITH MORE

	RADIX=T3		;USED WITHIN NUMBER ROUTINES

	P1=5			;PERMANENT AC,	MAY NEVER BE DESTROYED
	P2=P1+1			;PERMANENT AC,	ACROSS FUNCTION CALLS.
	P3=P2+1			;   ALSO KNOWN AS (N)
	P4=P3+1			;   ALSO KNOWN AS (C)

	N=P3			; NUMBER AC,  USED TO RETURN A NUMBER
	C=P4			; CHARACTER AC, USED IN BYTE INSTR.


	CNT=11			;NEW COUNTER ADDRESS
	KNT=CNT+1		;ALSO FOR AUX COUNTER.

	M1=13			;FOR MACROS... TRY NOT TO USE ELSEWHERE
	M2=M1+1			;ALSO USED IN MACROS...

	S=15			;STATUS FLAGS -- FROM KOSTER.MAC
	L=16			;FORTRAN CALLING AC

	P=17			;PUSH DOWN LIST POINTER
SUBTTL	OPDEFS


	OPDEF	PJRST	[JRST]	;NORMALLY A JRST TO A POPJ EVENTUALLY
	OPDEF	GOTO	[JRST]	;... WHAT DES IT LOOK LIKE ...
	OPDEF	PGOTO	[PJRST]	;.... A LITTLE BIT REDUNDANT, BUT...
	OPDEF	PJSP	[JRST]	;WILL RETURN TO MAIN AS FROM A JSP

	OPDEF	NOP	[JFCL]	;NO OP.. OF COURSE.

	define	call(a)<	pushj	p,a>
SUBTTL	MAKPDL	TO CREATE THE INITIAL PDL LIST

;[MACRO]	MAKPDL	LENGTH , ADDRESS , %LABEL
;
;	IF ADDRESS IS MISSING "PDL" IS USED
;	IF LENGTH  IS MISSING  "50" IS USED
;	IF BOTH ARE BLANK, GOTTEN FROM .JBFF
;;;;
;
DEFINE	MAKPDL (LENGTH,ADDRESS,%LABEL) <
IFB	<LENGTH>,<LENGTH==50>	;; DECLARE A DEFAULT SIZE
IFB	<ADDRESS>,<
	HRRZ	P,.JBREL	;; TAKE TOP OF CORE
	SUB	P,.JBFF		;; THEN SUBTRACT CURRENT CORE
	CAIL	P,LENGTH	;; SEE IF ENOUGH FOR LIST
	  JRST	%LABEL		;; YES--SO SKIP TO END
	HRRZ	P,.JBFF		;; OBTAIN CURRENT LIMIT
	MOVEI	P,LENGTH(P)	;; INCREMENT P BY LENGTH
	CORE	P,		;; ASK FOR MORE CORE
	  EXIT			;; IF CANNOT GET CORE BYEBYE
%LABEL:	MOVSI	P,-1*LENGTH	;; GET SIZE
	HRR	P,.JBFF		;; FIRST LOCATION
	HRRI	P,-1(P)		;; FINISH IOWD LENGTH,LOC
	MOVEI	M1,LENGTH	;; GET THE SIZE
	ADDM	M1,.JBFF	;; UPDATE .JBFF
>
IFNB	<ADDRESS>,<
	MOVE	P,[IOWD LENGTH,ADDRESS]
>
>;END DEFINE MAKPDL (LENGTH,ADDRESS)
SUBTTL	.BEGIN	TO RESET & BEGIN EVERYTHING

;[MACRO]	.BEGIN	FLAG
;
;	IF FLAG IS NON-BLANK, A RESCAN WILL BE DONE
;	   INSTEAD OF THE STANDARD ^O DEFEAT PART
;
;	THE MACRO DOES A 	RESET
;				^O or RESCAN
;				MAKPDL
;;;;;;
;
DEFINE	.BEGIN (FLAG) <
	RESET			;PERFORM A RESET

IFB	<FLAG>,<
	SKPINL			;SKIP IF A LINE CAN BE INPUT
	  JFCL			;  TO DEFEAT THE ^O
>
IFNB	<FLAG>,<
	RESCAN			;RESCAN THE LINE FOR INPUT
>
>;END DEFINE .BEGIN (FLAG)
;***	TYPE  ********************************************************
DEFINE	TYPE(PART1,PART2,PART3,PART4)<
	OUTSTR	[ASCIZ\PART1'PART2'PART3'PART4\]
>


;***	LTYPE  *******************************************************
DEFINE LTYPE(PART1,PART2,PART3,PART4)<
	OUTSTR	[ASCIZ\
PART1'PART2'PART3'PART4
\]
>


;***	WARN  ********************************************************
DEFINE WARN(PART1,PART2,PART3,PART4)<
	TYPE	%'PART1,PART2,PART3,PART4
>


;***	FATAL  *******************************************************
DEFINE	FATAL(PART1,PART2,PART3,PART4)<
	TYPE	<?
?>'PART1,PART2,PART3,PART4
>
SUBTTL	VERSION	NAME,VER,EDIT,MINOR-VER,WHO


;[MACRO]	VERSION	NAME , VER , EDIT , MVER , EDIT
;
;	THIS WILL EVENTUALLY BE CHANGED TO USE MACTEN VERSION
;
;
DEFINE VERSION(NAME,VERS,EDIT,MVER,INST)<

	$$NAM%==NAME

	NAME'VER==VERS
	NAME'EDT==EDIT
	NAME'MIN==MVER
	NAME'WHO==INST

	LOC .JBVER
	NAME'%%V==<VRSN.NAME>
	EXP	NAME'%%V
	RELOC
	PURGE	NAME'VER,NAME'EDT,NAME'MIN,NAME'WHO
>
SUBTTL	DBP	DLDB	DDPB

;[MACRO]	DBP	PNTR		;;DECREMENT BYTE POINTER
;[MACRO]	DLDB	AC , PNTR	;;DECREMENT LOAD BYTE
;[MACRO]	DDPB	AC , PNTR	;;DECREMENT DEPOSIT BYTE
;
;	CURRENT MACRO'S DO NOT CONSIDER KL-10 INSTRUCTION SET
;
DEFINE DBP(PNTR)<;;DECREMENT BYTE POINTER ROUTINE
	LDB	M1,[POINT 6,PNTR,5]
	LDB	M2,[POINT 6,PNTR,11]
	ADD	M1,M2
	CAIGE	M1,^D36
	JRST	.+5
	SOS	PNTR
	MOVEI	M1,^D36
	IDIV	M1,M2
	MOVE	M1,M2
	DPB	M1,[POINT 6,PNTR,5]
>

DEFINE DLDB(AC,PNTR)<;;INSTRUCTION TO DECREMENT AND LOAD A BYTE
	DBP	PNTR
	LDB	AC,PNTR
>

DEFINE DDPB(AC,PNTR)<;;INSTRUCTION TO DECREMENT AND DEPOSIT A BYTE
	DBP	PNTR
	DPB	AC,PNTR
>
SUBTTL	COMP	COMP1	DISPLY	TWOCMP	PROCD	** COBOL **

COMMENT^
	THE VALUES IN VALUE MEAN AS FOLLOWS:

	COMP - COBOL COMPUTATIONAL WORD
		THE ADDRESS IS THAT OF THE ARG ITSELF

	2-WORD COMP - COBOL: USED 2 WORDS
		THE ADDRESS IS THAT OF THE HIGH ORDER OF THE WORD
		WITH THE NEXT LOCATION(ADR) AS THE LOW ORDER PART

	COMP-1	- DEC-10 SPECIAL COMPUTATIONAL VALUE
		THE ADDRESS IS THAT OF THE ARGUMENT ITSELF

	DISPLAY-6	COBOL-SIXBIT PACKED 6 CHRS TO A WORD EA. 6 BITS
	DISPLAY-7	STANDARD ASCII 7-BIT W/5 CHRS TO A WORD.
		THE ADDRESS IS THE ADR OF A 2-WORD BLOCK WHERE
	WORD-1		IS A BYTE POINTER TO THE LITERAL
	WORD-2		DATA IN BITS SPECIFYING MODE,SIZE ETC
			OF A STRING.

	PROCEDURE NAMES		COBOL: NAMES UNABLE TO USE
			FOR COBOL SUBPROGRAMS???

		ADDRESS IS THAT OF THE PROCEDURE ITSELF
^
	COMP=100	;;COMPUTATIONAL TYPE SPEC.
	COMP1=200	;;COMP-1 TYPE SPEC.
	DISPLY=640	;;DISPLAY-6 OR DISPLAY-7 ITEM TYPE
	TWCOMP=440	;;2-WORD COMPUTATIONAL
	PROCD=340	;;A PROCEDURE NAME
SUBTTL	TYPCHK - TYPE CHECKING MACRO FOR USE WITH COBOL ROUTINES


;[MACRO]	TYPCHK - TYPE CHECKING MACRO FOR USE WITH COBOL ROUTINES
;
;	AC	- WHICH ACCUMULATOR TO USE 0-17
;	OFF	- THE OFFSET FOR THE ARGUMENT BEING CHECKED
;	TYPE	- THE TYPE OF ARGUMENT USED (SEE ABOVE)
;	ERR	- THE NAME, ADDRESS OF THE ERROR ROUTINE TO USE
;	CODE	- #0 - GIVE AN ERROR MESSAGE
;		- =0 - NO ERROR MESSAGE
;	
;
DEFINE TYPCHK(AC,OFF,TYPE,ERR,CODE)<
	HLRZ	AC,OFF(16)		;;GET LEFT HALF OF STATUS WORD
	TRZ	AC,-741			;;CLEAR ALL BITS 'CEPT 9-12
	IFN	ERR,<			;;IF ERR IS NON-BLANK
		IFN	CODE,<		;;IF CODE IS NON-BLANK
			CAIE	AC,TYPE	;;CHECK TYPE
			PUSHJ	17,ERR	;;PERFORM ERROR ROUTINE
		>;;FIN IF CODE # 0
		IFE	CODE,<		;;IF CODE = 0
			CAIE	AC,TYPE	;;CHECK TYPE
			JRST	ERR	;;GOTO ERROR ROUTINE
		>;;FIN CODE = 0
	>;;FIN ERR # 0
	IFE	ERR,<			;;IF ERR IS BLANK
		IFN	CODE,<		;; IF CODE # 0
			CAIE	AC,TYPE	;CHECK TYPE
			LTYPE <%WARNING: ARGUMENT TYPE MUST MATCH FUNCTION TYPE>
		>;;FIN CODE # 0
	>;;FIN ERR = 0
>;;FIN MACRO DEFINITION TYPCHK (AC,OFF,TYPE,ERR,CODE)
SUBTTL	HI	COBOL ENTRY/REPEAT-ENTRY FACILITY

;[MACRO]	HI	NAME , NARG , <TYPES>
;
;	IF <TYPES> IS NON-BLANK THE TYPCHK MACRO IS INVOKED
;	   FOR EACH OF THE TYPED ARGUMENTS.. ELSE NO TYPE CHECKING
;
;	NAME IS DECLARED AS ENTRY POINT AND LATER WILL BE SETUP
;	TO MATCH COBOL MODULE ROUTINES IF POSSIBLE.  CURRENTLY
;	THE SETUP IS SIMILAR TO FORTRAN-10, BUT COBOL HAS BEEN THE
;	MAIN TARGET FOR THIS ROUTINE, SHOULD WORK WELL WITH F-10
;
;
;[COBOL USERS NOTE]
;	ARGUMENTS IN A MACRO CALL TO A SUBROUTINE FROM A COBOL PROGRAM
;	COMPLETELY INVISIBLE. IF FOR INSTANCE, A NORMAL CALL OF THE FORM:
;	"ENTER MACRO PROGRAM USING ARG1, ARG2." WERE THE CALL, THEN
;	THE FOLLOWING WOULD BECOME LEGAL WITH NO IMMEDIATE CODING
;	PROBLEMS:
;	"ENTER MACRO PROGRAM USING ARG1, ARG2
;				   ARG3, ARG4,
;				   ARG5,ARG6."
;	WHERE THIS CALL WOULD BE THE SAME AS:
;	"ENTER MACRO PROGRAM USING ARG1, ARG2."
;	"ENTER MACRO PROGRAM USING ARG3, ARG4."
;	"ENTER MACRO PROGRAM USING ARG5, ARG6."
;

DEFINE	HI(NAME,NARG,TYPES)<;;ENTRY LOOP PROCEDURE
	XLIST
IF1,<
IFDEF ...H$$,<
IFDEF NAME,<PRINTX ?'NAME IS DOUBLY DEFINED WITHIN "HI" MACRO>
>
IFNDEF ...H$$,<...H$$==1>
>;;END IF1
	LIST
	...A$$==NARG

IFNDEF E$$WNA,<
$FATAL	WNA,WRONG NUMBER OF ARGUMENTS IN SUBROUTINE 'NAME' CALL
>

	ENTRY	NAME

	SIXBIT	!NAME!			;THE NAME OF THE ROUTINE
NAME:	CALL	SAVEAC##		;SAVEAC SAVES ALL OF THE AC'S
	HLRE	T1,-1(L)		;FIND OUT HOW MANY ARGUMENTS
	MOVN	T1,T1			;ARE IN THE CURRENT CALLING BLOCK.
	IDIVI	T1,NARG			;AND SEE IF IT IS MOD 'NARG
	SKIPE	T2			; IF == 0 THEN OK.
	  ERROR	WNA			;--WRONG NUMBER OF ARGUMENTS.
	PUSH	P,T1			;SAVE THE NUMBER OF LOOPS HERE
$R$$$$:	...T$$==0
IRP TYPES,<
	TYPCHK	T1,...T$$,TYPES,,1	;USE DEFAULT ERROR MSG
	...T$$==...T$$+1		;INCREMENT COUNTER/OFFSET
>;;END IRP
>;;END HI
SUBTTL	BYE	ROUTINE EXIT PROCEDURE FOR USE WITH "HI"

;[MACRO]	BYE
;
;	THIS MACRO COMPLETES THE LOOP IMPLEMENTED BY THE "HI" MACRO
;	SO THAT A USER MAY CALL A SUBROUTINE WITH ADDITIONAL
;	FULL COMPLIMENTS OF ARGUMENTS INSTEAD OF MAKING DUPLICATE
;	CALLS TO THE SUBROUTINE.  SEE "HI" MACRO FOR MORE DETAILS.
;
;
DEFINE BYE,<
IFNDEF ...H$$,<
PRINTX "BYE" MACRO IN USE WITHOUT USE OF "HI" MACRO>
	SOSG	-1(P)			;DECREMENT THE COUNTER
	  POPJ	P,			;RETURN TO CALLING ROUTINE
	ADDI	L,...A$$		;INCREMENT PAST POINTER
	JRST	$R$$$$			;RETURN TO LOOP

	PURGE	E$$WNA
IF2,< PURGE $R$$$$,...A$$,...H$$,...T$$>
>;;END BYE MACRO
SUBTTL	HAZPOZ	HAZPSI

;[MACRO]	HAZPOS	COL , ROW	;; NORMAL MODE
;[MACRO]	HAZPSI	COL , ROW	;; IMMEDIATE MODE
;
;
;	THESE TWO ROUTINES POSITION THE CURSOR ON THE HAZELTINE
;	2000 OR SIMILAR FAMILY OF TERMINALS.  THE X,Y AXIS ON THIS
;	TERMINAL BEGINS IN THE UPPER LEFT CORNER, THE NORMAL
;	DIMENSIONS FOR THE SCREEN ARE 72 X 27.  THE 1500 HAS A
;	SMALLER SCREEN AREA OF 80 X 24.
;
DEFINE HAZPOS(COL,ROW)<;;POSITION THE CURSOR AT (COL),(ROW)
	IONEOU	[176]
	IONEOU	[21]
	IONEOU	COL
	IONEOU	ROW
>

DEFINE HAZPSI(COL,ROW)<;;POSITION THE CURSOR IMMEDIATE AT COL,ROW
	IONEOU	[176]
	IONEOU	[21]
	IONEOU	[COL]
	IONEOU	[ROW]
>
;***	$ESET  *******************************************************
DEFINE $ESET(PART1,PART2)<
	DEFINE $E$'PART1<PART2>;;END DEFINE $E$'PART1
>;;				;;END DEFINE $ESET


;***	$FSET  *******************************************************
DEFINE $FSET(ARG)<IFNDEF $E$'ARG,<$E$'ARG==-1>>;;SET TO -1

;***	ERROR  *******************************************************
DEFINE ERROR(CODE)<	XLIST
IF1 <	IFDEF E$M,<E$M==E$M+1>;;IF DEFINED, BUMP THE VALUE 1
	IFNDEF E$M,<E$M==1>;;IF NOT SET TO 1
	$ESET	\E$M,E$$'CODE		;;DEFINE A MACRO
>;;					;;END IF1
IF2 <	IFNDEF E$$'CODE,<
$$TELL	<FATAL LABEL E$$'CODE NOT DEFINED - MACRO BOMB>,\.
>;;					;;END IFNDEF E$$'CODE
	IFDEF E$$'CODE,<
		IFL E$$'CODE,<
$$TELL	<LABEL E$$'CODE IS NOT DEFINED>,\.
>;;					;;END IFL
>;;					;;END IFDEF
>;;					;;END IF2
	LIST
	  JRST	E$$'CODE		;;GO TO THE ERROR ROUTINE
>;;					;;END DEFINE ERROR
;***	$FATAL - MACRO TO GENERATE FATAL LABELS  *********************
DEFINE $FATAL(CODE,MSG)<
E$$'CODE:	LTYPE	<?'CODE MSG>
	EXIT
>;;END $FATAL


;***	$$TELL  ******************************************************
DEFINE $$TELL(MSG,LOC)<;;MACRO TO TELL USER OF ERROR DURING COMPILATION
PRINTX ?UVECMP - MSG
IFNB	LOC,<
PRINTX ?ERROR OCCURRED AT LOCATION:'LOC
>;;					;;END IFNB
>;;					;;END $$TELL
SUBTTL	$$FIN

;[MACRO]	$$FIN
;
;	$$FIN MACRO TO CLEAR ERROR FLAGS AND STUFF
;
;
DEFINE $$FIN(ARGS)<;;MACRO TO ADD IN THE END STATEMENT, ETC
IF1 <IFDEF E$M,<REPEAT E$M,<
	$FSET	\E$M
	E$M==E$M-1>;;END REPEAT
>;;					;;END IFDEF
>;;					;;END IF1
	END
>;;					;;END DEFINE $$FIN
	$$FIN
  