TITLE	TALK - program to let a group talk to each other
SUBTTL	S.A. Barkley		30-March-77

	SEARCH		STUART,MACTEN,UUOSYM

	.REQUEST	REL:SCN7B.REL[5,11]

COMMENT	!

		TTTTT      A      L        K   K
		  T       A A     L        K  K
		  T      A   A    L        K K
		  T      A   A    L        KK
		  T      AAAAA    L        K K
	          T      A   A    L        K  K   
		  T      A   A    LLLLL    K   K


This program lets all of the people running it be able to
talk to each other.  Anything typed on one terminal is typed
out at all the other terminals running the program.  Each time
a person runs TALK he is asked to give an id by which all
messages from him are proceeded.

!


	SALL
	SUBTTL	Table of Contents

;		TABLE OF CONTENTS FOR TALK
;
;
;			   SECTION			      PAGE
;    1. Table of Contents.....................................   2
;    2. Definitions...........................................   3
;    3. TALK - Main routine...................................   4
;    4. SETINT - Set up software interupt system..............   5
;    5. INIT - Initalize everything...........................   6
;    6. INITME - Init my stuff - Count me in..................   7
;    7. TYPRUN - Type names of people already running TALK....   8
;    8. SETLOC - Set interlock................................   9
;    9. GETNAM - Get name from user...........................  10
;   10. GETSIX - Get SIXBIT response from user................  11
;   11. READ - Read a message if one is there.................  12
;   12. WRITE - Write a message if line typed.................  13
;   13. GETCHR - Get a character from TTY.....................  14
;   14. DONE - Im done now - Clear all my stuff...............  15
;   15. Command Processing
;        15.1   Main Routine..................................  16
;        15.2   Tables........................................  17
;        15.3   Routines - INIT, WHO, EXIT, HELP..............  18
;        15.4   Routines - KILL...............................  19
;   16. WAILIN - Read messages until a line of input is read..  20
;   17. REENTER Processing - Maintance mode...................  21
;   18. Error messages........................................  22
;   19. Storage Areas
;        19.1   High Segment..................................  24
;        19.2   Low Segment...................................  25
	SUBTTL	Definitions

ND	$DEBUG,0		;DONT INCLUDE DEBUGGING CODE
ND	BUFLEN,23		;SIZE OF BUFFER
ND	NUMBUF,10		;NUMBER OF MSG BUFFERS
ND	WAIBSY,^D100		;0.1 SEC WAIT
ND	MAXWAI,^D200		;20 SEC MAX TIME
ND	PEOMAX,^D5		;MAX NUMBER OF USERS
ND	PDLLEN,40		;SIZE OF STACK

MAXMSG==<BUFLEN-3>*5		;NUMBER OF CHARS IN MAXIMUM MSG
MSGLEN==NUMBUF*BUFLEN		;NUMBER OF WORDS FOR ALL BUFFERS

	ERRSET	(TLK)		;DEFINE ERROR PREFIX

;FLAG DEFINITIONS

	T.CCL==1B35		;CCL ENTRY
	T.PRIV==1B34		;PRIVELEDGED USER
	T.MAIN==1B33		;MAINTAINCE MODE
	TLKVER==2		;MAJOR VERSION NUMBER
	TLKMIN==0		;MINOR VERSION NUMBER
	TLKEDT==6		;EDIT NUMBER
	TLKWHO==0		;WHO LAST PATCHED

	%TLK==<BYTE (3)TLKWHO(9)TLKVER(6)TLKMIN(18)TLKEDT>

	LOC	124
	EXP	REENT
	LOC	137
	EXP	%TLK

	.TWOSEG			;TWO SEGMENT PROGRAM
IFN	$DEBUG	<LOWSEG>	;IF DEBUGGING PUT CODE IN LOWSEG
	SUBTTL	TALK - Main routine

TALK:	.RESET			;RESET ALL
	STORE	T1,BZCORE,EZCORE,0;CLEAR CORE
	MOVE	P,[IOWD PDLLEN,PDL];SETUP PDL
	GETPPN	T1,		;GET OUR PPN
	  JFCL			;  (IN CASE PRIV)
	CAMGE	T1,[11,,0]	;IS IT A PRIVED USER?
	  TXO	F,T.PRIV	;  YES--SET FLAG FOR LATER
	SETZM	TALKIN		;LET ^C'S WORK NOW
	PUSHJ	P,SETINT	;SET ^C INTERUPT TRAPING
	MOVEI	T1,0		;GET WRITE-ENABLE CODE
	SETUWP	T1,		;WENABLE THE HIGH SEG
	  ERROR	CWS		;  ERROR--CANT WRITE HIGH SEG
	SETZM	XTFLAG		;DONT EXIT
	SETOM	TALKIN		;DONT EXIT ON ^C
	AOSN	REEINI		;NEED INITILIZATION?
	  PUSHJ	P,INIT		;  YES--INIT IT
	SETZM	TALKIN		;LET ^C'S WORK AGAIN
	SKIPE	XTFLAG		;DID WE GET ONE?
	  JRST	TALK4		;  YES--DIE NOW
	MOVEI	T1,5		;SLEEP 5 SECONDS AT A TIME
	MOVEI	T2,^D12		;FOR A MAXIMUN OF 60 SECS
TALK1:	SKIPG	REEINI		;IS IT BEING FIXED UP NOW?
	  JRST	TALK2		;  NO--THEN ITS OKAY
	SLEEP	T1,		;YES--GIVE HIM TIME
	SOJG	T2,TALK1	;THEN TRY AGAIN
	ERROR	TDI		;TIMEOUT DURING INIT
	CONT.
TALK2:	PUSHJ	P,INITME	;COUNT ME IN
	  JRST	TALK4		;  NO ROOM FOR A STRANGER
	SETZM	GETCMD		;DON'T HAVE A COMMAND YET
TALK3:	SETZM	DIDSOM		;DONE NOTHING YET
	PUSHJ	P,READ		;TRY TO READ A MSG
	PUSHJ	P,WRITE		;TRY TO WRITE ONE
	SKIPE	GETCMD		;GET A COMMAND FROM USER?
	  PUSHJ	P,COMAND	;  YES--GET AND PROCESS IT
	AOSN	DIDSOM		;DO ANYTHING?
	  JRST	TALK3		;  YES--DONT WAIT AROUND
	SKIPN	XTFLAG		;DO WE EXIT?
	 SKIPE	EXITME(P1)	; OR SOMEONE TELL US TO GO AWAY?
	  JRST	TALKA		;  YES--WELL GOODBY
	MOVEI	T1,^D1000	;1000 MILLISEC
	SKPINL			;ANY TTY ACTIVITY?
	 MOVE	T1,[HB.RTL+^D15000];NO--WAIT LONGER
	HIBER	T1,		;TAKE A SHORT NAP
	  JFCL			;  HUH???
	JRST	TALK3		;LOOP BACK

TALKA:	PUSHJ	P,DONE		;YES--COUNT ME OUT
TALK4:	SETZM	TALKIN		;ALLOW ^C'S ON CONTINUE
	.EXIT	TALK		;EXIT TO MONITOR
	SUBTTL	SETINT - Set up software interupt system

;Calling Sequence:
;
;	PUSHJ	P,SETINT	;SET UP INTERUPT SYSTEM
;	<Return>		;ONLY RETURN
;
;ACs used:	T1

SETINT:	MOVEI	T1,VECTOR	;ADDRESS OF INTERUPT VECTOR
	PIINI.	T1,		;TELL MONITOR
	  ERROR	SIE		;  SOFTWARE INTERUPT SYS ERROR
	MOVEI	T1,CCINT	;GET INTERUPT VECTOR
	MOVEM	T1,VECTOR	;SET IT IN VECTOR
	MOVE	T1,[PS.FAC+PS.FON+PS.FCP+[.PCSTP	;TRAP ^C'S
			0,,0				;TURN ON SYSTEM
			0,,0]]				;CLEAR ALL OLD INTER.
	PISYS.	T1,
	  ERROR	SIE		;  SOFTWARE INT. SYS ERROR
	POPJ	P,		;RETURN


	SUBTTL	CCINT - Control-C intercept routine

;Calling Sequence:
;
;	Called through PISYS. interupts.
;
;ACs used:	None

CCINT:	SETOM	XTFLAG		;FLAG THAT ^C READ
IFE	$DEBUG	<	;WHEN DEBUGGING ALWAYS EXIT
	SKIPN	TALKIN		;^C'S ENABLED?
	> ; END IFE $DEBUG
	  EXIT	1,		;  YES--EXIT
	DEBRK.			;RETURN FROM INTERUPT
	  HALT	.		;  BAD
	  HALT	.		;  BAD
	SUBTTL	INIT - Initalize everything

;Calling sequence:
;
;	PUSHJ	P,INIT		;INIT EVERYTHING
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

INIT:	STORE	T1,BZINI,EZINI,0;CLEAR STORAGE
	MOVEI	T1,MSGBUF+1	;POINT TO FIRST LINK
	MOVE	T2,[-MSGLEN+BUFLEN+1,,MSGBUF+BUFLEN+1]
INIT1:	SETOM	-1(T1)		;EMPTY BUFFER
	HRRZM	T2,(T1)		;LINK NEXT BUFFER
	HRRZ	T1,T2		;GOTO NEXT BUFFER
	ADD	T2,[BUFLEN,,BUFLEN]; ...
	JUMPL	T2,INIT1	;LOOP IF STILL IN BUFFER AREA
	MOVEI	T2,MSGBUF+1	;GET LINK TO FIRST HEADER
	HRRZM	T2,(T1)		;LINK BACK
	MOVEM	T2,BACK		;CLEAR LIST
	MOVEM	T2,FRONT	;BY SETTING POINTERS TO SAME PLACE
	HRLZI	T1,-PEOMAX	;GET NUMBER OF SLOTS
	MOVEI	T2,1		;AND BIT OF FIRST ONE
INIT2:	MOVEM	T2,PEOBIT(T1)	;SAVE THE BIT
	LSH	T2,1		;GET NEXT PERSONS BIT
	SETOM	EXITME(T1)	;TELL THEM TO EXIT IF STILL THERE
	AOBJN	T1,INIT2	;LOOP TO NEXT PERSON
	MOVEM	T2,LISBIT	;SAVE LISTENERS BIT
	SETOM	INUSE		;FREE INTERLOCK
	HRLZI	T1,400000	;GET MINUS INFINITY
	MOVEM	T1,REEINI	;AS FLAG THAT HIGH SEG IS SETUP
	POPJ	P,
	SUBTTL	INITME - Init my stuff - Count me in.

;Calling sequence:
;
;	PUSHJ	P,INITME	;INIT MY STUFF
;	  <Return>		;  NO ROOM IN THE INN
;	<Return>		;NORMAL RETURN
;
;ACs used:	T1-T4

INITME:	PUSHJ	P,GETNAM	;WHO ARE YOU?
	SETOM	TALKIN		;I NOW NEED SPECIAL EXIT STUFF
	MOVEI	T1,WAIBSY	;GET SLEEP TIME
	MOVEI	T2,MAXWAI	;AND MAX TIMES TO WAIT
	PUSHJ	P,SETLOC	;SET INTERLOCK
	  JRST	[ERROR	ISF	;  ERROR--TELL HIM
		.EXIT	TALK]	;  AND EXIT
	HRLZI	P1,-PEOMAX	;LENGTH OF LIST
INITM3:	SKIPE	PEOJOB(P1)	;ANY ONE HOME?
	  AOBJN	P1,INITM3	;  YES--TRY NEXT HOUSE
	JUMPG	P1,E$$NMR	;NO MORE ROOM?
	PJOB	T1,		;HAVE A PLACE TO STAY--WHO AM I?
	MOVEM	T1,PEOJOB(P1)	;LET OTHERS KNOW
	TRMNO.	T1,		;GET MY TTY UDX
	  ERROR	CRD		;  ERROR--RUNNING DETACHED?
	MOVEM	T1,MYUDX	;SAVE MY UDX
	MOVE	T1,MYNAM	;GET MY NAME
	MOVEM	T1,PEONAM(P1)	;LET PEOPLE KNOW ME
	GETPPN	T1,		;GET MY PPN
	  JFCL			;  (IN CASE PRIVED)
	MOVEM	T1,PEOPPN(P1)
	MOVE	T1,PEOBIT(P1)	;GET MY BIT
	ORM	T1,ALLBIT	;ADD ME TO LIST TO GET MSGS
	AOS	PEOPLE		;COUNT ME IN
	MOVE	T1,BACK		;ON ALL FURTHER MSGS
	MOVEM	T1,NEXT		;START WITH EMPTY LIST
	MOVE	T1,[POINT 7,[ASCIZ/Im Here/]]
	MOVEM	T1,SPCMSG	;SAVE SPECIAL MSG
	SETOM	INUSE		;CLEAR INTERLOCK
	SETZM	XTFLAG		;DONT EXIT YET
	SETZM	EXITME(P1)	;DONT EXIT YET
CPOPJ1:	AOS	(P)		;GIVE SKIP
CPOPJ:	POPJ	P,		;RETURN
	SUBTTL	TYPRUN - Type names of people already running TALK

;Calling Sequence:
;
;	PUSHJ	P,TYPRUN	;TELL WHO IS RUNNING
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4,	P2

TYPRUN:	MOVEI	T1,[ASCIZ/The following people are on:
/]
	PUSHJ	P,.TSTRG##	;TYPE HEADER
	MOVSI	P2,-PEOMAX	;POINT TO LIST OF PEOPLE
TYPRU1:	SKIPN	PEOJOB(P2)	;IS ONE THERE
	  JRST	TYPRU2		;  NONE--DONT PRINT ANYTHING
	MOVEI	T1,1(P2)	;GET INDEX NUMBER
	PUSHJ	P,.TDECW##	;TYPE IT
	MOVEI	T1,[ASCIZ/)  /]	;GET SEPERATOR
	SKIPE	EXITME(P2)	;ASKED TO LEAVE?
	MOVEI	T1,[ASCIZ/*  /]	;  YES--SPECIAL
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVE	T1,PEONAM(P2)	;GET HIS NAME
	PUSHJ	P,.TSIXN##	;TYPE NAME
	MOVE	T1,PEOPPN(P2)	;GET HIS PPN
	PUSHJ	P,.TPPNW##	;  TYPE IT OUT
	PUSHJ	P,.TNEWL##	;FINISH LINE
TYPRU2:	AOBJN	P2,TYPRU1	;LOOP BACK
	POPJ	P,		;UNLESS DONE
	SUBTTL	SETLOC - Set interlock

;Calling Sequence:
;
;	MOVEI	T1,<Sleep Time>	;GET TIME BETWEEN TRIES
;	MOVEI	T2,<Times to try>;GET # OF TIMES TO TRY TO SET INTERLOCK
;	PUSHJ	P,SETLOC	;SET INTERLOCK
;	  <Error>		;  CAN'T SET INTERLOCK
;	<Normal>		;INTERLOCK IS SET

SETLOC:	AOSN	INUSE		;TEST INTERLOCK
	  JRST	CPOPJ1		;  WE HAVE IT--DO STUFF
	HIBER	T1,		;TAKE A NAP
	  JFCL			;  HUH???
	SOJG	T2,SETLOC	;LOOP...
	POPJ	P,		;ERROR CANT SET INTERLOCK
	SUBTTL	GETNAM - Get name from user.

;Calling Sequence:
;
;	PUSHJ	P,GETNAM	;WHO IS HE?
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

GETNAM:	MOVEI	T1,[ASCIZ/TALK %/];PROGRAM NAME
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVE	T1,.JBVER	;GET VERSION
	PUSHJ	P,.TVERW##	;TYPE IT
	PUSHJ	P,.TNEWL##	;FINISH LINE
	PUSHJ	P,.TNEWL##	;NEW LINE
	PUSHJ	P,TYPRUN	;TELL HIM WHO IS RUNNING IT ALREADY
GETNM1:	MOVEI	T1,[ASCIZ/
Who are you?  /]		;GET CHALLENGE
	PUSHJ	P,.TSTRG##	;ISSUE IT

	PUSHJ	P,GETSIX	;GET SIXBIT NAME
	MOVEM	T4,MYNAM	;SAVE IT
	SKIPE	MYNAM		;DID HE GIVE ONE?
	  JRST	GETNM4		;  YES--CHECK IT OUT
	ERROR	MSN		;MUST SUPPLY NAME
	JRST	GETNM1		;GO GET IT

GETNM4:	MOVSI	T1,-PEOMAX	;GET NUMBER OF PEOPLE
	MOVE	T2,MYNAM	;GET MY NAME
GETNM5:	SKIPN	PEOJOB(T1)	;SOME ONE THERE?
	  JRST	GETNM6		;  NO--GO TO NEXT ONE
	CAMN	T2,PEONAM(T1)	;SAME NAME AS ME?
	  JRST	GETNM7		;  YES--CAN'T DO IT
GETNM6:	AOBJN	T1,GETNM5	;KEEP ON LOOPING
	POPJ	P,		;RETURN

GETNM7:	ERROR	NIU		;NAME ALREADY IN USE
	JRST	GETNM1		;TRY AGAIN
	SUBTTL	GETSIX - Get SIXBIT response from user

;Calling sequence:
;
;	PUSHJ	P,GETSIX	;GET RESPONSE FROM USER
;	<Return>		;ALWAYS RETURN  (RESPONSE IN T4)
;
;ACs used:	T1-T4

GETSIX:	SETZM	T4		;CLEAR RESPONSE
	MOVE	T2,[POINT 6,T4]	;POINT TO AREA FOR IT
	MOVEI	T3,6		;MAX OF SIX CHARS
GETSI2:	INCHWL	T1		;GET A CHAR
	CAIN	T1,.CHCRT	;<CR>?
	  JRST	GETSI2		;  YES--IGNORE IT
	CAIN	T1,.CHCNZ	;CONTROL-Z?
	  JRST	GETSI3		;  YES--SPECIAL
	CAIN	T1,.CHLFD	;<LF>?
	  POPJ	P,		;  YES--FINISH OFF
	SOJL	T3,GETSI2	;ROOM LEFT?
	CAIGE	T1," "		;CONTROL?
	  MOVEI	T1," "		;  YES--BLANK IT
	CAILE	T1,"_"		;LOWER CASE?
	  SUBI	T1," "		;  YES--CONVERT TO UPPER
	SUBI	T1," "		;CONVERT TO SIXBIT
	IDPB	T1,T2		;STORE IT
	JRST	GETSI2		;GET ANOTHER

GETSI3:	SETOM	XTFLAG		;EXIT AS SOON AS POSSIBLE
	POPJ	P,		;RETURN
	SUBTTL	READ - Read a message if one is there

;CALLING SEQUENCE:
;
;	PUSHJ	P,READ		;READ MESSAGES
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

READ:	MOVE	T1,NEXT		;GET ADDRESS OF FIRST MSG FOR ME
	CAMN	T1,BACK		;IS THERE SOMETHING THERE?
	  POPJ	P,		;  NO--RETURN
	MOVE	T2,PEOBIT(P1)	;GET MY ADDRESS
	TDNN	T2,1(T1)	;IS IT ADDRESSED TO ME?
	  JRST	READ1		;  NO--DONT READ IT
	TXC	T2,-1		;MAKE MASK FOR OTHERS
	ANDM	T2,1(T1)	;CLEAR ME FROM LIST
	MOVEI	T1,2(T1)	;GET ADDRESS OF ASCIZ STRING
	PUSH	P,T1		;SAVE IT FOR A MOMENT
	MOVEI	T2,.TOOIP	;OUTPUT IN PROGRESS?
	MOVE	T3,MYUDX	;FOR MY TERMINAL
	MOVE	T1,[2,,T2]	;GET SET
	TRMOP.	T1,		;WELL?
	  SETZ	T1,		;  ASSUME NOT
	JUMPN	T1,READ2	;IS IT?
	MOVEI	T2,.TOHPS	;FUNCTION
	MOVE	T3,MYUDX	;GET TTY UDX
	MOVE	T1,[2,,T2]	;SET UP TO GET HORIZ POS OF
	TRMOP.	T1,		;CARRIAGE, GET IT
	 CAIA			; CAN'T ASSUME NOT LEFT MARGIN
	  SKIPE	T1		;  IS IT AT LEFT MARGIN?
	   PUSHJ P,.TNEWL##	;   NO--BREAK LINE
READ2:	POP	P,T1		;GET BACK MSG
	PUSHJ	P,.TSTRG##	;AND TYPE IT OUT
READ1:	MOVE	T2,NEXT		;POINT TO MSG AGAIN
	MOVE	T1,(T2)		;GET ADDRESS OF NEXT MSG IN LIST
	MOVEM	T1,NEXT		;AND SAVE IT FOR NEXT TIME
	SOSG	-1(T2)		;DECREMENT AND TEST COUNT
	  MOVEM	T1,FRONT	;  WE ARE LAST--CLEAN UP
	SETOM	DIDSOM		;WE DID SOMETHING
	POPJ	P,		;RETURN
	SUBTTL	WRITE - Write a message if line typed

;Calling Sequence:
;
;	PUSHJ	P,WRITE		;WRITE MESSAGE
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

WRITE:	SKIPE	SPCMSG		;SPECIAL MESSAGE?
	  JRST	WRITEC		;  YES--DON'T CARE ABOUT TTY
	SKPINL			;LINE READY?
	  POPJ	P,		;  NO--RETURN
WRITEC:	SETZB	T1,T2		;DON'T WAIT AROUND TO LONG
	PUSHJ	P,SETLOC	;TRY TO SET INTERLOCK
	  POPJ	P,		;  CAN'T--TRY LATER
	MOVEI	T1,MAXMSG-^D10	;GET MAX CHARACTER COUNT
	MOVEM	T1,CHRCNT	;AND SAVE IT
	MOVE	T1,BACK		;GET POINTER TO NEXT FREE MSG
	MOVE	T2,(T1)		;POINT TO NEXT FREE MSG
	CAMN	T2,FRONT	;ANY ROOM?
	  JRST	WRITE3		;  NO--RESET LOCK AND WAIT
	HRRZI	T2,2(T1)	;GET POINTER TO STRING
	HRLI	T2,(POINT 7)	;MAKE IT INTO A BYTE POINTER
	MOVEM	T2,POINTR	;AND SAVE IT
	PUSHJ	P,GETCHR	;GET A CHARACTER
	  JRST	WRITE3		;  DONT PRINT BLANK LINES
	PUSH	P,T1		;SAVE THE CHARACTER
	MOVEI	T1,PUTBYT	;GET OUTPUT ROUTINE
	PUSHJ	P,.TYOCH##	;SWAP WITH OLD ONE
	PUSH	P,T1		;SAVE OLD ONE
	MOVE	T1,PEONAM(P1)	;GET MY NAME
	PUSHJ	P,.TSIXN##	;PUT IT IN
	MOVEI	T1,[ASCIZ/>	/];GET END OF NAME STRING
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	POP	P,T1		;GET FIRST CHAR
	EXCH	T1,(P)		;SWAP WITH OLD ROUTINE
	PUSHJ	P,.TCHAR##	;TYPE IT
WRITE1:	PUSHJ	P,GETCHR	;GET A CHARACTER FROM TTY
	  JRST	WRITE2		;  <EOL> OR NONE WAITING
	PUSHJ	P,.TCHAR##	;WRITE THE CHARACTER
	SOSLE	CHRCNT		;COUNT THE CHARACTER
	  JRST	WRITE1		;  ROOM LEFT--LOOP BACK
	CONT.
WRITE2:	PUSHJ	P,.TNEWL##	;FINISH UP LINE
	MOVEI	T1,0		;GET A NULL
	IDPB	T1,POINTR	;TO FINISH STRING
	POP	P,T1		;GET OLD TYPE OUT ROUTINE
	PUSHJ	P,.TYOCH##	;RESTORE IT
	MOVE	T1,BACK		;GET POINTER TO CURRENT BUFFER
	MOVE	T2,PEOPLE	;GET THE PEOPLE COUNT
	MOVEM	T2,-1(T1)	;SAVE IT AS THE READ COUNT
	MOVE	T2,ALLBIT	;GET EVERYBODY
	TDZ	T2,PEOBIT(P1)	;EXCEPT ME
	MOVEM	T2,1(T1)	;SAVE IT
	MOVE	T1,(T1)		;GO TO NEXT BUFFER
	MOVEM	T1,BACK		;AND SAY THAT IT IS LAST
	SETOM	DIDSOM		;WE DID SOME WORK
	HRLZI	T1,-PEOMAX	;GET NUMBER OF PEOPLE
WRITEB:	SKIPE	T2,PEOJOB(T1)	;SOMEONE HERE
	 WAKE	T2,		;  YES--WAKE EM
	  JFCL			;  IGNORE ERRORS
	AOBJN	T1,WRITEB	;LOOP BACK
WRITE3:	SETOM	INUSE		;WE ARE DONE WITH INTERLOCKED CODE
	POPJ	P,		;RETURN
	SUBTTL	GETCHR - Get a character from TTY

;Calling sequence:
;
;	PUSHJ	P,GETCHR	;GET A CHAR FROM TTY
;	  <Return>		;  NONE THERE OR <EOL>
;	<Return>		;WITH CHAR IN T1
;
;ACs used:	T1

GETCHR:	SKIPE	SPCMSG		;SPECIAL MSG?
	  JRST	GETCH1		;  YES--USE IT
	INCHRS	T1		;GET A CHARACTER
	  POPJ	P,		;  NONE--NON SKIP RETURN
	CAIN	T1,.CHCRT	;IS IT <CR>
	  JRST	GETCHR		;  YES--IGNORE IT
	CAIN	T1,.CHLFD	;LINE FEED?
	  POPJ	P,		;  YES--RETURN <EOL>
	CAIN	T1,.CHCNA	;CONTROL-A?
	  JRST	GETCH2		;  YES-- SET COMMAND MODE
	CAIE	T1,.CHCNZ	;CONTROL-Z?
	  JRST	CPOPJ1		;  NO--SKIP RETURN
	SETOM	XTFLAG		;YES--FLAG TO EXIT ASAP
	POPJ	P,		;GIVE <EOL> RETURN

GETCH1:	ILDB	T1,SPCMSG	;GET CHAR FROM MSG
	JUMPN	T1,CPOPJ1	;NON-NUL--GOOD CHAR
	SETZM	SPCMSG		;CLEAR SPECIAL MESSAGE
	POPJ	P,		;NUL--EOL

GETCH2:	SETOM	GETCMD		;FLAG THAT COMMAND PENDING
	POPJ	P,		;RETURN



	SUBTTL	PUTBYT - Put a byte into a byte string

;Calling sequence:
;
;	MOVE	AC,[POINT 7,WHERE]	;GET BYTE POINTER
;	MOVEM	AC,POINTR		;SAVE IT
;	...
;	PUSHJ	P,PUTBYT		;PUT THE CHAR AWAY
;	<Return>			;ONLY RETURN
;
;ACs used:	T1

PUTBYT:	IDPB	T1,POINTR	;DEPOSIT BYTE
	POPJ	P,		;AND RETURN
	SUBTTL	DONE - Im done now - Clear all my stuff

;Calling sequence:
;
;	PUSHJ	P,DONE		;COUNT ME OUT
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

DONE:	MOVE	T1,[POINT 7,[ASCIZ/Bye/]]
	MOVEM	T1,SPCMSG	;SAVE SPECIAL MESSAGE
	SETZM	DIDSOM		;CLEAR FLAG
	PUSH	P,[MAXWAI/4]	;GET # TIMES TO TRY
DONEA:	PUSHJ	P,WRITE		;TRY TO WRITE MSG
	SKIPE	DIDSOM		;DID IT WORK?
	  JRST	DONE1		;  YES--GO ON
	MOVEI	T1,WAIBSY	;GET HIBER TIME
	HIBER	T1,		;HIBERNATE A WHILE
	  JFCL			;  ???
	SOSG	(P)		;COUNT DOWN
	  JRST	DONEA		;  10, 9, 8,...
	ERROR	CSG		;CANNOT SAY GOODBY

DONE1:	POP	P,T1		;CLEAN UP STACK
	MOVEI	T1,WAIBSY	;GET SLEEP TIME
	MOVEI	T2,MAXWAI	;AND MAX TIMES TO WAIT
	PUSHJ	P,SETLOC	;SET INTERLOCK
	  ERROR	ISF		;  ERROR--INTERLOCK SET FAILURE

DONE2:	MOVE	T2,NEXT		;GET POINTER TO OUR LIST
	CAMN	T2,BACK		;ANY THING IN IT?
	  JRST	DONE3		;  NO--NEXT PART
	MOVE	T1,(T2)		;POINT TO NEXT MSG
	MOVEM	T1,NEXT		;SAVE IT FOR LOOP
	SOSG	-1(T2)		;COUNT US OUT OF THIS MSG
	  MOVEM	T1,FRONT	;  WERE LAST--CLEAN UP
	JRST	DONE2		;GO TO NEXT MSG IN LIST

DONE3:	MOVE	T1,PEOBIT(P1)	;GET MY BIT
	TXC	T1,-1		;CLEAR IT OUT
	ANDM	T1,ALLBIT	;OF THE LIST
	SETZM	PEOJOB(P1)	;FREE THE ROOM
	SETZM	PEONAM(P1)	;WIPE THE NAME TAG
	SOSG	PEOPLE		;COUNT ME OUT
	  SETOM	REEINI		;  LAST ONE CLEANS UP
	SETOM	INUSE		;LET OTHERS IN
	SETZM	TALKIN		;NOT TALKING ANY MORE
	POPJ	P,		;RETURN
	SUBTTL	Command Processing -- Main Routine

;Calling sequence:
;
;	PUSHJ	P,COMAND	;DO ONE COMMAND
;	<Return>		;ALWAYS RETURN
;
;ACs used:	T1-T4

COMAND:	SETZM	GETCMD		;PROCESSING COMMANDS NOW
	PUSHJ	P,WAILIN	;READ MESSAGES UNTIL A LINE IS READY
	PUSHJ	P,GETSIX	;GET SIXBIT COMMAND
	JUMPE	T4,CPOPJ	;NULL COMMAND?
	MOVSI	T2,-CMDLEN	;GET LENGTH OF COMMAND LIST
COMAN1:	CAMN	T4,CMDSIX(T2)	;DO THEY MATCH?
	  JRST	COMAN3		;  YES--TRY IT OUT
	AOBJN	T2,COMAN1	;LOOP TILL DONE
	ERROR	ILC		;ILLEGAL COMMAND
	POPJ	P,		;RETURN

COMAN3:	TDC	F,CMDPRV(T2)	;COMPLIMENT NECESSARY BITS
	TDCN	F,CMDPRV(T2)	;REE-COMP  ALL SET?
	  PJRST	@CMDRTN(T2)	;  YES--DO ROUTINE
	ERROR	ILC		;NO--ILLEGAL CMD
	POPJ	P,
	SUBTTL	Command Processing -- Tables

DEFINE	C	X	EXIT,0,Exit program
	X	HELP,0,This text
	X	INIT,T.PRIV+T.MAIN,Initalise Data Base
	X	KILL,T.PRIV,Kill a user
	X	LISTEN,T.PRIV+T.MAIN,Listen in on conversation
	X	WHO,0,List people running TALK
>

DEFINE	X(A,B,C)	<
	SIXBIT	/'A/
>

CMDSIX:	CC
CMDLEN==.-CMDSIX

DEFINE	X(A,B,C)	<
	EXP	B
>

CMDPRV:	CC

DEFINE	X(A,B,C)	<
	EXP	C$'A
>

CMDRTN:	CC

DEFINE	X(A,B,C)	<
	[ASCIZ/'A	- 'C
/]
>
CMDHLP:	CC
	SUBTTL	Command Processing -- Routines - INIT, WHO, EXIT, HELP

C$EXIT:	SETOM	XTFLAG		;SET FLAG TO EXIT
	POPJ	P,		;RETURN

C$WHO:	PJRST	TYPRUN		;SAME AS TYPRUN POUTINE

C$INIT:	PJRST	INIT		;SAME AS INIT ROUTINE

C$HELP:	MOVEI	T1,[ASCIZ/TALK %/]
	PUSHJ	P,.TSTRG##	;TYPE HEADER
	MOVE	T1,.JBVER	;GET VERSION
	PUSHJ	P,.TVERW##	;AND TYPE IT
	MOVEI	T1,[ASCIZ/	S.A. Barkley

/]
	PUSHJ	P,.TSTRG	;TYPE IT
	MOVSI	P2,-CMDLEN	;GET # OF CMDS
C$HEL1:	MOVE	T1,CMDHLP(P2)	;GET POINTER TO HELP MSG
	TDC	F,CMDPRV(P2)	;COMP PRIV BITS NEEDED
	TDCN	F,CMDPRV(P2)	;REE-COMP AND TEST IF ALL SET
	  PUSHJ	P,.TSTRG##	;  YES--HE CANUSE COMMAND
	AOBJN	P2,C$HEL1	;LOOP TILL DONE
	POPJ	P,		;THEN RETURN

C$LIST:	ERROR	LNI		;LISTEN COMMAND NOT YET IMPLIMENTED
	POPJ	P,		;RETURN
	SUBTTL	Command Processing -- Routines - KILL

C$KILL:	MOVEI	T1,[ASCIZ/Who do you want to kill?  /]
	PUSHJ	P,.TSTRG##	;ASK IT
	PUSHJ	P,WAILIN	;READ MSGS UNTIL RESPONSE READY
	PUSHJ	P,GETSIX	;GET RESPONSE
	MOVSI	T1,-PEOMAX	;GET MAX NUMBER OF PEOPLE
C$KIL1:	CAME	T4,PEONAM(T1)	;NAMES MATCH?
	  JRST	C$KIL2		;  NO--IGNORE HIM
	SETOM	EXITME(T1)	;YES--KILL HIM
	MOVE	T2,PEOJOB(T1)	;GET HIS JOB NUMBER
	WAKE	T2,		;WAKE HIM UP
	  JFCL			;  ...
C$KIL2:	AOBJN	T1,C$KIL1	;LOOP TILL DONE
	PJRST	TYPRUN		;SHOW WHO IS LEFT
	SUBTTL	WAILIN - Read messages until a line of input is ready

;Calling sequence:
;
;	PUSHJ	P,WAILIN	;WAIT FOR A LINE
;	<Return>		;RETURN HERE
;
;AC used:	T1

WAILIN:	SKPINL			;LINE READY?
	 CAIA			; NO--SEE IF ANYTHING READY TO READ
	  POPJ	P,		;  YES--RETURN
	SETZM	DIDSOM		;DIDNT DO ANYTHING YET
	TXNN	F,T.MAIN	;IN MAINTAINCE MODE?
	  PUSHJ	P,READ		;  NO--TRY TO READ A MESSAGE
	SKIPE	DIDSOM		;DO ANYTHING?
	  JRST	WAILIN		;  YES--TRY AGAIN
	MOVE	T1,[HB.RTL+^D15000]
	HIBER	T1,		;WAIT FOR A LITTLE BIT
	  JFCL			; ...
	JRST	WAILIN		;TRY AGAIN
	SUBTTL	REENTER Processing - Maintance mode

REENT:	.RESET			;RESET ALL I/O
	STORE	T1,BZCORE,EZCORE,0;CLEAR CORE
	GETPPN	T1,		;GET PPN
	  JFCL			;  (IN CASE PRIVED)
	CAMGE	T1,[11,,0]	;PRIVED USER?
	  TXO	F,T.PRIV	;  YES--SET FLAG
	TXO	F,T.MAIN	;SET MAINTANCE MODE
	MOVE	P,[IOWD PDLLEN,PDL];SET UP PDL
	SETZM	TALKIN		;LET ^C'S WORK
	PUSHJ	P,SETINT	;SET UP ^C INTERCEPT PROCESSING
	MOVEI	T1,0		;GET WENABLE CODE
	SETUWP	T1,		;FOR THE HIGH SEG
	  ERROR	CWS		;  ERROR--CANNOT WE HIGH SEG?
	SETZM	XTFLAG
REENT1:	SKPINL			;ANY INPUT?
	 CAIA			; YES--JUST A MIN
	  PUSHJ	P,COMAND	;  YES--GET IT
	SKIPE	XTFLAG		;EXIT?
	  JRST	REENT2		;  YES--DO IT
	MOVE	T1,[HB.RTL+^D15000];GET READY TO SLEEP A WHILE
	HIBER	T1,		;OR UNTIL A LINE READY
	  JFCL			;  IGNORE ERROR
	JRST	REENT1		;LOOP FOREVER

REENT2:	.EXIT	REENT		;EXIT TO MONITOR
	SUBTTL	Error messages

	$FATAL	ILC,Illegal Command
	POPJ	P,

	$WARN	LNI,Listen Not Yet Implimented
	POPJ	P,

	$WARN	NIU,Name already In Use -- try another
	POPJ	P,		;RETURN

	$WARN	LIU,Listen In Use
	POPJ	P,

	$WARN	CSG,Cannot Say Goodby
	POPJ	P,

	$WARN	MSN,Must Supply Your Name
	POPJ	P,

	$FATAL	CRD,Cannot Run Detached
	.EXIT	TALK

	$FATAL	NMR,No More Room -- Try again later
	SETOM	INUSE		;CLEAR INTERLOCK
	.EXIT	TALK

	$FATAL	CWS,Cannot Write High Segment
	.EXIT	TALK

	$FATAL	TDI,Timeout During Init
	.EXIT	TALK

	$FATAL	ISF,Interlock Set Failure
	POPJ	P,
E$$SIE:	OUTSTR	[ASCIZ/?TLKSIE Software Interupt System Error (/]
	PUSHJ	P,.PSH4T##	;SAVE REGS
	PUSH	T1,		;SAVE T1
	SETZ	T1,		;USE DEFAULT OUTPUT ROUTINE
	PUSHJ	P,.TYOCH##	;GET OLD ONE
	EXCH	T1,(P)		;SWAP WITH ERROR CODE
	PUSHJ	P,.TOCTW##	;TYPE ERROR CODE
	POP	P,T1		;GET OLD I/O ROUTINE
	PUSHJ	P,.TYOCH##	;RESTORE IT
	OUTSTR	[ASCIZ/)
/]
	PUSHJ	P,.POP4T##	;RESTORE WORLD
	.EXIT	TALK		;EXIT

	XLIST			;LITERALS XLISTED
	LIT
	LIST			;LIST AGAIN
	SUBTTL	Storage Areas -- High Segment

	HISEG			;THIS MUST BE SHARED CODE
BZINI:
PEOPLE:	BLOCK	1		;COUNT OF PEOPLE USING TALK
BACK:	BLOCK	1		;POINTER TO NEXT AVAIL MSG
FRONT:	BLOCK	1		;POINTER TO FIRST MSG NOT FULLY READ

REEINI:	-1			;REE-INIT FLAG
				;-1 TO INIT
				;>0 BEING INIT BY SOMEONE
				;<-1 ALREADY INIT AND RUNNING

INUSE:	BLOCK	1		;SINGLE ACCESS FLAG
				;-1 IF FREE, ELSE BUSY

LISTEN:	BLOCK	1		;LISTEN FUNCTION IN USE
LISBIT:	BLOCK	1		;BIT FOR LISTENER

ALLBIT:	BLOCK	1		;BIT OF PEOPLE LISTENING
PEOBIT:	BLOCK	PEOMAX+1	;BITS FOR EACH PERSON
PEOJOB:	BLOCK	PEOMAX		;JOB NUMBER OF EACH PERSON
PEONAM:	BLOCK	PEOMAX		;NAME OF EACH PERSON
PEOPPN:	BLOCK	PEOMAX		;PPN OF EACH PERSON
EXITME:	BLOCK	PEOMAX		;FORCE EXIT OF PERSON

MSGBUF:	BLOCK	MSGLEN		;MESSAGE BUFFERS
EZINI=.-1
	SUBTTL	Storage Areas -- Low Segment
	LOWSEG			;DOWN TO LOWSEG

BZCORE:
VECTOR:	BLOCK	4		;SOFTWARE INT. SYSTEM BLOCK
TALKIN:	BLOCK	1		;WE ARE TALKING TO SOMEONE
GETCMD:	BLOCK	1		;GET A COMMAND
NEXT:	BLOCK	1		;NEXT BUFFER TO READ
CHRCNT:	BLOCK	1		;COUNT OF CHARS LEFT IN BUFFER
XTFLAG:	BLOCK	1		;EXIT IF -1
POINTR:	BLOCK	1		;BYTE POINTER FOR MSG
DIDSOM:	BLOCK	1		;-1 IF WORK DONE
MYNAM:	BLOCK	1		;MY NAME
SPCMSG:	BLOCK	1		;SPECIAL MESSAGE POINTER
MYUDX:	BLOCK	1		;UDX OF MY TTY

PDL:	BLOCK	PDLLEN		;PDL
EZCORE=.-1


	END	TALK
  
Az