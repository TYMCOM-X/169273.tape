C
C	SCOOP - MANAGEMENT SYSTEM FOR USER NOTICES - VERSION 2
C       AUTHOR: CLIVE B. DAWSON
C		U.T. AUSTIN
C	DATE:	4-Feb-77
C
	IMPLICIT INTEGER (A-Z)
	DIMENSION FILNAM(2)	![rld] For filename on indirect access
	COMMON /UNIV/ UTDAY,UEDAY,UFADAY,UFEDAY
	COMMON /PLANN/ MINTIM
	COMMON /DDATE/ DIFF,ERR1
	COMMON /ITEM/ ITEM(0/299),PT,ERR,NUMCH,NUMWD
	COMMON /NOTICE/ NOTIT,NOTDAY,NOTMON,NOTYR
	COMMON /BITS/ MASK(5),SHFT(5)
	COMMON /ONEIT/ ONEIT,TASK	!SINGLE ITEM #, OPR TASK
	COMMON /USER/ USER		!USER'S PPN
	DIMENSION LINEP(0/150)
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	COMMON /BUF/ CHARS(100),LINE(21),TITLE(60),TLEN
	COMMON /MONLEN/MONLEN(12)	!LENGTH OF EACH MONTH-1
	COMMON /MONTAB/ MONTAB(12)
	COMMON /DEV/DEV
	DIMENSION FLIT(8)
	EQUIVALENCE(FLIT(1),FADAY),(FLIT(2),FAMON),(FLIT(3),FAMONN),
	1(FLIT(4),FAYEAR),(FLIT(5),FEDAY),(FLIT(6),FEMON),
	2(FLIT(7),FEMONN),(FLIT(8),FEYEAR)
	DATA MASK/"774000000000,"3760000000,"17700000,"77400,"376/
	DATA SHFT/29,22,15,8,1/
	DATA MONLEN/30,27,30,29,30,29,30,30,29,30,29,30/
	DATA MONTAB/'-JAN-','-FEB-','-MAR-','-APR-','-MAY-','-JUN-',
	1'-JUL-','-AUG-','-SEP-','-OCT-','-NOV-','-DEC-'/
	DATA OPRPPN/"1030000001/,MONE/-1/
	DATA D0/"60/,D9/"71/,FF/"14/
	DATA CTLA/1/,CTLB/2/,CR/"15/,LF/"12/,NULL/0/,BL/"40/,VT/"13/
	DATA CTLE/"5/,CTLF/"6/,CTLG/"7/
	DATA CTLH/"10/,CTLR/"22/,CTLU/"25/,ALT/"33/
	DATA RUB/"177/,TAB/"11/,UPAR/"136/
	DATA UCI/"111/,UCD/"104/,UCC/"103/,UCP/"120/,UCQ/"121/
	DATA LCA/"141/,LCZ/"172/,UCE/"105/,UCN/"116/,UCH/"110/
	DATA UCY/"131/,LCY/"171/,LCN/"156/


	DEV='DSK'
	OPRPPN="1000002
	DEV='SYS'
D	DEV='DSK'
D	OPRPPN="1030000001
	CALL SCNLIN			!RESCAN COMMAND LINE FOR ARGS
	CALL WHO			!GET PPN
	MINTIM=0
	INTER=0			!SEE IF WE ARE INTERACTIVE
	IF(USER.EQ.OPRPPN.AND.ONEIT.EQ.0.AND.TASK.EQ.0) INTER=-1
C
C    IF OPR, OR QUICK OR NOTICE, SPECIAL RUN
C
	IF (USER.EQ.OPRPPN.OR.TASK.EQ.UCN.OR.TASK.EQ.UCQ) GO TO 1000

****************************************************************

C   THIS IS THE NORMAL SCOOP RUN

10	RFL=0				!NOTHING HAS BEEN TYPED
	WRITE (5,11)
11	FORMAT()
	IF (LKUP('SCOOP').EQ.0) GO TO 100  !SCOOP FILE NOT THERE
	OPEN(UNIT=1,DEVICE=DEV,FILE='SCOOP.TXT')

C   LOOK FOR AN ITEM--BEGINS WITH A ^A

15	READ (1,30,END=100) FSTCHR
	IF (FSTCHR.NE.CTLA) GO TO 15
	REREAD 20,ITNUM
20	FORMAT (2X,I2)

C   WE'VE GOT ONE...SHALL WE TYPE IT?

	IF (ONEIT.NE.0.AND.ITNUM.NE.ONEIT) GO TO 15	!NOPE
	REREAD 30,CHARS
30	FORMAT (100R1)
	GO TO 53

C   LOOP TO TYPE ITEM

50	ST=1
	IF(CHARS(1).LE.CTLE) ST=2
	WRITE (5,51)(CHARS(J),J=ST,I-1)	!OUT IT GOES
51	FORMAT(1X,100R1)
	RFL=1				!WE HAVE TYPED
52	READ (1,30,END=100) CHARS	!GET ANOTHER LINE
53	IF (CHARS(1).EQ.CTLE) GO TO 70	!END OF ITEM
	IF (CHARS(1).EQ.CTLB.AND.USER.NE.OPRPPN) GO TO 52  !^B PRIVS
	IF(TASK.EQ.UCQ.AND.CHARS(1).NE.CTLA) GO TO 52	!INDEX ONLY
54	DO 55 I=98,2,-1			!FIND END OF LINE
55	IF (CHARS(I-1).NE.BL) GO TO 50
	I=1
	GO TO 50			!LOOP

C   START OF NEW ITEM

70	CALL CTLO			!CANCEL CONTROL-O
	IF (ONEIT.EQ.0) GO TO 15	!WE WANT ALL ITEMS
	IF (INTER) GO TO 1013
	CALL EXITT

C   HERE ON EOF

100	IF (RFL.EQ.1.AND.INTER) GO TO 1013	!OPR LOOP
	IF (RFL.EQ.1) CALL EXITT	!TYPEOUT OCCURED-NORMAL EXIT
	IF (ONEIT.NE.0) GO TO 110	!FILE WAS EMPTY
	WRITE (5,105)
105	FORMAT(/' Sorry, no news today.'/)
	IF(INTER) GO TO 1013			!OPR LOOP
	CALL EXITT
110	WRITE (5,115) ONEIT
115	FORMAT (/' Item',I3,' not found.'/)
	IF(INTER) GO TO 1013			!OPR LOOP
	CALL EXITT

******************************************************************

C   OPERATOR RUN - COMMAND DISPATCH

1000	IF(ONEIT.NE.0.AND.TASK.EQ.0) GO TO 10	!MUST BE NORMAL RUN
	IF(TASK.EQ.0) GO TO 1013	!ASK WHAT HE WANTS
	WRITE (5,1005) TASK		!ECHO COMMAND
1005	FORMAT (1X,R1,$)
	GO TO 1017			!GO DISPATCH
1013	CALL CLRTTY
	ONEIT=0				!INITIALIZE
	TASK=0
	WRITE (5,1015)			!PROMPT
1015	FORMAT(/' *',$)
	CALL INCHR(TASK)		!GET A CHAR
	IF (TASK.GE.LCA.AND.TASK.LE.LCZ) TASK=TASK-"40	!UPPER CASE
1017	IF(TASK.EQ.UCI) GO TO 2000		!INSERT
	IF(TASK.EQ.UCD) GO TO 3000		!DELETE
	IF(TASK.EQ.UCC) GO TO 4000		!CLEAN UP
	IF(TASK.EQ.UCP) GO TO 5000		!PURGE
	IF(TASK.EQ.UCQ) GO TO 1090		!NORMAL RUN (INDEX)
	IF(TASK.EQ.CR) GO TO 10			!NORMAL RUN
	IF(TASK.EQ.UCE) GO TO 1080		!EXIT
	IF(TASK.EQ.UCH) GO TO 7000
	IF(TASK.EQ.UCN) GO TO 6000		!TYPE NOTICE.TXT
	IF(DIG(TASK)) GO TO 1070		!SPECIFIC ITEM

1019	WRITE (5,1020)
1020	FORMAT('+ is an illegal command.')
	GO TO 1013


1070	ONEIT=TASK-D0			!DECIMAL INPUT
	CALL INCHR(CH)			!GET POSSIBLE 2ND DIGIT
	IF(CH.EQ.CR) GO TO 10		!GO TO NORMAL RUN
	IF(CH.LT.D0.OR.CH.GT.D9) GO TO 1019	!ERROR
	ONEIT=ONEIT*10+CH-D0
	GO TO 10

1080 	WRITE (5,1081)	 		!EXIT
1081	FORMAT('+xit'//)
	CALL EXITT
1090	WRITE (5,1091)			!QUICK INDEX RUN
1091	FORMAT('+uick index:')
	GO TO 10
*****************************************************************

C   INSERTION

2000	WRITE (5,2005)
2005	FORMAT ('+nsert item.')
	MINTIM=0			!INIT MINTIM
2025	WRITE (5,2030)			!GET TITLE
2030	FORMAT (/' TITLE: ',$)
	READ (5,30,END=2025) TITLE
	DO 2038 I=60,1,-1		!CHECK LENGTH
	IF(TITLE(I).EQ.BL) GO TO 2038
	IF(I.LE.50) GO TO 2040
	WRITE (5,2036)			!ERROR
2036	FORMAT(' ?TOO LONG--50 CHARACTERS MAX')
	GO TO 2025
2038	CONTINUE
	WRITE (5,2039)
2039	FORMAT(' ?GOTTA HAVE A TITLE...')
	GO TO 2025
2040	TLEN=I				!LENGTH OF TITLE

C   EXPIRATION DATE

2050	CALL UNVDAY(UTDAY)		!GET UNIVERSAL DATE-TIME
	CALL UNDEC(UTDAY,TYEAR,TMONUM,TDAY,THOUR,TMIN) !GET COMPONENTS
	CALL UNVCAL(TYEAR,TMONUM,TDAY,THOUR,TMIN,0,UTDAY) !ROUND DOWN
	TYEAR=TYEAR-1900
	TMON=MONTAB(TMONUM)
2060	WRITE (5,2061)
2061	FORMAT(' EXP. DATE (CR=2 WKS): ',$)
	CALL DATEIN(EDAY,EMON,EMONUM,EYEAR)	!INPUT DATE
	IF(EDAY.GE.0) GO TO 2070		!CHECK FOR ERROR
2065	WRITE (5,2066)
2066	FORMAT(' ?BAD DATE! TRY AGAIN...DD-MMM-YY')
	GO TO 2060
2070	IF (EDAY.EQ.0) GO TO 2100		!COMPLETE DEFAULT
	CALL DEFDAT(EDAY,EMON,EMONUM,EYEAR,TDAY,TMONUM,TYEAR)
	CALL CHKDAT(EDAY,EMON,EMONUM,EYEAR,TDAY,TMONUM,TYEAR)
	IF(ERR1) 2065,2080,2060
2080	CALL UNVCAL(EYEAR+1900,EMONUM,EDAY,0,0,0,UEDAY)
	GO TO 2300

C   CALCULATE DEFAULT EXPIRATION DATE

2100	UEDAY=UTDAY+"16000000			!2 WEEK DEFAULT
	CALL UNDEC(UEDAY,EYEAR,EMONUM,EDAY,DUM,DUM) !DECOMPOSE UNIV DATE
	EMON=MONTAB(EMONUM)
	EYEAR=EYEAR-1900


C   EXPIRATION TIME

2300	WRITE (5,2305)
2305	FORMAT(' EXP. TIME (CR=23:59): ',$)
	CALL TIMEIN(EHOUR,EMIN,ERR)
	IF (ERR.EQ.0) GO TO 2325
2320	WRITE(5,2321)
2321	FORMAT(' ?BAD TIME! TRY AGAIN...HH:MM')
	GO TO 2300
2325	IF(EHOUR.GE.0) GO TO 2330		!IS IT DEFAULT?
	EHOUR=23			!DEFAULT
	EMIN=59
2330	UETIM=(EHOUR*3600+EMIN*60)*2**18/(24*3600)
	UEDAY=UEDAY.OR.UETIM
	IF(UEDAY.GT.UTDAY) GO TO 2350		!EXPIRE BEFORE CREATE?
	WRITE(5,2340)
2340	FORMAT(' THAT''S IN THE PAST! TRY AGAIN...')
	GO TO 2060			!GO ALL THE WAY BACK TO DATE

C   OPERATOR ID

2350	WRITE (5,2351)
2351	FORMAT(' OPERATOR ID: ',$)
	READ(5,2353,END=2350) OPER,DUM
2353	FORMAT(2A5)
	IF(DUM.EQ.' ') GO TO 2360	!CHECK FOR MAX OF 5 CHARS
	WRITE(5,2355) 
2355	FORMAT(' ?FIVE CHARACTER MAX...TRY AGAIN')
	GO TO 2350

C   FLASH STATUS

2360	DO 2361 I=1,6
2361	FLIT(I)=0			!INITIALIZE ALL FLASH DATES
	WRITE (5,2362)
	UFADAY=0
	UFEDAY=0
2362	FORMAT(' FLASH ITEM? (Y OR CR): ',$)
	CALL INCHR(CH)
	CALL CLRTTY
	IF(CH.NE.UCY.AND.CH.NE.LCY) GO TO 2400
2364	WRITE (5,2365)
2365	FORMAT('+es.'/' ACTIVATION DATE (CR=TODAY): ',$)
	CALL DATEIN(FADAY,FAMON,FAMONN,FAYEAR)	!GET DATE
	IF(FADAY.GE.0) GO TO 2370		!ERROR?
2366	WRITE(5,2066)				!YES
	GO TO 2364
2370	IF(FADAY.NE.0) GO TO 2375		!DEFAULT?
	FADAY=TDAY
	FAMON=TMON
	FAMONN=TMONUM
	FAYEAR=TYEAR
2375	CALL DEFDAT(FADAY,FAMON,FAMONN,FAYEAR,TDAY,TMONUM,TYEAR)
	CALL CHKDAT(FADAY,FAMON,FAMONN,FAYEAR,TDAY,TMONUM,TYEAR)
	IF(ERR1) 2366,2376,2364
2376	CALL UNVCAL(FAYEAR+1900,FAMONN,FADAY,0,0,0,UFADAY)
	IF(UFADAY.LE.UEDAY) GO TO 2382	  !CANT HAVE FLASH AFTER EXP 
2380	WRITE(5,2381)
2381	FORMAT(' THAT''S AFTER THE EXPIRATION!  TRY AGAIN...')
	GO TO 2364
2382	WRITE(5,2383)
2383	FORMAT(' ACTIVATION TIME (CR=NOW): ',$)
	CALL TIMEIN(FAHOUR,FAMIN,ERR)
	IF(ERR.EQ.0) GO TO 2384
	WRITE(5,2321)				!BAD TIME FORMAT
	GO TO 2382
2384	IF(FAHOUR.GE.0) GO TO 2385
	FAHOUR=THOUR			!SET NOW AS DEFAULT
	FAMIN=TMIN
2385	UFATIM=(FAHOUR*3600+FAMIN*60)*2**18/(3600*24)
2386	UFADAY=UFADAY.OR.UFATIM			!STORE THE TIME
	IF(UFADAY.GE.UEDAY) GO TO 2380   !CANT BE AFTER THE EXP
	UFEDAY=UFADAY+"1000000		!FLASH EXPIRES IN 24 HOURS
	IF(UFEDAY.GT.UEDAY) UFEDAY=UEDAY	!UNLESS EXP COMES
	CALL UNDEC(UFEDAY,FEYEAR,FEMONN,FEDAY,FEHOUR,FEMIN)
	FEMON=MONTAB(FEMONN)
	FEYEAR=FEYEAR-1900

C   PERMANENT OR TEMPORARY STATUS?  (PERMANENT WINDS UP IN SCOOP.OLD)

2400	CALL WAIT			!WAIT FOR OUTPUT TO STOP (KLUDGE)
	WRITE (5,2401)
2401	FORMAT (' PERMANENT? (Y OR CR): ',$)
	PERMFL=' '			!ASSUME NOT PERMANENT
	CALL INCHR(CH)
	CALL CLRTTY
	IF(CH.NE.UCY.AND.CH.NE.LCY) GO TO 2420
	PERMFL='*'
	WRITE (5,2961)			!FILL IN THE "ES"

C   ITEM INSERTION

2420	PT=0				!INITIALIZE ITEM PTR
	LPTR=0				!INIT LINE POSITION PTR
	LINEP(0)=0
	WRITE (5,2421)
	INDFLG=0	![rld] flag for reading indirect text. set false.
2421	FORMAT(/' ITEM: (END WITH AN ALTMODE.'/
	1' USE ^Ffile.ext FOR INDIRECT ACCESS.)'/$)
2450	IF(INDFLG) CALL FILCHR(CH,CHRCNT,CHRPTR,INDFLG) ![rld] FILCHR returns
							!from file.ext
	IF(.NOT.INDFLG) CALL INCHR(CH)
	SCH=CH				!SAVE IT
	IF(CH.EQ.CTLF) GO TO 2500	![rld] ^F indirect access
	IF(CH.EQ.RUB) GO TO 2510	!RUBOUT
	IF(CH.GT.ALT) GO TO 2800	!NORMAL CHAR
	IF(CH.EQ.ALT) GO TO 2850	!ALTMODE
	IF(CH.EQ.CTLH) GO TO 2600	!BACKSPACE
	IF(CH.EQ.CTLR) GO TO 2680	!^R
	IF(CH.EQ.CTLU) GO TO 2680	!^U
	IF(CH.EQ.CTLG) GO TO 2750	!^G
	IF(CH.EQ.CTLA.OR.CH.EQ.CTLB.OR.CH.EQ.CTLE) GO TO 2680 !LIKE ^R
	GO TO 2800			!MUST BE NORMAL

C	CONTROL F - PREPARE TO READ IN TEXT FROM A FILE [rld]
C	INITIALIZE VARIABLES FOR SUBROUTINE FILCHR.

2500	ACCEPT 2501,FILNAM		! Get name of file.
2501	FORMAT(2A5)
	OPEN(UNIT=23,DIALOG=FILNAM,ACCESS='SEQIN')
	INDFLG=-1	!Set Indirect flag true.
	CHRCNT=0	!Number of chars. in LBUF()
	CHRPTR=0	!Points to current char in LBUF()
	GOTO 2450
C   PROCESS RUBOUT

2510	CH=GETCH(-1)			!GET CURRENT CHAR
	IF(ERR) GO TO 2420		!WE'RE AT THE BEGINNING
	IF(NORMAL(CH)) GO TO 2512
	WRITE(5,2515) UPAR		!ITS A CONTROL CHAR
2512	WRITE(5,2515) CH
2515	FORMAT('+',R1,$)
	GO TO 2450

C   PROCESS BACKSPACE

2600	CH=GETCH(-1)			!GET THE CHAR
	IF(ERR) GO TO 2420		!WE'RE BACK ALL THE WAY
	IF(CH.EQ.CR) GO TO 2620		!SPECIAL HANDLING FOR CR
	IF(CH.EQ.LF) GO TO 2630		!LF
	IF(CH.EQ.VT) GO TO 2630		!VT
	IF(CH.EQ.FF) GO TO 2630		!FF
	GO TO 2650			!OTHERWISE NORMAL
2620	WRITE(5,2515) CR		!MAKE SURE WE ARE AT THE BEG.
	GO TO 2690			!SIMULATE CONTROL R
2630	LPTR=LPTR-1			!DECREMENT CHAR COUNT
	GO TO 2450
2650	WRITE(5,2651) BL,CTLH		!BLANK OUT BAD CHAR
2651	FORMAT('+',2R1,$)
	BLEN=LINEP(LPTR)-LINEP(LPTR-1)-1  !COUNT NUMBER OF POSITIONS
	IF(BLEN.EQ.0) GO TO 2660	!NORMAL BACKSPACING-OK
	DO 2652 I=1,BLEN		!ECHO EXTRA BACKSPACES
2652	WRITE(5,2553) CTLH,BL,CTLH
2553	FORMAT('+',3R1,$)
2660	LPTR=LPTR-1			!DECREMENT POSITION
	GO TO 2450

C   PROCESS ^R, ^U

2680	WRITE(5,2651) CR,LF		!TYPE OUT CRLF
2690	SAVPT=PT			!SAVE CURRENT POINTER
	LPTR=0				!RESET LINE PTR
2695	CH=GETCH(-1)			!BACK UP TO A CR OR START
	IF(ERR) GO TO 2698
	IF(CH.NE.CR) GO TO 2695		!LOOP
	CH=GETCH(1)			!MOVE FORWARD OVER CRLF
	CH=GETCH(1)
2698	IF(SCH.EQ.CTLU) GO TO 2450	!IF ^U, WE ARE DONE
	IF(PT.GE.SAVPT) GO TO 2450	!ARE WE DONE?
	CH=GETCH(1)			!NO, GET A CHAR
	IF(NORMAL(CH)) GO TO 2699
	WRITE(5,2515) UPAR		!ITS A CONTROL CHAR
2699	WRITE(5,2515) CH		!TYPE IT
	LPTR=LPTR+1
	CALL WAIT			!WAIT FOR OUTPUT TO STOP
	LINEP(LPTR)=GETPOS(0)		!STORE POSITION OF LINE
	GO TO 2698

C   PROCESS ^G

2750	SAVPT=PT			!SAVE PTR
	WRITE(5,2553) CR,LF,LF		!SKIP A LINE
	PT=0
2755	IF(PT.EQ.SAVPT) GO TO 2450	!ARE WE DONE
	CH=GETCH(1)			!GET A CHAR
	IF(NORMAL(CH)) GO TO 2756
	WRITE(5,2515) UPAR		!ITS A CONTROL CHAR
2756	WRITE(5,2515) CH		!TYPE IT
	GO TO 2755

C   PROCESS NORMAL CHAR

2800	CALL PUTCH(CH)			!INSERT CHAR INTO BUFFER
	IF(ERR) GO TO 2820
	LPTR=LPTR+1
	IF(CH.EQ.CR) LPTR=0		!IF CR, RESET LINE
	LINEP(LPTR)=GETPOS(0)		!STORE POSITION
	GO TO 2450
2820	WRITE(5,2821)
2821	FORMAT(//' ??ITEM TOO LONG!! 1500 CHAR MAX. SORRY ''BOUT THAT.')
	GO TO 2420

C   PROCESS END OF ITEM

2850	CH=GETCH(-1)			!GET LAST CHAR
	CALL PUTCH(CH)			!PUT IT BACK
	IF(CH.EQ.LF) GO TO 2851		!WAS IT A LINE FEED?
	CALL PUTCH(CR)			!NO, FAKE A CR,LF
	CALL PUTCH(LF)
2851	IF(MOD(PT,5).EQ.2) GO TO 2870
	CALL PUTCH(NULL)
	GO TO 2851
2870	CALL PUTCH(CR)
	IF(ERR) GO TO 2820
	CALL PUTCH(LF)
	CALL PUTCH(CTLE)
	NUMCH=PT
	NUMWD=(PT-1)/5

C   OBTAIN ITEM NUMBER AND VERIFY


C  SET UP TWO DIGIT PRINTOUT

	TH1=THOUR/10
	TH2=THOUR-TH1*10
	TM1=TMIN/10
	TM2=TMIN-TM1*10
	EH1=EHOUR/10
	EH2=EHOUR-EH1*10
	EM1=EMIN/10
	EM2=EMIN-EM1*10
	FAH1=FAHOUR/10
	FAH2=FAHOUR-FAH1*10
	FAM1=FAMIN/10
	FAM2=FAMIN-FAM1*10
	FEH1=FEHOUR/10
	FEH2=FEHOUR-FEH1*10
	FEM1=FEMIN/10
	FEM2=FEMIN-FEM1*10

C   ECHO FOR VERIFICATION

2920	WRITE(5,2925) TDAY,TMON,TYEAR,TH1,TH2,TM1,TM2,
	1(TITLE(I),I=1,TLEN)
2925	FORMAT(//' [  ]',1X,I2,A5,I2,'/',2I1,':',2I1,2X,50R1)
	WRITE (5,2926) OPER,PERMFL,EDAY,EMON,EYEAR,EH1,EH2,EM1,EM2
2926	FORMAT(1X,A5,1X,'EXP:',A1,'[',I2,A5,I2,'/',2I1,':',2I1,']',$)
	IF(FADAY.EQ.0) GO TO 2930
	WRITE(5,2927)FADAY,FAMON,FAYEAR,FAH1,FAH2,FAM1,FAM2,FEDAY,FEMON,
	1FEYEAR,FEH1,FEH2,FEM1,FEM2
2927	FORMAT('+ FLASH: [',I2,A5,I2,'/',2I1,':',2I1,']-[',I2,A5,I2,'/',
	12I1,':',2I1,']'$)
2930	WRITE (5,2931)
2931	FORMAT (/)
	WRITE(5,2934) (ITEM(I),I=0,NUMWD)
2934	FORMAT(1X,300A5)
2936	WRITE(5,2940)
2940	FORMAT(/' OK? (Y or N): ',$)
	CALL INCHR(CH)
	IF(CH.EQ.UCY.OR.CH.EQ.LCY) GO TO 2960
	IF(CH.EQ.UCN.OR.CH.EQ.LCN) GO TO 2950
	WRITE (5,2947) CR,LF
2947	FORMAT ('+',2R1,'You must type Y or N')
	GO TO 2936
2950	WRITE (5,2951)
2951	FORMAT('+o.')
	GO TO 1013
2960	WRITE (5,2961)
2961	FORMAT('+es.')

C  ITEM IS GOOD--GO AHEAD AND INSERT
2900	OPEN(UNIT=1,DEVICE=DEV,FILE='SCOOP.TXT',ACCESS='SEQOUT')
	ITNUM=1				!ASSUME ITEM 1
	LOOK=LKUP('SCOOP')		!CHECK EXISTENCE OF SCOOP
2905	IF(LOOK.EQ.0) GO TO 2963	!NOT THERE
	OPEN (UNIT=2,DEVICE=DEV,FILE='SCOOP.TXT',ACCESS='SEQIN')
	READ(2,2910,END=2919) ITNUM
2910	FORMAT(13X,I)
2919	ITNUM=ITNUM+1			!NEW ITEM
	IF (ITNUM.GT.99) ITNUM=1	!Wrap around from 99 to 1

2963	WRITE(1,2964) ITNUM		!PUT OUT FIRST LINE OF SCOOP.TXT
2964	FORMAT('LATEST ITEM: ',I2)
	WRITE (1,2965) CTLA,ITNUM,TDAY,TMON,TYEAR,TH1,TH2,TM1,TM2,
	1(TITLE(I),I=1,TLEN)
2965	FORMAT(R1,'[',I2,']',1X,I2,A5,I2,'/',2I1,':',2I1,2X,50R1)
	IF(FADAY.NE.0) GO TO 2968
	WRITE(1,2966) CTLB,OPER,PERMFL,EDAY,EMON,EYEAR,EH1,EH2,EM1,EM2
2966	FORMAT(R1,A5,1X,'EXP:',A1,'[',I2,A5,I2,'/',2I1,':',2I1,']')
	GO TO 2970
2968	WRITE(1,2969) CTLB,OPER,PERMFL,EDAY,EMON,EYEAR,EH1,EH2,EM1,EM2,
	1FADAY,FAMON,FAYEAR,FAH1,FAH2,FAM1,FAM2,FEDAY,FEMON,
	2FEYEAR,FEH1,FEH2,FEM1,FEM2
2969	FORMAT(R1,A5,1X,'EXP:',A1,'[',I2,A5,I2,'/',2I1,':',2I1,']',
	1' FLASH: [',I2,A5,I2,'/',2I1,':',2I1,']-[',I2,A5,I2,'/',
	22I1,':',2I1,']')
2970	WRITE (1,2973) (ITEM(I),I=0,NUMWD)
2973	FORMAT(300A5)

C   SET UP TO APPEND CURRENT SCOOP FILE TO THIS ITEM

	NOTS=-1				!WE ALREADY HAVE LATEST SCOOP
	NOTF=0				!NO FLASH YET
	IF(FADAY.NE.0.AND.UFADAY.LE.UTDAY.AND.UFEDAY.GT.UTDAY) NOTF=-1
	CALL PLAN (UEDAY)		!RECORD A CRITICAL TIME
	CALL PLAN (FADAY)
	CALL PLAN (FEDAY)
	IF(LOOK.NE.0) CALL COPY		!APPEND REST OF SCOOP, IF ANY
	CLOSE (UNIT=1)			!CLOSE SCOOP.TXT
	NOTIT=ITNUM			!SET UP FOR NOTICE.??
	NOTDAY=TDAY
	NOTMON=TMON
	NOTYR=TYEAR
	CALL NOTE
	CALL NOTIC
	IF(INTER) GO TO 1013
	CALL EXITT
**************************************************************

C   ITEM DELETION

3000	WRITE (5,3005)
3005	FORMAT('+elete item #: ',$)
3007	CALL DATEIN(ITNUM,DUM,DUM,DUM)	!KLUDGE FOR INPUTING #
	IF(ITNUM.GT.0.AND.ITNUM.LE.99) GO TO 3009
	WRITE(5,3008)
3008	FORMAT(' ?BAD NUMBER. TRY AGAIN...'/' Delete item #: ',$)
	GO TO 3007
3009	PURGE=0
3010	DELIT=ITNUM
	MINTIM=0			!REINIT MINTIM
	CALL CLNUP			!GO CLEAN UP!
	IF(DELIT.NE.0) GO TO 3050
	CALL NOTIC			!GO WRITE NOTICE.TXT
	GO TO 3060
3050	WRITE(5,3051) ITNUM
3051	FORMAT(' ?ITEM ',I2,' NOT FOUND')
3060	IF(INTER)  GO TO 1013		!RETURN
	CALL EXITT			!OR LEAVE

*****************************************************************

C   GENERAL CLEAN UP

4000	WRITE (5,4005)
4005	FORMAT('+lean up.')
	DELIT=0
	MINTIM=0
	PURGE=0
	CALL CLNUP			!GO CLEAN UP
	CALL NOTIC			!GO WRITE NOTICE.TXT
	IF(INTER) GO TO 1013		!ARE WE INTERACTIVE
	CALL EXITT			!NOPE

**************************************************************

C   PURGE AN ITEM  (DOESN'T GO INTO SCOOP.OLD

5000	WRITE (5,5005)
5005	FORMAT ('+urge item #: ',$)
5007	CALL DATEIN (ITNUM,DUM,DUM,DUM)		!ROB FROM PETER...
	IF(ITNUM.GT.0.AND.ITNUM.LE.99) GO TO 5010
	WRITE(5,5008)
5008	FORMAT (' ?BAD NUMBER. TRY AGAIN...'/' Purge item #: ',$)
	GO TO 5007
5010	PURGE=-1			!FLAG MEANS WE ARE PURGING
	GO TO 3010			!GO JOIN THE FUN AT DELETE

**********************************************************************

C   TYPE NOTICE.TXT

6000	WRITE (5,6005)
6005	FORMAT('+OTICE.TXT: ',$)
	OPEN (UNIT=4,DEVICE='NEW',FILE='NOTICE.TXT',ACCESS='SEQIN',
	1ERR=6004)
	GO TO 6010
6004	WRITE (5,6007)
6007	FORMAT('+was not found...')
	GO TO 6020
6010	WRITE (5,6009)
6009	FORMAT()
6011	READ(4,30,END=6020) CHARS
	DO 6015 I=100,1,-1
6015	IF(CHARS(I).NE.BL) GO TO 6018
	I=1
6018	WRITE(5,51) (CHARS(J),J=1,I)
	GO TO 6011
6020	IF(INTER) GO TO 1013
	CALL EXITT				!LEAVE
**********************************************************

C   HELP

7000	WRITE (5,7005)
7005	FORMAT ('+elp!'//
	1' <CR> - Normal SCOOP run: all current items typed.'/
	2' n    - Type item n.'/
	3' I    - Insert an item.'/
	4' D    - Delete an item.'/
	5' P    - Purge an item. (Doesn''t go into SCOOP.OLD)'/
	6' C    - Clean up SCOOP file.'/
	7' N    - Type NOTICE.TXT.'/
	8' Q    - Type a quick index of scoop items.'/
	9' H    - Type this.'/
	1' E    - Exit.'/)
	IF (INTER) GO TO 1013		!ARE WE INTERACTIVE?
	CALL EXITT

	END
	subroutine filchr(ch,chrcnt,chrptr,indflg)

C	THIS SUBROUTINE RETURNS A CHARACTER TAKEN FROM A LE OF TEXT. 100 CHARS ARE READ INTO LBUF().
C	WHEN ALL OF THESE HAVE BEEN RETURNED, THE BUFFER
C	IS RE-FILLED.

	implicit integer(a-z)
	dimension lbuf(100)	! Buffer for text to be read into

	if (chrptr.LT.chrcnt) goto 100 ! if equal its time to re-fill LBUF()

	read(23,10,end=200) (lbuf(i),i=1,100) !read in a new buffer of text
10	format(100r1)

	do 15 chrcnt=98,1,-1 ! find last non blank char of LBUF()
	if (lbuf(chrcnt).NE."40) goto 20
15	continue
20	lbuf(chrcnt+1)="15 ! add a <crlf> to end of line
	lbuf(chrcnt+2)="12
	chrcnt=chrcnt+2 ! chrcnt ='s chars in LBUF()
	chrptr=0

100	chrptr=chrptr+1 !point to next character in LBUF()
	ch = lbuf(chrptr)
	return

200	indflg=0	! indirect access of text done
	type 201
201	format(/' CONTINUE WITH TEXT:'//$)
	return
	end
	SUBROUTINE DATEIN(DAY,MON,MONUM,YEAR)

C   THIS SUBROUTINE WILL SCAN AN INPUT LINE FOR A DATE.
C   IF THERE IS AN ERROR, A -1 WILL BE RETURNED IN DAY,
C   OTHERWISE, IT WILL RETURN ALL IT FINDS IN THE APPROPRIATE 
C   LOCATIONS, LEAVING THE OTHER ONES AT ZERO

	IMPLICIT INTEGER(A-Z)
	DIMENSION CH(30)
	DATA D0/"60/,MINUS/"55/,BL/"40/
	DAY=0
	MON=0
	MONUM=0
	YEAR=0
	READ (5,30,END=110) CH
30	FORMAT(30R1)
	J=1
	IF(.NOT.DIG(CH(1))) GO TO 100		!DEFAULT
	DAY=CH(1)-D0				!GET DAY
	J=2
	IF(.NOT.DIG(CH(2))) GO TO 60
	DAY=DAY*10+CH(2)-D0
	J=3
60	IF(CH(J).NE.MINUS) GO TO 100		!SEE IF MONTH IS COMING
	MON=CH(J)
	DO 65 I=1,3
65	MON=LSHIFT(MON,7).OR.(CH(J+I).AND."137)	!PACK MONTH AND KILL LC
	MON=LSHIFT(MON,7).OR.MINUS		!PUT IN DASH
	MON=LSHIFT(MON,1)			!ADJUST 5 CHARS
	J=J+4
	MONUM=MONLEG(MON)
	IF(MONUM.EQ.0) GO TO 110		!CHECK FOR LEGAL MONTH
80	IF(CH(J).NE.MINUS) GO TO 100		!DOES YEAR FOLLOW?
	M=CH(J+1)
	N=CH(J+2)
	IF(.NOT.(DIG(M).AND.DIG(N))) GO TO 110	!MUST BE 2 DIGITS
	YEAR=(M-D0)*10+N-D0			!YEAR
	J=J+3
100	IF(CH(J).EQ.BL) RETURN
110	DAY=-1					!ERROR RETURN
	RETURN
	END
	FUNCTION MONLEG(MON)

C   THIS FUNCTION CHECKS A WORD OF 5 ASCII CHARACTERS TO SEE IF
C   THEY FORM A LEGAL MONTH NAME...IF SO, THE MONTH'S NUMBER IS
C   RETURNED; IF NOT, A ZERO.

	IMPLICIT INTEGER(A-Z)
	COMMON /MONTAB/MONTAB(12)
	DO 10 I=1,12
	IF(MON.EQ.MONTAB(I)) GO TO 20
10	CONTINUE
	MONLEG=0
	RETURN
20	MONLEG=I
	RETURN
	END
	FUNCTION DIG(N)

C   THIS FUNCTION CHECKS THE CHARACTER IN N TO SEE IF IT IS A DIGIT

	IMPLICIT INTEGER (A-Z)
	DATA D0/"60/,D9/"71/
	DIG=0
	IF(N.GE.D0.AND.N.LE.D9) DIG=-1
	RETURN
	END
	SUBROUTINE CHKDAT(DAY,MON,MONUM,YEAR,TDAY,TMONUM,TYEAR)

C   THIS SUBROUTINE PERFORMES DATE CHECKING ON DAY,MON,YEAR, AND
C   MAKES SURE THAT IT OCCURS AFTER TDAY,TMONUM,TYEAR.
C   IT RETURNS AN ERR CODE AS FOLLOWS: 0: OK
C				       -1: ERROR (NO MESSAGE TYPED)
C				        1: ERROR (MESSAGE ALREADY TYPED)

	IMPLICIT INTEGER (A-Z)
	COMMON /DDATE/ DIFF,ERR1
	COMMON /UNIV/ UTDAY,UEDAY,UFADAY,UFEDAY
	COMMON /MONLEN/MONLEN(12)
	DATA UCY/"131/,LCY/"171/,UCN/"116/,LCN/"156/

C   CHECK DATE

	ERR1=0
2250	IF(MONUM.EQ.2.AND.DAY.EQ.29.AND.MOD(YEAR,4).EQ.0) GO TO 2258
	IF(DAY.LE.MONLEN(MONUM)+1) GO TO 2258
	ERR1=-1
	RETURN
2258	CALL UNVCAL(YEAR+1900,MONUM,DAY,0,0,0,UDAY)
	DIFF=LSHIFT(UDAY,-18)-LSHIFT(UTDAY,-18)
	IF(DIFF.LT.0) GO TO 2270
	IF(DIFF.GT.31) GO TO 2280
	RETURN				!ITS OK
2270	WRITE (5,2271)
2271	FORMAT(' ?THAT''S IN THE PAST! TRY AGAIN...')
	ERR1=1
	RETURN
2280	WRITE (5,2281) DIFF
2281	FORMAT(' THAT''S',I4,' DAYS AWAY. ARE YOU SURE ABOUT THIS? ',$)
2282	CALL INCHR(REPLY)
	CALL CLRTTY
	IF(REPLY.NE.UCY.AND.REPLY.NE.LCY) GO TO 2285
	WRITE (5,2283)
2283	FORMAT('+es')
	RETURN
2285	IF(REPLY.NE.UCN.AND.REPLY.NE.LCN) GO TO 2290
	WRITE (5,2287)
2287	FORMAT('+o')
	ERR1=1				!ANOTHER CHANCE
	RETURN
2290	WRITE (5,2291)
2291	FORMAT(/' You must type Y or N: ',$)
	GO TO 2282
	END
	SUBROUTINE DEFDAT(DAY,MON,MONUM,YEAR,TDAY,TMONUM,TYEAR)

C   THIS SUBROUTINE WILL SUPPLY MISSING PORTIONS OF A DATE

	IMPLICIT INTEGER(A-Z)
	COMMON /MONTAB/ MONTAB(12)
	IF(MON.EQ.0) GO TO 2150
	IF(YEAR.EQ.0) GO TO 2200
	RETURN				!WE MUST HAVE IT ALL
2150	MONUM=TMONUM
	YEAR=TYEAR
	IF(DAY.LT.TDAY) MONUM=MONUM+1	!BUMP MONTH IF DAY IS LESS
	IF(MONUM.LE.12) GO TO 2155	!DID WE BUMP YEAR?
	MONUM=1
	YEAR=YEAR+1
2155	MON=MONTAB(MONUM)
	RETURN
2200	YEAR=TYEAR			!DEFAULT YEAR
	IF(MONUM-TMONUM) 2210,2230,2215
2210	YEAR=TYEAR+1			!MONTH IS LESS, BUMP YEAR
2215	RETURN
2230	IF(DAY.GE.TDAY) RETURN
	GO TO 2210
	END
	SUBROUTINE TIMEIN(HOUR,MIN,ERR)

C   THIS SUBROUTINE WILL RETURN HOURS AND MINUTES.  IF THERE IS AN
C   ERROR, ERR WILL BE TRUE. IF DEFAULT, HOUR WILL BE NEGATIVE.

	IMPLICIT INTEGER (A-Z)
	DIMENSION CH(60)
	DATA BL/"40/,D0/"60/,COL/"72/
	READ (5,5) CH
5	FORMAT(60R1)
	ERR=0				!RESET ERROR
	DO 10 I=1,60			!FLUSH BLANKS
10	IF(CH(I).NE.BL) GO TO 15
	HOUR=-1				!ALL BLANKS, DEFAULT
	RETURN
15	IF(.NOT.DIG(CH(I))) GO TO 30	!ERROR
	HOUR=CH(I)-D0			!GET HOUR
	I=I+1
	IF(.NOT.DIG(CH(I))) GO TO 20
	HOUR=HOUR*10+CH(I)-D0
	I=I+1
20	IF(CH(I).NE.COL) GO TO 30	!MUST BE A COLON
	I=I+1
	IF(.NOT.DIG(CH(I))) GO TO 30
	MIN=CH(I)-D0			!GET MINUTES
	I=I+1
	IF(.NOT.DIG(CH(I))) GO TO 30
	MIN=MIN*10+CH(I)-D0
	I=I+1
	IF(CH(I).EQ.BL) RETURN		!MUST BE TRAILED BY BLANK
30	ERR=-1				!SET ERROR
	RETURN
	END
	SUBROUTINE PUTCH(CH)

C   THIS SUBROUTINE DEPOSITS CH INTO THE ITEM BUFFER

	IMPLICIT INTEGER(A-Z)
	COMMON/ITEM/ ITEM(0/299),PT,ERR
	COMMON /BITS/ MASK(5),SHFT(5)
	ERR=0
	IF(PT.LT.1500) GO TO 10
	ERR=-1
	RETURN
10	PT=PT+1				!BUMP PTR
	WD=(PT-1)/5			!CALCULATE POSITION OF CHAR
	POS=MOD(PT-1,5)+1
	ITEM(WD)=(ITEM(WD).AND..NOT.MASK(POS)).OR.LSHIFT(CH,SHFT(POS))
	RETURN
	END
	FUNCTION GETCH(MOVE)

C   THIS SUBROUTINE RETURNS A CHARACTER FROM THE ITEM BUFFER
C	MOVE = -1 MEANS GET CURRENT CHAR, THEN BACK UP
C	MOVE = 0  MEANS GET CURRENT CHAR, DON'T MOVE
C	MOVE = 1  MEANS MOVE FORWARD, GET CHAR.

	IMPLICIT INTEGER(A-Z)
	COMMON /ITEM/ ITEM(0/299),PT,ERR
	COMMON /BITS/ MASK(5),SHFT(5)
	ERR=0
	IF(MOVE) 5,5,10
5	IF(PT.GT.0) GO TO 21
7	ERR=-1
	RETURN
10	IF(PT.LT.1500) GO TO 20
	GO TO 7
20	PT=PT+1
21	WD=(PT-1)/5
	POS=MOD(PT-1,5)+1
	GETCH=LSHIFT(ITEM(WD),-SHFT(POS)).AND."177
	IF(MOVE.LT.0) PT=PT-1
	RETURN
	END
	FUNCTION NORMAL(CH)

C   THIS SUBROUTINE DETERMINES WHETHER A CHARACTER SHOULD BE
C	TYPED PRECEEDED BY AN UPARROW. THAT IS, IS IT A CONTROL
C	CHARACTER?  IF SO, CH WILL BE ALTERED TO ITS PRINT FORM.

	IMPLICIT INTEGER(A-Z)
	DATA BL/"40/,TAB/"11/,CR/"15/
	NORMAL=-1			!ASSUME NORMAL CHAR
	IF(CH.GE.BL.OR.(CH.GE.TAB.AND.CH.LE.CR)) RETURN
	IF(CH.EQ.0) RETURN		!NULL IS NORMAL
	NORMAL=0			!ITS A CONTROL CHAR
	CH=CH+"100
	RETURN
	END
	SUBROUTINE COPY

C   THIS SUBROUTINE IS THE GENERAL UPDATE ROUTINE FOR SCOOP--
C   IT WILL RECOPY SCOOP, DELETING EXPIRED ITEMS, HANDLE FLASHES, ETC.
C   IT IS ALSO CALLED TO APPEND SCOOP TO A NEW ITEM

	IMPLICIT INTEGER(A-Z)
	DOUBLE PRECISION FILNAM
	COMMON /UNIV/ UTDAY,UEDAY,UFADAY,UFEDAY
	COMMON /ITEM/ ITEM(0/299),PT,ERR,NUMCH,NUMWD
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	COMMON /DEV/ DEV
	COMMON /BUF/ CHARS(100),LINE(21),TITLE(60),TLEN
	COMMON /NOTICE/ NOTIT,NOTDAY,NOTMON,NOTYR
	DIMENSION TEMPIT(50)
	DATA BL/"40/,CTLA/"1/,CTLB/"2/,CTLE/"5/
5	READ(2,10,END=100) A,ITNUM,TDAY,TMON,TYEAR,TEMPIT,B,PERMFL,EDAY,
	1EMON,EYEAR,EHOUR,EMIN,FADAY,FAMON,FAYEAR,FAHOUR,FAMIN,FEDAY,
	2FEMON,FEYEAR,FEHOUR,FEMIN
10	FORMAT(R1,1X,I2,2X,I2,A5,I2,8X,50R1/R1,10X,A1,1X,I2,A5,I2,1X,
	1I2,1X,I2,10X,I2,A5,I2,1X,I2,1X,I2,3X,I2,A5,I2,1X,I2,1X,I2)
	IF(A.NE.CTLA.OR.B.NE.CTLB) GO TO 200
	CALL UNVCAL(EYEAR+1900,MONLEG(EMON),EDAY,EHOUR,EMIN,0,UEDAY)
	FLASH=0
	IF(DELIT.EQ.ITNUM) GO TO 60		!WE WANT TO DELETE THIS
	IF(UEDAY.LE.UTDAY) GO TO 45		!ITEM HAS EXPIRED
	CALL PLAN(UEDAY)			!RECORD CRITICAL TIME
	IF(NOTF.OR.FADAY.EQ.0) GO TO 12		!CHECK POSSIBLE FLASH
	CALL UNVCAL(FAYEAR+1900,MONLEG(FAMON),FADAY,FAHOUR,FAMIN,0,
	1UFADAY)
	CALL UNVCAL(FEYEAR+1900,MONLEG(FEMON),FEDAY,FEHOUR,FEMIN,0,
	1UFEDAY)
	CALL PLAN(UFADAY)
	CALL PLAN(UFEDAY)
	IF(UFADAY.GT.UTDAY.OR.UTDAY.GE.UFEDAY) GO TO 12	!NOT A FLASH
	FLASH=-1			!THIS IS A FLASH
	NOTF=-1				!THIS WILL BE THE ONLY ONE
	PT=0				!INIT ITEM PTR FOR FLASH
12	IF (NOTS) GO TO 20		!DO WE HAVE A LATEST SCOOP
	DO 16 I=50,1,-1			!NOPE, GET THIS ONE
16	IF(TEMPIT(I).NE.BL) GO TO 17
	I=1
17	TLEN=I
	DO 18 I=1,TLEN
18	TITLE(I)=TEMPIT(I)
	NOTIT=ITNUM			!SET UP THIS ITEM FOR NOTICE
	NOTDAY=TDAY
	NOTMON=TMON
	NOTYR=TYEAR
	NOTS=-1				!WE NOW HAVE A LATEST SCOOP
20	UNIT=1				!SET UP TO APPEND THIS ITEM
21	BACKSPACE 2			!BACK UP OVER DATA ITEMS
	BACKSPACE 2
	CALL COPYIT(UNIT)
	GO TO (5,5,55) UNIT		!WHAT HAVE WE DONE?
45	IF(PERMFL.EQ.' ') GO TO 62	!THIS ITEM IS TO BE PURGED
50	WRITE(5,51) ITNUM		!HERE ON ITEM TO BE DELETED
51	FORMAT(' ITEM',I3,' DELETED.')
	UNIT=3				!SET UP SCOOP.OLD
	OPEN(UNIT=UNIT,DEVICE=DEV,FILE='SCOOP.OLD',ACCESS='APPEND')
	GO TO 21			!GO AND APPEND THIS ITEM TO .OLD
55	CLOSE(UNIT=UNIT)		!WE'RE BACK...CLOSE SCOOP.OLD
	IF(DELIT.EQ.ITNUM) DELIT=0	!DID WE DELETE A DOOMED ITEM?
	GO TO 70			!GO WIPE OUT NOTICE.??

60	IF (PURGE.EQ.0) GO TO 45	!REGULAR DELETION
62	WRITE(5,61) ITNUM
61	FORMAT(' ITEM ',I2,' PURGED.')
63	READ(2,64,END=200) CH			!FLUSH THIS ITEM
64	FORMAT(R1)
	IF(CH.NE.CTLE) GO TO 63
	DELIT=0
70	ITEN=ITNUM/10
	IONE=ITNUM-ITEN*10
	ENCODE(10,71,FILNAM) ITEN,IONE
71	FORMAT('NOTICE.'2I1)
	OPEN(UNIT=4,DEVICE='NEW',FILE=FILNAM,ACCESS='SEQIN',ERR=5)
	CLOSE(UNIT=4,DISPOSE='DELETE')
	GO TO 5

100	RETURN				!WE ARE DONE
200	WRITE(5,201)
201	FORMAT(' ?ILLEGAL SCOOP FORMAT!!!!!')
	STOP
	END
	SUBROUTINE COPYIT(UNIT)

C   THIS SUBROUTINE COPIES A SINGLE ITEM FROM THE OLD SCOOP FILE
C   ONTO DEVICE UNIT

	IMPLICIT INTEGER(A-Z)
	COMMON /ITEM/ ITEM(0/299),PT,ERR,NUMCH,NUMWD
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	COMMON /BUF/ CHARS(100),LINE(21),TITLE(60)
	DATA CR/"15/,LF/"12/,CTLE/"5/,BL/"40/,NULL/"0/
	DATA CTLA/"1/,CTLB/"2/
21	READ(2,22,END=50) CHARS
22	FORMAT(100R1)
	ST=1				!SET START OF LINE TO DEFAULT
	IF(UNIT.EQ.3.AND.CHARS(1).EQ.CTLB)GO TO 21  !NO ^B LINE IF OLD
	IF(UNIT.EQ.3.AND.CHARS(1).EQ.CTLE) GO TO 40  !NO ^E LINE IF OLD
	IF(UNIT.NE.3.OR.CHARS(1).NE.CTLA) GO TO 28   !NO ITEM # IF OLD
	ST=5
	CHARS(5)=CTLA			!KEEP THE CONTROL A, THOUGH
28	DO 29 I=100,1,-1		!TRIM THIS LINE
29	IF(CHARS(I).NE.BL) GO TO 30
	I=1
30	WRITE(UNIT,22) (CHARS(J),J=ST,I)	!OUTPUT THE LINE
	IF(FLASH.EQ.0.OR.CHARS(1).LE.CTLE) GO TO 40  !PROCESS FLASH?
	DO 35 J=1,I
35	CALL PUTCH(CHARS(J))		!INSERT THIS ITEM AS A FLASH
	CALL PUTCH(CR)
	CALL PUTCH(LF)			!INSERT CRLF AFTER EACH LINE
40	IF(CHARS(1).NE.CTLE) GO TO 21	!ARE WE DONE?
41	IF(FLASH.EQ.0) RETURN		!YES
	CH=GETCH(-1)
	CH=GETCH(-1)			!BACK UP OVER LAST CRLF
42	IF(MOD(PT,5).EQ.2) GO TO 45
	CALL PUTCH(NULL)		!PAD ITEM WITH NULLS TILL WD
	GO TO 42
45	PT=PT+3
	NUMWD=(PT-1)/5
	NUMCH=PT
	RETURN
50	WRITE (5,51) 
51	FORMAT(' ?ILLEGAL SCOOP FORMAT!!!!')
	STOP
	END
	SUBROUTINE PLAN(TIM)

C   THIS SUBROUTINE DETERMINES THE EARLIEST TIME THAT SOMETHING 
C   HAS TO BE DONE TO THE SCOOP FILE

	IMPLICIT INTEGER(A-Z)
	COMMON /UNIV/ UTDAY
	COMMON /PLANN/ MINTIM
	IF(TIM.LE.UTDAY.OR.UTDAY.EQ.0) RETURN
	IF(TIM.LT.MINTIM.OR.MINTIM.EQ.0) MINTIM=TIM
	RETURN
	END
	SUBROUTINE NOTE

C   THIS SUBROUTINE CREATES NOTICE.??, WHERE ?? IS THE ITEM #

	IMPLICIT INTEGER (A-Z)
	DOUBLE PRECISION FILNAM
	COMMON /NOTICE/ NOTIT,NOTDAY,NOTMON,NOTYR
	COMMON /ITEM/ ITEM(0/299),PT,ERR,NUMCH,NUMWD
	COMMON /BUF/ CHARS(100),LINE(21),TITLE(60),TLEN
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	COMMON /DEV/DEV
	ITEN = NOTIT/10
	IONE = NOTIT - ITEN*10
	ENCODE(10,2950,FILNAM) ITEN,IONE
2950	FORMAT('NOTICE.',2I1)
	OPEN (UNIT=4,DEVICE='NEW',FILE=FILNAM,ACCESS='SEQOUT')
	WRITE (4,2981) NOTIT,NOTDAY,NOTMON,NOTYR,(TITLE(I),I=1,TLEN)
2981	FORMAT('[',I2,']',I3,A5,I2,2X,50R1)
2990	CLOSE (UNIT=4)
	RETURN
	END
	SUBROUTINE NOTIC

C    THIS SUBROUTINE PUTS A FLASH INTO NOTICE.TXT

	IMPLICIT INTEGER (A-Z)
	DOUBLE PRECISION FILNAM
	COMMON /NOTICE/ NOTIT,NOTDAY,NOTMON,NOTYR
	COMMON /ITEM/ ITEM(0/299),PT,ERR,NUMCH,NUMWD
	COMMON /BUF/ CHARS(100),LINE(21),TITLE(60),TLEN
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	COMMON /DEV/DEV

	OPEN(UNIT=4,DEVICE='NEW',FILE='NOTICE.TXT',ACCESS='SEQIN',
	1ERR=10)
	CLOSE(UNIT=4,DISPOSE='DELETE')	!FIRST DELETE EXISTING FILE

10	IF(NOTF.EQ.0) RETURN		!NO FLASH

	OPEN(UNIT=4,DEVICE='NEW',FILE='NOTICE.TXT',ACCESS='SEQOUT')
	WRITE(4,15)			!BLANK LINE
15	FORMAT()
	ITEM(NUMWD)=ITEM(NUMWD).AND."777760000000	!NO CR,LF,^E
	IF(ITEM(NUMWD).EQ.0) NUMWD=NUMWD-1
	IF(NUMWD.LT.1) GO TO 100
	WRITE(4,20) (ITEM(I),I=0,NUMWD)
20	FORMAT('FLASH...'/300A5)
100	CLOSE(UNIT=4)
	RETURN
	END

	SUBROUTINE CLNUP

C   THIS SUBROUTINE PERFORMS GENERAL CLEAN UP, DELETING ITEMS IF
C   NECESSARY, ETC.

	IMPLICIT INTEGER(A-Z)
	COMMON /DEV/DEV
	COMMON /UNIV/ UTDAY,UEDAY,UFADAY,UFEDAY
	COMMON /CLEAN/ NOTS,NOTF,DELIT,PURGE,FLASH
	CALL UNVDAY(UTDAY)		!GET UNIVERSAL DAY-TIME
	NOTS=0			!NO NOTICE YET
	NOTF=0			!NO FLASH YET
	LOOK=LKUP('SCOOP')		!SEE IF SCOOP IS THERE
	IF(LOOK.EQ.0)   GO TO 3050	!NOT THERE
	OPEN (UNIT=1,DEVICE=DEV,FILE='SCOOP.TXT',ACCESS='SEQOUT')
	OPEN (UNIT=2,DEVICE=DEV,FILE='SCOOP.TXT',ACCESS='SEQIN')
	READ (2,2910) LATEST
2910	FORMAT(13X,I)
2964	FORMAT('LATEST ITEM: ',I2)
	WRITE(1,2964) LATEST
	CALL COPY			!GO UPDATE SCOOP
	CLOSE(UNIT=1)
3050	RETURN
	END
	SUBROUTINE QUEUE

C   THIS SUBROUTINE DECIDES IF A QUEUE REQUEST IS NEEDED
C   TO PROCESS AN ITEM DUE TO EXPIRE BEFORE THE NEXT CLEAN
C   UP.. IF SO, IT EXITS TO A RUN UUO FOR QUEUE...IF NOT, IT 
C   RETURNS

	IMPLICIT INTEGER (A-Z)
	COMMON /PLANN/ MINTIM
	COMMON /UNIV/ UTDAY
	COMMON /TMP/ TMPBUF(10)
	DIMENSION ATO(5)
	DATA CR/"15/,LF/"12/
C   ATO CONTAINS THE TIMES OF AUTOMATIC SCOOP CLEAN UPS BY OPSER
C   TIMES ARE IN UNIVERSAL FORMAT--SECONDS*2**18/86400  WHERE SECONDS
C   IS THE TIME EXPRESSED IN SECONDS SINCE MIDNITE
C                 8:00AM  8:45AM  3:45PM  10:00PM 11:59PM
	DATA ATO/"252525,"320000,"520000,"725252,"777777/
	DATA NUMATO/5/			!NUMBER OF DAILY AUTO FILES
	DATA DM/"777777000000/,TM/"777777/
	IF(MINTIM.EQ.0) RETURN		!MAKE SURE WE HAVE A TIME
	IF((UTDAY.AND.DM).NE.(MINTIM.AND.DM)) RETURN  !ONLY WORRY ABOUT TODAY
	TIME=MINTIM.AND.TM
	TIME=TIME+400			!ADD A COUPLE OF MINUTES--IN CASE
					!AUTO FILE IS IMMINENT...
	NOW=UTDAY.AND.TM
	DO 10 I=1,NUMATO
10	IF(NOW.LT.ATO(I).AND.TIME.GT.ATO(I)) RETURN
	H1=((TIME*24*3600)/2**18)/60
	MIN=H1-H1/60*60
	HR=H1/60
	H1=HR/10
	H2=HR-H1*10
	M1=MIN/10
	M2=MIN-M1*10
	WRITE(5,20) H1,H2,M1,M2
20	FORMAT(/' "NEXT SCOOP CLEAN UP DUE AT ',2I1,':',2I1,'"'/)
C  *****Note:  If this QUEUE request is changed, be sure to adjust
C		the number of words for TMPCOR UUO in TEMPC.
	ENCODE (50,30,TMPBUF) CR,LF,H1,H2,M1,M2,CR,LF
30	FORMAT('I:SCOOP=/KILL',2R1,
	1'I:=SCOOP,/DEL/OUTP:0/AFTER:',2I1,':',2I1,2R1)
	CALL TEMPC
	CALL RUNN ('SYS','QUEUE',0,0,1)
	CALL EXIT			!IN CASE OF RUN ERROR...
	END
	SUBROUTINE TMPFIL
C
C   THIS SUBROUTINE WILL WRITE A TMP FILE ON DISK IF THE 
C   TMPCOR UUO FAILS
C
	IMPLICIT INTEGER (A-Z)
	COMMON /TMP/ TMPBUF(10)
	COMMON /JOBNUM/ JOB
	DOUBLE PRECISION FILNAM
	J1=JOB/100
	J2=JOB/10-J1*10
	J3=JOB-J1*100-J2*10
	ENCODE(10,20,FILNAM) J1,J2,J3
20	FORMAT(3I1,'QUE.TMP')
	OPEN (UNIT=20,DEVICE='DSK',FILE=FILNAM)
	WRITE(20,30) TMPBUF
30	FORMAT(9A5)
	CLOSE(UNIT=20)
	RETURN
	END
   aOR0