	TITLE	FORFUN	%5A(650) - OVERLAY FUNCTION MODULE FOR FOROTS
	SUBTTL	H. P. WEISS/HPW/DMN/MD/DPL/JNG/SJW/SWG	21-MAR-77

;[JMS] Includes modifications for SYSTEM 1022 core allocation


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

;COPYRIGHT (C) 1973,1977 BY DIGITAL EQUIPMENT CORPORATION

VERWHO==0	;EDITOR
VERVER==05	;MAJOR VERSION NUMBER
VERUPD==0	;MINOR VERSION NUMBER
VEREDT==650	;EDIT NUMBER

VERFUN==BYTE (3)VERWHO(9)VERVER(6)VERUPD(18)VEREDT

PURGE	VERWHO,VERVER,VERUPD,VEREDT



	SUBTTL	REVISION HISTORY

;446	15993	FIX CBC FUNCTION SO IT WILL CUT BACK CORE PROPERLY
;		FOR LINK OVERLAY'S
;477	17759	ALWAYS REQUEST AT LEAST ONE WORD FROM GMEM%%
;506	17107	DELETE OVERLAY HANDLER'S FREE CORE LIST. HAVING ONLY
;		ONE LIST DOES NO HARM IF THE /SPACE DOES NOT OVERFLOW,
;		AND IS BENEFICIAL IN MOST CASES IF IT DOES.
;511	17107	DELETE ALL DMEM%% CALLS. THEY ARE USELESS AND WASTE TIME
;512	17107	IF GAD FAILS, DELETE FORMAT BLOCKS & RETRY.
;514	18030	CHANGE GMEM%% CALL SO CAN RETURN ERROR CODE INSTEAD
;		OF BOMBING WITH %FRSSYS NO CORE AVAILABLE MESSAGE.
;	*****	BEGIN VERSION 5
;571	-----	ADD FUNCTIONS RRS & WRS: RESERVED FOR DBMS
;650	-----	CHANGE REFERENCE TO ALCOR1 IN FOROTS TO FMEM%%
;****************	END OF REVISION HISTORY
	SUBTTL	DEFINE SYMBOLS
SEARCH	FORPRM		;GLOBAL SYMBOLS DEFINED IN FORPRM

IFNDEF FT$22,FT$22==-1	;[JMS]
IFE FT$22,<IF2,<PRINTX [DEC standard FORFUN will be assembled]>>
IFN FT$22,<IF2,<PRINTX [1022 version of FORFUN will be assembled]>>

SEGMEN

	DEFINE FUNDIR,<
	FNCTN	ILL		;0; ILLEGAL FNCTNION
	FNCTN	GAD		;1; GET CORE AT ADDRESS
	FNCTN	COR		;2; GET CORE FROM ANY ADDRESS
	FNCTN	RAD		;3; RETURN CORE AT ADDRESS
	FNCTN	GCH		;4; GET A CHANNEL
	FNCTN	RCH		;5; RETURN A CHANNEL
	FNCTN	GOT		;6;[251] GET CORE FROM OTS LIST
	FNCTN	ROT		;7;[251] RETURN CORE TO OTS LIST
	FNCTN	RNT		;10;[302] GET RUNTIME FROM OTS
	FNCTN	IFS		;11;[311] GET DEV:FILE[PPN] FROM OTS
	FNCTN	CBC		;12;[311] CUT BACK CORE
	FNCTN	RRS		;13;[571] READ ROUTINE STATUS (RESERVED FOR DBMS)
	FNCTN	WRS		;14;[571] WRITE ROUTINE STATUS (RESERVED FOR DBMS)
	>

	FUN.ZZ==0
	DEFINE FNCTN(A),<
	JRST	FUN'A		;DEFINE DISPATCH TO PROCESSING ROUTINE
	FUN.ZZ==FUN.ZZ+1	;COUNT NUMBER OF ENTRIES IN TABLE
	>

FUNDSP:	FUNDIR			;DEFINE DISPATCH TABLE
	SUBTTL	FUNCTION DISPATCH

	ENTRY	FUNCT%


;CALLS TO FUNCT. CONFORM TO THE DEC STANDARD CALLING SEQUENCE
;
;THE ARG LIST HAS THE GENERAL FORM
;
;		-ARG COUNT,,0
; ARGBLK:	TYPE,,[FUNCTION]
;		TYPE,,[ERROR CODE]
;		TYPE,,[STATUS]
;		TYPE,,[ARG1]
;		TYPE,,[ARG2]
;		TYPE,,[ARG3]
;

		DEFINE FUNBLK,<
		FUNARG	FUN,IND
		FUNARG	ERR,IND
		FUNARG	STS,IND
		FUNARG	RG1,IND
		FUNARG	RG2,IND
		FUNARG	RG3,IND
		>


		FUN.YY==0
		DEFINE FUNARG(A,B)<
		FN.'A==FUN.YY		;SET INDEX INTO ARGBLK
		FUN.YY==FUN.YY+1	;COUNT ENTRIES IN ARGBLK
		>

		FUNBLK			;DEFINE ARGBLK SYMBOLS
		PURGE	FUN.YY

	SIXBIT	/FUNCT./	;FOR TRACE
FUNCT%:	PUSHJ	P,SAVE.##	;SAVE REGISTERS
	MOVEI	T2,0		;LOCATE THE FUNCTION CODE
	PUSHJ	P,FUNADR	;LOCATE THE FUNCTION CODE
	SKIPL	G1,0(G1)	;LOAD THE ARGUMENT
	CAIL	G1,FUN.ZZ	;[311] IS THE FUNCTION DEFINED?
	MOVEI	G1,0		;DEFAULT TO ILLEGAL FUNCTION
	PUSHJ	P,@FUNDSP(G1)	;DISPATCH TO FUNCTION ROUTINE
	MOVEI	T2,FN.STS	;LOCATE STATUS ARGUMENT
	PUSHJ	P,FUNADR	;LOCATE STATUS ARGUMENT
	HRREM	P3,0(G1)	;STORE STATUS ARGUMENT
	POPJ	P,		;RETURN
	SUBTTL	FUNCTION ILL - ILLEGAL FUNCTION

;FUNCTION ILL - ILLEGAL FUNCTION
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARGBLK IS IGNORED
;ALWAYS RETURNS STATUS -1

FUNILL:	MOVEI	P3,-1		;SET ILLEGAL FUNCTION
	POPJ	P,		;RETURN TO USER
	SUBTTL	FUNCTION GAD - GET CORE AT SPECIFIED ADDRESS

;FUNCTION GAD - GET CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS TO ALLOCATE CORE AT
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 2:	CANNOT ALLOCATE AT SPECIFIED LOCATION
;STATUS 3:	ILLEGAL ARGUMENTS

FUNGAD:	PUSHJ	P,FUNRG1	;[506] LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD ADDRESS WANTED
	TLNE	P2,-1		;POSITIVE 18 BITS ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD SIZE WANTED
	TLNE	P3,-1		;POSITIVE 18 BITS ADDRESS
	JRST	FUNGAI		;[333] ILLEGAL ARGUMENT
FUNGAX:	ADDI	P3,-1(P2)	;COMPUTE LAST BLOCK ADR
	TLNE	P3,-1		;GREATER THAN 256 K
	PJRST	FUNST3		;ILLEGAL ARGUMENT
FUNGA5:				;P2 has start addr, P3 has end addr
    IFDEF FT$22,< ;In FUNGAR - Get core at particular address
	PUSHJ	P,LA1022	;GIVE SKIP RETURN IF IN 1022
	 JRST	N1022		;NOT IN 1022...SKIP THE REST
	CAIG	P3,(T1)		;LA1022 GIVES ".JBREL" IN T1, addr in T2
	 JRST	FUNDFM		;NO NEED TO ALLOCATE CORE
	MOVEI	T0,(P3)		;ALLOCATE BLOCK FROM AVAILABLE CORE
	SUBI	T0,-2(T1)	;DETERMINE THE NUMBER OF WORDS
				;TO ALLOCATE AND SUBTRACT 2 SO
				;THAT WE NEVER ALLOCATE THE EXACT
				;AMOUNT
	MOVE	T3,T1		;SAVE OLD ".JBFF"
	AOS	T3		;    ..
	PUSHJ	P,-3(T2)	;ALLOCATE CORE
	 JRST	FUNST3		;CAN'T...NONE AVAILABLE
	HRRZ	T4,FRE.DY(P4)	;GET DYNAMIC CORE POINTER
	JUMPN	T4,FA1022	;GO IF NOT FIRST TIME
	MOVEI	T4,-1(P2)	;GET HIGHEST ADDRESS WE DON'T WANT
	SUBI	T4,-1(T3)	;LENGTH TO GIVE BACK
	JUMPLE	T4,FA1022	;GIVE BACK ANY FREED CORE
	MOVE	T1,T3		;GET ".JBFF"
	HRLZM	T4,(T1)		;STORE LENGTH IN FIRST WORD
	ADDB	T4,T3		;ACCOUNT FOR IT
	AOS	T1		;POINT TO FIRST WORD
	MOVSS	FRE.DY(P4)	;POINT TO OTS LIST
	PUSH	P,T3		;SAVE ".JBFF"
	PUSHJ	P,PMEM%%	;RETURN CORE TO OTS LIST
	POP	P,T3		;RESTORE ".JBFF"
	MOVSS	FRE.DY(P4)	;    ..
FA1022:	PUSHJ	P,LA1022	;GET THE NEW ".JBREL"
	 JFCL			;(UNLIKELY THAT THIS WOULD HAPPEN)
	MOVE	T2,T1		;SAVE IT
	MOVE	T1,T3		;COMPUTE SIZE OF BLOCK ADDED
	SUBI	T2,-1(T1)	;    ..
	HRLZM	T2,(T1)		;STORE BLOCK SIZE
	JRST	X1022		;TO COMMON CODE

LA1022:	HLRE	T2,.JBCST##	;SEE IF A 1022 PROGRAM
	JUMPE	T2,P1022	;[JMS] No 1022 if location 136 is zero
	AOJE	T2,P1022	;-1 in LH means modified FOROTS but no HL1022
	PUSHJ	P,-2(T2)	;YES, LOAD ".JBREL"
	AOS	(P)		;AND SKIP RETURN
P1022:	POPJ	P,		;    ..
N1022:				;Here if HL1022.REL not loaded
    >  ;End of IFDEF FT$22
	MOVE	T1,.JBREL##	;[512] LOCATE LAST ASSIGNED ADR
	CAIG	P3,0(T1)	;[245] ALLOCATING PAST END OF CORE
	JRST	FUNDFM		;NO - DEFRAGMENT MEMORY
				;
	MOVEI	T1,0(P3)	;ALLOCATE BLOCK FROM AVAILABLE CORE
	CORE	T1,		;ALLOCATE BLOCK FROM AVAILABLE CORE
	  JRST	FUNST1		;[512] [333] NO CORE AVAILABLE
	MOVE	T1,.JBFF##	;LOCATE START OF BLOCK
	HRRZ	T2,FRE.DY(P4)	;[251] GET DYNAMIC CORE POINTER
	JUMPN	T2,FUNGA3	;[251] BRANCH IF NOT FIRST TIME
	MOVEI	T2,-1(P2)	;[251] HIGHEST ADDRESS WE DON'T WANT 
	SUBI	T2,-1(T1)	;[251] LENGTH TO GIVE BACK
	JUMPLE	T2,FUNGA4	;[274] ANY CORE TO RETURN?
	HRLZM	T2,0(T1)	;[251] STORE LENGTH IN FIRST WORD
	ADDB	T2,.JBFF	;[251] ACCOUNT FOR IT
	ADDI	T1,1		;[251] POINT PAST FIRST WORD
	PUSHJ	P,PMEM%%	;[251] RETURN CORE TO OTS LIST
FUNGA4:	MOVE	T1,.JBFF##	;[274] RESET START OF BLOCK
FUNGA3:	MOVE	T2,.JBREL##	;[251] LOCATE END OF CORE
	SUBI	T2,-1(T1)	;COMPUTE SIZE OF BLOCK ADDED
	HRLZM	T2,0(T1)	;STORE BLOCK SIZE
	ADDB	T2,.JBFF##	;OFFSET .JBFF
IFDEF FT$22,< X1022: >		;1022 returns to common code
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN SPACE ALLOCATED
FUNDFM:	MOVEI	T2,FRE.DY(P4)	;[511] LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
	JUMPE	T1,FMTZAP	;[512] CAN'T - MAYBE FORMAT IN WAY
FUNGA0:	HLRZ	P1,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	P1,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	CAIL	P2,0(T1)	;BELOW OR
	CAILE	P2,0(P1)	;ABOVE CURRENT BLOCK
	SKIPA	T2,0(T2)	;YES - ADVANCE LINK
	JRST	FUNGA1		;NO - CHECK IF WHOLE BLOCK IS CONTAINED
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNGA0	;CHECK IF IN NEXT BLOCK
	JRST	FMTZAP		;[512] CHECK FOR FORMAT IN WAY
FUNGA1:	CAILE	P3,0(P1)	;DOES BLOCK FIT IN BLOCK AVAILABLE
	JRST	FMTZAP		;[512] CHECK FOR FORMAT IN WAY
	HRRZ	T4,0(T1)	;SPACE FOUND
	HRRM	T4,0(T2)	;DELETE SPACE FROM CHAIN
	CAIN	P2,0(T1)	;EXTRA SPACE IN FRONT OF BLOCK?
	JRST	FUNGA2		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P2)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(T1)	;COMPUTE SPACE RETURNED
	HRLZM	T0,0(T1)	;SET BLOCK SIZE
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN EXTRA AT BEGINNING
FUNGA2:	CAIN	P3,0(P1)	;EXTRA SPACE AFTER BLOCK
	JRST	FUNALC		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P1)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(P3)	;COMPUTE SPACE RETURNED
	HRLZM	T0,1(P3)	;SET BLOCK SIZE
	MOVEI	T1,2(P3)	;SET BLOCK ADR
	PUSHJ	P,PMEM%%##	;RETURN EXTRRA SPACE
				;
FUNALC:	HRLI	T1,0(P2)	;SET UP BLT POINTER
	HRRI	T1,1(P2)	;TO CLEAR ALLOCATED BLOCK
	SETZM	0(P2)		;CLEAR FIRST WORD
	BLT	T1,0(P3)	;CLEAR ALLOCATED CORE
FUNST0:	TDZA	P3,P3		;SET STATUS 0
FUNST2:	MOVEI	P3,2		;SET STATUS 2
	POPJ	P,		;RETURN TO USER


FMTZAP:	HRRZ	T1,FMT.DY(P4)	;[512] GET ADDR OF FORMAT LIST
	JUMPE	T1,FUNST2	;[512] IF NONE, USER IS OUT OF LUCK
	HLLZS	FMT.DY(P4)	;[512] MARK FORMAT LIST GONE
	ADDI	T1,1		;[512] OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%	;[512] DELETE THEM ALL
	JRST	FUNGA5		;[512] NO RE-TRY THE ALLOCATION
;HERE IF SIZE IS ILLEGAL

REPEAT	0,<			;[506] THIS HACK NO LONGER NEEDED

;IF IT IS FIRST CALL ALLOCATE ALL OF FREE SPACE ABOVE ADDRESS
;OTHERWISE GIVE ERROR RETURN

FUNGAI:	HRRZ	T1,FRE.DY(P4)	;[333] GET FREE CORE POINTER
	JUMPN	T1,FUNGA3	;[333] NOT FIRST TIME
	MOVEI	P3,100		;[333] A RANDOM NUMBER
	MOVEM	P3,0(G1)	;[333] SET ARGUMENT BACK FOR USER
	CAML	P2,.JBREL##	;[333] IS BASE IN CORE?
	JRST	FUNGAX		;[333] NO, EXPAND AS BEFORE
	MOVE	P3,.JBREL##	;[333] HIGHEST ADDRESS WE NEED
	MOVE	T1,P3		;[333] BUT MUST CALCULATE LENGTH
	SUBI	T1,-1(P2)	;[333] THAT WE WILL ALLOCATE
	MOVEM	T1,0(G1)	;[333] AND STORE FOR USER
	MOVSS	FRE.DY(P4)	;[333] SWAP BACK TO GET SPACE FROM OTS
	PUSHJ	P,FUNDFM	;[333] GET THE TOP OF CORE
	MOVSS	FRE.DY(P4)	;[333] FUNDFM SWAPPED IT
	POPJ	P,		;[333] RETURN

>	;[506] END REPEAT 0


FUNGAI:	AOJN	P3,FUNST3	;[506] JUST PLAIN ILLEGAL UNLESS -1
	MOVEI	P3,10		;[506] BE COMPATIBLE WITH OLD OVRLAY
	MOVEM	P3,(G1)		;[506] BY JUST ALLOCATING 10 WORDS
	JRST	FUNGAX		;[506] VIA THE STANDARD ENTRY POINT
	SUBTTL	FUNCTION COR - GET CORE AT ANY ADDRESS

;FUNCTION COR - GET CORE FROM ANY ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT

FUNCOR:	PUSHJ	P,FUNRG2	;[506] [251] LOCATE SECOND ARGUMENT
	SKIPLE	T1,0(G1)	;LOAD SIZE OF BLOCK
	TLNE	T1,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T0,-1(T1)	;GMEM%% ADDS A WORD
	SKIPN	T0		;[477] USER REQUEST ONE WORD?
	MOVEI	T0,1		;[477] YES, GIVE HIM 2
	PUSH	P,ACC.SV+T0(P4)	;[514] CAN BE DESTROYED BY ALCOR%
	PUSHJ	P,FMEM%%##	;[650][514] CALL GMEM%%, T1=-1 IF ERROR
	POP	P,ACC.SV+T0(P4)	;[514] RESTORE USER'S AC 0
	JUMPL	T1,FUNST1	;[514] GIVE ERROR IF NONE AVAILABLE
	MOVEI	P3,-1(T1)	;REMOVE FOROTS
	SETZM	0(P3)		;CONTROL WORD
	PUSHJ	P,FUNRG1	;LOCATE FIRST ARGUMENT
	HRRZM	P3,0(G1)	;STORE ADR OF BLOCK
	PJRST	FUNST0		;SET STATUS 0 AND RETURN

FUNST1:	SKIPA	P3,FUNCO0	;SET STATUS 1
FUNST3:	MOVEI	P3,3		;SET STATUS 3
FUNCO0:	POPJ	P,1		;RETURN
	SUBTTL	FUNCTION RAD - RETURN CORE AT ADDRESS

;FUNCTION RAD - RETURN CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT

FUNRAD:	PUSHJ	P,FUNRG1	;[506] [251] LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD CORE ADR
	TLNE	P2,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD CORE SIZE
	TLNE	P3,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	CAIN	P3,1		;[477] RETURNING 1 WORD?
	MOVEI	P3,2		;[477] YES, WE GAVE HIM 2
    IFDEF FT$22,<
	PUSHJ	P,LA1022	;LOAD T1 WITH ".JBREL" IF 1022
    >
	 HRRZ	T1,.JBREL##	;LOAD LAST LEGAL ADR
	ADDI	P3,-1(P2)	;COMPUTE LAST ADR IN BLOCK
	TLNN	P3,-1		;POSITIVE 18 BIT ADDRESS
	CAILE	P3,0(T1)	;LEGAL ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T2,FRE.DY(P4)	;LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
	JUMPE	T1,FUNRA4	;NO - VALID DEALLOCATION
FUNRA3:	HLRZ	T3,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	T3,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	MOVSI	T4,(CAIGE P3,0(T1))	;FREE BLOCK STARTS FIRST
	CAIL	P2,0(T1)		;WHICH BLOCK STARTS FIRST
	MOVSI	T4,(CAILE P2,0(T3))	;TEST BLOCK STARTS FIRST
	XCT	T4		;DO BLOCKS OVERLAP
	SKIPA	T2,0(T2)	;NO - TEST NEXT BLOCK
	PJRST	FUNST1		;SET STATUS 1 AND RETURN
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNRA3	;TEST ALL BLOCKS
FUNRA4:	MOVE	P3,0(G1)	;RELOAD CORE SIZE
	CAIN	P3,1		;[477] GIVING BACK 1 WORD?
	MOVEI	P3,2		;[477] YES, HE REALLY MEANT 2
	HRLZM	P3,0(P2)	;BUILD FOROTS CONTROL WORD
	MOVEI	T1,1(P2)	;BUILD BLOCK POINTER
	PUSHJ	P,PMEM%%##	;RETURN CORE BLOCK
				;CLEAR ENCODED FORMATS IN BLOCK
	ADDI	P3,-1(P2)	;LOCATE END OF BLOCK
	MOVEI	P1,FMT.DY(P4)	;LOCATE LIST OF ENCODED FORMATS
FUNRA0:	HRRZ	T1,0(P1)	;LOCATE FORMAT POINTED TO BY LINK AT P1
					;[245] AT END LIST
	JUMPE	T1,FUNGC0	;[511] [245] SET STATUS 0 AND RETURN
	HRRZ	T2,1(T1)	;LOAD FORMAT ADR
	CAIL	T2,0(P2)	;BELOW OR
	CAILE	T2,0(P3)	;ABOVE DELETED BLOCK
	JRST	FUNRA2		;YES - RETAIN ENCODING
				;DELETE ENCODING
	MOVE	T2,0(T1)	;LOAD LINK WORD
	HRRM	T2,0(P1)	;LINK OVER THIS BLOCK
	ADDI	T1,1		;SET POINTER FOR PMEM%%
	HLLZS	-1(T1)		;CLEAR POINTER
	PUSHJ	P,PMEM%%##	;RETURN ENCODED LIST
	JRST	FUNRA0		;CHECK NEXT ENCODING
				;
FUNRA2:	HRRZ	P1,0(P1)	;FIND NEXT ENCODING
	JRST	FUNRA0		;REPEAT FOR NEXT ENCODING
	SUBTTL	FUNCTION GCH - GET AN I/O CHANNEL

;FUNCTION GCH - GET AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # ALLOCATED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL ALLOCATED
;STATUS 1:	NO CHANNELS AVAILABLE

FUNGCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	JSP	P1,GT.CHN##	;[265] GET A CHANNEL
	  JRST	FUNGC1		;NO CHANNELS AVAILABLE
	HRRZM	T1,0(G1)	;STORE CHANNEL #
	ADDI	T1,CHN.TB(P4)	;POINT TO THE CHANNEL TABLE
	SETOM	0(T1)		;SET CHANNEL IN USE
FUNGC0:	TDZA	P3,P3		;SET STATUS 0
FUNGC1:	MOVEI	P3,1		;SET STATUS 1
	POPJ	P,		;RETURN
	SUBTTL	FUNCTION RCH - RETURN AN I/O CHANNEL
;FUNCTION RCH - RETURN AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # TO BE RETURNED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL RETURNED
;STATUS 1:	INVALID OR NON-USER CHANNEL

FUNRCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	SKIPLE	T1,(G1)		;LOAD CHANNEL #
	CAILE	T1,17		;MUST BE BETWEEN 0 AND 20
	PJRST	FUNGC1		;CANNOT RETURN
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO CHANNEL TABLE
	SETCM	T0,0(T1)	;USER CHANNEL
	JUMPN	T0,FUNGC1	;NO - CANNOT RETURN
	SETZB	P3,0(T1)	;CLEAR CHANNEL TABLE
	POPJ	P,		;SET STATUS 0 AND RETURN
	SUBTTL	FUNCTION GOT - GET CORE FROM OTS LIST

;FUNCTION GOT - GET CORE FROM OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT


	FUNGOT==FUNCOR		;[506] USE COR FUNCTION
	SUBTTL	FUNCTION ROT  - RETURN CORE TO OTS LIST

;FUNCTION ROT - RETURN CORE TO OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT


	FUNROT==FUNRAD		;[506] USE RAD FUNCTION
	SUBTTL	FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS

;FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	RUNTIME FROM OTS
;ARG2:	IGNORED
;
;STATUS 0:	RUNTIME RETURNED
;STATUS 1:	RUNTIME NOT AVAILABLE

FUNRNT:	PUSHJ	P,FUNRG1	;[302] LOCATE FIRST ARGUMENT
	MOVE	T1,RUN.TM(P4)	;[302] GET RUNTIME FROM OTS
	MOVEM	T1,0(G1)	;[302] STORE
	PJRST	FUNGC0		;[302] OK RETURN
	SUBTTL	FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS

;FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	DEVICE
;ARG2:	FILE NAME
;ARG3:	[PPN]
;
;STATUS 0:	OK
;STATUS 1:	ERROR

FUNIFS:	PUSHJ	P,FUNRG1	;[311] LOCATE FIRST ARGUMENT
	MOVE	T1,REGS.2(P4)	 ;[311] GET DEVICE
	MOVEM	T1,0(G1)	;[311] STORE
	PUSHJ	P,FUNRG2	;[311] LOCATE SECOND ARGUMENT
	MOVE	T1,REGS.0(P4)	;[311] FILE NAME
	MOVEM	T1,0(G1)	;[311] STORE
	MOVEI	T2,FN.RG3	;[311] LOCATE THIRD ARGUMENT
	PUSHJ	P,FUNADR	;[311]
	MOVE	T1,REGS.1(P4)	;[311] PPN
	MOVEM	T1,0(G1)	;[311] STORE
	PJRST	FUNGC0		;[311] OK RETURN
	SUBTTL	FUNCTION CBC - CUT BACK CORE IF POSSIBLE

;FUNCTION CBC - CUT BACK CORE IF POSSIBLE
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;
;STATUS 0:	ALWAYS

FUNCBC:	PUSHJ	P,DMEM%%##	;[311] DEFRAGMENT CORE
	MOVEI	T3,FRE.DY(P4)	;[311] GET FREE CORE LIST
	MOVE	T2,T3		;[311] PREVIOUS ALSO
    IFDEF FT$22,< ;At FUNCBC+3, Cut Back Core
	HRRZ	T4,.JBREL##	;LOAD WITH .JBREL
	PUSHJ	P,LA1022	;OR LOAD WITH 1022'S ".JBREL"
	 CAIA			;HL1022.REL not loaded, use .JBREL
	MOVE	T4,T1		;Use 1022's JOBREL
    >  ;End of IFDEF FT$22
FUNCB0:	JUMPE	T3,FUNST0	;[311] GIVE IT IF NO FORWARD LINK
	MOVE	T1,T2		;[311] PUT PREVIOUS PREVIOUS IN T1
	MOVE	T2,T3		;[311] PUT PREVIOUS IN T2
	HRRZ	T3,(T2)		;[311] ANY LEFT
	HLRZ	P1,(T2)		;[311] GET SIZE
	CAIGE	P1,1000		;[311] DON'T WASTE TIME IF LESS THAN A PAGE
	JRST	FUNCB0		;[311][446] SINCE WE CANNOT REDUCE BY LESS
	ADDI	P1,-1(T2)	;[311] FIND END
    IFDEF FT$22,<
	CAME	P1,T4		;LESS THAN TOP?
    >
    IFNDEF FT$22,<
	CAME	P1,.JBREL##	;[311] LESS THAN TOP?
    >
	JRST	FUNCB0		;[311] YES, IGNORE THIS BLOCK
	MOVEI	P1,-1(T2)	;[311] LAST WORD WE NEED
    IFDEF FT$22,<
	HLRE	T3,.JBCST##	;SEE IF 1022
	JUMPE	T3,NO1022	;[JMS] No 1022 if location 136 is zero
	AOJE	T3,NO1022	;NOT 1022
	HLLZS	(T1)		;CLEAR FORWARD POINTER NOW
	MOVEI	T0,-1(T2)	;DETERMINE NUMBER OF WORDS TO
	SUBI	T0,(T4)		;DEALLOCATE
	PUSHJ	P,-3(T3)	;DEALLOCATE CORE
	 JFCL			;(SHOULDN'T NOT BE ABLE TO)
	PJRST	FUNST0		;RETURN
NO1022:  >  ;End of IFDEF FT$22
	CORE	P1,		;[311]
	  JRST	FUNST0		;[311] NO CHANGE IF WE FAILED
	CAMLE	T2,.JBREL##	;[311] INCASE WE GAVE IT ALL AWAY
	JRST	FUNCB1		;[311] JUST CLEAR PREVIOUS
	MOVE	P1,.JBREL	;[311] TOP OF CORE
	SUBI	P1,-1(T2)	;[333] - START
	HRLM	P1,(T2)		;[311] NEW LENGTH
	JRST	FUNCB311] SETUP .JBFF

FUNCB1:	HLLZS	(T1)		;[311] CLEAR FORWARD POINTER
FUNCB2:	MOVE	P1,.JBREL	;[311] GET TOP OF CORE
	ADDI	P1,1		;[311] MAKE SURE OUT OF BOUNDS
	MOVEM	P1,.JBFF	;[311]
	PJRST	FUNST0		;[311] OK RETURN
	SUBTTL	RRS & WRS - READ/WRITE ROUTINE STATUS (RESERVED FOR DBMS) [571]

;FUNCTION RRS - READ ROUTINE STATUS
;         WRS - WRITE ROUTINE STATUS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	GETS SET TO 0
;
;STATUS 0:	ALWAYS

FUNRRS:					;[571]
FUNWRS:					;[571]
	PUSHJ	P,FUNRG1		;[571] GET FIRST ARGUMENT
	SETZM	0,0(G1)			;[571] SET FIRST ARG TO 0
	PJRST	FUNGC0			;[571] 0 STATUS & EXIT

	SUBTTL	ARGBLK MANIPULATION ROUTINES

;FUNADR - RETURN ADR OF ARGUMENT
;CALL:	MOVEI	T2,OFFSET IN ARGBLK
;	PUSHJ	P,FUNADR
;	(RETURN)
;
; RETURN ADR IN G1
; CLOBBERS P1, AND T1
;
FUNRG2:	SKIPA	T2,FUNAD1	;LOAD ARG2 OFFSET
FUNRG1:	MOVEI	T2,FN.RG1	;LOAD ARG1 OFFSET
FUNADR:	ADDI	L,0(T2)		;OFFSET ARGBLK
	JSP	P1,EFCTV.##	;[265] COMPUTE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES - RELOCATE TO AC SAVE AREA
	SUBI	L,0(T2)		;RESET ARGBLK
FUNAD1:	POPJ	P,FN.RG2	;RETURN

	END
+.j[0