	TITLE	FORFUN	%5A(650) - OVERLAY FUNCTION MODULE FOR FOROTS
	SUBTTL	H. P. WEISS/HPW/DMN/MD/DPL/JNG/SJW/SWG	21-MAR-77




;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

;COPYRIGHT (C) 1973,1977 BY DIGITAL EQUIPMENT CORPORATION

VERWHO==0	;EDITOR
VERVER==05	;MAJOR VERSION NUMBER
VERUPD==0	;MINOR VERSION NUMBER
VEREDT==650	;EDIT NUMBER

VERFUN==BYTE (3)VERWHO(9)VERVER(6)VERUPD(18)VEREDT

PURGE	VERWHO,VERVER,VERUPD,VEREDT



	SUBTTL	REVISION HISTORY

;446	15993	FIX CBC FUNCTION SO IT WILL CUT BACK CORE PROPERLY
;		FOR LINK OVERLAY'S
;477	17759	ALWAYS REQUEST AT LEAST ONE WORD FROM GMEM%%
;506	17107	DELETE OVERLAY HANDLER'S FREE CORE LIST. HAVING ONLY
;		ONE LIST DOES NO HARM IF THE /SPACE DOES NOT OVERFLOW,
;		AND IS BENEFICIAL IN MOST CASES IF IT DOES.
;511	17107	DELETE ALL DMEM%% CALLS. THEY ARE USELESS AND WASTE TIME
;512	17107	IF GAD FAILS, DELETE FORMAT BLOCKS & RETRY.
;514	18030	CHANGE GMEM%% CALL SO CAN RETURN ERROR CODE INSTEAD
;		OF BOMBING WITH %FRSSYS NO CORE AVAILABLE MESSAGE.
;	*****	BEGIN VERSION 5
;571	-----	ADD FUNCTIONS RRS & WRS: RESERVED FOR DBMS
;650	-----	CHANGE REFERENCE TO ALCOR1 IN FOROTS TO FMEM%%
;****************	END OF REVISION HISTORY

	PAGE
	SUBTTL	DEFINE SYMBOLS
SEARCH	FORPRM		;GLOBAL SYMBOLS DEFINED IN FORPRM

SEGMEN

	DEFINE FUNDIR,<
	FNCTN	ILL		;0; ILLEGAL FNCTNION
	FNCTN	GAD		;1; GET CORE AT ADDRESS
	FNCTN	COR		;2; GET CORE FROM ANY ADDRESS
	FNCTN	RAD		;3; RETURN CORE AT ADDRESS
	FNCTN	GCH		;4; GET A CHANNEL
	FNCTN	RCH		;5; RETURN A CHANNEL
	FNCTN	GOT		;6;[251] GET CORE FROM OTS LIST
	FNCTN	ROT		;7;[251] RETURN CORE TO OTS LIST
	FNCTN	RNT		;10;[302] GET RUNTIME FROM OTS
	FNCTN	IFS		;11;[311] GET DEV:FILE[PPN] FROM OTS
	FNCTN	CBC		;12;[311] CUT BACK CORE
	FNCTN	RRS		;13;[571] READ ROUTINE STATUS (RESERVED FOR DBMS)
	FNCTN	WRS		;14;[571] WRITE ROUTINE STATUS (RESERVED FOR DBMS)
	>

	FUN.ZZ==0
	DEFINE FNCTN(A),<
	JRST	FUN'A		;DEFINE DISPATCH TO PROCESSING ROUTINE
	FUN.ZZ==FUN.ZZ+1	;COUNT NUMBER OF ENTRIES IN TABLE
	>

FUNDSP:	FUNDIR			;DEFINE DISPATCH TABLE
	PAGE
	SUBTTL	FUNCTION DISPATCH

	ENTRY	FUNCT%


;CALLS TO FUNCT. CONFORM TO THE DEC STANDARD CALLING SEQUENCE
;
;THE ARG LIST HAS THE GENERAL FORM
;
;		-ARG COUNT,,0
; ARGBLK:	TYPE,,[FUNCTION]
;		TYPE,,[ERROR CODE]
;		TYPE,,[STATUS]
;		TYPE,,[ARG1]
;		TYPE,,[ARG2]
;		TYPE,,[ARG3]
;

		DEFINE FUNBLK,<
		FUNARG	FUN,IND
		FUNARG	ERR,IND
		FUNARG	STS,IND
		FUNARG	RG1,IND
		FUNARG	RG2,IND
		FUNARG	RG3,IND
		>


		FUN.YY==0
		DEFINE FUNARG(A,B)<
		FN.'A==FUN.YY		;SET INDEX INTO ARGBLK
		FUN.YY==FUN.YY+1	;COUNT ENTRIES IN ARGBLK
		>

		FUNBLK			;DEFINE ARGBLK SYMBOLS
		PURGE	FUN.YY

	SIXBIT	/FUNCT./	;FOR TRACE
FUNCT%:	PUSHJ	P,SAVE.##	;SAVE REGISTERS
	MOVEI	T2,0		;LOCATE THE FUNCTION CODE
	PUSHJ	P,FUNADR	;LOCATE THE FUNCTION CODE
	SKIPL	G1,0(G1)	;LOAD THE ARGUMENT
	CAIL	G1,FUN.ZZ	;[311] IS THE FUNCTION DEFINED?
	MOVEI	G1,0		;DEFAULT TO ILLEGAL FUNCTION
	PUSHJ	P,@FUNDSP(G1)	;DISPATCH TO FUNCTION ROUTINE
	MOVEI	T2,FN.STS	;LOCATE STATUS ARGUMENT
	PUSHJ	P,FUNADR	;LOCATE STATUS ARGUMENT
	HRREM	P3,0(G1)	;STORE STATUS ARGUMENT
	POPJ	P,		;RETURN
	PAGE
	SUBTTL	FUNCTION ILL - ILLEGAL FUNCTION

;FUNCTION ILL - ILLEGAL FUNCTION
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARGBLK IS IGNORED
;ALWAYS RETURNS STATUS -1

FUNILL:	MOVEI	P3,-1		;SET ILLEGAL FUNCTION
	POPJ	P,		;RETURN TO USER
	PAGE
	SUBTTL	FUNCTION GAD - GET CORE AT SPECIFIED ADDRESS

;FUNCTION GAD - GET CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS TO ALLOCATE CORE AT
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 2:	CANNOT ALLOCATE AT SPECIFIED LOCATION
;STATUS 3:	ILLEGAL ARGUMENTS

;**;[506] Delete @ FUNGAD	JNG	3-Dec-75
FUNGAD:	PUSHJ	P,FUNRG1	;[506] LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD ADDRESS WANTED
	TLNE	P2,-1		;POSITIVE 18 BITS ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD SIZE WANTED
	TLNE	P3,-1		;POSITIVE 18 BITS ADDRESS
	JRST	FUNGAI		;[333] ILLEGAL ARGUMENT
FUNGAX:	ADDI	P3,-1(P2)	;COMPUTE LAST BLOCK ADR
	TLNE	P3,-1		;GREATER THAN 256 K
	PJRST	FUNST3		;ILLEGAL ARGUMENT
;**;[512] Insert label @ FUNGAX+3L	JNG	8-Dec-75
FUNGA5:	MOVE	T1,.JBREL##	;[512] LOCATE LAST ASSIGNED ADR
	CAIG	P3,0(T1)	;[245] ALLOCATING PAST END OF CORE
	JRST	FUNDFM		;NO - DEFRAGMENT MEMORY
				;
	MOVEI	T1,0(P3)	;ALLOCATE BLOCK FROM AVAILABLE CORE
	CORE	T1,		;ALLOCATE BLOCK FROM AVAILABLE CORE
;**;[512] Change @ FUNGAX+9L	JNG	8-Dec-75
	  JRST	FUNST1		;[512] [333] NO CORE AVAILABLE
	MOVE	T1,.JBFF##	;LOCATE START OF BLOCK
	HRRZ	T2,FRE.DY(P4)	;[251] GET DYNAMIC CORE POINTER
	JUMPN	T2,FUNGA3	;[251] BRANCH IF NOT FIRST TIME
	MOVEI	T2,-1(P2)	;[251] HIGHEST ADDRESS WE DON'T WANT 
	SUBI	T2,-1(T1)	;[251] LENGTH TO GIVE BACK
	JUMPLE	T2,FUNGA4	;[274] ANY CORE TO RETURN?
	HRLZM	T2,0(T1)	;[251] STORE LENGTH IN FIRST WORD
	ADDB	T2,.JBFF	;[251] ACCOUNT FOR IT
	ADDI	T1,1		;[251] POINT PAST FIRST WORD
;**;[506] Delete @ FUNGAX+19L	JNG	3-Dec-75
	PUSHJ	P,PMEM%%	;[251] RETURN CORE TO OTS LIST
FUNGA4:	MOVE	T1,.JBFF##	;[274] RESET START OF BLOCK
FUNGA3:	MOVE	T2,.JBREL##	;[251] LOCATE END OF CORE
	SUBI	T2,-1(T1)	;COMPUTE SIZE OF BLOCK ADDED
	HRLZM	T2,0(T1)	;STORE BLOCK SIZE
	ADDB	T2,.JBFF##	;OFFSET .JBFF
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN SPACE ALLOCATED
;**;[511] Delete @ FUNDFM	JNG	8-Dec-75
FUNDFM:	MOVEI	T2,FRE.DY(P4)	;[511] LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
;**;[512] Change @ FUNDFM+4L	JNG	8-Dec-75
	JUMPE	T1,FMTZAP	;[512] CAN'T - MAYBE FORMAT IN WAY
FUNGA0:	HLRZ	P1,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	P1,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	CAIL	P2,0(T1)	;BELOW OR
	CAILE	P2,0(P1)	;ABOVE CURRENT BLOCK
	SKIPA	T2,0(T2)	;YES - ADVANCE LINK
	JRST	FUNGA1		;NO - CHECK IF WHOLE BLOCK IS CONTAINED
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNGA0	;CHECK IF IN NEXT BLOCK
;**;[512] Change @ FUNGA0+8L	JNG	8-Dec-75
	JRST	FMTZAP		;[512] CHECK FOR FORMAT IN WAY
FUNGA1:	CAILE	P3,0(P1)	;DOES BLOCK FIT IN BLOCK AVAILABLE
	JRST	FMTZAP		;[512] CHECK FOR FORMAT IN WAY
	HRRZ	T4,0(T1)	;SPACE FOUND
	HRRM	T4,0(T2)	;DELETE SPACE FROM CHAIN
	CAIN	P2,0(T1)	;EXTRA SPACE IN FRONT OF BLOCK?
	JRST	FUNGA2		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P2)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(T1)	;COMPUTE SPACE RETURNED
	HRLZM	T0,0(T1)	;SET BLOCK SIZE
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN EXTRA AT BEGINNING
FUNGA2:	CAIN	P3,0(P1)	;EXTRA SPACE AFTER BLOCK
	JRST	FUNALC		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P1)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(P3)	;COMPUTE SPACE RETURNED
	HRLZM	T0,1(P3)	;SET BLOCK SIZE
	MOVEI	T1,2(P3)	;SET BLOCK ADR
	PUSHJ	P,PMEM%%##	;RETURN EXTRRA SPACE
				;
FUNALC:	HRLI	T1,0(P2)	;SET UP BLT POINTER
	HRRI	T1,1(P2)	;TO CLEAR ALLOCATED BLOCK
	SETZM	0(P2)		;CLEAR FIRST WORD
	BLT	T1,0(P3)	;CLEAR ALLOCATED CORE
FUNST0:	TDZA	P3,P3		;SET STATUS 0
FUNST2:	MOVEI	P3,2		;SET STATUS 2
;**;[506] Delete @ FUNST2+1L	JNG	3-Dec-75
	POPJ	P,		;RETURN TO USER


;**;[512] Insert @ FUNST2+3L	JNG	12-Dec-75
FMTZAP:	HRRZ	T1,FMT.DY(P4)	;[512] GET ADDR OF FORMAT LIST
	JUMPE	T1,FUNST2	;[512] IF NONE, USER IS OUT OF LUCK
	HLLZS	FMT.DY(P4)	;[512] MARK FORMAT LIST GONE
	ADDI	T1,1		;[512] OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%	;[512] DELETE THEM ALL
	JRST	FUNGA5		;[512] NO RE-TRY THE ALLOCATION
;HERE IF SIZE IS ILLEGAL

REPEAT	0,<			;[506] THIS HACK NO LONGER NEEDED

;IF IT IS FIRST CALL ALLOCATE ALL OF FREE SPACE ABOVE ADDRESS
;OTHERWISE GIVE ERROR RETURN

FUNGAI:	HRRZ	T1,FRE.DY(P4)	;[333] GET FREE CORE POINTER
	JUMPN	T1,FUNGA3	;[333] NOT FIRST TIME
	MOVEI	P3,100		;[333] A RANDOM NUMBER
	MOVEM	P3,0(G1)	;[333] SET ARGUMENT BACK FOR USER
	CAML	P2,.JBREL##	;[333] IS BASE IN CORE?
	JRST	FUNGAX		;[333] NO, EXPAND AS BEFORE
	MOVE	P3,.JBREL##	;[333] HIGHEST ADDRESS WE NEED
	MOVE	T1,P3		;[333] BUT MUST CALCULATE LENGTH
	SUBI	T1,-1(P2)	;[333] THAT WE WILL ALLOCATE
	MOVEM	T1,0(G1)	;[333] AND STORE FOR USER
	MOVSS	FRE.DY(P4)	;[333] SWAP BACK TO GET SPACE FROM OTS
	PUSHJ	P,FUNDFM	;[333] GET THE TOP OF CORE
	MOVSS	FRE.DY(P4)	;[333] FUNDFM SWAPPED IT
	POPJ	P,		;[333] RETURN

>	;[506] END REPEAT 0


;**;[506] Insert @ FUNGAI+15L	JNG	3-Dec-75
FUNGAI:	AOJN	P3,FUNST3	;[506] JUST PLAIN ILLEGAL UNLESS -1
	MOVEI	P3,10		;[506] BE COMPATIBLE WITH OLD OVRLAY
	MOVEM	P3,(G1)		;[506] BY JUST ALLOCATING 10 WORDS
	JRST	FUNGAX		;[506] VIA THE STANDARD ENTRY POINT
	PAGE
	SUBTTL	FUNCTION COR - GET CORE AT ANY ADDRESS

;FUNCTION COR - GET CORE FROM ANY ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT

;**;[506] Delete @ FUNCOR	JNG	3-Dec-75
FUNCOR:	PUSHJ	P,FUNRG2	;[506] [251] LOCATE SECOND ARGUMENT
	SKIPLE	T1,0(G1)	;LOAD SIZE OF BLOCK
	TLNE	T1,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T0,-1(T1)	;GMEM%% ADDS A WORD
;**;[477] Insert @ FUNCR1+6L	JNG	22-Nov-75
	SKIPN	T0		;[477] USER REQUEST ONE WORD?
	MOVEI	T0,1		;[477] YES, GIVE HIM 2
;**;[514] Replace @ FUNCOR+7L	JNG	11-Feb-76
	PUSH	P,ACC.SV+T0(P4)	;[514] CAN BE DESTROYED BY ALCOR%
;**; [650]	CHANGE AT FUNCOR+9L	SWG	21-MAR-77
	PUSHJ	P,FMEM%%##	;[650][514] CALL GMEM%%, T1=-1 IF ERROR
	POP	P,ACC.SV+T0(P4)	;[514] RESTORE USER'S AC 0
	JUMPL	T1,FUNST1	;[514] GIVE ERROR IF NONE AVAILABLE
	MOVEI	P3,-1(T1)	;REMOVE FOROTS
	SETZM	0(P3)		;CONTROL WORD
	PUSHJ	P,FUNRG1	;LOCATE FIRST ARGUMENT
	HRRZM	P3,0(G1)	;STORE ADR OF BLOCK
	PJRST	FUNST0		;SET STATUS 0 AND RETURN

FUNST1:	SKIPA	P3,FUNCO0	;SET STATUS 1
FUNST3:	MOVEI	P3,3		;SET STATUS 3
;**;[506] Delete @ FUNST3+1L	JNG	3-Dec-75
FUNCO0:	POPJ	P,1		;RETURN
	PAGE
	SUBTTL	FUNCTION RAD - RETURN CORE AT ADDRESS

;FUNCTION RAD - RETURN CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT

;**;[506] Delete @ FUNRAD	JNG	3-Dec-75
FUNRAD:	PUSHJ	P,FUNRG1	;[506] [251] LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD CORE ADR
	TLNE	P2,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD CORE SIZE
	TLNE	P3,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
;**;[477] Insert @ FUNRA1+9L	JNG	22-Nov-75
	CAIN	P3,1		;[477] RETURNING 1 WORD?
	MOVEI	P3,2		;[477] YES, WE GAVE HIM 2
	HRRZ	T1,.JBREL##	;LOAD LAST LEGAL ADR
	ADDI	P3,-1(P2)	;COMPUTE LAST ADR IN BLOCK
	TLNN	P3,-1		;POSITIVE 18 BIT ADDRESS
	CAILE	P3,0(T1)	;LEGAL ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T2,FRE.DY(P4)	;LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
	JUMPE	T1,FUNRA4	;NO - VALID DEALLOCATION
FUNRA3:	HLRZ	T3,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	T3,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	MOVSI	T4,(CAIGE P3,0(T1))	;FREE BLOCK STARTS FIRST
	CAIL	P2,0(T1)		;WHICH BLOCK STARTS FIRST
	MOVSI	T4,(CAILE P2,0(T3))	;TEST BLOCK STARTS FIRST
	XCT	T4		;DO BLOCKS OVERLAP
	SKIPA	T2,0(T2)	;NO - TEST NEXT BLOCK
	PJRST	FUNST1		;SET STATUS 1 AND RETURN
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNRA3	;TEST ALL BLOCKS
FUNRA4:	MOVE	P3,0(G1)	;RELOAD CORE SIZE
;**;[477] Insert @ FUNRA4+1L	JNG	22-Nov-75
	CAIN	P3,1		;[477] GIVING BACK 1 WORD?
	MOVEI	P3,2		;[477] YES, HE REALLY MEANT 2
	HRLZM	P3,0(P2)	;BUILD FOROTS CONTROL WORD
	MOVEI	T1,1(P2)	;BUILD BLOCK POINTER
	PUSHJ	P,PMEM%%##	;RETURN CORE BLOCK
				;CLEAR ENCODED FORMATS IN BLOCK
	ADDI	P3,-1(P2)	;LOCATE END OF BLOCK
	MOVEI	P1,FMT.DY(P4)	;LOCATE LIST OF ENCODED FORMATS
;**;[506] Delete @ FUNRA4+8L	JNG	3-Dec-75
FUNRA0:	HRRZ	T1,0(P1)	;LOCATE FORMAT POINTED TO BY LINK AT P1
					;[245] AT END LIST
;**;[511] Change @ FUNRA0+2L	JNG	8-Dec-75
	JUMPE	T1,FUNGC0	;[511] [245] SET STATUS 0 AND RETURN
	HRRZ	T2,1(T1)	;LOAD FORMAT ADR
	CAIL	T2,0(P2)	;BELOW OR
	CAILE	T2,0(P3)	;ABOVE DELETED BLOCK
	JRST	FUNRA2		;YES - RETAIN ENCODING
				;DELETE ENCODING
	MOVE	T2,0(T1)	;LOAD LINK WORD
	HRRM	T2,0(P1)	;LINK OVER THIS BLOCK
	ADDI	T1,1		;SET POINTER FOR PMEM%%
	HLLZS	-1(T1)		;CLEAR POINTER
	PUSHJ	P,PMEM%%##	;RETURN ENCODED LIST
	JRST	FUNRA0		;CHECK NEXT ENCODING
				;
FUNRA2:	HRRZ	P1,0(P1)	;FIND NEXT ENCODING
	JRST	FUNRA0		;REPEAT FOR NEXT ENCODING
	PAGE
	SUBTTL	FUNCTION GCH - GET AN I/O CHANNEL

;FUNCTION GCH - GET AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # ALLOCATED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL ALLOCATED
;STATUS 1:	NO CHANNELS AVAILABLE

FUNGCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	JSP	P1,GT.CHN##	;[265] GET A CHANNEL
	  JRST	FUNGC1		;NO CHANNELS AVAILABLE
	HRRZM	T1,0(G1)	;STORE CHANNEL #
	ADDI	T1,CHN.TB(P4)	;POINT TO THE CHANNEL TABLE
	SETOM	0(T1)		;SET CHANNEL IN USE
FUNGC0:	TDZA	P3,P3		;SET STATUS 0
FUNGC1:	MOVEI	P3,1		;SET STATUS 1
	POPJ	P,		;RETURN
	PAGE
	SUBTTL	FUNCTION RCH - RETURN AN I/O CHANNEL
;FUNCTION RCH - RETURN AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # TO BE RETURNED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL RETURNED
;STATUS 1:	INVALID OR NON-USER CHANNEL

FUNRCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	SKIPLE	T1,(G1)		;LOAD CHANNEL #
	CAILE	T1,17		;MUST BE BETWEEN 0 AND 20
	PJRST	FUNGC1		;CANNOT RETURN
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO CHANNEL TABLE
	SETCM	T0,0(T1)	;USER CHANNEL
	JUMPN	T0,FUNGC1	;NO - CANNOT RETURN
	SETZB	P3,0(T1)	;CLEAR CHANNEL TABLE
	POPJ	P,		;SET STATUS 0 AND RETURN
	PAGE
	SUBTTL	FUNCTION GOT - GET CORE FROM OTS LIST

;FUNCTION GOT - GET CORE FROM OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT

;**;[506] Replace @ FUNGOT	JNG	3-Dec-75

	FUNGOT==FUNCOR		;[506] USE COR FUNCTION
	PAGE
	SUBTTL	FUNCTION ROT  - RETURN CORE TO OTS LIST

;FUNCTION ROT - RETURN CORE TO OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT

;**;[506] Replace @ FUNROT	JNG	3-Dec-75

	FUNROT==FUNRAD		;[506] USE RAD FUNCTION
	PAGE
	SUBTTL	FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS

;FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	RUNTIME FROM OTS
;ARG2:	IGNORED
;
;STATUS 0:	RUNTIME RETURNED
;STATUS 1:	RUNTIME NOT AVAILABLE

FUNRNT:	PUSHJ	P,FUNRG1	;[302] LOCATE FIRST ARGUMENT
	MOVE	T1,RUN.TM(P4)	;[302] GET RUNTIME FROM OTS
	MOVEM	T1,0(G1)	;[302] STORE
	PJRST	FUNGC0		;[302] OK RETURN
	PAGE
	SUBTTL	FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS

;FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	DEVICE
;ARG2:	FILE NAME
;ARG3:	[PPN]
;
;STATUS 0:	OK
;STATUS 1:	ERROR

FUNIFS:	PUSHJ	P,FUNRG1	;[311] LOCATE FIRST ARGUMENT
	MOVE	T1,REGS.2(P4)	 ;[311] GET DEVICE
	MOVEM	T1,0(G1)	;[311] STORE
	PUSHJ	P,FUNRG2	;[311] LOCATE SECOND ARGUMENT
	MOVE	T1,REGS.0(P4)	;[311] FILE NAME
	MOVEM	T1,0(G1)	;[311] STORE
	MOVEI	T2,FN.RG3	;[311] LOCATE THIRD ARGUMENT
	PUSHJ	P,FUNADR	;[311]
	MOVE	T1,REGS.1(P4)	;[311] PPN
	MOVEM	T1,0(G1)	;[311] STORE
	PJRST	FUNGC0		;[311] OK RETURN
	PAGE
	SUBTTL	FUNCTION CBC - CUT BACK CORE IF POSSIBLE

;FUNCTION CBC - CUT BACK CORE IF POSSIBLE
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;
;STATUS 0:	ALWAYS

;**;[506] Delete @ FUNCBC	JNG	3-Dec-75
FUNCBC:	PUSHJ	P,DMEM%%##	;[311] DEFRAGMENT CORE
	MOVEI	T3,FRE.DY(P4)	;[311] GET FREE CORE LIST
	MOVE	T2,T3		;[311] PREVIOUS ALSO
FUNCB0:	JUMPE	T3,FUNST0	;[311] GIVE IT IF NO FORWARD LINK
	MOVE	T1,T2		;[311] PUT PREVIOUS PREVIOUS IN T1
	MOVE	T2,T3		;[311] PUT PREVIOUS IN T2
	HRRZ	T3,(T2)		;[311] ANY LEFT
	HLRZ	P1,(T2)		;[311] GET SIZE
	CAIGE	P1,1000		;[311] DON'T WASTE TIME IF LESS THAN A PAGE
	JRST	FUNCB0		;[311][446] SINCE WE CANNOT REDUCE BY LESS
	ADDI	P1,-1(T2)	;[311] FIND END
	CAME	P1,.JBREL##	;[311] LESS THAN TOP?
	JRST	FUNCB0		;[311] YES, IGNORE THIS BLOCK
	MOVEI	P1,-1(T2)	;[311] LAST WORD WE NEED
	CORE	P1,		;[311]
	  JRST	FUNST0		;[311] NO CHANGE IF WE FAILED
	CAMLE	T2,.JBREL##	;[311] INCASE WE GAVE IT ALL AWAY
	JRST	FUNCB1		;[311] JUST CLEAR PREVIOUS
	MOVE	P1,.JBREL	;[311] TOP OF CORE
	SUBI	P1,-1(T2)	;[333] - START
	HRLM	P1,(T2)		;[311] NEW LENGTH
	JRST	FUNCB2		;[311] SETUP .JBFF

FUNCB1:	HLLZS	(T1)		;[311] CLEAR FORWARD POINTER
FUNCB2:	MOVE	P1,.JBREL	;[311] GET TOP OF CORE
	ADDI	P1,1		;[311] MAKE SURE OUT OF BOUNDS
	MOVEM	P1,.JBFF	;[311]
	PJRST	FUNST0		;[311] OK RETURN
	PAGE
	SUBTTL	RRS & WRS - READ/WRITE ROUTINE STATUS (RESERVED FOR DBMS) [571]

;FUNCTION RRS - READ ROUTINE STATUS
;         WRS - WRITE ROUTINE STATUS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	GETS SET TO 0
;
;STATUS 0:	ALWAYS

FUNRRS:					;[571]
FUNWRS:					;[571]
	PUSHJ	P,FUNRG1		;[571] GET FIRST ARGUMENT
	SETZM	0,0(G1)			;[571] SET FIRST ARG TO 0
	PJRST	FUNGC0			;[571] 0 STATUS & EXIT

	PAGE
	SUBTTL	ARGBLK MANIPULATION ROUTINES

;FUNADR - RETURN ADR OF ARGUMENT
;CALL:	MOVEI	T2,OFFSET IN ARGBLK
;	PUSHJ	P,FUNADR
;	(RETURN)
;
; RETURN ADR IN G1
; CLOBBERS P1, AND T1
;
FUNRG2:	SKIPA	T2,FUNAD1	;LOAD ARG2 OFFSET
FUNRG1:	MOVEI	T2,FN.RG1	;LOAD ARG1 OFFSET
FUNADR:	ADDI	L,0(T2)		;OFFSET ARGBLK
	JSP	P1,EFCTV.##	;[265] COMPUTE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES - RELOCATE TO AC SAVE AREA
	SUBI	L,0(T2)		;RESET ARGBLK
FUNAD1:	POPJ	P,FN.RG2	;RETURN

	END
   