TITLE   RDTAPE - FORTRAN-10 PAPER TAPE READING SUBROUTINE
SUBTTL  VERSION 6.02 - 20 DECEMBER 1979

        LIST                    ;NORMAL LISTING
        SALL                    ;TURN OFF MACRO SPEWING


DEFINE EOP(MES)<SUBTTL MES
        PAGE>


COMMENT !

MAINTAIN THIS VERSION COMMENT AND UPDATE WITH EVERY RELEASE OF RDTAPE.

8/14/80 VER 6.02	SLG: CHANGED EXTERNALS JOBJDA, JOBHCU AND JOBFF
			TO .JBJDA, .JBHCU AND .JBFF RESPECTIVELY.
7/?/80 VER 6.01		DJF: FIXED SETUP OF BYTE POINTERS SO THAT
			RDTAPE WOULD PROPERLY RETURN FILE NAME WHEN
			IT SET UP A DEFAULT FILE.
12/20/79 VER 6.00	SLG: MODIFIED TO SUPPORT FORTRAN-10 ONLY.
			DELETED SFO/CFO CONDITIONAL CODE AND COMPTYPE SWITCH.
3/31/76 VER 5.03        FIXED PROBLEM CAUSED BY IN UUO DELIVERING EMPTY BUFS
02/26/74 VER 5.01       CLC:FIXES BUG 24697
9/17/73 VER 5.00        **NONAME** - FIXED FORSE TERMINAL BUFFER PROBLEM
9/13/73 VER 4.00        **NONAME** - FIXED CHAN LOOKUP BUGS
8/15/73 VER 3.00        **NONAME** - FIXED SOME BUGS
7/31/73 VER 2.00        **NONAME** - ADDED COMPTYPE SDWITCH AND CODE
6/6/73  VER 1.00        **NONAME** - AUTHOR - FIRST RELEASE

!

        EOP(ASSEMBLY PARAMETERS)

IF1 <PRINTX FORTRAN-10 CODE GENERATED >

IFNDEF CNTRLG,<CNTRLG==-1>      ;-1 IF ^G TERMINATES ELSE 0

COMMENT !

THIS SUBROUTINE, MEANT TO BE CALLED FROM FORTRAN-10, WILL READ PAPER
TAPE INTO A FILE.  CALLING SEQUENCE IS:

        CALL RDTAPE(ARY,ERRLAB,ERRNUM)

        ARY ::= AN ARRAY (PROPERLY DIMENSIONED FOR THE FILE NAME)
        WILL CONTAIN EITHER A) THE NAME OF THE FILE TO READ PAPER
        TAPE TO OR B) FIRST ELEMENT ZERO IN WHICH CASE
        A FILE NAME WILL BE MADE UP AND STORED INTO THE ARRAY.

        ERRLAB ::= ERROR PLACE TO GO

        ERRNUM ::= STANDARD MONITOR ERROR CODES (SEE DEC-10-NRZB-D)

!

        EOP(IO BLOCKS FOR OPEN RELEASE INPUT ETC)

DEFINE OPC(UUO,AC,ADR) < UUO AC,ADR>
DEFINE CT(UUO,ADR) < .UUO==UUO
 .ADR==ADR
 CR(<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>) >
DEFINE CR(A) <IRP A < OPC(.UUO,A,.ADR) >>

..CLOSE: CT(CLOSE,0)
..IN:   CT(IN,0)
..RELEASE: CT(RELEASE,0)
..SETSTS: CT(SETSTS,0)
..INBUF: CT(INBUF,5)
..OPNDSK: CT(OPEN,DSKSPEC)
..OUT:  CT(OUT,0)
..LOOKUP: CT(LOOKUP,DSKNAM)
..ENTER: CT(ENTER,DSKNAM)
..OUTBUF: CT(OUTBUF,2)
..OPEN: CT(OPEN,SPEC)

        EOP(ASSIGNMENT STATEMENTS)

;CONSTANTS
%IOCSMD==214                    ;SETMODE DATA I/O MODE FOR TTY: DEV
%IOCST==20                      ;REG.2 WHEN USING TTY: AS DEV TO IOCS
%IOCS==22                       ;REG.2 FOR IOCS .OPEN
%IOCSB==4                       ;REG.4 FOR IOCS .OPEN

; REGISTER ASSIGNMENTS
        ; MEANING
R0==0   ;SCR
R1==1
R2==2
R3==3
R4==4
R5==5
R6==6
R7==7
R10==10
R11==11
R12==12
R13==13
R14==14
R15==15
R16==16 ; POINTS TO ARGUMENT LIST ON SFO CALL
R17==17 ; PUSHJ R17, DONE TO CALL SUBROUTINE FROM SFO

; FORTRAN-10 CLOSE UUO
OPDEF FCALL [35B8]

        EOP(WORKING STORAGE)

; STORAGE FOR IO
DSKSPEC: DEC    0               ;MODE 0 - ASCII LINE MODE
        SIXBIT /DSK/
        XWD DSKPTR,0
SPEC:   EXP %IOCSMD
        SIXBIT /TTY/
        XWD 0,IOPTR
BUFFRS: BLOCK   30*5            ;5 TELETYPE INPUT BUFFERS
BLOCK 203*2              ;2 DISK BUFFERS
DSKNAM: BLOCK   4               ;OPEN BLOCK FILE NAME
USRNAM:	BLOCK	2		;USER NAME BLOCK
DSKPTR: BLOCK   3               ;DSK IO POINTERS 
CHRI==DSKPTR+1
BUFI==DSKPTR+2
IOPTR:  BLOCK   3               ;IO POINTERS
IBUF==IOPTR+2
ICHR==IOPTR+1
; SOME CONSTANTS
OPNTEL: BLOCK   1               ;OPN FILE # FOR TELETYPE
OPNFIL: BLOCK   1               ;OPN FILE # FROM IOCS
GFNAME: BLOCK   4               ;FOR OUT OWN BUILD FILE NAME

; KEEP THIS BLOCK IN ORDER
; PLACE TO SAVE AC'S

SVR0:   BLOCK   1               ;PLACE TO SAVE R0
SVR1:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR2:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR3:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR4:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR5:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR6:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR7:   BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR10:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR11:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR12:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR13:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR14:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR15:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR16:  BLOCK   1               ;PLACE TO SAVE NEXT AC
SVR17:  BLOCK   1               ;PLACE TO SAVE NEXT AC

;END OF REGISTER SAVE BLOCK

        EOP(WORKING CODE)

; SUBROUTINE: RDTAPE

        ENTRY   RDTAPE          ;DECLARE OURSELVES GLOBAL

RDTAPE:
        MOVEM   R0,SVR0         ;PREPARE TO BLT REGISTERS DOWN
        MOVE    R0,[R1,,SVR1]   ;COPY ALL REGS DOWN
        BLT     R0,SVR17        ;MOVE R1-R17
; WE HAVE SAVED THE REGISTERS
; R16 POINTS TO ARGUMENT LIST
; R17 IS PUSHDOWN STACK POINTER
;
IFN CNTRLG,<SETZM   CTRLGF          ;RESET CONTROL-G FOUND FLAG>
COMMENT !
FIGURE OUT FILE NAME... IF ELEMENT POINTER(0) IF = 0 THEN
WE HAVE A NULL NAME, ELSE WE DO NOT HAVE A NULL NAME; IN
ANY CASE, GFNAME WILL CONTAIN A GOOD NAME WHEN WE GET
THROUGH WITH THIS !

        SKIPN   @0(R16)                 ;SKIP IF NOT NULL NAME
        JRST    NULLNM                  ;NULL NAME
COMMENT !
WE HAVE A NAME.  AS WE ALL KNOW, FORTRAN-10 PASSES AN
ARGUMENT BLOCK OF THE FOLLOWING FORMAT:
		-ARG COUNT,,0
	(R16)==>100,,ARY	(100=> INTEGER ARG)
		340,,ERRLAB	(340=>LABEL)
		100,,ERRNUM
...
ARY: ARRAY CONTAINING THE FILE NAME
ERRLAB: LABEL FOR ERROR RETURN
ERRNUM: ERROR NUMBER
...

SO WE MUST UNPACK(UNHACK)
!
        MOVE    R3,[POINT 7,GFNAME]     ;POINTER TO OUT GOOD NAME
        HRRZI   R5,@0(R16)              ;R5 == ADR OF ARY
	ADD	R5,[POINT 7]		;MAKE R5 BYTE POINTER
	ILDB	R2,R5		;GET 1ST CHARACTER
	CAIN	R2," "		;IS IT A SPACE ???
	JRST	NULLNM		;YES - NULL NAME
	JUMPE	R2,NULLNM	;ALSO NULL ...
COMMENT !
WE NOW HAVE (R2) = A GOOD CHARACTER.  CHECK AND SEE IF IT IS
A ( AND IF SO WE MUST SAN FOR A USER NAME !
	CAIE	R2,"("		;OPEN PAREN?
	JRST	CPLP1		;NO - CONTINUE SCAN
; LOOP UNTIL WE SEE A CLOSING )
LOOP1:	IDPB	R2,R3		;STORE THE CHARACTER AWAY
	ILDB	R2,R5		;GET NX CHAR
	CAIE	R2,")"		;TERMINATOR???
	JRST	LOOP1		;NO, KEEP ATTACKING....
COMMENT !
(R2) NOW CONTAINS THE CLOSING ) SO STORE IT, AND LOAD THE NEXT
CHARACTER INTO R2 (BECAUSE IF WE FALL THRU THIS ROUTINE ON TOP
R2 HAS THE LAST VALID CHAR SO WE MUST DO THE SAME) !
	IDPB	R2,R3		;STORE THE CLOSING )
	ILDB	R2,R5		;GET NEXT CHARACTER
COMMENT !
CPLP1 : INITIALIZES (R4) AS THE CHARACTER COUNT OF THE
NUMBER OF VALID CHARACTERS BEFORE WE GIVE UP.  ALWAYS
ASSUMES FOLLOWING:
	FILE NAME ALWAYS FOLLOWED BY EXTENSION
	FILE NAME IS 1-6 CHARACTERS
	EXTENSION IS 3 CHARACTER, OR 1-2 CHARACTERS
	AND A BLANK CHARACTER
	TERMINATION ALWAYS ON NULL/BLANK CHARACTER
!
CPLP1:	MOVNI	R4,6+1		;7 CHARS: 6 ALPANUM AND A .
COMMENT !
CPLP2 : CHARAFCTER LOOPER , WILL FALL THRU IF
   R4 RUNS OUT OF TIME
   NULL REACHED
ALSO, IF . SEEN R4 INITIALIZED TO 3
!
CPLP2:	CAIN	R2," "		;SPACE ??
	JRST	CPLP3		;YES - QUIT
	JUMPE	R2,CPLP3	;NULL ALSO TERMINATES
; IF . THEN R4 = 3
	CAIN	R2,"."		;DOT??
	MOVNI	R4,3+1		;3 CHARS PLUS ROOM FOR DOT
	IDPB	R2,R3		;STORE CHARACTER
	AOJGE	R4,CPLP3	;ALL DONE IF R4 BOMBS
	ILDB	R2,R5		;LET'S EATNN!
	JRST	CPLP2		;AS SO
; HERE WE ARE ALL DONE .... STORE NULL AND GO GO GO !
CPLP3:	SETZ	R2,		;NULL
	IDPB	R2,R3		;STORE CHARACTER
	JRST	RDFILE		;READ THAT FILE .....
; ( F I N I )
; HERE WHEN WE MUST MAKE UP NAME
; FORMAT IS:    NNNTAP.TMP
; NNN = JOB I.D.
; ALSO, COPY NAME INTO BOTH THE USER'S AREA AND OUT AREA
; CHECK LENGTH
COMMENT !
NULL NAME GIVEN .... MAKE A STRING, STORE INTO GFNAME
AND USER'S BUFFER AREA .. THIS IS GOING TO BE A PAIN
!
NULLNM: HRRZI   R10,@0(R16)    ;R10 WILL POINT TO (ARY)
	ADD	R10,[POINT 7]	;AS A BYTE POINTER (H FMT)
        MOVE    R3,[POINT 7,GFNAME] ; R3 WILL POINT TO GFNAME
COMMENT !
STORE CHARACTERS ....!

        MOVE    R3,[POINT 7,GFNAME]     ;MAKE OUR OWN NAME
; NOW, GO TO IT ....................
        PJOB    R4,             ;GET JOB I.D. INTO R4
; THIS IS CHEATING CODE, BUT IT WORKS
;12/20/79:SLG - THE CHEAT IS THAT IT TAKES THE DECIMAL JOB NUMBER
;AND CONVERTS IT AS IF IT WERE OCTAL.  (I.E. NNN=30 FOR JOB 24)
;THE FILE NAME WILL BE UNIQUE, SO THIS PROBABLY WONT CAUSE
;ANY PROBLEMS UNLESS SOME OTHER CODE TRIES TO GET THE FILE BY
;CONVERTING THE JOB NUMBER CORRECTLY.  BAD CODE CARRIED OVER FROM
;F40/SFO HACKERS.
; IT BREAKS DOWN THE RIGHT-MOST 9 BITZ INTO 3-3BIT FIELDS
; AND CONVERTS THEM TO THEIR RESPECTIVE ASCII
        LDB     R5,[POINT 3,R4,35]      ;GET FIRST DIGIT
        LDB     R6,[POINT 3,R4,32]      ;GET SECOND DIGIT
        LDB     R7,[POINT 3,R4,29]      ;GET FIRST DIGIT
        ADDI    R5,"0"                  ;CONVERT TO ASCII
        ADDI    R6,"0"                  ;CONVERT TO ASCII
        ADDI    R7,"0"                  ;CONVERT TO ASCII
; WE NOW HAVE R7,R6,R5 = DIGITS 1,2,3 RESP.
; STORE INTO STRING
        IDPB    R7,R3           ;SAVE CHARACTER
	IDPB	R7,R10		;"
        IDPB    R6,R3           ;"
	IDPB	R6,R10		;"
        IDPB    R5,R3           ;"
	IDPB	R5,R10		;"
; THE STRINGS NOW HAVE THE JOB I.D. APPENDED TO THEM
; COPY THE REST DOWN
        MOVE    R4,[POINT 7,[ASCIZ /TAP.TMP/]]  ;STRING TO APPEND
LOOP2:        ILDB    R2,R4           ;GET NEXT CHAR OF APPENDABLE STRING
        IDPB    R2,R3           ;SAVE CHARACTER IN GFNAME
	IDPB	R2,R10		;SAVE IN LUSER'S AREA
        JUMPE   R2,RDFILE          ;SKIP IF 0 (EOSTRING)
	JRST	LOOP2		;ELSE LOOP ON CHAR STORE
; WE MUST FIND A GOOD CHANNEL NUMBER AND STORE IT INTO
; OPNTEL (R2)..

        EXTERNAL        .JBJDA,.JBHCU

;RDFILE: MOVEI   R0,5            ;UNIT 5 IS THE TERMINAL IN FORSE CLC: 02-26-74 BUG 24697
RDFILE: MOVNI   R0,1            ; CLOSE TTY (DEVICE -1) CLC: 02-26-74
;WHY?/SLG        FCALL   0,              ;CLOSE IT SO RDTAPE CAN USE TTY
        MOVEI   R2,1
LOOP3:        CAMLE   R2,.JBHCU       ;IS THE CHAN GT HIGHEST IN USE ?
        JRST    CHKCN           ;YES,, CHECK FOR LT=17.
        SKIPE   .JBJDA(R2)      ;LT HIGHEST... IS IT FREE?
        AOJA    R2,LOOP3          ;NO, LOOP ON NEXT CHANNEL
CHKCN:  CAILE   R2,17           ;IS IT A LEGAL CHANNEL NO?
        JRST    [OUTSTR [ASCIZ /?
? RUNTIME ERROR IN RDTAPE ROUTINE .. NO FREE IO CHANNELS FOR TTY:
? ABORTED
/]
                CALLI 0
                EXIT]
; R2 HAS THE CHANNEL
; SO, WE MUST PUT IT INTO R1
	MOVE	R1,R2		;MOVE CHAN {ROUND
; UNIT .OPEN - SAVE IT
        MOVEM   R1,OPNTEL               ;SAVE TELETYPE .OPEN FILE NO.
        XCT	..OPEN(R1)	;TRY AN OPEN TTY:
	JRST	SYSERR		;BAD--ABORT
        MOVEI   R2,TTYEOF               ;SET TTY EOF BIT


        MOVEM   R2,BADERR#              ;SET BAD ERROR LOCATION

; WE MUST OPEN THE FILE AT :GFNAME:
; DO NOT ACCEPT USER NAME DEVICE OR PPN SPEC
; USE DSKNAM AS 4-WORD ENTER BLOCK
        MOVEI   R2,1            ;ZERO COUNTER
LOOP4:        CAMLE   R2,.JBHCU       ;GT: HIGHEST IN USE CHANNEL ?
        JRST    NEXT1             ;YES
        SKIPE   .JBJDA(R2)      ;IS THE CHAN FREE?
	AOJA	R2,LOOP4		;LOOP ON NEXT CHAN
; SEE IF R2 IS WITHIN RANGE
NEXT1:        CAILE   R2,17           ;WITHIN RANGE ???
        JRST    [OUTSTR [ASCIZ /?
? RUNTIME ERROR IN RDTAPE ROUTINE ... NO FREE IO CHANNEL FOR DSK:
? ABORTED
/]
                CALLI 0
                EXIT]
        MOVEM   R2,OPNFIL               ;SAVE DISK OPEN CHANNEL NO.

COMMENT !
DISK CHANNEL IS NOW OKAY, SO WE MUST DO THE ENTER
DECODE INTO 6-BIT
!
        MOVE    R3,[POINT 7,GFNAME]
	MOVE	R5,[DSKNAM,,DSKNAM+1]	;BLT
	SETZM	DSKNAM			;DOWN ZERO'S
	BLT	R5,DSKNAM+3		;ALL ZERO . . .
COMMENT !
R3 POINTS TO GFNAME
R4 POINTS TO PLACE TO PUT THE INFORMATION -- GO TO IT
!
CPN1:	ILDB	R2,R3		;GET A CHARACTER
	CAIE	R2,"("		;LUSER NAME SPEC ?
	JRST	CPN2		;NO..........
; WE HAVE USER NAME SPEC, SET IT UP
	MOVE	R4,[POINT 6,USRNAM]	;POINTER TO NAME BLK
CPN1A:	ILDB	R2,R3		;GET CHARACTER
	CAIN	R2,")"		;TERMINATOR ?
	JRST	CPN0		;YES....
	SUBI	R2,40		;MAKE INTO SIX BIT
	TRNE	R2,000100	;IF LOWER CASE,
	  SUBI	  R2,40		;  CONVERT TO UPPER CASE
	IDPB	R2,R4		;PLACE NAME
	JRST	CPN1A		;LOOP
; DONE WITH LUSER NAME
CPN0:	HRRZI	R2,USRNAM	;POINTER TO USER NAME
	MOVEM	R2,DSKNAM+3	;SET UP NAME POINTER
	ILDB	R2,R3		;GET NEXT CHAR AFT THE (
COMMENT !
CPN2 -- R2 HAS A CHARACTER IN IT
WE MUST SET UP R4 TO POINT TO A PLACE AND GO TO IT
!
CPN2:	MOVE	R4,[POINT 6,DSKNAM]
CPN2A:	JUMPE	R2,LPE		;ALL DONE
	CAIN	R2,"."		;DOT ??
	JRST	[MOVE R4,[POINT 6,DSKNAM+1]
		ILDB R2,R3
		JRST CPN2+1]
	SUBI	R2,40
	TRNE	R2,000100	;IF LOWER CASE,
	  SUBI	  R2,40		;  CONVERT TO UPPER CASE
	IDPB	R2,R4		;SAVE CHAR
	ILDB	R2,R3		;GET NEXT CHAR
	JRST	CPN2A		;LOOP
LPE:    MOVE    R1,OPNFIL               ;GET DSK CHAN NO
        XCT     ..OPNDSK(R1)    ;OPEN THE DSK
        JRST    [OUTSTR [ASCIZ /?
? FATAL ERROR IN RDTAPE - CAN'T INIT THE DSK !!!
? HALTING * * *
/]
                HALT
                JRST .-1]
        XCT     ..ENTER(R1)     ;DO ENTER
        JRST    UBLUIT          ;ERROR

        EXTERNAL        .JBFF           ;JOB DAT LOC.

        MOVEI   R1,BUFFRS               ;LOC. OF 1 BUFFER
        EXCH    R1,.JBFF                ;SET UP .JBFF
        MOVE    R2,OPNTEL               ;GET CHANNEL;
        XCT     ..INBUFF(R2)            ;SET UP BUFFER RING
        MOVE    R2,OPNFIL               ;GET OPEN FILE NO.
        XCT     ..OUTBUF(R2)            ;SET UP BUFFER RING
        MOVEM   R1,.JBFF                ;RESET .JBFF

; ALL UNITS .OPEN ----- COPY

LOOPIT: MOVE    R1,OPNTEL               ;GET TTY FILE NO


        JSP     R17,RDTTY                ;READ IT

; STRIP OFF PAR BIT FOR CHECKS
        MOVE    R5,R1                   ;GET CHAR. IN SCR CELL
        ANDI    R5,177                  ;STRIP OFF PAR BIT
        JUMPE   R5,LOOPIT               ;IGNORE THE NULL CHAR
        CAIN    R5,177                  ;IGNORE RUBOUTS
        JRST    LOOPIT                  ;"

IFN CNTRLG,<
COMMENT !
THIS CODE IS FOR TERMINATING ON A CONTROL-G
!
        CAIN    R5,7                    ;SKIP IF NOT CONTROL-G
        JRST    [SETOM CTRLGF#          ;SET CONTROL-G FOUND FLAG
                MOVE R1,OPNTEL          ;GET TTY FILE NO.
                JSP R17,RDTTY           ;CONTINUE READING
                JRST .]                 ;LOOP
COMMENT !
THE 'JRST .' RE-EXECUTES THE LITERAL.  REMEMBERING YOUR MACRO,
THE LOCATION COUNTER DOES NOT CHANGE WHILE EXEUTING IN A LITERAL
(MACRO'S LOCATION COUNTER STUPID).  THE JRST . SAYS = JRST TO CURRENT
LOCATION, WHICH IS, OF COURSE, THE JRST TO THE LITERAL !
> ; ABOVE ASSEMBLE FOR CONTROL-G TEMRINATION OF READING

        MOVE    R2,OPNFIL               ;.OPEN FILE NO.
        EXCH    R2,R1                   ;R1=FN, R2=VAL

        JSP     R17,WTDSK               ;WRITE DISK
        JRST    LOOPIT                  ;LOOP

; DSK IO ROUTIN
; R1 ::= FIL NUM
; R2 ::= VALUE TO WRITE
; WRITES TO THAT CHANNEL....
WTDSK:  SOSG    BUFI            ;ANY MORE ROOM LEFT???
        XCT     ..OUT(R1)       ;NO - OUT A LOT
        JRST    WTDSK1          ;WORKED.....
; ERROR ON DISK ??!!??
        OUTSTR  [ASCIZ /?
? ERROR IN RDTAPE ROUTINE....DSK I-O ERROR
? ABORTED
/]
                CALLI 0
                EXIT
WTDSK1: IDPB    R2,CHRI          ;PUT CHARACTER OUT
        JRST    @R17             ;RETURN 

; TTY IO ROUTINE RDTTY
; R1 ::= CHANNEL NO. INPUT CHARACTER
; GO THRU BADERR ON EOF
RDTTY:  SOSG    IBUF                    ;ANY MORE CHARS LEFT?
        XCT     ..IN(R1)                ;NO - GET SOME
        JRST    RDTTY1                  ;GOT SOME
IFN CNTRLG,<
; IF NO CONTROL-G ENCOUNTERED, DO A CLOSE AND AN IN AGAIN
        SKIPN   CTRLGF          ;SKIP IF CONTROL-G FOUND
        JRST    [XCT ..CLOSE(R1)        ;CLOSE CHANNEL
                JRST RDTTY+1]           ;RE-IN >
; HERE ON EOF FROM TTY
	XCT	..SETSTS(R1)		;RESET STATUS TO ASCII
	SKIP
        XCT     ..RELEASE(R1)           ;RELEASE THE CHANNEL
        JRST    @BADERR                 ;ERROR RETURN
; HERE TO LOOP READ
RDTTY1: SKIPN   IBUF                            ; IF WE TIMED OUT ON THE IN
        JRST    RDTTY+1                         ; BUFFER IS EMPTY SO GO AGAIN
        ILDB    R1,ICHR                  ;GET CHARACTER
        JRST    @R17                     ;RETURN

;HERE ON TELETYPE E.O.F


TTYEOF:        MOVE    R1,OPNFIL               ;DSK: FILE NO.
        XCT	..CLOSE(R1)		;CLOSE DSK CHAN
        XCT     ..RELEAS(R1)            ;MAKE SURE IT'S RELEASED
        OUTCHR  [177]                   ; RDO
        MOVE    R0,[SVR1,,R1]           ;PREPARE TO BLT
        BLT     R0,R17                  ;BLT
        MOVE    R0,SVR0                 ;GET R0
        POPJ    R17,                    ;RETURN

; HERE WHEN TEL FAILS
SYSERR: MOVE    R16,SVR16               ;GET R16


; HERE WHEN USER BECOMES A LUSER
UBLUIT: MOVE    R16,SVR16               ;GET BACK R16
        MOVE	R1,OPNTEL		;CLOSE TELETYPE
	XCT	..SETSTS(R1)		;REZ CHAN STAT
	SKIP
	XCT	..RELEA(R1)		;CLOSE CHAN
	MOVE	R1,OPNFIL		;CLOSE FILE
	XCT	..RELEA(R1)		;RELEASE IT...
	HRRZ   R1,DSKNAM+1             ;GET SYSTEM ERROR CODE
        MOVEM   R1,@2(R16)              ;ERRCOD SET.
        OUTCHR  [177]                   ; /RDO
        MOVE    R0,[SVR1,,R1]           ;BLT WORD
        BLT     R0,R17                  ;BLT REGS. BACK
        MOVE    R1,@1(R16)              ;GET ADR. OF ERROR STEP
        JRST    0(R1)                   ;BRANCH TO ERROR STEP

        END
