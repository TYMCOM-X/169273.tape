TITLE FORDDT - FORTRAN INTERACTIVE DEBUGGING AID
SUBTTL  23-Oct-77	/P.E.T. HARDING/DBT/FLD/MD/JMT/MA/SJW		READING  .  .  UK.

	FT$TYM==-1	;[JMS] Don't crump on .JBREN if it is in use


;COPYRIGHT (C) 1973,1977 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

	;[JMS] Move SEARCH MONSYM to be inside TOPS20 conditional

EDITNO==101	;EDIT NO
VERSION==5	;MAJOR VERSION NO
VMINOR==1	;MINOR VERSION NO
VWHO==0		;WHO LAST EDITED



.JBDDT=74
.JBREN=124
.JBVER=137

LOC	.JBVER
BYTE(3)VWHO(9)VERSION(6)VMINOR(18)EDITNO	;SETS FORDDT VERSION #


IFE FT$TYM,<	;Don't overwrite JOBREN
LOC	.JBREN
RE.ENT		;SETS THE RE - ENTER ADDRESS
>  ;End of IFE FT$TYM


LOC	.JBDDT
FORDDT		;MAKES DEBUG PROG,FORDDT WORK


RELOC
DDTBEG:!	;[JMS] DDT beginning
	PAGE
;  REVISION HISTORY



;21		REMOVE ALL HIBERNATE CALLS - JUST USE TTCALL 4
;22		CHANGE TRACE% TO TRACE.
;23		BEGIN UPDATE FOR (1) SYMBOL TABLE LOOKUP ALGORITHMS
;				 (2) GENERAL CLEAN UP
;24		(CONTINUING)
;25		CONTINUING;  ALSO REWRITE OF LOOK
;26		CONTINUING;  REWRITE OF OFFSET
;			     REMOVAL OF 'BIGCOD'
;27		CONTINUING
;30		CONTINUING;  INCLUDING SYMBOL USAGE CLEANUP AND REMOVAL
;			     OF SYMSET
;31		CONTINUING;  REMOVAL OF MOST 'DEBUG' CONDITIONAL CODE
;			     AND INTCPT CONDITIONAL AND CODE
;32		CONTINUING;  REMOVAL OF SMART PORTION OF LOOK
;33		CONTINUING;  FIXUP OF PAUSE LOGIC
;34		CONTINUING;  REINSERT OF SMART CODE TO LOOK - IGNORE
;			     UDDT, FORDDT, AND JOBDAT ON LOOKUP.
;35		FINAL EDIT OF UPDATE - PATCH AREA GOES UNDER DEBUG
;		   CONDITIONAL, CALL TO DO MACRO IS FIXED, SO THIS WILL
;		   NOW ASSEMBLE WITH MACRO V50.
;36		ANOTHER FINAL - HIERARCHY IN LOOK;  FNDSYM RESOLVED
;37		CONTINUING FINAL - SCATTERED BUGS
;40		FIX AC LONG ASCII AND RASCII
;		FIX - LOCATE FOR LOCALS OUTSIDE OPEN
;		FIX - DIM A(X(1)/1)
;41		FIX USAGE OF PROGRAMS NAMED OTHER THAN MAIN.
;42		INITIALIZE  ODF (NUMERIC BASE) FOR GROUP TYPEOUT
;43		ADD  CURGRP (BIT MASK ) TO NOTE CURRENT GROUPS
;		ACTIVE IN A TYPEOUT  AND CATCH RECURSION
;44		FIX UP "LOOK" SO THAT IF "MATHSM" IS NON-0 THAT IT
;		WILL ACCEPT ONLY A SYMBOL WHOSE NAME IS IN "MATHSM"
;45		FIX PAUSE TYPING TO LISTEN TO TTY BETTER
;46		CHECK RANGES TO SEE THAT EACH  SYMBOL IS THE SAME
;***** BEGIN VERSION 4A
;47		DIFFERENTIATES ASCII- AND RASCII-MODE "TYPE"-OUTPUT
;50		ALLOWS = AS DELIMITER IN ACCEPT STATEMENTS
;51		FIXES "HELP" TO LIST COMMANDS
;52		FIX TYPEOUT OF COMPLEX VALUES
;53	15732	FIX TYPOUT OF SYMBOL WHEN LOCAL SYMBOL FOUND BEFORE GLOBAL
;***** DELETED ;54	15732	TYPE OUT NAMES OF ARGUMENTS WHEN PAUSE AT ROUTINE
;55	15708	MAKE TYPE KNOW ABOUT FORMAL ARGUMENTS
;***** BEGIN VERSION 4B
;56	16928	ACCEPT LOWER CASE MODE MODIFIERS
;57	17043	IF TWO SYMBOLS HAVE SAME ADDRESS VALUE AND SAME
;		NAME VALUE , THEN THEY MUST BE IN COMMON , SO LOOK
;		SHOULD SUCCEED (OK SKIP 2 RETURN)
;		ALSO REMEMBER NAME OF ARRAY FOR DIM COMMAND.
;60	17272	IF ARRAY INFORMATION DOES NOT EXIST, TELL THE USER
;		BUT DO NOT GIVE FDTIER ERROR.
;61	17574	IF ERROR HAPPENS IN TYPING GROUP, CURRENT GROUP VARIABLE
;		IS NOT CLEARED AND LATER GIVES ERROR FDTRGR.
;62	18059	ADD INFORMATION IN THE "WHAT" OUTPUT
;		(LOCATION OF THE PAUSE LABEL)
;63	18374	GIVE CORRECT INFORMATION FOR "WHAT" COMMAND:
;		SINGLE VARIABLE NAME + ARRAY NAMES AND SUBSCRIPT
;		+ LOCATION OF NAMES
;64	S19206	DONT TYPE EXTRA CRLF BETWEEN TYPED VALUES.
;65	18715	ACCEPT COMMENTS ON COMMAND LINES
;		DELIMITER IS !  TO END OF LINE OR OTHER !
;66	 --- 	FIX TEST FOR ARRAY BOUNDS EXCEEDED IN DIM COMMAND
;67	19541	FIX LOWER CASE RANGE CHECK
;70	QA570	FIX REENTER MESSAGE TO ALWAYS GIVE SECTION NAME
;
;	BEGIN VERSION 5A, 7-NOV-76
;
;71	20553	TYPING A FORMAT STATEMENT CAUSES AN E8 INTERNAL
;		ERROR IF THE PROGRAM WAS NOT COMPILED WITH THE
;		/DEBUG SWITCH. ADD MORE INFORMATIVE ERROR MESSAGE
;		AREAS AFFECTED: FRMSET, ERR41
;72	10088	WHEN TYPING AN ARRAY, THE INDEXES ARE NOT CORRECTLY
;		TYPED IF AND ONLY IF THE IS A HIGH SEGMENT SYMBOL
;		TABLE (FOR EXAMPLE FOROTS IS LOADED WITH SYMBOLS).
;73	21818	WHEN TYPING A COMPLEX ITEM OR ARRAY, OR ACCEPTING A
;		VALUE FOR A COMPLEX ARRAY, FORDDT DOESN'T NOTICE THAT
;		EACH ENTRY IS TWO WORDS AND MESSES UP SUBSCRIPTS ETC.
;74	21988	FORDDT CANT SET BREAK POINTS (PAUSE) IN HIGH SEGMENT
;		OF A FORTRAN PROGRAM. ROUTINE CHKADR CLOBBERS (T)
;75	21910	WHEN DOING A START, PROGRAM SHOULD CLEAR
;		ANY SUPPLIED ARGUMENTS FROM THE TTY BUFFER.
;76	21910	FIX ERROR IN ACCEPT ROUTINE WHICH CAUSES UNNECESSARY
;		WARNING MESSAGE WHEN EXACTLY 5 (OR EXACTLY 10 IF IN
;		LONG MODE) CHARACTERS ARE ACCEPTED
;77	21910	MAKE THE PAUSE COMMAND WITH NO ARGUMENTS DISPLAY
;		THE PAUSES.
;100		Add TOPS20 conditional, make FORDDT run in native
;		mode under TOPS-20.
;101	QA2171	FIX FORDDT OUTPUT TO USE FOROTS CORRECTLY AFTER OTS EDIT
;		  661: OUTPUT MUST START WITH + AND CLEAR TTY BUFFER
;		  AFTERWARDS
;*** END REVISION HISTORY
	PAGE
SUBTTL	DEFINITIONS	


;DEFINE ACCUMULATORS

ENTRY FDDT.,.F10
EXTERN .JBREL,.JBHRL,.JBSYM,.JBHSM,.JBSA,.JBUSY,.JBOPC,.JBDA

F=0		;FLAGS
TF=1		;TEMPORARY FLAGS  RESET EACH RETURN TO RET:
R=<T1=<A=2>>	;POINTERS TO TABLES, CORE, ETC.
S=<T2=<B=3>>
W=<T3=<C=4>>	;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T=<T4=5>	;TRANSFER DATA
W1=<T5=6>
W2=<T6=7>
TMOD=10		;TYPE MODE FLAGS
AR=11		;
ODF=12		;RADIX DEFINITION
TT=<P3=13>	;TEMPORARY
TT1=<P4=14>	;TEMPORARY
RAY.==15	;POINTS TO NEXT F10 DEFINE ARRAY DIMENSION
P=17		;PUSH DOWN



;DEFINE SYMBOL TABLE SYMBOL TYPES

GLOBAL==040000		;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000		;PROGRAM NAME
DELI==200000		;DELETE INPUT
DELO==400000		;DELETE OUTPUT



;GETTAB TABLES

.GTSGN==14	; GETTAB FOR DETERMINING HISEG INDEX
.GTUPM==100	; GETTAB FOR FINDING HISEG START ADR
	PAGE
;	DEFINE SYSTEM PARAMETERS


IFNDEF NBP,<NBP==^D10>		;NUMBER OF PUASE REQUESTS

IFNDEF GPMAX,<GPMAX==10>	;NUMBER OF GROUP STRINGS (MAX 35 )

IFNDEF PDSIZ,<PDSIZ==10*GPMAX+40>	;DEFINE PDL SIZE TO ALLOW ALL GROUPS TOGETHER
IFG PDSIZ-100,<PDSIZ==100>	;LIMIT SIZE TO ^D64

IFNDEF CFSIZ,<CFSIZ==^D15>	;CORE FILE LENGTH



IFNDEF DIMSIZ,<DIMSIZ==^D50>	;AMOUNT OF SPACE FOR DIMENSION DEFINITIONS




IFNDEF DEBUG,<DEBUG==0>		;KEEP OFF - DEVELOPMENT ONLY - UNSUPORTED
				IFN DEBUG<  IF1<
	PRINTX	FORDDT - DEVELOPMENT VERSION
					>	>

;[JMS] Put SEARCH MONSYM under IFN TOPS20
;**;[100] add conditional  ma 25-aug-77
ifndef tops20,<tops20==0>	;[100]set tops20==1 to run in native mode
IFN TOPS20,<printx [Building TOPS-20 version of FORDDT]
	search monsym>		;[100]




	PAGE
COMMENT \

NBP	DEFINE THE MAXIMUM NUMBER OF PAUSE REQUESTS ALLOWED
	EACH PAUSE INCREASES CORE REQUIREMENTS BY DECIMAL 10

GPMAX	DEFINE THE MAXIMUM NUMBER OF GROUPS
	EACH GROUP SETTING REQUIRES AN EXTRA DECIMAL 23 LOCATIONS

PDSIZ	DEFINE THE SIZE OF THE PUSH DOWN STACK 
	ALLOW SUFFICIENT STACK FOR ALL GROUPS TOGETHER
	LIMITS PDSIZE TO ^D64

CFSIZ	DEFINE THE SIZE OF EACH CORE FILE

DIMSIZ	DEFINE THE NUMBER OF TWO WORD PAIRS
	USED TO HOLD ARRAY DIMENSION DATA

\
	PAGE
;FLAG F DEFINITIONS,  LEFT HALF:

EOL==   400000	;END OF USER LINE 
FPF==   200000	;PERIOD TYPED FLAG
FEF==   100000	;EXPONENT FLAG

MF==    040000	;MINUS FLAG
SIGN==  020000	;PLUS OR MINUS TYPED
CFLIU== 010000	;CORE FILE IN USE FLAG

OFCFL== 004000	;OUTPUT FROM CORE FILE REQUESTED
CONS==  002000	;CONSTANT SEEN FLAG
GRPFL== 001000	;GROUP FLAG - ALLOWS GROUP LOGIC

AUTO==  000400	;AUTO PROCEDE FLAG
OCTF==  000200	;OCTAL NUMBER TYPED FLAG
FGLSNM==000100	;ALLOW GLOBAL SYMBOL NAMES (FOR LOOK AND FINDSYM)

LABEL== 000040	;INDICATES STATEMENT LABEL BEING PROCESSED
LFTSQB==000020	;FLAG THAT A [ IS SEEN - SO A ] WILL END THE SPECIFICATION
BAR==   000010	;FLAG THAT WE HAVE SEEN A / IN DIMENSION ANALYSIS

DIMEND==000004	; ) OR ] FOUND I.E. END OF DIMENSION SPEC IMINENT
FPRNM== 000002	; FIND PROGRAM NAME (FOR FNDSYM)
FLCLNM==000001	; FIND LOCAL IN CURRENT OPEN PROGRAM (FOR FNDSYM)



;RIGHT HALF

POWF==  400000	;POWER FLAG # TO FOLLOW
DOUBLE==200000	;FLAG FOR DOUBLE PRECISION ARRAY DATA
BASENM==100000	;AN ARRAY BASE NAME HAS BEEN ACCEPTED

TRLABL==040000	;TRACING LABEL ONLY FLAG
PNAMEF==020000	;PROGRAM NAME SEEN IN SYBOL TABLE SEARCH
MDLCLF==010000	;USED BY LOKSYM AND FNDSYM - MULTIPLY DEFINED LOCAL SYBOL

ID==    004000	;SYMBOL IDENTIFIED FLAG
IDINOS==002000	;SYMBOL IDENTIFIED IN OPEN SECTION
SILENT==001000	;DO NOT TYPE SYMBOL IF FOUND IN 'LOOK'UP

SUBFLG==000400	;SUBSCRIPT FLAG - CHECK SUBSCRIPTS IF ON
FLSHAL==000200	;FLUSH ALL ARRAY NAMES FROM BASRAY ONWARDS
IDPNAM==000100	;IF SET CAUSES 'LOOK' TO REMEMBER SECTION NAME

NEARST==000040	;IF SET CAUSES 'LOOK' TO RETURN THE NEXT LARGER SYMBOL
F10RAY==000020	;CURRENT ARRAY IS F10 DEFINED
TRLINE==000010	;TRACE AT LINES LEVEL

FORMAL==000004	;HANDLING ARRAY AS SUBROUTINE FORMAL PARAMETER
SURGFL=000001	;ACCEPT  / AND : AS DIMENSION RANGE DELIMETERS
;	*** FLAG TF ***
;
;	TF TEMPORARY FLAG DEFINITIONS:
;	CLEARED ON EVERY RETURN TO USER (RET:)
;
;	RIGHT HALF

DCOPFG==000001	;DON'T CHANGE OPEN PROGRAM FOR GROUP
ALPHA== 000002	;PERSUADES ROUTINE EITHER TO RETURN SIXBIT ON NON # INPUT
ACCPT== 000004	;SIGNALS AN ACCEPT IN PROGRESS
ADELIM==000010	;FLAG THAT WE HAVE HAD AN ASCII TEXT DELIMITER
IMPRNG==000020	;REQUEST FOR IMPLIED RANGE
;**;[060] FLAG TF DEFINITION
ARRAY.==000040	;AN ARRAY HAS BEEN DETECTED DURING ACCEPT LOGIC
		;[060] ALSO DURING TYPE OFFSET PROCESS
GUDLBL==000100	;A GOOD NUMERIC LABEL FOUND IGNORING LAST CHARACTER
FGLONL==000200	;FIND GLOBAL SYMBOL ONLY
SYMLAB==000400	;SYMBOL IS A LABEL
DCEVAL==001000	;DON'T CALL EVAL ( FROM SYMIN )
;**;[065],FLAG TF DEFINITION,MD,APR-76
COMDEL==002000	;[065] COMMENT PROCESS IN PROGRESS




;	*** FLAG TMOD ***
;
;	DEFINE THE PRINT OPTION FLAGS USED IN LEFT & RIGHT OF TMOD
;	RIGHT HAND - DEFAULT USER SETTING
;	LEFT HAND  - LOCAL TEMPORARY SETTING (TAKES PRIORITY)

F.==000001	;TYPE FLOATING POINT FORMAT
I.==000002	;TYPE INTEGER FORMAT
O.==000004	;TYPE OCTAL FORMAT
A.==000010	;TYPE ASCII FOMAT
D.==000020	;TYPE DOUBLE PRECISION FORMAT
R.==000040	;TYPE RIGHT JUSTIFIED ASCII
C.==000100	;TYPE COMPLEX FORM
L.==000200	;'LONG' OPTION REQUESTED OR TRACE LABELS

S.==000400	;TRACE SOURCE LINES
E.==001000	;TRACE ENTRIES

ANYMOD==400000	;USED BY OPTION TO SHOW LEGAL MODIFIER SEEN





;FLAG F - "STICKY FLAGS"

STIKYS==TRLABL!TRLINE
	PAGE
;	USEFUL OPDEFS

	OPDEF	INCHWL	[TTCALL 4,]	;INPUT CHARACTER - LINE MODE
	OPDEF	CLRBFI	[TTCALL 11,]	;CLEAR INPUT
	OPDEF	PJRST	[JRST]		;PUSHJ/=POPJ
	OPDEF	SKPINL	[TTCALL 14,]	;SKIP ON NO CHARS TYPED




;	POSSIBLE ERROR MESSAGES OF THE FORM ? E#

;	? E1	CANNOT FIND SYMBOLIC NAME FOR THE PAUSE IN A 'WHAT'
;	? E2	CANNOT FIND SYMBOLIC NAME FOR THIS PAUSE(BREAK)
;	? E3	CANNOT FIND SYMBOLIC NAME FOR AN ARGUMENT OF THE
;		ROUTINE ABOUT TO BE ENTERED
;	? E4	BAD LABEL FOUND WHERE SOURCE LINE OR STATEMENT LABEL EXPECTED
;	? E5	CANNOT FIND SYMBOL IN DIMENSION LOGIC
;	? E6	CANNOT FIND SYSMBOL MATCH IN A RE-ENTER
;	? E7	CANNOT FIND SYMBOL IN A TRACE INTERUPT
;	? E8	CANNOT FIND END OF F10 FORMAT STATEMENT = LABEL+F
;	? E9	INTERNAL INCONSISTENCY (FNDSYM)


;	THESE ERRORS SHOULD NEVER OCCUR - BUT COULD INDICATE THAT
;	THE SYMBOL TABLE HAD BEEN MODIFIED(OVERLAYED?) OR SOMETHING
	PAGE
SUBTTL	MACRO'S	

	DEFINE	SETPDL		;SETUP PDL STACK
<	MOVE	P,[IOWD	PDSIZ,PDL]	>

	DEFINE	QUERY
<	TYPE	(? )	>

;**;[100] conditionalize TOPS10 macros  ma 28-aug-77
ife tops20,<
	DEFINE	TYPE(X)
<	OUTSTR	[ASCIZ/X/]	>

	DEFINE	LINE
<	OUTSTR	CRLF	>

	define	atype(x)
<	outstr x	>

	define	stype(x)
<	outstr [asciz x]>

	define	tab
<	outstr	[byte(7)11,0]	>

	define	openp
<	outstr	[byte(7)"(",0]	>

	define	closep
<	outstr	[byte(7)")",0]	>

	define	openb
<	outstr	[byte(7)74,0]	>

	define	closeb
<	outstr	[byte(7)76,0]	>

	define	putchr(x)
<	outchr x>
>				;[100] end of conditional
;**;[100] add native macros  ma 28-aug-77
ifn tops20,<
	define	type(x)
<	push	p,tf
	hrroi	tf,[asciz/x/]
	psout
	pop	p,tf	>

	define	atype(x)
<	push	p,tf
	hrroi	tf,x
	psout
	pop	p,tf	>

	define	stype(x)
<	push	p,tf
	hrroi	tf,[asciz x]
	psout
	pop	p,tf	>

	define	line
<	push	p,tf
	hrroi	tf,[byte(7)15,12,0]
	psout
	pop	p,tf	>

	define	openp
<	push	p,tf
	hrrzi	tf,"("
	pbout
	pop	p,tf	>

	define	closep
<	push	p,tf
	hrrzi	tf,")"
	pbout
	pop	p,tf	>

	define	openb
<	push	p,tf
	hrrzi	tf,74
	pbout
	pop	p,tf	>

	define	closeb
<	push	p,tf
	hrrzi	tf,76
	pbout
	pop	p,tf	>

	define	tab
<	push	p,tf
	hrrzi	tf,11
	pbout
	pop	p,tf	>

	define	putchr(x)
<	push	p,tf
	move	tf,x
	pbout
	pop	p,tf	>
>				;[100] end of conditional





	DEFINE SKIPIF(STRING)		;IS STRING LOADED? - SKIP IF IT IS
<	MOVE	T,[SQUOZE 0,STRING]	;GET RAD50 FORM OF 'STRING'
	PUSHJ	P,FINDST		;SEE IF STRING IS LOADED>



	DEFINE PROGIF(NAME)		;IS NAME LOADED?  SKIP IF SO
<	MOVE	T,[SQUOZE 0,NAME]
	MOVEM	T,SYM
	TLO	F,FPRNM
	PUSHJ	P,FNDSYM	>
	PAGE
;	RECURSION MACRO'S
;
;	MACRO -RECURS- TO SAVE RELEVANT INFORMATION TO
;	ALLOW RECURSION
;	CALL SRUCER TO RESTORE



	DEFINE RECURS(X)
<	XLIST
	IRP(X)<	PUSH	P,X>
	DEFINE SRUCER<NAMLST <X>	>
	LIST	>



	DEFINE NAMLST(X)
<	..A=100
	IRP(X)<DO(\..A,X)>
	..A=..A-1
	IRP(X)<UNDO(\..A)>
	PURGE	..A	>



	DEFINE DO(I,J)
<	..K'I=J
	..A=..A+1	>



	DEFINE UNDO(I)
<	XLIST
	POP	P,..K'I
	..A=..A-1
	PURGE	..K'I
	LIST	>



	DEFINE	JUSTIFY		;JUSTIFY THE OUTPUT & RESET T
<	PUSHJ	P,JUSTFY	;DO TYPE COMMAND OUTPUT JUSTIFICATION>



;**;hack by ma!!1
	;SALL			;SUPPRESS ALL MACRO EXPANSIONS
	PAGE
	DEFINE NAMES<
	XLIST
	C	ACCEPT,ACCEPT
	C	CONTIN,CONTIN
	C	DDT,DDT
	C	DIMENS,DIM
	C	DOUBLE,DUBLE
	C	GROUP,GROUP
	C	GOTO,GOTO
	C	HELP,HELP
	C	LOCATE,Q
	C	MODE,MODE
	C	NEXT,NEXT
	C	OPEN,OPEN
	C	PAUSE,PAUSE
	C	REMOVE,RESET
	C	START,START
	C	STOP,EX.
	C	STRACE,TRACE
	C	TYPE,DISPLA
	C	WHAT,WHAT
	LIST
>

	PAGE
SUBTTL	INITIALIZATION

FDDT.:	JFCL			;DEFAULT TO NO TRACE  MODE
				;OTHERWISE PUSHJ P,STEP4 TO TRACE
.F10:	JSR	SAVE		;SAVE USERS ACS
	PUSHJ	P,REMOVB	;REMOVE PAUSES
	JRST	MODRET		;DO A RE-ENTER - FOR DDT ONLY

FORDDT:	JSR	SAVE		;SAVE THE WORLD
	PUSHJ	P,REMOVB	;REMOVE ANY STANDING PAUSE REQUESTS
	LINE
	TYPE(STARTING FORTRAN DDT)
	LINE

	PUSHJ	P,GHSSYP	;ANY HISEG SYMBOLS?
	 SKIPGE	.JBSYM		;NO, ANY LOSEG SYMBOLS?
	CAIA
	PUSHJ	P,ERR20		;NO - WARN USER
	PUSHJ	P,SETLST	;SETUP SYM TABLE LISTS
	HRRZ	T,.JBSA		;REMEMBER THE START ADDRESS
	MOVEM	T,JOBSA		; AND THE
	MOVE	T,.JBSYM	;  SYMBOL TABLE DETAILS AT THE-
	MOVEM	T,JOBSYM	;    TIME FORDDT IS ENTERED
;**;[100] conditionalize TOPS10 code @ forddt+20 ma 29-aug-77
ife tops20,<			;[100]this hack doesn't work under TOPS20
	MOVE	T,[XWD -1,3]	;GET THE CURRENT JOB
	GETTAB	T,		;   NAME
	 CAIA			;DON'T PANIC IF NO JOB NAME
	MOVEM	T,JOBNAM>	;AND SAVE, end of conditional
				;THIS WILL SERVE TO DETECT OVERLAYS
	HRRZI	T,[JRST RET]	;GUARD AGAINST CONTINUE AFTER CNTRL C
	HRRM	T,PROC0
	MOVEI	T,1		;RESET THE INITIAL TRACE VALUE
	MOVEM	T,STPVAL	;   TO ONE
	MOVE	T,STARTU
	HLLZM	T,STARTU	;RESET - SO USER MUST 'START'
	PUSHJ	P,RE.NTR	;ALLOW A RE-ENTER TO WORK
	SETOM	ESCAPE		;NO ^C'S SO ALLOW ESCAPES TO FOROTS

	SKIPIF	(RESET.)	;SKIP IF RESET. IS LOADED
	  JRST	RE.RET		;NOT LOADED WITH FOROTS - DO OTHER INITS
	JSP	16,@GOLOC	;INITIALISE THE FOROTS SYSTEM
	0,,0			;DUMMY RESET ARG
	PAGE
;	RE - ENTER ENTRY

RE.RET:	SETPDL
	SKIPIF	(CEXIT.)	;
	   SETZM T		;NO CLUDGE CONECTIONS IN THIS PROG
	HRRM	T,HELLO		;SET UP FOR HELLO MACRO DETECTOR
	MOVE	F,STKYFL	;REINSTATE THE FLAG REGISTER
	MOVSI	T,(JFCL)	;RESET THE TRACE ENTRY
	MOVEM	T,FDDT.		;
	MOVE	T,M2.F		;GET THE FOROTS FIN CALL
	MOVEM	T,M2.I		;RE-INSTATE IN FORMAT - AFTER COMPLEX INPUT

;	SET THE DEFAULT TYPING FORMAT TO FLOATING  -  ALSO SET STKYFL

MODRET:	HRRZI	T,F.		;SET UP TO TYPE FLOATING FORM
	MOVEM	T,MODFLG	;SAVE AS THE STANDARD DEFAULT
	HRRZ	T,STARTU	;SEE IF ALREADY STARTED
	JUMPN	T,RET		;YES LEAVE ANY OPENED SECTIONS ALONE
	SKIPE	PRGNAM		;HAS ANY SECTION BEEN OPENED?
	JRST	RET		;YES - SO NOT FIRST TIME THROUGH
	PROGIF	(MAIN.)		;SKIP IF MAIN. IS LOADED
BEGIN2:	   PUSHJ P,GETPRG	;NOT FOUND - GET THE MAIN PROGRAM NAME
			MOVE	T3,[SQUOZE 0,MAIN.]
	MOVEM	T3,PRGNAM	;DEFAULT MAIN PROG NAME IS MAIN.
	MOVEM	T3,SYM		;SET SO SETNAM CAN OPEN THE MAIN PROGRAM
	PUSHJ	P,SETNAM	;'OPEN' THE MAIN PROGRAM
	PAGE
SUBTTL	USER INPUT

RET:	HRRZ	TMOD,MODFLG	;SET UP THE DEFAULT TYPING OPTIONS ONLY
	AND	F,[STIKYS]	;MAKE SURE WE SAVE THE GOOD FLAGS
	MOVEM	F,STKYFL	; IN THE STICKY STORE
	SETZI	TF,		;RESET THE TEMPORARY FLAGS
	SKIPGE	TERMK		;END OF LAST LINE SEEN?
	PUSHJ	P,CLRLIN	;CLEAR OUT THE REST OF USERS LINE
	SETPDL
;**;[61],RET+7,INSERT,MD, 28-OCT-75
	CLEARM	CURGRP		;CLEAR CURRENT GROUP NUMBERS
	CLEARM	SYL
	CLEARM	MATHSM
	CLEARM	SYM
	CLEARM	DEN
	CLEARM	RANGE
	CLEARM	GETCHR
;**;[063],RET+15,  INSERT, MD,APR-76
	CLEARM	SECSAV		;[063] CLEAR SECTION NAME SAVED
;**;[100] conditionalize TOPS10 code @ ret+17 ma 28-aug-77
ife tops20,<
	SKPINL			;CLEARS THE EFFECT -
	JFCL>			;   OF ^O, end of conditional
;**;[100] add native code @ ret+17 ma 28-aug-77
ifn tops20,<
	push	p,tf		;[100]save tf
	push	p,r		;[100]save r
	hrrzi	tf,.priou	;[100]get terminal output designator
	rfmod			;[100]get terminal JFN word
	tlz	r,(tt%osp)	;[100]clear ^o effects
	hrrzi	tf,.priou	;[100]get terminal output designator
	sfmod			;[100]set new JFN word
	pop	p,r		;[100]restore r
	pop	p,tf>		;[100]restore tf, end of conditional
	LINE
	PUSHJ	P,OVRLAY	;HAS AN OVERLAY OCCURED

;00] delete/modify @ comcon-10 ma 29-aug-77
	pushj	p,readcm	;prompt and read user command
	JUMPE	T2,RET		;NO SIGNIFICANT INFORMATION

	MOVEM	T2,COMAND	;SAVE USER COMAND
	JUMPN	T1,BADSYN	;COMMAND TERMINOLOGICAL INEXACTITUDE

	SKIPGE	T1,TERMK	; SPACE IS NOT EOL
	TLZA	F,EOL		;CLEAR EOL FLAG
	TLO	F,EOL		;SET EOL FLAG
				;NOW SEE WHAT USER WANTS!
	PAGE
;	ENTER WITH SIXBIT USER COMMAND IN T2
;
;	EXIT TO COMMAND IF RECOGNISED AND UNIQUE, OTHERWISE
;	DISPATCH TO UNKNOWN OR COMMAND NOT UNIQUE ROUTINES
;	N.B.    T1 = DISPATCH ADDRESS
;		T2 = USER COMMAND NAME
;		T3 = OFFICIAL COMMAND NAME

COMCON:	MOVE	T2,COMAND	;GET USER COMMAND IN T2
	MOVEI	P3,DISP		;START OF DISPATCH TABLE
	MOVE	P4,[XWD -DISPL,COMTAB]	;STEP THRO COMMANDS
	MOVE	T1,T2		;COPY USER COMMAND
	SETOI	T4,		;SET ALL ONES MASK
	LSH	T4,-6		;SET MASK IN
	LSH	T1,6		;      T4 TO LENGTH OF
	JUMPN	T1,.-2		;              USER COMMAND
	MOVEI	AR,0		;NO. OF NON-UNIQUE OCURRENCES
	MOVE	T1,P4		;AOBJN FOR COMMAND TABLE
COMLP:	MOVE	T3,(T1)		;GET NEXT COMMAND
	TDZ	T3,T4		;MASK OUT FOR MATCH WITH USER
	CAMN	T2,(T1)		;EXACT MATCH?
	JRST	COMFND		; YES - THIS IS IT

	CAME	T2,T3		;MATCH SO FAR
	JRST	COMNEQ		;NO MATCH AT ALL

	AOS	AR		;FLAG ANOTHER MATCH
	HRL	P3,T1		;MARK LAST INDEX
COMNEQ:	AOBJN	T1,COMLP	;TRIED ALL KNOWN COMMANDS?

	JUMPN	AR,.+2		;UNKNOWN?
	AOS	T1		;SET FOR NONE UNIQUE
	CAIN	AR,1		;WAS THE COMMAND UNIQUE?
	HLR	T1,P3		;YES - REMEMBER THIS INDEX
COMFND:	MOVE	T3,(T1)		;SAVE OFFICIAL COMMAND NAME
	SUBI	T1,(P4)		;INDEX DOWN DISPATCH
	ADDI	P3,(T1)		;INDEX INTO DISPATCH
	MOVE	T1,(P3)		;GET DISPATCH ADDRESS
	JRST	@T1		;     DISPATCH
	PAGE
	SUBTTL	COMMAND DECODER



	DEFINE C(A,B)
<	SIXBIT/A/	>


COMTAB:	XLIST		;NAMES
	NAMES
	LIST

DISPL=.-COMTAB




	DEFINE C(A,B)
<	EXP	B	>


DISP:	XLIST		;HANDLERS
	NAMES
	EXP	NOTUNQ		;COMMAND NOT UNIQUE
	EXP	ERROR		;UNKNOWN COMMAND
	LIST
	PAGE
SUBTTL	COMMAND SERVICE MODULES


;STRACE - SUBROUTINE CALLING SEQUENCE TRACE (WALK-BACK)

TRACE:	HRRZ	T,STARTU	;USER MUST INITIALISE WITH START
	JUMPE	T,ERR4		;MUST TYPE START FIRST
	SKIPIF	(TRACE.)	;
	  POPJ	P,		;NO TRACE LOADED
	SKIPN	ESCAPE		;ARE WE ALLOWING ESCAPES
	JRST	ERR30		;NO TRACE
	MOVE	T,P		;SAVE FORDDT STACK PIONTER
	MOVE	T1,16		;SAVE FORDDT REG 16??
	MOVE	P,AC0+17	;SET UP FORTRAN STACK
	MOVE	16,AC0+16	;- AND REG 16
	PUSHJ	P,@GOLOC	;DO A FORTRAN TRACE
	MOVE	P,T		;MUST RESTORE FORDDT STACK
	MOVE	16,T1		;AND 16
	JRST	RET		;END OF TRACE
	PAGE
;	START FUNCTION

START:	MOVSI	T,(JFCL)	;RESET THE TRACE ENTRY
	MOVEM	T,FDDT.		;
;**;[75] insert @ start2-1 ma 22-aug-77
	PUSHJ	P,CLRLIN	;[75]FLUSH OUT LINE BUFFER
START2:	MOVE	T,PRGNAM	;GET THE MAIN PROGRAM NAME
	MOVEM	T,SYM		;SAVE FOR EVAL
	TLO	F,FPRNM		;LOOK FOR PROGRAM NAMES
	PUSHJ	P,FNDSYM	;FIND THE START
	   JRST	ERR8		;NO START ADDRESS
	HRRM	T,STARTU	;SAVE FOR GO
	MOVEM	F,STKYFL	;MAKE THE FOROTS FLAG STICK
	PUSHJ	P,RE.NTR	;ALLOW RE-ENTERS AGAIN
	PUSHJ	P,INSRTB	;PUT IN BREAKPOINTS
	JSP	T,RESTORE
	SETZI	16,		;MAKE F40 STRACE WORK
STARTU:	JRST	.-.		;START USER PROGRAM


;	GOTO  STATEMENT LABEL OR SYMBOL CONTENTS

GOTO:	JUMPL	F,START4	;NO ARGUMENTS = START AT LAST GOTO
	PUSHJ	P,SYMIN		;GET USERS ARGUMENT
	  JRST	ERR6		;NONE SUCH
	  CAIA			;NUMERIC
	MOVE	T,(T)		;GET CONTENTS
	PUSHJ	P,ONFORM	;ON A FORMAT STATEMENT?
	  JRST	ERR36		;YES - ERROR
	PUSHJ	P,CHKADR	;DO A CHECK OF USER AREA
	 JRST	ERR31		;ILLEGAL - ERROR
	 JFCL
	CAIA
START4:	HRRZ	T,STARTU	;GET START ADDRESS
	HRRZ	T1,STARTU	;SEE IF A START HAS BEEN DONE
	JUMPE	T1,ERR4		;NO, REFUSE STARTS AND GOTO'S

	MOVEM	T,GOLOC		;SET UP FOR EXTASK
	SETOI	T1,
	MOVSI	T,(POPJ P,)	;HAVE WE STOPPED AFTER A NEXT?
	CAMN	T,LEAV		;IF SO LEAV WILL BE A POPJ P,
	SUBM	T1,AC17		;SOBJN!!!!
	SKIPN	ESCAPE		;HAS A RE ENTER BEEN DONE?
	JRST	ERR30		;YES - ONLY SOME FORM OF CONTINUE ALLOWED
	PUSHJ	P,ONFORM	;SKIP IF NOT A FORMAT AT (T)
	  JRST	ERR24		;NOT ALLOWED
	PUSHJ	P,RE.NTR	;ALLOW RE-ENTERS AGAIN
	MOVSI	T,(JFCL)	;RESET THE TRACE ENTRY
	MOVEM	T,FDDT.		;
	PUSHJ	P,EXTASK	;TRANSFER TO EXTERNAL TASK
	PAGE
;	OPEN

OPEN:	JUMPL	F,OPEN2		;ASSUME MAIN PROG IF JUST 'OPEN'
	PUSHJ	P,TTYIN		;WHAT NEXT
	JUMPN	T1,BADSYN	;MUST BE LINE END DELIMITER
	JUMPE	T2,BADSYN	;MUST HAVE SOME CHARACTERS
	PUSHJ	P,VALID		;CHECK VALIDITY & GET RAD50 IN T3
OPEN3:	MOVEM	T3,SYM		;SAVE FOR 'OPEN'
	PUSHJ	P,SETNAM	;DO THE OPEN
	JRST	RET		;WHAT NEXT

OPEN2:	MOVE	T3,PRGNAM	;GET FORTRAN MAIN PROG NAME
	JRST	OPEN3		;OPEN THIS

;	DDT FUNCTION

DDT:	PROGIF	(UDDT)		;IS DDT LOADED?
	   JRST	ERR11		;NO  - COMPLAIN
	HRRZM	T,GOLOC		;SAVE ADDRESS
	JRST	EXTASK		;TRANSFER TO EXTERNAL TASK

;	EXIT FUNCTION

EX.:	JUMPGE	F,EX.R		;IS THE USER REQUESTING A MONITOR RETURN
	HRRZ	T,STARTU	;NO - SEE IF A START HAS BEEN DONE
	JUMPN	T,.+2
;**;[100] modify @ ex.+3 ma 28-aug-77
	jrst	ex.a		;JUST A NORMAL EXIT
	MOVE	T,STARTU	;REMOVE START ADDRESS SO-
	HLLZM	T,STARTU	;NO CONTINUES OR RE-ENTERS
	SKIPIF	(EXIT.)		;IS EXIT. LOADED?
;**;[100] modify @ ex.+7 ma 28-aug-77
	   jrst	ex.a		;MUST BE THERE????
	SETZM	TEM		;SET UP ARG BLOCK
	SETZM	TEM1		;  TO EXIT FOROTS
	PUSHJ	P,INSRTB	;REPLACE PAUSES
	JSP	T,RESTORE	;RESTORE USERS ACS
	MOVEI	16,TEM		;GET EXIT ARGBLOCK
	PUSHJ	P,@GOLOC	;DO A FOROTS EXIT

EX.R:	PUSHJ	P,TTYIN		;GET NEXT INPUT
	JUMPN	T2,BADSYN	;LOOKING FOR / - NOCHARACTERS ALLOWED
	JUMPE	T1,BADSYN	;BETTER BE /
	CAIE	T1,"/"
	JRST	BADSYN		;SORRY
	PUSHJ	P,TTYIN		;LOOK FOR RETURN
	JUMPN	T1,BADSYN	;NO MORE CHARACTERS ALLOWED
	JUMPE	T2,BADSYN	;NO CHARACTERS IN INPUT????
	LSHC	T1,6		;GET FIRST CHARACTER
	CAIE	T1,'  R'	;LOOK FOR 'RETURN' - IMPLIED BY R
	JRST	BADSYN		;WE DONT UNDERSTAND ANY OTHER CHARACTER
;**;[100] add TOPS10 conditional and native code @ ex.r+13
ife tops20,<
	CALLI	1,12>		;DO A MONRET
ifn tops20,<
	haltf>			;do a monret
	JRST	RET		;CONTINUE'S ALLOWED
;**;[100] add routine ex.a @ ovrlay-1 ma 28-aug-77
ife tops20,<
ex.a:	exit>			;do a non-returnable return
ifn tops20,<
ex.a:	reset			;close files, etc.
	haltf			;stop
	jrst	ex.a>		;and don't permit continues
	PAGE
;	ROUTINE OVERLAY - TO DETECT WHEN THERE HAS BEEN AN APPARENT
;	OVERLAY OF THE PROGRAM.	THIS IS DONE BY OBSERVING THE
;	VALUES OF .JBSA AND .JBSYM EVERY RETURN TO USER MODE (>>)

OVRLAY:	MOVE	T,.JBSYM	;GET THE SYMBOL TABLE PARAMETERS
	EXCH	T,JOBSYM	;SAVE NEW SYMBOL POINTERS
	JUMPE	T,OVRL4		;OLD VALUE COULD BE ZERO IF NOT INITED
	CAME	T,JOBSYM	;COMPARE WITH LAST KNOWN VALUE
	JRST	OVRL2		;SOMETHING CHANGED!!

OVRL4:	HRRZ	T,.JBSA		;GET THE START ADDRESS
	EXCH	T,JOBSA		;SAVE NEW - AND FIND OLD START ADDRESS
	JUMPE	T,CPOPJ		;EXIT IF OLD START NOT SET-UP
	CAMN	T,JOBSA		;HAS THIS CHANGED
	POPJ	P,		;ALL IS WELL

OVRL2:	LINE
	TYPE(%FDTPOV PROGRAM OVERLAYED)
;**;[100] conditionalize TOPS10 code @ ovrl2+2 ma 29-aug-77
ife tops20,<			;[100]this doesn't work under TOPS20
	MOVE	T,[XWD -1,3]	;SET FOR PROGRAM NAME
	GETTAB	T,>		;FIND THE CURRENT NAME,end of conditional
	JRST	OVRL3		;SECRETIVE TYPE??
	SKIPN	JOBNAM		;HAS ANY NAME BEEN STORED?
	MOVEM	T,JOBNAM	;NO - REMEMBER THIS
	CAMN	T,JOBNAM	;OVERLAYED BY SYSTEM WHICH DOSN'T CHANGE NAME?
	JRST	OVRL3		;YES

	MOVEM	T,JOBNAM	;REMEMBER NEW NAME
	TYPE( BY )
	PUSHJ	P,SIXBP		;OUTPUT PROGRAM NAME

OVRL3:	TYPE( ***)
	LINE
	SKIPN	T,JOBOPC	;ANY RE-ENTER ADDRESS?
	MOVE	T,BCOM		;IF NOT BCOM SHOULD BE USER BREAK
	HRRZ	T,T		;JUST THE ADDRESS THANK YOU
	PJRST	WHERE		;TELL WHERE - END OF OVERLAY
	PAGE
;	RE-ENTER LOGIC

RE.ENT:	MOVEM	P,SAVLOC	;FREE UP A SPARE REG
	HRRZ	P,.JBOPC	;GET THE BREAK P.C.
	SKIPE	ESCAPE		;RE-ENTERS ALLOWED ONCE(SEE ER.ENT)
	JRST	RE.BRK		;DONT DESTROY USER PROFILE

	MOVE	P,SAVLOC	;RE-INSTATE THE OLD REG
	JSR	SAVE		;SAVE THE EXTERNAL PROG STATUS
	PUSHJ	P,REMOVB	;AND REMOVE THE PAUSES
	MOVE	T,.JBOPC	;GET THE PROG P.C.
	MOVEM	T,JOBOPC	;STORE AND FLAG THAT WE ARE HANDLING RE-ENTER
	MOVEM	T,JOBBRK	;SAVE THE JOB BREAK LOCATION
	HRRM	T,STARTU	;ALLOW CONTINUES TO WORK
	MOVEI	T,ER.ENT	;CLOSE THE DOOR ON FURTHER ENTRIES
	MOVEM	T,.JBREN	;LIKE SO
	SKIPE	PRGM		;HAS ANY SECTION BEEN OPENED
	JRST	RE.LOC		;YES

	PROGIF(MAIN.)		;NO - SO OPEN MAIN PROG
	  CAIA			;NO SECTION CALLED MAIN.
	PUSHJ	P,SETNAM	;OPEN MAIN PROG IF FOUND

;	HERE TO DISPLAY THE CURRENT SUSPEND POINT
;	JOBBRK IS THE BREAK - NEED NOT = JOBOPC

;**;[100] insert/modify @ re.loc ma 28-aug-77
RE.LOC:				;CLEAR THE OUTPUT BUFFER
ife tops20,<
	clrbfo	>
ifn tops20,<
	push	p,tf
	hrrzi	tf,.priou
	cfobf
	pop	p,tf	>
	TYPE([ PROGRAM SUSPENDED )
	HRRZ	T,JOBBRK	;SET UP THE ACTUAL SUSPEND POINT
	PUSHJ	P,WHERE		;TELL USER WHERE HE IS SUSSPENDED
	TYPE(OPEN SECTION: )
	MOVE	T,OPENED	;WHAT IS THE CURRENTLY OPEN SECTION
	PUSHJ	P,SPT1		;TYPE THAT
	TYPE	( ])
	MOVE	F,STKYFL	;RESET THE FLAG REGISTER
	JRST	RET		;RETURN TO NORMAL WORKING

	PAGE
ER.ENT:	SETPDL			;RESET THE PDL
	JRST	RE.LOC		;INDICATE THAT WE ARE ALREADY HANDLING A REENTER

RE.NTR:
IFN FT$TYM,<IF2,<PRINTX [Preserving REENTER address]>
	HRRZ	T,.JBREN	;[JMS] Pick up current setting
	JUMPE	T,RE.NT1	;[JMS] Proceed if currently zero
	CAIL	T,DDTBEG	;[JMS] Within FORDDT?
	CAILE	T,DDTEND	;[JMS]
	 SKIPA	T,.JBREN	;[JMS] No, keep both halves the same
RE.NT1:	>  ;End of IFN FT$TYM
	MOVEI	T,RE.ENT	;AND SET UP THE RE-ENTER ADDRESS
	MOVEM	T,.JBREN	;SO THAT FUTURE RE ENTERS WILL WORK
	SETZM	JOBOPC		;CLEAR THE RE-ENTER IN PROGRESS FLAG
	SETZM	ESCAPE		;DO NOT ALLOW ESCAPES FROM FORDDT
	POPJ	P,

RE.BRK:	SETPDL			;RESTORE THE STACK
	HRRZ	T,STARTU	;HAS A START BEEN DONE
	JUMPE	T,RE.RET	;NO - JUST RETURN TO FORDDT USER MODE

	MOVE	T,BCOM		;GET THE PAUSE POINT
	MOVEI	T,-1(T)		;CORRECT FOR JSA
	ANDI	T,-1		;JUST THE ADDRESS PORTION
	MOVEM	T,JOBBRK	;SAVE THE JOB BREAK FOR RE.LOC
	JRST	RE.LOC		;DISPLAY PROGRAM EXECUTION SUSPENSION


;	ROUTINE TO DISPLAY WHERE THE PROGRAM IS SUSPENDED

WHERE:	SKIPN	.JBHRL		;SKIP IF WE HAVE A HIGH SEG.
	JRST	RE.L2

	CAMLE	T,.JBREL	;ARE WE SUSPENDED OVER THE LOW SEG.
;**;[100] modify @ where+3 ma 27-aug-77
	JRST	[type(IN HIGH SEGMENT)
		JRST	RE.L2]
	type(IN LOW SEGMENT)
RE.L2:	TYPE( AT )
	TLO	F,FGLSNM	;GLOBALS ARE OK
	PUSHJ	P,LOOK		;DO A SYSMBOL 'LOOK'-UP
	  JRST	E6		;
	  CAIA			;NOTHING TYPED
;**;[070], RE.L2+5, MD, AUG-76
	JRST	RE.L3A		;[070] FOUND AND TYPED
	MOVEM	T,TEM		;REMEMBER NEAREST REFERENCE
	PUSHJ	P,SPT		;TYPE THE SYMBOL
	TYPE( + )
	MOVE	T,TEM		;GET THE OFFSET
	PUSHJ	P,TYP4		;DISPLAY AS OCTAL
;**;[070], RE.L2+13, MD, AUG-76
RE.L3A:	SKIPN	PNAMSV		;[070] DID WE FIND A SECTION NAME
	JRST	RE.L3		;[070] NO
	TYPE( IN )
	MOVE	T,PNAMSV	;GET THE SECTION NAME
	PUSHJ	P,SPT1		;DISPLAY THAT
RE.L3:	LINE			;
	POPJ	P,		;
	PAGE
;	PAUSE LOGIC

;**;[77] modify @pause ma 22-aug-77
PAUSE:	JUMPL	F,PSEALL	;[77]DISPLAY ALL PAUSES IF NO ARGUMENTS
	TRO	TF,FGLONL	;FIND GLOBAL SYMBOL ONLY
	PUSHJ	P,SYMIN		;GET THE NEXT SYMBOL IN SYM
	   JRST	ERR6		;NONE SUCH!
	   CAIA			;STATEMENT # FROM USER
	JRST	PAUS10		;SYMBOL - MEANS STOP AT ROUTINE

PAUS11:	HRRZM	T,TEM1		;SAVE POINTER TEMPORARILY
	SETZM	TEM		;CLEAR CONDITIONAL REQUEST
	SKIPL	TERMK		;WAS THAT ALL THE USER WANTED?
	JRST	PAUS5		; YES

	PUSHJ	P,TTYIN		; NO,GET MOR
	JUMPN	T1,BADSYN	;DO WE HAVE A LEGAL DELIMITER
	CAMN	T2,[SIXBIT/AFTER/]	;FORCE USER TO TYPE WHOLE WORD
	JRST	PAUS4		;AFTER REQUESTED
	CAMN	T2,[SIXBIT/TYPING/]	;MAYBE A 'TYPING' REQUEST
	JRST	PAUS7
	CAME	T2,[SIXBIT/IF/]	;WAS IT 'IF'?
	JRST	BADSYN		;ANYTHING ELSE MEANS TROUBLE
	TLZ	F,CONS		;CLEAR CONSTANT SEEN FLAG
	PUSHJ	P,EITHER	;NUMBER OR SYMBOL SHOULD FOLLOW
	  PUSHJ	P,NUMB		;CONSTANT SEEN
	  MOVEM	T,COND1		;SAVE CONSTANT
	CLEARM	COND0		;CLEAR FOR TYPE OF TEST
	JUMPN	T1,.+2		;DELIMITER?
	PUSHJ	P,GETSKB	;NEXT CHARACTER
	CAIE	T1,"."		;MUST BE . OF .EQ. ETC
	JRST	BADSYN
	PUSHJ	P,TTYIN		;GET SIXBIT STRING
	CAIE	T1,"."		;MUST AGAIN BE TERMINATED BY .
	JRST	BADSYN
	HLRZS	T2,T2		;MORE USEFUL IN RIGHT HALF
	CAIN	T2,'LT '
	JRST	TEST1
	CAIN	T2,'LE '
	JRST	TEST2
	CAIN	T2,'EQ '
	JRST	TEST3
	CAIN	T2,'NE '
	JRST	TEST4
	CAIN	T2,'GT '
	JRST	TEST5
	CAIN	T2,'GE '
	JRST	TEST6
	JRST	BADSYN		;UNKNOWN CONDITION
	PAGE
TEST6:	AOS	COND0		;GE=5
TEST5:	AOS	COND0		;GR=4
TEST4:	AOS	COND0		;NE=3
TEST3:	AOS	COND0		;EQ=2
TEST2:	AOS	COND0		;LE=1
TEST1:	PUSHJ	P,EITHER
	  PUSHJ	P,NUMB		;SAVE AS A NUMBER
	  MOVEM	T,COND2		;SAVE THE LOCATION
	MOVE	T,[JSR	COND]
	MOVEM	T,TEM		;FORM THE (CONDITIONAL TEST) LOCATION LINK
PAUS5:	SKIPA	T,[Z 1]		;PROCEDE COUNT=1
PAUS4:	PUSHJ	P,EITHER	;GET USERS PROCEDE COUNT IN T
	   CAIA			;CONSTANT GIVEN
	   MOVE T,(T)		;SYMBOL - GET CONTENTS
	JUMPL	T,BADSYN	;DO NOT ALLOW NEGATIVE PROCEDE COUNTS
	EXCH	T,TEM1		;GET BACK BREAKPOINT ADDRESS
	SKIPL	TERMK		;WAS THAT ALL
	JRST	PAUS6		; YES

	MOVEM	T,SAVLOC	;SAVE PAUSE ADDRESS TEPORARILY
	PUSHJ	P,TTYIN		;GET SIXBIT USER INPUT
	JUMPN	T1,BADSYN
	CAME	T2,[SIXBIT/TYPING/]
	JRST	BADSYN
PAUS8:	PUSHJ	P,GETNUM	;USER WANTS AUTO DISPLAY
	JUMPN	T,PAUS3		;ASSUME ZERO MEANS NO INPUT

	CAIN	T1,"/"		;A / HERE DENOTES THAT A GROUP# FOLLOWS
	JRST	PAUS8		;TRY FOR THE NUMBER AGAIN

PAUS3:	CAIL	T,1		;MAKE SURE HE GETS
	CAILE	T,GPMAX		;  ONLY A VALID GROUP #
	JRST	ERR15		;COMPLAIN ABOUT GROUP #
	HRL	T,T		;SET UP FOR AUTO TYPE
	HRR	T,SAVLOC	;GET BACK PAUSE ADDRESS
	TLO	F,AUTO		;SET THE AUTO PROCEDE FLAG

PAUS6:	PUSHJ	P,ONFORM	;SKIP IF NOT A FORMAT AT (T)
	  JRST	ERR19
	PUSHJ	P,BPS1		;PLACE ALL PARAMETERS TO EFFECT A PAUSE
	JRST	RET		;DONE!
	PAGE
PAUS7:	SETZI	T,		;CLEAR PROCEDE COUNT
	EXCH	T,TEM1		;GET PAUSE PLACE
	MOVEM	T,SAVLOC	;STORE PAUSE LOCATION
	JRST	PAUS8

PAUS10:	MOVE	T1,@SYMSAV	;GET SYMBOL
	TLNE	T1,700000	;IS THIS A PROGRAM NAME OR GLOBAL
	JRST	ERR19		;NO SO DONT ALLOW

	SKIPE	SUBSCR		;NOR MUST THERE BE AN OFFSET
	JRST	ERR19
	MOVE	T1,1(T)		;DOES THIS ROUTINE INVOKE THE 'HELLO' MACRO?
	CAMN	T1,HELLO	;YES IT DOES - STOP 2 ON
	ADDI	T,2		;
	JRST	PAUS11

COND0:	Z			;SAVE # NUMBER OF TEST
COND1:	Z			;SAVE ADDRESS OF FIRST ARGUMENT
COND2:	Z			;SAVES ADDRESS OF SECOND ARGUMENT
COND3:	Z			;SAVE VALUE OF CONSTANT IF DEFINED

NUMB:	TLOE	F,CONS			;SET CONSTANT SEEN FLAG IF NOT ALREADY SET
	JRST	ERR14
	MOVEM	T,COND3		;SAVE VALUE OF CONSTANT
	MOVEI	T,COND3		;SAVE ADDRESS OF CONSTANT
	POPJ	P,


;	ROUTINE TO CHECK IF A FORTRAN FORMAT EXISTS AT 
;	THE ADDRESS POINTED TO BY T
;	RETURN 1   IF IT IS A FORMAT
;	RETURN 2   IF NOT A FORMAT

ONFORM:	LDB	W1,[POINT 7,(T),6]	;
	CAIN	W1,"("		;TRUE IF FIRST CHAR IS AN OPEN PAREN
	POPJ	P,
	JRST	CPOPJ1		;FOUND A FORMAT STATEMENT REFFERENCE
	PAGE
;	CONTINUE LOGIC


CONTIN:	MOVSI	T,(JFCL)	;RESET THE TRACE ENTRY
	MOVEM	T,FDDT.		;
	HRRZ	T,STARTU	;HAS START BEEN SEEN
	JUMPE	T,ERR4		;N0 - PLIS TYPE START
	SKIPE	T,JOBOPC	;ARE WE IN A RE-ENTER CONDITION
	JRST	CONT2		;YES - DEAL WITH IT

	MOVEI	T,[POPJ P,]	;POPJ P,  IS THE EXIT AFTER A 'NEXT'
	CAMN	T,LEAV		;DID WE DO A 'NEXT' LAST TIME
	JRST	PROCED		;YES - DO NOT TAKE ARGS - RETURN WITH A POPJ

	JUMPL	F,PROCED	;CONTINUE 1
	PUSHJ	P,EITHER	; NO - GET ARGUMENT
	   CAIA			;NUMBER TYPED
	   MOVE	T,(T)		;SYMBOL TYPED - GET CONTENTS
	JUMPL	T,BADSYN	;DO NOT ALLOW NEGATIVE PROCEDE SETTINGS
	JRST	PROCDX		;SET UP A PROCEDE COUNT

CONT2:	MOVE	T,JOBOPC	;GET THE CONTINUE P.C.
	MOVEM	T,GOLOC		;PREPARE TO CONTINUE
	PUSHJ	P,RE.NTR	;ALLOW RE-ENTERS AGAIN
	PUSHJ	P,INSRTB	;PUT BACK PAUSES
	JSP	T,RESTORE	;RESTORE USER ACS
	JRSTF	@GOLOC		;DO AN OFFICIAL RE-ENTER


;**;[100] modify @ help ma 27-aug-77
HELP:	atype(HLPTXT)		;TYPE AN ABREVIATED HELP TEXT
	JRST	RET		;FOR MORE HELP TRY HELP FORDDT?!!
	PAGE
;	REMOVE LOGIC

RESET:	JUMPL	F,RESET5	;'RESET' - RESET ALL PAUSES
	TRO	TF,FGLONL	;FIND GLOBAL ONLY IF NOT LABEL
	PUSHJ	P,SYMIN		; NO - MUST BE ANOTHER SYMBOL TO FOLLOW
	  JRST	ERR6		;SOME ONE SLIPPED UP
	  JFCL			;STATEMENT #
RESET6:	MOVEI	R,B1ADR		;LOOK THRO PAUSE POINTS FOR THE RIGHT ONE
RESET3:	HRRZ	W,(R)		;GET THE PAUSE CONTENTS
	CAIN	W,(T)		;IS THIS IT?
	JRST	RESET2		; YES - REMOVE IT!

	ADDI	R,3		; NO  - TRY ANOTHER
	CAIG	R,BNADR		;TRIED ALL POINTS YET?
	JRST	RESET3		; NO - FIND THE NEXT

	JRST	ERR17		;NO - NOT AN ARRAY NAME -  YOU LOSE

RESET2:	MOVE	W,1(T)		;DOES THIS ROUTINE USE THE HELLO MACRO
	CAMN	W,HELLO		;
	ADDI	T,1		;YES IT DOES - SO STOP 2 ON
	ADDI	T,1		;STOP 1 ON FOR NORMAL ROUTINES
	CLEARM	(R)		;CLEAR LOCATION OF PAUSE
	CLEARM	1(R)		;CLEAR CONDITIONAL CLAUSE
	CLEARM	2(R)		;CLEAR PROCEDE COUNT
	JRST	RET		;REMOVED!

RESET5:	CAME	T2,[SIXBIT/REMOVE/] ;DO NOT ALLOW ABREVIATIONS OF REMOVE
	JRST	BADSYN		;THIS ANNOYS MANY USERS
	PJRST	BPS		;RESET ALL PAUSES
	PAGE
;	ACCEPT LOGIC	= ACCEPT NAME/X #

ACCEPT:	JUMPL	F,BADSYN	;ACCEPT ALONE IS MEANINGLESS!
	SETZM	ARGVAL+1	;CLEAR IN CASE LONG INPUT
	SKIPN	ESCAPE		;ESCAPE TO FOROTS?
	JRST	ERR30		;SORRY
	TRO	TF,ACCPT	;ACCEPT IN PROGRESS
	PUSHJ	P,SYMIN		;GET USERS SYMBOL
	  JRST	ERR6		;SORRY - WE DONT HAVE IT!
	  JRST	ACC2		;STATEMENT # = FORMAT
	MOVEM	T,TEM2		;STORE FOR UPDATE
	TRNE	TF,IMPRNG	;IS THIS AN IMPLIED RANGE?
	PUSHJ	P,DISP14	;YES SETUP RANLIM/RANGE IN CASE OF A RANGE
	PUSHJ	P,EVAL		;SETUP SYMSAV TO POINT TO RAD50 SYMBOL
	 JFCL			;CAN'T HAPPEN!!?
	MOVE	T,SYMSAV	;GET THE SYMBOL POINTER
	HLRZ	T,(T)		;GET RADIX 50 FORM AND FLAGS
	TRNN	T,LOCAL		;ALLOW ONLY LOCAL VARIABLS TO CHANGE
	JRST	ERR24		;YOU LOOSE
	MOVE	T1,LSTCHR	;RESTORE USERS LAST CHARACTER

;	HERE HAVING READ A GOOD VARIABLE	= ACCEPT NAME/

	SKIPL	TERMK		;END OF LINE SEEN?
	JRST	BADSYN		;YES - BAD NEWS
	JUMPE	T1,ACCF		;SPACE DELIMITER ASSUMES REAL TO FOLLOW
	CAIN	T1,"="		;[50] ALLOW = AS DELIMITER
	JRST	ACCF		;[50]
	CAIN	T1,"-"		;A - MEANS A RANGE OF VALUES TO SET
	JRST	ACC23		;
	CAIE	T1,"/"		; WE EXPECT ONLY / FROM NOW ON
	JRST	BADSYN		;ANYTHING ELSE LOOSES
ACC22:	PUSHJ	P,TTYIN		;READ ARGUMENT TYPE REQUIRED BY USER
	JUMPE	T2,BADSYN	;NO CHARACTERS - BAD
	LDB	T,[POINT 6,T2,5];GET 1ST. CHARACTER TO IDENTIFT ARG TYPE
	CAIN	T,'L'		; LONG SWITCH ?
	TLOA	TMOD,L.		;YES - SET IT AND LOOK FOR ANOTHER SWITCH
	MOVEM	T,TEM		;NOT 'LONG' SO SAVE SWITCH IN CASE L FOLLOWS
	JUMPE	T1,ACC21	;NOTHING FOLLOWS
	CAIN	T1,"="		; ALLOW = AS DELIMITER
	JRST	ACC21		;PROCESS FORMAT
	CAIE	T1,"/"		;ANOTHER SWITCH ?
	JRST	BADSYN		;NO - ONLY / ALLOWED
	JRST	ACC22		;PROCESS ANOTHER SWITCH
	PAGE
;	HERE HAVING READ ALL THE MODE SWITCHES
;	THE LAST SWITCH TAKES PRIORITY (/F/D/C/I/O/A/R) /L ALLOWED
;	ACCEPT NAME/L/I

ACC21:	MOVE	T,TEM		;GET THE CURRENT FORMAT REQUEST
	CAIN	T,'S'		;SYMBOLIC?
	JRST	ACCS		;DO SYMBOL INPUT
	CAIN	T,'A'		;ASCII?
	JRST	ACCA		;PROCESS ASCII
	CAIN	T,'R'		;RASCII?
	JRST	RASCII		;PROCESS RIGHT JUSTIFIED ASCII
	CAIN	T,'O'		;OCTAL?
	JRST	ACCO		;PROCESS OCTAL
	TLZ	TMOD,L.		;IGNORE /LONG FOR THE REST
	CAIN	T,'F'		;FLOATING?
	JRST	ACCF		;PROCESS A FLOATING INPUT
	CAIN	T,'D'		;REAL*8?
	JRST	ACCD		;PROCESS REAL*8
	CAIN	T,'I'		;INTEGER?
	JRST	ACCI		;PROCESS INTEGER INPUT
	CAIN	T,'C'		;COMPLEX?
	JRST	ACCC		;PROCESS COMPLEX INPUT
	JRST	BADSYN		;NO OTHER TYPES SUPPORTED

;	ACCEPT A RANGE PROCESSING	= ACCEPT NAME(X)-

ACC23:	MOVE	T,TEM2		;SAVE THE FIRST VALUE SOMEWHERE SAFE
	MOVEM	T,RANGE		;SAVE THE FIRST VALUE OF A RANGE
	TLZ	F,GRPFL		;MAKE SURE WE DONT DO GROUP LOGIC
				;OR ACCEPT ANY PRINT MODIFIERS
	PUSH	P,MATHSM	;SAVE CURRENT SYMBOL
	PUSHJ	P,SYMIN		;GET THE NEXT VALUE
	  JRST	ERR6		;DOSNT EXIST
	  JRST	BADSYN		;NUMERICS????
	POP	P,T3		;GET FIRST SYMBOL BACK
	CAME	T3,MATHSM	;ARE THEY THE SAME
	JRST	ERR40		;NO - SORRY
	CAML	T,RANGE		;SORT OUT THE RANGE ORDER
	EXCH	T,RANGE		;WRONG WAY ROUND
	MOVEM	T,TEM2		;LOWER VALIUE IN RANLIM, HI IN RANGE
	PUSHJ	P,EVAL		;GET SYMBOL IN SYMSAV
	 JFCL			;
	MOVE	T,SYMSAV	;GET THE SYMBOL POINTER
	HLRZ	T,(T)		;GET SYMBOL FLAGS
	TRNN	T,LOCAL		;MODIFY LOCALS ONLY
	JRST	ERR24		;NOT ALLOWED
	MOVE	T1,LSTCHR	;RESTORE USERS LAST CHARACTER
	CAIN	T1,"/"		;MAYBE FORMAT SPECIFIER
	JRST	ACC22		;YES - GO FIND THEM
	JUMPE	T1,ACCF		;SPACE IMPLIES REAL*4
	JRST	BADSYN		;DONT ACCEPT ANYTHING ELSE HERE
	PAGE
;	*** FLOATING INPUT ***

ACCF:	TLO	TMOD,F.		;DISPLAY TO USER AS FLOATING
	MOVEI	T2,4		;ARG TYPE REAL FOR FOROTS
	PUSHJ	P,FORINP	;YES - ASK FOROTS FOR INPUT

;	HERE TO PLACE ALL ACCEPTED VALUES

ACC10:	MOVE	T,ARGVAL	;LETS SEE WHAT FOROTS HAS BEEN UP TO
ACC13:	MOVEM	T,@TEM2		;PLACE VALUE WHERE USER REQUESTED
	MOVEM	T,ARGVAL	;SOME PRINT OPTIONS NEED THIS
	AOS	T1,TEM2		;NEXT ARRAY LOCATION
	TLNN	TMOD,C.!L.!D.	;IF EITHER COMPLEX REAL*8 OR LONG OR -
	TRNE	F,DOUBLE	;WE HAVE A REAL*8 ARRAY?
	CAIA			;THEN WE PLACE TWO ARGUMENTS
	JRST	ACC14		;IF NOT THEN CHECK THE RANGE CONDITION
	TRO	F,SILENT	;QUIET
	PUSH	P,MATHSM	;SAVE CURRENT SYMBOL
	MOVE	T,[SQUOZE 0,.VEND]	;END OF VARIABLE AREA
	MOVEM	T,MATHSM	;ONLY ACCEPTABLE SYMBOL
	MOVE	T,TEM2		;GET DESTINATION
	PUSHJ	P,LOOK		;FIND A SYMBOL FOR IT
	  JFCL			;NONE-OK
	  CAIA			;OFFSET - OK
;	 JRST	ACC37		;  NONE - OK
;	 JRST	ACC37		;  OFFSET - OK
;	MOVE	T,(W1)		;GET SYMBOL
;	TLZ	T,PNAME		;NO BITS
;	CAMN	T,[SQUOZE 0,.VEND]	;END OF VARIABLE AREA?
	JRST	ERR35		;YES - ERROR

;ACC37:	
	POP	P,T
	MOVEM	T,MATHSM	;RESTORE CURRENT SYMBOL
	MOVE	T,ARGVAL+1	;GET THE 2ND WORD
	MOVEM	T,@TEM2		; - AND PLACE IN NEXT LOCATION
	AOS	T1,TEM2		;YES - SO NEXT DOUBLE WORD
ACC14:	SKIPN	RANGE		;ACCEPT A RANGE ?
	JRST	ACCPUT		;NO - UNLESS IMPLIED
	TLNE	TMOD,A.		;SPECIAL TREATMENT FOR ASCII ARRAYS
	JRST	[CAMG	T1,RANGE	;END OF ARRAY?
		 JRST	ACC12		;GET SOME MORE
		 JRST	RET	]	;QUIT
	CAMG	T1,RANGE	;ALL DONE ?
	JRST	ACC10		;NO - KEEP GOING
	JRST	RET		;ALL OVER

;	VARIABLE 'ACCEPT'ED - NOW CONFIRM TO USER

ACCPUT:	SETZM	TERMK		;PREPARE FOR -
	SETZM	RANGE		;  INPUT CONFIRMATION
	SOS	T,TEM2		;REMOVE OFFSET FROM ACC13
	TRZN	F,DOUBLE	;CHECK FOR ANY -
	TLNE	TMOD,C.!L.!D.	;  DOUBLE WORD WORKING
	SOS	T,TEM2		;    AND IF SO CORRECT BASE ADDRESS
	PUSHJ	P,DISP10	;AND LET HIM SEE HIS EFFORTS
	JRST	RET		;END OF ACCEPT
	PUSHJ	P,GETNUM	;GENERAL GET NUMBER ROUTINE
	JRST	ACC13		;STORE FOR USER
	PAGE
;	*** DOUBLE PRECISION INPUT ***

ACCD:	TLO	TMOD,D.		;DISPLAY TO USER AS REAL*8
	MOVEI	T2,10		;ARG TYPE FOR REAL*8
	PUSHJ	P,FORINP	;REQUEST INPUT
	JRST	ACC10		;PLACE FINAL ARG


;	*** INTEGER INPUT ***

ACCI:	TLO	TMOD,I.		;DISPLAY TO USER AS INTEGER
	MOVEI	T2,2		;GET ARG TYPE INTEGER FOR FOROTS
	PUSHJ	P,FORINP	;GO TO FOROTS
	JRST	ACC10		;PLACE ARG FOR USER

;	*** COMPLEX INPUT ***

ACCC:	TLO	TMOD,C.!L.	;DISPLAY TO USER AS COMPLEX
ACC11:	PUSHJ	P,GETSKB	;GET SIGNIFIGANT CHARACTER
	CAIE	T1,"("		;MAKE SURE ITS A (
	JRST	ERR32		; ( REQUIRED
	MOVE	T,[1200,,ARGVAL+1]  ;WHERE TO PUT IMAGINARY OF COMPLEX
	MOVEM	T,M2.I		;SET UP THE FORMAT
	MOVEI	T2,4		;SET UP FOR TYPE REAL INPUT
	PUSHJ	P,FORINP	;LET FOROTS GET THE REAL PART
	MOVE	T,M2.F		;RECOVER THE FIN CALL
	MOVEM	T,M2.I		;AND REMOVE THE COMPLEX SETTING
	JRST	ACC10		;GO PLACE THE RESULTS

;	*** SYMBOLIC INPUT ***

ACCS:	TLNE	TMOD,L.		;IF 'LONG' SET THEN
	TLOA	TMOD,C.		;DISPLAY TO USER AS TWO REAL*4
	TLO	TMOD,F.		;ELSE DISPLAY JUST ONE REAL*4
	PUSH	P,MATHSM	;SAVE MATHSM
	PUSH	P,SAVLOC	;SAVE SAVLOC AROUND CALL
	PUSHJ	P,SYMIN		;GET A USER SYMBOL
	  JRST	ERR6		;CAN'T FIND IT!
	  JRST	BADSYN		;DONT GIVE ME STATEMENT #
	POP	P,SAVLOC	;RESTORE SAVLOC
	POP	P,MATHSM	;RESTORE
	MOVE	T1,(T)		;I'LL ACCEPT THAT ONE
	MOVEM	T1,ARGVAL	;SAVE THE FIRST WORD VALUE
	TLNN	TMOD,L.		;DOUBLE WORD WORKING?
	JRST	ACC10		;NO JUST PLACE SINGLE VALUE
	MOVE	T,1(T)		;GET SECOND VALUE
	MOVEM	T,ARGVAL+1	;STORE THAT
	JRST	ACC10		;   AND EVEN STORE IT
	PAGE
;	*** ASCII INPUT RIGHT JUSTIFIED ***

RASCII:	TLO	TMOD,R.		;DISPLAY TO USER AS RASCII
	JRST	ACC1		;DO ASCII INPUT TO T


;	*** ASCII INPUT ***

ACCA:	TLO	TMOD,A.		;DISPLAY TO USER AS ASCII
	MOVE	T,[ASCII .     .]	;BLANK SECOND WORD FOR POSSIBLE
	MOVEM	T,ARGVAL+1		;LONG OR DOUBLE
	SKIPN	RANGE		;IGNORE /LONG IF ACCEPTING LONG ASCII
	JRST	ACC1		;OK IF NOT A RANGE
	TLZ	TMOD,L.		;CLEAR /L FLAG
	TRZ	F,DOUBLE	;CLEAR DOUBLE
ACC1:	PUSHJ	P,GETSKB	;GETA SIGNIFICANT USER CHARACTER
	SKIPL	TERMK		;EOL?
	JRST	BADSYN		;YES - SYNTAX ERROR
	MOVEI	T5,(T1)		;SAVE IN T2
ACC12:	SETZM	ARGVAL		;CLEAR FOR DOUBLE LENGTH ASCII
	TRZE	TF,ADELIM	; IF SET WE CLEAR THE REST OF THE ARRAY
	JRST	ACCA2		;
ACC24:	MOVE	T,[ASCII .     .]	;T BUILDS ASCII INPUT
	TLNE	TMOD,R.		;BUILD WITH ZERO IF RASCII
	SETZI	T,
	MOVE	T6,[POINT 7,T]	;STORES BYTES IN T
;**;[100] modify @ acc15 ma 29-aug-77
ACC15:	pushj	p,loadch	;NEXT ASCII CHARACTER
	CAIN	T1,(T5)		;TEXT DELIMITER FOUND?
	JRST	ACC18		;YES - CHECK FOR A SECOND
	TRZE	TF,ADELIM	;WAS THE LAST CHARACTER OUR DELIMITER
;**;[065],ACC15+4,MD,APR-76
;**;[100] modify @ acc15+4 ma 29-aug-77
	JRST	[PUSH P,T1		;[065] YES
		 MOVE T1,[pushj p,loadch];[065] FOR GETSKB
		 MOVEM	T1,GETCHR	;[065]
		 POP	P,T1		;[065]
		 PUSHJ	P,GETSK2	;[065] CHECK FOR COMMENT
		 PUSHJ P,CLRLIN	; WIND UP
		 JRST	ACC17]
ACC19:	IDPB	T1,T6		;SAVE USERS TEXT
	TLNE	T6,760000	;FILLED T?
	JRST	ACC15		;NO - TAKE MORE

	CAIA			;DONT CONFUSE THE INDEFINATE ACCEPT
ACC17:	TRO	TF,ADELIM	;SET TO CLEAR REST OF ARRAY IF IN A RANGE
	TRNE	F,DOUBLE	;TEST FOR ANY DOUBLE WORD -
	JRST	ACC2WD		;  WORKING -
	TLNN	TMOD,L.		;    IMPLIED BY REAL*8 OR L.
	JRST	ACC20		;STORE FINAL SINGLE VALUE IN T
	PAGE
;	DOUBLE WORD WORKING

ACC2WD:	SKIPN	ARGVAL		;IS THE FIRST VALUE STOREF?
	JRST	ACC3WD		;NO
	MOVEM	T,ARGVAL+1	;YES STORE SECOND
	JRST	ACC25		;PLACE BOTH VALUES
ACC3WD:	MOVEM	T,ARGVAL	;HOLD FIRST OF PAIR
	TRNN	TF,ADELIM	;ANY MORE TO COME
	JRST	ACC24		;YES - GO FIND IT
;**;[76] insert @ acc25 ma 22-aug-77
ACC25:	HRRZM	T5,DELCHR	;[76]SAVE DELIMITER FOR CLRLIN
	PUSHJ	P,CLRLIN	;CLEAR REST OF LINE
	TLNN	TMOD,R.		;ARE WE ACCEPTING RIGHT JUSTIFIED TEXT
	JRST	ACC10		;RELAX JUST ASCII
	MOVE	T1,ARGVAL	;GET BACK THE DOUBLE WORD
	JUMPE	T1,ACC10	;NO TEXT?????
	MOVE	T2,ARGVAL+1	;INTO A LONG SHIFT FORM
	LSH	T1,-1		;FIRST MAKE A CONTINUOUS STRING OF TEXT
	LSHC	T1,-1		;GET READY FOR 7BIT CHARACTER SHIFTS
ACC27:	LDB	T3,[POINT 7,T2,35]
	JUMPN	T3,ACC26	;TEST FOR SUCCESSFUL RIGHT JUSTIFICATION
	LSHC	T1,-7		;NOT YET MOVE DOWN
	JRST	ACC27		;TRY AGAIN
ACC26:	LSH	T1,1		;ASCII-ISE
	TLZE	T2,400000	;SHOULD THERE BE A LOWER BIT FOR T1
	TRO	T1,1		;YES - PUT IT IN
	MOVEM	T1,ARGVAL	;STORE TOP VALUE
	MOVEM	T2,ARGVAL+1	;AND FINALLY LAST VALUE
	JRST	ACC10		;AND GIVE THEM TO THE USER

ACC18:	TRON	TF,ADELIM	;FLAG THIS AS OUR DELIMITER
	JRST	ACC15		;SEE IF NEXT CHARACTER IS SAME
	TRZ	TF,ADELIM	;YES IT IS -
	JRST	ACC19		;PASS ON JUST ONE

ACCA2:	TLZ	TMOD,A.!R.	;REMOVE THE TEXT FLAGS
	MOVE	T,[ASCII .     .]	;FILL THE REST OF THE ARRAY
	MOVEM	T,ARGVAL	;WITH SPACES
	MOVEM	T,ARGVAL+1
	JRST	ACC13


;	FINISHED TEXT INPUT

;**;[76] insert @ acc20 ma 22-aug-77
ACC20:	HRRZM	T5,DELCHR	;[76]SAVE DELIMITER FOR CLRLIN
	SKIPN	RANGE		;IF NOT IN A RANGE SETTING -
	PUSHJ	P,CLRLIN	;THEN CLEAR THE REST OF THE USER INPUT
	TLNN	TMOD,R.		;LEFT OR RIGHT JUSTIFY
	JRST	ACC13		;LEFT
	LDB	T1,[POINT 6,T6,5] ;RIGHT - GET THE T3 POINTER RESIDUE
	SETCA	T1,		;RIGHT SHIFT
	LSH	T,1(T1)		; NOW
	JRST	ACC13		;NOW PLACE TEXT
	PAGE
;	*** OCTAL INPUT ***

ACCO:	TLO	TMOD,O.		;DISPLAY TO USER AS OCTAL
	SETZI	T,		;CLEAR FOR OCTAL BUILD
	SKIPL	TERMK		;END OF LINE SEEN?
	JRST	ACC13		;YES - ASSUME OCTAL = 0
	PUSHJ	P,GETSKB	;LOOK FOR "-"
	SKIPL	TERMK
	JRST	ACC13		;END OF LINE - =0
	SETZB	W1,W2		;CLEAR BUILD AREA
	MOVEI	T,^D12		;INITIALIZE COUNT
	TLNE	TMOD,L.		;CHECK LONG
	MOVEI	T,^D24		;DOUBLE IT FOR LONG
	CAIA

ACC29:	PUSHJ	P,GETSKB	;GET NEXT CHARACTER
	SKIPL	TERMK		;END OF LINE?
	JRST	ACC16		;
	CAIE	T1,"+"		;PLUS?
	JRST	ACC31
	TLNE	F,MF		;YES - MINUS SEEN?
	JRST	BADSYN
	JRST	ACC29		;NO - IGNORE THE +
ACC31:	CAIN	T1,42		;DOUBLE QUOTE?
	JRST	ACC29		;YES - IGNORE
	CAIE	T1,"-"
	JRST	ACC16		;NOT A "-"
	TLC	F,MF		;COMPLEMENT FLAG
	JRST	ACC29		;GET NEXT CHARACTER

ACC16:	SUBI	T1,60		;OCTALISE
	JUMPL	T1,ERR2		;CHARACTER MUST OF COURSE -
	CAIL	T1,10		;   BE OCTAL
	JRST	ERR2		;NOT OCTAL - COMPLAIN
	LSHC	W1,3		;BUILD OCTAL VALUE IN T
	IOR	W2,T1		;
	SOJE	T,ACC28		;CHECK FOR PROPER NUMBER OF CHARACTERS
ACA16:	PUSHJ	P,GETSKB	;GET A CHARACTER
	SKIPGE	TERMK		;END OF LINE
	JRST	ACC16		;BACK FOR MORE
	PAGE
;	HERE WITH LINE END OR FULL WORD(S)

ACC28:	TLNN	TMOD,L.		;LONG WORKING?
	JRST	ACC30		;AS YOU WERE - STORE OCTAL
	MOVEM	W1,ARGVAL	;STORE LONG OCTAL
	MOVEM	W2,ARGVAL+1
	JRST	ACC32
ACC30:	MOVEM	W2,ARGVAL	;STORE SINGLE OCTAL

;	HERE AT END OF INPUT

ACC32:	PUSHJ	P,CLRLIN	;CLEAR THE LINE
	TLZN	F,MF		;FLAGGED AS A NEGATIVE #?
	JRST	ACC10		;NORMAL
	SETCMM	ARGVAL		;SET TO NEGATIVE -
	SETCMM	ARGVAL+1	;	= 1'S COMPLEMENT
	AOS	ARGVAL+1	; LETS MAKE IT 2'S COMPLEMENT
	SKIPN	ARGVAL+1
	AOS	ARGVAL
	JRST	ACC10		;NOW PLACE THAT LOT
	PAGE
;	'ACCEPT' FORMAT PROCESSING

ACC2:	PUSHJ	P,EVAL
	   JRST	ERR6		;NO SUCH STATEMENT NO
	PUSHJ	P,FRMSET	;SET UP TO ACCESS A FORMAT STATEMENT
	  JRST	RET		;CANT DO IT!
	MOVE	W1,T3		;FORMAT START
	MOVE	W2,T1		;FORMAT END

;	HERE WITH A RECOGNISED FORMAT REFFERENCE SET UP


ACC3:	MOVE	T,[POINT 7,(W1)]
;**;[100] modify @ acc3+1 ma 29-aug-77
	pushj	p,loadch	;GET A USER CHARACTER
	CAIE	T1," "		;BLANKS
	CAIN	T1,11		; AND TABS IGNORED TO START WITH
	JRST	ACC3

;**;[100] modify @ acc3+5 ma 29-aug-77
	MOVE	T2,[pushj p,loadch]
	MOVEM	T2,GETCHR	;SET TO READ FROM USER
	PUSHJ	P,GETSK2
	CAIE	T1,"("		;FIRST FORMAT CHARACTER MUST BE (
	JUMPA	T1,BADSYN
ACC4:	ILDB	T2,T		;INCREMENT POINTER NOW
	HRRM	T,.+1
	CAIG	W2,(W1)		;HAVE WE EXHAUSTED THE FORMAT
	JRST	[JUMPE	T1,RET
		 JRST	ERR13]	;YES
	DPB	T1,T		;STORE NEXT CHARACTER
	JUMPE	T1,ACC4

;**;[100] modify @ acc6 ma 29-aug-77
ACC6:	pushj	p,loadch	;GET ANOTHER USER FORMAT CHARACTER
	CAIE	T1," "		;NOW ALLOW
	CAIN	T1,11		;BLANKS AND TABS AS USER WANTS
	CAIA
	PUSHJ	P,GETSK2
	JUMPN	T1,ACC7		;NOT THE LAST CHARACTER YET IF NON ZERO
	CAIE	T3,")"		;LAST USER CHARACTER MUST BE A )
	JRST	ERR32		;  IT WASN'T SO COMPLAIN
ACC7:	MOVE	T3,T1		;REMEMBER THE LST USER CHARACTER
	CAIE	T1,37		;DOES USER WANT LINE CONTINUATION = ^_
	JRST	ACC4		;NO - NORMAL

;**;[100] modify @ acc5 ma 29-aug-77
ACC5:	pushj	p,loadch	;ACCEPT ANOTHER USER CHARACTER
	CAIN	T1,12		;UNTIL END OF LAST LINE
	JRST	ACC6
	JRST	ACC5		;DO A CONTINUATION
	PAGE
;	TYPE LOGIC

DISPLA:	SKIPN	ESCAPE		;CAN WE USE FOROTS?
	JRST	ERR30		;NOT AFTER A ^C RE-ENTER
	SETZM	CURGRP		;CLEAR CURRENT GROUP STACK FLAGS
	TLO	F,CFLIU!GRPFL	;SET CORE FILE IN USE - ALLOW GROUPS
	CLEARM	GETCHR		;THIS IS THE FIRST ACCESS TO CORE FILE THIS LINE
	TLNE	F,EOL		;USER GAVE ANY ARGUMENTS?
	TLOA	F,OFCFL		;NO - GET THEM FROM CORE FILE
	TLZ	F,OFCFL		;YES - PUT THEM INTO CORE FILE
	PUSHJ	P,DISP4		;DISPLAY ROUTINE
	TLZ	F,CFLIU!OFCFL!GRPFL	;PULL DOWN DANGEROUS FLAGS
	PUSHJ	P,REINOP	;REINSTATE OPEN PROGRAM
	JRST	RET		;END OF TYPE COMMAND

DISP4:	CLEARM	RANGE		;CLEAR FOR RANGE INDICATION
	PUSHJ	P,SYMIN		;GET USERS NEXT SYMBOL VALUE
	   JRST	DISP3		;NOT THERE
	   CAIA			;STATEMENT # FOUND
	JRST	DISP2		;TRUE VARIABLE

;	FORMAT STATEMENT PROCESSOR


DISP13:	PUSHJ	P,FRMSET	;SET UP TO ACCESS A FORMAT STATEMENT
	  JRST	DISP5		;CANNOT DO IT

;	NOW FOUND A RECOGNISED FORMAT STATEMENT

	MOVE	T2,[POINT 7,(T3)]
	MOVEI	W1,SYM		;SET UP FOR SYMBOL PRINT
	PUSHJ	P,SPT		;PRINT SYMBOL=STATEMENT #
	TYPE(	FORMAT)
DISP6:	ILDB	T,T2		;GET A CHARACTER FROM THE FORMAT TEXT
	HRRM	T2,.+1		;GET NO OF WORDS DONE
	CAIG	T1,(T3)		;ALL DONE?
	JRST	DISP5		;DONE WITH FORMAT
;**;[100] modify @ disp6+4 ma 28-aug-77
	putchr	(T)		;[100]TYPE IT
	JRST	DISP6		;MORE TO DO - BACK FOR MORE
	PAGE
;	SET UP ACCESS TO A FORMAT STATEMENT  T3=START  T1=END
;	SKIP ON SUCCESS.

FRMSET:	MOVEI	T3,(T)		;SHOULD POINT TO A JRST
	LINE
	LDB	T,[POINT 7,(T3),6]	;GET FIRST CHARACTER OF FORMAT
	CAIE	T,"("		;FIRST CHARACTER MUST BE A (
	PJRST	ERR16		;USER LOSES
	MOVE	T,T3		;ACCEPTED START OF FORMAT -
	MOVEM	T,SAVLOC	; NOW FIND END OF F10 FORMAT
	HRREI	T,-12		;CHANGE LABEL+P TO LABEL+F
	ADDM	T,SYM		;LIKE SO
	PUSH	P,T3		;SAVE (T3)
	PUSHJ	P,EVAL		;LOCATE THE FORMAT END
; [71] Change @FRMSET+11 lines, JMT, 6-Dec-76
; [71] Delete 	  JRST	E8		;CANT FIND FORMAT END
	  JRST	ERR41		;[71] CANT FIND FORMAT END
	POP	P,T3		;RESTORE
	MOVEI	T1,1(T)		;SET UP END OF FORMAT IN T1
	JRST	CPOPJ1		;T3 START - T1 END . . . ALL SET UP

VAL2:	TAB
	MOVE	T,RANLIM	;GET THE CURRENT VALUE POINTER
	MOVE	T,1(T)		;GET THE NEXT VALUE
	POPJ	P,

;	IMPLIED RANGE   I.E. TYPE ARRAY

DISP2:	CAIN	T1,"-"
	JRST	DISP1		;GET LIMIT OF RANGE
	TRZN	TF,IMPRNG	;IS THIS A SIMULATED RANGE
	JRST	DISP10		; NO - JUST NORMAL

DISP11:	PUSHJ	P,DISP14	;SET UP RANGE WITH UPPER LIMIT
	TLOA	F,GRPFL		;PERMIT GROUP LOGIC AGAIN
;**; [73] Change @ DISP0, JMT, 12-Apr-77
DISP0:	HRL	TMOD,TMOD	;[73] UNFUDDLES THE MODIFIERS FOR A RANGE


;	ONE-SHOT TYPE REQUEST
;	ENTER WITH SYMBOL VALUE IN T
;	ENSURE TERMK,RANGE=0

DISP10:	MOVEM	T,LWT		;SAVE SYMBOL VALUE
	MOVE	T,(T)		;GET CONTENTS OF SYMBOLIC ADDRES
	EXCH	T,LWT		;SAVE CONTENTS AND GET SYMBOL VALUE
				;SAVE SYMBOL VALUE IN CASE WE DO A RANGE
	MOVEM	T,RANLIM	;SAVE FOR RANGE NAME ID SUPRESSION
;**;[064],DISP10+4, DELETE 1 LINE ,MD,APR-76
	PUSHJ	P,OFFSET	;TYPE USERS SYMBOL
	   JRST	DISP3
	EXCH	T,SYM		;GET BACK SYMBOL CONTENTS
	TLNE	TMOD,-1		;ANY LOCAL MODIFIERS?
	MOVS	TMOD,TMOD	;YES - USE THEM
	TRO	TMOD,ANYMOD	;FLAG FIRST PRINT ON LINE
	PAGE
;	*** TYPE FLOATING *** 

TYPF:	TRNN	TMOD,F.		;TEST THE FLOATING FLAG
	JRST	TYPD		;NO REAL TRY DOUBLE REAL
	JUSTIFY
	MOVEI	T2,4		;ARG TYPE REAL FOR FOROTS
	PUSHJ	P,FOROUT	;ONE ARG OUTPUT

;	*** TYPE DOUBLE REAL ***

TYPD:	TRNN	TMOD,D.		;TEST FOR DOUBLE REAL
	JRST	TYPC		;NO FLOATING TRY COMPLEX
	JUSTIFY
	MOVE	T2,RANLIM	;GET ARG POINTER
	MOVE	T,1(T2)		;GET SECOND ARG
	MOVEM	T,ARGVAL+1	;SAVE 2ND. HALF FOR FOROTS
	MOVE	T,(T2)		;RE-INSTATE IST.ARG IN T
	MOVEI	T2,10		;ARG TYPE REAL*8 FOR FOROTS
	PUSHJ	P,FOROUT	;OUTPUT REAL*8

;	*** TYPE COMPLEX ***

TYPC:	TRNN	TMOD,C.		;TEST FOR COMPLEX TYPE OUT
	JRST	TYPI		;NO COMLEX TRY FOR INTEGER
	JUSTIFY
	MOVE	T2,RANLIM	;[52] GET ARG POINTER
	MOVE	T,1(T2)		;[52] GET SECOND ARG
	MOVEM	T,ARGVAL+1	;[52] SAVE 2ND HALF FOR FOROTS
	MOVE	T,(T2)		;[52] REINSTATE 1ST ARG IN T
	MOVEI	T2,14		;SET UP ARGTYPE FOR COMPLEX
	PUSHJ	P,FOROUT	;ONE ARG OUTPUT

;	** TYPE INTEGER ***

TYPI:	TRNN	TMOD,I.		;TYPE AS INTEGER?
	JRST	TYPO		;NO - TRY OCTAL
	JUSTIFY
	MOVEI	ODF,^D10	;PREPARE FOR DECIMAL TYPE OUT
	PUSHJ	P,FTOC		;CONSTANT PRINT

;	*** TYPE OCTAL ***

TYPO:	TRNN	TMOD,O.		;TYPE AS OCTAL?
	JRST	TYPA		;NO - TRY ASCII
	JUSTIFY
	MOVEI	ODF,10		;PREPARE FOR OCTAL PRINT
	PUSHJ	P,FTOC		;PRINT IN OCTAL
	TRNN	TMOD,L.		;DOUBLE WORD
	JRST	TYPA		;NO - TRY ASCII
	PUSHJ	P,VAL2		;GET THE NEXT VALUE
	PUSHJ	P,FTOC		; DISPLAY THAT
	PAGE
;	*** TYPE ASCII ***

TYPA:	TRNN	TMOD,A.		;TYPE AS ASCII?
	JRST	TYPR		;NO - SEE IF RIGH JUSTIFIED ASCII
	JUSTIFY
	PUSHJ	P,TXT341	;THROW UP ASCII
	TRNN	TMOD,L.		;DOUBLE?
	JRST	TYPR		;NO - TRY RASCII
	PUSHJ	P,VAL2		;GET THE NEXT VALUE
	PUSHJ	P,TXT341	;AND TYPE THAT AS ASCII

;	*** TYPE RIGHT JUSTIFIED ASCII ***

TYPR:	TRNN	TMOD,R.		;TYPE AS ASCII RIGHT JUSTIFY
	JRST	TYPS		;NO - SEE IF IN RANGE
	JUSTIFY
	TYPE(R)			;[47] RASCII IDENTIFIER
	LSH	T,1		;MAKE LEFT JUSTIFIED ASCII
	PUSHJ	P,TXT341	;TYPE AS USUAL
	TRNN	TMOD,L.		;DOUBLE RASCII?
	JRST	TYPN		; NO
	PUSHJ	P,VAL2		;GET NEXT VALUE
	LSH	T,1		;FAKE ASCII
	PUSHJ	P,TXT341	;TYPE AS ASCII

TYPS:	TRNN	TMOD,S.		;/S IS ILLEGAL FOR TYPE
	JRST	TYPN
	JRST	ERR37		; - ERROR
	PAGE
;	HERE AT END OF TYPING - EXAMINE RANGE CONDITION

TYPN:	LINE
	SKIPN	RANGE		;ARE WE IN A RANGE CONDITION
	JRST	DISP5		; NO

	AOS	T,RANLIM	; YES INCREMENT VARIABLE
	TRNN	F,DOUBLE	;IS THIS A REAL*8 ARRAY RANGE
	TRNE	TMOD,C.!D.!L.	;OR ANY DOUBLE WORD MODIFIER
	AOS	T,RANLIM	;REAL*8 ARRAYS GO UP BY TWO
	CAMG	T,RANGE		;TO LIMIT OF RANGE
	JRST	DISP0		;AND TYPE ALL REQUIRED

DISP5:	TLNE	TMOD,-1		;LOCAL MODIFIERS?
	HLRZ	TMOD,TMOD	;YES - REMOVE THEM
	SKIPGE	TERMK		;END OF USER INPUT LINE YET?
	JRST	DISP4		; NO - KEEP GOING
	POPJ	P,		; YES - END OF TYPE COMMAND

JUSTFY:	TRZN	TMOD,ANYMOD	;SEE IF FIRST OUTPUT THIS VARIABLE
;**;[100] modify @ justify+1 ma 27-aug-77
	jrst	[LINE
		jrst	.+1]
	TYPE(	=  )
	MOVE	T,LWT		;GET BACK THE OUTPUT VARIABLE CONTENTS
	POPJ	P,



;	GET THE LIMIT OF A RANGE CONDITION AND CHECK THE ORDER

DISP1:	MOVEM	T,RANGE		;REMEMBER START OF RANGE
	TLZ	F,GRPFL		;NO GROUP REQUESTS HERE OR PRINT MODIFIERS
	PUSH	P,MATHSM	;SAVE CURRENT SYMBOL
	PUSHJ	P,SYMIN		;GET NEXT SYMBOL
	   JRST	DISP3		;BAD LABEL
	   JRST	BADSYN		;STATEMENT NO. ????
	POP	P,T3		;GET FIRST SYMBOL BACK
	CAME	T3,MATHSM	;ARE THEY THE SAME
	JRST	ERR40		;NO - SORRY
	TRZE	F,SUBFLG	;WAS THERE AN IMPLIED RANGE
	JRST	DISP11		;YES - GO DEAL WITH IT

	CAML	T,RANGE		;SORT OUT SYMBOL ORDER
	EXCH	T,RANGE		;CHANGE THEIR ORDER
	CAIN	T1,"-"		;"-" IS A DELIMITER BUT IS BAD HERE
	JRST	BADSYN
	TLO	F,GRPFL		;O.K. FOR GROUPS AGAIN
	JRST	DISP10		;NOW TYPE RANGE

SYM4:	TLNE	F,GRPFL		;ARE WE ALLOWING CORE STRINGS
	CAIE	T1,"/"		;AND IF SO DOES THE USER WANT ONE
	JRST	SYM1		;NOT IN GROUP LOGIC
	PAGE
;	ACCEPT TEMPORARY PRINT OPTION MODIFIERS

SYM15:	PUSHJ	P,OPTION	;GET THE PRINT OPTION SETTINGS
	  JRST	SYM14		;NUMERIC - MUST HAVE BEEN A GROUP REQUEST
	SKIPL	TERMK		;EOL?
	JRST	BADSYN		;CAN'T HAVE THAT!
	PJRST	SYMIN		;RESUME SYMIN ACTIVITIES

;	HANDLE GROUP REQUESTS

SYM14:	CAIL	T,1
	CAILE	T,GPMAX		;WHICH MUST BE IN RANGE
	JRST	ERR15		;NO GOOD
	CAIE	T1,","		;ALLOW COMMA AS DELIMITER
	JUMPN	T1,BADSYN	;ANYOTHER CHARACTER IS BAD


	PUSHJ	P,SYM5		;PROCESS GROUP CONTENTS


	POP	P,(P)		;REMOVE SYMIN PUSH
	JRST	DISP5		;ANYTHING ELSE ON USERS LINE?

SYM1:	TLNN	F,GRPFL		;IS GROUP LOGIC IN ACTION
	JRST	RET		;ASSUME NUL INPUT GO BACK TO USER

	POP	P,(P)		;REMOVE THE SYMIN PUSH
	JUMPE	T1,DISP5	;EMPTY GROUP?
	JRST	BADSYN		;MUST BE BAD SYNTAX


;	ROUTINE TO DETERMINE THE LENGTH OF AN IMPLIED RANGE

DISP14:	MOVEM	T,RANLIM	;SAVE THE BASE ARRAY REFFERENCE
	SETZM	PUTTER		;SET FOR RAYNAM
	PUSHJ	P,GET.RP	;GET THE RANGE PRODUCT FOR THIS ARRAY
	MOVE	T,DIMTOT	;
	ADD	T,RANLIM	;FORM UPPER RANGE LIMIT
	SOJ	T,		;
	MOVEM	T,RANGE		;SAVE THE RANGE
	MOVE	T,RANLIM	;GET THE START ADDRESS
	POPJ	P,
	PAGE
;	ENTRY POINT FOR A GROUP 'TYPE' REQUEST
;	PUSHJ P,SYM5
;	WITH GROUP # 1-GPMAX IN T
;	AND TERMK=0

SYM5:	TRZE	TF,DCOPFG	;DON'T OPEN PROG?
	JRST	SYM16		;NO - DON'T
	SKIPN	T3,GRP2(T)	;GET GROUP'S PROG
	JRST	SYM16		;NULL - IGNORE IT
	CAMN	T3,OPENED	;IS IT CURRENT?
	JRST	SYM16		;YES
	MOVEM	T3,SYM		;NO - SAVE IT
	MOVE	T3,OPENED
	MOVEM	T3,OLDOPN	;AND SAVE OLD OPENED
	PUSH	P,T		;SAVE (T)
	PUSHJ	P,IMPOPN	;DO THE OPEN AND MESSAGE
	POP	P,T		;RESTORE (T)

SYM16:	
;	CHECK FOR GROUP RECURSION

	MOVEI	T3,1
	LSH	T3,(T)	;SET UP MASK BIT
	TDOE	T3,CURGRP	;CHECK AND SET
	JRST	ERR39		;GROUP ALREADY ACTIVE - ERROR
	MOVEM	T3,CURGRP	;SAVE STATE
	PUSH	P,T		;SAVE T

	IMULI	T,CFSIZ		;GET RELEVANT GROUP SECTION
	ADD	T,[POINT 7,GRP1-CFSIZ]	;FORM POINTER TO IT

	RECURS <CFLPTR,CFLST,GETCHR,TERMK>
				;CFLPTR - SAVE CURRENT CORE POINTER
				;CFLST - SAVE CURRENT CORE LIMIT
				;GETCHR - SAVE CURRENT STRING SOURCE
				;TERMK - SAVE CURRENT DELIMITER DESCRIPTOR
	MOVEM	T,CFLPTR	;SET UP NEW POINTER
	HRRZM	T,CFLST		;DEFINE NEW STRING LIMIT
	MOVE	T,[ILDB T1,CFLPTR]	;GET POINTER TO NEW INFORMATION
	MOVEM	T,GETCHR	;STATE NEW STRING SOURCE
	PUSHJ	P,DISP4		;DO A RE-ENTER

	SRUCER			;POP BACK ALL ABOVE RECURS-ED VALUES

;	CLEAR CURRENT GROUP FLAG

	POP	P,T		;GET NUMBER BACK
	MOVEI	T3,1
	LSH	T3,(T)	;SET UP MASK
	TDC	T3,CURGRP	;CLEAR THIS GROUP FLAG
	MOVEM	T3,CURGRP	;SAVE IT

	PJRST	DISP5		;SEE IF THERE IS AN ORIGINAL USER
				;STRING TO PROCESS

DISP3:	PJRST	DISP9		;CANNOT FIND SYMBOL
	PAGE
;OPEN LOGIC

SETNAM:	TLO	F,FPRNM		; FIND PROGRAM NAME
	PUSHJ	P,FNDSYM	;
	 JRST	ERR6		; NO SUCH NAME
	HLRE	T,(R)		; GET (XWD -LEN,...)
	HRLM	T,OPENLS
	ADDI	T,1(R)		; POINT TO BEG OF PROGS SYMBOLS
	HRRM	T,OPENLS	;
	MOVE	T,SYM
	MOVEM	T,OPENED	; PROGRAM NAME OPENED
	POPJ	P,		;
	PAGE
;	DIMENSION LOGIC



	DEFINE	PAIRS(K)
<	K=K+2
	XWD	0,K		;START OF STRING,NEXT IN STRING
	XWD	0,0		;PARAMETER WORD>



K=DIMTAB

DIMTAB:	XLIST			;DEFINE TABLE OF TWO WORD PAIRS
	REPEAT	DIMSIZ-1,<PAIRS(K)>

	XWD	0,0		;END OF LIST IS SPECIAL
	XWD	0,0
	LIST



NUMPRS=DIMFRE-DIMTAB		;THE NUMBER OF AVAILABLE WORDS
NUMPRS=NUMPRS/2			;DEFINES THE # OF 'PAIRS' AVAILABLE

DIMFRE:	XWD	K,DIMTAB	;END, AND START OF FREE SPACE

DIMNAM:	XWD	0,0		;END, AND START OF LIST OF ARRAY NAMES
	PAGE
;	ROUTINE TO OBTAIN A FREE TWO WORD PAIR
;	CALL PUSHJ	P,GET2WD
;	     RETURN - ADDRESS OF 'PAIR' IN T

GET2WD:	HRRZ	T,DIMFRE	;GET THE START OF THE FREE LIST
	HRRZ	T1,(T)		;FIND THE LOCATION OF THE NEXT 'PAIR'
	JUMPE	T1,GETNON	;END OF LIST REACHED
	HRRM	T1,DIMFRE	;REMOVE THIS 'PAIR' FROM THE LIST
	POPJ	P,		;RETURN WITH GOOD 'PAIR' ADDRESS IN T

GETNON:	PUSHJ	P,FLUSHA	;REMOVE ALL STRUCTURES CREATED FOR
				;THE ARRAY VALUE IN SAVLOC
	TYPE(?FDTDTO DIMENSION TABLE OVERFLOW)
	JRST	RET

;	SUBROUTINE TO RETURN A 'PAIR' TO THE FREE LIST
;	CALL PUSHJ P,PUT2WD
;	     ENTER WITH ADDRESS OF 'PAIR' IN T
;	     RETURN

PUT2WD:	HLRZ	T1,DIMFRE	;GET THE ADDRESS OF THE END OF THE LIST
	HRRM	T,(T1)		;APPEND THE NEW 'PAIR'
	SETZM	(T)		;NEW 'PAIR' BECOMES END OF LIST
	HRLM	T,DIMFRE	;RECORD THE FACT
	POPJ	P,

;	ROUTINE TO LOOK THROUGH LIST OF ARRAY NAMES TO FIND IF 
;	THIS (SAVLOC) NAME IS ALREADY IN USE
;	CALL PUSHJ	P,RAYNAM
;	RETURN HERE IF NOT FOUND
;	RETURN HERE IF FOUND . . . T=ADDRESS OF ARRAY,  T2=LAST ARRAY
;				   F10RAY IN TF IS SET IF F10 DEFINED

RAYNAM:	HRRZI	T2,DIMNAM	;SET UP FOR FIRST ARRAY
	HRRZ	T,DIMNAM	;IS THERE AN ENTRY AT ALL?
RAY:	JUMPE	T,RAY3		;T2 WILL POINT TO THE END OF THE LIST
	HRRZ	T1,1(T)		;THIS IS AN ARRAY BLOCK - GET THE NAME(VALUE)
	CAMN	T1,SAVLOC	;ARE WE REDEFINING CURRENT NAME?
	JRST	RAY2		; YES - REMOVE THE ENTRY FIRST

	MOVE	T2,T		;T2 WILL POINT TO THE CURRENT GOOD ENTRY
	HRRZ	T,(T)		;FIND THE NEXT 'PAIR' ADDRESS
	JRST	RAY

RAY2:	SKIPL	1(T)		;IS THE DOUBLE PRECISION BIT ON = 400000,,0
	TRZA	F,DOUBLE	;NO  - MAKE SURE 'DOUBLE' IS OFF
	TRO	F,DOUBLE	;YES - SET THE DOUBLE FLAG
	TRZ	F,FORMAL!F10RAY	;THESE CAN'T APPLAY HERE
	JRST	CPOPJ1		;ARRAY IDENTIFIED EXIT
	PAGE
;	HERE IF NO USER DEFINITION EXISTS IN FORDDT DIMENSION LISTS
;	NOW CHECK FOR AN F10 DEFINITION

RAY3:	PUSH	P,T		;SAVE BOTH T AND-
	PUSH	P,T2		;  T2 AROUND EVAL
	MOVE	T,SAVLOC
	TRO	F,SILENT	;DON'T PRINT SYMBOL
	PUSHJ	P,LOOK		;SETS UP W1 FROM T
	  JRST	RAYPOP		;
	  JRST	RAYPOP		;DOSENT EXIST
	POP	P,T2		;RETURN T2
	POP	P,T		; AND T
	MOVE	RAY.,W1		;GET THE ARRAY SYMBOL
	MOVE	T1,(RAY.)	; AND SEE IF WE HAVE AN F10 ARRAY -
	TLZ	T1,PNAME	;    DEFINITION -
	IOR	T1,[XWD 500000,0];      THIS IS THE SAME SYMBOL
	CAME	T1,2(RAY.)	;        WITH FLAGS 50 SET
	POPJ	P,		;NO - NOT AN F10 DEFINITION
	TRO	F,F10RAY	;YES - FLAG THIS AS AN F10 ARRAY
	MOVE	RAY.,3(RAY.)	;SET POINTER TO ARRAY TABLE INFORMATION
	LDB	T1,[POINT 4,1(RAY.),12]
	CAIE	T1,10		;IS THIS A REAL*8 ARRAY?
	TRZA	F,DOUBLE	;NO MAKE SURE DOUBLE IS OFF
	TRO	F,DOUBLE	;YES FLAG IT
	LDB	T1,[POINT 9,1(RAY.),8]
	MOVEM	T1,DIMCNT	;SET UP THE NUMBER OF DIMENSIONS
	LDB	T1,[POINT 1,1(RAY.),13]
	JUMPN	T1,RAY4		;PASSING FORMAL ARRAY ARGUMENTS?
	TRZ	F,FORMAL	;THIS IS NOT A FORMAL PARAMETER
RAY5:	HRRZI	RAY.,3(RAY.)	;SET TO POINT TO THE FIRST DIMENSION
	JRST	CPOPJ1


RAYPOP:	POP	P,T1		;MUST RESET T2-
	POP	P,T		; AND T BEFORE
	POPJ	P,		; GIVING A NO FOUND EXIT


RAY4:	TRO	F,FORMAL	;FLAG FORMAL WORKING
	HRRZI	T,@1(RAY.)	;GET THE ACTUAL ARRAY BASE
	MOVEM	T,FRMSAV	;SAVE THE FORMAL REFFERENCE
	JRST	RAY5		;
	PAGE
;	ROUTINE TO CREATE AN ARRAY ENTRY
;	MUST HAVE A PAIR OF SUBSCRIPTS IN TEM,TEM1
;	 CALL PUSHJ P,PUTNAM
;	     ENTER WITH SAVLOC = VALUE OF NAME OF ARRAY

PUTNAM:	PUSH	P,F		;SAVE FLAGS ROUND THE NEXT FEW LINES
	PUSHJ	P,SIMDEF	;SEE IF THIS ARRAY NAME IS AFTER BASE-ARRAY
PUTCHK:	PUSHJ	P,RAYNAM	;HAVE WE USED THIS NAME BEFORE?
	  JRST	PUTOK		;NO  - GO AHEAD - PLACE NEW NAME
	PUSHJ	P,FLUSH		;NAME ALREADY IN USE STAND BY FOR REDEFINITION
	TRZE	F,FORMAL	;ATTEMPT TO RE-DIMENSION A FORMAL PARAMETER
	JRST	ERR33		;NO YOU DON'T
	TRNN	F,F10RAY	;F10 DEFINED ARRAY?
	JRST	PUTCHK		;RESET ALL
	JRST	ERR28		;WARN OF F10 REDEFINITION

PUTOK:	POP	P,F		;RESTORE FLAGS FROM ABOVE
	PUSHJ	P,GET2WD	;GET A 'PAIR' - END OF NAMES = T2
	MOVEM	T,T3		;SAVE FOR NAME DEFINITION - T3
	PUSHJ	P,GET2WD	;GET A 'PAIR' FOR DIMENSION DEFINITION
				;ENSURE WE HAVE 2 'PAIRS' FREE NOW
				;SAVE PAIN IN 'FLUSHING' LATER
	HRRM	T3,(T2)		;SAY HELLO TO NEW MEMBER
	SETZM	(T3)		;NEW MEMBER BECOMES END OF CHAIN
	MOVE	T1,SAVLOC	;GET THE NEW MEMBERS NAME
	TRNE	F,DOUBLE	;IS THIS A DOUBLE PRECISION ARRAY
	TLO	T1,400000	;YES - SAVE THE FACT
	MOVEM	T1,1(T3)	;ACCEPT THE NEW MEMBER TO THE FAMILY
	HRLM	T,(T3)		;NEW MEMBERS ARE GIVEN A DIMENSION LIST
	PUSHJ	P,PUTSUB	;STORE THE SUBSCRIPTS
	JRST	CPOPJ1		;JUMP OVER POSSIBLE PUTDIM ENTRY

PUTSUB:	MOVE	T1,TEM1		;GET THE UPPER SUBSCRIPT
	SUB	T1,TEM		;FORM THE DIMENSION RANGE < 256K
	HRLZM	T1,(T)		;SAVE IN LINK LOCATION OF PAIR
				;   AND DENOTE END OF PRESENT DIMENSION LIST
	MOVE	T1,TEM		;GET THE LOWER SUBSCRIPT
	MOVEM	T1,1(T)		;SAVE FOR FUTURE REFERENCE
	MOVEM	T,PUTTER	;SAVE THE END OF THE DIMENSION LIST
	POPJ	P,

;	ROUTINE TO ADD ANOTHER DIMENSION TO AN ARRAY DIMENSION LIST
;	CALL PUSHJ P,PUTDIM
;	     ENTER WITH TEM,TEM1 = LOWER AND UPPER SUBSRIPTS

PUTDIM:	PUSHJ	P,GET2WD	;GET A FREE 'PAIR'
	MOVE	T1,PUTTER	;FIND WHERE THE LAST DIMENSION WAS STORED
	HRRM	T,(T1)		;LINK NEW 'PAIR' TO OLD LIST
	PJRST	PUTSUB		;SAVE THE SUBSCRIPTS
	PAGE
;	ROUTINE TO GET THE DIMENSIONS, IN ORDER, FOR THE ARRAY VALUE(SAVLOC)
;	CALL PUSHJ P,GETDIM
;	WITH ARRAY VALUE IN SAVLOC AND PUTTER = 0 FOR FIRST CALL
;	EXIT WITH TEM=SUB LOWER   TEM1=SUB UPPER

GETDIM:	SKIPE	T,PUTTER	;IS THIS THE FIRST CALL?
	JRST	GET4		; NO - GET NEXT DIMENSION RANGE

	PUSHJ	P,RAYNAM	;YES - SET UP THE ARRAY REFERENCES
	  JRST	E5		;SAVLOC NAME NOT KNOWN??
	TRNE	F,F10RAY	;F10 DEFINED?
	JRST	GET3		;YES
	HLRZ	T,(T)		;GET THE START OF DIMENSION LIST
	JRST	GET5		;FIRST TIME IS SPECIAL
GET4:	TRNE	F,F10RAY	;F10 ARRAY DEFINITION?
	JRST	GET3		;YES
	HRRZ	T,(T)		;GET NEXT DIMENSION IF ANY
GET5:	JUMPE	T,ERR22		;END OF LIST - TOO MANY DIMENSIONS EXPECTED
	MOVEM	T,PUTTER	;SAVE LINK TO NEXT DIMENSION
	MOVE	T2,1(T)		;GET THE LOWER SUBSCRIPT
	MOVEM	T2,TEM		;SAVE THE LOWER SUBSCRIPT
	HLRZ	T2,(T)		;GET THE RANGE OF THIS DIMENSION
	ADD	T2,TEM		;FORM THE UPPER SUBSCRIPT
	MOVEM	T2,TEM1		;SAVE AS THE UPPER SUBSCRIPT
	POPJ	P,


;	HERE TO GET THE NEXT UPPER AND LOWER BOUNDS
;	FOR AN F10 DEFINED ARRAY

GET3:	SETOM	PUTTER		;FLAG NOT FIRST TIME FOR F10 ARRAYS
	SOSGE	DIMCNT		;ARE THERE ANY MORE DIMENSIONS TO COME?
	JRST	ERR22		;NO HARD LUCK
	MOVE	T,@(RAY.)	;GET THE LOWER BOUND
	MOVEM	T,TEM		;SAVE LOWER
	MOVE	T,@1(RAY.)	;GET THE UPPER BOUND
	MOVEM	T,TEM1		;SAVE LOWER
	HRRZI	RAY.,3(RAY.)	;RAY. NOW POINTS TO NEXT DIMENSION-
	POPJ	P,		;	IF ANY
	PAGE
;	ROUTINE TO GUARD AGAINST SIMULTANEOUS SINGLE COMMAND RE-DIMENSIONING
;	OF THE SAME ARRAY. THE LOCATION BASRAY CONTAINS A REFFERENCE TO 
;	THE ARRAY NAME WHICH STARTED THE CURRENT DIMENSION WORKING
;	AND WILL BE THE POINT IN THE NAMES LIST AFTER WHICH A REDEFINITION
;	OF THE NAME NOW FOUND IN SAVLOC WILL BE ILLEGAL

SIMDEF:	MOVE	T3,SAVLOC	;GET THE NEW ARRAY NAME(VALUE)
	EXCH	T3,BASRAY	;SAVE AND START AT BASE-ARRAY NAME
	PUSHJ	P,RAYNAM	;SET UP POINTERS TO BASE-ARRAY
	  POPJ	P,		;   ????
	MOVEM	T3,BASRAY	;RESET BASE ARRAY AND CURRENT NAME
	TRNE	F,F10RAY	;F10 DEFINED ARRAY?
	POPJ	P,		;MUST BE A NEW DEFINITION
	PUSHJ	P,RAY		;SEE IF THIS ARRAY NAME OCCURS AFTER BASRAY
	  POPJ	P,		;NO
	TYPE	(?FDTMLD )
	MOVE	T,SAVLOC	;GET THE OFFENDING VALUE
	PUSHJ	P,LOOK		;DISPLAY IT
	  JFCL
	  JFCL
	TYPE( MULTI-LEVEL ARRAY DEFINITION NOT ALLOWED.)
	PUSHJ	P,FLUSHA	;FLUSH ALL FROM BASRAY TO END OF NAME LIST
	JRST	RET		;EXIT TO USER MODEFORDDT


;	ROUTINE TO ENSURE THAT THERE ARE NO MORE DIMENSIONS
;	TO BE CHECK FOR THIS (SAVLOC) ARRAY

SUBCHK:	PUSHJ	P,MORDIM	;ARE THERE ANY MORE DIMENSIONS LEFT
	POPJ	P,		;O.K.
	JRST	ERR1		;NOT ENOUGH DIMENSION INFO

;	TYPE THE DIMENSION LIST FOR THE ARRAY NAME VALUE IN SAVLOC

DIM1:	PUSHJ	P,RAYNAM	;SET UP REFERENCES TO THIS ARRAY NAME
	JRST	ERR34		;NONE SUCH
	TRNE	F,F10RAY	;IS THIS AN F10 DEFINED ARRAY
	SKIPA	T3,[EXP SAVLOC-1]  ;IF SO FOOL TYPDIM
	MOVE	T3,T		;PREPARE FOR TYPDIM
	PUSHJ	P,TYPDIM	;TYPE OUT THE DIMENSIONS
	JRST	RET		;ALL DONE
	PAGE
;	ROUTINE TO REMOVE AND RETURN(GARBAGE COLLECTION) ALL REFERENCE
;	TO THE ARRAYS WHICH FOLLOW THAT DEFINED IN SAVLOC IF FLSHAL IS SET

FLUSHA:	TRO	F,FLSHAL	;SET UP TO FLUSH ALL FROM BASE-ARRAY
	MOVE	T,BASRAY	;GET THE BASE ARRAY VALUE
	MOVEM	T,SAVLOC	;AND SET UP FOR RAYNAM
	PUSHJ	P,RAYNAM	;RESET F10RAY FLAG TO NEW BASRAY SETTING
	  POPJ	P,		;?????

FLUSH:	TRNN	F,F10RAY	;NOTHING TO DO IF AN F10 ARRAY
	PUSHJ	P,RAYNAM	;SET UP POINTERS TO THE ARRAY IN SAVLOC
	  POPJ	P,		; CAN'T FIND THE ARRAY NAME
				;T2=POINTS TO LAST ARRAY NAME BLOCK
				;T= CURRENT ARRAY NAME BLOCK
FLUSH2:	HLRZ	T3,(T)		;GET DIMENSION LIST ADDRESS
	HRRZ	T1,(T)		;GET NEXT MEMBER ADDRESS
	HRRM	T1,(T2)		;LOOP OUT THE OFFENDING ARRAY NAME ENTRY
	PUSHJ	P,PUT2WD	;RETURN A PAIR
	PUSHJ	P,DELIST	;DELETE THE LIST STARTING AT C(T3)
	TRNN	F,FLSHAL	;HARD FLUSH?
	POPJ	P,		;JUST ONE ARRAY FOR NOW
	HRRZ	T,(T2)		;GET NEXT ARRAY REFERENCE IF ANY
	JUMPE	T,CPOPJ		;EXIT IF END OF LIST
	JRST	FLUSH2		;MORE TO DO

;ROUTINE TO DELETE A LIST - STARTING IN T3

DELIST:	SKIPN	T,T3		;TEST FOR END OF LIST - RETURN PAIR IN T
	  POPJ	P,		;END OF LIST
	HRRZ	T3,(T3)		;GET NEXT PAIR ADDRESS
	PUSHJ	P,PUT2WD	;RETURN THE OLD PAIR
	PJRST	DELIST		;FOLLOW THROUGH TO END OF LIST

DIM5:	PUSHJ	P,DIMOUT	;DISPLAY ALL ARRAY INFO.
	LINE
	JRST	RET
	PAGE
;	DIMENSION LOGIC


DUBLE:	TRO	F,DOUBLE	;FLAG THIS ARRAY DEFINITION AS REAL*8

DIM:	JUMPL	F,DIM5		;OUTPUT ALL DIMENSION SPECS
	PUSHJ	P,TTYIN		;GET NEXT USER STRING
	JUMPE	T2,DIM5		;TYPE ALL ARRAYS IF EOL

	PUSHJ	P,ALLNUM	;SEE IF USER TYPED A LABEL
	  JRST	DIM13		;NO - MUST BE VARIABLE
	JRST	BADSYN		;BAD SYNTAX
DIM13:	PUSHJ	P,VALID		;CHECK VALIDITY OF VARIABLE
;**;[057], DIM13+1 ,INSERT , MD , 8/11/75
	MOVEM	T3,MATHSM	;[057] THATS WHAT USER TYPED
	MOVEM	T3,SYM		;SAVE FOR 'EVAL'UATION
	PUSHJ	P,EVAL		;EVALUATE SYMBOL
	  JRST	ERR6		;WE DON'T HAVE IT
	MOVEM	T,SAVLOC	;SAVE ARRAY NAME VALUE
	MOVE	T1,LSTCHR	;RE-INSTATE USERS LAST CHARACTER
	SKIPL	TERMK		;END OF LINE?
	JRST	DIM1		;YES - USER WANTS TO SEE DIMENSION LIST

	PUSHJ	P,NXTCHR	;MOVE TO NEXT SIGNIFICANT CHARACTER
	CAIN	T1,"("		; [ DENOTES START OF DIMENSION DEFINITION
	JRST	DIM14		;COMMAND - WILL NOW BE NON ZERO

	CAIE	T1,"["		; ( IS AN ALTERNATIVE TO [
	JRST	DIM7
	TLO	F,LFTSQB	;FLAG THAT A LSB FOUND - SO RSB MUST END SPEC
DIM14:	PUSHJ	P,DIMIN		;SET UP A NEW ARRAY DEFINITION
	JRST	RET

DIM7:	CAIE	T1,"/"		;A / IS ACCEPTABLE TO REMOVE ARRAYS
	JRST	BADSYN		;ANYTHING ELSE WONT DO
	PUSHJ	P,TTYIN		;GET NEXT INPUT
	JUMPN	T1,BADSYN	;MUST BE LINE END NOW
	JUMPE	T2,BADSYN	;NO CHARACTERS??
	LSHC	T1,6		;GET THE FIRST SWITCH CHARACTER
	CAIE	T1,'R'		;DID THE USER REQUEST A REMOVE
	JRST	BADSYN		;NO - WELL TOO BAD
	PUSHJ	P,RAYNAM	;SEE IF WE KNOW ABOUT HIS ARRAY
	  JRST	ERR26		;NO - TELL HIM
	PJRST	DMFLSH		;REMOVE IT
	PAGE
;	ROUTINE TO SET UP A NEW ARRAY DEFINITION

DIMIN:	SETZM	DIMTOT		;CLEAR TOTAL ELEMENT COUNT
	TROE	F,BASENM	;HAS A BASE NAME BEEN ACCEPTED
	JRST	DIM0		;YES - DON'T FLUSH YET

	PUSH	P,F		;PROTECT THE DOUBLE FLAG AWHILE
	PUSHJ	P,RAYNAM	;HAVE WE HAD THIS BASE ARRAY BEFORE
	  CAIA			;NO - VIRGIN
	TRNN	F,F10RAY	;F10 DEFINED?
	PUSHJ	P,FLUSH		;YES - WE MUST REMOVE IT NOW FOR REDEFINITION
	MOVE	T,SAVLOC	;GET THE ARRAY VALUE
	MOVEM	T,BASRAY	;MARK THIS AS OUR BASE ARRAY
	POP	P,F		;RE-INSTATE THE DOUBLE FLAG IF THERE

DIM0:	TRO	F,SURGFL	;FLAG THIS CALL AS SUBSCRIPT GATHERING
	PUSHJ	P,EITHER	;READ A SUBSCRIPT
	  CAIA			;CONSTANT
	  MOVE	T,(T)		;VARIABLE - GET VALUE
	TRZ	F,SURGFL	;CLEAR SUBSCRIPT RANGE ACCEPT FLAG
	MOVEM	T,TEM1		;SAVE TEMPORARILY AS UPPER SUBSRIPT
	PUSHJ	P,NXTCHR	;MOVE TO NEXT CHARACTER
	CAIN	T1,","		;COMMA IS THE USUAL DELIMITER
	JRST	DIMCOM		;PROCESS A COMMA

	CAIE	T1,":"		;A : IS AS GOOD AS A BAR=/
	CAIN	T1,"/"		;BAR IS THE SUBSCRIPT SEPARATOR
	JRST	DIMBAR		;PROCESS A BAR
	TLNN	F,LFTSQB	;SKIP IF WE HAD A [ TO START
	ADDI	T1,"]"-")"	;ACCEPTABLE DELIMITER IF )
	CAIN	T1,"]"		;ONLY ] ACCEPTED AS DELIMITER
	JRST	DIM4		;DENOTE END OF DEFINITIONS

	PUSHJ	P,FLUSHA	;REMOVE THE PRESUMABLY WRONG DEFINITION
	JRST	BADSYN		;COMPLAIN ABOUT SYNTAX
	PAGE
DIM4:	TLO	F,DIMEND	;FLAG THAT THIS IS THE END OF THE LIST
DIMCOM:	TLZE	F,BAR		;HAVE HAD TWO SUBSCRIPTS?
	JRST	DIM2		;YES - CHECK THE ORDER
	MOVEI	T,1		;ADJUST LOWER SUBSCRIPT TO BE 1
	MOVEM	T,TEM		;LOWER SCR IN TEM
	JRST	DIM2		;CHECK THE SUBSCRIPTS
DIM3:	SKIPN	DIMTOT		;IS THIS THE FIRST SETTING FOR THIS ARRAY
	PUSHJ	P,PUTNAM	;YES - USE PUTNAM
	PUSHJ	P,PUTDIM	;N0  - ADD ANOTHER DIMENSION
	MOVE	T,TEM1		;GET UPPER SUBSCRIPT
	SUB	T,TEM		;FORM RANGE
	AOJ	T,		;MUST HAVE AT LEAST ONE
	SKIPN	DIMTOT		;IS THIS THE FIRST DIMENSION
	AOS	DIMTOT		;YES - MAKE FIRST RANGE DEFAULT = ONE
	IMULM	T,DIMTOT	;FORM TOTAL SUBSCRIPT COUNT IN DIMTOT
	TLNN	F,DIMEND	;WAS A LEFT SQUARE BRACKET SEEN LAST?
	JRST	DIM0		;NO - BACK FOR MORE
	MOVE	T,SAVLOC	;GET THE ARRAY VALUE
	ADD	T,DIMTOT	;FORM REFERENCE TO LAST ELEMENT OF ARRAY
	TRNE	F,DOUBLE	;DO WE HAVE A REAL*8 ARRAY
	ADD	T,DIMTOT	;YES - SO THE RANGE MUST BE DOUBLED
	SUBI	T,1
	TRO	F,SILENT	;DO NOT TYPE SYMBOL IF GOOD MATCH
;**;[066],DIM3+21,MD,APR-76
	SETZM	MATHSM		;[066] NO SPECIFIC SYMBOL TO FIND
	PUSHJ	P,LOOK		;DO A LOOK-UP ON LAST ELEMENT
	  JRST	E5		;INTERNAL ERROR
	  JFCL			;FOUND SOME REFERENCE - NOT EXACT
	MOVE	W1,1(W1)	;EXACT - FOR DIMENSION OF 1 ONLY
	TRZ	F,F10RAY	;NO LONGER REQUIRE F10 INDICATOR
	MOVE	T1,LSTCHR	;RE-INSTATE USERS LAST CHARACTER
	CAMN	W1,SAVLOC	;THE LAST REFERENCE SHOULD BE TO THE SAME ARRAY
	POPJ	P,

	LINE
	TYPE	(%FDTABX )		;WARNING
	PUSHJ	P,TYPRAY	;TYPE THE (SAVLOC) ARRAY NAME
	TYPE( COMPILED ARRAY BOUNDS EXCEEDED)
	POPJ	P,

DMFLSH:	PUSHJ	P,FLUSH		;THE WHOLE SETUP FAILS
	JRST	RET

TYPRAY:	MOVE	T,SAVLOC	;GET THE OFFENDING ARRAY NAME
	TRZ	F,SILENT	;SPEAK-UP
	PUSHJ	P,LOOK		;SHOW THE USER
	  JFCL
	  JFCL
	POPJ	P,
	PAGE
DIM2:	MOVE	T,TEM1		;GET THE SECOND SUBSCRIPT
	CAMGE	T,TEM		;ENSURE THAT IT IS GREATER THAN THE FIRST
	JRST	ERR3		;TELL USER ABAOUT THE ERROR
	SUB	T,TEM		;FIND THE RANGE
	CAIG	T,777777	;CANT HAVE ARRAYS OWNING WHOLE OF CORE
	JRST	DIM3		;SUBSCRIPTS OK
	JRST	ERR27		;BAD SUBSCRIPTS

DIMBAR:	TLOE	F,BAR		;FLAG A BAR IF NOT ALREADY SET
	JRST	BADSYN
	MOVE	T,TEM1		;MOVE FIRST SUBSCRIPT TO APPROPRIATE PALCE
	MOVEM	T,TEM		; IN TEM
	JRST	DIM0		;LOOK FOR SECOND SUBSCRIPT

NXTCHR:	SKIPL	TERMK		;END OF LINE?
	JRST	BADSYN		;YES - SHOULD'T BE
	JUMPN	T1,CPOPJ	;TERMINATOR?
	PJRST	GETSKB		;MOVE TO NEXT SIGNIFICANT CHARACTER

;	DISPLAY ALL ARRAY DATA ENTERED BY USER

DIMOUT:	LINE
;**;[100] conditionalize TOPS10 code @ dimout+1 ma 28-aug-77
ife tops20,<
	SKPINL			;INTERCEPT A USER CONTROL O
	JFCL>			;end of conditional
;**;[100] add native code @ dimout+1 ma 28-aug-77
ifn tops20,<
	push	p,tf		;[100]save tf
	push	p,r		;[100]save r
	hrrzi	tf,.priou	;[100]get terminal output designator
	rfmod			;[100]get terminal JFN word
	tlz	r,(tt%osp)	;[100]clear ^o effects
	hrrzi	tf,.priou	;[100]get terminal output designator
	sfmod			;[100]set new JFN word
	pop	p,r		;[100]restore r
	pop	p,tf>		;[100]restore tf, end of conditional
	LINE
	SKIPN	T3,DIMNAM	;START AT HEAD OF ARRAY NAMES
;**;[100] modify @ dimout+5 ma 27-aug-77
	jrst	[TYPE(NO )
		jrst	.+1]
	TYPE(ARRAY SPECIFICATIONS)
	LINE
	JUMPE	T3,CPOPJ	;EXIT IF NOTHING TO PRINT
	LINE
	TYPE(USED	MAX	ARRAY	DIMENSIONS)
	LINE
	HRRZI	T3,DIMNAM	;START AT HEAD OF ARRAY NAMES
TYPNXT:	HRRZ	T3,(T3)		;FIND NEXT ARRAY REFERENCE
	JUMPE	T3,CPOPJ	;ALL PROCESSED?

	PUSHJ	P,TYPDIM	;NO - TYPE DIMENSIONS
	JRST	TYPNXT		;LOOK FOR MORE
	PAGE
;	TYPE THE DIMENSION LIST FOR THE ARRAY 'PAIR' IN T3

TYPDIM:	PUSH	P,T3		;SAVE T3 ROUND LOOK-UP
	LINE
	HRRZ	T,1(T3)		;GET THE ARRAY NAME VALUE
	MOVEM	T,SAVLOC	;SAVE THE ARRAY REFERENCE
	PUSHJ	P,GET.RP	;GET THE RANGE PRODUCT = DIMTOT
	MOVE	T,DIMTOT	;GET TOTAL ELEMENT COUNT
	PUSHJ	P,TYP0		;AND DISPLAY IT
	TAB
	TYPE([)
	MOVE	T,SAVLOC	;GET THE USER ARRAY NAME
	TRO	F,SILENT!NEARST	;DO NOT PRINT IF EXACT MATCH & FIND NEAREST SYMBOL
	PUSHJ	P,LOOK		;SEE IF THE ARRAY EXISTS
	  JRST	E5		;CANNOT FIND IT!
	  JFCL			;NOT EXACT
				;EXACT MATCH RETURN
	SUB	T,SAVLOC	;REMOVE BASE ARRAY OFFSET
	PUSHJ	P,TYP0		;DISPLAY
;**;[100] modify/insert @ typdim+20 ma 27-aug-77
	type(])
	tab
	SETZM	PUTTER		;RESET FOR RESCAN OF ARRAY'S DIMENSIONS
	MOVE	T,SAVLOC	;GET THE ARRAY NAME VALUE
	TRZ	F,SILENT!NEARST	;TURN OF PRINT SUPRRESS SWITCH & NEAREST
	PUSHJ	P,LOOK		;DO A LOOK UP ON C(T)
	  JFCL			;NOT FOUND
	  JRST	E5		;  OR NOT EXACT??
	TAB
	TYPE([)
DIM10:	PUSHJ	P,GETDIM	;GET THE SUBSCRIPTS FOR THE NEXT DIMENSION IN TEM,TEM1
	MOVE	T,TEM		;GET THE LOWER SUBSCRIPT
	PUSHJ	P,TYP0		;AND TYPE IT
;**;[100] modify @ dim10+3 ma 27-aug-77
	stype("/")
	MOVE	T,TEM1		;GET TUE UPPER SUBSCRIPT
	PUSHJ	P,TYP0		;AND TYPE THAT
	PUSHJ	P,MORDIM	;ANY MORE DIMENSIONS?
	  JRST	DIM20		;NO
;**;[100] modify @ dim10+11 ma 27-aug-77
	stype(</,/>)
	JRST	DIM10		;PROCESS NEXT DIMENSION

DIM20:	TYPE(])
	POP	P,T3		;GET BACK ARRAY REFERENCE
;**;[100] recode routine @ dim20+2 ma 27-aug-77
	TRNE	F,F10RAY	;F10 ORIGINATED?
	jrst	[TYPE( - F10 ORIGINATED)
		jrst	.+1]
	TRNE	F,DOUBLE	;REAL*8
	jrst	[TYPE(  DP)
		jrst	.+1]
	TRNN	F,DOUBLE	;REAL*4
	jrst	[TYPE(  SP)
		jrst	.+1]
	TRNE	F,FORMAL	;ARRAY IS A FORMAL ?
	jrst	[TYPE(  FORMAL)
		jrst	.+1]
	POPJ	P,
	PAGE
;	SUBROUTINE TO SEE IF THERE ARE ANY MORE DIMENSIONS TO COME
;	FOR THE CURRENT ARRAY
;	CALL PUSHJ P,MORDIM
;	     RETURN NO MORE
;	     RETURN MORE TO FOLLOW

MORDIM:	TRNE	F,F10RAY	;F10 DEFINED ARRAY?
	JRST	MORD2		;YES
	SKIPN	T,PUTTER	;EXIT IF PUTTER = 0
	POPJ	P,		;NO MORE TO COME
	HRRZ	T,(T)		;NO MORE IF NEXT IN LINE = 0
	JUMPE	T,CPOPJ		;T WILL BE ZERO IF THIS IS THE LAST DIMENSION
	JRST	CPOPJ1		;MUST BE MORE THERE

MORD2:	SKIPG	DIMCNT		;ANY MORE DIMENSIONS TO COME?
	POPJ	P,		;NO
	JRST	CPOPJ1		;YES


;	ROUTINE TO GET THE RANGE PRODUCT FOR THE ARRAY WHOSE VALUE
;	IS HELD IN SAVLOC.  EXIT WITH DIMTOT = RANGE PROD.

GET.RP:	SETZM	DIMTOT		;CLEAR THE ELEMENT COUNT CELL
	SETZM	PUTTER		;CLEAR FOR NEW SCAN IN GETDIM
DIM11:	PUSHJ	P,GETDIM	;GET THE NEXT SET OF DIMENSIONS FOR THE (SAVLOC) ARRAY
	MOVE	T,TEM1		;GET THE UPPER SUBSCRIPT SU
	SUB	T,TEM		;FORM SU-SL
	AOJ	T,		;FORM SU-SL+1
	SKIPN	DIMTOT		;FIRST TIME IS SPECIAL
	AOS	DIMTOT
	IMULM	T,DIMTOT	;FORM TOTAL SPACE DECLARED FOR THIS ARRAY
	PUSHJ	P,MORDIM	;SEE IF THERE ARE ANY MORE DIMENSIONS
	SKIPA	T,DIMTOT	; NO - ALL DONE
	JRST	DIM11		;YES - BACK FOR MORE

;**; [73] Insert @ DIM11 + 10 1/2 source lines, JMT, 12-Apr-77
	TRNN	TMOD,C.!L.!D.	;[73] IS THIS ARRAY TWO WORDS / ENTRY ?
	TRNE	F,DOUBLE	;IS THIS ARRAY REAL*8
	ADDM	T,DIMTOT	;YES - DOUBLE UP THE RANGE ACCESSED
	POPJ	P,		;WE NOW HAVE THE TRUE SCOPE OF THE ARRAY
	PAGE
;	GROUP LOGIC

GROUP:	JUMPL	F,GRPALL	;DISPLAY ALL GROUPS
	PUSHJ	P,GETNUM	;WHICH GROUP IS THE USER SETTING?
	JUMPLE	T,ERR15		;NOT VALID
	CAILE	T,GPMAX		;GPMAX IS THE MOST HE SHOULD ASK FOR
	JRST	ERR15
	MOVE	T1,OPENED
	MOVEM	T1,GRP2(T)	;THIS GROUP BELONGS TO THIS SECTION
	IMULI	T,CFSIZ		;END OF GROUP AREA
	SKIPL	TERMK
	JRST	[PUSHJ P,GRTYP	;FORGETFULL USER WANTS TO SEE GROUP CONTENTS
		 JRST RET]
	ADD	T,[POINT 7,GRP1-CFSIZ]
	MOVEM	T,CFLPTR	;WHERE TO STORE NEW STRING
	HRRZM	T,CFLST		;GUARD AGAINST OVERFLOW
	MOVE	T,[PUSHJ P,I2CFIL]
	MOVEM	T,GETCHR	;SETUP TTYIN TO READ CORE FILE

GRPMOR:	PUSHJ	P,I2CFIL	;CRAFTY READ AND STORE ROUTINE
	PUSHJ	P,GETSK2	;SET UP ANY DELIMITER FLAGS
	JUMPN	T1,GRPMOR	;IF NO DELIMITERS - DO MORE
	SKIPL	TERMK		;END OF INPUT?
	JRST	RET		; YES - ALL DONE
	JRST	GRPMOR		; NO - DO MORE, WAS A SPACE

;	DISPLAY THE CONTENTS OF THE GROUP WHOSE # IS IN T

GRTYP:	HRRZM	T,T2		;
	ADD	T,[POINT 7,GRP1-CFSIZ]
	MOVE	T1,[ILDB T1,T]
	MOVEM	T1,GETCHR	; INPUT FROM GROUP FILE
GRPNXT:	SETOM	TERMK		;SET UP FOR DELIMETER TEST
	ILDB	T1,T		;GET NEXT CHAR FROM STRING
	PUSHJ	P,GETSK2	;END OF STRING?
	JUMPN	T1,.+2
	MOVEI	T1, " "		;SPACE IS SPECIAL
	SKIPL	TERMK
	POPJ	P,		;YES - IF TERMINAL CHARACTER TERMK +VE
;**;[100] modify @ grpnxt+7 ma 28-aug-77
	putchr	(T1)		;SHOW CHARACTER
	HRRZM	T,T3
	CAIE	T3,GRP1(T2)	;OVERFLO CHECK
	JRST	GRPNXT		;KEEP GOING
	POPJ	P,		;BETTER STOP
	PAGE
;	GROUP STRING CORE STORAGE

GRP1:	REPEAT	GPMAX,<	XWD	050000,0	;NULL GROUP CONTENTS
	BLOCK	CFSIZ-1		;SPACE FOR GROUP STRING
			>


GRP2=.-1
	BLOCK	GPMAX		;PROGRAM NAMES FOR GROUPS
CURGRP:	BLOCK	1		;BITS  TO FLAG CURRENT GROUP STACK
				;IN ORDER TO CATCH RECURSION
	PAGE
;	WHAT LOGIC

WHAT:	LINE
	TYPE(OPEN SECTION: )
	MOVE	T,OPENED
	PUSHJ	P,SPT1		;TYPE NAME OF OPEN SECTION
	LINE
;**;insert @what+5 ma 22-aug-77
	SKIPA	T,[0]		;[77]FLAG DISPLAY OF EVERYTHING
PSEALL:	SETO	T,		;[77]FLAG DISPLAY OF PAUSES ONLY
	PUSH	P,T		;[77]SAVE FLAG
	MOVEI	T,^D10
	MOVEM	T,ODF		;SET RADIX 10 AS STANDARD IN 'WHAT'
	MOVEI	T,B1ADR		;START OF PAUSES
WT10:	SKIPE	(T)
	JRST	WT9		;THERE IS AT LEAST ONE PAUSE SET
	ADDI	T,1		;NO PAUSES SEEN SO FAR
	CAIG	T,BNADR		;ALL PAUSES EXAMINED?
	JRST	WT10		;NO

	LINE
	TYPE(NO PAUSE REQUESTS)
	JRST	WT11

WT9:	LINE
;**;[062] WT9+1 , REPLACE MESSAGE , MD , 6-APR-76
	TYPE(GROUP	AFTER	PAUSE	LOCATED IN)
	LINE
	MOVEI	AR,B1ADR		;GET START OF PAUSES
WT6:	HRRZ	T,(AR)		;GET THE PAUSE ADDRESS
	JUMPE	T,WT5		;OMIT IF NO PAUSE SETTING

;	TYPING OPTION = GROUP

	HLRZ	T,(AR)		;GET THE 'TYPING' OPTION
	JUMPE	T,WT12		;WAS TYPING REQUESTED?
	HLRZ	T,(AR)		;YES - GET GROUP #
	PUSHJ	P,FTOC		;DISPLAY GROUP #

;	PROCEDE SETTING

WT12:	TAB
	MOVE	T,1(AR)		;GET CONDITIONAL SETTING
	JUMPE	T,WT2		;NO CONDITIONALS
;**;[100] modify @ wt12+3 ma 27-aug-77
	stype("N/A")		;NOT APLICABLE DUE TO CONDITIONAL
	JRST	WT13		;DISPLAY GROUP
WT2:	MOVE	T,2(AR)		;GET PROCEDE COUNT
	PUSHJ	P,FTOC		;TYPE THE PROCEDE COUNT
	PAGE
;	PAUSE IDENTIFICATION

WT13:	TAB
	HRRZ	T,(AR)		;GET PAUSE ADDRESS
	JUMPE	T,WT5		;NO PAUSE SET UP HERE
	TLO	F,FGLSNM	;GLOBALS OK
	PUSHJ	P,LOOK		;LOOKUP SYMBOL
	  JRST	E1		;NOT THERE??
	  PUSHJ	P,SPT		;TYPE SUBROUTINE NAME
;**;[062] , WT13+10 , MD , 6-APR-76
	TAB			;[062] ADD PROGRAM NAME WHERE PAUSE IS
	SKIPE	T,PNAMSV	;[062] WAS A PG NAME FOUND?
	PUSHJ	P,SPT1		;[062] YES TYPE IT

;	ANY CONDITIONALS?

	SKIPE	1(AR)		;IS THIS A CONDITIONAL PAUSE?
	JRST	WT14		; YES

WT5:	SKIPE	(AR)
;**;[100] modify @ wt5+1 ma 27-aug-77
	jrst	[LINE
		jrst	.+1]
	ADDI	AR,3		;MOVE ON TO NEXT PAUSE
	CAIG	AR,BNADR	;DONE ALL PAUSES?
	JRST	WT6		;NO - BACK FOR MORE
	JRST	WT11		;FINISHED PAUSE DISPLAY - DO GROUPS


;	TYPE PARAMETERS OF CONDITIONAL PAUSE

WT14:	TAB
	TYPE(IF )
	HRRZ	T1,AR		;GET CURRENT PAUSE ADDRESS
	SUBI	T1,B1ADR	;REMOVE OFFSETT
	IDIVI	T1,3		;FORM PAUSE#
	LSH	T1,2		;FORM INDEX TO TESTAB
	MOVEM	T1,WT16		;SAVE T1 TEMPORARILY
	MOVE	T,TESTAB+1(T1)	;GET FIRST ARG ADDRESS
	CAIN	T,TESTAB+3(T1)	;IS IT A CONSTANT?
	JRST	[MOVE  T,(T)	;YES
		 PUSHJ P,TFLOT	;TYPE FLOATING
		 JRST  WT15]
;**;[063],WT14+12,INSERT,MD,APR-76
	CLEARM	SAVLOC		;[063] USER DIDNT GIVE ANY INFO!
	CLEARM	SECSAV		;[063] CLEAR SAVED NAME OF SECTION
	PUSHJ	P,OFFSET	;TYPE THE ARGUMENT NAME
	  JRST	E1		;NAME NOT FOUND?
WT15:	MOVE	T1,WT16		;RE-INSTATE T1
	MOVE	T,TESTAB(T1)	;GET CONDITIONAL TYPE
	TYPE( .)
;**;[100] modify @ wt15+3 ma 27-aug-77
	atype(TYPTST(T))	;TYPE THE CONDITION
	MOVE	T,TESTAB+2(T1)	;GET SECOND ARG ADDRESS
	CAIN	T,TESTAB+3(T1)	;IS THIS A CONSTANT?
	JRST	[MOVE  T,(T)	;YES -
		 PUSHJ P,TFLOT	;TYPE FLOATING
		 JRST  WT5]
;**;[063],WT15+7,INSERT,MD,APR-76
	CLEARM	SAVLOC		;[063] USER DIDNT GIVE ANY INFO!
	CLEARM	SECSAV		;[063] CLEAR SAVED NAME OF SECTION
	PUSHJ	P,OFFSET	;DISPLAY THE SECOND ARGUMENT NAME
	  JRST	E1		;NAME NOT FOUND
	JRST	WT5		;RETURN FOR NEXT PAUSE
	PAGE
TYPTST:	ASCIZ/LT. /
	ASCIZ/LE. /
	ASCIZ/EQ. /
	ASCIZ/NE. /
	ASCIZ/GT. /
	ASCIZ/GE. /

WT16:	0

;	GROUP SETTINGS

WT11:	LINE
;**;[77]insert @wt11+1 ma 22-aug-77
	POP	P,T		;[77]GET DISPLAY FLAG BACK
	JUMPL	T,RET		;[77]DONE IF FLAG IS SET
	PUSHJ	P,GROUPS	;DISPLAY THE USERS GROUP SETTINGS
	PUSHJ	P,DIMOUT	;DISPLAY ANY USER DEFINED ARRAY SPECS.
	LINE
	JRST	RET		;END OF WHAT


;	PUSHJ P,GRPALL TO TYPE ALL GROUP SETTINGS

GRPALL:	PUSHJ	P,GROUPS
	JRST	RET

GROUPS:	MOVEI	AR,GPMAX	;CHECK IF ANY ARE USED

GROU1:	SKIPE	GRP2(AR)	;USED?
	JRST	GROU2		;YES
	SOJG	AR,GROU1	;NO, TRY NEXT
	LINE
	TYPE	(NO GROUP SPECIFICATIONS)
	POPJ	P,

GROU2:	MOVEI	AR,1		;SET UP FOR FIRST GROUP
	JRST	WT7.5		;

WT7:	SKIPN	GRP2(AR)	;THIS ONE USED?
	JRST	WT7.3		;NO - IGNORE IT
	LINE
	TLO	F,CFLIU!OFCFL	;MAKE REQUEST FOR CORE FILE USE
	TYPE(GROUP )
	MOVE	T,AR
	MOVEI	ODF,12		;DECIMAL BASE FOR GROUP NUMBERS
	PUSHJ	P,FTOC		;TYPE GROUP #
;**;[100] insert/modify @ wt7+10 ma 27-aug-77
	type(:)
	tab
	MOVEI	T,(AR)		;GET GROUP # BACK
	IMULI	T,CFSIZ		;POINT TO ACTUAL LOCATION OF GROUP START
	PUSHJ	P,GRTYP		;DISPLAY GROUP CONTENTS
WT7.3:	ADDI	AR,1		;BUMP GROUP NUMBER
WT7.5:	CAIG	AR,GPMAX	;DONE ALL GROUPS?
	JRST	WT7		;NO - BACK FOR MORE

WT8:	TLZ	F,CFLIU!OFCFL	;REMOVE DANGEROUS FLAGS
	POPJ	P,		;
	PAGE
;	NEXT LOGIC - STEPS THROUGH SOURCE LINE STATEMENTS(S)
;			OR LABELS(L) OR SUBROUTINE ENTRIES(E)

NEXT:	JUMPL	F,STEP2		;NO ARGUMENTS USES DEFAULTS
	PUSHJ	P,EITHER	;ACCEPT EITHER A NUMERIC OR VARIABLE
	  CAIA			;NUMERIC
	MOVE	T,(T)		;GET VARIABLE CONTENTS
	JUMPE	T,.+2		;ZERO = LAST VALUE SUPPLIED
	MOVEM	T,STPVAL	;STORE THE NEW STEP VALUE
	CAIE	T1,"/"		;TRACE OPTION FOLLOWS?
	JRST	STEP2		;NO SWITCHES
	PUSHJ	P,OPTION	;FIND WHICH
	JRST	BADSYN		;NO GROUP REQUESTS HERE
	TRNN	TMOD,L.!S.!E.	;ANY TRACE OPTIONS SELECTED?
	JRST	STEP2		;NO JUST 'NEXT'
	TRZ	F,TRLABL!TRLINE	;FIRST RESET THE TRACE FLAGS
	TRZE	TMOD,L.		;DO WE TRACE LINES?
	TRO	F,TRLINE	;YES
	TRZE	TMOD,S.		;DO WE TRACE LABELS?
	TRO	F,TRLABL	;YES
STEP2:	MOVEM	F,STKYFL	;RECORD THE STICKY FLAGS
	MOVE	T,STPVAL	;GET THE STEP VALUE
	MOVEM	T,STPCNT	;AND SET UP THE STEP COUNT
	MOVE	T,[PUSHJ P,STEP4]	;PREPARE TO SET UP THE TRACE FEATURE
	MOVEM	T,FDDT.		;LIKE-SO
	HRRZ	T,STARTU	;HAS A 'START' BEEN DONE
	JUMPE	T,START2	;SIMULATE A START WITH TRACE ON
	SKIPE	T,JOBOPC	;WAS A RE-ENTER THE LAST ACTION
	JRST	CONT2		;YES - PROCEED FROM THERE
	JRST	PROCED		; NO - DO A NORMAL CONTINUE

;	THIS IS THE ENTRY POINT FOR TRACING EACH SOURCE LINE OR LABEL

STEP4:	JSR	SAVE		;SAVE THE USERS ACS
	PUSHJ	P,REMOVB	;AND REMOVE THE PAUSES
	HRRZ	T,AC17		;GET THE FORTRAN PDL POINTER TO FIND THE PUSHJ
	HRRZ	T,(T)		;FIND WHERE WE ARE TRACING
	SOJ	T,		;P.C. = STOPS ONE ON
	MOVEM	T,BCOM		;SET UP FOR RE.BRK
	SETZM	SYM		;ACCEPT FIRST SYMBOL FOUND IN 'LOOK'UP
	SETOM	ESCAPE		;ALLOW ESCAPES
	TRO	F,SILENT	;RIG FOR SILENT RUNNING
	TLO	F,FGLSNM	;GLOBALS ARE OK
	PUSHJ	P,LOOK		;'LOOK'-UP THE INTERCEPT
	  JRST	E7		;JUST HAS TO BE THERE
	  JRST	E7		;     AN OFFSET IS EVEN WORSE
	PUSHJ	P,STEP11	;OPEN AND NAME SECTION IF NEW
	TRNN	F,TRLINE!TRLABL	;REQUESTED TO TRACE ENTRIES ONLY?
	JRST	STEP7		;YES
	PAGE
STEP13:	MOVEM	W1,W2		;SAVE THE NOW RECOGNISED SYMBOL(LINE)
	MOVE	T,TRUFST	;GET THE LAST CHARACTER OF THE LABEL
	CAIN	T,32		;"P"?
	TRNN	F,TRLABL	;AND TRACING LABELS?
	CAIA
	JRST	STEP5		;YES - OK
	TRNN	F,TRLINE	;ARE WE TRACING LINES?
	JRST	STEP7		;NO - IGNORE


;	PREPARE TO TYPE NEXT LABEL OR LINE

STEP5:	SOSG	TABCNT		;COUNT UP TO 8 LABELS PER LINE
;**;[100] modify @ step5+1 ma 27-aug-77
	JRST	[line
		 MOVEI	T,10	;SET FOR 8 LABELS/LINE
		 MOVEM	T,TABCNT	;RECORD IN TABCNT
		 JRST	.+1]

	TAB
	MOVE	W1,W2		;GET BACK THE NEW FOUND SOURCE LINE
	PUSHJ	P,SPT		;AND PROUDLY DISPLAY IT
	SKIPL	STPCNT		;SKIP IF AN INFINITE TRACE
	JRST	STEP6		;OTHERWISE GO COUNT DOWN STPCNT


;	HERE BEGINS THE EXIT

STEP7:	PUSHJ	P,LISTEN	;HAS THE USER HAD ENOUGH
	CAIA			;NO
	JRST	STEP8		;ENOUGH - ENOUGH
	PUSHJ	P,INSRTB	;REPLACE PAUSES
	JSP	T,RESTORE	;RESTORE FORTRAN ACS
	POPJ	P,		;RETURN THE WAY WE CAME IN

;	TRACE COUNT EXHAUSTED?

STEP6:	SOSE	STPCNT		;DECREMENT THE STEP COUNT
	JRST	STEP7		;MORE TO DO - SEE IF THE USER INTERCEPTS

;	TRAP TO USER COMMAND LEVEL

STEP8:	MOVEI	T,[POPJ	P,]	;MAKE SURE WE DO A POPJ RETURN
	MOVEM	T,LEAV		;PLACE IT IN THE LEAVE LOCATION
	HRRM	T,PROC0		;TO MAKE SURE WE DO A POPJ RETURN TO FORTRAN
	JRST	RET		;NORMAL WORKING
	PAGE
;	XCT REFFERENCE FOUND BUT NOT 'P' OR 'L'

STEP12:	TRZN	TF,GUDLBL	;DID WE FIND A GOOD NUMERIC LABEL?
	JRST	STEP7		;NO  - THEN IT MUST BE A SUBROUTINE
	MOVE	T,BCOM		;WHAT ARE WE 'LOOK'ING FOR
	TRO	F,SILENT	;SILENCE AGAIN
	PUSHJ	P,RELOOK	;REFFERENCE DID NOT POINT TO A KNOWN LINE#
	  JRST	E7		;CAN'T FIND A PROPPER REFFERENCE?
	  JRST	E7		;THERE REALLY SHOULD BE SOMETHING THERE
	JRST	STEP13		;VALIDATE THIS ONE THEN


;	ROUTINE TO TYPE OUT NEW SECTION NAME

STEP11:	PUSHJ	P,SAV2AC	;SAVES T & W1
	PUSHJ	P,OVRLAY	;LOOK FOR AND TELL WHERE & IF AN OVERLAY HAPPENED
	MOVE	T,PNAMSV	;WHAT WAS THE SECTION IN WHICH IT WAS FOUND
	CAMN	T,OPENED	;DO WE ALREADY NOW ABOUT IT
	POPJ	P,		;YES JUST EXIT - AND RESET T,W1
	MOVEM	T,SYM		;SET UP FOR SETNAM
	PUSHJ	P,SETNAM	;AND OPEN THIS SECTION FOR EFFICIENT SEARCHES
	LINE
;**;[100] modify @ step11+10 ma 27-aug-77
	type([)
	PUSHJ	P,SPT1		;DISPLAY THE SECTION NAME
;**;[100] insert/modify @ step11+12 ma 27-aug-77
	type(])
	tab
	TRNN	F,TRLINE!TRLABL	;ARE WE TRACING ENTRIES?
	JRST	STEP6		;YES - COUNT THEM - RET: RESETS PDL
	SETZM	TABCNT		;PRODUCE A PRETTY PRINT OF 8 LABELS/LINE
	POPJ	P,		;RESET T,W1
	PAGE
;	Q LOGIC

Q:	LINE
	JUMPL	F,BADSYN	;MUST HAVE AN ARGUMENT
	TRO	TF,DCEVAL	;DON'T CALL EVAL
	PUSHJ	P,SYMIN		;GET A SYMBOL REFERENCE
	 TRZ	F,ID		;SYMBOL FOUND FLAG
	SKIPGE	R,.JBSYM	;FIRST CHECK LOSEG TABLE
	JRST	QLIST1
QLIST0:	PUSHJ	P,GHSSYP	;NOW TRY HISEG TBL
	  JRST	QLIST9		;DONE
	MOVE	R,TT		;GET LIST
QLIST1:	SETZM	QLPNT		;ZERO FLAG SHOWING REFERENCE

QLIST2:	PUSHJ	P,FIXSYR	;UPDATE PTR
	MOVE	T,(R)		;PICK UP SYMBOL
	JUMPE	T,QLIST3
	TLZN	T,PNAME		;A PROGRAM NAME?
	JRST	QLIST6		;YES
	CAMN	T,SYM		;NO, IS AN OCCURANCE FOUND?
	HRRZM	R,QLPNT		;YES, REMEMBER WHERE

QLIST3:	ADD	R,[XWD 2,2]	;POINT TO NEXT ENTRY
	JUMPL	R,QLIST2	;AND GO IF MORE
	TRNN	R,1B18		;TABLE EXHAUSTED - LOSEG?
	JRST	QLIST0		;YES - TRY HISEG
QLIST9:	TRZE	F,ID		;ANY FOUND
	JRST	RET		;DONE
	JRST	ERR6		;NO - ERROR

QLIST6:	SKIPN	QLPNT		;FOUND THE SYMBOL?
	JRST	QLIST3		;NO
	TRO	F,ID
	PUSHJ	P,SPT1		;YES, PRINT THE PROGRAM NAME
	MOVE	T,@QLPNT	;GET THE SYMBOL BACK AND
	TLNE	T,GLOBAL	; TEST FOR A GLOBAL SYMBOL
	JRST	QLIST8		; THIS IS A GLOBAL SYMBOL
QLIST7:	TYPE(	)
	SETZM	QLPNT		;RESET FLAG
	JRST	QLIST3		; AND SEARCH THE NEXT SET OF SYMBOLS

;**;[100] insert/modify @ qlist8 ma 27-aug-77
QLIST8:	type( )
	openp
	MOVE	T,SYM		;PREPARE TO -
	PUSHJ	P,SPT1		; PRINT THE SYMBOL
;**;[100] insert/modify @ qlist8+4 ma 27-aug-77
	type( IS GLOBAL)
	closep
	JRST	QLIST7		;LOOK FOR MORE - SHOULD BE NONE
	PAGE
;	MODE CHANGE LOGIC

MODE:	JUMPL	F,MODRET	;'MODE' ALONE - MEANS RESUME STANDARD SETTING
	SETZI	W1,		;NO  - PREPARE FOR A MODE CHANGE
MODNXT:	PUSHJ	P,TTYIN		;GET AN ARGUMENT FROM USER
	JUMPE	T2,BADSYN
	LDB	T2,[POINT 6,T2,5]	;GET FIRST CHARACTER OF USERS ARGUMENT
	CAIN	T2,'F'
	JRST	[TRO	W1,F.
		 JRST	MODMOR]
	CAIN	T2,'D'
	JRST	[TRO	W1,D.
		 JRST	MODMOR]
	CAIN	T2,'I'
	JRST	[TRO	W1,I.
		 JRST	MODMOR]
	CAIN	T2,'O'
	JRST	[TRO	W1,O.
		 JRST	MODMOR]
	CAIN	T2,'R'
	JRST	[TRO	W1,R.
		 JRST	MODMOR]
	CAIN	T2,'C'
	JRST	[TRO	W1,C.
		 JRST	MODMOR]
	CAIE	T2,'A'
	JRST	BADSYN
	TRO	W1,A.

MODMOR:	SKIPL	TERMK
	JRST	MODSET		;END OF USER LINE SET MODES

	JUMPE	T1,MODNXT	;SPACE IS A DELIMITER
	CAIE	T1,","		;COMMA IS THE ONLY ARG SEPARATOR
	JRST	BADSYN
	JRST	MODNXT		;GET MORE ARGUMENTS

MODSET:	MOVEM	W1,MODFLG	;SAVE USERS DEFAULT TYPE OPTIONS
	JRST	RET		;END OF MODE CHANGE
	PAGE
SUBTTL SYMBOL TABLE LOGIC

;	SYMBOL EVALUATION ROUTINE - EVALUATES THE SYMBOL IN SYM

EVAL:	MOVEI	R,SYM		;CHECK SYM
	PUSHJ	P,TRUVAR	;LABEL OR STATEMENT #?
	  TROA	TF,SYMLAB	;YES
	TRZ	TF,SYMLAB
	TRZE	TF,FGLONL	;LOOKING FOR GLOBALS ONLY?
	TRNE	TF,SYMLAB	;AND THIS IS NOT A LABEL?
	CAIA
	JRST	EVAL1		;YES
	TLO	F,FLCLNM	; FIND LOCAL NAME
	PUSHJ	P,FNDSYM	;
	 CAIA
	JRST	EVAL2		; FOUND
	TRNE	TF,SYMLAB	;IS IT A LABEL?
	 POPJ	P,		;YES - FAIL
	MOVSI	R,LOCAL		;YES, LOOK FOR OUTSIDE LOCALS
EVAL0:	TLO	F,FGLSNM	;THROUGH THE WHOLE TABLE
	MOVEM	R,SYMASK	;
	PUSHJ	P,FNDSYM
	 POPJ	P,		; FAIL

EVAL2:	HRRZM	R,SYMSAV	;ALWAYS SAVE POINTER
	MOVE	W1,R		;
	MOVE	W2,1(R)
	SKIPA	T,1(R)		;GET VALUE OF SYMBOL
CPOPJ2:	AOS	(P)		;SKIP TWICE
CPOPJ1:	AOS	(P)		;FOUND SYMBOL, SKIP
	TLZ	F,FGLSNM	;KILL FLAG
CPOPJ:	POPJ	P,


EVAL1:	MOVSI	R,GLOBAL	;GLOBALS ONLY
	JRST	EVAL0		;GO
	PAGE
;  GHSSYP LOOKS TO SEE IF THERE IS A HISEG FOR THIS CORE IMAGE;  IF
;SO, IT GETS THE POINTER TO THE HISEG SYMBOL TABLE IN T.  THERE IS
;A SKIP RETURN ON SUCCESS.
;
; AC'S USED:  R, T



GHSSYP:	SKIPN	.JBHRL		; ANY HISEG?
	POPJ	P,		; NO - FAIL
	PUSHJ	P,GSTAH		;GET START ADDR OF HISEG
	MOVE	TT, .JBHSM(R)	;GET HISEG SYMBOL TABLE PTR
	JUMPE	TT,CPOPJ	;FAIL IF NO TBL
	JRST	CPOPJ1		;OK


;	GET HISEG START ADDRESS IN (R)

;**;[100] conditionalize TOPS10 code @ gstah ma 25-aug-77
ife tops20,<
GSTAH:	MOVE	R,[XWD -1,.GTSGN]
	GETTAB	R,		; GET HISEG INDEX
	 HALT	.		; *****
	HRLZI	R, (R)		; GET INDEX
	HRRI	R,.GTUPM
	GETTAB	R,		; GET HISEG START
	 HRLZI	R,400000	;PRE-507 MONITOR - FUDGE VALUE
	HLRZ	R,R
	POPJ	P,>		;[100]end of conditional
;**;[100] add native code @ gstah ma 25-aug-77
ifn tops20,<
gstah:	move	r,.jbhso	;[100]get page of high segment
	lsh	r,11		;[100]get address of high segment
	popj	p,>		;[100]return,end of conditional
	PAGE
;THIS ROUTINE SETS UP IGNORE LISTS FOR SYMBOL TABLE LOOKUPS.

SETLST:	MOVEI	AR,0		;COUNT
	SKIPN	R,.JBSYM	;LOSEG FIRST
	CAIA
	PUSHJ	P,SETL		;SET UP THAT PART
	PUSHJ	P,GHSSYP	;NOW THE HISEG TABLE
	 POPJ	P,		;NONE

SETL:	MOVE	W2,(R)		;GET NEXT ENTRY
	TLNN	W2,PNAME	;PRIG NAME?
	JRST	SETL1		;YES
SETL0:	ADD	R,[2,,2]	;NO
	JUMPL	R,SETL		;CHECK NEXT
	POPJ	P,		;DONE

SETL1:	CAME	W2,[SQUOZE 0,UDDT]	;IGNORE THESE PROGRAMS
	CAMN	W2,[SQUOZE 0,FORDDT]
	JRST	SETL2
	CAME	W2,[SQUOZE 0,JOBDAT]
	JRST	SETL0		;NO

SETL2:	HLRE	T2,1(R)		;GET THE -LENGTH
	ADDI	T2,2(R)		;BEG OF SYMBOLS FOR PROGRAM
	HRRZM	T2,SYMLST(AR)	;
	HLRE	T2,1(R)
	MOVM	T2,T2		;GET LENGTH
	HRLM	T2,SYMLST(AR)	;SAVE THAT TOO
	AOJA	AR,SETL0	;NEXT


;FIX (R) AS PTR TO SYMBOL TABLE.

FIXSYR:	MOVEI	W2,(R)		;GET ADDR POINTED TO
	MOVEI	TT,PSYLST-1	;GET # OF IGNORED PROGRAMS

FIXS1:	HRRZ	T3,SYMLST(TT)	;NEXT LOCATION
	CAIN	T3,(W2)		;PART OF AN IGNORED PROG?
	JRST	FIXS2
	SOJGE	TT,FIXS1	;NO - TRY NEXT
	POPJ	P,		;NONE - LET IT GO

FIXS2:	HLRZ	T3,SYMLST(TT)	;GET LENGTH OF IGNORED SYMBOLS
	HLL	T3,SYMLST(TT)	;LENGTH,,LENGTH
	ADD	R,T3		;UPDATE PTR
	POPJ	P,		;DONE


SYMLST:	BLOCK	5		;# OF POSSIBLE PROGRAMS TO IGNORE (CONSERVATIVE)
PSYLST==.-SYMLST		;LENGTH
	PAGE
;FNDSYM:  FIND A SYMBOL IN THE SYMBOL TABLE.  ACCORDING TO THE FOLLOWING
;BITS:		FPRNM - FIND PROGRAM NAME
;		FLCLNM - FIND LOCAL NAME
;		FGLSNM - FIND GLOBAL (ANYWHERE IN TABLE)  (SYMASK CONTROLS
;			    THE TYPES OF SYMBOLS ALLOWED)
;
;  THE SYMBOL (IN RADIX50) IS GIVEN IN SYM, AC R IS LEFT POINTING TO
;THE ENTRY THAT MATCHED.


FNDSYM:	SETZI	W1,
	TLZN	F,FPRNM		;LOOK FOR PROGRAM NAME?
	JRST	FNDS3		;NO
	MOVE	R,.JBSYM	; CHECK LOSEG TABLE FIRST
	MOVEM	R,OJBSYM
	PUSHJ	P,FINDS		; TRY
	 CAIA			; NO GOOD
	JRST	CPOPJ1
	PUSHJ	P,GHSSYP	;GET HISEG SYM TBL PTR
	 POPJ	P,		;FAIL
	MOVEM	TT,OJBSYM
	JRST	FINDS		;TRY

FNDS3:	TLZN	F,FLCLNM	;LOOKING FOR A LOCAL?
	JRST	FNDS5		;NO
	SKIPN	R,OPENLS	; YES - GET PROG SYM LIST
	 POPJ	P,		;NO PROGRAM OPENED, OR NO SYMS FOR PROG

FNDS4:	MOVE	W,(R)		;GET NEXT SYM
	TLNN	W,PNAME		;PROGRAM NAME?
	JRST	FNDS45		;YES - IGNORE
	TLZ	W,LOCAL		;LOCALS ONLY
	CAMN	W,SYM		;FOUND?
	JRST	FNDS9		;YES
FNDS45:	ADD	R,[XWD 2,2]	; NO, UPDATE PTR
	JUMPL	R,FNDS4
	POPJ	P,		;NOT FOUND

FNDS5:	TLZN	F,FGLSNM	;LOOKING FOR A GLOBAL?
	 JRST	E9		;ERROR - NO SPEC
	MOVE	R,.JBSYM
	JUMPE	R,FNDS6
	PUSHJ	P,FNDS7		;LOOK FOR SYM IN LOSEG SYM TABLE
	 CAIA			;N.G.
	JRST	FNDS9		;FOUND IT - SET T
FNDS6:	PUSHJ	P,GHSSYP	;GET HISEG SYM TABLE PTR
	 POPJ	P,		;
	JUMPE	TT,CPOPJ	;
	MOVE	R,TT
	PAGE
FNDS7:	PUSHJ	P,FIXSYR	;FIX PTR IN (R)
	MOVE	W,(R)		;GET NEXT SYM
	TLNN	W,PNAME		;PROGRAM NAME?
	JRST	FNDS8		;YES - IGNORE
	TDZ	W,SYMASK	;CLEAR LEGAL BITS
	CAMN	W,SYM		;MATCH?
	JRST	FNDS11		;YES
FNDS8:	ADD	R,[XWD 2,2]
	JUMPL	R,FNDS7		;TRY NEXT
	JUMPE	W1,CPOPJ	;FAIL IF NOTHING FOUND
	SKIPA	R,W1		;USE LOC OF MATCH

FNDS10:	SKIPA	T,(R)		;GET VALUE (FOR FINDS)
FNDS9:	MOVE	T,1(R)		;GET VALUE OF SYMBOL
	JRST	CPOPJ1		;SUCCESS

FNDS11:	MOVE	W,(R)		;GET SYMBOL
	TLNE	W,GLOBAL	;GLOBAL?
	JRST	FNDS9		;YES - USE IT
	JUMPN	W1,FNDS12	;MATCH ALREADY?
	MOVE	W1,R		;NO - MARK THIS ONE
	JRST	FNDS8		;GO AHEAD
FNDS12:	TRO	F,MDLCLF	;MULT. DEF.
	POPJ	P,		;FAIL




;  THIS ROUTINE SEARCHES THE SYMBOL TABLE IN A BACKWARDS DIRECTION
;LOOKING ONLY FOR PROGRAM NAMES.

FINDS:	HLRE	R,OJBSYM	; GET -# OF ENTRIES
	JUMPE	R,CPOPJ		;IGNORE IF TABLE EMPTY
	MOVM	R,R
	ADD	R,OJBSYM	;POINTER TO END OF TABLE
	MOVEI	R,-1(R)

FNDS1:	MOVE	W,-1(R)		;GET NEXT PROG NAME
	CAMN	W,SYM		;IS THIS IT?
	JRST	FNDS10		;YES
	HLRE	W,(R)		; NO, GET LEN OF SYMBOLS
	ADD	R,W		;POINT TO PREVIOUS PROG
	HRRZ	W,OJBSYM
	CAIL	W,-3(R)		;DONE?
	POPJ	P,		;YES - NO FOUND
	JRST	FNDS1		; NO - TRY NEXT
	PAGE
SUBTTL	ENTER AND LEAVE FORDDT LOGIC

;	SAVE THE ACS AND PI SYSTEM

SAVE:	0			;SAVE THE ACS AND PI SYSTEM
	SKIPN	SARS
	JRST	SAV1
	AOS	SAVE
	JRST	SAV5
SAV1:	MOVEM	17,AC17
	HRRZI	17,AC0
	BLT	17,AC0+16
	MOVE	T, SAVE
	HLLM	T, SAVPI
	SETPDL

SAV5:	MOVE	F,STKYFL	;INIT THE FLAG REGISTER
	SETOM	SARS		;FLAG PROTECTING SAVED REGISTERS
	SETPDL
	JRST	@SAVE


;	RESTORE ACS AND PI SYSTEM

RESTOR:	HRRM	T,SAVE
	MOVE	T,SAVPI
	TLZ	T,010037	;DON'T TRY TO RESTORE USER MODE FLAG
	HLLM	T, SAVE
	HRLZI	17,AC0
	BLT	17,17
	SETZM	SARS
	JRST	2,@SAVE
	PAGE
;	PAUSE LOGIC



BP1:	XLIST			;TABLE FOR ENTRY FROM BREAKPOINTS
	REPEAT	NBP,<	0	;JSR TO HERE FOR A PAUSE
	JSA	T, BCOM
	0		;HOLDS INSTRUCTION WHILE PAUSE IS IN PLACE>
	LIST


B1INS=BP1+2
BPN=.-3




;	CONDITIONAL LOGIC

TESTAB:	XLIST
	REPEAT	NBP,<	0	;NUMBER OF TEST
	0	;ADDRESS OF ARG1
	0	;ADDRESS OF ARG2
	0	;CONSTANT VALUE>
	LIST
	PAGE
COMPAR:	CAML	T2,T3
	CAMLE	T2,T3
	CAME	T2,T3
	CAMN	T2,T3
	CAMG	T2,T3
	CAMGE	T2,T3
COND:	0
	JSR	CONSAV		;SAVE RELEVANT REGS
	AOS	COND		;PREPARE FOR SKIP RETURNS
	HRRZ	T,BCOM3
	SUBI	T,B1ADR+1
	IDIVI	T,3
	LSH	T,2
	MOVE	T1,TESTAB(T)
	MOVE	T2,@TESTAB+1(T)
	MOVE	T3,@TESTAB+2(T)
	XCT	COMPAR(T1)
	AOS	COND
	JSR	CONSAV		;REINSTATE USERS ACS
	JRST	@COND

CONSAV:	0
	EXCH	T,CONSV0
	EXCH	T1,CONSV1
	EXCH	T2,CONSV2
	EXCH	T3,CONSV3
	JRST	@CONSAV

CONSV0:	Z
CONSV1:	Z
CONSV2:	Z
CONSV3:	Z
	PAGE
BCOM:	0
	POP	T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI	T,B1SKP-B1INS+1(T)
	HRRM	T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI	T,B1CNT-B1SKP(T)
	HRRM	T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE	T,BP1-B1CNT(T)	;GET PC WORD
	HLLM	T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH	T,BCOM		; ALSO SAVE PC WORD IN BCOM

BCOM3:	SKIPE	B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	XCT	@.-1
BCOM2:	SOSG	B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST	BREAK

	MOVEM	T,AC0+T
	HRRZ	T,BCOM3		;ADDRESS OF CONDITIONAL
	HLRZ	T,-1(T)		;SEE IF A 'TYPING' REQUESTED
	JUMPN	T,BCOM1		;'TYPING' REQUESTED
	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL	T,264		;JSR
	CAILE	T,266		;JSA,JSP
	TRNN	T,700		;UUO
	JRST	PROC1		;MUST BE INTERPRETED
	CAIE	T,260		;PUSHJ
	CAIN	T,256		;XCT
	JRST	PROC1		;MUST BE INTERPRETED
	MOVE	T,AC0+T
	JRST	2,@LEAV1	;RESTORE FLAGS, GO TO LEAV

LEAV1:	XWD	0,LEAV

BCOM1:	MOVE	T,AC0+T		;RESTORE T
	JSR	SAVE		;SAVE ACS
	PUSHJ	P,LISTEN	;DID THE DOOR BELL RING?
	JRST	BREAK3		;NO - THIS IS NOT A TRUE BREAK
	CAIA			;YES - LETS STOP HERE

BREAK:	JSR	SAVE		;SAVE THE WORLD
	TLO	F,AUTO		;SIGNAL THAT THIS WAS A TRUE BREAK
BREAK3:	PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	SETZM	MATHSM		;CLEAR SPECIFIC SYMBOL LOOKUP FLAG
	SETOM	ESCAPE		;USER ENVIRONMENT PROTECTED ALLOW ESCAPES
	PUSHJ	P,TTYCLR	;FLUSH WAITING TTY CHARACTERS FOR INPUT
	PUSHJ	P,FORBUF	;LET FOROTS CLEAR ITS BUFFER
	SOS	T,BCOM3
	HRRZS	T		;GET ADR OF CONDITIONAL BREAK INST
	SUBI	T,B1ADR-3	;CHANGE TO ADDRESS OF $0B
	IDIVI	T,3		;QUOTIENT IS BREAK POINT NUMBER
	HRRM	T,BREAK2	;SAVE BREAK POINT #
	PAGE
;NOW DISPLAY BREAK INFORMATION

	SETZI	TF,		;
	LINE
	TYPE(PAUSE AT )		;ANNOUNCE BREAK POINT
	MOVE	T,BCOM
	HLLM	T, SAVPI	;SAVE PROCESSOR FLAGS
	MOVEI	T,-1(T)
	ANDI	T,-1		;ADDRESS PORTION ONLY THANK YOU
	TRO	F,SILENT	;SILENCE
	TLO	F,FGLSNM	;GLOBALS ARE OK
	PUSHJ	P,LOOK		;TYPE PC AT BREAK
	  JRST	E2		;NO NAME?
	  JRST	E2		;OFFSET?
	MOVE	T,(R)		;GET SYMBOL
	TLNE	T,GLOBAL	;GLOBAL?
	JRST	BREAK6		;YES - THIS IMPLIES A ROUTINE
	PUSHJ	P,SPT1		;NO, SO PRINT IT
	TYPE( IN )
	MOVE	T,PNAMSV	;GET NAME OF SYMBOL'S SECTION
	MOVEM	T,SYM		;SAVE IT
	PUSHJ	P,SPT1		;AND TYPE IT
	MOVE	T,PNAMSV
	CAME	T,OPENED	;THIS PROGRAM OPENED?
	JRST	BREAK7		;NO - DO IT

BREAK4:	LINE
	HRRZ	T,@BCOM3
	HRRM	T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ	T,@BCOM3
	JUMPE	T,BREAK1	;TEST FOR REGISTER TO EXAMINE
	MOVE	TMOD,MODFLG	;REMEMBER TO SET UP THE PRINT FLAGS
	TLO	F,GRPFL!CFLIU!OFCFL	;WE WANT TO ALLOW GROUP LOGIC HERE
	SETZM	TERMK
	PUSHJ	P,SYM5		;DISPLAY USERS GROUP IN 'TYPING' REQUEST
	PUSHJ	P,REINOP	;RE-OPEN PROG
	TLZ	F,GRPFL!CFLIU!OFCFL	;REMOVE FLAG, IT MAY CAUSE TROUBLE

BREAK1:	MOVSI	S,400000
BREAK2:	ROT	S,.-.		;ROT BY # OF BREAK POINT
	TLZE	F,AUTO		;DO WE HAVE A TRUE BREAK CONDITION?
	ANDCAM	S,AUTOPI	;YES - END OF 'TYPING' LOGIC
	TDNN	S,AUTOPI	;DONT PROCEED IF NOT AUTOMATIC
	JRST	RET		;DONT PROCEED
	JRST	PROCD1

BREAK6:	MOVEM	R,SAVLOC	;NAME OR ROUTINE
	TYPE	(ROUTINE )
	PUSHJ	P,SPT		;TYPE ROUTINE NAME
	PUSHJ	P,GETARG	;DISPLAY ANY ARGS
	MOVE	T,PNAMSV	;GET PROGRAM NAME
BREAK7:	MOVEM	T,SYM		;SAVE IT
	PUSHJ	P,IMPOPN	;AND OPEN IT
	JRST	BREAK4
	PAGE
PROCED:	MOVEI	T,1		;SET UP FOR PROCEDE OF 1
	SKIPG	@BCOM2		;DO NOT CHANGE VALUE IF ALREADY SET
PROCDX:	MOVEM	T,@BCOM2	;STORE IN B#CNT
	HRRZ	R,BCOM3
	SETZM	TEM		;DO NOT RE-INSERT 'CONDITIONAL' INFO.
	HLRZ	S,(R)
	JUMPE	S,.+2		;SET THE AUTO PROCEDE FLAG 
	TLO	F,AUTO		;IF THIS IS A 'TYPING' REQUEST
	PUSHJ	P,AUTOP
PROCD1:	LINE

PROC0:	HRRZI	R,[JRST RET]	;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ	P,FETCH
	JRST	BPLUP1		; GET HERE ONLY IF MEMORY SHRANK
	MOVEM	T,LEAV
	PUSHJ	P,INSRTB
	JRST	PROC2

PROC1:	MOVE	T,AC0+T
	JSR	SAVE
	JFCL
	MOVE	T,BCOM		;STORE FLAGS WHERE "RESTORE"
	HLLM	T,SAVPI		;  CAN FIND THEM
PROC2:	MOVEI	W,100
	MOVEM	W,TEM1		;SETUP MAX LOOP COUNT
	JRST	IXCT5

IXCT4:	SUBI	T,041		;IS UUO "INIT"?
	JUMPE	T,BPLUP
	AOJGE	T,IXCT6		;DONT PROCEDE FOR INIT
				;DONT INTERPRET FOR SYSTEM UUOS
	MOVEM	R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI	R,41
IXCT:	SOSL	TEM1
	PUSHJ	P,FETCH
	JRST	BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM	T,LEAV
IXCT5:;	SETZM	ESCAPE		;NO ESCAPES FROM FORDDT
	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN	T,254		;DON'T DO ANYTHING TO JRST
	JRST	IXCT6
	HRLZI	17,AC0
	BLT	17,17
	MOVEI	T,@LEAV
	DPB	T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
	LDB	W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB	T,[POINT 9,LEAV,8]	;PICK UP INSTRUCTION FIELD
	SETPDL
	CAIN	T,260
	JRST	IPUSHJ		;INTERPRET PUSHJ

	CAIN	T,264
	JRST	IJSR		;INTERPRET JSR
	CAIN	T,265
	JRST	IJSP		;INTERPRET JSP
	CAIN	T,266
	JRST	IJSA		;INTERPRET JSA
	MOVE	R,LEAV
	TRNN	T,700
	JRST	IXCT4		;INTERPRET UUO
	CAIN	T,256
	JRST	IXCT		;INTERPRET XCT

IXCT6:	JSP	T,RESTORE
LEAV:	0			;INSTRUCTION MODIFIED
	JRST	@BCOM
	AOS	BCOM
	JRST	@BCOM

BPLUP:	PUSHJ	P,REMOVB	;BREAKPOINT PROCEED ERROR
BPLUP1:	JSR	SAVE
	JFCL
	JRST	ERR18

IPUSHJ:	DPB	W1,[POINT 4,CPUSHP,12]	;STORE AC FIELD INTO A PUSH
	HLL	T,SAVPI		;PICK UP FLAGS
	HLLM	T,BCOM		;SET UP THE OLD PC WORD
	MOVSI	T,(1B4)		;TURN OFF BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	JSP	T,RESTORE	;RESTORE THE MACHINE STATE
CPUSHP:	PUSH	.-.,BCOM	;GETS MODIFIED IN AC FIELD
	JRST	@LEAV		;JUMP TO "E" OF THE PUSHJ

IJSA:	MOVE	T,BCOM		;INTERPRET JSA
	HRL	T,LEAV
	EXCH	T,AC0(W1)
	JRST	IJSR2

IJSR:	MOVE	T,BCOM		;INTERPRET JSR
	HLL	T,SAVPI		;SET UP THE OLD PC WORD
	MOVSI	W,(1B4)		;TURN OFF BIS IN NEW PC WORD
	ANDCAM	W,SAVPI
IJSR2:	MOVE	R,LEAV
	PUSHJ	P,DEPMEM
	 JRST	BPLUP		;ERROR, CAN'T STORE
	AOSA	T,LEAV
IJSR3:	MOVE	T,LEAV
	JRST	RESTORE

IJSP:	MOVE	W,BCOM		;INTERPRET JSP
	HLL	W,SAVPI		;PICK UP PC WORD FLAGS
	MOVEM	W,AC0(W1)	;INSERT OLD PC WORD INTO AC
	MOVSI	T,(1B4)		;TURN OFF BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	JRST	IJSR3
	PAGE
;	INSERT PAUSES REQUESTS

INSRTB:	MOVE	S,[JSR BP1]
INSRT1:	SKIPE	R,B1ADR-BP1(S)
	PUSHJ	P,FETCH
	JRST	INSRT3

	MOVEM	T,B1INS-BP1(S)
	MOVE	T,S
	PUSHJ	P,DEPMEM
	 JFCL			;HERE ONLY IF CAN'T WRITE IN HIGH SEG

INSRT3:	ADDI	S,3
	CAMG	S,[JSR BPN]
	JRST	INSRT1
	POPJ	P,

;REMOVE PAUSE REQUESTS

REMOVB:	MOVEI	S,BNADR
REMOV1:	MOVE	T,B1INS-B1ADR(S)
	SKIPE	R,(S)
	PUSHJ	P,DEPMEM
	 JFCL			;HERE ONLY IF NO WRITE IN HIGH SEG
	SUBI	S,3
	CAIL	S,B1ADR
	JRST	REMOV1
	POPJ	P,		;
	PAGE
;	HERE TO SET PAUSE BREAKS



BPS:	MOVE	T,[XWD B1ADR,B1ADR+1]	; CLEAR ALL PAUSES
	CLEARM	B1ADR
	BLT	T,AUTOPI	;CLEAR OUT ALL PAUSES AND AUTO PROCEDE REGESTER
	JRST	RET

BPS1:	MOVE	R,T
	PUSHJ	P,FETCH		;CAN PAUSE BE INSERTED HERE?
	 JRST	ERR19		;NO
	PUSHJ	P,DMEMER	; AGAIN NO
	MOVE	T,R		;PUT THE PAUSE ADR BACK IN T
	SETZM	SAVLOC		;STORES AVAILABLE PAUSE SLOT
	MOVEI	R,B1ADR		;START OF PAUSE ARGUMENTS
BPS4:	HRRZ	W,(R)		;GET ADDRESS OF PAUSE IF ALREADY SET
	CAIN	W,(T)		;SEE IF ALREADY SET
	JRST	BPS5		;YES - USE THIS

	SKIPN	(R)		;IS IT FREE?
	HRRM	R,SAVLOC	;YES - REMEMBER WHERE
	ADDI	R,3		;LOOK AT NEXT
	CAIG	R,BNADR		;ALL EXAMINED?
	JRST	BPS4		;NO GO ON IN CASE THIS ADDRESS USED ALREADY

	SKIPN	R,SAVLOC	;WHERE THERE ANY FREE?
	JRST	ERR9		;NO - UNLUCKY USER
BPS5:	MOVEM	T,(R)		;SET UP PAUSE ADDRESS
	MOVE	T,TEM		;GET CONDITIONAL IF ANY   L.H. = WHAT TO TYPE
	MOVEM	T,1(R)
	MOVE	T,TEM1		;GET THE PROCEDE COUNT
	MOVEM	T,2(R)		;PLACE WHERE IT DOES THE MOST GOOD
	PAGE
AUTOP:	SUBI	R,B1ADR		;AUTO PROCEDE SETUP SUBROUTINE
	IDIVI	R,3
	MOVEI	S,1
	LSH	S,(R)
	ANDCAM	S,AUTOPI
	TLNE	F,AUTO		;DID USER ASK FOR AUTO PROCEDE?
	IORM	S,AUTOPI	;YES - LET HIM HAVE IT
	HRRZ	T,TEM		;DID USER ASK FOR A CONDITIONAL
	JUMPE	T,CPOPJ		;NO - ALL DONE

	LSH	R,2		;FORM INDEX TO TEST TABLES
	ADDI	R,TESTAB
	MOVE	T,COND0
	MOVEM	T,(R)		;SAVE TEST NO.
	MOVE	T,COND1
	CAIN	T,COND3		;SHOULD THIS BE A CONSTANT
	MOVEI	T,3(R)		;YES CORRECT IT
	MOVEM	T,1(R)		;SAVE ADDRESS OF FIRST ARG
	MOVE	T,COND2
	CAIN	T,COND3
	MOVEI	T,3(R)		;SAVE ADDRESS OF SECOND ARG
	MOVEM	T,2(R)		;SAVE ADDRESS OF SECOND ARG
	MOVE	T,COND3		;GET CONSTANT IF ANY
	MOVEM	T,3(R)		;AND SAVE
	POPJ	P,
	PAGE
SUBTTL MEMORY MANAGER SUBROUTINES

;DEPOSIT INTO MEMORY SUBROUTINE

DEPMEM:	EXCH	R,T		;CHECK (T)
	PUSHJ	P,CHKADR	;LEGAL ADDRESS?
	 POPJ	P,		;NO - ILLEGAL
	 JRST	DEP4		;YES BUT IN HI SEGMENT
	EXCH	R,T
	TRNN	R,777760
	JRST	DEPAC		;DEPOSIT IN AC
	MOVEM	T,(R)
	JRST	CPOPJ1		;SKIP RETURN

DEPAC:	MOVEM	T,AC0(R)	;DEPOSIT IN AC
	JRST	CPOPJ1		;SKIP RETURN


;**;[100] conditionalize TOPS10 code @ dep4 ma 25-aug-77
ife tops20,<
DEP4:	EXCH	R,T
	MOVEI	TT1,0
	SETUWP	TT1,		;IS HI SEGMENT PROTECTED? TURN OFF
	POPJ	P,		;PROTECTED, NO SKIP RETURN
	MOVEM	T,(R)		;STORE WORD IN HI SEGMENT
	TRNE	TT1,1		;WAS WRITE PROTECT ON?
	SETUWP	TT1,		;YES, TURN IT BACK ON
	JFCL
	JRST	CPOPJ1>		;[100]skip return, end of conditional
;**;[100] add native code @ dep4 ma 25-aug-77
ifn tops20,<
dep4:	exch	r,t		;[100]restore r and t
	push	p,tf		;[100]save regs for JSYS
	push	p,r
	lsh	r,-11		;[100]form page number from address
	hrrzi	tf,(r)		;[100]put into AC1
	hrli	tf,400000	;[100]get process handle into left half
	push	p,tf		;[100]save this argument, just in case!
	rpacs			;[100]get access bits into AC2
	tlne	tf,(pa%wt)	;[100]can we write to this page?
	jrst	dep5		;[100]yes, go do it
	move	tf,(p)		;[100]no, get saved argument
	and	r,[pa%wt!pa%rd!pa%cpy!pa%ex]
				;[100]clear unneeded bits
	tlo	r,(pa%cpy)	;[100]get cw access for page
	spacs			;[100]
	hrroi	tf,[asciz/
%FDTWSP	Writing to shared page
/]				;[100]prepare to warn him once
	aosn	pagwrn		;[100]skip if he has already been warned
	psout			;[100]send warning
dep5:	pop	p,r		;[100]flush extra stack level
	pop	p,r		;[100]restore r
	pop	p,tf		;[100]restore flags
	movem	t,(r)		;[100]save away t
	jrst	cpopj1>		;[100]skip return,end of conditional


DMEMER:	PUSHJ	P,DEPMEM	;DEPOSIT AND GO TO ERR IF IT FAILS
	 JRST	ERR19
	POPJ	P,
FETCH:	EXCH	R,T		;CHECK (T)
	PUSHJ	P,CHKADR	;LEGAL ADDRESS?
	 POPJ	P,		;NO
	 JFCL			;HIGH OR LOW OK FOR FETCH
	EXCH	R,T
	TRNN	R,777760	;ACCUMULATOR?
	SKIPA	T,AC0(R)	;YES
	MOVE	T,(R)		;NO
	JRST	CPOPJ1		;SKIP RETURN ONLY FOR LEGAL ADDRESS
	PAGE
SUBTTL BINARY TO SYMBOLIC CONVERSION

;	PUSHJ	P,LOOK		;AC T CONTAINS BINARY TO BE INTERPRETED
;	  RETURN 1		;NOTHING AT ALL FOUND THAT'S USEFUL
;	  RETURN 2		;SOMETHING FOUND, BUT NO EXACT MATCH
;				; OR MULTIPLY DEFINED IF OFFSET = 0 IN T
;	  RETURN 3		;EXACT MATCH FOUND AND PRINTED IF R=0
;				;R=SYMBOL VALUE IF SILENT FLAG ON
;				;T = SYMBOL VALUE BEING 'LOOKED' UP
;				;W1 = ADDRESS OF BEST SYMBOL SO FAR
;				;TRULST=LAST CHARACTER IF LABEL FOUND

LOOK:	SETZM	PNAMSV		;[070] RESET PROGRAM NAME OF SYMBOL
	TRZ	F,MDLCLF!PNAMEF!ID	;CLEAR FLAGS
	MOVEI	R,377777
	TRNE	F,NEARST	;
	MOVNI	R,377777
	MOVEM	R,BESTVA	;SETUP FALSE OFFSET
	PUSHJ	P,LOKSYM	;CHECK IT
LOOK0:	 POPJ	P,		;NOTHING FOUND
	 JRST	LOOK4		;MULT. DEF. OR OFFSET
	MOVE	R,W1		;PTR TO SYMBOL
	MOVEM	R,LASYM		;SAVE THIS SYMBOL
	MOVE	W2,1(R)		;GET VALUE
	MOVEM	W2,LASVAL	;SAVE
	TRZN	F,SILENT	;FOUND - SILENCE?
	PUSHJ	P,SPT		;NO - TYPE SYMBOL
;**;[070], LOOK0+10 , MD, AUG-76
	PUSHJ	P,LOOKPG	;[070] LOOKUP FOR PROGRAM NAME
	JRST	CPOPJ2		;[070] DOUBLE SKIP - SUCCESS

;**;[070],LOOK2,MOVE CODE TO CREATE ROUTINE LOOKPG,MD,AUG-76

LOOK4:	JUMPE	T,CPOPJ1	;MULT DEF
	MOVEM	R,LASYM		;UPDATE LAST SYMBOL
	MOVE	W2,1(R)		;GET VALUE
	ADDI	W2,(T)		;WITH OFFSET
	MOVEM	W2,LASVAL	;AS LAST VALUE
;**;[070], LOOK4+5 ,MD, AUG-76
	PUSHJ	P,LOOKPG	;[070] GET PROGRAM NAME
	JRST	CPOPJ1		;2ND SKIP

RELOOK:	MOVE	R,W1		;RESET (R)
	PUSH	P,[LOOK0]	;RETURN
	TRZ	F,ID		;ALLOW LOKSYM TO FIND IT
	JRST	LOK3		;HERE WE GO AGAIN


;**;[070],RELOOK+4,INSERT ROUTINE LOOKPG,MD,AUG-76
;[070] ROUTINE TO LOOKUP FOR PROGRAM NAME
LOOKPG:				;[070]
	PUSH	P,R		; SAVE R
LOOK2:	ADD	R,[2,,2]
	JUMPGE	R,LOOK3		;END OF TABLE
	MOVE	W2,(R)		;GET NEXT ENTRY
	TLNE	W2,PNAME	;PROGRAM NAME?
	JRST	LOOK2		;NO
	MOVEM	W2,PNAMSV	;YES - SAVE IT
LOOK3:	POP	P,R		;RESTORE R
	POPJ	P,		;[070] END ROUTINE
	PAGE
;THIS ROUTINE SEARCHES THE SYMBOL TABLE SPECIFIED BY FLAG FGLSNM FOR
;THE VALUE SUPPLIED IN AC T.  THERE IS A FAIL RETURN FOR SYMBOL NOT
;FOUND OR MULT. DEF. LOCAL.

LOKSYM:	SETZB	W1,TEM3
; [72] Insert @ LOKSYM+1/2, JMT, 13-Jan-77
	MOVEM	T,TEM8		;[72] STORE VALUE
	MOVE	R,.JBSYM	;USE LOSEG TBL
	PUSHJ	P,LOK2		;
	 JRST	LOK1		;NOT FOUND
	 CAIA			;OFFSET OR MULT DEF.
	JRST	CPOPJ2		;FOUND
	TRNE	F,MDLCLF	;MULT. DEF.?
	JRST	CPOPJ1		;FAIL - 2ND SKIP
	MOVEM	T,TEM3		;OFFSET - SAVE IT
	MOVEM	W1,TEM4		;SAVE PTR
LOK1:	PUSHJ	P,GHSSYP	;GET HISEG SYM TBL PTR
	 JRST	[SKIPN	TEM3	;OFFSET FOUND?
		 JRST	CPOPJ	;NO - FAIL
		 JRST	LOK15]	;YES - USE IT
; [72] Insert @ LOK1+3 1/2 lines, JMT, 13-Jan-77
	MOVE	T,TEM8		;[72] RESTORE VALUE
	MOVEI	R,(TT)		;
	PUSHJ	P,LOK2
	 JRST	CPOPJ		;NOTHING FOUND
	 CAIA
	JRST	CPOPJ2		;EXACT MATCH
	JUMPE	T,CPOPJ1	;2ND SKIP ON MULT DEF
	TRNN	F,NEARST	;LOOKING FOR THE NEAREST ABOVE?
	JRST	LOK13		;NO
	CAML	T,TEM3		;YES - NEW VALUE CLOSER?
	JRST	CPOPJ1		;YES
	JRST	LOK15		;NO - USE THE OLD VALUE

LOK13:	SKIPE	TEM3		;OFFSET FOUND FOR LOSEG TBL?
	CAMG	T,TEM3		;YES - A BETTER ONE?
	JRST	CPOPJ1		;NO
LOK15:	MOVE	T,TEM3		;YES - UPDATE VALUES
	MOVE	W1,TEM4
	MOVE	R,TEM4
	JRST	CPOPJ1		;2ND SKIP
	PAGE
LOK2:	PUSHJ	P,FIXSYR	;FIX SYM TBL PTR IN (R)
	MOVE	W2,(R)		;GET NEXT SYM
	TLNN	W2,PNAME	;IGNORE PROG NAMES
	JRST	LOK3
	TLNE	W2,GLOBAL	;GLOBAL?
	TLNE	F,FGLSNM	;GLOBALS OK?
	TLZA	W2,LOCAL!GLOBAL	;YES - ZERO BITS
	JRST	LOK3		;NO - PASS IT
	TLNE	W2,PNAME	;SHOULD BE CLEAR NOW
	JRST	LOK3
	MOVE	W2,1(R)		;OK - GET VALUE
	MOVEI	TT,(T)
	SUBI	TT,(W2)		;GET OFFSET
	JUMPL	TT,LOK6		;IGNORE IF WRONG DIRECTION
	JUMPE	TT,LOK5		;EXACT MATCH?
	CAMGE	TT,BESTVA	;NO, BUT BETTER VALUE?
	JRST	LOK4		;YES

LOK3:	ADD	R,[2,,2]	;TRY NEXT ENTRY
	JUMPL	R,LOK2		;
	JUMPE	W1,CPOPJ	;FAIL IF NONE FOUND
	TRNE	F,NEARST	;FOR NEAREST?
	JRST	LOK10		;YES
	CAMN	T,1(W1)		;EXACT MATCH?
	JRST	CPOPJ2		;YES - SUCCEED
	MOVE	W2,1(W1)	;NO, SO GET BEST VALUE
	SUB	T,W2		;GET OFFSET
	JRST	CPOPJ1		;EXIT FOR OFFSET

LOK4:	TRNE	F,NEARST	;NEAREST?
	JRST	LOK3		;YES - THIS ISN'T IT
	PUSHJ	P,TRUVAR	;VARIABLE ?
	JRST	[MOVE	W2,TRUFST
		 CAIN	W2,27		;"M" LABEL?
		 JRST	LOK3		;YES IGNORE
		 JRST	.+1]
	SKIPN	W2,MATHSM	;SPECIFIC SYMBOL??
	JRST	LOK4A		;NO
	PUSH	P,W1		;SAVE W1
	MOVE	W1,(R)		;GET SYMBOL
	TLZ	W1,PNAME	;FIX UP A BIT
	CAMN	W1,W2		;IS IT THE ONE WE ARE LOOKING FOR
	JRST	LOK4B		;YES
LOK4C:	POP	P,W1		;NO -RESTORE
	JRST	LOK3		;IGNORE
LOK4B:	POP	P,W1
LOK4A:	MOVEM	TT,BESTVA	;BETTER MATCH
	MOVE	W1,R
	JRST	LOK3		;KEEP GOING
LOK5:	TRNE	F,NEARST	;NEAREST ONLY?
	JRST	LOK3		;YES - PASS IT BY
	PUSHJ	P,TRUVAR	;YES - F10 SYMBOL?
	 JRST	[TRNE	F,ID	;NO - LABEL - MATCH ALREADY?
		 JRST	LOK12	;     YES - CHECK HIERARCHY
		 JRST	LOK14]	;     NO - TAKE IT
	SKIPN	W2,MATHSM	;ACCEPT ONLY THIS SYMBOL IF SET
	JRST	LOK7
	PUSH	P,W1		;SAVE W1
	MOVE	W1,(R)		;GET SYMBOL
	TLZ	W1,PNAME
	CAME	W1,W2
	JRST	LOK4C		;IGNORE IT IF NOT THE SAME
	POP	P,W1		;REMOVE POP
	MOVE	W1,R
	MOVE	W2,(R)		;LETS TAKE IT AND RUN
	TLNE	W2,GLOBAL	;GLOBAL?
	JRST	LOK11		;YES DONE
	JRST	CPOPJ2		;ALSO DONE
LOK7:	TRON	F,ID		;USE THIS SYMBOL
	JRST	LOK9		;FIX UP
LOK8:	TRO	F,MDLCLF	;SECOND SYM FOUND - MULT. DEF.
	MOVE	W2,(R)		;[053] GET SECOND SYMBOL FOUND
	TLNN	W2,GLOBAL	;[053] SEE IF IT IS A GLOBAL
;**;[57],LOK8+3, REPLACE, MD, 8/11/75
	JRST	LOK8A		;[057] [053] OTHER LOCAL - GO SEE IF EQUIVALENT DEFINITION
	MOVE	W1,R		;[053] GLOBAL HAS HIGHER PRIORITY
	JRST	LOK11		;[053] DONE
;**;[57],LOK8+6, INSERT, MD, 8/11/75
LOK8A:	JUMPN	TT,CPOPJ1	;[057] NOT EXACT MATCH
	MOVE	T,(W1)		;[057] GET PREVIOUS FOUND
	TLZ	T,PNAME		;[057] JUST RADIX-50 NAME
	TLZ	W2,PNAME	;[057] ALSO FOR NEW FOUND
	CAME	W2,T		;[057] SAME NAME
	JRST	CPOPJ1		;[057] NO
	JRST	LOK11		;[057] YES - MAY BE COMMON BECAUSE
				;[057] SAME NAME + SAME ADDRESS

LOK9:	MOVE	W1,R		;UPDATE PTR
	MOVE	W2,(R)		;GET SYM
	TLNE	W2,GLOBAL	;GLOBAL?
	JRST	LOK11		;YES - DONE
	SETZM	BESTVA		;BEST MATCH
	JRST	LOK3		;AND ON

LOK6:	TRNN	F,NEARST	;LOOKING FOR NEAREST?
	JRST	LOK3		;NO - IGNORE
	CAMG	TT,BESTVA	;CLOSER MATCH?
	JRST	LOK3
	MOVEM	TT,BESTVA	;YES - UPDATE BEST VALUE
	MOVE	W1,R		;SAVE PTR
	JRST	LOK3		;AND GO ON

LOK11:	SKIPA	T,1(W1)
LOK10:	SKIPA	T,1(W1)		;GET VALUE
	AOS	(P)		;DOUBLE SKIP HERE
	JRST	CPOPJ1		;ALL THATS NEEDED

LOK12:	MOVE	W2,LOKFST	;GET THE (LAST) CHAR
	EXCH	W2,TRUFST	;KEEP TRUFST UPDATED
	CAIE	W2,27		;"M"?
	CAMG	W2,TRUFST	;DOES THIS HAVE HIGHER PRIORITY?
	JRST	LOK3		;NO - IGNORE IT
	TRZ	F,ID		;YES - USE IT
	JRST	LOK7		;

LOK14:	MOVE	W2,TRUFST	;GET THE LABEL TYPE
	CAIN	W2,27 		;"M" ?
	JRST	LOK3		;YES IGNORE
	MOVEM	W2,LOKFST	;SAVE IT
	JRST	LOK7		;AND USE THIS SYMBOL
	PAGE
;	ROUTINES TO TYPE A SYMBOL IN THE NON OPEN SECTION

SYMBOL:	PUSHJ	P,SAV2AC	;SAVE T,W1
	TRNE	F,MDLCLF	;SYMBOL ALREADY TYPED
	JRST	SYMBL2		;DISPLAY ALTERNATE NAME

SYMBL3:	MOVE	T,(R)		;GET THE OUTPUT STRING
	PJRST	SPT1		;TYPE IT AND RESTORE T,W1

SYMBL2:	LINE
	TYPE(  EQUIVALENT TO )
	JRST	SYMBL3		;NOW TYPE NAME



;	TYPE THE SECTION NAME (ADDRESS OF NAME IS IN R )

SECTON:	PUSHJ	P,SAV2AC	;SAVE T,W1
;**;[063],SECTON+1, CHANGE , MD, APR-76
	MOVE	T,(R)		;[063] GET NAME OF SECTION
	CAMN	T,SECSAV	;[063] ALREADY TYPED?
	POPJ	P,		;[063] YES - MUST BE A RANGE
	MOVEM	T,SECSAV	;[063] SAVE THE NEW ONE BEING TYPED
	TYPE( IN )
	JRST	SYMBL3		;NOW TYPE NAME


;	PRESERVE REGISTERS T AND W1

SAV2AC:	EXCH	T,(P)		;SAVE T, AND GET RETURN
	MOVEM	T,TRULST	;SAVE AS ESCAPE
	MOVE	T,(P)		;RESTORE T
	PUSH	P,W1		;SAVE W1
	MOVEI	W1,SAVRET	;INTERCEPT FOR FINAL POPJ
	PUSH	P,W1		;SAVE FOR RETURN
	MOVE	W1,-1(P)	;REINSTATE W1
	JRST	@TRULST		;PSEUDO POPJ BACK TO USER
SAVRET:	POP	P,W1		;RESTORE OLD W1
	POP	P,T		;RESTORE OLD T
	POPJ	P,		;FINALLY DO THE USERS POPJ
	PAGE
	SUBTTL OUTPUT ROUTINES

;OFFSET TYPES THE SYMBOL WHOSE VALUE IS IN AC T.  SUBSCRIPTS ARE
;HANDLED.  THERE IS A SKIP RETURN ON SUCCESS, FAIL IF SYMBOL NOT FOUND.

OFFSET:	MOVEM	T,TEM5
	EXCH	T,SAVLOC	;UPDATE SAVLOC
	MOVEM	T,TEM6		;BUT SAVE OLD VALUE
	PUSHJ	P,RAYNAM	;IS (SAVLOC) AN ARRAY START ADDRESS?
	 JRST	OFF1		;NO
	MOVE	T,TEM5		;GET VALUE OF SYM
	TRO	F,SILENT	;SILENCE
	PUSHJ	P,LOOK		;GET SYM PTR
	 JRST	E5		;
	 JFCL
	MOVE	W1,R		;GET PTR
	MOVEI	W2,0		;YES, OFFSET IS ONE
;**;[063],OFFSET+14, DELETE 2 INSTR , MD ,APR-76
	JRST	OFF2		;GO

;**;[063],OFF1, RECODE OFF1 ROUTINE, MD ,APR-76
;**;[063], REMOVE PART OF EDIT 60 AND ADD ROUTINE OFF1A
OFF1:	MOVE	T,TEM6
	JUMPE	T,OFF1A		;[063] SAVLOC NOT AVAILABLE
	MOVEM	T,SAVLOC	;RESTORE SAVLOC
	PUSHJ	P,RAYNAM	;SET UP DOUBLE IF APPROPRIATE
	  JRST	OFF1A		;[063] NOT AN ARRAY KNOWN
	MOVE	T,TEM5		;RESTORE T
	TRO	F,SILENT	;[063] WE DONT WANT TO TYPE THE SYMBOL
	PUSHJ	P,LOOK		;NOT ARRAY START
	 JRST	OFF6		;[55] GO CHECK FOR FORMAL NAME
	 MOVE	W2,T		;[063] OFFSET - GET IT
	JRST	OFF2		;[063] FOUND - GO PRINT

;**;[063],BEFORE OFF2 INSERT ROUTINE OFF1A, MD, APR-76
OFF1A:	MOVE	T,TEM5		;[063] TRY TO FIND THE REQUESTED SYMBOL
	TRO	F,SILENT	;[063] DONT PRINT NOW
	PUSHJ	P,LOOK		;[063]
	  JRST	OFF6		;[063] MAY BE FORMAL
	  SKIPA	W2,T		;[063] MAY BE AN ARRAY
	JRST	[MOVE	W1,R	;[063] WAS A SINGLE VAR - FOUND
		 PUSHJ	P,SPT	;[063] TYPE NAME
		 JRST	OFF5A]	;[063] TYPE LOC IF NOT CURRENT
	MOVEM	R,TEM6		;[063] KEEP SYMBOL NAME FOUND
	MOVEM	W2,TEM		;[063] KEEP OFFSET
	MOVE	T,TEM5		;[063] GET BACK ORIGINAL ADDR
	SUB	T,W2		;[063] MINUS OFFSET SHOUD BE ARRAY START
	MOVEM	T,SAVLOC	;[063] MAY BE IT IS
	PUSHJ	P,RAYNAM	;[063] TRY IT
	  JRST	ERR34		;[063] NOT
	MOVE	W1,TEM6		;[063] GET BACK SYMBOL NAME
	MOVE	W2,TEM		;[063] AND OFFSET
;;;;	JRST	OFF2		;[063] GO PRINT IT

OFF2:	MOVEM	W2,TEM		;SAVE OFFSET
	PUSHJ	P,SPT		;PRINT SYMBOL
;**;[100] modify @ off2+2 ma 27-aug-77
	openp
	PUSH	P,SAVLOC	;SAVE SAVLOC AROUND OFFSET PRINT
	PUSH	P,AR		;AR TOO
	MOVEM	P,DIMTOT	;AND FREEZE PD LIST
	SETZM	PUTTER
	SETZM	COUNT		;PREPARE
	MOVE	W1,TEM
;**; [73] Insert @ OFF2 + 8 1/2 source lines, JMT, 12-Apr-77
	TRNN	TMOD,C.!L.!D.	;[73] ARRAY HAVE TWO WORD ENTRIES ?
	TRZE	F,DOUBLE	;ARRAY REAL*8?
	LSH	W1,-1		;YES - ONLY HALF OFFSET
	MOVEM	W1,TEM7		;SAVE W1
	MOVEI	T,1
	MOVEM	T,RP		;SET UP RANGE PRODUCT
	PAGE
OFF3:	PUSHJ	P,GETDIM	;GET DIMENSIONS TEM,TEM1
	PUSH	P,TEM		;SAVE LOWER VALUE
	PUSH	P,RP		;SAVE CURRENT RANGE PRODUCT
	MOVE	T,TEM1
	SUB	T,TEM
	AOJ	T,		;FORM RANGE FOR THIS DIM
	IMULM	T,RP
	AOS	COUNT		;INC COUNT OF # OF DIMS
	PUSHJ	P,MORDIM	;MORE?
	 CAIA
	JRST	OFF3		;YES
	MOVE	AR,COUNT	;NO
	MOVE	T3,P		;COPY PD LIST
	MOVE	W1,TEM7		;RESTORE W1

OFF4:	POP	T3,T2		;GET LAST RP
	POP	T3,T		;LOWER SUBSCRIPT
	IDIV	W1,T2		;VALUE OF FIRST ELEMENT
	ADDI	W1,(T)		;CORRECT FOR USERS OFFSET
	HRRZM	W1,1(T3)	;SAVE FOR PRINTING
	EXCH	W1,W2		;GET OFFSET REMAINDER
	SOJG	AR,OFF4

	SKIPA	AR,COUNT	;RESET DIM CNT

;**;[100] modify @ off5 ma 27-aug-77
OFF5:	jrst	[stype(</,/>)
		jrst	.+1]
	HRRE	T,1(T3)		;FIRST ELEMENT
	PUSHJ	P,TYP0		;TYPE IT DECIMAL
	ADDI	T3,2		;NEXT ELEMENT
	SOJG	AR,OFF5

;**;[100] modify @ off5+5 ma 27-aug-77
	closep
	MOVE	P,DIMTOT	;RESET PD LIST
	POP	P,AR
	POP	P,SAVLOC	;RESTORE
;**;[063], OFF5+11 , ADD LABEL , MD , APR-76
OFF5A:	MOVE	T,PNAMSV	;[063] GET SECTION NAME OF SYM
	CAMN	T,OPENED	;IS IT CURRENT?
	JRST	CPOPJ1
	MOVEI	R,PNAMSV
	PUSHJ	P,SECTON	;NO - TYPE IT IF APPROPRIATE
	JRST	CPOPJ1

OFF6:	SKIPN	FRMSAV		;[55] IS THERE A FORMAL NAME
	POPJ	P,		;[55] NO - SYMBOL NOT FOUND
	TYPE	(FORMAL PARAMETER ) ;[55] TELL THE USER
	MOVEI	W1,MATHSM	;[55] TYPE NAME OF FORMAL ARGUMENT
	PUSHJ	P,SPT		;[55] SO HE KNOWS
	LINE			;[55]
	SETZM	MATHSM		;[55] FORGET ABOUT SPECIFIC NAME
	MOVE	T,FRMSAV	;[55] GET ADDRESS OF ACTUAL PAR.
	PUSHJ	P,LOOK		;[55] TRY IT
	 POPJ	P,		;[55] NOT FOUND EITHER
	 SKIPA	W2,T		;[55] OFFSET - GET IT
;**;[063],OFF6+13 , MD, APR-76
	JRST	[MOVE	W1,R	;[063] EXACT ADDR FOUND - TYPE NAME
		 PUSHJ	P,SPT	;[063]
		 JRST	OFF5A]	;[063] IF REQUIRED TYPE NAME OF SECTION
	JRST	OFF2		;[55] CONTINUE
	PAGE
;	SYMBOL OUTPUT SUBROUTINE

SPT:				;RADIX 50 SYMBOL PRINT
	LDB	T,[POINT 32,0(W1),35]	;GET SYMBOL
SPT1:	CAME	T,PRGNAM	;COMPARE NAME WITH MAIN PROG NAME
	CAMN	T,[SQUOZE 0,MAIN.]
	JRST	SPT8
	PUSH	P,T		;SAVE T OVER THE NEXT FEW LINES
	MOVEI	W1,T		;SET UP FOR TRULBL
	PUSHJ	P,TRULBL	;IS THIS A TRUE-LABEL
	 CAIA			;NO
	JRST	SPT5		;YES - SEE IF SOURCE LINE

SPT6:	POP	P,T		;RESTORE T = SYMBOL
	MOVEI	W1,SPT4		;SPECIAL TREATMENT FOR LAST CHARACTER
	PUSH	P,W1		;SAVE ON STACK
SPT3:	TLZ	T,PNAME		;RADIX 50 PART ONLY
	IDIVI	T,50
	HRLM	W1,0(P)
	JUMPE	T,[SETOM W1
		   JRST	.+2]
	PUSHJ	P,SPT3
	HLRZ	T,(P)
	ADDI	T,260-1
	CAILE	T,271
	ADDI	T,301-272
	CAILE	T,332
	SUBI	T,334-244
	CAIN	T,243
	MOVEI	T,256
	ANDI	T,177		;USE 7 BIT CODE
	JUMPL	W1,SPT7		;FIRST TIME ROUND IS SPECIAL
	EXCH	T,SAVCHR	;SAVE AS LAST CHARACTER
	PJRST	TOUT		;DISPLAY CHARACTER

SPT8:	TYPE	(MAIN PROGRAM)
	POPJ	P,

SPT4:	MOVE	T,SAVCHR	;GET BACK THE LAST CHARACTER
	JUMPN	W1,CPOPJ	;DO WE TYPE THE LAST CHARACTER
	PJRST	TOUT		;YES

SPT5:	MOVEI	W1,26		;GET RADIX 50 'L'
	CAMN	W1,TRULST	;IS THIS A SOURCE LINE REFFERENCE
	jrst	[TYPE(L#)
		jrst	.+1]
	JRST	SPT6		;DISPLAY THE SOURCE LINE TAG

SPT7:	CAIL	T,"0"
	CAILE	T,"9"
	TDZA	W1,W1		;ZERO IF FIRST CHAR NOT NUMERIC
	HRRZI	W1,-1		;.GT. ZERO IF FIRST CHAR IS NUMERIC
	MOVEM	T,SAVCHR	;SAVE LAST CHARACTER
	POPJ	P,
	PAGE
	SUBTTL	GENERAL NUMBER INPUT ROUTINE

;	DELIMITERS ARE SPACES TABS OR , OR )   LAST CHAR IN T1

GETNUM:	TDZ	F,[XWD OCTF!SIGN!FPF!MF!FEF,POWF]
	CLEARM	SYL
	CLEARM	DEN
	PUSHJ	P,GETSKB	;REMOVE USERS LEADING SPACES OR TABS
	PUSHJ	P,EITHR3	;PROCESS
EITHR4:	PUSHJ	P,GETNBL	;PROCESS NEXT CHARACTER
	JRST	.-1		;UNTIL DELIMITER
GETNBL:	XCT	GETCHR		;GET NEXT NON BLANK USER CHAR
	PUSHJ	P,GETSK2	;TEST FOR DELIMITERS

;	ENTRY POINT FROM 'EITHER'

EITHR3:	JUMPE	T1,POWER	;LAST CHAR WAS A DELIMITER
	CAIE	T1,","		;ALLOW , AS # DELIMITER
	CAIN	T1,")"		;ALLOW ALSO RIGHT PARENS
	JRST	POWER		; DELIMITER SEEN - CLEAN UP

	CAIE	T1,"/"		;BAR IS A DELIMITER IN DIMENSION DEFS
	CAIN	T1,"]"		;LEFT SQUARE BRKT ALSO
	JRST	POWER		;DELIMITER

	CAIE	T1,":"		;ACCEPT : FOR DIMENSIONS
	CAIN	T1,"="		;ACCEPT = AS DELIMITER
	JRST	POWER

	MOVE	T,T1		;MORE USEFUL IN T
	CAIN	T,42		;IS IT " ?
	JRST	OCTAL		;YES - HOIST THE OCTAL FLAG

	CAIE	T,"+"		;BOTH PLUS AND MINUS
	CAIN	T,"-"		;   DISPATCH TO
	JRST	SGN		;	THE SAME PLACE

	CAIN	T,"."		;PERIOD TYPED ?
	JRST	PERIOD		;THIS MEANS INPUT CANNOT BE OCTAL

	CAIN	T,"E"		;EXPONENT REQUESTED?
	JRST	E		;FLOATING POINT VALUES ONLY RETURNED

	CAIL	T,"0"		;NUMERALS ONLY
	CAILE	T,"9"		;
	JRST	ERR7		;INVALID IF NOT NUMERIC AT THIS STAGE
	SUBI	T,60		;FORM OCTAL REPRESENTATION
	JRST	NUM		;GO DEAL WITH NUMERIC INPUT

OCTAL:	SKIPN	SYL		;HAVE ANY SIGNIFICANT CHARACTERS BEEN SEEN
	TLOE	F,OCTF		;STAMP THIS AS AN OCTAL NUMBER
	JRST	ERR7		;ERROR
	POPJ	P,
	PAGE
SGN:	SKIPE	SYL		;HAVE ANY SIGNIFICANT CHARACTERS BEEN SEEN?
	JRST	ERR7		;YES - TOO BAD
	TLOE	F,SIGN		;HAS A SIGN BEEN SEEN BEFORE?
	JRST	ERR7		;YES - REJECT
	CAIE	T,"+"		;NO SPECIAL ACTION FOR PLUS
	TLO	F,MF		;SET THE MINUS FLAG
	POPJ	P,		;
NUM:	ANDI	T,17		;T HOLDS CHARACTER
	TLNE	F,FPF
	JRST	NM1
	MOVE	W,SYL
	TLNE	W,700000	;TEST FOR PENDING WORD OVERFLOW
	JRST	ERR7		;BAD VALUE
	LSH	W,3
	ADD	W,T
	MOVEM	W,SYL
	MOVE	W,DEN
	IMULI	W,12		;CONVERT TO DECIMAL
	ADD	W,T
	MOVEM	W,DEN
	POPJ	P,

NM1:	MOVEI	W1,6		;FORM FLOATING POINT NUMBER
	AOS	NM1A
NM1A:	MOVEI	W2,0
	MOVSI	R,201400
NM1A1:	TRZE	W2,1
	FMPR	R,FT(W1)
	JUMPE	W2,NM1B
	LSH	W2,-1
	SOJG	W1,NM1A1
NM1B:	MOVSI	W1,211000(T)
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM	R,SYL
	TRO	F,POWF		;INDICATE THAT ANSWER WILL BE FLOATED
	POPJ	P,

POWER:	TLNN	F,FEF		;HAS E BEEN SEEN?
	JRST	POW3		; NO - MUST BE INTEGER OR OCT AL OR #.#
	MOVE	T,SYL
	MOVE	W2,DEN
	CAILE	W2,^D38		;POWERS <38 ONLY
	JRST	ERR7
	MOVEI	W1,FT-1
	TLZE	F,MF
	MOVEI	W1,FT01
	SKIPA	T,FSV
POW2:	LSH	W2,-1
	TRZE	W2,1
	FMPR	T,(W1)
	JUMPE	W2,GETOUT
	SOJA	W1,POW2
	PAGE
PERIOD:	TLNN	F,OCTF		;DO WE HAVE AN OCTAL NO.
	TLOE	F,FPF		;BOTH OCTAL AND FPF CANNOT EXIST TOGETHER
	JRST	ERR7

	MOVE	T,DEN
	IDIVI	T,400
	JUMPE	T,.+2
	TLC	T,243000
	TLC	W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM	T,FH
	MOVEM	T,SYL		;SAVE FLOATING ANSWER
	TRO	F,POWF		;AND REMEMBER WE NOW HAVE REAL
	HLLZS	NM1A
	POPJ	P,

E:	TLON	F,FEF		;HOIST THE FLOAT FLAG IF NOT UP
	TLNN	F,FPF		;REJECT IF E REQUESTED AND NO FPF
	JRST	ERR7

	TRNN	F,POWF		;USER MUST TYPE A DIGIT AFTER THE PERIOD
	JRST	ERR7

	TLZN	F,MF
	SKIPA	W1,SYL
	MOVN	W1,SYL
	MOVEM	W1,FSV
	CLEARM	SYL
	CLEARM	DEN
	TLZ	F,FPF!SIGN!MF
	POPJ	P,


POW3:				;ANSWER IN SYL IF #.# OR OCTAL OR INTEGER

	TLNN	F,FPF!OCTF	;TEST FOR INTEGER
	TLO	F,FPF		;MUST BE INTEGER
	TDNN	F,[XWD OCTF,POWF]
	TLNN	F,FPF		;DO WE HAVE INTEGER?
	SKIPA	T,SYL		;NO - GET OCTAL
	MOVE	T,DEN		;GET DECIMAL
	TLNE	F,MF		;SHOULD WE  RETURN  NEGATIVE#
	MOVNS	T,T		; YES - DO SO
GETOUT:	MOVE	T1,LSTCHR	;SET USERS LAST CHARACTER
	POP	P,(P)
	POPJ	P,		;FINALLY OUT OF GETNUM
	PAGE
	SUBTTL	OUTPUT ROUTINES

;	FLOATING POINT OUTPUT

TFLOT:	MOVE	A,T
	JUMPGE	A, TFLOT1
	MOVNS	A
	MOVEI	T,"-"
	PUSHJ	P,TOUT
	TLZE	A,400000
	JRST	FP1A

TFLOT1:	TLNN	A, 400
	PJRST	FP7		;DECIMAL PRINT

	MOVEI	B,0
	CAMGE	A,FT01
	JRST	FP4

	CAML	A,FT8
	AOJA	B,FP4
FP1A:	MOVEI	C,0

FP3:	MULI	A,400
	ASHC	B,-243(A)
	SETZM	TEM1		;INIT 8 DIGIT COUNTER
	SKIPE	A,B		;DON'T TYPE A LEADING 0
	PUSHJ	P,FP7		;PRINT INTEGER PART OF 8 DIGITS
	MOVEI	T,"."		;GET A MINUS
	PUSHJ	P,TOUT		;AND DISPLAY IT
	MOVNI	A,10
	ADD	A,TEM1
	MOVE	W1,C
FP3A:	MOVE	T,W1
	MULI	T,12
	PUSHJ	P,FP7B
	JUMPE	W1,CPOPJ
	AOJL	A,FP3A
	POPJ	P,
	PAGE
FP4:	MOVNI	C,6		;
	MOVEI	W2,0
FP4A:	ASH	W2,1
	XCT	FCP(B)
	JRST	FP4B

	FMPR	A,@FCP+1(B)
	IORI	W2,1
FP4B:	AOJN	C,FP4A
	PUSH	P,W2		;SAVE EXPONENT
	PUSH	P,FSGN(B)	;SAVE "E+" OR "E-"
	PUSHJ	P,FP3		;PRINT OUT FFF.FFF PART OF NUMBER
	POP	P,W1		;GET "E+" OR "E-" BACK
	PUSHJ	P,TEXT
	POP	P,A		;GET EXPONENT BACK
FP7:	IDIVI	A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS	TEM1
	HRLM	B,(P)
	JUMPE	A,FP7A1
	PUSHJ	P,FP7

FP7A1:	HLRZ	T,(P)
FP7B:	ADDI	T,260
	JRST	TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FCP:	CAMLE	A, FT0(C)
	CAMGE	A, FT(C)
	Z	FT0(C)

FSGN:	ASCII	.E-.
	ASCII	.E+.
	PAGE
;	TTY HANDLERS

TEXT:	TLNN	W1,774000	;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH	W1,35
TEXT2:	MOVEI	T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC	T,7
	PUSHJ	P,TOUT
	JUMPN	W1,TEXT2
	POPJ	P,

TXT341:	MOVEI	W2,5		;FIVE CHARACTERS
	TYPE(")
	MOVE	W1,T
TXT2:	SOSGE	W2
	JRST	TXT3		;END
	MOVEI	T,0
	LSHC	T,7
	PUSHJ	P,ASCOUT
	JRST	TXT2
TXT3:	TYPE(")
	POPJ	P,

SIXBP:	MOVEM	T,LWT
	MOVNI	W2,6		;SIXBIT PRINTER
	MOVE	W1,LWT
SIXBP1:	MOVEI	T,0
	ROTC	T,6
	ADDI	T,40
	PUSHJ	P,TOUT
	AOJL	W2,SIXBP1
	POPJ	P,

FTOC:	HRRZ	W1,ODF		;NUMERIC OUTPUT SUBROUTINE
	CAIN	W1,10		;IS OUPUT RADIX NOT OCTAL
	jrst	[TYPE(")		;SHOW  CURRENT OUTPUT AS OCTAL
		jrst	.+1]
	HRRZ	W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN	W1,12
	JRST	TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC	T,-43
	LSH	W1,-1		;W1=T+1
	DIVI	T,@ODF
	HRLM	W1,0(P)
	JUMPE	T,.+2
	PUSHJ	P,TOC0
	HLRZ	T,0(P)
	ADDI	T,"0"
	PJRST	TOUT
TOC4:	JUMPGE	T,TOC5		;TEST FOR NEGATIVE #
	TYPE(-)
TOC5:	MOVMS	T,T		;GET MAGNITUDE
	JRST	TOC0		;DO NORMAL RADIX PRINT
	PAGE
;**;[100] modify @ tout ma 28-aug-77
TOUT:	putchr	(T)		;[100]OUTPUT A CHARACTER
	POPJ	P,

;**;[100] conditionalize TOPS10 code @ listen ma 28-aug-77
ife tops20,<
LISTEN:	INCHRS	T		;GET NEXT CHAR, NO IO WAIT
	POPJ	P,		;NO CHARACTER EXISTED, RETURN
	CLRBFI			;CLEAR OUT INPUTBUFFER
	JRST	CPOPJ1>		;CHAR WAS THERE, SKIP RETURN,end of conditional
;**;[100] add native code @ listen ma 28-aug-77
ifn tops20,<
listen:	push	p,tf		;[100]save tf
	push	p,r		;[100]save r
	hrrzi	tf,.priou	;[100]get terminal output designator
	rfmod			;[100]get terminal JFN word
	tlz	r,(tt%osp)	;[100]clear ^o
	hrrzi	tf,.priou	;[100]get terminal output designator
	sfmod			;[100]set new terminal JFN word
	hrrzi	tf,.priin	;[100]get terminal input designator
	sibe			;[100]check for pending input
	caia
	jrst	rpopj		;[100]no pending input
	hrrzi	tf,.priin	;[100]get terminal input designator
	cfibf			;[100]clear input buffer
	aos	(p)		;[100]set up for skip return
rpopj:	pop	p,r		;[100]restore r
tfpopj:	pop	p,tf		;[100]restore tf
	popj	p,>		;[100]return, end of conditional
;**;[100] conditionalize TOPS10 code @ ttyclr ma 28-aug-77
ife tops20,<
TTYCLR:	SKPINC			;CLEAR ^O, SKIP ON INPUT CHARS
	  POPJ	P,		;NO INPUT CHARS, OR EXEC MODE
	CLRBFI			;FLUSH ALL
	POPJ	P,>		;WAITING INPUT CHARACTERS, end of conditional
;**;[100] add native code @ ttyclr ma 28-aug-77
ifn tops20,<
ttyclr:	pushj	p,listen	;[100]let listen do the work
	popj	p,		;[100]no characters were pending
	popj	p,>		;[100]pending chars flushed, end of conditional


OUT6:	MOVE	T,T1		;PRINT (T1) AS A SIXBIT WORD
	PJRST	SIXBP		;PRINT IT


;	ROUTINE TO CLEAR OUT REST OF USERS LINE

CLRLIN:	PUSHJ P,SAV2AC		;SAVE T THRO. CLRLIN
;**;[76] add label @ clrlin+1 ma 22-aug-77
;**;[100] insert TOPS10 conditional and native code @ clrli2 ma 29-aug-77
CLRLI2:
ife tops20,<
	SKPINL			;[76]SKIP IF ANY CHARS THERE
	  POPJ	P,>		;LINE CLEAR, end of conditional
ifn tops20,<
	push	p,tf		;[100]save tf
	sibe			;[100]more to come?
	caia			;[100]yes
	jrst	tfpopj		;[100]no
	pop	p,tf>		;[100]restore tf, end of conditional
	PUSHJ	P,GCHR		;GET THE NEXT CHAR
	SKIPL	TERMK		;NOW DONE?
	POPJ	P,		;YES
;**;[76] insert @clrlin+5 ma 22-aug-77
	CAIN	T1," "		;[76]SPACE OR TAB?
	JRST	CLRLI2		;[76]IGNORE IT
	SKIPE	DELCHR		;[76]DELIMITER SAVED FROM ASCII ACCEPT?
	CAME	T1,DELCHR	;[76]OR DELIMITER FOUND?
	JRST	CLRLI1		;[76]NO, PROCEED AS USUAL
	SETZM	DELCHR		;[76]CLEAR SAVED DELIMITER
	JRST	CLRLI2		;[76]AND TRY AGAIN
CLRLI1:	SETZM	DELCHR		;[76]MAKE SURE IT'S ZERO
	LINE
	TYPE	(%FDTCHI CHARACTERS IGNORED: ")	;WARN THE USER
	PUSHJ	P,OUTL1		;TYPE THE REST OF THE LINE
	TYPE	(")
	LINE
	POPJ	P,		;YES - LINE CLEARED

;	ROUTINE TO CLEAR OUT USER LINE AND DISPLAY REMAINING TEXT

ENDLIN:	SKIPL	TERMK		;END OF USER LINE?
	POPJ	P,		;YES
;**;[100] modify @ endlin+2 ma 28-aug-77
	putchr	(LSTCHR)	;[100]DISPLAY USERS LAST CHAR IN ERROR
	PJRST	OUTLIN		;AND TYPE THE REST OF THE LINE

;PRINT ALL CHARACTERS REMAINING IN THE INPUT BUFFER

OUTLIN:	PUSHJ	P,GCHR		;GET THE NEXT CHAR
	SKIPL	TERMK		;DONE?
	POPJ	P,		;YES
;**;[100] modify @ outl1 ma 28-aug-77
OUTL1:	putchr	(T1)		;[100]TYPE IT
	JRST	OUTLIN		;NEXT

GCHR:	XCT	GETCHR		;GET CHARACTER
	PUSHJ	P,GETSK2	;SET UP DELIMETER FLAGS
	JUMPN	T1,CPOPJ
	MOVEI	T1," "		;RECONVERT NULLS TO SPACES
	POPJ	P,
	PAGE
TYP0:	MOVEI	ODF,^D10	;PREPARE FOR DECIMAL PRINT
	PJRST	FTOC		;DO IT

TYP1:	TYPE(?FDTIAT ILLEGAL ARGUMENT TYPE = )
	MOVEI	ODF,10		;PRINT DEFAULTING ARG TYPE AS OCTAL
	HRRZ	T,T2		;TOC PRINTS T
	PJRST	FTOC		;DISPLAY ARGUMENT TYPE

TYP4:	MOVEI	ODF,10		;PRINT OCTAL
	PJRST	FTOC		;PRINT

TYP5:	PJRST	TXT341		;SHOW AS ASCII
	PAGE
;	F10 ARGUMENT PROCESSING

GETARG:	HRR	T3,AC0+16	;GET USERS AC 16 I.E. ARG BLOCK?
	HLL	T3,-1(T3)	;L.H. =-# OF ARGS ,,R.H. = ADDRESS
	JUMPGE	T3,CPOPJ	;APPEARS TO BE NO ARGS

	CAMGE	T3,[777700,,0]	;ARBITRARY LIMIT OF 64 ARGS
	POPJ	P,		;PREVENT RUN AWAY
	LINE
	TYPE(ARGUMENTS ARE:)
F10.2:	MOVEM	T3,SAVT3	;SAVE T3 DURING OUTPUT
	LINE
	LDB	T2,[POINT 4,(T3),12]	;GET ARGUMENT TYPE
	TYPE(	= )
	PUSHJ	P,FOROTS	;GET FOROTS TO TYPE ARGS
	MOVE	T3,SAVT3	;RE-INSTATE T3
	AOBJN	T3,F10.2	;MOVE TO NEXT ARG
	LINE
	POPJ	P,



TYP10:	F10.6			;0 = UNDEFINED
	F10.6			;1 = LOGICAL
	F10.6			;2 = SINGLE  PRECISION INTEGER
	TYP1			;3 = ILLIGAL
	F10.6			;4 = SINGLE PRECISION REAL
	TYP1			;5 = ILLEGAL
	TYP4			;6 = OCTAL
	F10.3			;7 = LABEL
	F10.6			;10= DOUBLE PRECISION REAL
	F10.4			;11= DOUBLE PRECISION INTEGER
	F10.5			;12= DOUBLE OCTAL
	TYP1			;13= ILLEGAL
	F10.6			;14= COMPLEX
	TYP1			;15= ILLEGAL
	TYP1			;16= ILLEGAL
	TYP5			;17= ASCII STRING
	PAGE
;	ROUTINE TO 'TYPE' AN ARGUMENT OF A SUBROUTINE CALLING LIST
;	ENTER WITH T= VALUE OF 1ST. ARG
;	T2= ARG TYPE
;	T3=POINTER IN SUBROUTINE ARGBLOCK

FOROTS:	MOVEI	T,@(T3)		;GET SECOND ARGUMENT ADDRESS
	MOVE	T,1(T)		;GET SECOND ARGUMENT
	MOVEM	T,ARGVAL+1	;STORE SECOND ARG
	MOVE	T,@(T3)		;GET FIRST ARGUMENT

;	ENTRY TO 'TYPE' A SINGLE VALUE IN T - ARG TYPE IN T2

FOROUT:	MOVEM	T,ARGVAL	;SAVE FIRST ARGUMENT FOR TYPING
DPBTYP:	DPB	T2,[POINT 4,M2.,12]	;PLACE ARG TYPE
	JRST	@TYP10(T2)	;DISPATCH ACORDING TO ARGUMENT TYPE

F10.6:	SKIPIF(OUT.)
	   POPJ	P,		;SHOULD NEVER HAPPEN
F10.8:	MOVEI	16,M1.		;GET ADDRESS OF FORMAT BLOCK
	PUSHJ	P,@GOLOC	; - AND TELL FOROTS ABOUT IT
	SKIPIF(IOLST.)
	   POPJ	P,		;SHOULD NEVER HAPPEN!
	MOVEI	16,M2.		;GET THE IOLIST ARGBLOCK
;**;[101] @F10.8 + 5L  SJW  23-OCT-77
	PUSHJ	P,@GOLOC	;[101] - AND LET FOROTS DO ITS THING
	PJRST	FORBUF		;[101] MUST CLEAR TTY BUFF SO FOROTS
				;[101]  EDIT 661 DOESN'T OVERWRITE NEXT LINE

F10.3:	TYPE(	LABEL)
	POPJ	P,

F10.4:	PUSHJ	P,TYP0		;TYPE FIRST INTEGER ARG
	TAB
	MOVE	T,ARGVAL+1	;GET SECOND ARG
	PJRST	TYP0		;TYPE SECOND ARG AS INTEGER AND EXIT

F10.5:	PUSHJ	P,TYP4		;TYPE FIRST ARG AS OCTAL
	TAB
	MOVE	T,ARGVAL+1	;GET SECOND OCTAL ARG
	PJRST	TYP4		;TYPE NEXT OCTAL ARG AND EXIT
	PAGE
;	ENTRY TO READ UP TO TWO WORD ENTRIES - ARG TYPE IN T2

FORINP:	XCT	DPBTYP		;PLACE ARGUMENT TYPE FOR INPUT
	SKIPIF(IN.)
	   POPJ	P,		;CAN'T GET HERE IF FOROTS IS IN
	PJRST	F10.8		;ACTION




;	THIS ROUTINE CAUSES FOROTS TO EMPTY ITS TTY BUFFER

FORBUF:	SKIPIF	(OUT.)
	 POPJ	P,		;SHOULDN'T HAPPEN
	MOVEI	16,M3.		;ARG BLOCK
	PUSHJ	P,@GOLOC	;CALL OUT.
	SKIPIF	(FIN.)
	 POPJ	P,		;SHOULDN'T EVER HAPPEN
	PJRST	@GOLOC		;DO IT AND RETURN




;ARG BLOCK FOR CALLS TO FOROTS

	777773,,0		;FIVE ARGUMENTS FOLLOW
M1.:	0,,-1			;OUTPUT TO TTY =-1
	0,,0			;END=
	0,,0			;ERR=   POSSIBLY SHOULD BE 0,,RET
	340,,FORMAT		;ASCII,,FORMAT
	0,,2			;TWO WORDS OF FORMAT INFO
	0,,0			; ?
M2.:	1200,,ARGVAL		;DATA 0-8/ARGTYP 9-12/ARGADDRESS 13-35
M2.I:	4000,,0			;CALL FIN - MAY BE USED FOR COMPLEX
M2.F:	4000,,0			;CALL FIN
ARGVAL:	BLOCK	2		;STORAGE FOR DOUBLE WORD ARGUMENTS
FORMAT:	ASCIZ/('+'G,G)/		;[101] + CARRIAGE CONTROL FOR EDIT OTS 661

	-5,,0
M3.:	0,,-1
	0,,0
	0,,0
	340,,FORM2
	0,,2
FORM2:	ASCIZ	.(1H+$).
	PAGE
SUBTTL	GENERAL SUBROUTINES



;CHKADR CHECKS THE LOCATION IN THE RH(T) FOR VALIDITY AS A USER
;ADDRESS.  RETURNS ARE:
;
;	PUSHJ	P,CHKADR	;WITH LOCATION IN T
;	 <ILLEGAL ADDRESS>
;	 <HISEG ADDRESS>
;	<LOSEG ADDRESS>



;**; [74] Insert @ CHKADR, JMT, 12-Apr-77
CHKADR:	PUSH	P,T		;[74] SAVE T FOLKS !
	MOVEI	TT,(T)
	CAIGE	TT,.JBDA	;ABOVE .JBDA
	JRST	TPOPJ		;[74] FAIL - ILLEGAL
	CAMG	TT,.JBREL	;BELOW HERE IS OK TOO
	JRST	TPOPJ2		;[74]
	MOVE	T4,R		;SAVE (R)
	PUSHJ	P,GSTAH		;GET THE START ADDR OF THE HISEG
	EXCH	T4,R
	CAIGE	TT,10(T4)	;
;**; [74] Change @ CHKADR + 9 1/2 lines, JMT, 12-Apr-77
	JRST	TPOPJ		;[74]
	HRRZ	T4,.JBHRL	;GET TOP OF HISEG
	CAILE	TT,(T4)		;
	JRST	TPOPJ		;[74]
	JRST	TPOPJ1		;[74] DONE

TPOPJ:	POP	P,T		;[74] RESTORE T
	POPJ	P,		;[74] AND RETURN

TPOPJ1:	POP	P,T		;[74] RESTORE T
	JRST	CPOPJ1		;[74] AND GIVE SKIP RETURN

TPOPJ2:	POP	P,T		;[74] RESTORE T
	JRST	CPOPJ2		;[74] AND GIVE DOUBLE SKIP RETURN
	PAGE
;REINOP - REINSTATE OPENED PROGRAM - THIS ROUTINE IS CALLED AFTER
;A GROUP REQUEST HAS BEEN EXHAUSTED TO RE-OPEN THE PROGRAM THAT WAS
;OPEN AT THE BEGINNING O THE REQUEST.


REINOP:	SKIPN	T3,OLDOPN	;GET THE OLD NAME
	POPJ	P,		;NONE - OK
	SETZM	OLDOPN
	CAMN	T3,OPENED	;SAME AS THE CURRENT?
	POPJ	P,
	MOVEM	T3,SYM		;NO - SAVE IT
IMPOPN:	LINE
;**;[100] modify @ impopn+1 ma 27-aug-77
	stype(.[IMPLICIT OPEN .)
	MOVE	T,SYM		;GET SYMBOL
	PUSHJ	P,SPT1		;TYPE PROGRAM NAME
;**;[100] modify @ impopn+4 ma 27-aug-77
	type(])
	LINE
	PJRST	SETNAM		;SET IT AND DONE
	PAGE
;ROUTINE TO READ WORDS FROM ASCII STRING FROM TTY
;FILTERS OUT TAB & SPACE
;STOPS ON ANY NON-ALPHA NUMERIC, CALLER MUST CHECK FOR LEGAL BREAK
;SET FLAGS FOR LEGAL LINE TERMINATORS
;
;	CALL	PUSHJ	P,TTYIN
;RETURN WITH SIXBIT WORD IN T2 LEFT JUSTIFIED, BREAK IN T1
;
;CFLIU	=	CORE FILE IN USE FLAG
;OFCFL	=	OUTPUT FROM CORE FILE FLAG
;
;N.B.	CLEAR GETCHR FOR FIRST CORE FILE ACCESS
;	ALWAYS CLEAR CFLIU IMMEDIATELY AFTER LINE END

I2CFIL:	HRRZ	T1,CFLPTR	;CURRENT POSITION IN CORE FILE
	SUBI	T1,CFSIZ	;REMOVE OFFSET
	CAML	T1,CFLST	;PRVENT CORE FILE OVERFLOW
	JRST	ERR12
;**;[100] modify @ i2cfil+4 ma 29-aug-77
	pushj	p,loadch	;GET USERS CHARACTER
	IDPB	T1,CFLPTR	;STORE IT IN CORE FILE FOR FUTURE ACCESS
	POPJ	P,		;

CFLST:	Z		;HOLDS START ADDRESS OF CORE FILE
CFLPTR:	Z
CFLBUF:	XWD	050000,0	;HOLDS CORE FILE FOR TYPE REQUEST
	BLOCK	CFSIZ-1
GETCHR:	Z			;EXCECUTED TO READ OR WRITE CHARACTERS


TTYIN:	MOVE	T,[pushj p,loadch]
	TLNN	F,CFLIU		;DO WE WISH TO USE A CORE FILE?
	JRST	XCTSET		;NO - JUST SET UP FOR NORMAL TTY INPUT
	SKIPE	GETCHR		;YES - FIRST CHAR OF LINE?
	JRST	TTYSET		;   NO - DO NOT TOUCH POINTERS
	MOVE	T,[POINT 7,CFLBUF]
	MOVEM	T,CFLPTR	;SET UP GENERAL CORE FILE POINTER
	HRRZM	T,CFLST		;	HOLDS START OF CURRENT CORE FILE
	TLNN	F,OFCFL		;OUTPUTTING TO CORE FILE?
	SKIPA	T,[PUSHJ P,I2CFIL]	;YES
	MOVE	T,[ILDB T1,CFLPTR]
XCTSET:	MOVEM	T,GETCHR	;SET UP FOR FUTURE XCT

TTYSET:	SETOM	TERMK			;PREPARE TERMINATOR FLAG
	PUSHJ	P,GETSKB		;SKIP LEADING BLANKS & TABS
EITHR5:	MOVEI	T2,0			;SET WORD TO ZERO FOR RETURN
	MOVE	T3,[XWD 440600,T2]	;SET SIXBIT BYTE POINTER
	PAGE
;LOOP TO ACCUMULATE AFTER LEADING SPACES & TABS

GETWLP:	JUMPE	T1,CPOPJ	;EXIT IF TERMINATOR FOUND
	CAIL	T1,"0"		;LESS THAN 0 ?
	CAILE	T1,"9"		;LESS THAN OR EQUAL TO 9 ?
	JRST	GETWD2		;YES - SEE IF LETTER
	JRST	GETWD3		;NO - NUMBER,STORE

;	HERE IF NOT A NUMBER

;**;[067],GETWD2,MD,APR-76
GETWD2:	CAILE	T1,"Z"+40	;[067] ABOVE LOWER CASE RANGE ?
	PJRST	GETSK1		;YES - SET BREAK
	CAIL	T1,"A"+40	;LOWER CASE ?
	TRC	T1,40		;YES - CONVERT TO UPPER CASE
	CAIL	T1,"A"		;LESS THAN A ?
	CAILE	T1,"Z"		;LESS THAN OR EQUAL TO Z ?
	PJRST	GETSK2		;NON-ALPHA OR NUMERIC IS A DELIMITER
				;& RETURN TO CALLER

;	HERE IF A LETTER OR NUMBER - CONVERT TO SIXBIT & STORE

GETWD3:	SUBI	T1,40		;CONVER TO SIXBIT
	TLNE	T3,770000	;OVERFLOWED T2 YET ?
	IDPB	T1,T3		;NO STORE NEXT SIXBIT CHR.
	XCT	GETCHR		;GET NEXT CHARACTER
	JRST	GETWLP		;& CHECK IT

;	ROUTINE TO SETUP FOR TRANSFER TO AN EXTERNAL TASK
;	GOLOC WILL CONTAIN THE DISPATCH ADDRESS IF SYMBOL FOUND
;	ENTER WITH RADIX50 SYMBOL IN T
;	NON-SKIP EXIT IF UNKNOWN SYMBOL
;	SKIP EXIT IF OK

FINDST:	EXCH	T,SYM		;SAVE FOR EVALUATION BY 'EVAL'
	MOVEM	T,SYL		;SAVE SYM
	TLO	F,FGLSNM	;FIND GLOBAL SYMBOL
	MOVSI	T,GLOBAL	;ONLY GLOBALS
	MOVEM	T,SYMASK
	PUSHJ	P,FNDSYM	;FIND THE ASSOCIATED ADDRESS
	   POPJ	P,		;NO SUCH SYMBOL
	HRRM	T,GOLOC		;SAVE  ADDRESS FOR DISPATCH IN GOLOC
	MOVE	T,SYL		;GET THE OLD SYM
	MOVEM	T,SYM		;RE-INSTATE SYM
	JRST	CPOPJ1		;GOOD RETURN

;	ROUTINE TO TRANSFER CONTROL TO AN EXTERNAL TASK
;	ASSUMES GOLOC HAS BEEN SET UP BY USE OF SKIPIF MACRO

EXTASK:	PUSHJ	P,INSRTB	;PUT IN PAUSE REQUESTS
	JSP	T,RESTORE	;RESTORE USERS ACS
	JRST	@GOLOC		;OF YOU GO
	PAGE
;	REMOVE BLANKS & TABS

GETSKB:	XCT	GETCHR		;GET NEXT CHARACTER
GETSK1:	CAIE	T1," "		;SPACE ?
	CAIN	T1,11		;TAB ?
	JRST	GETSKB		;YES - GET NEXT CHR

GETSK2:	CAIN	T1,15		;NO - FOUND NON-BLANK
	JRST	GETSKB		;IGNORE CR.
	CAIE	T1,12		;TEST FOR LINE FEED
	CAIN	T1,14		;FORM HAS THE SAME ACTION
	JRST	TERMLF		;YES - ACTION
	CAIE	T1,13		;CONTRL K = EOL
	CAIN	T1,7		;BELL - WILL DELIMIT
	JRST	TERMLF		;        NO EXTRA LF
	CAIN	T1,33		;TEST FOR ALTMODE
	JRST	TERNAM		;YES - ACTION
	CAIE	T1,175
	CAIN	T1,176
	JRST	TERNAM
	CAIN	T1,32		;TEST FOR ^Z
	JRST	TERMCZ		;YES - ACTION
	CAIE	T1," "		;TEST - SPACE
	CAIN	T1,11		;ACCEPT TAB
	JRST	TERMSP		;YES - ACTION
;**;[065],GETSK2+22,MD,APR-76
	CAIN	T1,"!"		;[065]DELIMITER FOR COMMENT
	JRST	CLRCOM		;[065] YES

	MOVEM	T1,LSTCHR	;SAVE USERS LAST CHARACTER
	POPJ	P,		;NO - RETURN


;	SET END OF LINE CHR FLAGS

TERNAM:	LINE
	AOS	TERMK		;SET TERMINATOR FLAGS
TERMLF:	AOS	TERMK
TERMCZ:	AOS	TERMK
TERMSP:	SETZB	T1,LSTCHR	;ZERO CHR
	POPJ	P,		;RETURN


LSTCHR:	Z			;USERS LAST CHARACTER

;**;[065],AFTER LSTCHR: INSERT ROUTINE CLRCOM,MD,APR-76
;	ROUTINE TO SKIP OVER THE COMMENT
;	COMMENT FORMAT IS:	! COMMENT... TO END-OF-LINE
;			OR:	! COMMENT !

CLRCOM:	TRCE	TF,COMDEL	;[065] FIRST !
	JRST	GETSKB		;[065] NO - END COMMENT - GET NEXT CH
CLRCO1:	SETOM	TERMK		;[065] PREPARE TEST FOR END OF COMMENT
	PUSHJ	P,GETSKB	;[065] GET NEXT CH
	TRNN	TF,COMDEL	;[065] DID WE FIND SECOND !
	POPJ	P,		;[065] YES - WE GOT NEXT COMMAND CH
	JUMPN	T1,CLRCO1	;[065] IF VALID CHAR IGNORE (PART OF COMMENT)
	SKIPGE	TERMK		;[065] EOL FOUND
	JRST	CLRCO1		;[065] NO CONTINUE
	TRZ	TF,COMDEL	;[065] NOT IN COMMENT PROCESS ANYMORE
	POPJ	P,		;[065] RETURN TO CALLER

;**;[100] insert routines loadch and readcm @ sixin-1 ma 29-aug-77
ife tops20,<
loadch:	inchwl	t1
	popj	p,>
ifn tops20,<
loadch:	push	p,tf		;[100]save tf
	pbin			;[100]read byte from terminal
	move	t1,tf		;[100]put it where it belongs
	pop	p,tf		;[100]restore tf
	popj	p,>		;[100]return, end of conditional
ife tops20,<
readcm:	closeb
	closeb
	type( )
	pjrst ttyin>
ifn tops20,<
readcm:	push	p,tf
	push	p,r
kparse:	move	t,[percsb,,temcsb]
	blt	t,temcsb+.cmgjb
	hrrzi	tf,temcsb
	hrrzi	r,funini
	comnd
lparse:	hrrzi	tf,temcsb
	hrrzi	r,funkey
	comnd
	tlne	tf,(cm%nop)
	haltf
	tlne	tf,(cm%eoc)
	jrst	cgo
	hrrzi	tf,lparse
	hrrzm	tf,temcsb
cloop:	hrrzi	tf,temcsb
	hrrzi	r,fungar
	comnd
	tlnn	tf,(cm%eoc)
	jrst cloop
cgo:	hrroi	1,parbuf
	rscan
	haltf
	setz	tf,
	rscan
	haltf
	pop	p,r
	pop	p,tf
	pjrst	ttyin>
	PAGE
;	SUBROUTINE TO READ EITHER A SYMBOL OR A CONSTANT FROM USER
;	PUSHJ P,EITHER
;	RETURN WITH CONSTANT IN T
;	RETURN SYMBOL VALUE IN T
;	IN ALL CASES T1=USERS LAST CHARACTER
;
;	ADDITIONALY ENTER AT SIXIN TO ACCEPT LEFT JUSTIFIED SIXBIT
;	IF USERS LEADING CHARACTER IS ALPHA

SIXIN:	TRO	TF,ALPHA		;THIS MODIFIES EITHER
EITHER:	SETOM	TERMK
	CLEARM	SYL
	CLEARM	DEN
	TDZ	F,[XWD FPF!FEF!MF!SIGN!OCTF,POWF]	;REMOVE THE UNWANTED FLAGS
EITHR2:	XCT	GETCHR		;READ USER INPUT
	CAIE	T1," "		;TILL NO BLANKS
	CAIN	T1,11		;OR TABS
	JRST	EITHR2

	PUSHJ	P,GETSK2	;TEST FOR DELIMITER
	JUMPE	T1,BADSYN
;**;[56] EITHR2+6  ADD CHECK FOR LOWER CASE ,MD, 7-AUG-75
	CAIL	T1,"A"+40	;[56] ACCEPT LOWER CASE
	CAILE	T1,"Z"+40	;[56] CHARACTERS
	JRST	.+2		;[56] IS NOT
	TRC	T1,40		;[56] IS - CONVERT TO UPPER CASE
	CAIL	T1,"A"
	CAILE	T1,"Z"

		;**** NUMERIC INPUT ****
	JRST	[TRZ	TF,ALPHA ;NO LONGER NEEDED
		 XCT	GETNUM	;CLEAR FLAGS
		 PUSHJ P,EITHR3	;MUST BE A CONSTANT
		 JRST	EITHR4]	;NON SKIP RETURN
	TRZE	TF,ALPHA	;ARE WE TRAPPING ALPHA
	JRST	SIXIN2		;YES

		;**** SYMBOLIC INPUT ****
		;SIMULATE A CALL OF SYMIN

	RECURS <DIMTOT,F,PUTTER,RP,SAVLOC,SYM,MATHSM,TEM,TEM1,DIMCNT,RAY.,FRMSAV>
	TRZ	F,DOUBLE	;ONLY THE BASE ARRAY IS ALLOWED TO BE REAL*8
	PUSHJ	P,EITHR5	;SYMBOL
	PUSHJ	P,SYM2		;ALLOW FOR OFFSET
	   JRST	ERR6		;NOT DEFINED
	   JRST	BADSYN

	SRUCER			;POP BACK ALL SAVED LOCATIONS

	JRST	CPOPJ1		;SYMBOL VALUE SKIP RETURN

SIXIN2:	PUSHJ	P,EITHR5	;CONTINUE AS TTYIN
	JRST	CPOPJ1		;DO A SYMBOL RETURN
	PAGE
;ROUTINE TO CONVERT FROM SIXBIT TO RADIX 50

;	CALL PUSHJ	P,SIX250	WITH 6BT IN T2
;	RETURNS		HERE		WITH RAD 50 IN T3
;	N.B.		USES: T1/T2/T3/T4/T5

SIX250:	MOVE	T1,[POINT	6,T2]	;SET UP BYTE POINTER FOR 6BT
	SETZI	T3,		;CLEAR FOR RAD 50
	MOVEI	T5,50		;SET UP TO FORM RADIX 50
SIXMOR:	ILDB	T4,T1		;GET NEXT 6BT BYTE
	JUMPE	T4,CPOPJ	;EXIT IF ZERO=LAST BYTE

	CAIL	T4,20		;ACCEPT NUMERALS
	CAILE	T4,31		;
	JRST	LETR		;NOT NUMERIC MAY BE ALPHA
	SUBI	T4,17		;CONVERT TO RAD 50
	JRST	R50CHR		;STORE

LETR:	CAIL	T4,41		;IS IT ALPHA
	CAILE	T4,72		;
	JRST	BADSYN		;CANT CONVERT
	SUBI	T4,41-13	;MAKE RAD 50
R50CHR:	IMULI	T3,(T5)		;MOVE UP LAST ENTRY
	ADDI	T3,(T4)		;UP DATE WITH NEW CHARACTER
	TLNE	T1,770000	;DONE 6 BYTES?
	JRST	SIXMOR		; NO
	POPJ	P,		; YES


;	ROUTINE TO CHECK THAT WE HAVE A LEGAL FORTRAN VARIABLE
;	AND CONVERTS FROM 6 BIT LEFT JUSTIFIED IN T2 TO RAD 50 IN T3


VALID:	MOVE	T1,[POINT 6,T2]	;GET FIRST CHARACTER
	ILDB	T3,T1		; IN T3
	CAIL	T3,41		;
	CAILE	T3,72		;ALPHA ONLY
	JRST	ERR5		; NOT F40
	PJRST	SIX250
	PAGE
;	SUBROUTINE TO CHECK THAT ALL 6BIT CHARACTERS IN T2 ARE NUMERIC
;	CALL PUSHJ	P,ALLNUM
;	NOT ALL NUMERIC
;	ALL NUMERIC WITH P APPENDED IF A LABEL OR # IF SOURCE LINE

ALLNUM:	MOVE	T3,[POINT 6,T2]	;GET POINTER TO INPUT
ALLMOR:	ILDB	T1,T3		;GET NEXT 6BIT CHAR
	JUMPE	T1,ALLEX	;ALL DONE
	CAIL	T1,20		;TEST WITHIN RANGE
	CAILE	T1,31		;  OF NUMERALS 6BT
	JRST	ALLIN		;NO - SEE IF WE HAVE A SOURCE LINE

	TLNE	T3,770000	;ALL 6 CHARS NUMERIC??????
	JRST	ALLMOR		;  NO - SO DO MORE
	JRST	BADSYN		;  YES - OO NASTY

ALLIN:	TLZE	F,LABEL		;ARE WE ALREADY PROCESSING LABEL INFO.
	JRST	BADSYN		;YES - ANOTHER # MUST BE REJECTED
	MOVEI	T1,"#"		;SEE IF THE USER IS TRYING TO GIVE LINE#
	CAME	T1,LSTCHR	;WAS A # HIS LAST CHARACTER
	JRST	CPOPJ		;NO USEFUL CHARACTERS TYPED - MAYBE GROUP#
	JRST	BADSYN		;YES - COMPLAIN ABOUT PRECEDING GARBAGE

ALLEX:	TLZN	F,LABEL		;ARE WE PROCESSING SOURCE LINES
	JRST	ALLFRM		;NO - SEE IF A FORMAT
	MOVEI	T1,'L'		;YES - GET THE SOURCE LINE TAG
	DPB	T1,T3		;CONVERT TO THE FORM FORTRAN RECOGNISES
	JRST	CPOPJ1		;EXIT AS ALL NUMERIC FROM USER

ALLFRM:	MOVEI	T1,'P'		;SET UP FOR A LABEL
	DPB	T1,T3		;CONVERT TO THE STANDARD FORTRAN FORM
	JRST	CPOPJ1		;DO AN ALL NUMERIC EXIT
	PAGE
;	ROUTINE TO GET NEXT USER SYMBOL AND RETURN
;	THE RADIX 50 SYMBOL NAME IN SYM
;	SYMBOL = NAME[V1/V2,..](V3,..), . .
;	7 DELIMITERS ARE ALLOWED AFTER SYMBOL ] ) / . , - =
;	V1-V2    V1,    V1(V2)    V1(V2/V3)    V1[V2]    V1=    V1.LT.V2
;	  ^	   ^	     ^	       ^	    ^      ^      ^
;	CALL	PUSHJ P,SYMIN
;	RETURN  NOT FOUND
;		STATEMENT NO.
;		VARIABLE		T=VALUE OF SYMBOL
;					T1=LAST CHARACTER
;				SUBFLG IS SET IF ARRAY NAME ONLY FOUND

SYMIN:	TLZ	F,LABEL		;CLEAR LABEL PROCESSING FLAG
	SETZM	MATHSM		;CLEAR SYMBOL SAVE
	PUSHJ	P,TTYIN		;GET USER SYMBOL
	JUMPN	T2,SYM12	;NO CHARACTERS - MAYBE SOURCE LINE OR GROUP SPEC.
	CAIE	T1,"#"		;IS THE USER ATTEMPTING TO SPECIFY A SOURCE LINE
	JRST	SYM4		;NO! - WELL MAYBE A GROUP REQUEST

	TLO	F,LABEL		;REMEMBER THIS IS A SOURCE LINE REQUEST
	PUSHJ	P,TTYIN		;GET USERS NEXT INFO.
	JUMPE	T2,BADSYN	;ZERO CHARACTERS HERE IS BAD

SYM12:	PUSHJ	P,ALLNUM	;SEE IF USER TYPED ALL NUMERIC
	  JRST	SYM2		;NO - MUST BE A VARIABLE
	MOVE	T1,LSTCHR	;REINSTATE USERS LAST CHAR
	CAIE	T1,","		;SEE IF A KNOWN DELIMITER FOLLOWS
	JUMPN	T1,BADSYN	;ANY OTHER CHARACTER IS ILLEGAL
	PUSHJ	P,SIX250	;CONVERT SYMBOL TO RADIX 50
	TLOA	F,LABEL		;SET THE LABEL PROCESSING FLAG

;	MULTIPLY RECURSIVE CALLS ARE MADE TO HERE BY ROUTINE EITHER

SYM2:	PUSHJ	P,VALID		;TEST FOR A TRUE F40 VARIABLE FROM USER
	MOVEM	T3,SYM		;EVAL NEEDS IT HERE
	MOVEM	T3,MATHSM	;SAVE FOR LOOK
	TRZE	TF,DCEVAL	; ? CALL EVAL
	POPJ	P,		;NO DON'T
	PUSHJ	P,EVAL		;'EVAL'UATE THE SYMBOL NAME
	  POPJ	P,		;SYMBOL NOT FOUND
	MOVEM	T,SAVLOC	;SAVE THE VALUE OF THE SYMBOL
	TLNE	F,LABEL		;DID WE HAVE A LABEL?
	JRST	SYM3		;YES - GO PROCESS

	CLEARM	SUBSCR		;ZERO THE OFFSET
	PUSHJ	P,RAYNAM	;DO WE KNOW ABOUT THIS ARRAY
	  CAIA			;NOT DEFINED
	TRO	TF,IMPRNG!ARRAY.;FLAG AS A POSSIBLE RANGE CONDITION
	MOVE	T1,LSTCHR	;GET BACK LAST CHAR SEEN
SYM7:	JUMPE	T1,SYM3		;SEE IF WE HAD A LEGAL DELIMITER
	CAIE	T1,"["		;[ MEANS WE HAVE AN ARRAY DEFINITION TO FOLLOW
	JRST	SYM13		;OBVIOUSLY NOT AN ARRAY DEFINITION
	TLO	F,LFTSQB	;FLAG A [ SEEN - ] MUST END DEFINITION
	PUSHJ	P,DIMIN		;GET NEW DEFINITION
	PUSHJ	P,GETSKB 	;MOVE ON TO NEXT CHARACTER
	JRST	SYM7		;GO BACK TO PROCESS MORE INPUT
	PAGE
SYM13:	CAIE	T1,"("		;THE ONLY OTHER ALLOWED CHARACTER IS (
	JRST	SYM6		;CHECK FOR OTHER DELIMITERS

	TRZ	TF,IMPRNG	;NO LONGER AN IMPLIED RANGE
	SETZM	DIMTOT		;CLEAR FOR TOTAL ELEMENT COUNT
	SETZM	PUTTER		;  AND VARIOUS WORDS IN CASE
 	MOVEI	T,1		;  WE GET AN ARRAY DEFINITION
	MOVEM	T,RP
	PUSHJ	P,RAYNAM	;HAS THIS SYMBOL AN ARRAY REFERENCE?
	TRZA	F,SUBFLG	;CLEAR THE SUBSCRIPT FLAG
	TRO	F,SUBFLG	;YES - REMEMBER TO CHECK ITS SUBSCRIPTS

SYM10:	PUSHJ	P,EITHER	;GET EITHER SYMBOL OR # FROM USER
	  CAIA			;NUMERIC
	MOVE	T,(T)		;SYMBOL - GET VALUE
	TRNE	F,SUBFLG	;DO WE CHECK SUBSCRIPTS FOR THIS ARRAY
	JRST	SYM8		;  PROCESS SUBSCRIPTS

	JUMPL	T,.+2		;AUTO CORRECTION ON -VE #
	SUBI	T,1		;CORRECT FOR A=A(1)

;	NO MORE SUBSCRIPTS - CHECK DELIMITERS

SYM9:	MOVEM	T,SUBSCR	;SAVE THE NEW OFFSET, WATCH ILL MEM REFS
	CAIE	T1,")"		;RIGHT PARENS MUST DELIMIT THE NO.
	JRST	BADSYN		;   THIS WONT DO EITHER!
	TRZE	F,SUBFLG	;ARE WE CHECKING SUBSCRIPTS?
	PUSHJ	P,SUBCHK	;YES - CHECK THERE ARE NO MORE TO FOLLOW
	XCT	GETCHR		;GET NEXT CHARACTER
	PUSHJ	P,GETSK2	;GET NEXT CHARACTER
SYM6:	JUMPE	T1,SYM3		;DELIMITER IS GOOD

	CAIE	T1,","		;WE ALLOW COMMA OR MINUS AT THIS STAGE
	CAIN	T1,"-"		;
	JRST	SYM3		;ACCEPT DELIMITER
	CAIE	T1,"."		;DOT IS ALLOWED FOR .LT. IN IF'S
	CAIN	T1,"="		;= IS ALLOWED FOR ACCEPT (INLINE)
	JRST	SYM3
	CAIE	T1,"]"		;] IS A DELIMITER FOR [A(1)]
	CAIN	T1,")"		;) IS A DELIMITER FOR SUBSCRIPTS
	JRST	SYM3		;
	CAIE	T1,"/"		; / IS A DELIMITER FOR DIMENSIONS
	CAIN	T1,":"		; EQUIV TO "/"
	CAIA
	JRST	BADSYN		;ALL ELSE LOOSES
	TRNE	F,SUBFLG!SURGFL	;IF HANDLING SUBSCRIPTS
	JRST	SYM3		;YES
				;NO - THEN THE / SHOULD MEAN A PRINT MODIFIER
	TRZE	TF,ACCPT	;UNLESS AN ACCEPT IS IN PROGRESS
	JRST	SYM3		;TEST FOR AN IMPLIED RANGE
	MOVS	TMOD,TMOD	;PREPARE TO RECIEVE FLAGS IN RH
	PAGE
	PUSHJ	P,OPTION	;GET THE PRINT MODIFIERS
	  JRST	BADSYN		;NUMERICS ????
	MOVS	TMOD,TMOD	;RESET AS LOCALS,,DEFAULT
	JRST	SYM3		;

;	TIDY UP BEFORE EXIT

SYM3:	MOVE	T,SAVLOC	;GET THE SYMBOL VALUE
	TRZE	F,FORMAL	;WAS THE BASE A FORMAL ARRAY PARAMETER
	SKIPE	T,FRMSAV	;YES - START AT THE FORMAL ADDRESS
	CAIA
	JRST	ERR38		;UNLESS IT'S ZERO
	MOVE	T1,LSTCHR	;RESTORE USERS LAST CHARACTER
	TLZE	F,LABEL		;SKIP IF SYMBOL+SUBSCRIP TO PROCESS
	JRST	CPOPJ1		;STATEMENT EXIT
	ADD	T,SUBSCR	;CORRECT SYMBOL VALUE TO WHAT USER ASKED FOR
;**; [73] Insert @ SYM3 + 8 1/2 source lines, JMT, 12-Apr-77
	TRNN	TMOD,C.!L.!D.	;[73] IS THIS A TWO WORD / ENTRY ARRAY ?
	TRZE	F,DOUBLE	;IS THIS A DOUBLE PRECISION ARRAY
	ADD	T,SUBSCR	;YES - SO GIVE HIM DOUBLE
	JRST	CPOPJ2		;AND LET HIM HAVE IT!


;	HERE TO HANDLE ARRAY SUBSCRIPTS

SYM8:	MOVEM	T,ODF		;SAVE TEMPORARILY
	PUSHJ	P,GETDIM	;GET RANGE OF CURRENT DIMENSION
	MOVE	T,ODF		;PREPARE TO TEST UPPER SUBSCRIPT LIMIT
	SUB	T,TEM1		;IF IN RANGE - SHOULD BE NEGATIVE
	JUMPG	T,ERR23		;IF NOT COMPLAIN - SUBSCRIPT ERROR

	MOVE	T,ODF		;GET USERS SUBSCRIPT VALUE
	SUB	T,TEM		;REMOVE OFFSET
	JUMPL	T,ERR23		; SHOULD BE POSITIVE AFTER REMOVING OFFSET

	IMUL	T,RP		;INCREASE BY CURRENT RANGE PRODUCT
	ADDB	T,DIMTOT	;STORE TOTAL ELEMENT COUNT
	MOVE	T1,LSTCHR	;  AND LAST USER CHARACTER
	CAIE	T1,","		;MORE SUBSCRIPTS?
	JRST	SYM9		;NO - RETURN TO NORMAL PROCESSING

	MOVE	ODF,TEM1	;PREPARE TO UPDATE
	SUB	ODF,TEM		;  RANGE PRODUCT
	AOJ	ODF,		;     WITH NEW RANGE
	IMULM	ODF,RP		;	   LIKE SO
	JRST	SYM10		;LOOK FOR NEW SUBSCRIPT
	PAGE
;	ROUTINE OPTION
;	TO READ THE USERS PRINT MODIFIER SWITCH SETTINGS
;	CALL PUSHJ P,OPTION
;	RETURN1 NUMERIC FOUND = GROUP
;	RETURN2 	TMOD(RH)=PRINT OPTIONS    T1=USERS LAST CHAR.

OPTION:	TRO	TMOD,ANYMOD	;FLAG FIRST TIME THROUGH THIS SCAN
OPTN2:	PUSHJ	P,SIXIN		;ACCEPT SIXBIT
	  POPJ	P,		;NON SKIP RETURN WITH NUMERIC IN T
	  JUMPE	T2,BADSYN	;NO CHARACTERS
	TRZE	TMOD,ANYMOD	;FIRST MODIFIER?
	HLLZ	TMOD,TMOD	;CLEAR FOR NEW MODIFIERS
	LDB	T2,[POINT 6,T2,5] ;GET THE FIRST CHARACTER OF THE SWITCH
	CAIN	T2,'A'		;ASCII?
	TRO	TMOD,A.!ANYMOD	;
	CAIN	T2,'O'		;OCTAL
	TRO	TMOD,O.!ANYMOD	;
	CAIN	T2,'R'		;RASCII
	TRO	TMOD,R.!ANYMOD	;
	CAIN	T2,'S'		;SOURCE LINE TRACE OPTION?
	TRO	TMOD,S.!ANYMOD		;
	TRZ	TMOD,L.		;IGNORE /LONG FOR THE REST
	CAIN	T2,'C'		;COMPLEX?
	TRO	TMOD,C.!ANYMOD	;
	CAIN	T2,'D'		;DOUBLE
	TRO	TMOD,D.!ANYMOD	;
	CAIN	T2,'F'		;FLOATING
	TRO	TMOD,F.!ANYMOD	;
	CAIN	T2,'I'		;INTEGER
	TRO	TMOD,I.!ANYMOD	;
	CAIN	T2,'L'		;'LONG'  ?
	TRO	TMOD,L.!ANYMOD	;'LONG' OPTION
	CAIN	T2,'E'		;TRACE ENTRIES OPTION
	TRO	TMOD,E.!ANYMOD		;
	TRZN	TMOD,ANYMOD	;ANY MODIFIERS SEE - NO MEANS:
	JRST	BADSYN		;NO KNOWN MODIFIER
	JUMPE	T1,OPTN3	;END OF OPTIONS FLAGS IN T
	CAIN	T1,","		;ALSO END OF OPTIONS DELIMITER
	JRST	OPTN3		;SKIP RETURN
	CAIE	T1,"/"		;MORE MODIFIERS ?
	JRST	BADSYN		;NO - NO OTHER MODIFIERS ALLOWED
	PJRST	OPTN2		;GET MORE

OPTN3:	TRNN	TMOD,A.!C.!D.!F.!I.!O.!R.;ANY PRINT MODIFIERS SET UP?
	TRO	TMOD,F.		;NO - SO SET UP FLOATING AS DEFUALT
	JRST	CPOPJ1		;GOOD RETURN
	PAGE
;	SUBROUTINE TO DETERMINE IF WE HAVE AN ACCEPTABLE LABEL
;	ENTER WITH THE ADDRESS OF RAD50 SYMBOL IN W1
;	CALL	PUSHJ P,TRULBL
;	RETURN	NOT GOOD
;	RETURN  ACCEPTABLE LABEL . . I.E. LABEL = ###X  WHERE X .EQ. P OR L
;	TRULST = LAST CHARACTER OF LABEL

TRULBL:	PUSHJ	P,SAV2AC	;SAVE AC S   T,W1
	TRZ	TF,GUDLBL	;CLEAR THE GOOD LABEL FLAG
	MOVE	T,(W1)		;GET THE SYMBOL
	CAIG	T,50		;SINGLE CHARACTER CAN NOT BE A LABEL
	POPJ	P,		;RESTORE T,W1
	TLZ	T,PNAME		;SYMBOL NAME ONLY
	IDIVI	T,50		;GET LAST CHARACTER
	MOVEM	W1,TRULST	;SAVE FOR LATER
TRU3:	JUMPE	T,TRU6		;ALL CHARACTERS SEPERATED IF T=0
	IDIVI	T,50		;GET NEXT CHAR.
	CAIL	W1,1		;IS THIS CHARACTER
	CAILE	W1,12		;     NUMERIC?
	POPJ	P,		; NO - LABEL NOT VALID
	JRST	TRU3		;YES - GET NEXT CHARACTER

TRU6:	TRO	TF,GUDLBL	;FLAG A GOOD LABEL SO FAR
	MOVE	W1,TRULST	;GET BACK LAST CHARACTER
	CAIE	W1,26		;WAS THE LAST CHARACTER AN 'L'
	CAIN	W1,32		;OR A 'P'
	AOS	-3(P)		;EITHER WILL BE ACCEPTABLE - SO SKIP
	POPJ	P,		;IF NEITHER THEN REJECT LABEL
	PAGE
;	SUBROUTINE TO DETERMINE IF THE SYMBOL JUST FOUND IS A TRUE
;	F10 VARIABLE
;	ENTER WITH THE ADDRESS OF RADIX 50 SYMBOL IN W1
;	CALL	PUSHJ	P,TRUVAR
;	RETURN1	NOT A GOOD VARIABLE
;	RETURN2	STANDARD F10 VARIABLE

TRUVAR:	PUSHJ	P,SAV2AC	;SAVE ACS W1,T
	MOVE	T,(R)		;GET THE SYMBOL
	TLZ	T,PNAME		;SYMBOL NAME ONLY
	IDIVI	T,50		;GET THE FIRST CHARACTER
	MOVEM	T+1,TRUFST	;SAVE IT
	JRST	TRUV2

TRUV1:	JUMPE	T,TRUV3		;LOOKED AT ALL CHARACTERS OF SYMBOL?
	IDIVI	T,50		;NO - GET NEXT CHARACTER
TRUV2:	CAIGE	W1,1		;ENSURE WE HAVE ONLY NUMERIC OR
	CAIG	T,44		;     ALPH CHARS
	JRST	TRUV1		;OK SO FAR
	POPJ	P,		;BAD CHARACTER FOR VARIABLE

TRUV3:	CAIL	W1,13		;CHECK THAT THIS FIRST CHARACTER OF
	AOS	-3(P)		;  THE SYMBOL IS ALPHA
	POPJ	P,		;OTHERWISE JUST NON SKIP RETURN
	PAGE
;	ROUTINE TO DISPLAY ASCII TEXT AS '.....'
;	ENTER WITH EACH CHARACTER IN T

ASCOUT:	JUMPE	T,ASCNUL	;HAVE WE A NULL?
	CAIN	T,177		;DELETE IS SPECIAL
	JRST	ASCDEL		;TYPE <DEL>
	CAIL	T,173		;MAYBE AN ESCAPE CHARACTER
	JRST	ASCAPE		;YES
	CAIL	T,40		;LESS THAN 40 = CONTROL CHARACTER
	JRST	ASCUP		;PERHAPS LOWER CASE?
;**;[100] modify @ ascout+7 ma 27-aug-77
	type(^)
	ADDI	T,100		;MAKE ASCII
;**;[100] modify @ ascasc ma 28-aug-77
ASCASC:	putchr	(T)		;[100]TYPE AS ASCII
	POPJ	P,		;DONE
ASCUP:	CAIG	T,140		;LOWER CASE?
	JRST	ASCASC		;JUST GOOD OLD ASCII
;**;[100] modify @ ascup+2 ma 27-aug-77
	type(')
	JRST	ASCASC		;TYPE AS ASCII
;**;[100] modify @ ascnul ma 27-aug-77
ASCNUL:	type(<<NUL>>)
	POPJ	P,
;**;[100] modify @ ascdel ma 27-aug-77
ASCDEL:	type(<<DEL>>)
	POPJ	P,
;**;[100] modify @ ascape ma 27-aug-77
ASCAPE:	openb
	PUSH	P,W1		;SAVE AROUND OCTAL PRINT
	PUSHJ	P,TYP4		;TYPE OCTAL
	POP	P,W1		;RESTORE REMAINDER OF OUTPUT
;**;[100] modify @ ascape+4 ma 27-aug-77
	closeb
	POPJ	P,


;	ROUTINE TO ACCEPT THE MAIN PROGRAM NAME FROM USER
;	SIX CHARACTERS ONLY
;	CALL PUSHJ P,GETPRG
;	RETURN1 NEVER
;	RETURN2 RADIX 50 PROGRAM NAME IN T

GETPRG:	LINE
	TYPE(PROGRAM NAME: )
	PUSHJ	P,TTYIN		;GET THE INPUT
	SKIPN	T2		;?IS THERE A SYMBOL
	JRST	BADSYN		;NO - ERROR
	PUSHJ	P,VALID		;CHECK FOR BEGINNING LETTER AND CONVERT
				;TO RADIX 50
	MOVEM	T3,SYM		;FOR FNDSYM
	TLO	F,FPRNM		;FIND PROGRAM NAME
	PUSHJ	P,FNDSYM
	  JRST	[PUSHJ	P,DISP9		;NOT THERE
		 JRST	GETPRG]		;TRY AGAIN
	HLRZ	T1,(T)		;WHERE IS THE USER ATTEMPTING TO START
	CAIE	T1,(JFCL)	; - ON A JFCL = F10 START
	JRST	ERR10		;YOU CANT START HERE
	JRST	CPOPJ1		;SKIP RETURN
	PAGE
SUBTTL	ERROR ROUTINES

;BAD SYNTAX GIVEN BY USER
;OUTPUTS MESSAGE & REPROMPTS ,ALSO CLEARS TYPE IN BUFFER
;CALL	PJRST BADSYN

BADSYN:	LINE
	TYPE(?FDTIAF ILLEGAL ARGUMENT FORMAT )
	PUSHJ	P,ENDLIN	;TYPE OUT REST OF USER LINE
	LINE
	TYPE(TYPE H FOR HELP)
	LINE
	SKIPE	PRGNAM		;RETURN TO GETPRG IF NO PROGRAM NAME YET
	JRST	RET
	PUSHJ	P,CLRLIN
	JRST	GETPRG


ERR1:	LINE
	TYPE(?FDTMSN MORE SUBSCRIPTS NEEDED)
	JRST	DIM1		;TYPE THE DIMENSIONS FOR ARRAY(SAVLOC)

ERR2:	TYPE(?FDTBOI BAD OCTAL INPUT )
	JRST	ERRR7		;SHOW REST OF BAD LINE

ERR3:	LINE
	TYPE	(?FDTLGU )
	PUSHJ	P,TYPRAY	;TYPE THE OFFENDING ARRAY NAME
	TYPE( LOWER SUBSCRIPT.GE.UPPER)
	JRST	RET

ERR4:	TYPE(%FDTNST NOT 'START'ED)	;'START' INITS FORDDT AND RESETS THE OTS
	JRST	RET

ERR5:	TYPE	(?FDTNFV )
	MOVE	T1,T2		;GET USERS SYMBOL
	PUSHJ	P,OUT6		;DISPLAY
	TYPE	( IS NOT A FORTRAN VARIABLE!)
	LINE
	SKIPE	PRGNAM		;RETURN TO GETPRG IF NO PROGRAM NAME YET
	JRST	RET
	PUSHJ	P,CLRLIN
	JRST	GETPRG

ERR6:	PUSHJ	P,DISP9		;
	JRST	RET

DISP9:	TYPE	(?FDTBDF )
	MOVE	T,SYM		;SET UP FOR RADIX 50 PRINT
	PUSHJ	P,SPT1		;RADIX 50 PRINT
	TRNN	F,MDLCLF	;MULTIPLY DEFINED?
;**;[100] modify @ disp9+4 ma 27-aug-77
	JRST	[type( IS UNDEFINED)
		 JRST	dispx]
	TYPE( IS MULTIPLY DEFINED)
;**;[100] add label @ disp9+6 ma 27-aug-77
dispx:	POPJ	P,

ERR7:	TYPE(?FDTINV INVALID VALUE )
ERRR7:	PUSHJ	P,ENDLIN	;TYPE REST OF USER LINE
	JRST	RET
	PAGE
ERR8:	TYPE(?FDTNFS CANNOT FIND FORTRAN START ADDRESS FOR )
	MOVE	T,SYM
	PUSHJ	P,SPT1
	JRST	BEGIN2		;TRY AGAIN

ERR9:	TYPE(?FDTPRO TOO MANY PAUSE REQUESTS)
	JRST	RET

ERR10:	TYPE(?FDTCSH CANNOT 'START' HERE)
	PUSHJ	P,CLRLIN
	JRST	GETPRG		;TRY ANOTHER PROGRAM NAME

ERR11:	TYPE(?FDTNDT DDT NOT LOADED)
	JRST	RET

ERR12:	TYPE(?FDTCFO CORE FILE OVERFLOW)
	JRST	RET

ERR13:	TYPE(?FDTFCX FORMAT CAPACITY EXCEEDED)
ER13:	TYPE(PLEASE RE-TYPE)
	JRST	RET

ERR14:	TYPE(?FDTICC COMPARE TWO CONSTANTS IS NOT ALLOWED)
	JRST	RET

ERR15:	TYPE(?FDTIGN INVALID GROUP NUMBER)
	JRST	RET

ERR16:	TYPE	(?FDTLNF )
	MOVEI	W1,SYM
	PUSHJ	P,SPT
	TYPE( IS NOT A FORMAT STATEMENT)
	POPJ	P,

ERR17:	TYPE	(?FDTNSP )
	MOVE	T,SYM
	PUSHJ	P,SPT1
	TYPE( NO SUCH PAUSE)
	JRST	RET
ERR18:	TYPE(?FDTCCN CANNOT CONTINUE)
	JRST	RET

ERR19:	TYPE(?FDTNPH CANT INSERT A PAUSE HERE)
	JRST	RET

ERR20:	TYPE(%FDTNSL NO SYMBOLS LOADED)
	POPJ	P,
	PAGE
ERR22:	LINE
	TYPE(?FDTTMS TOO MANY SUBSCRIPTS)
	JRST	DIM1		;TYPE THE DIMENSIONS FOR THE (SAVLOC) ARRAY

ERR23:	LINE			;SUBSCRIPT OUT OF RANGE
	TYPE(?FDTSER SUBSCRIPT ERROR)
	PUSHJ	P,CLRLIN	;ZERO REMAINDER OR USER LINE
	JRST	DIM1		;DISPLAY ARRAY DIMENSIONS

ERR24:	TYPE(?FDTNAL NOT ALLOWED)	;ATTEMP TO MODIFY NON LOCAL VARIABLES
	JRST	RET		;OR START ON A FORMAT STATEMENT

ERR26:	TYPE	(?FDTNUD )
	MOVE	T,SYM
	PUSHJ	P,SPT1
	TYPE( NOT A USER DEFINED ARRAY)
	JRST	RET

ERR27:	LINE
	TYPE	(?FDTSTL )
	PUSHJ	P,TYPRAY	;TYPE THE OFFENDING ARRAY NAME
	TYPE( SIZE TOO LARGE)
	JRST	RET

ERR28:	TYPE(%FDTSFA SUPERSEDES F10 ARRAY)
	JRST	PUTOK		;NOW PLACE THE NEW DEFINITION

ERR30:	TYPE(?FDTNAR NOT AFTER A RE-ENTER)
	JRST	RET

ERR31:	LINE
	TYPE(%FDTXPA ATTEMPT TO EXCEED PROGRAM AREA WITH )
	MOVE	T,SYM		;DISPLAY BASE SYMBOL
	PUSHJ	P,SPT1		;DISPLAY SYMBOL
	AOS	T,SUBSCR	;SHOW USER WHAT SUBSRIPT HE ATTEMPTED TO USE
	TYPE([)
	PUSHJ	P,TFLOT		;TYPE IT
	TYPE(])
	JRST	RET

;**;[100] modify @ err32 ma 27-aug-77
ERR32:	type(?FDTPAR PARENTHESES REQUIRED)
	JRST	ER13

ERR33:	LINE
	TYPE	(?FDTFNR )
	MOVE	T,SYM		;GET THE ARRAY NAME
	PUSHJ	P,SPT1		;TYPE IT
	TYPE( IS A FORMAL AND MAY NOT BE RE-DEFINED)
	PUSHJ	P,FLUSHA	;FLUSH THE LOT
	JRST	RET
	PAGE
ERR34:	TYPE	(%FDTNAR )
	MOVEI	W1,SYM
	PUSHJ	P,SPT		;TYPE SYMBOL
	TYPE	( IS NOT AN ARRAY)
	JRST	RET

ERR35:	TYPE	(%FDTSPO VARIABLE IS SINGLE PRECISION ONLY)
	JRST	RET

ERR36:	TYPE	(?FDTNGF CANNOT GOTO A FORMAT STATEMENT)
	JRST	RET

ERR37:	LINE
	TYPE	(?FDTITM ILLEGAL TYPE MODIFIER - S)
	JRST	RET

ERR38:	TYPE	(?FDTFNI FORMAL NOT INITIALIZED)
	JRST	RET

ERR39:	LINE
	TYPE	(?FDTRGR RECURSIVE GROUP REFERENCE)
	JRST	RET

ERR40:	LINE
	TYPE	(?FDTIRS ILLEGAL RANGE SPECIFICATION)
	JRST	RET

; [71] Add new error message @ERR40+2 1/2 lines, JMT, 6-Dec-76
ERR41:	LINE			;[71]
	TYPE	(?FDTMCD Compile program with the DEBUG switch to type a format statement)
	JRST	RET		;[71]
	PAGE
;  THIS PAGE HOLDS ERROR MESSAGES FOR INTERNAL ERRORS OF FORDDT.  KEEP
;SIMILAR MESSAGES ON THIS PAGE SO THAT THEY ARE EASY TO LOCATE.





E1:	TYPE	(?FDTIER E1)
	JRST	WT5


E2:	TYPE	(?FDTIER E2)
	JRST	BREAK4


;*E3:	TYPE	(?FDTIER E3)


;*E4:	TYPE	(?FDTIER E4)


E5:	TYPE	(?FDTIER E5)
	JRST	DMFLSH		;REMOVE RECENT ADDITIONS TO DIMTAB


E6:	TYPE	(?FDTIER E6)
	JRST	RE.L3


E7:	TAB
	TYPE	(?FDTIER E7)
	JRST	STEP6


E8:	LINE
	TYPE	(?FDTIER E8)
	JRST	RET


E9:	TYPE	(?FDTIER E9)
	JRST	RET
	PAGE
;COMMAND ERRORS

;**;[100] modify @ error ma 27-aug-77
ERROR:	type(?FDTURC UNRECOGNIZED COMMAND )
	MOVE	T1,T2		;PREPARE TO TYPE USER COMMAND
	PUSHJ	P,OUT6		;TYPE IT
;**;[100] modify @ error+3 ma 27-aug-77
	line			;TIDY
	JRST	RET		;RESTORE ACS AND RETURN TO MAIN LOOP
;**;[100] modify @ notunq ma 27-aug-77
NOTUNQ:	type(?FDTCNU THE COMMAND )
	MOVE	T1,T2		;PREPARE TO TYPE USER COMMAND
	PUSHJ	P,OUT6		;TYPE IT
;**;[100] modify @ notunq+3 ma 27-aug-77
	type( IS NOT UNIQUE)
	line			;TIDY UP
	JRST	RET		;RESTORE ACS & RETURN TO MAIN LOOP
	PAGE
SUBTTL	PROMPT MESSAGES

CRLF:	ASCIZ /
/

HLPTXT:	ASCIZ \
COMMANDS:
ACCEPT,CONTINUE,DDT,DIMENSION,DOUBLE,GOTO,GROUP,HELP,LOCATE,
MODE,NEXT,OPEN,PAUSE,REMOVE,START,STOP,STRACE,TYPE,WHAT
(SEE ALSO FORDDT.HLP; APPENDIX F, FORTRAN REFERENCE MANUAL.)
\
	PAGE
SUBTTL VARIABLE STORAGE

STKYFL:	TRLINE			;STICKY FLAGS REMAIN SET WHEN F IS CLEARED
FRMSAV:	BLOCK	1		;REFFERS TO THE FORMAL ARRAY BASE
RANGE:	BLOCK	1		;INDICATES RANGE OF VALUES A(1)-A(?)
SYMSAV:	BLOCK	1		;SAVE EVAL POINTER TO LAST SYMBOL
SYL:	BLOCK	1
LWT:	BLOCK	1
DEN:	BLOCK	1
DIMCNT:	BLOCK	1		;COUNT OF THE # OF DIMENSIONS FOR F10 ARRAY
SAVHSM:	BLOCK	1		;C(.JBHSM), USED BY EVAL, LOOK
ESCAPE:	-1			;NON ZERO MEANS NO ^C IN EFFECT SO ESCAPE ALLOWED
JOBSA:	BLOCK	1		;THESE THREE LOCATIONS ARE USED TO PRESERVE
JOBSYM:	BLOCK	1		;    THE INITIAL STATE OF THE PROGRAM - SO THAT
				;	OVERLAYS CAN BE DETECTED
JOBNAM:	BLOCK	1		;SIXBIT NAME OF PROGRAM OR OVERLAY
MODFLG:	F.			;HOLDS THE CURRENT TYPE OPTION FLAGS
JOBBRK:	BLOCK	1		;STORES THE CURRENT EXECUTION POINTER
PRGM:	BLOCK	1
SAVCHR:	BLOCK	1		;TEMP SAVE OF CHARACTER
TRUFST:	BLOCK	1		;SAVE FIRST CHARACTER OF A SYMBOL
LOKFST:	BLOCK	1		;DITTO EXCEPT USED BY LOOK
TRULST:	BLOCK	1		;SAVE LAST CHARACTER OF A SYMBOL
MATHSM:	BLOCK	1	;USED BY "LOOK" TO RESOLVE MULTIPLE DEF
SYM:	BLOCK	1
SYMASK:	BLOCK	1		;MASK FOR SYM TBL SYMBOL (FOR FNDSYM, WITH FGLSNM)
BESTVA:	BLOCK	1		;BEST VALUE FOUND FOR LOKSYM
LASYM:	BLOCK	1		;LAST SYMBOL FOUND BY LOKSYM
LASVAL:	BLOCK	1		;LAST VALUE CALLED TO LOKSYM
OJBSYM:	BLOCK	1		;'OUR JBSYM' USED FOR SYM TABLE ROUTINES
SAVT3:	BLOCK	1		;TEMPORARY SAVE OF T3
PRGNAM:	BLOCK	2		;SET TO NAME  OF CURRENT MAIN PROGRAM
				;CAIA APPEARS HERE
HELLO:	PUSH	17,0		;IDENTIFIES HELLO MACRO USEAGES
BASRAY:	BLOCK	1		;ARRAY BASE NAME(VALUE)
SAVLOC:	BLOCK	1		;GENERAL SAVE LOCATION
QLPNT:	BLOCK	1		;USED IN "QLIST" AS POINTER TO A SYMBOL
STPCNT:	BLOCK	1		;STEP COUNT - HOW MANY LINES TO TRACE
OPENED:	SQUOZE	0,MAIN.		;HOLDS CURRENTLEY OPENED PROGRAM NAME
OPENLS:	BLOCK	1		;HOLDS SUB-SET OF JBSYM FOR OPENED PROGRAM
OLDOPN:	BLOCK	1		;PROG THAT WAS OPEN BEFORE GROUP REQUEST
GOLOC:	BLOCK	1		;HOLDS E.T.V. TO EXTERNAL ROUTINES
SUBSCR:	BLOCK	1		;HOLDS ARRAY SUBSCRIPT VALUE
COUNT:	BLOCK	1
JOBOPC:	BLOCK	1		;HOLDS .JBOPC IF WE ARE IN A RE-ENTER
PNAMSV:	BLOCK	1		;STORES NAME OF SECTION OF NEAREST MATCH TO SYMBOL
RANLIM:	BLOCK	1		;HOLDS CURRENT PROGRESS IN A RANGE CONDITION
TABCNT:	BLOCK	1		;COUNTS THE # OF LABELS/LINE IN TRACE
COMAND:	BLOCK	1		;HOLDS USER COMMAND SIXBIT
PUTTER:	BLOCK	1		;STORES END OF CURRENT DIMENSION LIST
DIMTOT:	BLOCK	1		;STORES TOTAL ELEMENT COUNT
RP:	BLOCK	1		;HOLDS RANGE PRODUCT FOR ARRAY ELEMENT CALCULATION
;**;[063],RP+1,ADD LOCATION IN VARIABLE STORAGE
SECSAV:	BLOCK	1		;[063] HOLDS SECTION NAME
	PAGE
FSV:	BLOCK	1
FH:	BLOCK	1
SAVPI:	BLOCK	1
B1ADR:	BLOCK	1
B1SKP:	BLOCK	1
B1CNT:	BLOCK	1
	BLOCK	NBP*3-3

BNADR=.-3
AUTOPI:	BLOCK	1

AC0:	BLOCK	17
AC17:	BLOCK	1
SARS:	BLOCK	1
TEM:	BLOCK	1
TEM1:	BLOCK	1
TEM2:	BLOCK	1
TEM3:	BLOCK	1		;TEMP STORAGE
TEM4:	BLOCK	1		;TEMP STORAGE
TEM5:	BLOCK	1		;TEMP STORAGE
TEM6:	BLOCK	1		;TEMP STORAGE
TEM7:	BLOCK	1		;TEMP STORAGE
; [72] Insert @TEM7+1/2, JMT, 13-Jan-77
TEM8:	BLOCK	1		;[72] TEMP STORAGE FOR VALUE IN LOKSYM

STPVAL:	BLOCK	1		;HOLDS THE DEFAULT TRACE COUNT
PDL:	BLOCK	PDSIZ+1		;PUSH DOWN LIST
TERMK:	BLOCK	1		;FLAG FOR LINE TERMINATOR
				;-1=SP 0=^Z 1=LF 2=ALTMODE
;**;[76] insert @termk+1  ma 22-aug-77
DELCHR:	0			;[76]SAVED DELIMITER FOR ASCII ACCEPT AND CLRLIN
;**;[100] add native code @ delchr+1 ma 25-aug-77
ifn tops20,<
pagwrn:	-1			;[100]flag for page warning message in dep4
percsb:	kparse			;[100]command state block (permanent)
	.priin,,.priou
	point 7,[byte(7)76,76,0]
	point 7,parbuf
	point 7,parbuf
	^d80
	^d80
	point 7,paratm
	^d80
	0
temcsb:	block 12			;[100]command state block (temporary)
parbuf:	block 20			;[100]parsing buffer
paratm:	block 20			;[100]atom buffer
funini:	<.cmini>b8			;[100]init block for parse
	0
	0
	0
funkey:	<.cmkey>b8			;[100]keyword block for parse
	keytab
	0
	0
fungar:	<.cmtxt>b8!cm%hpp!cm%sdh	;[100]rest of line block for parse
	0
	point 7,[asciz/command arguments/]
	0
keytab:	23,,23				;[100]keyword table
	[asciz/ACCEPT/],,0
	[asciz/CONTINUE/],,0
	[asciz/DDT/],,0
	[asciz/DIMENSION/],,0
	[asciz/DOUBLE/],,0
	[asciz/GOTO/],,0
	[asciz/GROUP/],,0
	[asciz/HELP/],,0
	[asciz/LOCATE/],,0
	[asciz/MODE/],,0
	[asciz/NEXT/],,0
	[asciz/OPEN/],,0
	[asciz/PAUSE/],,0
	[asciz/REMOVE/],,0
	[asciz/START/],,0
	[asciz/STOP/],,0
	[asciz/STRACE/],,0
	[asciz/TYPE/],,0
	[asciz/WHAT/],,0
>				;[100]end of conditional





;hack!! by ma, must be removed!!!
	;XLIST			;LITERALS
	LIT
	LIST


IFN	DEBUG	<
PATCH:	BLOCK	50		;PATCHING SPACE
		>

IFE	DEBUG	<XPUNGE>		;DELETE SYMBOLS



DDTEND:	END	FORDDT
  	|K,