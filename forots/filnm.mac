	TITLE	FILNM. -  PROCESS FILE-NAME SPECIFICATION
	SEARCH	FORPRM
	ENTRY	FILNM.
;
;  CALLING SEQUENCE-
;	P2, P3 SET STANDARDLY  (SEE FORPRM FOR DETAILS)
;	IF NOT IN DIALOG MODE,
;	  G1 = ADDRESS OF SOURCE CHARACTERS
;	PUSHJ	P,FILNM.
;     WHERE REGISTER NAMES ARE DEFINED AS IN FORPRM.
;
;  DOES-
;	SETS T0 = DELIMITER FLAGS (AS IN SCNSWT) FOR USE UPON RETURN [T34]
;	SETS T1 = PPN FOR FILE NAME  (0 FOR CURRENT DIRECTORY).
;	SETS T2 = LEFT-JUSTIFIED ZERO-FILLED SIXBIT DEVICE NAME.
;	SETS T3 = LEFT-JUSTIFIED ZERO-FILLED SIXBIT FILE NAME.
;	SETS T4 = LEFT-JUSTIFIED ZERO=FILLED SIXBIT EXTENSION.
;	LEAVES ALL REGISTERS SET STANDARDLY.
;	 DETAILS.
;
; THE SPECIFICATION OF FILE-NAMES IN THE OPEN STATEMENT FOR
; FORTRAN-10 IS EXPANDED TO INCLUDE USER-NAMES AND DEVICES
; IN A FORMAT MEANT TO BE COMPATIBLE WITH F-IV.
;
; SYNTAX:
;
; <BLANKS>["("<BLANKS><USER-NAME><BLANKS>")"<BLANKS>]
;   [<DEVICE>":"<BLANKS>]
;   [<FILE-NAME>["."[<EXTENSION>]]]
; <BLANKS> ::= ZERO OR MORE BLANK CHARACTERS
; <USER-NAME> ::= ONE OR MORE (LETTERS OR DIGITS)
;   (CHARACTERS AFTER THE 12TH ARE IGNORED WITHOUT A DIAGNOSTIC)
; <DEVICE> ::= ONE OR MORE (LETTERS OR DIGITS)
;   (CHARACTERS AFTER THE 3RD ARE IGNORED WITHOUT A DIAGNOSTIC)
; <FILE-NAME> ::= ONE OR MORE (LETTERS OR DIGITS)
;   (CHARACTERS AFTER THE 6TH ARE IGNORED WITHOUT A DIAGNOSTIC)
; <EXTENSION> ::= ONE OR MORE (LETTERS OR DIGITS)
;   (CHARACTERS AFTER THE 3RD ARE IGNORED WITHOUT A DIAGNOSTIC)
;
; 1. <DEVICE> AND/OR <FILE-NAME> MUST BE SPECIFIED.
;
; 2. STRING LENGTH IS:
;	LITERAL => INFINITE
;	ARRAY => ARRAY SIZE IN CHARACTERS
;	COMPLEX/DOUBLE PRECISION VARIABLE/ARRAY-ELEMENT => 10
;	INTEGER/REAL/LOGICAL VARIABLE/ARRAY-ELEMENT => 5
;
; 3. THE STRING IS TERMINATED WHEN
;      A) THE STRING LENGTH IS EXCEEDED, OR
;      B) A NUL CHARACTER (I.E. 0) IS ENCOUNTERED, OR
;      C) A BLANK CHARACTER IS FOUND AFTER THE <FILE-NAME>,
;    WHICHEVER COMES FIRST.
;
; 4. CONTROL CHARACTERS (I.E. 01 THROUGH 37) ARE IGNORED, EXCEPT
;    IN COUNTING THE STRING LENGTH.
;
; 5. A BLANK CHARACTER IN THE MIDDLE OF THE <USER-NAME> WILL
;    TERMINATE THE <USER-NAME> (BUT NOT THE STRING), AND CAUSE
;    THE REMAINING CHARACTERS UNTIL THE ")" TO BE SKIPPED.
;
; SEMANTICS:
;
; 1. IF <DEVICE> IS "DSK" BUT <FILE-NAME> IS NOT SPECIFIED,
;    <FILE-NAME> WILL BE ASSUMED TO BE "DSK" WITHOUT
;    AN EXTENSION.
;
; 2. IF "." IS NOT SPECIFIED AND FOROTS VARIABLE DEBFNM HAS BEEN
;    SET NON-ZERO (VIA DDT), FORTRAN WILL TYPE:
;    'UNIT <N>, FILE "<FILE-NAME>" OPENED AS "<FILE-NAME>."
;				   INSTEAD OF "<FILE-NAME>.DAT"'
;
; INCOMPATIBILITIES:
;
; 1. EXISTING FORTRAN-10 PROGRAMS OMITTING "." AND <EXTENSION>
;    SO AS TO GET AN EXTENSION OF "DAT" WILL NOT GET ANY
;    EXTENSION OR WARNING.  THEY CAN GET A WARNING BY SETTING
;    THE VALUE OF FOROTS VARIABLE DEBFNM NON-ZERO (VIA DDT).
;
; 2. SPACES IMMEDIATELY BEFORE AND IN THE MIDDLE OF <USER-NAME>
;    WILL NO LONGER BE DIAGNOSED.
;

;EDIT HISTORY:
;T33	-----	ALLOW SPACES BETWEEN (USERNAME) AND DEVICE: OR FILE NAME.
;
;T34	-----	RETURN THE DELIMITER FLAGS FROM FNMSCN IN T0 SO THAT
;		THE CALLER CAN FIGURE OUT TO GO ON.
;
;T35	55825	SEARCH FOR ARRAY SPECIFIERS IN LOWER MEMORY TOO.  FIXES
;		BUG WITH LINK.

	EXTERN	DEBFN.		;NON-ZERO MEANS TYPE DEBUG MSG
				;FOR FILE-NAME WITHOUT EXTENSION
	EXTERN	IBYTE.		;GET BYTE FROM DIALOGUE
	EXTERN	NXTLN.		;START NEXT DIALOGUE LINE
	EXTERN	TY%DDB		;TYPE DESCRIPTION OF FILE SPEC
	EXTERN	USRNM.		;CONVERT USER-NAME TO PPN
 
; PROCESS ["("<USER-NAME>")"]
FILNM.:	PUSH	P,T2		;[T34] IN THE STRANGE CASE OF DELIMITER FOUND 
				;[T34] BEFORE ENTERING, DON'T CLOBBER IT
	PUSHJ	P,SETBP		;SET G4 = SOURCE LENGTH, AND
				; G1 = BYTE PTR (IF NOT DIALOG)
	POP	P,T2		;[T34] GET BACK THE DELIMITER MASK
	TLNN	P2,OP.OPN!OP.DIA;[T34] IF NOT DIALOG
	 MOVEI	 T2,0		;[T34] THERE CAN'T BE AN INCOMING DELIMITER
	MOVEI	T1,0		;ASSUME NO USER-NAME
	PUSH	P,T1
	TLZE	T2,(1B'(')	;[T34] WAS THE INCOMING DELIMITER "(" ?
	 JRST	 FILNM0		;[T34] YES, GO ON
	MOVEI	T4,1		;SKIP BLANKS IN SCAN
	PUSHJ	P,FNMSCN	;SET T1, T2, T3 FOR STR, DELIM
	JUMPN	T1,FILNM2	;IF LETTERS/DIGITS BEFORE DELIM
	TLNN	T2,(1B'(')	;IF DELIMITER IS NOT "(",
	  JRST	  FILNM6	;  TELL USER HE BLEW IT
FILNM0:	MOVEI	T4,0		;[T34] SET T2=0 ON BLANK IN SCAN
	PUSHJ	P,FNMSCN	;GET USER-NAME
	JUMPE	T2,[PUSH P,T1		;SAVE USERNAME
		PUSH	P,T3		;SAVE CHRS 7-12
		MOVEI	T4,0		;SET T2=0 ON BLANK
		PUSHJ	P,FNMSCN	;GET CHRS + DELIM
		JUMPE	T2,.-2		;IF DELIM=BLANK, LOOP
		POP	P,T3		;RESTORE CHRS 7-12
		POP	P,T1		;RESTORE CHRS 1-6
		JRST	FILNM1]		;RESUME WITH USER-NAME
FILNM1:	TLNN	T2,(1B')')	;IF DELIMITER IS NOT ")",
	  JRST	  FILNM6	;  TELL USER HE BLEW IT
	POP	P,T2		;GET RID OF 0 (FOR NO USER-NAME)
	PUSHJ	P,USRNM.	;SET T1 = PPN FOR USER-NAME
	PUSH	P,T3		;SAVE PPN OF USER-NAME
	MOVEI	T4,1		;[T33] SKIP OVER BLANKS
	PUSHJ	P,FNMSCN	;GET FILE-NAME OR DEVICE
	JUMPE	T1,FILNM6	;IF ")" WAS IMMEDIATELY
				; FOLLOWED BY A DELIMITER
 
;  PROCESS [<DEVICE>":"]
FILNM2:	TRNE	T2,1B':'	;IF DELIMITER IS ":",
	  JRST [PUSH	P,T1		;SAVE DEVICE NAME
		MOVEI	T4,1		;SKIP BLANKS IN SCAN
		PUSHJ	P,FNMSCN	;TRY FOR <FILE-NAME>
		JRST	FILNM3]		;ALLOW NULL <FILE-NAME>
	MOVSI	T4,'DSK'	;DEFAULT DEVICE NAME = 'DSK'
	PUSH	P,T4		;SAVE DEVICE NAME
				;REQUIRE <FILE-NAME>
 
; HERE WITHOUT <DEVICE>; MUST HAVE <FILE-NAME>
	JUMPE	T1,[POP	P,T1	;IF OMITTED, POP USELESS FILE-NM
		JRST	FILNM6]	;  AND GO ISSUE ERROR
;  PROCESS [<FILE-NAME>]
FILNM3:	JUMPN	T1,FILNM4	;IF <FILE-NAME> WAS SPECIFIED
	MOVSI	T1,'DSK'	;<FILE-NAME> BECOMES 'DSK'
	PUSH	P,T1		;SAVE THE <FILE-NAME>
	MOVEI	T1,0		;NO EXTENSION
	PUSH	P,T1		;SAVE THE EXTENSION
	JRST	FILNM5		;GO VERIFY CORRECT TERMINATION
 
FILNM4:	PUSH	P,T1		;SAVE THE <FILE-NAME>
 
; PROCESS ["."[<EXTENSION>]]
	TLZE	T2,(1B'.')	;IF AN EXTENSION FOLLOWS
	  JRST [SETO	T4,-1		;TERMINATE ON BLANK
		PUSHJ	P,FNMSCN	;SET T1 = <EXT> OR ZERO
		PUSH	P,T1		;SAVE <EXT> OR ZERO
		JRST	FILNM5]		;GO VERIFY TERMINATION
 
	MOVEI	T1,0		;ASSUME NO EXTENSION
	PUSH	P,T1
; <FILE-NAME> WITHOUT <EXTENSION>, TYPE:
;    'UNIT <N>, FILE "<FILE-NAME>" OPENED AS "<FILE-NAME>." INST
;				       EAD OF "<FILE-NAME>.DAT"'
	MOVE	T1,DEBFN.	;EXAMINE DEBUG FLAG
	JUMPE	T1,FILNM5	;IF ZERO, DO NOT TYPE MESSAGE
	OUTSTR	[ASCIZ /
UNIT /]
	PUSHJ	P,TYPUN		;TYPE <UNIT-NUMBER>
	OUTSTR	[ASCIZ /, FILE "/]
	PUSHJ	P,TYPFN		;TYPE <FILE-NAME>
	OUTSTR	[ASCIZ /" OPENED AS "/]
	PUSHJ	P,TYPFN		;TYPE <FILE-NAME>
	OUTSTR	[ASCIZ /." INSTEAD OF "/]
	PUSHJ	P,TYPFN		;TYPE <FILE-NAME>
	OUTSTR	[ASCIZ /.DAT"
/]
	MOVEI	T1,0		;DEFAULT EXTENSION IS NULL
	HRRZS	,DD.EXT(P2)	;ZERO OUT THE EXTENSION (LEFT)
; VERIFY CORRECT TERMINATION
FILNM5:	POP	P,T4		;T4 = EXTENSION
	POP	P,T3		;T3 = FILE NAME
	MOVE	T0,T2		;[T34] T0 = DELIMITER WORD
	POP	P,T2		;T2 = DEVICE
	POP	P,T1		;T1 = PPN
	POPJ	P,		;[T34] NO MATTER HOW IT IS TERMINATED
				;RETURN TO THE CALLER
 
; HANDLE AN ERROR
FILNM6:	POP	P,T1		;GET RID OF USELESS PPN
	TLZE	P2,40000	;[416] IF ALREADY IN DIALOG MODE
	  POPJ	  P,		;[416]   GO ASK AGAIN
	SETZB	T1,T1		;[416] SET ILLEGAL DELIMITER
	SETZB	G3,G3		;[416] SET SWITCH ERROR FOUND
	TLO	P2,OP.ERR	;[416] SET ERROR FOUND FLAG(ARG)
	ERROR	(OPN,11,7,.+1)	;[416] TELL ABOUT OPEN ARG ERROR
	EXCH	P2,P3		;[416] SET UP TO TYPE THE DDB
	PUSHJ	P,TY%DDB	;[416] SHOW WHAT WE GOT SO FAR
	EXCH	P3,P2		;[416] RESTORE THE I/O REGS
	POPJ	P,		;[416] RETURN TAKES US TO DIALOG
 
; TYPE <FILE-NAME>
TYPFN:	MOVE	T1,DD.NAM(P2)	;<FILE-NAME> IN SIXBIT
TYPFN1:	ROT	T1,6		;RIGHT-JUSTIFY NEXT CHARACTER
	MOVE	T4,T1		;PUT IT IN A SCRATCH REGISTER
	ANDI	T4,77		;KEEP ONLY THE RIGHT SIXBIT CHAR
	XOR	T1,T4		;ZERO OUT CHAR FROM <FILE-NAME>
	ADDI	T4,40		;CONVERT SIXBIT TO ASCII
	OUTCHR	T4		;TYPE THE CHARACTER
	JUMPN	T1,TYPFN1	;IF <FILE-NAME> NOT DONE, LOOP
	POPJ	P,		;EXIT TO CALLER
 
; TYPE <UNIT-NUMBER>   (DECIMAL BETWEEN 1 & 63, INCLUSIVE)
TYPUN:	HRRZ	T1,DD.UNT(P2)	;BINARY <UNIT-NUMBER>
	JUMPE	T1,TYPUN2	;IF 0, GO HANDLE ERROR
	CAILE	T1,^D63		;IF LARGER THAN 63,
	  JRST	  TYPUN2	;  GO HANDLE ERROR
	MOVE	T4,T1
	IDIVI	T4,^D10		;BINARY VALUE OF TEN'S DIGIT
	JUMPE	T4,TYPUN1	;IF ZERO, OMIT TEN'S DIGIT
	ADDI	T4,"0"		;CONVERT TO ASCII
	OUTCHR	T4		;TYPE THE TEN'S DIGIT
	SUBI	T4,"0"		;BINARY VALUE OF TEN'S DIGIT
	IMULI	T4,^D10		;T1/10*10
	SUB	T1,T4		;T1 - T1/10*10
TYPUN1:	ADDI	T1,"0"		;CONVERT TO ASCII
	OUTCHR	T1		;TYPE THE ONE'S DIGIT
	POPJ	P,		;EXIT TO CALLER
 
TYPUN2:	OUTSTR	[ASCIZ /<ILLEGAL>/]
	POPJ	P,		;EXIT TO CALLER
 
; SET G4 = LENGTH OF SOURCE, AND G1 = BYTE POINTER IF NOT DIALOG
;   GIVEN: P2 SET STANDARDLY, T5 = ARG TYPE, L = PTR TO ARG
SETBP:	JUMPL	P2,SETBP4	;IF DIALOG MODE, JUMP
	TLNN	G1,777777	;IF G1 IS NOT ALREADY BYTE PTR,
	  HRLI	  G1,(POINT 7)	;  MAKE IT A BYTE POINTER
	HRRZ	T1,.JBHRL	;HIGHEST HIGH-SEGMENT ADDRESS
	JUMPE	T1,SETBP5	;IF NO HIGH SEGMENT, SEARCH LOW-SEG
	TRZ	T1,400000	;DELETE THE HIGH-SEGMENT BIT
	SUBI	T1,2		;ENSURE INDEXED WITHIN MEMORY
; SEARCH FOR 9/0, 4/TYPE, 1/I, 4/0, 18/SOURCE-ADDRESS
;	     18/254237, 18/ANY
	MOVE	T2,(L)		;9/ANY, 4/TYPE, 1/I, 4/0, 18/ADR
	TLZ	T2,777000	;9/0,   4/TYPE, 1/I, 4/0, 18/ADR
SETBP1:	CAME	T2,400000(T1)	;IF CANDIDATE DOES NOT MATCH,
SETBP2:	  SOJN	  T1,SETBP1	;  DECREMENT INDEX AND LOOP
	JUMPLE	T1,SETBP5	;[T35] IF NOT FOUND AT ALL, JUMP
	HLRZ	T3,400001(T1)	;LOOK AT LEFT HALF OF 2ND WORD
	CAIE	T3,254237	;IF LEFT HALF DOES NOT MATCH,
	  JRST	  SETBP2	;  MATCH FAILS
; FOUND IT!  WE NOW HAVE:
;   400000(T1) = 9/0, 4/TYPE, 1/I, 4/0, 18/ADDRESS
;   400001(T1) = 18/254237, 18/ARRAY SIZE IN WORDS
	HRRZ	G4,400001(T1)	;SIZE IN WORDS
	IMULI	G4,5		;CONVERT WORDS TO CHARACTERS
	ADDI	G4,1		;PLUS 1 FOR NULL
	POPJ	P,		;EXIT TO CALLER
 
; ARG IS NOT AN ARRAY
SETBP3:	MOVEI	G4,^D6		;GUESS LENGTH = 5 CHARS + NULL
	CAIE	T5,TP%DOR	;IF DOUBLE PRECISION, SKIP
	 CAIN	 T5,TP%COM	; IF NOT COMPLEX, SKIP
	  MOVEI	  G4,^D11	;  LENGTH = 10 CHARS + NULL
	CAIN	T5,TP%LIT	;IF LITERAL,
SETBP4:	  SETO	  G4,		;  ALLOW INFINITE STRING
				;  (BOTH LITERAL AND DIALOG)
	POPJ	P,		;EXIT TO CALLER

; OVERLAY JOB (NO HIGH SEGMENT) SO SEARCH LOW SEGMENT
SETBP5:	MOVE	T1,.JBREL	;HIGHEST LOW-SEGMENT ADDRESS
	SUBI	T1,2		;ENSURE INDEXED WITHIN MEMORY
; SEARCH FOR 9/0, 4/TYPE, 1/I, 4/0, 18/SOURCE-ADDRESS
;	     18/254237, 18/ANY
	MOVE	T2,(L)		;9/ANY, 4/TYPE, 1/I, 4/0, 18/ADR
	TLZ	T2,777000	;9/0,   4/TYPE, 1/I, 4/0, 18/ADR
SETBP6:	CAME	T2,0(T1)	;IF CANDIDATE DOES NOT MATCH,
SETBP7:	  SOJN	  T1,SETBP6	;  DECREMENT INDEX AND LOOP
	JUMPLE	T1,SETBP3	;IF NOT FOUND AT ALL, JUMP
	HLRZ	T3,1(T1)	;LOOK AT LEFT HALF OF 2ND WORD
	CAIE	T3,254237	;IF LEFT HALF DOES NOT MATCH,
	  JRST	  SETBP7	;  MATCH FAILS
; FOUND IT!  WE NOW HAVE:
;   0(T1) = 9/0, 4/TYPE, 1/I, 4/0, 18/ADDRESS
;   1(T1) = 18/254237, 18/ARRAY SIZE IN WORDS
	HRRZ	G4,1(T1)	;SIZE IN WORDS
	IMULI	G4,5		;CONVERT WORDS TO CHARACTERS
	ADDI	G4,1		;PLUS 1 FOR NULL
	POPJ	P,		;EXIT TO CALLER
 
; RETURN T1, T2, T3 AS IN SCNSIX
; IF T4 IS 1, BLANKS ARE SKIPPED.
; IF T4 IS 0, BLANKS ARE DELIMITERS, SETTING T2=0.
; IF T4 IS -1, BLANKS TERMINATE THE STRING, SETTING T2<0.
; G4 AND G1 MUST BE SET (IF NOT DIALOG) BY SCNN12.
FNMSCN:	MOVE	T2,[POINT 6,T1]	;SET SIXBIT BYTE PTR FOR RESULT
	SETZ	T1,		;CLEAR THE OUTPUT WORD
	SETZ	T3,		;CLEAR THE SECOND OUTPUT WORD
FNMSC1:	SETZ	T0,		;SET ASCII NUL IN CASE JUMP
	SOJE	G4,FNMSC3	;DECR NLEFT; IF END, JUMP
	JUMPGE	P2,FNMSC2	;IF NOT DIALOG, JUMP
FNMSC9:	PUSH	P,T3		;PRESERVE SECOND OUTPUT WORD
	PUSH	P,T4		;PRESERVE BLANK FLAG
	TLNE	P3,IO.EOL	;IF AT END OF LINE,
	  PUSHJ	  P,NXTLN.	;  GET THE NEXT INPUT LINE
	JSP	P1,IBYTE.	;GET AN INPUT CHARACTER
	POP	P,T4		;RESTORE BLANK FLAG
	POP	P,T3		;RESTORE SECOND OUTPUT WORD
	TLNE	P3,IO.EOF	;[T34] IF EOF EVER GETS HERE
	 JRST	 FNMSC0		;[T34] TREAT AS AN ALTMODE
	TLNE	P3,IO.EOL	;[T34] IF END OF LINE
	 JRST	 FNMSC9		;[T34] GET ANOTHER ONE
	CAIN	T0,4		;[T34] IF WE SEE A CTRL-D
	 JRST	 FNMSC0		;[T34] TREAT IT AS AN ALTMODE
	CAIE	T0,176		;IF ALTMODE OF 176
	 CAIN	 T0,175		; OR ALTMODE OF 175,
	  MOVEI	  T0,33		;  REPLACE WITH STANDARD ALTMODE
	CAIE	T0,33		;IF THIS IS NOT AN ALTMODE,
	  JRST	  FNMSC3	;  SKIP POSSIBLE CARRIAGE RETURN
FNMSC0:	TLNE	P3,IO.TTY!IO.TTA  ;[T34] IF TTY TYPE DEVICE,
	  OUTSTR  [ASCIZ /
/]				  ;  TYPE CR-LF
FNMSC2:	SETZ	T0,		;CLEAR OUT THE CHARACTER
	ILDB	T0,G1		;LOAD ASCII CHARACTER
FNMSC3:	JUMPE	T0,FNMSC6	;IF NULL, TERMINATE
	TRC	T0,140		;INVERT CONTROL AND SHIFT BITS
	TRNN	T0,140		;IF LOWER CASE ALPHA CHARACTER,
	  IORI	  T0,40		;  SET TO UPPER CASE
	ANDCMI	T0,100		;CLEAR HIGH BIT & SET TO SIXBIT
	CAIL	T0,'0'		;IF LESS THAN '0'
	 CAILE	 T0,'Z'		; OR GREATER THAN 'Z'
	  JRST	  FNMSC4	;  MUST BE DELIMITER
	CAIGE	T0,'A'		;IF AT LEAST 'A'
	 CAIG	 T0,'9'		; OR AT MOST '9'
	  JRST	  FNMSC7	;  MUST BE LETTER OR DIGIT
FNMSC4:	JUMPN	T0,FNMSC5	;IF NOT BLANK, JUMP
	JUMPG	T4,FNMSC1	;IF BLANKS SKIPPED, LOOP
	JUMPL	T4,FNMSC6	;IF BLANK TERMINATES, JUMP
	SETZ	T2,		;NOTE BLANK VS. TERMINATOR
	POPJ	P,		;EXIT TO CALLER
 
FNMSC5:	CAILE	T0,'Z'		;IF DELIMITER IS IN 7X GROUP
	  ANDCMI  T0,50		;  PUT IN THE 2X GROUP
FNMSC6:	MOVSI	T2,400000	;1-BIT FLAG FOR THE DELIMITER
	MOVN	T4,T0		;SET THE SHIFT COUNT
	LSH	T2,(T4)		;SET BIT FOR THIS DELIMITER
	POPJ	P,		;RETURN TO CALLER
 
FNMSC7:	TLNN	T2,760000	;IF NO MORE ROOM IN DEST.
	  JRST [JUMPN	T3,FNMSC1	;(IF T3 ALREADY USED)
		MOVE	T2,[POINT 6,T3]	;POINT TO T3
		JRST	FNMSC8]		;GO FILL T3
FNMSC8:	IDPB	T0,T2		;DEPOSIT T0 INTO T1 OR T3
	JRST	FNMSC1		;GO GET NEXT CHARACTER
 
 
	END
  