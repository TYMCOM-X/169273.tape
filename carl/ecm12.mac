UNIVERSAL ECM12	MACRO DEFINITION FILE (USED WITH JOBDAT,MACTEN,UUOSYM,SCNMAC)
SUBTTL	EDWARD C. MULREAN

.DIRECTIVE .NOBIN	;DON'T GENERATE A REL FILE
.DIRECTIVE .XTABM	;EXCLUDE EXTRA TABS FROM MACRO ARGS

	%%ECMV==:12	;DEFINE AN INTERNAL VERSION NUMBER
	%%ECME==:46	;DEFINE AN INTERNAL EDIT LEVEL

;	Program:	ECMUNV.MAC
;	Author:		Edward C. Mulrean
;	Written:	21-Feb-75
;	Edited:		28-Oct-76

	SEARCH	MACTEN

	SALL
	SUBTTL		Table of Contents
;			----- -- --------

;	Macro			Description			    Page
;	-----			-----------			    ----
;  1.		  Table of contents ................................   2
;  2.		  Standard accumulator definitions .................   3
;  3.		  Character definitions not in MACTEN.UNV ..........   3
;  4.		  Variable definitions & bit assignments for ECMLIB    4
;  5.		  Useful operation definitions .....................   5
;  6.	VERSION - Generate a version number at location .JBVER .....   6
;  7.	REENTER	- Generate a reenter address at location .JBREN ....   7
;  8.	.TWOSEG	- Setup a two segment program ......................   7
;  9.	PURE	- Force following coding into the high segment .....   7
; 10.	IMPURE	- Force following coding into the low segment ......   7
; 11.	.RESET	- Set up for CCL entry, PDL, and Core zeroing ......   8
; 12.	SETPDL	- Setup the push down stack ........................   8
; 13.	CLEAR	- Clear an accumulator .............................   9
; 14.	MOVALL	- Transfer a set of locations by block transfer ....   9
; 15.	MOVAL2	- Transfer a set of locations by iteration .........   9
; 16.	XFR	- Move memory to memory ............................  10
; 17.	XFRI	- Move immediate to memory .........................  10
; 18.	XCALL	- External subroutine call via a PUSHJ .............  11
; 19.	CALL	- Do a PUSHJ subroutine call with optional args. ...  11
; 20.	RETURN	- Return from a subroutine (optional skip return) ..  11
; 21.	ERRSET	- Sets up initial error code & I/O routine .........  12
; 22.	FATAL	- Issue fatal error message with continuation ......  12
; 23.	WARN	- Issue warning error message with continuation ....  12
; 24.	INFO	- Issue information message with continuation ......  12
; 25.	FATALX	- Issue fatal error message with no continuation ...  12
; 26.	WARNX	- Issue warning error message with no continuation .  12
; 27.	INFOX	- Issue information message with no continuation ...  12
; 28.	WRITE	- Output a message using .TOUTS ....................  12
; 29.	ERROR	- Generate CALL to appropriate error message .......  12
; 30.	ERJMP	- Generate JUMP? to appropriate error message ......  12
; 31.	ERR	- Generate error label of the form E$$??? ..........  12
;	 .
;	 .
;	 .
; 55.	FIN	- Used in place of END to generate special ending ..  20
; 56.	PRGFIN	- Used in place of PRGEND for special ending .......  20
; 57.	$FIN	- Internal MACRO called by FIN and PRGFIN ..........  20
; 58.	TEXT	- Expand ASCIZ text without long octal listing .....  21
; 59.	STOREL	- Store literals and variables at program END ......  21
; 60.	HELLO	- Generates entry point for FORTRAN subroutine .....  22
; 61.	GOODBY	- Generates return from FORTRAN subroutine .........  22
; 62.	FUNCT	- Generates FORTRAN-10 subroutine call .............  22
	SUBTTL	AC DEFINITIONS AND CHARACTER DEFINTIONS


			;AC DEFINITIONS
	F=	 0		;FLAG AC
	T0=	 F		;SCRATCH REGISTER FOR FOROTS
	T1=	 1		;GENERAL PURPOSE
	T2=	 2		;GENERAL PURPOSE
	T3=	 3		;GENERAL PURPOSE
	T4=	 4		;GENERAL PURPOSE
	P1=	 5		;PRESERVED AC
	P2=	 6		;PRESERVED AC
	P3=	 7		;PRESERVED AC
	N=	P3		;NUMBER AC
	P4=	10		;PRESERVED AC
	C=	P4		;CHARACTER I/O AC
	M1=	11		;USED IN MACROS AND LIBRARY
	M2=	12		;USED IN MACROS AND LIBRARY
	M3=	13		;USED IN MACROS AND LIBRARY
	M4=	14		;USED IN MACROS AND LIBRARY
;		15		;--UNDEFINED--
	L=	16		;SUBROUTINE LINKAGE AC (USED BY FORTRAN)
	P=	17		;PUSH DOWN LIST


			;CHARACTER DEFINITIONS NOT IN C.UNV

	.CHSPC== 40		;SPACE
	.CHCOM== 54		;COMMA
	.CHDOT== 56		;PERIOD
	.CHCOL== 72		;COLAN
	.CHLT==  74		;LESS THAN (LEFT ANGLE BRACKET)
	.CHEQ==  75		;EQUAL TO
	.CHGT==  76		;GREATER THAN (RIGHT ANGLE BRACKET)
	.CHLB== 133		;LEFT BRACKET
	.CHRB== 135		;RIGHT BRACKET
	.CHLA== 137		;BACK (LEFT) ARROW
	SUBTTL	VARIABLE DEFINITIONS AND BIT ASSIGNMENTS FOR ECMLIB

			;I/O TYPE DEFINITIONS FOR IOSETUP
IO$LKP==0		;LOOKUP THE FILE
IO$ENT==1		;ENTER THE FILE
IO$RAN==2		;SETUP FOR RANDOM ACCESS
IO$APN==3		;SETUP FILE FOR APPENDING
IO$SUP==4		;SETUP FOR SUPER USETI/USETO (DO NOTHING)
IO$MAX==4		;MAXIMUM I/O TYPE VALUE


			;SETUP AND ERROR FLAG DEFINITIONS FOR IOSETUP
IF$SIC==1B0		;SELECT CHANNEL FOR INPUT (DEFAULT IF INPUT HEADER)
IF$SOC==1B1		;SELECT CHANNEL FOR OUTPUT (DEFAULT IF OUTPUT HEADER)
IF$IFO==1B2		;INHIBIT FILE OPEN/LOOKUP/ENTER ON IOSETUP CALL
IF$RES==1B3		;RETURN ERROR STATUS ON I/O ERRORS (NO MESSAGE)
IF$REM==1B4		;RETURN ERROR STATUS ON I/O ERRORS AFTER MESSAGE
	SUBTTL	USEFUL ASSORTED OPDEFS

OPDEF	GOTO	[JRST]
OPDEF	PGOTO	[GOTO]
OPDEF	NOP	[JFCL]
OPDEF	PERFORM	[PUSHJ P,]

OPDEF	TMF$EQ	[CAMN]	;TEST MEMORY AND SKIP IF CONDITION IS FALSE
OPDEF	TMF$NE	[CAME]
OPDEF	TMF$LT	[CAMGE]
OPDEF	TMF$LE	[CAMG]
OPDEF	TMF$GT	[CAMLE]
OPDEF	TMF$GE	[CAML]
OPDEF	TMT$EQ	[CAME]	;TEST MEMORY AND SKIP IF CONDITION IS TRUE
OPDEF	TMT$NE	[CAMN]
OPDEF	TMT$LT	[CAML]
OPDEF	TMT$LE	[CAMLE]
OPDEF	TMT$GT	[CAMG]
OPDEF	TMT$GE	[CAMGE]
OPDEF	TIF$EQ	[CAIN]	;TEST IMMEDIATE AND SKIP IF CONDITION IS FALSE
OPDEF	TIF$NE	[CAIE]
OPDEF	TIF$LT	[CAIGE]
OPDEF	TIF$LE	[CAIG]
OPDEF	TIF$GT	[CAILE]
OPDEF	TIF$GE	[CAIL]
OPDEF	TIT$EQ	[CAIE]	;TEST IMMEDIATE AND SKIP IF CONDITION IS TRUE
OPDEF	TIT$NE	[CAIN]
OPDEF	TIT$LT	[CAIL]
OPDEF	TIT$LE	[CAILE]
OPDEF	TIT$GT	[CAIG]
OPDEF	TIT$GE	[CAIGE]
OPDEF	T0F$EQ	[SKIPN]	;TEST MEMORY TO 0 AND SKIP IF CONDITION IS FALSE
OPDEF	T0F$NE	[SKIPE]
OPDEF	T0F$LT	[SKIPGE]
OPDEF	T0F$LE	[SKIPG]
OPDEF	T0F$GT	[SKIPLE]
OPDEF	T0F$GE	[SKIPL]
OPDEF	T0T$EQ	[SKIPE]	;TEST MEMORY TO 0 AND SKIP IF CONDITION IS TRUE
OPDEF	T0T$NE	[SKIPN]
OPDEF	T0T$LT	[SKIPL]
OPDEF	T0T$LE	[SKIPLE]
OPDEF	T0T$GT	[SKIPG]
OPDEF	T0T$GE	[SKIPGE]
OPDEF	TZF$EQ	[JUMPN]	;TEST AC TO ZERO AND JUMP IF CONDITION IS FALSE
OPDEF	TZF$NE	[JUMPE]
OPDEF	TZF$LT	[JUMPGE]
OPDEF	TZF$LE	[JUMPG]
OPDEF	TZF$GT	[JUMPLE]
OPDEF	TZF$GE	[JUMPL]
OPDEF	TZT$EQ	[JUMPE]	;TEST AC TO ZERO AND JUMP IF CONDITION IS TRUE
OPDEF	TZT$NE	[JUMPN]
OPDEF	TZT$LT	[JUMPL]
OPDEF	TZT$LE	[JUMPLE]
OPDEF	TZT$GT	[JUMPG]
OPDEF	TZT$GE	[JUMPGE]
	SUBTTL	VERSION - Macro to setup program version



;****[VERSION]**** MACRO TO SETUP A PROGRAM VERSION

DEFINE	VERSION	(CODE,NUMBER),<

	CODE'WHO==0			;;INITIALIZE VERSION NUMBER
	CODE'VER==0
	CODE'MIN==0
	CODE'EDT==0
	X.....==0			;;INITILIZE ERROR FLAG
	W.....==0			;;INITIALIZE SECTION FLAG

IRPC	NUMBER,<
IFE	W.....,<			;;SECTION TO SCAN MAJOR VERSION
IFGE	"NUMBER"-"0",<IFLE "NUMBER"-"7",<;;IF PART OF MAJOR VERSION
	CODE'VER==CODE'VER*^D8+NUMBER	;;UPDATE MAJOR VERSION
>>
IFL	"NUMBER"-"0",<W.....==1>	;;IF NOT PART TRY MINOR
IFG	"NUMBER"-"7",<W.....==1>	;;  "       "
> ;;END IFE W.....

IFE	W.....-1,<			;;SECTION TO SCAN MINOR VERSION
IFGE	"NUMBER"-"A",<IFLE "NUMBER"-"Z",<;;IF PART OF MINOR VERSION
	CODE'MIN==CODE'MIN*^D26+"NUMBER"-"A"+1;;UPDATE MINOR VERSION
>>
IFL	"NUMBER"-"A",<W.....==2>	;;IF NOT PART, TRY EDIT
IFG	"NUMBER"-"Z",<W.....==2>	;;   "          "
> ;;END IFE W.....-1

IFE	W.....-4,<W.....==5>		;;KLUDGE TO END EDIT NUMBER

IFE	W.....-3,<			;;SECTION TO PROCESS EDIT NUMBER
IFGE	"NUMBER"-"0",<IFLE "NUMBER"-"7",<;;IF PART OF EDIT NUMBER
	CODE'EDT==CODE'EDT*^D8+NUMBER	;;UPDATE EDIT NUMBER
>>
IFL	"NUMBER"-"0",<			;;IF END OF EDIT #
IFE	"NUMBER"-")",<W.....==4>	;;IF LEGAL--GO ON
IFN	"NUMBER"-")",<W.....==-1	;;ELSE ERROR
			X.....==-1>	;;FLAG ERROR
> ;;END IFL
IFG	"NUMBER"-"7",<			;;IF END OF EDIT #
IFE	"NUMBER"-")",<W.....==4>	;;IF LEGAL--GO ON
IFN	"NUMBER"-")",<W.....==-1	;;ELSE ERROR
			X.....==-1>	;;FLAG IT
> ;; END IFG
> ;;END IFE W.....-3

IFE	W.....-2,<			;;SECTION TO SEE IF EDIT # COMMING
IFE	"NUMBER"-"(",<W.....==3>	;;FLAG IF EDIT # NEXT
IFN	"NUMBER"-"(",<W.....==5>	;;FLAG CHECK WHO FIELD
> ;;END IFE W.....-2

IFE	W.....-6,<			;;SECTION TO PROCESS WHO PART
IFGE	"NUMBER"-"0",<IFLE "NUMBER"-"7",<;;IF PART OF WHO
	CODE'WHO==CODE'WHO*^D8+NUMBER	;;UPDATE WHO NUMBER
>>
IFL	"NUMBER"-"0",<W.....==-1	;;IF NOT #, ERROR
			X.....==-1>	;;FLAG IT
IFG	"NUMBER"-"7",<W.....==-1	;;IF NOT #, ERROR
			X.....==-1>	;;FLAG IT
> ;;END IFE W.....-6

IFE	W.....-5,<			;;SECTION TO SEE IF WHO COMMING
IFE	"NUMBER"-"-",<W.....==6>	;;FLAG IF EDIT # NEXT
IFN	"NUMBER"-"-",<W.....==-1	;;IF NOT-- ERROR
			X.....==-1>	;;SET FLAG
> ;;EDN IFE W.....-5
> ;;END IRPC NUMBER

IF1,<IFN X.....,<PRINTX ?ECMBVS Bad version number syntax.>>
	PURGE	X.....,W.....		;;CLEAN UP

	LOC	.JBVER			;;SETUP VERSION AT .JBVER
	VRSN.	(CODE)			;;EXPAND THE VERSION
	RELOC
>
	SUBTTL	GENERAL PROGRAM SETUP AND CONTROL MACROS

;****[REENTER]**** MACRO TO SETUP A PROGRAM REENTER ADDRESS

DEFINE	REENTER	(ADR),<
	LOC	.JBREN
	EXP	ADR
	RELOC
>


;****[.TWOSEG]**** MACRO TO INITILIZE A TWO SEGMENT PROGRAM

DEFINE	.TWOSEG,<
	TWOSEGMENTS
	RELOC	400000
	P2%$EG==0		;;SET TWO SEG FLAG
>


;****[PURE]**** MACRO TO PUT THE CODE FOLLOWING INTO THE HIGH SEGMENT

DEFINE	PURE,	<
IFDEF	P2%$EG,<
IFL	<.-400000>,<RELOC>
>>


;****[IMPURE]**** MACRO TO PUT THE CODE FOLLOING INTO THE LOW SEGMENT

DEFINE	IMPURE,	<
IFDEF	P2%$EG,<
IFG	<.-400000>,<RELOC>
>>
	SUBTTL	GENERAL INITILIZATION MACROS

;****[.RESET]**** MACRO TO SETUP CCL ENTRY, PDL, AND CLEAR LOW CORE

DEFINE	.RESET	<
	PO%$00==0		;;SHOW WE ARE SETTING UP OFFSET
	TDZA	T1,T1		;;NORMAL START T1=0
	MOVEI	T1,1		;;CCL START T1=1
	MOVEM	T1,OFFSET	;;SAVE THE CCL OFFSET FOR LATER
	RESET			;;RESET ALL I/O
	STORE	0,ZCORE,EZCORE,0;;CLEAR LOW CORE
	STORE	17,0,16,0	;;ZERO ALL AC'S
	SETPDL			;;CONSTRUCT A PUSH DOWN LIST
>


;****[SETPDL]**** MACRO TO SETUP PDL SIZE=PDLSIZ [DEFAULT 50] LOC=PDL:

DEFINE	SETPDL	<
	ND	PDLSIZ,50	;;DEFAULT PDL SIZE
	MOVE	P,[IOWD PDLSIZ,PDL];;SETUP THAT PDL
>

	SUBTTL	GENERAL DATA MOVE AND CLEAR MACROS

;****[CLEAR]**** MACRO TO CLEAR AN ACCUMULATOR (NO COMMA NEEDED)

DEFINE	CLEAR	(LOC),<		;;CLEAR AC LOCATION
	SETZ	LOC,		;;CLEAR THE AC
>


;****[MOVALL]**** MACRO TO BLOCK TRANSFER ON ARRAY TO ANOTHER
;		AC CHANGED: M1

DEFINE	MOVALL	(FROM,TO,NUMBER)<
	MOVE	M1,[XWD FROM,TO]	;;SETUP BLOCK TRANSFER
	BLT	M1,TO+NUMBER		;;TRANSFER IT
>


;****[MOVAL2]**** MACRO TO TRANSFER 1 ARRAY TO ANOTHER BY LOOPING
;		ACS CHANGED: M1, M2

DEFINE	MOVAL2	(FROM,TO,NUMBER)<
	MOVX	M2,NUMBER		;;SETUP A LOOP COUNTER
	XFR	FROM(M2),TO(M2)		;;TRANSFER ONE LOCATION
	SOJGE	M2,.-2			;;SEE IF MOVED ALL LOC'S
>
	SUBTTL	MACROS TO TRANSFER DATA MEMORY/IMMEDIATE TO MEMORY

;****[XFR]**** MACRO TO DO A MEMORY TO MEMORY MOVE (2 INSTRUCTIONS)
;		AC USED: M1

DEFINE	XFR	(FROM,TO),<
	MOVE	M1,FROM		;;GET THE VALUE
	MOVEM	M1,TO		;;AND STORE IT
>


;****[XFRI]**** MACRO TO MOVE IMMEDIATE DATA TO MEMORY (2 INSTRUCTIONS)
;		AC USED: M1
;		NOTE: IMMEDIATE VARIABLES MUST BE DEFINED ON PASS 1

DEFINE	XFRI	(FROM,TO),<
IFE	FROM,<
	CLEARM	TO		;;JUST CLEAR IF POSSIBLE>
IFE	<FROM+1>,<
	SETOM	TO		;;SET TO ONES MEMORY IF POSSIBLE
>
IFN	<FROM>*<<FROM>+1>,<
	MOVX	M1,FROM		;;GET THE VALUE
	MOVEM	M1,TO		;;AND STORE IT
>>
	SUBTTL	SUBROUTINE CALL AND RETURN MACROS

;****[XCALL]**** MACRO TO CALL AN EXTERNAL SUBROUTINE VIA A PUSHJ

DEFINE	XCALL	(ROUTINE,ARGS),<
	EXT	ROUTINE
	CALL	ROUTINE,ARGS
>


;****[CALL]**** MACRO TO CALL A SUBROUTINE VIA A PUSHJ

DEFINE	CALL	(ROUTINE,ARGS),<
IFNB	<ARGS>,<
	C.....=0
IRP	ARGS,<	C.....=C.....+1>
	MOVEI	L,[XWD -C.....,0
		   IRP ARGS,<ARGS>]+1
	PURGE	C.....
>
	PUSHJ	P,ROUTINE
>


;****[RETURN]**** MACRO TO RETURN FROM A SUBROUTINE CALLED VIA CALL

DEFINE RETURN (SKIPS),<
IFE SKIPS-1,<
	AOS	(P)		;;INCREMENT  ADRESS
>
IFE SKIPS+1,<
	SOS	(P)		;;DISTRESSFUL LOOP RETURN
>
IFE	<SKIPS>*<<SKIPS>+1>*<<SKIPS>-1>,<
	POPJ	P,		;;NOTE: THIS DOESN'T RESTORE CPU STATE
>
IFN	<SKIPS>*<<SKIPS>+1>*<<SKIPS>-1>,<
	POP	P,M1		;;GET RETURNING ADDR
	JRST	@SKIPS(M1)	;;AND DO A MINUS RETURN
>>
	SUBTTL	MESSAGE PROCESSING MACRO'S

;****[ERRSET]**** SETS UP INITIAL ERROR CODE AND I/O ROUTINE

DEFINE	ERRSET	(CODE,ROUTINE)	<
IFB	<ROUTINE>,<
	MOVSI	T1,''CODE''		;;GET ERROR CODE AND USE TTCALL OUTPUT
>
IFNB	<ROUTINE>,<
	MOVE	T1,[''CODE'',,ROUTINE]	;;GET ERROR CODE AND OUTPUT ROUTINE
>
	XCALL	ERRINI			;;AND INITILIZE IT
	>

;****[FATAL]**** ISSUE A FATAL MESSAGE WITH CONTINUATION (2 RETURNS)

DEFINE	FATAL	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
E$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERRFTL			;;CALL FATAL ERROR ROUTINE
	>

;****[WARN]**** ISSUE A WARNING MESSAGE WITH CONTINUATION (2 RETURNS)

DEFINE	WARN	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
W$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERRWRN			;;CALL WARNING ERROR ROUTINE
	>

;****[INFO]**** ISSUE AN INFORMATION MESSAGE WITH CONTINUATION (2 RETURNS)

DEFINE	INFO	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
I$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERRINF			;;CALL INFO MESSAGE ROUTINE
	>

;****[FATALX]**** ISSUE A FATAL MESSAGE NO CONTINUATION

DEFINE	FATALX	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
E$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERXFTL			;;CALL FATAL ERROR ROUTINE
	>

;****[WARNX]**** ISSUE A WARNING MESSAGE NO CONTINUATION

DEFINE	WARNX	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
W$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERXWRN			;;CALL WARNING ERROR ROUTINE
	>

				CONT.

;****[INFOX]**** ISSUE AN INFORMATION MESSAGE NO CONTINUATION

DEFINE	INFOX	(CODE,MSG1,MSG2,MSG3,MSG4,MSG5)	<
I$$'CODE:
	PUSH	P,[[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\],,''CODE'']
	XCALL	ERXINF			;;CALL INFO MESSAGE ROUTINE
	>

;****[WRITE]**** OUTPUT AN ASCIZ MESSAGE USING .TOUTS

DEFINE	WRITE	(MSG1,MSG2,MSG3,MSG4,MSG5)	<
	MOVEI	T1,[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5\];;LOAD MESSAGE
	XCALL	.TSTRG			;;AND DUMP THRU TOUTS
	>

;****[ERROR]**** GENERATES CALL TO APPROPRIATE ERROR MESSAGE

DEFINE	ERROR	(ECODE)	<
IF1	<JRST	.>
IF2	<IFDEF E$$'ECODE <CALL E$$'ECODE>
	 IFDEF W$$'ECODE <CALL W$$'ECODE>
	 IFDEF I$$'ECODE <CALL I$$'ECODE>
	 IFNDEF E$$'ECODE <IFNDEF W$$'ECODE <IFNDEF I$$'ECODE <
		PRINTX	?	Undefined error code: ECODE
		HALT	.>>>
	>>

;****[ERJMP]**** GENERATES JUMP? TO APPROPRIATE ERROR MESSAGE

DEFINE	ERJMP	(HOW,AC,ECODE)	<
IF1	<JRST	.>
IF2	<IFDEF E$$'ECODE <JUMP'HOW AC,E$$'ECODE>
	 IFDEF W$$'ECODE <JUMP'HOW AC,W$$'ECODE>
	 IFDEF I$$'ECODE <JUMP'HOW AC,I$$'ECODE>
	 IFNDEF E$$'ECODE <IFNDEF W$$'ECODE <IFNDEF I$$'ECODE <
		PRINTX	?	Undefined error code: ECODE
		HALT	.>>>
	>>

;****[ERR]**** GENERATES AN ERROR LABEL OF THE FORM E$$'???

DEFINE	ERR	(CODE)	<E$$'CODE>
	SUBTTL	TELETYPE I/O MACROS

;****[TYPE]**** MACRO TO TYPE A MESSAGE ON THE TTY VIA AN OUTSTR

DEFINE	TYPE	(MSG1,MSG2,MSG3,MSG4,MSG5,MSG6)<
	OUTSTR	[ASCIZ\MSG1'MSG2'MSG3'MSG4'MSG5'MSG6\]
>


;****[STAR]**** MACRO TO OUTPUT AN ASTRIK TO THE TTY VIA AN OUTCHR

DEFINE	STAR	<
	OUTCHR	["*"]			;;DUMP OUT STAR
>


;****[CRLF]**** MACRO TO OUTPUT A CR-LF TO THE TTY VIA OUTSTR

DEFINE	CRLF	<
	TYPE	<
>>


;****[FRCSTR]**** MACRO TO FORCE AN ASTRIK OUT TO THE TTY VIA TTCALLS

DEFINE	FRCSTR	<
	SKPINL
	  NOP
	STAR
>


;****[FRCTTY]**** MACRO TO FORCE A MESSAGE OUT TO THE TTY VIA TTCALLS

DEFINE	FRCTTY	(MSG1,MSG2,MSG3,MSG4,MSG5,MSG6),<
	SKPINL
	  NOP
	TYPE	<MSG1'MSG2'MSG3'MSG4'MSG5'MSG6>
>
	SUBTTL	I/O MACROS TO INTERFACE WITH ECMLIB

;****[INLINE]**** MACRO TO INPUT A LINE OF TEXT FROM THE TTY
;		FLAG=0	IF SET AMOUNT OF DATA INPUT LOCATIONS
;		FLAG#0	IF VARIABLE AMOUNT OF INPUT LOCATIONS
;		ACS USED: M1,M2,M3,C

DEFINE	INLINE	(LOC,MAXWRD,FLAG),<
IFN	FLAG,<
	MOVE	M1,MAXWRD		;;GET MAXIMUM # OF WORDS
	HRLI	M1,LOC			;;AND POINT TO LOCATION TO PUT
>
IFE	FLAG,<
	MOVE	M1,[LOC,,MAXWRD]	;;GET LOCATION,,# OF WORDS
>
	XCALL	TTYSVN			;;GO TO ROUTINE TO DO IT
>

DEFINE	INLIN6	(LOC,SIZE),<
	MOVE	M4,[SIZE,,LOC]		;;LOAD M4 WITH SIZE AND LOCATION
	XCALL	TTYSIX			;;CALL SIXBIT INPUTING ROUTINE
>

DEFINE	OUTTMP	(NAME,ADR),<	;;MACRO TO CALL WRTTMP TO WRITE A TMP FILE
	MOVE	T1,[ADR,,(SIXBIT/NAME/)];;LOAD TEXT ADDRESS AND TMP NAME
	XCALL	WRTTMP		;;GO TO WRITE IT OUT (NOTE 2 RETURNS)
>
	SUBTTL	IF - THEN - ELSE  CONDITIONAL MACROS

DEFINE	IF	(A,COND,B,$THEN),<
	IN$AC	<A>;			;;MAKE SURE VAR IS IN AN AC
	MI%$00==YES$NO			;;PROTECT THE RESPONCE
IFE	MI%$00,<	;;*****IF HAD TO PUT INTO AN AC*****
	$IF	(A,COND,B,$THEN,M3,B,TMF$,TMT$)
>
IFN	MI%$00,<	;;*****IF ALREADY IN AN AC*****
	$IF	(A,COND,B,$THEN,A,B,TMF$,TMT$)
>>

DEFINE	IFI	(A,COND,B,$THEN),<;;IMMEDIATE IF --- THEN STATEMENT
IFE	B,<		;;*****IF COMPARING WITH ZERO*****
	$CHECK	A,<F,T0,T1,T2,T3,T4,P1,P2,P3,N,P4,C,M1,M2,M3,M4,L,P>
	MI%$00==YES$NO			;;PROTECT THE RESPONCE
IFE	MI%$00,<	;;*****IF NOT IN AN AC*****
	$IF	(A,COND,B,$THEN,,A,T0F$,T0T$)
>
IFN	MI%$00,<	;;*****IF ALREADY IN AN AC*****
	$IF	(A,COND,B,$THEN,A,<.+2>,TZF$,TZT$)
>>
IFN	B,<		;;*****IF COMPARING WITH SOME NON-ZERO VALUE*****
	IN$AC	<A>;		;;PUT INTO AC IF NEEDED
	MI%$00==YES$NO			;;PROTECT THE RESPONCE
IFE	MI%$00,<	;;*****IF HAD TO PUT INTO AN AC*****
	$IF	(A,COND,B,$THEN,M3,B,TIF$,TIT$)
>
IFN	MI%$00,<	;;*****IF ALREADY IN AN AC*****
	$IF	(A,COND,B,$THEN,A,B,TIF$,TIT$)
>>>
DEFINE	$IF	(A,COND,B,$THEN,AC,MEM,FALSE,TRUE),<
	$CHECK	COND,<LT,LE,EQ,NE,GE,GT>
IFE	YES$NO,<
$$MERR <?IF ('A .'COND'. B') $THEN ... is not an acceptable construct.>,
<Illegal clause: COND>,\.
>
IFN	YES$NO,<
IFB	<$THEN>,<
	FALSE'COND	AC,MEM		;;TEST CONDITION, SKIP IF FALSE
>
IFNB <$THEN>,<
IFDIF	<THEN>,<$THEN>,<
$$MERR <?IF ('A .'COND'. B') $THEN ... is not an acceptable construct.>,
<Illegal clause: $THEN>,\.
>
IFIDN	<THEN>,<$THEN>,<
	ND	IT%$00,0	;;HANDEL CASE OF FIRST IF --- THEN
	IT%$00==IT%$00+1	;;INCREMENT FOR THIS IF --- THEN
	$VAR	IT%$,\IT%$00,0;;;;SET UP VARIABLE FOR ENDIF MACRO
IF2,<	$$THEN	\IT%$00,A,COND,B,$THEN>
IFIDN	<TZF$>,<FALSE>,<
	$INST	FALSE'COND,A,L%$,\IT%$00;;JUMP AROUND IF CONDITION FALSE
>
IFDIF	<TZF$>,<FALSE>TRUE'COND	AC,MEM	;;SKIP IF CONDITION TRUE
	$INST	GOTO,,L%$,\IT%$00	;;ELSE JUMP AROUND
>>>>>
DEFINE	ELSE	<
	$FIND	IT%$,IT%$00	;;LOCATE CURRENT IF --- THEN STATEMENT
IFE	MV%$00,<
	$$MERR	<?No IF -- THEN statement for ELSE clause.>,
<ELSE macro ignored.>,\.
>
IFN	MV%$00,<
	IT%$00==IT%$00+1		;;INCREMENT LABEL COUNT FOR THIS ELSE
	$VAR	IT%$,\IT%$00,1		;;SETUP VARIABEL FOR ENDIF MACRO
IF2,<
	$$ELSE	(\IT%$00)		;;CHECK FOR ENDING ENDIF MACRO
>
	$INST	GOTO,,L%$,\IT%$00	;;BRANCH AROUND ELSE CLAUSE
	$LABEL	(L%$,\MV%$00);		;;GENERATE THE ENDING LABEL
	$INST	PURGE,MV%$00,IT%$,\MV%$00;;CLEAR OUT VARIABLE
>>

DEFINE	ENDIF	<
	$FIND	IT%$,IT%$00	;;LOCATE THE CURRENT IF --- THEN STATEMENT
IFE	MV%$00,<
$$MERR <?No IF --- THEN statement to end.>,<ENDIF macro ignored.>,\.
>
IFN	MV%$00,<
	$LABEL	(L%$,\MV%$00)	;;GENERATE THE ENDING LABEL
	$INST	PURGE,MV%$00,IT%$,\MV%$00	;;CLEAR VARIABLE OUT
>>
	SUBTTL	INTERNAL SUPPORT MACROS

DEFINE	IN$AC	(VARIABLE),<
	$CHECK	VARIABLE,<F,T0,T1,T2,T3,T4,P1,P2,P3,N,P4,C,M1,M2,M3,M4,L,P>
IFE	YES$NO,<
	MOVE	M3,VARIABLE		;;PUT VARIABLE IN AC IF NOT ONE
>>

DEFINE	$CHECK	(VARIABLE,LIST),<
	YES$NO==0		;;PRESET FLAG TO NOT IN LIST
IRP	LIST,<
IFIDN	<VARIABLE>,<LIST>,<YES$NO==1>
>>

DEFINE	$VAR	(PART1,PART2,VALUE),<
	PART1'PART2==VALUE	;;DEFINE A FANCY VARIABLE
>

DEFINE	$INST	(CODE,AC,MEM1,MEM2),<
	CODE	AC,MEM1'MEM2	;;DEFINE A FANCY INSTRUCTION
>

DEFINE	$LABEL	(PART1,PART2),<
PART1'PART2:			;;DEFINE A FANCY LABEL
>

DEFINE	$FIND	(VARIABLE,NUMBER),<
	MV%$00==0		;;FLAG NONE FOUND
	MT%$00==NUMBER		;;COPY HIGHEST NUMBER TO CHECK TO TEMP
REPEAT	NUMBER,<
	$$FIND	VARIABLE,\MT%$00,MT%$00;;IS THIS VARIABLE DEFINED?
	MT%$00==MT%$00-1
>>

DEFINE	$$FIND	(VAR1,VAR2,NUMBER),<
IFG	<NUMBER-MV%$00>,<;;	;;ONLY CHECK IF HAVN'T FOUND ONE YET
IFDEF	VAR1'VAR2,<
	MV%$00==NUMBER		;;SAVE HIGHEST NUMBER IN MV%$00
>>>
DEFINE	$$MERR	(TEXT1,TEXT2,LOC),<
IF2,<	PRINTX
PRINTX	TEXT1
IFNB	<TEXT2>,<PRINTX TEXT2>
	PRINTX	Error at location: LOC
>>

DEFINE	$$THEN	(COUNT,A,COND,B,$THEN),<
IFL	L%$'COUNT,<
$$MERR	<?IF ('A .'COND'. B') $THEN ... has no ending>,
<Illegal code will be generated.>,\.
>>

DEFINE	$$ELSE	(COUNT),<
IFL	L%$'COUNT,<
$$MERR	<?IF --- THEN ... ELSE ... has no ending.>,
<Illegal code will be generated.>,\.
>>
	SUBTTL	GENERAL PROGRAM CLOSE UP MACROS

;****[FIN]**** MACRO TO REPLACE AN END STATEMENT IN A PROGRAM

DEFINE	FIN	(START),<
	$FIN	END,START	;;GO GENERATE PROPER END CODE
>


;****[PRGFIN]**** MACRO TO REPLACE A PRGFIN STATEMENT IN A PROGRAM

DEFINE	PRGFIN	(START),<
	$FIN	PRGEND,START	;;GO GENERATE PROPER PRGEND CODE
>


;****[$FIN]**** INTERNAL MACRO TO DO WORK FOR FIN AND PRGFIN MACROS

DEFINE	$FIN	(END,START),<	;;MACRO TO CLEAN UP NICELY
	IMPURE
IF1,<
IFDEF	IT%$00,<
REPEAT	IT%$00,<
	$FIND	IT%$,IT%$00	;;LOOK FOR OPEN IF --- THEN STATEMENTS
IFN	MV%$00,<		;;FOUND ONE?
	$VAR	L%$,\MV%$00,-1	;;FUDGE A VALUE TO KEEP MACRO HAPPY
	$INST	PURGE,MV%$00,IT%$,\MV%$00
>>
	PURGE	IT%$00		;;RESET IF STATEMENT FLAG
>
IFDEF PDLSIZ,< IFNDEF PDL,<	;;RESERVE PDL LOCATIONS IF NEEDED
PDL:	BLOCK	PDLSIZ
	PP%$00==0		;;FLAG WE HAD TO CONSTRUCT PDL BLOCK
>>
	ND	EZCORE,.-1	;;DEFINE END OF LOW CORE IF NOT DEFINED
IFDEF PO%$00,< IFNDEF OFFSET,<	;;SETUP OFFSET LOCATION IF NEEDED
OFFSET:	BLOCK	1
	PO%$01==0		;;FLAG WE HAD TO SETUP OFFSET LOC
>>>
IF2,<
IFDEF	PP%$00,<		;;MAKE SURE PDL IS MADE IN BOTH PASSES
PDL:	BLOCK	PDLSIZ
>
IFDEF	PO%$01,<		;;MAKE SURE OFFSET LOC IN BOTH PASSES
OFFSET:	BLOCK	1
>>
	STOREL			;;STORE ENDING LITERALS IN BOTH PASSES
	END	START>		;;AND BIND OFF NICELY
	SUBTTL	GENERAL STORAGE MACROS

;****[TEXT]**** MACRO TO GENERATE NICE LISTING OF ASCIZ TEXT

DEFINE	TEXT	(MSG),<
	XLIST
	ASCIZ	\MSG\
	LIST
>


;****[STOREL]**** MACRO TO PUT LITERALS IN HIGH SEG & VARIABLES IN LOW SEG

DEFINE	STOREL	<
	XLIST
	IMPURE
	VAR
	PURE
	LIT
	LIST
>
	SUBTTL	MACROS FOR FOROTS COMPATIBILITY

;****[HELLO]**** MACRO TO PUT IN THE BEGINNING OF A FORTRAN SUBROUTINE

DEFINE	HELLO	(NAME),<
	EXT	CEXIT.
	ENTRY	NAME
	SIXBIT/NAME/
NAME:	CAIA
	PUSH	P,CEXIT.
>


;****[GOODBY]**** MACRO TO RETURN FROM A FORTRAN SUBROUTINE

DEFINE	GOODBY	(N),<
	POPJ	P,N
>


;****[FUNCT]**** MACRO TO CALL A FORTRAN SUBROUTINE

DEFINE	FUNCT	(ROUTINE,ARGS),<	;;USED FOR SUBROUTINE CALLING
IFNB	<ARGS>,<
	X.....==0
IRP	ARGS,<X.....==X.....+1>
	PUSH	P,L
	MOVEI	L,[XWD -X.....,0
		IRP ARGS,<ARGS>]+1
	PURGE	X.....
>
	XCALL	ROUTINE
IFNB	<ARGS>,<
	POP	P,L
>>

	END
@@¤