	TITLE	QUEUER -- SUBROUTINE TO PUSHSEG TO HISEG -- %3(3)
	SUBTTL	P.CONKLIN/PFC/DAL/RLD	17-MARCH-1972


;***COPYRIGHT 1970,1971  DIGITAL EQUIPMENT CORP.,  MAYNARD, MASS.***


	INTERNAL  %QUEUR
	EXTERNAL  .JBSA,.JBREN,.JBREL,.JBFF


VERNO==3		;MAJOR VERSION NUMBER
VEDIT==3		;EDIT NUMBER
VMINOR==0		;MINOR EDIT NUMBDR
VWHO==0			;WHO LAST EDITED

%QUEUR==BYTE (3)VWHO(9)VERNO(6)VMINOR(18)VEDIT


;THIS SUBROUTINE IS TO BE LOADED INTO THE HIGH OR LOW SEGMENT AND IS
;CALLED WHEN IT IS DESIRED TO CALL THE SYSTEM HISEGMENT SUCH AS
;QUEUE MANAGER (QMANGR).
;THIS ROUTINE SAVES ALL ACS, REMEMBERS THE NAME OF THE CURRENT
;HIGH SEGMENT IF ANY, AND GETSEGS SYS: FOR THE SPECIFIED HISEGMENT.
;IT THEN PUSHJS TO 400010, HISEGMENT'S ENTRY POINT.
;WHEN FINISHED, POPJS BACK, AND QUEUER RESTORES THE PREVIOUS
;HIGH SEGMENT AND THE ACS.  FINALLY IT RETURNS.

;IN ORDER TO MAKE ^C START OR REENTER WORK,IT PUSHS THE START
;AND REENTER ADDRESSES AND SETS FAKE ONES TO POINT TO ITSELF.

;DEVELOPED AS A TOOL FOR THE MULTI-PROGRAMMED BATCH PROJECT
;JULY, 1970.

;REFER TO THE QUEUE CUSP DETAILED DESIGN SPECIFICATION (QUEUE.RNO)
;RELATED MODULES ARE QUEUE.MAC AND QMANGR.MAC


;DEFAULTS

IFNDEF	LN.PDL,<LN.PDL==70>	;LENGTH OF NEW PUSH-DOWN LIST
IFNDEF	DEBUG,<DEBUG==0>	;1=ACTIVATE DEBUGGING FEATURES
IFNDEF	PURESW,<PURESW==1>	;1=REENTRANT VERSION (LIVES IN HI-SEG)


	IFN	PURESW,<TWOSEG
			RELOC	400000>
	SUBTTL	STANDARD MNEMONICS--REGISTERS, BITS, UUOS

;AC NAMES

AC1=1	;ARG TO QMANGR
A=2	;SCRATCH AFTER PRESERVING
B=3
C=4
D=5
E=6
F=7
G=10

X=14	;TEMPORARY USED IN DOPH ROUTINE
T=15	;TEMPORARY USED IN SAVE LOGIC
R=16	;RELOCATION OF BLOCK IN LOW-SEG

P=17	;PUSH-DOWN LIST



;FLAGS

L.PHYS==1B0	;PHYSICAL GETSEG REQUESTED
L.HISG==1B1	;GET HISEGMENT POINTED BY AC1
L.PDLN==1B2	;DONOT RELOCATE PDL ELSEWHERE


;JOB TABLE INDICES

JBTSGN==14	;POINTER TO HIGH-SEGMENT FOR THIS JOB
JBTDEV==24	;NAME OF DEVICE FOR THIS HIGH-SEGMENT
JBTPPN==02	;DIRECTORY FOR THIS HIGH-SEGMENT
JBTPRG==03	;NAME OF THIS HIGH-SEGMENT

PDLOFF==35	;PDL OFFSET FOR CASE WHEN PDL NOT RELOCATED


IFN	DEBUG,<EXTERN	QUEUEN,QUEUEM>  ;CUSP NAME TO RETURN TO
	SUBTTL	GET AND ENTER HISEGMENT 

	ENTRY	.QUEER
	INTERN	QUEUER

;QUEUER -- ROUTINE TO PRESERVE ACS AND HIGH SEGMENT NAME, THEN
;GETSEG TO HISEG AND JUMP TO IT.  ON RETURN, RESTORE HIGH SEGMENT
;AND THE ACS, AND RETURN TO CALLER.
;THE ACCUMULATOR AC1 USED IN CALLING SEQUENCE USES THE FIELDS 
;AS DESCRIBED BELOW.
;BITS 0-8 ARE USED AS FLAG BITS, BITS 9-17 REPRESENT WORD COUNT FOR
;QMANGR PARAMETER AREA. IF BITS 1-8 ARE ZERO THEN ALWAYS CALL QMANGR.
;IF BITS 1 IS UP THEN CALL HISEGMENT POINTED BY THE ADDRESS IN BITS 18-35
;OF AC1. IF BIT 2 IS UP DONOT RELOCATE THE PDL.
;CALL:	MOVE	1,PARAMETER POINTER FOR QMANGR
;	MOVE	P,[IOWD 5,PUSH-DOWN LIST]
;	PUSHJ	P,QUEUER
;	ALWAYS RETURN
;PRESERVES ALL ACS.
;QUEUER WILL ALLOCATE CORE FROM C(.JBFF), ONLY IF BIT 2 IN LEFT HALF OF
;ACCUMULATOR AC1 IS DOWN AND IF SO IT WILL RESTORE IT BEFORE RETURNING.

.QUEER:!
QUEUER:	PUSH	P,T		;MAKE ROOM FOR TEMPORARY
	PUSH	P,R		;MAKE ROOM FOR RELOCATION REGISTER
	MOVEI	R,PDLOFF(P)		;LEAVE ROOM FOR THE PDL
	TLNE	AC1,(L.PDLN)	;CAN I RELOCATE THE STACK?
	JRST	NPDLS		;NO.NOT PDL STACK
	PUSH	P,.JBREL	;SAVE CORE SIZE

;HERE TO GRAB SPACE IN FREE CORE--EXPAND LOW SEG IF NEEDED

	HRRZ	R,.JBFF		;SET RELOCATION REGISTER
	MOVEI	T,LENLOW	;GET AMOUNT OF SPACE NEEDED
	ADDB	T,.JBFF		;ALLOCATE IT
	CAMLE	T,.JBREL	;SEE IF MORE CORE NEEDED
	CORE	T,		;YES--ASK FOR IT
	  JFCL			;PROCEED (IF NO CORE, WILL DIE LATER)

NPDLS:!	SETO	T,		;SET UWP BIT TO ONE
	SETUWP	T,		; ..
	  HALT	.		;THE ONLY WAY THIS CAN FAIL IS IF WE
				; DON'T HAVE KT10A.
	MOVEM	T,SAVUWP(R)	;SAVE THE OLD WRITE LOCK BIT
	TLNE	AC1,(L.PDLN)	;CAN I RELOCATE THE STACK?
	SKIPA	T,-2(P)		;NO
	MOVE	T,-3(P)		;SAVE RETURN POINT
	MOVEM	T,RETRNP(R)	;  IN CASE IT IS CHANGED LATER
	TLNE	AC1,(L.PDLN)	;NOW IS WHEN TO RELOCATE PDL.
	JRST	NPDLS1		;NO DONOT.
	MOVEM	P,PDL(R)	;SAVE OLD PUSH DOWN POINTER
	HRLZI	P,-LN.PDL	;SET LENGTH OF NEW LIST
	HRRI	P,PDL(R)	;SET START OF NEW LIST
;HERE WHEN SPACE HAS BEEN ALLOCATED, AND A NEW PDL ESTABLISHED
;SAVE THE ACS ON THIS NEW STACK

NPDLS1:!MOVSI	T,-T		;SET LOOP COUNTER TO SAVE ACS
	PUSH	P,(T)		;SAVE ONE AC
	AOBJN	T,.-1		;LOOP FOR 0-14

	PUSH	P,.JBSA		;SAVE START ADDRESS
	PUSH	P,.JBREN	;SAVE REENTER ADDRESS

;HERE WHEN ACS ARE SAVED--DETERMINE CURRENT HIGH SEG

	SETZB	B,D		;CLEAR IN CASE NO HIGH-SEG
	HRROI	A,JBTSGN	;GET HI-SEG INDEX
	GETTAB	A,
	  HALT	.
	JUMPLE	A,SVHISG	;IF NO HI-SEG INDEX, PROCEED
	HRLZ	B,A		;GET HI-SEG DEVICE
	HRRI	B,JBTDEV
	GETTAB	B,
	  MOVSI	B,'DSK'		;  IN CASE TABLE ABSENT
	HRLZ	C,A		;GET HI-SEG DIRECTORY
	HRRI	C,JBTPPN
	GETTAB	C,
	  HALT	.
	HRLZ	D,A		;GET HI-SEG NAME
	HRRI	D,JBTPRG
	GETTAB	D,
	  HALT	.

	JUMPGE	C,SVHISG	;IF JBTDEV TABLE ABSENT, IT IS IN PPN
	CAMN	B,[SIXBIT /DSK/]  ;IF PPN.LT.0 AND DEV=DSK
	MOVE	B,C		;THEN DEV WAS IN PPN
	MOVEI	C,0		;SO SHIFT IT
;HERE WHEN CURRENT HI-SEG HAS BEEN DETERMINED

SVHISG:	MOVEM	B,SAVDEV(R)	;SAVE DEVICE
	MOVEM	C,SAVDIR(R)	;SAVE DIRECTORY
	MOVEM	D,SAVNAM(R)	;SAVE FILE NAME

;HERE TO SWITCH STARTING ADDRESS TO ALLOW GETSEG BACK

	MOVEM	P,STARTP(R)	;SAVE PUSH-DOWN POINTER
	MOVEI	A,FAKSA(R)	;ESTABLISH TEMPORARY START ADDRESS
	HRRM	A,.JBSA		;  TO COME TO FIXUP ROUTINE
	MOVEI	A,FAKREN(R)	;ESTABLISH TEMPORARY REENTER
	HRRZ	B,.JBREN	;  BUT ONLY IF
	SKIPE	B		;  THERE IS ALREADY ONE
	HRRM	A,.JBREN	;  (IF NOT, SAY ?NO START ADDR)

;HERE TO GETSEG TO QMANGR

	MOVEI	A,B		;SET GETSEG POINTER TO BLOCK
	MOVSI	B,'SYS'		;GET FROM DEVICE "SYS:"
	TLNE	AC1,(L.HISG)	;WHAT SEGMENT?
	SKIPA	C,(AC1)		;GET NAME OF THE SEGMENT TO BE CALLED
	MOVE	C,[SIXBIT /QMANGR/]  ;GET FILE QMANGR.SHR
	SETZB	D,E		;CLEAR REST OF AREA
	SETZB	F,G		; ..
	MOVEM	P,SAVEP(R)	;SAVE P AROUND GETSEG

;BEFORE WE PROCEED, WE MUST MOVE ALL REMAINING CODE TO THE LOW SEG

	MOVSI	T,QUELOW	;START OF HI-SEG COPY OF CODE
	HRRI	T,(R)		;IT GOES TO START OF FREE SPACE
	BLT	T,LENLCD-1(R)	;COPY LENGTH OF CODE
	HRRM	R,RR1(R)	;SET CODE TO ESTABLISH RELOCATION
	HRRM	R,RR2(R)	; ..
	HRRM	R,RR3(R)	; ..
	HRRM	R,RR4(R)	; ..
	MOVSI	T,1		;ARG FOR CORE UUO

;JUMP INTO THE LOW SEGMENT TO EXECUTE THE CODE

GOLOW::	JRST	GTHISG(R)	;GO GET SEGMENT
;HERE TO RESTORE ACS AND RETURN

NOGET:	POP	P,.JBREN	;RESTORE REENTER ADDRESS
	POP	P,.JBSA		;RESTORE START ADDRESS

	MOVEI	T,T-1		;SET POINTER FOR LOOP
	POP	P,(T)		;RESTORE ONE AC
	SOJGE	T,.-1		;LOOP FOR 14-0

;HERE WHEN MOST ACS RESTORED.  NOW RESTORE OLD PDL AND CORE
;THEN FINISH UP AND RETURN.

	TLNE	AC1,(L.PDLN)	;WAS PDL RELOCATED?
	JRST	NOGET2		;NO.
	POP	P,T		;RESTORE OLD PDL.  THIS SEQUENCE
	MOVE	P,T		;  RATHER THAN POP P,P IN CASE OF
				;  A PDP-6 WHICH DID IT DIFFERENT
	MOVE	T,SAVUWP(R)	;FETCH USER WRITE PROTECT BIT
NOGET2:!SETUWP	T,		;RESET IT.
	  HALT	.		;HALT IF CAN NOT CLEAR UWP BIT AGAIN
				; THIS WILL ONLY HAPPEN IF UWP WAS
				; OFF AT CALL TO QUEUER BUT BECAUSE
				; GETSEGS SET THE MEDDLE BIT WE
				; CAN NOT TURN IT OFF AGAIN.
	MOVE	T,RETRNP(R)	;RESTORE RETURN ADDRESS
	TLNE	AC1,(L.PDLN)	;WAS PDL RELOCATED?
	JRST	[MOVEM	T,-2(P)		;RESTORE RETURN ADDRESS
		 JRST	NOGET1		;GO RESTORE PDL
			]
	MOVEM	T,-3(P)		;  IN CASE CHANGED BY START, ETC.
	HRRM	R,.JBFF		;RESTORE START OF FREE CORE
	POP	P,T		;RESTORE ORIGINAL CORE SIZE
	CAME	T,.JBREL	;SEE IF IT MATCHES
	CORE	T,		;NO--CHANGE BACK
	  JFCL			;WELL-NICE TRY
NOGET1:!POP	P,R		;RESTORE OLD AC
	POP	P,T		;RESTORE TEMPORARY
	POPJ	P,		;RETURN


;DUMP OUT LITERAL TABLE HERE

	LIT
	SUBTTL	CODE WHICH RUNS IN LOW-SEG

QUELOW:			;START OF HI-SEG COPY OF LOW-SEG CODE
	PHASE	0		;MAKE IT RELOCATABLE

GTHISG:!CORE	T,		;DUMP THE HISEG
	  JFCL			;BUT DO NOT WORY IF WE CAN'T
	TLNE	AC1,(L.PHYS)	;SEE IF PHYSICAL CALL
	PUSHJ	P,DOPH(R)	;YES--GO SET UP
	GETSEG	A,		;GETSEG QMANGR
	  HALT	-1		;DIE IF FAILURE
RR1:!	MOVEI	R,.-.		;RESTORE RELOCATION
	MOVE	P,SAVEP(R)	;RESTORE P
	MOVE	AC1,-15(P)	;RESTORE AC1 FOR QUEUE MANAGER
	TLZ	AC1,(L.PHYS)	;CLEAR PHYSICAL BIT FROM ARGS

;HERE WHEN QMANGR HAS BEEN ATTACHED

CLHISG:!PUSHJ	P,400010	;CALL QUEUE MANAGER
RR2:!	MOVEI	R,.-.		;RESTORE RELOCATION

;HERE ON RETURN TO GET BACK OLD SEGMENT

RESTOR:!MOVE	C,SAVNAM(R)	;RESTORE FILE NAME
	MOVE	F,SAVDIR(R)	;RESTORE DIRECTORY
	MOVE	B,SAVDEV(R)	;RESTORE DEVICE
	SETZB	D,E		;CLEAR REST OF AREA
	SETZ	G,		; ..
	MOVSI	A,1		;RELEASE HIGH SEGMENT
	CORE	A,		; ..
	  HALT	.(R)		; ..

	IFN	DEBUG,<
	MOVE	A,B		;COPY DEVICE
	PUSHJ	P,DOPH(R)	;DO PHYSICAL I/O IF POSSIBLE
	DEVCHR	A,		;SEE IF IT EXISTS
	TLNE	A,(1B1!1B11)	;SEE IF DISK OR DECTAPE
	SKIPE	C		;YES--SEE IF FILE NAME
	JUMPN	B,GTSEG(R)	;IF ALL SET, GO DO IT
	MOVSI	B,'DSK'		;ELSE, SETUP DSK:
	MOVSI	C,QUEUEM	;  OF DEBUGGING NAME
	HRRI	C,QUEUEN	;   ..
	MOVEI	F,0
	JUMPE	C,NOGET		;IF NO NAME, DON'T RESTORE
>

	IFE	DEBUG,<
	JUMPE	B,NOGET		;IF NO DEVICE, DON'T RESTORE
>
GTSEG:	MOVEI	A,B		;SETUP POINTER TO BLOCK
	MOVEM	P,SAVEP(R)	;SAVE P AROUND GETSEG
	PUSHJ	P,DOPH(R)	;DO PHYSICAL I/O IF POSSIBLE
	GETSEG	A,		;YES--GET PREVIOUS SEGMENT
	  HALT	-1		;HOPELESS IF FAILURE
RR3:!	MOVEI	R,.-.		;RESTORE RELOCATION
	MOVE	P,SAVEP(R)	;RESTORE P
	JRST	NOGET		;RETURN TO HI-SEG TO FINISH




;DOPH -- ROUTINE TO CAUSE PHYSICAL CALLI'S
;CALL:	PUSHJ	P,DOPH
;	CALLI TO EXECUTE
;CALLI WILL BE MODIFIED TO PHYSICAL IF IMPLEMENTED
;USES X, T

DOPH:	MOVSI	T,'DSK'		;DOPHYSICAL DSKCHR ON DSK
	MOVEI	X,T		;ARGUMENT LIST
	DSKCHR	X,1B19		;DO PHYSICAL DSKCHR TO SEEIF PHYSICAL IMPLEMENTED
	  TDZA	X,X		;NO, DSKCHR OF DSK ALWAYS WORKS
	MOVEI	X,1B19		;YES, CAN DO PHYSICAL ONLY UUO
	IORM	X,@(P)		;YES--ADD PHYS BIT
	POPJ	P,		;RETURN
;HERE WHEN USER TYPES ^C .START OR .REENTER WHEN WRONG SEGMENT IN

FAKREN:!TDZA	A,A		;REENTER IS 0 BACK
FAKSA:!	MOVNI	A,1		;START IS 1 BACK
RR4:!	MOVEI	R,.-.		;RESTORE RELOCATION
	MOVE	P,STARTP(R)	;RESTORE PUSH-DOWN POINTER
	ADDI	A,(P)		;GET LOCATION OF REAL RETURN POINT
	MOVE	A,(A)		;GET REAL RETURN ADDRESS
	MOVEM	A,RETRNP(R)	;PLACEIN RETURN SAVE POINT
	JRST	RESTOR(R)	;RESTORE HI-SEG

LENLCD:!		;LENGTH OF CODE IN LOW SEG
	DEPHASE


;STORAGE

	LOC	LENLCD		;PLACE AFTER CODE IN LOW SEG

SAVDEV:!BLOCK	1	;ORIGINAL HISEG DEVICE
SAVDIR:!BLOCK	1	;ORIGINAL HISEG DIRECTORY
SAVNAM:!BLOCK	1	;ORIGINAL HISEG FILE NAME
SAVEP:!	BLOCK	1	;TO STORE P AROUND GETSEGS
STARTP:!BLOCK	1	;TO STORE P FOR START COMMAND
RETRNP:!BLOCK	1	;TO STORE RETURN POINT SO IT IS EASY TO ALTER
SAVUWP:!BLOCK	1		;SAVE UWP BIT HERE
PDL:!	BLOCK	LN.PDL+2	;PUSH-DOWN LIST AREA

LENLOW:!		;LENGTH OF LOW CORE


	END		;NO START ADDRESS
