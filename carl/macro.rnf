.title MACRO.DOC -- Changes from MACRO 46(52) to MACRO 53B(1155)
.subtitle Tymshare, Inc. -- March 1982
.flag capital
.outline Alpha,decimal,lalpha,lroman,decimal,Lalpha
.first title
.spacing 1
.lm 0.rm 72

.hl 1 GENERAL INFORMATION - MACRO.DOC AND MACRO.INF
.paragraph
This file, MACRO.INF, is all of the external changes from MACRO 46(52) to
MACRO 53B(1155).
.paragraph
The file, MACRO.DOC, is internal documentation for the changes from MACRO
46(52) to MACRO 53B(1155A).  This includes known bugs and deficiencies, with
solutions or examples of work arounds for some problems.
.paragraph
NOTE: The changes in this version of macro are to match changes in DEC's
macros.  The Macro Assembler Reference Manual can be ordered from DEC (order
number AA-4159C-TM, or AA-C780C-TB).
.s3
.hl 1 SUMMARY
MCR47.DOC -- Changes from MACRO 46(52) to MACRO 47(113) Dec, 1971
.br
Macro version 47 is version 46 with edits _#53 through _#113.
This version has no known deficiencies  and  fully  replaces
version 46.
.s1
MCR50.DOC -- Changes from MACRO 47(113) to MACRO 50(272) Oct, 1974
.br
Macro version 50 is version 47 with edits _#114 through _#272 inclusive.
This version has no new deficiencies and fully replaces version 47.
.s1
MCR50A.DOC -- Changes from MACRO %50(272) to MACRO %50A(432) August 1976
.br
The purpose for this release is to consolidate enhancements and bug
fixes made since the last release.  This release includes 80 seperate
changes to MACRO.  Version 50A has been successfully tested in-house
and at several field-test sites.
.bl 1
No major new features have been implemented.  New arguments to the
_.DIRECTIVE pseudo-op have been added, and are discussed in elsewhere
in this document. KL10 opcodes and extended opcodes have been
implemented in this release, and the values for CALLIs through 162
have been added to bring MACRO into sync with DEC's 6.02 monitor
release.
.bl 1
There is no problem in converting to the new version.  However, this
release implements version 5 universal files, which are not
downwardly compatible with version 4.  In certain instances, the user
will be asked by MACRO to recompile existing universal files.  Under
version 5, default arguments are saved in binary universals.
.s1
Version 50A fully supersedes all previous versions, and includes
edits _#373 to _#432, excluding edits _#300 to _#317, which were used
for a special TOPS-20 version of MACRO (identified as MACRO 51).
.s1
MCR52.DOC -- Changes from V50A(432) to V52(551) February 1977
.br
The purpose for this release is to produce a single version of MACRO
for both the DECSYSTEM-20 and DECSYSTEM-10 by merging versions 51
(from TOPS-20) and 50A (from TOPS-10).  The single version of MACRO
will reduce the current support exposure.  The functional goals for
MACRO V52 are as follows:
.list
.le;Enhance MACRO processing capabilities
.le;Fix bugs
.le;Provide a single basis for coherent future development.
.le;Support use of external symbols in arbitrary expressions.
.els
.b1.lm0
Version 52 fully supersedes all previous versions, and includes edits
up to _#551.
.b2.c
***WARNING***
.b1
MACRO V52 requires that the REL files it generates be loaded with
LINK V3A, which supports the POLISH fixup capability with one
patch required.
.s1
MCR53.DOC -- Changes from V52(551) to V53(1020) March 1978
.br
The purpose of this release is to provide a software
multiple-segmentation (PSECT) facility.
.bl
Version 53 fully supersedes all previous versions, and includes edits
up to _#1020.  If PSECTS are used, the resultant .REL files be loaded
with LINK V4, which fully supports the PSECT facility.
.bl
MCR53A.DOC -- Changes from V53(1020) to V53A(1152) August 1979
The purpose of this release is to provide a more reliable version of
the product.
.bl
MACRO version 53A includes edits up to _#1152.  If PSECTS are used,
the resultant .REL files must be loaded with LINK V4 or later
versions, which support the PSECT facility.
.bl
For TOPS-10 systems, MACRO is documented in the DECsystem-10 User's
Guide, and in the DECsystem-10 MACRO Assembler Reference Manual,
order number AA-C780C-TB.
.bl
For TOPS-20 systems, MACRO is documented in the TOPS-20 User's Guide,
and in the DECSYSTEM-20 MACRO Assembler Reference Manual, order
number AA-4159C-TM.

.page
.hl 1 External changes

.hl 2 Version 47
.list
.le;Add new CALLIs _#111 thru _#120.
.le;Turn on KI-10 opcodes by default so that KI-10 opcodes are
generated whenever possible.
.le;Allow a user to save the current MACRO core image after UNIVERSAL
files have been assembled by re-starting MACRO at the REENTER
address.  A new switch /U clears the universal area and setsts the
starting address.
.le;Add new suffixes K, M and G after numbers to designate 1000*n,
1000000*n and 1000000000*n.
.le;Add MTAPE UUO mnemonics as well as CALLIs and TTCALLs.
.le;Implement the ARRAY and INTEGER pseudo-ops as standard.
INTEGER allocates a single word of storage per variable, and ARRAY
allocates as many words as specified by ARRAY FOO[n] where n is an
integer number.
.le;The program break may be larger if a LIT pseudo-op is given just
before the END statement (so literals are printed), than if no LIT is
given.
.s1
NOTE:  PRGEND cannot be used in macros which intend to continue over
the PRGEND.
.els

.page
.hl 2 Version 50
.list
.le;Implement binary UNIVERSAL files.  That is, write file.UNV which
contains definitions, opdefs, and macro definitions in a form which
can be read directly into memory rather than re-assembling the specified
UNIVERSAL file.
Change (Add?) /U which prevents writing over an existing UNV file
thus allowing new versions to be tested without overwriting the old
version.
.le;Add pseudo-ops _.REQUEST and _.REQUIRE which generate the SAIL block
types 16 and 17.  Syntax for both is:
.s1.i 4;_.REQUEST DEV:FILE[PPN]
.s1
where the only legal extension is _.REL and [PPN] is optional. The
only difference between the two pseudo-ops is that _.REQUEST loads
the file in library search mode, while _.REQUIRE does not.
.le;Add the operators _^! and _^- to mean logical XOR and logical NOT.
.le;Add global symbol _.CPU.# which is put in the user's symbol table
with a value which reflects the CPU type that MACRO is running on.
This value may be tested with IFN's etc, and the values are:
.s1.i4;#1 = PDP-6, #2 = KA-10, #3 = KI-10

.le;Make the location counter on the listing file show the PHASED
location on a PHASE pseudo-op rather than the current location.
This is the location of where the code should be when it is executed.
.le;Add the FAIL-compatible pseudo-ops LINK, LNKEND and ORG.
However, since all new pseudo-ops begin with "_." these are _.LINK,
_.LNKEND and _.ORG.  _.LINK and _.LNKEND (used to be _.ELINK) will
generate link block type 12 code.  _.ORG is similar to LOC and RELOC.
.le;Add the pseudo-op _.DIRECTIVE which takes a list of new pseudo-ops
which need no arguments.  See the MACRO manual for more information.
.le;Add switch /nnL to define the page size for the listing file.
.le;Add _.TEXT pseudo-op to generate ASCIZ block type for LINK-10.
.le;Enhance the SEARCH statement to allow the expanded syntax:
"SEARCH FOO(DSKB:BAR.ABC[123,456,SFD,LIST])" to first look in memory
for the UNIVERSAL then, to look on device DSKB: [123,456,SFD,LIST]
for the file named BAR.ABC and copy it into core with the UNIVERSAL
name FOO.  The default file specification is "DSK:xxxxxx.UNV" where
xxxxxx is the UNIVERSAL name.
.le;The .DIRECTIVE pseudo-op takes KA10 and KI10 as an argument.
These pseudo-ops take as values the types of CPUS that
the produced program can run on.  More than one CPU type can be set
via the .DIRECTIVE.  LINK detects conflicts at load time and reports
them.  The produced CPU type codes are:
.s1;.i 4;KA10=1b5##KI10=2b5
.le;Fix the problem in version 47 so that the LIT statement seen
just before the END or PRGEND statements will now work correctly
and the program break will be correct.
.le;Add the "_.IF conditional", Form is:
.s1.i4;_.IF SYMBOL ATTRIBUTE,_<CODE_>
.s1
where attribute is one of:
.s1.i4;SYMBOL, SYNONYM, MACRO, OPDEF, EXTERNAL, ENTRY,
.i4;INTERNAL, GLOBAL, LOCAL, LABEL, ASSIGNMENT,
.i4;ABSOLUTE, RELOCATEABLE, LRELOCATEABLE(LHS),
.i4;RRELOCATEABLE(RHS), NUMERIC
.els

.page
.hl 2 Version 50A
.list
.le;Two new arguments to the .DIRECTIVE pseudo-op have been added,
_.OKOVL and _.EROVL.  When the condition is _.OKOVL, overflows from
divide and multiply operations are ignored.  When the condition is
_.EROVL, an "N" error is produced on overflow.  Note that although the
code is generated in either case when an overflow occurs, existing
programs that compiled without error before may now produce "N"
errors because _.DIRECTIVE _.EROVL is the default.
.le;A single "!"  (exclamation point) can follow symbol names in
pseudo-ops like INTERN and EXTERN.  The effect is to supress the
symbol to DDT.
.le;The value of the symbol _.CPU.#is now defined for the KL-10 processor.
The values of this built in symbol are:
.s1.i4;PDP6 = 1, KA10 = 2, KI10 = 3, and KL10 = 4
.le;The KL10 opcodes and extended opcodes have been added to the built in
symbols.
.le;The .DIRECTIVE pseudo-op now takes KL10 as an argument, as well as
KA10 and KI10.  These pseudo-ops take as values the types of CPUS that
the produced program can run on.  More than one CPU type can be set
via the .DIRECTIVE.  LINK detects conflicts at load time and reports
them.  The produced CPU type codes are:
.s1;.i4;KA10=1b5##KI10=2b5##KL10=4b5
.le;The values for the CALLIS thru 162 have been added to bring MACRO
into sync with the TOPS-10 6.02 monitor release.  The PORTAL opcode
has also been added.
.le;Two new .DIRECTIVE pseudo-op arguments have been added to facilitate
the development and debugging of new LINK block types.  These two
arguments, under the normally off conditional, "TSTCD", are _.TCDON
and .TCDOFF (Test CoDe ON and Test CoDe OFF).  When a .DIRECTIVE
_.TCDON is seen, the current LINK REL block is closed and a special
flag is set.  From that point on any code that would normally be
placed in a formatted code block (LINK type 1), is put verbatim into
the REL file.  The flag is cleared when a corresponding .DIRECTIVE
_.TCDOFF is seen.  The effect is much like the .TEXT pseudo-op, except
that any number of arbitrary values can be placed in the REL file.
The expressions stowed while between .TCDON and .TCDOFF must be
absolute and not EXTERNAL.
.le;The .DIRECTIVE pseudo-op now accepts NO before an argument, which
functions as a logical not.  NO preceding an argument to the
_.DIRECTIVE operator causes the negative of the action described by
that argument to take place.  If no logical negative action makes
sense, an "A" error is produced.
.els

.page
.hl 2 Version 52
.list
.le;Polish Externals
.br
MACRO generates and passes to LINK Polish fixups for externals
symbols appearing in arbitrary expressions.  These complex expressions
are allowed wherever an external symbol was allowed previously.
.le;_.IFN Pseudo-op added, .IF/.ifn bugs fixed.
.br
General format is:
.b1.i5
_.IF symbol, QUALIFIER, _<conditional assembly>
.b1
where QUALIFIER is one of:
.b1.literal
	SYMNONYM, MACRO, OPDEF, EXTERNAL, ENTRY, INTERNAL,
	GLOBAL, LOCAL, LABEL, ASSIGNMENT, ABSOLUTE, OPCODE,
	RELOCATABLE, LRELOCATABLE, RRELOCATABLE, NUMERIC
.end literal
.b1
Differences from previous version:
.list
.le;There must be a comma "," after the qualifier and before the conditional assembly.
.le;More qualifiers
.le;Unique abbreviation allowed for qualifier.
.els
.le;MACRO call argument handling:
.list
.le;Tabs and spaces before and after each are eliminated unless
within parentheses or angle-brackets.  Directive .ITABM and .XTABM
are used to control the tab/space trimming.
.le;Square-brackets are counted and act as quotation brackets when
not in angle brackets.  Hence the following MACRO call may be
written:
.b1.i4
FOO [MOVE 1,1
.i10
MOVE 2,2]
.b1
also,
.b1.i4
JRST [FOO 123]
.b1
where FOO is a defined MACRO.
.b1
argument list will be terminated on unpaired right parenthesis,
square-bracket, or angle bracket.
.tp 3
.le;_.DIRECTIVE MACMPD (MACRO match paired delimiters) causes the
above described delimiter handling and imply a .XTABM also (.ITABM
has no effect with MACMPD).
.tp 4
.le;_.DIRECTIVE NO MACMPD disables the new delimiter handling.  Both
_.ITABM and _.XTABM may be used with _.DIRECTIVE NO MACMPD.
(_.DIRECTIVE NO MACMPD and .XTABM together correspond to default of
V50 and before).
.b1
Note:##(See a later section for a more detailed write-up on the new
MACRO call handling.)
.els
.le;Use of "NO" on a directive which has no logical negative
produces an error.
.le;Other new directives
.list
.le;_.DIRECTIVE LITLST -- MACRO lists binary in-line for all literals.  the
listing of literals at "LIT" is not affected.
.le;_.DIRECTIVE FLBLST(first-line binary listing) -- causes only the first
binary word to be listed for Pseudo-op (e.g., ASCII) which may
generate many words.  This makes the listing appearance more like the
source and eliminates generally useless octal output.
.le;_.DIRECTIVE MACPRF -- affects assembly when a symbol has both a value
and a MACRO definition.  Normally, the MACRO 1efinition is taken if
the symbol appears in the operator field of a statement, otherwise
the value is taken.  ".DIRECTIVE MACPRF" causes the MACRO definition
to be taken first always.  This is intended to support programs which
use MACRO definitions as variables.  The default setting is "NO
MACPRF", i.e., compatible with MACRO-50 and before.
.le;_.DIRECTIVE SFCOND(suppress failing conditionals) -- when in effect,
this suppresses listing of source lines within assembler conditionals
which fail.  This is intended for use with programs having many
feature test switches and allows listings to be produced which show
only the code actually in use.
.els
.le;The INTERNAL declaration is legal on a symbol declared OPDEF.
.le;Tags within literals now work properly, and any number may be
used.  Tags may also be used with nested literals.  Such tags may be
referenced within the scope of a literal or a group of nested
literals.  However forward references from outside the literal or
another literal may not be made.  Tags defined in a literal, also, may
not appear in any arbitrary arithmetic expression.  MACRO will
interpret them as external symbols instead and a polish fixup is
generated.
.le;The listing output when within literals is generally improved,
e.g., the listing mode (SALL/LALL/XALL) is properly observed.
.le;The general error message of LABEL+n has been improved, where n
is a decimal number representing the offset of lines of code
generated from the given label.
.le;When a symbol normally used as an operator is encountered with
an arithmetical or a logical operator immediately following it
instead of a tab or a space as expected, the symbol is interpreted by
MACRO as a part of an arithmetic or logical expression rather than
as an operator.  The opcode value is used in the evaluation of the
expression.
.le;MACRO'S asterisk-level command scanner has been generally
improved.  Added features are that SFDS are now allowed on output
file specifications, comments are allowed, [P,pn_<CRLF_> no longer
generates a command error, and null extensions are allowed on input
file specifications.
.le;RIM, RIM10 and RIM10B are now cleared at PRGEND.
.le;The "SYN" pseudo-op may be used in a UNV file.
The internal storage of a symbol that is declared to be synonymous to
an operator is changed to keep the sixbit operator name as its value.
.le;New universal file format
.s1.literal
	1st word/   777,,code
	2nd word/   MACRO version #
.end literal.s1
where the code field indicates what type of data is contained in this
UNV file.  It was previously referred as the UNV version#_#, and has
the following bit definitions:
.s1.literal
000001	on, if default arguments specified in MACRO definitions
000002	on, if Polish is included
000004	must be on to be compatible with previous versions
000010	on if new SYN handling in UNV
000020	on if a MACRO version number is written as the second word
.end literal.s1
NOTE:  MACRO V52 will read UNV file generated by all previous
versions of MACRO.  However, a UNV file generated by MACRO#V52(551)
will not be read by previous MACROS.
.le;No check will be made with the types of symbols being PURGED with
"PURGE" pseudo-op.  All specified symbols including undefined and
external will be removed from symbol table without error messages.
.le;The coding format for the MACRO source file MACRO.mac has been
changed to conform to the TOPS20 coding convention.
.els

.hl 3 Suggestions To The Users
.list
.le
Users are warned that they should begin to search UUOSYM in their
MACRO programs, as CALLIs will disappear from MACRO in some future
version.
.le
If you find a working MACRO program no longer assembles with MACRO
V52, and you are getting bizarre errors, such as "No END Statement
Encountered" or a bunch of U- or Q-errors, try the following two
things before anything else:
.list
.le;Put in ".DIRECTIVE NO MACMPD" at the beginning of your program.
This directive tells MACRO to do the old macro-call argument
processing.
.le;Look for "un-quoted", un-matched [,], (,) in a macro call line.
When you find them, quote them with _<#>, or whatever is appropriate.
.els
.els

.page
.hl 2 Version 53
.list
.le;_.PSECT pseudo-op:
.br
The .PSECT pseudo-op  directs  MACRO  to  start  or  continue
placing  code  and/or  data  into  the named program section.
.br;Syntax:
.s1.i4;_.PSECT name, origin
.s1
Where "name" is the name of the program section; name may be any
construction which would be valid as a symbol but will not conflict
with a symbol or macro of the same name.  MACRO will generate a global
symbol having the PSECT name and at load time the symbol will take on
the PSECT origin as its value.
.s1
The origin, if supplied in the program, tells LINK where the PSECT
origin should be.  If not supplied then it must be set by the
/SET:NAME:ORIGIN switch to LINK.  If both are supplwhichever
occurs first is used and cannot be over-ridden by a later
declaration.
.le;_.ENDPS pseudo op:
.br
The .ENDPS pseudo-op directs MACRO to stop placing code and/or data
into the current program section and to start placing it in the
previous (more outer nested) program section.
.br;Syntax:
.s1.i4;_.ENDPS [name]
.s1
The name field is optional and if present will be checked against the
current .PSECT name.  If there is a disagreement, a warning diagnostic
will be issued.  This check cannot be done for the blank .PSECT.
.le;"PSECT" Nesting
.br
_.PSECT and _.ENDPS are essentially brackets which surround the code
and/or data which is to be loaded into the named program section.
These brackets may be nested to a maximum depth which is an assembly
parameter normally set to 16 decimal when the MACRO assembler is
assembled.  Another such assembly parameter within MACRO is the
maximum number of distinct _.PSECT names which may occur within a
single assembly; it is normally set to 64 decimal.
.le;Restrictions
.list
.le;_.PSECT and .ENDPS are not allowed  within  a  "UNIVERSAL"
file.
.le;While MACRO allows a macro and a symbol to have the same
name, this can produce unpredictable results if the two are not in
the same symbol table during an assembly.  This can happen if one is
in a universal symbol table and the other is not, or if the two
appear to be in separate segments.  It is recommended that symbols and
macros of the same name not be employed.  If they are, DEC reserves
the right to change the implementation of the MACRO assembler with
respect to how this situation is treated.
.le;If universal files are
searched while assembling a program with multiple program sections,
symbols within the universal files will appear to be in the blank
program section.  This is particularly relevant to relocatable
symbols.
.le;_.PSECT, HISEG, and TWOSEG are all mutually exclusive.
.le;Literals containing inter-PSECT references will not be collapsed,
therefore if there are two such identical literals, two separate
entries in the literal table will be made.
.le;PRGEND is illegal with .PSECT and MACRO will treat it like END
and the rest of the file will be truncated.
.els
.le;New Error Messages:
.list
.le;"S" Errors:
.i4;Attempt to nest .PSECTs too deep.
.i4;Attempt to unnest .PSECTs too far.
.i4;_.PSECT occurs while assembling a universal.
.i4;Too many distinct .PSECT names.
.i4;Attempt to mix .PSECT with HISEG/TWOSEG.

.le;"Q" Warning (additional):
.i4;_.ENDPS specifies the wrong name.
.i4;_.PSECT specifies conflicting attributes.
.i4;_.PSECT specifies unknown attributes.
.le;New MCR error messages:
.i4;MCRSTO -- Search table overflow
.i4;MCRATS -- Argument too small.
.i4;MCRLTL -- Literal too long.
.i4;MCRISD -- Illegal syntax in DEFINE.
.i4;MCRISR -- Illegal syntax in REPEAT.
.i4;MCRISC -- Illegal syntax in conditional.
.i4;MCRISI -- Illegal syntax in IRP or IRPC or REPEAT.
.els
.le;_.IF ARG,REFERENCED,< ....  >
.br
The code will be assembled if arg is in the symbol table.
.le;_.IF ARG,NEEDED,< ....  >
.br
The code will be assembled if arg is in the symbol table and its
value is undefined.
.le;Alternate Interpretations of MACRO Arguments
The normal argument passed by a  macro  call  is  simply  the
string of characters given with the call.  MACRO offers three
alternate interpretations of the passed argument.
.list
.le;If you prefix a backslash-quotemark (\") to an argument,  the
argument  is expected to have a value of a ASCII string.  The
ASCII string value is passed.
.le;If you prefix a backslash-apostrophe (\') to an argument, the
argument is expected to have a value of a SIXBIT string.  The
ASCII representation of that SIXBIT value is passed.
.le;If you prefix a backslash (\) to an argument, MACRO expects a
numerical  value  and  the ASCII string representation of the
value is passed.
.els
.lm -8
.tp 13
.s1.literal
        LALL
        DEFINE LOOKIE(STR,ARG)< 
                REMARK  The passed argument is:  ARG
                REMARK  build a new string:     str'arg >

;Example of prefixing argument with \"
CASE1:  VALUE="XIT"
        LOOKIE  <?ERROR IN LINK MODULE LNK>,VALUE^
                REMARK  The passed argument is: VALUE
                REMARK  build a new string:     ?ERROR IN LINK MODULE LNKVALUE ^
CASE1A:  LOOKIE <?ERROR IN LINK MODULE LNK>,\"VALUE^
                REMARK  The passed argument is: XIT
                REMARK  build a new string:     ?ERROR IN LINK MODULE LNKXIT
.end literal
.tp 21
.s1.literal
;Example of prefixing argument with \'
CASE2:  VALUE='A'
        LOOKIE  DSK,VALUE^
                REMARK  The passed argument is: VALUE
                REMARK  build a new string:     DSKVALUE      ^
CASE2A: REPEAT  3,<
        LOOKIE  DSK,\'VALUE
                VALUE=VALUE+1>
        LOOKIE  DSK,\'VALUE^
                REMARK  The passed argument is: A
                REMARK  build a new string:     DSKA    ^
                VALUE=VALUE+1
        LOOKIE  DSK,\'VALUE^
                REMARK  The passed argument is: B
                REMARK  build a new string:     DSKB    ^
                VALUE=VALUE+1
        LOOKIE  DSK,\'VALUE^
                REMARK  The passed argument is: C
                REMARK  build a new string:     DSKC    ^
                VALUE=VALUE+1
.end literal
.tp 21
.s1.literal
;Example of prefixing actual argument with \
CASE3:  VALUE=0
        LOOKIE LPT,value+1>^
                REMARK  The passed argument is:  VALUE+1
                REMARK  build a new string:     LPTVALUE+1
CASE3A: REPEAT 3,<
        LOOKIE  LPT,\<VALUE+1>
                VALUE=VALUE+1>
        LOOKIE  LPT,\<VALUE+1>^
                REMARK  The passed argument is: 1
                REMARK  build a new string:     LPT1    ^
                VALUE=VALUE+1
        LOOKIE  LPT,\<VALUE+1>^
                REMARK  The passed argument is: 2
                REMARK  build a new string:     LPT2    ^
                VALUE=VALUE+1
        LOOKIE  LPT,\<VALUE+1>^
                REMARK  The passed argument is: 3
                REMARK  build a new string:     LPT3    ^
                VALUE=VALUE+1
.end literal
.lm +8
.le;Polish bugs fixed in the following areas:
.i4;_<XWD POL,POL_> or _<POL,,_POL>
.i4;_<IOWD POL_>
.i4;_<-POL_>
.i4;-EXP where EXP is a relocatable expression
.i4;@POL(AC)
.i4;OPDEF FOO [ POL ]
.i4;Generate full word fixup for FOO##
.tp 8
.le;Polish listing format -- A number sign (#) in the listing
indicates that a Polish expression is required to resolve the
expression.  For example:
.s1.literal
561  02  000  000000#      ;requires right half Polish fixup
000000000000#              ;requires full word Polish fixup
000000# 000002             ;requires left half Polish fixup
.end literal.
.tp 18
.le;PSECT index in listing -- PSECT index is output at the end of
relocation counter value in the listing, see example below:
.s1.literal
5176  005656'02 201 03 0 02 000000          MOVEI   T3,.NDNOD(T2) 
5177  005657'02 561 02 0 00 000000#         HRROI   T2,OURNAM-1   
5178  005660'02 260 17 0 00 000000*         CALL    CPYTU1        
5179  005661'02 254 00 0 00 005653*         RETSKP                
5180
5181                                        TNXEND
5182                                        END
PROGRAM BREAK IS 000000
PSECT 1 BREAK IS 000534 FOR RSCOD
PSECT 2 BREAK IS 007036 FOR NRCOD
PSECT 3 BREAK IS 000066 FOR BGSTR
PSECT 4 BREAK IS 000011 FOR BGPTR
CPU TIME USED 02:28.153
98P CORE USED
.end literal

.tp 20
.le;Polish not allowed with RELOC & BLOCK & Conditionals
.le;KL instructions have been updated:
.s1.literal
		   JRST and JFCL Mnemonics
		   -----------------------
 254 04 0 00 000000      HALT     254 04 0 00 000000    JRST 4,
 255 06 0 00 000000      JCRY     255 06 0 00 000000    JFCL 6,
 255 04 0 00 000000      JCRY0    255 04 0 00 000000    JFCL 4,
 255 02 0 00 000000      JCRY1    255 02 0 00 000000    JFCL 2,
 254 12 0 00 000000      JEN      254 12 0 00 000000    JRST 12,
 255 01 0 00 000000      JFOV     255 01 0 00 000000    JFCL 1,
 255 10 0 00 000000      JOV      255 10 0 00 000000    JFCL 10,
 254 02 0 00 000000      JRSTF    254 02 0 00 000000    JRST 2,
 254 01 0 00 000000      PORTAL   254 01 0 00 000000    JRST 1,
 254 06 0 00 000000      XJEN     254 06 0 00 000000    JRST 6,
 254 05 0 00 000000      XJRSTF   254 05 0 00 000000    JRST 5,
 254 07 0 00 000000      XPCW     254 07 0 00 000000    JRST 7,
 254 14 0 00 000000      XSFM     254 14 0 00 000000    JRST 14,
.end literal.
.tp 12
.s1.literal
	      KL10 EXTEND Instruction Mnemonics
	      ---------------------------------
 002 00 0 00 000000      CMPSE    010 00 0 00 000000     CVTDBO
 007 00 0 00 000000      CMPSG    011 00 0 00 000000     CVTDBT
 005 00 0 00 000000      CMPSGE   004 00 0 00 000000     EDIT
 001 00 0 00 000000      CMPSL    016 00 0 00 000000     MOVSLJ
 003 00 0 00 000000      CMPSLE   014 00 0 00 000000     MOVSO
 006 00 0 00 000000      CMPSN    017 00 0 00 000000     MOVSRJ
 012 00 0 00 000000      CVTBDO   015 00 0 00 000000     MOVST
 013 00 0 00 000000      CVTDBT   020 00 0 00 000000     XBLT
.end literal
.le;Tags defined in a literal -- Tags in literals may be referenced
anywhere from the program with the following restrictions:
.list
.br;May NOT be used in an arbitrary expression.
.br;May NOT be referenced from another PSECT.
.els

.le;Code Generation Changes -- The descriptions of the block types
24,23, and  22  supercede the descriptions in the LINK manual.
.list
.le;BLOCK 24  -- MACRO generates a  set  of  block  24's  at  the
beginning of the Rel file for each PSECT in this assembly.  A
type 24 contains three data words -- a PSECT name in  SIXBIT,
its  attributes  (right  half) and its index (left half), and
its origin.  A block 24 establishes a PSECT and associates it
with  an  index number so that block 22's and block 11's that
follow may reference PSECTs by the PSECT index number.
.le;BLOCK 22 -- Interspersed with the type 1  and  type  2  codes
there  are  type  22  codes.   A  type 22 directs the linking
loader to place subsequent type 1 and type 2 information into
the  named  .PSECT.   A  type 22 will also precede the type 7
block if one occurs and other type 22s have been emitted.   A
type 22 contains only one data word which is the PSECT index.
.le;BLOCK 23 -- MACRO generates a set of block 23's for  all  the
PSECTs  at  the end.  A type 23 contains two data words.  The
first is a .PSECT name in SIXBIT.  The  second  contains  the
_.PSECT break.
.le;BLOCK 11 -- There is an additional type of Polish fixup which
occurs  for  assemblies with multiple .PSECTs.  With multiple
_.PSECTs, it is necessary to  distinguish  among  the  .PSECTs
within  the  fixups  in  order  that  relocation  will  occur
properly.  Halfword PSECT  index  of  the  form  400000+(n-1)
indicates  next  relocatable  address is to be relocated with
respect to the PSECT which is  named  by  the  n'th  type  23
block.   The  very  first PSECT index in block 11 defines the
current PSECT  and  the  relocation  counter  for  the  store
address.  Any relocatable operand with a different relocation
counter must be preceded by the proper PSECT index.
.le;BLOCK 10 -- Forward references of a tag defined in a  LITERAL
are  chained similarly to that of an external chain.  A block
10 is generated containing the value of the tag and the start
of  the  chain.  A separate chain is generated for each PSECT
just as a separate external chain is generated for PSECT.
.els
.le;Better RELOC,LOC, .ORG interactions
.le;Add _.NODDT pseudo-op -- Suppress DDT and part of symbol names
.le;REL files generated by  MACRO  V52  and  MACRO  V53  may  not
compare with FILCOM.
.le;Universals are not searched when processing  label,  _#_#,  END
statement  and  the  following  pseudo-ops:   EXTERN,  OPDEF,
_.ASSIGN, SYN, INTEGER, ARRAY,  _.COMMON,  DEFINE.   Pseudo-ops
INTERN  and ENTRY will still search universals since they are
not truely defining occurrences.
.le;OPDEF's may be declared INTERNAL only if no label of the same
name exists.
.le;LABEL+OFFSET error reporting is now entirely source-oriented.
Specifically,  blank  lines  are reflected in the offset, and
MACRO/REPEAT expansion lines are not.
.els
.page
.hl 2 Version 53A
.list
.le;BYTE pseudo-op:
.br
Externals must be loaded into either  fullword  (36  bit)  or
halfword  (18  bit)  bytes.  Relocatables must be loaded into
fullword or halfword bytes, with the exception that  a  right
half  only  relocatable  can be loaded into a right justified
byte that is between 18 and 36 bits in length.  Examples:
.s1.literal
                BYTE (18) REL1, REL2 (6) 3 (30) RHREL3
                BYTE (10) 5 (26) RHREL4
.end literal
.le;Unary operators:
.br
Unary operators now properly take precedence over all  binary
and  shift  operators.   This  conflicts  with  the  existing
documentation.  The hierarchy is now as follows:
.list
.le;All unary operators
.br;(+, -, _^-, _^D, _^O, _^B, _^F, _^L, E,  K, M, G)
.le;Shift operators (B-shift, underscore-shift)
.le;Logical binary operators (!, _^!, _&)
.le;Multiplicative operators (*, /)
.le;Additive operators (+, -)
.els
.le;Error message standard:
.br
On TOPS-10 systems, MACRO will now observe the setting of the
message  level  bits  during error message typeout (reference
monitor GETTAB table .GTWCH(35)).
.le;Macro call statements and XALL
.br
MACRO will now list the entire statement  in  which  a  macro
call appears if XALL is in effect.  This may cause the source
line to be broken up in the listing if multiple  macro  calls
appear  on the same line, and the called macros have imbedded
line terminators.  Comments on macro  calls  imbedded  within
conditionals  will also be listed, with the comment appearing
along with the last line of the macro expansion, even  if  no
code is generated for that line.
.le;_.IF/_.IFN pseudo-ops
.br
Contrary to what the documentation states, the .IF and .IFN
pseudo-ops were never intended to take angle-bracketed expressions as
arguments.  Instead, they are intended to provide a powerful mechanism
for querying symbol table attributes, given a valid mnemonic
consisting of up to six RADIX50 characters.  The newly defined
attribute, "NAME", can be used to determine if the argument is a
single RADIX50 symbol name.  Such a symbol may be enclosed in angle
brackets, nested to any depth.  The use of angle-bracketed expressions
is allowed, and treated as decribed below, however their use is not
recommended.
.s1
Limited expression handling has been implemented to handle situations
in which angle-bracketed expressions are used as arguments.  Such an
argument will return the combined (IORed) attributes of its
components, except in the case of relocation attributes, which are
handled correctly only for a symbol.  In addition, an angle-bracketed
expression will have the newly defined attribute "EXPRESSION",
providing a means of defending against angle-bracketed expressions
passed as arguments to macro calls.  Note that all arguments that work
outside angle brackets will work inside them.
.le;Psects and literals
.br
Proper termination of literals within code bounded by _.PSECT/.ENDPS
is now enforced.  Early termination of a literal which was started in
the same PSECT but at a higher level (due to nesting), or the failure
to terminate a literal which was started in the current PSECT will
produce an L error, and will generate the new MCRLNI Literal nesting
incorrect message.
.le;Suppressed symbols
.br
Symbols declared as suppressed internal, but defined by externals or
Polish will now retain the suppressed attribute and will not be typed
out by DDT.
.le;PSECT attributes
.br
Valid PSECT attributes and their definitions are as follows:
.s1.literal
CONCATENATED	When  loading  multiple  modules,  all   PSECT
		blocks   having   the   same   name   will  be
		concatenated at load time.
OVERLAID	When  loading  multiple  modules,  all   PSECT
		blocks  having  the  same  name will be loaded
		starting at the same  origin  (each  one  will
		'overlay' the previous one).
RWRITE		The PSECT can be  read  and  written  (TOPS-20
		only).
RONLY		The PSECT can only be read (TOPS-20 only).
PALIGNED	When  loading  relocatable  PSECTs  (not   yet
		supported),  the  PSECT origin will be started
		at a page boundary.
.end literal
.le;PSECTs and PRGEND
.br
PRGENDs can now occur in a source file containing PSECTs.
.le;Assembler typeout for PRGENDed programs
.br
When MACRO is executed via a RUN command, and the listing device is
not the terminal, the informational messages (BREAK, CPU TIME, CORE
USED, etc...), will be typed out for each program module in a
PRGENDed source file.  The particular program module will be
identified by a line following the error counts, indicating "PROGRAM
XXXX", where "XXXX" is the information appearing on the TITLE
statement for the module.  If no TITLE is specified, the default
TITLE, ".MAIN" will be typed.  The program identification line will no
longer be output to the listing file, however, it will now appear
with the errors typed out when MACRO is invoked via the CCL entry
point, as done by the COMPIL class commands under TOPS-10.

.le;New Error Messages:
.list
.le;"Q" errors:
.i4;@ appearing in or before AC field
.i4;Index value has left half for POLISH(INDEX)
.i4;BYTE (n) RELOCATBLE where n is not 36 or halfword 18
.i4;@ in unbracketed expression to DEC/EXP/OCT
.i4;Multiple  TITLEs  or  TITLE/UNIVERSAL  conflicts ("M")
.le;"E" errors:
.i4;BYTE (n) EXTERNAL where n is not 36 or halfword 18
.i4;BYTE (n) POLISH symbol where n is not 36 or halfword 18
.i4;EXTERN/INTERN conflicts
.le;"X" errors:
.i4;Created symbol exceeds ..7777
.le;"A" errors:
.i4;OPDEF produces no code
.i4;PSECT origin not absolute
.le;"L" errors:
.i4;PSECT literal level mismatch
.i4;Assignment involves a label defined within a literal
.le;New MCR error messages:
.i4;MCRLNI -- Literal  nesting  incorrect  at  end  of  PSECT
.le;Modified MCR error messages:
.i4;MCRPTC -- Polish too complex for location nnnnnn
.i4;MCRPTC -- Polish too complex for symbol XXXXXX
.le;Deleted MCR error messages:
.i4;MCRPIP -- PRGEND illegal with PSECT
.els
.tp 20
.le;Polish bugs fixed in the following areas:
.list
.le;_<POINT K,POLISH_>
.le;_<POLISH_>B_<EXP_>
.le;Polish imbedded within a polish expression such as:
.i4;A_#_#+B_#_#+_<C_#_#+D_#_#_>
.i4;_<EXT_#_#,,POLISH_>
.i4;_<EXT_#_#+1,,0_>
.i4;POLISH(INDEX)
.i4;OP AC,ADDR(POLISH)
.i4;OP AC,-_<POLISH_>
.i4;OP AC,POLISH(LH,,RH)
.le;Generate fullword fixups only for externals such as:
.i4;0,,EXT_#_#
.le;Simplex forward references to Polish such as:
.i4;EXP POLISH
.i4;POLISH=EXT_#_#+K
.le;Generate Polish when needed when A or B is relocatable for
expressions such as:
.i4;A+B or A-B
.le;Generate proper polish when referencing  relocatables  across
PSECTs
.els
.els

.page
.end outline
.outline Roman,Alpha,Decimal,lalpha,lroman
.title New MACRO CALL argument handling -- MACRO Version 52 and later
.hl 1 GENERAL FORMAT
A MACRO Call has the general format:
.s1.literal
	(1)##NAME ARG1,ARG2,etc.
		or
	(2)##NAME (ARG1,ARG2,etc.)
.end literal
where:
.lm +10
.b1.i-10;NAME	is the name of the MACRO being called
.b1.i-10;ARG1, ARG2, etc.
.br;is the argument list.  The arguments in the argument list are
separated by commas.  The argument list is terminated by a CR-lf or a
semicolon in form (1) and close parenthesis, ")", in form (2)
.b1.i-10;Example:
.b1.literal
	FOO A,B,C	FOO has 3 ARGS:	A
					B
					C
.end literal.s1
.lm -10
Note:##FOO is assumed to be defined as a MACRO and is used throughout
in the remainder of this write-up.
.page

.hl 1 SPECIAL CHARACTERS
.list
.le;THIS DISCUSSION APPLIES TO FORM 1 ONLY.
The following characters have special meanings when they appear in
the MACRO Call line, unless they are "QUOTED" by the Special Quoting
Characters.  This rule also applies to quoting characters themselves.
.s1.literal
	Comma ","	Delimits an argument
	CR-lf		Terminates an argument list
	Semi-colon ";"	Terminates an argument list and
			starts the comment
.end literal.s1
Special Quoting Characters:
.s1.literal
	< >	Angle Brackets
	( )	Parenthesis
	[ ]	Square Brackets
	" "	Quote Marks
.end literal.s1
Note:##Single-Quotes are not special quoting characters.
.list
.le
The Special Quoting Characters do not delimit arguments.  Their
function is merely to tell the MACRO assembler to treat all
characters enclosed as regular characters.
.le
The Special Quoting Characters are always part of the
argument except for the following exception:
.list
.i-4;_<###If an _< is encountered as the first character (including
spaces) of the argument list or as the first character after an
unquoted Comma _<#> are treated as quoting characters, but they are
not included as part of the argument.
.els
.els

.le;FORM 2
.b1
In form 2, the outermost (#) are not quoting characters.  They are
argument list designators.  If this form is used, the only special
quoting characters are angle brackets, _<#>.  They followed the
exception rule described in 1.2.  Handling of Form 2 has not changed
from the previous version of MACRO.  Most of the examples given in the
remaining of this discussion will be using Form 1.
.page

.le;Why the new FORM 1 handling?
.b1
Prior to Version 52, the only quoting characters were _<#>.  By making
_<#>, [#], (#), and "#", quoting characters, we now can write:
.s1.literal
	FOO <[MOVE  1,1			FOO  [MOVE  1,1
	      MOVE#2,2]>	as	      MOVE#2,2]

	FOO <",">		as	FOO  ","

	FOO <A,<Z B>>		as	FOO  A,<Z B>
.end literal.s1

This way, we don't need to write the outermost _<#>.  A MACRO CALL
looks more like an instruction.  However, when we want the quoting
characters to be treated as regular characters, they must be quoted
by a pair of different quoting characters.
.els

.hl 1 OTHER RULES FOR FORM 1
.list
.le;Nesting
.i4;Only another _<#> may be nested in a _<#>.
.i4;Only another [#] may be nested in a [#].
.i4;Only another (#) may be nested in a (#).
.i4;No nesting with Quote-marks.
.le;All leading and trailing spaces and tabs for each argument are ignored unless "Quoted".
.le;An unmatched >, ), ], terminates the argument list.
.els
.page

.hl 1 Examples of using special quoting chracters:
.list
.le;When you want commas, semi-colons, and CR-LF to be treated as
regular characters:
.s1.literal
FOO  <A,B>,C	FOO has 2 args:	A,B
				C
.end literal.s1
The comma quoted by _<#> is treated as a regular character.  Because
_< is the first character, the first arg is "A,B" not "_<A,B>".  _<#>
are not part of arg.
.s1.literal
FOO  C,<A,B>	FOO has 2 args:	C
				A,B
.end literal.s1
_<#> are not part of 2nd arg, since _< is the first character after
an unquoted comma.
.s1.literal
FOO  C<A,B>	FOO has 1 arg:	C<A,B>
		< > are part of the argument.

FOO  <THIS	FOO has 1 arg:	All the characters in
      IS A			between < and > including
      MULTI-LINE		spaces and CR-LFs.
      TEXT ARGUMENT>	< > are not part of arg.
.end literal

.le;When you want a special quoting character to be treated as
a regular character:
.s1.literal
FOO  <ASCIZ /[ IS	FOO has 1 arg:	All the characters in
	 PART OF			between < > including
	  THE TEXT/>			[.
			< > are not part of arg.

FOO  [MOVE A,1(B)	FOO has 1 arg:	[...]
      JRST XYZ]		( ) are treated as regular characters.
			[ ] are part of arg.

FOO  "["		FOO has 1 arg:	"["
			[ is treated as a regular character.
			" " ARE PART OF ARG

FOO  <">		FOO has 1 arg:	"
			" is treated as a regular character.
			< > are not part of the arg.
.end literal.s1
.Page

.le;Examples with (...)
.s1.literal
FOO (A,B,C)	FOO HAS 3 ARGS:	A
				B
				C
.end literal.s1
Form 2 is used here.  (#) designates the ARG list and the
Commas delimite the arguments.  This case is same as FOO A,B,C
.s1.literal
FOO  A,(B,C)	FOO has 2 args:	A
				(B,C)
		( ) are part of the arg because "("
		    was not the first character.

FOO TABLE-1(AC)	FOO has 1 arg:	TABLE-1(AC)
		( ) are part of arg.

FOO (?LENGTH >132)	FOO HAS 1 ARG:	All the characters in
					between ( ) including ">".
			( ) are not part of the arg.
.end literal.s1

.le;Examples with _<...>
.s1.literal
FOO  <A,B,C>	FOO has 1 arg:	A,B,C
		< > are not part of arg because
		"<" is the first character.

FOO  A,<B,C>	FOO has 2 args:	A
				<B,C>
		< > are part of arg because
		"<" was not the first character.

FOO <<POINT 7,0>>	FOO has 1 arg:	<POINT 7,0>
			The outer < >  are not part of arg.
.end literal.s1

.le;Examples with [...]
.s1.literal
FOO  [XWD 1,L1		FOO has 1 arg:	[...]-1(AC)
      XWD 2,L2]-1(AC)	[ ],( ) are all part of arg.
.end literal.s1

.le;Examples with "..."
.s1.literal
FOO  "(",0	FOO has 2 args:	"("
				 0
		" " ARE PART OF ARG

FOO  "THIS	FOO has 1 arg:	All the characters enclosed
      IS A			by " " including the " "
      MULTI-LINE		themselves.a
      TEXT ARGUMENT"
.end literal
.els
   +@x³