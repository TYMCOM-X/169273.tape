
TITLE MACRO %52(551)  8-NOV-1976
SUBTTL EDIT BY M.CHEN	28-JAN-77

;COPYRIGHT 1968,1969,1970,1971,1972,1973,1974,1975,1976,1977
;  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

	VMACRO==52		;VERSION NUMBER
	VUPDATE==0		;DEC UPDATE LEVEL
	VEDIT==551		;EDIT NUMBER
	VCUSTOM==0		;NON-DEC UPDATE LEVEL


	LOC <.JBVER==137>
	<VCUSTOM>B2+<VMACRO>B11+<VUPDATE>B17+VEDIT
	RELOC

COMMENT * ASSEMBLY FEATURE SWITCHES (ACTION WHEN NON-ZERO)

	SWITCHES ON (NON-ZERO) IN DEC VERSION
PURESW		GIVES TWO SEGMENT MACRO
CCLSW		GIVES RAPID PROGRAM GENERATION FEATURE
TEMP		TMPCOR UUO IS TO BE USED
FORMSW		USE MORE READABLE FORMATS FOR LISTING (ICCSW)
DFRMSW		DEFAULT CONDITION OF FORMAT PRINTING (MULTI-FORM IF ON)
KI10		GIVES KI10 OP-CODES
KL10		GIVES KL10 OP-CODES
POLISH		GIVES EXTERNAL ARITHMETIC EXPRESSIONS
		AND PSECT MULTIPLE RELOCATION COUNTERS

	SWITCHES OFF (ZERO) IN DEC VERSION
FTPSEC		GIVES .PSECT PSEUDO-OPS
STANSW		GIVES STANFORD FEATURES
LNSSW		GIVES LNS VERSION
IIISW		GIVES III FEATURES
OPHSH		GIVES HASH SEARCH OF OPCODES
F40		GIVES F40 UUOS
TOPS20		PROCESSES LONG FILES, REMOVES TOPS10 SYMBOLS
TSTCD		GIVES LINK DEBUGGING SAND DEVELOPMENT DIRECTIVES

	OTHER SWITCHES
UUOSYM		DEFINES TOPS10 UUO'S, CALLI'S, TTCALL'S
*

SUBTTL DEFAULT ASSEMBLY SWITCH SETTINGS

   IFNDEF PURESW,<PURESW==1>

   IFNDEF STANSW,<STANSW==0>
   IFN STANSW,<CCLSW==1>

   IFNDEF LNSSW,<LNSSW==0>

   IFNDEF CCLSW,<CCLSW==1>

   IFNDEF TEMP,<TEMP==1>


   IFNDEF IIISW,<IIISW==0>
   IFN IIISW,<
   IFNDEF DFRMSW,<DFRMSW==0>>

   IFNDEF DFRMSW,<DFRMSW==1>
   IFN DFRMSW,<FORMSW==1>

   IFNDEF FORMSW,<FORMSW==1>

   IFNDEF OPHSH,<OPHSH==0>

   IFNDEF KI10,<KI10==1>

   IFNDEF POLISH,<POLISH==1>

   IFNDEF KL10,<KL10==1>
   IFN KL10,<KI==1>

   IFNDEF F40,<F40==0>
   IFNDEF TOPS20,<TOPS20==0>
   IFNDEF UUOSYM,<UUOSYM==^-TOPS20>

   IFNDEF FTPSEC,<FTPSEC==0>
   IFN FTPSEC,<POLISH==1>

   IFNDEF TSTCD,<TSTCD==0>

SUBTTL REVISION HISTORY

;START OF 50A
;274	(14734)	FIX PROBLEM WITH .IF CONDITIONALS
;275	(14723)	FIX SPURIOUS MONRET WITH STICKY PPNS
;276	(14811)	CAUSE * AND / TO GIVE N ERRORS WHEN THEY OVERFLOW
;277		ALLOW ALTMODES TO TERMINATE COMMAND STRINGS AGAIN

;EDITS 300 THROUGH 317 WERE USED FOR MACRO 51

;320	(Q3086)	FIX MCRNES MESSAGE IN DEFINE AFTER SIXBIT//
;321	(Q3085)	FIX LITERALS NOT LISTING IN MACROS AND SOME BOGUS V ERRORS WHEN NOT LALL
;322		CHANGE RADIX50 TO GIVE Q ERROR ON CODE NOT 74 BITS
;323	(14943)	FIX TO MAKE EXTERNALS REFERENCED IN UNIVERSALS WORK
;324	(14957)	FIX FOR E ERRORS WHEN OPDEF REFERENCES EXTERNAL OF SAME NAME
;325	(15043)	CHANGE 152 & 176 TO NOT PRINT ANGLE BRACKETS OR 1 ; AFTER ;;
;326	(15218)	CHANGE MCRNEC MESSAGE TO GIVE UP ASSEMBLY
;327		FIX THE CRLF'S WHEN LALL IS USED IN A MACRO UNDER SALL
;330	(15277)	CORRECT VALUE OF SYMBOL .CPU. FOR KA-10
;331	(15279)	CORRECT OUTPUT OF .TEXT BLOCKS GENERATING MORE THAN 18 WORDS
;332		CORRECTION TO 325 WHEN ;;> IS END OF MACRO
;333	(15280)	^ IS SOMETIMES SWALLOWED WHEN NOT FOLLOWED BY ! OR -
;334	(15293)	DEFAULT MACRO ARGUMENTS ARE NOT SAVED IN BINARY UNIVERSALS
;		.UVER=5
;335	(15406)	SCAN .REQUIRE,.REQUEST WITH FILE SPEC SCANNER, NOT GETSYM
;336	(15485)	CLEAN UP 323 TO MAKE IT THE SAME AS PUBLISHED 256
;337		FIX EDIT 333 TO MAKE ^! ^- WORK AGAIN
;340	(15682)	CHECK FOR FORWARD DEFINED ENTRIES BEFORE MAKING UNDEFINES EXTERNAL
;341		FIX ERRORS WITH DEFAULT ARGUMENTS
;342	(15680)	ADD PORTAL OPCODE
;343	(15683)	DON'T SEARCH UNIVERSALS WHEN DEFINING INTERN,EXTERN,ETC
;344		LIST MOVE [CONO] CORRECTLY
;345	(16130) CORRECT EDIT 335 TO BYPASS EXTRA TABS AND SPACES
;346	(16130) PREVENT RELOC FROM OPERATING ACROSS PRGEND'S
;347	(16250) FIX EDITS 325 AND 332 TO HANDLE MACROS TERMINATING
;	ON THE SAME LINE
;350	(16471) EDIT 345 BREAKS SCANNING OF .REQU??? TYPE ITEM BECAUSE
;	BYPASS MACRO EATS FIRST CHARACTER OF SPEC.
;351	(16335) WHEN AN OPEN ANGLE BRACKET IS MISSING AFTER IRPC,
;	DON'T CRASH WHILE SEARCHING FOR IT.
;352	(16589) FIX '[DEVICE] NOT AVAILABLE' ERROR MESSAGE TYPEOUT
;353		REMOVE EDIT 343
;354	(16804)	FIX EDIT 351 TO ALLOW COMMA BEFORE OPEN BRACKET IN IRP,IRPC
;	ADD 'MISSING OPEN BRACKET' ERROR MESSAGE FOR IRP
;355	(16878)	CHECK ENOUGH CORE ALLOTTED FOR UNIVERSAL FILES WITH PRGEND
;356	(16883)	GIVE ERROR MESSAGE IF UNABLE TO WRITE UNIVERSAL FILE
;357	(17041)	FIX EDITS 333,337 TO MAKE ^!,^- WORK IN A MACRO
;360	(16690)	FIX '[SYMBOL] UNASSIGNED, DEFINED AS IF EXTERNAL' ERROR
;	MESSAGE TYPEOUT
;361	(17046)	FIX EDITS 351,354 TO ALLOW ) BEFORE OPEN ANGLE BRACKET
;362		ADD .DIRECTIVES .OKOVL,.EROVL TO ALLOW * OR / OVERFLOW
;363	(16988)	INSERT UNDEFINED SYMBOL PRECEDED BY UNARY MINUS IN UNDEFINED SYMBOL TABLE
;364	(17147)	ADD SEPARATE 'UNIVERSAL VERSION SKEW' ERROR MESSAGE
;365	(17143)	FIX .CREF,.XCREF FOR MULTIPLY-ENTERED SYMBOLS
;366	(17256)	FIX HANDLING OF FIRST LEVEL ANGLE BRACKETS INSIDE MACROS
;367	(16559)	FIX ERROR HANDLING IN LITERALS
;370	(17387)	FIX .TEXT FLAG HANDLING
;371	(16710)	CORRECT DECREMENTING OF MACROS DEFINED IN UNIVERSALS BELOW 1
;372	(17912)	FIX .XTABM FOR SPECIAL CASES
;373	(17913)	ADD ERROR MESSAGE FOR MISSING < IN REPEAT
;374	(17993)	FIX HANDLING OF RELOCATABLE ARGUMENTS WITH ^L
;375	(17994)	FIX PREVIOUS EDITS TO ^-  AND ^! OPERATORS
;376	(18280)	CORRECT EDIT 367, IT BROKE ERRORS IN SINGLE LINE LITERALS
;377		ADD MCRPGE (PRGEND ERROR) MNEMONIC
;400		PRESERVE OLD .REL FILE AND PRODUCE PARTIAL LISTING AFTER
;		MRCNEC OR MRCPDL ERROR
;401		DON'T ALLOW SHIFT TO DELETE RELOCATION FACTOR
;402	(17904)	FIX "LABEL + OFFSET" FOR LABELS IN LITERALS
;403		REPLACE MCREWU,MCRERU ERROR MESSAGES WITH EXISTING I/O MESSAGES
;404	(18768)	FIX CHECK FOR ! AFTER SYMBOL IN INTERN,EXTERN,SUPRESS,ETC.
;405	(18282)	CHECK FOR DEFAULT PPN SUCH AS [,NNNN] OR [NNNN,]
;406	(18894)	DON'T ALLOW SEMI-INFINITE LOOP IN ASSIGNMENT STATEMENT
;407	(NONE)	EDIT 401 IS A GOOD IDEA,BUT IT BROKE OLD PROGRAMS
;410	(NONE)	GENERAL CLEANUP IN PREPARATION FOR RELEASE.
;411	(18828)	/N SHOULDN'T SUPRESS %....X SYMBOLS IN CREF
;412	(NONE)	CLEAR HISNSW AT PRGEND FOR NEXT PROGRAM
;413	(NONE)	ADD .DIRECTIVE KL10, MAKE IT OK TO HAVE MULTIPLE CPUS
;414	(NONE)	ADD .DIRECTIVES .TCDON/.TCDOFF FOR TESTING NEW LINK CODES
;415	(NONE)	SUPERSEDE EDITS 367,376 FOR CLARITY
;416	(Q00320) FIX ^- AGAIN. EDITS 375,333 SUPERSEDED.
;417	(Q00316) EDIT 221 BROKE TAPE PSEUDO-OP WHEN EOF FOLLOWS
;420	(Q00322) RESET TITLE TO ".MAIN" AT PRGEND
;421	(Q00328) CLEAN UP THE .DIRECTIVE CODE, ADD .DIRECTIVE NO
;
;457		.LINK
;460	(18893)	CHECK FOR ILLEGAL CHARACTERS AT ASTERISK LEVEL
;461	(Q0390)	ALLOW NULL EXTENSIONS IN SORCE SPECIFICATIONS

;; MACRO 50A   RELEASE IN MARCH, 1976


;START OF VERSION 51
;300		TURN ON POLISH SWITCH
;301		ADD ERRF FLAG TO SIGNAL NOT TO COLLAPSE LITERALS
;302		HANDLE EXTERNS CORRECTLY IF PSECTS USED
;303		HANDLE EXP CONST+EXTERN CORRECTLY (FULL WORD FIXUP)
;304		HANDLE XWD POLISH,POLISH CORRECTLY (HALF WORD FIXUPS)
;305		HANDLE SYMBOL TABLE FIXUPS CORRECTLY
;306		ADD KL10 OPCODES
;307		REMOVE F40 UUOS
;310		ADD .IFN PSEUDO-OP, AND OPCODE ARG
;311		POLISH BUG FIXES, STACK LARGER IF POLISH (DLM)
;312		.IF/.IFN - COMMA TO SEPARATE SYMBOLS, FIX BUGS (DLM)
;313		MACRO ARGS - PASS LEADING TAB/SPACE, COUNT [] (DLM)
;314		LIST BINARY FOR LITERALS IN LINE IF LITLST (DLM)
;315		SKIP TAB/SPACE AT END OF MACRO ARGS (DLM)
;316		(DELETED)
;317		ACCUMULATE ERROR FLAG DURING MULTI-LINE LIT (DLM)
;320 - 421 IN VERSION 50A
;422		IMPROVE ERROR MSG & HANDLING IN LITERAL (DLM)
;423		OPTIONAL LONG FILE NAME SUPPORT (ASM)
;424		ADD FLBLST DIRECTIVE (DLM)
;425		ADD UUOSYM SWITCH (DLM)
;426		MAKE MACRO NAME RECOGNIZED BEFORE SYMBOL IN EXP IF MACPRF (DLM)
;427		(DELETED)
;430		MORE CONSISTENT HANDLING OF EXPRESSIONS AND STATEMENTS (DLM)
;431		REMOVE EDIT 217, CAUSED BUGS AND LISTING SCREWUPS (DLM)
;432		SFCOND DIRECTIVE TO SIMULATE XLIST IN IF'S WHICH FAIL (DLM)
;433		FLUSH LEADING AND TRAILING TABS & SPACES IN MACRO ARGS (DLM)
;434		FIX BUG CAUSED BY CORE EXPANSION WHILE DUMPING SYMTAB (DLM)
;435		ALLOW INTERN OF SYMBOL DECLARED AS OPDEF (DLM)
;436		BETTER HANDLING OF RELOCATION COUNT FOR ALL OPERATORS (DLM)
;437		.PSECT PSEUDO-OPS REMOVED


;START OF VERSION 52
;440		TENEX SWITCH REMOVED
;441		ERROR FOR NO DIRECTIVE WHICH HAS NO LOGICAL OPPOSITE
;442		FIX LOSING OF FIRST CHARACTER AFTER TAPE PSEUDO-OP FOLLOWED BY A EOF
;443		FIX Q ERROR WITH 2 NESTED REPEATS ENDING ON THE SAME LINE
;444		HANDLE SYM=<Z POLISH> CORRECTLY
;445		HANDLE RUBOUTS (177) IN MACRO CALL ARGUMENT
;446		REMOVE : OR ! AFTER MULTIPLY DEFINED TAG WAS FOUND
;447		ALLOW REL+REL AND ABS-REL,THUS ASSUMING THEY ARE PART OF LARGER EXP
;450		IF MACMPD, .DIRECTIVE .ITABM HAS NO EFFECT.
;451		ADDED ERROR MESSAGES REL FILE OPEN ERROR AND
;		LST FILE OPEN ERROR FOR TOPS20
;452		ALLOW POLISH IN A UNV FILE
;453		A-ERROR WHEN ARG2 ABR. OF .IF/.IFN IS NOT UNIQUE
;454		BETTER HANDLING OF UNV VERSION DIFFERENCES
;		KLUDGE FOR VERSION 4 STILL IN
;455		DON'T COLLAPSE LITERAL CONTAINING POLISH ON PASS1
;456		FIX BUG WITH POLISH IN PHASE CODE
;457 - 461 IN VERSION 50A
;462		BUG FIXES IN OPDEF, .CPU. VALUES
;463		ALLOW: IFE A##/IFN A## GIVING F/T RESPECTIVELY WITHOUT ERROR.
;464		HANDLE <POINT N,POLISH,M> CORRECTLY.  NOTE: IN ANGLE-BRACKETS
;465	(20036)	IMPLEMENT "%MCRSOC STATMENT OUT OF ORDER .COMMON [SYMBOL]"
;		MESSAGE (SAME AS 50A(430))
;466	(NONE)	CLEAN UP UNIVERSAL I/O ERROR MESSAGES (50A(431))
;467	(20472)	FIX SPURIOUS "NO END STATEMENT" ON PASS 2 (50A(435))
;470		FIX DEFAULT ARG READ IN FOR DEFINES IN MACROS
;471		HANDLE X=ASCIZ/ (MULTIPLE LINE TEXT)../  CORRECTLY
;472		HANDLE X=<MOVEI 1,[POLISH]> CORRECTLY. NOTE: POL IN LIT
;473	(19585)	REWORK EDIT 373 (SAME AS 50A(425))
;474	(Q0390)	COUNT PAGES CORRECTLY ON PRGEND (50A(433))
;475	(20681)	FIX LOST PHASE ERROR ON 'END" BY FORCING EARLY CHECK WHEN NECESSARY (50A(436))
;476	(20779)	ALLOW SFD'S ON OUTPUT FILE SPECIFICATION (50A(437))
;477		FIX BUG WITH LISTING OF TITLE LINES WHEN XLIST IS IN EFFECT
;500		IFDEF/IFNDEF CHECKS FOR SYMBOL BEFORE SYN/OPD/MAC WHEN BOTH EXIST
;501		ENLARGE DEVBUF TO BLOCK 12--CAUSED PROBLEM WITH LONG FILE NAME CREF
;502		FIX "P" ERRORS WHEN SYMBOL FORWARD-REFERENCED ACROSS LIT
;503		FIX ILL.MEM.REF. DUE TO UE ERROR WHILE SETTINUP POLISH
;504		HANDLE "@" CORRECTLY WITH POLISH FWF
;505		P-ERROR ONLY IF VAR STARTING ADDRESS ON PASS2 IS .GT. PASS1
;506		FIX ILL-MEM-REF DUE TO CHANGE IN MACRO ARG HANDLING--
;		GIVE MACRO EXPANSION ERROR INSTEAD.
;507		MAKE QUOTES QUOTING CHARS IN MACRO CALL ARGS,IE. "[","("
;510		WHEN .IF/.IFN ARG1 APPEARS TWICE IN AYMBOL TABLE, MERGE THE FLAGS
;511		CHECK FOR A UNIVERSAL FILE WHICH IS REALLY NOT A UNV FILE
;512		REMOVE STICKY DEVICE FOR -20
;513		FIX BUG WITH PROGRAM BREAK WHEN LIT-COLLAPSE DIFFERENTLY BETWEEN THE TWO PASSES
;514		FIX BUG WITH ERROR COUNT WHEN A SYMBOL DECLARED INTERNAL
;		WAS NEVER REFERENCED
;515	(Q0881)	DON'T BOTHER WITH P-ERROR IN VAR IF VARCNT IS ZERO
;516	(Q0855)	FIX BUG WITH TAGS IN NESTED LITERALS
;517	(Q0856)	GET RID OF EXTRA ALPHAS AT THE END OF SWITCH
;520	(Q0855)	ALLOW TAG FIXUP IN THE SCOPE OF A LITERAL(NESTED LITS)
;521		FIX LISTING OF OPDEFS IN MACROS UNDER SALL
;522	(Q0888)	FIX BUG WITH .DIRECT FLBLST
;523		USE ONLY RADIX-50 CHARS FOR PROGRAM NAME
;524		HANDLE [P,PN<CR-LF> AT COMMAND LEVEL
;525		CLEAR RIM FLAGS AT PROGEND
;526	(Q0917)	HANDLE -1 RELOCATIONS DOING POLISH WITH OPERATORS +, -
;527	(Q0918)	REPLACE HALT WITH "EXPRESSION PARSING PROBLEM" ERR MSG
;530	(Q0872)	FIX LISTING BUG WITH COMMENT PSEUDO-OP
;531	(Q0880)	FIX BUG WITH LISTING OF MACRO CALL UNDER XALL
;532	(Q0889)	FIX LABEL+OFFSET ERROR MESSAGE
;533	(Q0747)	REMOVE CODE TO LOOKUP/RENAME LISTING FILE BEFORE ENTERING A NEW ONE
;534		FIX Q-ERROR WHEN NULL CHAR ENCOUNTERED BERFORE ] IN LIT
;535		HANDLE UNARY MINUS IN POLISH
;536		CLEAN UP
;537		SETS /U ON ALL FATAL ERRORS WHICH CONTINUE ASSEMBLY
;540		A-ERROR IF SYMBOL MISSING FROM LEFT OF =
;541		CALL XCEEDS INSTEAD OF CALL XCEED IN LBLFIX
;542		BETTER HANDLING OF SYN IN UNIVERSAL FILE
;543		WRITE MACRO VERSION NUMBER INTO THE 2ND WORD OF A UNV FILE
;544		REMOVE OPCODES PXCT(107) AND SXCT(106).
;545		STORE THE FIRST SUBTTL ON PASS1 ONLY IF PAGE 1.
;546	(Q1079)	STOP LOOPING OF "POLISH TOO COMPLEX" MSG WHEN POLISH >17 WORDS.
;547		CHECK OPERATOR INDEX RANGE WHEN DOING POLISH
;550		FIX SUBTTL AGAIN
;551		FIX POLISH WITH POINT
;*****END OF REVISION HISTORY*****

SUBTTL OTHER PARAMETERS

.PDP==^D100			; BASIC PUSH-DOWN POINTER
   IFN POLISH,<.PDP==^D250>	;[311] BE GENEROUS WITH STACK
   IFNDEF LPTWID,<LPTWID==^D132> ;DEFAULT WIDTH OF PRINTER
.LPTWD==8*<LPTWID/8>		;USEFUL WIDTH IN MAIN LISTING
.CPL==.LPTWD-^D32		;WIDTH AVAILABLE FOR TEXT WHEN
				;BINARY IS IN HALFWORD FORMAT
.CPLX==LPTWID-.LPTWD		; EXCESS SPACE IN LAST TAB STOP
   IFNDEF .LPP,<		;
	IFE STANSW,<.LPP==^D57>	;LINES/PAGE
	IFN STANSW,<.LPP==^D52>	;LINES/PAGE
   >
.STP==^D100			;STOW SIZE
.TBUF==^D80			;TITLE BUFFER
.SBUF==^D80			;SUB-TITLE BUFFER
.IFBLK==^D20			;IFIDN COMPARISON BLOCK SIZE
.R1B==^D18
.UNIV==^D10			;NUMBER OF UNIVERSAL SYMBOL TABLES ALLOWED
.LEAF==4			;SIZE OF BLOCKS IN MACRO TREE
.SFDLN==5			; NUMBER OF SFD'S ALLOWED

NCOLS==LPTWID/^D32		;NUMBER OF COLUMNS IN SYMBOL TABLE
SGNSGS==^D64			;MAX # OF DISTINCT PSECTS ALLOWED
				;IN ONE ASSEMBLY
SGNDEP==^D16			;MAX PSECT DEPTH ALLOWED
   IFN CCLSW,<IFNDEF CTLSIZ,<CTLSIZ==^D200>>
   IFN OPHSH,<IFNDEF PRIME,<PRIME==^D701>>
   IFNDEF NUMBUF,<NUMBUF==5>	; NUMBER OF INPUT BUFFERS

EXTERN .JBREL,.JBFF,.JBAPR,.JBSA,.JBERR
EXTERN .HELPR
   IFDEF .REQUEST,<.REQUEST SYS:HELPER  > ;

LOWL:!				;START OF LOW SEGMENT
   IFN PURESW,<TWOSEGMENTS
	RELOC 400000>

	SALL			;SUPPRESS ALL MACROS

;SOME ASCII CHARACTERS

HT==11
LF==12
VT==13
FF==14
CR==15
CZ==32
EOL==33
CLA==37
OBRCKT=="<"

				;ACCUMULATORS
AC0==0
AC1=AC0+1
AC2=AC1+1
SDEL=3				;SEARCH INCREMENT
SX=SDEL+1			;SEARCH INDEX
ARG=5				;ARGUMENT
V=6				;VALUE
C=7				;CURRENT CHARACTER
CS=C+1				;CHARACTER STATUS BITS
RC=11				;RELOCATION BITS
MWP=12				;MACRO WRITE POINTER
MRP=13				;MACRO READ POINTER
IO=14				;IO REGISTER (LEFT)
ER==IO				;ERROR REGISTER (RIGHT)
FR=15				;FLAG REGISTER (LEFT)
RX==FR				;CURRENT RADIX (RIGHT)
MP=16				;MACRO PUSHDOWN POINTER
P=17				;BASIC PUSHDOWN POINTER

%OP==3
%MAC==5
%DSYM==2
%SYM==1
%DMAC==%MAC+1
%ERR==%MAC

OPDEF RESET [CALLI  0]
OPDEF SETDDT [CALLI   2]
OPDEF DDTOUT [CALLI  3]
OPDEF DEVCHR [CALLI  4]
OPDEF CORE [CALLI 11]
OPDEF EXIT [CALLI 12]
OPDEF UTPCLR [CALLI 13]
OPDEF DATE [CALLI 14]
OPDEF APRENB [CALLI 16]
OPDEF MSTIME [CALLI 23]
OPDEF PJOB [CALLI 30]
OPDEF RUN [CALLI 35]
OPDEF TMPCOR [CALLI 44]
OPDEF MTWAT. [MTAPE  0]
OPDEF MTREW. [MTAPE  1]
OPDEF MTEOT. [MTAPE 10]
OPDEF MTSKF. [MTAPE 16]
OPDEF MTBSF. [MTAPE 17]



				;FR  FLAG REGISTER (FR/RX)
IOSCR==000001			;NO CR AFTER LINE
POLSW==000002			; DOING POLISH ON GLOBALS
MTAPSW==000004			;MAG TAPE
ERRQSW==000010			;IGNORE Q ERRORS
LOADSW==000020			;END OF PASS1 & NO EOF YET
DCFSW==000040			;DECIMAL FRACTION
RIM1SW==000100			;RIM10 MODE
NEGSW==000200			;NEGATIVE ATOM
RIMSW==000400			;RIM OUTPUT
PNCHSW==001000			;RIM/BIN OUTPUT WANTED
CREFSW==002000
R1BSW==004000			;RIM10 BINARY OUTPUT
TMPSW==010000			;EVALUATE CURRENT ATOM
INDSW==020000			;INDIRECT ADDRESSING WANTED
RADXSW==040000			;RADIX ERROR SWITCH
FSNSW==100000			;NON BLANK FIELD SEEN
MWLFLG==200000			;ON FOR DON'T ALLOW MULTI-WORD LITERALS
P1==400000			;PASS1

				;IO FLAG REGISTER (IO/ER)
FLDSW==400000			;ADDRESS FIELD
IOMSTR==200000
ARPGSW==100000			;ALLOW RAPID PROGRAM GENERATION
IOPROG==040000			;SUPRESS LISTING (LIST/XLIST PSEUDO OP)
NUMSW==020000
IOMAC==010000			;MACRO EXPANSION IN PROGRESS
IOPALL==004000			;SUPRESS LISTING OF MACRO EXPANSIONS
IONCRF==002000			;SUPRESS OUTPUT OF CREF INFORMATION
CRPGSW==001000			;CURRENTLY IN PROGRESS ON RPG
IOCREF==000400			;WE ARE NOW OUTPUTTING CREF INFO
IOENDL==000200			;BEEN TO STOUT
IOPAGE==000100
DEFCRS==000040			;THIS IS A DEFINING OCCURANCE (MACROS)
IOIOPF==000020			;IOP INSTRUCTION SEEN
MFLSW==000010			;MULTI-FILE MODE,PRGEND SEEN
IORPTC==000004			;REPEAT CURRENT CHARACTER
RSASSW==000002			; REFERENCE IS TO A SYMBOL IN ANOTHER PSECT
IOSALL==000001			;SUPPRESS MACRO LISTING EVEN IF BINARY IS GENERATED

OPDEF CALL [PUSHJ P,]		;FUNCTIONAL MNEMONIC
OPDEF RET [POPJ P,]		;FUNCTIONAL MNEMONIC

OPDEF JUMP1 [JUMPL FR,]		;JUMP IF PASS 1
OPDEF JUMP2 [JUMPGE FR,]	;JUMP IF PASS 2

OPDEF JUMPOC [JUMPGE IO,]	;JUMP IF IN OP-CODE FIELD
OPDEF JUMPAD [JUMPL IO,]	;JUMP IF IN ADDRESS FIELD

OPDEF JUMPCM [JUMPL CS,]	;JUMP IF CURRENT CHAR IS COMMA
OPDEF JUMPNC [JUMPGE CS,]	;JUMP IF CURRENT CHAR IS NON-COMMA

OPDEF PJRST [JRST]		;JUMP TO RET	;RETURN
OPDEF HALT [HALT]		;TO PUT IN CREF TABLE


				;ER ERROR REGISTERS (IO/ER)
TTYSW==000001
LPTSW==000002
ERRF==000004			;[301] FAKE ERROR TO PREVENT LITERALS BEING COLLAPSED

ERRS==000010			; ILLEGAL PSECT USAGE
ERRM==000020			;MULTIPLY DEFINED SYMBOL
ERRE==000040			;ILLEGAL USE OF EXTERNAL
ERRP==000100			;PHASE DISCREPANCY
ERRO==000200			;UNDEFINED OP CODE
ERRN==000400			;NUMBER ERROR
ERRV==001000			;VALUE PREVIOUSLY UNDEFINED
ERRU==002000			;UNDEFINED SYMBOL
ERRR==004000			;RELOCATION ERROR
ERRL==010000			;LITERAL ERROR
ERRD==020000			;REFERENCE TO MULTIPLY DEFINED SYMBOL
ERRA==040000			;PECULIAR ARGUMENT
ERRX==100000			;MACRO DEFINITION ERROR
ERRQ==200000			;QUESTIONABLE, NON-FATAL ERROR
ERROR1==ERRP!ERRM!ERRV!ERRX	; ERRORS THAT PRINT ON PASS 1
ERRORS==777760

				;SYMBOL TABLE FLAGS
SYMF==400000			;SYMBOL
TAGF==200000			;TAG
NOOUTF==100000			;NO DDT OUTPUT WFW
SYNF==040000			;SYNONYM
MACF==SYNF_-1			;MACRO
OPDF==SYNF_-2			;OPDEF
PNTF==004000			;"VALUE" IN SYMBOL TBL IS PNTR TO 36BIT VALUE
UNDF==002000			;UNDEFINED
EXTF==001000			;EXTERNAL
INTF==000400			;INTERNAL
ENTF==000200			;ENTRY
VARF==000100			;VARIABLE
NCRF==000040			; DO NOT CREF THIS SYMBOL
MDFF==000020			;MULTIPLY DEFINED
SPTR==000010			;SPECIAL EXTERNAL POINTER
SUPRBT==000004			;SUPRESS OUTPUT TO REL AND LISTING
LELF==000002			;LEFT HAND RELOCATABLE
RELF==000001			;RIGHT HAND RELOCATABLE

SIXF==SYNF+PNTF+VARF		;[542] USED WITH SYUNV FILE
				;[542] POINTER TO A SIXBIT OPERATOR

LITF==200000			;FLAG FOR PSEUDO-OPS INVALID IN LIT'S
ADDF==100000			;FLAG FOR PSEUDO-OPS INVALID IN ADDRESSES

TNODE==200000			;TERMINAL NODE FOR EVALEX

;FLAGS IN BLSW

BLOFF==1B0			;BINARY LISTING OFF (MUST BE B0)
FLBLST==1B1			;FIRST-LINE BINARY ONLY MODE

;POLISH FIXUP CODES

POLRHF==-1			;RIGHT-HALF FIXUP
POLLHF==-2			;LEFT-HALF FIXUP
POLFWF==-3			;FULL-WORD FIXUP

;UNIVERSAL VERSION BIT DEFINITION


;THE FIRST WORD OF A UNV FILE MUST CONTAIN:
;	LEFT HALF	777
;	RIGHT HALF	UNIVERSAL VERSION NUMBER
;WHEN WRITING A UNV FILE, MACRO WRITES OUT:
;	777,,UWVER	FOR THE FIRST WORD
;	.JBVER		FOR THE SECOND WORD( MACRO VERSION NUMBER)
;WHEN READING A UNV FILE, MACRO READS THE FIRST WORD AND CHECKS FOR:
;	777 IN LEFT HALF, AND
;	CHECKS THE RIGHT HALF AGAINST MASK .URVER
;	WILL SKIP THE SECOND WORD IF A VERSION NUMBER IS EXPECTED THERE
;

UMACV==000020			;[543] HAS MACRO VERSION IN 2ND WORD
USYN==000010			;[542] NEW SYN HANDLING IN UNIVERSAL
UBAS==000004			;[454] MUST HAVE THIS BASIC BIT ON
				;[454] SAME AS THE FIRST VERSION #4
UPOL==000002			;[454] POLISH INCLUDED
UMAD==000001			;[454] MACRO ARG DEFAULT VALUE BUG FIXED

UALL==UBAS+UMAD+UPOL+USYN+UMACV	;[543] EVERYTHING

   IFN POLISH,<.URVER==^-UALL>	;[543] WILL READ EVERY KIND OF UNV
   IFE POLISH,<.URVER==^-<UALL-UPOL>> ;[454] WILL NOT READ POLISH STUFF IN UNV 

;USEFUL MACROS

DEFINE FORERR(AC,ABC)<
	MOVE AC,[PAGENO,,ABC'PG]
	BLT AC,ABC'PG+3
   >

;MACRO TO BYPASS LEADING TABS AND SPACES
DEFINE BYPASS <
	CALL BYPAS1
   >

DEFINE BITON(BIT,ADR)<
	PUSH P,0
	MOVEI 0,BIT
	IORM 0,ADR
	POP P,0
   >


SUBTTL START ASSEMBLING

ASSEMB:	CALL INZ		;INITIALIZE FOR PASS
	SKIPA AC1,.+1		;LOCALIZED CODE
	ASCII /.MAIN/
	MOVEM AC1,TBUF
	SETZM TBUF+1		;SIGNAL NOT YET SEEN A TITLE
	MOVEI SBUF
	HRRM SUBTTX

ASSEM1:	CALL CHARAC		;TEST FOR FORM FEED
	SKIPGE LIMBO		;CRLF FLAG?
	JRST ASSEM1		;YES ,IGNORE LF
	CAIN C,14
	SKIPE SEQNO
	JRST ASSEM2
	CALL OUTFF1
	CALL OUTLI
	JRST ASSEM1

ASSEM2:	CAIN C,"\"		;BACK-SLASH?
	TLZA IO,IOMAC		;YES, LIST IF IN MACRO
	TLO IO,IORPTC
	CALL STMNT		;OFF WE GO
	TLZN IO,IOENDL		;WAS STOUT PRE-EMPTED?
	CALL STOUT		;NO, POLISH OFF LINE
	JRST ASSEM1

SUBTTL STATEMENT PROCESSOR

STMNT:
   IFN POLISH,<
	SKIPLE POLTYP		;[311] INIT POLISH
	SETZM POLTYP>		;[311]
	TLZ FR,INDSW!FSNSW!POLSW
	SETZM UPARROW		;[375] CLEAR SPECIAL REPEAT CHARACTER
	TLZA IO,FLDSW
STMNT1:	CALL LABEL
STMNT2:	CALL ATOM		;GET THE FIRST ATOM
	CAIN C,'='		;"="?
	JRST ASSIGN		;YES
	CAIN C,':'		;":"?
	JRST STMNT1		;YES
	JUMPAD STMNT9		;NUMERIC EXPRESSION
	JUMPN AC0,STMN2A	;JUMP IF NON NULL FIELD
	SKIPN LITLVL		;ALLOW COMMA IN LITERALS
	CAIE C,','		;NULL, COMMA?
	CAIN C,EOL		;OR END OF LINE?
	RET			;YES,EXIT
	CAIN C,']'		; CLOSING LITERAL?
	RET			;YES
	JRST STMNT9		;NO,AT LEAST SKIP ALL THIS NONSENSE



STMN2A:	SKIPE C
	TLO IO,IORPTC		;REPEAT TERMINATOR IF NOT BLANK
	CALL MSRCH		;SEARCH FOR MACRO/OPDEF/SYN
	  JRST STMNT3		;NOT FOUND, TRY OP CODE
	LDB SDEL,[POINT 3,ARG,5]
	JUMPE SDEL,ERRAX	;ERROR IF NO FLAGS
	SOJE SDEL,OPD1		;OPDEF IF 1
	SOJE SDEL,CALLM		;MACRO IF 2
	JRST STMNT4		;SYNONYM, PROCESS WITH OP-CODES

STMNT3:	CALL OPTSCH		;SEARCH OP CODE TABLE
	  JRST STMNT5		;NOT FOUND
STMNT4:	TLNE CS,(17B5)		;TERMINATED WITH OPERATOR? (+,-,ETC.)
	JRST [	HRRZ AC1,V	;YES
		TRZ AC1,ADDF+LITF
		CAIE AC1,OP	;REGULAR OPCODE?
		JRST .+1	;NO, MUST EXECUTE IT
		JRST STMNT9]	;YES, TREAT AS SYMBOL
	HLLZ AC0,V		;PUT CODE IN AC0
	TRZ V,ADDF		;CLEAR ADDRESS NON-VALID FLAG
	TRZE V,LITF		;VALID IN LITERAL?
	SKIPN LITLVL		;NO, ARE WE IN A LITERAL?
	JRST 0(V)		;EXECUTE APPROPRIATE PROCESSOR
	RET			;YES,EXIT

STMNT5:	CALL SSRCH		;TRY SYMBOLS
	  JRST STMNT8		;NOT FOUND
STMNT9:
   IFN POLISH,<
	PUSH P,[0,,POLFWF]	;[305] MARK AS TEMP FULL WORD FIXUP
	POP P,POLTYP		;[305] INCASE WE GO POLISH
   >
	TLZ IO,IORPTC		;EVAL WILL HANDLE TERMINATOR IN C
	CALL EVALHA		;EVALUATE EXPRESSION
   IFN FORMSW,< MOVE AC1,HWFORM> ;USE STANDARD FORM
	TLNE FR,FSNSW		;FIELD SEEN?
	JRST STOW		;YES,STOW THE CODE AND EXIT
	CAIE C,']'		;CLOSING LITERAL?
	TRO ER,ERRQ		;NO, GIVE "Q" ERROR
	RET			;EXIT

STMNT8:
   IFN UUOSYM,<			;ALL THIS ONLY IF TOPS10 SYMS WANTED
	MOVEI V,0		;ALWAYS START SCAN WITH 0
	CAIL V,CALNTH		;END OF TABLE?
	JRST STMN8C		;YES, TRY TTCALLS
	CAME AC0,CALTBL(V)	;FOUND IT?
	AOJA V,.-3		;NO,TRY AGAIN
	SUBI V,NEGCAL		;CALLI'S START AT -1
	HRLI V,(CALLI)		;PUT IN UUO
STMN8D:	MOVSI ARG,OPDF		;SET FLAG FOR OPDEF
STMN8B:	CALL INSERT		;PUT OPDEF IN TABLE
	JRST OPD		;AND TREAT AS OPDEF

STMN8C:	SETZ V,			;START WITH ZERO
	CAIL V,TTCLTH		;END OF TABLE?
	JRST STMN8E		;TRY MTAPES
	CAME AC0,TTCTBL(V)	;MATCH?
	AOJA V,.-3		;NO, KEEP TRYING
	LSH V,5			;PUT IN AC FIELD (RIGHT HALF)
	HRLZI V,<(TTCALL)>(V)	;PUT UUO IN LEFT HALF
	JRST STMN8D		;SET OPDEF FLAG

STMN8E:	SETZ V,			;START AT ZERO
	CAIL V,MTALTH		;END OF TABLE?
	JRST STMN8A		;YES, ERROR
	CAME AC0,MTATBL(V)	;MATCH
	AOJA V,.-3		;NOT YET
	PUSH P,AC0		;SAVE IT
	MOVE AC0,[POINT 9,MTACOD]
	IBP AC0			;GET TO RIGHT ONE
	SOJGE V,.-1		;EVENTUALLY
	LDB V,AC0		;GET FUNCTION
	HRLI V,(MTAPE)		;FILL IN OPCODE
	POP P,AC0
	JRST STMN8D

STMN8A:
   >				;END UUOSYM
	SETZB V,RC		;CLEAR VALUE AND RELOCATION
	TRO ER,ERRO		;FLAG AS UNDEFINED OP-CODE
	JUMP1 OPD		;TREAT AS STANDARD OP ON PASS1
	MOVSI ARG,OPDF!UNDF!EXTF ;SET A FEW FLAGS
	CALL INSERT		;TO FORCE OUT A MESSAGE
	JRST OPD

	SUBTTL LABEL PROCESSOR

LABEL:	JUMPAD LABEL4		;COMPARE IF NON-SYMBOLIC
	JUMPE AC0,LABEL5	;ERROR IF BLANK
	TLO IO,DEFCRS		;THIS IS A DEFINITION
	SKIPN LITLVL		;[402] LABEL IN LITERAL?
	JRST LABL10		;[402] NO
	SETOM LBLFLG		;[402] SET FLAG
	PUSH P,STPX		;[402]
	POP P,LTGINC		;[402] SET MARKER
LABL10:	PUSH P,UNISCH+1		;SAVE SEARCH LIST
	SETZM UNISCH+1		;BUT DISALLOW
	CALL SSRCH		;SEARCH FOR OPERAND
	  MOVSI ARG,SYMF!UNDF!TAGF ;NOT FOUND
	POP P,UNISCH+1		;RESTORE STATUS
	TLZN ARG,EXTF		;WAS EXTERNAL?
	JRST LABEL0		;NO
	TLNN ARG,UNDF		;YES, BECAUSE UNDEFINED?
	JUMP2 LABEL3		;NO, ERROR
	TLO ARG,UNDF		;YES, IGNORE
	TLZ ARG,EXTF!PNTF	;TURN OFF EXT FLAG NOW
	JUMPE V,LABEL0		;NOTHING TO CHAIN IF 0
	MOVE RC,LOCAL		;GET CURENT POINTER
	MOVEM RC,1(ARG)		;STORE OVER NAME
	HRRM ARG,LOCAL		;LINK INTO CHAIN
	MOVE RC,LOCA		;GET CURRENT LOCATION
	HRLM RC,(ARG)		;STORE BUT SWAPPED
	LSH V,-^D17		;SHIFT RELOCATION TO BIT 34
	IOR V,MODA		;CURRENT RELOCATION
	HRLM V,1(ARG)		;STORE IT
LABEL0:	TLZN ARG,UNDF!VARF	;WAS IT PREVIOUSLY DEFINED?
	JRST LABEL2		;YES, CHECK EQUALITY
	MOVE V,LOCA		;WFW
	MOVE RC,MODA
	SKIPE LITLVL		;IN LITERAL?
	JUMP1 [	TRO ER,ERRF	;PASS1, DON'T COLLAPSE AND
		JRST LABEL9]	;DO NOTHING
LABL11:	TLO ARG,TAGF
	CALL PEEK		;GET NEXT CHAR.
	CAIE C,":"		;SPECIAL CHECK FOR  ::
	JRST LABEL1		;NO MATCH
	TLO ARG,INTF		;MAKE IT INTERNAL
	CALL GETCHR		;PROCESS NEXT CHAR.
	CALL PEEK		;PREVIEW NEXT CHAR.
LABEL1:	CAIE C,"!"		;HALF-KILL SIGN
	JRST LABEL6		;NO
	TLO ARG,NOOUTF		;YES, SUPPRESS IT
	CALL GETCHR		;AND GET RID OF IT
LABEL6:	SKIPE LITLVL		;[520] IN LITERAL?
	CALL LBLFIX		;[520] YES, SHOULD GO THERE ONLY IN PASS2
	MOVEM AC0,TAG		;[422] SAVE FOR ERROR MSGS
	PUSH P,LOCA		;[422] SAVE LOC ALSO
	POP P,TAGINC		;[422]
	JRST INSERT		;INSERT/UPDATE AND EXIT

;HERE IF TAGS ENCOUNTERED INSIDE A LITERAL ON PASS2
;3-WORD-BLOCK PER TAG IS ADDED IN FRONT OF A CHAIN
;THE START OF THE CHAIN IS POINTED BY LBLPNT
; THE FORMAT OF THE 3-WORD-BLOCK IS:
;	LITLVL,,POINTER TO NEXT BLOCK (OR 0 FOR END)
;	NAME OF TAG IN SIXBIT
;	ARG FLAGS,,OFFSET INTO CURRENT LITERAL
;
LBLFIX:	PUSH P,AC1		;FREE UP AC1 $ AC0
	PUSH P,AC0
	MOVE AC1,FREE		;GET 3 WORDS FROM FREE CORE
	ADDI AC1,3
	CAML AC1,SYMBOL		;ENOUGH?
	CALL XCEEDS		;[541] NO, GET MORE
	EXCH AC1,FREE		;UPDATE FREE
	HRR AC0,LBLPNT		;UPDATE THE NEXT BLOCK POINTER
	HRL AC0,LITLVL		;GET LITERAL LEVEL
	MOVEM AC0,0(AC1)	;STORE IN WORD1
	MOVE AC0,STPX		;CURRENT DEPTH IN LITERAL
	SUB AC0,STPY		;MINUS THE START
	HLL AC0,ARG		;ARG FLAG IN LEFT HALF
	MOVEM AC0,2(AC1)	;STORE FLAGS,,OFFSET IN WORD 3
	TLO ARG,EXTF		;UPDATE FLAGS TO EXTF+TAGF, NO UNDF
	POP P,AC0		;RESTORE TAG NAME
	MOVEM AC0,1(AC1)	;STORE IN WORD 2
	MOVEM AC1,LBLPNT	;UPDATE START POINTER
	HRRZ V,ARG		;KEEP PRETENDING IT TO BE EXTERNAL
	POP P,AC1		;RESTORE AC1
	JUMPN V,CPOPJ		;GO UPDATE
	MOVEI V,2		;IF V IS ZERO
	ADDB V,FREE		;MAKE IT FAKE EXTERNAL
	CAML V,SYMBOL		;GET 2 WORDS
	CALL XCEEDS		;[541]ENOUGH ROOM?
	SUBI V,2		;
	SETZB RC,0(V)		;AND FAKE EXTERNAL POINTER
	MOVEM AC0,1(V)		;PUT THE TAG NAME THERE
	RET			;GO UPDATE


;HERE IF TAG ALREADY DEFINED

LABEL2:	SKIPE LITLVL		;IN LITERAL?
	JRST LABEL3		;YES, DEFINITE ERROR
	HRLOM V,LOCBLK		;SAVE LIST LOCATION
   IFN POLISH,<
	CAMLE SX,SGSBOT		;IS IT IN THE
	CAMLE SX,SGSTOP		; CURRENT PSECT
	JRST LABEL3>		;NO, FLAG ERROR
	CAMN V,LOCA		;DOES IT COMPARE WITH PREVIOUS? WFW
	CAME RC,MODA
LABEL3:	TLOA ARG,MDFF		;NO, FLAG MULTIPLY DEFINED AND SKIP
	JRST LABEL7		;YES, GET RID OF EXTRA CHARS.
	TRO ER,ERRM		;FLAG MULTIPLY DEFINED ERROR 
	CALL UPDATE		;[446] UPDATE AND EXIT
	JRST LABEL9		;[446] GET RID OF EXTRA CHARS.

;HERE IF EXPRESSION PRECEEDING COLON

LABEL4:	CAMN AC0,LOCA		;DO THEY COMPARE?
	CAME RC,MODA
LABEL5:	TRO ER,ERRP		;NO, FLAG PHASE ERROR
	JRST LABEL9		;[446] GET RID OF EXTRA CHARS.

LABEL7:	MOVEM AC0,TAG		;SAVE FOR ERRORS
	PUSH P,LOCA		;[422]
	POP P,TAGINC		;[422]
LABEL9:	CALL PEEK		;INSPECT A CHAR.
	CAIN C,":"		;COLON?
	CALL GETCHR		;YES, DISPOSE OF IT
	CALL PEEK		;EXAMINE ONE MORE CHAR.
	CAIN C,"!"		;EXCLAMATION?
	JRST GETCHR		;YES, INDEED
	RET

SUBTTL ATOM PROCESSOR
ATOM:	CALL CELL		;GET FIRST CELL
	TLNE IO,NUMSW		;IF NON-NUMERIC
ATOM1:	CAIE C,42		;OR NOT A BINARY SHIFT,
	RET			;EXIT

	PUSH P,AC0		;STACK REGISTERS, ITS A BINARY SHIFT
	PUSH P,AC1
	PUSH P,RC
	PUSH P,RX
	HRRI RX,^D10		;COMPUTE SHIFT RADIX 10
	CALL CELLSF		;GET SHIFT
	MOVE ARG,RC		;SAVE RELOCATION
	POP P,RX		;RESTORE REGISTERS
	POP P,RC
	POP P,AC1
	MOVN SX,AC0		;USE NEGATIVE OF SHIFT
	POP P,AC0
	JUMPN ARG,NUMER2	;IF NOT ABSOLUTE
	TLNN IO,NUMSW		;AND NUMERIC,
	JRST NUMER2		;FLAG ERROR
   IFN POLISH,<
	CAME SX,[-^D35]		;[304] SPECIAL TEST FOR <EXP>B35
	JUMPN RC,[HRRZ PS,(P)	;[304] IF RELOC OR EXTERN USE POLISH
		CAIE PS,EVATOM+1 ;[304] IF IN EXPRESSION EVAL
		JRST .+1	;[304] NO
		JRST ATOM2]	;[304] YES
   >
	LSHC AC0,^D35(SX)
	LSH RC,^D35(SX)
	JRST ATOM1		;TEST FOR ANOTHER

   IFN POLISH,<
ATOM2:	POP P,(P)		;[304] REMOVE TOP ADDRESS
	MOVE PS,(P)		;[304] GET NODE
	CAME PS,[TNODE,,0]	;[304] NOTHING THERE YET?
	JRST .+3		;[304] YES, BYPASS INITIALIZATION
	MOVSI PS,4000		;[304] NO, FAKE IT
	ADDM PS,(P)		;[304] PS
	PUSH P,AC0		;[304] CV
	PUSH P,RC		;[304] RC
	PUSH P,CSTAT+'_'	;[304] CS
	SETZB RC,EXTPNT		;[304]
	MOVEI AC0,^D35(SX)	;[304] SHIFT ARG
	JRST EVGETD		;[304] EVALUATE
   >

CELLSF:	TLO IO,FLDSW
CELL:	SETZB AC0,RC		;CLEAR RESULT AND RELOCATION
	SETZB AC1,AC2		;CLEAR WORK REGISTERS
	MOVEM P,PPTEMP		;SAVE PUSHDOWN POINTER
	TLZ IO,NUMSW
	TLZA FR,NEGSW!DCFSW!RADXSW

CELL1:	TLO IO,FLDSW
	AOSLE UPARRO		;[333] SKIP GETCHR IF RE-EATING ^
	BYPASS
	LDB V,[POINT 4,CSTAT(C),14] ;GET CODE
	XCT .+1(V)		;EXECUTE, INDEX VIA BITS 11,12,13,14 OF CSTAT TABLE
	JRST CELL1		;0; BLANK, (TAB OR "+")
	JRST LETTER		;1; LETTER  ] $ % ( ) , ; >
	TLC FR,NEGSW		;2; "-"
	TLO FR,INDSW		;3; "@"
	JRST NUM1		;4; NUMERIC   0 - 9
	JRST ANGLB		;5; "<"
	JRST SQBRK		;6; "["
	JRST QUOTES		;7; ""","'" 
	JRST QUAL		;10; "^"
	JRST PERIOD		;11; "."
	TROA ER,ERRQ		;12; ERROR, FLAG AND TREAT AS DELIMITER
				;12;	! # & * / : =? \ _


LETTER:	TLOA AC2,(POINT 6,AC0,)	;SET BYTE POINTER
LETTE1:	CALL GETCHR		;GET CHARACTER
	TLNN CS,6		;ALPHA-NUMERIC?
	JRST LETTE3		;NO,TEST FOR VARIABLE
	TLNE AC2,770000		;STORE ONLY SIX BYTES
LETTE2:	IDPB C,AC2		;RETURN FROM PERIOD
	JRST LETTE1

LETTE3:	CAIE C,03		;"#"?
	RET
	JUMPE AC0,POPOUT	;TEST FOR NULL
	CALL PEEK		;PEEK AT NEXT CHAR.
	CAIN C,"#"		;IS IT 2ND #?
	JRST LETTE4		;YES, THEN IT'S AN EXTERN
	TLO IO,DEFCRS
	CALL SSRCH		;YES, SEARCH FOR SYMBOL (OPERAND)
	  MOVSI ARG,SYMF!UNDF	;NOT FOUND, FLAG AS UNDEFINED SYM.
	TLNN ARG,UNDF		;UNDEFINED?
	JRST LETTE5		; NO, BUT SEE IF ALREADY DEFINED AS EXTERNAL
	TLO ARG,VARF		;YES, FLAG AS A VARIABLE
	TRO ER,ERRU		;SET UNDEFINED ERROR FLAG
	CALL INSERZ		;INSERT IT WITH A ZERO VALUE
	JRST GETDEL

LETTE4:	CALL GETCHR		;AND SCAN PAST IT
	TLZ IO,DEFCRS		; MAKE SURE NOT A DEFINITION
	CALL EXTER5		; PUT IN SYMBOL TABLE
	JRST GETCHR		;GET RID OF #

LETTE5:	TLNE ARG,EXTF		; EXTERNAL
	TRO ER,ERRQ		; YES, FLAG WITH "Q" ERROR
	JRST GETCHR		; GET NEXT CHAR AND RETURN

NUMER1:	SETZB AC0,RC		;RETURN ZERO
NUMER2:	TRO ER,ERRN		;FLAG ERROR

GETDEL:	CALL GETCHR
GETDE1:	JUMPE C,.-1
	MOVEI AC1,0
GETDE3:	TLO IO,NUMSW!FLDSW	;FLAG NUMERIC
	TLNN FR,NEGSW		;IS ATOM NEGATIVE?
	RET			;NO, EXIT
	JUMPE AC1,GETDE2
	MOVNS AC1
	TDCA AC0,[-1]
GETDE2:	MOVNS AC0		;YES, NEGATE VALUE
	MOVNS RC		;AND RELOCATION
POPOUT:	RET			;EXIT


QUOTES:	CAIE C,"'"-40		;IS IT  "'"
	JRST QUOTE		;NO MUST BE """
	JRST SQUOTE		;YES

QUOTE0:	TLNE AC0,376000		;5 CHARACTERS STORED ALREADY?
	TRO ER,ERRQ		;YES, GIVE WARNING
	ASH AC0,7
	IOR AC0,C
QUOTE:	CALL CHARAC		;GET 7-BIT ASCII
	CAIG C,15		;TEST FOR LF, VT, FF OR CR
	CAIGE C,12
	JRST .+2		;NO, SO ALL IS WELL
	JRST QUOTE2		;ESCAPE WITH Q ERROR
	CAIE C,42
	JRST QUOTE0
	CALL PEEK		;LOOK AT NEXT CHAR.
	CAIE C,42
	JRST QUOTE1		;RESTORE REPEAT LEVEL AND QUIT
	CALL CHARAC		;GET NEXT CHAR.
	JRST QUOTE0		;USE IT

QUOTE2:	TRO ER,ERRQ		;SET Q ERROR
QUOTE1:	JRST GETDEL

SQUOT0:	CAIL C,"a"		; TEST FOR LOWER CASE
	CAILE C,"z"		; ...
	JRST .+2		; NO
	SUBI C," "		;
	TLNE AC0,770000		;SIX CHARS. STORED ALREADY ?
	TRO ER,ERRQ		;YES
	LSH AC0,6
	IORI AC0,-40(C)		;OR IN SIXBIT CHAR.

SQUOTE:	CALL CHARAC
	CAIG C,CR
	CAIGE C,LF
	JRST .+2
	JRST QUOTE2		; FLAG WITH "Q" ERROR
	CAIE C,"'"
	JRST SQUOT0
	CALL PEEK
	CAIE C,"'"
	JRST QUOTE1
	CALL CHARAC
	JRST SQUOT0

QUAL:	BYPASS			;SKIP BLANKS, GET NEXT CHARACTER
	CAIN C,'B'		;"B"?
	JRST QUAL2		;YES, RADIX=D2
	CAIN C,'O'		;"O"?
	JRST QUAL8		;YES, RADIX=D8
	CAIN C,'F'		;"F"?
	JRST NUMDF		;YES, PROCESS DECIMAL FRACTION
	CAIN C,'L'		;"L"?
	JRST QUALL		;YES
	CAIN C,'-'		; "^-" IS NOT
	JRST QUALN		;
	CAIE C,'D'		;"D"?
	JRST NUMER1		;NO, FLAG NUMERIC ERROR
	ADDI AC2,2
QUAL8:	ADDI AC2,6
QUAL2:	ADDI AC2,2
	PUSH P,RX
	HRR RX,AC2
	CALL CELLSF
QUAL2A:	POP P,RX
	TLNN IO,NUMSW
	JRST NUMER1
	JRST GETDE1

QUALL:	PUSH P,FR
	CALL CELLSF
	MOVE AC2,AC0
	MOVEI AC0,^D36
	SETZ RC,		;[374] IN CASE ARG IS RELOCATABLE
	JUMPE AC2,QUAL2A
	LSH AC2,-1
	SOJA AC0,.-2

QUALN:
	MOVE CS,CSTATN		;[416] GET CHARACTERISTICS FOR "^-"
	JRST GETDE1		;[416] THEN GET DELIMITER


SUBTTL LITERAL PROCESSOR

SQBRK:	PUSH P,TAG		;[402] SAVE CURRENT TAG
	PUSH P,TAGINC		;[402] AND OFFSET
	PUSH P,FR
	PUSH P,EXTPNT		;ALLOW EXTERN TO PRECEDE LIT IN XWD
	SETZM EXTPNT
IFN FORMSW,<	PUSH P,IOSEEN>	;[344] SAVE I/O INSTRUCTION SEEN VALUE
	PUSH P,INANGL		;[472] SAVE INANGL
	SETZM INANGL		;[472]
	PUSH P,INASGN		;[472] SAVE INASGN
   IFN POLISH,<
	SETZM INASGN
	PUSH P,POLTYP		;[311] SAVE AND INIT POLTYP
	SETZM POLTYP		;[311]
	PUSH P,POLITS		;[304] SAVE PTR TO LITS STILL TO FIXUP
	SETZM POLITS		;[304] START AFRESH
   >
	SKIPE LITLVL		;FIRST TIME IN LIT?
	JRST SQB5		;NO, ALREADY IN LIT, DOING NESTING
	FORERR (C,LIT)		;YES, FIRST TIME, SAVE SEQNO AND PAGE
	MOVE AC0,LITABX		;SAVE POINTER INTO LITERAL POOL
	MOVEM AC0,SQBST		;AS THE START OF LITERAL TAG FIXUP
SQB5:	AOS LITLVL		;BUMP NESTING OF LITERALS
	PUSH P,STPX		;SAVE STATE OF BINARY BUFFER
	PUSH P,STPY
	PUSH P,LSTPY		;[314] SAVE CURRENT LITERAL VARIABLES
	MOVE AC0,STPX
	MOVEM AC0,STPY
	MOVEM AC0,LSTPY		;[314]
	PUSH P,[0]		;[317] MAKE PLACE TO KEEP ERROR FLAG
	HRRM ER,0(P)		;[317] SAVE CURRENT ERROR FLAGS
	TRZ ER,ERRF		;[317] START WITH CLEAN SLATE
SQB3:	CALL STMNT
	TRNE ER,ERRORS+ERRF	;[317] ANY ERRORS THIS WORD?
	HRROS 0(P)		;[317] YES, REMEMBER FOR STOLIT
	TLO IO,IORPTC		;[314] REPEAT TERMINATOR, UNLESS...
	CAIN C,75		;[314] IT WAS A CLOSE BKT
	TLZ IO,IORPTC		;[314]
	MOVEI AC1,0		;[314] SAY "]" NOT SEEN, UNLESS...
	CAIE C,75		;[314] "]" TERMINATED STATMENT?
	TLNE FR,MWLFLG		;[314] OR NO MULTI-LINE LITS?
	TRO AC1,1		;[314] YES, NOTE LITERAL TERMINATED
	SKIPN LITLST		;[314] NEW FORMAT LISTING?
	JUMPN AC1,SQB2A		;[314] NO, JUMP IF LITERAL DONE
	SKIPE AC1		;[314] LITERAL TERMINATED?
	SOS LITLVL		;[314] YES, MUST NOT CONFUSE CHARAC
SQB4:	CALL CHARAC		;[314] BYPASS NON-SIGNIFICANT CHARS
	CAIE C," "		;[314] SPACE
	CAIN C,HT		;[314] TAB
	JRST SQB4		;[314]
	CAIN C,";"		;COMMENT?
	JRST SQB6		;YES, IGNORE SQUARE BRACKETS
SQB4A:	SKIPE AC1		;[314] LITLVL SOS'D ABOVE?
	AOS LITLVL		;[314] YES, PUT IT BACK
	CAILE C,CR		;[314] LOOK FOR END OF LINE
	JRST [	JUMPN AC1,SQB2	;[314] JUMP IF SOMETHING AFTER "]"
		CAIN C,"]"	;[314] POSSIBLY A LITERAL TERM?
		JRST SQB2A	;[314] YES
		TRO ER,ERRQ	;[534] JUNK ON LINE, OTHER THAN "]"
		JRST SQB4]	;[314] SKIP IT AND LOOK FOR EOL
	PUSH P,AC1		;[314] SAVE LITERAL TERMINATED FLAG
	CALL OUTIML		;DUMP
	POP P,AC1		;[314] RECOVER FLAG
	JUMPN AC1,SQB1		;[314] JUMP IF LITERAL TERMINATED
	CALL CHARAC		;GET ANOTHER CHAR.
	SKIPL LIMBO		;CRLF FLAG
	TLO IO,IORPTC		;NO REPEAT
	JRST SQB3

SQB6:	CALL CHARAC		;GET A CHARACTER
	CAIG C,CR
	CAIN C,HT		;LOOK FOR END OF LINE CHAR.
	JRST SQB6		;NOT YET
	JRST SQB4A		;GOT IT

SQB1:	TLNE IO,IOSALL		;[314] SALL AND IN MACRO?
	JUMPN MRP,SQB2		;[314] IF SO, DON'T REPEAT TERMINATOR
	HRRZ C,LIMBO		;[314] GET TERMINATOR
	SOSG CPL		;[314] PUT IT IN IMAGE BUFFER
	CALL RSW5		;[314]
	IDPB C,LBUFP		;[314]
SQB2:	TLO IO,IORPTC		;[314] REPEAT TERMINATOR
SQB2A:	SKIPGE 0(P)		;[317] ERROR ANYWHERE IN LITERAL?
	TRO ER,ERRF		;[317] YES, PREVENT COMPRESSION
	MOVE AC1,LITNUM		;[520] LITNUM GET UPDATED IN STOLIT
	MOVEM AC1,LITN		;[520] WE NEED CURRENT LITNUM FOR SQBTGS
				;[520] SO SAVE IN LITN IN CASE WE NEED IT
	CALL STOLIT		;[314]
	SKIPE LBLPNT		;[516] ANY TAGS IN LITERAL TO FIX UP?
	CALL SQBTGS		;[516] YES, (ONLY ON PASS2)
	POP P,AC1		;[317] RECOVER ER AS BEFORE LIT
	TRNE AC1,ERRORS+ERRF	;[317] ANY ERRORS?
	TRO ER,ERRF		;[317] YES, KEEP ONLY ERRF
	POP P,LSTPY		;[314] RESTORE LITERAL VARIABLES
	POP P,STPY		;RESTORE PREVIOUS STATE OF CODE BUFFER
	POP P,STPX
	SOS LITLVL		;ONE LESS NESTING OF LITERALS
   IFN POLISH,<
	SKIPE POLITS		; NEED TO FIXUP ANY POLISH?
	CALL SQBPOL		; YES
	POP P,POLITS		;[304] RESTORE NEXT LEVEL PTR
	POP P,POLTYP		;[311] RESTORE POLTYP
   >
	POP P,INASGN		;[472] RESTORE NEXT LEVEL INASGN
	POP P,INANGL		;[472] RESTORE NEXT LEVEL INANGL
   IFN FORMSW,<	POP P,IOSEEN>	;[344] RESTORE IOSEEN FOR LISTING
	POP P,EXTPNT
	POP P,FR
	POP P,TAGINC		;[402] RESTORE PREVIOUS OFFSET
	POP P,TAG		;[402] AND LABEL
	SETZM LBLFLG		;[402] ZERO 'LABEL-INLITERAL' FLAG
	SETZM LTGINC		;[402] AND MARKER
	SKIPE LITLVL		;WERE WE NESTED?
	JUMP1 SQB2F		;[301] YES, FORCE ERROR IF PASS 1
	JUMP2 GETDEL		; USE VALUE GIVEN IF PASS 2
	TRO ER,ERRU		; VALUE IS UNDEFINED ON PASS 1
	TDZA AC0,AC0		;[301] SO SET IT TO 0
SQB2F:	TRO ER,ERRF		;[301] SET FAKE ERROR FLAG
	JRST GETDEL		;

;HERE ONLY DURING PASS2, WHEN THERE ARE TAGS IN LITERAL TO BE FIXUP.
;ONLY THE TAGS THAT BELONG TO THE SAME LEVEL AS THE LITERAL NOW
;BEING CLOSED ARE FIXED.
;ALL MEMORY LOCATIONS RELATED TO THE PROCESSING OF TAGS IN LITERALS
;ARE CLEARED WHEN THE OUTER MOST (LEVEL 1) LITERAL IS BEING CLOSED.
;
SQBTGS:	PUSH P,RC		;SAVE BUNCH OF ACS THAT WE NEED
	PUSH P,V
	PUSH P,AC0
	PUSH P,AC1
	PUSH P,ARG
	PUSH P,SX
	MOVE AC2,LITHDX		;GET HEADER BLOCK
	HLRZ RC,-1(AC2)		;GET BLOCK RELOCATION
	MOVEM RC,LITRC		;SAVE IT
	HRRZ AC0,-1(AC2)	;
	ADD AC0,LITN		;COMPUTE ACTUAL LOCATION
	MOVEM AC0,LITV		;ACTUAL START LOCATION OF THIS LITERAL
	MOVE AC1,LBLPNT		;GET START OF LITERAL TAG CHAIN
SQBTG1:	HRRZ AC0,(AC1)
	MOVEM AC0,LBLNXT	;ADDRESS OF NEXT BLOCK IN CHAIN
	HLRZ AC0,(AC1)		;GET LIT LEVEL
	CAME AC0,LITLVL		;SAME AS THE LITERAL BEING CLOSED?
	JRST [	MOVEM AC1,LBLPNT ;NO, UPDATE CHAINS STARTING ADDR
		JRST SQBTG3]	;GO RESTORE ACS AND RETURN
	MOVE AC0,1(AC1)		;YES, GET TAG NAME
	PUSH P,AC1		;SSRCH USES AC1
	CALL SSRCH		;SETUP POINTER INTO SYMBOL TABLE
	  JRST SQBTG5		;NO REFERENCE WAS MADE
	MOVE AC1,ARG		;REFERENCE WAS MAKE
	HRRZM AC1,SQBRC		;KEEP FAKE EXTERNAL POINTER
SQBTG5:	POP P,AC1
	HLLZ ARG,2(AC1)		;GET ARG FLAGS
	TLZ ARG,EXTF		;MAKE SURE EXTERNAL FLAG IF OFF
	HRRZ V,2(AC1)		;GET OFFSET
	ADD V,LITV		;ADD IN THE START LOCATION
	MOVEI RC,-1		;PUT -1 AS LIT LEVEL
	HRLM RC,(AC1)		;TO FLAG THIS TAG HAS BEEN PROCESSED
	MOVE RC,LITRC		;GET BLOCK RELOCATION
	CALL INSERT		;ADD TO THE SYMBOL TABLE
	SKIPE SQBRC		;WAS IT REFERENCED?
	CALL SQBFIX		;YES, GO FIXUP
SQBTG2:	SKIPE AC1,LBLNXT	;ARE THERE ANY MORE TAGS TO FIXUP?
	JRST SQBTG1		;YES,
SQBTG3:	MOVE SX,LITLVL		;OUTERMOST LITERAL BEING CLOSED?
	SOJG SX,SQBTG4		;NO, JUMP
	SETZM LBLPNT		;YES, CLEAR MEMORY LOCATIONS
	SETZM LBLNXT
	SETZM LITV
SQBTG4:	POP P,SX		;NO, RESTORE ACS
	POP P,ARG
	POP P,AC1
	POP P,AC0
	POP P,V
	POP P,RC
	RET


;HERE IF THE TAG BEING DEFINED AT END OF A LITERAL WAS
;REFERECED, THUS A TAG FIXUP INTO LITERAL POOL IS NEEDED
;
SQBFIX:	MOVE ARG,SQBRC		;GET FAKE EXTERAL PTR
	CAMN AC0,1(ARG)		;MAKE SURE WE HAVE THE RIGHT TAG
	JRST SQBFX1		;YES, GO CHECK LITERAL POOL
	TRO ER,ERRQ		;NO,SET Q ERROR
	RET			;RETURN BEFORE WE DO REAL DAMAGE
SQBFX1:	MOVE AC1,[1,,1]	;AC1 USED TO UPDATE RELOC WORD
	MOVE SX,SQBST		;GET THE START OF THIS LIT SCOPE
SQBFX2:	MOVE SX,(SX)
	HRRZ RC,-1(SX)
	CAME RC,ARG		;THIS ONE NEEDS FIXING?
	JRST SQBFX3		;NO,
	ADDM V,-2(SX)		;ADD IN THE VALUE
	HRRM AC1,-1(SX)
SQBFX3:	HLRZ RC,-1(SX)
	CAME RC,ARG
	JRST SQBFX4
	HRLZ RC,V
	ADDM RC,-2(SX)
	HLLM AC1,-1(SX)
SQBFX4:	CAMGE SX,LITABX
	JRST SQBFX2
	SETZM SQBRC
	RET

   IFN POLISH,<			;
;HERE TO FIXUP POLISH EXPRESSIONS INSIDE CURRENT LIT
;AS EACH ONE IS FIXED MOVE IT TO POLIST
SQBPOL:	PUSH P,CS		;GET SOME FREE ACCS
	PUSH P,AC0		;SAVE LOC
SQBPL1:	MOVE CS,@POLITS		;GET A BLOCK POINTER
	EXCH CS,POLITS		;SET FOR NEXT TIME
	MOVE AC0,CS		;GET A COPY
	EXCH AC0,POLIST		;STORE IN LIST OF "GOOD" POLISH
	MOVEM AC0,(CS)		;LINK IN
SQBPL2:	ADDI CS,1		;FIRST WORD
	MOVE AC0,(CS)		;GET SOMETHING
	JUMPL AC0,SQBPL5	;THIS IS AN OPERATOR
	JUMPE AC0,SQBPL4	;18 BIT VALUE
	SOJE AC0,SQBPL3		;36 BIT VALUE
	AOJA CS,SQBPL2		;SYMBOL

SQBPL3:	ADDI CS,1		;SKIP OVER 2 WORDS
SQBPL4:	AOJA CS,SQBPL2		;GET NEXT

SQBPL5:	HRRZ AC0,AC0		;GET OPERATOR ONLY
	CAIGE AC0,-6		; CHECK FOR STORE OP
	JRST SQBPL2		;ITS NOT
	MOVE AC0,0(P)		;GET ADDRESS
	ADDM AC0,1(CS)		;ADD TO OFFSET
	HRLM RC,1(CS)		;SET RELOCATION
	SKIPE POLITS		;MORE TO DO?
	JRST SQBPL1		;YES
	POP P,AC0		;RESTORE LOC
	POP P,CS		;AND SAVED AC
	RET
   >

SUBTTL NUMBER PROCESSOR

ANGLB:   IFN POLISH,<
	PUSH P,INANGL		;[305] PUSH CURRENT STACK PTR OR MARKER
	SETOM INANGL		;NOTE STARTING ANG BKTS
   >
	PUSH P,FR
	TLZ FR,INDSW+POLSW
	CALL ATOM
	TLNN IO,NUMSW
	CAIE C,35		; =
	JRST ANGLB1
	CALL ASSIG1
	MOVE AC0,V
	JRST ANGLB2

ANGLB1:	CALL EVALHA
ANGLB2:	POP P,FR
   IFN POLISH,<
	SETCM AC1,INANGL	;GET FLAG
	JUMPN AC1,[MOVE RC,INANGL ;GET PROPER POINTER
		CALL MOVSTK	;MOVE STACK TO FREE STORAGE
		TLO FR,POLSW	;NOTE ARE DOING POLISH
		JRST .+1]
	POP P,INANGL		;[305] GET CURRENT STATUS
   >
	CAIE C,36		; CLOSE ANGBKT?
	TRO ER,ERRN
	JRST GETDEL

PERIOD:	CALL GETCHR		;LOOK AT NEXT CHARACTER
	TLNN CS,2		;ALPHABETIC?
	JRST PERNUM		;NO, TEST NUMERIC
	MOVSI AC0,'.  '		;YES, PUT PERIOD IN AC0
	MOVSI AC2,(POINT 6,AC0,5) ;SET BYTE POINTER
	JRST LETTE2		;AND TREAT AS SYMBOL

PERNUM:	TLNE CS,4		;IS IT A NUMBER
	JRST NUM32		;YES
	MOVE AC0,LOCA		;NO. CURRENT LOC SYMBOL (.)
	MOVE RC,MODA		;SET TO CURRENT ASSEMBLY MODE
	JRST GETDE1		;GET DELIMITER
NUMDF:	TLO FR,DCFSW		;SET DECIMAL FRACTION FLAG
NUM:	CALL GETCHR		;GET A CHARACTER
	TLNN CS,4		;NUMERIC?
	JRST NUM10		;NO
NUM1:	SUBI C,20		;CONVERT TO OCTAL
	PUSH P,C		;STACK FOR FLOATING POINT
	SKIPE AC0		;ARE WE ABOUT TO LOSE SOME DATA?
	TRO ER,ERRQ		;YES, AT LEAST WARN USER
	MOVE AC0,AC1
	MULI AC0,0(RX)
	ADD AC1,C		;ADD IN LAST VALUE
	CAIL C,0(RX)		;IS NUMBER LESS THAN CURRENT RADIX?
	TLO FR,RADXSW		;NO, SET FLAG
	AOJA AC2,NUM		;YES, AC2=NO. OF DECIMAL PLACES

NUM10:	CAIE C,'.'		;PERIOD?
	TLNE FR,DCFSW		;OR DECIMAL FRACTION?
	JRST NUM30		;YES, PROCESS FLOATING POINT
	SETZ CS,		;AND CLEAR IT
	CAIN C,'K'		;SEE IF SUFFIX THERE
	MOVEI CS,3
	CAIN C,'M'
	MOVEI CS,6
	CAIN C,'G'
	MOVEI CS,9
	JUMPE CS,NUM12		;NO SUFFIX?
	MOVE AC0,AC1		;SCALE THE NUMBER
	MULI AC0,(RX)
	SOJG CS,.-2
	CALL GETCHR		;SKIP THE SUFFIX
NUM12:	MOVE CS,CSTAT(C)	;RESTORE STATUS
	LSH AC1,1		;NO, CLEAR THE SIGN BIT
	LSHC AC0,^D35		;AND SHIFT INTO AC0
	MOVE P,PPTEMP		;RESTORE P
	SOJE AC2,GETDE1		;NO RADIX ERROR TEST IF ONE DIGIT
	TLNE FR,RADXSW		;WAS ILLEGAL NUMBER ENCOUNTERED?
	TRO ER,ERRN		;YES, FLAG N ERROR
	JRST GETDE1

NUM30:	CAIE C,'B'		;IF "B" THEN MISSING  "."
NUM31:	CALL GETCHR
	TLNN CS,4		;NUMERIC?
	JRST NUM40		;NO
NUM32:	SUBI C,20
	PUSH P,C
	JRST NUM31

NUM40:	PUSH P,FR		;STACK VALUES
	HRRI RX,^D10
	PUSH P,AC2
	PUSH P,PPTEMP
	CAIN C,45		;"E"?
	JRST [CALL PEEK		;GET NEXT CHAR
		PUSH P,C	;SAVE NEXT CHAR
		CALL CELL	;YES, GET EXPONENT
		POP P,C		;GET FIRST CHAR. AFTER E
		CAIN V,4	;MUST HAVE NUMERICAL STATUS
		JRST .+2	;SKIP RETURN
		CAIN C,"<"	;ALLOW <EXP>
		JRST .+2	;SKIP RETURN
		SKIPN AC0	;ERROR IF NON-ZERO EXPRESSION
		TROA ER,ERRQ	;ALLOW E+,E-
		SETOM RC	;FORCE NUMERICAL ERROR
		JRST .+2]	;SKIP RETURN
	MOVEI AC0,0		;NO, ZERO EXPONENT
	POP P,PPTEMP
	POP P,SX
	POP P,FR
	HRRZ V,P
	MOVE P,PPTEMP
	JUMPN RC,NUMER1		;EXPONENT MUST BE ABSOLUTE
	ADD SX,AC0
	HRRZ ARG,P
	ADD SX,ARG
	SETZB AC0,AC2
	TLNE FR,DCFSW
	JRST NUM60
	JOV NUM50		;CLEAR OVERFLOW FLAG


NUM50:	JSP SDEL,NUMUP		;FLOATING POINT
	JRST NUM52		;END OF WHOLE NUMBERS
	FMPR AC0,[10.0]		;MULTIPLY BY 10
	TLO AC1,233000		;CONVERT TO FLOATING POINT
	FADR AC0,AC1		;ADD IT IN
	JRST NUM50

NUM52:	JSP SDEL,NUMDN		;PROCESS FRACTION
	FADR AC0,AC2
	JOV NUMER1		;TEST FOR OVERFLOW
	JRST GETDE1

	TLO AC1,233000
	TRNE AC1,-1
	FADR AC2,AC1		;ACCUMULATE FRACTION
	FDVR AC2,[10.0]
	JRST NUM52

NUM60:	JSP SDEL,NUMUP
	JRST NUM62
	IMULI AC0,^D10
	ADD AC0,AC1
	JRST NUM60

NUM62:	LSHC AC1,-^D36
	JSP SDEL,NUMDN
	LSHC AC1,^D37
	CALL BYPAS2
	JRST GETDE3

	DIVI AC1,^D10
	JRST NUM62

NUMUP:	MOVEI AC1,0
	CAML ARG,SX
	JRST 0(SDEL)
	CAMGE ARG,V
	MOVE AC1,1(ARG)
	AOJA ARG,1(SDEL)

NUMDN:	MOVEI AC1,0
	CAMG V,SX
	JRST 0(SDEL)
	CAMLE V,ARG
	MOVE AC1,0(V)
	SOJA V,3(SDEL)


SUBTTL GETSYM
GETSYM:	MOVEI AC0,0		;CLEAR AC0
	MOVSI AC1,(POINT 6,AC0)	;PUT POINTER IN AC1
	BYPASS			;SKIP LEADING BLANKS
	TLNN CS,2		;ALPHABETIC?
	JRST GETSY1		;NO, ERROR
	CAIE C,16		;PERIOD?
	JRST GETSY2		;NO, A VALID SYMBOL
	IDPB C,AC1		;STORE THE CHARACTER
	CALL GETCHR		;YES, TEST NEXT CHARACTER
	TLNN CS,2		;ALPHABETIC?
GETSY1:	TROA ER,ERRA
GETSY2:	AOS 0(P)		;YES, SET SKIP EXIT
GETSY3:	TLNN CS,6		;ALPHA-NUMERIC?
	JRST GETSY4		;[313] NO
	TLNE AC1,770000		;YES, HAVE WE STORED SIX?
	IDPB C,AC1		;NO, STORE IT
	CALL GETCHR
	JRST GETSY3

	CALL GETCHR		;[314] TRY AGAIN FOR TERMINATOR
GETSY4:	JUMPE C,.-1		;[314] BYPASS TRAILING TAB/SP
	TLNE CS,6		;[314] ALPHANUMERIC?
	TLO IO,IORPTC		;[314] YES, PUT IT BACK
	RET			;[314]


SUBTTL EXPRESSION EVALUATOR
CV==AC0				;CURRENT VALUE
PV==AC1				;PREVIOUS VALUE
RC=RC				;CURRENT RELOCATABILITY
PR==AC2				;PREVIOUS RELOCATABILITY
CS=CS				;CURRENT STATUS
PS==SDEL			;PREVIOUS STATUS

EVALHA:	TLO FR,TMPSW
EVALCM:	CALL EVALEX		;EVALUATE FIRST EXPRESSION
	PUSH P,[0]		;MARK PDL
	JUMPCM EVALC3		;JUMP IF COMMA
	TLO IO,IORPTC		;IT'S NOT,SO REPEAT
	JRST OP			;PROCESS IN OP
EVALC3:
   IFN POLISH,<
	TLNN FR,POLSW		;[305] POLISH FIXUP SEEN?
	JRST EVALC4		;[305] NO
	SETOM POLTYP		;[305] REST MUST BE RIGHT HALF
	MOVNI AC2,2		;[305] CHANGE THIS TO LEFT HALF
	SKIPE INASGN		;[305] BUT IF SYMBOLIC
	MOVNI AC2,4		;[305] USE CORRECT STORE OP
	MOVEM AC2,@LSTOPR	;[305]
EVALC4:>
   IFN FORMSW,<PUSH P,INFORM>	;PUT FORM WORD ON STACK
	PUSH P,[0]		;STORE ZERO'S ON PDL
	PUSH P,[0]		;.......
	MOVSI AC2,(POINT 4,(P),12)
	JRST OP1B		;PROCESS IN OP

EVALEX:	TLO IO,FLDSW
   IFN POLISH,<
	TLNN FR,TMPSW		;UNLESS FIRST ATOM ALREADY READ,
	TLZ FR,POLSW		; CLEAR EVALUATING POLISH FLAG
   >
	PUSH P,[TNODE,,0]	;MARK THE LIST 200000,,0
	TLZN FR,TMPSW
EVATOM:	CALL ATOM		;GET THE NEXT ATOM
	JUMPE AC0,EVGETD	;TEST FOR NULL/ZERO
	TLOE IO,NUMSW		;SET NUMERIC, WAS IT PREVIOUSLY?
	JRST EVGETD+1		;YES, TREAT ACCORDINGLY
	CALL SEARCH		;SEARCH FOR MACRO OR SYMBOL
	  JRST EVOP		;NOT FOUND, TRY FOR OP-CODE
	JUMPGE ARG,EVAS1	;JUMP IF HAVE OPERATOR
	CAME AC0,1(SX)		;HAVE SYMBOL, OPERATOR ALSO DEFINED?
	JRST EVAS2		;NO, USE WHAT WE HAVE
	ADDI SX,2		;CHECK OPERATOR FIRST
	CALL SRCH5		;LOAD REGISTERS
EVAS1:	SKIPN MACPRF		;MACRO DEF PREFERRED?
	JRST EVAS3		;NO
	TLNE ARG,MACF+SYNF	;MACRO OR SYN?
	JRST EVAS2		;YES, USE IT
EVAS3:	CAME AC0,-3(SX)		;NO, PROBABLY OPDEF.  SYMBOL ALSO DEFINED?
	JRST EVAS2		;NO, USE WHAT WE HAVE
	SUBI SX,2		;YES, SYMBOL BEFORE OPDEFS HERE
	CALL SRCH5		;LOAD REGISTERS
EVAS2:	CALL QSRCH		;CREF WHAT WE FOUND
   IFN POLISH,<
	JUMPGE RC,.+3		;[305] IS IT A POLISH FIXUP?
	TLO FR,POLSW		;[305] YES, FORCE FLAG ON
	SETZM EXTPNT		;[305] AVOID "E" ERRORS
   >
	JUMPG ARG,EVMAC		;BRANCH IF OPERATOR
	MOVE AC0,V		;SYMBOL, SET VALUE
	JRST EVTSTS		;TEST STATUS

EVMAC:	TLNE FR,NEGSW		;UNARY MINUS?
	JRST EVERRZ		;YES, INVALID BEFORE OPERATOR
	LDB SDEL,[POINT 3,ARG,5] ;GET MACF/OPDF/SYNF
	SOJL SDEL,EVERRZ	;ERROR IF NO FLAGS

	JUMPE C,.+2		;NON-BLANK?
	TLO IO,IORPTC		;YES, REPEAT CHARACTER
	SOJE SDEL,EVMAC1	;MACRO IF 2
	JUMPG SDEL,EVOPS	;SYNONYM IF 4

	MOVE AC0,V		;OPDEF
	MOVEI V,OP		;SET TRANSFER VECTOR
	JRST EVOPD


EVMAC1:	SKIPL MACENL		;ALREADY IN CALLM?
	JRST CALLM		;NO, EVALUATE MACRO
	SETZB RC,AC0		;ZERO VALUE
	TRO ER,ERRA		;SET "A" ERROR
	JRST EVGETD		;CONTINUE EVALUATION

EVOP:	CALL OPTSCH		;[363] SEARCH OP TABLE
	  JRST EVOPX		;[363] NOT FOUND
	TLNE FR,NEGSW		;[363] OPCODE, UNARY MINUS?
	JRST EVERRZ		;[363] YES, ERROR
EVOPS:	TRZ V,LITF		;CLEAR LIT INVALID FLAG
	TRZE V,ADDF		;SYNONYM
	JRST EVOPX		;PSEUDO-OP THAT GENERATES NO DATA JUMPS
	HLLZ AC0,V
EVOPD:	JUMPCM .+2		;TERMINATED WITH COMMA?
	TLNE CS,(17B5)		;TERMINATED WITH OPERATOR? (+,-,ETC.)
	JRST [	HRRZ AC1,V	;YES
		CAIE AC1,OP	;REGULAR OP?
		JRST .+1	;NO, MUST EXECUTE IT
		JRST EVTSTS]	;YES, TREAT AS SYMBOL
	SKIPE C			;NON-BLANK DELIMITER?
	TLO IO,IORPTC		;YES, REPEAT CHARACTER
	PUSH P,LOCA		;SAVE CURRENT LOCATION
	PUSH P,STPX		;SAVE CURRENT CODE BUFFER STATE
	PUSH P,STPY
	MOVE AC1,STPX
	MOVEM AC1,STPY
	CALL 0(V)		;DO OP
	MOVE AC2,STPX		;SEE HOW MANY WORDS GENERATED
	SUB AC2,STPY
;	CAIE AC2,1		;SHOULD BE ONE, BUT MANY PROGRAMS
;	TRO ER,ERRQ		; USE <> TO TRUNCATE, E.G. ASCII
	CALL DSTOW		;AC0 = WORD OF CODE GENERATED
	POP P,STPY		;RESTORE CODE BUFFER
	POP P,STPX
	POP P,LOCA		;RESTORE CURRENT LOCATION
	TRNE RC,-2
	HRRM RC,EXTPNT
	TLNE RC,-2
	HLLM RC,EXTPNT
	JRST EVNUM

EVOPX:	MOVSI ARG,SYMF!UNDF
	CALL INSERZ
EVERRZ:	SETZB AC0,RC		;CLEAR CODE AND RELOCATION
EVERRU:	TRO ER,ERRU
	JRST EVGETD


EVTSTS:	TLNE ARG,UNDF
	JRST [TRO ER,ERRU	;SET UNDEF ERROR
		JUMP1 EVGETD	;TREAT AS UNDF ON PASS1
		JRST .+1]	;TREAT AS EXTERNAL ON PASS2
	TLNN ARG,EXTF
	JRST EVTSTR
	HRRZ RC,ARG		;GET ADRES WFW
	HRRZ ARG,EXTPNT		;SAVE IT WFW
	HRRM RC,EXTPNT		;WFW
   IFE POLISH,<			; NOT NEEDED SINCE POLISH WILL TAKE CARE OF EXTERNS
	TRNE ARG,-1		;WFW
	TRO ER,ERRE
   >
	SETZB AC0,ARG

EVTSTR:	TLNE ARG,MDFF		;MULTIPLY DEFINED?
	TRO ER,ERRD		;YES, FLAG IT
	TLNN FR,NEGSW		; NEGATIVE ATOM?
	JRST EVGETD		; NO
   IFN POLISH,<
	TDNE RC,[-2,,-2]	; EXTERNALS?
	JRST NEGEXT		; YES, MUST BE UNARY MINUS
   >
	CALL GETDE2		; NO, JUST NEGATE
EVGETD:	TLNE IO,NUMSW		;NON BLANK FIELD
	TLO FR,FSNSW		;YES,SET FLAG
	CALL BYPAS2
	TLNE CS,6		;ALPHA-NUMERIC?
	TLO IO,IORPTC		;YES, REPEAT IT
	CAIN C,'^'		; IS THIS THE SPECIAL ESCAPE CHAR?
	JRST EVUPAR		; YES, SEE WHAT FOLLOWS
EVUPAT:				;[333] LABEL FOR RETURN FROM ^
   IFN POLISH,<
	TLZN IO,RSASSW		;INTER-PSECT REFERENCE?
	JRST EVNUM		;NO
	PUSH P,SGWFND		;INX OF PSECT REFERRED TO
	PUSH P,[-1]		;DUMMY RELOCATION
	PUSH P,CSTATP>		;ADDITIVE PSECT OPERATION
EVNUM:	POP P,PS		;POP THE PREVIOUS DELIMITER/TNODE
	TLO PS,4000
   IFN POLISH,<
	TLC PS,110000		;TEST FOR BITS 2 AND 5
	TLCN PS,110000		; BOTH ON - MEANS ADDITIVE
	JRST EVXCT>		; PSECT OPERATION
	CAMGE PS,CS		;OPERATION REQUIRED?
	JRST EVPUSH		;NO, PUT VALUES BACK ON STACK
	TLNN PS,TNODE		;YES, HAVE WE REACHED TERMINAL NODE?
	JRST EVXCT		;NO, EXECUTION REQUIRED
	TLNE CS,170000		; YES, ARE WE POINTING AT DEL? (& ! * / + - _)
	JRST EVPUSH		; NO,FALL INTO EVPUSH
   IFN POLISH,<
	TLNE FR,POLSW		; BEEN RESOLVING POLISH?
	JRST POLPOP		; YES, OUTPUT IT
   >
	RET			;NO, EXIT

;HERE TO HANDLE "^!"

EVUPAR:	SETZM UPARRO		;[333] CLEAR ^ COUNTER ONCE IN A WHILE
	CALL PEEK		;[333] SEE WHAT CHARACTER AFTER ^ IS
	SETZ CS,		;[333] AND CHECK FOR ! AFTER IT
	CAIN C,"!"		;[333] IS IT ! FOR ^!
	SKIPA CS,CSTATX		;[333] YES, GET SPECIAL POINTER
	JRST EVUPAN		;[416] NOT ^!
	TLZ IO,IORPTC		;[337] CLEAR REREAD
	SKIPE MRP		;[357] IF IN A MACRO
	CALL MREAD		;[357] BETTER DO THIS
	SUBI C,40		;[333] YES, CHANGE TO SIXBIT
	JRST EVNUM		;[333] AND EVALUATE
EVUPAN:	CAIN C,"-"		;WAS IT ^-
	TRO ER,ERRQ		;GIVE A Q ERROR IF ^- IS USED AS BINARY OPTR
	MOVEI C,'^'		;[333] RESTORE C
	MOVE CS,CSTAT(C)	;[333] AND CS
	SETOM UPARRO		;[333] SET FLAG FOR CELL1 TO RE-EAT ^
	JRST EVUPAT		;[333] AND CONTINUE FROM ^


EVPUSH:	PUSH P,PS		;STACK VALUES
	PUSH P,CV
	PUSH P,RC
	PUSH P,CS
	JRST EVATOM		;GET NEXT ATOM

EVXCT:	POP P,PR		;POP PREVIOUS RELOCATABILITY
	POP P,PV		;AND PREVIOUS VALUE
	LDB PS,[POINT 4,PS,29]	; TYPE OF OPERATION TO PS
   IFE POLISH,<
	XCT EVTAB(PS)		; PERFORM PROPER OPERATION
	JUMPN RC,.+2		;COMMON RELOCATION TEST
EVXCT1:	JUMPE PR,EVNUM
	TRO ER,ERRR		;BOTH MUST BE FIXED
	JRST EVNUM		;GO TRY AGAIN

EVTAB:	JRST ASSEM1		;0; SHOULD NEVER GET HERE ;DMN
	JRST XMUL		;1;
	JRST XDIV		;2;
	JRST XADD		;3;
	JRST XSUB		;4;
	JRST XLRW		;5; "_"
	IOR CV,PV		;6; MERGE PV INTO CV
	AND CV,PV		;7; AND PV INTO CV
	XOR CV,PV		;10; XOR PV INTO CV
	SETCM CV,CV		;11; NOT (ONE'S COMPLIMENT)
REPEAT 6,<CALL EVXERR>		;[527] 12-17; JUST INCASE
   >
   IFN POLISH,<
	CAILE PS,11		; OPS 12 AND 13
	JRST POLPSH		;  REQUIRE POLISH FIXUPS
	TDNN RC,[777700,,777700] ;[447] CHECK FOR EXTERNALS IN EITHER 
	TDNE PR,[777700,,777700] ;[447] OPERAND -- .LE. 100 ALLOWED
	JRST EVXCT2		;[455]
EVXCT3:	XCT PRTAB(PS)		;TEST PREVIOUS RELOCATION
	JUMPN RC,POLPSH		;GO POLISH IF BOTH OPERANDS RELOC'L
EVXCT1:	JFCL 17,.+1		; CLEAR OVERFLOW FOR * AND /
	XCT EVTAB(PS)		; PERFORM PROPER OPERATION
	SKIPL OKOVFL		;[362] OVERFLOW OK?
	JOV .+2			; SKIP IF * OR / OVERFLOWED
	SKIPA			; IT'S OK
	TRO ER,ERRN		; SET N ERROR FOR OVERFLOW
	JRST EVNUM		;GO TRY AGAIN

EVTAB:	JRST ASSEM1		;0; SHOULD NEVER GET HERE ;DMN
	IMULM PV,CV		;1; MUL
	IDIVM PV,CV		;2; DIV
	JRST XADD		;3;
	JRST XSUB		;4;
	CALL XLRW		;5; "_"
	IOR CV,PV		;6; MERGE PV INTO CV
	AND CV,PV		;7; AND PV INTO CV
	XOR CV,PV		;10; XOR PV INTO CV
	SETCM CV,CV		;11; NOT (ONE'S COMPLIMENT)
	MOVN CV,CV		;12; NEGATE (TWO'S COMPLEMENT)
	JFCL			;13; ADDITIVE PSECT OPERATION
REPEAT 4,<CALL EVXERR>		;[527] 14-17; JUST INCASE

EVXCT2:	CAIGE RC,100		;[447] ALLOW VALUES
	CAMG RC,[-100]		;[447] BETWEEN 100 TO -100
	JRST EVXCT4		;[447] POLISH
	CAIGE PR,100		;[447] SAME CHECK FOR EITHER
	CAMG PR,[-100]		;[447] OPERANDS
	JRST EVXCT4		;[447] POLISH
	JRST EVXCT3		;[455] GO BACK
EVXCT4:	SKIPN UWVER		;[454] WILL BE WRITING A UNV FILE?
	JRST EVXCT5		;[454] NO,
	BITON UPOL,UWVER	;[454] YES, INCLUDE POLISH BIT
EVXCT5:	JUMP2 POLPSH		;[455] DO POLISH ONLY IN PASS2
	SKIPE LITLVL		;[455] IS THIS POLISH IN A LITERAL?
	TRO ER,ERRF		;[455] YES, DONT COLLAPSE
	JRST EVXCT3		;[455] GO BACK

NEGEXT:	MOVSI PS,4000		;[535] FAKE UP EVPUSH OF
	ADDM PS,(P)		;  PS
	PUSH P,[0]		;  CV
	PUSH P,[0]		;  RC
	PUSH P,CSTATM		;  CS
	TLZ FR,NEGSW		; CLEAR FLAG
	JRST EVGETD		; NOW EVALUATE

PRTAB:	JFCL			;0
	JRST CHKPR		;1 MUL
	JRST CHKPRD		;2 DIV
	JRST EVXCT1		;[447] 3 ADD--NO CHECK DIS ONE ON
	JRST EVXCT1		;[447] 4 SUB--OPERANDS FOR ADD & SUB
	JRST CHKPRD		;5 SHIFT
	JRST CHKIOR		;6 IOR
	JRST CHKPR		;7 AND
	JRST CHKPR		;10 XOR
	JUMPN RC,POLPSH		;11 NOT

;CHECK RELOCATION WHERE SECOND OPERAND MUST BE ABSOLUTE

CHKPRD:	JUMPN RC,POLPSH		;GO POLISH IF SECOND ARG NOT ABSOLUTE

;CHECK RELOCATION FOR MULTIPLICATIVE OPERATORS

CHKPR:	SKIPN PR		;FIRST OPERAND RELOCATABLE?
	JRST [	JUMPE RC,EVXCT1	;NO, JUMP IF SECOND ALSO NOT RELOC
		PUSH P,PV	;SAVE VALUES
		PUSH P,CV
		SETZ CV,	;CONSTRUCT EQUIVALENT RELOCATABLE VALUE
		TRNE RC,-1	;RH?
		HRRI CV,-1	;YES
		TLNE RC,-1	;LH?
		HRLI CV,-1	;YES
		JRST CHKPR2]	;DO OPERATION AND TEST RESULTS
	JUMPN RC,POLPSH		;POLISH REQUIRED IF BOTH RELOCATABLE
	PUSH P,PV		;SAVE VALUES
	PUSH P,CV
	SETZ PV,		;CONSTRUCT EQUIVALENT RELOCATABLE VALUE
	TRNE PR,-1		;RH?
	HRRI PV,-1		;YES
	TLNE PR,-1		;LH?
	HRLI PV,-1		;YES
CHKPR2:	XCT EVTAB(PS)		;DO OPERATION ON RELOCATION EQUIVALENT
	SETO RC,		;FIGURE OUT WHAT HAPPENED...
	TLCN CV,-1		;LH 0?
	HRLI RC,0		;YES
	TLCN CV,-1		;LH 1?
	HRLI RC,1		;YES
	TRCN CV,-1		;RH 0?
	HRRI RC,0		;YES
	TRCN CV,-1		;RH 1?
	HRRI RC,1		;YES
	POP P,CV		;RECOVER VALUES
	POP P,PV
	TDNN RC,[-2,,-2]	;RELOC COUNTS OTHER THAN 0 OR 1?
	JRST EVXCT1		;ALL IS WELL, DO OPERATION
	SETZ RC,		;YES, GO POLISH
	JRST POLPSH

;CHECK RELOCATION FOR IOR

CHKIOR:	TDNE RC,PR		;ANY HALFWORDS IN COMMON?
	JRST POLPSH		;YES, GO POLISH

;CHECK EACH HALFWORD AGAINST THE RELOCATION COUNT IN THAT HALFWORD
;FOR THE OTHER OPERAND

DEFINE TST (OP,RR,VV)<
	OP RR,-1		;;RELOCATION NON-0?
	JRST [	OP VV,-1	;;YES, VALUE NON-0?
		JRST POLPSH	;;YES, GO POLISH
		JRST .+1]>	;;NO, CONTINUE

	TST TRNE,RC,PV
	TST TLNE,RC,PV
	TST TRNE,PR,CV
	TST TLNE,PR,CV
	JRST EVXCT1		;PASSED ALL TESTS, DO OPERATION

XLRW:	EXCH PV,CV
	LSH CV,0(PV)
	RET
   >

;HERE IF THERE IS PROBLEM WITH EXPRESSION PARSING AND EVALUATION
;GETTING ILLEGAL OPERATORS
;
EVXERR:	HRROI RC,[SIXBIT/EPP EXPRESSION PARSING PROBLEM @/] ;[527]
	JUMP1 .+2		;[537] INCREMENT ERRCNT ON PASS2
	AOS ERRCNT		;[537]
	JRST ERRNE0		;[527] COMMON ERROR MSG--WILL AT LEASE
				;[527] TYPE PAGE NO. THEN CONTINUE



XSUB:	SUBM PV,CV
	SUBM PR,RC
	JRST EVNUM

XADD:	ADDM PV,CV
	ADDM PR,RC
	JRST EVNUM

   IFE POLISH,<
XDIV:	IDIV PR,CV		;CORRECT RELOCATABILITY
	JFCL 17,.+1		; CLEAR OVERFLOW
	IDIVM PV,CV
	SKIPL OKOVFL		; SKIP IF OVERFLOW OK
	JOV .+2			; SEE IF OVERFLOWED
	SKIPA			; NO
	TRO ER,ERRN		; YES, SET N ERROR
XDIV1:	EXCH PR,RC		;TAKE RELOCATION OF NUMERATOR
	JRST EVXCT1

XMUL:	JUMPE PR,XMUL1		;AT LEAST ONE OPERAND
	JUMPE RC,XMUL1		;MUST BE FIXED
	TRO ER,ERRR
XMUL1:	IORM PR,RC		;GET RELOCATION TO RC
	CAMGE PV,CV		;FIND THE GREATER
	EXCH PV,CV		;FIX IN CASE CV=0,OR 1
	IMULM PV,RC
	JFCL 17,.+1		; CLEAR OVERFLOW
	IMULM PV,CV
	SKIPL OKOVFL		;[362] SKIP IF OVERFLOW OK
	JOV .+2			; SEEIF OVERFLOW
	SKIPA			; NO
	TRO ER,ERRN		; YES, SET N ERROR
	JRST EVNUM
XLRW:	EXCH PV,CV
	LSH CV,0(PV)
	LSH PR,0(PV)
	JRST XDIV1
   >


   IFN POLISH,<			;
;HERE FOR EXTERNAL ARITHMETIC
;CONVERS TO POLISH BLOCK TYPE 11

POLPSH:	JUMP1 [SKIPE LITLVL	;[301] ONLY SAVE POLISH ON PASS2
		TRO ER,ERRF	;[301] SET FAKE FLAG IF IN LITERAL
		JRST EVXCT1]	;[301]
	PUSH P,POLSTK		;SAVE STACK POINTER
	EXCH P,POLSTK		;SAVE P AND SET UP POLISH STACK
	TLO FR,POLSW		;SIGNAL STORING POLISH
	CAMN PR,[-1]		;[526] DO WE HAVE A -1 RELOCATION?
	CALL POLPPR		;[526] YES,
	CAMN RC,[-1]		;[526] HOW ABOUT THE OTHER OPERAND?
	CALL POLPRC		;[526] YES,
	PUSH P,POLTBL-1(PS)	;STACK OPERATOR
	PUSH P,PR		;STACK PREVIOUS RELOCATION
	PUSH P,PV		;AND VALUE
	PUSH P,RC		;STACK CURRENT
	PUSH P,CV
	EXCH P,POLSTK		;GET P BACK
	POP P,CV		;USE STACK POINTER FOR VALUE
	MOVE RC,CV		;AND RELOCATION (ENSURES EXTERNAL)
	JRST EVNUM

POLPPR:	CAIE PS,3		;[526] DOING +?
	JRST [	CAIN PS,4	;[526] NO, DOING -?
	 	MOVEI PS,3	;[526] YES, MAKE IT +
		JRST .+2]	;[526] GO NEGATE THE VALUE
	MOVEI PS,4		;[526] ITS +, MAKE IT -
	MOVEI PR,1		;[526] MAKE RELOCATION 1
	MOVNS PV,PV		;[526] NEGATE VALUE
	RET			;[526]
POLPRC:	CAIE PS,3		;[526] DOING +?
	JRST [	CAIN PS,4	;[526] NO, DOING -?
		MOVEI PS,3	;[526] YES, MAKE IT +
		JRST .+2]	;[526] GO NEGATE THE VALUE
	MOVEI PS,4		;[526] ITS +, MAKE IT -
	MOVEI RC,1		;[526] MAKE RELOCATION 1
	MOVNS CV,CV		;[526] NEGATE VALUE
	RET			;[526]

		;TRY NEXT ITEM

;HERE TO STORE THE POLISH LIST
;RC  (AND CV) HAVE POINTER TO TOP ITEM IN PUSHDOWN STACK
POLPOP:	EXCH RC,POLTYP		;[504] PUT POLTYP IN AC FOR WHILE
	CAME RC,[0,,POLFWF]	;[504] A FULL WORD FIXUP?
	JRST [	EXCH RC,POLTYP	;[504] NO,RESTORE
		JRST POLPO1]	;[504]
	EXCH RC,POLTYP		;[504] YES, CHECK FOR INCIRECT
	TLZE FR,INDSW		;[504] INDIRECT?
	JRST POLIND		;[504] YES,
POLPO1:	SKIPE INANGL		;[305] STILL IN EVALUATION?
	JRST [	MOVEM RC,INANGL	;[305] YES, MARK STACK
		SETZB RC,CV	;0 SO OP NOT CONFUSED
		SETZM EXTPNT	;[444]
		TLZ FR,POLSW
		RET]		;[305] WILL MOVE LATER
	SKIPE INASGN		;[305] IF DEFINING A SYMBOL JUST SAVE
	JRST POLASG		;[305] STATE OF STACK
POLSYM:	MOVE PV,FREE		;GET NEXT FREE LOCATION
	EXCH PV,POLIST		;SWAP STACK POINTER
	CALL POLSTR		;STORE POINTER TO NEXT POLISH BLOCK
	CALL POLOPF		;STORE FIRST OPERATOR
	CALL POLFST		;STORE FIRST PART
	CALL POLSND		;STORE SECOND PART
POLPSS:	SKIPE PV,POLTYP		;USE PRESET TYPE
	JRST [JUMPL PV,POLOCT	;SET AND PERMANENT
		SETZM POLTYP	;CLEAR TEMP SETTING
		HRRO PV,PV	;COMPLETE OPERATOR
		JRST POLOCT]	;FINALLY
	HRREI PV,POLRHF		;ASSUME RH FIXUP
	JUMPNC POLOCT		;COMMA?
	HRREI PV,POLLHF		;YES, LH FIXUP
POLOCT:	XCT 3+[SETZM EXTPNT	;FULL WORD
		HRRZS EXTPNT	;LEFT HALF
		HLLZS EXTPNT](PV) ;RIGHT HALF
	SKIPE INASGN		;[305] DEFINING A SYMBOL?
	JRST POLSTS		;[305] YES
	CALL POLSTO		;[305] STORE IT
	SKIPE PHALVL		;INSIDE PHASE?
	JRST [	MOVE PV,LOCO	;[456] YES, USE ORIGINAL LOC
		HRL PV,MODO	;[456] AND MODE
		JRST POLOC1]	;[456]
	MOVE PV,LOCA		;LOCATION
	HRL PV,MODA		;AND MODE
POLOC1:	SKIPN LITLVL		; HOWEVER IF IN A LITERAL?
	JRST POLPOR		; NOT
	MOVE PV,POLIST		; WE CAN NOT SUPPLY THE STORE ADDRESS YET
	MOVE CV,(PV)		; SO PUT IN A SPECIAL LIST
	MOVEM CV,POLIST		; REMOVE FROM REGULAR LIST
	EXCH PV,POLITS		; STORE IN POLIST LIT LIST
	MOVEM PV,@POLITS	; LINK TOGETHER
	MOVE PV,STPX		; STORE DEPTH IN THIS LIT
	SUB PV,STPY		; WITH NO RELOCATION YET
	TRO ER,ERRF		;[301] SET FAKE FLAG
POLPOR:	CALL POLSTR
	SETZB RC,CV		;USE ZERO VALUE AND RELOCATION
POLRET:	MOVE PV,POLPTR		;RESET INITIAL POLISH POINTER
	MOVEM PV,POLSTK
	RET			;RETURN


POLSTS:	SUBI PV,3		;DIFFERENT STORE OPERATOR
	CALL POLSTO		;STORE IT
	MOVE PV,INASGN		;GET RADIX-50 SYMBOL
	MOVE AC0,POLIST		;GET BLOCK
	JRST POLPOR		;STORE IT

POLIND:	POP P,(P)		;[504] REMOVE TOP ADDRESS
	SETZ AC0,		;[504] ZERO VALUE
	TLO AC0,(Z @)		;[504] TURN ON INDIRECT BIT
	MOVE PS,CSTAT+'!'	;[504] FORCE IOR 
	JRST FORCEP		;[504] GO DO IT

;HERE TO STORE CURRENT POLISH STACK
;WE MUST MOVE IT TO A SAFE PLACE

POLASG:	CALL MOVSTK		;[305] MOVE STACK
	MOVEI AC0,0		;RETURN WITH 0 VALUE AND NEW RC
	JRST POLRET

MOVSTK:	PUSH P,SDEL		;[305] SAVE ACC
	PUSH P,AC1		;[305] ...
	HRRZ AC1,POLSTK		;[305] GET TOP OF STACK
	HRRZ SDEL,RC		;[444] GET RH OF RC
	CAMLE SDEL,AC1		;[444] RH(RC) .LE. RH(POLSTK)?
	JRST MOVNOT		;[444] NO,DONT DO THE MOVSTK, SINCE NO ADDITIONAL POLISH WAS DONE
	SUBI AC1,(RC)		;[305] GET + LENGTH - 1
	HRRZI SDEL,1(AC1)	;[305] + LENGTH
	ADD SDEL,FREE		;[305] NEW TOP
	CAML SDEL,SYMBOL	;[305] WILL IT FIT
	CALL XCEED		;[305] NOT YET
	EXCH SDEL,FREE		;[305] BASE IN SDEL
	HRL SDEL,RC		;[305] FROM
	HRR RC,SDEL		;[305] NEW RELOC PTR
	MOVE CV,AC1		;[305] COPY LENGTH
	HRL CV,CV		;[305] INTO BOTH HALVES
	MOVE AC1,FREE		;[305] TOP +1
	BLT SDEL,-1(AC1)	;[305] MOVE IT
	MOVE AC1,POLSTK		;[305] GET STACK PTR
	SUB AC1,CV		;[305] BACKUP
	MOVEM AC1,POLSTK	;[305]
	POP P,AC1		;[305] RESTORE
	POP P,SDEL		;[305] ...
	MOVE CV,RC		;[305] RESET CURRENT VALUE VALUE
	RET

MOVNOT:	POP P,AC1		;[444]
	POP P,SDEL		;[444] RESTORE AC1 AND SDEL AND
	RET			;[444] RETURN


;THIS IS A KLUDGE TO PRODUCE ADDITIVE GLOBALS FOR THE FEW CASES THAT THEY
;CAN HANDLE. I.E. K+GLOBAL, GLOBAL+K, GLOBAL-K
;SO THAT OLD PROGRAMS WILL COMPIL THE SAME WAY AND LOAD WITH THE
;OLD LOADER WITHOUT THE FAILSW CODE
;APART FROM ADDITIVE SYMBOL FIXUPS POLISH BLOCKS ARE MORE POWERFULL
;***** REMOVE SOMEDAY
POLOPF:	SKIPE POLTYP		;[303] IF ALREADY SETUP THEN
	JRST POLOPX		;[303] WE MUST USE POLISH (EXP OR OCT)
	JUMPL RC,POLOPX		;[305] TOO COMPLEX IF ALREADY A POINTER
	HRRZ PS,1(RC)		;GET FIRST OPERATOR
	CAIE PS,3		;CAN ONLY HANDLE ADD
	CAIN PS,4		;AND SUBTRACT
	JRST POLOP2		;ITS ONE OF THOSE  GIVE IT A TRY
;*****
POLOPX:	SKIPN SGNMAX		; PSECTS USED?
	JRST POLOPR		; NO
	PUSH P,PV		; SAVE FIRST OP
	HRRO PV,SGNCUR		; GET CUR PSECT INX
	TRO PV,400000		; MAKE POLISH OP
	CALL POLSTR		; STORE IT
	POP P,PV		; GET FIRST OP
POLOPR:	HRRZ PV,1(RC)		; GET OPERATOR
	CAIL PV,OTLEN		;[547] A VALID OPERATOR INDEX?
	JRST EVXERR		;[547] NO, GIVE ERROR
	XCT OPRTBL-3(PV)	; ANYTHING SPECIAL?
	HRRO PV,1(RC)		; GET OPERATOR AND FLAG IT
	JRST POLSTR		;STORE IT AND EXIT

POLAPO:	AOS 0(P)		; SKIP FIRST OPERAND
	HRRO PV,3(RC)		; GET PSECT INX
	TRO PV,400000		; MAKE POLISH OP
	JRST POLSTR		; STORE AND EXIT

;***** MORE OF THIS KLUDGE
POLOP2:	SUBI PS,3		;MAKES LIFE EASIER
	MOVE CV,4(RC)		;GET 2ND OPERAND
	JUMPL CV,POLOPX		;ITS A POINTER, THEREFORE TOO COMPLEX
	MOVE PV,2(RC)		;AND 1ST OPERAND
	JUMPL PV,POLOPX		;THIS IS A POINTER
	TDNN CV,[-2,,-2]	;TEST FOR EXTERN
	JRST [TRNE CV,1		;TEST FOR BOTH RELOCATABLE
		TRNN PV,1
		JRST POLOP3	;THIS IS NOT EXTERN SO OTHER CAN BE
		JRST POLOPX]	;CANNOT HANDLE HERE, USE POLISH
	JUMPN PS,POLOPX		;CAN NOT HANDLE -GLOBAL
	TDNE PV,[-2,,-2]	;TEST FOR EXTERN HERE
	JRST POLOPX		;GLOBAL+GLOBAL TOO COMPLEX
POLOP3:	SOS FREE		;BACKUP FREE COUNTER
	MOVE PV,@FREE		;GET LAST POINTER
	MOVEM PV,POLIST		;SET POINTER BACK
	POP P,PV		;POP RETURN OFF STACK
	TLZ FR,POLSW		;CLEAR FLAG JUST IN CASE
;RELOAD RC, CV, PV, AND PR FROM STACK
;AND EXECUTE OPERATOR
	MOVE PR,2(RC)		;
	MOVE PV,3(RC)
	MOVE CV,5(RC)
	MOVE RC,4(RC)		;THIS ONE LAST OF COURSE
	JUMPN PS,POLOP5		;DO MINUS
	ADDM PV,CV
	ADDM PR,RC
	JRST POLRET		;RESTORE STACK AND RETURN

POLOP5:	SUBM PV,CV
	SUBM PR,RC
	JRST POLRET
;***** END OF THIS KLUDGE

;HERE TO HANDLE FIRST OPERAND
;HIGHLY RECURSIVE

POLFST:	SKIPGE PV,2(RC)		;GET RELOCATION
	JRST POLFSR		;THIS IS ANOTHER POINTER
	TDNE PV,[-2,,-2]	;IS IT EXTERNAL?
	JRST POLFS2		;YES
	MOVE CV,3(RC)		;GET VALUE
POLFS4:	TLNN PV,-1		;CHECK FOR LEFT HALF VALUE
	TLNE CV,-1
	JRST POLFS1		;YES, NEED FULL WORD
	HRL CV,PV		;XWD RELOC ,, VALUE
	SETZ PV,		;OPERAND IS 0 FOR 18 BIT VALUE
	CALL POLSTR
	MOVE PV,CV
	JRST POLSTR		;STORE AND EXIT

POLFS1:	MOVEI PV,1		;OPERAND IS 1 FOR 36 BIT VALUE
	CALL POLSTR
	MOVE PV,2(RC)		;RELOCATION
	CALL POLSTR
	MOVE PV,CV		;VALUE
	JRST POLSTR

POLSN2:
POLFS2:	MOVE CV,1(PV)		;GET SIXBIT SYMBOL INTO AC0
	MOVEI PV,2		;OPERAND IN 2 FOR SYMBOL
	CALL POLSTR
	MOVEI ARG,4		;MAKE GLOBAL REQUEST
	CALL SQOZE		;TO RADIX-50
	MOVE PV,CV		;PUT IN RIGHT ACC
	JRST POLSTR		;STORE IT

POLFSR:;	CAME PV,3(RC)	;CHECK TO MAKE SURE IT REALLY IS A POINTER
;	JRST POLFSN		;NO, ITS A NEGATIVE GLOBAL
	PUSH P,RC		;SAVE THIS POINTER
	MOVE RC,PV		;GET NEXT POINTER
	CALL POLOPR		;GET OPERATOR
	CALL POLFST		;GET FIRST OPERAND
	CALL POLSND		;GET SECOND OPERAND
	POP P,RC		;GET BACK PREVIOUS POINTER
	RET			;RETURN TO PREVIOUS LEVEL


POLFSN:	HRROI PV,14		;TWO'S COMPLIMENT NEGATIVE
	CALL POLSTR		;STORE OPERATOR
	MOVN PV,2(RC)		;GET RELOCATION
	TDNE PV,[-2,,-2]	;CHECK FOR EXTERN
	JRST POLFS2		;IT IS, CONVERT TO RADIX-50
	MOVN CV,3(RC)		;GET VALUE
	JRST POLFS4		;AND STORE IT

;HERE TO HANDLE 2ND OPERAND, ALSO RECURSIVE

POLSNR:;	CAME PV,5(RC)	;MAKE SURE IT REALLY IS
;	JRST POLSNN		;ITS A NEGATIVE GLOBAL
	MOVE RC,PV		;GET NEXT POINTER
	CALL POLOPR		;STORE OPERATOR
	CALL POLFST		;GET 1ST OPERAND
				;AND GET SECOND OPERAND

POLSND:	SKIPGE PV,4(RC)		;GET RELOCATION
	JRST POLSNR		;THIS IS A POINTER
	TDNE PV,[-2,,-2]	;IS IT EXTERNAL?
	JRST POLSN2		;YES
	MOVE CV,5(RC)		;GET VALUE
POLSN4:	TLNN PV,-1		;CHECK FOR LEFT HALF VALUE
	TLNE CV,-1
	JRST POLSN1		;YES, NEED FULL WORD
	HRL CV,PV		;XWD RELOC ,, VALUE
	SETZ PV,		;OPERAND IS 0 FOR 18 BIT VALUE
	CALL POLSTR
	MOVE PV,CV
	JRST POLSTR		;STORE AND EXIT

POLSNN:	HRROI PV,14		;TWO'S COMPLIMENT NEGATIVE
	CALL POLSTR		;STORE OPERATOR
	MOVN PV,4(RC)		;GET RELOCATION
	TDNE PV,[-2,,-2]	;CHECK FOR EXTERN
	JRST POLSN2		;IT IS, CONVERT TO RADIX-50
	MOVN CV,5(RC)		;GET VALUE
	JRST POLSN4		;AND STORE IT

POLSN1:	MOVEI PV,1		;OPERAND IS 1 FOR 36 BIT VALUE
	CALL POLSTR
	MOVE PV,4(RC)		;RELOCATION
	CALL POLSTR
	MOVE PV,CV		;VALUE
	JRST POLSTR

POLSTO:	MOVE SDEL,FREE		;[305] GET NEXT FREE WORD
	MOVEM SDEL,LSTOPR	;[305] STORE POINTER TO STORE OP
POLSTR:	AOS SDEL,FREE		;GET A FREE WORD
	CAML SDEL,SYMBOL	;ENOUGH?
	CALL XCEED		;NO
	MOVEM PV,-1(SDEL)	;STORE ONE WORD
	RET

;TABLE OF CORRESPONDENCE BETWEEN MACRO-10 OPERATORS AND BLOCK 11 OPERATORS
POLTBL:				;POLISH VALUE MACRO-10 OPERATOR
	5			;1		MULTIPLY
	6			;2		DIVIDE
	3			;3		ADD
	4			;4		SUBTRACT
	11			;5		LEFT SHIFT
	10			;6		LOGICAL IOR
	7			;7		LOGICAL AND
	12			;10		LOGICAL XOR
	13			;11		NOT
	14			;12		NEGATE
	15			;13		ADDITIVE PSECT OPERATION

	REPEAT 3,<CALL EVXERR>	;[527] IN CASE OF BAD OPERATOR
OPRTBL:
	JFCL			;3		ADD
	JFCL			;4		SUBTRACT
	JFCL			;5		MULTIPLY
	JFCL			;6		DIVIDE
	JFCL			;7		LOGICAL AND
	JFCL			;10		LOGICAL IOR
	JFCL			;11		LEFT SHIFT
	JFCL			;12		LOGICAL XOR
	AOS (P)			;13		NOT
	AOS (P)			;14		NEGATE
	JRST POLAPO		;15		ADDITIVE PSECT OPERATION
OTLEN==.-OPRTBL+3		;LENGTH OF THIS TABLE + 3

   >;END OF IFN POLISH

	SUBTTL LITERAL STORAGE HANDLER

STOLER:
   IFE FORMSW,< SETZB AC0,RC	;ERROR, NO CODE STORED
	CALL STOW>		;STOW ZERO
   IFN FORMSW,< MOVEI AC0,0
	CALL STOWZ1>
	TRO ER,ERRL		;AND FLAG THE ERROR

STOLIT:	MOVE SDEL,STPX
	SUB SDEL,STPY		;COMPUTE NUMBER OF WORDS
	JUMPE SDEL,STOLER	;ERROR IF NONE STORED
	TRNN ER,ERRORS!ERRF	;[301] ANY ERRORS?
	JRST STOL06		;NO
	TRNN ER,ERRORS-ERRU	;[502] ONLY ERRF!ERRU, THEN BRANCH
	JRST STOL22		;[502]
	JUMP2 STOL22		;YES, NO SEARCH.  BRANCH IF PASS2
	ADDM SDEL,LITCNT	;PASS ONE, UPDATE COUNT
	TRZ ER,ERRF		;[301] CLEAR FAKE FLAG
	JRST STOWI		;INITIALIZE STOW

STOL06:	MOVEI SX,LITAB		;PREPARE FOR SEARCH
	MOVE ARG,STPX		;SAVE IN THE EVENT OF MULTIPLE-WORD
	HRL ARG,STPY
	MOVE AC2,LITNUM
	MOVEI SDEL,0
STOL08:	CALL DSTOW		;GET VALUE WFW

STOL10:	SOJL AC2,STOL24		;TEST FOR END
	MOVE SX,0(SX)		;NO, GET NEXT STORAGE CELL
	MOVE V,-1(SX)		;GET RELOCATION BITS WFW
	CAMN AC0,-2(SX)		;DO CODES COMPARE? WFW
	CAME RC,V		;YES, HOW ABOUT RELOCATION?
	AOJA SDEL,STOL10	;NO, TRY AGAIN
	SKIPGE STPX		;YES, MULTI-WORD?
	JRST STOL13		;NO, JUST RETURN LOCATION
	MOVEM AC2,SAVBLK+AC2	;YES, SAVE STARTING INFO
	MOVEM SX,SAVBLK+SX

STOL12:	SOJL AC2,STOL23		;TEST FOR END
	CALL DSTOW		;GET NEXT WORD WFW
	MOVE SX,0(SX)		;UPDATE POINTER
	MOVE V,-1(SX)		;GET RELOCATION WFW
	CAMN AC0,-2(SX)		;COMPARE VALUE WFW
	CAME RC,V		;AND RELOCATION
	JRST STOL14		;NO MATCH, TRY AGAIN
	SKIPL STPX		;MATCH, HAVE WE FINISHED SEARCH?
	JRST STOL12		;NO, TRY NEXT WORD
STOL13:				;YES, RETURN LOCATION
   IFN POLISH,<
	SETZM POLITS		;CLEAR ANY POLISH PENDING
   >
	JRST STOL26

STOL14:	MOVE AC2,SAVBLK+AC2	;RESTORE STOW POINTERS
	MOVE SX,SAVBLK+SX
	HRREM ARG,STPX
	HLREM ARG,STPY
	AOJA SDEL,STOL08	;BETTER LUCK NEXT TIME


STOL22:	MOVE SDEL,LITNUM
STOL23:	CALL DSTOW		;DSTOW AND CONVERT
STOL24:	MOVE SX,LITABX		;GET CURRENT STORAGE
	CALL GETTOP		;GET NEXT CELL
	MOVEM AC0,-2(SX)	;STORE CODE WFW
   IFN POLISH,<
	JUMPN RC,.+3		;[305] LEAVE REAL RELOC ALONE
	TRNE ER,ERRF		;[305] BUT IF FAKE ERROR FOR POLISH
	TLO RC,(1B0)		;[305] FIX RC SO WE CAN TELL FROM [0]
   >
	MOVEM RC,-1(SX)		;WFW
   IFN FORMSW,<
	MOVE AC0,FORM
	MOVEM AC0,-3(SX)>
	MOVEM SX,LITABX		;SET POINTER TO CURRENT CELL
	AOS LITNUM		;INCREMENT NUMBER STORED
	AOS LITCNT		;INCREMENT NUMBER RESERVED
	SKIPL STPX		;ANY MORE CODE?
	JRST STOL23		;YES
STOL26:	TRZ ER,ERRF		;[301] CLEAR FAKE FLAG
	JUMP1 POPOUT		;EXIT IF PASS ONE
	MOVE SX,LITHDX		;GET HEADER BLOCK
	HLRZ RC,-1(SX)		;GET BLOCK RELOCATION
	HRRZ AC0,-1(SX)
	ADDI AC0,0(SDEL)	;COMPUTE ACTUAL LOCATION
	RET			;EXIT


SUBTTL INPUT ROUTINES

GETCHR:	CALL CHARAC		;GET ASCII CHARACTER
	CAIL C,"A"+40		;CHECK FOR LOWER CASE
	CAILE C,"Z"+40
	JRST .+2		;NOT LOWER CASE
   IFN STANSW,<
	SUBI C,40
	CAIN C,32
	MOVEI C,136		;^
	CAIN C,30
	MOVEI C,137		;_
	CAIN C,176
	MOVEI C,134		;~
	CAIN C,140
	MOVEI C,100>		;@
   IFE STANSW,<
	TRZA C,100>		;CONVERT LOWER CASE TO SIXBIT
	SUBI C,40		;CONVERT TO SIXBIT
	CAIG C,77		;CHAR GREATER THAN SIXBIT?
	JUMPGE C,GETCS		;TEST FOR VALID SIXBIT
	ADDI C,40		;BACK TO ASCII
	CAIN C,HT		;CHECK FOR TAB
	JRST GETCS2		;MAKE IT LOOK LIKE SPACE
	CAIG C,CR		;GREATER THAN CR
	CAIG C,HT		;GREATER THAN TAB
	JRST GETCS1		;IS NOT FF,VT,LF OR CR
	MOVEI C,EOL		;LINE OR FORM FEED OR V TAB
	TLOA IO,IORPTC		;REPEAT CHARACTER
GETCS2:	MOVEI C,0		;BUT TREAT AS BLANK
GETCS:	MOVE CS,CSTAT(C)	;GET STATUS BITS
	RET			;EXIT

GETCS1:	JUMPE C,GETCS		;IGNORE NULS
	TRC C,100		;MAKE CHAR. VISIBLE
	MOVEI CS,"^"
	DPB CS,LBUFP		;PUT ^ IN OUTPUT
	CALL RSW2		;ALSO MODIFIED CHAR.
	TRO ER,ERRQ		;FLAG Q ERROR
	JRST GETCHR		;BUT IGNORE CHAR.

CHARAC:	TLZE IO,IORPTC		;REPEAT REQUESTED?
	JRST CHARAX		;YES
RSW0:	JUMPN MRP,MREAD		;BRANCH IF TREE POINTER SET
	CALL READ
RSW1:	SKIPE RPOLVL		;ARE WE IN "REPEAT ONCE"?
	JRST REPO1		;YES
RSW2:	CAIN C,LF		;LF?
	JRST RSW4		;YES, SEE IF LAST CHAR WAS A CR
	MOVEM C,LIMBO		;STORE THIS CHAR. FOR RPTC
RSW3:	TLNE IO,IOSALL		;MACRO SUPPRESS ALL?
	JUMPN MRP,CPOPJ		;YES,DON'T LIST IN MACRO
	SOSG CPL		;ANY ROOM IN THE IMAGE BUFFER?
	CALL RSW5		; NO, BUT SEE IF ANY EXCESS WE CAN USE
	IDPB C,LBUFP		;YES, STORE IN PRINT AREA
	CAIE C,HT		;TAB?
	RET			;NO, EXIT
	MOVEI CS,7		;TAB COUNT MASK
	ANDCAM CS,CPL		;MASK TO TAB STOP
	RET

RSW4:	MOVE CS,LIMBO		;GET LAST CHAR.
	MOVEM C,LIMBO		;STORE THIS CHAR. FOR RPTC
	CAIE CS,CR		;LAST CHAR. A CR?
	JRST RSW3		;NO
	HRROS LIMBO		;YES,FLAG
	RET			;AND EXIT

RSW5:	PUSH P,C		; NEED AN ACC
	MOVNI C,.CPLX		; GET EXCESS SPACE
	CAMGE C,CPL		; ANY ROOM?
	JRST [POP P,C		; YES
		RET]		; JUST RETURN
	POP P,C			; NO
	JRST OUTPL		; OUTPUT THE PARTIAL LINE
CHARAX:	HRRZ C,LIMBO		;GET LAST CHARACTER
	RET			;EXIT

CHARL:	CALL CHARAC		;GET AND TEST 7-BIT ASCII
	CAIG C,FF		;LINE OR FORM FEED OR VT?
	CAIGE C,LF
	RET			;NO,EXIT
CHARL1:	CALL SAVEXS		;SAVE REGISTERS
	SKIPE LITLVL		;[314] IN LITERAL?
	JRST [	CALL OUTIML	;[471] YES
		JRST RSTRXS]	;[471] RESTORE REGISTERS AND EXIT
	SKIPN INASGN		;[471] NO, MULTIPLE LINE ASSIGNMENT?
	CALL OUTLIN		;[314] NO, DUMP THE LINE
	JRST RSTRXS		;RESTORE REGISTERS AND EXIT


;STATEMENT OUT PASSES REMAINDER OF LINE (CMNT)
;UNTIL A LINE TERMINATOR IS SEEN.
STOUTS:	TLOA IO,IOENDL!IORPTC
STOUT:	TLO IO,IORPTC
	BYPASS
	CAIE C,EOL		;MOST LIKELY A ; OR EOL CH
	JRST STOUT2		;IT WASN'T, SEE WHY!
	HRRZ C,LIMBO		;GET CHARACTER INCASE EOL
	TLZN IO,IORPTC		;IT WAS , SKIP NEXT GET
STOUT1:	CALL RSW0
	CAIN C,CR		;NEED SPECIAL TEST FOR CR
	JRST STOUT3		;INCASE NOT FOLLOWED BY LF
	CAIG C,FF
	CAIGE C,LF
	JRST STOUT1
	JRST OUTLIN		;OUTPUT THE LINE (BIN AND LST)

STOUT2:	CAIN C,14		;COMMA?
	SKIPL STPX		;YES, ERROR IF CODE STORED
	TRO ER,ERRQ
	JRST STOUT1		;PASS OUT TIL END OF LINE

STOUT3:	CALL RSW0		;GET NEXT CHAR.
	CAIG C,FF		;GENUINE EOL CHARACTER?
	CAIGE C,LF
	TLOA IO,IORPTC		;NO, SO REPEAT IT
	JRST OUTLIN		;AND DUMP LINE IN ANY CASE
REPEAT 0,<			; DON'T FLAG IT
	TRO ER,ERRQ		; FLAG EXTRA <CR> WITH "Q" ERROR
   >
	SETZ C,
	DPB C,LBUFP		;CLEAR LOOK-AHEAD CHAR OUT OF BUFFER
	CALL OUTLIN		;DUMP UPTO CR AS LINE
	HRRZ C,LIMBO		;GET C BACK
	JRST RSW3		;AND PUT CHAR IN NEW  BUFFER

SUBTTL CHARACTER STATUS TABLE

	DEFINE GENCS (OPLVL,ATOM,AN,SQUOZ,OPTYPE,SEQNO)
<BYTE (6)OPLVL (9)ATOM (3)AN (6)SQUOZ,OPTYPE,SEQNO>

	;OPLVL PRIORITY OF BINARY OPERATORS
	;ATOM INDEX TO JUMP TABLE AT CELL1
	;AN TYPE OF CHARACTER
	;	1=OTHER, 2=ALPHA, 4=NUMERIC
	;SQUOZ VALUE IN RADIX 50
	;OPTYPE INDEX TO JUMP TABLE AT EVXCT
	;SEQNO VALUE IN SIXBIT
CSTAT:
	GENCS 00,00,1,00,00,00	; ' '
	GENCS 04,12,1,00,06,01	; '!'
	GENCS 00,07,1,00,00,02	; '"'
	GENCS 00,12,1,00,00,03	; '#'
	GENCS 00,01,2,46,00,04	; '$'
	GENCS 00,01,2,47,00,05	; '%'
	GENCS 04,12,1,00,07,06	; '&'
	GENCS 00,07,1,00,00,07	; '''

	GENCS 00,01,1,00,00,10	; '('
	GENCS 00,01,1,00,00,11	; ')'
	GENCS 02,12,1,00,01,12	; '*'
	GENCS 01,00,1,00,03,13	; '+'
	GENCS 40,01,1,00,00,14	; ','
	GENCS 01,02,1,00,04,15	; '-'
	GENCS 00,11,2,45,00,16	; '.'
	GENCS 02,12,1,00,02,17	; '/'

	GENCS 00,04,4,01,00,20	; '0'
	GENCS 00,04,4,02,00,21	; '1'
	GENCS 00,04,4,03,00,22	; '2'
	GENCS 00,04,4,04,00,23	; '3'
	GENCS 00,04,4,05,00,24	; '4'
	GENCS 00,04,4,06,00,25	; '5'
	GENCS 00,04,4,07,00,26	; '6'
	GENCS 00,04,4,10,00,27	; '7'

	GENCS 00,04,4,11,00,30	; '8'
	GENCS 00,04,4,12,00,31	; '9'
	GENCS 00,12,1,00,00,32	; ':'
	GENCS 00,01,1,00,00,33	; ';'
	GENCS 00,05,1,00,00,34	; '<'
	GENCS 00,12,1,00,00,35	; '='
	GENCS 00,01,1,00,00,36	; '>'
	GENCS 00,12,1,00,00,37	; '?'


	GENCS 00,03,1,00,00,40	; '@'
	GENCS 00,01,2,13,00,41	; 'A'
	GENCS 00,01,2,14,00,42	; 'B'
	GENCS 00,01,2,15,00,43	; 'C'
	GENCS 00,01,2,16,00,44	; 'D'
	GENCS 00,01,2,17,00,45	; 'E'
	GENCS 00,01,2,20,00,46	; 'F'
	GENCS 00,01,2,21,00,47	; 'G'

	GENCS 00,01,2,22,00,50	; 'H'
	GENCS 00,01,2,23,00,51	; 'I'
	GENCS 00,01,2,24,00,52	; 'J'
	GENCS 00,01,2,25,00,53	; 'K'
	GENCS 00,01,2,26,00,54	; 'L'
	GENCS 00,01,2,27,00,55	; 'M'
	GENCS 00,01,2,30,00,56	; 'N'
	GENCS 00,01,2,31,00,57	; 'O'

	GENCS 00,01,2,32,00,60	; 'P'
	GENCS 00,01,2,33,00,61	; 'Q'
	GENCS 00,01,2,34,00,62	; 'R'
	GENCS 00,01,2,35,00,63	; 'S'
	GENCS 00,01,2,36,00,64	; 'T'
	GENCS 00,01,2,37,00,65	; 'U'
	GENCS 00,01,2,40,00,66	; 'V'
	GENCS 00,01,2,41,00,67	; 'W'

	GENCS 00,01,2,42,00,70	; 'X'
	GENCS 00,01,2,43,00,71	; 'Y'
	GENCS 00,01,2,44,00,72	; 'Z'
	GENCS 00,06,1,00,00,73	; '['
	GENCS 00,12,1,00,00,74	; '\'
	GENCS 00,01,1,00,00,75	; ']'
	GENCS 00,10,1,00,00,76	; '^'
	GENCS 10,12,1,00,05,77	; '_'

CSTATX:	GENCS 04,12,1,00,10,01	;  '^!'
CSTATN:	GENCS 04,12,1,00,11,15	; [416]  '^-'
   IFN POLISH,<
CSTATM:	GENCS 04,12,1,00,12,15	;UNARY MINUS
CSTATP:	GENCS 11,12,1,00,13,13	; ADDITIVE PSECT OPERATION
   >

SUBTTL LISTING ROUTINES

OUTLIN:	TRNN ER,ERRORS-ERRQ	;ANY ERRORS?
	TLNE FR,ERRQSW		;NO, IGNORE Q ERRORS?
	TRZ ER,ERRQ		;YES, YES, ZERO THE Q ERROR
	HRLZ AC0,ER		;PUT ERROR FLAGS IN AC0 LEFT
	TLZ AC0,ERRF		;[301] CLEAR FAKE FLAG
	TDZ ER,TYPERR
	JUMP1 OUTL30		;BRANCH IF PASS ONE
	JUMPN AC0,OUTL02	;JUMP IF ANY ERRORS TO FORCE PRINTING
	SKIPE LITLVL		;WITHIN NOLIST LITERAL?
	SKIPE LITLST
	JRST OUTL04		;NO
	TLNE IO,IOSALL		;YES, SALL MODE?
	JUMPN MRP,CPOPJ		;YES, EXIT IF IN MACRO EXPANSION
OUTL04:	MOVE AC1,STPX		;[314]
	CAME AC1,STPY		;[314] ANY CODE GENERATED?
	JRST OUTL01		;[314] YES
	TLNN IO,IOSALL		;YES,SUPPRESS ALL?
	JRST OUTL03		;NO
	JUMPN MRP,CPOPJ		;YES,EXIT IF IN MACRO
	LDB C,[XWD 350700,LBUF]
	CAIE C,CR		;FIRST CHAR CR?
OUTL01:	TLZ IO,IOMAC		;FORCE MACRO PRINTING
OUTL03:	TLNN IO,IOMSTR!IOPROG!IOMAC
OUTL02:	IOR ER,OUTSW		;FORCE IT.
	IDPB AC0,LBUFP		;STORE ZERO TERMINATOR AFTER ASCII SRC LINE
	TSO ER,AC0		;[411] RE-FLAG THE ERRORS FOR %....X
	TLNN FR,CREFSW		;CREF?
	CALL CLSCRF		;YES, WRITE END OF CREF DATA (177,003)
	MOVE C,TYPERR		;[411] NOW RESTORE FLAGS AS
	ANDI C,ERRORS		;[411] THEY WERE SO TTY LISTING IS
	TDZ ER,C		;[411] WHAT THEY ASKED FOR
	JUMPE AC0,OUTL20	;BRANCH IF NO ERRORS
	TLZE AC0,ERRM		;M ERROR?
	TLO AC0,ERRP		;M ERROR SET - SET P ERROR.
	CALL OUTLER		;PROCESS ERRORS

OUTL20:	MOVE AC1,STPX		;[314]
	SKIPN C,ASGBLK		;
	SKIPE CS,LOCBLK		;
	CAME AC1,STPY		;[314] ANY CODE GENERATED?
	JRST OUTL23		;YES, JUMP
	JUMPE C,OUTL22		; SEQUENCE BREAK AND NO BINARY JUMPS
	ILDB C,TABP		;ASSIGNMENT FALLS THROUGH
	CALL OUTL		;OUTPUT A TAB.
	ILDB C,TABP		;OUTPUT 2ND TAB, LOCATION FIELD
	CALL OUTC		;NEXT IS BINARY LISTING FIELD
	HLLO CS,LOCBLK		;LEFT HALF OF A 36BIT VALUE
	SKIPL ASGBLK		; SKIP IF LEFT HALF IS NOT RELOC
	TRZA CS,1		;IT IS, SET THE FLAG
	TLNE CS,-1		;SKIP IF ITS A 18BIT VALUE, OTHERWISE
	CALL ONC1		;PRINT LH OF A 36 BIT VALUE IN CS
	HRLO CS,LOCBLK		;PICK UP THE RIGHT HALF (18BIT VALUE)
	MOVE C,ASGBLK		; GET RIGHT HALF RELOCATION
	TRZ CS,0(C)		; 
	CALL ONC		;PRINT IT
	JRST OUTL23		;SKIP SINGLE QUOTE TEST

OUTL22:	CALL ONC		;TAB TO RH AND PRINT IT
	MOVEI C,"'"
	SKIPE MODA
	CALL OUTC
OUTL23:	MOVE AC1,STPX		;[314] ANY BINARY
	CAMG AC1,STPY		;[314]
	JRST [	SKIPGE CS,NOTFL	;[530] NO, FIRST LINE?
		CAME CS,[-2]	;[530] NO, LAST LINE?
		JRST OUTL29	;[530] NOT LAST
		SETZM NOTFL	;[530] IT IS LAST LINE, SET TO FIRST
		JRST OUTL29]	;[530]
	MOVSI AC1,(BLOFF)	;[424]
	ANDCAM AC1,BLSW		;[424] ASSUME WE WANT BINARY LISTING
	SKIPE LITLVL		;[424] IN LITERAL?
	JRST [	SKIPN LITLST	;[424] YES, IS LITLST REQUESTED
		JRST OUTL21	;[424] NO, GO SUPPRESS BINARY LISTING
		JRST .+1]	;[424] YES,
	SKIPL NOTFL		;[522] NOT THE FIRST LINE?
	JRST OUTL27		;[424] FIRST LINE, GO OUTPUT BINARY
	AOSE NOTFL		;[522] LAST LINE?
	AOSA NOTFL		;[522] YES, INTIALIZE TO FIRST LINE
	SOS NOTFL		;[522] NO, RESTORE THE FLAG SETTING
	MOVSI AC1,(FLBLST)	;[424] NOT FIRST LINE,
	TDNN AC1,BLSW		;[424] FIRST LINE BINARY ONLY REQUESTED?
	JRST OUTL27		;[424] NO, FLBLST NOT REQUESTED
OUTL21:	MOVSI AC1,(BLOFF)	;[424] YES
	IORM AC1,BLSW		;[424] SUPPRESS BINARY LISTING
OUTL27:	CALL BOUT		;OUTPUT BINARY
OUTL29:	MOVE CS,[POINT 7,LBUF]
OUTL24:	ILDB C,CS
	CAILE C," "		;
	JRST OUTL28		; FOUND A PRINTING CHARACTER
	JUMPN C,OUTL24		; TRY AGAIN UNLESS TERMINAL 0
	SKIPN SEQNO		; SEQUENCE NO. ARE WORTH PRINTING
	JRST OUTL25		; BUT JUST TABS AREN'T
OUTL28:	MOVE CS,TABP
	CALL OUTASC		;OUTPUT TABS & SEQ. NO.
OUTL25:	MOVEI CS,LBUF
	CALL OUTAS0		;DUMP THE LINE
	TLNE IO,IOSALL		;SUPPRESSING ALL
	JUMPN MRP,[CALL OUTCR	;YES, CR NOT OTHERWISE PROVIDED
		JRST .+1]
OUTL26:	MOVE AC1,STPX		;[314] ANY BINARY?
	SKIPE LITLVL		;AND NOT IN NOLIST LITERAL?
	SKIPE LITLST
	CAMG AC1,STPY		;[314]
	JRST OUTLI		;NO, CLEAN UP AND EXIT
	MOVSI AC1,(FLBLST)
	TDNE AC1,BLSW		;FIRST LINE BINARY ONLY?
	JRST [	MOVSI AC1,(BLOFF)
		IORM AC1,BLSW	;YES, SWITCH OFF BINARY
		CALL BOUT	;OUTPUT TO REL ONLY
		JRST OUTL26]
	CALL OUTLI2		;YES, INITIALIZE FOR NEXT LINE
	TLNN FR,CREFSW		; CREF REQUESTED?
	TLNE IO,IOPROG		; YES, THEN IS XLIST ON?
	JRST .+2		; CREF NOT BEING PRINTED
	CALL CLSCRF		; CLOSE OUT THIS CREF LINE
	CALL BOUT		;YES, DUMP IT
	CALL OUTCR		;OUTPUT CARRIAGE RETURN
	JRST OUTL26		;TEST FOR MORE BINARY

OUTPL:	SKIPN LITLVL		;IF IN LITERAL
	SKIPL STPX		;OR CODE GENERATED
	JRST OUTIM		;JUST OUTPUT THE IMAGE
	SKIPE ASGBLK		;
	JRST OUTPL1		; JUMP IF AN ASSIGNMENT
	SKIPE LOCBLK		; OR A BLOCK RESERVATION
	SKIPE MACENL		; STILL IN "CALLM"?
	JRST OUTIM		; OTHERWISE OUTPUT IMAGE
	JUMPN MRP,OUTIM		; ALSO IF IN A MACRO
OUTPL1:	CALL SAVEXS		; SAVE AC0 AND C
	MOVEI C,CR
	IDPB C,LBUFP
	MOVEI C,LF
	IDPB C,LBUFP		;FINISH WITH CRLF
	CALL OUTLIN		;OUTPUT PARTIAL LINE
	CALL RSTRXS		; RESTORE ACS
	JRST OUTLI2		;INITIALISE REST OF LINE

;HERE ON PASS 1 ONLY

OUTL30:	AOS CS,STPX		;PASS ONE
	CAIN C,FF		;FORM FEED?
	CALL OUTFF2		;YES, COUNT PAGES FOR PASS1 ERROR
	ADDM CS,LOCO		;INCREMENT OUTPUT LOCATION
	CALL STOWI		;INITIALIZE STOW
	TLZ AC0,ERRORS-ERROR1	;
	JUMPN AC0,OUTL32	;JUMP IF ERRORS
OUTML2:	TLNE IO,IOSALL		;SUPPRESSING ALL
	JUMPN MRP,CPOPJ		;YES,EXIT
	JRST OUTLI1		;NO,INIT LINE

OUTL32:	IDPB AC0,LBUFP		;ZERO TERNIMATOR
	IOR ER,OUTSW		;LIST ERRORS
	CALL OUTLER		;OUTPUT TAG AND FLAGS
	CALL OUTTAB
	MOVEI CS,SEQNO		;ADDRESS OF SEQUENCE NO.
	SKIPE SEQNO		;FILE NOT SEQUENCED
	CALL OUTAS0		;OUTPUT IT
	JRST OUTL25		;OUTPUT BASIC LINE

;OUTPUT ERROR HEADER AND SETUP ERROR FLAG LETTERS
; AC0/ ERROR FLAGS IN LH (NOTE: NOT RH LIKE ER)

OUTLER:	PUSH P,ER		;SAVE LISTING SWITCHES FOR LATER
	TRNE ER,TTYSW		;IF THIS IS ON, LISTING IS ON TTY
	TRZ ER,ERRORS		;SO SUPPRESS ON TTY
	TDZ ER,OUTSW		;BUT THIS SHOULD ONLY GO TO THE TTY
	MOVE CS,TAG
	CALL OUTSY1
	MOVEI C,"+"
	CALL OUTL
	MOVE C,LOCA		;CURRENT LOCATION
	SUB C,TAGINC		;COMPUTE DIFFERENCE FROM LAST TAG
	SKIPE LBLFLG		;[402] HAS A LABEL OCCURRED IN THIS LITERAL
	JRST [	MOVE C,STPY	;[402] GET OFFSET IN LITERAL STORAGE
		SUB C,LTGINC	;[402] ADJUST TO THE LAST LABEL IN LITERAL
		JRST OUTLE1]	;[402] 
	ADD C,STPY
	SUB C,STPX
OUTLE1:	CAIL C,0		;BE SURE REASONABLE RANGE
	CAILE C,1000
	SETZ C,
	CALL OUTOCT		;CONVERT INCREMENT TO OCTAL
	CALL OUTTAB		;OUTPUT TAB
	MOVE CS,INDIR		;GET FILE NAME
	CAME CS,LSTFIL		;AND SEE IF SAME
	SETOM LSTPGN		;ISN'T, GET IT TYPED
	MOVE CS,PAGENO		;NOW CHECK PAGE NUMBER
	CAMN CS,LSTPGN		;SAME?
	JRST OUTLE8		;YES, DON'T PRINT AGAIN
	MOVE CS,INDIR		;REMEMBER LAST FILE
	MOVEM CS,LSTFIL
	MOVEI CS,LSTFIL
	CALL OUTSIX		;TYPE FILE NAME
	MOVEI C," "
	CALL OUTL
	MOVE CS,PAGENO		;REMEMBER LAST PAGE NUMBER
	MOVEM CS,LSTPGN
	MOVEI CS,[ASCIZ /PAGE /]
	CALL OUTAS0
	MOVE C,PAGENO
	CALL DNC		;TYPE PAGE NUMBER
OUTLE8:	CALL OUTCR		;CR AFTER TAG AND PAGE
	HLLM ER,(P)		;RESTORE ER BUT NOT IO (LEFT HALF OF AC)
	POP P,ER
	MOVE CS,[POINT 7,[ASCII / QXADLRUVNOPEMS/]]
OUTLE2:	ILDB C,CS		;GET ERROR MNEMONIC
	JUMPGE AC0,OUTLE4	;BRANCH IF NOT FLAGGED
	CAIN C,"Q"		;"Q" ERROR?
	AOSA QERRS		;YES, JUST COUNT AS WARNING
	AOS ERRCNT		;INCREMENT ERROR COUNT
	CALL OUTL		;OUTPUT THE CHARACTER
OUTLE4:	LSH AC0,1		;SHIFT NEXT FLAG INTO SIGN BIT
	JUMPN AC0,OUTLE2	;TEST FOR END
	RET			;EXIT


OUTIM1:	TLOA FR,IOSCR		;SUPPRESS CRLF AFTER LINE
OUTIM:	TLZ FR,IOSCR		;DON'T FOR PARTIAL LINE
	TLNE IO,IOSALL		;SUPPRESSING ALL?
	JUMPN MRP,CPOPJ		;YES ,EXIT IF IN MACRO
	JUMP1 OUTLI1		;BYPASS IF PASS ONE
	PUSH P,ER
	TDZ ER,TYPERR
	TLNN IO,IOMSTR!IOPROG!IOMAC
	IOR ER,OUTSW
	PUSH P,C		;OUTPUT IMAGE
	TLNN FR,CREFSW
	CALL CLSCRF
OUTIM2:	MOVE CS,TABP
	CALL OUTASC		;OUTPUT TABS
	IDPB C,LBUFP		;STORE ZERO TERMINATOR
	MOVEI CS,LBUF
	CALL OUTAS0		;OUTPUT THE IMAGE
	TLZN FR,IOSCR		;CRLF SUPPRESS?
	CALL OUTCR		;NO,OUTPUT
	POP P,C
	HLLM ER,0(P)
	POP P,ER
	JRST OUTLI2

OUTLI:	TLNE IO,IOSALL		;SUPPRESSING ALL
	JUMPN MRP,OUTLI3	;YES,SET FLAG IN REPEATS ALSO
	TLNE IO,IOPALL		;MACRO EXPANSION SUPRESS REQUESTED?
	SKIPN MACLVL		;YES, ARE WE IN MACRO?
	TLZA IO,IOMAC		;NO, CLEAR MAC FLAG
OUTLI3:	TLO IO,IOMAC		;YES, SET FLAG

OUTLI1:	TRZ ER,ERRORS!LPTSW!TTYSW
OUTLI2:	MOVE CS,[POINT 7,LBUF]	;INITIALIZE BUFFERS
	MOVEM CS,LBUFP
   IFN FORMSW,<MOVE CS,[POINT 7,TABI]
	MOVSS HWFMT		;PUT FLAG IN LEFT HALF
	SKIPGE HWFMT>		;BUT IF ONLY HALF-WORD FORMAT
	MOVE CS,[POINT 7,TABI,6]
	MOVEM CS,TABP
	MOVEI CS,.CPL
   IFN FORMSW,<SKIPL HWFMT	;IF MULTI-FORMAT
	SUBI CS,8		;LINE IS ONE TAB SHORTER
	MOVSS HWFMT>		;BACK AS IT WAS
	SKIPE SEQNO		; A SEQUENCED FILE?
	SUBI CS,8		; YES, SEQ NO TAKES UP SPACE
	MOVEM CS,CPL
	MOVSI CS,(ASCII /	/)
	SKIPE SEQNO		;HAVE WE SEQUENCE NUMBERS?
	MOVEM CS,SEQNO		;YES, STORE TAB IN CASE OF MACRO
	MOVEM CS,SEQNO+1	;STORE TAB AND TERMINATOR
	SETZM ASGBLK
	SETZM LOCBLK
	RET


OUTIML:	JUMP2 [	PUSH P,STPX	;[314] SAVE CURRENT BUFFER VARIABLES
		PUSH P,EXTPNT	;[314] ..
		PUSH P,STPY	;[314] ..
		MOVE AC0,STPX	;[314] PRINT ONLY LITERALS SINCE
		EXCH AC0,LSTPY	;[314] LAST TIME
		MOVEM AC0,STPY	;[314] ..
		CALL OUTLIN	;[314] LIST THE LINE
		POP P,STPY	;[314] RESTORE CURRENT BUFFER VARIABLES
		POP P,EXTPNT	;[314] ..
		POP P,STPX	;[314] ..
		RET]		;[314]
	TRNN ER,ERRORS-ERRQ
	TLNE FR,ERRQSW
	TRZ ER,ERRQ
	HRLZ AC0,ER
	TLZ AC0,ERRORS-ERROR1-ERRL+ERRF ;[301] ANY ERRORS TO PRINT ON PASS1?
	JUMPE AC0,OUTML2	;[301] NONE
	PUSH P,ER		;SAVE
	PUSH P,C		;SAVE THIS
	TDZ ER,TYPERR
	IOR ER,OUTSW
	CALL OUTLER		;DO NOT FORGET ERRORS
	CALL OUTTAB
	SETZ AC0,		; SET A ZERO TERMINATOR
	IDPB AC0,LBUFP		; IN THE OUTPUT BUFFER
	MOVEI CS,LBUF		;PRINT REST OF LINE
	CALL SOUT20
	POP P,C
	POP P,ER
	JRST OUTLI1

SUBTTL OUTPUT ROUTINES
UOUT:	SETZM UNDCNT		;[514] CLEAR UNDEFINED SYMBOL COUNT
	CALL LOOKUP		;SET FOR TABLE SCAN
	TRNN ARG,PNTF		;WFW
	TRNN ARG,UNDF
	JRST UOUT13		;TEST FOR UNDF!EXTF!PNTF ON PASS2
	JUMP2 UOUT10
	TLNN IO,IOIOPF		;ANY IOP'S SEEN
	JRST UOUT12		;NO,MAKE EXTERNAL
	MOVSI CS,PRMTBL-PRMEND;YES LOOKUP IN TABLE
UOUT1:	CAME AC0,PRMTBL(CS)	;HAVE WE A MATCH?
	AOBJN CS,UOUT2		;NO,INCREMENT AND JUMP
	MOVE ARG,PRMTBL+1(CS);YES,GET VALUE
	MOVEM ARG,(SX)		;UPDATE SYMBOL TABLE
	RET			;EXIT
UOUT2:	AOBJN CS,UOUT1		;TEST FOR END

UOUT12:	TRNE ARG,ENTF		;[340] SEE IF FORWARD DEFINED
	RET			;[340] YES, THEN DON'T EXTERNAL IT
	CALL EXTER2		;MAKE IT EXTERNAL
	MOVSI ARG,UNDF		;BUT PUT UNDF BACK ON
	IORM ARG,(SX)		;SO MESSAGE WILL COME OUT
	RET			;GET NEXT SYMBOL

UOUT13:	JUMP1 CPOPJ		;RECYCLE ON PASS1
	TRC ARG,UNDF!EXTF!PNTF	;CHECK FOR ALL THREE ON
	TRCE ARG,UNDF!EXTF!PNTF	;ARE THEY?
	RET			;NO, RECYCLE

UOUT10:	AOS UNDCNT		;[514] INCREMENT UNDEFINED SYMBOL COUNT
	CALL OUTSYM		;OUTPUT THE SYMBOL
	CALL OUTTAB		;THEN A TAB
	MOVEI CS,[SIXBIT /UNASSIGNED, DEFINED AS IF EXTERNAL @/]
	CALL OUTSIX		;[360] 
	JRST OUTCR		;[360] POPJ FOR NEXT SYMBOL

				;OUTPUT THE ENTRIES

EOUT:	MOVEI C,0		;INITIALIZE THE COUNT
	MOVE SX,SYMBOL
	MOVE SDEL,0(SX)
EOUT1:	SOJL SDEL,EOUT2		;TEST FOR END
	ADDI SX,2
	HLRZ ARG,0(SX)
	ANDCAI ARG,SYMF!INTF!ENTF
	JUMPN ARG,EOUT1		;IF INVALID, DON'T COUNT
	AOJA C,EOUT1		;BUMP COUNT

EOUT2:	HRLI C,4		;BLOCK TYPE 4
	CALL OUTBIN
	SETZB C,ARG
	CALL OUTBIN
	MOVE SX,SYMBOL
	MOVE SDEL,0(SX)
	MOVEI V,^D18

EOUT3:	SOJL SDEL,POPOUT
	ADDI SX,2
	HLRZ C,0(SX)
	ANDCAI C,SYMF!INTF!ENTF
	JUMPN C,EOUT3
	SOJGE V,EOUT4		;TEST END OF BLOCK
	CALL OUTBIN
	MOVEI V,^D17		;WFW
EOUT4:	MOVE AC0,-1(SX)
	CALL SQOZE
	MOVE C,AC0
	CALL OUTBIN
	JRST EOUT3

LSOUT:	SKIPN C,LOCAL		;ANY LOCAL FIXUPS REQUIRED?
	RET			;NO
	MOVS AC0,(C)		;GET VALUE RIGHT WAY ROUND
	MOVS RC,1(C)		;AND RELOCATION
	HLRZM RC,LOCAL		;STORE NEXT POINTER
	CALL COUT		;OUTPUT THIS WORD
	JRST LSOUT		;LOOK FOR MORE


				;OUTPUT THE SYMBOLS
SOUT:	SKIPN IONSYM		;SKIP IF NOSYM SEEN
	TRNN ER,LPTSW!TTYSW	;A LISTING REQUIRED?
	JRST SOUT2		;NO
	MOVEI [ASCIZ /SYMBOL TABLE/]
	HRRM SUBTTX		;SET NEW SUB-TITLE
	MOVEI ARG,NCOLS		;SET UP FOR NCOLS ACROSS SYMBOL TABLE
	TRNE ER,TTYSW		;IS TTY LISTING DEVICE?
	MOVEI ARG,2		;YES,ONLY 2 COLLUMNS
	MOVEM ARG,NCOLLS	;STORE ANSWER
   IFE POLISH,<
	MOVE SX,SYMBOL		;START OF TABLE
	MOVE SDEL,(SX)		;COUNT OF SYMBOLS
   >
   IFN POLISH,<
	MOVE SX,SGSBOT		;START OF TABLE
	MOVE SDEL,SGNCUR	;CUR PSECT INX
   IFN FTPSEC,<
	JUMPE SDEL,SOUTBS	;IS THIS THE BLANK PSECT?
	MOVE ARG,[XWD SGTTLB,SGLIST]
	BLT ARG,SGTTLE-SGTTLB+SGLIST-1 ;MOVE SUBTTL
	MOVE AC1,SGTTLE		;'TO' POINTER
	MOVE AC2,SGTTLF		;'FROM' POINTER
SGTTLL:	ILDB AC0,AC2		;GET A SIXBIT CHAR
	ADDI AC0,40		;FORM ASCII
	IDPB AC0,AC1		;PUT IN SUBTTL
	TLNE AC2,770000		;DONE SIX CHARS?
	JRST SGTTLL		;NOT DONE YET
	SETZ AC0,		;TERMINATE SUBTTL
	IDPB AC0,AC1		; WITH NULL BYTE
	MOVEI AC0,SGLIST	;POINTER TO
	HRRM AC0,SUBTTX		; NEW SUBTTL
   >				;END OF FTPSEC NESTED IN POLISH
SOUTBS:	HRRZ SDEL,SGSCNT(SDEL)	;COUNT OF SYMBOLS
   >				;END OF POLISH
	ADDI SX,2		;SKIP COUNT
	MOVEM SX,SXSV		;SAVE PLACE
	MOVEM SDEL,SDELSV
	MOVE SX,SPAGNO		;GET LAST SYMBOL PAGE NUMBER
	EXCH SX,PAGENO		;SWAP WITH OUTPUT PAGE NUMBER
	MOVEM SX,SPAGNO		;AND STORE IT
	MOVE SX,[BYTE (7) 0,0,<"S">,<"-">,0]
	IORM SX,DBUF+4		;FIXUP TITLE

SOUT0:	CALL SOUTP		;GET PAGE SET UP
	  JRST SOUT1		;NOTHING TO OUTPUT
	CALL SOUTF		;DUMP ONE PAGE
	  JRST SOUT1		;DIDN'T FILL PAGE-DONE
	JRST SOUT0

   IFN POLISH,<
SGTTLB:	ASCII /SYMBOL TABLE FOR PSECT   /
SGTTLE:	POINT 7,SGTTLE-SGTTLB+SGLIST
SGTTLF:	POINT 6,SGNAME(SDEL)
   >

SOUTT:	MOVE ARG,(SX)		;GET FLAGS
	TLNE ARG,SUPRBT		;SURPRESSED?
	RET			;YES
	TLNN ARG,SYMF		;SYMBOL IS OK
	TLNN ARG,SYNF!MACF	;BUT MACRO OR SYNONYM AREN'T
	AOS (P)
	RET
SOUTP:	MOVE AC1,NCOLLS		;GET COLUMN COUNT
	MOVE SX,SXSV		;GET POSITION
	MOVE SDEL,SDELSV	;AND COUNT

SOUTP0:	MOVEM SX,SYMBLK(AC1)
	HRLM SDEL,SYMBLK(AC1)	;SAVE IN TABLE
	MOVE AC0,..LPP		; LINE COUNT

SOUTP1:	JUMPE SDEL,SOUTP2	;IF NONE LEFT, GO ELSEWHERE
	CALL SOUTT		;SYMBOL OK?
	  TDZA RC,RC		;NO
	SETO RC,		;YES
	ADDI SX,2		;SET UP FOR NEXT NOW
	SUBI SDEL,1
	JUMPGE RC,SOUTP1	;SKIP SYMBOL
	SOJG AC0,SOUTP1		;COUNT IN SYMBOL
	SOJG AC1,SOUTP0		;START NEXT COLUMN
	MOVEM SX,SXSV		;SAVE POSITION
	MOVEM SDEL,SDELSV
	AOS (P)
	RET

SOUTP2:	CLEARM SDELSV		;FLAG DONE
	CAME AC1,NCOLLS		;IF ON 1ST COLUMN
	JRST .+3
	CAMN AC0,..LPP		; AND FIRST LINE
	RET			;THEN SKIP PRINTING
	SOJLE AC1,CPOPJ1	;ALREADY GOT THIS LINE
	CLEARM SYMBLK(AC1)
	SOJG AC1,.-1		;ZERO ALL OTHERS
	JRST CPOPJ1
SOUTF:	CALL OUTFF		;GET TO TOP OF PAGE
	MOVE AC1,..LPP		;
	MOVEM AC1,COLSIZ

SOUTF1:	CALL SOUTL		;DUMP ONE LINE
	  RET			;WAS BLANK
	SOSLE COLSIZ		;ONE MORE DONE
	JRST SOUTF1		;MORE TO GO
SOUTF2:	JRST CPOPJ1

SOUTL:	MOVE AC1,NCOLLS		;SET COLUME COUNT
SOUTL0:	HRRZ SX,SYMBLK(AC1)
	HLRZ SDEL,SYMBLK(AC1);GET POSITION IN TABLE
	JUMPE SDEL,SOUTL3	;NOTHING THERE

SOUTL1:	CALL SOUTT		;SYMBLE PRINTABLE?
	  JRST SOUTL2		;CENCOR!!
	CALL SOUTE		;DUMP OUT ENTRY
	ADDI SX,2
	SUBI SDEL,1		;UP TP NEXT ONE
	HRL SX,SDEL		;SAVE OUR PLACE
	MOVEM SX,SYMBLK(AC1)
	SOJG AC1,SOUTL0		;NEXT!
	AOS (P)
	JRST OUTCR		;POLISH OFF LINE

SOUTL2:	ADDI SX,2
	SOJG SDEL,SOUTL1	;KEEP SEARCHING
SOUTL3:	CAME AC1,NCOLLS		;BLANK LINE?
	AOS (P)			;NO
	JRST OUTCR
SOUTE:	MOVE AC0,-1(SX)
	CALL OUTSYM		;DUMP SYMBOL OUT
	CALL OUTTAB		;THEN A TAB
	CALL SRCH7		;GET VALUE
	TLNN ARG,EXTF		;EXTERNAL?
	JRST .+5
	HLRZ RC,V		;YES, NEED FIXUP
	TRNE RC,-2
	MOVS RC,(RC)
	HLL V,RC

	HLLO CS,V
	TLNE RC,-1
	TRZ CS,1
	TLNE RC,-2
	TRZ CS,EXTF
	TLNN V,-1
	TLNE RC,-1
	CALL ONC1
	CALL OUTTAB
	HRLO CS,V
	TRNE RC,-1
	TRZ CS,1
	TRNE RC,-2
	TRZ CS,EXTF
	CALL ONC1
	CALL OUTTAB		;AND TAB, OF COURSE
	CALL SOUTE8		;ABBREVIATION FOR TYPE
	JRST OUTTAB		;FINAL TAB

SOUTE8:	TLNN ARG,INTF!EXTF!ENTF!UNDF!NOOUTF
	 RET			;SKIP JUNK FOR SIMPLE STUFF
	SETZ CS,
	TLNE ARG,INTF		;INTERNAL
	MOVEI CS,1
	TLNE ARG,EXTF		;EXTERNAL
	MOVEI CS,-1
	TLNE ARG,ENTF		;ENTRY
	MOVEI CS,-5
	TLNE ARG,NOOUTF		;DDT SURPRESSED
	ADDI CS,3
	TLNE ARG,UNDF		;UNDEFINED
	MOVEI CS,-3		;SET FOR UDF
	MOVEI CS,SOUTC(CS)	;GET ABREVIATION
	JRST OUTAS0

SOUT1:	MOVE SX,PAGENO		;GET LAST SYMBOL PAGE NUMBER
	EXCH SX,SPAGNO		;SWAP WITH OUTPUT PAGE NUMBER
	MOVEM SX,PAGENO		;AND STORE IT
	MOVE SX,[BYTE (7) 0,0,<"S">,<"-">,0]
	ANDCAM SX,DBUF+4	;FIXUP TITLE
SOUT2:	CALL SGLKUP		; SET FOR TABLE SCAN
	TRNN ARG,SYMF
	TRNN ARG,MACF!SYNF
	TDZA MRP,MRP		;SKIP AND CLEAR MRP
	RET			;NO, TRY AGAIN
	TRNE ARG,INTF
	MOVEI MRP,1
	TRNE ARG,EXTF
	MOVNI MRP,1		;MRP=-1 FOR EXTERNAL
	TRNE ARG,SYNF		;SYNONYM?
	JUMPL MRP,POPOUT	;YES, DON'T OUTPUT IF EXTERNAL
	TRNE ARG,SUPRBT		;IF SUPRESSED
	RET			;DO NOT OUTPUT
	JUMPGE MRP,SOUT10	;BRANCH IF NOT EXTERNAL
	HLRZ RC,V		;PUT POINTER/FLAGS IN RC
	TRNE RC,-2		;POINTER?
	MOVS RC,0(RC)		;YES
	HLL V,RC		;STORE LEFT VALUE
SOUT10:	PUSH P,RC		;SAVE FOR LATER
	MOVEI AC1,0
	JUMPLE MRP,SOUT15	;SET DEFFERRED BITS IF INTERN=EXTERN
	TDNE RC,[-2,,-2]	;CHECK FOR INTERN=EXTERN
	TRZ ARG,NOOUTF		;YES, SO CLEAR SUPPRESS FLAG
   IFN POLISH,<
	JUMPL RC,.+3		;[305] ONLY SET RHS FIXUP FLAG IF POLISH
   >
	TLNE RC,-2		;CHECK FOR LEFT FIXUP
	IORI AC1,40		;AND SET BITS
	TRNE RC,-2		;CHECK FOR RIGHT FIXUP
	IORI AC1,20		;AND SET BITS
SOUT15:	TLNE RC,-2		;FIX RELOC AS 0 IF EXTERNAL
	HRRZS RC
	TRNE RC,-2
	HLLZS RC
	TLZE RC,-1
	TRO RC,2
	HRL MRP,RC
	MOVEI RC,0
	TRNE ARG,ENTF		;ENTRY DMN
	HRRI MRP,-5
	TRNE ARG,NOOUTF		;SUPRESS OUTPUT? WFW
	ADDI MRP,3		;YES WFW
	TRNE ARG,UNDF		;UNDEFINED IS EXTERNAL
	HRRI MRP,2		;SO FLAG AS UDF
	IOR AC1,SOUTC(MRP)
	MOVE ARG,AC1
	CALL NOUT2		;SQUOZE AND DUMP THE SYMBOL
	MOVEM AC0,SVSYM		;SAVE IT
	MOVE AC0,V		;GET THE VALUE
	HLRZ RC,MRP		;AND THE RELOCATION

	CALL COUT
	POP P,RC		;GET BACK RELOC AND CHECK EXTERNAL
	TRNN RC,-2		;IS IT?
	JRST SOUT50		;NO
   IFN POLISH,<
	JUMPL RC,SOUT70		;[305] SPECIAL POLISH SYMBOL FIXUP
   >
	MOVE AC0,1(RC)		;GET NAME
	MOVEI ARG,60		;EXTERNAL REQ
	CALL SQOZE
	HLLZS RC		;NO RELOC
	CALL COUT		;OUTPUT IT
	MOVE AC0,SVSYM		;GET SYMBOL NAME
	TLO AC0,500000		;SET AS ADDITIVE SYMBOL
	TLZ AC0,200000		;BUT NOT LEFT HALF ETC
	CALL COUT
SOUT50:	MOVSS RC		;CHECK LEFT HALF
	TRNN RC,-2
	RET
	MOVE AC0,1(RC)
	MOVEI ARG,60
	CALL SQOZE
	MOVEI RC,0
	CALL COUT
	MOVE AC0,SVSYM
	TLO AC0,700000
	JRST COUT

   IFN POLISH,<
SOUT70:	CALL COUTD		;[305] DUMP CURRENT BLOCK
	PUSH P,SYMBOL		;SAVE CURRENT SYMBOL TABLE ORIGIN
	PUSH P,FREE		;SAVE FREE STORAGE ORIGIN
	PUSH P,BLKTYP		;[305] SAVE CURRENT BLOCK TYPE
	MOVEI AC0,11		;[305] SET TO POLISH
	MOVEM AC0,BLKTYP	;[305]
	PUSH P,POLIST		;[305] SAVE REAL LIST
	SETZM POLIST		;[305] INITIALIZE
	SKIPE (RC)
	JFCL
	MOVNI AC0,3		;[305] ASSUME FULL WORD FIXUP
	MOVEM AC0,POLTYP	;[305]
	MOVE AC0,SVSYM		;[305] RADIX-50 SYMBOL
	TLZ AC0,740000		;[305] CLEAR CODE BITS
	MOVEM AC0,INASGN	;[305] FLAG SYMBOL FIXUP
	CALL POLSYM		;[305] NOW CONVERT
	CALL POUT		;[305] DUMP THIS BLOCK
	CALL COUTD		;[305] FORCE BLOCK OUT
	MOVSI AC0,(POINT 2)	;[305] RESET BYTE FIELD
	HLLM AC0,COUTP		;[305] 
	POP P,POLIST		;[305] PUT LIST BACK
	POP P,BLKTYP		;[305] PREVIOUS BLOCK TYPE
	POP P,FREE		;GIVE BACK FREE STG USED BY POLSYM
	POP P,AC0		;RECOVER SYMTAB ORIGIN
	SUB AC0,SYMBOL		;COMPUTE DIFFERENCE IN CASE SYMTAB MOVED
	SUB SX,AC0		;ADJUST LOCAL PTR ACCORDINGLY
	RET			;[305]
   >

	<ASCII /ENT/>!04	;DMN
	0
	<ASCII /UDF/>!60	;UNDEFINED EXTERNAL
	<ASCII /SEN/>!44	;SUPRESSED ENTRY
	<ASCII /EXT/>!60
SOUTC:	EXP 10
	<ASCII /INT/>!04
	<ASCII /SEX/>!60	;SUPPRESSED EXTERNAL (NOT USED YET)
	<ASCII /SPD/>!50
	<ASCII /SIN/>!44	;DMN

				;OUTPUT THE BINARY

BOUT:	HRRZ CS,LOCA		; PICKUP THE LOCATION
	SUB CS,STPX		; MINUS START
	ADD CS,STPY		; PLUS END
	HRLO CS,CS		; TO GET ASSEMBLY LOCATION
	SKIPGE BLSW		;BINARY LISTING OFF?
	JRST BOUT1		;YES
	ILDB C,TABP		;[314] DO A TAB
	CALL OUTL		;[314]
	SKIPLE LITLVL		;[314] IN LITERAL?
	JRST BOUT1		;[314] YES, DON'T LIST LOCATION
	CALL ONC1		;[314]OUTPUT IT TO THE LISTING FILE
	MOVEI C,"'"
	SKIPE MODA		; IF MODE IS NOT ABSOLUTE
	CALL OUTC		;PRINT A SINGLE QUOTE
BOUT1:	CALL DSTOW		;GET THE CODE
	PUSH P,RC		;SAVE RELOC
	PUSH P,RC		;AND AGAIN
	TLNE RC,-2		;CHECK LEFT EXTERNAL
	HRRZS RC		;MAKE LEFT NON-RELOC
	SKIPG LITLVL		;[314] NOT IN LITERAL?
	TRNN RC,-2		;RIGHT EXT?
	JRST BOUT30		;NO
	HRRZ AC1,AC0		;YES
	JUMPE AC1,BOUT20	;PROCESS IF ZERO CODE THERE
	HLLZS RC		;MAKE NON-RELOC
	JRST BOUT30		;PROCESS

BOUT20:	HRRM AC1,-1(P)		;FIX RC IN STACK SO NO CONFUSION WFW (AC1 HAS 0)
	HRR AC0,0(RC)		;NO, SET ADDRESS LINK
	MOVE AC1,LOCO		;GET CURRENT LOCATION
	HRRM AC1,0(RC)		;SET NEW LINK
	HLRZ AC1,0(RC)		;GET FLAGS/POINTER
	TRNN AC1,-2		;POINTER?
	HRR AC1,RC		;NO, SET TO FLAGS
	HLR RC,0(AC1)		;PUT FLAGS IN RC
	HRL AC1,MODO		;GET CURRENT MODE
	TRZE RC,-2		;LEFT HALF RELOCATABLE+
	TLO AC1,2		;YES, SET FLAG
	HLLM AC1,0(AC1)		;STORE NEW FLAGS
BOUT30:	HLLO CS,AC0
	TLZE RC,1		;PACK RELOCATION BITS
	TRO RC,2
	TRNE RC,2		;LEFT HALF RELOCATABLE?
	TRZ CS,1		;YES, RESET BIT
	SKIPGE BLSW		;BINARY LISTING OFF?
	JRST BOUT3I		;YES
	PUSH P,AC0		;NEED AN AC
	HLRZ AC0,-1(P)		;AC0 = LEFT RELOCATION
	CAILE AC0,1		;EXTERNAL?
	XORI CS,EXTF!1		;YES, SET SWITCH

   IFN FORMSW,<
	OR AC0,HWFMT
	JUMPN AC0,BOUT3H	;EDIT IN HALF WORD FORMAT IF NOT 0
	MOVE AC0,FORM		;GET FORM WORD
	MOVEI C,0		;ZERO FIELD SIZE
BOUT3A:	JFFO AC0,BOUT3B		;AC1 = FIELD SIZE -1
	JRST BOUT3C		;NO FIELDS LEFT, JUMP
BOUT3B:	LSH AC0,1(AC1)		;SHIFT OFF FORM FIELD
	MOVEI AC1,6(AC1)
	IDIVI AC1,3		;AC1 = COLUMNS USED + 1
	ADDI C,(AC1)		;INCREMENT FIELD SIZE
	CAIG C,^D23		;IS FIELD SIZE GTR 23?
	JRST BOUT3A		;NO.  CONTINUE
	MOVE AC1,HWFORM		;USE STANDARD FORM
	MOVEM AC1,FORM
	MOVEI C,^D13		;SET FIELD SIZE TO 13
BOUT3C:	MOVEM C,FLDSIZ		;STORE FIELD SIZE
	MOVE AC0,FORM		;AC0 = FORM WORD
	TRNN RC,2		;IS LEFT HALF RELOCATED?
	CAMN AC0,HWFORM		;NO.  IS FORM HALF WORD?
	JRST BOUT3H		;YES.  EDIT IN OLD WAY
	IBP TABP
	CAIL C,^D16
	IBP TABP
	ILDB C,TABP		;GET A TAB
	CALL OUTL		;OUTPUT IT
	MOVE AC2,(P)		;AC2 = INFO TO BE EDITED
	PUSH P,CS		;SAVE CS = C+1
BOUT3D:	JFFO AC0,BOUT3E		;AC1 = FIELD LENGTH - 1
BOUT3E:	LSH AC0,1(AC1)		;SHIFT OFF FORM FIELD
	MOVEI C,3(AC1)
	MOVEI AC1,0
	LSHC AC1,-2(C)		;AC1 = FIELD INFO
	IDIVI C,3		;C = # OF OCTAL DIGITS
	MOVE C+1,AC0		;SAVE AC0
	SKIPE IOSEEN		;IS THIS A I/O INST.
	CALL BOUT3J		;YES,SET FIELDS CORRECTLY
	MOVNS C
	ROT AC1,(C)
	ROT AC1,(C)
	ROT AC1,(C)
	MOVNS C

BOUT3F:	MOVEI AC0,6		;EDIT A DIGIT
	LSHC AC0,3
	EXCH AC0,C
	CALL OUTC		;OUTPUT IT
	MOVE C,AC0
	SOJG C,BOUT3F		;IF MORE DIGITS,  GO BACK
	JUMPE C+1,BOUT3G	;JUMP IF END OF WORD
	MOVE AC0,C+1		;RESTORE AC0
	MOVEI C," "
	CALL OUTC		;OUTPUT A SPACE
	JRST BOUT3D		;PROCESS NEXT FIELD

BOUT3G:	POP P,CS		;RESTORE CS = C+1
	MOVEI C," "
	TRNE RC,1		;RELOCATABLE?
	MOVEI C,"'"		;YES
	HRRZ AC0,-1(P)		;AC0 = RIGHT RELOCATION
	CAILE AC0,1		;EXTERNAL?
	MOVEI C,"*"		;YES
	TLNE FR,POLSW		;POLISH?
	MOVEI C,"#"		;YES,
	CALL ONC2		;STORE POSSIBLE INDICATOR
	POP P,AC0
	JRST BOUT3I		;CONTINUE

BOUT3H:	MOVEI C,^D15		;SET SIZE TO 15
	MOVEM C,FLDSIZ		;
	SETZM IOSEEN		;CLEAR INCASE HWFMT WAS SET
   >
	POP P,AC0		;RESTORE
	CALL ONC
	HRLO CS,AC0
	TDZ CS,RC		;SET RELOCATION
	HRRZ C,(P)		;C = RIGHT RELOCATION
	CAILE C,1		;EXTERNAL
	XORI CS,EXTF!1		;YES, SET SWITCH
	CALL ONC
BOUT3I:	POP P,CS		;GET RID OF ENTRY ON STACK
	SKIPLE LITLVL		;[314] IN LITERAL?
	JRST [	POP P,RC	;[314] YES, CLEAR STACK
		RET]		;[314] DON'T OUTPUT TO REL
	HRRZ CS,LOCO
	TLNE FR,RIMSW!RIM1SW!R1BSW ;RIM OUTPUT?
	JRST ROUT		;YES, GO PROCESS

	HRL CS,MODO
	CAME CS,MODLOC		;SEQUENCE OR RELOCATION BREAK?
	CALL COUTD		;YES, DUMP THE BUFFER
	SKIPL COUTX		;NEW BUFFER?
	JRST BOUT40		;NO, STORE CODE AND EXIT
	MOVEM CS,MODLOC		;YES, STORE NEW VALUES
	EXCH AC0,LOCO
	EXCH RC,MODO
	CALL COUT		;STORE BLOCK LOCATION AND MODE
	EXCH RC,MODO		;RESTORE CURRENT VALUES
	EXCH AC0,LOCO

BOUT40:	CALL COUT		;EMIT CODE
	POP P,RC		;RETRIEVE EXTERNAL BITS
	TRNN RC,-2		;RIGHT EXTERNAL?
	JRST BOUT50		;TRY FOR LEFT
	CALL COUTD
	PUSH P,BLKTYP		;TERMINATE TYPE AND SAVE
	MOVEI AC0,2		;BLOCK TYPE 2
	MOVEM AC0,BLKTYP
	MOVE AC0,1(RC)		;GET SYMBOL
	MOVEI ARG,60		;CODE BITS
	CALL SQOZE		;CONVERT TO RADIX 50
	HLLZS RC		;SYMBOL HAS NO RELOCATION
	CALL COUT		;EMIT
	MOVE AC0,LOCO		;GET CURRENT LOC
	HRLI AC0,400000		;ADDITIVE REQ
	HRR RC,MODO		;CURRENT MODE
	CALL COUT		;EMIT
	MOVSS RC		;NOW FOR LEFT
	TRNN RC,-2
	JRST BOUT60
	JRST BOUT70
BOUT50:	MOVSS RC		;CHECK OTHER HALF
	TRNN RC,-2		;LEFT HALF EXTERNAL?
	JRST BOUT80		;NO, FALSE ALARM
	CALL COUTD		;CHANGE MODE
	PUSH P,BLKTYP
	MOVEI AC0,2
	MOVEM AC0,BLKTYP
BOUT70:	MOVE AC0,1(RC)
	MOVEI ARG,60
	CALL SQOZE
	HLLZS RC
	CALL COUT
	MOVE AC0,LOCO
	HRLI AC0,600000		;LEFT HALF ADD
	HRR RC,MODO
	CALL COUT		;EMIT
BOUT60:	CALL COUTD		;CHANGE MODE
	POP P,BLKTYP		;TO OLD ONE
BOUT80:	AOS LOCO
	AOS MODLOC
	RET

   IFN FORMSW,<
BOUT3J:	MOVSS IOSEEN		;SWAP
	SKIPGE IOSEEN		;SKIP IF NOT FIRST FIELD
	JRST [HLLZS IOSEEN	;CLEAR RIGHT HALF
		RET]		;AND RETURN
	MOVSS IOSEEN		;SWAP BACK
	LSH AC1,2		;CORRECT  MNEMONIC AND OP CODE
	CAIE C,1		;IS IT OP CODE?
	RET			;NO,JUST RETURN
	MOVEI C,2		;TWO CHAR. WIDE NOW
	SETZM IOSEEN		;DON'T COME AGAIN
	RET			;RETURN
   >

NOUT:	MOVE V,[POINT 7,TBUF]	;POINTER TO ASCII LINE
	MOVSI CS,(POINT 6,AC0)	;POINTER TO SIXBIT AC0
	SETZB ARG,AC0
NOUT1:	ILDB C,V		;GET ASCII
	CAIL C,"A"+40
	CAILE C,"Z"+40
	JRST .+2
	TRZA C,100		;LOWER CASE TO SIXBIT
	SUBI C,40		;CONVERT TO SIXBIT
	JUMPLE C,NOUT3		;TEST FORM NON-SIXBIT
	CAILE C,77		;AND NOT GREATER THAN SIXBIT
	JRST NOUT3		;...
	LDB AC1,[POINT 6,CSTAT(C),23] ;[523] INDEX TO CSTAT
	SKIPN AC1		;[523] RADIX 50?
	JRST NOUT3		;[523] NO, ASSUME TERMINATOR
	IDPB C,CS		;DEPOSIT IN AC0
	TLNE CS,770000		;TEST FOR SIX CHARACTERS
	JRST NOUT1		;NO, GET ANOTHER
NOUT3:	SKIPGE UNIVSN		;IF A UNIVERSAL PROG
	RET			;RETURN TO PUT IT IN THE TABLE

   IFN CCLSW,<SKIPN TBUF+1	;AND IF WE HAVE NOT SEEN A TITLE
	CALL PRNAM>		;THEN PRINT THE NAME
	CALL NOUT2		; DUMP NAME
	MOVSI AC0,11		; TYPE MARKER
	IOR AC0,CPUTYP		; CPU  TYPE
	PJRST COUT		; DUMP AND EXIT

NOUT2:	CALL SQOZE		;CONVERT TO SIXBIT
	JRST COUT		;DUMP AND EXIT

HOUT:
   IFN POLISH,<
	SETZ AC0,		; FORCE TO PSECT 0
	SKIPE SGNMAX		; NO PSECTS
	CALL SGOUTN		; PUT IT OUT
   >
	MOVEI RC,1		;RELOCATABLE
	MOVE AC0,HHIGH		;GET HIGH SEG IF TWO SEGMENTS
	JUMPE AC0,.+2		;NOT TWO SEGMENTS
	CALL COUT		;OUTPUT IT 
	MOVE AC0,SGATTR		;
	SKIPE HHIGH		;ANY TWOSEG HIGH STUFF
	JRST COUT		;YES,SO NO ABS.
	CALL COUT		;OUTPUT THE HIGHEST LOCATION
	MOVE AC0,ABSHI
				;PUT OUT ABS PORTION OF PROGRAM BREAK
	SOJA RC,COUT		;OUTPUT A WORD OF ZERO AND EXIT

   IFN POLISH,<			;
;HERE TO OUTPUT BLOCK TYPE 11
POUT:	SKIPN POLIST		;ANY POLISH TO OUTPUT?
	RET			;NO
	TLO FR,POLSW		;SET FLAG
	CALL COUTD		;DUMP BUFFER UNLESS EMPTY
	MOVE CS,@POLIST		;GET A BLOCK POINTER
	EXCH CS,POLIST		;SET FOR NEXT TIME
POUTA:	ADDI CS,1		;FIRST WORD
	MOVE AC0,(CS)		;GET SOMETHING
	SETZ RC,		;CLEAR RELOCATION
	JUMPL AC0,POUTOP	;THIS IS AN OPERATOR
	CALL PCOUT		;STORE THIS HALF WORD
	JUMPE AC0,POUT0		;18 BIT VALUE
	SOJE AC0,POUT1		;36 BIT VALUE
	HLRZ AC0,1(CS)		;GET HALF OF SYMBOL
	CALL PCOUT
	HRRZ AC0,1(CS)		;GET OTHER HALF
	CALL PCOUT
	AOJA CS,POUTA

POUT0:	HLRZ RC,1(CS)		;GET RELOCATION
	HRRZ AC0,1(CS)		;AND VALUE
	CALL PCOUT
	AOJA CS,POUTA		;GET NEXT

POUT1:	HLRZ RC,1(CS)		;GET LEFT HALF
	HLRZ AC0,2(CS)
	CALL PCOUT
	HRRZ RC,1(CS)		;RIGHT HALF
	HRRZ AC0,2(CS)
	CALL PCOUT
	ADDI CS,2		;SKIP OVER 2 WORDS
	JRST POUTA

POUTOP:	HRRZ AC0,AC0		;GET OPERATOR ONLY
	CALL PCOUT		;OUTPUT
	CAIGE AC0,-6		; CHECK FOR STORE OP
	JRST POUTA		;ITS NOT
	CAIGE AC0,-3		;CHECK FOR SYMBOL FIXUP
	JRST POUTSY		;IT IS
	HLRZ RC,1(CS)		;GET RELOCATION
	HRRZ AC0,1(CS)		;AND STORE ADDRESS
POUTOQ:	CALL PCOUT
	TLZ FR,POLSW		;CLEAR FLAG INCASE END
	JRST POUT		;SEE IF MORE TO GO

POUTSY:	HLRZ AC0,1(CS)		;GET LHS SYMBOL
	SETZ RC,		;NO RELOCATION
	CALL PCOUT		;OUTPUT IT
	HRRZ AC0,1(CS)		;GET RHS
	CALL PCOUT
	SETZ AC0,		;FOLLOW WITH 0 FOR BLOCK LEVEL (FAIL COMPATIBLE)
	CALL PCOUT		;LHS
	PJRST POUTOQ		;RHS

PCOUT:	MOVE C,COUTP		;GET POINTER
	TLNE C,010000		;LEFT OR RIGHT HALF?
	JRST PCOUTR		;JUST THE RIGHT HALF
	AOS C,COUTX		;INCREMENT INDEX
	HRLZM AC0,COUTDB(C)	;STORE LEFT HALF
	IDPB RC,COUTP		;AND RELOCATION
	RET

PCOUTR:	MOVE C,COUTX		;GET CURRENT INDEX
	HRRM AC0,COUTDB(C)	;STORE RIGHT HALF
	IDPB RC,COUTP		;AND RELOCATION
	CAIE C,^D17		;IS THE BUFFER FULL
	RET			;NO
	HRROI  RC,[SIXBIT /PTC POLISH TOO COMPLEX@/]
	CALL EFATAL		;[546] FATAL ERROR
	CALL TYPMSG		;[305] PRINT MESSAGE
	RET			;[546] FORGET ABOUT THIS BLOCK

;HERE TO OUTPUT BLOCK TYPE 22 - PSECT NAME
SGOUTN:	CALL COUTD		;FINISH OFF CURRENT BLOCK
	PUSH P,BLKTYP		;SAVE CURRENT BLOCK TYPE
	MOVEI AC0,22		;BLOCK TYPE 22 IS A
	MOVEM AC0,BLKTYP	; PSECT NAME
	MOVE C,SGNCUR		;GET CUR PSECT INX
	MOVE AC0,SGNAME(C)	;GET PSECT NAME
	SETZ RC,		;CLEAR RELOCATION
	CALL COUT		;OUTPUT THE BLOCK
	MOVE C,SGNCUR		;INDEX AGAIN
	HRRZ AC0,SGORIG(C)	;GET ORIGIN IF SPECIFIED
	SKIPE AC0		;NOT
	CALL COUT
	CALL COUTD		;FINISH IT OFF
	POP P,BLKTYP		;RESTORE CURRENT BLOCK TYPE
	RET			;RETURN

;HERE TO OUTPUT BLOCK TYPE 23 - PSECT LENGTH AND ATTRIBUTES
SGOUTL:	CALL COUTD		;FINISH OFF CURRENT BLOCK
	PUSH P,BLKTYP		;SAVE CURRENT BLOCK TYPE
	MOVEI AC0,23		;BLOCK TYPE 23 IS A
	MOVEM AC0,BLKTYP	; PSECT LENGTH
	MOVE RC,SGNCUR		;GET CUR PSECT INX
	MOVE AC0,SGNAME(RC)	;GET PSECT NAME
	SETZ RC,		;CLEAR RELOCATION
	CALL COUT		;OUTPUT THE NAME
	MOVE RC,SGNCUR		;GET CUR PSECT INX
	MOVE AC0,SGATTR(RC)	;GET PSECT LENGTH AND ATTRS
	MOVEI RC,1		;BREAK IS RELOCATED
	CALL COUT		;OUTPUT THE LENGTH AND ATTRS
	CALL COUTD		;FINISH IT OFF
	POP P,BLKTYP		;RESTORE CURRENT BLOCK TYPE
	RET			;RETURN
   >

HSOUT:	SETZM HISNSW		;CLEAR FOR PASS2
	MOVE AC0,SVTYP3		;GET HISEG ARG
	JUMPGE AC0,.+4		;JUMP IF ONLY HISEG
	HRL AC0,HIGH1		;GET BREAK FROM PASS 1
	JUMPL AC0,.+2		;OK IF GREATER THAN 400000
	HRLS AC0		;SIGNAL TWO SEGMENT TO LOADER
	MOVEI RC,1		;ASSUME RELOCATABLE
	JRST COUT		;OUTPUT THE WORD

VOUT:	SKIPN RC,VECREL		;IS VECTOR ABSOLUTE ZERO?
	SKIPE VECTOR		;ALSO CHECK RELOCATION
	JRST .+3		;
	SKIPN VECSYM		; SEE IF SYMBOLIC
	RET			;YES, EXIT
   IFN POLISH,<
	MOVE AC0,VECFND		;GET START ADR PSECT INX
	MOVEM AC0,SGNCUR	;POINT CUR PSECT THERE
	SKIPE SGNMAX		;IF PSECTS WERE USED
	CALL SGOUTN		; THEN PUT OUT PSECT BLOCK
	MOVE RC,VECREL>		;GET RELOCATION
	MOVE AC0,VECTOR		;AC0 SHOULD BE FLAGS
	SKIPN VECSYM		; 2 WORDS IF SYMBOLIC
	JRST COUT
	CALL COUT		;OUTPUT CONSTANT
	MOVE AC0,VECSYM		; GET SYMBOL
	MOVEI ARG,60		; MAKE REQUEST
	CALL SQOZE		; IN RADIX-50
	SETZ RC,		;

COUT:	AOS C,COUTX		;INCREMENT INDEX
	MOVEM AC0,COUTDB(C)	;STORE CODE
	IDPB RC,COUTP		;STORE RELOCATION BITS
	CAIE C,^D17		;IS THE BUFFER FULL?
	RET			;NO, EXIT

COUTD:	AOSG C,COUTX		;DUMP THE BUFFER
	JRST COUTI		;BUFFER WAS EMPTY
	HRL C,BLKTYP		;SET BLOCK TYPE
COUTT:				; ENTER FROM .TEXT PSEUDO-OP
	CALL OUTBIN		;OUTPUT COUNT AND TYPE
	SETOB C,COUTY		;INITIALIZE INDEX

COUTD2:	MOVE C,COUTDB(C)	;GET RELOCATION BITS/CODE
	CAMN SDEL,[XWD 440000,0] ;[331] IF .TEST, ONLY OUTPUT THE RELOCATION
	TRZN C,1		;[331] WORD IF IT HAS DATA OR IS NEEDED
				;[331] FOR A NULL STRING TERMINATOR
	CALL OUTBIN		;DUMP IT
	AOS C,COUTY		;INCREMENT INDEX
	CAMGE C,COUTX		;TEST FOR END
	JRST COUTD2		;NO, GET NEXT WORD

COUTI:	SETOM COUTX		;INITIALIZE BUFFER INDEX
	SETZM COUTRB		;ZERO RELOCATION BITS
   IFN POLISH,<
	HRRZ C,BLKTYP		; IF WE ARE OUTPUTING
	CAIN C,11		; POLISH BLOCK TYPE 11
	SKIPA C,[POINT 1,COUTRB] ; USE HALF WORDS
   >
	MOVE C,[POINT 2,COUTRB]
	MOVEM C,COUTP		;INITIALIZE BIT POINTER
	RET			;EXIT


STOWZ1:
   IFN FORMSW,< MOVE AC1,HWFORM> ;USE STANDARD FORM
STOWZ:	MOVEI RC,0
STOW:
   IFN FORMSW,< MOVEM AC1,FORM>	;STORE FORM WORD
   IFN TSTCD,<
	SKIPE TCDFLG		;[414] TESTING NEW LINK CODES?
	JRST STOWTC		;[414] YES.
   >
	JUMP1 STOW20		;SKIP TEST IF PASS ONE
	TRNE RC,-2		;RIGHT HALF ZERO OR 1?
	CALL STOWT		;NO, HANDLE EXTERNAL
	TLNN RC,-2		;LEFT HALF ZERO OR 1? WFW
	JRST STOW10		;YES, SKIP TEST
	MOVSS RC		;SWAP HALVES
	CALL STOWT1		;HANDLE EXTERNAL WFW
	MOVSS RC		;RESTORE VALUES

STOW10:	SKIPE EXTPNT		;ANY EXTERNALS REMAINING?
	TRO ER,ERRE		;YES, SET EXTERNAL ERROR FLAG

STOW20:	AOS AC1,STPX		;INCREMENT POINTER
	MOVEM AC0,STCODE(AC1)	;STOW CODE
	MOVEM RC,STOWRC(AC1)	;STOW RELOCATION BITS
   IFN FORMSW,<
	PUSH P,FORM
	POP P,STFORM(AC1)	;STORE FORM WORD
   >
	SKIPN LITLVL		;ARE WE IN LITERAL?
	AOS LOCA		;NO, INCREMENT ASSEMBLY LOCATION
	CAIGE AC1,.STP-1	;OVERFLOW?
	RET			;NO, EXIT

	SKIPE LITLVL		;ARE WE IN A LITERAL?
	TROA ER,ERRL		;YES, FLAG ERROR BUT DON'T DUMP
	JRST CHARL1		;NO, SAVE REGISTERS AND DUMP THE BUFFER
	JRST STOWI		;INITIALIZE BUFFER

;GET ONE WORD FROM CODE BUFFER

DSTOW:	AOS AC1,STPY		;INCREMENT POINTER
	MOVE AC0,STCODE(AC1)	;FETCH CODE
	MOVE RC,STOWRC(AC1)	;FETCH RELOCATION BITS
   IFN FORMSW,<
	PUSH P,STFORM(AC1)
	POP P,FORM		;GET FORM WORD
   >
	CAMGE AC1,STPX		;IS THIS THE END?
	RET			;NO, EXIT

STOWI:	SETOM STPX		;INITIALIZE FOR INPUT
	SETOM STPY		;INITIALIZE FOR OUTPUT
	SETZM EXTPNT
	RET			;EXIT


;EXTERNAL RIGHT

STOWT:	HRRZ AC1,EXTPNT		;GET RIGHT POINTER
	CAIE AC1,(RC)		;DOES IT MATCH 
	CALL QEXT		;EXTERNAL OR RELOCATION ERROR
	HLLZS EXTPNT
	RET			;EXIT

;EXTERNAL LEFT

STOWT1:	HLRZ AC1,EXTPNT		;GET LEFT HALF
	CAIE AC1,(RC)		;SEE ABOVE
	CALL QEXT
	HRRZS EXTPNT
	RET			;EXIT


   IFN TSTCD,<
STOWTC:
	SKIPE RC		;[414] RELOCATABLE OR EXTERNAL?
	CALL QEXT		;[414] YES, FLAG ERROR
	JUMP1 CPOPJ		;[414] IF PASS 1, RETURN
	MOVE C,AC0		;[414] GET VALUE
	JRST OUTBIN		;[414] DEPOSIT INTO REL FILE AND RETURN
   >

ONC:	ILDB C,TABP		;ENTRY TO ADVANCE TAB POINTER
	CALL OUTL		;OUTPUT A TAB
				;OUTPUT 6 OCT NUMBERS FROM CS LEFT
ONC1:	MOVEI C,6		;CONVERT TO ASCII
	LSHC C,3		;SHIFT IN OCTAL
	CALL OUTL		;OUTPUT ASCII FROM C
	TRNE CS,-1		;ARE WE THROUGH?
	JRST ONC1		;NO, GET ANOTHER
	MOVEI C,0		;CLEAR C
	TLNN CS,1		;RELOCATABLE?
	MOVEI C,"'"		;YES
	TLNN CS,EXTF		;OR EXTERNAL
	MOVEI C,"*"		;YES
ONC2:	JUMPN C,OUTC		;OUTPUT IF EXTERN OR RELOCATABLE
   IFN FORMSW,< SOS FLDSIZ>	;DECREMENT FIELD SIZE
	RET			;EXIT

DNC:	IDIVI C,^D10
	HRLM CS,0(P)
	JUMPE C,.+2
	CALL DNC		;RECURSE IF NON-ZERO
	HLRZ C,0(P)
	ADDI C,"0"		;FORM ASCII
	JRST PRINT		;DUMP AND TEST FOR END

;OCTAL OUTPUT FROM C

OUTOCT:	IDIVI C,^D8
	HRLM CS,0(P)
	SKIPE C
	CALL OUTOCT		;RECURSE UNTIL QUOTIENT 0
	HLRZ C,0(P)
	ADDI C,"0"		;CONVERT TO ASCII
	JRST PRINT

OUTAS0:	HRLI CS,(POINT 7,,)	;ENTRY TO SET POINTER
OUTASC:	ILDB C,CS		;GET NEXT BYTE
	JUMPE C,POPOUT		;EXIT ON ZERO DELIMITER
	CALL PRINT
	JRST OUTASC

OUTSIX:	HRLI CS,(POINT 6,,)	;OUTPUT SIXBIT
	ILDB C,CS		;GET SIXBIT
	CAIN C,40		;"@" DELIMITER?
	RET			;YES, EXIT
	ADDI C,40		;NO, FORM ASCII
	CALL OUTL		;OUTPUT ASCII CHAR FROM C
	JRST OUTSIX+1

OUTSYM:	MOVE CS,AC0		;PLACE NAME IN CS
OUTSY1:	MOVEI C,0		;CLEAR C
	LSHC C,6		;MOVE NEXT SIXBIT CHARACTER IN
	JUMPE C,CPOPJ		;TEST FOR END
	ADDI C,40		;CONVERT TO ASCII
	CALL OUTL		;OUTPUT
	JRST OUTSY1		;LOOP


OUTSET:	AOS SX,0(P)		;GET RETURN LOCATION
	MOVE SX,-1(SX)		;GET XWD CODE
	HLRM SX,BLKTYP		;SET BLOCK TYPE
	SETZB ARG,RC
	CALL 0(SX)		;GO TO PRESCRIBED ROUTINE
	JRST COUTD		;TERMINATE BLOCK AND EXIT

	;LOOKUP SCANS ALL THE SYMBOLS IN THE SYMBOL TABLE

LOOKUP:	POP P,LOOKX		;INTERCEPT RETURN POP
	MOVE SX,SYMBOL
   IFE POLISH,<
	MOVE SDEL,0(SX)		;SET FOR TABLE SCAN
LOOKL:	SOJL SDEL,POPOUT	;TEST FOR END
   >
   IFN POLISH,<
	PUSH P,0(SX)		;SET FOR TABLE SCAN
LOOKL:	SOSGE 0(P)		;TEST FOR END
	JRST LOOKXT		;DONE, EXIT
   >
	ADDI SX,2
	MOVE AC0,-1(SX)
	CALL SRCH7		;LOAD REGISTERS
	HLRZS ARG
	CALL @LOOKX		;RETURN TO CALLING ROUTINE
	JRST LOOKL		;TRY AGAIN

   IFE POLISH,<SYN LOOKUP,SGLKUP>
   IFN POLISH,<
LOOKXT:	POP P,AC0		;THROW AWAY COUNTER
	RET
SGLKUP:	POP P,LOOKX		;INTERCEPT RETURN POP
	MOVE SX,SGNCUR		;GET CUR PSECT INX
	PUSH P,SGSCNT(SX)	;SAVE SYM CNT
	HRRZS 0(P)		;DON'T WANT LEFT HALF
	MOVE SX,SGSBOT		;GET INIT SYM TAB PTR
	JRST LOOKL		;REST IS SAME AS FOR FULL CASE
   >


SUBTTL END ROUTINES

END0:
   IFN POLISH,<
	HRROS SGNCUR		; FORCE EVALUATION IN ITS OWN PSECT
   >
	CALL EVALCM		;GET A WORD
   IFN POLISH,<
	HRRZS SGNCUR		; BACK TO NORMAL
   >
	SKIPN V,AC0		;NON-ZERO?
	JUMPE RC,.+2		;OR RELOC?
	CALL ASSIG7		;[521] YES, LIST THE VALUE
	SETZM VECSYM		; INCASE NOT SYMBOLIC
	SKIPN EXTPNT		; EXTERNAL?
	JRST END00		; NO
	CAME RC,EXTPNT		; MAKE SURE SAME
	JRST [SETZB AC0,VECSYM	; NO, CLEAR
		TRO ER,ERRE	; FLAG ERROR
		JRST .+3]	;
	MOVE RC,1(RC)		; GET SIXBIT NAME
	MOVEM RC,VECSYM		; STORE SYMBOL NAME
	SETZB RC,EXTPNT		; AND CLEAR RELOC
END00:	MOVEM AC0,VECTOR
	MOVEM RC,VECREL
   IFN POLISH,<
	MOVE AC1,SGWFND		; GET START ADR PSECT INX
	MOVEM AC1,VECFND	; SAVE IT
   >
	SKIPN LITNUM		;[475] LITERALS TO FOLLOW?
	CALL VARP		;[475] NO, DO EARLY CHECK FOR VAR AREA
	SETOM ENDSN		;[475] FLAG BEEN HERE AND
	CALL STOUTS		;DUMP THE LINE
END01:	SETZ MRP,		; SHOULDN'T BE IN A MACRO BY NOW
   IFN POLISH,<
	MOVE AC1,SGNMAX		; GET HIGHEST PSECT USED
	PUSH P,AC1		; SAVE IT
END02:	CAME AC1,SGNCUR		; IF NOT CURRENT
	CALL %SWSEG		; SWAP IT
   >
	SKIPE ENDSN		;[475] HAVE WE CHECKED VAR AREA
	SKIPE LITNUM		;[475] PHASE ERRORS?
	CALL VARP		;[475] NO, DO SO
	CALL VARA		;FILL OUT SELF-DEFINED VARIABLES
   IFE IIISW,<PUSH P,IO		;SAVE FLAGS
	TLO IO,IOPROG>		;XLIST LITS
	CALL LIT1		;RETURN VALUE IN AC2
   IFE IIISW,<POP P,IO>		;GET FLAG BACK
   IFN POLISH,<
	SOSL AC1,0(P)		; DONE YET?
	JRST END02		; NO
	POP P,AC1		; GET JUNK OFF STACK
   >
	JUMP2 ENDP2

	MOVE HHIGH		;GET HIGH SEG BREAK
	MOVEM HIGH1		;SAVE FOR TWOSEG/HISEG BLOCK TYPE 3
	CALL UOUT
	TLNN IO,MFLSW		;SKIP IF ONLY PSEND
	CALL REC2
	MOVE INDIR		;SET UP FIRST AS LAST
	MOVEM LSTFIL		;PRINTED
	SETZM LSTPGN
	CALL INZ1		;
	TLNE IO,MFLSW		;IF PSEND
	RET			;BACK TO PSEND0
	SKIPE PRGPTR		;HAVE ANY PRGEND'S BEEN SEEN
	CALL PSEND3		;YES,GO SET UP AGAIN

PASS20:	SETZM CTLSAV
	CALL COUTI
	CALL EOUT		;OUTPUT THE ENTRIES
	CALL OUTSET
	XWD 6,NOUT		;OUTPUT THE NAME (BLKTYP-6)
	SKIPN HISNSW		;PUT OUT BLOCK TYPE 3?
	JRST PASS21		;NO
	CALL OUTSET
	XWD 3,HSOUT		;OUTPUT THE HISEG BLOCK
PASS21:	MOVEI 1
	HRRM BLKTYP		;SET FOR TYPE 1 BLOCK
	TLZ FR,P1		;SET FOR PASS 2 AND TURN OFF FLAG
	TLO IO,IOPALL		;PUT THESE BACK
	TLZ IO,IOPROG!IOCREF!DEFCRS!IONCRF ; SO LISTINGS WILL BE THE WAY THEY SHOULD
	TLNN FR,R1BSW
	JRST STOWI
	MOVE CS,[XWD $ST-1-$CKSM,R1BLDR]
	MOVE C,0(CS)
	CALL PTPBIN
	AOBJN CS,.-2
	CALL R1BI
	JRST STOWI

ENDP2:	CALL COUTD		;DUMP THE BUFFER
	MOVE AC0,LOCO		;CHECK TO SEE IF LIT DIFFERED
	SKIPN MODO		;AND USE SMALLER SINCE AT END
	JRST [CAMN AC0,ABSHI
		HRRZM AC2,ABSHI
		JRST ENDP2W]
	SKIPE HHIGH		;SKIP IF NOT TWO SEGMENTS
	JRST [CAMN AC0,HHIGH
		HRRZM AC2,HHIGH
		JRST ENDP2W]
ENDP2W:				;[513]
   IFE POLISH,<
	CAMN AC0,HIGH		;[513]
	HRRZM AC2,HIGH		;[513]
   >
   IFN POLISH,<
	MOVE AC1,SGNCUR
	CAMN AC0,HIGH
	HRRM AC2,SGATTR(AC1)
   >
REPEAT 1,<TLNE IO,IOCREF>	;CLOSE CREF IF NECESSARY
REPEAT 0,<TLNE FR,CREFSW	;IF CREFFING
	JRST ENDP2Q
	MOVEI SDEL,0
	PUSH P,DBUF+3		;SO NO PAGE INFO
	DPB SDEL,[POINT 7,DBUF+3,13]
	IOR ER,OUTSW		;MAKE SURE OF OUTPUT
	CALL CREF
	MOVEI C,20		;CODE FOR TITLE
	CALL OUTLST
	PUSH P,IO		;SAVE THIS
	TLZ IO,IOPAGE		;AND PREVENT PAGE DURING TITLE
	MOVEI CS,TBUF
	CALL OUTAS0
	MOVEI CS,VBUF
	CALL OUTAS0
	POP P,IO		;RESTORE THE IO WORD
	POP P,DBUF+3>		;NEEDS FIX TO CREF
	CALL CLSCR2		;CLOSE IT UP
ENDP2Q:	HRR ER,OUTSW		;SET OUTPUT SWITCH
	SKIPN TYPERR
	TRO ER,TTYSW
	CALL UOUT		;OUTPUT UNDEFINEDS
	TRO ER,TTYSW
	OUTPUT CTL,		;CLEAR JUNK OUT OF BUFFER
	SKPINC C		;SEE IF WE CAN INPUT A CHAR.
	  JFCL			;BUT ONLY TO DEFEAT ^O
	SKIPG C,QERRS		;ANY Q ERRORS SEEN?
	JRST ENDPER		;NO, TRY REAL ERRORS
	CALL OUTCR		;NEW LINE
	MOVEI C,"%"		;WARNING CHARACTER
	CALL OUTL
	MOVE C,QERRS		;GET COUNT
	CAIN C,1		;1 IS SPECIAL
	JRST ONERQ
	CALL DNC		;OUTPUT IT
	SKIPA CS,[EXP ERRMQ2]
ONERQ:	MOVEI CS,ERRMQ1
	CALL OUTSIX
ENDPER:	MOVE C,ERRCNT		;[514] GET ERROR COUNT
	CAMGE C,UNDCNT		;[514] .GE. UNDEFINED SYMBOL COUNT?
	MOVE C,UNDCNT		;[514] USE UND SYMBOL COUNT INSTEAD
	JUMPE C,NOERW		;[514] ZERO COUNT, PRINT NO ERR MSG
   IFN CCLSW,<ADDM C,.JBERR>	;REMEMBER ERROR COUNT FOR EXECUTION DELETION
	PUSH P,C		;[514] STORE ERROR COUNT FOR A WHILE
	CALL OUTCR
	MOVEI C,"?"		;? FOR BATCH
	CALL OUTL		;...
	POP P,C			;[514] RESTORE ERROR COUNT FROM STACK
	CAIN C,1		;1 IS A SPECIAL CASE
	JRST  ONERW		;PRINT MESSAGE
	CALL DNC
	SKIPA CS,[EXP ERRMS1]	;LOAD TO PRINT
ONERW:	MOVEI CS,ERRMS2		;ONE ERROR DETECTED
ONERW1:	CALL OUTSIX		;PRINT
	JRST ENDP2A

NOERW:	SKIPE QERRS		;IF "Q" ERRORS
	CALL OUTCR		;CLOSE LINE NOW
	MOVEI CS,ERRMS3
   IFN CCLSW,<TLNE IO,CRPGSW!MFLSW> ;IF RPG, DON'T PRINT MESSAGE
   IFE CCLSW,<TLNE IO,MFLSW>	;NOR IF MULTI-FILE MODE
	TRZ ER,TTYSW		;NO TTY OUTPUT
	IOR ER,OUTSW		;UNLESS NEEDED FOR LISTING
	SKIPN QERRS		;ALREADY DONE
	CALL OUTCR
	JRST ONERW1

ENDP2A:	CALL OUTCR
	TLNN IO,MFLSW		;IN A MULTI-PROG FILE?
	JRST ENDP2D		;NO
	SKIPN QERRS		;ANY WARNINGS?
	SKIPE ERRCNT		;ANY ERROR?
	CALL [MOVEI CS,[ASCIZ /PROGRAM	/]
		CALL OUTAS0	;YES,SO PRINT MESSAGE
		MOVEI CS,TBUF	;AND TITLE
		CALL OUTAS0	;FOR IDENTIFICATION
		JRST OUTCR]	;AND A CR-LF
	TRZA ER,TTYSW		;NO MORE OUTPUT NOW
ENDP2D:
   IFN CCLSW,<TLNE IO,CRPGSW	;IF RPG, DON'T PRINT PGM BREAK
	TRZ ER,TTYSW>		;...
   IFE CCLSW,< SKIPA>		;SO PRGEND CODE CAN WORK
	IOR ER,OUTSW		;...
	CALL OUTCR
	MOVEI CS,[SIXBIT /HI-SEG. BREAK IS @/]
	SKIPN HHIGH		;DON'T PRINT IF ZERO
	JRST ENDP2C		;IT WAS
	CALL OUTSIX
	HRLO CS,HHIGH		;GET THE BREAK
	CALL ONC1
	CALL OUTCR
ENDP2C:	MOVEI CS,[SIXBIT /PROGRAM BREAK IS @/]
	CALL OUTSIX		;OUTPUT PROGRAM BREAK
	HRLO CS,SGATTR		;GET PROGRAM BREAK
	CALL ONC1
	CALL OUTCR
   IFN FTPSEC,<
	SKIPN AC1,SGNMAX	;GET PSECT CNT
	JRST ENDP2E		;PSECTS NOT USED?
	MOVEI AC2,1
ENDP2F:	MOVEI CS,[SIXBIT /PSECT   BREAK IS @/]
	CALL OUTSIX		;OUTPUT PSECT BREAK
	HRLO CS,SGATTR(AC2)	;GET PSECT BRK
	CALL ONC1
	MOVE CS,[SIXBIT / FOR  /]
	MOVEM CS,SGLIST
	MOVE CS,SGNAME(AC2)	;GET PSECT NAME
	MOVEM CS,SGLIST+1
	MOVSI CS,SIXBIT/   @  /
	MOVEM CS,SGLIST+2
	MOVEI CS,SGLIST
	CALL OUTSIX
	CALL OUTCR
	AOS AC2
	SOJG AC1,ENDP2F		;LOOP THRU PSECT.S
ENDP2E:>
	HRRZ CS,ABSHI		;GET ABS. BREAK
	CAIG CS,140		;ANY ABS. CODE
	JRST ENDP2B		;NO, SO DON'T PRINT
	MOVEI CS,[SIXBIT /ABSLUTE BREAK IS @/]
	CALL OUTSIX
	HRLO CS,ABSHI
	CALL ONC1
	CALL OUTCR
ENDP2B:	MOVEI CS,[SIXBIT /CPU TIME USED @/]
	CALL OUTSIX		; PRINT THE TIME IT TOOK TO ASSEMBLE
	SETZ C,			; SO AS TO GET THE RIGHT TIME
	RUNTIM C,		; GET THE TIME NOW
	SUB C,RTIME		; MINUS TIME WHEN STARTED
	IDIVI C,^D1000		; GET MS.
	PUSH P,C+1		; SAVE
	IDIVI C,^D60		; GET SEC. IN C+1, MIN. IN C
	PUSH P,C+1		; SAVE SECONDS
	IDIVI C,^D60		; GET HOURS IN C, MINS. IN C+1
	PUSH P,C+1		; SAVE MINS
	JUMPE C,NOHOUR		; SKIP IF LESS THAN 1 HOUR
	CALL DNC		; PRINT HOURS
	MOVEI C,":"		; SEPARATOR
	CALL OUTC		;
NOHOUR:	POP P,CS		; GET MINS
	CALL DECPT2		; PRINT THEM
	MOVEI C,":"		;
	CALL OUTC		;
	POP P,CS		; A LITTLE DIFFERENT FOR MS
	CALL DECPT2		; PRINT SECONDS
	MOVEI C,"."		; A POINT FOR MS.
	CALL OUTC		;
	POP P,CS		; GET MS.
	CALL DECPT3		; PRINT MS.
	CALL OUTCR		; AND A CRLF
	TLNE FR,RIMSW!R1BSW	;RIM MODE?
	CALL RIMFIN		;YES, FINISH IT
   IFN CCLSW,<TLNN IO,CRPGSW!MFLSW> ;IF NOT IN CCL MODE
   IFE CCLSW,<TLNN IO,MFLSW>	;NOR IF IN MULTI-FILE MODE
	TRO ER,TTYSW		;PRINT SIZE
	CALL OUTCR
	MOVE C,.JBREL
	LSH C,-^D10
	ADDI C,1
	CALL DNC
	MOVEI CS,[SIXBIT /K CORE USED@/]
	CALL OUTSIX
	CALL OUTCR
	HRR ER,OUTSW
	CALL OUTSET
	XWD 10,LSOUT		;OUTPUT THE LOCALS (..-10)
   IFN POLISH,<
	SETZM SGNCUR		;SET TO BLANK PSECT
	SKIPN SGNMAX		;WERE PSECTS USED?
	JRST ENDP2H		;NO
ENDP2G:	CALL SRCHI		;SET UP SRCHX,SGSBOT,SGSTOP
	CALL SGOUTL		;OUTPUT PSECT LENGTH BLOCK
ENDP2H:
   >
	CALL OUTSET
	XWD 2,SOUT		;OUTPUT THE SYMBOLS (BLKTYP-2)
   IFN POLISH,<
	AOS SX,SGNCUR		;INCR PSECT INX
	CAMG SX,SGNMAX		;LAST PSECT DONE?
	JRST ENDP2G		;NO, DO NEXT PSECT
	SETZM SGNCUR		;SET TO BLANK PSECT
	CALL OUTSET		;
	XWD 11,POUT		; OUTPUT THE POLISH (..-11)
	MOVSI SX,(POINT 2)	; RESET BYTE COUNT
	HLLM SX,COUTP		; AFTER END OF POLISH
   >
	CALL OUTSET
	XWD 7,VOUT		;OUTPUT TRANSFER VECTOR (..-7)
	CALL OUTSET
	XWD 5,HOUT		;OUTPUT HIGHEST RELOCATABLE (..-5)
	CALL COUTD
	TLNN IO,MFLSW		;IS IT PRGEND?
	JRST FINIS		;ALAS, FINISHED
	MOVEI CS,SBUF		;RESET SBUF POINTER
	HRRM CS,SUBTTX		;TO SUBTTL
	SETZM PASS2I		;CLEAR PASS2 VARIABLES
	MOVE [XWD PASS2I,PASS2I+1]
	PUSH P,PAGENO		;SAVE PAGE NUMBER IN CASE PRGEND
	PUSH P,PAGEN.		;[474] AND OFFSET
	BLT PASS2Z-1		;BUT NOT ALL OF VARIABLES
	POP P,PAGEN.		;[474]
	POP P,PAGENO		;RESTORE IT
;	JRST INZ		;RE-INITIALIZE FOR NEXT PROG
				; FALL THROUGH

SUBTTL PASS INITIALIZE

INZ:	SETZ C,			; GET CURRENT JOB NUMBER
	RUNTIM C,		; GET RUNTIME FOR LATER
	MOVEM C,RTIME		; SAVE
INZ1:	AOS MODA
	AOS MODO
   IFN POLISH,<
	MOVE AC1,SGNMAX
	MOVSI AC0,1
	MOVEM AC0,SGRELC(AC1)
	SOJGE AC1,.-1
	MOVE AC1,SGNMAX		; GET HIGHEST PSECT USED
	PUSH P,AC1		; SAVE IT
INZ2:	CAME AC1,SGNCUR		; IF NOT CURRENT
	CALL %SWSEG		; SWAP IT
   >
	MOVEI VARHD
	MOVEM VARHDX
	MOVEI LITHD
	MOVEM LITHDX
	CALL LITI
   IFN POLISH,<
	SOSL AC1,0(P)		; DONE YET?
	JRST INZ2		; NO
	POP P,AC1		; GET JUNK OFF STACK
   >
	SETZM SEQNO
	HRRI RX,^D8
	CALL STOWI
   IFN FORMSW,<
	HRRES HWFMT>		;SET DEFAULT VALUE BACK
	JRST OUTLI

; ROUTINE TO PRINT CPU TIME USED

DECPT3:	MOVEI C,"0"		; FILL WITH ZERO
	CAIG CS,^D99		; 3 DIGITS?
	CALL OUTC		; NO
DECPT2:	MOVEI C,"0"		; FILL WITH ZERO
	CAIG CS,^D9		; 2 DIGITS?
	CALL OUTC		; NO
	MOVE C,CS		; GET VALUE
	PJRST DNC		; OUTPUT IN DECIMAL AND RETURN

RIMFIN:	TLNE FR,R1BSW
	CALL R1BDMP
	SKIPN C,VECTOR
	MOVSI C,(JRST 4,)
	TLNN C,777000
	TLO C,(JRST)
	CALL PTPBIN
	MOVEI C,0
	JRST PTPBIN

SUBTTL PSEUDO-OP HANDLERS

TAPE0:	CALL STOUTS		;FINISH THIS LINE
	SETZM EOFFLG		;[417] CLEAR END OF FILE FLAG
	CALL PEEK		; LOOK AT NEXT CHARACTER
	CAIE C,VT		; PRINT IF V TAB
	CAIN C,FF		; OR FORM FEED
	CALL STOUTS		;
	SKIPE EOFFLG		;[442] EOF SEEN DURING PEEKING?
	RET			;[442] YES
	TLZ IO,IORPTC		;[442] NO, CLEAR CHARACTER FROM LOOK-AHEAD
	CALL OUTLI2		;[442] AND FROM LINE BUFFER
	JRST GOTEND		;[442] IGNORE THE REST OF THIS FILE

%NOBIN:	TLZE FR,PNCHSW		;IS REL FILE OPEN?
	CLOSE BIN,40		;YES, GET RID OF IT
	RET

RADIX0:	CALL EVAL10		;EVALUATE RADIX D10
	CAIG AC0,^D10		;IF GREATER THAN 10
	CAIG AC0,1		;OR LESS THAN 2,
ERRAX:	TROA ER,ERRA		;FLAG ERROR AND SKIP
	HRR RX,AC0		;SET NEW RADIX
	RET


XALL0:	JUMP1 POPOUT		;IGNORE ON PASS 1
	TLZN IO,IOSALL		;TURN OFF MACRO SUPPRESS ALL
	JRST IOSET		;NOT SALL ON SO NOTHING TO WORRY ABOUT
	CAIE C,EOL		;END OF LINE SEEN?
	JRST XALL1		;NO
	LDB C,LBUFP		;GET LAST CHARACTER
	CAIN C,CR		;UNDER SPECIAL CIRCUMSTANCES IT GETS REMOVED
	JRST XALL1		; NO, ALL IS WELL
	SOSG CPL		;ANY ROOM?
	CALL RSW5		; NO, SEE IF ANY EXCESS IN IT
	MOVEI C,CR		;NOW FOR TERMINAYOR
	IDPB C,LBUFP		;WILL GET REMOVED LATER
XALL1:	CALL IOSET		; FINISH OFF LINE
	TRNN SX,IOPALL		; WAS IT XALL OR XLIST?
	TLO IO,IOSALL		; IT WAS XLIST
	RET			;

IOSET:	JUMP1 POPOUT		;NOSYM (IONSYM), XALL (IOPALL), XLIST (IOPROG)
	PUSH P,AC0		;[467] STORE FLAGS
	CALL STOUTS		;POLISH OFF LINE
	POP P,SX		;[467] PUT FLAGS IN RH OF SX
	HLRZS SX		;[467]
	TLO IO,0(SX)		;NOW SUPRESS PRINTING
	RET

IORSET:	TDZ IO,AC0		;RESET  FLAG IOPALL/IOPROG
	RET

IOLSET:	JUMP1 POPOUT		;[327] SPECIAL FOR LALL, TO SEE IF IN MACRO UNDER SALL
	TLNE IO,IOSALL		;[327] SEE IF SALL
	JUMPN MRP,IOLSE1	;[327] AND IN MACRO
	TDZ IO,AC0		;[327] NO, CHANGE TO LALL
	RET			;[327] AND RETURN

IOLSE1:	CALL STOUTS		;[327] LALL UNDER MACRO, CLEAR REST OF LINE
	TLZ IO,IOSALL!IOPALL	;[327] ***** SET TO LALL
	CALL OUTIM		;[327] FORCE A CRLF
	RET			;[327] AND RETURN

BLOCK0:	CALL HIGHQ
	CALL EVALEX		;EVALUATE
	TLNE AC0,-1		; SEE IF VALID ARG TYPE
	JRST ERRAX		; NO, GIVE ERROR
	TRZE RC,-1		;EXTERNAL OR RELOCATABLE?
	CALL QEXT		;YES, DETERMINE TYPE
	ADDM AC0,LOCO		;UPDATE ASSEMBLY LOCATION
BLOCK1:	EXCH AC0,LOCA		;SAVE START OF BLOCK
	ADDM AC0,LOCA		;UPDATE OUTPUT LOCATION
BLOCK2:	HRLOM AC0,LOCBLK
	JUMP2 POPOUT
	TRNE ER,ERRU
	TRO ER,ERRV
	RET

PRNTX0:	TRO ER,TTYSW		;SET OUTPUT TO TTY
	JUMP2 PRNTX2		;PASS1?
	TDO ER,OUTSW		;YES,OUTPUT TO LSTDEV ALSO
PRNTX2:	BYPASS			;GET FIRST CHAR.
	TLOA IO,IORPTC		;REPEAT IT AND SKIP
PRNTX4:	CALL PRINT		;PRINT THE CHAR.
	CALL CHARAC		;GET ASCII CHAR.
	CAIG C,CR		;IF GREATER THAN CR
	CAIG C,HT		;OR LESS THAN LF
	JRST PRNTX4		;THEN CONTINUE
	CALL OUTCR		;OUTPUT A CRLF
	TRZA ER,TTYSW!LPTSW	;TURN OF OUTPUT
CPOPJ1:	AOS (P)			;USEFUL TAG HAS TO GO SOMEWHERE
CPOPJ:	RET			;EXIT

REMAR0:	CALL GETCHR		;GET A CHARACTER
REMAR1:	CAIE C,EOL
	JRST REMAR0
	RET			;EXIT

PAGE0:	CALL STOUTS		; PAGE PSEUDO-OP

PAGE1:	TLNE IO,IOCREF		; CURRENTLY DOING CREF?
	TLNE IO,IOPROG		; AND NOT XLISTED?
	JRST PAGE2		; NO
	HRR ER,OUTSW		;
	CALL CLSCRF		;
	CALL OUTCR
	HRRI ER,0		;
PAGE2:	TLO IO,IOPAGE		;
	RET			;

LIT0:	CALL BLOCK1
	CALL STOUTS
LIT1:	JUMP2 LIT20

;ON PASS ONE, WE JUST STEP THE LOCATION COUNTER AND CLEAR

	MOVE AC0,LITCNT
	MOVE SX,LITHDX
	HRLM AC0,0(SX)
	MOVE V,LOCA
	HRL V,MODA
	MOVEM V,-1(SX)
	JRST LIT24

LIT20:	PUSH P,LOCA
	PUSH P,LOCO
	SKIPN LITNUM
	JRST LIT20A
	MOVE SX,LITHDX
	HRRZ AC0,-1(SX)
	CAME AC0,LOCA
	TRO ER,ERRP
LIT20A:	MOVE SX,LITAB
LIT21:	SOSGE LITNUM
	JRST LIT22
   IFN FORMSW,<
	MOVE AC0,-3(SX)
	MOVEM AC0,FORM
   >
	MOVE AC0,-2(SX)		;WFW
	MOVE RC,-1(SX)		;WFW
   IFN POLISH,<
	CAMN RC,[1B0]		;[305] SPECIAL FAKE RELOC?
	SETZ RC,		;[305] YES
   >
	MOVE  SX,(SX)		;WFW POINTER TO THE NEXT LIT
	CALL STOW20		;STOW CODE
	MOVEI C,12		;SET LINE FEED
	IDPB C,LBUFP
	CALL OUTLIN		;OUTPUT THE LINE
	JRST LIT21


LIT22:	HRRZ AC2,LOCO
	POP P,LOCO
	POP P,LOCA
	MOVE SX,LITHDX
	HLRZ AC0,0(SX)
	SUB AC2,LOCO		;COMPUTE LENGTH USED
	CAMGE AC0,AC2		;USE LARGER
	MOVE  AC0,AC2
	ADD AC2,LOCO
LIT24:	ADDM AC0,LOCA
	ADDM AC0,LOCO
	CALL GETTOP
	HRRM SX,LITHDX
LITI:	SETZM LITCNT
	SETZM LITNUM
	MOVEI LITAB
	MOVEM LITABX
	JRST HIGHQ

GETTOP:	HRRZ AC1,SX		;VARHD
	HRRZ SX,0(SX)
	JUMPN SX,POPOUT
   IFE FORMSW,< MOVEI SX,3>	;WFW
   IFN FORMSW,< MOVEI SX,4>	;ICC
	ADDB SX,FREE
	CAML SX,SYMBOL
	CALL XCEED
	SUBI SX,1		;MAKE SX POINT TO LINK
	SETZM 0(SX)		;CLEAR FORWARD LINK
	HRRM SX,0(AC1)		;STORE ADDRESS IN LAST LINK
	RET


VAR0:	CALL BLOCK1		;PRINT LOCATION
	CALL VARP		;[475] CHECK VAR AREA FOR PHASE ERROR
	CALL VARA
	JRST STOUTS
VARP:	JUMP1 POPOUT		;[475] DO NOT CHECK START ON PASS1
	SKIPN VARCNT		;[515] ANY VARIABLE?
	RET			;[515] NO, RETURN
	MOVE SX,VARHDX		;[475]
	MOVE AC0,LOCA		;[475] GET LOCATION FOR CHECK
	CAMN AC0,-1(SX)		;[505] SAME START FOR BOTH PASSES?
	RET			;[505] YES,
	CAML AC0,-1(SX)		;[505] NO,BIGGER IN PASS2
	JRST [	TRO ER,ERRP	;[505] GIVE P ERROR
		RET]
	HLRZ AC0,0(SX)		;[505] SMALLER ON PASS2
	JUMPE AC0,POPOUT	;[505] RETURN IF NO VAR
	MOVE AC0,-1(SX)		;[505] OTHERWISE, ADJUST  LOCA & LOCO
	MOVEM AC0,LOCA		;[505] TO PASS1 VALUES
	MOVEM AC0,LOCO		;[505]
	RET			;[505] AND RETURN

VARA:	MOVE SX,VARHDX
	MOVE AC0,LOCA		;GET LOCATION FOR CHECK
	MOVEM AC0,-1(SX)	;SAVE START FOR PASS 2
	HLRZ AC0,0(SX)
	ADDM AC0,LOCA
	ADDM AC0,LOCO
	CALL GETTOP
	HRRM SX,VARHDX
	JUMP2 POPOUT

	SETZM VARCNT		;[515] CLEAR VARIABLE COUNTER
	CALL LOOKUP		;SET FOR TABLE SCAN
	TRNN ARG,VARF		;[542] GOT A VARIABLE?
	RET			;NO, EXIT
	TRC ARG,SIXF		;[542] MAKE SURE VARF IS NOT PART OF SIXF
	TRCN ARG,SIXF		;[542]
	RET			;[542] IT'S SIXF, SO IGNORE THIS ONE
	AOS VARCNT		;[515] INCREMENT VARIABLE COUNTER
	TRZ ARG,UNDF+VARF	;[542] TURN OFF FLAGS NOW
	MOVSI AC0,1(V)		;NUMBER TO ADD TO
	ADDM AC0,0(AC1)		;UPDATE COUNT
VARA1:	ADDI V,1		;GET LENGTH OF DESIRED BLOCK
	ADDM V,LOCO
	EXCH V,LOCA
	ADDM V,LOCA
	HRL ARG,V		;GET STARTING LOCATION AND UPDAT PCS

	IOR ARG,MODA		;SET TO ASSEMBLY MODE
	MOVSM ARG,0(SX)		;UPDATE 2ND WRD OF SYM TAB ENTRY
	JRST HIGHQ1


IF:	PUSH P,AC0		;SAVE AC0
	PUSH P,IO
	CALL EVALXQ		;EVALUATE AND TEST EXTERNAL
	POP P,AC1
	IORI ER,(AC1)		; RESTORE PREVIOUS ERROR FLAGS
	JUMPL AC1,IFPOP
	TLZ IO,FLDSW
IFPOP:	POP P,AC1		;RETRIEVE SKIP INSTRUCTION
IFSET:	TLO IO,IORPTC		;REPEAT CHARACTER
;IFXCT:	XCT AC1			;EXECUTE INSTRUCTION
IFXCT:	JRST IFHACK		;[463] GO TO IFHACK CODE
IFXF:	TDZA AC0,AC0		;FALSE
IFXT:	MOVEI AC0,1		;TRUE
IFEXIT:	SETZM EXTPNT		;JUST IN CASE
   IFN POLISH,<
	TLZ IO,RSASSW		; ...
   >
	JUMPOC IFDO		; BRANCH IF IN OP-CODE FIELD
IFEX1:	CALL GETCHR		;SEARCH FOR "<"
	CAIN C,EOL		;ERROR IF END OF LINE
	JRST ERRAX
	CAIE C,'<'
	JRST IFEX1
	JUMPE AC0,IFEX2		;TEST FOR 0
	TLO IO,IORPTC		;NO, PROCESS AS CELL
	CALL CELL
   IFN FORMSW,<MOVE AC1,HWFORM>	;USE STANDARD FORM
	SETZM INCND		;NOT ANY MORE
	JRST STOW		;STOW CODE AND EXIT

IFDO:	BYPASS			; GET NEXT NON-3LANK
	CAIN C,EOL		; AT EOL?
	JRST  REPEA1		; YES, USE OLD METHOD
	CAIE C,','		; ARE WE AT THE COMMA?
	CAIN C,'<'		; OR START OF CONDITIONAL?
	CAIA			; YES
	JRST IFDO		; NOT YET AT COMMA OR ANGLE BRKT
	CAIN C,','		; IGNORE THE COMMA
	CALL BYPAS1		; AND GET SOMETHING ELSE
	TLO IO,IORPTC		; REPEAT LAST CHAR.
	CAIE C,'<'		; OLD METHOD USED ANGLES
	CAIN C,EOL		; ALSO OLD IF NEW LINE SEEN
	JRST REPEA1		; ASSEMBLE CODE BETWEEN ANGLES
	JUMPLE AC0,REMAR0	; FALSE, TREAT AS COMMENT
	JRST STMNT		; TRUE, ASSEMBLE IT

IFPASS:	HRRI AC0,P1		;MAKE IT TLNX IO,P1
	MOVE AC1,AC0		;PLACE IT IN AC1
	JRST IFSET		;EXECUTE INSTRUCTION

;THIS PATCH (IFHACK) IS ADDED SO THAT SCNMAC WILL ASSEMBLE WITH MACRO
;V52.  WHAT THIS PATCH DOES IS TO ALLOW:
;	1.	IFE A##		TO GIVE FALSE RETURN WITHOUT ERROR MSG, AND
;	2.	IFN A##		TO GIVE TRUE RETURN WITHOUT ERROR MSG
;ALL OTHER CASES OF
;		IFX A		WHERE A IS EXTERNAL IS NOT ALLOWED, AND
;				AN E-ERROR IS GENERATED.
;THIS PATCH SHOULD BE REMOVED WHEN SCNMAC'S MACROS GET CORRECTED
;TO USE .IF/.IFN A,EXTERNAL,<...>.  
IFHACK:	CAMN AC1,[SKIPE 0]	;[463] IS IT IFE?
	JRST IFHAC1		;[463] YES, GO CHECK FOR EXTERNAL
	CAMN AC1,[SKIPN 0]	;[463] IS IT IFN?
	JRST IFHAC1		;[463] YES, GO CHECK FOR EXTERNAL
	JRST IFHAC2		;[463] NO, SKIP EXTERNAL TEST
IFHAC1:	TRNN ER,ERRE		;[463] EXTERNAL?
	JRST IFHAC2		;[463] NO,
	TRZ ER,ERRE		;[463] YES, ALLOW IT
	SETO AC0,		;[463] PUT -1 IN AC0 FOR DESIRED T/F VALUE
IFHAC2:	XCT AC1			;[463]
	JRST IFXF		;[463] FALSE
	JRST IFXT		;[463] TRUE

IFB0:	HLLO AC1,AC0		;FORM AND STORE TEST INSTRUCTION
IFB1:	CALL CHARL		;GET FIRST NON-BLANK
	CAIE C," "
	CAIN C,HT
	JRST IFB1		;SKIP BLANKS AND TABS
	CAIG C,CR		;CHECK FOR CARRET AS DELIM.
	CAIGE C,LF
	CAIA
	JRST ERRAX
	FORERR (SX,CND)
	SETOM INCND		;SAVE INFO. FOR PASS 1 ERRORS
	CAIN C,"<"		;LEFT BRACKET?
	SETZB C,RC		;YES, PREPARE FOR OLD FORMAT
	SKIPA SX,C		;SAVE FOR COMPARISON
IFB3:	TRO AC0,1		;SET FLAG
IFB2:	CALL CHARL		;GET ASCII CHARACTER AND LIST
	CAMN C,SX		;TEST FOR DELIMITER
	JRST IFXCT		;FOUND
	CAIE C," "		;BLANK?
	CAIN C,HT		;OR TAB?
	JRST IFB2		;YES
	JUMPN SX,IFB3		;JUMP IF NEW FORMAT
	CAIN C,"<"		;<?
	AOJA RC,IFB2		;YES, INCREMENT COUNT
	CAIN C,">"		;>?
	SOJL RC,IFXCT		;YES, DECREMENT AND EXIT IF DONE
	JRST IFB3		;GET NEXT CHARACTER

IFDEF0:	HRRI AC0,UNDF		;MAKE IT TLNX ARG,UNDF
	PUSH P,AC0		;STACK IT
   IFN POLISH,<
	HRROS SGNCUR		;[302] DON'T COPY IF FOUND
   >
	CALL GETSYM		;TAKES SKIP RETURN IF SYM NAME IS LEGAL
	  TROA ER,ERRA		;ILLEGAL!
	CALL SEARCH
	  JRST [CALL OPTSCH
		TLO ARG,UNDF
		JRST IFDEF1]
IFDEF1:	JUMPG ARG,[CAME AC0,-3(SX) ;[500] JUMP IF WE HAVE OPDEF, ALSO SYMBOL?
		JRST IFDEF2	;[500] NO, PROCEED
		SUBI SX,2	;[500] YES, POINT TO IT
		CALL SRCH5	;[500] RESET REGISTERS
		JRST IFDEF2]	;[500]
IFDEF2:				;[500]
   IFN POLISH,<
	HRRZS SGNCUR		;[302] CLEAR FLAG
   >
	CALL SSRCH3		;EMIT TO CREF ANYWAY
	JRST IFPOP		;POP AND EXECUTE INSTRUCTION



IFIDN0:	HLRZS AC0
	MOVEI V,2*.IFBLK-1
	SETZM IFBLK(V)		;CLEAR COMPARISON BLOCK
	SOJGE V,.-1
	SETZM .TEMP		;CLEAR STORED DELIMETER
	MOVEI RC,IFBLK		;SET FOR FIRST BLOCK
	CALL IFCL		;GET FIRST STRING
	MOVEI RC,IFBLKA
	CALL IFCL		;GET SECOND STRING
	MOVEI V,.IFBLK-1
	MOVE SX,IFBLK(V)	;GET WORD FROM FIRST STRING
	CAMN SX,IFBLKA(V)	;COMPARE WITH SECOND STRING
	SOJGE V,.-2		;EQUAL, TRY NEXT WORD
	JUMPL V,IFEXIT		;DID WE FINISH STRING
	XORI AC0,1		;NO, TOGGLE REQUEST
	JRST IFEXIT		;DO NOT TURN ON IORPTC WFW

IFCL:	CALL CHARAC		;GET AND LIST CHARACTER
	CAIE C," "		;SKIP SPACES
	CAIG C,CR		;ALSO SKIP CR-LF
	CAIGE C,HT		;AND TAB
	JRST .+2		;NOT ONE OF THEM
	JRST IFCL		;SO LONG COMPARISONS WILL WORK
;*** A CROCK SO THAT IFIDN <X>,<X>,<INST.> WILL WORK ***
	CAIE C,","		;IS IT A COMMA?
	JRST .+3		;NO
	SKIPN .TEMP		;YES, WAS PREVIOUS FIELD OLD METHOD?
	JRST IFCL		;YES, IGNORE COMMA AND SPACES
;	***
	CAIN C,"<"		;WAS IT LEFT BRACKET?
	SETO C,			;SIGNAL OLD METHOD, LOOK FOR RIGHT BRACKET
	MOVEM C,.TEMP		;STORE TERMINATOR FOR COMPARISON
	MOVEI SX,5*.IFBLK-1	;LIMIT SEARCH
	HRLI RC,(POINT 7,,)	;SET UP BYTE IN RC
IFCLR:	CALL CHARAC
	SKIPLE .TEMP		;NEW METHOD?
	JRST IFCLR1		;YES, IGNORE ANGLE BRACKET COUNTING
	CAIN C,"<"		;ANOTHER LEFT ANGLE?
	SOS .TEMP		;YES, KEEP COUNT
	CAIN C,">"		;CLOSING ANGLE
	AOSGE .TEMP		;MATCHING COUNT?
IFCLR1:	CAMN C,.TEMP		;TEST FOR DELIMITER
	RET			;EXIT ON RIGHT DELIMITER
	SOJG SX,.+2		;ANY ROOM IN COMPARISON BLOCK?
	TROA ER,ERRA		;NO, FLAG ERROR BUT KEEP ON GOING
	IDPB C,RC		;DEPOSIT BYTE
	JRST IFCLR

IFEX2:	CALL GETCHR
	CAIN C,EOL		;EXIT WITH ERROR IF END OF LINE
	JRST ERRAX
	CAIN C,34		;"<"?
	AOJA AC0,IFEX2		;YES, INCREMENT COUNT
	CAIE C,36		;">"?
	JRST IFEX2		;NO, TRY AGAIN
	SOJGE AC0,IFEX2		;YES, TEST FOR MATCH
	BYPASS			;YES, MOVE TO NEXT DELIMITER
	SETZM INCND		;OUT OF CONDITIONAL NOW
	AOJA AC0,STOWZ1		;STOW ZERO


INTER0:	HLLZM AC0,INTENT	;AC0 CONTAINS INTF/ENTF FLAGS

INTER1:	CALL GETSYM		;GET A SYMBOL
	JRST INTER3		;INVALID, SKIP
	CALL SSRCH		;SEARCH THE TABLE
	 JRST [	CALL MSRCH	;[435] NOT SYMBOL, SEE IF OPDEF
		 SKIPA		;[435] NO
		TLNN ARG,OPDF	;[435] OPDEF?
		MOVSI ARG,SYMF!UNDF ;[435]
		TLO ARG,INTF	;[435]
		JRST .+1]	;[435]
	CALL SUPSYM		; SEE IF "!" SEEN
	TLNN ARG,UNDF		;ALLOW FORWARD REFERENCE
	TLNN ARG,SYNF!EXTF
	TDOA ARG,INTENT		;SET APPROPRIATE FLAGS
INTER3:	TROA ER,ERRA		;FLAG ARG EROR AND SKIP
	CALL INSERQ		;INSERT/UPDATE
	JUMPCM INTER1
	SETZM EXTPNT		;JUST IN CASE, SO AS NOT TO CONFUSE WORLD
   IFN POLISH,<
	TLZ IO,RSASSW		; ...
   >
	RET			;NO, EXIT


;.IF/.IFN SYMBOL ATTRIBUTE

NUMF==1B18			;LOCAL FLAG - ATOM IS A NUMBER
OPCF==1B19			;LOCAL FLAG - ATOM IS AN OPCODE

%IF:	TDZA AC0,AC0		;[310] .IF = 0
%IFN:	MOVEI AC0,1		;[310] .IFN = 1
	PUSH P,AC0		;[310] STORE WHICH
	PUSH P,IO		;[312] SAVE CURRENT FLAGS
	TRZ ER,ERRORS		;[312] RESET ERROR FLAGS
	CALL ATOM		;[312] GET THE ATOM TO BE TESTED
	MOVE AC1,IO		;[312] GET FLAGS FOR THE ATOM
	POP P,IO		;[312] RESTORE PREVIOUS FLAGS
	JUMPNC IFERRA		;[312] MAKE SURE TERMINATOR WAS A COMMA
	TLNE AC1,NUMSW		;[312] WAS IT A NUMBER?
	JRST [TRNE AC1,ERRORS;[312] MAYBE, ERRORS IN ATOM?
		SKIPA ARG,[UNDF,,0] ;[312] YES, SAY UNDEFINED
		MOVEI ARG,NUMF	;[312] A NUMBER IS NOTHING ELSE
		JRST %IF1]	;[312] GO GET TYPE WITHOUT SEARCH
	CALL SEARCH		; GENERAL SEARCH
	  JRST [CALL OPTSCH;[312] NOT SYMBOL, SEE IF OPCODE
		 SKIPA ARG,[UNDF,,0] ;[312] NOT OPCODE, ATOM UNDEFINED
		MOVE ARG,[SYMF,,OPCF];[312] OPCODE, IS ALSO SYMBOL
		JRST %IF1]	;[312] GO GET TYPE AND TEST
	JUMPL ARG,IFS1		;[510] JUMP IF HAVE SYMBOL DEFINITION
	CAME AC0,-3(SX)		;[510] HAVE OPDEF, SYMBOL ALSO PRESENT?
	JRST IFS2		;[510] NO
	SUBI SX,2		;[510] YES, POINT TO IT
	CALL SRCH5		;[510] RESET REGISTERS
IFS1:	CAMN AC0,1(SX)		;[510] HAVE SYMBOL, OPDEF ALSO PRESENT?
	IOR ARG,2(SX)		;[510] YES, MERGE FLAGS
IFS2:	HRRI ARG,0		;[312] NO RH LOCAL FLAGS IF SYMBOL
%IF1:	CALL GETSYM		; GET ATTRIBUTE
	  JRST IFERRA		;[310] MUST BE A SYMBOL
	SKIPE C			;[312] TERMINATE WITH SPACE OR COMMA
	JUMPNC IFERRA		;[312]
	CALL %IFSTM		;[312] SETUP MASK
	MOVSI AC2,-IFLEN	; AOBJN PTR
	PUSH P,[0]		;[453] END OF INDEX TO BE STORED 
IFLOOP:	MOVE SDEL,IFATAB(AC2)	; GET NAME
	ANDCM SDEL,AC1		; MASK
	CAMN AC0,SDEL		; MATCH
	JRST IFOUND		; GOT IT
IFLOP1:	AOBJN AC2,IFLOOP	; LOOP
	POP P,AC2		;[453] RECOVER INDEX
	JUMPE AC2,IFERRA	;[453] IT'S -1, NO INDEX, ERROR
	POP P,AC0		;[453] POP OFF -1
	POP P,AC0		;[453] GET WHICH
	JUMPN AC0,IFNTST	;[453] .IFN
	JRST IFTST		;[453] .IF

;SETUP MASK TO LOOK AT ONLY AS MANY LETTERS AS USER TYPED.   ALLOWS
;ATTRIBUTE TO BE UNIQUELY ABBREVIATED.

%IFSTM:	SETO AC1,		;[312] START WITH ALL
	TDNE AC0,AC1		;[312] STILL SEEING USERS CHARS?
	JRST [LSH AC1,-6	;[312] YES, SHIFT OUT ONE SIXBIT CHAR
		JRST .-1]	;[312] TRY AGAIN
	RET			;[312] MASK NOW IN AC1

;ANY DETECTED ERROR IN THIS PSEUDOOP GIVES "A" ERROR

IFERRA:	POP P,AC0		;[310] CLEAR STACK
	JRST ERRAX		;[310] ERROR "A"

IFOUND:	SKIPN 0(P)		;[453] FIRST FOUND?
	JRST [	PUSH P,AC2	;[453] YES, STORE INDES
		JRST IFLOP1]	;[453] GO BACK AND FINISH THE TABLE
	POP P,AC0		;[453] NO, NOT UNIQUE
	JUMPN	AC0,.-1		;[453] POP STUFF OFF TIL WE RID OF 0
	JRST IFERRA		;[453] AND ERROR

IFTST:	XCT IFJTAB(AC2)		; MAKE TEST
	  JRST IFXF		; FALSE
	JRST IFXT		; TRUE

IFNTST:	XCT IFJTAB(AC2)		; MAKE TEST
	  JRST IFXT		; TRUE
	JRST IFXF		; FALSE

DEFINE IFATRIB <
XX SYMBOL,<TLNN ARG,SYMF>
XX SYNONYM,<TLNN ARG,SYNF>
XX MACRO,<TLNN ARG,MACF>
XX OPDEF,<TLNN ARG,OPDF>
XX EXTERNAL,<TLNN ARG,EXTF!SPTR>
XX ENTRY,<TLNN ARG,ENTF>
XX INTERNAL,<TLNN ARG,INTF>
XX GLOBAL,<TLNN ARG,ENTF!EXTF!INTF!SPTR>
XX LOCAL
XX LABEL,<TLNN ARG,TAGF>
XX ASSIGNMENT
XX ABSOLUTE,<TLNE ARG,LELF!RELF!SYNF!MACF!EXTF!UNDF!SPTR>
XX RELOCATABLE,<TLNN ARG,LELF!RELF>
XX LRELOCATABLE,<TLNN ARG,LELF>
XX RRELOCATABLE,<TLNN ARG,RELF>
XX NUMERIC,<TRNN ARG,NUMF>
XX OPCODE,<TRNN ARG,OPCF>
   >

DEFINE XX (A,B)<
	<SIXBIT /A/>
   >
IFATAB:	IFATRIB
   IFLEN==.-IFATAB

DEFINE XX (A,B)<
 IFB <B>,<
	CALL %IF'A
   >
 IFNB <B>,<
	B
   >>
IFJTAB:	IFATRIB

%IFLOCAL:
	TLNN ARG,EXTF!SPTR!UNDF!MACF!SYNF
	TLNN ARG,SYMF		;[312] NOT EXTERNAL, BUT MUST BE SYMBOL
	RET
	JRST CPOPJ1

%IFASSIGNMENT:
	TLNE ARG,SYMF
	TLNE ARG,TAGF!UNDF!MACF!SYNF
	RET
	JRST CPOPJ1

;ASSIGN PSEUDO-OP
;ASSIGN SYM1,SYM2,INCR

ASGN:	CALL COUTD		;DUMP BUFFER
	PUSH P,BLKTYP		;SAVE BLOCK TYPE
	MOVEI AC0,100		;ASSIGN BLOCK TYPE
	MOVEM AC0,BLKTYP

	CALL GETSYM		;HERE TO ASGN6 COPIED FROM EXTERN
	JRST ASGN2
	TLO IO,DEFCRS		;FLAG AS DEFINITION
	CALL SSRCH
	JRST ASGN1
	TLNN ARG,EXTF!VARF!UNDF
	JRST ASGN2
	TLNE ARG,EXTF
	JRST [JUMP1 ASGN6
		TLZN ARG,UNDF
		JRST ASGN6
		ANDM ARG,(SX)
		JRST ASGN1]
ASGN1:	MOVEI V,2
	ADDB V,FREE
	CAML V,SYMBOL
	CALL XCEEDS
	SUBI V,2
	SETZB RC,0(V)
	MOVSI ARG,SYMF!EXTF
	CALL INSERT
	MOVSI ARG,PNTF
	IORM ARG,0(SX)
	MOVE AC0,-1(SX)
	MOVEM AC0,1(V)
ASGN6:	MOVE AC0,-1(SX)
	SETZ ARG,
	CALL SQOZE		;CONVERT TO SQUOZE
	CALL COUT		;OUTPUT FIRST SYMBOL
	JUMPNC ASGN2		;MUST BE COMMA HERE
	CALL GETSYM		;SECOND SYMBOL
	JRST ASGN2
	MOVEI SDEL,%SYM		;OUTPUT TO CREF
	CALL CREF
	SETZ ARG,
	CALL SQOZE		;CONVERT TO SQUOZE
	CALL COUT
	JUMPNC ASGN3		;COMMA?
	CALL EVALXQ		;YES, EVALUATE INCREMENT
ASGN4:	CALL COUT
	JUMP1 ASGN7		;DON'T OUTPUT IF PASS1
	CALL COUTD		;OUTPUT 3 WORDS
ASGN5:	POP P,BLKTYP		;RESTORE BLOCK TYPE
	RET

ASGN3:	MOVEI AC0,1		;INCREMENT IS 1 IF NOT SPECIFIED
	JRST ASGN4

ASGN2:	TRO ER,ERRE		;INDICATE
ASGN7:	CALL COUTI		;CLEAR OUTPUT BUFFER
	JRST ASGN5


EXTER0:	CALL GETSYM		;GET A SYMBOL
	  JRST EXTER4		;INVALID, ERROR
EXTER1:	TLO IO,DEFCRS		;FLAG THIS AS A DEFINITION
EXTER5:	CALL SSRCH		; OK, SEARCH SYMBOL TABLE
	  JRST EXTER2		;NOT THERE, INSERT IT
	TLNN ARG,EXTF!VARF!UNDF
	TROA ER,ERRE		;FLAG ERROR AND BYPASS
	TLNE ARG,EXTF		;VALID, ALREADY DEFINED?
	JRST [JUMP1 EXTER3	;YES, BYPASS
		TLZN ARG,UNDF	;SKIP IF UNDEFINED ALSO
		JRST EXTER3	;CONTINUE
		ANDM ARG,(SX)	;CLEAR UNDF ON PASS 2
		JRST EXTER2]	;SET UP EXTERNAL NOW
EXTER2:	MOVEI V,2		;NO, GET 2 CELLS FROM THE TREE
	ADDB V,FREE
	CAML V,SYMBOL		;HAVE WE RUN OUT OF CORE?
	CALL XCEEDS		;YES, TRY TO BORROW SOME MORE
	SUBI V,2		;GET RIGHT CELL FOR POINTER
	SETZB RC,0(V)		;ALL SET, ZERO VALUES
	MOVSI ARG,SYMF!EXTF
	CALL SUPSYM		; SEE IF "!" SEEN
	CALL INSERT		;INSERT/UPDATE IT
	MOVSI ARG,PNTF
	IORM ARG,0(SX)
	SKIPA ARG,-1(SX)	;GET THE SIXBIT FOR THE NAME
EXTER4:	TROA ER,ERRA		;FLAG AS ERROR
	MOVEM ARG,1(V)		;AND STORE IT FOR ADDITIVE GLOBAL FIXUPS
EXTER3:	CALL SUPSYM		; SEE IF "!" SEEN
   IFN POLISH,<			;[302] IF PSECT MUST SEARCH FOR ALL OCCURANCES
	SKIPN SGNMAX		;[302] ANY PSECTS?
	JRST EXTER9		;[302] NO
	PUSH P,SGNCUR		;[302] SAVE CURRENT PSECT
	SETZM SGNCUR		;[302] START WITH BLANK PSECT
EXTER6:	HRROS SGNCUR		;[302] DON'T COPY IF FOUND ELSE WHERE
	CALL SSRCH		;[302] LOOK FOR EXTERN
	  JRST EXTER8		;[302] FINISHED
	HRRZS SGNCUR		;[302] INDEX ONLY
	TLNE ARG,EXTF		;[302] ALREADY EXTERN?
	JRST [JUMP1 EXTER7	;[302] YES, BYPASS
		TLZN ARG,UNDF	;[302] UNDEF ALSO
		JRST EXTER7	;[302] NO
		ANDM ARG,(SX)	;[302] YES, CLEAR FLAG
		JRST .+1]	;[302] AND SETUP AS EXTERN
	MOVEI V,2		;NO, GET 2 CELLS FROM THE TREE
	ADDB V,FREE
	CAML V,SYMBOL		;HAVE WE RUN OUT OF CORE?
	CALL XCEEDS		;YES, TRY TO BORROW SOME MORE
	SUBI V,2		;GET RIGHT CELL FOR POINTER
	SETZB RC,0(V)		;ALL SET, ZERO VALUES
	MOVSI ARG,SYMF!EXTF
	CALL INSERT		;INSERT/UPDATE IT
	MOVSI ARG,PNTF
	IORM ARG,0(SX)
	MOVE ARG,-1(SX)		;GET THE SIXBIT FOR THE NAME
	MOVEM ARG,1(V)		;AND STORE IT FOR ADDITIVE GLOBAL FIXUPS
EXTER7:	AOS AC1,SGNCUR		;[302] NEXT PSECT
	CAMG AC1,SGNMAX		;[302] ALL DONE?
	JRST EXTER6		;[302] NO
EXTER8:	POP P,SGNCUR		;[302] BACK TO NORMAL
EXTER9:>			;[302] END IFN POLISH
	JUMPCM EXTER0
	RET			;NO, EXIT


EVAL10:	PUSH P,RX
	HRRI RX,^D10
	CALL EVALEX		;EVALUATE
	POP P,RX		;RESET RADIX
	JUMPE RC,POPOUT		;EXIT IF ABSOLUTE

QEXT:
   IFN POLISH,<
	TLNE FR,POLSW		; ANY POLISH EXTERNAL EXPRESSIONS
	JRST QPOL		; YES, REMOVE  AND FLAG ERROR
   >
	SKIPE EXTPNT		;ANY POSSIBILITIES?
	TROA ER,ERRE		;YES, FLAG EXTERNAL ERROR
	TRO ER,ERRR		;NO, FLAG RELOCATION ERROR
	HLLZS RC		;CLEAR RELOCATION/EXTERNAL
	RET

   IFN POLISH,<
QPOL:	TRO ER,ERRE		; FLAG EXTERNAL ERROR
	PUSH P,AC1		; GET AN AC
	SKIPE LITLVL		;[304] IN A LITERAL?
	SKIPA AC1,POLITS	;[304] YES, USE LAST LIT ITEM
	MOVE AC1,POLIST		; GET LAST ITEM IN LIST
	JUMPE AC1,QPOL1		;[503] IF ZERO, DON'T GO BACK
	MOVEM AC1,FREE		; RESET FREE CORE POINTER
	MOVE AC1,(AC1)		; GET PREVIOUS ITEM
	SKIPE LITLVL		;[304] IN A LITERAL?
	JRST [MOVEM AC1,POLITS	;[304] YES
		JRST .+2]	;[304]
	MOVEM AC1,POLIST	; MAKE IT TOP OF LIST
QPOL1:	POP P,AC1		;[503]
	RET			;
   >

EVALXQ:	PUSH P,IO		; SAVE ERROR STATUS
	TRZ ER,-1		; START AFRESH
	CALL EVALQ		; EVALUATE EXPRESSION
	TRNE ER,ERRU		; TEST FOR UNDEF
	TRO ER,ERRV		; FLAG "V" ERROR
	HLLM IO,(P)		; STORE STATUS FLAGS
	IORM ER,(P)		; COMPOUND ERRORS
	POP P,IO		; RESTORE THEM
	RET			;

EVALQ:	CALL EVALEX		;EVALUATE EXPRESSION
	TLNN FR,POLSW		;WAS POLISH FIXUP REQUIRED?
	TDZE RC,[-2,,-2]	;WAS AN EXTERNAL FOUND?
	TRO ER,ERRE		;YES, FLAG ERROR
	RET			;RETURN


OPDEF0:	CALL GETSYM		;GET THE FIRST SYMBOL
	  RET			;ERROR IF INVALID SYMBOL
	CAIE C,73		;"["?
	JRST ERRAX		;NO, ERROR
	PUSH P,AC0		;STACK MNEMONIC
	AOS LITLVL		;SHORT OUT LOCATION INCREMENT
	CALL STMNT		;EVALUATE STATEMENT
	SKIPGE STPX		;CODE STORED?
	TROA ER,ERRA		;NO,"A" ERROR
	CALL DSTOW		;GET AND DECODE VALUE
	SOS LITLVL
	EXCH AC0,0(P)		;EXCHANGE VALUE FOR MNEMONIC
	PUSH P,RC		;STACK RELOCATION
	TLO IO,DEFCRS		;SAY WE ARE DEFINING IT
	CALL MSRCH		;SEARCH SYMBOL TABLE
	  JRST [CALL SSRCH	;[435] SEARCH FOR INTERNAL SYMBOL	
		  JRST OPDEF1	;[435] NOT FOUND
		TLNN ARG,INTF	;[435] INTERNAL?
		JRST OPDEF1	;[435] NO,
		TLO ARG,OPDF	;[435] YES,
		TLZ ARG,UNDF	;[435]
		JRST OPDEF2]	;[435]
	SKIPA			;OPDEF ALREADY
OPDEF1:	MOVSI ARG,OPDF		;OPDEF
OPDEF2:	POP P,RC		;RESTORE VALUES
	POP P,V
	TLNE ARG,SYNF!MACF
	TRO ER,ERRA		;YES "A" ERROR
	TRNN ER,ERRA		;ERROR?
	CALL INSERT		;NO, INSERT/UPDATE
	CALL ASSIGL		; LIST VALUE LIKE =
	TLZ IO,DEFCRS		;JUST IN CASE
	BYPASS
	JRST STOWI		;BE SURE STOW IS RESET


DEPHA0:	SETZM PHALVL		;[456] NOT IN PHASE
	MOVE AC0,LOCO
	MOVE RC,MODO		;SET TO OUTPUT VALUES AND SKIP
	JRST PHASE1		;[456]
PHASE0:	SETOM PHALVL		;[456] IN PHASE
	CALL EVALXQ		;EVALUATE AND CHECK FOR EXTERNAL
PHASE1:	MOVEM AC0,LOCA		;SET ASSEMBLY LOCATION COUNTER
	MOVEM RC,MODA
	JRST BLOCK2


ASSIGN:	JUMPAD ERRAX		;NO, ERROR
	JUMPE AC0,ERRAX		;[540] NO SYMBOL ON THE LEFT OF=
	CALL ASSIG1
ASSIGL:	TLNE IO,IOSALL		;[521] SUPPRESS ALL?
	JUMPN MRP,CPOPJ		;IF IN MACRO
ASSIG7:	MOVEM RC,ASGBLK
	TRNE RC,-2		;EXTERNAL
	HLLZS ASGBLK		;YES,CLEAR RELOCATION
	TLNE RC,1		;LEFT HALF NOT RELOC?
	TLNE RC,-2		;...
	HRROS ASGBLK		;YES, SET FLAG
	MOVEM V,LOCBLK
	RET

ASSIG1:	PUSH P,AC0		;SAVE SYMBOL
   IFN POLISH,<
	MOVEM AC0,INASGN	;[305] INCASE POLISH FIXUP REQUIRED
   >
	SETZB AC0,EXTPNT	;SPECIAL CHECK FOR == WFW
ASSIG4:	CALL PEEK		;IS THE NEXT ON =
	CAIE C,"="
	CAIN C,"!"
	CAIA			;[406] WANT TO SUPRESS SYMBOL
	JRST ASSIG5		;[406] NOT "=" OR "!", SO SEE IF COLON
	TLOE AC0,NOOUTF		;[406] TURN ON "NO-OUTPUT" FLAG
	TRO ER,ERRQ		;[406] IF ALREADY ON, GIVE ERROR
	CALL GETCHR		;PROCESS THE CHAR.
	CALL PEEK		;CHECK FOR ==: DMN
ASSIG5:	CAIE C,":"		;IS IT
	JRST ASSIG6		;NO
	TLOE AC0,INTF		;[406] FLAG AS INTERNAL
	TRO ER,ERRQ		;[406] IF ALREADY ON, ITS AN ERROR
	CALL GETCHR		;REPEAT IT
	JRST ASSIG4		;TRY AGAIN (MIGHT BE =:!)

ASSIG6:	MOVEM AC0,HDAS		;STORE THESE BITS WFW
   IFN POLISH,<
	HRREI AC0,POLFWF	;[305] ASSUME FULL WORD FIXUP
	MOVEM AC0,POLTYP	;[305] UNLESS OTHERWISE SPECIFIED
   >
	CALL EVALCM		;EVALUATE EXPRESSION
	TDNN RC,[-2,,-2]	;[447] RC IS 0 OR 1?
	JRST ASSIG0		;[447] YES,
	CAIGE RC,100		;[447] NO, RC HAVING VALUES BETWEEN -100 AND
	CAMG RC,[-100]		;[447] 100 GETS R ERROR
	SKIPA			;[447] SINCE IT IS NOT PART OF A LARGER EXP
	TRO ER,ERRR		;[447] GIVE R ERROR
ASSIG0:	EXCH AC0,0(P)		;[447] SWAP VALUE FOR SYMBOL
	PUSH P,RC
   IFN POLISH,<
	JUMPL RC,ASSIG3		;[305] POLISH, BYPASS EXTERN TESTS
   >
	TRNN RC,-2		;CHECK EXTERNAL AGREEMENT
	JRST ASSIG2
	HRRZS RC
	HRRZ ARG,EXTPNT
	CAME RC,ARG
	CALL QEXT		;EXTERNAL OR RELOCATION ERROR
ASSIG2:	HLRZ RC,(P)
	TRNN RC,-2
	JRST ASSIG3
	HLRZ ARG,EXTPNT
	CAME RC,ARG
	CALL QEXT
ASSIG3:	TLO IO,DEFCRS
	PUSH P,UNISCH+1		;SAVE SEARCH LIST
	SETZM UNISCH+1		;BUT DISALLOW
	CALL SSRCH
	  MOVSI ARG,SYMF
	POP P,UNISCH+1		;RESTORE STATUS
	TLZ ARG,^-<SYMF!TAGF!NOOUTF!INTF!ENTF!NCRF!MDFF!SUPRBT> ;KEEP THESE
	IOR ARG,HDAS		;SET BITS DETERMINED ABOVE
	SETZM EXTPNT		;FOR REST OF WORLD
   IFN POLISH,<
	SETZM INASGN		;[305] FINISHED WITH POLISH BY NOW
	SETZM POLTYP		;[305]
	TLZ IO,RSASSW		; ...
   >
	POP P,RC
	TRNE ER,ERRORS-ERRQ
	SETZ RC,		;CLEAR RELOCATION
	POP P,V
	TRNE ER,ERRU		;WAS VALUE UNDEFINED?
	TLO ARG,UNDF		;YES,SO TURN UNDF ON
	TLNE ARG,TAGF
	JRST ERRAX
	JRST INSERT

;LOC, RELOC, AND ORG COME HERE

%ORG:	PUSH P,AC0		;SAVE TYPE
	CALL HIGHQ		;GET LATEST PC
	BYPASS			;SKIP BLANKS
	TLO IO,IORPTC		;REPEAT LAST
	CAIN C,EOL		;USE PREVIOUS VALUE IF NULL ARGUMENT
	JRST ORG03
	CALL EVALXQ		;GET EXPRESSION AND TEST EXTERNAL
	SKIPGE (P)		;ORG?
	HRLM RC,(P)		;YES, SAVE RELOC OF ARG
ORG01:	HRRM AC0,(P)		;STORE NEW VALUE
   IFE POLISH,<
	HLRZ AC1,(P)		;GET MODE
	HRRZ AC0,LOCO		;PC OF OUTPUT
	CAMN AC1,MODO		;MODE SAME?
	JRST [MOVEM AC0,@REL1P(AC1) ;SAVE NEW VALUE
		JRST ORG02]
	MOVEM AC0,@ABS1P(AC1)	;SAVE NEW VALUE
ORG02:	MOVE AC0,MODO		;SAVE OLD MODE
	MOVEM AC0,ORGMOD
   >
   IFN POLISH,<
	HRRZ AC0,LOCO		;PC OF OUTPUT
	MOVE AC1,MODO		;OLD MODE
	MOVEM AC0,@REL1P(AC1)	;SAVE OLD VALUE
	MOVE AC0,MODO		;SAVE OLD MODE
	MOVEM AC0,ORGMOD
	MOVE AC1,SGNCUR		;CURRENT PSECT INDEX
	MOVE AC0,HIGH		;SAVE PSECT BREAK
	HRRM AC0,SGATTR(AC1)
	HRR AC0,RELLOC		;SAVE PSECT REL PC
	HRL AC0,ORGMOD		;SAVE PSECT MODE
	MOVEM AC0,SGRELC(AC1)
   >
	POP P,AC0		;GET RESULT
ORG2A:	HLRZM AC0,MODA		;SET MODES
	HLRZM AC0,MODO
	HRRZM AC0,LOCA		;AND LOCATIONS
	HRRZM AC0,LOCO
	JRST BLOCK2

ORG03:	HRRZ AC0,ORGMOD		;GET PREV MODE
	SKIPGE (P)		;ORG?
	HRLM AC0,(P)		;YES, SAVE IT
	HLRZ AC1,(P)		;NEW MODE
	MOVE AC0,@REL1P(AC1)	;GET PREV VALUE
	JRST ORG01

REL1P:	EXP ABSLOC
ABS1P:	EXP RELLOC
	EXP ABSLOC

;	.PSECT NAME /ATTRIB,ORIGIN

   IFN POLISH,<
%SEGME:
   IFE FTPSEC,<			;ERROR IMMEDIATELY IF NOT ALLOWED
	JRST ERRSX>
   IFN FTPSEC,<
	SKIPN HISNSW		;CAN'T HAVE PSECTS WITH
	SKIPE UNIVSN		; HISEG, TWOSEG OR
	JRST ERRSX		; UNIVERSAL
	MOVE AC2,SGDMAX		;CHECK IF MAX PSECT
	CAILE AC2,SGNDEP-1	; NESTING DEPTH EXCEEDED
	JRST ERRSX		;YES
	CALL GETSYM		;GET PSECT NAME
	  CALL [SETZ AC0,	;NONE SPECIFIED, BLANK NAME
		TRZ ER,ERRA	;UNDO GETSYM'S ERR FLAG
		RET]
	MOVE AC1,SGNMAX		;GET PSECT COUNT
%SEGM1:	CAMN AC0,SGNAME(AC1)	;SEEN THIS NAME BEFORE?
	JRST %SEGM2		;YES
	SOJGE AC1,%SEGM1	;LOOP THRU KNOWN NAMES
	MOVE AC1,SGNMAX		;CHECK IF MAX DISTINCT PSECT
	CAILE AC1,SGNSGS-1	; LIMIT EXCEEDED
	JRST ERRSX		;YES
	AOS AC1,SGNMAX		;INCR PSECT COUNT
	MOVEM AC0,SGNAME(AC1)	;STORE PSECT NAME
	MOVSI AC2,1		;SET MODE TO RELOC
	MOVEM AC2,SGRELC(AC1)	; AND PC TO ZERO
	HRRZS SGORIG		;INCASE NOT GIVEN
%SEGM4:	MOVE SDEL,SYMBOL	;ROOM TO INIT
	SUBI SDEL,LENGTH	; SYM TAB
	CAMLE SDEL,FREE		; FOR NEW PSECT?
	JRST %SEGM3		;YES
	CALL XCEEDS		;TRY FOR MORE CORE
	JRST %SEGM4		;START OVER
%SEGM3:	MOVEM SDEL,SYMBOL	;NEW SYM TAB BOT
	HRLI SDEL,LENGTH(SDEL)	;OLD SYM TAB BOT
	MOVE SX,SYMTOP		;SYM TAB TOP
	BLT SDEL,-LENGTH(SX)	;MOVE SYM TAB DOWN
	HRLI SDEL,SYMNUM+1	;PTR TO PERM SYM TAB
	HRRI SDEL,1-LENGTH(SX)	;PERM SYMS GO HERE
	BLT SDEL,0(SX)		;MOVE PERM SYMS TO NEW PSECT
	MOVE AC2,SYMNUM		;PERM SYM CNT
	MOVEM AC2,SGSCNT(AC1)	;SET SYM CNT
	SETZM SGATTR(AC1)	;ZERO PSECT BRK AND ATTRS
	ADDM AC2,@SYMBOL	;ADJUST TOTAL SYM CNT
%SEGM2:	AOS AC2,SGDMAX		;INCR PSECT DEPTH
	MOVEM AC0,SGLIST(AC2)	;STORE PSECT NAME
%SEGM5:	CAIE C,'/'		;ATTRIBUTES SPECIFIED?
	JRST %SEGM9		;NO, TRY VALUE
	PUSH P,AC1		;SAVE PSECT INX
	CALL GETSYM		;GET ATTRIBUTE
	  JRST %SEGM8		;TOO BAD
; THE BELOW ATTRIBUTES ARE PAIRED; A CONFLICT IS
; FLAGGED IF BOTH OF ANY PAIR ARE SEEN (CUMMULATIVELY)
	MOVE AC1,AC0		;ATRIB NAME
	SETO AC2,		;MASK
	LSH AC1,6		;SHIFT UP 1 CHAR AT A TIME
	LSH AC2,6		;SAME FOR MASK
	JUMPN AC1,.-2		;UNTIL CHAR ALL GONE, MASK LEFT
	MOVSI AC1,-%SGTLN	;AOBJN WORD
%SEGM6:	CAMN AC0,%SGTBL(AC1)	;ATTRIBUTE FOUND?
	JRST %SEGM7		;YES, PROCESS IT
	XOR AC0,%SGTBL(AC1)	;BUT SEE IF WHAT WE HAVE MATCHES
	TDNN AC0,AC2		;TRUE IF MASKED BITS ARE 0
	JRST %SEGM7		;YES, IT MATCHES
	XOR AC0,%SGTBL(AC1)	;PUT NAME BACK
	AOBJN AC1,%SEGM6	;NO, CHECK NEXT
	SETZ AC2,		;CLEAR ATTR FLAG
	TRO ER,ERRQ		;FLAG WARNING
%SEGM7:	MOVEI AC2,1		;SET ATRIB BIT
	LSH AC2,-1(AC1)		; IN AC2
	MOVE AC1,0(P)		;GET PSECT INX
	HLRZ AC0,SGATTR(AC1)	;GET PREV ATTRS
	ANDI AC0,525252		;SELECT LEFT OPTIONS
	LSH AC0,-1		;SHIFT THEM RIGHT
	AND AC0,AC2		;COMPARE NEW AND PREVIOUS
	JUMPE AC0,.+3		;CONFLICTING ATTRIBUTE?
	TRO ER,ERRQ		;YES, FLAG WARNING
	SETZ AC2,		; AND IGNORE IT
	HLRZ AC0,SGATTR(AC1)	;GET PREV ATTRS
	ANDI AC0,252525		;SELECT RIGHT OPTIONS
	LSH AC0,1		;SHIFT THEM LEFT
	AND AC0,AC2		;COMPARE NEW AND PREVIOUS
	JUMPE AC0,.+3		;CONFLICTING ATTRIBUTE?
	TRO ER,ERRQ		;YES, FLAG WARNING
	SETZ AC2,		; AND IGNORE IT
	HRLZS AC2		;MOVE TO LEFT HALF
	IORM AC2,SGATTR(AC1)	;MERGE ATTRIBUTES
%SEGM8:	POP P,AC1		;RESTORE PSECT INX
	JUMPCM %SEGM5		;LOOP IF MORE ATTRS
	JRST %SWSEG		;SWAP PC AND MODE

%SEGM9:	JUMPNC %SWSEG		;NO VALUE
	PUSH P,AC1		;SAVE INDEX
	CALL EVALCM		;GET IT
	POP P,AC1		;RESTORE INDEX
	HRRM AC0,SGORIG(AC1)	;STORE IT
	JRST %SWSEG		;SWAP PC AND MODE

%SGTBL:	<SIXBIT /CONCATENATED/>
	<SIXBIT /OVERLAID/>
	<SIXBIT /RWRITE/>
	<SIXBIT /RONLY/>

%SGTLN==.-%SGTBL
   >				;END IFN FTPSEC

%ENDSE:
   IFE FTPSEC,<			;ERROR IMMEDIATELY IF NOT ALLOWED
	JRST ERRSX>
   IFN FTPSEC,<
	SKIPN HISNSW		;CAN'T HAVE PSECTS WITH
	SKIPE UNIVSN		; HISEG, TWOSEG OR
	JRST ERRSX		; UNIVERSAL
	MOVE AC2,SGDMAX		;IF DEPTH IS ALREADY ZERO
	JUMPE AC2,ERRSX		; THEN .ENDPS IS ILLEGAL
	CALL GETSYM		;GET PSECT NAME
	JRST %ENDS1		;NONE SPECIFIED, IGNORE CHECK
	CAME AC0,SGLIST(AC2)	;DOES IT MATCH CORRES .PSECT NAME
	TRO ER,ERRQ		;NO, FLAG WARN AND DO IT ANYWAY
%ENDS1:	TRZ ER,ERRA		;UNDO GETSYM'S ERR FLAG
	SOS AC2,SGDMAX		;DECR PSECT DEPTH
	MOVE AC0,SGLIST(AC2)	;NAME OF PSECT TO RESUME
	MOVE AC1,SGNMAX		;GET PSECT COUNT
	CAME AC0,SGNAME(AC1)	;NAME MATCH?
	SOJGE AC1,.-1		;NO, TRY NEXT
   >

;HERE TO SWAP TO NEW PSECT
;ENTER WITH OLD PSECR IN SGNCUR
;NEW PSECT IN AC1

%SWSEG:
   IFE FTPSEC,<
	HALT .>			;CAN'T HAPPEN
   IFN FTPSEC,<
	PUSH P,AC1		;SAVE NEW PSECT INX
	MOVE AC2,SGNCUR		;GET OLD PSECT INX
	HLRZ SDEL,SGORIG(AC2)	;ALREADY SETUP LIT/VAR BLOCK
	JUMPN SDEL,%SWSG1	;YES
	MOVEI SDEL,.SGLVL+1	;NO
	ADDB SDEL,FREE		;TRY TO GET IT
	CAML SDEL,SYMBOL	;WILL IT FIT?
	CALL XCEED		;NO, XPAND
	SUBI SDEL,.SGLVL+1	;GET ORIGIN
	HRLM SDEL,SGORIG(AC2)	;NOW STORE IT
%SWSG1:	MOVSI AC0,.SGLVZ	;START OF LIT/VAR AREA
	HRRI AC0,1(SDEL)	;SAVE AREA
	BLT AC0,.SGLVL(SDEL);STORE IT
	MOVE AC0,LITLVL		;GET LITLVL
	MOVEM AC0,(SDEL)	;STORE IT
	HLLZ AC0,SGORIG(AC1)	;RESTORE NEW LIT/VAR
	JUMPE AC0,[MOVE AC0,[.SGLVZ,,.SGLVZ+1] ;NOT YET SETUP
		SETZM .SGLVZ	;CLEAR FIRST WORD
		BLT AC0,.SGLVZ+.SGLVL ;PLUS REST
		MOVEI AC0,VARHD	;SET UP AREA
		MOVEM AC0,VARHDX
		MOVEI AC0,LITHD
		MOVEM AC0,LITHDX
		SETZM LITLVL
		CALL LITI
		JRST %SWSG2]	;JOIN COMMON CODE
	AOBJP AC0,.+1		;BYPASS FIRST WORD
	HRRI AC0,.SGLVZ		;TO LIT/VAR AREA
	BLT AC0,.SGLVZ+.SGLVL-1
	HLRZ SDEL,SGORIG(AC1)	;POINTER TO LIT INFO
	MOVE AC0,(SDEL)		;GET LITLVL
	MOVEM AC0,LITLVL	;WE ARE NOW IN
	CALL HIGHQ		;SET CURRENT PROG BRK
%SWSG2:	MOVE AC0,SGRELC(AC1)	;GET OLD MODE AND PC
	PUSH P,AC0		;SAVE SAME
	HLRZ RC,AC0		;GET OLD MODE
	SKIPN RC		;IF ABS MODE
	MOVE AC0,ABSLOC		; THEN GET ABS PC
	HRRM AC0,(P)		;STORE NEW VALUE
	HRRZ AC0,LOCO		;PC OF OUTPUT
	MOVE AC1,MODO		;OLD MODE
	MOVEM AC0,@REL1P(AC1)	;SAVE OLD VALUE
	MOVE AC0,MODO		;SAVE OLD MODE
	MOVEM AC0,ORGMOD
	MOVE AC1,SGNCUR		;CURRENT PSECT INDEX
	MOVE AC0,HIGH		;SAVE PSECT BREAK
	HRRM AC0,SGATTR(AC1)
	HRR AC0,RELLOC		;SAVE PSECT REL PC
	HRL AC0,ORGMOD		;SAVE PSECT MODE
	MOVEM AC0,SGRELC(AC1)
	MOVE AC0,-1(P)		;GET NEW PSECT INX
	MOVEM AC0,SGNCUR	;SET SGNCUR TO IT
	JUMP1 .+2		;IF PASS 2 THEN
	CALL SGOUTN		; OUTPUT PSECT NAME BLOCK
	POP P,AC0		;GET RESULT
	HLRZM AC0,MODA		;SET MODES
	HLRZM AC0,MODO
	HRRZM AC0,LOCA		;AND LOCATIONS
	HRRZM AC0,LOCO
	POP P,SGNCUR		;STORE NEW PSECT INX
	MOVE AC1,SGNCUR		;NEW PSECT INX
	HRRZ AC0,SGATTR(AC1)	;GET PSECT BRK
	MOVEM AC0,HIGH		;RESTORE IT
	CALL SRCHI		;SET UP SRCHX
	RET			;DONE
   >				;END IFN FTPSEC

ERRSX:	TRO ER,ERRS		;FLAG PSECT USAGE ERROR
	RET			;DONE
   >

HISEG1:
   IFN POLISH,<
	SKIPE SGNMAX		;IF PSECTS USED THEN CAN'T USE
	JRST ERRSX		; HISEG OR TWOSEG
   >
	CALL HIGHQ		;SET CURRENT PROGRAM BREAK
	CALL COUTD		;DUMP CURRENT TYPE OF BLOCK
	SKIPN HISNSW		;IF WE HAVE SEEN IT BEFORE
	SKIPE HIGH		;OR ANY RELOC CODE PUT OUT
	TRO ER,ERRQ		;FLAG AS AN ERROR
	BYPASS			;GO GET EXPRESSION
	TLO IO,IORPTC
	CALL EVALXQ		;CHECK FOR EXTERNAL
	ANDCMI AC0,1777		;ONLY ALLOWED TO START ON NEW K BOUND
	HRRZM AC0,LOCA		;SET LOC COUNTERS
	HRRZM AC0,LOCO
	MOVEI RC,1		;ASSUME RELOCATABLE
	RET

TWSEG0:	CALL HISEG1		;COMMON CODE
	JUMPN AC0,.+2		;ARGUMENT SEEN
	MOVEI AC0,400000	;ASSUME 400000
	HRRZM AC0,HMIN		;SET OFSET OF HIGH SEG.
	HRRZM AC0,HHIGH		;INCASE NO HISEG CODE
	TLOA AC0,(1B0)		;SIGNAL TWO SEGMENTS AND SKIP

HISEG0:	CALL HISEG1		;COMMON CODE
HISEG2:	MOVEM AC0,SVTYP3	;SAVE THE HISEG ARG
	MOVEM RC,MODA		;SET MODES
	MOVEM RC,MODO
	SETOM HISNSW		;WE HAVE ALREADY PUT ONE OUT
	JRST BLOCK2		;MAKE LISTING HAPPEN RIGHT


   IFN FORMSW,<
ONFORM:	HRRES HWFMT		;ALLOW MULTI-FORMAT LISTING
	RET
OFFORM:	HRROS HWFMT		;HALF-WORD FORMAT ONLY
	RET >

   IFE FORMSW,<
	SYN CPOPJ,ONFORM
	SYN CPOPJ,OFFORM>

HIGHQ:
HIGHQ1:	MOVE V,LOCO		;GET ASSEMBLY LOCATION
	SKIPN MODO		;IF ASSEMBLY MODE IS ABSOLUTE
	JRST [CAMLE V,ABSHI	;RECORED ABS HIGHEST ALSO
		MOVEM V,ABSHI
		RET]
	SKIPE HMIN		;IS IT A TWO SEGMENT PROGRAM?
	JRST [CAMGE V,HMIN	;YES,IS THIS HIGH SEG.?
		JRST .+1	;NO,STORE LOW SEGMENT
		CAMLE V,HHIGH	;YES,IS IT GREATER THAN "HHIGH"?
		MOVEM V,HHIGH	;YES,REPLACE WITH LARGER VALUE
		RET]
	CAMLE V,HIGH		;IS IT GREATER THAN "HIGH"?
	MOVEM V,HIGH		;YES, REPLACE WITH LARGER VALUE
	RET

ONML:	TLZA FR,MWLFLG		;MULTI-WORD LITERALS OK
OFFML:	TLO FR,MWLFLG		;NO
	RET

OFFSYM:	SETOM IONSYM		;SUPRESS SYMBOL TABLE LISTING
	RET

SUPRE0:	CALL GETSYM		;GET A SYMBOL TO SUPRES
	JRST SUPRE1		;ERROR
	CALL SSRCH		;SYMBOL ONLY
	  JRST SUPRE1		;GIVE ERROR MESSAGE
	CALL SUPSYM		; SEE IF "!" SEEN
	TLOA ARG,SUPRBT		;SET THE SUPRESS BIT
SUPRE1:	TROA ER,ERRA
	IORM ARG,(SX)		;PUT BACK
	JUMPCM SUPRE0		;ANY MORE?
	JRST SUPRS1

SUPRSA:	CALL LOOKUP		;SUPRESS ALL
	MOVSI ARG,SUPRBT
	IORM ARG,(SX)
SUPRS1:	SETZM EXTPNT		;JUST IN CASE WE LOOKED ONE UP
   IFN POLISH,<
	TLZ IO,RSASSW		; ...
   >
	RET

XPUNG0:	JUMP1 POPOUT
	CALL LOOKUP
	MOVE ARG,(SX)		;GET SYMBOL FLAGS
	TLNN ARG,INTF!ENTF!EXTF!SPTR
	TLOA ARG,SUPRBT		;LOCAL SYMBOL,SO SUPPRESS IT
	SETZM EXTPNT
   IFN POLISH,<
	TLZ IO,RSASSW		; ...
   >
	MOVEM ARG,(SX)		;RESTORE FLAGS
	RET

NODDT0:	CALL GETSYM		;GET A SYMBOL TO SUPRES
	  JRST NODDT1		;ERROR
	CALL SSRCH		;SYMBOL ONLY
	  JRST NODDT1		;GIVE ERROR MESSAGE
	CALL SUPSYM		;SEE IF "!" SEEN
	TLOA ARG,NOOUTF		;SET THE NO-DDT BIT
NODDT1:	TROA ER,ERRA
	IORM ARG,(SX)		;PUT BACK
	JUMPCM NODDT0		;ANY MORE?
	JRST SUPRS1


SUPSYM:	CAIE C,'!'		;[404] [167] WANT NO DDT OUTPUT FOR THIS SYMBOL?
	RET			; NO
	TLO ARG,NOOUTF		; YES, SET FLAG
	PJRST BYPAS1		; SKIP "!" AND RETURN
; .CREF SYMBOL,SYMBOL,ETC
ONCRF:	CALL GETSYM		;SEE IF A SYMBOL SPECIFIED
	  JRST [MOVSI AC0,IONCRF ;NO, PUT FLAG BACK
		TRZ ER,ERRA	;CLEAR "A" ERROR
		TLZ IO,DEFCRS	;CLEAR ANY WAITING DEFINING OCCURENCES
		JRST IORSET]
ONCRF0:	CALL SEARCH		;[365] GENERAL SEARCH
	  JRST ONCRFE		;[365] ERROR
	MOVSI ARG,NCRF		;[365] NO CREF FLAG IN ARG
	ANDCAM ARG,(SX)		;[365] TURN OFF NO CREF BIT
	CAMN AC0,1(SX)		;[365] OTHER ENTRY IN SYMBOL TABLE?
	 ANDCAM ARG,2(SX)	;[365] TURN OFF NCRF
	CAMN AC0,-3(SX)		;[365] OTHER ENTRY IN SYMBOL TABLE
	 ANDCAM ARG,-2(SX)	;[365] TURN OFF NCRF
	CAIA			;[365]
ONCRFE:	TRO ER,ERRA		;[365] SET ERROR CONDITION
	JUMPNC SUPRS1		;GIVE UP IF NO MORE
	CALL GETSYM		;GET NEXT SYMBOL
	  JRST ONCRFE		;ERROR
	JRST ONCRF0

; .XCREF SYMBOL,SYMBOL,ETC
OFFCRF:	CALL GETSYM		;SEE IF A SYMBOL SPECIFIED
	  JRST [MOVSI AC0,IONCRF ;PUT FLAG BACK
		TRZ ER,ERRA	;CLEAR "A" ERROR
		JRST IOSET]
OFCRF0:	CALL SEARCH		;[365] GENERAL SEARCH
	  JRST OFCRFE		;[365] ERROR
	MOVSI ARG,NCRF		;[365] NO CREF FLAG IN ARG
	IORM ARG,(SX)		;[365] SET NO CREF BIT
	CAMN AC0,1(SX)		;[365] OTHER ENTRY IN SYMBOL TABLE?
	 IORM ARG,2(SX)		;[365] SET BIT
	CAMN AC0,-3(SX)		;[365] OTHER ENTRY IN SYMBOL TABLE?
	 IORM ARG,-2(SX)	;[365] SET BIT
	CAIA			;[365]
OFCRFE:	TRO ER,ERRA		;[365] FLAG ERROR
	JUMPNC SUPRS1		;GIVE UP IF NO MORE SYMBOLS
	CALL GETSYM		;GET NEXT SYMBOL
	  JRST OFCRFE		;ERROR
	JRST OFCRF0

TITLE0:	JUMP2 REMAR0
	SKIPE TBUF+1		;IS THIS THE FIRST TITLE?
	JRST [TRO ER,ERRM	;NO, FLAG AS ERROR
		JRST REMAR0]	;AND IGNORE
	MOVEI SX,.TBUF
	HRRI AC0,TBUF
	CALL SUBTT1		;GO READ IT
	MOVEM SX,TCNT		;SAVE COUNT OF CHARS. WRITTEN
	SKIPE UNIVSN		;WAS IT A UNIVERSAL?
	CALL ADDUNV		;YES  ADD TO TABLE
	SKIPN TBUF+1		;2ND WORD NON-ZERO SIGNALS TITLE SEEN
	AOS TBUF+1		;MAKE IT SO
   IFN CCLSW,<JRST PRNAM>	;PRINT NAME IF FIRST ONE
   IFE CCLSW,<RET>		;EXIT OTHERWISE

SUBTT0:	JUMP1	[SKIPE SBUF	;[550] PASS1, FIRST SUBTTL?
		JRST REMAR0		;[550] NO,
		MOVE SX,PAGENO		;[550] YES, CHECK PAGE NUMBER
		CAIE SX,1		;[550] PAGE 1?
		JRST REMAR0		;[550] NO,
		JRST .+1]		;[550] YES,
	MOVEI SX,.SBUF
	HRRI AC0,SBUF

SUBTT1:	BYPASS			;BYPASS LEADING BLANKS
	TLO IO,IORPTC
SUBTT3:	CALL CHARAC		;GET ASCII CHARACTER
	IDPB C,AC0		;STORE IN BLOCK
	CAIGE C,40		;TEST FOR TERMINATOR
	CAIN C,HT
	SOJG SX,SUBTT3		;TEST FOR BUFFER FULL
	DPB RC,AC0		;END, STORE TERMINATOR
	SOJA SX,REMAR1		;COUNT NULL AND EAT UP ANY REMAINING CHARS.

   IFN CCLSW,<
PRNAM:	TLNN IO,CRPGSW		;NOT IF NOT RPG
	RET
	PUSH P,AC0		;SAVE AC0 DMN
	PUSH P,RC		;AND RC
	MOVE AC0,[POINT 7,TBUF]
	MOVE SX,[POINT 7,OTBUF]
	MOVEI RC,6		;MAX OF SIX CHRS
	MOVEI C,HT		;START WITH A TAB
	IDPB C,SX
PN1:	ILDB C,AC0
	CAILE C," "		;CHECK FOR LEGAL
	CAILE C,"Z"+40		;CHECK AGAINST LOWER CASE Z
	JRST PN2
	PUSH P,C		;[523] SAVE CHAR
	CAILE C,137		;[523] GET RADIX-50 VALUE FROM CSTAT
	SUBI C,40		;[523]
	SUBI C,40		;[523]
	LDB CS,[POINT 6,CSTAT(C),23] ;[523]
	POP P,C			;[523]
	SKIPN CS		;[523] RADIX-50?
	JRST PN2		;[523] NO, TREAT AS TERMINATOR
	IDPB C,SX		;PUT IN OUTPUT BUFFER
	SOJG RC,PN1		;GET MORE
PN2:	MOVEI C,CR		;END WITH CR-LF
	IDPB C,SX
	MOVEI C,LF
	IDPB C,SX
	SETZ C,			;TERMINATOR
	IDPB C,SX
	TTCALL 3,OTBUF
	POP P,RC
	POP P,AC0		;RESTORE AC0 DMN
	RET
   >


SYN0:	CALL GETSYM		;GET THE FIRST SYMBOL
	  JRST ERRAX		;ERROR, EXIT
	CALL MSRCH		;TRY FOR MACRO/OPDEF
	  JRST SYN3		;NO, TRY FOR OPERAND
SYN1:	MOVEI SX,MSRCH		;YES, SET FLAG
SYN2:	JUMPNC ERRAX		; ERROR IF NO COMMA
	PUSH P,ARG		; SAVE SOME REGISTERS
	PUSH P,RC		;
	PUSH P,V		;
	PUSH P,SX		; SAVE SEARCH ROUTINE
	CALL GETSYM		; GET THE SECOND SYMBOL
	  JRST [SUB P,[4,,4]	; PUT STACK BACK
		RET]		; AND GIVE UP
	POP P,SX		; RESTORE SEARCH ROUTINE
	CALL @SX		; SEARCH FOR SECOND SYMBOL
	  JFCL			;
	POP P,V			; RESTORE VALUES
	POP P,RC		;
	POP P,ARG		;
	TLNE ARG,MACF		;MACRO?
	CALL REFINC		;YES, INCREMENT REFERENCE
	JRST INSERT		;INSERT AND EXIT

SYN3:	CALL SSRCH		;SEARCH FOR OPERAND
	  JRST SYN4		;NOT FOUND, TRY OP CODE
	TLO ARG,SYNF		;FLAG AS SYNONYM
	TLNE ARG,EXTF		;EXTERNAL?
	HRRZ V,ARG		;YES, RELPACE WITH POINTER
	MOVEI SX,SSRCH		;SET FLAG
	TLNN ARG,VARF		;DO NOT LET HIM SYN A VARIABLE
	JRST SYN2
	JRST ERRAX

SYN4:	CALL OPTSCH		;SEARCH FOR OP-CODE
	  JRST ERRAX		;NOT FOUND, EXIT WITH ERROR
	MOVSI ARG,SYNF		;FLAG AS SYNONYM
	SKIPN UWVER		;[542] WRITING A UNIVERSAL FILE?
	JRST SYN1		;NO,
	MOVE AC1,FREE		;[542] YES, GET A FREE WORD
	ADDI AC1,1		;[542]
	CAML AC1,SYMBOL		;[542] NO MORE ROOM?
	CALL XCEEDS		;[542] GET MORE ROOM
	EXCH AC1,FREE		;[542] UPDATE FREE
	MOVEM AC0,(AC1)		;[542] KEEP THE SIXBIT OPERATOR
	MOVE V,AC0		;[542]
	HRR ARG,AC1		;[542] KEEP THE POINTER
	TLO ARG,SIXF		;[542] SET FLAGS FOR POINTER TO SIXBIT
	BITON USYN,UWVER	;[542] ALSO, SET NEW-SYN-HANDLING BIT IN
				;[542] UNIVERSAL VERSION NUMBER
	JRST SYN1		;[542] CONTINUE...

PURGE0:	CALL GETSYM		;GET A MNEMONIC
	  JRST [TRZ ER,ERRA	;CLEAR ERROR
		RET]		;AND RETURN
	CALL MSRCH		;SEARCH MACRO SYMBOL TABLE
	  JRST PURGE2		;NOT FOUND, TRY SYMBOLS
	PUSH P,CS		;SAVE CS AS IT MAY GET GARBAGED
	TLNE ARG,MACF		;MACRO?
	CALL REFDEC		;YES, DECREMENT THE REFERENCE
	POP P,CS
	JRST PURGE4		;REMOVE SYMBOL FROM TABLE

PURGE2:	CALL SSRCH		;TRY OPERAND SYMBOL TABLE
	  JRST PURGE5		;NOT FOUND GET NEXT SYMBOL
	TDNE RC,[-2,,-2]	;CHECK COMPLEX EXTERNAL
	TLNE ARG,SYNF
	JRST .+2
	JRST PURGE3
	TLNE ARG,EXTF!UNDF	;ERROR IF EXTERNAL OR UNDEFINED
	TLNE ARG,SYNF		;BUT NOT A SYNONYM
	JRST PURGE4
PURGE3:	;TROA ER,ERRA		;NOT FOUND, ERROR
PURGE4:	CALL REMOVE		;REMOVE FROM THE SYMBOL TABLE
PURGE5:	JUMPCM PURGE0
	RET			;EXIT


OPD1:	TLNE ARG,UNDF		;IF OPDEF IS UNDEFINED
	TRO ER,ERRO		;GIVE "O" ERROR
OPD:	MOVE AC0,V		;PUT VALUE IN AC0
	JRST OP

IOP:	MOVSI AC2,(POINT 9,0(P),11)
   IFE FORMSW,< TLOA IO,IOIOPF>	;SET "IOP SEEN" AND SKIP
   IFN FORMSW,< PUSH P,IOFORM	;USE I/O FORM
	JUMPAD .+2		;IF IN ADDRESS FIELD, SKIP
	SETOM IOSEEN		; SIGNAL  FOR BOUT TO ADJUST FIELDS
	TLO IO,IOIOPF		;SET "IOP" SEEN
	JRST OP+2>

OP:	MOVSI AC2,(POINT 4,0(P),12)
   IFN FORMSW,< PUSH P,INFORM>	;USE INST. FORM
	PUSH P,RC
	PUSH P,AC0		;STACK CODE 
	PUSH P,AC2
	CALL EVALEX		;EVALUATE FIRST EXPRESSION
	POP P,AC2
	JUMPNC OP2
OP1B:	CALL GETCHR		;GET A CHARACTER
   IFE FORMSW,<JUMPCM XWD5>	;PROCESS COMMA COMMA IN XWD
   IFN FORMSW,<JUMPNC .+4	;JUMP IF NO COMMA
	MOVE AC2,HWFORM		;GET FORM WORD FOR XWD
	MOVEM AC2,-2(P)		;REPLACE INSTRUCTION FORM
	JRST XWD5>		;PROCESS COMMA COMMA IN XWD
	TLO IO,IORPTC		;NOT A COMMA,REPEAT IT
	LDB AC1,AC2
	ADD AC1,AC0
	DPB AC1,AC2
   IFN POLISH,<
	TLNN FR,POLSW		; DON'T ALLOW EXTERNAL ACS
   >
	JUMPE RC,OP1A		;EXTERNAL OR RELOCATABLE?
	CALL QEXT		;YES, DETERMINE WHICH AND FLAG AN ERROR
OP1A:	CALL EVALEX		;GET ADDRESS PART
OP2:	CALL EVADR		;EVALUATE STANDARD ADDRESS
OP3:	POP P,AC0		;PUT IN AC0
	POP P,RC
   IFN FORMSW,< POP P,AC1>	;GET FORM WORD
	SKIPE (P)		;CAME FROM EVALCM?
	JRST STOW		;NO,STOW CODE AND EXIT
	POP P,AC1		;YES,EXIT IMMEDIATELY
	RET

   IFN FORMSW,<
INFORM:	BYTE  (9) 1 (4) 1 (1) 1 (4) 1 (18) 1
IOFORM:	BYTE (3) 1 (7) 1 (3) 1 (1) 1 (4) 1 (18) 1
   >


EVADR:				;EVALUATE STANDARD ADDRESS
   IFE IIISW,<TLNN AC0,-1	;OK IF ALL 0'S
	JRST .+4		;IT WAS
	TLC AC0,-1		;CHANGE ALL ONES TO ZEROS
	TLCE AC0,-1		;OK IF ALL 1'S
	TRO ER,ERRQ>		;NO,FLAG Q ERROR
	ADD AC0,-1(P)		;ADD ADDRESS PORTIONS
	HLL AC0,-1(P)		;GET LEFT HALF
	TLZE FR,INDSW		;INDIRECT BIT?
	TLO AC0,(Z @)		;YES, PUT IT IN
	MOVEM AC0,-1(P)		;RE-STACK CODE
	ADD RC,-2(P)		;UPDATE RELOCATION
	HRRM RC,-2(P)		;USE HALF WORD ADD
	CAIE C,10		;"("?
	RET			;NO, EXIT

	MOVSS EXTPNT		;WFW
	CALL EVALCM		;EVALUATE
	MOVSS EXTPNT		;WFW
	MOVSS V,AC0		;SWAP HALVES
   IFE IIISW,<MOVSS SX,RC
	IOR SX,V		;MERGE RELOCATION
	TRNN SX,-1		;RIGHT HALF ZERO?
	JRST OP2A		;YES, DO SIMPLE ADD
	MOVE ARG,RC>		;NO, SWAP RC INTO ARG
   IFN IIISW,<MOVSS ARG,RC>
	ADD V,-1(P)		;ADD RIGHT HALVES
	ADD ARG,-2(P)
	HRRM V,-1(P)		;UPDATE WITHOUT CARRY
	HRRM ARG,-2(P)
	HLLZS AC0		;PREPARE LEFT HALVES
	HLLZS RC
   IFE IIISW,<TLNE SX,-1	;IS LEFT HALF ZERO?
	TRO ER,ERRQ		;NO FLAG FORMAT ERROR
OP2A:	TLNE RC,-1		;RELOCATION FOR LEFT HALF?
	CALL OP2A1		;YES,IS IT LEGAL?
	TLNE AC0,777000		;OP CODE FIELD USED?
	JRST [EXCH AC0,-1(P)	;YES, GET STORED CODE
		TLNE AC0,777000	;OP CODE FIELD BEEN SET?
		TRO ER,ERRQ	;YES, MOST LIKELY AN ERROR
		EXCH AC0,-1(P)
		JRST .+1]>	;RETURN TO ADD 
	ADDM AC0,-1(P)		;MERGE WITH PREVIOUS VALUE
	ADDM RC,-2(P)
	CAIE C,11		;")"?
	JRST ERRAX		;NO, FLAG ERROR
				;YES, BYPASS PARENTHESIS
BYPAS1:	CALL GETCHR
BYPAS2:	JUMPE C,.-1		;SKIP TRAILING BLANKS
	RET			;EXIT

   IFE IIISW,<
OP2A1:	EXCH RC,-2(P)		;GET STORED CODE
	TLNN RC,-1		;OK IF ALL ZERO
	JRST OP2A2		;OK SO RETURN
	TLC RC,-1		;CHANGE ALL ONES TO ZEROS
	TLCE RC,-1		;OK IF ALL ONES
	TRO ER,ERRQ		;OTHERWISE A "Q" ERROR
OP2A2:	EXCH RC,-2(P)		;GET RC,BACK
	RET>			;AND RETURN


EXPRES:	HRLZ AC0,RX		;FUDGE FOR OCT0

OCT0:	PUSH P,RX
	HLR RX,AC0
   IFN POLISH,<
	HRREI AC0,POLFWF	; PRESET POLISH TYPE SINCE WE
	MOVEM AC0,POLTYP	; NEED FULL WORD FIXUPS IF POLISH
   >
OCT1:	CALL EVALEX		;EVALUATE
   IFN POLISH,<
	TDNE RC,[-2,,-2]	; TEST FOR EXTERNAL
	CALL OCTFW		; YES, NEEDS FULL WORD FIXUP
   >
   IFN FORMSW,< MOVE AC1,HWFORM>
	CALL STOW		;STOW CODE
	JUMPCM OCT1
	POP P,RX		;YES, RESTORE RADIX
   IFN POLISH,<
	SETZM POLTYP		; CLEAR FLAG
   >
	RET			;EXIT

   IFN POLISH,<
;HERE TO GENERATE FULL WORD FIXUPS FOR EXP EXTERN
;NOTE THIS GENERATES BLOCK TYPE 11 POLISH FIXUPS
;THESE CANNOT BE LOADER BY LOADER UNLESS FAILSW IS ON

OCTFW:	JUMP1 [	TRO ER,ERRF
		RET]		;[303] IGNORE ON PASS1
	MOVE PV,FREE		; COPY CODE FROM POLPOP
	EXCH PV,POLIST		; TO SET UP A NEW BLOCK
	CALL POLSTR		; STORE POINTER TO LAST
	MOVE PV,EXTPNT		; GET POINTER TO EXTERNAL SYMBOL
	CALL POLFS2		; STORE EXTERNAL
	JRST POLPSS		; FIXUP ADDRESS, AND RETURN
   >

SIXB10:	MOVSI RC,(POINT 6,AC0)	;SET UP POINTER
	MOVEI AC0,0		;CLEAR WORD

SIXB20:	CALL CHARL		;GET NEXT CHARACTER
	CAMN C,SX		;IS THIS PRESET DELIMITER?
   IFE FORMSW,< JRST ASC60>	;YES
   IFN FORMSW,<
	JRST [	CALL BYPAS1
		ANDCM RC,STPX
		MOVE AC1,SXFORM
		SETZM INTXT	;[320] NO LONGER IN TEXT
		JUMPGE RC,STOWZ
		RET]>
	CAIL C,"A"+40
	CAILE C,"Z"+40
	SKIPA
	SUBI C,40		;CONVERT LC TO UC
	CAIL C,40		;LEGAL SIXBIT CHAR?
	CAILE C,137
	JRST [	TRO ER,ERRA	;NO, FLAG
		JRST SIXB20]	;AND SKIP CHARACTER
	SUBI C,40		;CONVERT TO SIXBIT
	IDPB C,RC		;NO, DEPOSIT THE BYTE
	TLNE RC,770000		;IS THE WORD FULL?
	JRST SIXB20		;NO, GET NEXT CHARACTER
   IFN FORMSW,<
	SKIPA AC1,SXFORM	;SIXBIT FORM
SXFORM:	BYTE (6) 1,1,1,1,1,1
   >
	CALL STOWZ		;YES, STORE
	JRST SIXB10		;GET NEXT WORD


%TEXT1:	TLC AC0,240000		; CONVERT .TEXT TO COMMENT ON PASS1
ASCII0:	HLLZ SDEL,AC0		;STORE ASCII/ASCIZ FLAG
ASC10:	CALL CHARL		;GET FIRST NON-BLANK
	SETZM NOTFL		;[424] INITIALIZE TO FIRST LINE
	CAIE C," "
	CAIN C,HT
	JRST ASC10
	CAIG C,CR		;CHECK FOR CRRET AS DELIM
	CAIGE C,LF
	CAIA
	JRST ERRAX
	FORERR (SX,TXT)
	SETOM INTXT
	MOVE SX,C		;SAVE FOR COMPARISON
	JUMPG SDEL,SIXB10	;BRANCH IF SIXBIT

ASC20:	MOVSI RC,(POINT 7,AC0)	;SET UP POINTER
	TLNE SDEL,200000	;THIS BIT (AND BIT0) IN FOR COMMENT
	MOVSI RC,440000		;SO NOTHING WILL BE DEPOSITED
   IFE IIISW,<MOVEI AC0,0>	;CLEAR WORD
   IFN IIISW,<TLNE SDEL,100000	;ASCID?
	TLZA SDEL,400000	;YES, ZERO ASCIZ BIT
	TDZA AC0,AC0		;NO, ZERO WORD
	MOVE AC0,[BYTE (7) 10,10,10,10,10 (1) 1] >;YES, A WORD FULL OF BACKSPACES
ASC30:	CALL CHARL		;GET ASCII CHARACTER AND LIST
	JUMP1 ASC31		;[522] JUMP ON PASS1
	SKIPL NOTFL		;[522] FIRST LINE?
	AOS NOTFL		;[522] YES, COUNT CHARS IF FIRST LINE
	CAIG C,FF		;[424] LF, FF, OR VT?
	CAIGE C,LF		;[424]
	JRST ASC31		;[424] JUMP IF NO
	SKIPE LITLVL		;[424] IN LITERAL?
	JRST [	SKIPN LITLST	;[424] YES, LITLST REQUESTED?
		JRST ASC31	;[424] NO,
		JRST .+1]	;[424] YES,
	EXCH C,NOTFL		;[522] EXCHANGE TEMPORARILY
	CAILE C,5		;[522] WE HAVE AT LEAST 5 CHARS?
	SETO C,			;[522] YES, NO LONGER FIRST LINE
	EXCH C,NOTFL		;[522] RESTORE FROM THE EXCHANGE
ASC31:	CAMN C,SX		;[424] TEST FOR DELIMITER
	JRST ASC50		;FOUND
	IDPB C,RC		;DEPOSIT BYTE
	TLNE RC,760000		;HAVE WE FINISHED WORD?
	JRST ASC30		;NO,GET NEXT CHARACTER
   IFN FORMSW,<
	SKIPA AC1,ASCIIF	;USE ASCII FORM WORD
ASCIIF:	BYTE (7) 1,1,1,1,1
   >
	TLNE SDEL,040000	;.TEXT ?
	JRST [CALL STOTXT	;YES, STORE IN REL FILE
		JRST ASC20]	;CONTINUE
	CALL STOWZ		;YES, STOW IT
	JRST ASC20		;GET NEXT WORD

ASC50:	TDZ RC,SDEL		;TEST FOR ASCIIZ
	CALL BYPAS1		;POLISH OFF TERMINATOR
	SKIPGE NOTFL		;[522] FIRST LINE?
	SOS NOTFL		;[522] NO, MAKE IT LAST LINE
	SETZM INTXT		;WE ARE OUT OF IT
   IFN FORMSW,< MOVE AC1,ASCIIF> ;USE ASCII FORM WORD
   IFN IIISW,<TLNN SDEL,100000>	;NO EXTRA WORDS FOR ASCID
	ANDCM RC,STPX		;STORE AT LEAST ONE WORD
	TLNN SDEL,200000	;GET OUT WITHOUT STORING
	JUMPGE RC,[TLNN SDEL,040000 ;.TEXT?
		JRST STOWZ	;NO, STOW
		JRST STOTXT]	;YES, STORE IN REL FILE
	RET			;ASCII, NO BYTES STORED, SO EXIT


; .TEXT PSEUDO-OP

%TEXT0:	JUMP1 %TEXT1		;IGNORE ON PASS1
	PUSH P,BLKTYP		;SAVE CURRENT TYPE
	CALL COUTD		;[370] DUMP CURRENT BLOCK
	HLLZ SDEL,AC0		;[370] FLAG BITS FOR ASCII
	SETZM BLKTYP		;DON'T KNOW IT YET
	CALL ASC10		;START PROCESSING
	CALL STOTXD		;FINISH BLOCK
	POP P,BLKTYP		;RESTORE PREVIOUS
	RET

STOTXT:	SKIPN BLKTYP		;FIRST WORD?
	JRST [MOVEM AC0,BLKTYP
		RET]		;SAVE AS BLOCK TYPE
	SKIPN COUTRB		;2ND WORD
	JRST [MOVEM AC0,COUTRB
		RET]
	AOS C,COUTX		;NO, JUST STORE AS NORMAL
	MOVEM AC0,COUTDB(C)
	CAIE C,^D17		;BUFFER FULL?
	RET			;NO

STOTXD:	SKIPN C,BLKTYP		;[331] SEE IF ANY TEXT TO OUTPUT
	JRST COUTI		;[331] NO JUST CLEAR COUNTS
	AOS COUTX		;[331] ACCOUNT FOR STARTING FROM -1
	SETZM BLKTYP		;[331] CLEAR BLOCKTYPE WORD FOR NEXT BLOCK
	TRNN C,177_1		;[331] SEE IF RELOCATION WORD IS NEEDED
	AOS COUTRB		;[331] FIRST WORD OF BLOCK WAS NOT FULL,
				;[331] 2ND WAS 0, PUT THE LSN BIT ON FOR
				;[331] COUTD2 TO CHECK SO THERE WON'T BE
				;[331] AN EXTRA 0 WORD IN THE FILE
	JRST COUTT		;DUMP BLOCK

POINT0:
   IFN FORMSW,< PUSH P,BPFORM>	;USE BYTE POINTER FORM WORD
	PUSH P,RC		;STACK REGISTERS
	PUSH P,AC0
	CALL EVAL10		;EVALUATE RADIX 10
	DPB AC0,[POINT 6,0(P),11] ;STORE BYTE SIZE
	JUMPNC POINT2
   IFN POLISH,<
	SETOM POLTYP		; FORCE RIGHT-HALF FIXUP IF POLISH
   >
	CALL EVALEX		;NO, GET ADDRESS
   IFN POLISH,<
	CALL POLANG		;[464] POLISH IN ANGLE-BRACKETS?
	  JRST POINT1		;[464] NO,
	MOVEI AC0,-1		;[464] FORCE ANDDING WITH 777777
	MOVE PS,CSTAT+'&'	;[464] FORCE OPERATOR
	MOVE RC,INANGL		;[504]
	PUSH P,CS		;[551] SAVE CS
	CALL FORCEP		;[464]
	POP P,CS		;[551] RESTORE CS TO BEFORE FORCEP
POINT1:				;[464]
   >
	CALL EVADR		;EVALUATE STANDARD ADDRESS
   IFN POLISH,<
	SETZM POLTYP		; BACK TO NORMAL
   >
	JUMPNC POINT2
	CALL EVAL10		;EVALUATE RADIX 10
	TLNE IO,NUMSW		;IF NUMERIC
	TDCA AC0,[-1]		;POSITION=D35-RHB
POINT2:	MOVEI AC0,0		;OTHERWISE SET TO D36
	ADDI AC0,^D36
	LSH AC0,^D30
	ADDM AC0,0(P)		;UPDATE VALUE
   IFN POLISH,<
	CALL POLANG		;[464] POLISH IN ANGLE-BRACKETS?
	  JRST OP3		;[464] NO,
	MOVE AC0,0(P)		;[464] GET LEFT HALF OF POINT
	MOVE PS, CSTAT+'+'	;[464] FORCE ADD OF LEFT HALF TO POLISH
	MOVE RC,INANGL		;[504]
	PUSH P,CS		;[551] SAVE CS
	CALL FORCEP		;[464]
	POP P,CS		;[551] RESTORE CS
   >
	JRST OP3

IFN FORMSW,<
BPFORM:	BYTE (6) 1,1 (2) 1 (4) 1 (18) 1
   >



;HERE TO CHECK IF WE HAVE A POLISH IN ANGLE-BRACKETS
;	RETURN IF NO, AND SKIPE RETURN IF YES

   IFN POLISH,<
POLANG:	SKIPN INANGL		;[464] IN ANGLE BRACKET?
	RET			;[464] NO,
	EXCH AC0,INANGL		;[464] NEED TO PUT INANGL VALUE IN AC
	CAME AC0,[-1]		;[464] IS IT -1?
	AOS 0(P)		;[464] NO, SKIP RETURN
	EXCH AC0,INANGL		;[464] EXCHANGE BACK
	RET			;[464]

;USE TO FORCE POLISH OPERATION CONTAINED IN PS

FORCEP:	PUSH P,[TNODE,,0]	;[464] TERMINAL INDICATOR
	PUSH P,RC		;[504] GETS POPPED AS PV
	PUSH P,RC		;[504] GETS POPPED AS PR
	SETZ RC,		;[504]
	PUSH P,PS		;[464] GETS POPPED AS PS
	MOVE CS,[11,33]		;[464] FAKE END
	JRST EVGETD		;[464]
   >

XWD0:
   IFN FORMSW,< PUSH P,HWFORM>	;USE HALF WORD FORM
	PUSH P,RC
	PUSH P,AC0		;STORE ZERO ON STACK
   IFN POLISH,<
	MOVNI AC0,2		;[304] FORCE LEFT HALF STORE
	MOVEM AC0,POLTYP	;[304] IF POLISH
   >
	CALL EVALEX		;EVALUATE EXPRESSION
   IFN POLISH,<
	TLNE FR,POLSW		;[304] IF WE USED POLISH
	SETZM EXTPNT		;[304] CLEAR RHS NOW
   >
	JUMPNC OP2
XWD5:
   IFN POLISH,<
	TLNE FR,POLSW		;[304] IF WE USED POLISH
	SETZM EXTPNT		;[304] CLEAR RHS NOW
   >
	SKIPN (P)		;ANY CODE YET?
	JRST XWD10		;NO,USE VALUE IN AC0
	JUMPE AC0,.+2		;ANYTHING IN AC0?
	TRO ER,ERRQ		;YES,FLAG "Q"ERROR
	MOVE AC0,(P)		;USE PREVIOUS VALUE
	MOVE RC,-1(P)		;AND RELOCATION
XWD10:	TLNN AC0,-1		; LEFT HALF SHOULD BE ZERO
	JRST XWD11		; IT IS
	TLC AC0,-1		; OR AT LEST ALL ONES
	TLCE AC0,-1		; FOR XWD -1,-2 ETC
	TRO ER,ERRQ		; NO, WARN USER
XWD11:	HRLZM AC0,0(P)		;SET LEFT HALF
	HRLZM RC,-1(P)
	MOVSS EXTPNT		;WFW
   IFN POLISH,<
	SETOM POLTYP		;[304] FORCE RHS FIXUP
   >
	JRST OP1A		;EXIT THROUGH OP

IOWD0:
   IFE POLISH,<
	CALL EVALQ		; EVALUATE AND TEST FOR EXTERNAL
   >
   IFN POLISH,<
	MOVNI AC0,2		;[304] FORCE LEFT HALF STORE
	MOVEM AC0,POLTYP	;[304] IF POLISH
	CALL EVALEX		;[304] EVALUATE ALLOWING EXTERNS
	TLZE FR,POLSW		;[304] POLISH SEEN?
	JRST IOWDLP		;[304] YES
	SKIPE RC		;[304] EXTERNAL OR RELOCATABLE
	JUMP2 IOWDLE		;[304] FIXUP ON PASS2
IOWD1:>
	JUMPNC [SKIPN AC0	;IF NZERO AND NO "," SEEN
		TRO ER,ERRQ	;TREAT AS Q ERROR
   IFN FORMSW,< MOVE AC1,HWFORM> ;USE HALF WORD FORM
		SOJA AC0,STOW]	;NO, TREAT AS RIGHT HALF
	PUSH P,AC0		;YES, STACK LEFT HALF
   IFN POLISH,<
	SETZM POLTYP		;[304] RIGHT HALF STORE BY DEFAULT
   >
	CALL EVALEX		;WFW
   IFN POLISH,<
	TLZE FR,POLSW		;[304] POLISH SEEN?
	JRST IOWDRP		;[304] YES
   >
	SUBI AC0,1
IOWD2:	POP P,AC1		;RETRIEVE LEFT HALF
	MOVNS AC1
	HRL AC0,AC1
   IFN FORMSW,<
	SKIPA AC1,HWFORM	;USE HALF WORD FORM
HWFORM:	BYTE (18) 1,1
	JRST STOW		;STOW CODE AND EXIT

   IFN POLISH,<
IOWDLE:	MOVEI SDEL,6		;[304] NEED 6 LOCATIONS
	ADDB SDEL,FREE		;[304] FROM FREE CORE
	CAML SDEL,SYMBOL	;[304] ENOUGH?
	CALL XCEED		;[304] NO
	MOVEI PV,-6(SDEL)	;[304] GET START
	SKIPE LITLVL		;[304] IF IN LITS
	JRST [EXCH PV,POLITS	;[304] USE LIT PTR
		JRST .+2]	;[304]
	EXCH PV,POLIST		;[304] SWAP STACK PTR
	MOVEM PV,-6(SDEL)	;[304] STORE PTR TO NEXT BLOCK
	HRROI PV,14		;[304] UNARY MINUS OP
	MOVEM PV,-5(SDEL)	;[304]
	TRNN RC,-2		;[304] EXTERNAL?
	JRST [SETZM -4(SDEL)	;[304] NO, JUST RELOCATABLE
		HRLZ PV,RC	;[304] RELOC
		HRR PV,AC0	;[304] VALUE
		JRST IOWDLR]	;[304] STORE
	MOVEI PV,2		;[304] MARK GLOBAL
	MOVEM PV,-4(SDEL)	;[304]
	MOVE CV,1(RC)		;[304] GET SIXBIT SYMBOL
	MOVEI ARG,4		;[304] MAKE GLOBAL
	CALL SQOZE		;[304]
IOWDLR:	MOVEM CV,-3(SDEL)	;[304]
	MOVNI PV,2		;[304] LEFT HALF
	MOVEM PV,-2(SDEL)	;[304] STORE OP
	HRLZ PV,MODA		;[304] RELOC
	HRR PV,LOCA		;[304] LOCATION
	MOVEM PV,-1(SDEL)	;[304]
	SETZB RC,EXTPNT		;[304] JUST IN CASE
	JFFO P,IOWD1		;[304] CLEAR LEFT HALF

IOWDLP:	AOS SDEL,FREE		;[304] NEED EXTRA WORD FOR UNARY MINUS
	CAML SDEL,SYMBOL	;[304] SEE IF ENOUGH
	CALL XCEED		;[304] NO
	SKIPE LITLVL		;[304] IF IN LIT
	SKIPA AC1,POLITS	;[304] USE LIT PTR
	MOVE AC1,POLIST		;[304] START OF THIS BLOCK
	SUBI AC1,-2(SDEL)	;[304] NO. OF WORDS TO MOVE
	MOVE AC0,-2(SDEL)	;[304] GET WORD
	MOVEM AC0,-1(SDEL)	;[304] STORE
	SUBI SDEL,1		;[304] BACKUP
	AOJL AC1,.-3		;[304] LOOP
	HRROI AC0,14		;[304] UNARY MINUS
	MOVEM AC0,-1(SDEL)	;[304] AS TOP OPERATOR
	JFFO P,IOWD1		;[304] SETZ AC0,

IOWDRP:	MOVEI SDEL,3		;[304] NEED 3 EXTRA WORDS
	ADDB SDEL,FREE		;[304] TO HOLD -1
	CAML SDEL,SYMBOL	;[304] SEE IF ENOUGH
	CALL XCEED		;[304] NO
	MOVE AC0,-5(SDEL)	;[304] GET EXISTING STORE MARKER
	MOVE AC1,-4(SDEL)	;[304] AND LOCATION
	MOVEM AC0,-2(SDEL)	;[304] AND MOVE UP BY 3
	MOVEM AC1,-1(SDEL)	;[304]
	MOVEI AC1,1		;[304]
	SETZM -4(SDEL)		;[304] CONSTANT MARKER
	MOVEM AC1,-3(SDEL)	;[304] ONE
	SKIPE LITLVL		;[304] IF IN LIT
	SKIPA AC1,POLITS	;[304] USE LIT PTR
	MOVE AC1,POLIST		;[304] START OF THIS BLOCK
	SUBI AC1,-6(SDEL)	;[304] NO. OF WORDS TO MOVE
	MOVE AC0,-6(SDEL)	;[304] GET WORD
	MOVEM AC0,-5(SDEL)	;[304] STORE
	SUBI SDEL,1		;[304] BACKUP
	AOJL AC1,.-3		;[304] LOOP
	HRROI AC0,4		;[304] MINUS
	MOVEM AC0,-5(SDEL)	;[304] AS TOP OPERATOR
	JFFO P,IOWD2		;[304] SETZ AC0,
   >

BYTE0:	CALL BYPAS1		;GET FIRST NON-BLANK
	CAIE C,10		;"("?
	JRST ERRAX		;NO, FLAG ERROR AND EXIT
   IFN FORMSW,<
	PUSH P,[1]
	MOVEI AC0,0
   >
	PUSH P,RC
	PUSH P,AC0		;INITIALIZE STACK TO ZERO
	MOVSI ARG,(POINT -1,(P))

BYTE1:	PUSH P,ARG
	CALL EVAL10		;EVALUATE RADIX 10
	POP P,ARG
	CAIG AC0,^D36		;TEST SIZE
	JUMPGE AC0,.+2
	TRO ER,ERRA
	DPB AC0,[POINT 6,ARG,11] ;STORE BYTE SIZE

BYTE2:	IBP ARG			;INCREMENT BYTE
	TRZN ARG,-1		;OVERFLOW?
	JRST BYTE3		;NO
	SETZB AC0,RC		;YES
	EXCH AC0,0(P)		;GET CURRENT VALUES
	EXCH RC,-1(P)		;AND STACK ZEROS
   IFN FORMSW,<
	MOVE AC1,HWFORM		;USE STANDARD FORM
	EXCH AC1,-2(P)		;GET FORM WORD
   >
	CALL STOW		;STOW FULL WORD

BYTE3:	PUSH P,ARG
	CALL EVALEX		;COMPUTE NEXT BYTE
	POP P,ARG
	DPB AC0,ARG		;STORE BYTE
	HLLO AC0,ARG
	DPB RC,AC0		;STORE RELOCATION

   IFN FORMSW,<
	MOVEI AC0,1
	HRRI ARG,-2
	DPB AC0,ARG		;STORE FORM BYTE
	HRRI ARG,0
   >
	JUMPCM BYTE2
	CAIN C,10		;"("?
	JRST BYTE1		;YES, GET NEW BYTE SIZE
	JRST OP3		;NO, EXIT


RADX50:	CALL EVALEX		;EVALUATE CODE
	JUMPN RC,ERRAX		;ERROR IF NOT ABSOLUTE
	JUMPNC ERRAX
	TDZE AC0,[EXP ^-74]	;[322] MAKE SURE ONLY 74 BITS ON
	TRO ER,ERRQ		;[322] NOPE, LIGHT Q ERROR
	PUSH P,AC0		; SAVE CODE BITS
	CALL GETSYM		;YES, GET SYMBOL
	TRZ ER,ERRA		;CLEAR ERROR
	POP P,ARG		; PUT CODE INTO ARG
	CALL SQOZE		;SQUOZE SIXBIT AND ADD CODE
   IFN FORMSW,< MOVE AC1,HWFORM> ;USE STANDARD FORM
	JRST STOW		;STOW CODE AND EXIT


SQOZE:	MOVE AC1+1,AC0		;PUT SIXBIT IN AC1+1
	MOVEI AC0,0		;CLEAR RESULT
SQOZ1:	MOVEI AC1,0
	LSHC AC1,6		;PUT 6-BIT CHARACTER IN AC1
	LDB AC1,[POINT 6,CSTAT(AC1),23] ;CONVERT TO RADIX50
	IMULI AC0,50		;MULTIPLY PREVIOUS RESULT
	ADD AC0,AC1		;ADD NEW CHARACTER
	JUMPN AC1+1,SQOZ1	;TEST FOR END
	LSH ARG,^D30		;LEFT-JUSTIFY CODE
	IOR AC0,ARG		;MERGE WITH RESULT
	RET

%LINK:	PUSH P,BLKTYP		;SAVE BLOCK TYPE
	PUSH P,AC0
	JUMP1 LINK1		;SKIP CODE GEN IF P1
	CALL COUTD
	MOVEI AC0,12		;LINK TYPE
	MOVEM AC0,BLKTYP
LINK1:	CALL EVALEX		;EVAL CHECK EXT
	POP P,AC1		;GET BITS BACK
	JUMPN RC,LNKERR		;MUST BE ABS
	JUMPNC LNKERR		;GRNTEE COMMA
	TLNE AC1,400000		;LNKEND?
	MOVN AC0,AC0		;YES, NEGATE RESULT
	JUMP1 LINK2		;SKIP IF P1
	CALL COUT
LINK2:	CALL EVALXQ		;NO EXTERNALS
	JUMPNC LINK2A		;[457] THIRD ARGUMENT SPECIFIED?
	HRL AC0,RC		;[457] YES, MUST FIRST SAVE THE
	PUSH P,AC0		;[457] OLD VALUES OF RC, AC0
	CALL EVALXQ		;[457] READ IN THIRD ARGUMENT
	MOVS AC0,AC0		;[457] LINK EXPECTS LNKNXT IN THE
	MOVS RC,RC		;[457] LEFT HELF OF SECOND WORD
	HRR AC0,(P)		;[457] RESTORE LNKLOC VALUE
	HLR RC,(P)		;[457] AND ITS RELOCATION BIT
	TLNE RC,1		;[457] LNKXNT RELOCATABLE?
	 TRO RC,2		;[457] YES, SET FOR COUT TO DEPOSIT
	SUB P,[1,,1]		;[457] "POP" BOGUS WORD OF STACK
LINK2A:	JUMP1 LINK3
	CALL COUT		;DUMP LOC
	CALL COUTD		;FINISH BLOCK
LINK3:	POP P,BLKTYP		;RESTORE BLKTYP
	RET

LNKERR:	POP P,BLKTYP		;RESTORE BLOCK TYPE
	PJRST ERRAX		;GIVE ERROR RETURN

%INTEG:	CALL GETSYM		;GET A SYMBOL
	JRST INTG2		;BAD SYMBOL ERROR
	TLO IO,DEFCRS		;THIS IS A DEFINTION
	CALL SSRCH		;SEE IF THERE
	MOVSI ARG,SYMF!UNDF	;SET SYMBOL AND UNDEFINED IF NOT
	TLNN ARG,UNDF		;IF ALREADY DEFINED
	JRST INTG1		;JUST IGNORE
	TLOA ARG,VARF		;SET VARIABLE FLAG
INTG2:	TROA ER,ERRA		;SYMBOL ERROR
	CALL INSERZ		;PUT IN WITH ZERO VALUE (LENGTH OF 1)
INTG1:	JUMPCM %INTEG
	RET

%ARAY:	MOVEM P,ARAYP		;SAVE PUSHDOW POINTER
ARAY2:	CALL GETSYM
	JRST ARAY1		;BAD SYMBOL GIVE ERROR AND ABORT
	PUSH P,AC0		;SAVE NAME
	JUMPCM ARAY2		;AND GO ON IF A COMMA
	CAIE C,"["-40		;MUST BE A [
	JRST ARAY1
	BYPASS			;OH, WELL
	TLO IO,IORPTC
	CALL EVALXQ		;GET A SIZE
	CAIE C,"]"-40		;MUST END RIGHT
	JRST ARAY1
	BYPASS			;??
	HRRZ V,AC0		;GET VALUE
	SUBI V,1
NXTVAL:	POP P,AC0
	PUSH P,V		;SAVE OVER SEARCH
	TLO IO,DEFCRS
	CALL SSRCH		;FIND IT
	MOVSI ARG,SYMF!UNDF
	POP P,V			;GET VALUE BACK
	TLNN ARG,UNDF
	JRST ARAY3
	TLO ARG,VARF
	MOVEI RC,0		;NO RELOC
	CALL INSERT
ARAY3:	CAME P,ARAYP
	JRST NXTVAL		;STILL NAMES STACKED
	JUMPCM ARAY2
	RET

ARAY1:	TRO ER,ERRA		;ERROR EXIT
	MOVE P,ARAYP
	RET			;RESET PDL AND GO

; .COMMON SYMBOL [SIZE]
SYN ARAYP,COMMP			;SAVE SPACE

COMM0:	JUMP1 COMM1		;WASTE OF TIME ON PASS1
	CALL COUTD		;DUMP CURRENT BLOCK
	PUSH P,BLKTYP		;SAVE TYPE
	MOVEI AC0,20		;COMMON BLOCK TYPE
	MOVEM AC0,BLKTYP	;SET NEW
COMM1:	MOVEM P,COMMP		;SAVE PUSHDOWN POINTER
COMM2:	CALL GETSYM		;GET A 6-BIT SYMBOL NAME
	  JRST COMM7		;BAD SYMBOL, GIVE UP
	PUSH P,AC0		;SAVE SYMBOL NAME
	JUMPCM COMM2		;AND GET ANOTHER IF COMMA

	CAIE C,'['		;MUST BE A [
	JRST COMM7		;YOU LOSE
	BYPASS			;SKIP ANY LEADING SPACES
	TLO IO,IORPTC		;BUT NOT LAST CHAR
	CALL EVALXQ		;GET SIZE OF COMMON
	CAIE C,']'		;MUST END RIGHT
	JRST COMM7
	HRRZ V,AC0		;GET VALUE
				;PUSHDOWN STACK IS IN WRONG ORDER, REVERSE IT
	HRRZ RC,P		;TOP ITEM
	HRRZ ARG,COMMP		;BOTTOM ITEM
	ADDI ARG,1		;WELL ALMOST
COMM6:	CAIG RC,(ARG)		;ANYTHING TO MOVE?
	JRST COMM3		;NO
	MOVE 0,(RC)		;MOVE TOP
	EXCH 0,(ARG)		;TO BOTTOM
	MOVEM 0,(RC)
	SUBI RC,1		;DECREMENT
	AOJA ARG,COMM6		;AND TRY AGAIN

COMM3:	JUMP1 [	MOVE AC0,0(P)	;[465] GET SYMBOL
		CALL SEARCH	;[465] PERFORM GENERAL SEARCH
		  JRST COMM3A	;[465] NOT FOUND, GOOD
		JUMPL ARG,CMNERR ;[465] FOUND, OPERAND, WARN
		CAME AC0,-3(SX)	;[465] MACRO, LOOK ONE SLOT BELOW
		JRST COMM3A	;[465] NOT FOUND, CONTINUE
		JRST CMNERR]	;[465] WARNING
COMM3A:	POP P,AC0		;GET SYMBOL
	JUMP1 .+2		;IGNORE V ON PASS 1
	PUSH P,V		;SAVE VALUE
	CALL EXTER1		;DEFINE AS EXTERNAL
				;NOTE, CS IS NOT ON A COMMA, SO WILL RETURN
	JUMP1 COMM4		;ALL DONE IF PASS1
	SETZ RC,		;NO RELOCATION
	MOVEI ARG,4		;FORM RADIX50 04,SYMBOL
	CALL SQOZE		;IN AC0
	CALL COUT		;OUTPUT SYMBOL
	POP P,V			;GET VALUE BACK
	MOVE AC0,V		;AND INTO AC0
	CALL COUT		;SECOND PART OF PAIR
COMM4:	CAME P,COMMP		;FINISHED WITH STACKED SYMBOLS
	JRST COMM3		;NO MORE TO GO
	BYPASS			;GET NEXT DELIMITER
	JUMPCM COMM2		;MORE TO GO IF COMMA NEXT
COMM5:	JUMP1 CPOPJ
	CALL COUTD		;DUMP THIS BLOCK
	POP P,BLKTYP		;RESTORE LAST
	RET


COMM7:	TRO ER,ERRA		;FLAG ERROR
	MOVE P,COMMP		;RESET PUSHDOWN POINTER
	JRST COMM5		;RESTORE BLKTYP AND EXIT
CMNERR:	CALL EWARN		;[465] WARNING
	MOVSI RC,[SIXBIT /SOC STATEMENT OUT OF ORDER .COMMON@/] ;[465] SYMBOL IN AC0
	CALL TYPMSG		;[465]
	AOS QERRS		;[465] COUNT AS WARNING
	JRST COMM3A		;[465] CONTINUE


; .REQUEST DEV:FILENAME[PPN]

REQUIR:	SKIPA CS,[16]		;BLOCK TYPE 16
REQUES:	MOVEI CS,17		;BLOCK TYPE 17
	JUMP1 REMAR0		;IGNORE ON PASS 1
	CALL COUTD		;DUMP CURRENT
	PUSH P,BLKTYP		;SAVE LAST BLOCK TYPE
	MOVEM CS,BLKTYP		;SET NEW
REQU0:
REPEAT 3,<PUSH P,[0]>		;STACK A NULL SPEC INCASE OF ERROR
	BYPASS			;[345] FLUSH EXTRA TABS AND SPACES
	TLO IO,IORPTC		;[350] BACK OFF BECAUSE SCHGET
	CALL SCHGET		;[335] GET PART OF A FILE SPEC
	JUMPE AC0,REQUER	;[335] ERROR IF NOTHING
	CAIE C,':'		;WAS THERE A DEVICE
	JRST REQU1		;NO, GOOD GUESS
	MOVEM AC0,-2(P)		;SAVE DEVICE
	CALL SCHGET		;[335] GET THE FILE NAME
	JUMPE AC0,REQUER	;[335] ERROR IF NOTHING
REQU1:	MOVEM AC0,(P)		;STORE FILE NAME
	CAIN C,'.'		;[335] SEE IF AN EXTENSION GIVEN
	JRST REQU4		;[335] YES, GO SKIP IT AND MAKE SURE IT'S
REQU3:				;[335] A .REL FILE, CAUSE THAT'S ALL IT CAN BE
	CAIE C,'['		;WAS THERE A PPN
	JRST REQU2		;NO, AS EXPECTED
	BYPASS			;SKIP ANY BLANKS
	TLO IO,IORPTC
	CALL EVALXQ		;GET HALF A PPN
	HRLM AC0,-1(P)		;STORE IT
	CALL EVALXQ		;GET OTHER HALF
	HRRM AC0,-1(P)		;STORE IT
	CAIE C,']'		;MUST END ON ]
	JRST REQUER		;IT DIDN'T
	BYPASS			; SCAN AFTER RIGHT BRACKET
REQU2:	SETZ RC,		;NO RELOCATION
	POP P,AC0		;GET FILE NAME
	CALL COUT
	POP P,AC0		;AND PPN
	CALL COUT
	POP P,AC0		;FINALLY DEVICE
	CALL COUT
	JUMPCM REQU0		;MORE TO COME
	CALL COUTD		;DUMP BLOCK
	POP P,BLKTYP		;RESTORE BLOCK TYPE
	RET			;NO

REQU4:	CALL SCHGET		;[355] GO SCAN OUT EXTENSION
	HLRZ AC0,AC0		;[355] SWAP FOR CAIE
	CAIE AC0,'REL'		;[355] SEE IF IT'S FOR .REL
	TRO ER,ERRQ		;[355] NOPE, TELL HIM ABOUT IT
	JRST REQU3		;[355] BACK TO LOOK FOR PPN

REQUER:	SUB P,[3,,3]		;REMOVE THE THREE ITEMS
	POP P,BLKTYP		;RESTORE BLOCK TYPE
	JRST ERRAX		;AND GIVE UP

; NEW .DIRECTIVE PSEUDO-OP 
; ARGS ARE FUNCTIONS TO BE DONE

%DIREC:	MOVEI AC2,0		;[313] INIT FLAG TO 'YES'
DIREC1:	CALL GETSYM		;[313] GET THE SYMBOL
	  JRST ERRAX		;MISSING, GIVE ERROR
	CAMN AC0,[SIXBIT /NO/]	;[313] 'NO ...' ?
	JRST [	SETO AC2,	;[313] REVERSE FLAG
		JRST DIREC1]	;[313] TRY AGAIN FOR FUNCTION
	MOVSI ARG,-DIRLEN	;AOBJN WORD
	CAMN AC0,DIRARG(ARG)	;LOOK FOR MATCH
	JRST DIRFND		;GOT IT
	AOBJN ARG,.-2		;LOOP FOR ALL OF TABLE
	JRST ERRAX		;NOT FOUND, GIVE ERROR

DIRFND:	XCT DIRXCT(ARG)		;DO FUNCTION
	JUMPCM %DIREC		;MORE IF COMMA
	RET			;OTHERWISE RETURN

DIRARG:	SIXBIT /.NOBIN/		;DON'T GENERATE BINARY (REL) FILE
	SIXBIT /.ITABM/		;INCLUDE TAB/SPACE IN MACRO ARGS
	SIXBIT /.XTABM/		;ESCLUDE TAB/SPACE IN MACRO ARGS
	SIXBIT /SFCOND/		;XLIST IN IF (FALSE)
	SIXBIT /LITLST/		;[314] LIST BINARY IN LITERALS
	SIXBIT /FLBLST/		;FIRST LINE BINARY LISTING ONLY
	SIXBIT /MACPRF/		;MACRO DEF PREFERRED OVER SYMBOL
	SIXBIT /MACMPD/		;[313] NEW MACRO ARG HANDLING
	SIXBIT /KA10/		; PUT KA10 TYPE IN HEADER BLOCK
	SIXBIT /KI10/		; PUT KI10 TYPE IN HEADER BLOCK
	SIXBIT /KL10/		;PUT KL10 TYPE IN HEADER BLOCK
	SIXBIT /.OKOVL/		; ALLOW /,* OVERFLOW
	SIXBIT /.EROVL/		; DON'T ALLOW /,* OVERFLOW
   IFN TSTCD,<
	SIXIBT /.TCDON/		;[414] SET LINK DEBBUGGING FLAG
	SIXBIT /.TCDOF/		;[414] OFF
   >
DIRLEN==.-DIRARG

DIRXCT:	CALL [	JUMPE AC2,%NOBIN ;'NO' GIVEN?
		TRO ER,ERRQ	;YES, ILLEGAL
		RET]
	SETCAM AC2,ITABM	; = NO .XTABM
	MOVEM AC2,ITABM		;NORMAL DEFAULT
	SETCAM AC2,IFXLSW	;SWITCH TESTED AT REPZ (REPEAT)
	SETCAM AC2,LITLST	;[314] SET LISTING FLAG
	CALL SETFLB		;SET FLBLST
	SETCAM AC2,MACPRF	;SET FLAG FOR EVALEX
	CALL [	MOVEM AC2,MACTAB ;SET MACRO ARG DELIMITER FLAG
		MOVEM AC2,ITABM	;IMPLIES ITABM ALSO
		RET]
	CALL SETKA		;
	CALL SETKI		;
	CALL SETKL		;
	SETCAM AC2,OKOVFL	; = NO .EROVL
	MOVEM AC2,OKOVFL	; NORMAL DEFAULT
   IFN TSTCD,<
	CALL TCDSET
	MOVEM AC2,TCDFLG
   >

SETKA:	SKIPA ARG,[1B5]		;
SETKI:	MOVSI ARG,(2B5)		;
	SKIPA			;[413] SET FOR KI OR KA
SETKL:	MOVSI ARG,(4B5)		;[413] KA=1 KI=2 KL=4
	IORM ARG,CPUTYP		;[413] MAKE INCLUSIVE WITH WHAT IS THERE
	RET			;[413] THEN RETURN


;SET FLBLST SWITCH.  WHEN ON, IT CAUSES ONLY ONE LINE OF BINARY TO BE

;LISTED FOR MULTI-WORD STATEMENTS, E.G. ASCIZ.

SETFLB:	MOVSI AC1,(FLBLST)
	ANDCAM AC1,BLSW
	SKIPN AC2		;USER WANTS IT?
	IORM AC1,BLSW		;YES, SET FLAG
	RET

   IFN TSTCD,<
TCDSET:	SETCAM AC2,TCDFLG	;[414] SET FLAG ON
	CALL COUTD		;[414] BIND OFF LAST BLOCK
	RET			;[414]
>				;[414]


; PSEUDO-END STATEMENT FOR MULTI-FILE CAPABILITY

; HERE IF PRGEND (PASS 1)
PSEND0:	TLO IO,MFLSW		;PSEND SEEN
	CALL END0		;AS IF END STATEMENT
	HLLZS IO		;CLEAR ER(RH)
	SETZM ERRCNT		;CLEAR ERROR COUNT FOR EACH PROG.
	SETZM QERRS		; ...
	JUMP2 PSEND2		;DIFFERENT ON PASS2
	SKIPE UNIVSN		;SEEN A UNIVERSAL
	CALL UNISYM		;YES, STORE SYMBOLS
	CALL PSEND4		;SAVE SYMBOLS, POINTERS AND TITLE
	MOVE AC0,[ASCII /.MAIN/] ;[420] GET DEFAULT TITLE
	MOVEM AC0,TBUF		;[420] AND MAKE IT CURRENT TITLE
	SETZM TBUF+1		;CLEAR TITLE SEEN FLAG
	SETZM RELLOC		;[346] CLEAR TO PREVENT EFFECTS ACROSS PRGEND
PSEND1:	TLZ IO,MFLSW		;FOR NEXT FILE
	SETZM UNISCH		;CLEAR UNIVERSAL SEARCH TABLE
	MOVE AC0,[UNISCH,,UNISCH+1]
	BLT AC0,UNISCH+.UNIV-1
	TLO IO,IOPAGE		; SIGNAL NEW PAGE BUT DON'T CHANGE NUMBER
	MOVSI AC0,1		;SET SO RELOC 0 WORKS
	HRRZM AC0,LOCA		; SET ASSEMBLY LOCATION
	HRRZM AC0,LOCO		; AND OUTPUT LOCATION
	HLRZM AC0,MODA		; SET MODE
	HLRZM AC0,MODO		;
	RET			;

; HERE IF PRGEND (PASS 2)
PSEND2:	SETZM SBUF		;SO SUBTTL IS NOT WRONG
	SETZM UNIVSN		; IN CASE IN UNIVERSAL
	TLZ FR,R1BSW!RIMSW!RIM1SW
	CALL PSEND5		;PUT TITLE BACK
	CALL PSEND1		;COMMON  CODE
	JRST PASS20		;OUTPUT THE ENTRIES

; HERE IF END (PASS 1)
PSEND3:	CALL PSEND4		;SAVE LAST PROGRAM 
	HLRS PRGPTR		;REINITIALIZE POINTER
	PJRST PSEND5		;READ BACK FIRST PROGRAM

;HERE TO SAVE AND RESTORE SYMBOL TABLE, TITLE AND OTHER USEFUL LOCATIONS
	XTRA==7			;NUMBER OF OTHER LOCATIONS TO SAVE

PSEND4:	MOVE V,FREE		;GET  NEXT FREE LOCATION
	ADDI V,LENGTH+.TBUF/5+XTRA
   IFN POLISH,<
	ADD V,SGNMAX
	ADD V,SGNMAX
	ADD V,SGNMAX
	ADD V,SGNMAX
   >
	CAML V,SYMBOL		;WILL WORST CASE FIT?
	CALL XCEED		;NO, EXPAND
	MOVS V,FREE
	HRR V,PRGPTR		;LAST PRGEND BLOCK
	HLRM V,(V)		;LINK THIS BLOCK
	SKIPN PRGPTR		;IF FIRST TIME
	HLLZM V,PRGPTR		;SET LINK TO START OF CHAIN
	HLRM V,PRGPTR		;POINTER TO IT
	SETZM @FREE		;CLEAR LINK WORD
	AOS FREE		;THIS LOCATION USED NOW
	MOVS AC0,SYMBOL		;BOTTOM OF SYMBOL TABLE
	HRR AC0,FREE		;FREE SPACE
	MOVE V,@SYMBOL		;GET NUMBER OF SYMBOLS
	ASH V,1			;TWO WORDS PER SYMBOL
	ADDI V,1		;ONE MORE FOR COUNT
	ADDB V,FREE		;END OF TABLE WHEN MOVED
	BLT AC0,(V)		;MOVE TABLE
	HRRZ AC0,.JBREL		;TOP OF CORE
	SUBI AC0,1
	MOVEM AC0,SYMTOP	;FOR NEXT SYMBOL TABLE
	SUBI AC0,LENGTH		;LENGTH OF INITIAL SYMBOLS
	MOVEM AC0,SYMBOL	;SET POINTER TO COUNT OF SYMBOLS
	HRLI AC0,SYMNUM		;BLT POINTER
	BLT AC0,@SYMTOP		;SET UP INITIAL SYMBOL TABLE
	CALL SRCHI		;SET UP SEARCH POINTER
	MOVEI AC0,.TBUF		;MAX NUMBER OF CHARS. IN TITLE
	SUB AC0,TCNT		;ACTUAL NUMBER
	IDIVI AC0,5		;NUMBER OF WORDS
	SKIPE AC1		;REMAINDER?
	ADDI AC0,1		;YES
	MOVEM AC0,@FREE		;STORE COUNT
	AOS FREE		;THIS LOCATION USED NOW
	EXCH AC0,FREE		;SET UP AC0 FOR BLT
	ADDM AC0,FREE		;WILL BE AFTER TITLE MOVES
	HRLI AC0,TBUF		;BLT POINTER
	BLT AC0,@FREE		;MOVE TITLE
   IFN POLISH,<
	MOVE AC2,SGNMAX		;PSECT COUNT
	MOVE AC0,AC2
	CALL STORIT		;SAVE PSECT COUNT
	MOVE AC0,SGNAME(AC2)
	CALL STORIT		;SAVE PSECT NAME
	MOVE AC0,SGRELC(AC2)
	CALL STORIT		;SAVE MODE AND PC
	MOVE AC0,SGSCNT(AC2)
	CALL STORIT		;SAVE SYM CNT
	MOVE AC0,SGATTR(AC2)
	CALL STORIT		;SAVE BREAK AND ATTRS
	SOJGE AC2,.-10
	SETZM SGNMAX		;ZERO PSECT CNT
	SETZM SGNAME		;BLANK PSECT NAME
	MOVSI AC0,1		;SET RELOCATION
	MOVEM AC0,SGRELC	; TO RELATIVE ZERO
	MOVE AC0,@SYMBOL	;GET SYM CNT
	MOVEM AC0,SGSCNT	;SAVE PSECT SYM CNT
	CALL SRCHI		;SET UP SEARCH POINTER
   >
	MOVE AC0,LITHD		; LENGTH ,, START
	CALL STORIT		;
	MOVE AC2,LITHDX		;POINTER TO LIT INFO.
	MOVE AC0,-1(AC2)	;SIZE OF PASS1 LOCO
	CALL STORIT		;SAVE IT IN SYMBOL TABLE
	MOVE AC2,VARHDX		;SAME FOR VARS
	MOVE AC0,-1(AC2)
	CALL STORIT
	MOVE AC0,(AC2)
	CALL STORIT
	SETZM (AC2)		;CLEAR NUMBER OF VARIABLES SEEN
	MOVE AC0,HISNSW		;GET TWOSEG/HISEG FLAG
	HRR AC0,HIGH1		;AND PASS1 BREAK
	CALL STORIT
	SETZM HISNSW		;[412] CLEAR HISEG FLAG FOR NEXT PROGRAM
	JUMPGE AC0,PSEND6	;NOT TWOSEG
	MOVE AC0,SVTYP3		;HIGH SEGMENT OFFSET
	CALL STORIT		;SAVE IT ALSO
PSEND6:	MOVE AC0,FREE		;GET NEXT FREE LOCATION
	SUBI AC0,1		;LAST ONE USED
	HRRZ V,PRGPTR		;POINTER TO START OF DATA BLOCK
	HRLM AC0,(V)		;LINK TO END OF BLOCK
	RET			;RETURN

PSENDX:	CALL XCEED		;NEED TO EXPAND CORE FIRST
PSEND5:	HRRZ V,.JBREL		; GET TOP OF CORE
	SETZM (V)		; CLEAR OR GET ILL MEM REF
	MOVEI AC0,-1(V)		;
	MOVEM AC0,SYMTOP	;TOP OF NEW SYMBOL TABLE
	HRRZ V,PRGPTR		;ADDRESS OF THIS BLOCK
	JUMPE V,PSNDER		;ERROR LINK NOT SET UP
	MOVE AC1,(V)		;NEXT LINK
	MOVE V,1(V)		;GET ITS SYMBOL COUNT
	ASH V,1			;NUMBER OF WORDS
	ADDI V,1		;PLUS ONE FOR COUNT
	SUBI AC0,(V)		;START OF NEW SYMBOL TABLE
	CAMG AC0,FREE		;WILL IT FIT
	JRST PSENDX		;NO, NEED TO EXPAND AND RESET AC0
	ADD V,PRGPTR		;POINT TO END OF SYMBOL TABLE
	MOVEI V,1(V)		;THEN TO BEG OF TITLE
	MOVEM AC0,SYMBOL	;BOTTOM OF NEW TABLE
	HRL AC0,PRGPTR		;ADDRESS OF FIRST WORD OF BLOCK
	ADD AC0,[1,,0]		;MAKE BLT POINTER
	HRRM AC1,PRGPTR		;POINT TO NEXT BLOCK
	BLT AC0,@SYMTOP		;MOVE TABLE
	CALL SRCHI		;SET UP POINTER
	MOVE AC1,(V)		;NUMBER OF WORDS OF TITLE
	MOVEI AC0,1(V)		;START OF STORED TITLE
	ADD V,AC1		;INCREMENT PAST TITLE
	ADDI AC1,TBUF-1		;END OF TITLE
	HRLI AC0,TBUF		;WHERE TO PUT IT
	MOVSS AC0		;BLT POINTER
	BLT AC0,(AC1)		;MOVE TITLE
   IFN POLISH,<
	CALL GETIT		;GET PSECT COUNT
	MOVE AC2,AC0
	MOVEM AC2,SGNMAX
	CALL GETIT		;GET PSECT NAME
	MOVEM AC0,SGNAME(AC2)
	CALL GETIT		;GET MODE AND PC
	MOVEM AC0,SGRELC(AC2)
	CALL GETIT		;GET SYM CNT
	MOVEM AC0,SGSCNT(AC2)
	CALL GETIT		;GET BREAK AND ATTRS
	MOVEM AC0,SGATTR(AC2)
	SOJGE AC2,.-10
	SETZM SGNCUR		;SET TO BLANK PSECT
	CALL SRCHI		;SET UP POINTER
   >
	SKIPN TBUF+1		;CHECK TITLE SEEN FLAG
	AOS TBUF+1		;AND SET IT NON-ZERO
	CALL GETIT		;
	MOVEM AC0,LITHD		;
	MOVE AC2,LITHDX		;INVERSE OF ABOVE
	CALL GETIT
	MOVEM AC0,-1(AC2)
	MOVE AC2,VARHDX		;SAME FOR VARS
	CALL GETIT
	MOVEM AC0,-1(AC2)
	CALL GETIT
	MOVEM AC0,(AC2)		;RESTORE COUNT OF VARS
	CALL GETIT		;GET TWO HALF WORDS
	HRRZM AC0,HIGH1		;PASS1 BREAK
	HLLEM AC0,HISNSW	;TWOSEG/HISEG FLAG
	JUMPGE AC0,CPOPJ	;NOT TWOSEG
	CALL GETIT
	MOVEM AC0,SVTYP3	;BLOCK 3 WORD
	RET

STORIT:	MOVEM AC0,@FREE		;STORE IT IN DATA BLOCK
	AOS FREE		;ADVANCE POINTER
	RET

GETIT:	MOVE AC0,1(V)		;FILL AC0 OUT OF PRGEND BLOCK
	AOJA V,CPOPJ		;INCREMENT AND RETURN

PSNDER:	HRROI RC,[SIXBIT /PGE PRGEND ERROR @/] ;[377]
	JRST ERRFIN

;MULTIPLE SYMBOL TABLE FEATURE PSEUDO-OPS

UNIV0:	JUMP2 UNIV2		; DO PROPER PASS2 STUFF
	BITON UBAS+UMACV,UWVER	;[454] WRITING UNV FILE, MUST HAVE UBAS ON
				;[543] ALSO, MACRO VERSION GETS PUT OUT
	HRRZ SX,UNIVNO		;GET NUMBER OF UNIVERSALS SEEN
	CAIL SX,.UNIV		;ALLOW ONE MORE?
	JRST UNVERR		;NO, GIVE FATAL ERROR
	SETOM UNIVSN		;AND SET SEEN A UNIVERSAL
	JRST TITLE0		;CONTINUE AS IF TITLE

UNIV2:	HLLOS UNIVSN		; ENSURE SET UP FOR UNIVERSAL
	JRST REMAR0		; AND IGNORE LINE

ADDUNV:	PUSH P,RC		;AN AC TO USE
	CALL NOUT		;CONVERT TO SIXBIT
	HRRZ RC,UNIVNO		;GET ENTRY INDEX
	MOVEM AC0,UNITBL+1(RC)	;STORE SIXBIT NAME IN TABLE
	MOVEM AC0,UNVDIR	;AND FOR ENTER LATER
	HRRZS UNIVSN		;ONLY DO IT ONCE
	POP P,RC		;RESTORE RC
	RET			;AND RETURN

UNVERR:	HRROI RC,[SIXBIT /TMU TOO MANY UNIVERSALS@/]
	JRST ERRFIN

UNISYM:	CALL SUPRSA		;TURN ON SUPPRESS BIT
	SKIPN UNVSKP		;SKIP IF /U SEEN
	CALL UNVOUT		;OUTPUT SYMBOL TABLE
	TLNN IO,MFLSW		; ALSO IN PRGEND?
	JRST UNISYN		; NO
	MOVE AC0,@SYMBOL	; GET NO. OF SYMBOLS
	LSH AC0,1		; 2 WORDS EACH
	ADDI AC0,1		; PLUS COUNT
	ADD AC0,FREE		; HOW MUCH WE WILL NEED
	CAML AC0,SYMBOL		; WILL IT FIT IN WHAT WE HAVE
UNISYK:	CALL XCEED		;[355] [231] NO, EXPAND
	CAML AC0,SYMBOL		;[355] ENOUGH?
	JRST UNISYK		;[355] NO, EXPAND
UNISYN:	PUSH P,SYMBOL		;NEED TO SAVE INCASE PRGEND
	MOVE AC0,SYMTOP		;TOP OF TABLE
	SUB AC0,SYMBOL		;GET LENGTH OF TABLE
	HRL ARG,SYMBOL		;BOTTOM OF TABLE
	HRR ARG,FREE		;WHERE TO GO
	HRRZ RC,UNIVNO		;GET TABLE INDEX
	HRRM ARG,SYMBOL		;WILL BE THERE SOON
	HRRZM ARG,UNIPTR+1(RC)	;STORE IN CORRESPONDING PLACE
	ADDB AC0,FREE		;WHERE TO END
	HRLM AC0,UNIPTR+1(RC)	;SAVE NEW SYMTOP
	BLT ARG,@FREE		;MOVE TABLE
	HRRZM AC0,UNITOP	;SAVE TOP OF TABLES+1
	CAMLE AC0,MACSIZ	;IN CASE OVER A K BOUND
	MOVEM AC0,MACSIZ	;DON'T REDUCE SO FAR NOW
	MOVE AC0,SRCHX		;SAVE OLD SEARCH POINTER
	CALL SRCHI		;GET SEARCH POINTER
	EXCH AC0,SRCHX
	MOVEM AC0,UNISHX+1(RC)	;SAVE IT
	POP P,SYMBOL		;RESTORE OLD VALUE
	SETZM UNIVSN		;CLEAR FLAG INCASE PRGEND
	AOS UNIVNO		;SIGNAL ANOTHER UNIVERSAL SAVED
	RET			;RETURN

SERCH0:	CALL GETSYM		;GET A SYMBOL
	  JRST ERRAX		;ERROR IF NOT VALID
	MOVE RC,UNIVNO		;NUMBER OF UNIVERSALS AVAILABLE
	JUMPE RC,UNVINP		;TRY TO READ SYMBOLS FROM DSK
	CAME AC0,UNITBL(RC)	;LOOK FOR MATCH
	SOJA RC,.-2		;NOT FOUND YET
SERCH1:	MOVE AC0,RC		;STORE TABLE ENTRY NUMBER
	MOVEI RC,1		;START AT ENTRY ONE
	CAIL RC,.UNIV		;CHECK FOR CONSISTENCY ERROR
	JRST SCHERR		;SHOULD NEVER HAPPEN!!
	SKIPE UNISCH(RC)	;LOOK FOR AN EMPTY SLOT
	AOJA RC,.-3		;NOT FOUND YET
	MOVEM AC0,UNISCH(RC)	;STORE INDEX IN TABLE
	CAIE C,'('		; GIVING FILE SPEC?
	JRST SERCH4		; NO
SERCH2:	CALL GETCHR		; YES, GET RID OF IT
	CAIN C,')'		; LOOK FOR END
	JRST SERCH3		; FOUND IT
	CAIE C,EOL		; REACHED END OF LINE?
	JRST SERCH2		; NO, KEEP LOOKING
	TROA ER,ERRQ		; GIVE UP AND FLAG ERROR
SERCH3:	CALL GETCHR		; GET NEXT CHAR
SERCH4:	JUMPCM SERCH0		; LOOK FOR MORE NAMES
	RET			;FINISHED

VERSKW:	MOVSI RC,[SIXBIT /UVS UNIVERSAL VERSION SKEW, REASSEMBLE UNIVERSAL @/] ;[364]
	JRST ERRFIN		;[364] NAME IN AC0

SCHERR:	MOVSI RC,[SIXBIT /CFU CANNOT FIND UNIVERSAL@/]
	JRST ERRFIN		;NAME IN AC0

;MESSAGE FOR CASE WHERE FILES AFTER UNIVERSAL USED MORE BUFFER SPACE THAN FIRST UNIVERSAL
UNIERR:	HRROI RC,[SIXBIT /CAP CORE ALLOCATION PROBLEM WHEN DIFFERENT OUTPUT SPECS USED FOR UNV AND NON-UNV PROGRAMS IN THE SAME ASSEMBLY.  DO CONTROL-C AND START@/]
	JRST ERRFIN

SCHGET:	SETZ AC0,		; INITIALIZE
	MOVSI AC1,(POINT 6,AC0)	;
SCHGNX:	CALL GETCHR		; GET NEXT CHARACTER
	CAIE C,'.'		; SPECIAL TEST FOR END OF NAME
	TLNN CS,6		; OR ANY NON-ALPHANUMERIC
	PJRST BYPAS2		; SKIP ALL SPACES AND QUIT
	TLNE AC1,770000		; ALL SIX IN YET?
	IDPB C,AC1		; NO, STORE THIS ONE
	JRST SCHGNX		; GET NEXT

SCHOCT:	SETZ AC0,		; INITIALIZE
SCHONX:	CALL GETCHR		; GET NEXT CHAR
	TLNN CS,4		; NUMBER
	PJRST BYPAS2		; NO, SKIP TRAILING SPACES
	LSH AC0,3		; MAKE SPACE
	ADDI AC0,-'0'(C)	; AND STOW DIGIT
	JRST SCHONX		; GET NEXT

SUBTTL MACRO/REPEAT HANDLERS

REPEA0:	CALL EVALXQ		;EVALUATE REPEAT EXP, EXTERNS ARE ILL.
	JUMPNC ERRAX
	SETZM NESTED		;[443] ASSUME NOT NESTED
	SKIPN LITLVL		;[443] IN LITERAL?
	SKIPE MACLVL		;[443] IN MACRO?
	SKIPA			;[443]
	SKIPE RPOLVL		;[443] IN REPEAT 1 OR IF'S?
	SETOM NESTED		;[443] YES, IT IS NESTED IN ONE OF THEM

REPEA1:	SETZM COMSW		;[425] SET COMMENT SWITCH
	JUMPLE AC0,REPZ		;PASS THE EXP., DONT PROCESS
	SOJE AC0,REPO		;REPEAT ONCE
REPEA2:	CALL GCHARQ		;GET STARTING "<"
	CALL COMTST		;[425] IGNORE COMMENTS
	SKIPN COMSW		;[425] INSIDE A COMMENT?
	CAIG C," "		;[373] TEXT FORMATTING CHARACTER?
	JRST REPEA2		;[373] YES, GET NEXT
	CAIE C,"<"		;[373] "<"?
	JRST REPMAB		;[373] NO, ERROR
	CALL SKELI1		;INITIALIZE SKELETON
	PUSH MP,REPEXP
	MOVEM AC0,REPEXP
	PUSH MP,REPPNT		;STACK PREVIOUS REPEAT POINTER
	MOVEM ARG,REPPNT	;STORE NEW POINTER
	TDZA SDEL,SDEL		;YES, INITIALIZE BRACKET COUNT AND SKIP

REPEA4:	CALL WCHARQ		;WRITE A CHARACTER
	CALL GCHARQ		;GET A CHARACTER
	CAIN C,"<"		;"<"?
	AOJA SDEL,REPEA4	;YES, INCREMENT AND WRITE
	CAIE C,">"		;">"?
	JRST REPEA4		;NO, WRITE THE CHARACTER
	SOJGE SDEL,REPEA4	;YES, WRITE IF NON-NEGATIVE COUNT
	MOVSI CS,(BYTE (7) 177,3) ;SET "REPEAT" END
	CALL WWRXE		;WRITE END
	SKIPE NESTED		;[443] NESTED?
	JRST REPEA5		;[443] YES, REST OF LINE, SINCE SOMETHING ELSE MAY END HERE
	BYPASS
	CALL STOUTS		;POLISH OF LINE BEFORE PROCESSING REPEAT
REPEA5:	PUSH MP,MRP		;STACK PREVIOUS READ POINTER
	PUSH MP,RCOUNT		;SAVE WORD COUNT
	HRRZ MRP,REPPNT		;SET UP READ POINTER
	ADDI MRP,1		;[443] BYPASS ARG COUNT
	SKIPE NESTED		;[443] NESTED?
	JRST REPEA8		;[443] YES
	JRST POPOUT		;[443] NO 

REPEA7: HRRZ MRP,REPPNT		;SET UP READ POINTER
	ADDI MRP,1		;BYPASS ARG COUNT
REPEA8:	MOVEI C,LF
	JRST RSW2

REPEND:	SOSL REPEXP
	JRST REPEA7
	HRRZ V,REPPNT		;GET START OF TREE
	CALL REFDEC		;DECREMENT REFERENCE
	POP MP,RCOUNT
	POP MP,MRP
	POP MP,REPPNT
	POP MP,REPEXP
	SKIPE NESTED		;[443] NESTED?
	JRST RSW0		;YES, FINISH OF LINE NOW
	JRST REPEA8

REPMAB:	HRROI RC,[SIXBIT \MBR MISSING OPEN ANGLE BRACKET FOR REPEAT @\]
	JUMP1 .+2		;[373] ONLY COUNT ERROR ON PASS 2
	AOS ERRCNT		;[373] INCREMENT ERROR COUNT
	JRST ERRNE0		;[373] COMMON MESSAGE


REPZ:	FORERR (SDEL,REP)
	PUSH P,IO		;SAVE STATE OF IOPROG
	SETOM INREP
REPZ0:	CALL GCHAR		;[425] GET STARTING <
	CALL COMTST		;[425] IGNORE COMMENTS
	SKIPN COMSW		;[425] INSIDE A COMMENT?
	CAIG C," "		;[425] TEXT-FORMATING CHAR?
	JRST REPZ0		;[425] YES, GET NEXT
	CAIE C,"<"		;[425] <?
	JRST CORMAB		;[425] NO, ERROR
	MOVEI SDEL,1		;[425] SET COUNT
REPZ1:	CALL GCHAR		;GET NEXT CHARACTER
	CAIG C,FF		;END OF LINE?
	CAIGE C,LF
	JRST REPZ3		;NO
	SKIPE IFXLSW		;YES, XLISTING IN IF?
	TLO IO,IOPROG		;YES, DO IT
REPZ3:	CAIN C,"<"		;"<"?
	AOJA SDEL,REPZ1		;YES, INCREMENT COUNT
	CAIN C,">"		;">"?
	SOJLE SDEL,REPZ2	;YES, EXIT IF MATCHING
	JRST REPZ1		;NO, RECYCLE
REPZ2:	POP P,AC1		;RECOVER ORIGINAL IOPROG
	TLNN AC1,IOPROG		;ORIGINALLY 0?
	TLZ IO,IOPROG		;YES, RESTORE IT
	SETZM INREP		;FLAG OUT OF IT
	SETZM INCND		;AND CONDITIONAL ALSO
	JRST STMNT		;AND EXIT

REPO:	CALL GCHAR		;GET "<"
	CALL COMTST		;[425] IGNORE COMMENTS
	SKIPN COMSW		;[425] INSIDE A COMMENT?
	CAIG C," "		;[425] TEXT-FORMATTING CHAR?
	JRST REPO		;[425] YES, GET NEXT
	CAIE C,"<"		;[425] <?
	JRST CORMAB		;[425] NO, ERROR
	SKIPE RPOLVL		;ARE WE NESTED?
	AOS RPOLVL		;YES, DECREMENT CURRENT
	PUSH MP,RPOLVL
	SETOM RPOLVL
	JRST STMNT

REPO1:	CAIN C,"<"
	SOS RPOLVL
	CAIN C,">"
	AOSE RPOLVL
	JRST RSW2
	POP MP,RPOLVL
	CALL RSW2
	JRST RSW0

CORMAB:	HRROI RC,[SIXBIT /MBC MISSING OPEN ANGLE BRACKET FOR CONDITIONAL OR REPEAT@/] ;[425]
	JUMP1 .+2		;[425] ONLY COUNT ERROR ON PASS2
	AOS ERRCNT		;[425] INCREMENT ERROR COUNT
	JRST ERRNE0		;[425] COMMON MESSAGE
COMTST:	CAIG C,FF		;[425] SEARCH FOR END OF LINE
	CAIGE C,LF		;[425] LF, VT OR FF?
	JRST .+2		;[425] WASN'T ANY OF THEM
	SETZM COMSW		;[425] RESET COMMENT SWITCH
	CAIN C,";"		;[425] COMMENT?
	SETOM COMSW		;[425] YES, SET COMMENT SWITCH
	RET			;[425]


	SUBTTL MACRO PROCESSOR

	COMMENT \
THE FOLLOWING IS A PARTIAL DESCRIPTION OF THE DATA STRUCTURES USED
BY THE MACRO PROCESSOR.  

FREE STORAGE IS OBTAINED IN GROUPS OF .LEAF (4 PRESENTLY) WORDS.
SUCH A BLOCK IS CALLED A 'LEAF' AND IS FORMATTED AS FOLLOWS FOR
STORING TEXT:

	!-------------------------------------------!
	!  LINK TO NEXT LEAF   !//! CHAR 0 ! CHAR 1 !
	!-------------------------------------------!
	!  CHAR 2 ...				    !
	!-------------------------------------------!
	!					    !
	!-------------------------------------------!
	!					    !
	!-------------------------------------------!

THE FIRST LEAF OF A MACRO DEFINITION CONTAINS SOME ADDITIONAL INFORMATION
ABOUT THE MACRO:
  1. DEFAULT ARGUMENT POINTER
  2. ARGUMENT COUNT
  3. REFERENCE COUNT

	!-------------------------------------------!
	!   LINK	      !			    !
	!-------------------------------------------!
	! DEF ARG PTR         !    ARG CNT ! REF CNT!
	!-------------------------------------------!
	! CHAR 0 ! CHAR 1 ! ...			    !
	!-------------------------------------------!
	!					    !
	!-------------------------------------------!

THE FIRST LEAF OF A MACRO ARGUMENT ALSO CONTAINS A REF COUNT:

	!-------------------------------------------!
	!  LINK		      !			    !
	!-------------------------------------------!
	!		      !      1    ! REF CNT !
	!-------------------------------------------!
	!					    !
	!-------------------------------------------!
	!					    !
	!-------------------------------------------!

MP - POINTER TO STACK USED FOR REPEATS
RP - POINTER TO STACK USED FOR MACRO CALLS
MACPNT - POINTER TO LIST OF ARG POINTERS (I.E. RP AT FIRST ARG)

A MACRO CALL PRODUCES THE FOLLOWING STACK FRAME:

MACPNT/ ---)    PTR TO MACRO DEFINITION BODY
		ARG 1
		ARG 2
		..
		0
		OLD MACPNT
		OLD C
		OLD RCOUNT
RP/ ---)	OLD MRP

IRP VARIABLES:

  IRPARP	POINTER TO ORIGINAL MACRO ARG
  IRPCF		B0: 0=IRP, 1=IRPC
  IRPSW
  IRPARG	ORIGINAL MACRO ARG
  IRPCNT	READ COUNT
  IRPPOI	ORIGIN OF BODY OF IRP RANGE
\				;END OF COMMENT

DEFIN0:	SKIPN UWVER	;[454] WRITING UNV FILE?
	JRST DEF01		;[454] NO
	BITON UMAD,UWVER	;[454] MACRO ARG DEF VALUE FIXED BIT
DEF01:	CALL GETSYM		;GET MACRO NAME
	 JRST ERRAX		;EXIT ON ERROR
	MOVEM P,PPTMP1		;SAVE POINTER
	MOVEM AC0,PPTMP2	;SAVE NAME
	TLO IO,IORPTC
	FORERR (SX,DEF)
	SETOM INDEF		;AND FLAG IN DEFINE
	SETZB SX,.TEMP		;[425] SET ARGUMENT AND REFERENCE COUNT
	SETZM COMSW		;[425] AND COMMENT SWITCH
DEF02:	CALL GCHAR		;SEARCH FOR "(" OR "<"
	CALL COMTST		;[425] IGNORE COMMENTS
	SKIPE COMSW		;INSIDE A COMMENT?
	JRST DEF02		;YES, IGNORE CHARACTER
	CAIN C,"<"		;"<"?
	JRST DEF20		;YES
	CAIE C,"("		;"("?
	JRST DEF02		;NO
DEF10:	CALL GETSYM		;YES, GET DUMMY SYMBOL
	 TRO ER,ERRA		;FLAG ERROR
	ADDI SX,1		;INCREMENT ARG COUNT
	PUSH P,AC0		;STACK IT
	CAIN C,'<'		;A DEFAULT ARGUMENT COMING UP?
	JRST DEF80		;YES, STORE IT AWAY
	CAIE C,11		;")"?
	JRST DEF10		;NO, GET NEXT DUMMY SYMBOL
DEF12:	CALL GCHAR
	CALL COMTST		;[425] IGNORE COMMENTS
	SKIPN COMSW		;[425] SKIP IF INSIDE COMMENT
	CAIE C,"<"		;"<"?
	JRST DEF12		;NO
DEF20:	PUSH P,[0]		;YES, MARK THE LIST
	LSH SX,9		;SHIFT ARG COUNT
	AOS ARG,SX
	CALL SKELI		;INITIALIZE MACRO SKELETON
	MOVE AC0,PPTMP2		;GET NAME
	TLO IO,DEFCRS
	PUSH P,UNISCH+1		;MUST NOT SEARCH UNIVERSALS AT THIS POINT
	SETZM UNISCH+1		;OTHERWISE ORIGINAL DEFINITION WILL BE LOST
	CALL MSRCH		;SEARCH THE TABLE
	JRST DEF24		;NOT FOUND
	TLNN ARG,MACF		;FOUND, IS IT A MACRO?
	TROA ER,ERRX		;NO, FLAG ERROR AND SKIP
	CALL REFDEC		;YES, DECREMENT THE REFERENCE
DEF24:	POP P,UNISCH+1		;BACK AS IT WAS
	HRRZ V,WWRXX		;GET START OF TREE
	SKIPN .TEMP		;ANY DEFAULT ARGUMENTS TO TAKE CARE OF?
	JRST DEF25		;NO
	HRRZ C,1(V)		;GET SHIFTED ARG COUNT
	LSH C,-9		;GET ARG COUNT BACK
	ADDI C,1		;ONE MORE FOR TERMINAL ZERO

	ADD C,.TEMP		;NUMBER OF ITEMS IN STACK
	HRLS C			;MAKE XWD
	MOVE SDEL,.TEMP		;NUMBER OF WORDS NEEDED
	ADDI SDEL,1		;[341] PLUS THE 0 AT THE END
	ADDB SDEL,FREE		;FROM FREE CORE
	CAML SDEL,SYMBOL	;MORE CORE NEEDED
	CALL XCEEDS		;YES, TRY TO GET IT
	SUB SDEL,.TEMP		;FORM POINTER
	SUBI SDEL,1		;[341] MINUS THE 0
	SUB P,C			;[341] BACK UP STACK TO START OF ARGS
	HRLM SDEL,1(V)		;STORE IT WITH ARG COUNT IN MACRO
	SUBI SDEL,1		;TO USE FOR PUSHING POINTER INTO STORAGE
	MOVEI C,1(P)		;POINT TO START OF STACK
DEF26:	MOVE ARG,(C)		;GET AN ITEM OFF STACK
	TLNN ARG,-40		;A POINTER?
	JUMPN ARG,[PUSH SDEL,ARG ;YES, STORE IT
		AOJA C,DEF26]	;GET NEXT
	PUSH P,ARG		;RESTACK ARGUMENT
	SKIPE ARG		;FINISHED IF ZERO
	AOJA C,DEF26		;GET NEXT
	PUSH SDEL,ARG		;STORE ZERO IN DEFAULT LIST ALSO
DEF25:	MOVSI ARG,MACF
	MOVEM P,PPTMP2		;STORE TEMP STORAGE POINTER
	CALL INSERT		;INSERT/UPDATE
	TLZ IO,DEFCRS		;JUST IN CASE
	SETZM ARGF		;NO ARGUMENT SEEN
	SETZM SQFLG		;AND NO ' SEEN
	TDZA SDEL,SDEL		;CLEAR BRACKET COUNT
DEF30:	CALL WCHAR		;WRITE CHARACTER
DEF31:	CALL GCHAR		;GET A CHARACTER
DEF32:	MOVE CS,C		;GET A COPY
	CAIN C,";"		;IS IT A COMMENT
	JRST CPEEK		;YES CHECK FOR ;;
DEF33:	CAIG CS,"Z"+40		;CONVERT LOWER CASE
	CAIGE CS,"A"+40
	JRST .+2
	SUBI CS,40
	CAIGE CS,40		;TEST FOR CONTROL CHAR.
	JRST [SKIPN SQFLG	;HAS SINGLE QUOTE BEEN SEEN?
		JRST DEF30	;NO, OUTPUT THIS CHAR.
		PUSH P,C	;YES, SAVE CURRENT CHAR
		MOVEI C,47	;SET UP QUOTE
		CALL WCHAR	;WRITE IT
		POP P,C		;GET BACK CURRENT CHAR.
		SETZM SQFLG	;RESET FLAG
		JRST DEF30]	;AND CONTINUE 
	CAILE CS,77+40
	JRST DEF30		;TEST FOR SPECIAL
	MOVE CS,CSTAT-40(CS)	;GET STATUS BITS
	TLNE CS,6		;ALPHA-NUMERIC?
	JRST DEF40		;YES
	SKIPN SQFLG		;WAS A ' SEEN?
	JRST DEF36		;NO, PROCESH
	PUSH P,C		;YES, SAVE CURRENT CHARACTER
	MOVEI C,47		;AND PUT IN A '
	CALL WCHAR		;...
	POP P,C			;RESTORE CURRENT CHARACTER
	SETZM SQFLG		;AND RESET FLAG
DEF36:	CAIE C,47		;IS THIS A '?
	JRST DEF35		;NOPE
	SKIPN ARGF		;YES, WAS LAST THING SEEN AN ARG?
	SETOM SQFLG		;IF NOT, SET SNGL QUOT FLAG
	SETZM ARGF		;BUT NOT ARGUMENT IN ANY CASE
	JRST DEF31		;GO GET NEXT CHARACTER

DEF35:	SETZM ARGF		;THIS IS NOT AN ARGUMENT
	CAIN C,"<"		;"<"?
	AOJA SDEL,DEF30		;YES, INCREMENT COUNT AND WRITE
	CAIN C,">"		;">"?
	SOJL SDEL,DEF70		;YES, TEST FOR END
	JRST DEF30		;NO, WRITE IT

CPEEK:	TLNN IO,IOPALL		;IF LALL IS ON
	JRST DEF33		;JUST RETURN
	PUSH P,CS		;NEED TO SAVE CS, SINCE CHARAC MAY DESTROY IT
	CALL PEEK		;LOOK AT NEXT CHAR.
	POP P,CS		;RESTORE CS
	CAIN C,";"		;IS IT ;;?
	JRST CPEEK0		;[325] YES, GO SCAN LINE MATCHING ANGLE BRACKETS
	MOVE C,CS		;RESTORE C
	JRST DEF33		;AND RETURN

CPEEK0:	SETZM CPEEKC		;[325] CLEAR MATCHING ANGLE COUNTER
CPEEK1:	CALL GCHAR		;[325] GET A CHARACTER
	CAIN C,"<"		;[325] SEE IF LEFT ANGLE
	AOJA SDEL,CPEEKL	;[325] YES, GO ADD TO COUNT
	CAIN C,">"		;[325] SEE IF RIGHT ANGLE
	SOJA SDEL,CPEEKR	;[325] YES, GO SUBTRACT FROM COUNT
	CAIG C,CR		;[325] SEE IF AN
	CAIGE C,LF		;[325] END OF LINE CHARACTER
	JRST CPEEK1		;[325] NO, CONTINUE
CPEK1A:	SKIPL CPEEKC		;[347] YES, SEE IF UNMATCHED ANGLES
	JRST CPEEK3		;[332] NO, GO SEE IF END OF MACRO
	PUSH P,C		;[325] SAVE EOL CHARACTER
CPEEK2:	MOVEI C,">"		;[325] SET TO PUT IN SOME RIGHTS
	CALL WCHAR		;[325] GO DO ONE
	AOSGE CPEEKC		;[325] SEE IF ENOUGH
	JRST CPEEK2		;[325] NO, LOOP
	POP P,C			;[325] RECOVER EOL CHARACTER
CPEEK3:	JUMPL SDEL,DEF70	;[332] IF END OF MACRO, LEAVE COMPLETELY
	JRST DEF32		;[325] AND GET OUT OF LINE

CPEEKL:	AOS CPEEKC		;[325] ADD IN LEFT ANGLE BRACKET
	JRST CPEEK1		;[325] TO NEXT CHARACTER
CPEEKR:	JUMPL SDEL,CPEK1A	;[366] JUMP IF END OF MACRO
	SOS CPEEKC		;[325] [347] SUBTRACT OUT RIGHT BRACKET
	JRST CPEEK1		;[325] CONTINUE


DEF40:	MOVEI AC0,0		;CLEAR ATOM
	MOVSI AC1,(POINT 6,AC0)	;SET POINTER
DEF42:	PUSH P,C		;STACK CHARACTER
	TLNE AC1,770000		;HAVE WE STORED 6?
	IDPB CS,AC1		;NO, STORE IN ATOM
	CALL GCHAR		;GET NEXT CHARACTER
	MOVE CS,C
	CAIG CS,"Z"+40
	CAIGE CS,"A"+40
	JRST .+2
	SUBI CS,40		;CONVERT LOWER TO UPPER
	CAIL CS,40
	CAILE CS,77+40
	JRST DEF44		;TEST SPECIAL
	MOVE CS,CSTAT-40(CS)	;GET STATUS
	TLNE CS,6		;ALPHA-NUMERIC?
	JRST DEF42		;YES, GET ANOTHER
DEF44:	PUSH P,[0]		;NO, MARK THE LIST
	MOVE SX,PPTMP1		;GET POINTER TO TOP

DEF46:	SKIPN 1(SX)		;END OF LIST?
	JRST DEF50		;YES
	CAME AC0,1(SX)		;NO, DO THEY COMPARE?
	AOJA SX,DEF46		;NO, TRY AGAIN
	SUB SX,PPTMP1		;YES, GET DUMMY SYMBOL NUMBER
	LSH SX,4
	MOVSI CS,<(BYTE (7) 177,101)>(SX) ;SET ESCAPE CODE MACEND
	LSH AC0,-^D30
	CAIN AC0,5		;"%"?
	TLO CS,1000		;YES, SET CRESYM FLAG
	CALL WWORD		;WRITE THE WORD
	SETOM ARGF		;SET ARGUMENT SEEN FLAG
	SETZM SQFLG		;AND IGNORE ANY ' WAITING TO GET INTO STRING
DEF48:	MOVE P,PPTMP2		;RESET PUSHDOWN POINTER
	TLO IO,IORPTC		;ECHO LAST CHARACTER
	JRST DEF31		;RECYCLE

DEF50:
	SKIPN SQFLG		;HAVE WE SEEN A '?
	JRST DEF51		;NOPE
	MOVEI C,47		;YES, PUT IT IN
	CALL WCHAR		;...
	SETZM SQFLG		;AND CLEAR FLAG
DEF51:	MOVE C,2(SX)		;GET CHARACTER
	JUMPE C,DEF48		;CLEAN UP IF END
	CALL WCHAR		;WRITE THE CHARACTER
	AOJA SX,DEF51		;GET NEXT

DEF70:	MOVE P,PPTMP1		;RESTORE PUSHDOWN POINTER
	MOVSI CS,(BYTE (7) 177,1)
	CALL WWRXE		;WRITE END
	SETZM INDEF		;OUT OF IT
	JRST BYPAS1

; HERE TO STORE DEFAULT ARGUMENTS

DEF80:	AOS .TEMP		;COUNT ONE MORE
	CALL SKELI1		;INITIALIZE SKELETON
	HRL V,SX		;SYMBOL NUMBER
	PUSH P,V		;STORE POINTER
	TDZA SDEL,SDEL		;ZERO BRACKET COUNT
DEF81:	CALL WCHARQ		;WRITE A CHARACTER
	CALL GCHAR		;[470] GET A CHARACTER
	CAIN C,"<"		;ANOTHER "<"?
	AOJA SDEL,DEF81		;YES, INCREMENT AND WRITE
	CAIE C,">"		;CLOSING ANGLE?
	JRST DEF81		;NO, JUST WRITE THE CHAR.
	SOJGE SDEL,DEF81	;YES, WRITE IF NOT END
	MOVSI CS,(BYTE (7) 177,2)
	CALL WWRXE		;WRITE END OF DUMMY ARGUMENT
	CALL GCHAR		;READ AT NEXT CHAR.
	CAIE C,")"		;END OF ARGUMENT LIST?
	JRST DEF10		;NO, GET NEXT SYMBOL
	JRST DEF12		;YES, LOOK FOR "<"

SUBTTL MACRO CALL PROCESSOR
CALLM:	SKIPGE MACENL		;ARE WE TRYING TO RE-ENTER?
	JRST ERRAX		;YES, BOMB OUT WITH ERROR
	HRROS MACENL		;FLAG "CALLM IN PROGRESS"
	EXCH MP,RP
	PUSH MP,V		;STACK FOR REFDEC
	EXCH MP,RP
	MOVEM AC0,CALNAM	;SAVE MACRO NAME INCASE OF ERROR
	FORERR (SDEL,CAL)
	ADDI V,1		;POINT TO DUMMY SYMBOL COUNT
	AOS SDEL,0(V)		;INCREMENT ARG COUNT
	HLLZM SDEL,.TEMP	;DEFAULT ARG POINTER IF NON-ZERO
	LDB SX,[POINT 9,SDEL,26] ;GET ARG COUNT
	MOVEI SDEL,0		;INIT PAREN COUNTER
	SKIPE .TEMP		;IF AT LEAST ONE DEFAULT ARG
	HRRM SX,.TEMP		;STORE COUNT OF ARGS
	PUSH P,V		;STACK FOR MRP
	PUSH P,RP		;STACK FOR MACPNT
	JUMPE SX,MAC20		;TEST FOR NO ARGS
MAC13:	CALL CHARAC		;[313]
	SKIPN MACTAB		;[450] IF MACTAB=0..NEW ARG HANDLING V51
	JRST .+3		;[450] ASSUME ITABM=0
	SKIPE ITABM		;[313] NEW FORMAT ARG HANDLING?
	JRST MAC13A		;[313] NO, DON'T FLUSH TAB/SP
	CAIE C," "		;[313] FLUSH LEADING TABS AND SPACES
	CAIN C,HT		;[313]
	JRST MAC13		;[313]
MAC13A:	CAIE C,"("		;[313] "("
	TLOA SDEL,-1		; NO, FUDGE PAREN COUNT AND SKIP

MAC10:	CALL GCHAR		;GET A CHARACTER, LOOK FOR AN ARG
	JUMPGE SDEL,MAC11	; SKIP TEST IF IN ()
	CAIG C,CR
	CAIGE C,LF
	CAIN C,";"		;";"?
	JRST MAC21		;YES, END OF ARGUMENT STRING

MAC11:	SKIPN MACTAB		;[450] IF MACTAB=0..NEW ARG HANDLING V51
	JRST .+3		;[450] ASSUME ITABM=0
	SKIPE ITABM		;MAC51 ARG HANDLING?
	JRST MAC11A		;NO
	CAIE C," "		;YES, ELIMINATE LEADING TABS AND SPACES
	CAIN C,HT
	JUMPL SDEL,MAC10	;BUT ONLY IF NOT IN PARENS
MAC11A:	SKIPLE SX		; SKIP IF NO ARGS LEFT
	CALL SKELI1		;NO, INITIALIZE SKELETON
	CAIN C,"<"		;"<"?
	JRST MAC30		;YES, PROCESS AS SPECIAL
	CAIE C,176
	CAIN C,134		;"\"
	JRST MAC40		;YES, PROCESS SYMBOL
	; ..

MAC14:	CAIN C,","		;","?
	JRST MAC16		;YES; NULL SYMBOL
	JUMPGE SDEL,[CAIN C,"("	;[315] IF IN (), CHECK AND COUNT
		AOS SDEL	;[315] ..
		CAIN C,")"	;[315] ..
		SOJL SDEL,MAC16	;[315] JUMP IF END OF ARGLIST
		JRST MAC14B]	;[315] NO FURTHER CHECKS
	SKIPN MACTAB		;[450] IF MACTAB=0..NEW ARG HANDLING V51
	JRST .+3		;[450] ASSUME ITABM=0
	SKIPE ITABM		;[315] OLD FORMAT WANTED?
	JRST MAC14B		;[315] YES, NO FURTHER CHECKS
	CAIE C," "		;[315] SPACE OR TAB?
	CAIN C,HT		;[315]
	JRST MACTB		;[315] YES, GO SEE WHAT FOLLOWS
	SKIPE MACTAB		;NEW FORMAT DELIMITERS?
	JRST MAC14B		;NO
	CAIN C,42		;[507] A QUOTE MARK?
	JRST MAC12B		;[507] YES, GO QUOTE TIL ANOTHER QUOTE
	CAIN C,"<"		;OPEN ANG BKT?
	JRST MAC12		;YES, QUOTE TO CLOSE
	CAIE C,"("
	CAIN C,"["		;[313] CHECK FOR BKTS AND PARENS
	JRST MAC12		;[313] OPEN BKT, GO SCAN TO CLOSE BKT
	CALL SKPNTM		;CHECK FOR UNMATCHED TERMINATORS
	 JRST MAC9		;FOUND ONE, END OF ARG LIST
MAC14B:	SKIPLE SX		; IGNORE IF NO ARGS LEFT
	CALL WCHAR		;WRITE INTO SKELETON
MAC14A:	CALL CHARAC		;GET NEXT CHARACTER
	CAIE C,177		;[445] RUB-OUT?
	JRST MAC14E		;[445] NO,
	MOVSI CS,(BYTE (7) 177,5) ;[445] YES, A REAL RUBOUT, PUT INTO SKELETON
	CALL WWRXE		;[445] (177,5)
	JRST MAC14A		;[445]
MAC14E:	JUMPGE SDEL,MAC14	; IGNORE TEST IF IN ()
	CAIG C,CR
	CAIGE C,LF
	CAIN C,";"
	JRST MAC15
	JRST MAC14		;JUMP IF NOT END OF LINE

MAC9:	SETOM SDEL		;FORCE END OF ARG LIST
MAC15:	TLO IO,IORPTC
MAC16:	JUMPLE SX,MAC17		; SKIP IF NO ARGS LEFT
	MOVSI CS,(BYTE (7) 177,2)
	CALL WWRXE		;WRITE END
	EXCH MP,RP
	PUSH MP,WWRXX
	EXCH MP,RP
MAC17:	SUBI SX,1		; DECREMENT ARG COUNT
	JUMPGE SDEL,MAC10	; IF IN () KEEP LOOKING
	TRNN SDEL,1B18		; SKIP LOOKING IF SEEN ")"
	JUMPG SX,MAC10		; NO, BUT MORE ARGS TO COME


MAC20:	TLZN IO,IORPTC
	CALL CHARAC
MAC21:	EXCH MP,RP
	JUMPE SX,MAC21B		;NO MISSING ARGS
MAC21A:	PUSH MP,[-1]		;FILL IN MISSING ARGS
	SKIPN .TEMP		;ANY DEFAULT ARGS?
	JRST MAC21C		;NO
	HRRZ C,.TEMP		;GET ARG COUNT
	SUBI C,-1(SX)		;ACCOUNT FOR THOSE GIVEN
	HRLZS C			;PUT IN LEFT HALF
	HLRZ SDEL,.TEMP		;ADDRESS OF TABLE
MAC21D:	SKIPN (SDEL)		;END OF LIST
	JRST MAC21C		;YES
	XOR C,(SDEL)		;TEST FOR CORRECT ARG
	TLNN C,-1		;WAS IT?
	JRST MAC21E		;YES
	XOR C,(SDEL)		;BACK THE WAY IT WAS
	AOJA SDEL,MAC21D	;AND TRY AGAIN

MAC21E:	MOVEM C,(MP)		;REPLACE -1 WITH TREE POINTER
	AOS 1(C)		;INCREMENT REFERENCE
MAC21C:	SOJG SX,MAC21A
MAC21B:	PUSH MP,[0]		;SET TERMINAL
	HRRZ C,LIMBO
	TLNN IO,IOSALL		;SUPPRESSING ALL?
	JRST MAC23		;NO
	JUMPN MRP,MAC27		;IN MACRO?
	CALL SEMSRC		;CHECK FOR IMMEDIATE COMMENT
	  JRST MAC26		;NOT FOUND, CONTINUE
MAC22:	CALL CHARAC		;YES,GET IT INTO THE LBUF
	CAIG C,CR		;LESS THAN CR?
	CAIGE C,LF		;AND GREATER THAN LF?
	JRST MAC22		;NO GET ANOTHER
MAC26:	CALL DECLBP		;DECREMENT LINE BUFFER POINTER
MAC27:	HRLI C,-1		;SET FLAG
	JRST MAC25

MAC23:	TLZ IO,IOMAC		;[531] RESET LISTING FLAG
	MOVEI SX,"^"
	DPB SX,LBUFP		;SET ^ INTO LINE BUFFER
	JUMPAD MAC25		;BRANCH IF ADDRESS FIELD
	JUMPN MRP,MAC25		;BRANCH IF ALREADY IN A MACRO
	SKIPN LITLVL		; BRANCH IF WITHIN A LITERAL
	SKIPE RPOLVL		; OR IN A REPEAT
	JRST MAC25
	CALL RSW3		;OUTPUT C AGAIN (OVERWRITTEN BY "^")
	CALL SEMSRC		;LOOK FOR A COMMENT
	  JRST MAC24		;NO COMMENT CONTINUE
	CALL STOUT		;LIST COMMENT OR CR-LF
	TLNE IO,IOPALL		;MACRO EXPANSION SUPPRESSION?
	TLO IO,IOMAC		;  NO, SET TEMP BIT
	TDOA C,[-1]		;FLAG LAST CHARACTER
MAC24:	CALL DECLBP		;DECREMENT BYTE POINTER
MAC25:	PUSH MP,MACPNT
	POP P,MACPNT
	PUSH MP,C
	PUSH MP,RCOUNT		;STACK WORD COUNT
	PUSH MP,MRP		;STACK MACRO POINTER
	POP P,MRP		;SET NEW READ POINTER
	EXCH MP,RP
	AOS MACLVL
	HRRZS MACENL		;RESET "CALLM IN PROGRESS"
	JUMPOC STMNT2		;OP-CODE FIELD
	JRST EVATOM		;ADDRESS FIELD

;ROUTINE TO LOOK FOR A SEMICOLON, IGNORING SPACES AND TABS
; SKIP IF FOUND

	CALL CHARAC		;FETCH ANOTHER CHARACTER
SEMSRC:	CAIE C," "		;SPACE?
	CAIN C,HT		;OR TAB?
	JRST .-3		;YES, GET ANOTHER CHARACTER
	CAIN C,";"		;NO, SEMICOLON?
	AOS (P)			;YES, SKIP RETURN
	RET

;ROUTINE TO DEVREMENT BYTE POINTER LBUFP

DECLBP:	HRLZI SX,70000		;INCREASE P FIELD BY 1 BYTE
	ADDB SX,LBUFP
	JUMPGE SX,CPOPJ		;RETURN IF NO OVERFLOW
	HRLOI SX,347777		;OVERFLOW, BACKUP ONE WORD
	ADDM SX,LBUFP
	RET

;HERE WHEN ENCOUNTERED UNQUOTED TAB OR SPACE IN MACRO ARGUMENT.
;"LOOK AHEAD" TO SEE IF END OF ARG LIST COMING UP.
;IF ARG LIST END FOUND, FLUSH TRAILING TABS/SPACES, OTHERWISE
;KEEP THEM.  BUFFER TAB/SPACE STRING ON STACK.

MACTB:	MOVE AC2,P		;[315] SAVE CURRENT STACK PTR
	HRRZ AC1,AC2		;[315] CONSTRUCT BYTE PTR TO STACK
	HRLI AC1,(<POINT 7,0,34>) ;[315] ..
	MOVEI AC0,0		;[315] INIT CHAR COUNT
MACTB1:	TLNN AC1,(76B5)		;[315] NEED ANOTHER STACK WORD?
	PUSH P,[0]		;[315] YES, GET IT
	IDPB C,AC1		;[315] BUILD TEMP STRING
	AOS AC0			;[315] COUNT CHARS STORED
	CALL CHARAC		;[315] GET NEXT CHAR
	CAIE C," "		;[315] ANOTHER SPACE OR TAB?
	CAIN C,HT		;[315] ..
	JRST MACTB1		;[315] YES, KEEP SCANNING
	PUSH P,C		;[315] NO, SAVE IT
	CAIG C,CR		;[315] END OF LINE?
	CAIGE C,LF		;[315] ..
	CAIN C,";"		;[315] OR SEMICOLON?
	JRST MACTB2		;[315] YES, FLUSH TEMP STRING
	CAIE C,","		;END OF ARGUMENT?
	CALL SKPNTM		;OR ARG LIST TERMINATOR?
	 JRST MACTB2		;YES
	HRRZ AC1,AC2		;[315] NO, MUST KEEP TEMP STRING
	HRLI AC1,(<POINT 7,0,34>) ;[315] REINIT BYTE PTR
MACTB3:	ILDB C,AC1		;[315] COPY TEMP STRING TO SKELETON
	SKIPLE SX		;[315] UNLESS HAVE ALL ARGS NOW
	CALL WCHAR		;[315] ..
	SOJG AC0,MACTB3		;[315] ..
MACTB2:	POP P,C			;[315] RECOVER LAST CHAR
	MOVEM AC2,P		;[315] FLUSH TEMP STRING FROM STACK
	JRST MAC14E		;[315] CONTINUE PROCESSING

;TEST FOR UNMATCHED BRACKETING PAIR - TERMINATES ARG LIST IF NOT
;QUOTED.

SKPNTM:	SKIPE MACTAB		;NEW FORMAT DELIMITERS?
	JRST SKPNT1		;NO
	CAIE C,")"		;PAIRS ARE PARENS, BRACKETS, AND
	CAIN C,"]"		; ANG BKTS
	RET			;TERMINATOR, NOSKIP
	CAIN C,">"
	RET			;TERMINATOR, NOSKIP
SKPNT1:	AOS 0(P)		;NON-TERMINATOR, SKIP
	RET

;HERE ON OPEN ANG BKT AS FIRST CHAR IN ARG

MAC30:	MOVEI AC0,0		;INITIALIZE BRACKET COUNTER
MAC31:	CALL GCHAR		;GET A CHARACTER
	CAIN C,"<"		;"<"?
	ADDI AC0,1		;YES, INCREMENT COUNT
	CAIN C,">"		;">"?
	SOJL AC0,MAC14A		;YES, EXIT IF MATCHING
	SKIPLE SX		; IGNORE IF NO ARGS LEFT
	CALL WCHAR		;WRITE INTO SKELETON
	JRST MAC31		;GO BACK FOR ANOTHER

;HERE IF ENCOUNTERED UNQUOTED "<", "[", OR "(".  SCAN TO MATCHING
;CLOSE WITHOUT TERMINATING ARG.

MAC12:	MOVEI AC0,0		;[313] INIT BKT COUNT
	PUSH P,C		;SAVE CHAR
	CAIN C,"<"		;GET MATCHING CLOSE CHARACTER
	MOVEI C,">"
	CAIN C,"["
	MOVEI C,"]"
	CAIN C,"("
	MOVEI C,")"
	PUSH P,C		;SAVE TERMINATOR
	MOVE C,-1(P)		;GET ORIG CHAR
MAC12A:	SKIPLE SX		;[313] FLUSH CHAR IF NO ARGS LEFT
	CALL WCHAR		;[313] STOR CHAR
	CAMN C,-1(P)		;ANOTHER OPEN?
	AOS AC0			;[313] YES, COUNT UP
	CAMN C,0(P)		;A CLOSE?
	SOJLE AC0,[SUB P,[2,,2]	;YES. IF MATCH, CLEAR STACK
		JRST MAC14A]	;AND RESUME NORMAL SCAN
	CALL GCHAR		;[313] GET NEXT CHAR
	JRST MAC12A		;[313] CONTINUE SCAN

;HERE IF ENCOUNTERED UNQUOTED QUOTED MARK.
;SCAN TO ANOTHER QUOTE MARK WITHOUT TERMINATING ARG.

MAC12B:	PUSH P,C		;[507] SAVE THE QUOTE MARK
MAC12C:	SKIPLE SX		;[507] FLUSH CHAR IS NO ARGS LEFT
	CALL WCHAR		;[507] WRITE IT OUT
	CALL GCHAR		;[507] GET NEXT CHAR
	CAME C,0(P)		;[507] ANOTHER QUOTE MARK?
	JRST MAC12C		;[507] NO, LOOP
	SKIPLE SX		;[507] YES, DECIDE TO WRITE OR SKIP
	CALL WCHAR		;[507] WRITE QUOTE MARK OUT
	POP P,0(P)		;[507] CLEAR STACK
	JRST MAC14A		;[507] RESUME NORMAL SCAN


;HERE ON BACKSLASH AS FIRST CHAR IN ARG

MAC40:	PUSH P,SX		;STACK REGISTERS
	PUSH P,SDEL
	PUSH P,IO		;SAVE IO FLAGS
	CALL CELL		;GET AN ATOM
	MOVE V,AC0		;ASSUME NUMERIC
	TLNE IO,NUMSW		;GOOD GUESS?
	JRST MAC41		;YES
	CALL SSRCH		;SEARCH THE SYMBOL TABLE
	TROA ER,ERRX		;NOT FOUND, ERROR
MAC41:	CALL MAC42		;FORM ASCII STRING
	HLL IO,0(P)		;RESTORE IO FLAGS
	POP P,0(P)		;FLUSH TEMP
	POP P,SDEL
	POP P,SX
	TLO IO,IORPTC		;REPEAT LAST CHARACTER
	JRST MAC14A		;RETURN TO MAIN SCAN

MAC42:	JUMPLE SX,CPOPJ		; NO ARGS LEFT
	MOVE C,V
MAC44:	LSHC C,-^D35
	LSH CS,-1
	DIVI C,0(RX)		;DIVIDE BY CURRENT RADIX
	HRLM CS,0(P)
	JUMPE C,.+2		;TEST FOR END
	CALL MAC44
	HLRZ C,0(P)
	ADDI C,"0"		;FORM TEXT
	JRST WCHAR		;WRITE INTO SKELETON


MACEN0:	SOS MACENL
MACEND:	HRRZ C,0(P)		; GET TOP ADDRESS
	CAIN C,MAC14E		; WERE WE LOOKING FOR CLOSE PAREN?
	JUMPGE SDEL,MPAERR	; YES, GIVE USEFUL ERROR MESSAGE
	SKIPGE C,MACENL		;TEST "CALLM IN PROGRESS"
	AOS MACENL		;INCREMENT END LEVEL AND EXIT
	JUMPL C,REPEA8
	EXCH MP,RP
	POP MP,MRP		;RETRIEVE READ POINTER
	POP MP,RCOUNT		;AND WORD COUNT
	MOVEI C,"^"
	SKIPL 0(MP)		;TEST FLAG
	CALL RSW2		;MARK END OF SUBSTITUTION
	POP MP,C
	POP MP,ARG
	SKIPA MP,MACPNT		;RESET MP AND SKIP
MACEN1:	CALL REFDEC		;DECREMENT REFERENCE
MACEN2:	AOS V,MACPNT		;GET POINTER
	MOVE V,0(V)
	JUMPG V,MACEN1		;IF >0, DECREMENT REFERENCE
	JUMPL V,MACEN2		;IF <0, BYPASS
	POP MP,V		;IF=0, RETRIEVE POINTER
	CALL REFDEC		;DECREMENT REFERENCE
	MOVEM ARG,MACPNT
	EXCH MP,RP
	SOS MACLVL
	SKIPN MACENL		;CHECK UNPROCESSED END LEVEL
	JRST MACEN3		;NONE TO PROCESS
	TRNN MRP,-1		;MRP AT END OF TEXT
	JRST MACEN0		;THEN POP THE MACRO STACK NOW
MACEN3:	TRNN C,77400		;SALL FLAG?
	HRLI C,0		;YES,TURN IT OFF
	JUMPL C,REPEA8		;IF FLAG SET SUBSTITUTE
	JRST RSW2


IRP0:	SKIPN MACLVL		;ARE WE IN A MACRO?
	JRST ERRAX		;NO, BOMB OUT
IRP10:	CALL MREADS		;YES, GET DATA SPEC
	CAIE C,40		;SKIP LEADING BLANKS
	CAIN C,"("		;"("?
	JRST IRP10		;YES, BYPASS
	CAIE C,"<"		;
	CAIN C,11
	JRST IRP10
	CAIE C,177		;NO, IS IT SPECIAL?
	JRST ERRAX		;NO, ERROR
	CALL MREADS		;YES
	TRZN C,100		;CREATED?
	JRST ERRAX
	CAIL C,40		;TOO BIG?
	JRST ERRAX
	ADD C,MACPNT		;NO, FORM POINTER TO STACK
	PUSH MP,IRPCF		;STACK PREVIOUS POINTERS
	PUSH MP,IRPSW
	PUSH MP,IRPARP
	PUSH MP,IRPARG
	PUSH MP,IRPCNT
	PUSH MP,0(C)
	PUSH MP,IRPPOI

	HRRZM C,IRPARP
	MOVEM AC0,IRPCF		;IRPC FLAG FOUND IN AC0
	SETOM IRPSW		;RESET IRP SWITCH
	MOVE CS,0(C)
	MOVEM CS,IRPARG

IRP15:	CALL MREADS		;[351] GET A CHARACTER LOOKING FOR "<"
	CAIE C,"<"		;"<"?
	JRST [	CAIE C,","	;ALLOW COMMA
		CAIG C," "	;[351] ALLOW TEST FORMATTING CHARS
		JRST IRP15	;[351] IT WAS ONE, JUST GET ANOTHER
		CAIE C,")"	;[361] ALLOW )
		CAIN C,">"	;[354] ALLOW RIGHT ANGLE BRACKET
		JRST IRP15	;[354] GO BACK FOR ANOTHER
		JRST IRPMBI]	;[351] CAN'T FIND BRACKET, IT'S AN ERROR
	CALL SKELI1		;INITIALIZE NEW STRING
	MOVEM ARG,IRPPOI	;SET NEW POINTER

	TDZA SDEL,SDEL		;ZERO BRACKET COUNT AND SKIP
IRP20:	CALL WCHAR1
	CALL MREADS
	CAIN C,"<"		;"<"?
	AOJA SDEL,IRP20		;YES, INCREMENT COUNT AND WRITE
	CAIE C,">"		;">"?
	JRST IRP20		;NO, JUST WRITE IT
	SOJGE SDEL,IRP20	;YES, WRITE IF NOT MATCHING
	MOVE CS,[BYTE (7) 15,177,4]
	CALL WWRXE		;WRITE END
	PUSH MP,MRP		;STACK PREVIOUS READ POINTER
	PUSH MP,RCOUNT		;AND WORD COUNT
	SKIPG CS,IRPARG
	JRST IRPPOP		;EXIT IF NOT VALID ARGUMENT
	MOVEI C,1(CS)		;INITIALIZE POINTER
	MOVEM C,IRPARG


IRPSET:	EXCH MRP,IRPARG		;SWAP READ POINTERS
	MOVE SX,RCOUNT		;SWAP COUNT OF WORDS TO READ
	EXCH SX,IRPCNT
	MOVEM SX,RCOUNT
	CALL SKELI1		;INITIALIZE SKELETON FOR DATA
	HRRZM ARG,@IRPARP	;STORE NEW DS POINTER
	SETZB SX,SDEL		;ZERO FOUND FLAG AND BRACKET COUNT
	LDB C,MRP		;GET LAST CHAR
	CAIN C,","
	SKIPE IRPCF		;IN IRPC
	JRST IRPSE1		;NO
	MOVEI SX,1		;FORCE ARGUMENT
IRPSE1:	CALL MREADS
	CAIE C,177		;SPECIAL?
	AOJA SX,IRPSE2		;NO, FLAG AS FOUND
	CALL PEEKM		;LOOK AT NEXT CHARACTER
	SETZM IRPSW		;SET IRP SWITCH
	JUMPG SX,IRPSE4		;IF ARG FOUND, PROCESS IT
	JRST IRPPOP		;NO, CLEAN UP AND EXIT

IRPSE2:	SKIPE IRPCF		;IRPC?
	JRST IRPSE3		;YES, WRITE IT
	CAIN C,","		;NO, IS IT A COMMA?
	JUMPE SDEL,IRPSE4	;YES, EXIT IF NOT NESTED
	CAIN C,"<"		;"<"?
	ADDI SDEL,1		;YES, INCREMENT COUNT
	CAIN C,">"		;">"?
	SUBI SDEL,1		;YES, DECREMENT COUNT

IRPSE3:	CALL WCHAR
	SKIPN IRPCF		;IRPC?
	JRST IRPSE1		;NO, GET NEXT CHARACTER

IRPSE4:	MOVSI CS,(BYTE (7) 177,2)
	CALL WWRXE		;WRITE END
	MOVEM MRP,IRPARG	;SAVE POINTER
	MOVE MRP,RCOUNT		;SAVE COUNT
	MOVEM MRP,IRPCNT
	HRRZ MRP,IRPPOI		;SET FOR NEW SCAN
	AOJA MRP,REPEA8		;ON ARG COUNT

IRPMBI: CALL EFATAL		;[351] FATAL ERROR, TYPE ?MCR
	MOVE AC0,CALNAM		;[351] FETCH MACRO NAME
	SKIPN IRPCF		;[354] IRPC?
	JRST [	MOVSI RC,[	SIXBIT /MBI MISSING OPEN BRACKET FOR IRP INSIDE MACRO @/] ;[354] NO
		JRST IRPERR]	;[354]
	MOVSI RC,[	SIXBIT /MBI MISSING OPEN BRACKET FOR IRPC INSIDE MACRO @/] ;[351]
IRPERR: CALL TYPMSG		;[354] [351] OUTPUT MESSAGE
	JUMP1 .+2		;[351] ONLY COUNT ERROR ONCE
	AOS ERRCNT		;[351] DO DURING PASS 2
	JRST ERRNE2		;[351] COMMON MESSAGE


STOPI0:	SKIPN IRPARP		;IRP IN PROGRESS?
	JRST ERRAX		;NO, ERROR
	SETZM IRPSW		;YES, SET SWITCH
	RET

IRPEND:	MOVE V,@IRPARP
	CALL REFDEC
	SKIPE IRPSW		;MORE TO COME?
	JRST IRPSET		;YES

IRPPOP:	MOVE V,IRPPOI
	CALL REFDEC		;DECREMENT REFERENCE
	POP MP,RCOUNT
	POP MP,MRP		;RESTORE CELLS
	POP MP,IRPPOI
	POP MP,@IRPARP
	POP MP,IRPCNT
	POP MP,IRPARG
	POP MP,IRPARP
	POP MP,IRPSW
	POP MP,IRPCF
	JRST REPEA8


GETDS:				;GET DUMMY SYMBOL NUMBER
	MOVE CS,C		;USE CS FOR WORK REGISTER
	ANDI CS,37		;MASK
	ADD CS,MACPNT		;ADD BASE ADDRESS
	MOVE V,0(CS)		;GET POINTER FLAG
	JUMPG V,GETDS1		;BRANCH IF POINTER
	TRNN C,40		;NOT POINTER, SHOULD WE CREATE?
	JRST RSW0		;NO, FORGET THIS ARG
	PUSH P,WWRXX
	PUSH P,MWP		;STACK MACRO WRITE POINTER
	PUSH P,WCOUNT		;SAVE WORD  COUNT
	CALL SKELI1		;INITIALIZE SKELETON
	MOVEM ARG,0(CS)		;STORE POINTER
	MOVE CS,[BYTE (7) 0,170,170,170,171] ;CREATE A SYMBOL
	ADD CS,LSTSYM		;LSTSYM= # OF LAST CREATED
	TDZ CS,[BYTE (7) 0,170,170,170,170]
	MOVEM CS,LSTSYM
	IOR CS,[ASCII /.0000/]
	MOVEI C,"."
	CALL WCHAR
	CALL WWORD		;WRITE INTO SKELETON
	MOVSI CS,(BYTE (7) 177,2)
	CALL WWRXE		;WRITE END CODE
	POP P,WCOUNT		;RESTORE WORD COUNT
	POP P,MWP		;RESTORE MACRO WRITE POINTER
	POP P,WWRXX
	MOVE V,ARG		;SET UP FOR REFINC

GETDS1:	CALL REFINC		;INCREMENT REFERENCE
	HRL V,RCOUNT		;SAVE WORD COUNT
	PUSH MP,V		;STACK V FOR DECREMENT
	PUSH MP,MRP		;STACK READ POINTER
	MOVEI MRP,1(V)		;FORM READ POINTER
	JRST RSW0		;EXIT

DSEND:	POP MP,MRP
	POP MP,V
	HLREM V,RCOUNT		;RESTORE WORD COUNT
	HRRZS V			;CLEAR COUNT
	CALL REFDEC		;DECREMENT REFERENCE
	JRST RSW0		;EXIT


SKELI1:	MOVEI ARG,1		;ENTRY FOR SINGLE ARG
SKELI:	SETZ MWP,		;SIGNAL FIRST TIME THROUGH
	CALL SKELWL		;GET POINTER WORD
	HRRZM MWP,WWRXX		;SAVE FIRST ADDRESS
	HRRZM MWP,LADR		;SAVE START OF LINKED LIST
	HRRZM ARG,1(MWP)	;STORE COUNT
	SOS WCOUNT		;ACCOUNT FOR WORD
	HRRZ ARG,WWRXX		;SET FIRST ADDRESS
	ADDI MWP,2		;BUMP POINTER
	HRLI MWP,(POINT 7)	;SET FOR 5 ASCII BYTES
	;SKELW RETURNS WITH ADR OF NEXT FREE LOC IN V (RIGHT)

SKELW:	SOSLE WCOUNT		;STILL SOME SPACE IN LEAF?
	RET			;YES, RETURN
SKELWL:	SKIPE V,NEXT		;GET FIRST FREE ADDRESS
	JRST SKELW1		;IF NON-ZERO, UPDATE FREE
	MOVE V,FREE		;GET FREE
	ADDI V,.LEAF		;INCREMENT BY LEAF SIZE
	CAML V,SYMBOL		;OVERFLOW?
	CALL XCEED		;YES, BOMB OUT
	EXCH V,FREE		;UPDATE FREE
	SETZM (V)		;CLEAR LINK

SKELW1:	HLL V,0(V)		;GET ADDRESS
	HLRM V,NEXT		;UPDATE NEXT
	SKIPE MWP		;IF FIRST TIME
	HRLM V,1-.LEAF(MWP)	;STORE LINK IN FIRST WORD OF LEAF
	MOVEI MWP,.LEAF		;SIZE OF LEAF
	MOVEM MWP,WCOUNT	;STORE FOR COUNT DOWN
	MOVEI MWP,(V)		;SET UP WRITE POINTER
	TLO MWP,(POINT 7,,20)	;2 ASCII CHARS
	RET

	;WWRXX POINTS TO END OF TREE
	;MWP IDPB POINTER TO NEXT HOLE
	;NEXT FIRST OF A LINKED PORTION THAT IS NOT BEING USED (LEAVES)
	;FREE POINTS TO FREE CORE BETWEEN TREE AND SYM-TABLE
	;LADR POINTS TO BEG OF LINKED PORTION.


GCHARQ:	JUMPN MRP,MREADS	;IF GETTING CHAR. FROM TREE
GCHAR:	CALL CHARAC		;GET ASCII CHARACTER
	CAIG C,FF		;TEST FOR LF, VT OR FF
	CAIGE C,LF
	RET			;NO
	JRST OUTIM1		;YES, LIST IT

WCHARQ:
WCHAR:
WCHAR1:	TLNN MWP,760000		;END OF WORD?
	CALL SKELW		;YES, GET ANOTHER
	IDPB C,MWP		;STORE CHARACTER
	RET

WWORD:	LSHC C,7		;MOVE ASCII INTO C
	CALL WCHAR1		;STORE IT
	JUMPN CS,WWORD		;TEST FOR END
	RET			;YES, EXIT

WWRXE:	CALL WWORD		;WRITE LAST WORD
	ADD MWP,WCOUNT		;GET TO END OF LEAF
	SUBI MWP,.LEAF		;NOW POINT TO START OF IT
	HRRZS (MWP)		;ZERO LEFT HALF OF LAST LEAF
	HRRM MWP,@WWRXX		;SET POINTER TO END
	RET


MREAD:	CALL MREADS		;READ ONE CHARACTER
	CAIE C,177		;SPECIAL?
	JRST RSW1		;NO, EXIT
	CALL MREADS		;YES, GET CODE WORD
	TRZE C,100		;SYMBOL?
	JRST GETDS		;YES
	CAILE C,5		;[445] POSSIBLY ILLEGAL
	JRST ERRAX		;YUP
	HRRI MRP,0		;NO, SIGNAL END OF TEXT
	JRST .+1(C)
	CALL XCEED
	JRST MACEND		;1; END OF MACRO
	JRST DSEND		;2; END OF DUMMY SYMBOL
	JRST REPEND		;3; END OF REPEAT
	JRST IRPEND		;4; END OF IRP
	JRST RSW1		;[445] 5; RUBOUT

MREADI:	HRLI MRP,700		;SET UP BYTE POINTER
	MOVEI C,.LEAF-1		;NUMBER OF WORDS
	MOVEM C,RCOUNT
MREADS:	TLNN MRP,-1		;FIRST TIME HERE?
	JRST MREADI		;YES, SET UP MRP AND RCOUNT
	TLNN MRP,760000		;HAVE WE FINISHED WORD?
	SOSLE RCOUNT		;YES, STILL ROOM IN LEAF?
	JRST MREADC		;STILL CHAR. IN LEAF
	HLRZ MRP,1-.LEAF(MRP);YES, GET LINK
	HRLI MRP,(POINT 7,,20)	;SET POINTER
	MOVEI C,.LEAF		;RESET COUNT
	MOVEM C,RCOUNT
MREADC:	ILDB C,MRP		;GET CHARACTER
	TRNE MRP,-1		;[506] MACRO READ POINTER POINTS TO 0?
	RET
	JRST DECERR		;[506] CONFUSED WHILE EXPANDING--I.E.
				;[506] "[","(" WITH OUT ANGLE BRACKETS

PEEK:	JUMPN MRP,PEEKM		;THIS IS A MACRO READ
	CALL CHARAC		;READ AN ASCII CHAR.
	TLO IO,IORPTC		;REPEAT  FOR NEXT
	RET			;AND RETURN

PEEKM:	PUSH P,MRP		;SAVE MACRO READ POINTER
	PUSH P,RCOUNT		;SAVE WORD COUNT
	CALL MREADS		;READ IN A CHAR.
	POP P,RCOUNT		;RESTORE WORD COUNT
	POP P,MRP		;RESET READ POINTER
	RET			;IORPTC IS NOT SET


REFINC:	AOS 1(V)		;INCREMENT REFERENCE
	RET

REFDEC:	JUMPLE V,DECERR		;CATASTROPHIC ERROR SOMEWHERE
	SOS CS,1(V)		;DECREMENT REFERENCE
	TRNE CS,000777		;IS IT ZERO?
	RET			;NO, EXIT
	CAMGE V,UNITOP		; IS THIS IN UNIV AREA?
	JRST REFINC		;[371] YES, PUT IT BACK, DON'T DELETE
	HRRZ CS,0(V)		;YES, GET POINTER TO END
	HRL CS,NEXT		;GET POINTER TO NEXT RE-USABLE
	HLLM CS,0(CS)		;SET LINK
	HRRM V,NEXT		;RESET NEXT
	RET

DECERR:	CALL EFATAL		;OUTPUT CR-LF ? MCR
	MOVE AC0,CALNAM		;GET MACRO NAME
	MOVSI RC,[SIXBIT /EWE ERROR WHILE EXPANDING@/]
	CALL TYPMSG
	JUMP1 .+2		;[537] INCREMENT ERRCNT ON PASS2
	AOS ERRCNT		;[537]
	JRST ERRNE2		;COMMON MESSAGE

MPAERR:	CALL EFATAL		;OUTPUT CR-LF ? MCR
	MOVE AC0,CALNAM		;GET MACRO NAME
	MOVSI RC,[SIXBIT /MPA MISSING CLOSE PAREN AROUND ARG LIST OF@/]
	CALL TYPMSG
	JUMP1 .+2		;[537] INCREMENT ERRCNT ON PASS2
	AOS ERRCNT		;[537]
	JRST ERRNE2		;COMMON MESSAGE

A== 0				;ASCII MODE
AL== 1				;ASCII LINE MODE
IB== 13				;IMAGE BINARY MODE
B== 14				;BINARY MODE

;  ==   0			;USED BY HELPER AND GETSEGS
CTL== 1				;CONTROL DEVICE NUMBER
   IFN CCLSW,<CTL2==5>		;INPUT DEV FOR CCL FILE
BIN== 2				;BINARY DEVICE NUMBER
CHAR== 3			;INPUT DEVICE NUMBER
LST== 4				;LISTING DEVICE NUMBER
UNV== 6				;SYMBOL TABLE FILE (UNIVERSAL)

;	COMMAND STRING ACCUMULATORS

ACDEV== 1			;DEVICE
ACFILE==2			;FILE
ACEXT== 3			;EXTENSION
ACPPN== 4			;PPN
ACDEL== 4			;DELIMITER
ACPNTR==5			;BYTE POINTER

TIO== 6

TIORW== 1000
TIOLE== 2000
TIOCLD==20000

DIRBIT==4			;DIRECTORY DEVICE
TTYBIT==10			;TTY
MTABIT==20			;MTA
DTABIT==100			;DTA
DISBIT==2000			;DISPLAY
CONBIT==20000			;CONTROLING TTY
LPTBIT==40000			;LPT
DSKBIT==200000			;DSK

;GETSTS ERROR BITS

IOIMPM==400000			;IMPROPER MODE (WRITE LOCK)
IODERR==200000			;DEVICE DATA ERROR
IODTER==100000			;CHECKSUM OR PARITY ERROR
IOBKTL== 40000			;BLOCK TOO LARGE
ERRBIT==IOIMPM!IODERR!IODTER!IOBKTL

SYN .TEMP,PPN

SUBTTL I/O ROUTINES
BEG:
   IFN CCLSW,<TLZA IO,ARPGSW	;DON'T ALLOW RAPID PROGRAM GENERATION
	TLO IO,ARPGSW>		;ALLOW RAPID PROGRAM GENERATION
   IFN PURESW,<
	MOVE MRP,[XWD LOWL,LOWL+1] ;START OF DATA
	SETZM LOWL		;ZERO FIRST WORD
	BLT MRP,LOWEND		;AND THE REST
	MOVE MRP,[XWD LOWH,LOWL] ;PHASED CODE
	BLT MRP,LOWL+LENLOW>	;MOVE IT IN
	HRRZ MRP,.JBREL		;GET LOWSEG SIZE
	MOVEM MRP,MACSIZ	;SAVE CORE SIZE
				;DECODE VERSION NUMBER
	MOVEI P,JOBFFI		;TEMP PUSH DOWN STACK
	PUSH P,[0]		;MARK BOTTOM OF STACK
	LDB 0,[POINT 3,.JBVER,2] ;GET USER BITS
	JUMPE 0,GETE		;NOT SET IF ZERO
	ADDI 0,"0"		;FORM NUMBER
	PUSH P,0		;STACK IT
	MOVEI 0,"-"		;SEPARATE BY HYPHEN
	PUSH P,0		;STACK IT ALSO
GETE:	HRRZ 0,.JBVER		;GET EDIT NUMBER
	JUMPE 0,GETU		;SKIP ALL THIS IF ZERO
	MOVEI 1,")"		;ENCLOSE IN PARENS.
	PUSH P,1
GETED:	IDIVI 0,8		;GET OCTAL DIGITS
	ADDI 1,"0"		;MAKE ASCII
	PUSH P,1		;STACK IT
	JUMPN 0,GETED		;LOOP TIL DONE
	MOVEI 0,"("		;OTHER PAREN.
	PUSH P,0
GETU:	LDB 0,[POINT 6,.JBVER,17] ;UPDATE NUMBER
	JUMPE 0,GETV		;SKIP IF ZERO
	IDIVI 0,^D26		; MIGHT BE TWO DIGITS
	ADDI 1,"@"		;FORM ALPHA
	PUSH P,1
	JUMPN 0,GETU+1		;LOOP IF NOT DONE
GETV:	LDB 0,[POINT 9,.JBVER,11] ;GET VERSION NUMBER
	IDIVI 0,8		;GET DIGIT
	ADDI 1,"0"		;TO ASCII
	PUSH P,1		;STACK
	JUMPN 0,GETV+1		;LOOP
	MOVE 1,[POINT 7,VBUF+1,20] ;POINTER TO DEPOSIT IN VBUF
	POP P,0			;GET CHARACTER
	IDPB 0,1		;DEPOSIT IT
	JUMPN 0,.-2		;KEEP GOING IF NOT ZERO
   IFN FORMSW,<IFE DFRMSW,<
	SETOM PHWFMT>>		;HALF WORD UNLESS CHANGED BY SWITCH

   IFN CCLSW,<
	TLZA IO,CRPGSW		;SET TO INIT NEW COMMAND FILE
M:	TLNN IO,CRPGSW>		;CURRENTLY DOING RPG?
   IFE CCLSW,<M:>
	RESET			;INITIALIZE PROGRAM
	SETZM LITLST		;NOLIST LITERALS INLINE UNLESS CHANGED
	SETZM BLSW
	SETZM IFXLSW
	SETZM MACPRF		;DEFAULT IS OLD WAY
	SETZM BINDEV		;CLEAR INCASE NOT USED NEXT TIME
	SETZM LSTDEV		;SAME REASON
	SETZM INDEV		;INCASE OF ERROR
   IFN TOPS20,<			; FOR LONG FILES
	SETZM DINDEV		; NO STICKY DEVICE
	SETZM DINDIR		; NO STICKY INPUT DIRECTORY
   >	HRRZ MRP,MACSIZ		;GET INITIAL SIZE
	CORE MRP,		;BACK TO ORIGINAL SIZE
	  JFCL			;SHOULD NEVER FAIL
	SETZB MRP,PASS1I
	MOVE [XWD PASS1I,PASS1I+1]
	BLT PASS2X-1		;ZERO THE PASS1 AND PASS2 VARIABLES
;   IFE TOPS20,<			;TOPS20 DEFAULT IS NEW WAY
;	SETOM MACTAB>		;TOPS10 DEFAULT IS OLD WAY
	MOVEI P,JOBFFI		;SET TEMP PUSH-DOWN POINTER
   IFN FORMSW,<
	MOVE CS,PHWFMT		;GET DEFAULT VALUE (PERMANENT)
	MOVEM CS,HWFMT>		;SET IT (TEMP) 
	MOVE CS,[POINT 7,DBUF,6] ;INITIALIZE FOR DATE
	MSTIME 2,		;GET TIME FROM MONITOR
	CALL TIMOUT		;TIME FORMAT OUTPUT
	DATE 1,			;GET DATE
	IBP CS			;PASS OVER PRESET SPACE
	CALL DATOUT		;DATE FORMAT OUTPUT
	MOVSI FR,P1!CREFSW
   IFN CCLSW,<TLNE IO,CRPGSW	;RPG IN PROGRESS?
	JRST GOSET		;YES, GO READ NEXT COMMAND
	TLNE IO,ARPGSW		;NO, RPG ALLOWED?
	JRST RPGSET		;YES, GO TRY
CTLSET:	RELEASE CTL2,>		;IN CASE OF LOOKUP FAILURE
   IFE CCLSW,<CTLSET:>
	MOVSI IO,IOPALL		;ZERO FLAGS
	INIT CTL,AL		;INITIALIZE USER CONSOLE
	SIXBIT /TTY/
	XWD CTOBUF,CTIBUF
	  EXIT			;NO TTY, NO ASSEMBLY
	MOVSI C,'TTY'
	DEVCHR C,		;GET CHARACTERISTICS
	TLNN C,10		;IS IT REALLY A TTY
	EXIT			;NO
	INBUF CTL,1		;INITIALIZE SINGLE CONTROL
	OUTBUF CTL,1		;BUFFERS
	CALL CRLF		;OUTPUT CARRIAGE RETURN - LINE FEED
	MOVEI C,"*"
	IDPB C,CTOBUF+1
	OUTPUT CTL,
	MOVE AC1,[POINT 7,CTLBUF] ;BYTE POINTER TO STORE COMMAND
	MOVEI AC2,1		; INITIALIZE CHARACTER COUNT
CTLS2:	SOSGE CTIBUF+2		;USUAL SOSG LOOP ON TTY INPUT
	INPUT CTL,		;GET NEXT BUFFER
	ILDB 0,CTIBUF+1		;GET CHARACTER
	CAIL AC2,CTLSIZ		;NUMBER OF CHARS. ALLOWED
	JRST COMERR		;COMMAND LINE TOO LONG
	CAIN 0,CZ		;TEST FOR ^Z
	JRST CZSTOP		;MONRET TYPE EXIT
	IDPB 0,AC1		;STORE CHAR.
	CAIE 0,33		;TEST FOR ALTMODE
	CAIG 0,FF		;TEST FOR EOL CHAR
	CAIGE 0,LF		;ONE OF FF, VT, OR LF
	AOJA AC2,CTLS2		;NOT END OF LINE YET
	MOVEM AC2,CTIBUF+2	;RESET CHAR. COUNT
	MOVE AC1,[POINT 7,CTLBUF] ;BYTE POINTER TO STORE COMMAND
	MOVEM AC1,CTIBUF+1	;RESET BYTE POINTER


   IFN CCLSW,<JRST BINSET	;BEGIN WITH BINARY FILE

RPGSET:
   IFN TEMP,<HRRZ 3,.JBFF	;GET START OF BUFFER AREA
	HRRZ 0,.JBREL		;GET TOP OF CORE
	CAIGE 0,200(3)		;WILL BUFFER FIT?
	JRST [ADDI 0,200	;NO, GET ENUF CORE
		CORE 0,		;CORE UUO
		JRST XCEED2	;FAILED, SO GIVE UP
		JRST .+1]	;CONTINUE
	HRRM 3,TMPFIL+1		;STORE IN TMPCOR UUO IOWD
	SOS TMPFIL+1		;MAKE IT THE PROPER IOWD FORMAT
	HRRM 3,CTLBLK+1		;DUMMY UP BUFFER HEADER
	MOVE 0,[2,,TMPFIL]	;SET UP FOR TEMP CORE READ
	TMPCOR			;READ AND DELETE FILE "MAC"
	  JRST RPGTMP		;NO SUCH FILE IN CORE TRY DISK
	ADD 3,0			;CALCULATE END OF BUFFER
	MOVEM 3,.JBFF		;FIX JOBFF SO FILE WONT BE KILLED
	IMULI 0,5		;CALCULATE CHARACTER COUNT
	ADDI 0,1		;SINCE SOSG HAPPENS AFTER NOT BEFORE
	MOVEM 0,CTLBLK+2	;SET UP CHAR CNT IN BUFFER HEADER
	MOVEI 0,440700		;SET UP BYTE POINTER IN HEADER
	HRLM 0,CTLBLK+1		;BUFFER HEADER NOW SET UP
	SETOM TMPFLG		;MARK THAT A TMPCOR UUO WAS DONE
	JRST RPGS2A		;CONTINUE IN MAIN STREAM
RPGTMP:	SETZM TMPFLG>		;JUST IN CASE
	INIT CTL2,AL		;LOOK FOR DISK
	SIXBIT /DSK/		;...
	XWD 0,CTLBLK		;...
	  JRST CTLSET		;DSK NOT THERE
	HRLZI 3,'MAC'		;###MAC
	MOVEI 3			;COUNT
	PJOB AC1,		;RETURNS JOB NO. TO AC1
RPGLUP:	IDIVI AC1,12		;CONVERT
	ADDI AC2,"0"-40		;SIXBITIZE IT
	LSHC AC2,-6		;
	SOJG 0,RPGLUP		;3 TIMES
	MOVEM 3,CTLBUF		;###MAC
	HRLZI 'TMP'		;
	MOVEM CTLBUF+1		;TMP
	SETZM CTLBUF+3		;PROG-PRO
	LOOKUP CTL2,CTLBUF	;COMMAND FILE
	  JRST CTLSET		;NOT THERE
	HLRM EXTMP		;SAVE THE EXTENSION

RPGS2:	INBUF CTL2,1		;SINGLE BUFFERED
RPGS2A:	INIT CTL,AL		;TTY FOR CONSOLE MESSAGES
	SIXBIT /TTY/		;...
	XWD CTOBUF,0		;...
	  EXIT			;NO TTY, NO ASSEMBLY
	OUTBUF CTL,1		;SINGLE BUFFERED
	MOVE .JBFF		;REMEMBER WHERE BINARY BUFFERS BEGIN
	MOVEM SAVFF		;...
	HRRZ .JBREL		;TOP OF CORE
	CAMLE MACSIZ		;SEE IF IT HAS GROWN
	MOVEM MACSIZ		;PREVENTS ADDRESS CHECK ON EXIT
	TLNE IO,CRPGSW		;ARE WE ALREADY IN RPG MODE?
	JRST M			;MUST HAVE COME FROM @ COMMAND, RESET

GOSET:	MOVSI IO,IOPALL!CRPGSW	;SET INITIAL FLAGS
	MOVEI CS,CTLSIZ		;MAXIMUM CHARS IN A LINE
	MOVE AC1,CTLBLK+2	;NUMBER OF CHARACTERS
	MOVEM AC1,CTIBUF+2	;SAVE FOR PASS 2
	MOVE AC1,[POINT 7,CTLBUF] ;WHERE TO STASH CHARS
	MOVEM AC1,CTIBUF+1	;...
GOSET1:	SOSG CTLBLK+2		;ANY MORE CHARS?
	CALL [IFN TEMP,<SKIPE TMPFLG ;TMPCOR UUO IN PROGRESS?
		   EXIT>	;YES EXIT
		   IN CTL2,	;READ ANOTHER BUFFERFUL
		     RET	;EVERYTHING OK, RETURN
		   STATO CTL2,20000 ;EOF?
		   JRST [HRROI RC,[SIXBIT /ECF ERROR READING COMMAND FILE@/]
			JRST ERRFIN] ;GO COMPLAIN
		   CALL DELETE	;CMD FILE
		   EXIT]	;EOF AND FINISHED
	ILDB C,CTLBLK+1		;GET NEXT CHAR
	MOVE RC,@CTLBLK+1	;CHECK FOR SEQUENCE NUMBERS
	TRNE RC,1		;...
	JRST [AOS CTLBLK+1	;SKIP OVER ANOTHER 5 CHARS
		MOVNI RC,5	;...
		ADDM RC,CTLBLK+2 ;...
		JRST GOSET1 ]	;GO READ ANOTHER CHAR
	JUMPE C,GOSET1		;IGNORE NULLS
	CAIE C," "		; IGNORE SPACES
	CAIN C,HT		; AND TABS
	JRST GOSET1		; ALSO, SAVES SPACE AND COMMAND ERROR
	IDPB C,CTIBUF+1		;STASH AWAY
	AOS CTIBUF+2		;INCREMENT CHAR. COUNT
	CAIE C,12		;LINE FEED OR
	CAIN C,175		;ALTMODE?
	JRST GOSET2		;YES, FINISHED WITH COMMAND
	CAIE C,176
	CAIN C,33
	JRST GOSET2		;ALTMODE.
	SOJG CS,GOSET1		;GO READ ANOTHER
	JRST COMERR		;GO COMPLAIN

GOSET2:	MOVEI C,12		;MAKE SURE THERE'S A LF
	IDPB C,CTIBUF+1		;...
	MOVEM AC1,CTIBUF+1	;SET POINTER TO BEGINNING
	AOS CTIBUF+2		;ADD I TO COUNT
	MOVE SAVFF		;RESET JOBFF FOR NEW BINARY
	MOVEM .JBFF		;...
	JRST BINSET

RPGS1:	CALL DELETE		;DELETE COMMAND FILE
IFE TOPS20,<			;FOR  SHORT FILES
	MOVEM ACDEV,RPGDEV	;GET SET TO INIT
	OPEN CTL2,RPGINI	;DO IT
	JRST EINIT		;ERROR
	MOVEM ACFILE,INDIR	;USE INPUT BLOCK
	MOVEM ACPPN,INDIR+3	;SET PPN 
	HLLZM ACEXT,INDIR+1	;SET FILE EXTENSION
	JUMPN ACEXT,RPGS1A	; EXPLICIT EXTENSION GIVEN, USE IT
   IFE STANSW,<MOVSI ACEXT,'CCL'> ;IF BLANK TRY CCL
   IFN STANSW,<MOVSI ACEXT,'RPG'> ;IF BLANK TRY RPG
	HLLZM ACEXT,INDIR+1	; STORE DEFAULT EXT
	LOOKUP CTL2,INDIR	;
	  SKIPA ACEXT,INDIR+1	; FAILED, PICKUP EXT AND ERROR CODE
	JRST RPGS1B		; SUCCESS
	TRNE ACEXT,-1		; CHECK FOR ERROR CODE OTHER THAN 0
	JRST RPGLOS		; YES, YOU LOSE
	SETZB ACEXT,INDIR+1	; TRY NULL EXT
RPGS1A:	LOOKUP CTL2,INDIR	;
	  JRST RPGLOS		; TOTAL FAILURE
>				;END OF TOPS20 EQ CONDITIONAL

IFN TOPS20,<			;FOR LONG FILES
	SKIPN FILNAM		;HAVE A NAME YET?
	CALL NAME1		;NO GO GET THE NAME
	 JFCL			;LET COMPT GENERATE THE ERROR
	MOVE ACPPN,[10,,RPGADR]	;TO GET THE FILE
	COMPT. ACPPN,		;GO GET IT
	 JRST RPGLOS		; NOT THERE
>				;END OF TOPS20 NE CONDITIONAL
RPGS1B:	HLRM ACEXT,EXTMP	; SAVE THE EXTENSION
	HLRZ .JBSA		;RESET JOBFF TO ORIGINAL
	MOVEM .JBFF
	TLO IO,CRPGSW		;TURN ON SWITCH SO WE RESET WORLD
	JRST RPGS2		;AND GO

RPGLOS:	RELEAS CTL2,0
	TLZ IO,CRPGSW		;STOPS IO TO UNASGD CHAN
	JRST ERRCF		;NO FILE FOUND
   >


BINSET:	CALL NAME1		;GET FIRST NAME
	  JRST BINSE3		;NO FILE HERE
	HLLZ ACEXT,ACEXT	;[461] DISALLOW NULL EXTENSION
   IFN CCLSW,<CAIN C,"!"	;WAS THIS AN IMPERATIVE?
	JRST NUNSET		;GET THEE TO A NUNNERY
	CAIN C,"@"		;CHECK FOR A NEW RPG FILE
	JRST RPGS1>
	TLNN FR,CREFSW		;CROSS REF REQUESTED?
	JRST LSTSE1		;YES, SKIP BINARY
   IFN TOPS20,<			; CODE FOR LONG FILE NAMES
	LDB ACDEV,[POINT 7,FILNAM,6] ;GET FIRST ASCII BYTE
	JUMPE ACDEV,[	CAIN C,"," ;IF NULL AND TERM WITH COMMA
			JRST LSTSET ;THEN GO READ LISTING FILE
			CAIN C,"_" ;IF NULL AND TERM WITH _
			JRST GETSEN ;THEN GO READ INPUT FILE
			JRST M]	;ELSE, START OVER
	CAIE C,CR		; NOT NULL. END IN CR?
	CAIN C,LF		; OR LF?
	JRST GETSET		; YES. IT IS AN INPUT FILE

   >				;END OF TOPS20 CONDITIONAL

   IFE TOPS20,<			; CONDITIONAL FOR TOPS10 FILES
	CAIN C,","		;COMMA?
	JUMPE ACDEV,LSTSET	;YES, SKIP BINARY IF NO DEVICE SPECIFIED
	CAIN C,"_"		;LEFT ARROW?
	JUMPE ACDEV,LSTSE1	;YES, SKIP BINARY IF NO DEVICE SPECIFIED
	JUMPE ACDEV,M		;IGNORE IF JUST CR-LF
   >				; END OF TOPS20 EQ CONDITIONAL
	TLO FR,PNCHSW		;OK, SET SWITCH
   IFN TOPS20,<			; CONDITIONAL FOR LONG FILES
	MOVE ACDEV,[10,,BINADR]	;COMPT. ARGS
	COMPT. ACDEV,		; DO UUO
	JRST EINIT1		;REL FILE OPEN ERROR
   >				; END OF CONDITIONAL NE TOPS20
   IFE TOPS20,<			; FOR SHORT FILES
	MOVEM ACDEV,BINDEV	;STORE DEVICE NAME
	MOVEM ACFILE,BINDIR	;STORE FILE NAME IN DIRECTORY
	JUMPN ACEXT,.+2		;EXTENSION SPECIFIED?
	MOVSI ACEXT,'REL'	;NO, ASSUME RELOCATABLE BINARY
	MOVEM ACEXT,BINDIR+1	;STORE IN DIRECTORY
	CAIE ACPPN,SFDADD	;[476] SFD?
	JRST BINSE4		;[476]
	MOVE ACPPN,[0,,BINSFD]	;[476] RESET POINTER AND
	MOVE AC0,[SFDADD,,BINSFD] ;[476] BLT TO APPROPRIATE BLOCK
	BLT AC0,BINSFD+2+.SFDLN ;[476]
BINSE4:	MOVEM ACPPN,BINDIR+3	;SET PPN
	OPEN BIN,BININI		;INITIALIZE BINARY
	  JRST EINIT		;ERROR
   >				; END OF EQ TOPS20 CONDITIONAL
   IFN TOPS20,<			;FOR LONG FILES
	SETZM FILNAM		; CLEARED
	MOVEI ACDEV,BIN		;CHANNEL
	MOVEM BINDEV		;FOR DEVCHR
   >
	TLZE TIO,TIOLE		;SKIP TO EOT
	MTEOT. BIN,
	TLZE TIO,TIORW		;REWIND REQUESTED?
	MTREW. BIN,		;YES
	JUMPGE CS,BINSE2	;BRANCH IF NO BACK-SPACE
	MTBSF. BIN,		;BACK-SPACE A FILE
	AOJL CS,.-1		;TEST FOR END
	MTWAT. BIN,
	STATO BIN,1B24		;LOAD POINT?
	MTSKF. BIN,		;NO, GO FORWARD ONE
BINSE2:	SOJG CS,.-1		;TEST FORWARD SPACING

	TLNE TIO,TIOCLD		;DIRECTORY CLEAR REQUESTED?
	UTPCLR BIN,		;YES, CLEAR IT
	OUTBUF BIN,2		;SET UP TWO RING BUFFER
BINSE3:	CAIN C,"_"
	JRST GETSET		;NO LISTING

LSTSET:	CALL NAME1		;GET NEXT DEVICE
	  JRST GETSET		;NO FILE HERE
	HLLZ ACEXT,ACEXT	;[461] DISALLOW NULL EXTENSION
LSTSE1:	CAIE C,"_"
	JRST ERRCM
   IFN TOPS20,<			; CONDITIONAL FOR LONG FILE NAMES
	SETZM LSTNAM		; NO DEFAULT LISTING NAME
	HRROI ACDEV,[ASCIZ /LST/] ;DEFAULT EXTENSION
	MOVEM ACDEV,LSTEXT	; TO ARG BLOCK
   >				; END OF NE CONDITIONAL
	TLNE FR,CREFSW		;CROSS-REF REQUESTED?
   IFE TOPS20,<			; FOR SHORT FILES
	JRST LSTSE2		;NO, BRANCH
	JUMPN ACDEV,.+2		;YES, WAS DEVICE SPECIFIED?
	MOVSI ACDEV,'DSK'	;NO, ASSUME DSK
	JUMPN ACFILE,.+2
	MOVE ACFILE,[SIXBIT /CREF/]
	JUMPN ACEXT,.+2
	MOVSI ACEXT,'CRF'
LSTSE2:	JUMPE ACDEV,GETSET	;FORGET LISTING IF NO DEVICE SPECIFIED
	MOVE AC0,ACDEV
   >				; END OF EQ TOPS20 CONDITIONAL

   IFN TOPS20,<			; FRO LONG FILES
	JRST [	LDB ACDEV,[POINT 7,FILNAM,6] ;GET FIRST ASCII BYTE
		JUMPE ACDEV,GETSET ;IF NONE, GO DO INPUT
		JRST LSTSE2]	;IF ONE, USE IT
	HRROI ACDEV,[ASCIZ /CREF/] ;XREF REQUESTED
	MOVEM ACDEV,LSTNAM	; SET UP DEFAULT NAME
	HRROI ACDEV,[ASCIZ /CRF/] ;EXTENSION NAME
	MOVEM ACDEV,LSTEXT	; TO ARG BLOCK
LSTSE2:	MOVE ACDEV,[10,LSTARG]	;COMPT. ARGS
	COMPT. ACDEV,		; OPEN FILE
	 JRST EINIT2		; BAD, LST FILE OPEN ERROR
	SETZM FILNAM		; MADE IT
	MOVEI AC0,LST
	MOVEM AC0,LSTDEV	; FOR OTHER GUYS
   >				; END OF CONDITIONAL
	DEVCHR AC0,		;GET CHARACTERISTICS
	TLNE AC0,LPTBIT!DISBIT!TTYBIT
	TLNE FR,CREFSW		; WAS CROSS-REF REQUESTED?
	AOSA OUTSW+0*TTYSW	;NO, ASSUME TTY
	JRST ERRCM		;YES, ERROR - CREF DEV MUST NOT BE LPT, DIS, OR TTY
	TLNE AC0,CONBIT		;CONTROLING TELETYPE LISTING?
	JRST GETSET		;YES, BUFFER ALREADY SET
	MOVEM ACDEV,LSTDEV	;STORE DEVICE NAME
	AOS OUTSW+0*LPTSW	;SET FOR LPT
   IFE TOPS20,<			; FOR SHORT FILES
	MOVEM ACFILE,LSTDIR	;STORE FILE NAME
	JUMPN ACEXT,.+2
	MOVSI ACEXT,'LST'
	MOVEM ACEXT,LSTDIR+1
	CAIE ACPPN,SFDADD	;[476] SFD?
	JRST LSTSE5		;[476]
	MOVE ACPPN,[0,,LSTSFD]	;[476] YES, REST POINTER AND
	MOVE AC0,[SFDADD,,LSTSFD] ;[476] BLT TO APPROPRIATE
	BLT AC0,LSTSFD+2+.SFDLN ;[476]
LSTSE5:	MOVEM ACPPN,LSTDIR+3	;SET PPN
	OPEN LST,LSTINI		;INITIALIZE LISTING OUTPUT
	  JRST EINIT		;ERROR
   >				; END OF EQ CONDITIONAL
	TLZE TIO,TIOLE
	MTEOT. LST,
	TLZE TIO,TIORW		;REWIND REQUESTED?
	MTREW. LST,		;YES
	JUMPGE CS,LSTSE3
	MTBSF. LST,
	AOJL CS,.-1
	MTWAT. LST,
	STATO LST,1B24
	MTSKF. LST,
LSTSE3:	SOJG CS,.-1
	TLNE TIO,TIOCLD		;DIRECTORY CLEAR REQUESTED?
	UTPCLR LST,		;YES, CLEAR IT
	OUTBUF LST,2		;SET UP A TWO RING BUFFER


   IFN TOPS20,<
GETSEN:	SETZM FILNAM		; INIT CODE FOR LONG FILES
   >
GETSET:	MOVEI 3,PDPERR
	HRRM 3,.JBAPR		;SET TRAP LOCATION
	MOVEI 3,1B19		;SET FOR PUSH-DOWN OVERFLOW
	APRENB 3,
	SOS 3,PDP		;GET PDP REQUEST MINUS 1
	IMULI 3,.PDP		;COMPUTE SIZE (50*<NUMBER OF /P'S +1>)
	HRLZ MP,3
	HRR MP,.JBFF		;SET BASIC POINTER
	MOVE P,MP
	SUB P,3
	MOVEM P,RP		;SET RP
	MOVEM P,SAVERP
	SUB P,3
   IFN POLISH,<
	MOVEM P,POLSTK		; SAVE INITIAL POLISH FIXUP STACK
	MOVEM P,POLPTR		; ONLY CHANGE IF STACK MOVES
	SUB P,3			;
   >
	ASH 3,1			;DOUBLE SIZE OF BASIC POINTER
	HRL P,3
	MOVEM P,SAVEPP
	MOVEM MP,SAVEMP
	SUBM P,3		;COMPUTE TOP LOCATION
	SKIPN UNITOP		;IF ANY UNIVERSALS HAVE BEEN SEEN
	JRST GETSE0		;NO
	HRRZS 3			;GET TOP OF BUFFERS AND STACKS
	CAMLE 3,UNISIZ		;HOPE ITS NOT BIGGER THAN UNIVERSAL ONE
	JRST UNIERR		;IT WAS, YOU LOSE
	SKIPA 3,UNITOP		;DON'T LOSE THEM
GETSE0:	HRRZM 3,UNISIZ		;STORE UNTIL A UNIVERSAL IS SEEN
	HRRZM 3,LADR		;SET START OF MACRO TREE
	HRRZM 3,FREE

GETSE1:	HRRZ .JBREL
	SUBI 1
	MOVEM SYMTOP		;SET TOP OF SYMBOL TABLE
	SUBI LENGTH		;SET POINTER FOR INITIAL SYMBOLS
	CAMLE LADR		;HAVE WE ROOM?
	JRST GETSE2		;YES

	HRRZ 2,.JBREL		;NO, TRY FOR MORE CORE
	ADDI 2,2000
	CORE 2,
	  JRST XCEED2		;NO MORE, INFORM USER
	JRST GETSE1		;TRY AGAIN

GETSE2:	MOVEM SYMBOL		;SET START OF SYMBOL TABLE
	HRLI SYMNUM
	BLT @SYMTOP		;STORE SYMBOLS
   IFN POLISH,<
	MOVE @SYMBOL		;SYMBOL COUNT
	MOVEM SGSCNT		; FOR THIS PSECT
   >
	CALL SRCHI		;INITIALIZE TABLE

; ;HERE TO TEST FOR CPU AND SET VALUE IN .CPU.
;PDP-6 = 1
;KA-10 = 2
;KI-10 = 3
;KL-10 = 4
	MOVEI V,1		;START WITH PDP-6
	JFCL 1,.+1		;CLEAR PC CHANGE FLAG
	JRST .+1		;THEN CHANGE PC
	JFCL 1,.PDP6.		;[330] IF FLAG ON, ITS A PDP6
	HRLOI 1,-2		;[330] CHECK FOR KA-10
	AOBJP 1,.KA10.		;[330] CHECK CARRY BETWEEN HALVES
	SETZ 1,			;[330] CLEAR AC
	BLT 1,0			;[330] AND TRY BLT, KI WILL BE 0 AND
	JUMPE 1,.KI10.		;[330] LK WILL HAVE 1,,1
;	JRST .KL10.		;[330]

.KL10.:	AOS V
.KI10.:	AOS V
.KA10.:	AOS V
.PDP6.:	MOVE AC0,['.CPU. ']
	CALL SSRCH		;SEE IF THERE ALREADY AND IF NOT
	  CALL [MOVSI ARG,SYMF!NOOUTF!SUPRBT
		SETZ RC,
		JRST INSERT]	;PUT IT IN TABLE

	GETPPN V,		;[405] GET LOGGED IN PPN
	  JFCL			;[405] ALT. RETURN
	MOVEM V,MYPPN		;[405] AND REMEMBER IR
; END OF EDIT
   IFN POLISH,<
	SETZM SGNMAX		;INIT TO ONE .PSECT
	SETZM SGNCUR		;IT IS THE CURRENT .PSECT
	SETZM SGNAME		;IT IS THE BLANK .PSECT
	MOVSI 1
	MOVEM SGRELC		;SET THE RELOCATION COUNTER
	SETZM SGATTR		;ZERO PSECT BRK AND ATTRS
	SETZM SGDMAX		;ONE .PSECT DEEP
	SETZM SGLIST		;IT IS THE BLANK .PSECT
   >
	MOVE [XWD CTIBUF+1,CTLSAV] ;SAVE CONTROL INPUT BUFFER
	BLT CTLS1		;FOR RESCAN ON PASS 2
	MOVSI 'DSK'		;SET INPUT TO TAKE DSK AS DEV
	MOVEM ACDEVX
	CALL COUTI		;INIT OUTPUT JUST IN CASE
	CALL INSET		;GET FIRST INPUT FILE
	  JRST GETSE3		;ERROR

   IFN CCLSW,<TLNE IO,CRPGSW	;BUT ONLY IF DOING RPG
	TTCALL 3,[ASCIZ /MACRO:/] >;PUBLISH COMPILER NAME
	MOVE CS,INDIR		;SET UP NAME OF FIRST FILE
	MOVEM CS,LSTFIL		;AS LAST PRINTED
	SETZM LSTPGN
	JRST ASSEMB		;START ASSEMBLY

GETSE3:	CALL ERRNE
	JRST ERRFIN

FINIS:	CLOSE BIN,		;DUMP BUFFER
	TLNE FR,PNCHSW		;PUNCH REQUESTED?
	CALL TSTBIN		;YES, TEST FOR ERRORS
	RELEAS BIN,
	CLOSE LST,
	SOSLE OUTSW+0*LPTSW	;LPT TYPE OUTPUT?
	CALL TSTLST		;YES, TEST FOR ERRORS
	RELEAS LST,
	RELEAS CHAR,
	OUTPUT CTL,0		;FLUSH TTY OUTPUT
	SKIPE UNIVSN		;SKIP IF NOT ASSEMBLING UNIVERSAL
	CALL UNISYM		;STORE SYMBOLS ETC. FIRST
	JRST M			;RETURN FOR NEXT ASSEMBLY

   IFN CCLSW,<
   IFE TOPS20,<			;FOR SHORT FILES
NUNSET:	JUMPN ACDEV,.+2
	MOVSI ACDEV,'SYS'	;USE SYS IF NONE SPECIFIED
	MOVEM ACDEV,RUNDEV
	MOVEM ACFILE,RUNFIL	;STORE FILE NAME
	SKIPN SFDADD		;ANY SFD'S?
	JRST NUNPP		;NO
	HRLI ACPPN,RUNSFD	;FORM BLT WORD
	MOVSS ACPPN		;BUT WRONG WAY ROUND
	BLT ACPPN,RUNSFD+2+.SFDLN
	MOVEI ACPPN,RUNSFD	;SET UP ADDRESS AGAIN
NUNPP:	MOVEM ACPPN,RUNPP	;IN PPN
	CALL DELETE		;COMMAND FILE
	SETZM RUNFIL+1		;LET MONITOR CHOOSE EXT
	SETZM RUNFIL+2		;CLEAR ALSO
	SETZM RUNPP+1		;ZERO CORE ARG
	MOVEI 16,RUNDEV		;XWD 0,RUNDEV
	TLNE IO,CRPGSW		;WAS RPG IN PROGRESS?
	HRLI 16,1		;YES. START NEXT AT C(.JBSA)+1

;REDUCE THE LOW SEGMENT TO 1K AND DELETE THE HIGH
;BEFORE THE RUN UUO, SAVES CORE AND TIME
	MOVE 1,[1,,RUNEND-1]	;DELETE HIGH & LOW
	MOVE 2,[RUNHI,,RUNLO]
	BLT 2,RUNDEV-1		;BLT CODE DOWN
	JRST RUNLO		;GO TO IT

RUNHI:	PHASE LOWL
RUNLO:! CORE 1,			;CUT DOWN TO 1K
	  JFCL			;TOO BAD
	RUN 16,			;DO "RUN DEV:NAME"
	  HALT			;SHOULDN'T RETURN. HALT IF IT DOES

RUNDEV:! BLOCK 1
RUNFIL:! BLOCK 3
RUNPP:!		BLOCK 2
RUNSFD:! BLOCK 3+.SFDLN
RUNEND:!
	DEPHASE
   >				; END OF CONDITIONAL
   IFN TOPS20,<			; FOR LONG FILES
NUNSET:	CALL DELETE		; GET RID OF COMMAND FILE
	MOVE ACDEV,[4,,RUNARG]	;FOR COMPT.
	COMPT. ACDEV,		; DO IT
	 HALT			; LET PA1050 COMPLAIN
   >				; END OF CONDITIONAL

DELETE:	HRRZ EXTMP		;IF THE EXTENSION
	CAIE 'TMP'		;IS  .TMP
	RET			;RETURN.
	CLOSE CTL2,		;DELETE
	SETZB 4,5		;THE COMMAND FILE.
	SETZB 6,7
	RENAME CTL2,4		;
	  JFCL
	RET
   >


INSET:	MOVEI JOBFFI		;POINTER TO INPUT BUFFER
	HRRM .JBFF		;INFORM SYSTEM OF BUFFER AREA
   IFN TOPS20,<			; FOR LONG FILES
	SKIPE FILNAM		; ALREADY HAVE A NAME?
	JRST INSET9		; YES. GO USE IT
   >
	CALL NAME2		;GET NEXT COMMAND NAME
	  RET			;ERROR RETURN IF NONE LEFT
INSET9:	AOS (P)			;SUCCESS
   IFE TOPS20,<			; FOR SHORT FILES
	MOVEM ACDEV,INDEV	;STORE DEVICE
	MOVEM ACFILE,INDIR	;STORE FILE IN DIRECTORY
	MOVEM ACPPN,INDIR+3	;STORE PPN BEFORE WE LOSE IT
	OPEN CHAR,INDEVI
   >				; END OF EQ TOPS20 CONDITIONAL
   IFN TOPS20,<			; FOR LONG FILES
	MOVE ACDEV,[10,,INARG]	;COMPT. ARGS
	COMPT. ACDEV,		; OPEN THE FILE
   >				; END OF NE TOPS20
	  JRST EINIT		;ERROR
   IFN TOPS20,<			;FOR LONG FILES
	MOVEI ACDEV,CHAR	; THE CHANNEL
	MOVEM ACDEV,INDEV	; FAKE THIS AS THE DEVICE CODE
   >
	DEVCHR ACDEV,		;TEST CHARACTERISTICS
	TLNN ACDEV,MTABIT	;MAG TAPE?
	JRST INSET3		;NO
	TLZN FR,MTAPSW		;FIRST MAG TAPE IN PASS 2?
	JRST INSET1		;NO
	TLNN TIO,TIORW		;YES, REWIND REQUESTED?
	SUB CS,RECCNT		;NO, PREPARE TO BACK-SPACE TAPE
INSET1:	AOS RECCNT		;INCREMENT FILE COUNTER
	ADDM CS,RECCNT		;UPDATE  COUNT
	TLZE TIO,TIOLE
	MTEOT. CHAR,
	TLZE TIO,TIORW		;REWIND?
	MTREW. CHAR,		;YES
	JUMPGE CS,INSET2
	MTBSF. CHAR,
	MTBSF. CHAR,
	AOJL CS,.-1
	MTWAT. CHAR,
	STATO CHAR,1B24
	MTSKF. CHAR,
INSET2:	SOJGE CS,.-1

INSET3:	INBUF CHAR,1
	MOVEI ACPNTR,JOBFFI
	EXCH ACPNTR,.JBFF
	SUBI ACPNTR,JOBFFI
	MOVEI ACDEL,NUMBUF*203+1
	IDIV ACDEL,ACPNTR
	INBUF CHAR,(ACDEL)
   IFN TOPS20,<			; FOR LONG FILES
	SETZM FILNAM		; CLEAR THIS FOR NEXT TRY
   >
   IFE TOPS20,<			; FOR SHORT FILES
	JUMPN ACEXT,INSET4	;TAKE USER'S EXTENSION IF NON-BLANK
	MOVSI ACEXT,'MAC'	;BLANK, TRY .MAC FIRST
	CALL INSETI
INSET4: CALL INSETI
	  JUMPE ACEXT,ERRCF	;ERROR IF ZERO
	TLNE ACDEV,TTYBIT	;TELETYPE?
	SETSTS CHAR,AL		;YES, CHANGE TO ASCII LINE

				;DO ALL ENTERS HERE FOR LEVEL D
	SKIPE ENTERS		;HAVE ENTERS BEEN DONE ALREADY?
   >				; END OF EQ TOPS20
	JRST ENTRDN		;YES, DON'T DO TWICE
	SKIPN ACEXT,LSTDEV	;IS THERE A LIST DEVICE?
	JRST BINSE5		;[533] NO SO DON'T DO ENTER
	SKIPE ACFILE,LSTDIR	;[533] GET FILE NAME INCASE OF ERROR
	JRST LSTSE4		;[533]
	DEVCHR ACEXT,		;[533]
	TLNE ACEXT,DIRBIT	;DOES IT HAVE A DIRECTORY?
	JRST LSTSE4		;YES, GIVE UP BEFORE HARM IS DONE
	SKIPE ACFILE,INDIR	;USE INPUT FILE NAME
	MOVEM ACFILE,LSTDIR	;TOO BAD IF ZERO ALSO
LSTSE4:	HLLZS ACEXT,LSTDIR+1	;[533] EXT ALSO
	ENTER LST,LSTDIR	;SET UP DIRECTORY
	  JRST ERRCL		;ERROR
BINSE5:	SKIPN ACEXT,BINDEV	;[533] A BINARY DEVICE THEN ?
	JRST ENTRDN		;NO
	SKIPE ACFILE,BINDIR	;[533] INCASE OF ERROR
	JRST BINSE6		;[533]
	DEVCHR ACEXT,		;[533]
	TLNE ACEXT,DIRBIT	;DOES IT HAVE A DIRECTORY?
	JRST BINSE6		;[533] YES, GIVE UP BEFORE HARM IS DONE
	SKIPE ACFILE,INDIR	;USE INPUT FILE NAME
	MOVEM ACFILE,BINDIR	;TOO BAD IF ZERO ALSO
BINSE6:	HLLZS ACEXT,BINDIR+1	;[533]
	ENTER BIN,BINDIR	;ENTER FILE NAME
	  JRST ERRCB		;ERROR

ENTRDN:	SETOM ENTERS		;MAKE SURE ONLY DONE ONCE
	MOVE CS,[POINT 7,DEVBUF]
	PUSH P,1		;SAVE THE ACCS
	PUSH P,2
	PUSH P,3
   IFE TOPS20,<			; FOR SHORT FILES
	SKIPN 2,INDIR		;GET INPUT NAME
	JRST FINDEV		;FINISHED WITH DEVICE
	SETZ 1,			;CLEAR FOR RECEIVING
	LSHC 1,6		;SHIFT ONE CHAR. IN
	ADDI 1,40		;FORM ASCII
	IDPB 1,CS		;STORE CHAR.
	JUMPN 2,.-4		;MORE TO DO?
   >				; END OF EQ TOPS20
   IFN TOPS20,<			; FOR LONF FILES
	MOVE 1,[3,,[	CHAR,,5	;GET FILE NAME
			-1,,BIGBUF
			1B8+1B11+1]] ;NAME AND EXTENSION
	COMPT. 1,		;GET THEM
	 JFCL
	MOVE 1,[POINT 7,BIGBUF]
DONME:	ILDB 2,1
	JUMPE 2,NOEXT		; ALL DONE THE NAME
	CAIN 2,"."		; TO THE EXT?
	JRST EXXT		; YES
	IDPB 2,CS		; STORE IT
	JRST DONME
EXXT:	MOVEI 3,HT		; SEPARATOR
	IDPB 3,CS		; FOR THE EXTENSION
DOEXT:	ILDB 2,1		;THE EXTENSION
	JUMPE 2,NOEXT
	IDPB 2,CS		; TO THE OUTPTU
	JRST DOEXT
NOEXT:	DMOVE 1,INRIB+3		; THE DATE
	DMOVEM 1,INDIR+1	; FOR YHE REST
	MOVEI 1,HT
	IDPB 1,CS
   >				; END OF CONDITIONAL
   IFE TOPS20,<
	MOVEI 1,HT		;SEPARATE BY TAB
	IDPB 1,CS
	HLLZ 2,INDIR+1		;GET EXT
	JUMPE 2,FINEXT		;NO EXT
	SETZ 1,
	LSHC 1,6		;SAME LOOP AS ABOVE
	ADDI 1,40
	IDPB 1,CS
	JUMPN 2,.-4
	MOVEI 1,HT
	IDPB 1,CS		;SEPARATE BY TAB
   >				; END OF CONDITIONAL
FINEXT:	LDB 1,[POINT 12,INDIR+2,35] ;GET LOW 12 BITS OF DATE
	LDB 2,[POINT 3,INDIR+1,20] ;GET HIGH 3 BITS OF DATE
	DPB 2,[POINT 3,1,23]	;MERGE TO BITS 
	JUMPE 1,FINDEV		;NO DATE?
	CALL DATOUT		;STORE IT
	LDB 2,[POINT 11,INDIR+2,23] ;GET CREATION TIME
	JUMPE 2,FINDEV		;NO TIME (DECTAPE)
	MOVEI 1," "		;SEPARATE BY SPACE
	IDPB 1,CS
	CALL TIMOU1		;STORE TIME
FINDEV:	SETZ 1,
	MOVEI 2,HT		;FINAL TAB
	IDPB 2,CS
	IDPB 1,CS		;TERMINATE FOR NOW
	POP P,3			;RESTORE ACCS
	POP P,2
	POP P,1
	SKIPN PAGENO		;IF FIRST TIME THRU
	JRST OUTFF		;START NEW PAGE
	SETZM PAGENO		;ON NEW FILE, RESET PAGES
	JRST OUTFF2		;DON'T START NEW PAGE UNLESS FF

INSETI:	HLLZM ACEXT,INDIR+1	;STORE EXTENSION
	MOVE ACPPN,INDIR+3	;SAVE PPN
	LOOKUP CHAR,INDIR
	  SKIPA ACEXT,INDIR+1	;GET ERROR CODE
	JRST CPOPJ1		;SKIP-RETURN IF FOUND
	TRNE ACEXT,-1		;ERROR CODE OF 0 IS FILE NOT FOUND
	JRST ERRCF		;FILE THERE BUT NOT READABLE
	SETZ ACEXT,		;CLEAR EXT AND TRY AGAIN
	MOVEM ACPPN,INDIR+3	;RESTORE PPN
	RET


REC2:	MOVS [CTIBUF+1,,CTLSAV]	;RESCAN CONTROL (FROM PASS1 END STMNT)
	BLT CTIBUF+2		;INPUT BUFFER
	MOVEI "_"
	HRLM ACDELX		;FUDGE PREVIOUS DELIMITER
	SETZM PASS2I
	MOVE [XWD PASS2I,PASS2I+1]
	BLT PASS2X-1		;ZERO PASS2 VARIABLES
	TLO FR,MTAPSW!LOADSW	;SET FLAGS 

GOTEND:	MOVE INDEV		;GET LAST DEVICE
	DEVCHR			;GET ITS CHARACTERISTICS
	TLNE 4			;TEST FOR DIRECTORY (DSK OR DTA)
	JRST EOT		;YES, SO DON'T WASTE TIME
	JRST .+3		;NO, INPUT BUFFER BY BUFFER
	IN CHAR,
	JRST .-1		;NO ERRORS
	STATO CHAR,1B22		;TEST FOR EOF
	JRST .-3		;IGNORE ERRORS

EOT:	CALL SAVEXS		;SAVE REGISTERS
	SETOM EOFFLG		;[417] GOING THRU EOF PROCEDURE
	CALL INSET		;GET THE NEXT INPUT DEVICE
	  JRST EOT0		;ERROR
	HRROI RC,[SIXBIT /EP1 END OF PASS 1]@/] ;ASSUME END OF PASS
	TLZN FR,LOADSW		;ZERO ONLY ON END OF PASS 1
	HRROI RC,[SIXBIT /LNF LOAD THE NEXT FILE]@/] ;NOT END OF PASS
	TLNE ACDEV,(1B13!1B15)	;WAS ALL THAT WORK NECESSARY?
	JRST RSTRXS		;NO
	CALL EINFO		;CR-LF [
	CALL TYPMSG		;YES

RSTRXS:	MOVSI RC,SAVBLK		;SET POINTER
	BLT RC,RC-1		;RESTORE REGISTERS
	MOVE RC,SAVERC		;RESTORE RC
	RET			;EXIT

SAVEXS:	MOVEM RC,SAVERC		;SAVE RC
	MOVEI RC,SAVBLK		;SET POINTER
	BLT RC,SAVBLK+RC-1	;BLT ALL REGISTERS BELOW RC
	RET			;EXIT

EOT0:	JUMP1 [TLON FR,LOADSW	;PRINT MESSAGE ONCE
		CALL ERRNE	;ON PASS1
		JRST EOT1]
	AOS ERRCNT		;COUNT AS ERROR
	TLO FR,LOADSW		;USED TO SIGNAL  POPJ RET FROM ERRNE
	CALL ERRNE		;PRINT ERROR MESSAGE
EOT1:	TLZ IO,IORPTC
	MOVE P,SAVEPP		;RESTORE STACKS
	MOVE MP,SAVERP
	MOVEM MP,SAVERP
	MOVE MP,SAVEMP
	AOBJN P,END01		;FAKE END SEEN

NAME1:	SETZM ACDEVX		;ENTRY FOR DESTINATION
NAME2:	SETZB ACDEV,INDIR+2	;ENTRY FOR SOURCE
	SETZB ACFILE,PPN	;CLEAR FILE AND PPN
	HLRZ ACDEL,ACDELX	;GET PREVIOUS DELIMITER
	SETZB TIO,CS
   IFE TOPS20,<			; FOR SHORT FILES
	SETZB ACEXT,INDIR+3	;RESET EXTENSION AND PROGRAM-NUMBER PAIR
	SETZM SFDADD		;CLEAR FIRST WORD OF SFD BLOCK
	MOVE AC0,[SFDADD,,SFDADD+1]
	BLT AC0,SFDADD+2+.SFDLN	;AND REST OF IT
NAME3:	MOVSI ACPNTR,(POINT 6,AC0) ;SET POINTER
   >				; END OF EQ TOPS20
   IFN TOPS20,<			; FOR LONG FILES
NAME3:	MOVE ACPNTR,[POINT 7,FILNAM] ;ASCII POINTER
	SETZ ACPPN,		; NOT IN A PPN TO START
   >
	SETZ AC0,		;CLEAR SYMBOL
	JRST GETIOC		;GO GET INPUT CHARACTER



SLASH:	SETO CS,		;[517] CS=-1 GET RID OF ALPHAS AT END
	CALL SW0
GETIOC:	CALL TTYIN		;GET INPUT CHARACTER
	CAIN C,"/"
	JRST SLASH
	CAIN C,"("
	JRST [	SETZ CS,	;[517] CS=0 EVERY CHAR COUNT
		JRST SWITCH]
   IFE TOPS20,<			; FOR SHORT FILES
	CAIN C,":"
	JRST DEVICE
	CAIN C,"."
	JRST NAME
   >				; END OF EQ TOPS20
	CALL TRMTST		;[524] TERMINATOR?
	JRST TERM		;YES,
   IFE TOPS20,<			; FRO SHORT FILES
	CAIE C,OBRCKT		; AN OPEN BROCKET?
	CAIN C,"["
	JRST PROGNP		;GET PROGRAMER NUMBER PAIR
   >				; END OF CONDITIONAL
   IFN TOPS20,<			; FOR LONG FILES
	CAIN C,","		;A COMMA?
	JUMPL ACPPN,INPPN	;YES. IN A PPN?
   >				; END OF EQ TOPS20
	CAIN C,"="		;EQUALS IS SAME AS LEFT ARROW
	TRCA C,142		;SO MAKE IT A "_" AND SKIP
	CAIE C,","
	CAIN C,"_"
	JRST TERM
	JUMPL C,TERME		;ERROR RETURN FROM TTYIN?
   IFE TOPS20,<			; FOR SHORT FILES
	CAIGE C,40		;VALID AS SIXBIT?
	JRST [CAIN C,CZ		;NO,IS IT ^Z
		JRST CZSTOP	;YES,EXIT FOR BATCH
		JRST GETIOC]	;JUST IGNORE
	CAIL C,"0"		;[460] ERROR IF NOT ALPHANUMERIC
	CAILE C,"Z"		;[460]
	JRST ERRCM		;[460]
	CAILE C,"9"		;[460]
	CAIL C,"A"		;[460]
	CAIA			;[460]
	JRST ERRCM		;[460]
	SUBI C,40		;CONVERT TO 6-BIT
	TLNE ACPNTR,770000	;HAVE WE STORED SIX BYTES?
	IDPB C,ACPNTR		;NO, STORE IT
	JRST GETIOC		;GET NEXT CHARACTER
   >				; END OF EQ TOPS20
   IFN TOPS20,<			; FOR LONG FILES
	CAIN C,"["		; START OF A PPN?
	SETOM ACPPN		; YES. REMEMBER THUIS
	CAIN C,"]"		; END OF A PPN?
	SETZ ACPPN,		; YES. REMEMBER THIS
	CAIN C,CZ		; ^Z?
	JRST CZSTOP		; YES
INPPN:	IDPB C,ACPNTR		; NO. SAVE BYTE
	JRST GETIOC		; AND GO GET MORE
   >				; END OF NE TOPS20

TRMTST:				;[524] TERMINATOR TEST
   IFN CCLSW,<CAIE C,"!"	;[524] IS CHAR AN IMPERATIVE?
	CAIN C,"@"		;[524]
	RET>			;[524] YES, GO DO IT
	CAIE C,33		;[524] CHECK FOR THREE FLAVORS OF ALT-MODE
	CAIN C,176		;[524] ...
	RET			;[524]
	CAIG C,CR		;[524] LESS THAN CR?
	CAIGE C,LF		;[524] AND GREATER THAN LF?
	CAIN C,175		;[524] OR 3RD ALTMOD
	RET			;[524]
	CAIN C,";"		;[524] SEMI-COLON?
	RET			;[524] YES,
	JRST CPOPJ1		;[524] NOT A TERMINATOR, SKIP RETURN


DEVICE:	JUMPN ACDEV,ERRCM	;ERROR IF ALREADY SET
	MOVE ACDEV,AC0		;DEVICE NAME
	JRST DEVNAM		;COMMON CODE

NAME:	JUMPN ACFILE,ERRCM	;ERROR IF ALREADY SET
	MOVE ACFILE,AC0		;FILE NAME
DEVNAM:	MOVE ACDEL,C		;SET DELIMITER
	JRST NAME3		;GET NEXT SYMBOL

TERME:	TLZA C,-1		;MAKE INTO 33 BUT GIVE ERROR RET
TERM:	AOS (P)			;GIVE SKIP RETURN ON VALID TERMINATOR
   IFN TOPS20,<			; FOR LONG FILES
	SETZ ACDEV,		; GET A NULL
	IDPB ACDEV,ACPNTR	; TIE OFF ASCII STRING
   >
	JUMPE ACDEL,TERM1	;IF NO PREVIOUS TERMINATOR, THEN FILENAME
	CAIN ACDEL,"_"		;...
	JRST TERM1		;...
	CAIE ACDEL,":"		;IF PREVIOUS DELIMITER
	CAIN ACDEL,","		;WAS COLON OR COMMA
TERM1:	MOVE ACFILE,AC0		;SET FILE
	CAIN ACDEL,"."		;IF PERIOD,
	HLLO ACEXT,AC0		;[461] SET EXTENSION
	HRLM C,ACDELX		;SAVE PREVIOUS DELIMITER
   IFN TOPS20,<RET>		; ALL DONE IF LONG FILES
	JUMPN ACDEV,.+2		;IF DEVICE SET USE IT
	SKIPA ACDEV,ACDEVX	;OTHERWISE USE LAST DEVICE
	MOVEM ACDEV,ACDEVX	;AND DEVICE
	SKIPN ACPPN,PPN		; PUT PPN IN RIGHT PLACE
	SKIPN PPPN		; DO WE HAVE A DEFAULT?
	JRST TERM2		; PPN IS SETUP

	MOVE ACPPN,[PSFD,,SFDADD] ; MOVE DEFAULT SFD
	BLT ACPPN,SFDE		;
	MOVE ACPPN,PPPN		; AND PPN
TERM2:	CAIN C,"!"		;IMPERATIVE?
	RET			;YES, DON'T ASSUME DEV
	JUMPE ACFILE,CPOPJ	;IF THERE IS A FILE,
	JUMPN ACDEV,.+2		;BUT NO DEVICE
	MOVSI ACDEV,'DSK'	;THEN ASSUME DISK
	RET			;EXIT

CZSTOP:	EXIT 1,			; MONRET
	JRST M			; CONTINUE


ERRCM:	HRROI RC,[SIXBIT /CME COMMAND ERROR@/]
	JRST ERRFIN

PROGNP:	CALL GETOCT		;GET AN OCTAL NUMBER IN RC
	SKIPN RC		;[405] IF ITS 0, USE
	HLRZ RC,MYPPN		;[405] USE LOGGED IN PROJECT NUMBER
	HRLZM RC,PPN		;STORE IT
	CAIE C,","		;MORE?
	JRST PPNTST		; NO, GIVE UP
	CALL GETOCT		;GET AN OCTAL NUMBER
	SKIPN RC		;[405] IF ITS 0, USE
	HRRZ RC,MYPPN		;[405] MY PROGRAMMER NUMBER
	HRRM RC,PPN		;STORE IT
	CAIE C,","		;SFD'S?
	JRST PPNTST		; NO
	MOVEI C,SFDADD		;POINT TO DDDSFD BLOCK
	EXCH C,PPN		;SWAP WITH PPN
	MOVEM C,SFDADD+2	;STORE IT
	MOVEI RC,SFDADD+3	;START OF SFD AREA
SFD1:	HRRZS RC		;CLEAR BYTE POINTER
	CAILE RC,SFDADD+2+.SFDLN
	JRST ERRCM		;PATH TOO LONG
	HRLI RC,(POINT 6)	;BYTE POINTER SETUP
SFD2:	CALL TTYIN		;GET CHAR
	CAIE C,">"		;ALT FORM
	CAIN C,"]"		;END?
	JRST PPNTST		; YES
	CALL TRMTST		;[524] OR TERMINATOR?
	 JRST PPNTST		;[524] YES
	CAIN C,","		;NEXT SFD
	AOJA RC,SFD1		;YES, INCREMENT STORE ADDRESS
	SUBI C,40		;CONVERT TO SIXBIT
	JUMPL C,ERRCM		;ERROR
	TLNE RC,770000		;SPACE IN WORD
	IDPB C,RC		;YES, STORE CHAR.
	JRST SFD2		;GET NEXT CHAR

GETOCT:	SETZ RC,		;START WITH ZERO
GETOC1:	CALL TTYIN
	CAIE C,","		;TEST FOR COMMA
	CAIN C,"]"		;AND CLOSE SQB
	RET			;YES, WEVE GOT SOMETHING
	CAIN C,">"		;ALSO ALT FORM
	RET
	CALL TRMTST		;[524]
	 RET			;[524]
   IFE STANSW,<
	CAIL C,"0"		;CHECK FOR VALID NUMBERS
	CAILE C,"7"
	JRST ERRCM		;NOT VALID
	LSH RC,3		;SHIFT PREVIOUS RESULT
	ADDI RC,-"0"(C)>	;ADD IN NEW NUMBER
   IFN STANSW,<LSH RC,6		;SHIFT PREVIOUS RESULT
	ADDI RC,-40(C)>		;PUT IN NEW CHARACTER
	JRST GETOC1		;GET NEXT CHARACTER

; HERE TO TEST FOR DEFAULT PPN
PPNTST:	SKIPN ACFILE		;SEEN FILE NAME YET?
	SKIPE AC0		;OR PENDING
	JRST PPNTS1		;[524] NO
	PUSH P,AC0		;GET AN AC
	MOVE AC0,PPN		;GET PPN
	MOVEM AC0,PPPN		;MAKE IT PERMANENT
	MOVE AC0,[SFDADD,,PSFD]
	BLT AC0,PSFDE		;SAME FOR SFDS
	POP P,AC0
PPNTS1:	CALL TRMTST		;[524]
	JRST TERM		;[524]
	JRST GETIOC
; END OF EDIT

SWITC0:	CALL SW1		;PROCESS CHARACTER
SWITCH:	CALL TTYIN		;GET NEXT CHARACTER
	CAIE C,")"		;END OF STRING?
	JRST SWITC0		;NO
	JRST GETIOC		;YES

SW0:	CALL TTYIN
SW1:	HRREI C,-"A"(C)		; CONVERT FROM ASCII TO NUMERIC
	JUMPL C,SEELPP		; NUMERIC VALUE MAYBE?
	CAILE C,"Z"-"A"		;WITHIN BOUNDS? (IS IT ALPHA?)
	JRST ERRCM		; NO, LT. Z, ERROR
	MOVE RC,[POINT 5,BYTAB]
	IBP RC
	SOJGE C,.-1		;MOVE TO PROPER BYTE
	LDB C,RC		;PICK UP BYTE
	JUMPE C,ERRCM		;TEST FOR VALID SWITCH
	CAIG C,SWTABT-SWTAB	;LEGAL ON SOURCE?
	JUMPL P,ERRCM		;NO, TEST FOR SOURCE
	LDB RC,[POINT 4,SWTAB-1(C),12]
	CAIN RC,IO
	SKIPN CTLSAV		;IF PASS2 OR IO SWITCH,
	XCT SWTAB-1(C)		;EXECUTE INSTRUCTION
	SKIPA			;[517]
	TLZ IO,IOSALL		;TAKE CARE OF /X
	JUMPN CS,SW2		;[517] DOING A SLASH? IF YES, JUMP
	RET

SW2:	SETZ CS,		;[517]
	CALL TTYIN		;[517] NEXT CHAR
	CAIL C,"A"		;[517]
	CAILE C,"z"		;[517]
	JRST CPOPJ1		;[517] SKIP RETURN, SO NOT TO DO ANOTHER TTYIN
	CAILE C,"Z"		;[517] HERE IS BETWEEN A AND z
	CAIL C,"a"		;[517] NOW, IS IT BETWEEN Z AND a?
	JRST SW2+1		;[517] NO, IT'S ALPHA
	JRST CPOPJ1		;[517] YES, NOT ALPHA, SKIT RETURN

HELP:	PUSH P,.JBFF		;SAVE REAL .JBFF
	MOVE 1,.JBREL		;USE JOBREL
	MOVEM 1,.JBFF		;SO HELPER DOESN'T DESTROY SYMBOL TABLE
	MOVE 1,['MACRO ']	;GET MACRO.HLP
	CALL .HELPR		;CALL HELPER
	POP P,.JBFF		;RESTORE JOBFF INCASE CCL MODE
	JRST M			;RESTART

; HERE FOR /nnL SWITCH TO SET LINES/PAGE

SEELPP:	ADDI C,"A"-"0"		;TO NUMERIC RANGE
	CAIG C,9		;IS IT
	JUMPGE C,.+2
	JRST ERRCM		;NO, BARF
	MOVE RC,C		;MOVE VALUE

SEELP1:	CALL TTYIN		;GET NEXT
	CAIG C,"9"		;IS IT NUMERIC
	CAIGE C,"0"		;...
	JRST SEELP2		;NO, CHECK END
	IMULI RC,^D10		;MAKE SPACE
	ADDI RC,-"0"(C)		;AND PUT DIGIT
	JRST SEELP1		;AND CONTINUE

SEELP2:	CAIE C,"L"		;END PROPERLY?
	JRST ERRCM		;NO, BARF
	SUBI RC,4		;EASIER FOR SYMBOL OUTPUT ROUTINES
	MOVEM RC,..LPP		;SAVE IN "READ-ONLY"
	RET			;ALL DONE

	DEFINE SETSW (LETTER,INSTRUCTION) < INSTRUCTION
J= <"LETTER"-"A">-7*<I=<"LETTER"-"A">/7>
	SETCOD \I,J>

	DEFINE SETCOD		(I,J)
	<BYTAB'I=BYTAB'I!<.-SWTAB>B<5*J+4>>

BYTAB0= 0			;INITIALIZE TABLE
BYTAB1= 0
BYTAB2= 0
BYTAB3= 0

SWTAB:
	SETSW Z,<TLO TIO,TIOCLD >
	SETSW C,<TLZ FR,CREFSW >
	SETSW P,<SOS PDP		>
SWTABT:				;THE ABOVE SW'S ARE LEGAL ON OUTPUT ONLY
	SETSW A,<ADDI CS,1		>
	SETSW B,<SUBI CS,1		>
	SETSW E,<TLZ IO,IOPALL!IOSALL >
   IFN FORMSW,< SETSW F,<SETZM HWFMT>
		SETSW G,<SETOM HWFMT>>
	SETSW H,<JRST HELP>
	SETSW L,<TLZ IO,IOMSTR >
	SETSW M,<TLO IO,IOPALL!IOSALL >
	SETSW N,<HLLOS   TYPERR >
	SETSW O,<XCT OFFML		>
	SETSW Q,<TLO FR,ERRQSW >
	SETSW S,<TLO IO,IOMSTR >
	SETSW T,<TLO TIO,TIOLE >
	SETSW U,<SETOM UNVSKP		>
	SETSW W,<TLO TIO,TIORW >
	SETSW X,<TLOA IO,IOPALL >
   IFG .-SWTAB-37,<PRINTX SWITCH TABLE TOO LONG, CHANGE BYTE SIZE>

BYTAB:				;BYTAB CONTAINS AN INDEX TO SWTAB
				;IT CONSIST OF 7 5BIT BYTES/WORD
				;OR ONE BYTE FOR EACH LETTER

	+BYTAB0			;A-G BYTE = 1 THROUGH 17 = INDEX
	+BYTAB1			;H-N BYTE = 0 = COMMAND ERROR
	+BYTAB2			;O-U
	+BYTAB3			;V-Z

   IF2,<PURGE I,J,BYTAB0,BYTAB1,BYTAB2,BYTAB3>

TTYIN:	SOSGE CTIBUF+2		;ENUF CHAR.?
	JRST TTYERR		;NO
	ILDB C,CTIBUF+1		;GET CHARACTER
	CAIE C," "		;SKIP BLANKS
	CAIN C,HT		;AND TABS
	JRST TTYIN
	CAIN C,15		;CR?
	SETZM CTIBUF+2		;YES,IGNORE REST OF LINE
	CAIG C,"Z"+40		;CHECK FOR LOWER CASE
	CAIGE C,"A"+40
	RET			;NO,EXIT
	SUBI C,40
	RET			;YES, EXIT

COMERR:	HRROI RC,[SIXBIT /CTL COMMAND LINE TOO LONG@/]
	JRST ERRFIN

TTYERR:	SKIPN INDEV		;INPUT DEVICE SEEN?
	JRST ERRCM		;NO, SO MISSING "_"
	HRROI C,EOL		;SIGNAL ERROR
	RET			;AND RETURN

ERRNE:	HRROI RC,[SIXBIT /NES NO END STATEMENT ENCOUNTERED ON INPUT FILE@/]
ERRNE0:	CALL EFATAL		;OUTPUT CR-LF ?MCR
	CALL TYPMSG		;OUTPUT IT
	SKIPE LITLVL		;SEE IF IN LITERAL
	SKIPN LITPG		;PAGE 0 MEANS NOT IN A LITERAL REALLY
	JRST ERRNE1		;NO, TRY OTHERS
	MOVE V,[XWD [SIXBIT /IN LITERAL@/],LITPG]
	CALL PRNUM		;GO PRINT INFORMATION
ERRNE1:	MOVEI V,0		;CHECK FOR OTHER PLACES
	SKIPE INDEF
	MOVE V,[XWD [SIXBIT /IN DEFINE@/],DEFPG]
	SKIPE INTXT
	MOVE V,[XWD [SIXBIT /IN TEXT@/],TXTPG]
	SKIPE INREP
	MOVE V,[XWD [SIXBIT /IN CONDITIONAL OR REPEAT@/],REPPG]
	SKIPE INCND
	MOVE V,[XWD [SIXBIT /IN CONDITIONAL@/],CNDPG]
	SKIPGE MACENL
ERRNE2:	MOVE V,[XWD [SIXBIT /IN MACRO CALL@/],CALPG]
	SETOM UNVSKP		;[537] SET /U IN CASE CONTINUE ASSEMBLY
	JUMPN V,ERRNE3
	MOVE V,[XWD [SIXBIT /@/],PAGENO] ;BETTER THAN NOTHING
	SKIPE LITLVL		;HAD ONE PAGE NUMBER ALREADY
	RET
ERRNE3:	CALL PRNUM
	TLNE FR,LOADSW		;SEEN END OF FILE YET?
	RET			;YES
	MOVE P,SAVEPP		;NO RESET STACK
	MOVE MP,SAVERP
	MOVEM MP,RP
	MOVE MP,SAVEMP
	SETZ MRP,
	JRST ASSEM2		;AND CONTINUE

ERRMS1:	SIXBIT / ERRORS DETECTED@/
ERRMS2:	SIXBIT /1 ERROR DETECTED@/
ERRMS3:	SIXBIT /NO ERRORS DETECTED@/
ERRMQ1:	SIXBIT /1 WARNING GIVEN@/
ERRMQ2:	SIXBIT / WARNINGS GIVEN@/
   IFE TOPS20,<			; FOR SHORT FILES
EINIT:	CALL EFATAL		;[352] ?MCR
	MOVSI CS,'DNA'		;[352]
	CALL TYPSYM		;[352] DNA
	MOVEI C," "		;[352]
	CALL TYO		;[352] SPACE
	MOVE RC,[XWD ACDEV,[SIXBIT /NOT AVAILABLE @/]] ;[352]
	JRST ERRFN1		;[352] REST OF MESSAGE
   >				; END OF EQ TOPS20
   IFN TOPS20,<			; FOR LONG FILES
EINIT:	OUTSTR [ASCIZ /
?MCRFNF FILE NOT FOUND-/]
EINIT0:	OUTSTR FILNAM		; AND THE FILE NAME
	OUTSTR [ASCIZ /
/]
	JRST M			; AND START OVER

EINIT1:	OUTSTR [ASCIZ/
?MCRRFO REL FILE OPEN ERROR - /]
	JRST EINIT0
EINIT2:	OUTSTR [ASCIZ/
?MCRLFO LST FILE OPEN ERROR - /]
	JRST EINIT0
   >				; END OF NE TOPS20 CONDITIONAL

ERRCL:	HRRZ RC,LSTDIR+1	;GET LST DEV ERROR CODE
	JRST .+2		;GET ERROR MESSAGE
ERRCB:	HRRZ RC,BINDIR+1	;GET BIN DEV ERROR CODE
	JUMPN RC,ERRTYP
	SOJA RC,ERRTYP		;SPECIAL CASE IF ERROR CODE 0

ERRCF:	HRRZ RC,INDIR+1		;GET INPUT DEV ERROR CODE
	HLLZ ACEXT,INDIR+1	;SET UP EXT

ERRTYP:	CAIL RC,TABLND-TABLE	;IS ERROR CODE LEGAL?
	SKIPA RC,TABLND		;NO, GIVE CATCH ALL MESSAGE
	MOVE RC,TABLE(RC)	;YES, PICK UP MESSAGE
	CALL EFATAL		;PUT OUT CR-LF ?MCR
	MOVSI CS,'LRE'		;LOOKUP-RENAME-ENTER TYPE
	CALL TYPSYM
	CAIA			;SKIP CALL TO EFATAL NOW

ERRFIN:	CALL EFATAL
ERRFN1:	CALL TYPMSG		;[352]
	CLOSE LST,		;GIVE USER A PARTIAL LISTING
	CLOSE BIN,40		;BUT NEVER A BUM REL FILE
	JRST M

EFATAL:	CALL OCRLF
	MOVEI C,"?"
	CALL TYO
	MOVSI CS,'MCR'		;IDENTIFY CUSP
   IFN CCLSW,<AOS .JBERR>	;RECORD ERROR SO EXECUTION DELETED
	PJRST TYPSYM		;AND RETURN

EWARN:	CALL OCRLF
	MOVEI C,"%"
	CALL TYO
	MOVSI CS,'MCR'		;IDENTIFY CUSP
	PJRST TYPSYM		;AND RETURN

EINFO:	CALL OCRLF
	MOVEI C,"["
	CALL TYO
	MOVSI CS,'MCR'		;IDENTIFY CUSP
	PJRST TYPSYM		;AND RETURN

OCRLF:	SKPINC C		;SEE IN WE CAN INPUT A CHAR.
	  JFCL			;BUT ONLY TO DEFEAT ^O
	PJRST CRLF

	[SIXBIT /(0) ILLEGAL FILE NAME@/],,ACFILE
TABLE:	[SIXBIT /(0) FILE WAS NOT FOUND@/],,ACFILE
	[SIXBIT /(1) NO DIRECTORY FOR PROJECT-PROGRAMMER NUMBER@/],,ACFILE
	[SIXBIT /(2) PROTECTION FAILURE@/],,ACFILE
	[SIXBIT /(3) FILE WAS BEING MODIFIED@/],,ACFILE
	[SIXBIT /(4) RENAME FILE NAME ALREADY EXISTS@/],,ACFILE
	[SIXBIT /(5) ILLEGAL SEQUENCE OF UUOS@/],,ACFILE
	[SIXBIT /(6) BAD UFD OR BAD RIB@/],,ACFILE
	[SIXBIT /(7) NOT A SAV FILE@/],,ACFILE
	[SIXBIT /(10) NOT ENOUGH CORE@/],,ACFILE
	[SIXBIT /(11) DEVICE NOT AVAILABLE@/],,ACFILE
	[SIXBIT /(12) NO SUCH DEVICE@/],,ACFILE
	[SIXBIT /(13) NOT TWO RELOC REG. CAPABILITY@/],,ACFILE
	[SIXBIT /(14) NO ROOM OR QUOTA EXCEEDED@/],,ACFILE
	[SIXBIT /(15) WRITE LOCK ERROR@/],,ACFILE
	[SIXBIT /(16) NOT ENOUGH MONITOR TABLE SPACE@/],,ACFILE
	[SIXBIT /(17) PARTIAL ALLOCATION ONLY@/],,ACFILE
	[SIXBIT /(20) BLOCK NOT FREE ON ALLOCATION@/],,ACFILE
	[SIXBIT /(21) CAN'T SUPERSEDE (ENTER) AN EXISTING DIRECTORY@/],,ACFILE
	[SIXBIT /(22) CAN'T DELETE (RENAME) A NON-EMPTY DIRECTORY@/],,ACFILE
	[SIXBIT /(23) SFD NOT FOUND@/],,ACFILE
	[SIXBIT /(24) SEARCH LIST EMPTY@/],,ACFILE
	[SIXBIT /(25) SFD NESTED TOO DEEPLY@/],,ACFILE
	[SIXBIT /(26) NO-CREATE ON FOR SPECIFIED PATH@/],,ACFILE

TABLND:	[SIXBIT /(?) LOOKUP, ENTER, OR RENAME ERROR@/],,ACFILE


TYPMSG:	HLRZ CS,RC		;GET FIRST MESSAGE
	CAIE CS,-1		;SKIP IF MINUS ONE
	CALL TYPM2		;TYPE MESSAGE
	HRRZ CS,RC		;GET SECOND HALF
	CALL TYPM2

CRLF:	MOVEI C,CR		;OUTPUT CARRIAGE RETURN
	CALL TYO
	MOVEI C,LF		;AND LINE FEED

TYO:	SOSG CTOBUF+2		;BUFFER FULL?
	OUTPUT CTL,0		;YES, DUMP IT
	IDPB C,CTOBUF+1		;STORE BYTE
	CAIG C,FF		;FORM FEED?
	CAIGE C,LF		;V TAB OR LINE FEED?
	RET			;NO
	OUTPUT CTL,0		;YES
	RET			;AND EXIT

TYPM2:	MOVSI C,(1B0)		;ANTICIPATE REGISTER WORD
	CAIN CS,ACFILE		;FILE NAME ?
	JRST [JUMPE ACEXT,.+1	;YES, TEST FOR EXT
		LSH ACEXT,-6	;MAKE SPACE FOR "."
		IOR ACEXT,[SIXBIT /.   @/]
		JRST TYPM2A]
	CAIG CS,17		;IS IT?
	MOVEM C,1(CS)
TYPM2A:	HRLI CS,(POINT 6,,)	;FORM BYTE POINTER

TYPM3:	ILDB C,CS		;GET A SIXBIT BYTE
	CAIN C,40		;"@"?
	JRST TYO		;YES, TYPE SPACE AND EXIT
	ADDI C,40		;NO, FORM 7-BIT ASCII
	CALL TYO		;OUTPUT CHARACTER
	JRST TYPM3

TYPSYM:	MOVEI C,0		;CLEAR C
	LSHC C,6		;MOVE NEXT SIXBIT CHARACTER IN
	JUMPE C,CPOPJ		;TEST FOR END
	ADDI C,40		;CONVERT TO ASCII
	CALL TYO		;OUTPUT
	JRST TYPSYM		;LOOP



XCEEDS:	ADDI SX,2000		;ADJUST SYMBOL POINTER
XCEED:	CALL SAVEXS		;SAVE THE REGISTERS
	HRRZ 1,.JBREL		;GET CURRENT TOP
	MOVEI 0,2000(1)
	CORE 0,			;REQUEST MORE CORE
	  JRST XCEED2		;ERROR, BOMB OUT
	HRRZ 2,.JBREL		;GET NEW TOP

XCEED1:	MOVE 0,0(1)		;GET ORIGIONAL
	MOVEM 0,0(2)		;STORE IN NEW LOCATION
	SUBI 2,1		;DECREMENT UPPER
	CAMLE 1,SYMBOL		;HAVE WE ARRIVED?
	SOJA 1,XCEED1		;NO, GET ANOTHER
	MOVEI 1,2000
	ADDM 1,SYMBOL
	ADDM 1,SYMTOP
	CALL SRCHI		;RE-INITIALIZE SYMBOL TABLE
	JRST RSTRXS		;RESTORE REGISTERS AND EXIT

XCEED2:	HRROI RC,[SIXBIT /NEC INSUFFICIENT CORE@/]
XCEED3:	TLO FR,LOADSW		;[326] MAKE SURE IT COMES BACK
	CALL ERRNE0		;[326] GO PRINT HERE
	CLOSE LST,		;[400] GIVE USER A PARTIAL LISTING
	CLOSE BIN,40		;[400] BUT NEVER A BUM REL FILE
	JRST M			;[326] START ANOTHER ASSEMBLY
PDPERR:	HRROI RC,[SIXBIT .PDL PDP OVERFLOW, TRY /P@.]
	MOVE P,SAVEPP		;GET A VALID STACK POINTER
	JRST XCEED3		;[326] DON'T CONTINUE ASSEMBLY


PRNUM:	HLRZ CS,V		;GET MESSAGE
	CALL TYPM2
	MOVEI CS,[SIXBIT /ON PAGE@/]
	CALL TYPM2
	MOVE AC0,(V)		;GET PAGE
	CALL DP1		;PRINT NUMBER
	MOVEI C,40
	CALL TYO
	SKIPN AC1,1(V)		;GET SEQ NUM IF THERE
	JRST PRNUM1		;NO, TRY FOR TAG
	MOVEM AC1,OUTSQ
	MOVEI CS,[SIXBIT /LINE@/]
	CALL TYPM2
	OUTPUT CTL,0		;TO MAKE THINGS PRINT IN RIGHT ORDER
	OUTSTR OUTSQ		;PRINT SEQUENCE NUMBER
	MOVEI C," "		;ADD SPACE
	CALL TYO

PRNUM1:	MOVEI CS,[SIXBIT /AT@/]
	CALL TYPM2
	MOVE CS,2(V)
	CALL TYPSYM		;PRINT TAG
	MOVEI CS,[SIXBIT / +@/]
	CALL TYPM2
	MOVE AC0,LOCA		;[532] GET CURRENT OFFSET
	SUB AC0,3(V)		;[532] FROM THE TAG
	CALL DP1		;PRINT DECIMAL INCREMENT
	PJRST CRLF		;END LINE

DP1:	IDIVI AC0,^D10
	HRLM AC1,(P)
	JUMPE AC0,.+2
	CALL DP1
	HLRZ C,(P)
	ADDI C,"0"
	JRST TYO


RIM0:	TDO FR,AC0		;SET RIM/RIM10 FLAG
	TLNE FR,PNCHSW		;FORGET IT IF PUNCH RESET
	SETSTS BIN,IB		;SET TO IMAGE BINARY MODE
	RET

ROUT:	EXCH CS,RIMLOC
	SUB P,[XWD 1,1]		;CLEAR OUT STACK WFW
	TLNE FR,R1BSW
	JRST ROUT6
	TLNN FR,RIM1SW
	JRST ROUT1
	JUMPE CS,ROUT1		;RIM10 OUTPUT
	SUB CS,RIMLOC
	JUMPE CS,ROUT1
	JUMPG CS,ERRAX
	MOVEI C,0
	CALL PTPBIN
	AOJL CS,.-1
ROUT1:	MOVSI C,(DATAI PTR,)	;RIM OUTPUT
	HRR C,LOCO		;GET ADDRESS
	TLNE FR,RIM1SW		;NO DATAI IF RIM10
	AOSA RIMLOC
	CALL PTPBIN		;OUTPUT
	MOVE C,AC0		;CODE
	AOSA LOCO		;INCREMENT CURRENT LOCATION

OUTBIN:	TLNN FR,RIMSW!RIM1SW!R1BSW ;EXIT IF RIM MODE
PTPBIN:	TLNN FR,PNCHSW		;EXIT IF PUNCH NOT REQUESTED
	RET
	SOSG BINBUF+2		;TEST FOR BUFFER FULL
	CALL DMPBIN		;YES, DUMP IT
	IDPB C,BINBUF+1		;DEPOSIT BYTE
	RET			;EXIT

DMPBIN:	OUT BIN,0		;DUMP THE BUFFER
	RET			;NO ERRORS
TSTBIN:	GETSTS BIN,C		;GET STSTUS BITS
	TRNN C,ERRBIT		;ERROR?
	RET			;NO, EXIT
	MOVE AC0,BINDEV		;YES, GET TAG
	JRST ERRLST		;TYPE MESSAGE AND ABORT

DMPLST:	OUT LST,0		;OUTPUT BUFFER
	RET			;NO ERRORS
TSTLST:	GETSTS LST,C		;ANY ERRORS?
	TRNN C,ERRBIT
	RET			;NO, EXIT
	MOVE AC0,LSTDEV
ERRLST:	MOVSI RC,[SIXBIT /WLE OUTPUT WRITE-LOCK ERROR DEVICE@/]
	TRNE C,IOIMPM		;IMPROPER MODE?
	JRST ERRFIN		;YES
	MOVSI RC,[SIXBIT /ODE OUTPUT DATA ERROR DEVICE@/]
	TRNE C,IODERR		;DEVICE DATA ERROR?
	JRST ERRFIN		;YES
	MOVSI RC,[SIXBIT /OCP OUTPUT CHECKSUM OR PARITY ERROR DEVICE@/]
	TRNE C,IODTER		;IS IT
	JRST ERRFIN		;YES
	MOVE CS,AC0		;GET DEVICE
	DEVCHR CS,		;FIND OUT WHAT IT IS
	MOVSI RC,[SIXBIT /OQE OUTPUT QUOTA EXCEEDED ON DEVICE@/]
	TLNN CS,DSKBIT		;SKIP IF DSK OUTPUT
	MOVSI RC,[SIXBIT /OBL OUTPUT BLOCK TOO LARGE DEVICE@/]
	JRST ERRFIN

R1BDMP:	SETCM CS,R1BCNT
	JUMPE CS,R1BI
	HRLZS C,CS
	HRR C,R1BLOC
	HRRI C,-1(C)
	MOVEM C,R1BCHK
	CALL PTPBIN
	HRRI CS,R1BBLK
R1BDM1:	MOVE C,0(CS)
	ADDM C,R1BCHK
	CALL PTPBIN
	AOBJN CS,R1BDM1
	MOVE C,R1BCHK
	CALL PTPBIN
R1BI:	SETOM R1BCNT
	PUSH P,LOCO
	POP P,R1BLOC
	RET

ROUT6:	CAME CS,RIMLOC
	CALL R1BDMP
	AOS C,R1BCNT
	MOVEM AC0,R1BBLK(C)
	AOS LOCO
	CAIN C,.R1B-1
	CALL R1BDMP
	AOS RIMLOC
	RET


R1BLDR:
	PHASE 0
	IOWD $ADR,$ST
$ST:	CONO PTR,60
	HRRI $A,$RD+1
$RD:	CONSO PTR,10
	JRST .-1
	DATAI PTR,@$TBL1-$RD+1($A)
	XCT $TBL1-$RD+1($A)
	XCT $TBL2-$RD+1($A)
$A:	SOJA $A,
$TBL1:	CAME $CKSM,$ADR
	ADD $CKSM,1($ADR)
	SKIPL $CKSM,$ADR
$TBL2:	JRST 4,$ST
	AOBJN $ADR,$RD
$ADR:	JRST $ST+1
$CKSM:
	DEPHASE

   IF2,< PURGE $ST,$RD,$A,$TBL1,$TBL2,$ADR,$CKSM>


READ0:	CALL EOT		;END OF TAPE

READ:	SOSGE IBUF+2		;BUFFER EMPTY?
	JRST READ3		;YES
READ1:	ILDB C,IBUF+1		;PLACE CHARACTER IN C
	MOVE CS,@IBUF+1		;CHECK FOR SEQUENCE NUMBER
	TRNN CS,1
	JRST READ1A
	CAMN CS,[<ASCII /     />+1] ; HOWEVER IF AN SOS PAGE MARK
	SETZ CS,		; CLEAR SEQ NO. SO LINE NOT COUNTED
	MOVEM CS,SEQNO
	MOVEM CS,SEQNO2
	MOVNI CS,4
	ADDM CS,IBUF+2		;ADJUST WORD COUNT
REPEAT 4,< IBP IBUF+1>		;SKIP SEQ NO
	CALL READ		;AND THE TAB
	JRST READ		;GET NEXT CHARACTER

READ1A:	JUMPE C,READ		;IGNORE NULL
	CAIN C,CZ		;IF IT'S A "^Z"
	MOVEI C,LF		;TREAT IT AS A "LF"
	CAIE C,CLA		;CONTROL _
	RET
	MOVEI C,"^"		;MAKE CONTROL _ VISIBLE
	CALL RSW2
	MOVEI C,"_"
	CALL RSW2
	CALL PEEK		; LOOK AT NEXT CHAR
	CAIG C,CR		; IF IT IS END OF LINE
	CAIGE C,LF		;
	JRST [POP P,CS		; GET RETURN ADDRESS
		PUSH P,LIMBO	; SAVE NEXT CHAR,RSW1 DESTROYS IT
		MOVEI C,CLA	; RETORE ^_
		CALL (CS)	; RETURN TO LIST CHAR ETC
		POP P,LIMBO	; SAFE TO STORE NOW
		RET]		; RETURN TO PROGRAM
	TLZ IO,IORPTC		; USE THE CHAR IN C NOW
	JRST READ2A		; BUT DON'T LIST TWICE

READ2:	CALL READ		;YES, TEST FOR LINE FEED
	CALL RSW2		;LIST IN ANY EVENT
READ2A:	CAIG C,FF		; IS IT ONE OF
	CAIGE C,LF		;LF, VT, OR FF?
	JRST READ2		;NO
	CALL OUTIM1		;YES, DUMP THE LINE
	JRST READ		;RETURN NEXT CHARACTER

READ3:	IN CHAR,0		;GET NEXT BUFFER
	  JRST READ		;NO ERRORS
	GETSTS CHAR,C
	TRNN C,ERRBIT!2000	;ERRORS?
	JRST READ0		;EOF
	MOVE AC0,INDEV
READ4:	MOVSI RC,[SIXBIT /PET INPUT PHYSICAL END OF TAPE DEVICE@/] ;[403]
	TRNE C,2000
	JRST ERRFIN		;E-O-T
	MOVSI RC,[SIXBIT /MDE MONITOR DETECTED SOFTWARE INPUT ERROR DEVICE@/]
	TRNE C,IOIMPM		;IMPROPER MODE?
	JRST ERRFIN		;YES
	MOVSI RC,[SIXBIT /IDE INPUT DATA ERROR DEVICE@/]
	TRNE C,IODERR		;DEVICE DATA ERROR?
	JRST ERRFIN		;YES
	MOVSI RC,[SIXBIT /ICP INPUT CHECKSUM OR PARITY ERROR DEVICE@/]
	TRNN C,IODTER
	MOVSI RC,[SIXBIT /IBL INPUT BLOCK TOO LARGE DEVICE@/]
	JRST ERRFIN

OUTAB2:	CALL OUTTAB		;PRINT TWO TABS
OUTTAB:	MOVEI C,HT
PRINT:	CAIE C,CR		;IS THIS A CR?
	CAIN C,LF		;OR LF?
	JRST OUTCR		;YES, GO PROCESS
	CAIN C,VT		; VERT TAB?
	JRST OUTVT		; YES
	CAIN C,FF		;FORM FEED?
	JRST OUTFF		;YES, FORCE NEW PAGE
	JRST OUTL

OUTVT:	PUSH P,C+1		; NEED ADJACENT ACC
	MOVEI C,.LPP		; NO. OF LINES WE STARTED WITH
	SUB C,LPP		; MINUS NO. OF LINES LEFT
	IDIVI C,^D20		; HOW MANY WILL VT TAKE
	SUBI C+1,^D20		; TO GET TO NEXT TAB STOP
	ADDM C+1,LPP		; ACCOUNT FOR THEM
	POP P,C+1		;
	MOVEI C,VT		; PUT CHAR BACK
	SKIPLE LPP		; DID WE END PAGE?
	JRST OUTL		; NO, OUTPUT IT
	TLO IO,IOPAGE		; YES, NEXT TIME
	JRST OUTC		; OUTPUT IT

SOUT20:	CALL OUTAS0
OUTCR:	TRNN ER,ERRORS!LPTSW!TTYSW
	RET
	MOVEI C,CR		;CARRIAGE RETURN, LINE FEED
	CALL OUTL
	SOSGE LPP		;END OF PAGE?
	TLO IO,IOPAGE		;YES, SET FLAG
	TRCA C,7		;FORM LINE FEED AND SKIP

OUTL:	TLZN IO,IOPAGE		;NEW PAGE REQUESTED?
	JRST OUTC		;NO
	JUMP1 OUTC		;YES, BYPASS IF PASS ONE
	TLNE IO,IOMSTR+IOPROG	;[477] XLIST IN EFFECT
	JRST OUTC		;[477] YES
	PUSH P,C		;SAVE C AND CS
	PUSH P,CS
	PUSH P,ER
	HRR ER,OUTSW
	TLNE IO,IOCREF		;IF DOING CREF OUTPUT NOW
	TLNE FR,CREFSW		;AND CREFFING (JUST IN CASE)
	JRST .+2
	CALL CLSC3		;CLOSE IT OUT
	HLLM IO,(P)		;SAVE THIS NEW STATE OF IO
	MOVE C,..LPP		;
	ADDI C,2		; PUT BACK THE 2 LINES
	MOVEM C,LPP		;SET NEW COUNTER
	MOVEI C,CR
	CALL OUTC
	MOVEI C,FF
	CALL OUTC		;OUTPUT FORM FEED
	MOVEI CS,TBUF
	CALL OUTAS0		;OUTPUT TITLE
	MOVEI CS,VBUF
	CALL OUTAS0		;OUTPUT VERSION
	MOVEI CS,DBUF
	CALL OUTAS0		; AND DATE
	MOVE C,PAGENO
	CALL DNC		;OUTPUT PAGE NUMBER
	AOSG PAGEN.		;FIRST PAGE OF THIS NUMBER?
	JRST OUTL1		;YES
	MOVEI C,"-"		;NO, PUT OUT MODIFIER
	CALL OUTC
	MOVE C,PAGEN.
	CALL DNC
OUTL1:	CALL OUTCR
	MOVEI CS,DEVBUF
	CALL OUTAS0
	HRRZ CS,SUBTTX		;SWITCH FOR SUB-TITLE
	SKIPE 0(CS)		;IS THERE A SUB-TITLE?
	CALL OUTTAB		;YES, OUTPUT A TAB
	CALL SOUT20		;OUTPUT ASCII WITH CARRIAGE RETURN
	CALL OUTCR
	POP P,ER
	POP P,CS		;RESTORE REGISTERS
	POP P,C

OUTC:	TRNE ER,ERRORS!TTYSW
	CALL TYO
	TRNN ER,LPTSW
	RET
OUTLST:	SOSG LSTBUF+2		;BUFFER FULL?
	CALL DMPLST		;YES, DUMP IT
   IFN STANSW,< CAIN C,"@"
	MOVEI C,140
	CAIN C,"_"
	MOVEI C,30
	CAIN C,"^"
	MOVEI C,32
	CAIE C,"\"
	JRST OUTLSS
	MOVEI C,177
	IDPB C,LSTBUF+1
	JRST OUTLST
OUTLSS:	>
	IDPB C,LSTBUF+1		;STORE BYTE
	RET			;EXIT

OUTFF:	TLOA IO,IOPAGE		;
OUTFF1:	CALL PAGE1		; CLOSE CREF
OUTFF2:	SETOM PAGEN.		;
	AOS PAGENO		;
	RET			;

TIMOUT:	IDIVI 2,^D60*^D1000
TIMOU1:	IDIVI 2,^D60
	PUSH P,3		;SAVE MINUTES
	CALL OTOD		;STORE HOURS
	MOVEI 3,":"		;SEPARATE BY COLON
	IDPB 3,CS
	POP P,2			;STORE MINUTES
OTOD:	IDIVI 2,^D10
	ADDI 2,60		;FORM ASCII
	IDPB 2,CS
	ADDI 3,60
	IDPB 3,CS
	RET

DATOUT:	IDIVI 1,^D31		;GET DAY
	ADDI 2,1
	CAIG 2,^D9		;TWO DIGITS?
	ADDI 2,7760*^D10	;NO, PUT IN SPACE
	CALL OTOD		;STORE DAY
	IDIVI 1,^D12		;GET MONTH
	MOVE 2,DTAB(2)		;GET MNEMONIC
	IDPB 2,CS		;DEPOSIT RIGHT MOST 7 BITS
	LSH 2,-7		;SHIFT NEXT IN
	JUMPN 2,.-2		;DEPOSIT IFIT EXISTS
	MOVEI 2,^D64(1)		;GET YEAR
	JRST OTOD		;STORE IT

DTAB:	"-NAJ-"
	"-BEF-"
	"-RAM-"
	"-RPA-"
	"-YAM-"
	"-NUJ-"
	"-LUJ-"
	"-GUA-"
	"-PES-"
	"-TCO-"
	"-VON-"
	"-CED-"

; BINARY UNIVERSALS
;HERE TO WRITE OUT UNIVERSAL SYMBOL FILE
;SYMBOL TABLE PLUS MACROS

UNVOUT:	HRRZ AC0,FREE		;GET HIGHEST FREE LOCATION
	MOVEM AC0,.JBFF		;INTO JOBFF
	INIT UNV,B		;INIT DSK FOR OUTPUT
	SIXBIT /DSK/
	XWD UNVBUF,0		;OUTPUT ONLY
	 JRST UNVINT		;[466] ERROR
	MOVSI AC0,'UNV'		;STANDARD EXT
	MOVEM AC0,UNVDIR+1
	SETZM UNVDIR+2
	SETZM UNVDIR+3		;CLEAR PPN
	ENTER UNV,UNVDIR	;ENTER FILE
	 JRST UNVENT		;[466] ERROR
	MOVEI SDEL,2*203	;STANDARD DOUBLE BUFFERING
	ADD SDEL,FREE		;FROM FREE CORE
	CAML SDEL,SYMBOL	;MORE CORE NEEDED?
	CALL XCEED		;YES
	SUBI SDEL,2*203		;BACK TO START OF BUFFER
	MOVEM SDEL,.JBFF	;SETUP FOR BUFFERS
	OUTBUF UNV,2		;SET THEM UP
	MOVSI AC1,777		;SPECIAL MARKER FIRST WORD
	HRR AC1,UWVER		;[454] STORE VERSION NUMBER
	CALL UNVBIN		;LOADER BLOCK 777?
	MOVE AC1,.JBVER		;[543] GET MACRO VERSION NUMBER
	CALL UNVBIN		;[543] AND OUTPUT IT AS THE SECOND WORD
	MOVE AC1,@SYMBOL	;GET NUMBER OF SYMBOLS
	MOVN SDEL,AC1
	HRLZS SDEL
	HRR SDEL,SYMBOL		;FORM AOBJN POINTER
	CALL UNVBIN		;OUTPUT NUMBER OF SYMBOLS
	ADDI SDEL,1		;BYPASS COUNT
UNVLUP:	MOVE AC1,(SDEL)		;GET SYMBOL
	CALL UNVBIN
	ADDI SDEL,1
	MOVE AC1,(SDEL)		;GET VALUE
	TLNE AC1,SPTR		;SPECIAL EXTERNAL POINTER?
	JRST UNVSPT		;YES
	TLNE AC1,EXTF		;EXTERNAL (BUT NOT SPTR)?
	JRST UNVEXT		;YES, OUTPUT 2 WORDS
	TLNE AC1,MACF		;MACRO
	JRST UNVMAC		;YES, SAVE MACRO TEXT ALSO
	TLNE AC1,PNTF		;ONLY A POINTER TO VALUE?
	JRST UNVPTF		;YES
	CALL UNVBIN		;OUTPUT VALUE
UNVNXT:	AOBJN SDEL,UNVLUP	;FOR ALL SYMBOLS
	RELEASE UNV,
	RET


UNVINT:	CALL EWARN		;[466] NOT FATAL
	AOS QERRS		;[466] INCREMENT WARNING COUNT
	MOVE AC0,UNVDIR		;[466] FILNAM IN AC0
	MOVSI RC,[SIXBIT /UWU UNABLE TO WRITE UNIVERSAL FILE@/] ;[466]
	PJRST TYPMSG		;[466] TYPE MESSAGE AND EXIT

UNVENT:	CALL EWARN		;[466] NOT FATAL
	AOS QERRS		;[466] INCREMENT WARNING COUNT
	MOVSI CS,'EFU'		;[466] ENTER FAILED UNIVERSAL MNEMONIC
	CALL TYPSYM		;[466]
	MOVEI C," "		;[466]
	CALL TYO		;[466]
	HRRZ RC,UNVDIR+1	;[466] GET ERROR BITS
	SKIPN RC		;[466]
	SOS RC			;[466] =0 SPECIAL CASE
	CAIL RC,TABLND-TABLE	;[466] WITHIN BOUND?
	JRST [	HLRZ CS,TABLND	;[466] CATCH-ALL ERR MESS
		JRST .+2]	;[466]
	HLRZ CS,TABLE(RC)	;[466] REFERENCE TABLE
	CALL TYPM2		;[466] GIVE APPROPRIATE MESSAGE
	MOVE AC0,UNVDIR		;[466] FILENAME
	MOVSI RC,[SIXBIT /UNIVERSAL FILE@/] ;[466]
	PJRST TYPMSG		;[466] FINISH OFF AND EXIT

;HERE FOR EXTERNAL (NOT SPTR)
UNVEXT:	MOVE AC2,AC1		;GET POINTER
	HLLZ AC1,AC1		;CLEAR POINTER
	CALL UNVBIN		;OUTPUT FLAGS
	MOVE AC1,0(AC2)		;GET FIRST WORD (VALUE)
	CALL UNVBIN
	MOVE AC1,1(AC2)		;GET SECOND WORD (SYMBOL)
	CALL UNVBIN
	JRST UNVNXT

;HERE FOR 36 BIT VALUE
UNVPTF:	MOVE AC2,AC1		;GET COPY
	HLLZ AC1,AC1		;CLEAR POINTER
	CALL UNVBIN		;OUTPUT FLAGS
	MOVE AC1,(AC2)		;GET VALUE
	CALL UNVBIN		;OUTPUT IT
	JRST UNVNXT

;HERE FOR SPECIAL EXTERNAL SYMBOL
UNVSPT:	MOVE AC2,AC1		;COPY POINTER
	HLLZ AC1,AC1		;CLEAR POINTER
	CALL UNVBIN		;OUTPUT FLAGS
	MOVE AC1,(AC2)		;GET FIRST WORD
	CALL UNVBIN		;STORE VALUE
	MOVE AC1,1(AC2)		;GET RELOCATION WORD
	MOVE AC2,AC1		;COPY IT
	CALL UNVBIN
   IFN POLISH,<
	JUMPL AC2,UNVWPL	;IF POLISH JUMP
   >
	TRNN AC2,-1		;RIGHT HALF RELOCATION?
	JRST .+5		;NO
	MOVE AC1,(AC2)		;GET VALUE
	CALL UNVBIN
	MOVE AC1,1(AC2)		;EXTERNAL SYMBOL
	CALL UNVBIN
	TLNN AC2,-1		;LEFT HALF RELOCATION?
	JRST UNVNXT		;NO
	HLRZS AC2		;YES, SWAP
	JRST .-7		;AND OUTPUT

   IFN POLISH,<

;HERE IF POLISH
UNVWPL:	PUSH P,SDEL		;SAVE ORIGINAL SDEL
	PUSH P,AC2		;SAVE ORIGINAL AC2
	PUSH P,[-1]		;TO INDICATE THE END OF SAVED POINTERS
UNVWP1:	MOVEM AC2,UNVPOL	;SAVE THE POLISH PTR AT THE BEG OF STACK
	SETZ AC1,		;OUTPUT ZERO FOR 1ST WORD OF OPERATOR PAIR
	CALL UNVBIN		;WRITE IT OUT
	MOVE AC1,1(AC2)		;GET 2ND WORD -- THE OPERATOR
	CALL UNVBIN		;WRITE IT OUT
	MOVE SDEL,DESTB-3(AC1)	;GET # OF OPERANDS FOR THAT OPERATOR
UNVWP2:	ADDI AC2,2		;NEXT 2 WORDS PAIR
	MOVE AC1,(AC2)		;GET FIRST WORD
	CALL UNVBIN		;WRITE IT OUT
	JUMPN AC1,[	PUSH P,AC1 ;NOT ZERO, MUST BE A POINTER; SAVE IT
		SETZ AC1,	;ZERO FOR 2ND WORD
		JRST UNVWP5]
	MOVE AC1,1(AC2)		;GET 2ND WORD OF THE PAIR
UNVWP5:	CALL UNVBIN
	SOJG SDEL,UNVWP2	;ANY MORE OPERAND?
	SETZ AC1,		;
	CALL UNVBIN	;
	MOVE AC1,UNVPOL
	CALL UNVBIN

UNVWP3:	POP P, AC2		;NO, ANY PTRS SAVED ON STACK?
	CAME AC2,[-1]		;END OF SAVED PTRS?
	JRST UNVWP4		;NO, GO CHECK PTR
	POP P, AC2		;YES, RESTORE ORIGINAL AC2 COMING INTO UNVWPL
	POP P,SDEL		;RESTORE ORIGINAL SDEL
	JRST UNVNXT

UNVWP4:	JUMPL AC2,UNVWP1	;IF IT'S POLISH JUMP
	MOVE AC1,(AC2)		;GET 1ST WORD
	CALL UNVBIN
	SKIPE AC1
	PUSH P,AC2
	MOVE AC1,1(AC2)
	CALL UNVBIN
	JRST UNVWP3
;NUMBER OF OPERANDS FOR EACH OPERATOR
DESTB:	EXP 2,2,2,2,2,2,2,2,1,2,1,2,1,100

   >

;HERE FOR MACRO
UNVMAC:	MOVE AC2,AC1		;GET POINTER TO TEXT
	HLLZ AC1,AC1		;CLEAR POINTER
	CALL UNVBIN		;OUTPUT FLAGS
	HLRZ AC1,1(AC2)		;[334] GET DEFAULT VALUES, IF ANY
	MOVEM AC1,UNVDFA	;[334] SAVE STARTING ADRESS
	CALL UNVMCP		;[334] GO DUMP MACRO ITSELF
	SKIPN AC2,UNVDFA	;[334] SEE IF ANY DEFAULT VALUES (LEFT)
	JRST UNVNXT		;[334] NO, CONTINUE WITH NEXT SYMBOL
	HRROI AC1,(AC2)		;[334] SET UP AOBJP POINTER FOR # OF DEFAULTS
	SKIPE (AC1)		;[334] ARE THERE ANY MORE?
	AOBJP AC1,.-1		;[334] YES, COUNT AND TRY NEST
	CALL UNVBIN		;[334] OUTPUT COUNT WORD
UNVMC1:	HLRZ AC1,(AC2)		;[334] GET THE AGUMENT # OF THIS DEFAULT
	CALL UNVBIN		;[334] OUTPUT THE ARGUMENT NUMBER
	MOVE AC2,(AC2)		;[334] GET ADDRESS OF DEFAULT
	CALL UNVMCP		;[334] GO OUTPUT, IT LOOKS LIKE MACRO
	AOS AC2,UNVDFA		;[334] UP POINTER TO DEFAULT BLOCK
	SKIPE (AC2)		;[334] SEE IF ANY MORE
	JRST UNVMC1		;[334] YES, GO WRITE THEM OUT
	JRST UNVNXT		;[334] NO, GO DO NEXT SYMBOL

UNVMCP:	HLL AC2,(AC2)		;[334] PUT ADDRESS OF NEXT BLOCK IN LEFT
	QQ==0
REPEAT .LEAF,<
	MOVE AC1,QQ(AC2)
	CALL UNVBIN
	QQ==QQ+1>
	HLRZS AC2
	JUMPN AC2,UNVMCP	;[334] MORE LEAFS TO PROCESS
	RET			;[334] RETURN

UNVBIN:	SOSG UNVBUF+2
	CALL DMPUNV
	IDPB AC1,UNVBUF+1
	RET

DMPUNV:	OUT UNV,0
	  RET
	GETSTS UNV,C		;[403] GET STATUS BITS
	TRNN C,ERRBIT		;[403] ERRORS?
	RET			;[403] NO, EXIT
	MOVSI AC0,'DSK'		;DEVICE ALWAYS DSK
	JRST ERRLST		;[403] GIVE ERROR MESSAGE


;HERE TO READ IN UNIVERSAL SYMBOL TABLE

UNVINP:	MOVEM AC0,UNVDIR	;FILE WE NEED
	PUSH P,AC0		; SAVE REAL NAME OF UNV
	MOVSI AC1,'DSK'		; DEFAULT DEVICE
	MOVEM AC1,UNVDEV	;
	MOVSI AC1,'UNV'		;REQUIRED EXT
	MOVEM AC1,UNVDIR+1
	SETZM UNVDIR+2
	SETZM UNVDIR+3
	CAIE C,'('		; SEE IF USER SUPPLIED FILE SPEC
	JRST UNVOPN		; NO, USE DEFAULT
	CALL SCHGET		; GET A NAME
	CAIE C,':'		; IS IT A DEVICE?
	JRST UNVCKN		; NO TRY NAME
	MOVEM AC0,UNVDEV	; YES, SAVE DEVICE
	CALL SCHGET		; TRY NEXT NAME
UNVCKN:	MOVEM AC0,UNVDIR	; SAVE NAME
	CAIE C,'.'		; DOES EXT FOLLOW?
	JRST .+3		; NO
	CALL SCHGET		; YES, GET IT
	MOVEM AC0,UNVDIR+1	; AND STORE IT
	CAIE C,'['		; A DIRECTORY SPECIFIED?
	JRST SCHCLP		; NO
	CALL SCHOCT		; GET PPN
	HRLZM AC0,UNVDIR+3	; AND SAVE IT
	CAIE C,','		; CHECK PROG NO.
	TROA ER,ERRQ		; WARN USER
	CALL SCHOCT		; GRT IT
	HRRM AC0,UNVDIR+3	;
	CAIE C,','		; AN SFD GIVEN?
	JRST SCHCLB		; NO
	MOVEI AC0,UNVPTH	;GET PATH PTR
	EXCH AC0,UNVDIR+3	; SWAP WITH PPN
	MOVEM AC0,UNVPTH+2	; AND PUT IN PATH
	MOVSI RC,-.SFDLN	; AOBJN PTR FOR SFDS
SCHSFD:	CALL SCHGET		; GET SFD NAME
	AOBJP RC,SCHCLB+1	; SEE IF ENOUGH ROOM
	MOVEM AC0,UNVPTH+2(RC)	; YES, STORE
	CAIN C,','		; DOES PATH CONTINUE ON?
	JRST SCHSFD		; YES
SCHCLB:	CAIE C,']'		; DOES PATH FINISH PROPERLY?
	TROA ER,ERRQ		; NO
	CALL BYPAS1		; EAT UP THE "]"
SCHCLP:	CAIE C,')'		; FILE SPEC END PROPERLY?
	TROA ER,ERRQ		; NO
	CALL BYPAS1		; EAT IT
UNVOPN:	POP P,AC0		; UNV NAME BACK IN 0
	OPEN UNV,UNVINI		; TRY USER SPECIFICATION
	  JRST UNVUNV		;FAILED
	LOOKUP UNV,UNVDIR	;SEE IF THERE
	  JRST UNVUNV		;TRY UNV:
	MOVEM AC0,UNVDIR	; RESTORE NAME OF UNV 
UNVFND:	AOS RC,UNIVNO		;BUMP COUNT OF UNIVERSALS
	CAILE RC,.UNIV		;SEE IF ROOM IN TABLES
	JRST UNVERR		;NO, GIVE ERROR
	SKIPN UNIVSN		;IS CURRENT PROG A UNIVERSAL
	JRST UNVNOT		;NO
	CAIL RC,.UNIV		;YES, ROOM FOR IT AS WELL?
	JRST UNVERR		;NO
	MOVE AC1,UNITBL(RC)	;GET CURRENT NAME
	MOVEM AC1,UNITBL+1(RC)	;STORE IT IN NEXT SLOT
UNVNOT:	MOVEM AC0,UNITBL(RC)	;STORE NAME
	HLRE SDEL,UNVDIR+3	;GET SIZE OF FILE
	MOVMS SDEL		;IN WORDS
	ADD SDEL,FREE		;AT TOP OF FREE CORE
	HRRZM SDEL,UNIPTR(RC)	;SAVE NEW SYMTOP (IN WRONG HALF)
	ADDI SDEL,2*203		;PLUS  2 BUFFERS
	CAML SDEL,SYMBOL	;WILL IT FIT?
	CALL XCEED		;NO, TRY FOR MORE
	CAML SDEL,SYMBOL	;DID WE GET ENOUGH?
	JRST .-2		;NO TRY AGAIN
	SUBI SDEL,2*203		;START OF BUFFERS
	MOVEM SDEL,.JBFF
	INBUF UNV,2		;STANDARD DOUBLE BUFFERING
	CALL UNVREAD		;READ 
	PUSH P,AC1		;[511] SAVE AC1 FOR A WHILE
	HLRZS AC1		;[511] LEFT HALF OF FIRST WORD OF UNV FILE
	CAIE AC1,777		;[511] MUST BE A 777 MARKER
	JRST [	POP P,AC1	;[511] FIX STACK
		JRST UNVFAKE]	;[511] AND GIVE UNV FILE NOT REAL ERROR
	POP P,AC1		;[511] IT'S UNV FILE--RESTORE AC1
	HRRZS AC1		;GET UNV VERSION #
	SETOM UNVER%		;[334] KLUDGE SWITCH TO ALLOW VERSION 4
	CAIE AC1,4		;[334] SEE IF 4 (MIGHT BOMB DEFAULT ARGUMENTS)
	AOS UNVER%		;[454] NO, UNVER% IS 0 FOR GOOD FILES
	TRNE AC1,.URVER		;[454] MAKE SURE EXTRA BITS ARE NOT ON
	JRST VERSKW		;[364] YOU LOSE
	TRNE AC1,UMACV		;[543] MACRO VERSION EXPECTED?
	CALL UNVREAD		;[543] YES, SKIP OVER IT
	CALL UNVREAD		;READ SYMBOL COUNT (SECOND WORD)
	MOVE SDEL,AC1		;GET COPY
	LSH SDEL,1		;TWO WORDS PER SYMBOL
	ADDI SDEL,1		;PLUS ONE FOR COUNT
	MOVNS SDEL		;NEGATE
	MOVE AC2,SDEL		;STORE IT
	ADD AC2,UNIPTR(RC)	;ADD SYMTOP
	HRLM AC2,UNIPTR(RC)	;TO FORM SYMBOL
	MOVSS UNIPTR(RC)	;NOW PUT IN CORRECT HALVES
	MOVN SDEL,AC1		;GET NO. OF SYMBOLS
	HRLZ SDEL,SDEL		;TO FORM AOBJN POINTER
	HRR SDEL,AC2		;POINT TO WHERE TO STORE THEM
	MOVEM AC1,(SDEL)	;STORE COUNT
	ADDI SDEL,1		;AND GET PAST IT

UNVRLO:	CALL UNVREAD		;GET A SYMBOL
	MOVEM AC1,(SDEL)	;STORE IT
	ADDI SDEL,1		;INCREMENT PAST IT
	CALL UNVREAD		;GET  VALUE
	MOVEM AC1,(SDEL)	;STORE IT
	TLNE AC1,SPTR		;SPECIAL EXTERNAL POINTER?
	JRST UNVRSP		;YES
	TLNE AC1,EXTF		;EXTERNAL (NOT SPTR)?
	JRST UNVREX		;YES
	TLNE AC1,MACF		;MACRO?
	JRST UNVRMC		;YES
	TLNE AC1,PNTF		;36 BIT VALUE
	JRST UNVRPT		;YES
UNVRNX:	AOBJN SDEL,UNVRLO	;GET NEXT
	RELEASE UNV,
	MOVE RC,UNIVNO		;POINT TO LAST ENTRY
	MOVE AC1,UNITBL+1(RC)	;GET NAME INCASE IN UNIV NOW
	SKIPE UNIVSN		;ARE WE?
	MOVEM AC1,UNVDIR	;YES, RESET NAME OF OUTPUT FILE
   IFN POLISH,<
	PUSH P,SGSBOT
	PUSH P,SGSTOP
	PUSH P,SGSCNT
	PUSH P,SGNCUR
   >
	PUSH P,SYMBOL
	PUSH P,SYMTOP		;SAVE EXISTING VALUES
	PUSH P,SRCHX
	MOVE AC1,UNIPTR(RC)	;GET SYMTOP,,SYMBOL
	HLRZM AC1,SYMTOP
	HLRZM AC1,FREE		;DON'T FORGET TO SET FREE BEYOND SYMTOP
	HRRZM AC1,SYMBOL
	HLRZ AC1,AC1		;TOP LOCATION
	MOVEM AC1,UNITOP	;SAVE NEW TOP FOR UNIVERSALS
	CAMLE AC1,MACSIZ	;HAVE WE INCREASED?
	MOVEM AC1,MACSIZ	;YES, STOP ILL MEM REFS
   IFN POLISH,<
	SETZM SGNCUR
	MOVE AC0,@SYMBOL
	MOVEM AC0,SGSCNT
   >
	CALL SRCHI		;SETUP SEARCH POINTER
	MOVE AC1,SRCHX		;LOAD IT
	MOVEM AC1,UNISHX(RC)	;SAVE IT
	POP P,SRCHX		;RESTORE
	POP P,SYMTOP
	POP P,SYMBOL
   IFN POLISH,<
	POP P,SGNCUR
	POP P,SGSCNT
	POP P,SGSTOP
	POP P,SGSBOT
   >
	JRST SERCH1		;AND RETURN

;HERE FOR 36 BIT VALUE
UNVRPT:	CALL UNVREAD
	AOS AC2,FREE		;GET A FREE LOC
	SUBI AC2,1
	MOVEM AC1,(AC2)		;STORE IT
	HRRM AC2,(SDEL)		;FIXUP SYMBOL POINTER
	JRST UNVRNX		;GET NEXT

;HERE FOR EXTERNAL (NOT SPTR)
UNVREX:	MOVEI AC2,2		;NEED 2 LOCS
	ADDB AC2,FREE
	SUBI AC2,2		;POINT TO START OF 2 WORDS
	CALL UNVREAD		;GET VALUE
	MOVEM AC1,0(AC2)	;MOST LIKELY 0
	CALL UNVREAD		;GET NAME
	MOVEM AC1,1(AC2)
	HRRM AC2,(SDEL)		;POINT TO VALUE
	JRST UNVRNX		;GET NEXT

;HERE FOR SPECIAL EXTERNAL SYMBOL
UNVRSP:	CALL UNVR2W		;GET 2 LOCATIONS
	CALL UNVREAD		;GET VALUE
	MOVEM AC1,(AC2)
	CALL UNVREAD		;GET RELOCATION
	HRRM AC2,(SDEL)		;STORE POINTER
	MOVEI RC,1(AC2)		;POINT TO RELOCATION WORD
	SETZM (RC)		;CLEAR RELOCATION
   IFN POLISH,<
	JUMPL AC1,UNVRPL	;JUMP IF IT'S POLISH
   >
	MOVE AC2,AC1		;STORE PREVIOUS RELOCATION
	TRNN AC2,-1		;RIGHT HALF RELOCATION?
	JRST UNVRS2		;NO
	HRR AC2,FREE		;POINT TO NEXT 2 WORD BLOCK
	HRRM AC2,(RC)		;POINT TO BLOCK (RELOCATION)
UNVRS1:	CALL UNVREAD		;GET VALUE
	MOVEM AC1,(AC2)
	CALL UNVREAD		;GET EXTERNAL SYMBOL
	MOVEM AC1,1(AC2)
	HRRI AC2,2(AC2)		;INCREMENT RIGHT HALF BY 2 WORDS USED
	HRRZM AC2,FREE		;INCREMENT FREE
UNVRS2:	TLZN AC2,-1		;LEFT HALF RELOCATION?
	JRST UNVRNX		;NO, GET NEXT SYMBOL
	HRLM AC2,(RC)		;FIX LEFT RELOCATION
	JRST UNVRS1		;AND FILL IN VALUE

UNVR2W:	MOVEI AC2,2		;GET 2 LOCATIONS
	ADDB AC2,FREE		;FROM FREE CORE
	SUBI AC2,2		;POINT TO START OF 2 WORDS
	RET

   IFN POLISH,<

;HERE FOR POLISH
UNVRPL:	PUSH P,[-1]		;END OF LOCATIONS TO BE ADJUSTED
	MOVEM AC1,UNVPOL	;STORE PTR, USED TO FIND END OF POL STK
	CALL UNVR2W		;GET 2 LOCATIONS
UNVRP0:	SETOM (RC)		;-1 IN LEFT HALF
	HRRM AC2,(RC)		;TO SET UP A NEW POLISH POINTER
	MOVE AC1,(RC)	
	MOVEM AC1,UNVNPL	;SAVE THE NEW POLISH POINTER
UNVRP1:	CALL UNVREAD		;READ 1ST WORD OF THE PAIR
	MOVEM AC1,(AC2)	
	JUMPE AC1,UNVRP2
	SKIPG AC1		;SKIP IF NOT POLISH
	PUSH P,AC1		;STORE POLISH PTR WITH ORIGINAL ADDR
	MOVEI RC,(AC2)
	HLL RC,AC1
	PUSH P,RC		;STORE LOCATIONS TO BE ADJUSTED ON STACK
UNVRP2:	CALL UNVREAD		;READ 2ND WORD OF THE PAIR
	CAME AC1,UNVPOL		;END OF POLISH STACK?
	JRST [	MOVEM AC1,1(AC2)
		CALL UNVR2W
		JRST UNVRP1]	;GET 2 LOCATIONS AND LOOP BACK
	MOVE AC1,UNVNPL		;ADJUSTED NEW POL STR IN 2ND WORD
	MOVEM AC1,1(AC2)

;HERE AT END OF POLISH STACK READ
UNVRP3:	POP P,AC1		;GET LOCATION TO BE ADJUSTED
	CAMN AC1,[-1]		;NO MORE?
	JRST UNVRNX		;
	CALL UNVR2W		;GET 2 LOCATIONS
	HRRM AC2,(AC1)		;SO ADJUST IT
	JUMPL AC1,[POP P, AC1	;GET POL PTR WITH ORIGINAL ADDR
		MOVEM AC1,UNVPOL ;SAVE IT
		SETZM (AC2)	;ZERO THE FIRST WORD
		MOVEI RC,1(AC2)
		JRST UNVRP0]
	MOVEI RC,(AC2)
	CALL UNVREAD		;READ 1ST WORD
	MOVEM AC1,(AC2)
	JUMPE AC1,UNVRP4
	HLL RC,AC1
	PUSH P,RC
UNVRP4:	CALL UNVREAD
	MOVEM AC1,1(AC2)
	JRST UNVRP3

   >

;HERE FOR MACRO
UNVRMC:	MOVE AC2,FREE		;FREE LOC COUNTER
	HRRM AC2,(SDEL)		;IS WHERE MACRO STARTS

	MOVEM AC2,UNVDFA	;[334] SAVE STARTING ADDRESS OF MACRO
	CALL UNVRML		;[334] GO READ IN MACRO DEFINITION
	MOVE AC1,UNVDFA		;[334] GET STARTING ADDRESS BACK
	HLRZ AC2,1(AC1)		;[334] GET POINTER FOR ANY DEFAULTS
	JUMPE AC2,UNVRNX	;[334] NONE, GO DO NEXT SYMBOL
	SKIPE UNVER%		;[334] MAKE SURE WE WROTE THEM ON DISK
	JRST UNVRER		;[334] NO, TELL USER
	PUSH P,SDEL		;[334] SAVE AOBJN POINTER
	MOVE AC2,FREE		;[334] GET NEXT FREE ADDRESS
	HRLM AC2,1(AC1)		;[334] POINT TO IT IN MACRO BODY
	CALL UNVREAD		;[334] GO READ COUNT OF DEFAULTS
	MOVN SDEL,AC1		;[334] COPY COUNT TO AOBJN POINTER
	HRRI SDEL,(AC2)		;[334] SET AOBJN ADDRESS INTO SDEL
	HLRZ AC2,AC1		;[334] GET COUNT-1 OF DEFAULTS
	ADDI AC2,2		;[334] CHANGE TO COUNT+1 (+0 WORD)
	ADDB AC2,FREE		;[334] BUMP FREE BY DEFAULT POINTER BLOCK LENGTH
UNVRM1:	CALL UNVREAD		;[334] GO READ ARGUMENT NUMBER
	HRLM AC1,(SDEL)		;[334] SAVE IN POINTER BLOCK
	HRRM AC2,(SDEL)		;[334] SAVE START OF VALUE (MAY BE SET UP BY UNVRML)
	CALL UNVRML		;[334] GO COPY DEFAULT VALUE
	AOBJN SDEL,UNVRM1	;[334] DO ALL DEFAULTS
	SETZM (SDEL)		;[334] CLEAR END OF BLOCK WORD
	POP P,SDEL		;[334] RESTORE BIG AOBJN WORD
	JRST UNVRNX		;[334] GO DO NEXT SYMBOL

UNVRML:	QQ==0
REPEAT .LEAF,<
	CALL UNVREAD
	MOVEM AC1,QQ(AC2)	;STORE
QQ==QQ+1>
	MOVE AC1,(AC2)		;SEE WHAT FIRST WORD WAS
	TLNN AC1,-1		;IF ZERO THEN FINISHED
	JRST UNVRMF		;SET LAST BLOCK POINTER
	MOVEI AC1,.LEAF(AC2)	;POINT TO NEXT BLOCK
	HRLM AC1,(AC2)		;FILL IT IN
	ADDI AC2,.LEAF		;POINT TO IT
	JRST UNVRML		;AND LOOP

UNVRMF:	MOVE AC1,(SDEL)		;GET FIRST BLOCK
	HRRM AC2,(AC1)		;POINT TO LAST
	ADDI AC2,.LEAF		;POINT TO NEXT FREE
	MOVEM AC2,FREE
	RET			;[334] RETURN

UNVRER:	MOVSI RC,[SIXBIT /OUF UNIVERSAL FILE DEFAULT ARGUMENTS LOST, REASSEMBLE@/] ;[334]
	JRST ERRFIN		;[334] PRINT THAT HAD DEFAULTS WHICH WERE LOST
UNVFAKE: MOVSI RC,[SIXBIT /NUF NOT A REAL UNIVERSAL FILE @/] ;[511]
	JRST ERRFIN		;[511] NAME IN AC0



UNVREA:	SOSG UNVBUF+2
	CALL UNVRIN
	ILDB AC1,UNVBUF+1
	RET

UNVRIN:	IN UNV,
	  RET
	GETSTS UNV,C		;[403] GET STATUS BITS
	TRNN C,ERRBIT!2000	;[403] ERRORS?
	JRST [	MOVSI RC,[	SIXBIT /ERU UNEXPECTED END-OF-FILE  READING UNIVERSAL FILE @ /] ;NAME IN AC0
		JRST ERRFIN]	;[403] GIVE ERROR MESSAGE
	MOVE AC0,UNVDEV		;[403] GET DEVICE
	JRST READ4		;[403] GIVE I/O ERROR MESSAGE

UNVUNV:	MOVEM AC0,UNVDIR	; RESTORE REAL NAME
	MOVSI AC1,'UNV'		; AND DEFAULT EXT
	MOVEM AC1,UNVDIR+1	;
	SETZM UNVDIR+2		;
	SETZM UNVDIR+3		; DEFAULT PATH
	INIT UNV,B
	SIXBIT /UNV/
		UNVBUF
	  JRST UNVSYS
	LOOKUP UNV,UNVDIR
	  JRST UNVSYS
	JRST UNVFND

UNVSYS:	INIT UNV,B
	SIXBIT /SYS/
		UNVBUF
	  JRST SCHERR
	LOOKUP UNV,UNVDIR	;SEE IF THERE
	  JRST SCHERR		;NO
	JRST UNVFND		;GOT IT

SUBTTL MACHINE INSTRUCTION SEARCH ROUTINES
   IFE OPHSH,<
OPTSCH:	MOVEI RC,0
	MOVEI ARG,1B^L<OP1END-OP1TOP> ;SET UP INDEX
	MOVEI V,1B^L<OP1END-OP1TOP>/2 ;SET UP INCREMENT

OPT1A:	CAMN AC0,OP1TOP(ARG)	;ARE WE POINTING AT SYMBOL?
	JRST OPT1D		;YES, GET THE CODE
	JUMPE V,POPOUT		;TEST FOR END
	CAML AC0,OP1TOP(ARG)	;NO, SHOULD WE MOVE DOWN?
	TDOA ARG,V		;NO, INCREMENT
OPT1B:	SUB ARG,V		;YES, DECREMENT
	ASH V,-1		;HALVE INCREMENT
	CAIG ARG,OP1END-OP1TOP	;ARE WE OUT OF BOUNDS?
	JRST OPT1A		;NO, TRY AGAIN
	JRST OPT1B		;YES, BRING IT DOWN A PEG
   >

   IFN OPHSH,<
OPTSCH:	MOVE ARG,AC0		;GET SIXBIT NAME
	TLZ ARG,400000		;CLEAR SIGN BIT
	IDIVI ARG,PRIME		;REM. GOES IN V
	CAMN AC0,OP1TOP(V)	;ARE WE POINTING AT SYMBOL?
	JRST OPT1D		;YES
	SKIPN OP1TOP(V)		;TEST FOR END
	JRST OPT1B		;SYMBOL NOT FOUND
	HLRZ RC,ARG		;SAVE LHS OF QUOTIENT
	SKIPA ARG,RC		;GET IT BACK
OPT1A:	ADDI ARG,(RC)		;INCREMENT ARG
	ADDI V,(ARG)		;QUADRATIC INCREASE TO V
	CAIL V,PRIME		;V IS MODULO PRIME
	JRST [SUBI V,PRIME
		JRST .-1]
	CAMN AC0,OP1TOP(V)	;IS THIS IT?
	JRST OPT1D		;YES
	SKIPE OP1TOP(V)		;END?
	JRST OPT1A		;TRY AGAIN
OPT1B:	SETZ RC,		; CLEAR RELOCATION INCASE IMPLICIT OPDEF
	RET			;FAILED
   >
OPT1D:
   IFN OPHSH,< SETZ RC,		;CLEAR RELOCATION
	MOVE ARG,V>		;GET INDEX IN RIGHT ACC.
	IDIVI ARG,4		;ARG HAS INDEX USED IN OPTTAB
	LDB V,OPTTAB(V)		;V HAS INDEX TO OPTTAB
	CAIL V,700		;PSEUDO-OP OR IO INSTRUCTION?
	JRST OPT1G		;YES
	ROT V,-^D9		;LEFT JUSTIFY
	HRRI V,OP		;POINT TO BASIC FORMAT
OPT1F:	AOS 0(P)		;SET FOR SKIP EXIT
	MOVEI SDEL,%OP		;SET OP-CODE CROSS-REF FLAG
	JRST CREF		;TEST AND OUTPUT, AC0=SYMBOL, V=VALUE

OPT1G:	JUMPG AC0,[CAME AC0,['.XCREF'] ; DON'T CREF .XCREF
		JRST .+3	;IF ".","$",OR "%" USE TABLE 1
		MOVE V,OP1TAB-700(V) ; USE TABLE 1
		JRST CPOPJ1]	; AND BYPASS CREF
	TLNN AC0,200000		;PSEUDO-OP OR IO INST., TEST FOR PROPER TABLE
	SKIPA V,OP2TAB-700(V)	;2ND TABLE, FIRST LETTER IS "A" TO "O"
	MOVE V,OP1TAB-700(V)	;1ST TABLE, ..."P" TO "Z"
	JRST OPT1F		;EXIT

OPTTAB:
   IFE OPHSH,< POINT 9,OP1COD-1(ARG),35>
	POINT 9,OP1COD  (ARG), 8
	POINT 9,OP1COD  (ARG),17
	POINT 9,OP1COD  (ARG),26
   IFN OPHSH,< POINT 9,OP1COD  (ARG),35>



	.XCREF			;DON'T CREF THIS MESS
   IFE OPHSH,<
	RELOC .-1
OP1TOP:
	RELOC

	IF1,<N1=0
	DEFINE X (SYM,COD)<N1=N1+1>> ;

	IF2, <
	N2=^D36
	CC=0
	RELOC OP1COD
	RELOC
DEFINE X (SYMBOL,CODE)
<SIXBIT /SYMBOL/
CC=CC+CODE_<N2=N2-9>
   IFE N2, <OUTLIT>>

DEFINE OUTLIT <
	RELOC
	+CC
	RELOC
N2=^D36+<CC=0>>>
   >

   IFN OPHSH,<
OP1TOP:	IF1,< BLOCK PRIME>
   IF1,<DEFINE X (SB,CD)<>>
   IF2,<
DEFINE OPSTOR (RM)<.$'RM=.$'RM+<OPCODE_<9*<3-R&3>>>>

DEFINE X (SB,CD)<
SXB=<SIXBIT /SB/>
Q=SXB&-1_-1/PRIME
R=SXB&-1_-1-Q*PRIME
H=Q_-22&777
TRY=1
OPCODE=CD
ITEM Q,\R
   IFL PRIME-TRY,<PRINTX HASH FAILURE>>

DEFINE ITEM (QT,RM)<
   IFN .%'RM,<R=R+H
   IFL PRIME-R,<R=R-R/PRIME*PRIME>
H=H+Q_-22&777
   IFGE PRIME-<TRY=TRY+1>,<ITEM Q,\R>>
   IFE .%'RM,<.%'RM=SXB
OPSTOR \<R/4>>>>
   IF1,<
DEFINE GETSYM (N)<.%'N=0>

N=0
	XLIST
REPEAT PRIME,<GETSYM \N
N=N+1>
DEFINE GETSYM (N)<.$'N=0>
N=0
REPEAT <PRIME/4+1>,<GETSYM \N
N=N+1>
   >
	LIST>

;MACRO TO HANDLE KI10 OP-CODES
   IFE KI10,<
DEFINE XK (SB,CD) <>>		;NUL MACRO
   IFN KI10,<SYN X,XK>		;USUAL X MACRO

;MACRO TO HANDLE KL10 OP-CODES
   IFE KL10,<
DEFINE XL (SB,CD) <>>		;NUL MACRO
   IFN KL10,<SYN X,XL>		;USUAL X MACRO

;MACRO TO HANDLE F40 UUOS
   IFE F40,<
DEFINE XF (SB,CD) <>>		;NUL MACRO
   IFN F40,<SYN X,XF>		;USUAL X MACRO

X ADD   , 270
X ADDB  , 273
X ADDI  , 271
X ADDM  , 272

XL ADJBP , 133
XL ADJSP , 105

X AND   , 404
X ANDB  , 407
X ANDCA , 410
X ANDCAB, 413
X ANDCAI, 411
X ANDCAM, 412
X ANDCB , 440
X ANDCBB, 443
X ANDCBI, 441
X ANDCBM, 442
X ANDCM , 420
X ANDCMB, 423
X ANDCMI, 421
X ANDCMM, 422
X ANDI  , 405
X ANDM  , 406

X AOBJN , 253
X AOBJP , 252

X AOJ   , 340
X AOJA  , 344
X AOJE  , 342
X AOJG  , 347
X AOJGE , 345
X AOJL  , 341
X AOJLE , 343
X AOJN  , 346

X AOS   , 350
X AOSA  , 354
X AOSE  , 352
X AOSG  , 357
X AOSGE , 355
X AOSL  , 351
X AOSLE , 353
X AOSN  , 356
X ARG   , 320
X ARRAY , 771
   IFN IIISW,<X ASCID , 773>
X ASCII , 700
X ASCIZ , 701

X ASH   , 240
X ASHC  , 244

X ASUPPR, 705
X BLKI  , 702
X BLKO  , 703
X BLOCK , 704

X BLT   , 251

X BYTE  , 707

X CAI   , 300
X CAIA  , 304
X CAIE  , 302
X CAIG  , 307
X CAIGE , 305
X CAIL  , 301
X CAILE , 303
X CAIN  , 306

X CALL  , 040
X CALLI , 047

X CAM   , 310
X CAMA  , 314
X CAME  , 312
X CAMG  , 317
X CAMGE , 315
X CAML  , 311
X CAMLE , 313
X CAMN  , 316

X CLEAR , 400
X CLEARB, 403
X CLEARI, 401
X CLEARM, 402

X CLOSE , 070
XL CMPSE , 002
XL CMPSG , 007
XL CMPSGE, 005
XL CMPSL , 001
XL CMPSLE, 003
XL CMPSN , 006
X COMMEN, 770


X CONI  , 710
X CONO  , 711
   IFN STANSW,<X CONS,257>
X CONSO , 712
X CONSZ , 713

XL CVTBDO, 012
XL CVTBDT, 013
XL CVTDBO, 010
XL CVTDBT, 011
XL DADD  , 114

XF DATA. , 020

X DATAI , 714
X DATAO , 715
XL DDIV  , 117
X DEC   , 716
X DEFINE, 717
X DEPHAS, 720

XK DFAD  , 110
XK DFDV  , 113
XK DFMP  , 112
X DFN   , 131
XK DFSB  , 111

X DIV   , 234
X DIVB  , 237
X DIVI  , 235
X DIVM  , 236

XK DMOVE , 120
XK DMOVEM, 124
XK DMOVN , 121
XK DMOVNM, 125
XL DMUL  , 116
X DPB   , 137
XL DSUB  , 115
XL EBLT  , 020
XL EDIT  , 004

X END   , 721
X ENTER , 077
X ENTRY , 722

X EQV   , 444
X EQVB  , 447
X EQVI  , 445
X EQVM  , 446

X EXCH  , 250

X EXP   , 723
XL EXTEND, 123
X EXTERN, 724

X FAD   , 140
X FADB  , 143
X FADL  , 141
X FADM  , 142

X FADR  , 144
X FADRB , 147
X FADRI , 145
X FADRM , 146

X FDV   , 170
X FDVB  , 173
X FDVL  , 171
X FDVM  , 172

X FDVR  , 174
X FDVRB , 177
X FDVRI , 175
X FDVRM , 176

XF FIN.  , 021

   IFN STANSW,<X FIX   , 130>
   IFE STANSW,<XK FIX   , 122>
XK FIXR  , 126
XK FLTR  , 127

X FMP   , 160
X FMPB  , 163
X FMPL  , 161
X FMPM  , 162
X FMPR  , 164
X FMPRB , 167
X FMPRI , 165
X FMPRM , 166

X FSB   , 150
X FSBB  , 153
X FSBL  , 151
X FSBM  , 152

X FSBR  , 154
X FSBRB , 157
X FSBRI , 155
X FSBRM , 156

X FSC   , 132

X GETSTS, 062



X HALT  , 725
X HISEG , 706

X HLL   , 500
X HLLE  , 530
X HLLEI , 531
X HLLEM , 532
X HLLES , 533
X HLLI  , 501
X HLLM  , 502
X HLLO  , 520
X HLLOI , 521
X HLLOM , 522
X HLLOS , 523
X HLLS  , 503
X HLLZ  , 510
X HLLZI , 511
X HLLZM , 512
X HLLZS , 513

X HLR   , 544
X HLRE  , 574
X HLREI , 575
X HLREM , 576
X HLRES , 577
X HLRI  , 545
X HLRM  , 546
X HLRO  , 564
X HLROI , 565
X HLROM , 566
X HLROS , 567
X HLRS  , 547
X HLRZ  , 554
X HLRZI , 555
X HLRZM , 556
X HLRZS , 557



X HRL   , 504
X HRLE  , 534
X HRLEI , 535
X HRLEM , 536
X HRLES , 537
X HRLI  , 505
X HRLM  , 506
X HRLO  , 524
X HRLOI , 525
X HRLOM , 526
X HRLOS , 527
X HRLS  , 507
X HRLZ  , 514
X HRLZI , 515
X HRLZM , 516
X HRLZS , 517

X HRR   , 540
X HRRE  , 570
X HRREI , 571
X HRREM , 572
X HRRES , 573
X HRRI  , 541
X HRRM  , 542
X HRRO  , 560
X HRROI , 561
X HRROM , 562
X HRROS , 563
X HRRS  , 543
X HRRZ  , 550
X HRRZI , 551
X HRRZM , 552
X HRRZS , 553

X IBP   , 133

X IDIV  , 230
X IDIVB , 233
X IDIVI , 231
X IDIVM , 232

X IDPB  , 136

X IF1   , 726
X IF2   , 727
X IFB   , 730
X IFDEF , 731
X IFDIF , 732
X IFE   , 733
X IFG   , 734
X IFGE  , 735
X IFIDN , 736
X IFL   , 737
X IFLE  , 740
X IFN   , 741
X IFNB  , 742
X IFNDEF, 743

X ILDB  , 134

X IMUL  , 220
X IMULB , 223
X IMULI , 221
X IMULM , 222

X IN    , 056
XF IN.   , 016
X INBUF , 064
XF INF.  , 026
X INIT  , 041
X INPUT , 066
X INTEGE, 772

X INTERN, 744

X IOR   , 434
X IORB  , 437
X IORI  , 435
X IORM  , 436


X IOWD  , 745
X IRP   , 746
X IRPC  , 747
X JCRY  , 750
X JCRY0 , 751
X JCRY1 , 752
X JEN   , 753

X JFCL  , 255

X JFFO  , 243
X JFOV  , 765
X JOV   , 754

X JRA   , 267
X JRST  , 254

X JRSTF , 755

X JSA   , 266
X JSP   , 265
X JSR   , 264
X JSYS  , 104

X JUMP  , 320
X JUMPA , 324
X JUMPE , 322
X JUMPG , 327
X JUMPGE, 325
X JUMPL , 321
X JUMPLE, 323
X JUMPN , 326

X LALL  , 756

X LDB   , 135

X LIST  , 757
X LIT   , 760
X LOC   , 761

X LOOKUP, 076

X LSH   , 242
X LSHC  , 246
XK MAP   , 257
X MLOFF , 767
X MLON  , 766
X MOVE  , 200
X MOVEI , 201
X MOVEM , 202
X MOVES , 203
X MOVM  , 214
X MOVMI , 215
X MOVMM , 216
X MOVMS , 217
X MOVN  , 210
X MOVNI , 211
X MOVNM , 212
X MOVNS , 213
X MOVS  , 204
X MOVSI , 205
XL MOVSLJ, 016
X MOVSM , 206
XL MOVSO , 014
XL MOVSRJ, 017
X MOVSS , 207
XL MOVST , 015


X MTAPE , 072
XF MTOP. , 024

X MUL   , 224
X MULB  , 227
X MULI  , 225
X MULM  , 226
XF NLI.  , 031
XF NLO.  , 032

X NOSYM , 762



X OCT   , 763
X OPDEF , 764

X OPEN  , 050

X OR    , 434
X ORB   , 437
X ORCA  , 454
X ORCAB , 457
X ORCAI , 455
X ORCAM , 456
X ORCB  , 470
X ORCBB , 473

X ORCBI , 471
X ORCBM , 472
X ORCM  , 464
X ORCMB , 467
X ORCMI , 465
X ORCMM , 466
X ORI   , 435
X ORM   , 436

X OUT   , 057
XF OUT.  , 017
X OUTBUF, 065
XF OUTF. , 027
X OUTPUT, 067



X PAGE  , 700
X PASS2 , 701
X PHASE , 702
X POINT , 703

X POP   , 262
X POPJ  , 263
X PORTAL, 760

X PRGEND, 714
X PRINTX, 704
X PURGE , 705

X PUSH  , 261
X PUSHJ , 260

X RADIX , 706
X RADIX5, 707

XL RDCLK , 052
X RELEAS, 071

X RELOC , 710
X REMARK, 711

X RENAME, 055

X REPEAT, 712

XF RESET., 015
X RIM   , 715
X RIM10 , 735
X RIM10B, 736

X ROT   , 241
X ROTC  , 245

X RSW   , 716
XF RTB.  , 022
X SALL  , 720
X SEARCH, 721

X SETA  , 424
X SETAB , 427
X SETAI , 425
X SETAM , 426
X SETCA , 450
X SETCAB, 453
X SETCAI, 451
X SETCAM, 452
X SETCM , 460
X SETCMB, 463
X SETCMI, 461
X SETCMM, 462
X SETM  , 414
X SETMB , 417
X SETMI , 415
X SETMM , 416
X SETO  , 474
X SETOB , 477
X SETOI , 475
X SETOM , 476
X SETSTS, 060
X SETZ  , 400
X SETZB , 403
X SETZI , 401
X SETZM , 402

X SIXBIT, 717

X SKIP  , 330
X SKIPA , 334
X SKIPE , 332
X SKIPG , 337
X SKIPGE, 335
X SKIPL , 331
X SKIPLE, 333
X SKIPN , 336

XF SLIST., 025

X SOJ   , 360
X SOJA  , 364
X SOJE  , 362
X SOJG  , 367
X SOJGE , 365
X SOJL  , 361
X SOJLE , 363
X SOJN  , 366

X SOS   , 370
X SOSA  , 374
X SOSE  , 372
X SOSG  , 377
X SOSGE , 375
X SOSL  , 371
X SOSLE , 373
X SOSN  , 376

   IFN STANSW,<X SPCWAR,43>
X SQUOZE, 707

X STATO , 061
X STATUS, 062
X STATZ , 063

X STOPI , 722

X SUB   , 274
X SUBB  , 277
X SUBI  , 275
X SUBM  , 276

   IF2,<IFE OPHSH,<SUBTL:>>
X SUBTTL, 723
X SUPPRE, 713
X SYN   , 724
X TAPE  , 725



X TDC   , 650
X TDCA  , 654
X TDCE  , 652
X TDCN  , 656
X TDN   , 610
X TDNA  , 614
X TDNE  , 612
X TDNN  , 616
X TDO   , 670
X TDOA  , 674
X TDOE  , 672
X TDON  , 676
X TDZ   , 630
X TDZA  , 634
X TDZE  , 632
X TDZN  , 636

X TITLE , 726

X TLC   , 641
X TLCA  , 645
X TLCE  , 643
X TLCN  , 647
X TLN   , 601
X TLNA  , 605
X TLNE  , 603
X TLNN  , 607
X TLO   , 661
X TLOA  , 665
X TLOE  , 663
X TLON  , 667
X TLZ   , 621
X TLZA  , 625
X TLZE  , 623
X TLZN  , 627



X TRC   , 640
X TRCA  , 644
X TRCE  , 642
X TRCN  , 646
X TRN   , 600
X TRNA  , 604
X TRNE  , 602
X TRNN  , 606
X TRO   , 660
X TROA  , 664
X TROE  , 662
X TRON  , 666
X TRZ   , 620
X TRZA  , 624
X TRZE  , 622
X TRZN  , 626

X TSC   , 651
X TSCA  , 655
X TSCE  , 653
X TSCN  , 657
X TSN   , 611
X TSNA  , 615
X TSNE  , 613

X TSNN  , 617
X TSO   , 671
X TSOA  , 675
X TSOE  , 673
X TSON  , 677
X TSZ   , 631
X TSZA  , 635
X TSZE  , 633
X TSZN  , 637
X TTCALL, 051
X TWOSEG, 731
X UFA   , 130
X UGETF , 073
X UJEN  , 100
X UNIVER, 737
X USETI , 074
X USETO , 075

X VAR   , 727

XF WTB.  , 023

X XALL  , 732

X XCT   , 256

X XLIST , 733

X XOR   , 430
X XORB  , 433
X XORI  , 431
X XORM  , 432

X XPUNGE, 730
X XWD   , 734

X Z     , 000

X .ASSIG, 751
X .COMMO, 747
X .CREF , 740
X .DIREC, 750
   IFN POLISH,<
X .ENDPS, 762
   >
X .HWFRM, 742
X .IF   , 756
X .IFN  , 757
X .LINK , 753
X .LNKEN, 754
X .MFRMT, 743
X .NODDT, 746
X .ORG  , 752
   IFN POLISH,<
X .PSECT, 761
   >
X .REQUE, 744
X .REQUI, 745
X .TEXT , 755
X .XCREF, 741

   IFE OPHSH,<
   IF1, < BLOCK N1>
OP1END:	-1B36
OP1COD:	BLOCK N1/4
	CC
 IF2,< PURGE N1,N2>
   >
   IFN OPHSH,<
   IF2,<
DEFINE SETVAL (N)<EXP .%'N
PURGE .%'N>
N=0
XLIST
REPEAT PRIME,<SETVAL \N
N=N+1>
LIST
   >
OP1COD:	IF1,< BLOCK <PRIME/4+1>>
   IF2,<
DEFINE SETVAL (N)<EXP .$'N
PURGE .$'N>
N=0
XLIST
REPEAT <PRIME/4+1>,<SETVAL \N
N=N+1>
   >
LIST>

	.CREF			;START CREFFING AGAIN


	SUBTTL PERMANENT SYMBOLS

SYMNUM:	EXP LENGTH/2		;NUMBER OF PERMANENT SYMBOLS

DEFINE PSYM (A,B)<
	XLIST
	SIXBIT /A/
	XWD SYMF!NOOUTF,B
	LIST>

	PSYM @, 0(SUPRBT)
	PSYM ??????, 0(SUPRBT)

LENGTH= .-SYMNUM-1		;LENGTH OF INITIAL SYMBOLS

PRMTBL:				;PERMANENT SYMBOLS
	PSYM ADC, 24
	PSYM ADC2, 30
	PSYM APR, 0
	PSYM CCI, 14
	PSYM CDP, 110
	PSYM CDR, 114
	PSYM CLK, 70
	PSYM CLK2, 74
	PSYM CPA, 0
	PSYM CR, 150
	PSYM CR2, 154
	PSYM DC, 200
	PSYM DC2, 204
	PSYM DCSA, 300
	PSYM DCSB, 304
	PSYM DDC, 270
	PSYM DDC2, 274
	PSYM DF, 270
	PSYM DIS, 130
	PSYM DIS2, 134
	PSYM DLB, 60
	PSYM DLB2, 160
	PSYM DLC, 64
	PSYM DLC2, 164
	PSYM DLS, 240
	PSYM DLS2, 244
	PSYM DPC, 250
	PSYM DPC2, 254
	PSYM DPC3, 260
	PSYM DPC4, 264
	PSYM DSI, 464
	PSYM DSI2, 474
	PSYM DSK, 170
	PSYM DSK2, 174
	PSYM DSS, 460
	PSYM DSS2, 470
	PSYM DTC, 320
	PSYM DTC2, 330
	PSYM DTS, 324
	PSYM DTS2, 334
	PSYM LPT, 124
	PSYM LPT2, 234
	PSYM MDF, 260
	PSYM MDF2, 264
	PSYM MTC, 220
	PSYM MTM, 230
	PSYM MTS, 224
	PSYM PAG, 10
	PSYM PI, 4
	PSYM PLT, 140
	PSYM PLT2, 144
	PSYM PTP, 100
	PSYM PTR, 104
	PSYM TMC, 340
	PSYM TMC2, 350
	PSYM TMS, 344
	PSYM TMS2, 354
	PSYM TTY, 120
	PSYM UTC, 210
	PSYM UTS, 214
PRMEND:				;END OF PERMANENT SYMBOLS



	OPDEF ZL [Z LITF]	;INVALID IN LITERALS
	OPDEF ZA [Z ADDF]	;INVALID IN ADDRESSES
	OPDEF ZAL [Z ADDF!LITF]

OP1TAB:

	ZA PAGE0		;PAGE
	ZAL PASS20		;PASS2
	ZAL PHASE0		;PHASE
	Z POINT0		;POINT
	ZA PRNTX0		;PRINTX
	ZA PURGE0		;PURGE
	ZA RADIX0		;RADIX
	Z RADX50		;RADIX50,SQUOZE
	ZAL %ORG (1)		;RELOC
	ZAL REMAR0		;REMARK
	ZA REPEA0		;REPEAT
	ZA SUPRE0		;SUPRESS
	ZAL PSEND0		;PRGEND
	ZAL RIM0 (RIMSW)	;RIM
	DATAI 0,IOP		;RSW
	Z ASCII0 (1)		;SIXBIT
	ZAL IOSET (IOPALL!IOSALL) ;SALL
	ZAL SERCH0		;SEARCH
	ZA STOPI0		;STOPI
	ZA SUBTT0 (Z (POINT 7,,)) ;SUBTTL
	ZA SYN0			;SYN
	ZAL TAPE0		;TAPE
	ZA TITLE0 (Z (POINT 7,,)) ;TITLE
	ZAL VAR0		;VAR

	Z XPUNG0		;XPUNGE
	ZAL TWSEG0		;TWOSEGMENTS
	ZAL XALL0 (IOPALL)	;XALL
	ZAL XALL0 (IOPROG)	;XLIST
	Z XWD0			;XWD
	ZAL RIM0 (RIM1SW)	;RIM10
	ZAL RIM0 (R1BSW)	;RIM10B
	ZA UNIV0 (Z (POINT 7,,)) ;UNIVERSAL
	ZAL ONCRF (IONCRF)	;.CREF
	ZAL OFFCRF (IONCRF)	;.XCREF
	ZA OFFORM		;.HWFRMT
	ZA ONFORM		;.MFRMT
	ZAL REQUEST		;.REQUEST
	ZAL REQUIRE		;.REQUIRE
	ZA NODDT0		;.NODDT
	ZAL COMM0		;.COMMON
	ZAL %DIREC		;.DIRECTIVE
	ZA ASGN			;.ASSIGN
	ZAL %ORG (1B18)		;.ORG
	ZAL %LINK (0)		;.LINK
	ZAL %LINK (1B18)	;.LNKEND
	Z %TEXT0 (1B18+1B21)	;.TEXT
	Z %IF			;.IF
	Z %IFN			;.IFN
	JRST 1,OP		;PORTAL
   IFN POLISH,<
	ZA %SEGME		;.PSECT
	ZA %ENDSE		;.ENDPS
   >

OP2TAB:

	Z ASCII0 (0)		;ASCII
	Z ASCII0 (1B18)		;ASCIZ
	BLKI IOP		;BLKI
	BLKO IOP		;BLKO
	ZAL BLOCK0		;BLOCK
	ZA SUPRSA		;ASUPPRESS
	ZAL HISEG0		;HISEG
	Z BYTE0			;BYTE
	CONI IOP		;CONI
	CONO IOP		;CONO
	CONSO IOP		;CONSO
	CONSZ IOP		;CONSZ
	DATAI IOP		;DATAI
	DATAO IOP		;DATAO
	Z OCT0 (^D10)		;DEC
	ZA DEFIN0		;DEFINE

	ZAL DEPHA0		;DEPHASE
	ZAL END0		;END
	ZA INTER0 (INTF!ENTF)	;ENTRY
	Z EXPRES		;EXP
	ZA EXTER0		;EXTERN
	JRST 4,OP		;HALT
	TLNN FR,IFPASS		;IF1
	TLNE FR,IFPASS		;IF2

	TRNE AC0,IFB0		;IFB
	TLNE ARG,IFDEF0		;IFDEF
	Z IFIDN0 (0)		;IFDIF
	SKIPE IF		;IFE
	SKIPG IF		;IFG
	SKIPGE IF		;IFGE
	Z IFIDN0 (1)		;IFIDN
	SKIPL IF		;IFL

	SKIPLE IF		;IFLE
	SKIPN IF		;IFN
	TRNN AC0,IFB0		;IFNB
	TLNN ARG,IFDEF0		;IFNDEF
	ZA INTER0 (INTF)	;INTERN
	Z IOWD0			;IOWD
	Z IRP0 (0)		;IRP
	Z IRP0 (400000)		;IRPC

	JFCL 6,OP		;JCRY
	JFCL 4,OP		;JCRY0
	JFCL 2,OP		;JCRY1
	JRST 12,OP		;JEN
	JFCL 10,OP		;JOV
	JRST 2,OP		;JRSTF
	ZAL IOLSET (IOPALL!IOSALL) ;[327] LALL
	ZAL IORSET (IOPROG)	;LIST
	ZAL LIT0		;LIT
	ZAL %ORG (0)		;LOC
	ZA OFFSYM		;NOSYM
	Z OCT0 (^D8)		;OCT
	ZA OPDEF0		;OPDEF
	JFCL 1,OP		;JFOV
	ZA ONML			;MLON
	ZA OFFML		;MLOFF
	Z ASCII0 (3B19)		;COMMENT
	ZAL %ARAY		;ARRAY
	ZAL %INTEG		;INTEGER
	ZAL %LINK (0)		;LINK
	ZAL %LINK (1B18)	;LNKEND
	ZAL %ORG (1B18)		;ORG
	ZA ASGN			;ASSIGN
   IFN IIISW,<
	Z ASCII0 (5B20)>	;ASCID


   IFN UUOSYM,<
CALTBL:
				;USER DEFINED CALLI'S GO HERE
	SIXBIT /LIGHTS/		;-1
CALLI0:	SIXBIT /RESET/		; 0
	SIXBIT /DDTIN/		; 1
	SIXBIT /SETDDT/		; 2
	SIXBIT /DDTOUT/		; 3
	SIXBIT /DEVCHR/		; 4
	SIXBIT /DDTGT/		; 5
	SIXBIT /GETCHR/		; 6
	SIXBIT /DDTRL/		; 7
	SIXBIT /WAIT/		;10
	SIXBIT /CORE/		;11
	SIXBIT /EXIT/		;12
	SIXBIT /UTPCLR/		;13
	SIXBIT /DATE/		;14
	SIXBIT /LOGIN/		;15
	SIXBIT /APRENB/		;16
	SIXBIT /LOGOUT/		;17
	SIXBIT /SWITCH/		;20
	SIXBIT /REASSI/		;21
	SIXBIT /TIMER/		;22
	SIXBIT /MSTIME/		;23
	SIXBIT /GETPPN/		;24
	SIXBIT /TRPSET/		;25
	SIXBIT /TRPJEN/		;26
	SIXBIT /RUNTIM/		;27
	SIXBIT /PJOB/		;30
	SIXBIT /SLEEP/		;31
	SIXBIT /SETPOV/		;32
	SIXBIT /PEEK/		;33
	SIXBIT /GETLIN/		;34
	SIXBIT /RUN/		;35
	SIXBIT /SETUWP/		;36
	SIXBIT /REMAP/		;37
	SIXBIT /GETSEG/		;40
	SIXBIT /GETTAB/		;41
	SIXBIT /SPY/		;42
	SIXBIT /SETNAM/		;43
	SIXBIT /TMPCOR/		;44
	SIXBIT /DSKCHR/		;45
	SIXBIT /SYSSTR/		;46
	SIXBIT /JOBSTR/		;47
	SIXBIT /STRUUO/		;50
	SIXBIT /SYSPHY/		;51
	SIXBIT /FRECHN/		;52
	SIXBIT /DEVTYP/		;53
	SIXBIT /DEVSTS/		;54
	SIXBIT /DEVPPN/		;55
	SIXBIT /SEEK/		;56
	SIXBIT /RTTRP/		;57
	SIXBIT /LOCK/		;60
	SIXBIT /JOBSTS/		;61
	SIXBIT /LOCATE/		;62
	SIXBIT /WHERE/		;63
	SIXBIT /DEVNAM/		;64
	SIXBIT /CTLJOB/		;65
	SIXBIT /GOBSTR/		;66
	0			;67
	0			;70
	SIXBIT /HPQ/		;71
	SIXBIT /HIBER/		;72
	SIXBIT /WAKE/		;73
	SIXBIT /CHGPPN/		;74
	SIXBIT /SETUUO/		;75
	SIXBIT /DEVGEN/		;76
	SIXBIT /OTHUSR/		;77
	SIXBIT /CHKACC/		;100
	SIXBIT /DEVSIZ/		;101
	SIXBIT /DAEMON/		;102
	SIXBIT /JOBPEK/		;103
	SIXBIT /ATTACH/		;104
	SIXBIT /DAEFIN/		;105
	SIXBIT /FRCUUO/		;106
	SIXBIT /DEVLNM/		;107
	SIXBIT /PATH./		;110
	SIXBIT /METER./		;111
	SIXBIT /MTCHR./		;112
	SIXBIT /JBSET./		;113
	SIXBIT /POKE./		;114
	SIXBIT /TRMNO./		;115
	SIXBIT /TRMOP./		;116
	SIXBIT /RESDV./		;117
	SIXBIT /UNLOK./		;120
	SIXBIT /DISK./		;121
	SIXBIT /DVRST./		;122
	SIXBIT /DVURS./		;123
	SIXBIT /XTTSK./		;124
	SIXBIT /CAL11./		;125
	SIXBIT /MTAID./		;126
	SIXBIT /IONDX./		;127
	SIXBIT /CNECT./		;130
	SIXBIT /MVHDR./		;131
	SIXBIT /ERLST./		;132
	SIXBIT /SENSE./		;133
	SIXBIT /CLRST./		;134
	SIXBIT /PIINI./		;135
	SIXBIT /PISYS./		;136
	SIXBIT /DEBRK./		;137
	SIXBIT /PISAV./		;140
	SIXBIT /PIRST./		;141
	SIXBIT /IPCFR./		;142
	SIXBIT /IPCFS./		;143
	SIXBIT /IPCFQ./		;144
	SIXBIT /PAGE./		;145
	SIXBIT /SUSET./		;146
	SIXBIT /COMPT./		;147
	SIXBIT /SCHED./		;150
	SIXBIT /ENQ./		;151
	SIXBIT /DEQ./		;152
	SIXBIT /ENQC./		;153
	SIXBIT /TAPOP./		;154
	SIXBIT /FILOP./		;155
	SIXBIT /CAL78./		;156
	SIXBIT /NODE./		;157
	SIXBIT /ERRPT./		;160
	SIXBIT /ALLOC./		;161
	SIXBIT /PERF./		;162
CALNTH==.-CALTBL
NEGCAL==CALLI0-CALTBL		;NUMBER OF NEGATIVE CALLI'S

TTCTBL:	SIXBIT /INCHRW/		; 0 INPUT A CHAR. AND WAIT
	SIXBIT /OUTCHR/		; 1 OUTPUT A CHAR.
	SIXBIT /INCHRS/		; 2 INPUT A CHAR. AND SKIP
	SIXBIT /OUTSTR/		; 3 OUTPUT A STRING
	SIXBIT /INCHWL/		; 4 INPUT CHAR., WAIT, LINE MODE
	SIXBIT /INCHSL/		; 5 INPUT CHAR., SKIP, LINE MODE
	SIXBIT /GETLCH/		; 6 GET LINE CHARACTERISTICS
	SIXBIT /SETLCH/		; 7 SET LINE CHARACTERISTICS
	SIXBIT /RESCAN/		;10 RESET INPUT STREAM TO COMMAND
	SIXBIT /CLRBFI/		;11 CLEAR TYPEIN BUFFER
	SIXBIT /CLRBFO/		;12 CLEAR TYPEOUT BUFFER
	SIXBIT /SKPINC/		;13 SKIPS IF A CHAR. CAN BE INPUT
	SIXBIT /SKPINL/		;14 SKIPS IF A LINE CAN BE INPUT
	SIXBIT /IONEOU/		;15 OUTPUT AS AN IMAGE CHAR.

TTCLTH==.-TTCTBL

MTATBL:	SIXBIT /MTWAT./		;  0
	SIXBIT /MTREW./		;  1
	SIXBIT /MTEOF./		;  3
	SIXBIT /MTSKR./		;  6
	SIXBIT /MTBSR./		;  7
	SIXBIT /MTEOT./		; 10
	SIXBIT /MTUNL./		; 11
	SIXBIT /MTBLK./		; 13
	SIXBIT /MTSKF./		; 16
	SIXBIT /MTBSF./		; 17
	SIXBIT /MTDEC./		;100
	SIXBIT /MTIND./		;101

MTALTH==.-MTATBL

MTACOD:	BYTE (9) 0,1,3,6
	BYTE (9) 7,10,11,13
	BYTE (9) 16,17,100,101
   >			;END UUOSYM

	SUBTTL USER-DEFINED SYMBOL SEARCH ROUTINES

;SEARCH FOR OPERATOR DEFINITION (MACRO, SYN, OPDEF)

MSRCH:	CALL SEARCH		;PERFORM GENERAL SEARCH
	  RET			;NOT FOUND, EXIT
	JUMPG ARG,MSRCH2	;SKIP-EXIT AND CROSS-REF IF FOUND
	CAME AC0,1(SX)		;WE ARE LOOKING AT SYMBOL, TRY ONE ABOVE
	RET			;NO, EXIT
	ADDI SX,2		;YES, POINT TO IT
	SETZM EXTPNT		;[324] RESET EXTERNAL POINTER WORD
	CALL SRCH5		;LOAD REGISTERS
MSRCH2:	AOSA 0(P)		;SET SKIP-EXIT
QSRCH:	JUMPL ARG,SSRCH3	;BRANCH IF OPERAND
	TLC ARG,SIXF		;[542] DO WE HAVE A SIXF?
	TLCN ARG,SIXF		;[542]
	CALL SYNFIX		;[542] YES, GO TAKE CARE OF IT FIRST
QSRCH1:	MOVEI SDEL,%MAC		;[542] SET OPERATOR FLAG
	TLZE IO,DEFCRS		;IS IT A DEFINITION?
	MOVEI SDEL,%DMAC	;YES
	JRST CREF		;CROSS-REF AND EXIT

;HERE IF WE HAVE A SYN AND ITS VALUE IS A POINTER TO A SIXBIT OPERATOR NAME
SYNFIX:	PUSH P,AC0		;[542] SAVE CURRENT SYMBOL
	MOVE AC0,(ARG)		;[542] AND GET SIXBIT SYMBOL NAME
	PUSH P,ARG		;[542] SAVE SIXBIT POINTER
	CALL OPTSCH		;[542] GET ITS VALUE
	  JRST [TRO ER,ERRA	;[542] GIVE A-ERROR
		JRST SYNFI1]	;[542]
	POP P,ARG		;[542] RESTORE POINTER
	SKIPE UWVER		;[542] WRITING A UNV FILE?
	JRST SYNFI1		;[542]  YES, JUMP, DON'T UPDATE SYMBOL TABLE
	MOVEM V,(ARG)		;[542] NO, REPLACE SIXBIT WITH OPERATOR VALUE
	MOVSI ARG,SYNF+PNTF	;[542] SET FLAGS
	HLLM ARG,(SX)		;[542] UPDATE IN SYMBOL TABLE
SYNFI1:	POP P,AC0		;[542] RESTORE SYMBOL NAME
	RET			;[542]

;SEARCH FOR SYMBOL DEFINITION

SSRCH:	CALL SEARCH		;PERFORM GENERAL SEARCH
	RET			;NOT FOUND, EXIT
	JUMPL ARG,SSRCH2	;SKIP-EXIT AND CROSS-REF IF FOUND
SSRCH1:	CAME AC0,-3(SX)		;WE ARE LOOKING AT MACRO, LOOK ONE SLOT BELOW
	RET			;NO DICE, EXIT
	SUBI SX,2		;YES, POINT TO IT
	SETZM EXTPNT		;[324] RESET EXTERNAL POINTERS WORD
	CALL SRCH5		;LOAD REGISTERS
SSRCH2:	AOS 0(P)		;SET FOR SKIP-EXIT
SSRCH3:	MOVEI SDEL,%SYM		;SET OPERAND FLAG

CREF:	TLNE ARG,NCRF		; .XCREF SEEN?
	JRST [TLZ IO,DEFCRS	; CLEAR DEFINITION FLAG
		RET]		; AND DON'T CREF
	TLNN IO,IONCRF		;NO CREFFING FOR THIS SYMBOL?
	TLNE FR,P1!CREFSW	;PASS ONE OR CROSS-REF SUPPRESSION?
	RET			;YES, EXIT
	EXCH SDEL,C		;PUT FLAG IN C, SACE C
	PUSH P,CS
	TLNE IO,IOCREF		;HAVE WE PUT OUT THE 177,102
	JRST CREF3		;YES
	PUSH P,C		;START OF CREF DATA

REPEAT 0,<			;NEEDS CHANGE TO CREF
	MOVEI C,177
	CALL OUTLST
	MOVEI C,102
	CALL OUTLST
	TLO IO,IOCREF		;WE NOW ARE IN THAT STATE
	POP P,C			;WE HAVE NOW
CREF3:	JUMPE C,NOFLG		;JUST CLOSE IT
	CALL OUTLST		;TYPE OF SYMBOL (%MAC,%DMAC,%SYM)
	MOVSI CS,770000		;COUNT CHRS
	TDZA C,C		;STARTING AT 0
	LSH CS,-6		;TRY NEXT
	TDNE AC0,CS		;IS THAT ONE THERE?
	AOJA  C,.-2		;YES
	CALL OUTLST		;PRINT NUMBER OF SYMBOL CONSTITUENTS
	MOVE CS,AC0

CREF2:	MOVEI C,0
	LSHC C,6
	ADDI C,40
	CALL OUTLST		;THE ASCII SYMBOL
	JUMPN CS,CREF2
	MOVEI C,%DSYM
	TLZE IO,DEFCRS
	CALL OUTLST		;MARK IT AS A DEFINING OCCURENCE
NOFLG:	MOVE C,SDEL
	POP P,CS
	RET

CLSCRF:	TRNN ER,LPTSW
	RET			;LEAVE IF WE SHOULD NOT BE PRINTING
CLSCR2:	MOVEI C,177
	CALL PRINT
	TLZE IO,IOCREF		;WAS IT OPEN?
	JRST CLSCR1		;YES, JUST CLOSE IT
	MOVEI C,102		;NO, OPEN IT FIRST
	CALL OUTLST		;MARK BEGINNING OF CREF DATA
	MOVEI C,177
	CALL OUTLST
CLSCR1:	MOVEI C,103
	JRST OUTLST		;MARK END OF CREF DATA

CLSC3:	TLZ IO,IOCREF
	MOVEI C,177
	CALL OUTLST
	MOVEI C,104
	JRST OUTLST		;177,104 CLOSES IT FOR NOW
   >				;END OF REPEAT 0


REPEAT 1,<			;WORKS WITH EXISTING CREF
	TLNE IO,IOPAGE
	CALL CRFHDR		;GET CORRECT SUBTTL
	MOVEI C,177
	CALL OUTLST
	MOVEI C,102
	CALL OUTLST
	TLO IO,IOCREF		;WE NOW ARE IN THAT STATE
	POP P,C			;WE HAVE NOW
CREF3:	CALL OUTLST		;TYPE OF SYMBOL (%MAC,%DMAC,%SYM)
	MOVSI CS,770000		;COUNT CHRS
	TDZA C,C		;STARTING AT 0
	LSH CS,-6		;TRY NEXT
	TDNE AC0,CS		;IS THAT ONE THERE?
	AOJA C,.-2		;YES
	CALL OUTLST		;PRINT NUMBER OF SYMBOL CONSTITUENTS
	MOVE CS,AC0

CREF2:	MOVEI C,0
	LSHC C,6
	ADDI C,40
	CALL OUTLST		;THE ASCII SYMBOL
	JUMPN CS,CREF2
	MOVEI C,%DSYM
	TLZE IO,DEFCRS
	CALL OUTLST		;MARK IT AS A DEFINING OCCURENCE
	MOVE C,SDEL
	POP P,CS
	RET

   IFN OPHSH,<
SUBTL:	SIXBIT /SUBTTL/>
CRFHDR:	CAME AC0,SUBTL		;IS FIRST SYMBOL "SUBTTL"
	JRST CRFHD1		;NO
	HLLZ AC0,V
	CALL SUBTT0		;UPDATE SUBTTL
	MOVE AC0,SUBTL		;RESTORE ARG.
	MOVEI V,CPOPJ
CRFHD1:	MOVEI C,0
	JRST OUTL

CLSC3:
CLSCRF:	TRNN ER,LPTSW
	RET			;LEAVE IF WE SHOULD NOT BE PRINTING
CLSCR2:	TLZE  IO,IOCREF		;FINISH UP LINE
	JRST CLSCR1
	MOVEI C,0
	TLNE IO,IOPAGE		;NEW PAGE?
	CALL OUTL		;YES,GIVE IT A ROUSING SENDOFF!
	MOVEI C,177
	CALL OUTLST
	MOVEI C,102
	CALL OUTLST		;MARK BEGINNING OF CREF DATA
CLSCR1:	TRNN ER,ERRORS		;ANY ERRORS TO CREF
	JRST CLSCR6		;NO, JUST CLOSE OUT
	MOVE C,[POINT 6,[SIXBIT /QXADLRUVNOPEMS/]]
	PUSH P,ER		;SAVE 
	ANDI ER,ERRORS		;ONLY LOOK AT THESE
	HRLZ ER,ER		;PUT FLAGS IN LEFT HALF
CLSCR4:	ILDB CS,C		;GET NEXT ERROR CODE
	LSH ER,1		;SHIFT FLAG IN
	JUMPE ER,CLSCR5		;FINISHED
	JUMPG ER,CLSCR4		;NOT YET
	PUSH P,C		;SAVE BYTE POINTER
	TDO CS,['%.... ']	;MAGIC SYMBOL
	MOVEI C,%ERR		;TYPE
	CALL OUTLST
	MOVEI C,6		;NO OF CHARS.
	CALL OUTLST
	SETZ C,			;CLEAR RECEIVING ACC
	LSHC C,6		;SHIFT IN CHAR
	ADDI C,40		;TO ASCII
	CALL OUTLST
	JUMPN CS,.-4		;MORE TO DO
	POP P,C			;BYTE POINTER BACK
	JUMPN ER,CLSCR4		;GET NEXT
CLSCR5:	POP P,ER		;RESTORE ER
CLSCR6:	MOVEI C,177
	CALL OUTLST
	MOVEI C,103
	JRST OUTLST		;MARK END OF CREF DATA
   >				;END OF REPEAT 1

RCPNTR:	POINT 1,ARG,^L<RELF>-18	;POINT 1,ARG,22

   IFE POLISH,<
SEARCH:	HLRZ SX,SRCHX
	HRRZ SDEL,SRCHX

SRCH1:	CAML AC0,-1(SX)
	JRST SRCH3
SRCH2:	SUB SX,SDEL
	LSH SDEL,-1
	CAMG SX,SYMTOP
	JUMPN SDEL,SRCH1
	JUMPN SDEL,SRCH2
	SOJA SX,SRCHNO		;NOT FOUND

SRCH3:	CAMN AC0,-1(SX)
	JRST SRCH4		;NORMAL / FOUND EXIT
	ADD SX,SDEL
	LSH SDEL,-1
	CAMG SX,SYMTOP
	JUMPN SDEL,SRCH1
	JUMPN SDEL,SRCH2
	SOJA SX,SRCHNO		;NOT FOUND

SRCH4:	AOS 0(P)		;SET FOR SKIP EXIT
SRCH5:	MOVSI ARG,SUPRBT	;HE IS USING IT, TURN OFF BIT
	ANDCAM ARG,(SX)		; IN THE TABLE
SRCH7:	MOVE ARG,0(SX)		;FLAG AND VALUE TO ARG
	LDB RC,RCPNTR		;POINT 1,ARG,17
	TLNE ARG,LELF		;CHECK LEFT RELOCATE
	TLO RC,1
	HRRZ V,ARG
	TLNE ARG,SPTR		;CHECK SPECIAL EXTESN POINTER
	JRST SRCH6
	TLNE ARG,PNTF
	MOVE V,0(ARG)		;36BIT VALUE TO V
	JRST SRCHOK

SRCH6:	MOVE V,0(ARG)		;VALUE
	MOVE RC,1(ARG)		;AND RELOC
	TLNE RC,-2		;CHECK AND SET EXTPNT
	HLLM RC,EXTPNT
	TRNE RC,-2
	HRRM RC,EXTPNT
	JRST SRCHOK
SRCHNO:	SKIPN UNISCH+1		;ALLOWED TO SEARCH OTHER TABLES
	RET			;NO, JUST RETURN
	AOS V,UNISCH		;GET NEXT INDEX TO TABLE
	CAIE V,1		;FIRST TIME IN
	JRST SRCHN1		;YES, SAVE SYMBOL INFO
	HRLM SX,UNISCH		;SAVE SX AND SET FLAG
	MOVE ARG,SRCHX		;SEARCH POINTER
	MOVEM ARG,UNISHX	;TO A SAFE PLACE
	HRR ARG,SYMBOL
	HRL ARG,SYMTOP
	MOVEM ARG,UNIPTR	;STORE ALSO
SRCHN1:	MOVE V,UNISCH(V)	;GET TRUE INDEX
	JUMPE V,SRCHKO		;IF ZERO ALL TABLE SCANNED
	MOVE ARG,UNISHX(V)	;NEW SRCHX
	MOVEM ARG,SRCHX		;SET IT UP
	MOVE ARG,UNIPTR(V)	;SYMTOP,,SYMBOL
	HRRZM ARG,SYMBOL
	HLRZM ARG,SYMTOP
	JRST SEARCH		;TRY AGAIN

   >

   IFN POLISH,<
SEARCH:	CALL SRCHI		;SET UP SRCHX
	TLZ IO,RSASSW		;CLR INTER-PSECT REF SWITCH
	HRRZ AC1,SGNCUR		;GET CUR PSECT INX
	MOVEM AC1,SGWFND	;SET PSECT WHERE FOUND
	CALL SRCH		;SEARCH CURRENT PSECT
   IFE FTPSEC,<
	  JRST SRCHU		;SEE IF THERE ARE UNIVERSALS TO SEARCH
	JRST SRCH4S		;COMMON SUCCESSFUL EXIT
   >
   IFN FTPSEC,<
	  JRST SRCHSG		;NOPE TRY OTHER PSECTS
	JRST SRCH4S		;COMMON SUCCESSFUL EX

SRCHSG:	PUSH P,V		;[462] SAVE V
	PUSH P,SX		;SAVE SX VALUE
	PUSH P,SGNCUR		;SAVE SGNCUR
	PUSH P,SGNMAX		;INIT PSECT INX
SRCHSL:	MOVE V,0(P)		;GET PSECT INX
	CAMN V,-1(P)		;DON'T SEARCH CURRENT
	JRST SRCHSC		; PSECT AGAIN
	MOVEM V,SGNCUR		;FUDGE CUR PSECT
	CALL SRCHI		;SET UP SRCHX
	CALL SRCH		;SEARCH THIS PSECT
	  JRST SRCHSC		;NOT HERE EITHER
	MOVE AC1,SGNCUR		;GET RELEVANT PSECT INX
	MOVEM AC1,SGWFND	;SET PSECT WHERE FOUND
	SKIPGE -1(P)		;WANT TO EVALUATE IN THIS PSECT?
	JRST SRCH4		;YES, JUST EXIT
	MOVE ARG,0(SX)		;GET FLAGS
	TLNN ARG,EXTF		;EXTERNAL?
	JRST .+3		;NO
	TLNN ARG,SPTR		;BUT NOT SPECIAL
	JRST SRCHEX		;YES, MUST STOR IN REQUESTING PSECT
	TLNE ARG,LELF!RELF	;IF RELOCATABLE THEN
	TLO IO,RSASSW		; SET INTER-PSECT REF SWITCH
	JRST SRCH4		;COMMON SUCCESSFUL EXIT

SRCHEX:	POP P,AC1		;INDEX
	POP P,SGNCUR		;RESTORE
	POP P,SX		;WHERE IT SHOULD BE
	POP P,V			;[462]
	MOVEI SDEL,2		;NEEDS 2 WORDS
	ADDB SDEL,FREE
	CAML SDEL,SYMBOL	;WILL IT FIT?
	CALL XCEEDS		;NO
	SETZM -1(SDEL)		;VALUE
	MOVEM AC0,-1(SDEL)	;NAME
	MOVEI V,-2(SDEL)	;POINTER
	HLLZ ARG,ARG		;KEEP FLAGS BUT NOT POINTER
	CALL INSERT		;PUT IT IN
	JRST SEARCH		;TRY AGAIN

SRCHSC:	SOS V,0(P)		;BUMP PSECT INX
	JUMPGE V,SRCHSL		;LOOP IF MORE PSECTS
	POP P,AC1		;THROW AWAY PSECT INX
	POP P,SGNCUR		;RESTORE SGNCUR
	CALL SRCHI		;RESET SRCHX
	POP P,SX		;RESTORE SX VALUE
	POP P,V			;[462] RESTORE V
   >
SRCHU:	SKIPN UNISCH+1		;ALLOWED TO SEARCH OTHER TABLES
	RET			;NO, JUST RETURN
	HRLM SX,UNISCH		;SAVE SX AND SET FLAG
	MOVE ARG,SRCHX		;SEARCH POINTER
	MOVEM ARG,UNISHX	;TO A SAFE PLACE
	HRR ARG,SGSBOT
	HRL ARG,SGSTOP
	MOVEM ARG,UNIPTR	;STORE ALSO
SRCHUL:	AOS V,UNISCH		;GET NEXT INDEX TO TABLE
	MOVE V,UNISCH(V)	;GET TRUE INDEX
	JUMPE V,SRCHKO		;IF ZERO ALL TABLE SCANNED
	MOVE ARG,UNISHX(V)	;NEW SRCHX
	MOVEM ARG,SRCHX		;SET IT UP
	MOVE ARG,UNIPTR(V)	;SGSTOP,,SGSBOT
	HRRZM ARG,SGSBOT
	HLRZM ARG,SGSTOP
	CALL SRCH		;SEARCH UNIV SYM TAB
	  JRST SRCHUL		;NOPE, TRY NEXT ONE
   IFN FTPSEC,<
	JRST SRCH4S		;COMMON SUCCESSFUL EXIT

SRCH4:	POP P,AC1		;THROW AWAY PSECT INX
	POP P,SGNCUR		;RESTORE SGNCUR
	POP P,AC1		;THROW AWAY SX VALUE
	POP P,AC1		;[462] THROW AWAY V
   >
SRCH4S:	AOS 0(P)		;SET FOR SKIP EXIT
SRCH5:	MOVSI ARG,SUPRBT	;HE IS USING IT, TURN OFF BIT
	ANDCAM ARG,(SX)		; IN THE TABLE
SRCH7:	MOVE ARG,0(SX)		;FLAG AND VALUE TO ARG
	LDB RC,RCPNTR		;POINT 1,ARG,17
	TLNE ARG,LELF		;CHECK LEFT RELOCATE
	TLO RC,1
	HRRZ V,ARG
	TLNE ARG,SPTR		;CHECK SPECIAL EXTESN POINTER
	JRST SRCH6
	TLNE ARG,PNTF
	MOVE V,0(ARG)		;36BIT VALUE TO V
	JRST SRCHOK

SRCH6:	MOVE V,0(ARG)		;VALUE
	MOVE RC,1(ARG)		;AND RELOC
	TLNE RC,-2		;CHECK AND SET EXTPNT
	HLLM RC,EXTPNT
	TRNE RC,-2
	HRRM RC,EXTPNT
	JRST SRCHOK
   >

SRCHKO:	SETZ ARG,		;CLEAR ARG SO ZERO STORED
SRCHOK:	SKIPN UNISCH		;HAVE WE SEARCH OTHER TABLES
	RET			;NO, JUST RETURN
SYMBCK:	HLRZ SX,UNISCH		;RESTORE SX
	SETZM UNISCH		;CLEAR SYMBCK FLAG
	MOVE SDEL,UNISHX	;SRCHX
	MOVEM SDEL,SRCHX	;RESTORE ORIGINAL
   IFE POLISH,<
	MOVE SDEL,UNIPTR	;SYMTOP,,SYMBOL
	HRRZM SDEL,SYMBOL
	HLRZM SDEL,SYMTOP
	JUMPE ARG,CPOPJ		;TOTALLY UNDEFINED
   >
   IFN POLISH,<
	MOVE SDEL,UNIPTR	;SGSTOP,,SGSBOT
	HRRZM SDEL,SGSBOT
	HLRZM SDEL,SGSTOP
	JUMPE ARG,CPOPJ		;TOTALLY UNDEFINED
	PUSH P,SGNCUR		;SAVE CUR PSECT
	SETZM SGNCUR		;SET TO BLANK PSECT
	SETZM SGWFND		;SET PSECT WHERE FOUND
	CALL SRCHI		;SET UP SRCHX
	CALL SRCH		;SET UP SX
	  JFCL
   >
	TLNE ARG,SPTR		; SPECIAL EXTERNAL?
	JRST SYMBKS		; YES
	TLNE ARG,EXTF		;EXTERNAL?
	JRST SYMBKX		;YES, NEED 2 MORE CELLS
	TLNN ARG,PNTF		;36 BIT VALUE FLAG SET?
	JRST .+3		; NO, PUT IN TABLE AND RETURN
	TLNN V,-1		;BUT IS IT ONLY 18 BIT VALUE?
	TLZ ARG,PNTF		;YES, SO ONLY USE 18 BITS
   IFE POLISH,<
	JRST INSERT
	SYN CPOPJ,SYMBKR
   >
   IFN POLISH,<
	CALL INSERT		; STILL HAVE 0 PSECT
SYMBKR:	POP P,SGNCUR		; RESTORE CUR PSECT
	RET			;
   >

SYMBKX:	PUSH P,[EXP SYMBKR]	; RETURN ADDRESS
	PUSH P,1(ARG)		;SAVE SIXBIT NAME
	MOVSI ARG,SYMF!EXTF!PNTF ;SET ONLY THE REQUIRED FLAGS
				; PUT 2 WORDS IN CORE
SYMBKY:	CALL INSERZ		; INSERT SYMBOL IN TABLE
	MOVEI SDEL,2		;GET 2 CELLS FROM FREE CORE
	ADDB SDEL,FREE
	CAML SDEL,SYMBOL	;MORE CORE NEEDED?
	CALL XCEEDS		;YES
	HRRI ARG,-2(SDEL)	;POINTER TO VALUE
	SETZM (ARG)		;AND CLEAR IT
	POP P,1(ARG)		;STORE SIXBIT VALUE
	MOVEM ARG,(SX)		;SET FLAGS AND VALUE AS IT SHOULD BE
	RET			;RETURN

SYMBKS:	PUSH P,V		; SAVE ADDITIVE VALUE
	PUSH P,[Z SYMBKZ]	;[336] SET UP RETURN ADDRESS FOR PJRST
	PUSH P,ARG		;[323] SAVE SYMBOL'S FLAGS
	PUSH P,UNISCH+1		; ONLY SEARCH MAIN TABLE
	SETZM UNISCH+1		; ...
	PUSH P,AC0		; SAVE SYMBOL WE REALLY WANT
	MOVE ARG,1(ARG)		; GET POINTER TO DEFINING SYMBOL
   IFN POLISH,<
	JUMPL ARG,SYMBKP	;[452] JUMP IF POLISH
   >
	MOVE AC0,1(ARG)		; AND FINALLY SYMBOL
	CALL SEARCH		; SEE IF DEFINING GLOBAL IS IN TABLE
	  CALL [PUSH P,1(ARG)	;SAVE SIXBIT NAME
		MOVSI ARG,SYMF!EXTF!PNTF ;SET ONLY THE REQUIRED FLAGS
		JRST SYMBKY]	; NO, PUT IN SYMBOL TABLE
SYMBS1:	POP P,AC0		; GET SYMBOL BACK
	CALL SEARCH		; SETUP SX AGAIN
	  JFCL			; WILL ALWAYS FAIL
	POP P,UNISCH+1		; BACK TO MULTIPLE SEARCHES
	HLL ARG,0(P)		; RECOVER FLAGS
	HRRZM ARG,0(P)		; STACK POINTER TO GLOBAL
	JRST SYMBKY		;[323] AND DO DUMMY PUSHJ
SYMBKZ:				;[323] FAKE RETURN ADDRESS
	POP P,V			; GET OFFSET
	MOVEM V,0(ARG)		; STORE OFFSET
	JRST SYMBKR		; RETURN


   IFN POLISH,<
;HERE IF POLISH
SYMBKP:	PUSH P,ARG
	PUSH P,SDEL		;SAVE SDEL
	PUSH P,[-1]		;END OF LOWER LEVEL POLISH TO BE CHECKED
SYMBP4:	MOVE AC1,1(ARG)		;GET THE OPERATOR
	MOVE SDEL,DESTB-3(AC1)	;AND NUMBER OF OPERANDS
SYMBP0:	ADDI ARG,2		;GET 1ST OPERAND
	HRRZM ARG,UNVNPL	;REMEMBER CURRENT ADDRESS
	MOVE AC0,(ARG)		;GET 1ST WORD OF THE PAIR
	JUMPE AC0,SYMBP1	;IF 1ST WORD IS 0, GO ONTO NEXT PAIR
	JUMPL AC0,[PUSH P,AC0	;1ST WORD IS POLISH
		JRST SYMBP1]	;STORE LOWER LEVEL POLISH PTR ON STACK
	MOVE ARG,AC0
	MOVE AC0,1(ARG)		;GET SIXBIT SYMBOL
	PUSH P,SDEL		;SAVE NUMBER OF OPERANDS LEFT
	CALL SEARCH
	   CALL [PUSH P,1(ARG)		;NOT FOUND, GO INSERT IT
		TLO ARG,SYMF!EXTF!PNTF
		JRST SYMBKY]
	POP P,SDEL		;RESTORE NUMBER OF OPERANDS LEFT
SYMBP1:	MOVE ARG,UNVNPL	;GET CURRENT LOCATION
	SOJG SDEL,SYMBP0	;ANY MORE OPERANDS? IF YES, GO BACK
	POP P,ARG		;NO, ANY LOWER LEVEL POLISH?
	CAMN ARG,[-1]		;END?
	JRST SYMBP3		;YES,
	JRST SYMBP4

SYMBP3:	POP P,SDEL		;RESTORE ORIGINAL SDEL
	POP P,ARG		;RECOVER ORIGINAL ARG
	POP P,AC0		;AND SYMBOL
	CALL SEARCH		;SET UP SX AGAIN
	  JFCL			;WILL ALWAYS FAIL
	POP P,UNISCH+1		;BACK TO MULTIPLE SEARCH
	MOVEM ARG,0(P)		;STACK POINTER TO POLISH
	SETZ ARG,
	TLO ARG,SPTR!SYMF	;SET ONLY THE REQUIRED FLAGS
	JRST SYMBKY		;GO INSERT

   >

   IFN POLISH,<
SRCH:	HLRZ SX,SRCHX
	HRRZ SDEL,SRCHX
SRCH1:	CAML AC0,-1(SX)
	JRST SRCH3
SRCH2:	SUB SX,SDEL
	LSH SDEL,-1
	CAMG SX,SGSTOP
	JUMPN SDEL,SRCH1
	JUMPN SDEL,SRCH2
	SOJA SX,SRCHNO		;NOT FOUND
SRCH3:	CAMN AC0,-1(SX)
	JRST SRCHYE		;NORMAL / FOUND EXIT
	ADD SX,SDEL
	LSH SDEL,-1
	CAMG SX,SGSTOP
	JUMPN SDEL,SRCH1
	JUMPN SDEL,SRCH2
	SOJA SX,SRCHNO		;NOT FOUND
	SYN CPOPJ1,SRCHYE	;SKIP RETURN
	SYN CPOPJ,SRCHNO	;NON-SKIP RETURN
   >

INSERQ:	TLNE ARG,UNDF!VARF
INSERZ:	SETZB RC,V
INSERT:	CAME AC0,-1(SX)		;ARE WE LOOKING AT MATCHING MNEMONIC?
	JRST INSRT2		;NO, JUST INSERT
	JUMPL ARG,INSRT1	;YES, BRANCH IF OPERAND
	SKIPL 0(SX)		;OPERATOR, ARE WE LOOKING AT ONE?
	JRST UPDATE		;YES, UPDATE
	JRST INSRT2		;NO, INSERT

INSRT1:	SKIPG 0(SX)		;OPERAND, ARE WE LOOKING AT ONE?
	JRST UPDATE		;YES, UPDATE
	SUBI SX,2		;NO, MOVE UNDER OPERATOR AND INSERT
INSRT2:	MOVE SDEL,SYMBOL
	SUBI SDEL,2
	CAMLE SDEL,FREE
	JRST INSRT3
	CALL XCEEDS
	ADDI SDEL,2000
INSRT3:	MOVEM SDEL,SYMBOL	;MAKE ROOM FOR A TWO WORD ENTRY
	HRLI SDEL,2(SDEL)
	BLT SDEL,-2(SX)		;PUSH EVERYONE DOWN TWO LOACTIONS
   IFN POLISH,<
	MOVE AC1,SGNCUR		;CURRENT PSECT INDEX
	AOS SGSCNT(AC1)		;INCREMENT PSECT SYM COUNT
   >
	AOS @SYMBOL		;INCREMENT THE SYMBOL COUNT
	TDNE RC,[-2,,-2]	;SPECIAL LEFT OR RIGHT EXTERNAL?
	JRST INSRT5		;YES, JUMP
	TLNN V,-1		;SKIP IF V IS A 36BIT VALUE
	JRST INSRT4		;JUMP, ITS A 18BIT VALUE
	AOS SDEL,FREE		;36BIT, SO GET A CELL FROM FREE CORE
	CAML SDEL,SYMBOL	;MORE CORE NEEDED?
	CALL XCEEDS		;YES
	HRRI ARG,-1(SDEL)	;POINTER TO ARG
	MOVEM V,0(ARG)		;36BIT VALUE TO FREE CORE
	TLO ARG,PNTF		; NOTE THAT ARG IS APOINTER, NOT A 18BIT VALUE
	JRST INSRT7		; STORE SYMBOL

INSRT4:	HRR ARG,V		;18 BIT VALUE ARG
	TLNN ARG,EXTF		; POSSIBLE TO BE EXT WITH 0 RELOC SO DON'T
	TLZ ARG,PNTF		; CLEAR POINTER FLAG INCASE SET
INSRT7:	DPB RC,RCPNTR		;FIX RIGHT RELOCATION
	TLNE RC,1
	TLO ARG,LELF		;FIX LEFT RELOCATION
INSRT6:	MOVEM ARG,0(SX)		;INSERT FLAGS AND VALUE.
	MOVEM AC0,-1(SX)	;INSERT SYMBOL NAME.
	CALL SRCHI		;INITILIAZE SRCHX
	JRST QSRCH		;EXIT THROUGH CREF

INSRT5:	MOVEI SDEL,2		;GET TWO CELLS FROM FREE CORE
	ADDB SDEL,FREE
	CAML SDEL,SYMBOL	;MORE CORE NEEDED?
	CALL XCEEDS		;YES
	MOVEM RC,-1(SDEL)
	HRRI ARG,-2(SDEL)	;POINTER TO ARG
	MOVEM V,0(ARG)
	TLO ARG,SPTR		;SET SPECIAL POINTER, POINTS TO TWO CELLS
	JRST INSRT6

REMOVE:
   IFN POLISH,<
	MOVEI AC2,0(SX)		;ADDRESS OF THE SYMBOL
	SUB AC2,SYMBOL		; - BASE OF SYMBOL TABLE
	LSH AC2,-1		; / 2 = SYMBOL ORDINAL
	TDZA AC1,AC1		;INIT PSECT INDEX
	ADDI AC1,1		;INCREMENT PSECT INDEX
	HRRZ AC0,SGSCNT(AC1)	;WITHIN THIS PSECT?
	SUB AC2,AC0
	JUMPG AC2,.-3		;TRY NEXT PSECT IF NOT
	SOS SGSCNT(AC1)		;DECREMENT PSECT SYM COUNT
   >
	SUBI SX,2		;MOVE EVERYONE UP TWO LOCATIONS
REMOV1:	MOVE 0(SX)
	MOVEM 2(SX)		;OVERWRITE THE DELETED SYMBOL
	CAME SX,SYMBOL		;SKIP WHEN DONE
	SOJA SX,REMOV1
	ADDI SX,2
	MOVEM SX,SYMBOL
	SOS 0(SX)		;DECREMENT THE SYMBOL COUNT

SRCHI:	MOVEI AC2,0		;THIS CODE SETS UP SRCHX
   IFE POLISH,<
	FAD AC2,@SYMBOL
   >
   IFN POLISH,<
	HRRZ AC1,SGNCUR
	HRRZ AC1,SGSCNT(AC1)
	FAD AC2,AC1
   >
	LSH AC2,-^D27
	MOVEI AC1,1000
	LSH AC1,-357(AC2)
	HRRM AC1,SRCHX
	LSH AC1,1
   IFE POLISH,<
	ADD AC1,SYMBOL
	HRLM AC1,SRCHX
   >
   IFN POLISH,<
	HRLM AC1,SRCHX
	MOVE AC1,SYMBOL
	MOVEM AC1,SGSBOT
	HRRZ AC2,SGNCUR
	JUMPE AC2,SRCHI2
SRCHI1:	HRRZ AC1,SGSCNT-1(AC2)
	LSH AC1,1
	ADDB AC1,SGSBOT
	SOJG AC2,SRCHI1
SRCHI2:	MOVS AC2,AC1
	ADDM AC2,SRCHX
	MOVE AC2,SGNCUR
SRCHI3:	HRRZ AC1,SGSCNT(AC2)
	LSH AC1,1
	ADD AC1,SGSBOT
	MOVEM AC1,SGSTOP
   >
	RET			;SRCHX=XWD <SYMTBL+LENGTH/2>,LENGTH/4



UPDATE:	DPB RC,RCPNTR		;FIX RIGHT RELOCATION
	TLNE ARG,SPTR		;SKIP IF THERE IS NO SPECIAL POINTER
	JRST UPDAT4		;YES, USE THE TWO CELLS
	TDNE RC,[-2,,-2]	;NEED TO CHANGE ANY CURRENT EXTERNS
	JRST UPDAT5		;YES ,JUMP
	TLZ ARG,LELF		;CLEAR LELF
	TLNE RC,1		;LEFT RELOCATABLE?
	TLO ARG,LELF		;YES, SET THE FLAG
	TLNE ARG,PNTF		;WAS THERE A 36BIT VALUE?
	JRST UPDAT2		;YES, USE IT.
	TLNE V,-1		;NO,IS THERE A 36BIT VALUE?
	JRST UPDAT1		;YES, GET A CELL
	HRR ARG,V		;NO, USE RH OF ARG
UPDAT3:	MOVEM ARG,0(SX)		;OVERWRITE THE ONE IN THE TABLE
   IFE POLISH,<
	RET			;AND EXIT
   >
   IFN POLISH,<
	JRST UPDAT6		;AND EXIT
   >

UPDAT1:	AOS SDEL,FREE		;GET ONE CELL
	CAML SDEL,SYMBOL	;NEED MORE CORE?
	CALL XCEEDS		;YES
	HRRI ARG,-1(SDEL)	;POINTER TO ARG
	TLO ARG,PNTF		;AND NOTE IT.
UPDAT2:	TLNE ARG,EXTF		;IS THERE A EXTERNAL?
	JRST UPDAT3		;YES, - JUST SAVE A LOCATION
	MOVEM ARG,0(SX)		;NO, OVERWRITE THE POINTER IN THE TABLE
	MOVEM V,0(ARG)		;STORE VALUE AS A 36BIT VALUE
   IFE POLISH,<
	RET			;AND EXIT
   >
   IFN POLISH,<
	JRST UPDAT6		;AND EXIT
   >

UPDAT4:	MOVEM ARG,0(SX)		;WE HAVE TWO CELLS, WE USE THEM
	MOVEM V,0(ARG)		;SAVE AS 36BIT VALUE
	MOVEM RC,1(ARG)		;SAVE RELOCATION BITS
	RET			;AND EXIT

UPDAT5:	MOVEI SDEL,2		;THERE IS A EXTERNAL
	ADDB SDEL,FREE		;SO WE NEED TWO LOACTIONS
	CAML SDEL,SYMBOL	;NEED MORE CORE?
	CALL XCEEDS		;YES
	MOVEM RC,-1(SDEL)	;SAVE RELOCATION BITS
	HRRI ARG,-2(SDEL)	;SAVE THE POINTER IN ARG
	MOVEM V,0(ARG)		;SAVE A 36BIT VALUE
	TLO ARG,SPTR		;SET SPECIAL PNTR FLAG
	TLZ ARG,PNTF		;CLEAR POINTER FLAG
	JRST UPDAT3		;SAVE THE POINTER AND EXIT
   IFN POLISH,<
UPDAT6:	TLNN IO,DEFCRS		;DEFINING OCCURANCE?
	RET			;NO, RETURN
	TLNE ARG,EXTF		;EXTERNAL?
	RET			;YES, RETURN
	MOVE SDEL,SYMBOL	;GET START OF SYM TAB
	SETZ AC1,		;ZERO PSECT INX
UPDAT7:	HRRZ AC2,SGSCNT(AC1)	;PSECT SYM CNT
	LSH AC2,1		;DOUBLE IT
	ADD SDEL,AC2		;END OF PSECT
	CAMGE SDEL,SX		;SYM IN THIS PSECT?
	AOJA AC1,UPDAT7		;NO, TRY NEXT PSECT
	CAMN AC1,SGNCUR		;IF IT'S IN THE CUR PSECT
	RET			; THEN RETURN
	PUSH P,AC1		;SAVE PRESENT PSECT INX
	PUSH P,0(SX)		;SAVE SYMBOL STUFF
	PUSH P,-1(SX)		; AND NAME
	PUSH P,SX		;SAVE PRESENT SYM INX
	CALL SRCHI		;SET UP SRCHX
	CALL SRCH		;SET UP NEW SX
	  JFCL
	POP P,SDEL		;RESTORE PRESENT SYM INX
	MOVE AC1,-2(P)		;GET PRESENT PSECT INX
	CAMG AC1,SGNCUR		;WHICH WAY TO MOVE?
	JRST UPDAT9		;DOWN
	ADDI SX,2		;MUST MOVE THIS ONE ALSO
UPDAT8:	MOVE AC2,-2(SDEL)	;MOVE PART OF
	MOVEM AC2,0(SDEL)	; SYMBOL TABLE
	CAILE SDEL,0(SX)	;ENOUGH MOVED?
	SOJA SDEL,UPDAT8	;NO
	JRST UPDT10		;COMMON EXIT
UPDAT9:	HRLI AC2,1(SDEL)	;FROM HERE
	HRRI AC2,-1(SDEL)	; TO HERE
	BLT AC2,-2(SX)		; UNTIL HERE, MOVE!
UPDT10:	POP P,-1(SX)		;RESTORE SYMBOL NAME
	POP P,0(SX)		; AND STUFF
	POP P,AC1		;OLD PSECT INX
	SOS SGSCNT(AC1)		;DECR ITS SYM CNT
	MOVE AC1,SGNCUR		;CUR PSECT INX
	AOS SGSCNT(AC1)		;INCR ITS SYM CNT
	CALL SRCHI		;SET UP SRCHX
	RET			;RETURN
   >

	SUBTTL PHASED CODE

   IFN PURESW,<LOWH:
	PHASE LOWL>

   IFN TEMP,<TMPFIL: SIXBIT /MAC/
	XWD -200,0>
LSTFIL:	BLOCK 1
	SIXBIT /@/		;SYMBOL TO STOP PRINTING
TABI:
   IFE FORMSW,< BYTE (7) 0, 11, 11, 11, 11>
   IFN FORMSW,< BYTE (7) 11,11, 11, 11, 11>
SEQNO:	BLOCK 1
	ASCIZ /	/
BININI:	EXP B
BINDEV:	BLOCK 1
	XWD BINBUF,0
LSTINI:	EXP AL
LSTDEV:	BLOCK 1
	XWD LSTBUF,0
   IFN CCLSW,<
RPGINI:	EXP AL
RPGDEV:	BLOCK 1
	XWD 0,CTLBLK
   >
INDEVI:	EXP A
INDEV:	BLOCK 1
	XWD 0,IBUF

UNVINI:	EXP B			; OPEN BLOCK FOR BINARY UNV
UNVDEV:	BLOCK 1			; SO USER CAN SPECIFY
	EXP UNVBUF		;

..LPP:	EXP .LPP-2		; "READ-ONLY" LINES/PAGE


;DATA AREA FOR COMPT. UUO'S
   IFN TOPS20,<

DEFDIR:	BLOCK ^D8		; DEFAULT DIRECTORY NAME
DEFDEV:	BLOCK ^D8		; DEFAULT DEVICE NAME
BIGBUF:	BLOCK ^D17
FILNAM:	BLOCK ^D26

RUNARG:	4			; RUN ARG
	RUNBLK			; LONG FORM
	-1,,FILNAM
	1
RUNBLK:	100001,,0
	377777,,377777
	-1,,[ASCIZ /SYS/]
	0
	0
	-1,,[ASCIZ /EXE/]	; DEFAULT EXT
	BLOCK 3			; THAT'S ALL
INARG:	CHAR,,1
	INBLK
	-1,,FILNAM
	440000,,200000
	0
	IBUF
	0
	.+1
INRIB:	5			; SIZE OF RIB
	BLOCK 5			; DUMMY
INBLK:	100001,,0
	377777,,377777
DINDEV:	0
DINDIR:	0
	0
	-1,,[ASCIZ /MAC/]
	BLOCK 3
LSTARG:	LST,,1
	LSTBLK
	-1,,FILNAM
	070000,,100000
	1
	0
	LSTBUF
	.+1
	BLOCK 4			;DUMMY RIB
LSTBLK:	400001,,0
	377777,,377777
	0
	0
LSTNAM:	0			; NAME
LSTEXT:	0			;EXTENSION
	BLOCK 3
BINADR:	BIN,,1
	BINSTK			; LONG FORM
	-1,,FILNAM
	440000,,100000		; WRITE ACCESS
	14
	0
	BINBUF
	.+1
	BLOCK 4			; DUMMY RIB
BINSTK:	400001,,0		;FLAGS
	377777,,377777
	0
	0
	0
	-1,,[ASCIZ /REL/]	;DEFAULT EXTENSION
	BLOCK 3			; ALL REST ARE ZERO

RPGADR:	CTL2,,1			;BLOCK FO COMMADN FILE
	RPGBLK
	-1,,FILNAM
	440000,,200000		;OPENF BITS
	0
	CTLBLK
	0
	.+1			;RIB ADDRESS
	5			;SIZE OF BLOCK WHICH FOLLOWS
	BLOCK 5
RPGBLK:	100001,,0		;OLD FILE
	377777,,377777
	BLOCK 3			;NO DEFAULTS HERE
	-1,,[ASCIZ /CCL/]	;DEFAULT EXTTENSION
	BLOCK 3
   >				; END OF TOPS20 CONDITIONAL

DBUF:	ASCIZ / TI:ME DY-MON-YR PAGE /
VBUF:	ASCIZ /	MACRO %/	;MUST BE LAST LOCATIONS IN BLOCK
   IFE PURESW,< BLOCK 3>	;ALLOW FOR LONG TITLE
   IFN PURESW,< DEPHASE
	LENLOW==.-LOWH>



SUBTTL STORAGE CELLS

   IFN PURESW,< RELOC LOWL
LOWL:	BLOCK LENLOW+3 >
PASS1I:

RP:	BLOCK 1
   IFN POLISH,<
POLSTK:	BLOCK 1			;
POLPTR:	BLOCK 1			;
   >
CTLBUF:	BLOCK <CTLSIZ+5>/5
LSTBUF:	BLOCK 3
BINBUF:	BLOCK 3
IBUF:	BLOCK 3
UNVBUF:	BLOCK 3
LSTDIR:	BLOCK 4
BINDIR:	BLOCK 4
INDIR:	BLOCK 4
UNVDIR:	BLOCK 4
UNVPTH:	BLOCK 2+.SFDLN		; PATH FOR UNV LOOKUP
MYPPN:	BLOCK 1			;[405] LOGGED IN PPN

ACDELX:				;LEFT HALF
BLKTYP:	BLOCK 1			;RIGHT HALF

COUTX:	BLOCK 1
COUTY:	BLOCK 1
COUTP:	BLOCK 1
COUTRB:	BLOCK 1
COUTDB:	BLOCK ^D18

UPARRO:	BLOCK 1			;[333] -1 == RE-EAT ^ IF NOT FOLLOWED BY ! / -
OKOVFL:	BLOCK 1			;[362] -1 == * OR / OVERFLOW OK
EOFFLG:	BLOCK 1			;[417] END OF FILE SEEN, NEXT FILE OPENED
   IFN TSTCD,<
TCDFLG:	BLOCK 1			;[414] -1 MEANS TEST MODE, 0 REGULAR MODE
   >

MACTAB:	BLOCK 1			;[313] -1 == OLD FORMAT MACRO ARGS
ITABM:	BLOCK 1			;INCLUDE TABS IN MACRO ARGS IF NON-0
UNDCNT:	BLOCK 1			;[514] UND SYMBOL COUNT--CLEARED AND INCREMENTED IN UOUT
ERRCNT:	BLOCK 1
QERRS:	BLOCK 1			;COUNT OF "Q" ERRORS
FREE:	BLOCK 1
HIGH1:	BLOCK 1
HISNSW:	BLOCK 1
SVTYP3:	BLOCK 1
HMIN:	BLOCK 1			;START OF HIGH SEG. IN TWO SEG. PROG.
SXSV:	BLOCK 1
SDELSV:	BLOCK 1
COLSIZ:	BLOCK 1
SYMBLK:	BLOCK 1
IFBLK:	BLOCK .IFBLK
IFBLKA:	BLOCK .IFBLK
LADR:	BLOCK 1
NCOLLS:	BLOCK 1
LIMBO:	BLOCK 1
LBUFP:	BLOCK 1
LBUF:	BLOCK <.CPL+5>/5
.SGLVZ==.			; START OF LIT /VAR AREA
	BLOCK 1
VARHD:	BLOCK 1
VARHDX:	BLOCK 1
VARCNT:	BLOCK 1			;[515] VARIABLE COUNTER

LITAB:	BLOCK 1
LITABX:	BLOCK 1
	BLOCK 1
LITHD:	BLOCK 1
LITHDX:	BLOCK 1
LITCNT:	BLOCK 1
LITNUM:	BLOCK 1
.SGLVL==.-.SGLVZ		; LENGTH OF LIT/VAR AREA

ENDSN:	BLOCK 1			;[475] -1 IF CHECKED VAR AREA BEFORE LISING END
LOOKX:	BLOCK 1
NEXT:	BLOCK 1
OUTSW:	BLOCK 1
PDP:	BLOCK 1
RECCNT:	BLOCK 1
SAVBLK:	BLOCK RC
SAVERC:	BLOCK 1
SBUF:	BLOCK .SBUF/5
SRCHX:	BLOCK 1
SUBTTX:	BLOCK 1
SVSYM:	BLOCK 1
SYMBOL:	BLOCK 1
SYMTOP:	BLOCK 1
SYMCNT:	BLOCK 1
   IFN POLISH,<
SGNMAX:	BLOCK 1
SGNAME:	BLOCK SGNSGS+1
SGRELC:	BLOCK SGNSGS+1
SGSCNT:	BLOCK SGNSGS+1
SGATTR:	BLOCK SGNSGS+1
SGORIG:	BLOCK SGNSGS+1		; LIT/VAR AREA ,, ORIGIN OF PSECT
SGSBOT:	BLOCK 1
SGSTOP:	BLOCK 1
SGWFND:	BLOCK 1
   >

STPX:	BLOCK 1
STPY:	BLOCK 1
STCODE:	BLOCK .STP
STOWRC:	BLOCK .STP

   IFN FORMSW,<
STFORM:	BLOCK .STP
FORM:	BLOCK 1
HWFMT:	BLOCK 1
FLDSIZ:	BLOCK 1
IOSEEN:	BLOCK 1
   >
TABP:	BLOCK 1
TCNT:	BLOCK 1			;COUNT OF CHARS. LEFT IN TBUF
TBUF:	BLOCK .TBUF/5
DEVBUF:	BLOCK 12			;STORE NAME.EXT CREATION DATE AND TIME
TYPERR:	BLOCK 1
PRGPTR:	BLOCK 1			;POINTER TO CHAIN OF PRGEND BLOCKS
ENTERS:	BLOCK 1			;-1 WHEN ENTERS HAVE BEEN DONE
UNIVSN:	BLOCK 1			;-1 WHEN A UNIVERSAL SEEN
UNVSKP:	BLOCK 1			;-1 IF /U SEEN (DON'T SAVE UNIV)
CPUTYP:	BLOCK 1			; CPU TYPE FOR HEADER BLOCK



PASS2I:

ABSHI:	BLOCK 1
HIGH:	BLOCK 1
HHIGH:	BLOCK 1			;SAVE BREAK OF HIGH SEG. IN TWO SEG PROG.
   IFN POLISH,<
SGNCUR:	BLOCK 1
SGDMAX:	BLOCK 1
SGLIST:	BLOCK SGNDEP+1
   >
ACDEVX:	BLOCK 1
CPL:	BLOCK 1
CTLSAV:	BLOCK 1
CTLS1:	BLOCK 1
EXTPNT:	BLOCK 1
INTENT:	BLOCK 1
INREP:	BLOCK 1
INDEF:	BLOCK 1
INTXT:	BLOCK 1
INCND:	BLOCK 1
CALNAM:	BLOCK 1
COMSW:	BLOCK 1			;[425] -1 IF IN COMMENT WHILE SCANNING  FOR ANG.BRKT.
;DO NOT SPLIT THIS BLOCK OF 4 WORDS
PAGENO:	BLOCK 1
SEQNO2:	BLOCK 1
TAG:	BLOCK 1
TAGINC:	BLOCK 1
CALPG:	BLOCK 4
DEFPG:	BLOCK 4
LITPG:	BLOCK 4
REPPG:	BLOCK 4
TXTPG:	BLOCK 4
CNDPG:	BLOCK 4
IRPCNT:	BLOCK 1
IRPARG:	BLOCK 1
IRPARP:	BLOCK 1
IRPCF:	BLOCK 1
IRPPOI:	BLOCK 1
IRPSW:	BLOCK 1
LSTPY:	BLOCK 1			;[314] SAVED STPY IN LITERAL
LITLVL:	BLOCK 1
LBLFLG:	BLOCK 1			;[402] -1 IF LABEL HAS OCCURRED INSIDE CURRENT LITERAL
LTGINC:	BLOCK 1			;[402] DEPTH OF LABEL IN LITERAL
LBLPNT:	BLOCK 1			;[516] POINTS TO THE START OF TAGS IN LITERAL CHAIN
LBLNXT:	BLOCK 1			;[516] POINTS TO THE NEXT BLOCK IN CHAIN
LITV:	BLOCK 1			;[516] ACTUAL ADDR OF THIS LITERAL
LITRC:	BLOCK 1			;[516] BLOCK RELOCATION FOR THIS LITERAL
LITN:	BLOCK 1			;[520] SAVE LITNUM BEFORE IT GETS UPDATED IN STOLIT
SQBST:	BLOCK 1			;[520] START OF LIT SCOPE FOR CHECKING TAG FIXUPS IN LITERAL POOL
SQBRC:	BLOCK 1			;[520] KEEP THE FAKE EXT PTR , WHEN DOING LIT TAG FIXUPS

ASGBLK:	BLOCK 1
LOCBLK:	BLOCK 1

LOCA:	BLOCK 1
LOCO:	BLOCK 1
RELLOC:	BLOCK 1
ABSLOC:	BLOCK 1
LPP:	BLOCK 1
ORGMOD:	BLOCK 1
MODA:	BLOCK 1
MODLOC:	BLOCK 1
MODO:	BLOCK 1
NESTED:	BLOCK 1		;[443] -1 IF IN LITERAL, MACRO, REPEAT 1 OR IF'S
   IFN CCLSW,<OTBUF:	BLOCK 2>
OUTSQ:	BLOCK 2
PAGEN.:	BLOCK 1
PPTEMP:	BLOCK 1
PPTMP1:	BLOCK 1
PPTMP2:	BLOCK 1

REPCNT:	BLOCK 1
REPEXP:	BLOCK 1
REPPNT:	BLOCK 1
RPOLVL:	BLOCK 1
R1BCNT:	BLOCK 1
R1BCHK:	BLOCK 1
R1BBLK:	BLOCK .R1B
R1BLOC:	BLOCK 1
RIMLOC:	BLOCK 1
VECREL:	BLOCK 1
VECTOR:	BLOCK 1
VECSYM:	BLOCK 1			; GLOBAL SYMBOLIC START ADDRESS
   IFN POLISH,<
VECFND:	BLOCK 1
   >
.TEMP:	BLOCK 1			;TEMPORARY STORAGE
UNISCH:	BLOCK .UNIV+1		;SEARCH TABLE FOR UNIVERSALS
SQFLG:	BLOCK 1
ARGF:	BLOCK 1
CPEEKC:	BLOCK 1			;[325] ANGLE COUNT AFTER ;; IN MACRO
MACENL:	BLOCK 1
MACLVL:	BLOCK 1
MACPNT:	BLOCK 1
WWRXX:	BLOCK 1
RCOUNT:	BLOCK 1			;COUNT OF WORDS STILL TO READ IN LEAF
WCOUNT:	BLOCK 1			;COUNT OF WORDS STILL FREE IN LEAF
IONSYM:	BLOCK 1			;-1 SUPRESS LISTING OF SYMBOLS
LOCAL:	BLOCK 1			;LINKED LIST OF LOCAL FIXUPS 
   IFN POLISH,<
POLTYP:	BLOCK 1			; PRESET IF POLISH FIXUP TYPE KNOWN
POLIST:	BLOCK 1			; LINKED LIST OF POLISH FIXUP BLOCKS
POLITS:	BLOCK 1			; LINKED LIST OF POLISH FIXUPS TO LITS (TEMP)
INANGL:	BLOCK 1			;[305] -1 WHEN INSIDE ANGLE BRACKETS
INASGN:	BLOCK 1			; HOLDS SYMBOL NAME DURING ASSIGN INCASE NEEDS POLISH
LSTOPR:	BLOCK 1			;[305] POINTER TO STORE OP FOR LAST POLISH
   >
SFDADD:	BLOCK 3+.SFDLN		;FOR LOOKUP/ENTER OF SFD PATH
SFDE==.-1			; END OF SFD
PPPN:	BLOCK 1			; DEFAULT PPN
PSFD:	BLOCK 3*.SFDLN		; DEFAULT SFD
PSFDE==.-1			; LAST ADDRESS IN SFD
BINSFD:	BLOCK 3+.SFDLN		;[476]
LSTSFD:	BLOCK 3+.SFDLN		;[476]
LITLST:	BLOCK 1			;[314] LIST BINARY IN LITERALS IF NON-0
BLSW:	BLOCK 1			;BINARY LISTING CONTROL SWITCHES
NOTFL:	BLOCK 1			;[522] -1 IF NOT FIRST LINE.
				;[522] -2 IF LAST LINE.
				;[522] 0 OR +N FOR CHAR COUNT OF FIRST LINE.
IFXLSW:	BLOCK 1			;XLIST IN IF SWITCH
PASS2Z:				;ONLY CLEAR TO HERE ON PRGEND
LSTSYM:	BLOCK 1
SPAGNO:	BLOCK 1			;PAGE NUMBER FOR SYMBOL TABLES
PASS2X:

SUBTTL MULTI-ASSEMBLY STORAGE CELLS

SAVEPP:	BLOCK 1			;SAVE P INCASE NO END STATEMENT
SAVEMP:	BLOCK 1			;MACRO PNTR FOR SAME REASOM
SAVERP:	BLOCK 1			;MACRO READ POINTER
LSTPGN:	BLOCK 1
ARAYP:	BLOCK 1
HDAS:	BLOCK 1
   IFN CCLSW,<EXTMP:	BLOCK 1	;HOLDS EXT OF COMMAND FILE (RH)
SAVFF:	BLOCK 1>
CTLBLK:	BLOCK 3
CTIBUF:	BLOCK 3
CTOBUF:	BLOCK 3
   IFN TEMP,<TMPFLG:	BLOCK 1>
   IFN FORMSW,<PHWFMT:	BLOCK 1>
MACSIZ:	BLOCK 1			;INITIAL SIZE OF LOW SEG
UNISIZ:	BLOCK 1			;TOP OF BUFFERS AND STACKS
UNITOP:	BLOCK 1			;TOP OF UNIVERSAL SYMBOL TABLE
UNIVNO:	BLOCK 1			;NUMBER OF UNIVERSALS SEEN
UNITBL:	BLOCK .UNIV+1		;TABLE OF UNIVERSAL NAMES
UNIPTR:	BLOCK .UNIV+1		;TABLE OF SYMBOL POINTERS
UNISHX:	BLOCK .UNIV+1		;TABLE OF SRCHX POINTERS
UNVDFA:	BLOCK 1			;[334] DEFAULT ARGUMENT POINTER FOR UNIVERSAL I/O
UNVER%:	BLOCK 1			;[334] OLD UNIVERSAL FILE IF -1, MAY HAVE LOST DEFAULT ARGUMENTS
UNVPOL:	BLOCK 1		;[452] STORE POLISH PTR, USED TO FIND THE END OF POLISH STACK
UNVNPL:	BLOCK 1			;[452] NEW(ADJUSTED) POLISH PTR WHEN READING UNV FILE
UWVER: BLOCK 1			;[454] ACCUMULATE FEATURE BITS FOR WRITING UNV FILE
RTIME:	BLOCK 1			; CPU TIME AT START OF PASS1
MACPRF:	BLOCK 1			;MACRO DEF PREFERRED OVER SYMBOL IF NON-0
PHALVL:	BLOCK 1			;[456] -1 IN PHASE, 0 NOT IN PHASE
	VAR			;CLEAR VARIABLES

   IFE POLISH,<SYN HIGH,SGATTR>
JOBFFI:	BLOCK 203*NUMBUF+1	;INPUT BUFFER PLUS ONE
   IFN PURESW,<LOWEND==.-1
	RELOC >

	END BEG
   