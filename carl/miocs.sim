!  IOCS - VERSION 16.6 - 7-30-76
!  I/O PACKAGE FOR THE PDP-10              CAROLINE DIEHL AND FRIENDS


ALT.ENTRY("$SETCF","SETCFN")
ALT.ENTRY("$EXU","EXU")
ALT.ENTRY("$EXUF","EXUF")
ALT.ENTRY("$IOCS","IOCS")
ALT.ENTRY("$OPEN","OPEN")
ALT.ENTRY("$SETFI","SETFID")
ALT.ENTRY("$TELCH","TELCHK")
ALT.ENTRY("$WFID","WFID")
ALT.ENTRY("$CLOSE","CLOSE")
ALT.ENTRY("$CANCE","CANCEL")
ALT.ENTRY("$BUFDU","BUF.DUMP")
ALT.ENTRY("$OPENP","OPENP")
ALT.ENTRY("$SETFP","SETFIP")
ALT.ENTRY("$SETMO","SETMODE")
ALT.ENTRY("$CLALL","CLOSE.ALL")
ALT.ENTRY("$CAALL","CANC.ALL")
ALT.ENTRY("$PLNCH","PLNCHK")
ALT.ENTRY("$PLNW","PLNW")
ALT.ENTRY("$SETTA","SET.TAB")
ALT.ENTRY("$SETTE","SET.TERM")
ALT.ENTRY("$SETPR","SET.PRMPT")
ALT.ENTRY("$TABOF","TAB.OFF")
ALT.ENTRY("$R","R")
ALT.ENTRY("$GETLI","GETLINE")
ALT.ENTRY("$W","W")
ALT.ENTRY("$WX","WX")
ALT.ENTRY("$ERASE","ERASE")
ALT.ENTRY("$SETCP","SETCP")
ALT.ENTRY("$CP","CP")
ALT.ENTRY("$SIZE","SIZE")
ALT.ENTRY("$WB","WB")
ALT.ENTRY("$RB","RB")
ALT.ENTRY("$FIXBUF","FIXBUF")
ALT.ENTRY("$DELET","DELETE")
ALT.ENTRY("$RENAM","RENAME")
ALT.ENTRY("$CLIBU","CLIBUF")
ALT.ENTRY("$CLOBU","CLOBUF")
ALT.ENTRY("$TTYLE","TTYLEN")
ALT.ENTRY("$GET","GET")
ALT.ENTRY("$PUT","PUT")
ALT.ENTRY("$PUTX","PUTX")
ALT.ENTRY("$PUTC","PUTC")
ALT.ENTRY("$PRINT","PRINT")
ALT.ENTRY("$PRINC","PRINTC")
ALT.ENTRY("$MSG","MSG")
ALT.ENTRY("$SETRW","SETRWE")
ALT.ENTRY("$FPMSG","F.P.MSG")
ALT.ENTRY("$FPRNT","F.P.PRINT")
ALT.ENTRY("$NOESC","NOESC")
ALT.ENTRY("$YSESC","YESESC")
ALT.ENTRY("$OFFAL","OFFALT")
ALT.ENTRY("$ONALT","ONALT")
ALT.ENTRY("$ONALC","ONALT.C")
ALT.ENTRY("$XTOUT","EX.TOUT")
ALT.ENTRY("$EXCFN","EX.CFN")
ALT.ENTRY("$TDEST","TT.DEST")
ALT.ENTRY("$CECHO","CF.ECHO")
ALT.ENTRY("$TECHO","TT.ECHO")
ALT.ENTRY("$RSBRK","RS.BRK")
ALT.ENTRY("$RSALT","RS.ALT")
ALT.ENTRY("$DDOVR","DDTOVR")
ALT.ENTRY("$ARTHV","ARTHOV")

!  IOCS DEFS OF INTEREST TO USER

!  FILE DESCRIPTORS PASSED TO %OPEN

!MAINTAIN ORDER OF FILE TYPES (SEE %OPEN1)

DEF INPUT AS 0
DEF UPDATE AS 1
DEF OUTPUT AS 2
DEF OUTMSG AS 3

!FILE TYPE MODIFIERS

DEF NEW AS OCT 100
DEF OLD AS OCT 200

!FILE MODES

DEF SEQUEN AS 0
DEF DIRECT AS OCT 10

!FILE ORGANIZATIONS

DEF WORD AS 0
DEF CHARACTER AS OCT 20
DEF PACK AS OCT 40
DEF ORGIND(FN) AS (ORG(FN) SHR 4)     !0,1,2,...
DEF ORGINDLIM AS 0:2

!  FILE NUMBERS  (FNMIN IS MIN CHANNEL WHICH WILL BE USED)

DEF FNMIN AS 1            !MIN AND MAX FILE NUMBERS
DEF FNMAX AS 15           !AVAILABLE, EXCLUDING TEL
DEF TEL AS (FNMIN-1)        !FILE NO. INDICATING TERMINAL 

!  ERROR NUMBERS (ERRNUM VALUES)

DEF TMFERR AS 1     !TOO MANY FILES OPEN (OPEN)
DEF FMDERR AS 2     !BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION
                    !(OPEN SEQUEN UPDATE, SETCP OR ERASE SEQUEN,
                    !WRITE OR ERASE INPUT, READ SEQUEN OUTPUT)
DEF IFDERR AS 3     !ILLEGAL FILE IDENTIFIER (SETFID, OPEN, DELETE, RENAME)
DEF CNFERR AS 4     !NEW/OLD FILE MESSAGE NOT CONFIRMED (OPEN OUTMSG)
                    !OR TYPE MODIFIER CONFLICT - FILE NOT NEW/OLD (OPEN OUTPUT OR UPDATE)

!ORDER OF FOLLOWING 5 NOS. SHALL BE MAINTAINED. (ALL BUT LAST MAY
!OCCUR DURING OPEN, DELETE, OR RENAME)

DEF FNFERR AS 5     !FILE NOT FOUND
DEF IUSERR AS 6     !INVALID USER NAME (BAD PPN)
DEF PRTERR AS 7     !PROTECTION VIOLATION ATTEMPT
DEF FBSERR AS 8     !FILE BUSY
DEF AEFERR AS 9     !NEW NAME BELONGS TO ALREADY EXISTING FILE  (RENAME)

DEF EOFERR AS 10    !END OF FILE (R, RB, GETLINE)
DEF LNGERR AS 11    !LINE TOO LONG (GETLINE FROM FILE)
DEF TELERR AS 12    !ILLEGAL OPERATION ON TEL (OPEN, DELETE, RENAME,
                    !CP, SIZE)
DEF ARGERR AS 13    !BAD ARGUMENT VALUE - SUCH AS:
                    !NEGATIVE CURSOR POSITION (SETCP, ERASE),
                    !NEG. COUNT (RB, WB, OPEN NSBUFS)
DEF CORERR AS 14    !OUT OF CORE (OPEN SEQUEN)
DEF DEVERR AS 15    !DEVICE DOES NOT EXIST OR BAD MODE FOR DEVICE
                    !OR DEVICE NOT SUPPORTED BY IOCS



!  MACHINE DEPENDENT MACROS

DEF MKCTRL(CHAR) AS (CHAR-OCT 100)
DEF UNCTRL(CHAR) AS (CHAR+OCT 100)
DEF CTRLCH(CHAR) AS (0<CHAR<=OCT 37)     !ALL CTRL CHARS, INCL. BEYOND ZCTRL
DEF PRCHAR(CHAR) AS (OCT 40<=CHAR<=OCT 176)
DEF PUT.CR   AS TTY _ CARRET     !CR W/O LF
DEF PUT.LF   AS TTY _ LNFEED     !LF W/O CR
DEF PUT.CRLF AS [PUT.CR; PUT.LF]
DEF PUT.LFCR AS [PUT.LF; PUT.CR]
DEF RUBOUT AS OCT 177
DEF EOLITWD AS 0


GLOBAL ALT.NAME("$STS",STS)
GLOBAL ALT.NAME("$SETCF",%SETCFN)
GLOBAL ALT.NAME("$CFN",CFN)
GLOBAL ALT.NAME("$EXU",%EXU)
GLOBAL ALT.NAME("$EXUF",%EXUF)
GLOBAL ALT.NAME("$IOCS",%IOCS)
GLOBAL ALT.NAME("$OPEN",%OPEN)
GLOBAL ALT.NAME("$SETFI",%SETFID)
GLOBAL ALT.NAME("$TELCH",%TELCHK)
GLOBAL ALT.NAME("$WFID",%WFID)
GLOBAL ALT.NAME("$CLOSE",%CLOSE)
GLOBAL ALT.NAME("$CANCE",%CANCEL)
GLOBAL ALT.NAME("$BUFDU",%BUF.DUMP)
GLOBAL ALT.NAME("$OPENP",%OPENP)
GLOBAL ALT.NAME("$SETFP",%SETFIP)
GLOBAL ALT.NAME("$SETMO",%SETMODE)
GLOBAL ALT.NAME("$CLALL",%CLOSE.ALL)
GLOBAL ALT.NAME("$CAALL",%CANC.ALL)
GLOBAL ALT.NAME("$PLNCH",%PLNCHK)
GLOBAL ALT.NAME("$PLNW",%PLNW)
GLOBAL ALT.NAME("$SETTA",%SET.TAB)
GLOBAL ALT.NAME("$SETTE",%SET.TERM)
GLOBAL ALT.NAME("$SETPR",%SET.PRMPT)
GLOBAL ALT.NAME("$TABOF",%TAB.OFF)
GLOBAL ALT.NAME("$R",%R)
GLOBAL ALT.NAME("$GETLI",%GETLINE)
GLOBAL ALT.NAME("$W",%W)
GLOBAL ALT.NAME("$WX",%WX)
GLOBAL ALT.NAME("$ERASE",%ERASE)
GLOBAL ALT.NAME("$SETCP",%SETCP)
GLOBAL ALT.NAME("$CP",%CP)
GLOBAL ALT.NAME("$SIZE",%SIZE)
GLOBAL ALT.NAME("$WB",%WB)
GLOBAL ALT.NAME("$RB",%RB)
GLOBAL ALT.NAME("$FIXBUF",%FIXBUF)
GLOBAL ALT.NAME("$DELET",%DELETE)
GLOBAL ALT.NAME("$RENAM",%RENAME)
GLOBAL ALT.NAME("$CLIBU",%CLIBUF)
GLOBAL ALT.NAME("$CLOBU",%CLOBUF)
GLOBAL ALT.NAME("$TTYLE",%TTYLEN)
GLOBAL ALT.NAME("$GET",%GET)
GLOBAL ALT.NAME("$PUT",%PUT)
GLOBAL ALT.NAME("$PUTX",%PUTX)
GLOBAL ALT.NAME("$PUTC",%PUTC)
GLOBAL ALT.NAME("$PRINT",%PRINT)
GLOBAL ALT.NAME("$PRINC",%PRINTC)
GLOBAL ALT.NAME("$MSG",%MSG)
GLOBAL ALT.NAME("$SETRW",%SETRWE)
GLOBAL ALT.NAME("$FPMSG",%F.P.MSG)
GLOBAL ALT.NAME("$FPRNT",%F.P.PRINT)
GLOBAL ALT.NAME("$NOESC",%NOESC)
GLOBAL ALT.NAME("$YSESC",%YESESC)
GLOBAL ALT.NAME("$OFFAL",%OFFALT)
GLOBAL ALT.NAME("$ONALT",%ONALT)
GLOBAL ALT.NAME("$ONALC",%ONALT.C)
GLOBAL ALT.NAME("$ALTLO",ALTLOC)
GLOBAL ALT.NAME("$ERRNU",ERRNUM)
GLOBAL ALT.NAME("$XTOUT",%EX.TOUT)
GLOBAL ALT.NAME("$EXCFN",%EX.CFN)
GLOBAL ALT.NAME("$TDEST",%TT.DEST)
GLOBAL ALT.NAME("$CECHO",%CF.ECHO)
GLOBAL ALT.NAME("$TECHO",%TT.ECHO)
GLOBAL ALT.NAME("$RSBRK",%RS.BRK)
GLOBAL ALT.NAME("$RSALT",%RS.ALT)

GLOBAL ALT.NAME("$FIDP",FIDP())
GLOBAL ALT.NAME("$DDOVR",%DDTOVR)
GLOBAL ALT.NAME("$ARTHV",%ARTHOV)
DEF LOCWPF AS 5
DEF MAXARG AS 27
DEF MINARG AS 5
DEF WPF AS (LOCWPF+1+MINARG)
DEF MAXWPF AS (LOCWPF+1+MAXARG)
! EXTENDED ARGUMENT BLOCK:
DEF ARGCNT(TBL) AS TBL(LOCWPF)
DEF PPNARG(TBL) AS TBL(LOCWPF+1)
DEF NAMARG(TBL) AS TBL(LOCWPF+2)
DEF EXTARG(TBL) AS TBL(LOCWPF+3)
DEF PRVARG(TBL) AS TBL(LOCWPF+4)
DEF FILSIZ(TBL) AS TBL(LOCWPF+5)
DEF EXTQ(TBL) AS TBL(0)
DEF USRNAM(TBL) AS TBL(1)
DEF DEVNAM(TBL) AS TBL(3)
DEF CONFWD(TBL) AS TBL(4)

!  GETLINE 

DEF LLEN AS 256                !MAX. LINE LENGTH
DEF GLBCMX AS (LLEN+1)         !MAX. CHAR CAPACITY
DEF CPW AS CHARS.PER.WORD
DEF GLBSZ AS (GLBCMX+CPW-1)/CPW   !SIZE IN WORDS
GLOBAL ALT.NAME("$FREE",FREE(0:GLBSZ-1))        !GETLINE INTERNAL BUFFER (AVAILABLE
                               !BETWEEN GETLINE CALLS)
GLOBAL ALT.NAME("$IMAGE",IMAGE(0:GLBSZ-1))       !GETLINE IMAGE LINE BUFFER
GLOBAL ALT.NAME("$GLCNT",GLCNT)                   !GETLINE CHAR COUNT

FIND ALT.NAME("$DSA",%DSA)
FIND ALT.NAME("$GETMEM",%GETMEM)
FIND ALT.NAME("$RLSMEM",%RLSMEM)

FIND ALT.NAME("JOBHCU",JOBHCU)
FIND ALT.NAME("JOBJDA",JOBJDA(1))
FIND ALT.NAME(".JBFF",JOBFF)
FIND ALT.NAME(".JBAPR",JOBAPR)
FIND ALT.NAME(".JBTPC",JOBTPC)
FIND ALT.NAME(".JBREL",JOBREL)

LOCAL %INIT.R, %RBLK, %WBLK, %GETCHK, %SETCPI, %SET.NXCHAR
DEF WBUF(BPTR) AS WBLK(FN.ID(BPTR),BUFSZ,BGNADR(BPTR),BLK.ID(BPTR))
DEF CLEAN(BPTR) AS [WBUF(BPTR); DIRTY(BPTR) _ NO]
LOCAL %S.RBLK, %S.WBLK, %DSIZE, %DCP, %DSETCP
LOCAL %TTYIO, %IOERR, %SETALT, %ABNERR, %SET.ARTHOV
LOCAL %SET.CTRL, %UNSET.CTRL, %OFF.ECHO, %ON.ECHO, %GET.BRK
LOCAL %PUTTY, %PUTTYC, %PUTTYX, %PRNTTY, %PRNTTC, %MSGTTY
LOCAL %L.OFFALT,  %L.ONALT, L.ALTLEV
DEF ERR(N) AS [ERRNUM _ N; GO ERLAB]
DEF FNERR(N) AS IOERR(FN,N)

LOCAL I
DEF YES AS 1
DEF NO AS 0
DEF BPW AS BITS.PER.WORD

!     BUFFER PARAMETERS

DEF BUFSZ AS 128           !SIZE OF DUMP-MODE DISK BUFFER
DEF BBUFSZ AS 131          !SIZE OF BUFFERED-MODE DISK BUFFER
TABLE BPE(ORGINDLIM) [36, 7, 8]     !BITS PER ELEMENT
TABLE EBUFS(ORGINDLIM) [BUFSZ, BUFSZ*CPW, BUFSZ*BPW/8]
DEF EBUFSZ(FN) AS EBUFS(ORGIND(FN))
DEF WPB(C) AS (BUFSZ-(EBUFSZ(FN)-(C))*BUFSZ/EBUFSZ(FN))
  !NO. OF WDS C BUFFER ELEMENTS OCCUPY

! WHEN FILE MODE IS DIRECT:

LOCAL BUF()               !MASTER BUFFER, TO CONSIST OF NBUFS BUFFERS,
                          !BUFSZ WDS. EACH
LOCAL NXBUF               !INDICATES FIRST BUFFER TO BE EXAMINED IN NEXT
                          !SEARCH FOR ONE INTO WHICH TO READ FILE BLOCK

! NXBUF & THE SUBSCRIPT OF THE FOLLOWING ARRAYS INDICATE AN
! INDIVIDUAL BUFFER (OF BUFSZ WDS.) WITHIN BUF AS FOLLOWS:  VALUE I
! INDICATES BUFFER STARTING AT BUF+I*BUFSZ. THUS, 0 POINTS TO 1ST,
! 1 TO 2ND, ..., NEXT-TO-LAST TO LAST BUFFER

BASE 0
LOCAL FN.ID()    !-1 INDICATES BUFFER UNUSED
                 !ELSE VALUE IS FILE NO. WHOSE BLOCK IS THERE
LOCAL BLK.ID()   !NUMBER OF BLOCK IN BUFFER
LOCAL DIRTY()    !YES IF BLOCK IN BUFFER WAS WRITTEN ON

DEF BGNADR(X) AS (BUF+(X)*BUFSZ)        !ADDR OF 1ST WORD OF BUFFER X

!     FILE PARAMETERS

LOCAL FIDTBL(0:MAXWPF-1)

! THE FOLLOWING ARE UNDEFINED IF NO FILE OPEN WITH SPECIFIED NUMBER
!  (EXCEPT FTYP, WHICH IS <0)

BASE TEL
GLOBAL ALT.NAME("$FLTYP",FTYP(FNMAX))
LOCAL MODE(FNMAX),ORG(FNMAX)     !FILE DESCRIPTORS
BASE FNMIN
LOCAL EPTR(FNMAX),ECNT(FNMAX)       !ELEMENT POINTER & COUNT OF
                          !REMAINING ELEMENTS
LOCAL CP1(FNMAX)           !USED IN CURSOR POSITION CALCULATION
LOCAL OPNSZ(FNMAX)        !FILE SIZE IN ELEMENTS, USED IN
                          !SIZE CALCULATION.
LOCAL SZFG(FNMAX)         !NEGATIVE IF OPNSZ IS APPROXIMATE (CHARACTER
                          !FILES ON PDP-10)
LOCAL SUBCNT(FNMAX), PKA, PKB       !USED IN PACK I/O

!IF MODE(FN) IS DIRECT:

LOCAL CPBUF(FNMAX)        !BUFFER CONTAINING FILE CURSOR (<0 IF NONE,
                          !OR IF CP SET AND NO I/O DONE)
LOCAL MXACP(FNMAX)        !MAXIMUM ABANDONED CURSOR POSITION
LOCAL ENDCNT(FNMAX)       !USED IN DIRECT EOF CHECK IN %R

!     READ & WRITE LABELS

! LABEL MANIPULATION BETWEEN %R, AND %W AND OTHER PROCEDURES
! REQUIRES THESE DECLARATIONS

LOCAL RINIT:, WINIT:, WXLAB:
LOCAL R.ERR:, RTEL:, W.ERR:, WSET:, WTEL:, YCHAR:, YTEL:
LOCAL RADR(ORGINDLIM), WADR(ORGINDLIM), ENDRADR(ORGINDLIM)
LOCAL RWD:, RCH:, WWD:, WCH:, ENDRWD:, ENDRCH:
LOCAL RPK:, WPK:, ENDRPK:
BASE TEL
LOCAL RLAB(FNMAX), WLAB(FNMAX), YLAB(FNMAX)
LOCAL RWELAB(FNMAX)     !ERROR LABELS
BASE 1

!     CONTROL CHARACTER CODES

DEF ACTRL AS MKCTRL($A)
DEF BCTRL AS MKCTRL($B)
DEF CCTRL AS MKCTRL($C)
DEF DCTRL AS MKCTRL($D)
DEF ECTRL AS MKCTRL($E)
DEF FCTRL AS MKCTRL($F)
DEF GCTRL AS MKCTRL($G)
DEF HCTRL AS MKCTRL($H)
DEF ICTRL AS MKCTRL($I)
DEF JCTRL AS MKCTRL($J)
DEF KCTRL AS MKCTRL($K)
DEF LCTRL AS MKCTRL($L)
DEF MCTRL AS MKCTRL($M)
DEF NCTRL AS MKCTRL($N)
DEF OCTRL AS MKCTRL($O)
DEF PCTRL AS MKCTRL($P)
DEF QCTRL AS MKCTRL($Q)
DEF RCTRL AS MKCTRL($R)
DEF SCTRL AS MKCTRL($S)
DEF TCTRL AS MKCTRL($T)
DEF UCTRL AS MKCTRL($U)
DEF VCTRL AS MKCTRL($V)
DEF WCTRL AS MKCTRL($W)
DEF XCTRL AS MKCTRL($X)
DEF YCTRL AS MKCTRL($Y)
DEF ZCTRL AS MKCTRL($Z)

DEF BELL AS GCTRL

!     MACHINE EXCLUSIVE

! INSTRUCTION CODES PASSED TO %EXU

DEF GETMOD AS -OCT 31
DEF JRSTCD AS OCT 254 !JRST
DEF GTTAB AS OCT 41
DEF AUXCAL AS OCT 42
DEF DEVNAMUUO AS OCT 64
DEF OPNCD AS OCT 50   !OPEN
DEF ENTCD AS OCT 77   !ENTER
DEF LKPCD AS OCT 76   !LOOKUP
DEF RNMCD AS OCT 55   !RENAME
DEF CLSCD AS OCT 70   !CLOSE
DEF RLSCD AS OCT 71   !RELEASE
DEF STZCD AS OCT 63   !STATZ
DEF INCD  AS OCT 56   !IN
DEF OUTCD AS OCT 57   !OUT
DEF UGFCD AS OCT 73   !UGETF
DEF USICD AS OCT 74   !USETI
DEF USOCD AS OCT 75   !USETO
DEF STSCD AS OCT 60   !SETSTS
DEF GTSCD AS OCT 62   !GETSTS
DEF TTCD  AS OCT 51   !TTCALL
DEF CLICD AS OCT 47   !CALLI

DEF JSR   AS OCT 264000.000000   !JSR INSTRUCTION
DEF JFCL  AS OCT 255000.000000   !JFCL INSTRUCTION

!IF MODE(FN) IS SEQUEN:
GLOBAL ALT.NAME("$HEAD",HEAD(FNMIN*3:FNMAX*3+2))   !BUFFER RING HEADER AREA - 3 WDS. PER FN
DEF USEBIT(FN) AS BYT(HEAD(FN*3),1,35)     !RING USE BIT
DEF CURBUF(FN) AS RH(HEAD+FN*3)        !CURRENT BUFFER
DEF S.EPTR(FN) AS HEAD(FN*3+1)            !ELEMENT POINTER
DEF S.ECNT(FN) AS HEAD(FN*3+2)            !ELEMENT COUNT

LOCAL %DO.ERR
LOCAL MINFID(FNMIN*4:FNMAX*4+3)   !FOR %ERASE
DEF LH(X) AS HW(X)
DEF RH(X) AS HW(X,1)

DEF TO.TERM AS 1
DEF TO.TOUT AS 2
DEF TO.BOTH AS 3
DEF TO.NEITHER AS 4


LOCAL TOUT.FILE     ! THE NUMBER OF OPEN TOUT.FILE
LOCAL TERM.DEST     ! DESCRIBES DESTINATION OF TERMINAL OUTPUT.
LOCAL COM.ECHO.DEST ! DESTINATION OF COMMANDS FILE ECHOING.
LOCAL TERM.ECHO.P   ! IF TRUE, THEN TERMINAL INPUT IS COPIED TO TOUT.


!     *****  THE I/O CONTROL SYSTEM  *****

%IOCS (NBUFS)

! IOCS MUST BE CALLED TO INITIALIZE THIS PACKAGE; RH(NBUFS) SPECIFIES
! THE NUMBER OF BUFFERS TO BE USED IN DIRECT MODE I/O OPERATIONS.
! LH(NBUFS) IF NONZERO IS THE LOCATION AT WHICH THE BUFFERS ARE TO
! BE ALLOCATED; IF ZERO, BLOCK IS USED TO OBTAIN SPACE.
LOCAL %NULLP, %OPEN1
LOCAL J,K
LOCAL EROUT:, QUIT:, ALT:, ALTNIL:
LOCAL ALTLEV, ALTBLK(0:2), TRPFG, DDTFLG, ARTHOV.ADDR, NOESC.P

DEF BIT18 AS OCT 400000     !REPETITIVE ENABLE
DEF BIT25 AS OCT 2000       !ESCAPE
DEF TRPBITS AS (BIT18+BIT25)
TABLE ALTJUMP [OCT 254120.000127]       ! JRSTF @JOBTPC I HOPE

EXU(CLICD,0,0)     !RESET


ARTHOV(NO)   !DO NOT ALLOW ARITHMETIC OVERFLOW TO TRAP UNTIL REQUESTED.

ALTLEV _ 0; L.ALTLEV _ 0; TRPFG _ 0; NOESC.P _ 0; L.OFFALT

DSA
BUF _ LH(@NBUFS)
IF NBUFS _ RH(@NBUFS) >0 THEN DO
  IF BUF=0 THEN BUF _ GETMEM(NBUFS*BUFSZ);  IF BUF=0 THEN GO EROUT
  IF (FN.ID  _ GETMEM(NBUFS))=0 THEN GO EROUT
  IF (BLK.ID _ GETMEM(NBUFS))=0 THEN GO EROUT
  IF (DIRTY  _ GETMEM(NBUFS))=0 THEN GO EROUT
  MOVE NBUFS FROM ALL -1 TO FN.ID
END
NXBUF _ 0

MODE(TEL) _ SEQUEN; ORG(TEL) _ CHARACTER
WLAB(TEL) _ WTEL; YLAB(TEL) _ YTEL          !TEL OUTPUT 
RLAB(TEL) _ RTEL          !TEL INPUT
SETMODE(-1)	!SET DEFAULT
INIT.R
SET.TERM(EOLIT); SET.PRMPT(%NULLP)
SET.TAB(0); TAB.OFF(%NULLP)

FOR I _ FNMIN TO FNMAX DO
  FTYP(I) _ -1
END
!REPLACE WITH TABLE WHEN IMPLEMENTED:
RADR(0) _ RWD; RADR(1) _ RCH; RADR(2) _ RPK
WADR(0) _ WWD; WADR(1) _ WCH; WADR(2) _ WPK
ENDRADR(0) _ ENDRWD; ENDRADR(1) _ ENDRCH; ENDRADR(2) _ ENDRPK

TTYIO; ALTLOC _ QUIT
L.ONALT

%%NULLP
RETURN 0

QUIT:    EXIT; GO ^@ALTJUMP

AOVTRP:  SET.ARTHOV; GO ^ALTLOC

ALT:     ALTBLK(0) _ TRPBITS; ALTBLK(1) _ AOVTRP  !SHORT STOP BEFORE ALTLOC.
         ALTBLK(2) _ ^14 <== ALTBLK; EXU(CLICD,14,-OCT 23)  !DISMIS
ALTNIL:  IF NOT NOESC.P THEN INC TRPFG; GO ^@ALTJUMP        ! WHAT A KLUDGE!!!!!!!!

EROUT:   MSG('$TOO MANY IOCS BUFFERS$'); L.ONALT; HALT


%EXU (CODE, ACC, ADDR, SKPLAB)

! SAME AS EXUF BUT WITH NO INDIRECT OR INDEX

LOCAL INDIRECT, INDEX

INDIRECT _ INDEX _ 0

%%EXUF (CODE, ACC, INDIRECT, INDEX, ADDR, SKPLAB)

! THIS IS THE PRIMITIVE EXECUTE FUNCTION WHICH TAKES A FULL SET OF ARGUMENTS.

! MACHINE DEPENDENT.
! EXECUTES MONITOR CALLS OR OTHER INSTRUCTIONS. RETURNS UNLESS SKIP RETURN
! IS GENERATED BY MONITOR, IN WHICH CASE GO TO SKPLAB. LAST ARGUMENT 
! OMITTED IF INSTRUCTION NEVER SKIPS.

DEF GOCD AS OCT 254000.000000      !JRST (BRANCH)
LOCAL OPWORD(0:2), FOO:

OPWORD(0) _ [9,4,1,4,18] * [CODE,ACC,INDIRECT,INDEX,ADDR]
OPWORD(1) _ GOCD BOR FOO
OPWORD(2) _ GOCD BOR RH(@SKPLAB)
GO ^OPWORD
FOO:  RETURN

END EXU


!     *****  FILE OPEN & CLOSE & UTILITY OPERATIONS


%OPENP (%NNCH,FDESCR,ERLAB:,NSBUFS)

! OPEN FILE. FID=ADDRESS OF FILE IDENTIFYING STRING IF >=0, ELSE
!  IS -(FID TABLE ADDR) (I.E., SETFID HAS BEEN CALLED PREVIOUSLY).
!  FDESCR=TYPE+MODE+ORGANIZATION.
!  ERLAB:=ERROR LABEL. NSBUFS=IF SEQ. MODE, NO. OF BUFFERS IN RING.
!  CALLED WITHOUT THIS ARGUMENT IF DIRECT MODE.
!  INITIALIZES CURSOR POSITION (AND MXACP, IF DIRECT).
!  RETURNS FILE NUMBER.
! IF NAME IS SUBSET OF "TELETY", RETURN TEL.

LOCAL %GETFN,%ST.DESCR,%INIT.SCP,%DVSIZE
LOCAL FN, PTR, TEMP, HERE:
LOCAL FISPEC(0:2), TYPMOD

DEF KF.NO AS  1
DEF KF.YES AS 2
DEF FWDCNT AS KF.YES
DEF KF.ANY AS 3
DEF KF.EXSTS AS 4
DEF KF.NEW AS 5
DEF CNFTBLCNT AS KF.NEW-KF.YES

TABLE FWD(FWDCNT+1) ['NO', 'YES', '[[[[[']

TABLE CONFTBL(CNFTBLCNT+1) ['ANY', 'EXISTING', 'NEW', '[[[[[']

L.OFFALT; SETFIP(FIDTBL,%NNCH,0,ERLAB); GO BELOW

%%OPEN (FID,FDESCR,ERLAB:,NSBUFS)

L.OFFALT
IF FID<0 THEN FIDP _ -FID ELSE &
  [PTR _ CHPT(FID,-1); SETFID(FIDTBL,@PTR,0,ERLAB)]

BELOW: &
IF TELCHK THEN DO
  RWELAB(FN_TEL) _ ERLAB; ST.DESCR
  IF MODE(TEL)=DIRECT OR ORG(TEL)#CHARACTER THEN DO
    MODE(TEL) _ SEQUEN; ORG(TEL) _ CHARACTER; FNERR(TELERR)
  END
END ELSE DO

! NOT TELETYPE
  RWELAB(FN_GETFN) _ HERE; ST.DESCR
  IF MODE(FN)=SEQUEN AND FTYP(FN)=UPDATE THEN FNERR(FMDERR)
  OPEN1
  IF MODE(FN)=SEQUEN THEN INIT.SCP ELSE SETCPI(FN,MXACP(FN)_0)
  YLAB(FN) _ IF ORG(FN)=CHARACTER THEN YCHAR ELSE WXLAB
  RWELAB(FN) _ ERLAB
END

L.ONALT; RETURN FN

HERE:    FTYP(FN) _ -1; GO ERLAB


%GETFN
! MACHINE DEPENDENT.
! RETURNS AN AVAILABLE FILE NUMBER FROM FNMIN TO FNMAX INCLUSIVE.
! DONE CORRECT METHOD ALA BILL WEIHER - DOES NOT USE JOBHCU OR JOBJDA.

LOCAL NAME.EXISTS:

FOR I _ FNMIN TO FNMAX  DO
   ^14 _  I
   EXU(CLICD,14,DEVNAMUUO,NAME.EXISTS)

!NO LOGICAL DEVICE NAME IS ASSOCIATED WITH THIS CHANNEL:
   RETURN (I)

NAME.EXISTS: NULL
   IF ^14=0 THEN RETURN (I)

END

ERR(TMFERR)

END GETFN


%ST.DESCR
! UNPACKS FDESCR TO GET TYPE, MODE & ORGANIZATION OF FN

TYPMOD _ FDESCR BAND OCT 300
ORG(FN) _ FDESCR BAND OCT 60(FN) _ FDESCR BAND OCT 10
FTYP(FN) _ FDESCR BAND 7
RETURN

END ST.DESCR


%SET.CTRL
! MACHINE DEPENDENT
! SET BREAK TABLE (OR DO WHATEVER) FOR GETLINE SO THAT CTRL
! CHARACTERS WILL BE ACCEPTED AS DESIRED (AND NOT PERFORM
! SPECIAL FUNCTIONS)

LOCAL TEMP, SVLCH, SAV.TAB.P, ECHO.WAS.ON.P, GOT.ECHO:

! SETMOD BITS:
DEF BIT29  AS OCT           100     !FULL CHAR SET
DEF BIT28  AS OCT           200     !NO ECHO
DEF BIT26  AS OCT          1000     !BREAK ON ALL BUT LETTERS, DIGITS

! SETLCH BITS (LINE CHARACTERISTICS):
DEF BIT17  AS OCT      1.000000     !NO FORM FEED (TTY FORM)

! AUXCAL FUNCTION TO SET STATE OF TAB PROCESSING:
DEF NO.TAB AS OCT 777777.000025

DEF STSBITS AS (BIT29+BIT26)
DEF LCHBITS AS (BIT17)

        ! GET STATE OF TAB HANDLING AND SAVE IT.
        ^14 _ NO.TAB; SAV.TAB.P _ -1; EXU(AUXCAL,14,@SAV.TAB.P)

        ! GET STATE OF ECHOING:
        ^14 _ GETMOD; EXU(CLICD,14,GTTAB,GOT.ECHO)
GOT.ECHO: ECHO.WAS.ON.P _ BNOT (((^14)SHR 7) BAND 1)

        SVLCH _ -1; EXU(TTCD, 6, @SVLCH)    !GETLCH

%%RS.BRK                ! RESET (RESTORE) BREAK SET.

        ! SET TTY FORM:
        TEMP _ SVLCH BOR LCHBITS; EXU(TTCD, 7, @TEMP)    !SETLCH

        ! SET SUPPRESS MONITOR TAB ACTION:
        ^14 _ NO.TAB; TEMP _ 1; EXU(AUXCAL,14,@TEMP)

%%ON.ECHO

        ^14 _ IF ECHO.WAS.ON.P THEN STSBITS ELSE (STSBITS+BIT28)

SET:    EXU(CLICD,14,-OCT 26)    !SETMOD
        RETURN

%%OFF.ECHO

        ^14 _ STSBITS+BIT28; GO SET

%%UNSET.CTRL

        ^14 _ NO.TAB
        EXU(AUXCAL,14,@SAV.TAB.P)
        EXU(TTCD, 7, @SVLCH)
        RETURN

END SET.CTRL


%OPEN1

! MACHINE DEPENDENT
! OPENS FILE WITH FIDTBL ENTRIES AT FIDP AS FILE NUMBER N.
! IF SEQUEN MODE, SETS UP BUFFER RING.

!  1) INPUT - LOOKUP
!  2) UPDATE - LOOKUP. IF FILE EXISTS, ENTER. IF NOT, 3).
!  3) DIRECT OUTPUT - ENTER, CLOSE, LOOKUP, ENTER
!  4) SEQUEN OUTPUT - ENTER

LOCAL %SETFISPEC, %INIT.RNG, %FILEP, %NXCHAR, %GETCONF, %GET.ANS, %MAP.TO.UPPER.CASE
LOCAL %ABORT, %ABORT1, %ABORT2
LOCAL INITOK:,STPPN:,GETSZ:, CHKMSG:, ABRT:, FINI:, REASK:
LOCAL PPNHLD, SAVLOC, OLDP, CONF, LPTR
DEF OLDFILE AS EXTARG(FIDP) BAND OCT 40.00.00 #0

DEF OLDMSG AS 'EXISTING FILE'
DEF NEWMSG AS 'NEW FILE'

         SETFISPEC
         EXU(OPNCD, FN, FISPEC, INITOK)   !INIT. CHANNEL
         MSG('DISK NOT AVAILABLE$')
         ABNERR(FN)     !DISK NOT AVAILABLE - VERY RARE
INITOK:  SETMODE(-1) !RESET DEFAULT!; OPNSZ(FN) _ SZFG(FN) _ 0
         PPNHLD _ PPNARG(FIDP)     !SAVE PROJ-PROG NO.
	 CONF _ CONFWD(FIDP)
         IF FTYP(FN)>UPDATE THEN DO
ENTER:     EXU(ENTCD, FN, @ARGCNT(FIDP), CHKMSG); GO ERROUT
CHKMSG:    EIF FTYP(FN)=OUTMSG THEN DO
             SAVLOC _ ALTLOC <== ABRT; OLDP _ SETPRMPT(%FILEP); L.ONALT
	     IF CONF=0 THEN CONF _ GET.ANS(%NXCHAR)+1
             IF (CONF=KF.NO) &
             OR (CONF=KF.NEW   AND     OLDFILE) &
             OR (CONF=KF.EXSTS AND NOT OLDFILE) &
             THEN ABORT(CNFERR)
             L.OFFALT; ALTLOC _ SAVLOC; SETPRMPT(OLDP); FTYP(FN) _ OUTPUT
           END
           FIF FTYP(FN)=OUTPUT THEN DO
             IF (OLDFILE AND TYPMOD=NEW) OR (NOT OLDFILE AND TYPMOD=OLD) THEN ABORT1(CNFERR)
           END
           IF MODE(FN)=SEQUEN THEN INIT.RNG ELSE DO
             EXU(CLSCD, FN, 0)
             EXU(LKPCD, FN, @ARGCNT(FIDP), STPPN); HALT  !NO ERROR AS LONG AS ENTER
                                       !INITS. PROTECTION TO READ ALL
           END
         END ELSE DO     !INPUT OR UPDATE
           EXU(LKPCD, FN, @ARGCNT(FIDP), GETSZ)
           IF FTYP(FN)=UPDATE AND (EXTARG(FIDP) BAND 7)=0 !NEWFILE! &
            THEN IF TYPMOD=OLD THEN ABORT2(CNFERR) ELSE GO ENTER
ERROUT:    DO.ERR(FN)
GETSZ:     OPNSZ(FN) _ EBUFSZ(FN)*FILSIZ(FIDP)/BUFSZ
           IF ORG(FN)=CHARACTER THEN SZFG(FN) _ -1   !SIZE IS APPROX.
           EIF FTYP(FN)=UPDATE THEN DO
             IF TYPMOD=NEW THEN ABORT2(CNFERR)
STPPN:       PPNARG(FIDP) _ PPNHLD   !RESTORE PROJ-PROG NO, CLOBBERED BY LOOKUP
             EXU(ENTCD, FN, @ARGCNT(FIDP), FINI); GO ERROUT
           END
           FIF MODE(FN)=SEQUEN THEN INIT.RNG
         END
FINI:    MOVE 4 FROM @ARGCNT(FIDP)+1 TO @MINFID(FN*4)   !FOR %ERASE
         RETURN

ABRT:   ABORT(CNFERR)


%DO.ERR (FN)
! CALL AFTER UNSUCCESSFUL LOOKUP, ENTER, RENAME.

         EXU(RLSCD, FN, 0)
         FTYP(FN) _ -1     !BETTER BE SAFE...
         FNERR(FNFERR+(EXTARG(FIDP) BAND 7))

END DO.ERR


%ABORT (ERNUM)

L.OFFALT; ALTLOC _ SAVLOC; SETPRMPT(OLDP)

%%ABORT1 (ERNUM)

EXU(CLSCD, FN, OCT 40)     !UNDOES ENTER

%%ABORT2 (ERNUM)

EXU(RLSCD, FN, 0); FNERR(ERNUM)

END ABORT


%SETMODE (MODE)

FISPEC(0) _ MODE; RETURN

END SETMODE


%SETFISPEC

! SETS SPECS FOR DEVICE INITIALIZATION 

DEF DSKDEV AS OCT 446353.000000    !SIXBIT /DSK/
LOCAL TEMP

FISPEC(1) _ IF DEVNAM(FIDP)=0 THEN DSKDEV ELSE DEVNAM(FIDP)
FISPEC(2) _ 0
IF MODE(FN)=DIRECT THEN DO
   IF FISPEC(0)<0 THEN FISPEC(0) _ OCT 17     !DUMP (UNBUFFERED)

!CHECK THAT THE DEVICE EXISTS AND THAT THE MODE IS LEGAL:

   IF DVSIZE(FISPEC)<0 THEN FNERR(DEVERR)
   TEMP _ 0
END ELSE DO
   IF FISPEC(0)<0 THEN FISPEC(0) _ 0  !BUFFERED
   HW(FISPEC+2, [FTYP(FN)=INPUT]) _ HEAD+FN*3  !HEADER

!CHECK THAT DEVICE EXISTS, MODE IS LEGAL, AND GET BUFFER SIZE FOR THIS DEVICE:
!ALSO NOTE THAT WE DON'T SUPPORT BUFFER SIZES # 131.

   IF TEMP _ DVSIZE(FISPEC) <= 0 OR RH(@TEMP) # BBUFSZ THEN FNERR(DEVERR)
END

RETURN (TEMP)

END SETFISPEC


%INIT.RNG
! SET UP RING BUFFERS

LOCAL %GETBUF

IF NSBUFS<0 THEN ERR(ARGERR)
USEBIT(FN) _ 1

!CURBUF WILL POINT TO THE SECOND WORD OF THE BUFFER FIRST ALLOCATED:
CURBUF(FN) _ TEMP _ GETBUF

!LINK THE OTHER BUFFERS:
REPEAT NSBUFS-1 DO

!PUT BUFFER SIZE AND CURRENT BUFFER ADDRESS INTO SECOND WORD OF NEXT BUFFER:
   ^TEMP _ [18,18]*[BUFSZ+1, TEMP <== GETBUF]
END

!RESET BUFFERR POINTER IN FIRST BUFFER TO POINT TO BUFFER LAST ALLOCATED:
^CURBUF(FN) _ [18,18]*[BUFSZ+1, TEMP]

RETURN

%GETBUF
!ALLOCATES SPACE FOR ONE BUFFER, RETURNS POINTER TO SECOND WORD

LOCAL P

P _ GETMEM(BBUFSZ)
IF P=0 THEN GO ERLAB
MOVE BBUFSZ FROM ALL 0 TO P
RETURN P+1

END GETBUF

END INIT.RNG


%TELCHK
! MACHINE DEPENDENT.
! RETURNS 1 IF FILE NAME DESIGNATES TERMINAL, ELSE RETURNS 0.

TABLE TELFID(2) [OCT 64.45.54.45.64.71,     !SIXBIT /TELETY/!&
      OCT 64.45.62.55.51.56]     !SIXBIT /TERMIN/

     IF LH(@EXTARG(FIDP))#0 THEN RETURN NO

     FOR J_ 1 TO 2 DO
       TEMP _ NAMARG(FIDP); I _ TELFID(J)
       REPEAT 6 DO
         IF (TEMP _ TEMP ROTL 6) BAND OCT 77 # (I _ I ROTL 6) BAND OCT 77 &
            THEN GO OUT
       END
       RETURN YES
OUT:   IF TEMP BAND OCT 77=0 THEN RETURN YES
     END
     RETURN NO

END TELCHK


%MAP.TO.UPPER.CASE(CHAR)

! RETURNS, IF CHAR IS A LOWER CASE ALPHABETIC, ITS UPPER CASE VALUE.
! ELSE, RETURNS CHAR.

IF $A + OCT 40 <= CHAR <= $Z + OCT 40 THEN RETURN (CHAR - OCT 40)
RETURN CHAR

END MAP.TO.UPPER.CASE


%GET.ANS(%NXT)

! ASSUMES PROMPT IS SET (A QUESTION); GETS A Y OR N ANSWER FROM CFN,
! USING %NXT TO ADVANCE THE CHARACTER POINTER, AND ASKS 'WHAT?'
! UNTIL IT GETS A Y OR N ANSWER.

   LOCAL %WHAT

   LOOP DO
      LPTR _ GETLINE(CFN)
      WHILE TEMP _ MAP.TO.UPPER.CASE(NXT) = $  THEN NULL
      IF TEMP=$Y OR TEMP=$N THEN [GLCNT _ 0;  RETURN [TEMP=$Y]]
      IF CFN # TEL THEN ABORT(CNFERR)
      SETPRMPT(%WHAT)
   END

   RETURN

   %WHAT

      PRINT('WHAT? ')
      RETURN

   END WHAT

END GET.ANS


%FILEP

PRINT(IF OLDFILE THEN OLDMSG ELSE NEWMSG); PRINT(' - OK? '); RETURN

END FILEP


%NXCHAR

RETURN NCHV LPTR

END NXCHAR


%SET.NXCHAR (%NXCHAR)

LOCAL %PTRNXT, %GETNXT
RETURN

%SETFIP (FIDTBL, %NNCH, EXTDEF, ERLAB:)

! MACHINE DEPENDENT.
!  IGNORES LEADING BLANKS.
!  EXAMINES STRING AT (CHAR) PTR FOR VALID FILE IDENTIFIER TERMINATED
!  BY ANY CHAR INVALID IN FILE IDENTIFIER (INCLUDING BLANK,
!  EXCEPT IN USER NAME)
!  IF FINDS, STORES WPF WORDS OF FID INFO AT
!  FIDTBL, AS REQUIRED BY %OPEN1, WITH PTR AT CHAR
!  BEFORE TERMINATOR.  SETS FIDP TO ADDRESS OF 1ST OF FIDTBL ENTRIES.
!  IF DOESN'T FIND VALID FID, GOES TO ERLAB WITH PTR RESET TO
!  ORIGINAL VALUE.
!  EXTDEF IS DEFAULT EXTENSION.

!  FORM OF FILE ID:
!    NAME  (MAX 6 ALPHA-NUM. CHARS)
!    OPTIONAL:  .EXTENSION  (MAX 3 ALPHA-NUM. CHARS)
!    OPTIONAL:  [PROJ,PROG]  (MAX 6 OCTAL DIGITS EACH)
!  NAME & EXT ARE STORED SIXBIT & LEFT-JUSTIFIED IN 1ST AND 2ND WDS;
!  PROJ STORED AS BINARY INTEGER IN LEFT HALF OF 4TH WD; PROG, IN
!  RIGHT HALF. EXTQ(FIDP) IS 1 IF EXTENSION FOUND, 0 IF USED DEFAULT.
!    OR OPTIONAL (USERNAME) BEFORE FILE NAME, MAX 12 CHARS,
!  IN WHICH CASE STORE USER NAME IN SIXBIT, 0 IN LH OF 4TH
!  WD, AND LOCATION OF USER NAME IN RH.

!  BECAUSE OF %SETFIP, NO PCHV DURING SCAN.

DEF SIXBIT(X) AS (X-OCT 40)      !CONVERTS 7-BIT CHAR TO SIXBIT

LOCAL CHAR, SIXPTR, HOLD
LOCAL %GETNUM
DEF SXPT(X) AS [6,6,24]*[36,6,(X)]

SET.NXCHAR(%GETNXT); GO BELOW

%%SETFID (FIDTBL, @PTR, EXTDEF, ERLAB:)

SET.NXCHAR(%PTRNXT)

BELOW: &
         MOVE WPF FROM ALL 0 TO FIDP _ FIDTBL
         ARGCNT(FIDP) _ MINARG; EXTARG(FIDP) _ EXTDEF; HOLD _ PTR
         WHILE NXCHAR = $  THEN NULL
NAM:     I _ 6; SIXPTR _ SXPT( @NAMARG(FIDP) )
         LOOP DO
           CHAR _ MAP.TO.UPPER.CASE(CHAR)
           EIF $0<=CHAR<=$9 OR $A<=CHAR<=$Z THEN DO
             IF DEC I>=0 THEN NCHV SIXPTR _ SIXBIT(CHAR)
           END
           ORIF CHAR=$. THEN DO
             I _ 3; SIXPTR _ SXPT(@EXTARG(FIDP))
             EXTARG(FIDP) _ 0; EXTQ(FIDP) _ YES
           END
           ORIF CHAR=$( THEN DO
             I _ 12; SIXPTR _ SXPT(RH(@PPNARG(FIDP))_@USRNAM(FIDP))
             LOOP DO
               WHILE NXCHAR # $)
               IF DEC I<0 THEN GO OUT
               NCHV (SIXPTR) _ SIXBIT(MAP.TO.UPPER.CASE(CHAR))
             END
             NXCHAR; GO NAM
           END
           ORIF CHAR=$[ THEN DO
             LH(@PPNARG(FIDP)) _ GETNUM
             IF CHAR=$, THEN RH(@PPNARG(FIDP)) _ GETNUM
             IF CHAR#$] THEN GO OUT
             GO CONFLB
           END
           ORIF CHAR=$: THEN DO
	     DEVNAM(FIDP) _ NAMARG(FIDP); NXCHAR; GO NAM
	   END
CONFLB:    ORIF CHAR=$- THEN DO
	     CONFWD(FIDP) _ GETCONF(%NXCHAR,OUT)
             IF %NXCHAR=%PTRNXT THEN PCHV PTR
	   END
           ELSE GO DONE
	   NXCHAR
         END
DONE:    IF NAMARG(FIDP)#0 THEN [IF %NXCHAR=%PTRNXT THEN PCHV PTR; RETURN]

OUT:     PTR _ HOLD; ERR(IFDERR)

%GETNUM

LOCAL I
         I _ 0
         WHILE $0<=NXCHAR<=$7 THEN I_(I SHL 3) BOR (CHAR-$0)
         RETURN I

END GETNUM


%PTRNXT
RETURN CHAR _ NCHV PTR
END PTRNXT


%GETNXT
RETURN CHAR _ NNCH
END GETNXT


%WFID (FIDP())

!  TYPES OUT NAME & EXT OF FILE HAVING FID TABLE AT FIDP.

SIXPTR _ SXPT(@NAMARG(FIDP))
LOOP [REPEAT 6; WHILE CHAR_NCHV SIXPTR#0; PUT(CHAR+OCT 40)]
IF LH(@EXTARG(FIDP))#0 THEN DO
  PUT($.); SIXPTR _ SXPT(@EXTARG(FIDP))
  LOOP [REPEAT 3; WHILE CHAR_NCHV SIXPTR#0; PUT(CHAR+OCT 40)]
END
RETURN

END WFID

END SETFIP

END SET.NXCHAR


%DVSIZE(OPEN.BLOCK())

!GIVEN THE FILE STATUS AND DEVICE FROM THE OPEN.BLOCK,
!RETURN -2 IF ILLEGAL MODE, -1 IF DEVICE DOES NOT EXIST,
!0 IF ONLY UNBUFFERED IS ALLOWED, OTHERWISE RETURN
!THE STANDARD NUMBER OF BUFFERS IN THE LEFT HALF, AND
!IN THE RIGHT HALF THE STANDARD BUFFER SIZE (INCLUDING THE 1ST 3 WORDS).

LOCAL SKPLAB:

   ^14 _ OPEN.BLOCK
   EXU(CLICD,14,OCT 101,SKPLAB)         !DEVSIZ UUO

SKPLAB: &
   RETURN (^14)

END DVSIZE


%INIT.SCP
! INITIALIZE SEQUEN FILE CURSOR POSITION. ANALOGOUS TO SETCP(FN,0)
! FOR DIRECT MODE. USER CAN REQUEST BUT NOT SET CURSOR POSITION IF
! MODE IS SEQUEN.

! SETS RLAB(FN)/WLAB(FN) TO LABEL IN %R/%W TO BE BRANCHED TO
! ON NEXT READ/WRITE OF FN.

CP1(FN) _ ECNT(FN) _ 0
RLAB(FN) _ IF FTYP(FN)=OUTPUT THEN R.ERR ELSE RADR(ORGIND(FN))
WLAB(FN) _ IF FTYP(FN)= INPUT THEN W.ERR ELSE WADR(ORGIND(FN))
RETURN

END INIT.SCP


%GETCONF (%NXCH, LAB:)

!GET CONFIRMATION KEYWORD. READ UP TO CPW ALPHA CHARS WITH %NXCH.
! ALLOW SHORTEST UNIQUE ABBREVIATION.
! GO TO LAB IF NEXT CHAR NOT ALPHA,
! OR NO MATCH, OR AMBIGUITY.

LOCAL PTR, INWD, CHAR, CNT
DEF BPC AS (BPW/CPW)
DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
DEF MASK(CNT) AS (-1 SHL (BPW-BPC*(CPW-CNT)))

INWD _ 0; PTR _ CHPT(@INWD,-1); CNT _ CPW
LOOP DO
  WHILE $A<= CHAR _ MAP.TO.UPPER.CASE(NXCH) <=$Z; WHILE DEC CNT>=0
  NCHV PTR _ CHAR
END
IF CNT=CPW THEN GO LAB
IF CNT < 0 THEN DO  ! STRING OF GREATER THAN FIVE CHARS.
   CNT _ 0   ! FOR MASKING - IMPLIES FULL WORD TOKEN.
   LOOP [WHILE $A <= MAP.TO.UPPER.CASE(NXCH) <= $Z]  ! WE ONLY READ A WORD-FULL OF CHARACTERS,
                                  ! BUT WE MAKE IT LOOK LIKE WE READ THEM ALL.
END
! COMPARE
PTR _ 0
LOOP DO
  IF INWD=^CONFTBL(INC PTR) THEN RETURN PTR + FWDCNT
  WHILE NOT LESSTR(INWD,^CONFTBL(PTR))
END
! INWD < ^CONFTBL(PTR)
IF INWD#^CONFTBL(PTR) BAND MASK(CNT) OR INWD=^CONFTBL(PTR+1) BAND MASK(CNT) &
  THEN GO LAB
RETURN PTR + FWDCNT

END GETCONF

END OPEN1

END OPENP




%CLOSE (FN)

! CLOSE FILE FN.  DO NOTHING IF FN=TEL.

! IF DIRECT MODE:
! *SPECIAL CONSIDERATION IS TAKEN IN WRITING LAST FILE BLOCK,
! *SINCE IT MAY BE PARTIALLY FULL - MUST ADJUST COUNT.
!  WRITE OUT ANY DIRTY FN BLOCKS, SET BUFFERS UNUSED
!  THAT CONTAIN FN BLOCKS, CLOSE & SAVE.
! A BUFFER IS SET UNUSED BY STORING -1 AS ITS FN.ID

! IF SEQUEN MODE:
!  IF TYPE OUTPUT, WRITE OUT BLOCK IN CURRENT BUFFER.
!  RELEASE BUFFERS, CLOSE & SAVE.

DEF SAVE AS 0
DEF DEL AS 1
DEF DISCARD AS OCT 40

LOCAL %CLOSE1,%RLS.RNG,TEMP,I,OPTION

OPTION _ SAVE

GO DOIT

%%CANCEL(FN) !  FOR OUTPUT SEQUEN FILES, CLOSES WITHOUT SUPERCEDING.

   OPTION _ DISCARD

DOIT:  IF FN=TEL THEN RETURN
L.OFFALT

  IF MODE(FN)=DIRECT THEN DO
   IF FTYP(FN)#INPUT AND TEMP_DSIZE(FN)#0 THEN DO
    DSETCP(FN,TEMP-1)     !LAST ELEMENT
    IF TEMP _ WPB(TEMP MOD EBUFSZ(FN))>0 THEN DO
      I _ GETCHK(FN)
      WBLK(FN,TEMP,I,BLK.ID(CPBUF(FN)))
      FN.ID(CPBUF(FN)) _ -1
    END
   END
    FOR I _ 0 TO NBUFS-1 IF FN.ID(I)=FN THEN &
      [IF DIRTY(I) THEN CLEAN(I); FN.ID(I)_-1]
  END ELSE [IF FTYP(FN)=OUTPUT THEN S.WBLK(FN)]
  CLOSE1(OPTION); IF MODE(FN)#DIRECT THEN RLS.RNG; L.ONALT; RETURN


%%DELETE (FID, ERLAB:)

!DELETE FILE WITH NAME AT FID

         L.OFFALT
         FN _ OPEN(FID, INPUT+DIRECT, ERLAB); CLOSE1(DEL)
         L.ONALT; RETURN


%%RENAME (OLDFID, NEWFID, ERLAB:)

! MACHINE DEPENDENT
! RENAME FILE WITH NAME AT OLDFID TO NAME AT NEWFID

LOCAL OUT:, OLDRLS:, PTR, DATE, HIDATE

DEF HI.DATE.BYTE AS BYT(EXTARG(FIDP),2,14)

         L.OFFALT
         FN _ OPEN(OLDFID, INPUT+DIRECT, ERLAB)
         HIDATE _ HI.DATE.BYTE
         DATE _ PRVARG(FIDP)
         IF NEWFID<0 THEN FIDP _ -NEWFID ELSE DO
           PTR _ CHPT(NEWFID,-1); SETFID(FIDTBL,@PTR,0,OLDRLS)
         END
         HI.DATE.BYTE _ HIDATE
         PRVARG(FIDP) _ DATE
         EXU(RNMCD, FN, @ARGCNT(FIDP), OUT)    !CLOSE IS AUTOMATIC
         DO.ERR(FN)
OLDRLS:  CLOSE1(SAVE); FNERR(IFDERR)

OUT:	 EXU(RLSCD, FN, 0)
         FTYP(FN) _ -1 !SINCE SKIPPED CLOSE!; L.ONALT; RETURN


%CLOSE1 (OPT)

! MACHINE DEPENDENT.
! CLOSE FILE FN. DELETE IF OPT=DEL, OTHERWISE SAVE.
!  SET FTYP(FN) NEGATIVE.

LOCAL RELEAS:

       IF OPT=DEL THEN DO
         FIDTBL(0) _ 0
         EXU(RNMCD, FN, FIDTBL, RELEAS)  !CLOSE IS AUTOMATIC
         DO.ERR(FN)
       END ELSE DO
         EXU(CLSCD, FN, OPT)
         EXU(STZCD, FN, OCT 740.000, RELEAS)
         MSG('CAN NOT CLOSE FILE$')
         ABNERR(FN)      !CAN'T CLOSE FILE
RELEAS:  EXU(RLSCD, FN, 0)
       END
       FTYP(FN) _ -1; RETURN

END CLOSE1

%RLS.RNG
! RELEASE RING BUFFERS FOR FILE FN

LOCAL LINK

LINK _ RH(CURBUF(FN)); RH(CURBUF(FN)) _ 0  !NO SOFT STORE
WHILE LINK#0 THEN RLSMEM(BBUFSZ,(LINK<==RH(LINK))-1)
RETURN

END RLS.RNG

END CLOSE


%CANC.ALL   !  LIKE CLOSE ALL, BUT SEQUEN OUTPUT FILES ARE NOT SUPERCEDED.

   LOCAL I

   FOR I _ FNMIN TO FNMAX  IF FTYP(I)>=0 THEN CANCEL(I)
   RETURN

END CANC.ALL


%CLOSE.ALL
! CLOSE ALL FILES

LOCAL I
	FOR I _ FNMIN TO FNMAX  IF FTYP(I)>=0 THEN CLOSE(I)
	RETURN
END CLOSE.ALL


%BUF.DUMP

! MACHINE DEPENDENT IN PART (INDICATED).
! TO BE CALLED AS A PROTECTIVE MEASURE BEFORE DOING SOMETHING THAT
! MAY DESTROY FILE BUFFERS.  WRITES OUT ALL DIRTY BLOCKS IN DIRECT
! MODE BUFFERS & SETS THEM CLEAN.  ACTION TO PROTECT SEQUEN FILES 
! IS MACHINE DEPENDENT.  FOR THIS IMPLEMENTATION, WAIT UNTIL ALL
! CHANNELS ARE INACTIVE (NO MORE DATA TRANSMISSION). OK IF CHANNEL
! NOT IN USE.

L.OFFALT
FOR I _ 0 TO NBUFS-1 IF FN.ID(I)>=0 AND DIRTY(I) THEN CLEAN(I)
FOR I _ FNMIN TO FNMAX EXU(CLICD, I, OCT 10)
L.ONALT; RETURN

END BUF.DUMP


%FIXBUF(DISP)

! MOVES I/O BUFFERS UP OR DOWN BY THE AMOUNT IN DISP.  USED BY MIGHTYCHAIN.
! RETURNS DISP.

LOCAL FN, P, FIRSTP

FN.ID +_ DISP
BLK.ID +_ DISP
DIRTY +_ DISP

FOR FN _ FNMIN BY 1 TO JOBHCU &
  IF FTYP(FN)>=0 AND MODE(FN)=SEQUEN THEN DO
    LH(14) _ FN+(IF FTYP(FN)=INPUT THEN OCT 20 ELSE OCT 40)
    RH(14) _ DISP
    EXU(CLICD, 14, - OCT 27)	!MOVBUF
    IF RH(@S.EPTR(FN))#0 THEN S.EPTR(FN) +_ DISP
    IF RH(@EPTR(FN))#0 THEN EPTR(FN) +_ DISP
    FIRSTP _ P _ CURBUF(FN); CURBUF(FN) _ CURBUF(FN)+DISP
    LOOP [RH(P) _ RH(P)+DISP; WHILE (P _ RH(P)-DISP) # FIRSTP]
  END

RETURN DISP

END FIXBUF



!     *****  FILE CURSOR POSITION & SIZE


%SETCPI (FN,POS)

! DIRECT MODE ONLY.  SETS CURSOR POSITION ON FN TO POS.
! KEEPS TRACK OF MAXIMUM ABANDONED CURSOR POSITION, USED IN %SIZE.
! SETCPI CALLED AT OPEN TIME, SINCE NO PREVIOUS CP YET.

! NEGATES CPBUF(FN), INDICATING TO %CP THAT CURSOR POSITION
! CAN BE FOUND IN CP1(FN).  CPBUF UNNEGATED WHEN I/O DONE.

! SETS RLAB(FN) AND WLAB(FN) TO LABEL TO BE BRANCHED TO ON NEXT
! READ OR WRITE OF FN. SEE %R AND %W.

L.OFFALT; GO HERE

%%SETCP (FN,POS)

IF MODE(FN)=SEQUEN THEN FNERR(FMDERR)
IF POS<0 THEN FNERR(ARGERR)
%%DSETCP (FN, POS)

         L.OFFALT
         IF CPBUF(FN)>=0 THEN MXACP(FN) _ MXACP(FN) MAX DCP(FN)
HERE:    CP1(FN) _ POS; CPBUF(FN) _ -1
         RLAB(FN) _ RINIT
         WLAB(FN) _ IF FTYP(FN)=INPUT THEN W.ERR ELSE WINIT
         L.ONALT
         RETURN POS

END SETCPI


%CP (FN)

! RETURNS CURSOR POSITION ON FILE FN.

! IF DIRECT MODE:
! IF NO READ OR WRITE HAS BEEN DONE SINCE LAST SETCP ON FN
! (CPBUF(FN)<0), POSITION NEED NOT BE CALCULATED (=CP1(FN)).
! OTHERWISE, MUST BE CALCULATED FROM CPBUF(FN), WHICH INDICATES
! BUFFER CONTAINING CURSOR POSITION, AND AVAILABLE INFO FOR CPBUF.

! IF SEQUEN MODE:
! CP1(FN) IS 1ST POSITION ON BLOCK PAST CURRENT BLOCK, S.ECNT IS
! COUNT OF REMAINING ELEMENTS ON CURRENT BLOCK.

IF FN=TEL THEN FNERR(TELERR)

IF MODE(FN)=SEQUEN THEN RETURN CP1(FN)-ECNT(FN)

%%DCP (FN)       !DIRECT MODE ONLY

RETURN IF CPBUF(FN)<0 THEN CP1(FN) ELSE BLK.ID(CPBUF(FN))*EBUFSZ(FN)-ECNT(FN)

END CP


%SIZE (FN)

! MACHINE DEPENDENT IN PART.
! RETURNS CURRENT SIZE OF FILE IN ELEMENTS, DEFINED AS:
!
! DIRECT MODE  - MAX. OF CURRENT CURSOR POS, IF I/O DONE AT  IT,
!                MAX. ABANDONED CP AT WHICH I/O DONE,
!                & OPNSZ(FN), WHICH IS REDUCED IF ERASE DONE.
!                (EXACT OPNSZ CALCULATED IF NECESSARY)
! SEQUEN INPUT  -  ON PDP-10, LIMITED TO RETURNING ONLY CPW*NO.
!                  OF WORDS.  (USETI & BUFFERED
!                  MODE DON'T MIX)
! SEQUEN OUTPUT -  CP(FN)

LOCAL %OPNSZX

IF FN=TEL THEN FNERR(TELERR)
IF MODE(FN)=SEQUEN THEN RETURN IF FTYP(FN)=OUTPUT THEN CP(FN) &
  ELSE OPNSZ(FN)

%%DSIZE (FN)         !DIRECT MODE ONLY

IF CPBUF(FN)>=0 THEN MXACP(FN) _ MXACP(FN) MAX DCP(FN)
IF MXACP(FN)>=OPNSZ(FN) THEN RETURN MXACP(FN)
IF SZFG(FN)<0 THEN SZFG(FN) _ OPNSZX(FN)
RETURN MXACP(FN) MAX OPNSZ(FN)

%OPNSZX (FN)

! ADJUSTS OPNSZ(FN) TO BE EXACT FILE SIZE IN ELEMENTS.
! CALLED FROM %SIZE.  FOR DIRECT, CHARACTER FILES ONLY.

LOCAL TEMP, I      !'I' IS A FIX AROUND SIMPL BUG

IF OPNSZ(FN)#0 THEN DO
  L.OFFALT; TEMP _ DCP(FN); SETCP(FN,OPNSZ(FN)-1)  !AT LAST POSITION
  GETCHK(FN)
  REPEAT 2 NCHV EPTR(FN)
  I _ EPTR(FN)
   LOOP DO
    REPEAT CPW; WHILE PCHV I=0; DEC OPNSZ(FN)
    INC ECNT(FN)  !FOR DCP CALL IN SETCP (BELOW)
  END
  DSETCP(FN,TEMP); L.ONALT
END
RETURN 0     !TO SET SZFG

END OPNSZX

END SIZE


!     *****  FILE & TERMINAL INPUT & OUTPUT


%INIT.R

LOCAL OBPI, NBPI       !NCHV IS 1ST CHAR OF OLD & NEW LINE BUFFERS
LOCAL NBP              !CURRENT NEW LINE BUFFER PTR
LOCAL NBPE             !PTR TO END OF NEW LINE BUFFER

DEF NOTERM(CHAR) AS (CARRET#CHAR#TERMCH)
DEF TERM(CHAR) AS NOT NOTERM(CHAR)

TABLE DEFTAB(0:8)[8,9,17,25,33,41,49,57,65]

! INITIALIZATION

OBPI _ CHPT(FREE,-1)
NBPI _ CHPT(IMAGE,-1)
NBPE _ CHPT(IMAGE,LLEN)    !CHV(NBPE) IS LAST CHAR
CH(IMAGE) _ EOLIT     !NO EDIT IMAGE
RETURN

%%SET.TERM(TERMCH)
LOCAL OLDTERMCH
RETURN OLDTERMCH <== TERMCH

%%TAB.OFF(%OFF)
LOCAL OLDOFF
RETURN OLDOFF <== %OFF

%%SET.PRMPT(%PROMPT)
LOCAL OLDPROMPT
RETURN OLDPROMPT <== %PROMPT

%%SET.TAB(TAB())
LOCAL OLDTAB
IF TAB=0 THEN TAB _ DEFTAB; RETURN OLDTAB <== TAB


%R (FN)

! RETURNS ELEMENT READ FROM CURSOR POSITION ON FILE FN.

! RLAB(FN) IS  RTEL IF FN IS TEL 

!              IF DIRECT MODE:
!              RINIT IF THIS IS 1ST ACCESS TO FN AFTER SETCP ON FN
!              OTHERWISE, IS ADDRESS OF CORRESPONDING READ ROUTINE.
!              SPECIAL ROUTINE TO CHECK FOR EOF IF READING LAST
!              BLOCK, SINCE DON'T WANT TO REDUCE ECNT(FN)
!              (WHICH WOULD SCREW UP %CP & %W)

!              IF SEQUEN MODE:
!              R.ERR IF OUTPUT FILE
!              OTHERWISE, ADDRESS OF CORRESPONDING READ ROUTINE

DEF WDMAC(X) AS IF ECNT(FN)>X THEN [DEC ECNT(FN); RETURN ^INC EPTR(FN)]
DEF CHMAC(X) AS IF ECNT(FN)>X THEN [DEC ECNT(FN); RETURN NCHV EPTR(FN)]
DEF PKMAC(X) BY IF ECNT(FN)>X THEN DO
          DEC ECNT(FN)
	  IF DEC SUBCNT(FN)<0 THEN [EPTR(FN) +_2; SUBCNT(FN)_8]
	  [;PKB] _ [^EPTR(FN);^(EPTR(FN)+1)] DSHR SUBCNT(FN)*8
	  RETURN PKB BAND OCT 377
	END ENDM PKMAC

LOCAL CP.TO.EOF

         GO ^RLAB(FN)

ENDRWD:  WDMAC(ENDCNT(FN)); GO NXBLK

ENDRPK:  PKMAC(ENDCNT(FN))
         GO NXBLK

ENDRCH:  CHMAC(ENDCNT(FN)); GO NXBLK

RWD:     WDMAC(0); GO NXBLK

RPK:     PKMAC(0)
         GO NXBLK

RCH:     CHMAC(0)

NXBLK:   IF MODE(FN)=SEQUEN THEN [S.RBLK(FN); GO ^RLAB(FN)]
RINIT:   IF CP.TO.EOF _ DSIZE(FN)-DCP(FN)<=0 THEN FNERR(EOFERR)
         L.OFFALT; GETCHK(FN)
         IF WLAB(FN)#W.ERR THEN WLAB(FN) _ WSET
         L.ONALT
         GO ^RLAB(FN) _ IF ENDCNT(FN) _ ECNT(FN)-CPTOEOF>0 THEN &
           ENDRADR(ORGIND(FN)) ELSE RADR(ORGIND(FN))

RTEL:    RETURN GET

R.ERR:   FNERR(FMDERR)


%%PLNCHK (FN)

! CALLED AFTER FILE OPEN; RETURNS 1 IF FIRST WORD ON FILE FN
! IS A PDP-10 STANDARD LINE NUMBER (BIT 35 ON), ELSE RETURNS 0.

RETURN [^(IF MODE(FN)=SEQUEN THEN S.RBLK(FN) ELSE GETCHK(FN)) BON 1]


%RB (FN, CNT, ADR)

DEF GETCH(C) AS TEMP _ CHPT(ADR,-1); REPEAT C [NCHV TEMP _ R(FN); &
  DEC CNT]
DEF GETWD(C) AS REPEAT C [^ADR _ R(FN); INC ADR; DEC CNT]
LOCAL %GETPK

LOCAL HOLD, TEMP, CFRAG, PFRAG, PTR
LOCAL ULAB, HERE:
LOCAL %SZAP, %DZAP, I

IF RLAB(FN)=R.ERR THEN FNERR(FMDERR)
IF FN=TEL THEN FNERR(TELERR)
IF HOLD _ CNT <0 THEN FNERR(ARGERR)
IF HOLD=0 THEN RETURN 0
[PTR;PFRAG] _ CP(FN) DIVMOD EBUFSZ(FN); INC PTR  !BLK NO & ELMT DISPL
L.OFFALT
ULAB _ SETRWE(FN,HERE)

DO ORGIND(FN) OF ORGINDLIM

1:         !CHARACTER! &
  IF PFRAG MOD CPW THEN DO    !CP NOT AT WORD BOUNDARY
    GETCH(HOLD)
  END ELSE DO      !CP AT WORD BOUNDARY
    IF MODE(FN)=SEQUEN THEN DO       !SEQUEN CHARACTER
	CHPT(PTR,PFRAG) _ EPTR(FN); INC PTR
	SZAP
	ECNT(FN) -_ CNT
	[TEMP;CFRAG] _ CNT DIVMOD CPW
	IF TEMP#0 THEN MOVE TEMP FROM PTR TO ADR
	EPTR(FN) _ CHPT(PTR+TEMP,-1); PTR _ CHPT(ADR+TEMP,-1)
	REPEAT CFRAG NCHV PTR _ NCHV EPTR(FN)
    END ELSE DO       !DIRECT CHARACTER
	IF PFRAG THEN DO       !CP NOT AT BLOCK BOUNDARY
	  GETCH(HOLD MIN BUFSZ*CPW-PFRAG)
	  CHPT(ADR,PFRAG) _ TEMP     !PFRAG IS DUMMY
	  INC ADR
	  INC PTR
	END
	DZAP; GETCH(CFRAG)
    END
  END

0:       !WORD! &
  IF MODE(FN)=SEQUEN THEN DO          !SEQUEN WORD
	PTR _ 1+EPTR(FN)
	SZAP
	IF CNT#0 THEN DO
	  MOVE CNT FROM PTR TO ADR; EPTR(FN) +_ CNT
	  ECNT(FN) -_ CNT
	END
  END ELSE DO          !DIRECT WORD
	IF PFRAG THEN DO    !CP NOT AT BLOCK BOUNDARY
	  GETWD(HOLD MIN BUFSZ-PFRAG)
	  INC PTR
	END
	DZAP; GETWD(CFRAG)
  END

2:       !PACK! &
IF SUBCNT(FN)>0 THEN DO    !CP NOT AT WORD BOUNDARY
	GETPK(HOLD)
END ELSE DO     !CP AT WORD BOUNDARY
  IF MODE(FN)=SEQUEN THEN DO      !SEQUEN PACK
	PTR _ 2+EPTR(FN)
	SZAP
	[TEMP;CFRAG] _ CNT DIVMOD 9
	IF TEMP#0 THEN DO
	  MOVE TEMP*2 FROM PTR TO ADR
	  EPTR(FN) +_ TEMP*2; ADR +_ TEMP*2
	END
	ECNT(FN) -_ CNT-CFRAG
	GETPK(CNT _ CFRAG)
  END ELSE DO       !DIRECT PACK
	IF PFRAG THEN DO     !NOT AT BLOCK BOUNDARY
	  GETPK(HOLD MIN EBUFSZ(FN)-PFRAG)
	  INC PTR
	END
	DZAP; GETPK(CFRAG)
  END
END

END
	CNT _ 0     !READ ALL
HERE:	SETRWE(FN,ULAB); L.ONALT
	IF CNT=HOLD THEN FNERR(EOFERR)
	RETURN HOLD-CNT

%GETPK (C)

LOCAL PKEOF:, PKA, PKB

	SETRWE(FN,PKEOF)
	PKA _ PKB _ 0; I _ 9
	WHILE DEC C>=0 THEN DO
	  TEMP _ R(FN)  !SO EOF EXIT BEFORE DSHL
	  [PKA;PKB] _ [PKA;PKB] DSHL 8; PKB BOR_ TEMP
	  IF DEC I=0 THEN DO
	    ^ADR _ PKA <==0; ^INC ADR _ PKB <==0; INC ADR
	    CNT -_ I _ 9
	  END
	END
PKEOF:	IF I<9 THEN DO
	  CNT -_ 9-I
	  [PKA;PKB] _ [PKA;PKB] DSHL I*8
	  [I;TEMP] _ [BNOT 0; BNOT 0] DSHL I*8
	  ^ADR _ ^ADR BAND BNOT I BOR PKA
	  ^ADR _ ^INC ADR BAND BNOT TEMP BOR PKB
	  INC ADR
	END
	IF C>=0 THEN GO HERE   !HIT EOF
	SETRWE(FN,HERE)
	RETURN
END GETPK

%SZAP
! READ FULL WDS FROM PTR INTO BUFFER AT ADR UNTIL CNT<=ECNT(FN).
! UPDATE ADR AND COUNT.

	WHILE CNT>ECNT(FN) THEN DO
	  IF ECNT(FN)#0 THEN DO
	    MOVE I _ WPB(ECNT(FN)) FROM PTR TO ADR
	    ADR +_ I; CNT -_ ECNT(FN) <== 0
	  END
	  PTR _ S.RBLK(FN)
	END
	RETURN

END SZAP

%DZAP
! READ BLOCKS DIRECTLY FROM FN INTO BUFFER AT ADR
! STARTING AT BLOCK:  PTR
! NO. OF BLOCKS:  DETERMINE FROM REMAINING ELEMENT COUNT, CNT,
! BUT DO NOT READ PAST PENULTIMATE BLOCK.
! SET CFRAG TO ELEMENT FRAGGLE BEYOND LAST BLOCK READ.

	  [TEMP;CFRAG] _ CNT DIVMOD EBUFSZ(FN)
	  EXU(UGFCD,FN,@I)
	  IF TEMP > I_TEMP MIN RH(@I)-PTR THEN DO  !EOF
	    TEMP _ I; CFRAG _ EBUFSZ(FN)
	  END
	  IF TEMP >0 THEN DO
	    FOR J _ PTR TO PTR+TEMP-1 DO        !WRITE OUT IF DIRTY
	      FOR I _ 0 TO NBUFS-1 DO
	        IF FN.ID(I)=FN AND BLK.ID(I)=J AND DIRTY(I) THEN DO
	          CLEAN(I)
	        END
	      END
	    END
	    RBLK(FN,TEMP,ADR,PTR); ADR +_ TEMP*BUFSZ
	    CNT -_ I_TEMP*EBUFSZ(FN)
	    MXACP(FN) _ MXACP(FN) MAX SETCP(FN,DCP(FN)+I)
	  END
	RETURN
END DZAP

END RB

END R


%GETLINE (FN)

! READS A LINE FROM FN AND, IF FN IS TEL:
!  STORES LINE IN NEW (IMAGE) BUFFER.  HANDLES OVERFLOW LOCALLY BY
!  REQUESTING NEW LINE.  PERFORMS EDITING SPECIFIED BY CONTROL
!  CHARACTERS, WITH OLD LINE BEING LINE PASSED IN NEW BUFFER
!  FOLLOWED BY EOLIT.  ECHO CR AFTER LF.
!  TERMCH - END OF LINE CHAR IN ADDITION TO CARRET (EOLIT IF NONE))
!  %PROMPT - PRINTS PROMPT CHARACTERS
! IF FN IS NOT TEL:
!  IGNORES EOLITS.  STORES LINE IN OLD (FREE) BUFFER. IGNORES ANY
!  CHARS AT FILE END NOT FOLLOWED BY CARRET.
!  ERRORS: EOFERR, LNGERR (LINE TOO LONG), ABNERR.
!  WHEN EOFERR OCCURS, IF OBP#OBPI, CHARS LIE BETWEEN LAST CR
!  AND EOF, ELSE EOF FOLLOWS CR IMMEDIATELY.
!
! IN EITHER CASE, LINE IS STORED WITH TERMINATOR AND EOLIT AT END
! AND PTR TO 1 BEFORE FIRST CHAR IS RETURNED.
! GLOBAL GLCNT CONTAINS NO. OF CHARS STORED (EXCLUDING EOLIT).
!
! LF-CR HANDLING IS MACHINE DEPENDENT:
!  FILE INPUT: CR LF TERMINATES LINES, TRANSLATES TO CR EOLIT.
!              OTHERWISE, CR AND LF ARE NOT SPECIAL.
!  TERMINAL INPUT: CR IS ALWAYS FOLLOWED BY LF BY THE SYSTEM. IT TERMINATES
!                  THE LINE, TRANSLATES TO CR EOLIT.
!                  CR IS ECHOED AFTER LF IS RECEIVED.

LOCAL OBP              !CURRENT OLD LINE PTR
LOCAL OBPB, NBPB       !NCHV IS 1ST CHAR OF LINE OR INSERT
LOCAL OBPLE            !END OF OLD LINE (NCHV IS EOLIT)
LOCAL OBPE             !LIMIT TO OBP; INITIALLY OBPLE; MOVES PAST
                       !LINE END WITH OBP WHEN CHARS ARE STORED IN NEW

LOCAL %PNB, %ECHK, %GETTAB, %NLPOS, %NXCH
LOCAL AFG, E.ON, CHAR, POS, TEMP, J, HOLD
LOCAL MYMODE, DELFG, EXCFG, SAVLOC, ALTFX:, SAVDEST

DEF NBCHKB AS IF NBP=NBPB THEN GO RING
DEF OB.END AS OBP=OBPE

!ADVANCE 1 CHAR IN OLD
DEF FORW.OB AS [IF OB.END THEN NCHV OBPE; NCHV OBP]

!BACKSPACE 1 CHAR IN OLD
DEF BACK.OB BY DO
  IF OBP=OBPB THEN GO RING
  IF OB.END#OBPLE THEN PCHV OBPE; PCHV OBP
END
ENDM BACK.OB

!COPY 1 CHAR FROM OLD TO NEW & PRINT IT. EXIT IF TERMINATOR.
DEF COPRNX AS IF TERM(PUTC(PNB(NCHV OBP))) THEN GO XIT

         IF FN#TEL THEN DO
           OBP _ OBPI; GLCNT _ 0; CHAR _ NXCH
           WHILE INC GLCNT<=LLEN THEN DO
	     IF NCHV OBP _ CHAR =CARRET THEN DO
	       EIF NXCH#LNFEED THEN CHAR _ TEMP  !FROM NXCH
	       ELSE DO
                  NCHV OBP _ EOLIT
                  IF (FN=CFN) THEN DO
                     IF (COM.ECHO.DEST BAND TO.TOUT) AND TOUT.FILE THEN DO
                        TEMP _ TT.DEST(TO.TOUT)
                        PROMPT   ! PUTS PROMPT TO SAME DEST AS COM ECHO.
                        F.P.PRINT(TOUT.FILE,OBPI)
                        TT.DEST(TEMP)
                     END
                     IF (COM.ECHO.DEST BAND TO.TERM) THEN DO
                        TEMP _ TT.DEST(TO.TERM)
                        PROMPT
                        PRINT(FREE)
                        TT.DEST(TEMP)
                     END
                  END
                  RETURN OBPI
               END
	     END ELSE CHAR _ NXCH
           END
! OVERFLOW ON FILE LINE AT CHAR
           CHV OBP _ CARRET; NCHV OBP _ EOLIT
           LOOP DO
	     IF CHAR=CARRET THEN DO
	       WHILE NXCH#LNFEED; CHAR _ TEMP
	     END ELSE CHAR _ NXCH
           END
           FNERR(LNGERR)
         END

! TERMINAL INPUT
         SET.CTRL
	 ^14 _ OCT 777777.000006	! .GTPRV
	 EXU(CLICD,14,GTTAB)
	 MYMODE _ BYT(^14,2,8)
         SAVLOC _ ALTLOC
         AFG _ E.ON _ NO

RSTRT:   OBP _ OBPB _ OBPE _ OBPI
         HOLD _ NBP _ NBPB _ NBPI

!  MOVE NEW TO OLD & CLEAR NEW
         WHILE NCHV OBPE_NCHV HOLD #EOLIT THEN DO
           IF HOLD=NBPE THEN HALT     !BAD IMAGE LINE
         END
         PCHV OBPE; OBPLE _ OBPE
         ALTLOC _ ALTFX
         SAV.DEST _ TT.DEST(TO.TERM)
PCGET:   MOVE GLBSZ FROM ALL EOLITWD TO IMAGE

         PROMPT
!  GET A CHARACTER. ASSUME LF FOLLOWS CR. IF IN ACTRL/WCTRL MODE,
!  MUST BREAK ON ALL SO CAN PRINT BACK SLASH IF NEC.
!  IGNORE RUBOUT IF MODE # 0.
CGET:	EIF AFG=NO THEN DO
	  WHILE ((CHAR_GET=RUBOUT) and (MYMODE # 0)) THEN NULL
	  EIF CHAR=CARRET THEN GET
	  FIF CHAR=LNFEED THEN PUTX(CARRET)
	END
	ELSE DO
	  OFF.ECHO
	  WHILE (CHAR_GET.BRK=RUBOUT) AND (MYMODE # 0) THEN NULL
	  ON.ECHO
	  IF MYMODE = 0 AND CHAR = RUBOUT THEN CHAR_ ACTRL
	  IF ACTRL#CHAR#WCTRL THEN DO
	    PUT($\); AFG _ NO
	    EIF PUTX(CHAR)=CARRET THEN GET
	    FIF CHAR=LNFEED THEN PUTX(CARRET)
	  END
	END
	 IF MYMODE = 0 AND CHAR = RUBOUT THEN CHAR_ ACTRL
	 IF TERM(CHAR) THEN [PNB(CHAR); GO XIT]
         IF CTRLCH(CHAR) THEN GO CTREXU
CSTOR:   PNB(CHAR); IF NOT E.ON THEN FORW.OB
         GO CGET

PCRXIT:  PUT(PNB(CARRET))  !STORE & PRINT CR
XIT:     PNB(EOLIT)        !STORE EOLIT
         L.OFFALT
         ALTLOC _ SAVLOC
         TT.DEST(SAV.DEST)
         UNSET.CTRL
         L.ONALT
         CHPT(HOLD,GLCNT) _ NBP
         GLCNT +_ (HOLD-IMAGE)*CPW  !EXCLUDE EOLIT FROM COUNT
         IF (TERM.ECHO.P) AND (TOUT.FILE) THEN DO
            TEMP _ TT.DEST(TO.TOUT)
            PROMPT
            TT.DEST(TEMP)
            F.P.PRINT(TOUT.FILE,NBPI)
         END
         RETURN NBPI


!  ALT MODE TYPED.  MOVE OLD BACK TO NEW
ALTFX:   L.OFFALT
         IF (TERM.ECHO.P) AND (TOUT.FILE) THEN DO
            PNB(CARRET)
            PNB(EOLIT)
            F.P.MSG(TOUT.FILE,NBPI)
         END
         MOVE GLBSZ FROM FREE TO IMAGE
         ALTLOC _ SAVLOC
         TT.DEST(SAV.DEST)
         UNSET.CTRL
         L.ONALT; GO ^ALTLOC


!  EXECUTE CONTROL CHARACTER		** BEGIN CASE EXPRESSION **
CTREXU:  IF CHAR>ZCTRL THEN GO RING
         DO CHAR OF ACTRL:ZCTRL

!  CHANGE INSERT MODE; PRINT OPEN OR CLOSE ANGLE BRACKET
ECTRL:   IF NOT ECHK THEN DO
           E.ON _ YES; PUT($<)
           NBPB _ NBP; OBPB _ OBP
         END

!  BACKSPACE OLD & NEW 1 CHAR; PRINT BACK ARROW
NCTRL:   IF NOT E.ON THEN BACK.OB
         NBCHKB; PCHV NBP; PUT($_)

!  BACKSPACE NEW 1 CHAR. PRINT CHAR PRECEDED BY BACK SLASH IF
!  1ST ACTRL/WCTRL.
ACTRL:   NBCHKB; IF NO=AFG<==YES THEN PUT($\)
         PUTC(CHV NBP); PCHV NBP

!  BACKSPACE NEW TO LAST SPACE BEFORE LAST NON-SPACE
!  PRINT SAME AS WOULD ACTRLS.
WCTRL:   NBCHKB; IF NO=AFG<==YES THEN PUT($\)
	LOOP [I_PUTC(CHV NBP); PCHV NBP; WHILE I=$  AND NBP#NBPB]
	WHILE NBP#NBPB AND I_CHV NBP#$  THEN [PUTC(I); PCHV NBP]

!  RESTART OLD & NEW AT BEGINNING OF LINE OR INSERT
!  PRINT UP ARROW & CR
QCTRL:   NBCHKB; NBP _ NBPB; OBP _ OBPB; PUT($^)
         IF NOT E.ON THEN [PUT(CARRET); GO PCGET]

!  STORE BLANKS UP TO NEXT TAB
ICTRL:   REPEAT GETTAB DO
           PUT(PNB($ ))
           IF NOT E.ON THEN FORW.OB
         END

!  COPY OLD TO NEW UP TO NEXT TAB STOP OR TAB CHAR, WHICHEVER COMES FIRST,
!  PRINTING CHARS COPIED.
!  IF HIT TERMINATOR OR END OF OLD, STORE BLANKS UP TO TAB.
UCTRL:   ECHK
         REPEAT GETTAB DO
           IF OB.END THEN DO
             PUT(PNB($ )); NCHV OBPE; NCHV OBP
           END ELSE DO
             IF TERM(CHAR _ NCHV OBP) THEN CHAR _ $ 
             IF PUTC(PNB(CHAR))=ICTRL THEN GO CGET
           END
         END

!  COPY 1 CHAR FROM OLD TO NEW & PRINT
CCTRL:   ECHK; IF OB.END THEN GO RING; COPRNX

!  COPY REST OF OLD TO NEW, PRINTING. ADD CR IF NO TERMINATOR.
DCTRL:   ECHK
         WHILE NOT OB.END THEN COPRNX
         GO PCRXIT   !HERE IF NO TERMINATOR

!  COPY REST OF OLD TO NEW, PRINTING ONLY TERMINATOR (ADD CR IF NONE)
FCTRL:   ECHK
         WHILE NOT OB.END THEN DO
           IF TERM(PNB(I_NCHV OBP)) THEN [PUTC(I); GO XIT]
         END
         GO PCRXIT   !HERE IF NO TERMINATOR

!  COPY OLD TO NEW UP TO BUT NOT INCLUDING TERMINATOR 
!  (UP TO LINE END IF NO TERMINATOR)
!  IF H, ALSO PRINT CHARS; IF L, PRINT ONLY +
HCTRL: LCTRL: &
         ECHK; IF OB.END THEN GO RING
         IF TERM(I_NCHV OBP) THEN [PCHV OBP; GO RING]
         HOLD _ NBP
HCTA:    PNB(I)
         IF NOT OB.END THEN &
           IF TERM(I_NCHV OBP) THEN PCHV OBP ELSE GO HCTA
         IF CHAR=LCTRL THEN PUT($+) ELSE GO RCTB

!  COPY OLD TO NEW UP TO BUT NOT INCLUDING NEXT INPUT CHAR
OCTRL:   DELFG _ NO; EXCFG _ YES; GO CHMTCH

!  COPY OLD TO NEW UP TO & INCLUDING NEXT INPUT CHAR
ZCTRL:   DELFG _ EXCFG _ NO; GO CHMTCH

!  DELETE FROM OLD UP TO BUT NOT INCLUDING NEXT INPUT CHAR
PCTRL:   DELFG _ EXCFG _ YES; GO CHMTCH

!  DELETE FROM OLD UP TO & INCLUDING NEXT INPUT CHAR
XCTRL:   DELFG _ YES; EXCFG _ NO

!  MATCH NEXT INPUT CHAR IN OLD LINE & PROCESS AS FOLLOWS:
!   DELFG - YES IF DELETE, NO IF COPY, CHARS PASSED.
!   EXCFG - YES IF EXCLUDE, NO IF INCLUDE, CHAR MATCHED.
CHMTCH:  ECHK
         OFF.ECHO; IF CHAR _ GET.BRK =CARRET THEN GET.BRK   !BREAK ON THIS CHAR
         ON.ECHO; HOLD _ OBP
         IF EXCFG THEN IF OB.END THEN GO RING ELSE NCHV HOLD
         LOOP DO
           IF HOLD=OBPE THEN GO RING
           WHILE NCHV HOLD#CHAR
         END
         IF EXCFG THEN PCHV HOLD
         WHILE OBP#HOLD THEN IF DELFG THEN [NCHV OBP; PUT($%)] ELSE &
          COPRNX

!  DELETE 1 CHAR FROM OLD. IF S, PRINT %; IF K, PRINT CHAR.
KCTRL: &
SCTRL:   ECHK; IF OB.END THEN GO RING; NCHV OBP
         PUTC(IF CHAR=SCTRL THEN $% ELSE CHV OBP)

!  PRINT REST OF OLD (INCLUDING TERMINATOR) & CURRENT NEW
!  IF NO MORE OLD LINE OR IF TERMINATOR ISN'T CR, PRINT CR
RCTRL:   ECHK; PUTX(LNFEED)
RCTA:    HOLD _ OBP; WHILE HOLD#OBPE THEN PUTC(NCHV HOLD)
         IF CHV(HOLD)#CARRET THEN PUT(CARRET)
         HOLD _ NBPI
RCTB:    WHILE HOLD#NBP THEN PUTC(NCHV HOLD)

!  SAME AS RCTRL EXCEPT OLD & NEW ARE LINED UP
!  NOTE: CTRL CHARS WILL SCREW THIS UP.
TCTRL:   ECHK; PUT(CARRET); REPEAT NLPOS-1 PUT($ ); GO RCTA

!  DO FCTRL ACTION, THEN
!  MAKE NEW LINE OLD LINE; PRINT CR
YCTRL:   ECHK
         WHILE NOT OB.END THEN DO
           IF TERM(PNB(I_NCHV OBP)) THEN [PUTC(I); GO Y1]
         END
         PUT(PNB(CARRET))
Y1:      PNB(EOLIT); GO RSTRT

!  STORE CHAR
GCTRL: MCTRL: JCTRL:   GO CSTOR

!  STORE NEXT INPUT CHAR; TERMINATES IF TERM CHAR
VCTRL:   OFF.ECHO; CHAR _ GET.BRK; ON.ECHO; PUTC(CHAR); GO CSTOR

!  ILLEGAL CONTROL CHARACTERS
BCTRL: &
RING:    PUTX(BELL)

         END

         GO CGET

%ECHK
!  IF IN ECTRL INSERT MODE, TURNS OFF MODE AND PRINTS >,
!  RETURNING YES; OTHERWISE, RETURNS NO.

IF E.ON THEN [PUT($>); NBPB _ NBPI; OBPB _ OBPI]
RETURN E.ON<==NO

END ECHK

%GETTAB
!  RETURNS NUMBER OF POSITIONS BEFORE NEXT TAB
!  TABS ARE IN ARRAY TAB, WHOSE 0TH ELEMENT = NO. OF TABS

POS _ NLPOS-OFF; I _ 0
WHILE INC I<=TAB(0) THEN DO
  IF TAB(I)>POS THEN RETURN TAB(I)-POS
END
GO RING

END GETTAB

%NLPOS
!  RETURNS WHAT TERMINAL POSITION WOULD BE IF NEW LINE WERE PRINTED
!  (MORE OR LESS) USING PUT.

TEMP _ NBPI; POS _ 1
WHILE TEMP#NBP THEN DO
  EIF I_NCHV TEMP=LNFEED THEN POS _ 1
  FIF PRCHAR(I) THEN INC POS
END
RETURN POS

END NLPOS


%PNB (CHAR)
! PUTS CHAR INTO NEW LINE BUFFER. CALLED BY USER
! TO SET EDIT IMAGE FOR NEXT GETLINE. CHECKS FOR OVERFLOW.
! RETURNS CHAR.

IF NBP#NBPE THEN RETURN NCHV NBP_CHAR
CHV(NBP) _ EOLIT; PCHV NBP _ CARRET   !TRUNCATE
E.CHK; CLIBUF; MSG('$Line too long. Truncated line available for edit.$')
GO RSTRT

END PNB


%NXCH
  WHILE TEMP _ R(FN) =EOLIT THEN NULL; RETURN TEMP
END NXCH

END GETLINE

END INIT.R



%W (FN,VAL)

! WRITES SPECIFIED ELEMENT VALUE AT CURSOR POSITION ON FILE FN.
! CHAR OUTPUT TO TERMINAL IF FN IS TEL.
! RETURNS VALUE WRITTEN.
!
! MACHINE DEPENDENCY: CR/LF HANDLING.  LF IS WRITTEN AFTER CR

! WLAB(FN) IS  WTEL IF FN IS TEL
!              W.ERR IF FN IS AN INPUT FILE (CAN'T WRITE)

!              IF DIRECT MODE:
!              WINIT IF THIS IS 1ST ACCESS TO FN AFTER SETCP ON FN
!              WSET IF HAVE READ BUT NOT WRITTEN SINCE SETCP ON FN
!              OTHERWISE, IS ADDRESS OF CORRESPONDING WRITE ROUTINE

!              IF SEQUEN MODE:
!              W.ERR IF INPUT FILE
!              OTHERWISE, ADDRESS OF CORRESPONDING WRITE ROUTINE

LOCAL HOLD, CP.TO.EOF, TEMP

         GO ^YLAB(FN)

YTEL:    IF TERM.DEST BAND TO.TERM THEN PUTTY(VAL)
         IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN GO ^YLAB(FN _ TOUT.FILE)
         RETURN VAL

YCHAR:   IF VAL=CARRET THEN DO
           HOLD _ RETURN; WX(FN,CARRET); WX(FN,LNFEED)
           RETURN _ HOLD; RETURN CARRET
         END

%%WX (FN, VAL)

WXLAB:   GO ^WLAB(FN)

WWD:     IF ECNT(FN)>0 THEN [DEC ECNT(FN); RETURN ^INC EPTR(FN) _ VAL]
         GO NXBLK

WPK:     IF ECNT(FN)>0 THEN DO
           DEC ECNT(FN)
           IF DEC SUBCNT(FN)<0 THEN [EPTR(FN) +_2; SUBCNT(FN)_8]
           [PKA;PKB] _ [^EPTR(FN);^(EPTR(FN)+1)] DROTR SUBCNT(FN)*8
           [^EPTR(FN);^(EPTR(FN)+1)] _ [PKA;PKB BAND BNOT &
             OCT 377 BOR VAL BAND_ OCT 377] DROTL SUBCNT(FN)*8
           RETURN VAL
         END
         GO NXBLK

WCH:     IF ECNT(FN)>0 THEN [DEC ECNT(FN); RETURN NCHV EPTR(FN) _ VAL]

NXBLK:   IF MODE(FN)=SEQUEN THEN [S.WBLK(FN); GO ^WLAB(FN)]
WINIT:   L.OFFALT
         IF CP.TO.EOF _ (TEMP _ DSIZE(FN)) - DCP(FN) <0 AND ORG(FN)#WORD THEN DO
	   !BLANK FILL PAST EOF (UGHLY)
	   HOLD _ RETURN
	   DSETCP(FN,TEMP); REPEAT -CP.TO.EOF W(FN,$ )
	   RETURN _ HOLD
	 END
         GETCHK(FN)
         ! IF PAST EOF, SPECIAL CASE FOR %R
         RLAB(FN) _ IF ECNT(FN)>CP.TO.EOF THEN &
           RINIT ELSE RADR(ORGIND(FN))
         L.ONALT

WSET:    DIRTY(CPBUF(FN)) _ YES
         GO ^WLAB(FN) _ WADR(ORGIND(FN))

WTEL:    IF TERM.DEST BAND TO.TERM THEN PUTTYX(VAL)
         IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN GO ^WLAB(FN _ TOUT.FILE)
         RETURN VAL

W.ERR:   FNERR(FMDERR)


%PLNW (FN, ADR, WCNT)

! MACHINE DEPENDENT.  WRITE SPECIAL FORMAT LINE NO. AT ADR
! (WCNT WDS) ON FILE FN AFTER WRITING EOLITS TO BEGINNING OF
! NEXT WORD.  FOR CHARACTER ORGANIZED FILES ONLY.

LOCAL PTR, I, J

  REPEAT (CPW-(CP(FN) MOD CPW)) MOD CPW W(FN,EOLIT)
  PTR _ CHPT(ADR,-1)
  REPEAT WCNT DO
    REPEAT CPW W(FN,NCHV PTR)
    CHPT(I,J) _ EPTR(FN)
    ^I BOR_ 1    !BIT 35
  END
  W(FN,ICTRL); RETURN

END PLNW

END W


%WB (FN, CNT, ADR)

DEF PUTCH(C) AS TEMP _ CHPT(ADR,-1); REPEAT C WX(FN,NCHV TEMP)
DEF PUTWD(C) AS REPEAT C [W(FN,^ADR); INC ADR]
LOCAL %PUTPK

LOCAL HOLD, TEMP, CFRAG, PFRAG, PTR
LOCAL %SZAP, %DZAP, I

IF WLAB(FN)=W.ERR THEN FNERR(FMDERR)
IF FN=TEL THEN FNERR(TELERR)
IF HOLD _ CNT <0 THEN FNERR(ARGERR)
IF HOLD=0 THEN RETURN
L.OFFALT
[PTR;PFRAG] _ CP(FN) DIVMOD EBUFSZ(FN); INC PTR  !BLK NO & ELMT DISPL

DO ORGIND(FN) OF ORGINDLIM

1:       !CHARACTER! &
  IF PFRAG MOD CPW THEN DO    !CP NOT AT WORD BOUNDARY
    PUTCH(CNT)
  END ELSE DO    !CP AT WORD BOUNDARY
    IF MODE(FN)=SEQUEN THEN DO       !SEQUEN CHARACTER
	CHPT(PTR,PFRAG) _ EPTR(FN); INC PTR
	SZAP
	ECNT(FN) -_ CNT
	[CNT;CFRAG] _ CNT DIVMOD CPW
	IF CNT#0 THEN MOVE CNT FROM ADR TO PTR
	EPTR(FN) _ CHPT(PTR+CNT,-1); PTR _ CHPT(ADR+CNT,-1)
	REPEAT CFRAG NCHV EPTR(FN) _ NCHV PTR
    END ELSE DO       !DIRECT CHARACTER
	IF PFRAG THEN DO       !CP NOT AT BLOCK BOUNDARY
	  PUTCH(I_CNT MIN BUFSZ*CPW-PFRAG); CNT -_ I
	  CHPT(ADR,PFRAG) _ TEMP     !PFRAG IS A DUMMY
	  INC ADR
	  INC PTR
	END
	DZAP; PUTCH(CFRAG)
    END
  END

0:       !WORD! &
  IF MODE(FN)=SEQUEN THEN DO          !SEQUEN WORD
	PTR _ 1+EPTR(FN)
	SZAP
	IF CNT#0 THEN DO
	  MOVE CNT FROM ADR TO PTR; EPTR(FN) +_ CNT
	  ECNT(FN) -_ CNT
	END
  END ELSE DO          !DIRECT WORD
	IF PFRAG THEN DO    !CP NOT AT BLOCK BOUNDARY
	  PUTWD(I_CNT MIN BUFSZ-PFRAG); CNT -_ I
	  INC PTR
	END
	DZAP; PUTWD(CFRAG)
  END

2:       !PACK! &
IF SUBCNT(FN)>0 THEN DO    !CP NOT AT WORD BOUNDARY
	PUTPK(HOLD)
END ELSE DO
  IF MODE(FN)=SEQUEN THEN DO    !SEQUEN PACK
	PTR _ 2+EPTR(FN)
	SZAP
	[TEMP;CFRAG] _ CNT DIVMOD 9
	IF TEMP#0 THEN DO
	  MOVE TEMP*2 FROM ADR TO PTR
	  EPTR(FN) +_ TEMP*2; ADR +_ TEMP*2
	END
	ECNT(FN) -_ CNT-CFRAG
	PUTPK(CFRAG)
  END ELSE DO      !DIRECT PACK
	IF PFRAG THEN DO    !NOT AT BLOCK BOUNDARY
	  CNT -_ PUTPK(HOLD MIN EBUFSZ(FN)-PFRAG)
	  INC PTR
	END
	DZAP; PUTPK(CFRAG)
  END
END

END
L.ONALT
RETURN HOLD

%PUTPK (C)
LOCAL PKA, PKB

	PKA _ ^ADR; PKB _ ^(ADR+1); I _ 9
	REPEAT C DO
	  [PKA;PKB] _ [PKA;PKB] DROTL 8
	  W(FN,PKB BAND OCT 377)
	  IF DEC I=0 THEN DO
	    ADR +_ 2; PKA _ ^ADR; PKB _ ^(ADR+1); I _ 9
	  END
	END
	RETURN C
END PUTPK

%SZAP
! WRITE FULL WORDS FROM BUFFER AT ADR TO PTR UNTIL CNT<=ECNT(FN).
! UPDATE ADR AND CNT.

	WHILE CNT>ECNT(FN) THEN DO
	  IF ECNT(FN)#0 THEN DO
	    MOVE I_WPB(ECNT(FN)) FROM ADR TO PTR
	    ADR +_ I; CNT -_ ECNT(FN) <==0
	  END
	  PTR _ S.WBLK(FN)
	END
	RETURN
END SZAP

%DZAP
! WRITE BLOCKS DIRECTLY FROM BUFFER AT ADR TO FN
! STARTING AT BLOCK PTR.
! NO. OF BLOCKS: DETERMINE FROM REMAINING ELEMENT COUNT, CNT.
! SET CFRAG TO ELEMENT FRAGGLE BEYOND LAST BLOCK WRITTEN.

	  [CNT;CFRAG] _ CNT DIVMOD EBUFSZ(FN)
	  IF CNT>0 THEN DO
	    WBLK(FN,CNT*BUFSZ,ADR,PTR); ADR +_ CNT*BUFSZ
	    MXACP(FN) _ MXACP(FN) MAX DSETCP(FN,DCP(FN)+CNT*EBUFSZ(FN))
	    REPEAT CNT DO
	      FOR I _ 0 TO NBUFS-1 DO
	        IF FN.ID(I)=FN AND BLK.ID(I)=PTR THEN FN.ID(I)_-1
	      END
	      INC PTR
	    END
	  END
	RETURN
END DZAP

END WB


%GETCHK (FN)

! CHECKS WHETHER BLOCK CONTAINING CP(FN) IS ALREADY IN A BUFFER.
! IF NOT, A BUFFER IS SELECTED INTO WHICH TO READ THE BLOCK (NXBUF
! INDICATES 1ST BUFFER TO EXAMINE); THE BLOCK IS READ & THE BUFFER
! SET CLEAN.  IN ANY CASE, GETCHK SETS THE ELEMENT POINTER & COUNT,
! (WHICH IS NO. OF ELEMENTS FROM CP TO END OF BLOCK)
! SETS CPBUF(FN) TO INDICATE BUFFER CONTAINING CP(FN), 
! RETURNS ADDRESS OF 1ST WORD OF BUFFER,
! AND RESETS NXBUF TO POINT TO 1ST BUFFER TO BE EXAMINED AT NEXT
! BUFFER SELECTION TIME.

LOCAL %SETNXBUF
LOCAL DISPL, BLKNUM, HOLD

         [BLKNUM;DISPL] _ DCP(FN) DIVMOD EBUFSZ(FN)
         INC BLKNUM          !FIRST BLOCK IS BLOCK NO. 1
         FOR I _ 0 TO NBUFS-1 &
          IF FN.ID(I)=FN AND BLK.ID(I)=BLKNUM THEN [NXBUF_I; GO GET1]

!BLOCK NOT ALREADY IN BUFFER
         IF NOT RBLK(FN,1,BGNADR(SETNXBUF),BLKNUM) THEN DO
           MOVE BUFSZ FROM ALL 0 TO BGNADR(NXBUF)
         END
         FN.ID(NXBUF)_FN; BLK.ID(NXBUF)_BLKNUM; DIRTY(NXBUF) _ NO
GET1:    HOLD _ BGNADR(NXBUF)
         DO ORGIND(FN) OF ORGINDLIM
0:         EPTR(FN) _ HOLD+DISPL-1
1:         EPTR(FN) _ CHPT(HOLD,DISPL-1)
2:         [PKA;PKB] _ DISPL DIVMOD 9
           EPTR(FN) _ HOLD+2*PKA-2*[SUBCNT(FN)_(9-PKB) MOD 9=0]
         END
         ECNT(FN) _ EBUFSZ(FN)-DISPL
         CPBUF(FN) _ NXBUF <== (NXBUF+1) MOD NBUFS
         RETURN HOLD

%SETNXBUF
! BEGINS EXAMINING BUFFERS AT NXBUF. RESETS NXBUF TO POINT
! TO BUFFER THAT FILE BLOCK IS TO BE READ INTO. RETURNS NXBUF.
! PRIORITY FOR SELECTION:
!  1) UNUSED BUFFER
!  2) CLEAN BUFFER NOT CPBUF FOR ITS FN.ID
!  3) DIRTY BUFFER NOT CPBUF FOR ITS FN.ID
!  4) CLEAN BUFFER (IS CPBUF)
!  5) NXBUF (IS DIRTY AND CPBUF)
! IF 3) OR 5), BLOCK CURRENTLY IN BUFFER IS WRITTEN OUT
! IF 4) OR 5), MUST RELINQUISH CPBUF WITH A DSETCP

LOCAL LAB, CHK3:, CHK2:, CHK1:, CHK:
DEF IF.MORE AS IF INC I=NBUFS THEN I_0; WHILE I#NXBUF
DEF ACTIVE(I) AS I=CPBUF(FN.ID(I))

         I _ NXBUF
         LOOP [IF FN.ID(I)<0 THEN GO OUT; IF.MORE]
	LAB _ CHK3
	LOOP DO
	  GO ^LAB
CHK3:	  IF DIRTY(I) AND ACTIVE(I) THEN [HOLD _ I; LAB _ CHK2]
CHK2:	  IF NOT DIRTY(I) AND ACTIVE(I) THEN [HOLD _ I; LAB _ CHK1]
CHK1:	  IF DIRTY(I) AND NOT ACTIVE(I) THEN [HOLD _ I; LAB _ CHK]
CHK:	  IF NOT DIRTY(I) AND NOT ACTIVE(I) THEN [HOLD _ I; GO THRU]
	  IF.MORE
	END
THRU:	I _ HOLD
	IF FN.ID(I)#FN THEN DSETCP(FN.ID(I),DCP(FN.ID(I)))
	IF DIRTY(I) THEN CLEAN(I)
OUT:     RETURN NXBUF _ I

END SETNXBUF

END GETCHK


%RBLK (FN, NBLKS, ADR, BLKNO)
! MACHINE DEPENDENT.
! DIRECT BLOCK INPUT.
! READS NBLKS BLOCKS FROM BLKNO ON FN TO ADR.
! IF EOF HIT, RETURNS 0 ELSE RETURNS 1.

LOCAL LIST(0:1)
LOCAL ERRCHK:,EOF:,OUTERR:

         EXU(USICD, FN, BLKNO)   !POSITION AT BLKNUM
         LIST(0) _ [18,18] * [-BUFSZ*NBLKS, ADR-1]
         LIST(1) _ 0
         EXU(INCD, FN, LIST, ERRCHK); RETURN YES
ERRCHK:  EXU(STZCD, FN, OCT 740.000, EOF)
OUTERR:  ABNERR(FN)

%%WBLK (FN, NWDS, ADR, BLKNO)

! MACHINE DEPENDENT.  CALLED FROM %CLOSE, %SETNXBUF, %ERASE, %WB
! DIRECT BLOCK OUTPUT.
! WRITES OUT NWDS WORDS AT ADR ON FN AT BLKNO.
! IF BLKNO EXCEEDS FILE SIZE, INTERVENING BLOCKS ARE FILLED WITH
! ZEROES.

         EXU(USOCD, FN, BLKNO)
         LIST(0) _ [18,18] * [-NWDS, ADR-1]
         LIST(1) _ 0
         EXU(OUTCD, FN, LIST, OUTERR)
EOF:     RETURN NO

END RBLK


%S.RBLK (FN)
! MACHINE DEPENDENT.
! SEQUENTIAL BLOCK INPUT.
! ADVANCES TO NEXT BUFFER & READS IN NEXT BLOCK ON FN
! SETS EPTR(FN) & ECNT(FN) (LATTER APPROX. FOR NON-WORD FILES)
! INCREMENTS CP1(FN) BY ECNT(FN).
! RETURNS ADDRESS OF 1ST WD OF NEXT BUFFER.

LOCAL ERRCHK:, EOF:, OUTERR:

         L.OFFALT
         RH(CURBUF(FN)+1) _ BUFSZ
         EXU(INCD, FN, 0, ERRCHK)  !S.ECNT(FN) GETS CHAR CNT
         ECNT(FN) _ S.ECNT(FN)/CPW*EBUFSZ(FN)/BUFSZ
         GO BELOW

ERRCHK:  EXU(STZCD, FN, OCT 740.000, EOF)
OUTERR:  ABNERR(FN)
EOF:     FNERR(EOFERR)

%%S.WBLK (FN)

! MACHINE DEPENDENT. CALLED FROM %CLOSE AND %W.
! SEQUENTIAL BLOCK OUTPUT.
! WRITES OUT BLOCK IN CURRENT BUFFER ON FN (NONE 1ST TIME THRU)
! & ADVANCES TO NEXT BUFFER, PREPARING IT FOR WRITING.
! SETS EPTR(FN) & ECNT(FN), INC'ING CP1(FN) BY THE LATTER.
! RETURNS ADDRESS OF 1ST WORD OF NEXT BUFFER.

         L.OFFALT
         EXU(STSCD, FN, OCT 20)          !BIT 31 SAYS TO OBEY OUR WORD COUNT
         RH(CURBUF(FN)+1) _ WPB(EBUFSZ(FN)-ECNT(FN))   !SET (EXACT) WORD COUNT
         EXU(OUTCD, FN, 0, OUTERR)
         ECNT(FN) _ EBUFSZ(FN)
BELOW:   DO ORGIND(FN) OF ORGINDLIM
0:         EPTR(FN) _ CURBUF(FN)+1
1:         EPTR(FN) _ S.EPTR(FN)
2:         EPTR(FN) _ CURBUF(FN); SUBCNT(FN) _ 0
         END
         CP1(FN) +_ ECNT(FN)
         L.ONALT
         RETURN CURBUF(FN)+2

END S.RBLK



%ERASE (FN, CPI, CPF)

!  FN MAY NOT BE TEL OR A SEQUEN MODE OR INPUT TYPE FILE.

! WRITES OUT ZEROES FROM POSITIONS CPI TO CPF ON FILE FN.
! PHYSICALLY TRUNCATES FILE IF POSSIBLE.

! %W IS USED TO ERASE ANY PARTS OF (NOT ENTIRE) BLOCKS IN THE RANGE.
! TO ERASE THE 1ST ENTIRE BLOCK, IF ANY, A BUFFER IS SOUGHT
! (THRU %GETCHK), CLEARED & WRITTEN OUT (I.E., %W NOT USED).
! SUBSEQUENT ENTIRE BLOCKS ARE ERASED BY WRITING OUT THIS SAME CLEARED
! BUFFER.  TO ACHIEVE THIS, SUBSEQUENT CALLS TO %GETCHK ARE "FIXED"
! SO THAT IF THE BLOCK SOUGHT IS NOT ALREADY IN A BUFFER, THE BUFFER
! SELECTED IS THE ONE PREVIOUSLY CLEARED (ZBUF).  THE FIX IS TO MAKE
! ZBUF LOOK LIKE IT HOLDS THE BLOCK SOUGHT, BY INCREMENTING ITS 
! BLK.ID AND MAKING CERTAIN THAT NXBUF IS 1 PAST ZBUF, SO THAT
! ZBUF IS EXAMINED LAST AND CHOSEN IF THE BLOCK WASN'T IN ANOTHER
! BUFFER.

! IF CPF EXCEEDS POSITION OF LAST ELEMENT (SIZE(FN)-1), IT IS SET
! TO THAT POSITION, AND ERASE LEAVES CURSOR AT CPI (NEW FILE END)
! & REDUCES MXACP AND OPNSZ TO CPI; ELSE
! CURSOR IS LEFT AT CPF+1.

LOCAL CNT, DISPL, ZBUF, LAST, EVAL
LOCAL %TRUNCATE, CLR:

         IF FTYP(FN)=INPUT THEN FNERR(FMDERR)
         IF CPF<0 THEN FNERR(ARGERR)
         SETCP(FN,CPI)     !ERROR IF SEQUEN OR <0
         IF CPF _ CPF MIN LAST _ (DSIZE(FN)-1)>=CPI THEN DO

	 EVAL _ IF ORG(FN)=WORD THEN 0 ELSE $ 
         IF DISPL _ CPI MOD EBUFSZ(FN) #0 THEN DO
           IF CNT _ EBUFSZ(FN)-(CPF-CPI+1+DISPL) >=0 THEN GO ZREST

!CPI NOT AT BEGINNING & CPF PAST END
           LOOP[W(FN,EVAL); WHILE ECNT(FN)#0]
         END

!CP(FN) AT BLOCK BEGINNING
         IF CNT _ EBUFSZ(FN)-(CPF-DCP(FN)+1) >0 THEN DO

!CPI NOT AT BEGINNING OF BLOCK & CPF AT OR BEFORE END,
!OR CP(FN) AT BEGINNING & CPF BEFORE END.
!CNT IS NO. OF ELEMENTS PAST CPF
ZREST:     LOOP[W(FN,EVAL); WHILE ECNT(FN)#CNT]
         END ELSE DO

!CP(FN) AT BEGINNING & CPF AT OR BEYOND END
           IF CPF=LAST THEN [TRUNCATE(DCP(FN)/EBUFSZ(FN),CLR); GO CHOP]
!SELECT BUFFER, CLEAR IT, WRITE IT OUT
CLR:       MOVE BUFSZ FROM ALL EVAL TO GETCHK(FN); ZBUF _ CPBUF(FN)
           LOOP DO
             WBUF(ZBUF); WHILE CNT#0

!MORE TO GO. SET TO 1ST POSITION AFTER BLK JUST WRITTEN
             IF CNT _ EBUFSZ(FN)-(CPF-DSETCP(FN,BLK.ID(ZBUF)*EBUFSZ(FN))+1) >0 THEN GO ZREST
             INC BLK.ID(ZBUF); GETCHK(FN)
             IF CPBUF(FN)#ZBUF THEN !BLK ALREADY IN BUFFER! &
                    [FN.ID(CPBUF(FN))_-1; NXBUF _ (ZBUF+1) MOD NBUFS]
           END
         END

         IF CPF<LAST THEN DO
           IF CNT=0 THEN DSETCP(FN,CPF+1)
         END ELSE DO
CHOP:      DSETCP(FN,CPI); MXACP(FN) _ OPNSZ(FN) _ SZFG(FN) _ CPI
         END

         END
         RETURN

%TRUNCATE (NBLKS, ERLAB:)
! MACHINE DEPENDENT
! TRUNCATE FILE FN TO NBLKS BLOCKS; GO TO ERLAB IF CAN'T

LOCAL RNMOK:

MOVE 4 FROM @MINFID(FN*4) TO @ARGCNT(FIDTBL)+1
ARGCNT(FIDTBL) _ 9; FIDTBL(LOCWPF+9) _ NBLKS
MOVE 4 FROM ALL 0 TO @ARGCNT(FIDTBL)+5
EXU(RNMCD, FN, @ARGCNT(FIDTBL), RNMOK ); GO ERLAB
RNMOK: ARGCNT(FIDTBL) _ MINARG
OPEN1
RETURN

END TRUNCATE

END ERASE


%TTYIO

! REST OF TERMINAL AND TOUT I/O PROCEDURES
! IN THE SET OF PROCEDURES THAT PRINT CHARACTERS TO TEL ARE TWO GROUPS:
! ONE GROUP CONSISTS OF THE PRIMITIVE PROCEDURES THAT PRINT DIRECTLY TO THE
! TERMINAL (%MSG.TTY, %PRNTTC, %PRNTTY, %PUTTYC, %PUTTY, %PUTTYX);
! THE OTHERS PRINT TO A TOUT FILE IF IT EXISTS, ELSE TO THE
! TERMINAL (%MSG, %PRINTC, %PRINT, %PUTC, %PUT, %PUTX).

LOCAL TEMP, TTY.P, TEMP1
LOCAL SPCNT              !NUMBER OF PENDING OUTPUT SPACES

DEF INITPOS AS [PUT.CR; SPCNT_0]
DEF FILLSP AS [REPEAT SPCNT TTY_$ ;  SPCNT_0]

! INITIALIZATION

SPCNT _ 0
EXTOUT(TEL)
EX.CFN(TEL)
TT.DEST(TO.TERM)
CF.ECHO(TO.NEITHER)
RETURN


%EXTOUT(FILNUM)

! SETS TOUT OUTPUT TO FILE FILNUM. RETURNS CURRENT TOUT FILE NUMBER.
! (AN EXCHANGE)

   RETURN TOUT.FILE <== FILNUM

END EXTOUT


%EX.CFN(FILNUM)

%%SET.CFN(FILNUM)   ! THE OLD NAME

! SETS COMMAND INPUT FROM FILNUM. NO ERROR CHECKING IS DONE ON FILNUM TO SEE
! THAT IT IS OPEN. RETURNS CURRENT COMMANDS FILE NUMBER.

   RETURN (CFN <== FILNUM)

END EX.CFN


%TT.DEST(WHERE)

! SETS DESTINATION OF TERMINAL OUTPUT. TO TERM, TOUT, BOTH, OR NEITHER.
! RETURNS OLD DESTINATION.

   RETURN (TERM.DEST <== WHERE)

END TT.DEST


%CF.ECHO(WHERE)

! SETS DESTINATION OF COMMANDS FILE ECHO. TO TERM, TOUT, BOTH, OR NEITHER.
! RETURNS OLD DESTINATION.

   RETURN (COM.ECHO.DEST <== WHERE)

END CF.ECHO


%TT.ECHO(ON.P)

! SETS ON/OFF STATE OF INPUT FROM TERMINAL ECHOING TO TOUT FILE.
! RETURNS OLD STATE VALUE.

   RETURN (TERM.ECHO.P <== ON.P)

END TT.ECHO


%CLIBUF

! CLEAR INPUT BUFFER

EXU(TTCD,OCT 11,0); RETURN

END CLIBUF


%CLOBUF

! CLEAR OUTPUT BUFFER

EXU(TTCD,OCT 12,0); RETURN

END CLOBUF


%TTYLEN
!  TERMINAL WIDTH

^14_-1; EXU(CLICD,14,-OCT 16)   !GETTMC
RETURN (^14 BAND OCT 17740.000000) SHR 23

END TTYLEN


%GET.BRK

! READS A CHARACTER FROM THE TERMINAL & BREAKS ON IT,

FILLSP
EXU(TTCD, 0, @I);  RETURN I

%%GET

! READS A CHARACTER FROM THE TERMINAL & RETURNS IT.
! FIRST PRINTS ANY PENDING OUTPUT SPACES (SEE PUT & PUTX)

         FILLSP;  RETURN TTY

END GET.BRK


%PUTTYX (CHAR)

! PRINTS CHAR ON TERMINAL AND RETURNS CHAR.
! PRINTS SPACES ONLY IF PRINTING CHAR FOLLOWS.
! UNLIKE PUTTYX, PUTTY
!    PRINTS LF AFTER CR
!    PRINTS CR AFTER LF

         EIF CHAR=CARRET THEN INITPOS
         ORIF CHAR=LNFEED THEN DO
           FILLSP; PUT.LF
         END
         ELSE GO PUT1
         RETURN CHAR

%%PUTTY (CHAR)

         EIF ICTRL<=CHAR<=MCTRL THEN DO CHAR OF ICTRL:MCTRL
MCTRL:     INITPOS; PUT.LF
JCTRL:     PUT.LF; INITPOS
ICTRL: LCTRL:  TTY _ CHAR
KCTRL:     GO PUT2
         END
         ORIF CTRLCH(CHAR) THEN DO
PUT2:      TTY_$&; TTY_UNCTRL(CHAR)
         END
PUT1:    ORIF NOT PRCHAR(CHAR) THEN TTY_CHAR
         ELSE DO
           IF CHAR#$  THEN [WHILE DEC SPCNT>=0 THEN TTY_$ ; TTY_CHAR]
           INC SPCNT
         END

         RETURN CHAR


END PUTTYX


%PUTX (CHAR)

! PUTS CHAR, EXACTLY, TO TERM.DEST .

   IF (TERM.DEST BAND TO.TERM) THEN PUTTYX(CHAR)
   IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN RETURN (WX(TOUT.FILE,CHAR))
   RETURN CHAR

END PUTX


%PUT (CHAR)

! PUTS TO TERM.DEST THE CHARACTER, PROPERLY TRANSLATED.

   IF (TERM.DEST BAND TO.TERM) THEN PUTTY(CHAR)
   IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN RETURN (W(TOUT.FILE,CHAR))
   RETURN CHAR

END PUT


%PUTTYC (CHAR)

! PRINTS CONTROL CHARACTERS (EXCEPT &I AND &L) AS '&''CHAR', TO TEL.

   TTY.P _ YES
   GO PUTC.LOOP

%%PUTC (CHAR)

! PRINTS TO TERM.DEST.

   TTY.P _ NO

PUTC.LOOP:  IF ICTRL#CHAR#LCTRL THEN DO
                RETURN (IF TTY.P THEN PUTTY(CHAR) ELSE PUT(CHAR))
            END ELSE DO
                IF TTY.P THEN [PUTTY($&); RETURN (PUTTY(UNCTRL(CHAR)))]
                PUT($&); RETURN (PUT(UNCTRL(CHAR)))
            END

END PUTTYC




%PRNTTY (ADR)

! PRINTS STRING STARTING AT ADR TERMINATED BY EOLIT

   LOCAL TEMP

   TEMP _ TT.DEST(TEL)
   TT.DEST(TEMP <== F.P.PRINT(TEL,CHPT(ADR,-1)))
   RETURN TEMP

%%PRINT (ADR)   ! PRINTS TO TERM.DEST

   RETURN (F.P.PRINT(TEL,CHPT(ADR,-1)))


%F.P.PRINT(FILE,POINTER)  ! PRINT MESSAGE AT POINTER TO FILE

   LOCAL CHAR

   WHILE CHAR _ NCHV(POINTER) # EOLIT THEN W(FILE,CHAR)
   RETURN

END F.P.PRINT


END PRNTTY


%PRNTTC (ADR)

! PRINTS STRING AT ADR USING %PUTC

   TTY.P _ YES
   GO PRNTC.LOOP

%%PRINTC (ADR)

! PRINTS TO TOUT

   TTY.P _ NO

PRNTC.LOOP:  &
TEMP _ CHPT(ADR,-1)
WHILE I_NCHV TEMP#EOLIT THEN [IF TTY.P THEN PUTTYC(I) ELSE PUTC(I)]
RETURN

END PRNTTC


%MSG.TTY (ADR)

! PRINTS STRING STARTING AT ADR TERMINATED BY EOLIT,
! IN WHICH $ DESIGNATES CR & \CHAR DESIGNATES CONTROL CHAR.

   DEF CTRL(CHAR) AS (CHAR-$M+CARRET) ! MACHINE DEPENDENT BUT HANDLES IX AND X.


   TEMP _ TT.DEST(TEL); TT.DEST(TEMP <== F.P.MSG(TEL,CHPT(ADR,-1))); RETURN TEMP

%%MSG (ADR)   ! PRINTS TO TERM.DEST

   RETURN (F.P.MSG(TEL,CHPT(ADR,-1)))

%F.P.MSG (FILE,POINTER)   ! PUT A MESSAGE TO A FILE GIVEN A POINTER.
                          ! CONVERTS '$' TO CARRET, '\X' TO CONTROL-X.

   DEF NXTCHR AS [WHILE (C _ NCHV(POINTER)) # EOLIT] 

   LOCAL C

   LOOP DO
      NXTCHR
      EIF C=$$ THEN W(FILE,CARRET)
      ORIF C=$\ THEN DO
         NXTCHR
         IF $@ <= C <= $_ THEN C _ MKCTRL(C)
         WX(FILE,C)
      END
      ELSE W(FILE,C)
   END

   RETURN

END F.P.MSG

END MSG.TTY

END TTYIO


!     *****  EXCEPTION HANDLING

%ARTHOV(ADDR)

! IF ADDR=0 , ALL ARITHMETIC OVERFLOW WILL BE IGNORED. OTHERWISE, IT WILL
! TRAP BY EXECUTING A JSR ADDR INSTRUCTION FROM THE MONITOR'S PROCESS TABLE.

   LOCAL RETURN.ADDR:

   ARTHOV.ADDR _ ADDR

   IF ADDR = 0 THEN ^14 _ JFCL ELSE ^14 _ JSR + ADDR
   EXU(CLICD, 14, -OCT 40, RETURN.ADDR)   !SETTR1 CALLI
RETURN.ADDR:   RETURN

END ARTHOV


%DDTOVR(STATE)

! IF STATE IS TRUE, THEN EVEN IF LOADED WITH DDT, IOCS WILL ARM ESCAPES.

   RETURN (DDTFLG <== STATE)

END DDTOVR


%NOESC

! ROUTINE TO DISABLE ESCAPES FOR USER PROGRAM
! NOTE THAT ESCAPES ARE NOT QUEUED WHILE NOESC.P IS TRUE (I.E.,NONZERO)

NOESC.P _ 1;  SETALT(ALTNIL)
RETURN

END NOESC


%YESESC

! ROUTINE TO REENABLE ESCAPES FOR USER PROGRAM
! ESCAPES QUEUED PRIOR TO CALLING NOESC WILL BE ACTED UPON BY ONALT, NOT HERE

NOESC.P _ 0
IF ALTLEV <= 1 THEN DO
   SETALT(ALT);  IF TRPFG>0 THEN GO ALT
END
RETURN

END YESESC


%OFFALT

IF INC ALTLEV > 1 THEN RETURN   ! ESCAPES ALREADY DISARMED.
! REALLY DISARM, FIRST TIME:

TRPFG _ 0; SETALT(ALTNIL)
RETURN

END OFFALT


%ONALT

IF ALTLEV=0 OR DEC ALTLEV>0 THEN RETURN
IF NOT NOESC.P THEN DO
   SETALT(ALT); IF TRPFG>0 THEN GO ALT
END
RETURN

END ONALT


%ONALT.C

ALTLEV _ 1; ONALT; RETURN

END ONALT.C


%SET.ARTHOV

! CHECKS TO SEE IF ARITHMETIC OVERFLOW SHOULD BE TRAPPED.

   LOCAL RETN.ADDR:

   IF ARTHOV.ADDR THEN DO

      ^14 _ JSR + ARTHOV.ADDR
      EXU(CLICD, 14, -OCT 40, RETN.ADDR)   !SETTR1 CALLI

   END
RETN.ADDR:   RETURN

END SET.ARTHOV


%SETALT (LAB:)
%%RS.ALT        ! RESTORE ALT STATE.

FIND ALT.NAME(".JBDDT",JOBDDT)

IF JOBDDT AND NOT DDTFLG THEN JOBAPR _ ^14 _ 0 ELSE [JOBAPR _ LAB; ^14 _ TRPBITS]
EXU(CLICD,14,OCT 16); SET.ARTHOV; RETURN

END SETALT


%L.OFFALT

IF L.ALTLEV=0 THEN OFFALT; INC L.ALTLEV; RETURN

END L.OFFALT


%L.ONALT

IF DEC L.ALTLEV=0 THEN ONALT; RETURN

END L.ONALT


%SETRWE (FN, LAB:)

RETURN RWELAB(FN) <== LAB

END SETRWE


%IOERR (FN, N)

IF (L.ALTLEV<==0)>0 THEN ONALT
ERRNUM _ N; GO ^RWELAB(FN)

END IOERR


%ABNERR(FN)
  MSG('$ABNORMAL ERROR ON FILE$')
  MOVE 4 FROM @MINFID(FN*4) TO @ARGCNT(FIDTBL)+1
  WFID(FIDTBL)
  MSG('$FILE STATUS WORD$')
  EXU(GTSCD,FN,@STS)
  REPEAT 12 DO
    STS_STS ROTL 3
    TTY_(STS BAND 7)+$0
  END
FINI:   NULL
        EXIT
        MSG("Can not continue")
        GO FINI
END ABNERR

END IOCS
  N@5F