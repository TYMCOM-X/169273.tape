;*****************************************************************
;****							      ****
;****			  S N A T C H			      ****
;****		       (Super Net Watch)		      ****
;****		       By Bruce B Thomson		      ****
;****		     Tymnet Eastern Region		      ****
;****		     24-April-1983 at 2247		      ****
;****							      ****
;*****************************************************************
;*								 *
;* Command Summary:						 *
;*								 *
;*	     `	      Default escape character ($)		 *
;*	    $C	      Change Escape character			 *
;*	    $E	      Exit to OS				 *
;*	    $L	      Change Probe Login string 		 *
;*	    $N	      Start Net watching function		 *
;*	    $R	      Restart (already logged in to probe)	 *
;*	    $S	      Save Core image (and all changes) 	 *
;*	    $$	      Send escape character to modem		 *
;*	    $	      Stop Snatch function, use Probe		 *
;*	    $	      Also used to terminate Login		 *
;*								 *
;*	When entering file name only:				 *
;*								 *
;*	    Rubout,^H, or ^A will Rub out last character	 *
;*	    ^Q or ^U will cancel the entire line		 *
;*								 *
;*****************************************************************

;*****************************************************************
;*  >>>>>>>>>>>>>>>>>>>>  W A R N I N G  <<<<<<<<<<<<<<<<<<<<<<  *
;*								 *
;* This program is the sole property of Tymnet Incorporated, and *
;* CONFIDENTIAL.  It may NOT be disclosed to any third party, it *
;* may NOT be copied or reproduced in whole or in part,  without *
;* WRITTEN permission from Tymnet Incorporated. 		 *
;*								 *
;*****************************************************************

;********************** Assembly Options *************************

Origin	Equ	100h	; Origin of program
Msoft	Equ	0	; Set if using Microsoft assembler (M80)
MPM	Equ	0	; Set if MPM, or OS using interupts 

;***************** Equipment Related Equates *********************

North	Equ	-1	; Set if using Northstar computer
Xerox	Equ	0	; If this is to run on a Xerox 820
Altos	Equ	0	; If this is to run on an Altos
Hpterm	Equ	-1	; If using an HP2621 terminal
Epson	Equ	0	; If Epson printer is used for log

;******************** Bells and Whistles *************************

Halarm	Equ	-1	; Set if want host alarm
Nalarm	Equ	-1	; Set if want node alarm
Lalarm	Equ	-1	; Set if want line alarm
Aalarm	Equ	-1	; Set if want accounting alarm
Acctbk	Equ	1000	; Number of acct blocks to set off alarm
Logalrm Equ	-1	; Set if want alarm to ring at login
Votrax	Equ	0	; Set to enable special votrax output
Allok	Equ	0	; Set if want all ok message from votrax
Okcnt	Equ	20	; number of scans between ok messages
Plog	Equ	0	; If printer is used for log

;********************* Other Parameters **************************

Escape	Equ	'H'-'@'	; Default escape character for cmds
Drive	Equ	'B'-'@' ; Drive for node and host files (A,B,C,D etc.)
Slowdsk Equ	-1	; Slow or noisy disk, uses more memory
Timer	Equ	0	; Set if want timer between scans
Time	Equ	10	; If timer, # of 15 sec. periods between scans
Trymax	Equ	5	; Number of times to try login before give up
Gonhst	Equ	0	; Set if want to report hosts only if gone
Maxnum	Equ	3777Q	; Max( Max host number, max node number )
Sernum	Equ	06969h	; Serial number for this copy

;****************** Some Ascii Characters ************************

Cr	Equ	0dh	; Carriage return
Lf	Equ	0ah	; Line feed
Feep	Equ	07h	; Character to send alarm

;**************** Check Consistancy of Equates ******************

   If (Altos and North) or (Altos and Xerox) or (North and Xerox)
	Warning, Only one of Xerox, Altos or North.
	Endif

	If (Xerox and Hpterm)
	Warning, Hpterm should not be specified with Xerox.
	Endif

	If (Allok and (not Votrax))
	Warning, Ok messages requested, no Votrax.
	Endif

	If (Plog and (not Epson))
	Warning, Plog specified with no printer support (Epson).
	Endif

	If (Epson and (not North))
	Warning, Epson supported only for Northstar computer.
	Endif

;*************** Device Dependant definitions ********************

	If Altos
Condata Equ	2eh	; Console data port
Constat Equ	2fh	; Console status port
Moddata Equ	1eh	; Modem data port
Modstat Equ	1fh	; Modem status port
Inbit	Equ	1	; Bit to test for character waiting
Outbit	Equ	4	; Bit to test for port ready
	Endif

	If North
Condata Equ	2	; Console data port
Constat Equ	3	; Console status port
Moddata Equ	4	; Modem data port
Modstat Equ	5	; Modem status port
Inbit	Equ	2	; Bit to test for character waiting
Outbit	Equ	1	; Bit to test for port ready
	Endif

	If Xerox
Moddata Equ	5	; Modem data port
Modstat Equ	7	; Modem status port
Inbit	Equ	1	; 
Outbit	Equ	4	;
	Endif

	If Votrax
Votdat	Equ	17	; Votrax Data port
Votsta	Equ	16	; Votrax status port
Votbit	Equ	'r'	; Bit pattern to test for output
	Endif

	If Epson
Pdat	Equ	0	; Epson Data port
Psta	Equ	0	; Epson Status port
Pbit	Equ	2	; Bit to test for ready
	Endif

;******************** Assembler controls etc. *******************

	If (not MPM)
System	Equ	5
	Endif

	If Msoft
	Aseg
	Endif

	Org Origin

;**********************  Initialization   ***********************

	Jmp Init		; Jump past this garbage
	Db 'opyright (C) Tymnet Inc. 1982',cr,lf
	Ldax d			; Which is just a scary message

Init:
	If MPM
	Di		; Disable interupts
	Endif
	Lxi Sp,Stack	; Set up stack pointer
	If (allok and votrax)
	xra a		; Zero
	sta allflg	; allflg
	sta not1st	; and not first one flag
	Endif
	Lda Reflag	; See if we are re-entering
	Ora A		; If so
	Jnz Start	; Skip initialization
	Mvi A,1 	; Else
	Sta Reflag	; Set flag to say we have been here
	Mvi A,Trymax	; Get number of login trys
	Sta Lgtry	; Store it
	Lhld 6		; Get CPM vector
	Lxi D,0-128	; And subtract 128 to give safe upper
	Shld Top	; Limit for buffers etc.
	Mvi a,127	; Set Disk buffer count to default
	Sta cnt 	; and start program

Start:
	Call Clear	; Clear the screen
	Call Initar	; Initialize Node and host bit arrays
	Call Print	; And print the following banner

	Db Cr,Lf
	Db		'*****************************',Cr,Lf
	Db		'*        S N A T C H        *',Cr,Lf
	Db		'*     (Super Net Watch)     *',Cr,Lf
	Db		'* Version  of  24-April-83  *',Cr,Lf
	Db		'*****************************',Cr,Lf
	Db Cr,Lf
	Db		'[Ready]'
	Db Cr,Lf,0

	If Votrax
	Lxi H,Ready	; If Votrax, say we are ready
	Call Votstr
	Endif

	If Plog
	Mvi a,'L'-'@'	; Send ^L to printer
	Call Pchar
	Endif

	If North	; Only works for north star computers
	Call Initm	; Initialize mother board
	Call Initpn	; Initialize ports to normal setup
	Endif		; So dont do it

;***********************   Main Program  ************************

Main:			; This is the control level of the program
	Call Gcistat	; Just checks port status
	Jnz Pcc 	; and dispatches to character processors
	Call Gmistat	; for Login, and use as a terminal
	Jnz Pmc 	; etc.
	Jmp Main	; Stay right around here

;*****************  Process Console Character  *******************

Pcc:
	Call Gcc	; Get a character from console
	Sta Cchar	; Save it in case we want it
	Ani 7fh 	; Strip parity
	Lxi H,Escch	; Point to escape character
	Cmp M		; was it one of those??
	Jz Pesc 	; If so, go do something
	Lda Cchar	; Else get back char before naked parity
	Call Smc	; Send it to the Modem
	Jmp Main	; And loop tightly

;*******************  Process Modem Character  *******************

Pmc:
	In Moddata	; Get a character from the modem
	Sta Mchar	; Save it case we need it
	Call Scc	; Send it to the console
	Jmp Main	; And loop tightly

;******************* Send Console Character **********************

Scc:
	If Xerox
	Push Psw	; Save the sucker
	Push D
	Push B
	Push H
	Call 0f00ch
	Pop H
	Pop B
	Pop D
	Pop Psw
	Ret
	Endif
	If (Not Xerox)
	Push Psw	; save char
Scc1:
	Call Gcostat	; Check port status
	jz scc1 	; loop if not ready
	pop psw 	; retrieve char
	out condata	; send it
	ret		; and return
	Endif

;********************* Send Modem Character **********************

Smc:
	Push H		; Save some
	Push Psw	; for good keeping
	Lxi H,0fffh	; set up for timed output
Smc1:
	Dcx H		; Tick by tick (slowly I turned)
	Mov a,l 	; We check the count
	ora h		; to see if its zero
	Jz Serr 	; If so we have a problem
	Call Gmostat	; Else we check the status
	Jz Smc1 	; and loop if not ready
	Pop Psw 	; If ready, we get the character
	Out Moddata	; And spit the sucker out
	Pop H		; And restore our registers
	Ret		; and return nicely
Serr:			; Else
	Call Gotoxy
	Db 63,0
	Call Ceol
	Call Print 
	Db '[Output err]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; And reset SP
	Jmp Main	; And abort to main loop (for now)

;*********************	Get Console Character ********************

Gcc:
	If (Xerox)
	Push H
	Push D
	Push B
	Call 0f009h
	Pop B
	Pop D
	Pop H
	Ret
	Endif
	If (not Xerox)
	Call Gcistat	; Is char waiting
	Jz Gcc		; No, loop
	In Condata	; Get it
	Ret		; and return
	Endif

;*********************** Get Modem Character *********************

Gmc:
	Call Gmistat	; Is character waiting
	Jz Gmc		; No, loop
	In Moddata	; Yes, grab it up
	Ret		; And return (how drol)

;******************* Timed get Modem Character *******************

;*	Timed Get modem char routine used for Snatch function.
;*	If it times out, something is wrong, so it attempts
;*	to log in again

Tgmc:
	Push H		; Save some registers
	Push B		; ditto
	Lxi H,0ffffh	; About one seconds worth
	Mvi C,12	; About 15 seconds
Tgmc1:
	Dcx H		; Tick by tick...
	Mov A,L 	; We see if
	Ora H		; zero yet?
	Jz Tgmc2	; and decrement second count if so
	In Modstat	; else check status
	Ani Inbit	; Character yet?
	Jz Tgmc1	; No, loop
	In Moddata	; Else grab the mother
	Ani 7fh 	; and strip off the silly parity bit
	Pop B		; restore registers
	Pop H		; ditto
	Ret		; and return for more abuse
Tgmc2:
	Dcr C		; One second less
	Jz Login	; timeout?, go log in
	Jmp Tgmc1	; else loop

;********************** Send Modem String  **********************

;*	This send string routine allows us to see echo when we
;*	are sending a string. That is unless echfg=1
;*	Enter string pointed to by HL, terminated by 0

Sms:
	Lda Echfg	; Check echo flag
	Ora a		; if zero, echo
	Jnz Sms1	; else skip it
	Call Gmistat	; get modem status
	Jz Sms1 	; character waiting?
	Call Gmc	; if so, get it
	Call Scc	; and echo it
Sms1:
	Mov A,M 	; Get a char from string
	Ora A		; End of string?
	Rz		; Return if so
Cipher:
	Db 0		; Space for 'RLC' instruction
	Call Smc	; Send modem character
	Inx H		; point to next char
	Jmp Sms 	; and play it again Sam

;********************** Send Console String **********************

;*	Send string to console pointed to by HL, Terminated
;*	by 0 byte.

Scs:
	Mov A,M 	; Get a character
	Ora A		; Is it 0
	Rz		; Yup, return
	Call Scc	; Else send it
	Inx H		; and point to the next one
	Jmp Scs 	; and do it again

;***************** Get Console String And Echo It ****************

Gcs:
	Lxi H,Conbuf	; Point to el'multipurposo buffero
	Mvi B,0 	; and zero our count
Gcs1:
	Call Gcc	; Get a character
	Ani 7fh 	; Strip parity (make it naked)
	Cpi 7fh 	; see if its rubout
	Jz Gsbs 	; erase last character if it was
	Cpi 'H'-'@'	; ^H does the same thing
	Jz Gsbs 	; ...
	Cpi 'A'-'@'	; And so does ^A
	Jnz Gcs2	; else it must be a real char
Gsbs:
	Inr B		; Set flags based on B
	Dcr B		; restore B
	Jz Gcs1 	; Start from scratch if b=0
	Dcx H		; else back up pointer
	Call Dbs	; and do back space
	Dcr B		; and reduce count
	Jmp Gcs1	; and wait for next
Gcs2:
	Cpi 'Q'-'@'	; ^Q
	Jz Gcs2a	; and
	Cpi 'U'-'@'	; ^U
	Jz Gcs2a	; cancel the line
	Jmp Gcs3	; else go
Gcs2a:
	Call Print 
	Db '^',Cr,Lf,0
	Jmp Gcs 	; Cancel line
Gcs3:
	Mov M,A 	; Put it in buffer
	Inr B		; increment count
	Inx H		; and pointer
	Cpi Cr		; see if what we got was Cr
	Rz		; done if it was
	Call Scc	; else Echo it too
	Jmp Gcs1	; and go back for more

;******************  Get Console Input Status  *******************

Gcistat:
	If (not Xerox)
	In Constat	; Just get the status
	Ani Inbit	; and set flag for In
	Ret		; and return...
	Endif
	If xerox
	Call 0f006h
	ora a
	ret
	Endif

;*******************  Get Modem Input Status  ********************

Gmistat:
	In Modstat	; Just get the status
	Ani Inbit	; and set flag for In
	Ret		; and return...

;*****************  Get Console Output Status  *******************

	If (Not Xerox)
Gcostat:
	In Constat	; Just get the status
	Ani Outbit	; and set the flag for out
	Ret		; duh, whad do ya think this does
	Endif

;*****************  Get Modem Output Status  *********************

Gmostat:
	In Modstat	; Just get the status
	Ani Outbit	; and set the flag for out
	Ret		; duh, whad do ya think this does

;****************** Process Escaped Command **********************

;*	Escape character recieved, get next char and see if
;*	its a command, if so, do it...

Pesc:
	call gcc	; Get a char
	Ani 7fh 	; strip it (Oh)
	Lxi H,Escch	; Point to Escape char default
	Cmp M		; is it that
	Jnz Pesc1	; Naw, see if its anything else
	Call Print 
	Db '[$]',Cr,Lf,0 ; this shows we sent escape
	Lxi H,Escch	; We get the char
	Mov A,M 	; (Like so)
	Call Smc	; and we send it
	Jmp Main	; and then resume our main looop
Pesc1:
	Ani 5fh 	; Make it upper case
	Cpi 'E' 	; Duh, is it a 'E'
	Jnz Pesc4	; Nope, I wunde wad it is?
	Call Print 
	Db '[Exit]',Cr,Lf,0 ; Yup, exit
	If MPM		; and if this is MPM
	Ei		; Enable interupts
	Endif		; so the OS can work
	Jmp 0		; And jump to tha abort loc
Pesc4:
	Cpi 'N' 	; Duh, is it a 'N'?
	Jnz Pesc5	; Nope, Gee what is it?
	Call Clear	; Clear the screen
	Jmp Login	; And go log in
Pesc5:
	Cpi 'R' 	; Is it a 'R'?
	Jnz Pesc6	; No, It must be sumtin else
	Call clear	; Yup, clear the screen
	Jmp snw ; and restart
Pesc6:
	Cpi 'C' 	; Is it an 'C'
	Jnz pesc7	; Naw, must be an ocean
	Call print 
	Db '[New Escape:',0 ; Ask fer new escape
	Call gcc	; Get it
	ani 7fh 	; strip it
	Sta escch	; Install it
	Call print 
	Db ']',cr,lf,0 ; and pack
	Jmp main	; it up
Pesc7:
	Cpi 'S' 	; Is it an ocean?
	Jnz pesc8	; No
	Call print 
	Db '[Save core]',cr,lf,0 ; Must be an 'S' ... Save
	Xra A		; First set re-entry flag off
	Sta Reflag	; set it
	Call Gfn	; get the file name to save it to
	Lxi H,Origin	; start at origin
	Lxi D,Bottom	; and save it all up
	Call Wbdsk	; Write buffer to disk file
	Mvi A,1 	; Restore re-enter flag
	Sta Reflag	; like this
	Jmp Main	; and jmp into the mainstreem
Pesc8:
	Cpi 'L' 	; Oops, it was a 'L'
	Jnz Pesc10	; or was it
	Call Print 
	Db '[Login: (end with $)]',cr,lf,0 ; yep, then..
	Lxi H,logmsg	; change the login string
	Mvi c,127	; no more than 127 chars
Pesc8a:
	Dcr C		; this counts for 1 char
	Jz berr 	; to many characters, throw up
	Call Gcc	; else get another
	Ani 7fh 	; and strip it
	Push H		; Save pointer
	Lxi H,escch	; Point to escape
	Cmp M		; Is this one
	Pop H		; restore pointer
	Jz pezz 	; done, tidy up
	Push Psw	; and save it
	Call Scc	; and show it (even echoes passwords)
	Pop psw 	; and get it back
	Rrc		; and encript it (a little)
	Mov m,a 	; and save it
	Inx h		; move the pointer
	Jmp Pesc8a	; loop
Pezz:
	Mvi m,0 	; and put a 0
	Call Print 
	Db cr,lf,'[ok]',cr,lf,0 ; Yes, done
	Jmp Main	; and get on back to where yu was
Berr:
	Call Print 
	Db '[Buffer barf]',cr,lf,feep,0
	Jmp Main	; No comment
Pesc10:
	If North	; If we have a northstar
	Cpi 'A' 	; we would now how to
	Jnz Pesc11	; drop our signals
	Call Print 
	Db '[Abort]',Cr,Lf,0 ; and abort
	Call Initm	; in style
	Call Nosig	; like this
	Jmp 0		; flop
	Endif
Pesc11:
	If North	; Ah, if only we where a Northstar
	Cpi 'D'
	Jnz Pesc12
	Call Print 
	Db '[Drop]    ',0
	Call Initm
	Call Nosig
	Call Delay
	Call Delay
	Call Delay
	Call Initm
	Call Initpn
	Call Crlf
	Jmp Main
	Endif
Pesc12: 		; Duh, yu typed a booboo
	Call Print 
	Db Feep,'[Huh?]',Cr,Lf,Feep,0
	Jmp Main	; go back and try again

;************************ Print String ***************************

Print:
	Pop H		; The return address is our pointer
Print1:
	Mov A,M 	; get a char
	Ora A		; is it 0
	Inx H		; point to next one in anticipation
	Jnz Print2	; for it not to be
	Pchl		; but it works out ok either way
Print2:
	Call Scc	; send it
	Jmp Print1	; and loop for the next one

;*********************** Compare Hl And De ***********************

Cphl:
	Mov A,H 	; sets flags
	Cmp D		; based on
	Rnz		; HL-DE
	Mov A,L
	Cmp E
	Ret

;******************** Send Cr Lf To Console **********************

Crlf:			; a convienient way to send CRLF
	Call Print 
	Db Cr,Lf,0
	Ret

;*********************** Send Bs,' ',Bs **************************

Dbs:			; Sends destructive backspace
	Push Psw
	Push H
	Call Print 
	Db 8,' ',8,0
	Pop H
	Pop Psw
	Ret

;*************** Read A Character From Disk File *****************

Rcd:
	Push H		; Save HL
	Lda Cnt 	; Get the count into the buffer
	Cpi 127 	; are we at the end
	Jnz Noread	; If not, we dont have to read sector
	Call Reads	; Read a sector
	Inr A		; FF=error, so incrementing would make it 0
	Jnz Rcd2	; If not zero, no error, continue, else..
	Call Print 
	Db '[Read Error]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; Abort pretty
	Jmp Main	; to main loop
Rcd2:	Cpi 2		; If it was a 1 then it is now 2
	Jnz Rcd3	; If its not 2, then not at end of file, else
	Call Print 
	Db '[Physical Eof]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; Abort pretty
	Jmp Main	; to main loop
Rcd3:
	Mvi A,0ffh	; since we just read, put -1 in cnt
	Sta Cnt 	; this gets incremented to 0
Noread:
	Lda Cnt 	; Get the count
	Inr A		; point to next loc in buffer
	Sta Cnt 	; Save it back
	Lxi H,80h	; Point to disk buffer address
	Mov C,A 	; Prepare to add count
	Mvi B,0 	; by putting it in BC
	Dad B		; Add it to buffer address
	Mov A,M 	; And get our character
	Pop H		; Restore HL
	Ret		; And return (woop dee doo)

;***************** Read A Sector From Disk File ******************

Reads:
	Lxi D,80h	; Point to default disk buffer
	Mvi C,26	; code to
	Call System	; set DMA address
	Lxi D,Fcoint to file control block
	Mvi C,20	; code to
	Call System	; read sector from disk
	Ret		; and return

;**************** Write Buffer Hl Thru De To Disk ****************

Wbdsk:
	Push D		; Save DE
	Push H		; and HL registers
	Lxi D,Fcb	; Point to our FCB
	Mvi C,15	; code to
	Call System	; open the file
	Inr A		; Prepare to
	Jz Wbdsk2	; check if error
	Call Print 
	Db '[Delete File? ',0
	Call Gcc	; file existed, ok to delete
	Push Psw	; save answer
	Call Scc	; echo it
	Call Print 
	Db ']',Cr,Lf,0
	Pop Psw 	; restore answer
	Ani 5fh 	; make upper case
	Cpi 'Y' 	; was it affirmative
	Jz Wbdsk1	; Yes continue
	Call Print 
	Db '[Aborted]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; Else abort clean
	Jmp Main	; to main loop
Wbdsk1:
	Lxi D,Fcb	; Point to file control block
	Mvi C,19	; code to
	Call System	; delete file
Wbdsk2:
	Lxi D,Fcb	; Point to fcb
	Mvi C,22	; code to 
	Call System	; Make file
	Pop H		; restore HL
	Pop D		; and DE
	Mvi A,0ffh	; Set up count
	Sta Cnt 	; for write operation
Wbdsk3:
	Mov A,M 	; get a char pointed to by HL
	Call Wcd	; Write it to disk
	Inx H		; point to the next one
	Call Cphl	; Done yet?
	Jnz Wbdsk3	; No, loop
	Call Writes	; Else write out last sector
	Lxi D,Fcb	; point to fcb
	Mvi C,16	; code to
	Call System	; close file
	Inr A		; see if it went ok
	Jnz Wbdsk4	; if so, jump, else print message
	Call Print 
	Db '[Cannot Close]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; and 
	Jmp Main	; abort
Wbdsk4: 
	Call Print 
	Db '[File Written]',Cr,Lf,Feep,0
	mvi a,127	; say write went ok, adjust cnt
	sta cnt 	; to default
	Ret		; and return

;******************* Write Character To Disk *********************

Wcd:
	Sta Ch1 	; store the character
	Push H		; save HL
	Push D		; and DE
	Lda Cnt 	; get count
	Cpi 127 	; are we done with this sector
	Jnz Nowrt	; no, dont write it to disk yet
	Call Writes	; else write it out
	Inr A		; and set up to see if ok
	Jnz Wcd2	; If ok, continue, else print error
	Call Print 
	Db '[Write Error]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; and
	Jmp Main	; abort
Wcd2:
	Mvi A,0ffh	; Adjust count to -1
	Sta Cnt 	; cause the first thing is to increment
Nowrt:
	Lda Cnt 	; get the count
	Inr A		; make it 1 bigger
	Sta Cnt 	; save it back
	Lxi H,80h	; point to our disk buffer
	Mov C,A 	; prepare BC
	Mvi B,0 	; to
	Dad B		; add it to pointer
	Lda Ch1 	; get our character back
	Mov M,A 	; put it in our buffer
	Pop D		; and restore DE
	Pop H		; And HL
	Ret		; Done

;********************* Write Sector To Disk **********************

Writes:
	Lxi D,80h	; Point to default DMA buffer
	Mvi C,26	; code to 
	Call System	; set DMA address
	Lxi D,Fcb	; Point to fcb
	Mvi C,21	; Code to
	Call System	; write sector
	Ret		; done


;*********************** Get File Name ***************************

Gfn:
	Call Print 
	Db Cr,Lf,'[Drive: ',0
	Call Gcc	; get drive spec
	Call Scc	; echo it
	Ani 5fh 	; make it upper case
	Sui 'A'-1	; make it a binary number
	Sta Fcb 	; and put it in our fcb
Gfnb:
	Call Print 
	Db '    Filename: ',0
	Call Gcs	; get console string
	Call Print 
	Db ']',Cr,Lf,0
	Lxi H,Fcb+1	; point to fcb
	Mvi C,11	; 11 characters in name
Gfn1:
	Mvi M,' '	; init to spaces
	Inx H		; point to next one
	Dcr C		; is it the last one
	Jnz Gfn1	; if not, loop
	Lxi H,Conbuf	; if so, point to string
	Lxi D,Fcb+1	; and our fcb
	Mvi C,9 	; 9-1 is 8
Gfn2:
	Call Gfn7	; Get a character from string
Gfn2a:
	Jz Gfn5 	; if it was CR, if so, finish up
	Cpi '.' 	; was it . ?
	Jz Gfn3 	; yes, go work on extent
	Stax D		; else store it in fcb
	Inx D		; point to next location
	Dcr C		; and see if too many
	Jnz Gfn2	; if not, get next one
	Jmp Gfn6	; else error has occured
Gfn3:
	Lxi D,Fcb+9	; point to extent
	Mvi C,4 	; 4-1 = 3 chars per extent
Gfn4:
	Call Gfn7	; Get a character
Gfn4a:
	Jz Gfn5 	; was it CR, if so finish
	Stax D		; else store it
	Inx D		; point to next
	Dcr C		; see if too many
	Jnz Gfn4	; no, get next
	Jmp Gfn6	; yes, error
Gfn5:
	Xra A		; zero
	Sta Fcb+12	; out some fcb
	Sta Fcb+32	; locations as needed
	Ret		; and go back
Gfn6:
	Call Print 
	Db '[Bad Filename]',Cr,Lf,Feep,0
	Lxi Sp,Stack	; we told em bout bad name
	Jmp Main	; exit
Gfn7:
	Mov A,M 	; get a character
	Inx H		; point to next one
	Cpi 61h 	; see if its lower case
	Jc Gfn8 	; go check for cr, else
	Sui 20h 	; make it upper case
Gfn8:
	Cpi Cr		; set zero if cr
	Ret		; you know...

;********************* Delay For .5 Seconds **********************

Delay:
	Lxi H,0ffffh	; About .5 seconds worth of ticks
Delay1:
	Dcx H		; count down
	mov a,h 	; to
	ora l		; zero
	Jnz Delay1	; loop
	Ret		; done

;******************  Inititialize Mother Board	******************

	If North
Initm:			; wish this was a north star
	Xra A
	Out 6
	Out 6
	Out 6
	Out 6
	Out 6
	Ret

;************** Set Up Usart To 'Normal' Config  ****************

Initpn:
	Mvi A,0ceh
	Out 3
	Out 5
	Mvi A,37h
	Out 3
	Out 5
	Ret

;******************** Turn Off Modem Signals *********************

Nosig:
	Mvi A,0ceh
	Out 3
	Out 5
	Mvi A,37h
	Out 3
	Xra A
	Out 5
	Ret

	Endif

;******** Find Next One Bit # Starting At Hl In Table De *********

;*	Enter Hl=Bit Number, De=Address Of Table
;*	Exit Hl=Bit Number

Next1:
	Call Chkbit	; Is this bit set
	Ora A		; set zero flag if not
	Rnz		; return if it is
	Inx H		; point to next bit
	Jmp Next1	; and keep checking

;********** Set Bit # Hl In A Table Pointed To By De *************

Setbit:
	Push H		; Save Bit Number
	Push D		; Save Table Address
	Call Fndbit	; Locate Bit
	Mov A,M 	; Get Byte Containing Bit
	Ora C		; Or In Bit To Set
	Mov M,A 	; Save It Back
	Pop D		; Restore Table Address
	Pop H		; Restore Bit Number
	Ret

;********* Check Bit # Hl In A Table Pointed To By De ************

;*	Return A=1 If Bit Is On
;*	       A=0 If Bit Is Off

Chkbit:
	Push H		; Save Bit Number
	Push D		; Save Table Address
	Call Fndbit	; Locate Bit
	Mov A,M 	; Get Byte Containing Bit
	Ana C		; Mask Off Bit
	Jz Chkbt1	; Return A=0 If Bit Off
	Mvi A,1 	; Else Return A=1
Chkbt1: Pop D		; Save Table Address
	Pop H		; Restore Bit Number
	Ret

;*** Return Byte Address And Mask For Bit # In Hl Of Table De ****

;*	Address Returned In Hl
;*	Mask In C

Fndbit:
	Mvi C,8 	; eight bits per byte
	Push D		; save table address
	Call Div	; Divide Hl By 8
	Inr C		; C is remainder. add one cuz we gona dec
	Pop D		; Get table address
	Dad D		; Add To Table Address
	Mvi A,80h	; Bit Mask For Zero

;*	Now A Contains 10000000, C Contains A Value 1-8
;*	We Decrement This Until Zero, Each Time Rotating
;*	The Mask To The Right

Fndbt1:
	Dcr C		; dec
	Jz Fndbt2	; Finished If Zero
	Rar		; Shift A Right
	Jmp Fndbt1	; Loop Till Done
Fndbt2:
	Mov C,A 	; Get Mask Into C
	Ret		; and return

;*********************** Divide Hl By C **************************

;*	16 Bits/8 Bits = 16 Bits, 8 Bit Remainder
;*	Enter With Hl=Dividend, C=Divisor
;*	Returns With Hl=Quotient, C=Remainder.

Div:
	Mov E,C 	; Swap Some Registers Around To 
	Mvi D,0 	; Keep Register Conventions, And
	Call Divit	; Keep 8 Bit Values, Call 16 Bit
	Mov A,L 	; Divide Routine Below.
	Lxi H,0 	; init H
	Dad B		; add to BC
	Mov C,A 	; put remainder in C
	Ret		; done

;********************** Divide Hl By De **************************

;*	16 Bits/16 Bits = 16 Bits, 16 Bit Remainder
;*	Enter With Hl Dividend, De Divisor
;*	Returns Bc=Quotient, Hl=Remainder

Divit:
	Push H		; Save dividend
	Mov L,H 	; Divide H By De
	Mvi H,0 	; set up HL
	Call Div1	; Divide high order byte
	Mov B,C 	; Save Result In B
	Mov A,L 	; (Remainder+L)/De
	Pop H		; Set up low orde byte
	Mov H,A 	; and continue
Div1:
	Mvi C,0ffh	; Init C
Div2:
	Inr C		; C Will Be The Result
	Mov A,L 	; (Hl=Hl-De)
	Sub E		; Divides By Subtracting
	Mov L,A 
	Mov A,H
	Sbb D
	Mov H,A
	Jnc Div2	; And Counting
	Dad D
	Ret

;****** Convert An Octal Number Pointed To By Hl To Binary *******

;*	Returns With Carry Set If Illegal Character Found.
;*	Conversion Stops When Character Less Than Zero Is Found.
;*	Binary Number Is Left In Hl, Maximum 77,777 Octal
;*	Least Significant 8 Bits Of Number In A.

Octin:	Lxi D,0 	; Zero De
	Xchg		; Address Pointer To De, Zero To Hl
Oloop:	Ldax D		; Get A Ascii Digit
	Sui '0' 	; Convert To Bcd And Test
	Ana A		; Reset Carry
	Rm		; Terminate Conversion If < Zero
	Cpi 8		; Check Legitimate Digit (0-7)
	Cmc		; Complement Carry
	Rc		; Return With Carry Set If Error
	Inx D		; Increment Address Pointer
	Dad H		; Shift Left 1
	Dad H		; Shift Left 2
	Dad H		; 3 Shifts For Eight
	Mov C,A 	; Move Prduct Into C
	Mvi B,0 	; Zero B
	Dad B		; Add It In
	Jmp Oloop	; Back For Another Digit

;****** Convert A Decimal Number Pointed To By Hl To Binary ******

;*	Returns With Carry Set If Illegal Character Found.
;*	Conversion Stops When Character Less Than Zero Is Found.
;*	Binary Number Is Left In Hl, Maximum 65,535 Decimal
;*	Least Significant 8 Bits Of Number In A.

Decin:	Lxi D,0 	; Zero De
	Xchg		; Addr Pointer To De, Zero To Hl
Dloop:	Ldax D		; Get A Ascii Digit
	Sui '0' 	; Convert To Bcd And Test
	Ana A		; Reset Carry
	Rm		; Terminate Conversion If < Zero
	Cpi 10		; Check for Legitimate Digit (0-9)
	Cmc		; Complement Carry
	Rc		; Ret With Carry Set If Error
	Inx D		; Incr Addr Pointer
	Dad H		; Shift Left 1
	Push H		; Save Result
	Dad H
	Dad H		; Shift Left 2
	Pop B		; No * 2 To B
	Dad B		; Hl Now Contains 10*No
	Mov C,A 	; Add Product To Digit
	Mvi B,0
	Dad B
	Jmp Dloop	; Back For Another Digit

;****  Convert An Integer To Octal And Output To The Console  ****

;*	Number In Hl
;*	Leading Zeros Supressed.
;*	Maximum Number 77,777.

	if 0

Octout: Push Psw	; Save Registers
	Push H
	Push D
	Push B
	Lxi B,0-8	; Radix For Conversion
	Lxi D,0-1	; This Becomes Number Divided By Radix
Octx:	Dad B		; Subtract 8
	Inx D
	Jc Octx
	Lxi B,8
	Dad B		; Add Radix Back In Once
	Xchg
	Mov A,H
	Ora L		; Test For Zero
	Cnz Octout	; Recursive Call
	Mov A,E
	Adi '0' 	; Convert From Bcd To Hex
	Mov E,A 	; To E For Output
	Call Scc	; Console Output
	Pop B
	Pop D
	Pop H
	Pop Psw
	Ret

	Endif

;********** Fill starting at DE for HL chars with zero ***********

Zero:
	Xra a		; make a=0
	Stax D		; store it at DE
	Inx D		; point next
	Dcx H		; reduce count
	Mov A,L 	; check if
	Ora H		; count is 0
	Rz		; and return if it is
	Jmp Zero	; else keep doin it

;********** Initialize Node and Host bit arrays to zero **********

Zerar:
	Mvi a,1
	Sta zerfg
Initar:
	Lxi H,Maxnum	; Number of elements in array
	Mvi C,8 	; Divided by 8 bits
	Call Div	; Compute number of bytes for array
	Inx H		; Add one for good measure
	Lxi D,Data	; Point at begining of table
	Call Zero	; Zero Them out
	Lda zerfg	; Get flag
	Ora a		; Is it zero
	Mvi a,0 	; Put a zero
	Sta zerfg	; in flag
	Rnz
	Xchg		; DE points to top of host array, Put in HL
	Inx H		; Add one for good measure
	If Slowdsk
	Shld Topar	; Store as top of array, topbit becomes
			; End of disk read area

	Lxi H,ndfcb	; Point to fcb for node file
	Call filfcb	; Mov it to fcb
	Mvi C,15	; open the file
	Lxi D,Fcb
	Call System
	inr a		; set zero flag if not found
	jnz ndffnd	; jump past if ok
	call print	; print error message
	db '[No NODE file]',0
	jmp 0		; exit
ndffnd:	Lhld Topar	; Point to where we are going

Iar1:
	Call Rcd	; Read a character from disk
	Ani 7fh 	; Strip parity
	Cpi 'Z'-'@'	; Is it Eof?
	Jz Iar2 	; if it is, we done wif node
	Mov m,a 	; else we sticks it in memory
	Inx H		; and increments the pointer
	Jmp Iar1	; and loops fer sum'ore
Iar2:
	Shld topnf	; Store location of top of node file
	Mvi a,127	; init cnt
	Sta Cnt 	; to default
	Lxi h,hstfcb	; Point to host fcb
	Call filfcb	; Mov it to fcb
	Mvi C,15	; code to
	Lxi D,Fcb	; open file
	Call System	; open it
	inr a		; set zero flag if no file
	jnz htffnd	; jump past if ok
	call print	; print error message
	db '[No HOST file]',0
	jmp 0		; exit
htffnd:	Lhld Topnf	; Point to top	of node file
	Inx H		; Plus 1
Iar3:
	Call Rcd	; Read a character from disk
	Ani 7fh 	; Strip parity
	Cpi 'Z'-'@'	; Is it Eof?
	Jz Iar4 	; if it is, we done wif node
	Mov m,a 	; else we sticks it in memory
	Inx H		; and increments the pointer
	Jmp Iar3	; and loops fer sum'ore
Iar4:
	Inx H		; Add 1
	Endif
	Shld Topbit	; And store top address of bit table
	If Slowdsk
	Mvi a,127	; And default
	Sta Cnt 	; the count
	Endif
	Ret		; Return

;*************** Fill bit array pointed to by DE ****************

;*	Enter DE points to bit array to fill, HL to Info
;*	Info is in the form #,cr,lf,#,cr,lf etc.
;*	Exit Bit array filled

Filar:
	Shld Ptr1	; save pointer to data
	Xchg		; get pointer to array
	Shld Ptr2	; save it
Filar1:
	Lxi H,Rdar	; Address of character from Info routine
	Call Rducr	; Call delimited read routine, # now in Conbuf
	Lxi H,Conbuf	; Point to where number went
Cludge:
	Call Octin	; Convert to binary in HL
	Rc		; Return if conversion error
	Mov A,H 	; Set up for compare
	Ora L		; To see if we are done
	Rz		; Return if so
	Xchg		; Put in De
	Lhld Ptr2	; Get bit array pointer
	Xchg		; Switch back for Setbit
	Call Setbit	; Set the bit for this #
	Jmp Filar1	; loop till done

;************* Read a character pointed to by Ptr1 **************

;*	Enter Ptr1 is pointer to Character
;*	Exit Ptr1 incremented, char in A

Rdar:
	Lhld Ptr1	; Get pointer to char
	Mov A,M 	; get it
	Inx H		; increment pointer
	Shld Ptr1	; and save it back
	Ret		; and go crazy

;************* Fill Fcb with fname pointed to by HL *************

FilFcb:
	Mvi C,33	; 33 locations
	Lxi D,Fcb	; point at it
	Mvi A,Drive	; get drive spec
	Stax D		; put it in fcb
	Inx D		; point to start of name
Fil1:
	Mov A,M 	; get a character
	Ora a		; is it 0
	Jz Fil21	; done?, continue
	Stax D		; no, save it
	Inx D		; point to next
	Inx H		; ditto
	Dcr C		; reduce count
	Jmp Fil1	; cont
Fil2:
	Inx D		; point to next
Fil21:
	xra A		; zero
	Stax d		; this one
	Dcr C		; done?
	Rz		; return if so
	Jmp Fil2	; else loop

;**** Read input stream from routine pointed to by HL till CR ****

;*	Enter HL=Address of routine to call to get char in A
;*	Exit Rdbuf=String delimited by CR,^Z, or Nul. Lf ignored
;*	String is terminated by zero. May not be>128 chars.

Rducr:
	Lxi D,Conbuf	; where we put it
	Mvi C,128	; maximum count
Rduc1:
	Push D		; save registers
	Push H
	Push B
	Call Chl	; call routine pointed to by HL
	Pop B		; restore registers
	Pop H
	Pop D
	Ani 7fh 	; strip parity
	Cpi Lf		; ignore lf
	Jz Rduc1
	Cpi Cr		; done if cr
	Jz Rduc2
	Cpi 'Z'-'@'	; or control z
	Jz Rduc2
	Ora A		; or if nul
	Jz Rduc2
	Stax D		; else save it in conbuf
	Inx D		; point to next one
	Dcr C		; reduce count
	Jz Rduc2	; done if count=0
	Jmp Rduc1	; loop for more
Rduc2:
	Xra A		; string is terminated with 0
	Stax D		; put it there
	Ret		; and go back

;***************** Call Routine pointed to by HL *****************

Chl:	Pchl		; a way to call a 
	Ret		; routine pointed to by HL

;************************* Watch Probe ***************************

snw:
	Mvi A,1 	; we dont want string output to echo
	Sta Echfg	; so turn it off
	Call scanning	; Print scanning probe message
snws:
	Lxi Sp,stack	; fix stack just to be safe
	call chkprb	; see if probe is ok
	If (Allok and votrax)
	Lda oksav	; get count for ok message
	dcr a		; decrement
	Sta oksav	; store it back
	cz sayok	; say ok if 0
	Endif
	Mvi H,42	; set up column
	Mvi L,3 	; and row address
	Mvi a,13	; and maximum rows to use
	Sta Maxrow+1	; set it
	Shld Posxy	; all up
	Lxi H,Gnode	; Point to AU message
	call Sms	; Send it to Probe
	Call Lfwait	; wait for a lf
	Lhld Topbit	; Point to Top of host buffer
	Inx H		; AU buffer is Just above this
snw1:
	Call chkq	; did he type a $
	Call tgmc	; Get a Char from Probe
	Cpi ':' 	; See if we are done yet
	Jz snw2 ; Done, Start processing Data
	Mov M,A 	; Put it in buffer
	Inx H		; Increment pointer
	Jmp snw1	; And loop for the next char
snw2:
	Xra A		; Zero A
	Mov M,A 	; Mark top of table with Zero
snw3:
	Lxi H,Octin	; Node numbers are octal
	Shld Cludge+1	; So tell Filar to use octal
	Lhld Topbit	; Point back to top of host buffer
	Inx H		; Au buffer is here
	Lxi D,Data	; Point at Node bit array
	Call Filar	; Fill array
snwz:
	If (not Slowdsk)
	Lxi H,ndfcb	; Point to fcb for node file
	Call filfcb	; Mov it to fcb
	Mvi C,15	; open the file
	Lxi D,Fcb
	Call System
	Endif
snw4:
	Call chkq	; did he type $
	Call reading	; print reading message
	Call Gotoxy 
	Db 42,3
	Call Print 
	Db '****  Nodes not reporting  ****',0
	If Nalarm
	Lda dnodes	; get number of down nodes
	Sta dnode1	; save for later
	Xra A		; Zero
	Sta dnodes	; number of down nodes
	Endif
	If Slowdsk
	Lhld Topar	; get pointer to top of bit array
	Shld ptr1	; store it in ptr1 for rdar
	Endif
snwj:
	If (not Slowdsk)
	Lxi H,Rcd	; Point to char in routine
	Endif
	If Slowdsk
	Lxi H,rdar
	Endif
	Call Rducr	; Call delimited read routine
	Lxi H,Conbuf	; # is in Conbuf
	Mov a,m 	; Get character
	cpi ':' 	; Is this a comment
	Jz snwj ; If so, get the next line
	Call Octin	; Convert to binary in HL
	Mov A,L 	; Set up for compare
	Ora H		; See if HL is zero
	Jz snw5 ; if so, do it again
	Lxi D,Data	; Point to bit array
	Call Chkbit	; Check if bit set
	Jnz snwj	; Node ok, loop
	Call nextxy	; next position to write to
	Jz tmany	; if > maxrow
	Call Ceol	; clear to end of line
	If Nalarm
	Lda dnodes	; Get number of down nodes
	Inr A		; add 1
	Sta dnodes	; Store it back
	Endif
	Lxi H,Conbuf	; Point to string
	Call Scs	; Send it to console
	Call Crlf	; Followed by Crlf
	Jmp snwj	; and loop for next one
Tmany:
	Call Ceol	; Clear to end of line
	Call Andmore	; print and more message
	Jmp prb5a	; and continue
snw5:
	Call clrmax	; clear all in this field
Prb5a:
	If (Votrax or plog)	
	xra a		; the node token is 0
	sta Token	; store token
	Endif
	If Nalarm
	Lda dnodes	; get number this time
	Lxi H,dnode1	; Point to number last time
	Cmp m		; compare
	cnz alarm	; sound alarm if different
	Endif
	Call chkq	; $?
	Call Scanning	; Print scanning probe message
	mvi a,127	; restore cnt
	sta cnt 	; to default
	Call zerar	; Zero bit array
Prob99: 		; Done scanning for Node, Scan for host
	call chkprb	; probe still ok?
	Lxi H,Ghost	; Point to Host message
	call Sms	; Send it to Probe
	Call Lfwait
	Lhld Topbit	; Point to Top of host buffer
	Inx H		; Host buffer is Just above this
Host1:
	Shld this1	; Save 1st Char ad
Host1a:
	Call Chkq
	Call tgmc	; Get a Char from Probe
	Cpi ':' 	; See if we are done yet
	Jz Host2	; Done, Start processing Data
	Cpi ' ' 	; Is it a Space
	Jz skp		; Skip to end (actually handle it)
	Mov M,A 	; Put it in buffer
	Inx H		; Increment pointer
	Jmp Host1a	; And loop for the next char
Skp:
	Mov M,a 	; Save space to delimit number
	Inx H
	Call tgmc	; Get condition code
	Mov M,a 	; Store Code
	Inx H	
	Mvi M,Cr	; Delimit with CR
	Inx H
	call lfwait	; wait for line feed
	Jmp Host1	; And do next one
Host2:			; Done, end of table
	Dcx H
	Mvi M,'0'	; put 00,cr here
	Inx H
	Mvi M,'0'
	Inx H
	Mvi M,Cr
	Inx H
	Mvi M,0
	Lxi H,Decin	; set up for decimal
	Shld Cludge+1	; conversion
	Lxi h,data	; set up
	Xchg		; for
	Lhld Topbit	; fill 
	Inx H		; array
	Call filar	; call
Hostz:
	If (not Slowdsk)
	Lxi H,Hstfcb	; Point to fcb for host file
	Call filfcb	; Mov it to fcb
	Mvi C,15	; code to
	Lxi D,Fcb	; open file
	Call System	; open it
	Endif
	Mvi H,3 	; column 
	Mvi L,3 	; and row
	Mvi a,23	; and max row
	Sta Maxrow+1	; set it
	Shld Posxy	; all up
	Call chkq	; and see if $ typed
	Call Reading	; Print 'reading' message
	Call gotoxy 
	Db 3,3
	Call Print
	If (not Gonhst)
	Db '****  Hosts  not answered  ****',0
	Endif
	If Gonhst
	Db '****  Hosts gone from net  ****',0
	Endif
	If Halarm
	Lda dhosts	; get number of hosts not answered
	Sta dhost1	; Store it back
	Xra A		; Zero 
	Sta dhosts	; number of hosts
	endif
	If Slowdsk
	Lhld topnf	; get top of node file
	Inx H		; add 1 to get bottom of host file
	Shld ptr1	; store it in ptr1 for rdar
	endif
Hostj:			; Now we print out gone hosts
	If (not Slowdsk)
	Lxi H,Rcd	; Point to char in routine
	Endif
	If Slowdsk
	Lxi H,rdar
	Endif
	Call Rducr	; Call delimited read routine
	Lxi H,Conbuf	; # is in Conbuf
	Mov a,m 	; Get the first char
	Cpi ':' 	; Is this a comment
	jz hostj	; skip it if it is
	Call Decin	; Convert to binary in HL
	Mov A,L 	; Set up for compare
	Ora H		; See if HL is zero
	Jz Host5	; if so, do it again
	Push H		; Save number
	Lxi H,data	; Point to
	Xchg		; With DE
	Pop H		; Restore host number
	Call Chkbit	; Check if bit set
	If (not Gonhst)
	Jnz Tsthst	; Host not gone, see if not answered
	Endif
	If Gonhst
	Jnz hostj
	Endif
	Call Clearp	; Position cursor and clear 35 spaces
	Jz Htmany	; Too many hosts out
	If Halarm
	Lda dhosts	; Get number of hosts
	Inr a		; add 1
	Sta dhosts	; Store it back
	Endif
	Lxi H,Conbuf	; Point to string (padded out with spaces)
	Call Scs	; Send it to console
	if (not Gonhst)
	Call Print 
	Db ' [Gone]',0
	Endif
	Jmp Hostj	; and loop for next one
			; We have checked for gone, now check for
Tsthst: 		; other conditions
	Lhld Topbit	; List of hosts
	Inx H
	Xchg		; In DE
Tsloop:
	Lxi h,Conbuf	; Number to find
Ts1:
	Ldax D		; Get byte
	Ora a		; Done?
	Jz Hostj	; return if so
	Cmp m		; is it the same
	Jnz NextTs	; Scan to next in list
	Mvi A,' '	; Set up to
	Cmp m		; see if we are done
	Jz fndts	; We have found it, go look at it
	Inx H		; Set up pointers to test next byte
	Inx D
	Jmp Ts1 	; and loop
NextTs:
	Ldax D		; get char
	Cpi Cr		; done?
	Inx D		; point to next
	Jnz Nextts	; no, loop wait
	Jmp Tsloop	; go again
Fndts:
	Xchg
	Inx H		; Hl now points to Code
	Mov a,m
	Cpi 'A' 	; A=Answered,
	Jz Hostj	; ignore
	sta temp	; save code
	If Halarm
	Lda dhosts	; get number of hosts
	Inr a		; ad 1
	Sta dhosts	; store it back
	Endif
	Call Clearp	; clear line
	Jz htmany	; unless too many rows
	Lxi h,Conbuf	; point to message
	Call Scs	; send it
	lda temp	; get code back
	Cpi 'D' 	; and print appropriatem message
	Jnz hnd
	Call Print 
	Db ' [Down]',0
	Jmp Hostj
Hnd:
	Cpi 'N' 	; No ports
	Jnz Hnoop
	Call Print 
	Db ' [Nopo]',0
	Jmp Hostj
Hnoop:
	Cpi 'S' 	; S is for shut
	Jnz Hns
	Call Print 
	Db ' [Shut]',0
	Jmp Hostj
Hns:			; not recignized
	Sta $+6 	; Put code in place of #
	Call Print 
	Db ' [#?!!]',0
	Jmp Hostj
Htmany:
	Call Andmore	; Print and more message
	Jmp Host5a
Host5:
	Call clrmax
Host5a:
	If (Votrax or plog)
	Mvi a,1 	; Host token is 1
	Sta Token	; store token
	Endif
	If Halarm
	Lda dhosts	; Get number of hosts not answered
	Lxi h,dhost1	; point to last number
	Cmp m		; compare
	Cnz alarm	; feep if different
	Endif
	mvi a,127	; fix cnt
	sta cnt 	; for disk buffer
	Call zerar	; zero bit array
	Call Scanning	; Print scanning message
	Call chkq	; $?
	Call chkprb
	Lxi H,Lsmsg	; Point to Host message
	call Sms	; Send it to Probe
	Call Lfwait
	Lhld Topbit	; Point to buffer
	Inx H
LLoop:
	Call tgmc	; get char
	Cpi ':' 	; check for :
	Jz Lsm		; if done, go set flag
	Mov M,a 	; else get char
	Inx H		; point to next
	Jmp LLoop
Lsm:
	Mvi M,'F'	; Done Flag
	Inx H
	Mvi M,cr	; Delimiter
	Call chkq
	Call Gotoxy 
	Db 42,15
	CAll Print 
	Db '****  Network  exceptions  ****',0
	If Lalarm
	Lda dlines	; get number of exceptions
	Sta dline1	; store it for future
	Xra a		; zero
	Sta dlines	; number of exceptions
	endif
	Lhld Topbit
	Inx h
	Shld Ptr1
	Mvi H,42	; **** to hell with comments *****
	Mvi L,15
	Shld posxy
	Mvi A,23
	Sta Maxrow+1
Lsm2:
	Lxi h,rdar
	Call Rducr
	Lxi h,Conbuf
	Mov a,m
	Cpi 'F'
	Jz Lsm3
	Call nextxy
	Jz Lsm4
	Call Ceol
	Lxi H,conbuf
	Call Scs
	If Lalarm
	Lda dlines
	Inr a
	Sta dlines
	Endif
	Jmp Lsm2
Lsm4:
	Call Ceol
	Call Andmore	; Print 'and more' message
	Jmp Lsm3a
Lsm3:
	Call clrmax
Lsm3a:
	If (Votrax or plog)
	Mvi a,2 	; Line token is 2
	Sta Token	; store token
	Endif
	If Lalarm
	Lda dlines	; get number of shut lines
	Lxi h,dline1	; point to old number
	Cmp m		; compare
	Cnz alarm	; feep if dif
	Endif
	Call chkq
	Call chkprb
	Lxi H,Cntmsg	; Point to Count message
	call Sms	; Send it to Probe
	Call Lfwait
	Call Lfwait
	Lxi h,conbuf
	Mvi c,80
Cnt1:
	Call Chkq
	Call tgmc
	Cpi cr
	Jz Cnt2
	Mov m,a
	Dcr c
	jz Cnt2
	Inx h
	Jmp Cnt1
Cnt2:
	mvi c,':'
	Call waitc
	Mvi m,0
	call gotoxy 
	db 0,0
	Call print 
	Db '   Stats: ',0
	Lxi h,conbuf
	call scs
	Call Chkq
stats:
	Call chkprb
	Lxi H,sysmsg
	Call sms
	call lfwait
	call filcon
	mvi c,':'
	call waitc
	call gotoxy 
	db 10,1
	Call print 
	db 'SUP ',0
	Lxi h,conbuf
	call scs
	call chkprb
	lxi h,timmsg
	call sms
	call lfwait
	call filcon
	mvi c,':'
	call waitc
	If Plog
	call savtim
	Endif
	call print 
	db ', TIME ',0
	Lxi h,conbuf
	call scs
	call print 
	db ', ',0
	call chkprb
	call chkq
	lxi h,actmsg
	call sms
	mvi c,' '
	call waitc
	call waitc
	call waitc
	call filcon
	mvi c,':'
	call waitc
	call print 
	db 'ACTG BLKS ',0
	call ceol
	lxi h,conbuf
	call scs
	If (Votrax or plog)
	Mvi a,3 		; Token for acct is 3
	Sta Token		; store in token
	Endif
	If Aalarm
	Lxi H,conbuf
	Call decin
	Lxi D,acctbk
	Call cphl
	Jnc acok
	Call alarm
	Call print 
	Db ' <= LOW!!',0
	Call alarm
Acok:
	Endif
	call chkq
	If timer
	Call sleep
	endif
	jmp snws

;***************** Say all is well with Votrax *******************

	If (Allok and votrax)
Sayok:	Lxi H,allokm
	call Votstr
	Mvi a,okcnt
	Sta oksav
	Lda allflg
	ora a
	rz
	lxi h,allnot
	call votstr
	ret
	Endif

;******************** Print 'Reading' message ********************

Reading:
	Call gotoxy 
	db 63,0
	Call Ceol	; clear to end of line
	If (not Slowdsk)
	Call Print 
	Db '[Reading Disk]',0
	Endif
	If Slowdsk
	Call Print 
	Db '[Memory scan]',0
	Endif
	Ret

;******************** Print 'Scanning' message *******************

Scanning:
	Call gotoxy 
	Db 63,0
	Call ceol	; clear line
	Call Print 
	Db '[Scanning Probe]',0
	Ret

;******************** Print 'And More' message *******************

Andmore:
	Call Print 
	Db '[And More ....]',0
	Ret

;******************** Scan memory until C found ******************

Scanc:
	mov a,m 	; get a character
	cmp c		; is it same as C
	inx h		; point to next
	rz		; return if it was
	jmp scanc	; else loop

;************************** Fill conbuf **************************

filcon:
	Lxi h,conbuf	; point to buffer
filc1:
	call tgmc	; get a character
	cpi cr		; was it cr
	jz filc2	; yes, finish
	mov m,a 	; no, put it here
	inx h		; and point to next
	jmp filc1	; and loop
filc2:
	mvi m,0 	; finish with 0
	ret		; and return

;********************* Wait for C from modem *********************

waitc:
	Call tgmc	; get a char from modem
	cmp c		; was it same as C
	rz		; yes, return
	jmp waitc	; else loop

;********************* Abort Snatch if $ typed *******************

Chkq:
	If (not Xerox)
	In Condata	; get what was typed
	Endif
	If (Xerox)
	Call 0f006h	; Was a char typed
	Ora A		; Zero if not
	Rz		; No, return
	Call 0f009h	; Else get the char
	Endif
	ani 7fh 	; strip parity
	Push h		; save hl
	Lxi h,escch	; point to escape char
	Cmp m		; was it one of those
	Pop h		; restor hl
	Rnz		; no, just return
	Mvi a,1bh	; else send escape to probe
	call smc	; this way char...
	Call clear	; clear screen
	Call Print 
	Db '[Probe]',cr,lf,0
	xra a		; turn on
	sta echfg	; echo for string output
	Lxi sp,stack	; and 
	Jmp main	; abort

;************* Clear line we are on for host routine *************

Clearp:
	Call nextxy	; go to next line
	Mvi C,34	; put 34 spaces here
	Call Spaces	; using spaces routine
	Lhld Posxy	; get xy address
	Dcr L		; we want to go back
	Shld Posxy	; so fake it out
	Call nextxy	; and do it again
	Ret		; done

;********************* Scan input till Lf ************************

Lfwait: Call tgmc	; Get a Char
	Cpi Lf		; Lf yet?
	Jnz lfwait	; Loop if not (We dont this message)
	ret

;**************** Check if probe is still Talking ****************

;*	If probe still here, return, else log back in
;*	also will log in if probe is sleeping

chkprb:
	Mvi a,cr	; send an escape
	Call smc	; to probe
	Lxi H,valid	; we expect this back
chkp1:
	xra a		; when we are done comparing Valid
	cmp m		; we will see a zero, so return
	rz		; no problem
	Call tgmc	; get a character
	cmp m		; is it what we expect
	jnz login	; if no, go log in
	inx h		; point to next
	jmp chkp1	; and loop

;************** Log in to probe, Try again if failure ************

Login:
	Lxi sp,stack	; In case we have to do this several times
	mvi a,1 	; we dont want string output to echo
	sta echfg	; so turn it off
	If (allok and votrax)
	sta oksav	; set oksav at same time
	xra a		; zero
	sta allflg	; flag that a change has happened
	Endif
	Call Gotoxy 
	Db 63,0
	Call Ceol	; clear the line
	Call chkq	; check for $
	lda Lgtry	; Get try count
	Dcr A		; decrement
	Sta Lgtry	; Store it back
	Ora A		; See if last try
	Jnz lg1		; continue if not
	Call Print
	Db '[Login Failed]',cr,lf,0
	Lxi Sp,stack	; abort
	Jmp Main	; Nicely
Lg1:	Call Print 
	Db '[Logging In]',0
	If (Votrax or Plog)
	Mvi a,4 	; Logging in token
	Sta Token	; store token
	Endif
	if Logalrm
	Call alarm	; set off the allarm
	endif
	Lxi H,Eximsg	; in case sup is sleeping
	Call Sms	; send this string
	call wait15	; wait 15 seconds
	call cib	; clear input
	mvi a,1bh	; escape
	call smc	; send it
	lxi h,pli	; point to cr,lf,'please log in'
	call chkp1	; did we get this?
	Lxi H,logmsg	; if so, point to log message
	Mvi a,7 	; code for RLC
	Sta Cipher	; used to cipher probe login
	Call sms	; send the string
	xra a		; and restore 
	Sta Cipher	; to normal
	call wait15	; wait 15 secs
	call cib	; clear input
	call chkprb	; double check
	Mvi A,Trymax	; Get maximum
	Sta Lgtry	; store
	Jmp snw 	; and jump to Snatch

;*********************** Clear input buffer **********************

cib:
	in moddata
	in moddata
	in moddata
	ret

;********************* Wait aprox 15 seconds *********************

Wait15:
	lxi h,0ffffh	; about 1 seconds worth
	Mvi c,12	; 15 seconds
wait1:
	dcx h		; count down
	mov a,h 	; to zero
	ora l		; (about 1 sec)
	jz wait2	; count down 1 second
	jmp wait1	; loop
wait2:
	Dcr c		; reduce seconds
	rz		; if done return
	jmp wait1	; else continue

;********* Sleep 'time' number of 15 second intervals ************

Sleep:
	Call gotoxy 
	db 63,0
	Call ceol
	Call print 
	db '[Waiting]',0
	Mvi B,time
Sleepy:
	Call wait15
	Dcr B
	Rz
	Push B
	Call chkprb
	Call Chkq
	Pop B
	Jmp sleepy

;***************** Ring terminal bell 255 times ******************

Alarm:
	Mvi c,255	; number of times to ring bell
Al2:
	Dcr c		; count down
	If (Not Votrax)
	rz		; done, return
	Endif
	If (Votrax and (not plog))
	Jz Valarm	; just say it
	Endif
	If (Votrax and plog)
	jnz al3
	call valarm	; say it on votrax
	jmp plogger	; and log it
	endif
	If (Plog and (not Votrax))
	Jz Plogger	; just log it
	endif
al3:	mvi a,feep	; else beep
	call scc	; the console
	jmp al2 	; and do it again

;************************ Votrax Alarm ***************************

	If Votrax

Valarm: Push H		; Save HL
	Lda Token	; Get token
	Ora A		; if zero, then node
	Lxi h,Vnode	; point to text
	jz Votel	; say it if change
	dcr a		; decrement
	Lxi h,Vhost	; point to text
	jz Votel	; say it if change
	dcr a		; dec
	Lxi h,Vline	; point to text
	jz Votel	; say it if change
	dcr a		; dec
	Lxi h,Vacct	; point
	jz Votel	; say it if change
	dcr a		; dec
	Lxi h,Vlog	; point to text
	jz Vota2	; Say it if so
	Pop H		; restore HL
	ret
Votel:
	If (allok and votrax)
	lda not1st	; See if this is the first time through
	ora a		; zero if so
	mvi a,1 	; set
	jz vota1	; jump past
	sta allflg	; flag to say change
vota1:	sta not1st	; set not first one flag
	endif

vota2:	Call Votstr	; send string to votrax
	pop h		; restore HL
	ret

;************** Send Votrax String pointed to by HL **************

Votstr: Mov a,m 	; get char
	ora a		; done?
	rz		; return if so
	call votchr	; send votrax char
	inx h		; point to next
	jmp votstr	; loop

;******************* Send Char in A to Votrax ********************

*	Routine times out if votrax not available
*	otherwise sends character in A to Votrax

Votchr: Push Psw	; Save Char
	Push H		; Save Hl
	Lxi H,0ffffh	; try this many times
Vota:	Dcx H		; Dec HL
	Mov a,l		; get ready to
	ora h		; see if zero
	jz voterr	; error if so
	In Votsta	; get status
	Cpi Votbit	; see if ready
	Jnz Vota	; loop if not
	Pop H		; restore HL
	Pop Psw 	; restore char
	out Votdat	; send it
	ret
Voterr:	call gotoxy	; position cursor
	db 63,0		; to normal place
	call ceol	; clear to end of line
	call print	; print error
	db '[Votrax Error]',0
	Pop H		; restore HL
	Pop Psw		; restore char
	Ret

	Endif

;******************** Send message to printer ********************

	If Plog

Plogger:
	Push H		; Save HL
	Lda Token	; Get token
	Ora A		; if zero, then node
	Lxi h,PPnode	; point to text
	jz Potel	; say it if change
	dcr a		; decrement
	Lxi h,PPhost	; point to text
	jz Potel	; say it if change
	dcr a		; dec
	Lxi h,PPline	; point to text
	jz Potel	; say it if change
	dcr a		; dec
	Lxi h,PPacct	; point
	jz Potel	; say it if change
	dcr a		; dec
	Lxi h,PPlog	; point to text
	jz Potel	; Say it if so
	Pop H		; restore HL
	ret
Potel:
	Push h		; Save pointer
	lxi h,tmbuf	; point to time
	call ptstr	; print it
	pop h		; restore pointer
	Call Ptstr	; send string to printer
	pop h		; restore HL
	ret

;************* Send Printer String pointed to by HL **************


Ptstr:	Mov a,m 	; get char
	ora a		; done?
	rz		; return if so
	call Pchar	; send printer char
	inx h		; point to next
	jmp Ptstr	; loop

;**************** Print character in A to printer ****************

*	Routine times out if printer not available
*	otherwise sends character in A to printer

Pchar:	Push Psw	; Save Char
	Push H		; Save Hl
	Lxi H,0ffffh	; try this many times
P1:	Dcx H		; Dec HL
	Mov a,l		; get ready to
	ora h		; see if zero
	jz pterr	; error if so
	in Psta		; get status
	ani 2		; see if ready
	jnz P1		; loop if not
	pop H		; restore hl
	Pop psw		; get char
	ori 80h		; set strobe bit
	out pdat	; send char and raise strobe
	xri 80h		; turn off strobe
	out pdat	; send it
	xri 80h		; toggle
	out pdat	; send it
	ret

pterr:	call gotoxy	; position cursor
	db 63,0		; to normal place
	call ceol	; clear to end of line
	call print	; print error
	db '[Printer Error]',0
	Pop H		; restore HL
	Pop Psw		; restore char
	Ret

;****************** Save time in Tmbuf for logger ****************

Savtim:	Lxi h,Conbuf
	Lxi d,Tmbuf
Savt1:	Mov a,m
	stax d
	ora a
	rz
	inx h
	inx d
	jmp savt1

	Endif
	
;***************** Clear to maxrow with 34 spaces ****************

Clrmax:
	Call Nextxy	; write 34 spaces
	Mvi c,34	; rows
	Jz spaces	; let space routine return if done
	Call spaces	; else come back
	Jmp Clrmax	; and do it again

;******************** Go to next XY position *********************

Nextxy:
	Lhld Posxy	; get cursor position
	Inr L		; increment row
	Mov a,L 	; get row in a
	Shld Posxy	; and store it back
	Push Psw	; save row
	Call Xy 	; go to row, column
	Pop Psw 	; get row back
Maxrow: Cpi 0		; see if this is the max row number
	ret		; and return

;***************** Address Crt cursor to Db X,Y ******************

;*	This routine for convieniant inline cursor positioning
;*	Entry Call Gotoxy 
;*	      Db XX,YY
;*	Exit Cursor Positioned to XY coordinates

Gotoxy:
	Pop H
	Mov D,M
	Inx H
	Mov E,M
	Inx H
	Push H
	Xchg
	Call XY
	Pop H
	Pchl

;****************** Serial number goes here **********************

	Dw Sernum

;********************** Gotoxy H=Y L=X ***************************

;*	 Enter H=Row address (Y) L=Column Address (X)
;*	Exit cursor addressed

xy:
	If Hpterm
	Mov E,H
	Mov B,L
	Lxi H,St444+5
	Call Cnvxy
	Mov B,E
	Lxi H,St444+2
	Call Cnvxy
	Lxi H,St444+9
	Mvi D,10
XyLoop: Dcx H
	Dcr D
	Rz
	Mov A,M
	Call Scc
	Jmp Xyloop

Cnvxy:	Mvi M,'0'
	Dcx H
	Mvi M,'0'
	Mov A,B
	Cpi 0
	Rz

Cloop:	Mov A,M
	Cpi '9'
	Jnz Ones
	Mvi M,'0'-1
	Inx H
	Inr M
	Dcx H
Ones:	Inr M
	Dcr B
	Rz
	Jmp Cloop
	Endif
	If Xerox
	Mvi a,1bh
	Call scc
	Mvi a,'='
	Call scc
	Mov a,l
	adi 32
	call scc
	Mov a,h
	adi 32
	call scc
	ret
	Endif

;************** Clear Crt Screen and home cursor *****************

Clear:
	If Hpterm
	Call Print 
	Db 27,'H',27,'J',0
	Ret
	Endif
	If Xerox
	Mvi a,1ah
	call scc
	ret
	Endif

;***************** Clear to end of line, Crt *********************

Ceol:
	If Hpterm
	Call Print 
	Db 27,'K',0
	Ret
	Endif
	If Xerox
	Mvi a,18h
	call scc
	ret
	Endif

;******************** Send C spaces to Crt ***********************

Spaces:
	Mvi A,' '	; set up to
	Call Scc	; send a space
	Dcr C		; decrement count
	Jnz Spaces	; loop till done
	Ret		; return

;*************** Make system call, fix interupts *****************

	If MPM
System:
	Ei		; enable interupts for system
	Call 5		; call the system
	Di		; disable iterupts again
	Ret		; return

	Endif

;*************************  Data Area  ***************************

Fcb:	Ds	66		; Programs File control block area
Ndfcb:	Db	'NODE       ',0 ; Fcbs for files
Hstfcb: Db	'HOST       ',0 ;
Gnode:	Db	'AU',Cr,0	; Messages to send to probe
Ghost:	Db	'HOST',Cr,0	;
Eximsg: Db	'A',1bh,'EXI',Cr,0
Lsmsg:	Db	'EXC',Cr,0	; Use exceptions instead of lshut
Cntmsg: Db	'COUNT',Cr,0	;
sysmsg: Db	'SYS',cr,0	;
timmsg: Db	'TIME',Cr,0	;
Actmsg: Db	'ACCT',Cr,0	;
St444:	Db	'C00r00a&',1bh	;string to send to hp 2621
Valid:	Db	cr,lf,'?',cr,lf,':',0	; Match for probe responce
Pli:	Db	cr,lf,'please log in:',0
Logmsg: Ds	127		; Space for loggin string
Cnt:	Db	127		; Buffer count for disk i/o
Ch1:	Db	0		; Used for disk i/o
Temp:	Db	0		; Temporary byte storage
Lgtry:	Db	0		; Number of login attempts
Escch:	Db	Escape		; Escape character for commands
Reflag: Db	0		; Flag=1 says re-entering code
Zerfg:	Db	0		; Flag if no disk read by INITAR
Echfg:	Db	0		; Echo durring Smc = 0, no echo=1
	If	(Votrax or plog)
Token: Db	0fh		; token for votrax and printer log
	Endif
This1:	Dw	$-$		; Addresses
Endhst: Dw	$-$		;
Posxy:	Dw	$-$		;
Ptr1:	Dw	$-$		;
Ptr2:	Dw	$-$		;
Top:	Dw	$-$		;
Topbit: Dw	$-$		; Top of bit array unless
	if Slowdsk
Topar:	Dw	$-$		; Top of bit array
Topnf:	Dw	$-$		; Top of node file
	Endif
Mchar:	Db	0		; Last character from modem
Cchar:	Db	0		; Last character from console
	If Nalarm
Dnodes: Db	0		; Number of down nodes
Dnode1: Db	0		; old number of down nodes
	Endif
	If (Votrax and Nalarm)
Vnode:	Db	'Change in node',cr,0
	Endif
	If Plog
Tmbuf:	Db	'000:00:00:00',0	; Timestamp buffer for plog
PPnode:	Db	' Change in node',cr,lf,0
	Endif
	If (Votrax and (not Nalarm))
Vnode:	Db	0
	Endif
	If Halarm
Dhosts: Db	0		; Number of down hosts
Dhost1: Db	0		; old number of down hosts
	Endif
	If (Votrax and Halarm)
Vhost:	Db	'Change in Host',cr,0
	Endif
	If Plog
PPhost:	Db	' Change in host',cr,lf,0
	Endif
	If (Votrax and (Not Halarm))
Vhost:	Db	0
	Endif
	If Lalarm
Dlines: Db	0		; Number of shut lines
Dline1: Db	0		; old number of shut lines
	Endif
	If (Votrax and Lalarm)
Vline:	Db	'Change in exeptshuns',cr,0
	Endif
	If Plog
PPline:	Db	' Change in exceptions',cr,lf,0
	Endif
	If (Votrax and (Not Lalarm))
Vline:	Db	0
	Endif
	If (Votrax and Logalrm)
Vlog:	Db	'Logging in to probe',cr,0
	Endif
	If Plog
PPlog:	Db	' Probe Login',cr,lf,0
	Endif
	If (Votrax and (Not Logalrm))
Vlog:	Db	0
	Endif
	If (Votrax and Aalarm)
Vacct:	Db	'Low Akounting bloks',cr,0
	Endif
	If Plog
PPacct:	Db	' Accounting blocks low',cr,0
	Endif
	If (Votrax and (Not Aalarm))
Vacct:	Db	0
	Endif
	If Votrax
Ready:	Db	'Ready',cr,0
	Endif
	If (Votrax and Allok)
Allokm: Db	'all is well',cr,0
Allnot: Db	'  but b awair of change es',cr,0
Allflg: Db	0
Oksav:	Db	0
not1st: Db	0		; not first scan report flag
	Endif
Bottom	Equ	$		; Last core address to save
Conbuf: Ds	128		; Multipurpose buffers
	Ds	80		; Stack
Stack	Equ	$		; From here to (top), buffer space
Data	Equ	$

	End

;*****************************************************************
; - Eof -
   A@!