	TITLE	TYMSCN	Routine to read a user file specification
	SUBTTL	BY	CARL A. BALTRUNAS	1977


	SEARCH	CARL,MACTEN,JOBDAT,UUOSYM

	SALL

	IFNDEF	TYMCOM,<TYMCOM==-1>	;DEFAULT TO TYMCOM VERSION

	EXTERN	TYPINC,TYPOUC	;ROUTINES TO SET TTY INPUT & OUTPUT ROUTINES
	EXTERN	TYPCLN		;ROUTINE TO CLEAN OUT AFTER A COMMENT CHAR
	EXTERN	CHKCHR		;CHECK ON CHARACTER
	EXTERN	TRIMT3		;ROUTINE TO TRIM T3 TO THE SIZE OF T2
	EXTERN	MSGOUT		;ROUTINE TO OUTPUT A MESSAGE
	EXTERN	OUTOCT,OUTDEC	;ROUTINE TO OUTPUT T1 IN OCTAL, DECIMAL
	EXTERN	OUTNUM		;ROUTINE TO OUTPUT T1 IN RADIX(T3)
	EXTERN	OUTSIX		;ROUTINE TO OUTPUT T1 AS SIXBIT NON-PADDED
	EXTERN	PPNOUT		;OUTPUT A PPN.
	EXTERN	SWDEC		;ROUTINE TO INPUT A NUMBER INTO N (uses C,N)
	EXTERN	GETWRD,OCTWRD	;ROUTINES TO INPUT A SIXBIT WORD,OCTAL WORD
	EXTERN	GETNAM		;ROUTINE TO INPUT 2 SIXBIT WORDS a la GETWRD

	ENTRY	SCANER		;ROUTINE TO READ A FILE SPECIFICATION
	ENTRY	SCN$LK		;ROUTINE TO RETURN FILE SPEC BLOCKS
	ENTRY	SCN$SW		;ROUTINE TO FLAG SWITCHES, RESET EACH
				;  CALL TO SCANER.

;FLAGS FOR FILSPEC DECODER

	F$OPEN==777777000000	;HIGH ORDER BITS SAY OPEN THINGS

	F$OEXT==1B0		; . TYPED
	F$OANG==1B1		; < TYPED
	F$OPPN==1B2		; [ TYPED
	F$OPPR==1B3		; ( TYPED

	F$DEV== 1B18		; DEVICE ACCEPTED
	F$FILE==1B19		; FILE ACCEPTED
	F$EXT== 1B20		; EXT  ACCEPTED
	F$PROT==1B21		; PROTECTION ACCEPTED
	F$PPN== 1B22		; PPN ACCEPTED
	F$USER==1B23		; USER-NAME ACCEPTED

	F$MORE==1B35		; MORE TO COME

;OFFSETS FOR SCANNER MASK BLOCK

	MS$DEV==0		;TOP OF BLOCK
	MS$NAM==1		;SECOND
	MS$EXT==2		;THIRD
	MS$PPN==3		;LAST

;FLAGS FOR SWITCH SCANNER	(LH FLAGS)

	SW$GLB==1B18		; GLOBAL -- PRESET FIRST TIME ONLY
	SW$FIL==1B19		; PER-FILE  PRESET EACH CALL
	SW$UNQ==1B20		; SWITCH IS UNIQUE ON 1 CHAR
	SW$ARG==1B21		; ARGUMENT ACCEPTED	
	SW$NUM==1B22		; NUMERIC ARGUMENT
	SW$SIX==1B23		; SIXBIT ARGUMENT
	SW$ASC==1B24		; ASCII ARGUMENT


IFN TYMCOM,<
	.PTFCN==0		; FUNCTION NAME
	.PTSWT==1		; SWITCH FLAGS
	.PTPPN==2		; PPN FIELD
	.PTSFD==3		; BEGINNING OF SFD FIELD
	.PTMAX==11		; END OF PATH. BLOCK == ALWAYS 0
>

Define ERR(CODE)<
ERR'CODE:MOVEM	T1,STASAV	;; Save the status of the line
	MOVEI	T1,E$M'CODE	;; Setup for typeout
IFB <MSG>,<JRST ERRORS>		;; Finish up if nothing else
>
	SUBTTL	File Specification (read) routine

SCANER:	PUSH	P,F			;SAVE THE FLAGS FROM PROGRAM
	SETZ	F,			;CLEAR THE FLAG WORD
	STORE	T2,FCORE,EFCORE-1,0	;ZERO FILE SPEC BLOCKS
	SETOM	PATH			;TELL THAT YOU WANT PATH
ife tymcom,<
	MOVE	T2,[.PTMAX,,PATH]	;GET PATH BLOCK
	PATH.	T2,			;AND AWAY WE GO!
	  JFCL				;IF ERROR RETURN -- IGNORE
>
ifn tymcom,<
	GETPPN	T2,			;USE MY PPN
	  JFCL				;JACCT KLUDGE
	MOVEM	T2,PATH+.PTPPN		;STORE AS IF PATH. WORKED
>
	SETOM	MASK+MS$NAM		;SET FILE MASK TO *
	SETOM	MASK+MS$EXT		;   AND EXTENSION MASK TO *
	SKIPE	SWITCH			;SKIP IF SWITCHES NOT ALLOWED
	  PUSHJ	P,SCN.SW		;   ELSE CLEAR FILE SWITCHES
	setzb	t2,t3			;Insure that this is blank
	skipn	t1			;Don't call anything if non-zero
SCAN00:	CALL	GETWRD			;GET THE NEXT/FIRST PARCEL
	CAIN	T1,':'			;WAS IT FOLLOWED BY A COLON?
	  JRST	SCAN10			;YES--SO CHECK UP ON DEVICE
	CAIN	T1,'.'			;SEE IF IT WAS A FILE-TERMINATOR
	  JRST	SCAN20			;YES--SO SEE IF WE HAVE A FILE
	CAIN	T1,'<'			;MAYBE A FILE-PROTECTION?
	  JRST	SCAN30			;YES--SO LET'S GET THE PROTECTION
	CAIN	T1,'['			;AND MAYBE WE HAVE A PATH?
	  JRST	SCAN40			;YES--LET'S GET IT
	CAIN	T1,' '			;A SPACE SEPARATOR?
	  JRST	SCAN50			;YES--CLEAN UP ANY FILE.EXT STUFF
IFN TYMCOM,<
	CAIN	T1,'('			;A NAME FIELD?
	  JRST	SCAN60			;YES--FILL OUT THE NAME PART
>
	CAIN	T1,'/'			;HMMM. IS IT A SWITCH COMING UP???
	  JRST	SCAN70			;YES--SEE IF SWITCHING IS ENABLED
	CAIN	T1,','			;LAST OF ALL IS IT A FILE-SPEC SEPARATOR?
	  JRST	SCN600			;YES--SETUP HOLDING PATTERN & GO BYE-BYE
	caie	t1,'!'			;At this point, if we find a
	cain	t1,';'			;  comment character, we will
scancl:	  pushj	p,typcln		;  clean out the line.
	JUMPL	T1,SCN700		;IF WE'RE NOT AT EOL--WE HAVE AN ERROR
	PJRST	ERRICF			;ILLEGAL CHARACTER IN FILE SPECIFICATION

	SUBTTL	Sub Specification tests & Parsing routines

SCAN10:	TXNE	F,F$OPEN		;SEE IF ANYTHING IS OPEN EG. EXT OR PPN
	  PJRST	ERRICF			;ILLEGAL CHARACTER IN OPEN FIELD
	MOVEI	T4,[ASCIZ\Device name\]	;DEVICE ERROR
	TXNE	F,F$DEV			;DO WE ALREADY HAVE A DEVICE?
	  PJRST	ERRDUP			;DUPLICATE DEVICE NAME
	JUMPN	T3,ERRWLD		;WILD CARDED DEVICE ERROR
	JUMPE	T2,ERRNUL		;NULL DEVICE NAME
	MOVEM	T2,LOOK+.RBDEV		;SET DEVICE NAME
	TXO	F,F$DEV			;LET THEM KNOW WE HAVE ONE
	JRST	SCAN00			;RETURN TO SCANNER


SCAN20:	TXNE	F,F$OPEN		;SEE IF ANYTHING IS OPEN?
	  PJRST	ERRICF			;ILLEGAL CHARACTER
	MOVEI	T4,[ASCIZ\Extension\]	;EXTENSION ERROR
	TXNE	F,F$EXT			;DO WE ALREADY HAVE AN EXTENSION?
	  PJRST	ERRDU0			;YES--SO LET THEM KNOW ABOUT IT
	JUMPE	T2,SCAN22		;YES--BUT HE DIDN'T TYPE ANOTHER ANYWAY
	TXNN	F,F$FILE		;DO WE ALREADY HAVE A FILE?
	  JRST	SCAN21			;NO--GO LOOK AT THIS ONE
	MOVEI	T4,[ASCIZ\File name\]	;FILE-NAME ERROR
	PJRST	ERRDUP			;DUPLICATE!!!
SCAN21:	MOVEM	T2,LOOK+.RBNAM		;SETUP THE NAME
	MOVEM	T3,MASK+MS$NAM		;AND THE MASK THAT GOES WITH IT
	SKIPE	T2			;AND IF THERE WASN'T ANY, THEN DON'T SET IT
	TXO	F,F$FILE		;SET THE FILE EXIST FLAG
SCAN22:	TXO	F,F$OEXT		;OPEN--EXTENSION WORD
	JRST	SCAN00			;AND RETURN TO MAIN LOOP


SCAN30:	PUSHJ	P,SCN400		;SCAN-CHECK FOR FILE.EXT PART
	  PJRST	ERRDUP			;RETURN HERE ALL-DONE ONE WAY OR OTHER
	TXO	F,F$OANG		;OPEN ANGLE BRACKET
	PUSHJ	P,OCTWRD		;GET AN OCTAL PROTECTION
	CAIE	T1,'>'			;BETTER BE CLOSED OFF HERE
	  PJRST	ERRIPS			;ILLEGAL PROTECTION SPECIFICATION
	TXZ	F,F$OANG		;CLEAR THIS PART
	TXO	F,F$PROT		;AND TELL THEM WE GOT A PROTECTION
	JUMPN	T3,ERRIPS		;ILLEGAL WILD? PROTECTION
	CAILE	T2,777			;MAKE SURE LESS THAN HIGH
	  PJRST	ERRIPS			;ILLEGAL (TOO BIG) PROTECTION
	MOVEM	T2,LOOK+.RBPRV		;SET PROTECTION
	JRST	SCAN00			;AND RETURN TO MAIN LOOP
	SUBTTL	MORE Tests & Parsing routines

SCAN40:	MOVEI	T4,[ASCIZ\User name or a PPN\]	; Name error
	TXNE	F,F$PPN!F$USER		;DO WE ALREADY HAVE A PPN?
	  PJRST	ERRDUP			;DUPLICATE SOMETHINGS
	PUSHJ	P,SCN400		;CHECK OUT THE FILE.EXT SCENE
	  PJRST	ERRDUP			;DUPLICATION ERROR (FILE OR EXT)
	TXO	F,F$OPPN		;OPEN IN PPN
	CALL	OCTWRD			;GET NEXT PARCEL	(PROJECT #)?
	CAIE	T1,'-'			;DASH IS A SPECIAL CASE [-] PATH
	  JRST	SCAN41			;THE REST IS LOOKED AFTER HERE
	JUMPN	T2,ERRICP		;IF NON-ZERO THERE IS AN ERROR HERE
	CALL	OCTWRD			;GET THE REST (SHOULD ALSO BE 0)
	JUMPN	T2,ERRICP		;  ELSE GIVE ERROR
	JUMPL	T1,SCAN47		;THIS IS OK--SO GO
	CAIN	T1,']'			;THEN IT MUST BE FOLLOWED BY A CLOSE BRACKET
	PJRST	SCAN47			;  CLOSE BRACKET? OK!
	PJRST	ERRICP			;ELSE AN ILLEGAL CHARACTER

SCAN41:	CAIE	T1,','			;MUST HAVE AT LEAST A COMMA HERE!
	  JRST	ERRCRP			;ERROR IN PPN (COMMA REQUIRED IN PPN)
	SKIPN	T2			;IF NONE-TYPED USE PATH
	  HLRZ	T2,PATH+.PTPPN		;READ PROJECT FROM PATH
	HRLM	T2,PATH+.PTPPN		;SET PROJECT
	HRLM	T3,MASK+MS$PPN		;  AND IT'S ASSOCIATED MASK
	HRLM	T3,PMASK+.PTPPN		; ....
	CALL	OCTWRD			;READ PROGRAMMER NUMBER
	JUMPL	T1,SCAN42		;  DONE & GOT END OF LINE
	CAIE	T1,','			;LOOKING FOR A COMMA
	CAIN	T1,']'			;OR A CLOSE BRACKET
	CAIA				;OK, FOUND ONE
	  JRST	ERRICP			;ILLEGAL CHARACTER IN PPN
SCAN42:	SKIPN	T2			;USE PPN (PROJECT) FROM PATH
	  HRRZ	T2,PATH+.PTPPN		;IF NONE TYPED

	HRRM	T2,PATH+.PTPPN		;PUT PROGRAMMER AWAY
	HRRM	T3,MASK+MS$PPN		;  ALONG WITH THE ASSOCIATED MASK
	HRRM	T3,PMASK+.PTPPN		; ....
	JUMPL	T1,SCAN45		;FINISH UP IF AT EOL...
	CAIN	T1,']'			;OFFICIAL! (CLOSING BRACKET)
	  JRST	SCAN45			;YES, SO DONE WITH LINE (MAYBEE?)
	CAIE	T1,','			;THEN,--ONLY A COMMA IS LEGAL BREAK
	  JRST	ERRICP			;ILLEGAL CHARACTER IN PPN SPEC
	SUBTTL	SFD Support section -- Fall through from above

	SETZ	T4,			;SET SFD LEVEL
SCAN43:	CALL	GETWRD			;GET THE NEXT ITEM IN THE LIST
	JUMPL	T1,SCAN44		;IF FINISHED, STOP SEARCHING FOR BREAK
	CAIE	T1,','			;SEARCH FOR A COMMA
	CAIN	T1,']'			;  OR A ']' THEN WE'RE DONE
	CAIA				;OK, SO PUT THIS ONE AWAY
	  JRST	ERRICP			;ILLEGAL CHARACTER IN PPN
SCAN44:	SKIPN	T2			;CHECK FOR TYPED OR (PATH)
	  MOVE	T2,PATH+.PTSFD(T4)	;GET DEFAULT (IF ANY)
	SKIPN	T2			;MAKE SURE THE SFD WAS TYPED
	  JRST	ERRNSS			;NULL SFD SPECIFICATION
	MOVEM	T2,PATH+.PTSFD(T4)	;SET SFDNAME IN LIST
	MOVEM	T3,PMASK+.PTSFD(T4)	;  AND MASK ALSO
	CAIN	T1,']'			;SEE IF END OF LINE
	  JRST	SCAN46			;END OF PPN SPEC
	JUMPL	T1,SCAN46		;END OF LINE REACHED?
	CAIGE	T4,4			;NO MORE THAN 5 ALLOWED
	AOJA	T4,SCAN43		;LOOP.
	  JRST	ERRSND			;SFD'S NESTED TOO DEEPLY
SCAN45:	SETO	T4,			;NONE-TYPED -- CLEAR ALL SFD'S
SCAN46:	AOJ	T4,			;INCREMENT SFD POINTER TO NEXT
	CAILE	T4,4			;MAKE SURE IT'S NOT FINISHED
	  JRST	SCAN47			;IT IS--SO EXIT
	SETZM	PATH+.PTSFD(T4)		;CLEAR NEXT PART OF PATH
	SETZM	PMASK+.PTSFD(T4)	;  AND IT'S ASSOCIATED MASK
	JRST	SCAN46			;LOOP TILL OUT OF ROOM

SCAN47:	TXZ	F,F$OPPN		;PPN SPEC FINISHED
	TXO	F,F$PPN!F$USER		;AND ACCEPTED IN ORDER (MARK USER TOO)
	JRST	SCAN00			;RETURN TO SCANNER
	SUBTTL	MORE Tests & Parsing

SCAN50:	CALL	SCN400			;CLEAN UP FILE.EXT STUFF IF ANY
	  PJRST	ERRDUP			;OOPS! AN ERROR
	JRST	SCAN00			;GO GET MORE IF ANY

IFN TYMCOM,<
SCAN60:	MOVEI	T4,[ASCIZ\User name or a PPN\]	; Name error
	TXNE	F,F$USER!F$PPN		;ALREADY HAVE A NAME?
	  PJRST	ERRDUP			; YEP!! COMPLAIN
	PUSHJ	P,SCN400		;CHECK OUT THE FILE.EXT SCENE
	  PJRST	ERRDUP			;DUPLICATION ERROR (FILE OR EXT)
	TXO	F,F$OPPR		; SET USER READING '('
SCAN61:	PUSHJ	P,GETNAM		; READ THE NAME INTO T2-T3
	  JUMPL	T1,ERRUUN		;UNTERMINATED USER NAME
	SKIPN	T2			; BLANK?
	JUMPE	T1,SCAN61		; TERMINATED BY A SPACE?
	CAIE	T1,')'			; MUST BE TERMINATED BY A CLOSE
	  PJRST	ERRUUN			; ILLEGALLY TERMINATED USER NAME
	DMOVEM	T2,LOOK+.RBUNM		;USER NAME
	DMOVEM	T2,PATH			; INCLUDE IT AS TYMSHARE DOES IT
	PUSHJ	P,CVPPN##		; AND CONVERT TO A PPN ALSO
	  SETO	T1,			;OOPS-NOT FOUND--LEAVE -1
	MOVEM	T1,LOOK+.RBPPN		;SET THE PPN
	MOVEM	T1,PATH+.PTPPN		; IN PLACES IT'S LOOKED FOR
	TXZ	F,F$OPPR		; CLOSE USER NAME
	TXO	F,F$USER!F$PPN		; SAY WE HAVE ONE!
	JRST	SCAN00			; BYE!
>
	SUBTTL	Switch parsing section

SCAN70:	Skipn	Switch			; Are we allowing switches?
	  Jrst	Scancl			; No!  Clean up and give error
	Call	SCN400			; Clean up any file stuff
	  Pjrst	ERRDUP			; OOPS! some kind of an error.
SCAN71:	Call	Getwrd			; Read a word.
	Setz	T4,			; Clear match pointer
	Move	P1,Sw.Nam		; Get a pointer to the name table
	Move	P2,Sw.Adr		; Get a pointer to storage
SCAN72:	Move	T3,(P1)			; Get an item
	Camn	T3,T2			; Do we have an exact match?
	  Jrst	SCAN74			; Yes -- Forget rest of loop!
	Call	Trimt3			; Trim it to size
	Came	T3,T2			; Do we have a match?
	  Jrst	SCAN73			; Not yet.
	Move	T3,(P2)			; Yes! Copy flag info
	Tlne	T3,SW$UNQ		; Is it a unique switch?
	  Jrst	SCAN74			; Yes--Treat it like an exact match
	Jumpn	T4,ERRSWA		; Ambigious switch?
	Move	T4,P2			; MATCH!
SCAN73:	Aoj	P1,			; Increment
	Aobjn	P2,SCAN72		; Loop.
	Jumpn	T4,SCAN75		; Did we find one?
	Jrst	ERRSWI			; Illegal or unknown switch!

SCAN74:	Move	T4,P2			; Copy pointer to prove it.
SCAN75:	Move	T3,(T4)			; Does it expect a value?
	Tlnn	T3,SW$ARG		; ???
	  Jrst	SCAN76			; No!
	Jumpl	T1,SCAN77		; Yes, is one available? (NO)
	Caie	T1,':'			; Allow colons...
	  Jrst	ERRICS			; ILLEGAL CHAR IN SWITCH
	Tlne	T3,SW$NUM		; Numeric?
	  Call	SWDEC			;  Yes!
	Tlne	T3,SW$NUM		; Numeric?
	  Move	T2,N			;  Yes!  So copy the value read
	Tlne	T3,SW$SIX		; Sixbit?
	  Call	GETWRD			;  Yes!
	Tlnn	T3,SW$SIX!SW$NUM!SW$ASC	; One of these?
SCAN76:	  Movei	T2,1			; Get a value
	Movem	T2,@(T4)		; Store it.
	Caia				;  ...and skip
SCAN77:	SETOM	@(T4)			; Set the argument
	Cain	T1,'/'			; Check if another switch?
	  Jrst	SCAN71			; Yes--DO another one
	Jrst	SCAN00			; do the next thing
	SUBTTL	FINISH UP WITH COMMA (,) OR SIMPLY THE END

SCN600:	TXO	F,F$MORE		;MORE TO COME
	SETO	T1,			;ACT LIKE END OF LINE CHAR


SCN700:	PUSHJ	P,SCN400		;ALL DONE--SO CLEAN UP NOW
	  PJRST	ERRDUP			;DUPLICATION ERROR (FILE OR EXT)
	TXNN	F,F$DEV			;DID THE USER TYPE A DEVICE?
	  JRST	SCN777			;NO--SO SKIP TO END
	MOVE	T1,LOOK+.RBDEV		;YES-GET THE DEVICE & SEE WHAT IT IS
	DEVPPN	T1,			;FIND OUT WHAT PPN IS ASSOCIATED
	  JRST	SCN777			;  WITH THIS DEVICE (QUIT IF ERROR)
	GETPPN	T2,			;GET OUR OWN PPN TO COMPARE
	  JFCL				;   AGAINST THE DEVPPN
	TXNN	F,F$PPN			;BUT USE OUR PPN IF WE TYPED ONE
	  MOVE	T2,PATH+.PTPPN		;  ELSE USE THE PATH PPN
	CAMN	T1,T2			;IF THESE MATCH -- IGNORE ERSATZ PROBLEM
	  JRST	SCN777			;   BY FINISHING UP STRAIGHT AWAY.
	MOVEM	T1,PATH+.PTPPN		;SET THE PAT PPN TO DEVPPN
	STORE	T1,PATH+.PTSFD,PATH+.PTMAX,0	;CLEAR SFD'S IN PATH
	MOVSI	T1,'ALL'		;USE SYSTEM SEARCH LIST
	MOVEM	T1,LOOK+.RBDEV		;  NOW THAT THE PPN IS ESTABLISHED
	JRST	SCN777			;DONE!


SCN400:	TXNE	F,F$OEXT		;SEE IF THERE'S AN EXT COMING
	  JRST	SCAN81			;YES--SO GO & GET IT
	JUMPE	T2,CPOPJ1		;CLEAR?--THEN NO SETTINGS
	MOVEI	T4,[ASCIZ\File name\]	;FILE NAME ERROR
	TXNE	F,F$FILE		;ALREADY A FILE?
	  PJRST	CPOPJ			;ERROR RETURN
	MOVEM	T2,LOOK+.RBNAM		;SETUP NAME
	MOVEM	T3,MASK+MS$NAM		;AND THE ASSOCIATED MASK
	TXO	F,F$FILE		;THEN SET FILE-FOUND
	JRST	CPOPJ1			;RETURN GOOD

SCAN81:	TXZ	F,F$OEXT		;CLOSE OFF EXTENSION
	MOVEM	T2,LOOK+.RBEXT		;SETUP EXTENSION
	MOVEM	T3,MASK+MS$EXT		;AND THE ASSOCIATED MASK
	TXO	F,F$EXT			;AND TELL THEM WE HAVE AN EXTENSION
	PJRST	CPOPJ1			;RETURN
	SUBTTL	FINISH UP PROCESSING

SCN777:	SETZ	T1,			;MAKE THIS ONE PERFECTLY CLEAR
	TXNE	F,F$MORE		;ANY MORE?
	  SETO	T1,			;TELL ME A STORYE ABOUT MORE & MORE
	POP	P,F			;RESTORE THEIR FLAG WORD
CPOPJ1:	AOS	(P)			;SETUP SKIP RETURN
CPOPJ:	POPJ	P,			; RETURN
	SUBTTL	Return the long & short lookup blocks to the addr spec.


;SCN$LK - RETURNS THE LONG - LOOKUP BLOCK TO THE ADDRESS SPECIFIED BY THE USER
;	AS THE CONTENTS OF AC 1.
;EG CALL:
;	MOVE	T1,[LEN,,LOOKUP]	;LENGTH OF BLOCK ,, LOOKUP BLOCK ADDR
;	MOVE	T2,[LEN,,PATH]		;LENGTH OF BLOCK ,, PATH BLOCK ADDR
;	MOVE	T3,[LEN,,LOOKUP-MASK]	;LENGTH OF BLOCK ,, MASK FOR LOOKUP BLOCK
;	MOVE	T4,[LEN,,PATH-MASK]	;LENGTH OF BLOCK ,, MASK FOR PATH BLOCK
;
;AC'S USED T1-T4

SCN$LK:	PUSH	P,F			;SAVE THIS ONE TO USE
	PUSH	P,T1			;ALSO A TEMP
	HLRZ	F,T1			;SIZE OF BLOCK
	MOVEM	F,(T1)			;  PUT IT AWAY
	ADDI	F,(T1)			;  ADD IN THE END-ADDRESS
	EXCH	F,T1			;  SWAP SO WE CAN DESTROY IT
	HRLI	F,LOOK			;  SETUP BLT
	AOBJN	F,.+1			;  INCREMENT BOTH HALVES
	BLT	F,-1(T1)		;  USER NOW HAS HIS BLOCK
	JUMPE	T2,SCNLK0		;IF NO PATH REQUESTED, BYE--!
	HRRZ	T1,(P)			;ELSE GET ADDR OF LOOKUP BLOCK
	HRRZM	T2,.RBPPN(T1)		;  SET HIS PATH BLOCK
	HLRZ	T1,T2			;GET SIZE OF BLOCK
	ADDI	T1,(T2)			;  GET ENDING POINT
	MOVE	F,T2			;  GET BLT WORD
	HRLI	F,PATH			;  AND THE ADDR OF THE PATH BLOCK
	BLT	F,-1(T1)		;  TRANSFER PATH BLOCK
	JUMPE	T3,SCNLK0		;RETURN IF NO MORE (MASKS)
	HLRZ	T1,T3			;GET SIZE OF BLOCK
	ADDI	T1,(T3)			;  GET ENDING POINT
	MOVE	F,T3			;  GET BLT WORD
	HRLI	F,MASK			;  AND THE ADDR OF THE MASK BLOCK
	BLT	F,-1(T1)		;  TRANSFER PATH BLOCK
	JUMPE	T4,SCNLK0		;RETURN IF NO MORE MASKS
	HLRZ	T1,T4			;GET SIZE OF BLOCK
	ADDI	T1,(T4)			;  GET ENDING POINT
	MOVE	F,T4			;  GET BLT WORD
	HRLI	F,PMASK			;  AND THE ADDR OF THE PATH MASK BLOCK
	BLT	F,-1(T1)		;  TRANSFER PATH BLOCK
SCNLK0:	POP	P,T1			;RESTORE TEMPS
	POP	P,F			;AND RETURN
	POPJ	P,
	SUBTTL	SCN$SW	-  SWITCH INITIALIZATION ROUTINE

;SCN$SW - ROUTINE TO INITIALIZE THE SWITCH SCANNER TO ALLOW A
;	  SET OF SWITCHES TO BE APPLIED.  A ZERO LENGTH WILL RESET
;	  THE ROUTINE TO DISALLOW SWITCHES.
;
;CALL:
;	MOVEI	T1,[ LENGTH ,, NAMES
;		     DEFAULT,, STORAGE]
;	PUSHJ P,SCN$SW
;	  <only return>
;

SCN$SW:	HLRZ	T2,(T1)			; DO WE HAVE A LENGTH?
	SKIPN	T2			; ???
	  JRST	SCN$RS			; NO--SO RESET!
	MOVE	T2,1(T1)		; GET DEFAULTS & STORAGE
	HLRM	T2,SW.DFT		; STORE THE DEFAULT TABLE
	HRRM	T2,SW.ADR		; STORE THE RESULT TABLE
	MOVE	T2,(T1)			; GET LENGTH & NAMES
	HRRM	T2,SW.NAM		; STORE THE ADDRESS OF TABLE
	HLRZ	T1,T2			; GET THE LENGTH IN RH
	MOVN	T2,T1			; NEGATE IT FOR AOBJN POINTER
	HRLM	T2,SW.DFT		; STORE
	HRLM	T2,SW.ADR		; STORE
	HRLM	T2,SW.NAM		; STORE

; NOW, STORE GLOBAL VALUES AT THIS TIME.

	MOVE	T1,SW.DFT		; GET THE DEFAULTS
	MOVE	T2,SW.ADR		; AND THEIR STORAGE AREAS
	HRLZI	T3,SW$GLB		; ONLY DO GLOBALS
SCN.GL:	MOVE	T4,(T1)			; GET ONE DEFAULT
	TDNE	T3,(T2)			; TEST FOR GLOBAL
	  MOVEM	T4,@(T2)		; YES--SET IT
	AOBJN	T1,.+1			; INCREMENT
	AOBJN	T2,SCN.GL		; DO GLOBAL LOOP
	SETOM	SWITCH			; ALLOW SWITCHES
	POPJ	P,			; RETURN

SCN$RS:	SETZM	SWITCH			; NO SWITCHES ALLOWED.
	POPJ	P,


SCN.SW:	PUSH	P,T1			; SAVE SOME AC'S
	PUSH	P,T2			; ...
	PUSH	P,T3			; ...
	PUSH	P,T4			; ...
	MOVE	T1,SW.DFT		; GET THE DEFAULTS
	MOVE	T2,SW.ADR		; AND THEIR STORAGE AREAS
	HRLZI	T3,SW$FIL		; ONLY DO FILE SWITCHES
SCN.FL:	MOVE	T4,(T1)			; GET ONE DEFAULT
	TDNE	T3,(T2)			; TEST FOR FILE
	  MOVEM	T4,@(T2)		; YES--SET IT
	AOBJN	T1,.+1			; INCREMENT
	AOBJN	T2,SCN.FL		; DO FILE LOOP
	POP	P,T4			; RESTORE AC'S
	POP	P,T3			; ...
	POP	P,T2			; ...
	POP	P,T1			; ...
	POPJ	P,			; RETURN
	SUBTTL	FILSPC - ERROR Routines

ERR(CRP,MORE)				;COMMA REQUIRED IN PPN
	CALL	MSGOUT			;TELL USER
	MOVE	T1,PATH+.PTPPN		;GET PPN TYPED SO FAR...
	IOR	T1,MASK+MS$PPN		;ADD MASK ON TOP
	CALL	PPNOUT			;PRINT PPN
	JRST	ERROR0			;USE COMMON  EXIT

ERRDU0:	CALL	GETWRD			;GET A NEW WORD
	IOR	T2,T3			;ADD THE MASK
ERRDUP:	MOVEM	T1,STASAV		;SAVE T1 FOR NOW
	PUSH	P,T2			;AND SAVE
	MOVEI	T1,E$MDUP		;DUPLICATE SOMETHING
	CALL	MSGOUT
	MOVE	T1,T4			;...XXX...
	CALL	MSGOUT
	MOVEI	T1," "			;GET A SPACE TO TYPE
	CALL	TYPOUC			;AND TYPE IT
	POP	P,T1			;GET SIXBIT WORD
	CALL	OUTSIX			;PRINT IT
	MOVEI	T1,E$MILL		;ILLEGAL
	JRST	ERRORS

ERRICF:	MOVEM	T1,STASAV		;SAVE T1 FOR NOW
	MOVEI	T1,E$MICH		;ILLEGAL CHARACTER
	CALL	MSGOUT			;   TELL HIM(HER)
	MOVE	T1,STASAV		;GET CHAR BACK!
	MOVEI	T1," "(T1)		;MAKE THE CHARACTER READABLE
	CALL	TYPOUC			;AND TYPE IT OUT
	MOVEI	T1,E$MICF		;  ...IN FILE SPEC
	JRST	ERRORS			;RETURN ETC.

ERRICP:	MOVEM	T1,STASAV		;SAVE T1 FOR NOW
	MOVEI	T1,E$MICH		;TYPE FIRST PART
	CALL	MSGOUT			;  OF ILLEGAL CHARACTR IN PPN MESSAGE
	MOVE	T1,STASAV		;GET CHAR BACK!
	MOVEI	T1," "(T1)		;MAKE THIS CHARACTER A
	CALL	TYPOUC			;THEN -- TYPE IT OUT
	MOVEI	T1,E$MICP		;  THEN PRINT REST OF MESSAGE
	JRST	ERRORS			;USE COMMON  EXIT

ERRICS:	MOVEM	T1,STASAV		;SAVE T1 FOR NOW
	MOVEI	T1,E$MICH		;TYPE FIRST PART
	CALL	MSGOUT			;  OF ILLEGAL CHARACTR IN PPN MESSAGE
	MOVE	T1,STASAV		;GET CHAR BACK!
	MOVEI	T1," "(T1)		;MAKE THIS CHARACTER ASCII
	CALL	TYPOUC			;THEN -- TYPE IT OUT
	MOVEI	T1,E$MICS		;  THEN PRINT REST OF MESSAGE
	JRST	ERRORS			;USE COMMON  EXIT



ERR(IPS)		;ILLEGAL PROTECTION SPECIFICATION
ERR(NSS)		;NULL SFD SPECIFICATION ILLEGAL

ERR(NUL,MORE)		;NULL XXX SPECIFIED
	CALL	MSGOUT			;TELL THEM
	MOVE	T1,T4			;GET THIS PART
	CALL	MSGOUT			;AND TELL THEM
	MOVEI	T1,E$MSPC		;...SPECIFIED
	JRST	ERRORS			;   ....

ERR(SND)		;SFD'S NESTED TOO DEEPLY

ERR(SWA,MORE)		;Switch Ambigious
	CALL	MSGOUT			;TELL THEM
	MOVE	T1,T2			;GET THE NAME
	CALL	OUTSIX			;PRINT IT
	MOVEI	T1,E$MSWE		;...ending
	JRST	ERRORS

ERR(SWI,MORE)		;Switch Illegal
	CALL	MSGOUT			;TELL THEM
	MOVE	T1,T2			;GET THE NAME
	CALL	OUTSIX			;PRINT IT
	MOVEI	T1,E$MSWE		;...ending
	JRST	ERRORS


ERR(UUN)		;UNTERMINATED USER NAME

ERR(WLD,MORE)		;WILD XXX...
	CALL	MSGOUT
	MOVE	T1,T4			;XXX...
	CALL	MSGOUT
	MOVEI	T1,E$MILL		;...ILLEGAL
	JRST	ERRORS


ERRORS:	CALL	MSGOUT			;TYPE OUT THE LAST PART OF MSG
ERROR0:	MOVEI	T1,M$CRLF		;GET CRLF TO TACK ON THE END
	CALL	MSGOUT			;TYPE IT
	SETO	T1,			;SET ERROR RETURN
	POP	P,F
	SKIPGE	STASAV			;IF STATUS IS + THEN CONTINUE
	  POPJ	P,			;NOPE--OK TO RETURN
ERRFIN:	CALL	TYPINC			;READ A CHAR
	CALL	CHKCHR			;SEE IF IT'S A BREAK
	  CAIA				;YES--SO SKIP
	JRST	ERRFIN			;NO--SO LOOP
	JUMPGE	T1,ERRFIN		;WAIT TILL YOU GET AN EOL
	POPJ	P,			;RETURN FROM ROUTINE
	SUBTTL	Text Messages & Storage

.DIRECTIVE	FLBLST			;PRINT BINARY ONLY ON FIRST LINE OF TEXT

E$MCRP:	ASCIZ	/
?FSPCRP	Comma Required in PPN /

E$MDUP:	ASCIZ	/
?FSPDUP	Duplicate /

E$MICF:	ASCIZ	/' in File Specification/

E$MICH:	ASCIZ	/
?FSPICP	Illegal Character '/

E$MICP:	ASCIZ	/' in PPN Specification/
E$MICS:	ASCIZ	/' in Switch Specification/

E$MILL:	ASCIZ	/ is Illegal/

E$MIPS:	ASCIZ	/
?FSPIPS	Illegal Protection Specification/

E$MNSS:	ASCIZ	/
?FSPNSS	Null SFD Specification Illegal/

E$MNUL:	ASCIZ	/
?FSPNUL	Null /

E$MSND:	ASCIZ	/
?FSPSND	SFD Nested too Deep/

E$MSPC:	ASCIZ	/ Specification is illegal/

E$MSWA:	ASCIZ	/
?FSPSWA	Ambigious Switch /

E$MSWI:	ASCIZ	/
?FSPSWI	Illegal Switch /

E$MSWE:	ASCIZ	/ Specified/

E$MUUN:	ASCIZ	/
?FSPUUN	Unterminated User Name/

E$MWLD:	ASCIZ	/
?FSPWLD	Wild card in /



M$CRLF:	ASCIZ	/
/


	SUBTTL	File area storage

SWITCH:	Z			;BEGIN 0 MEANS NO SWITCHES
SW.NAM:	BLOCK	1		;ADDRESS OF CURRENT SWITCH NAME BLOCK
SW.ADR:	BLOCK	1		;ADDRESS OF CURRENT SWITCH VALUE BLOCK
SW.DFT:	BLOCK	1		;ADDRESS OF CURRENT SWITCH DEFAULTS

FCORE:				;BEGINNING OF FILE AREA
STASAV:	BLOCK	1		;SAVE T1 STATE HERE

PATH:	BLOCK	^D9		;PATH BLOCK

MASK:	BLOCK	4		;MASKS FOR DEV,FILE,EXT,PPN
PMASK:	BLOCK	^D9		;MASKS FOR PPN/PATH

LOOK:	BLOCK	35		; FULL SIZE NOT INCLUDING ACCOUNTING INFO

EFCORE:				;END OF FILE AREA


	END
  ^e