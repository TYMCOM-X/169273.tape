TITLE TSTSUP
SUBTTL ABSOLUTE DISK READ/WRITE TOOL
	VTSTSP==4
;LOAD WITH COMMOD.REL
EXTERNAL	CODRIB,RIBALP,RIBCOD,RIBEXT,RIBLST,RIBNAM,RIBPFS
EXTERNAL	RIBPPN,RIBSIZ,RIBSLF,RIBSNM,RIBSTS,RIBSZS,RIPBDR
EXTERNAL	RIBPFS,RIBSFS,RIBRIB,RBLVSP,RBLVPR

	FLG=0
	  FL.DET==1B35		;REPORT DETAIL ON FILE ALLOCATION
	T1=1
	T2=2
	T3=3
	T4=4
	P1=5
	P2=6
	P3=7
	P4=10		;P1-P4 FOR USING IN PATCH PROGRAMS.
	PAGE=16
	P=17

UFD==1

CIO.PI==31
CIO.PO==32

IF2,<
PRINTX from DDT do...
PRINTX PAGE,,DATBRK$B
PRINTX EXIT$X
PRINTX SAVE TSTSUP
>

DEFINE MSG(TEXT),<OUTSTR [ASCIZ\'TEXT\]>
DEFINE CRLF <OUTSTR [ASCIZ /
/]>

DEFINE ERRPOP(TEXT)<JRST [MSG <'TEXT>
		CRLF
		POPJ P,]>
DEFINE ERROR (TEXT) <JRST[MSG<'TEXT>
		EXIT 1,
		JRST .-1]>

	LOC 137
	EXP VTSTSP
	RELOC
ST:	JFCL
	RESET
	SETZ	FLG,
	MOVE	P,[IOWD PDLLEN,PDL]
	OPEN	[EXP 17,SIXBIT/STR/,0]
	  JRST	[OUTSTR [ASCIZ/
NO STR
/]
		EXIT]

	MOVSI	T1,'DSK'
	MOVEM	T1,DSKCBL
	MOVE	T1,[XWD 7,DSKCBL]
	DSKCHR	T1,
	  HALT
	MOVE	T1,DSKCBL+6
	MOVEM	T1,STRBPU#
	MOVEI	PAGE,1

MORE:	PUSHJ	P,CNVPAG		;GET DISK PAGE NUMBER IN AC 1
	MOVE	T2,[CIO.PI,,0]
	CHANIO	T2,T1
	INPUT	IOWD
	GETSTS	T1
	ANDI	T1,IO.ERR
	JUMPE	T1,DATBRK	;GO IF NO ERRORS.
DEFINE IOERRS <
X 400000,IOIMPM,<IMPROPER MODE>
X 200000,IODERR,<DEVICE ERROR>
X 100000,IODTER,<DATA ERROR>
X 40000,IOBKTL,<BLOCK TOO LARGE>
X 20000,IOEOF,<END OF FILE>
>
IO.ERR==760000
DEFINE X(A,B,C)<
'B=='A
TRNE T1,'A
MSG < 'C>
>
ERRBRK:	IOERRS
	CRLF
	SETSTS	0,17
DATBRK:	JRST	MORE

NEXT:	AOJA	PAGE,MORE

OPDEF WRITE [JRST XWRITE]
XWRITE:	PUSHJ	P,CNVPAG		;GET PAGE REL TO STR IN AC 1
	MOVE	T2,[CIO.PO,,0]
	CHANIO	T2,T1
	OUTPUT	IOWD
	GETSTS	T1
	ANDI	T1,IO.ERR
	JUMPE	T1,DATBRK	;GET READY TO READ AGAIN.
	JRST	ERRBRK

CNVPAG:	LDB	T2,RBYUNI
	IMUL	T2,STRBPU
	LDB	T1,RBYPAG
	ADD	T1,T2
	POPJ	P,

RBYUNI:	POINT 8,PAGE,16
RBYPAG:	POINT 19,PAGE,35
IOWD:	IOWD	1000,D
	0

D:	BLOCK	1000

DSKCBL:	BLOCK	7


OPDEF HELP [OUTSTR HLPMSG]
HLPMSG:	ASCIZ \
$P		reads c(PAGE) into data buffer D
MORE$G		same as $P if not at breakpoint
NEXT$G		reads c(PAGE)+1 into data buffer D
WRITE$G		writes out buffer D to c(PAGE)
LOOK$X		asks for file, if found reads its prime rib into buffer D
RLOOK$X		same as LOOK$X, but uses c(USRNAM,FNAME,FEXT)
SCAN$X		scans filename from terminal into c(USRNAM,FNAME,FEXT)
ALC$X		prints out allocation report for file
RIBCLR$X	takes rib in buffer D with rib error and makes it deletable
		(use regular delete in P034/E and later monitors)
HELP$X		types this message
RD$X		Used in patch programs - reads c(PAGE) into buffer D and
		skips if successful.
\
OPDEF LOOK[PUSHJ P,.LOOK]
.LOOK:	PUSHJ	P,FLOOK
	  ERRPOP	<<NOT FOUND>>
	POP	P,T1		;GET RETURN ADDR OFF STACK
	JRST	MORE		;GO READ THE PAGE IN.
OPDEF RLOOK[PUSHJ P,.RLOOK]
.RLOOK:	PUSHJ	P,FLOOK1
	  ERRPOP	<<NOT FOUND>>
	POP	P,T1		;GET RETURN ADDR OFF STACK
	JRST	MORE		;GO READ THE PAGE IN.
OPDEF SCAN[PUSHJ P,.SCAN]
.SCAN:	PUSHJ	P,SCANER
	  HALT	.
	POP	P,T1
	JRST	MORE

FLOOK:	PUSHJ	P,SCANER	;GET FILENAME ETC SETUP
	  HALT	.		;NOT SUPPOSED TO HAPPEN
FLOOK1:	PUSHJ	P,RIBGET	;GET THE PRIME RIB SETUP IN AC PAGE
	  POPJ	P,
	JRST	CPOPJ1		;GOOD RETURN.

;PUSHJ HERE WITH USRNAM,FNAME,FEXT SETUP. RETURN SKIP WITH PRIME RIB
; PAGE IN PAGE IF FOUND, NON-SKIP IF NOT FOUND.
RIBGET:	OPEN	UFD,[EXP 17,SIXBIT/STR/,0]
	  JRST	[OUTSTR [ASCIZ/
NO STR
/]
		 POPJ P,]
	MOVEI	T1,USRNAM
	SKIPN	(T1)
	GETPPN	T1,
	  JFCL
	MOVEM	T1,UFDLKB+2
	MOVE	T1,[1,,1]
	MOVEM	T1,UFDLKB+1
	MOVSI	T1,'UFD'
	MOVEM	T1,UFDLKB+3
	LOOKUP	UFD,UFDLKB
	  JRST	[OUTSTR [ASCIZ/
CAN'T FIND UFD
/]
		 POPJ P,]
	MOVE	T1,FNAME
	TLZ	T1,400000
	IDIVI	T1,7		;GET PAGE NUMBER TO START
	ADDI	T2,1		;START WITH 1
GETUFD:	MOVE	T1,[CIO.PI,,UFD]
	CHANIO	T1,2
	MOVEM	T2,UFDPAG
	INPUT	UFD,UIOWD
	GETSTS	UFD,1
	ANDI	T1,IO.ERR
	TRNE	T1,20000
	JRST	[OUTSTR [ASCIZ/
<UFD EOF>
/]
		 POPJ P,]
	SKIPE	T1
	HALT	.+1
	MOVE	T3,[-1000,,UD]
UFDLUP:	SKIPN	T1,(T3)
	JRST	UFDNXP
	CAME	T1,FNAME
	JRST	UFDNXE
	HLLZ	T1,1(T3)
	CAME	T1,FEXT
	JRST	UFDNXE
	OUTSTR	[ASCIZ/
<FOUND>
/]
	MOVE	PAGE,4(T3)
CPOPJ1:	AOS	(P)		;SKIP RETURN WITH PAGE IN AC PAGE
CPOPJ:	POPJ	P,

UFDNXE:	ADD	T3,[4,,4]
	AOBJN	T3,UFDLUP
UFDNXP:	SKIPN	T2,UD+777
	POPJ	P,		;ERROR RETURN.
	AOJA	T2,GETUFD	;GET LINK PAGE NUMBER, CONTINUE.

UIOWD:	IOWD 1000,UD
	0
UD:	BLOCK	1000

USRNAM:	EXP 0,0
FNAME:	0
FEXT:	0

UFDLKB:	EXP 3,0,0,0
UFDPAG:	0

OPDEF	RIBCLR	[PUSHJ P,XRBCLR]
XRBCLR:	MOVE T1,D+RIBSLF	; CHECK RIBSLF
	CAME T1,PAGE
	  ERRPOP <RIBSLF BAD>
	MOVE T1,D+RIBCOD	; CHECK RIBCOD
	CAIE T1,CODRIB
	  ERRPOP <RIBCOD BAD>
	MOVE T1,D+RIBNAM	; CHECK NAME
	CAME T1,FNAME
	  ERRPOP <RIBNAM BAD>
	HLLZ T1,D+RIBEXT	; CHECK EXTENSION
	CAME T1,FEXT
	  ERRPOP <RIBEXT BAD>
	MOVE T1,D+RIBPPN	; CHECK DIRECTORY
	CAME T1,UFDLKB+2
	  ERRPOP <RIBPPN BAD>
	MOVE T1,D+RIBSTS	; IS IT REALLY BAD?
	TRNN T1,RIPBDR
	  ERRPOP <?RIPBDR=0 - shame on you!>
	SETZM D+RIBPFS		; ZERO RIB POINTERS
	MOVE T1,[D+RIBPFS,,D+RIBPFS+1]
	BLT T1,D+RIBLST
	MOVEI T1,1		; SET RIBALP TO 1
	MOVEM T1,D+RIBALP
	MOVEM T1,D+RIBSZS	; SET RIBSZS TO 1
	SETZM D+RIBSIZ		; ZERO RIBSIZ
	SETZM D+RIBSNM		; ZERO RIBSNM
	SETZM D+RIBSTS		; ZERO RIBSTS
	JRST	CPOPJ1		;RETURN SUCCESS TO USER.


;HERE TO SCAN A FILE AND REPORT ON ITS ALLOCATION

OPDEF ALC[PUSHJ P,ALCSCN]
ALCSCN:	PUSHJ	P,FLOOK		;GET FILE IN
	  ERRPOP <<NOT FOUND>>
	PUSHJ	P,REDPAG	;READ PAGE INTO BUFFER
	  ERRPOP <CAN'T READ FILE'S PRIME RIB>

	MOVE	T1,[UNICNT,,UNICNT+1]
	SETZM	UNICNT
	BLT	T1,UNICNT+SIZUNI-1	;CLEAR OUT TABLE THAT COUNTS
	MSG	<DETAILED REPORT?>
	INCHRW	T1
	INCHRW	T2
	CAIE	T2,12
	JRST	.-2
	CAIN	T1,"Y"
	TROA	FLG,FL.DET
	TRZ	FLG,FL.DET
	SETZM	PAGNO		;CLEAR OUT PAGE NUMBER IN FILE WE ARE DOING
	SETOM	HGHUNI		;HIGHEST UNIT SEEN.
	SETOM	UNIGRP		;FORCE NEW GROUP TO START.
	TRNE	FLG,FL.DET	;DETAILED REPORT?
	MSG	<FILE PAGES	UNIT>
	CRLF

RIBSCN:	PUSHJ	P,RPTRIB	;REPORT ON RIB PAGE, INCREMENT COUNTS
	SKIPE	D+RIBRIB	;PRIME OR SPARE
	SKIPA	T4,[-RBLVSP,,D+RIBSFS]
	MOVE	T4,[-RBLVPR,,D+RIBPFS]

RIBSC1:	SKIPN	PAGE,(T4)	;GET NEXT POINTER
	JRST	RIBSC4
	JUMPG	PAGE,RIBSC2	;GO IF NOT SPARE POINTER.
	PUSH	P,T4		;SAVE PLACE IN THIS RIB
	PUSHJ	P,REDPAG	;GET PAGE INTO BUFFER
	  ERROR <CAN'T READ FILE'S RIB>
	JRST	RIBSCN		;AND SCAN THAT RIB.
RIBSC2:	PUSHJ	P,RPTPAG
RIBSC3:	AOBJN	T4,RIBSC1	;DO NEXT ONE
RIBSC4:	SKIPN	PAGE,D+RIBRIB	;GET NEXT HIGHER RIB IF ANY
	JRST	RIBEOF		;DONE
	PUSHJ	P,REDPAG	;GET HIGHER LEVEL RIB AGAIN
	  ERROR <CAN'T RE-READ FILE'S RIB>
	POP	P,T4		;GET SAVED POINTER
	JRST	RIBSC3		;AND CONTINUE

RIBEOF:	PUSHJ	P,RPTPAG	;CLOSE OFF DETAILED REPORT IF NECESSARY
	CRLF
	MSG	<UNIT		NUMBER OF PAGES>
	CRLF
	SETZ	T4,		;WILL HAVE UNIT WORKING ON.
RIBEO1:	SKIPN	UNICNT(T4)	;ANY COUNTS FOR THIS UNIT?
	JRST	RIBEO2		;NO
	MOVE	T1,T4		;GET UNIT NUMBER
	PUSHJ	P,DECOUT	;PRINT UNIT NUMBER
	MSG	<		>
	MOVE	T1,UNICNT(T4)
	PUSHJ	P,DECOUT
	CRLF
RIBEO2:	CAMGE	T4,HGHUNI	;DONE?
	AOJA	T4,RIBEO1	;NO
	POPJ	P,		;YES.
RPTCOM:	JUMPE	PAGE,CPOPJ	;IF THE END, DON'T INCREMENT
	LDB	T2,RBYUNI	;GET UNIT NUMBER
	CAILE	T2,SIZUNI-1	;IN RANGE?
	JRST	[MSG <BAD RIB>
		 EXIT]
	AOS	UNICNT(T2)	;INCREMENT
	CAMLE	T2,HGHUNI
	MOVEM	T2,HGHUNI
	POPJ	P,		;RETURN.

RPTRIB:	PUSHJ	P,RPTCOM
	TRNN	FLG,FL.DET	;DETAILED REPORT?
	POPJ	P,		;NO, FORGET IT.
	MOVEI	T1,[ASCIZ/PRIB(/]
	SKIPGE	PAGE
	MOVEI	T1,[ASCIZ/SRIB(/]
	OUTSTR	@T1
	MOVE	T1,PAGNO
	PUSHJ	P,DECOUT	;REPORT WHICH RIB IT IS
	MSG	<)		>
	LDB	T1,RBYUNI	;GET UNIT NUMBER
	PUSHJ	P,DECOUT
	CRLF
	POPJ	P,

RPTPAG:	AOS	PAGNO
	PUSHJ	P,RPTCOM	;DO STUFF WE DO FOR RIBS.
	TRNN	FLG,FL.DET	;DETAILED REPORTS?
	POPJ	P,		;NO
	JUMPE	PAGE,RPTPG0	;IF THE END, JUST FINISH OFF.
	CAMN	T2,UNIGRP	;SAME UNIT AS LAST TIME?
	POPJ	P,		;YES, DON'T SAY ANYTHING YET.
	SKIPGE	UNIGRP		;MAKE SURE NOT FIRST TIME
	JRST	[MOVEM T2,UNIGRP ;IT IS, UNIT UNIGRP
		 MOVE T1,PAGNO  ;AND INIT FIRGRP
		 MOVEM T1,FIRGRP
		 POPJ P,]	;RETURN.
RPTPG0:	PUSH	P,T2		;SAVE IT FROM DECOUT
	MOVE	T1,FIRGRP	;GET FIRST PAGE OF GROUP
	PUSHJ	P,DECOUT	;PRINT IT
	MOVE	T1,PAGNO
	AOS	T2,FIRGRP	;SEE IF ONLY ONE PAGE IN GROUP
	CAMN	T1,T2
	JRST	RPTPG1		;ONLY ONE PAGE
	MSG	(<->)		;PRINT RANGE
	SUBI	T1,1		;LAST PAGE OF GROUP
	PUSHJ	P,DECOUT
RPTPG1:	MOVE	T1,PAGNO
	MOVEM	T1,FIRGRP	;START OF NEW GROUP.
	MSG	<		>
	MOVE	T1,UNIGRP	;GET LAST UNIT NUMBER
	PUSHJ	P,DECOUT
	CRLF
	POP	P,UNIGRP	;NEW LAST UNIT
	POPJ	P,		;AND RETURN.

UNIGRP:	0			;UNIT OF CURRENT GROUP.
FIRGRP:	0			;PAGE NUMBER IN FILE OF FIRST PAGE IN THIS UNIT NUMBER GROUP
PAGNO:	0			;CURRENT FILE PAGE NUMBER.
HGHUNI:	0			;HIGHEST UNIT SEEN.

SIZUNI==^D50			;MAX NUMBER OF UNITS EXPECTED TO SEE IN STR

UNICNT:	BLOCK	SIZUNI
DECOUT:	MOVEI	T3,^D10
RADOUT:	IDIVI	T1,(T3)
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,RADOUT
	HLRZ	T1,(P)
	OUTCHI	"0"(T1)
	POPJ	P,

OPDEF RD [PUSHJ P,REDPAG]

REDPAG:	PUSHJ	P,CNVPAG	;T1 GETS PAGE TO USE
	MOVE	T2,[CIO.PI,,0]
	CHANIO	T2,T1		;SUPER USETI
	INPUT	IOWD
	GETSTS	T1
	ANDI	T1,IO.ERR
	JUMPE	T1,CPOPJ1
	POPJ	P,
SCANER:	OUTSTR [ASCIZ "File: "]
	SETZM USRNAM
	SETZM USRNAM+1
	SETZM FNAME
 	SETZM FEXT
S1:	MOVE T1,[POINT 6,FNAME]
	MOVEI T2,6
	SETZM FNAME
S2:	INCHWL T3
	CAIN T3,15	; IF <CR> EAT LF
	  INCHWL T3
	CAIL T3,140
	  SUBI T3,40
	CAIN T3,"("
	  JRST [MOVE T1,[POINT 6,USRNAM]
		MOVEI T2,14
		SETZM USRNAM
		SETZM USRNAM+1
		JRST S2]
	CAIN T3,")"
	  JRST S1
	CAIN T3,"."
	  JRST [MOVE T1,[POINT 6,FEXT]
		MOVEI T2,3
		SETZM FEXT
		JRST S2]
	SUBI T3,40
	JUMPL T3,CPOPJ1
	JUMPE T3,S2
	SOJL T2,S2
	IDPB T3,T1
	JRST S2

PDLLEN==^D40
DEFINE PDLOV<JRST [MSG<PDL UNDERFLOW>
		HALT .]>
REPEAT 10,<PDLOV>
PDL:	BLOCK	PDLLEN
PAT:	BLOCK	1000
	END	ST
 