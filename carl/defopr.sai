
begin "SETOP SYSTEMS"

require "(CARL)DEFOPR.INF"   source!file;

require "(SAILIB)SAIL.DEF"   source!file;
require "(SAILIB)UUOSYM.DEF" source!file;
require "(SAILIB)VERSN.REQ"  source!file;
require "(SAILIB)VMFILE.REQ" source!file;
require "(SAILIB)BITARY.REQ" source!file;
require "(SAILIB)FRMRUN.REQ" source!file;

require "(CARL)DEFOPR.DEF"   source!file;
require "(CARL)OPRSUB.REQ"   source!file;
require "(CARL)OPRPKG.REQ"   source!file;
require "(CARL)LOGPKG.REQ"   source!file;
require "(CARL)BRKINI.REQ"   source!file;
require "(CARL)LICSUB.REQ"   source!file;
require "(CARL)DAYTIM.REQ"   source!file;
require "(CARL)STXLIB.REQ"   source!file;


define
	C$$PRV = !bit(0)	! privileged command ;
,	C$$MNT = !bit(1)	! maintenance command ;
,	C$$SLF = !bit(2)	! self implied without license ;
,	C$$LIC = !bit(4)	! license grant command ;
,	C$$MAN = !bit(5)	! manager level command ;
,	C$$EMP = !bit(7)	! in employee text data ;
,	C$$BIN = !bit(8)	! in binary data file ;
,	C$$CAS = !bit(16)	! allow lower case input ;
,	C$$INV = !bit(17)	! invisible command ;
,	C$$DEV = C$$PRV lor C$$INV lor C$$MNT
;

Define All.Commands = {

!C!( Add, "       opername  Create a new opername entry.", C$$PRV lor C$$EMP )
!C!( Cancel, "    opername  Remove an opername entry.", C$$PRV lor C$$EMP )
!C!( Imitate, "   opername  Assume another identity.", C$$PRV )
!C!( Who, "                 Print information about my identity.", C$$PRV )
!C!( XYZZY, "               Enter maintenance mode.", C$$PRV lor C$$INV )

!C!( Request, "   opername  Request a new opername from validations." )
!C!( List, "      opername  List one or more opername entries." )
!C!( Managed, "   opername  List all names managed by opername." )
!C!( Change, "    opername  Change information for an opername entry.", C$$SLF )
!C!( Password, "  opername  Change the password for an opername entry.", C$$SLF )
!C!( Transfer, "  oper man  Transfer opername oper to manager man.", C$$MAN )

!C!( Grant, "     opername  Grant license to another entry.", C$$LIC )
!C!( Remove, "    opername  Remove license from an opername entry.", C$$LIC )
!C!( Show, "      opername  Show license grant links for an entry." )

!C!( Hold, "      opername  Put an opername entry on hold.", C$$MAN )
!C!( Release, "   opername  Release an opername from hold.", C$$MAN )

!C!( Brief, "               Disable VERBOSE mode." )
!C!( Verbose, "             Enable verbose messages when available." )
!C!( Help, " or ?           Reprint this message." )
!C!( Exit, "                Exit program.", C$$INV )
!C!( Quit, "                Exit program." )

!C!( Batch, "               Toggle batch/normal mode for data entry.", C$$DEV )
!C!( Debug, "               Allow developer to debug the program.", C$$DEV )
!C!( Dump, "      <file>    Dump the database into a flat file.", C$$DEV )
!C!( Futz, "                Do something special.", C$$DEV )
!C!( Index, "               Index text file against binary file.", C$$DEV lor C$$EMP )
!C!( Open, "      <file>    Read system file or <file> into memory.", C$$DEV )
!C!( Statistic, " opername  Show statistics for an opername entry.", C$$DEV )
!C!( Trace, "     opername  Print trace information for an entry.", C$$INV )
!C!( Unlock, "              Unlock binary and text files after crash.", C$$DEV )
!C!( Verify, "              Verify structure and space allocation.", C$$DEV )
!C!( Write, "               Write password file to user directory.", C$$DEV )

    };


require crlf message;
Redefine !C!(Nam,Hlp,Flg,AltC) = {
require
    ifcr length(cvps(flg))  thenc ("000000"&cvos(!lh(flg)))[inf-5 to inf-3] &
				  ("000000"&cvos(!lh(flg)))[inf to inf] &
			    elsec  "    " & endc " " &
    cvps(Nam) & Hlp &
    ifcr length(cvps(altc)) thenc " use: "& cvps(altc)  & endc
    crlf message;
};
All.Commands
require crlf message;

Redefine Len.Commands = 0;
Redefine !C!(Nam,Hlp,Flg,AltC) = {
    Ifcr Len.Commands > 0 thenc , endc CvPS(Nam)
    Redefine Len.Commands = Len.Commands + 1;};
Preset!with All.Commands;
Own safe string array CmdName[1:Len.Commands];


Redefine Len.Commands = 0;
Redefine !C!(Nam,Hlp,Flg,AltC) = {
    Ifcr Len.Commands > 0 thenc , endc
    Ifcr Length(CvPS(Flg)) thenc Flg elsec 0 endc
    Redefine Len.Commands = Len.Commands + 1;};
Preset!with All.Commands;
Own safe integer array CmdFlag[1:Len.Commands];


Redefine Len.Commands = 0;
Redefine !C!(Nam,Hlp,Flg,AltC) = {
    Ifcr Len.Commands > 0 thenc , endc Cvps(Nam) & Hlp
    Redefine Len.Commands = Len.Commands + 1;};
Preset!with All.Commands;
Own safe string array CmdText[1:Len.Commands];


Redefine !C!(Nam,Hlp,Flg,AltC) = {
    Ifcr Length(CvPS(AltC))
     thenc AltC;
     elsec C.}&{Nam}&{;
    endc};

define pagebreak = {};
define spaces = 
    {"                                                                "};
define lpad(x,y) = {(spaces[1 for y]&(x))[inf-(y-1) to inf]};
define rpad(x,y) = {((x)&spaces[1 for 1 max (y-length(x))]};

define Gettab(x,y) = {calli( !xwd( (x),(y) ), calli!GETTAB )};

define Bomb(text) = {begin print(text&crlf&crlf); return end};

define maintenancemessage = { "
  A black cloud envelops you as you see the sceptre of death approach.
  Hark!  You are a maintainer...  and you begin to glow with a bright light.
  Death retreats as quickly as he came... you are in Maintenance mode!

" };


internal integer vml,vmi,vmx;		! length, index-page, data-page ;
internal integer Level, MySelf;		! tree depth, self node ;
internal integer MyLock, LockWait;	! my lock id number, wait time ;
internal integer BinLevel, TxtLevel;	! levels of locking ;
internal integer Today, RootNode;	! today's date, root node;
internal string  Line;			! line from user ;

Integer BinSlot, BinChan, TxtSlot, DmpSlot, Written;
Integer Eof, EndOfFile, Count, Index, I, InitialSelf;

Preset!with  cvsix("#REPO#"), 1 lsh 18, -1, 1, -1, -1, [6] 0, '377 rot -8;
Safe integer array NewIndexData[ 0:I!Sat ];
Boolean Verbose, FileModified, SetMgr, SuperUser, Maintenance, BatchMode;

Preset!with  !xwd('00,'20), '00, !xwd('34,'14), '600377775717,
	     '21, '21, 0, 0, '21, '21, -1, 0,
	     !xwd('00,'00), 0, 0, -1,
	     !xwd('00,'00), '00, !xwd('00,'34), '600377775717,
	     cvsix("ROOT"), 0, '267411405420, 0, cvsix("ROOT"), 0, -1, 0,
	     !xwd('00,'20), 0, 0, '377775717;
Safe integer array NewSetopData[ 0:'37 ];

String  Filename, Command, MessageText, Str, L;
String  MyName;


simple procedure InitMemPointer;
begin

    begin!code
	Setzm	vml;			! initialize length of buffer ;
	Movei	'1,'677000;		! use page 677 ;
	Movem	'1,vmi;			! for the index page ;
	Movei	'1,'700000;		! start with page 700 ;
	Movem	'1,vmx;			! for the data ;
    end;

end;
require InitMemPointer initialization;


simple boolean procedure Ok2See( integer lic, flag );
begin "ok to see"

    if ( Maintenance )  or
       ( SuperUser and not( Flag land C$$MNT ) )
     then return( true );

    if ( Flag land C$$PRV )
     then return( Lic land L!SU );

    if not( Flag land ( C$$LIC lor C$$MAN ) )
     then return( true );

    if ( ( Flag land C$$LIC ) and ( Lic land L!LG ) )
     then return( true );

    if ( ( Flag land C$$MAN ) and ( Lic land L!MG ) )
     then return( true );

    return( false );

end "ok to see";


define TopManager = '2000;
safe integer array Mgrs[ 0:TopManager-1 ];
safe string  array Managers[ 0:TopManager-1 ];
integer UsedMgrs;


simple procedure Forget;
begin "management purge"
    own integer r, l;

    arrClr( Mgrs );			! clear pointer array ;
    arrClr( Managers );			! clear text array ;
    UsedMgrs_ -1;			! reset manager count ;

    if ( BinSlot )
     then VMFree( BinSlot );

    InitMemPointer;

end "management purge";
require Forget initialization;


simple procedure C.Verify;
begin "verify structure"
    own integer array Sats[ 0:511 ];	! one page is more than enough ;
    define MySatBase = { location( Sats[ 0 ] ) };
    integer r, t, b, c, MisMatch;

    if ( memory[ !jbVER ] neq t_ memory[ vmi + I!Version ] )
     then print( "%OPRVER File written by version ", !VERSN( t ), crlf );

    arrClr( Sats );			! clear memory map ;
    r_ 0;				! start at tree trunk ;
    while ( t_ r_ traverse( r ) )	! for each node ;
     do begin "set Sats"		!  set bits in the memory map ;

	b_ BitPtr(r div 4) + MySatBase;	! get pointer for new bitmap ;
	for c_ 1 upto 3			! for each entry block ;
	 do idpb( 1, b );		! bit set in bitmap ;

	while ( t_ Rlk( t ) )		! if any gifts, set them in map ;
	 do idpb( 1, b_ BitPtr(t lsh -2) + MySatBase );

	t_ r;				! reset index to oper entry ;
	while ( t_ Glk( t ) )		! if any grants, set them in map ;
	 do idpb( 1, b_ BitPtr(t lsh -2) + MySatBase );

     end "set Sats";

    b_ point( 1, memory[ vmi + I!Sat ], -1 );	! get pointer into bitmap ;
    t_ point( 1, memory[ MySatBase ],   -1 );

    for c_ 1 upto 4
     do begin ibp( b ); idpb( 1,t ) end;	! skip entry 0 ;

    MisMatch_ 0;
    for c_ 5 upto MaxSat
     do if ( ildb( b ) neq ildb( t ) )
	 then MisMatch_ MisMatch + 1;

    if ( MisMatch )
     then begin "tell about problem"
	print( "%OPRSAT Mismatch in memory allocation table...repairing."&crlf );
	arrblt( memory[ vmi + I!Sat ], memory[ MySatBase ], MaxSat div 36 );
     end "tell about problem"
     else print( "[OPRVER Memory map verified]"& crlf );

end "verify structure";


simple boolean Procedure C.Imitate;
begin "validations"
    integer v, count;
    string MyOper;

    Count_ TrialCount;		! only loop for so many times ;

    while ( 0 leq Count_ Count - 1 )
     do begin "validate name"

	if ( length( Line ) )
	 then MyOper_ Line
	 else if ( InitialSelf )
	       then MyOper_ Sxt( Opr( InitialSelf ) )
	       else if ( "?" = MyOper_ Prompt( "Opername: " ) )
		     then begin "help wanted"
			print( crlf &"Please enter your Opername"& crlf );
			Count_ Count+1;	! allow an extra time for "?" ;
			continue;	! we know it is kept in memory ;
		     end "help wanted";

	Line_ null;			! clear this for loop-back ;

	if not( length( MyOper ) )	! allow a carriage return ;
	 then begin "use root"
	    if ( InitialSelf )		! default back to myself ;
	     then MyOper_ Sxt( Opr( InitialSelf ) )
	     else MyOper_ RootHead;	! or setup as root ;
	    print( "[OPRVAL validating opername ", NoSp(MyOper), "]"& crlf );
	 end "use root";

	if ( v_ FndName( MyOper, 0 ) )	! does name exist? ;
	 then begin "setup self"

	    if ( Licens( v ) land L!Hold )
	     then begin "holding out"
		print( "?OPRHLD You are on hold."& crlf );
		return( false );
	     end "holding out";

	    if ( SuperUser )  or	! we are already validated ;
	       ( PswCph( v )
		 = PasHsh( PasGet( if EolTrm = #Esc
				    then null
				    else "Password: " ) ) )
	     then begin "good password"

		if ( Licens( v ) < 0 )	! check privileges ;
		 then SuperUser_ true;	!  and set ;

		print( (if v_ Man( MySelf_ v )
			 then "Manager: "& NoSp( Sxt( Opr( v ) ) ) & crlf
			 else null),
		       crlf );
		return( true );		! then finish validation ;

	     end "good password"
	     else print( "?OPRPSW Bad password."& crlf );

	 end "setup self"
	 else if ( InitialSelf )	! bad name, if not first time ;
	       then done;		! then we are completely done ;

     end "validate name";

    return( false );

end "validations";


Procedure WriteFile( Boolean Reality );
! ----------------------------------------------------------------------;
!									;
!	"WRITE"		Write out a copy of the in-core system list	;
!			on the current user's directory.		;
!									;
! ----------------------------------------------------------------------;
begin

    if not( FileModified )
     then Print( "No changes made."& Crlf );
    Print( "Writing..." );

    VMFree( BinSlot );

    FileModified_ False;
    Print( "Done."& Crlf );

end;



simple Procedure C.Quit;
begin
    if ( BinSlot )
     then VMFree( BinSlot );
    calli( 0, calli!EXIT );
    start!code uuo!EXIT end;
end;

Simple Procedure C.Exit;
begin
    Line_ System.File;

    if ( FileModified )
     then WriteFile( false );

    C.Quit;
end;


Procedure C.Open;
! ----------------------------------------------------------------------;
!									;
!	"OPEN"		Read a new copy of the master opername list.	;
!									;
! ----------------------------------------------------------------------;
begin

    if ( BinSlot > 0 )			! Do we have the file open? ;
     then VMFree( BinSlot );		! Maybe, so close this slot ;

!    print( "Reading system file."& Crlf );
    if not( length( Filename_ Line ) )
     then Filename_ System.File;

    Forget;				! empty list ;
    Count_0;

    if ( 0 > BinSlot_ VMFile( Filename, VM$Read, 1, File.Page ) )
     then begin "no file"
	print( Filename," not found.  Empty list created.",Crlf );
	VMFree( BinSlot );

	if ( 0 > BinSlot_ VMFile( Filename, VM$Write, 2, File.Page ) )
	 then begin "cannot create"
	    print( "Cannot create ", Filename, " (", cvos(!rh(BinSlot)), ")."& crlf );
	    C.Quit;
	 end "cannot create";

	VMGetW( BinSlot, 0 );		! pull in the file ;

	arrBlt( memory[ vmi ], NewIndexData[ 0 ], I!Sat+1 );
	memory[ vmi+I!Size ]_ vml_ 1;	! size of data area ;
	memory[ vmi+I!Version ]_ memory[ !jbVER ];
	memory[ vmi+I!Change ]_ Today;	! make change = creation ;
	arrBlt( memory[ vmx ], NewSetopData[ 0 ], '40 );
	VMFree( BinSlot );		! close file ;

	MySelf_ '20;			! hard coded constants ;
	SuperUser_ true;		! select special privs ;

	if ( 0 > TxtSlot_ VMFile( Text.File, VM$Write, 1, Text.Page ) )
	 then begin "no text file"
	    print( "?OPRCRE Cannot create ", Text.File &"."& crlf );
	    return
	 end "no text file";

	VMText( TxtSlot, crlf &"000000000000;ROOT        "& crlf );
	VMFree( TxtSlot );

     end "no file"
     else begin "read file size"
	vml_ VMGetC( BinSlot, VM$Size ) div 5;
	if ( vml mod 512 )		! if eof is inside a page ;
	 then vml_ (vml div 512)	!  remember that page + 1 - 1 ;
	 else vml_ (vml div 512) - 1;	!  else that page - 1 ;
	VMFree( BinSlot );		! close file ;
     end "read file size";

    if ( 0 > BinSlot_ VMFile( Filename, VM$Multi, 1+vml, File.Page ) )
     then begin "cannot read file"
	print( "SETOP master file unavailable.  Contact software support."&crlf );
	C.Quit;
     end "cannot read file";

    if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi, 1, Text.Page ) )
     then begin "no text file"
	print( Text.File &" not found."& crlf );
	return
     end "no text file";
    VMFree( TxtSlot, CL!ACS lor CL!RST );

    VMGetW( BinSlot, 0 );		! pull in the file ;

    C.Verify;				! verify data structure ;

    if not( SuperUser ) and		! no validations necessary ;
       not( C.Imitate )			! figure out who we are ;
     then C.Quit;			! oops, no good -- bye bye ;

end;


procedure printEntry( reference integer r );
begin "print entry"
    integer t, doe, license;
    string ThisName;

    license_ AllLic( r );

    print(  Sxt( Opr( r ) ),
	    (case ( t_ ( ISCDst( r ) lsh -20 ) land '77 )
	      of ([0] "#",		! St. Louis Payroll ;
		  [1] "I",		! Irvine Payroll ;
		  [else] "?")),		! ? Payroll group ;
	    (if ( t_ ISCDst( r ) land '3777777 )
	      then lpad( cvs( t ),6 )	! ISC Number ;
	      else "      "),
	    (if license land L!Hold
	      then " HOLD"
	      else null),
	    (if ( License land L!CAP )
	      then " "& LicPrt( License land L!CAP )
	      else null),
	    crlf,
	    (if ( License_ License land lnot L!CAP )
	      then "            "& LicPrt( License ) & crlf
	      else null),
	    (if ( t_ Man( r ) )
	      then "            Manager: "& Sxt( Opr( t ) )
	      else null),
	    (if ( t_ISCDst( r ) lsh -26 )
	      then "            district: "& cvs( t )
	      else null),
	    crlf );

    if ( Verbose and EmpMsc( r ) )		! Verbose? Validated? ;
     then begin "give more info"

	if ( TxtSlot )
	 then begin "text available"

	    VMSetC( TxtSlot, EmpMsc( r )+2 );	! setup for employee ;
	    Line_ VMLine( TxtSlot, Brk );	! Entry info ;
	    if ( kequ( ThisName_ Line[14 for 12], Sxt( Opr( r ) ) ) )
	     then begin "good info"
		print( "Entry date: ", TymDay( cvo( Line[1 for 12] ) ), crlf );
		while ( length( Line_ VMLine( TxtSlot, Brk ) ) )
		 do print( (case Token( Line )
			     of ( ["A"]  "Address:    ",
				  ["C"]  "            ",
				  ["D"]  "Department: ",
				  ["E"]  "Employee:   ",
				  ["M"]  "Mailbox:    ",
				  ["S"]  "Supervisor: ",
				  ["U"]  "Username:   ",
				  ["W"]  "Why needed: ",
				  [else] "            " )),
			    NoSp( Line ), crlf );
	     end "good info"
	     else print( "%OPRTXT Text pointer mangled: (",
			 NoSp( ThisName ),")."& crlf );

	 end "text available"
	 else print( "%OPRTXT No additional information available at this time."& crlf );

      end "give more info";

    print( crlf );

end "print entry";


simple procedure printGrant( integer g, ch );
begin "print grants"

    if ( ch = "R" )
     then print( " from ", Sxt( Opr( Gix( g ) ) ) )
     else print( " to   ", Sxt( Opr( Rix( g ) ) ) );

    print(  " on ", cvSDat( Gdt( g ) ),
	    (if Rdt( g )
	      then " until "& cvSDat( Rdt( g ) )
	      else null),
	    crlf &"      ",
	    LicPrt( GlcRlc( g ) ),
	    crlf );

end "print grants";


simple procedure ShowEntry( reference integer r );
begin "show grants"
    integer t;

    t_ Licens( r );

    print(  Sxt( Opr( r ) ),
	    lpad( cvos( r ), 6 ),
	    (if t land L!Hold
	      then " HOLD"
	      else null),
	    (if t
	      then "  "& LicPrt( t )
	      else null),
	    crlf );

    t_ r;
    while ( t_ Rlk( t ) )
     do if ( Gix( t ) )
	 then printGrant( t, "R" );

    t_ r;
    while ( t_ Glk( t ) )
     do printGrant( t, "G" );

    print( crlf );

end "show grants";



simple procedure EntryStatus( reference integer r );
begin "set grants"
    integer t, b, c, ms, es, rs, gs, ei;

    print(  Sxt( Opr( r ) ),
	    lpad( cvos( r ), 6 ),
	    "a"
	);

    ms_ es_ rs_ gs_ 0;			! no size y

    b_ BitPtr(r div 4) + vmi + I!Sat;	! get pointer into bitmap ;
    for c_ 1 upto 3
     do if ( ildb( b ) )		! bit set in bitmap? ;
	 then es_ es + 1		! marked size ;
	 else ms_ ms + 1;		! un-marked size ;

    t_ r;
    while ( t_ Rlk( t ) )
     do if ( ildb( b_ BitPtr(t lsh -2) + vmi + I!Sat ) )
	 then rs_ rs + 1
	 else ms_ ms + 1;

    t_ r;
    while ( t_ Glk( t ) )
     do if ( ildb( b_ BitPtr(t lsh -2) + vmi + I!Sat ) )
	 then gs_ gs + 1
	 else ms_ ms + 1;

    ei_ EmpMsc( r );			! employee info record ;

    print( NoSp( (if es then lpad( cvs( es ), 4 ) &"e" else "     ") &
		 (if rs then lpad( cvs( rs ), 4 ) &"r" else "     ") &
		 (if gs then lpad( cvs( gs ), 4 ) &"g" else "     ") &
		 (if ei then lpad( cvs( ei ), 8 ) &"i" else "         ") &
		 (if ms then lpad( cvs( ms ), 4 ) &"m" else null )
	       ),
	   crlf
	  );

end "set grants";


procedure printTrace( reference integer r );
begin "print trace"
    integer t;

	print(	Sxt( Opr( r ) ),
		lpad( cvos( r ), 6 ),
		" ^:",
		( if ( t_ Man( r ) ) then Sxt(Opr( t )) else "-none-      " ),
		" v:",
		( if ( t_ Sub( r ) ) then Sxt(Opr( t )) else "-none-      " ),
		" <:",
		( if ( t_ Gni( r ) ) then Sxt(Opr( t )) else "-none-      " ),
		" >:",
		( if ( t_ Sib( r ) ) then NoSp(Sxt(Opr( t ))) else "-none-" ),
		Crlf );

end "print trace";


simple Procedure C.List;
begin "list the record"

    if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi, 1, Text.Page ) )
     then begin "no text file"
	print( Text.File &" not found."& crlf );
	TxtSlot_ 0;			! disable use of text file ;
     end "no text file";

    Display( printEntry );

    VMFree( TxtSlot, CL!ACS lor CL!RST );
    TxtSlot_ 0;				! disable use of text file ;

end "list the record";


simple procedure C.Managed;
begin "display entry"
    own integer r, t;

    if length( Line )
     then begin "find name"

	if not( r_ FndName( Line, 0 ) )
	 then return;			! message already printed ;

	if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi, 1, Text.Page ) )
	 then begin "no text file"
	    print( Text.File &" not found."& crlf );
	    TxtSlot_ 0;			! disable use of text file ;
	 end "no text file";

	if ( t_ Sub( r ) )		! to manage, one must have children ;
	 then begin "ah children"

	    printEntry( t );		! list the first child ;
	    while ( t_ Sib( t ) )	! while any siblings are here ;
	     do printEntry( t );	! list them also ;

	 end "ah children"
	 else print( "%OPRNTM No one to manage for ",Sxt( Opr( r ) ),crlf );

	VMFree( TxtSlot, CL!ACS lor CL!RST );
	TxtSlot_ 0;			! disable use of text file ;

     end "find name"
     else begin "managed syntax error"

	print( "?OPRSYN Syntax error: opername required in command."&
		crlf&crlf );
	return;

     end "managed syntax error";

    print( Crlf );

end "display entry";


simple procedure E!Transfer( reference integer r );
begin "transfer entry"
    own integer M, v;

    if not( length( Line ) )
     then Line_ Prompt( "Manager name: " );

    if length( Line )
     then begin "find new manager"

	if not( M_ FndName( Line, (if SuperUser then 0 else MySelf) ) )
	 then return;			! ?OPRNNF message already printed ;

	if ( r = M )
	 then bomb( "?OPRCMS cannot transfer opername to self." );

	if not( Licens( M ) land L!MG )
	 then bomb( "?OPRMNR manager name required in transfer request." );

	v_ Man( r );			! Get old manager pointer ;
	if ( Sub( v ) = r )		! if this is first child ;
	 then ManSub( v )_ !xwd( Man( v ), Sib( r ) );
	if ( v_ Gni( r ) )		! fixup previous sibling (if any) ;
	 then GniSib( v )_ !xwd( Gni( v ), Sib( r ) );
	if ( v_ Sib( r ) )		! fixup next sibling (if any ) ;
	 then GniSib( v )_ !xwd( Gni( r ), Sib( v ) );
	GniSib( r )_ 0;			! forget my current siblings ;
	Subordinate( r, M );		! setup new manager and siblings ;

	print( Sxt( Opr( r ) )," ==> ", Sxt( Opr( M ) ),crlf );

     end "find new manager"
     else bomb( "?OPRSYN Syntax error: manager name required in command." );

end "transfer entry";


simple procedure C.Transfer;
itemize( L!MG, false, (if SuperUser then 0 else MySelf), E!Transfer,
	 "Opername to transfer: ",
	 "?OPRCTO cannot transfer opername" );


simple procedure E!Grant( reference integer r );
begin "grant to entry"
    own integer Lic, t, v, w;

    if not( length( Line ) )
     then Line_ Prompt( "License: " );

    if length( Line )
     then begin "check the license"

	if ( 0 > Lic_ LicRd( Line ) )
	 then bomb( "?OPRUNK Unknown license name." );

	if ( LCheck( MySelf, r, Lic ) )	! if a potential loop ;
	 then bomb( "?OPRCGL Cannot make license grant loop." );

	v_ MySelf;			! begin with self pointer ;
	while ( v_ Glk( w_ v ) )	! scan list, w = self or last ;
	 do;

	if ( Gix( t_ v_ Gft( r ) ) )	! we already have something ;
	 then begin "allocate new gift block"

	    while ( Gix( t ) neq MySelf )
	     do if not( t_ Rlk( v_ t ) )
		 then begin "out of gifts"

		    if ( t_ FndGwd )	! get gift block ;
		     then begin "new gift block"

			GlkRlk( v )_ !Xwd( Glk( v ), t );
			done;

		     end "new gift block"
		     else bomb( "?OPRNMR No more room for grant entries." );
		 end "out of gifts";

	 end "allocate new gift block";

	GdtRdt( t )_ Today land (-1 lsh 18);	! when ;

	if ( GlcRlc( t ) )			! what ;
	 then GlcRlc( t )_ LicOr( GlcRlc( t ), Lic )
	 else begin "new block"
	    GixRix( t )_ !Xwd( MySelf,r );	! grantor,receiver ;
	    GlcRlc( t )_ Lic;			! set license name ;
	    GlkRlk( w )_ !Xwd( t, Rlk( w ) );	! set link pointer ;
	 end "new block";

     end "check the license";

end "grant to entry";


simple procedure C.Grant;
itemize( L!LG, false, 0, E!Grant,
	 "Grant license to: ",
	 "?OPRCGL cannot grant license to" );


simple procedure E!Remove( reference integer r );
begin "remove from entry"
    integer Lic;

	if not( length( Line ) )
	 then Line_ Prompt( "License: " );

	if length( Line )
	 then begin "check the license"

	    if ( 0 > Lic_ LicRd( Line ) )
	     then bomb( "?OPRUNK Unknown license name." );

	    print( "Removing license grants:"& crlf );
	    LTake( Myself, r, Lic );	! take away the license ;

	 end "check the license";

end "remove from entry";


simple procedure C.Remove;
itemize( L!LG, false, 0, E!Remove,
	 "Remove license from: ",
	 "?OPRCRL cannot remove license from" );


simple Procedure C.Show;
Display( ShowEntry );


simple procedure E!Hold( reference integer r );
Licens( r )_ Licens( r ) lor L!Hold;


simple procedure E!Release( reference integer r );
Licens( r )_ Licens( r ) land lnot L!Hold;


simple procedure C.Hold;
itemize( L!MG, false, (if SuperUser then 0 else MySelf), E!Hold,
	 "Hold license on: ",
	 "?OPRCHL cannot hold license on" );


simple procedure C.Release;
itemize( L!MG, false, (if SuperUser then 0 else MySelf), E!Release,
	 "Release license hold on: ",
	 "?OPRCRH cannot release hold on" );


simple procedure E!Password( reference integer r );
begin
    integer Psc, Psw;
    string  Name;

    Psc_ TrialCount + 1;
    while ( PasHsh( PasGet( "New password: " ) )
	    neq Psw_ PasHsh( PasGet( "Enter password again: " ) ) )
     do if ( Psc_ Psc - Psc )
	 then print( "%OPRPSW Passwords do not match, try again."& crlf )
	 else bomb( "?OPRPSW Too many tries." );

    PswCph( r )_ Psw;			! set new password ;
    PswWho( r )_ OprNam( MySelf );	! leave trail, who changed it ;
    PswWh1( r )_ OprNa1( MySelf );
    PswDat( r )_ GetTDT;		! leave trail, date/time ;

end;

simple procedure C.Password;
itemize( L!MG, true, (if SuperUser then 0 else MySelf), E!Password,
	 "Opername to change: ",
	 "?OPRCCP cannot change password for" );


simple procedure E!Change( reference integer r );
begin
    Boolean EmpChange, Flag, LicSlf;
    Integer Cdx, Cen, Cmd, Dst, Id, Lic, Psc, Psw, TxtLen;
    String  Oper, Name, Payr, Tele, Addr, Mgmt, Dept, User, Mail, Whys;
    String  AnyComment, EmpTxt;

    Define All.Changes = {

    !C!!( ISCNumber, "  ISC Identification Information.",
	C$$PRV, [
	Id_   cvd( Prompt( "Employee ISC#:  " ) );
	Cen_ case ( Payr_ Prompt( "Payroll center (St.Louis, Irvine, Other): " ) )
	      of ( ["S"] 0, ["I"] 1, [else] 2 );
	ISCDst( r )_ (Id land '3777777) lor (Cen lsh 20) lor (Dst lsh 26);
	] )
    !C!!( OperName, "   Oper Name for this entry.",
	C$$PRV lor C$$EMP, [
	Oper_ Prompt( "New oper name:  " );
	OprNam( r )_ cvSIX( Oper[ 1 for 6 ] );
	OprNa1( r )_ cvSIX( Oper[ 7 for 6 ] );
	] )
    !C!!( Password, "   Oper password for this entry.",
	C$$SLF, [
	Psc_ TrialCount + 1;
	while ( PasHsh( PasGet( "Initial password: " ) )
		neq Psw_ PasHsh( PasGet( "Enter password again: " ) ) )
	 do if ( Psc_ Psc - Psc )
	     then print( "%OPRPSW Passwords do not match, try again."& crlf )
	     else bomb( "?OPRPSW Too many tries." );
	PswCph( r )_ Psw;
	] )
    !C!!( License, "    Capability license.",
	C$$PRV, [
	Lic_ LicEnt( Prompt( "Privileges (MG LG): " ) );
	Licens( r )_ Lic;
	] )
    !C!!( District, "   Marketing district number.",
	C$$MAN, [
	Dst_  cvd( Prompt( "Marketing Dist: " ) );
	] )
    !C!!( Employee, "   Employee name.",
	C$$PRV lor C$$EMP lor C$$CAS, [
	Name_ Prompt( "Employee Name:  " );
	] )
    !C!!( Telephone, "  Employee telephone number.",
	C$$SLF lor C$$EMP, [
	Tele_ Prompt( "Employee Phone #: " );
	] )
    !C!!( Address, "    Employee mail stop.",
	C$$SLF lor C$$EMP lor C$$CAS, [
	Addr_ Prompt( "Employee inter-office Mail stop: " );
	] )
    !C!!( Mailbox, "    Internet SMTP mailbox.",
	C$$SLF lor C$$EMP lor C$$CAS, [
	Mail_ Prompt( "SMTP internet mailbox: " );
	] )
    !C!!( Username, "   Username(s) used by employee.",
	C$$SLF lor C$$EMP, [
	User_ Prompt( "Username(s) used by employee: " );
	] )
    !C!!( Manager, ["    Employee manager name, telephone, mailbox."],
	C$$MAN lor C$$EMP lor C$$CAS, [
	Mgmt_ Prompt( "Supervisor (name, phone, mailstop): " );
	] )
    !C!!( Department, " Employee department.",
	C$$MAN lor C$$EMP lor C$$CAS, [
	Dept_ Prompt( "ISC Company & Department: " );
	] )
    !C!!( Why, "        Why license is needed.",
	C$$MAN lor C$$EMP lor C$$CAS, [
	Whys_ Prompt( "Why is license needed: " );
	] )
    !C!!( Help, "       Print this text.",
	0, [
	for Index_ 1 upto Len.Changes
	 do if ( Ok2See( LicSlf, ChgFlag[ Index ] ) )
	 then if not( ChgFlag[ Index ] land C$$Inv )
	       then print( "  ", ChgText[ Index ], Crlf )
	       else if ( Maintenance )
		     then print( " "&("$"+(ChgFlag[ Index ] lsh -35)),
				 ChgText[ Index ], Crlf );
	print( Crlf );
	] )

    };

    require crlf message;
    Redefine !C!!(Nam,Hlp,Flg,Cod) = {
    require
	ifcr length(cvps(flg))
	 thenc ("000000"&cvos(!lh(flg)))[inf-5 to inf-3] &
	       ("000000"&cvos(!lh(flg)))[inf to inf] &
	 elsec  "    " & endc " " &
    cvps(Nam) & Hlp &
    crlf message;
    };
    All.Changes
    require crlf message;

    Redefine Len.Changes = 0;
    Redefine !C!!(Nam,Hlp,Flg,Cod) = {
	Ifcr Len.Changes > 0 thenc , endc CvPS(Nam)
	Redefine Len.Changes = Len.Changes + 1;};
    Preset!with All.Changes;
    Own safe string array ChgName[1:Len.Changes];

    Redefine Len.Changes = 0;
    Redefine !C!!(Nam,Hlp,Flg,Cod) = {
	Ifcr Len.Changes > 0 thenc , endc
	Ifcr Length(CvPS(Flg)) thenc Flg elsec 0 endc
	Redefine Len.Changes = Len.Changes + 1;};
    Preset!with All.Changes;
    Own safe integer array ChgFlag[1:Len.Changes];

    Redefine Len.Changes = 0;
    Redefine !C!!(Nam,Hlp,Flg,Cod) = {
	Ifcr Len.Changes > 0 thenc , endc Cvps(Nam) & Hlp
	Redefine Len.Changes = Len.Changes + 1;};
    Preset!with All.Changes;
    Own safe string array ChgText[1:Len.Changes];

    Redefine !C!!(Nam,Hlp,Flg,Cod) = { begin Cod end; };


! *** Actual change code *** ;
! *** Get info on opername *** ;

    Payr_ (case ( ISCDst( r ) lsh -20 ) land '77
	    of ([0] "#",		! St. Louis Payroll ;
		[1] "I",		! Irvine Payroll ;
		[else] "?"));		! ? Payroll group ;
    Id_  ISCDst( r ) land '3777777;	! ISC Number ;
    Lic_ Licens( r );			! Privileges ;
    Dst_ ISCDst( r ) lsh -26;		! District ;

    Addr_ AnyComment_ Dept_ Name_ Mail_ Mgmt_ User_ Whys_ null;
    TxtLen_ 0;

    if ( EmpMsc( r ) )			! Validated? ;
     then begin "get more info"

	if ( 0 > TxtSlot_ VMFile( Text.File, VM$Read, 1, Text.Page ) )
	 then begin "no text file"
	    print( Text.File &" not found."& crlf );
	    TxtSlot_ 0;			! disable use of text file ;
	 end "no text file";

	if ( TxtSlot )			! if file open ;
	 then begin "text available"
	    TxtWait;			! wait for text file unlocked ;

	    VMSetC( TxtSlot, EmpMsc( r )+2 );	! setup for employee ;
	    Line_ VMLine( TxtSlot, Brk );	! Entry info ;
	    Oper_ Line[14 for 12];		! better match sxt ;
	    while ( length( Line_ VMLine( TxtSlot, Brk ) ) )
		 do case Token( Line )
		     of begin
			["A"]  Addr_ Line;
			["C"]  AnyComment_ AnyComment & Line & crlf;
			["D"]  Dept_ Line;
			["E"]  Name_ Line;
			["M"]  Mail_ Line;
			["S"]  Mgmt_ Line;
			["U"]  User_ Line;
			["W"]  Whys_ Line;
			[else] AnyComment_ AnyComment & Line & crlf
		    end;

	    TxtLen_ VMGetC( TxtSlot ) - EmpMsc( r ) - 2;
	    VMFree( TxtSlot, CL!ACS lor CL!RST );
	    TxtSlot_ 0;			! disable use of text file ;

	 end "text available";

      end "get more info";


! *** do stuff here with entry *** ;

    while true
     do begin "changes are coming"

	if not( length( Line ) )			! if no line ;
	  or not( length( Command_ Token( Line ) ) )	!  or blank, get one ;
	 then Command_ Token( Line_ Prompt( "Change: " ) );

	if not( length( Command ) )			! no response? ;
	 then done "changes are coming";		! ignore blank lines ;

	if kequ(Command, "?") then Command_ "HELP";	! "?" means "HELP";
	LicSlf_ Licens( MySelf );			! do this once ;

	Cdx_ 0;
	for Cmd_ 1 step 1 until Len.Changes
	 do if ( Ok2See( LicSlf, ChgFlag[ Cmd ] ) )
	     then if kequ( Command, ChgName[ Cmd ][1 for length(Command)] )
		   then if Cdx neq 0
			 then bomb( "Ambigious change."&crlf )
			 else Cdx_ Cmd;

	if 0 < Cdx leq Len.Changes
	 then begin "setup change defaults"

	    scan( Line, BrkWht, Brk );		! remove any whitespace;
	    if Line = "?"			! if first character is "?";
	     then bomb( ChgText[ Cdx ] );	! give an help message ;

	    Command_ ChgName[ Cdx ];		! copy name for later;
	    Flag_ ChgFlag[ Cdx ];

	    MessageText_ null;			! default message is null ;
	    if ( Flag land C$$CAS )		! case independant? ;
	     then TTYUP( false );		! no, allow lower case ;
	    Case Cdx-1 of begin All.Changes end; ! perform command ;
	    if ( Flag land C$$CAS )		! case independant? ;
	     then TTYUP( true );		! no, reset upper case ;
	    if ( Flag land C$$EMP )		! change in employee file ;
	     then EmpChange_ true;		! yes, remember it ;

	 end "setup change defaults"
	 else bomb( "?OPRINV Invalid change" );	! canned error message ;
     end "changes are coming";


! *** Here is where we actually make the changes *** ;

    if ( EmpChange )
     then begin "change in employee file"

	if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi, 1, Text.Page ) )
	 then begin "no text file"
	    print( Text.File &" not found."& crlf );
	    TxtSlot_ 0;			! disable use of text file ;
	    return;
	 end "no text file";

	EmpTxt_ ("            "& cvos( Today_ GetTDT ))[inf-11 to inf] &
		";" & Oper & crlf &
		"E "& Name & crlf &
		"A "& Tele & "; " & Addr & crlf &
		"U "& User & crlf &
		"M "& Mail & crlf &
		"S "& Mgmt & crlf &
		"D "& Dept & crlf &
		"W "& Whys & crlf &
		AnyComment;

	TxtLock;			! Lock the text file ;
	if ( length( EmpTxt ) > TxtLen )
	 then begin "need more"

	    Cmd_ EmpMsc( r );
	    for Cdx_ Cmd upto Cmd + TxtLen - 1
	     do VMSetB( TxtSlot, 0, Cdx );

	    Cmd_ VMGetC( TxtSlot, VM$Size );
	    while ( VMGetB( TxtSlot, Cmd ) = 0 )
	     do Cmd_ Cmd - 1;

	    VMSetC( TxtSlot, EmpMsc( r )_ Cmd );
	    VMText( TxtSlot, Crlf );	! make sure it's right ;

	 end "need more"
	 else begin "use less"

	    VMSetC( TxtSlot, EmpMsc( r ) + 2 );

	 end "use less";

	VMText( TxtSlot, EmpTxt );
	VMFree( TxtSlot );
	TxtUnlock;			! Unlock the text file ;
	TxtSlot_ 0;			! disable use of text file ;

     end "change in employee file";
end;

simple procedure C.Change;
itemize( L!MG, true, (if SuperUser then 0 else MySelf), E!Change,
	 "Opername to change: ",
	 "?OPRCCP cannot change opername" );

simple procedure writeEntry( integer r );
begin
    own safe integer array Days[0:3];
    own integer base;
    own string  name;

    if ( Licens( r ) land L!Hold )	! if entry is on hold ;
     then return;			!  don't write it ;

    if ( '777 = ( Written_ Written + 1 ) land '777 )
     then Written_ Written + 1;		! last place?  skip to next page ;
    print( sxt( opr( r ) ), cvos( Written ), crlf );

    VMGetW( DmpSlot, Written );		! pull in the right page ;
    base_ ( Dump.Page lsh 9 ) + ( Written land '777 );

    OprHsh( memory[ base ], name_ Sxt( Opr( r ) ) );
    memory[ base+2 ]_ PswCph( r );
    memory[ base+3 ]_ AllLic( r ) land lnot ( L!HOLD lor L!SU lor L!LG );

    Days[0]_ PswDat( r );		! set GMT time ;
    Days[2]_ !xwd( '500020, '000020 );	! convert to dec-date ;
    Calli( location( Days[0] ), calli!DATUUO );
    memory[ base+4 ]_ Days[0] lsh 8 + ( ISCDst( r ) lsh -26 );
    OprHsh( memory[ base+5 ], name_ Sxt( Opr( Man( r ) ) ) );

    VMGetW( DmpSlot, Written_ Written + 6 );

end;

simple procedure C.Write;
begin
    integer r;

    if not( length( Filename_ Line ) )
     then Filename_ "DRWSPR.EPO";

    if ( 0 > DmpSlot_ VMFile( Filename, VM$Write, 1, Dump.Page) )
     then begin
	print( "?OPRCEF Cannot enter ",Filename,"."& Crlf );
	return;
     end;

    Written_ -1;			! note: nothing written ;
    Level_ r_ 0;			! start at the top ;

    while ( r_ traverse( r ) )		! process each entry ;
     do writeEntry( r );

    VMFree( DmpSlot );

end;


simple procedure DumpGrant( reference integer g );
begin "dump grants"

    VMText( DmpSlot,
	    Sxt( Opr( Gix( g ) ) )      & lpad( cvos( Gix( g ) ), 6 ) &
	    Sxt( Opr( Rix( g ) ) )      & lpad( cvos( Rix( g ) ), 6 ) &
	    lpad( cvos( Gdt( g ) ), 6 ) & lpad( cvos( Rdt( g ) ), 6 ) &
	    lpad( cvos( Glc( g ) ), 6 ) & lpad( cvos( Rlc( g ) ), 6 ) &
	    crlf );

end "dump grants";



simple procedure DumpEntry( reference integer r );
begin "dump entry"
    integer t;

    VMText( DmpSlot,
	    lpad( cvs( Level ), 2) &
	    Sxt( Opr( r ) ) &
	    lpad( cvos( r ), 6 ) &
	    (case ( t_ ( ISCDst( r ) lsh -20 ) land '77 )
	      of ([0] "#",		! St. Louis Payroll ;
		  [1] "I",		! Irvine Payroll ;
		  [else] "?")) &	! ? Payroll group ;
	    lpad( cvs( ISCDst( r ) land '3777777 ),6 ) &
	    lpad( cvs( ISCDst( r ) lsh -26 ), 4 ) &
	    lpad( cvos( PswCph( r ) ), 12 ) &
	    lpad( cvos( PswDat( r ) ), 12 ) &
	    Sxt( Chg( r ) ) &
	    lpad( cvos(!lh(Licens(r))),6 ) &
	    lpad( cvos(!rh(Licens(r))),6 ) &
	    lpad( cvos( Man( r ) ),6 ) &
	    lpad( cvos( Sub( r ) ),6 ) &
	    lpad( cvs( EmpMsc( r ) ), 8 ) &
	    crlf );

end "dump entry";


simple procedure C.Dump;
begin
    integer r, t, v;

    if not( length( Filename_ Line ) )
     then Filename_ Dump.File;

    if ( 0 > DmpSlot_ VMFile( Filename, VM$Write, 1, Dump.Page) )
     then begin
	print( "?OPRCEF Cannot enter ",Filename,"."& Crlf );
	return;
     end;

    Level_ 0;				! start at the top ;
    dumpEntry( r_ 0 );

    while ( r_ traverse( r ) )		! process each entry ;
     do dumpEntry( r );

    VMText( DmpSlot, crlf );		! separate lists ;

    while ( t_ r_ traverse( r ) )	! note: r is reset to 0 ;
     do while ( t_ Rlk( t ) )		! if any grants here ;
	 do dumpGrant( t );		!  dump them ;

    VMFree( DmpSlot );

end;


simple procedure E!Cancel( reference integer r );
begin "cancel entry"
    integer lic, t, v;

	while ( t_ Sub( r ) )
	 do begin "transfer subordinates"
  
	    if ( t = Sub( r ) )		! if this is first child ;
	     then ManSub( r )_ !xwd( Man( r ), Sib( t ) );

	    if ( v_ Gni( t ) )		! fixup previous sibling (if any) ;
	     then GniSib( v )_ !xwd( Gni( v ), Sib( t ) );
	    if ( v_ Sib( t ) )		! fixup next sibling (if any ) ;
	     then GniSib( v )_ !xwd( Gni( t ), Sib( v ) );

	    GniSib( t )_ 0;		! forget my current siblings ;
	    Subordinate( t, Man( r ) );	! setup new manager and siblings ;

	    print( "  ", Sxt( Opr( t ) )," transferred to ",
			 NoSp( Sxt( Opr( Man( r ) ) ) ),crlf );

	 end "transfer subordinates";

	if ( r = Sub( t_ Man( r ) ) )	! unlink r from his manager ;
	 then if ( v_ Sub( ManSub( t )_ !xwd( Man( t ), Sib( r ) ) ) )
	       then GniSib( v )_ Sib( v )
	       else
	 else begin "remove child"
	    t_ Gni( r );		! or unlink r from his siblings ;
	    GniSib( t )_ !xwd( Gni( t ), v_ Sib( r ) );
	    GniSib( v )_ !xwd( t, GniSib( v ) );
	 end "remove child";
	
	Lic_ AllLic( r );		! save my total license ;
	
	print( "Removing license grants"& crlf );
	t_ r;				! copy for loop ;
	while ( t_ Grt( t ) )		! for any license grants ;
	 do LTake( r, Rix( t ), Lic );	! take away the license ;

	t_ r;				! copy for loop ;
	while ( t_ Gft( t ) )		! take away any license gifts ;
	 do LTake( v_ Gix( t ), r, GlcRlc( t ) );

	ManSub( r )_ 0;			! clear out the entry ;
	arrBlt( GniSib( r ), ManSub( r ), '17 );

	t_ BitPtr(r lsh -2)+vmi+I!Sat;	! get pointer into bitmap ;
	for v_ 1 upto 4			!  and free both the ;
	 do idpb( 0, t );		!  entry and gift blocks ;

end "cancel entry";


simple procedure C.Cancel;
itemize( L!SU, false, 0, E!Cancel,
	 "Cancel opername: ",
	 "?OPRCCO cannot cancel" );


simple procedure E!Add( boolean Mailing );
begin "Add opername"
    string Oper, Whom, Name, Payr, Tele, Mail, User, Addr;
    string Mgmt, Dept, Whys, AnyComment;
    integer Id, Cen, Dst, Psc, Psw, Lic, r, M, Code;

    if not( length( Oper_ TokNam( Line ) ) )
     then Oper_ Prompt( "New oper name:  " );

    if not( length( Oper ) )
     then return;

    Oper_ ( Oper &"            " )[1 for 12];

    r_ 0;
    while ( r _ traverse( r ) )
     do if ( kequ( Sxt( Opr( r ) ), Oper ) )
	 then bomb( "?OPRNAM Opername already exists." );

    if ( BatchMode )
     then Psw_ cvo( Prompt( "Password Hash: " ) )
     else begin "password prompt"
	Psc_ TrialCount + 1;
	while ( PasHsh( PasGet( "Initial password: " ) )
		neq Psw_ PasHsh( PasGet( "Enter password again: " ) ) )
	 do if ( Psc_ Psc - Psc )
	     then print( "%OPRPSW Passwords do not match, try again."& crlf )
	     else bomb( "?OPRPSW Too many tries." );
     end "password prompt";

    Lic_ LicEnt( Prompt( "Privileges (MG LG): " ) );

    Whom_ (Prompt( "Oper manager:   " )&"            ")[1 for 12];

    if not( M_ FndName( Whom, 0 ) )	! OPRNNF already printed ;
     then return;

    TTYUP( False );			! allow lower case input ;
    Dst_  cvd( Prompt( "Marketing Dist: " ) );
    Name_ Prompt( "Employee Name:  " );

    TTYUP( True );
    Id_   cvd( Prompt( "Employee ISC#:  " ) );
    Cen_ case ( Payr_ Prompt( "Payroll center (St.Louis, Irvine, Other): " ) )
	  of ( ["S"] 0, ["I"] 1, [else] 2 );
    TTYUP( False );

    Tele_ Prompt( "Employee Phone #: " );
    Addr_ Prompt( "Employee inter-office Mail stop: " );
    Mgmt_ Prompt( "Supervisor (name, phone, mailstop): " );
    Dept_ Prompt( "ISC Company & Department: " );
    User_ Prompt( "Username(s) used by employee: " );
    Mail_ Prompt( "SMTP internet mailbox: " );
    Whys_ Prompt( "Why is license needed: " );

    AnyComment_ null;
    while length( NoSp( Line_ Prompt( "Comment: " ) ) )
     do AnyComment_ AnyComment & "C " & Line & crlf;
    TTYUP( True );			! revert back to upper case ;


    if ( Mailing )
     then begin "send mail"
	FrmRun(
	    MailerName,
	    F.CCL lor F.NTTY lor F.NWAI lor F.NEOL,
	    Code,
	    "MAI",
	    "From:  " & cv6str( Gettab( -1,!gtUNM ) ) &
			cv6str( Gettab( -1,!gtUN1 ) ) &
		"@"  & cvstr( Gettab( 0,!gtCNF ) )[1 for 1] &
			cvs( Gettab( !cnSYS,!gtCNF ) ) & ".Tymnet" & crlf &
		"To:  "& SystemValidations & crlf &
		"Subject:  SETOP User Request  at  "&
			TymDay( GetTDT ) & crlf &
		crlf &
		"Oper:  "& Oper & " manager: " & Sxt( Opr( M ) ) & crlf &
		"Password hash: "& cvos( Psw ) & crlf &
		"Privileges:    "& (if Lic then LicPrt( Lic )
					   else "-none-") & crlf &
		"Mktg District: "& cvs( Dst ) & crlf &
		"Name:  "& Name & crlf &
		"ISC Id#"& ("     "& cvs( Id ))[inf-5 to inf] &
		    " center: " & (case Cen of ([0] "St.Louis",
						[1] "Irvine",
						[else] "Other" ) ) & crlf &
		"Phone: "& Tele & "; Mailstop: " & Addr & crlf &
		"User:  "& User & crlf &
		"Mail:  "& Mail & crlf &
		"Supv:  "& Mgmt & crlf &
		"Dept:  "& Dept & crlf &
		"Why:   "& Whys & crlf &
		(if length( AnyComment ) then crlf &"Comments:"& crlf
					 else null) &
		AnyComment & crlf &
		crlf & #EOT
	    );
     end "send mail"
     else begin "add to file"
	if not( r_ FndEwd )
	 then bomb( "?OPRNMR No more room for additional entries." );

	BinLock;			! lock binary file ;
	GixRix( GlkRlk( r )_ r+12 )_ r;	! setup pointers for gift ;
	OprNam( r )_ cvSIX( Oper[ 1 for 6 ] );
	OprNa1( r )_ cvSIX( Oper[ 7 for 6 ] );
	Subordinate( r, M );
	ISCDst( r )_ (Id land '3777777) lor (Cen lsh 20) lor (Dst lsh 26);
	PswCph( r )_ Psw;
	Licens( r )_ Lic;
	BinUnLock;			! unlock binary file ;

	if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi lor VM$Append, 1, Text.Page ) )
	 then begin "no text file"
	    TxtSlot_ 0;			! disable use of text file ;
	    bomb( Text.File &" not found."& crlf );
	 end "no text file";

	TxtLock;			! lock the text file ;
	VMText( TxtSlot, Crlf );	! make sure it's right ;
	EmpMsc( r )_ VMGetC( TxtSlot ) - 2;
	VMText( TxtSlot,
		("            "& cvos( Today_ GetTDT ))[inf-11 to inf] &
		";" & Oper & crlf &
		"E "& Name & crlf &
		"A "& Tele & "; " & Addr & crlf &
		"U "& User & crlf &
		"M "& Mail & crlf &
		"S "& Mgmt & crlf &
		"D "& Dept & crlf &
		"W "& Whys & crlf &
		AnyComment
	    );

	VMFree( TxtSlot );
	TxtUnlock;			! Unlock the text file ;
	TxtSlot_ 0;			! disable use of text file ;

     end "add to file";

end "Add opername";


simple procedure C.Add;
E!Add( False );


simple procedure C.Request;
begin "request information"

    print( "[OPRREQ Request is used to request NEW opernames only]"& crlf );
    print( "[OPRREQ Please MAIL ""all"" other requests to REQUESTOP]"& crlf );
    E!Add( True );			! use ADD code, but for mail ;

end "request information";


simple procedure C.Batch;
print( ( case ( BatchMode_ (BatchMode * -1) + 1 )
	  of ( "Normal", "Batch" ) ),
	" entry mode."& crlf );


simple procedure C.Debug;
if ( memory[ !jbddt ] )
 then quick!code
	push	'17,'1;
	hrrz	'1,!jbddt;
	pushj	'17,@'1;
	pop	'17,'1;
 end
 else MessageText_ "?OPRPRV DDT not loaded.";


simple procedure C.Who;
print( "[OPRWHO Opername: ", NoSp( Sxt( Opr( InitialSelf ) ) ),
	(if MySelf neq InitialSelf
	  then " imitating "& NoSp( Sxt( Opr( MySelf ) ) )
	  else null),
	"]"& crlf&crlf );

simple procedure C.Statistic;
Display( EntryStatus );

simple Procedure C.Trace;
Display( printTrace );



simple procedure C.Index;
begin
    integer r, t;
    string ThisName;

    BinLock;

    print( "Clearing data..." );
    r_ 0;
    while ( t_ r_ traverse( r ) )
     do EmpMsc( r )_ 0;
    print( "done."&crlf );

    if ( 0 > TxtSlot_ VMFile( Text.File, VM$Multi, 1, Text.Page ) )
     then begin "no text file"
	print( Text.File &" not found."& crlf );
	TxtSlot_ 0;			! disable use of text file ;
	BinUnLock;
	return;
     end "no text file";

    Line_ VMLine( TxtSlot, Brk );	! Entry info ;
    do begin "each text entry"

	t_ VMGetC( TxtSlot );
	Line_ VMLine( TxtSlot, Brk );	! Entry info ;
	ThisName_ Line[14 for 12];

	r_ 0;
	while ( r_ traverse( r ) )
	 do if ( kequ( ThisName, Sxt( Opr( r ) ) ) )
	     then done;

	print( crlf, ThisName, " " );
	if ( r )
	 then print( cvos( EmpMsc( r )_ t - 2 ) )
	 else print( "- No oper record" );

	while ( length( Line_ VMLine( TxtSlot, Brk ) ) )
	 do;
     end "each text entry" until Brk = 0;
    print( crlf );

    VMFree( TxtSlot, CL!ACS lor CL!RST );
    TxtSlot_ 0;				! disable use of text file ;

    BinUnLock;
    ! while ( t_ Rlk( t ) ) do;
    MessageText_ "Nothing happens.";
end;


simple procedure C.XYZZY;
MessageText_ if ( Maintenance_ (Maintenance + 1) mod 2 )
	      then MaintenanceMessage
	      else "Nothing happens.";

simple procedure C.Futz;
begin
    integer r, t;

    r_ 0;
    while ( t_ r_ traverse( r ) )
     do while ( t_ Rlk( t ) )
	 do;
    MessageText_ "Nothing happens.";
end;

simple procedure C.Brief;
Verbose_ false;

simple procedure C.Verbose;
Verbose_ true;


simple Procedure C.Unlock;
begin TxtUnlock; BinUnlock end;


simple Procedure C.Help;
begin
    integer licslf;
    licslf_ Licens( MySelf );
    print(  Crlf,  "License manager ",
	    !VERSN, Crlf,
	    "Commands:", Crlf );
    for Index_ 1 upto Len.Commands
     do if ( Ok2See( LicSlf, CmdFlag[ Index ] ) )
	 then if not( CmdFlag[ Index ] land C$$Inv )
	       then print( "  ", CmdText[ Index ], Crlf )
	       else if ( Maintenance )
		     then print( " "&("$"+(CmdFlag[ Index ] lsh -35)),
				 CmdText[ Index ], Crlf );
    print( Crlf );
end;


simple Procedure C.HelpMe;
begin
    print( crlf &"Please type HELP for help"& crlf );
end;


ifcr false
 thenc

simple procedure C.FixupTexts;		! requires patch VM$Multi in C.Open ;
begin "futz"
    integer r, Brk, More, NewText, OldText, Count;
    string Line;

    if ( 0 > OldText_ VMFile( Text.File, VM$Read, 1, Text.Page-1 ) )
     then begin
	MessageText_ "?OPRFUK Cannot find "& Text.File;
	return;
     end;
    if ( 0 > NewText_ VMFile( Text.File, VM$Write, 1, Text.Page-2 ) )
     then begin
	MessageText_ "?OPRFUK Cannot enter "& Text.File;
	return;
     end;

    VMSetC( NewText, 0 );			! start at the beginning ;
    Print( Sxt( Opr( r ) ), EmpMsc( r ), "	" );
    VMSetC( OldText, EmpMsc( r ) + 2 );		! position past crlf ;
    VMLine( OldText, Brk );			! skip isc #, dist ;
    print( EmpMsc( r )_ VMGetC( NewText ), crlf );
    VMText( NewText, Crlf );			! write blank line ;
    while ( length( Line_ VMLine( OldText, Brk ) ) )
     do VMText( NewText, Line & Crlf );		! write remainder ;

    while r_ traverse( r )
     do begin "operate"
	if ( ISCDst( r ) land '3777777 )
	 then begin "write new employee info"
	    Print( Sxt( Opr( r ) ), EmpMsc( r ), "	" );
	    VMSetC( OldText, EmpMsc( r ) + 2 );		! position past crlf ;
	    VMLine( OldText, Brk );			! skip isc #, dist ;
	    print( EmpMsc( r )_ VMGetC( NewText ), crlf );
	    VMText( NewText, Crlf );			! write blank line ;
	    while ( length( Line_ VMLine( OldText, Brk ) ) )
	     do VMText( NewText, Line & Crlf );		! write remainder ;
	 end "write new employee info"
	 else EmpMsc( r )_ 0;
	Count_ Count + 1;
     end "operate";

    VMFree( OldText );
    VMFree( NewText );
    print( "Processed ", Count, " entries."& crlf );

end "futz";

endc
Simple string procedure Perform!Command;
! ----------------------------------------------------------------------;
!									;
!    Perform!Command	This is the CRUX of the main program.  This	;
!			routine reads the user's command line and then	;
!			dispatches to the proper routine to perform	;
!			the specified command.  Initial data requests	;
!			for each command are also read and verified	;
!			by this routine before further processing is	;
!			allowed.					;
!									;
! ----------------------------------------------------------------------;
begin "perform command"
    Integer Cmd, Cdx, C, P, LicSlf;

    LockWait_ -1;				! Reset lock counter ;
    Line_ inchwl;				! Get a command;
    Command_ Token( Line );			! Get the first word;
    if Length( Command ) = 0			! Ignore blank lines;
     then return( Null );

    if kequ(Command, "?") then Command_ "HELP";	! "?" means "HELP";
    LicSlf_ Licens( MySelf );			! do this once ;

    Cdx _ 0;
    for Cmd _ 1 step 1 until Len.Commands
     do if ( Ok2See( LicSlf, CmdFlag[ Cmd ] ) )
	 then if kequ( Command, CmdName[ Cmd ][1 for length(Command)] )
	       then if Cdx neq 0
		     then return( "Ambigious command." )
		     else Cdx _ Cmd;

    Today_ GetTDT;				! get current date-time ;
    if 0 < Cdx leq Len.Commands
     then begin "setup command defaults"

	scan( Line, BrkWht, Brk );		! remove any whitespace;
	if Line = "?"				! if first character is "?";
	 then return( CmdText[ Cdx ] );		! give an help message ;

	Command_ CmdName[ Cdx ];		! copy name for later;

	MessageText_ null;			! default message is null ;
	Case Cdx-1 of begin All.Commands end;	! perform command ;
	return( MessageText );			! return null or message ;

     end "setup command defaults"
     else return( "?OPRINV Invalid command" );	! canned error message ;

end "perform command";


TTYUP( True );
Print(  Crlf, "License manager ", !VERSN, Crlf );

VMValF_ false;				! try to speed up i/o ;
SuperUser_ false;			! initially we are human ;
InitialSelf_ MySelf_ 0;			!   and have no identity ;
MyLock_ calli( !xwd(-1,!gtUID), calli!GETTAB );
BinLevel_ TxtLevel_ 0;			! zero lock levels ;

C.Brief;				! use short messages ;

C.Open;					! read in the data ;
RootNode_ FndName( RootHead, 0 );	! remember root pointer ('20) ;
InitialSelf_ MySelf;			! remember who we once were ;

while TRUE
 do begin
    String More;
    print( "SETOP> " );			! prompt ;
    print( More_ Perform!Command );	! get : execute command ;
    if length( More )			! if anything to say ;
     then print( Crlf );		!  then say it ;
 end;

end "SETOP SYSTEMS";
  >&f=