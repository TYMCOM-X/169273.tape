TITLE	LGNSCN - SWITCH.INI scanner for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV
	LGNDCL

LGNSCN::
repeat 0,<
	MOVEI	T1,[ASCIZ /LOGIN/]
	MOVEM	T1,HELP
	MOVE	T1,[XWD 6,SCIBLK]
	PUSHJ	P,.ISCAN##	;CALL SCAN TO GET COMMAND
	MOVE	P1,T1		;SAVE COMMAND VALUE
	SKIPN	SAOFST		;CCL RUN?
	SKIPE	.JBDDT##	;IS DDT LOADED?
	JRST	LGIN2B		;YES--LET IT GO
	MOVN	T1,THSJOB	;MAKE NEGATIVE
	JOBSTS	T1,		;READ JOB STATUS
	  JRST	LOGIN2		;ASSUME OK IF NO JOB STATUS
	TXNE	T1,JB.UJC	;IF JACCT IS CLEAR THERE IS NO HARM TRYING
	TXNN	T1,JB.ULI	;IF JACCT IS SET JLOG MUST BE CLEAR
	JRST	LOGIN2		;OK--EITHER NO PRIVS OR LOGGED OUT
	FATAL	KOD,<Please KJOB or DETACH>,EF.SIL
LOGIN2:	TXNE	T1,JB.UJC	;[541] JACCT?
	  JRST	LGIN2A		;[541] YES
	WARN	IDJ,<I do not have JACCT>
LGIN2B:	TRO	F,R.DBUG	;[626] SET DEBUG FLAG; WE'RE BEING DEBUGGED
LGIN2A:	JUMPLE	P1,LOGDIS	;IF R, RUN, OR  LOGIN COMMAND

	SUBTTL	Type first message, check states bits


LOGDIS:
NOJBMS:	MOVE	T3,TTBITS
	MOVE	T2,STATES	;GET STATES WORD
	TXNN	T3,GL.ITY	;[605] PTY?
	  JRST	TTYGO		;[605] NO: NO SPECIAL CHECKS THEN

	TRO	F,R.PTYJ	;MARK AS A PTY JOB
	TLNE	F,FL.BAT	;Is this a Batch job ?
	JRST	TTYGO		;[605] TRUST BATCON AND SKIP CHECKS

;[605] HERE IF NON-BATCH PTY JOB TO CHECK SUPERIOR JOBS

NOTBAT:	PUSHJ	P,FNDCTL	;FIND CONTROLLING JOB NUMBER
	 JRST	TTYDET		;CAN'T
	  JRST	BJSJ		;BATCH JOB SUBJOB
	MOVEM	T2,CNTLJP	;SAVE CONTROLLER'S PPN
	HRLZ	T1,T3		;T1=SIXBIT LINE NUMBER
	CAME	T3,[SIXBIT/CTY/]	;[660] SKIP IF ATTACHED CTY
	CAMN	T3,SAVOPR	;IS IT THE OPR?
	TLO	F,L.SOPR	;FLAG SUBJOB OF OPR.
	SETZ	T3,
	MOVE	T4,[POINT 6,T1]
	JUMPN	T1,ISPTY1	;JUMP IF NOT CTY
	MOVX	T3,%CNPTY
	GETTAB	T3,
	  SETO	T3,
	HLRES	T3		;T3=OFFSET FOR FIRST PTY
	SUBI	T3,1		;-1=LINE NUMBER OF CTY
	JUMPGE	T3,ISPTY2	;JUMP IF HAVE CTY LINE NUMBER
	MOVX	T3,GL.CTY	;NO, FAKE TTBITS
	JRST	ISPTY3		;WE KNOW ITS THE CTY

ISPTY1:	ILDB	WD,T4
	JUMPE	WD,ISPTY2	;JUMP IF NO MORE CHARS
	LSH	T3,3
	ADDI	T3,-20(WD)
	JRST	ISPTY1

TTYDET:	SKIPA	T3,[GL.REM+GL.DSL]	;MAKE HIM NON-LOCAL

ISPTY2:	GETLCH	T3		;GET LINE BITS FOR CONTROL JOB TTY
ISPTY3:	MOVEM	T3,CNTLJT	;SAVE LINE BITS FOR CONTROL JOB TTY
	JRST	TTYGO		;GO DO THE ACCOUNTING

BJSJ:	TLO	F,FL.BSJ	;REMEMBER WE'RE A BATCH JOB SUBJOB
	MOVEM	T2,CNTLJP	;CONTROLLING PPN=PPN OF BATCH JOB
	MOVX	T3,GL.REM	;PRETEND REMOTE
	MOVEM	T3,CNTLJT	;SAVE FAKE TTY BITS
	JRST	TTYGO		;GO DO CHECKING
;ROUTINE TO FIND JOB'S ULTIMATE CONTROLLER FOR PURPOSES OF ACCESS CHECKING
;STOP SCANNING IF REACH: [1,2] JOB, TOP LEVEL JOB, DETACHED JOB, OR BATCH JOB
;CALL:	PUSHJ	P,FNDCTL
;	 CPOPJ IF CAN'T FIND JOB (ASSUME WE'RE DETACHED)
;	  CPOPJ1 IF BATCH JOB SUBJOB (ASSUME REMOTE)
;	    CPOPJ2 WITH AC'S SET UP AS FOLLOWS:
;		T1=CONTROLLING JOB NUMBER
;		T2=CONTROLLING JOB'S PPN
;		T3=CONTROLLING JOB'S PHYSICAL TTY NAME
FNDCTL:	SETO	T1,		;FIRST, GET IMMEDIATE CONTROLLING JOB
	CTLJOB	T1,		;..
	  JRST	CPOPJ		;ASSUME WE'VE BECOME DETACHED
	JUMPL	T1,CPOPJ	;DITTO

FNDCT1:	HRLZ	T3,T1		;GET THIS JOB'S TTY DDB ADDRESS
	HRRI	T3,.GTTTY	;..
	GETTAB	T3,		;..
	  JRST	CPOPJ
	PEEK	T3,		;GET PHYSICAL TTY NAME
				;[660] REMOVED 3 INSTRUCTIONS
	PUSH	P,T1		;SAVE T1
	MOVE	T1,T2		;SAVE LAST PPN IN CASE SON-OF-OPR
	HRLZ	T2,(P)		;GET THIS JOB'S PPN (JOB # ON STACK)
	HRRI	T2,.GTPPN	;..
	GETTAB	T2,
	  SETZ	T2,
	CAMN	T2,ALPPPN	;HAVE WE HIT A [1,2] JOB YET?
	  JRST	SONOPR		;YES: WE'RE SON-OF-OPR
	HRRZ	T1,(P)		;GET JOB NO. BACK AGAIN
	PUSHJ	P,ISBATC	;IS THIS JOB A BATCH JOB?
	  JRST	NOTBSJ
	POP	P,T1		;FIX UP STACK
	JRST	CPOPJ1		;WE'RE A BATCH JOB SUBJOB

NOTBSJ:	MOVE	T1,(P)		;RESTORE T1 FOR A BIT
	CTLJOB	T1,		;ANOTHER LEVEL?
	  JRST	TPOPJ		;[670] RESTORE T1 AND RETURN
	AOJE	T1,TOPLVL	;IF T1=-1 WE'VE HIT TOP LEVEL
	TLO	F,L.MANY	;FLAG MORE THAN ONE SUPERIOR
	POP	P,T3		;[704] ADJUST STACK
	SOJA	T1,FNDCT1	;[704] GO THRU NEXT LEVEL


SONOPR:	TLO	F,L.SOPR	;REMEMBER WE'RE SPAWN OF OPR
	MOVE	T2,T1		;USE LAST NON-[1,2] PPN AS CONTROLLER
	TLNN	F,L.MANY	;UNLESS [1,2] IS IMMEDIATE CONTROLLER
	  MOVE	T2,ALPPPN	;IN WHICH CASE USE [1,2]
TOPLVL:	POP	P,T1		;JOB # WE WANT IS ON STACK
  >  ;end of repeat 0
CPOPJ2:	AOS	(P)
CPOPJ1:	AOSA	(P)		;[670]
TPOPJ:	POP	P,T1		;[670] RESTORE T1
CPOPJ:	POPJ	P,
;ENTER HERE WITH	T3=TTBITS FOR TTY OR CONTROL JOB TTY

TTYGO:	MOVE	T2,STATES	;GET STATES BITS
	TLNE	F,L.OPR!L.SOPR	;OPER OR HIS SUB?
	TLNE	F,FL.BAT	;[700]  AND NON-BATCH JOB?
	SKIPA			;[700]  NO--CONTINUE
	JRST	PPNGO		;[1101] YES. OK TO GO
	TXNN	T2,ST%NLG	;NO LOGIN?
	JRST	SYSAVL		;NO--SYSTEM IS AVAIL
	STOP	SNA,<System not available>
SYSAVL:	TXNE	T3,GL.DSL!GL.REM	;NON-LOCAL?
	TXNN	T2,ST%NRL	;AND STATES SAYS LOCAL ONLY?
	JRST	NOTRMT		;NO. OK
	REQUE	NRU,<No remote users; Try again later>
NOTRMT:
NT2MNY:	TLNE	F,FL.BAT	;BATCH JOB?
	JRST	PPNGO		;YES, GO CHECK JOBMAX
	TXNN	T2,ST%BON	;NO. BATCH ONLY ONES ALLOWED?
	JRST	PPNGO		;NO
	FATAL	OBU,<Only batch users may LOGIN>

PPNGO:	MOVX	T1,%NSKTM	;FIND OUT IF SYSTEM IS DOWN
	GETTAB	T1,
	  SETZ	T1,
	JUMPE	T1,PPNGO1	;OK TO GO
	JUMPG	T1,PPNGO3	;JUMP IF SYSTEM GOING DOWN SOON
	TLNN	F,L.OPR!L.SOPR	;[606] IF OPR OR SUB OF OPR OR 1,2
	 TXNN	T3,GL.REM!GL.DSL	;[657] OR LOCAL TTY
	  JRST	PPNGO1		;[606] THEN LET HIM IN ANYWAY
	STOP	TIO,<Timesharing is over>
PPNGO3:	CAIL	T1,^D24*^D60	;OVER A DAY TO GO?
	JRST	PPNGO1		;YES--SKIP WARNING
	INFO	TCI,<Timesharing will cease in >,,E.TCI
	JRST	PPNGO1

E.TCI:	PUSH	P,T1		;SAVE MINUTES TILL KSYS
	IDIVI	T1,^D60
	MOVE	T4,T2		;SAVE REMAINDER (MINUTES)
	JUMPE	T1,E.TCI1	;SEE IF HOURS NONZERO
	PUSHJ	P,.TDECW##	;YES. PRINT HOURS
	MOVEI	T1,[ASCIZ/ hours /]
	PUSHJ	P,.TSTRG##
E.TCI1:	MOVE	T1,T4		;GET MINUTES
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ/ minutes at /]
	PUSHJ	P,.TSTRG##	;TYPE
	MSTIME	T1,		;GET NOW
	IDIVI	T1,^D60*^D1000	;MAKE MINUTES
	POP	P,T2		;RESTORE KSYS TIMER
	ADD	T1,T2		;COMBINE
	CAILE	T1,^D24*^D60	;WRAP AROUND?
	 SUBI	T1,^D24*^D60	;YES--FIX UP
	IMULI	T1,^D60*^D1000	;BACK INTO MILLISECONDS FOR SCAN
	PJRST	.TTIME##	;TYPE AND RETURN

;HERE TO BEGIN CHECKING PPN
;HERE TO COMPUTE BIT IN TIMES WORD TO CHECK

PPNGO1:	MOVE	T1,STATES	;[354] GET STATES WORD
	TXNN	T1,ST%NOP	;[354] IS THERE AN OPERATOR?
	JRST	LOGIN3		;[354,360] YES -- PROCEED
	INFO	NOC,<No operator coverage>

LOGIN3:	MOVE	P,PDPLST	;[565] RE-INIT STACK
	TLZ	F,FL.WKD+FL.RAS	;TRY AGAIN ENTRY
	PUSHJ	P,.GTNOW##	;GO GET TODAYS DATE
	HLRZ	T1,T1		;SAVE THE DAY
	IDIVI	T1,7		;FIGURE OUT THE DAY
	CAIL	T2,3		;[316] SATURDAY??
	CAILE	T2,4		;[316]  OR SUNDAY??
	TLO	F,FL.WKD	;NO--FLAG AS WEEKDAY
	MOVEM	T2,SAVEDA	;SALT AWAY
	MSTIME	T1,
	IDIV	T1,[EXP ^D1000*^D60*^D60]
	MOVSI	T2,400000	;MAKE A BIT FOR THE CURRENT HOUR
	TLNN	F,FL.WKD	;WEEKDAY?
	MOVEI	T2,4000		;NO. USE LOW 12 BITS
	TLNN	F,FL.WKD	;WEEKDAY?
	ASH	T1,-1		;NO. USE TWO-HOUR SHIFTS
	MOVNS	T1
	LSH	T2,0(T1)	;PUT BIT IN TUNE WITH TIME
	MOVEM	T2,NOWBIT	;SAVE.

	PUSHJ	P,PARSE##	;GO PARSE LOGIN LINE
	CAME	PP,SYSPPN	;SYSPPN CAN ALWAYS LOGIN
	CAME	PP,MFDPPN	;BUT IF MFDPPN IS NOT SYSPPN,
	JRST	STACCT
	FATAL	MLB,<May not LOGIN as MFD PPN>,EF.FMT


	SUBTTL	SWITCH.INI handling

;SUBROUTINE TO BE CALLED WHEN READY TO READ SWITCH.INI OF THE USER.

SW.INI:	MOVE	T1,[XWD LOGBLN,LOGBLK]	;[442] POINTER TO SWITCH TABLE
	SETOM	INISCN		;[744] FLAG IN SWITCH.INI OSCAN
	PUSHJ	P,.OSCAN##	;[442] READ SWITCH.INI
	SETZM	INISCN		;[744] DONE WITH SWITCH.INI
	POPJ	P,		;[1101] RETURN

;SUBROUTINE TO PARSE THE LOGIN COMMAND LINE
;CALL WITH:
;	PUSHJ	P,PARSE
;	RETURN HERE IF OK
;
PARSE::	TLZ	F,FL.WLD	;[355]
	TRZ	F,R.EOL		;[604] CLEAR FLAGS WHICH NEED IT
	SETZM	Z.STRT		;INIT SOME SWITCHES TO 0
	MOVE	T1,[XWD Z.STRT,Z.STRT+1];SETUP BLT
	BLT	T1,Z.END-1	;CLEAR THEM OUT
	SETOM	OOBEG		;[355] CLEAR OUT SWITCH BLOCK
	MOVE	T1,[XWD OOBEG,OOBEG+1]	;[355]
	BLT	T1,OOMAX-1	;[355]
	MOVE	T1,[IOWD DVICES*2+1,DEVTAB] ;[470] INIT PTR TO DEV TABLE
	MOVEM	T1,DEVPTR	;[470] ..
	MOVE	T1,[LOGBLN,,LOGBLK]	;SETUP UP TO DO A PARTIAL
	PUSHJ	P,.PSCAN##	; SCAN.
	 PUSHJ	P,GIVNBR##	;GIVE NUMBER SIGN PROMPT IF NEEDED
	SETZB	PP,RDHED	;[451] THIS IS A GOOD IDEA
	;;
	JRST	.POPJ1		;[CARL]



;[470] SUBROUTINE TO STORE ARGS TO /ASSIGN:PHYS:LOG
;
ASSIGN:	TRZ	F,R.NXSW!R.EOL	;[627] CLEAR NEXT-SWITCH-SEEN FLAG AND END-OF-LINE FLAG
	AOS	(P)		;[470] SKIP RETURN TO BYPASS .SWDPB
	PUSHJ	P,.+1		;[470] DO THIS TWICE - ONCE FOR PHYS
				;[470] NAME, ONCE FOR LOG NAME
	TRNE	F,R.EOL		;[473] EOL SEEN YET?
	  POPJ	P,		;[473] YES-SCAN BARFS IF WE CALL .SIXSW
	MOVE	T1,DEVPTR	;[470] GET POINTER TO TABLE
	AOBJP	T1,LGNA2M	;[470] TOO MANY /ASSIGN SWITCHES
	SETZ	T2,		;[627] ZAP T2 IN CASE NO LOGICAL NAME
	TRNE	F,R.NXSW	;[627] ARE WE ABOUT TO READ THE NEXT SWITCH?
	  JRST	ASIGN1		;[627] YES - DON'T!
	PUSH	P,T1		;[470] SAVE T1 OVER .SIXQW
	PUSHJ	P,.SIXSW##	;[470] GET SIXBIT STRING
	CAIN	C,"/"		;[627] NEXT SWITCH?
	TRO	  F,R.NXSW	;[627] REMEMBER TO STOP NOW
	SKIPG	C		;[473] EOL YET?
	TRO	  F,R.EOL	;[627] EOL - REMEMBER IT
	POP	P,T1		;[470] GET T1 BACK AGAIN
	MOVE	T2,.NMUL##	;[470] PICK UP ARG FROM SCAN
ASIGN1:	MOVEM	T2,(T1)		;[627] STORE AWAY IN TABLE
	MOVEM	T1,DEVPTR	;[470] SAVE POINTER TO TABLE
	POPJ	P,		;[470] RETURN

	WARN	A2M,<Attempt to assign too many devices with /ASSIGN>
	POPJ	P,		;AND RETURN

	SUBTTL	BATNAM - Handle /BATNAM:"Name" switch

;SUBROUTINE TO READ /BATNAM:"NAME" SWITCH
BATNAM:	PUSHJ	P,.SIXQW##	;[744] READ QUOTED SIXBIT STRING
	MOVE	N,.NMUL##	;[744] RETURN FIRST WORD
	JRST	.SWDPB##	;[744] AND LET SCAN STORE

	SUBTTL	TERMSW - Handle /TERMINAL:(args) switch	[744]

TERMSW:	MOVEI	T1,TERSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS

	SUBTTL	DEFASW -- Handle /DEFAULT:(args) switch

DEFASW:	MOVEI	T1,DEFSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS


	SUBTTL	BATCSW -- Handle /BATCH:(args) switch

BATCSW:	MOVEI	T1,BATSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS

;THIS ROUTINE IS SIMILIAR TO .KEYWD IN SCAN, EXCEPT IT DOESNT HANDLE
;ALSO THE CASES THAT SCAN'S DOES. BUT, IT HANDLES THE SIMPLE SN,SP,SL
;SUB-SWITCHES THAT LOGIN USERS FOR /TERMINAL:. MAYBE SOMEDAY IF SCAN
;CHANGES, WE CAN REMOVE THIS CODE
					;  AND P2 (LOCAL/REMOTE INDEX)
KEYWRD:	PUSHJ	P,.SAVE2##		;SAVE P1 (SWITCH INDEX)
	MOVEI	P2,(T1)			;SAVE POINTER TO SWITCH TABLE
	PUSHJ	P,SIXSW			;GET NAME
	MOVE	T1,SWA(P2)		;GET POINTER TO TABLES
	PUSHJ	P,SWTNAM		;LOOKUP IN TABLE
	 SKIPA				;CAN'T FIND, TRY HARDER
	  JRST	KEYWDG			;GOT IT
	JUMPG	T1,E.UKK##		;AMBIGUOUS IF MORE THAN ONE
	TLC	N,'NO '			;SEE IF /NOXYZ
	TLCE	N,'NO '			;..
	 JRST	E.UKK##			;NO--ISSUE ERROR
	PUSH	P,N			;SAVE WORD
	LSH	N,^D12			;STRIP "NO"
	MOVE	T1,SWA(P2)		;POINT TO TABLES AGAIN
	PUSHJ	P,SWTNAM		;LOOKUP
	 JRST	[POP   P,N		;ERROR--RESTORE WORD
		 JRST	E.UKK]		;AND ISSUE ERROR
	POP	P,N			;RESTORE NAME
	TLO	P1,-1			;FLAG /NOXYZ
	MOVX	T1,FS.NOS 		;GET YES/NO BIT
	TDNN	T1,@SWD(P2)		;SEE IF YES/NO SWITCH
	 JRST	[MOVNI	T1,1		;ELSE PRETEND UNKNOWN
		 JRST	E.UKK##]	;FOR SCAN
KEYWDG:	MOVE	T2,@SWD(P2)		;GET DEFAULT
	MOVEI	N,(T2)			;COPY INTO N
	MOVE	T1,@SWM(P2)		;GET PROCESSOR OR TABLE POINTER
	TXNE	T2,FS.NOS		;SEE IF "NO" SWITCH
	JRST	[HLRZ N,P1		;IF SN STYLE, GET NO INDICATOR
		 MOVEI N,1(N)		;SET N=0 IF NO, 1 IF NOT NO
		 JRST KEYWDA]		;GO STUFF RESULT
	CAIN	C,":"			;SEE IF VALUE SPECIFIED
	JRST	KEYWD2			;YES--GO CHECK INTO IT
;HERE WHEN DEFAULT NEEDED
KEYWD1:	TXNE	T2,FS.VRQ		;SEE IF VALUE REQUIRED
	 JRST	E.SVR##			;YES--GIVE ERROR
	TLNN	T1,-1			;SEE IF MAX SET
	JUMPN	T1,KEYWDJ		;NO--DIRECT ACTION
	JRST	KEYWD8			;YES--GO STORE DEFAULT
;HERE WHEN VALUE SPECIFIED BY USER (MAY BE NULL)
KEYWD2:	;JUMPE	T1,E$$NMA		;IF NO VALUE LEGAL, GIVE ERROR
	JUMPG	T1,KEYWDJ		;IF SPECIAL PROCESSOR, GO DO IT

	PUSHJ	P,SIXSW			;VALUE IS ANOTHER KEYWORD--GET IT
	MOVE	T1,@SWM(P2)		;REFETCH SUB-KEY POINTER
	PUSHJ	P,.NAME			;LOOK IT UP
	  JRST	E.UKK##			;ERROR
	SUB	T1,@SWM(P2)		;DETERMINE INDEX AS VALUE
	MOVEI	N,(T1)			;PLACE IN VALUE (1,2,...)
	JRST	KEYWD8			;AND GO STORE IT AWAY

;HERE IF SN SWITCH TO LOOK FOR VALUES

KEYWDA:	JUMPE	N,KEYWD8		;IF NO, PROCEED (NO VALUES)
	CAIE	C,":"			;SEE IF VALUE COMING
	JRST	KEYWD8			;NO--THAT'S IT
KEYWDB:	PUSHJ	P,SIXSW		;GET VALUE AS NAME
	MOVE	T1,[IOWD YNTABL,YNTAB] 	;TRY YES-NO TABLE
	PUSHJ	P,.NAME			;LOOK UP NAME
	 JRST	E.UKK##			;UNKNOWN
	MOVEI	N,(T1)			;GET LOCATION OF MATCH
	SUBI	N,YNTAB			;GET OFFSET IN TABLE
	ANDI	N,1			;GET YES/NO SETTING
	JRST	KEYWD8			;RETURN THAT VALUE

;HERE TO GO TO SWITCH PROCESSOR
KEYWDJ:	PUSHJ	P,(T1)			;GO DO IT
	 JFCL				;GO STORE
;HERE TO STORE SWITCH
KEYWD8:	LDB	T1,@SWP(P2)		;GET STORED VALUE
	CAME	T1,[-1]			;SEE IF SET
	 JRST	[CAME	T1,N		;SAME AS BEFORE?
		  SKIPE	INISCN		;IN SWITCH.INI?
		   JRST	.SWDON##	;YES--JUST FORGET
		 JRST	E.DSI##]	;NO--ERROR
	DPB	N,@SWP(P2)		;NO--STORE VALUE
	JRST	.SWDON##		;AND RETURN W/O STORE

;TABLE OF YES/NO VALUES--MUST BE NO/YES PAIRS
YNTAB:	SIXBIT	/0/
	SIXBIT	/1/
	SIXBIT	/NO/
	SIXBIT	/YES/
	SIXBIT	/OFF/
	SIXBIT	/ON/
YNTABL==.-YNTAB

;ROUTINE TO READ SIXBIT WORD IGNORING LEADING SPACES
SIXSW:	PUSHJ	P,.TIAUC##		;Prime the pump
	CAIN	C," "			;Space?
	 PUSHJ	P,.TIAUC##		;Yes--Get a real char
	PJRST	.SIXSC##		;Read SIXBIT (char in C)

;ROUTINE TO LOOKUP SWITCH IN TABLE
SWTNAM:	PUSHJ	P,.NAME##		;LOOKUP IN TABLE
	 POPJ	P,			;NOT FOUND
	HRRZ	T2,SWN(P2)		;GET START
	MOVEI	P1,(T1)			;GET MATCH
	SUBI	P1,(T2)			;COMPUTE OFFSET
	JRST	.POPJ1##		;AND SKIP RETURN
LOGBLK:	IOWD	LOGSWL,LOGSWN
	XWD	LOGSWD,LOGSWM
	XWD	0,LOGSWP
	SIXBIT	/LOGIN/		;[320] TYPE HLP:LOGIN.HLP ON /HELP
LOGBLN==.-LOGBLK

SCIBLK:	IOWD	COMLEN,COMLST
	XWD	SAOFST,'LGN'
	XWD	TTYGET,STYO
	XWD	0,0
	XWD	SCNPMT##,FLUSH	
	EXP	FS.ICL

COMLST:	<SIXBIT	/LOGIN/>
COMLEN==.-COMLST

LOKBLK:	XWD	[WILDBK],0
	XWD	JUNK,SECBUF	;[422] THROW AWAY 4-WORD LOOKUP BLK SO
	XWD	.FXLEN,.RBSTS+1	;[422] IT WON'T OVERWRITE AUXACC.SYS DATA
	XWD	0,WLDPNT
LOKBLN==.-LOKBLK

;OFFSETS INTO SWT TABLES FOR KEYWRD ROUTINE

	SWA==-1
	SWN==0
	SWP==1
	SWM==2
	SWD==3

	IOWD	TERM.L,TERM.N	;[744] POINTER TO SWITCH KEYWORDS
TERSWT:	TERM.N(P1)		;[744] SWITCH POINTERS FOR /SETTTY
	TERM.P(P1)		;[744]
	TERM.M(P1)		;[744]
	TERM.D(P1)		;[744]

	IOWD	DEFA.L,DEFA.N	;POINTER TO SWITCH KEYWORDS
DEFSWT:	DEFA.N(P1)		;SWITCH POINTERS FOR /DEFAULT:(args)
	DEFA.P(P1)
	DEFA.M(P1)
	DEFA.D(P1)

	IOWD	BATC.L,BATC.N	;POINTER TO SWITCH KEYWORDS
BATSWT:	BATC.N(P1)		;SWITCH POINTERS FOR /BATCH:(args)
	BATC.P(P1)
	BATC.M(P1)
	BATC.D(P1)
	SUBTTL	Switch tables -- LOGIN switches (definition)

DM	COR,^D0,^D262143,^D262143	;[551]
DM	DPR,3,0,1
DM	FIL,.FXLEN,0,0
DM	LOC,77,0,0
DM	QTA,1,0,0
DM	TIM,0,0,^D60
DM	YN,1,0,1

KEYS	ATT,<ASK,IGNORE>			;/ATTACH:
KEYS	DSKF,<ERROR,PAUSE>			;/DSKFUL:
KEYS	WTCH,<FILES,MTA,VERSION,WRITE,READ,WAIT,RUN,DAY>;/WATCH:
KEYS	NOTC,<ALWAYS,SOMETIMES,NEVER>		;/NOTICE:
; KEYS	SPOL,<LPT,PLT,PTP,CDP,CDR>		;/SPOOL:

	DEFINE SWTCHS,<
;;Switches not applicable to TYMCOM-X
;; SP	ASSIGN,<*F,DEVTAB>,ASSIGN,,FS.VRQ	;;/ASSIGN:DSK:REL
;; SP	LOCATE,<*F,U.STA>,.SWOCT##,LOC,FS.VRQ	;;Sets default printer location
;; SL	SPOOL,<*F,U.SPL>,SPOL,0,FS.OBV		;;(LPT,PLT,PTP,CDP,CDR,ALL)
;; SN	DEFER,<*F,U.DFER>,			;;Deferred spooling
;; SP	DSKPRI,<*F,U.DPRI>,SWDSKP,DPR,FS.VRQ	;;Disk priority
;;Accounting
;; SP	ACCOUNT,<*P,<POINT ^D65-^D8,U.ACTS>>,ACCTSW,,FS.VRQ	;;Project code
;; SP	NAME,<*P,<POINT ^D65-2,U.NAME>>,.SIXQW##,,FS.VRQ	;;User name
;; SN	PASSWORD,<*F,U.NPSW>, 					;;Change password
;; SP	REMARK,<*P,<POINT ^D65-^D8,U.RMRK>>,RMRKSW,,FS.VRQ	;;Session remark
;;Set by BATCON, never by SWITCH.INI
;; SP	BATCH,,BATCSW,,FS.VRQ			;;(INTERV,NAME,SEQUEN,STREAM,REQUES)
;; SP	TIME,<*F,U.TIME>,.SWDEC##,TIM,FS.VRQ	;;Set limit on CPU run time
;;Core related
;; SP	CORE,<*F,U.CORE>,.SWCOR##,COR,FS.VRQ	;;Set both /PHYSICAL and /VIRTUA
;; SP	PHYSICAL,<*F,U.CPPL>,.SWCOR##,COR,FS.VRQ;;Physical memory limit or guide
;; SN	GUIDELINE,<*F,U.GUID>			;;/PHYSICAL is only a guideline
;; SN	LIMIT,<*F,U.LIMIT>			;;/PHYSICAL is an absolute limit
;; SP	VIRTUAL,<*F,U.CVPL>,.SWCOR##,COR,FS.VRQ	;;Virtual memory limit
;;LIB related
;; SP	LIB,<*F,LIBSPC>,.SWFIL##,FIL,FS.VRQ	;;Define a library PPN
;; SS	NOLIB,<*F,LIBSPC+.FXDIR>,0		;;Undefine library PPN
;; SN	NEW,<*F,U.NEW>,				;;Search [1,5] before [1,4]
;; SN	SYS,<*F,U.SYS>,				;;Search SYS: if not on DSK:
;; SN	SCAN,<*F,U.SCAN>,			;;Enable scanning of SYS:,LIB:
;;SFD related
;; SP	PATH,<*F,PTHSPC>,.SWFIL##,FIL,FS.VRQ	;;Set default directory path
;; SN	SCAN,<*F,U.SCAN>,			;;Enable scanning of SFDs
;; SN	SFDCREATE,<*F,U.SFDC>,			;;Create default SFD
;; SP	SFDPROT,<*F,U.SFDP>,.SWOCT##,,FS.VRQ	;;Protection for creating SFD
;;Duplicate syntax switches have been removed
;; BATINT,BATNAM,BATSEQ,BATSTR,REQID are all part of /BATCH:(arg,arg)
;; DEFPROT,DEFBUFFER are part of /DEFAULT:(arg,arg)
;; All TTY status switches are part of /TERMINAL:(arg,arg)

;;These remaining switches are useful in SWITCH.INI
SL	ATTACH,<*F,U.ATT>,ATT,ATTASK		;;(ASK,IGNORE)
SP	DEFAULT,,DEFASW,,FS.VRQ			;;(BIGBUF,BUFFER,PROTEC)
SL	DSKFUL,<*F,U.DFUL>,DSKF,DSKFPA		;;(ERROR,PAUSE)
SN	MAILCHECK,<*F,U.MAIL>,			;;Check if MAIL is waiting
SP	NOTE,<*F,NOTSPC>,.SWFIL##,FIL,FS.VRQ	;;Output file every LOGIN
SL	NOTICE,<*F,U.NOTC>,NOTC,0,FS.VRQ	;;(ALWAYS,SOMTIM,NEVER)
SP	QUOTA,<*F,U.QTA>,QUOTAS##,QTA		;;Recompute disk usage
SN	STR,<*F,U.STR>,				;;Print DSKB:STR.TXT[1,4]
SP	UFDPROT,<*F,U.UFDP>,.SWOCT##,,FS.VRQ	;;Protection on any UFD created
SL	WATCH,<*F,U.WAT>,WTCH,0,FS.OBV	;;(FILE,MTA,VERS,WRITE,READ,WAIT,RUN,DAY)
SS	NOWATCH,<*F,U.NWAT>,0			;;/WATCH:NONE
SN	SETTTY,<*F,U.SETT>,			;;/NOSETTTY to ignore /TERMINAL
SP	TERMINAL,,TERMSW,,FS.VRQ		;;See TERMSW table
	SUBTTL	Switch tables -- LOGIN switches (expansion)

	DOSCAN(LOGSW)			;LOGIN SWITCHES
	SUBTTL	Switch tables -- TERMINAL arguments (definition)

;[744] ADD ALL NEW TERMINAL SWITCHS HERE

DM	FLL,3,0,2			;;Filler classes 0,1,2,3
DM	PSZ,^D255,^D255,^D24		;;Page size
DM	WTH,^D255,^D80,^D132		;;Width

KEYS	SPED,<50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,EXTA,EXTB>

DEFINE SWTCHS,<
SN	ALTMODE,<*F,U.ALTM>,		;;Convert 175 altmode to 33 escape
SN	BLANKS,<*F,U.BLNK>,		;;Suppress blank lines
SN	CRLF,<*F,U.CRLF>,		;;Output CRLF when width exceeded
SN	DEFER,<*F,U.TTDE>,		;;Deferred echo
SN	DISPLAY,<*F,U.DISP>,		;;Do back-space-backspace
SN	ECHO,<*F,U.ECHO>,		;;Echo input characters
;; SN	FFHOME,<*F,U.FFHO>,		;;Formfeed erases screen
;; SN	FFSIMULATE,<*F,U.FFSI>		;;Formfeed simulated, 0 to 66 linefeeds
;; SN	FFSTOP,<*F,U.FFST>		;;Formfeed stops output until XON
SP	FILL,<*F,U.FILL>,.SWOCT##,FLL	;;Filler class 0-3
SN	FORM,<*F,U.FORM>,		;;Terminal has hardware formfeeds
;; SN	GAG,<*F,U.GAG>,			;;Suppress SEND message (unless ^C)
SN	LC,<*F,U.LC>,			;;Accept lowercase input
;; SP	LENGTH,<*F,U.LENG>,.SWDEC##,PSZ,FS.VRQ	;;Number of lines on screen
SS	NOFILL,<*F,U.FILL>,0		;;Same as FILL:0, no fillers needed
;; SS	NOSTOP,<*F,U.STOP>,0		;;Don't stop every 24 lines
;; SS	NOSSTOP,<*F,U.SSTO>,0		;;Don't stop every 24 lines
SN	PAGE,<*F,U.PAGE>,		;;Old name for /XONXOFF
;; SP	PAGESIZE,<*F,U.PGSZ>,.SWDEC##,PSZ,FS.VRQ ;;Old name for /LENGTH
SL	RCVSPEED,<*F,U.RSPD>,SPED,0,FS.VRQ ;;Baud rate received by PDP-10
SN	RTCOMP,<*F,U.RTC>,		;;To allow ^R and ^T to be input
;; SN	SBELL,<*F,U.SBEL>,		;;Beep when stopping after 24 lines
SL	SPEED,<*F,U.SPED>,SPED,0,FS.VRQ	;;Set RCVSPEED and XMTSPEED to same
;; SP	STOP,<*F,U.STOP>,.SWDEC##,PSZ,FS.VRQ	;;Stop 24 lines after XON
;; SP	SSTOP,<*F,U.SSTO>,.SWDEC##,PSZ,FS.VRQ	;;Stop 24 lines in spite of XON
SN	TABS,<*F,U.TABS>,		;;Terminal has hardware tabs
SN	TAPE,<*F,U.TAPE>,
;; SN	TIDY,<*F,U.TIDY>,			;[747]
SP	TYPE,<*F,U.TYPE>,.SIXSW##,,FS.VRQ	;[675]
SN	UC,<*F,U.UC>,				;[747]
SP	WIDTH,<*F,U.WDTH>,.SWDEC##,WTH,
SN	XONXOFF,<*F,U.XONXO>,
SL	XMTSPEED,<*F,U.XSPD>,SPED,0,FS.VRQ
>;END DEFINE SWTCHS
	SUBTTL	Switch tables -- TERMINAL arguments (expansion)

	DOSCAN	(TERM.)		;[744] EXPAND THE SUBTABLE POINTERS

>;END IFN SETTTY
	SUBTTL	Switch tables -- DEFAULT arguments (definition)

DM	PRO,777,0,0
;; DM	BUF,777,0,2
;; DM	BIG,^D31,0,^D4

DEFINE SWTCHS,<
;; SP	BIGBUFFER,<*F,U.DFBB>,.SWDEC##,BIG,
;; SP	BUFFER,<*F,U.DFBU>,.SWDEC##,BUF,
SP	PROTECTION,<*F,U.DFPR>,.SWOCT##,PRO,FS.VRQ
>

	SUBTTL	Switch tables -- DEFAULT arguments (expansion)

	DOSCAN	(DEFA.)		;EXPAND THE SUBTABLE POINTERS
	SUBTTL	Switch tables -- BATCH arguments (definition)

DEFINE SWTCHS,<
SN	INTERVENTION,<*F,U.BINT>,
SP	NAME,<*F,U.BNAM>,BATNAM,,FS.VRQ
SP	SEQUENCE,<*F,U.BSEQ>,.SWDEC##,,FS.VRQ
SP	STREAM,<*F,U.BSTR>,.SWOCT##,,FS.VRQ
SP	REQUESTID,<*F,U.BREQ>,.SWDEC##,,FS.VRQ
>

	SUBTTL	Switch tables -- BATCH arguments (expansion)

	DOSCAN	(BATC.)

;CHKOPR - SEE IF [1,2] AND NO ACCOUNT STRING. READ THE SYSTEM DEFAULT
;AND USE THAT IF WE CAN

CHKOPR:	MOVE	T1,PPN		;GET PPN
	CAME	T1,ALPPPN	;OPR?
	 JRST	.POPJ1##	;NO--BETTER WAIT
	MOVE	T1,U.ACTS	;GET ACCOUNT STRING
	CAME	T1,[-1]		;SEE IF SPECIFIED
	 JUMPN	T1,.POPJ1##	;YES--BETTER WAIT
	MOVE	T1,[.ACTRD,,T2]	;READ ACCOUNT STRING
	MOVEI	T2,2		;2 ARGS
	MOVEI	T3,0		;NULL JOB (SYSTEM DEFAULT)
	MOVEI	T4,U.ACTS	;INTO OUR ACCOUNT STRING
	ACCT.	T1,		;DO IT
	 JFCL			;CANT SAY WE DIDNT TRY
	POPJ	P,		;AND LET HIM IN

;DATTIM - ROUTINE TO GETTAB THE INTERNAL DATE AND TIME (%CNDTM) AND STORE IT
;	IN ACTACK SO IPCF MESSAGES AND THEIR RESPONSES CAN BE SYNCRONIZED AND
;	ALSO ENSURE SYSTEM SECURITY AND ACCOUNTING DATA INTEGRITY.
;	RETURNS THE DATE/TIME WORD IN T1

DATTIM:	MOVX	T1,%CNDTM
	GETTAB	T1,
	  MOVEI	T1,0		;CAN'T HAPPEN
	MOVEM	T1,ACTACK	;SAVE IT AS A UNIQUE NUMBER
	POPJ	P,
;[344] TABLES FOR ROUTINE TO DO TRMOP.S AND SET TERMINAL STUFF

IFN	SETTTY,<

	DEFINE X(TCODE,ARG,FLAGS),<
	XWD	ARG,FLAGS!TCODE+1000 >

;FLAGS
TF.CMP==1B18		;USE COMPLEMENT OF VALUE STORED BY SCAN

TTAB:	X .TOTRM,U.TYPE,0	;[675] DO TYPE SETTING FIRST THEN ALTER
				;[675] THE DEFAULTS.
	X .TOALT,U.ALTM,TF.CMP	;[472] TRMOP.S WHICH ARE DONE BEFORE
	X .TOBLK,U.BLNK,TF.CMP	;[472] PRINTING NOTICE.TXT
	X .TONFC,U.CRLF,TF.CMP
;;	X .TODBK,U.DBRK,0
	X .TOLCP,U.ECHO,TF.CMP
	X .TOFLC,U.FILL,0
	X .TOFRM,U.FORM,0
	X .TOSND,U.GAG,TF.CMP
	X .TOLCT,U.LC,TF.CMP
	X .TOPAG,U.PAGE,0
;;	X .TOPSZ,U.PGSZ,0
	X .TORTC,U.RTC,0
	X .TOTAB,U.TABS,0
	X .TOTAP,U.TAPE,0
	X .TOWID,U.WDTH,0
;;	X .TODEM,U.TTDE,0
;;	X .TODIS,U.DISP,0	;[743]
	X .TOLCT,U.UC,0		;[747]
;;	X .TOTDY,U.TIDY,0	;[747]
;;	X .TOFFH,U.FFHO,0
;;	X .TOFFF,U.FFSI,0
;;	X .TOFFS,U.FFST,0
;;	X .TOLNB,U.LENG,0
;;	X .TOSBL,U.SBEL,0
;;	X .TOSSZ,U.SSTO,0	;STOP SIZE
;;	X .TOSSZ,U.STOP,0	; "     "
	X .TOXNF,U.XONXO,0
;;	X .TOSTO,T.STOP,0	;STOP BIT
;;	X .TOSST,T.SSTOP,0	;SSTOP BIT
TTLNTH=.-TTAB

PTAB:	X .TORSP,U.RSPD,0	;[472] TRMOP.S WHICH SHOULD BE DONE
	X .TOTSP,U.XSPD,0	;[472] AFTER PRINTING NOTICE.TXT
PTLNTH=.-PTAB			;[472]

	>		;[344] END IFN SETTTY

	SUBTTL	Set user profile -- non-privileged SETUUOs

;HERE AFTER LOGIN UUO IS DONE TO SET OPTIONAL STUFF
USRSET:	HRROI	T1,.GTWCH	;[446] TRY GETTAB TO GET THIS JOB'S
	GETTAB	T1,		;[446] WATCH BITS. IF GETTAB FAILS,
	  JRST	TINY		;[446] THIS MUST BE A 1040 MONITOR
	LDB	T1,WATBTS	;GET WATCH BITS
	LSH	T1,SHFWAT
	HRRZ	T2,U.WAT	;GET WATCH BITS
	LSH	T2,WCHLSH##	;SHIFT TO CORRECT PLACE
	IOR	T1,T2		;OR IN THE USER SETTINGS
	MOVE	T2,ENTRY+.ACPRO	;GET THE PROFILE WORD
	TXNE	T2,AC.WVR	;WANT TO WATCH VERSIONS?
	TRO	T1,(JW.WVR)	;YES--TURN ON VERSION WATCHING
	SKIPE	NEWACT		;IF OLD ACCT.SYS FORMAT
	TXNE	T2,AC.WMT	; OR USER WANTS MTA WATCHING
	TRO	T1,(JW.WMT)	; TURN ON WATCH MTA
	TXNE	T2,AC.WFL	;USER WANTS FILE WATCHING
	TRO	T1,(JW.WFI)
	MOVE	T2,.FLVRB##	;[455] GET /VERBOSITY FROM SCAN
	LSH	T2,^D6		;[542] SHIFT OVER TO RIGHT PLACE
	ANDI	T2,700		;[542] THROW AWAY GARBAGE BITS
	IOR	T1,T2		;[455] OR INTO WATCH BITS
	HRLI	T1,.STWTC	;SET WATCH FUNCTION
	MOVE	T2,['SWB',,[ASCIZ/watch bits/]]
	SKIPE	U.NWAT		;[336] SKIP THE SETUUO IF /NOWATCH
	PUSHJ	P,SETIT		;DO THE SET UUO
TINY:	SETOM	UFDFSN		;[446] START WITH FIRST STR

;HERE TO SET CURRENT VM LIMITS
USRST1:	MOVE	T1,STATS2	;GET SECOND STATES WORD
	TXNN	T1,ST%VMS	;DO WE HAVE VM?
	JRST	USRST7		;NO--TRY NEXT THING
	MOVEI	T3,0		;PRESET ANSWER TO ZERO
	SKIPGE	T1,U.CVPL	;GET CURRENT VIRT LIMIT
	JRST	USRS6A		;NONE SUPPLIED
	PUSHJ	P,FIXPGS	;CONVERT TO PAGES
	HRL	T3,T1		;USER SUPPLIED ONE -- USE IT
USRS6A:	SKIPGE	T1,U.CPPL	;GET CURRENT PHYS LIMIT
	JRST	USRS6B		;NONE SUPPLIED--LEAVE ZERO
	PUSHJ	P,FIXPGS	;MAKE SURE WE HAVE PAGES
	HRR	T3,T1		;USER SPECIFIED ONE -- USE IT
USRS6B:	JUMPE	T3,USRST7	;JUMP IF NOTHING REQUESTED
	SKIPG	U.LIMIT		;SKIP IF /LIMIT
	SKIPN	U.GUID		;SKIP UNLESS /NOGUIDELINE GIVEN
	TRO	T3,400000	;SET THE BIT
	MOVE	T1,[.STCVM,,T3]	;ARGUMENT TO SET UUO
	MOVE	T2,['SCV',,[ASCIZ/current virtual and physical limits/]]
	PUSHJ	P,SETIT		;DO THE SETUUO

USRST7:	IFN	SETTTY,<	;[344]
	SKIPN	U.SETT		;[344] DID HE SAY /NOSETTY?
	JRST	USRST8		;[344] YES -- SKIP THE WHOLE BIT
	SKIPG	T1,U.SPED	;[344] DID HE SAY /SPEED:N?
	JRST	.+3		;[344] NOPE
	MOVEM	T1,U.RSPD	;[344] YES -- SET BOTH RCV AND XMIT
	MOVEM	T1,U.XSPD	;[344] SPEED TO N
;FIX UP STOP/SSTOP
	MOVEI	T1,1		;A BIT
	SKIPG	U.STOP		;STOP?
	 SKIPLE	U.SSTOP		;OR SSTOP?
	  MOVEM	T1,T.STOP	;YES--SET STOP
	SKIPLE	U.SSTOP		;SSTOP?
	 MOVEM	T1,T.SSTOP	;YES--SET SSTOP TOO
	MOVE	T1,[-TTLNTH,,TTAB] ;[472] TABLE OF PRE-NOTICE TRMOP.S
	PUSHJ	P,DOTRMP	;[472] DO THE TRMOP.S
	>			;[472] END IFN SETTTY



USRST8:	MOVEI	P1,DEVTAB	;[470] MAKE PTR TO LIST
	HLRE	T1,DEVPTR	;[470] GET -NUMBER OF WORD PAIRS LEFT
	ADDI	T1,DVICES*2	;[470] MAKE +NUMBER OF PAIRS USED
	JUMPL	T1,USRS8C	;[470] NO /ASSIGN SWITCH TYPED
	CAILE	T1,DVICES*2	;[470] TOO MANY?
	  MOVEI	T1,DVICES*2	;[631] YES - USE MAX
	LSH	T1,-1		;[470] HALVE BECAUSE WORD PAIRS
	MOVN	P2,T1		;[470] MAKE AOJL COUNTER
USRS8A:	SETZB	T1,T3		;[470] SET UP OPEN BLOCK
	MOVE	T2,(P1)		;[470] GET PHYSICAL NAME
	OPEN	UFD,T1		;[470] OPEN ON SOME RANDOM CHANNEL
	  JRST	NDEV		;[470] LOSE
	AOS	P1		;[470] BUMP POINTER
	MOVEI	T1,UFD		;[470] CHANNEL NUMBER
	SKIPN	T2,(P1)		;[470] PICK UP LOGICAL NAME
	  JRST	.+3		;[470] NONE - KEEP GOING
	DEVLNM	T1,		;[470] ASSIGN LOGICAL NAME
	  JRST	NODEV		;[470] LOST
	MOVE	T1,THSJOB	;[470] SET ASSCON BY REASSI
	MOVEI	T2,UFD		;[470] CHANNEL NUMBER
	REASSI	T1,		;[470] ZAP!
USRS8B:	CLOSE	UFD,		;[470] TIDY UP
	AOS	P1		;[470] BUMP POINTER
	AOJLE	P2,USRS8A	;[502] LOOP THRU DEVICE LIST

USRS8C:	POPJ	P,		;[470] ALL DONE


NODEV:	SOS	P1		;[470] DROP BACK TO POINT AT PHYS NAME
NDEV:	WARN	CAD,<Could not assign device >,,E.CAD
	JRST	USRS8B		;KEEP ON TRUCKIN

E.CAD:	MOVE	T1,(P1)		;GET PHYSICAL NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	AOS	P1		;BUMP POINTER
	SKIPN	(P1)		;LOGICAL NAME SPECIFIED?
	 POPJ	P,		;NO - DON'T TALK ABOUT IT
	MOVEI	T1,[ASCIZ/ logical name /]	;[470]
	PUSHJ	P,.TSTRG##
	MOVE	T1,(P1)		;GET LOGICAL NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	PJRST	.TSIXN##	;TYPE IT AND RETURN

;[472] ROUTINE TO DO POST-NOTICE TRMOP.S
POSTMS:	IFN	SETTTY,<	;[472]
	SKIPN	U.SETT		;[472] DID HE SAY /NOSETTTY?
	  POPJ	P,		;[556] YES- SKIP IT
	PUSHJ	P,WAITO		;[472] WAIT UNTIL OUTPUT BUFFER EMPTY
	MOVE	T1,[-PTLNTH,,PTAB] ;[472] TABLE OF POST-NOTICE TRMOP.S
	PUSHJ	P,DOTRMP	;[472] DO THEM UP
	>			;[472] END IFN SETTTY
	POPJ	P,		;[472]

	IFN SETTTY,<		;[556]
DOTRMP:	MOVE	P1,[XWD 3,T2]	;[472] SET UP ARG POINTER
TLOOP:	SETZ	P2,		;[344] CLEAR FLAGS
	HLRZ	T4,(T1)		;[344] GET ADDR OF ARG FOR TRMOP.
	MOVE	T4,(T4)		;[344] GET ACTUAL ARGUMENT
	CAMN	T4,[-1]		;[675] IF -1,
	JRST	LEAVE		;[675]  SCAN DIDN'T TOUCH IT
	HRRZ	T2,(T1)		;[344] GET TRMOP. FUNCTION CODE & FLAGS
	TRZE	T2,TF.CMP	;[344] CLEAR FLAGS OUT OF T2 SO IT
	TRO	P2,TF.CMP	;[344] WILL BE A REAL TRMOP. CODE
	MOVE	T3,TTYUDX	;[344] GET TTY UDX
	TRNE	P2,TF.CMP	;[344] COMPLEMENT ARGUMENT?
	TRC	T4,1		;[344] YUP
	TRMOP.	P1,
	  JRST	WHA		;[344] OOPS -- CHECK IT OUT
LEAVE:	AOBJN	T1,TLOOP	;[344] GO ROUND AGAIN
FORGET:	POPJ	P,		;[475] ALL DONE
	>			;[470] END IFN SETTTY


	IFN	SETTTY,<	;[556]
;[344] HERE IF TRMOP. UUO FAILS
WHA:	CAIN	P1,TOPRC%	;[344] NOT PRIVILEGED?
	JRST	IGNORE		;[344] ACT LIKE IT DIDN'T HAPPEN
	JUMPE	P1,IGNORE	;[344] IF FUN. NOT IMPLEMENTED, IGNORE
	CAMN	P1,[XWD 3,T2]	;[344] IF UUO NOT IMPLEMENTED, FORGET
	JRST	FORGET		;[475] THE WHOLE THING
	PUSH	P,T1		;[375] WATCH OUT FOR T1
	HRRZ	T1,(T1)		;[675] PICK UP FUNCTION CODE
	CAIN	T1,.TOTRM+1000	;[675] TRYING TO SET TERMINAL TYPE
	JRST	NOTTYP		;[675] YES, NO SUCH TTY TYPE
	WARN	TUF,<TRMOP. UUO failed. Function code = >,,.TOCTW##
	POP	P,T1		;[677] GET T1 BACK AGAIN

IGNORE:	MOVE	P1,[XWD 3,T2]	;[344] RESTORE POINTER
	JRST	LEAVE		;[344] AND RETURN

;[675] TERMINAL TYPE INVALID ERROR
NOTTYP:	POP	P,T1		;[677]  GET T1 BACK AGAIN
	WARN	TTI,<Terminal type invalid;  Using defaults>
	JRST	IGNORE		;[744] AND RETURN

;[367] ROUTINE TO SLEEP UNTIL FINISHED OUTPUTTING ON TTY
WAITO:	MOVEI	P1,^D120	;[475] WAIT FOR TTY OUTPUT FOR 2 MIN.
WAITO1:	MOVE	T1,[XWD 2,T2]	;[553] SET UP POINTER FOR TRMOP.
	MOVEI	T2,.TOSOP	;[367] SKIP IF OUTPUT BUFFER NON-EMPTY
	MOVE	T3,TTYUDX	;[367] OUR UNIVERSAL I/O INDEX
	TRMOP.	T1,		;[367] IF OUTPUT BUFFER EMPTY OR TRMOP.
	  POPJ	P,		;[367] FAILS, ASSUME OK AND RETURN
	MOVEI	T4,1		;[367] SLEEP FOR ONE SECOND
	SLEEP	T4,
	SOJG	P1,WAITO1	;[553] IF STILL PATIENT, KEEP SLEEPING
	POPJ	P,		;[475] WAITED TOO LONG - GIVE UP

	>			;[357] END IFN SETTTY

	SUBTTL	Set user parameters -- subroutines

;SUBROUTINE TO DO A SET UUO
;CALL WITH:
;	T1 = SET UUO ARGUMENT
;	LH(T2) =  3 LETTER CODE IN SIXBIT
;	RH(T2) = ADDRESS OF ASCIZ STRING
;	PUSHJ	P,SETIT
;	RETURN HERE IN ALL CASES
SETIT:	SETUUO	T1,		;SET THE PARAMETER
	  SKIPA			;LOST--PRINT MESSAGE
	POPJ	P,0		;WORKED--RETURN
	PUSH	P,T2		;SAVE T2
	PUSHJ	P,NEWLIN	;START WITH CLEAN LINE
	MOVEI	T1,[ASCIZ/%LGN/] ;PRINT PREFIX
	PUSHJ	P,.TSTRG##	; ..
	HLLZ	T1,(P)		;COPY 3 LETTER CODE
	PUSHJ	P,.TSIXN##	;PRINT THAT OUT
	MOVEI	T1,[ASCIZ/ SETUUO failed attempting to set /]
	PUSHJ	P,.TSTRG##	;TYPE THE FIRST STUFF
	HRRZ	T1,(P)		;COPY REST OF STRING
	PUSHJ	P,.TSTRG##	;PRINT IT
	POP	P,T2		;CLEAN UP STACK
	PJRST	.TCRLF##	;ADD A CRLF
;SUBROUTINE TO CONVERT CORE ARGUMENT TO PAGES
;CALL WITH:
;	MOVE	T1,ANSWER-FROM-.SWCOR
;	PUSHJ	P,FIXPGS
;	RETURN HERE # OF PAGES IN T1
;USES NO AC'S
FIXPGS:	CAIG	T1,^D512	;JUST A NUMBER?
	IMULI	T1,^D1024	;YES--CONVERT TO WORDS
	LSH	T1,-9		;CONVERT TO PAGES
	POPJ	P,0		;RETURN
	SUBTTL	LGNSCN storage

	WCHLSH==:^D17-WTCHDA	;AMOUNT TO SHIFT BITS RETURNED BY
				; SCAN FOR SETUUO

	XLIST
	LIT
	LIST

;LOWSEG STORAGE FOR LGNSCN & LGNSET
	RELOC

MSKMEM:	BLOCK	1	;MEMORY FOR MASK PRINTER

NODBLK:
NODLEN:	BLOCK	1		;[633] LENGTH OF NODE UUO ARGUMENT BLOCK
NODLOC:	BLOCK	1		;[633] NODE NUMBER
	BLOCK	1		;[633] RESERVED ARGUMENT
NODDEV:	BLOCK	1		;[633] NUMBER OF DEVICES,,DEVICE TYPE

	END
    / o+