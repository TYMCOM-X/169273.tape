.Flag index
.flag macro $
.lm0;.rm 70
.fill;.just
.figure 10
.c;$Bold(TYMSHARE TYMCOM-X)
.s6;.c;$Bold(VUE - Version %1)
.s2;.c;$Bold(A DISPLAY EDITOR FOR TYMCOM-X)
.s6;.c;$Bold(Reference Manual)
.s2;.c;$Bold(By)
.s2;.c;$Bold(CARL A BALTRUNAS)
.s3;.c;Last revision: 1-Jun-81
.s6;.c;$Bold(Tymshare), $Bold(Inc.)
.s2;.c;$Bold(Cupertino), $Bold(California)
.page
.number 1
.hl 1 $Bold(Introduction)
.hl 2 $Bold(Organization of This Text)
.index Introduction
.index Text Organization
.paragraph
This is the manual for the Tymshare display editor VUE.  The reader is
not expected to be a programmer.  This text is meant to be a reference
and not a teaching manual.  Please refer to the VUE >tutorial text guide
for that purpose.  This is also available, as an on-line file, VUE.TUT,
which steps through the basic VUE commands to provide the user with an
elementary understanding of the editor.  If you are a new user, then
please take the time to go through the tutorial.
.paragraph
On the first few readings, you need not make any attempt to memorize
the early chapters, which describe the notational conventions and the
general appearance of the VUE display screen.  These things will become
clear after you have used VUE for a short time.  After reading the Basic
Editing section, you should practice using the commands described there,
before you continue on to the next section.
.paragraph
To find documentation on a particular command, look in the index or the
command appendix if you know what the command is.  If you know vaguely
what a command does, look first in the table of contents then in the
function index.
.paragraph
Also note that this text is currently under massive revision and
portions of the document that are referred to may not currently exist.
If a need to use one or more of these sections arises with any frequency,
feel free to stop by and remind me that it isn't written yet.

.hl 2 $Bold(Description)
.paragraph
$Bold(VUE) is characterized as a real-time display editor.  Its name
originates from two areas.  First, from the $Bold(French) word "$Bold(vue)"
which means "to see", and second, because we needed a nice snappy name
for an editor which was not already in use.  In recognition of the
language from which the name was taken, and for completeness, here is
a formal definition:
.lm 9
.sk
.index Definition of VUE
.indent -9
VUE##[1]#n.  fem.  Faculte de voir; sens qui nous fait distinguer a
lumiere, la forme des objets...; l'organe de la vue ou les yeux; les
regards; action de regarder; espace qu'on peut embrasser du regard.
.indent -4
[2]#n.  fem.  Un programme d'edition et de modification de texte avec
repercussion immediate des changements sur l'ecran du terminal.  Un
nouveau video editeur actuellement developpe par Tymshare a partir de
"EMACS" [1], un editeur du MIT (Massachusetts Institute of Technology).
.lm 0;.sk
.footnote
[1] $Bold(EMACS) - the extensible real-time display editor for the PDP-10
written at the Massachusetts Institute of Technology (MIT).
.end footnote

.index Real-Time
.paragraph
In english, VUE is simply a display editor.  This means that normally
the text being edited is visible on the screen and is updated
automatically as you type your commands.  VUE is "real-time" because
the display is updated very frequently, usually after each character
or group of characters that the user types.  This minimizes the amount
of information that you must keep in your head as you edit.  What you
change is displayed almost immediately, or as you change it.
.index Display Terminals
.index Glass Teletypes
.paragraph
However, it is important to note that as a display editor, VUE can
only be used on display terminals.  As such its use is limited to
those display screens which are currently defined.  It will not work
on hardcopy terminals such as teletypes and on some very dumb display
terminals which are also referred to as "glass" teletypes.  New types
of terminals can be defined if they do not already exist, but this
requires re-compilation of the editor and can be done only
infrequently.

.hl 2 $Bold(Future Releases)
.paragraph
VUE is currently Unsupported, but an attempt will be made to correct any
major bugs or problems which users may find.  However, no guarantees are
expressed or implied.
.paragraph
It is also important to note, that VUE is undergoing considerable
development and that the command structure as well as certain areas
of functionality are changing.  This means that some commands $Bold(will)
be changing in the future, and that this manual only reflects the state
of the current version.
.paragraph
This text will try to point out some of the areas which will be changing
by marking those commands due to be changed in some way with an asterisk
($Bold(*)).  This is to allow you to be wary of using these commands for
anything complicated, such as macros$Bold(*).  (Note that the entire
macro facility is due to be revamped).

.page
.hl 1 $Bold(>Terminology>)
.hl 2 $Bold(Notational >Conventions for VUE and >ASCII characters)
.paragraph
Characters in files and your VUE buffer are ordinary ASCII [2]
characters and are represented as themselves when possible:  The letter
.footnote
[2] $Bold(ASCII) - The American Standard Code for Information
Interchange is a 7-bit or seven-level standard code for transmitting
single character information across communication lines.  This is the
code used by the PDP-10 hardware to communicate with terminals.
.end footnote
.index 7-Bit character set
.index 8-Bit character set
"E", for instance, is represented as $Bold(E) on the screen.  Some
characters, such as control characters do not appear on your keyboard
as normal characters.  These characters must be displayed on your screen
however, so the convention used in this manual and on your screen is to
represent control characters as uparrow or caret ($Bold(_^)) followed by the
corresponding non-control character:  Control-E is represented as $Bold(_^E).
The special 8-bit character set used by VUE only applies to commands
typed at the keyboard.
.index CRLF
.paragraph
CRLF is the traditional term for carriage return followed by a
linefeed.  This sequence of two characters is what separates lines of
text in a file, or in the text being edited.  VUE normally makes this
sequence of characters appear as "one" character which we will call
"newline".  The occurrence of one or the other of these characters by
itself is what we will call a ">stray>".  A stray carriage-return will
be converted by VUE to be a ">newline>", while a stray >linefeed will be
typed as "_^J".
.paragraph
The ">altmode>" or ">escape>" key which is described below has two notational
conventions in this manual.  This is because VUE understands this key
in two separate >contexts>.  In the first context, "escape" is meant to be
a general termination character.  This will be represented as _<esc_>
throughout this document.  In the second context, "escape" is used as
a bit-prefix character and will be represented as ">Meta>" or "M-".
.index Numeric expressions
.paragraph
Numeric expressions are considered to be decimal numbers unless they
contain a prefix.  The single quote character ($Bold(')) is used to
prefix an octal number (a number in base 8, in deference to base 10).

.hl 2 $Bold(The VUE Keyboard)
.index The VUE Keyboard
.paragraph
VUE is designed ideally to be used with terminals whose keyboards have
a pair of shift keys, labelled "$Bold(>Control>)" and "$Bold(>Meta>)" [3],
.footnote
[3] $Bold(>META>) - The META key is also analogous to the >EDIT key found
on some keyboards (Quite often refugees from Stanford, and a few
others).  However, if your terminal has this key, it is a good idea to
check the hardware and make sure it is setting bit 8 and not bit 9.
.end footnote
either or both of which can be combined with any character that you can
type.  These shift keys produce "$Bold(>Control>)" characters and
"$Bold(Meta)" characters, which are the editing commands in VUE.
Ordinary characters like "$Bold(A)" which are neither Control nor Meta
are used for inserting <text.  We name each of the editing command
.index C-#Prefix
.index M-#Prefix
characters by prefixing "Control-" or "Meta-" (abbreviated "$Bold(C-)"
and "$Bold(M-)") to the character:  thus, Control-F or $Bold(C-F) is the
character which is $Bold(F) typed with the Control key held down.
.index 256-character set
.index 8-Bit character set
.paragraph
The 128 characters, multiplied by two by combinations with the META
key, make 256 characters in the VUE command character set.  So it is
called the 256-character set to distinguish it from ASCII, which has
only 128 characters.  It is also called the "8-bit" character set
because 8 bits are required to express a number from 0 to 255.  Note
.index 256-character set
that the 256-character set is used only for keyboard commands.  All
characters in files being edited with VUE are >ASCII characters.
.paragraph
To curtail misunderstanding further on, a brief description of the
keyboard command characters follows.  The 8-bit character set can be
divided into three sections.
.hl 3;$Bold(Control Characters)
.index Control Characters
.paragraph
The first section is made up of "Control" characters, (ASCII characters
in the range '000 to '037).  These characters are almost always commands,
depending upon what mode you are in.  There is one character, ASCII code
'177, the >RUBOUT or >DELETE character which is not really a "Control"
character, but is included in that section since it is never entered as
text.  These characters are represented on your screen prefixed with the
uparrow or caret character ($Bold(_^)), and as commands prefixed by the
abbreviation "$Bold(C-)".
.hl 3;$Bold(Text Characters)
.index Text Characters
.index self-inserting
.Paragraph
The second section is comprised of text characters which can be thought
of as self-inserting.  These are the ASCII characters in the range '040
to '176 and include all the alphabetic, numeric and punctuation
characters on your keyboard.  These characters are represented by
themselves in printed form.  The first two sections, Control and Text,
cover the first 128 characters or the "ASCII" characters.
.hl 3;$Bold(Meta Characters)
.index Meta Characters
.paragraph
The third section covers all the rest.  By combining all of the 128
characters in the ASCII character set with the META key we allow for
128 additional commands.  This is accomplished by setting bit 8 in
combination with all other combinations of typable characters.  These
commands are represented as characters prefixed by the abbreviation
"$Bold(M-)".  The need for these and more will become evident as you use
VUE to edit your files.

.hl 2 $Bold(Prefix Characters)
.paragraph
Sadly, most terminals do not have "$Bold(ideal)" keyboards.  In fact,
very few terminals do, so on non-ideal keyboards, we provide
two-character circumlocutions, made up of characters that you can type,
for each of the command characters that you can't type.
.paragraph
Most, but not all of the "Control" characters can be typed from
the keyboard.  The ones which cannot be typed often depend upon
the specific terminal, but this will be covered later.
.paragraph
The META characters, of course, cannot be typed on most standard ASCII
keyboards.  Thus, on non-ideal keyboards, each of these characters is
typed by prefixing them with an ">Altmode>".  On some keyboards this key
is labelled ">ALT>", "PRE", ">ESCAPE>" or ">ESC>".  It is a good idea to look
at your specific terminal to see what it is called.  Hereafter in this
text, whatever the key is called for your terminal, this key will be
referred to as the "ESCAPE" or "META" key.  On terminals with a META key
remember to combine the Meta key with the command character.  On other
terminals, remember to type "META" prior to typing the second part of
the command character.  The character Meta-F can thus be typed as two
characters, "Escape" and "F".
.paragraph
Note that the "META" key on non-ideal terminals is also an ASCII control
character, and that it may be entered into the text as such.  VUE takes
exception to this and a few other control characters.  "Escape" is
displayed on the screen as "$Bold(>_$>)".  Remember that VUE uses the escape
character for both a general terminator and as the Meta (M-) prefix.
When we are referring to the escape key as a prefix to other commands, we
will always call it the Meta key or the MetaPrefix.
.paragraph
The "Control" key on most non-ideal keyboards can combine with most of
the other keys, but not all.  At present, there is not a special
character prefix for "Control", but after some study of Tymshare
.index Control-_^
.index Control-Caret
.index EMACS
.index Control-Arrow
terminals, such a prefix may come to exist.  If it does, the potential
choice for a character will probably be $Bold(C-_^) (Control-Caret or
Control-Arrow on some terminals).  This is an attempt to bring the
functionality of VUE closer to EMACS.
.index Control-x
.index C-X
.paragraph
There is one additional prefix character which is important to know.
It is Control-X (or $Bold(C-X)) which is used as the beginning of a large
set of two-character commands known as "$Bold(C-X commands)".  C-X is not a
bit-prefix character like Meta, nor is it a circumlocution for any
single character.  C-X is the beginning of an e$Bold(X)tended set of commands
which must always be typed as two characters on the terminal.

.page
.hl 1 $Bold(The Organization of the Screen)
.index Screen Organization
.hl 2 $Bold(The Editing Area)
.index Editing Area
.paragraph
The VUE >screen is divided into several areas, each of which contains
its own type of information.  The biggest area is, of course, the one in
which you usually see the text you are editing.  The terminal's cursor
usually appears somewhere inside that text, showing the position of
">point>", the location at which editing takes place.  While the cursor
appears to point $Bold(at) a particular character, point should be
thought of as $Bold(between) two characters.  It points $Bold(after) the
character that the cursor appears after and $Bold(before) the character
that the cursor appears on top of.  Terminals only have one cursor, and
when output is in progress it must appear where the typing is being
done.  This does not mean that the point is moving.  It is only that VUE
has no way to show you the location of "point", except when the terminal
is idle.
.hl 2 $Bold(The Echo Area)
.index Echo Area
.paragraph
Near the bottom of the screen, there is an area called the "echo" area.
This is where VUE types out messages and you sometimes type commands.
The functionality of this area is changing in the future, but generally,
you can think of this area as used for command prompting and echoing.
.hl 2 $Bold(The Status Line Area)
.index Status Line Area
.paragraph
Above the Echo Area is a single line called the "status line".  This line is
used to display the current status of your VUE session, including major
modes, terminal type and buffer information.  A close look at this line
shows the following things:
.sk.literal
    VUE type (terminal major minor) buffer  File:name  percent changed
eg.
    VUE (HP2621  INIT   Save) MAIN   File:DELETE   --37%-- *
.end literal
.hl 3 $Bold(Session and Type)
The line always begins with "VUE" to remind you that you are inside the
VUE editor.  The "type" field designates the "caller type" or type of
editing session.  This field is normally blank (as you see in the
example given), however it may contain the name of a >superior process
as explained later in the manual.
.hl 3 $Bold(>Modes>)
Inside the parentheses, you find various different "mode" information:
Terminal is the type of display terminal which VUE beleives it is
talking to; Major is the type of "major" mode which VUE is processing
commands in; Minor is one of the submodes which may be modifying the
major mode or may be providing a service every now and then.  It is
important to note that a number of minor modes may appear at various
times, and sometimes more than one minor mode will be present.  For
example, when ">autosave>" mode is on, the word "Save" will appear in this
area; when you are in search mode the word "SEARCH" will appear.
.hl 3 $Bold(Buffer Name)
.index Buffer Name
The "buffer" field contains the name of your current editing buffer
(this will be explained in more detail later).
.hl 3 $Bold(File Name)
Name is the name of the Tymcom-X file which VUE is reading or visiting
for the current buffer.  If you change buffers or $Bold(read) another
file, this field will change to reflect the current file name.
.hl 3 $Bold(>Percentage or >Location>)
Percent is the percentage of the file which is found before the current
point, and can be thought of as the location of the cursor on the
screen and within the buffer.  This is displayed as a two digit number
with a per cent between two sets of dashed lines.  However, there are
two special cases which are displayed differently:  --TOP-- is displayed
if the pointer is positioned at the beginning (or top) of the buffer
.index --TOP--
.index --BOT--
and --BOT-- is displayed if the ">point>" is positioned at the end (or
bottom) of the current buffer.
.hl 3 $Bold(Change Flag)
.index Change Flag
Changed is a flag which signifies whether the current buffer has been
modified in any way.  If no changes have been made, this field is
blank.  If any changes have been made to the buffer, this field is
displayed as an asterisk ($Bold(*)).

.page
.hl 1 $Bold(Basic Editing Commands)
.index Basic Editing Commands
.hl 2 $Bold(Entering and Exiting VUE)
.index Entering VUE
.paragraph
The most important initial information you will need about VUE is
how to begin and end your editing session.  If you are a "new" user
of VUE, then this is the place to start.  However, once you learn
how to begin and end your session, you should peruse the VUE >tutorial
file to become familiar with the basic commands.
.hl 3;$Bold(Beginning A VUE Session*)
.parh
To begin your session, first determine what it is you wish to accomplish.
Do you want to create a new file?  To modify an existing file? Or to
.index XEXEC
simply peruse a file for reference or copying some text?  Once this is
determined, you will know how to deal with the messages which VUE will
type.  Then$Bold(*), you type the XEXEC command:
.sk.indent 4;_.>CT4
.break;or
.indent 4;_.CT4 filename.ext
.sk
.index CT4
.index question-mark
If you had typed a filename, as in the second example above, VUE will
look to see if you have an existing file with that name.  If you do,
then VUE will automatically go to the next step.  If the file doesn't
exist already, VUE will tell you that the file was not found and then
proceed to get ready to create a new file for you.
.paragraph
At the next step, VUE prompts you with the question:
.sk.indent 4;Enter terminal type (?#for help, E for Exit):
.sk
This question expects a single character response from you.  Typing a
question-mark $Bold(?)  tells VUE to print a list of terminal names and
their appropriate terminal definition characters as follows:
.index Adm3A
.index Beehive
.Index Hazeltine 2000
.index Hazeltine 1500
.index GT40 VT06
.index Heath-Kit 19
.index HP2621
.index Teleray 1061
.index Act4
.index Vt52
.index VT100
.index Tymshare 425
.index Tymshare 444
.tp 16.sk.literal
    Terminals are:
     A    Adm-3A             ^A    Adm-31 (TYM 425)
     B    Beehive             C    Concept 100
    ^E    MIMEs Act4
     G    GP-100             ^G    GT-40 VT06
     H    Hazeltine 2000     ^H    Hazeltine 1500
     I    Infoton             K    Heath-Kit 19
     N    Bantam              P    HP-2621 (TYM 444)
     Q    Annarbor            R    Teleray 1061
     S    Superbee
     V    VT52               ^V    VT100              
     1    DM-1500             2    DM-2500
     3    TEK 4023            4    ACT-IV
     5    TEK 4025            7    TEK 4027
     8    HP-2648             9    Heath 19 (ANSI)
.end literal
.paragraph
VUE then re-prompts with the question:
.sk.indent 4;Enter terminal type (?#for help, E for Exit):
.sk
.index Terminal definition character
You should then type in the terminal definition character for your
terminal type.  For example, if you have a Tymshare model 444 terminal
(also called an HP2621), then you would type the letter "$Bold(P)" in
answer to the question.  If you do not recognize a terminal name as
the name of your terminal, please feel free to ask about the
implementation of your terminal type.  Chances are that your terminal
is installed under a different name and you merely need to find out
what kind of terminal you have.
.paragraph
At this point, you are "ready"  to begin you editing session.
VUE will clear your screen and fill in the various areas of the
screen with the appropriate information.  Notice the information
in the status line area.  It contains information about your
terminal type, your filename and your position in the buffer
which should say ">--TOP-->".  If you are creating a "new" file,
the remainder of your screen will be blank.  If you are editing
an existing file, then the screen will contain the first screen
of text from your file.
.hl 3;$Bold(>Terminating A VUE Session)
.index Terminating a VUE Session
.paragraph
When you've completed your session, you need to tell VUE that
you are done.  Again, you must first determine what action that you
would like to take, $Bold(before) you actually close out your VUE
session.  Do you want to "save" your text and exit to >XEXEC level?
Do you want to simply "save" your text, so that you can edit another
file?  Or do you want to exit without saving anything?
.index Saving text
.index C-X C-S
.index C-X C-C
.index Control-X Control-S
.index Control-X Control-C
.paragraph
The "normal" way to exit is to first save your editing in the current
file and then to return to XEXEC level.  This is accomplished by typing
the command sequence "Control-X#Control-S Control-X#Control-C"
(abbreviated $Bold(C-X#C-S C-X#C-C)).  This command tells VUE that you
are done, you want to "save" your text, and you wish to return to your
superior process (usually XEXEC mode).  VUE then outputs your current
buffer to the currently designated file and returns to XEXEC level (or
your superior process).
.paragraph
To simply "save" the current state of your VUE edits, type the two
character command sequence "$Bold(C-X#C-S)".  This command takes the
current buffer and writes it out to the currently designated file.  Upon
successful completion, VUE returns you to editing level and you may
either continue your edit, edit another file, or "exit" out of VUE.
.tp 5
.paragraph
If you wish to terminate your edit at the current point $Bold(without)
making any changes or saving any changes you may have made, then type
the two character command sequence "$Bold(C-X#C-C)".  This command is useful
to "abort" an edit, or to simply exit after perusing a file.
.paragraph
In review, here is a small table of "save"-ing and exiting commands:
.sk.ts 24
.indent 4;C-X#C-S	$Bold(S)ave the current buffer
.indent 4;C-X#C-C	$Bold(C)all superior, Exit the editor
.indent 4;C-X#C-S  C-X#C-C	$Bold(F)inish edit, Save the buffer and exit
.sk.ts 8,16,24,32,40,48,56,64,72
Please take note that these commands consist of two-character sequences
instead of just a single character.  This is because these commands
are used less frequently than other editing commands and we want to
leave as many as possible of the single-character commands available
to the more commonly used functions.  In later chapters you will notice
this if it is not apparent at this point.

.hl 2 $Bold(Inserting Text)
.index Inserting Text
.index Inserting Control Characters
.paragraph
Now that you know how to begin and end your VUE session, it would be
quite useful to learn what you can do during an editing session.  To
insert printing characters into the text you are editing, just type
them.  Normally (when VUE is at top level), the characters that you type
are inserted into the text at the cursor, which moves forward.  Any
characters which appear after the cursor move forward too.  If the
cursor is between the text "FOO" and "BAR", typing #XX# produces and
displays "FOOXXBAR" with the cursor pointing before the "B".  This
method works for printing characters and space, but other characters
act as editing commands and do not insert themselves.  If you need to
insert a control character, Escape or Rubout, you must quote it by
typing the $Bold(>C-Q>) command first.  (Remember that the "$Bold(C-)"
prefix refers to holding down the "Control" key on the keyboard.  This
is the same as $Bold(_^Q) and if entered as text, this would be it's
representation on the screen.  For text, "control" will be represented
as "_^", while commands will be represented as "C-").
.index Deleting text
.paragraph
To correct text which you have just inserted, you can use ">Rubout>" or
">Delete>".  Rubout deletes the character $Bold(before) the cursor (not
the one that the cursor is on top of or under;  that is the character
$Bold(after) the cursor).  The cursor and all of the characters after
it move backwards.  You can rub out a line boundary by typing "rubout"
when the cursor is at the beginning of a line.
.paragraph
To end a line and start typing a new one, type $Bold(Return).  You can
also use >Return to break a line into two.  A Rubout after a Return will
undo it.  Return really inserts two characters:  a carriage return (_^M)
and a linefeed (_^J), a >CRLF, but almost everything in VUE makes them
look like just a single character, ">newline>", which you can think of as
the line separator character.

.hl 2 $Bold(Moving The Cursor)
.index Moving the cursor
.paragraph
To do more than insert characters, you have to know how to move the
>cursor.  Here are a few of the commands for doing that.
.sk.lm 12
.indent -8;>C-B#####Moves $Bold(b)ackward over one character.
.indent -8;>C-F#####Moves $Bold(f)orward over one character.
.indent -8;>C-A#####Moves to the beginning of the line.
.indent -8;>C-E#####Moves to the $Bold(e)nd of the line.
.indent -8;>C-N#####Moves down one line, vertically.  If you start in the
middle of one line, you end in the middle of the $Bold(n)ext.
.indent -8;>C-P#####Moves up one line, vertically, to the $Bold(p)revious line.
.indent -8;>C-V#####Moves to the next screen full of text.
.indent -8;>M-V#####Moves to the previous screen of text.
.indent -8;>C-L#####Clears the screen and redisplays everything.
.indent -8;>M-_<#####Moves to the top of your text.
.indent -8;>M-_>#####Moves to the end of your text.
.lm 0.sk
There are quite a few other commands which move the cursor, but these
are the basic ones, which you would use all the time.  Try to remember
the following diagram as you edit.  It will help you remember the
orientation of text on the screen.
.sk
.indent 28;Previous Line
.indent 32;$Bold(C-P)
.indent 33;_^
.indent 33;|
.indent 4;Backward Character $Bold(C-B) _<-----+-----_> $Bold(C-F) Forward Character
.indent 33;|
.indent 33;v
.indent 32;$Bold(C-N)
.indent 29;Next Line

.hl 2 $Bold(Erasing Text)
.index Erasing Text
.sk.ts 16
.indent 4;>Rubout	Delete the character before the cursor.
.indent 4;>Backspace	Delete the character before the cursor.
.indent 4;>C-D	Delete the character after the cursor.
.indent 4;>C-H	Same as "backspace".
.indent 4;>C-K	Kill to the end of the line.
.ts 8,16,24,32,40,48,54,64,72
.paragraph
You already know about the Rubout (or delete) key which deletes the
character before the cursor.  On some keyboards, there is a key labelled
">backspace>".  In VUE, this will also act as a "rubout" command.  For
those keyboards which do not have a "backspace" key, the Control-H
($Bold(C-H)) command will serve this function.
.paragraph
The command >Control-D>, ($Bold(>C-D>)) deletes the character after the
cursor, causing the rest of the text on the line to shift left one
character.  If Control-D is typed at the end of a line, that line and
the next line are joined together.
.paragraph
To erase a larger amount of text, use the >Control-K ($Bold(>C-K>))
command, which kills a line at a time.  If Control-K is done at the
beginning or middle of a line, it kills all the text up to the end of
the line.  If Control-K is done at the end of a line, it kills the line
termination character, that is, it joins that line and the next line.
Thus, it takes two invocations of C-K to delete a line of text and its
line terminator.

.hl 2 $Bold(Using Blank Lines Can Make Editing Faster)
.index Inserting blank lines
.paragraph
One  thing  you  should  know is that it is much more efficient to insert
text at the end of a line than in the middle.  So if you want  to  stick  a
new  line  before  an existing one, it is better to make a blank line there
first and then type the text into it, rather than inserting the new text at
the beginning of the existing line and then insert a line separator.  It is
also clearer what is going on while you are in the middle.
.sk.ts 16
.indent 4;>C-O	    Insert one or more blank lines after the cursor.
.ts 8,16,24,32,40,48,54,64,72
.paragraph
To make a blank line, you can type Return and then C-B.  But there is a
single character for this:  C-O.  So, instead of typing FOO Return to
insert a line containing FOO, type C-O FOO.  If you want to insert many
lines, you should type many C-O's at the beginning (or you can give C-O
an argument to tell it how many blank lines to make.)

.hl 2 $Bold(Basic Summary)
.index Tutorial
.paragraph
The commands above are sufficient for creating or editing most simple
texts using VUE.  The more advanced commands just make things easier.
Remember the cross pattern for cursor movement, and that you must "save"
your text before you exit from each editing session.  You may want to
take a "perusal" through the file (SYSNEWS)VUE.TUT and try out some of the
things that you've learned so far.  To do this, first make a copy of this
file using the XEXEC command:
.sk.indent 4;-COPY (SYSNEWS)VUE.TUT,SAME_<cr_>
.sk
Then, enter VUE as though you were about to "EDIT" your newly created
copy using the command:
.sk.indent 4;-CT4 VUE.TUT_<cr_>
.sk
Type your terminal definition character, (or a "?"  to review the list
of supported terminals), then "read" what is on your screen and "follow"
the directions.  VUE will give you a short tutorial about VUE and how
to to use it effectively.  Then, return to this manual for more advanced
features.
.page
.index Numeric Arguments
.hl 1 $Bold(Giving Numeric Arguments To VUE Commands)
.paragraph
Any VUE command can be given a numeric argument.  Some commands
interpret the argument as a repetition count.  For example, giving an
argument of ten to the C-F command (move forward one character) moves
forward ten characters.  With these commands, no argument is equivalent
to an argument of one.
.paragraph
Some commands care only about whether there is an argument, and not
about its value; for example, the command C-@ (Set MARK) with
no arguments sets the mark to the current point, but with an argument it
clears the mark ($Bold(C-U C-@)).
.index Universal Argument
.paragraph
The fundamental way of specifying an argument is to use the >C-U
(Universal Argument) command followed by the optional minus sign and
the digits.  C-U followed by a non-digit other than a minus sign has the
special meaning of "multiply by four".  It multiplies the argument for
the next command by four.  Two such C-U's multiply it by sixteen.  Thus,
C-U C-U C-F moves forward sixteen characters.  It is a good way to move
forward "fast", since it moves about 1/4 of a line on most terminals.
Other useful combinations are C-U C-N, C-U C-U C-N (move down a good
fraction of a screen), C-U C-U C-O (make "a lot" of blank lines), and
C-U C-K (kill four of either the line contents or line separators in
whatever combination they exist.  This usually kills two lines and their
separators).  With commands like C-@ that care whether there is an
argument but not what the value is, C-U is a good way of saying "I want
an argument".
.paragraph
A few commands treat a plain C-U differently from an ordinary argument.
A few others may treat an >argument of just a minus sign differently
from an argument of -1.  These unusual cases will be described when they
come up; they are always for reasons of convenience of use.
$Bold(Please note:  Negative arguments are not currently implemented),
$Bold(but they will be in the very near future.)
.paragraph
There are other, terminal-dependent ways of specifying arguments.  They
have the same effect but may be easier to type.  See the appendix.  If
your terminal has a numeric keypad which sends something recognizably
different from the ordinary digits, it is possible to program VUE to
allow use of the numeric keypad for specifying arguments.
.page
.hl 1 $Bold(The Mark and The Region)
.paragraph
A major feature of VUE which needs to be discussed before we continue
is the ">mark>".  Most of the commands in VUE act upon the text in the
buffer beginning at a specific point, the ">point>", usually the position
of the cursor on the screen.  For example, C-K (Kill Line) kills the
text from the point to the end of the line, or kills the end of the
line if that is where the point is positioned.  Even in this example, we
speak of another point, "the end of the line".  There are many such
points within your text, for example:  the beginning of a line, the end
of the next word, the end of a sentence, the beginning of a paragraph,
the end of a LISP expression, the beginning of a block structure and
many many more.  Since we could not "invent" a command to to cover each
and every one of the possible instances, VUE provides a "mark" which
can be placed on the "object" position of our choice, so that we can
remember a point in the buffer.  We can position the cursor, set the
"mark" and move the cursor elsewhere.  The mark thus becomes a pseudo
"point", and we can "invent" commands which act upon the text between
"point" and pseudo "point" (or "mark").
.index Setting mark
.paragraph
The way to set the mark is to use the >Control-Atsign ($Bold(>C-@>))
command.  Once you set the mark, it stays remembered.  However, it is
important to understand the nature of the mark.  It is an absolute
position within your buffer, thus if you insert or delete text in front
of the mark, you seem to "move" the mark.  It is best to set the mark
and to use the command which needs the mark before you do any large
inserts or deletions "in front of" the mark.
.paragraph
This is not to say you cannot make inserts or deletions in front of the
mark, just that if you make insertions the mark will appear to move
backwards one character for each character you insert, and it wil
appear to move forward one character for each character that you
delete.  It is still useful for remembering your "general" place in
a large document.  Regardless of the insertions or deletions, you will
tend to be left in the same area of the buffer.
.paragraph
Commands which make use of the mark are as follows:
.sk.ts 26
.index C-X C-X 
.index M-X Indent Region
.index M-X Unindent Region
.indent 4;C-@	Set-Erase Mark.
.indent 4;C-X#C-X	Exchange point and mark.
.indent 4;>C-W	Kill region from point to mark.
.indent 4;>M-C-W	Copy region from point to mark.
.indent 4;>M-C-_^	Invert case of region from point to mark.
.indent 4;M-X Indent Region	Indent region from point to mark.
.indent 4;M-X Unindent Region	Un-indent region from point to mark.
.ts 8,16,24,32,40,48,54,64,72

.hl 2 $Bold(Set-Erase Mark)
.paragraph
As mentioned above, the Control-@ ($Bold(C-@)) command is used to set
the mark at the current point.  To clear the mark, you give the C-@
command an argument.  Thus, you type $Bold(C-U C-@) and the mark is
cleared.  It is a wise idea to clear the mark when you are not using it,
because a slip of a keystroke could easily perform one of the following
commands inadvertantly.  However, you need not worry about this too
often, because most commands that use the mark, also clear it as soon
as they are done.  You will also find that commands which require the
mark, do nothing, if the mark is not set.
.hl 2  $Bold(Exchange Point and Mark)
.index Exchange Point and Mark
.index C-X C-X
.paragraph
Before doing anything which references the >mark>, it is good practice
to make sure that you "know" exactly where the mark is positioned.
The "Exchange Point and Mark" command ($Bold(C-X#C-X)) is useful for
exactly this function.  First set the mark and move the cursor to another
point within the buffer.  When you type C-X#C-X, the "mark" position
becomes the "point" position and the ">point>" position becomes the "mark"
position.  Typing C-X#C-X again exchanges them a second time, or puts
them back into their positions before the first C-X#C-X command.
.paragraph
If upon typing C-X#C-X, you find that the position of the mark had
changed from where you thought it was, you can correct that quite
easily.  Since you are now positioned where the mark was, if you move the
cursor to where you want the mark to really be and then type C-X#C-X again,
you will be positioned where you originally started, and the mark will
be where you want it to be.  You are now ready to type whatever command
you were setting up for.

.hl 2 $Bold(Kill Region From Point to Mark)
.paragraph
.index Kill Region Mark
For killing large portions of text, or even more than a few lines, it
becomes tedious to count the correct number of lines each time.  Thus,
if you set the mark at the beginning (or end) of the text you want
killed and then move the cursor to the end (or beginning), you can use
the Kill Region Mark
command to kill the correct text.  To do this, set the mark,
then move to the other end of the text, then type Control-W
($Bold(>C-W>)).  The text will now disappear from the screen and will be
loaded into the "kill buffer".  As such, you can now reposition the
cursor and retrieve that text using the C-Y (Restore Killed Text) 
command described
below.  (See "Restoration of Killed Text").

.hl 2 $Bold(Copy Region From Point to Mark)
.index Kill buffer
.index Copy Region
.paragraph
Since killing text and then repositionning the cursor and restoring the
text is the major way to move text.  The Copy Region function, which is
equivalent to C-W followed by a C-Y was invented.  This function is
important because killing text and then redisplaying the same text can
take a long time depending upon the amount of text killed.  The Copy
Region command is >M-C-W which is typed as >Meta-Control-W (holding down
the "Meta" key and the "control" key simultaneously with the "W" key; On
non-ideal keyboards, typing "Meta" followed by "Control-W").  It is
important to remember that the "copied" text in this instance is put into
the kill buffer, because all the restrictions which are placed upon C-K, C-W
and C-Y in reference to the kill buffer also refer to M-C-W.
.hl 2 $Bold(Invert Case of Region From Point to Mark)
.index Invert Case Region
.paragraph
This command is used for those times when you need to convert something
which is in all "UPPER" case to "lower" case, or vice versa.  It can be
used to invert any amount of text ranging from a few words, sentences,
paragraphs or the entire buffer if necessary.  Set the >mark at one end
of the text to be inverted, and the cursor at the other end.  Then type
>Meta-Control-Arrow ($Bold(>M-C-_^>)) to invert the text.  For inverting
the case of words and characters, see the sections on "English Text
Functions" and some of the "Miscellaneous" or "Advanced" commands.
.hl 2 $Bold(Indent Region From Point to Mark)
.index Indent Region
.paragraph
This command is most useful when indenting a large portion of text, or
when working with a program source for a "block structured" language.
First, set the mark at the beginning (or the end) of the text and
reposition the cursor to the opposite end of the text or block.  Then,
type the command "Meta-X Indent Region" to indent the entire portion of
text one tab stop.  (See the command "Meta-X Indent Line" to indent a
single line).
.hl 2 $Bold(Un-Indent Region From Point to Mark)
.index Unindent Region
.paragraph
Just as you might want to "indent" text for a reason, you may want to
remove that indentation at some later time.  Or, if it is a section of
frequently typed program text, you might want to change the actual
indentation for a particular incandation of the text.  (I am not
promoting the idea of duplicating program text in various different
places.  If a section of code is long enough to copy, it is usually
long enough to make a subroutine out of it and simply reference the
subroutine where applicable).  Anyway, to remove the indentation
one-level, after setting your mark and point, type the command
sequence "Meta-X Unindent Region".

.page
.hl 1 $Bold(Killing and Moving Text)
.paragraph
The most common way of moving text around with VUE is to "kill" it, and
get it back again, after you have repositioned the cursor.  In fact,
except for some very specialized commands, this is the "only" way to
move text around inside your buffer.
.hl 2 $Bold(Deleting and Killing)
.paragraph
Most commands which erase portions of text from your buffer save it so
that you can retrieve it.  If you change your mind, or you decide you
want it copied to another part of your buffer, you simply have to
position the cursor to the point where the text "should" be, and
"un-kill" the text.  The commands which save the text as they >delete it
are known as ">kill>" commands.  The rest of the text deletion commands
(which simply delete and discard the text), are known as "delete"
commands.  The "delete" commands include C-D and Rubout, which act on
single characters, and those commands which only delete blank space or
blank lines.  In general, any command which can destroy a significant
amount of non-trivial data will "kill" the text rather than just "delete"
it.  In the "Command Index", the names and descriptions use the words
"kill" or "delete" to say which they do.  If you do a kill command by
mistake, you can always "un-kill" it.
.sk.ts 16,24,32
.indent 4;>C-D	Delete next character.
.indent 4;>Rubout	Delete previous character.
.indent 4;>C-H	Delete previous character.
.indent 4;>M-D	Delete the next word.
.indent 4;>M-Rubout	Delete previous word.
.indent 4;>M-H	Delete previous word.
.indent 4;>M-_\	Delete leading spaces or tabs on a line.
.indent 4;>C-K	Kill rest of line, or one or more lines.
.indent 4;>C-W	Kill region (from point to mark).
.indent 4;>M-W	Kill search region (from point to "string").
.ts 8,16,24,32,40,48,56,64,72

.hl 3;$Bold(Character and Word Deletion)
.index Delete Horizontal Space
.paragraph
You already know about "$Bold(rubout)" and $Bold(C-D) from the earlier
discussions.  All these commands delete characters.  $Bold(C-H) (or
backspace) also works to delete a character just after it is entered.
In the same way, $Bold(Meta-D), $Bold(Meta-Rubout) and $Bold(Meta-H)
have the corresponding effect on words.  (Please refer to the section on
"Commands for English Text" for more information on "word" commands).
Because of the "limited" way in which the "save" area is implemented,
these commands always delete text.  There is also a command to delete
"blank" space between the current point and the next non-blank
character on a single line.  This is performed by the "Delete Horizontal
Blank Space" function which is typed as a Meta-_\ ($Bold(M-_\)) on
your keyboard.  You will find this command useful, when you have some
combination of spaces and tabs, and you simply want to replace it with
some "known" quantity of spaces, tabs, or other text.


.hl 2 $Bold(The "KILL" Buffer)
.index Kill buffer
.paragraph
The remainder of the commands in the above list, are "$Bold(kill)"
commands.  Each time they are invoked, the text which is "killed" is
added to a special buffer called the "kill buffer".  At present, this is
only a single storage area with an approximate maximum of about 25,000
characters, (that is about 10 disk pages of text).  The importance of
only having "one" area means that each "new" kill, expunges the old
text and replaces it with the new text.  If you kill multiple lines,
they are kept together as "one" complete string.  VUE allows you to kill
these lines either as a group, or individually.  As long as you do not
perform any of the "cursor" movement commands, each set of consecutive
kills is appended together.
.paragraph
However, if you make a small killing and then move the cursor, (even if
you move it back to its original position), the "next" kill that you make
will erase the contents of the "kill buffer" and replace it with the
newly "killed" text.
.hl 3;$Bold(Killing Text on Lines)
.paragraph
You know about >C-K from the earlier discussions and from the exercises
you were asked to do inside the VUE tutorial.  The only "major" item to
remember about this command is that each invocation, only kills the
contents of a line, "$Bold(or)" its terminator.  The command
$Bold(C-U#C-K) will delete four blank lines or two lines and their line
terminators (or any combination of the above)!
.hl 3;$Bold(Killing Text in a Region)
.paragraph
The >Control-W ($Bold(>C-W>)) command is used to kill the text in the
region which is bounded by the "point" at which the cursor is located,
and some other pre-determined "mark" which you have made.  Regardless of
the direction, forward or backward from the cursor, all of the text
between the cursor and the mark is killed $Bold(and) (if it is not too
large) put into the kill buffer.
.index M-C-W
.index Copy Region
.paragraph
The >Meta-Control-W commands works in identically the same fashion as
Control-W.  It is typed on "most" keyboards by entering the "Meta"
prefix character, followed by the $Bold(C-W) key combination.  This
command, simply "copies" the text which resides in the specified region
into the "kill buffer".  It is much more useful to use this command
than to "kill" the text and restore it, if you just want to copy it to
another point in the buffer. (It is also faster and more efficient).
.index Kill Search Region
.paragraph
Then, there are times when you want to delete a portion of text, and
you know that the other boundary of the "region" you want to kill
includes a specific character sequence which doesn't occur within that
same region.  Then you can use the "Kill Search Region" command,
">Meta-W>" ($Bold(>M-W>)).  This command automatically sets the "mark" at
your starting location, and performs a "complete-string" search for the
specified character sequence.  Once found, it backs up to the near side
(beginning) of the string and kills all the text between the mark and
the "new" point.  To search in the reverse direction, simply specify the
command with an argument of four, using $Bold(C-U#M-W#"string"#_<esc_>).

.hl 2 $Bold(Restoration of Killed Text)
.index Restore Killed Text
.paragraph
Now that you know all about "killing" your text, you should learn how
to "un-kill" whatever you've done.  This is done using the >Control-Y,
($Bold(>C-Y>)), or "Restore Killed Text" command.  Remember that there is
only "one" kill buffer, and that whenever you restore text, it is always
coming from the same place.  This is important!  Because, if you want
to restore your text, you simply "un-kill" it.  If you want to make
a "copy" of your text, you reposition your cursor (or leave it where it
is), and simply "un-kill" the text a second time.  Each time you type the
un-kill command, you will get another copy of your text.
.paragraph
When you've finished making as many copies of your killed text as you
desire, you are free to kill some more text.  Remember, that when you
make another "kill", you erase the contents of the kill buffer and
you fill it with the new text.

.page
.hl 1 $Bold(>Searching>)
.index Incremental Search
.index Reverse Incremental Search
.index String Search
.index Reverse String Search
.paragraph
There are currently two different ways to do searching:  Incremental
searching and complete-string searching.  The reason for having two
modes of searching is that initially the author wrote the
complete-string search mode and implemented it as the default search
command.  When the incremental mode was complete, it was simply added as
an additional set of commands.  However, in implementing VUE at
Tymshare, the incremental mode was the preferred mode and is
implemented as the default.  Search commands are summarized as follows:
.sk.ts 16
.indent 4;>C-S	Incremental Search
.indent 4;>C-R	Reverse Search
.indent 4;>M-S	String Search
.indent 4;>M-R	Reverse String Search
.indent 4;>M-C-S	Incremental Search (Same as C-S)
.indent 4;>M-C-R	Reverse Search (Same as C-R)
.indent 4;>M-W	Kill Region String


.hl 2 $Bold(Incremental Search Mode)
.index Incremental Search Mode
.paragraph
Incremental searching is actually simpler than "complete-string"
searching, because you do not need to enter and exit search mode
as often to accomplish the same amount of work.  It is also more
efficient because you do not need to type as many keystrokes.
.paragraph
To enter Incremental search mode, simply type "$Bold(>C-S>)" for forward
searching or type "$Bold(>C-R>)" for searching in the reverse direction.
Searches in either direction work basically the same, as follows.  When
you type $Bold(C-S) the prompt "$Bold(I-Search)" appears near the
bottom of your screen.  The cursor remains where it is on the screen.
Now, as you type in your string, VUE incrementally does the search.  Thus,
if you were searching for the string "abcd", as you type, VUE searches for
the string "a", then the string "ab", then "abc" and finally "abcd".  After
each successive search, VUE shows you your position in the text, thus you
tend to find what you are searching for without having to type the entire
text string.  This is extremely useful when you do not remember the exact
spelling of an entire word or name.  To terminate your search, you type
an _<Esc_> character ($Bold(_$)).
.paragraph
If you type another $Bold(C-S) while you are in incremental search mode,
VUE automatically advances to the next occurrence of the search string
which has been typed so far.  In this instance, you notice that typing
the second or succeeding C-S's is like typing other regular commands
to VUE.  While you are in incremental search mode, VUE allows you to type
other VUE commands as well.  However, as mentioned above, typing an
_<esc_> (which is normally the "Meta" prefix) terminates the search.
Thus, while in incremental search mode, VUE rebinds the MetaPrefix value
to the >Control-_\ ($Bold(>C-_\>)) key.  To type Meta-F on a non-ideal
keyboard you can type $Bold(C-_\ F).
.paragraph
For those users who prefer to redefine their Meta keys as something other
than the "escape" key, there are two customizations which are available
which will cause somewhat different behavior.  First of all, you can
redefine both your _<esc_> function and your MetaPrefix keys to any other
key on your keyboard (see the section on "modes" and "parameter setting").
If you redefine both the _<esc_> function and the MetaPrefix to be the
"same" other key, then the behavior will be as described above.  If you
redefine either or both functions to different (non-alike) keys, then
VUE will not rebind Meta to control-_\.  Thus, you can feel free to use
C-_\ for whatever rebinding that you prefer.
 
.hl 2 $Bold(Failing Incremental Searches)
.index Failing Incremental Seach Mode
.paragraph
When the search fails, you are not taken out of search mode.  Instead,
you are notified that the search has failed and you enter a sub-mode
called "failing incremental search" mode.  The prompt at the bottom of
the screen changes from "I-Search:"  to "Failing I-Search:"  with the
erroneous search string after the prompt.  In this mode, you can type
rubouts to the search string to correct it.  Thus, if you meant to type
"abcd" and you typed "abcf" instead, you can type rubout to erase the
"f" and then type the correct letter ("d").  If there was no occurrence
of the string "abcf", then you will still be at the point of the "abc",
however, if there was an occurrence in the direction that you were
searching, you will be left at the point$Bold(*) where the "abcf" was
found.
.paragraph
At any time while you are in incremental search mode or "failing"
incremental search mode, you may return to non-searching mode by typing
an _<Esc_> or a Control-G ($Bold(C-G)).  Control-G is the general "quit"
or "gasp" command character.  It tells VUE that you want it to stop
whatever it was doing and return to VUE command level.

.hl 2 $Bold(Complete-String Search Mode)
.index String Search
.index Complete-string Search Mode
.paragraph
Complete-string search mode is very similar to "Incremental" search mode.
To perform a "complete-string" search you type the command >Meta-S ($Bold(>M-S>))
followed by the string you wish to search for, followed by an _<esc_>.
The main difference is that VUE waits until you type an _<esc_> before
it begins its search.
.paragraph
In the above example, searching for the string "abcd", you would type
M-S then the string "abcd" followed by an _<esc_>.  VUE then attempts to
find the specified string.  If found, the new location is shown on the
screen, with a new screen being redisplayed if necessary.  If the string
is not found, VUE prints the message "Search Failed" in the echo area
of the screen.
.paragraph
As with "incremental" search mode, you can also search for multiple
occurrences of the current search string.  The way to do this is to
type the M-S command to request a search string, and then immediately
type an _<esc_>.  A null search string tells VUE to search again.
If you have not previously searched for anything, VUE will simply
print an error message in the echo area of your screen, and return
the cursor to its current point on the screen.
.paragraph
The "complete-string" search mode is not as keystroke efficient as the
incremental-search mode, however, it is more output efficient.  If you
are working on a slow-speed display terminal, this mode of searching
would be slightly faster.  Again, this depends upon the text and the
nature of the strings you search for.
.hl 2 $Bold(Reverse Searches)
.paragraph
In the above sections, we have discussed only the forward search modes.
For the reverse incremental search and the reverse complete-string
searches, the commands simply mirror the forward mode searches.  The
command for reverse incremental searches is >Control-R ($Bold(>C-R>)) and
the command for reverse complete-string searches is >Meta-R ($Bold(>M-R>)).
In each mode, the reverse search works identically with the forward
search mode except that the cursor is left positioned at the beginning of
the specified string.

.hl 2 $Bold(Kill Region From Point to String)
.index Kill Region String
.paragraph
This command is really a text deletion command, but due to its nature
as a "search" command it is included in this section.  In function, this
command remembers the point at which it starts by automatically setting
the mark and then performs a complete-string search for the specified
string.  If it finds the specified string, it then kills all the text
from mark to the point at the "beginning" of the string.  If it doesn't
find the string, it prints a message in the echo area of the screen
"Wipe string not found" and repositions the point and the cursor to the
starting location.  It is important to note the side-effects of this
command before you use it:  The location of the "mark" is changed to be
your starting point.

.page
.hl 1 $Bold(Replacement Commands)
.index Search-and-replace
.paragraph
Global search-and-replace operations are not used as often in display
editors as they are in non-display editors.  However, they do serve an
important function and thus are provided for completeness.  There are
two basic types of global replacement implemented in VUE:  Simple
replacement mode which simply replaces the specified string and Query
replacement mode which finds each occurrence of the string and asks you
what you would like to do with it.
.tp 25
.hl 2 $Bold(Simple Replacement Mode)
.index Replace String
.index Simple Replacement Mode
.paragraph
To replace every occurrence of a specified string following the current
point in the text, you type Meta-Dollarsign ($Bold(>M-_$>)) followed by
the string to search for, then an _<esc_> followed by the string to
replace it with, then a final _<esc_>.  For example, to search for
"abcd" and replace it with "efgh", you would type the command:
.sk
.indent 4;M-_$abcd_<esc_>efgh_<esc_>
.sk
What actually happens is that when you type M-_$ command, VUE prompts
you for the string to search for with the message "Old String:"  in the
echo area.  When you type the first _<esc_> character, VUE changes the
prompt to "New String:"  to let you know what it is waiting for you to
enter next.  When you type the final _<esc_>, VUE begins searching
throughout the remainder of your buffer for each occurrence of the
"Old String" and replaces it with the "New String".
.paragraph
This function also provides a nice way to search for every occurrence
of a character string and delete it.  To do this, simply type two
_<esc_> characters in a row after you have typed in the "Old String"
part of the command.
.sk
.indent 4;M-_$delete-this-string_<esc_>_<esc_>
.sk

.page
.hl 3;$Bold(Query Replacement Mode)
.index Query Replace String
.index Query Replacement Mode
.paragraph
Query replacement mode works basically the same way as the "simple"
replacement mode.  The command is >Meta-_% ($Bold(>M-_%>)), which is
followed by the strings as in the "simple" replacement mode.  However,
after you type the second _<esc_> character, VUE will position the
cursor at each occurrence of the "Old String" and wait for you to
decide what to do with it.  That is, VUE will "pause" and wait for you
to type one of the following responses:
.lm 12
.sk.indent -8
_<$Bold(Space)_>#Space:  Replace this occurrence of the string with the
"New String" and prompt again at the next occurrence.
.sk.indent -8
($Bold(!))#####Exclamation Point:  Replace this occurrence of the string
with the "New String" and all further ones without prompting.  (As if
you had asked for "Simple" replacement mode at this point).
.sk.indent -8
$Bold(Rubout)##Rubout or Delete:  Leave this occurrence of the string
$Bold(untouched), go to the next occurrence and prompt again.
.sk.indent -8
_<$Bold(Esc)_>###Escape or Altmode: Leave this occurrence of the string
untouched as for "Rubout" and then exit from query replace mode.
.sk.indent -8
($Bold(.))#####Period: Same as "space" followed by _<esc_>; Replaces the
current occurrence of the sting and then exits from query replace mode.
.sk.indent -8
$Bold(C-G)#####Control-G: Same as _<esc_>; Exit from query replace mode
without making the replacement.
.sk.indent -8
($Bold(?))#####Question mark:  Types out an on-line help message about
query replacement mode and the current options available.
.sk.lm 4
Anything else is interpreted as a "rubout", and no replacement is done.
VUE continues on to the next occurrence and prompts again$Bold(*).
.lm 0
.paragraph
Thus, query-replace mode provides a mechanism for global replacements
with allowances for individual decision making for each instance or
occurrence of a particular sequence of characters in the text.  
When the end of the text is reached, VUE will notify you that it is
finished with the Query Replace and leave the cursor positioned at
the last instance of either the "old" or "new" string, depending upon
the last decision that you made.  This is the same response you receive
after specifying _<esc_>, period or C-G for an occurrence.
.paragraph
However, it is important to note that if you tell VUE to enter "simple
replacement" mode, it will continue until it finds the last occurrence
of your string and then leave the cursor positioned at that point in the
text.

.page
.hl 1 $Bold(Commands for English Text)
.index English Text Functions
.index English Text Commands
.index Editing Text
.paragraph
In the sections above, we have talked mostly about characters,
lines and display screen pages.  That doesn't seem to have much to
do with editing "Text".  However, the previous sections contained
the "basic" material upon which everything else is built.
.paragraph
Similar commands exist to perform "all" of the functions you have
learned so far, but instead of working on characters or blank space,
these commands work on those things which you are more familiar:  VUE
enables you to manipulate manipulate words, sentences and complete
paragraphs as well.
.hl 2 $Bold(Word Commands)
.index Word Commands
.paragraph
By convention, the majority of "basic" commands are prefixed by using
the "Control" key on your terminal.  The "word" commands follow the
same pattern, however, they are all prefixed by the "Meta" key:
.sk.ts 16,24
.indent 4;>M-F	Move $Bold(F)orward over a word.
.indent 4;>M-B	Move $Bold(B)ackward over a word.
.indent 4;>M-D	$Bold(D)elete forward to the end of the "next" word.
.indent 4;>M-H	Delete  backward to start of the "previous" word.
.indent 4;>M-Rubout	Delete  backward to start of the "previous" word.
.ts 8,16,24,32,40,48,56,64,72
.paragraph
Notice how these commands form a group of parallels with all of the
character based commands C-F, C-B, C-D, C-H and Rubout.  This was
"planned", to make learning and using the commands much easier.
.index Forward Word
.index Backward Word
.paragraph
The >Meta-F (Forward Word) and >Meta-B (Backward Word) move forward and
backward over words.  Like their "Control-" character analogues, both
Meta-F ($Bold(>M-F>)) and Meta-B ($Bold(>M-B>)) will move over several
words, if given an argument.  Forward motion stops immediately after the
last character of the "passed" word and backward motion stops right
before the first character of the word.
.index Delete Word
.paragraph
It is "easy" to kill a word at a time.  >Meta-D ($Bold(>M-D>)), the command
to "delete" forward one word, deletes the next word after the point.  To
be precise, it kills everything between the current point and the last
character of the next or current word, the same place where Meta-F
would have placed you.  If the point was in the "middle" of a word, only
the latter half of that word is deleted.  Generally, most punctuation
characters between the point and the end of the word will also be deleted,
but not all punctuation, so be careful.
.index Rubout Word
.paragraph
If you want to delete the next word, but not the punctuation in front
of it, then you should use "Meta-F" to position you to the end of the
word, then use >Meta-Rubout or >Meta-H (Rubout Word) function
to do this.  As always, most VUE commands can accept a numeric argument,
and "n" words will be deleted.

.hl 2 $Bold(Sentence), $Bold(Paragraph and Page Commands)
.index Sentence Commands
.index Page Commands
.index Paragraph Commands
.paragraph
Again, by convention, the commands to manipulate sentences and
paragraphs, also parallel a subset of "Control" prefix commands, and
are themselves prefixed with the "Meta" key.  At present, the "sentence"
commands are not implemented, but as they will be added in the near
future, it is best that they appear with the documentation for
completeness:
.sk.ts 16,24
.indent 4;>M-A	Move to the beginning of the sentence.
.indent 4;>M-E	Move to the end of the sentence.
.indent 4;>M-K	Kill this or next sentence.
.indent 4;>M-[	Move back to previous paragraph boundary.
.indent 4;>M-]	Move forward to next paragraph boundary.
.indent 4;>M-{	Move back to the beginning of this page.
.indent 4;>M-}	Move forward to the end of this page.
.indent 4;>C-X#[	Move back to the beginning of the previous page.
.indent 4;>C-X#]	Move forward to the beginning of the next page.
.indent 4;>C-X#Rubout	Kill back to the beginning of the sentence.
.ts 8,16,24,32,40,48,56,64,72

.hl 3;$Bold(Sentences)
.paragraph
The >Meta-A ($Bold(>M-A>)) and >Meta-E ($Bold(>M-E>)) commands work exactly
like their Control-A and Control-E counterparts.  However, there is one
special exception.  Meta-A positions you at the beginning of the current
sentence.  If you are at the beginning, "nothing happens"!  Meta-E will
position you at the end of the current, or "next" sentence, depending
upon the current position of the point.  If you are positioned somewhere
before the end of the current sentence, you will be repositioned at the
end.  If you are already located at the "end" of the current sentence,
you will be moved to the end of the "next" sentence.  This provides a
mechanism for moving through a document, sentence by sentence, but when
you want to want to back up, you will only be moved to the beginning of
the current sentence.
.index Kill Sentence
.paragraph
The >Meta-K ($Bold(>M-K>)), Kill Sentence, command is used to kill all the
text from the current point to the "end" of the current or next
sentence.  The behavior of Meta-K can be thought of as similar to that
of Meta-E.  Multiple invocations will cause succeeding sentences to be
deleted, including the "period" (or other punctuation character).
To delete backward to the beginning of the current sentence, use the
extended command sequence Control-X#Rubout ($Bold(C-X#Rubout)).  The
behavior of this command on the "beginning" of the current sentence has
not yet been determined, but I suppose that it will suffer from the
same restrictions which have been placed upon Meta-A.
.hl 3;$Bold(Paragraphs)
.index Pargraph Commands
.paragraph
First, it would be helpful to "define" in somewhat loose terms, what
VUE thinks is a paragraph.  Generally, any portion of text which does
not contain imbedded indented lines or document processing commands
where one would expect to find text, is considered to be a single
paragraph.  The "beginning" is roughly the first group of more than
one "blank" line or an indented line, or a document-processor command
such as found in RUNOFF and PUB sources.  The "end" is considered to
be the occurrence of the beginning of another paragraph or the
end of a page or buffer.
.paragraph
The two commands, >Meta-[ and >Meta-], ($Bold(>M-[ and >M-]>)) simply move
forward or backward to the "next" paragraph boundary.  If you are within
a paragraph and type "M-[", you will be positioned at the top of the
current paragraph.  A second M-[ will leave you at the "end" of the
previous paragraph.  A third, would leave you at the "beginning" of that
paragraph, and so on.  Likewise, in the forward direction.  The paragraph
commands simply provide a way to move quickly from major sources of
text to other major portions of text, not to move to a particular
point within them.

.hl 3;$Bold(>Pages>)
.index Page Mode
.index Page Commands
.paragraph
A page is the text that falls between the beginning of the text
and the first page mark, between two page marks or between the
last page mark in the text and the end of the text.  VUE normally
prevents you from looking past the end of the page that you are on.
This tends to keep the display a little neater.  However, the "Page
Mode" variable is settable so that you can see past page marks if
you wish.  This is done with the Meta-X Set Mode Parameters command.
.index Beginning of Page
.index End of Page
.paragraph
However, in either mode, it is desireable to be able to quickly move to
the top or bottom (beginning or end) of a page.  These two functions are
accomplished by the $Bold(>Meta-{>) (Beginning of Page) and
$Bold(>Meta-}>) (End of Page) commands.  The Meta-{ command usually
positions you at the top left corner of the screen since this is almost
always where the page starts, however, if you have "Page Mode" turned
off, and the beginning of the page you are in is already being
displayed, you will merely have the cursor moved into that position.
Meta-} tends to leave you positioned between the middle and the bottom
of the screen.  However, again, this is dependent upon the state of the
"Page Mode" flag.
.index Previous Page
.paragraph
The command >Control-X#[ (Previous Page) moves the point backward in the
buffer until you are either at the beginning of the buffer, or have
reached the beginning of the previous page.  Otherwise, it is identical to
the "Beginning of Page" command.
.index Next Page
.paragraph
The command >Control-X#] (Next Page) moves the point forward until you
reach either the end of the buffer or the top of the next page.  This
command differs from the "End of Page" command in that you are alwyas
left at the beginning of a page when possible.  If there is no "next"
page, then you are left pointing to the "end" of the buffer.


.page
.hl 1 $Bold(Data Organization)
.paragraph
In the above sections we have discussed many of the basic editing
elements available in VUE.  However, we have not said anything about
the organization of the text which VUE is acting upon.  There are two
distinct sources of data which are important to understand:  "files"
and "buffers".  The major difference between these is that >files are
considered external to VUE while >buffers are an integral part of the
internal structure.

.hl 2 $Bold(Buffers)
.paragraph
VUE is actually implemented to edit a buffer, which generally contains
text of some kind.  This buffer currently resides completely in memory
and thus any section of the text which it contains can be accessed
rather quickly.  This is an important piece of information, because your
entire text exists in this buffer, and thus you can only edit as much
text as can be fit into memory at once.  (The current limit is now
approximately 256,000 characters or 100 disk pages). But you need not
concern yourself with this unless you need to edit very large files.
.paragraph
When we speak of "the buffer", which contains the text you are editing,
we have given the impression that there is only one.  In fact, there may
be many of them, each with its own body of text.  At any time only one
buffer can be "selected" and available for editing, but it isn't hard
to switch to a different one.  Each buffer individually remembers which
file it is visiting, what modes are in effect, and whether there are
any changes that need saving.
.index MAIN buffer
.index DELETE buffer
.paragraph
Each buffer in VUE has a single name, which normally doesn't change.  A
buffer's name can be from one to six characters long and should contain
only legal filename characters.  A newly started VUE session has only
one buffer, named "MAIN" which defaults to visiting a file named
"DELETE" if one was not specified on the command line.  The name of the
currently selected buffer, and the name of the file visited in it, are
visible in the status line when you are at top level.
.paragraph
A buffer can, if ordered to, remember many other things "locally",
besides the visited file and the major mode.  This information is kept
for each buffer.  (For example:  the current location of the mark and the
current point are available, but only certain operations request to use
this additional information).
.paragraph
The whole idea of having a buffer which remembers vital information
about itself is so that you are able to edit more than one file at the
same time without losing the state that you have built up during a
particular editing session.  This is very useful when you want to
copy only a small portion of one file into another, or if you are
re-organizing the contents of several files at once.  The following
list of commands is used for manipulating your VUE buffers:
.sk
.index C-X B
.index C-X C-B
.index Create buffer
.index Select Buffer
.indent 4;C-X#B	Select or create new buffer.
.indent 4;C-X#C-B	List the existing buffers.

.hl 3;$Bold(Creating and Selecting Buffers)
.paragraph
To create a new buffer, you need only think of a name for it (say,
"FOO") and then do $Bold(C-X#B FOO_<cr_>), which is the command
$Bold(C-X#B) (Select Buffer) followed by the name.  This makes a new,
empty buffer and selects it for editing.  The new buffer is automatically
set to visit the default filename "DELETE".  To tell VUE to use this
buffer for a specific file use the $Bold(C-X#C-R) command which is
discussed below.  Each buffer has its own major mode; the new buffer's
major >mode is taken from the value of the variable Default Major Mode,
or from the major mode of the previously selected buffer if that
variable is the null string.  Normally this is "INIT" mode.

.hl 3;$Bold(Using Existing Buffers)
.index List Buffers
.index C-X C-B
.paragraph
To get a list of all the buffers that exist, do $Bold(C-X#C-B) (List
Buffers).  Each buffer's name, major mode, and visited filenames are
printed.  A star at the beginning of a line indicates a buffer which
contains changes that have not been saved.
.paragraph
To return to buffer FOO later after having switched to another, the
same command $Bold(C-X#B FOO_<cr_>) is used, since $Bold(C-X#B) can
tell whether a buffer named FOO exists already or not.  It does not
matter whether you use upper case or lower case in typing the name of a
buffer.  $Bold(C-X#B Main_<cr_>) reselects the buffer Main that VUE
started out with.  Just $Bold(C-X#B_<cr_>) reselects the default buffer
(which currently is also "Main").

.hl 2 $Bold(Files)
.paragraph
>Files represent collections of information such as program sources,
reports, program data and text.  For the purposes of this manual, we
can consider all of these to be simply "text".  The following is a
list of commands which perform useful file operations:
.sk.ts 30
.index C-X C-V
.index C-X C-R
.index C-X C-K
.index C-X C-W
.index C-X C-S
.index Insert File
.index Execute File
.index Finish File
.index Save and Run Superior
.indent 4;C-X#C-V	$Bold(V)isit a file, use a new buffer.
.indent 4;C-X#C-R	$Bold(R)ead a file into the current buffer.
.indent 4;C-X#C-K	Read $Bold(K)illed buffer file into memory.
.indent 4;M-X#Insert File	Insert or Include the specified file.
.indent 4;M-X#Execute File	Execute command input from a file.
.indent 4;C-X#C-W	$Bold(W)rite into the specified file.
.indent 4;C-X#C-S	$Bold(S)ave into the current file.
.indent 4;M-X#Finish File	$Bold(F)inish, Save text and Exit to Superior.
.indent 4;M-X#Save and Run Superior	Save text and return to RPG.
.ts 8,16,24,32,40,48,56,64,72

.paragraph
In the earlier discussion about terminating your VUE session, we
discussed ways to "save" your text in a file.  Well, VUE can do
many other things with files and that is what this section will talk
about.

.hl 3;$Bold(Visiting New or Existing Buffers)
.index Visit File
.paragraph
It can be convenient to think of files as "buffers", because to VUE,
>files are merely "external" >buffers which can be read or visited.
When you switch from one buffer to another buffer using VUE, you actually
write the contents of your first buffer into a special VUE "buffer
file" and read in another "buffer file".
.index C-X C-V
.paragraph
You can also read a file into its own newly created buffer, all with
one command:  $Bold(C-X#C-V), followed by the filename.  The first name
of the file becomes the buffer name.  $Bold(C-V) stands for "Visit",
because if the specified file already resides in a buffer, that buffer
will be re-visited.  So you need not remember whether you have brought
the file in already or not.  A buffer created by $Bold(C-X#C-V) can be
reselected later with $Bold(C-X#B) or $Bold(C-X#C-V), whichever you
find more convenient.
.paragraph
If the buffer with the same name that C-X#C-V wants to use already
exists but with the wrong contents (often a different file with a
similar name), then VUE currently ignores$Bold(*) the filename that you
typed and simply selects the buffer it already knows about.  Note that
this will probably change in the future, so do not rely on this exact
behavior.

.hl 3;$Bold(Reading Files)
.index C-X C-R
.index Read File
.paragraph
Reading files is essentially the same as visiting a file.  The major
difference is that "visiting" creates a new buffer (or uses an existing
buffer with the correct name) while "reading" simply erases the current
buffer and reads in the newly specified file.  In the example above,
where C-X#C-V was used to visit a file and a buffer was found with the
same name, but with the wrong text, reading the file would insure that
the proper text and file would be used.  The normal procedure would be
to first select the buffer using the $Bold(C-X#B) command, then to read
in the new file using the $Bold(C-X#C-R) command.

.hl 3;$Bold(Reading Old or Killed Buffer Files)
.index C-X C-K
.paragraph
As mentioned previously, each time you switch buffers in VUE, your
buffer is written into a special "buffer file".  These buffer files are
usually left around when you exit from VUE and you must delete them
manually.  VUE does this for your convenience (believe it or not!).  Each
time you select a file for editing, VUE creates a buffer for it and
creates a buffer file.  When you switch buffers or exit from VUE, the
current state of your buffer is generally saved.  The next time you
enter VUE, you have the option of continuing your edit "precisely"
where you left off, or with a new copy of your buffer.  The advantage of
continuing where you left off is that you don't have to scout around
and find the point where you last were, and VUE doesn't have to go
through the work of creating a "new" buffer file for you.
.paragraph
The way to access an old buffer is simply to type the command:
.sk
.indent 4;$Bold(C-X#C-K) buffername _<esc_>
.sk
Another important piece of information is that you can use this feature
to recover your edit after a system crash or other serious system error
which might have affected your editing session.  The way to do this is
to simply enter VUE without specifying a file to edit.  There are two ways
to do this:
.sk
.indent 4;-R CT4
.break;or
.indent 4;-R VUE
.sk
After specifying your terminal definition character, VUE will then be
waiting for a command.  You should then determine what the name of the
buffer you were editing in was.  This will normally be the buffer "MAIN"
but could possibly be another buffer if you were using multiple
buffers.  Then simply tell VUE to select the old buffer using the
command sequence, "$Bold(C-X#C-K#buffername#_<esc_>)".  VUE will then
restore your buffer to the last "known" state.  This "known" state is
nominally the state remembered at the time of the last "autosave".
Thus, it is both useful and a good idea to have VUE set to perform
autosaves for you.  These "saves" are into the "buffer" file and not in
your "actual" file.  This is important to remember.

.hl 3;$Bold(Inserting or Including Files)
.index Insert File
.paragraph
There are also times when you would like to copy the entire contents of
one file into the file you are editing.  This can be accomplished by
first positioning yourself at the point where you whould like to insert
the other, file and then using the extended command $Bold(M-X#Insert#File).
Extended commands are typed exactly like other commands, however, these
commands are selected by "name" rather than by keyboard character. The
format of this command is:
.sk.indent 4;M-X#Insert File _<esc_> filename _<cr_>
.sk
VUE will leave you positioned at the end of the inserted text.  If you
would prefer to be positioned at the beginning of the newly inserted
text, you may do this by first setting the mark with $Bold(C-@), then
inserting the text, then switching point and mark using the
$Bold(C-X#C-X) command.

.hl 3;$Bold(Command Files)
.index Command File
.index Execute File
.paragraph
A similar function would be to have VUE read a file, but instead of
inserting that file at the current point, having VUE interpret that
file as a set of keyboard commands.  This is performed by using the
extended command sequence $Bold(M-X#Execute#File).  This command is
especially useful if you are customizing your VUE session by rebinding
functions, setting or resetting parameters, defining macros, etc.  You
may also perform very complicated commands by placing them into a file.
(See the sections on Macros and VUE.INI later in this manual).

.hl 3;$Bold(Saving Text in Files)
.index auto-save
.paragraph
In the previous section, we discussed briefly the "auto-save" feature
of VUE.  We noted that the "save" was that of your buffer and not that
of your actual file.  This is so that you would not lose your entire
edit if the system were to go away while you were somewhere within a
long editing session.  But, we don't want to overwrite your original
file without your approval, thus, the auto-save feature "only" saves
your current buffer. (See the section on "Mode Parameters" for more
information on how to set the "auto-save" feature.  This is normally
set to save every 100 commands by default).
.paragraph
There are many reasons that you may want to save the current state of
your edit.  A few of these are:  that you just want to feel "safe", that
you are going to do something massive and you want a "good" copy, or
that you are going to edit another file and you don't want to "forget"
to save this one.  All of these are "good" reasons, and you should
"save" the state of your edits every so often, just to insure yourself
against major mishaps.  If you want to save your edit yourself, then we
allow you to write into your original file, or to any other file that
you would like.  The following commands all perform some sort of
"saving" or "writing" into real files on your directory:
.sk.ts 32,40
.index C-X C-S
.index C-X C-W
.index Finish File
.index Save and Run Superior
.indent 4;C-X#C-S	$Bold(S)ave the buffer in the current file.
.indent 4;C-X#C-W	$Bold(W)rite the buffer into another file.
.indent 4;M-X#Finish File	$Bold(S)ave the buffer and $Bold(E)xit.
.indent 4;M-X#Save and Run Superior	$Bold(S)ave the buffer and $Bold(E)nter RPG.

.hl 4;$Bold(Saving the Current File)
.index C-X C-S
.index Save Current Buffer
.paragraph
To save the current state of your text in the current buffer that you
are using and in the current file you have selected, you type the
command:  "$Bold(C-X#C-S)".  You will note that this command takes no
arguments and will only "save" everything in its current place.  To
make a distinct copy of your text, in another place, you must select
another filename and then "write" your current buffer into that file.

.tp 10
.hl 4;$Bold(Writing Files)
.index C-X C-W
.index Write File
.paragraph
To save your current buffer in another file, for safekeeping or for
simply creating a "new" file, you select and "write" that new file in
one command:  "$Bold(C-X#C-W fileneme _<esc_>)".  This tells VUE to open
a new file named "filename" and to write out the current state of the
buffer.  This also selects "filename" as the new file to associate with
this buffer.  Thus, two successive C-X#C-W commands are necessary to
keep the buffer pointing to the same file.  The first to select and
write into a new file and the second to re-select and also write into
the old file.  If you are merely hacking away at the text in a particular
file and have no intention of re-writing the text after you have erased
any significant parts, you may not wish to re-select the old filename.
Simply leave the new name associated with the buffer and be sure to exit
VUE with the $Bold(C-X#C-C) command sequence.

.hl 4;$Bold(Save Text and Exit)
.index C-X C-X
.index C-X C-S
.index Finish File
.paragraph
VUE provides three ways to exit from each editing session.  One way
simply exits:  $Bold(C-X#C-C), while the other two options allow you to
save your text in a file.  The command $Bold(M-X#Finish#File) tells VUE
to first do a C-X#C-S command to save the current state of things (if
this is necessary), and to exit back to XEXEC mode (or PDP-10 mode) or
to your superior (or "calling") program.  Using the sequence
M-X#Finish#File is the normal way to terminate a VUE session, and once
you begin using VUE as your editor you will do this as a matter of
course.
.paragraph
The command sequence M-X#Finish#File can also be simulated.  That is to
say, that by typing another set of commands you will have the same
effect.  To do this, simply type the sequence:  C-X#C-S C-X#C-C.  This in
effect, saves the current state, and then exits.  

.hl 4;$Bold(Save Text and Run Superior (RPG))
.index Save and Run Superior
.paragraph
The third way to exit from a VUE session, (ah, you thought I forgot!),
is to save your text and then exit to RPG.  To do this, you type the
command sequence:  $Bold(M-X#Save#and#Run) which performs the same
functions as C-X#C-S and then performs a XEXEC "RUN" command on the RPG
program.  This is intrinsically the same as typing the command sequence
M-X#Finish#File which saves your text and then exits to your superior.
The difference is that M-X#Finish#File returns your to XEXEC (or
Monitor) mode if you do not have a superior process, while the command
M-X#Save#and#Run attempts to run RPG and execute your latest "saved"
RPG command.  (Authors note:  If you know what I'm talking about, this is
reasonably clear.  If you don't understand this section, don't worry
about it; I could explain and explain and you still won't understand
it.)

.tp 10
.hl 2 $Bold(Windows)
.index Windows
.paragraph
Just as you can have multiple buffers for editing multiple files, VUE
allows you to have multiple windows present on your screen at once.
These windows can be used to view separate file or can be used to look
at different sections of the same file.  In either case, VUE makes every
attempt to keep the information about each window separate from every
other window.  In the discussion below, we will be discussing "additional"
windows, because you always have at least one "window" when you are using
VUE.

.hl 3;$Bold(Creating and Deleting Windows)
.index C-X 2
.index Create Window
.index C-X C
.index Split Window
.paragraph
There are two methods for creating additional windows, and the one you
use most often depends upon your preference.  The first method is to
position the cursor roughly on the screen where you would like the
dividing line to be created between the current window and the "new"
window.  Then, you type the $Bold(C-X#C) command to create the window
divider at that point.  The second method is slightly simplier, but
achieves a similar result.  Instead of moving the cursor around at all,
simply type the command $Bold(C-X#2) which takes the current window and
splits it into two equal parts.
.paragraph
In either of the two cases, the results are similar with one additional
window being created for each invocation of the command.  The cursor is
always placed in the lower half of the two windows, and the status line
is always current for the window that the cursor is in.  To remind you
that there are two or more windows on the screen, VUE places a divider
bar which consists of a row of "_<_>_<_>_<_>_<_>" characters across the
screen.  If the two windows point to the same buffer, changes to the
contents of one window will affect the other window.  However, the
changes will not become apparent until you move the cursor into the
other window.
.index C-X D
.index Delete Window
.paragraph
Once you are finished using a window, you need to know how to make it
go away.  To do this, you "delete" it.  If it points into the same buffer
as one of your other windows, you are assured not to lose any
information.  If it points at a buffer which you have made changes to,
which is not part of another window, it is in your best interest to
save it using C-X#C-S before you delete the window.  To "delete" a
window, you use the command $Bold(C-X#D).  This command deletes the
current window, and allows your other window to reclaim the space it
used.
.tp 12
.hl 3;$Bold(Using Windows)
.index Next window
.index Previous Window
.paragraph
Now that you have a second window, what can you use it for?  Well, as
mentioned above, you can view one section of a file while you work on
another.  You can also look at the reference manual for a particular
aspect of code that you might be working on in one window while you
type in the actual code in the other window.  To use this feature,
however, you need to be able to switch back and forth from one window
to another.  To do this, use the "M-X#Next#Window" and
"M-X#Previous#Window" commands.  These commands also appear to work as
"up window" (previous) and "down window" (next), just in case you get
confused.
.paragraph
Some caution should be exercised when viewing two sections of the same
buffer with two separate windows.  If you $Bold(R)ead another file into
the buffer with C-X#C-R or C-X#C-V, you are liable to change all windows
which are viewing parts of that file to the new file.  To insure against
this mishap, it is best to use the C-X#B command to select a new buffer
name, then, select a new file to view.
.hl 3;$Bold(Multiple Windows vs. Multiple Buffers)
.index Multiple windows
.paragraph
There are arguments from both sides as to which is better: using multiple
buffers or using multiple windows.  Multiple windows allow you to view
different parts of different (or the same) buffer on the same screen.
However, your screen becomes smaller by one line for each additional
window that you put on the screen (you are not limited to two).
.paragraph
To use multiple buffers with one window, you do not lose any screen space,
but you do not have the capability of viewing more than will fit on the
screen at a single time, from top to bottom.  This is important, because
you may want to flip between large portions of text inside the same buffer.
With multiple buffers, you can flip between an "untouched" copy of your
edit and your editied version, but you have to rely on your memory to make
the comparisons.
.paragraph
Truly, the best solution is to use a combination of multiple buffers
and multiple windows.  Use multiple buffers when you need to see an
entire screen of information, and multiple windows when you need to see
more than one section of text simultaneously.  You will build a
preference for one style or technique and you will stick with it.  But,
remember, there are almost always, more than one way to accomplish a
single editing task.

.page
.hl 1 $Bold(Extended (Meta-X) Commands and Functions)
.index Extended Commands
.index Extended Functions
.index M-X commands
.paragraph
While the most                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ill
receive an error.

.hl 3;$Bold(Numeric Arguments and String Arguments)
.paragraph
Some functions can use numeric prefix arguments.  Simply give the Meta-X
command an argument and Meta-X will pass it along to the function which
it calls.  For example, C-U 5 M-X Forward Word _<esc_> will move the
cursor forward 5 words.
.paragraph
Some functions require "string arguments" or "suffix arguments".  For
those functions, the function name is terminated with an _<Esc_>, then
you type the arguments, separated by _<esc_>s.  After the last argument,
type a Return to cause the function to be executed.  For example, the
function Major Mode initializes various functions based upon the mode
name, whose name must be given as a string argument.  For example,
Meta-X Major Mode _<esc_> TEXT _<cr_> initializes the "TEXT" mode.

.page
.hl 1 $Bold(Command and Function Bindings)
.index Command Binding
.index Function Binding
.index Binding
.paragraph
Actually, every keyboard command in VUE runs a function.  For example,
the command C-N runs the function "Down Text Line".  The extended
command "M-X Down Text Line" also runs this function.  C-N can be
thought of as a sort of abbreviation such that the command C-N has been
"connected" to the function "Down Text Line".  Just as any function can
be called directly with M-X, so almost any function can be connected to
a command.
.paragraph
When VUE is initialized, there are a specific set of keys which perform
specific functions.  These keys have been picked primarily for their
ease in typing based upon frequency of use and mnemonic value.  Thus, it
can be shown that it is advantageous for the user to be able to push
the right keys to use the functions which are most often needed.  Since
VUE supports a variety of different terminals, all of which tend to
have different keyboards, it is conceivable that some characters may
be difficult to type on some keyboards.  Thus, VUE provides a mechanism
for binding any key to any function, or >rebinding existing keys (which
are bound to a function) to other keys in order to make them less or
more difficult to type.
.paragraph
While you are rebinding keys, you might want to bind a command to "any"
key on the keyboard.  However, you should exercise some caution because
you might accidentally bind a function to a key which you cannot "really"
type.  For this reason, any function may be bound to as many keys as you
like, all at the same time.  One important point to remember is that
it is unwise to bind any function to Meta-X, Control-X or Escape.  In
particular, Control-X and Escape are reasonably "hard-wired" in many parts
of the editor and you may get unpredictable results by rebinding commands
to these keys.
.paragraph
Should you want to "unbind" something you have bound, changing the
mode to INIT will reset all command keys to their initial state (See MODES).
Note that binding to a standard printing character will cause it to
no longer print nor insert itself into the buffer.

.hl 2 $Bold(Binding Functions to Keys)
.index Bind Function
.paragraph
The most simple rebinding command is to bind a function to an existing
key.  The extended command $Bold(M-X#Bind#Function) will do this for
you.  The format of this command is as follows:
.sk.indent 4;M-X#Bind#Function#_<esc_>#_<function-name_>#_<esc_>#_<key_>
.sk
What this command does is to search through the list of names for
the extended commands for a match to the _<function-name_> which
you enter.  Then, if found, it assigns that function to the key
which you specify.  If the function name is not found, the "error"
message is printed and you must try again.  You need not type the
entire function name to completion.  As in the extended command
itself, you need only type enough of the command name to make it
unique.  If you want to review the list of command names, they can
be found in the command index of this document, or you can see find
them on-line by typing a question-mark (?) after the Meta-X command.
.paragraph
It is important to note that binding a function to a specific key
will erase any "old" binding which that key previously had.  However,
if the function requested is used by some other key, that binding is
left intact.  (In fact, if you so desired, you could make every key on
the keyboard perform the same function if you so desired, however,
this would not be too terribly useful).

.hl 2 $Bold(Copying Existing Key Bindings)
.index Copy Key
.paragraph
If you want to make another key do what some key already does, you
can simply use the M-X#Copy#Key command, which will prompt for the
old key (the one currently performing the function) and then a new
key (which will be redefined to also perform this function.  Note that
the original key's definition is not changed.  You can, of course,
bind a key to its own definition, but this has no effect whatsoever.

.hl 2 $Bold(Binding a Macro Slot to a Key)
.index Bind Macro 
.paragraph
If however the function is performed by a command currently stored in a
macro slot, then you use the M-X#Bind#Macro command, which instead of
asking for a key providing the function, asks for the name of a macro
slot instead.  It then asks for a key to have perform this macro.  (Do not
bind a macro slot to a key that is contained in that macro slot, or you
will find out what recursion is not all about).  Also do not bind a macro
slot to the key command "C-X#)" or you will find out what it means to
"break" every macro slot currently in use as well as cause an infinite
recursion within itself.

.page
.hl 1 $Bold(Keyboard Macros*)
.index Keyboard Macros
.paragraph
VUE has a very simple-minded "macro" facility available.  It is useful
mostly for long-winded command sequences which you might want to have
performed many times, or for combinations of existing commands which
you might wish to have "bound" to a single key.  The actual >macros are
called "keyboard macro"s, because they are normally entered by hand
at the keyboard.
.paragraph
First, assume that you have a text file in which you had typed
the string "FOOBAR" in a lot of places, an you realize that these
were really supposed to say "FOO".  You could use "Replace String"
or you could search for the entries yourself and make the proper
corrections.  To search for the word "FOO", then delete the three
characters after it you would type the VUE commands:
.sk.indent 4;C-S FOO _<esc_> C-U 3 C-D
.sk
.paragraph
Now, after typing that once, you realize that you need to make this
change another 20 or 30 times.  You could type the commands again and
again, or you could "define" a macro to do it for you.  At
present$Bold(*), as you define a macro, you must assign it to a
specific "slot".  Eventually this will go away, and you will be able
to "name" your macros and reference them like you would the regular
"built-in" functions.  Say we select the macro slot "F", then we must
declare it.  So, we type:
.sk.indent 4;C-X#(#F#C-S#FOO#_<esc_>#C-U#3#C-D#C-X#)
.sk
The macro slot "F" is now available.  To "execute" the macro, we
call it by "slot name".  The command to do this is Control-X#E.
So, we type:
.sk.indent 4;C-X#E#F
.sk
This says to perform the macro which resides in slot "F".  If we want
to execute the macro more than once, we give it an argument, as in:
"C-U#30#C-X#E#F".  If there were 30 more occurrences of the string
"FOOBAR" you would have been finished.  However, if there were only
20, what would have happenned?  Well, after finding the last
occurrence, VUE would attempt to execute the macro.  The search would
fail and the macro would abort.  But, because of the simple way in
which macros are currently implemented, execution of the macro would
be attempted over and over again, until the repeat count was exhausted.
This will be corrected in the next release, but at present, is something
to be wary of.  In this instance, no "damage" is done because the macro
is aborted almost immediately.  However, if you had performed some other
commands before the macro is aborted, these commands would would be
executed as many times as the macro is re-started.

.hl 2 $Bold(Defining Macros)
.index Begin Macro Definition
.index Control-X (
.index Defining Macros
.paragraph
To insert text into a macro slot, you use the "Begin Macro
Definition" command, "Control-X#(".  This then puts you into macro
definition mode and prompts for the necessary information.  A VUE
macro currently$Bold(*) consists of two distinct parts:  the "slot"
name and the "definition".  
.hl 3;$Bold(Slot Names)
.index Macro Slot
.paragraph
There are currently 26 slots allocated and assigned to the letters of
the alphabet ("A" through "Z").  Each slot may contain one macro
definition with up to five hundred bytes of "normal" VUE commands.  When
you invoke the "macro" reader, you are prompted by the string "Macro
Slot:" to which you respond with the single letter name of the slot that
you want to use.
.hl 3;$Bold(Definition)
.paragraph
.index Control-X )
For your macro, you are free to use any combination of VUE commands,
self-inserting text characters and macro parameters with the "one"
exception that you may not type the "definition terminator" as part
of the macro.  The definition terminator is the "Control-X#)"
character, which has absolutely "no" other use in VUE.  Simply type in
your VUE commands as if you were typing to the editor.  Your commands
will be recorded in the selected macro slot until you are finished
with the definition.  When you are done, merely end with the definition
terminator and you will be returned to the normal VUE editing mode.

.index Keyboard Marco Query
.index C-X Q
.index Control-X Q
.hl 2 $Bold(Querying from a Macro)
.paragraph
In the example given above, you realize that there are some other
references to "FOO" other than "FOOBAR".  For example, there was a list
of "FOOD" items.  Well, you don't want to delete the "D" and anything
else around that occurrence, so it is wise to re-write our macro a
little.  Using the Keyboard Macro Query command, Control-X#Q, which
tells VUE to pause and wait for the user to type in a "Y" or an "N"
and then continues with that invocation of the macro only if the answer
was a "Y".
.sk.indent 4
C-X#(#F#C-S#FOO#_<esc_>#C-X#Q#C-U#3#C-D#C-X#)
.paragraph
Now, when the macro reaches the point after finding an occurrence of
the word "FOO" it stops and waits.  If you type a "Y", then it continues
with the deletion, otherwise, that invocation of the macro is
terminated.  If you had given an argument of "30" to the "C-X#E F"
command, then after each "FOO" found, the macro would wait for an
answer.  Each "Y" answer meant that it would "delete" the three
characters following the word "FOO".  If you type "N", then that
particular invocation of the macro would be terminated, but it would
search for the next "FOO" again and again, until the count of 30 tries
reached 0, or until the search fails.  (At which point, the action
previously discussed would occur).


.page
.hl 1 $Bold(>Modes>)
.paragraph
A mode is basically a state that VUE can be put into which allows
certain functions to act in specific ways.  In particular, some commands
will do something slightly different depending upon the mode.  For
example:
.index TEXT mode
.sk.lm+8.rm-8
In "TEXT" mode, the "space" command first checks to see that
the last word entered ends before the Right Justification Margin.  Then
if this is true it simply enters a space.  If this is false, then the
word is moved to the next line and then a space is entered.
.index INIT mode
.sk.lm-8.rm+8
.paragraph
The default mode is called "INIT" mode.  This is the state which you are
in when you begin your VUE session.  This mode sets or resets all
command keys to their initial state.  Thus, changing to this mode will
un-do all command bindings which you may have done, leaving you in a
known state.  Basically, entering a new mode rebinds some of the
commands to execute different procedures, thus providing different
functions.  (Note that this may interfere with your own key rebindings,
thus it is wise to check the references which accompany each mode in
this document).
.index Major Mode
.paragraph
To change your mode, you use the extended command "M-X#Major#Mode", and
supply a string argument from the following selection:
.sk
.ts 18
.indent 4;INIT	VUE's Initial state.
.indent 4;TEXT	Functions pertaining to text and text processing.
.indent 4;BLISS	Understand BLISS programming formats.
.indent 4;PASCAL	Understand PASCAL block structures.
.indent 4;ABBREV	Recognize abbreviations and replace them.
.sk
.ts 8,16,24,32,40,48,56,64,72
The exact format is as follows:
.sk.indent 4;M-X#Major#Mode#_<esc_>#_<mode-name_>#_<esc_>
.sk
where _<mode-name_> is the name of one of the currently legal "major" mode
types.

.hl 2 $Bold(INIT Mode)
.index INIT mode
.paragraph
This is the mode in which VUE is initialized.  This mode assumes that
all key command bindings are illegal and resets them to their initial
basic function state.  Thus, all macro bindings, function bindings and
duplicate key functions are bound to the set of "basic" functions.  Any
key which is not assigned to an initial function is bound to the
function "Illegal command" which prints the messsage "Error" in the
echo area and attempts to abort any currently running function (like
C-G, the abort command would).  Think of this mode as a "reset all"
function and you will be very close.

.hl 2 $Bold(TEXT Mode)
.index TEXT mode
.paragraph
Text mode is useful for writing papers.
In text mode when you type a space past the "right justification
margin", the last word will be deleted and a carriage return inserted, and
then the word just deleted will be typed at the start of the new line.
Thus, while entering text, you need not worry about ever typing a
carriage-return at the edge of your screen; VUE will do it for you.
.lm+12.ts 12
.sk
.i-12;_<Space_>	This command causes a space to be inserted, except when typed
when beyond the indentation column, when it will cause the last word
typed to be saved and deleted, and then a new line to be created and
this word to be put at the start of the new line.
.ts 8,16,24,32,40,48,56,64,72
.lm-12

.hl 2 $Bold(BLISS Mode)
.index BLISS mode
.paragraph
This mode is used to type in BLISS programs.  Actually, this is not a
very intelligent "Bliss" mode.  The only commands which do anything
different are: 
.lm+12
.b1;.i-12;C-J	The line-feed command.  This is does a carriage return and then it
indents the proper number of spaces and tabs to get to the point
directly beneath the first non-blank character on the previous line.  If
the previous line contains a BLISS block structure element such as
"Begin" or "End", this function will also attempt to move the statement
to where it thinks it should be.
.b1;.i-12;M-1	This is the comment enterer.  It gets you to a reasonable place to
put the comment, and prints the comment prompt, too.  This place can be
changed with the "M-X Set Mode Parameter _<esc_>" command.
.lm-12

.hl 2 $Bold(PASCAL Mode)
.index PASCAL mode
.paragraph
This mode is used to type in Pascal programs.  When typing in code, the
line-feed command is used for getting a new line and indenting it.
There are also useful commands for other things.  Here is a list of what
is implemented so far.
.lm+12
.b1;.i-12;C-J	The line-feed command.  This command is similar to the C-J
command in BLISS mode.  However, it knows a lot more about Pascal style
block structures.
.b1;.i-12;M-{	This is used to begin a comment.  It does the right thing in trying
to put you in a reasonable column for a comment.  If you do not like
where this column is, you can change it with the "M-XSet Mode
Parameter_<esc_>" command.
.b1;.i-12;M-}	This is used to end a comment.  It puts in a space, a "}" and then
does a linefeed command.
.b1;.i-12;:	This character is typed at the end of a label.  It will shift the
label to the right margin.
.lm-12

.hl 2 $Bold(Abbreviation Mode)
.index ABBREV mode
.index C-X C-A
.paragraph
This mode is useful for entering text as well as program sources.  The
basic commands which are implemented are: defining abbreviations and
replacing the abbreviations with the expanded texts.  The command C-X#C-A
is used to define new abbreviations.

.hl 2 $Bold(Multiple Modes)
.paragraph
Except for INIT mode, switching to a particular mode leaves the old
command bindings in effect, when possible.  For instance, if you were in
Pascal mode and switched to Bliss mode, the binding for M-{ would be
left as it was in Pascal mode, because Bliss mode does not respecify
this command.  Furthermore, for some commands, such as "_<space_>", it
is possible that $Bold(both) bindings will remain in effect.  With
"_<space_>", the INIT mode command simply inserts a space, while the
TEXT mode command checks for line overflow, and and then executes the
functions previously bound to "_<space_>".  If some of these
left-overs are actually irritating, switching to INIT mode will reset
all the command bindings.
.index Rebind space overflow
.paragraph
If too many of these patches are made (by switching modes too often),
you will get a message saying "Rebind space overflow, reseting with
INIT mode".  You will then have to switch back to whatever mode
you were in by hand.  This should not occur normally.
.lm 0

.page
.hl 2 $Bold(Setting Mode Parameters)
.index Set Mode Parameter
.paragraph
The "Meta-X Set Mode Parameter" command is used to set the values of
various mode parameters for VUE.  These parameters all have integer values
(plus, minus and 0 are all acceptable).  If the parameter is a boolean
variable, the convention is as in BLISS, specifically "1" is true and "0"
is false.
.paragraph
You will notice that these names are quite long.  Fortunately, typing
_<esc_> at any time will run the command completion code, so all you
have to type is a unique prefix.  After the name of the variable to be
set is typed and accepted, VUE will prompt for the value, which must be
an integer.
.paragraph
You can type "?"  to the symbol name prompt and get a list of all the
possible variables to set.

.ls
.le;Autosave Frequency
.br
.index Autosave Frequency
This is a variable which tells how often autosaving will be done.  If it
is set to 0, none will be performed.  The default value is 100.
.le;Page Mode
.br
.index Page Mode
This variable tells whether or not to allow the user to see past the
edge of a page boundary.  If true, the user may only see one page at
a time regardless of the page size.  The default value is 1, which is
True.
.le;Center Screens
.br
.index Center Screens
This variable specifies whether the C-L command will center the screen
or not.  If the value is true, the line on which the cursor appears
will be repositioned near the center of the screen.  The default value
for this parameter is 1.
.le;Argument Multiplier
.br
.index C-U, Setting Value
.index Argument Multiplier
This is used to set the value that C-U uses for a multiplier as a
default.  The initial value for this variable is 4.
.le;Indentation Width
.br
.index Indentation Width
For any of the language modes, (BLISS and Pascal), this variable
contains the distance for each newly-indented line.  Each time a new
block is indented from the previous block, the next level is indented
with spaces by the current value of this variable.  The initial value is
4.
.le;Right Margin for Justification
.br
.index Right Margin for Justification
.index Margin for Justification
This variable contains the position of the right margin for the justify
command.  This value is also used by TEXT mode to determine when to
break the line and put additional words on the next.  The default value
for this variable is 72.
.le;Comment Position
.br
.index Comment Position
For the language modes, this tells in which column you like to see your
comments started.  The initial value is 41.
.le;Status Line 
.br
.index Status Line 
This variable is used to regulate whether the status line is displayed
at the bottom of your screen or not.  If this variable is True, then the
status line is displayed, otherwise the bottom of the screen will be left
blank.  The default value for this variable is 1.
.le;Escape Value
.br
.index Escape Value
This variable is read by many internal command processing sections
of the editor to determine whether or not the Escape key was pushed.
The initial value is 27, however, changing this value means that the
key with the equivalent ASCII value is read as an Escape instead of
the normal _<esc_> key.
.le;Meta Prefix Value
.br
.index Meta Prefix Value
Again, like the Escape Value, this variable is referenced internally
to determine whether the next command is a "Meta" command or not.  The
initial value of this variable is 27, for _<esc_>.
.le;Control-X#Prefix Value
.br
.index Control-X Prefix Value
This variable contains the internal representation value to be used for
the Control-X key.  The default value is 24.
.le;Baud Rate	
.br
.index Baud Rate
This variable is used by some of the cursor positioning routines to
perform some basic speed optimizations depending upon the terminal type
you are using.  (Some terminals cannot be optimized at any speed).  The
initial value is 1200.
.els
.ts 8,16,24,32,40,48,56,64,72

.page
.index Command files
.hl 1 $Bold(Command Files and >VUE.INI>)
.paragraph
Command files are simply user created disk files which contain
commands for VUE to process.  The commands which are entered in the file
should be formatted exactly as if the user was typing them to the
editor.  For example, if the commands were to move the cursor forward
three words and then delete the fourth word, the contents of the
command file would be:
.sk.indent 4;C-U 3 M-F M-D
.sk
Of course, the representation in the file would be "_^U3_$F_$D", but
the effect would be the same.  Command files, however, suffer from a
lack of readability and thus the following conventions have been
adopted.  First, the characters:  Carriage-Return, Linefeed and Null
(C-@) are completely ignored in the file.  Second, control characters
can be entered as themselves (Usually by typing >C-Q to quote them), or
as a two-character pair >?_<char_> where the "?"  is used as a "Control"
prefix.  Thus, ?D would be equivalent to _^D or C-D.  To enter a single
question-mark "?"  character type the character sequence "??".  This
character was chosen because it cannot be confused with an ordinary
"Control" character.
.paragraph
To cause VUE to read and execute a file of VUE commands, use the
command M-X#Execute#File_<esc_>.  This command will redirect VUE to your
file of commands and then read and execute them as if you had typed
them in from your terminal.
.paragraph
VUE.INI is a special case command file which VUE attempts to "read" each time that
you use the editor.  If you do not have one, VUE automatically continues
and you begin your editing session.  If you do have a file with this
name on your currently GFD'd directory, VUE will read the file as if it
contained "normal" editing commands.  In a sense, this is a special
"command file" (see the section under "command files" in the discussion
about Files above).  The only difference is that this file is read first,
before you type any commands from your terminal.
.paragraph
The primary usage of this file is to setup command bindings, define
macros, initialize various mode parameters and generally customize your
keyboard to the kind of environment you like to "edit" in.  You can also
"call" other files like subroutines and perform any commands which you
could normally enter from the keyboard.  After using VUE for awhile you
will find that command files are no different from other text files.

.page
.Appendix;$Bold(Command Index)
.lm 0.rm 70
.hl 1 $Bold(Command Summary by Function)
.paragraph
This index contains brief descriptions with cross references for all
commands, grouped by topic.  Within each topic, they are in alphabetical
order.  Our version of alphabetical order places ASCII characters first,
then meta characters, then control-X last.

.hl 2 $Bold(Prefix Characters)
.lm+12
.b;.i-12;Escape or Altmode  (Prefix Meta)
.break
Escape is a bit prefix character which turns on the Meta bit in the
next character.  Thus, Escape F is equivalent to the single character
Meta-F, which is useful if your keyboard has no Meta key.
.b;.i-12;Control-Q  (Quoted Insert)
.break
Control-Q inserts the following character.  This is a way of inserting
control characters.
.b;.i-12;Control-U (Universal Argument)
.break
Control-U is a prefix for numeric arguments which works the
same on all terminals.
.b;.i-12;Control-X
.break
Control-X is a prefix character which begins a two-character command.
Each combination of Control-X and another character is a "Control-X
command".  Individual Control-X commands appear in this index according
to their uses.
.b;.i-12;Meta-X  (Extended Command)
.break
Meta-X  is  a prefix character which introduces an extended
command name.
.lm-12

.page
.hl 2 $Bold(Simple Cursor Motion)
.lm+12
.b.i-12;Control-A  (Beginning of Line)
.break
Control-A moves to the beginning of the line.
.b;.i-12;Control-B  (Backward Character)
.break
Control-B moves backward one character.
.b;.i-12;Control-E  (End of Line)
.break
Control-E moves to the end of the line.
.b;.i-12;Control-F  (Forward Character)
.break
Control-F moves forward one character.
.b;.i-12;Control-H  (Rubout Character)
.break
Control-H deletes the previous character.
.b;.i-12;Control-N  (Down Text Line)
.break
Control-N moves vertically straight down.
.b;.i-12;Control-P  (Up Text Line)
.break
Control-P moves vertically straight up.  
.b;.i-12;Meta-X Beginning of Screen
.break
Meta-X Beginning of Screen moves to the first position on the screen.
.b;.i-12;Meta-X End of Screen
.break
Meta-X End of Screen moves to the end of the screen.
.b;.i-12;Meta-_<  (Beginning of Text)
.break
Meta-_< moves to the beginning of the buffer.  
.b;.i-12;Meta-_>  (End of Text)
.break
Meta-_> moves to the end of the buffer.  
.lm-12

.page
.hl 2 $Bold(Lines)
.lm+12
.b;.i-12;Return  (CRLF)
.break
Return inserts a line separator, or advances onto a following blank
line.
.b;.i-12;Control-O  (Open Blank Lines)
.break
Control-O  inserts a line separator, but point stays before it.
This is identical to typing "Return " followed by Control-B.
.lm-12

.hl 2 $Bold(Whitespace and Indentation)
.lm+12
.b;.i-12;Tab  (Indent According to Mode)
.break
Tab  either  adjusts the indentation of the current line or
inserts some indentation, in a  way  that  depends  on  the
major  mode.
.b;.i-12;Linefeed  (Indent New Line)
.break
Linefeed is equivalent to Return followed by Tab.  It moves to a new
line and indents that line.  If done in the middle of a line, it escapes
out of that line and indents for the next available line.
.b;.i-12;Control-J  (Indent New Line)
.break
Control-J is the same as Linefeed.
.b;.i-12;Meta-X Indent Line.
.break
Meta-X Indent Line indents the line one tab stop.
.b;.i-12;Meta-X Indent Region.
.break
Meta-X Indent Region indents all the lines in the region to mark one tab stop.
.b;.i-12;Meta-X Unindent Line.
.break
Meta-X Unindent Line removes the indentation on the line.
.b;.i-12;Meta-X Unindent Region.
.break
Meta-X Indent Region removes the indentation in the region to mark.
.b;.i-12;Meta-_\  (Delete Horizontal Space)
.break
Meta-_\  deletes all spaces and tab characters following the point but
preceeding the next non-blank character on the current line.
.lm-12

.page
.hl 2 $Bold(Killing and Un-killing)
.lm+12
.b;.i-12;Rubout  (Rubout Character)
.break
Rubout deletes the previous character.  
.b;.i-12;Control-D  (Delete Character)
.break
Control-D deletes the next character.  
.b;.i-12;Control-H  (Rubout Character)
.break
Control-H deletes the previous character.  (Same as Rubout).
.b;.i-12;Control-K  (Kill Line)
.break
Control-K kills to the end of the line, or, at the end of a line, kills
the line separator.
.b;.i-12;Control-W  (Kill Region Mark)
.break
Control-W kills the region, the text betwen point and the mark.
.b;.i-12;Control-Y  (Restore Killed Text)
.break
Control-Y  reinserts  the  last saved block of killed text.
.b;.i-12;Meta-Control-W  (Copy Region)
.break
Meta-Control-W saves the region as if it were killed without removing
it from the buffer.  
.b;.i-12;Meta-W  (Kill Region String)
.break
Meta-W will set mark where the cursor is, search for string given, and kill
all text from mark to the "beginning" of the string.
.b;.i-12;Meta-D  (Kill Word)
.break
Meta-D  kills one word following the cursor.
.b;.i-12;Meta-H  (Rubout Word)
.break
Meta-H kills the previous word. (Also see Meta-Rubout).
.b;.i-12;Meta-K$Bold(*)  (Kill Sentence)
.break
Meta-K kills to the end of the sentence.
.b;.i-12;Meta-Rubout  (Rubout Word)
.break
Meta-Rubout kills the previous word. (Also see Meta-H).
.lm-12

.page
.hl 2 $Bold(Scrolling and Display Control)
.lm+12
.b;.i-12;Control-L  (Redisplay Screen)
.break
Control-L clears the screen and centers point in it.   With
an  argument,  it  can  put point on a specific line of the
screen.
.b;.i-12;Control-V  (Next Screen)
.break
Control-V scrolls downward by a screenful or several lines.
.b;.i-12;Meta-!  (Scroll Line to Top)
.break
Meta-!  moves the line on which the cursor resides, to the top of the
screen, scrolling the remaining section of the screen up at the same
time.
.bl.i-12;Meta-O  (Toggle Display Output)
.break
Meta-O toggles the condition of the screen display output flag.  When this
flag is True the redisplay is constantly updating the screen for each change.
When this flag is False, nothing is shown on the screen.  This is very useful
for turning "off" the screen.  Each successive Meta-O switches between True
and False.
.b;.i-12;Meta-V  (Previous Screen)
.break
Meta-V scrolls upward by a screenful.
.b;.i-12;Meta-X Reverse Scroll Screen
.break
Meta-X Reverse Scroll Screen scrolls the screen down one line.
.b;.i-12;Meta-X Scroll Screen
.break
Meta-X Scroll Screen scrolls the screen up one line.
.lm-12

.page
.hl 2 $Bold(Searching)
.lm+12
.b;.i-12;Control-S  (Incremental Search)
.break
Control-S searches for a string, terminated by Escape.  It
searches as you type.
.b;.i-12;Control-R  (Reverse Search)
.break
Control-R is like Control-S but searches backward.
.b;.i-12;Meta-S  (String Search)
.break
Meta-S searches for the string given (terminated by Escape), beginning
the search after the Escape.
.b;.i-12;Meta-R  (Reverse String Search)
.break
Meta-R is like Meta-S but searches backwards.
.b;.i-12;Meta-Control-S  (Incremental Search)
.break
Meta-Control-S is the same as Control-S.
.b;.i-12;Meta-Control-R  (Reverse Search)
.break
Meta-Control-R is the same as Control-R.
.b;.i-12;Meta-_$  (Replace String)
.break
Meta-_$ prompts for a string to search for and a string to replace it with.
Then it proceeds from the current point to the end of the buffer replacing
all occurrences with the new string.  Preceeded by a C-U will search in the
reverse direction.
.b;.i-12;Meta-_%  (Query Replace)
.break
Meta-_% works exactly like Meta-_$ except that it asks at each occurrence
whether you want it replaced or not.  Options include: Yes, No, Stop and
Continue without asking.
.lm-12

.hl 2 $Bold(The Mark and the Region)
.lm+12
.b;.i-12;Control-@  (Set-Erase Mark)
.break
Control-@ sets the mark or moves to the location of the mark.
Given an argument (using C-U) the mark is cleared.
.b;.i-12;Control-X Control-X  (Exchange Point and Mark)
.break
Control-X Control-X sets point where the mark was  and  the
mark where point was.
.lm-12

.page
.hl 2 $Bold(Words), $Bold(Sentences and Paragraphs)
.lm+12
.b;.i-12;Meta-A*  (Beginning of Sentence)
.break
Meta-A moves to the beginning of the sentence.
.b;.i-12;Meta-B  (Backward Word)
.break
Meta-B moves backward one word.
.b;.i-12;Meta-D  (Delete Word)
.break
Meta-D  kills one word following the cursor.
.b;.i-12;Meta-E*  (Forward Sentence)
.break
Meta-E moves to the end of the sentence.
.b;.i-12;Meta-F  (Forward Word)
.break
Meta-F  moves forward one word.
.b;.i-12;Meta-K*  (Kill Sentence)
.break
Meta-K kills to the end of the sentence.
.b;.i-12;Meta-[  (Up Paragraph)
.break
Meta-[ moves to the previous paragraph break.
.b;.i-12;Meta-X Justify Paragraph
.break
Meta-X Justify Paragraph fills and justifies the paragraph containing
the cursor.
.b;.i-12;Meta-]  (Down Paragraph)
.break
Meta-] moves to the next paragraph break.
.b;.i-12;Meta-Rubout  (Rubout Word)
.break
Meta-Rubout deletes the previous word.
.bl.i-12;Control-X Rubout* (Kill Previous Sentence)
.break
Control-X Rubout deletes the previous sentence.
.lm-12

.hl 2 $Bold(Case Conversion)
.lm+12
.b;.i-12;Control-_^  (Invert Case Character)
.break
Control-_^ inverts the case of the next character.
.b;.i-12;Meta-_^  (Invert Case Word)
.break
Control-_^ inverts the case of the text characters from the cursor to the
end of the word.
.b;.i-12;Meta-Control-_^  (Invert Case Region)
.break
Meta-Control-_^ inverts the case of the text characters from the point to the
mark.
.lm-12

.page
.hl 2 $Bold(Exiting)
.lm+12
.b;.i-12;Control-X Control-C  (Return to Superior)
.break
Control-X Control-C returns from VUE to its superior job,
even  if  VUE  is  currently  inside  a recursive editing
level.  In that case, re-entering VUE will find it  still
within  the  recursive  editing	level.

.b;.i-12;Meta-Control-C  (Exit)
.break
Meta-Control-C exits from a recursive editing level and allows the
command which invoked the recursive editing level to finish.  At top
level, it exits from VUE to its superior job.
.b;.i-12;Meta-X Finish File
.break
Meta-X Finish File saves the current file and exits from VUE to superior.
.b;.i-12;Meta-X Save and Run Superior
.break
Meta-X Save and Run Superior saves the current file and exits to RPG
performing a XEXEC "RUN" command on the RPG program.
.lm-12

.hl 2 $Bold(Pages)
.lm+12
.b;.i-12;Meta-{  (Beginning of Page)
.break
Meta-{ moves backward to the preceeding page boundary (this page)
and stops on the current page.
.b;.i-12;Meta-}  (End of Page)
.break
Meta-} moves forward to the next page boundary (this page) and
stops on the current page.
.b;.i-12;Control-X [  (Previous Page)
.break
Control-X [ moves backward past the previous  page  boundary (this page)
and stops when it reaches the next previous page boundary (previous page).
.b;.i-12;Control-X ]  (Next Page)
.break
Control-X ] moves forward  past the next page boundary (this page) and
stops at the beginning of the next page.
.lm-12

.page
.hl 2 $Bold(Lisp)
.lm+12
.b;.i-12;Meta-(  (Match Right Parenthesis)
.break
Meta-( repositions the cursor at the matching right parenthesis,
square bracket or curly bracket.
.b;.i-12;Meta-)  (Match Left Parenthesis)
.break
Meta-) repositions the cursor at the previous matching left parenthesis,
square bracket or curly bracket.
.lm-12

.hl 2 $Bold(Files)
.lm+12
.b;.i-12;Meta-~  (Buffer Not Modified)*
.break
Meta-~ clears the flag which says that the buffer contains changes that
have not been saved.  
.b;.i-12;Control-X Control-R  (Read File)
.break
Control-X Control-R reads a file into present buffer.
.b;.i-12;Control-X Control-S  (Save File)
.break
Control-X Control-S saves the current buffer in the current file.
.b;.i-12;Control-X Control-V  (Visit File)
.break
Control-X Control-V visits a file, usually creating new buffer.
If a buffer with that name already exists, it will simply read in
that buffer.
.b;.i-12;Control-X Control-W  (Write File)
.break
Control-X Control-W writes the current buffer into the specified file
and moves you into that buffer for editing.
.b;.i-12;Meta-X Execute File
.break
Meta-X Execute File reads commands from specified file and executes them.
.b;.i-12;Meta-X Insert File
.break
Meta-X Insert File inserts entire contents of the specified file
into file you are editing at the point of the cursor.
.lm-12

.page
.hl 2 $Bold(Buffers)
.lm+12
.b;.i-12;Control-X Control-K  (Read Killed Buffer)
.break
Control-X Control-K selects an old or killed buffer and reads it
in as though you were merely selecting it as a buffer.  This is
useful for recovering after a crash.  See the section on files and
buffers above.
.b;.i-12;Control-X Control-B (List Buffers)
.break
Control-X Control-B lists existing buffers.  If an asterisk (*) appears
after the buffer name, it means that the buffer has been modified.
.b;.i-12;Control-X B  (Select Buffer)
.break
Control-X B is the command for switching to another buffer.
.b;.i-12;Control-X K  (Kill Buffer)*
.break
Control-X K kills a buffer.
.lm-12

.page
.hl 2 $Bold(Windows)
.lm+12
.b;.i-12;Control-X 2  (Split Current Window)
.break
Control-X 2 splits the screen into two windows.
.b;.i-12;Control-X C (Create Window)
.break
Control-X C creates a divider line at the current cursor position and
then displays two windows on the screen.  Both windows will be identical
to the window in which the cursor was residing.  The cursor will be
placed at the current position in the lowest of the two windows just
created.
.b;.i-12;Control-X D  (Delete Window)
.break
Control-X D deletes whatever window it currently resides in from the
screen and then attempts to put the cursor into the next higher
screen of the windows left on the screen.
.b;.i-12;Meta-X Enlarge Window
.break
Meta-X Enlarge Window will make the window containing the cursor larger.
(This command will not work in bottom window.)
.b;.i-12;Meta-X Next Window
.break
Meta-X Next Window moves cursor to next window.
.b;.i-12;Meta-X Previous Window
.break
Meta-X Previous Window moves cursor to preceeding window.
.b;.i-12;Meta-X Shrink Window
.break
Meta-X Shrink Window will make the window containing the cursor smaller.
(This command will not work in bottom window.)
.lm-12

.page
.hl 2 $Bold(Keyboard Macros)
.lm+12
.b;.i-12;Control-X (  (Start Keyboard Macro)
.break
Control-X  ( begins definition of a keyboard macro.
.b;.i-12;Control-X )  (End Keyboard Macro)
.break
Control-X  ) terminates the definition of a keyboard macro.
.b;.i-12;Control-X E (Call Keyboard Macro)
.break
Control-X E executes the  most  recently  defined  keyboard
macro.
.b;.i-12;Control-X Q (Keyboard Macro Query)
.break
Control-X Q in a keyboard macro can ask the user whether to
continue  or allow him to do some editing before continuing
with the keyboard macro.
.b;.i-12;Meta-X Load Macro Slot*
.break
Meta-X Load Macro Slot takes current buffer and loads into a 
macro slot (this command due to disappear).
.lm-12

.hl 2 $Bold(Binding Functions and Macros)
.lm+12
.b;.i-12;Meta-X Bind Function
.break
Meta-X Bind Function prompts for a function name, searches for it in the
list of names for the extended commands, and, if found, prompts for a key
to which to assign that function.
.b;.i-12;Meta-X Bind Macro Slot
.break
Meta-X Bind Macro Slot prompts for a the name of a macro slot, and then the
name of the key to which to bind that macro.
.b;.i-12;Meta-X Copy Key
.break
Meta-X Copy Key prompts for old key and then the new key which will then also
perform the same function.
.lm-12

.page
.hl 2 $Bold(Modes and Parameters)
.lm+12
.b;.i-12;Meta-X Major Mode
.break
Meta-X Major Mode prompts for name of "major" mode types (currently
INIT, TEXT, BLISS, PASCAL and ABBREV) and puts you into that mode.
.b;.i-12;Meta-X Set Mode Parameter
.break
Meta-X Set Mode Paramenter will prompt for the name of a mode parameter
and then for the value you wish which must be an integer.  (? will give
you a list of the possible variables to set).  Mode parameters are:
.b;.i 12;Autosave Frequency
.i 12;Page Mode
.i 12;Center New Screens
.i 12;Repetition Value for C-U
.i 12;Indentation Width
.i 12;Margin for Justification
.i 12;Comment Position
.i 12;Status Line Display
.i 12;Escape Value
.i 12;Meta Prefix Value
.i 12;Control-X Prefix
.i 12;Value
.i 12;Baud Rate
.b;.i-12;Meta-X Terminal Type
.break
Meta-X Terminal Type works just the same as the request for Terminal
Type as you enter VUE.  It will prompt for Terminal Type, or ? will
give you a list of terminal types.
.lm-12

.page
.Appendix $Bold(Command Summary by Key)
.lm 20.ts 20,32
.b1;.i-20
_!"_#...012...ABC...abc...  All standard printing characters:  These
characters simply insert themselves into the buffer at the current
cursor position.
.b
.i-20;Control-A	Beginning of Line.
.i-20;Control-B	Backward Character.
.i-20;Control-C	Exit to Superior.
.i-20;Control-D	Delete Character.
.i-20;Control-E	End of Line.
.i-20;Control-F	Forward Character.
.i-20;Control-G	Abort Operation.
.i-20;Control-H	Rubout Character.
.i-20;Control-I	Tab According to Mode.
.i-20;Control-J	Indent New Line.
.i-20;Control-K	Kill Line.
.i-20;Control-L	Redisplay Screen.
.i-20;Control-M	Carriage Return.
.i-20;Control-N	Down Text Line.
.i-20;Control-O	Open Blank Lines.
.i-20;Control-P	Up Text Line.
.i-20;Control-Q	Quote Character.
.i-20;Control-R	Reverse Search.
.i-20;Control-S	Incremental Search.
.i-20;Control-T	Transpose Characters.
.i-20;Control-U	Universal Argument.
.i-20;Control-V	Next Screen.
.i-20;Control-W	Kill Region Mark.
.i-20;Control-X	Prefix eXtended Commands.
.i-20;Control-Y	Yank Killed Text.
.i-20;Control-_^	Invert Case of Character.
.i-20;Control-@	Set-Erase Mark.
.i-20;_<ESC_>	Prefix Meta Commands.

.page
.i-20;Meta-Control-R	Reverse Search.
.i-20;Meta-Control-S	Incremental Search.
.i-20;Meta-Control-W	Copy Region.
.i-20;Meta-Control-_^	Invert Case Region.
.i-20;Meta-!	Scroll Line to Top.
.i-20;Meta-_$	Replace String.
.i-20;Meta-%	Query Replace String.
.b

.i-20;Meta-(	Match Right Parenthesis.
.i-20;Meta-)	Match Left Parenthesis.
.i-20;Meta-A	Beginning of Sentence.*
.i-20;Meta-B	Backward word.
.i-20;Meta-C	Call Macro.
.i-20;Meta-D	Delete Word.
.i-20;Meta-E	End of Sentence.*
.i-20;Meta-F	Forward Word.
.i-20;Meta-H	Rubout Word.
.i-20;Meta-I	Tabify Line.
.i-20;Meta-K	Kill Sentence.*
.i-20;Meta-O	Toggle Display Output.
.i-20;Meta-R	Reverse String Search.
.i-20;Meta-S	String Search.
.i-20;Meta-T	Transpose Words.*
.i-20;Meta-U	Untabify Line.
.i-20;Meta-W	Kill Region String.
.i-20;Meta-_<	Beginning of Text.
.i-20;Meta-_>	End of Text.
.i-20;Meta-?	On-line documentation Try it.
.i-20;Meta-[	Up Paragraph.
.i-20;Meta-_\	Kill Horizontal Whitespace.
.i-20;Meta-]	Down Paragraph.
.i-20;Meta-_^	Invert Case Word.
.i-20;Meta-{	Beginning of Page.
.i-20;Meta-}	End of Page.
.i-20;Meta-RUBOUT	Rubout Word.

.page
.i-20;Control-X Control-A	Define Abbreviation.
.i-20;Control-X Control-B	List Buffers.
.i-20;Control-X Control-C	Exit to Superior.
.i-20;Control-X Control-G	Abort Operation.
.i-20;Control-X Control-K	Read Killed Buffer
.i-20;Control-X Control-O	Delete Blank Lines.
.i-20;Control-X Control-R	Read File.
.i-20;Control-X Control-S	Save Current Buffer.
.i-20;Control-X Control-T	Transpose Lines.*
.i-20;Control-X Control-V	Visit File.
.i-20;Control-X Control-W	Write File.
.i-20;Control-X Control-X	Exchange Point and Mark.
.b
.i-20;Control-X (	Begin Keyboard Macro.
.i-20;Control-X )	End Keyboard Macro.
.i-20;Control-X 2	Split Window.
.i-20;Control-X B	Select Buffer.
.i-20;Control-X C	Create Window.
.i-20;Control-X D	Delete Window.
.i-20;Control-X E	Execute Keyboard Macro.
.i-20;Control-X K	Kill Buffer.
.i-20;Control-X Q	Keyboard Macro Query.
.i-20;Control-X [	Previous Page.
.i-20;Control-X ]	Next Page.
.i-20;Control-X ~	Unmodify Buffer.
.b
.i-20
The following functions are not bound to keys and are available via 
.i-20;Meta-X (extended command):
.b
.i-20;	Beginning of Screen.
.i-20;	Bind Function.
.i-20;	Bind Macro Slot.
.i-20;	Copy Key.
.i-20;	End of Screen.
.i-20;	Enlarge Window.
.i-20;	Execute File.
.i-20;	Finish File.
.i-20;	Indent Line.
.i-20;	Indent Region.
.i-20;	Insert File.
.i-20;	Justify Paragraph.
.i-20;	Load Macro Slot.
.i-20;	Major Mode.
.i-20;	Next Window.
.i-20;	Previous Window.
.i-20;	Reverse Scroll Screen.
.i-20;	Save and Run Superior.
.i-20;	Scroll Screen.
.i-20;	Set Mode Parameter.
.i-20;	Shrink Window.
.i-20;	Terminal Type.
.i-20;	Unindent Line.
.i-20;	Unindent Region.

.page
.Appendix $Bold(Command Summary by Name)
.paragraph
In the following list, an asterisk ($Bold(*)) means that the function
is not currently implemented, but will be in the near future.  Due to
the imminent release of these functions, they are included in this manual.
A "blank" following a function name means that it is only available via
the Meta-X (extended command) vehicle unless you bind a key to it, vis.:
.sk.indent 4;Meta-X#Bind#Function#_<esc_>#Beginning#of#Screen#_<esc_>#M-,
.sk
Now the function "Beginning of Screen" is available by typing "$Bold(M-)",
as well as by typing "M-X#Beginning#of#Screen".
.sk.ts 40
.br;Function Name	Command
.br;-------------	-------
.br;Abort Operation	Control-G
.br;Backward Character	Control-B
.br;Backward Word	Meta-B
.br;Begin Keyboard Macro	Control-X Meta-(
.br;Beginning of Line	Control-A
.br;Beginning of Page	Meta-{
.br;Beginning of Screen
.br;Beginning of Sentence*	Meta-A
.br;Beginning of Text	Meta-_<
.br;Bind Function
.br;Bind Macro Slot
.br;Copy Key  
.br;Copy Region	Meta-Control-W
.br;Create Window	Control-X C
.br;Delete Blank Lines	Control-X Control-O
.br;Delete Character	Control-D
.br;Delete Horizontal Space	Meta-_\
.br;Delete Window	Control-X D
.br;Delete Word	Meta-D
.br;Down Paragraph	Meta-]
.br;Down Text Line	Control-N
.br;End Keyboard Macro	Control-X )
.br;End of Line	Control-E
.br;End of Page	Meta-}
.br;End of Screen
.br;End of Sentence*	Meta-E
.br;End of Text	Meta-_>
.br;Enlarge Window
.br;Exchange Point and Mark	Control-X Control-X
.br;Execute File
.br;Execute Keyboard Macro	Control-X E
.br;Exit to Superior	Control-X Control-C
.br;Extended Command	Meta-X
.br;Finish File
.br;Forward Character	Control-F
.br;Forward Word	Meta-F
.br;Help Me	Meta-?
.br;Incremental Search	Control-S
.br;Indent Line
.br;Indent Region
.br;Insert File
.br;Invert Case Character	Control-_^
.br;Invert Case Region	Meta-Control-_^
.br;Invert Case Word	Meta-_^
.br;Justify Paragraph
.br;Keyboard Macro Query	Control-X Q
.br;Kill Buffer*	Control-X K
.br;Kill Line	Control-K
.br;Kill Region Mark	Control-W
.br;Kill Region String	Meta-W
.br;Kill Sentence*	Meta-K
.br;List Buffers	Control-X Control-B
.br;Load Macro Slot
.br;Major Mode
.br;Match Left Parenthesis	Meta-)
.br;Match Right Parenthesis	Meta-(
.br;Next Page	Control-X [
.br;Next Screen	Control-V
.br;Next Window
.br;Open Blank Lines	 Control-O
.br;Previous Page	Control-X [
.br;Previous Screen	Meta-V
.br;Previous Window
.br;Query Replace String	Meta-%
.br;Read File	Control-X Control-R
.br;Read Killed Buffer	Control-X Control-O
.br;Redisplay Screen	Control-L
.br;Replace String	Meta-_$
.br;Restore Killed Text	Control-Y
.br;Reverse Scroll Screen
.br;Reverse Search	Control-R
.br;Reverse String Search	Meta-R
.br;Rubout Character	_<Rubout_> or Control-H
.br;Rubout Word	Meta-Rubout or Meta-H
.br;Save File	Control-X Control-S
.br;Save and Run Superior
.br;Scroll Line to Top	Meta-!
.br;Scroll Screen
.br;Select Buffer	Control-X B
.br;Set Mode Parameter
.br;Set-Erase Mark	Control-@
.br;Shrink Window
.br;Split Current Window	Control-X 2
.br;String Search	Meta-S
.br;Terminal Type
.br;Toggle Display Output	Meta-O
.br;Transpose Characters	Control-T
.br;Transpose Lines*	Control-X Control-T 
.br;Transpose Regions*	Control-X T
.br;Transpose Words*	Meta-X
.br;Unindent Line
.br;Unindent Region
.br;Unmodify Buffer	Control-X ~
.br;Up Paragraph	Meta-[
.br;Up Text Line	Meta-]
.br;Visit File	Control-X Control-V
.br;Write File	Control-X Control-W

.page

.Do Index
RI