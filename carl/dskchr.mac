	TITLE DSKCHR & PACK ROUTINE TO GET DSKCHR'S
	SUBTTL	BY CARL A BALTRUNAS

	T1=1
	T2=2		;DEFINE A FEW TEMP AC'S
	T3=3
	T4=4
	P=17		;PUSHDOWN POINTER


DEFINE SETBIT(BIT,MEMORY)<
	MOVEI	1B<BIT>
	IORM	MEMORY
>

DEFINE CLRBIT(BIT,MEMORY)<
	MOVEI	1B<BIT>
	IORM	MEMORY
>

;NOW FOR A FEW BITS TO DEFINE

	.NOWRT=1B0		;DEFINE NO-WRITE STATUS
	.NOCRE=1B1		;DEFINE NO-CREATES

	CHAN=1			;SETUP A CHAN FOR LOOKUP

	ENTRY DSKCHR

	VER=1			;VERSION
	MVER=1			;MINER VERSION
	EDIT=10			;EDIT NUMBER

	OPDEF	DSKCHR	[CALLI 45]	;OPDEF SO WILL WORK

;SETUP TO DEFINE THE VERSION WITHOUT USING A MACRO
	LOC	137		;LOCATE AT ABSOLUTE 137
	XWD	VER*100+MVER,EDIT	;PUT IN THE VERSION & EDIT NUMBERS
	RELOC			;CONTINUE PROCESSING FROM THERE
DSKCHR:	RESET			;RESET ANY I/O DSKS
	SKPINL
	JFCL			;INHIBIT ^O
	SETZM	FENCE		;CLEAR THE FENCE OF GARBAGE
	SETOM	STRLST		;SET LIST NAME TO ZERO
	MOVE	P,[IOWD 50,PDL]	;SETUP PDLIST
	GETPPN	T1,		;GET THE USERS PPN
	JFCL			;NO-OP HERE
	OUTSTR	[ASCIZ\
User: \]			;TELL WHICH USER
	MOVEM	T1,FNAM		;PUT IT INTO FILENAME
	PUSHJ	P,OUTPPN	;PRINT THE PPN FROM REGISTER T1
	MOVSI	T1,'UFD'	;GET EXT
	MOVEM	T1,FEXT		;PUT IT INTO EXT AREA
	OUTSTR	[ASCIZ\
Str      Used   Left:(In) (Out)   (Sys)  Mount Logical Physical Unit-Id\]
GETSTR:	OUTSTR	[ASCIZ\
\]				;PRINT A CRLF
	MOVE	[XWD 4,STRLST]	;GET LIST TOGETHER
	JOBSTR			;GET FIRST STRUCTURE
	HALT			;STOP HERE IF PROBLEM
	AOSN	STRLST		;MAKE SURE NOT -1
	JRST	NOMORE		;NO MORE - STRUCTURES
	SOS	STRLST		;DECREMENT BACK TO SIZE
	SKIPN	STRLST		;SKIP IF NOT = ZERO
	JRST	[SETOM	FENCE
		JRST	GETSTR+1]	;SETUP FENCE FLAG
	SKIPGE	FENCE		;SKIP IF FENCE NOT SET
	JRST	[SETZM	FENCE	;ZERO THE FENCE
		OUTSTR	[ASCIZ\--Fence--
\]
		JRST	GETQTA-1];RETURN TO WHERE LEFT OFF
	MOVE	[XWD 17,STRLST]	;MAKE SURE IT'S THERE
GETQTA:	SETZM	STARS		;THIS SHOULD MAKE SURE THAT ALL IS OK
	SETZM	DSKHLT		;CLEAR THIS HERE
	DSKCHR			;ZERO SHOULD BE INTACT AT THIS POINT
	SETOM	DSKHLT		;SET THIS TO -1
	MOVE	T1,[POINT 6,STRLST]	;SETUP POINTER TO GET CHRS
CHRLP:	ILDB	T2,T1		;GET A CHR
	CAIN	T2,0		;IS IT A NULL ?
	JRST	COLON		;YES, DONE OUTPUT COLON CR ETC.
	ADDI	T2,40		;NO, ADD 40 TO MAKE 7-BIT
	OUTCHR	T2		;PRINT IT ON TTY
	JRST	CHRLP		;LOOP
COLON:	OUTSTR	[ASCIZ\:	\];OUTPUT ENDING
;	SKIPE	DSKHLT		;IF THE DSK IS BAD FORGET THE REST
;	JRST	GETSTR		;THIS IS A TEST
	MOVE	T1,STRLST	;GET THE PACK TO CHECK
	MOVEM	T1,OPNDEV	;ALSO PUT INTO OPEN BLOCK
	MOVEM	T1,FDEV		;PUT IT INTO FILE DEVICE BLOCK
	OPEN	CHAN,OPNBLK	;OPEN ON DSK PACK SPECIFIED
	HALT			;ERR HERE
	LOOKUP	CHAN,FILBLK	;LOOK FOR UFD FILE
	JRST	[OUTSTR	[ASCIZ\No \];TELL FIRST PART
		GETPPN	T1,		;GET THE PPN
		JFCL			;CATCH ANY PRIV. JOBS
		SETZ	T4,		;ZERO THE COUNTER
		PUSHJ	P,OUTPPN	;PRINT THE PPN
		OUTSTR	[ASCIZ\ Ufd\];print ending
		IDIVI	T4,10		;DIVIDE BY 10
		SKIPN	T4		;SKIP IF NON-ZERO
		OUTCHR	[11]		;PRINT A TAB
		JRST	SYSLFT]	;RETURN TO WHERE LEFT OFF
	RELEAS	CHAN,		;SHOULD BE ENOUGH
	MOVEI	T3,5		;SETUP FOR 6 CHARS
	MOVE	T2,STRLST+1	;GET USED LEFT ON STR
	MOVE	[XWD 400000,0]	;GET SIGN BIT
	CAME	T2		;ARE THEY EQUAL OR NOT?
	PUSHJ	P,UFDLGU	;DO IT THE RIGHT WAY
	JUMP	2		;SHOULD BE RIGHT AMOUNT
	MOVE	T1,LGOQTA+2	;GET THE USED QUOTA
	SKIPGE	T1		;MAKE SURE IT'S POSITIVE
	PUSHJ	P,MINUS		;MAKE MINUS
	PUSHJ	P,OUTDEC	;OUTPUT THE NUMBER
GETLFT:	OUTCHR	[11]		;PRINT A TAB
	MOVEI	T3,6		;GET THE FILLER AMOUNT
	MOVE	T1,STRLST+1	;GET FIRST LIST OWN DSKCHR
	MOVE	[XWD 400000,0]	;GET THE SIGN BIT
	CAMN	T1		;SEE IF THESE ARE EQUAL
	PUSHJ	P,UFDLGI	;GET LOGGED IN LEFT FROM UFD
	MOVE	[XWD 377777,0]	;GET BIGGEST NUMBER
	CAMGE	T1		;SEE IF INFIN
	PUSHJ	P,.INFIN	;PRINT INFINITE QUOTA
	JUMP	5		;ARGUMENT HERE
	MOVEI	T3,6		;GET 6 CHARS
	SKIPGE	T1		;NONE IF MINUS
	PUSHJ	P,MINUS		;GET THE MINUS PART TO WORK
	PUSHJ	P,OUTDEC	;PRINT IT
	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,LGOQTA-1	;GET LOGGED IN QUOTA
	MOVE	T2,STRLST+1	;GET IN-QUOTA LEFT
	MOVE	[XWD 400000,0]	;GET THE SIGN BIT HERE
	CAMN	T2		;SEE IF EQUAL HERE
	PUSHJ	P,UFDNOT	;NO USE TO UFD YET SO GET OTHR WAY
	JUMP	7		;MAKE IT READY FOR A JUMP
	MOVE	[XWD 377777,0]	;GET THE LARGE NUMBER
	CAMGE	T2		;SEE IF INFIN
	PUSHJ	P,.INFIN	;YES, PRINT IT
	JUMP	10		;7 THIS TIME
	MOVEI	T3,6		;FILIN FOR 6 CHARS
	SUB	T2,T1		;GET A MINUS DIFFERENCE
	MOVE	T1,LGOQTA	;GET THE LOGGED OUT QUOTA
	ADD	T1,T2		;ADD IN THE -DIFERENCE
	SKIPGE	T1		;SKIP IF GREATER OR EQ TO ZERO
	PUSHJ	P,MINUS		;GO TO PRINT ANY MINUS
	PUSHJ	P,OUTDEC	;PRINT IT
SYSLFT:	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,STRLST+2	;GET ALL LEFT ON THING
	MOVEI	T3,6		;JUSTIFY TO 6 CHARS
	SKIPGE	T1		;SKIP IF GREATER OR EQ TO ZERO
	PUSHJ	P,MINUS		;GO TO PRINT ANY MINUS
	PUSHJ	P,OUTDEC	;PRINT IT
	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,STRLST+7	;GET THE MOUNT COUNT
	MOVEI	T3,4		;JUSTIFY 4 PLACES
	PUSHJ	P,OUTDEC	;PRINT IT
	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,STRLST+14	;GET LOGICAL UNIT
	PUSHJ	P,OUTSIX	;PRINT 6 6-BIT CHRS FROM T1
	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,STRLST+15	;GET PHYSICAL UNIT
	PUSHJ	P,OUTSIX	;PRINT UNIT NAME
	OUTCHR	[11]		;PRINT A TAB
	MOVE	T1,STRLST+16	;GET UNIT ID
	PUSHJ	P,OUTSIX	;PRINT THE ID
	JRST	GETSTR		;GET IT

UFDLGI:	MOVE	T1,LGOQTA-1	;GET LOGGED IN QUOTA
	MOVE	LGUSD		;GET THE LOGGED USED FROM UFD
	SUB	T1,		;PUT RESULT IN T1
	POPJ	P,		;RETURN RIGHT AWAY

.INFUN:	MOVE	T1,LGUSD	;GET THE USED FROM UFD
	SKIPGE	T1		;SKIP IF MINUS
	PUSHJ	P,MINUS		;SET FLAG
	PUSHJ	P,OUTDEC	;PRINT IT
	OUTCHR	["@"]	;PRINT IT
	SETOM 	STARS		;MAKE VISIBLE
	POP	P,		;CLEAN OFF TOP
	JRST	GETLFT		;GO TO GET LEFT

UFDLGU:	MOVE	T1,LGOQTA-1	;GET THE LOGGED IN QUOTA
	MOVE	[XWD 377777,0]	;GET THE HIGH ONE
	CAMG	T2		;TEST IT
	JRST	.INFUN		;1,2 OR OTHER 1,* JOB WITH INFIN QTA.
	SUB	T1,T2		;GET USED NUMBER
	SKIPA			;SKIP TO WORK HERE
.INFIN:	OUTSTR	[ASCIZ\+Infin\]	;tell it's infinite
	HRRZ	@(P)		;GET THE VALUE IN ADR IN P
	ADDM	(P)		;ADD IT TO THE ADRESS
	POPJ	P,		;RETURN @ CORRECT LOCATION
MINUS:	IMUL	T1,[EXP -1]	;BY A WHOLE -1
	SETOM	DASH		;SET THE MINUS FLAG
	POPJ	P,		;RETURN

OUTSIX:	MOVEI	T3,6		;SETUP FOR ONLY 6 CHRS
	MOVE	T2,[POINT 6,T1]	;GET POINTER TO POINT AT T1
SIXLP:	ILDB	T2		;GET A BYTE
	ADDI	0,40		;MAKE ASCII 7-BIT
	OUTCHR			;PRINT IT ON TTY
	SOJG	T3,SIXLP	;LOOP TILL DONE
	POPJ	P,		;RETURN

OUTDEC:	IDIVI	T1,^D10		;DIVIDE BY 10 DECIMAL
	HRLM	T2,(P)		;PUT IT AWAY
	SOJ	T3,		;SUBTRACT FROM COUNTER
	JUMPE	T1,FILLER	;FILLIN IF NEEDED
	PUSHJ	P,OUTDEC	;LOOP TILL DONE
DECOUT:	HLRZ	T2,(P)		;GET THE CHR TO PRINT
	ADDI	T2,60		;MAKE A NUMBER
	OUTCHR	T2		;PRINT IT
	POPJ	P,		;RETURN WHEN DONE

FILLER:	SKIPE	DASH		;SKIP IF POSITIVE
	SOJ	T3,		;DECREMENT COUNT HERE
	JUMPLE	T3,DECOUT	;OUTPUT IF NEEDED
	OUTCHR	[40]		;PRINT A SPACE
	SOJG	T3,.-1		;LOOP IF NECESSARY
	SKIPE	DASH		;SKIP IF POSITIVE
	OUTCHR	[55]		;PRINT A MINUS
	SETZM	DASH		;MAKE SURE IT'S ZEROED NOW
	JRST	DECOUT		;PRINT NUMBERS


OUTPPN:	MOVEI	T3,6		;GET 6 CHRS
	SETZM	PPNFST		;SET THIS FLAG
	MOVE	T2,[POINT 3,T1]	;SETUP BYTE POINTER
	SETZM	PPNFLG		;MAKE SURE IT'S ZERO
BYTEPP:	ILDB	T2		;GET A NUMBER
	SKIPN			;SKIP IF NUN-NULL CHR
	SKIPE	PPNFLG		;SKIP IF FLAG SET
	SKIPA			;FILL IN FOR MISS HERE
	JRST	.+5		;FINISH LOOPING
	SETOM	PPNFLG		;SET SO REST OF 0'S PRINT
	ADDI	60		;ADD IN THE 60 NEEDED
	OUTCHR			;PRINT THE CHR
	AOJ	T4,		;INCREMENT T4
	SOJG	T3,BYTEPP	;LOOP HERE
	SKIPE	PPNFST		;SKIP IF FIRST HALF
	POPJ	P,		;RETURN HERE SINCE 2ND HALF DONE
	OUTCHR	[","]		;PRINT A COMMA
	SETOM	PPNFST		;SET TO -1
	MOVEI	T3,6		;TRY AGAIN
	JRST	BYTEPP-1	;LOOP AGAIN

UFDNOT:	MOVE	T2,LGUSD	;GET THE USED BLOCKS FROM UFD
	IMUL	T2,[EXP -1]	;MAKE MINUS HERE
	MOVEI	T3,6		;GET 6 CHARS HERE
	JRST	.INFIN+1	;get arg that way
NOMORE:	SKIPE	STARS		;SEE IF THERE ARE ANY STARS OUT
	OUTSTR	[ASCIZ\
 @ Means - Job Is Privaliged With Infinite Quota & Values May Differ
     From Those Specified Above.\]				;GIVE MESSAGE
	SETZM	STARS		;MAKE SURE STARS ARE CLEAR
	OUTSTR	[ASCIZ\
\]				;THAT'S IT
	RESET
	EXIT	1,
	EXIT			;JUST INCASE HE DOES A CONTINUE

FENCE:	BLOCK 1			;LOC FOR FENCE
DASH:	BLOCK	1		;FLAG FOR MINUS
STARS:	BLOCK	1		;SEE IF THE STARS ARE OUT
DSKHLT:	BLOCK	1		;HERE FOR THIS ONE
PPNFST:	BLOCK	1		;HERE FOR FIRST TIME
PPNFLG:	BLOCK	1		;HERE TO SET ZEROES
STRLST:	BLOCK 20		;MAKE SURE ENOUGH SPACE
PDL:	BLOCK 50		;THAT'S ENOUGH
OPNBLK:	XWD	400000,0	;SET STATUS SO THAT DEV MUST BE PHYS
OPNDEV:	BLOCK	1		;BLOCK FOR OPNDEVICE
	BLOCK	1		;BLOCK FOR BUFFERS

FILBLK:	EXP	27		;25 ARGS AT PRESENT
MFDHLD:	XWD	1,1		;[1,1] AREA
FNAM:	BLOCK	1		;SPACE FOR NAME
FEXT:	BLOCK	13		;SPACE FOR EXT & REST HERE UNUSED
FDEV:	BLOCK	5		;SPACE FOR DEV & UNUSED
LGOQTA:	BLOCK	2		;FIN REST & GET LOGGED OUT QUOTA
LGUSD:	BLOCK	5		;USED & REST EXTRA

	END DSKCHR
    