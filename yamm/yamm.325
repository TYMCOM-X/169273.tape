

























                                         ___ _______ _______ ______                                         Yet Another Monitor Manual

                                            "Cogito Ergo Spudd"
                                         (I think, therefore yamm)
                                         - Pliny the Junior 353 BC

                                                July 3, 1980































                                                                                William R. Soley
                                                                              Arthur A. Atkinson
                                                                          Tymshare, Incorporated
                                                                     Systems Technology Division
                                                                        20705 Valley Green Drive
                                                                           Cupertino, California
                                                                                           95014





      Copyright (C) 1979 by Tymshare, Inc.
      20705 Valley Green Drive
      Cupertino, CA   95014




              All rights reserved.  No part of this document may be reproduced in any form
              or by any means without permission in writing from Tymshare.

























              The information in this document is subject to change without notice and
              should not be construed as a commitment by Tymshare.  No responsibility is
              assumed for any errors that may appear in this manual.





                                            Reader Comment Form



            This form is for reader comments on the documentation.  For comments and bug reports
            regarding the software, the user should submit a Tymshare Software Report (TSR).


            Document:          YAMM

            Manuscript:        YAMM  .PUB

            Compile date:      July 3, 1980

            Compile time:      3:07

            Your name:         [                                   ]

            Organization:      [                                   ]

            Telephone:         [(     )     -      ]

            Date submitted:    [   /   /19   ]

            Address:           [                                   ]

            City/State/Zip:    [                            ], [   ]   [       ]

            Reply required?    [ ] Yes    [ ] No


            Please show your comments below.  Please include document page number for any
            references to the text.  If possible, include a copy of the page with the problem
            marked.  Please also mention any things you find ommited or unclear.




































                                               *  
                                             *   *
                                               *  


            July 3, 1980                                                       Table of Contents


                                             _____ __ ________                                             Table of Contents



            Section

                List of Tables    iv

            1     Preface    1-1
            1.1      Conventions    1-1
            1.2      Abbreviations    1-1
            1.3      Acknowledgements    1-2

            2     Frames and Processes    2-1
            2.1      Frame Identification    2-1
            2.2      Privilege    2-2
            2.3      Frame License    2-4
            2.4      Frame Status    2-6
            2.5      Session control operations    2-7
            2.6      Frame Generation and Control Operations    2-11
            2.7      Temporary files    2-33

            3     Virtual Memory    3-1
            3.1      High and Low Segments    3-1
            3.2      Job Data Area    3-3
            3.3      Core image files    3-5
            3.4      Execute-Only Programs    3-11

            4     Paging    4-1
            4.1      Hardware Paging    4-1
            4.2      Software Paging    4-1
            4.3      Creating Private Pages    4-3
            4.4      Unmapping Virtual Pages    4-4
            4.5      Replicating Virtual Pages    4-4
            4.6      Mapping File Pages    4-5
            4.7      Mapping Absolute Disk Pages    4-6
            4.8      Changing Page Protection    4-7
            4.9      Working Set Control    4-7
            4.10     Prereferencing Pages    4-9
            4.11     Uninterruptible Page Copy    4-10
            4.12     Paging Related Errors    4-11
            4.13     Page Faults    4-13
            4.14     Page Reference Bits    4-15
            4.15     Virtual Page Information    4-16

            5     General I/O    5-1
            5.1      Channels & I/O Initialization    5-1
            5.2      Device Assignment    5-1
            5.3      Channel Numbers    5-2
            5.4      Closing channels    5-2
            5.5      Releasing Channels    5-3
            5.6      File Status Bits    5-3
            5.7      Device Characteristics    5-4
            5.8      Device Manipulation    5-5
            5.9      Major I/O UUOs    5-8

            6     Buffered Mode I/O    6-1
            6.1      Buffer Ring Headers    6-1
            6.2      Buffer Format    6-2
            6.3      Buffer Setup    6-2
            6.4      Buffered I/O Operations    6-4
            6.5      I/O synchronization    6-6
            6.6      Buffered I/O Errors    6-6

            7     Dump Mode I/O    7-1
            7.1      Dump I/O Operations    7-1
            7.2      Dump I/O Errors    7-2

                                                     i


      Table of Contents                                                   YAMM edition 2.0

      Section
      8     Disk I/O    8-1
      8.1      Device Names    8-1
      8.2      Buffered I/O    8-2
      8.3      Dump I/O    8-2
      8.4      Directories    8-2
      8.5      Frame Search List    8-5
      8.6      Storage Allocation Table    8-5
      8.7      File Organization    8-5
      8.8      File Access Protection    8-6
      8.9      Directory Access Protection    8-7
      8.10     File Selection    8-8
      8.11     File Positioning    8-20
      8.12     Direct File Page Manipulation    8-23
      8.13     Specialized File Manipulation    8-25
      8.14     Reading Information    8-26
      8.15     Validating and Flushing    8-32

      9     Processor ID Mechanism    9-1
      9.1      Purpose of PID's    9-1
      9.2      Definition of PID    9-1
      9.3      Issuing PID's    9-1
      9.4      Authority Conferred by a PID    9-2
      9.5      Executing with a PID    9-2
      9.6      Manipulating the PID    9-2
      9.7      PID Handling on ENTER and RENAME    9-3
      9.8      PID's and Storage Accounting    9-3

      10    Port I/O    10-1
      10.1     Port Numbers and Device Names    10-1
      10.2     Command Ports    10-1
      10.3     Auxiliary Ports    10-2
      10.4     Reseting Ports    10-2
      10.5     Line Characteristic Word    10-3
      10.6     File Status Bits    10-3
      10.7     Port Operations    10-3
      10.8     Baud Rates    10-7
      10.9     Buffering and Backpressure    10-8
      10.10    Data Transmission Methods    10-8
      10.11    Character Handling    10-9
      10.12    Block I/O    10-18
      10.13    Port Creation,Moving,Deletion UUOs    10-19
      10.14    Port and Terminal Characteristics UUOs    10-25
      10.15    Echo,Break,Backpressure UUOs    10-28
      10.16    Port Input UUOs    10-29
      10.17    Output UUOs    10-36
      10.18    Port Block I/O UUOs    10-41

      11    Magnetic Tape I/O    11-1
      11.1     Device Names    11-1
      11.2     Recording Modes    11-1
      11.3     Parity    11-1
      11.4     Recording Density    11-1
      11.5     Begin and End of Tape Bits    11-2
      11.6     Buffered Tape I/O    11-2
      11.7     Dump Tape I/O    11-2
      11.8     MTAPE Operations    11-3
      11.9     UGETF Information    11-4

      12    Card Reader Input    12-1
      12.1     ASCII Mode Input    12-1
      12.2     Image Mode Input    12-1
      12.3     Binary Mode Input    12-1

      13    Line Printer Output    13-1
      13.1     Output    13-1
      13.2     Form Feeds    13-1
      13.3     KS2020 Line Printer Forms Control    13-1

                                               ii


            July 3, 1980                                                       Table of Contents

            Section
            14    Paper Tape I/O    14-1
            14.1     Leaders and Trailers    14-1
            14.2     ASCII Mode I/O    14-1
            14.3     Image Mode I/O    14-1
            14.4     Image Binary Mode I/O    14-1
            14.5     Binary Mode I/O    14-2

            15    Plotter Output    15-1
            15.1     Output    15-1
            15.2     Hardware Action    15-1

            16    Interrupt System and Sleeping    16-1
            16.1     Trapping Arithmetic and Stack Overflow    16-1
            16.2     APRENB Interrupt System    16-1
            16.3     INTADR Interrupt System    16-3
            16.4     Sleeping    16-8
            16.5     APRENB/INTADR Interaction    16-9

            17    Club Facility    17-1
            17.1     Purpose    17-1
            17.2     Definition    17-1
            17.3     Use of the Club UUOs    17-1
            17.4     Club UUOs    17-3

            18    Environmental Information    18-1
            18.1     Dates and Times    18-1
            18.2     GETTAB tables and functions    18-3
            18.3     Addressing Monitor Memory    18-10
            18.4     Lights and Switches    18-11

            19    Miscellaneous Operations    19-1
            19.1     Operator Functions    19-1
            19.2     Executing IO instructions (User-IOT)    19-4
            19.3     Accounting Device Control Functions    19-4
            19.4     Obsolete and Unavailable Functions    19-5

            20    Accounting    20-1
            20.1     Special charging    20-1
            20.2     Royalty Charging    20-5
            20.3     Writing Stream Records    20-6
            20.4     Stream Accounting Data    20-7


            Appendix

                UUOSYM.MAC    A-1
                System Calls by Name    B-1
                System Calls by Number    C-1
                Index    D-1



















                                                    iii


      List of Tables                                                      YAMM edition 2.0


                                         ____ __ ______                                         List of Tables


      Table


      Frames and Processes
      2-3      Frame Privilege Word    2-3
      2-5      Frame License Bits    2-5
      2-7      Frame Status Word    2-7
      2-8      Watch Bit Definitions    2-8
      2-12     Frame Descriptor Format    2-12
      2-15     Access Rights Definitions    2-15
      2-16     FRMOP standard error codes    2-17
      2-18     FRMOP calls by function    2-18
      2-19     FRMOP functions by number    2-19
      2-20     .FOCFM error codes    2-20
      2-25     System Start Vector Indicies    2-25
      2-26     Halt Status Classes & Types    2-26
      2-29     Rules for .FOCFH handle creation    2-29
      2-30     .FORSI Item Numbers    2-30

      Virtual Memory
      3-4      Job Data Area Locations    3-4

      Paging
      4-3      Page Protection Codes    4-3
      4-3b     VCREAT Error Codes    4-3
      4-7      VPROT Error Codes    4-7
      4-9      WSCTL Error Codes    4-9
      4-10     PREREF Error Codes    4-10
      4-11     BLTPAG error codes    4-11
      4-12     PERSET Error Codes    4-12
      4-12b    Page-error Status-word    4-12
      4-13     VALPAG Error Codes    4-13
      4-13b    Page Fault Word    4-14
      4-14     PGRSTS and PGISTS word formats    4-14
      4-16     REFBIT Error Codes    4-16
      4-17     Page Status Word Format    4-17
      4-17b    PAGSTS Error Code    4-17
      4-18     VPGFIL Error Codes    4-18
      4-19     Standard Paging error Codes    4-19

      General I/O
      5-3      File Status Bits    5-3
      5-4      Data Modes    5-4
      5-5      Device Characteristics Word    5-5
      5-8      SYSDVF Function Codes    5-8
      5-9      CHANIOs by function    5-9
      5-10     CHANIOs by number    5-10

      Disk I/O
      8-5      Special UFD status bits    8-5
      8-7      File Protection Codes    8-7
      8-8      Directory Protection Bits    8-8
      8-9      File Access State Transition Rules    8-9
      8-10     Argument Codes    8-10
      8-11     Short Lookup Block    8-11
      8-12     Extended Lookup Block    8-12
      8-19     File Selection Error Codes    8-19
      8-28     DSKCHR Data Block    8-28
      8-29     DSKCHR Status Bits    8-29
      8-30     GOBSTR error codes    8-30
      8-31     STRUUO function codes    8-31
      8-31b    STRUUO error codes    8-31
      8-33     DSK: File Status Bits    8-33

      Port I/O
                                               iv


            July 3, 1980                                                          List of Tables

            Table
            10-4     AUXCALs by function    10-4
            10-6     AUXCALs by number    10-6
            10-7     TTCALL functions by number    10-7
            10-22    RETACH error codes    10-22
            10-22b   CREAUX Error Codes    10-23
            10-25    Port Event-Status Bits    10-25
            10-26    Line Characteristics Word    10-26
            10-27    TTY: File Status Bits    10-27
            10-27b   Monitor Modes & Special Characters    10-27
            10-30    Port Character Input Calls    10-30
            10-36    Port Character Output Calls    10-36
            10-39    Port String Output Calls    10-39

            Magnetic Tape I/O
            11-4     MTAPE Functions    11-4
            11-5     UGETF Function Codes    11-5
            11-5b    FTA: File Status Bits    11-5

            Card Reader Input
            12-2     026 Card Codes    12-2
            12-2b    029 Card Codes    12-2
            12-3     CDR: File Status Bits    12-3

            Paper Tape I/O
            14-2     CDR: File Status Bits    14-2

            Plotter Output
            15-1     Plotter command bits    15-1
            15-2     PLT: File Status Bits    15-2

            Interrupt System and Sleeping
            16-3     APRENB Interrupt Bit Definitions    16-3
            16-4     Port Interrupt Cause Codes    16-4
            16-4b    General Interrupt Cause Codes    16-4
            16-7     INTRMT error codes    16-7

            Club Facility
            17-4     Club Interlock Status Flags    17-4
            17-7     Club Facility Standard Error Codes    17-7

            Environmental Information
            18-2     Time Zone Codes    18-2
            18-4     GETTAB tables by function    18-4
            18-6     GETTAB tables by number    18-6
            18-7     .GTCNF (GETTAB +11) Items    18-7
            18-7b    .GTLOG Bits (GETTAB -24)    18-7
            18-8     Terminal Identifier Codes    18-8
            18-8b    .GTLVD (GETTAB 16) Items    18-8
            18-8c    .GTNSW Items (GETTAB 12)    18-9
            18-9     .GTODP(GETTAB +15) items (ONCDSK parameters)    18-9
            18-10    .GTWSC(GETTAB +25) items (Wait State Codes)    18-10

            Miscellaneous Operations
            19-4     SETABK control bits    19-4

            Accounting
            20-1     XCHARG functions by number    20-1
            20-3     .XCSET Error Codes    20-3
            20-4     XCHARG Charge Table Entries    20-4
            20-6     Stream Royalty Record Words 5,6,7,10    20-6
            20-7     PUTSAR error codes    20-7
            20-7b    Stream Accounting Record Types    20-7
            20-8     Stream Accounting Record Lengths    20-8
            20-8b    Stream Record Std. Header words 0-4    20-8
            20-8c    Stream Record types 0-6 (GET/RUN etc) format    20-8
            20-8d    Change Project-Code Record words 5-7    20-8
            20-8e    System Initialization Record words 0-1    20-9
            20-9     Date Change Record words 0-5    20-9
                                                     v


      List of Tables                                                      YAMM edition 2.0

      Table
      20-9b    Local Stream Accounting Record words 5-7    20-9
      20-9c    SETLIC/SETE Record words 5-7    20-9
      20-9d    License-Setting RUN Record words 0-2    20-9
      20-9e    LOGINN Record words 3-6    20-10
      20-10    Uptime Record words 0-2    20-10
      20-10b   Restart Record words 0-1    20-10
      20-10c   Stream Error Record words 0-1    20-10
      20-11    LOGOUT and CHKPNT stream record format    20-11
      20-12    XCHARG stream record format    20-12



























































                                               vi


            July 3, 1980                             1                                   Preface


                                                 _______ _                                                 Section 1
                                                  _______                                                  Preface

                                             Table of Contents



            SubSection

        1.1      Conventions    1-1

            1.2      Abbreviations    1-1

            1.3      Acknowledgements    1-2





















































                                                    1-i


                                               1                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              1-ii


            July 3, 1980                             1                                   Preface





                                                 _______ _                                                 Section 1
                                                  _______                                                  Preface




            This document describes version P034 of the Tymshare Tymcom-X operating system.

            The material contained herein is provided primarily for the benefit of  the assembly
            language programmer.   Users of higher  level languages such  as FORTRAN,  COBOL and
            TymBasic may  have access to  some of the  calls described here  through subroutines
            provided  in libraries.   Also, languages  such as  BLISS and  SAIL provide  for the
            execution of these calls  within the syntax of the  language.  If you intend  to use
            these  calls from  one of  these higher  level languages,  you will  need  to become
            familiar with the way  the language presents its  data structures to the  call being
            executed in order to properly pass arguments between your program and the monitor.

            For MACRO programmers, there is a file SYS:UUOSYM.MAC which contains definitions for
            all of the uuos and functions described in this manual.  A copy of this file  may be
            found in the appendix.

            It is assumed that you are familiar with the PDP-10 instruction set as well  as with
            the architecture of  the machine as viewed  by a user program.   If this is  not the
            case, it would be advisable to obtain a copy of the following publications available
            from Digital Equipment Corp.:
                    ________ ____________ _________ ______                1)  MACRO-10 Programmer's Reference Manual, DEC-10-LALMA;
                    ____________ ________ _________ ______                2)  DECsystem-10 Hardware Reference Manual, DEC-10-XSRMA;


                   ___________            1.1    Conventions

            Regarding  the  radix of  numbers,  this  manual attempts  to  follow  the following
            convention:
                1)  In  examples  of  MACRO  code,  MACRO  conventions  are  used;  that is,
                    everything  is  octal  unless preceded  by  "^D"  or  similar construct.
                    Numbers indicating bit positions are always decimal.
                2)  Numbers representing locations of memory are octal.
                3)  Numbers representing locations of bits in a word are decimal.
                4)  Numbers preceeded with "'" are octal.
                5)  Numbers  followed by  "." or  "^D" are  decimal (except  "." for  end of
                    sentence).
                6)  Numbers followed by  "K" or "P" (ie.  256K or 512P) are  decimal numbers
                    denoting an amount of core (in 1024 or 512 word blocks).


                   _____________            1.2    Abbreviations

            The following abbreviations are used throughout this manual:
                ac             an accumulator
                AR             Access Rights
                BPI            Bits per inch
                c(x)           contents of location x
                CR             Carriage return
                CR LF          Carriage return, Line feed
                DEC            Digital Equipment Corporation
                DDB            Device Data Block
                E              Effective address
                EOF            End of File
                EPT            Exec Page Table
                EXT            File extension
                FD             Frame Descriptor
                I/O            Input and Output
                JBTPRV         Frame Privilege Word
                JBTSTS         Frame Status Word
                JOBDAT         "Job Data Area"
                                                    1-1


      Preface                                  1                          YAMM edition 2.0


          LDB            Line Data Block
          lh(x)          Left half of x
          LUD            Local User Directory
          MFD            Master File Directory
          OPR            Operator (or operator's terminal)
          PC             Program Counter
          PPN            Project Programmer Number
          PDL            Push Down List
          RIB            Retrieval Information Block
          rh(x)          Right half of x
          TTY            Terminal (teletype)
          UFD            User File Directory
          UPT            User Process Table
          UUO            User Unimplimented Operation (monitor call)
          VM             Virtual Memory (machine)


             ________________      1.3    Acknowledgements

                                                                       ___  ______      A large portion of the text  within this document was taken from The  Murray written
      by Murray Bowles.  The document has been somewhat reformatted since then and has had
      a number of new  features added to keep it  current with P034.  Aside from  the text
      Murray provided, I would also like to thank him for a number of macros which  I have
      partially used in the YAMM.

      We wish to thank Mike Hinckley for his supply of Pub macros and general Pub support.
      Pub is a real animal and it often takes at least two to quiet it.

      I also wish to thank my wife, Becky, for putting up with the long, late  hours spent
      on this project, and for bringing me little snacks as I worked.

                           ___ _______  _______ ______      Credit for the name (Yet Another  Monitor Manual) goes to Scott Daniels  who thought
      of it one night at 2:00 AM at the Red Coach.

      Bill Soley

































                                              1-2


            July 3, 1980                             2                      Frames and Processes


                                                 _______ _                                                 Section 2
                                            ______ ___ _________                                            Frames and Processes

                                             Table of Contents



            SubSection


            2.1      Frame Identification    2-1
            2.1.1       Account User Numbers (AUN,PPN,FPN)    2-1
            2.1.2       User and Process Names    2-1
            2.1.3       CHGPPN: change frame PPN (CALLI +74)    2-2
            2.1.4       GETPPN: get frame PPN (CALLI +24)    2-2
            2.1.5       PJOB: get frame number (CALLI +30)    2-2
            2.1.6       SETNAM: set frame name (CALLI +43)    2-2

            2.2      Privilege    2-2
            2.2.1       SETPRV: set frame privilege word (CALLI -11)    2-2
            2.2.2       SETMAL: set mail-waiting bit (CALLI -17)    2-3

            2.3      Frame License    2-4
            2.3.1       CHKLIC: check settable license (CALLI -31)    2-4
            2.3.2       SETE: set frame license (CALLI -7)    2-5
            2.3.3       SETLIC: set process license (CALLI -10)    2-5

            2.4      Frame Status    2-6
            2.4.1       SETJAL: set frame status bits (CALLI -21)    2-6

            2.5      Session control operations    2-7
            2.5.1       LOGIN: log a frame in (CALLI +15)    2-7
            2.5.2       .STWAT: set WATCH bits (SETUUO fn 6)    2-8
            2.5.3       Project Codes    2-8
                           CHPRJ: change project code (CALLI -61)    2-8
            2.5.4       Restricted Command Mode    2-9
                           SETRCF: set restricted cmnd file (CALLI -57)    2-9
            2.5.5       LOGOUT: log a frame out (CALLI +17)    2-9
            2.5.6       Alternate Logout Program    2-9
                           LOGOFF: Run Alternate Logout Program (CALLI -130)    2-9
                           SETALP: Set Alternate Logout Program (CALLI -127)    2-10
            2.5.7       EVICT: Cause Notice to Quit Interrupt (CALLI -134)    2-10
            2.5.8       HANG: hang a port or frame or frames (CALLI -32)    2-10

            2.6      Frame Generation and Control Operations    2-11
            2.6.1       Per Frame Program Number    2-11
            2.6.2       Universal Frame ID    2-11
            2.6.3       Frame Descriptors    2-12
                           Absolute FD    2-12
                           Other Frame FD    2-13
                              SETOTF: set other-frame FD (CALLI -126)    2-13
                           Handles    2-13
                              Family FD's    2-13
                              Created Handle    2-14
            2.6.4       Access Rights    2-14
                           Maximum Frame Rights    2-14
                           Handle Rights vs. Effective Rights    2-16
            2.6.5       FRMOP: Frame Operation (op code 044)    2-16
            2.6.6       Tree manipulation FRMOPs    2-19
                           .FOCFM: create frame (FRMOP fn 1)    2-19
                           .FOGFT: Graft Frame Subtree (FRMOP fn 24)    2-20
            2.6.7       Memory manipulation FRMOPs    2-20
                           .FORVA: read frame virtual address (FRMOP fn 2)    2-20
                           .FOWVA: write frame virtual address (FRMOP fn 3)    2-21
                           .FOREP: VREPLC to/from another frame (FRMOP fn 7)    2-21
                           .FOVRM: VREMOV in another frame (FRMOP fn 10)    2-21
                           .FOVCL: VCLEAR in another frame (FRMOP fn 11)    2-21
                           .FOGET: Setup frame core image from file (FRMOP fn 32)    2-21
                                                    2-i


      Frames and Processes                     2                          YAMM edition 2.0

      SubSection
                     .FOSAV: SAVE frame core image on file (FRMOP fn 34)    2-22
                     .FOSSA: SAVE frame core image on SHR file (FRMOP fn 35)    2-22
      2.6.8       State manipulation FRMOPs    2-22
                     .FOJMP: gate jump to frame (FRMOP fn 0)    2-22
                     .FOSAA: start frame at absolute address (FRMOP fn 4)    2-23
                     .FOHLT: halt frame (FRMOP fn 5)    2-23
                     .FORPC: Read Frame PC (FRMOP fn 6)    2-24
                     .FOCLR: Clear a Frame (FRMOP fn 14)    2-24
                     .FOSVA: start frame at vector address (FRMOP fn 22)    2-24
                     .FOHST: Read Halt Status Block (FRMOP fn 23)    2-25
                     .FOCON: continue frame (FRMOP fn 25)    2-27
                     .FOGIN: Gate-jump Initialization (FRMOP fn 26)    2-27
                     .FORUN: RUN program in frame (FRMOP fn 33)    2-27
      2.6.9       Rights and Handles FRMOPs    2-28
                     .FOCFH: Create Handle (FRMOP fn 12)    2-28
                     .FODFH: Destroy Handle (FRMOP fn 13)    2-29
                     .FORSI: Read Standard Access Rights Info (FRMOP fn 15)    2-30
                     .FORAR: Read Handle Access Rights (FRMOP fn 16)    2-30
                     .FORER: Read Handle Effective Rights (FRMOP fn 17)    2-30
                     .FOSMF: Set Max Frame Rights (FRMOP fn 20)    2-31
                     .FOCHR: Change Handle Rights (FRMOP fn 21)    2-31
                     .FOVCH: Validate Child Rights (FRMOP fn 27)    2-31
                     .FOCAR: Read Child Access Rights (FRMOP fn 30)    2-32
                     .FOCER: Read Child Effective Rights (FRMOP fn 31)    2-32
      2.6.10      EXIT: stop frame execution (CALLI +12)    2-32
      2.6.11      SETSTV: set start vector address (CALLI -137)    2-33

      2.7      Temporary files    2-33
      2.7.1       TMPCOR: do TMPCOR file i/o (CALLI +44)    2-33
      2.7.2       .TCRRF: read TMPCOR file (TMPCOR fn 1)    2-33
      2.7.2       .TCRDF: delete TMPCOR file (TMPCOR fn 2)    2-33
      2.7.3       .TCRWF: write TMPCOR file (TMPCOR fn 3)    2-34
      2.7.4       .TCRRD: read TMPCOR directory (TMPCOR fn 4)    2-34
      2.7.4       .TCRDD: clear TMPCOR directory (TMPCOR fn 5)    2-34
      2.7.5       .TCRFS: get free space count (TMPCOR fn 0)    2-34


      Table

      2-3      Frame Privilege Word    2-3
      2-5      Frame License Bits    2-5
      2-7      Frame Status Word    2-7
      2-8      Watch Bit Definitions    2-8
      2-12     Frame Descriptor Format    2-12
      2-15     Access Rights Definitions    2-15
      2-16     FRMOP standard error codes    2-17
      2-18     FRMOP calls by function    2-18
      2-19     FRMOP functions by number    2-19
      2-20     .FOCFM error codes    2-20
      2-25     System Start Vector Indicies    2-25
      2-26     Halt Status Classes & Types    2-26
      2-29     Rules for .FOCFH handle creation    2-29
      2-30     .FORSI Item Numbers    2-30















                                              2-ii


            July 3, 1980                             2                      Frames and Processes





                                                 _______ _                                                 Section 2
                                            ______ ___ _________                                            Frames and Processes




            Tymcom-X  provides slots  called "frames"  in which  virtual address  spaces  may be
            created and programs run.  Previous monitors have allowed only one address  space to
            be created by an incoming Tymnet circuit.  Since this address space was the  root of
            all activities generated  by the user,  it became known  as a "job".   P034/C allows
            many  such address  spaces  to be  generated in  a  controlled fashion  by  a single
            terminal user or incoming circuit.  Therefore "job" has become an ambiguous term.

            The entire complex  of activities invoked by  such a user or  circuit is known  as a
            "session".  We have  attempted to eliminate the  word "job" from this  manual, using
            instead "session" and "frame", where each is appropriate.

            All of the  information kept by the  monitor about a frame  is keyed on  an Absolute
            frame number.   This number  is assigned  by the  monitor when  it receives  a login
            message from Tymnet, or when a frame creates another frame.  Absolute  Frame numbers
            are reassigned when a frame is killed (logged out).

            More information about how frames  operate upon one another to create  a multi-frame
            session can be found on 2-11.


                   _____ ______________            2.1    Frame Identification

                     _______ ____ _______ _____________            2.1.1    Account User Numbers (AUN,PPN,FPN)

            An Account User Number  (or AUN) consists of  an 18-bit Global Account  Number (GAN)
            and an 18-bit Universal User Number (UUN).  The AUN is used to identify a  frame for
            accounting and some security purposes.  It is similar to DEC's PPN: the term  PPN is
            used in this document to refer to those AUNs associated with the file system, and in
            some cases the terms "project  number" and "GAN", and "programmer number"  and "UUN"
            are used interchangibly.

            A frame has associated with it three AUNs:
                1)  the "frame AUN" is the AUN corresponding to the username under which the
                    frame logged in
                2)  the  "frame PPN"  is initially  the same  as the  frame AUN  but  may be
                    changed  by  the CHGPPN  UUO  (CALLI +74, pg. 2-2).   It  identifies the
                    default  directory for  file  access operations;  it and  the  frame AUN
                    together determine which files a frame is considered to own (see 8-6)
                3)  the "frame FPN" is the AUN corresponding to the directory from which the
                    current (or last)  program was run.  If  a process is running  with Home
                    File (HF)  the file  system will  allow it  access to  files in  the FPN
                    directory.

                     ____ ___ _______ _____            2.1.2    User and Process Names

            There are two names which are maintained for each frame:
                1)  the user name  which corresponds to the  accounting AUN and is  the name
                    supplied by the user when logging in to the system.
                2)  the process name  which is the name  of the program currently  loaded in
                    the frame's virtual memory.
            The  user name  is provided  by  the LOGIN  UUO (CALLI +15,  pg. 2-7).   The process
            name is automatically  set by the  RUN UUO (CALLI +35, pg. 3-7)  as well as  the RUN
            and GET  commands.  A  process may  change its own  name by  executing a  SETNAM UUO
            (CALLI +43,  pg. 2-2).   The loader  typically  does a  SETNAM  to the  name  of the
            program it just loaded.




                                                    2-1


      Frames and Processes                     2                          YAMM edition 2.0


               _______ ______ _____ ___ ______ ____      2.1.3    CHGPPN: change frame PPN (CALLI +74)

              MOVE    ac, [ppn]
              CHGPPN  ac,
                error return  ; no Jacct (JL) license
              normal return

      If the process does not have  Jacct (JL) license, take the error  return; otherwise,
      set the frame PPN to <ppn> and skip-return.

               _______ ___ _____ ___ ______ ____      2.1.4    GETPPN: get frame PPN (CALLI +24)

              GETPPN  ac,
              return1
              return2

      Set c(<ac>) to the frame  PPN.  Nonskip-return if JB.JAC =  0, or if JB.JAC =  1 and
      this is the only frame running with  this PPN.  Skip-return is JB.JAC = 1  and there
      are other frames running with this PPN.

               _____ ___ _____ ______ ______ ____      2.1.5    PJOB: get frame number (CALLI +30)

              PJOB    ac,
              only return

      Set AC to the caller's Absolute Frame number, and return.

               _______ ___ _____ ____ ______ ____      2.1.6    SETNAM: set frame name (CALLI +43)

              MOVE    ac, [SIXBIT /program name/]
              SETNAM  ac,
              only return

      Set  the frame's  program  name to  <program name>  and  clear the  frame  FPN (this
      effectively turns  off Home File  (HF) license,  since there are  no files  with PPN
      0,,0).


             _________      2.2    Privilege

      The initial value  of .GTPRV for  a frame is provided  either when the  LOGINN (sic)
      program performs a  LOGIN UUO (CALLI +15, pg. 2-7),  or when another  frame performs
      a .FOCFM UUO (FRMOP fn 1, pg. 2-19).  Some  of the bits and fields in  the privilege
      word actually describe  privileges, and cannot  be changed without  license; others,
      such as the monitor mode or time zone fields, can be altered by anyone.

               _______ ___ _____ _________ ____ ______ ____      2.2.1    SETPRV: set frame privilege word (CALLI -11)

              MOVE    ac, priv
              SETPRV  ac,
              only return

      where <priv> is a frame privilege word,
      as shown in Table 2-3 

      Set those fields in the current  frame's frame privilege word which are  marked with
      "*" in Table 2-3   to the the corresponding  fields of <priv>, leaving  the unmarked
      fields unchanged.  If the JP.COR field is greater than JP.CRM, reduce it to JP.CRM.

      Return.








                                              2-2


            July 3, 1980                             2                      Frames and Processes


                                                 _____ ___                                                  Table 2-3 
                                            _____ _________ ____                                            Frame Privilege Word


            Symbol   Bits      Description

            * - indicates that this field is settable with the SETPRV UUO, (see 2-2).

            JP.1UU   1b0       unused
            JP.NAT   1B1       * no attach at login
            JP.DST   1B2       * daylight savings applies
            JP.ZON   37B7      * applicable time zone (see Table 18-2 ).
            JP.2UU   77B10     unused
            JP.COR   177B17    * max core for frame
                               (max / 4) + 1 where max is the maximum number of pages that can
                               exist in the frame's address space at any one time.  This field
                               can be set to any value up to the value stored in JP.CRM
            JP.EXO   1B18      execute only program
            JP.DOP   3B20      * disconnect options
                               one of the following which determine the action taken upon
                               disconnect (circuit zapper received on command port):
                               .JPLOG    0         Logout on disconnect
                               .JPDET    1         Detach on disconnect
                               .JPCON    2         Continue on disconnect
                               .JPDTO    3         Detach (15 min timeout)
            JP.TYM   1B21      Tymshare proprietary
            JP.ASV   1B22      Account supervisor
            JP.MAL   1B23      Mail-waiting
                               set by the SETMAL UUO, and cleared by the command processor when
                               it prints the "MAIL WAITING" message.
            JP.XOG   1B24      Execute only get
                               Set by the monitor while it is in the process of loading an
                               execute-only program.
            JP.3UU   1B25      unused
            JP.RCM   1B26      * Restricted command mode.
            JP.MOD   3B28      * monitor mode
                               .JPMPD    0         PDP-10 mode
                               .JPMXE    1         XEXEC mode
                               .JPMXJ    2         XEXECJ (Japan)  mode
                               .JPMSU    3         SUDS mode
            JP.CRM   177B35    Maximum value for JP.COR which can be set by SETPRV.


                     _______ ___ ____________ ___ ______ ____            2.2.2    SETMAL: set mail-waiting bit (CALLI -17)

                    MOVEI   ac, addr
                    SETMAL  ac,
                    only return

            where <addr> points to a word containing 0
                    to set mail-waiting for all frames,
                    or to a (2-word) SIXBIT username
                    to set mail-waiting for all frames logged-in
                    to that username.

            If the current process  cannot delete a file in  SYS that has ALL NO  NO protection,
            just return.

            If c(<addr>) = 0, set the mail-waiting bit for every frame in the system and return.

            if c(<addr>)  is nonzero, set  the mail-waiting  bit for every  frame in  the system
            logged-in with the username pointed to by <addr> and return.






                                                    2-3


      Frames and Processes                     2                          YAMM edition 2.0


             _____ _______      2.3    Frame License

      The  monitor  maintains three  license  for each  frame,  each one  being  an 18-bit
      quantity laid out as in Table 2-5 .   Frame license belongs to the frame  itself and
      represents the "baseline"  from which all process  license is set.   Process license
      belongs to each process which inhabits the frame; it is re-initialized when  the PNO
      changes and can  be set by  the SETLIC UUO  (CALLI -10, pg. 2-5).  File  license can
      be used  to set  up process  license if the  file is  loaded into  the frame  by the
      monitor.

      When  the monitor  loads a  frame from  a file,  it sets  up the  process  and saved
      licenses from  the maximum  of the  file license  and the  frame license  (see 3-5).
      The  saved license  is retained  by the  monitor so  that a  process can  reduce its
      license with SETLIC UUO (CALLI -10, pg. 2-5) and then restore it.

      The CORE n (where n  is not 0), SSAVE, SAVE,  and FINISH commands set the  saved and
      process licenses back to the frame license.

      A program  can read the  current frame  and process license  from the  .GTLIC GETTAB
      table.  See Table 18-4 .  The process license bits are in the left half of  the word
      returned and the frame license bits in the right half.

               _______ _____ ________ _______ ______ ____      2.3.1    CHKLIC: check settable license (CALLI -31)

              MOVE    ac, [bits,,addr]
              CHKLIC  ac,
              only return

      where <bits> is '1 to use c(<addr>+1) in place of the
                         current frame's process,,frame license
                    + '2 to check the license settable for
                         a file rather than the license
                         settable for the frame

      and <addr> points to a block of the form
              wd 0    proc,,frame lic desired (or 0,,file lic)
              wd 1    proc,,frame current license (if '1 bit is set)
              wd 2    XOR of file and frame PPN (if '2 bit is set)

      If the  '1 bit of  <bits> is set,  let <cproc> be  c(<addr>+1 left) and  <cframe> be
      c(<addr>+1 right); otherwise let them be the current process and frame licenses.

      If the '2 bit of <bits> is set,

          Set  <dlic> to  c(<addr> right).   Turn  off those  bits in  <dlic>  which a
          process whose license was <cproc> and whose relationship to the owner of the
          file was as specified by c(<addr>+2).  Set c(<ac> right) to <dlic>.

      Otherwise,

          Set <dproc>  to c(<addr> left)  and <dframe> to  c(<addr> right).   Turn off
          those  bits in  <dproc>  and <dframe>  which  a process  running  with frame
          license <cframe>  and process license  <cproc> could not  set with  a SETLIC
          UUO.  Set c(<ac> left) to <dproc> and c(<ac> right) to <dframe>.

      Return.












                                              2-4


            July 3, 1980                             2                      Frames and Processes


                                                 _____ ___                                                  Table 2-5 
                                             _____ _______ ____                                             Frame License Bits


            name     bits  function

            LC.WC    1B0   Write Core (POKE UUO)
            LC.RC    1B1   Read Core (VPEEK UUO)
            LC.OP    1B2   Operator (SETUUO UUO)
            LC.SY    1B3   SYSTAT (read protected GETTAB tables)
            LC.GD    1B4   Get Devices (INIT devices other than TTY and DSK)
            LC.TD    1B5   Transfer Devices (REASSI UUO)
            LC.ST    1B6   Manipulate Structures (manipulate file structures using STRUUO UUO)
            LC.HF    1B7   Home Files (allow access as owner to files whose PPN matches the
                           frame FPN)
            LC.JL    1B8   Priviledged System Program (set restricted bits in the frame status
                           word; set JBTAUN, JBTPPN, etc; read/write any UFD)
            LC.AC    1B9   Auxiliary Circuits (build more than two aux circuits; build an aux
                           circuit to a AUN other than the frame's own)
            LC.XC    1B10  XCHARG (adjust charges using the XCHARG UUO)
            LC.RPS   3B15  read priviledges (a field)
                           .LCRP    1     read project
                           .LCRF    2     read files
                           .LCRA    3     read absolute
            LC.WPS   3B17  write priviledges (a field)
                           .LCWP    1     write project
                           .LCWF    2     write files
                           .LCWA    3     write absolute


                     _____ ___ _____ _______ ______ ___            2.3.2    SETE: set frame license (CALLI -7)

                    MOVEI   ac, [
                            ASCII /password word 1/
                            ASCIZ /password word 2/
                            password number
                            0,,desired license
                    ]
                    SETE    ac,
                      error return
                    normal return

            Hash  the two-word  password supplied  and check  the result  against the  hash code
            stored for <password number> in the monitor: if the two do not match, error-return.

            Set the frame license to <desired license> after turning off any license in <desired
            license> that is not permitted by  the license for <password number> in  the monitor
            tables, and setting the read  (write) privilege to 0 if <desired  license> specifies
            more privilege than that table entry; then skip-return.

                     _______ ___ _______ _______ ______ ____            2.3.3    SETLIC: set process license (CALLI -10)

                    MOVE    ac, [process,,frame]
                    SETLIC  ac,
                    only return

            Let <max> be the maximum of the current frame license and saved license.

            Set the process license to <process> after turning off any license in <process> that
            is  not set  in <max>,  and setting  the read  (write) privilege  to 0  if <process>
            specifies more privilege than <max>.

            If <max> does not have Write Core (WC) set, set <max> to the current  frame license.
            (Note that Write Core (WC) was not required to increase frame license under previous
            monitors.)

            Set the frame license  to <frame> after turning off  any license in <frame>  that is

                                                    2-5


      Frames and Processes                     2                          YAMM edition 2.0


      not set in <max>, truning off  Home File (HF) license, and setting the  read (write)
      privilege to 0 if <frame> specifies more privilege than <max>.

      Return.


             _____ ______      2.4    Frame Status

      The frame  status word contains  various bits  which are mostly  of interest  to the
      monitor.  The JB.JAC and JB.LOG bits can be set or cleared by any process with Jacct
      (JL) license, and JB.JA2 by any process.

      The frame status word can be read from the .GTSTS GETTAB table.

               _______ ___ _____ ______ ____ ______ ____      2.4.1    SETJAL: set frame status bits (CALLI -21)

              MOVE    ac, status
              SETJAL  ac,
                error return
              normal return

      If the process has Jacct (JL)  license, set JB.JAC, JB.LOG, and JB.JA2 in  the frame
      status word from the corresponding bits of <status> and skip-return.

      If the process does not have Jacct (JL) license, set JB.JA2 in the frame status word
      from the corresponding bit  of <status>, then take  the normal return if  the JB.JAC
      and JB.LOG bits in the two match and the error return if they do not.









































                                              2-6


            July 3, 1980                             2                      Frames and Processes


                                                 _____ ___                                                  Table 2-7 
                                             _____ ______ ____                                             Frame Status Word


            * - settable with SETJAL UUO (CALLI -21, pg. 2-6)

            Symbol   Bits     Description

            JB.RUN   1B0      Frame is runnable
            JB.CMW   1B1      Waiting to execute command
                              set only if monitor-level command (e.g. RUN, WHO, FILES, LOG etc.)
                              is pending but cannot immediately be executed;
            JB.MRQ   1B2      Frame has page faulted and needs the swapper to swap something in;
                              OR the monitor has swapped out the frame's context pages
            JB.JNA   1B3      Frame number assigned
            JB.JER   1B4      A monitor-detected error has occurred - causes the CONTINUE
                              command to fail
            JB.ESC   1B9      An escape was typed while the frame was in command mode and not in
                              input wait
            JB.WSC   37B14    Wait state code (zero if process is running) see Table 18-10 
            JB.LOG   1B15     * Frame is logged in - cleared by the LOGOUT program just before
                              executing the LOGOUT UUO (settable with SETJAL if process has
                              Jacct (JL) license).
            JB.JRQ   1B16     Frame must be requeued
            JB.JAC   1B17     * Frame cannot be stopped; this makes the frame immune to escapes
                              and to the HALT command (settable with SETJAL if process has Jacct
                              (JL) license).
            JB.WAK   1B19     WAKE pending (see 16-9, 17-6).
            JB.JA2   1B20     * Frame shouldn't be stopped.  A nonprivileged version of JB.JAC
                              (settable with SETJAL).
            JB.UTR   1B21     Trap to user on UUO exit.
            JB.DCN   1B22     Waiting for oper action.
            JB.PRF   1B24     The frame has prereferenced a page that was not in core.
            JB.SIP   1B25     The swapper is currently bringing in pages for the frame.
            JB.SCP   1B26     The swapper has taken away pages from the frame (cleared when the
                              frame's in-core-protect time is reset).



                   _______ _______ __________            2.5    Session control operations

                     ______ ___ _ _____ __ ______ ____            2.5.1    LOGIN: log a frame in (CALLI +15)

                    MOVE    ac, [-count,,addr]
                    LOGIN   ac,
                    only return     ;no return if this contains a HALT

            where <addr> points to a block of <count> words:
            JBTPPN   wd 0   initial frame PPN
            JBTPRV   wd 1   initial frame privilege word
            JBTAUN   wd 2   initial frame AUN
            JBTUNM   wd 3   first word of SIXBIT username
            JBTUN1   wd 4   second word of SIXBIT username

            If JB.LOG is set for the frame (already logged-in), abort the process and store halt
            status HT.ILU for the frame.

            Copy as many  words as are  defined or specified  by <count>, whichever  is smaller,
            into  the appropriate  monitor tables.   Set JB.LOG  in the  frame status  word.  If
            JP.COR is greater than JP.CRM, set JP.COR = JP.CRM.

            If the instruction following  the LOGIN UUO is a  HALT, perform the equivalent  of a
            RELEAS UUO for all initted channels, type a prompt sequence on the command port, and
            put the port into command mode; otherwise just return.




                                                    2-7


      Frames and Processes                     2                          YAMM edition 2.0


               _______ ___ _____ ____ _______ __ __      2.5.2    .STWAT: set WATCH bits (SETUUO fn 6)

              MOVE    ac, [.STWAT,,watch]
              SETUUO  ac,
                JFCL  ; never taken
              normal return

      Set the right half of the frame's watch word to <watch> and skip-return.


                                           _____ ___                                            Table 2-8 
                                     _____ ___ ___________                                     Watch Bit Definitions


      Name     Bit   Function

      ST.WDY   1B19  time-of-day
      ST.WRN   1B20  run time (TRUs)
      ST.WWT   1B21  wait time
      ST.WDR   1B22  disk reads (blocks)
      ST.WDW   1B23  disk writes (blocks)


               _______ _____      2.5.3    Project Codes

      The monitor keeps a "project code" for each frame.  The notion of a project  code is
      different from the notion of a frame's project number, or GAN.  The project  code is
      set by the CHPRJ  UUO (which, in turn, is  executed by LOGINN and PROJEC  after they
      have verified, if necessary, that the user is authorized to use that project code).

      The monitor also has a "project code  verify" bit for each frame, which is  also set
      by  CHPRJ.  Until  a frame's  project-code-verify bit  has been  set, no  license is
      required to change  its project code;  after it has been  set, XCharge (XC)  or Read
      Project (RP) license is required.

      The monitor writes a  stream acounting record every  time a frame's project  code is
      changed.   It  also stores  a  frame's project  code  (and its  verify  bit)  into a
      three-word field  (.RBPJC) in the  RIB of  each non-UFD file  created by  the frame.
      (The  .RBPJC field  in UFDs  is  used by  the LOGINN  and PROJEC  programs  to store
      information specifying how to (or whether to) verify project codes).

      To  change a  frame's project  code, a  program executes  the CHPRJ  UUO (CALLI -61,
      pg. 2-8).

                 ______ ______ _______ ____ ______ ____      2.5.3.1    CHPRJ: change project code (CALLI -61)

              MOVE    ac, [bits,,addr]
              CHPJC   ac,
                error return
              normal return

      where <bits> = 0 to read current project code
                       and verify bit
                     1 to set project code but not change
                       verify bit
                     3 to set both project code and
                       verify bit

      where <addr> points to a block of the form
              wd 0            chars 1-5 of project code
              wd 1            chars 6-10 of project code
              wd 2 bits 0-13  chars 11-12 of project code
              wd 2 bits 14-34 0
              wd 2 bit 35     project-code-verify bit

      If <bits>  = 0, store  the current project  code and project-code-verify  bit values
      into the block at <addr>, and skip-return.

                                              2-8


            July 3, 1980                             2                      Frames and Processes


            If <bits> = 1 or 3, error-return if the project-code-verify bit is set for the frame
            and the process does not have either XCharge (XC) or Write Absolute (WA) license.

            If <bits> = 1,  set the frame's project code  from the block at <addr>,  leaving the
            verify bit unchanged, and skip-return.

            If <bits>  = 3,  set both  the project code  and the  verify bit  from the  block at
            <addr>, and skip-return.

                     __________ _______ ____            2.5.4    Restricted Command Mode

            If the JP.RCM bit is set in a frame's frame privilege word, the monitor will process
            only the commands

                    EXIT    HALT    DETACH  CONTINUE
                    LOGOUT  KJOB    BYE

            If any  other command  is typed, the  monitor will  execute the  frame's "restricted
            command file".

            The restricted  command file is  specified by executing  the SETRCF  UUO (CALLI -57,
            pg. 2-9).

                       _______ ___ __________ ____ ____ ______ ____            2.5.4.1    SETRCF: set restricted cmnd file (CALLI -57)

                    MOVEI   ac, [
                            SIXBIT /filename/
                            ppn
                    ]
                    SETRCF  ac,
                    only return

            Set the frame's restricted command file  to be the file <filename> in  the directory
            <ppn> and return.

                     _______ ___ _ _____ ___ ______ ____            2.5.5    LOGOUT: log a frame out (CALLI +17)

                    LOGOUT
                    ; no return

            If JB.LOG is 1, just do an EXIT UUO.

            Otherwise, release all resources held by the frame, restore its command port  to the
            initial state, stop the frame, and clear its frame status word.

                     _________ ______ _______            2.5.6    Alternate Logout Program

                       _______ ___ _________ ______ _______ ______ _____            2.5.6.1    LOGOFF: Run Alternate Logout Program (CALLI -130)

                    MOVSI   AC,<start-addr-increment>
                    LOGOFF  AC,
                      error return          ; can't run required program
                    no-ALP-set return       ; KJOB pending and no ALP



            The KJOB pending bit is set by the LOGOUT program when the LOGOFF sequence is begun.

            If  "KJOB pending"  is set  for the  caller's process,  and if  an  Alternate Logout
            Program has  been established by  SETALP UUO (CALLI -127,  pg. 2-10) then  attempt a
            RUN  UUO  (CALLI +35, pg. 3-7)  on  the  Alternate Logout  Program  (ALP).  If "KJOB
            pending" is set but no ALP has been set, take the <no-ALP-set> return.

            If the  RUN succeeds,  do not return  to the  caller.  If the  RUN fails,  abort the
            process and store halt status HC.xxx for the frame.

            If "KJOB pending" is not set, run (SYS)LOGOUT.

                                                    2-9


      Frames and Processes                     2                          YAMM edition 2.0


                 _______ ___ _________ ______ _______ ______ _____      2.5.6.2    SETALP: Set Alternate Logout Program (CALLI -127)

              MOVEI   AC,<addr>
              SETALP  AC,
               error return   ;AC unchanged
              normal return   ;AC unchanged

      where the arguments at <addr> are:

      ADDR:   SIXBIT /<filename>/
              PPN


      If an Alternate Logout  Program has already been  established for the caller,  or if
      the logout process is already underway, take the error return.

      Store <filename> and <PPN> for later use by LOGOFF UUO (CALLI -130, pg. 2-9).

               ______ _____ ______ __ ____ _________ ______ _____      2.5.7    EVICT: Cause Notice to Quit Interrupt (CALLI -134)

              MOVE    AC,[<flag>,,<frame>]
              EVICT   AC,
               error  return
              normal return   ;AC contains <channel number>

      where <flag> is as follows:
      1       ;cause the interrupt
      0       ;simply return <channel number>

      If the  caller does  not have .ARHLT  rights to  <frame>, or if  the frame  does not
      exist, take the error return without modifying AC.

      Set  AC to  the  software interrupt  channel on  which  .IANTQ (notice  to  quit) is
      assigned for  the target  frame.  If  the interrupt  is not  assigned in  the target
      frame, set AC to 0 and take the normal return.

      If EV.NTQ was set in lh(AC),  cause an interrupt on the appropriate channel  for the
      target frame.

      Take the normal return.

               _____ ____ _ ____ __ _____ __ ______ ______ ____      2.5.8    HANG: hang a port or frame or frames (CALLI -32)

              MOVE    ac, [bits,,frame or port]
              HANG    ac,
                error return
              normal return

      where <bits> = '10 to hang a line already hung
                      '4 to hang all frames then go to "BOOTS LOADED"
                      '2 to force logout even if the frame has
                        JP.DET or JP.TIM set
                      '1 is specifying a frame rather than a
                        port number

      If the process does not have Write Core (WC) license, take the error return.

      If <bits>='10 and <port> is logged-in,  take the error return; send a zapper  on the
      (already zapped) <port> and take the normal return.

      Otherwise, if  <port> does not  exist or is  not logged-in, or  if <frame>  does not
      exist, take the error return.

      If  the '4  bit  is set  in  <bits>, set  the  system super-shut,  then  perform the
      equivalent of a HANG UUO with <bits> = '2 for every port in the system.

      If the '1 bit is set in <bits> (indicating that a frame rather than a port  is being

                                              2-10


            July 3, 1980                             2                      Frames and Processes


            specified), proceed  as if  that frame's command  port had  been specified.  (If the
            frame is running detached, attach it to a fake port and proceed).

            Simulate the effect of  a circuit zapper arriving at  the port, except that,  if the
            port is a frame's command port and bit '2 is set in bits, always force a  logout for
            the frame  regardless of the  setting of  JP.TIM and JP.DET  in its  frame privilege
            word.


                   _____ __________ ___ _______ __________            2.6    Frame Generation and Control Operations

            A variety of operations are available as subfunctions of the FRMOP UUO (op code 044,
            pg. 2-16) to  allow any process  to create, delete,  move, and control  the contents
            and priviledges of, other frames.  For a quick summary, see Table 2-18 .

            These operations allow a  process to exercise all the  control over what goes  on in
            another frame that  could be exercised  by the user  at his terminal  under previous
            monitors.  The result is that a  terminal user can develop a session  which consists
            of numerous address spaces [the  different frames] with different programs  in them,
            related to one another in a hierarchy known as a "frame tree".  A session is  a tree
            of frames whose  root frame is  ordinarily created by the  monitor in response  to a
            network login message.

            This root frame may contain any process, although in many cases users will choose to
            have it contain the system executive program XEXEC.

            The root frame may create  "children" (subordinate frames), place programs  in those
            child  frames,  run  them  in  parallel  or  serially,  control  their  input/output
            abilities, handle  their exception conditions  (ILL MEM REF,  etc.), give  access to
            them to  other processes in  the system, and  even "hand them  off" (graft  them) to
            other sessions.

                     ___ _____ _______ ______            2.6.1    Per Frame Program Number

            For each  frame the system  maintains a  Program Number.  Every  GET operation  on a
            frame causes its PNO to be  incremented.  For a given frame, then, the  PNO uniquely
            identifies the program or process in the  frame.  If a new program is placed  in the
            frame,  process handles  to  the previous  program  become invalid  because  the new
            program is identified by a new PNO.

            The operations which change a frame's PNO are:
                1)  .FOGET and GET command
                2)  .FORUN, RUN command, and RUN UUO
                3)  .FOCLR

                     _________ _____ __            2.6.2    Universal Frame ID

            For  each frame  the system  maintains a  Universal Frame  ID which  is  assigned at
            creation of the frame and is guaranteed unique to that frame during  any incarnation
            of the  system (i.e.,  between system  bring-up and  crash or  take-down).  Absolute
            Frame Numbers  on the other  hand, do  not uniquely identify  frames, since  a frame
            occupying slot N might be destroyed and another frame created later in the same slot
            N.  The new frame would, however, have a new UID by which it could  be distinguished
            from the old frame in that same Absolute Frame Number slot.














                                                    2-11


      Frames and Processes                     2                          YAMM edition 2.0


               _____ ___________      2.6.3    Frame Descriptors

      Frame Descriptors are the means by  which a user program talks about  frames.  Frame
      Descriptors (FD's)  come in  several types described  in Table 2-12 .   An FD  is an
      18-bit quantity. In Table 2-12  the bit-positions are shown assuming that the  FD is
      in a low-order half-word, as is the case with most FRMOP arguments.

      The  subtype field  is ignored  for those  types which  do not  have  subtypes.  For
      instance, an Absolute FD (type 0)  has no subtypes; the subtype field is  treated as
      being 0,  so that the  Absolute FD  functions like a  "job number"  functioned under
      previous monitors.  Likewise, the FD.SLF has no subtype; nor is the data field used;
      if the caller passes 777777 as his  FD, he is referring to himself, in the  same way
      that -1 has traditionally referred to "self" in UUOs under previous monitors.

      Any  fields which  are  documented as  "ignored" should  be  set to  zero,  with the
      exception of 777777 for FD.SLF.   Non-zero data in these fields may  produce strange
      results in the future.

                 ________ __      2.6.3.1    Absolute FD

      FD.ABS handles exist  automatically by their nature.   An Absolute FD  (FD.ABS) will
      work  only  if  some  (depending on  the  operation)  combination  of  the following
      conditions are met:
          1)  caller has Systat (SY) license
          2)  caller has JP.TYM (Tymshare Proprietary) priviledge
          3)  caller has Read Core (RC) or Write Core (WC) license
          4)  caller is parent of target
          5)  caller has same AUN as target
          6)  caller  has same  GAN as  target, and  caller has  JP.ASV  (Acct. Supv.)
              priviledge
      In the last 2  cases, the caller is given  access to the target frame  equivalent to
      Systat (SY) license.


                                          _____ ____                                           Table 2-12 
                                    _____ __________ ______                                    Frame Descriptor Format



      the frame descriptor format looks like TSXXXX
      where each character is an octal digit as follows:
              T    = type code
              S    = subtype code
              XXXX = index (abs frame no, handle index, etc)

      the values for these fields are as follows:

      FD.ABS   0B20  absolute type FD
                     X field is frame number
      FD.FAM   1B20  family type FD
                     FM.CHL   0B23  child subtype
                              X field is child frame number
                     FM.PAR   1B23  parent subtype
      FD.OTF   2B20  "other" frame
                     uses FD specified by SETOTF UUO (CALLI -126, pg. 2-13)
      FD.CRH   3B20  created handle type FD
                     X field is handle index
                     CH.FRM   0B23  frame handle subtype
                     CH.PRO   1B23  process handle subtype
                     CH.LIC   2B23  license handle subtype
      FD.SLF   7B20  self
                     S and X fields are ignored






                                              2-12


            July 3, 1980                             2                      Frames and Processes


                       _____ _____ __            2.6.3.2    Other Frame FD

            Passing a FD of type FD.OTF causes the system to use the FD which was  most recently
            given to the SETOTF UUO  (CALLI -126, pg. 2-13) In addition to FRMOP,  the following
            UUOs will  operate on  the "other"  frame if the  appropriate flag  is set  in their
            arguments:
                1)  VPROT UUO (CALLI -70, pg. 4-7)
                2)  PAGSTS UUO (CALLI -71, pg. 4-16)
                3)  VALPAG UUO (CALLI -76, pg. 4-12)
                4)  PREREF UUO (CALLI -75, pg. 4-10)
                5)  VCREAT UUO (CALLI -67, pg. 4-3)
                6)  VREMOV UUO (CALLI -65, pg. 4-4)
                7)  VCLEAR UUO (CALLI -66, pg. 4-4)
                8)  VREPLC UUO (CALLI -64, pg. 4-4)
                9)  .FOREP UUO (FRMOP fn 7, pg. 2-21)
                10)  .CHMFP UUO (CHANIO fn 35, pg. 4-5)

                         _______ ___ ___________ __ ______ _____            2.6.3.2.1    SETOTF: set other-frame FD (CALLI -126)

                    MOVEI   ac,FD
                    SETOTF  ac,
                      error return
                    normal return   ;ac/previous "other frame" FD if any

            If <FD> is of type FD.OTF, take the error return.

            Exchange the FD in <ac> with the monitor's "other frame" FD storage  location.  Take
            the normal return.

            This "other frame"  FD can be  used by subsequent UUOs  to operate on  the indicated
            frame without explicitly  passing the FD to  the UUO. See .CHMFP  UUO (CHANIO fn 35,
            pg. 4-5) for example.

                       _______            2.6.3.3    Handles

            A "handle"  is a system  construct which is  a means of  accessing or  changing data
            associated with a frame.  It may be useful to consider a handle as a  "path" between
            frames.  The most significant facts about handles are:
                1)  A handle describes the operations  for which its holder may use  it upon
                    the object (target frame) which  it names.  These are the  Handle Access
                    Rights
                2)  A handle may be passed from frame to frame.
            These two facts are an important part of the basis of constructing "capability-based
            systems"--that is, systems  of programs which cannot  talk about or  affect anything
            except those other  objects for which  they have been given  a name.  The  "name" or
            "path" given to any program is the FD itself.

                         ______ ____            2.6.3.3.1    Family FD's

            Some  handles  are  generated   auutomatically  by  the  .FOCFH   UUO  (FRMOP fn 12,
            pg. 2-28).  The FD's  for these  handles are  the type  FD.FAM, subtypes  FM.CHL and
            FM.PAR. They govern the effects parents can have upon their children and vice-versa.
















                                                    2-13


      Frames and Processes                     2                          YAMM edition 2.0


                   _______ ______      2.6.3.3.2    Created Handle

      The .FOCFH UUO (FRMOP fn 12, pg. 2-28)  produces "created handles", or FD's  of type
      FD.CRH.  Created handles are of three subtypes:
          1)  Frame Handle.  A frame handle is  valid for for as long as the  frame it
              points to exists.  If the frame is destroyed, the handle becomes invalid
              but may continue to exist for some time.
          2)  Process Handle.  A Process handle  is valid only so long as  the program
              within the  target frame is  not replaced by  another program.  In other
              words, a process handle grants access to one incarnation of a program.
          3)  Licensed Handle.  A Licensed handle grants access to its target absolute
              frame  number  according  to  the license  stored  in  the  handle.  (An
              Absolute Frame Descriptor also can function as a licensed handle because
              the access it grants is determined by the process license of  the caller
              at the moment the Absolute FD is used.)

               ______ ______      2.6.4    Access Rights

      A  system of  Access Rights  (AR)  bits allows  a very  subtle and  flexible  set of
      security measures to  be developed between processes  executing in the  system.  See
      Table 2-15  for  the names and  meanings of AR's  currently defined.  The  number of
      AR's  is  likely  to grow  in  the  future as  new  possibilities  and  contexts are
      discovered.

                 _______ _____ ______      2.6.4.1    Maximum Frame Rights

      Every frame has a set of Maximum Frame Rights; these the rights which any  CH.FRH to
      the frame may possess.  When a frame is created, the Maximum Frame Rights  (MFR) are
      initialized  to ALL  rights.   When a  program is  loaded  into the  frame  with the
      monitor's RUN or GET operations, the protection code of the file and the PPN  of the
      frame into  which the file  is being loaded  determine the setting  of the  MFR: the
      frame is either the file's Owner  (same PPN), project-mate (same GAN) or is  part of
      "the public".  In addition, licenses on  the frame and file affect the  initial MFR.
      These are the conditions:
          1)  if the  file is  Execute-Only (see  3-11) set  the MFR  to allow  only a
              limited set of  control functions to be  applied to the  frame.  Prevent
              any operations which would break Execute-Only security, such as .FORVA.
          2)  if the file  has more license than  the frame, but is  not Execute-Only,
              set the MFR to allow  frame handles to read information about  the frame
              and exercise the limited set  of control functions which are  allowed in
              the Execute-Only case.   Prevent any operations  which could be  used to
              exploit the license.
          3)  if neither of these conditions applies, set the MFR to ALL rights.
      Another way of  setting the MFR  is to use  the .FOSMF UUO  (FRMOP fn 20, pg. 2-31).
      This operation allows a frame  to set its own MFR or  the MFR of any other  frame to
      which it has .ARSMF access.

      Note that a process  has the option of setting  its own MFR down from  their initial
      values in order to protect any information it wishes to keep to itself.



















                                              2-14


            July 3, 1980                             2                      Frames and Processes


                                                _____ ____                                                 Table 2-15 
                                         ______ ______ ___________                                         Access Rights Definitions


            oct name    when   lic          description

            0   .ARRDM  R      RC           Read Map
                                            find out things about a map (i.e., VPGSTS, WSCTL to
                                            read WS size, etc.)
            1   .ARCHM  W      WC           Change Map
                                            do VREMOV,VCREAT,.CHMFP, .FOREP to other frame, etc.
            2   .ARRAC  R      RC           Read ACs
            3   .ARWAC  W      WC           Write ACs
            4   .ARVAR  R      RC           Read VM data
                                            also VREPLC or .FOREP with protection .PRRO, etc.
            5   .ARVAW  W      WC           Write VM data
                                            also VREPLC or .FOREP with protection .PRRW
            6   .ARHLT  W      WC           Halt frame
            7   .ARSTP  X      WC           Stop frame
                                            like escape/^C, this is trappable by the target
                                            frame
            10  .ARHNG  W      WC           Hang frame
            11  .ARCLR  X      WC           Clear frame and release devices
                                            frame must be stopped first
            12  .ARSVA  X      WC           Start at Vector Address
                                            see .FOSVA UUO (FRMOP fn 22, pg. 2-24)
            13  .ARSAA  W      WC           Start at Arbitrary Address
            14  .ARRVA  W      WC           Restart at Vector Address
            15  .ARRAA  W      WC           Restart at Arbitrary Address
            16  .ARRUN  X      TP,SY,AUN    Read User Name
                                            also allows checking JBTSTS to see if logged-in.
                                            See Table 2-7 .
            17  .ARRDS  R      SY,AUN       Read Frame State
                                            read PC,Halt Status Block. See Table 2-26 .
            20  .ARRAD  R      SY,AUN       Read Accounting Data
                                            read TRU components, etc.
            21  .ARRFI  R      SY,AUN       Read Frame Information
                                            read AUN,PPN,UID, etc.
            22  .ARRPI  R      SY,AUN       Read Process Info
                                            read FPN,Process Name, PNO, etc.
            23  .ARSMF  W      WC           Set Max Frame Rights
                                            (set in the MFR of a frame on GET or RUN operations
                                            only if the frame has write access to the file being
                                            gotten in order to prevent creation of handles to an
                                            EXO or RDO program which have .ARSMF rights over the
                                            program)
            24  .ARWAK  W      WC           Do Wake UUO on frame
            25  .ARATT  W      JL,AUN       Attach Port
            26  .ARDET  W      WC           Take Port away (Detach)
            27  .ARTKP  W      WC           Take parent away from frame
            30  .ARGVP  W      JL           Give parent to frame
            31  .ARGVC  W      WC           Give child to frame

            Explanations:
            oct   octal Access Right number
            name  symbol name for this AR number
            when  conditions under which this AR is set in initial MFR
                  "W"   set when JP.EXO is off AND Process
                        License is less than or equal to Frame License
                  "R"   set when JP.EXO is off AND
                        Process License is greater than frame license, and under "W" conditions
                  "X"   set when JP.EXO is set and under
                        "R" and "W" conditions
            lic   license which grants this AR.
                  "AUN" means frames have same AUN, or caller
                        has JP.ASV and his GAN
                        matches that of target frame
                  "TP" means JP.TYM set in JBTPRV
                                                    2-15


      Frames and Processes                     2                          YAMM edition 2.0


                 ______ ______ ___ _________ ______      2.6.4.2    Handle Rights vs. Effective Rights

      Every FD  (and thus every  handle) has associated  with it a  set of  "handle access
      rights", or "handle rights", which are the rights for which the handle  may possibly
      be exercised on its target frame.  However, if the target frame has reduced its MFR,
      some handles to it may contain rights which are not presently effective.  A handle's
      "effective rights" are those for which  it is currently good over the  target frame.
      Effective rights may or  may not be identical to  handle rights.  These two  sets of
      rights may be read with
          1)  .FORAR UUO (FRMOP fn 16, pg. 2-30)
          2)  .FORER UUO (FRMOP fn 17, pg. 2-30)
          3)  .FOCAR UUO (FRMOP fn 30, pg. 2-32)
          4)  .FOCER UUO (FRMOP fn 31, pg. 2-32)

               ______ _____ _________ ___ ____ ____      2.6.5    FRMOP: Frame Operation (op code 044)

              MOVE    AC,[function,,FD]
              FRMOP   AC,addr
                error return          ; AC/ error code
              normal return

      where
       FD     = a frame descriptor
       addr   = address of the argument or argument block
       function = one of the functions of Table 2-18 

      Perform <function> on  the indicated frame.  If  an error is encountered,  return an
      error code from Table 2-16  (except as noted).








































                                              2-16


            July 3, 1980                             2                      Frames and Processes




                                                _____ ____                                                 Table 2-16 
                                         _____ ________ _____ _____                                         FRMOP standard error codes


            Name     Code  Description
            FENOH%   1     no handle in slot
            FEBDI%   2     Bad (nonmatching) universal ID number
            FENRT%   3     no rights to do operation
            FEBDF%   4     bad frame number
            FENLC%   5     not enough license
            FEUND%   6     undefined frame descriptor type
            FENCH%   7     not a child
                           FD said child, but gave non-child frame number
            FECLP%   10    cannot lock context pages
            FEBAR%   11    bad access rights code
            FENPR%   12    no parent
                           (frame without a parent asked for its parent)
            FEBFD%   13    bad family dispatch type
            FEBDH%   14    bad handle index number in FD
            FEBFN%   15    bad FRMOP function code
            FEADB%   16    address bad
                           replicate failed in .FORVA/.FOWVA
            FEIOE%   17    page I/O error
            FEALR%   20    already running
            FEALH%   21    already halted
            FECSJ%   22    cannot stop frame with JACCT set
            FEFHE%   23    handle descriptor expected, not given
            FEFHU%   24    handle (index) already used
            FENFH%   25    no frame handle indices left
            FEBCN%   26    bad count
            FEBTN%   27    bad table number
            FEBHT%   30    bad handle type
            FECCH%   31    can't create handle (access failure)
            FEBSV%   32    bad start vector offset
            FECII%   33    cannot make child its own inferior in frame tree
            FECCF%   34    cannot continue frame
            FECFJ%   35    cannot do frame jump
                           target frame PC not in user mode
            FEREM%   36    rights exceed maximum
                           rights in target handle exceed max specifications
            All FRMOPs except .FOREP, .FOVRM, .FOCLR return these error codes in AC right half.
                           .FOREP and friends return these codes in AC bits 0-5, VP in bits
                           8-17, and the VREPLC, VCLEAR or VREMOV error code (see Table 4-19 )
                           in AC right half.






















                                                    2-17


      Frames and Processes                     2                          YAMM edition 2.0


                                          _____ ____                                           Table 2-18 
                                    _____ _____ __ ________                                    FRMOP calls by function


      Name     Code  AR req'd.        Description

      Tree manipulation

      .FOCFM   1     -none-           create frame (2-19)
      .FOGFT   24    .ARGVC,.ARGVP    graft frame (2-20)


      Memory manipulation

      .FORVA   2     .ARVAR           read virtual address (2-20)
      .FOWVA   3     .ARVAW           write virtual address (2-21)
      .FOREP   7     .ARCHM           replicate pages to/from frame (2-21)
      .FOVRM   10    .ARCHM           VREMOV for other frame (2-21)
      .FOVCL   11    .ARCHM           VCLEAR for other frame (2-21)
      .FOGET   32    .ARVAW           GET file into frame (2-21)
      .FOSAV   34    .ARVAR           SAVE frame on file (2-22)
      .FOSSA   35    .ARVAR           SSAVE frame on file (2-22)


      State manipulation

      .FOJMP   0     .ARSVA or .ARSAA Gate Jump to frame (2-22)
      .FOSAA   4     .ARSAA           start at absolute address (2-23)
      .FOHLT   5     .ARHLT           halt frame (2-23)
      .FORPC   6     .ARRDS           read user mode PC (2-24)
      .FOCLR   14    .ARCLR           clear stopped frame (2-24)
      .FOSVA   22    .ARSVA           start at start vector (2-24)
      .FOHST   23    .ARRDS           read halt status block (2-25)
      .FOCON   25    .ARSVA           continue frame (2-27)
      .FOGIN   26    -none-           Gate jump Init (2-27)
      .FORUN   33    .ARVAW           RUN program in frame (2-27)


      Rights and Handles

      .FOCFH   12    -none-           create frame handle (2-28)
      .FODFH   13    -none-           destroy frame handle (2-29)
      .FORSI   15    -none-           return standard access rights info (2-30)
      .FORAR   16    -none-           read handle's access rights (2-30)
      .FORER   17    -none-           read handle's effective rights (2-30)
      .FOSMF   20    .ARSMF           set maximum frame rights (2-31)
      .FOCHR   21    -none-           change rights for handle (2-31)
      .FOVCH   27    -none-           Validate Child's rights (2-31)
      .FOCAR   30    -none-           Read Child-to-Parent Handle Access Rights (2-32)
      .FOCER   31    -none-           Read Child-to-Parent Handle Effective Rights (2-32)


















                                              2-18


            July 3, 1980                             2                      Frames and Processes


                                                _____ ____                                                 Table 2-19 
                                         _____ _________ __ ______                                         FRMOP functions by number


            Function Name     Description

              fn 0   .FOJMP   Gate Jump to frame (2-22)
              fn 1   .FOCFM   create frame (2-19)
              fn 2   .FORVA   read virtual address (2-20)
              fn 3   .FOWVA   write virtual address (2-21)
              fn 4   .FOSAA   start at absolute address (2-23)
              fn 5   .FOHLT   halt frame (2-23)
              fn 6   .FORPC   read user mode PC (2-24)
              fn 7   .FOREP   replicate pages to/from frame (2-21)
              fn 10  .FOVRM   VREMOV for other frame (2-21)
              fn 11  .FOVCL   VCLEAR for other frame (2-21)
              fn 12  .FOCFH   create frame handle (2-28)
              fn 13  .FODFH   destroy frame handle (2-29)
              fn 14  .FOCLR   clear stopped frame (2-24)
              fn 15  .FORSI   return standard access rights info (2-30)
              fn 16  .FORAR   read handle's access rights (2-30)
              fn 17  .FORER   read handle's effective rights (2-30)
              fn 20  .FOSMF   set maximum frame rights (2-31)
              fn 21  .FOCHR   change rights for handle (2-31)
              fn 22  .FOSVA   start at start vector (2-24)
              fn 23  .FOHST   read halt status block (2-25)
              fn 24  .FOGFT   graft frame (2-20)
              fn 25  .FOCON   continue frame (2-27)
              fn 26  .FOGIN   Gate jump Init (2-27)
              fn 27  .FOVCH   Validate Child's rights (2-31)
              fn 30  .FOCAR   Read Child-to-Parent Handle Access Rights (2-32)
              fn 31  .FOCER   Read Child-to-Parent Handle Effective Rights (2-32)
              fn 32  .FOGET   GET file into frame (2-21)
              fn 33  .FORUN   RUN program in frame (2-27)
              fn 34  .FOSAV   SAVE frame on file (2-22)
              fn 35  .FOSSA   SSAVE frame on file (2-22)


                     ____ ____________ ______            2.6.6    Tree manipulation FRMOPs

                       _______ ______ _____ ______ __ __            2.6.6.1    .FOCFM: create frame (FRMOP fn 1)

                    MOVSI   ac,.FOCFM
                    FRMOP   ac,[-count,,addr]
                      error return
                    normal return   ; AC/ child frame desc

            addr:   JBTPPN          ; PPN for new frame
                    JBTPRV          ; Table 2-3
                    JBTAUN          ; AUN for new frame
                    JBTUNM          ; sixbit username for given AUN
                    JBTUN1          ;

            Create a new frame and make it a child of the caller.  Give the frame the parameters
            given at addr.  If a parameter is not specified (ie. not included in count),  or the
            job is not licensed to set that parameter, use the corresponding parameter  from the
            frame doing the uuo.

            If no error is detected, skip  return with the child frame descriptor (see  2-12) in
            the ac.

            If an error is  detected, non-skip return with  the error code (see  Table 2-20 ) in
            the ac.





                                                    2-19


      Frames and Processes                     2                          YAMM edition 2.0


                                          _____ ____                                           Table 2-20 
                                       ______ _____ _____                                       .FOCFM error codes


      name     code description
      CF.NRD   0    no disk room
      CF.FCE   1    frame capacity exceeded
      CF.BAL   2    bad arg no license
      CF.DDB   3    cannot create command port DDB


                 _______ _____ _____ _______ ______ __ ___      2.6.6.2    .FOGFT: Graft Frame Subtree (FRMOP fn 24)

              MOVE    ac,[.FOGFT,,<FD of subtree root>]
              FRMOP   ac,[<FD of destination frame>]
               error return   ;ac/Table 2-16
              normal return

      where
      <FD of subtree root> is the FD of the root frame
      of a subtree of some existing frame tree, which is
      to be moved by the .FOGFT

      <FD of destination frame> is 0 or the FD of
      a new prospective parent for the subtree being moved.
      If 0, the subtree is going to become a free-standing
      tree in its own right.

      If <FD of destination frame> is non-zero, take the error return if either
          1)  the caller is missing .ARGVC over the destination frame, or
          2)  the caller is missing .ARGVP over the subtree being moved.

      If <FD of  destination frame> is a  member of the subtree  rooted in <FD  of subtree
      root>, take the error return (since this would destroy the tree-structure  by making
      it into a graph).

      Take the error return if the  caller lacks .ARTKP over the subtree being  moved, AND
      that subtree currently has a parent.

      Invalidate the child-to-parent handle of  <FD of subtree>.  Give the new  parent (if
      any)  a  handle  to  its  new  child  with  the  same  AR's  that  existed   in  the
      parent-to-child handle of <FD of subtree> before it was moved.  Move the  subtree as
      requested.  Leave the MFR of <FD of subtree> unmodified.

      Take the normal return.

               ______ ____________ ______      2.6.7    Memory manipulation FRMOPs

                 _______ ____ _____ _______ _______ ______ __ __      2.6.7.1    .FORVA: read frame virtual address (FRMOP fn 2)

              MOVE    ac,[.FORVA,,FD]
              FRMOP   ac,block
                error return  ; AC/ Table 2-16
              normal return

      block:  <address>
              <data>

      The contents of  the virtual address  <address> in the  target frame is  copied into
      <data>.

      For Access Rights required, see Table 2-18 .






                                              2-20


            July 3, 1980                             2                      Frames and Processes


                       _______ _____ _____ _______ _______ ______ __ __            2.6.7.2    .FOWVA: write frame virtual address (FRMOP fn 3)

                    MOVE    ac,[.FOWVA,,FD]
                    FRMOP   ac,block
                      error return  ; AC/ Table 2-16
                    normal return

            block:  <address>
                    <data>

            <data> is copied into the virtual address <address> in the target frame.

            For Access Rights required, see Table 2-18 .

                       _______ ______ _______ _______ _____ ______ __ __            2.6.7.3    .FOREP: VREPLC to/from another frame (FRMOP fn 7)

                    MOVE    ac,[.FOREP,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/bits 0-5 see Table 2-16
                                        bits 6-35 see Table 4-19 
                    normal return

            ADDR:   <otfflg>B1+<prot>B7+<count>B17,,destination VP
                    <otfflg>B1,,source VP

            where
            <otfflg>=1 to indicate frame specified by FD
                     0 to indicate calling frame
            <prot> is from Table 4-3 
            <count> is 1 .LE. <count> .LE. 777 specifying a range of pages

            Refer  to the  VREPLC UUO  (CALLI -64, pg. 4-4)  for discussion  of  this operation.
            .FOREP differs only in that <otfflg>  can be used to cause the replicate  to operate
            between the caller and target frame.

                       _______ ______ __ _______ _____ ______ __ ___            2.6.7.4    .FOVRM: VREMOV in another frame (FRMOP fn 10)
                       _______ ______ __ _______ _____ ______ __ ___            2.6.7.4    .FOVCL: VCLEAR in another frame (FRMOP fn 11)

                    MOVE    ac,[.FOVRM or .FOVCL,,FD]
                    FRMOP   ac,
                     error return   ;ac/bits 0-5 see Table 2-16
                                        bits 6-35 see Table 4-19 
                    normal return

            See  VCLEAR UUO  (CALLI -66,  pg. 4-4) and  VREMOV  UUO (CALLI -65,  pg. 4-4)  for a
            discussion of these operations.  .FOVRM and .FOVCL differ only in that  they operate
            on the frame specified by FD.

                       _______ _____ _____ ____ _____ ____ ____ ______ __ ___            2.6.7.5    .FOGET: Setup frame core image from file (FRMOP fn 32)


                    MOVE    ac,[.FOGET,,FD]
                    FRMOP   ac,adr
                     error return           ;ac/Table 2-16
                    normal return

            adr:    exp     count           ;number of arguments passed
                    sixbit  /device/
                    xwd     gan,uun
                    sixbit  /filename/
                    sixbit  /ext/           ;best left zero = unspecified
                    xwd     license,core
            count=  .-adr-1


            If any of the conditions named in Table 2-16 is present, take the error return.  The
            AR required to perform .FOGET are listed in Table 2-18 .

                                                    2-21


      Frames and Processes                     2                          YAMM edition 2.0


      Initiate  the  GET  operation  (see GETSEG  UUO  (CALLI +40,  pg. 3-6)  and  RUN UUO
      (CALLI +35, pg. 3-7)) into the target frame and take the normal return.

      The caller  must examine  the halt  status block  of the  target frame  to determine
      whether the  GET succeeds  or not.   It is possible  for .FOGET  to take  the normal
      return but for the operation to fail. For example, the named file may not  be found.
      This would result in  a halt status of  HT.FNF.  See Table 2-26 .  A  successful GET
      operation results in HT.JSU.

                 _______ ____ _____ ____ _____ __ ____ ______ __ ___      2.6.7.6    .FOSAV: SAVE frame core image on file (FRMOP fn 34)
                 _______ ____ _____ ____ _____ __ ___ ____ ______ __ ___      2.6.7.6    .FOSSA: SAVE frame core image on SHR file (FRMOP fn 35)


              MOVE    ac,[.FOSAV or .FOSSA,,FD]
              FRMOP   ac,adr
               error return           ;ac/Table 2-16
              normal return

      adr:    exp     count           ;number of arguments passed
              sixbit  /device/
              xwd     gan,uun
              sixbit  /filename/
              sixbit  /ext/           ;assumed /SHR/ or /SAV/ if 0
              xwd     0,core
      count=  .-adr-1


      If any of the conditions named in Table 2-16 is present, take the error return.  The
      AR required by .FOSAV and .FOSSA are listed in Table 2-18 .

      Initiate  the SAVE  operation (see  3-5) from  the target  frame onto  the specified
      file.  Take the normal return.

      The caller must examine the halt status block in the target frame to  determine that
      the operation  completed successfully.  If  the UUO takes  the normal return,  it is
      still possible that the SAVE may not succeed.  For example, the target frame may not
      have the ability to ENTER a file in the named directory; this would result in a halt
      status of HT.EUF.  A successful SAVE will result in HT.JSV.

               _____ ____________ ______      2.6.8    State manipulation FRMOPs

                 _______ ____ ____ __ _____ ______ __ __      2.6.8.1    .FOJMP: gate jump to frame (FRMOP fn 0)

              MOVE    ac,[.FOJMP,,<FD.CRH index number>]
               or
              MOVEI   ac,<FD.CRH index number> ;.FOJMP=0
              FRMOP   ac,addr
               error return           ;ac/ Table 2-16
              normal "return"         ;ac's may all be changed

      addr:   0B17 + <start address>
          or
      addr:   1B17 + <start vector index>

      <FD.CRH index number> is the index field (low order 12 bits) of the caller's created
      handle to the target frame.  (see Table 2-12 ) This deviation from the usual calling
      convention is done for efficiency.

      If <FD.CRH index number> is invalid, or if the caller does not have .ARSAA or .ARSVA
      (as appropriate) over the target, take the error return.

      Stop  the caller  frame  with PC  pointing at  the  normal return  from  this FRMOP.
      Continue processing in the target frame  at the PC specified at <addr>.   (note that
      the target frame PC is  typically at a gate jump  UUO, to cause the target  frame to
      effectively  "return"  from this  UUO,  the SV.CON  start  vector may  be  used; see
      Table 2-25 )

      Several facts should be noted about the facility provided by .FOJMP:
                                              2-22


            July 3, 1980                             2                      Frames and Processes


                1)  any frame wishing to .FOJMP at a target frame must first create a handle
                    to that target.
                2)  the AC's are completely shared between the jumping and target frame.
                3)  the target frame can return to the original jumping frame at  the normal
                    "return" from  the .FOJMP FRMOP  by performing its  own .FOJMP  with the
                    CONTINUE vector index set.
                4)  if the target frame does return in any way, any AC's used by  the target
                    but not restored will be  seen by the original jumping frame.   This can
                    facilitate  passing  information  between  otherwise   disjoint  address
                    spaces.
                5)  the state of the command port, if any, is unchanged by .FOJMP
                6)  .FOJMP is fast  enough to make  it practical to  use it as  a subroutine
                    call mechanism between frames.  It is flexible enough to  implement more
                    elaborate control structures such as co-routines.
                7)  .FOJMP is not guaranteed to work if the target frame has  not previously
                    done a .FOGIN  or .FOJMP of its  own, although there are  certain states
                    wherin it can work.  The  best practice is to initialize a  target frame
                    with .FOGIN UUO (FRMOP fn 26, pg. 2-27).
                8)  a frame which  is stopped because  processing jumped into  another frame
                    via .FOJMP can be started  by the monitor command interpreter or  by any
                    frame  owning  a  handle  which allows  starting  that  frame.   If this
                    happens, the contents of that frame's AC's are undefined.

                       _______ _____ _____ __ ________ _______ ______ __ __            2.6.8.2    .FOSAA: start frame at absolute address (FRMOP fn 4)

                    MOVE    ac,[.FOSAA,,FD]
                    FRMOP   ac,addr
                      error return  ; AC/ Table 2-16
                    normal return

            addr:   1B0+<address>   ; start at <address> in target
                or
            addr:   <location>      ; start at address found in given
                                    ; location of target frame

            The target frame is started at the specified address.

            The second form, where the location of the start address is specified, is useful for
            starting at an address stored in .JBSA, .JBDDT, etc.  The start address is read from
            the specified location in the target frame and the frame is started at that address.

            For Access Rights required, see Table 2-18 . The target frame must not be running.

                       _______ ____ _____ ______ __ __            2.6.8.3    .FOHLT: halt frame (FRMOP fn 5)

                    MOVE    ac,[.FOHLT,,FD]
                    FRMOP   ac,
                      error return  ; AC/ Table 2-16
                    normal return

            The target frame will be halted or set to halt when it next runs.

            For Access Rights required,  see Table 2-18 . The  target frame may have  JB.JA2 set
            and may be trapping ^C.  The target frame must not have JB.JAC set (see Table 2-7 ).














                                                    2-23


      Frames and Processes                     2                          YAMM edition 2.0


                 _______ ____ _____ __ ______ __ __      2.6.8.4    .FORPC: Read Frame PC (FRMOP fn 6)

              MOVE    ac,[.FORPC,,FD]
              FRMOP   ac,<addr>
                error return  ; AC/ Table 2-16
              normal return

      Return the last known user mode PC for the target frame in <addr>.  If no  user mode
      PC is known  (ie. just finished  a RUN UUO  (CALLI +35, pg. 3-7)), return  zero.  If
      the frame is currently executing a UUO  (ie. the PC is in exec mode), return  the PC
      of the UUO.

      For Access Rights required, see Table 2-18 .

                 _______ _____ _ _____ ______ __ ___      2.6.8.5    .FOCLR: Clear a Frame (FRMOP fn 14)

              MOVE    ac,[.FOCLR,,FD]
              FRMOP   ac,
               error return   ;ac/Table 2-16
              normal return

      If the target frame is not stopped, take the error return.

      Set up the target to run a program  which will have the same effect as the  "CORE 0"
      command-- particularly, VCLEAR all memory,  release all devices, set the MFR  to all
      AR, and set the P2S rights to all AR.

      Take the normal return.  Upon receiving the normal return, the caller  cannot assume
      that the target is clear until the target halts.

                 _______ _____ _____ __ ______ _______ ______ __ ___      2.6.8.6    .FOSVA: start frame at vector address (FRMOP fn 22)

              MOVE    ac,[.FOSVA,,FD]
              FRMOP   ac,[<start vector index>]
                error return  ; AC/ Table 2-16
              normal return

      Positive start vector indicies specify the corresponding offsets into a table in the
      target  frame's address  space (which  may  or may  not be  set up).   The  table is
      specified  by SETSTV  UUO (CALLI -137,  pg. 2-33).  Negative  start  vector indicies
      specify system standard start locations as indicated in Table 2-25 .

      The target frame must  be halted.  For Access  Rights required, see Table 2-18  . If
      <start vector index> is invalid (which can happen if no start vector has been set up
      in the target frame), take the error return.

      Start  the target  frame at  the address  specified by  the contents  of  the vector
      location selected by <start vector index>.  Take the normal return.




















                                              2-24


            July 3, 1980                             2                      Frames and Processes


                                                _____ ____                                                 Table 2-25 
                                        ______ _____ ______ ________                                        System Start Vector Indicies


            Name     Index Description
            SV.NSA   -1    normal start address (as found in .JBSA)
            SV.CCL   -2    CCL start address (normal plus one)
            SV.REN   -3    REENTER start address (as found in .JBREN)
            SV.DDT   -4    DDT start address (as found in .JBDDT)
            SV.CON   -5    CONTINUE start address


                       _______ ____ ____ ______ _____ ______ __ ___            2.6.8.7    .FOHST: Read Halt Status Block (FRMOP fn 23)

                    MOVE    ac,[.FOHST,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-16
                    normal return

            ADDR:   <count>         ;number of words to return starting at
                                    ;ADDR+1 as follows:
            ADDR+1/ <halt class>,,<halt type> (see Table 2-26 )
            ADDR+2/ halt count
            ADDR+3/ PC of last halt or exit
            ADDR+4/ PC of last UUO
            ADDR+5/ sixbit <device name> if relevant
            ADDR+6/ class/type dependent data word
            ADDR+7/ another class/type dependent data word

            The system maintains for every  frame a Halt Status Block which  records significant
            information when a frame stops processing.  Frames stop processing for a  variety of
            reasons, some  good and  some not.   All of these  are recorded  in the  Halt Status
            Block, which is readable by another process with .ARRDS.

            The Halt Count at ADDR+2 can be used to determine if the data is new since  the last
            time the block was  read. If the target frame  is not halted, the Halt  Status Block
            does not reflect the frame state, only the conditions prevailing at the last halt.

            If <count> is negative, zero or greater  than the length of a Halt Status  block, or
            if the caller lacks .ARRDS over the target, take the error return.

            Return as much of the Halt Status  Block as allowed by <count>, and take  the normal
            return.

























                                                    2-25


      Frames and Processes                     2                          YAMM edition 2.0


                                          _____ ____                                           Table 2-26 
                                  ____ ______ _______ _ _____                                  Halt Status Classes & Types



      class   code description
                   type    code description

      HC.MEM  0    Memory Violations
                   HT.PCO  0    PC Out of Bounds
                   HT.IMR  1    Illegal Memory Reference
                   HT.WRV  2    Write Violation
                   HT.ADC  3    Address Check for Device X
                   HT.IMU  4    Ill Mem Ref in UUO
                   HT.IIA  5    Illegal Interrupt Address
                   HT.ABK  6    Address Break
                   HT.POV  7    PDL Overflow

      HC.SYS  1    System-Related Errors
                   HT.PIO  0    Page I/O Error
                   HT.DFL  1    Disk Full during copy of .PRCW page
                   HT.PHE  2    Paging Hardware Error
                   HT.TPL  3    Too many Pages Locked, Cannot handle fault
                   HT.CIO  4    Context Page I/O Error
                   HT.PAR  5    Parity Error(s). All Core Removed

      HC.DEV  2    Device Related Errors
                   HT.OCI  0    Output device Cannot Input
                   HT.ICO  1    Input device Cannot Output
                   HT.IDM  2    Illegal Data Mode for device X
                   HT.IUC  3    I/O to Unassigned Channel
                   HT.HDV  4    Hung Device
                   HT.DOP  5    Device X OPR action requested

      HC.ILL  3    Illegal Instruction Traps
                   HT.ILU  0    Illegal UUO
                   HT.UUE  1    UUO error
                   HT.ILI  2    Illegal Instruction
                   HT.HLT  3    Halt

      HC.EXI  4    Frame Exits
                   HT.EXI  0    Exit
                   HT.EX1  1    Exit 1,
                   HT.FEX  2    Fail Exit
                   HT.TLE  3    Time Limit Exceeded
                   HT.JSU  4    <filename> setup
                   HT.JSV  5    <filename> saved
                   HT.FCL  6    frame cleared

      HC.RUN  5    RUN,RUNSEG & GETSEG UUO errors
                   HT.TRE  0    Transmission Error
                   HT.PGN  1    N Pages Required
                   HT.DNA  2    Device Not Available
                   HT.FNF  3    <filename.ext> not found
                   HT.NSF  4    Not a Save File
                   HT.EUF  5    <filename.ext> Attempted Enter UUO Failed
                   HT.CAN  6    Core Argument Not specified (magtape only)
                   HT.MHB  7    Magtape Hiseg Format Bad
                   HT.RMF  10   Remap UUO Fatal error
                   HT.MGF  11   Magtape GET failure
                   HT.NSA  12   No Start Address







                                              2-26


            July 3, 1980                             2                      Frames and Processes


                       _______ ________ _____ ______ __ ___            2.6.8.8    .FOCON: continue frame (FRMOP fn 25)

                    MOVE    ac,[.FOCON,,FD]
                    FRMOP   ac,
                      error return  ; AC/ Table 2-16
                    normal return

            The target frame is started at  its current PC.  This is functionally  equivalent to
            .FORPC UUO (FRMOP fn 6, pg. 2-24) followed by .FOSAA UUO (FRMOP fn 4, pg. 2-23).

            For Access Rights required,  see Table 2-18 . The  target frame must not  be running
            and must not have JB.JER on in JBTSTS (see Table 2-7 ).

                       _______ _________ ______________ ______ __ ___            2.6.8.9    .FOGIN: Gate-jump Initialization (FRMOP fn 26)

                    MOVE    ac,[.FOGIN,,0]
                    FRMOP   ac,
                     error return   ;ac/ Table 2-16
                    normal "return"

            Perform the normal FRMOP checks. Stop the calling frame and leave its PC pointing at
            the normal "return"  location.  (The caller is  now properly initialized to  be gate
            jumped to with .FOJMP UUO (FRMOP fn 0, pg. 2-22) from another frame.   Either .FOCON
            UUO (FRMOP fn 25,  pg. 2-27) or  .FOJMP UUO (FRMOP fn 0,  pg. 2-22) will  cause this
            frame to begin execution at the normal "return" location.

            The state of the caller's command port is unchanged by gate jumping.

                        _______ ___ _______ __ _____ ______ __ ___            2.6.8.10    .FORUN: RUN program in frame (FRMOP fn 33)


                    MOVE    ac,[.FORUN,,FD]
                    FRMOP   ac,adr
                     error return           ;ac/Table 2-16
                    success return

            adr:    xwd     start-incr,count
                    sixbit  /device/
                    xwd     gan,uun
                    sixbit  /filename/
                    sixbit  /file extension/        ;best left zero = unspecified
                    xwd     license,core
            count=.-adr-1


            The meaning of the items in the block at <adr> is the same as explained for  the RUN
            UUO (CALLI +35,  pg. 3-7).  If any  of the conditions  named in Table 2-16  is true,
            take the error return.  The AR required by .FORUN are listed in Table 2-18 .

            If <count>  is less  than 5 (i.e.  does not  specify all of  the items  shown above,
            substitute 0 for the unspecified items.

            Initiate  the RUN  operation  (see RUN  UUO  (CALLI +35, pg. 3-7))  into  the target
            frame.

            Take the normal return.

            The caller of .FORUN can determine that the .FORUN is complete by examining the halt
            status block of the  target frame.  The fact  that .FORUN returns normally  does not
            mean  that the  operation will  complete  without error  in the  target  frame.  For
            example, if the  file named cannot  be found, the target  frame will halt  with halt
            status HT.FNF.  See Table 2-26 . A successful RUN will result in HT.JSU.






                                                    2-27


      Frames and Processes                     2                          YAMM edition 2.0


               ______ ___ _______ ______      2.6.9    Rights and Handles FRMOPs

                 _______ ______ ______ ______ __ ___      2.6.9.1    .FOCFH: Create Handle (FRMOP fn 12)

              MOVE    ac,[.FOCFH,,<source FD>]
              FRMOP   ac,<addr>
               error return   ;ac/Table 2-16
              normal return   ;ac/new handle FD

      ADDR:   <subtype>,,<FD of new handle>
              <count>,,<location>

      LOCATION: <count> words of AR bits


      where
      <subtype>=
              0B17    frame handle
              1B17    process handle
              2B17    license handle
      <FD of new handle> =
              <FD.CRH>B20+<index>B35
        where <index>=77777 to allocate first free
                      <created handle index>
              <index>=<created handle index> to use that
                      specific index

      <location>=     address of AR bit table (in caller's
                      address space) to use in setting AR
                      for the new handle

      <count>=        length of AR bit table, or 0 to set AR
                      of new handle to max allowable.

      If <FD of new handle> is not of type FD.CRH, or if <index> specifies an out-of-range
      or currently used <created handle index>, take the error return.

      If <index>=77777, allocate a new <created handle index>, taking the error  return if
      none exists.

      Create a new  handle to the  frame specified by <source  FD>, giving it  the subtype
      specified by <bits> and AR specified by <count> and <location>.  The rules governing
      conversion of handles are summarized in Table 2-29 .

      A <created handle index> is a small integer much like a software I/O channel number;
      every created handle FD has a data  field which has in it a <created  handle index>,
      not an absolute frame  number.  The system keeps, for  each frame, a small  array of
      information about  all handles  created by  that frame;  the created  handle indices
      select handles in that  array.  The size of this  array is a system  parameter which
      may change from time to time.

      If <count>=0,  set the AR  for the new  handle to the  maximum AR allowable  for the
      handle; otherwise, set the AR according  to the bit table at <location>.  If <count>
      specifies less than a full complement  of AR bits, assume that unspecified  bits are
      0.

      Set  AC   to  the  <FD   of  new  handle>,   including  the   directly-specified  or
      newly-allocated <index>, and take the normal return.










                                              2-28


            July 3, 1980                             2                      Frames and Processes


                                                _____ ____                                                 Table 2-29 
                                      _____ ___ ______ ______ ________                                      Rules for .FOCFH handle creation


            source FD type   new FD type resultant attributes



            license          license     max AR=AR of source
                                         license:=license of source
                             frame       max AR=AR of source
                             process     max AR=AR of source,
                                         PNO:=current PNO of target
            frame            license     license:=process-license
                                         of .FOCFH caller
                             frame       max AR=AR of source
                             process     max AR=AR of source ANDed
                                         with MFR of target
                                         PNO:=current PNO of target
            process          license     license:=process-license
                                         of .FOCFH caller
                             frame       illegal: may not create frame handle
                                         from process handle
                             process     max AR=AR of source,
                                         PNO:=PNO of source
            absolute FD      license     license:=process-license
                                         of .FOCFH caller
                             frame       license:=process-license
                                         of .FOCFH caller
                             process     license:=process-license
                                         of .FOCFH caller
                                         PNO:=current PNO of target
            .FOCFH treates source FD's of other types as follows:

            Source FD       Treated as
            FM.CHL          CH.FRM
            FM.PAR          CH.PRO
            FD.SLF          CH.PRO  with all AR set.

            To create a licensed handle with max rights
            based on the process-license of the caller (rather
            than on the license in the source handle), use
            a Frame, Process or Absolute FD as source handle.


                       _______ _______ ______ ______ __ ___            2.6.9.2    .FODFH: Destroy Handle (FRMOP fn 13)

                    MOVE    ac,[.FODFH,,FD]
                    FRMOP   ac,
                     error return   ;ac/Table 2-16
                    normal return

            The handle designated by FD is  destroyed. If it is of type FD.CRH,  the appropriate
            <created  handle index>  (see .FOCFH  UUO (FRMOP fn 12,  pg. 2-28)) is  marked free.
            Naturally, the frame to which FD refers is totally unaffected by the .FODFH.













                                                    2-29


      Frames and Processes                     2                          YAMM edition 2.0


                 _______ ____ ________ ______ ______ ____ ______ __ ___      2.6.9.3    .FORSI: Read Standard Access Rights Info (FRMOP fn 15)

              MOVE    ac,[.FORSI,,<item>]
              FRMOP   ac,addr
               error return   ;ac/ Table 2-16
              normal return   ;ac/ number of highest
                              ; currently-defined access right

      <item>  is from Table 2-30 
      ADDR:   <count>,,TABLE
      TABLE:  BLOCK <count>   ;for return of access rights bits

      Return a bit string in TABLE  describing the access rights requested by  <item>.  As
      much of the bitstring  as <count> allows is  returned.  If <count>=0, do  not return
      any bitstring.  Set <ac> to the number of the highest currently defined AR  and take
      the normal return.

      .FORSI with <count>=0  should be used by  programs which wish to  allocate precisely
      the right-sized  argument block for  other FRMOPs such  as .FORER  UUO (FRMOP fn 17,
      pg. 2-30) which  manipulate access  rights.  If N  is returned  by .FORSI,  then the
      exact number of words needed for arguemnt blocks is the result of
          (N + 35) / 36(integer divide)


                                          _____ ____                                           Table 2-30 
                                      ______ ____ _______                                      .FORSI Item Numbers


      name     item  description

      .SREXO   0     max frame rights for execute-only processes, and processes loaded
                     from licensed SWR files or files read-protected against the caller.
      .SRLIC   1     max frame rights for process with license greater than the frame it
                     lives in
      .SRALL   2     all rights defined by monitor
      .SRRCL   3     AR conferred by Read Core (RC) license
      .SRSYL   4     AR comferred by Systat (SY) license
      .SRTYM   5     AR conferred by JP.TYM priviledge
      .SRAUN   6     AR conferred by having same AUN or JP.ASV and same GAN
      .SRJLL   7     AR conferred by Jacct (JL) license
      .SRWCL   10    AR conferred by Write Core (WC) license


                 _______ ____ ______ ______ ______ ______ __ ___      2.6.9.4    .FORAR: Read Handle Access Rights (FRMOP fn 16)
                 _______ ____ ______ _________ ______ ______ __ ___      2.6.9.4    .FORER: Read Handle Effective Rights (FRMOP fn 17)

              MOVE    ac,[.FORAR or .FORER,,FD]
              FRMOP   ac,addr
               error return   ;ac/ Table 2-16
              normal return

      ADDR:   <count>,,TABLE
      TABLE:  BLOCK <count>   ;words to return info as follows:

          word   contents
          0      subtype,,frame number (see Table 2-12 )
          1      UID           except FD.ABS (see 2-11)
          2      PNO           process handles only (see 2-11)
          3-n    access bits

      If  <count>   is  greater   than  the  number   of  words   needed  to   return  all
      currently-defined  rights-bits, take  the error  return.  (To  determine  the proper
      number of words, see .FORSI UUO (FRMOP fn 15, pg. 2-30))

      These two FRMOPs return rights associated with a particular handle.   .FORAR returns
      the AR  of the handle  itself.  .FORER returns  the rights for  which the  handle is
      currently good, which may or may not be the same as the AR of the handle.  See 2-14,

                                              2-30


            July 3, 1980                             2                      Frames and Processes


            .FOSMF UUO  (FRMOP fn 20, pg. 2-31) and  2-16.  For FD.ABS,  the UID and  PNO fields
            are returned zero.   Note that any  process which needs  to know the  absolute frame
            number of a frame to which it has  a handle can find out that number with  either of
            these FRMOPs.

                       _______ ___ ___ _____ ______ ______ __ ___            2.6.9.5    .FOSMF: Set Max Frame Rights (FRMOP fn 20)

                    MOVE    ac,[.FOSMF,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-16
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;table of AR bits

            If the caller lacks .ARSMF rights on the target frame, take the error return.

            See 2-14.   Set the  MFR for  frame specified  by FD.   If <count>  is too  small to
            specify all AR bits, set unspecified bits to 0.  If <count> is 0, set maximum rights
            allowed.  Take the normal return.

                       _______ ______ ______ ______ ______ __ ___            2.6.9.6    .FOCHR: Change Handle Rights (FRMOP fn 21)

                    MOVE    ac,[.FOCHR,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-16
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;table of AR bits

            If FD is of type FD.ABS or FD.SLF, take the error return.

            If the AR's at LOCATION are less than the current AR of the handle specified  by FD,
            set the handle AR to the requested values and take the normal return.

            Otherwise, unless FD is  a process handle, set the  handle AR to <requested  AR> AND
            <current AR> and take the  error return.  If FD is  a process handle, set the  AR to
            the <requested AR>, invalidate PNO in the handle, and take the normal return.

                       _______ ________ _____ ______ ______ __ ___            2.6.9.7    .FOVCH: Validate Child Rights (FRMOP fn 27)

                    MOVE    ac,[.FOVCH,,<FD of child>]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-16
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;access rights specified must
                                    ;match those in child's handle

            If <count> is 0, use the rights in the child-to-parent handle.  If the rights in the
            handle of the child specified by <FD of child> do not exactly match those specified,
            take the error  return.  Otherwise, validate  that child-to-parent handle.   It will
            remain valid until another program is  run in the parent frame (i.e., until  the PNO
            of the parent changes).  Take the normal return.












                                                    2-31


      Frames and Processes                     2                          YAMM edition 2.0


                 _______ ____ _____ ______ ______ ______ __ ___      2.6.9.8    .FOCAR: Read Child Access Rights (FRMOP fn 30)
                 _______ ____ _____ _________ ______ ______ __ ___      2.6.9.8    .FOCER: Read Child Effective Rights (FRMOP fn 31)

              MOVE    ac,[.FOCAR or .FOCER,,<FD of child>]
              FRMOP   ac,addr
               error return   ;ac/Table 2-16
              normal return

      ADDR:   <count>,,<location>

      LOCATION: BLOCK <count> ;return info here

      Every child  that is created  owns an automatically-generated  handle to  its parent
      known as its child-to-parent handle; this handle describes what the child can  do to
      its parent.

      Child-to-parent  handles are  always process  handles.  This  causes child-to-parent
      handles to remain valid  only so long as the  program (i.e., the PNO) in  the parent
      frame remains the same.

      .FOCAR and .FOCER allow any parent to read the info in the child-to-parent handle of
      each of its children, in order to  find out what the children would like to  be able
      to (and actually can) do to it, the parent.  These FRMOPs are used to help  a parent
      judge  whether  or not  to  attempt to  validate  a child's  handle  via  .FOVCH UUO
      (FRMOP fn 27, pg. 2-31).

      Store at LOCATION information from the child-to-parent handle of the child specified
      by <FD of child>.   The format of the data  returned at LOCATION is as  described in
      .FORAR UUO (FRMOP fn 16, pg. 2-30). See 2-16 for more discussion of Effective Rights
      vs. Handle Rights.

                _____ ____ _____ _________ ______ ____      2.6.10    EXIT: stop frame execution (CALLI +12)

              EXIT
               or
              EXIT    1,

      Clear JB.JAC and JB.JA2.

      If the accumulator field of the EXIT call is 0,

          Perform a RELEAS for each initted channel.  Perform a RESET.  Set JB.ERR.

      If the frame is detached, and has no parent frame,

          do a HANGUP for the frame  if JP.TIM is set; otherwise, wait for  someone to
          attach to it.

      (If the frame is  detached, but has a parent  frame, terminate the UUO here  with no
      further action.)

      If the accumulator field of the EXIT  call was 0, move the string CR LF  "EXIT" into
      the command port's output buffer.

      Print CR LF <WATCH data if any> CR LF CR LF <prompt character> on the  command port,
      and place the frame in command level.












                                              2-32


            July 3, 1980                             2                      Frames and Processes


                      _______ ___ _____ ______ _______ ______ _____            2.6.11    SETSTV: set start vector address (CALLI -137)

                    MOVE    ac,[<count>,,<addr>]
                    SETSTV  ac,
                      error return
                    normal return

            <count> locations starting at <addr>  contain start addresses in bits  18-35.  These
            addresses may be specified by the .FOSVA UUO (FRMOP fn 22, pg. 2-24) by giving their
            displacement from <addr>.  This is intended  to provide a means for a program  to be
            started at a fixed number of addresses without the parent frame having  knowledge of
            the actual address and without the need  for the parent frame to have the  rights to
            start at an arbitrary address.

            The  RESET  UUO (CALLI +0,  pg. 5-12)  does not  clear  the vector.   The  vector is
            cleared only when a new program is setup in the frame.


                   _________ _____            2.7    Temporary files

            The  monitor provides  each frame  with  a small  number of  small  in-core "files",
            intended for such functions as  passing command lines between programs.   The TMPCOR
            files have three-character (SIXBIT) file  names.  Simce there is only  limited space
            in the  monitor for  such files, it  is possible  that a program  will be  unable to
            create a TMPCOR file.  To get around this problem, a convention exists  where, after
            trying and failing to create a TMPCOR file, a program creates a disk file whose name
            is

                    <3-digit decimal frame #><TMPCOR filename>.TMP

            and  a  program  which  fails  to find  a  TMPCOR  file  likewise  searches  for the
            appropriate disk file.

                     _______ __ ______ ____ ___ ______ ____            2.7.1    TMPCOR: do TMPCOR file i/o (CALLI +44)

                    MOVE    ac, [function,,addr]
                    TMPCOR  ac,
                      error return
                    normal return

                     _______ ____ ______ ____ _______ __ __            2.7.2    .TCRRF: read TMPCOR file (TMPCOR fn 1)
                     _______ ______ ______ ____ _______ __ __            2.7.2    .TCRDF: delete TMPCOR file (TMPCOR fn 2)

                    MOVE    ac, [.TCRRF or .TCRDF,,addr]
                    TMPCOR  ac,
                      error return
                    normal return

            where <addr> points to a block of the form
                    wd 0    SIXBIT /file name/,, 0
                    wd 1    -length,,base-1

            If the TMPCOR file specified by <file name> is not found, set c(<ac>) to  the number
            of words of TMPCOR storage available to the process, and nonskip-return.

            Otherwise,  copy  up to  <length>  words of  the  TMPCOR file  named  into locations
            starting at <base>, set c(<ac>) to the actual length (so the program can tell if its
            buffer was too short), delete the TMPCOR file if this is a .TCDRF, then skip-return.










                                                    2-33


      Frames and Processes                     2                          YAMM edition 2.0


               _______ _____ ______ ____ _______ __ __      2.7.3    .TCRWF: write TMPCOR file (TMPCOR fn 3)

              MOVE    ac, [.TCRWF,,addr]
              TMPCOR  ac,
                error return
              normal return

      where <addr> points to a block of the form
              wd 0    SIXBIT /file name/,,0
              wd 1    -length,,base-1

      If a TMPCOR file with the specified name already exists, delete it.   Check <length>
      against the number of words of free space available: if there is not enough room for
      the new file, set c(<ac>) to the number of free words and error-return.

      Otherwise, create a new  TMPCOR file, store into  it the <length> words  starting at
      <base>, set c(<ac>) to the number of free words left (after creating the  file), and
      skip-return.

               _______ ____ ______ _________ _______ __ __      2.7.4    .TCRRD: read TMPCOR directory (TMPCOR fn 4)
               _______ _____ ______ _________ _______ __ __      2.7.4    .TCRDD: clear TMPCOR directory (TMPCOR fn 5)

              MOVE    ac, [.TCRRD or .TCRDD,,addr]
              TMPCOR  ac,
                JFCL  ; never taken
              only return

      where <addr> points to a block of the form
              wd 0    unused
              wd 1    -length,,base-1

      Set c(<ac>)  to the number  of files in  the frame's TMPCOR  directory.  Read  up to
      <length> directory entries into locations starting at <base>, clear the directory if
      this is a .TCRDD, then skip-return.

      The entries are of the form

              SIXBIT /file name/,,length

               _______ ___ ____ _____ _____ _______ __ __      2.7.5    .TCRFS: get free space count (TMPCOR fn 0)

              MOVSI   ac, .TCRFS
              TMPCOR  ac,
                JFCL  ; never taken
              only return

      Set c(<ac>) to the number of  words of TMPCOR storage available to the  process, and
      skip-return.




















                                              2-34


            July 3, 1980                             3                            Virtual Memory


                                                 _______ _                                                 Section 3
                                               _______ ______                                               Virtual Memory

                                             Table of Contents



            SubSection


            3.1      High and Low Segments    3-1
            3.1.1       CORE: allocate or free core (CALLI +11)    3-1
            3.1.2       REMAP: move top of lowseg to highseg (CALLI +37)    3-2
            3.1.3       SETUWP: set highseg write protection (CALLI +36)    3-2

            3.2      Job Data Area    3-3
            3.2.1       Low Segment Job Data Area    3-3
            3.2.2       Vestigial Job Data Area    3-3
            3.2.3       SETDDT: set DDT start address (CALLI +2)    3-3

            3.3      Core image files    3-5
            3.3.1       SAVE and SSAVE operations    3-5
            3.3.2       GETSEG: load a high segment (CALLI +40)    3-6
            3.3.3       RUN: load and run a program (CALLI +35)    3-7
            3.3.4       RUNSEG: load and run a high segment (CALLI -25)    3-10

            3.4      Execute-Only Programs    3-11


            Table

            3-4      Job Data Area Locations    3-4




































                                                    3-i


                                               3                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              3-ii


            July 3, 1980                             3                            Virtual Memory





                                                 _______ _                                                 Section 3
                                               _______ ______                                               Virtual Memory





                   ____ ___ ___ ________            3.1    High and Low Segments

            A frame's address space is composed of 512 512-word pages.  The bottom 256 pages are
            called the "low segment" and the top 256 pages the "high segment".  This division is
            inherited from monitors designed to run on the KA-10, which, instead of page tables,
            had only a  pair of relocation  registers to map  user addresses into  physical core
            adddresses.  The high segment came to  be used for programs and data which  could be
            shared   by   all  frames   running   a  particular   program   (and   was  normally
            write-protected), and  the low  segment for impure  data which  was private  to each
            frame.

            A program can make its high  segment writable by executing a SETUWP  UUO (CALLI +36,
            pg. 3-2).  THis  has the effect  of making the  high segment pages  from a  SHR file
            become copy-on-write and the high segment pages from a SWR file become  writable (so
            that stores into the high segment actually modify he file from which the program was
            run).

            The  RUN UUO  (CALLI +35,  pg. 3-7), RUNSEG  UUO (CALLI -25,  pg. 3-10),  GETSEG UUO
            (CALLI +40,  pg. 3-6), and  the RUN,  GET, SAVE,  and SSAVE  commands  still reflect
            the high/low  division.  Programs  which share data  and code  among all  the frames
            executing them  are saved in  two parts, one  of which is  mapped directly  from the
            program file into addresses above '400000,  so that all the pages are shared  by all
            the frames  running the program,  the other  of which is  copied into  private pages
            below '400000.

            In addition, the monitor maintains (compatibly with pre-paging monitors) a notion of
            each frame's low and high segment sizes,  so that the CORE command and the  CORE UUO
            (CALLI +11, pg. 3-1), designed to expand and contract segments, still work.

                     _____ ________ __ ____ ____ ______ ____            3.1.1    CORE: allocate or free core (CALLI +11)

                    MOVE    ac, [high,,low]
                    CORE    ac,
                      error return
                    normal return

            where <high> (<low>) = 0 to retain the current allocation,
                    or the highest address needed in the
                    high (low) segment

            (On  any  return from  CORE,  the specified  accumulator  is set  to  the  amount of
            additional core (in 1K units) available to the process).

            If both <high> and <low> are 0, take the error return; otherwise, wait until all i/o
            for the current process has stopped, then proceed as follows:

            Let <monrel> be the value last  stored by the monitor into .JBREL, and  <monhrl> the
            value last stored by the monitor into .JBHRL.

            If <low> is nonzero,  let <lowtop> = <low> rounded  up to the next 1K  boundary.  If
            <lowtop> is above '400000 and c(.JBHRL right) is nonzero, take the error return.  If
            <lowtop> < <monrel>, perform  VCLEARs for the pages  between the two; if  <lowtop> >
            <monrel>, perform VCREATs for the pages between the two.  If VCREAT or VCLEAR signal
            an error, take the error return; otherwise, set c(.JBREL) to <lowtop> and proceed.

            If <high> is nonzero, let <hightop> = <high> rounded up to the next 1K boundary.  If
            <monhrl> = 0, take  the error return.  If  <hightop> < '400000, perform  VCLEARs for

                                                    3-1


      Virtual Memory                           3                          YAMM edition 2.0


      all the pages from '400 through  '777; if <hightop> < <monhrl>, perform  VCLEARs for
      all the pages between the two; if <hightop> > <monhrl>, perform VCREATs for  all the
      pages between the two.  If VCLEAR or VCREAT signal an error, take the  error return;
      otherwise, set c(.JBHRL right) to <hightop> and proceed.

      Skip-return.

               ______ ____ ___ __ ______ __ _______ ______ ____      3.1.2    REMAP: move top of lowseg to highseg (CALLI +37)

              MOVE    ac, top
              REMAP   ac,
                error return
              normal return

      Let <lowtop> be <top> rounded up to the next 1K boundary.  Let <monrel> be the value
      last stored by  the monitor into  .JBREL and <monhrl> the  value last stored  by the
      monitor into .JBHRL.

      If <lowtop> < 0 or > '377777, or if <lowtop> > <monrel>, take the error return.

      If <monhrl> is nonzero, VCLEAR the pages from '400 through '777.

      (In what  follows, <take the  error return>  means just that  unless REMAP  has done
      something to the page containing the return address, in which case abort the process
      and store halt status HT.RMF for the frame.  ).

      If  <lowtop> =  <monrel>, or  if (<monrel>  - <lowtop>)  > '400000,  take  the error
      return.

      Remap the pages containing <lowtop>+1  through <monrel> so that the  page containing
      <lowtop>+1  becomes  page '400  (and  so  forth), set  their  current  protection to
      read-only, and add them to the working set.

               _______ ___ _______ _____ __________ ______ ____      3.1.3    SETUWP: set highseg write protection (CALLI +36)

              MOVEI   ac, prot
              SETUWP  ac,
                error return
              normal return

      where <prot> = 0 to make the high segment writable
                     1 to make it read-only

      If the frame has no high segment, clear <ac> and skip-return.

      Let <oldprot> be 1 if the current protection of page '400 is read-only, 0 otherwise.

      If  <prot>  is  1,  perform  a  VPROT UUO  to  set  the  current  protection  of the
      high-segment  pages  to  read-only;  otherwise,  perform  a  VPROT  UUO  to  set the
      protection of the  high-segment pages to read/write  if the high segment  was loaded
      from a SWR file or to copy-on-write if it was not.

      If  the  VPROT  signals an  error,  reset  the protection  of  the  high  segment to
      read-only,  set c(<ac>)  =  <oldprot>, and  take  the error  return;  otherwise, set
      c(<ac>) = <oldprot> and skip-return.













                                              3-2


            July 3, 1980                             3                            Virtual Memory


                   ___ ____ ____            3.2    Job Data Area

            Certain areas of your address space are typically reserved for communication between
            your program and the monitor.  Although these remain mostly for  historical reasons,
            they are still used by the monitor and contain a good deal of information  useful to
            the user.

                     ___ _______ ___ ____ ____            3.2.1    Low Segment Job Data Area

            The locations 20 through  137 of your address  space are typically reserved  as your
            Job data area.   These locations contain information  of mutual interest to  you and
            the monitor.  Unless the use agrees  with those shown in table Table 3-4   then your
            program should avoid accessing these locations.

            The file SYS:JOBDAT.REL contains the symbols for these location and is automatically
            loaded by the loader.   The loading of this  file also causes the  first relocatable
            data from your program to be loaded at location 140.

            Note  that it  is possible  to remove  page 0  from your  address space  and perhaps
            replace it with a file page.  This procedure is not recommended.

                     _________ ___ ____ ____            3.2.2    Vestigial Job Data Area

            Some constants in the Job data area may be loaded from the high segment  file (.HGH,
            .SHR or .SWR).  This removes the need  for a low segment file to accompany  the high
            segment  file in  the event  that there  is no  low segment.   The first  10 (octal)
            locations of the high segment are reserved fo vestigial dob data area.  When  such a
            program is saved using  the SAVE or SSAVE monitor  commands, no low segment  file is
            created unless  the left half  of .JBCOR  is 140 (octal)  or greater.   High segment
            programs will be  loaded with their first  relocatable location at the  high segment
            origin (400000+10 octal).   Again, use of these  locations which conflicts  with the
            uses described in Table 3-4  should be avoided.

                     _______ ___ ___ _____ _______ ______ ___            3.2.3    SETDDT: set DDT start address (CALLI +2)

                    MOVE    ac, addr
                    SETDDT  ac,
                    only return

            Set .JBDDT to <addr> and return.




























                                                    3-3


      Virtual Memory                           3                          YAMM edition 2.0


                                           _____ ___                                            Table 3-4 
                                    ___ ____ ____ _________                                    Job Data Area Locations


      symbol   loc        bits description

      .JBUUO   40              LUUO word stored here by hardware
      .JB41    41              LUUO instruction fetched from here by hardware (see
                               DECSYSTEM 10 System Reference Manual)
      .JBERR   42         LH:  (unused)
                          RH:  Used by CUSPs to record the number of errors detected:
                               incremented for each error. (Obsolete)
      .JBREL   44         LH:  (always 0)
                          RH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, by
                               the RUN and GET commands, and by the loader, to the highest
                               low-segment address.
      .JBBLT   45-47           Used by the loader to store a 3-instruction loop to copy
                               the loaded program into its proper position.
      .JBMUU   66              On an INTADR illegal-instruction or UUO trap, holds the
                               illegal instruction or UUO executed.
      .JBHCU   72              Contains the channel number of the highest-numbered channel
                               currently initted.
      .JBDDT   74         LH:  The highest address occupied by DDT.
                          RH:  The starting address of DDT, or 0 if ddt is not loaded.
                               This is the address branched to by the DDT command.
      .JBJDA   75-114          For channels 0 through '17, .JBJDA(channel no.) is nonzero
                               iff the channel is initted, so a program can scan .JBJDA to
                               find a vacant channel.  Note that .JBHCU can be greater
                               than '17, so it should not be used blindly as an index into
                               .JBJDA.
      .JBCNK   102-110         Temporaries used by CHAIN (see the LOADER manual).
      .JBCN6   106-114         Temporaries used by CHAIN (see the LOADER manual).
      .JBPFI   114             Highest "protected" location in the frame data area: all
                               i/o must be to locations above .JBPFI.
      .JBHRL   115        LH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, by
                               the RUN and GET commands, and by the loader, to the length
                               of the high segment.
                          RH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, and
                               by the loader, to the highest high-segment address.  by the
                               GET and RUN commands, and by the loader, to the highest
                               high-segment address.
      .JBSYM   116             AOBJN pointer to the symbol table created by the loader, or
                               0 if there is no symbol table.
      .JBUSY   117             AOBJN pointer to the undefined-symbol symbol table created
                               by the loader or DDT, or 0 if there are no undefined
                               symbols.
      .JBSA    120        LH:  Set by the loader to the first free low-segment address.
                          RH:  Set by the loader to the program's start address.  The RUN
                               command starts a program at this address.  The RPG program
                               starts a program at this address+1.
      .JBFF    121        LH:  (always 0)
                          RH:  Set to c(.JBSA left) by the RESET UUO.  Used in
                               buffered-mode i/o as the starting point for allocating
                               buffers, and advanced as buffers are allocated.
      .JBREN   124        LH:  (unused)
                          RH:  Set by the loader to the program's reenter address.  The
                               REENTER command transfers control to the address stored
                               here.
      .JBAPR   125        LH:  (always 0)
                          RH:  The APRENB trapping system transfers control to the routine
                               whose address is stored here.
      .JBCNI   126             The APRENB trapping system simulates a CONI APR into this
                               location before dispatching to the user's routine.
      .JBTPC   127             The APRENB trapping system stores the user's PC here before
                               dispatching to the user's trap routine.
      .JBOPC   130             The DDT, START, REENTER, and CSTART commands store the last
                               user-mode PC here before proceeding.

                                              3-4


            July 3, 1980                             3                            Virtual Memory

            symbol   loc        bits description
            .JBCHN   131        LH:  Set, in FORTRAN programs, to the address one above the last
                                     program loaded.
                                RH:  Set, in FORTRAN programs, to the address one above the last
                                     block data area loaded.
            .JBCOR   133        LH:  Set by the loader to the highest low-segment address
                                     containing nonzero data.  (If c(.JBCOR left) < 140, the
                                     SAVE and SSAVE commands will not create a low-segment
                                     file).
                                RH:  Set to the core argument of the last SAVE, SSAVE, RUN, or
                                     GET command.
            .JBCST   136             This location is for customers to use as they please
            .JBVER   137             Contains a version number for the program.
            .JBDA    140             This is the first location available to the user.





                                     _________ ___ ____ ____ _________                                     Vestigial Job Data Area Locations

            Symbol   Loc *      Bits Description

            .JBHSA   0               A copy of .JBSA.
            .JBH41   1               A copy of .JB41.
            .JBHCR   2               A copy of .JBCOR.
            .JBHRN   3          LH:  Restores the left half of .JBHRL.
                                RH:  Restores the right half of .JBREN.
            .JBHNM   5               The high segment name which was set on the execution of a
                                     SAVE command.
            .JBHSM   6               A pointer to the high segment symbols, if any.
            .JBHDA   10              First location available to user.

            * - These locations are relative to 400000



                   ____ _____ _____            3.3    Core image files

            This section  describes the  RUN and GET  operations provided  by the  monitor.  The
            monitor SAVE operation produces  a file or files which  can be loaded by GET  or RUN
            operations.  Its format is described  below.  RUN and GET operations can  be invoked
            by a variety of UUOs and by commands given to the monitor's command interpreter.

            The RUN  operation is that  action described for  the RUN UUO  (CALLI +35, pg. 3-7).
            The GET  operation is exactly  the same except  that the last  step, entry  into the
            gotten program, is not taken.

                     ____ ___ _____ __________            3.3.1    SAVE and SSAVE operations

            The high segment of a two-segment core-image is saved in a file having one  of these
            extensions:
                1)  .SHR.  Used to hold pages of a high segment which is sharable.  Normally
                    SHR files hold pure code.  The GET and RUN operations will map  pages of
                    a SHR file read-only.  The SETUWP UUO (CALLI +36, pg. 3-2) will make the
                    pages copy-on-write if it is asked to make the segment writable.
                2)  .SWR.  Used to hold pages of a sharable-writable high-segment.   The GET
                    and  RUN operations  will  map pages  read-only  but maximally-writable.
                    SETUWP will make the pages read-write.
                3)  .HGH.  Used to hold pages of  a high-segment which is not to  be shared.
                    GET,RUN and SETUWP operate as on SHR file pages.

            The  SAVE  command will  create  a  .HGH file  from  the high  segment  of  a loaded
            two-segment program; the SSAVE command will  create a .SHR file.  To save  a program
            with a sharable-writable high segment, the  SSAVE command is used and the  .SHR file
            renamed to .SWR.

            The low segment of a two-segment program is normally saved (by SSAVE) in a file with

                                                    3-5


      Virtual Memory                           3                          YAMM edition 2.0


      the extension .LOW, and  a single-segment program is  normally saved (by SAVE)  as a
      file with the extension .SAV.  If,  however, the SAVE or SSAVE commands are  given a
      file extension, they will use that instead.  For example,

              SSAVE FOO.BAZ

      will produce a high-segment file named FOO.SHR and a low-segment file named FOO.BAZ.

      High-segment files simply  store the pages that  were mapped into  addresses '400000
      and above at the time of the SAVE or SSAVE.

      Low-segment files  are zero-compressed: for  each nonzero sequence  of words  in the
      address  space, starting  with location  0, they  contain an  IOWD for  the sequence
      (whose left half is a  negative word count and whose  right half is 1 less  than the
      address into which the first word of  the sequence is to be loaded) followed  by the
      sequence itself.  The last "IOWD" (the word in the file following the  last sequence
      of nonzero data) is either a HALT or a JRST instruction.

      There are numerous  ways to invoke  the GET, RUN and  SAVE operations on  core image
      files:
          1)  RUN UUO (see below)
          2)  RUNSEG UUO (see below)
          3)  RUN and R commands
          4)  .FORUN UUO (FRMOP fn 33, pg. 2-27)
          5)  GETSEG UUO (see below)
          6)  GET command
          7)  .FOGET UUO (FRMOP fn 32, pg. 2-21)
          8)  SAVE and SSAVE commands
          9)  .FOSAV UUO (FRMOP fn 34, pg. 2-22)
          10)  .FOSSA UUO (FRMOP fn 35, pg. 2-22)

               _______ ____ _ ____ _______ ______ ____      3.3.2    GETSEG: load a high segment (CALLI +40)

              MOVEI   ac, addr
              GETSEG  ac,
                error return  ; <ac> := error code
              normal return

      where <addr> points to a block of the form
              SIXBIT /device name/
              SIXBIT /file name/
              0       ; ignored
              0       ; ignored
              ppn
              0       ; ignored

      and <ppn> is one of
              0 (or negative) : the current process's PPN
              0,,[SIXBIT /username/] : the AUN of the
                  specified (two-word) username
              project number,,programmer number : that PPN

      and <error code> is an error code from Table 8-19 

      If c(.JBREL) >= '400000, take the  error return.  Perform an OPEN operation  for the
      specified device: if it fails take the error return unless the error return location
      contains a HALT instruction, in which case abort the operation and store halt status
      HT.DNA for the frame.

      Attempt to LOOKUP, in the following order,

      <file name> . SHR
      <file name> . HGH
      <file name> . SWR

      If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
      location contains a  HALT instruction, in which  case abort the operation  and store

                                              3-6


            July 3, 1980                             3                            Virtual Memory


            halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
            (that is, using the first file successfully looked-up).

            Perform  a VCLEAR  operation on  all pages  from '400  through '777  of  the current
            process's  address  space.   If  GETSEG  was  called  from  an  address  >= '400000,
            subsequent <error return>s will instead abort the operation with either a  HT.TRE or
            HT.PGN halt  status, depending on  the device.  (This  is due to  the fact  that the
            caller's program no longer exists to which the monitor could return).

            If the device is a magtape,

                Read one standard-length magtape record into locations starting  at '400000.
                Then, based on c(.JBHRN left) in the vestigial "job data area" (part  of the
                record just read in), input  successive records until all the file  has been
                read: if an unexpected EOF occurs, abort the operation and store halt status
                HT.TRE for the frame.

                Perform  a  VPROT UUO  to  make all  the  pages just  created  and read-into
                read-only.  If the number of pages is odd, create a private page above them,
                to make the total number of  words a multiple of 1K.  Set c(.JBHRL  right) =
                the highest address read-into or created.

            Otherwise, the device must be a disk:

                If the file's size  is > '377777 words,  abort the operation and  store halt
                status HT.PGN for the frame.

                Otherwise, perform a VMAP UUO,  mapping the file's pages read-only  into the
                current  process's address  space, starting  at virtual  page '400:  if VMAP
                signals an error, abort the  operation and store halt status HT.TRE  for the
                frame.  If the file's extension is SWR, make the pages maximally-writable.

                Perform a WSCTL UUO to add the mapped pages to the current process's working
                set, and ignore any  error return.  If the  number of pages mapped  was odd,
                create a private page  above the mapped pages,  to make the total  number of
                words a  multiple of  1K.  Set  c(.JBHRL left)  = 0,  c(.JBHRL right)  = the
                highest address of the highest page mapped or created.

            Perform a RELEASE operation for channel 0, then skip-return.

                     ____ ____ ___ ___ _ _______ ______ ____            3.3.3    RUN: load and run a program (CALLI +35)

                    MOVE    ac, [start,,addr]
                    RUN     ac,
                      error return  ; <ac> := error code
                    ; normal return is to .JBSA of the loaded program
                    ; + <start>

            where <addr> points to a block of the form
                    SIXBIT /device name/
                    SIXBIT /file name/
                    SIXBIT /file extension/
                    0       ; ignored
                    ppn
                    license,,core

            and <ppn> is one of
                    0 (or negative) : the current process's PPN
                    0,,[SIXBIT /username/] : the AUN of the
                        specified (two-word) username
                    project number,,programmer number : that PPN

            and <error code> is an error code from Table 8-19 

            (The phrase "abort the operation and store halt status HT.xxx" appears several times
            in the discussion below.  The action  of the system at each such point  depends upon
            the context.  If the operation occurs in  a frame with no parent to which a  port is

                                                    3-7


      Virtual Memory                           3                          YAMM edition 2.0


      attached, then the  system error message corresponding  to that halt status  will be
      output on the port.  See Table 2-26 for halt status definitions.)

      Perform  a RESET  UUO.  Set  JBTNAM to  the specified  file name.   Perform  an OPEN
      operation for the  specified device: if  it fails take  the error return  unless the
      error return location contains a HALT instruction, in which case abort the operation
      and store halt status HT.DNA for the frame.

      Attempt to LOOKUP, in the following order,

      <file name> . SHR
      <file name> . HGH
      <file name> . <file extension>
          (or <file name> . SAV if <file extension> = 0)
      <file name> . SWR

      If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
      location contains a  HALT instruction, in which  case abort the operation  and store
      halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
      (that is, using the first file successfully looked-up).

      Perform a VCLEAR operation on all pages but page 0 of the current  process's address
      space.  Set c(.JBREL right) and c(.JBHRL) = 0.

      Let <core request> initially = <core>.   Let <size> be <core request> if  the device
      is a magtape, or the file's size if the device is a disk.

      If the file's extension is SHR, HGH, or SWR,

          If <core request> is greater  than the file's size, decrease  <core request>
          by <size>.

          If the device is a disk,

              If the file's size is > '377777 words, abort the operation and store
              halt status HT.PGN for the frame.

              Otherwise, perform  a VMAP UUO,  mapping the file's  pages read-only
              into the current process's  address space, starting at  virtual page
              '400: if VMAP signals an  error, abort the operation and  store halt
              status HT.TRE for the frame.   If the file's extension is  SWR, make
              the pages maximally-writable.

              Perform a WSCTL UUO to add the mapped pages to the current process's
              working set, and  ignore any error return.   If the number  of pages
              mapped was  odd, create a  private page above  the mapped  pages, to
              make the total number of words a multiple of 1K.  Set c(.JBHRL left)
              =  0, c(.JBHRL  right) =  the highest  address of  the  highest page
              mapped or created.

          Otherwise, the device must be a magtape:

              Read one standard-length  magtape record into locations  starting at
              '400000.  Then, based on  c(.JBHRN left) in the vestigial  "job data
              area" (part of  the record just  read in), input  successive records
              until all the file has been read: if an unexpected EOF occurs, abort
              the operation and store halt status HT.TRE for the frame.

              Perform a VPROT UUO to make all the pages just created and read-into
              read-only.  If  the number of  pages is odd,  create a  private page
              above them, to make the total number of words a multiple of 1K.  Set
              c(.JBHRL right) = the highest address read-into or created.

          Set c(.JBVER), c(.JBHRL left), rh(.JBREN), c(.JBCOR), c(.JB41), and c(.JBSA)
          from the corresponding  locations in the  vestigial "Job Data  Area".  Clear
          the rest of the "Job  Data Area" locations from .JBSA through  .JBDA.  Clear
          .JBDDT.

                                              3-8


            July 3, 1980                             3                            Virtual Memory


                If <file  extension> was 0,  and c(.JBCOR left)  is an address  below .JBDA,
                clear  page 0  above .JBDA.   Starting with  page 1,  create  enough private
                read/write pages to  include the address in  c(.JBCOR right), rounded  up to
                the next 1K boundary.  Set c(.JBREL right) to the highest address created.

                If <file extension> was nonzero, or the address stored in c(.JBCOR left) was
                above  c(.JBDA),  LOOKUP  <file name>.<file  extension>  or  <file name>.LOW
                (respectively):  if the  LOOKUP fails,  abort the  operation and  store halt
                status HT.FNF.  Let <size> be <core request> if the device is a  magtape, or
                the file's size if  the device is a disk.   If <size> is greater  than 128K,
                abort the operation and store halt status HT.PGN.  otherwise, load  the file
                as described below for non-(SHR, HGH, SWR) files.

            If the extension is not SHR, HGH, or LOW:

                Let <needed> be the address of the highest location needed to load a file of
                <size> words starting at the  location after .JBSVM, rounded up to  the next
                1K boundary.  If <core request> is  nonzero but is less, when rounded  up to
                the  next 1K,  than  <needed>, abort  the  operation and  store  halt status
                HT.PGN.  Otherwise, perform a VCREAT UUO to allocate pages up to  the larger
                of  <needed> or  <core  request> (aborting  the operation  and  storing halt
                status HT.PGN if it fails), then  perform a WSCTL UUO to add those  pages to
                the current process's working set, ignoring any error return.  Set c(.JBREL)
                = the highest address created.

                Perform an INPUT UUO  to read the file  into memory starting at  the address
                after .JBSVM: if INPUT signals an error, abort the operation and  store halt
                status HT.TRE.  If  the first word read  was negative, expand the  file read
                (see below).

                Let <needed> be  c(.JBCOR right) after reading  in the file, or  the highest
                address created  to read  in the  file if  c(.JBCOR right)  is 0.   If <core
                request> is nonzero  and less than <wanted>,  abort the operation  and store
                halt status HT.PGN.  Otherwise, perform the equivalent of a CORE UUO for the
                maximum of <needed> and <core request>: if it fails, abort the operation and
                store halt status  HT.PGN; otherwise, set c(.JBREL  right) = the  maximum of
                <needed> and <core request>.

                Set c(.JB41) = c(.JBS41).

            Set <passed license>  to minimum of <license>  and the current process  license (but
            set the read(write) privilege to  0 if <license>'s read(write) privilege  is greater
            than the current process's).  If the device is a magtape, or if the device is a disk
            and the  file's ppn differs  from the frame's  FPN, clear the  LC.HF bit  in <passed
            license>.

            Set the <execute only> bit of  the frame privilege word if an execute-only  file was
            read, or  if a file  with extension SWR  that had nonzero  license (or to  which the
            current  process  did  not have  update  access)  was loaded  as  the  high segment;
            otherwise, clear it.

            If the device is a  magtape, let <file license> be 0.   If the device is a  disk and
            only a  single file  was loaded,  let <file license>  be its  license word.   If the
            device is  a disk and  both a  low and a  high segment file  were loaded,  let <file
            license> be the  minimum of the  two files' license  words (but set  the read(write)
            privilege to 0 if the files' read(write) privileges are not the same).

            Set the process'  current license and  the frame's saved  license to the  maximum of
            <passed license>, <file license>, and the frame's current license.

            If the device is a disk, let the process' PID be:
                1)  <file PID> if only one file was loaded
                2)  <file PID> if  both high and  low files were  loaded and the  files have
                    identical PID
                3)  zero if two files were loaded with different PID

            Write a type 0 accounting record for the current frame.

                                                    3-9


      Virtual Memory                           3                          YAMM edition 2.0


               _______ ____ ___ ___ _ ____ _______ ______ ____      3.3.4    RUNSEG: load and run a high segment (CALLI -25)

              MOVE    ac, [start,,addr]
              RUNSEG  ac,
                error return  ; <ac> := error code
              ; normal return is to .JBSA of the loaded program
              ; + <start>

      where <addr> points to a block of the form
              SIXBIT /device name/
              SIXBIT /file name/
              0       ; ignored
              0       ; ignored
              ppn
              license,,0      ; right half ignored

      and <ppn> is one of
              0 (or negative) : the current process's PPN
              0,,[SIXBIT /username/] : the AUN of the
                  specified (two-word) username
              project number,,programmer number : that PPN

      and <error code> is an error code from Table 8-19 

      Set .GTNAM for the  frame to <file name>.  If  c(.JBREL) >= '400000, take  the error
      return.  Perform an OPEN  operation for the specified  device: if it fails  take the
      error return unless the error return location contains a HALT instruction,  in which
      case abort the operation and store halt status HT.DNA for the frame.

      Attempt to LOOKUP, in the following order,

      <file name> . SHR
      <file name> . HGH
      <file name> . SWR

      If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
      location contains a  HALT instruction, in which  case abort the operation  and store
      halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
      (that is, using the first file successfully looked-up).

      Perform  a VCLEAR  operation on  all pages  from '400  through '777  of  the current
      process's  address  space.   If  RUNSEG  was  called  from  an  address  >= '400000,
      subsequent <error return>s will instead abort the operation with either a  HT.TRE or
      HT.PGN halt  status, depending on  the device.  (This  is due to  the fact  that the
      caller's program no longer exists to which the monitor could return).

      If the device is a magtape,

          Read one standard-length magtape record into locations starting  at '400000.
          Then, based on c(.JBHRN left) in the vestigial "job data area" (part  of the
          record just read in), input  successive records until all the file  has been
          read: if an unexpected EOF occurs, abort the operation and store halt status
          HT.TRE for the frame.

          Perform  a  VPROT UUO  to  make all  the  pages just  created  and read-into
          read-only.  If the number of pages is odd, create a private page above them,
          to make the total number of  words a multiple of 1K.  Set c(.JBHRL  right) =
          the highest address read-into or created.

      Otherwise, the device must be a disk:

          If the file's size  is > '377777 words,  abort the operation and  store halt
          status HT.PGN for the frame.

          Otherwise, perform a VMAP UUO,  mapping the file's pages read-only  into the
          current  process's address  space, starting  at virtual  page '400:  if VMAP
          signals an error, abort the  operation and store halt status HT.TRE  for the
          frame.  If the file's extension is SWR, make the pages maximally-writable.
                                              3-10


            July 3, 1980                             3                            Virtual Memory


                Perform a WSCTL UUO to add the mapped pages to the current process's working
                set, and ignore any  error return.  If the  number of pages mapped  was odd,
                create a private page  above the mapped pages,  to make the total  number of
                words a  multiple of  1K.  Set  c(.JBHRL left)  = 0,  c(.JBHRL right)  = the
                highest address of the highest page mapped or created.

            Set <passed license>  to minimum of <license>  and the current process  license (but
            set the read(write) privilege to  0 if <license>'s read(write) privilege  is greater
            than the current process's).  If the device is a magtape, or if the device is a disk
            and the  file's ppn differs  from the frame's  FPN, clear the  LC.HF bit  in <passed
            license>.

            Set the <execute only> bit of  the frame privilege word if an execute-only  file was
            read, or  if a file  with extension SWR  that had nonzero  license (or to  which the
            current process  did not have  update access) was  loaded ; leave  it set if  it was
            already set at the time of the RUNSEG; and clear it otherwise.

            If the device is a  magtape, let <file license> be 0.   If the device is a  disk and
            only a  single file  was loaded,  let <file license>  be its  license word.   If the
            device is  a disk and  both a  low and a  high segment file  were loaded,  let <file
            license> be the  minimum of the  two files' license  words (but set  the read(write)
            privilege to 0 if the files' read(write) privileges are not the same).

            Set the process'  current license and  the frame's saved  license to the  maximum of
            <passed license>, <file license>, and the frame's current license.

            If the device is a disk, let the process' PID be:
                1)  <file PID> if only one file was loaded
                2)  <file PID> if  both high and  low files were  loaded and the  files have
                    identical PID
                3)  zero if two files were loaded with different PID

            Write a type 0 accounting record for the current frame.

            Set  c(.JBVER), c(.JBREN  right), c(.JBCOR),  c(.JB41) and  c(.JBSA right)  from the
            corresponding locations  in the vestigial  "job data area."  Set c(.JBREN  left) and
            c(.JBDDT) = 0.

            Perform the equivalent of an APRENB UUO with an argument of 0.

            Let <starting increment> be  <start>.  If the JP.EXO  bit was previously set  in the
            frame  privilege word,  clear all  but  1B35 of  <starting increment>.   If  the new
            <starting increment> is not either 0 or 1, clear the current process license and the
            current frame's saved license.  Add <starting increment> to c(.JBSA).  If the result
            is between 0 and '77, abort the operation and store halt status HT.NSA.

            Enter the loaded program at the address stored in c(.JBSA).


                   ____________ ________            3.4    Execute-Only Programs

            The monitor bit JP.EXO is used to prevent the users of programs from  doing anything
            but running them.  It  prevents operations which examine  or modify the VM  space of
            the program,  start it at  arbitrary locations, or  save it.  JP.EXO  is set  by the
            following operations
                1)  RUN command,  RUN UUO (CALLI +35,  pg. 3-7) or .FORUN  UUO (FRMOP fn 33,
                    pg. 2-27)
                2)  RUNSEG UUO (CALLI -25, pg. 3-10)
                3)  GET command, .FOGET UUO (FRMOP fn 32, pg. 2-21)

            whenever any of the following conditions prevails:
                1)  JP.EXO is already set before  RUN or RUNSEG is issued. (In  other words,
                    if an EXO program  RUNs other programs which  are not EXO, EXO  stays on
                    anyway)
                2)  file  from which  program  is being  gotten has  protection  FP.RUN. See
                    Table 8-7 .
                3)  file extension is SWR and file has license

                                                    3-11


      Virtual Memory                           3                          YAMM edition 2.0


          4)  file extension is SWR and frame does not have at least update  access to
              the file


































































                                              3-12


            July 3, 1980                             4                                    Paging


                                                 _______ _                                                 Section 4
                                                   ______                                                   Paging

                                             Table of Contents



            SubSection


            4.1      Hardware Paging    4-1

            4.2      Software Paging    4-1
            4.2.1       Page Types    4-1
            4.2.2       Working Sets    4-2
            4.2.3       Sharing    4-2
            4.2.4       Protection    4-2

            4.3      Creating Private Pages    4-3
            4.3.1       VCREAT: create private pages (CALLI -67)    4-3

            4.4      Unmapping Virtual Pages    4-4
            4.4.1       VCLEAR: unmap pages (CALLI -66)    4-4
            4.4.1       VREMOV: unmap pages (CALLI -65)    4-4

            4.5      Replicating Virtual Pages    4-4
            4.5.1       VREPLC: replicate virtual pages (CALLI -64)    4-4

            4.6      Mapping File Pages    4-5
            4.6.1       .CHMFP: map file pages (CHANIO fn 35)    4-5

            4.7      Mapping Absolute Disk Pages    4-6
            4.7.1       .CHSMP: super-map file pages (CHANIO fn 43)    4-6

            4.8      Changing Page Protection    4-7
            4.8.1       VPROT: set current protection for pages (CALLI -70)    4-7

            4.9      Working Set Control    4-7
            4.9.1       WSmax, WSlim, WSsiz    4-7
            4.9.2       WSCTL: do working set functions (CALLI -74)    4-8
            4.9.3       .WSRNG: add/remove pages from working set (WSCTL fn 1)    4-8
            4.9.4       .WSRSZ: read WSSIZ (WSCTL fn 3)    4-8
            4.9.4       .WSRLM: read WSLIM (WSCTL fn 4)    4-8
            4.9.4       .WSRMX: read WSMAX (WSCTL fn 5)    4-8
            4.9.4       .WSSTL: set WSLIM (WSCTL fn 2)    4-8
            4.9.5       .WSRBM: read working set bits (WSCTL fn 0)    4-9

            4.10     Prereferencing Pages    4-9
            4.10.1      PREREF: prereference a page (CALLI -75)    4-10

            4.11     Uninterruptible Page Copy    4-10
            4.11.1      BLTPAG: change data in page uninterruptibly (CALLI -123)    4-10

            4.12     Paging Related Errors    4-11
            4.12.1      Illegal Memory Reference    4-11
            4.12.2      Page Errors    4-11
                           PERSET: set/clear error bit (CALLI -72)    4-11
                           PGESTS: read/clear page-error status words (CALLI -100)    4-12
            4.12.3      Validating Pages    4-12
                           VALPAG: validate pages (CALLI -76)    4-12

            4.13     Page Faults    4-13
            4.13.1      Page Fault Word    4-13
            4.13.2      PGFSTS: read and clear page fault words (CALLI -101)    4-14
            4.13.3      PGRSTS: read/clear REFBIT fault info (CALLI -133)    4-14
            4.13.3      PGISTS: read/clear ill mem ref fault info (CALLI -132)    4-14

            4.14     Page Reference Bits    4-15
                                                    4-i


      Paging                                   4                          YAMM edition 2.0

      SubSection
      4.14.1      REFBIT: manipulate reference bits (CALLI -73)    4-15
      4.14.2      .RFRBM: Read refbits (Refbit fn 0)    4-15
      4.14.2      .RFSBM: Set refbits from bitmap (Refbit fn 1)    4-15
      4.14.3      .RFRNG: set refbits by range (Refbit fn 2)    4-15

      4.15     Virtual Page Information    4-16
      4.15.1      Page Status Word    4-16
                     PAGSTS: read page status word (CALLI -71)    4-16
      4.15.2      Testing for File Membership    4-17
                     VFSTAT: check private/file page (CALLI -77)    4-17
                     VPGFIL: get mapped-file name for page (CALLI -103)    4-18
      4.15.3      Disk Retrieval Pointers    4-18
                     VDSKPT: read disk pointer (CALLI -102)    4-18


      Table

      4-3      Page Protection Codes    4-3
      4-3b     VCREAT Error Codes    4-3
      4-7      VPROT Error Codes    4-7
      4-9      WSCTL Error Codes    4-9
      4-10     PREREF Error Codes    4-10
      4-11     BLTPAG error codes    4-11
      4-12     PERSET Error Codes    4-12
      4-12b    Page-error Status-word    4-12
      4-13     VALPAG Error Codes    4-13
      4-13b    Page Fault Word    4-14
      4-14     PGRSTS and PGISTS word formats    4-14
      4-16     REFBIT Error Codes    4-16
      4-17     Page Status Word Format    4-17
      4-17b    PAGSTS Error Code    4-17
      4-18     VPGFIL Error Codes    4-18
      4-19     Standard Paging error Codes    4-19



































                                              4-ii


            July 3, 1980                             4                                    Paging





                                                 _______ _                                                 Section 4
                                                   ______                                                   Paging





                   ________ ______            4.1    Hardware Paging

            The KI-10 hardware splits each 18-bit address into two parts -- a 9-bit  page number
            and  a 9-bit  word address  within that  page.  It  converts this  two-part "virtual
            address" into a "real  address" (the address of a  word in core) by indexing  into a
            "page table" with  the page number  to obtain the high-order  bits of the  real core
            address, then OR-ing-in the word address to obtain the low-order bits.

            Each of the 512 entries in  a hardware page table also contains an  "accessible" bit
            and a "writable" bit.  If a user process attempts a memory reference to a page whose
            "accessible" bit is off, that operation  will trap to the monitor; similarly,  if it
            attempts to write  into a page  whose "writable" bit is  off, the operation  will be
            trapped.


                   ________ ______            4.2    Software Paging

            The monitor maintains  a "logical page  table", or map,  for each process,  which it
            uses to set up the hardware map while that process is running.

            The main difference between the two  is that the logical page table  entries contain
            disk  page  addresses  while  the hardware  page  table  entries  contain  core page
            addresses.  A disk page is said to be "mapped to" a virtual page if the logical page
            table entry for  that virtual page  contains the address of  that disk page;  a disk
            page is said to be "mapped into a process's address space" if that page is mapped to
            some virtual page for that process.

                     ____ _____            4.2.1    Page Types

            A virtual page may either exist or  not exist: it "exists" if it has some  disk page
            mapped to it and does not exist otherwise.

            The  monitor  will signal  an  "illegal memory  reference"  if a  frame  attempts to
            reference a nonexistent page.

            A disk page which is  part of some file is a  "file page"; all other disk  pages are
            available for  allocation as new  file pages or  as "private"  pages--virtual memory
            pages  created  by the  CORE  UUO  (CALLI +11, pg. 3-1)  or  VCREAT  UUO (CALLI -67,
            pg. 4-3) which  disappear once  the process(es)  using them  disappear, or  when all
            users of  them remove  them from their  address spaces  with VREMOV  UUO (CALLI -65,
            pg. 4-4).

            The total  number of  existent pages  in a frame's  map cannot  be greater  than the
            current value of the .JPCOR field of the frame's Frame Privilege Word.














                                                    4-1


      Paging                                   4                          YAMM edition 2.0


               _______ ____      4.2.2    Working Sets

      Each entry in a  frame's map has an  "in-working-set" bit.  Before running  a frame,
      the  monitor  checks  every  existent   virtual  page  in  the  frame's   map  whose
      "in-working-set" bit  is on, brings  its disk page  into core if  it is  not already
      there, and sets up the corresponding hardware map entry to point to the core page.

      The monitor will signal a "page fault" if a frame attempts to reference  an existent
      virtual page whose "in-working-set" bit is zero.

      To the  monitor, the  "working set"  of a  process is  that set  of its  pages whose
      "in-working-set" bits are 1.   The monitor charges a  frame for (1) its  working set
      size over time, and (2) for each addition to its working set.

      The actual working set of a process (that is, the set of pages which it must have in
      core  to run  efficiently) will  often be  smaller than  the total  number  of pages
      mapped, and its membership fairly stable over time.  To run a  program economically,
      it is necessary to  make the state of  the "in-working-set" bits reflect  the actual
      working set of the process.  Some techniques for doing this are discussed on 4-7.

               _______      4.2.3    Sharing

      If a disk page is  referred to by more than one  map entry, that page is said  to be
      "shared".   (Even private  pages can  be shared,  since the  VREPLC  UUO (CALLI -64,
      pg. 4-4) can make two entries in a process's map refer to the same private page).

      The monitor guarantees  that, if two  running processes have  the same disk  page in
      their working sets,  their hardware page  tables will be  pointing to the  same core
      page.  (The same  is true if one  process has the same  page appearing twice  in its
      map).

               __________      4.2.4    Protection

      Each  entry  in  a  frame's  map  has  a  "maximally-writable"  bit  and  a "current
      protection" field.  The current  protection can be "read-only",  "copy-on-write", or
      "read/write".  A  process can  change the current  protection for  a page,  with the
      exception  that  only maximally-writable  pages  can have  their  protection  set to
      read/write.

      If a process attempts to store  data into a read-only page, the monitor  will signal
      an illegal memory reference for that page.

      If a  process attempts to  store data  into a copy-on-write  page, the  monitor will
      create a new  private page (maximally-writable  and currently read/write),  copy the
      contents of the referenced  page into it, replace the  old page with the new  one in
      the map, and then restart the store operation.

      All  private  pages are  maximally-writable.   A page  mapped  from a  file  will be
      maximally-writable if and only if (1) the process had done a successful ENTER on the
      file before mapping the page and (2)  the process had at least update access  to the
      file at the time of the ENTER.

















                                              4-2


            July 3, 1980                             4                                    Paging


                   ________ _______ _____            4.3    Creating Private Pages

            There are several methods by which a  private page may be added to a  frames address
            space.  The direct  method is to execute  the VCREAT UUO (CALLI -67,  pg. 4-3).  The
            subtler methods  include the CORE  UUO (CALLI +11, pg. 3-1),  as well as  other UUOs
            which call the CORE UUO.

                     _______ ______ _______ _____ ______ ____            4.3.1    VCREAT: create private pages (CALLI -67)

                    MOVE    ac,[flagB1+protB7+countB17,,page]
                    VCREAT  ac,
                      error return  ;ac/page,,code (see Table 4-19 )
                    normal return

            where <prot> is a protection code
                    from Table 4-3 
            and
            flag=0  to indicate the calling frame, and
            flag=1  to indicate the "other" frame
            (see 2-13)

            If <count> = 0,  or if <prot> is not  legal, take the error return.   Otherwise, for
            each of the <count> pages starting with <page>, perform the following:

                If  the page  number is  bad  (which count  result from  a bad  <page>  or a
                too-large <count>), or if the  page already exists, of if creating  the page
                would exceed the process's virtual page limit, or is there is no  disk space
                available to create the page, take the error return.

                Otherwise, create  the page,  making it  maximally-writable and  setting its
                current protection to <prot>, and clear it to zeros.

            Skip-return.


                                                 _____ ___                                                  Table 4-3 
                                           ____ __________ _____                                           Page Protection Codes


            name     code  protection
            .PRRO    1B7   read-only
            .PRCW    2B7   Copy-on-Write
            .PRRW    3B7   Read-Write



                                                 _____ ____                                                 Table 4-3b
                                             ______ _____ _____                                             VCREAT Error Codes


            name     code  error

            CRBCN%   0     <count> = 0
            CRBVP%   1     bad page number
            CRBPR%   2     bad <protection>
            CREXV%   3     page already exists (whose number is stored in <ac> left)
            CRLIM%   5     exceeded existing page limit (.PVCOR)
            CRDFL%   6     disk full










                                                    4-3


      Paging                                   4                          YAMM edition 2.0


             _________ _______ _____      4.4    Unmapping Virtual Pages

      The two UUOs VCLEAR and VREMOV remove one or more pages from a process's  map.  When
      the  last remaining  reference to  a particular  private page  is removed  (and only
      then), the page will be deleted; a particular disk page will retain its  contents as
      long as (and only as long as) it is either in some process's map or part of a file.

      To  unmap a  page, a  program executes  one of  VCLEAR UUO  (CALLI -66,  pg. 4-4) or
      VREMOV UUO (CALLI -65, pg. 4-4).

               _______ _____ _____ ______ ____      4.4.1    VCLEAR: unmap pages (CALLI -66)
               _______ _____ _____ ______ ____      4.4.1    VREMOV: unmap pages (CALLI -65)

              MOVE    ac, [flagB1+refclearB7+countB17,,page]
              VCLEAR  ac,
                or
              VREMOV  ac,
                error return  ;ac/page,,code (see Table 4-19 )
              normal return

      where <refclear> = 1B7 to clear the reference bit(s)
              on the page(s) being unmapped
      and
      flag=0  to indicate the calling frame, and
      flag=1  to indicate the "other" frame
      (see 2-13)

      If the  specified range of  pages (from  <page> through <page>  + <count>-1)  is not
      within the process's address space, take the error return.

      Otherwise, perform the equivalent  of a VALPAG UUO  for the range of  pages, waiting
      for all the dirty pages to be written to disk.  If the VALPAG signals an error, take
      the  error  return.   (The  important  exception  is  that  VCLEAR  will  ignore the
      nonexistent-page error-return of VALPAG).

      Otherwise, remove the  range of pages from  the process's map, clearing  the current
      protection  and maximally-writable  fields in  each page's  map slots,  clearing the
      reference bits if <refclear> is 1, and removing the pages from the process's working
      set.


             ___________ _______ _____      4.5    Replicating Virtual Pages

      The current contents of a range of map entries can be copied (possibly  with changed
      current protection) into some other nonoverlapping range.  This can be used  to make
      the same  page appear in  different places  in a process's  address space,  or, when
      followed by a VREMOV on the old  range, to move some set of pages without  having to
      copy their contents.

      The process executes VREPLC UUO (CALLI -64, pg. 4-4).

               _______ _________ _______ _____ ______ ____      4.5.1    VREPLC: replicate virtual pages (CALLI -64)

              MOVEI   ac, [
                      flagB1+protB7+countB17,,destination
                      source]
              VREPLC  ac,
                error return  ;ac/page,,code (see Table 4-19 )
              normal return

      where <prot> is a protection code
              from Table 4-3
      and
      flag=0  to indicate the calling frame, and
      flag=1  to indicate the "other" frame
      (see 2-13)


                                              4-4


            July 3, 1980                             4                                    Paging


            If the specified range of source pages (from <source> through <source>  + <count>-1)
            or  the   specified  range   of  destination   pages  (from   <destination>  through
            <destination> + <count>-1) are identical,  or if either is not within  the process's
            address space, or if <prot> is illegal, take the error return.  Otherwise,  for each
            of the <count> pairs of pages starting with <source> and <destination>,  perform the
            following:

                If  the source  page does  not  exist, or  if the  destination  page already
                exists; or if <prot> is .PRRW and the source page is not maximally-writable,
                take the error return.

                Otherwise, take the page currently mapped  as the source page and map  it as
                the destination  page, then  set the current  protection of  the destination
                page from <prot> and the maximally-writable bit from the source page entry.

            Skip-return.


                   _______ ____ _____            4.6    Mapping File Pages

            After a  file has  been properly  setup on a  channel using  the calls  described on
            8-1, the process may map pages  of the file into any previously  nonexistant virtual
            page in  its own  frame or  any other  frame to  which it  has .ARCHM  rights.  This
            functions is performed by the .CHMFP UUO (CHANIO fn 35, pg. 4-5).

                     _______ ___ ____ _____ _______ __ ___            4.6.1    .CHMFP: map file pages (CHANIO fn 35)

                    MOVE    ac, [.CHMFP,,channel]
                    CHANIO  ac, [
                            flagB1+protB7+countB17,,virtual page
                            file page]
                      error return  ; <ac> := page,,error code
                    normal return

            where <prot> is a protection code from
                    Table 4-3
            and
            flag=0  to indicate the calling frame, and
            flag=1  to indicate the "other" frame
            (see 2-13)

            If  <count> is  illegal, or  if  mapping <count>  pages would  exceed  the process's
            virtual page limit,  or if <prot>  is illegal; or if  <flag>=1 and the  caller lacks
            .ARCHM rights over the "other" frame; or if no file is selected on <channel>, or the
            process has  only lookup  access to  the file selected,  or <prot>  is .PRRW  and he
            process does not have at least update access to the file selected; or if <file page>
            is past the end of the file, take the error return.

            Otherwise, for  each of the  <count> pairs  of pages starting  with <file  page> and
            <virtual page>, perform the following:

                If the file page  is nonexistent, or if  the virtual page number  is outside
                the process's  address space or  the virtual page  already exists,  take the
                error return.  Otherwise, map the file page to the virtual page, setting the
                virtual page's  maximally-writable bit  if the process  has at  least update
                access to the file, and setting its current protection to <prot>.

            Skip-return.










                                                    4-5


      Paging                                   4                          YAMM edition 2.0


             _______ ________ ____ _____      4.7    Mapping Absolute Disk Pages

      A process having Read Absolute (RA) or Write Absolute (WA) license can map arbitrary
      pages of a disk structure or disk  unit into its address space using the  .CHSMP UUO
      (CHANIO fn 43,  pg. 4-6).   (For more  details  on the  interpretation  of  the disk
      address argument, refer to .CHSMP UUO (CHANIO fn 43, pg. 4-6) and 8-21.

               _______ _________ ____ _____ _______ __ ___      4.7.1    .CHSMP: super-map file pages (CHANIO fn 43)

              MOVE    ac, [.CHSMP,,channel]
              CHANIO  ac, [
                      protection + countB17 + virtual page
                      disk page]
                error return  ; <ac> := virtual page  ,,error code
              normal return

      where <protection> is a protection code from
              Table 4-3

      and <error code> is a code from Table 4-19 .

      If  <count> is  illegal, or  if  mapping <count>  pages would  exceed  the process's
      virtual page  limit, or  if <protection>  is illegal; or  if a  file is  selected on
      <channel>, take the error return.

      If the channel is not in "super mode", perfrom the following:

          If the process has neither read nor write absolute license, or if the device
          initted  was  neither  a  disk   structure  name  nor  a  disk   unit  name,
          error-return.   Otherwise, place  the  channel in  super mode,  and  make it
          available  for  subsequent inputs  if  the process  has  Read  Absolute (RA)
          license or  for inputs and  outputs if the  process has Write  Absolute (WA)
          license.

      Otherwise, for  each of the  <count> pairs  of pages starting  with <disk  page> and
      <virtual page>, perform the following:

          If "DSK"  or some  disk structure was  initted, interpret  <disk page>  as a
          logical page within the structure (with  the first page being page 0);  if a
          particular unit  was initted, interpret  it as an  absolute page  within the
          unit (also starting at page 0).

          If the  disk page is  past the  end of the  unit if a  unit was  selected or
          structure if  a structure  was selected, or  if the  virtual page  number is
          outside the process's address space  or the virtual page already  exists; or
          if <protection> =  .PRRW and the channel  is not available for  output, take
          the error-return.

          Otherwise, map the disk page to the virtual page, setting the virtual page's
          maximally-writable bit if the  channel is available for output,  and setting
          its current protection to <protection>.

      Skip-return.















                                              4-6


            July 3, 1980                             4                                    Paging


                   ________ ____ __________            4.8    Changing Page Protection

            To change the current protection on  a range of pages, a process executes  VPROT UUO
            (CALLI -70, pg. 4-7).

                     ______ ___ _______ __________ ___ _____ ______ ____            4.8.1    VPROT: set current protection for pages (CALLI -70)

                    MOVE    ac, [flagB1+protB7+countB17,,page]
                    VPROT   ac,
                      error return  ;ac/ vp,,error code
                    normal return

            where <prot> is a protection code
                    from Table 4-3
            and <flag> is 0 to indicate operating on the calling frame
            or  <flag> is 1 to indicate operating on the "other" frame
            (see 2-13).

            If <count> = 0, or if <prot> is illegal, take the error return.  Otherwise, for each
            of the <count> pages starting with <page>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, or if .PRRW is  being set
                and the page is not maximally-writable, take the error return.

                Otherwise, set the page's current protection to <prot>.

            Skip-return.


                                                 _____ ___                                                  Table 4-7 
                                             _____ _____ _____                                             VPROT Error Codes


            name     code  error

            PTBCN%   0     <count> = 0
            PTBVP%   1     bad <page>
            PTBPR%   2     bad <protection>
            PTNVP%   4     page does not exist
            PTPRF%   5     protection failure (only lookup access or <protection> = .PRRW and
                           less than update access



                   _______ ___ _______            4.9    Working Set Control

            A program may modify its user working set by executing the various functions  of the
            WSCTL  UUO (CALLI -74,  pg. 4-8).   When the  user  is performing  user  working set
            control, the monitor disables monitor working set control.

                     ______ ______ _____            4.9.1    WSmax, WSlim, WSsiz

            The monitor maintains, for each frame, a "maximum working set size limit" (WSMAX), a
            "current working set size limit"  (WSLIM), and a "current working set  size" (WSSIZ)
            value.

            If a process is not trapping page faults, the monitor will add each page faulted-for
            to its working set, but will throw  a page out before doing so if WSSIZ  has reached
            WSLIM.

            A program can set WSLIM to any value not exceeding WSMAX. The RUN and GET operations
            set WSLIM to equal WSMAX when a core image file is loaded.

            The user can set WSMAX with the command

            SET WSMAX <# of pages>

                                                    4-7


      Paging                                   4                          YAMM edition 2.0


      Doing so sets WSLIM and WSMAX  to the specified number of pages, and  removes enough
      pages from the current program's working set to bring WSSIZ down to the new WSLIM.

      A program can read WSSIZ, WSLIM, or WSMAX by executing the appropriate  functions of
      the WSCTL UUO (CALLI -74, pg. 4-8).

               ______ __ _______ ___ _________ ______ ____      4.9.2    WSCTL: do working set functions (CALLI -74)

              MOVE    ac, [function,,addr]
              WSCTL   ac,
                error return
              normal return

      If <function> is unknown, error-return; otherwise perform the specified function.

               _______ __________ _____ ____ _______ ___ ______ __ __      4.9.3    .WSRNG: add/remove pages from working set (WSCTL fn 1)

              MOVE    ac, [.WSRNG,,[addB7 + countB17 + page]
              WSCTL   ac,
                error return  ; <ac> := page  ,,error code
              normal return

      If <count> = 0, take the  error return.  Otherwise, for each of the  <count> virtual
      pages starting with <page>, perform the following:

          If the page number is bad (which could result from either a bad <page>  or a
          too-large <count>), take the error-return.

          If <add> = 0, remove the page from the working set.

          If <add> = 1, take the error return if the page does not exist, or if adding
          it to the working set would  cause WSLIM to be exceeded; otherwise,  add the
          page to the working set.

      Skip-return.

               _______ ____ _____ ______ __ __      4.9.4    .WSRSZ: read WSSIZ (WSCTL fn 3)
               _______ ____ _____ ______ __ __      4.9.4    .WSRLM: read WSLIM (WSCTL fn 4)
               _______ ____ _____ ______ __ __      4.9.4    .WSRMX: read WSMAX (WSCTL fn 5)

              MOVE    ac, [.WSRSZ or .WSRLM or .WSRMX ,, addr]
              WSCTL   ac,
                error return  ; never taken
              normal return   ; c(<addr>) := WSSIZ/WSLIM/WSMAX

      A program can set WSLIM by executing
               _______ ___ _____ ______ __ __      4.9.4    .WSSTL: set WSLIM (WSCTL fn 2)

              MOVE    ac, [.WSSTL,,[new limit]]
              WSCTL   ac,
                error return  ; <ac> := 0,,error code
              normal return

      If  <new limit>  is less  than  3 or  greater than  WSMAX,, take  the  error return.
      Otherwise, set WSLIM for the process to <new limit> and take the normal return.













                                              4-8


            July 3, 1980                             4                                    Paging


                     _______ ____ _______ ___ ____ ______ __ __            4.9.5    .WSRBM: read working set bits (WSCTL fn 0)

                    MOVE    ac, [.WSRBM,,addr]
                    WSCTL   ac,
                      error return  ; <ac> := 0,,error code
                    normal return

            where <addr> points to a block of the format
                    word 0    of words after this one
                    word 1  gets bits from first 36 pages
                    word 2  gets bits from 2nd 36 pages
                    ...

            Let <count> be c(<addr>).  If <count> <= 0, just take the normal return.  If <count>
            > ceiling(512/36), take the error return.

            Otherwise, fill  the <count>  words starting with  <addr>+1 with  the in-working-set
            bits of the process's pages, such that

                    c(<addr>+1+j bit k) :=
                    1 if page (j*36)+k is in the working set
                    0 otherwise

            Take the normal return.


                                                 _____ ___                                                  Table 4-9 
                                             _____ _____ _____                                             WSCTL Error Codes


            name     code  meaning

            WSBCN%   0     count = 0
            WSBVP%   1     bad virtual page
                     2     (unused)
                     3     (unused)
            WSNVP%   4     virtual page does not exist
            WSBFN%   5     illegal function code
            WSCTL%   6     count too large
            WSEWL%   7     exceeded working set size limit
            WSLGM%   10    attempt to set limit over  max
            WSLL3%   11    attempt to set limit under 3 pages



                    ______________ _____            4.10    Prereferencing Pages

            When a page is  added to a process's working  set, the monitor does  not immediately
            make it present  in core.  The  PREREF UUO (CALLI -75,  pg. 4-10) has the  effect of
            referencing a page, but does not block if the page is not present in core; this will
            inform the  monitor (in the  case the page  is not present)  that the  process needs
            attention. In addition, PREREF returns a bit indicating whether a real  reference by
            the program to the page would cause the program to block.















                                                    4-9


      Paging                                   4                          YAMM edition 2.0


                _______ ____________ _ ____ ______ ____      4.10.1    PREREF: prereference a page (CALLI -75)

              MOVE    ac,[flagB1,,page]
              PREREF  ac,
                error return  ;ac/page,,code (see Table 4-10 )
              normal return
      where
      flag=0  to indicate the calling frame, and
      flag=1  to indicate the "other" frame
      (see 2-13)

      If <page> is a bad page number, or  if the page does not exist, or if it  exists but
      is not in the process's working set, error-return.

      If  the  page is  already  present  in core,  set  bit 0  of  <ac>  and skip-return.
      Otherwise, initiate a swap-in  of it and any other  pages that are in  the process's
      working set but are not in core, clear bit 0 of <ac>, and skip-return.


                                          _____ ____                                           Table 4-10 
                                       ______ _____ _____                                       PREREF Error Codes


      name     code  condition

      PRBVP%   1     bad <page>
      PRNVP%   4     <page> does not exist
      PRNIW%   5     <page> not in working set



              _______________ ____ ____      4.11    Uninterruptible Page Copy

      A user program may be suspended between any two machine instructions,  in principle,
      and the physical machine might  be assigned to process some other  program entirely.
      Certain  individual instructions  can also  be interrupted:  notably the  BLT (Block
      Transfer) instruction.  This  may be unacceptable to  some processors which  need to
      make several changes to  a data page "in one  operation" so that a database  on disk
      reflects either all of the changes or  none of them.  To meet this need  the monitor
      provides  the BLTPAG  UUO (CALLI -123,  pg. 4-10), which  will  uninterruptibly copy
      data from one page to another.

                _______ ______ ____ __ ____ _______________ ______ _____      4.11.1    BLTPAG: change data in page uninterruptibly (CALLI -123)

              MOVE    AC,[1st source word,,1st destination word
                         last destination word]
              BLTPAG  AC,
               error return   <AC> := error code
              normal return
      where <error code> is from Table 4-11 

      If <1st destination> is greater than or equal to <last destination> or if the source
      or destination data cross a page boundary,  or if the pages cannot be locked  for an
      uninterruptible transfer, take the error return.  Otherwise, copy <1st  source word>
      to  <1st  destination  word>  and  so on  until  data  has  been  copied  into <last
      destination word>, then take the normal return.












                                              4-10


            July 3, 1980                             4                                    Paging


                                                _____ ____                                                 Table 4-11 
                                             ______ _____ _____                                             BLTPAG error codes


            name   number  meaning
            BUCBB% 0       can't BLT backwards (last dest. <= first dest. word)
            BUNWP% 1       data not all within one page
            BUCLP% 2       can't lock dest. page - too many lockers.  This is a temporary
                           condition.



                    ______ _______ ______            4.12    Paging Related Errors

            There are  three kinds of  error which can  occur when a  program tries to  access a
            page: an "illegal memory reference" will  occur if it tries to access  a nonexistent
            page, or if it tries to write on a page that is write-protected (read-only); a "page
            fault" will occur if it  tries to access a page which  is not in its working  set; a
            "page  error"  will occur  if  it  tries to  access  a page  which  has  suffered an
            irrecoverable i/o error in the process of being transferred to or from disk.

                      _______ ______ _________            4.12.1    Illegal Memory Reference

            Illegal memory references can be trapped using either the APRENB or INTADR interrupt
            system.  When an  illegal memory reference occurs,  the monitor stores  the hardware
            page fail word for the page in .JBPFN of the frame data area. The right half of this
            word is the address causing the ill mem ref, so the left 9 bits of that halfword are
            the  offending page's  page number.   The PAGSTS  UUO (CALLI -71,  pg. 4-16)  can be
            used to determine whether the ill mem ref was caused by accessing a nonexistent page
            or by writing into a write-protected page, etc.

                      ____ ______            4.12.2    Page Errors

            When a  page error  occurs, the  monitor will note  the fact  by setting  error bits
            associated with the page.   Page errors occur both when  a page is being  written to
            disk and read into core from disk.

            In neither case does a  process receive an immediate interrupt.  Page  output errors
            are reflected  to a program  when (if) it  tries to validate  the page.   Page input
            errors normally cause the .IAERR  software interrupt when a program tries  to access
            the  page.  The  PERSET UUO  (CALLI -72, pg. 4-11)  may be  executed to  cause these
            errors to be ignored, not causing the interrupt.

                        _______ _________ _____ ___ ______ ____            4.12.2.1    PERSET: set/clear error bit (CALLI -72)

                    MOVE    ac, [ignore + count,,start]
                    PERSET  ac,
                      error return  ;ac/page,,code (see Table 4-12 )
                    normal return

            where <ignore> = PS.NER (1B7) to ignore errors,
                             or 0B7 to interrupt on errors

            If <count>  = 0, error-return.   Otherwise, for each  of the <count>  pages starting
            with page <start> perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, take the error return.

                Otherwise, set the ignore-errors bit for the page if <ignore> is  PS.NER and
                clear it otherwise.

            Skip-return.

            The  monitor  maintains  two  page-error  status-words  for  each  process:  one for
            page-errors  which could  not  be handled  by the  user  for some  reason  (trap not
            enabled, etc.) and thus had to be handled by the monitor, and one for errors handled

                                                    4-11


      Paging                                   4                          YAMM edition 2.0


      by  the  process.  The  format  of  the two  words  is identical,  and  is  shown in
      Table 4-12b.  To read/clear these words, issue PGESTS UUO (CALLI -100, pg. 4-12).

                  _______ __________ __________ ______ _____ ______ _____      4.12.2.2    PGESTS: read/clear page-error status words (CALLI -100)

              MOVE    ac, [-count,,addr]
              PGESTS  ac,
                error return
              normal return

      If  <count> <=  0, clear  <ac> and  take the  error return.   If <count>  >=  1, set
      c(<addr>) to the stored user-handled error  status word, and set the stored  word to
      0.  If  <count> >=  2, set c(<addr>+1)  to the  stored monitor-handled  error status
      word, and set the stored word to 0.   If <count> > 2, clear <ac> and take  the error
      return; otherwise, take the normal return.


                                          _____ ____                                           Table 4-12 
                                       ______ _____ _____                                       PERSET Error Codes


      name     code  condition

      PEBCN%   0     bad <count>
      PEBVP%   1     bad <page>
      PENVP%   4     nonexistent page



                                          _____ _____                                          Table 4-12b
                                     __________ ___________                                     Page-error Status-word


      name   bit(s)  meaning

      EI.VAL 1B0     information is valid
      EI.PAR 1B14    parity error on dirty page
      EI.OER 1B15    output error
      EI.DER 1B16    device error
      EI.DTE 1B17    data error


                __________ _____      4.12.3    Validating Pages

      A program  can ensure that  a range  of pages is  written to the  disk by  using the
      VALPAG  UUO (CALLI -76,  pg. 4-12), which  initiates the  writing of  all  the dirty
      pages in that  range to disk,  and optionally waits  until the writes  are complete.
      Note that  the RIB of  a file open  on a channel  can also be  forced out  using the
      .CHVRB UUO (CHANIO fn 42, pg. 8-32).

                  _______ ________ _____ ______ ____      4.12.3.1    VALPAG: validate pages (CALLI -76)

              MOVE    ac, [flagB1+waitB7+countB17,,VP]
              VALPAG  ac,
                error return  ;ac/page,,code (see Table 4-13 )
              normal return

      where <wait> = VL.WAT (1B7) to wait for the writes
                     to complete, 0 to return immediately
      and
      flag=0  to indicate the calling frame, and
      flag=1  to indicate the "other" frame
      (see 2-13)

      If <count> =  0, take the  error return.  Otherwise, for  each of the  <count> pages
      starting with <VP>, perform the following:


                                              4-12


            July 3, 1980                             4                                    Paging


                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, take the error return.

                Otherwise, initiate a disk write for the page if it has been  modified since
                it was last swapped-in.

            If <wait> is 0,  skip-return.  Otherwise, wait until  all the dirty pages  have been
            written to the disk; if an i/o error has occurred, take the error  return, otherwise
            skip-return.


                                                _____ ____                                                 Table 4-13 
                                             ______ _____ _____                                             VALPAG Error Codes


            name     code  condition

            VLBCN%   0     bad <count>
            VLBVP%   1     bad page
            VLNVP%   4     page does not exist
            VLIOE%   5     i/o error occurred



                    ____ ______            4.13    Page Faults

            When  a  page fault  occurs,  say for  page  <page>, the  monitor  will  execute the
            following algorithm:

                If WSSIZ < WSLIM then

                    If an .IAFLL  software interrupt can  be taken, take  it; otherwise,
                    add <page> to the process's working set, and repeat  the interrupted
                    instruction.

                Otherwise (WSSIZ >= WSLIM),

                    If an .IAFEL  software interrupt can  be taken, take  it; otherwise,
                    remove pages from  the process's working set  until WSSIZ is  1 less
                    than  WSLIM, then  add <page>  to the  working set,  and  repeat the
                    interrupted instruction.

                Where "a  <x> interrupt can  be taken" means  that the process  is currently
                running in user mode (the fault did not, for example, happen as  the monitor
                was trying to reference a UUO argument), that the process has enabled (using
                INTASS) the <x> interrupt, and that no higher-priority software interrupt is
                in-progress or pending for that process.

            Note that even if  the program chooses to "see"  no page faults at all  (by choosing
            not to enable for either interrupt condition), it can still have some effect  on its
            paging behavior by  setting WSLIM, which determines  the point at which  page faults
            will cease to cause its working set to expand.

                      ____ _____ ____            4.13.1    Page Fault Word

            The monitor maintains two page fault words for each process: one for the  last fault
            which trapped to the user, and one for the last fault handled by the monitor.

            The format of a page fault word is described in Table 4-13b.









                                                    4-13


      Paging                                   4                          YAMM edition 2.0




                                          _____ _____                                          Table 4-13b
                                        ____ _____ ____                                        Page Fault Word


      name   bits   meaning
      FI.VAL 1B0    this word contains valid data
      FI.SAL 1B1    WSSIZ >= WSLIM at time of fault
      FI.VPN 777B26 Virtual Page number


                _______ ____ ___ _____ ____ _____ _____ ______ _____      4.13.2    PGFSTS: read and clear page fault words (CALLI -101)

              MOVE    ac, [-count,,addr]
              PGFSTS  ac,
                error return
              normal return

      If  <count> <=  0, clear  <ac> and  take the  error return.   If <count>  >=  1, set
      c(<addr>) to the stored user-handled fault  word, and set the stored word to  0.  If
      <count> >= 2, set c(<addr>+1) to the stored monitor-handled fault word, and  set the
      stored word to 0.  If <count> > 2, clear <ac> and take the error  return; otherwise,
      take the normal return.

                _______ __________ ______ _____ ____ ______ _____      4.13.3    PGRSTS: read/clear REFBIT fault info (CALLI -133)
                _______ __________ ___ ___ ___ _____ ____ ______ _____      4.13.3    PGISTS: read/clear ill mem ref fault info (CALLI -132)

              MOVE    ac,[-count,,addr]
              PGISTS  ac,
               or
              PGRSTS  ac,
               error return   ;ac/0 - <count> bad
              normal return

      addr:   user info word returned here
              monitor info word returned here if <count> allows

      If <count> is  less than 1  or greater than 2,  take the error  exit with ac  set to
      zero, the only error code for these UUOs.

      Clear the  saved user infomation  word and  return its old  contents at  <addr>.  If
      count allows, clear the saved  monitor information word, return its old  contents at
      <addr>+1, and take the normal return.


                                          _____ ____                                           Table 4-14 
                                 ______ ___ ______ ____ _______                                 PGRSTS and PGISTS word formats


      name   bit(s)  meaning

      II.ADR 777777B17 virtual address
      II.PFW 777777B35 soft page fail word

      RI.VAL 1B0     information is valid
      RI.ADR 777777B35 virtual address











                                              4-14


            July 3, 1980                             4                                    Paging


                    ____ _________ ____            4.14    Page Reference Bits

            The monitor associates a reference bit with each map entry.  The bit is set whenever
            a page is referenced by the process and cleared
                1)  When the program does a VREMOV or VCLEAR and specifies that it should be
                    cleared
                2)  When the program does a REFBIT UUO explicitly clearing it
            The monitor will cause a .IAREF software interrupt whenever a process attempts  to a
            access a page with reference bit 0 if the interrupt has been enabled.

            The main purpose of reference bits  is to enable a process managing its  own working
            set to  determine which of  its pages it  has touched over  some period of  time.  A
            program  manipulates  its pages'  reference  bits with  the  REFBIT  UUO (CALLI -73,
            pg. 4-15).

                      _______ __________ _________ ____ ______ ____            4.14.1    REFBIT: manipulate reference bits (CALLI -73)

                    MOVE    ac, [function,,addr]
                    REFBIT  ac,
                      error return  ; ac/ page,,error code
                    normal return

            <error code> is from Table 4-16 

            If <function> is  illegal take the error  return.  Perform the  appropriate function
            and take the normal return.

                      _______ ____ _______ _______ __ __            4.14.2    .RFRBM: Read refbits (Refbit fn 0)
                      _______ ___ _______ ____ ______ _______ __ __            4.14.2    .RFSBM: Set refbits from bitmap (Refbit fn 1)

                    MOVE    ac,[<.RFRBM or .RFSBM>,,<addr>]
                    REFBIT  ac,
                     error  return  ;ac/ page,,error code
                    normal  return

            where <addr> is the address of a block of the form
                    word 0  <count> of words following this one
                    word 1  ref bits for pp 0-35
                    word 2  ref bits for pp 36-71
                    ...

            If <count> > (512+35)/36, or if it  is <= 0, take the error return.   Otherwise, for
            .RFRBM, store <count> words of  reference bits into locations starting  at <addr>+1;
            for  .RFSBM, set  the refbit  for virtual  pages corresponding  to the  bits  in the
            <count> words beginning at <addr>+1.  Take the normal return.

                      _______ ___ _______ __ _____ _______ __ __            4.14.3    .RFRNG: set refbits by range (Refbit fn 2)

                    MOVE    ac,[.RFRNG,,[<bit>B7 + <count>B17 + <page>]]
                    REFBIT  ac,
                      error return
                    normal return

            <bit> is the new value for the refbits in the given range
            <count> is the number of pages to operate on
            <page> is the number of the first page to operate on

            If <count> =  0, take the  error return.  Otherwise, for  each of the  <count> pages
            starting with <page>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large  <count>),  take  the error  return.   Otherwise,  set  the page's
                reference bit to <bit>.

            Take the normal return.



                                                    4-15


      Paging                                   4                          YAMM edition 2.0


                                          _____ ____                                           Table 4-16 
                                       ______ _____ _____                                       REFBIT Error Codes


      name     code  condition

      RFBCN%   0     bad <count>
      RFBVP%   1     bad page number
      RFBFN%   5     bad <function>



              _______ ____ ___________      4.15    Virtual Page Information

                ____ ______ ____      4.15.1    Page Status Word

      A program can obtain a page status word for any existent virtual page.  The word has
      the format described in Table 4-17 .

      Note that the PS.FIL bit indicates whether  the page was part of a file at  the time
      it was mapped.  If the file page it was mapped from is deleted (e.g., using .CHDFP),
      PS.FIL will  remain on.  The  VFSTAT UUO (CALLI -77,  pg. 4-17), on the  other hand,
      indicates whether a particular  virtual page is currently  part of a file.   To read
      the  status  word  for  a  page,  a  program  executes  the  PAGSTS  UUO (CALLI -71,
      pg. 4-16).

                  _______ ____ ____ ______ ____ ______ ____      4.15.1.1    PAGSTS: read page status word (CALLI -71)

              MOVE    ac, [flagB1,,page]
              PAGSTS  ac,
                error return  ;ac/Table 4-17b
              normal return   ; <ac> := page status word
      where
      flag=0  to indicate the calling frame, and
      flag=1  to indicate the "other" frame
      (see 2-13)

      If <page> is bad, take the error  return.  If <page> does not exist, clear  <ac> and
      skip-return.  If <page> exists, set <ac> to the page's status word and skip-return.





























                                              4-16


            July 3, 1980                             4                                    Paging


                                                _____ ____                                                 Table 4-17 
                                          ____ ______ ____ ______                                          Page Status Word Format


            name     bits  meaning

            PS.UWS   1B0   in user working set
            PS.REF   1B1   has been referenced (ref bit)
            PS.MXW   1B2   maximally-writable
            PS.SUP   1B3   super-mapped
            PS.DDE   3B5   swap device error has occurred
            PS.FIL   1B32  was a file-page (when mapped)
            PS.CPR   7B35  current protection (see Table 4-3 )
                           1        read only
                           2        copy-on-write
                           3        read/write



                                                _____ _____                                                Table 4-17b
                                             ______ _____ ____                                             PAGSTS Error Code


            name     code  condition

            PSBVP%   1     bad <page>


                      _______ ___ ____ __________            4.15.2    Testing for File Membership

            A program can find out whether a particular page is currently mapped from a  file or
            whether it is private (note that  being private does not necessarily mean a  page is
            unshared)  by  executing the  VFSTAT  UUO (CALLI -77,  pg. 4-17).   (Note  also that
            VFSTAT tests for  a page's CURRENT  membership in any  file, whereas the  PS.FIL bit
            returned by PAGSTS UUO (CALLI -71,  pg. 4-16) reports its membership AT THE  TIME of
            the VMAP).

            Using the VPGFIL UUO (CALLI -103, pg. 4-18)  a program can find out the name  of the
            file from which any page was mapped, in case this information is not  known already.
            This permits, for example,  a GETSEG'd program to read  the file name from  which it
            was loaded  in order  to pass  this name  on to  another program  which may  want to
            return.

                        _______ _____ ____________ ____ ______ ____            4.15.2.1    VFSTAT: check private/file page (CALLI -77)

                    MOVE    ac, [page]
                    VFSTAT  ac,
                      error return  ; <ac> := error code
                    normal return

            where <error code> is a code from Table 4-19 .

            If <page> is bad,  or if the specified virtual  page does not exist, take  the error
            return.

            Otherwise, set c(<ac>) to 1 if the page is a file page or 0 if it is a private page,
            and skip-return.











                                                    4-17


      Paging                                   4                          YAMM edition 2.0


                  _______ ___ ___________ ____ ___ ____ ______ _____      4.15.2.2    VPGFIL: get mapped-file name for page (CALLI -103)

              MOVE    AC,[-count,,block]
              VPGFIL  AC,
               error return   ;  <AC> := error code
              normal return   ; block has data
       where <error code> is taken from Table 4-18 

      BLOCK:  <vp>    ;(argument to uuo; rest of block is return data)
              <bits>
              sixbit /<structure name>/
              sixbit /<file name>/
              sixbit /<ext>/
              zero
              <ppn>
              zero

      If <count> <=0, take the normal return with <AC> and <block> unchanged.  If  <vp> is
      bad, or <vp> doesn't exist, or <vp> is not a file page, take the error  return.  Set
      <structure>  to  the  structure-name  from  which  <vp>  was  mapped.   If  <vp> was
      super-mapped, let <bits>,<filename>,<ext> and <ppn> be zero.  If the file from which
      <vp> was mapped is now marked for deletion, set <bits> to 400000,,0; else set <bits>
      to zero. Set  <filename>,<ext> and <ppn> to  the name, extension and  directory from
      which <vp> was  mapped.  Begin returning  <bits>, <structure>, <filename>,  etc.  to
      <block> until  <count> runs  out; i.e.,  return as  much of  the information  as the
      caller allows room for.  Take the success return.


                                          _____ ____                                           Table 4-18 
                                       ______ _____ _____                                       VPGFIL Error Codes


      name     code  meaning

      PFBVP%   1     bad vp number
      PFNEX%   4     non-existent vp
      PFNFP%   6     not file page


                ____ _________ ________      4.15.3    Disk Retrieval Pointers

      To read the disk retrieval pointer for the disk page mapped to a  particular virtual
      page, a program executes the VDSKPT UUO (CALLI -102, pg. 4-18).

                  _______ ____ ____ _______ ______ _____      4.15.3.1    VDSKPT: read disk pointer (CALLI -102)

              MOVE    ac, [page]
              VDSKPT  ac,




















                                              4-18


            July 3, 1980                             4                                    Paging


                                                _____ ____                                                 Table 4-19 
                                        ________ ______ _____ _____                                        Standard Paging error Codes


            name     code  condition

            FLCTG%   0     virtual page <count> = 0
                           (.CHMFP, .CHSMP, VREMOV, VCLEAR, VREPLC)
            FLDVR%   1     Destination virtual page out of range
                           A destination page is (or will be) out-of-range (.CHMFP, .CHSMP,
                           VREMOV, VCLEAR, VREPLC, VFSTAT)
            FLCPU%   2     current <prot> undefined
                           <prot> is not a recognized protection code (.CHMFP, .CHSMP, VREPLC)
            FLVEX%   4     virtual page exists
                           a VP which should be nonexistent does exist (.CHMFP, .CHSMP, VREPLC)
            FLNEX%   4     page doesn't exist
                           A VP which should exist does not ( VREMOV, VREPLC, VFSTAR)
            FLSVR%   5     source VP out-of-range
                           A source VP is (or will be) out-of-range ( VREPLC)
            FLPHP%   6     past highest page
                           A specified file page is past the end-of-file (or past the end of the
                           unit or structure on a super-map) (.CHMFP, .CHSMP, .CHDFP, .CHXFP)
            FLFPZ%   7     a specified file page number is <= 0
                           (.CHMFP, .CHSMP(<0 only), VREPLC)
            FLCOR%   10    caller's .PVCOR size limit will be exceeded
                           (.CHMFP, .CHSMP, VREPLC)
            FLRBE%   11    RIB error
                           (.CHMFP, .CHCFP, .CHDFP, .CHXFP)
            FLBDS%   12    bad SAT
                           (.CHMFP, VREPLC, VFSTAT)
            FLCPL%   13    specified <prot> cannot be set for the VP
                           (.CHMFP, .CHSMP, VREPLC)
            FLLKC%   14    file is LOOKUP only, cannot be mapped
                           (.CHMFP)
            FLHOL%   16    file page which must exist is a hole
                           (.CHMFP, .CHDFP)
            FLNHL%   16    no hole at specified file page
                           A page cannot be created at the specified position because one
                           already exists there.  (.CHCFP)
            FLSNM%   17    structure name bad
                           Super map attempted when name INIT'ed is not a unit or structure
                           (.CHSMP)
            FLOPE%   20    i/o error on validation write of page
                           (VREMOVE, VCLEAR when page mapped max-write)
            FLSAM%   21    same source and destination page numbers
                           (.CHXFP, VREPLC)
            FLNML%   22    file already selected
                           Super map attempted with file already selected on the channel
                           (.CHSMP)
            FLNOF%   23    no file selected
                           (.CHMFP, .CHCFP, .CHDFP, .CHXFP, .CHVRB)
            FLNWT%   24    no write allowed
                           no file selected for output,or file selected is append-only (.CHCFP,
                           .CHDFP, .CHXFP)
            FLAQA%   25    disk full or user's quota exceeded
                           (.CHCFP)
            FLCTL%   26    (not returned to user programs)
            FLIPE%   27    (not returned to user programs)
            FLNTF%   30    no page of desired kind found
                           Find first interesting file page CHANIO has found no page of the
                           indicated kind (not currently returned by the CHANIO; may be
                           implemented later) (.CHFFI)
            FLNIM%   31    function not implemented
                           Find First Interesting file page CHANIO subfunction requested is not
                           yet implemented.  (.CHFFI)
            FLLGE%   32    suppress error logging not allowed
                           Caller asked to suppress logging of i/o errors in BAT blocks, but is
                           not priviledged to ask this.  (VREMOV,VCLEAR)
                                                    4-19


      Paging                                   4                          YAMM edition 2.0


      FLNSP%   33    (obsolete)
                     Caller asked to truncate file to a position not in the last page.
                     (obsolete; .CHFTR allows truncating to any position) (.CHFTR)

































































                                              4-20


            July 3, 1980                             5                               General I/O


                                                 _______ _                                                 Section 5
                                                _______ ___                                                General I/O

                                             Table of Contents



            SubSection


            5.1      Channels & I/O Initialization    5-1

            5.2      Device Assignment    5-1
            5.2.1       Device Availability    5-1
            5.2.2       Logical Names    5-2
            5.2.3       Device Names    5-2

            5.3      Channel Numbers    5-2

            5.4      Closing channels    5-2

            5.5      Releasing Channels    5-3

            5.6      File Status Bits    5-3
            5.6.1       Data Modes    5-3
            5.6.2       Reading, Testing and Setting    5-4

            5.7      Device Characteristics    5-4

            5.8      Device Manipulation    5-5
            5.8.1       Reassigning Devices    5-5
            5.8.2       Wait until inactive    5-5
            5.8.3       DEVCHR: read device characteristics word (CALLI +4)    5-6
            5.8.3       GETCHR: read device characteristics word (CALLI +6)    5-6
            5.8.4       DEVNAM: read device physical name (CALLI +64)    5-6
            5.8.5       DEVPPN: read PPN (CALLI +55)    5-6
            5.8.6       DEVSTS: read device hardware status (CALLI +54)    5-6
            5.8.7       REASSI: reassign i/o device (CALLI +21)    5-6
            5.8.8       SYSDVF: read system device data (CALLI -24)    5-7
            5.8.9       WAIT: wait until device inactive (CALLI +10)    5-7
            5.8.9       .CHWT: wait until device inactive (CHANIO fn 25)    5-7

            5.9      Major I/O UUOs    5-8
            5.9.1       CHANIO: do channel i/o functions (op code 043)    5-8
            5.9.2       INIT: Open a Channel (op code 041)    5-10
            5.9.2       OPEN: Open a Channel (op code 050)    5-10
            5.9.2       .CHOPN: Open a Channel (CHANIO fn 13)    5-10
            5.9.3       IN: input from channel (op code 056)    5-11
            5.9.3       .CHIN: input from channel (CHANIO fn 14)    5-11
            5.9.3       INPUT: input from channel (op code 066)    5-11
            5.9.3       .CHIPT: input from channel (CHANIO fn 3)    5-11
            5.9.4       OUT: output from channel (op code 057)    5-11
            5.9.4       .CHOUT: output from channel (CHANIO fn 15)    5-11
            5.9.4       OUTPUT: output from channel (op code 067)    5-11
            5.9.4       .CHOPT: output from channel (CHANIO fn 2)    5-11
            5.9.5       RESET: initialize frame state (CALLI +0)    5-12
            5.9.6       CLOSE: close a file (op code 070)    5-12
            5.9.6       .CHCLS: close a file (CHANIO fn 1)    5-12
            5.9.7       RELEAS: release device (op code 071)    5-13
            5.9.7       .CHREL: release device (CHANIO fn 0)    5-13
            5.9.8       GETSTS: read file status bits (op code 062)    5-13
            5.9.8       .CHGS: read file status bits (CHANIO fn 17)    5-13
            5.9.9       SETSTS: set file status bits (op code 060)    5-13
            5.9.9       .CHSS: set file status bits (CHANIO fn 16)    5-13
            5.9.10      STATO: skip if file status bits set (op code 061)    5-14
            5.9.10      .CHSO: skip if file status bits set (CHANIO fn 21)    5-14
            5.9.10      STATZ: skip if file status bits clear (op code 063)    5-14
            5.9.10      .CHSZ: skip if file status bits clear (CHANIO fn 20)    5-14
                                                    5-i


      General I/O                              5                          YAMM edition 2.0

      Table
      Table

      5-3      File Status Bits    5-3
      5-4      Data Modes    5-4
      5-5      Device Characteristics Word    5-5
      5-8      SYSDVF Function Codes    5-8
      5-9      CHANIOs by function    5-9
      5-10     CHANIOs by number    5-10




























































                                              5-ii


            July 3, 1980                             5                               General I/O





                                                 _______ _                                                 Section 5
                                                _______ ___                                                General I/O





                   ________ _ ___ ______________            5.1    Channels & I/O Initialization

            Each process has  48 software i/o channels.   The INIT UUO  (op code 041, pg. 5-10),
            OPEN  UUO  (op code 050, pg. 5-10),  and  the .CHOPN  UUO  (CHANIO fn 13, pg. 5-10),
            take a  channel number  and a  device name: they  assign the  device to  the calling
            process, and associate it with the specified channel.  The device (and  the channel)
            are said to be "initted" when this has been done.

            For each device, the monitor maintains  a "device data block" (or DDB),  which holds
            data identifying the device and describing its current status.  Each initted channel
            in a process points to some device  data block.  Since the disk is a  shared device,
            the monitor  creates a copy  of a master  disk DDB for  each channel that  inits the
            disk.  If more than  one channel inits the  same non-disk device, the  channels will
            share the same DDB.


                   ______ __________            5.2    Device Assignment

            A device  must be  "assigned" to  a process  in order  for that  process to  use it.
            Devices other than the disk may not be assigned to more than one process at a time.

            When a program inits a device,  the device is "assigned by program" to  the process;
            it remains assigned until the program releases it (or until it or the monitor does a
            RESET, which will release all assigned-by-program devices).

            When a user types the ASSIGN command

                    ASSIGN <device name>

            the device is "assigned by console" to the frame; it remains assigned until the user
            types

                    DEASSIGN <device name>

            or logs out.

            A  process which  has Transfer  Device (TD)  license can  take any  device currently
            "assigned by program" to it, and reassign that device "by console" either  to itself
            or  to  some  other  frame,  using  the  REASSI  UUO  (CALLI +21,  pg. 5-6),  or the
            REASSIGN command.

                     ______ ____________            5.2.1    Device Availability

            All devices are assigned to some frame.  Devices which are completely unavailable to
            the system are  "assigned by program"  to frame 0.   Devices which are  available to
            users are "assigned by console" to frame 0.

            If a process has  Get Device (GD) license, it  can init a device which  is available
            (i.e., which is "assigned by program" to frame 0).

            If a  frame has  Get Device (GD)  license, the  user can use  the ASSIGN  command to
            assign a device which is available.

            The device DSK  can always be  assigned, without Get Device  (GD) license, as  can a
            frame's command port or any port it has CREAUXed 10-21.



                                                    5-1


      General I/O                              5                          YAMM edition 2.0


               _______ _____      5.2.2    Logical Names

      The ASSIGN command can take an optional second argument specifying a  "logical name"
      for the device being assigned:

              ASSIGN <device physical name> <device logical name>

      Sunsequent  inits on  <logical name>  will be  redirected to  the  specified <device
      physical name>.  For example,

              ASSIGN LPT PTP

      will cause subsequent paper-tape-punch-directed output to go to the line printer.

      In many  UUOs which  take device names,  the program  can specify  a "physical-only"
      search, in which case logical name assignments are ignored.

               ______ _____      5.2.3    Device Names

      When processing  a UUO  which specifies  a device  name, the  monitor must  find the
      appropriate DDB.  The algorithm is:

      If the UUO does not specify a physical-only search, look for a device  whose logical
      name matches the argument: use its DDB.

      If that fails, check  whether the argument is the  generic name for disk,  "DSK", or
      "DS" or "D";  or whether it is  a disk structure name  ("DSKB"); or whether it  is a
      disk unit name: if it is, use a copy of the master disk DDB.

      If that fails, look for a  device whose physical name matches the argument:  use its
      DDB.

      If that fails,  and the argument  is "TTY", use  the current frame's  command port's
      DDB.


             _______ _______      5.3    Channel Numbers

      The monitor originally passed  channel numbers using the  ac field of the  i/o UUOs,
      limiting  the  maximum number  of  channels  to 16.   The  CHANIO  UUO (op code 043,
      pg. 5-8) was added to allow the number of channels to be increased.


             _______ ________      5.4    Closing channels

      Most devices have some notion of a "file".  Several files may be read or  written on
      a device before that device  is released; the .CHCLS UUO (CHANIO fn 1,  pg. 5-12) or
      CLOSE UUO (op code 070,  pg. 5-12) can be  used by a  program to inform  the monitor
      that it intends to finish the processing of the current file.

      The exact operation of CLOSE depends on the data mode the device was initted  in and
      on the device initted.
















                                              5-2


            July 3, 1980                             5                               General I/O


                   _________ ________            5.5    Releasing Channels

            When  a  process  is  finished  with a  channel,  it  should  execute  a  .CHREL UUO
            (CHANIO fn 0, pg. 5-13)  or RELEAS UUO  (op code 071, pg. 5-13) to  disassociate the
            device  with the  channel.   The RESET  UUO  (CALLI +0, pg. 5-12)  will  release all
            channels automatically.


                   ____ ______ ____            5.6    File Status Bits

            The monitor maintains a  file status word for each  device.  The right half  of that
            word can be manipulated by user  programs, and its bits are called the  "file status
            bits".   Some  file  status  bits are  device-dependent:  those  which  are  not are
            described in table Table 5-3 .

                     ____ _____            5.6.1    Data Modes

            There are eight standard data modes that can be specified for a device. The behavior
            of the modes differs from device  to device, but the general arrangement is  show in
            table Table 5-4 .


                                                 _____ ___                                                  Table 5-3 
                                              ____ ______ ____                                              File Status Bits


            name     bit   meaning

            IO.IMP   1B18  improper mode - some operation was performed or some data read which
                           is inappropriate for the current data mode
            IO.DER   1B19  device error detected by device
            IO.DTE   1B20  data error detected by monitor
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.EVP   1B26  (FTA: only) even parity (Table 11-5b)
            IO.BK2   1B26  (TTY: only) break-on-punctuation bit (Table 10-27 )
            IO.NEE   1B27  (TTY: only) no-escape-echo bit (Table 10-27 )
            IO.NEC   1B28  (TTY: only) no-echo bit (Table 10-27 )
            IO.DEN   3B28  (FTA: only) recording density (Table 11-5b)
            IO.FCS   1B29  (TTY: only) full-character-set bit (Table 10-27 )
            IO.SYN   1B30  synchronous i/o - in buffered mode IO, the device will stop after
                           processing each buffer; usually used with random IO
            IO.UWC   1B31  user supplied word count - in buffered mode IO, a user supplied word
                           count will be used in place of the one computed by the monitor
            IO.MOD   77B35 data mode mask (see Table 5-4 )





















                                                    5-3


      General I/O                              5                          YAMM edition 2.0


                                           _____ ___                                            Table 5-4 
                                           ____ _____                                           Data Modes


      name     code  description

      .IOASC   0     ASCII : a device-independent mode for buffered i/o of ordinary ASCII
                     text.  The byte size is 7 bits, and the characters are translated
                     where necessary (e.g., from card codes) by the monitor.
      .IOASL   1     ASCII line : identical to ASCII mode (retained only for
                     compatibility).
      .IOKAT   2     Katakana : a device-independent mode for buffered i/o of JIS-8
                     (Katakana) text.  The byte size is 9 bits (of which the high-order
                     bit should always be 0).
      .IOIMG   10    Image : a device-dependent mode for transfer of data without monitor
                     processing directly to and from the device.
      .IOIBN   13    Image Binary : a device-independent mode for the buffered transfer of
                     36-bit words without checksumming.
      .IOBIN   14    Binary : a device-independent mode for the buffered transfer of
                     records of 36-bit words with checksumming.
      .IODPR   16    Dump Records : a device-dependent mode for unbuffered blocked data
                     transfers.
      .IODMP   17    Dump : a device-dependent mode for unblocked unbuffered data
                     transfers.


               ________ _______ ___ _______      5.6.2    Reading, Testing and Setting

      To  read the  file status  bits  for a  channel, a  program executes  the  .CHGS UUO
      (CHANIO fn 17, pg. 5-13) or GETSTS UUO (op code 062, pg. 5-13).

      A program may  test the file status  bits for a channel  by executing the  .CHSO UUO
      (CHANIO fn 21,  pg. 5-14) or  STATO  UUO (op code 061,  pg. 5-14) to  test  for bits
      which are set, or the .CHSZ UUO (CHANIO fn 20, pg. 5-14) or STATZ  UUO (op code 063,
      pg. 5-14) to test for bits which are clear.

      Finally, a program may set the file status bits for a channel by executing the .CHSS
      UUO (CHANIO fn 16, pg. 5-13) or SETSTS UUO (op code 060, pg. 5-13).


             ______ _______________      5.7    Device Characteristics

      Since a  program may be  getting a logical  device when it  performs an OPEN  UUO, a
      means has been provided for the program  to determine the type of device that  it is
      working  with.   The program  may  execute  the DEVCHR  UUO  (CALLI +4,  pg. 5-6) or
      GETCHR  UUO  (CALLI +6,  pg. 5-6)  to obtain  a  word  describing  the  device.  The
      format of this word is given in Table 5-5 .





















                                              5-4


            July 3, 1980                             5                               General I/O


                                                 _____ ___                                                  Table 5-5 
                                        ______ _______________ ____                                        Device Characteristics Word


            name     bit   meaning

            DV.DSK   1B1   is a disk
            DV.CDR   1B2   is a card reader
            DV.LPT   1B3   is a line printer
            DV.TTA   1B4   is a frame's command port (DV.TTY will also be set)
            DV.NZP   1B5   do not zap circuit on a RESET (DV.TTY will also be set)
            DV.1UU   1B6   unused
            DV.2UU   1B7   unused
            DV.3UU   1B8   unused
            DV.PTP   1B9   is a paper tape punch
            DV.PTR   1B10  is a paper tape reader
            DV.4UU   1B11  unused
            DV.AVL   1B12  is available to this frame
            DV.MTA   1B13  is a magtape
            DV.TTY   1B14  is a terminal or aux circuit
            DV.DIR   1B15  has a directory (DV.DSK will also be set)
            DV.IN    1B16  input possible
            DV.OUT   1B17  output possible
            DV.ASG   1B18  assigned by console
            DV.ASP   1B19  assigned by program
            DV.DMP   1B20  dump mode legal
            DV.DPR   1B21  dump records mode legal
            DV.BIN   1B23  binary mode legal
            DV.IBN   1B24  image binary mode legal
            DV.IMG   1B27  image mode legal
            DV.KAT   1B33  katakana mode legal
            DV.ASL   1B34  ascii line mode legal
            DV.ASC   1B35  ascii mode legal



                   ______ ____________            5.8    Device Manipulation

            There is a family of UUOs which take either a channel number or a device name for an
            argument  and return  information  about the  device.   In what  follows,  a "device
            descriptor" is either a channel number or the SIXBIT name of some device.   A device
            descriptor is "invalid" if (1) it  is a channel number and the channel  it specifies
            is not initted or (2) it is a device name and the device cannot be found.

                     ___________ _______            5.8.1    Reassigning Devices

            A process which has a device assigned "by program" to it can assign that  device "by
            console" to  itself (or any  other process  having the same  AUN or,  given Transfer
            Device  (TD)  license,  any  other  process at  all)  by  executing  the  REASSI UUO
            (CALLI +21, pg. 5-6).

                     ____ _____ ________            5.8.2    Wait until inactive

            In order to wait for a device to stop transfering data, that is, become  inactive, a
            program may execute  the .CHWT UUO (CHANIO fn 25,  pg. 5-7) or WAIT  UUO (CALLI +10,
            pg. 5-7).   Several UUOs  automatically  wait for  their  device or  all  devices to
            become inactive.











                                                    5-5


      General I/O                              5                          YAMM edition 2.0


               _______ ____ ______ _______________ ____ ______ ___      5.8.3    DEVCHR: read device characteristics word (CALLI +4)
               _______ ____ ______ _______________ ____ ______ ___      5.8.3    GETCHR: read device characteristics word (CALLI +6)

              MOVE    ac, device descriptor
              DEVCHR  ac,     ; or GETCHR ac,
              only return

      (The GETCHR and DEVCHR UUOs are identical).

      If the <device descriptor> is invalid, set <ac> to 0 and return; otherwise, set <ac>
      to the device's device characteristics word, and return.

               _______ ____ ______ ________ ____ ______ ____      5.8.4    DEVNAM: read device physical name (CALLI +64)

              MOVE    ac, device descriptor
              DEVNAM  ac,
                error return
              normal return

      If  the  <device descriptor>  is  invalid, clear  <ac>  and take  the  error return.
      otherwise, set <ac> to the SIXBIT physical device name and take the normal return.

               _______ ____ ___ ______ ____      5.8.5    DEVPPN: read PPN (CALLI +55)

              MOVE    ac, device descriptor
              DEVPPN  ac,
                error return
              normal return

      If the <device descriptor> is invalid, clear <ac> and take the error return.

      Otherwise, set <ac> to SYS's PPN if the device is SYS and to the current frame's PPN
      if it is not, and take the normal return.

               _______ ____ ______ ________ ______ ______ ____      5.8.6    DEVSTS: read device hardware status (CALLI +54)

              MOVE    ac, device descriptor
              DEVSTS  ac,
                JFCL
              only return

      If the <device  descriptor> is invalid, clear  <ac> and skip-return;  otherwise, set
      <ac> to the device's hardware status word and skip-return.  The meaning of  the word
      returned is entirely device-dependent.

               _______ ________ ___ ______ ______ ____      5.8.7    REASSI: reassign i/o device (CALLI +21)

              MOVE    ac, [frame]
              MOVE    ac+1, device descriptor
              REASSI  ac,
              only return

      If <frame> does not exist, clear <ac> and return.

      If the <device descriptor> is invalid, or the device is a port, or the device is not
      assigned  to  the  current process;  or  if  <frame> and  the  current  process have
      different AUNs and the current  process does not have Transfer Device  (TD) license,
      clear <ac+1> and return.

      If <frame> is the current process, assign the device "by console" to the process and
      return.

      If <frame>  is a  different process,  do a RELEAS  on every  channel of  the current
      process which has the device initted, set the device's logical name to  its physical
      name (that is, nullify any previous logical name assignment), assign the  device "by
      console" to <frame>, and return.


                                              5-6


            July 3, 1980                             5                               General I/O


                     _______ ____ ______ ______ ____ ______ ____            5.8.8    SYSDVF: read system device data (CALLI -24)

                    MOVE    ac, [length,,addr]
                    SYSDVF  ac,
                      error return
                    normal return

            where <addr> points to a block of the form
                    word 0  function
                    word 1  start
                    word 2  set to word count for data block
                    word 3  set to word 0 of data block
                    ...

            If <function> is invalid, take the error return.

            If <start> is nonzero,  search the appropriate chain  of monitor data blocks  for an
            entry matching <start>, and take the error-return if none is found.

            The SYSDVF functions are shown in Table 5-8 .  Start with the first entry  after the
            one selected by <start>, or with the first entry in the chain if <start> was  0.  If
            there  is no  such entry,  set  c(<addr>+1) to  0 and  skip-return.   Otherwise, set
            c(<addr>+1) to  the name (.SDDDN,  .SDUDB, .SDSDD, .SDFTA)  or the  absolute address
            (.SDDDA) of the entry found and proceed as follows:

            For .SDDDN and .SDDDA:

                Store as  much of  the device data  block as  will fit (up  to <length>  - 2
                words) into locations starting with <addr>+3, set c(<addr>+2) to  the number
                of words stored, and skip-return.

            For .SDUDB, .SDSDD, and .SDFTA:

                If  the  process  does  not  have  Systat  (SY)  license,  just skip-return.
                Otherwise, store as much of the disk unit data block (.SDUDB), structure DDB
                (.SDSDD), or magtape unit data block (.SDFTA) as will fit (up to  <length> -
                2  words) into  locations  starting with  <addr>+3, set  c(<addr>+2)  to the
                number of words stored, and skip-return.

                     _____ ____ _____ ______ ________ ______ ____            5.8.9    WAIT: wait until device inactive (CALLI +10)
                     ______ ____ _____ ______ ________ _______ __ ___            5.8.9    .CHWT: wait until device inactive (CHANIO fn 25)

                    WAIT    channel,
                    only return

                    MOVE    ac, [.CHWT,,channel]
                    CHANIO  ac,
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Otherwise, wait for the device initted to become inactive, then return.















                                                    5-7


      General I/O                              5                          YAMM edition 2.0


                                           _____ ___                                            Table 5-8 
                                     ______ ________ _____                                     SYSDVF Function Codes


      name     code  description

      .SDDDN   0     Non-port/disk; the device data blocks for all those non-disk,
                     non-port devices belonging to the current process (or to all
                     processes with the current process's GAN if the current process has
                     account supervisor privilege, or to any process if the current
                     process has Systat (SY) license)
      .SDDDA   1     All; the same list as for .SDDDN except that ports and disks are not
                     excluded
      .SDUNI   2     Unit DDBs; the chain of unit data blocks for all the disk units in
                     the system (the current process must have Systat (SY) license)
      .SDSTR   3     STR DDBs; the chain of structure device data block (the current
                     process must have Systat (SY) license)
      .SDFTA   4     Mag Tape DDBs; the chain of unit data blocks for all the magnetic
                     tape units in the system



             _____ ___ ____      5.9    Major I/O UUOs

               _______ __ _______ ___ _________ ___ ____ ____      5.9.1    CHANIO: do channel i/o functions (op code 043)

              MOVE    ac, [function,,channel]
              CHANIO  ac, addr

      <channel> is the software channel number  on which the function is to  be performed.
      Currently, this may be in the range [0,47.].

      <function> is the function code for the operation to be performed on <channel>.  See
      Table 5-9  and Table 5-10  for a description of the CHANIO functions.

      The older i/o UUOs all have CHANIO equivalents, and the new functions  are available
      only through CHANIO.































                                              5-8


            July 3, 1980                             5                               General I/O


                                                 _____ ___                                                  Table 5-9 
                                            _______ __ ________                                            CHANIOs by function


            Function  Name     Description

            Channel functions

              fn 0    .CHREL   release device (5-13)
              fn 1    .CHCLS   close a file (5-12)
              fn 13   .CHOPN   Open a Channel (5-10)
              fn 16   .CHSS    set file status bits (5-13)
              fn 17   .CHGS    read file status bits (5-13)
              fn 20   .CHSZ    skip if file status bits clear (5-14)
              fn 21   .CHSO    skip if file status bits set (5-14)


            Disk file functions

              fn 4    .CHLK    select file for input (8-17)
              fn 5    .CHENT   select file for output (8-16)
              fn 6    .CHUSI   set file pointer by block (8-21)
              fn 7    .CHUSO   set file position by block (8-22)
              fn 10   .CHUGF   read disk file position (8-32)
              fn 11   .CHREN   rename or delete a file (8-17)
              fn 27   .CHFSI   set file pointer by block (8-21)
              fn 30   .CHFSO   set file position by block (8-22)
              fn 31   .CHPSI   set file pointer by page (8-21)
              fn 32   .CHPSO   set file position by page (8-22)
              fn 41   .CHMEN   select file for multi-update output (8-16)
              fn 45   .CHFTR   Truncate File (8-25)


            I/O functions

              fn 2    .CHOPT   output from channel (5-11)
              fn 3    .CHIPT   input from channel (5-11)
              fn 14   .CHIN    input from channel (5-11)
              fn 15   .CHOUT   output from channel (5-11)


            Page manipulation functions

              fn 35   .CHMFP   map file pages (4-5)
              fn 36   .CHDFP   delete file page (8-24)
              fn 37   .CHXFP   exchange file pages (8-24)
              fn 40   .CHCFP   create file page (8-24)
              fn 43   .CHSMP   super-map file pages (4-6)
              fn 44   .CHFFI   Find First Interesting Page (8-25)


            Buffer manipulation functions

              fn 22   .CHIBF   create input buffer ring (6-3)
              fn 23   .CHOBF   create output buffer ring (6-3)
              fn 26   .CHMBF   move buffers (6-4)


            Miscellaneous functions

              fn 12   .CHMTA   perform magtape functions (11-3)
              fn 24   .CHSK    seek to current page (8-23)
              fn 25   .CHWT    wait until device inactive (5-7)
              fn 33   .CHUFD   read UFD (8-3)
              fn 34   .CHMGN   manipulate update-interlock bit (8-26)
              fn 42   .CHVRB   validate RIB (8-32)


                                                    5-9


      General I/O                              5                          YAMM edition 2.0


                                          _____ ____                                           Table 5-10 
                                       _______ __ ______                                       CHANIOs by number


      Function  Name     Description

        fn 0    .CHREL   release device (5-13)
        fn 1    .CHCLS   close a file (5-12)
        fn 2    .CHOPT   output from channel (5-11)
        fn 3    .CHIPT   input from channel (5-11)
        fn 4    .CHLK    select file for input (8-17)
        fn 5    .CHENT   select file for output (8-16)
        fn 6    .CHUSI   set file pointer by block (8-21)
        fn 7    .CHUSO   set file position by block (8-22)
        fn 10   .CHUGF   read disk file position (8-32)
        fn 11   .CHREN   rename or delete a file (8-17)
        fn 12   .CHMTA   perform magtape functions (11-3)
        fn 13   .CHOPN   Open a Channel (5-10)
        fn 14   .CHIN    input from channel (5-11)
        fn 15   .CHOUT   output from channel (5-11)
        fn 16   .CHSS    set file status bits (5-13)
        fn 17   .CHGS    read file status bits (5-13)
        fn 20   .CHSZ    skip if file status bits clear (5-14)
        fn 21   .CHSO    skip if file status bits set (5-14)
        fn 22   .CHIBF   create input buffer ring (6-3)
        fn 23   .CHOBF   create output buffer ring (6-3)
        fn 24   .CHSK    seek to current page (8-23)
        fn 25   .CHWT    wait until device inactive (5-7)
        fn 26   .CHMBF   move buffers (6-4)
        fn 27   .CHFSI   set file pointer by block (8-21)
        fn 30   .CHFSO   set file position by block (8-22)
        fn 31   .CHPSI   set file pointer by page (8-21)
        fn 32   .CHPSO   set file position by page (8-22)
        fn 33   .CHUFD   read UFD (8-3)
        fn 34   .CHMGN   manipulate update-interlock bit (8-26)
        fn 35   .CHMFP   map file pages (4-5)
        fn 36   .CHDFP   delete file page (8-24)
        fn 37   .CHXFP   exchange file pages (8-24)
        fn 40   .CHCFP   create file page (8-24)
        fn 41   .CHMEN   select file for multi-update output (8-16)
        fn 42   .CHVRB   validate RIB (8-32)
        fn 43   .CHSMP   super-map file pages (4-6)
        fn 44   .CHFFI   Find First Interesting Page (8-25)
        fn 45   .CHFTR   Truncate File (8-25)


               _____ ____ _ _______ ___ ____ ____      5.9.2    INIT: Open a Channel (op code 041)
               _____ ____ _ _______ ___ ____ ____      5.9.2    OPEN: Open a Channel (op code 050)
               _______ ____ _ _______ _______ __ ___      5.9.2    .CHOPN: Open a Channel (CHANIO fn 13)

              OPEN    channel, [
                      bits,,status
                      SIXBIT /device name/
                      outring,,inring]
                error return
              normal return

              INIT    channel, status
              SIXBIT  /device name/
              outring,,inring
                error return
              normal return






                                              5-10


            July 3, 1980                             5                               General I/O


                    MOVE    ac, [.CHOPN,,channel]
                    CHANIO  ac, [
                            bits,,status
                            SIXBIT /device name/
                            outring,,inring]
                      error return
                    normal return

            where <inring> and <outring> are the addresses
                    of headers for buffered-mode input
                    and output, and can be 0 if no
                    buffered-mode i/o is to be done

            and <bits> is '100000 to specify a physical-only
                    search

            and <channel> is a channel number, which must be
                    between 0 and '17 for OPEN and INIT,
                    and between -1 and 48 for .CHOPN

            and <status> is the initial value for the device's
                    file status bits

            In the case of .CHOPN, if <channel> is -1, find the lowest-numbered channel  that is
            not initted and use it, taking the error-return if all channels are in use.

            If <channel> is already initted, perform a RELEAS for it.  Search for <device name>:
            if it is  not found, take  the error-return.  Check the  data mode field  (the right
            four bits)  of <status>: if  they are not  legal for the  device, abort the  UUO and
            store halt  status HT.IDM  for the  frame.  Assign  the device  "by program"  to the
            current process: error-return if it is not possible.

            Wait for the device to become inactive, then set the file status bits from <status>.
            If <outring> is  nonzero, initialize the output  buffer ring header; if  <inring> is
            nonzero, initialize the input buffer ring header.

                     ___ _____ ____ _______ ___ ____ ____            5.9.3    IN: input from channel (op code 056)
                     ______ _____ ____ _______ _______ __ ___            5.9.3    .CHIN: input from channel (CHANIO fn 14)
                     ______ _____ ____ _______ ___ ____ ____            5.9.3    INPUT: input from channel (op code 066)
                     _______ _____ ____ _______ _______ __ __            5.9.3    .CHIPT: input from channel (CHANIO fn 3)

            The action of these UUOs depends upon  the data mode of the channel at the  time the
            UUO is issued.  For a discussion of  their use in Buffered modes, see 6-4.   For use
            in dump modes, see 7-1.

                     ____ ______ ____ _______ ___ ____ ____            5.9.4    OUT: output from channel (op code 057)
                     _______ ______ ____ _______ _______ __ ___            5.9.4    .CHOUT: output from channel (CHANIO fn 15)
                     _______ ______ ____ _______ ___ ____ ____            5.9.4    OUTPUT: output from channel (op code 067)
                     _______ ______ ____ _______ _______ __ __            5.9.4    .CHOPT: output from channel (CHANIO fn 2)
            The action of these UUOs depends upon  the data mode of the channel at the  time the
            UUO is issued.  For a discussion of  their use in Buffered modes, see 6-4.   For use
            in dump modes, see 7-1.
















                                                    5-11


      General I/O                              5                          YAMM edition 2.0


               ______ __________ _____ _____ ______ ___      5.9.5    RESET: initialize frame state (CALLI +0)

              RESET
              only return

      Make page 0 be  private and writable if it  is not already.  Perform  the operations
      described in 10-2  for ports. For  initted channels, do  the equivalent of  a RELEAS
      UUO (op code 071,  pg. 5-13), except  do not  do a CLOSE,  and do  not wait  for the
      device to become inactive.

      Clear any charging  information saved by XCHARG.   Set the frame's working  set size
      limit to its  maximum working set  size limit.  Do the  equivalent of an  APRENB UUO
      with no conditions enabled.

      Return to the user, clearing the left half of the PC with the exception of  the USER
      and PUBLIC bits.

               ______ _____ _ ____ ___ ____ ____      5.9.6    CLOSE: close a file (op code 070)
               _______ _____ _ ____ _______ __ __      5.9.6    .CHCLS: close a file (CHANIO fn 1)

              CLOSE   channel, bits
              only return

              MOVE    ac, [.CHCLS,,channel]
              CHANIO  ac, bits
              only return

      where <bits> = CL.OUT  ('1) to inhibit closing output
                   + CL.IN   ('2) to inhibit closing input
                   + CL.ACS ('10) to inhibit access date update
                   + CL.RST ('40) to inhibit supersede/create

      If <channel> is not initted, just  return; otherwise, wait for the device  to become
      inactive and proceed.

      If  CL.IN  is  not  set,  close   the  input  side  of  the  channel:   perform  the
      device-dependent  close  routine  if  one exists  (unless  this  is  a buffered-mode
      non-disk file on which no input was actually done); then (unless this is a dump mode
      file) clear the use bits for each buffer  in the input ring, set the use bit  in the
      input buffer ring header, and set the input buffer ring header's count field to 0.

      Clear IO.EOF in the file status bits.

      If  CL.OUT  is not  set,  close the  output  side of  the  channel: if  the  file is
      buffered-mode and some output has been  done, write out all the output  buffers, set
      the  use bit  in the  output  buffer ring  header, and  set the  output  buffer ring
      header's count field to 0.  Perform the device-dependent close routine if one exists
      (unless this is a buffered-mode non-disk file on which no output was actually done).

      Check the error bits (bits 18-22) of the file status bits: if any are set, or if the
      device is a  magtape and the  end-of-tape flag is  set, cause an  i/o-error software
      interrupt if the process is enabled for one.

      Return.

      (The CL.ACS and CL.RST bits have meaning only for disk i/o: see 8-19).












                                              5-12


            July 3, 1980                             5                               General I/O


                     _______ _______ ______ ___ ____ ____            5.9.7    RELEAS: release device (op code 071)
                     _______ _______ ______ _______ __ __            5.9.7    .CHREL: release device (CHANIO fn 0)

                    RELEAS  channel,
                    only return

                    MOVE    ac, [.CHREL,,channel]
                    RELEAS  ac,
                    only return

            If <channel> is not initted, just return.

            Perform the equivalent of a CLOSE UUO (with 0 address) on the channel.  Wait for the
            device to become inactive, then perform the device-dependent release routine, if one
            exists.

            Break  the  association  between the  device  and  <channel>.  If  it  is  not still
            associated with the process (initted on some other channel or assigned  by console),
            assign it to frame 0 by console (making  it available) if it is not a disk  or port,
            zap it if it is a port.

            Return.

                     _______ ____ ____ ______ ____ ___ ____ ____            5.9.8    GETSTS: read file status bits (op code 062)
                     ______ ____ ____ ______ ____ _______ __ ___            5.9.8    .CHGS: read file status bits (CHANIO fn 17)

                    GETSTS  channel, addr
                    only return

                    MOVE    ac, [.CHGS,,channel]
                    CHANIO  ac, addr
                    only return


            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  Get the file status bits for <channel>'s device.  If the device is a disk or
            magtape  and  either  (1)  input  is  in  progress  or  (2)  the  monitor  has  done
            buffered-mode input ahead of the user, clear the error bits (bits 18 through 22).

            Set <addr> right to the bits and return.

                     _______ ___ ____ ______ ____ ___ ____ ____            5.9.9    SETSTS: set file status bits (op code 060)
                     ______ ___ ____ ______ ____ _______ __ ___            5.9.9    .CHSS: set file status bits (CHANIO fn 16)

                    SETSTS  channel, status
                    only return

                    MOVE    ac, [.CHSS,,channel]
                    CHANIO  ac, status
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.   Check the  data mode  field (the  right four  bits) of  <status>: if  it is
            illegal for  the device,  abort the  process and  store halt  status HT.IDM  for the
            frame.

            Wait for the device to become inactive, then set the file status bits from <status>.











                                                    5-13


      General I/O                              5                          YAMM edition 2.0


                ______ ____ __ ____ ______ ____ ___ ___ ____ ____      5.9.10    STATO: skip if file status bits set (op code 061)
                ______ ____ __ ____ ______ ____ ___ _______ __ ___      5.9.10    .CHSO: skip if file status bits set (CHANIO fn 21)
                ______ ____ __ ____ ______ ____ _____ ___ ____ ____      5.9.10    STATZ: skip if file status bits clear (op code 063)
                ______ ____ __ ____ ______ ____ _____ _______ __ ___      5.9.10    .CHSZ: skip if file status bits clear (CHANIO fn 20)

              STATO   channel, mask

              MOVE    ac, [.CHSO,,channel]
              CHANIO  ac, mask

              STATZ   channel, mask

              MOVE    ac, [.CHSZ,,channel]
              CHANIO  ac, mask

      All four calls do what GETSTS does to obtain the file status bits.  STATO  and .CHSO
      skip-return  if  the  logical  and   of  the  bits  and  <mask>  is   non-zero,  and
      nonskip-return otherwise.   STATZ and .CHSZ  skip-return if the  logical and  of the
      bits and <mask> is zero, and nonskip-return otherwise.

















































                                              5-14


            July 3, 1980                             6                         Buffered Mode I/O


                                                 _______ _                                                 Section 6
                                             ________ ____ ___                                             Buffered Mode I/O

                                             Table of Contents



            SubSection


            6.1      Buffer Ring Headers    6-1

            6.2      Buffer Format    6-2

            6.3      Buffer Setup    6-2
            6.3.1       User-Constructed Buffer Rings    6-2
                           Reading Standard Buffer Size    6-2
                           Initial Conditions    6-3
            6.3.2       Monitor-Constructed Buffer Rings    6-3
            6.3.3       DEVSIZ: read standard buffer size (CALLI +101)    6-3
            6.3.4       INBUF: create input buffer ring (op code 064)    6-3
            6.3.4       .CHIBF: create input buffer ring (CHANIO fn 22)    6-3
            6.3.4       OUTBUF: create output buffer ring (op code 065)    6-3
            6.3.4       .CHOBF: create output buffer ring (CHANIO fn 23)    6-3
            6.3.5       MOVBUF: move buffers (CALLI -27)    6-4
            6.3.5       .CHMBF: move buffers (CHANIO fn 26)    6-4

            6.4      Buffered I/O Operations    6-4
            6.4.1       Buffered Input Calls    6-4
            6.4.2       Buffered Output Calls    6-5

            6.5      I/O synchronization    6-6

            6.6      Buffered I/O Errors    6-6


































                                                    6-i


                                               6                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              6-ii


            July 3, 1980                             6                         Buffered Mode I/O





                                                 _______ _                                                 Section 6
                                             ________ ____ ___                                             Buffered Mode I/O




            Buffered-mode I/O  involves the  transfer of  data between  i/o devices  (or monitor
            buffers) and a ring of buffers in the user's address space.  Although P034 maintains
            the appearance of allowing simultaneous transfer of data and user processing of that
            data, this  is true  of only certain  devices, notably  magnetic tape.   Disk device
            transfers  are  handled  synchronously:  no  user  process  runs  while  the monitor
            transfers data to/from the user address space.

            To perform buffered input (output), a program must do the following:
                1)  Init a channel for the  input (output), specifying a buffered  data mode
                    (ASCII,  Katakana, Image,  Image Binary,  or Binary)  and  supplying the
                    address of a three-word input (output) buffer ring header.
                2)  Set up a buffer ring and  make the buffer ring header point to  it.  The
                    program can  allocate the  buffers itself  and set  the pointer;  it can
                    execute an INBUF (OUTBUF) to  cause the monitor to allocate  a specified
                    number of standard-sized  buffers; or it can  do nothing, in  which case
                    the first input (output) operation will do an INBUF  (OUTBUF) allocating
                    a buffer-ring of N standard-sized buffers, where N is standard  for each
                    device.
                3)  If doing output, execute an OUT or OUTPUT: ths causes the monitor to set
                    up  a byte  pointer and  byte  count in  the output  buffer  ring header
                    through which the program can store its first bufferful of data.
                4)  If doing input, execut an IN or INPUT: this causes the monitor to obtain
                    a bufferful of  data from the  device and to set  up a byte  pointer and
                    byte count in the input buffer ring header through which the program can
                    read its first bufferful of data.
                5)  Read data bytes from (write data bytes to) the buffer,  decrementing the
                    byte  count  each time,  until  the count  becomes  zero.   Then perform
                    another IN or  INPUT (OUT or OUTPUT)  to get another buffer,  and repeat
                    the process.
                6)  When input (output) is complete, release the channel.


                   ______ ____ _______            6.1    Buffer Ring Headers

            The buffer ring header has the format

                    word 0  bit 0   use bit
                    word 0  rh      current buffer
                    word 1          byte pointer
                    word 2          byte count

            The <use bit> is 1 if no i/o has yet been done using this buffer ring.  It is set to
            1 by the monitor at channel-init  time, and cleared at the first i/o  operation, and
            should not be altered by programs.

            The <current buffer> address is 0 if n buffer ring has been set up; otherwise, it is
            the address  of the second  word (word 1)  of the buffer  currently being  filled or
            emptied by the program.  If the monitor  finds the use bit 1 and the  current buffer
            address 0 when  attempting an i/o  operation, it will  perform an INBUF  (or OUTBUF)
            setting up a ring of two standard-size buffers.

            The <byte pointer> and <byte count> words are stored into the header by  the monitor
            at the completion of an i/o operation.  The byte pointer is set to point at the byte
            before the first byte of the buffer  so that the program can do ILDBs or  IDPBs, and
            the byte count is set to the number of words in the buffer times the number of bytes
            per word for the channel's data mode.

            The byte size field of the byte pointer is set by the monitor at  channel-init time,
            and should not be altered by the program.
                                                    6-1


      Buffered Mode I/O                        6                          YAMM edition 2.0


             ______ ______      6.2    Buffer Format

      Each buffer in a buffer ring has the format

              word 0  bits 18-35      file status bits
              word 1  bit 0           use bit
              word 1  bits 2-17       buffer size (words)
              word 1  bits 18-35      next buffer
              word 2  bits 0-17       checksum (if any)
              word 2  bits 18-35      word count
              word 3                  data
              ...
              word (<word count>+2)   data
              word (<word count>+3)   unused
              ...
              word (<buffer size>-1)  unused

      The <use  bit> is  1 if  the buffer  is available  to the  emptier, and  0 if  it is
      available to the filler.

      The <buffer size> field contains the  total size of the buffer, including  the three
      header words (word 0 through word 2).

      The <next buffer> address  contains the address of the  second word (word 1)  of the
      next buffer in the ring.

      On binary mode card or paper tape input, the <checksum> field contains  the checksum
      read at  the start of  the input record  and the <word  count> field the  word count
      read.  IO.DTE will be set if  the monitor's computed checksum differs from  the read
      value, and IO.BKT will be set  if an unexpected end-of-file occured (the  count read
      was too  big for  the physical medium)  or if  the count read  was greater  than the
      buffer size.

      On input from other devices and other modes, the <checksum> field is unused  and the
      <word count> contains the number of words actually read from the device.

      On output, the <word  count> originally in the  buffer is normally ignored,  and the
      number of words to output is computed  by the monitor from the current value  of the
      byte pointer in the  buffer ring header.  If, however,  the IO.UWC bit isset  in the
      file status bits, the monitor will use the <word count> in the buffer instead.


             ______ _____      6.3    Buffer Setup

      There are three  ways to set up  a buffer ring: entirely  "by hand", using  INBUF or
      OUTBUF, and letting the monitor allocate the ring by default.

               ________________ ______ _____      6.3.1    User-Constructed Buffer Rings

                 _______ ________ ______ ____      6.3.1.1    Reading Standard Buffer Size

      Each device  has a  standard buffer  size and  a standard-sized  buffer ring.   If a
      program is constructing its  own buffer ring and wants  to make it standard,  it can
      read the standard sizes by executing the DEVSIZ UUO (CALLI +101, pg. 6-3).














                                              6-2


            July 3, 1980                             6                         Buffered Mode I/O


                       _______ __________            6.3.1.2    Initial Conditions

            At the time of the first  i/o operation using a particular buffer ring,  the monitor
            expects to find
                1)  Each buffer's <use bit> set to 0.
                2)  Each buffer's <buffer size> set correctly.
                3)  Each buffer's <next buffer> address pointing to the second word (word 1)
                    of the next buffer in the ring.
                4)  The <current buffer> address in the buffer's buffer ring header pointing
                    to the second word (word 1) of one of the buffers in the ring.
                5)  The <use bit> of the buffer ring header set to 1.

                     ___________________ ______ _____            6.3.2    Monitor-Constructed Buffer Rings

            To cause the  monitor to set up  an input or output  buffer ring for a  channel, the
            program  executes  one   of  .CHIBF  UUO   (CHANIO fn 22,  pg. 6-3)  or   INBUF  UUO
            (op code 064, pg. 6-3) to setup input  buffers, or one of .CHOBF  UUO (CHANIO fn 23,
            pg. 6-3) or OUTBUF UUO (op code 065, pg. 6-3) to setup output buffers.

            Buffers may be moved  once they have been setup  (regardless of who set them  up) by
            performing  the  .CHMBF  UUO  (CHANIO fn 26,  pg. 6-4)  or  MOVBUF  UUO  (CALLI -27,
            pg. 6-4) to inform the monitor of the change.

                     _______ ____ ________ ______ ____ ______ _____            6.3.3    DEVSIZ: read standard buffer size (CALLI +101)

                    MOVEI   ac, [
                            file status bits
                            SIXBIT /device name/
                    ]
                    DEVSIZ  ac,
                      JFCL
                    only return

            Set <ac> to -1 if  <device name> does not exist,  <0> if the data mode  specified by
            the right four bits of <file status  bits> is not legal for the device, <-2>  if the
            data mode specified is Dump or Dump Records, or

                    standard no. of buffers in ring,,standard buffer size

            otherwise, and skip-return.

            Note that  the <standard buffer  size> returned includes  the three words  of header
            (words 0 through 2).

                     ______ ______ _____ ______ ____ ___ ____ ____            6.3.4    INBUF: create input buffer ring (op code 064)
                     _______ ______ _____ ______ ____ _______ __ ___            6.3.4    .CHIBF: create input buffer ring (CHANIO fn 22)
                     _______ ______ ______ ______ ____ ___ ____ ____            6.3.4    OUTBUF: create output buffer ring (op code 065)
                     _______ ______ ______ ______ ____ _______ __ ___            6.3.4    .CHOBF: create output buffer ring (CHANIO fn 23)

                    INBUF   channel,   of buffers
                    only return

                    MOVE    ac, [.CHIBF,,channel]
                    CHANIO  ac,   of buffers
                    only return

                    OUTBUF  channel,   of buffers
                    only return

                    MOVE    ac, [.CHOBF,,channel]
                    CHANIO  ac,   of buffers
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Starting  at  the  location  stored  in  .JBFF,  allocate  <   of  buffers> buffers,

                                                    6-3


      Buffered Mode I/O                        6                          YAMM edition 2.0


      determining the size of  each buffer from the  device and data mode  associated with
      the <channel>.  If necessary, perform COREs to obtain enough space for  the buffers,
      and if sufficient space canot be obtained, cause a memory protection violation.

      Increment .JBFF past the last buffer and set up the input (INBUF, .CHIBF)  or output
      (OUTBUF, .CHOBF) buffer ring header for <channel>.

               _______ ____ _______ ______ ____      6.3.5    MOVBUF: move buffers (CALLI -27)
               _______ ____ _______ _______ __ ___      6.3.5    .CHMBF: move buffers (CHANIO fn 26)

              MOVE    ac, [bits,,offset]
              MOVBUF  ac,
              only return

              MOVE    ac, [.CHMBF,,channel]
              CHANIO  ac, [bits,,offset]
              only return

      where <bits> = channel (for MOVBUF -- ingored for .CHMBF)
                   + '20 if moving input ring
                   + '40 if moving output ring
                   + '100 if moving input header
                   + '200 if moving output header

      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.

      Wait  for the  device  initted to  become inactive.   Add  <offset> to  each  of the
      internal pointers according to <bits> and return.


             ________ ___ __________      6.4    Buffered I/O Operations

               ________ _____ _____      6.4.1    Buffered Input Calls

      To cause the monitor to fill empty buffers in a buffer ring, the caller uses  one of
      IN  UUO  (op code 056,  pg. 5-11),.CHIN  UUO  (CHANIO fn 14,  pg. 5-11),  INPUT  UUO
      (op code 066, pg. 5-11), or .CHIPT UUO (CHANIO fn 3, pg. 5-11):

              IN      channel, newbuf
              normal return
                error return

              MOVE    ac, [.CHIN,,channel]
              CHANIO  ac, newbuf
              normal return
                error return

              INPUT   channel, newbuf
              only return

              MOVE    ac, [.CHIPT,,channel]
              CHANIO  ac, newbuf
              only return

      where <newbuf> is 0 normally and the address
              of the next buffer if switching buffer
              rings

      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.

      If output is currently in progress for the device, wait for it to complete.

      If <newbuf> is nonzero, wait for i/o to stop in the current input ring,  then switch
      to the buffer ring containing  the buffer at <newbuf>.  If necessary,  start filling
      that buffer, and wait until it is full or until an input error occurs.

                                              6-4


            July 3, 1980                             6                         Buffered Mode I/O


            If <newbuf> is zero, start  filling, if necessary, the buffer following  the current
            buffer in the  input ring, and wait  until the input is  complete or an  input error
            occurs.

            Check the  error bits (bits  18-22) of the  device's file status  bits.  For  IN and
            .CHIN, skip-return if any are set and nonskip-return if all are clear,  updating the
            input buffer ring header to point to the buffer just filled.  For INPUT  and .CHIPT,
            cause an i/o-error  software interrupt if  any are set,  and return in  either case,
            updating the input buffer ring header to point to the buffer just filled.

                     ________ ______ _____            6.4.2    Buffered Output Calls

            To cause the monitor to free up a buffer for output, the program executes one of OUT
            UUO   (op code 057,   pg. 5-11),.CHOUT  UUO   (CHANIO fn 15,   pg. 5-11),OUTPUT  UUO
            (op code 067, pg. 5-11), or .CHOPT UUO (CHANIO fn 2, pg. 5-11).

                    OUT     channel, newbuf
                    normal return
                      error return

                    MOVE    ac, [.CHOUT,,channel]
                    CHANIO  ac, newbuf

                    OUTPUT  channel, newbuf
                    only return

                    MOVE    ac, [.CHOPT,,channel]
                    CHANIO  ac, newbuf
                    only return

            where <newbuf> is 0 normally and the address
                    of the next buffer if switching buffer
                    rings

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If input is currently in progress on the device, wait for it to finish.

            If <newbuf> is nonzero, wait for i/o to stop in the current buffer ring, then switch
            to the buffer ring containing the buffer at <newbuf>.  If necessary,  start emptying
            that buffer, and wait until the output is complete or an output error occurs.

            In <newbuf> is zero, start emptying, if necessary, the buffer following  the current
            buffer in the output ring, and wait until the output is complete or an  output error
            occurs.

            Check the error  bits (bits 18-22)  of the device's file  status bits.  For  OUT and
            .CHOUT, skip-return if any are set and nonskip-return if all are clear, updating the
            output buffer  ring header  to point  to the  buffer just  emptied.  For  OUTPUT and
            .CHOPT, cause an i/o-error software interrupt  if any are set, and return  in either
            case, updating the output buffer ring header to point to the buffer just emptied.
















                                                    6-5


      Buffered Mode I/O                        6                          YAMM edition 2.0


             ___ _______________      6.5    I/O synchronization

      (The information below is not applicable to every device; in particular, DSK devices
      do not behave exactly as described below).

      For an input  buffer ring, the monitor  begins filling buffers whenever  the program
      does an input  operation and there  are fewer than  two full buffers  available, and
      stops when it reaches a buffer that the program has not yet emptied.   (Except that,
      for ports, the monitor will not  begin filling buffers until an input  operation has
      been executed with no full buffers available).

      For an output buffer ring, the monitor begins emptying buffers whenever  the program
      does an output operation and the monitor finds no empty buffers available, and stops
      when it reaches a buffer that the program has not yet filled.

      Setting the IO.SYN bit in the file status word will cause the monitor to  stop after
      filling (on  input) or  emptying (on output)  one buffer,  thus keeping  i/o exactly
      synchronized with the program.


             ________ ___ ______      6.6    Buffered I/O Errors

      (The information below is not applicable to every device; in particular, DSK devices
      do not any longer mask off error bits until the program reaches the buffer  in which
      the error occurred; the monitor does not know which block of 128 words within a page
      has suffered an error since it deals with DSK devices strictly on a page basis).

      Each time  it finishes filling  an input  buffer or emptying  an output  buffer, the
      monitor stores the appropriate device's file status bits into the right half of word
      0 of that buffer.   If an i/o error occurs,  the monitor will store the  status bits
      immediately, and stop further i/o on the buffer ring.

      The status-reading UUOs  (GETSTS, STATZ, STATO), and  the error-return/normal-return
      mechanism of the IN and OUT UUOs read the current value of the device's  file status
      bits, except that for  disk and magtape input the  error bits are masked off  if the
      program has not yet reached the buffer affected by the error.

      If the monitor has read ahead of the user from a device other than disk  or magtape,
      the program may receive an error indication before it actually reaches the bad data.
      In such a case, the program must check the status bits in each buffer if it wants to
      read all of the "good" data.



























                                              6-6


            July 3, 1980                             7                             Dump Mode I/O


                                                 _______ _                                                 Section 7
                                               ____ ____ ___                                               Dump Mode I/O

                                             Table of Contents



            SubSection


            7.1      Dump I/O Operations    7-1
            7.1.1       Dump Input Calls    7-1
            7.1.2       Dump Output Calls    7-2

            7.2      Dump I/O Errors    7-2





















































                                                    7-i


                                               7                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              7-ii


            July 3, 1980                             7                             Dump Mode I/O





                                                 _______ _                                                 Section 7
                                               ____ ____ ___                                               Dump Mode I/O




            In dump  mode i/o,  the monitor  transmits data to  or from  arbitrary areas  in the
            user's address space, under the control  of a command list whose entries  are 36-bit
            words having one of three forms:
                1)  -count,,addr-1
                        Transfer <count> words to or from
                <addr> through <addr>+<count>-1
                2)  0,,addr
                        Fetch the next command word
                from <addr> (This  is a  GOTO word.  Executing  more that  three consecutive
                    GOTOs is considered an error).
                3)  0
                        Return to the program.
                (This marks the end of a command list).
            To perform  dump mode  i/o, a program  must init  a channel in  either Dump  or Dump
            Records  mode.  (Dump  Records differs  from Dump  in that  records larger  than the
            standard  record size  will be  broken  up into  one or  more  standard-size records
            followed possibly by a single short record).


                   ____ ___ __________            7.1    Dump I/O Operations

            Dump mode I/O is accomplished by INITting the channel in Dump or Dump  Records mode,
            (see 5-10 and 5-3 and then using any of these UUOs:
                1)  .CHIN UUO (CHANIO fn 14, pg. 5-11)
                2)  IN UUO (op code 056, pg. 5-11)
                3)  .CHIPT UUO (CHANIO fn 3, pg. 5-11)
                4)  INPUT UUO (op code 066, pg. 5-11)
                5)  .CHOUT UUO (CHANIO fn 15, pg. 5-11)
                6)  OUT UUO (op code 057, pg. 5-11)
                7)  .CHOPT UUO (CHANIO fn 2, pg. 5-11)
                8)  OUTPUT UUO (op code 067, pg. 5-11)

                     ____ _____ _____            7.1.1    Dump Input Calls

                    IN      channel, addr
                    normal return
                      error return

                    MOVE    ac, [.CHIN,,channel]
                    CHANIO  ac, addr
                    normal return
                      error return

                    INPUT   channel, addr
                    only return

                    MOVE    ac, [.CHIPT,,channel]
                    CHANIO  ac, addr

            where <addr> is the address of a dump mode
                    command list

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If output is currently  in progress for the device,  wait for it to  complete.  Then
            execute the  command list at  <addr>, and wait  until it is  done or until  an input
            error occurs.

                                                    7-1


      Dump Mode I/O                            7                          YAMM edition 2.0


      Check  the error  bits (bits  18-22) of  the file  status bits.   For IN  and .CHIN,
      skip-return if any are set, nonskip-return if all are clear.  For INPUT  and .CHIPT,
      cause an i/o-error software interrupt if any are set, and return in either case.

               ____ ______ _____      7.1.2    Dump Output Calls

              OUT     channel, addr
              normal return
                error return

              MOVE    ac, [.CHOUT,,channel]
              CHANIO  ac, addr

              OUTPUT  channel, addr
              only return

              MOVE    ac, [.CHOPT,,channel]
              CHANIO  ac, addr
              only return

      where <addr> is the address of a dump mode
              command list

      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.

      If input is  currently in progress  for the device, wait  for it to  complete.  Then
      execute the command  list at <addr>, and  wait until it is  done or until  an output
      error occurs.

      Check the  error bits (bits  18-22) of the  file status bits.   For OUT  and .CHOUT,
      skip-return if any are set, nonskip-return if all are clear.  For OUTPUT and .CHOPT,
      cause an i/o-error software interrupt if any are set, and return in either case.


             ____ ___ ______      7.2    Dump I/O Errors

      An IN, INPUT, OUT, or OUTPUT returns  to the user program only when the  entire list
      of i/o requests has been processed, or an i/o error has occurred.

      If there is an error  in the I/O list itself  (such as illegal addresses in  the i/o
      words, or the execution of more than three successive GOTO words), abort the process
      and store halt status HT.ADC for the frame.  .

      I/o  errors stop  further execution  of the  command list,  and return  to  the user
      program after setting  the appropriate error  bits in the  file status bits  for the
      device.

      In neither  case is  there a  method for  the user  to determine  which word  in the
      command list caused the error.


















                                              7-2


            July 3, 1980                             8                                  Disk I/O


                                                 _______ _                                                 Section 8
                                                  ____ ___                                                  Disk I/O

                                             Table of Contents



            SubSection


            8.1      Device Names    8-1
            8.1.1       Logical Unit Names    8-1
            8.1.2       Physical Unit Names    8-2
            8.1.3       Abbreviations    8-2

            8.2      Buffered I/O    8-2

            8.3      Dump I/O    8-2

            8.4      Directories    8-2
            8.4.1       Master File Directory    8-3
            8.4.2       User File Directory    8-3
            8.4.3       Reading a Directory    8-3
            8.4.4       .CHUFD: read UFD (CHANIO fn 33)    8-3

            8.5      Frame Search List    8-5

            8.6      Storage Allocation Table    8-5

            8.7      File Organization    8-5

            8.8      File Access Protection    8-6
            8.8.1       License    8-6
            8.8.2       Disk Files with PIDs    8-7

            8.9      Directory Access Protection    8-7
            8.9.1       License    8-7

            8.10     File Selection    8-8
            8.10.1      File State Transitions    8-9
            8.10.2      Argument Blocks    8-9
            8.10.3      ENTER: select file for output (op code 077)    8-16
            8.10.3      .CHENT: select file for output (CHANIO fn 5)    8-16
            8.10.3      .CHMEN: select file for multi-update output (CHANIO fn 41)    8-16
            8.10.4      LOOKUP: select file for input (op code 076)    8-17
            8.10.4      .CHLK: select file for input (CHANIO fn 4)    8-17
            8.10.5      RENAME: rename or delete a file (op code 055)    8-17
            8.10.5      .CHREN: rename or delete a file (CHANIO fn 11)    8-17
            8.10.6      File Selection Error Codes    8-18
            8.10.7      Closing a Disk File    8-19
            8.10.8      Setting File License    8-20

            8.11     File Positioning    8-20
            8.11.1      Super USETI/USETO    8-21
            8.11.2      USETI: set file position by block (op code 074)    8-21
            8.11.2      .CHUSI: set file pointer by block (CHANIO fn 6)    8-21
            8.11.2      .CHFSI: set file pointer by block (CHANIO fn 27)    8-21
            8.11.2      .CHPSI: set file pointer by page (CHANIO fn 31)    8-21
            8.11.3      USETO: set file position by block (op code 075)    8-22
            8.11.3      .CHUSO: set file position by block (CHANIO fn 7)    8-22
            8.11.3      .CHFSO: set file position by block (CHANIO fn 30)    8-22
            8.11.3      .CHPSO: set file position by page (CHANIO fn 32)    8-22
            8.11.4      SEEK: seek to current page (CALLI +56)    8-23
            8.11.4      .CHSK: seek to current page (CHANIO fn 24)    8-23

            8.12     Direct File Page Manipulation    8-23
            8.12.1      .CHCFP: create file page (CHANIO fn 40)    8-24
            8.12.2      .CHDFP: delete file page (CHANIO fn 36)    8-24
                                                    8-i


      Disk I/O                                 8                          YAMM edition 2.0

      SubSection
      8.12.3      .CHXFP: exchange file pages (CHANIO fn 37)    8-24

      8.13     Specialized File Manipulation    8-25
      8.13.1      .CHFTR: Truncate File (CHANIO fn 45)    8-25
      8.13.2      .CHFFI: Find First Interesting Page (CHANIO fn 44)    8-25
      8.13.3      .CHMGN: manipulate update-interlock bit (CHANIO fn 34)    8-26

      8.14     Reading Information    8-26
      8.14.1      Disk Characteristics    8-27
                     DSKCHR: read disk characteristics (CALLI +45)    8-27
      8.14.2      Disk Unit/Structure Names    8-29
                     GOBSTR: Get system search list (CALLI +66)    8-29
                     JOBSTR: Return frames next file structure (CALLI +47)    8-30
                     STRUUO: Manipulate file structures (CALLI +50)    8-30
                     SYSPHY: read physical unit names (CALLI +51)    8-31
                     SYSSTR: read disk structure names (CALLI +46)    8-31
      8.14.3      UGETF: read disk file position (op code 073)    8-32
      8.14.3      .CHUGF: read disk file position (CHANIO fn 10)    8-32

      8.15     Validating and Flushing    8-32
      8.15.1      .CHVRB: validate RIB (CHANIO fn 42)    8-32
      8.15.2      DSKCLR: initialize in-core file system data (CALLI -22)    8-32


      Table

      8-5      Special UFD status bits    8-5
      8-7      File Protection Codes    8-7
      8-8      Directory Protection Bits    8-8
      8-9      File Access State Transition Rules    8-9
      8-10     Argument Codes    8-10
      8-11     Short Lookup Block    8-11
      8-12     Extended Lookup Block    8-12
      8-19     File Selection Error Codes    8-19
      8-28     DSKCHR Data Block    8-28
      8-29     DSKCHR Status Bits    8-29
      8-30     GOBSTR error codes    8-30
      8-31     STRUUO function codes    8-31
      8-31b    STRUUO error codes    8-31
      8-33     DSK: File Status Bits    8-33




























                                              8-ii


            July 3, 1980                             8                                  Disk I/O





                                                 _______ _                                                 Section 8
                                                  ____ ___                                                  Disk I/O




            The disk units of a system are not normally dealt with individually but  are grouped
            into "structures".  The current monitor supports only one disk structure (DSKB), but
            in the future, there may be  many.  The monitor organizes a disk structure  so that,
            rather than appearing as a fixed number of disk units each containing a fixed number
            of pages, it appears to contain  an arbitrary number of "directories" (or  UFDs, for
            User File Directories), each containing a variable number of variable-sized "files".

            A disk file has a name consisting of three parts:
                1)  The name of the structure it is stored on
                2)  The name of the UFD in which it is contained
                3)  The file's name
                4)  The file's extension
            For example,

                    DSKB: (SYS)SYSTAT.SAV

            is in the directory SYS on the structure DSKB; its name is SYSTAT and  its extension
            is  SAV.   A program  could  access this  file  by initting  the  device  DSKB, then
            executing a  file-selection UUO, such  as LOOKUP, to  specify the directory  and the
            file's name and extension.


                   ______ _____            8.1    Device Names

            Each file  structure has  a four-letter SIXBIT  name.  There  is currently  only one
            structure, and its name is DSKB.

            The structure  specified when a  channel is  initted is the  structure that  will be
            searched by subsequent file-selection UUOs on that channel.

            Normally, a program will init the generic device

                    DSK

            which causes the monitor  to refer to the  frame's "search list" to  determine which
            structures to search  on subsequent operations.  Since  there is currently  only one
            disk structure, specifying DSK as the device is equivalent to specifying DSKB.

                     _______ ____ _____            8.1.1    Logical Unit Names

            Each disk unit in a structure has a five-letter SIXBIT name, e.g.,

                    DSKB0   for the first unit in the structure
                    DSKB1   for the second, etc.

            If a program inits a  particular logical unit, subsequent operations  which allocate
            disk space (such as appending to a file or creating a file) will attempt to do so on
            the  specified unit,  but file  selection operations  will still  search  the entire
            structure.










                                                    8-1


      Disk I/O                                 8                          YAMM edition 2.0


               ________ ____ _____      8.1.2    Physical Unit Names

      Each type of disk controller has a two-letter SIXBIT name.  The only controller type
      currently supported is BP, which controls 3330-compatible disk drives.

      Each controller of a particular type has a three-letter SIXBIT name, e.g.,

              BPA     the first 3330 controller
              BPB     the second, etc.

      Each particular unit on a cpntroller has a four-letter SIXBIT name, e.g.,

              BPA0    the first 3330 on the first controller
              BPA1    the second 3330, etc.

      If  a program  inits a  particular controller  type, controller,  or  physical unit,
      subsequent operations  which allocate  disk space (such  as appending  to a  file or
      creating a file) will attempt to do so on the specified controller type, controller,
      or unit, but file selection operations will still search the entire structure within
      which it is contained.

               _____________      8.1.3    Abbreviations

      The generic name DSK can be abbreviated to DS or D.


             ________ ___      8.2    Buffered I/O

      Buffered disk i/o  can be performed in  ASCII, ASCII line (=ASCII),  extended ASCII,
      image, image binary (=image), or binary (=image) mode.

      In ASCII mode, the byte size is 7 bits; in extended ASCII, it is 9 bits; in image it
      is 36 bits.  Regardless of the mode used, the user's buffer is treated as containing
      36 bit words.

      The standard buffer size is 131 (decimal) words (128 data + 3 header).   The monitor
      will always assume that the user is providing standard-sized buffers.  If a program,
      for example, attempts disk  input into a 64-word  buffer with 3-word header,  the 64
      words immediately following the buffer will be written over.


             ____ ___      8.3    Dump I/O

      Either  dump  or  dump records  mode  i/o  can  be done  on  disk.   The  two behave
      identically: on input, the data is  read as specified; on output, records  which are
      not a multiple of 200 (occtal) words will be followed by enough 0s to reach the next
      200 word boundary.


             ___________      8.4    Directories

      A directory is a specially-formatted file which maps file names and  extensions into
      file addresses.















                                              8-2


            July 3, 1980                             8                                  Disk I/O


                     ______ ____ _________            8.4.1    Master File Directory

            The "master file directory" (MFD) of a structure is what the system searches to find
            a particular UFD.

            The "name" of a UFD is its owner's PPN; the "extension" is SIXBIT UFD.

            The master file directory itself can be looked up by passing the name word to LOOKUP
            with the 36-bit value "1,,1" and the extension "UFD".

                     ____ ____ _________            8.4.2    User File Directory

            A user file directory (UFD) is what the system searches to find a particular file.

            A structure's MFD is  in many ways just  a special case of a  UFD, and a UFD  just a
            special kind of file.  The differences are that
                1)  Only the MFD can contain pointers to UFD's
                2)  A program cannot directly perform i/o on a UFD
                3)  The  privilege  bits  (see  8-6)  of  a  UFD  or  MFD   are  interpreted
                    differently than those of a non-directory file

                     _______ _ _________            8.4.3    Reading a Directory

            An unlicensed process  cannot directly read  a directory as  though it were  a file.
            The monitor  does, however,  provide a  system call  for reading  the contents  of a
            directory.

            To examine the contents  of a directory, a  program first selects the  directory for
            input using the LOOKUP UUO, (by setting  the .RBNAM word of the LOOKUP block  to the
            PPN of the desired UFD, and the  .RBEXT word to SIXBIT "UFD") and then  executes the
            .CHUFD UUO (CHANIO fn 33, pg. 8-3).

                     _______ ____ ___ _______ __ ___            8.4.4    .CHUFD: read UFD (CHANIO fn 33)

                    MOVE    ac, [.CHUFD,,channel]
                    CHANIO  ac, addr
                      error return
                    normal return

            where <addr> points to an area of the form

                    wd 0    -length,,addr2
                    wd 1    SIXBIT /filename/
                    wd 2    SIXBIT /extension/
                    wd 3    bits (see below)
                    wd 4    (used by the UUO)
                    wd 5    startname
                    wd 6    startext
                    wd 7    count

            and <bits> = 1B0 to suppress wildcard processing
                             (# and * taken literally)
                       + 1B1 to return file size (in blocks)
                       + 1B2 to return file license word (.RBLIC)
                       + 1B3 to return file creation time and date
                       + 1B4 to return status bits (see below)
                       +1B10 to return the date and time in DEC
                             format and converted to the process's
                             current time zone, rather than
                             in standard format GMT








                                                    8-3


      Disk I/O                                 8                          YAMM edition 2.0


      and <addr2> points to a block (to be filled in by
              the UUO, one set of entries per file)
              of the form

              filename
              extension
              size (if requested) [see note below]
              license word (.RBLIC) (if requested)
              date,,time (if requested)
              status bits (if requested) (see below)

              with optional entries compressed
              (for example, if the status bits are
              requested, but the size, license word,
              and date and time are not,
              each entry will have only three words
              and the status bits will be stored in
              the third).

      and the <status bits> word contains

              bits 15-16      .RBLIC bits 0-1
              bits 17-18      .RBLIC bits 2-3
              bits 19-22      .RBLIC bits 4-7
              bits 23-26      .RBLIC bits 8-11
              bits 26-35      file protection code
      (see Table 8-5  for discussion of these bits)

      Note: Size of file returned is the value 777777400000
      if the actual file size is > 400000 blocks. Users of this
      UUO are advised to check the sign of the size returned,
      and if negative LOOKUP the file to get the size from
      the extended LOOKUP block.


      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.

      If no file has been selected for input, or if the file selected is not  a directory,
      error-return.

      Starting with the UFD entry after the one for <startname>.<startext>, or starting at
      the first directory entry if <startname> = 0, (and error-returning if  the directory
      is empty or  the specified starting  point could not  be found) iterate  through the
      entries satisfying <filename>.<extension>,  where "satisfying" means that  the names
      and extensions exactly match if bit 0 was set in <bits> or that they match if "#" in
      <filename> or  <extension> is  taken to  match any  character and  "*", if  given as
      <filename> or <extension> is taken to  match any filename or extension if bit  0 was
      clear: store the name and extension of each file matched (and as much  optional data
      as was  requested in <bits>)  into successive words  starting with <addr2>  until no
      more matching files are found or <length> words have been written.   Set c(<addr>+7)
      (the  count field)  to  the number  of  files for  which  data was  stored,  and set
      c(<addr>+5) (<startname>) and c(<addr>+6) (<startext>) to the name and  extension of
      the last file for which data was stored.

      If  no  entries  were  stored,  or if  the  EOF  of  the  directory  is encountered,
      error-return; otherwise, skip-return.











                                              8-4


            July 3, 1980                             8                                  Disk I/O


                                                 _____ ___                                                  Table 8-5 
                                          _______ ___ ______ ____                                          Special UFD status bits


            Bits in <status word> returned by .CHUFD UUO (CHANIO fn 33, pg. 8-3)
            See also discussion of .RBLIC in Table 8-12 
            bit    function 23     this file is temporary..LOGOUT & GFD will delete it
            24     this is a JIS-8 Katakana-mode file.
            Other bits may be getting use.  More research required.



                   _____ ______ ____            8.5    Frame Search List

            When a frame inits DSK rather than a specific disk structure, the monitor determines
            which structures to search on subsequent file-selection operations by  examining the
            frame's  "frame  search  list".   Since  only  one  structure,  DSKB,  is  currently
            supported, the contents of the frame search list are currently of no concern  to the
            user.


                   _______ __________ _____            8.6    Storage Allocation Table

            Each page of a file structure may
                1)  Be part of some file
                2)  Be mapped into the address space of some process (see 4-1)
                3)  Be defective

            On each structure is a file called (SYS)SAT.SYS (SAT standing for Storage Allocation
            Table).  The file contains two bits for every disk page:
                1)  The Mapped bit (or M-bit), which is set if the page is  currently mapped
                    into some process's address space
                2)  The File bit (or F-bit),  which is set if the  page is bad, or if  it is
                    currently part of a file


                   ____ ____________            8.7    File Organization

            A directory entry  for a file  points to a  "retrieval information block"  (RIB) for
            that file.  The  RIB contains data about  the protection, ownership, size,  etc., of
            the the file, and a number of "retrieval pointers".

            If the file is not too large (about 300 pages), the retrieval pointers point  to the
            disk pages containing the actual data of the file.

            If the file is extremely large,  the retrieval pointers in the "prime RIB"  point to
            "secondary RIB"  (or "spare  RIB") pages  which in  turn contain  retrieval pointers
            which point to the data pages.

            Storage  for  a  file  is  always  allocated  in  units  of  pages,   although,  for
            compatibility with older monitors, many numbers are given in "blocks"  of 200(octal)
            words.   There  is  also no  preallocation  of  storage to  the  file,  although the
            appearance of the old preallocation system is maintained.















                                                    8-5


      Disk I/O                                 8                          YAMM edition 2.0


             ____ ______ __________      8.8    File Access Protection

      A frame is said  to be a (nondirectory) file's  "owner" if that frame's  AUN matches
      the file's PPN in both halves, or  if the right half of the frame's PPN  matches the
      right  half of  the  file's PPN.   A  frame which  is not  the  owner of  a  file is
      considered to be an the same project as the file if the left half of its PPN matches
      the left half of the file's PPN.

      Each (nondirectory) file has a 9-bit "protection code" associated with it.  The code
      consists of three 3-bit fields:
          1)  The left 3 bits are used when the accessor is the file's owner
          2)  The middle 3 bits are used when the accessor is not the file's owner but
              is in the same project as the file
          3)  The right 3 bits are used when neither is the case
      Each of the three 3-bit protection codes  can take a value from 0 through 7,  with 7
      providing  the  greatest  protection  (least access).  The  codes  are  described in
      Table 8-7 .

      The owner of a file can always change its protection with a RENAME.

               _______      8.8.1    License

      A process having Read File (RF) license gets Read access to any (nondirectory) file;
      a process having Write File (WF) license gets All access.

      A process having Home File (HF) license gets Read access to all (nondirectory) files
      whose project number match its own; a process having Write Project (WP) license gets
      All access.

      A  process having  Jacct (JL)  license gets  All access  to any  file in  the stream
      accounting UFD.

      A process  having Home File  (HF) license whose  FPN matches a  file's PPN  gets the
      maximum of  its normal  access to  that file  and the  access it  would have  if its
      programmer number matched the file's.

































                                              8-6


            July 3, 1980                             8                                  Disk I/O


                                                 _____ ___                                                  Table 8-7 
                                           ____ __________ _____                                           File Protection Codes


            name   code  access

            FP.NO  7     No access.  For the file's owner, this is equivalent to FP.LK.
            FP.LK  6     Lookup access.  The various attributes of the file that are stored in
                         its RIB can be read (with LOOKUP), but the data itself cannot.
            FP.RUN 5     Run access.  All access permitted by FP.LK is possible. In addition,
                         the RUN and RUNSEG UUOs and the RUN command can execute the contents of
                         this file as a program, but the contents cannot otherwise be read.
            FP.RD  4     Read access.  All access permitted by FP.RUN is possible. In addition,
                         the data in the file can be read.
            FP.AP  3     Append access.  All access permitted by FP.RD is possible. In addition,
                         output can be done to blocks past the current end-of-file (that is, the
                         file can be expanded with new data, but the data already in it cannot
                         be altered).
            FP.UPD 2     Update access.  All access permitted by FP.AP is possible. In addition,
                         the data in the file can be read (by opening the file in update mode)
                         and the file's attributes and name can be read, but the file cannot be
                         truncated and its protection cannot be changed.
            FP.CP  1     Change-protection access.  All access permitted by FP.UPD is possible.
                         In addition, the file's protection and attributes can be changed, and
                         the file can be truncated or superseded (but not deleted).
            FP.ALL 0     All access.  All access permitted by FP.CP is possible. In addition,
                         the file can be deleted.


                     ____ _____ ____ ____            8.8.2    Disk Files with PIDs

            A file may be marked with a PID, making it available for special access by a process
            running with the same PID.  The special access/protection mechanisms  made available
            by PIDs are discussed fully on 9-1.


                   _________ ______ __________            8.9    Directory Access Protection

            A  frame  is said  to  be  a directory's  "owner"  if the  frame's  AUN  matches the
            directory's file name.  A frame which is not the owner of a directory  is considered
            to be  in the same  project as  the directory if  the left half  of the  frame's PPN
            matches the left half of the directory's PPN.

            Each directory has a 9-bit protection code asscciated with it, which is  broken down
            into three 3-bit fields  in the same way as  the file protection code.   The project
            and programmer numbers of  a directory are the left  and right halves of  its "name"
            (since its PPN is always 1,,1).

            Each of the three bits of a directory's protection code controls a  different access
            and the three can be set in any combination.  The bits are shown in Table 8-8 .

                     _______            8.9.1    License

            A process having Jacct (JL) or Write Absolute (WA) license can access  any directory
            as if  it were  a nondirectory  file with  All access.   (This includes  reading and
            writing it directly).

            A process having Write  File (WF) license can  change the protection of  a directory
            with RENAME.

            A process having Home File (HF)  license whose FPN matches the directory's  PPN gets
            the maximum of its  normal access to that directory  and the access it would  if its
            programmer number matched the directory's.





                                                    8-7


      Disk I/O                                 8                          YAMM edition 2.0


                                           _____ ___                                            Table 8-8 
                                   _________ __________ ____                                   Directory Protection Bits


      name     bit   access

      DP.LK    4     Lookup access.  The accessor can perform LOOKUPs on files in this
                     directory.
      DP.CR    2     New files access.  The accessor can create new files in this
                     directory.
      DP.RD    1     Read access.  The accessor can LOOKUP this directory and obtain the
                     information stored in its RIB; it can also read the directory's
                     entries using the .CHUFD UUO. It cannot read the directory as a file.



              ____ _________      8.10    File Selection

      The basic operations relating to file selection are:
          1)  LOOKUP;  Look  up an  existing  file, read  its  RIB data,  and  make it
              available for input.
          2)  CREATE; Create a new file of zero length, set its initial RIB  data, and
              make it  available for  input.  When  it is  closed, delete  the current
              directory  entry for  the file  if there  is one  and make  a  new entry
              pointing to the file being closed.
          3)  SUPERSEDE;   Create  a   new  file   of  zero   length  to   replace  an
              identically-named existing  file, set its  initial RIB  data (optionally
              inheriting values  from the  existing file), and  make it  available for
              input and output.  When the  file is closed, delete the  directory entry
              for the file if there still is one and make a new entry pointing  to the
              file being closed.
          4)  UPDATE; Look up an  existing file, read (and optionally  modify elements
              of) its RIB data,  and make it available  for input and output.   A file
              cannot be selected for single-user update unless there are  no processes
              currently updating (in  single or multiple user  mode) the file;  once a
              file is selected for single-user update, no process can select that file
              for updating (in either mode) until it is closed.
          5)  UPDATE (multiple-user); Look up  an existing file, read  (and optionally
              modify elements of)  its RIB data, and  make it available for  input and
              output.   A file  cannot be  selected for  multiple-user update  if some
              process is currently updating the file in single-user mode; once  a file
              is selected for  multiple-user update, no  process can select  that file
              for single-user update until it is closed.
          6)  RENAME; Change the name, extension,  directory, or other RIB data  of an
              existing file.
          7)  DELETE; Delete an existing file.
      There are fewer UUOs than operations.  The appropriate UUOs or UUO sequences for the
      above operations are
          1)  LOOKUP; Execute a LOOKUP UUO.
          2)  CREATE; Execute an ENTER UUO.
          3)  SUPERSEDE; Execute an ENTER UUO.
          4)  UPDATE  (single-user); Execute  a LOOKUP  UUO followed  by an  ENTER UUO
              specifying the same file.
          5)  UPDATE (multiple-user); Execute a LOOKUP UUO followed by a .CHMEN CHANIO
              specifying the same file name.
          6)  RENAME; Execute a RENAME UUO specifying the new data.
          7)  DELETE; Execute a RENAME UUO specifying a 0 filename.











                                              8-8


            July 3, 1980                             8                                  Disk I/O


                      ____ _____ ___________            8.10.1    File State Transitions

            When the basic operations listed above  are performed on a file, its  state changes.
            The monitor keeps  track of the state  of every file in  the system, and  allows the
            basic  operations  to be  performed  only in  accordance  with  the state-transition
            diagram shown in Table 8-9 .


                                                 _____ ___                                                  Table 8-9 
                                     ____ ______ _____ __________ _____                                     File Access State Transition Rules



                    File Access State Transition Rules

            #                                OPERATION
                #
                    #       LOOKUP  ENTER   1UPD    *UPD    RENAME
            STATE       #
            ---------------------------------------------------------
            Single Creator  FNF     FBM     FNF     FNF     FNF

            Exists, 0 Users OK      SUP     OK      OK      OK

            N Readers       OK      SUP     OK      OK      OK

            N Readers+*UPD  OK      FBM     FBM     OK      FBM

            N Readers+1UPD  OK      FBM     FBM     FBM     FBM

            N Readers+SUP   OK      FBM     FBM     FBM     FBM

            *UPD = Simultaneous Update including updaters via channels
                    (using !CHMEN) and via maximally-writeable 
                    mapped file pages
            1UPD = Single Update (ENTER and !CHENT only)
            SUP = Supercede
            FBM = "FILE BEING MODIFIED" error from UUO
            FNF = "FILE NOT FOUND" error from UUO

            After a file is successfully superceded, all old users
            of channels and pages continue to use the obsolete file
            as if nothing had happened.  New requests for operations 
            on the filename will deal with the new file only.  The 
            storage belonging to the obsolete file is returned to the 
            system only when the last user of the obsolete file closes 
            his channel to it or unmaps his last page from it.


                      ________ ______            8.10.2    Argument Blocks

            The LOOKUP  UUO (op code 076, pg. 8-17),  ENTER UUO (op code 077,  pg. 8-16), .CHMEN
            UUO (CHANIO fn 41,  pg. 8-16), and  RENAME UUO (op code 055,  pg. 8-17) all  take as
            their argument the  address of a  data block which is  essentially the same  for the
            four UUOs.

            There is a short and an  extended form of argument block. The two  are distinguished
            by the left half of the first word (word) 0, which must be nonzero for a short block
            and 0 for an extended block.

            The short form lookup block is described in Table 8-11  and long (extended)  form in
            Table 8-12 .  Each entry in the tables has associated with it a group  of protection
            codes which are described in Table 8-10 .





                                                    8-9


      Disk I/O                                 8                          YAMM edition 2.0


                                          _____ ____                                           Table 8-10 
                                         ________ _____                                         Argument Codes


      codemeaning

      V   This entry is a value stored in the user's argument block by the monitor.
          Whatever is contained in the argument block entry at the time of the call is
          ignored by the monitor.
      A   This entry is an argument supplied by the user. No special access to the file is
          required.
      A0  This entry is an argument supplied by the user.  If the user does not supply an
          argument (in the case of an extended block with a count that does not reach the
          argument), or if the user supplies the appropriate null argument (usually 0),
          the monitor uses a default argument instead, and stores that default into the
          user's argument block.
      F   Behaves like A0 if the process has Write Files license and like V if it does
          not.
      FJ  Behaves like A0 if the process has Write File (WF) or Jacct (JL) license, and
          like V if it does not.
      JD  Behaves like A0 if the process has Jacct (JL) license or if the file is not a
          directory, and like V otherwise.
      FP  Behaves like A0 if the process has Write Project (WP) or Write File (WF)
          license, and like V otherwise.
      S   Special protection.











































                                              8-10


            July 3, 1980                             8                                  Disk I/O


                                                _____ ____                                                 Table 8-11 
                                             _____ ______ _____                                             Short Lookup Block


            Wd  Bits   L  CS U  R   Description
            0          A  A  A  A   File name (in SIXBIT).
                                    When selecting a nondirectory file, the SIXBIT file name;
                                    when selecting a directory file, the ppn; when deleting a
                                    file with RENAME, a 0.
            1   0-17   A  A  A  A   File extension (in SIXBIT).
                                    When selecting a directory, the extension is SIXBIT /UFD/.
                18-35  V  -  V  -   LOOKUP and UPDATE clear this field.
                18     -  V  -  -   ENTER sets this bit if the file already existed (SUPERSEDE)
                                    and clears it if it did not (CREATE).
                20-21  V  A0 A0 A0  Creation date high-order bits.
                                    (see word 2, bits 24-35)
                22-35  V  A0 A0 A0  Access date (in days since 1/1/64 GMT).
                                    CREATE and SUPERSEDE use the current date if this field is 0
                                    or a date in the future.
                                    UPDATE and RENAME use the current date if this field is 0.
                18-35  V  V  V  V   File Selection Error Code.  If LOOKUP, ENTER or RENAME
                                    fails, the code from Table 8-19  is returned here.
            2   0-8    V  A0 V  A0  Protection code.
                                    CREATE and SUPERSEDE use this field if either it or the data
                                    mode field (below) is nonzero; otherwise, CREATE uses 051
                                    for directories and 750 for files, and SUPERSEDE uses the
                                    original protection.
                                    RENAME uses this field if word 2 is nonzero; otherwise it
                                    retains the original protection.
                9-12   V  A0 V  A0  Data mode.
                                    CREATE and SUPERSEDE use this field if either it or the
                                    protection field (above) is nonzero; otherwise, CREATE uses
                                    the mode the channel is open in; and SUPERSEDE retains the
                                    original mode.
                                    RENAME uses this field if word 2 is nonzero; otherwise it
                                    retains the original data mode.
                13-23  V  A0 A0 A0  Creation time (minutes since midnight GMT).
                                    (see word 2, bits 24-35)
                24-35  V  A0 A0 A0  Creation date low-order bits (in days since 1 January 1964).
                                    CREATE and SUPERSEDE use both the creation days and minutes
                                    field if either is nonzero; otherwise, they use the current
                                    day and minutes.  They will also use the current day if the
                                    day specified is in the future.
                                    UPDATE works the same but accepts future days.
                                    RENAME uses both the creation days and minutes if word 2 is
                                    nonzero; otherwise it retains the original values.
            3          A0 A0 A0 A0  PPN. This can be supplied in any of the forms:
                                    0 (or a negative word): the current process's PPN
                                    0,,[SIXBIT /username/]: the AUN of the specified (two-word)
                                    username
                                    project number,,programmer number: (directly)
                0-17   V     V      LENGTH.
                                    LOOKUP and UPDATE set this field to -file size in words if
                                    the file contains fewer than 2^17 words and file size in
                                    blocks otherwise.













                                                    8-11


      Disk I/O                                 8                          YAMM edition 2.0


                                          _____ ____                                           Table 8-12 
                                     ________ ______ _____                                     Extended Lookup Block


      Name     wd  bits   L  CS   U  R   Description

               0   19     -  -    A  A   If 1, RENAME and UPDATE will interpret .RBALC as
                                         being in units of words rather than pages, and a
                                         .RBALC of 0 will truncate the file to length 0
                                         rather than retaining its original length.  (The
                                         .RBALC value returned to the user is always in
                                         units of blocks, regardless of the setting of
                                         this bit).

               0   20     A  -    -  -   If 1, LOOKUP will grant access if .RBPID matches
                                         the PID of the caller.  If 0, LOOKUP will grant
                                         access according to the conventional protection
                                         system.  See 9-2.

                   27-35  A  A    A  A   Word count. Must be > 3.

      .RBPPN   1          A0 A0   A0 A0  PPN. This can be supplied in any of the forms:
                                         0 (or a negative word): the current process's PPN
                                         0,,[SIXBIT /username/]: the AUN of the specified
                                         (two-word) username
                                         project number,,programmer number: (directly)

      .RBNAM   2          A  A    A  A   File name (in SIXBIT).  the SIXBIT file name;
                                         when selecting a directory file, the ppn; when
                                         deleting a file with RENAME, a 0.

      .RBEXT   3   0-17   A  A    A  A   File extension (in SIXBIT).
                                         When selecting a directory, the extension is
                                         SIXBIT /UFD/.

                   18     -  V    -  -   ENTER sets this bit if the file already existed
                                         (SUPERSEDE) and clears it if it did not (CREATE).

                   20-21  V  A0   A0 A0  Creation date high-order bits.
                                         (see .RBPRV, bits 24-35)

                   22-35  V  A0   A0 A0  Access date (in days since 1/1/64 GMT).
                                         CREATE and SUPERSEDE use the current date if this
                                         field is 0 or a date in the future.
                                         UPDATE and RENAME use the current date if this
                                         field is 0.

                   18-35  V  V    V  V   Error Code.  If LOOKUP, ENTER, or RENAME fails,
                                         the file selection error code from Table 8-19  is
                                         stored here.

      .RBPRV   4                         Privilege word.

                   0-8    V  A0   V  A0  Protection code.
                                         CREATE and SUPERSEDE use this field if either it
                                         or the data mode field (below) is nonzero;
                                         otherwise, CREATE uses 051 for directories and
                                         750 for files, and SUPERSEDE uses the original
                                         protection.
                                         RENAME uses this field if .RBPRV is nonzero;
                                         otherwise it retains the original protection.

                   9-12   V  A0   V  A0  Data mode.
                                         CREATE and SUPERSEDE use this field if either it
                                         or the protection field (above) is nonzero;
                                         otherwise, CREATE uses ACSII (0) and SUPERSEDE
                                         retains the original mode.

                                              8-12


            July 3, 1980                             8                                  Disk I/O

            Name     wd  bits   L  CS   U  R   Description
                                               RENAME uses this field if .RBPRV is nonzero;
                                               otherwise it retains the original data mode.

                         13-23  V  A0   A0 A0  Creation time (minutes since midnight GMT).
                                               (see .RBPRV, bits 24-35)

                         24-35  V  A0   A0 A0  Creation date low-order bits (in days since 1
                                               January 1964).
                                               CREATE and SUPERSEDE use both the creation days
                                               and minutes field if either is nonzero;
                                               otherwise, they use the current day and minutes.
                                               They will also use the current day if the day
                                               specified is in the future.
                                               UPDATE works the same but accepts future days.
                                               RENAME uses both the creation days and minutes if
                                               .RBPRV is nonzero; otherwise it retains the
                                               original values.

            .RBSIZ   5          V  V    V  V   File size (in words).

            .RBVER   6          V  A    A  A   Not used by the monitor.

                         0-17                  UUN of the programmer who last changed the file.

                         18-35                 Version number of the file.

            .RBFUT   7          V  A    A  A   Not used by the monitor.

            .RBEST   10         V  A    A  A   Estimated file size (in blocks).
                                               (see .RBALC, below)

            .RBALC   11         V  A0   A0 A0  Allocated storage (in blocks).
                                               UPDATE and RENAME will truncate the file if
                                               supplied a .RBALC argument which is > 0 but less
                                               than the file's current size.  For the purposes
                                               of truncation, the argument can also be supplied
                                               in units of words (see word 0, bit 19).
                                               ENTER and RENAME store the larger of this
                                               argument and the last value stored as .RBEST into
                                               the RIB's .RBALC field.
                                               LOOKUP, ENTER and RENAME return the larger of the
                                               file size and the last value stored as into the
                                               .RBALC field of the RIB.

            .RBPOS   12         V  A    A  A   Not used by the monitor.

            .RBFT1   13         V  A    A  A   Not used by the monitor.

            .RBLIC   14                        File license word.

                         0-1    V  FJ   FJ FJ  Sets bits 1-2 word 3 of file's UFD entry

                         2-3    V  A    A  A   Sets bits 3-4 word 3 of file's UFD entry

                         4-7    V  FJ   FJ FJ  Sets bits 19-22 word 2 of file's UFD entry

                         4                     File dumped

                         5                     File has error

                         6                     File has a PID (for UFD's, means PID storage
                                               acct'g.)

                         8-11   V  A    A  A   Sets bits 23-26 word 2 of the file's UFD entry

                         (8)    V  A    A  A   (sets bit 23 of <status word> returned by .CHUFD
                                               UUO (CHANIO fn 33, pg. 8-3)  ).

                                                    8-13


      Disk I/O                                 8                          YAMM edition 2.0

      Name     wd  bits   L  CS   U  R   Description
                                         This file is a TMP file.  LOGOUT and GFD will
                                         delete it when they execute.

                   (9)    V  A    A  A   (Sets bit 24 of <status word> returned by .CHUFD
                                         UUO (CHANIO fn 33, pg. 8-3) ).
                                         By MAGNUM convention this bit is set if the file
                                         was created in JIS-8 Katakana mode.  This
                                         convention is purely a user-program one and is
                                         not enforced or supported by the monitor.)

                   12-17  V  A0   A0 A0  Creation seconds (since the last minute).
                                         RENAME uses this field if it is nonzero and
                                         retains the original creation seconds otherwise.
                                         ENTER uses this field if it is nonzero;
                                         otherwise, it uses the current time if it has
                                         defaulted the creation days and minutes and 0 if
                                         it has not.

                   18-35  V  S    S  S   License bits.
                                         (see 8-20)

      .RBMTA   15         V  F    F  F   Not used by the monitor.

      .RBDEV   16         V  V    V  V   0.

      .RBSTS   17         V  S    S  S   Status bits.
                                         If the process has Write File (WF) or JL license,
                                         ENTER and RENAME set these bits to the argument,
                                         except the "is-directory" bit (bit 18) which is
                                         maintained by the monitor.
                                         If the process does not have Write File (WF) or
                                         JL license, ENTER and RENAME AND argument bits
                                         27-35 into the RIB entry and leave the other bits
                                         alone.

                   0                     (UFDs only) Set by LOGIN and cleared by LOGOUT
                                         (to determine if the system crashed or was
                                         reloaded without logging all the users off)

                   9                     (UFDs only) Set when the monitor detects a
                                         checksum error for some file in this directory.

                   10                    (UFDs only) Set when the monitor detects a hard
                                         write error for some file in this directory.

                   11                    (UFDs only) Set when the monitor detects a hard
                                         read error for some file in this directory.

                   14                    (UFDs only) Set when FAILSAFE detects a bad file
                                         in this directory while restoring from magtape.

                   15                    (UFDs only) Set when the damage-assessment
                                         program finds a bad file in this directory.

                   18                    1 if this file is a directory.

                   19                    1 if this file or directory may not be deleted.

                   21                    1 if FAILSAFE may not delete this file or
                                         directory.

                   26                    1 if the file's PPN = frame PPN (GFD'd directory)
                                         at the time of creation.

                   27                    Set when the monitor detects a checksum error for
                                         this file or directory.


                                              8-14


            July 3, 1980                             8                                  Disk I/O

            Name     wd  bits   L  CS   U  R   Description
                         28                    Set when the monitor detects a hard write error
                                               for this file or directory.

                         32                    Set when FAILSAFE finds this file bad while
                                               restoring from magtape.

                         35                    Set when the damage-assessment program finds this
                                               file or directory bad.

            .RBELB   20         V  V    V  V   Error logical block.
                                               The block number of the first block found bad in
                                               this file.

            .RBXT1   21         V  V    V  V   0.

            .RBQTF   22         V  JD   JD JD  Logged-in disk quota.
                                               For UFDs, the maximum number of data and RIB
                                               pages that can be stored in this directory while
                                               the user is logged-in.

            .RBQTO   23         V  JD   JD JD  Logged-out disk quota.
                                               For UFDs, the maximum number of data and RIB
                                               pages that can be stored in this directory while
                                               the user is logged-out.

            .RBMXA   24         V  JD   JD JD  For UFDs, supllying a nonnegative argument causes
                                               .RBMXA to be set to .RBUSD and the old value of
                                               .RBMXA returned; supplying a negative argument
                                               causes the value last stored to be returned.

            .RBUSD   25         V  JD   JD JD  For UFDs, supplying a nonnegative argument causes
                                               .RBUSD to be set and returns its old value;
                                               supplying a negative argument causes the value
                                               last stored to be returned.

            .RBAUT   26         V  S    S  S   Author.
                                               ENTER and RENAME will use the argument if the
                                               process has Write File (WF) license.
                                               CREATE and SUPERSEDE set this field of the RIB to
                                               the process's PPN if they find it 0 when creating
                                               or superseding the file.

            .RBUNM   27         V  JD   JD JD  Username. 2 words

                     30         V  JD   JD JD  Username, 2nd word (SIXBIT)

            .RBTRU   31         V  JD   JD JD  Not used by the monitor.

            .RBXT2   32         V  JD   JD JD  Not used by the monitor.

            .RBALP   33         V  V    V  V   Allocated pages.
                                               The number of data and RIB pages actually
                                               allocated for this file.

            .RBSNM   34         V  V    V  V   The number of spare RIBs in this file.

            .RBPJC   35         V  FP   FP FP  Project-code information block.  Same format as
                                               argument block to CHPRJ UUO (CALLI -61, pg. 2-8)

                     36                        PJC next word

                     37                        PJC next word

            .RBPID   40         V  *    *  *   Processor ID
                                               Behavior of .RBPID is complex and depends on the
                                               license and PID of the caller.  (see 9-1).


                                                    8-15


      Disk I/O                                 8                          YAMM edition 2.0


                ______ ______ ____ ___ ______ ___ ____ ____      8.10.3    ENTER: select file for output (op code 077)
                _______ ______ ____ ___ ______ _______ __ __      8.10.3    .CHENT: select file for output (CHANIO fn 5)
                _______ ______ ____ ___ ____________ ______ _______ __ ___      8.10.3    .CHMEN: select file for multi-update output (CHANIO fn 41)

              ENTER   channel, addr
                error return  ; c(<addr>+1 right) :=
                              ; file selection error code
                              ; (see 8-18)
              normal return

              MOVE    ac, [.CHENT or .CHMEN,,channel]
              CHANIO  ac,
                error return  ; c(<addr>+1 right) :=
                              ; file selection error code
                              ; (see 8-18)
              normal return

      where <addr> points to a short or extended ENTER block
              (see above)

      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.  If the device is not a disk, just skip-return.

      If the output side of the channel  is open, perform a CLOSE operation on  the output
      side.  Clear the end-of-file and error bits of the file status bits.

      If this is a .CHMEN call and no LOOKUP has been done on the channel, take  the error
      return (.CHMEN can only be used for update, not for create or supersede).

      If a LOOKUP has already been done on the channel, take the error return if  the file
      being specified does not match that already looked-up; otherwise, proceed as follows
      (UPDATE):

          If the process does not have  at least Append access to the file  and Lookup
          access to the directory, take the error return.

          If the file is currently selected in single-update mode by some  process, or
          if it is selected  for multiple-update and this  is not a .CHMEN  call, take
          the error return.

          If it  has only  Append access,  fill in the  ENTER block  and set  the file
          attributes  appropriately,  but  do not  process  any  extended  ENTER block
          attributes past word  5 (.RBSIZ).  Make  the file availabble  for subsequent
          output operations if they are to blocks past the end-of-file.

          If it has at least Update access,  fill in the ENTER block and set  the file
          attributes appropriately, but ignore any attempt to truncate the file (using
          .RBALC) if  the process does  not have at  least Change  protection license.
          Make the file  available for output operations  (which will modify  the file
          "in place").

      If a LOOKUP has  not already been performed, search  for the specified file.   If it
      already exists, proceed as follows (SUPERSEDE):

          If the process does not  have at least Change-protection access to  the file
          and Lookup access to the directory, take the error return.

          Othrwise, create a new version of the file, with the protection specified by
          <prot>, and fill in the ENTER block appropriately.  Make the  file available
          for input and output.

      If the file was not already looked-up and does not already exist, proceed as follows
      (CREATE):

          If the process does not have Create access to the directory, take  the error
          return.


                                              8-16


            July 3, 1980                             8                                  Disk I/O


                Otherwise, create a new file, with protection <prot>, and fill in  the ENTER
                block appropriately.  Make the file available for input and output.

                      _______ ______ ____ ___ _____ ___ ____ ____            8.10.4    LOOKUP: select file for input (op code 076)
                      ______ ______ ____ ___ _____ _______ __ __            8.10.4    .CHLK: select file for input (CHANIO fn 4)

                    LOOKUP  channel, addr
                      error return  ; c(<addr>+1 right) :=
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

                    MOVE    ac, [.CHLK,,channel]
                    CHANIO  ac, addr
                      error return  ; c(<addr>+1 right) :=
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

            where <addr> points to a short or extended LOOKUP block
                    (see above)

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device is not a disk, just skip-return.

            If the input  side of the channel  is open, perform a  CLOSE operation on  the input
            side.  Clear the end-of-file and error bits of the file status bits.

            If the process does not have at least Lookup access to the file and Lookup access to
            the directory, or if the file does not exist, take the error return.

            Fill in the LOOKUP block with  the appropriate information from the file's  RIB.  If
            the  process has  at least  Read access  to the  file, make  the file  available for
            subsequent input operations.

                      _______ ______ __ ______ _ ____ ___ ____ ____            8.10.5    RENAME: rename or delete a file (op code 055)
                      _______ ______ __ ______ _ ____ _______ __ ___            8.10.5    .CHREN: rename or delete a file (CHANIO fn 11)

                    RENAME  channel, addr
                      error return  ; c(<addr>+1 right) :=
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

                    MOVE    ac, [.CHREN,,channel]
                    CHANIO  ac, addr
                      error return  ; c(<addr>+1 right) :=
                                    ; file selection error code
                                    ; (see section 8-18)
                    normal return

            where <addr> points to a short or extended RENAME block
                    (see above)

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device is not a disk, just skip-return.

            If no  file has ever  been selected on  the channel, take  the error-return.  (It is
            possible, though probably an  error, to do a LOOKUP  CLOSE RENAME or an  ENTER CLOSE
            RENAME and have the RENAME refer to  the file that was selected even though  a CLOSE
            was done).

            If the output side of the channel  is open, perform a CLOSE operation on  the output
            side.

            If <filename> is 0, proceed as follows (DELETE):


                                                    8-17


      Disk I/O                                 8                          YAMM edition 2.0


          If the  selected file  (the file  last selected  on <channel>)  is currently
          selected for output by any process, or if the current process does  not have
          All access to  it; or if the  file is a directory  and one or more  files in
          that directory are currently open, take the error return.

          Otherwise, remove the file's directory entry, and mark the file for deletion
          (it will be deleted when the last of its readers has closed it).

      If <filename> is not 0, perform the following (RENAME):

          If the  selected file  (the file  last selected  on <channel>)  is currently
          selected for output by some process,  or if it is marked for  deletion, take
          the error return.

          If the process does  not have at least Update  access to the file,  take the
          error return.  Otherwise,  set the name of  the file to <filename>,  and, if
          <extension> is not 0, the extension to <extension>.

          If  <ppn descriptor>  differs from  that of  the selected  file,  proceed as
          follows:

              If  the process  does not  have All  access to  the file  and Create
              access  to  the  new  directory  (the  direcory  specified  by  <ppn
              descriptor>),  or if  the new  file already  exists, take  the error
              return.

              Otherwise,  move  the  file  from  its  current  directory  to  that
              specified by <ppn descriptor>.

          If the process is attempting to change any other oo the file's  RIB entries,
          make the changes if  it has at least  Change protection access to  the file,
          and take the error return otherwise.

      Perform a CLOSE operation on <channel> and skip-return.

                ____ _________ _____ _____      8.10.6    File Selection Error Codes

      The LOOKUP, ENTER, RENAME, RUN, RUNSEG, GETSEG and equivalent CHANIO  functions, and
      CHANIO fn .CHMEN all return error codes from Table 8-19 .





























                                              8-18


            July 3, 1980                             8                                  Disk I/O


                                                _____ ____                                                 Table 8-19 
                                         ____ _________ _____ _____                                         File Selection Error Codes



            These error codes are returned in bits 18-35 of word 1 of the Short Lookup Block,
            and word .RBEXT of the Extended Lookup Block.  See Table 8-11 and Table 8-12 .

            name     code  condition

            .ERFNF   0     File Not Found.  Illegal file name (0), extended LOOKUP/ENTER/RENAME
                           block with count < 3.
            .ERIPP   1     Incorrect PPN.  The specified PPN does not exist.
            .ERPRT   2     Protection failure.
            .ERFBM   3     File being modified.  (from ENTER)
            .ERAEF   4     Already existing file.  Attempt to RENAME to an existing file name or
                           an ENTER following a LOOKUP and specifying a different file name.
            .ERISU   5     Illegal Sequence of UUOs.  RENAME where no file has been selected on
                           the device, or LOOKUP on a channel that already has an ENTER in
                           force.
            .ERTRN   6     Transmission error.  Transmission, data, or device error while
                           reading the file for a RUN, RUNSEG, or GETSEG UUO; hardware-detected
                           data or device error while reading a UFD or its RIB;
                           software-detected data inconsistency in a UFD or file RIB.
            .ERNSF   7     Not a saved file.  (from RUN, RUNSEG, GETSEG)
            .ERNEC   10    Not enough core.  (from RUN, RUNSEG, GETSEG)
            .ERDNA   11    Device not available.  (from RUN, RUNSEG, GETSEG)
            .ERNSD   12    No such device.  (from RUN, RUNSEG, GETSEG)
            .ERILU   13    (never happens)
            .ERNRM   14    No room.  No space left on the specified device or structure, or
                           process's disk quota exceeded.
            .ERWLK   15    (never happens)
            .ERNET   16    Not enough table space.  Insufficient space in monitor free core to
                           perform the operation.
            .ERPOA   17    (never happens)
            .ERBNF   20    (never happens)
            .ERNTR   21    (never happens)
            .ERLKM   22    (never happens)


                      _______ _ ____ ____            8.10.7    Closing a Disk File

            The CLOSE UUO  (op code 070, pg. 5-12) for a  disk device closes the  file currently
            selected on  the channel and  allows a new  file to be  selected (without  having to
            release and re-init the device).   The file name, extension, and ppn  are remembered
            until  the next  file selection  operation, however,  so the  sequence  LOOKUP CLOSE
            RENAME is permissible, though probably an error.

            On closing a file that was  open for input, the disk device-dependent  code normally
            updates  the access  date of  the  file to  the current  date.  This  action  can be
            inhibited by setting CL.ACS in the CLOSE argument.

            On closing a file that was being created or superseded, the monitor normally deletes
            the old version of the file (if  there was one) and replaces it with the  file being
            closed.  This action can be inhibited by setting CL.RST in the CLOSE argument.













                                                    8-19


      Disk I/O                                 8                          YAMM edition 2.0


                _______ ____ _______      8.10.8    Setting File License

      When a process supersedes of updates  a file which has license set  (c(.RBLIC right)
      nonzero),  the file's  license is  reduced,  if necessary,  to roughly  that  of the
      process modifying the  file.  The exact algorithm  by which ENTER computes  the file
      license (<result>) is:

          Let  <result> be  0 if  the file  is being  created, or  the  file's current
          license if it is being updated or superseded.

          If the project number (left half) of the process's PPN differs from  that of
          the file, clear Home File (HF) license from <result> unless the  process has
          Write File (WF) license, and set the read(write) privilege field of <result>
          to 0 if it was previously set to read(write) project.

          If the project numbers match but the programmer numbers (right half) do not,
          clear Home File (HF) license from <result> unless the process has Write File
          (WF) or Write Project (WP) license.

          If <result> specifies greater read(write) privilege than the current process
          has, set <result>'s  read(write) privilege field to  0.  Turn off  any other
          license bits (with the exception of Home File (HF) license) in <result> that
          are not set for the current process.

      If the ENTER is  extended, and specifies a new  set of license bits  (<want>), ENTER
      performs a further computation to obtain the license (again <result>):

          Let <max>  be the maximum  of the current  process license (minus  Home File
          (HF) license) and <result>, and let <want> be the license  argument supplied
          by the program.

          Set <result> = <want>.

          If the project number (left half) of the process's PPN differs from  that of
          the file, clear Home File  (HF) license from <result> unless  <max> contains
          Home File (HF) or Write File (WF) license, and set the read(write) privilege
          field of <result> to 0 if  it neither <want> nor <max> contain  greater than
          read(write) project.

          If the project numbers match but the programmer numbers (right half) do not,
          clear Home File (HF) license  from <result> unless <max> contains  Home File
          (HF), Write File (WF), or Write Project (WP) license.

          If <result> specifies greater read(write) privilege than <max> contains, set
          <result>'s read(write)  privilege field  to 0.  Turn  off any  other license
          bits (with the exception of Home File (HF) license) in <result> that are not
          set in <max>.

      <result> is now the license actually set for the file.


              ____ ___________      8.11    File Positioning

      The monitor maintains  for each channel  initted to a  disk device a  "file pointer"
      which  specifies  the disk  block  to be  referenced  by the  next  input  or output
      operation.

      Any process which has initted a disk device and selected a file on a channel can set
      the "file pointer" for that channel  to some relative block within the  file.  There
      are two positioning  operations, USETI and USETO  (and several variations  on each).
      USETI is normally used  before an input operation  and USETO before an  output.  The
      major differences are:
          1)  USETO requires  that an ENTER  have been done;  USETI works if  either a
              LOOKUP or ENTER has been done
          2)  USETI, if given a file position past the end-of-file, will set IO.EOF in
              the file  status bits and  set the  file pointer to  point to  the block
              after the last block of the file; USETO will expand the file out  to the
              specified block.
                                              8-20


            July 3, 1980                             8                                  Disk I/O


            USETI and USETO take as arguments a  "file block number", which is 1 to  specify the
            first block of the file.

                      _____ ___________            8.11.1    Super USETI/USETO

            A process which  has Write Absolute  (WA) or Read Absolute  (RA) license can  init a
            channel to a  disk structure or  device and then perform  a "super USETI"  or "super
            USETO" operation to set the file pointer to some block on that structure or device.

            A super  USETI or  USETO counts  as a file-selection  operation in  that i/o  can be
            performed on  a disk  device if and  only if  either a file  has been  selected with
            LOOKUP or ENTER, or the channel is in "super mode" as a result of having had a super
            USETI or USETO done on it.

            Super USETI and USETO take as arguments a "disk block number", which is 0 to specify
            the first block of the structure or device.

            A disk device channel may also be put into super mode by a .CHSMP UUO (CHANIO fn 43,
            pg. 4-6) operation. Once in super mode,  ordinary IN, OUT, INPUT and OUTPUT  UUOs or
            the .CHSMP UUO may be used to perform data access.

                      ______ ___ ____ ________ __ _____ ___ ____ ____            8.11.2    USETI: set file position by block (op code 074)
                      _______ ___ ____ _______ __ _____ _______ __ __            8.11.2    .CHUSI: set file pointer by block (CHANIO fn 6)
                      _______ ___ ____ _______ __ _____ _______ __ ___            8.11.2    .CHFSI: set file pointer by block (CHANIO fn 27)
                      _______ ___ ____ _______ __ ____ _______ __ ___            8.11.2    .CHPSI: set file pointer by page (CHANIO fn 31)

                    USETI   channel, block
                      or
                    MOVE    ac, [.CHUSI,,channel]
                    CHANIO  ac, block
                      or
                    MOVE    ac, [.CHFSI,,channel]
                    CHANIO  ac, [lblock]
                      or
                    MOVE    ac, [.CHPSI,,channel]
                    CHANIO  ac, [page]
                    only return

            where <block> is a halfword file block number
                    for a normal USETI,
                    or the address of a fullword disk block number
                    for a super USETI

            and <lblock> is a fullword file (normal USETI)
                    or disk (super USETI) block number

            and <page> is a fullword file (normal USETI)
                    or disk (super USETI) page number

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Wait for the device  to become inactive.  If  buffered input is being  performed and
            the monitor has read ahead of  the program, discard the read-ahead buffers.   If the
            device is not a disk, return.

            If no file has been selected on the channel, perform the following (super USETI):

                If  the process  does not  have Read  Absolute (RA)  or Write  Absolute (WA)
                license, just set IO.BKT in the file status bits; otherwise, proceed:

                If "DSK"  or some  disk structure  was initted,  interpret the  block (page)
                number as a logical block (page) within the structure; if a  particular unit
                was initted,  interpret it  as an  absolute block  (page) number  within the
                unit.  If the  number is out  of range, just set  IO.BKT in the  file status
                bits; otherwise proceed:


                                                    8-21


      Disk I/O                                 8                          YAMM edition 2.0


          Set the file pointer  to refer to the  specified block (page), and  make the
          disk available  for subsequent input  (and output if  the process  has Write
          Absolute  (WA) license)  operations.  (The  channel will  now be  in "super"
          mode, and subsequent LOOKUPs and ENTERs will be illegal).

      Otherwise, proceed as follows (normal USETI):

          Interpret the  block (page)  number as  a relative  block (page)  within the
          file.  If it is  out of bounds, set IO.EOF  in the file status bits  and set
          the file pointer to refer to the block after the last block of the file.

      Check the  error bits (bits  18-22) of the  file status bits.   If any  are nonzero,
      cause an io-error software interrupt if the process is enabled for one.  Return.

                ______ ___ ____ ________ __ _____ ___ ____ ____      8.11.3    USETO: set file position by block (op code 075)
                _______ ___ ____ ________ __ _____ _______ __ __      8.11.3    .CHUSO: set file position by block (CHANIO fn 7)
                _______ ___ ____ ________ __ _____ _______ __ ___      8.11.3    .CHFSO: set file position by block (CHANIO fn 30)
                _______ ___ ____ ________ __ ____ _______ __ ___      8.11.3    .CHPSO: set file position by page (CHANIO fn 32)

              USETO   channel, block
                or
              MOVE    ac, [.CHUSO,,channel]
              CHANIO  ac, block
                or
              MOVE    ac, [.CHFSO,,channel]
              CHANIO  ac, [lblock]
                or
              MOVE    ac, [.CHPSO,,channel]
              CHANIO  ac, [page]
              only return

      where <block> is a halfword file block number
              for a normal USETO,
              or the address of a fullword disk block number
              for a super USETO

      and <lblock> is a fullword file (normal USETO)
              or disk (super USETO) block number

      and <page> is a fullword file (normal USETO)
              or disk (super USETO) page number

      If <channel> is not initted, abort the process and store halt status HT.IUC  for the
      frame.

      If buffered  output is  being performed  and the  program has  written ahead  of the
      monitor, start  output of all  the buffers (including  the partial  buffer currently
      being written).  Wait  for the device  to become inactive.  If  the device is  not a
      disk, return.

      If no ENTER has been done on this channel, proceed as follows (super USETO):

          If a  LOOKUP has  been done,  or if the  process does  not have  either Read
          Absolute (RA) or  Write Absolute (WA) license,  just set IO.BKT in  the file
          status bits; otherwise, proceed:

          If "DSK"  or some  disk structure  was initted,  interpret the  block (page)
          number as a logical block (page) within the structure; if a  particular unit
          was initted,  interpret it  as an  absolute block  (page) number  within the
          unit.  If the  number is out  of range, just set  IO.BKT in the  file status
          bits; otherwise proceed:

          Set the file pointer  to refer to the  specified block (page), and  make the
          disk available  for subsequent input  (and output if  the process  has write
          absolute)  operations.   (The  channel  will now  be  in  "super"  mode, and
          subsequent LOOKUPs and ENTERs will be illegal).

      Otherwise, perform the following (normal USETO):
                                              8-22


            July 3, 1980                             8                                  Disk I/O


                Interpret the  block (page)  number as  a relative  block (page)  within the
                file.  If it is out of bounds, expand the file as follows:

                    Fill in  the space (if  any) between the  end-of-file block  and the
                    last block of the page containing it with zeros.

                    Fill  in  the  space  (if  any)  between  the  page  containing  the
                    end-of-file block and the  page containing the specified  block (the
                    specified  page, in  the  case of  .CHPSO) with  "holes"  (null page
                    pointers).

                    If this is a .CHPSO UUO,

                        Create the specified page.

                    Otherwise,

                        Create the page containing the specified block, and  fill in
                        the space (if any) between its first block and the specified
                        block with zeros.

                If the file was being expanded and the monitor ran out of disk space  on its
                structure  or  the  process  exceeded  its  disk  quota,  just  set  IO.BKT;
                otherwise, set the file pointer to refer to the specified block (page).

            Check the  error bits (bits  18-22) of the  file status bits.   If any  are nonzero,
            cause an io-error software interrupt if the process is enabled for one.  Return.

                      _____ ____ __ _______ ____ ______ ____            8.11.4    SEEK: seek to current page (CALLI +56)
                      ______ ____ __ _______ ____ _______ __ ___            8.11.4    .CHSK: seek to current page (CHANIO fn 24)

                    SEEK    channel,
                    only return

                    MOVE    ac, [.CHSK,,channel]
                    CHANIO  ac,
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If the device initted is not a disk, just return.

            Otherwise, if the disk  unit containing the next page  to be read or written  on the
            channel is currently idle, issue a positioning request to prepare for the  next read
            or write, and return.


                    ______ ____ ____ ____________            8.12    Direct File Page Manipulation

            There are several operations supplied by the monitor for directly manipulating pages
            of  a file  (in  addition to  the basic  mapping  operation supplied  by  .CHMFP UUO
            (CHANIO fn 35, pg. 4-5): a  page can be  created at some point  in the file  where a
            page does not already exist; a page  can be deleted from some point in the  file; or
            two file pages can be exchanged.

            It should be noted that, to the monitor, a "file" is basically just a set  of pages.
            The file's RIB contains a map pointing to the pages making up the file, and that map
            can be thought of as being similar to a process's map.

            When a process maps a file page, it is actually just mapping into its  address space
            the disk page which  is currently pointed to by  the appropriate slot in  the file's
            RIB.  If process  A maps page  12 of the file  and process B  subsequently exchanges
            page 12 with page 13, process A will still be using the same disk page it  was using
            before, with the  result that it  will now be using  what process B  (and subsequent
            mappers) see as page 13 of the file.


                                                    8-23


      Disk I/O                                 8                          YAMM edition 2.0


      In brief, the  delete, create, and exchange  operations only affect the  RIB entries
      for the file.   They have no  effect on any of  the pages of  the file which  may be
      currently mapped by any process.

                _______ ______ ____ ____ _______ __ ___      8.12.1    .CHCFP: create file page (CHANIO fn 40)

              MOVE    ac, [.CHCFP,,channel]
              CHANIO  ac, [page]
                error return  ; <ac> := error code
              normal return

      where <error code> is a code from Table 4-19 .

      If <page> is negative, set c(<addr>) to  the page number of the page above  the last
      page of the file, and use that number as <page>.

      If no file is selected  on <channel> or if the  process has not ENTERed the  file or
      did not have at least append access to it at the time of the ENTER; or if  <page> is
      past the end-of-file and the process did not have at least update access to the file
      at the time of the ENTER; or if <page> is 0; or if page <page> already exists in the
      file, error-return.

      Otherwise, allocate a disk page, clear it to zeros, make it page <page> of the file,
      and skip-return.

      This operation will extend the length of the file if the page being created  is past
      the current end-of-file.

                _______ ______ ____ ____ _______ __ ___      8.12.2    .CHDFP: delete file page (CHANIO fn 36)

              MOVE    ac, [.CHDFP,,channel]
              CHANIO  ac, [page]
                error return  ; <ac> := error code
              normal return

      where <error code> is a code from Table 4-19 .

      If no file  has been selected on  <channel>; or if the  process has not  ENTERed the
      file or did not have  at least update access to it  at the time of the ENTER;  or if
      <page> is  <= 0 or  past the  end-of-file; or if  page <page> of  the file  does not
      exist, error-return.

      Otherwise, delete page <page> of the file and skip-return.

      This operation does  not affect the  EOF; regardless of where  in the file  the page
      lives, it  is replaced  with a "hole".   Thus the  EOF of a  file may  be at  a word
      position past that of the last real data.  I.e, it may point to a hole.   See .CHFTR
      UUO (CHANIO fn 45, pg. 8-25).

                _______ ________ ____ _____ _______ __ ___      8.12.3    .CHXFP: exchange file pages (CHANIO fn 37)

              MOVE    ac, [.CHXFP,,channel]
              CHANIO  ac, [
                      page1
                      page2
              ]
                error return  ; <ac> := error code
              normal return

      where <error code> is a code from Table 4-19 .

      If no file  has been selected on  <channel>; or if the  process has not  ENTERed the
      file or did not have  at least update access to it  at the time of the ENTER;  or if
      either <page1> or <page2> is <= 0 or past the end-of-file, error-return.

      Otherwise,  exchange  <page1>'s  entry   in  the  file's  RIB  with   <page2>'s  and
      skip-return.

                                              8-24


            July 3, 1980                             8                                  Disk I/O


                    ___________ ____ ____________            8.13    Specialized File Manipulation

            Three CHANIOs are available to fill other file control needs
                1)  .CHFTR UUO (CHANIO fn 45,  pg. 8-25) allows the  caller to move  the EOF
                    point
                2)  .CHFFI UUO (CHANIO fn 44, pg. 8-25) allows the caller to search  the RIB
                    structure of a  file for "interesting" pages:  the next "hole"  page, or
                    the next "real" page, for example
                3)  .CHMGN UUO  (CHANIO fn 34, pg. 8-26) allows  several updaters of  a file
                    to interlock with one another as they attempt to update

                      _______ ________ ____ _______ __ ___            8.13.1    .CHFTR: Truncate File (CHANIO fn 45)

                    MOVE    AC,[.CHFTR,,<channel>]
                    CHANIO  AC,LOC
                     error  return          ;ac contains error code
                    normal  return

            LOC:    <new size in words>

            Perform the  normal CHANIO checks.   If <new  size in words>  is negative,  zero, or
            greater than the current EOF; or if no file is selected on <channel> or if  there is
            a RIB error for the  file; or if the caller  has not ENTERed the file  on <channel>,
            set ac to the appropriate error code from Table 4-19 and take the error return.

            Set the file EOF to <new size in words>, and return to the system any complete pages
            which are past the new EOF.  The new EOF may lie within what was previously  a hole.
            (If the new  EOF is in  the middle of an  existing page, do  not clear out  the data
            within that page past the EOF).  Take the normal return.

                      _______ ____ _____ ___________ ____ _______ __ ___            8.13.2    .CHFFI: Find First Interesting Page (CHANIO fn 44)

                    MOVE    AC,[.CHFFI,,<channel>]
                    CHANIO  AC,LOC
                     error return   ;ac contains error code
                    normal return

            LOC:    <file page number>      ;for beginning of search
            LOC+1   <condition of interest>


            <condition of interest> codes are as follows:
            0       find first "hole" at or after <file page number>
            1       find first real page at or after <file page number>

            error codes are taken from Table 4-19

            Perform the usual CHANIO checks.  If no file exists on <channel>, or if the  file is
            LOOKUP-ONLY, or if the  file has a RIB error,  or if <file page number  is negative,
            zero or greater than the file EOF page, or if <condition of interest> is not 0 or 1,
            set AC to the appropriate error code and take the error return.

            Scan  the RIB  for  the first  file page  beginning  with <file  page  number> which
            satisfies <condition of interest>.   Store the number of  this page at LOC  and take
            the normal return.













                                                    8-25


      Disk I/O                                 8                          YAMM edition 2.0


                _______ __________ ________________ ___ _______ __ ___      8.13.3    .CHMGN: manipulate update-interlock bit (CHANIO fn 34)

              MOVE    AC,[.CHMGN,<channel>}]
              CHANIO  AC,LOC
               error return   ;ac unchanged
              normal return

      LOC:    <function>
      LOC+1   data returned here


      Perform the usual CHANIO checks.

      If the device on <channel> is not a disk device, take the normal return.

      If <function> is not an item from the list below,, take the error return.

      function code           action
      0,,1            updater wants to clear flag in all DDB's
                      for this file
      1,,1            updater wants to set flag in all DDB's
      0,,2            read & clear flag in own DDB
      0,,3            is the file on <channel> being updated?
      0,,4            is there another reader of this file?
      0,,5            read simultaneous update information


      Function  1  allows  multiple readers  &  writers  of a  file  to  communicate their
      intentions among one another.   The left half of  <function> must be zero  (to clear
      the flag for all other DDBs) or one (to set it).  If the lh is not 0 or 1,  take the
      error return.  If  the caller does  not have the file  on <channel> in  update mode,
      take the error return.   Set or clear the interlock  flag in all DDBs for  the file.
      Take the normal return.

      Function 2 allows the caller to see if he has been interlocked.  Set LOC+1 to 0 or 1
      according to whether the flag is 0 or 1.  Take the normal return.

      Function 3 allows the caller to see  if the file is being updated by anyone.   If no
      file exists on <channel>,  take the error return.  Set  LOC+1 to 0 if not  in update
      mode, 1 if in update mode. Take the normal return

      Function 4 allows an updater to see if other readers exist.  If the caller  does not
      have the file on <channel> in update mode, take the error return.  If  other readers
      exist, set LOC+1 to 1; otherwise set it to 0; take the normal return.

      Function 5 lets simultaneous  updaters know about the file.   If no file is  open on
      <channel>, take the error return. Set LOC+1 to:

      LOC+1:  <number of updating channels>,,<pages mapped max-write>


              _______ ___________      8.14    Reading Information
















                                              8-26


            July 3, 1980                             8                                  Disk I/O


                      ____ _______________            8.14.1    Disk Characteristics

            A program can obtain the characteristics  of a disk device or class of  disk devices
            with  the DSKCHR  UUO.   The UUO  returns  a data  block  of the  form  described in
            Table 8-28 .

            The <name> (word 0) is supplied by the program and can be in one of seven forms:
                1)  the generic device DSK or a logical name ASSIGNed to it
                2)  a structure name (DSKB))
                3)  a unit within a structure (DSKB1)
                4)  a controller class (BP)
                5)  a controller (BPA)
                6)  a unit within a controller (BPA1)
            The UUO also returns a word of status bits described in Table 8-29 .

                        _______ ____ ____ _______________ ______ ____            8.14.1.1    DSKCHR: read disk characteristics (CALLI +45)

                    MOVE    ac, [length,,addr]
                    DSKCHR  ac,
                      error return
                    normal return

            where <addr> points to a DSKCHR data block
                    as described below, whose first entry
                    (word 0) the program has filled in
                    with a device name

            Search for a disk unit satisfying <name>:
                1)  generic DSK: Use the first unit of the first structure on the system
                2)  structure: Use the first unit of the structure
                3)  unit within structure: Use the specified unit
                4)  controller class:  Use the  first unit  on the  first controller  of the
                    class in the system
                5)  controller: Use the first unit on the controller
                6)  unit within controller: Use the specified unit
            If no such device is found, take the error return.

            Otherwise, set c(<ac>) to the DSKCHR Status Bits (see TabRef(TAB4)) for  the device,
            store  up to  <length> words  of data  from the  device into  the DSKCHR  Data Block
            starting at <addr> (see TabRef (TAB3) ), and skip-return.




























                                                    8-27


      Disk I/O                                 8                          YAMM edition 2.0


                                          _____ ____                                           Table 8-28 
                                       ______ ____ _____                                       DSKCHR Data Block


      word   contents

      0      device name argument (see DSKCHR UUO (CALLI +45, pg. 8-27))
      1      # blocks left in quota
      2      # pages left on the structure
      3      # pages left on the unit
      4      SIXBIT structure name
      5      unit characteristics word
      6      # pages on the unit
      7      (unused)
      10     (unused)
      11     # SAT blocks on the unit
      12     (unused)
      13     (unused)
      14     logical name within structure (e.g., DSKB1)
      15     unit name within controller (e.g., BPA1)
      16     home block id
      17     (unused)
      20     left half: logical page number of unit's first HOM page
             right half: logical page number of unit's second HOM page
      21     left half: logical page number of unit's first BAT page
             right half: logical page number of unit's second BAT page
      22     left half: number of pages in a unit's bootstrap area
             right half: logical page number of start of bootstrap area








































                                              8-28


            July 3, 1980                             8                                  Disk I/O


                                                _____ ____                                                 Table 8-29 
                                             ______ ______ ____                                             DSKCHR Status Bits


            name     bits  contents

            DC.OFL   1B1   unit offline
            DC.HWP   1B2   unit hardware write-protected
            DC.USF   1B6   unit unsafe
            DC.MSB   1B9   unit has multiple SAT blocks
            DC.TYP   7B17  type of <name> passed to DSKCHR
                           .DCTDS    0     generic DSK
                           .DCTFS    2     file structure
                           .DCTUF    3     unit within structure
                           .DCTCN    4     controller class
                           .DCTCC    5     controller within class
                           .DCTPU    6     unit within controller
            DC.DCN   7B20  data channel number
            DC.CNT   77B26 controller type
                           .DCCDR    0     FH  drum
                           .DCCFH    1     fixed-head disk
                           .DCCDP    2     DP  disk pack (RP01,RP02)
                           .DCCMD    3     mass disk
                           .DCCBP    4     BP  big pack (IBM 3330)
            DC.CNN   7B29  controller number
            DC.UNT   3B31  unit type
                           controller type = FH
                           .DCUBU    0     Burroughs disk
                           .DCBBR    1     Bryant drum
                           controller type = DP
                           .DCUD1    0     RP01
                           .DCUD2    1     RP02
                           controller type = MD
                           .DCUDP    0     dual positioner
                           .DCUSP    1     single positioner
                           controller type = BP
                           .DCUM1    0     3330 Model I
                           .DCUM2    1     3330 Model II
            DC.UNN   7B35  unit number within controller


                      ____ ______________ _____            8.14.2    Disk Unit/Structure Names

            These UUOs allow a  program to obtain names of  all the disk units (SYSPHY)  or disk
            structures (SYSSTR) in a system.

                        _______ ___ ______ ______ ____ ______ ____            8.14.2.1    GOBSTR: Get system search list (CALLI +66)

                    MOVE    ac,[count,,addr]
                    GOBSTR  ac,
                      error return          ; ac/ error code
                    normal return

            addr:   frame number            ; or 0 for system
                    PPN of frame
                    -1                      ; sixbit structure name returned here
                    Z                       ; not used
                    Z                       ; status returned here

            where <error code> is given in Table 8-30 .

            If <frame number> is zero, the PPN is ignored and the system search list  is scaned.
            If <frame number> and  <PPN> are -1 then the  current frames search list  is scaned.
            If the PPN of the specified frame does not match <PPN>, or the frame does not exist,
            then an error is given.

            Requesting information  about another  frame or the  system requires  Structure (ST)
            license.
                                                    8-29


      Disk I/O                                 8                          YAMM edition 2.0


                                          _____ ____                                           Table 8-30 
                                       ______ _____ _____                                       GOBSTR error codes


      name     code  description

      DFGIF%   3     <addr>+2 is not in search list or -1 or 0.
      DFGPP%   6     <frame> and <PPN> do not agree
      DFGNP%   10    No license
      DFGLN%   12    Bad length for list


                  _______ ______ ______ ____ ____ _________ ______ ____      8.14.2.2    JOBSTR: Return frames next file structure (CALLI +47)

              MOVE    ac,[count,,addr]
              JOBSTR  ac,
                error return
              normal return

      addr:   -1              ; sixbit structure name returned here
              Z               ; not used
              Z               ; status bits returned here

      If addr  contains -1  the first file  structure name  is returned.   Otherwise, addr
      should contain a  file structure name  and the one following  that on in  the frames
      search list is returned.

                  _______ __________ ____ __________ ______ ____      8.14.2.3    STRUUO: Manipulate file structures (CALLI +50)

              MOVE    ac,[length,,addr]
              STRUUO  ac,
                error return          ; ac/ error code
              normal return           ; ac/ status information

      addr:   funct                   ; see Table 8-31 
              arguments if any

      <error code> is found in Table 8-31b.

      The argument list consists  of word triplets, which  specify the new search  list in
      order to replace the current search list.  The current search list may be determined
      by the JOBSTR UUO (CALLI +47, pg. 8-30).  The format of a triplet is:

              SIXBIT "str-name"
              0                       ; not used
              status-bits

      The status bits are:

              1B0     0=read/write, 1=read only
              1B1     don't create files on this structure

      Preform the specified function.  All functions except .FSSRC require  Structure (ST)
      license.














                                              8-30


            July 3, 1980                             8                                  Disk I/O


                                                _____ ____                                                 Table 8-31 
                                           ______ ________ _____                                           STRUUO function codes


            name     code  description

            .FSSRC   0     Define new search list for frame (no license required).
            .FSDSL   1     Define new search list for any frame or system.
            .FSDEF   2     Define new file structure.
            .FSRDF   3     Redefine file structure.
            .FSLOK   4     Lock file structure.
            .FSREM   5     Remove file structure.
            .FSULK   6     Test/Set UFD interlock.
            .FSUCL   7     Clear UFD interlock.
            .FSETS   10    Simulate hard errors.
            .FSRRL   11    Read/reset log for 3330's.



                                                _____ _____                                                Table 8-31b
                                             ______ _____ _____                                             STRUUO error codes


            name     code  description

            FSILF%   0     Illegal function code
            FSSNF%   1     Structure not found
            FSSSA%   2     Structure single access only
            FSILE%   3     Illegal list entry
            FSTME%   4     Too many entries in list
            FSUNA%   5     Unit not available
            FSPPN%   6     PPN doesn't match
            FSMCN%   7     Mount count greater then 1
            FSNPV%   10    No license
            FSFSA%   11    Structure already exists
            FSILL%   12    Bad list length
            FSUNC%   13    Unable to complete UUO
            FSNFS%   14    System full of structures
            FSNCS%   15    No free core
            FSUNF%   16    Illegal unit
            FSRSL%   17    File structure repeated in list


                        _______ ____ ________ ____ _____ ______ ____            8.14.2.4    SYSPHY: read physical unit names (CALLI +51)
                        _______ ____ ____ _________ _____ ______ ____            8.14.2.4    SYSSTR: read disk structure names (CALLI +46)

                    MOVE    ac, [start]
                    SYSPHY  ac,
                      or
                    SYSSTR  ac,
                      error return
                    normal return

            In what follows, the term "thing" refers to a disk unit in the SYSPHY UUO and a disk
            structure in the SYSSTR UUO.

            If <start> is 0, set c(<ac>) to 0 if there are no things, or to the  SIXBIT physical
            name of the first unit in the system if there are, and skip-return.

            If <start> is nonzero, search the system for a thing whose name matches <start>.  If
            none is found, error-return.  If the named thing is found, but it is the last one on
            the monitor's list, set c(<ac>) to 0 and skip-return; otherwise, set c(<ac>)  to the
            SIXBIT name of the next thing on the monitor's list, and skip-return.





                                                    8-31


      Disk I/O                                 8                          YAMM edition 2.0


                ______ ____ ____ ____ ________ ___ ____ ____      8.14.3    UGETF: read disk file position (op code 073)
                _______ ____ ____ ____ ________ _______ __ ___      8.14.3    .CHUGF: read disk file position (CHANIO fn 10)

              UGETF   channel, addr
              only return

              MOVE    ac, [.CHUGF,,channel]
              CHANIO  ac, addr
              only return

      If no file is  selected on <channel>, set  c(<addr>) to -1; otherwise,  set c(<addr>
      left) to the current  file pointer position, in  blocks, and c(<addr> right)  to the
      current file size, in blocks.  Return.


              __________ ___ ________      8.15    Validating and Flushing

                _______ ________ ___ _______ __ ___      8.15.1    .CHVRB: validate RIB (CHANIO fn 42)

              MOVE    ac, [.CHVRB,,channel]
              CHANIO  ac,
                error return  ; c(<ac>) := error code
              normal return

      where <error code> is a code from Table 4-19

      If no file is selected on <channel>, take the error return; otherwise, wait  for the
      selected file's RIB to be written to disk, then skip-return.

                _______ __________ _______ ____ ______ ____ ______ ____      8.15.2    DSKCLR: initialize in-core file system data (CALLI -22)

              DSKCLR  <mode>,
               <parameter>
               error return
              normal return

      where <mode> = :
              0       DC.CLR  clear in-core file system info
              1       DC.FPC  set Free-Page Count for all SATs,
                              and clear "need DSKCLN" flag
              2       DC.NDS  clear "need DSKCLN" flag

      and the <parameter> corresponding to each <mode> is:
      mode    parameter
      0        no <parameter>
      1       addr of AOBJN word of form
                   -<count of args>,,<addr of first arg>
      2       no <parameter>

      If the caller lacks Write Core (WC) license, take the normal return.

      If <mode> is not 0,1, or 2, take the error return.

      If <mode>=0,

          If any of the in-core file system database is in use, take the error return.
          Otherwise clear it all and take the normal return.

      If <mode>=1,

          Check that <count>=the  number of SATs on  all units in the  DSKB structure.
          If not equal, take the error return.

          Set  the  Free Page  Count  entries for  all  SATs from  the  argument block
          starting at  <addr of first  arg>.  Clear the  "need DSKCLN" bit.   Take the
          normal return.

      If <mode>=2,
                                              8-32


            July 3, 1980                             8                                  Disk I/O


                Clear the "need DSKCLN" bit.  Take the normal return.


                                                _____ ____                                                 Table 8-33 
                                           ____ ____ ______ ____                                           DSK: File Status Bits


            name     bit   meaning

            IO.IMP   1B18  improper mode
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   77B35 data mode mask

















































                                                    8-33


      Disk I/O                                 8                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              8-34


            July 3, 1980                             9                    Processor ID Mechanism


                                                 _______ _                                                 Section 9
                                           _________ __ _________                                           Processor ID Mechanism

                                             Table of Contents



            SubSection


            9.1      Purpose of PID's    9-1

            9.2      Definition of PID    9-1

            9.3      Issuing PID's    9-1

            9.4      Authority Conferred by a PID    9-2

            9.5      Executing with a PID    9-2

            9.6      Manipulating the PID    9-2
            9.6.1       PIDSET: Manipulate Process' PID (CALLI -122)    9-2

            9.7      PID Handling on ENTER and RENAME    9-3

            9.8      PID's and Storage Accounting    9-3










































                                                    9-i


                                               9                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              9-ii


            July 3, 1980                             9                    Processor ID Mechanism





                                                 _______ _                                                 Section 9
                                           _________ __ _________                                           Processor ID Mechanism





                   _______ __ _____            9.1    Purpose of PID's

            PID's extend  the basic  Tymshare file protection  mechanisms and  provide a  way of
            associating  the  charge  for  disk storage  with  the  processors  (programs) which
            manipulate that storage, rather than with the directory in which it  resides.  PID's
            may also be  used as validity-stamps  to ensure the  integrity of data.   PID's were
            developed to allow processors or groups of cooperating processors to implement their
            own file protection policies different from those offered by the monitor.


                   __________ __ ___            9.2    Definition of PID

            A PID is a 36-bit quantity whose left  half is the UUN of some valid user  and whose
            right half is  an index number.  Under  normal circumstances, a user  can manipulate
            only those PID's that have his UUN in their left half; he can arbitrarily select the
            index in the right half.  This allows a user to allocate his own  PID's, eliminating
            the requirement that some central Tymshare authority do so.

            The  value 0,  when specified  in a  PID argument  or returned  as a  PID by  a UUO,
            represents the absence of a PID. No PID may be created whose left half (UUN part) is
            zero, except  by programs  having Write Absolute  (WA) or  Write File  (WF) license.
            These zero-UUN PID's are reserved for system use.

            A PID becomes  associated with a  processor (i.e., a program)  in much the  same way
            that license is associated with  the processor: some other processor  with authority
            to do so issues an ENTER or  RENAME UUO on <processor>.SAV (or .SHR, etc.)  with the
            new  PID  in  .RBPID,  word 40  of  the  extended  LOOKUP/ENTER/RENAME  block.  When
            <processor> is  later executed,  this PID  becomes associated  with the  process and
            gives it authority to access files with matching PID's in ways described on 9-2.


                   _______ _____            9.3    Issuing PID's

            A processor is authorized to issue a PID if any of the following are true:
                1)  The PID is zero.  (A process can  clear the PID on any file to  which it
                    has at least append access);
                2)  The PID in .RBPID exactly matches the PID of the executing process;
                3)  The UUN-part of the PID exactly  matches the UUN-part of the AUN  of the
                    executing process;
                4)  The process has Write File (WF) license.  The PID can have any value.
            To issue a PID, a processor must have ENTER or RENAME access to the file.   To issue
            the PID (that is,  to place it on the  file) the processor must execute  an extended
            ENTER   or  RENAME,   placing   the  desired   PID   in  .RBPID   in   the  extended
            LOOKUP/ENTER/RENAME block.














                                                    9-1


      Processor ID Mechanism                   9                          YAMM edition 2.0


             _________ _________ __ _ ___      9.4    Authority Conferred by a PID

      A process executing with PID xx can successfully gain any level of access to  a file
      having PID xx, even if the directory in which this file resides is protected against
      LOOKUP's.  This  ability is  enabled by  setting bit  20 of  .RBCNT in  the extended
      LOOKUP/ENTER/RENAME block.  See 9-1.  In particular, this means that  the protection
      on the file can be changed to prevent the owner of the directory in which it resides
      from modifying or deleting the file.   For example, if you ran a processor  with PID
      xx it could create a file in your directory, place PID xx on it, set  the protection
      to  NO NO  NO, and  implement its  own protection  scheme with  which you  could not
      interfere.

      Note that no processor (with or without PID) can be guaranteed the ability to search
      an arbitrary directory for  files with matching PID;  all that a PID  guarantees the
      holder is the ability to gain access to a file with matching PID whose  location and
      name he knows.


             _________ ____ _ ___      9.5    Executing with a PID

      A PID  becomes associated  with a  program's execution  if the  file from  which the
      program was run has a PID.  As with license, the PID disappears if the  user meddles
      with the program (provides an argument to the START command, etc.).  If  the process
      issues a RUN or RUNSEG UUO, the old PID remains in effect until the new  file(s) are
      successfully set up; then the  PID is set to the PID  of the new file(s).  If,  in a
      RUN UUO, the low file PID differs from  the hiseg file PID, the new PID will  be set
      to zero.   A GETSEG UUO  will not affect  a process' PID.   The RUN, GET,  SAVE, and
      SSAVE operations will clear a process'  PID and saved PID (see 9-2) before  any file
      accesses  are done.   The  CLOSE, FINISH,  CORE  and START  <argument>  commands are
      considered meddling  and will  clear out  the PID  and saved  PID.  In  general, any
      command that would reset process license will also clear PID's.


             ____________ ___ ___      9.6    Manipulating the PID

      The PIDSET  UUO (CALLI -122,  pg. 9-2) allows a  process to  set,clear and  read the
      PID under  which it  is executing.   Whenever a  process with  non-zero PID  sets or
      clears  the PID  it is  first saved.   This <saved  PID> can  later be  restored.  A
      process may set its PID  to 0, to the saved PID  (if any), or to any PID  whose left
      half (UUN-part) matches the right half (UUN-part) of the process' logged-in AUN.

      The purpose of allowing processors to clear and restore their PID's is to allow them
      to control selectively their special access priviledges.  In particular, a processor
      may wish to clear its PID before  any RUN, GET or SAVE operation to prevent  the PID
      authority from being used by these operations.

               _______ __________ ________ ___ ______ _____      9.6.1    PIDSET: Manipulate Process' PID (CALLI -122)

              MOVE AC,[<pid>]
              PIDSET AC,
               error return   ;AC/ current PID
              normal return

      If <pid>  is zero, or  current process  license includes Write  Absolute (WA)  or WF
      license, or the process AUN matches the left half of <pid>, or <pid> =  <saved PID>,
      then set process' PID to <pid>, set <saved PID> to previous PID if it  was non-zero,
      set AC to previous PID, and take the normal return.  Otherwise set AC to current PID
      and take the error return.










                                              9-2


            July 3, 1980                             9                    Processor ID Mechanism


                   ___ ________ __ _____ ___ ______            9.7    PID Handling on ENTER and RENAME

            For all RENAMEs and ENTERs, the old file PID is set to zero.  This forces processors
            to specify PID's directly,preventing inadvertent spread of the PID.  The new  PID in
            .RBPID is checked; if it is zero or -1, the new file PID becomes zero.  if it is not
            zero or -1,  the new PID  in .RBPID must  pass the tests  described on 9-1.   If the
            tests fail,  the new file  PID becomes zero;  otherwise it is  set to  the requested
            value.

            If .RBPID is unspecified  because the count in an  extended ENTER or RENAME  is less
            than .RBPID or  because a short ENTER  or RENAME is done,  the PID argument  will be
            assumed to be zero.  This  means that any ENTER or  RENAME on a file will  result in
            that file's PID becoming zero unless .RBPID is specifically set to a non-zero value.


                   _____ ___ _______ __________            9.8    PID's and Storage Accounting

            Bit 6  in .RBLIC for  a file will  be set  if and only  if the PID  for the  file is
            non-zero.  This  bit may  be examined  in the  UFD entry  for the  file to  find out
            whether the file has a PID without doing  a LOOKUP on the file.  Bit 6 in  .RBLIC of
            the UFD rib will also be set for any UFD which has special PID storage accounting.

            Files which have PID's are not charged according to the standard accounting policies
            but rather according to special  PID accounting schemes developed to meet  the needs
            of processors  using PID's.   Contact Marketing for  more information.   Please note
            that even though a file with a PID may not be charged according to  standard storage
            charging policies, its space is counted against the storage quota for  the directory
            in which it resides.








































                                                    9-3


      Processor ID Mechanism                   9                          YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              9-4


            July 3, 1980                             10                                 Port I/O


                                                 _______ __                                                 Section 10
                                                  ____ ___                                                  Port I/O

                                             Table of Contents



            SubSection


            10.1     Port Numbers and Device Names    10-1

            10.2     Command Ports    10-1
            10.2.1      Detaching    10-1
            10.2.2      Attaching    10-1
            10.2.3      Command versus User Level    10-1

            10.3     Auxiliary Ports    10-2
            10.3.1      Creating    10-2
            10.3.2      Slaving the Command Port    10-2
            10.3.3      Inquiring about Ports and their Statuses    10-2
            10.3.4      Zapping    10-2

            10.4     Reseting Ports    10-2

            10.5     Line Characteristic Word    10-3

            10.6     File Status Bits    10-3

            10.7     Port Operations    10-3
            10.7.1      AUXCAL: perform port i/o functions (op code 042)    10-3
            10.7.2      TTCALL: perform cmnd port i/o (op code 051)    10-7
            10.7.3      Buffered I/O    10-7

            10.8     Baud Rates    10-7

            10.9     Buffering and Backpressure    10-8
            10.9.1      Host No XON    10-8
            10.9.2      Remote XON    10-8
            10.9.3      Reverse XON    10-8
            10.9.4      Flushing Input    10-8
            10.9.5      Flushing Output    10-8

            10.10    Data Transmission Methods    10-8

            10.11    Character Handling    10-9
            10.11.1     Input    10-9
                           Case Mapping    10-9
                           Special Characters    10-9
                              Line Editing    10-9
                              Escape Character    10-9
                              Output Suppression    10-10
                              End Of File    10-10
                              Monitor Modes    10-10
                           Break Characters    10-10
                           Image State    10-11
                              Breaks    10-11
                              Image Break Character    10-12
            10.11.2     Echoing    10-12
                           Turning off Echo    10-12
                              Half-Duplex    10-12
                              No Echo    10-13
                              Local Copy    10-13
                           Yellow and Orange Balls    10-13
                           Faking Input Wait    10-14
                           Special Characters    10-14
                              Backspace    10-14
                              Deleted Characters    10-14
                                                    10-i


      Port I/O                                 10                         YAMM edition 2.0

      SubSection
                        Escape    10-14
      10.11.3     Output    10-14
                     Output Case Mapping    10-14
                     Image Characters    10-15
                     Line Width and Position    10-15
                     HT, VT, FF simulation    10-15
                     CR and LF delay    10-15
                        CR Delay Formula    10-16
                        LF Delay Formula    10-16
                     HT, VT, FF delays    10-16
                        HT Filler Cclass    10-16
                        VT and FF filler class    10-16
      10.11.4     Parity    10-17
      10.11.5     Data Transmission Modes    10-17
                     Katakana Data Mode    10-17
                     Paper Tape Mode    10-17
                     Port Buffered-I/O Modes    10-18

      10.12    Block I/O    10-18
      10.12.1     Block I/O Buffer Format    10-18
      10.12.2     Block I/O Data Modes    10-18
      10.12.3     Interaction with Non-Block Input    10-19
      10.12.4     Interaction with Non-Block Output    10-19
      10.12.5     Block I/O Tutorial    10-19

      10.13    Port Creation,Moving,Deletion UUOs    10-19
      10.13.1     GETLIN: get command port name (CALLI +34)    10-20
      10.13.2     ATTACH: attach command port to frame (CALLI -6)    10-20
      10.13.3     RETACH: move port from frame to frame (CALLI -135)    10-20
      10.13.4     CREAUX: create an aux circuit (CALLI -44)    10-21
      10.13.5     .AXSLV: slave command port (AUXCAL fn 43)    10-22
      10.13.6     ZAPCIR: zap an aux circuit (CALLI -45)    10-23
      10.13.7     .AXHNG: send hangup (AUXCAL fn 60)    10-23
      10.13.8     AUXRED: read aux circuit port numbers (CALLI -46)    10-24
      10.13.9     POLPRT: Poll Ports for Events (CALLI -115)    10-24
      10.13.10    .AXPSM: read port-status msg (AUXCAL fn 61)    10-25

      10.14    Port and Terminal Characteristics UUOs    10-25
      10.14.1     GETLCH: read line characteristics (TTCALL 6)    10-25
      10.14.2     SETLCH: set line characteristics (TTCALL 7)    10-26
      10.14.3     GETTMC: (obs.) get terminal characteristics (CALLI -16)    10-26
      10.14.3     SETTMC: (obsolete) no-op (CALLI -15)    10-26
      10.14.4     SETMOD: set cmnd port file status (CALLI -26)    10-26
      10.14.5     .AXSFS: set port file status bits (obsolescent) (AUXCAL fn 32)    10-27
      10.14.5     .AXCFS: change port file status bits (AUXCAL fn 64)    10-27
      10.14.6     .AXCRD: r/s compute-CR-delay bit (AUXCAL fn 14)    10-28
      10.14.6     .AXIBR: r/s input baud rate (AUXCAL fn 15)    10-28
      10.14.6     .AXOBR: r/s output baud rate (AUXCAL fn 16)    10-28
      10.14.6     .AXEP: r/s even-parity bit (AUXCAL fn 17)    10-28
      10.14.6     .AXHD: r/s half-duplex bit (AUXCAL fn 20)    10-28
      10.14.6     .AXPA: r/s parameter A (AUXCAL fn 21)    10-28
      10.14.6     .AXPB: r/s parameter B (AUXCAL fn 22)    10-28
      10.14.6     .AXPC: r/s parameter C (AUXCAL fn 23)    10-28
      10.14.6     .AXHNX: r/s host-no-XON bit (AUXCAL fn 24)    10-28
      10.14.6     .AXNTE: r/s no HT/VT/FF bit (AUXCAL fn 25)    10-28
      10.14.6     .AXTBK: r/s tabs-as-breaks bit (AUXCAL fn 26)    10-28
      10.14.6     .AXWID: r/s line width (AUXCAL fn 27)    10-28
      10.14.6     .AXFC1: r/s filler class 1 (AUXCAL fn 30)    10-28
      10.14.6     .AXFC2: r/s filler class 2 (AUXCAL fn 31)    10-28
      10.14.6     .AXRMX: r/s remote-XON bit (AUXCAL fn 53)    10-28
      10.14.6     .AXRBS: r/s remote-BS-echo bit (AUXCAL fn 54)    10-28
      10.14.6     .AXRVX: r/s reverse-XON bit (AUXCAL fn 55)    10-28
      10.14.6     .AXTYP: r/s terminal type (AUXCAL fn 56)    10-28
      10.14.6     .AXBS: r/s BS-for-char-delete bit (AUXCAL fn 57)    10-28
      10.14.6     .AXERA: r/s Erase-for-char-delete bit (AUXCAL fn 62)    10-28
      10.14.6     .AXEDE: r/s force deferred-echo bit (AUXCAL fn 63)    10-28
      10.14.6     .AXLCO: r/s Lower-case-output bit (AUXCAL fn 65)    10-28
      10.14.6     .AXBBP: r/s backspace break/punctuation bit (AUXCAL fn 66)    10-28
                                             10-ii


            July 3, 1980                             10                                 Port I/O

            SubSection
            10.15    Echo,Break,Backpressure UUOs    10-28
            10.15.1     .AXS8B: set image break char (AUXCAL fn 13)    10-28
            10.15.2     .AXSYB: send yellow ball (AUXCAL fn 12)    10-29
            10.15.3     .AXSOB: send orange ball (AUXCAL fn 70)    10-29
            10.15.4     LEVDEF: leave deferred echo mode (CALLI -30)    10-29
            10.15.4     .AXLDE: leave deferred echo mode (AUXCAL fn 11)    10-29
            10.15.5     CLRBFI: clear input buffer (TTCALL 11)    10-29
            10.15.5     .AXCBI: clear input buffer (AUXCAL fn 6)    10-29
            10.15.6     CLRBFO: clear output buffer (TTCALL 12)    10-29
            10.15.6     .AXCBO: clear output buffer (AUXCAL fn 7)    10-29

            10.16    Port Input UUOs    10-29
            10.16.1     INCHRW: input char [wait/bka] (TTCALL 0)    10-30
            10.16.2     .AXICW: input char [wait/bka] (AUXCAL fn 44)    10-30
            10.16.3     INCHRS: input char [skip/bka] (TTCALL 2)    10-31
            10.16.4     .AXICS: input char [skip/bka] (AUXCAL fn 45)    10-31
            10.16.5     INCHWL: input char [wait] (TTCALL 4)    10-31
            10.16.6     .AXIWL: input char [wait] (AUXCAL fn 46)    10-31
            10.16.7     INCHSL: input char [skip] (TTCALL 5)    10-32
            10.16.8     .AXISL: input char [skip] (AUXCAL fn 47)    10-32
            10.16.9     Image State    10-32
                           .AXI8C: input char [wait/bka/img] (AUXCAL fn 0)    10-32
                           .AXI8S: input char [skip/bka/img] (AUXCAL fn 1)    10-33
                           .AXI8B: input char [wait/img] (AUXCAL fn 2)    10-33
            10.16.10    Testing    10-33
            10.16.11    Faking Input    10-33
            10.16.12    Miscellaneous Command Port UUOs    10-34
            10.16.13    SKPINC: skip if char (TTCALL 13)    10-34
            10.16.13    SKPINL: skip if break char (TTCALL 14)    10-34
            10.16.13    .AXSIC: skip if char (AUXCAL fn 10)    10-34
            10.16.13    .AXSIL: skip if break char (AUXCAL fn 50)    10-34
            10.16.14    .AXSI: simulate input (AUXCAL fn 33)    10-34
            10.16.15    REDNXT: peek at input (CALLI -14)    10-35
            10.16.16    WAITCH: wait for input char (CALLI -13)    10-35
            10.16.17    RESCAN: rescan command line (TTCALL 10)    10-35
            10.16.18    DDTIN: DDT-mode input (CALLI +1)    10-35
            10.16.19    CONT: Put port in user level (CALLI -125)    10-35

            10.17    Output UUOs    10-36
            10.17.1     Single Character Output    10-36
                           OUTCHR: output char [CMD] (TTCALL 1)    10-36
                           OUTCHI: output char [CMD/IMM] (TTCALL 16)    10-36
                           .AXOCI: output char [IMM] (AUXCAL fn 51)    10-37
                           IONEOU: output char [CMD/IMG] (TTCALL 15)    10-37
                           .AXO8: output char [IMG] (AUXCAL fn 3)    10-37
                           .AXO8I: output char [IMG/IMM] (AUXCAL fn 4)    10-37
            10.17.2     String Output    10-38
                           OUTSTR: output string [STR/CMD] (TTCALL 3)    10-38
                           .AXOST: output string [STR] (AUXCAL fn 52)    10-39
                           OUTPTR: output string [PTR/CMD] (TTCALL 17)    10-39
                           .AXPTR: output string [PTR] (AUXCAL fn 5)    10-40
                           .AXOPC: output string [PTR+count] (AUXCAL fn 67)    10-40
                           DDTOUT: DDT-mode output (CALLI +3)    10-40

            10.18    Port Block I/O UUOs    10-41
            10.18.1     .AXEBM: enter block i/o mode (AUXCAL fn 34)    10-41
            10.18.2     .AXLBM: leave block i/o mode (AUXCAL fn 42)    10-41
            10.18.3     .AXIBW: input block and wait (AUXCAL fn 35)    10-41
            10.18.4     .AXIBS: input block and skip (AUXCAL fn 36)    10-41
            10.18.5     .AXTBI: terminate block input (AUXCAL fn 40)    10-42
            10.18.6     .AXOB: block output (AUXCAL fn 37)    10-42
            10.18.7     .AXTBO: terminate block output (AUXCAL fn 41)    10-42


            Table

            10-4     AUXCALs by function    10-4
            10-6     AUXCALs by number    10-6
                                                   10-iii


      Port I/O                                 10                         YAMM edition 2.0

      Table
      10-7     TTCALL functions by number    10-7
      10-22    RETACH error codes    10-22
      10-22b   CREAUX Error Codes    10-23
      10-25    Port Event-Status Bits    10-25
      10-26    Line Characteristics Word    10-26
      10-27    TTY: File Status Bits    10-27
      10-27b   Monitor Modes & Special Characters    10-27
      10-30    Port Character Input Calls    10-30
      10-36    Port Character Output Calls    10-36
      10-39    Port String Output Calls    10-39


























































                                             10-iv


            July 3, 1980                             10                                 Port I/O





                                                 _______ __                                                 Section 10
                                                  ____ ___                                                  Port I/O





                    ____ _______ ___ ______ _____            10.1    Port Numbers and Device Names

            Each TYMNET port is given a "port number" by the monitor.  That port nunber  is used
            directly by some functions, notably AUXCAL,  the UUO through which most port  i/o is
            done.  Each port also has a normal device name, of the form

                    TTY<port number>

            where the port number is expressed in octal.


                    _______ _____            10.2    Command Ports

            Each frame  normally has a  "command port".  This  port is referred  to by  the UUOs
            taking port numbers as port -1, and by the UUOs taking device names as device TTY.

                      _________            10.2.1    Detaching

            A frame can "detach" itself from its command port if the user types the command

                    DETACH

            or if a program executes the ATTACH UUO (CALLI -6, pg. 10-20).

            Most  i/o operations,  when directed  towards the  command port  of a  frame running
            detached, will just hang until a real port is attached to the frame again.

                      _________            10.2.2    Attaching

            A user who is logged-in, and  who has another frame running detached on  the system,
            can attach his  current frame's command  port to that  frame (detaching it  from the
            current frame) by typing the command

                    ATTACH <frame number>

            A program can  likewise cause its  frame's command port to  be detached from  it and
            attached to  some other  frame by  executing the  ATTACH UUO  (CALLI -6, pg. 10-20).
            The RETACH UUO (CALLI -135, pg. 10-20) allows ports to be moved from frame  to frame
            in a completely general way by a process with sufficient access rights.

                      _______ ______ ____ _____            10.2.3    Command versus User Level

            Any terminal input is processed either by

                    1. the monitor's command processor
                    2. a user program

            When input is going  to the monitor as  in (1), the port  is said to be  in "command
            level"; when situation (2) prevails, the port is in "user level".

            A port can be  in command level even though  a program is running, and  even perhaps
            waiting for input.  This situation can be caused by the CSTART, CCONTINUE and ATTACH
            commands.

            In the ordinary course  of events, a START, CON,  or RUN command puts the  port into
            user  level, and  it  remains in  user level  (causing  the program  to  receive any
            characters) until any of the following happens:

                                                    10-1


      Port I/O                                 10                         YAMM edition 2.0



              1. the program does an EXIT UUO
              2. the program encounters an error condition
                      which makes it unrunnable (ILL MEM REF,
                      ILL INST, etc.)
              3. the port receives an escape character
                      while the program is in input wait
              4. the port receives two consecutive escapes


              _________ _____      10.3    Auxiliary Ports

                ________      10.3.1    Creating

      To create an aux circuit, a program executes the CREAUX UUO (CALLI -44, pg. 10-21).

      CREAUX returns its error  codes in <ac> left,  and the supervisor's error  codes (if
      any) in <ac> right. The CREAUX error codes are shown in Table 10-22b.   Aux circuits
      are always in image state; see 10-11 for more discussion of this attribute.

                _______ ___ _______ ____      10.3.2    Slaving the Command Port

      The  .AXSLV  UUO  (AUXCAL fn 43,  pg. 10-22)  works  very  much  like  a  CREAUX UUO
      (CALLI -44,  pg. 10-21), but  instead of  creating a  new circuit,  it  detaches the
      current frame's command port and makes it available as if it were an auxiliary port.

      Slaved command ports differ in behavior from auxiliary circuits in that they are not
      always in deferred echo mode and are not always in image state.

                _________ _____ _____ ___ _____ ________      10.3.3    Inquiring about Ports and their Statuses

      A program can obtain the port numbers of all the aux circuits the  process currently
      owns  by  executing  the  AUXRED  UUO  (CALLI -46,  pg. 10-24).   Using  POLPRT  UUO
      (CALLI -115, pg. 10-24) a program can find out what, if any, significant events have
      happened on its ports since they were last polled.

                _______      10.3.4    Zapping

      If the CREAUX that created a particular aux port did not have the CX.NZP bit  set, a
      RESET UUO will zap the port.

      Regardless of the setting  of CX.ZAP at the time  of creation, a program can  zap an
      aux port by executing the ZAPCIR UUO (CALLI -45, pg. 10-23).


              ________ _____      10.4    Reseting Ports

      The RESET UUO 5-12 has the following effect on a frame's ports:

          Clear the  break-on-all state, and  IO.BK2 and IO.FCS  for the  command port
          (even if the frame is running detached).

          If the  frame is not  detached, clear block  i/o mode if  it is set  for the
          command  port,  and clear  the  hardware-horizontal-tabs  and tabs-as-breaks
          bits.

          Zap every  aux circuit  belonging to  the frame  except those  whose CREAUXs
          specified CX.NZP.










                                              10-2


            July 3, 1980                             10                                 Port I/O


                    ____ ______________ ____            10.5    Line Characteristic Word

            The  line  characteristics  word  for  a port  can  be  read  with  then  GETLCH UUO
            (TTCALL 6,  pg. 10-25)  and set  with  the SETLCH  UUO  (TTCALL 7,  pg. 10-26).  Its
            format is desccribed in Table 10-26 .


                    ____ ______ ____            10.6    File Status Bits

            Some  of a  port's characteristics  are  determined by  its file  status  bits.  The
            device-dependent bits for ports are shown in Table 10-27 .

            If  a  port has  been  INIT'ed, the  file  status bits  can  be read  and  set using
            GETSTS/SETSTS/STATZ/STATO in the normal way.

            The bits can, in addition, be read from the .GTMOD GETTAB table (see 18-3).

            To set the file status bits for the command port, a program executes the  SETMOD UUO
            (CALLI -26, pg. 10-26).

            To set the file status bits for  any port owner by the current frame, a  program can
            execute the .AXSFS UUO (AUXCAL fn 32, pg. 10-27).


                    ____ __________            10.7    Port Operations

            Most port operations are done with the AUXCAL UUO (op code 042, pg. 10-3)  or TTCALL
            UUO  (op code 051,  pg. 10-7).    AUXCAL  does  some  preliminary   checking  before
            performing its function code.

            Most simple operations on a command port are done using TTCALL, with the  <ac> field
            of the TTCALL  specifying the function, and  effective address field  specifying the
            argument, if any.

            While AUXCAL is  the more general of  the two UUO's, it  has the property  that many
            AUXCAL  output functions  are NO-OPs  if directed  at a  non-existent  port.  TTCALL
            output issued by a  detached frame will cause the  frame to go into  terminal output
            wait until  a command  port re-appears.  AUXCAL  output by  the same  detached frame
            would simply be lost.  Use TTCALL for command port I/O.

                      _______ _______ ____ ___ _________ ___ ____ ____            10.7.1    AUXCAL: perform port i/o functions (op code 042)

                    MOVE    ac, [port,,function]
                    AUXCAL  ac, addr

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, take the non-skip  return.  (On
            input calls, the non-skip return is  an error or no-data return; on  numerous output
            calls,  the non-skip  return is  the only  return, so  that if  no port  exists, the
            function becomes a no-op).

            Perform  the specified  function.  See  Table 10-4  and  Table 10-6  for  a  list of
            AUXCAL functions.











                                                    10-3


      Port I/O                                 10                         YAMM edition 2.0


                                          _____ ____                                           Table 10-4 
                                      _______ __ ________                                      AUXCALs by function


      Function  Name     Description

      Char input calls

        fn 0    .AXI8C   input char [wait/bka/img] (10-32)
        fn 1    .AXI8S   input char [skip/bka/img] (10-33)
        fn 2    .AXI8B   input char [wait/img] (10-33)
        fn 10   .AXSIC   skip if char (10-34)
        fn 44   .AXICW   input char [wait/bka] (10-30)
        fn 45   .AXICS   input char [skip/bka] (10-31)
        fn 46   .AXIWL   input char [wait] (10-31)
        fn 47   .AXISL   input char [skip] (10-32)
        fn 50   .AXSIL   skip if break char (10-34)


      Char output calls

        fn 3    .AXO8    output char [IMG] (10-37)
        fn 4    .AXO8I   output char [IMG/IMM] (10-37)
        fn 51   .AXOCI   output char [IMM] (10-37)


      String output calls

        fn 5    .AXPTR   output string [PTR] (10-40)
        fn 52   .AXOST   output string [STR] (10-39)
        fn 67   .AXOPC   output from pointer w/count [PTR,CNT] (10-40)


      Block I/O calls

        fn 34   .AXEBM   enter block i/o mode (10-41)
        fn 35   .AXIBW   input block and wait (10-41)
        fn 36   .AXIBS   input block and skip (10-41)
        fn 37   .AXOB    block output (10-42)
        fn 40   .AXTBI   terminate block input (10-42)
        fn 41   .AXTBO   terminate block output (10-42)
        fn 42   .AXLBM   leave block i/o mode (10-41)


      Parameter calls

        fn 14   .AXCRD   r/s compute-CR-delay bit (10-28)
        fn 15   .AXIBR   r/s input baud rate (10-28)
        fn 16   .AXOBR   r/s output baud rate (10-28)
        fn 17   .AXEP    r/s even-parity bit (10-28)
        fn 20   .AXHD    r/s half-duplex bit (10-28)
        fn 21   .AXPA    r/s parameter A (10-28)
        fn 22   .AXPB    r/s parameter B (10-28)
        fn 23   .AXPC    r/s parameter C (10-28)
        fn 24   .AXHNX   r/s host-no-XON bit (10-28)
        fn 25   .AXNTE   r/s no-tab-echo bit (10-28)
        fn 26   .AXTBK   r/s tabs-as-breaks bit (10-28)
        fn 27   .AXWID   r/s line width (10-28)
        fn 30   .AXFC1   r/s filler class 1 (10-28)
        fn 31   .AXFC2   r/s filler class 2 (10-28)
        fn 32   .AXSFS   set file status (replaced by fn 64) (10-27)
        fn 53   .AXRMX   r/s remote-XON bit (10-28)
        fn 54   .AXRBS   r/s remote-BS-echo bit (10-28)
        fn 55   .AXRVX   r/s reverse-XON bit (10-28)
        fn 56   .AXTYP   r/s terminal type (10-28)
        fn 57   .AXBS    r/s BS-for-char-delete bit (10-28)
        fn 62   .AXERA   r/s Erase-for-char-delete bit (10-28)
        fn 63   .AXEDE   r/s force deferred-echo bit (10-28)
                                              10-4


            July 3, 1980                             10                                 Port I/O


              fn 64   .AXCFS   change port file status (10-27)
              fn 65   .AXLCO   r/s Lower-case-output bit (10-28)
              fn 66   .AXBBP   r/s backspace break/punctuation bit (10-28)


            Miscellaneous calls

              fn 6    .AXCBI   clear input buffer (10-29)
              fn 7    .AXCBO   clear output buffer (10-29)
              fn 11   .AXLDE   leave deferred echo mode (10-29)
              fn 12   .AXSYB   send yellow ball (10-29)
              fn 13   .AXS8B   set image break char (10-28)
              fn 33   .AXSI    simulate input (10-34)
              fn 43   .AXSLV   slave command port (10-22)
              fn 60   .AXHNG   send hangup (10-23)
              fn 61   .AXPSM   read port status msg (10-25)
              fn 70   .AXSOB   send orange ball (10-29)



















































                                                    10-5


      Port I/O                                 10                         YAMM edition 2.0


                                          _____ ____                                           Table 10-6 
                                       _______ __ ______                                       AUXCALs by number


      Function  Name     Description

        fn 0    .AXI8C   input char [wait/bka/img] (10-32)
        fn 1    .AXI8S   input char [skip/bka/img] (10-33)
        fn 2    .AXI8B   input char [wait/img] (10-33)
        fn 3    .AXO8    output char [IMG] (10-37)
        fn 4    .AXO8I   output char [IMG/IMM] (10-37)
        fn 5    .AXPTR   output string [PTR] (10-40)
        fn 6    .AXCBI   clear input buffer (10-29)
        fn 7    .AXCBO   clear output buffer (10-29)
        fn 10   .AXSIC   skip if char (10-34)
        fn 11   .AXLDE   leave deferred echo mode (10-29)
        fn 12   .AXSYB   send yellow ball (10-29)
        fn 13   .AXS8B   set image break char (10-28)
        fn 14   .AXCRD   r/s compute-CR-delay bit (10-28)
        fn 15   .AXIBR   r/s input baud rate (10-28)
        fn 16   .AXOBR   r/s output baud rate (10-28)
        fn 17   .AXEP    r/s even-parity bit (10-28)
        fn 20   .AXHD    r/s half-duplex bit (10-28)
        fn 21   .AXPA    r/s parameter A (10-28)
        fn 22   .AXPB    r/s parameter B (10-28)
        fn 23   .AXPC    r/s parameter C (10-28)
        fn 24   .AXHNX   r/s host-no-XON bit (10-28)
        fn 25   .AXNTE   r/s no-tab-echo bit (10-28)
        fn 26   .AXTBK   r/s tabs-as-breaks bit (10-28)
        fn 27   .AXWID   r/s line width (10-28)
        fn 30   .AXFC1   r/s filler class 1 (10-28)
        fn 31   .AXFC2   r/s filler class 2 (10-28)
        fn 32   .AXSFS   set file status (replaced by fn 64) (10-27)
        fn 33   .AXSI    simulate input (10-34)
        fn 34   .AXEBM   enter block i/o mode (10-41)
        fn 35   .AXIBW   input block and wait (10-41)
        fn 36   .AXIBS   input block and skip (10-41)
        fn 37   .AXOB    block output (10-42)
        fn 40   .AXTBI   terminate block input (10-42)
        fn 41   .AXTBO   terminate block output (10-42)
        fn 42   .AXLBM   leave block i/o mode (10-41)
        fn 43   .AXSLV   slave command port (10-22)
        fn 44   .AXICW   input char [wait/bka] (10-30)
        fn 45   .AXICS   input char [skip/bka] (10-31)
        fn 46   .AXIWL   input char [wait] (10-31)
        fn 47   .AXISL   input char [skip] (10-32)
        fn 50   .AXSIL   skip if break char (10-34)
        fn 51   .AXOCI   output char [IMM] (10-37)
        fn 52   .AXOST   output string [STR] (10-39)
        fn 53   .AXRMX   r/s remote-XON bit (10-28)
        fn 54   .AXRBS   r/s remote-BS-echo bit (10-28)
        fn 55   .AXRVX   r/s reverse-XON bit (10-28)
        fn 56   .AXTYP   r/s terminal type (10-28)
        fn 57   .AXBS    r/s BS-for-char-delete bit (10-28)
        fn 60   .AXHNG   send hangup (10-23)
        fn 61   .AXPSM   read port status msg (10-25)
        fn 62   .AXERA   r/s Erase-for-char-delete bit (10-28)
        fn 63   .AXEDE   r/s force deferred-echo bit (10-28)
        fn 64   .AXCFS   change port file status (10-27)
        fn 65   .AXLCO   r/s Lower-case-output bit (10-28)
        fn 66   .AXBBP   r/s backspace break/punctuation bit (10-28)
        fn 67   .AXOPC   output from pointer w/count [PTR,CNT] (10-40)
        fn 70   .AXSOB   send orange ball (10-29)





                                              10-6


            July 3, 1980                             10                                 Port I/O


                      _______ _______ ____ ____ ___ ___ ____ ____            10.7.2    TTCALL: perform cmnd port i/o (op code 051)

                    TTCALL  function, addr
                      or
                    functionname    addr

            where <function> or <functionname> is taken from Table 10-7 .


                                                _____ ____                                                 Table 10-7 
                                         ______ _________ __ ______                                         TTCALL functions by number


            symbol   code  description
            INCHRW   0     input character, wait
            OUTCHR   1     output one character
            INCHRS   2     input character, skip
            OUTSTR   3     output asciz string
            INCHWL   4     input character, wait, line mode
            INCHSL   5     input character, skip, line mode
            GETLCH   6     get line characteristics
            SETLCH   7     set line characteristics
            RESCAN   10    rescan command line
            CLRBFI   11    clear input buffer
            CLRBFO   12    clear output buffer
            SKPINC   13    skip if character present
            SKPINL   14    skip if break character present
            IONEOU   15    output one character, image mode
            OUTCHI   16    output one character, immediate
            OUTPTR   17    output asciz string via bytepointer


                      ________ ___            10.7.3    Buffered I/O

            Buffered port I/O can be  performed in ASCII, ASCII line (=ASCII),  Katakana, Image,
            Image Binary, or Binary mode.

            In ASCII mode, the byte size is 7 bits; in Katakana it is 9 bits; in Image and Image
            Binary it is 8 bits, and in  Binary it is 36 bits.  (In Binary mode,  the characters
            are stored one to a word, right justified in the user's buffer).

            The standard buffer size is 23 (decimal) words (20 data + 3 header).


                    ____ _____            10.8    Baud Rates

            A program can read or set a port's input and output baud rates using the  .AXIBR UUO
            (AUXCAL fn 15,  pg. 10-28) and  .AXOBR UUO  (AUXCAL fn 16, pg. 10-28).   The numbers
            passed to and returned by the AUXCALs  are not the actual baud rates but a  code for
            the baud rate:

                code baud

                0    110 (or Aux Circuit)
                1    150
                2    300
                3    400
                4    600
                5    1200
                6    300 (IBM 3767)
                7    150 (IBM 2741)







                                                    10-7


      Port I/O                                 10                         YAMM edition 2.0


              _________ ___ ____________      10.9    Buffering and Backpressure

      The  monitor maintains  an input  and an  output buffer  for each  port,  and TYMNET
      maintains buffers in both directions as  well.  When buffers fill up, there  are two
      mechanisms for stopping the flow of characters:
          1)  Cassette and  paper-tape-reading terminals can  usually be made  to stop
              transmitting characters by sending  them an XOFF, and will  restart when
              sent an XON.
          2)  Hosts will stop  outputting when backpressure is  applied to a  line and
              will resume when it is relieved.
      When the monitor's input buffer becomes full, it will normally apply backpressure if
      the port's data mode is image, image binary, or binary, or send an XOFF otherwise.

                ____ __ ___      10.9.1    Host No XON

      The sending of  XOFFs and XONs can  be inhibited by setting  the "no host  XON" bit,
      using the .AXHNX UUO (AUXCAL fn 24, pg. 10-28).

                ______ ___      10.9.2    Remote XON

      The TYMNET remote can be instructed to send the terminal XOFFs when  backpressure is
      applied to  a line and  XONs when it  is released by  setting the "remote  XON" bit,
      using the .AXRMX UUO (AUXCAL fn 53, pg. 10-28).

                _______ ___      10.9.3    Reverse XON

      TYMNET can be instructed to apply and release backpressure on a line when  XOFFs and
      XONs (respectively) are typed at a terminal by setting the "reverse XON"  bit, using
      the .AXRVX UUO (AUXCAL fn 55, pg. 10-28).  This is especially useful  for high-speed
      display terminals, where it provide  a means for stopping output  immediately before
      it scrolls off the screen.

                ________ _____      10.9.4    Flushing Input

      To clear the monitor's input buffer for a line, and release backpressure (if  it has
      been applied)  or send an  XON (if an  XOFF has been  sent), a program  executes the
      CLRBFI UUO (TTCALL 11, pg. 10-29) or .AXCBI UUO (AUXCAL fn 6, pg. 10-29).

                ________ ______      10.9.5    Flushing Output

      To clear the monitor's output buffers and send a character gobbler to TYMBET (eating
      all the output characters  between the process and the  othr end of the  circuit), a
      program executes the CLRBFO  UUO (TTCALL 12, pg. 10-29) or .AXCBO  UUO (AUXCAL fn 7,
      pg. 10-29).


               ____ ____________ _______      10.10    Data Transmission Methods

      Ports can transmit characters by either of two methods:

              character-by-character (normal) mode
                (see 10-9)
              Block I/O mode (see 10-18)

      All ports are in character-by-character mode unless specifically placed in block I/O
      mode by  the appropriate  AUXCAL.  In  block I/O mode,  whole buffers  of up  to 400
      characters are transferred to/from the base in one operation, whereas in normal mode
      the host and base  handle each character to  pass it across their  interface.  Block
      I/O can realize significant performance improvements and cost reductions.









                                              10-8


            July 3, 1980                             10                                 Port I/O


                     _________ ________            10.11    Character Handling

                       _____            10.11.1    Input

                         ____ _______            10.11.1.1    Case Mapping

            Normally,  the  monitor  maps  all  non-image-state  lowercase  characters  to their
            uppercase equivalents on input:

                    `       mapped to    @
                    a-z     mapped to    A-Z
                    {       mapped to    [
                    |       mapped to    \
                    }       mapped to    ESC
                    tilde   mapped to    ESC

            This action can be disabled by setting LC.NCM in the line characteristics  word (see
            Table 10-26 ).

                         _______ __________            10.11.1.2    Special Characters

                           ____ _______            10.11.1.2.1    Line Editing

            The monitor provides a line-delete and a character-delete character for line editing
            during terminal input.   The actual characters recognized  by the monitor  depend on
            the monitor mode as described on 10-10.

            The character-delete character deletes characters,  one at a time, back to  (but not
            including) the most  recently-typed break character or  until all the  characters in
            the input buffer have been deleted.

            The line-delete  character has the  same effect as  infinitely-many character-delete
            characters: if there are  no break characters in  the buffer, it deletes  the entire
            buffer;  otherwise  it deletes  everything  back  to (but  not  including)  the most
            recently-typed break character.

            The line-editing characters will not have an effect if they arrive
                1)  when the port is in image state
                2)  when the port is in break-on-all mode
                3)  when the port is in full-character-set mode
            In any of the above cases, the  editing character will simply be passed to  the user
            program.  In full-character-set mode, the editing characters are treated  as control
            characters (i.e., they always break).  This is the only effect of full-character-set
            mode, which is entered by setting IO.FCS as shown in Table 10-27 .

                           ______ _________            10.11.1.2.2    Escape Character

            The  monitor provides  an "escape"  character,  which a  user normally  types  (on a
            frame's command  port) to get  the attention  of either the  running program  or the
            monitor.

            Upon receiving an escape character, the monitor acts as follows:

                If the port is in image state, just deposit the escape in its input buffer.

                Otherwise, set the "escape seen" bit (bit LC.ESC of the line characteristics
                word, Table 10-26 ) for the port, and proceed:

                    If the frame that owns the port is enabled for a  software interrupt
                    on escapes,  cause the interrupt,  without depositing the  escape in
                    the input buffer.

                    Otherwise,  perform  a  line-delete operation  on  the  port's input
                    buffer (as if  a line-delete character  had been typed,  but without
                    the echo), and proceed:

                        If this is not the  second escape received, or if it  is the

                                                    10-9


      Port I/O                                 10                         YAMM edition 2.0


                  second, but either (1)  the port is not its  owner's command
                  port, (2) the  port is at command  level, or (3)  the port's
                  owner  is running  with JB.JAC  or JB.JA2  set in  its frame
                  status word (see Table 2-7 ), just deposit the  character in
                  the port's input buffer.  (If the line is at  command level,
                  perform a CLRBFO operation as well).

                  Otherwise, perform a CLRBFI  and a CLRBFO operation  for the
                  port, set its suppress-output bit, force a HALT  command for
                  the frame, and force the port to command level.

                     ______ ___________      10.11.1.2.3    Output Suppression

      The monitor provides a character which  a user can type to suppress  unwanted output
      without stopping the program that is generating it.

      Whenever a suppress-output character is received, the monitor does a CLRBFO  for the
      port, then complements the suppress-output bit for the port.

      The suppress-output bit  LC.NOP lives in the  port's line characteristics  word (see
      Table 10-26 ).  When it is 1, output  calls for the port become no-ops.  The  bit is
      cleared
          1)  by the first output after an INIT on the port
          2)  by any input call
          3)  by SKPINC, SKPINL, .AXSIL, .AXSIC
          4)  by the command interpreter in various situations

      See Table 10-27b for the suppress output characters.

                     ___ __ ____      10.11.1.2.4    End Of File

      In PDP10 mode, IO.EOF is set in the  port's file status bits if a ^Z is read  from a
      terminal (while it is not in the image state).

                     _______ _____      10.11.1.2.5    Monitor Modes

      A frame can run in one of four "monitor modes": PDP10, XEXEC, XEXECJ, and SUDS.  The
      current mode is stored in bits  27-28 of the frame privilege word (see  Table 2-3 ),
      which can be read from the  .GTPRV GETTAB table (see Table 18-4 ), and set  with the
      SETPRV UUO (CALLI -11, pg. 2-2).

      The  monitor  mode  determines  the characters  used  for  various  terminal control
      functions for the frame's command port as indicated in Table 10-27b.

                   _____ __________      10.11.1.3    Break Characters

      A port has a "break-on-all" bit.  When it is set, a non-image-state  input operation
      will return as soon as there is  at least one character in the port's  input buffer;
      when it is cleared, a non-image-state input operation will return as soon as either
          1)  there is at least one break character in the port's input buffer
          2)  the port's input buffer is nearly full
      The break-on-all bit is set by the input operations

              DDTIN UUO (CALLI +1, pg. 10-35)
              .AXSIC UUO (AUXCAL fn 10, pg. 10-34)
              .AXICW UUO (AUXCAL fn 44, pg. 10-30)
              INCHRS UUO (TTCALL 2, pg. 10-31)
              INCHRW UUO (TTCALL 0, pg. 10-30)

      The break-on-all bit is cleared by the input operations

              INPUT UUO (op code 066, pg. 5-11)
                      (not in image mode)
              .AXISL UUO (AUXCAL fn 47, pg. 10-32)
              .AXIWL UUO (AUXCAL fn 46, pg. 10-31)
              INCHSL UUO (TTCALL 5, pg. 10-32)
              INCHWL UUO (TTCALL 4, pg. 10-31)

                                             10-10


            July 3, 1980                             10                                 Port I/O


            The  class  of  characters that  are  considered  to be  "break  characters"  can be
            controlled somewhat by the user.

            Normally, the break  set consists of all  the control characters which  actually get
            placed in the port's input buffer (excluding, therefore, the  line-delete character,
            for example), with the exception of HT.

            If the  "break-on-punctuation" bit  (bit 26  of the  file status  bits) is  set, the
            punctuation characters are also considered break characters:

                    ! " # $ % & ' ( ) _ = - ^ <tilde> { }
                    [ ] ` @ + ; * : < , > . ? / | \

            If the  "tabs-as-breaks" bit is  set, tabs are  counted as control  characters (they
            always cause breaks); if it  is cleared, they are counted as  punctuation characters
            (and only cause breaks if  the break-on-punctuation bit is set).   The tabs-as-break
            bit can be  read and reset  with the .AXTBK  UUO (AUXCAL fn 26, pg. 10-28).   If the
            Backspace Break/Punctuation bit is clear  (the default case), backspace is  always a
            break character.  If it is set (use .AXBBP UUO (AUXCAL fn 66, pg. 10-28) ) backspace
            counts as a punctuation character and causes a break only if break-on-punctuation is
            set.

                         _____ _____            10.11.1.4    Image State

            A  port can  be in  "image state",  in which  case the  characters input  are simply
            deposited  into  the  input  buffer  without  further  examination  by  the monitor.
            Characters received in image state are furthermore flagged so that no special action
            will be taken for them when they  are read by the program (this is important  in the
            case of the escape character) or  echoed by the monitor (this affects  line position
            computation, VT and FF padding and HT echoing).

            An aux port is always in image state; non-aux ports are placed in image state by any
            of the following operations:
                1)  INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOIBN, or .IOBIN)
                2)  .AXI8C, .AXI8S, .AXI8B
            It is cleared (for non-aux ports) whenever
                1)  any  output operation  is performed  and the  data mode  is  not .IOIMG,
                    .IOIBN, or .IOBIN
                2)  a CLOSE is done for the output side of a channel initted to the port and
                    the data mode is not .IOIMG, .IOIBN, or .IOBIN
                3)  the  port  stays  in input  wait  for  more than  20  seconds  without a
                    character arriving and the port's data mode is .IOIMG.

                           ______            10.11.1.4.1    Breaks

            The operations

                    .AXI8C, .AXI8S
                    .AXICW, .AXISC
                    INCHRW, INCHRS
                    DDTIN

            set the port's break-on-all bit.  (.AXI8C  and .AXI8S place the port in  image state
            as well).   They wait until  (or nonskip-return unless)  at least one  character has
            been deposited in the buffer.

            The operations
                1)  .AXI8W
                2)  INCHWL, INCHSL
                3)  .AXIWL, .AXISL
                4)  INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOBIN, .IOIBN)
            clear the port's break-on-all bit.   The break condition is different,  however, for
            them than for non-image mode operations.

            The calls  that nonskip or  skip-return depending  on the presence  of a  break will
            return if the port's input buffer  is empty and skip-return if it contains  at least
            one character (just as if they were the corresponding break-on-all calls).

                                                   10-11


      Port I/O                                 10                         YAMM edition 2.0


      The calls that wait for a break character will return immediately if  any characters
      are in the  port's input buffer.  If  the buffer is empty  at the time of  the call,
      what happens depends on whether the program has set an "image break  character" (see
      10-12).  If  it has,  the call will  return as  soon as one  of those  characters is
      received (or as soon as a timeout clears the image state and a non-image-state break
      character arrives).   If it has  not, the call  will return as  soon as  the monitor
      receives some characters and then  stops receiving characters for a few  seconds, or
      until the input buffer becomes full.

                     _____ _____ _________      10.11.1.4.2    Image Break Character

      To set a port's  image break character, or to  declare that there is no  image break
      character, a program executes the .AXS8B UUO (AUXCAL fn 13, pg. 10-28).

                 _______      10.11.2    Echoing

      A TYMNET  circuit can  be in  deferred or remote  echo mode.   In remote  echo mode,
      echoing is done by the TYMNET remote; in deferred echo mode, echoing is done  by the
      host  computer.  The  idea is  that  the remote  can echo  everything  whose echoing
      behavior  is obvious  (such as  the printing  characters), but  that the  echoing of
      questionable characters (such as control characters) should be left to the host.

      A remote will switch from remote to deferred echo when (1) a control character other
      than carriage-return or linefeed  is typed, (2) a  right brace, tilde, or  rubout is
      typed, (3)  a character is  typed while output  is in progress  at the  terminal, or
      .AXEDE UUO (AUXCAL fn 63, pg. 10-28) is issued.  It preceeds the offending character
      with an  "entering deferred  echo mode"  message (so  that the  host will  know that
      subsequent characters have not yyet been echoed) and stops echoing remotely.  Having
      done  this, the  remote now  seeks  to get  back into  remote echo  mode:  every few
      seconds, it sends a  green ball towards the host;  if a green ball reaches  the host
      and  the  host (1)  is  in input  wait  and (2)  has  finished all  its  echoing and
      outputting on the line, it will  reflect the ball back; when the green  ball reaches
      the remote, it will  send a "leaving deferred echo  mode" message along to  the host
      (so that the host will know that the subsequent characters have already been echoed)
      and will resume echoing characters remotely.

                   _______ ___ ____      10.11.2.1    Turning off Echo

      There are three ways to make the TYMNET/host combination stop echoing characters:
          1)  Log in to TYMNET on a local-copy device (for example an IBM 2741)
          2)  Set half-duplex mode
          3)  Turn off echo
      The three behave in somewhat different ways, as described below.

                     ___________      10.11.2.1.1    Half-Duplex

      When half-duplex mode is set, the  TYMNET line goes into remote echo mode  and stays
      there, and the remote stops echoing; nothing happens in the monitor.  The  result is
      that most normal characters stop  echoing, but that characters with  special echoing
      properties (such as the  character-delete character, which echoes the  characters it
      has deleted, or the horizontal tab character which, if simulated, echoes some number
      of spaces) do not.  Half-duplex mode  is the correct mode to set for  a half-duplex,
      but not line-at-a-time, terminal.

      The "half  duplex" bit (LC.HDX,  see Table 10-26 ),  can be set  with the  .AXHD UUO
      (AUXCAL fn 20, pg. 10-28).

      It can also be set or reset with the command

              TTY [NO] ECHO

      (which does not set the "no echo" bit.).






                                             10-12


            July 3, 1980                             10                                 Port I/O


                           __ ____            10.11.2.1.2    No Echo

            When no echo mode is in effect, the TYMNET line stops echoing characters if it is in
            remote echo mode, and,  once in deferred echo mode,  does not attempt to  leave; the
            monitor stops echoing altogether, with the exception that control-O,  the PDP10-mode
            output-suppress character, is still echoed as ^O.  No-echo mode is the  correct mode
            to set  when reading passwords,  for example, since  setting half-duplex  mode would
            allow deleted characters of the password to be echoed.

            The "no echo" bit is bit 28 of a port's file status bits (see 10-3).

                           _____ ____            10.11.2.1.3    Local Copy

            Local-copy mode is set along with half-duplex by TYMNET wher a user logs in  and his
            or her terminal  identifier character indicates a  local-copy device such as  an IBM
            2741.  Regardless  of the settings  of any  other bits, when  local-copy mode  is in
            effect, the monitor assures
                1)  No free carriage-returns on lines greater than the maximum line-width
                2)  No dollar-sign echo for escapes
                3)  No ^<character> echoes for control characters such as control-Z
                4)  No spaces output for horizontal tabs
                5)  No linefeeds output for VT or FF
                6)  No echoing of deleted characters
            The intent of local-copy mode is to keep the monitor from trying to output while the
            user is trying to type.

                         ______ ___ ______ _____            10.11.2.2    Yellow and Orange Balls

            The remotes send green balls to determine when a host port has gone into input wait.
            It is often useful for a program to know the same thing about the port at  the other
            end of an aux circuit.

            To  do this,  the program  sends a  yellow ball.   The yellow  ball will  follow amy
            characters the program has output along  the circuit.  When it reaches the  host, it
            will "stick" there until the host port goes into input wait, at which point, it will
            be reflected  back as an  orange ball.  (A  yellow ball sent  to a terminal  will be
            reflected back as soon as it arrives).

            The .HBODN  wait condition  of the HIBER  UUO (CALLI +72,  pg. 16-8) sends  a yellow
            ball and waits  until it is  reflected back. This is  a straightforward way  to wait
            until a batch of program output has been absorbed by the host at the other end.

            The  .IAORG  software interrupt  condition  (see TINASS  UUO  (CALLI -42, pg. 16-5))
            will cause a software interrupt when an orange ball is received.

            To  simply send  a yellow  ball, a  program executes  the .AXSYB  UUO (AUXCAL fn 12,
            pg. 10-29).

            The  .IAYEL  software interrupt  condition  (see TINASS  UUO  (CALLI -42, pg. 16-5))
            will cause a software interrupt when a yellow ball is seen, and  suppress reflection
            of the yellow ball  as an orange ball.  The  program which wishes to send  an orange
            ball executes .AXSOB UUO (AUXCAL fn 70, pg. 10-29).
















                                                   10-13


      Port I/O                                 10                         YAMM edition 2.0


                   ______ _____ ____      10.11.2.3    Faking Input Wait

      If a program is  doing interrupt driven terminal  I/O, it will never  actually enter
      input wait  since it will  only ever  do input calls  after itreceives  an interrupt
      indicating that characters  are present.  This will  cause the circuit to  remain in
      deffered echo mode for ever.  If the program is doing line input, the line  will not
      be echoed until the <return> is  entered.  To prevent this, the program  may execute
      the .AXLDE UUO  (AUXCAL fn 11, pg. 10-29) or  the LEVDEF UUO  (CALLI -30, pg. 10-29)
      to tell the monitor to behave as if it were in input wait.

                   _______ __________      10.11.2.4    Special Characters

                     _________      10.11.2.4.1    Backspace

      Normally,  backspace  is a  control  character to  TYMNET,  and forces  a  line into
      deferred-echo mode.  If a terminal can perform backspacing, it is reasonable to echo
      backspaces remotely.  A program can read or set the "remote backspace echo" bit with
      the .AXRBS UUO (AUXCAL fn 54, pg. 10-28).

                     _______ __________      10.11.2.4.2    Deleted Characters

      Normally, the monitor responds  to the first character-delete character  it receives
      by  typing a  backslash and  the character  deleted; to  subsequent character-delete
      characters by typing the characters deleted; and to the  next (non-character-delete)
      character typed by typing a concluding backslash and echoing that character.

      On most display terminals, characters  can be erased by backspacing and  typing over
      them.  The monitor can be made to simply echo a backspace for  each character-delete
      character received by settting  the "backspace for character-delete" bit,  using the
      .AXBS UUO (AUXCAL fn 57, pg. 10-28).

                     ______      10.11.2.4.3    Escape

      In the PDP10 modes,  the monitor normally echoes ESC  (and right brace and  tilde if
      they are being mapped to escape) as a dollar sign (unless the ESC was received while
      the port was in image state, in  which case as ESC is echoed).  This feature  can be
      disabled by setting the "no special escape echo" bit, bit 27 of the file status bits
      (see 10-3).

                 ______      10.11.3    Output

      The character-handling described in  this section applies both to  characters output
      by a program and to characters echoed by the monitor.

                   ______ ____ _______      10.11.3.1    Output Case Mapping

      Normally,  characters are  sent to  TYMNET exactly  as generated  by the  program or
      echoed by the host.  For certain  terminals, it is desirable to have  all alphabetic
      material in  lower case, since  upper case  is used on  these terminals  for special
      characters.  A user of such a terminal may give the command

              TTY [NO] UCO

      meaning "no upper case output", and cause all upper-case alphabetic characters to be
      mapped to lower-case.  This port parameter can also be manipulated by the .AXLCO UUO
      (AUXCAL fn 65, pg. 10-28).












                                             10-14


            July 3, 1980                             10                                 Port I/O


                         _____ __________            10.11.3.2    Image Characters

            For the purposes of this section, an "image character" is a character received while
            the port was in image state (which is being echoed), or an output character from the
            program which was output by
                1)  OUT, OUTPUT, .CHOUT, .CHOPT (data mode = .IOIMG, .IOIBN, .IOBIN)
                2)  .AXPTR, OUTPTR (byte size > 8 and level-9 bit = 1)
                3)  .AXO8, .AXO8I, IONEOU
            These characters are  transferred directly from the  port's output buffer  to TYMNET
            without special processing by the monitor.

                         ____ _____ ___ ________            10.11.3.3    Line Width and Position

            While echoing  and outputting  characters, the  monitor keeps  track of  the current
            position of the terminal's print  head.  (Image characters, however, are  treated as
            having zero width).  This estimate of the print position can be read from the .GTLPS
            GETTAB table (see Table 18-4 ).

            The monitor has a "line width" parameter for each port, and if echoing or outputting
            a character would cause  the print position to exceed  the line width, it  outputs a
            carriage return/linefeed sequence in front of the character.

            The line  width parameter  can be  read or  set with  the .AXWID  UUO (AUXCAL fn 27,
            pg. 10-28).  and the automatic carriage return/linefeed action can be  suppressed by
            setting the  "no free  carriage return"  bit of  the terminal  using the  SETLCH UUO
            (TTCALL 7, pg. 10-26).

                         ___ ___ __ __________            10.11.3.4    HT, VT, FF simulation

            The monitor normally simulates horizontal tabs (unless they are image characters) by
            inserting blanks to the next "tab  stop", tab stops being every 8  characters.  This
            feature can be  disabled for terminals having  HT hardware by setting  the "hardware
            horizontal tabs" bit, (LC.HHT, see Table 10-26 ).

            The monitor normally  simulates vertical tabs and  formfeeds (unless they  are image
            characters) by inserting linefeeds, 4 for each vertical tab and 8 for each formfeed.
            This feature can be disabled for terminal having vertical motion hardware by setting
            the "hardware vertical tabs and formfeeds" bit, (LC.HFF, see Table 10-26 ).

            The echoing (or simulation) of  horizontal tabs, vertical tabs and formfeeds  can be
            suppressed  altogether  by setting  the  "no  HT/VT/FF" bit,  using  the  .AXNTE UUO
            (AUXCAL fn 25, pg. 10-28).  This bit affects only echoing, not output.

                         __ ___ __ _____            10.11.3.5    CR and LF delay

            TYMNET  can supply  delays for  carriage-returns and  linefeeds for  terminals where
            those operations take longer tha  one character time to perform.  The  formulas used
            to compute those delays are given below.  The units are 30ths of a second.

            The "compute CR delay"  bit determines how the delay  parameters A, B, C, and  D are
            used.  If it is set, A, B, and C are used to compute the carriage-return  delay, and
            D is  the (constant)  line feed delay.   If it  is clear, A,  B, and  C are  used to
            compute the linefeed delay, and D is the (constant) carriage-return delay.   The bit
            can be read and set with the .AXCRD UUO (AUXCAL fn 14, pg. 10-28).

            Parameter D  cannot be  set by the  monitor.  Parameters  A, B, and  C can,  but the
            values passed between the monitor and  the user are not the actual  parameter values
            but rather indexes  into tables of the  actual parameter values.   The relationships
            are

             param A-use .AXPA UUO (AUXCAL fn 21, pg. 10-28)
             index          0  1  2  3  4  5  6  7
             value          1  2  4  8  16 32 64 128

             param B-use .AXPB UUO (AUXCAL fn 22, pg. 10-28)
             index          0 1 2 3 4 5 6 7
             value          0 1 2 3 4 5 6 7

                                                   10-15


      Port I/O                                 10                         YAMM edition 2.0


       param C-use .AXPC UUO (AUXCAL fn 23, pg. 10-28)
       index          0  1  2  3  4  5  6  7
       value          0  1  2  3  4  5  7  10

       index          8  9  10 11 12 13 14 15
       value          14 19 26 36 50 69 95 131

                     __ _____ _______      10.11.3.5.1    CR Delay Formula

      Parameters A, B, and C are used to compute the carriage-return delay as follows:

              delay := min( N/A + B, C )

      where <N> is the current line position.

                     __ _____ _______      10.11.3.5.2    LF Delay Formula

      Parameters A, B, and C are used to compute the linefeed delay as follows:

              delay := log2(A)        if N <= 1
                       C-N+B          if 2 <= N < C
                       B              if N >= C

      where <N> is the current line position.

                   ___ ___ __ ______      10.11.3.6    HT, VT, FF delays

      The monitor can supply delays for horizontal tabs, vertical tabs, and formfeeds, for
      terminals  where  those operations  take  longer  than one  character  time  and are
      hardware-implemented.   The  delays  are  produced  by  inserting  rubout characters
      ('177s), and  the units given  below are the  number of rubouts  inserted (character
      times).

      Such padding is not provided if the VT or FFs are image characters.

                     __ ______ ______      10.11.3.6.1    HT Filler Cclass

      The  "filler  class  2"  terminal  characteristic  is  used  to  compute  delays for
      horizontal  tabs.   It  can be  read  and  set with  the  .AXFC2  UUO (AUXCAL fn 31,
      pg. 10-28).  The delays are computed as follows:

              FC2     N<=4    N>4
              0       0       0
              1       1       2
              2       3       5
              3       3       5

      where <N> is the distance to the next tab stop
      assuming that tabs are every 8 characters.

                     __ ___ __ ______ _____      10.11.3.6.2    VT and FF filler class

      The "filler class 1" terminal characteristic is used to compute delays  for vertical
      tabs and  formfeeds.  It  can be  read and  set with  the .AXFC1  UUO (AUXCAL fn 30,
      pg. 10-28).  The delays are computed as follows:

              FC1     VT      FF
              0       0       0
              1       6       12
              2       5       15
              3       20      40







                                             10-16


            July 3, 1980                             10                                 Port I/O


                       ______            10.11.4    Parity

            TYMNET has an even-parity parameter which, when set, causes the level-8 bit  of each
            character transmitted to be discarded and replaced with a generated  even-parity bit
            for the character.

            The monitor always sets the level-8  bit to 0 on 7-bit characters output  to TYMNET,
            and  always sends  the character's  level-8 bit  on 8-bit  output.  A  program must,
            however, clear TYMNET's even-parity parameter  if it wants to send  8-bit characters
            unchanged over TYMNET.

            The even-parity parameter can be  read and reset using the .AXEP  UUO (AUXCAL fn 17,
            pg. 10-28).

                       ____ ____________ _____            10.11.5    Data Transmission Modes

                         ________ ____ ____            10.11.5.1    Katakana Data Mode

            The port  i/o routines  normally treat  image characters  as being  8 bits  wide and
            non-image  characters as  being 7.   If, however,  the port's  data mode  is .IOKAT,
            non-image characters are treated as being 8 bits wide.

            This data  mode is intended  to allow the  handling of the  JIS-8 character  set, an
            8-bit extension of ASCII that has Katakana characters in code positions '241 through
            '377.

            For buffered i/o, the byte size in .IOKAT mode is 9 bits. The level-9 bit  is always
            0 on input and should be always 0 on output.

            Most  port  i/o calls  adjust  appropriately to  Katakana  mode,  transmitting 8-bit
            instead of 7-bit characters.  Those that do not are
                1)  OUTSTR UUO (TTCALL 3, pg. 10-38), .AXOST UUO (AUXCAL fn 52, pg. 10-39)
                2)  DDTIN UUO (CALLI +1, pg. 10-35)
                3)  DDTOUT UUO (CALLI +3, pg. 10-40)
            The monitor decides whether a given character is a special-function character, break
            character, or punctuation character by examining its right 7 bits.  For  example, in
            PDP10 mode, where ^C is the escape character, both '003 and '203 act as escapes.

            If case mapping is in effect, codes '340 through '374 will be mapped to '300 through
            '334, and codes '375 and '376 will be mapped to ESC.

                         _____ ____ ____            10.11.5.2    Paper Tape Mode

            For reading  paper tape or  cassettes, the monitor  supplies "paper tape"  mode.  In
            this mode, regardless of the settings of any other bits,
                1)  Linefeeds are not echoed after each carriage-return
                2)  Rubouts are ignored
                3)  No free carriage-returns  are supplied for  lines over the  maximum line
                    width
                4)  There is no dollar-sign echo for escapes
                5)  There are no ^<character> echoes for control characters such as ^Z
                6)  No spaces are output for horizontal tabs
                7)  No linefeeds are output for VT or FF
            This mode can be entered by setting LC.PTM (see Table 10-26 ).














                                                   10-17


      Port I/O                                 10                         YAMM edition 2.0


                   ____ ____________ _____      10.11.5.3    Port Buffered-I/O Modes

      See 10-7 for  a discussion of  the legal data modes  for buffered I/O  operations on
      ports.   See 6-1  for general  discussion and  definition of  buffered I/O  with any
      device.


               _____ ___      10.12    Block I/O

      The block i/o  facility was designed to  make high-volume data transfer  over TYMNET
      more efficient, mainly by reducing per-character cpu overhead in the host.  Charging
      is adjusted accordingly: at 80 characters per transfer, block i/o costs the  same as
      normal i/o; at the  maximum 400 characters per transfer  it costs less than  half as
      much.

                 _____ ___ ______ ______      10.12.1    Block I/O Buffer Format

      The block input and output AUXCALs are all passed the address of a 101(decimal)-word
      buffer, whose format is

              0-7     8-15    16-23   24-31   32-35 bits
              --------------byte count------------- wd 0
              b0      b1      b2      b3      XXXXX wd 1
              b4      b5      b6      b7      XXXXX wd 2
              ...
              b396    b397    b398    b399    XXXXX wd 100

      On output, <byte  count> specifies the number  of bytes to be  output; it must  be a
      number from 1 to 100 (inclusive).

      On input, the <byte count> is set  by the monitor, and indicates how many  bytes the
      monitor has stored into  the user's buffer.  The  monitor reads the <byte  count> at
      the time the input operation is performed, and requests that many bytes from TYMNET.
      When the input arrives, the monitor copies it all into the user's data area (without
      reexamining  the count).   Since the  monitor reads  ahead, it  is not  advisible to
      change <byte count> from one request to the next.

      Successive words after  <byte count> store the  actual data, 4  left-justified 8-bit
      bytes  per word.   The  rightmost 4  bits  of each  word  are unused  on  output and
      undefined on input.  The  contents of bytes after  the <byte count>th byte  are also
      undefined on input.

                 _____ ___ ____ _____      10.12.2    Block I/O Data Modes

      Block I/O should be performed in Image, Image Binary, or Binary Mode.  The treatment
      of data modes while in block i/o mode differs from the normal treatment.

      The  monitor  will  signal  an  end-of-input  (and  wake  or  interrupt   the  frame
      accordingly) if
          1)  it receives an end-of-transmission message (this is  currently signalled
              by sending a yellow ball)
          2)  a  timeout occurs  (currently,  this means  that  the base  has  gone 16
              seconds without receiving four characters)
          3)  the requested input arrives

      The data mode determines the handling of timeouts and EOTs.

      Timeouts in Image Binary and Binary modes simply cause the monitor to re-request the
      input (i.e., there are no timeouts).  In Image mode, the monitor sets IO.BKT  in the
      port's file  status bits  when it  receives a  timeout message  from the  base, then
      forces an .AXTBI operation on the port.

      EOTs are ignored in Binary mode.   In Image Binary and Image modes, they  signal the
      end of the data: the monitor will not send any more input requests to the base until
      the program has exhausted all the data, by doing block inputs until IO.EOF is set in
      the file status bits.


                                             10-18


            July 3, 1980                             10                                 Port I/O


                       ___________ ____ _________ _____            10.12.3    Interaction with Non-Block Input

            Between the time a block input call  is done on a port and a subsequent  block input
            returns  with IO.EOF  set in  the file  status bits,  the effect  of  nonblock input
            operations is  unpredictable; after the  IO.EOF has been  received, the  program can
            proceed with nonblock input operations (without doing a .AXLBM), though caution must
            be exercised with respect to the data modes.

            The existence  of block i/o  at all is  not known past  the PDP10's base:  the first
            block input starts diverting input characters from the port's normal buffer into the
            block  input buffer,  where they  will continue  to go  until block  input  has been
            terminated, a state which is indicated by a block input call's returning with IO.EOF
            set.

                       ___________ ____ _________ ______            10.12.4    Interaction with Non-Block Output

            It is acceptable  to perform a nonblock  output operation immediately after  a block
            output operation: the nonblock  characters will be output immediately  following the
            block output characters.  Before doing  a block output, however, the  program should
            make sure  that all of  the previous nonblock  output characters have  actually been
            sent (e.g., by doing a HIBER on output complete), since otherwise, the  block output
            characters may intervene among the nonblock.

            The data mode of the port has no effect on block output.

                       _____ ___ ________            10.12.5    Block I/O Tutorial

            To perform block i/o on a port,  the program must first place the port in  block I/O
            mode by executing the .AXEBM UUO (AUXCAL fn 34, pg. 10-41).

            A port will leave block i/o mode  when the program executes a RESET or HANG  UUO, or
            the  port  is  zapped,  or  the  program  executes  the  .AXLBM  UUO  (AUXCAL fn 42,
            pg. 10-41).

            To do block  input, a program executes  the .AXIBW UUO (AUXCAL fn 35,  pg. 10-41) or
            .AXIBS UUO (AUXCAL fn 36, pg. 10-41).  It is  valid for either call to store  a byte
            count of zero and transfer no data.

            In Binary mode, IO.EOF is never set, and in the other modes, it may be  desirable to
            terminate  block  input before  the  "other end"  times  out or  sends  an  EOT.  To
            terminate  block  input without  losing  data,  a program  executes  the  .AXTBI UUO
            (AUXCAL fn 40, pg. 10-42).

            To do block output, a program executes the .AXOB UUO (AUXCAL fn 37, pg. 10-42).

            To do the equivalent of a normal CLRBFO, a program must first execute the .AXTBO UUO
            (AUXCAL fn 41, pg. 10-42)  to stop the  base from working  on any  uncompleted block
            output  for the  port,  then do  a .AXCBO  UUO  (AUXCAL fn 7, pg. 10-29)  to  send a
            character gobbler.


                     ____ ________________________ ____            10.13    Port Creation,Moving,Deletion UUOs
















                                                   10-19


      Port I/O                                 10                         YAMM edition 2.0


                 _______ ___ _______ ____ ____ ______ ____      10.13.1    GETLIN: get command port name (CALLI +34)

              GETLIN  ac,
              only return

      Set c(<ac>)  to the SIXBIT  left-justified device name  of the frame's  command port
      (e.g., SIXBIT /TTY57/ for port 57 (octal)), and return.

      If the frame is detached, c(<ac> left)  will be 0 (instead of SIXBIT /TTY/)  and the
      right half will be the port number of the frame's last command port.

                 _______ ______ _______ ____ __ _____ ______ ___      10.13.2    ATTACH: attach command port to frame (CALLI -6)

              MOVE    ac, [bits,,frame]
              ATTACH  ac,
                error return
              normal return

      bits =  1B17 to suppress forcing the attachee into command mode
              1B16 to suppress doing an EXIT for the detachee

      If c(ac) are 0 or negative, DETACH the calling frame from its port, as follows:

      If the frame has no command port attached, or if a zapper has arrived on the command
      port but has not yet been acted upon, take the error return.

      Otherwise,  detach the  command port  from the  current frame,  and take  the normal
      return.

      If c(ac) are not 0 or negative, then ATTACH the command port as follows:

      If the current  frame is running  detached, or if <frame>  either does not  exist or
      already has a command port attached to it, or if <frame>'s AUN is different from the
      current frame's and  the current frame  does not have  Jacct (JL) license,  take the
      error return.

      Otherwise, detach the current frame's command port and if bit 16 is clear in the ac,
      perform the equivalent of an EXIT  UUO on the current frame.  Then attach  that port
      as <frame>'s command port.  if bit 17 is clear in the ac, print a prompt sequence on
      the TTY and force the frame into command mode.

                 _______ ____ ____ ____ _____ __ _____ ______ _____      10.13.3    RETACH: move port from frame to frame (CALLI -135)

              MOVEI   AC,<ADDR>
              RETACH  AC,
               error return   ;AC/ Table 10-22 
              normal return   ;AC/ port number of port moved
      <ADDR>  source frame FD,,target frame FD
              <bits>,,<port>


      <bits> =
      name    bits    description
      RT.SLV  1B0     attach <port> as aux/slave port rather
                      than as a command port
      RT.MOD  3B2     level to force in target frame after attach
       .RTMSV 0       according to saved command level state
       .RTMCU 1       according to current command level state
       .RTMCO 2       command level
       .RTMUS 3       user level
                      (see 10-1 for
                      discussion of command and user level)
      RT.SIG  1B3     signal a hangup on the source frame

      <port> = a port number or 777777 to indicate the
              command port of the source frame


                                             10-20


            July 3, 1980                             10                                 Port I/O


            RETACH  requires .ARDET  rights over  the source  frame and  .ARATT rights  over the
            target frame.

            If the required access rights are  missing, or if any other of the  conditions named
            in Table 10-22  exists, take the error return.

            RETACH is not allowed if any forced commands are pending on <port>.  Forced commands
            are those  such as KJOB  (i.e., LOGOUT),  LOGIN, DETACH and  HALT which  the monitor
            initiates on  a port; their  action cannot be  altered if system  security is  to be
            maintained.

            If RT.SLV is set, turn <port> into a slave port belonging to the target frame.

            Otherwise, make <port> the command port  of the target frame, and force the  port to
            command/user level according to the RT.MOD field of <bits>.  .RTMSV causes <port> to
            be set to  the level which prevailed  the last time the  target frame had  a command
            port.  .RTMCU preserves the level which prevails on <port> at the moment it is being
            taken away from the source frame.  .RTMCO and .RTMUS force their respective levels.

            If RT.SIG is set, simulate in the source frame the arrival of a zapper on <port>.

            Set AC to the number of the port moved, and take the normal return.

                       _______ ______ __ ___ _______ ______ ____            10.13.4    CREAUX: create an aux circuit (CALLI -44)

                    MOVE    ac, [nozap + [ASCIZ /login string/]]
                    CREAUX  ac,
                      error return
                    normal return

            <nozap> = CX.NZP (1B17) to inhibit zapping the
                    circuit when the process does a
                    RESET UUO (CALLI +0, pg. 5-12)

            <login string> is a valid username, in uppercase
                    ASCII, optionally followed by a colon and host #,
                    followed by a semicolon, carriage-return, or NUL

            Let  <string>  be null.   Copy  characters  from <login  string>  to  <string> until
            <string>  is 29  characters  long, or  until  a carriage-return,  semicolon,  or NUL
            character has been copied.  If  the last character copied was not  a carriage-return
            or semicolon, append a semicolon to <string>.

            If the current process does  not have Auxiliary Circuit (AC) license,  scan <string>
            up to the first colon (or the end of <string>) and compare that initial segment with
            the process's UNM.  If it does not match, take the error return.

            If the  current process does  not have AC  license, and it  already has built  2 aux
            circuits, take the error return.

            Output a login  message to TYMNET,  and pass <string> as  the login string.   If the
            login protocol fails, take the error return.

            Create a DDB for the new port,  error-returning if there is no room for  one; assign
            the port "by console" to the frame, mark it, if CX.NZP was set, so that it  will not
            automatically  be  zapped  on  a  RESET,  store  its  port  number  into  <ac>,  and
            skip-return.











                                                   10-21


      Port I/O                                 10                         YAMM edition 2.0


                                          _____ _____                                           Table 10-22 
                                       ______ _____ _____                                       RETACH error codes


      name     code  description

      RTSAC%   1     insufficient access rights to source frame
      RTSNX%   2     source frame does not exist
      RTTAC%   3     insufficient access rights  to target frame
      RTTNX%   4     target frame does not exist
      RTSNA%   5     specified port not attached to source frame
      RTTAT%   6     target frame already has port attached
      RTSCP%   7     forced command already pending on port
      RTAUX%   10    attaching aux circuit as command port
      RTNRM%   11    no room for new port DDB


                 _______ _____ _______ ____ _______ __ ___      10.13.5    .AXSLV: slave command port (AUXCAL fn 43)

              MOVE    ac, [port,,.AXSLV]
              AUXCAL  ac, addr

      If the frame is detached, or if it is being logged out; or if it already has two aux
      circuits and the process does not have Auxiliary Circuit (AC) license, error-return.

      Detach the frame's command port, mark it so that it will not be automatically zapped
      on a RESET, assign it "by console"  to the frame, set c(<addr>) to its  port number,
      and skip-return.








































                                             10-22


            July 3, 1980                             10                                 Port I/O




                                                _____ ______                                                Table 10-22b
                                             ______ _____ _____                                             CREAUX Error Codes


            name   code  condition

            CREAUX Error Codes (left half)

            CXSUP% 0     supervisor error code in right half - see below.
            CX2AX% 1     too many circuits without Auxiliary Circuit (AC) license; - only 2
                         circuits are allowed per process without Auxiliary Circuit (AC)
                         license.
            CXLOG% 2     not your username without Auxiliary Circuit (AC) license; - must only
                         build circuits to the username the process is logged in as without
                         Auxiliary Circuit (AC) license.
            CXDCB% 3     no room in monitor
            CXNRR% 4     supervisor did not respond to the original request.
            CXNRL% 5     supervisor did not respond to the login message.
            CXNCH% 6     supervisor did not supply a circuit
            CXERR% 7     supervisor error from original request


            CREAUX Error Codes (right half)
                         The following codes are returned in the right half following a CREAUX
                         in which the monitor saw an error message from the supervisor.  These
                         error codes are generated by the supervisor, not the monitor.  This
                         information is copied from comments in the source code for version 28
                         of the Tymnet supervisor.

            CXSFE% 1     format error
            CXSBU% 2     user not in mud
            CXSBM% 3     bad mud
            CXSHU% 4     host unavailable
            CXSDF% 5     downline load or dialout request failure
            CXSTO% 6     timeout
            CXSAB% 7     access barred
            CXSIS% 10    error in ISIS
            CXSLQ% 11    long queue in supervisor


                       _______ ___ __ ___ _______ ______ ____            10.13.6    ZAPCIR: zap an aux circuit (CALLI -45)

                    MOVE    ac, [port]
                    ZAPCIR  ac,
                    only return

            If <port> is negative, zap every aux port belonging to the current frame; otherwise,
            zap port <port> unless it does not belong to the current frame.  Return.

                       _______ ____ ______ _______ __ ___            10.13.7    .AXHNG: send hangup (AUXCAL fn 60)

                    MOVE    ac,[port,,.AXHNG]
                    AUXCAL  ac,
                    only return

            This operation sends a "soft zapper" which hangs up the dataset on the other  end of
            the circuit,  but which leaves  the circuit unaltered.   It was implemented  for the
            initial TYMNET Dial-Out facility.








                                                   10-23


      Port I/O                                 10                         YAMM edition 2.0


                 _______ ____ ___ _______ ____ _______ ______ ____      10.13.8    AUXRED: read aux circuit port numbers (CALLI -46)

              MOVE    ac, [-count,,addr]
              AUXRED  ac,
                error return  ; count <= 0
              normal return

      If <count> <= 0, take the error return.  Otherwise, set <ac> to the number  of ports
      owned by the current  process, store the port  numbers of each port  into successive
      locations starting at  <addr>, and follow the  (possibly null) list of  port numbers
      with a -1.

      If the table supplied is  to short (<count> is less  than the number of ports  + 1),
      store only the first <count> entries, but still set <ac> to the number of ports.

      Skip-return.

                 _______ ____ _____ ___ ______ ______ _____      10.13.9    POLPRT: Poll Ports for Events (CALLI -115)

              MOVE    AC,[<bits>,,<addr>]
              POLPRT  AC,
               error return   ;AC contains <number of ports returned>
              normal return   ;AC contains <number of ports returned>

      where <bits> is a mask of <events> in which the caller
      is interested as shown in Table 10-25 ,
      and where the  argument supplied at <addr> is:

      ADDR:   <count>         ;number of words reserved for
                              ;return data

      Data returned by the UUO is:

      ADDR+1  <events>,,<port>        ;for the first port
       ..     ..
       ..     ..
      ADDR+<count> <events>,,<port>   ;for the last port


      See Table 10-25  for a discussion of interrupt-causing <events> which can occur on a
      port.  The purpose of this UUO is to enable the owner of many aux ports to determine
      what, if any, significant events may have happened since he last looked, and on what
      ports they happened.

      For each of the caller's ports on which any of the <events> specified by  <bits> has
      happened, return <bits>AND<events>,,<port>  to a word  following ADDR and  clear any
      <events> bit returned by the UUO.  Continue returning event bitmasks with their port
      numbers to successive words until either <count> runs out or there are no more ports
      owned by the caller.   Set AC to <number of  ports returned> by POLPRT.   If <count>
      ran out and ports  still remained whose event  bitmasks could not be  returned, take
      the error return; otherwise take the normal return.

















                                             10-24


            July 3, 1980                             10                                 Port I/O


                                                _____ _____                                                 Table 10-25 
                                           ____ ____________ ____                                           Port Event-Status Bits


            name     bit   meaning

            LXRESC   1B0   escape seen
            LXROBS   1B1   orange ball seen
            LXRPSS   1B2   port status message seen
            LXRICL   1B3   input characters lost
            LXROCL   1B4   output characters lost
            LXRCHR   1B5   character seen
            LXRBRK   1B6   break condition seen (any of the following): break char read (normal
                           mode) or image break read (image mode) or break2 char read (break2
                           mode) or block received (block input mode)
            LXRYBS   1B7   yellow ball seen
            LXRGOB   1B10  character gobbler seen


                        _______ ____ ___________ ___ _______ __ ___            10.13.10    .AXPSM: read port-status msg (AUXCAL fn 61)

                    MOVE    ac,[port,,.AXPSM]
                    AUXCAL  ac,
                    only return     ;ac/port status

            The  port status  returned is  4 bits  for which  there is  no  documentation.  This
            operation was implemented for the initial TYMNET Dial-Out facility.


                     ____ ___ ________ _______________ ____            10.14    Port and Terminal Characteristics UUOs

                       _______ ____ ____ _______________ _______ __            10.14.1    GETLCH: read line characteristics (TTCALL 6)

                    GETLCH  addr
                    only return

            where <addr> points to a word containing
                    0 (or a negative number) to specify the
                    current frame's command port,
                    or the port number of the port whose
                    line characteristics are being read

            If c(<addr>) <  0, let <port>  be the current  frame's command port;  otherwise, let
            <port> be c(<addr> right).

            If the <port> does not  belong to the current frame,  or if c(<addr>) was 0  and the
            current frame is  running detached, set c(<addr>)  = 0; otherwise, set  c(<addr>) to
            the port's line characteristics word.

            Return.


















                                                   10-25


      Port I/O                                 10                         YAMM edition 2.0


                                          _____ _____                                           Table 10-26 
                                   ____ _______________ ____                                   Line Characteristics Word


      name     bit(s)contents

      Bits marked "*" can be set with SETLCH
      Bits marked "**" are cleared when read with GETLCH

      LC.ECS   1B2   "command line" exists,will be thrown away
      LC.PSS   1B3   ** a port status message has been seen
      LC.OBS   1B4   ** an orange ball has been seen
      LC.HDX   1B5   * half duplex
      LC.ESC   1B6   ** an escape has been seen
      LC.CRD   1B7   * compute carriage return delay (not LF)
      LC.DFR   1B8   in deferred echo mode
      LC.NOP   1B9   suppress output bit
      LC.NFC   1B10  * no free carriage return
      LC.BRK   1B11  input buffer contains a break character
      LC.AXC   1B12  auxiliary circuit
      LC.NCM   1B13  * no case mapping
      LC.HHT   1B14  * hardware horizontal tabs
      LC.LCP   1B15  local-copy (e.g. 2741) device
      LC.PTM   1B16  * paper tape mode
      LC.HFF   1B17  * hardware VT/FF
      LC.PNO   777777B35 port number


                 _______ ___ ____ _______________ _______ __      10.14.2    SETLCH: set line characteristics (TTCALL 7)

              SETLCH  addr
              only return

      where <addr> points to a word from whose left half
              the command port's line characteristics bits
              are to be set

      Set the settable  bits of the command  port's line characteristics word  (see above)
      from c(<addr> left) and return.

                 _______ ______ ___ ________ _______________ ______ ____      10.14.3    GETTMC: (obs.) get terminal characteristics (CALLI -16)
                 _______ __________ _____ ______ ____      10.14.3    SETTMC: (obsolete) no-op (CALLI -15)

                 _______ ___ ____ ____ ____ ______ ______ ____      10.14.4    SETMOD: set cmnd port file status (CALLI -26)

              MOVEI   ac, file status bits
              SETMOD  ac,
              only return

      Wait for  the command  port to  become inactive.  If  the data  mode field  of <file
      status bits> specifies  an illegal mode  for port i/o,  abort the process  and store
      halt status HT.IDM for the frame.

      Otherwise, set the file status bits from <file status bits> and return.














                                             10-26


            July 3, 1980                             10                                 Port I/O


                                                _____ _____                                                 Table 10-27 
                                           ____ ____ ______ ____                                           TTY: File Status Bits


            name     bit   meaning

            IO.IMP   1B18  improper mode
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large - characters lost or BIO timeout
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file - timeout in BIO or EOF char
            IO.ACT   1B23  device is active
            IO.BK2   1B26  break-on-punctuation bit
            IO.NEE   1B27  no-escape-echo bit
            IO.NEC   1B28  no-echo bit
            IO.FCS   1B29  full-character-set bit
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   77B35 data mode mask



                                                _____ ______                                                Table 10-27b
                                     _______ _____ _ _______ __________                                     Monitor Modes & Special Characters


                                 PDP10   XEXEC

            escape               ^C      ESC*
            character-delete     DEL     ^A
            line-delete          ^U      ^Q
            output-suppress      ^O      FS
            eof                  ^Z      **
            input ^D             ^D      RS

            *  if the no-case-mapping bit is 0, tilde ('176)    and right brace ('175) map to
                                         ESC and hence    have the escape function
            ** there is no character in XEXEC or GEXEC    which sets the end-of-file indication,
                                         but    most software recognizes ^D or ^Z as an
                                         end-of-file indication


                       _______ ___ ____ ____ ______ ____ _____________ _______ __ ___            10.14.5    .AXSFS: set port file status bits (obsolescent) (AUXCAL fn 32)
                       _______ ______ ____ ____ ______ ____ _______ __ ___            10.14.5    .AXCFS: change port file status bits (AUXCAL fn 64)

                    MOVE    ac, [port,,.AXSFS or .AXCFS]
                    AUXCAL  ac, file status bits
                    normal return

            Perform the standard AUXCAL tests (see 10-3).

            Wait for <port> to  become inactive.  If the data  mode field of <file  status bits>
            specifies an  illegal mode for  port i/o,  abort the process  and store  halt status
            HT.IDM for the frame.

            Otherwise, set the port file status  bits as in Table 10-27 from <file  status bits>
            and return.

            The difference  between these functions  is that presently  .AXSFS will not  put the
            port into/out of image state until certain UUO's are issued later; .AXCFS will force
            the proper image state immediately.   In the future this difference  will disappear.
            The best policy is to consider .AXSFS obsolete.





                                                   10-27


      Port I/O                                 10                         YAMM edition 2.0


                 _______ ___ ________________ ___ _______ __ ___      10.14.6    .AXCRD: r/s compute-CR-delay bit (AUXCAL fn 14)
                 _______ ___ _____ ____ ____ _______ __ ___      10.14.6    .AXIBR: r/s input baud rate (AUXCAL fn 15)
                 _______ ___ ______ ____ ____ _______ __ ___      10.14.6    .AXOBR: r/s output baud rate (AUXCAL fn 16)
                 ______ ___ ___________ ___ _______ __ ___      10.14.6    .AXEP: r/s even-parity bit (AUXCAL fn 17)
                 ______ ___ ___________ ___ _______ __ ___      10.14.6    .AXHD: r/s half-duplex bit (AUXCAL fn 20)
                 ______ ___ _________ _ _______ __ ___      10.14.6    .AXPA: r/s parameter A (AUXCAL fn 21)
                 ______ ___ _________ _ _______ __ ___      10.14.6    .AXPB: r/s parameter B (AUXCAL fn 22)
                 ______ ___ _________ _ _______ __ ___      10.14.6    .AXPC: r/s parameter C (AUXCAL fn 23)
                 _______ ___ ___________ ___ _______ __ ___      10.14.6    .AXHNX: r/s host-no-XON bit (AUXCAL fn 24)
                 _______ ___ __ ________ ___ _______ __ ___      10.14.6    .AXNTE: r/s no HT/VT/FF bit (AUXCAL fn 25)
                 _______ ___ ______________ ___ _______ __ ___      10.14.6    .AXTBK: r/s tabs-as-breaks bit (AUXCAL fn 26)
                 _______ ___ ____ _____ _______ __ ___      10.14.6    .AXWID: r/s line width (AUXCAL fn 27)
                 _______ ___ ______ _____ _ _______ __ ___      10.14.6    .AXFC1: r/s filler class 1 (AUXCAL fn 30)
                 _______ ___ ______ _____ _ _______ __ ___      10.14.6    .AXFC2: r/s filler class 2 (AUXCAL fn 31)
                 _______ ___ __________ ___ _______ __ ___      10.14.6    .AXRMX: r/s remote-XON bit (AUXCAL fn 53)
                 _______ ___ ______________ ___ _______ __ ___      10.14.6    .AXRBS: r/s remote-BS-echo bit (AUXCAL fn 54)
                 _______ ___ ___________ ___ _______ __ ___      10.14.6    .AXRVX: r/s reverse-XON bit (AUXCAL fn 55)
                 _______ ___ ________ ____ _______ __ ___      10.14.6    .AXTYP: r/s terminal type (AUXCAL fn 56)
                 ______ ___ __________________ ___ _______ __ ___      10.14.6    .AXBS: r/s BS-for-char-delete bit (AUXCAL fn 57)
                 _______ ___ _____________________ ___ _______ __ ___      10.14.6    .AXERA: r/s Erase-for-char-delete bit (AUXCAL fn 62)
                 _______ ___ _____ _____________ ___ _______ __ ___      10.14.6    .AXEDE: r/s force deferred-echo bit (AUXCAL fn 63)
                 _______ ___ _________________ ___ _______ __ ___      10.14.6    .AXLCO: r/s Lower-case-output bit (AUXCAL fn 65)
                 _______ ___ _________ _________________ ___ _______ __ ___      10.14.6    .AXBBP: r/s backspace break/punctuation bit (AUXCAL fn 66)

              MOVE    ac, [port,,function]
              AUXCAL  ac, addr

      where <function> is one of the function codes

      and <addr> points to either
              1) a word containing a negative number,
                 in which case AUXCAL reads the specified
                 value into c(<addr>)
              2) a word containing a positive number,
                 in which case c(<addr>) is swapped
                 with the current setting of the specified
                 value

      Perform the normal AUXCAL checks (see 10-3).

      Set  <old>  to  the current  value  of  the specified  parameter.   If  c(<addr>) is
      nonnegative, set the specified parameter to c(<addr>).

      Set c(<addr>) to <old> and return.


               _______________________ ____      10.15    Echo,Break,Backpressure UUOs

                 _______ ___ _____ _____ ____ _______ __ ___      10.15.1    .AXS8B: set image break char (AUXCAL fn 13)

              MOVE    ac, [port,,.AXS8B]
              AUXCAL  ac, addr

      If c(<addr> bit 27) is 0, make <port> have no image break character.

      Otherwise, set the port's image break character to c(<addr> bits 28-35).

      Return.










                                             10-28


            July 3, 1980                             10                                 Port I/O


                       _______ ____ ______ ____ _______ __ ___            10.15.2    .AXSYB: send yellow ball (AUXCAL fn 12)

                    MOVE    ac, [port,,.AXSYB]
                    AUXCAL  ac,
                    only return

                       _______ ____ ______ ____ _______ __ ___            10.15.3    .AXSOB: send orange ball (AUXCAL fn 70)

                    MOVE    ac,[port,,.AXSOB]
                    AUXCAL  ac,
                    only return

            This function performs a LEVDEF so that the orange ball is sent immediately.

                       _______ _____ ________ ____ ____ ______ ____            10.15.4    LEVDEF: leave deferred echo mode (CALLI -30)
                       _______ _____ ________ ____ ____ _______ __ ___            10.15.4    .AXLDE: leave deferred echo mode (AUXCAL fn 11)

                    LEVDEF
                    only return

                    MOVE    ac, [port,,.AXLDE]
                    AUXCAL  ac,
                    only return

            As soon as all echoing and output is done on the command port, reflect any  green or
            yellow balls that have arrived  or that subsequently arrive.  (This state  is turned
            off by the receipt of an "entering deferred echo mode" message).

                       _______ _____ _____ ______ _______ ___            10.15.5    CLRBFI: clear input buffer (TTCALL 11)
                       _______ _____ _____ ______ _______ __ __            10.15.5    .AXCBI: clear input buffer (AUXCAL fn 6)

                    CLRBFI

                    MOVE    ac, [port,,.AXCBI]
                    AUXCAL  ac,
                    only return

            (The AUXCAL is a no-op if <port> does not belong to the process).

                       _______ _____ ______ ______ _______ ___            10.15.6    CLRBFO: clear output buffer (TTCALL 12)
                       _______ _____ ______ ______ _______ __ __            10.15.6    .AXCBO: clear output buffer (AUXCAL fn 7)

                    CLRBFO

                    MOVE    ac, [port,,.AXCBO]
                    AUXCAL  ac,
                    only return

            (The AUXCAL is a no-op if <port> does not belong to the process).


                     ____ _____ ____            10.16    Port Input UUOs

            There are 8 different calls to read  a single 7-bit (or 8-bit if the port  data mode
            is Katakana) character from a port. The 8 calls correspond to the 8 combinations of
                1)  [CMD] Whether the call specifies a port or just uses the frame's command
                    port
                2)  [WAIT] Whether the call waits for a break or whether it  skip-returns if
                    there is a break and nonskips if there is not
                3)  [BKA] Whether the port's break-on-all bit is set, so that  any character
                    in the input buffer is considered a break, or whether it is cleared
            The calls are described below and summarized in Table 10-30 .






                                                   10-29


      Port I/O                                 10                         YAMM edition 2.0


                 _______ _____ ____ __________ _______ __      10.16.1    INCHRW: input char [wait/bka] (TTCALL 0)

              INCHRW     addr
              only return

      If the frame is detached, or if there are no characters in the port's  input buffer,
      cause an i/o wait software interrupt if the frame is enabled for one (setting .JBTPC
      to  point  to the  INCHRW),  otherwise wait  until  the frame  is  attached-to  or a
      character arrives.

      Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
      buffer, and store it, right-justified with leading bits zero, into <addr>.

      Return.


                                          _____ _____                                           Table 10-30 
                                   ____ _________ _____ _____                                   Port Character Input Calls


      CMD WAIT BKA  call

      *   *    *    INCHRW UUO (TTCALL 0, pg. 10-30)
          *    *    .AXICW UUO (AUXCAL fn 44, pg. 10-30)
      *        *    INCHRS UUO (TTCALL 2, pg. 10-31)
               *    .AXICS UUO (AUXCAL fn 45, pg. 10-31)
      *   *         INCHWL UUO (TTCALL 4, pg. 10-31)
          *         .AXIWL UUO (AUXCAL fn 46, pg. 10-31)
      *             INCHSL UUO (TTCALL 5, pg. 10-32)
                    .AXISL UUO (AUXCAL fn 47, pg. 10-32)


                 _______ _____ ____ __________ _______ __ ___      10.16.2    .AXICW: input char [wait/bka] (AUXCAL fn 44)

              MOVE    ac, [port,,.AXICW]
              AUXCAL  ac, addr
                error return
              normal return

      where <port> is -1 to specify the frame's command port,
              or the port number of some port owned by
              the frame

      If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
      port does not exist or does not belong to the frame, return.

      If there are no  characters in the port's input  buffer, cause an i/o  wait software
      interrupt if the frame is enabled  for one (setting .JBTPC to point to  the .AXICW),
      otherwise wait until a character arrives.

      Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
      buffer, and store it, right-justified with leading bits zero, into <addr>.

      Skip-return.














                                             10-30


            July 3, 1980                             10                                 Port I/O


                       _______ _____ ____ __________ _______ __            10.16.3    INCHRS: input char [skip/bka] (TTCALL 2)

                    INCHRS     addr
                    no-data return
                    success return

            If the frame is detached, or if there are no characters in the port's  input buffer,
            just return.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

                       _______ _____ ____ __________ _______ __ ___            10.16.4    .AXICS: input char [skip/bka] (AUXCAL fn 45)

                    MOVE    ac, [port,,.AXICS]
                    AUXCAL  ac, addr
                    error/no-data return
                    success return

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there are no characters in the port's input buffer, just return.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

                       _______ _____ ____ ______ _______ __            10.16.5    INCHWL: input char [wait] (TTCALL 4)

                    INCHWL     addr
                    only return

            If the frame is  detached, or if there are  no break characters in the  port's input
            buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
            (setting  .JBTPC  to  point  to  the INCHWL),  otherwise  wait  until  the  frame is
            attached-to or a break character arrives.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Return.

                       _______ _____ ____ ______ _______ __ ___            10.16.6    .AXIWL: input char [wait] (AUXCAL fn 46)

                    MOVE    ac, [port,,.AXIWL]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there  are no  break characters  in the port's  input buffer,  cause an  i/o wait
            software interrupt if the frame is  enabled for one (setting .JBTPC to point  to the
            .AXIWL), otherwise wait until a break character arrives.

                                                   10-31


      Port I/O                                 10                         YAMM edition 2.0


      Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
      buffer, and store it, right-justified with leading bits zero, into <addr>.

      Skip-return.

                 _______ _____ ____ ______ _______ __      10.16.7    INCHSL: input char [skip] (TTCALL 5)

              INCHSL     addr
              no-data return
              success return

      If the frame is  detached, or if there are  no break characters in the  port's input
      buffer, just return.

      Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
      buffer, and store it, right-justified with leading bits zero, into <addr>.

      Skip-return.

                 _______ _____ ____ ______ _______ __ ___      10.16.8    .AXISL: input char [skip] (AUXCAL fn 47)

              MOVE    ac, [port,,.AXISL]
              AUXCAL  ac, addr
              error/no-data return
              success return

      where <port> is -1 to specify the frame's command port,
              or the port number of some port owned by
              the frame

      If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
      port does not exist or does not belong to the frame, return.

      If there are no break characters in the port's input buffer, just return.

      Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
      buffer, and store it, right-justified with leading bits zero, into <addr>.

      Skip-return.

                 _____ _____      10.16.9    Image State

      There are three system calls which place the port into image state and then input an
      8-bit character:

                   _______ _____ ____ ______________ _______ __ __      10.16.9.1    .AXI8C: input char [wait/bka/img] (AUXCAL fn 0)

              MOVE    ac, [port,,.AXI8C]
              AUXCAL  ac, addr
                error return
              normal return

      where <port> is -1 to specify the frame's command port,
              or the port number of some port owned by
              the frame

      If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
      port does not exist or does not belong to the frame, return.

      Place the  port in  image state.   If there are  no characters  in the  port's input
      buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
      (setting .JBTPC to point to the .AXI8C), otherwise wait until a character arrives.

      Remove one 8-bit character from the input buffer, and store it, right-justified with
      leading bits zero, into <addr>.

      Skip-return.

                                             10-32


            July 3, 1980                             10                                 Port I/O


                         _______ _____ ____ ______________ _______ __ __            10.16.9.2    .AXI8S: input char [skip/bka/img] (AUXCAL fn 1)

                    MOVE    ac, [port,,.AXI8S]
                    AUXCAL  ac, addr
                    error/no-data return
                    success return

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Place the  port in  image state.   If there are  no characters  in the  port's input
            buffer, just return.

            Remove one 8-bit character from the input buffer, and store it, right-justified with
            leading bits zero, into <addr>.

            Skip-return.

                         _______ _____ ____ __________ _______ __ __            10.16.9.3    .AXI8B: input char [wait/img] (AUXCAL fn 2)

                    MOVE    ac, [port,,.AXI8B]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Place the port in image state.  If there are no break characters in the port's input
            buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
            (setting .JBTPC  to point  to the .AXI8B),  otherwise wait  until a  break character
            arrives.

            Remove one 8-bit character from the input buffer, and store it, right-justified with
            leading bits zero, into <addr>.

            Skip-return.

                        _______            10.16.10    Testing

            A program can test whether there are break characters or any characters in  a port's
            input buffer.  The calls are shown below.

                        ______ _____            10.16.11    Faking Input

            A program can  force a character string  into a port's input  buffer, in such  a way
            that  the characters  in the  string appear  to have  been typed  by the  user.  The
            program executes the .AXSI UUO (AUXCAL fn 33, pg. 10-34).












                                                   10-33


      Port I/O                                 10                         YAMM edition 2.0


                  _____________ _______ ____ ____      10.16.12    Miscellaneous Command Port UUOs

      A program can read the next character from the command port without removing it from
      the input buffer by executing the REDNXT UUO (CALLI -14, pg. 10-35).

      To wait for a character to arrive at the command port, a program executes the WAITCH
      UUO (CALLI -13, pg. 10-35).

      The CONT UUO (CALLI -125, pg. 10-35) allows a program to switch its command  port to
      user level from command level.  This is useful if a program running  detached wishes
      to receive input from  any terminal that reattaches.   See 10-1 for a  discussion of
      the significance of command and user levels.

      When the  monitor processes a  command line, it  does not remove  the line  from the
      command port's  input buffer,  but merely  sets a  bit which  causes the  next input
      operation to remove the line.  That  bit can be cleared (enabling a program  to read
      the line that caused it to be executed) with the RESCAN UUO (TTCALL 10, pg. 10-35).

      There is a  call originally used by  DDT for input from  the command port  which has
      some  rather  unique  (possibly  useless)  characteristics:  DDTIN   UUO  (CALLI +1,
      pg. 10-35).

                  _______ ____ __ ____ _______ ___      10.16.13    SKPINC: skip if char (TTCALL 13)
                  _______ ____ __ _____ ____ _______ ___      10.16.13    SKPINL: skip if break char (TTCALL 14)
                  _______ ____ __ ____ _______ __ ___      10.16.13    .AXSIC: skip if char (AUXCAL fn 10)
                  _______ ____ __ _____ ____ _______ __ ___      10.16.13    .AXSIL: skip if break char (AUXCAL fn 50)

              SKPINC or SKPINL
              no char or break char present
              char or break char present

              MOVE    ac, [port,,.AXSIC or .AXSIL]
              AUXCAL  ac,
              no char or break char present (or error)
              char or break char present

      In the AUXCAL with  the command port specified, and  in the TTCALL, always  take the
      nonskip return if the frame  is running detached.  (The AUXCAL  also nonskip-returns
      if a port is specified which does not belong to the frame).

      If a character (SKPINC, .AXSIC) or a break character (SKPINL, .AXSIL) is  present in
      the port's input buffer, skip-return; otherwise nonskip-return.

                  ______ ________ _____ _______ __ ___      10.16.14    .AXSI: simulate input (AUXCAL fn 33)

              MOVE    ac, [port,,.AXSI]
              AUXCAL  ac, addr
                error return
              normal return

      Perform the normal AUXCAL error-checking.  (See 10-3).

      Fetch characters one-by-one (as with  ILDB) from the byte pointer stored  at <addr>,
      and deposit the right 8 bits of each into <port>'s input buffer.

      Skip-return.












                                             10-34


            July 3, 1980                             10                                 Port I/O


                        _______ ____ __ _____ ______ ____            10.16.15    REDNXT: peek at input (CALLI -14)

                    REDNXT  ac,
                    buffer-empty return
                    character-present return

            If the command port's input buffer is empty, nonskip-return.

            Otherwise, copy one 7-bit character  from the input buffer to  <ac>, right-justified
            with  leading  bits zero  (without  removing  that character  from  the  buffer) and
            skip-return.

                        _______ ____ ___ _____ ____ ______ ____            10.16.16    WAITCH: wait for input char (CALLI -13)

                    WAITCH
                    only return

            If the command port's input buffer is not empty, just return; otherwise, wait  for a
            character to arrive, then return.

                        _______ ______ _______ ____ _______ ___            10.16.17    RESCAN: rescan command line (TTCALL 10)

                    RESCAN
                    only return

            Clear LC.ECS (see  Table 10-26 ) so that  subsequent input operations will  read the
            characters that  were read by  the monitor in  processing the last  command.  RESCAN
            must precede all terminal input operations in the program; the first  terminal input
            UUO which is executed  while LC.ECS is set  will cause the existing  monitor command
            line (a RUN, GET, START or similar command) to be thrown away.

                        ______ ________ _____ ______ ___            10.16.18    DDTIN: DDT-mode input (CALLI +1)

                    MOVEI   ac, addr
                    DDTIN   ac,
                    only return

            If the frame is running detached, just return.

            If the command port's input buffer  is empty, wait for a character to  arrive.  Then
            copy up to 104 (decimal) ASCII characters from the input buffer to the 21-word block
            starting at <addr>, followed by a NUL character.  (The NUL is always  inserted, even
            if there  are 105  characters or  more in the  port's input  buffer, so  <addr> will
            always point to an ASCIZ string).

            No special processing of character-delete or line-delet characters is done,  and all
            characters are treated as breaks.

                        _____ ___ ____ __ ____ _____ ______ _____            10.16.19    CONT: Put port in user level (CALLI -125)

                    CONT    0,      ;no arguments
                     error return   ;not used
                    normal return

            Put the command port into "user level", and take the normal return.  See 10-1  for a
            discussion of Command and User Levels on a port.












                                                   10-35


      Port I/O                                 10                         YAMM edition 2.0


               ______ ____      10.17    Output UUOs

                 ______ _________ ______      10.17.1    Single Character Output

      There are a  number of system calls  to output a single  character to a  port.  They
      differ according to
          1)  [IMG]  Whether the  character  is output  as  an image  character  or is
              subject to the normal processing (including tab simulation and the like)
              for output characters.
          2)  [IMM] Whether the  UUO's argument is immediate  or whether it  points to
              the character to be output.
          3)  [CMD] Whether the  call applies only to  the command port or  whether it
              takes an argument specifying the port to be used.
      The calls are summarized in Table 10-36  and described in detail below.

                   _______ ______ ____ _____ _______ __      10.17.1.1    OUTCHR: output char [CMD] (TTCALL 1)

              OUTCHR     addr
              only return

      If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
      enabled for one (setting  .JBTPC to point to  the OUTCHR), otherwise wait  until the
      frame is attached-to.

      Let <char>  be c(<addr>).  Deposit  the rightmost 7  bits of <char>  (8 bits  if the
      port's data mode is IO.KAT) into the port's output buffer.

      return.


                                          _____ _____                                           Table 10-36 
                                  ____ _________ ______ _____                                  Port Character Output Calls


      CMD IMM  IMG  Call
      *             OUTCHR UUO (TTCALL 1, pg. 10-36)
      *   *         OUTCHI UUO (TTCALL 16, pg. 10-36)
          *         .AXOCI UUO (AUXCAL fn 51, pg. 10-37)
      *             IONEOU UUO (TTCALL 15, pg. 10-37)
               *    .AXO8 UUO (AUXCAL fn 3, pg. 10-37)
          *    *    .AXO8I UUO (AUXCAL fn 4, pg. 10-37)


                   _______ ______ ____ _________ _______ ___      10.17.1.2    OUTCHI: output char [CMD/IMM] (TTCALL 16)

              OUTCHI     addr
              only return

      If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
      enabled for one (setting  .JBTPC to point to  the OUTCHI), otherwise wait  until the
      frame is attached-to.

      Let <char> be the effective address, <addr>.  Deposit the rightmost 7 bits of <char>
      (8 bits if the port's data mode is IO.KAT) into the port's output buffer.

      return.












                                             10-36


            July 3, 1980                             10                                 Port I/O


                         _______ ______ ____ _____ _______ __ ___            10.17.1.3    .AXOCI: output char [IMM] (AUXCAL fn 51)

                    MOVE    ac, [port,,.AXOCI]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Let <char> be the effective address, <addr>.  Deposit the rightmost 7 bits of <char>
            (8 bits if the port's data mode is IO.KAT) into the port's output buffer.

            return.

                         _______ ______ ____ _________ _______ ___            10.17.1.4    IONEOU: output char [CMD/IMG] (TTCALL 15)

                    IONEOU     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the IONEOU), otherwise wait  until the
            frame is attached-to.

            Let  <char> be  c(<addr>).   Deposit the  rightmost 8  bits  of <char>  as  an image
            character into the port's output buffer.

            return.

                         ______ ______ ____ _____ _______ __ __            10.17.1.5    .AXO8: output char [IMG] (AUXCAL fn 3)

                    MOVE    ac, [port,,.AXO8]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Let  <char> be  c(<addr>).   Deposit the  rightmost 8  bits  of <char>  as  an image
            character into the port's output buffer.

            return.

                         _______ ______ ____ _________ _______ __ __            10.17.1.6    .AXO8I: output char [IMG/IMM] (AUXCAL fn 4)

                    MOVE    ac, [port,,.AXO8I]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Let <char> be the effective address, <addr>.  Deposit the rightmost 8 bits of <char>
            as an image character into the port's output buffer.
                                                   10-37


      Port I/O                                 10                         YAMM edition 2.0


      return.

                 ______ ______      10.17.2    String Output

      There are  4 system  calls to  output a  string to  a port,  corresponding to  the 4
      combinations of
          1)  [CMD] Whether the  call applies only to  the command port or  whether it
              takes an argument specifying the port to be used.
          2)  [PTR]  Whether the  call takes  as its  argument the  address of  a byte
              pointer (thus allowing the call  to be interrupted if the  port's output
              buffer  becomes full,  since the  monitor modifies  the byte  pointer to
              point to the next  character to be processed, and  allowing non-standard
              byte sizes to some extent), or whether it takes the address of  an ASCIZ
              string  (in which  case the  monitor cannot  take an  i/o  wait software
              interrupt in  the middle  of outputting the  string, and  the characters
              must always be 7 bits, even in Katakana mode)
      The calls are summarized in Table 10-39  and described in detail below.

                   _______ ______ ______ _________ _______ __      10.17.2.1    OUTSTR: output string [STR/CMD] (TTCALL 3)

              OUTSTR     addr
              only return

      If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
      enabled for one (setting  .JBTPC to point to  the OUTSTR), otherwise wait  until the
      frame is attached-to.

      For each character in the ASCIZ string pointed to by <addr>,

          If the port's output buffer is full, wait until there is room in  the buffer
          (regardless of whether the frame has enabled an i/o wait software interrupt)
          .

          Deposit the character in the port's output buffer.

      return.
































                                             10-38


            July 3, 1980                             10                                 Port I/O


                                                _____ _____                                                 Table 10-39 
                                          ____ ______ ______ _____                                          Port String Output Calls


            CMD PTR  call

            *        OUTSTR UUO (TTCALL 3, pg. 10-38)
                     .AXOST UUO (AUXCAL fn 52, pg. 10-39)
            *   *    OUTPTR UUO (TTCALL 17, pg. 10-39)
                *    .AXPTR UUO (AUXCAL fn 5, pg. 10-40)
                *    .AXOPC UUO (AUXCAL fn 67, pg. 10-40)


                         _______ ______ ______ _____ _______ __ ___            10.17.2.2    .AXOST: output string [STR] (AUXCAL fn 52)

                    MOVE    ac, [port,,.AXOST]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by
                    the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            For each character in the ASCIZ string pointed to by <addr>,

                If the port's output buffer is full, wait until there is room in  the buffer
                (regardless of whether the frame has enabled an i/o wait software interrupt)
                .

                Deposit the character in the port's output buffer.

            return.

                         _______ ______ ______ _________ _______ ___            10.17.2.3    OUTPTR: output string [PTR/CMD] (TTCALL 17)

                    OUTPTR     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the OUTPTR), otherwise wait  until the
            frame is attached-to.

            For each character in the null-terminated  string pointed to by the byte  pointer in
            c(<addr>),

                If the port's output buffer  is full, cause an i/o error  software interrupt
                if the frame is enabled for one (setting .JBTPC to point to the  OUTPTR, and
                modifying c(<addr>) to  point to the character  that would have  been output
                next), otherwise wait until there is room in the buffer .

                Deposit the  character in the  port's output buffer.   (If the byte  size is
                greater  than  8 bits,  only  the rightmost  8  bits of  each  byte  will be
                deposited, and if the level-9 bit  is 1, the character will be  deposited as
                an image character).

            return.








                                                   10-39


      Port I/O                                 10                         YAMM edition 2.0


                   _______ ______ ______ _____ _______ __ __      10.17.2.4    .AXPTR: output string [PTR] (AUXCAL fn 5)

              MOVE    ac, [port,,.AXPTR]
              AUXCAL  ac, addr
              only return


      where <port> is -1 to specify the frame's command port,
              or the port number of some port owned by
              the frame

      If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
      port does not exist or does not belong to the frame, return.

      For each character in the null-terminated  string pointed to by the byte  pointer in
      c(<addr>),

          If the port's output buffer  is full, cause an i/o error  software interrupt
          if the frame is enabled for one (setting .JBTPC to point to the  .AXPTR, and
          modifying c(<addr>) to  point to the character  that would have  been output
          next), otherwise wait until there is room in the buffer .

          Deposit the  character in the  port's output buffer.   (If the byte  size is
          greater  than  8 bits,  only  the rightmost  8  bits of  each  byte  will be
          deposited, and if the level-9 bit  is 1, the character will be  deposited as
          an image character).

      return.

                   _______ ______ ______ ___________ _______ __ ___      10.17.2.5    .AXOPC: output string [PTR+count] (AUXCAL fn 67)

              MOVE    ac,[port,,.AXOPC]
              AUXCAL  ac,addr
              only return

      addr:   0,,<count>
              <bytepointer>

      If <port> is -1 and  the job is detached, or  if <port> specifies a port  which does
      not exist or belong to the caller, return.

      For each character in the string of length <count> pointed to by <bytepointer>, take
      the same action as described for .AXPTR UUO (AUXCAL fn 5, pg. 10-40).

      Whenever this UUO returns to the caller, <count> and <bytepointer> are updated.

                   _______ ________ ______ ______ ___      10.17.2.6    DDTOUT: DDT-mode output (CALLI +3)

              MOVEI   ac, addr
              DDTOUT  ac,
              only return

      Equivalent to the OUTSTR TTCALL.















                                             10-40


            July 3, 1980                             10                                 Port I/O


                     ____ _____ ___ ____            10.18    Port Block I/O UUOs

                       _______ _____ _____ ___ ____ _______ __ ___            10.18.1    .AXEBM: enter block i/o mode (AUXCAL fn 34)

                    MOVE    ac, [port,,.AXEBM]
                    AUXCAL  ac,
                      error return
                    normal return

            If the base rejected the monitor's request to establish another block i/o port, take
            the error-return; otherwise, place the port in block i/o mode and skip-return.

                       _______ _____ _____ ___ ____ _______ __ ___            10.18.2    .AXLBM: leave block i/o mode (AUXCAL fn 42)

                    MOVE    ac, [port,,.AXLBM]
                    AUXCAL  ac,
                    only return

            If block output is pending on the port, wait for it to complete.  Then take the port
            out of block i/o mode and return.

            (Block input requested but not yet received will be lost).

                       _______ _____ _____ ___ ____ _______ __ ___            10.18.3    .AXIBW: input block and wait (AUXCAL fn 35)

                    MOVE    ac, [port,,.AXIBW]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <addr> is the address of a block i/o buffer
                    (see 10-18)

            If <port> is not in block i/o mode, take the error return.

            If there is no more data for  the port (EOT received or .AXTBI done), set  IO.EOF in
            the file status bits and skip-return.

            If there  is data  waiting for  the port, copy  it into  the user's  buffer, setting
            c(<addr>) to the  number of bytes transferred,  request another block of  input from
            the base (the same size as the last request), and skip-return.

            If no block input request is pending, request c(<addr>) bytes of data from the base.

            Wait for the data to arrive.  If the circuit is zapped while  waiting, error-return;
            otherwise, copy the data received  into the user's buffer, setting c(<addr>)  to the
            number of bytes received, and skip-return.

                       _______ _____ _____ ___ ____ _______ __ ___            10.18.4    .AXIBS: input block and skip (AUXCAL fn 36)

                    MOVE    ac, [port,,.AXIBS]
                    AUXCAL  ac, addr
                      error,no-data return
                    data-present return

            where <addr> is the address of a block i/o buffer
                    (see 10-18)

            If <port> is not in block i/o mode, take the error return.

            If there is no more data for  the port (EOT received or .AXTBI done), set  IO.EOF in
            the file status bits and skip-return.

            If there  is data  waiting for  the port, copy  it into  the user's  buffer, setting
            c(<addr>) to the  number of bytes transferred,  request another block of  input from
            the base (the same size as the last request), and skip-return.


                                                   10-41


      Port I/O                                 10                         YAMM edition 2.0


      If no block input request is pending, request c(<addr>) bytes of data from  the base
      and take the error return.

                 _______ _________ _____ _____ _______ __ ___      10.18.5    .AXTBI: terminate block input (AUXCAL fn 40)

              MOVE    ac, [port,,.AXTBI]
              AUXCAL  ac,
              only return

      If the <port> is not in block i/o mode, just return.

      If no block input is pending, and the program has read all the data in the monitor's
      buffers, just set IO.EOF and return.

      Otherwise, request block  input termination from the  base and return.   The monitor
      will not send any  more input requests to the  base until the program  has exhausted
      all the data, by doing block inputs until IO.EOF is set in the file status bits.

                 ______ _____ ______ _______ __ ___      10.18.6    .AXOB: block output (AUXCAL fn 37)

              MOVE    ac, [port,,.AXOB]
              AUXCAL  ac, addr

      where <addr> is the address of a block i/o buffer
              (see 10-18)

      If a block output is already in progress, wait for it to complete, taking  the error
      return if the port is zapped while waiting.

      Transfer the data from the user's buffer to the port's block output  buffer, request
      a block output operation from the base, and skip-return.

                 _______ _________ _____ ______ _______ __ ___      10.18.7    .AXTBO: terminate block output (AUXCAL fn 41)

              MOVE    ac, [port,,.AXTBO]
              AUXCAL  ac,
              only return

      If <port>  is not in  block i/o mode,  just return; otherwise,  send a  block output
      termination message to the base and return.




























                                             10-42


            July 3, 1980                             11                        Magnetic Tape I/O


                                                 _______ __                                                 Section 11
                                             ________ ____ ___                                             Magnetic Tape I/O

                                             Table of Contents



            SubSection


            11.1     Device Names    11-1

            11.2     Recording Modes    11-1

            11.3     Parity    11-1

            11.4     Recording Density    11-1

            11.5     Begin and End of Tape Bits    11-2

            11.6     Buffered Tape I/O    11-2

            11.7     Dump Tape I/O    11-2
            11.7.1      Non-Integral Word Counts    11-2
            11.7.2      Actual Word/Byte Counts    11-3

            11.8     MTAPE Operations    11-3
            11.8.1      MTAPE: perform magtape functions (op code 072)    11-3
            11.8.1      .CHMTA: perform magtape functions (CHANIO fn 12)    11-3

            11.9     UGETF Information    11-4


            Table

            11-4     MTAPE Functions    11-4
            11-5     UGETF Function Codes    11-5
            11-5b    FTA: File Status Bits    11-5






























                                                    11-i


                                               11                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             11-ii


            July 3, 1980                             11                        Magnetic Tape I/O





                                                 _______ __                                                 Section 11
                                             ________ ____ ___                                             Magnetic Tape I/O





                    ______ _____            11.1    Device Names

            Magnetic tape drives have mnemonics of the form

                    FTkn

            where  <k>  is  a letter  specifying  a  controller  (A for  the  first,  B  for the
            second,...) and  <n> is a  digit specifying a  drive on that  controller (0  for the
            first, 1 for the second,...).


                    _________ _____            11.2    Recording Modes

            The monitor supports four recording modes for magnetic tape i/o:
                1)  a DEC-compatible 7-track mode, in which each word in core is transferred
                    as six 6-bit bytes, with odd parity.
                2)  a DEC-compatible 9-track mode, in which each word in core is transferred
                    as four 8-bit bytes followed by one right-adjusted 4-bit byte,  with odd
                    parity.
                3)  an IBM-compatible 9-track mode, in which the high-order 32 bits  of each
                    word in core are transmitted  as four 8-bit bytes, with odd  parity, and
                    the low-order 4 bits of each word in core are ignored.
                4)  a special  7-track mode, in  which each word  in core is  transmitted as
                    four 6-bit bytes  (the low-order 6 bits  of each of the  four high-order
                    8-bit bytes of the word in core), with either even or odd parity.
            The transfer mode is settable with the MTAPE UUO (op code 072, pg. 11-3).


                    ______            11.3    Parity

            Hardware  restrictions prevent  the use  of even  parity in  other than  the special
            7-track recording mode described above.  The monitor will permit either parity to be
            set in any recording mode,  but will set IO.IMP in  the file status bits as  soon as
            the program tries a  tape operation if even parity  is specified for other  than the
            special 7-track mode.

            The parity bit is bit 26 of the  file status bits.  Even parity is 1 and  odd parity
            0.


                    _________ _______            11.4    Recording Density

            The tape units supported by the monitor have either 6250, 6250/1600, 1600, 1600/800,
            800/556, or 800/556/200  BPI densities, depending on  the unit and  controller.  The
            recording density is specified by bits 27-28 of the file status bits.

            Their interpretation is

                    0  system standard density (presently highest)
                    1  lowest density of which the unit is capable
                    2  medium density "    "    "   "   "    "
                    3  highest density"    "    "   "   "    "

            For units capable of  only one density, the  contents of this field  are irrelevant;
            for units capable of  only two densities, the "medium  density" code is the  same as
            the "lowest density".


                                                    11-1


      Magnetic Tape I/O                        11                         YAMM edition 2.0


      The densities of which a particular unit is capable can be read using the  UGETF UUO
      (op code 073, pg. 8-32).


              _____ ___ ___ __ ____ ____      11.5    Begin and End of Tape Bits

      The "at load point" bit, bit 3 of the word returned by the .UGSTS function of UGETF,
      is cleared  when a  magtape is  initted, then  set or  cleared appropriately  by the
      monitor whenever  it performs  a tape-moving operation.  Manually rewinding  a tape,
      however, will not set the bit.

      The "past end-of-tape marker" bit, bit 4 of the word returned by the .UGSTS function
      of UGETF, is cleared whena magtape is initted, then set or cleared  appropriately by
      the monitor when it performs any tape-moving function other than a  read operations.
      A read operation neither sets not clears the bit.


              ________ ____ ___      11.6    Buffered Tape I/O

      Buffered magtape i/o  can be performed in  ASCII, ASCII line (=ASCII),  image, image
      binary (=image), or binary (=image) mode.

      In ASCII mode, the byte size is 7 bits; in image mode it is 36 bits.   Regardless of
      the mode used, the user's buffer is treated as containing 36 bit words.

      The standard buffer size is 131(decimal) words (128 data + 3 header).


              ____ ____ ___      11.7    Dump Tape I/O

      Either dump or  dump records mode i/o  can be done on  magtape.  In dump  mode, each
      iowd reads or writes one magtape record; in dump records mode, each iowd larger than
      128(decimal) words is broken up into one or more standard-sized  (128-word) requests
      followed (if necessary) by one short request.

      On  input, if  the record  read is  smaller than  the request,  the length  error is
      ignored; if the record  read is larger than the  request, IO.BKT is set in  the file
      status bits, and input terminates at the end of the current iowd.

                ____________ ____ ______      11.7.1    Non-Integral Word Counts

      In  the IBM-compatible  9-track mode  and the  special 7-track  mode, a  program can
      specify a non-integral number of words  to input or output (in dump or  dump records
      mode only).  This  is useful when text  is being read or  written and the  number of
      bytes in a record is not a multiple of 4.

      The monitor maintains  a "byte adjust" value  for this purpose. It  can be set  to a
      value from  0 through 3  to specify how  many bytes fewer  than four times  the word
      count should  be transferred.   For example,  with a word  count of  100 and  a byte
      adjust  value of  1, 99  full words  would be  written (366  bytes) followed  by the
      high-order 3 bytes of the 100th word.

      The byte adjust value is specified along with the transmission mode using  the MTAPE
      UUO (op code 072,  pg. 11-3).  If a  program attempts to  set a nonzero  byte adjust
      and the data mode is not dump or dump records, MTAPE will force the byte adjust to 0
      and set IO.IMP in the file status bits.












                                              11-2


            July 3, 1980                             11                        Magnetic Tape I/O


                      ______ _________ ______            11.7.2    Actual Word/Byte Counts

            The number of words (or bytes in  IBM mode) actually read by an input  operation can
            be obtained with the .UGCNT function of the UGETF UUO (op code 073, pg. 8-32).


                    _____ __________            11.8    MTAPE Operations

            Most  magtape  control  functions  are  performed  by  the  MTAPE  UUO (op code 072,
            pg. 11-3).  The functions performed are described in Table 11-4 .

                      ______ _______ _______ _________ ___ ____ ____            11.8.1    MTAPE: perform magtape functions (op code 072)
                      _______ _______ _______ _________ _______ __ ___            11.8.1    .CHMTA: perform magtape functions (CHANIO fn 12)

                    MTAPE   channel, function
                    only return

                    MOVE    ac, [.CHMTA,,channel]
                    CHANIO  ac, function
                    only return

            where <function> is a function code from Table 11-4 

            If <channel>  is not initted,  If <channel>  is not initted,  abort the  process and
            store halt status  HT.IUC for the  frame.  If the device  initted is not  a magtape,
            just return;  otherwise, wait for  the device to  become inactive, then  perform the
            specified function.

            If the drive is past the EOT marker or any of the error bits (bits 18-22) are set in
            the  file status  bits, cause  an  i/o-error software  interrupt if  the  process is
            enabled for one.  Return.





































                                                    11-3


      Magnetic Tape I/O                        11                         YAMM edition 2.0


                                          _____ ____                                           Table 11-4 
                                        _____ _________                                        MTAPE Functions


      name     code  function

      .MTWAT   0     wait for i/o completion
      .MTREW   1     rewind
      .MTEOF   3     write tape mark
      .MTSKR   6     skip forward 1 record
      .MTBSR   7     backspace 1 record
      .MTEOT   10    go to logical end of tape
      .MTUNL   11    rewind and unload
      .MTBLK   13    erase gap
      .MTSKF   16    skip forward 1 file
      .MTBSF   17    backspace 1 file
      .MTDEC   100   set DEC 9-track mode
      .MTIC0   101   set IBM 9-track mode, byte adjust 0
      .MTIC1   102   set IBM 9-track mode, byte adjust 1
      .MTIC2   103   set IBM 9-track mode, byte adjust 2
      .MTIC3   104   set IBM 9-track mode, byte adjust 3
      .MT7E0   201   set special 7-track mode, byte adjust 0
      .MT7E1   202   set special 7-track mode, byte adjust 1
      .MT7E2   203   set special 7-track mode, byte adjust 2
      .MT7E3   204   set special 7-track mode, byte adjust 3



              _____ ___________      11.9    UGETF Information

      The  UGETF  UUO  (op code 073,  pg. 8-32)  is  used  to  obtain  various  pieces  of
      information about the status of a process's magtape i/o.


              UGETF <channel>,<addr>
              only return

      ADDR:   <count>,,<function>
              ...
              data returned here
              ...

      If <function> is not one of the codes described in Table 11-5  set <ADDR> to  -1 and
      return.

      If  <function>  is  .UGCNT or  .UGSTS,  ignore  <count>.  Return  data  as  shown in
      Table 11-5 .





















                                              11-4


            July 3, 1980                             11                        Magnetic Tape I/O


                                                _____ ____                                                 Table 11-5 
                                            _____ ________ _____                                            UGETF Function Codes


            name     code  function

            .UGCNT   0     return byte/word count of last input
            .UGSEN   1     return drive sense data
            .UGSTS   2     return drive status data - for .UGSEN, return up to 6 words of unit
                           sense data; for .UGSTS, return 1 word of compacted sense data as
                           follows:
                           MT.PRO    1B0   write protected
                           MT.TAB    3B2   TU A & B
                           MT.LDP    1B3   load point
                           MT.EOT    1B4   end of tape indicator
                           MT.IBM    1B5   IBM compatible unit
                           MT.7TR    1B12  7 track capability
                           MT6250    1B13  6250 bpi capability
                           MT1600    1B14  1600 bpi
                           MT800     1B15  800 bpi
                           MT556     1B16  556 bpi
                           MT200     1B17  200 bpi



                                                _____ _____                                                Table 11-5b
                                           ____ ____ ______ ____                                           FTA: File Status Bits


            name     bit   meaning

            IO.IMP   1B18  improper mode - even parity set in 9-track mode or attempt to set a
                           nonzero byte adjust while data mode not dump or dump records
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large - input record on tape longer than IOWD specified
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.EVP   1B26  even parity
            IO.DEN   3B28  recording density - 0 = default density - 1 = lowest density - 2 =
                           middle density - 3 = highest density
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   77B35 data mode mask























                                                    11-5


      Magnetic Tape I/O                        11                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              11-6


            July 3, 1980                             12                        Card Reader Input


                                                 _______ __                                                 Section 12
                                             ____ ______ _____                                             Card Reader Input

                                             Table of Contents



            SubSection


            12.1     ASCII Mode Input    12-1

            12.2     Image Mode Input    12-1

            12.3     Binary Mode Input    12-1


            Table

            12-2     026 Card Codes    12-2
            12-2b    029 Card Codes    12-2
            12-3     CDR: File Status Bits    12-3














































                                                    12-i


                                               12                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             12-ii


            July 3, 1980                             12                        Card Reader Input





                                                 _______ __                                                 Section 12
                                             ____ ______ _____                                             Card Reader Input




            Card  input can  be performed  in ASCII,  ASCII line  (=ASCII), image,  image binary
            (=image), or binary mode.

            The standard buffer size for buffered i/o is 30 words, regardless of the input mode.

            There is no special action on CLOSE or RELEAS.

            The card reader has the device mnemonic CDR.


                    _____ ____ _____            12.1    ASCII Mode Input

            Each card is read as 80 7-bit ASCII characters, followed by a carriage  return ('15)
            and a linefeed ('12).

            Two card codes  are supported, one  for 026 (see Table 12-2 )  and one for  029 (see
            Table 12-2b) keypunches.  Initially, the 029 code is assumed.

            The following special codes are recognized if they appear in column 1 of a card:

                    12-11-0-1-6-7-8-9       end-of-file
                    12-2-4-8                switch to 026 code
                    12-0-2-4-6-8            switch to 029 code


                    _____ ____ _____            12.2    Image Mode Input

            Each  card is  read as  80  12-bit bytes  (one per  column).  No  special  codes are
            recognized, but the hardware end-of-file condition will result in IO.EOF being set.


                    ______ ____ _____            12.3    Binary Mode Input

            Cards in binary mode have the format:

                    col 1  row 6-9  7-9 punch
                    col 1  row 12-3 word count
                    col 2           checksum
                    col 3-5         first word of data
                    col 6-8         second word of data
                    ...

            On binary mode input, the monitor  saves the checksum and word count,  then attempts
            to read the specified number of words from the card reader, three card columns  to a
            word.

            If the input  record is too  long to fit  into the user's  buffer, or if  a hardware
            end-of-file indication is  received before the specified  number of words  have been
            read, IO.BKT is set in the file status bits.  If the record can all be read, but the
            checksum computed by  the monitor differs  from that read  from the card,  IO.DTE is
            set.  Whether an error occurred or not, the checksum and word count read  are stored
            as the left and right halves of the third word (word 2) of the user's buffer.







                                                    12-1


      Card Reader Input                        12                         YAMM edition 2.0


                                          _____ ____                                           Table 12-2 
                                         ___ ____ _____                                         026 Card Codes


                              none    12      11      0
                      none    space   +       -       0
                      1       1       A       J       /
                      2       2       B       K       S
                      3       3       C       L       T
                      4       4       D       M       U
                      5       5       E       N       V
                      6       6       F       O       W
                      7       7       G       P       X
                      8       8       H       Q       Y
                      9       9       I       R       Z
                      8-2     _       ?       :       ;
                      8-3     =       .       $       ,
                      8-4     @       )       *       (
                      8-5     ^       ]       [       "
                      8-6     '       <       >       #
                      8-7     \       !       &       %



                                          _____ _____                                          Table 12-2b
                                         ___ ____ _____                                         029 Card Codes


                              none    12      11      0
                      none    space   &       -       0
                      1       1       A       J       /
                      2       2       B       K       S
                      3       3       C       L       T
                      4       4       D       M       U
                      5       5       E       N       V
                      6       6       F       O       W
                      7       7       G       P       X
                      8       8       H       Q       Y
                      9       9       I       R       Z
                      8-2     :       [       !       ]
                      8-3     #      .       $       ,
                      8-4     @       <       *       %
                      8-5     '       (       )       _
                      8-6     =       +       ;       >
                      8-7     "       ^       \       ?























                                              12-2


            July 3, 1980                             12                        Card Reader Input


                                                _____ ____                                                 Table 12-3 
                                           ____ ____ ______ ____                                           CDR: File Status Bits


            name     bit   meaning

            IO.IMP   1B18  improper mode - no 7-9 punch in column 1 on binary input
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file - (12-11-0-1-6-7-8-9) card read in ASCII mode or hardware
                           EOF signal from card reader in any mode
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   77B35 data mode mask



















































                                                    12-3


      Card Reader Input                        12                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              12-4


            July 3, 1980                             13                      Line Printer Output


                                                 _______ __                                                 Section 13
                                            ____ _______ ______                                            Line Printer Output

                                             Table of Contents



            SubSection


            13.1     Output    13-1

            13.2     Form Feeds    13-1

            13.3     KS2020 Line Printer Forms Control    13-1





















































                                                    13-i


                                               13                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             13-ii


            July 3, 1980                             13                      Line Printer Output





                                                 _______ __                                                 Section 13
                                            ____ _______ ______                                            Line Printer Output




            Line printer output can be performed in ASCII, ASCII line (=ASCII), or image mode.

            The standard buffer size for buffered output is 28 words (25 data+3 header),  or 125
            ASCII characters.

            The line printer has the device mnemonic LPT.


                    ______            13.1    Output

            In line printer output, the  contents of the user's buffer are  transferred, without
            processing, directly to the line printer.   In ASCII mode, the byte size is  7 bits;
            in image mode, the  byte size is 36  bits, but each word  is still treated as  if it
            contained five 7-bit bytes, left-justified.


                    ____ _____            13.2    Form Feeds

            The monitor normally supplies  a free carriage-return, formfeed sequence  before the
            first  output after  the line  printer is  initted or  CLOSEd.  This  action  can be
            suppressed by setting the "no free formfeed" bit, bit 29 of the file status bits.


                    ______ ____ _______ _____ _______            13.3    KS2020 Line Printer Forms Control

            The LP20  line printer which  is available  on systems with  a KS2020  processor has
            provisions  for  user  control  of the  forms  size  and  other  vertical formatting
            parameters.  The LP20 has a Direct Access Vertical Format Unit, or DAVFU,  which can
            be programmed  from the host.   The user  program can accomplish  this by  using the
            MTAPE UUO on a channel on which the LPT is initted:

                    MTAPE   ch,CLIST
                     error return           ;error in command list
                    normal return

            where <ch> is the channel on which the device is initted,
            and
            CLIST: block N  ;DAVFU command list
            is an arbitrary-length block of data which is a
            DAVFU "program".

            The CLIST commands  allow the user to  set or reset stops  on any of the  12 control
            channels which govern page up-spacing.  A command is also provided to  allow setting
            form size and page length.  Each CLIST command occupies one PDP-10 36-bit word.  The
            CLIST must terminate with the RELOAD DAVFU command.

            A detailed description of the commands follows:

              OPCODE                        COMMAND
              -----   -------------------------------------------------------
               0 0    CLEAR STOPS ON MASKED CHANNELS from first line to last line.
               0 1    SET STOPS ON MASKED CHANNELS from first line to last line.
               1 0    RESET TOP OF FORM
               1 1    RELOAD DAVFU and terminate command list


                                 C O M M A N D     B I T S
            ____________________________________._________________________________
                              1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3|
                                                    13-1


      Line Printer Output                      13                         YAMM edition 2.0


      0 1 2 3-5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5|
      _.___.___._______________________|_._______________._._______________|
      x|0 0| x |     channel mask      |x|  first line   |x|   last line   |
      _|___|___|_______________________|_|_______________|_|_______________|
      x|0 1| x |     channel mask      |x|  first line   |x|   last line   |
      _|___|___|_______________________|_|_______________|_|_______________|
      x|1 0| x |x x x x x x x x x x x x|x|0 0 0 0 0 0 0 1|x|0 0 0 0 0 0 0 1|
      _|___|___|_______________________|_|_______________|_|_______________|
      x|1 1| x |x x x x x x x x x x x x|x|  page length  |x|   form size   |
      _|___|___|_______________________|_|_______________|_|_______________|
       |CMD|   |1 1 1                  |
       +---+   |2 1 0 9 8 7 6 5 4 3 2 1|
               |   CHANNEL  NUMBERS    |
               +-----------------------+

      Note:
          1)  channel numbers increase from right to left, not in  normal bit-ordering
              sequence from left to right.
          2)  last line and form size must be less than or equal to 143
          3)  first line must be positive and less than or equal to last line
          4)  page length must be greater than 8 but less than or equal to form size
          5)  the RESET TOP of  FORM command must be  the only command in  the command
              list, if it is  used at all.  Its first  and last line fields  should be
              set to 1.












































                                              13-2


            July 3, 1980                             14                           Paper Tape I/O


                                                 _______ __                                                 Section 14
                                               _____ ____ ___                                               Paper Tape I/O

                                             Table of Contents



            SubSection


            14.1     Leaders and Trailers    14-1

            14.2     ASCII Mode I/O    14-1

            14.3     Image Mode I/O    14-1

            14.4     Image Binary Mode I/O    14-1

            14.5     Binary Mode I/O    14-2


            Table

            14-2     CDR: File Status Bits    14-2












































                                                    14-i


                                               14                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             14-ii


            July 3, 1980                             14                           Paper Tape I/O





                                                 _______ __                                                 Section 14
                                               _____ ____ ___                                               Paper Tape I/O




            Paper tape i/o can be performed in ASCII, ASCII line (=ASCII), image,  image binary,
            or binaryy mode.

            The standard buffer size for buffered-mode input and output is 35 words (32 data + 3
            header), regardless of the data mode.

            The paper  tape reader has  the device mnemonic  PTR; the paper  tape punch  has the
            mnemonic PTP.


                    _______ ___ ________            14.1    Leaders and Trailers

            The  monitor inserts  128 NUL  characters (no  punches) as  leader before  the first
            output  after the  device is  initted, and  128 NULs  trailer characters  after each
            CLOSE.


                    _____ ____ ___            14.2    ASCII Mode I/O

            The byte size is 7 bits.

            On output, the  monitor takes 7-bit ASCII  characters (left-justified, 5 to  a word)
            from the  user's buffer, computes  the necessaryy level-8  bit for even  parity, and
            punches the resultant  8-bit character.  Formfeeds are  output followed by  16 NULs,
            HTs and VTs are followed by a rubout character, and NULs are ignored (not punched).

            On input, the 8-bit codes '000,  '200, and '377 are ignored; otherwise, the  right 7
            bits  of  each  frame  read  are stored  in  the  user's  buffer,  left-justified, 5
            characters to a word.  The phyysical end-of-tape causes IO.EOF to be set in the file
            status bits.


                    _____ ____ ___            14.3    Image Mode I/O

            The byte size is 36 bits.

            On output, the low-order 8 bits of each word in the user's buffer are output without
            processing byy the monitor.

            On input, the 8-bit frames read are stored, one per word, right-justified,  into the
            user's buffer,  with the high-order  28 bits of  each word set  to 0.   The physical
            end-of-tape causes IO.EOF to be set in the file status bits.


                    _____ ______ ____ ___            14.4    Image Binary Mode I/O

            The byte size is 36 bits.

            On output, each word  in the user's buffer is  split into siz 6-bit bytes,  and each
            byyte is or-ed with '200 before being punched.  For example,

                    010203,,040506

            would be punched as

                    '201, '202, '203, '204, '205, '206

            On input, each frame is truncated  to 6 bits by discarding the high-order  two bits,
            and the resultant characters are packed 6 to a word into the user's buffer.
                                                    14-1


      Paper Tape I/O                           14                         YAMM edition 2.0


              ______ ____ ___      14.5    Binary Mode I/O

      As in image binary mode, the byte  size is 36 bits, and each 36-bit word  is encoded
      as six 6-bit characters, with '200  or-ed in on output, and the high-order  two bits
      stripped on input.

      Binary mode buffered output is like image binary except that each bufferful  of data
      is punched preceded byy a word of the form

              checksum,,word count

      where the checksum is computed by the  monitor from the data in the buffer,  and the
      word count is the number of words in the buffer.

      On input, the first six characters read from each record are assumed to encode a

              checksum,,word count

      word.   The checksum  is  saved, then  enough characters  are  read to  make  up the
      specified number of words.   If an input record is  too long to fit into  the user's
      buffer, or  if the physical  end-of-tape is reached  before the specified  number of
      characters has been read, IO.BKT is set in the file status bits.  If the  record can
      all be read, but the checksum computed by the monitor differs from that read  at the
      start  of the  record, IO.DTE  is set  in the  file status  bits.  Whether  an error
      occurred or not, the  checksum and word count read  from the tape are stored  as the
      left and right halves of the third word (word 2) of the user's buffer.


                                          _____ ____                                           Table 14-2 
                                     ____ ____ ______ ____                                     CDR: File Status Bits


      name     bit   meaning

      IO.IMP   1B18  improper mode - no 7-9 punch in column 1 on binary input
      IO.DER   1B19  device error
      IO.DTE   1B20  data error
      IO.BKT   1B21  block too large
      IO.ERR   17B21 error bit mask
      IO.EOF   1B22  end of file - (12-11-0-1-6-7-8-9) card read in ASCII mode or hardware
                     EOF signal from card reader in any mode
      IO.ACT   1B23  device is active
      IO.SYN   1B30  synchronous i/o
      IO.UWC   1B31  user supplied word count
      IO.MOD   77B35 data mode mask























                                              14-2


            July 3, 1980                             15                           Plotter Output


                                                 _______ __                                                 Section 15
                                               _______ ______                                               Plotter Output

                                             Table of Contents



            SubSection


            15.1     Output    15-1

            15.2     Hardware Action    15-1


            Table

            15-1     Plotter command bits    15-1
            15-2     PLT: File Status Bits    15-2

















































                                                    15-i


                                               15                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             15-ii


            July 3, 1980                             15                           Plotter Output





                                                 _______ __                                                 Section 15
                                               _______ ______                                               Plotter Output




            Plotter output can be performed  in ASCII, ASCII line (=ASCII), image,  image binary
            (=image), and binary (=image) modes.

            The standard buffer size for buffered output id 38 words (35 data + 3 header).

            The plotter has the device mnemonic PLT.


                    ______            15.1    Output

            The  plotter receives  a stream  of 6-bit  bytes from  the monitor.   In  ASCII mode
            output, the byte size is 7 bits,  and the low-order 6 bits of each character  in the
            user's buffer are  transmitted to the plotter.   In image, image binary,  and binary
            modes, the byte size is 36 bits,  and each word in the user's buffer is  broken into
            six 6-bit bytes which are transmitted to the plotter.


                    ________ ______            15.2    Hardware Action

            The  six-bit  characters  received  by  the  plotter  are  interpreted  as  shown in
            Table 15-1 .

            The raise-pen  and lower-pen commands  should not  be combined in  the same  byte as
            positioning commands, since the motion will begin before the pen has been  raised or
            lowered.  The effect of contradictory commands in the same byte is unpredictable.


                                                _____ ____                                                 Table 15-1 
                                            _______ _______ ____                                            Plotter command bits


            bit    meaning

            0      raise pen
            1      lower pen
            2      -x (drum up)
            3      +x (drum down)
            4      -y (carriage left)
            5      +y (carriage right)




















                                                    15-1


      Plotter Output                           15                         YAMM edition 2.0


                                          _____ ____                                           Table 15-2 
                                     ____ ____ ______ ____                                     PLT: File Status Bits


      name     bit   meaning

      IO.IMP   1B18  improper mode
      IO.DER   1B19  device error
      IO.DTE   1B20  data error
      IO.BKT   1B21  block too large
      IO.ERR   17B21 error bit mask
      IO.EOF   1B22  end of file
      IO.ACT   1B23  device is active
      IO.SYN   1B30  synchronous i/o
      IO.UWC   1B31  user supplied word count
      IO.MOD   77B35 data mode mask




















































                                              15-2


            July 3, 1980                             16            Interrupt System and Sleeping


                                                 _______ __                                                 Section 16
                                       _________ ______ ___ ________                                       Interrupt System and Sleeping

                                             Table of Contents



            SubSection


            16.1     Trapping Arithmetic and Stack Overflow    16-1
            16.1.1      SETTR1: set arithmetic overflow instruction (CALLI -40)    16-1
            16.1.2      SETTR2: set stack over/underflow instruction (CALLI -41)    16-1

            16.2     APRENB Interrupt System    16-1
            16.2.1      APRENB: enable APRENB trapping (CALLI +16)    16-2

            16.3     INTADR Interrupt System    16-3
            16.3.1      Initializing the INTADR System    16-3
            16.3.2      Assigning Causes to Channels    16-4
            16.3.3      INTADR: initialize INTADR system (CALLI -33)    16-5
            16.3.4      TINASS: assign port interrupt causes (CALLI -42)    16-5
            16.3.5      INTASS: assign general interrupt causes (CALLI -36)    16-6
            16.3.6      INTRMT: (obsolete) assign I/O software interrupts (CALLI -52)    16-6
            16.3.7      SETTIM: set timer interrupt (CALLI -37)    16-6
            16.3.8      INTENB: enable and disable INTADR channels (CALLI -34)    16-7
            16.3.9      REDPIP: read in-progress bits (CALLI -43)    16-7
            16.3.10     INTACT: cause and uncause interrupts (CALLI -35)    16-7
            16.3.11     DISMIS: dismiss INTADR interrupts (CALLI -23)    16-8

            16.4     Sleeping    16-8
            16.4.1      HIBER: wait for event (CALLI +72)    16-8
            16.4.2      SLEEP: wait for N seconds (CALLI +31)    16-9
            16.4.3      WAKE: wake sleeping frame (CALLI +73)    16-9

            16.5     APRENB/INTADR Interaction    16-9


            Table

            16-3     APRENB Interrupt Bit Definitions    16-3
            16-4     Port Interrupt Cause Codes    16-4
            16-4b    General Interrupt Cause Codes    16-4
            16-7     INTRMT error codes    16-7
























                                                    16-i


                                               16                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             16-ii


            July 3, 1980                             16            Interrupt System and Sleeping





                                                 _______ __                                                 Section 16
                                       _________ ______ ___ ________                                       Interrupt System and Sleeping





                    ________ __________ ___ _____ ________            16.1    Trapping Arithmetic and Stack Overflow

            On encountering an  integer or floating-point overflow  condition in user  mode, the
            KI-10 hardware executes  the instruction found in  location 421 of the  user process
            table; on encountering stack overflow or underflow it executes the instruction found
            in location 422.  This provides an efficient means for the user program to trap such
            errors without incurring monitor overhead.  | The monitor normally stores a  JFCL as
            the arithmetic overflow trap instruction.  To set the instruction to be  executed on
            integer or floating-point arithmetic  overflow, the program executes the  SETTR1 UUO
            (CALLI -40, pg. 16-1).

            The monitor normally stores an instruction which will cause it to abort  the current
            frame as the  stack over/underflow trap instruction.   To set the instruction  to be
            executed  on  stack  over  or  underflow,  the  program  executes  the   SETTR2  UUO
            (CALLI -41, pg. 16-1).

                      _______ ___ __________ ________ ___________ ______ ____            16.1.1    SETTR1: set arithmetic overflow instruction (CALLI -40)

                    MOVE    ac, [trap instruction]
                    SETTR1  ac,
                      error return
                    normal return

            Set <ac> to  the previous trap  instruction.  If <trap  instruction> is 0,  take the
            error return; if only <trap instruction>'s op  code field is 0, store a JFCL  as the
            trap instruction and take the normal return; otherwise, store <trap  instruction> as
            the trap instruction and take the normal return.

                      _______ ___ _____ ______________ ___________ ______ ____            16.1.2    SETTR2: set stack over/underflow instruction (CALLI -41)

                    MOVE    ac, [trap instruction]
                    SETTR2  ac,
                      error return
                    normal return

            Set <ac> to  the previous trap  instruction.  If <trap  instruction> is 0,  take the
            error return; if only <trap instruction>'s op code field is 0, store  an instruction
            which will cause the monitor to  abort the process as the trap instruction  and take
            the normal return; otherwise, store  <trap instruction> as the trap  instruction and
            take the normal return.


                    ______ _________ ______            16.2    APRENB Interrupt System

            The APRENB interrupt system provides for dispatch to a user-supplied routine  on any
            of the events shown in table Table 16-3 .

            When an enabled APRENB condition  occurs and the APRENB interrupt system  is active,
            the monitor will
                1)  Store a representation  of the current  processor status into  .JBCNI of
                    the "Job Data Area".  Where appropriate, the bits stored are those which
                    would have  resulted from  a CONI  APR instruction  executed on  a KA-10
                    processor.
                2)  Store the current program counter into .JBTPC of the "Job Data Area".
                3)  Disable all APRENB  interrupt causes if AP.REN  is 0, or all  but AP.UUO
                    and AP.CLK if AP.REN is 1.  An exception occurs on UUO traps,  where all
                    causes but AP.CHR, AP.BRK, and AP.ESC are disabled.

                                                    16-1


      Interrupt System and Sleeping            16                         YAMM edition 2.0


          4)  Jump  to  the address  stored  in .JBAPR  of  the "Job  Data  Area".  An
              exception  can  occure on  AP.UUO  traps: if  the  last  APRENB executed
              specified  a  separate address  for  them the  monitor  will  jump there
              instead.
      An AP.CHR, AP.BRK, or AP.ESC trap will be deferred if it occurs while another APRENB
      trap is in progress.

      To dismiss from an APRENB  interrupt, the DISMIS UUO (CALLI -23, pg. 16-8)  is used.
      Note that it is not used  in the same manner when dismissing from  APRENB interrupts
      as it is from INTADR interrupts.

                _______ ______ ______ ________ ______ ____      16.2.1    APRENB: enable APRENB trapping (CALLI +16)

              MOVE    ac, [UUO trap addr,,enable bits]
              APRENB  ac,
              only return

      where <UUO trap address>, if nonzero,
              specifies an alternate address to use
              instead of .JBAPR for trapping
              UUOs and illegal instructions (AP.UUO)

      and <enable bits> are the AP.xxx bits defined above

      Turn off  the INTADR  system if  it is  in effect,  and turn  on the  APRENB system,
      enabling those trap conditions whose <enable bits> are 1 and disabling the others.

      If  AP.CHR  or  AP.BRK is  set,  check  the input  buffer  for  characters  or break
      characters, and arrange for an immediate interrupt upon return if any are present.

      If <UUO trap address> is nonzero, it, rather than c(.JBAPR right) will be  used when
      trapping AP.UUO events.




































                                              16-2


            July 3, 1980                             16            Interrupt System and Sleeping


                                                _____ ____                                                 Table 16-3 
                                      ______ _________ ___ ___________                                      APRENB Interrupt Bit Definitions


            name     bits   name     bits   description

            CN.REN          AP.REN   1B18   Repetitive enable.  Permit nested traps.
            CN.POV   1B19   AP.POV   1B19   Stack Overflow or Underflow;
            CN.UUO   1B18   AP.UUO   1B20   Attempt to execute a UUO or any other illegal
                                            instruction.
            CN.BRK   1B24   AP.BRK   1B21   The receipt of a break character while not in input
                                            wait.
            CN.ILM   1B22   AP.ILM   1B22   Illegal memory reference.
            CN.CHR   1B21   AP.CHR   1B24   The receipt of a character while not in input wait.
            CN.ESC   1B17   AP.ESC   1B25   The receipt of an escape.
            CN.CLK   1B26   AP.CLK   1B26   The ocurrence of a clock tick while the program is
                                            running.
            CN.FOV   1B29   AP.FOV   1B29   Floating-Point Overflow.
            CN.HNG   1B16   AP.HNG   1B30   Hung device.
            CN.AOV   1B32   AP.AOV   1B32   Arithmetic Overflow (integer).



                    ______ _________ ______            16.3    INTADR Interrupt System

            The INTADR  interrupt system  has 35  software interrupt  channels, with  a priority
            structure such that channel 1 has  the highest, and channel 35 the  lowest priority.
            At any given time, each channel has three bits of state information  associated with
            it:
                1)  It may either be enabled or disabled.
                2)  It may have an interrupt currently in progress.
                3)  It may have an interrupt pending.
            Each channel can be selectively enabled or disabled, or the system as a whole can be
            enabled or  disabled (perserving  the states  of the  individual channels)  or reset
            (disabling each channel and clearing its in-progress and pending bits).

                      ____________ ___ ______ ______            16.3.1    Initializing the INTADR System

            The INTADR system uses  a 70-word transfer vector to  save the current PC  and fetch
            the  trap routine's  address when  initiating interrupts.   The format  of  the trap
            vector is

                    word 0  channel 1 old PC address
                    word 1  channel 1 trap routine address
                    word 2  channel 2 old PC address
                    word 3  channel 2 trap routine address
                    ...

            To  set  up the  INTADR  system, the  program  executes the  INTADR  UUO (CALLI -33,
            pg. 16-5).

            The proper use  of the INTADR  system is to first  initialize the vector  with words
            0,2,4..set to zero, words 1,3,5..set to the entry points of the routines for each PI
            level.   Then  issue  the   INTADR  UUO  (CALLI -33,  pg. 16-5),  followed   by  the
            appropriate TINASS and/or INTASS UUO to assign causes.

            Once  everything is  set up,  issue the  INTENB UUO  (CALLI -34, pg. 16-7)  to begin
            accepting interrupts.

            Each PI routine  should end its execution  with a DISMIS UUO  (CALLI -23, pg. 16-8),
            which will return via the appropriate PC in the transfer vector.







                                                    16-3


      Interrupt System and Sleeping            16                         YAMM edition 2.0


                _________ ______ __ ________      16.3.2    Assigning Causes to Channels

      Each  possible interrupt  cause can  be assigned  to one  of the  software interrupt
      channels, or ignored.  An interrupt  channel can have several causes assigned  to it
      but it then becomes difficult to determine what actually caused a given interrupt.

      Assignment of port causes is  handled by the TINASS UUO (CALLI -42,  pg. 16-5).  The
      port causes are shown in Table 16-4 .

      General  causes  are  assigned  with  the  INTASS  UUO  (CALLI -36,  pg. 16-6).  The
      general causes are shown in Table 16-4b.


                                          _____ ____                                           Table 16-4 
                                   ____ _________ _____ _____                                   Port Interrupt Cause Codes


      Name     Code  Condition

      .IAESC   0     Receipt of an escape.
      .IACHR   1     Receipt of a character.
      .IABRK   2     Receipt of a break character.
      .IAIOW   3     Potential I/O wait Execution of a UUO which would put the process
                     into port input or output wait.
      .IAROM   4     Room for more output characters.  Happens only if an .IAIOW interrupt
                     has been trapped because of a pending output wait.
      .IALOS   5     Characters lost on input.
      .IAORG   6     Receipt of an orange ball.
      .IAZAP   7     Receipt of a circuit zapper.
      .IAPSS   10    Port Status msg seen
      .IAYEL   11    Receipt of Yellow Ball.
                     if this cause is assigned, the monitor will not reflect yellow balls
                     as orange balls as it normally does; the user program should send an
                     orange ball using .AXSOB UUO (AUXCAL fn 70, pg. 10-29) when this
                     interrupt is received.
      .IAGOB   12    Receipt of Character Gobbler.



                                          _____ _____                                          Table 16-4b
                                 _______ _________ _____ _____                                 General Interrupt Cause Codes


      Symbol   Code  Description

      .IAUUO   0     UUO or illegal instruction
      .IACLK   1     Clock tick while running
      .IAILM   2     Ill mem ref
      .IAHNG   3     Hung device
      .IATIM   4     SETTIM timer interrupt
      .IADEV   5     Device error
      .IAWAK   6     Wake UUO for this frame
      .IAFEL   7     Page fault (WS=WSL) The current working set size is at least equal to
                     the working set size limit.
      .IAFLL   10    Page fault (WS<WSL) The current working set size is less than the
                     working set size limit.
      .IAREF   11    Reference-bit trap
      .IAERR   12    Paging I/O error
      .IANTQ   13    Notice to quit (sys going down)
      .IAFEX   14    Frame exit in child








                                              16-4


            July 3, 1980                             16            Interrupt System and Sleeping


                      _______ __________ ______ ______ ______ ____            16.3.3    INTADR: initialize INTADR system (CALLI -33)

                    MOVE    ac, [bits,,trap vector address]
                    INTADR  ac,
                      error return
                    normal return

            where <bits> = IA.DIS ('1) to disable
                           IA.REE ('2) to (re-)enable
                           IA.CLR ('4) to clear

            If <trap vector address> is 0 and the INTADR system is not currently in effect, take
            the error return.

            If it is nonzero and the APRENB system is in effect, turn off the APRENB  system and
            turn on the INTADR system.

            If it is nonzero, make it the trap vector address for the INTADR system.

            If IA.DIS  is set, disable  the INTADR  system.  If IA.REE  is set,  (re-)enable the
            INTADR system.  If IA.CLR is set, reset the INTADR system, "forgetting"  all pending
            and in-progress interrupts, disabling all the channels, and disabling the  system as
            a  whole.  (This  operation does  not disturb  interrupt cause  assignments  made by
            TINASS or INTASS).

            If the APRENB system  had previously been in effect,  set <ac> to the  last argument
            passed an APRENB UUO.  If the INTADR system was already in effect, set <ac>  left to
            the previous trap vector address.

                      _______ ______ ____ _________ ______ ______ ____            16.3.4    TINASS: assign port interrupt causes (CALLI -42)

                    MOVE    ac, [causeB8+channelB17+port]
                    TINASS  ac,
                      error return
                    normal return

            where <cause> is a cause number from
            Table 16-4 ,

            and <channel> is 0 to deassign the cause or
                    the number of the INTADR channel to assign
                    it to

            and <port> is the number of a port or -1 to specify
                    the process's command port

            If <channel> is greater than 35 or the INTADR system is not in effect; or  if <port>
            is negative and the current process is running detached; or if <port> is nonnegative
            and the specified port is not owned  by the process; or if <cause> is not  one found
            in Table 16-4 , take the error return.

            Assign the  port/cause combination  to the  specified channel  (or deassign  them if
            <channel> is 0).  Store the channel that this port/cause was previously  assigned to
            (or 0 if not assigned) in <ac> and take the normal return.

            If .IACHR or .IABRK is being assigned, check <port>'s buffer for characters or break
            characters, and arrange for an immediate interrupt upon return if any are present.











                                                    16-5


      Interrupt System and Sleeping            16                         YAMM edition 2.0


                _______ ______ _______ _________ ______ ______ ____      16.3.5    INTASS: assign general interrupt causes (CALLI -36)

              MOVE    ac, [cause,,channel]
              INTASS  ac,
                error return
              normal return

      where <cause> is taken from Table 16-4b

      and <channel> is 0 to deassign the cause or
              the number of the INTADR channel to assign
              it to

      If <channel> is greater  than 35; or if <cause>  is not found in Table 16-4b;  or if
      the INTADR system is not in effect, take the error return.

      Otherwise, assign the <cause> to the  <channel> (or deassign it if <channel>  is 0),
      store the channel to which it was  previously assigned (or 0 if it wasn't)  in <ac>,
      and take the normal return.

                _______ __________ ______ ___ ________ __________ ______ ____      16.3.6    INTRMT: (obsolete) assign I/O software interrupts (CALLI -52)

              MOVE    AC,[<reason>B8+<intch>B17,,<channel>]
              INTRMT  ac,
               error  return  ;ac/Table 16-7 
              normal return   ;ac/previous <intch>

      where <channel> is a software I/O channel on which the
      device has been initted (currently only ACT device works),
      and <intch> is a software interrupt channel,
      and where <reason> is:
      0       input available
      1       output buffer available (good only if already interrupted
               for output wait)
      2       about to go into I/O wait
      3       EOF on input
      4       error on I/O
      5       port zapped


      This UUO is  obsolete; certain functions  work on the  ACT device.  No  other device
      currently implements any of these functions.  The UUO was originally implemented for
      use with the Remote 620 Dispatch Base facility.

                _______ ___ _____ _________ ______ ____      16.3.7    SETTIM: set timer interrupt (CALLI -37)

              MOVE    ac, [units,,time]
              SETTIM  ac,
                JFCL  ; never taken
              normal return

      where <units> = 0 for milliseconds (maximum 2^18-1)
                      1 for seconds      (maximum 2^16-1)
                      2 for minutes      (maximum 2^16-1)

      It <time>  is 0,  reset the  timer (so it  will never  go off)  and take  the normal
      return.

      If <units> is milliseconds, convert <time>  to jiffies, rounding it up so that  1 ms
      becomes 1 jiffy.

      Set the timer to  go off (causing a timer  interrupt) after <time> <units>  and take
      the normal return.





                                              16-6


            July 3, 1980                             16            Interrupt System and Sleeping


                                                _____ ____                                                 Table 16-7 
                                             ______ _____ _____                                             INTRMT error codes


            IRBCH%     1       bad I/O channel
            IRBDR%     5       bad interrupt reason
            IRBIC%     6       bad interrupt channel number
            IRNIS%     7       no INTADR system in effect.


                      _______ ______ ___ _______ ______ ________ ______ ____            16.3.8    INTENB: enable and disable INTADR channels (CALLI -34)

                    MOVE    ac, [bits]
                    INTENB  ac,
                      error return
                    normal return

            where <bits> = 1B0 to enable, 0B0 to disable
                         + 1B1 to do it to channel 1
                         + 1B2 for channel 2,...

            If the INTADR system is not in effect, take the error return.

            Otherwise, enable (if  c(<ac> bit 0) is  1) or disable (if  c(<ac> bit 0) is  0) the
            channels whose corresponding bits are set, and take the normal return.

                      _______ ____ ___________ ____ ______ ____            16.3.9    REDPIP: read in-progress bits (CALLI -43)

                    REDPIP  ac,
                      error return
                    normal return

            If the INTADR system is not in effect, take the error return.

            Otherwise, set  bit <n> of  <ac> to 1  if an interrupt  is currently in  progress of
            channel <n>, 0 otherwise, and skip-return.

                       _______ _____ ___ _______ __________ ______ ____            16.3.10    INTACT: cause and uncause interrupts (CALLI -35)

                    MOVE    ac, [bits]
                    INTACT  ac,
                      error return
                    normal return

            where <bits> = 1B0 to set, 0B0 to clear the pending bit
                         + 1B1 to do it to channel 1
                         + 1B2 for channel 2,...

            If the INTADR system is not in effect, take the error return.

            Otherwise, set or clear the specified channels' interrupt-pending bits, set  <ac> to
            reflect the previous state of those bits, and take the normal return.
















                                                    16-7


      Interrupt System and Sleeping            16                         YAMM edition 2.0


                 _______ _______ ______ __________ ______ ____      16.3.11    DISMIS: dismiss INTADR interrupts (CALLI -23)

              DISMIS
              ; clear activity on current PI level,
              ; continue processing at the interrupt PC


              ________      16.4    Sleeping

      The  HIBER and  SLEEP  UUOs do  not  affect the  ability  of a  process  to continue
      receiving timer  interrupts generated  by the SETTIM  UUO (CALLI -37,  pg. 16-6) and
      INTASS UUO (CALLI -36, pg. 16-6).

                ______ ____ ___ _____ ______ ____      16.4.1    HIBER: wait for event (CALLI +72)

              MOVE    ac, [bits,,time]
              HIBER   ac,
                error return
              normal return

      where <bits> = '0 for ms, '1 for sec, '2 for min time units,
      + '10 to return if a character arrives
      + '20 to return if a break character arrives
      + '40 to return when output is complete
      + '100 + port # in bits 0-8 if not cmnd port
      + '200 to return on WAKE UUO (CALLI +73, pg. 16-9)
      + '400 to return on frame exit in "child" frames

      Let <port> be c(<bits> bits 0-1) if the '100 bit of <bits> is set, the  command port
      otherwise, taking the error return if a port is specified and does not belong to the
      frame or if the command port is specified and the frame is running detached.

      If <time> is  specified in milliseconds,  convert if to  jiffies, rounding up  (1 ms
      becomes 1 jiffy, not  0); if it is specified  in seconds or minutes, and  is greater
      than 2^16-1, set it to 2^16-1.

      Wait until one of the specified events occurs, then skip-return.

      The sleep time is only kept in jiffies, and it is less accurate than that,  since it
      may take several seconds for an awakened frame to be rescheduled.

      An "output complete" HIBER sends a yellow ball and waits for an orange ball  to come
      back.   Since balls  can be  lost, a  sleep time  should always  be specified  (as a
      timeout).

      HIBER  uses  software interrupt  channel  36, a  fact  not normally  visible  to any
      program. This  is a channel  on which interrupt  causes cannot directly  be assigned
      with TINASS or INTASS.  However TINASS or INTASS can report that a certain cause was
      previously assigned on channel 36 if that cause was previously among the <bits> in a
      HIBER.

      If a HIBER is executed which has <bits> which specify conditions on a port for which
      a TINASS has already enabled interrupts,  then the HIBER <bits> are ignored  and the
      interrupts remain as they  were.  However, if the HIBER  has bits for WAKE  or Frame
      Exit in child, and if these conditions were previously enabled via INTASS,  then the
      channel assignments for those conditions are lost and the HIBER interrupt assignment
      is put in force.











                                              16-8


            July 3, 1980                             16            Interrupt System and Sleeping


                      ______ ____ ___ _ _______ ______ ____            16.4.2    SLEEP: wait for N seconds (CALLI +31)

                    MOVE    ac, [time]
                    SLEEP   ac,
                    only return

            where <time> is the number of seconds to sleep

            Convert <time> to jiffies, with a minimum of 1 jiffy and a maximum of 2^12-1.  (This
            translates into a maximum sleep of 68 seconds).  Put the process in SL  state (i.e.,
            make it wait) for  the calculated number of  jiffies, then return.  If  any software
            interrupts  fire during  the sleep,  answer them  immediately, but  do  not continue
            sleeping when they DISMIS.

                      _____ ____ ________ _____ ______ ____            16.4.3    WAKE: wake sleeping frame (CALLI +73)

                    MOVEI   ac, frame
                    WAKE    ac,
                      error return
                    normal return

            If <frame> is <0 or .o frame exists for <job>, take the error return.

            If <frame> is armed for interrupt on receipt of a WAKE, fire the  interrupt.  Awaken
            <frame> and return.


                    _____________ ___________            16.5    APRENB/INTADR Interaction

            The APRENB and INTADR  systems aannot both be in  effect at the same time.   Doing a
            RESET or an APRENB will turn on the APRENB system; doing an INTADR 7ill turn  on the
            INTADR system.

            If  an APRENB  tr     !T        !S@       !T        !P        !>        !P        !T        !P        !P        !8        !R@       !T        !T        !T        !T        !T        !S        !T        !S        !R@       !T        !T                  !P        !T                                                                                                                                                                                                                                                                                                                                                                                                               16-9


      Interrupt System and Sleeping            16                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             16-10


            July 3, 1980                             17                            Club Facility


                                                 _______ __                                                 Section 17
                                               ____ ________                                               Club Facility

                                             Table of Contents



            SubSection


            17.1     Purpose    17-1

            17.2     Definition    17-1
            17.2.1      Club Interlock    17-1
            17.2.2      Club ID numbers    17-1

            17.3     Use of the Club UUOs    17-1
            17.3.1      Joining a Club    17-2
            17.3.2      Leaving a Club    17-2
            17.3.3      Getting an Interlock    17-2
            17.3.4      Releasing an Interlock    17-2
            17.3.5      Direct Interaction with other club members    17-3

            17.4     Club UUOs    17-3
            17.4.1      CLBADD: Join Club (CALLI -114)    17-3
            17.4.2      CLBLEV: Leave a Club (CALLI -113)    17-3
            17.4.3      CLBINW: Get Interlock,wait (CALLI -112)    17-4
            17.4.4      CLBINI: Get Interlock,No Wait (CALLI -111)    17-4
            17.4.5      CLBRLI: Release Club Interlock (CALLI -110)    17-5
            17.4.6      CLBMEM: Read Club Member List (CALLI -107)    17-5
            17.4.7      CLBSTS: Read Status of Club Member (CALLI -106)    17-5
            17.4.8      CLBWAK: Wake Up Club Member (CALLI -105)    17-6
            17.4.9      CLBHNG: Hang Club Member (CALLI -104)    17-6


            Table

            17-4     Club Interlock Status Flags    17-4
            17-7     Club Facility Standard Error Codes    17-7





























                                                    17-i


                                               17                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             17-ii


            July 3, 1980                             17                            Club Facility





                                                 _______ __                                                 Section 17
                                               ____ ________                                               Club Facility





                    _______            17.1    Purpose

            The monitor Club  facility has been  provided to make  it possible for  processes to
            cooperate  more efficiently.   The facility  allows  a process  to join  a  group of
            processes which cooperate in updating and maintaining the integrity of some resource
            like a  database, or which  for any  other reason wish  to wait  upon/issue wake-up-
            signals-to each other.

            The facility provides only a basic interlock mechanism; more complex  interlocks can
            be implemented by  the processes in  a club.  The  importance of the  basic facility
            provided by Clubs is that it  allows the cooperating processes a means  of detecting
            that the system or another member  of the club crashed while holding  the interlock.
            A club member who detects such a crash can then perform a recovery procedure  on the
            interlocked resource.


                    __________            17.2    Definition

            A Club is  a set of processes  associated with a shared  disk page mapped by  all of
            them.  "First Class"  members of any  club are those who  map the page  with maximum
            protection  Writeable;  "Second  Class"  members  are  those  who  map  with maximum
            protection Read-only or Copy-on-Write (COW).

                      ____ _________            17.2.1    Club Interlock

            Associated with every club is an Interlock which can be held by only one club member
            at  a  time.   Second-class members  may  not  hold the  interlock.   When  a member
            successfully obtains the interlock, he  is informed whether or not the  last process
            to hold  the interlock released  it normally  or abnormally.  The  holder of  a club
            interlock can release it  normally (by issuing a  UUO) or can release  it abnormally
            (by having the  monitor crash on  him or by  having it taken  away from him  by some
            other club member who determines that the holder has crashed).

                      ____ __ _______            17.2.2    Club ID numbers

            Associated with every club  member is a Club ID  number unique within that  club; ID
            numbers are guaranteed  never to be  reused within a given  club while the  club has
            members. [A  process belonging to  two or more  clubs may receive  the same  ID from
            different clubs; the ID's are  not unique system-wide.] First-class members  can use
            the club ID numbers to act upon or obtain information about other club members.


                    ___ __ ___ ____ ____            17.3    Use of the Club UUOs















                                                    17-1


      Club Facility                            17                         YAMM edition 2.0


                _______ _ ____      17.3.1    Joining a Club

      For a  club to come  into existence, the  processes which wish  to form a  club must
      agree on a disk page which will be  mapped by all of them.  If all of  the processes
      agree upon page N of file F, then the club becomes uniquely identified by the system
      internal "name" of this page.  Any process which wishes to join this club  need only
      map page N of file F, and then issue the CLBADD UUO (CALLI -114, pg. 17-3).

      The club UUOs all  require the caller to identify  the club by giving the  VP number
      where the agreed-upon page is mapped.  This  means that a process can be in  at most
      512 clubs at once.  The system performs the translation from VP number to the system
      internal page "name", which club members never need to know.

                _______ _ ____      17.3.2    Leaving a Club

      A club member leaves a club whenever he ceases to map the agreed-upon page  (for any
      reason),  or when  he issues  the CLBLEV  UUO (CALLI -113,  pg. 17-3). A  variety of
      events can destroy  the mapping; some  are not under  control of the  process.  Some
      examples are 1) running a  new program; 2) writing on  a COW page which was  used to
      enter a club; 3) memory parity error or context page swap error, which zap all  of a
      process' memory.  If the mapping ceases while the club member has the interlock, the
      interlock is released, and is marked "abnormally released".

                _______ __ _________      17.3.3    Getting an Interlock

      First-class members  may obtain their  club interlock by  using either of  two UUOs:
      CLBINW UUO (CALLI -112, pg. 17-4), or  CLBINI UUO (CALLI -111, pg. 17-4) If  he uses
      CLBINW, he can  "queue up" to  the interlock.  If the  interlock is held  by another
      club member, the caller of CLBINW goes into wait for the interlock, and  is awakened
      and given the interlock  when all members ahead of  him on the queue have  taken and
      released the interlock.  This mechanism is provided by the system.

      A First-class member may issue  CLBINI UUO (CALLI -111, pg. 17-4) to attempt  to get
      the interlock; this UUO will not wait, but will immediately return if  the interlock
      is busy.

      A club  member in Interlock  Wait can  escape/control-C out of  the wait,  or answer
      software  interrupts while  in wait.   If a  software interrupt  is  answered during
      interlock  wait, the  return  PC stored  will point  at  the CLBINW  UUO.   When the
      interrupt routine  returns, the CLBINW  will be re-executed  and the caller  will be
      re-queued for the interlock (i.e., he loses his place if he services an interrupt).

                _________ __ _________      17.3.4    Releasing an Interlock

      As mentioned above, the interlock is released abnormally if the "club  page" mapping
      is  broken.   Club  members  release the  interlock  normally  by  using  CLBRLI UUO
      (CALLI -110,  pg. 17-5);  such  a  release  causes  the  next  member  who  gets the
      interlock to  see the  interlock status as  "normally released".   If a  club member
      holding  the interlock  encounters any  condition (ill  mem ref,  i/o  to unassigned
      channel,  etc.) which  sets the  system internal  bit JB.JER  (which means  that the
      process  cannot  run and  has  an error),  then  the interlock  will  be "abnormally
      released".
















                                              17-2


            July 3, 1980                             17                            Club Facility


                      ______ ___________ ____ _____ ____ _______            17.3.5    Direct Interaction with other club members

            First-class members of a club can use CLBMEM UUO (CALLI -107, pg. 17-5) to  obtain a
            list of  ID numbers  of other club  members and  a count of  members.  Using  the ID
            number, first-class  members can find  out how "healthy"  other club members  are by
            using CLBSTS UUO (CALLI -106, pg. 17-5),  can wake up other members with  CLBWAK UUO
            (CALLI -105,  pg. 17-6), or  can  hang other  members with  CLBHNG  UUO (CALLI -104,
            pg. 17-6).


                    ____ ____            17.4    Club UUOs

            Some club UUOs return successfully with  data in AC; others write data  at addresses
            pointed to by AC.  The error return for all club UUOs is the non-skip return,  and a
            standard  club  error code  is  returned in  AC  for all  errors.   These  codes are
            summarized in Table 17-7 

                      _______ ____ ____ ______ _____            17.4.1    CLBADD: Join Club (CALLI -114)

                    MOVEI   AC,VP
                    CLBADD  AC,
                      error return  ;AC contains <error code>
                    normal return   ;AC contains <Club ID> number

            where <error code> may be found in Table 17-7 

            If <VP> is out of range, or has  no disk page mapped, or if the caller is  already a
            member of  VP's club, or  if the club  ID number would  overflow if the  caller were
            added to the club, set AC to the appropriate error code and take the error return.

            If the club currently has no  members, initialize ID numbers for this club  to zero,
            and set the interlock status to "abnormally released".

            Increment the club ID number, assign the new ID to the caller, put him in  the club,
            set AC to the ID number, and take the success return.

                      _______ _____ _ ____ ______ _____            17.4.2    CLBLEV: Leave a Club (CALLI -113)

                    MOVEI   AC,<VP>
                    CLBLEV  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            If <VP> is out of range, or if no disk page is mapped in VP, or if the caller is not
            in any club, or if VP is not  the virtual page thru which the caller entered  any of
            the clubs of which he is currently a member, or if the caller has the  interlock for
            VP's club, set AC to the appropriate error code and take the error return.

            Remove the caller  from VP's club.   If no members remain  in the club,  destroy the
            club.  Take the normal return.
















                                                    17-3


      Club Facility                            17                         YAMM edition 2.0


                _______ ___ ______________ ______ _____      17.4.3    CLBINW: Get Interlock,wait (CALLI -112)

              MOVEI   AC,<VP>
              CLBINW  AC,
                error return  ;AC contains <error code>
              normal return   ;AC contains <interlock status flags>

      where <error code> may be found in Table 17-7 

      If <VP> is out of range or has no page mapped in it, or if the caller is not  in any
      club, or if <VP> is  not the virtual page thru  which the caller entered any  of the
      clubs of  which he  is currently a  member, or  if the caller  is not  a first-class
      member of VP's club, or if the caller has the interlock for this club, set AC to the
      approiate error code and take the error return.

      If the interlock is currently held by another club member, put the caller  into wait
      for the interlock; wake him up when his turn comes to get it.

      Give the interlock  for VP's club  to the caller, set  AC to the  current <interlock
      status flags> as shown in Table 17-4 , and take the normal return.


                                          _____ ____                                           Table 17-4 
                                  ____ _________ ______ _____                                  Club Interlock Status Flags


      name     bit   meaning

      CB.NML   1     last interlock release was normal
                     if set, release was normal; if 0, release was abnormal
      CB.EVI   2     Ever Interlocked
                     if set, the club interlock has been given at least once since
                     creation of the club.  If 0, this CLBINW or CLBINI call is the first
                     to get the interlock since creation of the club, and the interlocked
                     resource may need cleanup.


                _______ ___ ____________ ____ ______ _____      17.4.4    CLBINI: Get Interlock,No Wait (CALLI -111)

              MOVEI   AC,<addr>
              CLBINI  AC,
                error return  ;AC contains <error code>
              normal return   ;AC contains <interlock status flags>
      If the error code is CBAIL%, then data returned at <addr> is:

      ADDR:   <ID>

      where <error code> may be found in Table 17-7 

      If any of the error conditions for CLBINW UUO (CALLI -112, pg. 17-4) is true,  or if
      the interlock  is busy, set  AC to the  approiate error code.   If the  interlock is
      busy,  store in  <addr>  the ID  number of  the  club member  currently  holding the
      interlock.  Take the error return.

      Give the interlock to the caller, set AC to the <interlock status flags> as shown in
      Table 17-4 , and take the normal return.












                                              17-4


            July 3, 1980                             17                            Club Facility


                      _______ _______ ____ _________ ______ _____            17.4.5    CLBRLI: Release Club Interlock (CALLI -110)

                    MOVEI   AC,<VP>
                    CLBRLI  AC,
                      error return  ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            If <VP> is out of  range, or if no ddisk page  is mapped there, or if the  caller is
            not in any club, or if <VP> is  not a virtual page via which the caller  entered any
            of the clubs of which he is a  member, or if the caller is not a  first-class member
            of VP's club, or if the caller does not currently have the interlock, set AC  to the
            appropriate error code and take the error return.

            Release  the  interlock for  VP's  club, mark  it  normally released,  and  give the
            interlock to the first frame in the interlock wait queue, if there is any.  Take the
            normal return.

                      _______ ____ ____ ______ ____ ______ _____            17.4.6    CLBMEM: Read Club Member List (CALLI -107)

                    MOVEI   AC,<addr>
                    CLBMEM  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <count>

            and data is returned at <addr> as follows:
            ADDR:   <number of club members>
            ADDR+1  1st ID number
            ..      ..
            ..      ..
            ADDR+<count> last ID number

            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
            in any club, or if VP is not a virtual page via which the caller entered any  of the
            clubs of which he is a member, or if the caller is not a first-class member  of VP's
            club, or if <count> is negative, set  AC to the appropriate error code and  take the
            error return.

            Store at  <addr> the number  of members  currently in VP's  club, and  begin storing
            their ID numbers at <addr>+1 and so  on until ID numbers or <count> runs  out.  Take
            the normal return.

                      _______ ____ ______ __ ____ ______ ______ _____            17.4.7    CLBSTS: Read Status of Club Member (CALLI -106)

                    MOVEI  MOVEI   AC,<addr>
                          
                    CLBSTS  AC,
                     error return   ;AC contains <error code>
                    normal return   ;AC contains <status>

            where <error code> can be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <ID>


            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not

                                                    17-5


      Club Facility                            17                         YAMM edition 2.0


      in any club, or if VP is not a virtual page via which the caller entered any  of the
      clubs of which he is a member, or if the caller is not a first-class member  of VP's
      club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
      appropriate error code and take the error return.

      Set AC  to <status>  (the contents  of the  monitor internal  table JBTSTS)  for the
      process identified by <ID>, and take the success return.

      There is only one bit in  <status> which is significant to the club  mechanism; that
      is JB.JER (see Table 2-7 ).  If  a club member's <status> shows JB.JER set,  then he
      can be assumed to be "unhealthy".

                _______ ____ __ ____ ______ ______ _____      17.4.8    CLBWAK: Wake Up Club Member (CALLI -105)

              MOVEI   AC,<addr>
              CLBWAK  AC,
               error return   ;AC contains <error code>
              normal return

      where <error code> may be found in Table 17-7 

      The arguments passed at <addr> are as follows:

      ADDR:   <VP>
      ADDR+1  <ID>


      If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
      in any club, or if VP is not a virtual page via which the caller entered any  of the
      clubs of which he is a member, or if the caller is not a first-class member  of VP's
      club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
      appropriate error code and take the error return.

      Send a wake-up signal to the process identified by <ID> and take the normal return.

                _______ ____ ____ ______ ______ _____      17.4.9    CLBHNG: Hang Club Member (CALLI -104)

              MOVEI   AC,<addr>
              CLBHNG  AC,
               error return   ;AC contains <error code>
              normal return

      where <error code> may be found in Table 17-7 

      The arguments passed at <addr> are as follows:

      ADDR:   <VP>
      ADDR+1  <ID>


      If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
      in any club, or if VP is not a virtual page via which the caller entered any  of the
      clubs of which he is a member, or if the caller is not a first-class member  of VP's
      club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
      appropriate error code and take the error return.

      Hang the process identified by <ID> in such a way as to force logout even though the
      process may have "detach on disconnect" set.  Take the normal return.










                                              17-6


            July 3, 1980                             17                            Club Facility


                                                _____ ____                                                 Table 17-7 
                                     ____ ________ ________ _____ _____                                     Club Facility Standard Error Codes


            name     value meaning

            CBVPR%   1     VP number out of legal range
            CBNEX%   2     VP does not exist (has no disk page mapped)
            CBINC%   3     Caller already in a club for this VP
            CBIDO%   4     Club ID number overflow
            CBNIC%   5     Not in Club (from UUOs requiring club membership)
            CBVPM%   6     VP mismatch (specified VP is not one thru which caller entered any of
                           the clubs he is currently in)
            CBHIL%   7     Have Interlock,cannot perform UUO at this time
            CBAIL%   10    Attempted to get Interlock, but it was busy
            CBNIL%   11    No Interlock  ( attempt to release it when you dont have it)
            CBCNT%   12    Requested count of club members is <0
            CBNFC%   13    Not First Class  (from UUOs requiring first class membership)
            CBJNI%   14    Frame Not In your club,can't get info on it

















































                                                    17-7


      Club Facility                            17                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              17-8


            July 3, 1980                             18                Environmental Information


                                                 _______ __                                                 Section 18
                                         _____________ ___________                                         Environmental Information

                                             Table of Contents



            SubSection


            18.1     Dates and Times    18-1
            18.1.1      DATE: read date (CALLI +14)    18-1
            18.1.2      DATUUO: do time zone conversions (CALLI -55)    18-2
            18.1.3      MSTIME: read time in ms (CALLI +23)    18-3
            18.1.4      RUNTIM: get TRUs (CALLI +27)    18-3
            18.1.5      TIMER: read time in jiffies (CALLI +22)    18-3

            18.2     GETTAB tables and functions    18-3
            18.2.1      GETTAB: read monitor tables (CALLI +41)    18-3

            18.3     Addressing Monitor Memory    18-10
            18.3.1      VPEEK: Virtual/Physical PEEK (CALLI -136)    18-10
            18.3.2      PEEK: (obsolete) read monitor core (CALLI +33)    18-11
            18.3.3      POKE: write in monitor core (CALLI -12)    18-11
            18.3.4      BITPOK: read/modify/write in monitor memory (CALLI -120)    18-11

            18.4     Lights and Switches    18-11
            18.4.1      LIGHTS: display word in console lights (CALLI -1)    18-12
            18.4.2      SWITCH: read console switches (CALLI +20)    18-12


            Table

            18-2     Time Zone Codes    18-2
            18-4     GETTAB tables by function    18-4
            18-6     GETTAB tables by number    18-6
            18-7     .GTCNF (GETTAB +11) Items    18-7
            18-7b    .GTLOG Bits (GETTAB -24)    18-7
            18-8     Terminal Identifier Codes    18-8
            18-8b    .GTLVD (GETTAB 16) Items    18-8
            18-8c    .GTNSW Items (GETTAB 12)    18-9
            18-9     .GTODP(GETTAB +15) items (ONCDSK parameters)    18-9
            18-10    .GTWSC(GETTAB +25) items (Wait State Codes)    18-10

























                                                    18-i


                                               18                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             18-ii


            July 3, 1980                             18                Environmental Information





                                                 _______ __                                                 Section 18
                                         _____________ ___________                                         Environmental Information





                    _____ ___ _____            18.1    Dates and Times

            The monitor supports two date formats:
                1)  DEC format
                        ((year-1964)*12) + (month-1))*31 + (day-1)
                        where <month> is the current month of the year
                        and <day> is the current day of the month
                2)  Standard Format
                        the number of days since 1 January 1964

            Times are supplied by the monitor with respect to midnight of the appropriate day.

            Most UUOs supply dates and times with respect to the user's current time  zone.  The
            time zones and their codes are described in Table 18-2 .

            The current time zone for a process is stored in bits 3-7 of the process's privilege
            word (see Table 2-3 ), with bit 2 set if the process is subject to  daylight savings
            time.

                      _____ ____ ____ ______ ____            18.1.1    DATE: read date (CALLI +14)

                    DATE    ac,
                    only return

            Set  c(<ac>) to  the current  date, in  DEC format,  with respect  to  the process's
            current time zone, and return.
































                                                    18-1


      Environmental Information                18                         YAMM edition 2.0


                                          _____ ____                                           Table 18-2 
                                        ____ ____ _____                                        Time Zone Codes


               A = hours to add to GMT
               B = international zone letter
               C = monitor code
               D = zone name


               A    B    C    D

               -12  Y    4
               -11  X    5
               -10  W         HST Hawaii, Alaska
               -9   V    7
               -8   U    10   PST Cupertino
               -7   T    11   MST Houston
               -6   S    12   CST Chicago
               -5   R    13   EST New Yorkrk
               -4   Q    14   AST
               -3   P    15
               -2   O    16
               -1   N    17
               0    Z    20   GMT London
               1    A    21    Paris
               2    B    22
               3    C    23
               4    D    24
               5    E    25
               6    F    26
               7    G    27
               8    H    30
               9    I    31    Tokyo
               10   K    32    Brisbane
               11   L    33
               12   M    34

               In the monitor, a code of zero (0) usually represents the current user's
               time zone


                _______ __ ____ ____ ___________ ______ ____      18.1.2    DATUUO: do time zone conversions (CALLI -55)

              MOVEI   ac, addr
              DATUUO  ac,
                JFCL  ; error return never taken
              only return

      where <addr> points to a block of the form
              addr:   date
              addr+1: time (jiffies since midnight)
              addr+2: old,,new

      and <old> and <new> are time zone codes:
              time zone (see above)
              + '40 if subject to daylight savings
              + '400000 for standard format (not DEC)

      Convert  <date> and  <time> from  the zone  and format  specified by  <old>  to that
      specified  by <new>,  and store  the converted  values into  <addr>  and (<addr>+1),
      respectively, then skip-return.

      Adjustments for daylight savings will  only be applied if daylight savings  time was
      in effect at the  specified old or new date.   Daylight savings (to the  monitor) is
      never in effect for years after 2008.


                                              18-2


            July 3, 1980                             18                Environmental Information


                      _______ ____ ____ __ __ ______ ____            18.1.3    MSTIME: read time in ms (CALLI +23)

                    MSTIME  ac,
                    only return

            Set  c(<ac>)  to  the time,  in  milliseconds  since midnight  with  respect  to the
            process's current time zone, and return.

            This UUO is really only accurate to  plus or minus one jiffy (1/60 sec, or  about 17
            ms).

                      _______ ___ ____ ______ ____            18.1.4    RUNTIM: get TRUs (CALLI +27)

                    MOVE    ac, [frame]
                    RUNTIM  ac,
                    only return

            If <frame> does not exist, clear <ac> and return.

            If (1) the current process has  Systat (SY) license, or (2) the current  process has
            the same AUN as  <frame>, or (3) the  current process has account  supervisor status
            and the left half of its AUN matches the left half of <frame>'s, then set c(<ac>) to
            the number of  demilliTRUs charged to <frame>  (TRUs * 10^4) and  return; otherwise,
            clear <ac> and return.

                      ______ ____ ____ __ _______ ______ ____            18.1.5    TIMER: read time in jiffies (CALLI +22)

                    TIMER   ac,
                    only return

            Set c(<ac>) to  the time, in  jiffies since midnight  with respect to  the process's
            current time zone, and return.


                    ______ ______ ___ _________            18.2    GETTAB tables and functions

            The GETTAB UUO (CALLI +41, pg. 18-3)  supplies data about the current status  of the
            processes and ports on a system, as well as certain global monitor data.   A process
            may obtain  information from  various GETTAB  tables in  accordance with  the Access
            Rights it has and the Access  Rights required by the different GETTABs, as  shown in
            Table 18-4  and Table 18-6 .

                      _______ ____ _______ ______ ______ ____            18.2.1    GETTAB: read monitor tables (CALLI +41)

                    MOVE    ac, [index,,table]
                    GETTAB  ac,
                      error return
                    normal return

            If the table specified by <table> does not exist, or the index specified  by <index>
            is invalid, or  the process does  not have permission to  access the data,  take the
            error return.

            Otherwise set c(<ac>) (and c(<ac>+1) for double-precision GETTABs) to  the <index>th
            item of table <table>, and skip-return.

            Where <index> is a frame number, -1 can be used to specify the current  frame; where
            <index> is  a port number,  -1 can be  used to specify  the current  frame's command
            port.









                                                    18-3


      Environmental Information                18                         YAMM edition 2.0


                                          _____ ____                                           Table 18-4 
                                   ______ ______ __ ________                                   GETTAB tables by function


      Table  Access
      Number Req'd. **  Name      Description

      Frame data: index by FRAME descriptor

      -54    .ARRFI     .GTFTR    frame tree information
      -53    .ARRFI     .GTUID    Universal ID
      -52    .ARRPI     .GTPNO    Program Number
      -27    .ARRDS     .GTLIN    TTY: name in SIXBIT; (lh)=0 if detached
      -25    .ARRPI     .GTFPN    File Proj-prog Number
      -23    .ARRFI     .GTAUN    Accounting User Number
      -22    .ARRUN     .GTUNM    user name (1-6) SIXBIT
      -21    .ARRUN     .GTUN1    user name (7-12) SIXBIT
      -20    .ARRPI     .GTLIC    license word
      0      .ARRUN     .GTSTS    Status Bits (Table 2-7 )
      2      .ARRFI     .GTPPN    Project Programmer Number
      3      .ARRPI     .GTNAM    SIXBIT user program name
      6      .ARRPI     .GTPRV    Privilege Bits (Table 2-3 )
      7                 .GTSWP    swapper status bits
      10     .ARRDS     .GTTTY    address of TTY DDB


      Port data: index by PORT number

      -32    .ARRFI     .GTLPS    tty input line position
      -31    .ARRFI     .GTMOD    tty mode (GETSTS info)
      -26    .ARRFI     .GTJOB    frame who owns this port
      -24    .ARRFI     .GTLOG    LDBLOG info (Table 18-7b)


      Accounting data: index by FRAME descriptor

      -51    .ARRAD     .GTSPW    double precision pages-to-WS*size
      -50    .ARRAD     .GTPWS    pages to working-set
      -47    .ARRAD     .GTMPC    pages mapped/created
      -46    .ARRAD     .GTMCY    double precision microcycles
      -45    .ARRAD     .GTKCM    double precision K-core microcycles
      -44    .ARRAD     .GTTRU    double precision TRUs * 10^4
      -43    .ARRAD     .GTTR2    high order TRUs * 10^4
      -42    .ARRAD     .GTMC2    high order microcycles
      -41    .ARRAD     .GTBIO    block IO chars transmitted
      -40    .ARRAD     .GTBET    BIO elapsed time (sec)
      -37    .ARRAD     .GTSOK    TYMCHG TRUs * 10^4
      -33    .ARRAD     .GTERN    ENTER + RENAME count
      -30    .ARRDS     .GTLIM    time limit (TRUs * 10^4)
      -15    .ARRAD     .GTMC1    low order microcycles
      -14    .ARRAD     .GTKM2    high order K-core microcycles
      -13    .ARRAD     .GTBCS    K-core break chars
      -12    .ARRAD     .GTCNK    attach time (sec)
      -11    .ARRAD     .GTELP    K-core seconds
      -10    .ARRAD     .GTCOT    characters output
      -7     .ARRAD     .GTCIN    characters input
      -6     .ARRAD     .GTSOT    K-core DSK blocks out
      -5     .ARRAD     .GTSIN    K-core DSK blocks in
      -4     .ARRAD     .GTSRN    K-core ENTER + RENAME
      -3     .ARRAD     .GTSLK    K-core LOOKUP
      -2     .ARRAD     .GTDLK    LOOKUP count
      4      .ARRAD     .GTTR1    low order TRUs * 10^4
      5      .ARRAD     .GTKM1    low order K-core microcycles
      17     .ARRAD     .GTRCT    DSK blocks in
      20     .ARRAD     .GTWCT    DSK blocks out


      Global system data: index by ITEM number
                                              18-4


            July 3, 1980                             18                Environmental Information


            -36    LC.SY      .GTLNK    debugging tables
            11                .GTCNF    config data (Table 18-7 )
            12     LC.SY      .GTNSW    nonswap data (Table 18-8c)
            15     LC.SY      .GTODP    ONCE-time disk parameters (Table 18-9 )
            16                .GTLVD    level-D disk (Table 18-8b)
            23     LC.SY      .GTSLF    GETTAB table addresses
            25                .GTWSC    wait states (Table 18-10 )


            ** NOTE: see Table 2-15  for discussion of AR's and equivalent license and
                                        priviledge.

























































                                                    18-5


      Environmental Information                18                         YAMM edition 2.0


                                          _____ ____                                           Table 18-6 
                                    ______ ______ __ ______                                    GETTAB tables by number


      Table  Access     Name
      Number Req'd. **  [index]             Description

      -54    .ARRFI     .GTFTR [FD]         frame tree information
      -53    .ARRFI     .GTUID [FD]         Universal ID
      -52    .ARRPI     .GTPNO [FD]         Program Number
      -51    .ARRAD     .GTSPW [FD]         double precision pages-to-WS*size
      -50    .ARRAD     .GTPWS [FD]         pages to working-set
      -47    .ARRAD     .GTMPC [FD]         pages mapped/created
      -46    .ARRAD     .GTMCY [FD]         double precision microcycles
      -45    .ARRAD     .GTKCM [FD]         double precision K-core microcycles
      -44    .ARRAD     .GTTRU [FD]         double precision TRUs * 10^4
      -43    .ARRAD     .GTTR2 [FD]         high order TRUs * 10^4
      -42    .ARRAD     .GTMC2 [FD]         high order microcycles
      -41    .ARRAD     .GTBIO [FD]         block IO chars transmitted
      -40    .ARRAD     .GTBET [FD]         BIO elapsed time (sec)
      -37    .ARRAD     .GTSOK [FD]         TYMCHG TRUs * 10^4
      -36    LC.SY      .GTLNK [item]       debugging tables
      -35                                   (obsolete) remote IO
      -34                                   (obsolete) remote secs
      -33    .ARRAD     .GTERN [FD]         ENTER + RENAME count
      -32    .ARRFI     .GTLPS [port]       tty input line position
      -31    .ARRFI     .GTMOD [port]       tty mode (GETSTS info)
      -30    .ARRDS     .GTLIM [FD]         time limit (TRUs * 10^4)
      -27    .ARRDS     .GTLIN [FD]         TTY: name in SIXBIT; (lh)=0 if detached
      -26    .ARRFI     .GTJOB [port]       frame who owns this port
      -25    .ARRPI     .GTFPN [FD]         File Proj-prog Number
      -24    .ARRFI     .GTLOG [port]       LDBLOG info (Table 18-7b)
      -23    .ARRFI     .GTAUN [FD]         Accounting User Number
      -22    .ARRUN     .GTUNM [FD]         user name (1-6) SIXBIT
      -21    .ARRUN     .GTUN1 [FD]         user name (7-12) SIXBIT
      -20    .ARRPI     .GTLIC [FD]         license word
      -17                                   reserved
      -16                                   reserved
      -15    .ARRAD     .GTMC1 [FD]         low order microcycles
      -14    .ARRAD     .GTKM2 [FD]         high order K-core microcycles
      -13    .ARRAD     .GTBCS [FD]         K-core break chars
      -12    .ARRAD     .GTCNK [FD]         attach time (sec)
      -11    .ARRAD     .GTELP [FD]         K-core seconds
      -10    .ARRAD     .GTCOT [FD]         characters output
      -7     .ARRAD     .GTCIN [FD]         characters input
      -6     .ARRAD     .GTSOT [FD]         K-core DSK blocks out
      -5     .ARRAD     .GTSIN [FD]         K-core DSK blocks in
      -4     .ARRAD     .GTSRN [FD]         K-core ENTER + RENAME
      -3     .ARRAD     .GTSLK [FD]         K-core LOOKUP
      -2     .ARRAD     .GTDLK [FD]         LOOKUP count
      -1                                    reserved
      0      .ARRUN     .GTSTS [FD]         Status Bits (Table 2-7 )
      1                                     reserved
      2      .ARRFI     .GTPPN [FD]         Project Programmer Number
      3      .ARRPI     .GTNAM [FD]         SIXBIT user program name
      4      .ARRAD     .GTTR1 [FD]         low order TRUs * 10^4
      5      .ARRAD     .GTKM1 [FD]         low order K-core microcycles
      6      .ARRPI     .GTPRV [FD]         Privilege Bits (Table 2-3 )
      7                 .GTSWP [FD]         swapper status bits
      10     .ARRDS     .GTTTY [FD]         address of TTY DDB
      11                .GTCNF [item]       config data (Table 18-7 )
      12     LC.SY      .GTNSW [item]       nonswap data (Table 18-8c)
      13                                    (obsolete) swapper data
      14                                    (obsolete) high seg data
      15     LC.SY      .GTODP [item]       ONCE-time disk parameters (Table 18-9 )
      16                .GTLVD [item]       level-D disk (Table 18-8b)
      17     .ARRAD     .GTRCT [FD]         DSK blocks in
      20     .ARRAD     .GTWCT [FD]         DSK blocks out
                                              18-6


            July 3, 1980                             18                Environmental Information


            21                                    reserved
            22                                    reserved
            23     LC.SY      .GTSLF [item]       GETTAB table addresses
            24                                    (obsolete) dev/str name
            25                .GTWSC [item]       wait states (Table 18-10 )
            26                                    reserved
            27                                    (obsolete) physical core table
            ** NOTE: See Table 2-15  for information on AR's and equivalent license and
                                                  priviledge.



                                                _____ ____                                                 Table 18-7 
                                         ______ _______ ____ _____                                         .GTCNF (GETTAB +11) Items


            name     items description

            .CNFG0   0     System Name (in ASCII)
            .CNDT0   5     System Date (in ASCII)
            .CNTAP   7     System Device Name (in SIXBIT)
            .CNTIM   10    jiffies since midnight GMT
            .CNDAT   11    days since 1 January 1964 GMT
            .CNSIZ   12    words used by monitor
            .CNOPR   13    operator console name (in SIXBIT)
            .CNDEV   14    lh = address of first DDB
            .CNNJB   15    largest possible frame number+1
            .CNSTS   17    states word
            .CNSER   20    cpu serial number
            .CNNSM   21    memory cycle time (in nanoseconds)
            .CNFRE   22    freecore bit map AOBJN pointer
            .CNLOC   23    address of first freecore
            .CNPTS   24    number of ports
            .CNLGO   25    LOGOUT program name (in SIXBIT)
            .CNJPS   26    jiffies per second
            .CNJPM   27    jiffies per minute
            .CNJPH   30    jiffies per hour
            .CNHGH   31    highest addressible block in core
            .CNHFD   32    Snoopy facility buffer size,,beginning loc
            .CNSYS   33    system number
            .CNFCW   34    freecore words allocated
            .CNSCC   35    Soft Crash Countdown in seconds
            .CNS30   36    XWD SAV30,NUMTAB ; info for crash analysis



                                                _____ _____                                                Table 18-7b
                                          ______ ____ _______ ____                                          .GTLOG Bits (GETTAB -24)


            name   bits    meaning
            LG.ZAP 1B1     a zapper has been received on this port
            LG.GON 1B2     this port is gone
            LG.HDX 1B6     this port is half-duplex
            LG.NAX 1B16    1 if this port is not an aux circuit
            LG.TID 17B11   terminal identifier code (see Table 18-8 )
            LG.ND1 77B19   high-order 6 bits of the originating node number
            LG.ND2 77B27   low-order 6 bits of the originating node number
            LG.PORT177B35  TYMNET port number (as opposed to the monitor's port number, which is
                           the number that is part of the device name in, for example, TTY125:)








                                                    18-7


      Environmental Information                18                         YAMM edition 2.0


                                          _____ ____                                           Table 18-8 
                                   ________ __________ _____                                   Terminal Identifier Codes


      code    char                    code    char

      0       (aux circuit)           10      (unused)
      1       A                       11      <CR>
      2       C                       12      D
      3       E                       13      (2780 RJE)
      4       G                       14      (1200 baud)
      5       B                       15      (unused)
      6       F                       16      (unused)
      7       J                       17      (unused)



                                          _____ _____                                          Table 18-8b
                                    ______ _______ ___ _____                                    .GTLVD (GETTAB 16) Items


      name     item  description

      .LDMFD   0     MFD PPN [1,1]
      .LDSYS   1     SYS PPN [1,4]
      .LDFSF   2     FAILSAFE PPN  (obsolete)
      .LDHLP   3     HELP PPN (obsolete)
      .LDSPL   4     SPOOL PPN (obsolete)
      .LDDRB   5     directory block pointers
                     lh = addr of first directory block
                     rh = addr of next block to scan
                          to reclaim a block (0-> first)
      .LDSTR   6     (obsolete)
      .LDUNI   7     unit data block pointers
                     lh = addr of first unit data block
      .LDSWP   10    (unused)
      .LDCBN   11    number of file system core blocks
      .LDSTP   12    standard file protection in bits 0-8
      .LDUFP   13    standard directory protection in bits 0-8
      .LDRPC   14    number of RIB PCBs
      .LDSPC   15    number of SAT PCBs
      .LDQST   16    sixbit name of fastest STR
      .LDACT   17    accounting program PPN [6,270]
      .LDCRS   20    (obsolete)
      .LDLKB   21    longest meaningful LOOKUP block size























                                              18-8


            July 3, 1980                             18                Environmental Information




                                                _____ _____                                                Table 18-8c
                                          ______ _____ _______ ___                                          .GTNSW Items (GETTAB 12)


            name     item  description

            .NSCMX   10    maximum CORE request + 1
            .NSCTL   12    # free core blocks left
            .NSUPT   15    uptime (in jiffies)
            .NSHJB   20    highest frame number currently assigned
            .NSCLW   21    (obsolete) words cleared by CLRCOR
            .NSLST   22    lost time (in jiffies)
            .NSMMS   23    physical memory size (in words)
            .NSTPE   24    # parity errors
            .NSSPE   25    # spurious parity errors
            .NSCPE   26    # oper cont from parity errors
            .NSMPA   27    addr of last parity error
            .NSMPW   30    contents of that word
            .NSMPP   31    PC at the time of that error
            .NSNUL   34    null time (tics)
            .NSNMN   35    null time during the last minute (tics)
            .NSALR   36    alarm (unhappy msg) bits
            .NSMWM   37    monitor WS max size
            .NSUID   40    latest UID issued (SYSUID)
            .NSSTM   41    uptime of latest SCNSER cycle
            .NSMXT   42    max time between SCNSER cycles
            Unlisted item numbers are obsolete; they return 0.



                                                _____ ____                                                 Table 18-9 
                                _____________ ____ _____ _______ ___________                                .GTODP(GETTAB +15) items (ONCDSK parameters)


            name     item  description

            .ODSWH   0     highest block for swapping (obsolete)
            .ODSWK   1     K of disk words for swapping (obsolete)
            .ODPRT   2     in-core protect mult (tics/page)
            .ODPRA   3     in-core protect offset (tics)
            .ODMXP   4     max value for ICPT function
            .ODDCT   5     action code for DSKCLN
























                                                    18-9


      Environmental Information                18                         YAMM edition 2.0


                                          _____ _____                                           Table 18-10 
                          _____________ ____ _____ _____ _____ ______                          .GTWSC(GETTAB +25) items (Wait State Codes)


      name    meaning

      WS.RN    running
      WS.WS    I/O wait satisfied
      WS.TS    Terminal I/O wait satisfied
      WS.SS    Swap wait satisfied
      WS.SI    SAT I/O wait
      WS.RI    RIB I/O wait
      WS.PS    SAT primary PCB wait
      WS.PR    RIB primary PCB wait
      WS.M2    Two PCB wait
      WS.DA    Disk Allocation wait
      WS.CB    File system Core Block resource wait
      WS.FC    Freecore wait
      WS.MT    Magtape control wait (up to 8 units)
      WS.AX    Aux Circuit resource wait
      WS.AC    Accounting Resource wait
      WS.BP    Block I/O port resource wait
      WS.IOW   I/O wait
      WS.MBW   Monitor Buffer wait
      WS.TIO   Terminal I/O wait
      WS.SW    Swap wait
      WS.ML    PCB Lock queue wait
      WS.IL    Club Interlock wait
      WS.FL    File wait (atomic lock queue)
      WS.SL    Sleep
      WS.NU    Null (no process here)
      WS.ST    Stop (usually displayed "^C")



              __________ _______ ______      18.3    Addressing Monitor Memory

      A process with Read Core (RC) license can read arbitrary words from  monitor memory,
      and a  process with Write  Core (WC)  license can write  arbitrary words  in monitor
      memory.   It does  so  by supplying  absolute  (physical) or  virtual  (exec mapped)
      addresses  to   the  PEEK  UUO   (CALLI +33,  pg. 18-11),  VPEEK   UUO  (CALLI -136,
      pg. 18-10),  or  POKE  UUO  (CALLI -12, pg. 18-11)  .  The  BITPOK  UUO (CALLI -120,
      pg. 18-11)  allows  read/modify/write access  to  physical memory  in  one operation
      allowing the user to change specified  fields within a word without concern  for the
      value of the other bits.

                ______ ________________ ____ ______ _____      18.3.1    VPEEK: Virtual/Physical PEEK (CALLI -136)

              MOVE    AC,[<flag>B0,,<addr>]
              VPEEK   AC,
               error return
              normal return
      where
      <flag>=1        <addr> is exec virtual address
      <flag>=0        <addr> is exec physical address

      If the process does not have Read Core (RC) license, or if <flag>=0 and the physical
      address <addr> is either negative or less  than 20 or has no memory assigned,  or if
      <flag>=1 and the virtual address <addr>  cannot be accessed without an exec  ILL MEM
      REF or page fault, then take the error return.

      Take the normal return with AC/ contents of <addr>






                                             18-10


            July 3, 1980                             18                Environmental Information


                      _____ __________ ____ _______ ____ ______ ____            18.3.2    PEEK: (obsolete) read monitor core (CALLI +33)

                    MOVE    ac, [addr]
                    PEEK    ac,
                    only return

            If the process  does not have Read  Core (RC) license, or  if <addr> is  negative or
            larger  than the  highest physical  memory  address, set  c(<ac>) to  0  and return;
            otherwise, set c(<ac>) to c(<addr>) and return.

                      _____ _____ __ _______ ____ ______ ____            18.3.3    POKE: write in monitor core (CALLI -12)

                    MOVEI   ac,[    data
                                    <flag>B0+addr   ]
                    POKE    ac,
                      error return
                    normal return
            where <flag>=0 for physical <addr>
                  <flag>=1 for virtual <addr>

            If the process does not have Write  Core (WC) license, or if <flag>=0 and  <addr> is
            larger than the highest physical memory address, or if <flag>=1 and <addr> cannot be
            written without an exec memory  protection failure or addressing failure,  then take
            the error return.

            Otherwise, set c(<addr>) to <data>, and take the normal return.

                      _______ _________________ __ _______ ______ ______ _____            18.3.4    BITPOK: read/modify/write in monitor memory (CALLI -120)

                    MOVEI   ac,[    <flag>B0+<address>
                                    andcam word
                                    iorm word       ]
                    BITPOK ac,
                      error return
                    normal return

            where <flag>=0 for physical <address>, and
                  <flag>=1 for virtual <address>

            The BITPOK  uuo allows the  user to set  and clear specific  bits in  monitor memory
            without affecting other bits in the same word.

            The second word in  the argument block is the  ANDCAM word.  It is  complemented and
            ANDedinto the  specified address.  The  third word, the  IORM word, is  ORedinto the
            specific address.

            The UUO fails if the user or  process does not have Write Core (WC) license,  if the
            physical <address> does  not exist, or if  the virtual <address> cannot  be accessed
            without a monitor page failure or  write violation.  If the user has Read  Core (RC)
            license, the UUO returns the previous contents of the specified address in the ac.


                    ______ ___ ________            18.4    Lights and Switches

            Any process can read the current KI-10 console switch settings or display a value in
            the console lights, though neither operation is especially useful.

            To read the switches, a program executes the SWITCH UUO (CALLI +20,  pg. 18-12).  To
            display a 36 bit  word in the lights, a  program executes the LIGHTS  UUO (CALLI -1,
            pg. 18-12).








                                                   18-11


      Environmental Information                18                         YAMM edition 2.0


                _______ _______ ____ __ _______ ______ ______ ___      18.4.1    LIGHTS: display word in console lights (CALLI -1)

              MOVE    ac, [data]
              LIGHTS  ac,
              only return

      Display <data> in the console lights.  Return.

                _______ ____ _______ ________ ______ ____      18.4.2    SWITCH: read console switches (CALLI +20)

              SWITCH  ac,
              only return

      Set c(<ac>) to the console switch setting and return.






















































                                             18-12


            July 3, 1980                             19                 Miscellaneous Operations


                                                 _______ __                                                 Section 19
                                          _____________ __________                                          Miscellaneous Operations

                                             Table of Contents



            SubSection


            19.1     Operator Functions    19-1
            19.1.1      SETUUO: do SET command functions (CALLI +75)    19-1
                           .STTYO: OUTSTR to OPR terminal (SETUUO fn 0)    19-1
                           .STSTA: set STATES (SETUUO fn 1)    19-1
                           .STFAR: finish auto-restart (SETUUO fn 2)    19-1
                           .STTIM: set time (SETUUO fn 3)    19-1
                           .STDAT: set date (SETUUO fn 4)    19-2
                           .STBST: Set/Read BOOTS command string (SETUUO fn 11)    19-2
                           .STRES: Read/Set RESTART bits (SETUUO fn 12)    19-2
            19.1.2      ONEJOB: skip if only frame and super-shut (CALLI -20)    19-3
            19.1.3      SETABK: Set/Clear Address Break (CALLI -131)    19-3

            19.2     Executing IO instructions (User-IOT)    19-4
            19.2.1      TRPSET: Set/Clear User-IOT (CALLI +25)    19-4

            19.3     Accounting Device Control Functions    19-4

            19.4     Obsolete and Unavailable Functions    19-5
            19.4.1      Current List    19-5
            19.4.1      GETPFW: (obsolete) (CALLI -121)    19-5
            19.4.1      RDHIST: (not available) (CALLI -117)    19-5
            19.4.1      SNOOP: (not available) (CALLI -116)    19-5
            19.4.1      DDT620: (obsolete) interrogate 620 (CALLI -54)    19-5
            19.4.1      VALRMT: (obsolete) validate 620 password (CALLI -53)    19-5
            19.4.1      IDLRMT: (obsolete) set 620 idle (CALLI -51)    19-5
            19.4.1      ZAPRMT: (obsolete) zap 620 port (CALLI -50)    19-5
            19.4.1      CRERMT: (obsolete) create 620 port (CALLI -47)    19-5
            19.4.1      CALIM5: (obsolete) (CALLI -5)    19-5
            19.4.1      CALIM4: (obsolete) (CALLI -4)    19-5
            19.4.1      CALIM3: (obsolete) (CALLI -3)    19-5
            19.4.1      CALIM2: (obsolete) (CALLI -2)    19-5
            19.4.1      DDTGT: (obsolete) Get DDT mode (CALLI +5)    19-5
            19.4.1      DDTRL: (obsolete) Release DDT mode (CALLI +7)    19-5
            19.4.1      UTPCLR: (obsolete) (CALLI +13)    19-5
            19.4.1      TRPJEN: (obsolete) (CALLI +26)    19-5
            19.4.1      SETPOV: (obsolete) Set PDL OV trap (CALLI +32)    19-5
            19.4.1      SPYUUO: (obsolete) (CALLI +42)    19-5


            Table

            19-4     SETABK control bits    19-4
















                                                    19-i


                                               19                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             19-ii


            July 3, 1980                             19                 Miscellaneous Operations





                                                 _______ __                                                 Section 19
                                          _____________ __________                                          Miscellaneous Operations





                    ________ _________            19.1    Operator Functions

                      _______ __ ___ _______ _________ ______ ____            19.1.1    SETUUO: do SET command functions (CALLI +75)

                    MOVE    ac, [function,,addr]
                    SETUUO  ac,
                      error return
                    normal return

                        _______ ______ __ ___ ________ _______ __ __            19.1.1.1    .STTYO: OUTSTR to OPR terminal (SETUUO fn 0)

                    MOVE    ac, [.STTYO,,[ASCIZ/message/]]
                    SETUUO  ac,
                      error return
                    normal return

            If the process does not have oper license, error-return; otherwise, print message on
            the OPR terminal if there is one, or on CTY if there is not, and skip-return.

                        _______ ___ ______ _______ __ __            19.1.1.2    .STSTA: set STATES (SETUUO fn 1)

                    MOVE    ac, [.STSTA,,states]
                    SETUUO  ac,
                      error return
                    normal return

            If the process does not have Operator (OP) license, error-return; otherwise, set the
            right half of the STATES word to <states> and skip-return.

                        _______ ______ ____________ _______ __ __            19.1.1.3    .STFAR: finish auto-restart (SETUUO fn 2)

                    MOVSI   ac, .STFAR
                    SETUUO  ac,
                      error return
                    normal return

            If  the  monitor  is not  in  auto-restart  mode  (bit 35  is  not  set  in STATES),
            error-return; otherwise, start the remainder of the auto-restart frames.   (This UUO
            used by DSKCLN when it finishes).

                        _______ ___ ____ _______ __ __            19.1.1.4    .STTIM: set time (SETUUO fn 3)

                    MOVE    ac, [.STTIM,,time]
                    SETUUO  ac,
                      error return
                    normal return

            If the  process does  not have Operator  (OP) or  Jacct (JL)  license, error-return;
            otherwise, set the system time  to <time>, interpreted as minutes since  midnight in
            the current process's time zone, and skip-return.








                                                    19-1


      Miscellaneous Operations                 19                         YAMM edition 2.0


                  _______ ___ ____ _______ __ __      19.1.1.5    .STDAT: set date (SETUUO fn 4)

              MOVE    ac, [.STDAT,,date]
              SETUUO  ac,
                error return
              normal return

      If the  process does  not have Operator  (OP) or  Jacct (JL)  license, error-return;
      otherwise,  set  the  date  to  <date>,  interpreted  as  a  DEC-format   date,  and
      skip-return.

                  _______ ________ _____ _______ ______ _______ __ ___      19.1.1.6    .STBST: Set/Read BOOTS command string (SETUUO fn 11)

              MOVE    ac,[.STBST,,<addr>]
              SETUUO  ac,
               error return           ;no license or string too long
              normal return           ;AC/max length in characters

      ADDR:   <flag>B0,,<stringaddress>

      <flag>=1 to write the BOOTS command string
      <flag>=0 to read the string

      <stringaddress>= address of ASCIZ string to write to monitor
                      or to copy into from monitor
      <stringaddress>=0 to clear the BOOTS command string to nulls


      If the caller has neither Read  Core (RC) nor Operator (OP) license, take  the error
      return.

      If <addr>=0 set AC to the maximum BOOTS command string length in characters and take
      the normal return.

      If  <flag>=0  copy  characters from  the  BOOTS  command string  in  the  monitor to
      <stringaddress>, terminating  on the  null character;  set AC  to the  maximum BOOTS
      command string length in characters and take the normal return.

      <flag>=1.  If the  caller is missing Operator  (OP) license, take the  error return.
      If <stringaddress>=0, set the  BOOTS command string to  null, set AC to  the maximum
      BOOTS command string length in characters, and take the normal return.

      <stringaddress>  is non-zero.   Copy characters  from <stringaddress>  to  the BOOTS
      command  string.  If  the caller's  ASCIZ string  is longer  than the  maximum BOOTS
      command string length, copy as much  as possible and terminate with a null.   Set AC
      to the maximum BOOTS command string length in characters, and take the  error return
      if the  string was  too long,  or the  normal return  if the  string was  within the
      maximum.

                  _______ ________ _______ ____ _______ __ ___      19.1.1.7    .STRES: Read/Set RESTART bits (SETUUO fn 12)

              MOVE    ac,[.STRES,<bits>]
              SETUUO  ac,
               error return           ;license missing
              normal return

      <bits>:
      bit(s)  function

      1B18    0-read RESTART bits into rh(AC)
              1-swap RESTART bits with bits in AC
      1B19    0-write DSKCLN type to HOM blocks
              1-do not write DSKCLN type to HOM blocks
      377B27  crash RESTART bits
      377B35  orderly takedown RESTART bits



                                              19-2


            July 3, 1980                             19                 Miscellaneous Operations


            The structure of the <crash> and <hangup> fields is
            identical. Numbering the bits in the field from 0 to
            7 [higher to lower order], the structure is:

            bit(s)  function
            1B0     the auto/manual BOOTS bit is defined
            1B1     the auto/manual ONCE bit is defined
            1B2     the DSKCLN type field is defined
            1B3     auto/manual BOOTS bit:
                    1-manual BOOTS (requests CTY input)
                    0-auto BOOTS (BOOTS reads command string
                      passed to it by crash code)
            1B4     auto/manual ONCE bit:
                    1-manual ONCE (requests CTY input)
                    0-auto ONCE restart, no CTY input
            7B7     DSKCLN type field:
              0     no DSKCLN
              1     quick DSKCLN
              7     full DSKCLN
             other values of DSKCLN type currently undefined

            If the caller has  neither Operator (OP) or Read  Core (RC) license, take  the error
            return.

            Set AC to the current monitor RESTART bits.

            If 1B18 in <bits> is 0, take the normal return.

            If the caller is missing Operator (OP) license, take the error return.

            Set the monitor RESTART bits to <bits> and take the normal return.

                      _______ ____ __ ____ _____ ___ __________ ______ ____            19.1.2    ONEJOB: skip if only frame and super-shut (CALLI -20)

                    ONEJOB
                    return1
                    return2

            If this is the only frame  on the system and the system is  super-shut, skip-return;
            otherwise nonskip-return.

                      _______ _________ _______ _____ ______ _____            19.1.3    SETABK: Set/Clear Address Break (CALLI -131)

                    MOVE    AC,[<bits>,,<address>]
                    SETABK  ac,
                     error return   ;AC unchanged
                    normal return   ;AC/ previous <bits>,,<address>

            where <bits> are from Table 19-4 

            If the  hardware processor is  a KI-10,  or if <bits>  specifies a  monitor adddress
            break and the caller does not  have Write Core (WC) license, take the  error return.
            Otherwise, cause the paging hardware to generate an address-break pagefault  trap on
            the next reference to <address> of  the type specified by <bits>, or, if  <bits> and
            <address> are zero, clear all adddress-breaks.  Set AC to the previous address-break
            <bits> and <address> and take the normal return.












                                                    19-3


      Miscellaneous Operations                 19                         YAMM edition 2.0


                                          _____ ____                                           Table 19-4 
                                      ______ _______ ____                                      SETABK control bits


      name     bit   meaning

      AB.FET   1B9   break on instruction-fetch from <address>
      AB.RED   1B10  break on reads from <address>
      AB.WRT   1B11  break on writes to <adddress>
      AB.USR   1B12  0=monitor, 1=user address



              _________ __ ____________ __________      19.2    Executing IO instructions (User-IOT)

      "User-IOT" is a bit  in the PC word which  allows user mode processes to  execute IO
      class instructions.  "I/O class" is a group of instructions which are  prohibited in
      user  mode  by the  hardware  unless  User-IOT is  set  in the  PC  word.   (see the
      DECsystem-10 Hardware  Reference Manual) The  PDP-10 hardware typically  restricts a
      user mode program  from executing IO class  instructions.  Programs running  in user
      mode with the User-IOT  bit set in their PC  word are exempt from  this restriction.
      Only  an  exec mode  process  has  the ability  to  set this  bit.   The  TRPSET UUO
      (CALLI +25, pg. 19-4)  allows the  user having Write  Core (WC)  license to  set the
      User-IOT bit.   This is  a very hazardous  practice and  should be  avoided whenever
      possible.

                _______ _________ ________ ______ ____      19.2.1    TRPSET: Set/Clear User-IOT (CALLI +25)

              TRPSET ac,
                error return          ; insuficient license
              normal return

      where <ac> contains zero (0) to turn off User-IOT
      or minus-one (-1) to turn it on.

      The TRPSET  uuo will  allow the  user with .WC  to set  the user-IOT  bit in  his PC
      allowing him to execute IO instrcutions from his user program.

      The monitor  may perform other  internal tasks when  setting and  clearing User-IOT.
      Therefore it is bad practice to clear user-IOT by any means other this UUO.

      Note the  differences between TYMCOM-X  and TOPS-10 versions  of TRPSET:  ac:=-1 not
      legal on TOPS-10; ac:=[n,,adr] not legal on TYMCOM-X. In other words, this  uuo does
      not allow the user to specify PI trap locations in his address space.


              __________ ______ _______ _________      19.3    Accounting Device Control Functions

      The ACT  device is  controlled by  the CHKPNT  program.  CHKPNT  uses the  MTAPE UUO
      (op code 072, pg. 11-3) with  effective address 110 to  cause the device to  give an
      EOF when the  next monitor buffer  is emptied.  It  uses the INTRMT  UUO (CALLI -52,
      pg. 16-6)  to  cause the  ACT  to give  input-available  and input-is-about-to-block
      interrupts.















                                              19-4


            July 3, 1980                             19                 Miscellaneous Operations


                    ________ ___ ___________ _________            19.4    Obsolete and Unavailable Functions

                      _______ ____            19.4.1    Current List
                      _______ __________ ______ _____            19.4.1    GETPFW: (obsolete) (CALLI -121)
                      _______ ____ __________ ______ _____            19.4.1    RDHIST: (not available) (CALLI -117)
                      ______ ____ __________ ______ _____            19.4.1    SNOOP: (not available) (CALLI -116)
                      _______ __________ ___________ ___ ______ ____            19.4.1    DDT620: (obsolete) interrogate 620 (CALLI -54)
                      _______ __________ ________ ___ ________ ______ ____            19.4.1    VALRMT: (obsolete) validate 620 password (CALLI -53)
                      _______ __________ ___ ___ ____ ______ ____            19.4.1    IDLRMT: (obsolete) set 620 idle (CALLI -51)
                      _______ __________ ___ ___ ____ ______ ____            19.4.1    ZAPRMT: (obsolete) zap 620 port (CALLI -50)
                      _______ __________ ______ ___ ____ ______ ____            19.4.1    CRERMT: (obsolete) create 620 port (CALLI -47)
                      _______ __________ ______ ___            19.4.1    CALIM5: (obsolete) (CALLI -5)
                      _______ __________ ______ ___            19.4.1    CALIM4: (obsolete) (CALLI -4)
                      _______ __________ ______ ___            19.4.1    CALIM3: (obsolete) (CALLI -3)
                      _______ __________ ______ ___            19.4.1    CALIM2: (obsolete) (CALLI -2)
                      ______ __________ ___ ___ ____ ______ ___            19.4.1    DDTGT: (obsolete) Get DDT mode (CALLI +5)
                      ______ __________ _______ ___ ____ ______ ___            19.4.1    DDTRL: (obsolete) Release DDT mode (CALLI +7)
                      _______ __________ ______ ____            19.4.1    UTPCLR: (obsolete) (CALLI +13)
                      _______ __________ ______ ____            19.4.1    TRPJEN: (obsolete) (CALLI +26)
                      _______ __________ ___ ___ __ ____ ______ ____            19.4.1    SETPOV: (obsolete) Set PDL OV trap (CALLI +32)
                      _______ __________ ______ ____            19.4.1    SPYUUO: (obsolete) (CALLI +42)















































                                                    19-5


      Miscellaneous Operations                 19                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                              19-6


            July 3, 1980                             20                               Accounting


                                                 _______ __                                                 Section 20
                                                 __________                                                 Accounting

                                             Table of Contents



            SubSection


            20.1     Special charging    20-1
            20.1.1      XCHARG: modify charges (CALLI -60)    20-1
                           .XCSAV: save charging data (XCHARG fn 0)    20-1
                           .XCRSC: read saved charges (XCHARG fn 1)    20-2
                           .XCRCC: read current charges (XCHARG fn 2)    20-2
                           .XCSET: set charges (XCHARG fn 4)    20-2
                           .XCTRN: write transaction charges (XCHARG fn 5)    20-3
                           .XCTCC: Write TRU Component Checkpoint (XCHARG fn 6)    20-3
            20.1.2      Saving Charges    20-4
            20.1.3      Reading Current Charges    20-4
            20.1.4      Setting Charges    20-4
            20.1.5      TRU Component Checkpoint    20-5

            20.2     Royalty Charging    20-5
            20.2.1      PUTROY: Put Royalty Record in Stream (CALLI -124)    20-5
            20.2.2      TYMCHG: add TRU charges (CALLI -56)    20-5

            20.3     Writing Stream Records    20-6
            20.3.1      PUTLSA: write local stream acctg record (CALLI -63)    20-6
            20.3.2      PUTSAR: write stream acctg record (CALLI -62)    20-6

            20.4     Stream Accounting Data    20-7


            Table

            20-1     XCHARG functions by number    20-1
            20-3     .XCSET Error Codes    20-3
            20-4     XCHARG Charge Table Entries    20-4
            20-6     Stream Royalty Record Words 5,6,7,10    20-6
            20-7     PUTSAR error codes    20-7
            20-7b    Stream Accounting Record Types    20-7
            20-8     Stream Accounting Record Lengths    20-8
            20-8b    Stream Record Std. Header words 0-4    20-8
            20-8c    Stream Record types 0-6 (GET/RUN etc) format    20-8
            20-8d    Change Project-Code Record words 5-7    20-8
            20-8e    System Initialization Record words 0-1    20-9
            20-9     Date Change Record words 0-5    20-9
            20-9b    Local Stream Accounting Record words 5-7    20-9
            20-9c    SETLIC/SETE Record words 5-7    20-9
            20-9d    License-Setting RUN Record words 0-2    20-9
            20-9e    LOGINN Record words 3-6    20-10
            20-10    Uptime Record words 0-2    20-10
            20-10b   Restart Record words 0-1    20-10
            20-10c   Stream Error Record words 0-1    20-10
            20-11    LOGOUT and CHKPNT stream record format    20-11
            20-12    XCHARG stream record format    20-12











                                                    20-i


                                               20                         YAMM edition 2.0

































                                               *  
                                             *   *
                                               *  


































                                             20-ii


            July 3, 1980                             20                               Accounting





                                                 _______ __                                                 Section 20
                                                 __________                                                 Accounting





                    _______ ________            20.1    Special charging

            A process having  XCharge (XC) license  to alter the  normal system charges  for the
            frame.  The  XCHARG UUO  (CALLI -60, pg. 20-1) is  used to  alter the  charges being
            accumulated for the current frame.

                      _______ ______ _______ ______ ____            20.1.1    XCHARG: modify charges (CALLI -60)

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return
                    normal return

            addr:   <function code>
                    <arguments>

            If  the function  code is  invalid, error-return.   (see Table 20-1   for functions)
            Otherwise, perform the specified XCHARG function.

                        _______ ____ ________ ____ _______ __ __            20.1.1.1    .XCSAV: save charging data (XCHARG fn 0)

                    MOVE    ac, [-1,,[.XCSAV]]
                    XCHARG  ac,
                      JFCL  ; never taken
                    normal return

            Save the charging data shown above and skip-return.


                                                _____ ____                                                 Table 20-1 
                                         ______ _________ __ ______                                         XCHARG functions by number


            Function Name      Description

              fn 0   .XCSAV    save charging data
              fn 1   .XCRSC    read saved charges
              fn 2   .XCRCC    read current charges
              fn 3             (obsolete) reset charges
              fn 4   .XCSET    set charges
              fn 5   .XCTRN    write transaction charge
              fn 6   .XCTCC    write tru checkpoint
















                                                    20-1


      Accounting                               20                         YAMM edition 2.0


                  _______ ____ _____ _______ _______ __ __      20.1.1.2    .XCRSC: read saved charges (XCHARG fn 1)

              MOVE    ac, [-count,,addr]
              XCHARG  ac,
                error return
              normal return

      where <addr> points to a <count>-long table of the form
              wd 0    .XCRSC  ; function code
              wd 1    mask
              wd 2+   ; see below

      If the process  has not done an  .XCSAV, or if <count>  < 2, take the  error return;
      otherwise, let <next> initially be 2, and for <j> from 0 to min(<count>-2,the length
      of the XCHARG data), perform the following:

          If c(<mask> bit  <j>) = 1, set  c(<addr>+<next>) to the  corresponding saved
          charge word, and add 1 to <next>.

      Skip-return.

                  _______ ____ _______ _______ _______ __ __      20.1.1.3    .XCRCC: read current charges (XCHARG fn 2)

              MOVE    ac, [-count,,addr]
              XCHARG  ac,
                error return
              normal return

      where <addr> points to a <count>-long block of the form
              wd 0    .XCRCC  ; function code
              wd 1    mask
              wd 2+   ; see below

      If <count> < 2, take the error return; otherwise, let <next> initially be 2, and for
      <j> from 0 to min(<count>-2,the length of the XCHARG data), perform the following:

          If c(<mask> bit <j>) = 1, set c(<addr>+<next>) to the  corresponding current
          charge word, and add 1 to <next>.

      Skip-return.

                  _______ ___ _______ _______ __ __      20.1.1.4    .XCSET: set charges (XCHARG fn 4)

              MOVE    ac, [-count,,addr]
              XCHARG  ac,
                error return  ; c(<ac>) := error code
              normal return

      where <addr> points to a <count>-long block of the form
              wd 0    .XCSET  ; function code
              wd 1    mask
              wd 2+   ; see below

      If the process does not have XCharge (XC) license, or if the process has not done an
      .XCSAV, or if <count>  < 4 or >  the number of components +  2, or if the  system is
      running without accounting, or if <mask> has any bit <j> set where <j>  > <count>-2,
      take the error return; otherwise, let <errmsk> initially be 0, and for <j> from 0 to
      min(<count>-2,the number of savable components), perform the following:

          If c(<addr>+2+<j>) is less than  the corresponding saved value or  more than
          the  corresponding  current  value,  set  <errmsk>  bit  <j>  and  leave the
          component unchanged;  otherwise, set the  corresponding charge  component to
          c(<addr>+2+<j>).

      IF any bits are set in <errmsk>, error-return; otherwise, skip-return.



                                              20-2


            July 3, 1980                             20                               Accounting


                        _______ _____ ___________ _______ _______ __ __            20.1.1.5    .XCTRN: write transaction charges (XCHARG fn 5)

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return  ; ac/ error code
                    normal return

            addr:   wd 0    .XCTRN  ; function code
                    block n         ; user supplied data
            count=  .-addr

            If the process does not have XCharge (XC) license, or if <count> is less than  2, or
            if <count> is greater than '27, or if the system is running without accounting, take
            the error  return; otherwise,  write a transaction  record containing  the specified
            data into the stream accounting file as record type '17.

            The user supplied data may contain up to '26 words.  The format of the data  must be
            agreed upon by the user and the accounting department.  No signifigance is placed on
            the data by the operating system.


                                                _____ ____                                                 Table 20-3 
                                             ______ _____ _____                                             .XCSET Error Codes


            code   condition

                   0 process does not have XCharge (XC) license
                   1 no save (.XCSAV) done
                   2 system running without accounting
                   3 bad component value; bits 0-32 of AC is <errmsk>
                   4 bad <count>
                   5 too many bits in <mask>


                        _______ _____ ___ _________ __________ _______ __ __            20.1.1.6    .XCTCC: Write TRU Component Checkpoint (XCHARG fn 6)

                    MOVE    AC,[-count,,[.XCTCC]]
                    XCHARG  AC,
                      error return  ;ac contains <error code>
                    normal return   ;ac unchanged

            Where the <error code> is from Table 20-3 .

            The value  of <count>  is ignored  by the  system; (this  calling sequence  has been
            chosen to be consistent with that of other XCHARG functions).

            If the caller lacks XCharge (XC) license, or if no stream accounting is  not active,
            take the error return.

            Generate a TRU component checkpoint  record in the accounting stream,  which records
            the value of each component at the time of the call.  Take the normal return.
















                                                    20-3


      Accounting                               20                         YAMM edition 2.0


                ______ _______      20.1.2    Saving Charges

      A process (with or without XCharge (XC) license) can save the current  charging data
      into the monitor's table by executing the .XCSAV UUO (XCHARG fn 0, pg. 20-1).


                                          _____ ____                                           Table 20-4 
                                  ______ ______ _____ _______                                  XCHARG Charge Table Entries


      mask GETTAB   description

      0    .GTKM2   kilo-core microcycles (high-order)
      1    .GTKM1   kilo-core microcycles (low-order)
      2    .GTMC2   microcycles (high-order)
      3    .GTMC1   microcycles (low-order)
      4    .GTELP   kilo-core seconds (elapsed time*size)
      5    .GTBCS   kilo-core break characters input
      6    .GTCIN   characters input
      7    .GTCOT   characters output
      10   .GTBET   block i/o elapsed time (seconds)
      11   .GTBIO   block i/o characters
      12   .GTSRN   kilo-core ENTERs + RENAMEs
      13   .GTSLK   kilo-core LOOKUPs
      14   .GTSIN   kilo-core disk blocks read
      15   .GTSOT   kilo-core disk blocks written
      16   .GTERN   # ENTERs + # RENAMEs
      17   .GTDLK   # LOOKUPs
      20   .GTRCT   disk blocks read
      21   .GTWCT   disk blocks written
      22   .GTMPC   # VCREATs + (4 * # .CHMFPs)
      23   .GTPWS   # pages added to working set
      24            kilo-core pages added to wkg set (high-order)
      25            kilo-core pages added to wkg set (low-order)


                _______ _______ _______      20.1.3    Reading Current Charges

      The current  charges can  all be  obtained from  GETTAB tables,  but the  .XCRCC UUO
      (XCHARG fn 2, pg. 20-2) is more convenient to use, since it reads the charges into a
      table of the same format as used by the other XCHARG functions.

                _______ _______      20.1.4    Setting Charges

      The normal use of the above  3 XCHARG functions by an XCHARG-licensed program  is as
      follows:  first,  do  an  .XCSAV  to  save  the  current  charges;  then  process  a
      transaction; then do an .XCRSC and an .XCRCC to read the saved and  current charges,
      compute, for each charge component, what the frame is to be charged (the result must
      be between the corresponding  saved and current values);  then do an .XCSET  to pass
      the monitor the computed charges.

      It is  important to  note that  the .XCRSC  and .XCRCC  functions read  the selected
      components into  contiguous locations  into the  user's data  block, but  the .XCSET
      function expects  to find each  component value in  the position it  would be  in if
      <mask> were  all ones.  The  easiest way to  accomplish this is  to always  read all
      charge components when doing an .XCRSC or .XCRCC.

      To set the charges, a program executes the .XCSET UUO (XCHARG fn 4, pg. 20-2).










                                              20-4


            July 3, 1980                             20                               Accounting


                      ___ _________ __________            20.1.5    TRU Component Checkpoint

            Certain  XC-licensed   programs  may  use   another  XCHARG  function,   .XCTCC  UUO
            (XCHARG fn 6,  pg. 20-3),  to  place  a  TRU  Component  Checkpoint  record  in  the
            accounting stream.  Such records are useful in analyzing the resource demands placed
            upon the system by heavily-used programs.


                    _______ ________            20.2    Royalty Charging

            Any program can add a royalty  charge to the current frame's TRU count  by executing
            the  TYMCHG  UUO (CALLI -56,  pg. 20-5).   Any  process or  program  running  on the
            Tymcom-X may have one or more  Royalty Product ID's associated with it  according to
            product  licensing  agreement files  maintained  by Tymshare  Marketing.   A Royalty
            product  can  record  the fact  that  it  was executed  by  issuing  the  PUTROY UUO
            (CALLI -124, pg. 20-5).  Persons  wishing to have  Royalty Product ID's  assigned to
            their programs should contact Marketing.

                      _______ ___ _______ ______ __ ______ ______ _____            20.2.1    PUTROY: Put Royalty Record in Stream (CALLI -124)

                    MOVE    ac,[BYTE (1)<flag> (35)<royalty product ID>]
                    PUTROY  ac,
                     error return   ; AC unchanged
                    normal return   ; AC unchanged

            The meaning of <flag> will be:
            <flag>=0        This record signals the beginning of a
                            Royalty session
            <flag>=1        This record signals the end of a Royalty session


            If the accounting system is  not operating (stream accounting records are  not being
            written to accounting  files) then take the  error return; otherwise write  a stream
            record as shown in table Table 20-6 .

            <royalty product ID>'s are not to be invented by the callers of this UUO;  they must
            be cleared thru Marketing to be certain that they do not conflict with those  in use
            for other Royalty Products.

                      _______ ___ ___ _______ ______ ____            20.2.2    TYMCHG: add TRU charges (CALLI -56)

                    MOVE    ac, [charge]
                    TYMCHG  ac,
                    only return

            where <charge> is the number of TRUs to add

            Let  <TRUs>  be <charge>  logically  ANDed with  '377.   Add <TRUs>  to  the frame's
            added-charge word, unless doing so would make that word overflow, and return.



















                                                    20-5


      Accounting                               20                         YAMM edition 2.0


                                          _____ ____                                           Table 20-6 
                              ______ _______ ______ _____ ________                              Stream Royalty Record Words 5,6,7,10


      word   bits    contents;

      5              program name (JBTNAM)
      6              program source UFD (JBTFPN)
      7              current contents of premium cell JBTSOK
      10     0       <begin/end flag> 0 implies that this record signals the beginning of
                     a Royalty session. 1 implies the end of a session.
             1-35    Royalty Product ID



              _______ ______ _______      20.3    Writing Stream Records

      Any program  can, once  and only  once during  its execution,  execute a  PUTLSA UUO
      (CALLI -63,  pg. 20-6)  to output  a  local stream  accounting  record.   The record
      output has the same  format as a RUN record,  except that the program name  field is
      specified by the caller of PUTLSA.  The UUO is useful for tracking  variant versions
      of a program.

      A process with Jacct (JL) license  can cause the monitor to write a  LOGINN, CHKPNT,
      LOGOUT, or uptime record by executing the PUTSAR UUO (CALLI -62, pg. 20-6).

                _______ _____ _____ ______ _____ ______ ______ ____      20.3.1    PUTLSA: write local stream acctg record (CALLI -63)

              MOVEI   ac, [SIXBIT /identifier/]
              PUTLSA  ac,
              only return

      If a  PUTLSA has  already been done  since the  last RUN/RUNSEG/START,  just return;
      otherwise, write  a local stream  accounting record, using  <identifier> for  word 5
      unless <identifier> is null (c(<ac>) =  0), in which case using the  current program
      name, then return.

                _______ _____ ______ _____ ______ ______ ____      20.3.2    PUTSAR: write stream acctg record (CALLI -62)

              MOVEI   ac, addr
              PUTSAR  ac,
                error return  ; c(<ac>) := error code
              normal return

      where <addr> points to a block of the form
              wd 0  bits 0-8    type
                    bits 30-35  record length
              wd 1+             ; contents of record

      If the system is  running without accounting, or if  the process is not  licensed to
      write a record of  type <type>, or if <record  length> is incorrect for a  record of
      type <type>, or if <type> is  bad, take the error return; otherwise, write  a stream
      accounting record  of the specified  type, from the  <record length> words  of data
      beginning at <addr>+1, and skip-return.

      Currently, Jacct (JL) license is required to write each of the four  writable record
      types (40-43).











                                              20-6


            July 3, 1980                             20                               Accounting


                                                _____ ____                                                 Table 20-7 
                                             ______ _____ _____                                             PUTSAR error codes


            code   condition

            0      system running without accounting
            1      insufficient license
            2      bad <record length> for the type
            3      bad <type>



                    ______ __________ ____            20.4    Stream Accounting Data

            The  monitor  writes  records  of  accounting  information  which  are  read  from a
            pseudo-device called  ACT by a  program called  CHKPNT and stored  by it  into daily
            accounting files.

            The monitor writes stream accounting records for certain significant events  such as
            the running of a program outside of a user's directory or the setting of  license by
            a process.   In addition, certain  privileged programs (such  as LOGINN,  LOGOUT and
            CHKPNT) can  request the  monitor to write  stream accounting  records by  using the
            PUTSAR UUO (CALLI -62,  pg. 20-6), and any program  can write a single  local stream
            accounting record (for purposes of tracking) once during its execution by  using the
            PUTLSA UUO (CALLI -63, pg. 20-6).


                                                _____ _____                                                Table 20-7b
                                       ______ __________ ______ _____                                       Stream Accounting Record Types


            type   description

            0      GET/RUN/R command, RUN/RUNSEG UUO
            1      EXIT UUO, ac field 0
            2      EXIT UUO, ac field nonzero
            3      SETNAM UUO
            4      START command
            5      REENTER command
            6      DDT command
            7      project code changed
            10     .XCSET XCHARG function executed
            11     system initialization
            12     date or time change during timesharing
            13     PUTLSA record
            14     SETLIC UUO
            15     SETE UUO
            16     license set by RUN UUO
            40     LOGINN record
            41     CHKPNT record
            42     LOGOUT record
            43     uptime record (written by CHKPNT when it comes up)
            400    CHKPNT restart (only words 0 and 1 present)
            401    error (inconsistent data from ACT) (only wds 0 and 1)
            402    dummy (used to pad to the end of a disk block)












                                                    20-7


      Accounting                               20                         YAMM edition 2.0


                                          _____ ____                                           Table 20-8 
                                ______ __________ ______ _______                                Stream Accounting Record Lengths


      type   length (octal words)

      0-6    10
      7      10
      10     36
      11     2
      12     6
      13     10
      14     10
      15     10
      16     3
      40     7
      41     41
      42     41
      43     3



                                          _____ _____                                          Table 20-8b
                              ______ ______ ____ ______ _____ ___                              Stream Record Std. Header words 0-4


      word   bits  contents

      0      0-8   type
             9-17  frame number
             18-28 terminal type info or 0
             29-35 length (including this word)
      1      lh    date in days since 1 Jan 1964 GMT
             rh    time in seconds since midnight GMT
      2            frame AUN
      3            high-order TRUs (except LOGINN record)
      4            low-order TRUs (except LOGINN record)



                                          _____ _____                                          Table 20-8c
                          ______ ______ _____ ___ ________ ____ ______                          Stream Record types 0-6 (GET/RUN etc) format


      word   contents 0-4 Standard Stream Header 5 SIXBIT program name 6 progran ppn
                   (frame FPN) 7 .GTSOK contents TYMCHG UUO (CALLI -56, pg. 20-5)



                                          _____ _____                                          Table 20-8d
                              ______ ____________ ______ _____ ___                              Change Project-Code Record words 5-7


      word   bit   contents
      5            chars 1-5 of new project code (ASCII)
      6            chars 6-10 of new project code
      7      0-13  chars 11-12 of new project code
             14-34 0
             35    project code verify bit









                                              20-8


            July 3, 1980                             20                               Accounting




                                                _____ _____                                                Table 20-8e
                                   ______ ______________ ______ _____ ___                                   System Initialization Record words 0-1


            word   contents

            0      standard header, but frame = 0
            1      same contents as word 0



                                                _____ ____                                                 Table 20-9 
                                        ____ ______ ______ _____ ___                                        Date Change Record words 0-5


            word   contents

            0-4    standard header; word 1 contains old date and time
            5      new date,,time



                                                _____ _____                                                Table 20-9b
                                  _____ ______ __________ ______ _____ ___                                  Local Stream Accounting Record words 5-7


            word   contents

            5      SIXBIT program name or PUTLSA argument
            6      program ppn (JBTFPN)
            7      .GTSOK contents (see TYMCHG UUO (CALLI -56, pg. 20-5))



                                                _____ _____                                                Table 20-9c
                                        ___________ ______ _____ ___                                        SETLIC/SETE Record words 5-7


            word   contents

            5      SIXBIT program name
            6      program ppn (frame FPN)
            7      license set



                                                _____ _____                                                Table 20-9d
                                    _______________ ___ ______ _____ ___                                    License-Setting RUN Record words 0-2


            word   contents

            0      standard header
            1      standard date,,time word
            2      license set











                                                    20-9


      Accounting                               20                         YAMM edition 2.0




                                          _____ _____                                          Table 20-9e
                                    ______ ______ _____ ___                                    LOGINN Record words 3-6


      word   contents

      3      chars 1-5 of project code given to LOGINN
      4      chars 6-10
      5      chars 11-12 (left-justified)
      6      32 bits of supervisor data for line



                                          _____ _____                                           Table 20-10 
                                    ______ ______ _____ ___                                    Uptime Record words 0-2


      word   contents

      0      standard header, but frame number = 0
      1      standard date,,time format
      2      jiffies since system loaded



                                          _____ ______                                          Table 20-10b
                                    _______ ______ _____ ___                                    Restart Record words 0-1


      word   contents

      0      standard header, but frame number = 0
      1      standard date,,time format



                                          _____ ______                                          Table 20-10c
                                 ______ _____ ______ _____ ___                                 Stream Error Record words 0-1


      word   contents

      0      standard header, but frame number = 0
      1      date,,time of last good record read






















                                             20-10


            July 3, 1980                             20                               Accounting


                                                _____ _____                                                 Table 20-11 
                                   ______ ___ ______ ______ ______ ______                                   LOGOUT and CHKPNT stream record format


            word     contents

            0 - 4    standard header Table 20-8b
            5        blocks of storage for the AUN logging out.  -1 if CHKPNT record or if other
                           frames remain logged-in under this AUN
            6        high-order kilo-core-microcycles
            7        low-order kilo-core microcycles
            10       lookups
            11       lookups*size
            12       size*(enters+renames)
            13       size*blocks read
            14       size*block written
            15       tymnet chars input
            16       tymnet chars output
            17       size*seconds elapsed
            20       seconds connected (excludes detached time)
            21       size*break chars
            22       blocks read
            23       blocks written
            24       supervisor login info low-order 32 bits
            25       enters+renames
            26       remote peripheral (RMT620) seconds (obsolete)
            27       remote peripheral chars input/output (obsolete)
            30       premium charge (contents of JBTSOK)
            31       port Block I/O elapsed seconds
            32       port Block I/O chars transferred
            33       hi-order microcycles
            34       low-order microcycles
            35       mapped pages + created pages
            36       pages put into working set
            37       hi-order size*(pages put in working set0
            40       low-order size*(pages put in working set)
































                                                   20-11


      Accounting                               20                         YAMM edition 2.0


                                          _____ _____                                           Table 20-12 
                                  ______ ______ ______ ______                                  XCHARG stream record format


          The values in words 10 (octal) thru 35 of XCHARG records are differences between
                        values which were current at the moment XCHARG was executing, and
                        values supplied by the user or previously saved.  In effect, these
                        amounts were "given away".

          word   contents

          0-4    standard stream header 5 SIXBIT program name 6 progran ppn (frame FPN) 7
                                            .GTKM2 Table 20-4 11 .GTKM1 12 .GTMC2 13                                                                                          .GTSOK contents 10
                                   .GTELP 15 .GTBCS 16 .GTCIN 17 .GTCOT 20 .GTBET 21                                                                                     .GTMC1 14
                                   .GTSRN 23 .GTSLK 24 .GTSIN 25 .GTSOT 26 .GTERN 27                                                                                     .GTBIO 22
                                   .GTRCT 31 .GTWCT 32 .GTMPC 33 .GTPWS 34 hi-order                                                                                     .GTDLK 30
                        .GTPWS*size 35 low-order .GTPWS*size
          see also Table 18-4


















































                                             20-12


            July 3, 1980                             A                                UUOSYM.MAC



                                                 __________                                                 UUOSYM.MAC



            title      UUOSYM
            
            
            OPDEF INIT   [041B8]        ;Open a Channel
            OPDEF AUXCAL [042B8]        ;perform port i/o functions
                .AXI8C== 0    ;input char [wait/bka/img]
                .AXI8S== 1    ;input char [skip/bka/img]
                .AXI8B== 2    ;input char [wait/img]
                .AXO8==  3    ;output char [IMG]
                .AXO8I== 4    ;output char [IMG/IMM]
                .AXPTR== 5    ;output string [PTR]
                .AXCBI== 6    ;clear input buffer
                .AXCBO== 7    ;clear output buffer
                .AXSIC== 10   ;skip if char
                .AXLDE== 11   ;leave deferred echo mode
                .AXSYB== 12   ;send yellow ball
                .AXS8B== 13   ;set image break char
                .AXCRD== 14   ;r/s compute-CR-delay bit
                .AXIBR== 15   ;r/s input baud rate
                .AXOBR== 16   ;r/s output baud rate
                .AXEP==  17   ;r/s even-parity bit
                .AXHD==  20   ;r/s half-duplex bit
                .AXPA==  21   ;r/s parameter A
                .AXPB==  22   ;r/s parameter B
                .AXPC==  23   ;r/s parameter C
                .AXHNX== 24   ;r/s host-no-XON bit
                .AXNTE== 25   ;r/s no HT/VT/FF bit
                .AXTBK== 26   ;r/s tabs-as-breaks bit
                .AXWID== 27   ;r/s line width
                .AXFC1== 30   ;r/s filler class 1
                .AXFC2== 31   ;r/s filler class 2
                .AXSFS== 32   ;set port file status bits (obsolescent)
                .AXSI==  33   ;simulate input
                .AXEBM== 34   ;enter block i/o mode
                .AXIBW== 35   ;input block and wait
                .AXIBS== 36   ;input block and skip
                .AXOB==  37   ;block output
                .AXTBI== 40   ;terminate block input
                .AXTBO== 41   ;terminate block output
                .AXLBM== 42   ;leave block i/o mode
                .AXSLV== 43   ;slave command port
                .AXICW== 44   ;input char [wait/bka]
                .AXICS== 45   ;input char [skip/bka]
                .AXIWL== 46   ;input char [wait]
                .AXISL== 47   ;input char [skip]
                .AXSIL== 50   ;skip if break char
                .AXOCI== 51   ;output char [IMM]
                .AXOST== 52   ;output string [STR]
                .AXRMX== 53   ;r/s remote-XON bit
                .AXRBS== 54   ;r/s remote-BS-echo bit
                .AXRVX== 55   ;r/s reverse-XON bit
                .AXTYP== 56   ;r/s terminal type
                .AXBS==  57   ;r/s BS-for-char-delete bit
                .AXHNG== 60   ;send hangup
                .AXPSM== 61   ;read port-status msg
                .AXERA== 62   ;r/s Erase-for-char-delete bit
                .AXEDE== 63   ;r/s force deferred-echo bit
                .AXCFS== 64   ;change port file status bits
                .AXLCO== 65   ;r/s Lower-case-output bit
                .AXBBP== 66   ;r/s backspace break/punctuation bit
                .AXOPC== 67   ;output string [PTR+count]
                .AXSOB== 70   ;send orange ball
            OPDEF CHANIO [043B8]        ;do channel i/o functions
                                                    A-1


      UUOSYM.MAC                               A                          YAMM edition 2.0


          .CHREL== 0    ;release device
          .CHCLS== 1    ;close a file
          .CHOPT== 2    ;output from channel
          .CHIPT== 3    ;input from channel
          .CHLK==  4    ;select file for input
          .CHENT== 5    ;select file for output
          .CHUSI== 6    ;set file pointer by block
          .CHUSO== 7    ;set file position by block
          .CHUGF== 10   ;read disk file position
          .CHREN== 11   ;rename or delete a file
          .CHMTA== 12   ;perform magtape functions
          .CHOPN== 13   ;Open a Channel
          .CHIN==  14   ;input from channel
          .CHOUT== 15   ;output from channel
          .CHSS==  16   ;set file status bits
          .CHGS==  17   ;read file status bits
          .CHSZ==  20   ;skip if file status bits clear
          .CHSO==  21   ;skip if file status bits set
          .CHIBF== 22   ;create input buffer ring
          .CHOBF== 23   ;create output buffer ring
          .CHSK==  24   ;seek to current page
          .CHWT==  25   ;wait until device inactive
          .CHMBF== 26   ;move buffers
          .CHFSI== 27   ;set file pointer by block
          .CHFSO== 30   ;set file position by block
          .CHPSI== 31   ;set file pointer by page
          .CHPSO== 32   ;set file position by page
          .CHUFD== 33   ;read UFD
          .CHMGN== 34   ;manipulate update-interlock bit
          .CHMFP== 35   ;map file pages
          .CHDFP== 36   ;delete file page
          .CHXFP== 37   ;exchange file pages
          .CHCFP== 40   ;create file page
          .CHMEN== 41   ;select file for multi-update output
          .CHVRB== 42   ;validate RIB
          .CHSMP== 43   ;super-map file pages
          .CHFFI== 44   ;Find First Interesting Page
          .CHFTR== 45   ;Truncate File
      OPDEF FRMOP  [044B8]        ;Frame Operation
          .FOJMP== 0    ;gate jump to frame
          .FOCFM== 1    ;create frame
          .FORVA== 2    ;read frame virtual address
          .FOWVA== 3    ;write frame virtual address
          .FOSAA== 4    ;start frame at absolute address
          .FOHLT== 5    ;halt frame
          .FORPC== 6    ;Read Frame PC
          .FOREP== 7    ;VREPLC to/from another frame
          .FOVRM== 10   ;VREMOV in another frame
          .FOVCL== 11   ;VCLEAR in another frame
          .FOCFH== 12   ;Create Handle
          .FODFH== 13   ;Destroy Handle
          .FOCLR== 14   ;Clear a Frame
          .FORSI== 15   ;Read Standard Access Rights Info
          .FORAR== 16   ;Read Handle Access Rights
          .FORER== 17   ;Read Handle Effective Rights
          .FOSMF== 20   ;Set Max Frame Rights
          .FOCHR== 21   ;Change Handle Rights
          .FOSVA== 22   ;start frame at vector address
          .FOHST== 23   ;Read Halt Status Block
          .FOGFT== 24   ;Graft Frame Subtree
          .FOCON== 25   ;continue frame
          .FOGIN== 26   ;Gate-jump Initialization
          .FOVCH== 27   ;Validate Child Rights
          .FOCAR== 30   ;Read Child Access Rights
          .FOCER== 31   ;Read Child Effective Rights
          .FOGET== 32   ;Setup frame core image from file
          .FORUN== 33   ;RUN program in frame
          .FOSAV== 34   ;SAVE frame core image on file
                                              A-2


            July 3, 1980                             A                                UUOSYM.MAC


                .FOSSA== 35   ;SAVE frame core image on SHR file
            OPDEF SETSTV [47B8 -137]    ;set start vector address
            OPDEF VPEEK  [47B8 -136]    ;Virtual/Physical PEEK
            OPDEF RETACH [47B8 -135]    ;move port from frame to frame
            OPDEF EVICT  [47B8 -134]    ;Cause Notice to Quit Interrupt
            OPDEF PGRSTS [47B8 -133]    ;read/clear REFBIT fault info
            OPDEF PGISTS [47B8 -132]    ;read/clear ill mem ref fault info
            OPDEF SETABK [47B8 -131]    ;Set/Clear Address Break
            OPDEF LOGOFF [47B8 -130]    ;Run Alternate Logout Program
            OPDEF SETALP [47B8 -127]    ;Set Alternate Logout Program
            OPDEF SETOTF [47B8 -126]    ;set other-frame FD
            OPDEF CONT   [47B8 -125]    ;Put port in user level
            OPDEF PUTROY [47B8 -124]    ;Put Royalty Record in Stream
            OPDEF BLTPAG [47B8 -123]    ;change data in page uninterruptibly
            OPDEF PIDSET [47B8 -122]    ;Manipulate Process' PID
            ;     GETPFW [47B8 -121]    ;(obsolete)
            OPDEF BITPOK [47B8 -120]    ;read/modify/write in monitor memory
            OPDEF RDHIST [47B8 -117]    ;(not available)
            OPDEF SNOOP  [47B8 -116]    ;(not available)
            OPDEF POLPRT [47B8 -115]    ;Poll Ports for Events
            OPDEF CLBADD [47B8 -114]    ;Join Club
            OPDEF CLBLEV [47B8 -113]    ;Leave a Club
            OPDEF CLBINW [47B8 -112]    ;Get Interlock,wait
            OPDEF CLBINI [47B8 -111]    ;Get Interlock,No Wait
            OPDEF CLBRLI [47B8 -110]    ;Release Club Interlock
            OPDEF CLBMEM [47B8 -107]    ;Read Club Member List
            OPDEF CLBSTS [47B8 -106]    ;Read Status of Club Member
            OPDEF CLBWAK [47B8 -105]    ;Wake Up Club Member
            OPDEF CLBHNG [47B8 -104]    ;Hang Club Member
            OPDEF VPGFIL [47B8 -103]    ;get mapped-file name for page
            OPDEF VDSKPT [47B8 -102]    ;read disk pointer
            OPDEF PGFSTS [47B8 -101]    ;read and clear page fault words
            OPDEF PGESTS [47B8 -100]    ;read/clear page-error status words
            OPDEF VFSTAT [47B8 -77]     ;check private/file page
            OPDEF VALPAG [47B8 -76]     ;validate pages
            OPDEF PREREF [47B8 -75]     ;prereference a page
            OPDEF WSCTL  [47B8 -74]     ;do working set functions
                .WSRBM== 0    ;read working set bits
                .WSRNG== 1    ;add/remove pages from working set
                .WSSTL== 2    ;set WSLIM
                .WSRSZ== 3    ;read WSSIZ
                .WSRLM== 4    ;read WSLIM
                .WSRMX== 5    ;read WSMAX
            OPDEF REFBIT [47B8 -73]     ;manipulate reference bits
                .RFRBM== 0    ;Read refbits
                .RFSBM== 1    ;Set refbits from bitmap
                .RFRNG== 2    ;set refbits by range
            OPDEF PERSET [47B8 -72]     ;set/clear error bit
            OPDEF PAGSTS [47B8 -71]     ;read page status word
            OPDEF VPROT  [47B8 -70]     ;set current protection for pages
            OPDEF VCREAT [47B8 -67]     ;create private pages
            OPDEF VCLEAR [47B8 -66]     ;unmap pages
            OPDEF VREMOV [47B8 -65]     ;unmap pages
            OPDEF VREPLC [47B8 -64]     ;replicate virtual pages
            OPDEF PUTLSA [47B8 -63]     ;write local stream acctg record
            OPDEF PUTSAR [47B8 -62]     ;write stream acctg record
            OPDEF CHPRJ  [47B8 -61]     ;change project code
            OPDEF XCHARG [47B8 -60]     ;modify charges
                .XCSAV== 0    ;save charging data
                .XCRSC== 1    ;read saved charges
                .XCRCC== 2    ;read current charges
                .XCSET== 4    ;set charges
                .XCTRN== 5    ;write transaction charges
                .XCTCC== 6    ;Write TRU Component Checkpoint
            OPDEF SETRCF [47B8 -57]     ;set restricted cmnd file
            OPDEF TYMCHG [47B8 -56]     ;add TRU charges
            OPDEF DATUUO [47B8 -55]     ;do time zone conversions
            ;     DDT620 [47B8 -54]     ;(obsolete) interrogate 620
                                                    A-3


      UUOSYM.MAC                               A                          YAMM edition 2.0


      ;     VALRMT [47B8 -53]     ;(obsolete) validate 620 password
      ;     INTRMT [47B8 -52]     ;(obsolete) assign I/O software interrupts
      ;     IDLRMT [47B8 -51]     ;(obsolete) set 620 idle
      ;     ZAPRMT [47B8 -50]     ;(obsolete) zap 620 port
      ;     CRERMT [47B8 -47]     ;(obsolete) create 620 port
      OPDEF AUXRED [47B8 -46]     ;read aux circuit port numbers
      OPDEF ZAPCIR [47B8 -45]     ;zap an aux circuit
      OPDEF CREAUX [47B8 -44]     ;create an aux circuit
      OPDEF REDPIP [47B8 -43]     ;read in-progress bits
      OPDEF TINASS [47B8 -42]     ;assign port interrupt causes
      OPDEF SETTR2 [47B8 -41]     ;set stack over/underflow instruction
      OPDEF SETTR1 [47B8 -40]     ;set arithmetic overflow instruction
      OPDEF SETTIM [47B8 -37]     ;set timer interrupt
      OPDEF INTASS [47B8 -36]     ;assign general interrupt causes
      OPDEF INTACT [47B8 -35]     ;cause and uncause interrupts
      OPDEF INTENB [47B8 -34]     ;enable and disable INTADR channels
      OPDEF INTADR [47B8 -33]     ;initialize INTADR system
      OPDEF HANG   [47B8 -32]     ;hang a port or frame or frames
      OPDEF CHKLIC [47B8 -31]     ;check settable license
      OPDEF LEVDEF [47B8 -30]     ;leave deferred echo mode
      OPDEF MOVBUF [47B8 -27]     ;move buffers
      OPDEF SETMOD [47B8 -26]     ;set cmnd port file status
      OPDEF RUNSEG [47B8 -25]     ;load and run a high segment
      OPDEF SYSDVF [47B8 -24]     ;read system device data
      OPDEF DISMIS [47B8 -23]     ;dismiss INTADR interrupts
      OPDEF DSKCLR [47B8 -22]     ;initialize in-core file system data
      OPDEF SETJAL [47B8 -21]     ;set frame status bits
      OPDEF ONEJOB [47B8 -20]     ;skip if only frame and super-shut
      OPDEF SETMAL [47B8 -17]     ;set mail-waiting bit
      OPDEF GETTMC [47B8 -16]     ;(obs.) get terminal characteristics
      ;     SETTMC [47B8 -15]     ;(obsolete) no-op
      OPDEF REDNXT [47B8 -14]     ;peek at input
      OPDEF WAITCH [47B8 -13]     ;wait for input char
      OPDEF POKE   [47B8 -12]     ;write in monitor core
      OPDEF SETPRV [47B8 -11]     ;set frame privilege word
      OPDEF SETLIC [47B8 -10]     ;set process license
      OPDEF SETE   [47B8 -7]      ;set frame license
      OPDEF ATTACH [47B8 -6]      ;attach command port to frame
      ;     CALIM5 [47B8 -5]      ;(obsolete)
      ;     CALIM4 [47B8 -4]      ;(obsolete)
      ;     CALIM3 [47B8 -3]      ;(obsolete)
      ;     CALIM2 [47B8 -2]      ;(obsolete)
      OPDEF LIGHTS [47B8 -1]      ;display word in console lights
      OPDEF RESET  [47B8 +0]      ;initialize frame state
      OPDEF DDTIN  [47B8 +1]      ;DDT-mode input
      OPDEF SETDDT [47B8 +2]      ;set DDT start address
      OPDEF DDTOUT [47B8 +3]      ;DDT-mode output
      OPDEF DEVCHR [47B8 +4]      ;read device characteristics word
      ;     DDTGT  [47B8 +5]      ;(obsolete) Get DDT mode
      OPDEF GETCHR [47B8 +6]      ;read device characteristics word
      ;     DDTRL  [47B8 +7]      ;(obsolete) Release DDT mode
      OPDEF WAIT   [47B8 +10]     ;wait until device inactive
      OPDEF CORE   [47B8 +11]     ;allocate or free core
      OPDEF EXIT   [47B8 +12]     ;stop frame execution
      ;     UTPCLR [47B8 +13]     ;(obsolete)
      OPDEF DATE   [47B8 +14]     ;read date
      OPDEF LOGIN  [47B8 +15]     ;log a frame in
      OPDEF APRENB [47B8 +16]     ;enable APRENB trapping
      OPDEF LOGOUT [47B8 +17]     ;log a frame out
      OPDEF SWITCH [47B8 +20]     ;read console switches
      OPDEF REASSI [47B8 +21]     ;reassign i/o device
      OPDEF TIMER  [47B8 +22]     ;read time in jiffies
      OPDEF MSTIME [47B8 +23]     ;read time in ms
      OPDEF GETPPN [47B8 +24]     ;get frame PPN
      OPDEF TRPSET [47B8 +25]     ;Set/Clear User-IOT
      ;     TRPJEN [47B8 +26]     ;(obsolete)
      OPDEF RUNTIM [47B8 +27]     ;get TRUs
      OPDEF PJOB   [47B8 +30]     ;get frame number
                                              A-4


            July 3, 1980                             A                                UUOSYM.MAC


            OPDEF SLEEP  [47B8 +31]     ;wait for N seconds
            ;     SETPOV [47B8 +32]     ;(obsolete) Set PDL OV trap
            ;     PEEK   [47B8 +33]     ;(obsolete) read monitor core
            OPDEF GETLIN [47B8 +34]     ;get command port name
            OPDEF RUN    [47B8 +35]     ;load and run a program
            OPDEF SETUWP [47B8 +36]     ;set highseg write protection
            OPDEF REMAP  [47B8 +37]     ;move top of lowseg to highseg
            OPDEF GETSEG [47B8 +40]     ;load a high segment
            OPDEF GETTAB [47B8 +41]     ;read monitor tables
            ;     SPYUUO [47B8 +42]     ;(obsolete)
            OPDEF SETNAM [47B8 +43]     ;set frame name
            OPDEF TMPCOR [47B8 +44]     ;do TMPCOR file i/o
                .TCRFS== 0    ;get free space count
                .TCRRF== 1    ;read TMPCOR file
                .TCRDF== 2    ;delete TMPCOR file
                .TCRWF== 3    ;write TMPCOR file
                .TCRRD== 4    ;read TMPCOR directory
                .TCRDD== 5    ;clear TMPCOR directory
            OPDEF DSKCHR [47B8 +45]     ;read disk characteristics
            OPDEF SYSSTR [47B8 +46]     ;read disk structure names
            OPDEF JOBSTR [47B8 +47]     ;Return frames next file structure
            OPDEF STRUUO [47B8 +50]     ;Manipulate file structures
            OPDEF SYSPHY [47B8 +51]     ;read physical unit names
            OPDEF DEVSTS [47B8 +54]     ;read device hardware status
            OPDEF DEVPPN [47B8 +55]     ;read PPN
            OPDEF SEEK   [47B8 +56]     ;seek to current page
            OPDEF DEVNAM [47B8 +64]     ;read device physical name
            OPDEF GOBSTR [47B8 +66]     ;Get system search list
            OPDEF HIBER  [47B8 +72]     ;wait for event
            OPDEF WAKE   [47B8 +73]     ;wake sleeping frame
            OPDEF CHGPPN [47B8 +74]     ;change frame PPN
            OPDEF SETUUO [47B8 +75]     ;do SET command functions
                .STTYO== 0    ;OUTSTR to OPR terminal
                .STSTA== 1    ;set STATES
                .STFAR== 2    ;finish auto-restart
                .STTIM== 3    ;set time
                .STDAT== 4    ;set date
                .STWAT== 6    ;set WATCH bits
                .STBST== 11   ;Set/Read BOOTS command string
                .STRES== 12   ;Read/Set RESTART bits
            OPDEF DEVSIZ [47B8 +101]    ;read standard buffer size
            OPDEF OPEN   [050B8]        ;Open a Channel
            OPDEF TTCALL [051B8]        ;perform cmnd port i/o
            OPDEF INCHRW [51B8 0,]      ;input char [wait/bka]
            OPDEF OUTCHR [51B8 1,]      ;output char [CMD]
            OPDEF INCHRS [51B8 2,]      ;input char [skip/bka]
            OPDEF OUTSTR [51B8 3,]      ;output string [STR/CMD]
            OPDEF INCHWL [51B8 4,]      ;input char [wait]
            OPDEF INCHSL [51B8 5,]      ;input char [skip]
            OPDEF GETLCH [51B8 6,]      ;read line characteristics
            OPDEF SETLCH [51B8 7,]      ;set line characteristics
            OPDEF RESCAN [51B8 10,]     ;rescan command line
            OPDEF CLRBFI [51B8 11,]     ;clear input buffer
            OPDEF CLRBFO [51B8 12,]     ;clear output buffer
            OPDEF SKPINC [51B8 13,]     ;skip if char
            OPDEF SKPINL [51B8 14,]     ;skip if break char
            OPDEF IONEOU [51B8 15,]     ;output char [CMD/IMG]
            OPDEF OUTCHI [51B8 16,]     ;output char [CMD/IMM]
            OPDEF OUTPTR [51B8 17,]     ;output string [PTR/CMD]
            OPDEF RENAME [055B8]        ;rename or delete a file
            OPDEF IN     [056B8]        ;input from channel
            OPDEF OUT    [057B8]        ;output from channel
            OPDEF SETSTS [060B8]        ;set file status bits
            OPDEF STATO  [061B8]        ;skip if file status bits set
            OPDEF GETSTS [062B8]        ;read file status bits
            OPDEF STATZ  [063B8]        ;skip if file status bits clear
            OPDEF INBUF  [064B8]        ;create input buffer ring
            OPDEF OUTBUF [065B8]        ;create output buffer ring
                                                    A-5


      UUOSYM.MAC                               A                          YAMM edition 2.0


      OPDEF INPUT  [066B8]        ;input from channel
      OPDEF OUTPUT [067B8]        ;output from channel
      OPDEF CLOSE  [070B8]        ;close a file
      OPDEF RELEAS [071B8]        ;release device
      OPDEF MTAPE  [072B8]        ;perform magtape functions
      OPDEF UGETF  [073B8]        ;read disk file position
      OPDEF USETI  [074B8]        ;set file position by block
      OPDEF USETO  [075B8]        ;set file position by block
      OPDEF LOOKUP [076B8]        ;select file for input
      OPDEF ENTER  [077B8]        ;select file for output
      
      
      subttl Frame Privilege (JBTPRV) Bits
      
          JP.1UU==1b0   ;unused
          JP.NAT==1B1   ;* no attach at login
          JP.DST==1B2   ;* daylight savings applies
          JP.ZON==37B7  ;* applicable time zone
          JP.2UU==77B10 ;unused
          JP.COR==177B17;* max core for frame
          JP.EXO==1B18  ;execute only program
          JP.DOP==3B20  ;* disconnect options
          .JPLOG==0     ;Logout on disconnect
          .JPDET==1     ;Detach on disconnect
          .JPCON==2     ;Continue on disconnect
          .JPDTO==3     ;Detach (15 min timeout)
          JP.TYM==1B21  ;Tymshare proprietary
          JP.ASV==1B22  ;Account supervisor
          JP.MAL==1B23  ;Mail-waiting
          JP.XOG==1B24  ;Execute only get
          JP.3UU==1B25  ;unused
          JP.RCM==1B26  ;* Restricted command mode.
          JP.MOD==3B28  ;* monitor mode
          .JPMPD==0     ;PDP-10 mode
          .JPMXE==1     ;XEXEC mode
          .JPMXJ==2     ;XEXECJ (Japan)  mode
          .JPMSU==3     ;SUDS mode
          JP.CRM==177B35;Maximum value for JP.COR
      
      
      subttl Frame License Bits
      
          LC.WC== 1B0   ;Write Core (POKE UUO)
          LC.RC== 1B1   ;Read Core (VPEEK UUO)
          LC.OP== 1B2   ;Operator (SETUUO UUO)
          LC.SY== 1B3   ;SYSTAT (read protected GETTAB tables)
          LC.GD== 1B4   ;Get Devices
          LC.TD== 1B5   ;Transfer Devices (REASSI UUO)
          LC.ST== 1B6   ;Manipulate Structures
          LC.HF== 1B7   ;Home Files
          LC.JL== 1B8   ;Priviledged System Program
          LC.AC== 1B9   ;Auxiliary Circuits
          LC.XC== 1B10  ;XCHARG (adjust charges using the XCHARG UUO)
          LC.RPS==3B15  ;read priviledges (a field)
          .LCRP== 1     ;read project
          .LCRF== 2     ;read files
          .LCRA== 3     ;read absolute
          LC.WPS==3B17  ;write priviledges (a field)
          .LCWP== 1     ;write project
          .LCWF== 2     ;write files
          .LCWA== 3     ;write absolute
      
      
      subttl Frame Status Bits
      
          JB.RUN==1B0   ;Frame is runnable
          JB.CMW==1B1   ;Waiting to execute command
          JB.MRQ==1B2   ;Waiting for page(s)
                                              A-6


            July 3, 1980                             A                                UUOSYM.MAC


                JB.JNA==1B3   ;Frame number assigned
                JB.JER==1B4   ;Monitor detected error
                JB.ESC==1B9   ;Escape seen in command mode
                JB.WSC==37B14 ;Wait state code
                JB.LOG==1B15  ;* Frame is logged in
                JB.JRQ==1B16  ;Frame must be requeued
                JB.JAC==1B17  ;Frame can't be stopped
                JB.WAK==1B19  ;WAKE pending
                JB.JA2==1B20  ;* Frame shouldn't be stopped.
                JB.UTR==1B21  ;Trap to user on UUO exit.
                JB.DCN==1B22  ;Waiting for oper action.
                JB.PRF==1B24  ;Frame Prereferenced a page.
                JB.SIP==1B25  ;Swap-in in progress.
                JB.SCP==1B26  ;Swapper has taken pages.
            
            
            subttl Watch Bit Definitions
            
                ST.WDY==1B19  ;time-of-day
                ST.WRN==1B20  ;run time (TRUs)
                ST.WWT==1B21  ;wait time
                ST.WDR==1B22  ;disk reads (blocks)
                ST.WDW==1B23  ;disk writes (blocks)
            
            
            subttl Frame Descriptor Format
            
                FD.ABS==0B20  ;absolute type FD
                FD.FAM==1B20  ;family type FD
                FM.CHL==0B23  ;child subtype
                FM.PAR==1B23  ;parent subtype
                FD.OTF==2B20  ;"other" frame
                FD.CRH==3B20  ;created handle type FD
                CH.FRM==0B23  ;frame handle subtype
                CH.PRO==1B23  ;process handle subtype
                CH.LIC==2B23  ;license handle subtype
                FD.SLF==7B20  ;self
            
            
            subttl Map Manipulation Rights
            
                .ARRDM==0     ;Read Map
                .ARCHM==1     ;Change Map
            
            
            subttl Virtual Memory Data Manipulation Rights
            
                .ARRAC==2     ;Read ACs
                .ARWAC==3     ;Write ACs
                .ARVAR==4     ;Read VM data
                .ARVAW==5     ;Write VM data
            
            
            subttl Frame Control Rights
            
                .ARHLT==6     ;Halt frame
                .ARSTP==7     ;Stop frame
                .ARHNG==10    ;Hang frame
                .ARCLR==11    ;Clear frame and release devices
                .ARSVA==12    ;Start at Vector Address
                .ARSAA==13    ;Start at Arbitrary Address
                .ARRVA==14    ;Restart at Vector Address
                .ARRAA==15    ;Restart at Arbitrary Address
            
            
            subttl Read Frame Status Rights
            
                .ARRUN==16    ;Read User Name
                                                    A-7


      UUOSYM.MAC                               A                          YAMM edition 2.0


          .ARRDS==17    ;Read Frame State
          .ARRAD==20    ;Read Accounting Data
          .ARRFI==21    ;Read Frame Information
          .ARRPI==22    ;Read Process Info
      
      
      subttl Access Rights Control Rights
      
          .ARSMF==23    ;Set Max Frame Rights
      
      
      subttl Wakeup Rights
      
          .ARWAK==24    ;Do Wake UUO on frame
      
      
      subttl TTY Attaching and Detaching Rights
      
          .ARATT==25    ;Attach Port
          .ARDET==26    ;Take Port away (Detach)
      
      
      subttl Frame Tree Grafting Rights
      
          .ARTKP==27    ;Take parent away from frame
          .ARGVP==30    ;Give parent to frame
          .ARGVC==31    ;Give child to frame
      
      
      subttl FRMOP standard error codes
      
          FENOH%==1     ;no handle in slot
          FEBDI%==2     ;Bad (nonmatching) universal ID number
          FENRT%==3     ;no rights to do operation
          FEBDF%==4     ;bad frame number
          FENLC%==5     ;not enough license
          FEUND%==6     ;undefined frame descriptor type
          FENCH%==7     ;not a child
          FECLP%==10    ;cannot lock context pages
          FEBAR%==11    ;bad access rights code
          FENPR%==12    ;no parent
          FEBFD%==13    ;bad family dispatch type
          FEBDH%==14    ;bad handle index number in FD
          FEBFN%==15    ;bad FRMOP function code
          FEADB%==16    ;address bad
          FEIOE%==17    ;page I/O error
          FEALR%==20    ;already running
          FEALH%==21    ;already halted
          FECSJ%==22    ;cannot stop frame with JACCT set
          FEFHE%==23    ;handle descriptor expected, not given
          FEFHU%==24    ;handle (index) already used
          FENFH%==25    ;no frame handle indices left
          FEBCN%==26    ;bad count
          FEBTN%==27    ;bad table number
          FEBHT%==30    ;bad handle type
          FECCH%==31    ;can't create handle (access failure)
          FEBSV%==32    ;bad start vector offset
          FECII%==33    ;cannot make child its own inferior in frame tree
          FECCF%==34    ;cannot continue frame
          FECFJ%==35    ;cannot do frame jump
          FEREM%==36    ;rights exceed maximum
      
      
      subttl .FOCFM error codes
      
          CF.NRD==0     ;no disk room
          CF.FCE==1     ;frame capacity exceeded
          CF.BAL==2     ;bad arg no license
                                              A-8


            July 3, 1980                             A                                UUOSYM.MAC


                CF.DDB==3     ;cannot create command port DDB
            
            
            subttl System Start Vector Indicies
            
                SV.NSA==-1    ;normal start address (as found in .JBSA)
                SV.CCL==-2    ;CCL start address (normal plus one)
                SV.REN==-3    ;REENTER start address (as found in .JBREN)
                SV.DDT==-4    ;DDT start address (as found in .JBDDT)
                SV.CON==-5    ;CONTINUE start address
            
            
            subttl Halt Status Classes & Types
            
                HC.MEM==0     ;Memory Violations
                HT.PCO==0     ;PC Out of Bounds
                HT.IMR==1     ;Illegal Memory Reference
                HT.WRV==2     ;Write Violation
                HT.ADC==3     ;Address Check for Device X
                HT.IMU==4     ;Ill Mem Ref in UUO
                HT.IIA==5     ;Illegal Interrupt Address
                HT.ABK==6     ;Address Break
                HT.POV==7     ;PDL Overflow
                HC.SYS==1     ;System-Related Errors
                HT.PIO==0     ;Page I/O Error
                HT.DFL==1     ;Disk Full during copy of .PRCW page
                HT.PHE==2     ;Paging Hardware Error
                HT.TPL==3     ;Too many Pages Locked, Cannot handle fault
                HT.CIO==4     ;Context Page I/O Error
                HT.PAR==5     ;Parity Error(s). All Core Removed
                HC.DEV==2     ;Device Related Errors
                HT.OCI==0     ;Output device Cannot Input
                HT.ICO==1     ;Input device Cannot Output
                HT.IDM==2     ;Illegal Data Mode for device X
                HT.IUC==3     ;I/O to Unassigned Channel
                HT.HDV==4     ;Hung Device
                HT.DOP==5     ;Device X OPR action requested
                HC.ILL==3     ;Illegal Instruction Traps
                HT.ILU==0     ;Illegal UUO
                HT.UUE==1     ;UUO error
                HT.ILI==2     ;Illegal Instruction
                HT.HLT==3     ;Halt
                HC.EXI==4     ;Frame Exits
                HT.EXI==0     ;Exit
                HT.EX1==1     ;Exit 1,
                HT.FEX==2     ;Fail Exit
                HT.TLE==3     ;Time Limit Exceeded
                HT.JSU==4     ;filename setup
                HT.JSV==5     ;filename saved
                HT.FCL==6     ;frame cleared
                HC.RUN==5     ;RUN,RUNSEG & GETSEG UUO errors
                HT.TRE==0     ;Transmission Error
                HT.PGN==1     ;N Pages Required
                HT.DNA==2     ;Device Not Available
                HT.FNF==3     ;filename.ext not found
                HT.NSF==4     ;Not a Save File
                HT.EUF==5     ;filename.ext Attempted Enter UUO Failed
                HT.CAN==6     ;Core Argument Not specified (magtape only)
                HT.MHB==7     ;Magtape Hiseg Format Bad
                HT.RMF==10    ;Remap UUO Fatal error
                HT.MGF==11    ;Magtape GET failure
                HT.NSA==12    ;No Start Address
            
            
            subttl .FORSI Item Numbers
            
                .SREXO==0     ;max frame rights for execute-only
                .SRLIC==1     ;max frame rights for process with license
                                                    A-9


      UUOSYM.MAC                               A                          YAMM edition 2.0


          .SRALL==2     ;all rights defined by monitor
          .SRRCL==3     ;AR conferred by Read Core (RC)
          .SRSYL==4     ;AR comferred by Systat (SY)
          .SRTYM==5     ;AR conferred by JP.TYM priviledge
          .SRAUN==6     ;AR conferred by having same AUN
          .SRJLL==7     ;AR conferred by Jacct (JL)
          .SRWCL==10    ;AR conferred by Write Core (WC)
      
      
      subttl Job Data Area Locations
      
          .JBUUO==40    ;LUUO storage location
          .JB41== 41    ;LUUO instruction location
          .JBREL==44    ;(Obsolescent) highest relative loc
          .JBBLT==45    ;Loader BLT locations 45-47
          .JBMUU==66    ;MUUO stored here on INTADR MUUO-trapping
          .JBHCU==72    ;Highest-channel-used stored here
          .JBDDT==74    ;DDT entry loc
          .JBJDA==75    ;Begin Array of channel-in-use flags
          .JBCNK==102   ;CHAIN temporary locs 102-110
          .JBCN6==106   ;more CHAIN temporary locs 106-113
          .JBPFI==114   ;(Obsolete) lower limit for I/O
          .JBHRL==115   ;(Obsolescent) Hiseg length and ending loc
          .JBSYM==116   ;Symbol-table pointer stored here
          .JBUSY==117   ;Undefined-symbols table pointer
          .JBSA== 120   ;Start Address of loaded program
          .JBFF== 121   ;First Free loc for buffered I/O to use
          .JBREN==124   ;REENTER command address stored here
          .JBAPR==125   ;APRENB transfer address stored here
          .JBCNI==126   ;APRENB simulated CONI word location
          .JBTPC==127   ;APRENB trap PC loc
          .JBOPC==130   ;Old PC loc set by DDT,START etc.
          .JBCHN==131   ;loaded FORTRAN program information
          .JBCOR==133   ;loc of last non-zero data in core image
          .JBCST==136   ;For Customer Use
          .JBVER==137   ;Version number
          .JBDA== 140   ;First loc available to user program
      
      
      subttl Vestigial Job Data Area Locations
      
          .JBHSA==0     ;copy of .JBSA
          .JBH41==1     ;copy of .JB41
          .JBHCR==2     ;copy of .JBCOR
          .JBHRN==3     ;.JBHRL,.JBREN restore word
          .JBHNM==5     ;hiseg name
          .JBHSM==6     ;pointer to hiseg symbol-table
          .JBHGA==7     ;(Obsolete)
          .JBHDA==10    ;first loc of hiseg available to user
      
      
      subttl Page Protection Codes
      
          .PRRO== 1B7   ;read-only
          .PRCW== 2B7   ;Copy-on-Write
          .PRRW== 3B7   ;Read-Write
      
      
      subttl VCREAT Error Codes
      
          CRBCN%==0     ;count = 0
          CRBVP%==1     ;bad page number
          CRBPR%==2     ;bad protection
          CREXV%==3     ;page already exists
          CRLIM%==5     ;exceeded existing page limit
          CRDFL%==6     ;disk full
      
      
                                              A-10


            July 3, 1980                             A                                UUOSYM.MAC


            subttl VPROT Error Codes
            
                PTBCN%==0     ;count = 0
                PTBVP%==1     ;bad page
                PTBPR%==2     ;bad protection
                PTNVP%==4     ;page does not exist
                PTPRF%==5     ;protection failure (only lookup access
            
            
            subttl WSCTL Error Codes
            
                WSBCN%==0     ;count = 0
                WSBVP%==1     ;bad virtual page
            ;   ==      2     ;(unused)
            ;   ==      3     ;(unused)
                WSNVP%==4     ;virtual page does not exist
                WSBFN%==5     ;illegal function code
                WSCTL%==6     ;count too large
                WSEWL%==7     ;exceeded working set size limit
                WSLGM%==10    ;attempt to set limit over  max
                WSLL3%==11    ;attempt to set limit under 3 pages
            
            
            subttl PREREF Error Codes
            
                PRBVP%==1     ;bad page
                PRNVP%==4     ;page does not exist
                PRNIW%==5     ;page not in working set
            
            
            subttl BLTPAG Error codes
            
                BUCBB%==0     ;can't BLT backwards
                BUNWP%==1     ;data not all within one page
                BUCLP%==2     ;can't lock dest. page
            
            
            subttl PERSET Error Codes
            
                PEBCN%==0     ;bad count
                PEBVP%==1     ;bad page
                PENVP%==4     ;nonexistent page
            
            
            subttl PGESTS Word
            
                EI.VAL==1B0   ;information is valid
                EI.PAR==1B14  ;parity error on dirty page
                EI.OER==1B15  ;output error
                EI.DER==1B16  ;device error
                EI.DTE==1B17  ;data error
            
            
            subttl VALPAG Error Codes
            
                VLBCN%==0     ;bad count
                VLBVP%==1     ;bad page
                VLNVP%==4     ;page does not exist
                VLIOE%==5     ;i/o error occurred
            
            
            subttl Page Fault Word
            
                FI.VAL==1B0   ;this word contains valid data
                FI.SAL==1B1   ;WSSIZ = WSLIM at time of fault
                FI.VPN==777B26;Virtual Page number
            
            
                                                    A-11


      UUOSYM.MAC                               A                          YAMM edition 2.0


      subttl PGISTS Word
      
          II.ADR==777777B17       ;virtual address
          II.PFW==777777B35       ;soft page fail word
      
      
      subttl PGRSTS Word
      
          RI.VAL==1B0   ;information is valid
          RI.ADR==777777B35       ;virtual address
      
      
      subttl REFBIT Error Codes
      
          RFBCN%==0     ;bad count
          RFBVP%==1     ;bad page number
          RFBFN%==5     ;bad function
      
      
      subttl Page Status Word
      
          PS.UWS==1B0   ;in user working set
          PS.REF==1B1   ;has been referenced
          PS.MXW==1B2   ;maximally-writable
          PS.SUP==1B3   ;super-mapped
          PS.DDE==3B5   ;swap device error has occurred
          PS.FIL==1B32  ;was a file-page (when mapped)
          PS.CPR==7B35  ;current protection
      ;   ==      1     ;read only
      ;   ==      2     ;copy-on-write
      ;   ==      3     ;read/write
      
      
      subttl PAGSTS Error Code
      
          PSBVP%==1     ;bad page
      
      
      subttl VPGFIL Error Codes
      
          PFBVP%==1     ;bad vp number
          PFNEX%==4     ;non-existent vp
          PFNFP%==6     ;not file page
      
      
      subttl Standard Paging error Codes
      
          FLCTG%==0     ;virtual page count = 0
          FLDVR%==1     ;Destination virtual page out of range
          FLCPU%==2     ;current prot undefined
          FLVEX%==4     ;virtual page exists
          FLNEX%==4     ;page doesn't exist
          FLSVR%==5     ;source VP out-of-range
          FLPHP%==6     ;past highest page
          FLFPZ%==7     ;a specified file page number is = 0
          FLCOR%==10    ;caller's .PVCOR size limit will be exceeded
          FLRBE%==11    ;RIB error
          FLBDS%==12    ;bad SAT
          FLCPL%==13    ;specified prot cannot be set for the VP
          FLLKC%==14    ;file is LOOKUP only, cannot be mapped
          FLHOL%==16    ;file page which must exist is a hole
          FLNHL%==16    ;no hole at specified file page
          FLSNM%==17    ;structure name bad
          FLOPE%==20    ;i/o error on validation write of page
          FLSAM%==21    ;same source and destination page numbers
          FLNML%==22    ;file already selected
          FLNOF%==23    ;no file selected
          FLNWT%==24    ;no write allowed
                                              A-12


            July 3, 1980                             A                                UUOSYM.MAC


                FLAQA%==25    ;disk full or user's quota exceeded
                FLCTL%==26    ;(not returned to user programs)
                FLIPE%==27    ;(not returned to user programs)
                FLNTF%==30    ;no page of desired kind found
                FLNIM%==31    ;function not implemented
                FLLGE%==32    ;suppress error logging not allowed
                FLNSP%==33    ;(obsolete)
            
            
            subttl file status bits
            
                IO.IMP==1B18  ;improper mode
                IO.DER==1B19  ;device error
                IO.DTE==1B20  ;data error
                IO.BKT==1B21  ;block too large
                IO.ERR==17B21 ;error bit mask
                IO.EOF==1B22  ;end of file
                IO.ACT==1B23  ;device is active
                IO.EVP==1B26  ;(FTA: only) even parity
                IO.BK2==1B26  ;(TTY: only) break-on-punctuation bit
                IO.NEE==1B27  ;(TTY: only) no-escape-echo bit
                IO.NEC==1B28  ;(TTY: only) no-echo bit
                IO.DEN==3B28  ;(FTA: only) recording density
                IO.FCS==1B29  ;(TTY: only) full-character-set bit
                IO.SYN==1B30  ;synchronous i/o
                IO.UWC==1B31  ;user supplied word count
                IO.MOD==77B35 ;data mode mask
            
            
            subttl Data modes
            
                .IOASC==0     ;ASCII
                .IOASL==1     ;ASCII line
                .IOKAT==2     ;Katakana
                .IOIMG==10    ;Image
                .IOIBN==13    ;Image Binary
                .IOBIN==14    ;Binary
                .IODPR==16    ;Dump Records
                .IODMP==17    ;Dump
            
            
            subttl Device characteristic word
            
                DV.DSK==1B1   ;is a disk
                DV.CDR==1B2   ;is a card reader
                DV.LPT==1B3   ;is a line printer
                DV.TTA==1B4   ;is a frame's command port
                DV.NZP==1B5   ;do not zap circuit on a RESET
                DV.1UU==1B6   ;unused
                DV.2UU==1B7   ;unused
                DV.3UU==1B8   ;unused
                DV.PTP==1B9   ;is a paper tape punch
                DV.PTR==1B10  ;is a paper tape reader
                DV.4UU==1B11  ;unused
                DV.AVL==1B12  ;is available to this frame
                DV.MTA==1B13  ;is a magtape
                DV.TTY==1B14  ;is a terminal or aux circuit
                DV.DIR==1B15  ;has a directory
                DV.IN== 1B16  ;input possible
                DV.OUT==1B17  ;output possible
                DV.ASG==1B18  ;assigned by console
                DV.ASP==1B19  ;assigned by program
                DV.DMP==1B20  ;dump mode legal
                DV.DPR==1B21  ;dump records mode legal
                DV.BIN==1B23  ;binary mode legal
                DV.IBN==1B24  ;image binary mode legal
                DV.IMG==1B27  ;image mode legal
                DV.KAT==1B33  ;katakana mode legal
                                                    A-13


      UUOSYM.MAC                               A                          YAMM edition 2.0


          DV.ASL==1B34  ;ascii line mode legal
          DV.ASC==1B35  ;ascii mode legal
      
      
      subttl SYSDVF Function Codes
      
          .SDDDN==0     ;Non-port/disk;
          .SDDDA==1     ;All;
          .SDUNI==2     ;Unit DDBs;
          .SDSTR==3     ;STR DDBs;
          .SDFTA==4     ;Mag Tape DDBs;
      
      
      subttl File protection codes
      
          FP.NO== 7     ;No access.
          FP.LK== 6     ;Lookup access.
          FP.RUN==5     ;Run access.
          FP.RD== 4     ;Read access.
          FP.AP== 3     ;Append access.
          FP.UPD==2     ;Update access.
          FP.CP== 1     ;Change-protection access.
          FP.ALL==0     ;All access.
      
      
      subttl Directory protection bits
      
          DP.LK== 4     ;Lookup access.
          DP.CR== 2     ;New files access.
          DP.RD== 1     ;Read access.
      
      
      subttl Extended Lookup Block Locations
      
          .RBPPN==1     ;PPN of UFD to search
          .RBNAM==2     ;SIXBIT /filename/
          .RBEXT==3     ;SIXBIT /extension/
          .RBPRV==4     ;Priviledge word
          .RBSIZ==5     ;File size in words
          .RBVER==6     ;Version (not used by monitor)
          .RBFUT==7     ;(not used by monitor)
          .RBEST==10    ;Estimated file size (in blocks)
          .RBALC==11    ;Allocated storage (in blocks)
          .RBPOS==12    ;(not used)
          .RBFT1==13    ;(not used)
          .RBLIC==14    ;File license word
          .RBMTA==15    ;(not used)
          .RBDEV==16    ;zero
          .RBSTS==17    ;File status bits
          .RBELB==20    ;Error logical block
          .RBXT1==21    ;zero
          .RBQTF==22    ;Logged-in disk quota
          .RBQTO==23    ;Logged-out disk quota
          .RBMXA==24    ;
          .RBUSD==25    ;
          .RBAUT==26    ;Author (last writer's) PPN
          .RBUNM==27    ;Username (SIXBIT)
          .RBTRU==31    ;unused
          .RBXT2==32    ;unused
          .RBALP==33    ;Allocated pages
          .RBSNM==34    ;number of spare RIBs
          .RBPJC==35    ;Project-code block
          .RBPID==40    ;Processor ID
      
      
      subttl file selection error codes
      
          .ERFNF==0     ;File Not Found.
                                              A-14


            July 3, 1980                             A                                UUOSYM.MAC


                .ERIPP==1     ;Incorrect PPN.
                .ERPRT==2     ;Protection failure.
                .ERFBM==3     ;File being modified.
                .ERAEF==4     ;Already existing file.
                .ERISU==5     ;Illegal Sequence of UUOs.
                .ERTRN==6     ;Transmission error.
                .ERNSF==7     ;Not a saved file.
                .ERNEC==10    ;Not enough core.
                .ERDNA==11    ;Device not available.
                .ERNSD==12    ;No such device.
                .ERILU==13    ;(never happens)
                .ERNRM==14    ;No room.
                .ERWLK==15    ;(never happens)
                .ERNET==16    ;Not enough table space.
                .ERPOA==17    ;(never happens)
                .ERBNF==20    ;(never happens)
                .ERNTR==21    ;(never happens)
                .ERLKM==22    ;(never happens)
            
            
            subttl DSKCHR status bits
            
                DC.OFL==1B1   ;unit offline
                DC.HWP==1B2   ;unit hardware write-protected
                DC.USF==1B6   ;unit unsafe
                DC.MSB==1B9   ;unit has multiple SAT blocks
                DC.TYP==7B17  ;type of name passed to DSKCHR
                .DCTDS==0     ;generic DSK
                .DCTFS==2     ;file structure
                .DCTUF==3     ;unit within structure
                .DCTCN==4     ;controller class
                .DCTCC==5     ;controller within class
                .DCTPU==6     ;unit within controller
                DC.DCN==7B20  ;data channel number
                DC.CNT==77B26 ;controller type
                .DCCDR==0     ;FH  drum
                .DCCFH==1     ;fixed-head disk
                .DCCDP==2     ;DP  disk pack (RP01,RP02)
                .DCCMD==3     ;mass disk
                .DCCBP==4     ;BP  big pack (IBM 3330)
                DC.CNN==7B29  ;controller number
                DC.UNT==3B31  ;unit type
                .DCUBU==0     ;Burroughs disk
                .DCBBR==1     ;Bryant drum
                .DCUD1==0     ;RP01
                .DCUD2==1     ;RP02
                .DCUDP==0     ;dual positioner
                .DCUSP==1     ;single positioner
                .DCUM1==0     ;3330 Model I
                .DCUM2==1     ;3330 Model II
                DC.UNN==7B35  ;unit number within controller
            
            
            subttl GOBSTR error codes
            
                DFGIF%==3     ;addr+2 is not in search list
                DFGPP%==6     ;frame and PPN do not agree
                DFGNP%==10    ;No license
                DFGLN%==12    ;Bad length for list
            
            
            subttl STRUUO function codes
            
                .FSSRC==0     ;Define new search list for frame
                .FSDSL==1     ;Define new search list
                .FSDEF==2     ;Define new file structure.
                .FSRDF==3     ;Redefine file structure.
                .FSLOK==4     ;Lock file structure.
                                                    A-15


      UUOSYM.MAC                               A                          YAMM edition 2.0


          .FSREM==5     ;Remove file structure.
          .FSULK==6     ;Test/Set UFD interlock.
          .FSUCL==7     ;Clear UFD interlock.
          .FSETS==10    ;Simulate hard errors.
          .FSRRL==11    ;Read/reset log for 3330's.
      
      
      subttl STRUUO error codes
      
          FSILF%==0     ;Illegal function code
          FSSNF%==1     ;Structure not found
          FSSSA%==2     ;Structure single access only
          FSILE%==3     ;Illegal list entry
          FSTME%==4     ;Too many entries in list
          FSUNA%==5     ;Unit not available
          FSPPN%==6     ;PPN doesn't match
          FSMCN%==7     ;Mount count greater then 1
          FSNPV%==10    ;No license
          FSFSA%==11    ;Structure already exists
          FSILL%==12    ;Bad list length
          FSUNC%==13    ;Unable to complete UUO
          FSNFS%==14    ;System full of structures
          FSNCS%==15    ;No free core
          FSUNF%==16    ;Illegal unit
          FSRSL%==17    ;File structure repeated in list
      
      
      subttl CREAUX control bits
      
          CX.NZP==1B17  ;don't zap on RESET
      
      
      subttl RETACH error codes
      
          RTSAC%==1     ;insufficient access rights to source frame
          RTSNX%==2     ;source frame does not exist
          RTTAC%==3     ;insufficient access rights  to target frame
          RTTNX%==4     ;target frame does not exist
          RTSNA%==5     ;specified port not attached to source frame
          RTTAT%==6     ;target frame already has port attached
          RTSCP%==7     ;forced command already pending on port
          RTAUX%==10    ;attaching aux circuit as command port
          RTNRM%==11    ;no room for new port DDB
      
      
      subttl CREAUX Error Codes (left half)
      
          CXSUP%==0     ;supervisor error code in right half
          CX2AX%==1     ;too many circuits without Auxiliary Circuit (AC)
          CXLOG%==2     ;not your username without Auxiliary Circuit (AC)
          CXDCB%==3     ;no room in monitor
          CXNRR%==4     ;supervisor did not respond
          CXNRL%==5     ;supervisor did not respond
          CXNCH%==6     ;supervisor did not supply a circuit
          CXERR%==7     ;supervisor error from original request
      
      
      subttl CREAUX Error Codes (right half)
      
          CXSFE%==1     ;format error
          CXSBU%==2     ;user not in mud
          CXSBM%==3     ;bad mud
          CXSHU%==4     ;host unavailable
          CXSDF%==5     ;downline load or dialout request failure
          CXSTO%==6     ;timeout
          CXSAB%==7     ;access barred
          CXSIS%==10    ;error in ISIS
          CXSLQ%==11    ;long queue in supervisor
                                              A-16


            July 3, 1980                             A                                UUOSYM.MAC


            
            
            subttl Port Event-Status Bits
            
                LXRESC==1B0   ;escape seen
                LXROBS==1B1   ;orange ball seen
                LXRPSS==1B2   ;port status message seen
                LXRICL==1B3   ;input characters lost
                LXROCL==1B4   ;output characters lost
                LXRCHR==1B5   ;character seen
                LXRBRK==1B6   ;break condition seen
                LXRYBS==1B7   ;yellow ball seen
                LXRGOB==1B10  ;character gobbler seen
            
            
            subttl Line Characteristics Word
            
                LC.ECS==1B2   ;"command line" exists,will be thrown away
                LC.PSS==1B3   ;** a port status message has been seen
                LC.OBS==1B4   ;** an orange ball has been seen
                LC.HDX==1B5   ;* half duplex
                LC.ESC==1B6   ;** an escape has been seen
                LC.CRD==1B7   ;* compute carriage return delay (not LF)
                LC.DFR==1B8   ;in deferred echo mode
                LC.NOP==1B9   ;suppress output bit
                LC.NFC==1B10  ;* no free carriage return
                LC.BRK==1B11  ;input buffer contains a break character
                LC.AXC==1B12  ;auxiliary circuit
                LC.NCM==1B13  ;* no case mapping
                LC.HHT==1B14  ;* hardware horizontal tabs
                LC.LCP==1B15  ;local-copy (e.g. 2741) device
                LC.PTM==1B16  ;* paper tape mode
                LC.HFF==1B17  ;* hardware VT/FF
                LC.PNO==777777B35       ;port number
            
            
            subttl MTAPE Functions
            
                .MTWAT==0     ;wait for i/o completion
                .MTREW==1     ;rewind
                .MTEOF==3     ;write tape mark
                .MTSKR==6     ;skip forward 1 record
                .MTBSR==7     ;backspace 1 record
                .MTEOT==10    ;go to logical end of tape
                .MTUNL==11    ;rewind and unload
                .MTBLK==13    ;erase gap
                .MTSKF==16    ;skip forward 1 file
                .MTBSF==17    ;backspace 1 file
                .MTDEC==100   ;set DEC 9-track mode
                .MTIC0==101   ;set IBM 9-track mode, byte adjust 0
                .MTIC1==102   ;set IBM 9-track mode, byte adjust 1
                .MTIC2==103   ;set IBM 9-track mode, byte adjust 2
                .MTIC3==104   ;set IBM 9-track mode, byte adjust 3
                .MT7E0==201   ;set special 7-track mode, byte adjust 0
                .MT7E1==202   ;set special 7-track mode, byte adjust 1
                .MT7E2==203   ;set special 7-track mode, byte adjust 2
                .MT7E3==204   ;set special 7-track mode, byte adjust 3
            
            
            subttl UGETF Function Codes
            
                .UGCNT==0     ;return byte/word count of last input
                .UGSEN==1     ;return drive sense data
                .UGSTS==2     ;return drive status data
                MT.PRO==1B0   ;write protected
                MT.TAB==3B2   ;TU A & B
                MT.LDP==1B3   ;load point
                MT.EOT==1B4   ;end of tape indicator
                                                    A-17


      UUOSYM.MAC                               A                          YAMM edition 2.0


          MT.IBM==1B5   ;IBM compatible unit
          MT.7TR==1B12  ;7 track capability
          MT6250==1B13  ;6250 bpi capability
          MT1600==1B14  ;1600 bpi
          MT800== 1B15  ;800 bpi
          MT556== 1B16  ;556 bpi
          MT200== 1B17  ;200 bpi
      
      
      subttl APRENB interrupt bits
      
          AP.REN==1B18  ;Repetitive enable
          CN.POV==1B19  ;Stack Overflow or Underflow
          AP.POV==1B19  ;Stack Overflow or Underflow
          CN.UUO==1B18  ;UUO or ill ins
          AP.UUO==1B20  ;UUO or ill ins
          CN.BRK==1B24  ;Break character
          AP.BRK==1B21  ;Break character
          CN.ILM==1B22  ;Ill mem ref
          AP.ILM==1B22  ;Ill mem ref
          CN.CHR==1B21  ;Character
          AP.CHR==1B24  ;Character
          CN.ESC==1B17  ;Escape (ctrl-C)
          AP.ESC==1B25  ;Escape (ctrl-C)
          CN.CLK==1B26  ;Clock tick
          AP.CLK==1B26  ;Clock tick
          CN.FOV==1B29  ;Floating overflow
          AP.FOV==1B29  ;Floating overflow
          CN.HNG==1B16  ;Hung device
          AP.HNG==1B30  ;Hung device
          CN.AOV==1B32  ;Integer overflow
          AP.AOV==1B32  ;Integer overflow
      
      
      subttl Port Interrupt Cause Codes
      
          .IAESC==0     ;Receipt of an escape.
          .IACHR==1     ;Receipt of a character.
          .IABRK==2     ;Receipt of a break character.
          .IAIOW==3     ;Potential I/O wait
          .IAROM==4     ;Room for more output characters.
          .IALOS==5     ;Characters lost on input.
          .IAORG==6     ;Receipt of an orange ball.
          .IAZAP==7     ;Receipt of a circuit zapper.
          .IAPSS==10    ;Port Status msg seen
          .IAYEL==11    ;Receipt of Yellow Ball.
          .IAGOB==12    ;Receipt of Character Gobbler.
      
      
      subttl General Interrupt Cause Codes
      
          .IAUUO==0     ;UUO or illegal instruction
          .IACLK==1     ;Clock tick while running
          .IAILM==2     ;Ill mem ref
          .IAHNG==3     ;Hung device
          .IATIM==4     ;SETTIM timer interrupt
          .IADEV==5     ;Device error
          .IAWAK==6     ;Wake UUO for this frame
          .IAFEL==7     ;Page fault (WS=WSL)
          .IAFLL==10    ;Page fault (WSWSL)
          .IAREF==11    ;Reference-bit trap
          .IAERR==12    ;Paging I/O error
          .IANTQ==13    ;Notice to quit (sys going down)
          .IAFEX==14    ;Frame exit in child
      
      
      subttl INTRMT error codes
      
                                              A-18


            July 3, 1980                             A                                UUOSYM.MAC


                IRBCH%==1     ;bad I/O channel
                IRBDR%==5     ;bad interrupt reason
                IRBIC%==6     ;bad interrupt channel number
                IRNIS%==7     ;no INTADR system in effect.
            
            
            subttl Club Interlock Status Flags
            
                CB.NML==1     ;last interlock release was normal
                CB.EVI==2     ;Ever Interlocked
            
            
            subttl Club Facility Standard Error Codes
            
                CBVPR%==1     ;VP number out of legal range
                CBNEX%==2     ;VP does not exist (has no disk page mapped)
                CBINC%==3     ;Caller already in a club for this VP
                CBIDO%==4     ;Club ID number overflow
                CBNIC%==5     ;Not in Club (from UUOs requiring club membership)
                CBVPM%==6     ;VP mismatch
                CBHIL%==7     ;Have Interlock,cannot perform UUO at this time
                CBAIL%==10    ;Attempted to get Interlock, but it was busy
                CBNIL%==11    ;No Interlock
                CBCNT%==12    ;Requested count of club members is 0
                CBNFC%==13    ;Not First Class
                CBJNI%==14    ;Frame Not In your club,can't get info on it
            
            
            subttl GETTAB table numbers
            
                .GTFTR==-54   ;frame tree information
                .GTUID==-53   ;Universal ID
                .GTPNO==-52   ;Program Number
                .GTSPW==-51   ;double precision pages-to-WS*size
                .GTPWS==-50   ;pages to working-set
                .GTMPC==-47   ;pages mapped/created
                .GTMCY==-46   ;double precision microcycles
                .GTKCM==-45   ;double precision K-core microcycles
                .GTTRU==-44   ;double precision TRUs * 10^4
                .GTTR2==-43   ;high order TRUs * 10^4
                .GTMC2==-42   ;high order microcycles
                .GTBIO==-41   ;block IO chars transmitted
                .GTBET==-40   ;BIO elapsed time (sec)
                .GTSOK==-37   ;TYMCHG TRUs * 10^4
                .GTLNK==-36   ;debugging tables
            ;   ==      -35   ;(obsolete) remote IO
            ;   ==      -34   ;(obsolete) remote secs
                .GTERN==-33   ;ENTER + RENAME count
                .GTLPS==-32   ;tty input line position
                .GTMOD==-31   ;tty mode (GETSTS info)
                .GTLIM==-30   ;time limit (TRUs * 10^4)
                .GTLIN==-27   ;TTY: name in SIXBIT; (lh)=0 if detached
                .GTJOB==-26   ;frame who owns this port
                .GTFPN==-25   ;File Proj-prog Number
                .GTLOG==-24   ;LDBLOG info (Table 18-7b)
                .GTAUN==-23   ;Accounting User Number
                .GTUNM==-22   ;user name (1-6) SIXBIT
                .GTUN1==-21   ;user name (7-12) SIXBIT
                .GTLIC==-20   ;license word
            ;   ==      -17   ;reserved
            ;   ==      -16   ;reserved
                .GTMC1==-15   ;low order microcycles
                .GTKM2==-14   ;high order K-core microcycles
                .GTBCS==-13   ;K-core break chars
                .GTCNK==-12   ;attach time (sec)
                .GTELP==-11   ;K-core seconds
                .GTCOT==-10   ;characters output
                .GTCIN==-7    ;characters input
                                                    A-19


      UUOSYM.MAC                               A                          YAMM edition 2.0


          .GTSOT==-6    ;K-core DSK blocks out
          .GTSIN==-5    ;K-core DSK blocks in
          .GTSRN==-4    ;K-core ENTER + RENAME
          .GTSLK==-3    ;K-core LOOKUP
          .GTDLK==-2    ;LOOKUP count
      ;   ==      -1    ;reserved
          .GTSTS==0     ;Status Bits (Table 2-7 )
      ;   ==      1     ;reserved
          .GTPPN==2     ;Project Programmer Number
          .GTNAM==3     ;SIXBIT user program name
          .GTTR1==4     ;low order TRUs * 10^4
          .GTKM1==5     ;low order K-core microcycles
          .GTPRV==6     ;Privilege Bits (Table 2-3 )
          .GTSWP==7     ;swapper status bits
          .GTTTY==10    ;address of TTY DDB
          .GTCNF==11    ;config data (Table 18-7 )
          .GTNSW==12    ;nonswap data (Table 18-8c)
      ;   ==      13    ;(obsolete) swapper data
      ;   ==      14    ;(obsolete) high seg data
          .GTODP==15    ;ONCE-time disk parameters (Table 18-9 )
          .GTLVD==16    ;level-D disk (Table 18-8b)
          .GTRCT==17    ;DSK blocks in
          .GTWCT==20    ;DSK blocks out
      ;   ==      21    ;reserved
      ;   ==      22    ;reserved
          .GTSLF==23    ;GETTAB table addresses
      ;   ==      24    ;(obsolete) dev/str name
          .GTWSC==25    ;wait states (Table 18-10 )
      ;   ==      26    ;reserved
      ;   ==      27    ;(obsolete) physical core table
      
      
      subttl .GTCNF Items
      
          .CNFG0==0     ;System Name (in ASCII)
          .CNDT0==5     ;System Date (in ASCII)
          .CNTAP==7     ;System Device Name (in SIXBIT)
          .CNTIM==10    ;jiffies since midnight GMT
          .CNDAT==11    ;days since 1 January 1964 GMT
          .CNSIZ==12    ;words used by monitor
          .CNOPR==13    ;operator console name (in SIXBIT)
          .CNDEV==14    ;lh = address of first DDB
          .CNNJB==15    ;largest possible frame number+1
          .CNSTS==17    ;states word
          .CNSER==20    ;cpu serial number
          .CNNSM==21    ;memory cycle time (in nanoseconds)
          .CNFRE==22    ;freecore bit map AOBJN pointer
          .CNLOC==23    ;address of first freecore
          .CNPTS==24    ;number of ports
          .CNLGO==25    ;LOGOUT program name (in SIXBIT)
          .CNJPS==26    ;jiffies per second
          .CNJPM==27    ;jiffies per minute
          .CNJPH==30    ;jiffies per hour
          .CNHGH==31    ;highest addressible block in core
          .CNHFD==32    ;Snoopy facility buffer size,,beginning loc
          .CNSYS==33    ;system number
          .CNFCW==34    ;freecore words allocated
          .CNSCC==35    ;Soft Crash Countdown in seconds
          .CNS30==36    ;XWD SAV30,NUMTAB ; info for crash analysis
      
      
      subttl .GTLOG Bits (GETTAB -24)
      
          LG.ZAP==1B1   ;a zapper has been received on this port
          LG.GON==1B2   ;this port is gone
          LG.HDX==1B6   ;this port is half-duplex
          LG.NAX==1B16  ;1 if this port is not an aux circuit
          LG.TID==17B11 ;terminal identifier code
                                              A-20


            July 3, 1980                             A                                UUOSYM.MAC


                LG.ND1==77B19 ;high-order 6 bits of the originating node number
                LG.ND2==77B27 ;low-order 6 bits of the originating node number
                         177B35                LG.PORT==     ;TYMNET port number
            
            
            subttl .GTLVD (GETTAB 16) Items;
            
                .LDMFD==0     ;MFD PPN [1,1]
                .LDSYS==1     ;SYS PPN [1,4]
                .LDFSF==2     ;FAILSAFE PPN  (obsolete)
                .LDHLP==3     ;HELP PPN (obsolete)
                .LDSPL==4     ;SPOOL PPN (obsolete)
                .LDDRB==5     ;directory block pointers
                .LDSTR==6     ;(obsolete)
                .LDUNI==7     ;unit data block pointers
                .LDSWP==10    ;(unused)
                .LDCBN==11    ;number of file system core blocks
                .LDSTP==12    ;standard file protection
                .LDUFP==13    ;standard directory protection
                .LDRPC==14    ;number of RIB PCBs
                .LDSPC==15    ;number of SAT PCBs
                .LDQST==16    ;sixbit name of fastest STR
                .LDACT==17    ;accounting program PPN [6,270]
                .LDCRS==20    ;(obsolete)
                .LDLKB==21    ;longest meaningful LOOKUP block size
            
            
            subttl .GTNSW items (GETTAB 12)
            
                .NSCMX==10    ;maximum CORE request + 1
                .NSCTL==12    ;# free core blocks left
                .NSUPT==15    ;uptime (in jiffies)
                .NSHJB==20    ;highest frame number currently assigned
                .NSCLW==21    ;(obsolete) words cleared by CLRCOR
                .NSLST==22    ;lost time (in jiffies)
                .NSMMS==23    ;physical memory size (in words)
                .NSTPE==24    ;# parity errors
                .NSSPE==25    ;# spurious parity errors
                .NSCPE==26    ;# oper cont from parity errors
                .NSMPA==27    ;addr of last parity error
                .NSMPW==30    ;contents of that word
                .NSMPP==31    ;PC at the time of that error
                .NSNUL==34    ;null time (tics)
                .NSNMN==35    ;null time during the last minute (tics)
                .NSALR==36    ;alarm (unhappy msg) bits
                .NSMWM==37    ;monitor WS max size
                .NSUID==40    ;latest UID issued (SYSUID)
                .NSSTM==41    ;uptime of latest SCNSER cycle
                .NSMXT==42    ;max time between SCNSER cycles
            
            
            subttl .GTODP items (once disk parameters)
            
                .ODSWH==0     ;highest block for swapping (obsolete)
                .ODSWK==1     ;K of disk words for swapping (obsolete)
                .ODPRT==2     ;in-core protect mult (tics/page)
                .ODPRA==3     ;in-core protect offset (tics)
                .ODMXP==4     ;max value for ICPT function
                .ODDCT==5     ;action code for DSKCLN
            
            
            subttl Wait State Codes
            
            ;   WS.RN==       ;running
            ;   WS.WS==       ;I/O wait satisfied
            ;   WS.TS==       ;Terminal I/O wait satisfied
            ;   WS.SS==       ;Swap wait satisfied
            ;   WS.SI==       ;SAT I/O wait
                                                    A-21


      UUOSYM.MAC                               A                          YAMM edition 2.0


      ;   WS.RI==       ;RIB I/O wait
      ;   WS.PS==       ;SAT primary PCB wait
      ;   WS.PR==       ;RIB primary PCB wait
      ;   WS.M2==       ;Two PCB wait
      ;   WS.DA==       ;Disk Allocation wait
      ;   WS.CB==       ;File system Core Block resource wait
      ;   WS.FC==       ;Freecore wait
      ;   WS.MT==       ;Magtape control wait (up to 8 units)
      ;   WS.AX==       ;Aux Circuit resource wait
      ;   WS.AC==       ;Accounting Resource wait
      ;   WS.BP==       ;Block I/O port resource wait
      ;   WS.IOW==      ;I/O wait
      ;   WS.MBW==      ;Monitor Buffer wait
      ;   WS.TIO==      ;Terminal I/O wait
      ;   WS.SW==       ;Swap wait
      ;   WS.ML==       ;PCB Lock queue wait
      ;   WS.IL==       ;Club Interlock wait
      ;   WS.FL==       ;File wait (atomic lock queue)
      ;   WS.SL==       ;Sleep
      ;   WS.NU==       ;Null (no process here)
      ;   WS.ST==       ;Stop (usually displayed "^C")
      
      
      subttl SETABK control bits
      
          AB.FET==1B9   ;break on instruction-fetch
          AB.RED==1B10  ;break on reads
          AB.WRT==1B11  ;break on writes
          AB.USR==1B12  ;0=monitor, 1=user address







































                                              A-22


            July 3, 1980                             B                      System Calls by Name



                                            ______ _____ __ ____                                            System Calls by Name



            Call             Name      Page    Description

            CALLI ac,+16     APRENB    16-2    enable APRENB trapping
            CALLI ac,-6      ATTACH    10-20   attach command port to frame
            op code 042      AUXCAL    10-3    perform port i/o functions
               fn 66         .AXBBP    10-28   r/s backspace break/punctuation bit
               fn 57         .AXBS     10-28   r/s BS-for-char-delete bit
               fn 6          .AXCBI    10-29   clear input buffer
               fn 7          .AXCBO    10-29   clear output buffer
               fn 64         .AXCFS    10-27   change port file status bits
               fn 14         .AXCRD    10-28   r/s compute-CR-delay bit
               fn 34         .AXEBM    10-41   enter block i/o mode
               fn 63         .AXEDE    10-28   r/s force deferred-echo bit
               fn 17         .AXEP     10-28   r/s even-parity bit
               fn 62         .AXERA    10-28   r/s Erase-for-char-delete bit
               fn 30         .AXFC1    10-28   r/s filler class 1
               fn 31         .AXFC2    10-28   r/s filler class 2
               fn 20         .AXHD     10-28   r/s half-duplex bit
               fn 60         .AXHNG    10-23   send hangup
               fn 24         .AXHNX    10-28   r/s host-no-XON bit
               fn 2          .AXI8B    10-33   input char [wait/img]
               fn 0          .AXI8C    10-32   input char [wait/bka/img]
               fn 1          .AXI8S    10-33   input char [skip/bka/img]
               fn 15         .AXIBR    10-28   r/s input baud rate
               fn 36         .AXIBS    10-41   input block and skip
               fn 35         .AXIBW    10-41   input block and wait
               fn 45         .AXICS    10-31   input char [skip/bka]
               fn 44         .AXICW    10-30   input char [wait/bka]
               fn 47         .AXISL    10-32   input char [skip]
               fn 46         .AXIWL    10-31   input char [wait]
               fn 42         .AXLBM    10-41   leave block i/o mode
               fn 65         .AXLCO    10-28   r/s Lower-case-output bit
               fn 11         .AXLDE    10-29   leave deferred echo mode
               fn 25         .AXNTE    10-28   r/s no HT/VT/FF bit
               fn 3          .AXO8     10-37   output char [IMG]
               fn 4          .AXO8I    10-37   output char [IMG/IMM]
               fn 37         .AXOB     10-42   block output
               fn 16         .AXOBR    10-28   r/s output baud rate
               fn 51         .AXOCI    10-37   output char [IMM]
               fn 67         .AXOPC    10-40   output string [PTR+count]
               fn 52         .AXOST    10-39   output string [STR]
               fn 21         .AXPA     10-28   r/s parameter A
               fn 22         .AXPB     10-28   r/s parameter B
               fn 23         .AXPC     10-28   r/s parameter C
               fn 61         .AXPSM    10-25   read port-status msg
               fn 5          .AXPTR    10-40   output string [PTR]
               fn 54         .AXRBS    10-28   r/s remote-BS-echo bit
               fn 53         .AXRMX    10-28   r/s remote-XON bit
               fn 55         .AXRVX    10-28   r/s reverse-XON bit
               fn 13         .AXS8B    10-28   set image break char
               fn 32         .AXSFS    10-27   set port file status bits (obsolescent)
               fn 33         .AXSI     10-34   simulate input
               fn 10         .AXSIC    10-34   skip if char
               fn 50         .AXSIL    10-34   skip if break char
               fn 43         .AXSLV    10-22   slave command port
               fn 70         .AXSOB    10-29   send orange ball
               fn 12         .AXSYB    10-29   send yellow ball
               fn 40         .AXTBI    10-42   terminate block input
               fn 26         .AXTBK    10-28   r/s tabs-as-breaks bit
               fn 41         .AXTBO    10-42   terminate block output
               fn 56         .AXTYP    10-28   r/s terminal type
               fn 27         .AXWID    10-28   r/s line width
            CALLI ac,-46     AUXRED    10-24   read aux circuit port numbers
                                                    B-1


      System Calls by Name                     B                          YAMM edition 2.0

      Call             Name      Page    Description
      CALLI ac,-120    BITPOK    18-11   read/modify/write in monitor memory
      CALLI ac,-123    BLTPAG    4-10    change data in page uninterruptibly
      CALLI ac,-2      CALIM2    19-5    (obsolete)
      CALLI ac,-3      CALIM3    19-5    (obsolete)
      CALLI ac,-4      CALIM4    19-5    (obsolete)
      CALLI ac,-5      CALIM5    19-5    (obsolete)
      op code 043      CHANIO    5-8     do channel i/o functions
         fn 40         .CHCFP    8-24    create file page
         fn 1          .CHCLS    5-12    close a file
         fn 36         .CHDFP    8-24    delete file page
         fn 5          .CHENT    8-16    select file for output
         fn 44         .CHFFI    8-25    Find First Interesting Page
         fn 27         .CHFSI    8-21    set file pointer by block
         fn 30         .CHFSO    8-22    set file position by block
         fn 45         .CHFTR    8-25    Truncate File
         fn 17         .CHGS     5-13    read file status bits
         fn 22         .CHIBF    6-3     create input buffer ring
         fn 14         .CHIN     5-11    input from channel
         fn 3          .CHIPT    5-11    input from channel
         fn 4          .CHLK     8-17    select file for input
         fn 26         .CHMBF    6-4     move buffers
         fn 41         .CHMEN    8-16    select file for multi-update output
         fn 35         .CHMFP    4-5     map file pages
         fn 34         .CHMGN    8-26    manipulate update-interlock bit
         fn 12         .CHMTA    11-3    perform magtape functions
         fn 23         .CHOBF    6-3     create output buffer ring
         fn 13         .CHOPN    5-10    Open a Channel
         fn 2          .CHOPT    5-11    output from channel
         fn 15         .CHOUT    5-11    output from channel
         fn 31         .CHPSI    8-21    set file pointer by page
         fn 32         .CHPSO    8-22    set file position by page
         fn 0          .CHREL    5-13    release device
         fn 11         .CHREN    8-17    rename or delete a file
         fn 24         .CHSK     8-23    seek to current page
         fn 43         .CHSMP    4-6     super-map file pages
         fn 21         .CHSO     5-14    skip if file status bits set
         fn 16         .CHSS     5-13    set file status bits
         fn 20         .CHSZ     5-14    skip if file status bits clear
         fn 33         .CHUFD    8-3     read UFD
         fn 10         .CHUGF    8-32    read disk file position
         fn 6          .CHUSI    8-21    set file pointer by block
         fn 7          .CHUSO    8-22    set file position by block
         fn 42         .CHVRB    8-32    validate RIB
         fn 25         .CHWT     5-7     wait until device inactive
         fn 37         .CHXFP    8-24    exchange file pages
      CALLI ac,+74     CHGPPN    2-2     change frame PPN
      CALLI ac,-31     CHKLIC    2-4     check settable license
      CALLI ac,-61     CHPRJ     2-8     change project code
      CALLI ac,-114    CLBADD    17-3    Join Club
      CALLI ac,-104    CLBHNG    17-6    Hang Club Member
      CALLI ac,-111    CLBINI    17-4    Get Interlock,No Wait
      CALLI ac,-112    CLBINW    17-4    Get Interlock,wait
      CALLI ac,-113    CLBLEV    17-3    Leave a Club
      CALLI ac,-107    CLBMEM    17-5    Read Club Member List
      CALLI ac,-110    CLBRLI    17-5    Release Club Interlock
      CALLI ac,-106    CLBSTS    17-5    Read Status of Club Member
      CALLI ac,-105    CLBWAK    17-6    Wake Up Club Member
      op code 070      CLOSE     5-12    close a file
      TTCALL 11,e      CLRBFI    10-29   clear input buffer
      TTCALL 12,e      CLRBFO    10-29   clear output buffer
      CALLI ac,-125    CONT      10-35   Put port in user level
      CALLI ac,+11     CORE      3-1     allocate or free core
      CALLI ac,-44     CREAUX    10-21   create an aux circuit
      CALLI ac,-47     CRERMT    19-5    (obsolete) create 620 port
      CALLI ac,+14     DATE      18-1    read date
      CALLI ac,-55     DATUUO    18-2    do time zone conversions
      CALLI ac,-54     DDT620    19-5    (obsolete) interrogate 620
      CALLI ac,+5      DDTGT     19-5    (obsolete) Get DDT mode
                                              B-2


            July 3, 1980                             B                      System Calls by Name

            Call             Name      Page    Description
            CALLI ac,+1      DDTIN     10-35   DDT-mode input
            CALLI ac,+3      DDTOUT    10-40   DDT-mode output
            CALLI ac,+7      DDTRL     19-5    (obsolete) Release DDT mode
            CALLI ac,+4      DEVCHR    5-6     read device characteristics word
            CALLI ac,+64     DEVNAM    5-6     read device physical name
            CALLI ac,+55     DEVPPN    5-6     read PPN
            CALLI ac,+101    DEVSIZ    6-3     read standard buffer size
            CALLI ac,+54     DEVSTS    5-6     read device hardware status
            CALLI ac,-23     DISMIS    16-8    dismiss INTADR interrupts
            CALLI ac,+45     DSKCHR    8-27    read disk characteristics
            CALLI ac,-22     DSKCLR    8-32    initialize in-core file system data
            op code 077      ENTER     8-16    select file for output
            CALLI ac,-134    EVICT     2-10    Cause Notice to Quit Interrupt
            CALLI ac,+12     EXIT      2-32    stop frame execution
            op code 044      FRMOP     2-16    Frame Operation
               fn 30         .FOCAR    2-32    Read Child Access Rights
               fn 31         .FOCER    2-32    Read Child Effective Rights
               fn 12         .FOCFH    2-28    Create Handle
               fn 1          .FOCFM    2-19    create frame
               fn 21         .FOCHR    2-31    Change Handle Rights
               fn 14         .FOCLR    2-24    Clear a Frame
               fn 25         .FOCON    2-27    continue frame
               fn 13         .FODFH    2-29    Destroy Handle
               fn 32         .FOGET    2-21    Setup frame core image from file
               fn 24         .FOGFT    2-20    Graft Frame Subtree
               fn 26         .FOGIN    2-27    Gate-jump Initialization
               fn 5          .FOHLT    2-23    halt frame
               fn 23         .FOHST    2-25    Read Halt Status Block
               fn 0          .FOJMP    2-22    gate jump to frame
               fn 16         .FORAR    2-30    Read Handle Access Rights
               fn 7          .FOREP    2-21    VREPLC to/from another frame
               fn 17         .FORER    2-30    Read Handle Effective Rights
               fn 6          .FORPC    2-24    Read Frame PC
               fn 15         .FORSI    2-30    Read Standard Access Rights Info
               fn 33         .FORUN    2-27    RUN program in frame
               fn 2          .FORVA    2-20    read frame virtual address
               fn 4          .FOSAA    2-23    start frame at absolute address
               fn 34         .FOSAV    2-22    SAVE frame core image on file
               fn 20         .FOSMF    2-31    Set Max Frame Rights
               fn 35         .FOSSA    2-22    SAVE frame core image on SHR file
               fn 22         .FOSVA    2-24    start frame at vector address
               fn 27         .FOVCH    2-31    Validate Child Rights
               fn 11         .FOVCL    2-21    VCLEAR in another frame
               fn 10         .FOVRM    2-21    VREMOV in another frame
               fn 3          .FOWVA    2-21    write frame virtual address
            CALLI ac,+6      GETCHR    5-6     read device characteristics word
            TTCALL 6,e       GETLCH    10-25   read line characteristics
            CALLI ac,+34     GETLIN    10-20   get command port name
            CALLI ac,-121    GETPFW    19-5    (obsolete)
            CALLI ac,+24     GETPPN    2-2     get frame PPN
            CALLI ac,+40     GETSEG    3-6     load a high segment
            op code 062      GETSTS    5-13    read file status bits
            CALLI ac,+41     GETTAB    18-3    read monitor tables
            CALLI ac,-16     GETTMC    10-26   (obs.) get terminal characteristics
            CALLI ac,+66     GOBSTR    8-29    Get system search list
            CALLI ac,-32     HANG      2-10    hang a port or frame or frames
            CALLI ac,+72     HIBER     16-8    wait for event
            CALLI ac,-51     IDLRMT    19-5    (obsolete) set 620 idle
            op code 056      IN        5-11    input from channel
            op code 064      INBUF     6-3     create input buffer ring
            TTCALL 2,e       INCHRS    10-31   input char [skip/bka]
            TTCALL 0,e       INCHRW    10-30   input char [wait/bka]
            TTCALL 5,e       INCHSL    10-32   input char [skip]
            TTCALL 4,e       INCHWL    10-31   input char [wait]
            op code 041      INIT      5-10    Open a Channel
            op code 066      INPUT     5-11    input from channel
            CALLI ac,-35     INTACT    16-7    cause and uncause interrupts
            CALLI ac,-33     INTADR    16-5    initialize INTADR system
                                                    B-3


      System Calls by Name                     B                          YAMM edition 2.0

      Call             Name      Page    Description
      CALLI ac,-36     INTASS    16-6    assign general interrupt causes
      CALLI ac,-34     INTENB    16-7    enable and disable INTADR channels
      CALLI ac,-52     INTRMT    16-6    (obsolete) assign I/O software interrupts
      TTCALL 15,e      IONEOU    10-37   output char [CMD/IMG]
      CALLI ac,+47     JOBSTR    8-30    Return frames next file structure
      CALLI ac,-30     LEVDEF    10-29   leave deferred echo mode
      CALLI ac,-1      LIGHTS    18-12   display word in console lights
      CALLI ac,+15     LOGIN     2-7     log a frame in
      CALLI ac,-130    LOGOFF    2-9     Run Alternate Logout Program
      CALLI ac,+17     LOGOUT    2-9     log a frame out
      op code 076      LOOKUP    8-17    select file for input
      CALLI ac,-27     MOVBUF    6-4     move buffers
      CALLI ac,+23     MSTIME    18-3    read time in ms
      op code 072      MTAPE     11-3    perform magtape functions
      CALLI ac,-20     ONEJOB    19-3    skip if only frame and super-shut
      op code 050      OPEN      5-10    Open a Channel
      op code 057      OUT       5-11    output from channel
      op code 065      OUTBUF    6-3     create output buffer ring
      TTCALL 16,e      OUTCHI    10-36   output char [CMD/IMM]
      TTCALL 1,e       OUTCHR    10-36   output char [CMD]
      TTCALL 17,e      OUTPTR    10-39   output string [PTR/CMD]
      op code 067      OUTPUT    5-11    output from channel
      TTCALL 3,e       OUTSTR    10-38   output string [STR/CMD]
      CALLI ac,-71     PAGSTS    4-16    read page status word
      CALLI ac,+33     PEEK      18-11   (obsolete) read monitor core
      CALLI ac,-72     PERSET    4-11    set/clear error bit
      CALLI ac,-100    PGESTS    4-12    read/clear page-error status words
      CALLI ac,-101    PGFSTS    4-14    read and clear page fault words
      CALLI ac,-132    PGISTS    4-14    read/clear ill mem ref fault info
      CALLI ac,-133    PGRSTS    4-14    read/clear REFBIT fault info
      CALLI ac,-122    PIDSET    9-2     Manipulate Process' PID
      CALLI ac,+30     PJOB      2-2     get frame number
      CALLI ac,-12     POKE      18-11   write in monitor core
      CALLI ac,-115    POLPRT    10-24   Poll Ports for Events
      CALLI ac,-75     PREREF    4-10    prereference a page
      CALLI ac,-63     PUTLSA    20-6    write local stream acctg record
      CALLI ac,-124    PUTROY    20-5    Put Royalty Record in Stream
      CALLI ac,-62     PUTSAR    20-6    write stream acctg record
      CALLI ac,-117    RDHIST    19-5    (not available)
      CALLI ac,+21     REASSI    5-6     reassign i/o device
      CALLI ac,-14     REDNXT    10-35   peek at input
      CALLI ac,-43     REDPIP    16-7    read in-progress bits
      CALLI ac,-73     REFBIT    4-15    manipulate reference bits
         fn 0          .RFRBM    4-15    Read refbits
         fn 2          .RFRNG    4-15    set refbits by range
         fn 1          .RFSBM    4-15    Set refbits from bitmap
      op code 071      RELEAS    5-13    release device
      CALLI ac,+37     REMAP     3-2     move top of lowseg to highseg
      op code 055      RENAME    8-17    rename or delete a file
      TTCALL 10,e      RESCAN    10-35   rescan command line
      CALLI ac,+0      RESET     5-12    initialize frame state
      CALLI ac,-135    RETACH    10-20   move port from frame to frame
      CALLI ac,+35     RUN       3-7     load and run a program
      CALLI ac,-25     RUNSEG    3-10    load and run a high segment
      CALLI ac,+27     RUNTIM    18-3    get TRUs
      CALLI ac,+56     SEEK      8-23    seek to current page
      CALLI ac,-131    SETABK    19-3    Set/Clear Address Break
      CALLI ac,-127    SETALP    2-10    Set Alternate Logout Program
      CALLI ac,+2      SETDDT    3-3     set DDT start address
      CALLI ac,-7      SETE      2-5     set frame license
      CALLI ac,-21     SETJAL    2-6     set frame status bits
      TTCALL 7,e       SETLCH    10-26   set line characteristics
      CALLI ac,-10     SETLIC    2-5     set process license
      CALLI ac,-17     SETMAL    2-3     set mail-waiting bit
      CALLI ac,-26     SETMOD    10-26   set cmnd port file status
      CALLI ac,+43     SETNAM    2-2     set frame name
      CALLI ac,-126    SETOTF    2-13    set other-frame FD
      CALLI ac,+32     SETPOV    19-5    (obsolete) Set PDL OV trap
                                              B-4


            July 3, 1980                             B                      System Calls by Name

            Call             Name      Page    Description
            CALLI ac,-11     SETPRV    2-2     set frame privilege word
            CALLI ac,-57     SETRCF    2-9     set restricted cmnd file
            op code 060      SETSTS    5-13    set file status bits
            CALLI ac,-137    SETSTV    2-33    set start vector address
            CALLI ac,-37     SETTIM    16-6    set timer interrupt
            CALLI ac,-15     SETTMC    10-26   (obsolete) no-op
            CALLI ac,-40     SETTR1    16-1    set arithmetic overflow instruction
            CALLI ac,-41     SETTR2    16-1    set stack over/underflow instruction
            CALLI ac,+75     SETUUO    19-1    do SET command functions
               fn 11         .STBST    19-2    Set/Read BOOTS command string
               fn 4          .STDAT    19-2    set date
               fn 2          .STFAR    19-1    finish auto-restart
               fn 12         .STRES    19-2    Read/Set RESTART bits
               fn 1          .STSTA    19-1    set STATES
               fn 3          .STTIM    19-1    set time
               fn 0          .STTYO    19-1    OUTSTR to OPR terminal
               fn 6          .STWAT    2-8     set WATCH bits
            CALLI ac,+36     SETUWP    3-2     set highseg write protection
            TTCALL 13,e      SKPINC    10-34   skip if char
            TTCALL 14,e      SKPINL    10-34   skip if break char
            CALLI ac,+31     SLEEP     16-9    wait for N seconds
            CALLI ac,-116    SNOOP     19-5    (not available)
            CALLI ac,+42     SPYUUO    19-5    (obsolete)
            op code 061      STATO     5-14    skip if file status bits set
            op code 063      STATZ     5-14    skip if file status bits clear
            CALLI ac,+50     STRUUO    8-30    Manipulate file structures
            CALLI ac,+20     SWITCH    18-12   read console switches
            CALLI ac,-24     SYSDVF    5-7     read system device data
            CALLI ac,+51     SYSPHY    8-31    read physical unit names
            CALLI ac,+46     SYSSTR    8-31    read disk structure names
            CALLI ac,+22     TIMER     18-3    read time in jiffies
            CALLI ac,-42     TINASS    16-5    assign port interrupt causes
            CALLI ac,+44     TMPCOR    2-33    do TMPCOR file i/o
               fn 5          .TCRDD    2-34    clear TMPCOR directory
               fn 2          .TCRDF    2-33    delete TMPCOR file
               fn 0          .TCRFS    2-34    get free space count
               fn 4          .TCRRD    2-34    read TMPCOR directory
               fn 1          .TCRRF    2-33    read TMPCOR file
               fn 3          .TCRWF    2-34    write TMPCOR file
            CALLI ac,+26     TRPJEN    19-5    (obsolete)
            CALLI ac,+25     TRPSET    19-4    Set/Clear User-IOT
            op code 051      TTCALL    10-7    perform cmnd port i/o
            CALLI ac,-56     TYMCHG    20-5    add TRU charges
            op code 073      UGETF     8-32    read disk file position
            op code 074      USETI     8-21    set file position by block
            op code 075      USETO     8-22    set file position by block
            CALLI ac,+13     UTPCLR    19-5    (obsolete)
            CALLI ac,-76     VALPAG    4-12    validate pages
            CALLI ac,-53     VALRMT    19-5    (obsolete) validate 620 password
            CALLI ac,-66     VCLEAR    4-4     unmap pages
            CALLI ac,-67     VCREAT    4-3     create private pages
            CALLI ac,-102    VDSKPT    4-18    read disk pointer
            CALLI ac,-77     VFSTAT    4-17    check private/file page
            CALLI ac,-136    VPEEK     18-10   Virtual/Physical PEEK
            CALLI ac,-103    VPGFIL    4-18    get mapped-file name for page
            CALLI ac,-70     VPROT     4-7     set current protection for pages
            CALLI ac,-65     VREMOV    4-4     unmap pages
            CALLI ac,-64     VREPLC    4-4     replicate virtual pages
            CALLI ac,+10     WAIT      5-7     wait until device inactive
            CALLI ac,-13     WAITCH    10-35   wait for input char
            CALLI ac,+73     WAKE      16-9    wake sleeping frame
            CALLI ac,-74     WSCTL     4-8     do working set functions
               fn 0          .WSRBM    4-9     read working set bits
               fn 4          .WSRLM    4-8     read WSLIM
               fn 5          .WSRMX    4-8     read WSMAX
               fn 1          .WSRNG    4-8     add/remove pages from working set
               fn 3          .WSRSZ    4-8     read WSSIZ
               fn 2          .WSSTL    4-8     set WSLIM
                                                    B-5


      System Calls by Name                     B                          YAMM edition 2.0

      Call             Name      Page    Description
      CALLI ac,-60     XCHARG    20-1    modify charges
         fn 2          .XCRCC    20-2    read current charges
         fn 1          .XCRSC    20-2    read saved charges
         fn 0          .XCSAV    20-1    save charging data
         fn 4          .XCSET    20-2    set charges
         fn 6          .XCTCC    20-3    Write TRU Component Checkpoint
         fn 5          .XCTRN    20-3    write transaction charges
      CALLI ac,-45     ZAPCIR    10-23   zap an aux circuit
      CALLI ac,-50     ZAPRMT    19-5    (obsolete) zap 620 port



























































                                              B-6


            July 3, 1980                             C                    System Calls by Number



                                           ______ _____ __ ______                                           System Calls by Number



            Call             Name      Page    Description

            op code 041      INIT      5-10    Open a Channel
            op code 042      AUXCAL    10-3    perform port i/o functions
               fn 0          .AXI8C    10-32   input char [wait/bka/img]
               fn 1          .AXI8S    10-33   input char [skip/bka/img]
               fn 2          .AXI8B    10-33   input char [wait/img]
               fn 3          .AXO8     10-37   output char [IMG]
               fn 4          .AXO8I    10-37   output char [IMG/IMM]
               fn 5          .AXPTR    10-40   output string [PTR]
               fn 6          .AXCBI    10-29   clear input buffer
               fn 7          .AXCBO    10-29   clear output buffer
               fn 10         .AXSIC    10-34   skip if char
               fn 11         .AXLDE    10-29   leave deferred echo mode
               fn 12         .AXSYB    10-29   send yellow ball
               fn 13         .AXS8B    10-28   set image break char
               fn 14         .AXCRD    10-28   r/s compute-CR-delay bit
               fn 15         .AXIBR    10-28   r/s input baud rate
               fn 16         .AXOBR    10-28   r/s output baud rate
               fn 17         .AXEP     10-28   r/s even-parity bit
               fn 20         .AXHD     10-28   r/s half-duplex bit
               fn 21         .AXPA     10-28   r/s parameter A
               fn 22         .AXPB     10-28   r/s parameter B
               fn 23         .AXPC     10-28   r/s parameter C
               fn 24         .AXHNX    10-28   r/s host-no-XON bit
               fn 25         .AXNTE    10-28   r/s no HT/VT/FF bit
               fn 26         .AXTBK    10-28   r/s tabs-as-breaks bit
               fn 27         .AXWID    10-28   r/s line width
               fn 30         .AXFC1    10-28   r/s filler class 1
               fn 31         .AXFC2    10-28   r/s filler class 2
               fn 32         .AXSFS    10-27   set port file status bits (obsolescent)
               fn 33         .AXSI     10-34   simulate input
               fn 34         .AXEBM    10-41   enter block i/o mode
               fn 35         .AXIBW    10-41   input block and wait
               fn 36         .AXIBS    10-41   input block and skip
               fn 37         .AXOB     10-42   block output
               fn 40         .AXTBI    10-42   terminate block input
               fn 41         .AXTBO    10-42   terminate block output
               fn 42         .AXLBM    10-41   leave block i/o mode
               fn 43         .AXSLV    10-22   slave command port
               fn 44         .AXICW    10-30   input char [wait/bka]
               fn 45         .AXICS    10-31   input char [skip/bka]
               fn 46         .AXIWL    10-31   input char [wait]
               fn 47         .AXISL    10-32   input char [skip]
               fn 50         .AXSIL    10-34   skip if break char
               fn 51         .AXOCI    10-37   output char [IMM]
               fn 52         .AXOST    10-39   output string [STR]
               fn 53         .AXRMX    10-28   r/s remote-XON bit
               fn 54         .AXRBS    10-28   r/s remote-BS-echo bit
               fn 55         .AXRVX    10-28   r/s reverse-XON bit
               fn 56         .AXTYP    10-28   r/s terminal type
               fn 57         .AXBS     10-28   r/s BS-for-char-delete bit
               fn 60         .AXHNG    10-23   send hangup
               fn 61         .AXPSM    10-25   read port-status msg
               fn 62         .AXERA    10-28   r/s Erase-for-char-delete bit
               fn 63         .AXEDE    10-28   r/s force deferred-echo bit
               fn 64         .AXCFS    10-27   change port file status bits
               fn 65         .AXLCO    10-28   r/s Lower-case-output bit
               fn 66         .AXBBP    10-28   r/s backspace break/punctuation bit
               fn 67         .AXOPC    10-40   output string [PTR+count]
               fn 70         .AXSOB    10-29   send orange ball
            op code 043      CHANIO    5-8     do channel i/o functions
               fn 0          .CHREL    5-13    release device
                                                    C-1


      System Calls by Number                   C                          YAMM edition 2.0

      Call             Name      Page    Description
         fn 1          .CHCLS    5-12    close a file
         fn 2          .CHOPT    5-11    output from channel
         fn 3          .CHIPT    5-11    input from channel
         fn 4          .CHLK     8-17    select file for input
         fn 5          .CHENT    8-16    select file for output
         fn 6          .CHUSI    8-21    set file pointer by block
         fn 7          .CHUSO    8-22    set file position by block
         fn 10         .CHUGF    8-32    read disk file position
         fn 11         .CHREN    8-17    rename or delete a file
         fn 12         .CHMTA    11-3    perform magtape functions
         fn 13         .CHOPN    5-10    Open a Channel
         fn 14         .CHIN     5-11    input from channel
         fn 15         .CHOUT    5-11    output from channel
         fn 16         .CHSS     5-13    set file status bits
         fn 17         .CHGS     5-13    read file status bits
         fn 20         .CHSZ     5-14    skip if file status bits clear
         fn 21         .CHSO     5-14    skip if file status bits set
         fn 22         .CHIBF    6-3     create input buffer ring
         fn 23         .CHOBF    6-3     create output buffer ring
         fn 24         .CHSK     8-23    seek to current page
         fn 25         .CHWT     5-7     wait until device inactive
         fn 26         .CHMBF    6-4     move buffers
         fn 27         .CHFSI    8-21    set file pointer by block
         fn 30         .CHFSO    8-22    set file position by block
         fn 31         .CHPSI    8-21    set file pointer by page
         fn 32         .CHPSO    8-22    set file position by page
         fn 33         .CHUFD    8-3     read UFD
         fn 34         .CHMGN    8-26    manipulate update-interlock bit
         fn 35         .CHMFP    4-5     map file pages
         fn 36         .CHDFP    8-24    delete file page
         fn 37         .CHXFP    8-24    exchange file pages
         fn 40         .CHCFP    8-24    create file page
         fn 41         .CHMEN    8-16    select file for multi-update output
         fn 42         .CHVRB    8-32    validate RIB
         fn 43         .CHSMP    4-6     super-map file pages
         fn 44         .CHFFI    8-25    Find First Interesting Page
         fn 45         .CHFTR    8-25    Truncate File
      op code 044      FRMOP     2-16    Frame Operation
         fn 0          .FOJMP    2-22    gate jump to frame
         fn 1          .FOCFM    2-19    create frame
         fn 2          .FORVA    2-20    read frame virtual address
         fn 3          .FOWVA    2-21    write frame virtual address
         fn 4          .FOSAA    2-23    start frame at absolute address
         fn 5          .FOHLT    2-23    halt frame
         fn 6          .FORPC    2-24    Read Frame PC
         fn 7          .FOREP    2-21    VREPLC to/from another frame
         fn 10         .FOVRM    2-21    VREMOV in another frame
         fn 11         .FOVCL    2-21    VCLEAR in another frame
         fn 12         .FOCFH    2-28    Create Handle
         fn 13         .FODFH    2-29    Destroy Handle
         fn 14         .FOCLR    2-24    Clear a Frame
         fn 15         .FORSI    2-30    Read Standard Access Rights Info
         fn 16         .FORAR    2-30    Read Handle Access Rights
         fn 17         .FORER    2-30    Read Handle Effective Rights
         fn 20         .FOSMF    2-31    Set Max Frame Rights
         fn 21         .FOCHR    2-31    Change Handle Rights
         fn 22         .FOSVA    2-24    start frame at vector address
         fn 23         .FOHST    2-25    Read Halt Status Block
         fn 24         .FOGFT    2-20    Graft Frame Subtree
         fn 25         .FOCON    2-27    continue frame
         fn 26         .FOGIN    2-27    Gate-jump Initialization
         fn 27         .FOVCH    2-31    Validate Child Rights
         fn 30         .FOCAR    2-32    Read Child Access Rights
         fn 31         .FOCER    2-32    Read Child Effective Rights
         fn 32         .FOGET    2-21    Setup frame core image from file
         fn 33         .FORUN    2-27    RUN program in frame
         fn 34         .FOSAV    2-22    SAVE frame core image on file
         fn 35         .FOSSA    2-22    SAVE frame core image on SHR file
                                              C-2


            July 3, 1980                             C                    System Calls by Number

            Call             Name      Page    Description
            CALLI ac,-137    SETSTV    2-33    set start vector address
            CALLI ac,-136    VPEEK     18-10   Virtual/Physical PEEK
            CALLI ac,-135    RETACH    10-20   move port from frame to frame
            CALLI ac,-134    EVICT     2-10    Cause Notice to Quit Interrupt
            CALLI ac,-133    PGRSTS    4-14    read/clear REFBIT fault info
            CALLI ac,-132    PGISTS    4-14    read/clear ill mem ref fault info
            CALLI ac,-131    SETABK    19-3    Set/Clear Address Break
            CALLI ac,-130    LOGOFF    2-9     Run Alternate Logout Program
            CALLI ac,-127    SETALP    2-10    Set Alternate Logout Program
            CALLI ac,-126    SETOTF    2-13    set other-frame FD
            CALLI ac,-125    CONT      10-35   Put port in user level
            CALLI ac,-124    PUTROY    20-5    Put Royalty Record in Stream
            CALLI ac,-123    BLTPAG    4-10    change data in page uninterruptibly
            CALLI ac,-122    PIDSET    9-2     Manipulate Process' PID
            CALLI ac,-121    GETPFW    19-5    (obsolete)
            CALLI ac,-120    BITPOK    18-11   read/modify/write in monitor memory
            CALLI ac,-117    RDHIST    19-5    (not available)
            CALLI ac,-116    SNOOP     19-5    (not available)
            CALLI ac,-115    POLPRT    10-24   Poll Ports for Events
            CALLI ac,-114    CLBADD    17-3    Join Club
            CALLI ac,-113    CLBLEV    17-3    Leave a Club
            CALLI ac,-112    CLBINW    17-4    Get Interlock,wait
            CALLI ac,-111    CLBINI    17-4    Get Interlock,No Wait
            CALLI ac,-110    CLBRLI    17-5    Release Club Interlock
            CALLI ac,-107    CLBMEM    17-5    Read Club Member List
            CALLI ac,-106    CLBSTS    17-5    Read Status of Club Member
            CALLI ac,-105    CLBWAK    17-6    Wake Up Club Member
            CALLI ac,-104    CLBHNG    17-6    Hang Club Member
            CALLI ac,-103    VPGFIL    4-18    get mapped-file name for page
            CALLI ac,-102    VDSKPT    4-18    read disk pointer
            CALLI ac,-101    PGFSTS    4-14    read and clear page fault words
            CALLI ac,-100    PGESTS    4-12    read/clear page-error status words
            CALLI ac,-77     VFSTAT    4-17    check private/file page
            CALLI ac,-76     VALPAG    4-12    validate pages
            CALLI ac,-75     PREREF    4-10    prereference a page
            CALLI ac,-74     WSCTL     4-8     do working set functions
               fn 0          .WSRBM    4-9     read working set bits
               fn 1          .WSRNG    4-8     add/remove pages from working set
               fn 2          .WSSTL    4-8     set WSLIM
               fn 3          .WSRSZ    4-8     read WSSIZ
               fn 4          .WSRLM    4-8     read WSLIM
               fn 5          .WSRMX    4-8     read WSMAX
            CALLI ac,-73     REFBIT    4-15    manipulate reference bits
               fn 0          .RFRBM    4-15    Read refbits
               fn 1          .RFSBM    4-15    Set refbits from bitmap
               fn 2          .RFRNG    4-15    set refbits by range
            CALLI ac,-72     PERSET    4-11    set/clear error bit
            CALLI ac,-71     PAGSTS    4-16    read page status word
            CALLI ac,-70     VPROT     4-7     set current protection for pages
            CALLI ac,-67     VCREAT    4-3     create private pages
            CALLI ac,-66     VCLEAR    4-4     unmap pages
            CALLI ac,-65     VREMOV    4-4     unmap pages
            CALLI ac,-64     VREPLC    4-4     replicate virtual pages
            CALLI ac,-63     PUTLSA    20-6    write local stream acctg record
            CALLI ac,-62     PUTSAR    20-6    write stream acctg record
            CALLI ac,-61     CHPRJ     2-8     change project code
            CALLI ac,-60     XCHARG    20-1    modify charges
               fn 0          .XCSAV    20-1    save charging data
               fn 1          .XCRSC    20-2    read saved charges
               fn 2          .XCRCC    20-2    read current charges
               fn 4          .XCSET    20-2    set charges
               fn 5          .XCTRN    20-3    write transaction charges
               fn 6          .XCTCC    20-3    Write TRU Component Checkpoint
            CALLI ac,-57     SETRCF    2-9     set restricted cmnd file
            CALLI ac,-56     TYMCHG    20-5    add TRU charges
            CALLI ac,-55     DATUUO    18-2    do time zone conversions
            CALLI ac,-54     DDT620    19-5    (obsolete) interrogate 620
            CALLI ac,-53     VALRMT    19-5    (obsolete) validate 620 password
                                                    C-3


      System Calls by Number                   C                          YAMM edition 2.0

      Call             Name      Page    Description
      CALLI ac,-52     INTRMT    16-6    (obsolete) assign I/O software interrupts
      CALLI ac,-51     IDLRMT    19-5    (obsolete) set 620 idle
      CALLI ac,-50     ZAPRMT    19-5    (obsolete) zap 620 port
      CALLI ac,-47     CRERMT    19-5    (obsolete) create 620 port
      CALLI ac,-46     AUXRED    10-24   read aux circuit port numbers
      CALLI ac,-45     ZAPCIR    10-23   zap an aux circuit
      CALLI ac,-44     CREAUX    10-21   create an aux circuit
      CALLI ac,-43     REDPIP    16-7    read in-progress bits
      CALLI ac,-42     TINASS    16-5    assign port interrupt causes
      CALLI ac,-41     SETTR2    16-1    set stack over/underflow instruction
      CALLI ac,-40     SETTR1    16-1    set arithmetic overflow instruction
      CALLI ac,-37     SETTIM    16-6    set timer interrupt
      CALLI ac,-36     INTASS    16-6    assign general interrupt causes
      CALLI ac,-35     INTACT    16-7    cause and uncause interrupts
      CALLI ac,-34     INTENB    16-7    enable and disable INTADR channels
      CALLI ac,-33     INTADR    16-5    initialize INTADR system
      CALLI ac,-32     HANG      2-10    hang a port or frame or frames
      CALLI ac,-31     CHKLIC    2-4     check settable license
      CALLI ac,-30     LEVDEF    10-29   leave deferred echo mode
      CALLI ac,-27     MOVBUF    6-4     move buffers
      CALLI ac,-26     SETMOD    10-26   set cmnd port file status
      CALLI ac,-25     RUNSEG    3-10    load and run a high segment
      CALLI ac,-24     SYSDVF    5-7     read system device data
      CALLI ac,-23     DISMIS    16-8    dismiss INTADR interrupts
      CALLI ac,-22     DSKCLR    8-32    initialize in-core file system data
      CALLI ac,-21     SETJAL    2-6     set frame status bits
      CALLI ac,-20     ONEJOB    19-3    skip if only frame and super-shut
      CALLI ac,-17     SETMAL    2-3     set mail-waiting bit
      CALLI ac,-16     GETTMC    10-26   (obs.) get terminal characteristics
      CALLI ac,-15     SETTMC    10-26   (obsolete) no-op
      CALLI ac,-14     REDNXT    10-35   peek at input
      CALLI ac,-13     WAITCH    10-35   wait for input char
      CALLI ac,-12     POKE      18-11   write in monitor core
      CALLI ac,-11     SETPRV    2-2     set frame privilege word
      CALLI ac,-10     SETLIC    2-5     set process license
      CALLI ac,-7      SETE      2-5     set frame license
      CALLI ac,-6      ATTACH    10-20   attach command port to frame
      CALLI ac,-5      CALIM5    19-5    (obsolete)
      CALLI ac,-4      CALIM4    19-5    (obsolete)
      CALLI ac,-3      CALIM3    19-5    (obsolete)
      CALLI ac,-2      CALIM2    19-5    (obsolete)
      CALLI ac,-1      LIGHTS    18-12   display word in console lights
      CALLI ac,+0      RESET     5-12    initialize frame state
      CALLI ac,+1      DDTIN     10-35   DDT-mode input
      CALLI ac,+2      SETDDT    3-3     set DDT start address
      CALLI ac,+3      DDTOUT    10-40   DDT-mode output
      CALLI ac,+4      DEVCHR    5-6     read device characteristics word
      CALLI ac,+5      DDTGT     19-5    (obsolete) Get DDT mode
      CALLI ac,+6      GETCHR    5-6     read device characteristics word
      CALLI ac,+7      DDTRL     19-5    (obsolete) Release DDT mode
      CALLI ac,+10     WAIT      5-7     wait until device inactive
      CALLI ac,+11     CORE      3-1     allocate or free core
      CALLI ac,+12     EXIT      2-32    stop frame execution
      CALLI ac,+13     UTPCLR    19-5    (obsolete)
      CALLI ac,+14     DATE      18-1    read date
      CALLI ac,+15     LOGIN     2-7     log a frame in
      CALLI ac,+16     APRENB    16-2    enable APRENB trapping
      CALLI ac,+17     LOGOUT    2-9     log a frame out
      CALLI ac,+20     SWITCH    18-12   read console switches
      CALLI ac,+21     REASSI    5-6     reassign i/o device
      CALLI ac,+22     TIMER     18-3    read time in jiffies
      CALLI ac,+23     MSTIME    18-3    read time in ms
      CALLI ac,+24     GETPPN    2-2     get frame PPN
      CALLI ac,+25     TRPSET    19-4    Set/Clear User-IOT
      CALLI ac,+26     TRPJEN    19-5    (obsolete)
      CALLI ac,+27     RUNTIM    18-3    get TRUs
      CALLI ac,+30     PJOB      2-2     get frame number
      CALLI ac,+31     SLEEP     16-9    wait for N seconds
                                              C-4


            July 3, 1980                             C                    System Calls by Number

            Call             Name      Page    Description
            CALLI ac,+32     SETPOV    19-5    (obsolete) Set PDL OV trap
            CALLI ac,+33     PEEK      18-11   (obsolete) read monitor core
            CALLI ac,+34     GETLIN    10-20   get command port name
            CALLI ac,+35     RUN       3-7     load and run a program
            CALLI ac,+36     SETUWP    3-2     set highseg write protection
            CALLI ac,+37     REMAP     3-2     move top of lowseg to highseg
            CALLI ac,+40     GETSEG    3-6     load a high segment
            CALLI ac,+41     GETTAB    18-3    read monitor tables
            CALLI ac,+42     SPYUUO    19-5    (obsolete)
            CALLI ac,+43     SETNAM    2-2     set frame name
            CALLI ac,+44     TMPCOR    2-33    do TMPCOR file i/o
               fn 0          .TCRFS    2-34    get free space count
               fn 1          .TCRRF    2-33    read TMPCOR file
               fn 2          .TCRDF    2-33    delete TMPCOR file
               fn 3          .TCRWF    2-34    write TMPCOR file
               fn 4          .TCRRD    2-34    read TMPCOR directory
               fn 5          .TCRDD    2-34    clear TMPCOR directory
            CALLI ac,+45     DSKCHR    8-27    read disk characteristics
            CALLI ac,+46     SYSSTR    8-31    read disk structure names
            CALLI ac,+47     JOBSTR    8-30    Return frames next file structure
            CALLI ac,+50     STRUUO    8-30    Manipulate file structures
            CALLI ac,+51     SYSPHY    8-31    read physical unit names
            CALLI ac,+54     DEVSTS    5-6     read device hardware status
            CALLI ac,+55     DEVPPN    5-6     read PPN
            CALLI ac,+56     SEEK      8-23    seek to current page
            CALLI ac,+64     DEVNAM    5-6     read device physical name
            CALLI ac,+66     GOBSTR    8-29    Get system search list
            CALLI ac,+72     HIBER     16-8    wait for event
            CALLI ac,+73     WAKE      16-9    wake sleeping frame
            CALLI ac,+74     CHGPPN    2-2     change frame PPN
            CALLI ac,+75     SETUUO    19-1    do SET command functions
               fn 0          .STTYO    19-1    OUTSTR to OPR terminal
               fn 1          .STSTA    19-1    set STATES
               fn 2          .STFAR    19-1    finish auto-restart
               fn 3          .STTIM    19-1    set time
               fn 4          .STDAT    19-2    set date
               fn 6          .STWAT    2-8     set WATCH bits
               fn 11         .STBST    19-2    Set/Read BOOTS command string
               fn 12         .STRES    19-2    Read/Set RESTART bits
            CALLI ac,+101    DEVSIZ    6-3     read standard buffer size
            op code 050      OPEN      5-10    Open a Channel
            op code 051      TTCALL    10-7    perform cmnd port i/o
            TTCALL 0,e       INCHRW    10-30   input char [wait/bka]
            TTCALL 1,e       OUTCHR    10-36   output char [CMD]
            TTCALL 2,e       INCHRS    10-31   input char [skip/bka]
            TTCALL 3,e       OUTSTR    10-38   output string [STR/CMD]
            TTCALL 4,e       INCHWL    10-31   input char [wait]
            TTCALL 5,e       INCHSL    10-32   input char [skip]
            TTCALL 6,e       GETLCH    10-25   read line characteristics
            TTCALL 7,e       SETLCH    10-26   set line characteristics
            TTCALL 10,e      RESCAN    10-35   rescan command line
            TTCALL 11,e      CLRBFI    10-29   clear input buffer
            TTCALL 12,e      CLRBFO    10-29   clear output buffer
            TTCALL 13,e      SKPINC    10-34   skip if char
            TTCALL 14,e      SKPINL    10-34   skip if break char
            TTCALL 15,e      IONEOU    10-37   output char [CMD/IMG]
            TTCALL 16,e      OUTCHI    10-36   output char [CMD/IMM]
            TTCALL 17,e      OUTPTR    10-39   output string [PTR/CMD]
            op code 055      RENAME    8-17    rename or delete a file
            op code 056      IN        5-11    input from channel
            op code 057      OUT       5-11    output from channel
            op code 060      SETSTS    5-13    set file status bits
            op code 061      STATO     5-14    skip if file status bits set
            op code 062      GETSTS    5-13    read file status bits
            op code 063      STATZ     5-14    skip if file status bits clear
            op code 064      INBUF     6-3     create input buffer ring
            op code 065      OUTBUF    6-3     create output buffer ring
            op code 066      INPUT     5-11    input from channel
                                                    C-5


      System Calls by Number                   C                          YAMM edition 2.0

      Call             Name      Page    Description
      op code 067      OUTPUT    5-11    output from channel
      op code 070      CLOSE     5-12    close a file
      op code 071      RELEAS    5-13    release device
      op code 072      MTAPE     11-3    perform magtape functions
      op code 073      UGETF     8-32    read disk file position
      op code 074      USETI     8-21    set file position by block
      op code 075      USETO     8-22    set file position by block
      op code 076      LOOKUP    8-17    select file for input
      op code 077      ENTER     8-16    select file for output



























































                                              C-6


            July 3, 1980                             D                                     Index


            .AXBBP  10-11,10-28#                        .CHIPT  5-11#,6-4,7-1
                                                   Index                                                   _____            .AXBS  10-14,10-28#                         .CHLK  8-17#
            .AXCBI  10-8,10-29#                         .CHMBF  6-3,6-4#
            .AXCBO  10-8,10-19,10-29#                   .CHMEN  8-9,8-16#
            .AXCFS  10-27#                              .CHMFP  2-13,4-5,4-5#,8-23
            .AXCRD  10-15,10-28#                        .CHMGN  8-25,8-26#
            .AXEBM  10-19,10-41#                        .CHMTA  11-3#
            .AXEDE  10-12,10-28#                        .CHOBF  6-3,6-3#
            .AXEP  10-17,10-28#                         .CHOPN  5-1,5-10#
            .AXERA  10-28#                              .CHOPT  5-11#,6-5,7-1
            .AXFC1  10-16,10-28#                        .CHOUT  5-11#,6-5,7-1
            .AXFC2  10-16,10-28#                        .CHPSI  8-21#
            .AXHD  10-12,10-28#                         .CHPSO  8-22#
            .AXHNG  10-23#                              .CHREL  5-3,5-13#
            .AXHNX  10-8,10-28#                         .CHREN  8-17#
            .AXI8B  10-33#                              .CHSK  8-23#
            .AXI8C  10-32#                              .CHSMP  4-6,4-6#,8-21
            .AXI8S  10-33#                              .CHSO  5-4,5-14#
            .AXIBR  10-7,10-28#                         .CHSS  5-4,5-13#
            .AXIBS  10-19,10-41#                        .CHSZ  5-4,5-14#
            .AXIBW  10-19,10-41#                        .CHUFD  8-3,8-3#,8-5,8-13,8-14
            .AXICS  10-30,10-31#                        .CHUGF  8-32#
            .AXICW  10-10,10-30,10-30#                  .CHUSI  8-21#
            .AXISL  10-10,10-30,10-32#                  .CHUSO  8-22#
            .AXIWL  10-10,10-30,10-31#                  .CHVRB  4-12,8-32#
            .AXLBM  10-19,10-41#                        .CHWT  5-5,5-7#
            .AXLCO  10-14,10-28#                        .CHXFP  8-24#
            .AXLDE  10-14,10-29#                        .FOCAR  2-16,2-32#
            .AXNTE  10-15,10-28#                        .FOCER  2-16,2-32#
            .AXO8  10-36,10-37#                         .FOCFH  2-13,2-14,2-28#,2-29
            .AXO8I  10-36,10-37#                        .FOCFM  2-2,2-19#
            .AXOB  10-19,10-42#                         .FOCFM error codes  2-20
            .AXOBR  10-7,10-28#                         .FOCHR  2-31#
            .AXOCI  10-36,10-37#                        .FOCLR  2-24#
            .AXOPC  10-39,10-40#                        .FOCON  2-27#,2-27
            .AXOST  10-17,10-39,10-39#                  .FODFH  2-29#
            .AXPA  10-15,10-28#                         .FOGET  2-21#,3-6,3-11
            .AXPB  10-15,10-28#                         .FOGFT  2-20#
            .AXPC  10-16,10-28#                         .FOGIN  2-23,2-27#
            .AXPSM  10-25#                              .FOHLT  2-23#
            .AXPTR  10-39,10-40#,10-40                  .FOHST  2-25#
            .AXRBS  10-14,10-28#                        .FOJMP  2-22#,2-27
            .AXRMX  10-8,10-28#                         .FORAR  2-16,2-30#,2-32
            .AXRVX  10-8,10-28#                         .FOREP  2-13,2-21#
            .AXS8B  10-12,10-28#                        .FORER  2-16,2-30,2-30#
            .AXSFS  10-3,10-27#                         .FORPC  2-24#,2-27
            .AXSI  10-33,10-34#                         .FORSI  2-30#,2-30
            .AXSIC  10-10,10-34#                        .FORSI Item Numbers  2-30
            .AXSIL  10-34#                              .FORUN  2-27#,3-6,3-11
            .AXSLV  10-2,10-22#                         .FORVA  2-20#
            .AXSOB  10-13,10-29#,16-4                   .FOSAA  2-23#,2-27
            .AXSYB  10-13,10-29#                        .FOSAV  2-22#,3-6
            .AXTBI  10-19,10-42#                        .FOSMF  2-14,2-31,2-31#
            .AXTBK  10-11,10-28#                        .FOSSA  2-22#,3-6
            .AXTBO  10-19,10-42#                        .FOSVA  2-15,2-24#,2-33
            .AXTYP  10-28#                              .FOVCH  2-31#,2-32
            .AXWID  10-15,10-28#                        .FOVCL  2-21#
            .CHCFP  8-24#                               .FOVRM  2-21#
            .CHCLS  5-2,5-12#                           .FOWVA  2-21#
            .CHDFP  8-24#                               .RFRBM  4-15#
            .CHENT  8-16#                               .RFRNG  4-15#
            .CHFFI  8-25,8-25#                          .RFSBM  4-15#
            .CHFSI  8-21#                               .STBST  19-2#
            .CHFSO  8-22#                               .STDAT  19-2#
            .CHFTR  8-24,8-25,8-25#                     .STFAR  19-1#
            .CHGS  5-4,5-13#                            .STRES  19-2#
            .CHIBF  6-3,6-3#                            .STSTA  19-1#
            .CHIN  5-11#,6-4,7-1                        .STTIM  19-1#
                                                    D-1


      Index                                    D                          YAMM edition 2.0


      .STTYO  19-1#                               Attaching  10-1#,10-1
      .STWAT  2-8#                                AUN  2-1
      .TCRDD  2-34#                               Authority Conferred by a PID  9-2#
      .TCRDF  2-33#                               AUXCAL  10-3,10-3#,10-4,10-6
      .TCRFS  2-34#                               AUXCALs by function  10-4
      .TCRRD  2-34#                               AUXCALs by number  10-6
      .TCRRF  2-33#                               Auxiliary Ports  10-2#
      .TCRWF  2-34#                               AUXRED  10-2,10-24#
      .WSRBM  4-9#
      .WSRLM  4-8#
      .WSRMX  4-8#                                backpressure  10-8
      .WSRNG  4-8#                                Backspace  10-14#
      .WSRSZ  4-8#                                backspace break/punctuation bit  10-10
      .WSSTL  4-8#                                backspace-for-character-delete  10-14
      .XCRCC  20-2#,20-4                          balls (messages) in Tymnet  10-13
      .XCRSC  20-2#                               baud rate  10-7
      .XCSAV  20-1#,20-4                          Baud Rates  10-7#
      .XCSET  20-2#,20-4                          Begin and End of Tape Bits  11-2#
      .XCTCC  20-3#,20-5                          Binary Mode I/O  14-2#
      .XCTRN  20-3#                               Binary Mode Input  12-1#
                                                  BITPOK  18-10,18-11#
                                                  BLISS  1-1
      .GTCNF (GETTAB +11) Items  18-7             Block I/O  10-18#
      .GTLOG Bits (GETTAB -24)  18-7              Block I/O Buffer Format  10-18#
      .GTLVD (GETTAB 16) Items  18-8              Block I/O Data Modes  10-18#
      .GTNSW Items (GETTAB 12)  18-9              Block I/O Tutorial  10-19#
      .GTODP(GETTAB +15) items (ONCDSK            block IO  10-18
         parameters)  18-9                        BLTPAG  4-10,4-10#
      .GTWSC(GETTAB +25) items (Wait State        BLTPAG error codes  4-11
         Codes)  18-10                            BOT  11-2
      .JBCOR  3-3                                 Break Characters  10-10#,10-10
      .XCSET Error Codes  20-3                    Breaks  10-11#
                                                  Buffer Format  6-2#
                                                  buffer ring  6-2
      026 Card Codes  12-2                        Buffer Ring Headers  6-1#
      029 Card Codes  12-2                        Buffer Setup  6-2#,6-2
                                                  Buffered I/O  8-2#,10-7#
                                                  Buffered I/O Errors  6-6#
      Abbreviations  1-1#,8-2#                    Buffered I/O Operations  6-4#
      absolute FD  2-12,2-12#                     buffered I/O use bit  6-1
      Absolute Frame Number  2-1                  buffered input  6-4
      Access Rights  2-14#                        Buffered Input Calls  6-4#
      Access Rights Definitions  2-15             Buffered Mode I/O  6-1#
      Account User Numbers (AUN,PPN,FPN)  2-1#    buffered output  6-4
      Accounting  20-1#                           Buffered Output Calls  6-5#
      Accounting Device Control Functions         Buffered Tape I/O  11-2#
         19-4#                                    Buffering and Backpressure  10-8#
      Acknowledgements  1-2#
      ACT:  20-7
      Actual Word/Byte Counts  11-3#              CALIM2  19-5#
      Addressing Monitor Memory  18-10#           CALIM3  19-5#
      Alternate Logout Program  2-9#              CALIM4  19-5#
      APRENB  16-2#                               CALIM5  19-5#
      APRENB Interrupt Bit Definitions  16-3      card reader  12-1
      APRENB Interrupt System  16-1#              Card Reader Input  12-1#
      APRENB interrupts  16-1                     Case Mapping  10-9#,10-9
      APRENB/INTADR Interaction  16-9#            CDR  12-1
      AR  2-14                                    CDR: File Status Bits  12-3,14-2
      Argument Blocks  8-9#                       Change Project-Code Record words 5-7
      Argument Codes  8-10                           20-8
      arithmetic overflow  16-1                   Changing Page Protection  4-7#
      ASCII Mode I/O  14-1#                       CHANIO  5-2,5-8#,5-9,5-10
      ASCII Mode Input  12-1#                     CHANIOs by function  5-9
      ASSIGN command  5-1                         CHANIOs by number  5-10
      assigned by console  5-1                    channel  5-1
      assigned by program  5-1                    Channel Numbers  5-2#,5-2
      Assigning Causes to Channels  16-4#         Channels & I/O Initialization  5-1#
      ATTACH  10-1,10-20#                         Character Handling  10-9#
                                              D-2


            July 3, 1980                             D                                     Index


            character-delete character  10-9            DDTOUT  10-17,10-40#
            CHGPPN  2-1,2-2#                            DDTRL  19-5#
            child-to-parent handle  2-32                DEASSIGN command  5-1
            children  2-11                              DEC date format  18-1
            CHKLIC  2-4#                                deferred echo  10-12
            CHPRJ  2-8,2-8#,8-15                        Definition  17-1#
            CLBADD  17-2,17-3#                          Definition of PID  9-1#
            CLBHNG  17-3,17-6#                          delay  10-15
            CLBINI  17-2,17-4#                          delete  8-8
            CLBINW  17-2,17-4#,17-4                     delete file pages  8-23
            CLBLEV  17-2,17-3#                          Deleted Characters  10-14#
            CLBMEM  17-3,17-5#                          density  11-1
            CLBRLI  17-2,17-5#                          Detaching  10-1#,10-1
            CLBSTS  17-3,17-5#                          DEVCHR  5-4,5-6#
            CLBWAK  17-3,17-6#                          Device Assignment  5-1#
            CLOSE  5-2,5-12#,8-19                       Device Availability  5-1#
            Closing a Disk File  8-19#                  Device Characteristics  5-4#
            Closing channels  5-2#                      Device Characteristics Word  5-5
            CLRBFI  10-8,10-29#                         device data block  5-1
            CLRBFO  10-8,10-29#                         device descriptor  5-5
            Club Facility  17-1#                        Device Manipulation  5-5#
            Club Facility Standard Error Codes  17-7    Device Names  5-2#,8-1#,11-1#
            Club ID numbers  17-1#                      DEVNAM  5-6#
            Club Interlock  17-1#                       DEVPPN  5-6#
            Club Interlock Status Flags  17-4           DEVSIZ  6-2,6-3#
            Club UUOs  17-3#                            DEVSTS  5-6#
            Club, definition of  17-1                   Digital Equipment Corp.  1-1
            COBOL  1-1                                  Direct File Page Manipulation  8-23#
            colored balls  10-13                        Direct Interaction with other club
            Command Level  10-1                            members  17-3#
            command port  10-1                          Directories  8-2#
            Command Ports  10-1#                        directory  8-2
            Command versus User Level  10-1#            Directory Access Protection  8-7#
            CONT  10-34,10-35#                          directory protection  8-7
            controlling TTY  10-1                       Directory Protection Bits  8-8
            Conventions  1-1#                           disconnect options  2-3
            copy-on-write page  4-2                     Disk Characteristics  8-27#
            CORE  3-1,3-1#,4-1,4-3                      disk directory  8-2
            Core image files  3-5#                      Disk Files with PIDs  8-7#
            COW page  4-2                               Disk I/O  8-1#
            CR and LF delay  10-15#                     Disk Retrieval Pointers  4-18#
            CR delay  10-15                             disk structure  8-1
            CR Delay Formula  10-16#                    Disk Unit/Structure Names  8-29#
            create  8-8                                 DISMIS  16-2,16-3,16-8#
            create file pages  8-23                     DSK: File Status Bits  8-33
            Created Handle  2-14#                       DSKCHR  8-27#,8-28
            created handle index  2-28                  DSKCHR Data Block  8-28
            Creating  10-2#                             DSKCHR Status Bits  8-29
            Creating Private Pages  4-3#                DSKCLR  8-32#
            CREAUX  10-2,10-21#                         Dump I/O  8-2#
            CREAUX Error Codes  10-23                   Dump I/O Errors  7-2#
            CRERMT  19-5#                               Dump I/O Operations  7-1#
            Current List  19-5#                         Dump Input Calls  7-1#
            current page protection  4-2                Dump Mode I/O  7-1#,7-1
                                                        Dump Output Calls  7-2#
                                                        Dump Tape I/O  11-2#
            Data Modes  5-3#,5-4
            Data Transmission Methods  10-8#
            Data Transmission Modes  10-17#             echo  10-12
            DATE  18-1#                                 Echo,Break,Backpressure UUOs  10-28#
            Date Change Record words 0-5  20-9          Echoing  10-12#
            date format  18-1                           Effective Rights  2-16
            Dates and Times  18-1#                      End Of File  10-10#
            DATUUO  18-2#                               EndPoint  11-2
            DDB  5-1                                    ENTER  8-9,8-16#
            DDT620  19-5#                               Environmental Information  18-1#
            DDTGT  19-5#                                EOT  11-2
            DDTIN  10-10,10-17,10-34,10-35#             Escape  10-14#
                                                    D-3


      Index                                    D                          YAMM edition 2.0


      Escape Character  10-9#,10-9                GAN  2-1
      even-parity  10-17                          gate jumps  2-22,2-27
      EVICT  2-10#                                General I/O  5-1#
      exchange file pages  8-23                   General Interrupt Cause Codes  16-4
      Execute-Only Programs  3-11#                GET operation  3-5
      Executing IO instructions (User-IOT)        GETCHR  5-4,5-6#
         19-4#                                    GETLCH  10-3,10-25#
      Executing with a PID  9-2#                  GETLIN  10-20#
      executive program  2-11                     GETPFW  19-5#
      EXIT  2-32#                                 GETPPN  2-2#
      Extended Lookup Block  8-12                 GETSEG  2-22,3-1,3-6#
                                                  GETSTS  5-4,5-13#
                                                  GETTAB  18-3,18-3#
      F-bit  8-5                                  GETTAB tables and functions  18-3#
      Faking Input  10-33#                        GETTAB tables by function  18-4
      Faking Input Wait  10-14#                   GETTAB tables by number  18-6
      Family FD's  2-13#                          Getting an Interlock  17-2#
      FF filler class  10-16                      GETTMC  10-26#
      File Access Protection  8-6#                Global Account Number  2-1
      File Access State Transition Rules  8-9     GOBSTR  8-29#
      file license  2-4,8-20                      GOBSTR error codes  8-30
      File Organization  8-5#,8-5                 graphics  15-1
      file owner  8-6                             green ball  10-12
      file page  4-1                              green balls  10-13
      file page manipulation  8-23
      file pointer  8-20
      file position  8-20                         Half-Duplex  10-12#,10-12
      File Positioning  8-20#                     Halt Status Classes & Types  2-26
      file protection  8-6                        handle access rights  2-16
      File Protection Codes  8-7                  handle effective rights  2-16
      File Selection  8-8#,8-8                    Handle Rights vs. Effective Rights
      File Selection Error Codes  8-18#,8-19         2-16#
      File State Transitions  8-9#                Handles  2-13#
      File Status Bits  5-3#,5-3,10-3#            HANG  2-10#
      file system  8-1                            Hardware Action  15-1#
      filler class 1  10-16                       Hardware Paging  4-1#
      filler class 2  10-16                       HDX  10-12
      first class Club member  17-1               HGH file  3-5
      Flushing  8-32                              HIBER  10-13,16-8#
      Flushing Input  10-8#                       High and Low Segments  3-1#
      Flushing Output  10-8#                      high segment  3-1
      forced command  10-21                       Host No XON  10-8#
      Form Feeds  13-1#,13-1                      HT Filler Cclass  10-16#
      FORTRAN  1-1                                HT filler class  10-16
      FPN  2-1                                    HT, VT, FF delays  10-16#
      Frame Descriptor Format  2-12               HT, VT, FF simulation  10-15#
      frame descriptor types  2-12
      Frame Descriptors  2-12#
      Frame Generation and Control Operations     I/O synchronization  6-6#
         2-11#                                    IDLRMT  19-5#
      Frame handle  2-12                          ILL MEM REF  4-11
      Frame Identification  2-1#                  Illegal Memory Reference  4-11#,4-11
      Frame License  2-4#                         Image Binary Mode I/O  14-1#
      Frame License Bits  2-5                     Image Break Character  10-12#,10-12
      Frame Privilege Word  2-3                   Image Characters  10-15#
      Frame Search List  8-5#,8-5                 image mode  10-11
      Frame Status  2-6#                          Image Mode I/O  14-1#
      Frame Status Word  2-7                      Image Mode Input  12-1#
      frame tree  2-11                            image output  10-15
      Frames and Processes  2-1#                  Image State  10-11#,10-32#
      FRMOP  2-11,2-16#,2-19                      IN  5-11#,6-4,7-1
      FRMOP calls by function  2-18               inactive  5-5
      FRMOP functions by number  2-19             INBUF  6-3,6-3#
      FRMOP standard error codes  2-17            INCHRS  10-10,10-30,10-31#
      FTA:  11-1                                  INCHRW  10-10,10-30#,10-30
      FTA: File Status Bits  11-5                 INCHSL  10-10,10-30,10-32#
      full-character-set mode  10-9               INCHWL  10-10,10-30,10-31#
                                                  incremental plotter  15-1
                                              D-4


            July 3, 1980                             D                                     Index


            INIT  5-1,5-10#                             LOGINN  2-2
            Initial Conditions  6-3#                    LOGINN Record words 3-6  20-10
            Initializing the INTADR System  16-3#       LOGOFF  2-9#,2-10
            INPUT  5-11#,6-4,7-1,10-9#,10-10            LOGOUT  2-9#
            Inquiring about Ports and their Statuses    LOGOUT and CHKPNT stream record format
               10-2#                                       20-11
            INTACT  16-7#                               lookup  8-8,8-9,8-17#
            INTADR  16-3,16-5#                          LOW file  3-5
            INTADR Interrupt System  16-3#              low segment  3-1
            INTADR interrupts  16-3                     Low Segment Job Data Area  3-3#
            INTASS  16-4,16-6#,16-8                     LPT forms control  13-1
            INTENB  16-3,16-7#                          LPT:  13-1
            Interaction with Non-Block Input  10-19#
            Interaction with Non-Block Output
               10-19#                                   M-bit  8-5
            Interrupt System and Sleeping  16-1#        magnetic tape  11-1
            INTRMT  16-6#,19-4                          Magnetic Tape I/O  11-1#
            INTRMT error codes  16-7                    mail-waiting bit  2-3
            IO instructions  19-4                       Major I/O UUOs  5-8#
            IONEOU  10-36,10-37#                        Manipulating the PID  9-2#
            IOT  19-4                                   map  4-1
            Issuing PID's  9-1#                         map file pages  8-23
                                                        Mapping Absolute Disk Pages  4-6#
                                                        Mapping File Pages  4-5#
            JIS-8  8-14,10-17                           Master File Directory  8-3#,8-3
            job  2-1                                    maximally-writable page  4-2
            Job Data Area  3-3#                         Maximum Frame Rights  2-14#
            Job Data Area Locations  3-4                Memory manipulation FRMOPs  2-20#
            JOBDAT.REL  3-3                             MFD  8-3
            JOBSTR  8-30#,8-30                          MFR  2-14
            Joining a Club  17-2#                       Miscellaneous Command Port UUOs  10-34#
                                                        Miscellaneous Operations  19-1#
                                                        Monitor Modes  10-10#,10-10
            Katakana  8-14                              Monitor Modes & Special Characters
            Katakana Data Mode  10-17#,10-17               10-27
            KS2020 Line Printer Forms Control  13-1#    monitor working set  4-2
                                                        monitor working set control  4-7
                                                        Monitor-Constructed Buffer Rings  6-3#
            Leaders and Trailers  14-1#                 MOVBUF  6-3,6-4#
            Leaving a Club  17-2#                       MSTIME  18-3#
            LEVDEF  10-14,10-29#                        MTA:  11-1
            LF delay  10-15                             MTAPE  11-1,11-2,11-3,11-3#,13-1,19-4
            LF Delay Formula  10-16#                    MTAPE Functions  11-4
            license  2-4,8-6#,8-7#,8-20                 MTAPE Operations  11-3#
            License Bit Definitions  2-5
            License-Setting RUN Record words 0-2
               20-9                                     No Echo  10-13#
            licensed handle  2-12                       no-free-CR bit  10-15
            LIGHTS  18-11,18-12#                        no-HT/VT/FF bit  10-15
            Lights and Switches  18-11#                 Non-Integral Word Counts  11-2#
            Line Characteristic Word  10-3#             nonexistent page  4-1
            Line Characteristics Word  10-26            notice to quit  2-10
            Line Editing  10-9#,10-9
            line printer  13-1
            Line Printer Output  13-1#                  Obsolete and Unavailable Functions
            Line Width and Position  10-15#                19-5#
            line-delete character  10-9                 ONEJOB  19-3#
            LoadPoint  11-2                             OPEN  5-1,5-10#
            Local Copy  10-13#                          Operator Functions  19-1#
            local echo  10-12                           orange balls  10-13
            Local Stream Accounting Record words 5-7    Other Frame FD  2-13#
               20-9                                     OUT  5-11#,6-5,7-1
            logging out  2-9                            OUTBUF  6-3,6-3#
            logical name  5-2                           OUTCHI  10-36,10-36#
            Logical Names  5-2#                         OUTCHR  10-36#,10-36
            logical page table  4-1                     OUTPTR  10-39,10-39#
            Logical Unit Names  8-1#,8-1                OUTPUT  5-11#,6-5,7-1,10-14#,13-1#,15-1#
            LOGIN  2-1,2-2,2-7#                         Output Case Mapping  10-14#
                                                    D-5


      Index                                    D                          YAMM edition 2.0


      Output Suppression  10-10#                  Port Event-Status Bits  10-25
      Output UUOs  10-36#                         Port I/O  10-1#
      OUTSTR  10-17,10-38#,10-39                  port image break character  10-12
                                                  port image mode  10-11
                                                  port image output  10-15
      page 0  3-3                                 port input  10-29
      page breaks  13-1                           Port Input UUOs  10-29#
      Page Errors  4-11#                          Port Interrupt Cause Codes  16-4
      Page Fault Word  4-13#,4-14                 port numbers  10-1
      Page Faults  4-13#                          Port Numbers and Device Names  10-1#
      page protection  4-2                        Port Operations  10-3#
      Page Protection Codes  4-3                  port output  10-36
      Page Reference Bits  4-15#,4-15             port parity  10-17
      Page Status Word  4-16#                     port speeds  10-7
      Page Status Word Format  4-17               Port String Output Calls  10-39
      Page Types  4-1#                            ports  10-1
      Page-error Status-word  4-12                Preface  1-1#
      Paging  4-1#,4-1                            PREREF  2-13,4-9,4-10#
      paging errors  4-11                         PREREF Error Codes  4-10
      Paging Related Errors  4-11#                Prereferencing Pages  4-9#
      PAGSTS  2-13,4-11,4-16,4-16#,4-17           prime RIB  8-5
      PAGSTS Error Code  4-17                     printer  13-1
      paper tape  14-1                            private page  4-1
      Paper Tape I/O  14-1#                       Privilege  2-2#
      Paper Tape Mode  10-17#                     process handle  2-12
      parameter A  10-15                          process license  2-4
      parameter B  10-15                          process name  2-1
      parameter C  10-15                          Processor ID Mechanism  9-1#
      Parity  10-17#,10-17,11-1#,11-1             program formats  3-5
      PDL OV  16-1                                project code verify bit  2-8
      PEEK  18-10,18-11#                          Project Codes  2-8#
      pen movements  15-1                         Protection  4-2#,8-6
      Per Frame Program Number  2-11#             punched cards  12-1
      PERSET  4-11,4-11#                          punched tape  14-1
      PERSET Error Codes  4-12                    Purpose  17-1#
      PGESTS  4-12,4-12#                          Purpose of PID's  9-1#
      PGFSTS  4-14#                               PUTLSA  20-6,20-6#,20-7
      PGISTS  4-14#                               PUTROY  20-5,20-5#
      PGRSTS  4-14#                               PUTSAR  20-6,20-6#,20-7
      PGRSTS and PGISTS word formats  4-14        PUTSAR error codes  20-7
      physical address  4-1
      Physical Unit Names  8-2#,8-2
      PID Handling on ENTER and RENAME  9-3#      RDHIST  19-5#
      PID's and Storage Accounting  9-3#          read-only page  4-2
      PIDSET  9-2,9-2#                            Reading a Directory  8-3#
      PJOB  2-2#                                  Reading Current Charges  20-4#
      plot operations  15-1                       Reading Information  8-26#
      plotter  15-1                               Reading Standard Buffer Size  6-2#
      Plotter command bits  15-1                  Reading, Testing and Setting  5-4#
      Plotter Output  15-1#                       REASSI  5-1,5-5,5-6#
      PLT: File Status Bits  15-2                 REASSIGN command  5-1
      PNO  2-11                                   Reassigning Devices  5-5#
      POKE  18-10,18-11#                          Recording Density  11-1#
      POLPRT  10-2,10-24#                         Recording Modes  11-1#,11-1
      Port and Terminal Characteristics UUOs      red ball  10-12
         10-25#                                   REDNXT  10-34,10-35#
      Port Block I/O UUOs  10-41#                 REDPIP  16-7#
      port break characters  10-10                REFBIT  4-15,4-15#
      Port Buffered-I/O Modes  10-18#             REFBIT Error Codes  4-16
      port buffering  10-8                        reference bits  4-15
      port case mapping  10-9                     RELEAS  5-3,5-12,5-13#
      Port Character Input Calls  10-30           Releasing an Interlock  17-2#
      Port Character Output Calls  10-36          Releasing Channels  5-3#
      Port Creation,Moving,Deletion UUOs          REMAP  3-2#
         10-19#                                   remote backspace echo  10-14
      port device names  10-1                     remote echo  10-12
      port echoing  10-12                         Remote XON  10-8#
      port escape characcter  10-9                rename  8-8,8-9,8-17#
                                              D-6


            July 3, 1980                             D                                     Index


            Replicating Virtual Pages  4-4#             Short Lookup Block  8-11
            RESCAN  10-34,10-35#                        SHR file  3-5
            RESET  2-33,5-3,5-12#,10-21                 Single Character Output  10-36#
            Reseting Ports  10-2#                       SKPINC  10-34#
            Restart Record words 0-1  20-10             SKPINL  10-34#
            Restricted Command Mode  2-9#               slaved port  10-2
            RETACH  10-1,10-20#                         Slaving the Command Port  10-2#
            RETACH error codes  10-22                   SLEEP  16-9#
            retrieval information block  8-5            Sleeping  16-8#
            Reverse XON  10-8#                          SNOOP  19-5#
            RIB  8-5                                    software i/o channels  5-1
            Rights and Handles FRMOPs  2-28#            Software Paging  4-1#
            ring buffer  6-2                            spare RIB  8-5
            ring setup  6-2                             Special Characters  10-9#,10-9,10-14#
            Royalty Charging  20-5#                     Special charging  20-1#
            Royalty Product ID  20-5                    Special UFD status bits  8-5
            Rules for .FOCFH handle creation  2-29      Specialized File Manipulation  8-25#
            RUN  2-1,2-9,2-22,2-24,2-27,3-1,3-5,        SPYUUO  19-6#
               3-7#,3-11                                SSAVE  3-3
            RUN operation  3-5                          stack overflow  16-1
            RUNSEG  3-1,3-10#,3-11                      standard date format  18-1
            RUNTIM  18-3#                               Standard Paging error Codes  4-19
                                                        State manipulation FRMOPs  2-22#
                                                        STATO  5-4,5-14#
            SAIL  1-1                                   STATZ  5-4,5-14#
            SAT  8-5                                    Storage Allocation Table  8-5#,8-5
            SAV file  3-5                               stream accounting  20-7
            SAVE  3-3                                   Stream Accounting Data  20-7#
            SAVE and SSAVE operations  3-5#             Stream Accounting Record Lengths  20-8
            SAVE operation  3-5                         Stream Accounting Record Types  20-7
            saved license  2-4                          Stream Error Record words 0-1  20-10
            Saving Charges  20-4#                       Stream Record Std. Header words 0-4
            search list  8-5                               20-8
            second class club member  17-1              Stream Record types 0-6 (GET/RUN etc)
            secondary RIB  8-5                             format  20-8
            SEEK  8-23#                                 Stream Royalty Record Words 5,6,7,10
            segment  3-1                                   20-6
            session  2-1,2-11                           String Output  10-38#
            Session control operations  2-7#            structure  8-1
            SETABK  19-3#                               STRUUO  8-30#
            SETABK control bits  19-4                   STRUUO error codes  8-31
            SETALP  2-9,2-10#                           STRUUO function codes  8-31
            SETDDT  3-3#                                super IO  8-21
            SETE  2-5#                                  super mapping  4-6
            SETJAL  2-6#,2-7                            super mode  8-21
            SETLCH  10-3,10-15,10-26#                   super USETI  8-21
            SETLIC  2-4,2-5#                            Super USETI/USETO  8-21#
            SETLIC/SETE Record words 5-7  20-9          super USETO  8-21
            SETMAL  2-3#                                supercede  8-8
            SETMOD  10-3,10-26#                         SWITCH  18-11,18-12#
            SETNAM  2-1,2-2#                            SWR file  3-5
            SETOTF  2-12,2-13,2-13#                     SYSDVF  5-7#
            SETPOV  19-5#                               SYSDVF Function Codes  5-8
            SETPRV  2-2#,10-10                          SYSPHY  8-31#
            SETRCF  2-9,2-9#                            SYSSTR  8-31#
            SETSTS  5-4,5-13#                           System Initialization Record words 0-1
            SETSTV  2-24,2-33#                             20-9
            SETTIM  16-6#,16-8                          System Start Vector Indicies  2-25
            Setting Charges  20-4#
            Setting File License  8-20#
            SETTMC  10-26#                              tab-as-break  10-10
            SETTR1  16-1,16-1#                          tape  11-1
            SETTR2  16-1,16-1#                          tape byte counts  11-3
            setup  6-2                                  tape density  11-1
            SETUUO  19-1#                               tape formats  11-1
            SETUWP  3-1,3-2#,3-5                        tape parity  11-1
            shared page  4-2                            tape word counts  11-3
            Sharing  4-2#                               Temporary files  2-33#
                                                    D-7


      Index                                    D                          YAMM edition 2.0


      Terminal Identifier Codes  18-8             VFSTAT  4-16,4-17,4-17#
      Testing  10-33#                             virtual address  4-1
      Testing for File Membership  4-17#          virtual address space  4-1
      Time Zone Codes  18-2                       Virtual Memory  3-1#
      TIMER  18-3#                                Virtual Page Information  4-16#
      TINASS  10-13,16-4,16-5#                    VPEEK  18-10,18-10#
      TMP file  8-13                              VPGFIL  4-17,4-18#
      TMPCOR  2-33#                               VPGFIL Error Codes  4-18
      Trapping Arithmetic and Stack Overflow      VPROT  2-13,4-7,4-7#
         16-1#                                    VPROT Error Codes  4-7
      trapping arithmetic overflow  16-1          VREMOV  2-13,2-21,4-1,4-4,4-4#
      trapping stacck overflow  16-1              VREPLC  2-13,2-21,4-2,4-4,4-4#
      Tree manipulation FRMOPs  2-19#             VT and FF filler class  10-16#
      TRPJEN  19-5#                               VT filler class  10-16
      TRPSET  19-4,19-4#
      TRU Component Checkpoint  20-5#
      TTCALL  10-3,10-7#                          WAIT  5-5,5-7#
      TTCALL functions by number  10-7            Wait until inactive  5-5#
      TTY I/O wait  10-3                          WAITCH  10-34,10-35#
      TTY parity  10-17                           WAKE  16-8,16-9#
      TTY:  10-1                                  Watch Bit Definitions  2-8
      TTY: File Status Bits  10-27                working set  4-2
      Turning off Echo  10-12#                    Working Set Control  4-7#
      TymBasic  1-1                               Working Sets  4-2#
      TYMCHG  20-5,20-5#,20-8,20-9                Writing Stream Records  20-6#
                                                  WSCTL  4-7,4-8,4-8#
                                                  WSCTL Error Codes  4-9
      UFD  8-3                                    WSLIM  4-7
      UFD protection  8-7                         WSMAX  4-7
      UGETF  8-32#,11-2,11-3,11-4                 WSmax, WSlim, WSsiz  4-7#
      UGETF Function Codes  11-5                  WSSIZ  4-7
      UGETF Information  11-4#
      UID  2-11
      Uninterruptible Page Copy  4-10#            XCHARG  20-1,20-1#
      unit names  8-1                             XCHARG Charge Table Entries  20-4
      Universal Frame ID  2-11#                   XCHARG functions by number  20-1
      Universal User Number  2-1                  XCHARG stream record format  20-12
      Unmapping Virtual Pages  4-4#               XEXEC  2-11
      update  8-8                                 XOFF  10-8
      Uptime Record words 0-2  20-10              XON  10-8
      use bit  6-1
      Use of the Club UUOs  17-1#
      user address space  4-1                     Yellow and Orange Balls  10-13#
      User and Process Names  2-1#                yellow balls  10-13
      User File Directory  8-3#,8-3
      User Level  10-1
      user map  4-1                               ZAPCIR  10-2,10-23#
      user name  2-1                              Zapping  10-2#
      user working set  4-2,4-7                   ZAPRMT  19-5#
      User-Constructed Buffer Rings  6-2#
      User-IOT  19-4
      USETI  8-21#
      USETO  8-22#
      UTPCLR  19-5#
      UUN  2-1
      UUOSYM.MAC  1-1


      Validating and Flushing  8-32#
      Validating Pages  4-12#
      VALPAG  2-13,4-12,4-12#
      VALPAG Error Codes  4-13
      VALRMT  19-5#
      VCLEAR  2-13,2-21,4-4,4-4#
      VCREAT  2-13,4-1,4-3,4-3#
      VCREAT Error Codes  4-3
      VDSKPT  4-18,4-18#
      Vestigial Job Data Area  3-3#
                                              D-8
 k@