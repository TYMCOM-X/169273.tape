.sec Port I/O,Ports:
.ind ports; ind port numbers; ind port device names;
.
.sec Port Numbers and Device Names,PortNum:

Each TYMNET port is given a "port number" by the monitor.  That port
number is used directly by some functions, notably AUXCAL, the UUO
through which most port i/o is done.  Each port also has a normal
device name, of the form
.b!ex
	TTY<port number>
.e!ex
where the port number is expressed in octal.
.endSec PortNum:

     


     
     
     
.sec Command Ports,CmdPort:
.ind command port; ind controlling TTY; ind TTY:;
Each frame normally has a "command port".
This port is referred to by the UUOs taking
port numbers as port -1,
and by the UUOs taking device names
as device TTY.
.
.sec Detaching,Detaching:
.ind detaching;
A frame can "detach" itself from its command port
if the user types the command
.b!ex
	DETACH
.e!ex
or if a program executes
the {CalliRef ATTACH}.

Most i/o operations,
when directed towards the command port
of a frame running detached
will just hang until a real port is attached
to the frame again.
.endSec Detaching:
.
.sec Attaching,Attaching:
.ind attaching;
A user who is logged-in,
and who has another frame running detached
on the system,
can attach his current frame's command port to
that frame (detaching it from the current frame)
by typing the command
.b!ex
	ATTACH <frame number>
.e!ex
If the detached frame has any license set, the user must have at least
as much license on his current frame in order to attach to the detached
frame.

A program can likewise cause its frame's
command port to be detached
from it and attached to some other frame
by executing
the {CalliRef ATTACH}.
The {calliRef RETACH} allows ports to be moved from
frame to frame in a completely general way by a process
with sufficient access rights.
.endSec Attaching:
.sec Command versus User Level,CmdLevel:
.ind Command Level
.ind User Level
Any terminal input is processed either by
.b!ex
	1. the monitor's command processor
	2. a user program
.e!ex
When input is going to the monitor as in (1), the
port is said to be in "command level"; when situation
(2) prevails, the port is in "user level".

A port can be in command level even though a program
is running, and even perhaps waiting for input.  This
situation can be caused by the CSTART, CCONTINUE and
ATTACH commands.

In the ordinary course of events, a START, CON, or RUN command
puts the port into user level, and it remains in user level
(causing the program to receive any characters) until
any of the following happens:
.b!ex
	1. the program does an EXIT UUO
	2. the program encounters an error condition which makes
		it unrunnable (ILL MEM REF, ILL INST, etc.)
	3. the port receives an escape character while the program
		is in input wait
	4. the port receives two consecutive escapes
.e!ex
.endSec CmdLevel:
.endSec CmdPort:
     


     
     
     
.sec Auxiliary Ports,AuxCir:
.sec Creating,CreAC:
To create an aux circuit,
a program executes
the {CalliRef CREAUX}.

CREAUX returns its error codes in <ac> left,
and the supervisor's error codes (if any)
in <ac> right. The CREAUX error codes
are
shown in {TabRef CREAUX}.
.
Aux circuits are always in image state; see
{secRef ImagePort} for more discussion
of this attribute.
.endSec CreAC:
.
.sec Slaving the Command Port,CmdSlave:
.ind slaved port;
The {AuxcalRef !AXSLV} works very much
like a {CalliRef CREAUX},
but instead of creating a new circuit,
it detaches the current frame's command port
and makes it available as if it were an
auxiliary port.

Slaved command ports differ in behavior from
auxiliary circuits in that they are
not always in deferred echo mode
and are not always in image state.
.
.endSec CmdSlave:
.
.sec Inquiring about Ports and their Statuses,PortInq:
A program can obtain the port numbers of all
the aux circuits the process currently owns
by executing
the {CalliRef AUXRED}.
Using {calliRef POLPRT} a program can find out what, if any,
significant events have happened on its ports since they
were last polled.  
.endSec PortInq:
.
.sec Zapping,Zap:
A program can zap an aux port by executing
the {CalliRef ZAPCIR}.
.
The no-zap bit can be read or set by {AuxCalRef !AXNZP}.
.endSec Zap:
.
.endSec AuxCir:

     


     
     
     
.sec PTYs,PTY:
.sec Creating PTYs,CreatePty:
PTYs (pseudo teletypes) are somewhat like internal aux circuits.  PTYs
always come in pairs.  To get a pair of PTYs,
execute the {CalliRef CREPTY}.

Normally one of the slave ports returned will be attached to some other
frame (using the {CalliRef RETACH}) as its command port.

Unlike aux circuits, PTYs are symmetrical.  In order to get the effect
of an aux circuit where the "near" end (the end obtained from CREAUX
rather than the end that is logged in at the specified host) is always
in image state and is initialized to not echo, the data mode of the
originating end should be set to '214 (no echo, binary).

.endSec CreatePty:
.sec Characteristics of PTYs,CharPty:
.ind PTY;
A circuit zap on either PTY of the pair will free up both PTYs.  The
opposite end will get a circuit-zapped interrupt.

Yellow balls and character gobblers pass between PTYs exactly as they
would between ends of an aux circuit.

PTYs always apply backpressure when they are overloaded, regardless of
the data mode set.  They wil never send XONs or XOFFS or bells on their
own.  The TYMNET reverse-XON parameter is not simulated.  There is no
state in which sending an XOFF to a PTY will backpressure it.  In the
unlikely case that a PTY pair lost characters the sender would receive an
"output characters lost" interrupt and the intended recipient an "input
characters lost" interrupt.

Block i/o between PTYs will be extremely fast if both ends are doing
block i/o and using the same buffer sizes.

.endSec CharPty:
.sec Suppress-output-translation Bit,SupOutBit:
A program that runs another
program in a separate frame attached to a PTY and
records its output in a file, typically does not want the monitor to
alter the output in such ways as expanding HT's into spaces, regardless
of what the controlled frame has for terminal characteristics.  The 
"suppress-output-translation" bit, {AuxcalRef !AXSOX}, is used for this
purpose.  The port number of one end is specified
to control translation of
the other end's output.
.endSec SupOutBit:

.sec PTY Terminal Charactersitics,PTYTerm:

The terminal characteristics of a PTY (including all of the TYMNET
characterstics, however inappropriate) are always reflected by the
monitor.  If parameter A is set to 6, it will then be read back as 6.
	
The TINASS interrupt, !IATTC (terminal characteristics changed, cause 13)
goes off whenever the "other end" changes one or more of its
terminal characteristics (the corresponding POLPRT bit is LXRTCC, mask =
'400).  For more information on TINASS interrupt see {CalliRef TINASS}
and {TabRef TINASS}, on POLPRT see {CalliRef POLPRT} and {TabRef
POLPRT}.

The recipient of an !IATCC interrupt can use
{AuxcalRef !AXTCP} to read the "next"
unread changed terminal characteristic.

A transparent program which stands between a controlled frame and a real
TTY will want to set the "suppress-output-translations" bit for the PTY
through which the frame is controlled, and then use the !IATCC/!AXTCH
mechanism to pass on the controlled frame's terminal characteristics
settings to the real TTY.

Auxcal function {AuxcalRef !AXTCN} reads and/or sets terminal
characteristics by number.
.EndSec PTYTerm:
.EndSec PTY:
.sec Reseting Ports,TTYreset:
The RESET UUO {secRef RESET}
has the following effect on a frame's ports:
.b!nest
Clear the break-on-all state,
and IO.BK2 and IO.FCS for the command port
(even if the frame is running detached).

If the frame is not detached,
clear block i/o mode if it is set for the command port,
and clear the hardware-horizontal-tabs
and tabs-as-breaks bits.

Zap every aux circuit belonging to the frame
except those whose CREAUXs specified
CX.NZP.
.e!nest
.endSec TTYreset:

     


     
     
     
.sec Line Characteristic Word,LCH:
The line characteristics word for a port
can be read with then {TtcallRef GETLCH}
and set with the {TtcallRef SETLCH}.
Its format is
described in {TabRef GETLCH}.
.
.endSec LCH:
.sec File Status Bits,PortFileStatus:
Some of a port's characteristics
are determined by its file status bits.
The device-dependent bits for ports are
shown in {TabRef TTYFSB}.

If a port has been INIT'ed,
the file status bits can be read and set
using GETSTS/SETSTS/STATZ/STATO
in the normal way.

The bits can, in addition,
be read from the {GettabRef !GTMOD} table
(see {secRef GETTAB}).

To set the file status bits
for the command port,
a program executes
the {CalliRef SETMOD}.

To set the file status bits for
any port owner by the current frame,
a program can execute
the {AuxcalRef !AXSFS}.

.endSec PortFileStatus:
     


     
     
     
.sec Port Operations,PortOper:
.ind TTY I/O wait;
Most port operations are done with the {UuoRef AUXCAL}
or {UuoRef TTCALL}.  AUXCAL does some preliminary checking
before performing its function code.

Most simple operations on a command port are done using
TTCALL, with the <ac> field of the TTCALL specifying the
function, and effective address field specifying the
argument, if any.

While AUXCAL is the more general of the two UUO's, it has
the property that many AUXCAL output functions are NO-OPs
if directed at a non-existent port.  TTCALL output  issued by
a detached frame will cause the frame to go into terminal
output wait until a command port re-appears.  AUXCAL
output by the same detached frame would simply be lost.
TTCALL should be used for command port I/O.

.use AUXCAL.UUO;
.use TTCALL.UUO;
.
.sec Buffered I/O,PortBufIO:
Buffered port i/o can be performed
in ASCII,
ASCII line (=ASCII),
Katakana,
Image,
Image Binary,
or Binary mode.

In ASCII mode,
the byte size is 7 bits;
in Katakana it is 9 bits;
in Image and Image Binary it is 8 bits,
and in Binary it is 36 bits.
(In Binary mode,
the characters are stored
one to a word,
right justified in the user's buffer).

The standard buffer size is
23 (decimal) words (20 data + 3 header).
.endSec PortBufIO:
.
.endSec PortOper:
.sec Baud Rates,Baud:
.ind baud rate; ind port speeds;
A program can read or set a port's
input and output baud rates
using the {AuxcalRef !AXIBR} and {AuxcalRef !AXOBR}.
The numbers passed to and returned by the
AUXCALs are not the actual baud rates
but a code for the baud rate:
.b!nest b!nftab("code\baud",,"6",6)
0\110 (or Aux Circuit)
1\150
2\300
3\400
4\600
5\1200
6\300 (IBM 3767)
7\150 (IBM 2741)
8\300 (10 cps)
9\1200 (10 cps)
10\2400
11\4800
12\9600
13\50 BAUDOT
14\75 BAUDOT
15\75 ASCII
.e!nftab e!nest
.endSec Baud:

     


     
     
     
.sec Buffering and Backpressure,BackPres:
.ind backpressure; ind XON; ind XOFF; ind port buffering;
The monitor maintains an input and an output buffer
for each port,
and TYMNET maintains buffers in both directions as
well.
When buffers fill up,
there are two mechanisms for stopping the
flow of characters:
.b!list
--Cassette and paper-tape-reading terminals
can usually be made to stop transmitting
characters by sending them an XOFF,
and will restart when sent an XON.
--Hosts will stop outputting when backpressure
is applied
to a line
and will resume when it is relieved.
.e!list
When the monitor's input buffer becomes full,
it will normally
apply backpressure if the port's data mode
is image, image binary, or binary,
or send an XOFF otherwise.
.
.sec Host No XON,HNoXON:
The sending of XOFFs and XONs can be inhibited
by setting the "no host XON" bit,
using the {AuxcalRef !AXHNX}.
.endSec HNoXON:
.
.sec Remote XON,RemXON:
The TYMNET remote can be instructed to send the
terminal XOFFs when backpressure is applied
to a line
and XONs when it is released
by setting the "remote XON" bit,
using the {AuxcalRef !AXRMX}.
.endSec RemXON:
.
.sec Reverse XON,Stall:
TYMNET can be instructed to apply and release
backpressure on a line
when XOFFs and XONs (respectively) are typed
at a terminal
by setting the "reverse XON" bit,
using the {AuxcalRef !AXRVX}.
This is especially useful for high-speed
display terminals,
where it provide a means for stopping
output immediately
before it scrolls off the screen.
.endSec Stall:
.
.sec Flushing Input,FlushIn:
To clear the monitor's input buffer for a line,
and release backpressure (if it has been applied)
or send an XON (if an XOFF has been sent),
a program executes
the {TtcallRef CLRBFI} or {AuxcalRef !AXCBI}.
.
.endSec FlushIn:
.
.sec Flushing Output,FlushOut:
To clear the monitor's output buffers
and send a character gobbler
to TYMNET
(eating all the output characters between
the process and the other end of the circuit),
a program executes
the {TtcallRef CLRBFO} or {AuxcalRef !AXCBO}.
.
.endSec FlushOut:
.
.endSec BackPres:

     


     
     
     
.sec Data Transmission Methods,PortTransMeth:
Ports can transmit characters by either of two methods:
.b!ex
	character-by-character (normal) mode (see {SecRef PortCharIO})
	Block i/o mode (see {SecRef PortBlockIO})
.e!ex

All ports are in character-by-character mode unless specifically
placed in block i/o mode by the appropriate AUXCAL.
In block i/o mode, whole buffers of up to 400 characters
are transferred to/from the base in one operation, whereas
in normal mode the host and base handle each character
to pass it across their interface.
Block i/o can realize significant performance improvements
and cost reductions.
.
.endSec PortTransMeth:
.sec Character Handling,PortCharIO:
.
.sec Input,PortInput:
.
.sec Case Mapping,CaseMap:
.ind port case mapping; ind case mapping;
Normally,
the monitor maps all non-image-state lowercase
characters
to their uppercase equivalents
on input:
.skip group begin verbatim
        `    	mapped to    @
        a-z  	mapped to    A-Z
        {    	mapped to    [
        |    	mapped to    \
        }    	mapped to    ESC
        tilde	mapped to    ESC
.end
This action can be disabled by setting
LC!NCM in the line characteristics word
(see {TabRef GETLCH}).
.endSec CaseMap:
.
.sec Special Characters,SpclChar:
.ind special characters;
.
.sec Line Editing,LineEdit:
.ind line editing;
.ind full-character-set mode;
.ind line-delete character;
.ind character-delete character;
The monitor provides a line-delete and a character-delete
character for line editing during terminal input.
The actual characters recognized by the monitor depend
on the monitor mode as described on {secRef MonMode}.

Backspace (^H) can be defined to be an additional character-delete
character by using {AuxcalRef !AXRUB}.  It also can be set or reset by
using the command
.b!ex
	TTY [NO] BSD
.e!ex

The character-delete character deletes characters,
one at a time,
back to (but not including)
the most recently-typed break character
or until all the characters in the input buffer
have been deleted.

The line-delete character has the same effect as
infinitely-many character-delete characters:
if there are no break characters in the buffer,
it deletes the entire buffer;
otherwise it deletes everything back to
(but not including)
the most recently-typed break character.

The line-editing characters will not have
an effect if they arrive
.b!list
--when the port is in image state
--when the port is in break-on-all mode
--when the port is in full-character-set mode
.e!list
In any of the above cases, the editing character
will simply be passed to the user program.
In full-character-set mode,
the editing characters are treated as
control characters (i.e., they always break).
This is the only effect of full-character-set mode, which
is entered by setting IO!FCS as shown in {tabRef TTYFSB}.
.endSec LineEdit:
.
.sec Escape Character,Escape:
.ind port escape characcter; ind escape character;
The monitor provides an "escape" character,
which a user normally types
(on a frame's command port)
to get the attention of either the
running program or the monitor.

Upon receiving an escape character,
the monitor acts as follows:
.b!nest
If the port is in image state,
just deposit the escape in its input buffer.

Otherwise, set the "escape seen" bit
(bit LC!ESC of the line characteristics word,
{TabRef GETLCH})
for the port,
and proceed:
.b!nest
If the frame that owns the port
is enabled for a software interrupt
on escapes,
cause the interrupt,
without depositing the escape in the
input buffer.

Otherwise,
perform a line-delete operation on
the port's input buffer
(as if a line-delete character had been typed,
but without the echo),
and proceed:
.b!nest
If this is not the second escape received,
or if it is the second, but either
(1) the port is not its owner's command port,
(2) the port is at command level,
or (3) the port's owner is running
with JB.JAC or JB.JA2 set in its frame status word
(see {TabRef JBTSTS}),
just deposit the character in the port's
input buffer.
(If the line is at command level,
perform a CLRBFO operation as well).

Otherwise,
perform a CLRBFI and a CLRBFO operation
for the port,
set its suppress-output bit,
force a HALT command for the frame,
and force the port to command level.
.e!nest
.e!nest
.e!nest
.endSec Escape:

.
.sec Output Suppression,OutSup:
The monitor provides a character
which a user can type to suppress
unwanted output without
stopping the program that is generating it.

Whenever a suppress-output character is received,
the monitor does a CLRBFO for the port,
then complements the suppress-output bit
for the port.

The suppress-output bit LC!NOP is bit 9 in the
port's line characteristics word (see {tabRef GETLCH}).
When it is 1, output calls for the port become
no-ops.
The bit is cleared
.b!list
--by the first output after an INIT on the port
--by any input call
--by SKPINC, SKPINL, .AXSIL, .AXSIC
--by the command preter in various situations
.e!list

See {TabRef TAB41} for the suppress output characters.
.endSec OutSup:
.
.sec End Of File,TTYEOF:
In PDP10 mode,
IO.EOF is set in the port's file status bits
if a ^Z is read from a terminal
(while it is not in the image state).
.endSec TTYEOF:
.
.sec Monitor Modes,MonMode:
.ind monitor modes;
A frame can run in one of four "monitor modes":
PDP10, XEXEC, XEXECJ, and SUDS.
The current mode is stored in bits 27-28
of the frame privilege word (see {TabRef JBTPRV}),
which can be read from the {GettabRef !GTPRV}
table (see {TabRef GTFUN}),
and set with the {CalliRef SETPRV}.

The monitor mode determines the characters used for various
terminal control functions for the frame's command port as
indicated in {TabRef TAB41}.
.endSec MonMode:
.endSec SpclChar:
.
.sec Break Characters,BreakTTY:
.ind break characters; ind port break characters;
.ind tab-as-break; ind |backspace break/punctuation bit|;
A port has a "break-on-all" bit.
When it is set,
a non-image-state input operation will return
as soon as there is at least one
character in the port's input buffer;
when it is cleared,
a non-image-state input operation will return
as soon as either
.b!list
--there is at least one break character
in the port's input buffer
--the port's input buffer is nearly full
.e!list
The break-on-all bit is set by the input operations
.b!ex
	{CalliRef DDTIN}
	{AuxcalRef !AXSIC}
	{AuxcalRef !AXICW}
	{TtcallRef INCHRS}
	{TtcallRef INCHRW}
.e!ex
The break-on-all bit is cleared by the input operations
.b!ex
	{UuoRef INPUT}
		(not in image mode)
	{AuxcalRef !AXISL}
	{AuxcalRef !AXIWL}
	{TtcallRef INCHSL}
	{TtcallRef INCHWL}
.e!ex
The class of characters that are considered to be
"break characters" can be controlled
somewhat by the user.

Normally, the break set consists of all
the control characters which actually
get placed in the port's input buffer
(excluding, therefore, the line-delete character,
for example), with the exception of
HT.

If the "break-on-punctuation" bit
(bit 26 of the file status bits) is set,
the punctuation characters are also
considered break characters:
.skip begin group verbatim
        ! " # $ % & ' ( ) _ = - ^ <tilde> { }
        [ ] ` @ + ; * : < , > . ? / | \
.end
If the "tabs-as-breaks" bit is set,
tabs are counted as control characters
(they always cause breaks);
if it is cleared,
they are counted as punctuation
characters
(and only cause breaks if the
break-on-punctuation bit is set).
The tabs-as-break bit can be read and reset
with the {AuxcalRef !AXTBK}.
If the Backspace Break/Punctuation bit is clear (the
default case), backspace is always a break character.  If it
is set (use {AuxcalRef !AXBBP} ) backspace counts as
a punctuation character and causes a break only if
break-on-punctuation is set.
.endSec BreakTTY:
.sec Image State,ImagePort:
.ind image mode; ind port image mode;
A port can be in "image state",
in which case the characters input
are simply deposited into the input buffer
without further examination by the monitor.
Characters received in image state
are furthermore flagged
so that no special action
will be taken for them when they
are read by the program
(this is important in the case of the
escape character)
or echoed by the monitor
(this affects line position computation,
VT and FF padding and HT echoing).

An aux port is always in image state;
non-aux ports are placed in image state
by any of the following operations:
.b!list
--INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOIBN, or .IOBIN)
--.AXI8C, .AXI8S, .AXI8B
.e!list
It is cleared (for non-aux ports) whenever
.b!list
--any output operation is performed
and the data mode is not .IOIMG, .IOIBN, or .IOBIN
--a CLOSE is done for the output side of
a channel initted to the port
and the data mode is not .IOIMG, .IOIBN, or .IOBIN
--the port stays in input wait for more than
20 seconds without a character arriving
and the port's data mode is .IOIMG.
.e!list
.
.sec Breaks,ImgBreak:
The operations
.b!ex
	.AXI8C, .AXI8S
	.AXICW, .AXISC
	INCHRW, INCHRS
	DDTIN
.e!ex
set the port's break-on-all bit.
(.AXI8C and .AXI8S place the port in image state
as well).
They wait until (or nonskip-return unless)
at least one character has been
deposited in the buffer.

The operations
.b!ex
	.AXI8W
	.AXIWL, .AXISL
	INCHWL, INCHSL
	INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOBIN, .IOIBN)
.e!ex
clear the port's break-on-all bit.
The break condition is different, however,
for them than for non-image mode operations.

The calls that nonskip or skip-return depending
on the presence of a break
will return if the port's input buffer is empty
and skip-return if it contains at least
one character (just as if they were the corresponding
break-on-all calls).

The calls that wait for a break character
will return immediately if any characters
are in the port's input buffer.
If the buffer is empty at the time of the call,
what happens depends on whether the program
has set an "image break character"
(see {secRef ImgBrk}).
If it has,
the call will return as soon as one of those
characters is received
(or as soon as a timeout clears the image
state and a non-image-state break character
arrives).
If it has not,
the call will return as soon as the
monitor receives some characters
and then stops receiving characters for a few
seconds,
or until the input buffer becomes full.
.endSec ImgBreak:
.
.sec Image Break Character,ImgBrk:
.ind image break character; ind port image break character;
To set a port's image break character,
or to declare that there is no image break character,
a program executes
the {AuxcalRef !AXS8B}.
.endSec ImgBrk:
.endSec ImagePort:
.endSec PortInput:
.
.sec Echoing,Echo:
.ind green ball; ind red ball; ind port echoing; ind remote echo;
.ind local echo; ind deferred echo; ind echo;
A TYMNET circuit can be in deferred or remote echo mode.
In remote echo mode,
echoing is done by the TYMNET remote;
in deferred echo mode,
echoing is done by the host computer.
The idea is that the remote can echo everything
whose echoing behavior is obvious
(such as the printing characters),
but that the echoing of questionable
characters
(such as control characters)
should be left to the host.

A remote will switch from remote to deferred echo
when
(1) a control character other than
carriage-return or linefeed is typed,
(2) a right brace, tilde, or rubout is typed,
(3) a character is typed while output
is in progress at the terminal, or {auxcalRef !AXEDE} is issued.
It preceeds the offending character with an
"entering deferred echo mode" message
(so that the host will know that
subsequent characters have not yet been
echoed) and stops echoing remotely.
Having done this, the remote now seeks to get back
into remote echo mode:
every few seconds,
it sends a green ball towards the host;
if a green ball reaches the host
and the host (1) is in input wait
and (2) has finished all its echoing and
outputting on the line,
it will reflect the ball back;
when the green ball reaches the remote,
it will send a "leaving deferred echo mode"
message along to the host
(so that the host will know
that the subsequent characters have already
been echoed)
and will resume echoing characters remotely.
.
.sec Turning off Echo,EchoOff:
There are three ways to make the
TYMNET/host combination stop echoing characters:
.b!list
--Log in to TYMNET on a local-copy device
(for example an IBM 2741)
--Set half-duplex mode
--Turn off echo
.e!list
The three behave in somewhat different ways,
as described below.
.
.sec Half-Duplex,HDX:
.ind half-duplex; ind HDX;
When half-duplex mode is set,
the TYMNET line goes into remote echo
mode and stays there,
and the remote stops echoing;
nothing happens in the monitor.
The result is that most normal characters
stop echoing,
but that characters with special echoing properties
(such as the character-delete character,
which echoes the characters it has deleted,
or the horizontal tab character which,
if simulated, echoes some number of spaces)
do not.
Half-duplex mode is the correct mode to set
for a half-duplex,
but not line-at-a-time,
terminal.

The "half duplex" bit 
(LC!HDX, see {tabRef GETLCH}),
can be set with the {AuxcalRef !AXHD}.

It can also  be set or reset with the command
.b!ex
	TTY [NO] ECHO
.e!ex
(which does not set the "no echo" bit!).
.endSec HDX:
.
.sec No Echo,NoEcho:
When no echo mode is in effect,
the TYMNET line stops echoing characters
if it is in remote echo mode,
and, once in deferred echo mode,
does not attempt to leave;
the monitor
stops echoing altogether,
with the exception that control-O,
the PDP10-mode output-suppress character,
is still echoed as ^O.
No-echo mode is the correct mode to set
when reading passwords,
for example,
since setting half-duplex mode
would allow deleted characters of the password
to be echoed.

The "no echo" bit is bit 28 of a port's
file status bits (see {secRef PortFileStatus}).
.endSec NoEcho:
.
.sec Local Copy,LocalCpy:
Local-copy mode is set along with half-duplex
by TYMNET where a user
logs in and his or her terminal identifier
character indicates a local-copy device
such as an IBM 2741.
Regardless of the settings of any other bits,
when local-copy mode is in effect,
the monitor assures
.b!list
--No free carriage-returns on lines greater
than the maximum line-width
--No dollar-sign echo for escapes
--No ^<character> echoes for control characters
such as control-Z
--No spaces output for horizontal tabs
--No linefeeds output for VT or FF
--No echoing of deleted characters
.e!list
The intent of local-copy mode is to keep the
monitor from trying to output
while the user is trying to type.
.endSec LocalCpy:
.
.endSec EchoOff:
.
.sec Yellow and Orange Balls,YellowBalls:
.ind yellow balls; ind orange balls;
.ind green balls; ind |balls (messages) in Tymnet|;
.ind colored balls; ind orange balls;

The remotes send green balls to determine when
a host port has gone into input wait.
It is often useful for a program to know
the same thing about the port at the other end
of an aux circuit.

To do this,
the program sends a yellow ball.
The yellow ball will follow any characters
the program has output along the circuit.
When it reaches the host,
it will "stick" there until the host port
goes into input wait,
at which point,
it will be reflected back as an orange ball.
(A yellow ball sent to a terminal will be reflected
back as soon as it arrives).

The .HBODN wait condition of the {CalliRef HIBER}
sends a yellow ball and waits until it
is reflected back. This is a straightforward
way to wait until a batch of program output
has been absorbed by the host or terminal
at the other end.

The .IAORG software interrupt condition
(see {CalliRef TINASS})
will cause a software interrupt when an
orange ball is received.

To simply send a yellow ball,
a program executes
the {AuxcalRef !AXSYB}.

The !IAYEL software interrupt condition
(see {calliRef TINASS}) will cause a software interrupt
when a yellow ball is seen, and suppress reflection
of the yellow ball as an orange ball.  
In order to conform with proper protocol,
the receiving program should
send back an orange ball; this is accomplished with
the {auxcalRef !AXSOB}.

.endSec YellowBalls:
.sec Faking Input Wait,IWFake:
It is possible to inadvertently put a circuit in deferred
echo mode forever.  If a program is doing interrupt driven
i/o (i.e. !INCHR is set as a TINASS cause for interrupt)
the program will never actually enter input wait.  As a
result, no yellow balls will be reflected as orange balls,
and no green balls will be reflected back to the remote to
tell it to reenter remote echo mode.  This 
will cause a problem if
there is a program at the other end of the circuit in
interrupt wait waiting to receive an orange ball before
waking up.
If the program is doing line input,
the line will not be echoed until the <return> is entered.
To prevent this,
the program may execute the {AuxcalRef !AXLDE} or
the {CalliRef LEVDEF} to tell the monitor to behave as if
it were in input wait.
.
.endSec IWFake:
.
.sec Special Characters,SpclCharTTY:
.
.sec Backspace,BS:
.ind remote backspace echo;
Normally, backspace is a control character to
TYMNET,
and forces a line into deferred-echo mode.
If a terminal can perform backspacing,
it is reasonable to
echo backspaces remotely.
A program can read or set the "remote backspace echo" bit
with the {AuxcalRef !AXRBS}.  This can also be set of reset by the
command
.b!ex
	TTY [NO] BACKSPACE
.e!ex
Backspace can be set up as a character-delete character
(see {SecRef LineEdit}).

.endSec BS:
.
.sec Deleted Characters,DelChrs:
.ind backspace-for-character-delete;
Normally,
the monitor responds to the first
character-delete character it receives
by typing a backslash and the character
deleted;
to subsequent character-delete characters
by typing the characters deleted;
and to the next (non-character-delete) character
typed by typing a concluding backslash
and echoing that character.

On most display terminals,
characters can be erased by backspacing
and typing over them.
The monitor can be made to simply echo
a backspace for each character-delete character
received
by settting the "backspace for character-delete"
bit,
using the {AuxcalRef !AXBS}.  This can also be set or reset by the
command
.b!ex
	TTY [NO] ERASE
.e!ex
.endSec DelChrs:
.
.sec Escape,EscapeChar:
In the PDP10 modes,
the monitor normally echoes ESC
(and right brace and tilde if they are being
mapped to escape)
as a dollar sign
(unless the ESC was received while the port
was in image state, in which case an ESC is echoed).
This feature can be disabled by
setting the
"no special escape echo" bit,
bit 27 of the file status bits
(see {secRef PortFileStatus}).
.endSec EscapeChar:
.
.endSec SpclCharTTY:
.
.endSec Echo:
.
.
.sec Output,PortOut:
The character-handling described in this section
applies both to characters output by a program
and to characters echoed by the monitor.
.sec Output Case Mapping,POCMap:
Normally, characters are sent to TYMNET exactly
as generated by the program or echoed by the host.  For
certain terminals, it is desirable to have all alphabetic
material in lower case, since upper case is used on
these terminals for special characters.  A user of
such a terminal may give the command
.b!ex
	TTY [NO] UCO
.e!ex
meaning "no upper case output", and cause all upper-case
alphabetic characters to be mapped to lower-case.
This port parameter can also be manipulated
by the {auxcalRef !AXLCO}.
.endSec POCMap:
.sec Image Characters,PortOutImg:
.ind image output; ind port image output;
For the purposes of this section,
an "image character" is a character
received while the port was in image state
(which is being echoed),
or an output character from the program
which was output by
.b!list
--OUT, OUTPUT, .CHOUT, .CHOPT (data mode = .IOIMG, .IOIBN, .IOBIN)
--.AXPTR, OUTPTR (byte size > 8 and level-9 bit = 1)
--.AXO8, .AXO8I, IONEOU
.e!list
These characters are transferred directly
from the port's output buffer
to TYMNET without special processing by the monitor.
.endSec PortOutImg:
.
.sec Line Width and Position,LDLNFC:
.ind no-free-CR bit;
While echoing and outputting characters,
the monitor keeps track of the current
position of the terminal's print head.
(Image characters, however,
are treated as having zero width).
This estimate of the print position
can be read from the {GettabRef !GTLPS}
table (see {TabRef GTFUN}).

The monitor has a "line width" parameter for
each port,
and if echoing or outputting a character
would cause the print position to exceed the
line width,
it outputs a carriage return/linefeed sequence
in front of the character.

The line width parameter can be read or set
with the {AuxcalRef !AXWID}.
and the automatic carriage return/linefeed
action can be suppressed by setting
the "no free carriage return" bit of
the terminal
using the {TtcallRef SETLCH}.
.endSec LDLNFC:
.
.sec |HT, VT, FF simulation|,HT!VT!FF:
.ind |no-HT/VT/FF bit|;
The monitor normally simulates horizontal tabs
(unless they are image characters)
by inserting blanks to the next "tab stop",
tab stops being every 8 characters.
This feature can be disabled
for terminals having HT hardware
by setting the "hardware horizontal tabs" bit,
(LC!HHT, see {tabRef GETLCH}).

The monitor normally simulates vertical tabs and
formfeeds
(unless they are image characters)
by inserting linefeeds,
4 for each vertical tab and 8 for each
formfeed.
This feature can be disabled
for terminal having vertical motion hardware
by setting the "hardware vertical tabs and formfeeds" bit,
(LC!HFF, see {tabRef GETLCH}).

The echoing (or simulation) of horizontal tabs,
vertical tabs and formfeeds can be suppressed
altogether
by setting the
"no HT/VT/FF" bit,
using the {AuxcalRef !AXNTE}.
This bit affects only echoing,
not output.
.endSec HT!VT!FF:
.
.sec CR and LF delay,CRLFdelay:
.ind parameter A; ind parameter B; ind parameter C;
.ind CR delay; ind LF delay; ind delay;
TYMNET can supply delays for carriage-returns
and linefeeds
for terminals where those operations
take longer than one character time
to perform.
The formulas used to compute those delays
are given below.
The units are 30ths of a second.

The "compute CR delay" bit determines how
the delay parameters A, B, C, and D are used.
If it is set,
A, B, and C are used to compute the carriage-return
delay,
and D is the (constant) line feed delay.
If it is clear,
A, B, and C are used to compute the linefeed delay,
and D is the (constant) carriage-return delay.
The bit can be read and set
with the {AuxcalRef !AXCRD}.

Parameter D cannot be set by the monitor.
Parameters A, B, and C can,
but the values passed between the monitor
and the user are not the actual parameter
values
but rather indexes into tables
of the actual parameter values.
The relationships are
.b!ex
 param A-use {AuxcalRef !AXPA}
 index		0  1  2  3  4  5  6  7
 value		1  2  4  8  16 32 64 128
.!sag
 param B-use {AuxcalRef !AXPB}
 index		0 1 2 3 4 5 6 7
 value		0 1 2 3 4 5 6 7
.!sag
 param C-use {AuxcalRef !AXPC}
 index		0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
 value		0  1  2  3  4  5  7  10 14 19 26 36 50 69 95 131
.e!ex
.
.sec CR Delay Formula,CRformula:
Parameters A, B, and C
are used to compute the carriage-return delay
as follows:
.b!ex
	delay := min( N/A + B, C )
.e!ex
where <N> is the current line position.
.endSec CRformula:
.
.sec LF Delay Formula,LFformula:
Parameters A, B, and C
are used to compute the linefeed delay
as follows:
.b!ex
	delay := log2(A)	if N <= 1
		 C-N+B		if 2 <= N < C
		 B		if N >= C
.e!ex
where <N> is the current line position.
.endSec LFformula:
.endSec CRLFdelay:
.
.sec |HT, VT, FF delays|,HT!VT!FFdelay:
The monitor can supply delays
for horizontal tabs,
vertical tabs,
and formfeeds,
for terminals where those operations
take longer than one character time
and are hardware-implemented.
The delays are produced by inserting
rubout characters ('177s),
and the units given below
are the number of rubouts inserted
(character times).

Such padding is not provided if the VT or FFs
are image characters.
.
.sec HT Filler Cclass,HTfillCls:
.ind HT filler class; ind filler class 2;
The "filler class 2" terminal characteristic
is used to compute delays
for horizontal tabs.
It can be read and set
with the {AuxcalRef !AXFC2}.
The delays are computed as follows:
.b!ex
	FC2	N<=4	N>4
	0	0	0
	1	1	2
	2	3	5
	3	3	5

where <N> is the distance to the next tab stop
.e!ex
This assumes that tabs are every 8 characters.
.endSec HTfillCls:
.
.sec VT and FF filler class,VT!FFfillCls:
.ind filler class 1; ind VT filler class; ind FF filler class;
The "filler class 1" terminal characteristic
is used to compute delays
for vertical tabs and formfeeds.
It can be read and set
with the {AuxcalRef !AXFC1}.
The delays are computed as follows:
.b!ex
	FC1	VT	FF
	0	0	0
	1	6	12
	2	5	15
	3	20	40
.e!ex
.endSec VT!FFfillCls:
.
.endSec HT!VT!FFdelay:
.
.endSec PortOut:
.
.sec Parity,PortParity:
.ind port parity; ind TTY parity; ind parity; ind even-parity;
TYMNET has an even-parity parameter which, when set,
causes the level-8 bit of each character transmitted
to be discarded and replaced with
a generated even-parity bit for the character.

The monitor always sets the level-8 bit to 0
on 7-bit characters output to TYMNET,
and always sends the character's level-8 bit
on 8-bit output.
A program must, however,
clear TYMNET's even-parity parameter
if it wants to send 8-bit characters
unchanged over TYMNET.

The even-parity parameter can be read and reset
using the {AuxcalRef !AXEP}.
.endSec PortParity:
.
.sec Data Transmission Modes,PortDataMode:
.sec Katakana Data Mode,Katakana:
.ind Katakana data mode;
.ind JIS-8;
The port i/o routines normally treat
image characters as being 8 bits wide
and non-image characters as being 7.
If, however,
the port's data mode is .IOKAT,
non-image characters are treated as
being 8 bits wide.

This data mode is intended to allow the handling
of the JIS-8 character set,
an 8-bit extension of ASCII
that has Katakana characters
in code positions '241 through '377.

For buffered i/o, the byte size in .IOKAT mode
is 9 bits. The level-9 bit is always 0 on input
and should be always 0 on output.

Most port i/o calls adjust appropriately
to Katakana mode,
transmitting 8-bit instead of 7-bit characters.
Those that do not are
.b!list
--{TtcallRef OUTSTR}, {AuxcalRef !AXOST}
--{CalliRef DDTIN}
--{CalliRef DDTOUT}
.e!list
The monitor decides whether a given character
is a special-function character,
break character,
or punctuation character
by examining its right 7 bits.
For example, in PDP10 mode,
where ^C is the escape character,
both '003 and '203 act as escapes.

If case mapping is in effect,
codes '340 through '374 will be mapped
to '300 through '334,
and codes '375 and '376 will be mapped
to ESC.
.endSec Katakana:
.sec Paper Tape Mode,PTPmode:
For reading paper tape or cassettes,
the monitor supplies "paper tape" mode.
In this mode,
regardless of the settings of any other bits,
.b!list
--Linefeeds are not echoed after each carriage-return
--Rubouts are ignored
--No free carriage-returns are supplied for
lines over the maximum line width
--There is no dollar-sign echo for escapes
--There are no ^<character> echoes
for control characters such as ^Z
--No spaces are output for horizontal tabs
--No linefeeds are output for VT or FF
.e!list
This mode can be entered by setting LC!PTM
(see {tabRef GETLCH}).
.endSec PTPmode:

.sec Port Buffered-I/O Modes,PBufMod:
See {SecRef PortBufIO} for a discussion of the legal data
modes for buffered i/o operations on ports.
See {SecRef BufIO} for general discussion and definition
of buffered i/o with any device.
.endSec PBufMod:
.endSec PortDataMode:
.endSec PortCharIO:
     


     
     
     
.sec Special Purpose Terminal Charactersitics,SpecPur:
.ind tty class;
.sec Terminal Class,TerClass:
A SIXBIT string identifying the "class" of the terminal in use is set
or read by {AuxcalRef !AXTTP}.  This identification can be used by
screen editors and other applications on display type terminals.

The terminal class can also be set by the command
.
.b!ex
	TTY CLASS <terminal identifier>
.e!ex
.endSec TerClass:
.ind Control T Mode;
.sec Special Control-T Mode,SpecTMode:
The "special control-t" mode bit can be set or read in the usual way with
{AuxcalRef !AXCLR}.  If it is set and the user is in PDP10 mode,
a ^T will display a status line on the
command port terminal in the following format:
.b!ex
	elapsed:0:00:34 tru:5.01 blks in:136 out:0 state:^C mws:46
.e!ex

The display elements are elapsed time since the last ^T command in
hours, minutes, and seconds; cpu time (microcycles) in minutes, seconds
and jiffies; disk blocks read; disk blocks written; the current state of
the calling job; and the current monitor working set size.
.endSec SpecTMode:
.endSec SpecPur:

.sec Block I/O,PortBlockIO:
.ind block IO;
The block i/o facility was designed
to make high-volume data transfer
over TYMNET more efficient,
mainly by reducing per-character cpu
overhead in the host.
Charging is adjusted accordingly:
at 80 characters per transfer,
block i/o costs the same as
normal i/o;
at the maximum 400 characters per transfer
it costs less than half as much.

.sec Block I/O Buffer Format,BIObuf:
The block input and output AUXCALs
are all passed the address of a 101(decimal)-word
buffer,
whose format is
.b!ex
	0-7	8-15	16-23	24-31	32-35 bits
	--------------byte count------------- wd 0
	b0	b1	b2	b3	XXXXX wd 1
	b4	b5	b6	b7	XXXXX wd 2
	...
	b396	b397	b398	b399	XXXXX wd 100
.e!ex
On output, <byte count> specifies the number
of bytes to be output;
it must be a number from 1 to 400 (inclusive).

On input,
the <byte count> is set by the monitor,
and indicates how many bytes
the monitor has stored into the user's buffer.
The monitor reads the <byte count>
at the time the input operation is performed,
and requests that many bytes from TYMNET.
When the input arrives,
the monitor copies it all into the user's
data area (without reexamining the count).
Since the monitor reads ahead,
it is not advisible to change <byte count>
from one request to the next.

Successive words after <byte count> store
the actual data,
4 left-justified 8-bit bytes per word.
The rightmost 4 bits of each word
are unused on output
and undefined on input.
The contents of bytes after the <byte count>th byte
are also undefined on input.
.endSec BIObuf:
.
.sec Block I/O Data Modes,BIOmode:
Block i/o should be performed in Image,
Image Binary,
or Binary Mode.
The treatment of data modes
while in block i/o mode
differs from the normal treatment.

The monitor will signal an end-of-input
(and wake or interrupt the frame accordingly)
if
.b!list
--it receives an end-of-transmission message
(this is currently signalled by sending a yellow
ball)
--a timeout occurs
(currently, this means that the base has
gone 16 seconds without receiving four characters)
--the requested input arrives
.e!list

The data mode determines the handling
of timeouts and EOTs.

Timeouts in Image Binary and Binary modes
simply cause the monitor to re-request
the input (i.e., there are no timeouts).
In Image mode,
the monitor sets IO.BKT in the port's file status
bits when it receives a timeout
message from the base,
then forces an .AXTBI operation on the port.

EOTs are ignored in Binary mode.
In Image Binary and Image modes,
they signal the end of the data:
the monitor will not send any more
input requests to the base
until the program has exhausted
all the data,
by doing block inputs until IO.EOF is set
in the file status bits.
.endSec BIOmode:
.
.sec Interaction with Non-Block Input,BIO!NBI:
Between the time a block input call is done
on a port
and a subsequent block input returns
with IO.EOF set in the file status bits,
the effect of nonblock input operations
is unpredictable;
after the IO.EOF has been received,
the program can proceed
with nonblock input operations
(without doing a .AXLBM),
though caution must be exercised
with respect to the data modes.

The existence of block i/o at all is not
known past the PDP10's base:
the first block input starts diverting
input characters from the port's normal
buffer
into the block input buffer,
where they will continue to go
until block input has been terminated,
a state which is indicated by a
block input call's returning
with IO.EOF set.
.endSec BIO!NBI:
.
.sec Interaction with Non-Block Output,BIO!NBO:
It is acceptable to perform a nonblock
output operation
immediately after a block output operation:
the nonblock characters will be output
immediately following the block output
characters.
Before doing a block output, however,
the program should make sure that all
of the previous nonblock output characters
have actually been sent
(e.g., by doing a HIBER on output complete),
since otherwise, the block output characters
may intervene among the nonblock.

The data mode of the port has no effect on block
output.
.endSec BIO!NBO:
.
.sec Block I/O Tutorial,BIOTut:
To perform block i/o on a port,
the program must first place the port
in block I/O mode by executing the {AuxcalRef !AXEBM}.

A port will leave block i/o mode
when the program executes a RESET or HANG UUO,
or the port is zapped,
or the program executes
the {AuxcalRef !AXLBM}.

To do block input, a program executes
the {AuxcalRef !AXIBW} or {AuxcalRef !AXIBS}.
It is valid for either call to store a byte count
of zero and transfer no data.

In Binary mode,
IO.EOF is never set,
and in the other modes,
it may be desirable to terminate block
input before the "other end" times out
or sends an EOT.
To terminate block input without
losing data,
a program executes
the {AuxcalRef !AXTBI}.

To do block output,
a program executes
the {AuxcalRef !AXOB}.

To do the equivalent of a normal CLRBFO,
a program must first
execute the {AuxcalRef !AXTBO} to stop the base from working
on any uncompleted block output for the port,
then do a {AuxcalRef !AXCBO} to send a character gobbler.
.endSec BIOTut:
.endSec PortBlockIO:
     


     
     
     
.sec |Port Creation,Moving,Deletion UUOs|,PortCreDelUUO:
.use GETLIN.UUO
.use ATTACH.UUO
.QueueTab RETACH;
.use RETACH.UUO;
.use RLSLDB.UUO;
.use CREAUX.UUO
.QueueTab CREAUX;
.use AUXCAL.SLV
.use ZAPCIR.UUO
.USE AUXCAL.HNG;
.use AUXRED.UUO
.use CREPTY.UUO
.use POLPRT.UUO
.USE AUXCAL.PSM;
.use AUXCAL.NZP;
.endSec PortCreDelUUO:
.sec Port and Terminal Characteristics UUOs,PortCharUUO:
.QueueTab GETLCH;
.use GETLCH.UUO;
.use SETLCH.UUO;
.use AUXCAL.TCN;
.use AUXCAL.TCP;
.QueueTab TERM;
.use GETTMC.UUO;
.QueueTab TTYFSB;
.QueueTab TAB41;
.use SETMOD.UUO;
.use AUXCAL.SFS;
.use AUXCAL.SOX;
.use AUXCAL.CRD;
.use AUXCAL.IBR;
.use AUXCAL.OBR;
.use AUXCAL.EP;
.use AUXCAL.HD;
.use AUXCAL.PA;
.use AUXCAL.PB;
.use AUXCAL.PC;
.use AUXCAL.HNX;
.use AUXCAL.NTE;
.use AUXCAL.TBK;
.use AUXCAL.WID;
.use AUXCAL.FC1;
.use AUXCAL.FC2;
.use AUXCAL.RMX;
.use AUXCAL.RBS;
.use AUXCAL.RVX;
.use AUXCAL.TYP;
.use AUXCAL.BS;
.use AUXCAL.RUB;
.use AUXCAL.CLR;
.use AUXCAL.TTP;
.endSec PortCharUUO:
.sec |Echo,Break,Backpressure UUOs|,EBBUUO:
.use AUXCAL.S8B
.use AUXCAL.SYB
.use AUXCAL.SOB
.use AUXCAL.LDE
.use LEVDEF.UUO
.use CLRBFI.UUO
.use AUXCAL.CBI
.use CLRBFO.UUO
.use AUXCAL.CBO
.endSec EBBUUO:
     


     
     
     
.
.sec Port Input UUOs,PortIn:
.ind port input;
There are 8 different calls to read a single
7-bit (or 8-bit if the port data mode is Katakana)
character from a port. The 8 calls correspond
to the 8 combinations of
.b!list
--[CMD] Whether the call specifies a port or just uses
the frame's command port
--[WAIT] Whether the call waits for a break
or whether it skip-returns if there is a break
and nonskips if there is not
--[BKA] Whether the port's break-on-all bit is set,
so that any character in the input buffer
is considered a break,
or whether it is cleared
.e!list
The calls are
described below and summarized in {TabRef TTYin}.
.QueueTab TTYin;
.!pin(T,0,INCHRW,input char [wait/bka],T,T,F)
.!pin(F,44,!AXICW,input char [wait/bka],T,T,F)
.!pin(T,2,INCHRS,input char [skip/bka],F,T,F)
.!pin(F,45,!AXICS,input char [skip/bka],F,T,F)
.!pin(T,4,INCHWL,input char [wait],T,F,F)
.!pin(F,46,!AXIWL,input char [wait],T,F,F)
.!pin(T,5,INCHSL,input char [skip],F,F,F)
.!pin(F,47,!AXISL,input char [skip],F,F,F)
.
.sec Image State,PortInImage:
There are three system calls which place the
port into image state
and then input an 8-bit character:
.
.!pin(F,0,!AXI8C,input char [wait/bka/img],T,T,T)
.!pin(F,1,!AXI8S,input char [skip/bka/img],F,T,T)
.!pin(F,2,!AXI8B,input char [wait/img],T,F,T)
.
.endSec PortInImage:
.
.sec Testing,PortInTest:
A program can test whether there are break characters
or any characters in a port's input buffer.
The calls are
shown below.
.
.endSec PortInTest:
.
.sec Faking Input,PortInFake:
A program can force a character string into a port's
input buffer,
in such a way that the characters in the string
appear to have been typed by the user.
The program executes the {AuxcalRef !AXSI}.
.
.endSec PortInFake:
.
.sec Miscellaneous Command Port UUOs,PortInMisc:
A program can read the next character from
the command port without removing it from
the input buffer by executing
the {CalliRef REDNXT}.

To wait for a character to arrive
at the command port,
a program executes
the {CalliRef WAITCH}.

The {calliRef CONT} allows a program to switch
its command port to user level from command level.
This is useful if a program running detached wishes
to receive input from any terminal that reattaches.
See {secRef CmdLevel} for a discussion of the significance
of command and user levels.

When the monitor processes a command line,
it does not remove the line from the command port's
input buffer, but merely sets a bit
which causes the next input operation
to remove the line.
That bit can be cleared
(enabling a program to read the line that
caused it to be executed) with
the {ttcallRef RESCAN}.

A rescan line can be forced by the {AuxCalRef !AXFRS}.

There is a call originally used by DDT for input from the
command port which has some rather unique (possibly useless)
characteristics: {CalliRef DDTIN}.

.endSec PortInMisc:
.
.use SKPINC.UUO;
.use SKPINL.UUO;
.use AUXCAL.SIC;
.use AUXCAL.SIL;
.use AUXCAL.SI;
.use REDNXT.UUO;
.use WAITCH.UUO;
.use RESCAN.UUO;
.use AUXCAL.FRS;
.use DDTIN.UUO;
.use CONT.UUO
.endSec PortIn:
     


     
     
     
.sec Output UUOs,PortOutCall:
.ind port output;
.
.sec Single Character Output,PortOutC:
There are a number of system calls to output a
single character to a port.
They differ according to
.b!list
--[IMG] Whether the character is output as an image
character or is subject to the normal processing
(including tab simulation and the like) for
output characters.
--[IMM] Whether the UUO's argument is immediate
or whether it points to the character to be output.
--[CMD] Whether the call applies only to the command
port or whether it takes an argument specifying
the port to be used.
.e!list
The calls are summarized in {TabRef TTYout} and described
in detail below.
.
.QueueTab TTYout;
.!pout(T,1,OUTCHR,output char [CMD],F,F,F,F)
.!pout(T,16,OUTCHI,output char [CMD/IMM],T,F,F,F)
.use AUXCAL.OCI;
.!pout(T,15,IONEOU,output char [CMD/IMG],F,T,F,F)
.!pout(F,3,!AXO8,output char [IMG],F,T,F,F)
.!pout(F,4,!AXO8I,output char [IMG/IMM],T,T,F,F)
.endSec PortOutC:
.
.sec String Output,PortOutS:
There are 6 system calls to output a string to
a port,
which have varying combinations of
.b!list
--[CMD] The call applies only to the command
port rather than taking an argument specifying
the port to be used.
--[PTR] The call takes as its argument the address of a
byte pointer (thus allowing
the call to be interrupted if the port's
output buffer becomes full,
since the monitor modifies the byte pointer
to point to the next character to be processed,
and allowing non-standard byte sizes
to some extent),
rather than the address of an ASCIZ string
(in which case the monitor cannot take an
i/o wait software interrupt in the
middle of outputting the string,
and the characters must always be
7 bits, even in Katakana mode)
--[STR] Same as PTR except user supplies a half-word count
of characters to be output rather than providing a null at the end.
The string descriptor consists of the character count in the first
word and the ILDB byte pointer in the second word.  The left half
of the first word is unused.
.e!list
The calls are summarized in {TabRef TTYOS} and described
in detail below.
.
.QueueTab TTYOS;
.!pout(T,3,OUTSTR,output string [STR/CMD],F,F,T,F)
.!pout(T,17,OUTPTR,output string [PTR/CMD],F,F,F,T)
.!pout(F,5,!AXPTR,output string [PTR],F,F,F,T)
.use auxcal.ost;
.use auxcal.opc;
.use auxcal.osf;
.use DDTOUT.UUO;
.endSec PortOutS:
.
.endSec PortOutCall:
.

     


     
     
     
.sec Port Block I/O UUOs,PBIOUUO:
.use AUXCAL.EBM;
.use AUXCAL.LBM;
.use AUXCAL.IBW;
.use AUXCAL.IBS;
.use AUXCAL.TBI;
.use AUXCAL.OB;
.use AUXCAL.TBO;
.endSec PBIOUUO:
     


     
     
     
.endSec Ports:
  ` (