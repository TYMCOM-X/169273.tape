.Sec Frames and Processes,Frames:
.ind session;ind Absolute Frame Number;
.ind job;
Tymcom-X provides slots called "frames" in which virtual address spaces
may be created and programs run.  Previous monitors have allowed only
one address space to be created by an incoming Tymnet circuit.  Since
this address space was the root of all activities generated by the
user, it became known as a "job".  P034/C and later releases allow many
such address spaces to be generated in a controlled fashion by a single
terminal user or incoming circuit.  Therefore "job" has become an
ambiguous term.

The entire complex of activities invoked by such a user or circuit is
known as a "session".  We have attempted to eliminate the word "job"
from this manual, using instead "session" and "frame", where each is
appropriate.

All of the information kept by the monitor about a frame is keyed on an
Absolute Frame number.  This number is assigned by the monitor when it
receives a login message from Tymnet, or when a frame creates another
frame.  Absolute Frame numbers are made available for reassignment when
a frame is logged out.

More information about how frames operate upon one another to create a
multi-frame session can be found on {secRef FrameOP}.

.sec Frame Identification,Ident:
.sec |Account User Numbers (AUN,PPN,FPN)|,AUN:
.ind AUN;ind Account User Number;
.ind GAN;ind Global Account Number;
.ind UUN;ind Universal User Number;
.ind FPN;ind Frame Program Number;
.ind PPN;ind Project Programmer Number;

An Account User Number (AUN) consists of an 18-bit Global Account Number
(GAN) and an 18-bit Universal User Number (UUN).  The AUN is used to
identify a frame for accounting and some security purposes.  It is
similar to DEC's PPN:  the term PPN is used in this document to refer
to those AUNs associated with the file system, and in some cases the
terms "project number" and "GAN", and "programmer number" and "UUN" are
used interchangibly.


A frame has associated with it three account numbers:

.myList
--the "frame AUN" is the account number corresponding to the username
under which the frame logged in.
--the "frame PPN" is the default directory for file access operations.
It is initially the same as the frame AUN but may be changed by the
{CalliRef CHGPPN}.  It and the frame AUN together determine which files
a frame is considered to own (see {SecRef FILEPROT}).
--the "frame FPN" is the account number corresponding to the directory
from which the current (or last) program was run.  If a process is
running with {HF} license the file system will allow it owner access to
files in the FPN directory.
.endList
.endSec AUN:
.sec User and Process Names,Names:
.ind user name;ind process name;
There are two names which are maintained for each frame:

.myList
--the user name
which corresponds to the accounting AUN and is the name supplied
by the user when logging in to the system.
--the process name 
which is the name of the program currently loaded in the frame's
virtual memory.
.endList

The user name is provided by the {CalliRef LOGIN}.
The process name is automatically set by the {CalliRef RUN} as well
as the RUN and GET commands.
A process may change its own name by executing a
{CalliRef SETNAM}.
The loader typically does a SETNAM to the name of the program it
just loaded.
.endSec Names:

.use CHGPPN.UUO;
.use GETPPN.UUO;
.use PJOB.UUO;
.use SETNAM.UUO;
.endSec Ident:


.sec Privilege,Privilege:
.ind LOGINN;
The initial value of the frame privilege word is provided either when
the LOGINN program performs a {calliRef LOGIN}, or when another frame
performs a {frmopRef !FOCFM}.  Some of the bits and fields in the
privilege word actually describe privileges, and cannot be changed
without license;  others, such as the monitor mode or time zone fields,
can be altered for any individual frame by that frame.

The current value of the frame privilege word can be read with a
{calliRef GETTAB} from the {GettabRef !GTPRV} table.

.QueueTab JBTPRV;
.use SETPRV.UUO;
.use SETMAI.UUO;
.use SETMAL.UUO;
.use SETINA.UUO;
.endSec Privilege:
     
.sec Frame License,License:
.ind file license;ind saved license;
.ind process license; ind license;

The monitor maintains three licenses for each frame:  frame license,
process license and saved license, each one being an 18-bit quantity
laid out as in {tabRef JBTLIC}.
Frame license belongs to the frame itself and represents
the "baseline" from which all process license is set.
Process license belongs to each process which inhabits the
frame.  It is re-initialized each time the PNO changes and can
be modified by the process with the {calliRef SETLIC}.
Saved license is a copy of the maximum process license retained by the
monitor to allow a process to reduce its license and then restore it.

The TYMCOM-X file system allows a process to save any or all of its
license on a file.  Subsequently, this file license can be used to set
up the process license for a particular frame.  When the monitor loads
a frame from a file.  for example the {CalliRef GETSEG} or {FrmopRef
!FOGET}, it sets up the process and saved licenses from the maximum of
the file license and the frame license (see {SecRef Image}).

The CORE n (where n is not 0), SSAVE, SAVE,
and FINISH commands set the saved and process licenses
back to the frame license.

A program can read the current frame and process license from the
{GettabRef !GTLIC} table.  See {tabRef GTFUN}.  The process license
bits are in the left half of the word returned and the frame license
bits are in the right half.

.QueueTab JBTLIC;
.use CHKLIC.UUO;
.use SETE.UUO;
.use SETLIC.UUO;
.endSec License:
     
.sec Frame Status,Status:
The frame status word contains various bits
which are mostly of interest to the monitor.
The JB.JAC and JB.LOG bits can be set
or cleared by any process with {JL} license,
and JB.JA2 by any process.

The frame status word can be read from the
{GettabRef !GTSTS} table.  See {TabRef GTFUN}.

.QueueTab JBTSTS;
.use SETJAL.UUO;
.endSec Status:
     
.sec Session control operations,SessCtl:
.
.use LOGIN.UUO;

.sec Project Codes,Pjc:
.ind project code verify bit;
The monitor keeps a "project code" for each frame.
The notion of a project code is different
from the notion of a frame's project number,
or GAN.
The project code is set by the CHPRJ UUO
(which, in turn, is executed by LOGINN and PROJEC
after they have verified, if necessary,
that the user is authorized to use that
project code).

The monitor also has a
"project code verify" bit for each frame,
which is also set by CHPRJ.
Until a frame's project-code-verify bit has been set,
no license is required to change its project code;
after it has been set,
{XC} or {RP} license is required.

The monitor writes a stream acounting record
every time a frame's project code is changed.
It also stores a frame's project code
(and its verify bit) into a three-word field
(.RBPJC) in the RIB of each non-UFD file created
by the frame.
(The .RBPJC field in UFDs is used by the
LOGINN and PROJEC programs
to store information specifying how to
(or whether to)
verify project codes).

To change a frame's project code,
a program executes
the {CalliRef CHPRJ}.
.
.use CHPRJ.UUO;
.endSec Pjc:
.
.sec Restricted Command Mode,RCM:
If the JP.RCM bit is set in a frame's frame privilege word,
the monitor will process only the commands
.b!ex
	EXIT	HALT	DETACH	CONTINUE
	LOGOUT	KJOB	BYE
.e!ex
If any other command is typed,
the monitor will execute the frame's
"restricted command file".
That restricted command program will receive the monitor parsed command
name in SIXBIT in user AC 1.

The restricted command file is specified
by executing
the {CalliRef SETRCF}.
.
.use SETRCF.UUO;
.endSec RCM:
.
.Sec Special Command Mode,SCM:
If the JP!CMD bit is set in a frame's frame privilege word,
and the user types an illegal command, the monitor will execute
the frame's "restricted command program".
That restricted command program will receive the monitor parsed command
name in SIXBIT in user AC 1.

The restricted command program is specified
by executing
the {CalliRef SETRCF}.
.
.endSec SCM:
.Sec Logout On Stop,LOS:
If the JP!LOS bit is set in the frame's frame privilege word,
LOGOUT will be forced on the frame if the frame is being stopped.
If this bit is set, Restriced Command Mode will be forced on the frame
at command dispatch time.

JP!LOS can be set with {CalliRef SETUUO}, but cannot be cleared.
.
.endSec LOS:
.use LOGOUT.UUO;
.Sec Alternate Logout Program,ALP:
.ind logging out;
.
.use LOGOFF.UUO;
.use SETALP.UUO;
.endSec ALP:

.use EVICT.UUO;
.use HANG.UUO;
.endSec SessCtl:
.sec Frame Generation and Control Operations, FrameOP:
.ind frame tree; ind session;
.ind children; ind executive program; ind XEXEC;
A variety of operations are available as subfunctions
of the {UuoRef FRMOP} to allow any process to create,
delete, move, and control the contents and privileges
of other frames.  For a quick summary, see {tabRef FOFUN}.

These operations allow a process to exercise all the control
over what goes on in another frame that could be
exercised by the user at his terminal under previous monitors.
The result is that a terminal user can develop a session
which consists of numerous address spaces [the different
frames] with different programs in them, related to one
another in a hierarchy known as a "frame tree".  A session
is a tree of frames whose root frame is ordinarily created by the
monitor in response to a network login message.

This root frame may contain any process, although
in many cases users will choose to have it contain
the system executive program XEXEC.

The root frame may create "children" (subordinate frames),
place programs in those child frames, run them in parallel
or serially, control their input/output abilities,
handle their exception conditions (ILL MEM REF, etc.),
give access to them to other processes in the system,
and even "hand them off" (graft them) to other sessions.

.sec Per Frame Program Number,PNO:
.ind PNO;
For each frame the system maintains a Program Number.
Every GET operation on a frame causes its PNO to be
incremented.  For a given frame, then, the PNO uniquely
identifies the program or process in the frame.  If a
new program is placed in the frame, process handles
(see {SecRef HAND})
to the previous program
become invalid because the new
program is identified by a new PNO.

The operations which change a frame's PNO are:
.myList
--!FOGET and GET command
--!FORUN, RUN command, and RUN UUO
--!FOCLR
.endList;
.endSec PNO:
.sec Universal Frame ID,UID:
.ind UID;
For each frame the system maintains a Universal Frame
ID which is assigned at creation of the frame and is
guaranteed unique to that frame during any incarnation
of the system (i.e., between system bring-up and crash
or take-down).  Absolute Frame Numbers on the other
hand, do not uniquely identify frames, since a frame
occupying slot N might be destroyed and another frame
created later in the same slot N.  The new frame would,
however, have a new UID by which it could be distinguished
from the old frame in that same Absolute Frame Number slot.
.endSec UID:

.sec Frame Descriptors,FrameDesc:
.ind absolute FD; ind Frame handle;
.ind licensed handle; ind process handle;

Frame Descriptors are the means by which a user program
talks about frames.  Frame Descriptors (FD's) come
in several types described in {tabRef FDESC}.  An FD is
an 18-bit quantity. In {tabRef FDESC} the bit-positions
are shown assuming that the FD is in a low-order
half-word, as is the case with most FRMOP arguments.

The subtype field is ignored for those types which
do not have subtypes.  For instance, an Absolute FD
(type 0) has no subtypes; the subtype field is treated as
being 0, so that the Absolute FD functions like a "job number"
functioned under previous monitors.
Likewise, the FD!SLF has no subtype; nor is the
data field used; if the caller passes 777777 as his FD,
he is referring to himself, in the same way that -1 has
traditionally referred to "self" in UUOs under previous monitors.

Any fields which are documented as "ignored" should
be set to zero, with the exception of 777777 for FD!SLF.
Non-zero data in these fields may produce strange results
in the future.
.QueueTab FDESC;
.sec Absolute FD,ABSFD:
FD!ABS handles exist automatically by their nature.
An Absolute FD (FD!ABS) will work only if some 
(depending on the operation)
combination of the
following conditions are met:

.myList
--caller has {SY} license
--caller has JP!TYM (Tymshare Proprietary) privilege
--caller has {RC} or {WC} license
--caller is parent of target
--caller has same AUN as target
--caller has same GAN as target, and caller has JP!ASV
(Acct. Supv.) privilege
.endList

In the last 2 cases, the caller is given access to the target
frame equivalent to {SY} license.
.endSec ABSFD:

.sec Other Frame FD,OTFFD:
Passing a FD of type FD!OTF causes the system to use the FD which
was most recently given to the {calliRef SETOTF}.
In addition to FRMOP,
the following UUOs will operate on the "other"
frame if the appropriate flag is set in
their arguments:

.myList
--{calliRef VPROT}
--{calliRef PAGSTS}
--{calliRef VALPAG}
--{calliRef PREREF}
--{calliRef VCREAT}
--{calliRef VREMOV}
--{calliRef VCLEAR}
--{calliRef VREPLC}
--{chanioRef !CHMFP}
.endList
.use SETOTF.UUO;
.endSec OTFFD:

.sec Handles,HAND:
A "handle" is a system construct which is a means
of accessing or changing data associated with a
frame.  It may be useful to consider a handle as a
"path" between frames.  The most significant facts about
handles are:
.myList
--A handle describes the operations for which its holder
may use it upon the object (target frame) which it names.
These are the Handle Access Rights
--A handle may be passed from frame to frame.
.endList
These two facts are an important part of the basis
of constructing
"capability-based systems"--that is, systems of 
programs which cannot talk about or affect anything
except those other objects for which they have been
given a name.
The "name" or "path" given to any program is the FD
itself.

.sec |Family FD's|,FDFAM:
Some handles are generated automatically
by the {FrmopRef !FOCFH}. The FD's for these handles
are the type FD!FAM, subtypes FM!CHL and FM!PAR. They
govern the effects parents can have upon their children
and vice-versa.
.endSec FDFAM:
.sec Created Handle,FDCRH:
The {FrmopRef !FOCFH} produces "created handles",
or FD's of type FD!CRH.
Created handles are of three subtypes:
.myList
--Frame Handle.  A frame handle is valid 
for as long as the frame it points to exists.
If the frame is destroyed, the handle becomes
invalid but may continue to exist for some time.
--Process Handle.  A Process handle is valid
only so long as the program within the target
frame is not replaced by another program. In
other words, a process handle grants access
to one incarnation of a program.
--Licensed Handle.  A Licensed handle grants
access to its target absolute frame number according to the
license stored in the handle.
(An Absolute Frame Descriptor also can function
as a licensed handle because the
access it grants is determined by
the process license of the caller at
the moment the Absolute FD is used.)
.endList;

.endSec FDCRH:
.endSec HAND:
.endSec FrameDesc:
.sec Access Rights, !AR:
.ind AR;
A system of Access Rights (AR) bits allows a very subtle and
flexible set of security measures to be developed between
processes executing in the system.  Access Rights define the ability
of a frame to perform certain functions.
See {tabRef ARTAB} for
the names and meanings of AR's currently defined.  
.QueueTab ARTAB;

.sec Maximum Frame Rights, MFR:
.ind MFR;
Every frame has some Access Rights, and the full set of
the Access Rights that it has at any one time is called
the Maximum Frame Rights; these are the maximum
rights which any CH!FRH to the frame may
possess.  When a frame is created, the Maximum Frame
Rights (MFR) are initialized to ALL rights (as listed 
in {tabRef ARTAB}).  When a
program is loaded into the frame with the monitor's
RUN or GET operations,
the protection code of the file and the PPN of the frame
into which the file is being loaded determine the setting
of the MFR:  the frame is either the file's Owner (same
PPN), project-mate (same GAN) or is part of "the public".
In addition, licenses on the frame and file affect the
initial MFR.  These are the conditions:
.myList
--if the file is Execute-Only (see {secRef EXO})
set the MFR to allow only a limited 
set of control functions to be applied to the frame.
Prevent any operations which would break Execute-Only
security, such as !FORVA.
--if the file has more license than the frame,
but is not Execute-Only,
set the MFR to allow frame handles to read information about the
frame and exercise the limited set of control functions
which are allowed in the Execute-Only case.  Prevent
any operations which could be used to exploit the license.
--if neither of these conditions applies, set the MFR
to ALL rights.
.endList
Another way of setting the MFR is to use the 
{frmopRef !FOSMF}.  This operation allows a frame to set its own
MFR or the MFR of any other frame to which it has
!ARSMF access.

Note that a process has the option of setting its
own MFR down from their initial values in order
to protect any information it wishes to keep to
itself.

Note also that if a frame wishes to access another frame, and
either manipulate that frame or gather information about that
frame, then it must have the proper license to do so.
See {tabRef ARTAB}.
.endSec MFR:
.sec |Handle Rights vs. Effective Rights|,HandEffAR:
.ind handle access rights; ind Effective Rights
.ind handle effective rights;

Every FD (and thus every handle) has associated with it
a set of "handle access rights", or "handle rights", which
are the rights for which the handle may possibly be 
exerciseits target frame.  However, if the target
frame has reduced its MFR, some handles to it may
contain rights which are not presently effective.
A handle's "effective rights" are those for which
it is currently good over the target frame.  Effective
rights may or may not be identical to handle rights.
These two sets of rights may be read with
.mylist;
--{frmopRef !FORAR}
--{frmopRef !FORER}
--{frmopRef !FOCAR} 
--{frmopRef !FOCER}
.endList;
.endSec HandEffAR:
.endSec !AR:
.QueueTab FRMOPE;
.QueueTab FOFUN;  <<call's FRMOP.TAB>>
.QueueTab FONUM;  <<call's FRMOP.TAB>>
.use FRMOP.UUO;
.DoTables;	  <<prevent nesting calls to FRMOP.TAB>>
.use FRMOPS.REQ;  <<call's FRMOP.TAB>>
.use EXIT.UUO;
.use FLEXIT.UUO;
.use FLSTOP.UUO;
.use SETSTV.UUO;
.
.endSec FrameOP:

.sec Temporary files,TempFiles:
The monitor provides each frame
with a small number of small in-core "files",
intended for such functions as passing command lines
between programs.
The TMPCOR files have three-character (SIXBIT)
file names.
Since there is only limited space in the monitor
for such files,
it is possible that a program
will be unable to create a TMPCOR file.
To get around this problem,
a convention exists where,
after trying and failing to create a TMPCOR
file,
a program creates a disk file
whose name is
.b!ex
	<3-digit decimal frame #><TMPCOR filename>.TMP
.e!ex
and a program which fails to find a TMPCOR
file likewise searches for the appropriate
disk file.

.use TMPCOR.UUO
.use TMPCOR.RRF
.use TMPCOR.RDF
.use TMPCOR.RWF
.use TMPCOR.RRD
.use TMPCOR.RDD
.use TMPCOR.RFS
.endSec TempFiles:
     
.endSec Frames:
 2@ 