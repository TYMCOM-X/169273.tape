

























                                         Yet Another Monitor Manual
                                         ___ _______ _______ ______

                                            "Cogito Ergo Spudd"
                                         (I think, therefore yamm)
                                         - Pliny the Junior 353 BC

                                               June 27, 1984































                                                                                William R. Soley
                                                                              Arthur A. Atkinson
                                                                          Tymshare, Incorporated
                                                                     Systems Technology Division
                                                                        20705 Valley Green Drive
                                                                           Cupertino, California
                                                                                           95014





            First Printing  July 1980
            Revised June 1984


            Copyright (C) 1979 by Tymshare, Inc.
            20705 Valley Green Drive
            Cupertino, CA   95014




                    All rights reserved.  No part of this document may be reproduced in any form
                    or by any means without permission in writing from Tymshare.





















                    The information in this document is subject to change without notice and
                    should not be construed as a commitment by Tymshare.  No responsibility is
                    assumed for any errors that may appear in this manual.





                                            Reader Comment Form



            This form is for reader comments on the documentation.  For comments and bug reports
            regarding the software, the user should submit a Tymshare Software Report (TSR).


            Document:          YAMM

            Manuscript:        YAMM  .PUB

            Compile date:      June 27, 1984

            Compile time:      10:22

            Your name:         [                                   ]

            Organization:      [                                   ]

            Telephone:         [(     )     -      ]

            Date submitted:    [   /   /19   ]

            Address:           [                                   ]

            City/State/Zip:    [                            ], [   ]   [       ]

            Reply required?    [ ] Yes    [ ] No


            Please show your comments below.  Please include document page number for any
            references to the text.  If possible, include a copy of the page with the problem
            marked.  Please also mention any things you find ommited or unclear.




































                                                     *  
                                                   *   *
                                                     *  


            June 27, 1984                                                      Table of Contents


                                             Table of Contents
                                             _____ __ ________



            Section

                List of Tables    iv

            1     Preface    1-1
            1.1      Conventions    1-1
            1.2      Abbreviations    1-1
            1.3      Acknowledgements    1-2
            1.4      Edition 2.1    1-2

            2     Frames and Processes    2-1
            2.1      Frame Identification    2-1
            2.2      Privilege    2-2
            2.3      Frame License    2-4
            2.4      Frame Status    2-6
            2.5      Session control operations    2-7
            2.6      Frame Generation and Control Operations    2-12
            2.7      Temporary files    2-37

            3     Virtual Memory    3-1
            3.1      High and Low Segments    3-1
            3.2      Job Data Area    3-3
            3.3      Core image files    3-5
            3.4      Execute-Only Programs    3-11

            4     Paging    4-1
            4.1      Hardware Paging    4-1
            4.2      Software Paging    4-1
            4.3      Creating Private Pages    4-3
            4.4      Unmapping Virtual Pages    4-4
            4.5      Replicating Virtual Pages    4-4
            4.6      Mapping File Pages    4-5
            4.7      Mapping Absolute Disk Pages    4-6
            4.8      Changing Page Protection    4-7
            4.9      Working Set Control    4-7
            4.10     Prereferencing Pages    4-9
            4.11     Uninterruptible Page Copy    4-10
            4.12     Paging Related Errors    4-11
            4.13     Page Faults    4-14
            4.14     Page Reference Bits    4-15
            4.15     Virtual Page Information    4-17

            5     General I/O    5-1
            5.1      Channels & I/O Initialization    5-1
            5.2      Device Assignment    5-1
            5.3      Channel Numbers    5-2
            5.4      Closing channels    5-2
            5.5      Releasing Channels    5-3
            5.6      File Status Bits    5-3
            5.7      Device Characteristics    5-4
            5.8      Device Manipulation    5-5
            5.9      Major I/O UUOs    5-8

            6     Buffered Mode I/O    6-1
            6.1      Buffer Ring Headers    6-1
            6.2      Buffer Format    6-2
            6.3      Buffer Setup    6-2
            6.4      Buffered I/O Operations    6-4
            6.5      I/O synchronization    6-6
            6.6      Buffered I/O Errors    6-6

            7     Dump Mode I/O    7-1
            7.1      Dump I/O Operations    7-1
            7.2      Dump I/O Errors    7-2
                                                     i


            Table of Contents                                                   YAMM edition 2.1

            Section
            8     Disk I/O    8-1
            8.1      Device Names    8-1
            8.2      Buffered I/O    8-2
            8.3      Dump I/O    8-2
            8.4      Directories    8-2
            8.5      Frame Search List    8-5
            8.6      Storage Allocation Table    8-5
            8.7      File Organization    8-5
            8.8      File Access Protection    8-6
            8.9      Directory Access Protection    8-7
            8.10     File Selection    8-8
            8.11     File Positioning    8-20
            8.12     Direct File Page Manipulation    8-23
            8.13     Specialized File Manipulation    8-25
            8.14     Reading Information    8-27
            8.15     Validating and Flushing    8-32

            9     Processor ID Mechanism    9-1
            9.1      Purpose of PID's    9-1
            9.2      Definition of PID    9-1
            9.3      Issuing PID's    9-1
            9.4      Authority Conferred by a PID    9-2
            9.5      Executing with a PID    9-2
            9.6      Manipulating the PID    9-2
            9.7      PID Handling on ENTER and RENAME    9-3
            9.8      PID's and Storage Accounting    9-3

            10    Port I/O    10-1
            10.1     Port Numbers and Device Names    10-1
            10.2     Command Ports    10-1
            10.3     Auxiliary Ports    10-2
            10.4     PTYs    10-3
            10.5     Reseting Ports    10-4
            10.6     Line Characteristic Word    10-4
            10.7     File Status Bits    10-4
            10.8     Port Operations    10-4
            10.9     Baud Rates    10-9
            10.10    Buffering and Backpressure    10-10
            10.11    Data Transmission Methods    10-11
            10.12    Character Handling    10-11
            10.13    Special Purpose Terminal Charactersitics    10-21
            10.14    Block I/O    10-21
            10.15    Port Creation,Moving,Deletion UUOs    10-23
            10.16    Port and Terminal Characteristics UUOs    10-29
            10.17    Echo,Break,Backpressure UUOs    10-35
            10.18    Port Input UUOs    10-36
            10.19    Output UUOs    10-43
            10.20    Port Block I/O UUOs    10-48

            11    Magnetic Tape I/O    11-1
            11.1     Device Names    11-1
            11.2     Recording Modes    11-1
            11.3     Parity    11-1
            11.4     Recording Density    11-1
            11.5     Begin and End of Tape Bits    11-2
            11.6     Buffered Tape I/O    11-2
            11.7     Dump Tape I/O    11-2
            11.8     MTAPE Operations    11-3
            11.9     UGETF Information    11-4

            12    Card Reader Input    12-1
            12.1     ASCII Mode Input    12-1
            12.2     Image Mode Input    12-1
            12.3     Binary Mode Input    12-1

            13    Line Printer Output    13-1
            13.1     Output    13-1
            13.2     Form Feeds    13-1
                                                     ii


            June 27, 1984                                                      Table of Contents

            Section
            13.3     KS2020 Line Printer Forms Control    13-1

            14    Paper Tape I/O    14-1
            14.1     Leaders and Trailers    14-1
            14.2     ASCII Mode I/O    14-1
            14.3     Image Mode I/O    14-1
            14.4     Image Binary Mode I/O    14-1
            14.5     Binary Mode I/O    14-2

            15    Plotter Output    15-1
            15.1     Output    15-1
            15.2     Hardware Action    15-1

            16    Interrupt System and Sleeping    16-1
            16.1     Trapping Arithmetic and Stack Overflow    16-1
            16.2     APRENB Interrupt System    16-1
            16.3     INTADR Interrupt System    16-3
            16.4     Sleeping    16-8
            16.5     APRENB/INTADR Interaction    16-9

            17    Club Facility    17-1
            17.1     Purpose    17-1
            17.2     Definition    17-1
            17.3     Use of the Club UUOs    17-1
            17.4     Club UUOs    17-3

            18    Environmental Information    18-1
            18.1     Dates and Times    18-1
            18.2     GETTAB tables and functions    18-3
            18.3     Addressing Monitor Memory    18-11
            18.4     Lights and Switches    18-13

            19    Miscellaneous Operations    19-1
            19.1     Operator Functions    19-1
            19.2     Executing IO instructions (User-IOT)    19-5
            19.3     Accounting Device Control Functions    19-6
            19.4     Obsolete and Unavailable Functions    19-6

            20    Accounting    20-1
            20.1     Special charging    20-1
            20.2     Royalty Charging    20-5
            20.3     Writing Stream Records    20-6
            20.4     Stream Accounting Data    20-7


            Appendix

                UUOSYM.MAC    A-1
                System Calls by Name    B-1
                System Calls by Number    C-1
                Index    D-1

















                                                    iii


            List of Tables                                                      YAMM edition 2.1


                                               List of Tables
                                               ____ __ ______


            Table


            Frames and Processes
            2-3      Frame Privilege Word    2-3
            2-5      Frame License Bits    2-5
            2-7      Frame Status Word    2-7
            2-8      Watch Bit Definitions    2-8
            2-13     Frame Descriptor Format    2-13
            2-16     Access Rights Definitions    2-16
            2-17     FRMOP standard error codes    2-18
            2-19     FRMOP calls by function    2-19
            2-20     FRMOP functions by number    2-20
            2-21     .FOCFM error codes    2-21
            2-27     System Start Vector Indicies    2-27
            2-28     Halt Status Classes & Types    2-28
            2-32     Rules for .FOCFH handle creation    2-32
            2-33     .FORSI Item Numbers    2-33

            Virtual Memory
            3-4      Job Data Area Locations    3-4

            Paging
            4-3      Page Protection Codes    4-3
            4-3b     VCREAT Error Codes    4-3
            4-7      VPROT Error Codes    4-7
            4-9      WSCTL Error Codes    4-9
            4-10     PREREF Error Codes    4-10
            4-11     BLTPAG error codes    4-11
            4-12     PERSET Error Codes    4-12
            4-13     Page-error Status-word    4-13
            4-14     VALPAG Error Codes    4-14
            4-14b    Page Fault Word    4-14
            4-15     PGRSTS and PGISTS word formats    4-15
            4-16     REFBIT Error Codes    4-16
            4-17     Page Status Word Format    4-17
            4-17b    PAGSTS Error Code    4-17
            4-19     VPGFIL Error Codes    4-19
            4-19b    VDSKPT Error Codes    4-19
            4-20     Standard Paging error Codes    4-20

            General I/O
            5-3      File Status Bits    5-3
            5-4      Data Modes    5-4
            5-5      Device Characteristics Word    5-5
            5-8      SYSDVF Function Codes    5-8
            5-9      CHANIOs by function    5-9
            5-10     CHANIOs by number    5-10

            Disk I/O
            8-5      Special UFD status bits    8-5
            8-7      File Protection Codes    8-7
            8-8      Directory Protection Bits    8-8
            8-9      File Access State Transition Rules    8-9
            8-10     Argument Codes    8-10
            8-11     Short Lookup Block    8-11
            8-12     Extended Lookup Block    8-12
            8-19     File Selection Error Codes    8-19
            8-28     DSKCHR Data Block    8-28
            8-29     DSKCHR Status Bits    8-29
            8-30     GOBSTR error codes    8-30
            8-31     STRUUO function codes    8-31
            8-31b    STRUUO error codes    8-31
            8-33     DSK: File Status Bits    8-33

                                                     iv


            June 27, 1984                                                         List of Tables

            Table
            Port I/O
            10-6     AUXCALs by function    10-6
            10-8     AUXCALs by number    10-8
            10-9     TTCALL functions by number    10-9
            10-25    RETACH error codes    10-25
            10-26    CREAUX Error Codes    10-26
            10-29    Port Event-Status Bits    10-29
            10-30    Line Characteristics Word    10-30
            10-32    Terminal Characteristics    10-32
            10-33    TTY: File Status Bits    10-33
            10-33b   Monitor Modes & Special Characters    10-33
            10-37    Port Character Input Calls    10-37
            10-43    Port Character Output Calls    10-43
            10-46    Port String Output Calls    10-46

            Magnetic Tape I/O
            11-4     MTAPE Functions    11-4
            11-5     UGETF Function Codes    11-5
            11-5b    FTA: File Status Bits    11-5

            Card Reader Input
            12-2     026 Card Codes    12-2
            12-2b    029 Card Codes    12-2
            12-3     CDR: File Status Bits    12-3

            Paper Tape I/O
            14-2     CDR: File Status Bits    14-2

            Plotter Output
            15-1     Plotter command bits    15-1
            15-2     PLT: File Status Bits    15-2

            Interrupt System and Sleeping
            16-3     APRENB Interrupt Bit Definitions    16-3
            16-4     Port Interrupt Cause Codes    16-4
            16-4b    General Interrupt Cause Codes    16-4
            16-7     INTRMT error codes    16-7

            Club Facility
            17-4     Club Interlock Status Flags    17-4
            17-7     Club Facility Standard Error Codes    17-7

            Environmental Information
            18-2     Time Zone Codes    18-2
            18-5     GETTAB tables by function    18-5
            18-7     GETTAB tables by number    18-7
            18-8     .GTFTR Bits (GETTAB -54)    18-8
            18-8b    .GTCNF (GETTAB +11) Items    18-8
            18-9     states word    18-9
            18-9b    .GTLOG Bits (GETTAB -24)    18-9
            18-9c    Terminal Identifier Codes    18-9
            18-10    .GTLVD (GETTAB 16) Items    18-10
            18-10b   .GTNSW Items (GETTAB 12)    18-10
            18-11    .GTODP(GETTAB +15) items (ONCDSK parameters)    18-11
            18-11b   .GTWSC(GETTAB +25) items (Wait State Codes)    18-11

            Miscellaneous Operations
            19-3     STTLK Error Codes    19-3
            19-5     SETABK control bits    19-5

            Accounting
            20-1     XCHARG functions by number    20-1
            20-3     .XCSET Error Codes    20-3
            20-4     XCHARG Charge Table Entries    20-4
            20-6     Stream Royalty Record Words 5,6,7,10    20-6
            20-7     PUTSAR error codes    20-7
            20-7b    Stream Accounting Record Types    20-7
            20-8     Stream Accounting Record Lengths    20-8
                                                     v


            List of Tables                                                      YAMM edition 2.1

            Table
            20-8b    Stream Record Std. Header words 0-4    20-8
            20-8c    Stream Record types 0-6 (GET/RUN etc) format    20-          20-8d    Change Project-Code Record words 5-7    20-8
            20-9     System Initialization Record words 0-1    20-9
            20-9b    Date Change Record words 0-5    20-9
            20-9c    Local Stream Accounting Record words 5-7    20-9
            20-9d    SETLIC/SETE Record words 5-7    20-9
            20-9e    License-Setting RUN Record words 0-2    20-9
            20-9f    LOGINN Record words 3-6    20-10
            20-10    Uptime Record words 0-2    20-10
            20-10b   Restart Record words 0-1    20-10
            20-10c   Stream Error Record words 0-1    20-10
            20-11    LOGOUT and CHKPNT stream record format    20-11
            20-12    XCHARG stream record format    20-12






















































                                                     vi


            June 27, 1984                            1                                   Preface


                                                 Section 1
                                                 _______ _
                                                  Preface
                                                  _______

                                             Table of Contents



            SubSection


            1.1      Conventions    1-1

            1.2      Abbreviations    1-1

            1.3      Acknowledgements    1-2

            1.4      Edition 2.1    1-2



















































                                                    1-i


                                                     1                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    1-ii


            June 27, 1984                            1                                   Preface





                                                 Section 1
                                                 _______ _
                                                  Preface
                                                  _______




            This document describes version P034 of the Tymshare Tymcom-X operating system.

            The material contained herein is provided primarily for the benefit of  the assembly
            language programmer.   Users of higher  level languages such  as FORTRAN,  COBOL and
            TymBasic may  have access to  some of the  calls described here  through subroutines
            provided  in libraries.   Also, languages  such as  BLISS and  SAIL provide  for the
            execution of these calls  within the syntax of the  language.  If you intend  to use
            these  calls from  one of  these higher  level languages,  you will  need  to become
            familiar with the way  the language presents its  data structures to the  call being
            executed in order to properly pass arguments between your program and the monitor.

            For MACRO programmers, there is a file SYS:UUOSYM.MAC which contains definitions for
            all of the uuos and functions described in this manual.  A copy of this file  may be
            found in the appendix.

            It is assumed that you are familiar with the PDP-10 instruction set as well  as with
            the architecture of  the machine as viewed  by a user program.   If this is  not the
            case, it would be advisable to obtain a copy of the following publications available
            from Digital Equipment Corp.:
                1)  MACRO-10 Assembler Reference Manual, AA-C780C-TB;
                    ________ _________ _________ ______
                2)  DECsystem-10 DECsystem-20 Processor Reference Manual, AA-H391A-TK;
                    ____________ ____________ _________ _________ ______


            1.1    Conventions
                   ___________

            Regarding  the  radix of  numbers,  this  manual attempts  to  follow  the following
            convention:
                1)  In  examples  of  MACRO  code,  MACRO  conventions  are  used;  that is,
                    everything  is  octal  unless preceded  by  "^D"  or  similar construct.
                    Numbers indicating bit positions are always decimal.
                2)  Numbers representing locations of memory are octal.
                3)  Numbers representing locations of bits in a word are decimal.
                4)  Numbers preceeded with "'" are octal.
                5)  Numbers  followed by  "." or  "^D" are  decimal (except  "." for  end of
                    sentence).
                6)  Numbers followed by  "K" or "P" (ie.  256K or 512P) are  decimal numbers
                    denoting an amount of core (in 1024 or 512 word blocks).


            1.2    Abbreviations
                   _____________

            The following abbreviations are used throughout this manual:
                ac             an accumulator
                AR             Access Rights
                BPI            Bits per inch
                c(x)           contents of location x
                CR             Carriage return
                CR LF          Carriage return, Line feed
                DEC            Digital Equipment Corporation
                DDB            Device Data Block
                E              Effective address
                EOF            End of File
                EPT            Exec Page Table
                EXT            File extension
                FD             Frame Descriptor
                I/O            Input and Output
                JBTPRV         Frame Privilege Word
                JBTSTS         Frame Status Word
                JOBDAT         "Job Data Area"
                                                    1-1


            Preface                                  1                          YAMM edition 2.1


                LDB            Line Data Block
                lh(x)          Left half of x
                LUD            Local User Directory
                MFD            Master File Directory
                OPR            Operator (or operator's terminal)
                PC             Program Counter
                PPN            Project Programmer Number
                PDL            Push Down List
                RIB            Retrieval Information Block
                rh(x)          Right half of x
                TTY            Terminal (teletype)
                UFD            User File Directory
                UPT            User Process Table
                UUO            User Unimplemented Operation (monitor call)
                VM             Virtual Memory (machine)


            1.3    Acknowledgements
                   ________________

            A large portion of the text  within this document was taken from The  Murray written
                                                                             ___  ______
            by Murray Bowles.  The document has been somewhat reformatted since then and has had
            a number of new  features added to keep it  current with P034.  Aside from  the text
            Murray provided, I would also like to thank him for a number of macros which  I have
            partially used in the YAMM.

            We wish to thank Mike Hinckley for his supply of Pub macros and general Pub support.
            Pub is a real animal and it often takes at least two to quiet it.

            I also wish to thank my wife, Becky, for putting up with the long, late  hours spent
            on this project, and for bringing me little snacks as I worked.

            Credit for the name (Yet Another  Monitor Manual) goes to Scott Daniels  who thought
                                 ___ _______  _______ ______
            of it one night at 2:00 AM at the Red Coach.

            Bill Soley


            1.4    Edition 2.1
                   _______ ___

            Edition 2.1 updates the YAMM for the P034/M monitor release.  Basic research for the
            revision was  begun by  Greg Matoka.  Carl  Baltrunas and  Ken Dawson  have provided
            valuable help and advice in both wording and content.

            Lois Lindley
























                                                    1-2


            June 27, 1984                            2                      Frames and Processes


                                                 Section 2
                                                 _______ _
                                            Frames and Processes
                                            ______ ___ _________

                                             Table of Contents



            SubSection


            2.1      Frame Identification    2-1
            2.1.1       Account User Numbers (AUN,PPN,FPN)    2-1
            2.1.2       User and Process Names    2-1
            2.1.3       CHGPPN: change frame PPN (CALLI +74)    2-2
            2.1.4       GETPPN: get frame PPN (CALLI +24)    2-2
            2.1.5       PJOB: get frame number (CALLI +30)    2-2
            2.1.6       SETNAM: set frame name (CALLI +43)    2-2

            2.2      Privilege    2-2
            2.2.1       SETPRV: set frame privilege word (CALLI -11)    2-2
            2.2.2       SETMAL: set mail-waiting bit (CALLI -17)    2-3
            2.2.3       SETMAI: set new mail waiting bit (CALLI -145)    2-4
            2.2.4       SETINA: set inactivity timeout (CALLI -146)    2-4

            2.3      Frame License    2-4
            2.3.1       CHKLIC: check settable license (CALLI -31)    2-4
            2.3.2       SETE: set frame license (CALLI -7)    2-5
            2.3.3       SETLIC: set process license (CALLI -10)    2-6

            2.4      Frame Status    2-6
            2.4.1       SETJAL: set frame status bits (CALLI -21)    2-6

            2.5      Session control operations    2-7
            2.5.1       LOGIN: log a frame in (CALLI +15)    2-7
            2.5.2       .STWAT: set WATCH bits (SETUUO fn 6)    2-8
            2.5.3       Project Codes    2-8
                           CHPRJ: change project code (CALLI -61)    2-8
            2.5.4       Restricted Command Mode    2-9
                           SETRCF: set restricted cmnd file (CALLI -57)    2-9
            2.5.5       Special Command Mode    2-9
            2.5.6       Logout On Stop    2-9
            2.5.7       LOGOUT: log a frame out (CALLI +17)    2-10
            2.5.8       Alternate Logout Program    2-10
                           LOGOFF: Run Alternate Logout Program (CALLI -130)    2-10
                           SETALP: Set Alternate Logout Program (CALLI -127)    2-10
            2.5.9       EVICT: Cause Notice to Quit Interrupt (CALLI -134)    2-10
            2.5.10      Inactivity Logout    2-11
            2.5.11      HANG: hang a port or frame or frames (CALLI -32)    2-11

            2.6      Frame Generation and Control Operations    2-12
            2.6.1       Per Frame Program Number    2-12
            2.6.2       Universal Frame ID    2-12
            2.6.3       Frame Descriptors    2-12
                           Absolute FD    2-13
                           Other Frame FD    2-13
                              SETOTF: set other-frame FD (CALLI -126)    2-14
                           Handles    2-14
                              Family FD's    2-14
                              Created Handle    2-14
            2.6.4       Access Rights    2-14
                           Maximum Frame Rights    2-15
                           Handle Rights vs. Effective Rights    2-17
            2.6.5       FRMOP: Frame Operation (op code 044)    2-17
            2.6.6       Tree manipulation FRMOPs    2-20
                           .FOCFM: create frame (FRMOP fn 1)    2-20
                           .FOGFT: Graft Frame Subtree (FRMOP fn 24)    2-22
            2.6.7       Memory manipulation FRMOPs    2-22
                           .FORVA: read frame virtual address (FRMOP fn 2)    2-22
                                                    2-i


            Frames and Processes                     2                          YAMM edition 2.1

            SubSection
                           .FOWVA: write frame virtual address (FRMOP fn 3)    2-22
                           .FOREP: VREPLC to/from another frame (FRMOP fn 7)    2-23
                           .FOVRM: VREMOV in another frame (FRMOP fn 10)    2-23
                           .FOVCL: VCLEAR in another frame (FRMOP fn 11)    2-23
                           .FOGET: Setup frame core image from file (FRMOP fn 32)    2-23
                           .FOSAV: SAVE frame core image on file (FRMOP fn 34)    2-24
                           .FOSSA: SAVE frame core image on SHR file (FRMOP fn 35)    2-24
            2.6.8       State manipulation FRMOPs    2-24
                           .FOJMP: gate jump to frame (FRMOP fn 0)    2-24
                           .FOSAA: start frame at absolute address (FRMOP fn 4)    2-25
                           .FOHLT: halt frame (FRMOP fn 5)    2-25
                           .FORPC: Read Frame PC (FRMOP fn 6)    2-25
                           .FOCLR: Clear a Frame (FRMOP fn 14)    2-26
                           .FOSVA: start frame at vector address (FRMOP fn 22)    2-26
                           .FOHST: Read Halt Status Block (FRMOP fn 23)    2-27
                           .FOCON: continue frame (FRMOP fn 25)    2-29
                           .FOGIN: Gate-jump Initialization (FRMOP fn 26)    2-29
                           .FORUN: RUN program in frame (FRMOP fn 33)    2-29
                           .FOSTP: stop frame for non-privileged user (FRMOP fn 41)    2-30
                           .FOFCF: force command on frame (FRMOP fn 42)    2-30
                           .FOCPC: change project code for frame (FRMOP fn 43)    2-30
            2.6.9       Rights and Handles FRMOPs    2-30
                           .FOCFH: Create Handle (FRMOP fn 12)    2-30
                           .FODFH: Destroy Handle (FRMOP fn 13)    2-32
                           .FORSI: Read Standard Access Rights Info (FRMOP fn 15)    2-33
                           .FORAR: Read Handle Access Rights (FRMOP fn 16)    2-33
                           .FORER: Read Handle Effective Rights (FRMOP fn 17)    2-33
                           .FOSMF: Set Max Frame Rights (FRMOP fn 20)    2-34
                           .FOCHR: Change Handle Rights (FRMOP fn 21)    2-34
                           .FOVCH: Validate Child Rights (FRMOP fn 27)    2-34
                           .FOCAR: Read Child Access Rights (FRMOP fn 30)    2-35
                           .FOCER: Read Child Effective Rights (FRMOP fn 31)    2-35
                           .FORFA: Read Frame Attribute (FRMOP fn 36)    2-35
                           .FOWFA: Write Frame Attribute (FRMOP fn 37)    2-35
                           .FOXFA: Exchange Frame Attributes (FRMOP fn 40)    2-35
            2.6.10      EXIT: stop frame execution (CALLI +12)    2-36
            2.6.11      FLEXIT: fail exit, don't continue (CALLI -142)    2-36
            2.6.12      FLSTOP: fail exit, continue allowed (CALLI -147)    2-36
            2.6.13      SETSTV: set start vector address (CALLI -137)    2-37

            2.7      Temporary files    2-37
            2.7.1       TMPCOR: do TMPCOR file i/o (CALLI +44)    2-37
            2.7.2       .TCRRF: read TMPCOR file (TMPCOR fn 1)    2-37
            2.7.2       .TCRDF: delete TMPCOR file (TMPCOR fn 2)    2-37
            2.7.3       .TCRWF: write TMPCOR file (TMPCOR fn 3)    2-38
            2.7.4       .TCRRD: read TMPCOR directory (TMPCOR fn 4)    2-38
            2.7.4       .TCRDD: clear TMPCOR directory (TMPCOR fn 5)    2-38
            2.7.5       .TCRFS: get free space count (TMPCOR fn 0)    2-38


            Table

            2-3      Frame Privilege Word    2-3
            2-5      Frame License Bits    2-5
            2-7      Frame Status Word    2-7
            2-8      Watch Bit Definitions    2-8
            2-13     Frame Descriptor Format    2-13
            2-16     Access Rights Definitions    2-16
            2-17     FRMOP standard error codes    2-18
            2-19     FRMOP calls by function    2-19
            2-20     FRMOP functions by number    2-20
            2-21     .FOCFM error codes    2-21
            2-27     System Start Vector Indicies    2-27
            2-28     Halt Status Classes & Types    2-28
            2-32     Rules for .FOCFH handle creation    2-32
            2-33     .FORSI Item Numbers    2-33


                                                    2-ii


            June 27, 1984                            2                      Frames and Processes





                                                 Section 2
                                                 _______ _
                                            Frames and Processes
                                            ______ ___ _________




            Tymcom-X  provides slots  called "frames"  in which  virtual address  spaces  may be
            created and programs run.  Previous monitors have allowed only one address  space to
            be created by an incoming Tymnet circuit.  Since this address space was the  root of
            all activities generated  by the user,  it became known  as a "job".   P034/C allows
            many  such address  spaces  to be  generated in  a  controlled fashion  by  a single
            terminal user or incoming circuit.  Therefore "job" has become an ambiguous term.

            The entire complex  of activities invoked by  such a user or  circuit is known  as a
            "session".  We have  attempted to eliminate the  word "job" from this  manual, using
            instead "session" and "frame", where each is appropriate.

            All of the  information kept by the  monitor about a frame  is keyed on  an Absolute
            Frame number.   This number  is assigned  by the  monitor when  it receives  a login
            message from Tymnet, or when a frame creates another frame.  Absolute  Frame numbers
            are reassigned when a frame is killed (logged out).

            More information about how frames  operate upon one another to create  a multi-frame
            session can be found on 2-12.


            2.1    Frame Identification
                   _____ ______________

            2.1.1    Account User Numbers (AUN,PPN,FPN)
                     _______ ____ _______ _____________

            An Account User Number  (or AUN) consists of  an 18-bit Global Account  Number (GAN)
            and an 18-bit Universal User Number (UUN).  The AUN is used to identify a  frame for
            accounting and some security purposes.  It is similar to DEC's PPN: the term  PPN is
            used in this document to refer to those AUNs associated with the file system, and in
            some cases the terms "project  number" and "GAN", and "programmer number"  and "UUN"
            are used interchangibly.

            A frame has associated with it three AUNs:
                1)  the "frame AUN" is the AUN corresponding to the username under which the
                    frame logged in
                2)  the  "frame PPN"  is initially  the same  as the  frame AUN  but  may be
                    changed  by  the CHGPPN  UUO  (CALLI +74, pg. 2-2).   It  identifies the
                    default  directory for  file  access operations;  it and  the  frame AUN
                    together determine which files a frame is considered to own (see 8-6)
                3)  the "frame FPN" is the AUN corresponding to the directory from which the
                    current (or last)  program was run.  If  a process is running  with Home
                    File (HF)  the file  system will  allow it  access to  files in  the FPN
                    directory.

            2.1.2    User and Process Names
                     ____ ___ _______ _____

            There are two names which are maintained for each frame:
                1)  the user name  which corresponds to the  accounting AUN and is  the name
                    supplied by the user when logging in to the system.
                2)  the process name  which is the name  of the program currently  loaded in
                    the frame's virtual memory.
            The  user name  is provided  by  the LOGIN  UUO (CALLI +15,  pg. 2-7).   The process
            name is automatically  set by the  RUN UUO (CALLI +35, pg. 3-7)  as well as  the RUN
            and GET  commands.  A  process may  change its own  name by  executing a  SETNAM UUO
            (CALLI +43,  pg. 2-2).   The loader  typically  does a  SETNAM  to the  name  of the
            program it just loaded.




                                                    2-1


            Frames and Processes                     2                          YAMM edition 2.1


            2.1.3    CHGPPN: change frame PPN (CALLI +74)
                     _______ ______ _____ ___ ______ ____

                    MOVE    ac, [ppn]
                    CHGPPN  ac,
                      error return  ; no Jacct (JL) license
                    normal return

            If the process does not have  Jacct (JL) license, take the error  return; otherwise,
            set the frame PPN to <ppn> and skip-return.

            2.1.4    GETPPN: get frame PPN (CALLI +24)
                     _______ ___ _____ ___ ______ ____

                    GETPPN  ac,
                    return1
                    return2

            Set c(<ac>) to the frame  PPN.  Nonskip-return if JB.JAC =  0, or if JB.JAC =  1 and
            this is the only frame running with  this PPN.  Skip-return is JB.JAC = 1  and there
            are other frames running with this PPN.

            2.1.5    PJOB: get frame number (CALLI +30)
                     _____ ___ _____ ______ ______ ____

                    PJOB    ac,
                    only return

            Set AC to the caller's Absolute Frame number, and return.

            2.1.6    SETNAM: set frame name (CALLI +43)
                     _______ ___ _____ ____ ______ ____

                    MOVE    ac, [SIXBIT /program name/]
                    SETNAM  ac,
                    only return

            Set  the frame's  program  name to  <program name>  and  clear the  frame  FPN (this
            effectively turns  off Home File  (HF) license,  since there are  no files  with PPN
            0,,0).


            2.2    Privilege
                   _________

            The initial value of .GTPRV for  a frame is provided either when the  LOGINN program
            performs  a  LOGIN  UUO  (CALLI +15, pg. 2-7),  or  when  another  frame  performs a
            .FOCFM UUO  (FRMOP fn 1, pg. 2-20).  Some  of the bits  and fields in  the privilege
            word actually describe  privileges, and cannot  be changed without  license; others,
            such as the monitor mode or time zone fields, can be altered by anyone.

            2.2.1    SETPRV: set frame privilege word (CALLI -11)
                     _______ ___ _____ _________ ____ ______ ____

                    MOVE    ac, priv
                    SETPRV  ac,
                    only return

            where <priv> is a frame privilege word, as shown in Table 2-3 

            Set those fields in the current  frame's frame privilege word which are  marked with
            "*" in Table 2-3   to the the corresponding  fields of <priv>, leaving  the unmarked
            fields unchanged.  If the JP.COR field is greater than JP.CRM, reduce it to JP.CRM.

            Return.









                                                    2-2


            June 27, 1984                            2                      Frames and Processes


                                                 Table 2-3 
                                                 _____ ___ 
                                            Frame Privilege Word
                                            _____ _________ ____


            Symbol   Bits      Description

            * - indicates that this field is settable with the SETPRV UUO, (see 2-2).

            JP.LOS   1B0       * logout on stop
            JP.NAT   1B1       * no attach at login
            JP.DST   1B2       * daylight savings applies
            JP.ZON   37B7      * applicable time zone (see Table 18-2 ).
            JP.MAI   1B8       new mail-waiting
            JP.INA   1B9       * use default inactivity timeout
            JP.CMD   1B10      * special command mode
            JP.COR   177B17    * max core for frame
                               (max / 4) + 1 where max is the maximum number of pages that can
                               exist in the frame's address space at any one time.  This field
                               can be set to any value up to the value stored in JP.CRM
            JP.EXO   1B18      execute only program
            JP.DOP   3B20      * disconnect options
                               one of the following which determine the action taken upon
                               disconnect (circuit zapper received on command port):
                               .JPLOG    0         Logout on disconnect
                               .JPDET    1         Detach on disconnect
                               .JPCON    2         Continue on disconnect
                               .JPDTO    3         Detach (15 min timeout)
            JP.TYM   1B21      Tymshare proprietary
            JP.ASV   1B22      account supervisor
            JP.MAL   1B23      mail-waiting
                               set by the SETMAL UUO, and cleared by the command processor when
                               it prints the "MAIL WAITING" message.
            JP.XOG   1B24      execute only get
                               Set by the monitor while it is in the process of loading an
                               execute-only program.
            JP.BUD   1B25      tru budget being used
            JP.RCM   1B26      * restricted command mode.
            JP.MOD   3B28      * monitor mode
                               .JPMPD    0         PDP-10 mode
                               .JPMXE    1         XEXEC mode
                               .JPMXJ    2         XEXECJ (Japan)  mode
                               .JPMSU    3         SUDS mode
            JP.CRM   177B35    maximum value for JP.COR which can be set by SETPRV


            2.2.2    SETMAL: set mail-waiting bit (CALLI -17)
                     _______ ___ ____________ ___ ______ ____

                    MOVEI   ac, addr
                    SETMAL  ac,
                    only return

            where <addr> points to a word containing 0 to set mail-waiting
                    for all frames, or to a (2-word) SIXBIT username to set
                    mail-waiting for all frames logged-in to that username.

            If the current process  cannot delete a file in  SYS that has ALL NO  NO protection,
            just return.

            If c(<addr>) = 0, set the mail-waiting bit for every frame in the system and return.

            if c(<addr>)  is nonzero, set  the mail-waiting  bit for every  frame in  the system
            logged-in with the username pointed to by <addr> and return.






                                                    2-3


            Frames and Processes                     2                          YAMM edition 2.1


            2.2.3    SETMAI: set new mail waiting bit (CALLI -145)
                     _______ ___ ___ ____ _______ ___ ______ _____

                    MOVEI   ac, addr
                    SETMAI  ac,
                    only return

            This is the same as SETMAL (CALLI-17) except that JP.MAI gets set instead of JP.MAL.

            2.2.4    SETINA: set inactivity timeout (CALLI -146)
                     _______ ___ __________ _______ ______ _____

                    MOVEI   ac, limit in minutes
                    SETINA  ac,
                      error return
                    normal return

            If the limit requested by the user is greater than 17 bits, error return; otherwise,
            set the timeout limit to c<ac> in minutes.  When no job activity occurs  within this
            limit, the process  will be evicted  if enabled for  eviction, otherwise it  will be
            hung (killed  regardless of hang/zap  action specified by  user).  (See  also .GTMOD
            GETTAB table 18-4)


            2.3    Frame License
                   _____ _______

            The  monitor maintains  three licenses  for  each frame,  each one  being  an 18-bit
            quantity laid out as in Table 2-5 .   Frame license belongs to the frame  itself and
            represents the "baseline"  from which all process  license is set.   Process license
            belongs to each process which inhabits the frame; it is re-initialized when  the PNO
            changes and can  be set by  the SETLIC UUO  (CALLI -10, pg. 2-6).  File  license can
            be used  to set  up process  license if the  file is  loaded into  the frame  by the
            monitor.

            When  the monitor  loads a  frame from  a file,  it sets  up the  process  and saved
            licenses from  the maximum  of the  file license  and the  frame license  (see 3-5).
            The  saved license  is retained  by the  monitor so  that a  process can  reduce its
            license with SETLIC UUO (CALLI -10, pg. 2-6) and then restore it.

            The CORE n (where n  is not 0), SSAVE, SAVE,  and FINISH commands set the  saved and
            process licenses back to the frame license.

            A program  can read the  current frame  and process license  from the  .GTLIC GETTAB
            table.  See Table 18-5 .  The process license bits are in the left half of  the word
            returned and the frame license bits in the right half.

            2.3.1    CHKLIC: check settable license (CALLI -31)
                     _______ _____ ________ _______ ______ ____

                    MOVE    ac, [bits,,addr]
                    CHKLIC  ac,
                    only return

            where <bits> is '1 to use c(<addr>+1) in place of the current
                                    frame's process,,frame license
                          + '2 to check the license settable for a file
                                    rather than the license settable for the frame

            and <addr> points to a block of the form
                    wd 0    proc,,frame lic desired (or 0,,file lic)
                    wd 1    proc,,frame current license (if '1 bit is set)
                    wd 2    XOR of file and frame PPN (if '2 bit is set)

            If the '1 bit of <bits> is set,

                let <cproc> be c(<addr>+1 left) and <cframe> be c(<addr>+1 right); otherwise
                let them be the current process and frame licenses.

            If the '2 bit of <bits> is set,


                                                    2-4


            June 27, 1984                            2                      Frames and Processes


                Set  <dlic> to  c(<addr> right).   Turn  off those  bits in  <dlic>  which a
                process whose license was <cproc> and whose relationship to the owner of the
                file was as specified by c(<addr>+2).  Set c(<ac> right) to <dlic>.

            Otherwise,

                Set <dproc>  to c(<addr> left)  and <dframe> to  c(<addr> right).   Turn off
                those  bits in  <dproc>  and <dframe>  which  a process  running  with frame
                license <cframe>  and process license  <cproc> could not  set with  a SETLIC
                UUO.  Set c(<ac> left) to <dproc> and c(<ac> right) to <dframe>.

            Return.


                                                 Table 2-5 
                                                 _____ ___ 
                                             Frame License Bits
                                             _____ _______ ____


            name     bits  function

            LC.WC    1B0   Write Core (POKE UUO)
            LC.RC    1B1   Read Core (VPEEK UUO)
            LC.OP    1B2   Operator (SETUUO UUO)
            LC.SY    1B3   SYSTAT (read protected GETTAB tables)
            LC.GD    1B4   Get Devices (INIT devices other than TTY and DSK)
            LC.TD    1B5   Transfer Devices (REASSI UUO)
            LC.ST    1B6   Manipulate Structures (manipulate file structures using STRUUO UUO)
            LC.HF    1B7   Home Files (allow access as owner to files whose PPN matches the
                           frame FPN)
            LC.JL    1B8   Privileged System Program (set restricted bits in the frame status
                           word; set JBTAUN, JBTPPN, etc; read/write any UFD)
            LC.AC    1B9   Auxiliary Circuits (build more than two aux circuits; build an aux
                           circuit to a AUN other than the frame's own)
            LC.XC    1B10  XCHARG (adjust charges using the XCHARG UUO)
            LC.RPS   3B15  read privileges (a field)
                           .LCRP    1     read project
                           .LCRF    2     read files
                           .LCRA    3     read absolute
            LC.WPS   3B17  write privileges (a field)
                           .LCWP    1     write project
                           .LCWF    2     write files
                           .LCWA    3     write absolute


            2.3.2    SETE: set frame license (CALLI -7)
                     _____ ___ _____ _______ ______ ___

                    MOVEI   ac, [
                            ASCII /password word 1/
                            ASCIZ /password word 2/
                            password number
                            0,,desired license
                    ]
                    SETE    ac,
                      error return
                    normal return

            Hash  the two-word  password supplied  and check  the result  against the  hash code
            stored for <password number> in the monitor: if the two do not match, error-return.

            Set the frame license to <desired license> after turning off any license in <desired
            license> that is not permitted by  the license for <password number> in  the monitor
            tables, and setting the read  (write) privilege to 0 if <desired  license> specifies
            more privilege than that table entry; then skip-return.





                                                    2-5


            Frames and Processes                     2                          YAMM edition 2.1


            2.3.3    SETLIC: set process license (CALLI -10)
                     _______ ___ _______ _______ ______ ____

                    MOVE    ac, [process,,frame]
                    SETLIC  ac,
                    only return

            Let <max> be the maximum of the current frame license and saved license.

            Set the process license to <process> after turning off any license in <process> that
            is  not set  in <max>,  and setting  the read  (write) privilege  to 0  if <process>
            specifies more privilege than <max>.

            If <max> does not have Write Core (WC) set, set <max> to the current  frame license.
            (Note that Write Core (WC) was not required to increase frame license under previous
            monitors.)

            Set the frame license  to <frame> after turning off  any license in <frame>  that is
            not set in <max>, turning off  Home File (HF) license, and setting the  read (write)
            privilege to 0 if <frame> specifies more privilege than <max>.

            Return.


            2.4    Frame Status
                   _____ ______

            The frame  status word contains  various bits  which are mostly  of interest  to the
            monitor.  The JB.JAC and JB.LOG bits can be set or cleared by any process with Jacct
            (JL) license, and JB.JA2 by any process.

            The frame status word can be read from the .GTSTS GETTAB table.

            2.4.1    SETJAL: set frame status bits (CALLI -21)
                     _______ ___ _____ ______ ____ ______ ____

                    MOVE    ac, status
                    SETJAL  ac,
                      error return
                    normal return

            If the process has Jacct (JL)  license, set JB.JAC, JB.LOG, and JB.JA2 in  the frame
            status word from the corresponding bits of <status> and skip-return.

            If the process does not have Jacct (JL) license, set JB.JA2 in the frame status word
            from the corresponding bit  of <status>, then take  the normal return if  the JB.JAC
            and JB.LOG bits in the two match and the error return if they do not.
























                                                    2-6


            June 27, 1984                            2                      Frames and Processes


                                                 Table 2-7 
                                                 _____ ___ 
                                             Frame Status Word
                                             _____ ______ ____


            * - settable with SETJAL UUO (CALLI -21, pg. 2-6)

            Symbol   Bits     Description

            JB.RUN   1B0      Frame is runnable
            JB.CMW   1B1      Waiting to execute command
                              set only if monitor-level command (e.g. RUN, WHO, FILES, LOG etc.)
                              is pending but cannot immediately be executed
            JB.MRQ   1B2      Frame has page faulted and needs the swapper to swap something in;
                              OR the monitor has swapped out the frame's context pages
            JB.JNA   1B3      Frame number assigned
            JB.JER   1B4      A monitor-detected error has occurred - causes the CONTINUE
                              command to fail
            JB.ESC   1B9      An escape was typed while the frame was in command mode and not in
                              input wait
            JB.WSC   37B14    Wait state code (zero if process is running) see (Table 18-11b)
            JB.LOG   1B15     * Frame is logged in - cleared by the LOGOUT program just before
                              executing the LOGOUT UUO (settable with SETJAL if process has
                              Jacct (JL) license)
            JB.JRQ   1B16     Frame must be requeued
            JB.JAC   1B17     * Frame cannot be stopped; this makes the frame immune to escapes
                              and to the HALT command (settable with SETJAL if process has Jacct
                              (JL) license)
            JB.WAK   1B19     WAKE pending (see 16-9, 17-6)
            JB.JA2   1B20     * Frame shouldn't be stopped.  A nonprivileged version of JB.JAC
                              (settable with SETJAL)
            JB.UTR   1B21     Trap to user on UUO exit
            JB.DCN   1B22     Waiting for oper action
            JB.SCH   1B23     Frame must be rescheduled
            JB.PRF   1B24     The frame has prereferenced a page that was not in core
            JB.SIP   1B25     The swapper is currently bringing in pages for the frame
            JB.SCP   1B26     The swapper has taken away pages from the frame (cleared when the
                              frame's in-core-protect time is reset)



            2.5    Session control operations
                   _______ _______ __________

            2.5.1    LOGIN: log a frame in (CALLI +15)
                     ______ ___ _ _____ __ ______ ____

                    MOVE    ac, [-count,,addr]
                    LOGIN   ac,
                    only return     ;no return if this contains a HALT

            where <addr> points to a block of <count> words:
            JBTPPN   wd 0   initial frame PPN
            JBTPRV   wd 1   initial frame privilege word
            JBTAUN   wd 2   initial frame AUN
            JBTUNM   wd 3   first word of SIXBIT username
            JBTUN1   wd 4   second word of SIXBIT username
                     wd 5   ASCII characters 1-5 of project code
                     wd 6   ASCII characters 6-10 of project code
                     wd 7   ASCII characters 11-12 of project code

            If JB.LOG is set for the frame (already logged-in), abort the process and store halt
            status HT.ILU for the frame.

            Copy as many  words as are  defined or specified  by <count>, whichever  is smaller,
            into  the appropriate  monitor tables.   Set JB.LOG  in the  frame status  word.  If
            JP.COR is greater than JP.CRM, set JP.COR = JP.CRM.

            If the instruction following  the LOGIN UUO is a  HALT, perform the equivalent  of a
            RELEAS UUO for all initted channels, type a prompt sequence on the command port, and
            put the port into command mode; otherwise just return.
                                                    2-7


            Frames and Processes                     2                          YAMM edition 2.1


            If project code is supplied in words 5-7, WRTACR is called to write a  LOGINN stream
            record.  The project code information is  in the same form as the argument  block to
            CHPRJ UUO (CALLI -61, pg. 2-8).

            2.5.2    .STWAT: set WATCH bits (SETUUO fn 6)
                     _______ ___ _____ ____ _______ __ __

                    MOVE    ac, [.STWAT,,watch]
                    SETUUO  ac,
                      JFCL  ; never taken
                    normal return

            Set the right half of the frame's watch word to <watch> and skip-return.


                                                 Table 2-8 
                                                 _____ ___ 
                                           Watch Bit Definitions
                                           _____ ___ ___________


            Name     Bit   Function

            ST.WDY   1B19  time-of-day
            ST.WRN   1B20  run time (TRUs)
            ST.WWT   1B21  wait time
            ST.WDR   1B22  disk reads (blocks)
            ST.WDW   1B23  disk writes (blocks)


            2.5.3    Project Codes
                     _______ _____

            The monitor keeps a "project code" for each frame.  The notion of a project  code is
            different from the notion of a frame's project number, or GAN.  The project  code is
            set by the CHPRJ  UUO (which, in turn, is  executed by LOGINN and PROJEC  after they
            have verified, if necessary, that the user is authorized to use that project code).

            The monitor also has a "project code  verify" bit for each frame, which is  also set
            by  CHPRJ.  Until  a frame's  project-code-verify bit  has been  set, no  license is
            required to change  its project code;  after it has been  set, XCharge (XC)  or Read
            Project (RP) license is required.

            The monitor writes a  stream acounting record every  time a frame's project  code is
            changed.   It  also stores  a  frame's project  code  (and its  verify  bit)  into a
            three-word field  (.RBPJC) in the  RIB of  each non-UFD file  created by  the frame.
            (The  .RBPJC field  in UFDs  is  used by  the LOGINN  and PROJEC  programs  to store
            information specifying how to (or whether to) verify project codes).

            To  change a  frame's project  code, a  program executes  the CHPRJ  UUO (CALLI -61,
            pg. 2-8).

            2.5.3.1    CHPRJ: change project code (CALLI -61)
                       ______ ______ _______ ____ ______ ____

                    MOVE    ac, [bits,,addr]
                    CHPJC   ac,
                      error return
                    normal return

            where <bits> = 0 to read current project code and verify bit
                           1 to set project code but not change verify bit
                           3 to set both project code and verify bit

            where <addr> points to a block of the form
                    wd 0            chars 1-5 of project code
                    wd 1            chars 6-10 of project code
                    wd 2 bits 0-13  chars 11-12 of project code
                    wd 2 bits 14-34 0
                    wd 2 bit 35     project-code-verify bit

            If <bits>  = 0, store  the current project  code and project-code-verify  bit values
            into the block at <addr>, and skip-return.
                                                    2-8


            June 27, 1984                            2                      Frames and Processes


            If <bits> = 1 or 3, error-return if the project-code-verify bit is set for the frame
            and the process does not have either XCharge (XC) or Write Absolute (WA) license.

            If <bits> = 1,  set the frame's project code  from the block at <addr>,  leaving the
            verify bit unchanged, and skip-return.

            If <bits>  = 3,  set both  the project code  and the  verify bit  from the  block at
            <addr>, and skip-return.

            2.5.4    Restricted Command Mode
                     __________ _______ ____

            If the JP.RCM bit is set in a frame's frame privilege word, the monitor will process
            only the commands

                    EXIT    HALT    DETACH  CONTINUE
                    LOGOUT  KJOB    BYE

            If any  other command  is typed, the  monitor will  execute the  frame's "restricted
            command  file".  That  restricted command  program will  receive the  monitor parsed
            command name in SIXBIT in user AC 1.

            The restricted  command file is  specified by executing  the SETRCF  UUO (CALLI -57,
            pg. 2-9).

            2.5.4.1    SETRCF: set restricted cmnd file (CALLI -57)
                       _______ ___ __________ ____ ____ ______ ____

                    MOVEI   ac, [
                            SIXBIT /filename/
                            ppn
                    ]
                    SETRCF  ac,
                    only return

            Set the frame's restricted command file  to be the file <filename> in  the directory
            <ppn> and return.

            2.5.5    Special Command Mode
                     _______ _______ ____

            If the JP.CMD bit is  set in a frame's frame  privilege word, and the user  types an
            illegal command, the monitor will execute the frame's "restricted  command program".
            That restricted  command program  will receive  the monitor  parsed command  name in
            SIXBIT in user AC 1.

            The restricted command program is specified by executing the SETRCF  UUO (CALLI -57,
            pg. 2-9).

            2.5.6    Logout On Stop
                     ______ __ ____

            If the JP.LOS bit is set in the frame's frame privilege word, LOGOUT will  be forced
            on the frame if the frame is  being stopped.  If this bit is set,  Restriced Command
            Mode will be forced on the frame at command dispatch time.

            JP.LOS can be set with SETUUO UUO (CALLI +75, pg. 19-1), but cannot be cleared.















                                                    2-9


            Frames and Processes                     2                          YAMM edition 2.1


            2.5.7    LOGOUT: log a frame out (CALLI +17)
                     _______ ___ _ _____ ___ ______ ____

                    LOGOUT
                    ; no return

            If JB.LOG is 1, just do an EXIT UUO.

            Otherwise, release all resources held by the frame, restore its command port  to the
            initial state, stop the frame, and clear its frame status word.

            2.5.8    Alternate Logout Program
                     _________ ______ _______

            2.5.8.1    LOGOFF: Run Alternate Logout Program (CALLI -130)
                       _______ ___ _________ ______ _______ ______ _____

                    MOVSI   AC,<start-addr-increment>
                    LOGOFF  AC,
                      error return          ; can't run required program
                    no-ALP-set return       ; KJOB pending and no ALP



            The KJOB pending bit is set by the LOGOUT program when the LOGOFF sequence is begun.

            If  "KJOB pending"  is set  for the  caller's process,  and if  an  Alternate Logout
            Program has  been established by  SETALP UUO (CALLI -127,  pg. 2-10) then  attempt a
            RUN  UUO  (CALLI +35, pg. 3-7)  on  the  Alternate Logout  Program  (ALP).  If "KJOB
            pending" is set but no ALP has been set, take the <no-ALP-set> return.

            If the  RUN succeeds,  do not return  to the  caller.  If the  RUN fails,  abort the
            process and store halt status HC.xxx for the frame.

            If "KJOB pending" is not set, run (SYS)LOGOUT.

            2.5.8.2    SETALP: Set Alternate Logout Program (CALLI -127)
                       _______ ___ _________ ______ _______ ______ _____

                    MOVEI   AC,<addr>
                    SETALP  AC,
                     error return   ;AC unchanged
                    normal return   ;AC unchanged

            where the arguments at <addr> are:

            ADDR:   SIXBIT /<device>/
                    PPN
                    SIXBIT /<filename>/


            If an Alternate Logout  Program has already been  established for the caller,  or if
            the logout process is already underway, take the error return.

            Store <filename> and <PPN> for later use by LOGOFF UUO (CALLI -130, pg. 2-10).

            2.5.9    EVICT: Cause Notice to Quit Interrupt (CALLI -134)
                     ______ _____ ______ __ ____ _________ ______ _____

                    MOVE    AC,[<flag>,,<frame>]
                    EVICT   AC,
                     error  return
                    normal return   ;AC contains <channel number>

            where <flag> is as follows:
            1       ;cause the interrupt
            0       ;simply return <channel number>

            If the  caller does  not have .ARHLT  rights to  <frame>, or if  the frame  does not
            exist, take the error return without modifying AC.

            Set  AC to  the  software interrupt  channel on  which  .IANTQ (notice  to  quit) is

                                                    2-10


            June 27, 1984                            2                      Frames and Processes


            assigned for  the target  frame.  If  the interrupt  is not  assigned in  the target
            frame, set AC to 0 and take the normal return.

            If EV.NTQ was set in lh(AC),  cause an interrupt on the appropriate channel  for the
            target frame.

            EVICT also sets PV.LOS (logout on stop)  in the target frame to force logout  if the
            program terminates without explicitly logging out.

            Take the normal return.

            2.5.10    Inactivity Logout
                      __________ ______

            If the  inactivity logout  bit is set  (see SETINA  UUO (CALLI -146,  pg. 2-4)), the
            frame will receive a notice to quit if there has been no activity for the time limit
            set (or the default time limit  of 15 minutes).  The inactivity logout limit  can be
            set or reset by the command

                    SET [NO]AUTOLOGOUT n

            where "n" is the time limit in minutes.

            2.5.11    HANG: hang a port or frame or frames (CALLI -32)
                      _____ ____ _ ____ __ _____ __ ______ ______ ____

                    MOVE    ac, [bits,,frame or port]
                    HANG    ac,
                      error return
                    normal return

            where <bits> =  '20 to not detach before logout
                            '10 to hang a line already hung
                            '4 to hang all frames then go to "BOOTS LOADED"
                            '2 to force logout even if the frame has
                              JP.DET or JP.TIM set
                            '1 is specifying a frame rather than a port number

            If the process does not have Write Core (WC) license, take the error return.

            If <bits>='10,

                If <port> is logged-in, take the error return.

                Otherwise send a zapper on  the (already zapped) <port> and take  the normal
                return.

            Otherwise, if  <port> does not  exist or is  not logged-in, or  if <frame>  does not
            exist, take the error return.

            If  the '4  bit  is set  in  <bits>, set  the  system super-shut,  then  perform the
            equivalent of a HANG UUO with <bits> = '2 for every port in the system.

            If the '1 bit is set in <bits> (indicating that a frame rather than a port  is being
            specified), proceed  as if that  frame's command port  had been specified.   (If the
            frame is running detached, attach it to a fake port and proceed).

            Simulate the effect of  a circuit zapper arriving at  the port, except that,  if the
            port is a frame's command port and bit '2 is set in bits, always force a  logout for
            the frame  regardless of the  setting of  JP.TIM and JP.DET  in its  frame privilege
            word.

            Note that even a successful self-hang takes the normal return and the  job continues
            to run until the next clock tick.






                                                    2-11


            Frames and Processes                     2                          YAMM edition 2.1


            2.6    Frame Generation and Control Operations
                   _____ __________ ___ _______ __________

            A variety of operations are available as subfunctions of the FRMOP UUO (op code 044,
            pg. 2-17) to  allow any process  to create, delete,  move, and control  the contents
            and privileges of other frames.  For a quick summary, see Table 2-19 .

            These operations allow a  process to exercise all the  control over what goes  on in
            another frame that  could be exercised  by the user  at his terminal  under previous
            monitors.  The result is that a  terminal user can develop a session  which consists
            of numerous address spaces [the  different frames] with different programs  in them,
            related to one another in a hierarchy known as a "frame tree".  A session is  a tree
            of frames whose  root frame is  ordinarily created by the  monitor in response  to a
            network login message.

            This root frame may contain any process, although in many cases users will choose to
            have it contain the system executive program XEXEC.

            The root frame may create  "children" (subordinate frames), place programs  in those
            child  frames,  run  them  in  parallel  or  serially,  control  their  input/output
            abilities, handle  their exception conditions  (ILL MEM REF,  etc.), give  access to
            them to  other processes in  the system, and  even "hand them  off" (graft  them) to
            other sessions.

            2.6.1    Per Frame Program Number
                     ___ _____ _______ ______

            For each  frame the system  maintains a  Program Number.  Every  GET operation  on a
            frame causes its PNO to be  incremented.  For a given frame, then, the  PNO uniquely
            identifies the program or process in the  frame.  If a new program is placed  in the
            frame, process  handles (see 2-14)  to the previous  program become  invalid because
            the new program is identified by a new PNO.

            The operations which change a frame's PNO are:
                1)  .FOGET and GET command
                2)  .FORUN, RUN command, and RUN UUO
                3)  .FOCLR

            2.6.2    Universal Frame ID
                     _________ _____ __

            For  each frame  the system  maintains a  Universal Frame  ID which  is  assigned at
            creation of the frame and is guaranteed unique to that frame during  any incarnation
            of the  system (i.e.,  between system  bring-up and  crash or  take-down).  Absolute
            Frame Numbers  on the other  hand, do  not uniquely identify  frames, since  a frame
            occupying slot N might be destroyed and another frame created later in the same slot
            N.  The new frame would, however, have a new UID by which it could  be distinguished
            from the old frame in that same Absolute Frame Number slot.

            2.6.3    Frame Descriptors
                     _____ ___________

            Frame Descriptors are the means by  which a user program talks about  frames.  Frame
            Descriptors (FD's)  come in  several types described  in Table 2-13 .   An FD  is an
            18-bit quantity. In Table 2-13  the bit-positions are shown assuming that the  FD is
            in a low-order half-word, as is the case with most FRMOP arguments.

            The  subtype field  is ignored  for those  types which  do not  have  subtypes.  For
            instance, an Absolute FD (type 0)  has no subtypes; the subtype field is  treated as
            being 0,  so that the  Absolute FD  functions like a  "job number"  functioned under
            previous monitors.  Likewise, the FD.SLF has no subtype; nor is the data field used;
            if the caller passes 777777 as his  FD, he is referring to himself, in the  same way
            that -1 has traditionally referred to "self" in UUOs under previous monitors.

            Any  fields which  are  documented as  "ignored" should  be  set to  zero,  with the
            exception of 777777 for FD.SLF.   Non-zero data in these fields may  produce strange
            results in the future.





                                                    2-12


            June 27, 1984                            2                      Frames and Processes


            2.6.3.1    Absolute FD
                       ________ __

            FD.ABS handles exist  automatically by their nature.   An Absolute FD  (FD.ABS) will
            work  only  if  some  (depending on  the  operation)  combination  of  the following
            conditions are met:
                1)  caller has Systat (SY) license
                2)  caller has JP.TYM (Tymshare Proprietary) privilege
                3)  caller has Read Core (RC) or Write Core (WC) license
                4)  caller is parent of target
                5)  caller has same AUN as target
                6)  caller  has same  GAN as  target, and  caller has  JP.ASV  (Acct. Supv.)
                    privilege
            In the last 2  cases, the caller is given  access to the target frame  equivalent to
            Systat (SY) license.


                                                Table 2-13 
                                                _____ ____ 
                                          Frame Descriptor Format
                                          _____ __________ ______



            the frame descriptor format looks like TSXXXX
            where each character is an octal digit as follows:
                    T    = type code
                    S    = subtype code
                    XXXX = index (abs frame no, handle index, etc)

            the values for these fields are as follows:

            FD.ABS   0B20  absolute type FD
                           X field is frame number
            FD.FAM   1B20  family type FD
                           FM.CHL   0B23  child subtype
                                    X field is child frame number
                           FM.PAR   1B23  parent subtype
            FD.OTF   2B20  "other" frame
                           uses FD specified by SETOTF UUO (CALLI -126, pg. 2-14)
            FD.CRH   3B20  created handle type FD
                           X field is handle index
                           CH.FRM   0B23  frame handle subtype
                           CH.PRO   1B23  process handle subtype
                           CH.LIC   2B23  license handle subtype
            FD.SLF   7B20  self
                           S and X fields are ignored


            2.6.3.2    Other Frame FD
                       _____ _____ __

            Passing a FD of type FD.OTF causes the system to use the FD which was  most recently
            given to the SETOTF UUO  (CALLI -126, pg. 2-14) In addition to FRMOP,  the following
            UUOs will  operate on  the "other"  frame if the  appropriate flag  is set  in their
            arguments:
                1)  VPROT UUO (CALLI -70, pg. 4-7)
                2)  PAGSTS UUO (CALLI -71, pg. 4-17)
                3)  VALPAG UUO (CALLI -76, pg. 4-13)
                4)  PREREF UUO (CALLI -75, pg. 4-10)
                5)  VCREAT UUO (CALLI -67, pg. 4-3)
                6)  VREMOV UUO (CALLI -65, pg. 4-4)
                7)  VCLEAR UUO (CALLI -66, pg. 4-4)
                8)  VREPLC UUO (CALLI -64, pg. 4-4)
                9)  .FOREP UUO (FRMOP fn 7, pg. 2-23)
                10)  .CHMFP UUO (CHANIO fn 35, pg. 4-5)






                                                    2-13


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.3.2.1    SETOTF: set other-frame FD (CALLI -126)
                         _______ ___ ___________ __ ______ _____

                    MOVEI   ac,FD
                    SETOTF  ac,
                      error return
                    normal return   ;ac/previous "other frame" FD if any

            If <FD> is of type FD.OTF, take the error return.

            Exchange the FD in <ac> with the monitor's "other frame" FD storage  location.  Take
            the normal return.

            This "other frame"  FD can be  used by subsequent UUOs  to operate on  the indicated
            frame without explicitly  passing the FD to  the UUO. See .CHMFP  UUO (CHANIO fn 35,
            pg. 4-5) for example.

            2.6.3.3    Handles
                       _______

            A "handle"  is a system  construct which is  a means of  accessing or  changing data
            associated with a frame.  It may be useful to consider a handle as a  "path" between
            frames.  The most significant facts about handles are:
                1)  A handle describes the operations  for which its holder may use  it upon
                    the object (target frame) which  it names.  These are the  Handle Access
                    Rights
                2)  A handle may be passed from frame to frame.
            These two facts are an important part of the basis of constructing "capability-based
            systems"--that is, systems  of programs which cannot  talk about or  affect anything
            except those other  objects for which  they have been given  a name.  The  "name" or
            "path" given to any program is the FD itself.

            2.6.3.3.1    Family FD's
                         ______ ____

            Some  handles  are  generated   auutomatically  by  the  .FOCFH   UUO  (FRMOP fn 12,
            pg. 2-30).  The FD's  for these  handles are  the type  FD.FAM, subtypes  FM.CHL and
            FM.PAR. They govern the effects parents can have upon their children and vice-versa.

            2.6.3.3.2    Created Handle
                         _______ ______

            The .FOCFH UUO (FRMOP fn 12, pg. 2-30)  produces "created handles", or FD's  of type
            FD.CRH.  Created handles are of three subtypes:
                1)  Frame Handle.   A frame  handle is  valid for  as long  as the  frame it
                    points to exists.  If the frame is destroyed, the handle becomes invalid
                    but may continue to exist for some time.
                2)  Process Handle.  A Process handle  is valid only so long as  the program
                    within the  target frame is  not replaced by  another program.  In other
                    words, a process handle grants access to one incarnation of a program.
                3)  Licensed Handle.  A Licensed handle grants access to its target absolute
                    frame  number  according  to  the license  stored  in  the  handle.  (An
                    Absolute Frame Descriptor also can function as a licensed handle because
                    the access it grants is determined by the process license of  the caller
                    at the moment the Absolute FD is used.)

            2.6.4    Access Rights
                     ______ ______

            A  system of  Access Rights  (AR)  bits allows  a very  subtle and  flexible  set of
            security measures to be developed between processes executing in the system.  Access
            Rights define the ability of a frame to perform certain functions.   See Table 2-16 
            for the names and meanings of AR's currently defined.










                                                    2-14


            June 27, 1984                            2                      Frames and Processes


            2.6.4.1    Maximum Frame Rights
                       _______ _____ ______

            Every frame has some  Access Rights, and the full  set of the Access Rights  that it
            has at any one time is called the Maximum Frame Rights; these are the maximum rights
            which any CH.FRH  to the frame  may possess.  When a  frame is created,  the Maximum
            Frame Rights (MFR) are initialized to ALL rights (as listed in Table 2-16 ).  When a
            program is  loaded into  the frame  with the  monitor's RUN  or GET  operations, the
            protection code of the file  and the PPN of the  frame into which the file  is being
            loaded determine the setting of the MFR: the frame is either the file's  Owner (same
            PPN), project-mate (same GAN) or is part of "the public".  In addition,  licenses on
            the frame and file affect the initial MFR.  These are the conditions:
                1)  if the  file is  Execute-Only (see  3-11) set  the MFR  to allow  only a
                    limited set of  control functions to be  applied to the  frame.  Prevent
                    any operations which would break Execute-Only security, such as .FORVA.
                2)  if the file  has more license than  the frame, but is  not Execute-Only,
                    set the MFR to allow  frame handles to read information about  the frame
                    and exercise the limited set  of control functions which are  allowed in
                    the Execute-Only case.   Prevent any operations  which could be  used to
                    exploit the license.
                3)  if neither of these conditions applies, set the MFR to ALL rights.
            Another way of  setting the MFR  is to use  the .FOSMF UUO  (FRMOP fn 20, pg. 2-34).
            This operation allows a frame  to set its own MFR or  the MFR of any other  frame to
            which it has .ARSMF access.

            Note that a process  has the option of setting  its own MFR down from  their initial
            values in order to protect any information it wishes to keep to itself.

            Note also that if a frame wishes to access another frame, and either manipulate that
            frame or gather information about that  frame, then it must have the  proper license
            to do so.  See Table 2-16 .






































                                                    2-15


            Frames and Processes                     2                          YAMM edition 2.1


                                                Table 2-16 
                                                _____ ____ 
                                         Access Rights Definitions
                                         ______ ______ ___________


            oct name    when   lic          description

            0   .ARRDM  R      RC           Read Map
                                            find out things about a map (i.e., VPGSTS, WSCTL to
                                            read WS size, etc.)
            1   .ARCHM  W      WC           Change Map
                                            do VREMOV,VCREAT,.CHMFP, .FOREP to other frame, etc.
            2   .ARRAC  R      RC           Read ACs
            3   .ARWAC  W      WC           Write ACs
            4   .ARVAR  R      RC           Read VM data
                                            also VREPLC or .FOREP with protection .PRRO, etc.
            5   .ARVAW  W      WC           Write VM data
                                            also VREPLC or .FOREP with protection .PRRW
            6   .ARHLT  W      WC           Halt frame
            7   .ARSTP  X      WC           Stop frame
                                            like escape/^C, this is trappable by the target
                                            frame
            10  .ARHNG  W      WC           Hang frame
            11  .ARCLR  X      WC           Clear frame and release devices
                                            frame must be stopped first
            12  .ARSVA  X      WC           Start at Vector Address
                                            see .FOSVA UUO (FRMOP fn 22, pg. 2-26)
            13  .ARSAA  W      WC           Start at Arbitrary Address
            14  .ARRVA  W      WC           Restart at Vector Address
            15  .ARRAA  W      WC           Restart at Arbitrary Address
            16  .ARRUN  X      TP,SY,AUN    Read User Name
                                            also allows checking JBTSTS to see if logged-in.
                                            See Table 2-7 .
            17  .ARRDS  R      SY,AUN       Read Frame State
                                            read PC,Halt Status Block. See Table 2-28 .
            20  .ARRAD  R      SY,AUN       Read Accounting Data
                                            read TRU components, etc.
            21  .ARRFI  R      SY,AUN       Read Frame Information
                                            read AUN,PPN,UID, etc.
            22  .ARRPI  R      SY,AUN       Read Process Info
                                            read FPN,Process Name, PNO, etc.
            23  .ARSMF  W      WC           Set Max Frame Rights
                                            (set in the MFR of a frame on GET or RUN operations
                                            only if the frame has write access to the file named
                                            in order to prevent creation of handles to an EXO or
                                            RDO program which have .ARSMF rights over the
                                            program)
            24  .ARWAK  W      WC           Do Wake UUO on frame
            25  .ARATT  W      JL,AUN       Attach Port
            26  .ARDET  W      WC           Take Port away (Detach)
            27  .ARTKP  W      WC           Take parent away from frame
            30  .ARGVP  W      JL           Give parent to frame
            31  .ARGVC  W      WC           Give child to frame

            Explanations:
            oct   octal Access Right number
            name  symbol name for this AR number
            when  conditions under which this AR is set in initial MFR
                  "W"   set when JP.EXO is off AND Process License
                        is less than or equal to Frame License
                  "R"   set when JP.EXO is off AND Process License
                        is greater than Frame License, and under "W" conditions
                  "X"   set when JP.EXO is set and under "R" and "W" conditions
            lic   license which grants this AR.
                  "AUN" means frames have same AUN, or caller has JP.ASV
                        and his GAN matches that of target frame
                  "TP" means JP.TYM set in JBTPRV


                                                    2-16


            June 27, 1984                            2                      Frames and Processes


            2.6.4.2    Handle Rights vs. Effective Rights
                       ______ ______ ___ _________ ______

            Every FD  (and thus every  handle) has associated  with it a  set of  "handle access
            rights", or "handle rights", which are the rights for which the handle  may possibly
            be exercised on its target frame.  However, if the target frame has reduced its MFR,
            some handles to it may contain rights which are not presently effective.  A handle's
            "effective rights" are those for which  it is currently good over the  target frame.
            Effective rights may or  may not be identical to  handle rights.  These two  sets of
            rights may be read with
                1)  .FORAR UUO (FRMOP fn 16, pg. 2-33)
                2)  .FORER UUO (FRMOP fn 17, pg. 2-33)
                3)  .FOCAR UUO (FRMOP fn 30, pg. 2-35)
                4)  .FOCER UUO (FRMOP fn 31, pg. 2-35)

            2.6.5    FRMOP: Frame Operation (op code 044)
                     ______ _____ _________ ___ ____ ____

                    MOVE    AC,[function,,FD]
                    FRMOP   AC,addr
                      error return          ; AC/ error code
                    normal return

            where
             FD       = a frame descriptor
             addr     = address of the argument or argument block
             function = one of the functions of Table 2-19 

            Perform <function> on  the indicated frame.  If  an error is encountered,  return an
            error code from Table 2-17  (except as noted).








































                                                    2-17


            Frames and Processes                     2                          YAMM edition 2.1




                                                Table 2-17 
                                                _____ ____ 
                                         FRMOP standard error codes
                                         _____ ________ _____ _____


            Name     Code  Description
            FENOH%   1     no handle in slot
            FEBDI%   2     Bad (nonmatching) universal ID number
            FENRT%   3     no rights to do operation
            FEBDF%   4     bad frame number
            FENLC%   5     not enough license
            FEUND%   6     undefined frame descriptor type
            FENCH%   7     not a child
                           FD said child, but gave non-child frame number
            FECLP%   10    cannot lock context pages
            FEBAR%   11    bad access rights code
            FENPR%   12    no parent
                           (frame without a parent asked for its parent)
            FEBFD%   13    bad family dispatch type
            FEBDH%   14    bad handle index number in FD
            FEBFN%   15    bad FRMOP function code
            FEADB%   16    address bad
                           replicate failed in .FORVA/.FOWVA
            FEIOE%   17    page I/O error
            FEALR%   20    already running
            FEALH%   21    already halted
            FECSJ%   22    cannot stop frame with JACCT set
            FEFHE%   23    handle descriptor expected, not given
            FEFHU%   24    handle (index) already used
            FENFH%   25    no frame handle indices left
            FEBCN%   26    bad count
            FEBTN%   27    bad table number
            FEBHT%   30    bad handle type
            FECCH%   31    can't create handle (access failure)
            FEBSV%   32    bad start vector offset
            FECII%   33    cannot make child its own inferior in frame tree
            FECCF%   34    cannot continue frame
            FECFJ%   35    cannot do frame jump
                           target frame PC not in user mode
            FEREM%   36    rights exceed maximum
                           rights in target handle exceed max specifications
            All FRMOPs except .FOREP, .FOVRM, .FOCLR return these error codes in AC right half.
                           .FOREP and friends return these codes in AC bits 0-5, VP in bits
                           8-17, and the VREPLC, VCLEAR or VREMOV error code (see Table 4-20 )
                           in AC right half.






















                                                    2-18


            June 27, 1984                            2                      Frames and Processes


                                                Table 2-19 
                                                _____ ____ 
                                          FRMOP calls by function
                                          _____ _____ __ ________


            Name     Code  AR req'd.        Description

            Tree manipulation

            .FOCFM   1     -none-           create frame (2-20)
            .FOGFT   24    .ARGVC,.ARGVP    graft frame (2-22)


            Memory manipulation

            .FORVA   2     .ARVAR           read virtual address (2-22)
            .FOWVA   3     .ARVAW           write virtual address (2-22)
            .FOREP   7     .ARCHM           replicate pages to/from frame (2-23)
            .FOVRM   10    .ARCHM           VREMOV for other frame (2-23)
            .FOVCL   11    .ARCHM           VCLEAR for other frame (2-23)
            .FOGET   32    .ARVAW           GET file into frame (2-23)
            .FOSAV   34    .ARVAR           SAVE frame on file (2-24)
            .FOSSA   35    .ARVAR           SSAVE frame on file (2-24)


            State manipulation

            .FOJMP   0     .ARSVA or .ARSAA Gate Jump to frame (2-24)
            .FOSAA   4     .ARSAA           start at absolute address (2-25)
            .FOHLT   5     .ARHLT           halt frame (2-25)
            .FORPC   6     .ARRDS           read user mode PC (2-25)
            .FOCLR   14    .ARCLR           clear stopped frame (2-26)
            .FOSVA   22    .ARSVA           start at start vector (2-26)
            .FOHST   23    .ARRDS           read halt status block (2-27)
            .FOCON   25    .ARSVA           continue frame (2-29)
            .FOGIN   26    -none-           Gate jump Init (2-29)
            .FORUN   33    .ARVAW           RUN program in frame (2-29)
            .FOSTP   41    .ARSTP           halt frame (2-30)
            .FOFCF   42    .ARVAW           force command on frame (2-30)
            .FOCPC   43    .ARFFI           change project code for frame (2-30)


            Rights and Handles

            .FOCFH   12    -none-           create frame handle (2-30)
            .FODFH   13    -none-           destroy frame handle (2-32)
            .FORSI   15    -none-           return standard access rights info (2-33)
            .FORAR   16    -none-           read handle's access rights (2-33)
            .FORER   17    -none-           read handle's effective rights (2-33)
            .FOSMF   20    .ARSMF           set maximum frame rights (2-34)
            .FOCHR   21    -none-           change rights for handle (2-34)
            .FOVCH   27    -none-           Validate Child's rights (2-34)
            .FOCAR   30    -none-           Read Child-to-Parent Handle Access Rights (2-35)
            .FOCER   31    -none-           Read Child-to-Parent Handle Effective Rights (2-35)
            .FORFA   36    .ARRFI           read frame attributes (2-35)
            .FOWFA   37    -none-           write frame attributes (2-35)
            .FOXFA   40    .ARRFI           exchange frame attributes (2-35)












                                                    2-19


            Frames and Processes                     2                          YAMM edition 2.1


                                                Table 2-20 
                                                _____ ____ 
                                         FRMOP functions by number
                                         _____ _________ __ ______


            Function Name     Description

              fn 0   .FOJMP   Gate Jump to frame (2-24)
              fn 1   .FOCFM   create frame (2-20)
              fn 2   .FORVA   read virtual address (2-22)
              fn 3   .FOWVA   write virtual address (2-22)
              fn 4   .FOSAA   start at absolute address (2-25)
              fn 5   .FOHLT   halt frame (2-25)
              fn 6   .FORPC   read user mode PC (2-25)
              fn 7   .FOREP   replicate pages to/from frame (2-23)
              fn 10  .FOVRM   VREMOV for other frame (2-23)
              fn 11  .FOVCL   VCLEAR for other frame (2-23)
              fn 12  .FOCFH   create frame handle (2-30)
              fn 13  .FODFH   destroy frame handle (2-32)
              fn 14  .FOCLR   clear stopped frame (2-26)
              fn 15  .FORSI   return standard access rights info (2-33)
              fn 16  .FORAR   read handle's access rights (2-33)
              fn 17  .FORER   read handle's effective rights (2-33)
              fn 20  .FOSMF   set maximum frame rights (2-34)
              fn 21  .FOCHR   change rights for handle (2-34)
              fn 22  .FOSVA   start at start vector (2-26)
              fn 23  .FOHST   read halt status block (2-27)
              fn 24  .FOGFT   graft frame (2-22)
              fn 25  .FOCON   continue frame (2-29)
              fn 26  .FOGIN   Gate jump Init (2-29)
              fn 27  .FOVCH   Validate Child's rights (2-34)
              fn 30  .FOCAR   Read Child-to-Parent Handle Access Rights (2-35)
              fn 31  .FOCER   Read Child-to-Parent Handle Effective Rights (2-35)
              fn 32  .FOGET   GET file into frame (2-23)
              fn 33  .FORUN   RUN program in frame (2-29)
              fn 34  .FOSAV   SAVE frame on file (2-24)
              fn 35  .FOSSA   SSAVE frame on file (2-24)
              fn 36  .FORFA   read frame attributes (2-35)
              fn 37  .FOWFA   write frame attributes (2-35)
              fn 40  .FOXFA   exchange frame attributes (2-35)
              fn 41  .FOSTP   halt frame (2-30)
              fn 42  .FOFCF   force command on frame (2-30)
              fn 43  .FOCPC   change project code for frame (2-30)


            2.6.6    Tree manipulation FRMOPs
                     ____ ____________ ______

            2.6.6.1    .FOCFM: create frame (FRMOP fn 1)
                       _______ ______ _____ ______ __ __

            There are two forms for this call:



















                                                    2-20


            June 27, 1984                            2                      Frames and Processes



                    MOVSI   AC,.FOCFM
                    FRMOP   AC,block
                      error return  ; AC/ error code from Table 2-21 
                    normal return   ; AC/ child frame desc

            block:  flags,,CNT
                    JBTPPN
                    JBTPRV          ; Table 2-3
                    JBTAUN          ; AUN for new frame
                    JBTUNM          ; sixbit username for given AUN
                    JBTUN1          ;
                    <license>       ; iff CF.LIC set

            where CNT is the number (0-5) of login data words that follow the header
                    word; this number does NOT include the license word, if any

            and <license> is the license bits to pass to child frame; license can be
                    the same or less than caller, but not more; non-privileged caller
                    can set non-privilege bits

            and flags are:

                    CF.OLD==1B0     ; this word is - count,,addr (old way)
                    CF.LOG==1B17    ; run LOGINN in child
                    CF.LIC==1B16    ; pass frame license of parent to child

                        or:         ; (old way)

                    MOVSI   AC,.FOCFM
                    FRMOP   AC,[-count,,addr]
                      error return  ; AC/ error code from Table 2-21 
                    normal return   ; AC/ child frame desc

            addr:   JBTPPN          ; PPN for new frame
                    JBTPRV          ; Table 2-3
                    JBTAUN          ; AUN for new frame
                    JBTUNM          ; sixbit username for given AUN
                    JBTUN1          ;

            Create a new frame and make it a child of the caller.  Give the frame the parameters
            given at addr.  If a parameter is not specified (i.e. not included in count), or the
            job is not licensed to set that parameter, use the corresponding parameter  from the
            frame doing the UUO.

            If no error is detected, skip  return with the child frame descriptor (see  2-12) in
            the AC.

            If an error is  detected, non-skip return with  the error code (see  Table 2-21 ) in
            the AC.


                                                Table 2-21 
                                                _____ ____ 
                                             .FOCFM error codes
                                             ______ _____ _____


            name     code description
            CF.NRD   0    no disk room
            CF.FCE   1    frame capacity exceeded
            CF.BAL   2    bad arg no license
            CF.DDB   3    cannot create command port DDB







                                                    2-21


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.6.2    .FOGFT: Graft Frame Subtree (FRMOP fn 24)
                       _______ _____ _____ _______ ______ __ ___

                    MOVE    AC,[.FOGFT,,<FD of subtree root>]
                    FRMOP   AC,[<FD of destination frame>]
                     error return   ;AC/Table 2-17
                    normal return

            where
             <FD of subtree root> is the FD of the root frame of a subtree
             of some existing frame tree, which is to be moved by the .FOGFT

             <FD of destination frame> is 0 or the FD of a new prospective
             parent for the subtree being moved.  If 0, the subtree is going
             to become a free-standing tree in its own right.

            If <FD of destination frame> is non-zero, take the error return if either
                1)  the caller is missing .ARGVC over the destination frame, or
                2)  the caller is missing .ARGVP over the subtree being moved.

            If <FD of  destination frame> is a  member of the subtree  rooted in <FD  of subtree
            root>, take the error return (since this would destroy the tree-structure  by making
            it into a graph).

            Take the error return if the  caller lacks .ARTKP over the subtree being  moved, AND
            that subtree currently has a parent.

            Invalidate the child-to-parent handle of  <FD of subtree>.  Give the new  parent (if
            any)  a  handle  to  its  new  child  with  the  same  AR's  that  existed   in  the
            parent-to-child handle of <FD of subtree> before it was moved.  Move the  subtree as
            requested.  Leave the MFR of <FD of subtree> unmodified.

            Take the normal return.

            2.6.7    Memory manipulation FRMOPs
                     ______ ____________ ______

            2.6.7.1    .FORVA: read frame virtual address (FRMOP fn 2)
                       _______ ____ _____ _______ _______ ______ __ __

                    MOVE    ac,[.FORVA,,FD]
                    FRMOP   ac,block
                      error return  ; AC/ Table 2-17
                    normal return

            block:  <address>
                    <data>

            The contents of  the virtual address  <address> in the  target frame is  copied into
            <data>.

            For Access Rights required, see Table 2-19 .

            2.6.7.2    .FOWVA: write frame virtual address (FRMOP fn 3)
                       _______ _____ _____ _______ _______ ______ __ __

                    MOVE    ac,[.FOWVA,,FD]
                    FRMOP   ac,block
                      error return  ; AC/ Table 2-17
                    normal return

            block:  <address>
                    <data>

            <data> is copied into the virtual address <address> in the target frame.

            For Access Rights required, see Table 2-19 .





                                                    2-22


            June 27, 1984                            2                      Frames and Processes


            2.6.7.3    .FOREP: VREPLC to/from another frame (FRMOP fn 7)
                       _______ ______ _______ _______ _____ ______ __ __

                    MOVE    ac,[.FOREP,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/bits 0-5 see Table 2-17
                                        bits 6-35 see Table 4-20 
                    normal return

            ADDR:   <otfflg>B1+<prot>B7+<count>B17,,destination VP
                    <otfflg>B1,,source VP

            where
             <otfflg> = 1 to indicate frame specified by FD
                        0 to indicate calling frame
             <prot>   is from Table 4-3 
             <count>  is 1 .LE. <count> .LE. 777 specifying a range of pages

            Refer  to the  VREPLC UUO  (CALLI -64, pg. 4-4)  for discussion  of  this operation.
            .FOREP differs only in that <otfflg>  can be used to cause the replicate  to operate
            between the caller and target frame.

            2.6.7.4    .FOVRM: VREMOV in another frame (FRMOP fn 10)
                       _______ ______ __ _______ _____ ______ __ ___
            2.6.7.4    .FOVCL: VCLEAR in another frame (FRMOP fn 11)
                       _______ ______ __ _______ _____ ______ __ ___

                    MOVE    ac,[.FOVRM or .FOVCL,,FD]
                    FRMOP   ac,
                     error return   ;ac/bits 0-5 see Table 2-17
                                        bits 6-35 see Table 4-20 
                    normal return

            See  VCLEAR UUO  (CALLI -66,  pg. 4-4) and  VREMOV  UUO (CALLI -65,  pg. 4-4)  for a
            discussion of these operations.  .FOVRM and .FOVCL differ only in that  they operate
            on the frame specified by FD.

            2.6.7.5    .FOGET: Setup frame core image from file (FRMOP fn 32)
                       _______ _____ _____ ____ _____ ____ ____ ______ __ ___


                    MOVE    ac,[.FOGET,,FD]
                    FRMOP   ac,addr
                     error return           ;ac/Table 2-17
                    normal return

            addr:   exp     count           ;number of arguments passed
                    SIXBIT  /device/
                    xwd     gan,uun
                    SIXBIT  /filename/
                    SIXBIT  /ext/           ;best left zero = unspecified
                    xwd     license,core
            count=  .-addr-1


            If any of the conditions named in Table 2-17 is present, take the error return.  The
            AR required to perform .FOGET are listed in Table 2-19 .

            Initiate  the  GET  operation  (see GETSEG  UUO  (CALLI +40,  pg. 3-6)  and  RUN UUO
            (CALLI +35, pg. 3-7)) into the target frame and take the normal return.

            The caller  must examine  the halt  status block  of the  target frame  to determine
            whether  the GET  completed successfully.   It is  possible for  .FOGET to  take the
            normal return but for the operation to fail. For example, the named file may  not be
            found.   This  would  result  in  a halt  status  of  HT.FNF  (see  Table 2-28 ).  A
            successful GET operation results in HT.JSU.






                                                    2-23


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.7.6    .FOSAV: SAVE frame core image on file (FRMOP fn 34)
                       _______ ____ _____ ____ _____ __ ____ ______ __ ___
            2.6.7.6    .FOSSA: SAVE frame core image on SHR file (FRMOP fn 35)
                       _______ ____ _____ ____ _____ __ ___ ____ ______ __ ___


                    MOVE    ac,[.FOSAV or .FOSSA,,FD]
                    FRMOP   ac,addr
                     error return           ;ac/Table 2-17
                    normal return

            addr:   exp     count           ;number of arguments passed
                    SIXBIT  /device/
                    xwd     gan,uun
                    SIXBIT  /filename/
                    SIXBIT  /ext/           ;assumed /SHR/ or /SAV/ if 0
                    xwd     0,core
            count=  .-addr-1


            If any of the conditions named in Table 2-17 is present, take the error return.  The
            AR required by .FOSAV and .FOSSA are listed in Table 2-19 .

            Initiate  the SAVE  operation (see  3-5) from  the target  frame onto  the specified
            file.  Take the normal return.

            The caller must examine the halt status block in the target frame to  determine that
            the operation  completed successfully.  If  the UUO takes  the normal return,  it is
            still possible that the SAVE may not succeed.  For example, the target frame may not
            have the ability to ENTER a file in the named directory; this would result in a halt
            status of HT.EUF.  A successful SAVE will result in HT.JSV.

            2.6.8    State manipulation FRMOPs
                     _____ ____________ ______

            2.6.8.1    .FOJMP: gate jump to frame (FRMOP fn 0)
                       _______ ____ ____ __ _____ ______ __ __

                    MOVE    ac,[.FOJMP,,<FD.CRH index number>]
                     or
                    MOVEI   ac,<FD.CRH index number> ;.FOJMP=0
                    FRMOP   ac,addr
                     error return           ;AC/ Table 2-17
                    normal "return"         ;AC's may all be changed

            addr:   0B17 + <start address>
                or
            addr:   1B17 + <start vector index>

            <FD.CRH index number> is the index field (low order 12 bits) of the caller's created
            handle to the target frame (see Table 2-13 ).  This deviation from the usual calling
            convention is done for efficiency.

            If <FD.CRH index number> is invalid, or if the caller does not have .ARSAA or .ARSVA
            (as appropriate) over the target, take the error return.

            Stop  the caller  frame  with PC  pointing at  the  normal return  from  this FRMOP.
            Continue processing in the target frame  at the PC specified at <addr>.   (Note that
            the target frame PC is  typically at a gate jump  UUO, to cause the target  frame to
            effectively  "return"  from this  UUO,  the SV.CON  start  vector may  be  used; see
            Table 2-27 .)

            Several facts should be noted about the facility provided by .FOJMP:
                1)  any frame wishing to .FOJMP at a target frame must first create a handle
                    to that target.
                2)  the AC's are completely shared between the jumping and target frame.
                3)  the target frame can return to the original jumping frame at  the normal
                    "return" from  the .FOJMP FRMOP  by performing its  own .FOJMP  with the
                    CONTINUE vector index set.
                4)  if the target frame does return in any way, any AC's used by  the target
                    but not restored will be  seen by the original jumping frame.   This can

                                                    2-24


            June 27, 1984                            2                      Frames and Processes


                    facilitate  passing  information  between  otherwise   disjoint  address
                    spaces.
                5)  the state of the command port, if any, is unchanged by .FOJMP.
                6)  .FOJMP is fast  enough to make  it practical to  use it as  a subroutine
                    call mechanism between frames.  It is flexible enough to  implement more
                    elaborate control structures such as co-routines.
                7)  .FOJMP is not guaranteed to work if the target frame has  not previously
                    done a .FOGIN  or .FOJMP of its  own, although there are  certain states
                    wherin it can work.  The  best practice is to initialize a  target frame
                    with .FOGIN UUO (FRMOP fn 26, pg. 2-29).
                8)  a frame which  is stopped because  processing jumped into  another frame
                    via .FOJMP can be started  by the monitor command interpreter or  by any
                    frame  owning  a  handle  which allows  starting  that  frame.   If this
                    happens, the contents of that frame's AC's are undefined.

            2.6.8.2    .FOSAA: start frame at absolute address (FRMOP fn 4)
                       _______ _____ _____ __ ________ _______ ______ __ __

                    MOVE    ac,[.FOSAA,,FD]
                    FRMOP   ac,addr
                      error return  ; AC/ Table 2-17
                    normal return

            addr:   1B0+<address>   ; start at <address> in target
                or
            addr:   <location>      ; start at address found in given
                                    ; location of target frame

            The target frame is started at the specified address.

            The second form, where the location of the start address is specified, is useful for
            starting at an address stored in .JBSA, .JBDDT, etc.  The start address is read from
            the specified location in the target frame and the frame is started at that address.

            For Access Rights required, see Table 2-19 . The target frame must not be running.

            2.6.8.3    .FOHLT: halt frame (FRMOP fn 5)
                       _______ ____ _____ ______ __ __

                    MOVE    ac,[.FOHLT,,FD]
                    FRMOP   ac,
                      error return  ; AC/ Table 2-17
                    normal return

            The target frame will be halted or set to halt when it next runs.

            For Access Rights required,  see Table 2-19 . The  target frame may have  JB.JA2 set
            and may be trapping ^C.  The target frame must not have JB.JAC set (see Table 2-7 ).

            2.6.8.4    .FORPC: Read Frame PC (FRMOP fn 6)
                       _______ ____ _____ __ ______ __ __

                    MOVE    ac,[.FORPC,,FD]
                    FRMOP   ac,<addr>
                      error return  ; AC/ Table 2-17
                    normal return

            Return the last known user mode PC for the target frame in <addr>.  If no  user mode
            PC is known  (ie. just finished  a RUN UUO  (CALLI +35, pg. 3-7)), return  zero.  If
            the frame is currently executing a UUO  (ie. the PC is in exec mode), return  the PC
            of the UUO.

            For Access Rights required, see Table 2-19 .








                                                    2-25


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.8.5    .FOCLR: Clear a Frame (FRMOP fn 14)
                       _______ _____ _ _____ ______ __ ___

                    MOVE    ac,[.FOCLR,,FD]
                    FRMOP   ac,
                     error return   ;ac/Table 2-17
                    normal return

            If the target frame is not stopped, take the error return.

            Set up the target to run a program  which will have the same effect as the  "CORE 0"
            command-- particularly, VCLEAR all memory,  release all devices, set the MFR  to all
            AR, and set the P2S rights to all AR.

            Take the normal return.  Upon receiving the normal return, the caller  cannot assume
            that the target is clear until the target halts.

            2.6.8.6    .FOSVA: start frame at vector address (FRMOP fn 22)
                       _______ _____ _____ __ ______ _______ ______ __ ___

                    MOVE    ac,[.FOSVA,,FD]
                    FRMOP   ac,[<start vector index>]
                      error return  ; AC/ Table 2-17
                    normal return

            Positive start vector indicies specify the corresponding offsets into a table in the
            target  frame's address  space (which  may  or may  not be  set up).   The  table is
            specified  by SETSTV  UUO (CALLI -137,  pg. 2-37).  Negative  start  vector indicies
            specify system standard start locations as indicated in Table 2-27 .

            The target frame must  be halted.  For Access  Rights required, see Table 2-19  . If
            <start vector index> is invalid (which can happen if no start vector has been set up
            in the target frame), take the error return.

            Start  the target  frame at  the address  specified by  the contents  of  the vector
            location selected by <start vector index>.  Take the normal return.


































                                                    2-26


            June 27, 1984                            2                      Frames and Processes


                                                Table 2-27 
                                                _____ ____ 
                                        System Start Vector Indicies
                                        ______ _____ ______ ________


            Name     Index Description
            SV.NSA   -1    normal start address (as found in .JBSA)
            SV.CCL   -2    CCL start address (normal plus one)
            SV.REN   -3    REENTER start address (as found in .JBREN)
            SV.DDT   -4    DDT start address (as found in .JBDDT)
            SV.CON   -5    CONTINUE start address


            2.6.8.7    .FOHST: Read Halt Status Block (FRMOP fn 23)
                       _______ ____ ____ ______ _____ ______ __ ___

                    MOVE    ac,[.FOHST,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-17
                    normal return

            ADDR:   <count>         ;number of words to return starting at
                                    ;ADDR+1 as follows:
            ADDR+1/ <halt class>,,<halt type> (see Table 2-28 )
            ADDR+2/ halt count
            ADDR+3/ PC of last halt or exit
            ADDR+4/ PC of last UUO
            ADDR+5/ sixbit <device name> if relevant
            ADDR+6/ class/type dependent data word
            ADDR+7/ another class/type dependent data word

            The system maintains for every  frame a Halt Status Block which  records significant
            information when a frame stops processing.  Frames stop processing for a  variety of
            reasons, some  good and  some not.   All of these  are recorded  in the  Halt Status
            Block, which is readable by another process with .ARRDS.

            The Halt Count at ADDR+2 can be used to determine if the data is new since  the last
            time the block was read.  If the  target frame is not halted, the Halt  Status Block
            does not reflect the frame state, only the conditions prevailing at the last halt.

            If <count> is negative, zero or greater  than the length of a Halt Status  block, or
            if the caller lacks .ARRDS over the target, take the error return.

            Return as much of the Halt Status  Block as allowed by <count>, and take  the normal
            return.

























                                                    2-27


            Frames and Processes                     2                          YAMM edition 2.1


                                                Table 2-28 
                                                _____ ____ 
                                        Halt Status Classes & Types
                                        ____ ______ _______ _ _____



            class   code description
                         type    code description

            HC.MEM  0    Memory Violations
                         HT.PCO  0    PC Out of Bounds
                         HT.IMR  1    Illegal Memory Reference
                         HT.WRV  2    Write Violation
                         HT.ADC  3    Address Check for Device X
                         HT.IMU  4    Ill Mem Ref in UUO
                         HT.IIA  5    Illegal Interrupt Address
                         HT.ABK  6    Address Break
                         HT.POV  7    PDL Overflow

            HC.SYS  1    System-Related Errors
                         HT.PIO  0    Page I/O Error
                         HT.DFL  1    Disk Full during copy of .PRCW page
                         HT.PHE  2    Paging Hardware Error
                         HT.TPL  3    Too many Pages Locked, Cannot handle fault
                         HT.CIO  4    Context Page I/O Error
                         HT.PAR  5    Parity Error(s). All Core Removed

            HC.DEV  2    Device Related Errors
                         HT.OCI  0    Output device Cannot Input
                         HT.ICO  1    Input device Cannot Output
                         HT.IDM  2    Illegal Data Mode for device X
                         HT.IUC  3    I/O to Unassigned Channel
                         HT.HDV  4    Hung Device
                         HT.DOP  5    Device X OPR action requested

            HC.ILL  3    Illegal Instruction Traps
                         HT.ILU  0    Illegal UUO
                         HT.UUE  1    UUO error
                         HT.ILI  2    Illegal Instruction
                         HT.HLT  3    Halt

            HC.EXI  4    Frame Exits
                         HT.EXI  0    Exit
                         HT.EX1  1    Exit 1,
                         HT.FEX  2    Fail Exit
                         HT.TLE  3    Time Limit Exceeded
                         HT.JSU  4    <filename> setup
                         HT.JSV  5    <filename> saved
                         HT.FCL  6    frame cleared

            HC.RUN  5    RUN,RUNSEG & GETSEG UUO errors
                         HT.TRE  0    Transmission Error
                         HT.PGN  1    N Pages Required
                         HT.DNA  2    Device Not Available
                         HT.FNF  3    <filename.ext> not found
                         HT.NSF  4    Not a Save File
                         HT.EUF  5    <filename.ext> Attempted Enter UUO Failed
                         HT.CAN  6    Core Argument Not specified (magtape only)
                         HT.MHB  7    Magtape Hiseg Format Bad
                         HT.RMF  10   Remap UUO Fatal error
                         HT.MGF  11   Magtape GET failure
                         HT.NSA  12   No Start Address







                                                    2-28


            June 27, 1984                            2                      Frames and Processes


            2.6.8.8    .FOCON: continue frame (FRMOP fn 25)
                       _______ ________ _____ ______ __ ___

                    MOVE    ac,[.FOCON,,FD]
                    FRMOP   ac,
                      error return  ; AC/ Table 2-17
                    normal return

            The target frame is started at  its current PC.  This is functionally  equivalent to
            .FORPC UUO (FRMOP fn 6, pg. 2-25) followed by .FOSAA UUO (FRMOP fn 4, pg. 2-25).

            For Access Rights required,  see Table 2-19 . The  target frame must not  be running
            and must not have JB.JER on in JBTSTS (see Table 2-7 ).

            2.6.8.9    .FOGIN: Gate-jump Initialization (FRMOP fn 26)
                       _______ _________ ______________ ______ __ ___

                    MOVE    ac,[.FOGIN,,0]
                    FRMOP   ac,
                     error return   ;ac/ Table 2-17
                    normal "return"

            Perform the normal FRMOP checks. Stop the calling frame and leave its PC pointing at
            the normal "return"  location.  (The caller is  now properly initialized to  be gate
            jumped to with .FOJMP UUO (FRMOP fn 0, pg. 2-24) from another frame.   Either .FOCON
            UUO (FRMOP fn 25,  pg. 2-29) or  .FOJMP UUO (FRMOP fn 0,  pg. 2-24) will  cause this
            frame to begin execution at the normal "return" location.

            The state of the caller's command port is unchanged by gate jumping.

            2.6.8.10    .FORUN: RUN program in frame (FRMOP fn 33)
                        _______ ___ _______ __ _____ ______ __ ___


                    MOVE    ac,[.FORUN,,FD]
                    FRMOP   ac,addr
                     error return           ;ac/Table 2-17
                    success return

            addr:   xwd     start-incr,count
                    SIXBIT  /device/
                    xwd     gan,uun
                    SIXBIT  /filename/
                    SIXBIT  /file extension/        ;best left zero = unspecified
                    xwd     license,core
            count=.-addr-1


            The meaning of the items in the block at <addr> is the same as explained for the RUN
            UUO (CALLI +35,  pg. 3-7).  If any  of the conditions  named in Table 2-17  is true,
            take the error return.  The AR required by .FORUN are listed in Table 2-19 .

            If <count>  is less  than 5 (i.e.  does not  specify all of  the items  shown above,
            substitute 0 for the unspecified items.

            Initiate  the RUN  operation  (see RUN  UUO  (CALLI +35, pg. 3-7))  into  the target
            frame.

            Take the normal return.

            The caller of .FORUN can determine that the .FORUN is complete by examining the halt
            status block of the  target frame.  The fact  that .FORUN returns normally  does not
            mean  that the  operation will  complete  without error  in the  target  frame.  For
            example, if the  file named cannot  be found, the target  frame will halt  with halt
            status HT.FNF.  See Table 2-28 . A successful RUN will result in HT.JSU.






                                                    2-29


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.8.11    .FOSTP: stop frame for non-privileged user (FRMOP fn 41)
                        _______ ____ _____ ___ ______________ ____ ______ __ ___

                    MOVE    ac,[.FOSTP,,FD]
                    FRMOP   ac,
                      error return  ; AC/ Table 2-17
                    normal return

            The  target  frame will  be  halted or  set  to halt  when  it next  runs.   This is
            accomplished by forcing a HALT command (which may by trapped by the target frame).

            Requires .ARSTP access right only.

            The target frame must not have JB.JAC set (see Table 2-7 ).

            2.6.8.12    .FOFCF: force command on frame (FRMOP fn 42)
                        _______ _____ _______ __ _____ ______ __ ___

                    MOVE    AC,[.FOFCF,,FD]
                    FRMOP   AC,addr
                      error return
                    normal return

            ADDR:   SIXBIT/command string/

            Command  string must  be either  KJOB, DETACH,  HALT or  INITIA.  Any  other command
            string will error return.  If the command is valid, then put the tty in command mode
            and force  the command on  the frame.  The  index into the  table where  the command
            string is found is returned in AC.

            2.6.8.13    .FOCPC: change project code for frame (FRMOP fn 43)
                        _______ ______ _______ ____ ___ _____ ______ __ ___

                    MOVE    ac,[.FOCPC,,FD]
                    FRMOP   ac,addr
                      error return
                    normal return

            ADDR:   wd0     <bits>    ;see CHPRJ UUO (CALLI -61, pg. 2-8)
                    wd1     chars 1-5 of project code
                    wd2     chars 6-10 of project code
                    wd3     bits 0-13       chars 11-12 of project code
                    wd3     bits 14-34      0
                    wd3     bit 35          project code verify bit (PJCUFY)

            In order to set or change the project  code the user must have WP or XC  license.  A
            non-privileged user may set the project code by running a program which  has license
            at login  time when the  CHPJC call  (see CHPRJ UUO  (CALLI -61, pg. 2-8))  sets the
            PJCUFY (this process is performed only for users subject to verification).

            2.6.9    Rights and Handles FRMOPs
                     ______ ___ _______ ______

            2.6.9.1    .FOCFH: Create Handle (FRMOP fn 12)
                       _______ ______ ______ ______ __ ___

                    MOVE    ac,[.FOCFH,,<source FD>]
                    FRMOP   ac,<addr>
                     error return   ;ac/Table 2-17
                    normal return   ;ac/new handle FD

            ADDR:   <subtype>,,<FD of new handle>
                    <count>,,<location>

            LOCATION: <count> words of AR bits








                                                    2-30


            June 27, 1984                            2                      Frames and Processes



            where
            <subtype>=
                    0B17    frame handle
                    1B17    process handle
                    2B17    license handle
            <FD of new handle> =
                    <FD.CRH>B20+<index>B35
              where <index>=77777 to allocate first free <created handle index>
                    <index>=<created handle index> to use that specific index

            <location>=     address of AR bit table (in caller's address space)
                            to use in setting AR for the new handle

            <count>=        length of AR bit table, or 0 to set AR of new
                            handle to max allowable.

            If <FD of new handle> is not of type FD.CRH, or if <index> specifies an out-of-range
            or currently used <created handle index>, take the error return.

            If <index>=77777, allocate a new <created handle index>, taking the error  return if
            none exists.

            Create a new  handle to the  frame specified by <source  FD>, giving it  the subtype
            specified by <bits> and AR specified by <count> and <location>.  The rules governing
            conversion of handles are summarized in Table 2-32 .

            A <created handle index> is a small integer much like a software I/O channel number;
            every created handle FD has a data  field which has in it a <created  handle index>,
            not an absolute frame  number.  The system keeps, for  each frame, a small  array of
            information about  all handles  created by  that frame;  the created  handle indices
            select handles in that  array.  The size of this  array is a system  parameter which
            may change from time to time.

            If <count>=0,  set the AR  for the new  handle to the  maximum AR allowable  for the
            handle; otherwise, set the AR according  to the bit table at <location>.  If <count>
            specifies less than a full complement  of AR bits, assume that unspecified  bits are
            0.

            Set  AC   to  the  <FD   of  new  handle>,   including  the   directly-specified  or
            newly-allocated <index>, and take the normal return.



























                                                    2-31


            Frames and Processes                     2                          YAMM edition 2.1


                                                Table 2-32 
                                                _____ ____ 
                                      Rules for .FOCFH handle creation
                                      _____ ___ ______ ______ ________


            source FD type   new FD type resultant attributes



            license          license     max AR = AR of source
                                         license := license of source
                             frame       max AR = AR of source
                             process     max AR = AR of source,
                                         PNO := current PNO of target
            frame            license     license := process-license
                                         of .FOCFH caller
                             frame       max AR = AR of source
                             process     max AR = AR of source ANDed
                                         with MFR of target
                                         PNO := current PNO of target
            process          license     license := process-license
                                         of .FOCFH caller
                             frame       illegal: may not create frame handle
                                         from process handle
                             process     max AR = AR of source,
                                         PNO := PNO of source
            absolute FD      license     license := process-license
                                         of .FOCFH caller
                             frame       license := process-license
                                         of .FOCFH caller
                             process     license := process-license
                                         of .FOCFH caller
                                         PNO := current PNO of target
            .FOCFH treates source FD's of other types as follows:

            Source FD       Treated as
            FM.CHL          CH.FRM
            FM.PAR          CH.PRO
            FD.SLF          CH.PRO  with all AR set.

            To create a licensed handle with max rights
            based on the process-license of the caller (rather
            than on the license in the source handle), use
            a Frame, Process or Absolute FD as source handle.


            2.6.9.2    .FODFH: Destroy Handle (FRMOP fn 13)
                       _______ _______ ______ ______ __ ___

                    MOVE    ac,[.FODFH,,FD]
                    FRMOP   ac,
                     error return   ;ac/Table 2-17
                    normal return

            The handle designated by FD is  destroyed. If it is of type FD.CRH,  the appropriate
            <created  handle index>  (see .FOCFH  UUO (FRMOP fn 12,  pg. 2-30)) is  marked free.
            Naturally, the frame to which FD refers is totally unaffected by the .FODFH.













                                                    2-32


            June 27, 1984                            2                      Frames and Processes


            2.6.9.3    .FORSI: Read Standard Access Rights Info (FRMOP fn 15)
                       _______ ____ ________ ______ ______ ____ ______ __ ___

                    MOVE    AC,[.FORSI,,<item>]
                    FRMOP   AC,addr
                     error return   ;AC/ Table 2-17
                    normal return   ;AC/ number of highest currently-defined
                                    ; access right

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;for return of access rights bits

            where <item> is from Table 2-33 


            Return a bit string in TABLE  describing the access rights requested by  <item>.  As
            much of the bitstring as <count> allows is returned.  If <count> = 0, do  not return
            any bitstring.  Set AC  to the number of the  highest currently defined AR  and take
            the normal return.

            .FORSI with <count> = 0 should be used by programs which wish to  allocate precisely
            the right-sized  argument block for  other FRMOPs such  as .FORER  UUO (FRMOP fn 17,
            pg. 2-33) which  manipulate access  rights.  If N  is returned  by .FORSI,  then the
            exact number of words needed for argument blocks is the result of


                    (N + 35) / 36 (integer divide)



                                                Table 2-33 
                                                _____ ____ 
                                            .FORSI Item Numbers
                                            ______ ____ _______


            name     item  description

            .SREXO   0     max frame rights for execute-only processes, and processes loaded
                           from licensed SWR files or files read-protected against the caller
            .SRLIC   1     max frame rights for process with license greater than the frame it
                           lives in
            .SRALL   2     all rights defined by monitor
            .SRRCL   3     AR conferred by Read Core (RC) license
            .SRSYL   4     AR comferred by Systat (SY) license
            .SRTYM   5     AR conferred by JP.TYM privilege
            .SRAUN   6     AR conferred by having same AUN or JP.ASV and same GAN
            .SRJLL   7     AR conferred by Jacct (JL) license
            .SRWCL   10    AR conferred by Write Core (WC) license


            2.6.9.4    .FORAR: Read Handle Access Rights (FRMOP fn 16)
                       _______ ____ ______ ______ ______ ______ __ ___
            2.6.9.4    .FORER: Read Handle Effective Rights (FRMOP fn 17)
                       _______ ____ ______ _________ ______ ______ __ ___

                    MOVE    ac,[.FORAR or .FORER,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-17
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;words to return info as follows:

                word   contents
                0      subtype,,frame number (see Table 2-13 )
                1      UID           except FD.ABS (see 2-12)
                2      PNO           process handles only (see 2-12)
                3-n    access bits

            If  <count> is  greater than  the number  of words  needed to  return  all currently
            defined rights-bits,  take the  error return.   (To determine  the proper  number of
            words, see .FORSI UUO (FRMOP fn 15, pg. 2-33))
                                                    2-33


            Frames and Processes                     2                          YAMM edition 2.1


            These two FRMOPs return rights associated with a particular handle.   .FORAR returns
            the AR  of the handle  itself.  .FORER returns  the rights for  which the  handle is
            currently good, which may or may not be the same as the AR of the handle.  See 2-15,
            .FOSMF UUO  (FRMOP fn 20, pg. 2-34) and  2-17.  For FD.ABS,  the UID and  PNO fields
            are returned zero.   Note that any  process which needs  to know the  absolute frame
            number of a frame to which it has  a handle can find out that number with  either of
            these FRMOPs.

            2.6.9.5    .FOSMF: Set Max Frame Rights (FRMOP fn 20)
                       _______ ___ ___ _____ ______ ______ __ ___

                    MOVE    ac,[.FOSMF,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-17
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;for return of access rights bits
                                    ;  (see Table 2-16 )

            If the caller lacks .ARSMF rights on the target frame, take the error return.

            See 2-15.   Set the  MFR for  frame specified  by FD.   If <count>  is too  small to
            specify all AR bits, set unspecified bits to 0.  If <count> is 0, set maximum rights
            allowed.  Take the normal return.

            2.6.9.6    .FOCHR: Change Handle Rights (FRMOP fn 21)
                       _______ ______ ______ ______ ______ __ ___

                    MOVE    ac,[.FOCHR,,FD]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-17
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;for return of access rights bits
                                    ;  (see Table 2-16 )

            If FD is of type FD.ABS or FD.SLF, take the error return.

            If the AR's at LOCATION are less than the current AR of the handle specified  by FD,
            set the handle AR to the requested values and take the normal return.

            Otherwise, unless FD is  a process handle, set the  handle AR to <requested  AR> AND
            <current AR> and take the  error return.  If FD is  a process handle, set the  AR to
            the <requested AR>, invalidate PNO in the handle, and take the normal return.

            2.6.9.7    .FOVCH: Validate Child Rights (FRMOP fn 27)
                       _______ ________ _____ ______ ______ __ ___

                    MOVE    ac,[.FOVCH,,<FD of child>]
                    FRMOP   ac,addr
                     error return   ;ac/ Table 2-17
                    normal return

            ADDR:   <count>,,TABLE
            TABLE:  BLOCK <count>   ;for return of access rights
                                    ;  (see Table 2-16 )

            If <count> is 0, use the rights in the child-to-parent handle.  If the rights in the
            handle of the child specified by <FD of child> do not exactly match those specified,
            take the error  return.  Otherwise, validate  that child-to-parent handle.   It will
            remain valid until another program is  run in the parent frame (i.e., until  the PNO
            of the parent changes).  Take the normal return.







                                                    2-34


            June 27, 1984                            2                      Frames and Processes


            2.6.9.8    .FOCAR: Read Child Access Rights (FRMOP fn 30)
                       _______ ____ _____ ______ ______ ______ __ ___
            2.6.9.8    .FOCER: Read Child Effective Rights (FRMOP fn 31)
                       _______ ____ _____ _________ ______ ______ __ ___

                    MOVE    ac,[.FOCAR or .FOCER,,<FD of child>]
                    FRMOP   ac,addr
                     error return   ;ac/Table 2-17
                    normal return

            ADDR:   <count>,,TABLE

            TABLE:  BLOCK <count>   ;for return of access rights bits
                                    ;  (see Table 2-16 )

            Every child  that is created  owns an automatically-generated  handle to  its parent
            known as its child-to-parent handle; this handle describes what the child can  do to
            its parent.

            Child-to-parent  handles are  always process  handles.  This  causes child-to-parent
            handles to remain valid  only so long as the  program (i.e., the PNO) in  the parent
            frame remains the same.

            .FOCAR and .FOCER allow any parent to read the info in the child-to-parent handle of
            each of its children, in order to  find out what the children would like to  be able
            to (and actually can) do to it, the parent.  These FRMOPs are used to help  a parent
            judge  whether  or not  to  attempt to  validate  a child's  handle  via  .FOVCH UUO
            (FRMOP fn 27, pg. 2-34).

            Store at LOCATION information from the child-to-parent handle of the child specified
            by <FD of child>.   The format of the data  returned at LOCATION is as  described in
            .FORAR UUO (FRMOP fn 16, pg. 2-33). See 2-17 for more discussion of Effective Rights
            vs. Handle Rights.

            2.6.9.9    .FORFA: Read Frame Attribute (FRMOP fn 36)
                       _______ ____ _____ _________ ______ __ ___
            2.6.9.9    .FOWFA: Write Frame Attribute (FRMOP fn 37)
                       _______ _____ _____ _________ ______ __ ___
            2.6.9.9    .FOXFA: Exchange Frame Attributes (FRMOP fn 40)
                       _______ ________ _____ __________ ______ __ ___

                    MOVE    ac,[FN,,FD]
                    FRMOP   ac,addr
                     error return
                    normal return

            ADDR:   attribute  ,,<argument address>
                          or
            ADDR:   0,,<argument block address>
            ADDR+1: -count,,<attribute list address>

            On error return, FRMOP error is in AC right, positive index  into argument/attribute
            table is in AC left.

            .FORFA, .FOWFA, and .FOXFA  allow the user to  read or write frame  attributes which
            are otherwise unobtainable by the other FRMOP functions or other UUOs.

                attribute  description                        form
                1          the originating port for FD        full word

            It is intended that more attributes will be added as the need arises.  The user will
            then be able to specify a list of attributes and a negative count of  the attributes
            sought,  or an  address containing  a block  of arguments.   This block  will either
            contain space to which all the  frame's attributes will be deposited on a  .FORFA or
            else it will contain attributes that will be written into the specified  location so
            as to indicate a new attribute for frame FD.







                                                    2-35


            Frames and Processes                     2                          YAMM edition 2.1


            2.6.10    EXIT: stop frame execution (CALLI +12)
                      _____ ____ _____ _________ ______ ____

                    EXIT
                     or
                    EXIT    1,

            Clear JB.JAC and JB.JA2.

            If the accumulator field of the EXIT call is 0,

                Perform a RELEAS for each initted channel.  Perform a RESET.  Set JB.ERR.

            If the frame is detached, and has no parent frame,

                do a HANGUP for the frame  if JP.TIM is set; otherwise, wait for  someone to
                attach to it.

            (If the frame is  detached, but has a parent  frame, terminate the UUO here  with no
            further action.)

            If the accumulator field of the EXIT  call was 0, move the string CR LF  "EXIT" into
            the command port's output buffer.

            Print CR LF <WATCH data if any> CR LF CR LF <prompt character> on the  command port,
            and place the frame in command level.

            2.6.11    FLEXIT: fail exit, don't continue (CALLI -142)
                      _______ ____ _____ _____ ________ ______ _____

                    MOVE    AC, [frame exit error code]
                    FLEXIT

            where <frame exit error code> is either 0,,<octal number> or
            SIXBIT <one word error message>


            Clear JB.JAC and JB.JA2.

            Perform a RELEAS for each initted channel.  Perform a RESET.  Set JB.ERR.

            If the frame  is detached, and  has no parent  frame, do a  HANGUP for the  frame if
            JP.TIM is set; otherwise, wait for someone to attach to it.

            (If the frame is  detached, but has a parent  frame, terminate the UUO here  with no
            further action.)

            Print CR LF "?fail exit" <frame  exit error code> "at user" <location number>  CR LF
            CR LF <prompt character> on the command port, and place the frame in command level.

            The <frame  exit error  code> also  appears in the  halt status  block, if  any (see
            .FOHST UUO (FRMOP fn 23, pg. 2-27)).

            2.6.12    FLSTOP: fail exit, continue allowed (CALLI -147)
                      _______ ____ _____ ________ _______ ______ _____

                    MOVE    AC, [frame exit error code]
                    FLSTOP

            where <frame exit error code> is either 0,,<octal number> or
            SIXBIT <one word error message>

            (The <frame exit error code> also appears in the halt status block,
            if any.)


            Clear JB.JAC and JB.JA2.

            If the frame  is detached, and  has no parent  frame, do a  HANGUP for the  frame if
            JP.TIM is set; otherwise, wait for someone to attach to it.

                                                    2-36


            June 27, 1984                            2                      Frames and Processes


            (If the frame is  detached, but has a parent  frame, terminate the UUO here  with no
            further action.)

            Print CR LF "?fail stop" <frame  exit error code> "at user" <location number>  CR LF
            CR LF on the command port.  The frame is not placed at command level, and  no prompt
            is printed.  Although the job is stopped, it may be continued.

            2.6.13    SETSTV: set start vector address (CALLI -137)
                      _______ ___ _____ ______ _______ ______ _____

                    MOVE    ac,[<count>,,<addr>]
                    SETSTV  ac,
                      error return
                    normal return

            <count> locations starting at <addr>  contain start addresses in bits  18-35.  These
            addresses may be specified by the .FOSVA UUO (FRMOP fn 22, pg. 2-26) by giving their
            displacement from <addr>.  This is intended  to provide a means for a program  to be
            started at a fixed number of addresses without the parent frame having  knowledge of
            the actual address and without the need  for the parent frame to have the  rights to
            start at an arbitrary address.

            The  RESET  UUO (CALLI +0,  pg. 5-11)  does not  clear  the vector.   The  vector is
            cleared only when a new program is setup in the frame.


            2.7    Temporary files
                   _________ _____

            The  monitor provides  each frame  with  a small  number of  small  in-core "files",
            intended for such functions as  passing command lines between programs.   The TMPCOR
            files have three-character (SIXBIT) file  names.  Since there is only  limited space
            in the  monitor for  such files, it  is possible  that a program  will be  unable to
            create a TMPCOR file.  To get around this problem, a convention exists  where, after
            trying and failing to create a TMPCOR file, a program creates a disk file whose name
            is

                    <3-digit decimal frame #><TMPCOR filename>.TMP

            and  a  program  which  fails  to find  a  TMPCOR  file  likewise  searches  for the
            appropriate disk file.

            2.7.1    TMPCOR: do TMPCOR file i/o (CALLI +44)
                     _______ __ ______ ____ ___ ______ ____

                    MOVE    ac, [function,,addr]
                    TMPCOR  ac,
                      error return
                    normal return

            2.7.2    .TCRRF: read TMPCOR file (TMPCOR fn 1)
                     _______ ____ ______ ____ _______ __ __
            2.7.2    .TCRDF: delete TMPCOR file (TMPCOR fn 2)
                     _______ ______ ______ ____ _______ __ __

                    MOVE    ac, [.TCRRF or .TCRDF,,addr]
                    TMPCOR  ac,
                      error return
                    normal return

            where <addr> points to a block of the form
                    wd 0    SIXBIT /file name/,, 0
                    wd 1    -length,,base-1

            If the TMPCOR file specified by <file name> is not found, set c(<ac>) to  the number
            of words of TMPCOR storage available to the process, and nonskip-return.

            Otherwise,  copy  up to  <length>  words of  the  TMPCOR file  named  into locations
            starting at <base>, set c(<ac>) to the actual length (so the program can tell if its
            buffer was too short), delete the TMPCOR file if this is a .TCDRF, then skip-return.



                                                    2-37


            Frames and Processes                     2                          YAMM edition 2.1


            2.7.3    .TCRWF: write TMPCOR file (TMPCOR fn 3)
                     _______ _____ ______ ____ _______ __ __

                    MOVE    ac, [.TCRWF,,addr]
                    TMPCOR  ac,
                      error return
                    normal return

            where <addr> points to a block of the form
                    wd 0    SIXBIT /file name/,,0
                    wd 1    -length,,base-1

            If a TMPCOR file with the specified name already exists, delete it.   Check <length>
            against the number of words of free space available: if there is not enough room for
            the new file, set c(<ac>) to the number of free words and error-return.

            Otherwise, create a new  TMPCOR file, store into  it the <length> words  starting at
            <base>, set c(<ac>) to the number of free words left (after creating the  file), and
            skip-return.

            2.7.4    .TCRRD: read TMPCOR directory (TMPCOR fn 4)
                     _______ ____ ______ _________ _______ __ __
            2.7.4    .TCRDD: clear TMPCOR directory (TMPCOR fn 5)
                     _______ _____ ______ _________ _______ __ __

                    MOVE    ac, [.TCRRD or .TCRDD,,addr]
                    TMPCOR  ac,
                      JFCL  ; never taken
                    only return

            where <addr> points to a block of the form
                    wd 0    unused
                    wd 1    -length,,base-1

            Set c(<ac>)  to the number  of files in  the frame's TMPCOR  directory.  Read  up to
            <length> directory entries into locations starting at <base>, clear the directory if
            this is a .TCRDD, then skip-return.

            The entries are of the form

                    SIXBIT /file name/,,length

            2.7.5    .TCRFS: get free space count (TMPCOR fn 0)
                     _______ ___ ____ _____ _____ _______ __ __

                    MOVSI   ac, .TCRFS
                    TMPCOR  ac,
                      JFCL  ; never taken
                    only return

            Set c(<ac>) to the number of  words of TMPCOR storage available to the  process, and
            skip-return.




















                                                    2-38


            June 27, 1984                            3                            Virtual Memory


                                                 Section 3
                                                 _______ _
                                               Virtual Memory
                                               _______ ______

                                             Table of Contents



            SubSection


            3.1      High and Low Segments    3-1
            3.1.1       CORE: allocate or free core (CALLI +11)    3-1
            3.1.2       REMAP: move top of lowseg to highseg (CALLI +37)    3-2
            3.1.3       SETUWP: set highseg write protection (CALLI +36)    3-2

            3.2      Job Data Area    3-3
            3.2.1       Low Segment Job Data Area    3-3
            3.2.2       Vestigial Job Data Area    3-3
            3.2.3       SETDDT: set DDT start address (CALLI +2)    3-3

            3.3      Core image files    3-5
            3.3.1       SAVE and SSAVE operations    3-5
            3.3.2       GETSEG: load a high segment (CALLI +40)    3-6
            3.3.3       RUN: load and run a program (CALLI +35)    3-7
            3.3.4       RUNSEG: load and run a high segment (CALLI -25)    3-10

            3.4      Execute-Only Programs    3-11


            Table

            3-4      Job Data Area Locations    3-4




































                                                    3-i


                                                     3                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    3-ii


            June 27, 1984                            3                            Virtual Memory





                                                 Section 3
                                                 _______ _
                                               Virtual Memory
                                               _______ ______





            3.1    High and Low Segments
                   ____ ___ ___ ________

            A frame's address space is composed of 512 512-word pages.  The bottom 256 pages are
            called the "low segment" and the top 256 pages the "high segment".  This division is
            inherited from monitors designed to run on the KA-10, which, instead of page tables,
            had only a  pair of relocation  registers to map  user addresses into  physical core
            adddresses.  The high segment came to  be used for programs and data which  could be
            shared   by   all  frames   running   a  particular   program   (and   was  normally
            write-protected), and  the low  segment for impure  data which  was private  to each
            frame.

            A program can make its high  segment writable by executing a SETUWP  UUO (CALLI +36,
            pg. 3-2).  This  has the effect  of making the  high segment pages  from a  SHR file
            become copy-on-write and the high segment pages from a SWR file become  writable (so
            that stores into the  high segment actually modify  the file from which  the program
            was run).

            The  RUN UUO  (CALLI +35,  pg. 3-7), RUNSEG  UUO (CALLI -25,  pg. 3-10),  GETSEG UUO
            (CALLI +40,  pg. 3-6), and  the RUN,  GET, SAVE,  and SSAVE  commands  still reflect
            the high/low  division.  Programs  which share data  and code  among all  the frames
            executing them  are saved in  two parts, one  of which is  mapped directly  from the
            program file into addresses above '400000,  so that all the pages are shared  by all
            the frames  running the program,  the other  of which is  copied into  private pages
            below '400000.

            In addition, the monitor maintains (compatibly with pre-paging monitors) a notion of
            each frame's low and high segment sizes,  so that the CORE command and the  CORE UUO
            (CALLI +11, pg. 3-1), designed to expand and contract segments, still work.

            3.1.1    CORE: allocate or free core (CALLI +11)
                     _____ ________ __ ____ ____ ______ ____

                    MOVE    ac, [high,,low]
                    CORE    ac,
                      error return
                    normal return

            where <high> (<low>) = 0 to retain the current allocation,
                    or the highest address needed in the high (low) segment

            (On  any  return from  CORE,  the specified  accumulator  is set  to  the  amount of
            additional core (in 1K units) available to the process).

            If both <high> and <low> are 0, take the error return; otherwise, wait until all i/o
            for the current process has stopped, then proceed as follows:

            Let <monrel> be the value last  stored by the monitor into .JBREL, and  <monhrl> the
            value last stored by the monitor into .JBHRL.

            If <low> is nonzero,  let <lowtop> = <low> rounded  up to the next 1K  boundary.  If
            <lowtop> is above '400000 and c(.JBHRL right) is nonzero, take the error return.  If
            <lowtop> is less than  <monrel>, perform VCLEARs for  the pages between the  two; if
            <lowtop> is greater  than <monrel>, perform VCREATs  for the pages between  the two.
            If VCREAT or VCLEAR signal an error, take the error return; otherwise, set c(.JBREL)
            to <lowtop> and proceed.

            If <high> is nonzero, let <hightop> = <high> rounded up to the next 1K boundary.  If
            <monhrl> = 0,  take the error  return.  If <hightop>  is less than  '400000, perform

                                                    3-1


            Virtual Memory                           3                          YAMM edition 2.1


            VCLEARs  for  all the  pages  from '400  through  '777; if  <hightop>  is  less than
            <monhrl>, perform VCLEARs for all the pages between the two; if <hightop> is greater
            than <monhrl>,  perform VCREATs for  all the  pages between the  two.  If  VCLEAR or
            VCREAT signal  an error, take  the error return;  otherwise, set c(.JBHRL  right) to
            <hightop> and proceed.

            Skip-return.

            3.1.2    REMAP: move top of lowseg to highseg (CALLI +37)
                     ______ ____ ___ __ ______ __ _______ ______ ____

                    MOVE    ac, top
                    REMAP   ac,
                      error return
                    normal return

            Let <lowtop> be <top> rounded up to the next 1K boundary.  Let <monrel> be the value
            last stored by  the monitor into  .JBREL and <monhrl> the  value last stored  by the
            monitor into .JBHRL.

            If <lowtop>  is less than  0 or greater  than '377777, or  if <lowtop>  greater than
            <monrel>, take the error return.

            If <monhrl> is nonzero, VCLEAR the pages from '400 through '777.

            (In what  follows, <take the  error return>  means just that  unless REMAP  has done
            something to the page containing the return address, in which case abort the process
            and store halt status HT.RMF for the frame.  )

            If <lowtop> = <monrel>,  or if (<monrel> -  <lowtop>) is greater than  '400000, take
            the error return.

            Remap the pages containing <lowtop>+1  through <monrel> so that the  page containing
            <lowtop>+1  becomes  page '400  (and  so  forth), set  their  current  protection to
            read-only, and add them to the working set.

            3.1.3    SETUWP: set highseg write protection (CALLI +36)
                     _______ ___ _______ _____ __________ ______ ____

                    MOVEI   ac, prot
                    SETUWP  ac,
                      error return
                    normal return

            where <prot> = 0 to make the high segment writable
                           1 to make it read-only

            If the frame has no high segment, clear <ac> and skip-return.

            Let <oldprot> be 1 if the current protection of page '400 is read-only, 0 otherwise.

            If  <prot>  is  1,  perform  a  VPROT UUO  to  set  the  current  protection  of the
            high-segment  pages  to  read-only;  otherwise,  perform  a  VPROT  UUO  to  set the
            protection of the  high-segment pages to read/write  if the high segment  was loaded
            from a SWR file or to copy-on-write if it was not.

            If  the  VPROT  signals an  error,  reset  the protection  of  the  high  segment to
            read-only,  set c(<ac>)  =  <oldprot>, and  take  the error  return;  otherwise, set
            c(<ac>) = <oldprot> and skip-return.











                                                    3-2


            June 27, 1984                            3                            Virtual Memory


            3.2    Job Data Area
                   ___ ____ ____

            Certain areas of  a frame's address space  are typically reserved  for communication
            between the process  and the monitor.  Although  these remain mostly  for historical
            reasons, they are still used by  the monitor and contain a good deal  of information
            useful to the user.

            3.2.1    Low Segment Job Data Area
                     ___ _______ ___ ____ ____

            The locations 20 through 137 of the frame's address space are typically  reserved as
            the Job data  area.  These locations contain  information of mutual interest  to the
            process  and  the  monitor.   Unless  the  use  agrees  with  those  shown  in table
            Table 3-4  a user program should avoid accessing these locations.

            The  file  SYS:JOBDAT.REL   contains  the  symbols   for  these  locations   and  is
            automatically loaded by the loader.  The loading of this file also causes  the first
            relocatable data from a program to be loaded at location 140.

            Note that it is possible to remove page 0 from the frame's address space and perhaps
            replace it with a file page.  This procedure is not recommended.

            3.2.2    Vestigial Job Data Area
                     _________ ___ ____ ____

            Some constants in the Job data area may be loaded from the high segment  file (.HGH,
            .SHR or .SWR).  This removes the need  for a low segment file to accompany  the high
            segment  file in  the event  that there  is no  low segment.   The first  10 (octal)
            locations of the high  segment are reserved for  the vestigial job data  area.  When
            such a program  is saved using  the SAVE or SSAVE  monitor commands, no  low segment
            file is  created unless the  left half of  .JBCOR is 140  (octal) or  greater.  High
            segment programs will  be loaded with their  first relocatable location at  the high
            segment origin  (400000+10 octal).   Again, use of  these locations  which conflicts
            with the uses described in Table 3-4  should be avoided.

            3.2.3    SETDDT: set DDT start address (CALLI +2)
                     _______ ___ ___ _____ _______ ______ ___

                    MOVE    ac, addr
                    SETDDT  ac,
                    only return

            Set .JBDDT to <addr> and return.




























                                                    3-3


            Virtual Memory                           3                          YAMM edition 2.1


                                                 Table 3-4 
                                                 _____ ___ 
                                          Job Data Area Locations
                                          ___ ____ ____ _________


            symbol   loc        bits description

            .JBUUO   40              LUUO word stored here by hardware
            .JB41    41              LUUO instruction fetched from here by hardware (see
                                     DECsystem-10 DECsystem-20 Processor Reference Manual)
            .JBERR   42         LH:  (unused)
                                RH:  Used by CUSPs to record the number of errors detected:
                                     incremented for each error. (Obsolete)
            .JBREL   44         LH:  (always 0)
                                RH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, by
                                     the RUN and GET commands, and by the loader, to the highest
                                     low-segment address.
            .JBBLT   45-47           Used by the loader to store a 3-instruction loop to copy
                                     the loaded program into its proper position.
            .JBMUU   66              On an INTADR illegal-instruction or UUO trap, holds the
                                     illegal instruction or UUO executed.
            .JBHCU   72              Contains the channel number of the highest-numbered channel
                                     currently initted.
            .JBDDT   74         LH:  The highest address occupied by DDT.
                                RH:  The starting address of DDT, or 0 if ddt is not loaded.
                                     This is the address branched to by the DDT command.
            .JBJDA   75-114          For channels 0 through '17, .JBJDA(channel no.) is nonzero
                                     iff the channel is initted, so a program can scan .JBJDA to
                                     find a vacant channel.  Note that .JBHCU can be greater
                                     than '17, so it should not be used blindly as an index into
                                     .JBJDA.
            .JBCNK   102-110         Temporaries used by CHAIN (see the LOADER manual).
            .JBCN6   106-114         Temporaries used by CHAIN (see the LOADER manual).
            .JBPFI   114             Highest "protected" location in the frame data area: all
                                     i/o must be to locations above .JBPFI.
            .JBHRL   115        LH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, by
                                     the RUN and GET commands, and by the loader, to the length
                                     of the high segment.
                                RH:  Set by the RUN, RUNSEG, GETSEG, REMAP, and CORE UUOs, and
                                     by the loader, to the highest high-segment address.  by the
                                     GET and RUN commands, and by the loader, to the highest
                                     high-segment address.
            .JBSYM   116             AOBJN pointer to the symbol table created by the loader, or
                                     0 if there is no symbol table.
            .JBUSY   117             AOBJN pointer to the undefined-symbol symbol table created
                                     by the loader or DDT, or 0 if there are no undefined
                                     symbols.
            .JBSA    120        LH:  Set by the loader to the first free low-segment address.
                                RH:  Set by the loader to the program's start address.  The RUN
                                     command starts a program at this address.  The RPG program
                                     starts a program at this address+1.
            .JBFF    121        LH:  (always 0)
                                RH:  Set to c(.JBSA left) by the RESET UUO.  Used in
                                     buffered-mode i/o as the starting point for allocating
                                     buffers, and advanced as buffers are allocated.
            .JBREN   124        LH:  (unused)
                                RH:  Set by the loader to the program's reenter address.  The
                                     REENTER command transfers control to the address stored
                                     here.
            .JBAPR   125        LH:  (always 0)
                                RH:  The APRENB trapping system transfers control to the routine
                                     whose address is stored here.
            .JBCNI   126             The APRENB trapping system simulates a CONI APR into this
                                     location before dispatching to the user's routine.
            .JBTPC   127             The APRENB trapping system stores the user's PC here before
                                     dispatching to the user's trap routine.
            .JBOPC   130             The DDT, START, REENTER, and CSTART commands store the last
                                     user-mode PC here before proceeding.

                                                    3-4


            June 27, 1984                            3                            Virtual Memory

            symbol   loc        bits description
            .JBCHN   131        LH:  Set, in FORTRAN programs, to the address one above the last
                                     program loaded.
                                RH:  Set, in FORTRAN programs, to the address one above the last
                                     block data area loaded.
            .JBCOR   133        LH:  Set by the loader to the highest low-segment address
                                     containing nonzero data.  (If c(.JBCOR left) < 140, the
                                     SAVE and SSAVE commands will not create a low-segment
                                     file).
                                RH:  Set to the core argument of the last SAVE, SSAVE, RUN, or
                                     GET command.
            .JBCST   136             This location is for customers to use as they please
            .JBVER   137             Contains a version number for the program.
            .JBDA    140             This is the first location available to the user.





                                     Vestigial Job Data Area Locations
                                     _________ ___ ____ ____ _________

            Symbol   Loc *      Bits Description

            .JBHSA   0               A copy of .JBSA.
            .JBH41   1               A copy of .JB41.
            .JBHCR   2               A copy of .JBCOR.
            .JBHRN   3          LH:  Restores the left half of .JBHRL.
                                RH:  Restores the right half of .JBREN.
            .JBHNM   5               The high segment name which was set on the execution of a
                                     SAVE command.
            .JBHSM   6               A pointer to the high segment symbols, if any.
            .JBHDA   10              First location available to user.

            * - These locations are relative to 400000



            3.3    Core image files
                   ____ _____ _____

            This section  describes the  RUN and GET  operations provided  by the  monitor.  The
            monitor SAVE operation produces  a file or files which  can be loaded by GET  or RUN
            operations.  Its format is described  below.  RUN and GET operations can  be invoked
            by a variety of UUOs and by commands given to the monitor's command interpreter.

            The RUN  operation is that  action described for  the RUN UUO  (CALLI +35, pg. 3-7).
            The GET  operation is exactly  the same except  that the last  step, entry  into the
            retrieved program, is not taken.

            3.3.1    SAVE and SSAVE operations
                     ____ ___ _____ __________

            The high segment of a two-segment core-image is saved in a file having one  of these
            extensions:
                1)  .SHR.  Used to hold pages of a high segment which is sharable.  Normally
                    SHR files hold pure code.  The GET and RUN operations will map  pages of
                    a SHR file read-only.  The SETUWP UUO (CALLI +36, pg. 3-2) will make the
                    pages copy-on-write if it is asked to make the segment writable.
                2)  .SWR.  Used to hold pages of a sharable-writable high-segment.   The GET
                    and  RUN operations  will  map pages  read-only  but maximally-writable.
                    SETUWP will make the pages read-write.
                3)  .HGH.  Used to hold pages of  a high-segment which is not to  be shared.
                    GET,RUN and SETUWP operate as on SHR file pages.

            The  SAVE  command will  create  a  .HGH file  from  the high  segment  of  a loaded
            two-segment program; the SSAVE command will  create a .SHR file.  To save  a program
            with a sharable-writable high segment, the  SSAVE command is used and the  .SHR file
            renamed to .SWR.

            The low segment of a two-segment program is normally saved (by SSAVE) in a file with

                                                    3-5


            Virtual Memory                           3                          YAMM edition 2.1


            the extension .LOW, and  a single-segment program is  normally saved (by SAVE)  as a
            file with the extension .SAV.  If,  however, the SAVE or SSAVE commands are  given a
            file extension, they will use that instead.  For example,

                    SSAVE FOO.BAZ

            will produce a high-segment file named FOO.SHR and a low-segment file named FOO.BAZ.

            High-segment files simply  store the pages that  were mapped into  addresses '400000
            and above at the time of the SAVE or SSAVE.

            Low-segment files  are zero-compressed: for  each nonzero sequence  of words  in the
            address  space, starting  with location  0, they  contain an  IOWD for  the sequence
            (whose left half is a  negative word count and whose  right half is 1 less  than the
            address into which the first word of  the sequence is to be loaded) followed  by the
            sequence itself.  The last "IOWD" (the word in the file following the  last sequence
            of nonzero data) is either a HALT or a JRST instruction.

            There are numerous  ways to invoke  the GET, RUN and  SAVE operations on  core image
            files:
                1)  RUN UUO (see below)
                2)  RUNSEG UUO (see below)
                3)  RUN and R commands
                4)  .FORUN UUO (FRMOP fn 33, pg. 2-29)
                5)  GETSEG UUO (see below)
                6)  GET command
                7)  .FOGET UUO (FRMOP fn 32, pg. 2-23)
                8)  SAVE and SSAVE commands
                9)  .FOSAV UUO (FRMOP fn 34, pg. 2-24)
                10)  .FOSSA UUO (FRMOP fn 35, pg. 2-24)

            3.3.2    GETSEG: load a high segment (CALLI +40)
                     _______ ____ _ ____ _______ ______ ____

                    MOVEI   AC, addr
                    GETSEG  AC,
                      error return  ; AC/ error code
                    normal return

            where <addr> points to a block of the form
                    SIXBIT /device name/
                    SIXBIT /file name/
                    0       ; ignored
                    0       ; ignored
                    ppn
                    0       ; ignored

            and <ppn> is one of
                    0 (or negative)                   ; the current process's PPN
                    0,,[SIXBIT /username/]            ; the AUN of the specified
                                                      ;   (two-word) username
                    project number,,programmer number ; that PPN

            and <error code> is an error code from Table 8-19 

            If c(.JBREL) >= '400000, take the  error return.  Perform an OPEN operation  for the
            specified device: if it fails take the error return unless the error return location
            contains a HALT instruction, in which case abort the operation and store halt status
            HT.DNA for the frame.

            Attempt to LOOKUP, in the following order,

            <file name> . SHR
            <file name> . HGH
            <file name> . SWR

            If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
            location contains a  HALT instruction, in which  case abort the operation  and store

                                                    3-6


            June 27, 1984                            3                            Virtual Memory


            halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
            (that is, using the first file successfully looked-up).

            Perform  a VCLEAR  operation on  all pages  from '400  through '777  of  the current
            process's  address  space.   If  GETSEG  was  called  from  an  address  >= '400000,
            subsequent <error return>s will instead abort the operation with either a  HT.TRE or
            HT.PGN halt  status, depending on  the device.  (This  is due to  the fact  that the
            caller's program no longer exists to which the monitor could return).

            If the device is a magtape,

                Read one standard-length magtape record into locations starting  at '400000.
                Then, based on c(.JBHRN left) in the vestigial "job data area" (part  of the
                record just read in), input  successive records until all the file  has been
                read: if an unexpected EOF occurs, abort the operation and store halt status
                HT.TRE for the frame.

                Perform  a  VPROT UUO  to  make all  the  pages just  created  and read-into
                read-only.  If the number of pages is odd, create a private page above them,
                to make the total number of  words a multiple of 1K.  Set c(.JBHRL  right) =
                the highest address read-into or created.

            Otherwise, the device must be a disk:

                If the file's  size is greater than  '377777 words, abort the  operation and
                store halt status HT.PGN for the frame.

                Otherwise, perform a VMAP UUO,  mapping the file's pages read-only  into the
                current  process's address  space, starting  at virtual  page '400:  if VMAP
                signals an error, abort the  operation and store halt status HT.TRE  for the
                frame.  If the file's extension is SWR, make the pages maximally-writable.

                Perform a WSCTL UUO to add the mapped pages to the current process's working
                set, and ignore any  error return.  If the  number of pages mapped  was odd,
                create a private page  above the mapped pages,  to make the total  number of
                words a  multiple of  1K.  Set  c(.JBHRL left)  = 0,  c(.JBHRL right)  = the
                highest address of the highest page mapped or created.

            Perform a RELEASE operation for channel 0, then skip-return.

            3.3.3    RUN: load and run a program (CALLI +35)
                     ____ ____ ___ ___ _ _______ ______ ____

                    MOVE    AC, [start,,addr]
                    RUN     AC,
                      error return  ; AC/ error code
                    ; normal return is to .JBSA of the loaded program
                    ; + <start>

            where <addr> points to a block of the form
                    SIXBIT /device name/
                    SIXBIT /file name/
                    SIXBIT /file extension/
                    0       ; ignored
                    ppn
                    license,,core

            and <ppn> is one of
                    0 (or negative)                   ; the current process's PPN
                    0,,[SIXBIT /username/]            ; the AUN of the specified
                                                      ;   (two-word) username
                    project number,,programmer number ; that PPN

            and <error code> is an error code from Table 8-19 

            (The phrase "abort the operation and store halt status HT.xxx" appears several times
            in the discussion below.  The action  of the system at each such point  depends upon
            the context.  If the operation occurs in  a frame with no parent to which a  port is

                                                    3-7


            Virtual Memory                           3                          YAMM edition 2.1


            attached, then the  system error message corresponding  to that halt status  will be
            output on the port.  See Table 2-28 for halt status definitions.)

            Perform  a RESET  UUO.  Set  JBTNAM to  the specified  file name.   Perform  an OPEN
            operation for the  specified device: if  it fails take  the error return  unless the
            error return location contains a HALT instruction, in which case abort the operation
            and store halt status HT.DNA for the frame.

            Attempt to LOOKUP, in the following order,

            <file name> . SHR
            <file name> . HGH
            <file name> . <file extension>
                (or <file name> . SAV if <file extension> = 0)
            <file name> . SWR

            If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
            location contains a  HALT instruction, in which  case abort the operation  and store
            halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
            (that is, using the first file successfully looked-up).

            Perform a VCLEAR operation on all pages but page 0 of the current  process's address
            space.  Set c(.JBREL right) and c(.JBHRL) = 0.

            Let <core request> initially = <core>.   Let <size> be <core request> if  the device
            is a magtape, or the file's size if the device is a disk.

            If the file's extension is SHR, HGH, or SWR,

                If <core request> is greater  than the file's size, decrease  <core request>
                by <size>.

                If the device is a disk,

                    If  the  file's  size  is  greater  than  '377777  words,  abort the
                    operation and store halt status HT.PGN for the frame.

                    Otherwise, perform  a VMAP UUO,  mapping the file's  pages read-only
                    into the current process's  address space, starting at  virtual page
                    '400: if VMAP signals an  error, abort the operation and  store halt
                    status HT.TRE for the frame.   If the file's extension is  SWR, make
                    the pages maximally-writable.

                    Perform a WSCTL UUO to add the mapped pages to the current process's
                    working set, and  ignore any error return.   If the number  of pages
                    mapped was  odd, create a  private page above  the mapped  pages, to
                    make the total number of words a multiple of 1K.  Set c(.JBHRL left)
                    =  0, c(.JBHRL  right) =  the highest  address of  the  highest page
                    mapped or created.

                Otherwise, the device must be a magtape:

                    Read one standard-length  magtape record into locations  starting at
                    '400000.  Then, based on  c(.JBHRN left) in the vestigial  "job data
                    area" (part of  the record just  read in), input  successive records
                    until all the file has been read: if an unexpected EOF occurs, abort
                    the operation and store halt status HT.TRE for the frame.

                    Perform a VPROT UUO to make all the pages just created and read-into
                    read-only.  If  the number of  pages is odd,  create a  private page
                    above them, to make the total number of words a multiple of 1K.  Set
                    c(.JBHRL right) = the highest address read-into or created.

                Set c(.JBVER), c(.JBHRL left), rh(.JBREN), c(.JBCOR), c(.JB41), and c(.JBSA)
                from the corresponding  locations in the  vestigial "Job Data  Area".  Clear
                the rest of the "Job  Data Area" locations from .JBSA through  .JBDA.  Clear
                .JBDDT.

                                                    3-8


            June 27, 1984                            3                            Virtual Memory


                If <file  extension> was 0,  and c(.JBCOR left)  is an address  below .JBDA,
                clear  page 0  above .JBDA.   Starting with  page 1,  create  enough private
                read/write pages to  include the address in  c(.JBCOR right), rounded  up to
                the next 1K boundary.  Set c(.JBREL right) to the highest address created.

                If <file extension> was nonzero, or the address stored in c(.JBCOR left) was
                above  c(.JBDA),  LOOKUP  <file name>.<file  extension>  or  <file name>.LOW
                (respectively):  if the  LOOKUP fails,  abort the  operation and  store halt
                status HT.FNF.  Let <size> be <core request> if the device is a  magtape, or
                the file's size if  the device is a disk.   If <size> is greater  than 128K,
                abort the operation and store halt status HT.PGN.  otherwise, load  the file
                as described below for non-(SHR, HGH, SWR) files.

            If the extension is not SHR, HGH, or LOW:

                Let <needed> be the address of the highest location needed to load a file of
                <size> words starting at the  location after .JBSVM, rounded up to  the next
                1K boundary.  If <core request> is  nonzero but is less, when rounded  up to
                the  next 1K,  than  <needed>, abort  the  operation and  store  halt status
                HT.PGN.  Otherwise, perform a VCREAT UUO to allocate pages up to  the larger
                of  <needed> or  <core  request> (aborting  the operation  and  storing halt
                status HT.PGN if it fails), then  perform a WSCTL UUO to add those  pages to
                the current process's working set, ignoring any error return.  Set c(.JBREL)
                = the highest address created.

                Perform an INPUT UUO  to read the file  into memory starting at  the address
                after .JBSVM: if INPUT signals an error, abort the operation and  store halt
                status HT.TRE.  If  the first word read  was negative, expand the  file read
                (see below).

                Let <needed> be  c(.JBCOR right) after reading  in the file, or  the highest
                address created  to read  in the  file if  c(.JBCOR right)  is 0.   If <core
                request> is nonzero  and less than <wanted>,  abort the operation  and store
                halt status HT.PGN.  Otherwise, perform the equivalent of a CORE UUO for the
                maximum of <needed> and <core request>: if it fails, abort the operation and
                store halt status  HT.PGN; otherwise, set c(.JBREL  right) = the  maximum of
                <needed> and <core request>.

                Set c(.JB41) = c(.JBS41).

            Set <passed license>  to minimum of <license>  and the current process  license (but
            set the read(write) privilege to  0 if <license>'s read(write) privilege  is greater
            than the current process's).  If the device is a magtape, or if the device is a disk
            and the  file's ppn differs  from the frame's  FPN, clear the  LC.HF bit  in <passed
            license>.

            Set the <execute only> bit of  the frame privilege word if an execute-only  file was
            read, or  if a file  with extension SWR  that had nonzero  license (or to  which the
            current  process  did  not have  update  access)  was loaded  as  the  high segment;
            otherwise, clear it.

            If the device is a  magtape, let <file license> be 0.   If the device is a  disk and
            only a  single file  was loaded,  let <file license>  be its  license word.   If the
            device is  a disk and  both a  low and a  high segment file  were loaded,  let <file
            license> be the  minimum of the  two files' license  words (but set  the read(write)
            privilege to 0 if the files' read(write) privileges are not the same).

            Set the process'  current license and  the frame's saved  license to the  maximum of
            <passed license>, <file license>, and the frame's current license.

            If the device is a disk, let the process' PID be:
                1)  <file PID> if only one file was loaded
                2)  <file PID> if  both high and  low files were  loaded and the  files have
                    identical PID
                3)  zero if two files were loaded with different PID

            Write a type 0 accounting record for the current frame.

                                                    3-9


            Virtual Memory                           3                          YAMM edition 2.1


            3.3.4    RUNSEG: load and run a high segment (CALLI -25)
                     _______ ____ ___ ___ _ ____ _______ ______ ____

                    MOVE    AC, [start,,addr]
                    RUNSEG  AC,
                      error return  ; AC/ error code
                    ; normal return is to .JBSA of the loaded program
                    ; + <start>

            where <addr> points to a block of the form
                    SIXBIT /device name/
                    SIXBIT /file name/
                    0       ; ignored
                    0       ; ignored
                    ppn
                    license,,0      ; right half ignored

            and <ppn> is one of
                    0 (or negative)                   ; the current process's PPN
                    0,,[SIXBIT /username/]            ; the AUN of the specified
                                                      ;   (two-word) username
                    project number,,programmer number ; that PPN

            and <error code> is an error code from Table 8-19 

            Set .GTNAM for the  frame to <file name>.  If  c(.JBREL) >= '400000, take  the error
            return.  Perform an OPEN  operation for the specified  device: if it fails  take the
            error return unless the error return location contains a HALT instruction,  in which
            case abort the operation and store halt status HT.DNA for the frame.

            Attempt to LOOKUP, in the following order,

            <file name> . SHR
            <file name> . HGH
            <file name> . SWR

            If none  of the  LOOKUPs succeeds,  take the  error return  unless the  error return
            location contains a  HALT instruction, in which  case abort the operation  and store
            halt status HT.FNF  for the frame.   If a LOOKUP  succeeds, proceed using  that file
            (that is, using the first file successfully looked-up).

            Perform  a VCLEAR  operation on  all pages  from '400  through '777  of  the current
            process's  address  space.   If  RUNSEG  was  called  from  an  address  >= '400000,
            subsequent <error return>s will instead abort the operation with either a  HT.TRE or
            HT.PGN halt  status, depending on  the device.  (This  is due to  the fact  that the
            caller's program no longer exists to which the monitor could return).

            If the device is a magtape,

                Read one standard-length magtape record into locations starting  at '400000.
                Then, based on c(.JBHRN left) in the vestigial "job data area" (part  of the
                record just read in), input  successive records until all the file  has been
                read: if an unexpected EOF occurs, abort the operation and store halt status
                HT.TRE for the frame.

                Perform  a  VPROT UUO  to  make all  the  pages just  created  and read-into
                read-only.  If the number of pages is odd, create a private page above them,
                to make the total number of  words a multiple of 1K.  Set c(.JBHRL  right) =
                the highest address read-into or created.

            Otherwise, the device must be a disk:

                If the file's  size is greater than  '377777 words, abort the  operation and
                store halt status HT.PGN for the frame.

                Otherwise, perform a VMAP UUO,  mapping the file's pages read-only  into the
                current  process's address  space, starting  at virtual  page '400:  if VMAP
                signals an error, abort the  operation and store halt status HT.TRE  for the
                frame.  If the file's extension is SWR, make the pages maximally-writable.
                                                    3-10


            June 27, 1984                            3                            Virtual Memory


                Perform a WSCTL UUO to add the mapped pages to the current process's working
                set, and ignore any  error return.  If the  number of pages mapped  was odd,
                create a private page  above the mapped pages,  to make the total  number of
                words a  multiple of  1K.  Set  c(.JBHRL left)  = 0,  c(.JBHRL right)  = the
                highest address of the highest page mapped or created.

            Set <passed license>  to minimum of <license>  and the current process  license (but
            set the read(write) privilege to  0 if <license>'s read(write) privilege  is greater
            than the current process's).  If the device is a magtape, or if the device is a disk
            and the  file's ppn differs  from the frame's  FPN, clear the  LC.HF bit  in <passed
            license>.

            Set the <execute only> bit of  the frame privilege word if an execute-only  file was
            read, or  if a file  with extension SWR  that had nonzero  license (or to  which the
            current process  did not have  update access) was  loaded ; leave  it set if  it was
            already set at the time of the RUNSEG; and clear it otherwise.

            If the device is a  magtape, let <file license> be 0.   If the device is a  disk and
            only a  single file  was loaded,  let <file license>  be its  license word.   If the
            device is  a disk and  both a  low and a  high segment file  were loaded,  let <file
            license> be the  minimum of the  two files' license  words (but set  the read(write)
            privilege to 0 if the files' read(write) privileges are not the same).

            Set the process'  current license and  the frame's saved  license to the  maximum of
            <passed license>, <file license>, and the frame's current license.

            If the device is a disk, let the process' PID be:
                1)  <file PID> if only one file was loaded
                2)  <file PID> if  both high and  low files were  loaded and the  files have
                    identical PID
                3)  zero if two files were loaded with different PID

            Write a type 0 accounting record for the current frame.

            Set  c(.JBVER), c(.JBREN  right), c(.JBCOR),  c(.JB41) and  c(.JBSA right)  from the
            corresponding locations  in the vestigial  "job data area."  Set c(.JBREN  left) and
            c(.JBDDT) = 0.

            Perform the equivalent of an APRENB UUO with an argument of 0.

            Let <starting increment> be  <start>.  If the JP.EXO  bit was previously set  in the
            frame  privilege word,  clear all  but  1B35 of  <starting increment>.   If  the new
            <starting increment> is not either 0 or 1, clear the current process license and the
            current frame's saved license.  Add <starting increment> to c(.JBSA).  If the result
            is between 0 and '77, abort the operation and store halt status HT.NSA.

            Enter the loaded program at the address stored in c(.JBSA).


            3.4    Execute-Only Programs
                   ____________ ________

            The monitor bit JP.EXO is used to prevent the users of programs from  doing anything
            but running them.  It prevents  operations from examining or modifying the  VM space
            of the program, starting it at arbitrary locations, or saving it.  JP.EXO is  set by
            the following operations:
                1)  RUN command,  RUN UUO (CALLI +35,  pg. 3-7) or .FORUN  UUO (FRMOP fn 33,
                    pg. 2-29)
                2)  RUNSEG UUO (CALLI -25, pg. 3-10)
                3)  GET command, .FOGET UUO (FRMOP fn 32, pg. 2-23)

            whenever any of the following conditions prevails:
                1)  JP.EXO is already set before  RUN or RUNSEG is issued. (In  other words,
                    if an EXO program  RUNs other programs which  are not EXO, EXO  stays on
                    anyway)
                2)  file  from  which  program  is  being  run  has  protection  FP.RUN. See
                    Table 8-7 .
                3)  file extension is SWR and file has license

                                                    3-11


            Virtual Memory                           3                          YAMM edition 2.1


                4)  file extension is SWR and frame does not have at least update  access to
                    the file


































































                                                    3-12


            June 27, 1984                            4                                    Paging


                                                 Section 4
                                                 _______ _
                                                   Paging
                                                   ______

                                             Table of Contents



            SubSection


            4.1      Hardware Paging    4-1

            4.2      Software Paging    4-1
            4.2.1       Page Types    4-1
            4.2.2       Working Sets    4-2
            4.2.3       Sharing    4-2
            4.2.4       Protection    4-2

            4.3      Creating Private Pages    4-3
            4.3.1       VCREAT: create private pages (CALLI -67)    4-3

            4.4      Unmapping Virtual Pages    4-4
            4.4.1       VCLEAR: unmap pages (CALLI -66)    4-4
            4.4.1       VREMOV: unmap pages (CALLI -65)    4-4

            4.5      Replicating Virtual Pages    4-4
            4.5.1       VREPLC: replicate virtual pages (CALLI -64)    4-4

            4.6      Mapping File Pages    4-5
            4.6.1       .CHMFP: map file pages (CHANIO fn 35)    4-5

            4.7      Mapping Absolute Disk Pages    4-6
            4.7.1       .CHSMP: super-map file pages (CHANIO fn 43)    4-6

            4.8      Changing Page Protection    4-7
            4.8.1       VPROT: set current protection for pages (CALLI -70)    4-7

            4.9      Working Set Control    4-7
            4.9.1       WSmax, WSlim, WSsiz    4-7
            4.9.2       WSCTL: do working set functions (CALLI -74)    4-8
            4.9.3       .WSRNG: add/remove pages from working set (WSCTL fn 1)    4-8
            4.9.4       .WSRSZ: read WSSIZ (WSCTL fn 3)    4-8
            4.9.4       .WSRLM: read WSLIM (WSCTL fn 4)    4-8
            4.9.4       .WSRMX: read WSMAX (WSCTL fn 5)    4-8
            4.9.4       .WSSTL: set WSLIM (WSCTL fn 2)    4-8
            4.9.5       .WSRBM: read working set bits (WSCTL fn 0)    4-9

            4.10     Prereferencing Pages    4-9
            4.10.1      PREREF: prereference a page (CALLI -75)    4-10

            4.11     Uninterruptible Page Copy    4-10
            4.11.1      BLTPAG: change data in page uninterruptibly (CALLI -123)    4-10

            4.12     Paging Related Errors    4-11
            4.12.1      Illegal Memory Reference    4-11
            4.12.2      Page Errors    4-11
                           PERSET: set/clear error bit (CALLI -72)    4-11
                           PGESTS: read/clear page-error status words (CALLI -100)    4-12
            4.12.3      Validating Pages    4-13
                           VALPAG: validate pages (CALLI -76)    4-13

            4.13     Page Faults    4-14
            4.13.1      Page Fault Word    4-14
            4.13.2      PGFSTS: read and clear page fault words (CALLI -101)    4-15
            4.13.3      PGRSTS: read/clear REFBIT fault info (CALLI -133)    4-15
            4.13.3      PGISTS: read/clear ill mem ref fault info (CALLI -132)    4-15

            4.14     Page Reference Bits    4-15
                                                    4-i


            Paging                                   4                          YAMM edition 2.1

            SubSection
            4.14.1      REFBIT: manipulate reference bits (CALLI -73)    4-16
            4.14.2      .RFRBM: Read refbits (Refbit fn 0)    4-16
            4.14.2      .RFSBM: Set refbits from bitmap (Refbit fn 1)    4-16
            4.14.3      .RFRNG: set refbits by range (Refbit fn 2)    4-16

            4.15     Virtual Page Information    4-17
            4.15.1      Page Status Word    4-17
                           PAGSTS: read page status word (CALLI -71)    4-17
            4.15.2      Testing for File Membership    4-18
                           VFSTAT: check private/file page (CALLI -77)    4-18
                           VPGFIL: get mapped-file name for page (CALLI -103)    4-18
            4.15.3      Disk Retrieval Pointers    4-19
                           VDSKPT: read disk pointer (CALLI -102)    4-19


            Table

            4-3      Page Protection Codes    4-3
            4-3b     VCREAT Error Codes    4-3
            4-7      VPROT Error Codes    4-7
            4-9      WSCTL Error Codes    4-9
            4-10     PREREF Error Codes    4-10
            4-11     BLTPAG error codes    4-11
            4-12     PERSET Error Codes    4-12
            4-13     Page-error Status-word    4-13
            4-14     VALPAG Error Codes    4-14
            4-14b    Page Fault Word    4-14
            4-15     PGRSTS and PGISTS word formats    4-15
            4-16     REFBIT Error Codes    4-16
            4-17     Page Status Word Format    4-17
            4-17b    PAGSTS Error Code    4-17
            4-19     VPGFIL Error Codes    4-19
            4-19b    VDSKPT Error Codes    4-19
            4-20     Standard Paging error Codes    4-20


































                                                    4-ii


            June 27, 1984                            4                                    Paging





                                                 Section 4
                                                 _______ _
                                                   Paging
                                                   ______





            4.1    Hardware Paging
                   ________ ______

            The KI-10 hardware splits each 18-bit address into two parts -- a 9-bit  page number
            and  a 9-bit  word address  within that  page.  It  converts this  two-part "virtual
            address" into a "real  address" (the address of a  word in core) by indexing  into a
            "page table" with  the page number  to obtain the high-order  bits of the  real core
            address, then OR-ing-in the word address to obtain the low-order bits.

            Each of the 512 entries in  a hardware page table also contains an  "accessible" bit
            and a "writable" bit.  If a user process attempts a memory reference to a page whose
            "accessible" bit is off, that operation  will trap to the monitor; similarly,  if it
            attempts to write  into a page  whose "writable" bit is  off, the operation  will be
            trapped.


            4.2    Software Paging
                   ________ ______

            The monitor maintains  a "logical page  table", or map,  for each process,  which it
            uses to set up the hardware map while that process is running.

            The main difference between the two  is that the logical page table  entries contain
            disk  page  addresses  while  the hardware  page  table  entries  contain  core page
            addresses.  A disk page is said to be "mapped to" a virtual page if the logical page
            table entry for  that virtual page  contains the address of  that disk page;  a disk
            page is said to be "mapped into a process's address space" if that page is mapped to
            some virtual page for that process.

            4.2.1    Page Types
                     ____ _____

            A virtual page may either exist or  not exist; it "exists" if it has some  disk page
            mapped to it and does not exist otherwise.

            The  monitor  will signal  an  "illegal memory  reference"  if a  frame  attempts to
            reference a nonexistent page.

            A disk page which is  part of some file is a  "file page"; all other disk  pages are
            available for  allocation as new  file pages or  as "private"  pages--virtual memory
            pages  created  by the  CORE  UUO  (CALLI +11, pg. 3-1)  or  VCREAT  UUO (CALLI -67,
            pg. 4-3) which  disappear once  the process(es)  using them  disappear, or  when all
            users of  them remove  them from their  address spaces  with VREMOV  UUO (CALLI -65,
            pg. 4-4).

            The total  number of  existent pages  in a frame's  map cannot  be greater  than the
            current value of the .JPCOR field of the frame's Frame Privilege Word.














                                                    4-1


            Paging                                   4                          YAMM edition 2.1


            4.2.2    Working Sets
                     _______ ____

            Each entry in a  frame's map has an  "in-working-set" bit.  Before running  a frame,
            the  monitor  checks  every  existent   virtual  page  in  the  frame's   map  whose
            "in-working-set" bit  is on, brings  its disk page  into core if  it is  not already
            there, and sets up the corresponding hardware map entry to point to the core page.

            The monitor will signal a "page fault" if a frame attempts to reference  an existent
            virtual page whose "in-working-set" bit is zero.

            To the  monitor, the  "working set"  of a  process is  that set  of its  pages whose
            "in-working-set" bits are 1.   The monitor charges a  frame for (1) its  working set
            size over time, and (2) for each addition to its working set.

            The actual working set of a process (that is, the set of pages which it must have in
            core  to run  efficiently) will  often be  smaller than  the total  number  of pages
            mapped, and its membership fairly stable over time.  To run a  program economically,
            it is necessary to  make the state of  the "in-working-set" bits reflect  the actual
            working set of the process.  Some techniques for doing this are discussed on 4-7.

            4.2.3    Sharing
                     _______

            If a disk page is  referred to by more than one  map entry, that page is said  to be
            "shared".   (Even private  pages can  be shared,  since the  VREPLC  UUO (CALLI -64,
            pg. 4-4) can make two entries in a process's map refer to the same private page).

            The monitor guarantees  that, if two  running processes have  the same disk  page in
            their working sets,  their hardware page  tables will be  pointing to the  same core
            page.  (The same  is true if one  process has the same  page appearing twice  in its
            map).

            4.2.4    Protection
                     __________

            Each  entry  in  a  frame's  map  has  a  "maximally-writable"  bit  and  a "current
            protection" field.  The current  protection can be "read-only",  "copy-on-write", or
            "read/write".  A  process can  change the current  protection for  a page,  with the
            exception  that  only maximally-writable  pages  can have  their  protection  set to
            read/write.

            If a process attempts to store  data into a read-only page, the monitor  will signal
            an illegal memory reference for that page.

            If a  process attempts to  store data  into a copy-on-write  page, the  monitor will
            create a new  private page (maximally-writable  and currently read/write),  copy the
            contents of the referenced  page into it, replace the  old page with the new  one in
            the map, and then restart the store operation.

            All  private  pages are  maximally-writable.   A page  mapped  from a  file  will be
            maximally-writable if and only if (1) the process had done a successful ENTER on the
            file before mapping the page and (2)  the process had at least update access  to the
            file at the time of the ENTER.

















                                                    4-2


            June 27, 1984                            4                                    Paging


            4.3    Creating Private Pages
                   ________ _______ _____

            There are several methods by which a  private page may be added to a  frames address
            space.  The direct  method is to execute  the VCREAT UUO (CALLI -67,  pg. 4-3).  The
            subtler methods  include the CORE  UUO (CALLI +11, pg. 3-1),  as well as  other UUOs
            which call the CORE UUO.

            4.3.1    VCREAT: create private pages (CALLI -67)
                     _______ ______ _______ _____ ______ ____

                    MOVE    ac,[flagB1+protB7+countB17,,page]
                    VCREAT  ac,
                      error return  ;ac/page,,code (see Table 4-20 )
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <prot> is a protection code from Table 4-3 

            If <count> = 0,  or if <prot> is not  legal, take the error return.   Otherwise, for
            each of the <count> pages starting with <page>, perform the following:

                If the page  number is bad (which  could result from a  bad <page> or  a too
                large <count>), or if the page already exists, or if creating the page would
                exceed  the process's  virtual page  limit,  or if  there is  no  disk space
                available to create the page, take the error return.

                Otherwise, create  the page,  making it  maximally-writable and  setting its
                current protection to <prot>, and clear it to zeros.

            Skip-return.


                                                 Table 4-3 
                                                 _____ ___ 
                                           Page Protection Codes
                                           ____ __________ _____


            name     code  protection

            .PRRO    1B7   read-only
            .PRCW    2B7   Copy-on-Write
            .PRRW    3B7   Read-Write



                                                 Table 4-3b
                                                 _____ ____
                                             VCREAT Error Codes
                                             ______ _____ _____


            name     code  error

            CRBCN%   0     <count> = 0
            CRBVP%   1     bad page number
            CRBPR%   2     bad <protection>
            CREXV%   3     page already exists (whose number is stored in <ac> left)
            CRLIM%   5     exceeded existing page limit (.PVCOR)
            CRDFL%   6     disk full











                                                    4-3


            Paging                                   4                          YAMM edition 2.1


            4.4    Unmapping Virtual Pages
                   _________ _______ _____

            The two UUOs VCLEAR and VREMOV remove one or more pages from a process's  map.  When
            the  last remaining  reference to  a particular  private page  is removed  (and only
            then), the page will be deleted; a particular disk page will retain its  contents as
            long as (and only as long as) it is either in some process's map or part of a file.

            To  unmap a  page, a  program executes  one of  VCLEAR UUO  (CALLI -66,  pg. 4-4) or
            VREMOV UUO (CALLI -65, pg. 4-4).

            4.4.1    VCLEAR: unmap pages (CALLI -66)
                     _______ _____ _____ ______ ____
            4.4.1    VREMOV: unmap pages (CALLI -65)
                     _______ _____ _____ ______ ____

                    MOVE    ac, [flagB1+refclearB7+countB17,,page]
                    VCLEAR  ac,
                      or
                    VREMOV  ac,
                      error return  ;ac/page,,code (see Table 4-20 )
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <refclear> = 1B7 to clear the reference bit(s) on the page(s)
                           being unmapped

            If the  specified range of  pages (from  <page> through <page>  + <count>-1)  is not
            within the process's address space, take the error return.

            Otherwise, perform the equivalent  of a VALPAG UUO  for the range of  pages, waiting
            for all the dirty pages to be written to disk.  If the VALPAG signals an error, take
            the  error  return.   (The  important  exception  is  that  VCLEAR  will  ignore the
            nonexistent-page error-return of VALPAG).

            Otherwise, remove the  range of pages from  the process's map, clearing  the current
            protection  and maximally-writable  fields in  each page's  map slots,  clearing the
            reference bits if <refclear> is 1, and removing the pages from the process's working
            set.


            4.5    Replicating Virtual Pages
                   ___________ _______ _____

            The current contents of a range of map entries can be copied (possibly  with changed
            current protection) into some other nonoverlapping range.  This can be used  to make
            the same  page appear in  different places  in a process's  address space,  or, when
            followed by a VREMOV on the old  range, to move some set of pages without  having to
            copy their contents.

            The process executes VREPLC UUO (CALLI -64, pg. 4-4).

            4.5.1    VREPLC: replicate virtual pages (CALLI -64)
                     _______ _________ _______ _____ ______ ____

                    MOVEI   ac, [
                            flagB1+protB7+countB17,,destination
                            source]
                    VREPLC  ac,
                      error return  ;ac/page,,code (see Table 4-20 )
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <prot> is a protection code from Table 4-3

            If the specified range of source pages (from <source> through <source>  + <count>-1)
            or  the   specified  range   of  destination   pages  (from   <destination>  through
            <destination> + <count>-1) are identical,  or if either is not within  the process's

                                                    4-4


            June 27, 1984                            4                                    Paging


            address space, or if <prot> is illegal, take the error return.  Otherwise,  for each
            of the <count> pairs of pages starting with <source> and <destination>,  perform the
            following:

                If  the source  page does  not  exist, or  if the  destination  page already
                exists; or if <prot> is .PRRW and the source page is not maximally-writable,
                take the error return.

                Otherwise, take the page currently mapped  as the source page and map  it as
                the destination  page, then  set the current  protection of  the destination
                page from <prot> and the maximally-writable bit from the source page entry.

            Skip-return.


            4.6    Mapping File Pages
                   _______ ____ _____

            After a  file has  been properly  setup on a  channel using  the calls  described on
            8-1, the process may map pages  of the file into any previously  nonexistent virtual
            page in  its own  frame or  any other  frame to  which it  has .ARCHM  rights.  This
            functions is performed by the .CHMFP UUO (CHANIO fn 35, pg. 4-5).

            4.6.1    .CHMFP: map file pages (CHANIO fn 35)
                     _______ ___ ____ _____ _______ __ ___

                    MOVE    ac, [.CHMFP,,channel]
                    CHANIO  ac, [
                            flagB1+protB7+countB17,,virtual page
                            file page]
                      error return  ; ac/ page,,error code from Table 4-17 
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <prot> is a protection code from Table 4-3


            If  <count> is  illegal, or  if  mapping <count>  pages would  exceed  the process's
            virtual page limit,  or if <prot>  is illegal, or if  <flag>=1 and the  caller lacks
            .ARCHM rights over the "other" frame, or if no file is selected on <channel>, or the
            process has  only lookup access  to the file  selected, or <prot>  is .PRRW  and the
            process does not have at least update access to the file selected; or if <file page>
            is past the end of the file, take the error return.

            Otherwise, for  each of the  <count> pairs  of pages starting  with <file  page> and
            <virtual page>, perform the following:

                If the file page  is nonexistent, or if  the virtual page number  is outside
                the process's  address space or  the virtual page  already exists,  take the
                error return.  Otherwise, map the file page to the virtual page, setting the
                virtual page's  maximally-writable bit  if the process  has at  least update
                access to the file, and setting its current protection to <prot>.

            Skip-return.














                                                    4-5


            Paging                                   4                          YAMM edition 2.1


            4.7    Mapping Absolute Disk Pages
                   _______ ________ ____ _____

            A process having Read Absolute (RA) or Write Absolute (WA) license can map arbitrary
            pages of a disk structure or disk  unit into its address space using the  .CHSMP UUO
            (CHANIO fn 43,  pg. 4-6).   (For more  details  on the  interpretation  of  the disk
            address argument,  refer to  .CHSMP UUO  (CHANIO fn 43, pg. 4-6)  and 8-21.   For an
            explanation  of   "super  mode"   see  8-21.)   Note  that   at  the   present  time
            "copy-on-write"  is not  implemented  in this  "super-mapping".   Super-mapping must
            presently be done either read-only or read-write.

            4.7.1    .CHSMP: super-map file pages (CHANIO fn 43)
                     _______ _________ ____ _____ _______ __ ___

                    MOVE    ac, [.CHSMP,,channel]
                    CHANIO  ac, [
                            protection + countB17 + virtual page
                            disk page]
                      error return  ; ac/ virtual page  ,,error code from Table 4-17 
                    normal return

            where <protection> is a protection code from Table 4-3

            and <error code> is a code from Table 4-20 .

            If  <count> is  illegal, or  if  mapping <count>  pages would  exceed  the process's
            virtual page  limit, or  if <protection>  is illegal, or  if a  file is  selected on
            <channel>, take the error return.

            If the channel is not in "super mode", perform the following:

                If the process has neither read nor write absolute license, or if the device
                initted  was  neither  a  disk   structure  name  nor  a  disk   unit  name,
                error-return.   Otherwise, place  the  channel in  super mode,  and  make it
                available  for  subsequent inputs  if  the process  has  Read  Absolute (RA)
                license or  for inputs and  outputs if the  process has Write  Absolute (WA)
                license.

            For each of the <count> pairs of pages starting with <disk page> and <virtual page>,
            perform the following:

                If "DSK"  or some  disk structure was  initted, interpret  <disk page>  as a
                logical page within the structure (with  the first page being page 0);  if a
                particular unit  was initted, interpret  it as an  absolute page  within the
                unit (also starting at page 0).

                If the  disk page is  past the  end of the  unit if a  unit was  selected or
                structure if  a structure  was selected, or  if the  virtual page  number is
                outside the process's address space  or the virtual page already  exists; or
                if <protection> =  .PRRW and the channel  is not available for  output, take
                the error-return.

                Otherwise, map the disk page to the virtual page, setting the virtual page's
                maximally-writable bit if the  channel is available for output,  and setting
                its current protection to <protection>.

            Skip-return.













                                                    4-6


            June 27, 1984                            4                                    Paging


            4.8    Changing Page Protection
                   ________ ____ __________

            To change the current protection on  a range of pages, a process executes  VPROT UUO
            (CALLI -70, pg. 4-7).

            4.8.1    VPROT: set current protection for pages (CALLI -70)
                     ______ ___ _______ __________ ___ _____ ______ ____

                    MOVE    ac, [flagB1+protB7+countB17,,page]
                    VPROT   ac,
                      error return  ;ac/ vp,,error code
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <prot> is a protection code from Table 4-3

            If <count> = 0, or if <prot> is illegal, take the error return.  Otherwise, for each
            of the <count> pages starting with <page>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, or if .PRRW is  being set
                and the page is not maximally-writable, take the error return.

                Otherwise, set the page's current protection to <prot>.

            Skip-return.


                                                 Table 4-7 
                                                 _____ ___ 
                                             VPROT Error Codes
                                             _____ _____ _____


            name     code  error

            PTBCN%   0     <count> = 0
            PTBVP%   1     bad <page>
            PTBPR%   2     bad <protection>
            PTNVP%   4     page does not exist
            PTPRF%   5     protection failure (only lookup access or <protection> = .PRRW and
                           less than update access



            4.9    Working Set Control
                   _______ ___ _______

            A program may modify its user working set by executing the various functions  of the
            WSCTL  UUO (CALLI -74,  pg. 4-8).   When the  user  is performing  user  working set
            control, the monitor disables monitor working set control.

            4.9.1    WSmax, WSlim, WSsiz
                     ______ ______ _____

            The monitor maintains, for each frame, a "maximum working set size limit" (WSMAX), a
            "current working set size limit"  (WSLIM), and a "current working set  size" (WSSIZ)
            value.

            If a process is not trapping page faults, the monitor will add each page faulted-for
            to its working set, but will throw  a page out before doing so if WSSIZ  has reached
            WSLIM.

            A program can set WSLIM to any value not exceeding WSMAX. The RUN and GET operations
            set WSLIM to equal WSMAX when a core image file is loaded.

            The user can set WSMAX with the command

            SET WSMAX <# of pages>


                                                    4-7


            Paging                                   4                          YAMM edition 2.1


            Doing so sets WSLIM and WSMAX  to the specified number of pages, and  removes enough
            pages from the current program's working set to bring WSSIZ down to the new WSLIM.

            A program can read WSSIZ, WSLIM, or WSMAX by executing the appropriate  functions of
            the WSCTL UUO (CALLI -74, pg. 4-8).

            4.9.2    WSCTL: do working set functions (CALLI -74)
                     ______ __ _______ ___ _________ ______ ____

                    MOVE    ac, [function,,addr]
                    WSCTL   ac,
                      error return
                    normal return

            If <function> is unknown, error-return; otherwise perform the specified function.

            4.9.3    .WSRNG: add/remove pages from working set (WSCTL fn 1)
                     _______ __________ _____ ____ _______ ___ ______ __ __

                    MOVE    ac, [.WSRNG,,[addB7 + countB17 + page]
                    WSCTL   ac,
                      error return  ; AC/ page number,,error code
                    normal return

            If <count> = 0, take the  error return.  Otherwise, for each of the  <count> virtual
            pages starting with <page>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), take the error-return.

                If <add> = 0, remove the page from the working set.

                If <add> = 1, take the error return if the page does not exist, or if adding
                it to the working set would  cause WSLIM to be exceeded; otherwise,  add the
                page to the working set.

            Skip-return.

            4.9.4    .WSRSZ: read WSSIZ (WSCTL fn 3)
                     _______ ____ _____ ______ __ __
            4.9.4    .WSRLM: read WSLIM (WSCTL fn 4)
                     _______ ____ _____ ______ __ __
            4.9.4    .WSRMX: read WSMAX (WSCTL fn 5)
                     _______ ____ _____ ______ __ __

                    MOVE    ac, [.WSRSZ or .WSRLM or .WSRMX ,, addr]
                    WSCTL   ac,
                      error return  ; never taken
                    normal return   ; c(<addr>)/ WSSIZ or WSLIM or WSMAX

            A program can set WSLIM by executing the .WSSTL function:

            4.9.4    .WSSTL: set WSLIM (WSCTL fn 2)
                     _______ ___ _____ ______ __ __

                    MOVE    ac, [.WSSTL,,[new limit]]
                    WSCTL   ac,
                      error return  ; AC/ 0,,error code
                    normal return

            If  <new limit>  is  less than  3  or greater  than  WSMAX, take  the  error return.
            Otherwise, set WSLIM for the process to <new limit> and take the normal return.












                                                    4-8


            June 27, 1984                            4                                    Paging


            4.9.5    .WSRBM: read working set bits (WSCTL fn 0)
                     _______ ____ _______ ___ ____ ______ __ __

                    MOVE    ac, [.WSRBM,,addr]
                    WSCTL   ac,
                      error return  ; AC/ 0,,error code
                    normal return

            where <addr> points to a block of the format
                    word 0    of words after this one
                    word 1  gets bits from first 36 pages
                    word 2  gets bits from 2nd 36 pages
                    ...

            Let <count> be c(<addr>).  If <count> <= 0, just take the normal return.  If <count>
            is greater than ceiling(512/36), take the error return.

            Otherwise, fill  the <count>  words starting with  <addr>+1 with  the in-working-set
            bits of the process's pages, such that


            c(<addr>+1+j bit k) =   1 if page (j*36)+k is in the working set
                                    0 otherwise

            Take the normal return.


                                                 Table 4-9 
                                                 _____ ___ 
                                             WSCTL Error Codes
                                             _____ _____ _____


            name     code  meaning

            WSBCN%   0     count = 0
            WSBVP%   1     bad virtual page
                     2     (unused)
                     3     (unused)
            WSNVP%   4     virtual page does not exist
            WSBFN%   5     illegal function code
            WSCTL%   6     count too large
            WSEWL%   7     exceeded working set size limit
            WSLGM%   10    attempt to set limit over max
            WSLL3%   11    attempt to set limit under 3 pages



            4.10    Prereferencing Pages
                    ______________ _____

            When a page is  added to a process's working  set, the monitor does  not immediately
            make it present  in core.  The  PREREF UUO (CALLI -75,  pg. 4-10) has the  effect of
            referencing a page, but does not block if the page is not present in core; this will
            inform the  monitor (in the  case the page  is not present)  that the  process needs
            attention.  In addition, PREREF returns a bit indicating whether a real reference by
            the program to the page would cause the program to block.















                                                    4-9


            Paging                                   4                          YAMM edition 2.1


            4.10.1    PREREF: prereference a page (CALLI -75)
                      _______ ____________ _ ____ ______ ____

                    MOVE    ac,[flagB1,,page]
                    PREREF  ac,
                      error return  ;ac/page,,code (see Table 4-10 )
                    normal return
            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)

            If <page> is a bad page number, or  if the page does not exist, or if it  exists but
            is not in the process's working set, error-return.

            If  the  page is  already  present  in core,  set  bit 0  of  <ac>  and skip-return.
            Otherwise, initiate a swap-in  of it and any other  pages that are in  the process's
            working set but are not in core, clear bit 0 of <ac>, and skip-return.


                                                Table 4-10 
                                                _____ ____ 
                                             PREREF Error Codes
                                             ______ _____ _____


            name     code  condition

            PRBVP%   1     bad <page>
            PRNVP%   4     <page> does not exist
            PRNIW%   5     <page> not in working set



            4.11    Uninterruptible Page Copy
                    _______________ ____ ____

            A user program may be suspended between any two machine instructions,  in principle,
            and the physical machine might  be assigned to process some other  program entirely.
            Certain  individual instructions  can also  be interrupted:  notably the  BLT (Block
            Transfer) instruction.  This  may be unacceptable to  some processors which  need to
            make several changes to  a data page "in one  operation" so that a database  on disk
            reflects either all of the changes or  none of them.  To meet this need  the monitor
            provides  the BLTPAG  UUO (CALLI -123,  pg. 4-10), which  will  uninterruptibly copy
            data from one page to another.

            4.11.1    BLTPAG: change data in page uninterruptibly (CALLI -123)
                      _______ ______ ____ __ ____ _______________ ______ _____

                    MOVEI   AC,[1st source word,,1st destination word
                               last destination word]
                    BLTPAG  AC,
                     error return   ; AC/ error code
                    normal return
            where <error code> is from Table 4-11 

            If <1st destination> is greater than or equal to <last destination> or if the source
            or destination data cross a page boundary,  or if the pages cannot be locked  for an
            uninterruptible transfer, take the error return.  Otherwise, copy <1st  source word>
            to  <1st  destination  word>  and  so on  until  data  has  been  copied  into <last
            destination word>, then take the normal return.













                                                    4-10


            June 27, 1984                            4                                    Paging


                                                Table 4-11 
                                                _____ ____ 
                                             BLTPAG error codes
                                             ______ _____ _____


            name   number  meaning

            BUCBB% 0       can't BLT backwards (last dest. <= first dest. word)
            BUNWP% 1       data not all within one page
            BUCLP% 2       can't lock dest. page - too many lockers.  This is a temporary
                           condition.



            4.12    Paging Related Errors
                    ______ _______ ______

            There are  three kinds of  error which can  occur when a  program tries to  access a
            page: an "illegal memory reference" will  occur if it tries to access  a nonexistent
            page, or if it tries to write on a page that is write-protected (read-only); a "page
            fault" will occur if it  tries to access a page which  is not in its working  set; a
            "page  error"  will occur  if  it  tries to  access  a page  which  has  suffered an
            irrecoverable i/o error in the process of being transferred to or from disk.

            4.12.1    Illegal Memory Reference
                      _______ ______ _________

            Illegal memory references can be trapped using either the APRENB or INTADR interrupt
            system.  When an  illegal memory reference occurs,  the monitor stores  the hardware
            page fail word  for the page in  .JBPFN of the frame  data area.  The right  half of
            this  word is  the address  causing the  ill mem  ref, so  the left  9 bits  of that
            halfword  are  the  offending  page's  page  number.   The  PAGSTS  UUO  (CALLI -71,
            pg. 4-17) can be used to determine  whether the ill mem ref was caused  by accessing
            a nonexistent page or by writing into a write-protected page.

            4.12.2    Page Errors
                      ____ ______

            When a  page error  occurs, the  monitor will note  the fact  by setting  error bits
            associated with the page.   Page errors occur both when  a page is being  written to
            disk and read into core from disk.

            In neither case does a  process receive an immediate interrupt.  Page  output errors
            are reflected  to a program  when (if) it  tries to validate  the page.   Page input
            errors normally cause the .IAERR  software interrupt when a program tries  to access
            the  page.  The  PERSET UUO  (CALLI -72, pg. 4-11)  may be  executed to  cause these
            errors to be ignored, not causing the interrupt.

            4.12.2.1    PERSET: set/clear error bit (CALLI -72)
                        _______ _________ _____ ___ ______ ____

                    MOVE    ac, [ignore + count,,start]
                    PERSET  ac,
                      error return  ;ac/page,,code (see Table 4-12 )
                    normal return

            where <ignore> = PS.NER (1B7) to ignore errors,
                             or 0B7 to interrupt on errors

            If <count>  = 0, error-return.   Otherwise, for each  of the <count>  pages starting
            with page <start> perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, take the error return.

                Otherwise, set the ignore-errors bit for the page if <ignore> is  PS.NER and
                clear it otherwise.

            Skip-return.

            The  monitor  maintains  two  page-error  status-words  for  each  process:  one for
            page-errors  which could  not  be handled  by the  user  for some  reason  (trap not

                                                    4-11


            Paging                                   4                          YAMM edition 2.1


            enabled, etc.) and thus had to be handled by the monitor, and one for errors handled
            by  the  process.  The  format  of  the two  words  is identical,  and  is  shown in
            Table 4-13 .  To read/clear these words, issue PGESTS UUO (CALLI -100, pg. 4-12).

            4.12.2.2    PGESTS: read/clear page-error status words (CALLI -100)
                        _______ __________ __________ ______ _____ ______ _____

                    MOVE    AC, [-count,,addr]
                    PGESTS  AC,
                      error return
                    normal return

            If <count>  is less than  or equal  to 0, clear  AC and take  the error  return.  If
            <count> is  greater than or  equal to  1, set c(<addr>)  to the  stored user-handled
            error status  word, and set  the stored word  to 0.  If  <count> is greater  than or
            equal to 2, set c(<addr>+1) to the stored monitor-handled error status word, and set
            the stored word  to 0.  If <count>  is greater than 2,  clear AC and take  the error
            return; otherwise, take the normal return.


                                                Table 4-12 
                                                _____ ____ 
                                             PERSET Error Codes
                                             ______ _____ _____


            name     code  condition

            PEBCN%   0     bad <count>
            PEBVP%   1     bad <page>
            PENVP%   4     nonexistent page








































                                                    4-12


            June 27, 1984                            4                                    Paging


                                                Table 4-13 
                                                _____ ____ 
                                           Page-error Status-word
                                           __________ ___________


            name   bit(s)     meaning

            EI.VAL 1B0        information in error status word is valid
            EI.PAR 1B14       parity error on dirty page
            EI.OER 1B15       output error
            EI.DER 1B16       device error
            EI.DTE 1B17       data error
            EI.VPN 777777B35  virtual page number


            4.12.3    Validating Pages
                      __________ _____

            A program  can ensure that  a range  of pages is  written to the  disk by  using the
            VALPAG  UUO (CALLI -76,  pg. 4-13), which  initiates the  writing of  all  the dirty
            pages in that  range to disk,  and optionally waits  until the writes  are complete.
            Note that  the RIB of  a file open  on a channel  can also be  forced out  using the
            .CHVRB UUO (CHANIO fn 42, pg. 8-32).

            4.12.3.1    VALPAG: validate pages (CALLI -76)
                        _______ ________ _____ ______ ____

                    MOVE    ac, [flagB1+waitB7+countB17,,VP]
                    VALPAG  ac,
                      error return  ;ac/page,,code (see Table 4-14 )
                    normal return

            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)
             <wait> = VL.WAT (1B7) to wait for the writes to complete
                      0 to return immediately

            If <count> =  0, take the  error return.  Otherwise, for  each of the  <count> pages
            starting with <VP>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large <count>), or if the page does not exist, take the error return.

                Otherwise, initiate a disk write for the page if it has been  modified since
                it was last swapped-in.

            If <wait> is 0,  skip-return.  Otherwise, wait until  all the dirty pages  have been
            written to the disk; if an i/o error has occurred, take the error  return, otherwise
            skip-return.





















                                                    4-13


            Paging                                   4                          YAMM edition 2.1


                                                Table 4-14 
                                                _____ ____ 
                                             VALPAG Error Codes
                                             ______ _____ _____


            name     code  condition

            VLBCN%   0     bad <count>
            VLBVP%   1     bad page
            VLNVP%   4     page does not exist
            VLIOE%   5     i/o error occurred



            4.13    Page Faults
                    ____ ______

            When  a  page fault  occurs,  say for  page  <page>, the  monitor  will  execute the
            following algorithm:

                If WSSIZ < WSLIM then

                    If an .IAFLL  software interrupt can  be taken, take  it; otherwise,
                    add <page> to the process's working set, and repeat  the interrupted
                    instruction.

                Otherwise (WSSIZ >= WSLIM),

                    If an .IAFEL  software interrupt can  be taken, take  it; otherwise,
                    remove pages from  the process's working set  until WSSIZ is  1 less
                    than  WSLIM, then  add <page>  to the  working set,  and  repeat the
                    interrupted instruction.

                Where "a  <x> interrupt can  be taken" means  that the process  is currently
                running in user mode (the fault did not, for example, happen as  the monitor
                was trying to reference a UUO argument), that the process has enabled (using
                INTASS) the <x> interrupt, and that no higher-priority software interrupt is
                in-progress or pending for that process.

            Note that even if  the program chooses to "see"  no page faults at all  (by choosing
            not to enable for either interrupt condition), it can still have some effect  on its
            paging behavior by  setting WSLIM, which determines  the point at which  page faults
            will cease to cause its working set to expand.

            4.13.1    Page Fault Word
                      ____ _____ ____

            The monitor maintains two page fault words for each process: one for the  last fault
            which trapped to the user, and one for the last fault handled by the monitor.

            The format of a page fault word is described in Table 4-14b.


                                                Table 4-14b
                                                _____ _____
                                              Page Fault Word
                                              ____ _____ ____


            name   bits   meaning

            FI.VAL 1B0    this word contains valid data
            FI.SAL 1B1    WSSIZ >= WSLIM at time of fault
            FI.VPN 777B26 Virtual Page number









                                                    4-14


            June 27, 1984                            4                                    Paging


            4.13.2    PGFSTS: read and clear page fault words (CALLI -101)
                      _______ ____ ___ _____ ____ _____ _____ ______ _____

                    MOVE    AC, [-count,,addr]
                    PGFSTS  AC,
                      error return
                    normal return

            If <count>  is less than  or equal  to 0, clear  AC and take  the error  return.  If
            <count> is  greater than or  equal to  1, set c(<addr>)  to the  stored user-handled
            fault word, and set the stored word to 0.  If <count> is greater than or equal to 2,
            set c(<addr>+1) to the stored monitor-handled fault word, and set the stored word to
            0.  If <count>  is greater than  2, clear AC and  take the error  return; otherwise,
            take the normal return.

            4.13.3    PGRSTS: read/clear REFBIT fault info (CALLI -133)
                      _______ __________ ______ _____ ____ ______ _____
            4.13.3    PGISTS: read/clear ill mem ref fault info (CALLI -132)
                      _______ __________ ___ ___ ___ _____ ____ ______ _____

                    MOVE    ac,[-count,,addr]
                    PGISTS  ac,
                     or
                    PGRSTS  ac,
                     error return   ;ac/0 - <count> bad
                    normal return

            addr:   user info word returned here
                    monitor info word returned here if <count> allows

            If <count> is  less than 1  or greater than 2,  take the error  exit with ac  set to
            zero, the only error code for these UUOs.

            Clear the  saved user infomation  word and  return its old  contents at  <addr>.  If
            count allows, clear the saved  monitor information word, return its old  contents at
            <addr>+1, and take the normal return.


                                                Table 4-15 
                                                _____ ____ 
                                       PGRSTS and PGISTS word formats
                                       ______ ___ ______ ____ _______


            name    bit(s)     meaning

            II.ADR  777777B17  virtual address
            II.PFW  777777B35  soft page fail word

            RI.VAL  1B0        information is valid
            RI.ADR  777777B35  virtual address



            4.14    Page Reference Bits
                    ____ _________ ____

            The monitor associates a reference bit with each map entry.  The bit is set whenever
            a page is referenced by the process and cleared
                1)  When the program does a VREMOV or VCLEAR and specifies that it should be
                    cleared
                2)  When the program does a REFBIT UUO explicitly clearing it
            The monitor will cause a .IAREF software interrupt whenever a process attempts  to a
            access a page with reference bit 0 if the interrupt has been enabled.

            The main purpose of reference bits  is to enable a process managing its  own working
            set to  determine which of  its pages it  has touched over  some period of  time.  A
            program manipulates the reference bits of its pages with the REFBIT  UUO (CALLI -73,
            pg. 4-16).





                                                    4-15


            Paging                                   4                          YAMM edition 2.1


            4.14.1    REFBIT: manipulate reference bits (CALLI -73)
                      _______ __________ _________ ____ ______ ____

                    MOVE    ac, [function,,addr]
                    REFBIT  ac,
                      error return  ; ac/ page,,error code
                    normal return

            where <error code> is from Table 4-16 

            If <function> is illegal, take  the error return.  Perform the  appropriate function
            and take the normal return.

            4.14.2    .RFRBM: Read refbits (Refbit fn 0)
                      _______ ____ _______ _______ __ __
            4.14.2    .RFSBM: Set refbits from bitmap (Refbit fn 1)
                      _______ ___ _______ ____ ______ _______ __ __

                    MOVE    ac,[<.RFRBM or .RFSBM>,,<addr>]
                    REFBIT  ac,
                     error  return  ;ac/ page,,error code
                    normal  return

            where <addr> is the address of a block of the form
                    word 0  <count> of words following this one
                    word 1  ref bits for pp 0-35
                    word 2  ref bits for pp 36-71
                    ...

            If <count> is greater than  (512+35)/36, or if it is  less than or equal to  0, take
            the error return.  Otherwise, for .RFRBM, store <count> words of reference bits into
            locations  starting  at <addr>+1;  for  .RFSBM,  set the  refbit  for  virtual pages
            corresponding to  the bits  in the <count>  words beginning  at <addr>+1.   Take the
            normal return.

            4.14.3    .RFRNG: set refbits by range (Refbit fn 2)
                      _______ ___ _______ __ _____ _______ __ __

                    MOVE    ac,[.RFRNG,,[<bit>B7 + <count>B17 + <page>]]
                    REFBIT  ac,
                      error return
                    normal return

            where
             <bit>   is the new value for the refbits in the given range
             <count> is the number of pages to operate on
             <page>  is the number of the first page to operate on

            If <count> =  0, take the  error return.  Otherwise, for  each of the  <count> pages
            starting with <page>, perform the following:

                If the page number is bad (which could result from either a bad <page>  or a
                too-large  <count>),  take  the error  return.   Otherwise,  set  the page's
                reference bit to <bit>.

            Take the normal return.


                                                Table 4-16 
                                                _____ ____ 
                                             REFBIT Error Codes
                                             ______ _____ _____


            name     code  condition

            RFBCN%   0     bad <count>
            RFBVP%   1     bad page number
            RFBFN%   5     bad <function>





                                                    4-16


            June 27, 1984                            4                                    Paging


            4.15    Virtual Page Information
                    _______ ____ ___________

            4.15.1    Page Status Word
                      ____ ______ ____

            A program can obtain a page status word for any existent virtual page.  The word has
            the format described in Table 4-17 .

            Note that the PS.FIL bit indicates whether  the page was part of a file at  the time
            it was mapped.  If the file page it was mapped from is deleted (e.g., using .CHDFP),
            PS.FIL will  remain on.  The  VFSTAT UUO (CALLI -77,  pg. 4-18), on the  other hand,
            indicates whether a particular  virtual page is currently  part of a file.   To read
            the  status  word  for  a  page,  a  program  executes  the  PAGSTS  UUO (CALLI -71,
            pg. 4-17).

            4.15.1.1    PAGSTS: read page status word (CALLI -71)
                        _______ ____ ____ ______ ____ ______ ____

                    MOVE    AC, [flagB1,,page]
                    PAGSTS  AC,
                      error return  ; AC/Table 4-17b
                    normal return   ; AC/ page status word
            where
             flag = 0  to indicate the calling frame
                    1  to indicate the "other" frame (see 2-13)

            If <page> is  bad, take the error  return.  If <page> does  not exist, clear  AC and
            skip-return.  If <page> exists, set AC to the page's status word and skip-return.


                                                Table 4-17 
                                                _____ ____ 
                                          Page Status Word Format
                                          ____ ______ ____ ______


            name     bits  meaning

            PS.UWS   1B0   in user working set
            PS.REF   1B1   page has been referenced (ref bit)
            PS.MXW   1B2   page can be protected read/write
            PS.SUP   1B3   super-mapped
            PS.DER   1B4   device page I/O error has occurred
            PS.DTE   1B5   data page I/O error has occurred
            PS.DDE   3B5   error mask
            PS.DRT   1B6   not dirty or swap-out in progress
            PS.NEW   1B7   errors for this page are ignored
            PS.OER   1B8   page has an output error (status bits are logical OR of input and
                           output error status)
            PS.PAR   1B9   parity error on dirty page (may also set PS.DER)
            PS.FIL   1B32  originally mapped from a file
            PS.CPR   7B35  current protection (see Table 4-3 )
                           0        page non-existent
                           1        read only
                           2        copy-on-write
                           3        read/write



                                                Table 4-17b
                                                _____ _____
                                             PAGSTS Error Code
                                             ______ _____ ____


            name     code  condition

            PSBVP%   1     bad <page>






                                                    4-17


            Paging                                   4                          YAMM edition 2.1


            4.15.2    Testing for File Membership
                      _______ ___ ____ __________

            A program can find out whether a particular page is currently mapped from a  file or
            whether it is private (note that  being private does not necessarily mean a  page is
            unshared)  by  executing the  VFSTAT  UUO (CALLI -77,  pg. 4-18).   (Note  also that
            VFSTAT tests for  a page's CURRENT  membership in any  file, whereas the  PS.FIL bit
            returned by PAGSTS UUO (CALLI -71,  pg. 4-17) reports its membership AT THE  TIME of
            the VMAP).

            Using the VPGFIL UUO (CALLI -103, pg. 4-18)  a program can find out the name  of the
            file from which any page was mapped, in case this information is not  known already.
            This permits, for example,  a GETSEG'd program to read  the file name from  which it
            was loaded  in order  to pass  this name  on to  another program  which may  want to
            return.

            4.15.2.1    VFSTAT: check private/file page (CALLI -77)
                        _______ _____ ____________ ____ ______ ____

                    MOVE    AC, [page]
                    VFSTAT  AC,
                      error return  ; AC/ error code
                    normal return

            where <error code> is a code from Table 4-20 .

            If <page> is bad,  or if the specified virtual  page does not exist, take  the error
            return.

            Otherwise, set AC to 1 if the page is a file page or 0 if it is a private  page, and
            skip-return.

            4.15.2.2    VPGFIL: get mapped-file name for page (CALLI -103)
                        _______ ___ ___________ ____ ___ ____ ______ _____

                    MOVE    AC,[-count,,block]
                    VPGFIL  AC,
                     error return   ; AC/ error code
                    normal return   ; block has data

            where <error code> is taken from Table 4-19 

            block:  <vp>    ;(argument to uuo; rest of block is return data)
                    <bits>
                    SIXBIT /<structure name>/
                    SIXBIT /<file name>/
                    SIXBIT /<ext>/
                    zero
                    <ppn>
                    zero

            If <count> <= 0, take the normal  return with AC and <block> unchanged.  If  <vp> is
            bad, or <vp> doesn't exist, or <vp> is not a file page, take the error  return.  Set
            <structure>  to  the  structure-name  from  which  <vp>  was  mapped.   If  <vp> was
            super-mapped, let <bits>,<filename>,<ext> and <ppn> be zero.  If the file from which
            <vp> was mapped is now marked for deletion, set <bits> to 400000,,0; else set <bits>
            to zero. Set  <filename>,<ext> and <ppn> to  the name, extension and  directory from
            which <vp> was  mapped.  Begin returning  <bits>, <structure>, <filename>,  etc.  to
            <block> until  <count> runs  out; i.e.,  return as  much of  the information  as the
            caller allows room for.  Take the success return.











                                                    4-18


            June 27, 1984                            4                                    Paging


                                                Table 4-19 
                                                _____ ____ 
                                             VPGFIL Error Codes
                                             ______ _____ _____


            name     code  meaning

            PFBVP%   1     bad vp number
            PFNEX%   4     non-existent vp
            PFNFP%   6     not file page


            4.15.3    Disk Retrieval Pointers
                      ____ _________ ________

            To read the disk retrieval pointer for the disk page mapped to a  particular virtual
            page, a program executes the VDSKPT UUO (CALLI -102, pg. 4-19).

            4.15.3.1    VDSKPT: read disk pointer (CALLI -102)
                        _______ ____ ____ _______ ______ _____

                    MOVE    ac, [page]
                    VDSKPT  ac,
                      error return  ;license missing or invalid page
                    normal return

            Requires RA license.


                                                Table 4-19b
                                                _____ _____
                                             VDSKPT Error Codes
                                             ______ _____ _____


            name     code  meaning

            PFBVP%   1     bad vp number
            VDNVP%   4     vp does not exist
            VDNEL%   5     not enough license

































                                                    4-19


            Paging                                   4                          YAMM edition 2.1


                                                Table 4-20 
                                                _____ ____ 
                                        Standard Paging error Codes
                                        ________ ______ _____ _____


            name     code  condition

            FLCTG%   0     virtual page <count> = 0
                           (.CHMFP, .CHSMP, VREMOV, VCLEAR, VREPLC)
            FLDVR%   1     Destination virtual page out of range
                           A destination page is (or will be) out-of-range (.CHMFP, .CHSMP,
                           VREMOV, VCLEAR, VREPLC, VFSTAT)
            FLCPU%   2     current <prot> undefined
                           <prot> is not a recognized protection code (.CHMFP, .CHSMP, VREPLC)
            FLVEX%   3     virtual page exists
                           A VP which should be nonexistent does exist (.CHMFP, .CHSMP, VREPLC)
            FLNEX%   4     page doesn't exist
                           A VP which should exist does not ( VREMOV, VREPLC, VFSTAR)
            FLSVR%   5     source VP out-of-range
                           A source VP is (or will be) out-of-range ( VREPLC)
            FLPHP%   6     past highest page
                           A specified file page is past the end-of-file (or past the end of the
                           unit or structure on a super-map) (.CHMFP, .CHSMP, .CHDFP, .CHXFP)
            FLFPZ%   7     a specified file page number is <= 0
                           (.CHMFP, .CHSMP(<0 only), VREPLC)
            FLCOR%   10    caller's .PVCOR size limit will be exceeded
                           (.CHMFP, .CHSMP, VREPLC)
            FLRBE%   11    RIB error
                           (.CHMFP, .CHCFP, .CHDFP, .CHXFP)
            FLBDS%   12    bad SAT
                           (.CHMFP, VREPLC, VFSTAT)
            FLCPL%   13    specified <prot> cannot be set for the VP
                           (.CHMFP, .CHSMP, VREPLC)
            FLLKC%   14    file is LOOKUP only, cannot be mapped
                           (.CHMFP)
            FLHOL%   15    file page which must exist is a hole
                           (.CHMFP, .CHDFP)
            FLNHL%   16    no hole at specified file page
                           A page cannot be created at the specified position because one
                           already exists there (.CHCFP)
            FLSNM%   17    structure name bad
                           Super-map attempted when name INIT'ed is not a unit or structure
                           (.CHSMP)
            FLOPE%   20    i/o error on validation write of page
                           (VREMOVE, VCLEAR when page mapped max-write)
            FLSAM%   21    same source and destination page numbers
                           (.CHXFP, VREPLC)
            FLNML%   22    file already selected
                           Super-map attempted with file already selected on the channel
                           (.CHSMP)
            FLNOF%   23    no file selected
                           (.CHMFP, .CHCFP, .CHDFP, .CHXFP, .CHVRB)
            FLNWT%   24    no write allowed
                           No file selected for output,or file selected is append-only (.CHCFP,
                           .CHDFP, .CHXFP)
            FLAQA%   25    disk full or user's quota exceeded
                           (.CHCFP)
            FLCTL%   26    (not returned to user programs)
            FLIPE%   27    (not returned to user programs)
            FLNTF%   30    no page of desired kind found
                           Find first interesting file page CHANIO has found no page of the
                           indicated kind (not currently returned by the CHANIO; may be
                           implemented later) (.CHFFI)
            FLNIM%   31    function not implemented
                           Find First Interesting file page CHANIO subfunction requested is not
                           yet implemented.  (.CHFFI)
            FLLGE%   32    suppress error logging not allowed
                           Caller asked to suppress logging of i/o errors in BAT blocks, but is
                           not privileged to ask this.  (VREMOV,VCLEAR)
                                                    4-20


            June 27, 1984                            4                                    Paging


            FLNSP%   33    (obsolete)
                           Caller asked to truncate file to a position not in the last page.
                           (obsolete; .CHFTR allows truncating to any position) (.CHFTR)
            FLOFF%   34    "other frame" failure
                           Error in accessing page in another frame such as get access rights
                           failure or bad sat.
            FLALF%   35    vp already mappable from a file
                           Caller asked to write a page that was not a private page, i.e. the
                           page was already mapped from a file.  (.CHVMP)
            FLNSP%   36    trying to insert super-mapped vp into file
                           Caller asked to write a page that already exists on disk and is
                           super-mapped into a file.  (.CHVMP)
























































                                                    4-21


            Paging                                   4                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    4-22


            June 27, 1984                            5                               General I/O


                                                 Section 5
                                                 _______ _
                                                General I/O
                                                _______ ___

                                             Table of Contents



            SubSection


            5.1      Channels & I/O Initialization    5-1

            5.2      Device Assignment    5-1
            5.2.1       Device Availability    5-1
            5.2.2       Logical Names    5-2
            5.2.3       Device Names    5-2

            5.3      Channel Numbers    5-2

            5.4      Closing channels    5-2

            5.5      Releasing Channels    5-3

            5.6      File Status Bits    5-3
            5.6.1       Data Modes    5-3
            5.6.2       Reading, Testing and Setting    5-4

            5.7      Device Characteristics    5-4

            5.8      Device Manipulation    5-5
            5.8.1       Reassigning Devices    5-5
            5.8.2       Wait until inactive    5-5
            5.8.3       DEVCHR: read device characteristics word (CALLI +4)    5-6
            5.8.3       GETCHR: read device characteristics word (CALLI +6)    5-6
            5.8.4       DEVNAM: read device physical name (CALLI +64)    5-6
            5.8.5       DEVPPN: read PPN (CALLI +55)    5-6
            5.8.6       DEVSTS: read device hardware status (CALLI +54)    5-6
            5.8.7       REASSI: reassign i/o device (CALLI +21)    5-6
            5.8.8       SYSDVF: read system device data (CALLI -24)    5-7
            5.8.9       WAIT: wait until device inactive (CALLI +10)    5-7
            5.8.9       .CHWT: wait until device inactive (CHANIO fn 25)    5-7

            5.9      Major I/O UUOs    5-8
            5.9.1       CHANIO: do channel i/o functions (op code 043)    5-8
            5.9.2       INIT: Open a Channel (op code 041)    5-10
            5.9.2       OPEN: Open a Channel (op code 050)    5-10
            5.9.2       .CHOPN: Open a Channel (CHANIO fn 13)    5-10
            5.9.3       IN: input from channel (op code 056)    5-11
            5.9.3       .CHIN: input from channel (CHANIO fn 14)    5-11
            5.9.3       INPUT: input from channel (op code 066)    5-11
            5.9.3       .CHIPT: input from channel (CHANIO fn 3)    5-11
            5.9.3       OUT: output from channel (op code 057)    5-11
            5.9.3       .CHOUT: output from channel (CHANIO fn 15)    5-11
            5.9.3       OUTPUT: output from channel (op code 067)    5-11
            5.9.3       .CHOPT: output from channel (CHANIO fn 2)    5-11
            5.9.4       RESET: initialize frame state (CALLI +0)    5-11
            5.9.5       CLOSE: close a file (op code 070)    5-12
            5.9.5       .CHCLS: close a file (CHANIO fn 1)    5-12
            5.9.6       RELEAS: release device (op code 071)    5-12
            5.9.6       .CHREL: release device (CHANIO fn 0)    5-12
            5.9.7       GETSTS: read file status bits (op code 062)    5-13
            5.9.7       .CHGS: read file status bits (CHANIO fn 17)    5-13
            5.9.8       SETSTS: set file status bits (op code 060)    5-13
            5.9.8       .CHSS: set file status bits (CHANIO fn 16)    5-13
            5.9.9       STATO: skip if file status bits set (op code 061)    5-13
            5.9.9       .CHSO: skip if file status bits set (CHANIO fn 21)    5-13
            5.9.9       STATZ: skip if file status bits clear (op code 063)    5-13
            5.9.9       .CHSZ: skip if file status bits clear (CHANIO fn 20)    5-13
                                                    5-i


            General I/O                              5                          YAMM edition 2.1

            SubSection
            5.9.10      .CHNXT: return next channel (CHANIO fn 42)    5-14


            Table

            5-3      File Status Bits    5-3
            5-4      Data Modes    5-4
            5-5      Device Characteristics Word    5-5
            5-8      SYSDVF Function Codes    5-8
            5-9      CHANIOs by function    5-9
            5-10     CHANIOs by number    5-10

























































                                                    5-ii


            June 27, 1984                            5                               General I/O





                                                 Section 5
                                                 _______ _
                                                General I/O
                                                _______ ___





            5.1    Channels & I/O Initialization
                   ________ _ ___ ______________

            Each process has  48 software i/o channels.   The INIT UUO  (op code 041, pg. 5-10),
            OPEN  UUO  (op code 050, pg. 5-10),  and  the .CHOPN  UUO  (CHANIO fn 13, pg. 5-10),
            take a  channel number  and a  device name: they  assign the  device to  the calling
            process, and associate it with the specified channel.  The device (and  the channel)
            are said to be "initted" when this has been done.

            For each device, the monitor maintains  a "device data block" (or DDB),  which holds
            data identifying the device and describing its current status.  Each initted channel
            in a process points to some device  data block.  Since the disk is a  shared device,
            the monitor  creates a copy  of a master  disk DDB for  each channel that  inits the
            disk.  If more than  one channel inits the  same non-disk device, the  channels will
            share the same DDB.


            5.2    Device Assignment
                   ______ __________

            A device  must be  "assigned" to  a process  in order  for that  process to  use it.
            Devices other than the disk may not be assigned to more than one process at a time.

            When a program inits a device,  the device is "assigned by program" to  the process;
            it remains assigned until the program releases it (or until it or the monitor does a
            RESET, which will release all assigned-by-program devices).

            When a user types the ASSIGN command

                    ASSIGN <device name>

            the device is "assigned by console" to the frame; it remains assigned until the user
            types

                    DEASSIGN <device name>

            or logs out.

            A  process which  has Transfer  Device (TD)  license can  take any  device currently
            "assigned by program" to it, and reassign that device "by console" either  to itself
            or  to  some  other  frame,  using  the  REASSI  UUO  (CALLI +21,  pg. 5-6),  or the
            REASSIGN command.

            5.2.1    Device Availability
                     ______ ____________

            All devices are assigned to some frame.  Devices which are completely unavailable to
            the system are  "assigned by program"  to frame 0.   Devices which are  available to
            users are "assigned by console" to frame 0.

            If a process has  Get Device (GD) license, it  can init a device which  is available
            (i.e., which is "assigned by program" to frame 0).

            If a  frame has  Get Device (GD)  license, the  user can use  the ASSIGN  command to
            assign a device which is available.

            The device DSK  can always be  assigned, without Get Device  (GD) license, as  can a
            frame's command port or  any port assigned to the  frame in creating an  aux circuit
            (see 10-25).


                                                    5-1


            General I/O                              5                          YAMM edition 2.1


            5.2.2    Logical Names
                     _______ _____

            The ASSIGN command can take an optional second argument specifying a  "logical name"
            for the device being assigned:

                    ASSIGN <device physical name> <device logical name>

            Subsequent  inits on  <logical name>  will be  redirected to  the  specified <device
            physical name>.  For example,

                    ASSIGN LPT PTP

            will cause subsequent paper-tape-punch-directed output to go to the line printer.

            In many  UUOs which  take device names,  the program  can specify  a "physical-only"
            search, in which case logical name assignments are ignored.

            5.2.3    Device Names
                     ______ _____

            When processing  a UUO  which specifies  a device  name, the  monitor must  find the
            appropriate DDB.  The algorithm is:

            If the UUO does not specify a physical-only search, look for a device  whose logical
            name matches the argument: use its DDB.

            If that fails, check  whether the argument is the  generic name for disk,  "DSK", or
            "DS" or "D";  or whether it is  a disk structure name  ("DSKB"); or whether it  is a
            disk unit name: if it is, use a copy of the master disk DDB.

            If that fails, look for a  device whose physical name matches the argument:  use its
            DDB.

            If that fails,  and the argument  is "TTY", use  the current frame's  command port's
            DDB.


            5.3    Channel Numbers
                   _______ _______

            The monitor originally passed  channel numbers using the  ac field of the  i/o UUOs,
            limiting  the  maximum number  of  channels  to 16.   The  CHANIO  UUO (op code 043,
            pg. 5-8) was added to allow the number of channels to be increased.


            5.4    Closing channels
                   _______ ________

            Most devices have some notion of a "file".  Several files may be read or  written on
            a device before that device  is released; the .CHCLS UUO (CHANIO fn 1,  pg. 5-12) or
            CLOSE UUO (op code 070,  pg. 5-12) can be  used by a  program to inform  the monitor
            that it intends to finish the processing of the current file.

            The exact operation of CLOSE depends on the data mode the device was initted  in and
            on the device initted.
















                                                    5-2


            June 27, 1984                            5                               General I/O


            5.5    Releasing Channels
                   _________ ________

            When  a  process  is  finished  with a  channel,  it  should  execute  a  .CHREL UUO
            (CHANIO fn 0, pg. 5-12)  or RELEAS UUO  (op code 071, pg. 5-12) to  disassociate the
            device  with the  channel.   The RESET  UUO  (CALLI +0, pg. 5-11)  will  release all
            channels automatically.


            5.6    File Status Bits
                   ____ ______ ____

            The monitor maintains a  file status word for each  device.  The right half  of that
            word can be manipulated by user  programs, and its bits are called the  "file status
            bits".   Some  file  status  bits are  device-dependent:  those  which  are  not are
            described in table Table 5-3 .

            5.6.1    Data Modes
                     ____ _____

            There are eight standard data modes that can be specified for a device. The behavior
            of the modes differs from device to device, but the general arrangement is  shown in
            table Table 5-4 .


                                                 Table 5-3 
                                                 _____ ___ 
                                              File Status Bits
                                              ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode - some operation was performed or some data read which
                           is inappropriate for the current data mode
            IO.DER   1B19  device error detected by device
            IO.DTE   1B20  data error detected by monitor
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.EVP   1B26  (FTA: only) even parity (Table 11-5b)
            IO.BK2   1B26  (TTY: only) break-on-punctuation bit (Table 10-33 )
            IO.NEE   1B27  (TTY: only) no-escape-echo bit (Table 10-33 )
            IO.NEC   1B28  (TTY: only) no-echo bit (Table 10-33 )
            IO.DEN   3B28  (FTA: only) recording density (Table 11-5b)
            IO.FCS   1B29  (TTY: only) full-character-set bit (Table 10-33 )
            IO.SYN   1B30  synchronous i/o - in buffered mode i/o, the device will stop after
                           processing each buffer; usually used with random i/o
            IO.UWC   1B31  user supplied word count - in buffered mode i/o, a user supplied word
                           count will be used in place of the one computed by the monitor
            IO.MOD   17B35 data mode mask (see Table 5-4 )





















                                                    5-3


            General I/O                              5                          YAMM edition 2.1


                                                 Table 5-4 
                                                 _____ ___ 
                                                 Data Modes
                                                 ____ _____


            name     code  description

            .IOASC   0     ASCII : a device-independent mode for buffered i/o of ordinary ASCII
                           text.  The byte size is 7 bits, and the characters are translated
                           where necessary (e.g., from card codes) by the monitor.
            .IOASL   1     ASCII line : identical to ASCII mode (retained only for
                           compatibility).
            .IOKAT   2     Katakana : a device-independent mode for buffered i/o of JIS-8
                           (Katakana) text.  The byte size is 9 bits (of which the high-order
                           bit should always be 0).
            .IOIMG   10    Image : a device-dependent mode for transfer of data without monitor
                           processing directly to and from the device.
            .IOIBN   13    Image Binary : a device-independent mode for the buffered transfer of
                           36-bit words without checksumming.
            .IOBIN   14    Binary : a device-independent mode for the buffered transfer of
                           records of 36-bit words with checksumming.
            .IODPR   16    Dump Records : a device-dependent mode for unbuffered blocked data
                           transfers.
            .IODMP   17    Dump : a device-dependent mode for unblocked unbuffered data
                           transfers.


            5.6.2    Reading, Testing and Setting
                     ________ _______ ___ _______

            To  read the  file status  bits  for a  channel, a  program executes  the  .CHGS UUO
            (CHANIO fn 17, pg. 5-13) or GETSTS UUO (op code 062, pg. 5-13).

            A program may  test the file status  bits for a channel  by executing the  .CHSO UUO
            (CHANIO fn 21,  pg. 5-13) or  STATO  UUO (op code 061,  pg. 5-13) to  test  for bits
            which are set, or the .CHSZ UUO (CHANIO fn 20, pg. 5-13) or STATZ  UUO (op code 063,
            pg. 5-13) to test for bits which are clear.

            Finally, a program may set the file status bits for a channel by executing the .CHSS
            UUO (CHANIO fn 16, pg. 5-13) or SETSTS UUO (op code 060, pg. 5-13).


            5.7    Device Characteristics
                   ______ _______________

            Since a  program may be  getting a logical  device when it  performs an OPEN  UUO, a
            means has been provided for the program  to determine the type of device that  it is
            working  with.   The program  may  execute  the DEVCHR  UUO  (CALLI +4,  pg. 5-6) or
            GETCHR  UUO  (CALLI +6,  pg. 5-6)  to obtain  a  word  describing  the  device.  The
            format of this word is given in Table 5-5 .





















                                                    5-4


            June 27, 1984                            5                               General I/O


                                                 Table 5-5 
                                                 _____ ___ 
                                        Device Characteristics Word
                                        ______ _______________ ____


            name     bit   meaning

            DV.DSK   1B1   is a disk
            DV.CDR   1B2   is a card reader
            DV.LPT   1B3   is a line printer
            DV.TTA   1B4   is a frame's command port (DV.TTY will also be set)
            DV.NZP   1B5   do not zap circuit on a RESET (DV.TTY will also be set)
            DV.1UU   1B6   unused
            DV.2UU   1B7   unused
            DV.3UU   1B8   unused
            DV.PTP   1B9   is a paper tape punch
            DV.PTR   1B10  is a paper tape reader
            DV.4UU   1B11  unused
            DV.AVL   1B12  is available to this frame
            DV.MTA   1B13  is a magtape
            DV.TTY   1B14  is a terminal or aux circuit
            DV.DIR   1B15  has a directory (DV.DSK will also be set)
            DV.IN    1B16  input possible
            DV.OUT   1B17  output possible
            DV.ASG   1B18  assigned by console
            DV.ASP   1B19  assigned by program
            DV.DMP   1B20  dump mode legal
            DV.DPR   1B21  dump records mode legal
            DV.BIN   1B23  binary mode legal
            DV.IBN   1B24  image binary mode legal
            DV.IMG   1B27  image mode legal
            DV.KAT   1B33  katakana mode legal
            DV.ASL   1B34  ASCII line mode legal
            DV.ASC   1B35  ASCII mode legal



            5.8    Device Manipulation
                   ______ ____________

            There is a family of UUOs which take either a channel number or a device name for an
            argument  and return  information  about the  device.   In what  follows,  a "device
            descriptor" is either a channel number or the SIXBIT name of some device.   A device
            descriptor is "invalid" if (1) it  is a channel number and the channel  it specifies
            is not initted or (2) it is a device name and the device cannot be found.

            5.8.1    Reassigning Devices
                     ___________ _______

            A process which has a device assigned "by program" to it can assign that  device "by
            console" to  itself (or any  other process  having the same  AUN or,  given Transfer
            Device  (TD)  license,  any  other  process at  all)  by  executing  the  REASSI UUO
            (CALLI +21, pg. 5-6).

            5.8.2    Wait until inactive
                     ____ _____ ________

            In order to wait for a device to stop transfering data, that is, become  inactive, a
            program may execute  the .CHWT UUO (CHANIO fn 25,  pg. 5-7) or WAIT  UUO (CALLI +10,
            pg. 5-7).   Several UUOs  automatically  wait for  their  device or  all  devices to
            become inactive.











                                                    5-5


            General I/O                              5                          YAMM edition 2.1


            5.8.3    DEVCHR: read device characteristics word (CALLI +4)
                     _______ ____ ______ _______________ ____ ______ ___
            5.8.3    GETCHR: read device characteristics word (CALLI +6)
                     _______ ____ ______ _______________ ____ ______ ___

                    MOVE    ac, device descriptor
                    DEVCHR  ac,     ; or GETCHR ac,
                    only return

            (The GETCHR and DEVCHR UUOs are identical).

            If the <device descriptor> is invalid, set <ac> to 0 and return; otherwise, set <ac>
            to the device's device characteristics word, and return.

            5.8.4    DEVNAM: read device physical name (CALLI +64)
                     _______ ____ ______ ________ ____ ______ ____

                    MOVE    ac, device descriptor
                    DEVNAM  ac,
                      error return
                    normal return

            If  the  <device descriptor>  is  invalid, clear  <ac>  and take  the  error return.
            otherwise, set <ac> to the SIXBIT physical device name and take the normal return.

            5.8.5    DEVPPN: read PPN (CALLI +55)
                     _______ ____ ___ ______ ____

                    MOVE    ac, device descriptor
                    DEVPPN  ac,
                      error return
                    normal return

            If the <device descriptor> is invalid, clear <ac> and take the error return.

            Otherwise, set <ac> to SYS's PPN if the device is SYS and to the current frame's PPN
            if it is not, and take the normal return.

            5.8.6    DEVSTS: read device hardware status (CALLI +54)
                     _______ ____ ______ ________ ______ ______ ____

                    MOVE    ac, device descriptor
                    DEVSTS  ac,
                      JFCL
                    only return

            If the <device  descriptor> is invalid, clear  <ac> and skip-return;  otherwise, set
            <ac> to the device's hardware status word and skip-return.  The meaning of  the word
            returned is entirely device-dependent.

            5.8.7    REASSI: reassign i/o device (CALLI +21)
                     _______ ________ ___ ______ ______ ____

                    MOVE    ac, [frame]
                    MOVE    ac+1, device descriptor
                    REASSI  ac,
                    only return

            If <frame> does not exist, clear <ac> and return.

            If the <device descriptor> is invalid, or the device is a port, or the device is not
            assigned  to  the  current process;  or  if  <frame> and  the  current  process have
            different AUNs and the current  process does not have Transfer Device  (TD) license,
            clear <ac+1> and return.

            If <frame> is the current process, assign the device "by console" to the process and
            return.

            If <frame>  is a  different process,  do a RELEAS  on every  channel of  the current
            process which has the device initted, set the device's logical name to  its physical
            name (that is, nullify any previous logical name assignment), assign the  device "by
            console" to <frame>, and return.


                                                    5-6


            June 27, 1984                            5                               General I/O


            5.8.8    SYSDVF: read system device data (CALLI -24)
                     _______ ____ ______ ______ ____ ______ ____

                    MOVE    ac, [length,,addr]
                    SYSDVF  ac,
                      error return
                    normal return

            where <addr> points to a block of the form
                    word 0  function
                    word 1  start
                    word 2  set to word count for data block
                    word 3  set to word 0 of data block
                    ...

            If <function> is invalid, take the error return.

            If <start> is nonzero,  search the appropriate chain  of monitor data blocks  for an
            entry matching <start>, and take the error-return if none is found.

            The SYSDVF functions are shown in Table 5-8 .  Start with the first entry  after the
            one selected by <start>, or with the first entry in the chain if <start> was  0.  If
            there  is no  such entry,  set  c(<addr>+1) to  0 and  skip-return.   Otherwise, set
            c(<addr>+1) to  the name (.SDDDN,  .SDUDB, .SDSDD, .SDFTA)  or the  absolute address
            (.SDDDA) of the entry found and proceed as follows:

            For .SDDDN and .SDDDA:

                Store as  much of  the device data  block as  will fit (up  to <length>  - 2
                words) into locations starting with <addr>+3, set c(<addr>+2) to  the number
                of words stored, and skip-return.

            For .SDUDB, .SDSDD, and .SDFTA:

                If  the  process  does  not  have  Systat  (SY)  license,  just skip-return.
                Otherwise, store as much of the disk unit data block (.SDUDB), structure DDB
                (.SDSDD), or magtape unit data block (.SDFTA) as will fit (up to  <length> -
                2  words) into  locations  starting with  <addr>+3, set  c(<addr>+2)  to the
                number of words stored, and skip-return.

            5.8.9    WAIT: wait until device inactive (CALLI +10)
                     _____ ____ _____ ______ ________ ______ ____
            5.8.9    .CHWT: wait until device inactive (CHANIO fn 25)
                     ______ ____ _____ ______ ________ _______ __ ___

                    WAIT    channel,
                    only return

                    MOVE    ac, [.CHWT,,channel]
                    CHANIO  ac,
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Otherwise, wait for the device initted to become inactive, then return.















                                                    5-7


            General I/O                              5                          YAMM edition 2.1


                                                 Table 5-8 
                                                 _____ ___ 
                                           SYSDVF Function Codes
                                           ______ ________ _____


            name     code  description

            .SDDDN   0     Non-port/disk; the device data blocks for all those non-disk,
                           non-port devices belonging to the current process (or to all
                           processes with the current process's GAN if the current process has
                           account supervisor privilege, or to any process if the current
                           process has Systat (SY) license)
            .SDDDA   1     All; the same list as for .SDDDN except that ports and disks are not
                           excluded
            .SDUNI   2     Unit DDBs; the chain of unit data blocks for all the disk units in
                           the system (the current process must have Systat (SY) license)
            .SDSTR   3     STR DDBs; the chain of structure device data block (the current
                           process must have Systat (SY) license)
            .SDFTA   4     Mag Tape DDBs; the chain of unit data blocks for all the magnetic
                           tape units in the system



            5.9    Major I/O UUOs
                   _____ ___ ____

            5.9.1    CHANIO: do channel i/o functions (op code 043)
                     _______ __ _______ ___ _________ ___ ____ ____

                    MOVE    ac, [function,,channel]
                    CHANIO  ac, addr

            where
             <channel> is the software channel number on which the function is to
                       be performed.  Currently, this may be in the range [0,47.].

             <function> is the function code for the operation to be performed
                        on <channel>.  See Table 5-9  and Table 5-10  for
                        a description of the CHANIO functions.

            The older i/o UUOs all have CHANIO equivalents, and the new functions  are available
            only through CHANIO.





























                                                    5-8


            June 27, 1984                            5                               General I/O


                                                 Table 5-9 
                                                 _____ ___ 
                                            CHANIOs by function
                                            _______ __ ________


            Function  Name     Description

            Channel functions

              fn 0    .CHREL   release device (5-12)
              fn 1    .CHCLS   close a file (5-12)
              fn 13   .CHOPN   open a channel (5-10)
              fn 16   .CHSS    set file status bits (5-13)
              fn 17   .CHGS    read file status bits (5-13)
              fn 20   .CHSZ    skip if file status bits clear (5-13)
              fn 21   .CHSO    skip if file status bits set (5-13)
              fn 46   .CHNXT   get next available channel (5-14)


            Disk file functions

              fn 4    .CHLK    select file for input (8-17)
              fn 5    .CHENT   select file for output (8-16)
              fn 6    .CHUSI   set file pointer by block (8-21)
              fn 7    .CHUSO   set file position by block (8-22)
              fn 10   .CHUGF   read disk file position (8-32)
              fn 11   .CHREN   rename or delete a file (8-17)
              fn 27   .CHFSI   set file pointer by block (8-21)
              fn 30   .CHFSO   set file position by block (8-22)
              fn 31   .CHPSI   set file pointer by page (8-21)
              fn 32   .CHPSO   set file position by page (8-22)
              fn 41   .CHMEN   select file for multi-update output (8-16)
              fn 45   .CHFTR   truncate file (8-25)


            I/O functions

              fn 2    .CHOPT   output from channel (5-11)
              fn 3    .CHIPT   input from channel (5-11)
              fn 14   .CHIN    input from channel (5-11)
              fn 15   .CHOUT   output from channel (5-11)


            Page manipulation functions

              fn 35   .CHMFP   map file pages (4-5)
              fn 36   .CHDFP   delete file page (8-24)
              fn 37   .CHXFP   exchange file pages (8-24)
              fn 40   .CHCFP   create file page (8-24)
              fn 43   .CHSMP   super-map file pages (4-6)
              fn 44   .CHFFI   find first interesting page (8-26)
              fn 47   .CHVMP   move virtual page to a file (8-25)


            Buffer manipulation functions

              fn 22   .CHIBF   create input buffer ring (6-3)
              fn 23   .CHOBF   create output buffer ring (6-3)
              fn 26   .CHMBF   move buffers (6-4)


            Miscellaneous functions

              fn 12   .CHMTA   perform magtape functions (11-3)
              fn 24   .CHSK    seek to current page (8-23)
              fn 25   .CHWT    wait until device inactive (5-7)
              fn 33   .CHUFD   read UFD (8-3)
              fn 34   .CHMGN   manipulate update-interlock bit (8-26)
              fn 42   .CHVRB   validate RIB (8-32)
                                                    5-9


            General I/O                              5                          YAMM edition 2.1


                                                Table 5-10 
                                                _____ ____ 
                                             CHANIOs by number
                                             _______ __ ______


            Function  Name     Description

              fn 0    .CHREL   release device (5-12)
              fn 1    .CHCLS   close a file (5-12)
              fn 2    .CHOPT   output from channel (5-11)
              fn 3    .CHIPT   input from channel (5-11)
              fn 4    .CHLK    select file for input (8-17)
              fn 5    .CHENT   select file for output (8-16)
              fn 6    .CHUSI   set file pointer by block (8-21)
              fn 7    .CHUSO   set file position by block (8-22)
              fn 10   .CHUGF   read disk file position (8-32)
              fn 11   .CHREN   rename or delete a file (8-17)
              fn 12   .CHMTA   perform magtape functions (11-3)
              fn 13   .CHOPN   open a channel (5-10)
              fn 14   .CHIN    input from channel (5-11)
              fn 15   .CHOUT   output from channel (5-11)
              fn 16   .CHSS    set file status bits (5-13)
              fn 17   .CHGS    read file status bits (5-13)
              fn 20   .CHSZ    skip if file status bits clear (5-13)
              fn 21   .CHSO    skip if file status bits set (5-13)
              fn 22   .CHIBF   create input buffer ring (6-3)
              fn 23   .CHOBF   create output buffer ring (6-3)
              fn 24   .CHSK    seek to current page (8-23)
              fn 25   .CHWT    wait until device inactive (5-7)
              fn 26   .CHMBF   move buffers (6-4)
              fn 27   .CHFSI   set file pointer by block (8-21)
              fn 30   .CHFSO   set file position by block (8-22)
              fn 31   .CHPSI   set file pointer by page (8-21)
              fn 32   .CHPSO   set file position by page (8-22)
              fn 33   .CHUFD   read UFD (8-3)
              fn 34   .CHMGN   manipulate update-interlock bit (8-26)
              fn 35   .CHMFP   map file pages (4-5)
              fn 36   .CHDFP   delete file page (8-24)
              fn 37   .CHXFP   exchange file pages (8-24)
              fn 40   .CHCFP   create file page (8-24)
              fn 41   .CHMEN   select file for multi-update output (8-16)
              fn 42   .CHVRB   validate RIB (8-32)
              fn 43   .CHSMP   super-map file pages (4-6)
              fn 44   .CHFFI   find first interesting page (8-26)
              fn 45   .CHFTR   truncate file (8-25)
              fn 46   .CHNXT   get next available channel (5-14)
              fn 47   .CHVMP   move virtual page to a file (8-25)


            5.9.2    INIT: Open a Channel (op code 041)
                     _____ ____ _ _______ ___ ____ ____
            5.9.2    OPEN: Open a Channel (op code 050)
                     _____ ____ _ _______ ___ ____ ____
            5.9.2    .CHOPN: Open a Channel (CHANIO fn 13)
                     _______ ____ _ _______ _______ __ ___

                    OPEN    channel, [
                            bits,,status
                            SIXBIT /device name/
                            outring,,inring]
                      error return
                    normal return

                    INIT    channel, status
                    SIXBIT  /device name/
                    outring,,inring
                      error return
                    normal return




                                                    5-10


            June 27, 1984                            5                               General I/O


                    MOVE    ac, [.CHOPN,,channel]
                    CHANIO  ac, [
                            bits,,status
                            SIXBIT /device name/
                            outring,,inring]
                      error return
                    normal return

            where
             <inring> and <outring> are the addresses of headers for
                    buffered-mode input and output, and can be 0 if no
                    buffered-mode i/o is to be done

             <bits> is '400000 to specify a physical-only search

             <channel> is a channel number, which must be between 0 and '17
                    for OPEN and INIT, and between -1 and 48 for .CHOPN

             <status> is the initial value for the device's file status bits

            In the case of .CHOPN, if <channel> is -1, find the lowest-numbered channel  that is
            not initted and use it, taking the error-return if all channels are in use.

            If <channel> is already initted, perform a RELEAS for it.  Search for <device name>:
            if it is  not found, take  the error-return.  Check the  data mode field  (the right
            four bits)  of <status>: if  they are not  legal for the  device, abort the  UUO and
            store halt  status HT.IDM  for the  frame.  Assign  the device  "by program"  to the
            current process: error-return if it is not possible.

            Wait for the device to become inactive, then set the file status bits from <status>.
            If <outring> is  nonzero, initialize the output  buffer ring header; if  <inring> is
            nonzero, initialize the input buffer ring header.

            5.9.3    IN: input from channel (op code 056)
                     ___ _____ ____ _______ ___ ____ ____
            5.9.3    .CHIN: input from channel (CHANIO fn 14)
                     ______ _____ ____ _______ _______ __ ___
            5.9.3    INPUT: input from channel (op code 066)
                     ______ _____ ____ _______ ___ ____ ____
            5.9.3    .CHIPT: input from channel (CHANIO fn 3)
                     _______ _____ ____ _______ _______ __ __
            5.9.3    OUT: output from channel (op code 057)
                     ____ ______ ____ _______ ___ ____ ____
            5.9.3    .CHOUT: output from channel (CHANIO fn 15)
                     _______ ______ ____ _______ _______ __ ___
            5.9.3    OUTPUT: output from channel (op code 067)
                     _______ ______ ____ _______ ___ ____ ____
            5.9.3    .CHOPT: output from channel (CHANIO fn 2)
                     _______ ______ ____ _______ _______ __ __

            The action of these UUOs depends upon  the data mode of the channel at the  time the
            UUO is issued.  For a discussion of  their use in Buffered modes, see 6-4.   For use
            in dump modes, see 7-1.

            5.9.4    RESET: initialize frame state (CALLI +0)
                     ______ __________ _____ _____ ______ ___

                    RESET
                    only return

            Make page 0 be  private and writable if it  is not already.  Perform  the operations
            described in 10-4  for ports. For  initted channels, do  the equivalent of  a RELEAS
            UUO (op code 071,  pg. 5-12), except  do not  do a CLOSE,  and do  not wait  for the
            device to become inactive.

            Clear any charging  information saved by XCHARG.   Set the frame's working  set size
            limit to its  maximum working set  size limit.  Do the  equivalent of an  APRENB UUO
            with no conditions enabled.

            Return to the user, clearing the left half of the PC with the exception of  the USER
            and PUBLIC bits.






                                                    5-11


            General I/O                              5                          YAMM edition 2.1


            5.9.5    CLOSE: close a file (op code 070)
                     ______ _____ _ ____ ___ ____ ____
            5.9.5    .CHCLS: close a file (CHANIO fn 1)
                     _______ _____ _ ____ _______ __ __

                    CLOSE   channel, bits
                    only return

                    MOVE    ac, [.CHCLS,,channel]
                    CHANIO  ac, bits
                    only return

            where <bits> = CL.OUT  ('1) to inhibit closing output
                         + CL.IN   ('2) to inhibit closing input
                         + CL.ACS ('10) to inhibit access date update
                         + CL.RST ('40) to inhibit supersede/create

            If <channel> is not initted, just  return; otherwise, wait for the device  to become
            inactive and proceed.

            If  CL.IN  is  not  set,  close   the  input  side  of  the  channel:   perform  the
            device-dependent  close  routine  if  one exists  (unless  this  is  a buffered-mode
            non-disk file on which no input was actually done); then (unless this is a dump mode
            file) clear the use bits for each buffer  in the input ring, set the use bit  in the
            input buffer ring header, and set the input buffer ring header's count field to 0.

            Clear IO.EOF in the file status bits.

            If  CL.OUT  is not  set,  close the  output  side of  the  channel: if  the  file is
            buffered-mode and some output has been  done, write out all the output  buffers, set
            the  use bit  in the  output  buffer ring  header, and  set the  output  buffer ring
            header's count field to 0.  Perform the device-dependent close routine if one exists
            (unless this is a buffered-mode non-disk file on which no output was actually done).

            Check the error bits (bits 18-22) of the file status bits: if any are set, or if the
            device is a  magtape and the  end-of-tape flag is  set, cause an  i/o-error software
            interrupt if the process is enabled for one.

            Return.

            (The CL.ACS and CL.RST bits have meaning only for disk i/o: see 8-19).

            5.9.6    RELEAS: release device (op code 071)
                     _______ _______ ______ ___ ____ ____
            5.9.6    .CHREL: release device (CHANIO fn 0)
                     _______ _______ ______ _______ __ __

                    RELEAS  channel,
                    only return

                    MOVE    ac, [.CHREL,,channel]
                    RELEAS  ac,
                    only return

            If <channel> is not initted, just return.

            Perform the equivalent of a CLOSE UUO (with 0 address) on the channel.  Wait for the
            device to become inactive, then perform the device-dependent release routine, if one
            exists.

            Break  the  association  between the  device  and  <channel>.  If  it  is  not still
            associated with the process (initted on some other channel or assigned  by console),
            assign it to frame 0 by console (making  it available) if it is not a disk  or port,
            zap it if it is a port.

            Return.






                                                    5-12


            June 27, 1984                            5                               General I/O


            5.9.7    GETSTS: read file status bits (op code 062)
                     _______ ____ ____ ______ ____ ___ ____ ____
            5.9.7    .CHGS: read file status bits (CHANIO fn 17)
                     ______ ____ ____ ______ ____ _______ __ ___

                    GETSTS  channel, addr
                    only return

                    MOVE    ac, [.CHGS,,channel]
                    CHANIO  ac, addr
                    only return


            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  Get the file status bits for <channel>'s device.  If the device is a disk or
            magtape  and  either  (1)  input  is  in  progress  or  (2)  the  monitor  has  done
            buffered-mode input ahead of the user, clear the error bits (bits 18 through 22).

            Set <addr> right to the bits and return.

            5.9.8    SETSTS: set file status bits (op code 060)
                     _______ ___ ____ ______ ____ ___ ____ ____
            5.9.8    .CHSS: set file status bits (CHANIO fn 16)
                     ______ ___ ____ ______ ____ _______ __ ___

                    SETSTS  channel, status
                    only return

                    MOVE    ac, [.CHSS,,channel]
                    CHANIO  ac, status
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.   Check the  data mode  field (the  right four  bits) of  <status>: if  it is
            illegal for  the device,  abort the  process and  store halt  status HT.IDM  for the
            frame.

            Wait for the device to become inactive, then set the file status bits from <status>.

            5.9.9    STATO: skip if file status bits set (op code 061)
                     ______ ____ __ ____ ______ ____ ___ ___ ____ ____
            5.9.9    .CHSO: skip if file status bits set (CHANIO fn 21)
                     ______ ____ __ ____ ______ ____ ___ _______ __ ___
            5.9.9    STATZ: skip if file status bits clear (op code 063)
                     ______ ____ __ ____ ______ ____ _____ ___ ____ ____
            5.9.9    .CHSZ: skip if file status bits clear (CHANIO fn 20)
                     ______ ____ __ ____ ______ ____ _____ _______ __ ___

                    STATO   channel, mask

                    MOVE    ac, [.CHSO,,channel]
                    CHANIO  ac, mask

                    STATZ   channel, mask

                    MOVE    ac, [.CHSZ,,channel]
                    CHANIO  ac, mask

            All four calls do what GETSTS does to obtain the file status bits.  STATO  and .CHSO
            skip-return  if  the  logical  and   of  the  bits  and  <mask>  is   non-zero,  and
            nonskip-return otherwise.   STATZ and .CHSZ  skip-return if the  logical and  of the
            bits and <mask> is zero, and nonskip-return otherwise.














                                                    5-13


            General I/O                              5                          YAMM edition 2.1


            5.9.10    .CHNXT: return next channel (CHANIO fn 42)
                      _______ ______ ____ _______ _______ __ ___

                    MOVE    ac, [.CHNXT,,channel]
                    CHANIO  ac
                      error return
                    normal return

            If channel is -1, the number of  the next free channel is returned.  If  the channel
            is a legal channel number then  skip return.  If an illegal channel is  specified or
            if the channel is in use, then nonskip return.


























































                                                    5-14


            June 27, 1984                            6                         Buffered Mode I/O


                                                 Section 6
                                                 _______ _
                                             Buffered Mode I/O
                                             ________ ____ ___

                                             Table of Contents



            SubSection


            6.1      Buffer Ring Headers    6-1

            6.2      Buffer Format    6-2

            6.3      Buffer Setup    6-2
            6.3.1       User-Constructed Buffer Rings    6-2
                           Reading Standard Buffer Size    6-2
                           Initial Conditions    6-3
            6.3.2       Monitor-Constructed Buffer Rings    6-3
            6.3.3       DEVSIZ: read standard buffer size (CALLI +101)    6-3
            6.3.4       INBUF: create input buffer ring (op code 064)    6-3
            6.3.4       .CHIBF: create input buffer ring (CHANIO fn 22)    6-3
            6.3.4       OUTBUF: create output buffer ring (op code 065)    6-3
            6.3.4       .CHOBF: create output buffer ring (CHANIO fn 23)    6-3
            6.3.5       MOVBUF: move buffers (CALLI -27)    6-4
            6.3.5       .CHMBF: move buffers (CHANIO fn 26)    6-4

            6.4      Buffered I/O Operations    6-4
            6.4.1       Buffered Input Calls    6-4
            6.4.2       Buffered Output Calls    6-5

            6.5      I/O synchronization    6-6

            6.6      Buffered I/O Errors    6-6


































                                                    6-i


                                                     6                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    6-ii


            June 27, 1984                            6                         Buffered Mode I/O





                                                 Section 6
                                                 _______ _
                                             Buffered Mode I/O
                                             ________ ____ ___




            Buffered-mode i/o  involves the  transfer of  data between  i/o devices  (or monitor
            buffers) and a ring of buffers in the user's address space.  Although P034 maintains
            the appearance of allowing simultaneous transfer of data and user processing of that
            data, this  is true  of only certain  devices, notably  magnetic tape.   Disk device
            transfers  are  handled  synchronously:  no  user  process  runs  while  the monitor
            transfers data to/from the user address space.

            To perform buffered input (output), a program must do the following:
                1)  Init a channel for the  input (output), specifying a buffered  data mode
                    (ASCII,  Katakana, Image,  Image Binary,  or Binary)  and  supplying the
                    address of a three-word input (output) buffer ring header.
                2)  Set up a buffer ring and  make the buffer ring header point to  it.  The
                    program can  allocate the  buffers itself  and set  the pointer;  it can
                    execute an INBUF (OUTBUF) to  cause the monitor to allocate  a specified
                    number of standard-sized  buffers; or it can  do nothing, in  which case
                    the first input (output) operation will do an INBUF  (OUTBUF) allocating
                    a buffer-ring of N standard-sized buffers, where N is standard  for each
                    device.
                3)  If doing output,  execute an OUT or  OUTPUT; this causes the  monitor to
                    set up a byte  pointer and byte count  in the output buffer  ring header
                    through which the program can store its first bufferful of data.
                4)  If  doing input,  execute an  IN or  INPUT; this  causes the  monitor to
                    obtain a bufferful of data from the device and to set up a  byte pointer
                    and byte count in the input buffer ring header through which the program
                    can read its first bufferful of data.
                5)  Read data bytes from (write data bytes to) the buffer,  decrementing the
                    byte  count  each time,  until  the count  becomes  zero.   Then perform
                    another IN or  INPUT (OUT or OUTPUT)  to get another buffer,  and repeat
                    the process.
                6)  When input (output) is complete, release the channel.


            6.1    Buffer Ring Headers
                   ______ ____ _______

            The buffer ring header has the format

                    word 0  bit 0   use bit
                    word 0  rh      current buffer
                    word 1          byte pointer
                    word 2          byte count

            The <use bit> is 1 if no i/o has yet been done using this buffer ring.  It is set to
            1 by the monitor at channel-init  time, and cleared at the first i/o  operation, and
            should not be altered by programs.

            The <current buffer> address is 0 if  no buffer ring has been set up;  otherwise, it
            is the address of the second word  (word 1) of the buffer currently being  filled or
            emptied by the program.  If the monitor  finds the use bit 1 and the  current buffer
            address 0 when  attempting an i/o  operation, it will  perform an INBUF  (or OUTBUF)
            setting up a ring of two standard-size buffers.

            The <byte pointer> and <byte count> words are stored into the header by  the monitor
            at the completion of an i/o operation.  The byte pointer is set to point at the byte
            before the first byte of the buffer  so that the program can do ILDBs or  IDPBs, and
            the byte count is set to the number of words in the buffer times the number of bytes
            per word for the channel's data mode.

            The byte size field of the byte pointer is set by the monitor at  channel-init time,
            and should not be altered by the program.
                                                    6-1


            Buffered Mode I/O                        6                          YAMM edition 2.1


            6.2    Buffer Format
                   ______ ______

            Each buffer in a buffer ring has the format

                    word 0  bits 18-35      file status bits
                    word 1  bit 0           use bit
                    word 1  bits 2-17       buffer size (words)
                    word 1  bits 18-35      next buffer
                    word 2  bits 0-17       checksum (if any)
                    word 2  bits 18-35      word count
                    word 3                  data
                    ...
                    word (<word count>+2)   data
                    word (<word count>+3)   unused
                    ...
                    word (<buffer size>-1)  unused

            The <use  bit> is  1 if  the buffer  is available  to the  emptier, and  0 if  it is
            available to the filler.

            The <buffer size> field contains the  total size of the buffer, including  the three
            header words (word 0 through word 2).

            The <next buffer> address  contains the address of the  second word (word 1)  of the
            next buffer in the ring.

            On binary mode card or paper tape input, the <checksum> field contains  the checksum
            read at  the start of  the input record  and the <word  count> field the  word count
            read.  IO.DTE will be set if  the monitor's computed checksum differs from  the read
            value, and IO.BKT will be set  if an unexpected end-of-file occured (the  count read
            was too  big for  the physical medium)  or if  the count read  was greater  than the
            buffer size.

            On input from other devices and other modes, the <checksum> field is unused  and the
            <word count> contains the number of words actually read from the device.

            On output, the <word  count> originally in the  buffer is normally ignored,  and the
            number of words to output is computed  by the monitor from the current value  of the
            byte pointer in the buffer ring header.   If, however, the IO.UWC bit is set  in the
            file status bits, the monitor will use the <word count> in the buffer instead.


            6.3    Buffer Setup
                   ______ _____

            There are three  ways to set up  a buffer ring: entirely  "by hand", using  INBUF or
            OUTBUF, and letting the monitor allocate the ring by default.

            6.3.1    User-Constructed Buffer Rings
                     ________________ ______ _____

            6.3.1.1    Reading Standard Buffer Size
                       _______ ________ ______ ____

            Each device  has a  standard buffer  size and  a standard-sized  buffer ring.   If a
            program is constructing its  own buffer ring and wants  to make it standard,  it can
            read the standard sizes by executing the DEVSIZ UUO (CALLI +101, pg. 6-3).














                                                    6-2


            June 27, 1984                            6                         Buffered Mode I/O


            6.3.1.2    Initial Conditions
                       _______ __________

            At the time of the first  i/o operation using a particular buffer ring,  the monitor
            expects to find
                1)  Each buffer's <use bit> set to 0.
                2)  Each buffer's <buffer size> set correctly.
                3)  Each buffer's <next buffer> address pointing to the second word (word 1)
                    of the next buffer in the ring.
                4)  The <current buffer> address in the buffer's buffer ring header pointing
                    to the second word (word 1) of one of the buffers in the ring.
                5)  The <use bit> of the buffer ring header set to 1.

            6.3.2    Monitor-Constructed Buffer Rings
                     ___________________ ______ _____

            To cause the  monitor to set up  an input or output  buffer ring for a  channel, the
            program  executes  one   of  .CHIBF  UUO   (CHANIO fn 22,  pg. 6-3)  or   INBUF  UUO
            (op code 064, pg. 6-3) to setup input  buffers, or one of .CHOBF  UUO (CHANIO fn 23,
            pg. 6-3) or OUTBUF UUO (op code 065, pg. 6-3) to setup output buffers.

            Buffers may be moved  once they have been setup  (regardless of who set them  up) by
            performing  the  .CHMBF  UUO  (CHANIO fn 26,  pg. 6-4)  or  MOVBUF  UUO  (CALLI -27,
            pg. 6-4) to inform the monitor of the change.

            6.3.3    DEVSIZ: read standard buffer size (CALLI +101)
                     _______ ____ ________ ______ ____ ______ _____

                    MOVEI   ac, [
                            file status bits
                            SIXBIT /device name/
                    ]
                    DEVSIZ  ac,
                      JFCL
                    only return

            Set <ac> to -1 if  <device name> does not exist,  <0> if the data mode  specified by
            the right four bits of <file status  bits> is not legal for the device, <-2>  if the
            data mode specified is Dump or Dump Records, or

                    standard no. of buffers in ring,,standard buffer size

            otherwise, and skip-return.

            Note that  the <standard buffer  size> returned includes  the three words  of header
            (words 0 through 2).

            6.3.4    INBUF: create input buffer ring (op code 064)
                     ______ ______ _____ ______ ____ ___ ____ ____
            6.3.4    .CHIBF: create input buffer ring (CHANIO fn 22)
                     _______ ______ _____ ______ ____ _______ __ ___
            6.3.4    OUTBUF: create output buffer ring (op code 065)
                     _______ ______ ______ ______ ____ ___ ____ ____
            6.3.4    .CHOBF: create output buffer ring (CHANIO fn 23)
                     _______ ______ ______ ______ ____ _______ __ ___

                    INBUF   channel, number of buffers
                    only return

                    MOVE    ac, [.CHIBF,,channel]
                    CHANIO  ac, number of buffers
                    only return

                    OUTBUF  channel, number of buffers
                    only return

                    MOVE    ac, [.CHOBF,,channel]
                    CHANIO  ac, number of buffers
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Starting at  the location  stored in  .JBFF, allocate  <number of  buffers> buffers,

                                                    6-3


            Buffered Mode I/O                        6                          YAMM edition 2.1


            determining the size of  each buffer from the  device and data mode  associated with
            the <channel>.  If necessary, perform COREs to obtain enough space for  the buffers,
            and if sufficient space cannot be obtained, cause a memory protection violation.

            Increment .JBFF past the last buffer and set up the input (INBUF, .CHIBF)  or output
            (OUTBUF, .CHOBF) buffer ring header for <channel>.

            6.3.5    MOVBUF: move buffers (CALLI -27)
                     _______ ____ _______ ______ ____
            6.3.5    .CHMBF: move buffers (CHANIO fn 26)
                     _______ ____ _______ _______ __ ___

                    MOVE    ac, [bits,,offset]
                    MOVBUF  ac,
                    only return

                    MOVE    ac, [.CHMBF,,channel]
                    CHANIO  ac, [bits,,offset]
                    only return

            where <bits> = channel (for MOVBUF -- ingored for .CHMBF)
                         + '20 if moving input ring
                         + '40 if moving output ring
                         + '100 if moving input header
                         + '200 if moving output header

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Wait  for the  device  initted to  become inactive.   Add  <offset> to  each  of the
            internal pointers according to <bits> and return.


            6.4    Buffered I/O Operations
                   ________ ___ __________

            6.4.1    Buffered Input Calls
                     ________ _____ _____

            To cause the monitor to fill empty buffers in a buffer ring, the caller uses  one of
            IN  UUO  (op code 056,  pg. 5-11),.CHIN  UUO  (CHANIO fn 14,  pg. 5-11),  INPUT  UUO
            (op code 066, pg. 5-11), or .CHIPT UUO (CHANIO fn 3, pg. 5-11):

                    IN      channel, newbuf
                    normal return
                      error return

                    MOVE    ac, [.CHIN,,channel]
                    CHANIO  ac, newbuf
                    normal return
                      error return

                    INPUT   channel, newbuf
                    only return

                    MOVE    ac, [.CHIPT,,channel]
                    CHANIO  ac, newbuf
                    only return

            where <newbuf> is 0 normally and the address of the next buffer
                    if switching buffer rings

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If output is currently in progress for the device, wait for it to complete.

            If <newbuf> is nonzero, wait for i/o to stop in the current input ring,  then switch
            to the buffer ring containing  the buffer at <newbuf>.  If necessary,  start filling
            that buffer, and wait until it is full or until an input error occurs.


                                                    6-4


            June 27, 1984                            6                         Buffered Mode I/O


            If <newbuf> is zero, start  filling, if necessary, the buffer following  the current
            buffer in the  input ring, and wait  until the input is  complete or an  input error
            occurs.

            Check the  error bits (bits  18-22) of the  device's file status  bits.  For  IN and
            .CHIN, skip-return if any are set and nonskip-return if all are clear,  updating the
            input buffer ring header to point to the buffer just filled.  For INPUT  and .CHIPT,
            cause an i/o-error  software interrupt if  any are set,  and return in  either case,
            updating the input buffer ring header to point to the buffer just filled.

            6.4.2    Buffered Output Calls
                     ________ ______ _____

            To cause the monitor to free up a buffer for output, the program executes one of OUT
            UUO   (op code 057,   pg. 5-11),.CHOUT  UUO   (CHANIO fn 15,   pg. 5-11),OUTPUT  UUO
            (op code 067, pg. 5-11), or .CHOPT UUO (CHANIO fn 2, pg. 5-11).

                    OUT     channel, newbuf
                    normal return
                      error return

                    MOVE    ac, [.CHOUT,,channel]
                    CHANIO  ac, newbuf
                    normal return
                      error return

                    OUTPUT  channel, newbuf
                    only return

                    MOVE    ac, [.CHOPT,,channel]
                    CHANIO  ac, newbuf
                    only return

            where <newbuf> is 0 normally and the address of the next buffer
                    if switching buffer rings

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If input is currently in progress on the device, wait for it to finish.

            If <newbuf> is nonzero, wait for i/o to stop in the current buffer ring, then switch
            to the buffer ring containing the buffer at <newbuf>.  If necessary,  start emptying
            that buffer, and wait until the output is complete or an output error occurs.

            In <newbuf> is zero, start emptying, if necessary, the buffer following  the current
            buffer in the output ring, and wait until the output is complete or an  output error
            occurs.

            Check the error  bits (bits 18-22)  of the device's file  status bits.  For  OUT and
            .CHOUT, skip-return if any are set and nonskip-return if all are clear, updating the
            output buffer  ring header  to point  to the  buffer just  emptied.  For  OUTPUT and
            .CHOPT, cause an i/o-error software interrupt  if any are set, and return  in either
            case, updating the output buffer ring header to point to the buffer just emptied.















                                                    6-5


            Buffered Mode I/O                        6                          YAMM edition 2.1


            6.5    I/O synchronization
                   ___ _______________

            (The information below is not applicable to every device; in particular, DSK devices
            do not behave exactly as described below).

            For an input  buffer ring, the monitor  begins filling buffers whenever  the program
            does an input  operation and there  are fewer than  two full buffers  available, and
            stops when it reaches a buffer that the program has not yet emptied.   (Except that,
            for ports, the monitor will not  begin filling buffers until an input  operation has
            been executed with no full buffers available).

            For an output buffer ring, the monitor begins emptying buffers whenever  the program
            does an output operation and the monitor finds no empty buffers available, and stops
            when it reaches a buffer that the program has not yet filled.

            Setting the IO.SYN bit in the file status word will cause the monitor to  stop after
            filling (on  input) or  emptying (on output)  one buffer,  thus keeping  i/o exactly
            synchronized with the program.


            6.6    Buffered I/O Errors
                   ________ ___ ______

            (The information below is not applicable to every device; in particular, DSK devices
            do not any longer mask off error bits until the program reaches the buffer  in which
            the error occurred; the monitor does not know which block of 128 words within a page
            has suffered an error since it deals with DSK devices strictly on a page basis).

            Each time  it finishes filling  an input  buffer or emptying  an output  buffer, the
            monitor stores the appropriate device's file status bits into the right half of word
            0 of that buffer.   If an i/o error occurs,  the monitor will store the  status bits
            immediately, and stop further i/o on the buffer ring.

            The status-reading UUOs  (GETSTS, STATZ, STATO), and  the error-return/normal-return
            mechanism of the IN and OUT UUOs read the current value of the device's  file status
            bits, except that for  disk and magtape input the  error bits are masked off  if the
            program has not yet reached the buffer affected by the error.

            If the monitor has read ahead of the user from a device other than disk  or magtape,
            the program may receive an error indication before it actually reaches the bad data.
            In such a case, the program must check the status bits in each buffer if it wants to
            read all of the "good" data.



























                                                    6-6


            June 27, 1984                            7                             Dump Mode I/O


                                                 Section 7
                                                 _______ _
                                               Dump Mode I/O
                                               ____ ____ ___

                                             Table of Contents



            SubSection


            7.1      Dump I/O Operations    7-1
            7.1.1       Dump Input Calls    7-1
            7.1.2       Dump Output Calls    7-2

            7.2      Dump I/O Errors    7-2





















































                                                    7-i


                                                     7                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    7-ii


            June 27, 1984                            7                             Dump Mode I/O





                                                 Section 7
                                                 _______ _
                                               Dump Mode I/O
                                               ____ ____ ___




            In dump  mode i/o,  the monitor  transmits data to  or from  arbitrary areas  in the
            user's address space, under the control  of a command list whose entries  are 36-bit
            words having one of three forms:
                1)  -count,,addr-1
                        Transfer <count> words to or from <addr> through
                        <addr>+<count>-1
                2)  0,,addr
                        Fetch the next command word from <addr>
                        (This is a GOTO word.  Executing more than three
                        consecutive GOTOs is considered an error).
                3)  0
                        Return to the program.
                        (This marks the end of a command list).

            To perform  dump mode  i/o, a program  must init  a channel in  either Dump  or Dump
            Records  mode.  (Dump  Records differs  from Dump  in that  records larger  than the
            standard  record size  will be  broken  up into  one or  more  standard-size records
            followed possibly by a single short record).


            7.1    Dump I/O Operations
                   ____ ___ __________

            Dump mode I/O is accomplished by INITting the channel in Dump or Dump  Records mode,
            (see 5-10 and 5-3 and then using any of these UUOs:
                1)  .CHIN UUO (CHANIO fn 14, pg. 5-11)
                2)  IN UUO (op code 056, pg. 5-11)
                3)  .CHIPT UUO (CHANIO fn 3, pg. 5-11)
                4)  INPUT UUO (op code 066, pg. 5-11)
                5)  .CHOUT UUO (CHANIO fn 15, pg. 5-11)
                6)  OUT UUO (op code 057, pg. 5-11)
                7)  .CHOPT UUO (CHANIO fn 2, pg. 5-11)
                8)  OUTPUT UUO (op code 067, pg. 5-11)

            7.1.1    Dump Input Calls
                     ____ _____ _____

                    IN      channel, addr
                    normal return
                      error return

                    MOVE    ac, [.CHIN,,channel]
                    CHANIO  ac, addr
                    normal return
                      error return

                    INPUT   channel, addr
                    only return

                    MOVE    ac, [.CHIPT,,channel]
                    CHANIO  ac, addr

            where <addr> is the address of a dump mode command list

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If output is currently  in progress for the device,  wait for it to  complete.  Then
            execute the  command list at  <addr>, and wait  until it is  done or until  an input
            error occurs.

                                                    7-1


            Dump Mode I/O                            7                          YAMM edition 2.1


            Check  the error  bits (bits  18-22) of  the file  status bits.   For IN  and .CHIN,
            skip-return if any are set, nonskip-return if all are clear.  For INPUT  and .CHIPT,
            cause an i/o-error software interrupt if any are set, and return in either case.

            7.1.2    Dump Output Calls
                     ____ ______ _____

                    OUT     channel, addr
                    normal return
                      error return

                    MOVE    ac, [.CHOUT,,channel]
                    CHANIO  ac, addr
                    normal return
                      error return

                    OUTPUT  channel, addr
                    only return

                    MOVE    ac, [.CHOPT,,channel]
                    CHANIO  ac, addr
                    only return

            where <addr> is the address of a dump mode command list

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If input is  currently in progress  for the device, wait  for it to  complete.  Then
            execute the command  list at <addr>, and  wait until it is  done or until  an output
            error occurs.

            Check the  error bits (bits  18-22) of the  file status bits.   For OUT  and .CHOUT,
            skip-return if any are set, nonskip-return if all are clear.  For OUTPUT and .CHOPT,
            cause an i/o-error software interrupt if any are set, and return in either case.


            7.2    Dump I/O Errors
                   ____ ___ ______

            An IN, INPUT, OUT, or OUTPUT returns  to the user program only when the  entire list
            of i/o requests has been processed, or an i/o error has occurred.

            If there is an error  in the i/o list itself  (such as illegal addresses in  the i/o
            words, or the execution of more than three successive GOTO words), abort the process
            and store halt status HT.ADC for the frame.

            I/o  errors stop  further execution  of the  command list,  and return  to  the user
            program after setting  the appropriate error  bits in the  file status bits  for the
            device.

            In neither  case is  there a  method for  the user  to determine  which word  in the
            command list caused the error.

















                                                    7-2


            June 27, 1984                            8                                  Disk I/O


                                                 Section 8
                                                 _______ _
                                                  Disk I/O
                                                  ____ ___

                                             Table of Contents



            SubSection


            8.1      Device Names    8-1
            8.1.1       Logical Unit Names    8-1
            8.1.2       Physical Unit Names    8-2
            8.1.3       Abbreviations    8-2

            8.2      Buffered I/O    8-2

            8.3      Dump I/O    8-2

            8.4      Directories    8-2
            8.4.1       Master File Directory    8-3
            8.4.2       User File Directory    8-3
            8.4.3       Reading a Directory    8-3
            8.4.4       .CHUFD: read UFD (CHANIO fn 33)    8-3

            8.5      Frame Search List    8-5

            8.6      Storage Allocation Table    8-5

            8.7      File Organization    8-5

            8.8      File Access Protection    8-6
            8.8.1       License    8-6
            8.8.2       Disk Files with PIDs    8-7

            8.9      Directory Access Protection    8-7
            8.9.1       License    8-7

            8.10     File Selection    8-8
            8.10.1      File State Transitions    8-9
            8.10.2      Argument Blocks    8-9
            8.10.3      ENTER: select file for output (op code 077)    8-16
            8.10.3      .CHENT: select file for output (CHANIO fn 5)    8-16
            8.10.3      .CHMEN: select file for multi-update output (CHANIO fn 41)    8-16
            8.10.4      LOOKUP: select file for input (op code 076)    8-17
            8.10.4      .CHLK: select file for input (CHANIO fn 4)    8-17
            8.10.5      RENAME: rename or delete a file (op code 055)    8-17
            8.10.5      .CHREN: rename or delete a file (CHANIO fn 11)    8-17
            8.10.6      File Selection Error Codes    8-18
            8.10.7      Closing a Disk File    8-19
            8.10.8      Setting File License    8-20

            8.11     File Positioning    8-20
            8.11.1      Super USETI/USETO    8-21
            8.11.2      USETI: set file position by block (op code 074)    8-21
            8.11.2      .CHUSI: set file pointer by block (CHANIO fn 6)    8-21
            8.11.2      .CHFSI: set file pointer by block (CHANIO fn 27)    8-21
            8.11.2      .CHPSI: set file pointer by page (CHANIO fn 31)    8-21
            8.11.3      USETO: set file position by block (op code 075)    8-22
            8.11.3      .CHUSO: set file position by block (CHANIO fn 7)    8-22
            8.11.3      .CHFSO: set file position by block (CHANIO fn 30)    8-22
            8.11.3      .CHPSO: set file position by page (CHANIO fn 32)    8-22
            8.11.4      SEEK: seek to current page (CALLI +56)    8-23
            8.11.4      .CHSK: seek to current page (CHANIO fn 24)    8-23

            8.12     Direct File Page Manipulation    8-23
            8.12.1      .CHCFP: create file page (CHANIO fn 40)    8-24
            8.12.2      .CHDFP: delete file page (CHANIO fn 36)    8-24
                                                    8-i


            Disk I/O                                 8                          YAMM edition 2.1

            SubSection
            8.12.3      .CHXFP: exchange file pages (CHANIO fn 37)    8-24
            8.12.4      .CHVMP: move virtual page to a file (CHANIO fn 47)    8-25

            8.13     Specialized File Manipulation    8-25
            8.13.1      .CHFTR: Truncate File (CHANIO fn 45)    8-25
            8.13.2      .CHFFI: Find First Interesting Page (CHANIO fn 44)    8-26
            8.13.3      .CHMGN: manipulate update-interlock bit (CHANIO fn 34)    8-26

            8.14     Reading Information    8-27
            8.14.1      Disk Characteristics    8-27
                           DSKCHR: read disk characteristics (CALLI +45)    8-27
            8.14.2      Disk Unit/Structure Names    8-29
                           GOBSTR: Get system search list (CALLI +66)    8-29
                           JOBSTR: Return frames next file structure (CALLI +47)    8-30
                           STRUUO: Manipulate file structures (CALLI +50)    8-30
                           SYSPHY: read physical unit names (CALLI +51)    8-31
                           SYSSTR: read disk structure names (CALLI +46)    8-32
            8.14.3      UGETF: read disk file position (op code 073)    8-32
            8.14.3      .CHUGF: read disk file position (CHANIO fn 10)    8-32

            8.15     Validating and Flushing    8-32
            8.15.1      .CHVRB: validate RIB (CHANIO fn 42)    8-32
            8.15.2      DSKCLR: initialize in-core file system data (CALLI -22)    8-32


            Table

            8-5      Special UFD status bits    8-5
            8-7      File Protection Codes    8-7
            8-8      Directory Protection Bits    8-8
            8-9      File Access State Transition Rules    8-9
            8-10     Argument Codes    8-10
            8-11     Short Lookup Block    8-11
            8-12     Extended Lookup Block    8-12
            8-19     File Selection Error Codes    8-19
            8-28     DSKCHR Data Block    8-28
            8-29     DSKCHR Status Bits    8-29
            8-30     GOBSTR error codes    8-30
            8-31     STRUUO function codes    8-31
            8-31b    STRUUO error codes    8-31
            8-33     DSK: File Status Bits    8-33



























                                                    8-ii


            June 27, 1984                            8                                  Disk I/O





                                                 Section 8
                                                 _______ _
                                                  Disk I/O
                                                  ____ ___




            The disk units of a system are not normally dealt with individually but  are grouped
            into "structures".  The current monitor supports only one disk structure (DSKB), but
            in the future, there may be  many.  The monitor organizes a disk structure  so that,
            rather than appearing as a fixed number of disk units each containing a fixed number
            of pages, it appears to contain  an arbitrary number of "directories" (or  UFDs, for
            User File Directories), each containing a variable number of variable-sized "files".

            A disk file has a name consisting of three parts:
                1)  The name of the structure it is stored on
                2)  The name of the UFD in which it is contained
                3)  The file's name
                4)  The file's extension
            For example,

                    DSKB: (SYS)SYSTAT.SAV

            is in the directory SYS on the structure DSKB; its name is SYSTAT and  its extension
            is  SAV.   A program  could  access this  file  by initting  the  device  DSKB, then
            executing a  file-selection UUO, such  as LOOKUP, to  specify the directory  and the
            file's name and extension.


            8.1    Device Names
                   ______ _____

            Each file  structure has  a four-letter SIXBIT  name.  There  is currently  only one
            structure, and its name is DSKB.

            The structure  specified when a  channel is  initted is the  structure that  will be
            searched by subsequent file-selection UUOs on that channel.

            Normally, a program will init the generic device

                    DSK

            which causes the monitor  to refer to the  frame's "search list" to  determine which
            structures to search  on subsequent operations.  Since  there is currently  only one
            disk structure, specifying DSK as the device is equivalent to specifying DSKB.

            8.1.1    Logical Unit Names
                     _______ ____ _____

            Each disk unit in a structure has a five-letter SIXBIT name, e.g.,

                    DSKB0   for the first unit in the structure
                    DSKB1   for the second, etc.

            If a program inits a  particular logical unit, subsequent operations  which allocate
            disk space (such as appending to a file or creating a file) will attempt to do so on
            the  specified unit,  but file  selection operations  will still  search  the entire
            structure.










                                                    8-1


            Disk I/O                                 8                          YAMM edition 2.1


            8.1.2    Physical Unit Names
                     ________ ____ _____

            Each type of disk controller has a two-letter SIXBIT name.  The only controller type
            currently supported is BP, which controls 3330-compatible disk drives.

            Each controller of a particular type has a three-letter SIXBIT name, e.g.,

                    BPA     the first 3330 controller
                    BPB     the second, etc.

            Each particular unit on a controller has a four-letter SIXBIT name, e.g.,

                    BPA0    the first 3330 on the first controller
                    BPA1    the second 3330, etc.

            If  a program  inits a  particular controller  type, controller,  or  physical unit,
            subsequent operations  which allocate  disk space (such  as appending  to a  file or
            creating a file) will attempt to do so on the specified controller type, controller,
            or unit, but file selection operations will still search the entire structure within
            which it is contained.

            8.1.3    Abbreviations
                     _____________

            The generic name DSK can be abbreviated to DS or D.


            8.2    Buffered I/O
                   ________ ___

            Buffered disk i/o  can be performed in  ASCII, ASCII line (=ASCII),  extended ASCII,
            image, image binary (=image), or binary (=image) mode.

            In ASCII mode, the byte size is 7 bits; in extended ASCII, it is 9 bits; in image it
            is 36 bits.  Regardless of the mode used, the user's buffer is treated as containing
            36 bit words.

            The standard buffer size is 131 (decimal) words (128 data + 3 header).   The monitor
            will always assume that the user is providing standard-sized buffers.  If a program,
            for example, attempts disk  input into a 64-word  buffer with 3-word header,  the 64
            words immediately following the buffer will be written over.


            8.3    Dump I/O
                   ____ ___

            Either  dump  or  dump records  mode  i/o  can  be done  on  disk.   The  two behave
            identically: on input, the data is  read as specified; on output, records  which are
            not a multiple of 200 (occtal) words will be followed by enough 0s to reach the next
            200 word boundary.


            8.4    Directories
                   ___________

            A directory is a specially-formatted file which maps file names and  extensions into
            file addresses.















                                                    8-2


            June 27, 1984                            8                                  Disk I/O


            8.4.1    Master File Directory
                     ______ ____ _________

            The "master file directory" (MFD) of a structure is what the system searches to find
            a particular UFD.

            The "name" of a UFD is its owner's PPN; the "extension" is SIXBIT UFD.

            The master file directory itself can be looked up by passing the name word to LOOKUP
            with the 36-bit value "1,,1" and the extension "UFD".

            8.4.2    User File Directory
                     ____ ____ _________

            A user file directory (UFD) is what the system searches to find a particular file.

            A structure's MFD is  in many ways just  a special case of a  UFD, and a UFD  just a
            special kind of file.  The differences are that
                1)  Only the MFD can contain pointers to UFD's
                2)  A program cannot directly perform i/o on a UFD
                3)  The  privilege  bits  (see  8-6)  of  a  UFD  or  MFD   are  interpreted
                    differently than those of a non-directory file

            8.4.3    Reading a Directory
                     _______ _ _________

            An unlicensed process  cannot directly read  a directory as  though it were  a file.
            The monitor  does, however,  provide a  system call  for reading  the contents  of a
            directory.

            To examine the contents  of a directory, a  program first selects the  directory for
            input using the LOOKUP UUO, (by setting  the .RBNAM word of the LOOKUP block  to the
            PPN of the desired UFD, and the  .RBEXT word to SIXBIT "UFD") and then  executes the
            .CHUFD UUO (CHANIO fn 33, pg. 8-3).

            8.4.4    .CHUFD: read UFD (CHANIO fn 33)
                     _______ ____ ___ _______ __ ___

                    MOVE    ac, [.CHUFD,,channel]
                    CHANIO  ac, addr
                      error return
                    normal return

            where <addr> points to an area of the form

                    wd 0    -length,,addr2
                    wd 1    SIXBIT /filename/
                    wd 2    SIXBIT /extension/
                    wd 3    bits (see below)
                    wd 4    (used by the UUO)
                    wd 5    startname
                    wd 6    startext
                    wd 7    count

            and <bits> = 1B0 to suppress wildcard processing
                             (# and * taken literally)
                       + 1B1 to return file size (in blocks)
                       + 1B2 to return file license word (.RBLIC)
                       + 1B3 to return file creation time and date
                       + 1B4 to return status bits (see below)
                       +1B10 to return the date and time in DEC format
                             and converted to the process's current time
                             zone, rather than in standard format GMT









                                                    8-3


            Disk I/O                                 8                          YAMM edition 2.1


            and <addr2> points to a block (to be filled in by the UUO,
                    one set of entries per file) of the form

                    filename
                    extension
                    size (if requested) [see note below]
                    license word (.RBLIC) (if requested)
                    date,,time (if requested)
                    status bits (if requested) (see below)

                    with optional entries compressed
                    (for example, if the status bits are requested, but
                    the size, license word, and date and time are not,
                    each entry will have only three words and the status
                    bits will be stored in the third).

            and the <status bits> word contains

                    bits 15-16      .RBLIC bits 0-1
                    bits 17-18      .RBLIC bits 2-3
                    bits 19-22      .RBLIC bits 4-7
                    bits 23-26      .RBLIC bits 8-11
                    bits 26-35      file protection code
            (see Table 8-5  for discussion of these bits)


            Note: Size of  file returned is  the value 777777400000 if  the actual file  size is
            greater than 400000 blocks. Users of this  UUO are advised to check the sign  of the
            size returned, and  if negative LOOKUP  the file to get  the size from  the extended
            LOOKUP block.

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If no file has been selected for input, or if the file selected is not  a directory,
            error-return.

            Starting with the UFD entry after the one for <startname>.<startext>, or starting at
            the first directory entry if <startname> = 0, (and error-returning if  the directory
            is empty or  the specified starting  point could not  be found) iterate  through the
            entries satisfying <filename>.<extension>,  where "satisfying" means that  the names
            and extensions exactly match if bit 0 was set in <bits> or that they match if "#" in
            <filename> or  <extension> is  taken to  match any  character and  "*", if  given as
            <filename> or <extension> is taken to  match any filename or extension if bit  0 was
            clear: store the name and extension of each file matched (and as much  optional data
            as was  requested in <bits>)  into successive words  starting with <addr2>  until no
            more matching files are found or <length> words have been written.   Set c(<addr>+7)
            (the  count field)  to  the number  of  files for  which  data was  stored,  and set
            c(<addr>+5) (<startname>) and c(<addr>+6) (<startext>) to the name and  extension of
            the last file for which data was stored.

            If  no  entries  were  stored,  or if  the  EOF  of  the  directory  is encountered,
            error-return; otherwise, skip-return.















                                                    8-4


            June 27, 1984                            8                                  Disk I/O


                                                 Table 8-5 
                                                 _____ ___ 
                                          Special UFD status bits
                                          _______ ___ ______ ____


            Bits in <status word> returned by .CHUFD UUO (CHANIO fn 33, pg. 8-3)

            (See also discussion of .RBLIC in Table 8-12 )

            bit    function

            23     This file is temporary..LOGOUT & GFD will delete it.
            24     This is a JIS-8 Katakana-mode file.
            Other bits may be getting used.  More research required.



            8.5    Frame Search List
                   _____ ______ ____

            When a frame inits DSK rather than a specific disk structure, the monitor determines
            which structures to search on subsequent file-selection operations by  examining the
            frame's  "frame  search  list".   Since  only  one  structure,  DSKB,  is  currently
            supported, the contents of the frame search list are currently of no concern  to the
            user.


            8.6    Storage Allocation Table
                   _______ __________ _____

            Each page of a file structure may
                1)  Be part of some file
                2)  Be mapped into the address space of some process (see 4-1)
                3)  Be defective

            On each structure is a file called (SYS)SAT.SYS (SAT standing for Storage Allocation
            Table).  The file contains two bits for every disk page:
                1)  The Mapped bit (or M-bit), which is set if the page is  currently mapped
                    into some process's address space
                2)  The File bit (or F-bit),  which is set if the  page is bad, or if  it is
                    currently part of a file


            8.7    File Organization
                   ____ ____________

            A directory entry  for a file  points to a  "retrieval information block"  (RIB) for
            that file.  The  RIB contains data about  the protection, ownership, size,  etc., of
            the the file, and a number of "retrieval pointers".

            If the file is not too large (about 300 pages), the retrieval pointers point  to the
            disk pages containing the actual data of the file.

            If the file is extremely large,  the retrieval pointers in the "prime RIB"  point to
            "secondary RIB"  (or "spare  RIB") pages  which in  turn contain  retrieval pointers
            which point to the data pages.

            Storage  for  a  file  is  always  allocated  in  units  of  pages,   although,  for
            compatibility with older monitors, many numbers are given in "blocks"  of 200(octal)
            words.   There  is  also no  preallocation  of  storage to  the  file,  although the
            appearance of the old preallocation system is maintained.











                                                    8-5


            Disk I/O                                 8                          YAMM edition 2.1


            8.8    File Access Protection
                   ____ ______ __________

            A frame is said  to be a (nondirectory) file's  "owner" if that frame's  AUN matches
            the file's PPN in both halves, or  if the right half of the frame's PPN  matches the
            right  half of  the  file's PPN.   A  frame which  is not  the  owner of  a  file is
            considered to be in the same project as the file if the left half of its PPN matches
            the left half of the file's PPN.

            Each (nondirectory) file has a 9-bit "protection code" associated with it.  The code
            consists of three 3-bit fields:
                1)  The left 3 bits are used when the accessor is the file's owner
                2)  The middle 3 bits are used when the accessor is not the file's owner but
                    is in the same project as the file
                3)  The right 3 bits are used when neither is the case
            Each of the three 3-bit protection codes  can take a value from 0 through 7,  with 7
            providing  the  greatest  protection  (least access).  The  codes  are  described in
            Table 8-7 .

            The owner of a file can always change its protection with a RENAME.

            8.8.1    License
                     _______

            A process having Read File (RF) license gets Read access to any (nondirectory) file;
            a process having Write File (WF) license gets All access.

            A process having Home File (HF) license gets Read access to all (nondirectory) files
            whose project number match its own; a process having Write Project (WP) license gets
            All access.

            A  process having  Jacct (JL)  license gets  All access  to any  file in  the stream
            accounting UFD.

            A process  having Home File  (HF) license whose  FPN matches a  file's PPN  gets the
            maximum of  its normal  access to  that file  and the  access it  would have  if its
            programmer number matched the file's.

































                                                    8-6


            June 27, 1984                            8                                  Disk I/O


                                                 Table 8-7 
                                                 _____ ___ 
                                           File Protection Codes
                                           ____ __________ _____


            name   code  access

            FP.NO  7     No access.  For the file's owner, this is equivalent to FP.LK.
            FP.LK  6     Lookup access.  The various attributes of the file that are stored in
                         its RIB can be read (with LOOKUP), but the data itself cannot.
            FP.RUN 5     Run access.  All access permitted by FP.LK is possible. In addition,
                         the RUN and RUNSEG UUOs and the RUN command can execute the contents of
                         this file as a program, but the contents cannot otherwise be read.
            FP.RD  4     Read access.  All access permitted by FP.RUN is possible. In addition,
                         the data in the file can be read.
            FP.AP  3     Append access.  All access permitted by FP.RD is possible. In addition,
                         output can be done to blocks past the current end-of-file (that is, the
                         file can be expanded with new data, but the data already in it cannot
                         be altered).
            FP.UPD 2     Update access.  All access permitted by FP.AP is possible. In addition,
                         the data in the file can be read (by opening the file in update mode)
                         and the file's attributes and name can be read, but the file cannot be
                         truncated and its protection cannot be changed.
            FP.CP  1     Change-protection access.  All access permitted by FP.UPD is possible.
                         In addition, the file's protection and attributes can be changed, and
                         the file can be truncated or superseded (but not deleted).
            FP.ALL 0     All access.  All access permitted by FP.CP is possible. In addition,
                         the file can be deleted.


            8.8.2    Disk Files with PIDs
                     ____ _____ ____ ____

            A file may be marked with a PID, making it available for special access by a process
            running with the same PID.  The special access/protection mechanisms  made available
            by PIDs are discussed fully on 9-1.


            8.9    Directory Access Protection
                   _________ ______ __________

            A  frame  is said  to  be  a directory's  "owner"  if the  frame's  AUN  matches the
            directory's file name.  A frame which is not the owner of a directory  is considered
            to be  in the same  project as  the directory if  the left half  of the  frame's PPN
            matches the left half of the directory's PPN.

            Each directory has a 9-bit protection code associated with it, which is  broken down
            into three 3-bit fields  in the same way as  the file protection code.   The project
            and programmer numbers of  a directory are the left  and right halves of  its "name"
            (since its PPN is always 1,,1).

            Each of the three bits of a directory's protection code controls a  different access
            and the three can be set in any combination.  The bits are shown in Table 8-8 .

            8.9.1    License
                     _______

            A process having Jacct (JL) or Write Absolute (WA) license can access  any directory
            as if  it were  a nondirectory  file with  All access.   (This includes  reading and
            writing it directly).

            A process having Write  File (WF) license can  change the protection of  a directory
            with RENAME.

            A process having Home File (HF)  license whose FPN matches the directory's  PPN gets
            the maximum of its  normal access to that directory  and the access it would  if its
            programmer number matched the directory's.





                                                    8-7


            Disk I/O                                 8                          YAMM edition 2.1


                                                 Table 8-8 
                                                 _____ ___ 
                                         Directory Protection Bits
                                         _________ __________ ____


            name     bit   access

            DP.LK    4     Lookup access.  The accessor can perform LOOKUPs on files in this
                           directory.
            DP.CR    2     New files access.  The accessor can create new files in this
                           directory.
            DP.RD    1     Read access.  The accessor can LOOKUP this directory and obtain the
                           information stored in its RIB; it can also read the directory's
                           entries using the .CHUFD UUO. It cannot read the directory as a file.



            8.10    File Selection
                    ____ _________

            The basic operations relating to file selection are:
                1)  LOOKUP;  Look  up an  existing  file, read  its  RIB data,  and  make it
                    available for input.
                2)  CREATE; Create a new file of zero length, set its initial RIB  data, and
                    make it  available for  input.  When  it is  closed, delete  the current
                    directory  entry for  the file  if there  is one  and make  a  new entry
                    pointing to the file being closed.
                3)  SUPERSEDE;   Create  a   new  file   of  zero   length  to   replace  an
                    identically-named existing  file, set its  initial RIB  data (optionally
                    inheriting values  from the  existing file), and  make it  available for
                    input and output.  When the  file is closed, delete the  directory entry
                    for the file if there still is one and make a new entry pointing  to the
                    file being closed.
                4)  UPDATE; Look up an  existing file, read (and optionally  modify elements
                    of) its RIB data,  and make it available  for input and output.   A file
                    cannot be selected for single-user update unless there are  no processes
                    currently updating (in  single or multiple user  mode) the file;  once a
                    file is selected for single-user update, no process can select that file
                    for updating (in either mode) until it is closed.
                5)  UPDATE (multiple-user); Look up  an existing file, read  (and optionally
                    modify elements of)  its RIB data, and  make it available for  input and
                    output.   A file  cannot be  selected for  multiple-user update  if some
                    process is currently updating the file in single-user mode; once  a file
                    is selected for  multiple-user update, no  process can select  that file
                    for single-user update until it is closed.
                6)  RENAME; Change the name, extension,  directory, or other RIB data  of an
                    existing file.
                7)  DELETE; Delete an existing file.
            There are fewer UUOs than operations.  The appropriate UUOs or UUO sequences for the
            above operations are
                1)  LOOKUP; Execute a LOOKUP UUO.
                2)  CREATE; Execute an ENTER UUO.
                3)  SUPERSEDE; Execute an ENTER UUO.
                4)  UPDATE  (single-user); Execute  a LOOKUP  UUO followed  by an  ENTER UUO
                    specifying the same file.
                5)  UPDATE (multiple-user); Execute a LOOKUP UUO followed by a .CHMEN CHANIO
                    specifying the same file name.
                6)  RENAME; Execute a RENAME UUO specifying the new data.
                7)  DELETE; Execute a RENAME UUO specifying a 0 filename.











                                                    8-8


            June 27, 1984                            8                                  Disk I/O


            8.10.1    File State Transitions
                      ____ _____ ___________

            When the basic operations listed above  are performed on a file, its  state changes.
            The monitor keeps  track of the state  of every file in  the system, and  allows the
            basic  operations  to be  performed  only in  accordance  with  the state-transition
            diagram shown in Table 8-9 .


                                                 Table 8-9 
                                                 _____ ___ 
                                     File Access State Transition Rules
                                     ____ ______ _____ __________ _____



                    File Access State Transition Rules

            #                                OPERATION
                #
                    #       LOOKUP  ENTER   1UPD    *UPD    RENAME
            STATE       #
            ---------------------------------------------------------
            Single Creator  FNF     FBM     FNF     FNF     FNF

            Exists, 0 Users OK      SUP     OK      OK      OK

            N Readers       OK      SUP     OK      OK      OK

            N Readers+*UPD  OK      FBM     FBM     OK      FBM

            N Readers+1UPD  OK      FBM     FBM     FBM     FBM

            N Readers+SUP   OK      FBM     FBM     FBM     FBM

            *UPD = Simultaneous Update including updaters via channels
                    (using !CHMEN) and via maximally-writeable 
                    mapped file pages
            1UPD = Single Update (ENTER and !CHENT only)
            SUP = Supersede
            FBM = "FILE BEING MODIFIED" error from UUO
            FNF = "FILE NOT FOUND" error from UUO

            After a file is successfully superseded, all old users of channels and
            pages continue to use the obsolete file as if nothing had happened.
            New requests for operations on the filename will deal with the new
            file only.  The storage belonging to the obsolete file is returned to
            the system only when the last user of the obsolete file closes his
            channel to it or unmaps his last page from it.


            8.10.2    Argument Blocks
                      ________ ______

            The LOOKUP  UUO (op code 076, pg. 8-17),  ENTER UUO (op code 077,  pg. 8-16), .CHMEN
            UUO (CHANIO fn 41,  pg. 8-16), and  RENAME UUO (op code 055,  pg. 8-17) all  take as
            their argument the  address of a  data block which is  essentially the same  for the
            four UUOs.

            There is a short and an extended form of argument block.  The two  are distinguished
            by the left half of the first word (word) 0, which must be nonzero for a short block
            and 0 for an extended block.

            The short form lookup block is described in Table 8-11  and the long (extended) form
            in  Table 8-12 .   Each entry  in  the tables  has  associated with  it  a  group of
            protection codes which are described in Table 8-10 .






                                                    8-9


            Disk I/O                                 8                          YAMM edition 2.1


                                                Table 8-10 
                                                _____ ____ 
                                               Argument Codes
                                               ________ _____


            code  meaning

            V     This entry is a value stored in the user's argument block by the monitor.
                  Whatever is contained in the argument block entry at the time of the call is
                  ignored by the monitor.
            A     This entry is an argument supplied by the user.  No special access to the file
                  is required.
            A0    This entry is an argument supplied by the user.  If the user does not supply
                  an argument (in the case of an extended block with a count that does not reach
                  the argument), or if the user supplies the appropriate null argument (usually
                  0), the monitor uses a default argument instead, and stores that default into
                  the user's argument block.
            F     Behaves like A0 if the process has Write Files license and like V if it does
                  not.
            FJ    Behaves like A0 if the process has Write File (WF) or Jacct (JL) license, and
                  like V if it does not.
            JD    Behaves like A0 if the process has Jacct (JL) license or if the file is not a
                  directory, and like V otherwise.
            FP    Behaves like A0 if the process has Write Project (WP) or Write File (WF)
                  license, and like V otherwise.
            S     Special protection.











































                                                    8-10


            June 27, 1984                            8                                  Disk I/O


                                                Table 8-11 
                                                _____ ____ 
                                             Short Lookup Block
                                             _____ ______ _____


            Wd  Bits   L  CS U  R   Description
            0          A  A  A  A   File name (in SIXBIT).
                                    When selecting a nondirectory file, the SIXBIT file name;
                                    when selecting a directory file, the PPN; when deleting a
                                    file with RENAME, a 0.
            1   0-17   A  A  A  A   File extension (in SIXBIT).
                                    When selecting a directory, the extension is SIXBIT /UFD/.
                18-35  V  -  V  -   LOOKUP and UPDATE clear this field.
                18     -  V  -  -   ENTER sets this bit if the file already existed (SUPERSEDE)
                                    and clears it if it did not (CREATE).
                20-21  V  A0 A0 A0  Creation date high-order bits.
                                    (see word 2, bits 24-35)
                22-35  V  A0 A0 A0  Access date (in days since 1/1/64 GMT).
                                    CREATE and SUPERSEDE use the current date if this field is 0
                                    or a date in the future.
                                    UPDATE and RENAME use the current date if this field is 0.
                18-35  V  V  V  V   File Selection Error Code.  If LOOKUP, ENTER or RENAME
                                    fails, the code from Table 8-19  is returned here.
            2   0-8    V  A0 V  A0  Protection code.
                                    CREATE and SUPERSEDE use this field if either it or the data
                                    mode field (below) is nonzero; otherwise, CREATE uses 051
                                    for directories and 750 for files, and SUPERSEDE uses the
                                    original protection.
                                    RENAME uses this field if word 2 is nonzero; otherwise it
                                    retains the original protection.
                9-12   V  A0 V  A0  Data mode.
                                    CREATE and SUPERSEDE use this field if either it or the
                                    protection field (above) is nonzero; otherwise, CREATE uses
                                    the mode the channel is open in; and SUPERSEDE retains the
                                    original mode.
                                    RENAME uses this field if word 2 is nonzero; otherwise it
                                    retains the original data mode.
                13-23  V  A0 A0 A0  Creation time (minutes since midnight GMT).
                                    (see word 2, bits 24-35)
                24-35  V  A0 A0 A0  Creation date low-order bits (in days since 1 January 1964).
                                    CREATE and SUPERSEDE use both the creation days and minutes
                                    fields if either is nonzero; otherwise, they use the current
                                    day and minutes.  They will also use the current day if the
                                    day specified is in the future.
                                    UPDATE works the same but accepts future days.
                                    RENAME uses both the creation days and minutes if word 2 is
                                    nonzero; otherwise it retains the original values.
            3          A0 A0 A0 A0  PPN. This can be supplied in any of the forms:
                                    0 (or a negative word): the current process's PPN
                                    0,,[SIXBIT /username/]: the AUN of the specified (two-word)
                                    username
                                    project number,,programmer number: (directly)
                0-17   V     V      LENGTH.
                                    LOOKUP and UPDATE set this field to -file size in words if
                                    the file contains fewer than 2^17 words and file size in
                                    blocks otherwise.













                                                    8-11


            Disk I/O                                 8                          YAMM edition 2.1


                                                Table 8-12 
                                                _____ ____ 
                                           Extended Lookup Block
                                           ________ ______ _____


            Name     wd  bits   L  CS   U  R   Description

            .RBCNT   0   19     -  -    A  A   If 1, RENAME and UPDATE will interpret .RBALC as
                                               being in units of words rather than pages.  (The
                                               .RBALC value returned to the user is always in
                                               units of blocks, regardless of the setting of
                                               this bit).

                     0   20     A  -    -  -   If 1, LOOKUP will grant access if .RBPID matches
                                               the PID of the caller.  If 0, LOOKUP will grant
                                               access according to the conventional protection
                                               system.  See 9-2.

                         27-35  A  A    A  A   Word count. Must be >= 3.

            .RBPPN   1          A0 A0   A0 A0  PPN. This can be supplied in any of the forms:
                                               0 (or a negative word): the current process's PPN
                                               0,,[SIXBIT /username/]: the AUN of the specified
                                               (two-word) username
                                               project number,,programmer number: (directly)

            .RBNAM   2          A  A    A  A   File name (in SIXBIT).  the SIXBIT file name;
                                               when selecting a directory file, the PPN; when
                                               deleting a file with RENAME, a 0.

            .RBEXT   3   0-17   A  A    A  A   File extension (in SIXBIT).
                                               When selecting a directory, the extension is
                                               SIXBIT /UFD/.

                         18     -  V    -  -   ENTER sets this bit if the file already existed
                                               (SUPERSEDE) and clears it if it did not (CREATE).

                         20-21  V  A0   A0 A0  Creation date high-order bits.
                                               (see .RBPRV, bits 24-35)

                         22-35  V  A0   A0 A0  Access date (in days since 1/1/64 GMT).
                                               CREATE and SUPERSEDE use the current date if this
                                               field is 0 or a date in the future.
                                               UPDATE and RENAME use the current date if this
                                               field is 0.

                         18-35  V  V    V  V   Error Code.  If LOOKUP, ENTER, or RENAME fails,
                                               the file selection error code from Table 8-19  is
                                               stored here.

            .RBPRV   4                         Privilege word.

                         0-8    V  A0   V  A0  Protection code.
                                               CREATE and SUPERSEDE use this field if either it
                                               or the data mode field (below) is nonzero;
                                               otherwise, CREATE uses 051 for directories and
                                               750 for files, and SUPERSEDE uses the original
                                               protection.
                                               RENAME uses this field if .RBPRV is nonzero;
                                               otherwise it retains the original protection.

                         9-12   V  A0   V  A0  Data mode.
                                               CREATE and SUPERSEDE use this field if either it
                                               or the protection field (above) is nonzero;
                                               otherwise, CREATE uses ACSII (0) and SUPERSEDE
                                               retains the original mode.
                                               RENAME uses this field if .RBPRV is nonzero;
                                               otherwise it retains the original data mode.

                                                    8-12


            June 27, 1984                            8                                  Disk I/O

            Name     wd  bits   L  CS   U  R   Description
                         13-23  V  A0   A0 A0  Creation time (minutes since midnight GMT).
                                               (see .RBPRV, bits 24-35)

                         24-35  V  A0   A0 A0  Creation date low-order bits (in days since 1
                                               January 1964).
                                               CREATE and SUPERSEDE use both the creation days
                                               and minutes fields if either is nonzero;
                                               otherwise, they use the current day and minutes.
                                               They will also use the current day if the day
                                               specified is in the future.
                                               UPDATE works the same but accepts future days.
                                               RENAME uses both the creation days and minutes if
                                               .RBPRV is nonzero; otherwise it retains the
                                               original values.

            .RBSIZ   5          V  V    V  V   File size (in words).

            .RBVER   6          V  A    A  A   Not used by the monitor.

                         0-17                  UUN of the programmer who last changed the file.

                         18-35                 Version number of the file.

            .RBFUT   7          V  A    A  A   Not used by the monitor.

            .RBEST   10         V  A    A  A   Estimated file size (in blocks).
                                               (see .RBALC, below)

            .RBALC   11         V  A0   A0 A0  Allocated storage (in blocks).
                                               UPDATE and RENAME will truncate the file if
                                               supplied a .RBALC argument which is > 0 but less
                                               than the file's current size.  A .RBALC value of
                                               0 will truncate the file to length 0 rather than
                                               retaining its original length.  Note that if bit
                                               19 of word 0 is set, RENAME and UPDATE will
                                               interpret .RBALC as being in units of words.
                                               ENTER and RENAME will compare the supplied .RBALC
                                               argument with the last value stored in .RBEST,
                                               and place the larger of the two values into the
                                               RIB's .RBALC field.

            .RBPOS   12         V  A    A  A   Not used by the monitor.

            .RBFT1   13         V  A    A  A   Not used by the monitor.

            .RBLIC   14                        File license word.

                         0-1    V  FJ   FJ FJ  Sets bits 1-2 word 3 of file's UFD entry

                         2-3    V  A    A  A   Sets bits 3-4 word 3 of file's UFD entry

                         4-7    V  FJ   FJ FJ  Sets bits 19-22 word 2 of file's UFD entry

                         4                     File dumped

                         5                     File has error

                         6                     File has a PID (for UFD's, means PID storage
                                               acct'g.)

                         8-11   V  A    A  A   Sets bits 23-26 word 2 of the file's UFD entry

                         (8)    V  A    A  A   (sets bit 23 of <status word> returned by .CHUFD
                                               UUO (CHANIO fn 33, pg. 8-3)  ).
                                               This file is a TMP file.  LOGOUT and GFD will
                                               delete it when they execute.


                                                    8-13


            Disk I/O                                 8                          YAMM edition 2.1

            Name     wd  bits   L  CS   U  R   Description
                         (9)    V  A    A  A   (Sets bit 24 of <status word> returned by .CHUFD
                                               UUO (CHANIO fn 33, pg. 8-3) ).
                                               By MAGNUM convention this bit is set if the file
                                               was created in JIS-8 Katakana mode.  This
                                               convention is purely a user-program one and is
                                               not enforced or supported by the monitor.)

                         12-17  V  A0   A0 A0  Creation seconds (since the last minute).
                                               RENAME uses this field if it is nonzero and
                                               retains the original creation seconds otherwise.
                                               ENTER uses this field if it is nonzero;
                                               otherwise, it uses the current time if it has
                                               defaulted the creation days and minutes and 0 if
                                               it has not.

                         18-35  V  S    S  S   License bits.
                                               (see 8-20)

            .RBMTA   15         V  F    F  F   Not used by the monitor.

            .RBDEV   16         V  V    V  V   0.

            .RBSTS   17         V  S    S  S   Status bits.
                                               If the process has Write File (WF) or JL license,
                                               ENTER and RENAME set these bits to the argument,
                                               except the "is-directory" bit (bit 18) which is
                                               maintained by the monitor.
                                               If the process does not have Write File (WF) or
                                               JL license, ENTER and RENAME AND argument bits
                                               27-35 into the RIB entry and leave the other bits
                                               alone.

                         0                     (UFDs only) Set by LOGIN and cleared by LOGOUT
                                               (to determine if the system crashed or was
                                               reloaded without logging all the users off)

                         9                     (UFDs only) Set when the monitor detects a
                                               checksum error for some file in this directory.

                         10                    (UFDs only) Set when the monitor detects a hard
                                               write error for some file in this directory.

                         11                    (UFDs only) Set when the monitor detects a hard
                                               read error for some file in this directory.

                         14                    (UFDs only) Set when the tape backup program
                                               detects a bad file in this directory while
                                               restoring from magtape.

                         15                    (UFDs only) Set when the damage-assessment
                                               program finds a bad file in this directory.

                         18                    1 if this file is a directory.

                         19                    1 if this file or directory may not be deleted.

                         21                    1 if the tape backup program may not delete this
                                               file or directory.

                         26                    1 if the file's PPN = frame PPN (GFD'd directory)
                                               at the time of creation.

                         27                    Set when the monitor detects a checksum error for
                                               this file or directory.

                         28                    Set when the monitor detects a hard write error
                                               for this file or directory.

                                                    8-14


            June 27, 1984                            8                                  Disk I/O

            Name     wd  bits   L  CS   U  R   Description
                         32                    Set when the tape backup program finds this file
                                               bad while restoring from magtape.

                         35                    Set when the damage-assessment program finds this
                                               file or directory bad.

            .RBELB   20         V  V    V  V   Error logical block.
                                               The block number of the first block found bad in
                                               this file.

            .RBXT1   21         V  V    V  V   0.

            .RBQTF   22         V  JD   JD JD  Logged-in disk quota.
                                               For UFDs, the maximum number of data and RIB
                                               pages that can be stored in this directory while
                                               the user is logged-in.

            .RBQTO   23         V  JD   JD JD  Logged-out disk quota.
                                               For UFDs, the maximum number of data and RIB
                                               pages that can be stored in this directory while
                                               the user is logged-out.

            .RBMXA   24         V  JD   JD JD  For UFDs, supplying a nonnegative argument causes
                                               .RBMXA to be set to .RBUSD and the old value of
                                               .RBMXA returned; supplying a negative argument
                                               causes the value last stored to be returned.

            .RBUSD   25         V  JD   JD JD  For UFDs, supplying a nonnegative argument causes
                                               .RBUSD to be set and returns its old value;
                                               supplying a negative argument causes the value
                                               last stored to be returned.

            .RBAUT   26         V  S    S  S   Author.
                                               ENTER and RENAME will use the argument if the
                                               process has Write File (WF) license.
                                               CREATE and SUPERSEDE set this field of the RIB to
                                               the process's PPN if they find it 0 when creating
                                               or superseding the file.

            .RBUNM   27         V  JD   JD JD  Username. 2 words

                     30         V  JD   JD JD  Username, 2nd word (SIXBIT)

            .RBTRU   31         V  JD   JD JD  Not used by the monitor.

            .RBXT2   32         V  JD   JD JD  Not used by the monitor.

            .RBALP   33         V  V    V  V   Allocated pages.
                                               The number of data and RIB pages actually
                                               allocated for this file.

            .RBSNM   34         V  V    V  V   The number of spare RIBs in this file.

            .RBPJC   35         V  FP   FP FP  Project-code information block.  Same format as
                                               argument block to CHPRJ UUO (CALLI -61, pg. 2-8)

                     36                        PJC next word

                     37                        PJC next word

            .RBPID   40         V  *    *  *   Processor ID
                                               Behavior of .RBPID is complex and depends on the
                                               license and PID of the caller.  (see 9-1).





                                                    8-15


            Disk I/O                                 8                          YAMM edition 2.1


            8.10.3    ENTER: select file for output (op code 077)
                      ______ ______ ____ ___ ______ ___ ____ ____
            8.10.3    .CHENT: select file for output (CHANIO fn 5)
                      _______ ______ ____ ___ ______ _______ __ __
            8.10.3    .CHMEN: select file for multi-update output (CHANIO fn 41)
                      _______ ______ ____ ___ ____________ ______ _______ __ ___

                    ENTER   channel, addr
                      error return  ; rh(.RBEXT) contains
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

                    MOVE    ac, [.CHENT or .CHMEN,,channel]
                    CHANIO  ac, addr
                      error return  ; rh(.rbEXT) contains
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

            where <addr> points to a short or extended ENTER block
                    (see above)

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device is not a disk, just skip-return.

            If the output side of the channel  is open, perform a CLOSE operation on  the output
            side.  Clear the end-of-file and error bits of the file status bits.

            If this is a .CHMEN call and no LOOKUP has been done on the channel, take  the error
            return (.CHMEN can only be used for update, not for create or supersede).

            If a LOOKUP has already been done on the channel, take the error return if  the file
            being specified does not match that already looked-up; otherwise, proceed as follows
            (UPDATE):

                If the process does not have  at least Append access to the file  and Lookup
                access to the directory, take the error return.

                If the file is currently selected in single-update mode by some  process, or
                if it is selected  for multiple-update and this  is not a .CHMEN  call, take
                the error return.

                If it  has only  Append access,  fill in the  ENTER block  and set  the file
                attributes  appropriately,  but  do not  process  any  extended  ENTER block
                attributes past word  5 (.RBSIZ).  Make  the file availabble  for subsequent
                output operations if they are to blocks past the end-of-file.

                If it has at least Update access,  fill in the ENTER block and set  the file
                attributes appropriately, but ignore any attempt to truncate the file (using
                .RBALC) if  the process does  not have at  least Change  protection license.
                Make the file  available for output operations  (which will modify  the file
                "in place").

            If a LOOKUP has  not already been performed, search  for the specified file.   If it
            already exists, proceed as follows (SUPERSEDE):

                If the process does not  have at least Change-protection access to  the file
                and Lookup access to the directory, take the error return.

                Othrwise, create a new version of the file, with the protection specified by
                <prot>, and fill in the ENTER block appropriately.  Make the  file available
                for input and output.

            If the file was not already looked-up and does not already exist, proceed as follows
            (CREATE):

                If the process does not have Create access to the directory, take  the error
                return.


                                                    8-16


            June 27, 1984                            8                                  Disk I/O


                Otherwise, create a new file, with protection <prot>, and fill in  the ENTER
                block appropriately.  Make the file available for input and output.

            8.10.4    LOOKUP: select file for input (op code 076)
                      _______ ______ ____ ___ _____ ___ ____ ____
            8.10.4    .CHLK: select file for input (CHANIO fn 4)
                      ______ ______ ____ ___ _____ _______ __ __

                    LOOKUP  channel, addr
                      error return  ; rh(.RBEXT) contains
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

                    MOVE    ac, [.CHLK,,channel]
                    CHANIO  ac, addr
                      error return  ; rh(.RBEXT) contains
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

            where <addr> points to a short or extended LOOKUP block
                    (see above)

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device is not a disk, just skip-return.

            If the input  side of the channel  is open, perform a  CLOSE operation on  the input
            side.  Clear the end-of-file and error bits of the file status bits.

            If the process does not have at least Lookup access to the file and Lookup access to
            the directory, or if the file does not exist, take the error return.

            Fill in the LOOKUP block with  the appropriate information from the file's  RIB.  If
            the  process has  at least  Read access  to the  file, make  the file  available for
            subsequent input operations.

            8.10.5    RENAME: rename or delete a file (op code 055)
                      _______ ______ __ ______ _ ____ ___ ____ ____
            8.10.5    .CHREN: rename or delete a file (CHANIO fn 11)
                      _______ ______ __ ______ _ ____ _______ __ ___

                    RENAME  channel, addr
                      error return  ; rh(.RBEXT) contains
                                    ; file selection error code
                                    ; (see 8-18)
                    normal return

                    MOVE    ac, [.CHREN,,channel]
                    CHANIO  ac, addr
                      error return  ; rh(.RBEXT) contains
                                    ; file selection error code
                                    ; (see section 8-18)
                    normal return

            where <addr> points to a short or extended RENAME block
                    (see above)

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device is not a disk, just skip-return.

            If no  file has ever  been selected on  the channel, take  the error-return.  (It is
            possible, though probably an  error, to do a LOOKUP  CLOSE RENAME or an  ENTER CLOSE
            RENAME and have the RENAME refer to  the file that was selected even though  a CLOSE
            was done).

            If the output side of the channel  is open, perform a CLOSE operation on  the output
            side.

            If <filename> is 0, proceed as follows (DELETE):


                                                    8-17


            Disk I/O                                 8                          YAMM edition 2.1


                If the  selected file  (the file  last selected  on <channel>)  is currently
                selected for output by any process, or if the current process does  not have
                All access to  it; or if the  file is a directory  and one or more  files in
                that directory are currently open, take the error return.

                Otherwise, remove the file's directory entry, and mark the file for deletion
                (it will be deleted when the last of its readers has closed it).

            If <filename> is not 0, perform the following (RENAME):

                If the  selected file  (the file  last selected  on <channel>)  is currently
                selected for output by some process,  or if it is marked for  deletion, take
                the error return.

                If the process does  not have at least Update  access to the file,  take the
                error return.  Otherwise,  set the name of  the file to <filename>,  and, if
                <extension> is not 0, the extension to <extension>.

                If  <ppn descriptor>  differs from  that of  the selected  file,  proceed as
                follows:

                    If  the process  does not  have All  access to  the file  and Create
                    access  to  the  new  directory  (the  direcory  specified  by  <ppn
                    descriptor>),  or if  the new  file already  exists, take  the error
                    return.

                    Otherwise,  move  the  file  from  its  current  directory  to  that
                    specified by <ppn descriptor>.

                If the process is attempting to change any other of the file's  RIB entries,
                make the changes if  it has at least  Change protection access to  the file,
                and take the error return otherwise.

            Perform a CLOSE operation on <channel> and skip-return.

            8.10.6    File Selection Error Codes
                      ____ _________ _____ _____

            The LOOKUP, ENTER, RENAME, RUN, RUNSEG, GETSEG and equivalent CHANIO  functions, and
            CHANIO fn .CHMEN all return error codes from Table 8-19 .





























                                                    8-18


            June 27, 1984                            8                                  Disk I/O


                                                Table 8-19 
                                                _____ ____ 
                                         File Selection Error Codes
                                         ____ _________ _____ _____



            These error codes are returned in bits 18-35 of word 1 of the Short Lookup Block,
            and word .RBEXT of the Extended Lookup Block.  See Table 8-11 and Table 8-12 .

            name     code  condition

            .ERFNF   0     File Not Found.  Illegal file name (0), extended LOOKUP/ENTER/RENAME
                           block with count less than 3.
            .ERIPP   1     Incorrect PPN.  The specified PPN does not exist.
            .ERPRT   2     Protection failure.
            .ERFBM   3     File being modified.  (from ENTER)
            .ERAEF   4     Already existing file.  Attempt to RENAME to an existing file name or
                           an ENTER following a LOOKUP and specifying a different file name.
            .ERISU   5     Illegal Sequence of UUOs.  RENAME where no file has been selected on
                           the device, or LOOKUP on a channel that already has an ENTER in
                           force.
            .ERTRN   6     Transmission error.  Transmission, data, or device error while
                           reading the file for a RUN, RUNSEG, or GETSEG UUO; hardware-detected
                           data or device error while reading a UFD or its RIB;
                           software-detected data inconsistency in a UFD or file RIB.
            .ERNSF   7     Not a saved file.  (from RUN, RUNSEG, GETSEG)
            .ERNEC   10    Not enough core.  (from RUN, RUNSEG, GETSEG)
            .ERDNA   11    Device not available.  (from RUN, RUNSEG, GETSEG)
            .ERNSD   12    No such device.  (from RUN, RUNSEG, GETSEG)
            .ERILU   13    (never happens)
            .ERNRM   14    No room.  No space left on the specified device or structure, or
                           process's disk quota exceeded.
            .ERWLK   15    (never happens)
            .ERNET   16    Not enough table space.  Insufficient space in monitor free core to
                           perform the operation.
            .ERPOA   17    (never happens)
            .ERBNF   20    (never happens)
            .ERNTR   21    (never happens)
            .ERLKM   22    (never happens)


            8.10.7    Closing a Disk File
                      _______ _ ____ ____

            The CLOSE UUO  (op code 070, pg. 5-12) for a  disk device closes the  file currently
            selected on  the channel and  allows a new  file to be  selected (without  having to
            release and re-init the device).   The file name, extension, and ppn  are remembered
            until  the next  file selection  operation, however,  so the  sequence  LOOKUP CLOSE
            RENAME is permissible, though probably an error.

            On closing a file that was  open for input, the disk device-dependent  code normally
            updates  the access  date of  the  file to  the current  date.  This  action  can be
            inhibited by setting CL.ACS in the CLOSE argument.

            On closing a file that was being created or superseded, the monitor normally deletes
            the old version of the file (if  there was one) and replaces it with the  file being
            closed.  This action can be inhibited by setting CL.RST in the CLOSE argument.













                                                    8-19


            Disk I/O                                 8                          YAMM edition 2.1


            8.10.8    Setting File License
                      _______ ____ _______

            When a process supersedes or updates  a file which has license set  (c<.RBLIC right>
            nonzero),  the file's  license is  reduced,  if necessary,  to roughly  that  of the
            process modifying the  file.  The exact algorithm  by which ENTER computes  the file
            license (<result>) is:

                Let  <result> be  0 if  the file  is being  created, or  the  file's current
                license if it is being updated or superseded.

                If the project number (left half) of the process's PPN differs from  that of
                the file, clear Home File (HF) license from <result> unless the  process has
                Write File (WF) license, and set the read(write) privilege field of <result>
                to 0 if it was previously set to read(write) project.

                If the project numbers match but the programmer numbers (right half) do not,
                clear Home File (HF) license from <result> unless the process has Write File
                (WF) or Write Project (WP) license.

                If <result> specifies greater read(write) privilege than the current process
                has, set <result>'s  read(write) privilege field to  0.  Turn off  any other
                license bits (with the exception of Home File (HF) license) in <result> that
                are not set for the current process.

            If the ENTER is  extended, and specifies a new  set of license bits  (<want>), ENTER
            performs a further computation to obtain the license (again <result>):

                Let <max>  be the maximum  of the current  process license (minus  Home File
                (HF) license) and <result>, and let <want> be the license  argument supplied
                by the program.

                Set <result> = <want>.

                If the project number (left half) of the process's PPN differs from  that of
                the file, clear Home File  (HF) license from <result> unless  <max> contains
                Home File (HF) or Write File (WF) license, and set the read(write) privilege
                field of <result> to 0 if  it neither <want> nor <max> contain  greater than
                read(write) project.

                If the project numbers match but the programmer numbers (right half) do not,
                clear Home File (HF) license  from <result> unless <max> contains  Home File
                (HF), Write File (WF), or Write Project (WP) license.

                If <result> specifies greater read(write) privilege than <max> contains, set
                <result>'s read(write)  privilege field  to 0.  Turn  off any  other license
                bits (with the exception of Home File (HF) license) in <result> that are not
                set in <max>.

            <result> is now the license actually set for the file.


            8.11    File Positioning
                    ____ ___________

            The monitor maintains  for each channel  initted to a  disk device a  "file pointer"
            which  specifies  the disk  block  to be  referenced  by the  next  input  or output
            operation.

            Any process which has initted a disk device and selected a file on a channel can set
            the "file pointer" for that channel  to some relative block within the  file.  There
            are two positioning  operations, USETI and USETO  (and several variations  on each).
            USETI is normally used  before an input operation  and USETO before an  output.  The
            major differences are:
                1)  USETO requires  that an ENTER  have been done;  USETI works if  either a
                    LOOKUP or ENTER has been done
                2)  USETI, if given a file position past the end-of-file, will set IO.EOF in
                    the file  status bits and  set the  file pointer to  point to  the block
                    after the last block of the file; USETO will expand the file out  to the
                    specified block.
                                                    8-20


            June 27, 1984                            8                                  Disk I/O


            USETI and USETO take as arguments a  "file block number", which is 1 to  specify the
            first block of the file.

            8.11.1    Super USETI/USETO
                      _____ ___________

            A process which  has Write Absolute  (WA) or Read Absolute  (RA) license can  init a
            channel to a  disk structure or  device and then perform  a "super USETI"  or "super
            USETO" operation to set the file pointer to some block on that structure or device.

            A super  USETI or  USETO counts  as a file-selection  operation in  that i/o  can be
            performed on  a disk  device if and  only if  either a file  has been  selected with
            LOOKUP or ENTER, or the channel is in "super mode" as a result of having had a super
            USETI or USETO done on it.

            Super USETI and USETO take as arguments a "disk block number", which is 0 to specify
            the first block of the structure or device.

            A disk device channel may also be put into super mode by a .CHSMP UUO (CHANIO fn 43,
            pg. 4-6) operation. Once in super mode,  ordinary IN, OUT, INPUT and OUTPUT  UUOs or
            the .CHSMP UUO may be used to perform data access.

            8.11.2    USETI: set file position by block (op code 074)
                      ______ ___ ____ ________ __ _____ ___ ____ ____
            8.11.2    .CHUSI: set file pointer by block (CHANIO fn 6)
                      _______ ___ ____ _______ __ _____ _______ __ __
            8.11.2    .CHFSI: set file pointer by block (CHANIO fn 27)
                      _______ ___ ____ _______ __ _____ _______ __ ___
            8.11.2    .CHPSI: set file pointer by page (CHANIO fn 31)
                      _______ ___ ____ _______ __ ____ _______ __ ___

                    USETI   channel, block
                      or
                    MOVE    ac, [.CHUSI,,channel]
                    CHANIO  ac, block
                      or
                    MOVE    ac, [.CHFSI,,channel]
                    CHANIO  ac, [lblock]
                      or
                    MOVE    ac, [.CHPSI,,channel]
                    CHANIO  ac, [page]
                    only return

            where <block> is a halfword file block number (normal USETI)
                    or the address of a fullword disk block number (super USETI)

            and <lblock> is a fullword file (normal USETI)
                    or disk (super USETI) block number

            and <page> is a fullword file (normal USETI)
                    or disk (super USETI) page number

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            Wait for the device  to become inactive.  If  buffered input is being  performed and
            the monitor has read ahead of  the program, discard the read-ahead buffers.   If the
            device is not a disk, return.

            If no file has been selected on the channel, perform the following (super USETI):

                If  the process  does not  have Read  Absolute (RA)  or Write  Absolute (WA)
                license, just set IO.BKT in the file status bits; otherwise, proceed:

                If "DSK"  or some  disk structure  was initted,  interpret the  block (page)
                number as a logical block (page) within the structure; if a  particular unit
                was initted,  interpret it  as an  absolute block  (page) number  within the
                unit.  If the  number is out  of range, just set  IO.BKT in the  file status
                bits; otherwise proceed:

                Set the file pointer  to refer to the  specified block (page), and  make the
                disk available  for subsequent input  (and output if  the process  has Write

                                                    8-21


            Disk I/O                                 8                          YAMM edition 2.1


                Absolute  (WA) license)  operations.  (The  channel will  now be  in "super"
                mode, and subsequent LOOKUPs and ENTERs will be illegal).

            Otherwise, proceed as follows (normal USETI):

                Interpret the  block (page)  number as  a relative  block (page)  within the
                file.  If it is  out of bounds, set IO.EOF  in the file status bits  and set
                the file pointer to refer to the block after the last block of the file.

            Check the  error bits (bits  18-22) of the  file status bits.   If any  are nonzero,
            cause an io-error software interrupt if the process is enabled for one.  Return.

            8.11.3    USETO: set file position by block (op code 075)
                      ______ ___ ____ ________ __ _____ ___ ____ ____
            8.11.3    .CHUSO: set file position by block (CHANIO fn 7)
                      _______ ___ ____ ________ __ _____ _______ __ __
            8.11.3    .CHFSO: set file position by block (CHANIO fn 30)
                      _______ ___ ____ ________ __ _____ _______ __ ___
            8.11.3    .CHPSO: set file position by page (CHANIO fn 32)
                      _______ ___ ____ ________ __ ____ _______ __ ___

                    USETO   channel, block
                      or
                    MOVE    ac, [.CHUSO,,channel]
                    CHANIO  ac, block
                      or
                    MOVE    ac, [.CHFSO,,channel]
                    CHANIO  ac, [lblock]
                      or
                    MOVE    ac, [.CHPSO,,channel]
                    CHANIO  ac, [page]
                    only return

            where <block> is a halfword file block number (normal USETO)
                    or the address of a fullword disk block number (super USETO)

            and <lblock> is a fullword file (normal USETO)
                    or disk (super USETO) block number

            and <page> is a fullword file (normal USETO)
                    or disk (super USETO) page number

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If buffered  output is  being performed  and the  program has  written ahead  of the
            monitor, start  output of all  the buffers (including  the partial  buffer currently
            being written).  Wait  for the device  to become inactive.  If  the device is  not a
            disk, return.

            If no ENTER has been done on this channel, proceed as follows (super USETO):

                If a  LOOKUP has  been done,  or if the  process does  not have  either Read
                Absolute (RA) or  Write Absolute (WA) license,  just set IO.BKT in  the file
                status bits; otherwise, proceed:

                If "DSK"  or some  disk structure  was initted,  interpret the  block (page)
                number as a logical block (page) within the structure; if a  particular unit
                was initted,  interpret it  as an  absolute block  (page) number  within the
                unit.  If the  number is out  of range, just set  IO.BKT in the  file status
                bits; otherwise proceed:

                Set the file pointer  to refer to the  specified block (page), and  make the
                disk available  for subsequent input  (and output if  the process  has write
                absolute)  operations.   (The  channel  will now  be  in  "super"  mode, and
                subsequent LOOKUPs and ENTERs will be illegal).

            Otherwise, perform the following (normal USETO):

                Interpret the  block (page)  number as  a relative  block (page)  within the
                file.  If it is out of bounds, expand the file as follows:

                                                    8-22


            June 27, 1984                            8                                  Disk I/O


                    Fill in  the space (if  any) between the  end-of-file block  and the
                    last block of the page containing it with zeros.

                    Fill  in  the  space  (if  any)  between  the  page  containing  the
                    end-of-file block and the  page containing the specified  block (the
                    specified  page, in  the  case of  .CHPSO) with  "holes"  (null page
                    pointers).

                    If this is a .CHPSO UUO,

                        Create the specified page.

                    Otherwise,

                        Create the page containing the specified block, and  fill in
                        the space (if any) between its first block and the specified
                        block with zeros.

                If the file was being expanded and the monitor ran out of disk space  on its
                structure  or  the  process  exceeded  its  disk  quota,  just  set  IO.BKT;
                otherwise, set the file pointer to refer to the specified block (page).

            Check the  error bits (bits  18-22) of the  file status bits.   If any  are nonzero,
            cause an io-error software interrupt if the process is enabled for one.  Return.

            8.11.4    SEEK: seek to current page (CALLI +56)
                      _____ ____ __ _______ ____ ______ ____
            8.11.4    .CHSK: seek to current page (CHANIO fn 24)
                      ______ ____ __ _______ ____ _______ __ ___

                    SEEK    channel,
                    only return

                    MOVE    ac, [.CHSK,,channel]
                    CHANIO  ac,
                    only return

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.

            If the device initted is not a disk, just return.

            Otherwise, if the disk  unit containing the next page  to be read or written  on the
            channel is currently idle, issue a positioning request to prepare for the  next read
            or write, and return.


            8.12    Direct File Page Manipulation
                    ______ ____ ____ ____________

            There are several operations supplied by the monitor for directly manipulating pages
            of  a file  (in  addition to  the basic  mapping  operation supplied  by  .CHMFP UUO
            (CHANIO fn 35, pg. 4-5): a  page can be  created at some point  in the file  where a
            page does not already exist; a page  can be deleted from some point in the  file; or
            two file pages can be exchanged.

            It should be noted that, to the monitor, a "file" is basically just a set  of pages.
            The file's RIB contains a map pointing to the pages making up the file, and that map
            can be thought of as being similar to a process's map.

            When a process maps a file page, it is actually just mapping into its  address space
            the disk page which  is currently pointed to by  the appropriate slot in  the file's
            RIB.  If process  A maps page  12 of the file  and process B  subsequently exchanges
            page 12 with page 13, process A will still be using the same disk page it  was using
            before, with the  result that it  will now be using  what process B  (and subsequent
            mappers) see as page 13 of the file.

            In brief, the  delete, create, and exchange  operations only affect the  RIB entries
            for the file.   They have no  effect on any of  the pages of  the file which  may be
            currently mapped by any process.

                                                    8-23


            Disk I/O                                 8                          YAMM edition 2.1


            8.12.1    .CHCFP: create file page (CHANIO fn 40)
                      _______ ______ ____ ____ _______ __ ___

                    MOVE    AC, [.CHCFP,,channel]
                    CHANIO  AC, [page]
                      error return  ; AC/ error code
                    normal return

            where <error code> is a code from Table 4-20 .

            If <page> is negative, set c(<addr>) to  the page number of the page above  the last
            page of the file, and use that number as <page>.

            If no file is selected  on <channel> or if the  process has not ENTERed the  file or
            did not have at least append access to it at the time of the ENTER; or if  <page> is
            past the end-of-file and the process did not have at least update access to the file
            at the time of the ENTER; or if <page> is 0; or if page <page> already exists in the
            file, error-return.

            Otherwise, allocate a disk page, clear it to zeros, make it page <page> of the file,
            and skip-return.

            This operation will extend the length of the file if the page being created  is past
            the current end-of-file.

            8.12.2    .CHDFP: delete file page (CHANIO fn 36)
                      _______ ______ ____ ____ _______ __ ___

                    MOVE    AC, [.CHDFP,,channel]
                    CHANIO  AC, [page]
                      error return  ; AC/ error code
                    normal return

            where <error code> is a code from Table 4-20 .

            If no file  has been selected on  <channel>; or if the  process has not  ENTERed the
            file or did not have  at least update access to it  at the time of the ENTER;  or if
            <page> is negative, zero or past the end-of-file; or if page <page> of the file does
            not exist, error-return.

            Otherwise, delete page <page> of the file and skip-return.

            This operation does  not affect the  EOF; regardless of where  in the file  the page
            lives, it  is replaced  with a "hole".   Thus the  EOF of a  file may  be at  a word
            position past that of the last real  data; i.e, it may point to a hole.   See .CHFTR
            UUO (CHANIO fn 45, pg. 8-25).

            8.12.3    .CHXFP: exchange file pages (CHANIO fn 37)
                      _______ ________ ____ _____ _______ __ ___

                    MOVE    AC, [.CHXFP,,channel]
                    CHANIO  AC, [
                            page1
                            page2
                    ]
                      error return  ; AC/ error code
                    normal return

            where <error code> is a code from Table 4-20 .

            If no file  has been selected on  <channel>; or if the  process has not  ENTERed the
            file or did not have  at least update access to it  at the time of the ENTER;  or if
            either <page1> or <page2> is negative, zero or past the end-of-file, error-return.

            Otherwise,  exchange  <page1>'s  entry   in  the  file's  RIB  with   <page2>'s  and
            skip-return.





                                                    8-24


            June 27, 1984                            8                                  Disk I/O


            8.12.4    .CHVMP: move virtual page to a file (CHANIO fn 47)
                      _______ ____ _______ ____ __ _ ____ _______ __ ___

                    MOVE    ac, [.CHVMP,,channel]
                    CHANIO  ac, ADDR
                     error return   ; AC/ garbage
                    normal return

            ADDR:   count,,virtual-page
                    file-page       ; -1 to append


            If no file  has been selected on  <channel>; or if the  process has not  ENTERed the
            file or did not have  at least update access to it  at the time of the ENTER;  or if
            <virtual page number> is negative or zero; or if <virtual page> is part of a file or
            is shared or  does not exist; or  if <file page number>  is positive and  page <file
            page number> of the file does not exist, error-return.

            Otherwise, move the  specified virtual page(s) into  the file open on  the specified
            channel as indicated by <file-page>.  If <file-page> is -1, the page will  be placed
            immediately past the current end-of-file.

            Skip-return.


            8.13    Specialized File Manipulation
                    ___________ ____ ____________

            Three CHANIOs are available to fill other file control needs
                1)  .CHFTR UUO (CHANIO fn 45,  pg. 8-25) allows the  caller to move  the EOF
                    point
                2)  .CHFFI UUO (CHANIO fn 44, pg. 8-26) allows the caller to search  the RIB
                    structure of a  file for "interesting" pages:  the next "hole"  page, or
                    the next "real" page, for example
                3)  .CHMGN UUO  (CHANIO fn 34, pg. 8-26) allows  several updaters of  a file
                    to interlock with one another as they attempt to update

            8.13.1    .CHFTR: Truncate File (CHANIO fn 45)
                      _______ ________ ____ _______ __ ___

                    MOVE    AC,[.CHFTR,,<channel>]
                    CHANIO  AC,LOC
                     error  return          ;ac contains error code
                    normal  return

            LOC:    <new size in words>

            Perform the  normal CHANIO checks.   If <new  size in words>  is negative,  zero, or
            greater than the current EOF; or if no file is selected on <channel> or if  there is
            a RIB error for the  file; or if the caller  has not ENTERed the file  on <channel>,
            set AC to the appropriate error code from Table 4-20 and take the error return.

            Set the file EOF to <new size in words>, and return to the system any complete pages
            which are past the new EOF.  The new EOF may lie within what was previously  a hole.
            (If the new  EOF is in  the middle of an  existing page, do  not clear out  the data
            within that page past the EOF).  Take the normal return.















                                                    8-25


            Disk I/O                                 8                          YAMM edition 2.1


            8.13.2    .CHFFI: Find First Interesting Page (CHANIO fn 44)
                      _______ ____ _____ ___________ ____ _______ __ ___

                    MOVE    AC,[.CHFFI,,<channel>]
                    CHANIO  AC,LOC
                     error return   ;ac contains error code
                    normal return

            LOC:    <file page number>      ;for beginning of search
            LOC+1   <condition of interest>


            <condition of interest> codes are as follows:
            0       find first "hole" at or after <file page number>
            1       find first real page at or after <file page number>

            error codes are taken from Table 4-20

            Perform the usual CHANIO checks.  If no file exists on <channel>, or if the  file is
            LOOKUP-ONLY, or if the file has a  RIB error, or if <file page number>  is negative,
            zero or greater than the file EOF page, or if <condition of interest> is not 0 or 1,
            set AC to the appropriate error code and take the error return.

            Scan  the RIB  for  the first  file page  beginning  with <file  page  number> which
            satisfies <condition of interest>.   Store the number of  this page at LOC  and take
            the normal return.

            8.13.3    .CHMGN: manipulate update-interlock bit (CHANIO fn 34)
                      _______ __________ ________________ ___ _______ __ ___

                    MOVE    AC,[.CHMGN,<channel>}]
                    CHANIO  AC,LOC
                     error return   ;ac unchanged
                    normal return

            LOC:    <function>
            LOC+1   data returned here


            Perform the usual CHANIO checks.

            If the device on <channel> is not a disk device, take the normal return.

            If <function> is not an item from the list below,, take the error return.

            function code   action
            0,,1            updater wants to clear flag in all DDB's for this file
            1,,1            updater wants to set flag in all DDB's
            0,,2            read and clear flag in own DDB
            0,,3            is the file on <channel> being updated?
            0,,4            is there another reader of this file?
            0,,5            read simultaneous update information


















                                                    8-26


            June 27, 1984                            8                                  Disk I/O



            Function  1 allows  multiple readers  and  writers of  a file  to  communicate their
            intentions among one another.   The left half of  <function> must be zero  (to clear
            the flag for all other DDBs) or one (to set it).  If the lh is not 0 or 1,  take the
            error return.  If  the caller does  not have the file  on <channel> in  update mode,
            take the error return.   Set or clear the interlock  flag in all DDBs for  the file.
            Take the normal return.

            Function 2 allows the caller to see if he has been interlocked.  Set LOC+1 to 0 or 1
            according to whether the flag is 0 or 1.  Take the normal return.

            Function 3 allows the caller to see  if the file is being updated by anyone.   If no
            file exists on <channel>,  take the error return.  Set  LOC+1 to 0 if not  in update
            mode, 1 if in update mode. Take the normal return

            Function 4 allows an updater to see if other readers exist.  If the caller  does not
            have the file on <channel> in update mode, take the error return.  If  other readers
            exist, set LOC+1 to 1; otherwise set it to 0; take the normal return.

            Function 5 lets simultaneous  updaters know about the file.   If no file is  open on
            <channel>, take the error return. Set LOC+1 to:

            LOC+1:  number of updating channels,,pages mapped max-write


            8.14    Reading Information
                    _______ ___________

            8.14.1    Disk Characteristics
                      ____ _______________

            A program can obtain the characteristics  of a disk device or class of  disk devices
            with  the DSKCHR  UUO.   The UUO  returns  a data  block  of the  form  described in
            Table 8-28 .

            The <name> (word 0) is supplied by the program and can be in one of seven forms:
                1)  the generic device DSK or a logical name ASSIGNed to it
                2)  a structure name (DSKB))
                3)  a unit within a structure (DSKB1)
                4)  a controller class (BP)
                5)  a controller (BPA)
                6)  a unit within a controller (BPA1)
            The UUO also returns a word of status bits described in Table 8-29 .

            8.14.1.1    DSKCHR: read disk characteristics (CALLI +45)
                        _______ ____ ____ _______________ ______ ____

                    MOVE    ac, [length,,addr]
                    DSKCHR  ac,
                      error return
                    normal return

            where <addr> points to a DSKCHR data block as described below,
                    whose first entry (word 0) the program has filled in
                    with a device name

            Search for a disk unit satisfying <name>:
                1)  generic DSK: Use the first unit of the first structure on the system
                2)  structure: Use the first unit of the structure
                3)  unit within structure: Use the specified unit
                4)  controller class:  Use the  first unit  on the  first controller  of the
                    class in the system
                5)  controller: Use the first unit on the controller
                6)  unit within controller: Use the specified unit
            If no such device is found, take the error return.

            Otherwise, set c(<ac>) to the  DSKCHR Status Bits (see Table 8-29 ) for  the device,
            store  up to  <length> words  of data  from the  device into  the DSKCHR  Data Block
            starting at <addr> (see Table 8-28 ), and skip-return.


                                                    8-27


            Disk I/O                                 8                          YAMM edition 2.1


                                                Table 8-28 
                                                _____ ____ 
                                             DSKCHR Data Block
                                             ______ ____ _____


            word   contents

            0      device name argument (see DSKCHR UUO (CALLI +45, pg. 8-27))
            1      number of blocks left in quota
            2      number of pages left on the structure
            3      number of pages left on the unit
            4      SIXBIT structure name
            5      unit characteristics word
            6      number of pages on the unit
            7      (unused)
            10     (unused)
            11     number of SAT blocks on the unit
            12     (unused)
            13     (unused)
            14     logical name within structure (e.g., DSKB1)
            15     unit name within controller (e.g., BPA1)
            16     home block id
            17     (unused)
            20     left half: logical page number of unit's first HOM page
                   right half: logical page number of unit's second HOM page
            21     left half: logical page number of unit's first BAT page
                   right half: logical page number of unit's second BAT page
            22     left half: number of pages in a unit's bootstrap area
                   right half: logical page number of start of bootstrap area








































                                                    8-28


            June 27, 1984                            8                                  Disk I/O


                                                Table 8-29 
                                                _____ ____ 
                                             DSKCHR Status Bits
                                             ______ ______ ____


            name     bits  contents

            DC.OFL   1B1   unit offline
            DC.HWP   1B2   unit hardware write-protected
            DC.USF   1B6   unit unsafe
            DC.MSB   1B9   unit has multiple SAT blocks
            DC.TYP   7B17  type of <name> passed to DSKCHR
                           .DCTDS    0     generic DSK
                           .DCTFS    2     file structure
                           .DCTUF    3     unit within structure
                           .DCTCN    4     controller class
                           .DCTCC    5     controller within class
                           .DCTPU    6     unit within controller
            DC.DCN   7B20  data channel number
            DC.CNT   77B26 controller type
                           .DCCDR    0     FH  drum
                           .DCCFH    1         fixed-head disk
                           .DCCDP    2     DP  disk pack (RP01,RP02)
                           .DCCMD    3         mass disk
                           .DCCBP    4     BP  big pack (IBM 3330)
            DC.CNN   7B29  controller number
            DC.UNT   3B31  unit type
                           controller type = FH
                           .DCUBU    0     Burroughs disk
                           .DCBBR    1     Bryant drum
                           controller type = DP
                           .DCUD1    0     RP01
                           .DCUD2    1     RP02
                           controller type = MD
                           .DCUDP    0     dual positioner
                           .DCUSP    1     single positioner
                           controller type = BP
                           .DCUM1    0     3330 Model I
                           .DCUM2    1     3330 Model II
            DC.UNN   7B35  unit number within controller


            8.14.2    Disk Unit/Structure Names
                      ____ ______________ _____

            These UUOs allow a  program to obtain names of  all the disk units (SYSPHY)  or disk
            structures (SYSSTR) in a system.

            8.14.2.1    GOBSTR: Get system search list (CALLI +66)
                        _______ ___ ______ ______ ____ ______ ____

                    MOVE    ac,[count,,addr]
                    GOBSTR  ac,
                      error return          ; ac/ error code
                    normal return

            addr:   frame number            ; or 0 for system
                    PPN of frame
                    -1                      ; sixbit structure name returned here
                    Z                       ; not used
                    Z                       ; status returned here

            where <error code> is given in Table 8-30 .

            If <frame number> is zero, the PPN is ignored and the system search list is scanned.
            If <frame number> and <PPN> are  -1 then the current frames search list  is scanned.
            If the PPN of the specified frame does not match <PPN>, or the frame does not exist,
            then an error is given.

            Requesting information  about another  frame or the  system requires  Structure (ST)
            license.
                                                    8-29


            Disk I/O                                 8                          YAMM edition 2.1


                                                Table 8-30 
                                                _____ ____ 
                                             GOBSTR error codes
                                             ______ _____ _____


            name     code  description

            DFGIF%   3     <addr>+2 is not in search list and is neither -1 nor 0.
            DFGPP%   6     <frame> and <PPN> do not agree
            DFGNP%   10    No license
            DFGLN%   12    Bad length for list


            8.14.2.2    JOBSTR: Return frames next file structure (CALLI +47)
                        _______ ______ ______ ____ ____ _________ ______ ____

                    MOVE    ac,[count,,addr]
                    JOBSTR  ac,
                      error return
                    normal return

            addr:   -1              ; sixbit structure name returned here
                    Z               ; not used
                    Z               ; status bits returned here

            If <addr> contains -1 the first file structure name is returned.   Otherwise, <addr>
            should contain a  file structure name  and the one following  that on in  the frames
            search list is returned.

            8.14.2.3    STRUUO: Manipulate file structures (CALLI +50)
                        _______ __________ ____ __________ ______ ____

                    MOVE    AC,[length,,addr]
                    STRUUO  AC,
                      error return          ; AC/ error code
                    normal return           ; AC/ status information

            ADDR:   function                ; see Table 8-31 
                    arguments if any

            where <error code> is found in Table 8-31b.

            The argument list consists  of word triplets, which  specify the new search  list in
            order to replace the current search list.  The current search list may be determined
            by the JOBSTR UUO (CALLI +47, pg. 8-30).  The format of a triplet is:

                    SIXBIT "str-name"
                    0                       ; not used
                    status-bits

            The status bits are:

                    1B0     0=read/write, 1=read only
                    1B1     don't create files on this structure

            Perform the specified function.  All functions except .FSSRC require  Structure (ST)
            license.














                                                    8-30


            June 27, 1984                            8                                  Disk I/O


                                                Table 8-31 
                                                _____ ____ 
                                           STRUUO function codes
                                           ______ ________ _____


            name     code  description

            .FSSRC   0     Define new search list for frame (no license required)
            .FSDSL   1     Define new search list for any frame or system
            .FSDEF   2     Define new file structure
            .FSRDF   3     Redefine file structure
            .FSLOK   4     Lock file structure
            .FSREM   5     Remove file structure
            .FSULK   6     Test/Set UFD interlock
            .FSUCL   7     Clear UFD interlock
            .FSETS   10    Simulate hard errors
            .FSRRL   11    Read/reset log for 3330's



                                                Table 8-31b
                                                _____ _____
                                             STRUUO error codes
                                             ______ _____ _____


            name     code  description

            FSILF%   0     Illegal function code
            FSSNF%   1     Structure not found
            FSSSA%   2     Structure single access only
            FSILE%   3     Illegal list entry
            FSTME%   4     Too many entries in list
            FSUNA%   5     Unit not available
            FSPPN%   6     PPN doesn't match
            FSMCN%   7     Mount count greater then 1
            FSNPV%   10    No license
            FSFSA%   11    Structure already exists
            FSILL%   12    Bad list length
            FSUNC%   13    Unable to complete UUO
            FSNFS%   14    System full of structures
            FSNCS%   15    No free core
            FSUNF%   16    Illegal unit
            FSRSL%   17    File structure repeated in list


            8.14.2.4    SYSPHY: read physical unit names (CALLI +51)
                        _______ ____ ________ ____ _____ ______ ____

                    MOVE    ac, [start]
                    SYSPHY  ac,
                      error return
                    normal return

            If <start>  is 0, set  c(<ac>) to 0  if there are  no disk units,  or to  the SIXBIT
            physical name of the first unit in the system if there are, and skip-return.

            If <start> is nonzero, search the system for a disk unit whose name matches <start>.
            If none is found, error-return.  If the named disk unit is found, but it is the last
            one on the monitor's list, set c(<ac>) to 0 and skip-return; otherwise,  set c(<ac>)
            to the SIXBIT name of the next disk unit on the monitor's list, and skip-return.











                                                    8-31


            Disk I/O                                 8                          YAMM edition 2.1


            8.14.2.5    SYSSTR: read disk structure names (CALLI +46)
                        _______ ____ ____ _________ _____ ______ ____

                    MOVE    ac, [start]
                    SYSSTR  ac,
                      error return
                    normal return

            If <start> is 0, set c(<ac>) to 0 if there are no disk structures, or to  the SIXBIT
            physical name of the first structure in the system if there are, and skip-return.

            If <start> is  nonzero, search the  system for a  disk structure whose  name matches
            <start>.  If none is found, error-return.  If the named disk structure is found, but
            it  is the  last  one on  the  monitor's list,  set  c(<ac>) to  0  and skip-return;
            otherwise,  set  c(<ac>) to  the  SIXBIT name  of  the next  disk  structure  on the
            monitor's list, and skip-return.

            8.14.3    UGETF: read disk file position (op code 073)
                      ______ ____ ____ ____ ________ ___ ____ ____
            8.14.3    .CHUGF: read disk file position (CHANIO fn 10)
                      _______ ____ ____ ____ ________ _______ __ ___

                    UGETF   channel, addr
                    only return

                    MOVE    ac, [.CHUGF,,channel]
                    CHANIO  ac, addr
                    only return

            If no file is  selected on <channel>, set  c(<addr>) to -1; otherwise,  set c(<addr>
            left) to the current  file pointer position, in  blocks, and c(<addr> right)  to the
            current file size, in blocks.  Return.


            8.15    Validating and Flushing
                    __________ ___ ________

            8.15.1    .CHVRB: validate RIB (CHANIO fn 42)
                      _______ ________ ___ _______ __ ___

                    MOVE    AC, [.CHVRB,,channel]
                    CHANIO  AC,
                      error return  ; AC/ error code
                    normal return

            where <error code> is a code from Table 4-20

            If no file is selected on <channel>, take the error return; otherwise, wait  for the
            selected file's RIB to be written to disk, then skip-return.

            8.15.2    DSKCLR: initialize in-core file system data (CALLI -22)
                      _______ __________ _______ ____ ______ ____ ______ ____

                    DSKCLR  <mode>,
                     <parameter>
                     error return
                    normal return

            where <mode> is:
                    mode    name    action
                    0       DC.CLR  clear in-core file system info
                    1       DC.FPC  set Free-Page Count for all SATs,
                                    and clear "need DSKCLN" flag
                    2       DC.NDS  clear "need DSKCLN" flag

            and the <parameter> corresponding to each <mode> is:
            mode    parameter
            0       no <parameter>
            1       addr of AOBJN word of form
                         -count of args,,addr of first arg
            2       no <parameter>

            If the caller lacks Write Absolute (WA) license, take the normal return.

                                                    8-32


            June 27, 1984                            8                                  Disk I/O


            If <mode> is not 0,1, or 2, take the error return.

            If <mode>=0,

                If any of the in-core file system database is in use, take the error return.
                Otherwise clear it all and take the normal return.

            If <mode>=1,

                Check that <count>=the  number of SATs on  all units in the  DSKB structure.
                If not equal, take the error return.

                Set  the  Free Page  Count  entries for  all  SATs from  the  argument block
                starting at  <addr of first  arg>.  Clear the  "need DSKCLN" bit.   Take the
                normal return.

            If <mode>=2,

                Clear the "need DSKCLN" bit.  Take the normal return.


                                                Table 8-33 
                                                _____ ____ 
                                           DSK: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask































                                                    8-33


            Disk I/O                                 8                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    8-34


            June 27, 1984                            9                    Processor ID Mechanism


                                                 Section 9
                                                 _______ _
                                           Processor ID Mechanism
                                           _________ __ _________

                                             Table of Contents



            SubSection


            9.1      Purpose of PID's    9-1

            9.2      Definition of PID    9-1

            9.3      Issuing PID's    9-1

            9.4      Authority Conferred by a PID    9-2

            9.5      Executing with a PID    9-2

            9.6      Manipulating the PID    9-2
            9.6.1       PIDSET: Manipulate Process' PID (CALLI -122)    9-2

            9.7      PID Handling on ENTER and RENAME    9-3

            9.8      PID's and Storage Accounting    9-3










































                                                    9-i


                                                     9                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    9-ii


            June 27, 1984                            9                    Processor ID Mechanism





                                                 Section 9
                                                 _______ _
                                           Processor ID Mechanism
                                           _________ __ _________





            9.1    Purpose of PID's
                   _______ __ _____

            PID's extend  the basic  Tymshare file protection  mechanisms and  provide a  way of
            associating  the  charge  for  disk storage  with  the  processors  (programs) which
            manipulate that storage, rather than with the directory in which it  resides.  PID's
            may also be  used as validity-stamps  to ensure the  integrity of data.   PID's were
            developed to allow processors or groups of cooperating processors to implement their
            own file protection policies different from those offered by the monitor.


            9.2    Definition of PID
                   __________ __ ___

            A PID is a 36-bit quantity whose left  half is the UUN of some valid user  and whose
            right half is  an index number.  Under  normal circumstances, a user  can manipulate
            only those PID's that have his UUN in their left half; he can arbitrarily select the
            index in the right half.  This allows a user to allocate his own  PID's, eliminating
            the requirement that some central Tymshare authority do so.

            The  value 0,  when specified  in a  PID argument  or returned  as a  PID by  a UUO,
            represents the absence of a PID. No PID may be created whose left half (UUN part) is
            zero, except  by programs  having Write Absolute  (WA) or  Write File  (WF) license.
            These zero-UUN PID's are reserved for system use.

            A PID becomes  associated with a  processor (i.e., a program)  in much the  same way
            that license is associated with  the processor: some other processor  with authority
            to do so issues an ENTER or  RENAME UUO on <processor>.SAV (or .SHR, etc.)  with the
            new  PID  in  .RBPID,  word 40  of  the  extended  LOOKUP/ENTER/RENAME  block.  When
            <processor> is  later executed,  this PID  becomes associated  with the  process and
            gives it authority to access files with matching PID's in ways described on 9-2.


            9.3    Issuing PID's
                   _______ _____

            A processor is authorized to issue a PID if any of the following are true:
                1)  The PID is zero.  (A process can  clear the PID on any file to  which it
                    has at least append access);
                2)  The PID in .RBPID exactly matches the PID of the executing process;
                3)  The UUN-part of the PID exactly  matches the UUN-part of the AUN  of the
                    executing process;
                4)  The process has Write File (WF) license.  The PID can have any value.
            To issue a PID, a processor must have ENTER or RENAME access to the file.   To issue
            the PID (that is,  to place it on the  file) the processor must execute  an extended
            ENTER   or  RENAME,   placing   the  desired   PID   in  .RBPID   in   the  extended
            LOOKUP/ENTER/RENAME block.














                                                    9-1


            Processor ID Mechanism                   9                          YAMM edition 2.1


            9.4    Authority Conferred by a PID
                   _________ _________ __ _ ___

            A process executing with PID xx can successfully gain any level of access to  a file
            having PID xx, even if the directory in which this file resides is protected against
            LOOKUP's.  This  ability is  enabled by  setting bit  20 of  .RBCNT in  the extended
            LOOKUP/ENTER/RENAME block.  See 9-1.  In particular, this means that  the protection
            on the file can be changed to prevent the owner of the directory in which it resides
            from modifying or deleting the file.  For example, a user could run a processor with
            PID xx which could create  a file in the user's  directory, place PID xx on  it, set
            the protection to NO NO NO,  and implement its own protection scheme with  which the
            user could not interfere even though he was the owner of the directory.

            Note that no processor (with or without PID) can be guaranteed the ability to search
            an arbitrary directory for  files with matching PID;  all that a PID  guarantees the
            holder is the ability to gain access to a file with matching PID whose  location and
            name he knows.


            9.5    Executing with a PID
                   _________ ____ _ ___

            A PID  becomes associated  with a  program's execution  if the  file from  which the
            program was run has a PID.  As with license, the PID disappears if the  user meddles
            with the program (provides an argument to the START command, etc.).  If  the process
            issues a RUN or RUNSEG UUO, the old PID remains in effect until the new  file(s) are
            successfully set up; then the  PID is set to the PID  of the new file(s).  If,  in a
            RUN UUO, the low file PID differs from  the hiseg file PID, the new PID will  be set
            to zero.   A GETSEG UUO  will not affect  a process' PID.   The RUN, GET,  SAVE, and
            SSAVE operations will clear a process'  PID and saved PID (see 9-2) before  any file
            accesses  are done.   The  CLOSE, FINISH,  CORE  and START  <argument>  commands are
            considered meddling  and will  clear out  the PID  and saved  PID.  In  general, any
            command that would reset process license will also clear PID's.


            9.6    Manipulating the PID
                   ____________ ___ ___

            The PIDSET  UUO (CALLI -122,  pg. 9-2) allows a  process to  set,clear and  read the
            PID under  which it  is executing.   Whenever a  process with  non-zero PID  sets or
            clears the  PID, it  is first  saved.  This <saved  PID> can  later be  restored.  A
            process may set its PID  to 0, to the saved PID  (if any), or to any PID  whose left
            half (UUN-part) matches the right half (UUN-part) of the process' logged-in AUN.

            The purpose of allowing processors to clear and restore their PID's is to allow them
            to control selectively their special access privileges.  In particular,  a processor
            may wish to clear its PID before  any RUN, GET or SAVE operation to prevent  the PID
            authority from being used by these operations.

            9.6.1    PIDSET: Manipulate Process' PID (CALLI -122)
                     _______ __________ ________ ___ ______ _____

                    MOVE AC,[<pid>]
                    PIDSET AC,
                     error return   ;AC/ current PID
                    normal return

            If <pid>  is zero, or  current process  license includes Write  Absolute (WA)  or WF
            license, or the process AUN matches the left half of <pid>, or <pid> =  <saved PID>,
            then set process' PID to <pid>, set <saved PID> to previous PID if it  was non-zero,
            set AC to previous PID, and take the normal return.  Otherwise set AC to current PID
            and take the error return.










                                                    9-2


            June 27, 1984                            9                    Processor ID Mechanism


            9.7    PID Handling on ENTER and RENAME
                   ___ ________ __ _____ ___ ______

            For all RENAMEs and ENTERs, the old file PID is set to zero.  This forces processors
            to specify PID's directly, preventing inadvertent spread of the PID.  The new PID in
            .RBPID is checked; if it is zero or -1, the new file PID becomes zero.  If it is not
            zero or -1,  the new PID  in .RBPID must  pass the tests  described on 9-1.   If the
            tests fail,  the new file  PID becomes zero;  otherwise it is  set to  the requested
            value.

            If .RBPID is unspecified  because the count in an  extended ENTER or RENAME  is less
            than .RBPID or  because a short ENTER  or RENAME is done,  the PID argument  will be
            assumed to be zero.  This  means that any ENTER or  RENAME on a file will  result in
            that file's PID becoming zero unless .RBPID is specifically set to a non-zero value.


            9.8    PID's and Storage Accounting
                   _____ ___ _______ __________

            Bit 6  in .RBLIC for  a file will  be set  if and only  if the PID  for the  file is
            non-zero.  This  bit may  be examined  in the  UFD entry  for the  file to  find out
            whether the file has a PID without doing  a LOOKUP on the file.  Bit 6 in  .RBLIC of
            the UFD rib will also be set for any UFD which has special PID storage accounting.

            Files which have PID's are not charged according to the standard accounting policies
            but rather according to special  PID accounting schemes developed to meet  the needs
            of processors  using PID's.   Contact Marketing for  more information.   Please note
            that even though a file with a PID may not be charged according to  standard storage
            charging policies, its space is counted against the storage quota for  the directory
            in which it resides.








































                                                    9-3


            Processor ID Mechanism                   9                          YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    9-4


            June 27, 1984                            10                                 Port I/O


                                                 Section 10
                                                 _______ __
                                                  Port I/O
                                                  ____ ___

                                             Table of Contents



            SubSection


            10.1     Port Numbers and Device Names    10-1

            10.2     Command Ports    10-1
            10.2.1      Detaching    10-1
            10.2.2      Attaching    10-1
            10.2.3      Command versus User Level    10-2

            10.3     Auxiliary Ports    10-2
            10.3.1      Creating    10-2
            10.3.2      Slaving the Command Port    10-2
            10.3.3      Inquiring about Ports and their Statuses    10-2
            10.3.4      Zapping    10-2

            10.4     PTYs    10-3
            10.4.1      Creating PTYs    10-3
            10.4.2      Characteristics of PTYs    10-3
            10.4.3      Suppress-output-translation Bit    10-3
            10.4.4      PTY Terminal Charactersitics    10-3

            10.5     Reseting Ports    10-4

            10.6     Line Characteristic Word    10-4

            10.7     File Status Bits    10-4

            10.8     Port Operations    10-4
            10.8.1      AUXCAL: perform port i/o functions (op code 042)    10-5
            10.8.2      TTCALL: perform cmnd port i/o (op code 051)    10-9
            10.8.3      Buffered I/O    10-9

            10.9     Baud Rates    10-9

            10.10    Buffering and Backpressure    10-10
            10.10.1     Host No XON    10-10
            10.10.2     Remote XON    10-10
            10.10.3     Reverse XON    10-10
            10.10.4     Flushing Input    10-11
            10.10.5     Flushing Output    10-11

            10.11    Data Transmission Methods    10-11

            10.12    Character Handling    10-11
            10.12.1     Input    10-11
                           Case Mapping    10-11
                           Special Characters    10-11
                              Line Editing    10-11
                              Escape Character    10-12
                              Output Suppression    10-12
                              End Of File    10-13
                              Monitor Modes    10-13
                           Break Characters    10-13
                           Image State    10-14
                              Breaks    10-14
                              Image Break Character    10-15
            10.12.2     Echoing    10-15
                           Turning off Echo    10-15
                              Half-Duplex    10-15
                              No Echo    10-16
                                                    10-i


            Port I/O                                 10                         YAMM edition 2.1

            SubSection
                              Local Copy    10-16
                           Yellow and Orange Balls    10-16
                           Faking Input Wait    10-17
                           Special Characters    10-17
                              Backspace    10-17
                              Deleted Characters    10-17
                              Escape    10-17
            10.12.3     Output    10-17
                           Output Case Mapping    10-18
                           Image Characters    10-18
                           Line Width and Position    10-18
                           HT, VT, FF simulation    10-18
                           CR and LF delay    10-19
                              CR Delay Formula    10-19
                              LF Delay Formula    10-19
                           HT, VT, FF delays    10-19
                              HT Filler Cclass    10-20
                              VT and FF filler class    10-20
            10.12.4     Parity    10-20
            10.12.5     Data Transmission Modes    10-20
                           Katakana Data Mode    10-20
                           Paper Tape Mode    10-21
                           Port Buffered-I/O Modes    10-21

            10.13    Special Purpose Terminal Charactersitics    10-21
            10.13.1     Terminal Class    10-21
            10.13.2     Special Control-T Mode    10-21

            10.14    Block I/O    10-21
            10.14.1     Block I/O Buffer Format    10-22
            10.14.2     Block I/O Data Modes    10-22
            10.14.3     Interaction with Non-Block Input    10-22
            10.14.4     Interaction with Non-Block Output    10-23
            10.14.5     Block I/O Tutorial    10-23

            10.15    Port Creation,Moving,Deletion UUOs    10-23
            10.15.1     GETLIN: get command port name (CALLI +34)    10-23
            10.15.2     ATTACH: attach command port to frame (CALLI -6)    10-23
            10.15.3     RETACH: move port from frame to frame (CALLI -135)    10-24
            10.15.4     RLSLDB: release spare LDB (CALLI -142)    10-25
            10.15.5     CREAUX: create an aux circuit (CALLI -44)    10-25
            10.15.6     .AXSLV: slave command port (AUXCAL fn 43)    10-26
            10.15.7     ZAPCIR: zap an aux circuit (CALLI -45)    10-27
            10.15.8     .AXHNG: send hangup (AUXCAL fn 60)    10-27
            10.15.9     AUXRED: read aux circuit port numbers (CALLI -46)    10-27
            10.15.10    CREPTY: Create PTYs (CALLI -141)    10-27
            10.15.11    POLPRT: Poll Ports for Events (CALLI -115)    10-27
            10.15.12    .AXPSM: read port-status msg (AUXCAL fn 61)    10-29
            10.15.13    .AXNZP: r/s no zap on reset bit (AUXCAL fn 75)    10-29

            10.16    Port and Terminal Characteristics UUOs    10-29
            10.16.1     GETLCH: read line characteristics (TTCALL 6)    10-30
            10.16.2     SETLCH: set line characteristics (TTCALL 7)    10-30
            10.16.3     .AXTCN: r/s terminal charactertistics by number (AUXCAL fn 73)    10-31
            10.16.4     .AXTCP: read changed tc number,,value for a pty (AUXCAL fn 74)    10-31
            10.16.5     GETTMC: (obs.) get terminal characteristics (CALLI -16)    10-31
            10.16.5     SETTMC: (obsolete) no-op (CALLI -15)    10-31
            10.16.6     SETMOD: set cmnd port file status (CALLI -26)    10-32
            10.16.7     .AXSFS: set port file status bits (obsolete) (AUXCAL fn 32)    10-33
            10.16.7     .AXCFS: change port file status bits (AUXCAL fn 64)    10-33
            10.16.8     .AXCRD: r/s compute-CR-delay bit (AUXCAL fn 14)    10-34
            10.16.8     .AXIBR: r/s input baud rate (AUXCAL fn 15)    10-34
            10.16.8     .AXOBR: r/s output baud rate (AUXCAL fn 16)    10-34
            10.16.8     .AXEP: r/s even-parity bit (AUXCAL fn 17)    10-34
            10.16.8     .AXHD: r/s half-duplex bit (AUXCAL fn 20)    10-34
            10.16.8     .AXPA: r/s parameter A (AUXCAL fn 21)    10-34
            10.16.8     .AXPB: r/s parameter B (AUXCAL fn 22)    10-34
            10.16.8     .AXPC: r/s parameter C (AUXCAL fn 23)    10-34
                                                   10-ii


            June 27, 1984                            10                                 Port I/O

            SubSection
            10.16.8     .AXHNX: r/s host-no-XON bit (AUXCAL fn 24)    10-34
            10.16.8     .AXNTE: r/s no HT/VT/FF bit (AUXCAL fn 25)    10-34
            10.16.8     .AXTBK: r/s tabs-as-breaks bit (AUXCAL fn 26)    10-34
            10.16.8     .AXWID: r/s line width (AUXCAL fn 27)    10-34
            10.16.8     .AXFC1: r/s filler class 1 (AUXCAL fn 30)    10-34
            10.16.8     .AXFC2: r/s filler class 2 (AUXCAL fn 31)    10-34
            10.16.8     .AXRMX: r/s remote-XON bit (AUXCAL fn 53)    10-34
            10.16.8     .AXRBS: r/s remote-BS-echo bit (AUXCAL fn 54)    10-34
            10.16.8     .AXRVX: r/s reverse-XON bit (AUXCAL fn 55)    10-34
            10.16.8     .AXTYP: r/s terminal type (AUXCAL fn 56)    10-34
            10.16.8     .AXBS: r/s BS-for-char-delete bit (AUXCAL fn 57)    10-34
            10.16.8     .AXERA: r/s Erase-for-char-delete bit (AUXCAL fn 62)    10-34
            10.16.8     .AXEDE: r/s force deferred-echo bit (AUXCAL fn 63)    10-34
            10.16.8     .AXLCO: r/s Lower-case-output bit (AUXCAL fn 65)    10-34
            10.16.8     .AXBBP: r/s backspace break/punctuation bit (AUXCAL fn 66)    10-34
            10.16.8     .AXSOX: r/s suppress output translation bit (AUXCAL fn 71)    10-34
            10.16.8     .AXRUB: r/s ctrl H/rubout bit (AUXCAL fn 77)    10-34
            10.16.8     .AXCLR: r/s special ctrl T mode (AUXCAL fn 101)    10-34
            10.16.9     .AXTTP: r/s terminal class (AUXCAL fn 100)    10-34

            10.17    Echo,Break,Backpressure UUOs    10-35
            10.17.1     .AXS8B: set image break char (AUXCAL fn 13)    10-35
            10.17.2     .AXSYB: send yellow ball (AUXCAL fn 12)    10-35
            10.17.3     .AXSOB: send orange ball (AUXCAL fn 70)    10-35
            10.17.4     LEVDEF: leave deferred echo mode (CALLI -30)    10-35
            10.17.4     .AXLDE: leave deferred echo mode (AUXCAL fn 11)    10-35
            10.17.5     CLRBFI: clear input buffer (TTCALL 11)    10-35
            10.17.5     .AXCBI: clear input buffer (AUXCAL fn 6)    10-35
            10.17.6     CLRBFO: clear output buffer (TTCALL 12)    10-36
            10.17.6     .AXCBO: clear output buffer (AUXCAL fn 7)    10-36

            10.18    Port Input UUOs    10-36
            10.18.1     INCHRW: input char [wait/bka] (TTCALL 0)    10-36
            10.18.2     .AXICW: input char [wait/bka] (AUXCAL fn 44)    10-37
            10.18.3     INCHRS: input char [skip/bka] (TTCALL 2)    10-37
            10.18.4     .AXICS: input char [skip/bka] (AUXCAL fn 45)    10-37
            10.18.5     INCHWL: input char [wait] (TTCALL 4)    10-38
            10.18.6     .AXIWL: input char [wait] (AUXCAL fn 46)    10-38
            10.18.7     INCHSL: input char [skip] (TTCALL 5)    10-38
            10.18.8     .AXISL: input char [skip] (AUXCAL fn 47)    10-39
            10.18.9     Image State    10-39
                           .AXI8C: input char [wait/bka/img] (AUXCAL fn 0)    10-39
                           .AXI8S: input char [skip/bka/img] (AUXCAL fn 1)    10-39
                           .AXI8B: input char [wait/img] (AUXCAL fn 2)    10-40
            10.18.10    Testing    10-40
            10.18.11    Faking Input    10-40
            10.18.12    Miscellaneous Command Port UUOs    10-40
            10.18.13    SKPINC: skip if char (TTCALL 13)    10-41
            10.18.13    SKPINL: skip if break char (TTCALL 14)    10-41
            10.18.13    .AXSIC: skip if char (AUXCAL fn 10)    10-41
            10.18.13    .AXSIL: skip if break char (AUXCAL fn 50)    10-41
            10.18.14    .AXSI: simulate input (AUXCAL fn 33)    10-41
            10.18.15    REDNXT: peek at input (CALLI -14)    10-41
            10.18.16    WAITCH: wait for input char (CALLI -13)    10-41
            10.18.17    RESCAN: rescan command line (TTCALL 10)    10-42
            10.18.18    .AXFRS: force rescan string [CNT,PTR] (AUXCAL fn 72)    10-42
            10.18.19    DDTIN: DDT-mode input (CALLI +1)    10-42
            10.18.20    CONT: Put port in user level (CALLI -125)    10-43

            10.19    Output UUOs    10-43
            10.19.1     Single Character Output    10-43
                           OUTCHR: output char [CMD] (TTCALL 1)    10-43
                           OUTCHI: output char [CMD/IMM] (TTCALL 16)    10-44
                           .AXOCI: output char [IMM] (AUXCAL fn 51)    10-44
                           IONEOU: output char [CMD/IMG] (TTCALL 15)    10-44
                           .AXO8: output char [IMG] (AUXCAL fn 3)    10-44
                           .AXO8I: output char [IMG/IMM] (AUXCAL fn 4)    10-45
            10.19.2     String Output    10-45
                                                   10-iii


            Port I/O                                 10                         YAMM edition 2.1

            SubSection
                           OUTSTR: output string [STR/CMD] (TTCALL 3)    10-45
                           OUTPTR: output string [PTR/CMD] (TTCALL 17)    10-46
                           .AXPTR: output string [PTR] (AUXCAL fn 5)    10-46
                           .AXOST: output string (AUXCAL fn 52)    10-47
                           .AXOPC: output string [STR] (AUXCAL fn 67)    10-47
                           .AXOSF: output string, never wait [STR] (AUXCAL fn 76)    10-47
                           DDTOUT: DDT-mode output (CALLI +3)    10-48

            10.20    Port Block I/O UUOs    10-48
            10.20.1     .AXEBM: enter block i/o mode (AUXCAL fn 34)    10-48
            10.20.2     .AXLBM: leave block i/o mode (AUXCAL fn 42)    10-48
            10.20.3     .AXIBW: input block and wait (AUXCAL fn 35)    10-48
            10.20.4     .AXIBS: input block and skip (AUXCAL fn 36)    10-49
            10.20.5     .AXTBI: terminate block input (AUXCAL fn 40)    10-49
            10.20.6     .AXOB: block output (AUXCAL fn 37)    10-49
            10.20.7     .AXTBO: terminate block output (AUXCAL fn 41)    10-49


            Table

            10-6     AUXCALs by function    10-6
            10-8     AUXCALs by number    10-8
            10-9     TTCALL functions by number    10-9
            10-25    RETACH error codes    10-25
            10-26    CREAUX Error Codes    10-26
            10-29    Port Event-Status Bits    10-29
            10-30    Line Characteristics Word    10-30
            10-32    Terminal Characteristics    10-32
            10-33    TTY: File Status Bits    10-33
            10-33b   Monitor Modes & Special Characters    10-33
            10-37    Port Character Input Calls    10-37
            10-43    Port Character Output Calls    10-43
            10-46    Port String Output Calls    10-46



































                                                   10-iv


            June 27, 1984                            10                                 Port I/O





                                                 Section 10
                                                 _______ __
                                                  Port I/O
                                                  ____ ___





            10.1    Port Numbers and Device Names
                    ____ _______ ___ ______ _____

            Each TYMNET port is given a "port number" by the monitor.  That port number  is used
            directly by some functions, notably AUXCAL,  the UUO through which most port  i/o is
            done.  Each port also has a normal device name, of the form

                    TTY<port number>

            where the port number is expressed in octal.


            10.2    Command Ports
                    _______ _____

            Each frame  normally has a  "command port".  This  port is referred  to by  the UUOs
            taking port numbers as port -1, and by the UUOs taking device names as device TTY.

            10.2.1    Detaching
                      _________

            A frame can "detach" itself from its command port if the user types the command

                    DETACH

            or if a program executes the ATTACH UUO (CALLI -6, pg. 10-23).

            Most  i/o operations,  when directed  towards the  command port  of a  frame running
            detached will just hang until a real port is attached to the frame again.

            10.2.2    Attaching
                      _________

            A user who is logged-in, and  who has another frame running detached on  the system,
            can attach his  current frame's command  port to that  frame (detaching it  from the
            current frame) by typing the command

                    ATTACH <frame number>

            If the  detached frame  has any license  set, the  user must have  at least  as much
            license on his current frame in order to attach to the detached frame.

            A program can  likewise cause its  frame's command port to  be detached from  it and
            attached to  some other  frame by  executing the  ATTACH UUO  (CALLI -6, pg. 10-23).
            The RETACH UUO (CALLI -135, pg. 10-24) allows ports to be moved from frame  to frame
            in a completely general way by a process with sufficient access rights.
















                                                    10-1


            Port I/O                                 10                         YAMM edition 2.1


            10.2.3    Command versus User Level
                      _______ ______ ____ _____

            Any terminal input is processed either by

                    1. the monitor's command processor
                    2. a user program

            When input is going  to the monitor as  in (1), the port  is said to be  in "command
            level"; when situation (2) prevails, the port is in "user level".

            A port can be  in command level even though  a program is running, and  even perhaps
            waiting for input.  This situation can be caused by the CSTART, CCONTINUE and ATTACH
            commands.

            In the ordinary course  of events, a START, CON,  or RUN command puts the  port into
            user  level, and  it  remains in  user level  (causing  the program  to  receive any
            characters) until any of the following happens:

                    1. the program does an EXIT UUO
                    2. the program encounters an error condition which makes
                            it unrunnable (ILL MEM REF, ILL INST, etc.)
                    3. the port receives an escape character while the program
                            is in input wait
                    4. the port receives two consecutive escapes


            10.3    Auxiliary Ports
                    _________ _____

            10.3.1    Creating
                      ________

            To create an aux circuit, a program executes the CREAUX UUO (CALLI -44, pg. 10-25).

            CREAUX returns its error  codes in <ac> left,  and the supervisor's error  codes (if
            any) in <ac> right. The CREAUX error codes are shown in Table 10-26 .   Aux circuits
            are always in image state; see 10-14 for more discussion of this attribute.

            10.3.2    Slaving the Command Port
                      _______ ___ _______ ____

            The  .AXSLV  UUO  (AUXCAL fn 43,  pg. 10-26)  works  very  much  like  a  CREAUX UUO
            (CALLI -44,  pg. 10-25), but  instead of  creating a  new circuit,  it  detaches the
            current frame's command port and makes it available as if it were an auxiliary port.

            Slaved command ports differ in behavior from auxiliary circuits in that they are not
            always in deferred echo mode and are not always in image state.

            10.3.3    Inquiring about Ports and their Statuses
                      _________ _____ _____ ___ _____ ________

            A program can obtain the port numbers of all the aux circuits the  process currently
            owns  by  executing  the  AUXRED  UUO  (CALLI -46,  pg. 10-27).   Using  POLPRT  UUO
            (CALLI -115, pg. 10-27) a program can find out what, if any, significant events have
            happened on its ports since they were last polled.

            10.3.4    Zapping
                      _______

            A program can zap  an aux port by  executing the ZAPCIR UUO  (CALLI -45, pg. 10-27).
            The no-zap bit can be read or set by .AXNZP UUO (AUXCAL fn 75, pg. 10-29).












                                                    10-2


            June 27, 1984                            10                                 Port I/O


            10.4    PTYs
                    ____

            10.4.1    Creating PTYs
                      ________ ____

            PTYs (pseudo teletypes) are somewhat  like internal aux circuits.  PTYs  always come
            in pairs.  To get a pair of PTYs, execute the CREPTY UUO (CALLI -141, pg. 10-27).

            Normally one of the slave ports returned will be attached to some other frame (using
            the RETACH UUO (CALLI -135, pg. 10-24)) as its command port.

            Unlike aux circuits,  PTYs are symmetrical.   In order to get  the effect of  an aux
            circuit where the "near" end (the end obtained from CREAUX rather than the  end that
            is logged in at the specified host)  is always in image state and is  initialized to
            not echo,  the data  mode of the  originating end  should be set  to '214  (no echo,
            binary).

            10.4.2    Characteristics of PTYs
                      _______________ __ ____

            A circuit zap on either  PTY of the pair will  free up both PTYs.  The  opposite end
            will get a circuit-zapped interrupt.

            Yellow balls and character gobblers pass between PTYs exactly as they  would between
            ends of an aux circuit.

            PTYs always apply backpressure when they are overloaded, regardless of the data mode
            set.   They  wil never  send  XONs  or XOFFS  or  bells on  their  own.   The TYMNET
            reverse-XON parameter is not simulated.  There is no state in which sending  an XOFF
            to a PTY will backpressure it.  In the unlikely case that a PTY pair lost characters
            the sender  would receive  an "output  characters lost"  interrupt and  the intended
            recipient an "input characters lost" interrupt.

            Block i/o between PTYs will be extremely  fast if both ends are doing block  i/o and
            using the same buffer sizes.

            10.4.3    Suppress-output-translation Bit
                      ___________________________ ___

            A  program that  runs another  program in  a separate  frame attached  to a  PTY and
            records its  output in  a file,  typically does not  want the  monitor to  alter the
            output in such ways as expanding HT's into spaces, regardless of what the controlled
            frame  has  for terminal  characteristics.   The  "suppress-output-translation" bit,
            .AXSOX UUO (AUXCAL fn 71, pg. 10-34), is used for this purpose.  The port  number of
            one end is specified to control translation of the other end's output.

            10.4.4    PTY Terminal Charactersitics
                      ___ ________ _______________

            The terminal characteristics of a  PTY (including all of the  TYMNET characterstics,
            however inappropriate) are always reflected  by the monitor.  If parameter A  is set
            to 6, it will then be read back as 6.
            The TINASS interrupt, .IATTC (terminal characteristics changed, cause 13)

            goes  off  whenever   the  "other  end"  changes   one  or  more  of   its  terminal
            characteristics (the  corresponding POLPRT bit  is LXRTCC, mask  = '400).   For more
            information  on   TINASS  interrupt  see   TINASS  UUO  (CALLI -42,   pg. 16-5)  and
            Table 16-4 ,   on    POLPRT   see   POLPRT    UUO   (CALLI -115,    pg. 10-27)   and
            Table POLPRT}.

            The recipient of an .IATCC interrupt can use .AXTCP UUO (AUXCAL fn 74, pg. 10-31) to
            read the "next" unread changed terminal characteristic.

            A transparent program which  stands between a controlled  frame and a real  TTY will
            want to  set the "suppress-output-translations"  bit for the  PTY through  which the
            frame  is  controlled, and  then  use the  .IATCC/.AXTCH  mechanism to  pass  on the
            controlled frame's terminal characteristics settings to the real TTY.

            Auxcal  function .AXTCN  UUO (AUXCAL fn 73,  pg. 10-31) reads  and/or  sets terminal
            characteristics by number.


                                                    10-3


            Port I/O                                 10                         YAMM edition 2.1


            10.5    Reseting Ports
                    ________ _____

            The RESET UUO 5-11 has the following effect on a frame's ports:

                Clear the  break-on-all state, and  IO.BK2 and IO.FCS  for the  command port
                (even if the frame is running detached).

                If the  frame is not  detached, clear block  i/o mode if  it is set  for the
                command  port,  and clear  the  hardware-horizontal-tabs  and tabs-as-breaks
                bits.

                Zap every  aux circuit  belonging to  the frame  except those  whose CREAUXs
                specified CX.NZP.


            10.6    Line Characteristic Word
                    ____ ______________ ____

            The  line  characteristics  word  for  a port  can  be  read  with  then  GETLCH UUO
            (TTCALL 6,  pg. 10-30)  and set  with  the SETLCH  UUO  (TTCALL 7,  pg. 10-30).  Its
            format is described in Table 10-30 .


            10.7    File Status Bits
                    ____ ______ ____

            Some  of a  port's characteristics  are  determined by  its file  status  bits.  The
            device-dependent bits for ports are shown in Table 10-33 .

            If  a  port has  been  INIT'ed, the  file  status bits  can  be read  and  set using
            GETSTS/SETSTS/STATZ/STATO in the normal way.

            The bits can, in addition, be read from the .GTMOD GETTAB table (see 18-4).

            To set the file status bits for the command port, a program executes the  SETMOD UUO
            (CALLI -26, pg. 10-32).

            To set the file status bits for  any port owner by the current frame, a  program can
            execute the .AXSFS UUO (AUXCAL fn 32, pg. 10-33).


            10.8    Port Operations
                    ____ __________

            Most port operations are done with the AUXCAL UUO (op code 042, pg. 10-5)  or TTCALL
            UUO  (op code 051,  pg. 10-9).    AUXCAL  does  some  preliminary   checking  before
            performing its function code.

            Most simple operations on a command port are done using TTCALL, with the  <ac> field
            of the TTCALL  specifying the function, and  effective address field  specifying the
            argument, if any.

            While AUXCAL is  the more general of  the two UUO's, it  has the property  that many
            AUXCAL  output functions  are NO-OPs  if directed  at a  non-existent  port.  TTCALL
            output issued by a  detached frame will cause the  frame to go into  terminal output
            wait until  a command  port re-appears.  AUXCAL  output by  the same  detached frame
            would simply be lost.  TTCALL should be used for command port I/O.














                                                    10-4


            June 27, 1984                            10                                 Port I/O


            10.8.1    AUXCAL: perform port i/o functions (op code 042)
                      _______ _______ ____ ___ _________ ___ ____ ____

                    MOVE    ac, [port,,function]
                    AUXCAL  ac, addr

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not  belong to the frame, take the non-skip  return.  On
            input calls, the non-skip return is  an error or no-data return; on  numerous output
            calls,  the non-skip  return is  the only  return, so  that if  no port  exists, the
            function becomes  a no-op.   If a  job becomes  detached after  an auxcal  has begun
            execution, error return.

            Perform  the specified  function.  See  Table 10-6  and  Table 10-8  for  a  list of
            AUXCAL functions.



















































                                                    10-5


            Port I/O                                 10                         YAMM edition 2.1


                                                Table 10-6 
                                                _____ ____ 
                                            AUXCALs by function
                                            _______ __ ________


            Function  Name     Description

            Char input calls

              fn 0    .AXI8C   input char [wait/bka/img] (10-39)
              fn 1    .AXI8S   input char [skip/bka/img] (10-39)
              fn 2    .AXI8B   input char [wait/img] (10-40)
              fn 10   .AXSIC   skip if char (10-41)
              fn 44   .AXICW   input char [wait/bka] (10-37)
              fn 45   .AXICS   input char [skip/bka] (10-37)
              fn 46   .AXIWL   input char [wait] (10-38)
              fn 47   .AXISL   input char [skip] (10-39)
              fn 50   .AXSIL   skip if break char (10-41)


            Char output calls

              fn 3    .AXO8    output char [IMG] (10-44)
              fn 4    .AXO8I   output char [IMG/IMM] (10-45)
              fn 51   .AXOCI   output char [IMM] (10-44)


            String output calls

              fn 5    .AXPTR   output string [PTR] (10-46)
              fn 52   .AXOST   output string (10-47)
              fn 67   .AXOPC   output from pointer w/count [STR] (10-47)
              fn 76   .AXOSF   output string, never wait [STR] (10-47)


            Block I/O calls

              fn 34   .AXEBM   enter block i/o mode (10-48)
              fn 35   .AXIBW   input block and wait (10-48)
              fn 36   .AXIBS   input block and skip (10-49)
              fn 37   .AXOB    block output (10-49)
              fn 40   .AXTBI   terminate block input (10-49)
              fn 41   .AXTBO   terminate block output (10-49)
              fn 42   .AXLBM   leave block i/o mode (10-48)


            Parameter calls

              fn 14   .AXCRD   r/s compute-CR-delay bit (10-34)
              fn 15   .AXIBR   r/s input baud rate (10-34)
              fn 16   .AXOBR   r/s output baud rate (10-34)
              fn 17   .AXEP    r/s even-parity bit (10-34)
              fn 20   .AXHD    r/s half-duplex bit (10-34)
              fn 21   .AXPA    r/s parameter A (10-34)
              fn 22   .AXPB    r/s parameter B (10-34)
              fn 23   .AXPC    r/s parameter C (10-34)
              fn 24   .AXHNX   r/s host-no-XON bit (10-34)
              fn 25   .AXNTE   r/s no-tab-echo bit (10-34)
              fn 26   .AXTBK   r/s tabs-as-breaks bit (10-34)
              fn 27   .AXWID   r/s line width (10-34)
              fn 30   .AXFC1   r/s filler class 1 (10-34)
              fn 31   .AXFC2   r/s filler class 2 (10-34)
              fn 32   .AXSFS   set file status (replaced by fn 64) (10-33)
              fn 53   .AXRMX   r/s remote-XON bit (10-34)
              fn 54   .AXRBS   r/s remote-BS-echo bit (10-34)
              fn 55   .AXRVX   r/s reverse-XON bit (10-34)
              fn 56   .AXTYP   r/s terminal type (10-34)
              fn 57   .AXBS    r/s BS-for-char-delete bit (10-34)
              fn 62   .AXERA   r/s Erase-for-char-delete bit (10-34)
                                                    10-6


            June 27, 1984                            10                                 Port I/O


              fn 63   .AXEDE   r/s force deferred-echo bit (10-34)
              fn 64   .AXCFS   change port file status (10-33)
              fn 65   .AXLCO   r/s Lower-case-output bit (10-34)
              fn 66   .AXBBP   r/s backspace break/punctuation bit (10-34)
              fn 71   .AXSOX   r/s suppress output translation bit (10-34)
              fn 73   .AXTCN   r/s terminal characteristics by number (10-31)
              fn 75   .AXNZP   r/s no zap on reset bit (10-29)
              fn 77   .AXRUB   r/s ctrl H=rubout (10-34)
              fn 100  .AXTTP   r/s terminal class (10-34)
              fn 101  .AXCLR   r/s special ctrl T mode (10-34)


            Miscellaneous calls

              fn 6    .AXCBI   clear input buffer (10-35)
              fn 7    .AXCBO   clear output buffer (10-36)
              fn 11   .AXLDE   leave deferred echo mode (10-35)
              fn 12   .AXSYB   send yellow ball (10-35)
              fn 13   .AXS8B   set image break char (10-35)
              fn 33   .AXSI    simulate input (10-41)
              fn 43   .AXSLV   slave command port (10-26)
              fn 60   .AXHNG   send hangup (10-27)
              fn 61   .AXPSM   read port status msg (10-29)
              fn 70   .AXSOB   send orange ball (10-35)
              fn 72   .AXFRS   force rescan string [STR] (10-42)
              fn 74   .AXTCP   read changed TC number,,value for a pty (10-31)










































                                                    10-7


            Port I/O                                 10                         YAMM edition 2.1


                                                Table 10-8 
                                                _____ ____ 
                                             AUXCALs by number
                                             _______ __ ______


            Function  Name     Description

              fn 0    .AXI8C   input char [wait/bka/img] (10-39)
              fn 1    .AXI8S   input char [skip/bka/img] (10-39)
              fn 2    .AXI8B   input char [wait/img] (10-40)
              fn 3    .AXO8    output char [IMG] (10-44)
              fn 4    .AXO8I   output char [IMG/IMM] (10-45)
              fn 5    .AXPTR   output string [PTR] (10-46)
              fn 6    .AXCBI   clear input buffer (10-35)
              fn 7    .AXCBO   clear output buffer (10-36)
              fn 10   .AXSIC   skip if char (10-41)
              fn 11   .AXLDE   leave deferred echo mode (10-35)
              fn 12   .AXSYB   send yellow ball (10-35)
              fn 13   .AXS8B   set image break char (10-35)
              fn 14   .AXCRD   r/s compute-CR-delay bit (10-34)
              fn 15   .AXIBR   r/s input baud rate (10-34)
              fn 16   .AXOBR   r/s output baud rate (10-34)
              fn 17   .AXEP    r/s even-parity bit (10-34)
              fn 20   .AXHD    r/s half-duplex bit (10-34)
              fn 21   .AXPA    r/s parameter A (10-34)
              fn 22   .AXPB    r/s parameter B (10-34)
              fn 23   .AXPC    r/s parameter C (10-34)
              fn 24   .AXHNX   r/s host-no-XON bit (10-34)
              fn 25   .AXNTE   r/s no-tab-echo bit (10-34)
              fn 26   .AXTBK   r/s tabs-as-breaks bit (10-34)
              fn 27   .AXWID   r/s line width (10-34)
              fn 30   .AXFC1   r/s filler class 1 (10-34)
              fn 31   .AXFC2   r/s filler class 2 (10-34)
              fn 32   .AXSFS   set file status (replaced by fn 64) (10-33)
              fn 33   .AXSI    simulate input (10-41)
              fn 34   .AXEBM   enter block i/o mode (10-48)
              fn 35   .AXIBW   input block and wait (10-48)
              fn 36   .AXIBS   input block and skip (10-49)
              fn 37   .AXOB    block output (10-49)
              fn 40   .AXTBI   terminate block input (10-49)
              fn 41   .AXTBO   terminate block output (10-49)
              fn 42   .AXLBM   leave block i/o mode (10-48)
              fn 43   .AXSLV   slave command port (10-26)
              fn 44   .AXICW   input char [wait/bka] (10-37)
              fn 45   .AXICS   input char [skip/bka] (10-37)
              fn 46   .AXIWL   input char [wait] (10-38)
              fn 47   .AXISL   input char [skip] (10-39)
              fn 50   .AXSIL   skip if break char (10-41)
              fn 51   .AXOCI   output char [IMM] (10-44)
              fn 52   .AXOST   output string (10-47)
              fn 53   .AXRMX   r/s remote-XON bit (10-34)
              fn 54   .AXRBS   r/s remote-BS-echo bit (10-34)
              fn 55   .AXRVX   r/s reverse-XON bit (10-34)
              fn 56   .AXTYP   r/s terminal type (10-34)
              fn 57   .AXBS    r/s BS-for-char-delete bit (10-34)
              fn 60   .AXHNG   send hangup (10-27)
              fn 61   .AXPSM   read port status msg (10-29)
              fn 62   .AXERA   r/s Erase-for-char-delete bit (10-34)
              fn 63   .AXEDE   r/s force deferred-echo bit (10-34)
              fn 64   .AXCFS   change port file status (10-33)
              fn 65   .AXLCO   r/s Lower-case-output bit (10-34)
              fn 66   .AXBBP   r/s backspace break/punctuation bit (10-34)
              fn 67   .AXOPC   output from pointer w/count [STR] (10-47)
              fn 70   .AXSOB   send orange ball (10-35)
              fn 71   .AXSOX   r/s suppress output translation bit (10-34)
              fn 72   .AXFRS   force rescan string [STR] (10-42)
              fn 73   .AXTCN   r/s terminal characteristics by number (10-31)
              fn 74   .AXTCP   read changed TC number,,value for a pty (10-31)
              fn 75   .AXNZP   r/s no zap on reset bit (10-29)
                                                    10-8


            June 27, 1984                            10                                 Port I/O


              fn 76   .AXOSF   output string, never wait [STR] (10-47)
              fn 77   .AXRUB   r/s ctrl H=rubout (10-34)
              fn 100  .AXTTP   r/s terminal class (10-34)
              fn 101  .AXCLR   r/s special ctrl T mode (10-34)


            10.8.2    TTCALL: perform cmnd port i/o (op code 051)
                      _______ _______ ____ ____ ___ ___ ____ ____

                    TTCALL  function, addr
                      or
                    functionname,   addr

            where <function> or <functionname> is taken from Table 10-9 .


                                                Table 10-9 
                                                _____ ____ 
                                         TTCALL functions by number
                                         ______ _________ __ ______


            symbol   code  description
            INCHRW   0     input character, wait
            OUTCHR   1     output one character
            INCHRS   2     input character, skip
            OUTSTR   3     output asciz string
            INCHWL   4     input character, wait, line mode
            INCHSL   5     input character, skip, line mode
            GETLCH   6     get line characteristics
            SETLCH   7     set line characteristics
            RESCAN   10    rescan command line
            CLRBFI   11    clear input buffer
            CLRBFO   12    clear output buffer
            SKPINC   13    skip if character present
            SKPINL   14    skip if break character present
            IONEOU   15    output one character, image mode
            OUTCHI   16    output one character, immediate
            OUTPTR   17    output asciz string via bytepointer


            10.8.3    Buffered I/O
                      ________ ___

            Buffered port i/o can be  performed in ASCII, ASCII line (=ASCII),  Katakana, Image,
            Image Binary, or Binary mode.

            In ASCII mode, the byte size is 7 bits; in Katakana it is 9 bits; in Image and Image
            Binary it is 8 bits, and in  Binary it is 36 bits.  (In Binary mode,  the characters
            are stored one to a word, right justified in the user's buffer).

            The standard buffer size is 23 (decimal) words (20 data + 3 header).


            10.9    Baud Rates
                    ____ _____

            A program can read or set a port's input and output baud rates using the  .AXIBR UUO
            (AUXCAL fn 15,  pg. 10-34) and  .AXOBR UUO  (AUXCAL fn 16, pg. 10-34).   The numbers
            passed to and returned by the AUXCALs  are not the actual baud rates but a  code for
            the baud rate:












                                                    10-9


            Port I/O                                 10                         YAMM edition 2.1



                code baud

                0    110 (or Aux Circuit)
                1    150
                2    300
                3    400
                4    600
                5    1200
                6    300 (IBM 3767)
                7    150 (IBM 2741)
                8    300 iocps
                9    1200 iocps
                10   2400 240 cps
                11   4800 480 cps
                12   9600 960 cps
                13   50 BAUDOT
                14   75 BAUDOT
                15   75 ASCII


            10.10    Buffering and Backpressure
                     _________ ___ ____________

            The  monitor maintains  an input  and an  output buffer  for each  port,  and TYMNET
            maintains buffers in both directions as  well.  When buffers fill up, there  are two
            mechanisms for stopping the flow of characters:
                1)  Cassette and  paper-tape-reading terminals can  usually be made  to stop
                    transmitting characters by sending  them an XOFF, and will  restart when
                    sent an XON.
                2)  Hosts will stop  outputting when backpressure is  applied to a  line and
                    will resume when it is relieved.
            When the monitor's input buffer becomes full, it will normally apply backpressure if
            the port's data mode is image, image binary, or binary, or send an XOFF otherwise.

            10.10.1    Host No XON
                       ____ __ ___

            The sending of  XOFFs and XONs can  be inhibited by setting  the "no host  XON" bit,
            using the .AXHNX UUO (AUXCAL fn 24, pg. 10-34).

            10.10.2    Remote XON
                       ______ ___

            The TYMNET remote can be instructed to send the terminal XOFFs when  backpressure is
            applied to  a line and  XONs when it  is released by  setting the "remote  XON" bit,
            using the .AXRMX UUO (AUXCAL fn 53, pg. 10-34).

            10.10.3    Reverse XON
                       _______ ___

            TYMNET can be instructed to apply and release backpressure on a line when  XOFFs and
            XONs (respectively) are typed at a terminal by setting the "reverse XON"  bit, using
            the .AXRVX UUO (AUXCAL fn 55, pg. 10-34).  This is especially useful  for high-speed
            display terminals, where it provide  a means for stopping output  immediately before
            it scrolls off the screen.
















                                                   10-10


            June 27, 1984                            10                                 Port I/O


            10.10.4    Flushing Input
                       ________ _____

            To clear the monitor's input buffer for a line, and release backpressure (if  it has
            been applied)  or send an  XON (if an  XOFF has been  sent), a program  executes the
            CLRBFI UUO (TTCALL 11, pg. 10-35) or .AXCBI UUO (AUXCAL fn 6, pg. 10-35).

            10.10.5    Flushing Output
                       ________ ______

            To clear the monitor's output buffers and send a character gobbler to TYMNET (eating
            all the output characters between the  process and the other end of the  circuit), a
            program executes the CLRBFO  UUO (TTCALL 12, pg. 10-36) or .AXCBO  UUO (AUXCAL fn 7,
            pg. 10-36).


            10.11    Data Transmission Methods
                     ____ ____________ _______

            Ports can transmit characters by either of two methods:

                    character-by-character (normal) mode (see 10-11)
                    Block i/o mode (see 10-21)

            All ports are in character-by-character mode unless specifically placed in block i/o
            mode by  the appropriate  AUXCAL.  In  block i/o mode,  whole buffers  of up  to 400
            characters are transferred to/from the base in one operation, whereas in normal mode
            the host and base  handle each character to  pass it across their  interface.  Block
            i/o can realize significant performance improvements and cost reductions.


            10.12    Character Handling
                     _________ ________

            10.12.1    Input
                       _____

            10.12.1.1    Case Mapping
                         ____ _______

            Normally,  the  monitor  maps  all  non-image-state  lowercase  characters  to their
            uppercase equivalents on input:

                    `       mapped to    @
                    a-z     mapped to    A-Z
                    {       mapped to    [
                    |       mapped to    \
                    }       mapped to    ESC
                    tilde   mapped to    ESC

            This action can be disabled by setting LC.NCM in the line characteristics  word (see
            Table 10-30 ).

            10.12.1.2    Special Characters
                         _______ __________

            10.12.1.2.1    Line Editing
                           ____ _______

            The monitor provides a line-delete and a character-delete character for line editing
            during terminal input.   The actual characters recognized  by the monitor  depend on
            the monitor mode as described on 10-13.

            Backspace (^H)  can be  defined to  be an  additional character-delete  character by
            using .AXRUB UUO (AUXCAL fn 77,  pg. 10-34).  It also can  be set or reset  by using
            the command

                    TTY [NO] BSD

            The character-delete character deletes characters,  one at a time, back to  (but not
            including) the most  recently-typed break character or  until all the  characters in
            the input buffer have been deleted.

            The line-delete  character has the  same effect as  infinitely-many character-delete
            characters: if there are  no break characters in  the buffer, it deletes  the entire

                                                   10-11


            Port I/O                                 10                         YAMM edition 2.1


            buffer;  otherwise  it deletes  everything  back  to (but  not  including)  the most
            recently-typed break character.

            The line-editing characters will not have an effect if they arrive
                1)  when the port is in image state
                2)  when the port is in break-on-all mode
                3)  when the port is in full-character-set mode
            In any of the above cases, the  editing character will simply be passed to  the user
            program.  In full-character-set mode, the editing characters are treated  as control
            characters (i.e., they always break).  This is the only effect of full-character-set
            mode, which is entered by setting IO.FCS as shown in Table 10-33 .

            10.12.1.2.2    Escape Character
                           ______ _________

            The  monitor provides  an "escape"  character,  which a  user normally  types  (on a
            frame's command  port) to get  the attention  of either the  running program  or the
            monitor.

            Upon receiving an escape character, the monitor acts as follows:

                If the port is in image state, just deposit the escape in its input buffer.

                Otherwise, set the "escape seen" bit (bit LC.ESC of the line characteristics
                word, Table 10-30 ) for the port, and proceed:

                    If the frame that owns the port is enabled for a  software interrupt
                    on escapes,  cause the interrupt,  without depositing the  escape in
                    the input buffer.

                    Otherwise,  perform  a  line-delete operation  on  the  port's input
                    buffer (as if  a line-delete character  had been typed,  but without
                    the echo), and proceed:

                        If this is not the  second escape received, or if it  is the
                        second, but either (1)  the port is not its  owner's command
                        port, (2) the  port is at command  level, or (3)  the port's
                        owner  is running  with JB.JAC  or JB.JA2  set in  its frame
                        status word (see Table 2-7 ), just deposit the  character in
                        the port's input buffer.  (If the line is at  command level,
                        perform a CLRBFO operation as well).

                        Otherwise, perform a CLRBFI  and a CLRBFO operation  for the
                        port, set its suppress-output bit, force a HALT  command for
                        the frame, and force the port to command level.

            10.12.1.2.3    Output Suppression
                           ______ ___________

            The monitor provides a character which  a user can type to suppress  unwanted output
            without stopping the program that is generating it.

            Whenever a suppress-output character is received, the monitor does a CLRBFO  for the
            port, then complements the suppress-output bit for the port.

            The suppress-output bit LC.NOP is bit 9 in the port's line characteristics word (see
            Table 10-30 ).  When it is 1, output  calls for the port become no-ops.  The  bit is
            cleared
                1)  by the first output after an INIT on the port
                2)  by any input call
                3)  by SKPINC, SKPINL, .AXSIL, .AXSIC
                4)  by the command interpreter in various situations

            See Table 10-33b for the suppress output characters.






                                                   10-12


            June 27, 1984                            10                                 Port I/O


            10.12.1.2.4    End Of File
                           ___ __ ____

            In PDP10 mode, IO.EOF is set in the  port's file status bits if a ^Z is read  from a
            terminal (while it is not in the image state).

            10.12.1.2.5    Monitor Modes
                           _______ _____

            A frame can run in one of four "monitor modes": PDP10, XEXEC, XEXECJ, and SUDS.  The
            current mode is stored in bits  27-28 of the frame privilege word (see  Table 2-3 ),
            which can be read from the  .GTPRV GETTAB table (see Table 18-5 ), and set  with the
            SETPRV UUO (CALLI -11, pg. 2-2).

            The  monitor  mode  determines  the characters  used  for  various  terminal control
            functions for the frame's command port as indicated in Table 10-33b.

            10.12.1.3    Break Characters
                         _____ __________

            A port has a "break-on-all" bit.  When it is set, a non-image-state  input operation
            will return as soon as there is  at least one character in the port's  input buffer;
            when it is cleared, a non-image-state input operation will return as soon as either
                1)  there is at least one break character in the port's input buffer
                2)  the port's input buffer is nearly full
            The break-on-all bit is set by the input operations

                    DDTIN UUO (CALLI +1, pg. 10-42)
                    .AXSIC UUO (AUXCAL fn 10, pg. 10-41)
                    .AXICW UUO (AUXCAL fn 44, pg. 10-37)
                    INCHRS UUO (TTCALL 2, pg. 10-37)
                    INCHRW UUO (TTCALL 0, pg. 10-36)

            The break-on-all bit is cleared by the input operations

                    INPUT UUO (op code 066, pg. 5-11)
                            (not in image mode)
                    .AXISL UUO (AUXCAL fn 47, pg. 10-39)
                    .AXIWL UUO (AUXCAL fn 46, pg. 10-38)
                    INCHSL UUO (TTCALL 5, pg. 10-38)
                    INCHWL UUO (TTCALL 4, pg. 10-38)

            The  class  of  characters that  are  considered  to be  "break  characters"  can be
            controlled somewhat by the user.

            Normally, the break  set consists of all  the control characters which  actually get
            placed in the port's input buffer (excluding, therefore, the  line-delete character,
            for example), with the exception of HT.

            If the  "break-on-punctuation" bit  (bit 26  of the  file status  bits) is  set, the
            punctuation characters are also considered break characters:

                    ! " # $ % & ' ( ) _ = - ^ <tilde> { }
                    [ ] ` @ + ; * : < , > . ? / | \

            If the  "tabs-as-breaks" bit is  set, tabs are  counted as control  characters (they
            always cause breaks); if it  is cleared, they are counted as  punctuation characters
            (and only cause breaks if  the break-on-punctuation bit is set).   The tabs-as-break
            bit can be  read and reset  with the .AXTBK  UUO (AUXCAL fn 26, pg. 10-34).   If the
            Backspace Break/Punctuation bit is clear  (the default case), backspace is  always a
            break character.  If it is set (use .AXBBP UUO (AUXCAL fn 66, pg. 10-34) ) backspace
            counts as a punctuation character and causes a break only if break-on-punctuation is
            set.








                                                   10-13


            Port I/O                                 10                         YAMM edition 2.1


            10.12.1.4    Image State
                         _____ _____

            A  port can  be in  "image state",  in which  case the  characters input  are simply
            deposited  into  the  input  buffer  without  further  examination  by  the monitor.
            Characters received in image state are furthermore flagged so that no special action
            will be taken for them when they  are read by the program (this is important  in the
            case of the escape character) or  echoed by the monitor (this affects  line position
            computation, VT and FF padding and HT echoing).

            An aux port is always in image state; non-aux ports are placed in image state by any
            of the following operations:
                1)  INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOIBN, or .IOBIN)
                2)  .AXI8C, .AXI8S, .AXI8B
            It is cleared (for non-aux ports) whenever
                1)  any  output operation  is performed  and the  data mode  is  not .IOIMG,
                    .IOIBN, or .IOBIN
                2)  a CLOSE is done for the output side of a channel initted to the port and
                    the data mode is not .IOIMG, .IOIBN, or .IOBIN
                3)  the  port  stays  in input  wait  for  more than  20  seconds  without a
                    character arriving and the port's data mode is .IOIMG.

            10.12.1.4.1    Breaks
                           ______

            The operations

                    .AXI8C, .AXI8S
                    .AXICW, .AXISC
                    INCHRW, INCHRS
                    DDTIN

            set the port's break-on-all bit.  (.AXI8C  and .AXI8S place the port in  image state
            as well).   They wait until  (or nonskip-return unless)  at least one  character has
            been deposited in the buffer.

            The operations

                    .AXI8W
                    .AXIWL, .AXISL
                    INCHWL, INCHSL
                    INPUT, IN, .CHIPT, .CHIN (data mode = .IOIMG, .IOBIN, .IOIBN)

            clear the port's break-on-all bit.   The break condition is different,  however, for
            them than for non-image mode operations.

            The calls  that nonskip or  skip-return depending  on the presence  of a  break will
            return if the port's input buffer  is empty and skip-return if it contains  at least
            one character (just as if they were the corresponding break-on-all calls).

            The calls that wait for a break character will return immediately if  any characters
            are in the  port's input buffer.  If  the buffer is empty  at the time of  the call,
            what happens depends on whether the program has set an "image break  character" (see
            10-15).  If  it has,  the call will  return as  soon as one  of those  characters is
            received (or as soon as a timeout clears the image state and a non-image-state break
            character arrives).   If it has  not, the call  will return as  soon as  the monitor
            receives some characters and then  stops receiving characters for a few  seconds, or
            until the input buffer becomes full.












                                                   10-14


            June 27, 1984                            10                                 Port I/O


            10.12.1.4.2    Image Break Character
                           _____ _____ _________

            To set a port's  image break character, or to  declare that there is no  image break
            character, a program executes the .AXS8B UUO (AUXCAL fn 13, pg. 10-35).

            10.12.2    Echoing
                       _______

            A TYMNET  circuit can  be in  deferred or remote  echo mode.   In remote  echo mode,
            echoing is done by the TYMNET remote; in deferred echo mode, echoing is done  by the
            host  computer.  The  idea is  that  the remote  can echo  everything  whose echoing
            behavior  is obvious  (such as  the printing  characters), but  that the  echoing of
            questionable characters (such as control characters) should be left to the host.

            A remote will switch from remote to deferred echo when (1) a control character other
            than carriage-return or linefeed  is typed, (2) a  right brace, tilde, or  rubout is
            typed, (3)  a character is  typed while output  is in progress  at the  terminal, or
            .AXEDE UUO (AUXCAL fn 63, pg. 10-34) is issued.  It preceeds the offending character
            with an  "entering deferred  echo mode"  message (so  that the  host will  know that
            subsequent characters have not yet been echoed) and stops echoing  remotely.  Having
            done  this, the  remote now  seeks  to get  back into  remote echo  mode:  every few
            seconds, it sends a  green ball towards the host;  if a green ball reaches  the host
            and  the  host (1)  is  in input  wait  and (2)  has  finished all  its  echoing and
            outputting on the line, it will  reflect the ball back; when the green  ball reaches
            the remote, it will  send a "leaving deferred echo  mode" message along to  the host
            (so that the host will know that the subsequent characters have already been echoed)
            and will resume echoing characters remotely.

            10.12.2.1    Turning off Echo
                         _______ ___ ____

            There are three ways to make the TYMNET/host combination stop echoing characters:
                1)  Log in to TYMNET on a local-copy device (for example an IBM 2741)
                2)  Set half-duplex mode
                3)  Turn off echo
            The three behave in somewhat different ways, as described below.

            10.12.2.1.1    Half-Duplex
                           ___________

            When half-duplex mode is set, the  TYMNET line goes into remote echo mode  and stays
            there, and the remote stops echoing; nothing happens in the monitor.  The  result is
            that most normal characters stop  echoing, but that characters with  special echoing
            properties (such as the  character-delete character, which echoes the  characters it
            has deleted, or the horizontal tab character which, if simulated, echoes some number
            of spaces) do not.  Half-duplex mode  is the correct mode to set for  a half-duplex,
            but not line-at-a-time, terminal.

            The "half  duplex" bit (LC.HDX,  see Table 10-30 ),  can be set  with the  .AXHD UUO
            (AUXCAL fn 20, pg. 10-34).

            It can also be set or reset with the command

                    TTY [NO] ECHO

            (which does not set the "no echo" bit.).















                                                   10-15


            Port I/O                                 10                         YAMM edition 2.1


            10.12.2.1.2    No Echo
                           __ ____

            When no echo mode is in effect, the TYMNET line stops echoing characters if it is in
            remote echo mode, and,  once in deferred echo mode,  does not attempt to  leave; the
            monitor stops echoing altogether, with the exception that control-O,  the PDP10-mode
            output-suppress character, is still echoed as ^O.  No-echo mode is the  correct mode
            to set  when reading passwords,  for example, since  setting half-duplex  mode would
            allow deleted characters of the password to be echoed.

            The "no echo" bit is bit 28 of a port's file status bits (see 10-4).

            10.12.2.1.3    Local Copy
                           _____ ____

            Local-copy mode is set along with half-duplex by TYMNET where a user logs in and his
            or her terminal  identifier character indicates a  local-copy device such as  an IBM
            2741.  Regardless  of the settings  of any  other bits, when  local-copy mode  is in
            effect, the monitor assures
                1)  No free carriage-returns on lines greater than the maximum line-width
                2)  No dollar-sign echo for escapes
                3)  No ^<character> echoes for control characters such as control-Z
                4)  No spaces output for horizontal tabs
                5)  No linefeeds output for VT or FF
                6)  No echoing of deleted characters
            The intent of local-copy mode is to keep the monitor from trying to output while the
            user is trying to type.

            10.12.2.2    Yellow and Orange Balls
                         ______ ___ ______ _____

            The remotes send green balls to determine when a host port has gone into input wait.
            It is often useful for a program to know the same thing about the port at  the other
            end of an aux circuit.

            To  do this,  the program  sends a  yellow ball.   The yellow  ball will  follow any
            characters the program has output along  the circuit.  When it reaches the  host, it
            will "stick" there until the host port goes into input wait, at which point, it will
            be reflected  back as an  orange ball.  (A  yellow ball sent  to a terminal  will be
            reflected back as soon as it arrives).

            The .HBODN  wait condition  of the HIBER  UUO (CALLI +72,  pg. 16-8) sends  a yellow
            ball and waits  until it is  reflected back. This is  a straightforward way  to wait
            until a batch  of program output has  been absorbed by the  host or terminal  at the
            other end.

            The  .IAORG  software interrupt  condition  (see TINASS  UUO  (CALLI -42, pg. 16-5))
            will cause a software interrupt when an orange ball is received.

            To  simply send  a yellow  ball, a  program executes  the .AXSYB  UUO (AUXCAL fn 12,
            pg. 10-35).

            The  .IAYEL  software interrupt  condition  (see TINASS  UUO  (CALLI -42, pg. 16-5))
            will cause a software interrupt when a yellow ball is seen, and  suppress reflection
            of the yellow ball as an orange ball.  In order to conform with proper protocol, the
            receiving program  should send back  an orange ball;  this is accomplished  with the
            .AXSOB UUO (AUXCAL fn 70, pg. 10-35).














                                                   10-16


            June 27, 1984                            10                                 Port I/O


            10.12.2.3    Faking Input Wait
                         ______ _____ ____

            It is possible to inadvertently put  a circuit in deferred echo mode forever.   If a
            program is  doing interrupt driven  i/o (i.e. .INCHR  is set as  a TINASS  cause for
            interrupt) the program will never actually enter input wait.  As a result, no yellow
            balls will be reflected as orange  balls, and no green balls will be  reflected back
            to the remote to tell it to reenter remote echo mode.  This will cause a  problem if
            there is  a program at  the other end  of the circuit  in interrupt wait  waiting to
            receive an orange ball  before waking up.  If the  program is doing line  input, the
            line will not be echoed until the <return> is entered.  To prevent this, the program
            may execute the .AXLDE UUO  (AUXCAL fn 11, pg. 10-35) or the LEVDEF  UUO (CALLI -30,
            pg. 10-35) to tell the monitor to behave as if it were in input wait.

            10.12.2.4    Special Characters
                         _______ __________

            10.12.2.4.1    Backspace
                           _________

            Normally,  backspace  is a  control  character to  TYMNET,  and forces  a  line into
            deferred-echo mode.  If a terminal can perform backspacing, it is reasonable to echo
            backspaces remotely.  A program can read or set the "remote backspace echo" bit with
            the .AXRBS  UUO (AUXCAL fn 54, pg. 10-34).   This can  also be set  of reset  by the
            command

                    TTY [NO] BACKSPACE

            Backspace can be set up as a character-delete character (see 10-11).

            10.12.2.4.2    Deleted Characters
                           _______ __________

            Normally, the monitor responds  to the first character-delete character  it receives
            by  typing a  backslash and  the character  deleted; to  subsequent character-delete
            characters by typing the characters deleted; and to the  next (non-character-delete)
            character typed by typing a concluding backslash and echoing that character.

            On most display terminals, characters  can be erased by backspacing and  typing over
            them.  The monitor can be made to simply echo a backspace for  each character-delete
            character received by settting  the "backspace for character-delete" bit,  using the
            .AXBS UUO (AUXCAL fn 57, pg. 10-34).  This can also be set or reset by the command

                    TTY [NO] ERASE

            10.12.2.4.3    Escape
                           ______

            In the PDP10 modes,  the monitor normally echoes ESC  (and right brace and  tilde if
            they are being mapped to escape) as a dollar sign (unless the ESC was received while
            the port was in image state, in  which case an ESC is echoed).  This feature  can be
            disabled by setting the "no special escape echo" bit, bit 27 of the file status bits
            (see 10-4).

            10.12.3    Output
                       ______

            The character-handling described in  this section applies both to  characters output
            by a program and to characters echoed by the monitor.















                                                   10-17


            Port I/O                                 10                         YAMM edition 2.1


            10.12.3.1    Output Case Mapping
                         ______ ____ _______

            Normally,  characters are  sent to  TYMNET exactly  as generated  by the  program or
            echoed by the host.  For certain  terminals, it is desirable to have  all alphabetic
            material in  lower case, since  upper case  is used on  these terminals  for special
            characters.  A user of such a terminal may give the command

                    TTY [NO] UCO

            meaning "no upper case output", and cause all upper-case alphabetic characters to be
            mapped to lower-case.  This port parameter can also be manipulated by the .AXLCO UUO
            (AUXCAL fn 65, pg. 10-34).

            10.12.3.2    Image Characters
                         _____ __________

            For the purposes of this section, an "image character" is a character received while
            the port was in image state (which is being echoed), or an output character from the
            program which was output by
                1)  OUT, OUTPUT, .CHOUT, .CHOPT (data mode = .IOIMG, .IOIBN, .IOBIN)
                2)  .AXPTR, OUTPTR (byte size > 8 and level-9 bit = 1)
                3)  .AXO8, .AXO8I, IONEOU
            These characters are  transferred directly from the  port's output buffer  to TYMNET
            without special processing by the monitor.

            10.12.3.3    Line Width and Position
                         ____ _____ ___ ________

            While echoing  and outputting  characters, the  monitor keeps  track of  the current
            position of the terminal's print  head.  (Image characters, however, are  treated as
            having zero width).  This estimate of the print position can be read from the .GTLPS
            GETTAB table (see Table 18-5 ).

            The monitor has a "line width" parameter for each port, and if echoing or outputting
            a character would cause  the print position to exceed  the line width, it  outputs a
            carriage return/linefeed sequence in front of the character.

            The line  width parameter  can be  read or  set with  the .AXWID  UUO (AUXCAL fn 27,
            pg. 10-34).  and the automatic carriage return/linefeed action can be  suppressed by
            setting the  "no free  carriage return"  bit of  the terminal  using the  SETLCH UUO
            (TTCALL 7, pg. 10-30).

            10.12.3.4    HT, VT, FF simulation
                         ___ ___ __ __________

            The monitor normally simulates horizontal tabs (unless they are image characters) by
            inserting blanks to the next "tab  stop", tab stops being every 8  characters.  This
            feature can be  disabled for terminals having  HT hardware by setting  the "hardware
            horizontal tabs" bit, (LC.HHT, see Table 10-30 ).

            The monitor normally  simulates vertical tabs and  formfeeds (unless they  are image
            characters) by inserting linefeeds, 4 for each vertical tab and 8 for each formfeed.
            This feature can be disabled for terminal having vertical motion hardware by setting
            the "hardware vertical tabs and formfeeds" bit, (LC.HFF, see Table 10-30 ).

            The echoing (or simulation) of  horizontal tabs, vertical tabs and formfeeds  can be
            suppressed  altogether  by setting  the  "no  HT/VT/FF" bit,  using  the  .AXNTE UUO
            (AUXCAL fn 25, pg. 10-34).  This bit affects only echoing, not output.













                                                   10-18


            June 27, 1984                            10                                 Port I/O


            10.12.3.5    CR and LF delay
                         __ ___ __ _____

            TYMNET  can supply  delays for  carriage-returns and  linefeeds for  terminals where
            those operations take longer than one character time to perform.  The  formulas used
            to compute those delays are given below.  The units are 30ths of a second.

            The "compute CR delay"  bit determines how the delay  parameters A, B, C, and  D are
            used.  If it is set, A, B, and C are used to compute the carriage-return  delay, and
            D is  the (constant)  line feed delay.   If it  is clear, A,  B, and  C are  used to
            compute the linefeed delay, and D is the (constant) carriage-return delay.   The bit
            can be read and set with the .AXCRD UUO (AUXCAL fn 14, pg. 10-34).

            Parameter D  cannot be  set by the  monitor.  Parameters  A, B, and  C can,  but the
            values passed between the monitor and  the user are not the actual  parameter values
            but rather indexes  into tables of the  actual parameter values.   The relationships
            are

             param A-use .AXPA UUO (AUXCAL fn 21, pg. 10-34)
             index          0  1  2  3  4  5  6  7
             value          1  2  4  8  16 32 64 128

             param B-use .AXPB UUO (AUXCAL fn 22, pg. 10-34)
             index          0 1 2 3 4 5 6 7
             value          0 1 2 3 4 5 6 7

             param C-use .AXPC UUO (AUXCAL fn 23, pg. 10-34)
             index          0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
             value          0  1  2  3  4  5  7  10 14 19 26 36 50 69 95 131

            10.12.3.5.1    CR Delay Formula
                           __ _____ _______

            Parameters A, B, and C are used to compute the carriage-return delay as follows:

                    delay := min( N/A + B, C )

            where <N> is the current line position.

            10.12.3.5.2    LF Delay Formula
                           __ _____ _______

            Parameters A, B, and C are used to compute the linefeed delay as follows:

                    delay := log2(A)        if N <= 1
                             C-N+B          if 2 <= N < C
                             B              if N >= C

            where <N> is the current line position.

            10.12.3.6    HT, VT, FF delays
                         ___ ___ __ ______

            The monitor can supply delays for horizontal tabs, vertical tabs, and formfeeds, for
            terminals  where  those operations  take  longer  than one  character  time  and are
            hardware-implemented.   The  delays  are  produced  by  inserting  rubout characters
            ('177s), and  the units given  below are the  number of rubouts  inserted (character
            times).

            Such padding is not provided if the VT or FFs are image characters.












                                                   10-19


            Port I/O                                 10                         YAMM edition 2.1


            10.12.3.6.1    HT Filler Cclass
                           __ ______ ______

            The  "filler  class  2"  terminal  characteristic  is  used  to  compute  delays for
            horizontal  tabs.   It  can be  read  and  set with  the  .AXFC2  UUO (AUXCAL fn 31,
            pg. 10-34).  The delays are computed as follows:

                    FC2     N<=4    N>4
                    0       0       0
                    1       1       2
                    2       3       5
                    3       3       5

            where <N> is the distance to the next tab stop

            This assumes that tabs are every 8 characters.

            10.12.3.6.2    VT and FF filler class
                           __ ___ __ ______ _____

            The "filler class 1" terminal characteristic is used to compute delays  for vertical
            tabs and  formfeeds.  It  can be  read and  set with  the .AXFC1  UUO (AUXCAL fn 30,
            pg. 10-34).  The delays are computed as follows:

                    FC1     VT      FF
                    0       0       0
                    1       6       12
                    2       5       15
                    3       20      40

            10.12.4    Parity
                       ______

            TYMNET has an even-parity parameter which, when set, causes the level-8 bit  of each
            character transmitted to be discarded and replaced with a generated  even-parity bit
            for the character.

            The monitor always sets the level-8  bit to 0 on 7-bit characters output  to TYMNET,
            and  always sends  the character's  level-8 bit  on 8-bit  output.  A  program must,
            however, clear TYMNET's even-parity parameter  if it wants to send  8-bit characters
            unchanged over TYMNET.

            The even-parity parameter can be  read and reset using the .AXEP  UUO (AUXCAL fn 17,
            pg. 10-34).

            10.12.5    Data Transmission Modes
                       ____ ____________ _____

            10.12.5.1    Katakana Data Mode
                         ________ ____ ____

            The port  i/o routines  normally treat  image characters  as being  8 bits  wide and
            non-image  characters as  being 7.   If, however,  the port's  data mode  is .IOKAT,
            non-image characters are treated as being 8 bits wide.

            This data  mode is intended  to allow the  handling of the  JIS-8 character  set, an
            8-bit extension of ASCII that has Katakana characters in code positions '241 through
            '377.

            For buffered i/o, the byte size in .IOKAT mode is 9 bits. The level-9 bit  is always
            0 on input and should be always 0 on output.

            Most  port  i/o calls  adjust  appropriately to  Katakana  mode,  transmitting 8-bit
            instead of 7-bit characters.  Those that do not are
                1)  OUTSTR UUO (TTCALL 3, pg. 10-45), .AXOST UUO (AUXCAL fn 52, pg. 10-47)
                2)  DDTIN UUO (CALLI +1, pg. 10-42)
                3)  DDTOUT UUO (CALLI +3, pg. 10-48)
            The monitor decides whether a given character is a special-function character, break
            character, or punctuation character by examining its right 7 bits.  For  example, in
            PDP10 mode, where ^C is the escape character, both '003 and '203 act as escapes.

            If case mapping is in effect, codes '340 through '374 will be mapped to '300 through
            '334, and codes '375 and '376 will be mapped to ESC.
                                                   10-20


            June 27, 1984                            10                                 Port I/O


            10.12.5.2    Paper Tape Mode
                         _____ ____ ____

            For reading  paper tape or  cassettes, the monitor  supplies "paper tape"  mode.  In
            this mode, regardless of the settings of any other bits,
                1)  Linefeeds are not echoed after each carriage-return
                2)  Rubouts are ignored
                3)  No free carriage-returns  are supplied for  lines over the  maximum line
                    width
                4)  There is no dollar-sign echo for escapes
                5)  There are no ^<character> echoes for control characters such as ^Z
                6)  No spaces are output for horizontal tabs
                7)  No linefeeds are output for VT or FF
            This mode can be entered by setting LC.PTM (see Table 10-30 ).

            10.12.5.3    Port Buffered-I/O Modes
                         ____ ____________ _____

            See 10-9 for  a discussion of  the legal data modes  for buffered i/o  operations on
            ports.   See 6-1  for general  discussion and  definition of  buffered i/o  with any
            device.


            10.13    Special Purpose Terminal Charactersitics
                     _______ _______ ________ _______________

            10.13.1    Terminal Class
                       ________ _____

            A SIXBIT string  identifying the "class" of  the terminal in use  is set or  read by
            .AXTTP UUO (AUXCAL fn 100,  pg. 10-34).  This identification  can be used  by screen
            editors and other applications on display type terminals.

            The terminal class can also be set by the command

                    TTY CLASS <terminal identifier>

            10.13.2    Special Control-T Mode
                       _______ _________ ____

            The "special control-t" mode bit can be set or read in the usual way with .AXCLR UUO
            (AUXCAL fn 101, pg. 10-34).  If it is set and  the user is in PDP10 mode, a  ^T will
            display a status line on the command port terminal in the following format:

                    elapsed:0:00:34 tru:5.01 blks in:136 out:0 state:^C mws:46

            The display elements are elapsed time  since the last ^T command in  hours, minutes,
            and seconds;  cpu time (microcycles)  in minutes, seconds  and jiffies;  disk blocks
            read; disk blocks  written; the current  state of the  calling job; and  the current
            monitor working set size.


            10.14    Block I/O
                     _____ ___

            The block i/o  facility was designed to  make high-volume data transfer  over TYMNET
            more efficient, mainly by reducing per-character cpu overhead in the host.  Charging
            is adjusted accordingly: at 80 characters per transfer, block i/o costs the  same as
            normal i/o; at the  maximum 400 characters per transfer  it costs less than  half as
            much.














                                                   10-21


            Port I/O                                 10                         YAMM edition 2.1


            10.14.1    Block I/O Buffer Format
                       _____ ___ ______ ______

            The block input and output AUXCALs are all passed the address of a 101(decimal)-word
            buffer, whose format is

                    0-7     8-15    16-23   24-31   32-35 bits
                    --------------byte count------------- wd 0
                    b0      b1      b2      b3      XXXXX wd 1
                    b4      b5      b6      b7      XXXXX wd 2
                    ...
                    b396    b397    b398    b399    XXXXX wd 100

            On output, <byte  count> specifies the number  of bytes to be  output; it must  be a
            number from 1 to 400 (inclusive).

            On input, the <byte count> is set  by the monitor, and indicates how many  bytes the
            monitor has stored into  the user's buffer.  The  monitor reads the <byte  count> at
            the time the input operation is performed, and requests that many bytes from TYMNET.
            When the input arrives, the monitor copies it all into the user's data area (without
            reexamining  the count).   Since the  monitor reads  ahead, it  is not  advisible to
            change <byte count> from one request to the next.

            Successive words after  <byte count> store the  actual data, 4  left-justified 8-bit
            bytes  per word.   The  rightmost 4  bits  of each  word  are unused  on  output and
            undefined on input.  The  contents of bytes after  the <byte count>th byte  are also
            undefined on input.

            10.14.2    Block I/O Data Modes
                       _____ ___ ____ _____

            Block i/o should be performed in Image, Image Binary, or Binary Mode.  The treatment
            of data modes while in block i/o mode differs from the normal treatment.

            The  monitor  will  signal  an  end-of-input  (and  wake  or  interrupt   the  frame
            accordingly) if
                1)  it receives an end-of-transmission message (this is  currently signalled
                    by sending a yellow ball)
                2)  a  timeout occurs  (currently,  this means  that  the base  has  gone 16
                    seconds without receiving four characters)
                3)  the requested input arrives

            The data mode determines the handling of timeouts and EOTs.

            Timeouts in Image Binary and Binary modes simply cause the monitor to re-request the
            input (i.e., there are no timeouts).  In Image mode, the monitor sets IO.BKT  in the
            port's file  status bits  when it  receives a  timeout message  from the  base, then
            forces an .AXTBI operation on the port.

            EOTs are ignored in Binary mode.   In Image Binary and Image modes, they  signal the
            end of the data: the monitor will not send any more input requests to the base until
            the program has exhausted all the data, by doing block inputs until IO.EOF is set in
            the file status bits.

            10.14.3    Interaction with Non-Block Input
                       ___________ ____ _________ _____

            Between the time a block input call  is done on a port and a subsequent  block input
            returns  with IO.EOF  set in  the file  status bits,  the effect  of  nonblock input
            operations is  unpredictable; after the  IO.EOF has been  received, the  program can
            proceed with nonblock input operations (without doing a .AXLBM), though caution must
            be exercised with respect to the data modes.

            The existence  of block i/o  at all is  not known past  the PDP10's base:  the first
            block input starts diverting input characters from the port's normal buffer into the
            block  input buffer,  where they  will continue  to go  until block  input  has been
            terminated, a state which is indicated by a block input call's returning with IO.EOF
            set.



                                                   10-22


            June 27, 1984                            10                                 Port I/O


            10.14.4    Interaction with Non-Block Output
                       ___________ ____ _________ ______

            It is acceptable  to perform a nonblock  output operation immediately after  a block
            output operation: the nonblock  characters will be output immediately  following the
            block output characters.  Before doing  a block output, however, the  program should
            make sure  that all of  the previous nonblock  output characters have  actually been
            sent (e.g., by doing a HIBER on output complete), since otherwise, the  block output
            characters may intervene among the nonblock.

            The data mode of the port has no effect on block output.

            10.14.5    Block I/O Tutorial
                       _____ ___ ________

            To perform block i/o on a port,  the program must first place the port in  block I/O
            mode by executing the .AXEBM UUO (AUXCAL fn 34, pg. 10-48).

            A port will leave block i/o mode  when the program executes a RESET or HANG  UUO, or
            the  port  is  zapped,  or  the  program  executes  the  .AXLBM  UUO  (AUXCAL fn 42,
            pg. 10-48).

            To do block  input, a program executes  the .AXIBW UUO (AUXCAL fn 35,  pg. 10-48) or
            .AXIBS UUO (AUXCAL fn 36, pg. 10-49).  It is  valid for either call to store  a byte
            count of zero and transfer no data.

            In Binary mode, IO.EOF is never set, and in the other modes, it may be  desirable to
            terminate  block  input before  the  "other end"  times  out or  sends  an  EOT.  To
            terminate  block  input without  losing  data,  a program  executes  the  .AXTBI UUO
            (AUXCAL fn 40, pg. 10-49).

            To do block output, a program executes the .AXOB UUO (AUXCAL fn 37, pg. 10-49).

            To do the equivalent of a normal CLRBFO, a program must first execute the .AXTBO UUO
            (AUXCAL fn 41, pg. 10-49)  to stop the  base from working  on any  uncompleted block
            output  for the  port,  then do  a .AXCBO  UUO  (AUXCAL fn 7, pg. 10-36)  to  send a
            character gobbler.


            10.15    Port Creation,Moving,Deletion UUOs
                     ____ ________________________ ____

            10.15.1    GETLIN: get command port name (CALLI +34)
                       _______ ___ _______ ____ ____ ______ ____

                    GETLIN  ac,
                    only return

            Set c(<ac>)  to the SIXBIT  left-justified device name  of the frame's  command port
            (e.g., SIXBIT /TTY57/ for port 57 (octal)), and return.

            If the frame is detached, c(<ac> left)  will be 0 (instead of SIXBIT /TTY/)  and the
            right half will be the port number of the frame's last command port.

            10.15.2    ATTACH: attach command port to frame (CALLI -6)
                       _______ ______ _______ ____ __ _____ ______ ___

                    MOVE    ac, [bits,,frame]
                    ATTACH  ac,
                      error return
                    normal return

            bits =  1B17 to suppress forcing the attachee into command mode
                    1B16 to suppress doing an EXIT for the detachee
                    1B15 to force target frame to run state

            If c(<ac>) are 0 or negative, DETACH the calling frame from its port, as follows:

            If the frame has no command port attached, or if a zapper has arrived on the command
            port but has not yet been acted upon, take the error return.

            Otherwise,  detach the  command port  from the  current frame,  and take  the normal
            return.
                                                   10-23


            Port I/O                                 10                         YAMM edition 2.1


            If c(<ac>) are not 0 or negative, then ATTACH the command port as follows:

            If the current  frame is running  detached, or if <frame>  either does not  exist or
            already has a command port attached to it, or if <frame>'s AUN is different from the
            current frame's and  the current frame  does not have  Jacct (JL) license,  take the
            error return.

            Otherwise, detach the current frame's command port and if bit 16 is clear in the ac,
            perform the equivalent of an EXIT  UUO on the current frame.  Then attach  that port
            as <frame>'s command port.  If bit 17 is clear in the ac, print a prompt sequence on
            the TTY and force the frame into  command mode.  If bit 15 is set,  resume execution
            in the target frame if the target frame is not already in run state.

            10.15.3    RETACH: move port from frame to frame (CALLI -135)
                       _______ ____ ____ ____ _____ __ _____ ______ _____

                    MOVEI   AC,<addr>
                    RETACH  AC,
                     error return   ;AC/ error code from Table 10-25 
                    normal return   ;AC/ port number of port moved

            addr:   source frame FD,,target frame FD
                    <bits>,,<port>


            where <bits> =
            name    bits    description
            RT.SLV  1B0     attach <port> as aux/slave port rather
                            than as a command port
            RT.MOD  3B2     level to force in target frame after attach
             .RTMSV 0       according to saved command level state
             .RTMCU 1       according to current command level state
             .RTMCO 2       command level
             .RTMUS 3       user level (see 10-2 for
                            discussion of command and user level)
            RT.SIG  1B3     signal a hangup on the source frame
                    1B4     force target frame to run state

            <port> = a port number or 777777 to indicate the command port
                     of the source frame

            RETACH  requires .ARDET  rights over  the source  frame and  .ARATT rights  over the
            target frame.

            If the required access rights are  missing, or if any other of the  conditions named
            in Table 10-25  exists, take the error return.

            RETACH is not allowed if any forced commands are pending on <port>.  Forced commands
            are those  such as KJOB  (i.e., LOGOUT),  LOGIN, DETACH and  HALT which  the monitor
            initiates on  a port; their  action cannot be  altered if system  security is  to be
            maintained.

            If RT.SLV is set, turn <port> into a slave port belonging to the target frame.

            Otherwise, make <port> the command port  of the target frame, and force the  port to
            command/user level according to the RT.MOD field of <bits>.  .RTMSV causes <port> to
            be set to  the level which prevailed  the last time the  target frame had  a command
            port.  .RTMCU preserves the level which prevails on <port> at the moment it is being
            taken away from the source frame.  .RTMCO and .RTMUS force their  respective levels.
            However,  provided  that  RT.SLV is  clear,  then  a 1B4  will  cause  resumption of
            execution in the target frame if the  target frame is not already in run  state.  If
            RT.SIG is set, simulate in the source frame the arrival of a zapper on <port>.

            Set <ac> to the number of the port moved, and take the normal return.





                                                   10-24


            June 27, 1984                            10                                 Port I/O


                                                Table 10-25 
                                                _____ _____ 
                                             RETACH error codes
                                             ______ _____ _____


            name     code  description

            RTSAC%   1     insufficient access rights to source frame
            RTSNX%   2     source frame does not exist
            RTTAC%   3     insufficient access rights  to target frame
            RTTNX%   4     target frame does not exist
            RTSNA%   5     specified port not attached to source frame
            RTTAT%   6     target frame already has port attached
            RTSCP%   7     forced command already pending on port
            RTAUX%   10    attaching aux circuit as command port
            RTNRM%   11    no room for new port DDB


            10.15.4    RLSLDB: release spare LDB (CALLI -142)
                       _______ _______ _____ ___ ______ _____

                    RLSLDB
                      error return
                    normal return

            This UUO is used by LOGOUT to release the spare LDB to the next waiter in  the queue
            (if any).  If the frame  has no DDB, or if  the calling process does not  have Jacct
            (JL) license, take the error return.  Otherwise, release the spare LDB, and  wake up
            any waiters.

            If the spare LDB is not attached to this frame, this UUO is a no-op.

            10.15.5    CREAUX: create an aux circuit (CALLI -44)
                       _______ ______ __ ___ _______ ______ ____

                    MOVE    ac, [nozap + [ASCIZ /login string/]]
                    CREAUX  ac,
                      error return
                    normal return

            where <nozap> = CX.NZP (1B17) to inhibit zapping the circuit when
                    the process does a RESET UUO (CALLI +0, pg. 5-11)

            <login string> is a valid username, in uppercase ASCII,
                    optionally followed by a colon and host number,
                    followed by a semicolon, carriage-return, or NUL

            Let  <string>  be null.   Copy  characters  from <login  string>  to  <string> until
            <string>  is 29  characters  long, or  until  a carriage-return,  semicolon,  or NUL
            character has been copied.  If  the last character copied was not  a carriage-return
            or semicolon, append a semicolon to <string>.

            If the current process does  not have Auxiliary Circuit (AC) license,  scan <string>
            up to the first colon (or the end of <string>) and compare that initial segment with
            the process's UNM.  If it does not match, take the error return.

            If the current process  does not have AC license,  and it already has built  two aux
            circuits, take the error return.

            Output a login  message to TYMNET,  and pass <string> as  the login string.   If the
            login protocol fails, take the error return.

            Create a DDB for the new port,  error-returning if there is no room for  one; assign
            the port "by console" to the frame, mark it, if CX.NZP was set, so that it  will not
            automatically  be  zapped  on  a  RESET,  store  its  port  number  into  <ac>,  and
            skip-return.





                                                   10-25


            Port I/O                                 10                         YAMM edition 2.1


            10.15.6    .AXSLV: slave command port (AUXCAL fn 43)
                       _______ _____ _______ ____ _______ __ ___

                    MOVE    ac, [port,,.AXSLV]
                    AUXCAL  ac, addr

            If the frame is detached, or if it is being logged out; or if it already has two aux
            circuits and the process does not have Auxiliary Circuit (AC) license, error-return.

            Detach the frame's command port, mark it so that it will not be automatically zapped
            on a RESET, assign it "by console"  to the frame, set c(<addr>) to its  port number,
            and skip-return.


                                                Table 10-26 
                                                _____ _____ 
                                             CREAUX Error Codes
                                             ______ _____ _____


            name   code  condition

            CREAUX Error Codes (left half)

            CXSUP% 0     supervisor error code in right half - see below.
            CX2AX% 1     too many circuits without Auxiliary Circuit (AC) license; - only 2
                         circuits are allowed per process without Auxiliary Circuit (AC)
                         license.
            CXLOG% 2     not your username without Auxiliary Circuit (AC) license; -  without
                         Auxiliary Circuit (AC) license must only build circuits to the logged
                         in username for the process.
            CXDCB% 3     no room in monitor
            CXNRR% 4     supervisor did not respond to the original request.
            CXNRL% 5     supervisor did not respond to the login message.
            CXNCH% 6     supervisor did not supply a circuit
            CXERR% 7     supervisor error from original request


            CREAUX Error Codes (right half)

                         The following codes are returned in the right half following a CREAUX
                         in which the monitor saw an error message from the supervisor.  These
                         error codes are generated by the supervisor, not the monitor.  This
                         information is copied from comments in the source code for version 28
                         of the Tymnet supervisor.

            CXSFE% 1     format error
            CXSBU% 2     user not in mud
            CXSBM% 3     bad mud
            CXSHU% 4     host unavailable
            CXSDF% 5     downline load or dialout request failure
            CXSTO% 6     timeout
            CXSAB% 7     access barred
            CXSIS% 10    error in ISIS
            CXSLQ% 11    long queue in supervisor
















                                                   10-26


            June 27, 1984                            10                                 Port I/O


            10.15.7    ZAPCIR: zap an aux circuit (CALLI -45)
                       _______ ___ __ ___ _______ ______ ____

                    MOVE    ac, [port]
                    ZAPCIR  ac,
                    only return

            If <port> is negative, zap every aux port belonging to the current frame; otherwise,
            zap port <port> unless it does not belong to the current frame.  Return.

            10.15.8    .AXHNG: send hangup (AUXCAL fn 60)
                       _______ ____ ______ _______ __ ___

                    MOVE    ac,[port,,.AXHNG]
                    AUXCAL  ac,
                    only return

            This operation sends a "soft zapper" which hangs up the dataset on the other  end of
            the circuit,  but which leaves  the circuit unaltered.   It was implemented  for the
            initial TYMNET Dial-Out facility.

            10.15.9    AUXRED: read aux circuit port numbers (CALLI -46)
                       _______ ____ ___ _______ ____ _______ ______ ____

                    MOVE    ac, [-count,,addr]
                    AUXRED  ac,
                      error return
                    normal return

            If <count> is negative or zero,  take the error return.  Otherwise, set <ac>  to the
            number of ports owned  by the current process, store  the port numbers of  each port
            into successive locations starting at <addr>, and follow the (possibly null) list of
            port numbers with a -1.

            If the table supplied is too short  (<count> is less than the number of ports  + 1),
            store only the first <count> entries, but still set <ac> to the number of ports.

            Skip-return.

            10.15.10    CREPTY: Create PTYs (CALLI -141)
                        _______ ______ ____ ______ _____

                    SETZ    AC,
                    CREPTY  AC,
                     error return   ;AC/ errorcode
                    normal return   ;AC/ one port number,,other port number

            where <error code> is one of:

                    CPNPT%  1       out of PTYs
                    CPNRM%  2       no DDB space for another PTY

            Attach the two PTYs to the calling job as slave ports.

            10.15.11    POLPRT: Poll Ports for Events (CALLI -115)
                        _______ ____ _____ ___ ______ ______ _____

















                                                   10-27


            Port I/O                                 10                         YAMM edition 2.1



                    MOVE    ac,[<bits>,,<addr>]
                    POLPRT  ac,
                     error return   ;ac/ <number of ports returned>
                    normal return   ;ac/ <number of ports returned>

            where <bits> is a mask of <events> in which the caller
            is interested as shown in Table 10-29 ,
            and where the  argument supplied at <addr> is:

            ADDR:   <count>         ;number of words reserved for
                                    ;return data

            Data returned by the UUO is:

            ADDR+1  <events>,,<port>        ;for the first port
             ..     ..
             ..     ..
            ADDR+<count> <events>,,<port>   ;for the last port


            See Table 10-29  for a discussion of interrupt-causing <events> which can occur on a
            port.  The purpose of this UUO is to enable the owner of many aux ports to determine
            what, if any, significant events may have happened since he last looked, and on what
            ports they happened.

            For each of the caller's ports on which any of the <events> specified by  <bits> has
            happened, return <bits>AND<events>,,<port>  to a word  following ADDR and  clear any
            <events> bit returned by the UUO.  Continue returning event bitmasks with their port
            numbers to successive words until either <count> runs out or there are no more ports
            owned by the caller.   Set AC to <number of  ports returned> by POLPRT.   If <count>
            ran out and ports still remain whose event bitmasks could not be returned,  take the
            error return; otherwise take the normal return.



































                                                   10-28


            June 27, 1984                            10                                 Port I/O


                                                Table 10-29 
                                                _____ _____ 
                                           Port Event-Status Bits
                                           ____ ____________ ____


            name     bit   meaning

            LXRESC   1B0   escape seen
            LXROBS   1B1   orange ball seen
            LXRPSS   1B2   port status message seen
            LXRICL   1B3   input characters lost
            LXROCL   1B4   output characters lost
            LXRCHR   1B5   character seen
            LXRBRK   1B6   break condition seen (any of the following): break char read (normal
                           mode) or image break read (image mode) or break2 char read (break2
                           mode) or block received (block input mode)
            LXRYBS   1B7   yellow ball seen
            LXRGOB   1B8   character gobbler seen
            LXRIOS   1B9   output done
            LXRTCC   1B10  terminal characteristic changed or port just attached


            10.15.12    .AXPSM: read port-status msg (AUXCAL fn 61)
                        _______ ____ ___________ ___ _______ __ ___

                    MOVE    ac,[port,,.AXPSM]
                    AUXCAL  ac,
                    only return     ;ac/port status

            The  port status  returned is  4 bits  for which  there is  no  documentation.  This
            operation was implemented for the initial TYMNET Dial-Out facility.

            10.15.13    .AXNZP: r/s no zap on reset bit (AUXCAL fn 75)
                        _______ ___ __ ___ __ _____ ___ _______ __ ___

                    MOVE    ac, [port,,.AXNZP]
                    AUXCAL  ac, addr

            where <port> is -1 to specify the frame's command port,
                    or the port number of some port owned by the frame

            and <addr> points to either
                    1) a word containing a negative number, in which case
                       AUXCAL reads the value of .AXNZP bit into c(<addr>)
                    2) a word containing a positive number, in which case
                       c(<addr>) is swapped with the current setting of the
                       .AXNZP bit

            Perform the normal AUXCAL checks (see 10-5).

            Set <old> to the current value of the .AXNZP bit.  If c(<addr>) is  nonnegative, set
            the .AXNZP bit to c(<addr>).

            Set c(<addr>) to <old> and return.


            10.16    Port and Terminal Characteristics UUOs
                     ____ ___ ________ _______________ ____














                                                   10-29


            Port I/O                                 10                         YAMM edition 2.1


            10.16.1    GETLCH: read line characteristics (TTCALL 6)
                       _______ ____ ____ _______________ _______ __

                    GETLCH  addr
                    only return

            where <addr> points to a word containing a negative number to specify
                    current frame's command port, or the port number of the port
                    whose line characteristics are being read

            If c(<addr>) = -1,  let <port> be the  current frame's command port;  otherwise, let
            <port> be c(<addr> right).

            If the <port> does not belong to  the current frame, or if c(<addr>) was -1  and the
            current frame is  running detached, set c(<addr>)  = 0; otherwise, set  c(<addr>) to
            the port's line characteristics word.

            Return.


                                                Table 10-30 
                                                _____ _____ 
                                         Line Characteristics Word
                                         ____ _______________ ____


            name     bit(s)     contents

            Bits marked "*" can be set with SETLCH
            Bits marked "**" are cleared when read with GETLCH

            LC.ECS   1B2        "command line" exists, will be thrown away
            LC.PSS   1B3        ** a port status message has been seen
            LC.OBS   1B4        ** an orange ball has been seen
            LC.HDX   1B5        * half duplex
            LC.ESC   1B6        ** an escape has been seen
            LC.CRD   1B7        * compute carriage return delay (not LF)
            LC.DFR   1B8        in deferred echo mode
            LC.NOP   1B9        suppress output bit
            LC.NFC   1B10       * no free carriage return
            LC.BRK   1B11       input buffer contains a break character
            LC.AXC   1B12       auxiliary circuit
            LC.NCM   1B13       * no case mapping
            LC.HHT   1B14       * hardware horizontal tabs
            LC.LCP   1B15       local-copy (e.g. 2741) device
            LC.PTM   1B16       * paper tape mode
            LC.HFF   1B17       * hardware VT/FF
            LC.PNO   777777B35  port number


            10.16.2    SETLCH: set line characteristics (TTCALL 7)
                       _______ ___ ____ _______________ _______ __

                    SETLCH  addr
                    only return

            where <addr> points to a word from whose left half the command
                     port's line characteristics bits are to be set

            Set the settable  bits of the command  port's line characteristics word  (see above)
            from c(<addr> left) and return.











                                                   10-30


            June 27, 1984                            10                                 Port I/O


            10.16.3    .AXTCN: r/s terminal charactertistics by number (AUXCAL fn 73)
                       _______ ___ ________ ________________ __ ______ _______ __ ___

                    MOVE    ac,[port,,.AXTCN]
                    AUXCAL  arg,[tc number,,new val (or -1 to just read)]
                     error return           ;bad tc number or new value is illegal
                    normal return           ;arg/tc number,,old value


            If there is no  such terminal characteristic number  or new value is  illegal, error
            return.

            Otherwise return terminal charactertistic number, old value in argument.

            (See Table 10-32  for terminal characteristics and their numbers.)

            10.16.4    .AXTCP: read changed tc number,,value for a pty (AUXCAL fn 74)
                       _______ ____ _______ __ _____________ ___ _ ___ _______ __ ___

                    MOVE    ac,[port,,.AXTCP]
                    AUXCAL  ac,arg
                     error return           ;usual auxcal reasons, or not a PTY
                    normal return           ;arg/(tc number,,new value or
                                            ;-1 if nothing has changed since
                                            ;last call)


            If auxcal error, or not a PTY, error return.

            Otherwise  return  terminal  charactertic  number,  new  value  to  argument.   (See
            Table 10-32  for terminal characteristics and their numbers.)

            Specify  one  end's  port  number to  read  the  other  end's  characteristics.  The
            "changed" bits are only set when a frame actually changes a terminal characteristic.
            They are initially clear, and are not set by RETACH.

            10.16.5    GETTMC: (obs.) get terminal characteristics (CALLI -16)
                       _______ ______ ___ ________ _______________ ______ ____
            10.16.5    SETTMC: (obsolete) no-op (CALLI -15)
                       _______ __________ _____ ______ ____
































                                                   10-31


            Port I/O                                 10                         YAMM edition 2.1


                                                Table 10-32 
                                                _____ _____ 
                                          Terminal Characteristics
                                          ________ _______________


            name     number characteristic                          TTY Command

            .TCCRD   0      delay after CR not after LF
            .TCCIR   1      input baud rate                         IN
            .TCCOR   2      output baud rate                        OUT
            .TCPAR   3      set output parity
            .TCHDX   4      half-duplex                             *ECHO
            .TCPA    5      parameter A                             A
            .TCPB    6      parameter B                             B
            .TCPC    7      parameter C                             C
            .TCXON   8      remote XON                              XON
            .TCECH   9      remote backspace echo                   RBS
            .TCRXE   10     reverse XON enable                      RXE
            .TCTYP   11     terminal type                           TYPE
            .TCNXO   12     never send XON/XOFF
            .TCWID   13     terminal line width                     WIDTH
            .TCFC1   14     filler class 1                          FILL1
            .TCFC2   15     filler class 2                          FILL2
            .TCBSP   16     backspace for character delete          BACKSPACE
            .TCERA   17     backspace/space/backspace for delete    ERASE
            .TCDEF   18     stay in deferred echo mode              DEF
            .TCLCO   19     lower case output only                  UCO
            .TCTAB   20     hardware HT                             TAB
            .TCFRM   21     hardware VT/FF                          FORM
            .TCLCT   22     map lower-case input to upper           *LC
            .TCNFC   23     no free CR/LFs on long line             *CRLF
            .TCPTP   24     paper tape mode                         TAPE
            .TCBSD   25     ^H for rubout                           BSD
            .TCTTP   26     terminal class in SIXBIT                CLASS
            .TCRTC   27     enable ^T                               RTCOMP


            *TTY command turns off bit

            Many TTY commands may be preceeded by "NO " for the opposite action.

            10.16.6    SETMOD: set cmnd port file status (CALLI -26)
                       _______ ___ ____ ____ ____ ______ ______ ____

                    MOVEI   ac, file status bits
                    SETMOD  ac,
                    only return

            Wait for  the command  port to  become inactive.  If  the data  mode field  of <file
            status bits> specifies  an illegal mode  for port i/o,  abort the process  and store
            halt status HT.IDM for the frame.

            Otherwise, set the file status bits from <file status bits> and return.

















                                                   10-32


            June 27, 1984                            10                                 Port I/O


                                                Table 10-33 
                                                _____ _____ 
                                           TTY: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large - characters lost or BIO timeout
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file - timeout in BIO or EOF char
            IO.ACT   1B23  device is active
            IO.BK2   1B26  break-on-punctuation bit
            IO.NEE   1B27  no-escape-echo bit
            IO.NEC   1B28  no-echo bit
            IO.FCS   1B29  full-character-set bit
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask



                                                Table 10-33b
                                                _____ ______
                                     Monitor Modes & Special Characters
                                     _______ _____ _ _______ __________


                                 PDP10   XEXEC

            escape               ^C      ESC*
            character-delete     DEL     ^A
            line-delete          ^U      ^Q
            output-suppress      ^O      FS
            eof                  ^Z      **
            input ^D             ^D      RS



            *  if the no-case-mapping bit is 0, tilde ('176) and right brace
               ('175) map to ESC and hence have the escape function

            ** there is no character in XEXEC or GEXEC which sets the
               end-of-file indication, but most software recognizes ^D or ^Z
               as an end-of-file indication

            10.16.7    .AXSFS: set port file status bits (obsolete) (AUXCAL fn 32)
                       _______ ___ ____ ____ ______ ____ __________ _______ __ ___
            10.16.7    .AXCFS: change port file status bits (AUXCAL fn 64)
                       _______ ______ ____ ____ ______ ____ _______ __ ___

                    MOVE    ac, [port,,.AXSFS or .AXCFS]
                    AUXCAL  ac, file status bits
                    normal return

            Perform the standard AUXCAL tests (see 10-5).

            Wait for <port> to  become inactive.  If the data  mode field of <file  status bits>
            specifies an  illegal mode for  port i/o,  abort the process  and store  halt status
            HT.IDM for the frame.

            Otherwise, set the port file status  bits as in Table 10-33 from <file  status bits>
            and return.

            The difference  between these functions  is that presently  .AXSFS will not  put the
            port into/out of image state until certain UUO's are issued later; .AXCFS will force
            the proper image state immediately.   In the future this difference  will disappear.
            The best policy is to consider .AXSFS obsolete.



                                                   10-33


            Port I/O                                 10                         YAMM edition 2.1


            10.16.8    .AXCRD: r/s compute-CR-delay bit (AUXCAL fn 14)
                       _______ ___ ________________ ___ _______ __ ___
            10.16.8    .AXIBR: r/s input baud rate (AUXCAL fn 15)
                       _______ ___ _____ ____ ____ _______ __ ___
            10.16.8    .AXOBR: r/s output baud rate (AUXCAL fn 16)
                       _______ ___ ______ ____ ____ _______ __ ___
            10.16.8    .AXEP: r/s even-parity bit (AUXCAL fn 17)
                       ______ ___ ___________ ___ _______ __ ___
            10.16.8    .AXHD: r/s half-duplex bit (AUXCAL fn 20)
                       ______ ___ ___________ ___ _______ __ ___
            10.16.8    .AXPA: r/s parameter A (AUXCAL fn 21)
                       ______ ___ _________ _ _______ __ ___
            10.16.8    .AXPB: r/s parameter B (AUXCAL fn 22)
                       ______ ___ _________ _ _______ __ ___
            10.16.8    .AXPC: r/s parameter C (AUXCAL fn 23)
                       ______ ___ _________ _ _______ __ ___
            10.16.8    .AXHNX: r/s host-no-XON bit (AUXCAL fn 24)
                       _______ ___ ___________ ___ _______ __ ___
            10.16.8    .AXNTE: r/s no HT/VT/FF bit (AUXCAL fn 25)
                       _______ ___ __ ________ ___ _______ __ ___
            10.16.8    .AXTBK: r/s tabs-as-breaks bit (AUXCAL fn 26)
                       _______ ___ ______________ ___ _______ __ ___
            10.16.8    .AXWID: r/s line width (AUXCAL fn 27)
                       _______ ___ ____ _____ _______ __ ___
            10.16.8    .AXFC1: r/s filler class 1 (AUXCAL fn 30)
                       _______ ___ ______ _____ _ _______ __ ___
            10.16.8    .AXFC2: r/s filler class 2 (AUXCAL fn 31)
                       _______ ___ ______ _____ _ _______ __ ___
            10.16.8    .AXRMX: r/s remote-XON bit (AUXCAL fn 53)
                       _______ ___ __________ ___ _______ __ ___
            10.16.8    .AXRBS: r/s remote-BS-echo bit (AUXCAL fn 54)
                       _______ ___ ______________ ___ _______ __ ___
            10.16.8    .AXRVX: r/s reverse-XON bit (AUXCAL fn 55)
                       _______ ___ ___________ ___ _______ __ ___
            10.16.8    .AXTYP: r/s terminal type (AUXCAL fn 56)
                       _______ ___ ________ ____ _______ __ ___
            10.16.8    .AXBS: r/s BS-for-char-delete bit (AUXCAL fn 57)
                       ______ ___ __________________ ___ _______ __ ___
            10.16.8    .AXERA: r/s Erase-for-char-delete bit (AUXCAL fn 62)
                       _______ ___ _____________________ ___ _______ __ ___
            10.16.8    .AXEDE: r/s force deferred-echo bit (AUXCAL fn 63)
                       _______ ___ _____ _____________ ___ _______ __ ___
            10.16.8    .AXLCO: r/s Lower-case-output bit (AUXCAL fn 65)
                       _______ ___ _________________ ___ _______ __ ___
            10.16.8    .AXBBP: r/s backspace break/punctuation bit (AUXCAL fn 66)
                       _______ ___ _________ _________________ ___ _______ __ ___
            10.16.8    .AXSOX: r/s suppress output translation bit (AUXCAL fn 71)
                       _______ ___ ________ ______ ___________ ___ _______ __ ___
            10.16.8    .AXRUB: r/s ctrl H/rubout bit (AUXCAL fn 77)
                       _______ ___ ____ ________ ___ _______ __ ___
            10.16.8    .AXCLR: r/s special ctrl T mode (AUXCAL fn 101)
                       _______ ___ _______ ____ _ ____ _______ __ ____

                    MOVE    ac, [port,,function]
                    AUXCAL  ac, addr

            where <function> is one of the function codes

            and <addr> points to either
                    1) a word containing a negative number, in which case
                       AUXCAL reads the specified value into c(<addr>)
                    2) a word containing a positive number, in which case
                       c(<addr>) is swapped with the current setting of the
                       specified value

            Perform the normal AUXCAL checks (see 10-5).

            Set  <old>  to  the current  value  of  the specified  parameter.   If  c(<addr>) is
            nonnegative, set the specified parameter to c(<addr>).

            Set c(<addr>) to <old> and return.

            10.16.9    .AXTTP: r/s terminal class (AUXCAL fn 100)
                       _______ ___ ________ _____ _______ __ ____

                    MOVE    ac, [port,,.AXTTP]
                    AUXCAL  ac, addr

            and <addr> points to either
                    1) a word containing a negative number, in which case
                       AUXCAL reads the value of .AXTTP into c(<addr>)
                    2) a word containing a SIXBIT string in which case
                       c(<addr>) is swapped with the current setting of .AXTTP

            Perform the normal AUXCAL checks (see 10-5).

            If c(<addr>) is nonnegative, set .AXTTP to c(<addr>).








                                                   10-34


            June 27, 1984                            10                                 Port I/O


            10.17    Echo,Break,Backpressure UUOs
                     _______________________ ____

            10.17.1    .AXS8B: set image break char (AUXCAL fn 13)
                       _______ ___ _____ _____ ____ _______ __ ___

                    MOVE    ac, [port,,.AXS8B]
                    AUXCAL  ac, addr

            If c(<addr> bit 27) is 0, make <port> have no image break character.

            Otherwise, set the port's image break character to c(<addr> bits 28-35).

            Return.

            10.17.2    .AXSYB: send yellow ball (AUXCAL fn 12)
                       _______ ____ ______ ____ _______ __ ___

                    MOVE    ac, [port,,.AXSYB]
                    AUXCAL  ac,
                    only return

            10.17.3    .AXSOB: send orange ball (AUXCAL fn 70)
                       _______ ____ ______ ____ _______ __ ___

                    MOVE    ac,[port,,.AXSOB]
                    AUXCAL  ac,
                    only return

            This function performs a LEVDEF so that the orange ball is sent immediately.

            10.17.4    LEVDEF: leave deferred echo mode (CALLI -30)
                       _______ _____ ________ ____ ____ ______ ____
            10.17.4    .AXLDE: leave deferred echo mode (AUXCAL fn 11)
                       _______ _____ ________ ____ ____ _______ __ ___

                    LEVDEF
                    only return

                        or

                    MOVE    ac, [port,,.AXLDE]
                    AUXCAL  ac,
                    only return

            As soon as all echoing and output is done on the command port, reflect any  green or
            yellow balls that have arrived  or that subsequently arrive.  (This state  is turned
            off by the receipt of an "entering deferred echo mode" message).

            10.17.5    CLRBFI: clear input buffer (TTCALL 11)
                       _______ _____ _____ ______ _______ ___
            10.17.5    .AXCBI: clear input buffer (AUXCAL fn 6)
                       _______ _____ _____ ______ _______ __ __

                    CLRBFI

                        or

                    MOVE    ac, [port,,.AXCBI]
                    AUXCAL  ac,
                    only return

            (The AUXCAL is a no-op if <port> does not belong to the process).













                                                   10-35


            Port I/O                                 10                         YAMM edition 2.1


            10.17.6    CLRBFO: clear output buffer (TTCALL 12)
                       _______ _____ ______ ______ _______ ___
            10.17.6    .AXCBO: clear output buffer (AUXCAL fn 7)
                       _______ _____ ______ ______ _______ __ __

                    CLRBFO

                        or

                    MOVE    ac, [port,,.AXCBO]
                    AUXCAL  ac,
                    only return

            (The AUXCAL is a no-op if <port> does not belong to the process).


            10.18    Port Input UUOs
                     ____ _____ ____

            There are 8 different calls to read  a single 7-bit (or 8-bit if the port  data mode
            is Katakana) character from a port. The 8 calls correspond to the 8 combinations of
                1)  [CMD] Whether the call specifies a port or just uses the frame's command
                    port
                2)  [WAIT] Whether the call waits for a break or whether it  skip-returns if
                    there is a break and nonskips if there is not
                3)  [BKA] Whether the port's break-on-all bit is set, so that  any character
                    in the input buffer is considered a break, or whether it is cleared
            The calls are described below and summarized in Table 10-37 .

            10.18.1    INCHRW: input char [wait/bka] (TTCALL 0)
                       _______ _____ ____ __________ _______ __

                    INCHRW     addr
                    only return

            If the frame is detached, or if there are no characters in the port's  input buffer,
            cause an i/o wait software interrupt if the frame is enabled for one (setting .JBTPC
            to  point  to the  INCHRW),  otherwise wait  until  the frame  is  attached-to  or a
            character arrives.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Return.




























                                                   10-36


            June 27, 1984                            10                                 Port I/O


                                                Table 10-37 
                                                _____ _____ 
                                         Port Character Input Calls
                                         ____ _________ _____ _____


            CMD WAIT BKA  call

            *   *    *    INCHRW UUO (TTCALL 0, pg. 10-36)
                *    *    .AXICW UUO (AUXCAL fn 44, pg. 10-37)
            *        *    INCHRS UUO (TTCALL 2, pg. 10-37)
                     *    .AXICS UUO (AUXCAL fn 45, pg. 10-37)
            *   *         INCHWL UUO (TTCALL 4, pg. 10-38)
                *         .AXIWL UUO (AUXCAL fn 46, pg. 10-38)
            *             INCHSL UUO (TTCALL 5, pg. 10-38)
                          .AXISL UUO (AUXCAL fn 47, pg. 10-39)


            10.18.2    .AXICW: input char [wait/bka] (AUXCAL fn 44)
                       _______ _____ ____ __________ _______ __ ___

                    MOVE    ac, [port,,.AXICW]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there are no  characters in the port's input  buffer, cause an i/o  wait software
            interrupt if the frame is enabled  for one (setting .JBTPC to point to  the .AXICW),
            otherwise wait until a character arrives.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

            10.18.3    INCHRS: input char [skip/bka] (TTCALL 2)
                       _______ _____ ____ __________ _______ __

                    INCHRS     addr
                    no-data return
                    success return

            If the frame is detached, or if there are no characters in the port's  input buffer,
            just return.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

            10.18.4    .AXICS: input char [skip/bka] (AUXCAL fn 45)
                       _______ _____ ____ __________ _______ __ ___

                    MOVE    ac, [port,,.AXICS]
                    AUXCAL  ac, addr
                    error/no-data return
                    success return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there are no characters in the port's input buffer, just return.


                                                   10-37


            Port I/O                                 10                         YAMM edition 2.1


            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

            10.18.5    INCHWL: input char [wait] (TTCALL 4)
                       _______ _____ ____ ______ _______ __

                    INCHWL     addr
                    only return

            If the frame is  detached, or if there are  no break characters in the  port's input
            buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
            (setting  .JBTPC  to  point  to  the INCHWL),  otherwise  wait  until  the  frame is
            attached-to or a break character arrives.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Return.

            10.18.6    .AXIWL: input char [wait] (AUXCAL fn 46)
                       _______ _____ ____ ______ _______ __ ___

                    MOVE    ac, [port,,.AXIWL]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there  are no  break characters  in the port's  input buffer,  cause an  i/o wait
            software interrupt if the frame is  enabled for one (setting .JBTPC to point  to the
            .AXIWL), otherwise wait until a break character arrives.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

            10.18.7    INCHSL: input char [skip] (TTCALL 5)
                       _______ _____ ____ ______ _______ __

                    INCHSL     addr
                    no-data return
                    success return

            If the frame is  detached, or if there are  no break characters in the  port's input
            buffer, just return.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.













                                                   10-38


            June 27, 1984                            10                                 Port I/O


            10.18.8    .AXISL: input char [skip] (AUXCAL fn 47)
                       _______ _____ ____ ______ _______ __ ___

                    MOVE    ac, [port,,.AXISL]
                    AUXCAL  ac, addr
                    error/no-data return
                    success return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            If there are no break characters in the port's input buffer, just return.

            Remove one 7-bit (8-bit if the port's data mode is IO.KAT) character from  the input
            buffer, and store it, right-justified with leading bits zero, into <addr>.

            Skip-return.

            10.18.9    Image State
                       _____ _____

            There are three system calls which place the port into image state and then input an
            8-bit character:

            10.18.9.1    .AXI8C: input char [wait/bka/img] (AUXCAL fn 0)
                         _______ _____ ____ ______________ _______ __ __

                    MOVE    ac, [port,,.AXI8C]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Place the  port in  image state.   If there are  no characters  in the  port's input
            buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
            (setting .JBTPC to point to the .AXI8C), otherwise wait until a character arrives.

            Remove one 8-bit character from the input buffer, and store it, right-justified with
            leading bits zero, into <addr>.

            Skip-return.

            10.18.9.2    .AXI8S: input char [skip/bka/img] (AUXCAL fn 1)
                         _______ _____ ____ ______________ _______ __ __

                    MOVE    ac, [port,,.AXI8S]
                    AUXCAL  ac, addr
                    error/no-data return
                    success return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Place the  port in  image state.   If there are  no characters  in the  port's input
            buffer, just return.

            Remove one 8-bit character from the input buffer, and store it, right-justified with
            leading bits zero, into <addr>.

            Skip-return.

                                                   10-39


            Port I/O                                 10                         YAMM edition 2.1


            10.18.9.3    .AXI8B: input char [wait/img] (AUXCAL fn 2)
                         _______ _____ ____ __________ _______ __ __

                    MOVE    ac, [port,,.AXI8B]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Place the port in image state.  If there are no break characters in the port's input
            buffer,  cause an  i/o  wait software  interrupt if  the  frame is  enabled  for one
            (setting .JBTPC  to point  to the .AXI8B),  otherwise wait  until a  break character
            arrives.

            Remove one 8-bit character from the input buffer, and store it, right-justified with
            leading bits zero, into <addr>.

            Skip-return.

            10.18.10    Testing
                        _______

            A program can test whether there are break characters or any characters in  a port's
            input buffer.  The calls are shown below.

            10.18.11    Faking Input
                        ______ _____

            A program can  force a character string  into a port's input  buffer, in such  a way
            that  the characters  in the  string appear  to have  been typed  by the  user.  The
            program executes the .AXSI UUO (AUXCAL fn 33, pg. 10-41).

            10.18.12    Miscellaneous Command Port UUOs
                        _____________ _______ ____ ____

            A program can read the next character from the command port without removing it from
            the input buffer by executing the REDNXT UUO (CALLI -14, pg. 10-41).

            To wait for a character to arrive at the command port, a program executes the WAITCH
            UUO (CALLI -13, pg. 10-41).

            The CONT UUO (CALLI -125, pg. 10-43) allows a program to switch its command  port to
            user level from command level.  This is useful if a program running  detached wishes
            to receive input from  any terminal that reattaches.   See 10-2 for a  discussion of
            the significance of command and user levels.

            When the  monitor processes a  command line, it  does not remove  the line  from the
            command port's  input buffer,  but merely  sets a  bit which  causes the  next input
            operation to remove the line.  That  bit can be cleared (enabling a program  to read
            the line that caused it to be executed) with the RESCAN UUO (TTCALL 10, pg. 10-42).

            A rescan line can be forced by the .AXFRS UUO (AUXCAL fn 72, pg. 10-42).

            There is a  call originally used by  DDT for input from  the command port  which has
            some  rather  unique  (possibly  useless)  characteristics:  DDTIN   UUO  (CALLI +1,
            pg. 10-42).











                                                   10-40


            June 27, 1984                            10                                 Port I/O


            10.18.13    SKPINC: skip if char (TTCALL 13)
                        _______ ____ __ ____ _______ ___
            10.18.13    SKPINL: skip if break char (TTCALL 14)
                        _______ ____ __ _____ ____ _______ ___
            10.18.13    .AXSIC: skip if char (AUXCAL fn 10)
                        _______ ____ __ ____ _______ __ ___
            10.18.13    .AXSIL: skip if break char (AUXCAL fn 50)
                        _______ ____ __ _____ ____ _______ __ ___

                    SKPINC or SKPINL
                    no char or break char present
                    char or break char present

                    MOVE    ac, [port,,.AXSIC or .AXSIL]
                    AUXCAL  ac,
                    no char or break char present (or error)
                    char or break char present

            In the AUXCAL with  the command port specified, and  in the TTCALL, always  take the
            nonskip return if the frame  is running detached.  (The AUXCAL  also nonskip-returns
            if a port is specified which does not belong to the frame).

            If a character (SKPINC, .AXSIC) or a break character (SKPINL, .AXSIL) is  present in
            the port's input buffer, skip-return; otherwise nonskip-return.

            10.18.14    .AXSI: simulate input (AUXCAL fn 33)
                        ______ ________ _____ _______ __ ___

                    MOVE    ac, [port,,.AXSI]
                    AUXCAL  ac, addr
                      error return
                    normal return

            Perform the normal AUXCAL error-checking.  (See 10-5).

            Fetch characters one-by-one (as with  ILDB) from the byte pointer stored  at <addr>,
            and deposit the  right 8 bits  of each into <port>'s  input buffer.  Null  byte will
            terminate input.

            Skip-return.

            10.18.15    REDNXT: peek at input (CALLI -14)
                        _______ ____ __ _____ ______ ____

                    REDNXT  ac,
                    buffer-empty return
                    character-present return

            If the command port's input buffer is empty, nonskip-return.

            Otherwise, copy one 7-bit character  from the input buffer to  <ac>, right-justified
            with  leading  bits zero  (without  removing  that character  from  the  buffer) and
            skip-return.

            10.18.16    WAITCH: wait for input char (CALLI -13)
                        _______ ____ ___ _____ ____ ______ ____

                    WAITCH
                    only return

            If the command port's input buffer is not empty, just return; otherwise, wait  for a
            character to arrive, then return.













                                                   10-41


            Port I/O                                 10                         YAMM edition 2.1


            10.18.17    RESCAN: rescan command line (TTCALL 10)
                        _______ ______ _______ ____ _______ ___

                    RESCAN
                    only return

            Clear LC.ECS (see  Table 10-30 ) so that  subsequent input operations will  read the
            characters that  were read by  the monitor in  processing the last  command.  RESCAN
            must precede all terminal input operations in the program; the first  terminal input
            UUO which is executed  while LC.ECS is set  will cause the existing  monitor command
            line (a RUN, GET, START or similar command) to be thrown away.

            10.18.18    .AXFRS: force rescan string [CNT,PTR] (AUXCAL fn 72)
                        _______ _____ ______ ______ _________ _______ __ ___

                    MOVE    ac,[port,,.AXFRS]
                    AUXCAL  ac,addr
                     error return   ;ac/ return code
                    normal return

            addr:   0,,<count>
                    <bytepointer>

            where error code is
                code   name        error
                0      .FROK       no error
                1      .FRAUX      port is an aux circuit
                2      .FRBIG      command string is too big
                3      .FRCMD      port is in command state
                4      .FRBRK      break before end of command string (byte ptr updated)
                5      .FRNBK      no break encountered in string
                6      .FRFUL      rescan command already present

            If <port> is -1 and  the job is detached, or  if <port> specifies a port  which does
            not exist or belong to the caller, return.

            For each character in the string of length <count> pointed to by <bytepointer>, take
            the same action  as described for  .AXPTR UUO (AUXCAL fn 5,  pg. 10-46).  Characters
            only are placed in the port's input buffer and the rescan pointer is adjusted.

            Whenever this UUO returns to the caller, <count> and <bytepointer> are updated.

            10.18.19    DDTIN: DDT-mode input (CALLI +1)
                        ______ ________ _____ ______ ___

                    MOVEI   ac, addr
                    DDTIN   ac,
                    only return

            If the frame is running detached, just return.

            If the command port's input buffer  is empty, wait for a character to  arrive.  Then
            copy up to 104 (decimal) ASCII characters from the input buffer to the 21-word block
            starting at <addr>, followed by a NUL character.  (The NUL is always  inserted, even
            if there  are 105  characters or  more in the  port's input  buffer, so  <addr> will
            always point to an ASCIZ string).

            No special processing of character-delete or line-delete characters is done, and all
            characters are treated as breaks.












                                                   10-42


            June 27, 1984                            10                                 Port I/O


            10.18.20    CONT: Put port in user level (CALLI -125)
                        _____ ___ ____ __ ____ _____ ______ _____

                    CONT    0,      ;no arguments
                     error return
                    normal return

            If frame is detached, error return.

            Put the command port into "user level", and take the normal return.  See 10-2  for a
            discussion of Command and User Levels on a port.


            10.19    Output UUOs
                     ______ ____

            10.19.1    Single Character Output
                       ______ _________ ______

            There are a  number of system calls  to output a single  character to a  port.  They
            differ according to
                1)  [IMG]  Whether the  character  is output  as  an image  character  or is
                    subject to the normal processing (including tab simulation and the like)
                    for output characters.
                2)  [IMM] Whether the  UUO's argument is immediate  or whether it  points to
                    the character to be output.
                3)  [CMD] Whether the  call applies only to  the command port or  whether it
                    takes an argument specifying the port to be used.
            The calls are summarized in Table 10-43  and described in detail below.

            10.19.1.1    OUTCHR: output char [CMD] (TTCALL 1)
                         _______ ______ ____ _____ _______ __

                    OUTCHR     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the OUTCHR), otherwise wait  until the
            frame is attached-to.

            Let <char>  be c(<addr>).  Deposit  the rightmost 7  bits of <char>  (8 bits  if the
            port's data mode is IO.KAT) into the port's output buffer.

            Return.


                                                Table 10-43 
                                                _____ _____ 
                                        Port Character Output Calls
                                        ____ _________ ______ _____


            CMD IMM  IMG  Call
            *             OUTCHR UUO (TTCALL 1, pg. 10-43)
            *   *         OUTCHI UUO (TTCALL 16, pg. 10-44)
                *         .AXOCI UUO (AUXCAL fn 51, pg. 10-44)
            *             IONEOU UUO (TTCALL 15, pg. 10-44)
                     *    .AXO8 UUO (AUXCAL fn 3, pg. 10-44)
                *    *    .AXO8I UUO (AUXCAL fn 4, pg. 10-45)















                                                   10-43


            Port I/O                                 10                         YAMM edition 2.1


            10.19.1.2    OUTCHI: output char [CMD/IMM] (TTCALL 16)
                         _______ ______ ____ _________ _______ ___

                    OUTCHI     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the OUTCHI), otherwise wait  until the
            frame is attached-to.

            Let <char> be the effective address, <addr>.  Deposit the rightmost 7 bits of <char>
            (8 bits if the port's data mode is IO.KAT) into the port's output buffer.

            Return.

            10.19.1.3    .AXOCI: output char [IMM] (AUXCAL fn 51)
                         _______ ______ ____ _____ _______ __ ___

                    MOVE    ac,[port,,.AXOCI]
                    AUXCAL  ac,chr
                     only return

            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and  the job is detached, or  if <port> specifies a port  which does
            not exist or belong to the caller, return.

            Deposit the specified 7 bit character (8 bit if the port's data mode is IO.KAT) into
            the port's output buffer.

            return.

            10.19.1.4    IONEOU: output char [CMD/IMG] (TTCALL 15)
                         _______ ______ ____ _________ _______ ___

                    IONEOU     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the IONEOU), otherwise wait  until the
            frame is attached-to.

            Let  <char> be  c(<addr>).   Deposit the  rightmost 8  bits  of <char>  as  an image
            character into the port's output buffer.

            Return.

            10.19.1.5    .AXO8: output char [IMG] (AUXCAL fn 3)
                         ______ ______ ____ _____ _______ __ __

                    MOVE    ac, [port,,.AXO8]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Let  <char> be  c(<addr>).   Deposit the  rightmost 8  bits  of <char>  as  an image
            character into the port's output buffer.

            Return.






                                                   10-44


            June 27, 1984                            10                                 Port I/O


            10.19.1.6    .AXO8I: output char [IMG/IMM] (AUXCAL fn 4)
                         _______ ______ ____ _________ _______ __ __

                    MOVE    ac, [port,,.AXO8I]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            Let <char> be the effective address, <addr>.  Deposit the rightmost 8 bits of <char>
            as an image character into the port's output buffer.

            Return.

            10.19.2    String Output
                       ______ ______

            There  are  6  system calls  to  output  a  string to  a  port,  which  have varying
            combinations of
                1)  [CMD] The call  applies only to the  command port rather than  taking an
                    argument specifying the port to be used.
                2)  [PTR] The call takes as its argument the address of a byte pointer (thus
                    allowing the call to be interrupted if the port's output  buffer becomes
                    full, since the monitor modifies  the byte pointer to point to  the next
                    character to be processed, and allowing non-standard byte sizes  to some
                    extent), rather than the address  of an ASCIZ string (in which  case the
                    monitor cannot  take an  i/o wait  software interrupt  in the  middle of
                    outputting the string, and the characters must always be 7 bits, even in
                    Katakana mode)
                3)  [STR] Same as PTR except  user supplies a half-word count  of characters
                    to  be output  rather than  providing  a null  at the  end.   The string
                    descriptor consists  of the character  count in the  first word  and the
                    ILDB byte pointer in the second  word.  The left half of the  first word
                    is unused.
            The calls are summarized in Table 10-46  and described in detail below.

            10.19.2.1    OUTSTR: output string [STR/CMD] (TTCALL 3)
                         _______ ______ ______ _________ _______ __

                    OUTSTR     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the OUTSTR), otherwise wait  until the
            frame is attached-to.

            For each character in the ASCIZ string pointed to by <addr>:

                If the port's output buffer is full, wait until there is room in  the buffer
                (regardless  of  whether  the  frame  has  enabled  an  i/o   wait  software
                interrupt).

                Deposit the character in the port's output buffer.

            Return.











                                                   10-45


            Port I/O                                 10                         YAMM edition 2.1


                                                Table 10-46 
                                                _____ _____ 
                                          Port String Output Calls
                                          ____ ______ ______ _____


            CMD PTR  STR  call

            *             OUTSTR UUO (TTCALL 3, pg. 10-45)
                          .AXOST UUO (AUXCAL fn 52, pg. 10-47)
            *   *         OUTPTR UUO (TTCALL 17, pg. 10-46)
                *         .AXPTR UUO (AUXCAL fn 5, pg. 10-46)
                     *    .AXOPC UUO (AUXCAL fn 67, pg. 10-47)
                     *    .AXOSF UUO (AUXCAL fn 76, pg. 10-47)


            10.19.2.2    OUTPTR: output string [PTR/CMD] (TTCALL 17)
                         _______ ______ ______ _________ _______ ___

                    OUTPTR     addr
                    only return

            If the  frame is  detached, cause  an i/o wait  software interrupt  if the  frame is
            enabled for one (setting  .JBTPC to point to  the OUTPTR), otherwise wait  until the
            frame is attached-to.

            For each character in the null-terminated  string pointed to by the byte  pointer in
            c(<addr>):

                If the port's output buffer  is full, cause an i/o error  software interrupt
                if the frame is enabled for one (setting .JBTPC to point to the  OUTPTR, and
                modifying c(<addr>) to  point to the character  that would have  been output
                next), otherwise wait until there is room in the buffer.

                Deposit the  character in the  port's output buffer.   (If the byte  size is
                greater  than  8 bits,  only  the rightmost  8  bits of  each  byte  will be
                deposited, and if the level-9 bit  is 1, the character will be  deposited as
                an image character).

            Return.

            10.19.2.3    .AXPTR: output string [PTR] (AUXCAL fn 5)
                         _______ ______ ______ _____ _______ __ __

                    MOVE    ac, [port,,.AXPTR]
                    AUXCAL  ac, addr
                    only return


            where <port> is -1 to specify the frame's command port,
            or the port number of some port owned by the frame

            If <port> is -1 and the frame is detached, or if <port> is not -1 and  the specified
            port does not exist or does not belong to the frame, return.

            For each character in the null-terminated  string pointed to by the byte  pointer in
            c(<addr>):

                If the port's output buffer  is full, cause an i/o error  software interrupt
                if the frame is enabled for one (setting .JBTPC to point to the  .AXPTR, and
                modifying c(<addr>) to  point to the character  that would have  been output
                next), otherwise wait until there is room in the buffer.

                Deposit the  character in the  port's output buffer.   (If the byte  size is
                greater  than  8 bits,  only  the rightmost  8  bits of  each  byte  will be
                deposited, and if the level-9 bit  is 1, the character will be  deposited as
                an image character).

            Return.



                                                   10-46


            June 27, 1984                            10                                 Port I/O


            10.19.2.4    .AXOST: output string (AUXCAL fn 52)
                         _______ ______ ______ _______ __ ___

                    MOVE    ac,[port,,.AXOST]
                    AUXCAL  ac,addr
                    only return

            addr:   <bytepointer>

            where <port> is -1 to specify the frame's command port, or the port
            number of some port owned by the frame

            If <port> is -1 and  the job is detached, or  if <port> specifies a port  which does
            not exist or belong to the caller, return.

            For each character in the ASCIZ string pointed to by <addr>,

                If the port's output buffer is full, wait until there is room in  the buffer
                (regardless  of  whether  the  frame  has  enabled  an  i/o   wait  software
                interrupt).

                Deposit the character in the port's output buffer.

            Return.

            10.19.2.5    .AXOPC: output string [STR] (AUXCAL fn 67)
                         _______ ______ ______ _____ _______ __ ___

                    MOVE    ac,[port,,.AXOPC]
                    AUXCAL  ac,addr
                    only return

            addr:   0,,<count>
                    <bytepointer>

            If <port> is -1 and  the job is detached, or  if <port> specifies a port  which does
            not exist or belong to the caller, return.

            For each character in the string of length <count> pointed to by <bytepointer>, take
            the same action as described for .AXPTR UUO (AUXCAL fn 5, pg. 10-46).

            Whenever this UUO returns to the caller, <count> and <bytepointer> are updated.

            10.19.2.6    .AXOSF: output string, never wait [STR] (AUXCAL fn 76)
                         _______ ______ _______ _____ ____ _____ _______ __ ___

                    MOVE    ac,[port,,.AXOSF]
                    AUXCAL  ac,addr
                     error return           ;output incomplete
                    normal return           ;output complete

            addr:   0,,<count>
                    <bytepointer>

            If block output is  already in progress when function  is called or if <port>  is -1
            and the  job is  detached, or if  <port> specifies  a port which  does not  exist or
            belong to the caller, error return without updating <count> and <bytepointer>.

            Output as many characters from the string as will fit in the buffer  without putting
            the user into  output wait.  When  all characters have been  output (count =  0), or
            when no more will  fit, update the <count>  and <bytepointer> in the  user's address
            space,  and  return.  If  the  output completed,  skip  return,  otherwise, non-skip
            return.  Otherwise, take the same  action as described for .AXPTR  UUO (AUXCAL fn 5,
            pg. 10-46).

            Whenever this UUO returns to the caller, including to service a  software interrupt,
            <count> and <bytepointer> are updated.




                                                   10-47


            Port I/O                                 10                         YAMM edition 2.1


            10.19.2.7    DDTOUT: DDT-mode output (CALLI +3)
                         _______ ________ ______ ______ ___

                    MOVEI   ac, addr
                    DDTOUT  ac,
                    only return

            Equivalent to the OUTSTR TTCALL.


            10.20    Port Block I/O UUOs
                     ____ _____ ___ ____

            10.20.1    .AXEBM: enter block i/o mode (AUXCAL fn 34)
                       _______ _____ _____ ___ ____ _______ __ ___

                    MOVE    ac, [port,,.AXEBM]
                    AUXCAL  ac,
                      error return
                    normal return

            If the base rejected the monitor's request to establish another block i/o port, take
            the error-return; otherwise, place the port in block i/o mode and skip-return.

            10.20.2    .AXLBM: leave block i/o mode (AUXCAL fn 42)
                       _______ _____ _____ ___ ____ _______ __ ___

                    MOVE    ac, [port,,.AXLBM]
                    AUXCAL  ac,
                    only return

            If block output is pending on the port, wait for it to complete.  Then take the port
            out of block i/o mode and return.

            (Block input requested but not yet received will be lost).

            10.20.3    .AXIBW: input block and wait (AUXCAL fn 35)
                       _______ _____ _____ ___ ____ _______ __ ___

                    MOVE    ac, [port,,.AXIBW]
                    AUXCAL  ac, addr
                      error return
                    normal return

            where <addr> is the address of a block i/o buffer (see 10-22)

            If <port> is not in block i/o mode, take the error return.

            If there is no more data for  the port (EOT received or .AXTBI done), set  IO.EOF in
            the file status bits and skip-return.

            If there  is data  waiting for  the port, copy  it into  the user's  buffer, setting
            c(<addr>) to the  number of bytes transferred,  request another block of  input from
            the base (the same size as the last request), and skip-return.

            If no block input request is pending, request c(<addr>) bytes of data from the base.

            Wait for the data to arrive.  If the circuit is zapped while  waiting, error-return;
            otherwise, copy the data received  into the user's buffer, setting c(<addr>)  to the
            number of bytes received, and skip-return.













                                                   10-48


            June 27, 1984                            10                                 Port I/O


            10.20.4    .AXIBS: input block and skip (AUXCAL fn 36)
                       _______ _____ _____ ___ ____ _______ __ ___

                    MOVE    ac, [port,,.AXIBS]
                    AUXCAL  ac, addr
                      error,no-data return
                    data-present return

            where <addr> is the address of a block i/o buffer (see 10-22)

            If <port> is not in block i/o mode, take the error return.

            If there is no more data for  the port (EOT received or .AXTBI done), set  IO.EOF in
            the file status bits and skip-return.

            If there  is data  waiting for  the port, copy  it into  the user's  buffer, setting
            c(<addr>) to the  number of bytes transferred,  request another block of  input from
            the base (the same size as the last request), and skip-return.

            If no block input request is pending, request c(<addr>) bytes of data from  the base
            and take the error return.

            10.20.5    .AXTBI: terminate block input (AUXCAL fn 40)
                       _______ _________ _____ _____ _______ __ ___

                    MOVE    ac, [port,,.AXTBI]
                    AUXCAL  ac,
                    only return

            If the <port> is not in block i/o mode, just return.

            If no block input is pending, and the program has read all the data in the monitor's
            buffers, just set IO.EOF and return.

            Otherwise, request block  input termination from the  base and return.   The monitor
            will not send any  more input requests to the  base until the program  has exhausted
            all the data, by doing block inputs until IO.EOF is set in the file status bits.

            10.20.6    .AXOB: block output (AUXCAL fn 37)
                       ______ _____ ______ _______ __ ___

                    MOVE    ac, [port,,.AXOB]
                    AUXCAL  ac, addr

            where <addr> is the address of a block i/o buffer (see 10-22)

            If a block output is already in progress, wait for it to complete, taking  the error
            return if the port is zapped while waiting.

            Transfer the data from the user's buffer to the port's block output  buffer, request
            a block output operation from the base, and skip-return.

            10.20.7    .AXTBO: terminate block output (AUXCAL fn 41)
                       _______ _________ _____ ______ _______ __ ___

                    MOVE    ac, [port,,.AXTBO]
                    AUXCAL  ac,
                    only return

            If <port>  is not in  block i/o mode,  just return; otherwise,  send a  block output
            termination message to the base and return.











                                                   10-49


            Port I/O                                 10                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   10-50


            June 27, 1984                            11                        Magnetic Tape I/O


                                                 Section 11
                                                 _______ __
                                             Magnetic Tape I/O
                                             ________ ____ ___

                                             Table of Contents



            SubSection


            11.1     Device Names    11-1

            11.2     Recording Modes    11-1

            11.3     Parity    11-1

            11.4     Recording Density    11-1

            11.5     Begin and End of Tape Bits    11-2

            11.6     Buffered Tape I/O    11-2

            11.7     Dump Tape I/O    11-2
            11.7.1      Non-Integral Word Counts    11-2
            11.7.2      Actual Word/Byte Counts    11-3

            11.8     MTAPE Operations    11-3
            11.8.1      MTAPE: perform magtape functions (op code 072)    11-3
            11.8.1      .CHMTA: perform magtape functions (CHANIO fn 12)    11-3

            11.9     UGETF Information    11-4


            Table

            11-4     MTAPE Functions    11-4
            11-5     UGETF Function Codes    11-5
            11-5b    FTA: File Status Bits    11-5






























                                                    11-i


                                                     11                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   11-ii


            June 27, 1984                            11                        Magnetic Tape I/O





                                                 Section 11
                                                 _______ __
                                             Magnetic Tape I/O
                                             ________ ____ ___





            11.1    Device Names
                    ______ _____

            Magnetic tape drives have mnemonics of the form

                    FTkn

            where  <k>  is  a letter  specifying  a  controller  (A for  the  first,  B  for the
            second,...) and  <n> is a  digit specifying a  drive on that  controller (0  for the
            first, 1 for the second,...).


            11.2    Recording Modes
                    _________ _____

            The monitor supports four recording modes for magnetic tape i/o:
                1)  a DEC-compatible 7-track mode, in which each word in core is transferred
                    as six 6-bit bytes, with odd parity.
                2)  a DEC-compatible 9-track mode, in which each word in core is transferred
                    as four 8-bit bytes followed by one right-adjusted 4-bit byte,  with odd
                    parity.
                3)  an IBM-compatible 9-track mode, in which the high-order 32 bits  of each
                    word in core are transmitted  as four 8-bit bytes, with odd  parity, and
                    the low-order 4 bits of each word in core are ignored.
                4)  a special  7-track mode, in  which each word  in core is  transmitted as
                    four 6-bit bytes  (the low-order 6 bits  of each of the  four high-order
                    8-bit bytes of the word in core), with either even or odd parity.
            The transfer mode is settable with the MTAPE UUO (op code 072, pg. 11-3).


            11.3    Parity
                    ______

            Hardware  restrictions prevent  the use  of even  parity in  other than  the special
            7-track recording mode described above.  The monitor will permit either parity to be
            set in any recording mode,  but will set IO.IMP in  the file status bits as  soon as
            the program tries a  tape operation if even parity  is specified for other  than the
            special 7-track mode.

            The parity bit is bit 26 of the  file status bits.  Even parity is 1 and  odd parity
            0.


            11.4    Recording Density
                    _________ _______

            The tape units supported by the monitor have either 6250, 6250/1600, 1600, 1600/800,
            800/556, or 800/556/200  BPI densities, depending on  the unit and  controller.  The
            recording density is specified by bits 27-28 of the file status bits.

            Their interpretation is

                    0  system standard density (presently highest)
                    1  lowest density of which the unit is capable
                    2  medium density "    "    "   "   "    "
                    3  highest density"    "    "   "   "    "

            For units capable of  only one density, the  contents of this field  are irrelevant;
            for units capable of  only two densities, the "medium  density" code is the  same as
            the "lowest density".


                                                    11-1


            Magnetic Tape I/O                        11                         YAMM edition 2.1


            The densities of which a particular unit is capable can be read using the  UGETF UUO
            (op code 073, pg. 8-32).


            11.5    Begin and End of Tape Bits
                    _____ ___ ___ __ ____ ____

            The "at load point" bit, bit 3 of the word returned by the .UGSTS function of UGETF,
            is cleared  when a  magtape is  initted, then  set or  cleared appropriately  by the
            monitor whenever  it performs  a tape-moving operation.  Manually rewinding  a tape,
            however, will not set the bit.

            The "past end-of-tape marker" bit, bit 4 of the word returned by the .UGSTS function
            of UGETF, is cleared whena magtape is initted, then set or cleared  appropriately by
            the monitor when it performs any tape-moving function other than a  read operations.
            A read operation neither sets not clears the bit.


            11.6    Buffered Tape I/O
                    ________ ____ ___

            Buffered magtape i/o  can be performed in  ASCII, ASCII line (=ASCII),  image, image
            binary (=image), or binary (=image) mode.

            In ASCII mode, the byte size is 7 bits; in image mode it is 36 bits.   Regardless of
            the mode used, the user's buffer is treated as containing 36 bit words.

            The standard buffer size is 131 (decimal) words (128 data + 3 header).


            11.7    Dump Tape I/O
                    ____ ____ ___

            Either dump or  dump records mode i/o  can be done on  magtape.  In dump  mode, each
            iowd reads or writes one magtape record; in dump records mode, each iowd larger than
            128 (decimal) words is broken up into one or more standard-sized (128-word) requests
            followed (if necessary) by one short request.

            On  input, if  the record  read is  smaller than  the request,  the length  error is
            ignored; if the record  read is larger than the  request, IO.BKT is set in  the file
            status bits, and input terminates at the end of the current iowd.

            11.7.1    Non-Integral Word Counts
                      ____________ ____ ______

            In  the IBM-compatible  9-track mode  and the  special 7-track  mode, a  program can
            specify a non-integral number of words  to input or output (in dump or  dump records
            mode only).  This  is useful when text  is being read or  written and the  number of
            bytes in a record is not a multiple of 4.

            The monitor maintains  a "byte adjust" value  for this purpose. It  can be set  to a
            value from  0 through 3  to specify how  many bytes fewer  than four times  the word
            count should  be transferred.   For example,  with a word  count of  100 and  a byte
            adjust  value of  1, 99  full words  would be  written (366  bytes) followed  by the
            high-order 3 bytes of the 100th word.

            The byte adjust value is specified along with the transmission mode using  the MTAPE
            UUO (op code 072,  pg. 11-3).  If a  program attempts to  set a nonzero  byte adjust
            and the data mode is not dump or dump records, MTAPE will force the byte adjust to 0
            and set IO.IMP in the file status bits.












                                                    11-2


            June 27, 1984                            11                        Magnetic Tape I/O


            11.7.2    Actual Word/Byte Counts
                      ______ _________ ______

            The number of words (or bytes in  IBM mode) actually read by an input  operation can
            be obtained with the .UGCNT function of the UGETF UUO (op code 073, pg. 8-32).


            11.8    MTAPE Operations
                    _____ __________

            Most  magtape  control  functions  are  performed  by  the  MTAPE  UUO (op code 072,
            pg. 11-3).  The functions performed are described in Table 11-4 .

            11.8.1    MTAPE: perform magtape functions (op code 072)
                      ______ _______ _______ _________ ___ ____ ____
            11.8.1    .CHMTA: perform magtape functions (CHANIO fn 12)
                      _______ _______ _______ _________ _______ __ ___

                    MTAPE   channel, function
                    only return

                    MOVE    ac, [.CHMTA,,channel]
                    CHANIO  ac, function
                    only return

            where <function> is a function code from Table 11-4 

            If <channel> is not initted, abort the process and store halt status HT.IUC  for the
            frame.  If the device initted is not a magtape, just return; otherwise, wait for the
            device to become inactive, then perform the specified function.

            If the drive is past the EOT marker or any of the error bits (bits 18-22) are set in
            the  file status  bits, cause  an  i/o-error software  interrupt if  the  process is
            enabled for one.  Return.






































                                                    11-3


            Magnetic Tape I/O                        11                         YAMM edition 2.1


                                                Table 11-4 
                                                _____ ____ 
                                              MTAPE Functions
                                              _____ _________


            name     code  function

            .MTWAT   0     wait for i/o completion
            .MTREW   1     rewind
            .MTEOF   3     write tape mark
            .MTSKR   6     skip forward 1 record
            .MTBSR   7     backspace 1 record
            .MTEOT   10    go to logical end of tape
            .MTUNL   11    rewind and unload
            .MTBLK   13    erase gap
            .MTSKF   16    skip forward 1 file
            .MTBSF   17    backspace 1 file
            .MTDEC   100   set DEC 9-track mode
            .MTIC0   101   set IBM 9-track mode, byte adjust 0
            .MTIC1   102   set IBM 9-track mode, byte adjust 1
            .MTIC2   103   set IBM 9-track mode, byte adjust 2
            .MTIC3   104   set IBM 9-track mode, byte adjust 3
            .MT7E0   201   set special 7-track mode, byte adjust 0
            .MT7E1   202   set special 7-track mode, byte adjust 1
            .MT7E2   203   set special 7-track mode, byte adjust 2
            .MT7E3   204   set special 7-track mode, byte adjust 3


            The MTAPE UUO can also be used to program a KS2020 line printer (LP20) Direct Access
            Verticl Format Unit (see 13-1).


            11.9    UGETF Information
                    _____ ___________

            The  UGETF  UUO  (op code 073,  pg. 8-32)  is  used  to  obtain  various  pieces  of
            information about the status of a process's magtape i/o.


                    UGETF <channel>,<addr>
                    only return

            ADDR:   <count>,,<function>
                    ...
                    data returned here
                    ...

            If <function> is not one of the codes described in Table 11-5  set <ADDR> to  -1 and
            return.

            If  <function>  is  .UGCNT or  .UGSTS,  ignore  <count>.  Return  data  as  shown in
            Table 11-5 .


















                                                    11-4


            June 27, 1984                            11                        Magnetic Tape I/O


                                                Table 11-5 
                                                _____ ____ 
                                            UGETF Function Codes
                                            _____ ________ _____


            name     code  function

            .UGCNT   0     return byte/word count of last input
            .UGSEN   1     return drive sense data
            .UGSTS   2     return drive status data - for .UGSEN, return up to 6 words of unit
                           sense data; for .UGSTS, return 1 word of compacted sense data as
                           follows:
                           MT.PRO    1B0   write protected
                           MT.TAB    3B2   TU A & B
                           MT.LDP    1B3   load point
                           MT.EOT    1B4   end of tape indicator
                           MT.IBM    1B5   IBM compatible unit
                           MT.7TR    1B12  7 track capability
                           MT6250    1B13  6250 bpi capability
                           MT1600    1B14  1600 bpi
                           MT800     1B15  800 bpi
                           MT556     1B16  556 bpi
                           MT200     1B17  200 bpi



                                                Table 11-5b
                                                _____ _____
                                           FTA: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode - even parity set in 9-track mode or attempt to set a
                           nonzero byte adjust while data mode not dump or dump records
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large - input record on tape longer than IOWD specified
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.EVP   1B26  even parity
            IO.DEN   3B28  recording density - 0 = default density - 1 = lowest density - 2 =
                           middle density - 3 = highest density
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask























                                                    11-5


            Magnetic Tape I/O                        11                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    11-6


            June 27, 1984                            12                        Card Reader Input


                                                 Section 12
                                                 _______ __
                                             Card Reader Input
                                             ____ ______ _____

                                             Table of Contents



            SubSection


            12.1     ASCII Mode Input    12-1

            12.2     Image Mode Input    12-1

            12.3     Binary Mode Input    12-1


            Table

            12-2     026 Card Codes    12-2
            12-2b    029 Card Codes    12-2
            12-3     CDR: File Status Bits    12-3














































                                                    12-i


                                                     12                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   12-ii


            June 27, 1984                            12                        Card Reader Input





                                                 Section 12
                                                 _______ __
                                             Card Reader Input
                                             ____ ______ _____




            Card  input can  be performed  in ASCII,  ASCII line  (=ASCII), image,  image binary
            (=image), or binary mode.

            The standard buffer size for buffered i/o is 30 words, regardless of the input mode.

            There is no special action on CLOSE or RELEAS.

            The card reader has the device mnemonic CDR.


            12.1    ASCII Mode Input
                    _____ ____ _____

            Each card is read as 80 7-bit ASCII characters, followed by a carriage  return ('15)
            and a linefeed ('12).

            Two card codes  are supported, one  for 026 (see Table 12-2 )  and one for  029 (see
            Table 12-2b) keypunches.  Initially, the 029 code is assumed.

            The following special codes are recognized if they appear in column 1 of a card:

                    12-11-0-1-6-7-8-9       end-of-file
                    12-2-4-8                switch to 026 code
                    12-0-2-4-6-8            switch to 029 code


            12.2    Image Mode Input
                    _____ ____ _____

            Each  card is  read as  80  12-bit bytes  (one per  column).  No  special  codes are
            recognized, but the hardware end-of-file condition will result in IO.EOF being set.


            12.3    Binary Mode Input
                    ______ ____ _____

            Cards in binary mode have the format:

                    col 1  row 6-9  7-9 punch
                    col 1  row 12-3 word count
                    col 2           checksum
                    col 3-5         first word of data
                    col 6-8         second word of data
                    ...

            On binary mode input, the monitor  saves the checksum and word count,  then attempts
            to read the specified number of words from the card reader, three card columns  to a
            word.

            If the input  record is too  long to fit  into the user's  buffer, or if  a hardware
            end-of-file indication is  received before the specified  number of words  have been
            read, IO.BKT is set in the file status bits.  If the record can all be read, but the
            checksum computed by  the monitor differs  from that read  from the card,  IO.DTE is
            set.  Whether an error occurred or not, the checksum and word count read  are stored
            as the left and right halves of the third word (word 2) of the user's buffer.







                                                    12-1


            Card Reader Input                        12                         YAMM edition 2.1


                                                Table 12-2 
                                                _____ ____ 
                                               026 Card Codes
                                               ___ ____ _____


                                    none    12      11      0
                            none    space   +       -       0
                            1       1       A       J       /
                            2       2       B       K       S
                            3       3       C       L       T
                            4       4       D       M       U
                            5       5       E       N       V
                            6       6       F       O       W
                            7       7       G       P       X
                            8       8       H       Q       Y
                            9       9       I       R       Z
                            8-2     _       ?       :       ;
                            8-3     =       .       $       ,
                            8-4     @       )       *       (
                            8-5     ^       ]       [       "
                            8-6     '       <       >       #
                            8-7     \       !       &       %



                                                Table 12-2b
                                                _____ _____
                                               029 Card Codes
                                               ___ ____ _____


                                    none    12      11      0
                            none    space   &       -       0
                            1       1       A       J       /
                            2       2       B       K       S
                            3       3       C       L       T
                            4       4       D       M       U
                            5       5       E       N       V
                            6       6       F       O       W
                            7       7       G       P       X
                            8       8       H       Q       Y
                            9       9       I       R       Z
                            8-2     :       [       !       ]
                            8-3     #      .       $       ,
                            8-4     @       <       *       %
                            8-5     '       (       )       _
                            8-6     =       +       ;       >
                            8-7     "       ^       \       ?























                                                    12-2


            June 27, 1984                            12                        Card Reader Input


                                                Table 12-3 
                                                _____ ____ 
                                           CDR: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode - no 7-9 punch in column 1 on binary input
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file - (12-11-0-1-6-7-8-9) card read in ASCII mode or hardware
                           EOF signal from card reader in any mode
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask



















































                                                    12-3


            Card Reader Input                        12                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    12-4


            June 27, 1984                            13                      Line Printer Output


                                                 Section 13
                                                 _______ __
                                            Line Printer Output
                                            ____ _______ ______

                                             Table of Contents



            SubSection


            13.1     Output    13-1

            13.2     Form Feeds    13-1

            13.3     KS2020 Line Printer Forms Control    13-1





















































                                                    13-i


                                                     13                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   13-ii


            June 27, 1984                            13                      Line Printer Output





                                                 Section 13
                                                 _______ __
                                            Line Printer Output
                                            ____ _______ ______




            Line printer output can be performed in ASCII, ASCII line (=ASCII), or image mode.

            The standard buffer size for buffered output is 28 words (25 data+3 header),  or 125
            ASCII characters.

            The line printer has the device mnemonic LPT.


            13.1    Output
                    ______

            In line printer output, the  contents of the user's buffer are  transferred, without
            processing, directly to the line printer.   In ASCII mode, the byte size is  7 bits;
            in image mode, the  byte size is 36  bits, but each word  is still treated as  if it
            contained five 7-bit bytes, left-justified.


            13.2    Form Feeds
                    ____ _____

            The monitor normally supplies a free carriage-return, form feed sequence  before the
            first  output after  the line  printer is  initted or  CLOSEd.  This  action  can be
            suppressed by setting the "no free form feed" bit, bit 29 of the file status bits.


            13.3    KS2020 Line Printer Forms Control
                    ______ ____ _______ _____ _______

            The LP20  line printer which  is available  on systems with  a KS2020  processor has
            provisions  for  user  control  of  the  form  size  and  other  vertical formatting
            parameters.  The LP20 has a Direct Access Vertical Format Unit, or DAVFU,  which can
            be programmed  from the host.   The user  program can accomplish  this by  using the
            MTAPE UUO on a channel on which the LPT is initted:

                    MTAPE   channel,CLIST
                     error return           ;error in command list
                    normal return

            CLIST: block N  ;DAVFU command list

            where <channel> is the channel on which the device is initted,
            and CLIST is an arbitrary-length block of data which is a
            DAVFU "program".

            The CLIST commands  allow the user to  set or reset stops  on any of the  12 control
            channels which govern page up-spacing.  A command is also provided to  allow setting
            form size and page length.  Each CLIST command occupies one PDP-10 36-bit word.  The
            CLIST must terminate with the RELOAD DAVFU command.

            A detailed description of the commands follows:

              OPCODE                        COMMAND
              -----   -------------------------------------------------------
               0 0    CLEAR STOPS ON MASKED CHANNELS from first line to last line
               0 1    SET STOPS ON MASKED CHANNELS from first line to last line
               1 0    RESET TOP OF FORM
               1 1    RELOAD DAVFU and terminate command list


                                 C O M M A N D     B I T S
            ____________________________________._________________________________
                              1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3|
                                                    13-1


            Line Printer Output                      13                         YAMM edition 2.1


            0 1 2 3-5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5|
            _.___.___._______________________|_._______________._._______________|
            x|0 0| x |     channel mask      |x|  first line   |x|   last line   |
            _|___|___|_______________________|_|_______________|_|_______________|
            x|0 1| x |     channel mask      |x|  first line   |x|   last line   |
            _|___|___|_______________________|_|_______________|_|_______________|
            x|1 0| x |x x x x x x x x x x x x|x|0 0 0 0 0 0 0 1|x|0 0 0 0 0 0 0 1|
            _|___|___|_______________________|_|_______________|_|_______________|
            x|1 1| x |x x x x x x x x x x x x|x|  page length  |x|   form size   |
            _|___|___|_______________________|_|_______________|_|_______________|
             |CMD|   |1 1 1                  |
             +---+   |2 1 0 9 8 7 6 5 4 3 2 1|
                     |   CHANNEL  NUMBERS    |
                     +-----------------------+

            Note:
                1)  Channel numbers increase from right to left, not in  normal bit-ordering
                    sequence from left to right.
                2)  Last line and form size must be less than or equal to 143.
                3)  First line must be positive and less than or equal to last line.
                4)  Page length must be greater than 8 but less than or equal to form size.
                5)  The RESET TOP of  FORM command must be  the only command in  the command
                    list, if it is  used at all.  Its first  and last line fields  should be
                    set to 1.












































                                                    13-2


            June 27, 1984                            14                           Paper Tape I/O


                                                 Section 14
                                                 _______ __
                                               Paper Tape I/O
                                               _____ ____ ___

                                             Table of Contents



            SubSection


            14.1     Leaders and Trailers    14-1

            14.2     ASCII Mode I/O    14-1

            14.3     Image Mode I/O    14-1

            14.4     Image Binary Mode I/O    14-1

            14.5     Binary Mode I/O    14-2


            Table

            14-2     CDR: File Status Bits    14-2












































                                                    14-i


                                                     14                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   14-ii


            June 27, 1984                            14                           Paper Tape I/O





                                                 Section 14
                                                 _______ __
                                               Paper Tape I/O
                                               _____ ____ ___




            Paper tape i/o can be performed in ASCII, ASCII line (=ASCII), image,  image binary,
            or binary mode.

            The standard buffer size for buffered-mode input and output is 35 words (32 data + 3
            header), regardless of the data mode.

            The paper  tape reader has  the device mnemonic  PTR; the paper  tape punch  has the
            mnemonic PTP.


            14.1    Leaders and Trailers
                    _______ ___ ________

            The  monitor inserts  128 NUL  characters (no  punches) as  leader before  the first
            output  after the  device is  initted, and  128 NULs  trailer characters  after each
            CLOSE.


            14.2    ASCII Mode I/O
                    _____ ____ ___

            The byte size is 7 bits.

            On output, the  monitor takes 7-bit ASCII  characters (left-justified, 5 to  a word)
            from the  user's buffer,  computes the necessary  level-8 bit  for even  parity, and
            punches the resultant 8-bit character.   Form feeds are output followed by  16 NULs,
            HTs and VTs are followed by a rubout character, and NULs are ignored (not punched).

            On input, the 8-bit codes '000,  '200, and '377 are ignored; otherwise, the  right 7
            bits  of  each  frame  read  are stored  in  the  user's  buffer,  left-justified, 5
            characters to a word.  The physical end-of-tape causes IO.EOF to be set in  the file
            status bits.


            14.3    Image Mode I/O
                    _____ ____ ___

            The byte size is 36 bits.

            On output, the low-order 8 bits of each word in the user's buffer are output without
            processing by the monitor.

            On input, the 8-bit frames read are stored, one per word, right-justified,  into the
            user's buffer,  with the high-order  28 bits of  each word set  to 0.   The physical
            end-of-tape causes IO.EOF to be set in the file status bits.


            14.4    Image Binary Mode I/O
                    _____ ______ ____ ___

            The byte size is 36 bits.

            On output, each word in the user's  buffer is split into 6-bit bytes, and  each byte
            is ORed with '200 before being punched.  For example,

                    010203,,040506

            would be punched as

                    '201, '202, '203, '204, '205, '206

            On input, each frame is truncated  to 6 bits by discarding the high-order  two bits,
            and the resultant characters are packed 6 to a word into the user's buffer.
                                                    14-1


            Paper Tape I/O                           14                         YAMM edition 2.1


            14.5    Binary Mode I/O
                    ______ ____ ___

            As in image binary mode, the byte  size is 36 bits, and each 36-bit word  is encoded
            as six 6-bit characters,  with '200 ORed in on  output, and the high-order  two bits
            stripped on input.

            Binary mode buffered output is like image binary except that each bufferful  of data
            is punched preceded by a word of the form

                    checksum,,word count

            where the checksum is computed by the  monitor from the data in the buffer,  and the
            word count is the number of words in the buffer.

            On input, the first six characters read from each record are assumed to encode a

                    checksum,,word count

            word.   The checksum  is  saved, then  enough characters  are  read to  make  up the
            specified number of words.   If an input record is  too long to fit into  the user's
            buffer, or  if the physical  end-of-tape is reached  before the specified  number of
            characters has been read, IO.BKT is set in the file status bits.  If the  record can
            all be read, but the checksum computed by the monitor differs from that read  at the
            start  of the  record, IO.DTE  is set  in the  file status  bits.  Whether  an error
            occurred or not, the  checksum and word count read  from the tape are stored  as the
            left and right halves of the third word (word 2) of the user's buffer.


                                                Table 14-2 
                                                _____ ____ 
                                           CDR: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode - no 7-9 punch in column 1 on binary input
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file - (12-11-0-1-6-7-8-9) card read in ASCII mode or hardware
                           EOF signal from card reader in any mode
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask























                                                    14-2


            June 27, 1984                            15                           Plotter Output


                                                 Section 15
                                                 _______ __
                                               Plotter Output
                                               _______ ______

                                             Table of Contents



            SubSection


            15.1     Output    15-1

            15.2     Hardware Action    15-1


            Table

            15-1     Plotter command bits    15-1
            15-2     PLT: File Status Bits    15-2

















































                                                    15-i


                                                     15                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   15-ii


            June 27, 1984                            15                           Plotter Output





                                                 Section 15
                                                 _______ __
                                               Plotter Output
                                               _______ ______




            Plotter output can be performed  in ASCII, ASCII line (=ASCII), image,  image binary
            (=image), and binary (=image) modes.

            The standard buffer size for buffered output is 38 words (35 data + 3 header).

            The plotter has the device mnemonic PLT.


            15.1    Output
                    ______

            The  plotter receives  a stream  of 6-bit  bytes from  the monitor.   In  ASCII mode
            output, the byte size is 7 bits,  and the low-order 6 bits of each character  in the
            user's buffer are  transmitted to the plotter.   In image, image binary,  and binary
            modes, the byte size is 36 bits,  and each word in the user's buffer is  broken into
            six 6-bit bytes which are transmitted to the plotter.


            15.2    Hardware Action
                    ________ ______

            The  six-bit  characters  received  by  the  plotter  are  interpreted  as  shown in
            Table 15-1 .

            The raise-pen  and lower-pen commands  should not  be combined in  the same  byte as
            positioning commands, since the motion will begin before the pen has been  raised or
            lowered.  The effect of contradictory commands in the same byte is unpredictable.


                                                Table 15-1 
                                                _____ ____ 
                                            Plotter command bits
                                            _______ _______ ____


            bit    meaning

            0      raise pen
            1      lower pen
            2      -x (drum up)
            3      +x (drum down)
            4      -y (carriage left)
            5      +y (carriage right)




















                                                    15-1


            Plotter Output                           15                         YAMM edition 2.1


                                                Table 15-2 
                                                _____ ____ 
                                           PLT: File Status Bits
                                           ____ ____ ______ ____


            name     bit   meaning

            IO.IMP   1B18  improper mode
            IO.DER   1B19  device error
            IO.DTE   1B20  data error
            IO.BKT   1B21  block too large
            IO.ERR   17B21 error bit mask
            IO.EOF   1B22  end of file
            IO.ACT   1B23  device is active
            IO.SYN   1B30  synchronous i/o
            IO.UWC   1B31  user supplied word count
            IO.MOD   17B35 data mode mask




















































                                                    15-2


            June 27, 1984                            16            Interrupt System and Sleeping


                                                 Section 16
                                                 _______ __
                                       Interrupt System and Sleeping
                                       _________ ______ ___ ________

                                             Table of Contents



            SubSection


            16.1     Trapping Arithmetic and Stack Overflow    16-1
            16.1.1      SETTR1: set arithmetic overflow instruction (CALLI -40)    16-1
            16.1.2      SETTR2: set stack over/underflow instruction (CALLI -41)    16-1

            16.2     APRENB Interrupt System    16-1
            16.2.1      APRENB: enable APRENB trapping (CALLI +16)    16-2

            16.3     INTADR Interrupt System    16-3
            16.3.1      Initializing the INTADR System    16-3
            16.3.2      Assigning Causes to Channels    16-4
            16.3.3      INTADR: initialize INTADR system (CALLI -33)    16-5
            16.3.4      TINASS: assign port interrupt causes (CALLI -42)    16-5
            16.3.5      INTASS: assign general interrupt causes (CALLI -36)    16-6
            16.3.6      INTRMT: (obsolete) assign I/O software interrupts (CALLI -52)    16-6
            16.3.7      SETTIM: set timer interrupt (CALLI -37)    16-6
            16.3.8      INTENB: enable and disable INTADR channels (CALLI -34)    16-7
            16.3.9      REDPIP: read in-progress bits (CALLI -43)    16-7
            16.3.10     INTACT: cause and uncause interrupts (CALLI -35)    16-7
            16.3.11     DISMIS: dismiss INTADR interrupts (CALLI -23)    16-8

            16.4     Sleeping    16-8
            16.4.1      HIBER: wait for event (CALLI +72)    16-8
            16.4.2      SLEEP: wait for N seconds (CALLI +31)    16-9
            16.4.3      WAKE: wake sleeping frame (CALLI +73)    16-9

            16.5     APRENB/INTADR Interaction    16-9


            Table

            16-3     APRENB Interrupt Bit Definitions    16-3
            16-4     Port Interrupt Cause Codes    16-4
            16-4b    General Interrupt Cause Codes    16-4
            16-7     INTRMT error codes    16-7
























                                                    16-i


                                                     16                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   16-ii


            June 27, 1984                            16            Interrupt System and Sleeping





                                                 Section 16
                                                 _______ __
                                       Interrupt System and Sleeping
                                       _________ ______ ___ ________





            16.1    Trapping Arithmetic and Stack Overflow
                    ________ __________ ___ _____ ________

            On encountering an  integer or floating-point overflow  condition in user  mode, the
            KI-10 hardware executes  the instruction found in  location 421 of the  user process
            table; on encountering stack overflow or underflow it executes the instruction found
            in location 422.  This provides an efficient means for the user program to trap such
            errors without incurring  monitor overhead.  The monitor  normally stores a  JFCL as
            the arithmetic overflow trap instruction.  To set the instruction to be  executed on
            integer or floating-point arithmetic  overflow, the program executes the  SETTR1 UUO
            (CALLI -40, pg. 16-1).

            The monitor normally stores an instruction which will cause it to abort  the current
            frame as the  stack over/underflow trap instruction.   To set the instruction  to be
            executed  on  stack  over  or  underflow,  the  program  executes  the   SETTR2  UUO
            (CALLI -41, pg. 16-1).

            16.1.1    SETTR1: set arithmetic overflow instruction (CALLI -40)
                      _______ ___ __________ ________ ___________ ______ ____

                    MOVE    ac, [trap instruction]
                    SETTR1  ac,
                      error return
                    normal return

            Set <ac> to  the previous trap  instruction.  If <trap  instruction> is 0,  take the
            error return; if only <trap instruction>'s op  code field is 0, store a JFCL  as the
            trap instruction and take the normal return; otherwise, store <trap  instruction> as
            the trap instruction and take the normal return.

            16.1.2    SETTR2: set stack over/underflow instruction (CALLI -41)
                      _______ ___ _____ ______________ ___________ ______ ____

                    MOVE    ac, [trap instruction]
                    SETTR2  ac,
                      error return
                    normal return

            Set <ac> to  the previous trap  instruction.  If <trap  instruction> is 0,  take the
            error return; if only <trap instruction>'s op code field is 0, store  an instruction
            which will cause the monitor to  abort the process as the trap instruction  and take
            the normal return; otherwise, store  <trap instruction> as the trap  instruction and
            take the normal return.


            16.2    APRENB Interrupt System
                    ______ _________ ______

            The APRENB interrupt system provides for dispatch to a user-supplied routine  on any
            of the events shown in table Table 16-3 .

            When an enabled APRENB condition  occurs and the APRENB interrupt system  is active,
            the monitor will
                1)  Store a representation  of the current  processor status into  .JBCNI of
                    the "Job Data Area".  Where appropriate, the bits stored are those which
                    would have  resulted from  a CONI  APR instruction  executed on  a KA-10
                    processor.
                2)  Store the current program counter into .JBTPC of the "Job Data Area".
                3)  Disable all APRENB  interrupt causes if AP.REN  is 0, or all  but AP.UUO
                    and AP.CLK if AP.REN is 1.  An exception occurs on UUO traps,  where all
                    causes but AP.CHR, AP.BRK, and AP.ESC are disabled.

                                                    16-1


            Interrupt System and Sleeping            16                         YAMM edition 2.1


                4)  Jump  to  the address  stored  in .JBAPR  of  the "Job  Data  Area".  An
                    exception  can  occur  on  AP.UUO traps:  if  the  last  APRENB executed
                    specified  a  separate address  for  them the  monitor  will  jump there
                    instead.
            An AP.CHR, AP.BRK, or AP.ESC trap will be deferred if it occurs while another APRENB
            trap is in progress.

            To dismiss from an APRENB  interrupt, the DISMIS UUO (CALLI -23, pg. 16-8)  is used.
            Note that it is not used  in the same manner when dismissing from  APRENB interrupts
            as it is from INTADR interrupts.

            16.2.1    APRENB: enable APRENB trapping (CALLI +16)
                      _______ ______ ______ ________ ______ ____

                    MOVE    ac, [UUO trap addr,,enable bits]
                    APRENB  ac,
                    only return

            where <UUO trap address>, if nonzero, specifies an alternate address
            to use instead of .JBAPR for trapping UUOs and illegal instructions
            (AP.UUO)

            and <enable bits> are the AP.xxx bits defined above

            Turn off  the INTADR  system if  it is  in effect,  and turn  on the  APRENB system,
            enabling those trap conditions whose <enable bits> are 1 and disabling the others.

            If  AP.CHR  or  AP.BRK is  set,  check  the input  buffer  for  characters  or break
            characters, and arrange for an immediate interrupt upon return if any are present.

            If <UUO trap address> is nonzero, it, rather than c(.JBAPR right) will be  used when
            trapping AP.UUO events.





































                                                    16-2


            June 27, 1984                            16            Interrupt System and Sleeping


                                                Table 16-3 
                                                _____ ____ 
                                      APRENB Interrupt Bit Definitions
                                      ______ _________ ___ ___________


            name     bits   name     bits   description

            CN.REN          AP.REN   1B18   Repetitive enable.  Permit nested traps.
            CN.POV   1B19   AP.POV   1B19   Stack Overflow or Underflow.
            CN.UUO   1B18   AP.UUO   1B20   Attempt to execute a UUO or any other illegal
                                            instruction.
            CN.BRK   1B24   AP.BRK   1B21   The receipt of a break character while not in input
                                            wait.
            CN.ILM   1B22   AP.ILM   1B22   Illegal memory reference.
            CN.CHR   1B21   AP.CHR   1B24   The receipt of a character while not in input wait.
            CN.ESC   1B17   AP.ESC   1B25   The receipt of an escape.
            CN.CLK   1B26   AP.CLK   1B26   The ocurrence of a clock tick while the program is
                                            running.
            CN.FOV   1B29   AP.FOV   1B29   Floating-Point Overflow.
            CN.HNG   1B16   AP.HNG   1B30   Hung device.
            CN.AOV   1B32   AP.AOV   1B32   Arithmetic Overflow (integer).



            16.3    INTADR Interrupt System
                    ______ _________ ______

            The INTADR  interrupt system  has 35  software interrupt  channels, with  a priority
            structure such that channel 1 has  the highest, and channel 35 the  lowest priority.
            At any given time, each channel has three bits of state information  associated with
            it:
                1)  It may either be enabled or disabled.
                2)  It may have an interrupt currently in progress.
                3)  It may have an interrupt pending.
            Each channel can be selectively enabled or disabled, or the system as a whole can be
            enabled or  disabled (preserving  the states  of the  individual channels)  or reset
            (disabling each channel and clearing its in-progress and pending bits).

            16.3.1    Initializing the INTADR System
                      ____________ ___ ______ ______

            The INTADR system uses  a 70-word transfer vector to  save the current PC  and fetch
            the  trap routine's  address when  initiating interrupts.   The format  of  the trap
            vector is

                    word 0  channel 1 old PC address
                    word 1  channel 1 trap routine address
                    word 2  channel 2 old PC address
                    word 3  channel 2 trap routine address
                    ...

            To  set  up the  INTADR  system, the  program  executes the  INTADR  UUO (CALLI -33,
            pg. 16-5).

            The proper use  of the INTADR  system is to first  initialize the vector  with words
            0,2,4..set to zero, words 1,3,5..set to the entry points of the routines for each PI
            level.   Then  issue  the   INTADR  UUO  (CALLI -33,  pg. 16-5),  followed   by  the
            appropriate TINASS and/or INTASS UUO to assign causes.

            Once  everything is  set up,  issue the  INTENB UUO  (CALLI -34, pg. 16-7)  to begin
            accepting interrupts.

            Each PI routine  should end its execution  with a DISMIS UUO  (CALLI -23, pg. 16-8),
            which will return via the appropriate PC in the transfer vector.







                                                    16-3


            Interrupt System and Sleeping            16                         YAMM edition 2.1


            16.3.2    Assigning Causes to Channels
                      _________ ______ __ ________

            Each  possible interrupt  cause can  be assigned  to one  of the  software interrupt
            channels, or ignored.  An interrupt  channel can have several causes assigned  to it
            but it then becomes difficult to determine what actually caused a given interrupt.

            Assignment of port causes is  handled by the TINASS UUO (CALLI -42,  pg. 16-5).  The
            port causes are shown in Table 16-4 .

            General  causes  are  assigned  with  the  INTASS  UUO  (CALLI -36,  pg. 16-6).  The
            general causes are shown in Table 16-4b.


                                                Table 16-4 
                                                _____ ____ 
                                         Port Interrupt Cause Codes
                                         ____ _________ _____ _____


            Name     Code  Condition

            .IAESC   0     Receipt of an escape.
            .IACHR   1     Receipt of a character.
            .IABRK   2     Receipt of a break character or a "line" of data.  A line is
                           currently > 72 characters.
            .IAIOW   3     Potential i/o wait. Execution of a UUO which would put the process
                           into port input or output wait.
            .IAROM   4     Room for more output characters.  Happens only if an .IAIOW interrupt
                           has been trapped because of a pending output wait.
            .IALOS   5     Characters lost on input.
            .IAORG   6     Receipt of an orange ball.
            .IAZAP   7     Receipt of a circuit zapper.
            .IAPSS   10    Port Status msg seen
            .IAYEL   11    Receipt of Yellow Ball.
                           if this cause is assigned, the monitor will not reflect yellow balls
                           as orange balls as it normally does; the user program should send an
                           orange ball using .AXSOB UUO (AUXCAL fn 70, pg. 10-35) when this
                           interrupt is received.
            .IAGOB   12    Receipt of Character Gobbler.
            .IATCC   13    Terminal characteristics changed at other end of PTY.



                                                Table 16-4b
                                                _____ _____
                                       General Interrupt Cause Codes
                                       _______ _________ _____ _____


            Symbol   Code  Description

            .IAUUO   0     UUO or illegal instruction
            .IACLK   1     Clock tick while running
            .IAILM   2     Ill mem ref
            .IAHNG   3     Hung device
            .IATIM   4     SETTIM timer interrupt
            .IADEV   5     Device error
            .IAWAK   6     Wake UUO for this frame
            .IAFEL   7     Page fault (WS=WSL) The current working set size is at least equal to
                           the working set size limit.
            .IAFLL   10    Page fault (WS<WSL) The current working set size is less than the
                           working set size limit.
            .IAREF   11    Reference-bit trap
            .IAERR   12    Paging i/o error
            .IANTQ   13    Notice to quit (sys going down)
            .IAFEX   14    Frame exit in child






                                                    16-4


            June 27, 1984                            16            Interrupt System and Sleeping


            16.3.3    INTADR: initialize INTADR system (CALLI -33)
                      _______ __________ ______ ______ ______ ____

                    MOVE    ac, [bits,,trap vector address]
                    INTADR  ac,
                      error return
                    normal return

                name   bit meaning
                IA.DIS 1B1 disable interrupt
                IA.REE 1B2 (re-)enable
                IA.CLR 1B4 clear interrups

            If <trap vector address> is 0 and the INTADR system is not currently in effect, take
            the error return.

            If it is nonzero and the APRENB system is in effect, turn off the APRENB  system and
            turn on the INTADR system.

            If it is nonzero, make it the trap vector address for the INTADR system.

            If IA.DIS  is set, disable  the INTADR  system.  If IA.REE  is set,  (re-)enable the
            INTADR system.  If IA.CLR is set, reset the INTADR system, "forgetting"  all pending
            and in-progress interrupts, disabling all the channels, and disabling the  system as
            a  whole.  (This  operation does  not disturb  interrupt cause  assignments  made by
            TINASS or INTASS).

            If the APRENB system  had previously been in effect,  set <ac> to the  last argument
            passed an APRENB UUO.  If the INTADR system was already in effect, set <ac>  left to
            the previous trap vector address.

            16.3.4    TINASS: assign port interrupt causes (CALLI -42)
                      _______ ______ ____ _________ ______ ______ ____

                    MOVE    ac, [causeB8+channelB17+port]
                    TINASS  ac,
                      error return
                    normal return

            where <cause> is a cause number from Table 16-4 ,

            and <channel> is 0 to deassign the cause or the number of the
                    INTADR channel to assign it to

            and <port> is the number of a port or -1 to specify the
                    process's command port

            If <channel> is greater than 35 or the INTADR system is not in effect; or  if <port>
            is negative and the current process is running detached; or if <port> is nonnegative
            and the specified port is not owned  by the process; or if <cause> is not  one found
            in Table 16-4 , take the error return.

            Assign the  port/cause combination  to the  specified channel  (or deassign  them if
            <channel> is 0).  Store the channel that this port/cause was previously  assigned to
            (or 0 if not assigned) in <ac> and take the normal return.

            If .IACHR or .IABRK is being assigned, check <port>'s buffer for characters or break
            characters, and arrange for an immediate interrupt upon return if any are present.












                                                    16-5


            Interrupt System and Sleeping            16                         YAMM edition 2.1


            16.3.5    INTASS: assign general interrupt causes (CALLI -36)
                      _______ ______ _______ _________ ______ ______ ____

                    MOVE    ac, [cause,,channel]
                    INTASS  ac,
                      error return
                    normal return

            where <cause> is taken from Table 16-4b

            and <channel> is 0 to deassign the cause or the number of the
                    INTADR channel to assign it to

            If <channel> is greater  than 35; or if <cause>  is not found in Table 16-4b;  or if
            the INTADR system is not in effect, take the error return.

            Otherwise, assign the <cause> to the  <channel> (or deassign it if <channel>  is 0),
            store the channel to which it was  previously assigned (or 0 if it wasn't)  in <ac>,
            and take the normal return.

            16.3.6    INTRMT: (obsolete) assign I/O software interrupts (CALLI -52)
                      _______ __________ ______ ___ ________ __________ ______ ____

                    MOVE    ac,[<reason>B8+<intch>B17,,<channel>]
                    INTRMT  ac,
                     error  return  ;ac/Table 16-7 
                    normal return   ;ac/previous <intch>

            where <channel> is a software I/O channel on which the
            device has been initted (currently only ACT device works),
            and <intch> is a software interrupt channel,
            and where <reason> is:

            0       input available
            1       output buffer available (good only if already interrupted
                     for output wait)
            2       about to go into I/O wait
            3       EOF on input
            4       error on I/O
            5       port zapped


            This UUO is  obsolete; certain functions  work on the  ACT device.  No  other device
            currently implements any of these functions.  The UUO was originally implemented for
            use with the Remote 620 Dispatch Base facility.

            16.3.7    SETTIM: set timer interrupt (CALLI -37)
                      _______ ___ _____ _________ ______ ____

                    MOVE    ac, [units,,time]
                    SETTIM  ac,
                      JFCL  ; never taken
                    normal return

            where <units> = 0 for milliseconds (maximum 2^18-1)
                            1 for seconds      (maximum 2^16-1)
                            2 for minutes      (maximum 2^16-1)

            It <time>  is 0,  reset the  timer (so it  will never  go off)  and take  the normal
            return.

            If <units> is milliseconds, convert <time>  to jiffies, rounding it up so that  1 ms
            becomes 1 jiffy.

            Set the timer to  go off (causing a timer  interrupt) after <time> <units>  and take
            the normal return.





                                                    16-6


            June 27, 1984                            16            Interrupt System and Sleeping


                                                Table 16-7 
                                                _____ ____ 
                                             INTRMT error codes
                                             ______ _____ _____


            IRBCH%     1       bad i/o channel
            IRBDR%     5       bad interrupt reason
            IRBIC%     6       bad interrupt channel number
            IRNIS%     7       no INTADR system in effect


            16.3.8    INTENB: enable and disable INTADR channels (CALLI -34)
                      _______ ______ ___ _______ ______ ________ ______ ____

                    MOVE    ac, [bits]
                    INTENB  ac,
                      error return
                    normal return

            where <bits> = 1B0 to enable, 0B0 to disable
                         + 1B1 to do it to channel 1
                         + 1B2 for channel 2,...

            If the INTADR system is not in effect, take the error return.

            Otherwise, enable (if  c(<ac> bit 0) is  1) or disable (if  c(<ac> bit 0) is  0) the
            channels whose corresponding bits are set, and take the normal return.

            16.3.9    REDPIP: read in-progress bits (CALLI -43)
                      _______ ____ ___________ ____ ______ ____

                    REDPIP  ac,
                      error return
                    normal return

            If the INTADR system is not in effect, take the error return.

            Otherwise, set  bit <n> of  <ac> to 1  if an interrupt  is currently in  progress of
            channel <n>, 0 otherwise, and skip-return.

            16.3.10    INTACT: cause and uncause interrupts (CALLI -35)
                       _______ _____ ___ _______ __________ ______ ____

                    MOVE    ac, [bits]
                    INTACT  ac,
                      error return
                    normal return

            where <bits> = 1B0 to set, 0B0 to clear the pending bit
                         + 1B1 to do it to channel 1
                         + 1B2 for channel 2,...

            If the INTADR system is not in effect, take the error return.

            Otherwise, set or clear the specified channels' interrupt-pending bits, set  <ac> to
            reflect the previous state of those bits, and take the normal return.
















                                                    16-7


            Interrupt System and Sleeping            16                         YAMM edition 2.1


            16.3.11    DISMIS: dismiss INTADR interrupts (CALLI -23)
                       _______ _______ ______ __________ ______ ____

                    DISMIS
                    ; clear activity on current PI level,
                    ; continue processing at the interrupt PC


            16.4    Sleeping
                    ________

            The  HIBER and  SLEEP  UUOs do  not  affect the  ability  of a  process  to continue
            receiving timer  interrupts generated  by the SETTIM  UUO (CALLI -37,  pg. 16-6) and
            INTASS UUO (CALLI -36, pg. 16-6).

            16.4.1    HIBER: wait for event (CALLI +72)
                      ______ ____ ___ _____ ______ ____

                    MOVE    ac, [bits,,time]
                    HIBER   ac,
                      error return
                    normal return

            where <bits> = '0 for ms, '1 for sec, '2 for min time units,
            + '10 to return if a character arrives
            + '20 to return if a break character arrives (see .IABRK, Table 16-4 )
            + '40 to return when output is complete
            + '100 + port # in bits 0-8 if not command port
            + '200 to return on WAKE UUO (CALLI +73, pg. 16-9)
            + '400 to return on frame exit in "child" frames

            Let <port> be c(<bits> bits 0-1) if the '100 bit of <bits> is set, the  command port
            otherwise, taking the error return if a port is specified and does not belong to the
            frame or if the command port is specified and the frame is running detached.

            If <time> is  specified in milliseconds,  convert if to  jiffies, rounding up  (1 ms
            becomes 1 jiffy, not  0); if it is specified  in seconds or minutes, and  is greater
            than 2^16-1, set it to 2^16-1.

            Note, however that if the time  specified will cause a clock interval to  be reached
            before the total specified time units  have expired, the wakeup will occur  when the
            clock interval is reached, not at the expiration of the time interval.  For example,
            if the time specified is 60 seconds and the current time is 1:3:45, the  wakeup will
            occur at 1:4:00, not 1:4:45.

            Wait until one of the specified events occurs, then skip-return.

            The sleep time is only kept in jiffies, and it is less accurate than that,  since it
            may take several seconds for an awakened frame to be rescheduled.

            An "output complete" HIBER sends a yellow ball and waits for an orange ball  to come
            back.   Since balls  can be  lost, a  sleep time  should always  be specified  (as a
            timeout).

            HIBER  uses  software interrupt  channel  36, a  fact  not normally  visible  to any
            program.  This is  a channel on which  interrupt causes cannot directly  be assigned
            with TINASS or INTASS.  However TINASS or INTASS can report that a certain cause was
            previously assigned on channel 36 if that cause was previously among the <bits> in a
            HIBER.

            If a HIBER is executed which has <bits> which specify conditions on a port for which
            a TINASS has already enabled interrupts,  then the HIBER <bits> are ignored  and the
            interrupts remain as they  were.  However, if the HIBER  has bits for WAKE  or Frame
            Exit in child, and if these conditions were previously enabled via INTASS,  then the
            channel assignments for those conditions are lost and the HIBER interrupt assignment
            is put in force.





                                                    16-8


            June 27, 1984                            16            Interrupt System and Sleeping


            16.4.2    SLEEP: wait for N seconds (CALLI +31)
                      ______ ____ ___ _ _______ ______ ____

                    MOVE    ac, [time]
                    SLEEP   ac,
                    only return

            where <time> is the number of seconds to sleep

            Convert <time> to jiffies, with a minimum of 1 jiffy and a maximum of 2^12-1.  (This
            translates into a maximum sleep of 68 seconds).  Put the process in SL  state (i.e.,
            make it wait) for  the calculated number of  jiffies, then return.  If  any software
            interrupts  fire during  the sleep,  answer them  immediately, but  do  not continue
            sleeping when they DISMIS.

            16.4.3    WAKE: wake sleeping frame (CALLI +73)
                      _____ ____ ________ _____ ______ ____

                    MOVEI   ac, frame
                    WAKE    ac,
                      error return
                    normal return

            If <frame> is less than 0 or no frame exists for <job>, take the error return.

            If <frame> is armed for interrupt on receipt of a WAKE, fire the  interrupt.  Awaken
            <frame> and return.


            16.5    APRENB/INTADR Interaction
                    _____________ ___________

            The APRENB and INTADR  systems cannot both be in  effect at the same time.   Doing a
            RESET or an APRENB will turn on the APRENB system; doing an INTADR will turn  on the
            INTADR system.

            If  an APRENB  trap is  enabled for  arithmetic or  stack overflow,  it  will "undo"
            (respectively) a  previous SETTR1  or SETTR2.   Similarly, a  SETTR1 or  SETTR2 will
            "undo" the enabling of an APRENB arithmetic or stack overflow trap.

            If a HIBER and an interrupt  are enabled for the same condition, the  interrupt will
            be taken and  the HIBER will be  continued (the monitor will  assume that it  is the
            sleep condition of the HIBER that is being interrupted) rather than returning.




























                                                    16-9


            Interrupt System and Sleeping            16                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   16-10


            June 27, 1984                            17                            Club Facility


                                                 Section 17
                                                 _______ __
                                               Club Facility
                                               ____ ________

                                             Table of Contents



            SubSection


            17.1     Purpose    17-1

            17.2     Definition    17-1
            17.2.1      Club Interlock    17-1
            17.2.2      Club ID numbers    17-1

            17.3     Use of the Club UUOs    17-1
            17.3.1      Joining a Club    17-2
            17.3.2      Leaving a Club    17-2
            17.3.3      Getting an Interlock    17-2
            17.3.4      Releasing an Interlock    17-2
            17.3.5      Direct Interaction with other club members    17-3

            17.4     Club UUOs    17-3
            17.4.1      CLBADD: Join Club (CALLI -114)    17-3
            17.4.2      CLBLEV: Leave a Club (CALLI -113)    17-3
            17.4.3      CLBINW: Get Interlock,wait (CALLI -112)    17-4
            17.4.4      CLBINI: Get Interlock,No Wait (CALLI -111)    17-4
            17.4.5      CLBRLI: Release Club Interlock (CALLI -110)    17-5
            17.4.6      CLBMEM: Read Club Member List (CALLI -107)    17-5
            17.4.7      CLBSTS: Read Status of Club Member (CALLI -106)    17-5
            17.4.8      CLBWAK: Wake Up Club Member (CALLI -105)    17-6
            17.4.9      CLBHNG: Hang Club Member (CALLI -104)    17-6


            Table

            17-4     Club Interlock Status Flags    17-4
            17-7     Club Facility Standard Error Codes    17-7





























                                                    17-i


                                                     17                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   17-ii


            June 27, 1984                            17                            Club Facility





                                                 Section 17
                                                 _______ __
                                               Club Facility
                                               ____ ________





            17.1    Purpose
                    _______

            The monitor club  facility has been  provided to make  it possible for  processes to
            cooperate  more efficiently.   The facility  allows  a process  to join  a  group of
            processes which cooperate in updating and maintaining the integrity of some resource
            like a  database, or  which for  any other reason  wish to  wait upon/issue  wake up
            signals to each other.

            The facility provides only a basic interlock mechanism; more complex  interlocks can
            be implemented by  the processes in  a club.  The  importance of the  basic facility
            provided by clubs is that it  allows the cooperating processes a means  of detecting
            that the system or another member  of the club crashed while holding  the interlock.
            A club member who detects such a crash can then perform a recovery procedure  on the
            interlocked resource.


            17.2    Definition
                    __________

            A club is  a set of processes  associated with a shared  disk page mapped by  all of
            them.  "First Class"  members of any  club are those who  map the page  with maximum
            protection  Writeable;  "Second  Class"  members  are  those  who  map  with maximum
            protection Read-only or Copy-on-Write (COW).

            17.2.1    Club Interlock
                      ____ _________

            Associated with every club is an Interlock which can be held by only one club member
            at  a  time.   Second-class members  may  not  hold the  interlock.   When  a member
            successfully obtains the interlock, he  is informed whether or not the  last process
            to hold  the interlock released  it normally  or abnormally.  The  holder of  a club
            interlock can release it  normally (by issuing a  UUO) or can release  it abnormally
            (by having the  monitor crash on  him or by  having it taken  away from him  by some
            other club member who determines that the holder has crashed).

            17.2.2    Club ID numbers
                      ____ __ _______

            Associated with every club  member is a club ID  number unique within that  club; ID
            numbers are guaranteed  never to be  reused within a given  club while the  club has
            members. (A  process belonging to  two or more  clubs may receive  the same  ID from
            different clubs; the ID's are  not unique system-wide.) First-class members  can use
            the club ID numbers to act upon or obtain information about other club members.


            17.3    Use of the Club UUOs
                    ___ __ ___ ____ ____















                                                    17-1


            Club Facility                            17                         YAMM edition 2.1


            17.3.1    Joining a Club
                      _______ _ ____

            For a  club to come  into existence, the  processes which wish  to form a  club must
            agree on a disk page which will be  mapped by all of them.  If all of  the processes
            agree upon page N of file F, then the club becomes uniquely identified by the system
            internal "name" of this page.  Any process which wishes to join this club  need only
            map page N of file F, and then issue the CLBADD UUO (CALLI -114, pg. 17-3).

            The club UUOs all  require the caller to identify  the club by giving the  VP number
            where the agreed-upon page is mapped.  This  means that a process can be in  at most
            512 clubs at once.  The system performs the translation from VP number to the system
            internal page "name", which club members never need to know.

            17.3.2    Leaving a Club
                      _______ _ ____

            A club member leaves a club whenever he ceases to map the agreed-upon page  (for any
            reason),  or when  he issues  the CLBLEV  UUO (CALLI -113,  pg. 17-3). A  variety of
            events can destroy  the mapping; some  are not under  control of the  process.  Some
            examples are 1) running a  new program; 2) writing on  a COW page which was  used to
            enter a club; 3) memory parity error or context page swap error, which zap all  of a
            process' memory.  If the mapping ceases while the club member has the interlock, the
            interlock is released, and is marked "abnormally released".

            17.3.3    Getting an Interlock
                      _______ __ _________

            First-class members  may obtain their  club interlock by  using either of  two UUOs,
            CLBINW  UUO (CALLI -112,  pg. 17-4), or  CLBINI UUO  (CALLI -111, pg. 17-4).   If he
            uses  CLBINW, he  can "queue  up" to  the interlock.   If the  interlock is  held by
            another club member, the caller of  CLBINW goes into wait for the interlock,  and is
            awakened and given  the interlock when  all members ahead of  him on the  queue have
            taken and released the interlock.  This mechanism is provided by the system.

            A First-class member may issue  CLBINI UUO (CALLI -111, pg. 17-4) to attempt  to get
            the interlock; this UUO will not wait, but will immediately return if  the interlock
            is busy.

            A club  member in Interlock  Wait can  escape/control-C out of  the wait,  or answer
            software  interrupts while  in wait.   If a  software interrupt  is  answered during
            interlock  wait, the  return  PC stored  will point  at  the CLBINW  UUO.   When the
            interrupt routine  returns, the CLBINW  will be re-executed  and the caller  will be
            re-queued for the interlock (i.e., he loses his place if he services an interrupt).

            17.3.4    Releasing an Interlock
                      _________ __ _________

            As mentioned above, the interlock is released abnormally if the "club  page" mapping
            is  broken.   Club  members  release the  interlock  normally  by  using  CLBRLI UUO
            (CALLI -110,  pg. 17-5);  such  a  release  causes  the  next  member  who  gets the
            interlock to  see the  interlock status as  "normally released".   If a  club member
            holding  the interlock  encounters any  condition (ill  mem ref,  i/o  to unassigned
            channel,  etc.) which  sets the  system internal  bit JB.JER  (which means  that the
            process  cannot  run and  has  an error),  then  the interlock  will  be "abnormally
            released".
















                                                    17-2


            June 27, 1984                            17                            Club Facility


            17.3.5    Direct Interaction with other club members
                      ______ ___________ ____ _____ ____ _______

            First-class members of a club can use CLBMEM UUO (CALLI -107, pg. 17-5) to  obtain a
            list of  ID numbers  of other club  members and  a count of  members.  Using  the ID
            number, first-class  members can find  out how "healthy"  other club members  are by
            using CLBSTS UUO (CALLI -106, pg. 17-5),  can wake up other members with  CLBWAK UUO
            (CALLI -105,  pg. 17-6), or  can  hang other  members with  CLBHNG  UUO (CALLI -104,
            pg. 17-6).


            17.4    Club UUOs
                    ____ ____

            Some club UUOs return successfully with  data in AC; others write data  at addresses
            pointed to by AC.  The error return for all club UUOs is the non-skip return,  and a
            standard  club  error code  is  returned in  AC  for all  errors.   These  codes are
            summarized in Table 17-7 .

            17.4.1    CLBADD: Join Club (CALLI -114)
                      _______ ____ ____ ______ _____

                    MOVEI   AC,<VP>
                    CLBADD  AC,
                      error return  ;AC contains <error code>
                    normal return   ;AC contains <Club ID> number

            where <error code> may be found in Table 17-7 

            If <VP> is out of range, or has  no disk page mapped, or if the caller is  already a
            member of  VP's club, or  if the club  ID number would  overflow if the  caller were
            added to the club, set AC to the appropriate error code and take the error return.

            If the club currently has no  members, initialize ID numbers for this club  to zero,
            and set the interlock status to "abnormally released".

            Increment the club ID number, assign the new ID to the caller, put him in  the club,
            set AC to the ID number, and take the success return.

            17.4.2    CLBLEV: Leave a Club (CALLI -113)
                      _______ _____ _ ____ ______ _____

                    MOVEI   AC,<VP>
                    CLBLEV  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            If <VP> is out of range, or if no disk page is mapped in VP, or if the caller is not
            in any club, or if VP is  not the virtual page through which the caller  entered any
            of the clubs of which he is  currently a member, or if the caller has  the interlock
            for VP's club, set AC to the appropriate error code and take the error return.

            Remove the caller  from VP's club.   If no members remain  in the club,  destroy the
            club.  Take the normal return.
















                                                    17-3


            Club Facility                            17                         YAMM edition 2.1


            17.4.3    CLBINW: Get Interlock,wait (CALLI -112)
                      _______ ___ ______________ ______ _____

                    MOVEI   AC,<VP>
                    CLBINW  AC,
                      error return  ;AC contains <error code>
                    normal return   ;AC contains <interlock status flags>

            where <error code> may be found in Table 17-7 

            If <VP> is out of range or has no page mapped in it, or if the caller is not  in any
            club, or if <VP> is not the virtual page through which the caller entered any of the
            clubs of  which he  is currently a  member, or  if the caller  is not  a first-class
            member of VP's club, or if the caller has the interlock for this club, set AC to the
            approiate error code and take the error return.

            If the interlock is currently held by another club member, put the caller  into wait
            for the interlock; wake him up when his turn comes to get it.

            Give the interlock  for VP's club  to the caller, set  AC to the  current <interlock
            status flags> as shown in Table 17-4 , and take the normal return.


                                                Table 17-4 
                                                _____ ____ 
                                        Club Interlock Status Flags
                                        ____ _________ ______ _____


            name     bit   meaning

            CB.NML   1     last interlock release was normal
                           if set, release was normal; if 0, release was abnormal.
            CB.EVI   2     Ever Interlocked
                           if set, the club interlock has been given at least once since
                           creation of the club.  If 0, this CLBINW or CLBINI call is the first
                           to get the interlock since creation of the club, and the interlocked
                           resource may need cleanup.


            17.4.4    CLBINI: Get Interlock,No Wait (CALLI -111)
                      _______ ___ ____________ ____ ______ _____

                    MOVEI   AC,<addr>
                    CLBINI  AC,
                      error return  ;AC contains <error code>
                    normal return   ;AC contains <interlock status flags>
            If the error code is CBAIL%, then data returned at <addr> is:

            ADDR:   <ID>

            where <error code> may be found in Table 17-7 

            If any of the error conditions for CLBINW UUO (CALLI -112, pg. 17-4) is true,  or if
            the interlock is busy,  set AC to the appropriate  error code.  If the  interlock is
            busy,  store in  <addr>  the ID  number of  the  club member  currently  holding the
            interlock.  Take the error return.

            Give the interlock to the caller, set AC to the <interlock status flags> as shown in
            Table 17-4 , and take the normal return.












                                                    17-4


            June 27, 1984                            17                            Club Facility


            17.4.5    CLBRLI: Release Club Interlock (CALLI -110)
                      _______ _______ ____ _________ ______ _____

                    MOVEI   AC,<VP>
                    CLBRLI  AC,
                      error return  ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            If <VP> is out of range, or if no disk page is mapped there, or if the caller is not
            in any club, or if  <VP> is not a virtual page  via which the caller entered  any of
            the clubs of which he is a member,  or if the caller is not a first-class  member of
            VP's club, or  if the caller does  not currently have the  interlock, set AC  to the
            appropriate error code and take the error return.

            Release  the  interlock for  VP's  club, mark  it  normally released,  and  give the
            interlock to the first frame in the interlock wait queue, if there is any.  Take the
            normal return.

            17.4.6    CLBMEM: Read Club Member List (CALLI -107)
                      _______ ____ ____ ______ ____ ______ _____

                    MOVEI   AC,<addr>
                    CLBMEM  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <count>

            and data is returned at <addr> as follows:
            ADDR:   <number of club members>
            ADDR+1  1st ID number
            ..      ..
            ..      ..
            ADDR+<count> last ID number

            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
            in any club, or if VP is not a virtual page via which the caller entered any  of the
            clubs of which he is a member, or if the caller is not a first-class member  of VP's
            club, or if <count> is negative, set  AC to the appropriate error code and  take the
            error return.

            Store at  <addr> the number  of members  currently in VP's  club, and  begin storing
            their ID numbers at <addr>+1 and so  on until ID numbers or <count> runs  out.  Take
            the normal return.

            17.4.7    CLBSTS: Read Status of Club Member (CALLI -106)
                      _______ ____ ______ __ ____ ______ ______ _____

                    MOVEI  MOVEI   AC,<addr>
                          
                    CLBSTS  AC,
                     error return   ;AC contains <error code>
                    normal return   ;AC contains <status>

            where <error code> can be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <ID>

            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
            in any club, or if VP is not a virtual page via which the caller entered any  of the

                                                    17-5


            Club Facility                            17                         YAMM edition 2.1


            clubs of which he is a member, or if the caller is not a first-class member  of VP's
            club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
            appropriate error code and take the error return.

            Set AC  to <status>  (the contents  of the  monitor internal  table JBTSTS)  for the
            process identified by <ID>, and take the success return.

            There is only one bit in  <status> which is significant to the club  mechanism; that
            is JB.JER (see Table 2-7 ).  If  a club member's <status> shows JB.JER set,  then he
            can be assumed to be "unhealthy".

            17.4.8    CLBWAK: Wake Up Club Member (CALLI -105)
                      _______ ____ __ ____ ______ ______ _____

                    MOVEI   AC,<addr>
                    CLBWAK  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <ID>


            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
            in any club, or if VP is not a virtual page via which the caller entered any  of the
            clubs of which he is a member, or if the caller is not a first-class member  of VP's
            club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
            appropriate error code and take the error return.

            Send a wake-up signal to the process identified by <ID> and take the normal return.

            17.4.9    CLBHNG: Hang Club Member (CALLI -104)
                      _______ ____ ____ ______ ______ _____

                    MOVEI   AC,<addr>
                    CLBHNG  AC,
                     error return   ;AC contains <error code>
                    normal return

            where <error code> may be found in Table 17-7 

            The arguments passed at <addr> are as follows:

            ADDR:   <VP>
            ADDR+1  <ID>


            If <VP> is out of range, or has no  disk page mapped in it, or if the caller  is not
            in any club, or if VP is not a virtual page via which the caller entered any  of the
            clubs of which he is a member, or if the caller is not a first-class member  of VP's
            club, or if <ID> does  not specify a process currently  in VP's club, set AC  to the
            appropriate error code and take the error return.

            Hang the process identified by <ID> in such a way as to force logout even though the
            process may have "detach on disconnect" set.  Take the normal return.











                                                    17-6


            June 27, 1984                            17                            Club Facility


                                                Table 17-7 
                                                _____ ____ 
                                     Club Facility Standard Error Codes
                                     ____ ________ ________ _____ _____


            name     value meaning

            CBVPR%   1     VP number out of legal range
            CBNEX%   2     VP does not exist (has no disk page mapped)
            CBINC%   3     Caller already in a club for this VP
            CBIDO%   4     Club ID number overflow
            CBNIC%   5     Not in Club (from UUOs requiring club membership)
            CBVPM%   6     VP mismatch (specified VP is not one through which caller entered any
                           of the clubs he is currently in)
            CBHIL%   7     Have Interlock,cannot perform UUO at this time
            CBAIL%   10    Attempted to get Interlock, but it was busy
            CBNIL%   11    No Interlock  ( attempt to release it when you don't have it)
            CBCNT%   12    Requested count of club members is negative
            CBNFC%   13    Not First Class  (from UUOs requiring first class membership)
            CBJNI%   14    Frame Not In your club, can't get info on it

















































                                                    17-7


            Club Facility                            17                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                    17-8


            June 27, 1984                            18                Environmental Information


                                                 Section 18
                                                 _______ __
                                         Environmental Information
                                         _____________ ___________

                                             Table of Contents



            SubSection


            18.1     Dates and Times    18-1
            18.1.1      DATE: read date (CALLI +14)    18-1
            18.1.2      DATUUO: do time zone conversions (CALLI -55)    18-2
            18.1.3      MSTIME: read time in ms (CALLI +23)    18-3
            18.1.4      DAYTIM: return elapsed time since 1/1/64 in seconds (CALLI -143)    18-3
            18.1.5      RUNTIM: get TRUs (CALLI +27)    18-3
            18.1.6      TIMER: read time in jiffies (CALLI +22)    18-3

            18.2     GETTAB tables and functions    18-3
            18.2.1      GETTAB: read monitor tables (CALLI +41)    18-4

            18.3     Addressing Monitor Memory    18-11
            18.3.1      VPEEK: Virtual/Physical PEEK (CALLI -136)    18-12
            18.3.2      PEEK: (obsolete) read monitor core (CALLI +33)    18-12
            18.3.3      POKE: write in monitor core (CALLI -12)    18-12
            18.3.4      BITPOK: read/modify/write in monitor memory (CALLI -120)    18-12

            18.4     Lights and Switches    18-13
            18.4.1      LIGHTS: display word in console lights (CALLI -1)    18-13
            18.4.2      SWITCH: read console switches (CALLI +20)    18-13
            18.4.3      SETMCY: Set micro cycle timer (CALLI -144)    18-13


            Table

            18-2     Time Zone Codes    18-2
            18-5     GETTAB tables by function    18-5
            18-7     GETTAB tables by number    18-7
            18-8     .GTFTR Bits (GETTAB -54)    18-8
            18-8b    .GTCNF (GETTAB +11) Items    18-8
            18-9     states word    18-9
            18-9b    .GTLOG Bits (GETTAB -24)    18-9
            18-9c    Terminal Identifier Codes    18-9
            18-10    .GTLVD (GETTAB 16) Items    18-10
            18-10b   .GTNSW Items (GETTAB 12)    18-10
            18-11    .GTODP(GETTAB +15) items (ONCDSK parameters)    18-11
            18-11b   .GTWSC(GETTAB +25) items (Wait State Codes)    18-11





















                                                    18-i


                                                     18                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   18-ii


            June 27, 1984                            18                Environmental Information





                                                 Section 18
                                                 _______ __
                                         Environmental Information
                                         _____________ ___________





            18.1    Dates and Times
                    _____ ___ _____

            The monitor supports two date formats:
                1)  DEC format
                        (year-1964)*12 + (month-1)*31 + (day-1)
                        where <month> is the current month of the year
                        and <day> is the current day of the month
                2)  Standard Format
                        the number of days since 1 January 1964

            Times are supplied by the monitor with respect to midnight of the appropriate day.

            Most UUOs supply dates and times with respect to the user's current time  zone.  The
            time zones and their codes are described in Table 18-2 .

            The current time zone for a process is stored in bits 3-7 of the process's privilege
            word (see Table 2-3 ), with bit 2 set if the process is subject to  daylight savings
            time.

            18.1.1    DATE: read date (CALLI +14)
                      _____ ____ ____ ______ ____

                    DATE    ac,
                    only return

            Set  c(<ac>) to  the current  date, in  DEC format,  with respect  to  the process's
            current time zone, and return.
































                                                    18-1


            Environmental Information                18                         YAMM edition 2.1


                                                Table 18-2 
                                                _____ ____ 
                                              Time Zone Codes
                                              ____ ____ _____


                     A = hours to add to GMT
                     B = international zone letter
                     C = monitor code
                     D = zone initials, standard time
                     E = zone initials, daylight time
                     F = location(s) in zone


                     A    B    C    D      E      F

                     -12  Y    4
                     -11  X    5    BST    BDT    Bering Straits
                     -10  W    6    HST    HDT    Hawaii, Alaska
                     -9   V    7    YST    YDT    Yukon
                     -8   U    10   PST    PDT    California
                     -7   T    11   MST    MDT    Denver
                     -6   S    12   CST    CDT    Chicago, Houston
                     -5   R    13   EST    EDT    New York
                     -4   Q    14   AST    ADT
                     -3   P    15
                     -2   O    16
                     -1   N    17
                     0    Z    20   GMT    WEST   London
                     1    A    21   CET    CEST   Paris
                     2    B    22   EET    EEST
                     3    C    23
                     4    D    24
                     5    E    25
                     6    F    26
                     7    G    27
                     8    H    30
                     9    I    31   JST           Tokyo
                     10   K    32                 Brisbane
                     11   L    33
                     12   M    34

                     In the monitor, a code of zero (0) usually represents the current user's
                     time zone


            18.1.2    DATUUO: do time zone conversions (CALLI -55)
                      _______ __ ____ ____ ___________ ______ ____

                    MOVEI   ac, addr
                    DATUUO  ac,
                      JFCL  ; error return never taken
                    only return

            where <addr> points to a block of the form
                    addr:   date
                    addr+1: time (jiffies since midnight)
                    addr+2: old,,new

            and <old> and <new> are time zone codes:
                    time zone (see Table 18-2 )
                    + '40 if subject to daylight savings
                    + '400000 for standard format (not DEC)
                    + '600000 for 1 word format

            Convert  <date> and  <time> from  the zone  and format  specified by  <old>  to that
            specified  by <new>,  and store  the converted  values into  <addr>  and (<addr>+1),
            respectively, then skip-return.

            If the time zone field is zero, the current user's time zone is used.

                                                    18-2


            June 27, 1984                            18                Environmental Information


            Adjustments for daylight savings will  only be applied if daylight savings  time was
            in effect at the  specified old or new date.   Daylight savings (to the  monitor) is
            never in effect for years after 2008.

            For one word formats, the second word is ignored on input, and undefined on output.

            18.1.3    MSTIME: read time in ms (CALLI +23)
                      _______ ____ ____ __ __ ______ ____

                    MSTIME  ac,
                    only return

            Set  c(<ac>)  to  the time,  in  milliseconds  since midnight  with  respect  to the
            process's current time zone, and return.

            This UUO is really only accurate to  plus or minus one jiffy (1/60 sec, or  about 17
            ms).

            18.1.4    DAYTIM: return elapsed time since 1/1/64 in seconds (CALLI -143)
                      _______ ______ _______ ____ _____ ______ __ _______ ______ _____

                    MOVEI   ac,time zone
                    DAYTIM  ac
                    only return

            Returns the elapsed time in seconds since 1/1/64 00:00 in ac.

            18.1.5    RUNTIM: get TRUs (CALLI +27)
                      _______ ___ ____ ______ ____

                    MOVE    ac, [frame]
                    RUNTIM  ac,
                    only return

            If <frame> does not exist, clear <ac> and return.

            If (1) the current process has  Systat (SY) license, or (2) the current  process has
            the same AUN as  <frame>, or (3) the  current process has account  supervisor status
            and the left half of its AUN matches the left half of <frame>'s, then set c(<ac>) to
            the number of  demilliTRUs charged to <frame>  (TRUs * 10^4) and  return; otherwise,
            clear <ac> and return.

            18.1.6    TIMER: read time in jiffies (CALLI +22)
                      ______ ____ ____ __ _______ ______ ____

                    TIMER   ac,
                    only return

            Set c(<ac>) to  the time, in  jiffies since midnight  with respect to  the process's
            current time zone, and return.


            18.2    GETTAB tables and functions
                    ______ ______ ___ _________

            The GETTAB UUO (CALLI +41, pg. 18-4)  supplies data about the current status  of the
            processes and ports on a system, as well as certain global monitor data.   A process
            may obtain  information from  various GETTAB  tables in  accordance with  the Access
            Rights it has and the Access  Rights required by the different GETTABs, as  shown in
            Table 18-5  and Table 18-7 .













                                                    18-3


            Environmental Information                18                         YAMM edition 2.1


            18.2.1    GETTAB: read monitor tables (CALLI +41)
                      _______ ____ _______ ______ ______ ____

                    MOVE    ac, [index,,table]
                    GETTAB  ac,
                      error return
                    normal return

            If the table specified by <table> does not exist, or the index specified  by <index>
            is invalid, or  the process does  not have permission to  access the data,  take the
            error return.

            Otherwise set c(<ac>) (and c(<ac>+1) for double-precision GETTABs) to  the <index>th
            item of table <table>, and skip-return.

            Where <index> is a frame number, -1 can be used to specify the current  frame; where
            <index> is  a port number,  -1 can be  used to specify  the current  frame's command
            port.



















































                                                    18-4


            June 27, 1984                            18                Environmental Information


                                                Table 18-5 
                                                _____ ____ 
                                         GETTAB tables by function
                                         ______ ______ __ ________


            Table  Access
            Number Req'd. **  Name      Description

            Frame data: index by FRAME descriptor

            -55    .ARRPI     .GTTMO    inactivity timeout limit
            -54    .ARRFI     .GTFTR    frame tree information (Table 18-8 )
            -53    .ARRFI     .GTUID    Universal ID
            -52    .ARRPI     .GTPNO    Program Number
            -27    .ARRDS     .GTLIN    TTY: name in SIXBIT; (lh)=0 if detached
            -25    .ARRPI     .GTFPN    File Proj-prog Number
            -23    .ARRFI     .GTAUN    Accounting User Number
            -22    .ARRUN     .GTUNM    user name (1-6) SIXBIT
            -21    .ARRUN     .GTUN1    user name (7-12) SIXBIT
            -20    .ARRPI     .GTLIC    license word
            0      .ARRUN     .GTSTS    Status Bits (Table 2-7 )
            2      .ARRFI     .GTPPN    Project Programmer Number
            3      .ARRPI     .GTNAM    SIXBIT user program name
            6      .ARRPI     .GTPRV    Privilege Bits (Table 2-3 )
            7                 .GTSWP    swapper status bits
            10     .ARRDS     .GTTTY    address of TTY DDB


            Port data: index by PORT number

            -32    .ARRFI     .GTLPS    tty input line position
            -31    .ARRFI     .GTMOD    tty mode (GETSTS info)
            -26    .ARRFI     .GTJOB    frame which owns this port
            -24    .ARRFI     .GTLOG    LDBLOG info (Table 18-9b)


            Accounting data: index by FRAME descriptor

            -51    .ARRAD     .GTSPW    double precision pages-to-WS*size
            -50    .ARRAD     .GTPWS    pages to working-set
            -47    .ARRAD     .GTMPC    pages mapped/created
            -46    .ARRAD     .GTMCY    double precision microcycles
            -45    .ARRAD     .GTKCM    double precision K-core microcycles
            -44    .ARRAD     .GTTRU    double precision TRUs * 10^4
            -43    .ARRAD     .GTTR2    high order TRUs * 10^4
            -42    .ARRAD     .GTMC2    high order microcycles
            -41    .ARRAD     .GTBIO    block IO chars transmitted
            -40    .ARRAD     .GTBET    BIO elapsed time (sec)
            -37    .ARRAD     .GTSOK    TYMCHG TRUs * 10^4
            -33    .ARRAD     .GTERN    ENTER + RENAME count
            -30    .ARRDS     .GTLIM    time limit (TRUs * 10^4)
            -15    .ARRAD     .GTMC1    low order microcycles
            -14    .ARRAD     .GTKM2    high order K-core microcycles
            -13    .ARRAD     .GTBCS    K-core break chars
            -12    .ARRAD     .GTCNK    attach time (sec)
            -11    .ARRAD     .GTELP    K-core seconds
            -10    .ARRAD     .GTCOT    characters output
            -7     .ARRAD     .GTCIN    characters input
            -6     .ARRAD     .GTSOT    K-core DSK blocks out
            -5     .ARRAD     .GTSIN    K-core DSK blocks in
            -4     .ARRAD     .GTSRN    K-core ENTER + RENAME
            -3     .ARRAD     .GTSLK    K-core LOOKUP
            -2     .ARRAD     .GTDLK    LOOKUP count
            4      .ARRAD     .GTTR1    low order TRUs * 10^4
            5      .ARRAD     .GTKM1    low order K-core microcycles
            17     .ARRAD     .GTRCT    DSK blocks in
            20     .ARRAD     .GTWCT    DSK blocks out


                                                    18-5


            Environmental Information                18                         YAMM edition 2.1


            Global system data: index by ITEM number

            -36    LC.SY      .GTLNK    debugging tables
            11                .GTCNF    config data (Table 18-8b)
            12     LC.SY      .GTNSW    nonswap data (Table 18-10b)
            15     LC.SY      .GTODP    ONCE-time disk parameters (Table 18-11 )
            16                .GTLVD    level-D disk (Table 18-10 )
            23     LC.SY      .GTSLF    GETTAB table addresses
            25                .GTWSC    wait states (Table 18-11b)


            ** NOTE: see Table 2-16  for discussion of AR's and equivalent license and
                                        privilege.























































                                                    18-6


            June 27, 1984                            18                Environmental Information


                                                Table 18-7 
                                                _____ ____ 
                                          GETTAB tables by number
                                          ______ ______ __ ______


            Table  Access     Name
            Number Req'd. **  [index]             Description

            -55    .ARRPI     .GTTMO [FD]         inactivity timeout limit
            -54    .ARRFI     .GTFTR [FD]         frame tree information (Table 18-8 )
            -53    .ARRFI     .GTUID [FD]         Universal ID
            -52    .ARRPI     .GTPNO [FD]         Program Number
            -51    .ARRAD     .GTSPW [FD]         double precision pages-to-WS*size
            -50    .ARRAD     .GTPWS [FD]         pages to working-set
            -47    .ARRAD     .GTMPC [FD]         pages mapped/created
            -46    .ARRAD     .GTMCY [FD]         double precision microcycles
            -45    .ARRAD     .GTKCM [FD]         double precision K-core microcycles
            -44    .ARRAD     .GTTRU [FD]         double precision TRUs * 10^4
            -43    .ARRAD     .GTTR2 [FD]         high order TRUs * 10^4
            -42    .ARRAD     .GTMC2 [FD]         high order microcycles
            -41    .ARRAD     .GTBIO [FD]         block IO chars transmitted
            -40    .ARRAD     .GTBET [FD]         BIO elapsed time (sec)
            -37    .ARRAD     .GTSOK [FD]         TYMCHG TRUs * 10^4
            -36    LC.SY      .GTLNK [item]       debugging tables
            -35                                   (obsolete) remote IO
            -34                                   (obsolete) remote secs
            -33    .ARRAD     .GTERN [FD]         ENTER + RENAME count
            -32    .ARRFI     .GTLPS [port]       tty input line position
            -31    .ARRFI     .GTMOD [port]       tty mode (GETSTS info)
            -30    .ARRDS     .GTLIM [FD]         time limit (TRUs * 10^4)
            -27    .ARRDS     .GTLIN [FD]         TTY: name in SIXBIT; (lh)=0 if detached
            -26    .ARRFI     .GTJOB [port]       frame which owns this port
            -25    .ARRPI     .GTFPN [FD]         File Proj-prog Number
            -24    .ARRFI     .GTLOG [port]       LDBLOG info (Table 18-9b)
            -23    .ARRFI     .GTAUN [FD]         Accounting User Number
            -22    .ARRUN     .GTUNM [FD]         user name (1-6) SIXBIT
            -21    .ARRUN     .GTUN1 [FD]         user name (7-12) SIXBIT
            -20    .ARRPI     .GTLIC [FD]         license word
            -17                                   reserved
            -16                                   reserved
            -15    .ARRAD     .GTMC1 [FD]         low order microcycles
            -14    .ARRAD     .GTKM2 [FD]         high order K-core microcycles
            -13    .ARRAD     .GTBCS [FD]         K-core break chars
            -12    .ARRAD     .GTCNK [FD]         attach time (sec)
            -11    .ARRAD     .GTELP [FD]         K-core seconds
            -10    .ARRAD     .GTCOT [FD]         characters output
            -7     .ARRAD     .GTCIN [FD]         characters input
            -6     .ARRAD     .GTSOT [FD]         K-core DSK blocks out
            -5     .ARRAD     .GTSIN [FD]         K-core DSK blocks in
            -4     .ARRAD     .GTSRN [FD]         K-core ENTER + RENAME
            -3     .ARRAD     .GTSLK [FD]         K-core LOOKUP
            -2     .ARRAD     .GTDLK [FD]         LOOKUP count
            -1                                    reserved
            0      .ARRUN     .GTSTS [FD]         Status Bits (Table 2-7 )
            1                                     reserved
            2      .ARRFI     .GTPPN [FD]         Project Programmer Number
            3      .ARRPI     .GTNAM [FD]         SIXBIT user program name
            4      .ARRAD     .GTTR1 [FD]         low order TRUs * 10^4
            5      .ARRAD     .GTKM1 [FD]         low order K-core microcycles
            6      .ARRPI     .GTPRV [FD]         Privilege Bits (Table 2-3 )
            7                 .GTSWP [FD]         swapper status bits
            10     .ARRDS     .GTTTY [FD]         address of TTY DDB
            11                .GTCNF [item]       config data (Table 18-8b)
            12     LC.SY      .GTNSW [item]       nonswap data (Table 18-10b)
            13                                    (obsolete) swapper data
            14                                    (obsolete) high seg data
            15     LC.SY      .GTODP [item]       ONCE-time disk parameters (Table 18-11 )
            16                .GTLVD [item]       level-D disk (Table 18-10 )
            17     .ARRAD     .GTRCT [FD]         DSK blocks in
                                                    18-7


            Environmental Information                18                         YAMM edition 2.1


            20     .ARRAD     .GTWCT [FD]         DSK blocks out
            21                                    reserved
            22                                    reserved
            23     LC.SY      .GTSLF [item]       GETTAB table addresses
            24                                    (obsolete) dev/str name
            25                .GTWSC [item]       wait states (Table 18-11b)
            26                                    reserved
            27                                    (obsolete) physical core table
            ** NOTE: See Table 2-16  for information on AR's and equivalent license and
                                                  privilege.



                                                Table 18-8 
                                                _____ ____ 
                                          .GTFTR Bits (GETTAB -54)
                                          ______ ____ _______ ____


            name   bits            meaning
            FT.PAR 7777B11         parent
            FT.NBR 7777B23         right hand neighbor
            FT.CHL 7777B35         leftmost child



                                                Table 18-8b
                                                _____ _____
                                         .GTCNF (GETTAB +11) Items
                                         ______ _______ ____ _____


            name     items description

            .CNFG0   0     System Name (in ASCII)
            .CNDT0   5     System Date (in ASCII)
            .CNTAP   7     System Device Name (in SIXBIT)
            .CNTIM   10    jiffies since midnight GMT
            .CNDAT   11    days since 1 January 1964 GMT
            .CNSIZ   12    words used by monitor
            .CNOPR   13    operator console name (in SIXBIT)
            .CNDEV   14    lh = address of first DDB
            .CNNJB   15    largest possible frame number+1
            .CNSTS   17    states word (Table 18-9 )
            .CNSER   20    cpu serial number
            .CNNSM   21    memory cycle time (in nanoseconds)
            .CNFRE   22    freecore bit map AOBJN pointer
            .CNLOC   23    address of first freecore
            .CNPTS   24    number of ports
            .CNLGO   25    LOGOUT program name (in SIXBIT)
            .CNJPS   26    jiffies per second
            .CNJPM   27    jiffies per minute
            .CNJPH   30    jiffies per hour
            .CNHGH   31    highest addressible block in core
            .CNHFD   32    Snoopy facility buffer size,,beginning loc
            .CNSYS   33    system number
            .CNFCW   34    freecore words allocated
            .CNSCC   35    Soft Crash Countdown in seconds
            .CNS30   36    XWD SAV30,NUMTAB ; info for crash analysis
            .CNDPT   37    pointer to patch area patches
            .CNRPT   40    pointer to new patch area
            .CNCPU   41    cpu type (1 = KI, 2 = KL, 3 = KS, 4 = F3)
            .CNMAP   42    mask of patches installed
            .CNMID   43    sixbit monitor ID (serial number)








                                                    18-8


            June 27, 1984                            18                Environmental Information


                                                Table 18-9 
                                                _____ ____ 
                                                states word
                                                ______ ____


            name   bits    meaning
            ST.SYS 1B0     disk system
            ST.SWP 1B1     swapping system
            ST.LOG 1B2     login
            ST.FDP 1B3     TTCALL, full duplex
            ST.PRV 1B4     privilege feature included
            ST.REE 1B5     reentrant software
            ST.LVD 1B9     level D disk software
            ST.PRR 1B10    independent project-R numbers
            ST.IMG 1B11    image, 8 bit scnser
            ST.AUT 1B17    system in auto restart
            ST.SHT 1B18    system shut
            ST.SUP 1B19    system super shut
            ST.RLB 1B20    restricted logins



                                                Table 18-9b
                                                _____ _____
                                          .GTLOG Bits (GETTAB -24)
                                          ______ ____ _______ ____


            name   bits    meaning
            LG.ZAP 1B1     a zapper has been received on this port
            LG.GON 1B2     this port is gone
            LG.HDX 1B6     this port is half-duplex
            LG.TID 27B11   terminal identifier code (see Table 18-9c)
            LG.ND1 77B19   high-order 6 bits of the originating node number
            LG.ND2 77B27   low-order 6 bits of the originating node number
            LG.POR 177B35  TYMNET port number (as opposed to the monitor's port number, which is
                           the number that is part of the device name in, for example, TTY125:)



                                                Table 18-9c
                                                _____ _____
                                         Terminal Identifier Codes
                                         ________ __________ _____


            code    char                    code    char

             0      (aux circuit)           14      (1200 async)
             1      A                       15      (BURROUGHS 1200)
             2      C                       16      (aux circuit through gateway)
             3      E                       17      (BAUDOT)
             4      G                       20      (2400 async)
             5      B                       21      (3270)
             6      F                       22      (3270 printer)
             7      J                       23      (4800 async)
            10      N                       24      (9600 async)
            11      <CR>                    25      (multiplexed pvc)
            12      D                       26      (audio response)
            13      I                       27      (video text)
            codes 30-37 unused












                                                    18-9


            Environmental Information                18                         YAMM edition 2.1


                                                Table 18-10 
                                                _____ _____ 
                                          .GTLVD (GETTAB 16) Items
                                          ______ _______ ___ _____


            name     item  description

            .LDMFD   0     MFD PPN [1,1]
            .LDSYS   1     SYS PPN [1,4]
            .LDFSF   2     FAILSAFE PPN  (obsolete)
            .LDHLP   3     HELP PPN (obsolete)
            .LDSPL   4     SPOOL PPN (obsolete)
            .LDDRB   5     directory block pointers
                           lh = addr of first directory block
                           rh = addr of next block to scan
                                to reclaim a block (0-> first)
            .LDSTR   6     (obsolete)
            .LDUNI   7     unit data block pointers
                           lh = addr of first unit data block
            .LDSWP   10    (unused)
            .LDCBN   11    number of file system core blocks
            .LDSTP   12    standard file protection in bits 0-8
            .LDUFP   13    standard directory protection in bits 0-8
            .LDRPC   14    number of RIB PCBs
            .LDSPC   15    number of SAT PCBs
            .LDQST   16    sixbit name of fastest STR
            .LDACT   17    accounting program PPN [6,270]
            .LDCRS   20    (obsolete)
            .LDLKB   21    longest meaningful LOOKUP block size



                                                Table 18-10b
                                                _____ ______
                                          .GTNSW Items (GETTAB 12)
                                          ______ _____ _______ ___


            name     item  description

            .NSCMX   10    maximum CORE request + 1
            .NSCTL   12    # free core blocks left
            .NSUPT   15    uptime (in jiffies)
            .NSHJB   20    highest frame number currently assigned
            .NSCLW   21    (obsolete) words cleared by CLRCOR
            .NSLST   22    lost time (in jiffies)
            .NSMMS   23    physical memory size (in words)
            .NSTPE   24    # parity errors
            .NSSPE   25    # spurious parity errors
            .NSCPE   26    # oper cont from parity errors
            .NSMPA   27    addr of last parity error
            .NSMPW   30    contents of that word
            .NSMPP   31    PC at the time of that error
            .NSNUL   34    null time (tics)
            .NSNMN   35    null time during the last minute (tics)
            .NSALR   36    alarm (unhappy msg) bits
            .NSMWM   37    monitor WS max size
            .NSUID   40    latest UID issued (SYSUID)
            .NSSTM   41    uptime of latest SCNSER cycle
            .NSMXT   42    max time between SCNSER cycles
            Unlisted item numbers are obsolete; they return 0.










                                                   18-10


            June 27, 1984                            18                Environmental Information


                                                Table 18-11 
                                                _____ _____ 
                                .GTODP(GETTAB +15) items (ONCDSK parameters)
                                _____________ ____ _____ _______ ___________


            name     item  description

            .ODSWH   0     highest block for swapping (obsolete)
            .ODSWK   1     K of disk words for swapping (obsolete)
            .ODPRT   2     in-core protect mult (tics/page)
            .ODPRA   3     in-core protect offset (tics)
            .ODMXP   4     max value for ICPT function
            .ODDCT   5     action code for DSKCLN



                                                Table 18-11b
                                                _____ ______
                                .GTWSC(GETTAB +25) items (Wait State Codes)
                                _____________ ____ _____ _____ _____ ______


            name    meaning

            WS.RN    running
            WS.WS    i/o wait satisfied
            WS.TS    Terminal i/o wait satisfied
            WS.SS    Swap wait satisfied
            WS.SI    SAT i/o wait
            WS.RI    RIB i/o wait
            WS.PS    SAT primary PCB wait
            WS.PR    RIB primary PCB wait
            WS.M2    Two PCB wait
            WS.DA    Disk Allocation wait
            WS.CB    File system Core Block resource wait
            WS.FC    Freecore wait
            WS.MT    Magtape control wait (up to 8 units)
            WS.AX    Aux Circuit resource wait
            WS.AC    Accounting Resource wait
            WS.BP    Block i/o port resource wait
            WS.IOW   i/o wait
            WS.MBW   Monitor Buffer wait
            WS.TIO   Terminal i/o wait
            WS.SW    Swap wait
            WS.ML    PCB Lock queue wait
            WS.IL    Club Interlock wait
            WS.FL    File wait (atomic lock queue)
            WS.SL    Sleep
            WS.NU    Null (no process here)
            WS.ST    Stop (usually displayed "^C")



            18.3    Addressing Monitor Memory
                    __________ _______ ______

            A process with Read Core (RC) license can read arbitrary words from  monitor memory,
            and a  process with Write  Core (WC)  license can write  arbitrary words  in monitor
            memory.   It does  so  by supplying  absolute  (physical) or  virtual  (exec mapped)
            addresses  to   the  PEEK  UUO   (CALLI +33,  pg. 18-12),  VPEEK   UUO  (CALLI -136,
            pg. 18-12),  or  POKE  UUO  (CALLI -12, pg. 18-12)  .  The  BITPOK  UUO (CALLI -120,
            pg. 18-12)  allows  read/modify/write access  to  physical memory  in  one operation
            allowing the user to change specified  fields within a word without concern  for the
            value of the other bits.








                                                   18-11


            Environmental Information                18                         YAMM edition 2.1


            18.3.1    VPEEK: Virtual/Physical PEEK (CALLI -136)
                      ______ ________________ ____ ______ _____

                    MOVE    AC,[<flag>B0,,<addr>]
                    VPEEK   AC,
                     error return
                    normal return   ; AC/ contents of <addr>

            where <flag>=0 for exec physical <addr>
                  <flag>=1 for exec virtual <addr>

            If the process does not have Read Core (RC) license, or if <flag>=0 and the physical
            address <addr> is either negative or less  than 20 or has no memory assigned,  or if
            <flag>=1 and the virtual address <addr>  cannot be accessed without an exec  ILL MEM
            REF or page fault, then take the error return.

            Otherwise, take the normal return with AC/ contents of <addr>.

            18.3.2    PEEK: (obsolete) read monitor core (CALLI +33)
                      _____ __________ ____ _______ ____ ______ ____

                    MOVE    ac, [addr]
                    PEEK    ac,
                    only return

            If the process  does not have Read  Core (RC) license, or  if <addr> is  negative or
            larger  than the  highest physical  memory  address, set  c(<ac>) to  0  and return;
            otherwise, set c(<ac>) to c(<addr>) and return.

            18.3.3    POKE: write in monitor core (CALLI -12)
                      _____ _____ __ _______ ____ ______ ____

                    MOVEI   ac,[    data
                                    <flag>B0+addr   ]
                    POKE    ac,
                      error return
                    normal return

            where <flag>=0 for physical <addr>
                  <flag>=1 for virtual <addr>

            If the process does not have Write  Core (WC) license, or if <flag>=0 and  <addr> is
            larger than the highest physical memory address, or if <flag>=1 and <addr> cannot be
            written without an exec memory  protection failure or addressing failure,  then take
            the error return.

            Otherwise, set c(<addr>) to <data>, and take the normal return.

            18.3.4    BITPOK: read/modify/write in monitor memory (CALLI -120)
                      _______ _________________ __ _______ ______ ______ _____

                    MOVEI   AC,[    <flag>B0+<address>
                                    andcam word
                                    iorm word       ]
                    BITPOK AC,
                      error return
                    normal return

            where <flag>=0 for physical <address>, and
                  <flag>=1 for virtual <address>

            The BITPOK  uuo allows the  user to set  and clear specific  bits in  monitor memory
            without affecting other bits in the same word.

            The second word in  the argument block is the  ANDCAM word.  It is  complemented and
            ANDed into the specified address.  The  third word, the IORM word, is ORed  into the
            specific address.

            The UUO fails if the user or  process does not have Write Core (WC) license,  if the
            physical <address> does  not exist, or if  the virtual <address> cannot  be accessed
            without a monitor page failure or  write violation.  If the user has Read  Core (RC)
            license, the UUO returns the previous contents of the specified address in the AC.
                                                   18-12


            June 27, 1984                            18                Environmental Information


            18.4    Lights and Switches
                    ______ ___ ________

            Any process can read the current KI-10 console switch settings or display a value in
            the console lights, though neither operation is especially useful.

            To read the switches, a program executes the SWITCH UUO (CALLI +20,  pg. 18-13).  To
            display a 36 bit  word in the lights, a  program executes the LIGHTS  UUO (CALLI -1,
            pg. 18-13).

            18.4.1    LIGHTS: display word in console lights (CALLI -1)
                      _______ _______ ____ __ _______ ______ ______ ___

                    MOVE    ac, [data]
                    LIGHTS  ac,
                    only return

            Display <data> in the console lights.  Return.

            18.4.2    SWITCH: read console switches (CALLI +20)
                      _______ ____ _______ ________ ______ ____

                    SWITCH  ac,
                    only return

            Set c(<ac>) to the console switch setting and return.

            18.4.3    SETMCY: Set micro cycle timer (CALLI -144)
                      _______ ___ _____ _____ _____ ______ _____

                    MOVE    ac,desired micro cycle interval
                    SETMCY  ac,
                     error return
                    only return

            If setting is a negative  number, error return.  Otherwise set timer  to -<interval>
            and skip return.



































                                                   18-13


            Environmental Information                18                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   18-14


            June 27, 1984                            19                 Miscellaneous Operations


                                                 Section 19
                                                 _______ __
                                          Miscellaneous Operations
                                          _____________ __________

                                             Table of Contents



            SubSection


            19.1     Operator Functions    19-1
            19.1.1      SETUUO: do SET command functions (CALLI +75)    19-1
                           .STTYO: OUTSTR to OPR terminal (SETUUO fn 0)    19-1
                           .STSTA: set STATES (SETUUO fn 1)    19-1
                           .STFAR: finish auto-restart (SETUUO fn 2)    19-1
                           .STTIM: set time (SETUUO fn 3)    19-1
                           .STDAT: set date (SETUUO fn 4)    19-2
                           .STOPR: set OPR terminal (SETUUO fn 5)    19-2
                           .STTLK: talk to another job command port (SETUUO fn 10)    19-2
                           .STBST: Set/Read BOOTS command string (SETUUO fn 11)    19-3
                           .STRES: Read/Set RESTART bits (SETUUO fn 12)    19-4
            19.1.2      ONEJOB: skip if only frame and super-shut (CALLI -20)    19-4
            19.1.3      SETABK: Set/Clear Address Break (CALLI -131)    19-5

            19.2     Executing IO instructions (User-IOT)    19-5
            19.2.1      TRPSET: Set/Clear User-IOT (CALLI +25)    19-5

            19.3     Accounting Device Control Functions    19-6

            19.4     Obsolete and Unavailable Functions    19-6
            19.4.1      Current List    19-6
            19.4.1      GETPFW: (obsolete) (CALLI -121)    19-6
            19.4.1      RDHIST: (not available) (CALLI -117)    19-6
            19.4.1      SNOOP: (not available) (CALLI -116)    19-6
            19.4.1      DDT620: (obsolete) interrogate 620 (CALLI -54)    19-6
            19.4.1      VALRMT: (obsolete) validate 620 password (CALLI -53)    19-6
            19.4.1      IDLRMT: (obsolete) set 620 idle (CALLI -51)    19-6
            19.4.1      ZAPRMT: (obsolete) zap 620 port (CALLI -50)    19-6
            19.4.1      CRERMT: (obsolete) create 620 port (CALLI -47)    19-6
            19.4.1      CALIM5: (obsolete) (CALLI -5)    19-6
            19.4.1      CALIM4: (obsolete) (CALLI -4)    19-6
            19.4.1      CALIM3: (obsolete) (CALLI -3)    19-6
            19.4.1      CALIM2: (obsolete) (CALLI -2)    19-6
            19.4.1      DDTGT: (obsolete) Get DDT mode (CALLI +5)    19-6
            19.4.1      DDTRL: (obsolete) Release DDT mode (CALLI +7)    19-6
            19.4.1      UTPCLR: (obsolete) (CALLI +13)    19-6
            19.4.1      TRPJEN: (obsolete) (CALLI +26)    19-6
            19.4.1      SETPOV: (obsolete) Set PDL OV trap (CALLI +32)    19-6
            19.4.1      SPYUUO: (obsolete) (CALLI +42)    19-6


            Table

            19-3     STTLK Error Codes    19-3
            19-5     SETABK control bits    19-5













                                                    19-i


                                                     19                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   19-ii


            June 27, 1984                            19                 Miscellaneous Operations





                                                 Section 19
                                                 _______ __
                                          Miscellaneous Operations
                                          _____________ __________





            19.1    Operator Functions
                    ________ _________

            19.1.1    SETUUO: do SET command functions (CALLI +75)
                      _______ __ ___ _______ _________ ______ ____

                    MOVE    ac, [function,,addr]
                    SETUUO  ac,
                      error return
                    normal return

            19.1.1.1    .STTYO: OUTSTR to OPR terminal (SETUUO fn 0)
                        _______ ______ __ ___ ________ _______ __ __

                    MOVE    ac, [.STTYO,,[ASCIZ/message/]]
                    SETUUO  ac,
                      error return
                    normal return

            If the process does not have oper license, error-return; otherwise, print message on
            the OPR terminal if there is one, or on CTY if there is not, and skip-return.

            19.1.1.2    .STSTA: set STATES (SETUUO fn 1)
                        _______ ___ ______ _______ __ __

                    MOVE    ac, [.STSTA,,states]
                    SETUUO  ac,
                      error return
                    normal return

            If the process does not have Operator (OP) license, error-return; otherwise, set the
            right half of the STATES word to <states> and skip-return.

            19.1.1.3    .STFAR: finish auto-restart (SETUUO fn 2)
                        _______ ______ ____________ _______ __ __

                    MOVSI   ac, .STFAR
                    SETUUO  ac,
                      error return
                    normal return

            If  the  monitor  is not  in  auto-restart  mode  (bit 35  is  not  set  in STATES),
            error-return; otherwise, start the remainder of the auto-restart frames.   (This UUO
            used by DSKCLN when it finishes).

            19.1.1.4    .STTIM: set time (SETUUO fn 3)
                        _______ ___ ____ _______ __ __

                    MOVE    ac, [.STTIM,,time]
                    SETUUO  ac,
                      error return
                    normal return

            If the  process does  not have Operator  (OP) or  Jacct (JL)  license, error-return;
            otherwise, set the system time  to <time>, interpreted as minutes since  midnight in
            the current process's time zone, and skip-return.








                                                    19-1


            Miscellaneous Operations                 19                         YAMM edition 2.1


            19.1.1.5    .STDAT: set date (SETUUO fn 4)
                        _______ ___ ____ _______ __ __

                    MOVE    ac, [.STDAT,,date]
                    SETUUO  ac,
                      error return
                    normal return

            If the  process does  not have Operator  (OP) or  Jacct (JL)  license, error-return;
            otherwise,  set  the  date  to  <date>,  interpreted  as  a  DEC-format   date,  and
            skip-return.

            19.1.1.6    .STOPR: set OPR terminal (SETUUO fn 5)
                        _______ ___ ___ ________ _______ __ __

                    MOVSI   ac, .STOPR
                    SETUUO  ac,
                      error return
                    normal return

            If the  process does  not have  Operator (OP)  or Jacct  (JL) license,  or if  it is
            running detached, error-return; otherwise, make the current frame's command port the
            OPR terminal and skip-return.

            19.1.1.7    .STTLK: talk to another job command port (SETUUO fn 10)
                        _______ ____ __ _______ ___ _______ ____ _______ __ ___

                    MOVE    ac, [.STTLK,,addr]
                    SETUUO  ac,
                      error return  ; ac/ error code from Table 19-3 
                    normal return

            addr:   exp     <job >
                    point   7,[asciz "msg"]

            If the  target job  owns the  oper terminal (OPR:),  or if  the calling  process has
            Operator (OP)  license, or  if the  target job's  command port  is idle  (in monitor
            mode), place  as many  characters as  will fit  into the  target job's  command port
            buffer; update the byte pointer to point to the last character sent.

            If the above conditions are not met, or  if the job doesn't exist, or if the  job is
            detached, or if there is not room for all the characters, take the error return with
            an error code from Table 19-3  in <ac>.   Note that in the case of not  enough room,
            some of the  characters may have  already been sent.  The  uuo may be  called again,
            with the updated byte pointer, to try again to output more characters.


























                                                    19-2


            June 27, 1984                            19                 Miscellaneous Operations


                                                Table 19-3 
                                                _____ ____ 
                                             STTLK Error Codes
                                             _____ _____ _____


            name     code  condition

            TKROM%   0     no room for characters
            TKEXS%   1     job does not exist
            TKATT%   2     job is detached
            TKBSY%   3     job busy or no license


            19.1.1.8    .STBST: Set/Read BOOTS command string (SETUUO fn 11)
                        _______ ________ _____ _______ ______ _______ __ ___

                    MOVE    ac,[.STBST,,<addr>]
                    SETUUO  ac,
                     error return           ;no license or string too long
                    normal return           ;AC/max length in characters

            ADDR:   <flag>B0,,<stringaddress>

            <flag>=1 to write the BOOTS command string
            <flag>=0 to read the string

            <stringaddress>= address of ASCIZ string to write to monitor
                                    or to copy into from monitor
            <stringaddress>=0 to clear the BOOTS command string to nulls


            If the caller has neither Read  Core (RC) nor Operator (OP) license, take  the error
            return.

            If <addr>=0, set  AC to the  maximum BOOTS command  string length in  characters and
            take the normal return.

            If  <flag>=0  copy  characters from  the  BOOTS  command string  in  the  monitor to
            <stringaddress>, terminating  on the  null character;  set AC  to the  maximum BOOTS
            command string length in characters and take the normal return.

            If <flag>=1,

                If the caller is missing Operator (OP) license, take the error return.

                If <stringaddress>=0,

                    Set the BOOTS  command string to null,  set AC to the  maximum BOOTS
                    command string length in characters, and take the normal return.

                If <stringaddress> is non-zero,

                    Copy characters  from <stringaddress> to  the BOOTS  command string.
                    If  the  caller's ASCIZ  string  is longer  than  the  maximum BOOTS
                    command string length, copy as much as possible and terminate with a
                    null.   Set  AC  to  the  maximum  BOOTS  command  string  length in
                    characters, and take the error return if the string was too long, or
                    the normal return if the string was within the maximum.












                                                    19-3


            Miscellaneous Operations                 19                         YAMM edition 2.1


            19.1.1.9    .STRES: Read/Set RESTART bits (SETUUO fn 12)
                        _______ ________ _______ ____ _______ __ ___

                    MOVE    ac,[.STRES,<bits>]
                    SETUUO  ac,
                     error return           ;license missing
                    normal return

            <bits>:
            bit(s)  function

            1B18    0-read RESTART bits into rh(AC)
                    1-swap RESTART bits with bits in AC
            1B19    0-write DSKCLN type to HOM blocks
                    1-do not write DSKCLN type to HOM blocks
            377B27  crash RESTART bits
            377B35  orderly takedown RESTART bits


            The structure of the <crash> and <hangup> fields is identical.
            Numbering the bits in the field from 0 to 7 [higher to lower order],
            the structure is:

            bit(s)  function
            1B0     the auto/manual BOOTS bit is defined
            1B1     the auto/manual ONCE bit is defined
            1B2     the DSKCLN type field is defined
            1B3     auto/manual BOOTS bit:
                    1-manual BOOTS (requests CTY input)
                    0-auto BOOTS (BOOTS reads command string
                      passed to it by crash code)
            1B4     auto/manual ONCE bit:
                    1-manual ONCE (requests CTY input)
                    0-auto ONCE restart, no CTY input
            7B7     DSKCLN type field:
              0     no DSKCLN
              1     fast DSKCLN
              7     full DSKCLN
            (other values of DSKCLN type currently undefined)

            If the caller has  neither Operator (OP) or Read  Core (RC) license, take  the error
            return.

            Set AC to the current monitor RESTART bits.

            If 1B18 in <bits> is 0, take the normal return.

            If the caller is missing Operator (OP) license, take the error return.

            Set the monitor RESTART bits to <bits> and take the normal return.

            19.1.2    ONEJOB: skip if only frame and super-shut (CALLI -20)
                      _______ ____ __ ____ _____ ___ __________ ______ ____

                    ONEJOB
                    return1
                    return2

            If this is the only frame  on the system and the system is  super-shut, skip-return;
            otherwise nonskip-return.










                                                    19-4


            June 27, 1984                            19                 Miscellaneous Operations


            19.1.3    SETABK: Set/Clear Address Break (CALLI -131)
                      _______ _________ _______ _____ ______ _____

                    MOVE    AC,[<bits>,,<address>]
                    SETABK  ac,
                     error return   ;AC unchanged
                    normal return   ;AC/ previous <bits>,,<address>

            where <bits> are from Table 19-5 

            If the  hardware processor is  a KI-10,  or if <bits>  specifies a  monitor adddress
            break and the caller does not have Write Core (WC) license, take the error return.

            Otherwise, cause the paging hardware to generate an address-break pagefault  trap on
            the next reference to <address> of  the type specified by <bits>, or, if  <bits> and
            <address> are zero, clear all adddress-breaks.  Set AC to the previous address-break
            <bits> and <address> and take the normal return.


                                                Table 19-5 
                                                _____ ____ 
                                            SETABK control bits
                                            ______ _______ ____


            name     bit   meaning

            AB.FET   1B9   break on instruction-fetch from <address>
            AB.RED   1B10  break on reads from <address>
            AB.WRT   1B11  break on writes to <adddress>
            AB.USR   1B12  0=monitor, 1=user address



            19.2    Executing IO instructions (User-IOT)
                    _________ __ ____________ __________

            "User-IOT" is a bit  in the PC word which  allows user mode processes to  execute IO
            class instructions.  "I/O class" is a group of instructions which are  prohibited in
            user  mode  by the  hardware  unless  User-IOT is  set  in the  PC  word.   (see the
            DECsystem-10 DECsystem-20 Processor Reference Manual) The PDP-10  hardware typically
            restricts  a  user mode  program  from executing  IO  class  instructions.  Programs
            running in user mode with the User-IOT bit set in their PC word are exempt from this
            restriction.  Only an exec mode process has the ability to set this bit.  The TRPSET
            UUO (CALLI +25,  pg. 19-5) allows  the user having  Write Core  (WC) license  to set
            the User-IOT bit.  This is a very hazardous practice and should be  avoided whenever
            possible.

            19.2.1    TRPSET: Set/Clear User-IOT (CALLI +25)
                      _______ _________ ________ ______ ____

                    TRPSET AC,
                      error return          ; insufficient license
                    normal return

            where AC contains zero (0) to turn off User-IOT
            or minus-one (-1) to turn it on.

            The TRPSET uuo will allow the user with Write Core (WC) license to set  the user-IOT
            bit in his PC allowing him to execute IO instructions from his user program.

            The monitor  may perform other  internal tasks when  setting and  clearing User-IOT.
            Therefore it is bad practice to clear user-IOT by any means other than this UUO.

            Note the  differences between TYMCOM-X  and TOPS-10 versions  of TRPSET:  ac:=-1 not
            legal on TOPS-10; ac:=[n,,adr] not legal on TYMCOM-X.  In other words, this UUO does
            not allow the user to specify PI trap locations in his address space.






                                                    19-5


            Miscellaneous Operations                 19                         YAMM edition 2.1


            19.3    Accounting Device Control Functions
                    __________ ______ _______ _________

            The ACT  device is  controlled by  the CHKPNT  program.  CHKPNT  uses the  MTAPE UUO
            (op code 072, pg. 11-3) with  effective address 110 to  cause the device to  give an
            EOF when the  next monitor buffer  is emptied.  It  uses the INTRMT  UUO (CALLI -52,
            pg. 16-6)  to  cause the  ACT  to give  input-available  and input-is-about-to-block
            interrupts.


            19.4    Obsolete and Unavailable Functions
                    ________ ___ ___________ _________

            19.4.1    Current List
                      _______ ____
            19.4.1    GETPFW: (obsolete) (CALLI -121)
                      _______ __________ ______ _____
            19.4.1    RDHIST: (not available) (CALLI -117)
                      _______ ____ __________ ______ _____
            19.4.1    SNOOP: (not available) (CALLI -116)
                      ______ ____ __________ ______ _____
            19.4.1    DDT620: (obsolete) interrogate 620 (CALLI -54)
                      _______ __________ ___________ ___ ______ ____
            19.4.1    VALRMT: (obsolete) validate 620 password (CALLI -53)
                      _______ __________ ________ ___ ________ ______ ____
            19.4.1    IDLRMT: (obsolete) set 620 idle (CALLI -51)
                      _______ __________ ___ ___ ____ ______ ____
            19.4.1    ZAPRMT: (obsolete) zap 620 port (CALLI -50)
                      _______ __________ ___ ___ ____ ______ ____
            19.4.1    CRERMT: (obsolete) create 620 port (CALLI -47)
                      _______ __________ ______ ___ ____ ______ ____
            19.4.1    CALIM5: (obsolete) (CALLI -5)
                      _______ __________ ______ ___
            19.4.1    CALIM4: (obsolete) (CALLI -4)
                      _______ __________ ______ ___
            19.4.1    CALIM3: (obsolete) (CALLI -3)
                      _______ __________ ______ ___
            19.4.1    CALIM2: (obsolete) (CALLI -2)
                      _______ __________ ______ ___
            19.4.1    DDTGT: (obsolete) Get DDT mode (CALLI +5)
                      ______ __________ ___ ___ ____ ______ ___
            19.4.1    DDTRL: (obsolete) Release DDT mode (CALLI +7)
                      ______ __________ _______ ___ ____ ______ ___
            19.4.1    UTPCLR: (obsolete) (CALLI +13)
                      _______ __________ ______ ____
            19.4.1    TRPJEN: (obsolete) (CALLI +26)
                      _______ __________ ______ ____
            19.4.1    SETPOV: (obsolete) Set PDL OV trap (CALLI +32)
                      _______ __________ ___ ___ __ ____ ______ ____
            19.4.1    SPYUUO: (obsolete) (CALLI +42)
                      _______ __________ ______ ____






































                                                    19-6


            June 27, 1984                            20                               Accounting


                                                 Section 20
                                                 _______ __
                                                 Accounting
                                                 __________

                                             Table of Contents



            SubSection


            20.1     Special charging    20-1
            20.1.1      XCHARG: modify charges (CALLI -60)    20-1
                           .XCSAV: save charging data (XCHARG fn 0)    20-1
                           .XCRSC: read saved charges (XCHARG fn 1)    20-2
                           .XCRCC: read current charges (XCHARG fn 2)    20-2
                           .XCSET: set charges (XCHARG fn 4)    20-2
                           .XCTRN: write transaction charges (XCHARG fn 5)    20-3
                           .XCTCC: Write TRU Component Checkpoint (XCHARG fn 6)    20-3
            20.1.2      Saving Charges    20-4
            20.1.3      Reading Current Charges    20-4
            20.1.4      Setting Charges    20-4
            20.1.5      TRU Component Checkpoint    20-5

            20.2     Royalty Charging    20-5
            20.2.1      PUTROY: Put Royalty Record in Stream (CALLI -124)    20-5
            20.2.2      TYMCHG: add TRU charges (CALLI -56)    20-5

            20.3     Writing Stream Records    20-6
            20.3.1      PUTLSA: write local stream acctg record (CALLI -63)    20-6
            20.3.2      PUTSAR: write stream acctg record (CALLI -62)    20-6

            20.4     Stream Accounting Data    20-7


            Table

            20-1     XCHARG functions by number    20-1
            20-3     .XCSET Error Codes    20-3
            20-4     XCHARG Charge Table Entries    20-4
            20-6     Stream Royalty Record Words 5,6,7,10    20-6
            20-7     PUTSAR error codes    20-7
            20-7b    Stream Accounting Record Types    20-7
            20-8     Stream Accounting Record Lengths    20-8
            20-8b    Stream Record Std. Header words 0-4    20-8
            20-8c    Stream Record types 0-6 (GET/RUN etc) format    20-8
            20-8d    Change Project-Code Record words 5-7    20-8
            20-9     System Initialization Record words 0-1    20-9
            20-9b    Date Change Record words 0-5    20-9
            20-9c    Local Stream Accounting Record words 5-7    20-9
            20-9d    SETLIC/SETE Record words 5-7    20-9
            20-9e    License-Setting RUN Record words 0-2    20-9
            20-9f    LOGINN Record words 3-6    20-10
            20-10    Uptime Record words 0-2    20-10
            20-10b   Restart Record words 0-1    20-10
            20-10c   Stream Error Record words 0-1    20-10
            20-11    LOGOUT and CHKPNT stream record format    20-11
            20-12    XCHARG stream record format    20-12











                                                    20-i


                                                     20                         YAMM edition 2.1

































                                                     *  
                                                   *   *
                                                     *  


































                                                   20-ii


            June 27, 1984                            20                               Accounting





                                                 Section 20
                                                 _______ __
                                                 Accounting
                                                 __________





            20.1    Special charging
                    _______ ________

            The XCHARG  UUO (CALLI -60,  pg. 20-1) is used  to alter  the normal  system charges
            being accumulated for the current frame.

            20.1.1    XCHARG: modify charges (CALLI -60)
                      _______ ______ _______ ______ ____

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return
                    normal return

            addr:   <function code>
                    <arguments>

            If  the function  code is  invalid, error-return.   (see Table 20-1   for functions)
            Otherwise, perform the specified XCHARG function.

            20.1.1.1    .XCSAV: save charging data (XCHARG fn 0)
                        _______ ____ ________ ____ _______ __ __

                    MOVE    ac, [-1,,[.XCSAV]]
                    XCHARG  ac,
                      HALT
                    normal return

            Save the charging data shown in Table 20-4  and skip-return.


                                                Table 20-1 
                                                _____ ____ 
                                         XCHARG functions by number
                                         ______ _________ __ ______


            Function Name      Description

              fn 0   .XCSAV    save charging data
              fn 1   .XCRSC    read saved charges
              fn 2   .XCRCC    read current charges
              fn 3             (obsolete) reset charges
              fn 4   .XCSET    set charges
              fn 5   .XCTRN    write transaction charge
              fn 6   .XCTCC    write tru checkpoint
              fn 7   .XCUCF    use tru charging factor
















                                                    20-1


            Accounting                               20                         YAMM edition 2.1


            20.1.1.2    .XCRSC: read saved charges (XCHARG fn 1)
                        _______ ____ _____ _______ _______ __ __

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return
                    normal return

            where <addr> points to a <count>-long table of the form
                    wd 0    .XCRSC  ; function code
                    wd 1    mask    ; see Table 20-4 
                    wd 2+           ; see below

            If the process  has not done an  .XCSAV, or if <count>  less than 2, take  the error
            return.  If  c<addr+1>=0 read  the saved charge  that is  given when  c<mask>=0 into
            addr+2  and  skip return.   Otherwise,  for each  marked  bit set  (as  indicated by
            c<mask>), deposit the  saved charges beginning at  addr+2 and continuing  for length
            <count>.  Skip return upon completion.

            20.1.1.3    .XCRCC: read current charges (XCHARG fn 2)
                        _______ ____ _______ _______ _______ __ __

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return
                    normal return

            where <addr> points to a <count>-long block of the form
                    wd 0    .XCRCC  ; function code
                    wd 1    mask    ; see Table 20-4 
                    wd 2+           ; see below

            If <count>  less than 2,  take the  error return.  If  c<addr+1>=0 read  the current
            charge that  is given when  c<mask>=0 into addr+2  and skip return.   Otherwise, for
            each marked bit set (as indicated by c<mask>), deposit the current charges beginning
            at  addr+2  and  continuing  for  length  <count>.   Skip  return  upon  completion.
            Otherwise, Skip-return.  Note that the process need not do an .XCSAV  before reading
            the current charges.

            20.1.1.4    .XCSET: set charges (XCHARG fn 4)
                        _______ ___ _______ _______ __ __

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return  ; c(<ac>) := error code
                    normal return

            where <addr> points to a <count>-long block of the form
                    wd 0    .XCSET  ; function code
                    wd 1    mask    ; see Table 20-4 
                    wd 2+           ; see below

            If the process does not have XCharge (XC) license, or if the process has not done an
            .XCSAV, or if <count> less than 4  or greater than the number of components +  2, or
            if the system is running without accounting, or if <mask> has any bit <j>  set where
            <j>  is greater  than  <count>-2, take  the  error return;  otherwise,  let <errmsk>
            initially  be  0,  and for  <j>  from  0 to  min(<count>-2,  the  number  of savable
            components), perform the following:

                If c(<addr>+2+<j>) is less than  the corresponding saved value or  more than
                the  corresponding  current  value,  set  <errmsk>  bit  <j>  and  leave the
                component unchanged;  otherwise, set the  corresponding charge  component to
                c(<addr>+2+<j>).

            IF any bits are set in <errmsk>, error-return; otherwise, skip-return.






                                                    20-2


            June 27, 1984                            20                               Accounting


            20.1.1.5    .XCTRN: write transaction charges (XCHARG fn 5)
                        _______ _____ ___________ _______ _______ __ __

                    MOVE    ac, [-count,,addr]
                    XCHARG  ac,
                      error return  ; ac/ error code
                    normal return

            addr:   wd 0    .XCTRN  ; function code
                    block n         ; user supplied data
            count=  .-addr

            If the process does not have XCharge (XC) license, or if <count> is less than  2, or
            if <count> is greater than '27, or if the system is running without accounting, take
            the error  return; otherwise,  write a transaction  record containing  the specified
            data into the stream accounting file as record type '17.

            The user supplied data may contain up to '26 words.  The format of the data  must be
            agreed upon by the user and the accounting department.  No signifigance is placed on
            the data by the operating system.


                                                Table 20-3 
                                                _____ ____ 
                                             .XCSET Error Codes
                                             ______ _____ _____


            code   condition

            0      process does not have XCharge (XC) license
            1      no save (.XCSAV) done
            2      system running without accounting
            3      bad component value; bits 0-32 of AC is <errmsk>
            4      bad <count>
            5      too many bits in <mask>


            20.1.1.6    .XCTCC: Write TRU Component Checkpoint (XCHARG fn 6)
                        _______ _____ ___ _________ __________ _______ __ __

                    MOVE    AC,[-count,,[.XCTCC]]
                    XCHARG  AC,
                      error return  ;AC contains <error code>
                    normal return   ;AC unchanged

            Where the <error code> is from Table 20-3 .

            The value  of <count>  is ignored  by the  system; (this  calling sequence  has been
            chosen to be consistent with that of other XCHARG functions).

            If the caller lacks XCharge (XC) license, or if no stream accounting is active, take
            the error return.

            Generate a TRU component checkpoint  record in the accounting stream,  which records
            the value of each component at the time of the call.  Take the normal return.
















                                                    20-3


            Accounting                               20                         YAMM edition 2.1


            20.1.2    Saving Charges
                      ______ _______

            A process (with or without XCharge (XC) license) can save the current  charging data
            into the monitor's table by executing the .XCSAV UUO (XCHARG fn 0, pg. 20-1).


                                                Table 20-4 
                                                _____ ____ 
                                        XCHARG Charge Table Entries
                                        ______ ______ _____ _______


            mask GETTAB   description

            0    .GTKM2   kilo-core microcycles (high-order)
            1    .GTKM1   kilo-core microcycles (low-order)
            2    .GTMC2   microcycles (high-order)
            3    .GTMC1   microcycles (low-order)
            4    .GTELP   kilo-core seconds (elapsed time*size)
            5    .GTBCS   kilo-core break characters input
            6    .GTCIN   characters input
            7    .GTCOT   characters output
            10   .GTBET   block i/o elapsed time (seconds)
            11   .GTBIO   block i/o characters
            12   .GTSRN   kilo-core ENTERs + RENAMEs
            13   .GTSLK   kilo-core LOOKUPs
            14   .GTSIN   kilo-core disk blocks read
            15   .GTSOT   kilo-core disk blocks written
            16   .GTERN   # ENTERs + # RENAMEs
            17   .GTDLK   # LOOKUPs
            20   .GTRCT   disk blocks read
            21   .GTWCT   disk blocks written
            22   .GTMPC   # VCREATs + (4 * # .CHMFPs)
            23   .GTPWS   # pages added to working set
            24            kilo-core pages added to wkg set (high-order)
            25            kilo-core pages added to wkg set (low-order)


            20.1.3    Reading Current Charges
                      _______ _______ _______

            The current  charges can  all be  obtained from  GETTAB tables,  but the  .XCRCC UUO
            (XCHARG fn 2, pg. 20-2) is more convenient to use, since it reads the charges into a
            table of the same format as used by the other XCHARG functions.

            20.1.4    Setting Charges
                      _______ _______

            The normal use of the above three XCHARG functions by an XCHARG-licensed  program is
            as  follows:  first, do  an  .XCSAV to  save  the current  charges;  then  process a
            transaction; then do an .XCRSC and an .XCRCC to read the saved and  current charges,
            compute, for each charge component, what the frame is to be charged (the result must
            be between the corresponding  saved and current values);  then do an .XCSET  to pass
            the monitor to the computed charges.

            It is  important to  note that  the .XCRSC  and .XCRCC  functions read  the selected
            components into  contiguous locations  into the  user's data  block, but  the .XCSET
            function expects  to find each  component value in  the position it  would be  in if
            <mask> were  all ones.  The  easiest way to  accomplish this is  to always  read all
            charge components when doing an .XCRSC or .XCRCC.

            To set the charges, a program executes the .XCSET UUO (XCHARG fn 4, pg. 20-2).










                                                    20-4


            June 27, 1984                            20                               Accounting


            20.1.5    TRU Component Checkpoint
                      ___ _________ __________

            Certain  XC-licensed   programs  may  use   another  XCHARG  function,   .XCTCC  UUO
            (XCHARG fn 6,  pg. 20-3),  to  place  a  TRU  Component  Checkpoint  record  in  the
            accounting stream.  Such records are useful in analyzing the resource demands placed
            upon the system by heavily-used programs.


            20.2    Royalty Charging
                    _______ ________

            Any program can add a royalty  charge to the current frame's TRU count  by executing
            the  TYMCHG  UUO (CALLI -56,  pg. 20-5).   Any  process or  program  running  on the
            Tymcom-X may have one or more  Royalty Product ID's associated with it  according to
            product  licensing  agreement files  maintained  by Tymshare  Marketing.   A Royalty
            product  can  record  the fact  that  it  was executed  by  issuing  the  PUTROY UUO
            (CALLI -124, pg. 20-5).  Persons  wishing to have  Royalty Product ID's  assigned to
            their programs should contact Marketing.

            20.2.1    PUTROY: Put Royalty Record in Stream (CALLI -124)
                      _______ ___ _______ ______ __ ______ ______ _____

                    MOVE    ac,[BYTE (1)<flag> (35)<royalty product ID>]
                    PUTROY  ac,
                     error return   ; AC unchanged
                    normal return   ; AC unchanged

            The meaning of <flag> will be:
            <flag>=0        This record signals the beginning of a
                            Royalty session
            <flag>=1        This record signals the end of a Royalty session


            If the accounting system is  not operating (stream accounting records are  not being
            written to accounting  files) then take the  error return; otherwise write  a stream
            record as shown in table Table 20-6 .

            <royalty product ID>'s are not to be invented by the callers of this UUO;  they must
            be cleared thru Marketing to be certain that they do not conflict with those  in use
            for other Royalty Products.

            20.2.2    TYMCHG: add TRU charges (CALLI -56)
                      _______ ___ ___ _______ ______ ____

                    MOVE    ac, [charge]
                    TYMCHG  ac,
                    skip return only

            where <charge> is the number of TRUs to add

            Let  <TRUs>  be <charge>  logically  ANDed with  '377.   Add <TRUs>  to  the frame's
            added-charge word, unless doing so would make that word overflow, and return.



















                                                    20-5


            Accounting                               20                         YAMM edition 2.1


                                                Table 20-6 
                                                _____ ____ 
                                    Stream Royalty Record Words 5,6,7,10
                                    ______ _______ ______ _____ ________


            word   bits    contents;

            5              program name (JBTNAM)
            6              program source UFD (JBTFPN)
            7              current contents of premium cell JBTSOK
            10     0       <begin/end flag> 0 implies that this record signals the beginning of
                           a Royalty session. 1 implies the end of a session.
                   1-35    Royalty Product ID



            20.3    Writing Stream Records
                    _______ ______ _______

            Any program  can, once  and only  once during  its execution,  execute a  PUTLSA UUO
            (CALLI -63,  pg. 20-6)  to output  a  local stream  accounting  record.   The record
            output has the same  format as a RUN record,  except that the program name  field is
            specified by the caller of PUTLSA.  The UUO is useful for tracking  variant versions
            of a program.

            A process with Jacct (JL) license  can cause the monitor to write a  LOGINN, CHKPNT,
            LOGOUT, or uptime record by executing the PUTSAR UUO (CALLI -62, pg. 20-6).

            20.3.1    PUTLSA: write local stream acctg record (CALLI -63)
                      _______ _____ _____ ______ _____ ______ ______ ____

                    MOVE    ac, [SIXBIT /identifier/]
                    PUTLSA  ac,
                    only return

            If a  PUTLSA has  already been done  since the  last RUN/RUNSEG/START,  just return;
            otherwise, write a  PUTLSA stream accounting record,  using <identifier> for  word 5
            unless <identifier> is null (c(<ac>) =  0), in which case using the  current program
            name, then return.

            20.3.2    PUTSAR: write stream acctg record (CALLI -62)
                      _______ _____ ______ _____ ______ ______ ____

                    MOVEI   AC, ADDR
                    PUTSAR  AC,
                      error return  ; AC/ error code
                    normal return

            where <addr> points to a block of the form
                    wd 0  bits 0-8    type
                          bits 30-35  record length
                    wd 1+             ; contents of record

            If the system is  running without accounting, or if  the process is not  licensed to
            write a record of  type <type>, or if <record  length> is incorrect for a  record of
            type <type>, or if <type> is  bad, take the error return; otherwise, write  a stream
            accounting record  of the  specified type, from  the <record  length> words  of data
            beginning at <addr>+1, and skip-return.

            Currently, Jacct (JL) license is required to write each of the four  writable record
            types (40-43).











                                                    20-6


            June 27, 1984                            20                               Accounting


                                                Table 20-7 
                                                _____ ____ 
                                             PUTSAR error codes
                                             ______ _____ _____


            code   condition

            0      system running without accounting
            1      insufficient license
            2      bad <record length> for the type
            3      bad <type>



            20.4    Stream Accounting Data
                    ______ __________ ____

            The  monitor  writes  records  of  accounting  information  which  are  read  from a
            pseudo-device called  ACT by a  program called  CHKPNT and stored  by it  into daily
            accounting files.

            The monitor writes stream accounting records for certain significant events  such as
            the running of a program outside of a user's directory or the setting of  license by
            a process.   In addition, certain  privileged programs (such  as LOGINN,  LOGOUT and
            CHKPNT) can  request the  monitor to write  stream accounting  records by  using the
            PUTSAR UUO (CALLI -62,  pg. 20-6), and any program  can write a single  local stream
            accounting record (for purposes of tracking) once during its execution by  using the
            PUTLSA UUO (CALLI -63, pg. 20-6).


                                                Table 20-7b
                                                _____ _____
                                       Stream Accounting Record Types
                                       ______ __________ ______ _____


            type   description

            0      GET/RUN/R command, RUN/RUNSEG UUO
            1      EXIT UUO, ac field 0
            2      EXIT UUO, ac field nonzero
            3      SETNAM UUO
            4      START command
            5      REENTER command
            6      DDT command
            7      project code changed
            10     .XCSET XCHARG function executed
            11     system initialization
            12     date or time change during timesharing
            13     PUTLSA record
            14     SETLIC UUO
            15     SETE UUO
            16     license set by RUN UUO
            40     LOGINN record
            41     CHKPNT record
            42     LOGOUT record
            43     uptime record (written by CHKPNT when it comes up)
            400    CHKPNT restart (only words 0 and 1 present)
            401    error (inconsistent data from ACT) (only wds 0 and 1)
            402    dummy (used to pad to the end of a disk block)












                                                    20-7


            Accounting                               20                         YAMM edition 2.1


                                                Table 20-8 
                                                _____ ____ 
                                      Stream Accounting Record Lengths
                                      ______ __________ ______ _______


            type   length (octal words)

            0-6    10
            7      10
            10     36
            11     2
            12     6
            13     10
            14     10
            15     10
            16     3
            40     7
            41     41
            42     41
            43     3



                                                Table 20-8b
                                                _____ _____
                                    Stream Record Std. Header words 0-4
                                    ______ ______ ____ ______ _____ ___


            word   bits  contents

            0      0-8   type
                   9-17  frame number
                   18-28 terminal type info or 0
                   29-35 length (including this word)
            1      lh    date in days since 1 Jan 1964 GMT
                   rh    time in seconds since midnight GMT
            2            frame AUN
            3            high-order TRUs (except LOGINN record)
            4            low-order TRUs (except LOGINN record)



                                                Table 20-8c
                                                _____ _____
                                Stream Record types 0-6 (GET/RUN etc) format
                                ______ ______ _____ ___ ________ ____ ______


            word   contents

            0-4    Standard Stream Header
            5      SIXBIT program name
            6      progran ppn (frame FPN)
            7      .GTSOK contents TYMCHG UUO (CALLI -56, pg. 20-5)



                                                Table 20-8d
                                                _____ _____
                                    Change Project-Code Record words 5-7
                                    ______ ____________ ______ _____ ___


            word   bit   contents

            5            chars 1-5 of new project code (ASCII)
            6            chars 6-10 of new project code
            7      0-13  chars 11-12 of new project code
                   14-34 0
                   35    project code verify bit




                                                    20-8


            June 27, 1984                            20                               Accounting


                                                Table 20-9 
                                                _____ ____ 
                                   System Initialization Record words 0-1
                                   ______ ______________ ______ _____ ___


            word   contents

            0      standard header, but frame = 0
            1      same contents as word 0



                                                Table 20-9b
                                                _____ _____
                                        Date Change Record words 0-5
                                        ____ ______ ______ _____ ___


            word   contents

            0-4    standard header; word 1 contains old date and time
            5      new date,,time



                                                Table 20-9c
                                                _____ _____
                                  Local Stream Accounting Record words 5-7
                                  _____ ______ __________ ______ _____ ___


            word   contents

            5      SIXBIT program name or PUTLSA argument
            6      program ppn (JBTFPN)
            7      .GTSOK contents (see TYMCHG UUO (CALLI -56, pg. 20-5))



                                                Table 20-9d
                                                _____ _____
                                        SETLIC/SETE Record words 5-7
                                        ___________ ______ _____ ___


            word   contents

            5      SIXBIT program name
            6      program ppn (frame FPN)
            7      license set



                                                Table 20-9e
                                                _____ _____
                                    License-Setting RUN Record words 0-2
                                    _______________ ___ ______ _____ ___


            word   contents

            0      standard header
            1      standard date,,time word
            2      license set













                                                    20-9


            Accounting                               20                         YAMM edition 2.1




                                                Table 20-9f
                                                _____ _____
                                          LOGINN Record words 3-6
                                          ______ ______ _____ ___


            word   contents

            3      chars 1-5 of project code given to LOGINN
            4      chars 6-10
            5      chars 11-12 (left-justified)
            6      32 bits of supervisor data for line



                                                Table 20-10 
                                                _____ _____ 
                                          Uptime Record words 0-2
                                          ______ ______ _____ ___


            word   contents

            0      standard header, but frame number = 0
            1      standard date,,time format
            2      jiffies since system loaded



                                                Table 20-10b
                                                _____ ______
                                          Restart Record words 0-1
                                          _______ ______ _____ ___


            word   contents

            0      standard header, but frame number = 0
            1      standard date,,time format



                                                Table 20-10c
                                                _____ ______
                                       Stream Error Record words 0-1
                                       ______ _____ ______ _____ ___


            word   contents

            0      standard header, but frame number = 0
            1      date,,time of last good record read






















                                                   20-10


            June 27, 1984                            20                               Accounting


                                                Table 20-11 
                                                _____ _____ 
                                   LOGOUT and CHKPNT stream record format
                                   ______ ___ ______ ______ ______ ______


            word     contents

            0 - 4    standard header Table 20-8b
            5        blocks of storage for the AUN logging out.  -1 if CHKPNT record or if other
                           frames remain logged-in under this AUN
            6        high-order kilo-core-microcycles
            7        low-order kilo-core microcycles
            10       lookups
            11       lookups*size
            12       size*(enters+renames)
            13       size*blocks read
            14       size*block written
            15       tymnet chars input
            16       tymnet chars output
            17       size*seconds elapsed
            20       seconds connected (excludes detached time)
            21       size*break chars
            22       blocks read
            23       blocks written
            24       supervisor login info low-order 32 bits
            25       enters+renames
            26       remote peripheral (RMT620) seconds (obsolete)
            27       remote peripheral chars input/output (obsolete)
            30       premium charge (contents of JBTSOK)
            31       port Block I/O elapsed seconds
            32       port Block I/O chars transferred
            33       hi-order microcycles
            34       low-order microcycles
            35       mapped pages + created pages
            36       pages put into working set
            37       hi-order size*(pages put in working set0
            40       low-order size*(pages put in working set)
































                                                   20-11


            Accounting                               20                         YAMM edition 2.1


                                                Table 20-12 
                                                _____ _____ 
                                        XCHARG stream record format
                                        ______ ______ ______ ______



            The values in words 10 (octal) through 35 of XCHARG records are
            differences between values which were current at the moment XCHARG was
            executing, and values supplied by the user or previously saved.  In
            effect, these amounts were "given away".

            word   contents

            0-4    standard stream header
            5      SIXBIT program name
            6      progran ppn (frame FPN)
            7      .GTSOK contents
            10     .GTKM2 Table 20-4
            11     .GTKM1
            12     .GTMC2
            13     .GTMC1
            14     .GTELP
            15     .GTBCS
            16     .GTCIN
            17     .GTCOT
            20     .GTBET
            21     .GTBIO
            22     .GTSRN
            23     .GTSLK
            24     .GTSIN
            25     .GTSOT
            26     .GTERN
            27     .GTDLK
            30     .GTRCT
            31     .GTWCT
            32     .GTMPC
            33     .GTPWS
            34     hi-order .GTPWS*size
            35     low-order .GTPWS*size

            see also Table 18-5




























                                                   20-12


            June 27, 1984                            A                                UUOSYM.MAC



                                                 UUOSYM.MAC
                                                 __________



            universal UUOSYM
            subttl  UUODEF
            ;
            ;Note the following files are available on most systems in (SYS):
            ;  UUOSYM.MAC, UUOSYM.SAI
            ;  UUODEF.MAC, UUODEF.SAI
            ;This appendix is representative of the file UUODEF.MAC.  The
            ;difference between UUOSYM.* and UUODEF.* is that the 'DEF file has
            ;full comments as shown here; the 'SYM file has all comments and
            ;unnecessary blanks removed to make compilation faster.  The way in
            ;which symbols are made available to the user varies between languages,
            ;as does the character set legal in identifiers.  For details of the
            ;convention used in each language, type the appropriate UUODEF file.
            ;These files are actually generated by a program from this document;
            ;new languages can easily be added to the filter program.
            
            
            OPDEF INIT   [041B8]        ;Open a Channel
            OPDEF AUXCAL [042B8]        ;perform port i/o functions
                .AXI8C== 0    ;input char [wait/bka/img]
                .AXI8S== 1    ;input char [skip/bka/img]
                .AXI8B== 2    ;input char [wait/img]
                .AXO8==  3    ;output char [IMG]
                .AXO8I== 4    ;output char [IMG/IMM]
                .AXPTR== 5    ;output string [PTR]
                .AXCBI== 6    ;clear input buffer
                .AXCBO== 7    ;clear output buffer
                .AXSIC== 10   ;skip if char
                .AXLDE== 11   ;leave deferred echo mode
                .AXSYB== 12   ;send yellow ball
                .AXS8B== 13   ;set image break char
                .AXCRD== 14   ;r/s compute-CR-delay bit
                .AXIBR== 15   ;r/s input baud rate
                .AXOBR== 16   ;r/s output baud rate
                .AXEP==  17   ;r/s even-parity bit
                .AXHD==  20   ;r/s half-duplex bit
                .AXPA==  21   ;r/s parameter A
                .AXPB==  22   ;r/s parameter B
                .AXPC==  23   ;r/s parameter C
                .AXHNX== 24   ;r/s host-no-XON bit
                .AXNTE== 25   ;r/s no HT/VT/FF bit
                .AXTBK== 26   ;r/s tabs-as-breaks bit
                .AXWID== 27   ;r/s line width
                .AXFC1== 30   ;r/s filler class 1
                .AXFC2== 31   ;r/s filler class 2
                .AXSFS== 32   ;set port file status bits (obsolete)
                .AXSI==  33   ;simulate input
                .AXEBM== 34   ;enter block i/o mode
                .AXIBW== 35   ;input block and wait
                .AXIBS== 36   ;input block and skip
                .AXOB==  37   ;block output
                .AXTBI== 40   ;terminate block input
                .AXTBO== 41   ;terminate block output
                .AXLBM== 42   ;leave block i/o mode
                .AXSLV== 43   ;slave command port
                .AXICW== 44   ;input char [wait/bka]
                .AXICS== 45   ;input char [skip/bka]
                .AXIWL== 46   ;input char [wait]
                .AXISL== 47   ;input char [skip]
                .AXSIL== 50   ;skip if break char
                .AXOCI== 51   ;output char [IMM]
                .AXOST== 52   ;output string
                .AXRMX== 53   ;r/s remote-XON bit
                                                    A-1


            UUOSYM.MAC                               A                          YAMM edition 2.1


                .AXRBS== 54   ;r/s remote-BS-echo bit
                .AXRVX== 55   ;r/s reverse-XON bit
                .AXTYP== 56   ;r/s terminal type
                .AXBS==  57   ;r/s BS-for-char-delete bit
                .AXHNG== 60   ;send hangup
                .AXPSM== 61   ;read port-status msg
                .AXERA== 62   ;r/s Erase-for-char-delete bit
                .AXEDE== 63   ;r/s force deferred-echo bit
                .AXCFS== 64   ;change port file status bits
                .AXLCO== 65   ;r/s Lower-case-output bit
                .AXBBP== 66   ;r/s backspace break/punctuation bit
                .AXOPC== 67   ;output string [STR]
                .AXSOB== 70   ;send orange ball
                .AXSOX== 71   ;r/s suppress output translation bit
                .AXFRS== 72   ;force rescan string [CNT,PTR]
                .AXTCN== 73   ;r/s terminal charactertistics by number
                .AXTCP== 74   ;read changed tc number,,value for a pty
                .AXNZP== 75   ;r/s no zap on reset bit
                .AXOSF== 76   ;output string, never wait [STR]
                .AXRUB== 77   ;r/s ctrl H/rubout bit
                .AXTTP== 100  ;r/s terminal class
                .AXCLR== 101  ;r/s special ctrl T mode
            OPDEF CHANIO [043B8]        ;do channel i/o functions
                .CHREL== 0    ;release device
                .CHCLS== 1    ;close a file
                .CHOPT== 2    ;output from channel
                .CHIPT== 3    ;input from channel
                .CHLK==  4    ;select file for input
                .CHENT== 5    ;select file for output
                .CHUSI== 6    ;set file pointer by block
                .CHUSO== 7    ;set file position by block
                .CHUGF== 10   ;read disk file position
                .CHREN== 11   ;rename or delete a file
                .CHMTA== 12   ;perform magtape functions
                .CHOPN== 13   ;Open a Channel
                .CHIN==  14   ;input from channel
                .CHOUT== 15   ;output from channel
                .CHSS==  16   ;set file status bits
                .CHGS==  17   ;read file status bits
                .CHSZ==  20   ;skip if file status bits clear
                .CHSO==  21   ;skip if file status bits set
                .CHIBF== 22   ;create input buffer ring
                .CHOBF== 23   ;create output buffer ring
                .CHSK==  24   ;seek to current page
                .CHWT==  25   ;wait until device inactive
                .CHMBF== 26   ;move buffers
                .CHFSI== 27   ;set file pointer by block
                .CHFSO== 30   ;set file position by block
                .CHPSI== 31   ;set file pointer by page
                .CHPSO== 32   ;set file position by page
                .CHUFD== 33   ;read UFD
                .CHMGN== 34   ;manipulate update-interlock bit
                .CHMFP== 35   ;map file pages
                .CHDFP== 36   ;delete file page
                .CHXFP== 37   ;exchange file pages
                .CHCFP== 40   ;create file page
                .CHMEN== 41   ;select file for multi-update output
                .CHNXT== 42   ;return next channel
                .CHVRB== 42   ;validate RIB
                .CHSMP== 43   ;super-map file pages
                .CHFFI== 44   ;Find First Interesting Page
                .CHFTR== 45   ;Truncate File
                .CHVMP== 47   ;move virtual page to a file
            OPDEF FRMOP  [044B8]        ;Frame Operation
                .FOJMP== 0    ;gate jump to frame
                .FOCFM== 1    ;create frame
                .FORVA== 2    ;read frame virtual address
                .FOWVA== 3    ;write frame virtual address
                                                    A-2


            June 27, 1984                            A                                UUOSYM.MAC


                .FOSAA== 4    ;start frame at absolute address
                .FOHLT== 5    ;halt frame
                .FORPC== 6    ;Read Frame PC
                .FOREP== 7    ;VREPLC to/from another frame
                .FOVRM== 10   ;VREMOV in another frame
                .FOVCL== 11   ;VCLEAR in another frame
                .FOCFH== 12   ;Create Handle
                .FODFH== 13   ;Destroy Handle
                .FOCLR== 14   ;Clear a Frame
                .FORSI== 15   ;Read Standard Access Rights Info
                .FORAR== 16   ;Read Handle Access Rights
                .FORER== 17   ;Read Handle Effective Rights
                .FOSMF== 20   ;Set Max Frame Rights
                .FOCHR== 21   ;Change Handle Rights
                .FOSVA== 22   ;start frame at vector address
                .FOHST== 23   ;Read Halt Status Block
                .FOGFT== 24   ;Graft Frame Subtree
                .FOCON== 25   ;continue frame
                .FOGIN== 26   ;Gate-jump Initialization
                .FOVCH== 27   ;Validate Child Rights
                .FOCAR== 30   ;Read Child Access Rights
                .FOCER== 31   ;Read Child Effective Rights
                .FOGET== 32   ;Setup frame core image from file
                .FORUN== 33   ;RUN program in frame
                .FOSAV== 34   ;SAVE frame core image on file
                .FOSSA== 35   ;SAVE frame core image on SHR file
                .FORFA== 36   ;Read Frame Attribute
                .FOWFA== 37   ;Write Frame Attribute
                .FOXFA== 40   ;Exchange Frame Attributes
                .FOSTP== 41   ;stop frame for non-privileged user
                .FOFCF== 42   ;force command on frame
                .FOCPC== 43   ;change project code for frame
            OPDEF FLSTOP [47B8 -147]    ;fail exit, continue allowed
            OPDEF SETINA [47B8 -146]    ;set inactivity timeout
            OPDEF SETMAI [47B8 -145]    ;set new mail waiting bit
            OPDEF SETMCY [47B8 -144]    ;Set micro cycle timer
            OPDEF DAYTIM [47B8 -143]    ;return elapsed time since 1/1/64 in seconds
            OPDEF FLEXIT [47B8 -142]    ;fail exit, don't continue
            OPDEF RLSLDB [47B8 -142]    ;release spare LDB
            OPDEF CREPTY [47B8 -141]    ;Create PTYs
            OPDEF SETSTV [47B8 -137]    ;set start vector address
            OPDEF VPEEK  [47B8 -136]    ;Virtual/Physical PEEK
            OPDEF RETACH [47B8 -135]    ;move port from frame to frame
            OPDEF EVICT  [47B8 -134]    ;Cause Notice to Quit Interrupt
            OPDEF PGRSTS [47B8 -133]    ;read/clear REFBIT fault info
            OPDEF PGISTS [47B8 -132]    ;read/clear ill mem ref fault info
            OPDEF SETABK [47B8 -131]    ;Set/Clear Address Break
            OPDEF LOGOFF [47B8 -130]    ;Run Alternate Logout Program
            OPDEF SETALP [47B8 -127]    ;Set Alternate Logout Program
            OPDEF SETOTF [47B8 -126]    ;set other-frame FD
            OPDEF CONT   [47B8 -125]    ;Put port in user level
            OPDEF PUTROY [47B8 -124]    ;Put Royalty Record in Stream
            OPDEF BLTPAG [47B8 -123]    ;change data in page uninterruptibly
            OPDEF PIDSET [47B8 -122]    ;Manipulate Process' PID
            ;     GETPFW [47B8 -121]    ;(obsolete)
            OPDEF BITPOK [47B8 -120]    ;read/modify/write in monitor memory
            OPDEF RDHIST [47B8 -117]    ;(not available)
            OPDEF SNOOP  [47B8 -116]    ;(not available)
            OPDEF POLPRT [47B8 -115]    ;Poll Ports for Events
            OPDEF CLBADD [47B8 -114]    ;Join Club
            OPDEF CLBLEV [47B8 -113]    ;Leave a Club
            OPDEF CLBINW [47B8 -112]    ;Get Interlock,wait
            OPDEF CLBINI [47B8 -111]    ;Get Interlock,No Wait
            OPDEF CLBRLI [47B8 -110]    ;Release Club Interlock
            OPDEF CLBMEM [47B8 -107]    ;Read Club Member List
            OPDEF CLBSTS [47B8 -106]    ;Read Status of Club Member
            OPDEF CLBWAK [47B8 -105]    ;Wake Up Club Member
            OPDEF CLBHNG [47B8 -104]    ;Hang Club Member
                                                    A-3


            UUOSYM.MAC                               A                          YAMM edition 2.1


            OPDEF VPGFIL [47B8 -103]    ;get mapped-file name for page
            OPDEF VDSKPT [47B8 -102]    ;read disk pointer
            OPDEF PGFSTS [47B8 -101]    ;read and clear page fault words
            OPDEF PGESTS [47B8 -100]    ;read/clear page-error status words
            OPDEF VFSTAT [47B8 -77]     ;check private/file page
            OPDEF VALPAG [47B8 -76]     ;validate pages
            OPDEF PREREF [47B8 -75]     ;prereference a page
            OPDEF WSCTL  [47B8 -74]     ;do working set functions
                .WSRBM== 0    ;read working set bits
                .WSRNG== 1    ;add/remove pages from working set
                .WSSTL== 2    ;set WSLIM
                .WSRSZ== 3    ;read WSSIZ
                .WSRLM== 4    ;read WSLIM
                .WSRMX== 5    ;read WSMAX
            OPDEF REFBIT [47B8 -73]     ;manipulate reference bits
                .RFRBM== 0    ;Read refbits
                .RFSBM== 1    ;Set refbits from bitmap
                .RFRNG== 2    ;set refbits by range
            OPDEF PERSET [47B8 -72]     ;set/clear error bit
            OPDEF PAGSTS [47B8 -71]     ;read page status word
            OPDEF VPROT  [47B8 -70]     ;set current protection for pages
            OPDEF VCREAT [47B8 -67]     ;create private pages
            OPDEF VCLEAR [47B8 -66]     ;unmap pages
            OPDEF VREMOV [47B8 -65]     ;unmap pages
            OPDEF VREPLC [47B8 -64]     ;replicate virtual pages
            OPDEF PUTLSA [47B8 -63]     ;write local stream acctg record
            OPDEF PUTSAR [47B8 -62]     ;write stream acctg record
            OPDEF CHPRJ  [47B8 -61]     ;change project code
            OPDEF XCHARG [47B8 -60]     ;modify charges
                .XCSAV== 0    ;save charging data
                .XCRSC== 1    ;read saved charges
                .XCRCC== 2    ;read current charges
                .XCSET== 4    ;set charges
                .XCTRN== 5    ;write transaction charges
                .XCTCC== 6    ;Write TRU Component Checkpoint
            OPDEF SETRCF [47B8 -57]     ;set restricted cmnd file
            OPDEF TYMCHG [47B8 -56]     ;add TRU charges
            OPDEF DATUUO [47B8 -55]     ;do time zone conversions
            ;     DDT620 [47B8 -54]     ;(obsolete) interrogate 620
            ;     VALRMT [47B8 -53]     ;(obsolete) validate 620 password
            ;     INTRMT [47B8 -52]     ;(obsolete) assign I/O software interrupts
            ;     IDLRMT [47B8 -51]     ;(obsolete) set 620 idle
            ;     ZAPRMT [47B8 -50]     ;(obsolete) zap 620 port
            ;     CRERMT [47B8 -47]     ;(obsolete) create 620 port
            OPDEF AUXRED [47B8 -46]     ;read aux circuit port numbers
            OPDEF ZAPCIR [47B8 -45]     ;zap an aux circuit
            OPDEF CREAUX [47B8 -44]     ;create an aux circuit
            OPDEF REDPIP [47B8 -43]     ;read in-progress bits
            OPDEF TINASS [47B8 -42]     ;assign port interrupt causes
            OPDEF SETTR2 [47B8 -41]     ;set stack over/underflow instruction
            OPDEF SETTR1 [47B8 -40]     ;set arithmetic overflow instruction
            OPDEF SETTIM [47B8 -37]     ;set timer interrupt
            OPDEF INTASS [47B8 -36]     ;assign general interrupt causes
            OPDEF INTACT [47B8 -35]     ;cause and uncause interrupts
            OPDEF INTENB [47B8 -34]     ;enable and disable INTADR channels
            OPDEF INTADR [47B8 -33]     ;initialize INTADR system
            OPDEF HANG   [47B8 -32]     ;hang a port or frame or frames
            OPDEF CHKLIC [47B8 -31]     ;check settable license
            OPDEF LEVDEF [47B8 -30]     ;leave deferred echo mode
            OPDEF MOVBUF [47B8 -27]     ;move buffers
            OPDEF SETMOD [47B8 -26]     ;set cmnd port file status
            OPDEF RUNSEG [47B8 -25]     ;load and run a high segment
            OPDEF SYSDVF [47B8 -24]     ;read system device data
            OPDEF DISMIS [47B8 -23]     ;dismiss INTADR interrupts
            OPDEF DSKCLR [47B8 -22]     ;initialize in-core file system data
            OPDEF SETJAL [47B8 -21]     ;set frame status bits
            OPDEF ONEJOB [47B8 -20]     ;skip if only frame and super-shut
            OPDEF SETMAL [47B8 -17]     ;set mail-waiting bit
                                                    A-4


            June 27, 1984                            A                                UUOSYM.MAC


            OPDEF GETTMC [47B8 -16]     ;(obs.) get terminal characteristics
            ;     SETTMC [47B8 -15]     ;(obsolete) no-op
            OPDEF REDNXT [47B8 -14]     ;peek at input
            OPDEF WAITCH [47B8 -13]     ;wait for input char
            OPDEF POKE   [47B8 -12]     ;write in monitor core
            OPDEF SETPRV [47B8 -11]     ;set frame privilege word
            OPDEF SETLIC [47B8 -10]     ;set process license
            OPDEF SETE   [47B8 -7]      ;set frame license
            OPDEF ATTACH [47B8 -6]      ;attach command port to frame
            ;     CALIM5 [47B8 -5]      ;(obsolete)
            ;     CALIM4 [47B8 -4]      ;(obsolete)
            ;     CALIM3 [47B8 -3]      ;(obsolete)
            ;     CALIM2 [47B8 -2]      ;(obsolete)
            OPDEF LIGHTS [47B8 -1]      ;display word in console lights
            OPDEF RESET  [47B8 +0]      ;initialize frame state
            OPDEF DDTIN  [47B8 +1]      ;DDT-mode input
            OPDEF SETDDT [47B8 +2]      ;set DDT start address
            OPDEF DDTOUT [47B8 +3]      ;DDT-mode output
            OPDEF DEVCHR [47B8 +4]      ;read device characteristics word
            ;     DDTGT  [47B8 +5]      ;(obsolete) Get DDT mode
            OPDEF GETCHR [47B8 +6]      ;read device characteristics word
            ;     DDTRL  [47B8 +7]      ;(obsolete) Release DDT mode
            OPDEF WAIT   [47B8 +10]     ;wait until device inactive
            OPDEF CORE   [47B8 +11]     ;allocate or free core
            OPDEF EXIT   [47B8 +12]     ;stop frame execution
            ;     UTPCLR [47B8 +13]     ;(obsolete)
            OPDEF DATE   [47B8 +14]     ;read date
            OPDEF LOGIN  [47B8 +15]     ;log a frame in
            OPDEF APRENB [47B8 +16]     ;enable APRENB trapping
            OPDEF LOGOUT [47B8 +17]     ;log a frame out
            OPDEF SWITCH [47B8 +20]     ;read console switches
            OPDEF REASSI [47B8 +21]     ;reassign i/o device
            OPDEF TIMER  [47B8 +22]     ;read time in jiffies
            OPDEF MSTIME [47B8 +23]     ;read time in ms
            OPDEF GETPPN [47B8 +24]     ;get frame PPN
            OPDEF TRPSET [47B8 +25]     ;Set/Clear User-IOT
            ;     TRPJEN [47B8 +26]     ;(obsolete)
            OPDEF RUNTIM [47B8 +27]     ;get TRUs
            OPDEF PJOB   [47B8 +30]     ;get frame number
            OPDEF SLEEP  [47B8 +31]     ;wait for N seconds
            ;     SETPOV [47B8 +32]     ;(obsolete) Set PDL OV trap
            ;     PEEK   [47B8 +33]     ;(obsolete) read monitor core
            OPDEF GETLIN [47B8 +34]     ;get command port name
            OPDEF RUN    [47B8 +35]     ;load and run a program
            OPDEF SETUWP [47B8 +36]     ;set highseg write protection
            OPDEF REMAP  [47B8 +37]     ;move top of lowseg to highseg
            OPDEF GETSEG [47B8 +40]     ;load a high segment
            OPDEF GETTAB [47B8 +41]     ;read monitor tables
            ;     SPYUUO [47B8 +42]     ;(obsolete)
            OPDEF SETNAM [47B8 +43]     ;set frame name
            OPDEF TMPCOR [47B8 +44]     ;do TMPCOR file i/o
                .TCRFS== 0    ;get free space count
                .TCRRF== 1    ;read TMPCOR file
                .TCRDF== 2    ;delete TMPCOR file
                .TCRWF== 3    ;write TMPCOR file
                .TCRRD== 4    ;read TMPCOR directory
                .TCRDD== 5    ;clear TMPCOR directory
            OPDEF DSKCHR [47B8 +45]     ;read disk characteristics
            OPDEF SYSSTR [47B8 +46]     ;read disk structure names
            OPDEF JOBSTR [47B8 +47]     ;Return frames next file structure
            OPDEF STRUUO [47B8 +50]     ;Manipulate file structures
            OPDEF SYSPHY [47B8 +51]     ;read physical unit names
            OPDEF DEVSTS [47B8 +54]     ;read device hardware status
            OPDEF DEVPPN [47B8 +55]     ;read PPN
            OPDEF SEEK   [47B8 +56]     ;seek to current page
            OPDEF DEVNAM [47B8 +64]     ;read device physical name
            OPDEF GOBSTR [47B8 +66]     ;Get system search list
            OPDEF HIBER  [47B8 +72]     ;wait for event
                                                    A-5


            UUOSYM.MAC                               A                          YAMM edition 2.1


            OPDEF WAKE   [47B8 +73]     ;wake sleeping frame
            OPDEF CHGPPN [47B8 +74]     ;change frame PPN
            OPDEF SETUUO [47B8 +75]     ;do SET command functions
                .STTYO== 0    ;OUTSTR to OPR terminal
                .STSTA== 1    ;set STATES
                .STFAR== 2    ;finish auto-restart
                .STTIM== 3    ;set time
                .STDAT== 4    ;set date
                .STOPR== 5    ;set OPR terminal
                .STWAT== 6    ;set WATCH bits
                .STTLK== 10   ;talk to another job command port
                .STBST== 11   ;Set/Read BOOTS command string
                .STRES== 12   ;Read/Set RESTART bits
            OPDEF DEVSIZ [47B8 +101]    ;read standard buffer size
            OPDEF OPEN   [050B8]        ;Open a Channel
            OPDEF TTCALL [051B8]        ;perform cmnd port i/o
            OPDEF INCHRW [51B8 0,]      ;input char [wait/bka]
            OPDEF OUTCHR [51B8 1,]      ;output char [CMD]
            OPDEF INCHRS [51B8 2,]      ;input char [skip/bka]
            OPDEF OUTSTR [51B8 3,]      ;output string [STR/CMD]
            OPDEF INCHWL [51B8 4,]      ;input char [wait]
            OPDEF INCHSL [51B8 5,]      ;input char [skip]
            OPDEF GETLCH [51B8 6,]      ;read line characteristics
            OPDEF SETLCH [51B8 7,]      ;set line characteristics
            OPDEF RESCAN [51B8 10,]     ;rescan command line
            OPDEF CLRBFI [51B8 11,]     ;clear input buffer
            OPDEF CLRBFO [51B8 12,]     ;clear output buffer
            OPDEF SKPINC [51B8 13,]     ;skip if char
            OPDEF SKPINL [51B8 14,]     ;skip if break char
            OPDEF IONEOU [51B8 15,]     ;output char [CMD/IMG]
            OPDEF OUTCHI [51B8 16,]     ;output char [CMD/IMM]
            OPDEF OUTPTR [51B8 17,]     ;output string [PTR/CMD]
            OPDEF RENAME [055B8]        ;rename or delete a file
            OPDEF IN     [056B8]        ;input from channel
            OPDEF OUT    [057B8]        ;output from channel
            OPDEF SETSTS [060B8]        ;set file status bits
            OPDEF STATO  [061B8]        ;skip if file status bits set
            OPDEF GETSTS [062B8]        ;read file status bits
            OPDEF STATZ  [063B8]        ;skip if file status bits clear
            OPDEF INBUF  [064B8]        ;create input buffer ring
            OPDEF OUTBUF [065B8]        ;create output buffer ring
            OPDEF INPUT  [066B8]        ;input from channel
            OPDEF OUTPUT [067B8]        ;output from channel
            OPDEF CLOSE  [070B8]        ;close a file
            OPDEF RELEAS [071B8]        ;release device
            OPDEF MTAPE  [072B8]        ;perform magtape functions
            OPDEF UGETF  [073B8]        ;read disk file position
            OPDEF USETI  [074B8]        ;set file position by block
            OPDEF USETO  [075B8]        ;set file position by block
            OPDEF LOOKUP [076B8]        ;select file for input
            OPDEF ENTER  [077B8]        ;select file for output
            
            
            subttl Frame Privilege (JBTPRV) Bits
            
                JP.LOS==1B0   ;* logout on stop
                JP.NAT==1B1   ;* no attach at login
                JP.DST==1B2   ;* daylight savings applies
                JP.ZON==37B7  ;* applicable time zone
                JP.MAI==1B8   ;new mail-waiting
                JP.INA==1B9   ;* use default inactivity timeout
                JP.CMD==1B10  ;* special command mode
                JP.COR==177B17;* max core for frame
                JP.EXO==1B18  ;execute only program
                JP.DOP==3B20  ;* disconnect options
                .JPLOG==0     ;Logout on disconnect
                .JPDET==1     ;Detach on disconnect
                .JPCON==2     ;Continue on disconnect
                                                    A-6


            June 27, 1984                            A                                UUOSYM.MAC


                .JPDTO==3     ;Detach (15 min timeout)
                JP.TYM==1B21  ;Tymshare proprietary
                JP.ASV==1B22  ;account supervisor
                JP.MAL==1B23  ;mail-waiting
                JP.XOG==1B24  ;execute only get
                JP.BUD==1B25  ;tru budget being used
                JP.RCM==1B26  ;* restricted command mode.
                JP.MOD==3B28  ;* monitor mode
                .JPMPD==0     ;PDP-10 mode
                .JPMXE==1     ;XEXEC mode
                .JPMXJ==2     ;XEXECJ (Japan)  mode
                .JPMSU==3     ;SUDS mode
                JP.CRM==177B35;maximum value for JP.COR
            
            
            subttl Frame License Bits
            
                LC.WC== 1B0   ;Write Core (POKE UUO)
                LC.RC== 1B1   ;Read Core (VPEEK UUO)
                LC.OP== 1B2   ;Operator (SETUUO UUO)
                LC.SY== 1B3   ;SYSTAT (read protected GETTAB tables)
                LC.GD== 1B4   ;Get Devices
                LC.TD== 1B5   ;Transfer Devices (REASSI UUO)
                LC.ST== 1B6   ;Manipulate Structures
                LC.HF== 1B7   ;Home Files
                LC.JL== 1B8   ;Privileged System Program
                LC.AC== 1B9   ;Auxiliary Circuits
                LC.XC== 1B10  ;XCHARG (adjust charges using the XCHARG UUO)
                LC.RPS==3B15  ;read privileges (a field)
                .LCRP== 1     ;read project
                .LCRF== 2     ;read files
                .LCRA== 3     ;read absolute
                LC.WPS==3B17  ;write privileges (a field)
                .LCWP== 1     ;write project
                .LCWF== 2     ;write files
                .LCWA== 3     ;write absolute
            
            
            subttl Frame Status Bits
            
                JB.RUN==1B0   ;Frame is runnable
                JB.CMW==1B1   ;Waiting to execute command
                JB.MRQ==1B2   ;Waiting for page(s)
                JB.JNA==1B3   ;Frame number assigned
                JB.JER==1B4   ;Monitor detected error
                JB.ESC==1B9   ;Escape seen in command mode
                JB.WSC==37B14 ;Wait state code
                JB.LOG==1B15  ;* Frame is logged in
                JB.JRQ==1B16  ;Frame must be requeued
                JB.JAC==1B17  ;Frame can't be stopped
                JB.WAK==1B19  ;WAKE pending
                JB.JA2==1B20  ;* Frame shouldn't be stopped.
                JB.UTR==1B21  ;Trap to user on UUO exit
                JB.DCN==1B22  ;Waiting for oper action
                JB.SCH==1B23  ;Frame must be rescheduled
                JB.PRF==1B24  ;Frame Prereferenced a page
                JB.SIP==1B25  ;Swap-in in progress.
                JB.SCP==1B26  ;Swapper has taken pages.
            
            
            subttl Watch Bit Definitions
            
                ST.WDY==1B19  ;time-of-day
                ST.WRN==1B20  ;run time (TRUs)
                ST.WWT==1B21  ;wait time
                ST.WDR==1B22  ;disk reads (blocks)
                ST.WDW==1B23  ;disk writes (blocks)
            
                                                    A-7


            UUOSYM.MAC                               A                          YAMM edition 2.1


            
            subttl Frame Descriptor Format
            
                FD.ABS==0B20  ;absolute type FD
                FD.FAM==1B20  ;family type FD
                FM.CHL==0B23  ;child subtype
                FM.PAR==1B23  ;parent subtype
                FD.OTF==2B20  ;"other" frame
                FD.CRH==3B20  ;created handle type FD
                CH.FRM==0B23  ;frame handle subtype
                CH.PRO==1B23  ;process handle subtype
                CH.LIC==2B23  ;license handle subtype
                FD.SLF==7B20  ;self
            
            
            subttl Map Manipulation Rights
            
                .ARRDM==0     ;Read Map
                .ARCHM==1     ;Change Map
            
            
            subttl Virtual Memory Data Manipulation Rights
            
                .ARRAC==2     ;Read ACs
                .ARWAC==3     ;Write ACs
                .ARVAR==4     ;Read VM data
                .ARVAW==5     ;Write VM data
            
            
            subttl Frame Control Rights
            
                .ARHLT==6     ;Halt frame
                .ARSTP==7     ;Stop frame
                .ARHNG==10    ;Hang frame
                .ARCLR==11    ;Clear frame and release devices
                .ARSVA==12    ;Start at Vector Address
                .ARSAA==13    ;Start at Arbitrary Address
                .ARRVA==14    ;Restart at Vector Address
                .ARRAA==15    ;Restart at Arbitrary Address
            
            
            subttl Read Frame Status Rights
            
                .ARRUN==16    ;Read User Name
                .ARRDS==17    ;Read Frame State
                .ARRAD==20    ;Read Accounting Data
                .ARRFI==21    ;Read Frame Information
                .ARRPI==22    ;Read Process Info
            
            
            subttl Access Rights Control Rights
            
                .ARSMF==23    ;Set Max Frame Rights
            
            
            subttl Wakeup Rights
            
                .ARWAK==24    ;Do Wake UUO on frame
            
            
            subttl TTY Attaching and Detaching Rights
            
                .ARATT==25    ;Attach Port
                .ARDET==26    ;Take Port away (Detach)
            
            
            subttl Frame Tree Grafting Rights
            
                                                    A-8


            June 27, 1984                            A                                UUOSYM.MAC


                .ARTKP==27    ;Take parent away from frame
                .ARGVP==30    ;Give parent to frame
                .ARGVC==31    ;Give child to frame
            
            
            subttl FRMOP standard error codes
            
                FENOH%==1     ;no handle in slot
                FEBDI%==2     ;Bad (nonmatching) universal ID number
                FENRT%==3     ;no rights to do operation
                FEBDF%==4     ;bad frame number
                FENLC%==5     ;not enough license
                FEUND%==6     ;undefined frame descriptor type
                FENCH%==7     ;not a child
                FECLP%==10    ;cannot lock context pages
                FEBAR%==11    ;bad access rights code
                FENPR%==12    ;no parent
                FEBFD%==13    ;bad family dispatch type
                FEBDH%==14    ;bad handle index number in FD
                FEBFN%==15    ;bad FRMOP function code
                FEADB%==16    ;address bad
                FEIOE%==17    ;page I/O error
                FEALR%==20    ;already running
                FEALH%==21    ;already halted
                FECSJ%==22    ;cannot stop frame with JACCT set
                FEFHE%==23    ;handle descriptor expected, not given
                FEFHU%==24    ;handle (index) already used
                FENFH%==25    ;no frame handle indices left
                FEBCN%==26    ;bad count
                FEBTN%==27    ;bad table number
                FEBHT%==30    ;bad handle type
                FECCH%==31    ;can't create handle (access failure)
                FEBSV%==32    ;bad start vector offset
                FECII%==33    ;cannot make child its own inferior in frame tree
                FECCF%==34    ;cannot continue frame
                FECFJ%==35    ;cannot do frame jump
                FEREM%==36    ;rights exceed maximum
            
            
            subttl .FOCFM error codes
            
                CF.NRD==0     ;no disk room
                CF.FCE==1     ;frame capacity exceeded
                CF.BAL==2     ;bad arg no license
                CF.DDB==3     ;cannot create command port DDB
            
            
            subttl System Start Vector Indicies
            
                SV.NSA==-1    ;normal start address (as found in .JBSA)
                SV.CCL==-2    ;CCL start address (normal plus one)
                SV.REN==-3    ;REENTER start address (as found in .JBREN)
                SV.DDT==-4    ;DDT start address (as found in .JBDDT)
                SV.CON==-5    ;CONTINUE start address
            
            
            subttl Halt Status Classes & Types
            
                HC.MEM==0     ;Memory Violations
                HT.PCO==0     ;PC Out of Bounds
                HT.IMR==1     ;Illegal Memory Reference
                HT.WRV==2     ;Write Violation
                HT.ADC==3     ;Address Check for Device X
                HT.IMU==4     ;Ill Mem Ref in UUO
                HT.IIA==5     ;Illegal Interrupt Address
                HT.ABK==6     ;Address Break
                HT.POV==7     ;PDL Overflow
                HC.SYS==1     ;System-Related Errors
                                                    A-9


            UUOSYM.MAC                               A                          YAMM edition 2.1


                HT.PIO==0     ;Page I/O Error
                HT.DFL==1     ;Disk Full during copy of .PRCW page
                HT.PHE==2     ;Paging Hardware Error
                HT.TPL==3     ;Too many Pages Locked, Cannot handle fault
                HT.CIO==4     ;Context Page I/O Error
                HT.PAR==5     ;Parity Error(s). All Core Removed
                HC.DEV==2     ;Device Related Errors
                HT.OCI==0     ;Output device Cannot Input
                HT.ICO==1     ;Input device Cannot Output
                HT.IDM==2     ;Illegal Data Mode for device X
                HT.IUC==3     ;I/O to Unassigned Channel
                HT.HDV==4     ;Hung Device
                HT.DOP==5     ;Device X OPR action requested
                HC.ILL==3     ;Illegal Instruction Traps
                HT.ILU==0     ;Illegal UUO
                HT.UUE==1     ;UUO error
                HT.ILI==2     ;Illegal Instruction
                HT.HLT==3     ;Halt
                HC.EXI==4     ;Frame Exits
                HT.EXI==0     ;Exit
                HT.EX1==1     ;Exit 1,
                HT.FEX==2     ;Fail Exit
                HT.TLE==3     ;Time Limit Exceeded
                HT.JSU==4     ;filename setup
                HT.JSV==5     ;filename saved
                HT.FCL==6     ;frame cleared
                HC.RUN==5     ;RUN,RUNSEG & GETSEG UUO errors
                HT.TRE==0     ;Transmission Error
                HT.PGN==1     ;N Pages Required
                HT.DNA==2     ;Device Not Available
                HT.FNF==3     ;filename.ext not found
                HT.NSF==4     ;Not a Save File
                HT.EUF==5     ;filename.ext Attempted Enter UUO Failed
                HT.CAN==6     ;Core Argument Not specified (magtape only)
                HT.MHB==7     ;Magtape Hiseg Format Bad
                HT.RMF==10    ;Remap UUO Fatal error
                HT.MGF==11    ;Magtape GET failure
                HT.NSA==12    ;No Start Address
            
            
            subttl .FORSI Item Numbers
            
                .SREXO==0     ;max frame rights for execute-only
                .SRLIC==1     ;max frame rights for process with license
                .SRALL==2     ;all rights defined by monitor
                .SRRCL==3     ;AR conferred by Read Core (RC)
                .SRSYL==4     ;AR comferred by Systat (SY)
                .SRTYM==5     ;AR conferred by JP.TYM privilege
                .SRAUN==6     ;AR conferred by having same AUN
                .SRJLL==7     ;AR conferred by Jacct (JL)
                .SRWCL==10    ;AR conferred by Write Core (WC)
            
            
            subttl Job Data Area Locations
            
                .JBUUO==40    ;LUUO storage location
                .JB41== 41    ;LUUO instruction location
                .JBREL==44    ;(Obsolescent) highest relative loc
                .JBBLT==45    ;Loader BLT locations 45-47
                .JBMUU==66    ;MUUO stored here on INTADR MUUO-trapping
                .JBHCU==72    ;Highest-channel-used stored here
                .JBDDT==74    ;DDT entry loc
                .JBJDA==75    ;Begin Array of channel-in-use flags
                .JBCNK==102   ;CHAIN temporary locs 102-110
                .JBCN6==106   ;more CHAIN temporary locs 106-113
                .JBPFI==114   ;(Obsolete) lower limit for I/O
                .JBHRL==115   ;(Obsolescent) Hiseg length and ending loc
                .JBSYM==116   ;Symbol-table pointer stored here
                                                    A-10


            June 27, 1984                            A                                UUOSYM.MAC


                .JBUSY==117   ;Undefined-symbols table pointer
                .JBSA== 120   ;Start Address of loaded program
                .JBFF== 121   ;First Free loc for buffered I/O to use
                .JBREN==124   ;REENTER command address stored here
                .JBAPR==125   ;APRENB transfer address stored here
                .JBCNI==126   ;APRENB simulated CONI word location
                .JBTPC==127   ;APRENB trap PC loc
                .JBOPC==130   ;Old PC loc set by DDT,START etc.
                .JBCHN==131   ;loaded FORTRAN program information
                .JBCOR==133   ;loc of last non-zero data in core image
                .JBCST==136   ;For Customer Use
                .JBVER==137   ;Version number
                .JBDA== 140   ;First loc available to user program
            
            
            subttl Vestigial Job Data Area Locations
            
                .JBHSA==0     ;copy of .JBSA
                .JBH41==1     ;copy of .JB41
                .JBHCR==2     ;copy of .JBCOR
                .JBHRN==3     ;.JBHRL,.JBREN restore word
                .JBHNM==5     ;hiseg name
                .JBHSM==6     ;pointer to hiseg symbol-table
                .JBHGA==7     ;(Obsolete)
                .JBHDA==10    ;first loc of hiseg available to user
            
            
            subttl Page Protection Codes
            
                .PRRO== 1B7   ;read-only
                .PRCW== 2B7   ;Copy-on-Write
                .PRRW== 3B7   ;Read-Write
            
            
            subttl VCREAT Error Codes
            
                CRBCN%==0     ;count = 0
                CRBVP%==1     ;bad page number
                CRBPR%==2     ;bad protection
                CREXV%==3     ;page already exists
                CRLIM%==5     ;exceeded existing page limit
                CRDFL%==6     ;disk full
            
            
            subttl VPROT Error Codes
            
                PTBCN%==0     ;count = 0
                PTBVP%==1     ;bad page
                PTBPR%==2     ;bad protection
                PTNVP%==4     ;page does not exist
                PTPRF%==5     ;protection failure (only lookup access
            
            
            subttl WSCTL Error Codes
            
                WSBCN%==0     ;count = 0
                WSBVP%==1     ;bad virtual page
            ;   ==      2     ;(unused)
            ;   ==      3     ;(unused)
                WSNVP%==4     ;virtual page does not exist
                WSBFN%==5     ;illegal function code
                WSCTL%==6     ;count too large
                WSEWL%==7     ;exceeded working set size limit
                WSLGM%==10    ;attempt to set limit over max
                WSLL3%==11    ;attempt to set limit under 3 pages
            
            
            subttl PREREF Error Codes
                                                    A-11


            UUOSYM.MAC                               A                          YAMM edition 2.1


            
                PRBVP%==1     ;bad page
                PRNVP%==4     ;page does not exist
                PRNIW%==5     ;page not in working set
            
            
            subttl BLTPAG Error codes
            
                BUCBB%==0     ;can't BLT backwards
                BUNWP%==1     ;data not all within one page
                BUCLP%==2     ;can't lock dest. page
            
            
            subttl PERSET Error Codes
            
                PEBCN%==0     ;bad count
                PEBVP%==1     ;bad page
                PENVP%==4     ;nonexistent page
            
            
            subttl PGESTS Word
            
                EI.VAL==1B0   ;information in error status word is valid
                EI.PAR==1B14  ;parity error on dirty page
                EI.OER==1B15  ;output error
                EI.DER==1B16  ;device error
                EI.DTE==1B17  ;data error
                EI.VPN==777777B35       ;virtual page number
            
            
            subttl VALPAG Error Codes
            
                VLBCN%==0     ;bad count
                VLBVP%==1     ;bad page
                VLNVP%==4     ;page does not exist
                VLIOE%==5     ;i/o error occurred
            
            
            subttl Page Fault Word
            
                FI.VAL==1B0   ;this word contains valid data
                FI.SAL==1B1   ;WSSIZ = WSLIM at time of fault
                FI.VPN==777B26;Virtual Page number
            
            
            subttl PGISTS Word
            
                II.ADR==777777B17       ;virtual address
                II.PFW==777777B35       ;soft page fail word
            
            
            subttl PGRSTS Word
            
                RI.VAL==1B0   ;information is valid
                RI.ADR==777777B35       ;virtual address
            
            
            subttl REFBIT Error Codes
            
                RFBCN%==0     ;bad count
                RFBVP%==1     ;bad page number
                RFBFN%==5     ;bad function
            
            
            subttl Page Status Word
            
                PS.UWS==1B0   ;in user working set
                PS.REF==1B1   ;page has been referenced
                                                    A-12


            June 27, 1984                            A                                UUOSYM.MAC


                PS.MXW==1B2   ;page can be protected read/write
                PS.SUP==1B3   ;super-mapped
                PS.DER==1B4   ;device page I/O error has occurred
                PS.DTE==1B5   ;data page I/O error has occurred
                PS.DDE==3B5   ;error mask
                PS.DRT==1B6   ;not dirty or swap-out in progress
                PS.NEW==1B7   ;errors for this page are ignored
                PS.OER==1B8   ;page has an output error
                PS.PAR==1B9   ;parity error on dirty page
                PS.FIL==1B32  ;originally mapped from a file
                PS.CPR==7B35  ;current protection
            ;   ==      0     ;page non-existent
            ;   ==      1     ;read only
            ;   ==      2     ;copy-on-write
            ;   ==      3     ;read/write
            
            
            subttl PAGSTS Error Code
            
                PSBVP%==1     ;bad page
            
            
            subttl VPGFIL Error Codes
            
                PFBVP%==1     ;bad vp number
                PFNEX%==4     ;non-existent vp
                PFNFP%==6     ;not file page
            
            
            subttl VDSKPT Error Codes
            
                PFBVP%==1     ;bad vp number
                VDNVP%==4     ;vp does not exist
                VDNEL%==5     ;not enough license
            
            
            subttl Standard Paging error Codes
            
                FLCTG%==0     ;virtual page count = 0
                FLDVR%==1     ;Destination virtual page out of range
                FLCPU%==2     ;current prot undefined
                FLVEX%==3     ;virtual page exists
                FLNEX%==4     ;page doesn't exist
                FLSVR%==5     ;source VP out-of-range
                FLPHP%==6     ;past highest page
                FLFPZ%==7     ;a specified file page number is = 0
                FLCOR%==10    ;caller's .PVCOR size limit will be exceeded
                FLRBE%==11    ;RIB error
                FLBDS%==12    ;bad SAT
                FLCPL%==13    ;specified prot cannot be set for the VP
                FLLKC%==14    ;file is LOOKUP only, cannot be mapped
                FLHOL%==15    ;file page which must exist is a hole
                FLNHL%==16    ;no hole at specified file page
                FLSNM%==17    ;structure name bad
                FLOPE%==20    ;i/o error on validation write of page
                FLSAM%==21    ;same source and destination page numbers
                FLNML%==22    ;file already selected
                FLNOF%==23    ;no file selected
                FLNWT%==24    ;no write allowed
                FLAQA%==25    ;disk full or user's quota exceeded
                FLCTL%==26    ;(not returned to user programs)
                FLIPE%==27    ;(not returned to user programs)
                FLNTF%==30    ;no page of desired kind found
                FLNIM%==31    ;function not implemented
                FLLGE%==32    ;suppress error logging not allowed
                FLNSP%==33    ;(obsolete)
                FLOFF%==34    ;"other frame" failure
                FLALF%==35    ;vp already mappable from a file
                                                    A-13


            UUOSYM.MAC                               A                          YAMM edition 2.1


                FLNSP%==36    ;trying to insert super-mapped vp into file
            
            
            subttl file status bits
            
                IO.IMP==1B18  ;improper mode
                IO.DER==1B19  ;device error
                IO.DTE==1B20  ;data error
                IO.BKT==1B21  ;block too large
                IO.ERR==17B21 ;error bit mask
                IO.EOF==1B22  ;end of file
                IO.ACT==1B23  ;device is active
                IO.EVP==1B26  ;(FTA: only) even parity
                IO.BK2==1B26  ;(TTY: only) break-on-punctuation bit
                IO.NEE==1B27  ;(TTY: only) no-escape-echo bit
                IO.NEC==1B28  ;(TTY: only) no-echo bit
                IO.DEN==3B28  ;(FTA: only) recording density
                IO.FCS==1B29  ;(TTY: only) full-character-set bit
                IO.SYN==1B30  ;synchronous i/o
                IO.UWC==1B31  ;user supplied word count
                IO.MOD==17B35 ;data mode mask
            
            
            subttl Data modes
            
                .IOASC==0     ;ASCII
                .IOASL==1     ;ASCII line
                .IOKAT==2     ;Katakana
                .IOIMG==10    ;Image
                .IOIBN==13    ;Image Binary
                .IOBIN==14    ;Binary
                .IODPR==16    ;Dump Records
                .IODMP==17    ;Dump
            
            
            subttl Device characteristic word
            
                DV.DSK==1B1   ;is a disk
                DV.CDR==1B2   ;is a card reader
                DV.LPT==1B3   ;is a line printer
                DV.TTA==1B4   ;is a frame's command port
                DV.NZP==1B5   ;do not zap circuit on a RESET
                DV.1UU==1B6   ;unused
                DV.2UU==1B7   ;unused
                DV.3UU==1B8   ;unused
                DV.PTP==1B9   ;is a paper tape punch
                DV.PTR==1B10  ;is a paper tape reader
                DV.4UU==1B11  ;unused
                DV.AVL==1B12  ;is available to this frame
                DV.MTA==1B13  ;is a magtape
                DV.TTY==1B14  ;is a terminal or aux circuit
                DV.DIR==1B15  ;has a directory
                DV.IN== 1B16  ;input possible
                DV.OUT==1B17  ;output possible
                DV.ASG==1B18  ;assigned by console
                DV.ASP==1B19  ;assigned by program
                DV.DMP==1B20  ;dump mode legal
                DV.DPR==1B21  ;dump records mode legal
                DV.BIN==1B23  ;binary mode legal
                DV.IBN==1B24  ;image binary mode legal
                DV.IMG==1B27  ;image mode legal
                DV.KAT==1B33  ;katakana mode legal
                DV.ASL==1B34  ;ASCII line mode legal
                DV.ASC==1B35  ;ASCII mode legal
            
            
            subttl SYSDVF Function Codes
            
                                                    A-14


            June 27, 1984                            A                                UUOSYM.MAC


                .SDDDN==0     ;Non-port/disk;
                .SDDDA==1     ;All;
                .SDUNI==2     ;Unit DDBs;
                .SDSTR==3     ;STR DDBs;
                .SDFTA==4     ;Mag Tape DDBs;
            
            
            subttl File protection codes
            
                FP.NO== 7     ;No access.
                FP.LK== 6     ;Lookup access.
                FP.RUN==5     ;Run access.
                FP.RD== 4     ;Read access.
                FP.AP== 3     ;Append access.
                FP.UPD==2     ;Update access.
                FP.CP== 1     ;Change-protection access.
                FP.ALL==0     ;All access.
            
            
            subttl Directory protection bits
            
                DP.LK== 4     ;Lookup access.
                DP.CR== 2     ;New files access.
                DP.RD== 1     ;Read access.
            
            
            subttl Extended Lookup Block Locations
            
                .RBPPN==1     ;PPN of UFD to search
                .RBNAM==2     ;SIXBIT /filename/
                .RBEXT==3     ;SIXBIT /extension/
                .RBPRV==4     ;privilege word
                .RBSIZ==5     ;File size in words
                .RBVER==6     ;Version (not used by monitor)
                .RBFUT==7     ;(not used by monitor)
                .RBEST==10    ;Estimated file size (in blocks)
                .RBALC==11    ;Allocated storage (in blocks)
                .RBPOS==12    ;(not used)
                .RBFT1==13    ;(not used)
                .RBLIC==14    ;File license word
                .RBMTA==15    ;(not used)
                .RBDEV==16    ;zero
                .RBSTS==17    ;File status bits
                .RBELB==20    ;Error logical block
                .RBXT1==21    ;zero
                .RBQTF==22    ;Logged-in disk quota
                .RBQTO==23    ;Logged-out disk quota
                .RBMXA==24    ;
                .RBUSD==25    ;
                .RBAUT==26    ;Author (last writer's) PPN
                .RBUNM==27    ;Username (SIXBIT)
                .RBTRU==31    ;unused
                .RBXT2==32    ;unused
                .RBALP==33    ;Allocated pages
                .RBSNM==34    ;number of spare RIBs
                .RBPJC==35    ;Project-code block
                .RBPID==40    ;Processor ID
            
            
            subttl file selection error codes
            
                .ERFNF==0     ;File Not Found.
                .ERIPP==1     ;Incorrect PPN.
                .ERPRT==2     ;Protection failure.
                .ERFBM==3     ;File being modified.
                .ERAEF==4     ;Already existing file.
                .ERISU==5     ;Illegal Sequence of UUOs.
                .ERTRN==6     ;Transmission error.
                                                    A-15


            UUOSYM.MAC                               A                          YAMM edition 2.1


                .ERNSF==7     ;Not a saved file.
                .ERNEC==10    ;Not enough core.
                .ERDNA==11    ;Device not available.
                .ERNSD==12    ;No such device.
                .ERILU==13    ;(never happens)
                .ERNRM==14    ;No room.
                .ERWLK==15    ;(never happens)
                .ERNET==16    ;Not enough table space.
                .ERPOA==17    ;(never happens)
                .ERBNF==20    ;(never happens)
                .ERNTR==21    ;(never happens)
                .ERLKM==22    ;(never happens)
            
            
            subttl DSKCHR status bits
            
                DC.OFL==1B1   ;unit offline
                DC.HWP==1B2   ;unit hardware write-protected
                DC.USF==1B6   ;unit unsafe
                DC.MSB==1B9   ;unit has multiple SAT blocks
                DC.TYP==7B17  ;type of name passed to DSKCHR
                .DCTDS==0     ;generic DSK
                .DCTFS==2     ;file structure
                .DCTUF==3     ;unit within structure
                .DCTCN==4     ;controller class
                .DCTCC==5     ;controller within class
                .DCTPU==6     ;unit within controller
                DC.DCN==7B20  ;data channel number
                DC.CNT==77B26 ;controller type
                .DCCDR==0     ;FH  drum
                .DCCFH==1     ;    fixed-head disk
                .DCCDP==2     ;DP  disk pack (RP01,RP02)
                .DCCMD==3     ;    mass disk
                .DCCBP==4     ;BP  big pack (IBM 3330)
                DC.CNN==7B29  ;controller number
                DC.UNT==3B31  ;unit type
                .DCUBU==0     ;Burroughs disk
                .DCBBR==1     ;Bryant drum
                .DCUD1==0     ;RP01
                .DCUD2==1     ;RP02
                .DCUDP==0     ;dual positioner
                .DCUSP==1     ;single positioner
                .DCUM1==0     ;3330 Model I
                .DCUM2==1     ;3330 Model II
                DC.UNN==7B35  ;unit number within controller
            
            
            subttl GOBSTR error codes
            
                DFGIF%==3     ;addr+2 is not in search list
                DFGPP%==6     ;frame and PPN do not agree
                DFGNP%==10    ;No license
                DFGLN%==12    ;Bad length for list
            
            
            subttl STRUUO function codes
            
                .FSSRC==0     ;Define new search list for frame
                .FSDSL==1     ;Define new search list
                .FSDEF==2     ;Define new file structure
                .FSRDF==3     ;Redefine file structure
                .FSLOK==4     ;Lock file structure
                .FSREM==5     ;Remove file structure
                .FSULK==6     ;Test/Set UFD interlock
                .FSUCL==7     ;Clear UFD interlock
                .FSETS==10    ;Simulate hard errors
                .FSRRL==11    ;Read/reset log for 3330's
            
                                                    A-16


            June 27, 1984                            A                                UUOSYM.MAC


            
            subttl STRUUO error codes
            
                FSILF%==0     ;Illegal function code
                FSSNF%==1     ;Structure not found
                FSSSA%==2     ;Structure single access only
                FSILE%==3     ;Illegal list entry
                FSTME%==4     ;Too many entries in list
                FSUNA%==5     ;Unit not available
                FSPPN%==6     ;PPN doesn't match
                FSMCN%==7     ;Mount count greater then 1
                FSNPV%==10    ;No license
                FSFSA%==11    ;Structure already exists
                FSILL%==12    ;Bad list length
                FSUNC%==13    ;Unable to complete UUO
                FSNFS%==14    ;System full of structures
                FSNCS%==15    ;No free core
                FSUNF%==16    ;Illegal unit
                FSRSL%==17    ;File structure repeated in list
            
            
            subttl RETACH error codes
            
                RTSAC%==1     ;insufficient access rights to source frame
                RTSNX%==2     ;source frame does not exist
                RTTAC%==3     ;insufficient access rights  to target frame
                RTTNX%==4     ;target frame does not exist
                RTSNA%==5     ;specified port not attached to source frame
                RTTAT%==6     ;target frame already has port attached
                RTSCP%==7     ;forced command already pending on port
                RTAUX%==10    ;attaching aux circuit as command port
                RTNRM%==11    ;no room for new port DDB
            
            
            subttl CREAUX control bits
            
                CX.NZP==1B17  ;don't zap on RESET
            
            
            subttl CREAUX Error Codes (left half)
            
                CXSUP%==0     ;supervisor error code in right half
                CX2AX%==1     ;too many circuits without Auxiliary Circuit (AC)
                CXLOG%==2     ;not your username without Auxiliary Circuit (AC)
                CXDCB%==3     ;no room in monitor
                CXNRR%==4     ;supervisor did not respond
                CXNRL%==5     ;supervisor did not respond
                CXNCH%==6     ;supervisor did not supply a circuit
                CXERR%==7     ;supervisor error from original request
            
            
            subttl CREAUX Error Codes (right half)
            
                CXSFE%==1     ;format error
                CXSBU%==2     ;user not in mud
                CXSBM%==3     ;bad mud
                CXSHU%==4     ;host unavailable
                CXSDF%==5     ;downline load or dialout request failure
                CXSTO%==6     ;timeout
                CXSAB%==7     ;access barred
                CXSIS%==10    ;error in ISIS
                CXSLQ%==11    ;long queue in supervisor
            
            
            subttl Port Event-Status Bits
            
                LXRESC==1B0   ;escape seen
                LXROBS==1B1   ;orange ball seen
                                                    A-17


            UUOSYM.MAC                               A                          YAMM edition 2.1


                LXRPSS==1B2   ;port status message seen
                LXRICL==1B3   ;input characters lost
                LXROCL==1B4   ;output characters lost
                LXRCHR==1B5   ;character seen
                LXRBRK==1B6   ;break condition seen
                LXRYBS==1B7   ;yellow ball seen
                LXRGOB==1B8   ;character gobbler seen
                LXRIOS==1B9   ;output done
                LXRTCC==1B10  ;terminal characteristic changed or port just attached
            
            
            subttl Line Characteristics Word
            
                LC.ECS==1B2   ;"command line" exists, will be thrown away
                LC.PSS==1B3   ;** a port status message has been seen
                LC.OBS==1B4   ;** an orange ball has been seen
                LC.HDX==1B5   ;* half duplex
                LC.ESC==1B6   ;** an escape has been seen
                LC.CRD==1B7   ;* compute carriage return delay (not LF)
                LC.DFR==1B8   ;in deferred echo mode
                LC.NOP==1B9   ;suppress output bit
                LC.NFC==1B10  ;* no free carriage return
                LC.BRK==1B11  ;input buffer contains a break character
                LC.AXC==1B12  ;auxiliary circuit
                LC.NCM==1B13  ;* no case mapping
                LC.HHT==1B14  ;* hardware horizontal tabs
                LC.LCP==1B15  ;local-copy (e.g. 2741) device
                LC.PTM==1B16  ;* paper tape mode
                LC.HFF==1B17  ;* hardware VT/FF
                LC.PNO==777777B35       ;port number
            
            
            subttl Terminal Characteristics/TTY Commands
            
                .TCCRD==0     ;delay after CR not after LF
                .TCCIR==1     ;input baud rate IN
                .TCCOR==2     ;output baud rate OUT
                .TCPAR==3     ;set output parity
                .TCHDX==4     ;half-duplex *ECHO
                .TCPA== 5     ;parameter A A
                .TCPB== 6     ;parameter B B
                .TCPC== 7     ;parameter C C
                .TCXON==8     ;remote XON XON
                .TCECH==9     ;remote backspace echo RBS
                .TCRXE==10    ;reverse XON enable RXE
                .TCTYP==11    ;terminal type TYPE
                .TCNXO==12    ;never send XON/XOFF
                .TCWID==13    ;terminal line width WIDTH
                .TCFC1==14    ;filler class 1 FILL1
                .TCFC2==15    ;filler class 2 FILL2
                .TCBSP==16    ;backspace for character delete BACKSPACE
                .TCERA==17    ;backspace/space/backspace for delete ERASE
                .TCDEF==18    ;stay in deferred echo mode DEF
                .TCLCO==19    ;lower case output only UCO
                .TCTAB==20    ;hardware HT TAB
                .TCFRM==21    ;hardware VT/FF FORM
                .TCLCT==22    ;map lower-case input to upper *LC
                .TCNFC==23    ;no free CR/LFs on long line *CRLF
                .TCPTP==24    ;paper tape mode TAPE
                .TCBSD==25    ;^H for rubout BSD
                .TCTTP==26    ;terminal class in SIXBIT CLASS
                .TCRTC==27    ;enable ^TRTCOMP
            
            
            subttl MTAPE Functions
            
                .MTWAT==0     ;wait for i/o completion
                .MTREW==1     ;rewind
                                                    A-18


            June 27, 1984                            A                                UUOSYM.MAC


                .MTEOF==3     ;write tape mark
                .MTSKR==6     ;skip forward 1 record
                .MTBSR==7     ;backspace 1 record
                .MTEOT==10    ;go to logical end of tape
                .MTUNL==11    ;rewind and unload
                .MTBLK==13    ;erase gap
                .MTSKF==16    ;skip forward 1 file
                .MTBSF==17    ;backspace 1 file
                .MTDEC==100   ;set DEC 9-track mode
                .MTIC0==101   ;set IBM 9-track mode, byte adjust 0
                .MTIC1==102   ;set IBM 9-track mode, byte adjust 1
                .MTIC2==103   ;set IBM 9-track mode, byte adjust 2
                .MTIC3==104   ;set IBM 9-track mode, byte adjust 3
                .MT7E0==201   ;set special 7-track mode, byte adjust 0
                .MT7E1==202   ;set special 7-track mode, byte adjust 1
                .MT7E2==203   ;set special 7-track mode, byte adjust 2
                .MT7E3==204   ;set special 7-track mode, byte adjust 3
            
            
            subttl UGETF Function Codes
            
                .UGCNT==0     ;return byte/word count of last input
                .UGSEN==1     ;return drive sense data
                .UGSTS==2     ;return drive status data
                MT.PRO==1B0   ;write protected
                MT.TAB==3B2   ;TU A & B
                MT.LDP==1B3   ;load point
                MT.EOT==1B4   ;end of tape indicator
                MT.IBM==1B5   ;IBM compatible unit
                MT.7TR==1B12  ;7 track capability
                MT6250==1B13  ;6250 bpi capability
                MT1600==1B14  ;1600 bpi
                MT800== 1B15  ;800 bpi
                MT556== 1B16  ;556 bpi
                MT200== 1B17  ;200 bpi
            
            
            subttl APRENB interrupt bits
            
                AP.REN==1B18  ;Repetitive enable
                CN.POV==1B19  ;Stack Overflow or Underflow
                AP.POV==1B19  ;Stack Overflow or Underflow
                CN.UUO==1B18  ;UUO or ill ins
                AP.UUO==1B20  ;UUO or ill ins
                CN.BRK==1B24  ;Break character
                AP.BRK==1B21  ;Break character
                CN.ILM==1B22  ;Ill mem ref
                AP.ILM==1B22  ;Ill mem ref
                CN.CHR==1B21  ;Character
                AP.CHR==1B24  ;Character
                CN.ESC==1B17  ;Escape (ctrl-C)
                AP.ESC==1B25  ;Escape (ctrl-C)
                CN.CLK==1B26  ;Clock tick
                AP.CLK==1B26  ;Clock tick
                CN.FOV==1B29  ;Floating overflow
                AP.FOV==1B29  ;Floating overflow
                CN.HNG==1B16  ;Hung device
                AP.HNG==1B30  ;Hung device
                CN.AOV==1B32  ;Integer overflow
                AP.AOV==1B32  ;Integer overflow
            
            
            subttl Port Interrupt Cause Codes
            
                .IAESC==0     ;Receipt of an escape.
                .IACHR==1     ;Receipt of a character.
                .IABRK==2     ;Receipt of a break character or a "line" of data.  A line
                .IAIOW==3     ;Potential i/o wait.
                                                    A-19


            UUOSYM.MAC                               A                          YAMM edition 2.1


                .IAROM==4     ;Room for more output characters.
                .IALOS==5     ;Characters lost on input.
                .IAORG==6     ;Receipt of an orange ball.
                .IAZAP==7     ;Receipt of a circuit zapper.
                .IAPSS==10    ;Port Status msg seen
                .IAYEL==11    ;Receipt of Yellow Ball.
                .IAGOB==12    ;Receipt of Character Gobbler.
                .IATCC==13    ;Terminal characteristics changed at other end of PTY.
            
            
            subttl General Interrupt Cause Codes
            
                .IAUUO==0     ;UUO or illegal instruction
                .IACLK==1     ;Clock tick while running
                .IAILM==2     ;Ill mem ref
                .IAHNG==3     ;Hung device
                .IATIM==4     ;SETTIM timer interrupt
                .IADEV==5     ;Device error
                .IAWAK==6     ;Wake UUO for this frame
                .IAFEL==7     ;Page fault (WS=WSL)
                .IAFLL==10    ;Page fault (WSWSL)
                .IAREF==11    ;Reference-bit trap
                .IAERR==12    ;Paging i/o error
                .IANTQ==13    ;Notice to quit (sys going down)
                .IAFEX==14    ;Frame exit in child
            
            
            subttl INTRMT error codes
            
                IRBCH%==1     ;bad i/o channel
                IRBDR%==5     ;bad interrupt reason
                IRBIC%==6     ;bad interrupt channel number
                IRNIS%==7     ;no INTADR system in effect
            
            
            subttl Club Interlock Status Flags
            
                CB.NML==1     ;last interlock release was normal
                CB.EVI==2     ;Ever Interlocked
            
            
            subttl Club Facility Standard Error Codes
            
                CBVPR%==1     ;VP number out of legal range
                CBNEX%==2     ;VP does not exist (has no disk page mapped)
                CBINC%==3     ;Caller already in a club for this VP
                CBIDO%==4     ;Club ID number overflow
                CBNIC%==5     ;Not in Club (from UUOs requiring club membership)
                CBVPM%==6     ;VP mismatch
                CBHIL%==7     ;Have Interlock,cannot perform UUO at this time
                CBAIL%==10    ;Attempted to get Interlock, but it was busy
                CBNIL%==11    ;No Interlock
                CBCNT%==12    ;Requested count of club members is negative
                CBNFC%==13    ;Not First Class
                CBJNI%==14    ;Frame Not In your club, can't get info on it
            
            
            subttl GETTAB table numbers
            
                .GTTMO==-55   ;inactivity timeout limit
                .GTFTR==-54   ;frame tree information (Table 18-8 )
                .GTUID==-53   ;Universal ID
                .GTPNO==-52   ;Program Number
                .GTSPW==-51   ;double precision pages-to-WS*size
                .GTPWS==-50   ;pages to working-set
                .GTMPC==-47   ;pages mapped/created
                .GTMCY==-46   ;double precision microcycles
                .GTKCM==-45   ;double precision K-core microcycles
                                                    A-20


            June 27, 1984                            A                                UUOSYM.MAC


                .GTTRU==-44   ;double precision TRUs * 10^4
                .GTTR2==-43   ;high order TRUs * 10^4
                .GTMC2==-42   ;high order microcycles
                .GTBIO==-41   ;block IO chars transmitted
                .GTBET==-40   ;BIO elapsed time (sec)
                .GTSOK==-37   ;TYMCHG TRUs * 10^4
                .GTLNK==-36   ;debugging tables
            ;   ==      -35   ;(obsolete) remote IO
            ;   ==      -34   ;(obsolete) remote secs
                .GTERN==-33   ;ENTER + RENAME count
                .GTLPS==-32   ;tty input line position
                .GTMOD==-31   ;tty mode (GETSTS info)
                .GTLIM==-30   ;time limit (TRUs * 10^4)
                .GTLIN==-27   ;TTY: name in SIXBIT; (lh)=0 if detached
                .GTJOB==-26   ;frame which owns this port
                .GTFPN==-25   ;File Proj-prog Number
                .GTLOG==-24   ;LDBLOG info (Table 18-9b)
                .GTAUN==-23   ;Accounting User Number
                .GTUNM==-22   ;user name (1-6) SIXBIT
                .GTUN1==-21   ;user name (7-12) SIXBIT
                .GTLIC==-20   ;license word
            ;   ==      -17   ;reserved
            ;   ==      -16   ;reserved
                .GTMC1==-15   ;low order microcycles
                .GTKM2==-14   ;high order K-core microcycles
                .GTBCS==-13   ;K-core break chars
                .GTCNK==-12   ;attach time (sec)
                .GTELP==-11   ;K-core seconds
                .GTCOT==-10   ;characters output
                .GTCIN==-7    ;characters input
                .GTSOT==-6    ;K-core DSK blocks out
                .GTSIN==-5    ;K-core DSK blocks in
                .GTSRN==-4    ;K-core ENTER + RENAME
                .GTSLK==-3    ;K-core LOOKUP
                .GTDLK==-2    ;LOOKUP count
            ;   ==      -1    ;reserved
                .GTSTS==0     ;Status Bits (Table 2-7 )
            ;   ==      1     ;reserved
                .GTPPN==2     ;Project Programmer Number
                .GTNAM==3     ;SIXBIT user program name
                .GTTR1==4     ;low order TRUs * 10^4
                .GTKM1==5     ;low order K-core microcycles
                .GTPRV==6     ;Privilege Bits (Table 2-3 )
                .GTSWP==7     ;swapper status bits
                .GTTTY==10    ;address of TTY DDB
                .GTCNF==11    ;config data (Table 18-8b)
                .GTNSW==12    ;nonswap data (Table 18-10b)
            ;   ==      13    ;(obsolete) swapper data
            ;   ==      14    ;(obsolete) high seg data
                .GTODP==15    ;ONCE-time disk parameters (Table 18-11 )
                .GTLVD==16    ;level-D disk (Table 18-10 )
                .GTRCT==17    ;DSK blocks in
                .GTWCT==20    ;DSK blocks out
            ;   ==      21    ;reserved
            ;   ==      22    ;reserved
                .GTSLF==23    ;GETTAB table addresses
            ;   ==      24    ;(obsolete) dev/str name
                .GTWSC==25    ;wait states (Table 18-11b)
            ;   ==      26    ;reserved
            ;   ==      27    ;(obsolete) physical core table
            
            
            subttl .GTFTR Bits (GETTAB -54)
            
                FT.PAR==7777B11         ;parent
                FT.NBR==7777B23         ;right hand neighbor
                FT.CHL==7777B35         ;leftmost child
            
                                                    A-21


            UUOSYM.MAC                               A                          YAMM edition 2.1


            
            subttl .GTCNF Items
            
                .CNFG0==0     ;System Name (in ASCII)
                .CNDT0==5     ;System Date (in ASCII)
                .CNTAP==7     ;System Device Name (in SIXBIT)
                .CNTIM==10    ;jiffies since midnight GMT
                .CNDAT==11    ;days since 1 January 1964 GMT
                .CNSIZ==12    ;words used by monitor
                .CNOPR==13    ;operator console name (in SIXBIT)
                .CNDEV==14    ;lh = address of first DDB
                .CNNJB==15    ;largest possible frame number+1
                .CNSTS==17    ;states word (Table 18-9
                .CNSER==20    ;cpu serial number
                .CNNSM==21    ;memory cycle time (in nanoseconds)
                .CNFRE==22    ;freecore bit map AOBJN pointer
                .CNLOC==23    ;address of first freecore
                .CNPTS==24    ;number of ports
                .CNLGO==25    ;LOGOUT program name (in SIXBIT)
                .CNJPS==26    ;jiffies per second
                .CNJPM==27    ;jiffies per minute
                .CNJPH==30    ;jiffies per hour
                .CNHGH==31    ;highest addressible block in core
                .CNHFD==32    ;Snoopy facility buffer size,,beginning loc
                .CNSYS==33    ;system number
                .CNFCW==34    ;freecore words allocated
                .CNSCC==35    ;Soft Crash Countdown in seconds
                .CNS30==36    ;XWD SAV30,NUMTAB ; info for crash analysis
                .CNDPT==37    ;pointer to patch area patches
                .CNRPT==40    ;pointer to new patch area
                .CNCPU==41    ;cpu type (1 = KI, 2 = KL, 3 = KS, 4 = F3)
                .CNMAP==42    ;mask of patches installed
                .CNMID==43    ;sixbit monitor ID (serial number)
            
            
            subttl states word
            
                ST.SYS==1B0   ;disk system
                ST.SWP==1B1   ;swapping system
                ST.LOG==1B2   ;login
                ST.FDP==1B3   ;TTCALL, full duplex
                ST.PRV==1B4   ;privilege feature included
                ST.REE==1B5   ;reentrant software
                ST.LVD==1B9   ;level D disk software
                ST.PRR==1B10  ;independent project-R numbers
                ST.IMG==1B11  ;image, 8 bit scnser
                ST.AUT==1B17  ;system in auto restart
                ST.SHT==1B18  ;system shut
                ST.SUP==1B19  ;system super shut
                ST.RLB==1B20  ;restricted logins
            
            
            subttl .GTLOG Bits (GETTAB -24)
            
                LG.ZAP==1B1   ;a zapper has been received on this port
                LG.GON==1B2   ;this port is gone
                LG.HDX==1B6   ;this port is half-duplex
                LG.TID==27B11 ;terminal identifier code
                LG.ND1==77B19 ;high-order 6 bits of the originating node number
                LG.ND2==77B27 ;low-order 6 bits of the originating node number
                LG.POR==177B35;TYMNET port number
            
            
            subttl .GTLVD (GETTAB 16) Items;
            
                .LDMFD==0     ;MFD PPN [1,1]
                .LDSYS==1     ;SYS PPN [1,4]
                .LDFSF==2     ;FAILSAFE PPN  (obsolete)
                                                    A-22


            June 27, 1984                            A                                UUOSYM.MAC


                .LDHLP==3     ;HELP PPN (obsolete)
                .LDSPL==4     ;SPOOL PPN (obsolete)
                .LDDRB==5     ;directory block pointers
                .LDSTR==6     ;(obsolete)
                .LDUNI==7     ;unit data block pointers
                .LDSWP==10    ;(unused)
                .LDCBN==11    ;number of file system core blocks
                .LDSTP==12    ;standard file protection
                .LDUFP==13    ;standard directory protection
                .LDRPC==14    ;number of RIB PCBs
                .LDSPC==15    ;number of SAT PCBs
                .LDQST==16    ;sixbit name of fastest STR
                .LDACT==17    ;accounting program PPN [6,270]
                .LDCRS==20    ;(obsolete)
                .LDLKB==21    ;longest meaningful LOOKUP block size
            
            
            subttl .GTNSW items (GETTAB 12)
            
                .NSCMX==10    ;maximum CORE request + 1
                .NSCTL==12    ;# free core blocks left
                .NSUPT==15    ;uptime (in jiffies)
                .NSHJB==20    ;highest frame number currently assigned
                .NSCLW==21    ;(obsolete) words cleared by CLRCOR
                .NSLST==22    ;lost time (in jiffies)
                .NSMMS==23    ;physical memory size (in words)
                .NSTPE==24    ;# parity errors
                .NSSPE==25    ;# spurious parity errors
                .NSCPE==26    ;# oper cont from parity errors
                .NSMPA==27    ;addr of last parity error
                .NSMPW==30    ;contents of that word
                .NSMPP==31    ;PC at the time of that error
                .NSNUL==34    ;null time (tics)
                .NSNMN==35    ;null time during the last minute (tics)
                .NSALR==36    ;alarm (unhappy msg) bits
                .NSMWM==37    ;monitor WS max size
                .NSUID==40    ;latest UID issued (SYSUID)
                .NSSTM==41    ;uptime of latest SCNSER cycle
                .NSMXT==42    ;max time between SCNSER cycles
            
            
            subttl .GTODP items (once disk parameters)
            
                .ODSWH==0     ;highest block for swapping (obsolete)
                .ODSWK==1     ;K of disk words for swapping (obsolete)
                .ODPRT==2     ;in-core protect mult (tics/page)
                .ODPRA==3     ;in-core protect offset (tics)
                .ODMXP==4     ;max value for ICPT function
                .ODDCT==5     ;action code for DSKCLN
            
            
            subttl Wait State Codes
            
            ;   WS.RN==       ;running
            ;   WS.WS==       ;i/o wait satisfied
            ;   WS.TS==       ;Terminal i/o wait satisfied
            ;   WS.SS==       ;Swap wait satisfied
            ;   WS.SI==       ;SAT i/o wait
            ;   WS.RI==       ;RIB i/o wait
            ;   WS.PS==       ;SAT primary PCB wait
            ;   WS.PR==       ;RIB primary PCB wait
            ;   WS.M2==       ;Two PCB wait
            ;   WS.DA==       ;Disk Allocation wait
            ;   WS.CB==       ;File system Core Block resource wait
            ;   WS.FC==       ;Freecore wait
            ;   WS.MT==       ;Magtape control wait (up to 8 units)
            ;   WS.AX==       ;Aux Circuit resource wait
            ;   WS.AC==       ;Accounting Resource wait
                                                    A-23


            UUOSYM.MAC                               A                          YAMM edition 2.1


            ;   WS.BP==       ;Block i/o port resource wait
            ;   WS.IOW==      ;i/o wait
            ;   WS.MBW==      ;Monitor Buffer wait
            ;   WS.TIO==      ;Terminal i/o wait
            ;   WS.SW==       ;Swap wait
            ;   WS.ML==       ;PCB Lock queue wait
            ;   WS.IL==       ;Club Interlock wait
            ;   WS.FL==       ;File wait (atomic lock queue)
            ;   WS.SL==       ;Sleep
            ;   WS.NU==       ;Null (no process here)
            ;   WS.ST==       ;Stop (usually displayed "^C")
            
            
            subttl STTLK Error Codes
            
                TKROM%==0     ;no room for characters
                TKEXS%==1     ;job does not exist
                TKATT%==2     ;job is detached
                TKBSY%==3     ;job busy or no license
            
            
            subttl SETABK control bits
            
                AB.FET==1B9   ;break on instruction-fetch
                AB.RED==1B10  ;break on reads
                AB.WRT==1B11  ;break on writes
                AB.USR==1B12  ;0=monitor, 1=user addressUUODEF==1
            end








































                                                    A-24


            June 27, 1984                            B                      System Calls by Name



                                            System Calls by Name
                                            ______ _____ __ ____



            Call             Name      Page    Description

            CALLI ac,+16     APRENB    16-2    enable APRENB trapping
            CALLI ac,-6      ATTACH    10-23   attach command port to frame
            op code 042      AUXCAL    10-5    perform port i/o functions
               fn 66         .AXBBP    10-34   r/s backspace break/punctuation bit
               fn 57         .AXBS     10-34   r/s BS-for-char-delete bit
               fn 6          .AXCBI    10-35   clear input buffer
               fn 7          .AXCBO    10-36   clear output buffer
               fn 64         .AXCFS    10-33   change port file status bits
               fn 101        .AXCLR    10-34   r/s special ctrl T mode
               fn 14         .AXCRD    10-34   r/s compute-CR-delay bit
               fn 34         .AXEBM    10-48   enter block i/o mode
               fn 63         .AXEDE    10-34   r/s force deferred-echo bit
               fn 17         .AXEP     10-34   r/s even-parity bit
               fn 62         .AXERA    10-34   r/s Erase-for-char-delete bit
               fn 30         .AXFC1    10-34   r/s filler class 1
               fn 31         .AXFC2    10-34   r/s filler class 2
               fn 72         .AXFRS    10-42   force rescan string [CNT,PTR]
               fn 20         .AXHD     10-34   r/s half-duplex bit
               fn 60         .AXHNG    10-27   send hangup
               fn 24         .AXHNX    10-34   r/s host-no-XON bit
               fn 2          .AXI8B    10-40   input char [wait/img]
               fn 0          .AXI8C    10-39   input char [wait/bka/img]
               fn 1          .AXI8S    10-39   input char [skip/bka/img]
               fn 15         .AXIBR    10-34   r/s input baud rate
               fn 36         .AXIBS    10-49   input block and skip
               fn 35         .AXIBW    10-48   input block and wait
               fn 45         .AXICS    10-37   input char [skip/bka]
               fn 44         .AXICW    10-37   input char [wait/bka]
               fn 47         .AXISL    10-39   input char [skip]
               fn 46         .AXIWL    10-38   input char [wait]
               fn 42         .AXLBM    10-48   leave block i/o mode
               fn 65         .AXLCO    10-34   r/s Lower-case-output bit
               fn 11         .AXLDE    10-35   leave deferred echo mode
               fn 25         .AXNTE    10-34   r/s no HT/VT/FF bit
               fn 75         .AXNZP    10-29   r/s no zap on reset bit
               fn 3          .AXO8     10-44   output char [IMG]
               fn 4          .AXO8I    10-45   output char [IMG/IMM]
               fn 37         .AXOB     10-49   block output
               fn 16         .AXOBR    10-34   r/s output baud rate
               fn 51         .AXOCI    10-44   output char [IMM]
               fn 67         .AXOPC    10-47   output string [STR]
               fn 76         .AXOSF    10-47   output string, never wait [STR]
               fn 52         .AXOST    10-47   output string
               fn 21         .AXPA     10-34   r/s parameter A
               fn 22         .AXPB     10-34   r/s parameter B
               fn 23         .AXPC     10-34   r/s parameter C
               fn 61         .AXPSM    10-29   read port-status msg
               fn 5          .AXPTR    10-46   output string [PTR]
               fn 54         .AXRBS    10-34   r/s remote-BS-echo bit
               fn 53         .AXRMX    10-34   r/s remote-XON bit
               fn 77         .AXRUB    10-34   r/s ctrl H/rubout bit
               fn 55         .AXRVX    10-34   r/s reverse-XON bit
               fn 13         .AXS8B    10-35   set image break char
               fn 32         .AXSFS    10-33   set port file status bits (obsolete)
               fn 33         .AXSI     10-41   simulate input
               fn 10         .AXSIC    10-41   skip if char
               fn 50         .AXSIL    10-41   skip if break char
               fn 43         .AXSLV    10-26   slave command port
               fn 70         .AXSOB    10-35   send orange ball
               fn 71         .AXSOX    10-34   r/s suppress output translation bit
               fn 12         .AXSYB    10-35   send yellow ball
                                                    B-1


            System Calls by Name                     B                          YAMM edition 2.1

            Call             Name      Page    Description
               fn 40         .AXTBI    10-49   terminate block input
               fn 26         .AXTBK    10-34   r/s tabs-as-breaks bit
               fn 41         .AXTBO    10-49   terminate block output
               fn 73         .AXTCN    10-31   r/s terminal charactertistics by number
               fn 74         .AXTCP    10-31   read changed tc number,,value for a pty
               fn 100        .AXTTP    10-34   r/s terminal class
               fn 56         .AXTYP    10-34   r/s terminal type
               fn 27         .AXWID    10-34   r/s line width
            CALLI ac,-46     AUXRED    10-27   read aux circuit port numbers
            CALLI ac,-120    BITPOK    18-12   read/modify/write in monitor memory
            CALLI ac,-123    BLTPAG    4-10    change data in page uninterruptibly
            CALLI ac,-2      CALIM2    19-6    (obsolete)
            CALLI ac,-3      CALIM3    19-6    (obsolete)
            CALLI ac,-4      CALIM4    19-6    (obsolete)
            CALLI ac,-5      CALIM5    19-6    (obsolete)
            op code 043      CHANIO    5-8     do channel i/o functions
               fn 40         .CHCFP    8-24    create file page
               fn 1          .CHCLS    5-12    close a file
               fn 36         .CHDFP    8-24    delete file page
               fn 5          .CHENT    8-16    select file for output
               fn 44         .CHFFI    8-26    Find First Interesting Page
               fn 27         .CHFSI    8-21    set file pointer by block
               fn 30         .CHFSO    8-22    set file position by block
               fn 45         .CHFTR    8-25    Truncate File
               fn 17         .CHGS     5-13    read file status bits
               fn 22         .CHIBF    6-3     create input buffer ring
               fn 14         .CHIN     5-11    input from channel
               fn 3          .CHIPT    5-11    input from channel
               fn 4          .CHLK     8-17    select file for input
               fn 26         .CHMBF    6-4     move buffers
               fn 41         .CHMEN    8-16    select file for multi-update output
               fn 35         .CHMFP    4-5     map file pages
               fn 34         .CHMGN    8-26    manipulate update-interlock bit
               fn 12         .CHMTA    11-3    perform magtape functions
               fn 42         .CHNXT    5-14    return next channel
               fn 23         .CHOBF    6-3     create output buffer ring
               fn 13         .CHOPN    5-10    Open a Channel
               fn 2          .CHOPT    5-11    output from channel
               fn 15         .CHOUT    5-11    output from channel
               fn 31         .CHPSI    8-21    set file pointer by page
               fn 32         .CHPSO    8-22    set file position by page
               fn 0          .CHREL    5-12    release device
               fn 11         .CHREN    8-17    rename or delete a file
               fn 24         .CHSK     8-23    seek to current page
               fn 43         .CHSMP    4-6     super-map file pages
               fn 21         .CHSO     5-13    skip if file status bits set
               fn 16         .CHSS     5-13    set file status bits
               fn 20         .CHSZ     5-13    skip if file status bits clear
               fn 33         .CHUFD    8-3     read UFD
               fn 10         .CHUGF    8-32    read disk file position
               fn 6          .CHUSI    8-21    set file pointer by block
               fn 7          .CHUSO    8-22    set file position by block
               fn 47         .CHVMP    8-25    move virtual page to a file
               fn 42         .CHVRB    8-32    validate RIB
               fn 25         .CHWT     5-7     wait until device inactive
               fn 37         .CHXFP    8-24    exchange file pages
            CALLI ac,+74     CHGPPN    2-2     change frame PPN
            CALLI ac,-31     CHKLIC    2-4     check settable license
            CALLI ac,-61     CHPRJ     2-8     change project code
            CALLI ac,-114    CLBADD    17-3    Join Club
            CALLI ac,-104    CLBHNG    17-6    Hang Club Member
            CALLI ac,-111    CLBINI    17-4    Get Interlock,No Wait
            CALLI ac,-112    CLBINW    17-4    Get Interlock,wait
            CALLI ac,-113    CLBLEV    17-3    Leave a Club
            CALLI ac,-107    CLBMEM    17-5    Read Club Member List
            CALLI ac,-110    CLBRLI    17-5    Release Club Interlock
            CALLI ac,-106    CLBSTS    17-5    Read Status of Club Member
            CALLI ac,-105    CLBWAK    17-6    Wake Up Club Member
                                                    B-2


            June 27, 1984                            B                      System Calls by Name

            Call             Name      Page    Description
            op code 070      CLOSE     5-12    close a file
            TTCALL 11,e      CLRBFI    10-35   clear input buffer
            TTCALL 12,e      CLRBFO    10-36   clear output buffer
            CALLI ac,-125    CONT      10-43   Put port in user level
            CALLI ac,+11     CORE      3-1     allocate or free core
            CALLI ac,-44     CREAUX    10-25   create an aux circuit
            CALLI ac,-141    CREPTY    10-27   Create PTYs
            CALLI ac,-47     CRERMT    19-6    (obsolete) create 620 port
            CALLI ac,+14     DATE      18-1    read date
            CALLI ac,-55     DATUUO    18-2    do time zone conversions
            CALLI ac,-143    DAYTIM    18-3    return elapsed time since 1/1/64 in seconds
            CALLI ac,-54     DDT620    19-6    (obsolete) interrogate 620
            CALLI ac,+5      DDTGT     19-6    (obsolete) Get DDT mode
            CALLI ac,+1      DDTIN     10-42   DDT-mode input
            CALLI ac,+3      DDTOUT    10-48   DDT-mode output
            CALLI ac,+7      DDTRL     19-6    (obsolete) Release DDT mode
            CALLI ac,+4      DEVCHR    5-6     read device characteristics word
            CALLI ac,+64     DEVNAM    5-6     read device physical name
            CALLI ac,+55     DEVPPN    5-6     read PPN
            CALLI ac,+101    DEVSIZ    6-3     read standard buffer size
            CALLI ac,+54     DEVSTS    5-6     read device hardware status
            CALLI ac,-23     DISMIS    16-8    dismiss INTADR interrupts
            CALLI ac,+45     DSKCHR    8-27    read disk characteristics
            CALLI ac,-22     DSKCLR    8-32    initialize in-core file system data
            op code 077      ENTER     8-16    select file for output
            CALLI ac,-134    EVICT     2-10    Cause Notice to Quit Interrupt
            CALLI ac,+12     EXIT      2-36    stop frame execution
            CALLI ac,-142    FLEXIT    2-36    fail exit, don't continue
            CALLI ac,-147    FLSTOP    2-36    fail exit, continue allowed
            op code 044      FRMOP     2-17    Frame Operation
               fn 30         .FOCAR    2-35    Read Child Access Rights
               fn 31         .FOCER    2-35    Read Child Effective Rights
               fn 12         .FOCFH    2-30    Create Handle
               fn 1          .FOCFM    2-20    create frame
               fn 21         .FOCHR    2-34    Change Handle Rights
               fn 14         .FOCLR    2-26    Clear a Frame
               fn 25         .FOCON    2-29    continue frame
               fn 43         .FOCPC    2-30    change project code for frame
               fn 13         .FODFH    2-32    Destroy Handle
               fn 42         .FOFCF    2-30    force command on frame
               fn 32         .FOGET    2-23    Setup frame core image from file
               fn 24         .FOGFT    2-22    Graft Frame Subtree
               fn 26         .FOGIN    2-29    Gate-jump Initialization
               fn 5          .FOHLT    2-25    halt frame
               fn 23         .FOHST    2-27    Read Halt Status Block
               fn 0          .FOJMP    2-24    gate jump to frame
               fn 16         .FORAR    2-33    Read Handle Access Rights
               fn 7          .FOREP    2-23    VREPLC to/from another frame
               fn 17         .FORER    2-33    Read Handle Effective Rights
               fn 36         .FORFA    2-35    Read Frame Attribute
               fn 6          .FORPC    2-25    Read Frame PC
               fn 15         .FORSI    2-33    Read Standard Access Rights Info
               fn 33         .FORUN    2-29    RUN program in frame
               fn 2          .FORVA    2-22    read frame virtual address
               fn 4          .FOSAA    2-25    start frame at absolute address
               fn 34         .FOSAV    2-24    SAVE frame core image on file
               fn 20         .FOSMF    2-34    Set Max Frame Rights
               fn 35         .FOSSA    2-24    SAVE frame core image on SHR file
               fn 41         .FOSTP    2-30    stop frame for non-privileged user
               fn 22         .FOSVA    2-26    start frame at vector address
               fn 27         .FOVCH    2-34    Validate Child Rights
               fn 11         .FOVCL    2-23    VCLEAR in another frame
               fn 10         .FOVRM    2-23    VREMOV in another frame
               fn 37         .FOWFA    2-35    Write Frame Attribute
               fn 3          .FOWVA    2-22    write frame virtual address
               fn 40         .FOXFA    2-35    Exchange Frame Attributes
            CALLI ac,+6      GETCHR    5-6     read device characteristics word
            TTCALL 6,e       GETLCH    10-30   read line characteristics
                                                    B-3


            System Calls by Name                     B                          YAMM edition 2.1

            Call             Name      Page    Description
            CALLI ac,+34     GETLIN    10-23   get command port name
            CALLI ac,-121    GETPFW    19-6    (obsolete)
            CALLI ac,+24     GETPPN    2-2     get frame PPN
            CALLI ac,+40     GETSEG    3-6     load a high segment
            op code 062      GETSTS    5-13    read file status bits
            CALLI ac,+41     GETTAB    18-4    read monitor tables
            CALLI ac,-16     GETTMC    10-31   (obs.) get terminal characteristics
            CALLI ac,+66     GOBSTR    8-29    Get system search list
            CALLI ac,-32     HANG      2-11    hang a port or frame or frames
            CALLI ac,+72     HIBER     16-8    wait for event
            CALLI ac,-51     IDLRMT    19-6    (obsolete) set 620 idle
            op code 056      IN        5-11    input from channel
            op code 064      INBUF     6-3     create input buffer ring
            TTCALL 2,e       INCHRS    10-37   input char [skip/bka]
            TTCALL 0,e       INCHRW    10-36   input char [wait/bka]
            TTCALL 5,e       INCHSL    10-38   input char [skip]
            TTCALL 4,e       INCHWL    10-38   input char [wait]
            op code 041      INIT      5-10    Open a Channel
            op code 066      INPUT     5-11    input from channel
            CALLI ac,-35     INTACT    16-7    cause and uncause interrupts
            CALLI ac,-33     INTADR    16-5    initialize INTADR system
            CALLI ac,-36     INTASS    16-6    assign general interrupt causes
            CALLI ac,-34     INTENB    16-7    enable and disable INTADR channels
            CALLI ac,-52     INTRMT    16-6    (obsolete) assign I/O software interrupts
            TTCALL 15,e      IONEOU    10-44   output char [CMD/IMG]
            CALLI ac,+47     JOBSTR    8-30    Return frames next file structure
            CALLI ac,-30     LEVDEF    10-35   leave deferred echo mode
            CALLI ac,-1      LIGHTS    18-13   display word in console lights
            CALLI ac,+15     LOGIN     2-7     log a frame in
            CALLI ac,-130    LOGOFF    2-10    Run Alternate Logout Program
            CALLI ac,+17     LOGOUT    2-10    log a frame out
            op code 076      LOOKUP    8-17    select file for input
            CALLI ac,-27     MOVBUF    6-4     move buffers
            CALLI ac,+23     MSTIME    18-3    read time in ms
            op code 072      MTAPE     11-3    perform magtape functions
            CALLI ac,-20     ONEJOB    19-4    skip if only frame and super-shut
            op code 050      OPEN      5-10    Open a Channel
            op code 057      OUT       5-11    output from channel
            op code 065      OUTBUF    6-3     create output buffer ring
            TTCALL 16,e      OUTCHI    10-44   output char [CMD/IMM]
            TTCALL 1,e       OUTCHR    10-43   output char [CMD]
            TTCALL 17,e      OUTPTR    10-46   output string [PTR/CMD]
            op code 067      OUTPUT    5-11    output from channel
            TTCALL 3,e       OUTSTR    10-45   output string [STR/CMD]
            CALLI ac,-71     PAGSTS    4-17    read page status word
            CALLI ac,+33     PEEK      18-12   (obsolete) read monitor core
            CALLI ac,-72     PERSET    4-11    set/clear error bit
            CALLI ac,-100    PGESTS    4-12    read/clear page-error status words
            CALLI ac,-101    PGFSTS    4-15    read and clear page fault words
            CALLI ac,-132    PGISTS    4-15    read/clear ill mem ref fault info
            CALLI ac,-133    PGRSTS    4-15    read/clear REFBIT fault info
            CALLI ac,-122    PIDSET    9-2     Manipulate Process' PID
            CALLI ac,+30     PJOB      2-2     get frame number
            CALLI ac,-12     POKE      18-12   write in monitor core
            CALLI ac,-115    POLPRT    10-27   Poll Ports for Events
            CALLI ac,-75     PREREF    4-10    prereference a page
            CALLI ac,-63     PUTLSA    20-6    write local stream acctg record
            CALLI ac,-124    PUTROY    20-5    Put Royalty Record in Stream
            CALLI ac,-62     PUTSAR    20-6    write stream acctg record
            CALLI ac,-117    RDHIST    19-6    (not available)
            CALLI ac,+21     REASSI    5-6     reassign i/o device
            CALLI ac,-14     REDNXT    10-41   peek at input
            CALLI ac,-43     REDPIP    16-7    read in-progress bits
            CALLI ac,-73     REFBIT    4-16    manipulate reference bits
               fn 0          .RFRBM    4-16    Read refbits
               fn 2          .RFRNG    4-16    set refbits by range
               fn 1          .RFSBM    4-16    Set refbits from bitmap
            op code 071      RELEAS    5-12    release device
                                                    B-4


            June 27, 1984                            B                      System Calls by Name

            Call             Name      Page    Description
            CALLI ac,+37     REMAP     3-2     move top of lowseg to highseg
            op code 055      RENAME    8-17    rename or delete a file
            TTCALL 10,e      RESCAN    10-42   rescan command line
            CALLI ac,+0      RESET     5-11    initialize frame state
            CALLI ac,-135    RETACH    10-24   move port from frame to frame
            CALLI ac,-142    RLSLDB    10-25   release spare LDB
            CALLI ac,+35     RUN       3-7     load and run a program
            CALLI ac,-25     RUNSEG    3-10    load and run a high segment
            CALLI ac,+27     RUNTIM    18-3    get TRUs
            CALLI ac,+56     SEEK      8-23    seek to current page
            CALLI ac,-131    SETABK    19-5    Set/Clear Address Break
            CALLI ac,-127    SETALP    2-10    Set Alternate Logout Program
            CALLI ac,+2      SETDDT    3-3     set DDT start address
            CALLI ac,-7      SETE      2-5     set frame license
            CALLI ac,-146    SETINA    2-4     set inactivity timeout
            CALLI ac,-21     SETJAL    2-6     set frame status bits
            TTCALL 7,e       SETLCH    10-30   set line characteristics
            CALLI ac,-10     SETLIC    2-6     set process license
            CALLI ac,-145    SETMAI    2-4     set new mail waiting bit
            CALLI ac,-17     SETMAL    2-3     set mail-waiting bit
            CALLI ac,-144    SETMCY    18-13   Set micro cycle timer
            CALLI ac,-26     SETMOD    10-32   set cmnd port file status
            CALLI ac,+43     SETNAM    2-2     set frame name
            CALLI ac,-126    SETOTF    2-14    set other-frame FD
            CALLI ac,+32     SETPOV    19-6    (obsolete) Set PDL OV trap
            CALLI ac,-11     SETPRV    2-2     set frame privilege word
            CALLI ac,-57     SETRCF    2-9     set restricted cmnd file
            op code 060      SETSTS    5-13    set file status bits
            CALLI ac,-137    SETSTV    2-37    set start vector address
            CALLI ac,-37     SETTIM    16-6    set timer interrupt
            CALLI ac,-15     SETTMC    10-31   (obsolete) no-op
            CALLI ac,-40     SETTR1    16-1    set arithmetic overflow instruction
            CALLI ac,-41     SETTR2    16-1    set stack over/underflow instruction
            CALLI ac,+75     SETUUO    19-1    do SET command functions
               fn 11         .STBST    19-3    Set/Read BOOTS command string
               fn 4          .STDAT    19-2    set date
               fn 2          .STFAR    19-1    finish auto-restart
               fn 5          .STOPR    19-2    set OPR terminal
               fn 12         .STRES    19-4    Read/Set RESTART bits
               fn 1          .STSTA    19-1    set STATES
               fn 3          .STTIM    19-1    set time
               fn 10         .STTLK    19-2    talk to another job command port
               fn 0          .STTYO    19-1    OUTSTR to OPR terminal
               fn 6          .STWAT    2-8     set WATCH bits
            CALLI ac,+36     SETUWP    3-2     set highseg write protection
            TTCALL 13,e      SKPINC    10-41   skip if char
            TTCALL 14,e      SKPINL    10-41   skip if break char
            CALLI ac,+31     SLEEP     16-9    wait for N seconds
            CALLI ac,-116    SNOOP     19-6    (not available)
            CALLI ac,+42     SPYUUO    19-6    (obsolete)
            op code 061      STATO     5-13    skip if file status bits set
            op code 063      STATZ     5-13    skip if file status bits clear
            CALLI ac,+50     STRUUO    8-30    Manipulate file structures
            CALLI ac,+20     SWITCH    18-13   read console switches
            CALLI ac,-24     SYSDVF    5-7     read system device data
            CALLI ac,+51     SYSPHY    8-31    read physical unit names
            CALLI ac,+46     SYSSTR    8-32    read disk structure names
            CALLI ac,+22     TIMER     18-3    read time in jiffies
            CALLI ac,-42     TINASS    16-5    assign port interrupt causes
            CALLI ac,+44     TMPCOR    2-37    do TMPCOR file i/o
               fn 5          .TCRDD    2-38    clear TMPCOR directory
               fn 2          .TCRDF    2-37    delete TMPCOR file
               fn 0          .TCRFS    2-38    get free space count
               fn 4          .TCRRD    2-38    read TMPCOR directory
               fn 1          .TCRRF    2-37    read TMPCOR file
               fn 3          .TCRWF    2-38    write TMPCOR file
            CALLI ac,+26     TRPJEN    19-6    (obsolete)
            CALLI ac,+25     TRPSET    19-5    Set/Clear User-IOT
                                                    B-5


            System Calls by Name                     B                          YAMM edition 2.1

            Call             Name      Page    Description
            op code 051      TTCALL    10-9    perform cmnd port i/o
            CALLI ac,-56     TYMCHG    20-5    add TRU charges
            op code 073      UGETF     8-32    read disk file position
            op code 074      USETI     8-21    set file position by block
            op code 075      USETO     8-22    set file position by block
            CALLI ac,+13     UTPCLR    19-6    (obsolete)
            CALLI ac,-76     VALPAG    4-13    validate pages
            CALLI ac,-53     VALRMT    19-6    (obsolete) validate 620 password
            CALLI ac,-66     VCLEAR    4-4     unmap pages
            CALLI ac,-67     VCREAT    4-3     create private pages
            CALLI ac,-102    VDSKPT    4-19    read disk pointer
            CALLI ac,-77     VFSTAT    4-18    check private/file page
            CALLI ac,-136    VPEEK     18-12   Virtual/Physical PEEK
            CALLI ac,-103    VPGFIL    4-18    get mapped-file name for page
            CALLI ac,-70     VPROT     4-7     set current protection for pages
            CALLI ac,-65     VREMOV    4-4     unmap pages
            CALLI ac,-64     VREPLC    4-4     replicate virtual pages
            CALLI ac,+10     WAIT      5-7     wait until device inactive
            CALLI ac,-13     WAITCH    10-41   wait for input char
            CALLI ac,+73     WAKE      16-9    wake sleeping frame
            CALLI ac,-74     WSCTL     4-8     do working set functions
               fn 0          .WSRBM    4-9     read working set bits
               fn 4          .WSRLM    4-8     read WSLIM
               fn 5          .WSRMX    4-8     read WSMAX
               fn 1          .WSRNG    4-8     add/remove pages from working set
               fn 3          .WSRSZ    4-8     read WSSIZ
               fn 2          .WSSTL    4-8     set WSLIM
            CALLI ac,-60     XCHARG    20-1    modify charges
               fn 2          .XCRCC    20-2    read current charges
               fn 1          .XCRSC    20-2    read saved charges
               fn 0          .XCSAV    20-1    save charging data
               fn 4          .XCSET    20-2    set charges
               fn 6          .XCTCC    20-3    Write TRU Component Checkpoint
               fn 5          .XCTRN    20-3    write transaction charges
            CALLI ac,-45     ZAPCIR    10-27   zap an aux circuit
            CALLI ac,-50     ZAPRMT    19-6    (obsolete) zap 620 port
































                                                    B-6


            June 27, 1984                            C                    System Calls by Number



                                           System Calls by Number
                                           ______ _____ __ ______



            Call             Name      Page    Description

            op code 041      INIT      5-10    Open a Channel
            op code 042      AUXCAL    10-5    perform port i/o functions
               fn 0          .AXI8C    10-39   input char [wait/bka/img]
               fn 1          .AXI8S    10-39   input char [skip/bka/img]
               fn 2          .AXI8B    10-40   input char [wait/img]
               fn 3          .AXO8     10-44   output char [IMG]
               fn 4          .AXO8I    10-45   output char [IMG/IMM]
               fn 5          .AXPTR    10-46   output string [PTR]
               fn 6          .AXCBI    10-35   clear input buffer
               fn 7          .AXCBO    10-36   clear output buffer
               fn 10         .AXSIC    10-41   skip if char
               fn 11         .AXLDE    10-35   leave deferred echo mode
               fn 12         .AXSYB    10-35   send yellow ball
               fn 13         .AXS8B    10-35   set image break char
               fn 14         .AXCRD    10-34   r/s compute-CR-delay bit
               fn 15         .AXIBR    10-34   r/s input baud rate
               fn 16         .AXOBR    10-34   r/s output baud rate
               fn 17         .AXEP     10-34   r/s even-parity bit
               fn 20         .AXHD     10-34   r/s half-duplex bit
               fn 21         .AXPA     10-34   r/s parameter A
               fn 22         .AXPB     10-34   r/s parameter B
               fn 23         .AXPC     10-34   r/s parameter C
               fn 24         .AXHNX    10-34   r/s host-no-XON bit
               fn 25         .AXNTE    10-34   r/s no HT/VT/FF bit
               fn 26         .AXTBK    10-34   r/s tabs-as-breaks bit
               fn 27         .AXWID    10-34   r/s line width
               fn 30         .AXFC1    10-34   r/s filler class 1
               fn 31         .AXFC2    10-34   r/s filler class 2
               fn 32         .AXSFS    10-33   set port file status bits (obsolete)
               fn 33         .AXSI     10-41   simulate input
               fn 34         .AXEBM    10-48   enter block i/o mode
               fn 35         .AXIBW    10-48   input block and wait
               fn 36         .AXIBS    10-49   input block and skip
               fn 37         .AXOB     10-49   block output
               fn 40         .AXTBI    10-49   terminate block input
               fn 41         .AXTBO    10-49   terminate block output
               fn 42         .AXLBM    10-48   leave block i/o mode
               fn 43         .AXSLV    10-26   slave command port
               fn 44         .AXICW    10-37   input char [wait/bka]
               fn 45         .AXICS    10-37   input char [skip/bka]
               fn 46         .AXIWL    10-38   input char [wait]
               fn 47         .AXISL    10-39   input char [skip]
               fn 50         .AXSIL    10-41   skip if break char
               fn 51         .AXOCI    10-44   output char [IMM]
               fn 52         .AXOST    10-47   output string
               fn 53         .AXRMX    10-34   r/s remote-XON bit
               fn 54         .AXRBS    10-34   r/s remote-BS-echo bit
               fn 55         .AXRVX    10-34   r/s reverse-XON bit
               fn 56         .AXTYP    10-34   r/s terminal type
               fn 57         .AXBS     10-34   r/s BS-for-char-delete bit
               fn 60         .AXHNG    10-27   send hangup
               fn 61         .AXPSM    10-29   read port-status msg
               fn 62         .AXERA    10-34   r/s Erase-for-char-delete bit
               fn 63         .AXEDE    10-34   r/s force deferred-echo bit
               fn 64         .AXCFS    10-33   change port file status bits
               fn 65         .AXLCO    10-34   r/s Lower-case-output bit
               fn 66         .AXBBP    10-34   r/s backspace break/punctuation bit
               fn 67         .AXOPC    10-47   output string [STR]
               fn 70         .AXSOB    10-35   send orange ball
               fn 71         .AXSOX    10-34   r/s suppress output translation bit
               fn 72         .AXFRS    10-42   force rescan string [CNT,PTR]
                                                    C-1


            System Calls by Number                   C                          YAMM edition 2.1

            Call             Name      Page    Description
               fn 73         .AXTCN    10-31   r/s terminal charactertistics by number
               fn 74         .AXTCP    10-31   read changed tc number,,value for a pty
               fn 75         .AXNZP    10-29   r/s no zap on reset bit
               fn 76         .AXOSF    10-47   output string, never wait [STR]
               fn 77         .AXRUB    10-34   r/s ctrl H/rubout bit
               fn 100        .AXTTP    10-34   r/s terminal class
               fn 101        .AXCLR    10-34   r/s special ctrl T mode
            op code 043      CHANIO    5-8     do channel i/o functions
               fn 0          .CHREL    5-12    release device
               fn 1          .CHCLS    5-12    close a file
               fn 2          .CHOPT    5-11    output from channel
               fn 3          .CHIPT    5-11    input from channel
               fn 4          .CHLK     8-17    select file for input
               fn 5          .CHENT    8-16    select file for output
               fn 6          .CHUSI    8-21    set file pointer by block
               fn 7          .CHUSO    8-22    set file position by block
               fn 10         .CHUGF    8-32    read disk file position
               fn 11         .CHREN    8-17    rename or delete a file
               fn 12         .CHMTA    11-3    perform magtape functions
               fn 13         .CHOPN    5-10    Open a Channel
               fn 14         .CHIN     5-11    input from channel
               fn 15         .CHOUT    5-11    output from channel
               fn 16         .CHSS     5-13    set file status bits
               fn 17         .CHGS     5-13    read file status bits
               fn 20         .CHSZ     5-13    skip if file status bits clear
               fn 21         .CHSO     5-13    skip if file status bits set
               fn 22         .CHIBF    6-3     create input buffer ring
               fn 23         .CHOBF    6-3     create output buffer ring
               fn 24         .CHSK     8-23    seek to current page
               fn 25         .CHWT     5-7     wait until device inactive
               fn 26         .CHMBF    6-4     move buffers
               fn 27         .CHFSI    8-21    set file pointer by block
               fn 30         .CHFSO    8-22    set file position by block
               fn 31         .CHPSI    8-21    set file pointer by page
               fn 32         .CHPSO    8-22    set file position by page
               fn 33         .CHUFD    8-3     read UFD
               fn 34         .CHMGN    8-26    manipulate update-interlock bit
               fn 35         .CHMFP    4-5     map file pages
               fn 36         .CHDFP    8-24    delete file page
               fn 37         .CHXFP    8-24    exchange file pages
               fn 40         .CHCFP    8-24    create file page
               fn 41         .CHMEN    8-16    select file for multi-update output
               fn 42         .CHNXT    5-14    return next channel
               fn 42         .CHVRB    8-32    validate RIB
               fn 43         .CHSMP    4-6     super-map file pages
               fn 44         .CHFFI    8-26    Find First Interesting Page
               fn 45         .CHFTR    8-25    Truncate File
               fn 47         .CHVMP    8-25    move virtual page to a file
            op code 044      FRMOP     2-17    Frame Operation
               fn 0          .FOJMP    2-24    gate jump to frame
               fn 1          .FOCFM    2-20    create frame
               fn 2          .FORVA    2-22    read frame virtual address
               fn 3          .FOWVA    2-22    write frame virtual address
               fn 4          .FOSAA    2-25    start frame at absolute address
               fn 5          .FOHLT    2-25    halt frame
               fn 6          .FORPC    2-25    Read Frame PC
               fn 7          .FOREP    2-23    VREPLC to/from another frame
               fn 10         .FOVRM    2-23    VREMOV in another frame
               fn 11         .FOVCL    2-23    VCLEAR in another frame
               fn 12         .FOCFH    2-30    Create Handle
               fn 13         .FODFH    2-32    Destroy Handle
               fn 14         .FOCLR    2-26    Clear a Frame
               fn 15         .FORSI    2-33    Read Standard Access Rights Info
               fn 16         .FORAR    2-33    Read Handle Access Rights
               fn 17         .FORER    2-33    Read Handle Effective Rights
               fn 20         .FOSMF    2-34    Set Max Frame Rights
               fn 21         .FOCHR    2-34    Change Handle Rights
               fn 22         .FOSVA    2-26    start frame at vector address
                                                    C-2


            June 27, 1984                            C                    System Calls by Number

            Call             Name      Page    Description
               fn 23         .FOHST    2-27    Read Halt Status Block
               fn 24         .FOGFT    2-22    Graft Frame Subtree
               fn 25         .FOCON    2-29    continue frame
               fn 26         .FOGIN    2-29    Gate-jump Initialization
               fn 27         .FOVCH    2-34    Validate Child Rights
               fn 30         .FOCAR    2-35    Read Child Access Rights
               fn 31         .FOCER    2-35    Read Child Effective Rights
               fn 32         .FOGET    2-23    Setup frame core image from file
               fn 33         .FORUN    2-29    RUN program in frame
               fn 34         .FOSAV    2-24    SAVE frame core image on file
               fn 35         .FOSSA    2-24    SAVE frame core image on SHR file
               fn 36         .FORFA    2-35    Read Frame Attribute
               fn 37         .FOWFA    2-35    Write Frame Attribute
               fn 40         .FOXFA    2-35    Exchange Frame Attributes
               fn 41         .FOSTP    2-30    stop frame for non-privileged user
               fn 42         .FOFCF    2-30    force command on frame
               fn 43         .FOCPC    2-30    change project code for frame
            CALLI ac,-147    FLSTOP    2-36    fail exit, continue allowed
            CALLI ac,-146    SETINA    2-4     set inactivity timeout
            CALLI ac,-145    SETMAI    2-4     set new mail waiting bit
            CALLI ac,-144    SETMCY    18-13   Set micro cycle timer
            CALLI ac,-143    DAYTIM    18-3    return elapsed time since 1/1/64 in seconds
            CALLI ac,-142    FLEXIT    2-36    fail exit, don't continue
            CALLI ac,-142    RLSLDB    10-25   release spare LDB
            CALLI ac,-141    CREPTY    10-27   Create PTYs
            CALLI ac,-137    SETSTV    2-37    set start vector address
            CALLI ac,-136    VPEEK     18-12   Virtual/Physical PEEK
            CALLI ac,-135    RETACH    10-24   move port from frame to frame
            CALLI ac,-134    EVICT     2-10    Cause Notice to Quit Interrupt
            CALLI ac,-133    PGRSTS    4-15    read/clear REFBIT fault info
            CALLI ac,-132    PGISTS    4-15    read/clear ill mem ref fault info
            CALLI ac,-131    SETABK    19-5    Set/Clear Address Break
            CALLI ac,-130    LOGOFF    2-10    Run Alternate Logout Program
            CALLI ac,-127    SETALP    2-10    Set Alternate Logout Program
            CALLI ac,-126    SETOTF    2-14    set other-frame FD
            CALLI ac,-125    CONT      10-43   Put port in user level
            CALLI ac,-124    PUTROY    20-5    Put Royalty Record in Stream
            CALLI ac,-123    BLTPAG    4-10    change data in page uninterruptibly
            CALLI ac,-122    PIDSET    9-2     Manipulate Process' PID
            CALLI ac,-121    GETPFW    19-6    (obsolete)
            CALLI ac,-120    BITPOK    18-12   read/modify/write in monitor memory
            CALLI ac,-117    RDHIST    19-6    (not available)
            CALLI ac,-116    SNOOP     19-6    (not available)
            CALLI ac,-115    POLPRT    10-27   Poll Ports for Events
            CALLI ac,-114    CLBADD    17-3    Join Club
            CALLI ac,-113    CLBLEV    17-3    Leave a Club
            CALLI ac,-112    CLBINW    17-4    Get Interlock,wait
            CALLI ac,-111    CLBINI    17-4    Get Interlock,No Wait
            CALLI ac,-110    CLBRLI    17-5    Release Club Interlock
            CALLI ac,-107    CLBMEM    17-5    Read Club Member List
            CALLI ac,-106    CLBSTS    17-5    Read Status of Club Member
            CALLI ac,-105    CLBWAK    17-6    Wake Up Club Member
            CALLI ac,-104    CLBHNG    17-6    Hang Club Member
            CALLI ac,-103    VPGFIL    4-18    get mapped-file name for page
            CALLI ac,-102    VDSKPT    4-19    read disk pointer
            CALLI ac,-101    PGFSTS    4-15    read and clear page fault words
            CALLI ac,-100    PGESTS    4-12    read/clear page-error status words
            CALLI ac,-77     VFSTAT    4-18    check private/file page
            CALLI ac,-76     VALPAG    4-13    validate pages
            CALLI ac,-75     PREREF    4-10    prereference a page
            CALLI ac,-74     WSCTL     4-8     do working set functions
               fn 0          .WSRBM    4-9     read working set bits
               fn 1          .WSRNG    4-8     add/remove pages from working set
               fn 2          .WSSTL    4-8     set WSLIM
               fn 3          .WSRSZ    4-8     read WSSIZ
               fn 4          .WSRLM    4-8     read WSLIM
               fn 5          .WSRMX    4-8     read WSMAX
            CALLI ac,-73     REFBIT    4-16    manipulate reference bits
                                                    C-3


            System Calls by Number                   C                          YAMM edition 2.1

            Call             Name      Page    Description
               fn 0          .RFRBM    4-16    Read refbits
               fn 1          .RFSBM    4-16    Set refbits from bitmap
               fn 2          .RFRNG    4-16    set refbits by range
            CALLI ac,-72     PERSET    4-11    set/clear error bit
            CALLI ac,-71     PAGSTS    4-17    read page status word
            CALLI ac,-70     VPROT     4-7     set current protection for pages
            CALLI ac,-67     VCREAT    4-3     create private pages
            CALLI ac,-66     VCLEAR    4-4     unmap pages
            CALLI ac,-65     VREMOV    4-4     unmap pages
            CALLI ac,-64     VREPLC    4-4     replicate virtual pages
            CALLI ac,-63     PUTLSA    20-6    write local stream acctg record
            CALLI ac,-62     PUTSAR    20-6    write stream acctg record
            CALLI ac,-61     CHPRJ     2-8     change project code
            CALLI ac,-60     XCHARG    20-1    modify charges
               fn 0          .XCSAV    20-1    save charging data
               fn 1          .XCRSC    20-2    read saved charges
               fn 2          .XCRCC    20-2    read current charges
               fn 4          .XCSET    20-2    set charges
               fn 5          .XCTRN    20-3    write transaction charges
               fn 6          .XCTCC    20-3    Write TRU Component Checkpoint
            CALLI ac,-57     SETRCF    2-9     set restricted cmnd file
            CALLI ac,-56     TYMCHG    20-5    add TRU charges
            CALLI ac,-55     DATUUO    18-2    do time zone conversions
            CALLI ac,-54     DDT620    19-6    (obsolete) interrogate 620
            CALLI ac,-53     VALRMT    19-6    (obsolete) validate 620 password
            CALLI ac,-52     INTRMT    16-6    (obsolete) assign I/O software interrupts
            CALLI ac,-51     IDLRMT    19-6    (obsolete) set 620 idle
            CALLI ac,-50     ZAPRMT    19-6    (obsolete) zap 620 port
            CALLI ac,-47     CRERMT    19-6    (obsolete) create 620 port
            CALLI ac,-46     AUXRED    10-27   read aux circuit port numbers
            CALLI ac,-45     ZAPCIR    10-27   zap an aux circuit
            CALLI ac,-44     CREAUX    10-25   create an aux circuit
            CALLI ac,-43     REDPIP    16-7    read in-progress bits
            CALLI ac,-42     TINASS    16-5    assign port interrupt causes
            CALLI ac,-41     SETTR2    16-1    set stack over/underflow instruction
            CALLI ac,-40     SETTR1    16-1    set arithmetic overflow instruction
            CALLI ac,-37     SETTIM    16-6    set timer interrupt
            CALLI ac,-36     INTASS    16-6    assign general interrupt causes
            CALLI ac,-35     INTACT    16-7    cause and uncause interrupts
            CALLI ac,-34     INTENB    16-7    enable and disable INTADR channels
            CALLI ac,-33     INTADR    16-5    initialize INTADR system
            CALLI ac,-32     HANG      2-11    hang a port or frame or frames
            CALLI ac,-31     CHKLIC    2-4     check settable license
            CALLI ac,-30     LEVDEF    10-35   leave deferred echo mode
            CALLI ac,-27     MOVBUF    6-4     move buffers
            CALLI ac,-26     SETMOD    10-32   set cmnd port file status
            CALLI ac,-25     RUNSEG    3-10    load and run a high segment
            CALLI ac,-24     SYSDVF    5-7     read system device data
            CALLI ac,-23     DISMIS    16-8    dismiss INTADR interrupts
            CALLI ac,-22     DSKCLR    8-32    initialize in-core file system data
            CALLI ac,-21     SETJAL    2-6     set frame status bits
            CALLI ac,-20     ONEJOB    19-4    skip if only frame and super-shut
            CALLI ac,-17     SETMAL    2-3     set mail-waiting bit
            CALLI ac,-16     GETTMC    10-31   (obs.) get terminal characteristics
            CALLI ac,-15     SETTMC    10-31   (obsolete) no-op
            CALLI ac,-14     REDNXT    10-41   peek at input
            CALLI ac,-13     WAITCH    10-41   wait for input char
            CALLI ac,-12     POKE      18-12   write in monitor core
            CALLI ac,-11     SETPRV    2-2     set frame privilege word
            CALLI ac,-10     SETLIC    2-6     set process license
            CALLI ac,-7      SETE      2-5     set frame license
            CALLI ac,-6      ATTACH    10-23   attach command port to frame
            CALLI ac,-5      CALIM5    19-6    (obsolete)
            CALLI ac,-4      CALIM4    19-6    (obsolete)
            CALLI ac,-3      CALIM3    19-6    (obsolete)
            CALLI ac,-2      CALIM2    19-6    (obsolete)
            CALLI ac,-1      LIGHTS    18-13   display word in console lights
            CALLI ac,+0      RESET     5-11    initialize frame state
                                                    C-4


            June 27, 1984                            C                    System Calls by Number

            Call             Name      Page    Description
            CALLI ac,+1      DDTIN     10-42   DDT-mode input
            CALLI ac,+2      SETDDT    3-3     set DDT start address
            CALLI ac,+3      DDTOUT    10-48   DDT-mode output
            CALLI ac,+4      DEVCHR    5-6     read device characteristics word
            CALLI ac,+5      DDTGT     19-6    (obsolete) Get DDT mode
            CALLI ac,+6      GETCHR    5-6     read device characteristics word
            CALLI ac,+7      DDTRL     19-6    (obsolete) Release DDT mode
            CALLI ac,+10     WAIT      5-7     wait until device inactive
            CALLI ac,+11     CORE      3-1     allocate or free core
            CALLI ac,+12     EXIT      2-36    stop frame execution
            CALLI ac,+13     UTPCLR    19-6    (obsolete)
            CALLI ac,+14     DATE      18-1    read date
            CALLI ac,+15     LOGIN     2-7     log a frame in
            CALLI ac,+16     APRENB    16-2    enable APRENB trapping
            CALLI ac,+17     LOGOUT    2-10    log a frame out
            CALLI ac,+20     SWITCH    18-13   read console switches
            CALLI ac,+21     REASSI    5-6     reassign i/o device
            CALLI ac,+22     TIMER     18-3    read time in jiffies
            CALLI ac,+23     MSTIME    18-3    read time in ms
            CALLI ac,+24     GETPPN    2-2     get frame PPN
            CALLI ac,+25     TRPSET    19-5    Set/Clear User-IOT
            CALLI ac,+26     TRPJEN    19-6    (obsolete)
            CALLI ac,+27     RUNTIM    18-3    get TRUs
            CALLI ac,+30     PJOB      2-2     get frame number
            CALLI ac,+31     SLEEP     16-9    wait for N seconds
            CALLI ac,+32     SETPOV    19-6    (obsolete) Set PDL OV trap
            CALLI ac,+33     PEEK      18-12   (obsolete) read monitor core
            CALLI ac,+34     GETLIN    10-23   get command port name
            CALLI ac,+35     RUN       3-7     load and run a program
            CALLI ac,+36     SETUWP    3-2     set highseg write protection
            CALLI ac,+37     REMAP     3-2     move top of lowseg to highseg
            CALLI ac,+40     GETSEG    3-6     load a high segment
            CALLI ac,+41     GETTAB    18-4    read monitor tables
            CALLI ac,+42     SPYUUO    19-6    (obsolete)
            CALLI ac,+43     SETNAM    2-2     set frame name
            CALLI ac,+44     TMPCOR    2-37    do TMPCOR file i/o
               fn 0          .TCRFS    2-38    get free space count
               fn 1          .TCRRF    2-37    read TMPCOR file
               fn 2          .TCRDF    2-37    delete TMPCOR file
               fn 3          .TCRWF    2-38    write TMPCOR file
               fn 4          .TCRRD    2-38    read TMPCOR directory
               fn 5          .TCRDD    2-38    clear TMPCOR directory
            CALLI ac,+45     DSKCHR    8-27    read disk characteristics
            CALLI ac,+46     SYSSTR    8-32    read disk structure names
            CALLI ac,+47     JOBSTR    8-30    Return frames next file structure
            CALLI ac,+50     STRUUO    8-30    Manipulate file structures
            CALLI ac,+51     SYSPHY    8-31    read physical unit names
            CALLI ac,+54     DEVSTS    5-6     read device hardware status
            CALLI ac,+55     DEVPPN    5-6     read PPN
            CALLI ac,+56     SEEK      8-23    seek to current page
            CALLI ac,+64     DEVNAM    5-6     read device physical name
            CALLI ac,+66     GOBSTR    8-29    Get system search list
            CALLI ac,+72     HIBER     16-8    wait for event
            CALLI ac,+73     WAKE      16-9    wake sleeping frame
            CALLI ac,+74     CHGPPN    2-2     change frame PPN
            CALLI ac,+75     SETUUO    19-1    do SET command functions
               fn 0          .STTYO    19-1    OUTSTR to OPR terminal
               fn 1          .STSTA    19-1    set STATES
               fn 2          .STFAR    19-1    finish auto-restart
               fn 3          .STTIM    19-1    set time
               fn 4          .STDAT    19-2    set date
               fn 5          .STOPR    19-2    set OPR terminal
               fn 6          .STWAT    2-8     set WATCH bits
               fn 10         .STTLK    19-2    talk to another job command port
               fn 11         .STBST    19-3    Set/Read BOOTS command string
               fn 12         .STRES    19-4    Read/Set RESTART bits
            CALLI ac,+101    DEVSIZ    6-3     read standard buffer size
            op code 050      OPEN      5-10    Open a Channel
                                                    C-5


            System Calls by Number                   C                          YAMM edition 2.1

            Call             Name      Page    Description
            op code 051      TTCALL    10-9    perform cmnd port i/o
            TTCALL 0,e       INCHRW    10-36   input char [wait/bka]
            TTCALL 1,e       OUTCHR    10-43   output char [CMD]
            TTCALL 2,e       INCHRS    10-37   input char [skip/bka]
            TTCALL 3,e       OUTSTR    10-45   output string [STR/CMD]
            TTCALL 4,e       INCHWL    10-38   input char [wait]
            TTCALL 5,e       INCHSL    10-38   input char [skip]
            TTCALL 6,e       GETLCH    10-30   read line characteristics
            TTCALL 7,e       SETLCH    10-30   set line characteristics
            TTCALL 10,e      RESCAN    10-42   rescan command line
            TTCALL 11,e      CLRBFI    10-35   clear input buffer
            TTCALL 12,e      CLRBFO    10-36   clear output buffer
            TTCALL 13,e      SKPINC    10-41   skip if char
            TTCALL 14,e      SKPINL    10-41   skip if break char
            TTCALL 15,e      IONEOU    10-44   output char [CMD/IMG]
            TTCALL 16,e      OUTCHI    10-44   output char [CMD/IMM]
            TTCALL 17,e      OUTPTR    10-46   output string [PTR/CMD]
            op code 055      RENAME    8-17    rename or delete a file
            op code 056      IN        5-11    input from channel
            op code 057      OUT       5-11    output from channel
            op code 060      SETSTS    5-13    set file status bits
            op code 061      STATO     5-13    skip if file status bits set
            op code 062      GETSTS    5-13    read file status bits
            op code 063      STATZ     5-13    skip if file status bits clear
            op code 064      INBUF     6-3     create input buffer ring
            op code 065      OUTBUF    6-3     create output buffer ring
            op code 066      INPUT     5-11    input from channel
            op code 067      OUTPUT    5-11    output from channel
            op code 070      CLOSE     5-12    close a file
            op code 071      RELEAS    5-12    release device
            op code 072      MTAPE     11-3    perform magtape functions
            op code 073      UGETF     8-32    read disk file position
            op code 074      USETI     8-21    set file position by block
            op code 075      USETO     8-22    set file position by block
            op code 076      LOOKUP    8-17    select file for input
            op code 077      ENTER     8-16    select file for output
































                                                    C-6


            June 27, 1984                            D                                     Index


            .AXBBP  10-13,10-34#                        .CHDFP  8-24#
            .AXBS  10-17,10-34#                         .CHENT  8-16#
                                                   Index
                                                   _____
            .AXCBI  10-11,10-35#                        .CHFFI  8-25,8-26#
            .AXCBO  10-11,10-23,10-36#                  .CHFSI  8-21#
            .AXCFS  10-33#                              .CHFSO  8-22#
            .AXCLR  10-21,10-34#                        .CHFTR  8-24,8-25,8-25#
            .AXCRD  10-19,10-34#                        .CHGS  5-4,5-13#
            .AXEBM  10-23,10-48#                        .CHIBF  6-3,6-3#
            .AXEDE  10-15,10-34#                        .CHIN  5-11#,6-4,7-1
            .AXEP  10-20,10-34#                         .CHIPT  5-11#,6-4,7-1
            .AXERA  10-34#                              .CHLK  8-17#
            .AXFC1  10-20,10-34#                        .CHMBF  6-3,6-4#
            .AXFC2  10-20,10-34#                        .CHMEN  8-9,8-16#
            .AXFRS  10-40,10-42#                        .CHMFP  2-13,2-14,4-5,4-5#,8-23
            .AXHD  10-15,10-34#                         .CHMGN  8-25,8-26#
            .AXHNG  10-27#                              .CHMTA  11-3#
            .AXHNX  10-10,10-34#                        .CHNXT  5-14#
            .AXI8B  10-40#                              .CHOBF  6-3,6-3#
            .AXI8C  10-39#                              .CHOPN  5-1,5-10#
            .AXI8S  10-39#                              .CHOPT  5-11#,6-5,7-1
            .AXIBR  10-9,10-34#                         .CHOUT  5-11#,6-5,7-1
            .AXIBS  10-23,10-49#                        .CHPSI  8-21#
            .AXIBW  10-23,10-48#                        .CHPSO  8-22#
            .AXICS  10-37,10-37#                        .CHREL  5-3,5-12#
            .AXICW  10-13,10-37,10-37#                  .CHREN  8-17#
            .AXISL  10-13,10-37,10-39#                  .CHSK  8-23#
            .AXIWL  10-13,10-37,10-38#                  .CHSMP  4-6,4-6#,8-21
            .AXLBM  10-23,10-48#                        .CHSO  5-4,5-13#
            .AXLCO  10-18,10-34#                        .CHSS  5-4,5-13#
            .AXLDE  10-17,10-35#                        .CHSZ  5-4,5-13#
            .AXNTE  10-18,10-34#                        .CHUFD  8-3,8-3#,8-5,8-13,8-14
            .AXNZP  10-2,10-29#                         .CHUGF  8-32#
            .AXO8  10-43,10-44#                         .CHUSI  8-21#
            .AXO8I  10-43,10-45#                        .CHUSO  8-22#
            .AXOB  10-23,10-49#                         .CHVMP  8-25#
            .AXOBR  10-9,10-34#                         .CHVRB  4-13,8-32#
            .AXOCI  10-43,10-44#                        .CHWT  5-5,5-7#
            .AXOPC  10-46,10-47#                        .CHXFP  8-24#
            .AXOSF  10-46,10-47#                        .FOCAR  2-17,2-35#
            .AXOST  10-20,10-46,10-47#                  .FOCER  2-17,2-35#
            .AXPA  10-19,10-34#                         .FOCFH  2-14,2-30#,2-32
            .AXPB  10-19,10-34#                         .FOCFM  2-2,2-20#
            .AXPC  10-19,10-34#                         .FOCFM error codes  2-21
            .AXPSM  10-29#                              .FOCHR  2-34#
            .AXPTR  10-42,10-46,10-46#,10-47            .FOCLR  2-26#
            .AXRBS  10-17,10-34#                        .FOCON  2-29#,2-29
            .AXRMX  10-10,10-34#                        .FOCPC  2-30#
            .AXRUB  10-11,10-34#                        .FODFH  2-32#
            .AXRVX  10-10,10-34#                        .FOFCF  2-30#
            .AXS8B  10-15,10-35#                        .FOGET  2-23#,3-6,3-11
            .AXSFS  10-4,10-33#                         .FOGFT  2-22#
            .AXSI  10-40,10-41#                         .FOGIN  2-25,2-29#
            .AXSIC  10-13,10-41#                        .FOHLT  2-25#
            .AXSIL  10-41#                              .FOHST  2-27#,2-36
            .AXSLV  10-2,10-26#                         .FOJMP  2-24#,2-29
            .AXSOB  10-16,10-35#,16-4                   .FORAR  2-17,2-33#,2-35
            .AXSOX  10-3,10-34#                         .FOREP  2-13,2-23#
            .AXSYB  10-16,10-35#                        .FORER  2-17,2-33,2-33#
            .AXTBI  10-23,10-49#                        .FORFA  2-35#
            .AXTBK  10-13,10-34#                        .FORPC  2-25#,2-29
            .AXTBO  10-23,10-49#                        .FORSI  2-33#,2-33
            .AXTCN  10-3,10-31#                         .FORSI Item Numbers  2-33
            .AXTCP  10-3,10-31#                         .FORUN  2-29#,3-6,3-11
            .AXTTP  10-21,10-34#                        .FORVA  2-22#
            .AXTYP  10-34#                              .FOSAA  2-25#,2-29
            .AXWID  10-18,10-34#                        .FOSAV  2-24#,3-6
            .CHCFP  8-24#                               .FOSMF  2-15,2-34,2-34#
            .CHCLS  5-2,5-12#                           .FOSSA  2-24#,3-6
                                                    D-1


            Index                                    D                          YAMM edition 2.1


            .FOSTP  2-30#                               ACT:  20-7
            .FOSVA  2-16,2-26#,2-37                     Actual Word/Byte Counts  11-3#
            .FOVCH  2-34#,2-35                          Addressing Monitor Memory  18-11#
            .FOVCL  2-23#                               Alternate Logout Program  2-10#
            .FOVRM  2-23#                               APRENB  16-2#
            .FOWFA  2-35#                               APRENB Interrupt Bit Definitions  16-3
            .FOWVA  2-22#                               APRENB Interrupt System  16-1#
            .FOXFA  2-35#                               APRENB interrupts  16-1
            .RFRBM  4-16#                               APRENB/INTADR Interaction  16-9#
            .RFRNG  4-16#                               AR  2-14
            .RFSBM  4-16#                               Argument Blocks  8-9#
            .STBST  19-3#                               Argument Codes  8-10
            .STDAT  19-2#                               arithmetic overflow  16-1
            .STFAR  19-1#                               ASCII Mode I/O  14-1#
            .STOPR  19-2#                               ASCII Mode Input  12-1#
            .STRES  19-4#                               ASSIGN command  5-1
            .STSTA  19-1#                               assigned by console  5-1
            .STTIM  19-1#                               assigned by program  5-1
            .STTLK  19-2#                               Assigning Causes to Channels  16-4#
            .STTYO  19-1#                               ATTACH  10-1,10-23#
            .STWAT  2-8#                                Attaching  10-1#,10-1
            .TCRDD  2-38#                               AUN  2-1
            .TCRDF  2-37#                               Authority Conferred by a PID  9-2#
            .TCRFS  2-38#                               AUXCAL  10-4,10-5#,10-6,10-8
            .TCRRD  2-38#                               AUXCALs by function  10-6
            .TCRRF  2-37#                               AUXCALs by number  10-8
            .TCRWF  2-38#                               Auxiliary Ports  10-2#
            .WSRBM  4-9#                                AUXRED  10-2,10-27#
            .WSRLM  4-8#
            .WSRMX  4-8#
            .WSRNG  4-8#                                backpressure  10-10
            .WSRSZ  4-8#                                Backspace  10-17#
            .WSSTL  4-8#                                backspace break/punctuation bit  10-13
            .XCRCC  20-2#,20-4                          backspace-for-character-delete  10-17
            .XCRSC  20-2#                               balls (messages) in Tymnet  10-16
            .XCSAV  20-1#,20-4                          baud rate  10-9
            .XCSET  20-2#,20-4                          Baud Rates  10-9#
            .XCTCC  20-3#,20-5                          Begin and End of Tape Bits  11-2#
            .XCTRN  20-3#                               Binary Mode I/O  14-2#
                                                        Binary Mode Input  12-1#
                                                        BITPOK  18-11,18-12#
            .GTCNF (GETTAB +11) Items  18-8             BLISS  1-1
            .GTFTR Bits (GETTAB -54)  18-8              Block I/O  10-21#
            .GTLOG Bits (GETTAB -24)  18-9              Block I/O Buffer Format  10-22#
            .GTLVD (GETTAB 16) Items  18-10             Block I/O Data Modes  10-22#
            .GTNSW Items (GETTAB 12)  18-10             Block I/O Tutorial  10-23#
            .GTODP(GETTAB +15) items (ONCDSK            block IO  10-21
               parameters)  18-11                       BLTPAG  4-10,4-10#
            .GTWSC(GETTAB +25) items (Wait State        BLTPAG error codes  4-11
               Codes)  18-11                            BOT  11-2
            .JBCOR  3-3                                 Break Characters  10-13#,10-13
            .XCSET Error Codes  20-3                    Breaks  10-14#
                                                        Buffer Format  6-2#
                                                        buffer ring  6-2
            026 Card Codes  12-2                        Buffer Ring Headers  6-1#
            029 Card Codes  12-2                        Buffer Setup  6-2#,6-2
                                                        Buffered I/O  8-2#,10-9#
                                                        Buffered I/O Errors  6-6#
            Abbreviations  1-1#,8-2#                    Buffered I/O Operations  6-4#
            absolute FD  2-12,2-13#                     buffered I/O use bit  6-1
            Absolute Frame Number  2-1                  buffered input  6-4
            Access Rights  2-14#                        Buffered Input Calls  6-4#
            Access Rights Definitions  2-16             Buffered Mode I/O  6-1#
            Account User Numbers (AUN,PPN,FPN)  2-1#    buffered output  6-4
            Accounting  20-1#                           Buffered Output Calls  6-5#
            Accounting Device Control Functions         Buffered Tape I/O  11-2#
               19-6#                                    Buffering and Backpressure  10-10#
            Acknowledgements  1-2#
                                                    D-2


            June 27, 1984                            D                                     Index


            CALIM2  19-6#                               Creating  10-2#
            CALIM3  19-6#                               Creating Private Pages  4-3#
            CALIM4  19-6#                               Creating PTYs  10-3#
            CALIM5  19-6#                               CREAUX  10-2,10-25#
            card reader  12-1                           CREAUX Error Codes  10-26
            Card Reader Input  12-1#                    CREPTY  10-3,10-27#
            Case Mapping  10-11#,10-11                  CRERMT  19-6#
            CDR  12-1                                   Current List  19-6#
            CDR: File Status Bits  12-3,14-2            current page protection  4-2
            Change Project-Code Record words 5-7
               20-8
            Changing Page Protection  4-7#              Data Modes  5-3#,5-4
            CHANIO  5-2,5-8#,5-9,5-10                   Data Transmission Methods  10-11#
            CHANIOs by function  5-9                    Data Transmission Modes  10-20#
            CHANIOs by number  5-10                     DATE  18-1#
            channel  5-1                                Date Change Record words 0-5  20-9
            Channel Numbers  5-2#,5-2                   date format  18-1
            Channels & I/O Initialization  5-1#         Dates and Times  18-1#
            Character Handling  10-11#                  DATUUO  18-2#
            character-delete character  10-11           DAYTIM  18-3#
            Characteristics of PTYs  10-3#              DDB  5-1
            CHGPPN  2-1,2-2#                            DDT620  19-6#
            child-to-parent handle  2-35                DDTGT  19-6#
            children  2-12                              DDTIN  10-13,10-20,10-40,10-42#
            CHKLIC  2-4#                                DDTOUT  10-20,10-48#
            CHPRJ  2-8,2-8#,2-30,8-15                   DDTRL  19-6#
            CLBADD  17-2,17-3#                          DEASSIGN command  5-1
            CLBHNG  17-3,17-6#                          DEC date format  18-1
            CLBINI  17-2,17-4#                          deferred echo  10-15
            CLBINW  17-2,17-4#,17-4                     Definition  17-1#
            CLBLEV  17-2,17-3#                          Definition of PID  9-1#
            CLBMEM  17-3,17-5#                          delay  10-19
            CLBRLI  17-2,17-5#                          delete  8-8
            CLBSTS  17-3,17-5#                          delete file pages  8-23
            CLBWAK  17-3,17-6#                          Deleted Characters  10-17#
            CLOSE  5-2,5-12#,8-19                       density  11-1
            Closing a Disk File  8-19#                  Detaching  10-1#,10-1
            Closing channels  5-2#                      DEVCHR  5-4,5-6#
            CLRBFI  10-11,10-35#                        Device Assignment  5-1#
            CLRBFO  10-11,10-36#                        Device Availability  5-1#
            Club Facility  17-1#                        Device Characteristics  5-4#
            Club Facility Standard Error Codes  17-7    Device Characteristics Word  5-5
            Club ID numbers  17-1#                      device data block  5-1
            Club Interlock  17-1#                       device descriptor  5-5
            Club Interlock Status Flags  17-4           Device Manipulation  5-5#
            Club UUOs  17-3#                            Device Names  5-2#,8-1#,11-1#
            Club, definition of  17-1                   DEVNAM  5-6#
            COBOL  1-1                                  DEVPPN  5-6#
            colored balls  10-16                        DEVSIZ  6-2,6-3#
            Command Level  10-2                         DEVSTS  5-6#
            command port  10-1                          Digital Equipment Corp.  1-1
            Command Ports  10-1#                        Direct File Page Manipulation  8-23#
            Command versus User Level  10-2#            Direct Interaction with other club
            CONT  10-40,10-43#                             members  17-3#
            Control T Mode  10-21                       Directories  8-2#
            controlling TTY  10-1                       directory  8-2
            Conventions  1-1#                           Directory Access Protection  8-7#
            copy-on-write page  4-2                     directory protection  8-7
            CORE  3-1,3-1#,4-1,4-3                      Directory Protection Bits  8-8
            Core image files  3-5#                      disconnect options  2-3
            COW page  4-2                               Disk Characteristics  8-27#
            CR and LF delay  10-19#                     disk directory  8-2
            CR delay  10-19                             Disk Files with PIDs  8-7#
            CR Delay Formula  10-19#                    Disk I/O  8-1#
            create  8-8                                 Disk Retrieval Pointers  4-19#
            create file pages  8-23                     disk structure  8-1
            Created Handle  2-14#                       Disk Unit/Structure Names  8-29#
            created handle index  2-31                  DISMIS  16-2,16-3,16-8#
                                                    D-3


            Index                                    D                          YAMM edition 2.1


            DSK: File Status Bits  8-33                 Flushing Output  10-11#
            DSKCHR  8-27#,8-28                          forced command  10-24
            DSKCHR Data Block  8-28                     Form Feeds  13-1#,13-1
            DSKCHR Status Bits  8-29                    FORTRAN  1-1
            DSKCLR  8-32#                               FPN  2-1
            Dump I/O  8-2#                              Frame Descriptor Format  2-13
            Dump I/O Errors  7-2#                       frame descriptor types  2-13
            Dump I/O Operations  7-1#                   Frame Descriptors  2-12#
            Dump Input Calls  7-1#                      Frame Generation and Control Operations
            Dump Mode I/O  7-1#,7-1                        2-12#
            Dump Output Calls  7-2#                     Frame handle  2-12
            Dump Tape I/O  11-2#                        Frame Identification  2-1#
                                                        Frame License  2-4#
                                                        Frame License Bits  2-5
            echo  10-15                                 Frame Privilege Word  2-3
            Echo,Break,Backpressure UUOs  10-35#        Frame Search List  8-5#,8-5
            Echoing  10-15#                             Frame Status  2-6#
            Edition 2.1  1-2#                           Frame Status Word  2-7
            Effective Rights  2-17                      frame tree  2-12
            End Of File  10-13#                         Frames and Processes  2-1#
            EndPoint  11-2                              FRMOP  2-12,2-17#,2-20
            ENTER  8-9,8-16#                            FRMOP calls by function  2-19
            Environmental Information  18-1#            FRMOP functions by number  2-20
            EOT  11-2                                   FRMOP standard error codes  2-18
            Escape  10-17#                              FTA:  11-1
            Escape Character  10-12#,10-12              FTA: File Status Bits  11-5
            even-parity  10-20                          full-character-set mode  10-11
            EVICT  2-10#
            exchange file pages  8-23
            exchange frame attributes  2-35             GAN  2-1
            Execute-Only Programs  3-11#                gate jumps  2-24,2-29
            Executing IO instructions (User-IOT)        General I/O  5-1#
               19-5#                                    General Interrupt Cause Codes  16-4
            Executing with a PID  9-2#                  GET operation  3-5
            executive program  2-12                     GETCHR  5-4,5-6#
            EXIT  2-36#                                 GETLCH  10-4,10-30#
            Extended Lookup Block  8-12                 GETLIN  10-23#
                                                        GETPFW  19-6#
                                                        GETPPN  2-2#
            F-bit  8-5                                  GETSEG  2-23,3-1,3-6#
            Faking Input  10-40#                        GETSTS  5-4,5-13#
            Faking Input Wait  10-17#                   GETTAB  18-3,18-4#
            Family FD's  2-14#                          GETTAB tables and functions  18-3#
            FF filler class  10-20                      GETTAB tables by function  18-5
            File Access Protection  8-6#                GETTAB tables by number  18-7
            File Access State Transition Rules  8-9     Getting an Interlock  17-2#
            file license  2-4,8-20                      GETTMC  10-31#
            File Organization  8-5#,8-5                 Global Account Number  2-1
            file owner  8-6                             GOBSTR  8-29#
            file page  4-1                              GOBSTR error codes  8-30
            file page manipulation  8-23                graphics  15-1
            file pointer  8-20                          green ball  10-15
            file position  8-20                         green balls  10-16
            File Positioning  8-20#
            file protection  8-6
            File Protection Codes  8-7                  Half-Duplex  10-15#,10-15
            File Selection  8-8#,8-8                    Halt Status Classes & Types  2-28
            File Selection Error Codes  8-18#,8-19      handle access rights  2-17
            File State Transitions  8-9#                handle effective rights  2-17
            File Status Bits  5-3#,5-3,10-4#            Handle Rights vs. Effective Rights
            file system  8-1                               2-17#
            filler class 1  10-20                       Handles  2-14#
            filler class 2  10-20                       HANG  2-11#
            first class club member  17-1               Hardware Action  15-1#
            FLEXIT  2-36#                               Hardware Paging  4-1#
            FLSTOP  2-36#                               HDX  10-15
            Flushing  8-32                              HGH file  3-5
            Flushing Input  10-11#                      HIBER  10-16,16-8#
                                                    D-4


            June 27, 1984                            D                                     Index


            High and Low Segments  3-1#                 Leaders and Trailers  14-1#
            high segment  3-1                           Leaving a Club  17-2#
            Host No XON  10-10#                         LEVDEF  10-17,10-35#
            HT Filler Cclass  10-20#                    LF delay  10-19
            HT filler class  10-20                      LF Delay Formula  10-19#
            HT, VT, FF delays  10-19#                   license  2-4,8-6#,8-7#,8-20
            HT, VT, FF simulation  10-18#               License Bit Definitions  2-5
                                                        License-Setting RUN Record words 0-2
                                                           20-9
            I/O synchronization  6-6#                   licensed handle  2-12
            IDLRMT  19-6#                               LIGHTS  18-13,18-13#
            ILL MEM REF  4-11                           Lights and Switches  18-13#
            Illegal Memory Reference  4-11#,4-11        Line Characteristic Word  10-4#
            Image Binary Mode I/O  14-1#                Line Characteristics Word  10-30
            Image Break Character  10-15#,10-15         Line Editing  10-11#,10-11
            Image Characters  10-18#                    line printer  13-1
            image mode  10-14                           Line Printer Output  13-1#
            Image Mode I/O  14-1#                       Line Width and Position  10-18#
            Image Mode Input  12-1#                     line-delete character  10-11
            image output  10-18                         LoadPoint  11-2
            Image State  10-14#,10-39#                  Local Copy  10-16#
            IN  5-11#,6-4,7-1                           local echo  10-15
            inactive  5-5                               Local Stream Accounting Record words 5-7
            Inactivity Logout  2-11#                       20-9
            INBUF  6-3,6-3#                             logging out  2-10
            INCHRS  10-13,10-37,10-37#                  logical name  5-2
            INCHRW  10-13,10-36#,10-37                  Logical Names  5-2#
            INCHSL  10-13,10-37,10-38#                  logical page table  4-1
            INCHWL  10-13,10-37,10-38#                  Logical Unit Names  8-1#,8-1
            incremental plotter  15-1                   LOGIN  2-1,2-2,2-7#
            INIT  5-1,5-10#                             LOGINN  2-2
            Initial Conditions  6-3#                    LOGINN Record words 3-6  20-10
            Initializing the INTADR System  16-3#       LOGOFF  2-10#,2-10
            INPUT  5-11#,6-4,7-1,10-11#,10-13           LOGOUT  2-10#
            Inquiring about Ports and their Statuses    LOGOUT and CHKPNT stream record format
               10-2#                                       20-11
            INTACT  16-7#                               Logout On Stop  2-9#
            INTADR  16-3,16-5#                          lookup  8-8,8-9,8-17#
            INTADR Interrupt System  16-3#              LOW file  3-5
            INTADR interrupts  16-3                     low segment  3-1
            INTASS  16-4,16-6#,16-8                     Low Segment Job Data Area  3-3#
            INTENB  16-3,16-7#                          LPT forms control  13-1
            Interaction with Non-Block Input  10-22#    LPT:  13-1
            Interaction with Non-Block Output
               10-23#
            Interrupt System and Sleeping  16-1#        M-bit  8-5
            INTRMT  16-6#,19-6                          magnetic tape  11-1
            INTRMT error codes  16-7                    Magnetic Tape I/O  11-1#
            IO instructions  19-5                       mail-waiting bit  2-3
            IONEOU  10-43,10-44#                        Major I/O UUOs  5-8#
            IOT  19-5                                   Manipulating the PID  9-2#
            Issuing PID's  9-1#                         map  4-1
                                                        map file pages  8-23
                                                        Mapping Absolute Disk Pages  4-6#
            JIS-8  8-14,10-20                           Mapping File Pages  4-5#
            job  2-1                                    Master File Directory  8-3#,8-3
            Job Data Area  3-3#                         maximally-writable page  4-2
            Job Data Area Locations  3-4                Maximum Frame Rights  2-15#
            JOBDAT.REL  3-3                             Memory manipulation FRMOPs  2-22#
            JOBSTR  8-30#,8-30                          MFD  8-3
            Joining a Club  17-2#                       MFR  2-15
                                                        Miscellaneous Command Port UUOs  10-40#
                                                        Miscellaneous Operations  19-1#
            Katakana  8-14                              Monitor Modes  10-13#,10-13
            Katakana Data Mode  10-20#,10-20            Monitor Modes & Special Characters
            KS2020 Line Printer Forms Control  13-1#       10-33
                                                        monitor working set  4-2
                                                        monitor working set control  4-7
                                                    D-5


            Index                                    D                          YAMM edition 2.1


            Monitor-Constructed Buffer Rings  6-3#      PGISTS  4-15#
            MOVBUF  6-3,6-4#                            PGRSTS  4-15#
            MSTIME  18-3#                               PGRSTS and PGISTS word formats  4-15
            MTA:  11-1                                  physical address  4-1
            MTAPE  11-1,11-2,11-3,11-3#,13-1,19-6       Physical Unit Names  8-2#,8-2
            MTAPE Functions  11-4                       PID Handling on ENTER and RENAME  9-3#
            MTAPE Operations  11-3#                     PID's and Storage Accounting  9-3#
                                                        PIDSET  9-2,9-2#
                                                        PJOB  2-2#
            No Echo  10-16#                             plot operations  15-1
            no-free-CR bit  10-18                       plotter  15-1
            no-HT/VT/FF bit  10-18                      Plotter command bits  15-1
            Non-Integral Word Counts  11-2#             Plotter Output  15-1#
            nonexistent page  4-1                       PLT: File Status Bits  15-2
            notice to quit  2-10                        PNO  2-12
                                                        POKE  18-11,18-12#
                                                        POLPRT  10-2,10-3,10-28#
            Obsolete and Unavailable Functions          Port and Terminal Characteristics UUOs
               19-6#                                       10-29#
            ONEJOB  19-4#                               Port Block I/O UUOs  10-48#
            OPEN  5-1,5-10#                             port break characters  10-13
            Operator Functions  19-1#                   Port Buffered-I/O Modes  10-21#
            orange balls  10-16                         port buffering  10-10
            Other Frame FD  2-13#                       port case mapping  10-11
            OUT  5-11#,6-5,7-1                          Port Character Input Calls  10-37
            OUTBUF  6-3,6-3#                            Port Character Output Calls  10-43
            OUTCHI  10-43,10-44#                        Port Creation,Moving,Deletion UUOs
            OUTCHR  10-43#,10-43                           10-23#
            OUTPTR  10-46,10-46#                        port device names  10-1
            OUTPUT  5-11#,6-5,7-1,10-17#,13-1#,15-1#    port echoing  10-15
            Output Case Mapping  10-18#                 port escape characcter  10-12
            Output Suppression  10-12#                  Port Event-Status Bits  10-29
            Output UUOs  10-43#                         Port I/O  10-1#
            OUTSTR  10-20,10-45#,10-46                  port image break character  10-15
                                                        port image mode  10-14
                                                        port image output  10-18
            page 0  3-3                                 port input  10-36
            page breaks  13-1                           Port Input UUOs  10-36#
            Page Errors  4-11#                          Port Interrupt Cause Codes  16-4
            Page Fault Word  4-14#,4-14                 port numbers  10-1
            Page Faults  4-14#                          Port Numbers and Device Names  10-1#
            page protection  4-2                        Port Operations  10-4#
            Page Protection Codes  4-3                  port output  10-43
            Page Reference Bits  4-15#,4-15             port parity  10-20
            Page Status Word  4-17#                     port speeds  10-9
            Page Status Word Format  4-17               Port String Output Calls  10-46
            Page Types  4-1#                            ports  10-1
            Page-error Status-word  4-13                Preface  1-1#
            Paging  4-1#,4-1                            PREREF  2-13,4-9,4-10#
            paging errors  4-11                         PREREF Error Codes  4-10
            Paging Related Errors  4-11#                Prereferencing Pages  4-9#
            PAGSTS  2-13,4-11,4-17,4-17#,4-18           prime RIB  8-5
            PAGSTS Error Code  4-17                     printer  13-1
            paper tape  14-1                            private page  4-1
            Paper Tape I/O  14-1#                       Privilege  2-2#
            Paper Tape Mode  10-21#                     process handle  2-12
            parameter A  10-19                          process license  2-4
            parameter B  10-19                          process name  2-1
            parameter C  10-19                          Processor ID Mechanism  9-1#
            Parity  10-20#,10-20,11-1#,11-1             program formats  3-5
            PDL OV  16-1                                project code verify bit  2-8
            PEEK  18-11,18-12#                          Project Codes  2-8#
            pen movements  15-1                         Protection  4-2#,8-6
            Per Frame Program Number  2-12#             PTY  10-3
            PERSET  4-11,4-11#                          PTY Terminal Charactersitics  10-3#
            PERSET Error Codes  4-12                    PTYs  10-3#
            PGESTS  4-12,4-12#                          punched cards  12-1
            PGFSTS  4-15#                               punched tape  14-1
                                                    D-6


            June 27, 1984                            D                                     Index


            Purpose  17-1#                              search list  8-5
            Purpose of PID's  9-1#                      second class club member  17-1
            PUTLSA  20-6,20-6#,20-7                     secondary RIB  8-5
            PUTROY  20-5,20-5#                          SEEK  8-23#
            PUTSAR  20-6,20-6#,20-7                     segment  3-1
            PUTSAR error codes  20-7                    session  2-1,2-12
                                                        Session control operations  2-7#
                                                        SETABK  19-5#
            RDHIST  19-6#                               SETABK control bits  19-5
            read frame attribute  2-35                  SETALP  2-10,2-10#
            read-only page  4-2                         SETDDT  3-3#
            Reading a Directory  8-3#                   SETE  2-5#
            Reading Current Charges  20-4#              SETINA  2-4#,2-11
            Reading Information  8-27#                  SETJAL  2-6#,2-7
            Reading Standard Buffer Size  6-2#          SETLCH  10-4,10-18,10-30#
            Reading, Testing and Setting  5-4#          SETLIC  2-4,2-6#
            REASSI  5-1,5-5,5-6#                        SETLIC/SETE Record words 5-7  20-9
            REASSIGN command  5-1                       SETMAI  2-4#
            Reassigning Devices  5-5#                   SETMAL  2-3#
            Recording Density  11-1#                    SETMCY  18-13#
            Recording Modes  11-1#,11-1                 SETMOD  10-4,10-32#
            red ball  10-15                             SETNAM  2-1,2-2#
            REDNXT  10-40,10-41#                        SETOTF  2-13,2-14#
            REDPIP  16-7#                               SETPOV  19-6#
            REFBIT  4-15,4-16#                          SETPRV  2-2#,10-13
            REFBIT Error Codes  4-16                    SETRCF  2-9,2-9#,2-9
            reference bits  4-15                        SETSTS  5-4,5-13#
            RELEAS  5-3,5-11,5-12#                      SETSTV  2-26,2-37#
            Releasing an Interlock  17-2#               SETTIM  16-6#,16-8
            Releasing Channels  5-3#                    Setting Charges  20-4#
            REMAP  3-2#                                 Setting File License  8-20#
            remote backspace echo  10-17                SETTMC  10-32#
            remote echo  10-15                          SETTR1  16-1,16-1#
            Remote XON  10-10#                          SETTR2  16-1,16-1#
            rename  8-8,8-9,8-17#                       setup  6-2
            Replicating Virtual Pages  4-4#             SETUUO  2-9,19-1#
            RESCAN  10-40,10-42#                        SETUWP  3-1,3-2#,3-5
            RESET  2-37,5-3,5-11#,10-25                 shared page  4-2
            Reseting Ports  10-4#                       Sharing  4-2#
            Restart Record words 0-1  20-10             Short Lookup Block  8-11
            Restricted Command Mode  2-9#               SHR file  3-5
            RETACH  10-1,10-3,10-24#                    Single Character Output  10-43#
            RETACH error codes  10-25                   SKPINC  10-41#
            retrieval information block  8-5            SKPINL  10-41#
            Reverse XON  10-10#                         slaved port  10-2
            RIB  8-5                                    Slaving the Command Port  10-2#
            Rights and Handles FRMOPs  2-30#            SLEEP  16-9#
            ring buffer  6-2                            Sleeping  16-8#
            ring setup  6-2                             SNOOP  19-6#
            RLSLDB  10-25#                              software i/o channels  5-1
            Royalty Charging  20-5#                     Software Paging  4-1#
            Royalty Product ID  20-5                    spare RIB  8-5
            Rules for .FOCFH handle creation  2-32      Special Characters  10-11#,10-11,10-17#
            RUN  2-1,2-10,2-23,2-25,2-29,3-1,3-5,       Special charging  20-1#
               3-7#,3-11                                Special Command Mode  2-9#
            RUN operation  3-5                          Special Control-T Mode  10-21#
            RUNSEG  3-1,3-10#,3-11                      Special Purpose Terminal Charactersitics
            RUNTIM  18-3#                                  10-21#
                                                        Special UFD status bits  8-5
                                                        Specialized File Manipulation  8-25#
            SAIL  1-1                                   SPYUUO  19-i#
            SAT  8-5                                    SSAVE  3-3
            SAV file  3-5                               stack overflow  16-1
            SAVE  3-3                                   standard date format  18-1
            SAVE and SSAVE operations  3-5#             Standard Paging error Codes  4-20
            SAVE operation  3-5                         State manipulation FRMOPs  2-24#
            saved license  2-4                          states word  18-9
            Saving Charges  20-4#                       STATO  5-4,5-13#
                                                    D-7


            Index                                    D                          YAMM edition 2.1


            STATZ  5-4,5-13#                            TTY parity  10-20
            Storage Allocation Table  8-5#,8-5          TTY:  10-1
            stream accounting  20-7                     TTY: File Status Bits  10-33
            Stream Accounting Data  20-7#               Turning off Echo  10-15#
            Stream Accounting Record Lengths  20-8      TymBasic  1-1
            Stream Accounting Record Types  20-7        TYMCHG  20-5,20-5#,20-8,20-9
            Stream Error Record words 0-1  20-10
            Stream Record Std. Header words 0-4
               20-8                                     UFD  8-3
            Stream Record types 0-6 (GET/RUN etc)       UFD protection  8-7
               format  20-8                             UGETF  8-32#,11-2,11-3,11-4
            Stream Royalty Record Words 5,6,7,10        UGETF Function Codes  11-5
               20-6                                     UGETF Information  11-4#
            String Output  10-45#                       UID  2-12
            structure  8-1                              Uninterruptible Page Copy  4-10#
            STRUUO  8-30#                               unit names  8-1
            STRUUO error codes  8-31                    Universal Frame ID  2-12#
            STRUUO function codes  8-31                 Universal User Number  2-1
            STTLK Error Codes  19-3                     Unmapping Virtual Pages  4-4#
            super IO  8-21                              update  8-8
            super mapping  4-6                          Uptime Record words 0-2  20-10
            super mode  8-21                            use bit  6-1
            super USETI  8-21                           Use of the Club UUOs  17-1#
            Super USETI/USETO  8-21#                    user address space  4-1
            super USETO  8-21                           User and Process Names  2-1#
            supercede  8-8                              User File Directory  8-3#,8-3
            Suppress-output-translation Bit  10-3#      User Level  10-2
            SWITCH  18-13,18-13#                        user map  4-1
            SWR file  3-5                               user name  2-1
            SYSDVF  5-7#                                user working set  4-2,4-7
            SYSDVF Function Codes  5-8                  User-Constructed Buffer Rings  6-2#
            SYSPHY  8-31#                               User-IOT  19-5
            SYSSTR  8-32#                               USETI  8-21#
            System Initialization Record words 0-1      USETO  8-22#
               20-9                                     UTPCLR  19-6#
            System Start Vector Indicies  2-27          UUN  2-1
                                                        UUODEF  A-1
                                                        UUOSYM.MAC  1-1
            tab-as-break  10-13
            tape  11-1
            tape byte counts  11-3                      Validating and Flushing  8-32#
            tape density  11-1                          Validating Pages  4-13#
            tape formats  11-1                          VALPAG  2-13,4-13,4-13#
            tape parity  11-1                           VALPAG Error Codes  4-14
            tape word counts  11-3                      VALRMT  19-6#
            Temporary files  2-37#                      VCLEAR  2-13,2-23,4-4,4-4#
            Terminal Characteristics  10-32             VCREAT  2-13,4-1,4-3,4-3#
            Terminal Class  10-21#                      VCREAT Error Codes  4-3
            Terminal Identifier Codes  18-9             VDSKPT  4-19,4-19#
            Testing  10-40#                             VDSKPT Error Codes  4-19
            Testing for File Membership  4-18#          Vestigial Job Data Area  3-3#
            Time Zone Codes  18-2                       VFSTAT  4-17,4-18,4-18#
            TIMER  18-3#                                virtual address  4-1
            TINASS  10-3,10-16,16-4,16-5#               virtual address space  4-1
            TMP file  8-13                              Virtual Memory  3-1#
            TMPCOR  2-37#                               Virtual Page Information  4-17#
            Trapping Arithmetic and Stack Overflow      VPEEK  18-11,18-12#
               16-1#                                    VPGFIL  4-18,4-18#
            trapping arithmetic overflow  16-1          VPGFIL Error Codes  4-19
            trapping stacck overflow  16-1              VPROT  2-13,4-7,4-7#
            Tree manipulation FRMOPs  2-20#             VPROT Error Codes  4-7
            TRPJEN  19-6#                               VREMOV  2-13,2-23,4-1,4-4,4-4#
            TRPSET  19-5,19-5#                          VREPLC  2-13,2-23,4-2,4-4,4-4#
            TRU Component Checkpoint  20-5#             VT and FF filler class  10-20#
            TTCALL  10-4,10-9#                          VT filler class  10-20
            TTCALL functions by number  10-9
            tty class  10-21
            TTY I/O wait  10-4                          WAIT  5-5,5-7#
                                                    D-8


            June 27, 1984                            D                                     Index


            Wait until inactive  5-5#
            WAITCH  10-40,10-41#
            WAKE  16-8,16-9#
            Watch Bit Definitions  2-8
            working set  4-2
            Working Set Control  4-7#
            Working Sets  4-2#
            write frame attribute  2-35
            Writing Stream Records  20-6#
            WSCTL  4-7,4-8,4-8#
            WSCTL Error Codes  4-9
            WSLIM  4-7
            WSMAX  4-7
            WSmax, WSlim, WSsiz  4-7#
            WSSIZ  4-7


            XCHARG  20-1,20-1#
            XCHARG Charge Table Entries  20-4
            XCHARG functions by number  20-1
            XCHARG stream record format  20-12
            XEXEC  2-12
            XOFF  10-10
            XON  10-10


            Yellow and Orange Balls  10-16#
            yellow balls  10-16


            ZAPCIR  10-2,10-27#
                                                     *  
            Zapping  10-2#
                                                   *   *
            ZAPRMT  19-6#
                                                     *  


































                                                    D-9

[(Q