begin	"XEXEC"

require "XEXEC.INF" source!file;

Define XEXEC!VERSION = (XEXEC!!VER lsh 24) lor XEXEC!!EDIT;
require XEXEC!VERSION version;

require "

XEXEC %"&CVOS(XEXEC!VERSION lsh -24)&"("&CVOS(XEXEC!VERSION land '777777)&")"&
     " - TYMCOM-X Periodic Processing Exec language

Assembly: Load @XEXEC.CMD

Sources:  XEXEC.SAI                 Main program source file
          XEXEC.INF                 Main release information file
          XEXEC.PAR                 Main parameter file
	  XEXEC.REQ                 Global declaration file
          SAIL.DEF                  General macro definition file
          UUOSYM.DEF                System call definition file
          JQUEUE.DEF                Job queue definition file

Library:  XEXSUB.REQ [SAI] [REL]    Main support routines
          JQUE.REQ   [SAI] [REL]    Job queue manipulation package
          VMFILE.REQ [SAI] [REL]    VM input file mapping pacakge
          DAYTIM.REQ [SAI] [REL]    Date time conversion package
          XEXINT.REQ [SAI] [REL]    Port and event interrupt package

License:  ALL license bits!!!
          WC RC SY OP GD TD ST JL AC XC HF RA WA

" message;

require "(SAILIB)SAIL.DEF" source!file;
require "(CARL)XEXEC.PAR"  source!file;
require "(MPL)UUOSYM.DEF"  source!file;
require "(CARL)JQUEUE.DEF" source!file;
require "(CARL)XEXSUB.REQ" source!file;
require "(CARL)JQUE.REQ"   source!file;
require "(CARL)VMFILE.REQ" source!file;
require "(CARL)DAYTIM.REQ" source!file;
require "(CARL)XEXINT.REQ" source!file;

require 25 polling!interval;
require 1000 new!items,  pnames;

Define OutMsg(x) = { Print(x) };
!	Definitions
;

Define	JobMax = 16;
Define Sleep!Time = !Xwd(1,3);		! sleep period between lines;

Define	Status!ERROR = -1		! Some error occurred;
,	Status!EXIT  =  0;		! XEXEC normal termination;

Define	Error! = 1;
	!Block(Error!,LIC)		! Not enough license;
	!Block(Error!,CFM)		! Create Frame;
	!Block(Error!,RFM)		! Run Frame;
	!Block(Error!,LFM)		! Logout Frame;
	!Block(Error!,FOE)		! File Operation Error;
	!Block(Error!,FMT)		! Formatting error;
	!Block(Error!,CMD)		! Command error;

Define DoIf(Flg,Top) = {
    If (Flg) then for MyJob_ 1 upto (Top)
     do if ( (Flg) land (1 lsh MyJob) )
};

Define TMPJob = { ("000"&Cvs(Frame[MyJob]))[inf-2 to inf] };
Define Complete = {"completed"};! successful completion;
Define Default!Ext = {".CTL"};	! default command file extension;
Define Uppercase(x) = {Scan(x, B!Up, Dummy)};
Define White(x) = {Scan(x, B!Wht, Brk)};
Define SetFlg(x,y) = { x_ x lor (1 lsh y) };
Define ClrFlg(x,y) = { x_ x land lnot(1 lsh y) };
Define NewLic(x,y) = { ( ((x lor y) land '777617777600)  lor
			 ((x land  '3) max (y land  '3)) lor
			 ((x land '14) max (y land '14)) ) };

Define Obnoxious!Message = {"

Warning!!! PERP and PCOM users...

    "":logfilename"" and "":LOGFILE logfilename"" are OBSOLETE.  The
    logfilename is specified when the job is entered in the queue.
    Temporarily the old commands will be ignored.  Please change your
    command files and delete this line.

"};

!	Command macro definitions
;

Define KQ(x,y) = 		     {	Kequ(x,CvPS(y))
    ifcr length( CvPS(y) ) > 3 thenc or Kequ(x,CvPS(y)[1 for 3]) endc
	};

Define AllCommands = {
    XC(AFTER)
    XC(BACKTO,    GOTO(CMD))
    XC(BACK,      GOTO(CMD))
    XC(COM,       COM(CMD))
    XC(CONTINUE)
    XC(DEFINE,    REASSIGN(CMD))
    XC(ESCAPE,    ESCAPE)
    XC(FIND)
    XC(GOTO,      GOTO(CMD))
    XC(GO,        GOTO(CMD))
    XC(IF)
    XC(LOOK)
    XC(PAUSE)
    XC(PARAMETERS,PARAMETERS(CMD))
    XC(QUIT,      QUIT)
    XC(REMARK)
    XC(RESTART)
    XC(SEND,      SEND(CMD))
    XC(STOP,      STOP)
    XC(TIME,      TIME(CMD))
    XC(UNLESS)
    XC(WAIT)
  };

!	Variable definitions for outer block;

Internal integer
	MyJob			! current job slot;
;

boolean
	ERR!, STOP!		! true when error occurrs or we stop;
,	TRU!			! true when the tru limit is exceeded;
,	NeedEscape		! true when waiting for command mode;
,	NeedZap			! true when waiting for zapper on job;
,	Quoted			! true if parameter is quoted [Get!Token];
,	DoParam			! true if $Substitutions;
,	DoNumerics		! true if $Numerics;
,	DoLog			! true if $Logging;
,	DoMail			! true if $Mail;
;

own integer 
	ActiveCount		! # active slots in use ;
,	HighJob			! highest active job slot ;
,	Child!handle, FD	! frame handles to child;
,	Seq			! current sequence number index;
,	Status			! current status of XEXEC job;
;

string	S, Disposition		! temp and completion variables;
,	Error!Text		! reason for error;
;

item	INTPRO;			! Item for interrupt processing;
itemvar	Intvar;			! Itemvar for INTPRO calls to INTINI;

!	Record and array definitions
;

record!class job( Integer Run, Seq, Opt; r!p (job) Nxt );
r!p (job) active, passive, jobs, tjob, njob, ljob;

  redefine CommandsLength = 0;
  redefine seperatorcharacter = {,};
  redefine XC(Text,Action) = {
    ifcr length( Cvps( Text ) ) thenc
      ifcr CommandsLength > 0 thenc seperatorcharacter endc
      redefine CommandsLength = CommandsLength + 1;
      Cvps( Text )
    endc
  };
Preset!with AllCommands;
Own safe string  array Commands[ 1 : CommandsLength ];

Own safe integer array Rec[ 0 : E!Length-1 ];	! record ;

Own safe integer array MySeq  [ 0 : JobMax ];	! My record number ;
Own safe integer array Frame  [ 0 : JobMax ];	! My frame number/handle ;
Own safe integer array OChan  [ 0 : JobMax ];	! Logfile channel ;
Own safe integer array PORT   [ 0 : JobMax ];	! port used for child i/o ;
Own safe integer array Limit  [ 0 : JobMax ];	! Timelimit ;
Own safe integer array Trus   [ 0 : JobMax ];	! TRU limit ;
Own safe integer array License[ 0 : JobMax ];	! File/Frame License ;
Own safe integer array MakeLog[ 0 : JobMax ];	! Log file creation ;
Own safe integer array LogDisp[ 0 : JobMax ];	! Log file disposition ;
Own safe integer array MyMail [ 0 : JobMax ];	! Mail action info ;

Own safe string  array Delim!list[0:JobMax ];	! stack of delimiter chars ;
Own safe string  array Del!Chr[ 0 : JobMax ];	! delimiter character ;
Own safe string  array Buffer [ 0 : JobMax ];	! additional lines ;
Own safe string  array IChan  [ 0 : JobMax ];	! stack of nested input files ;
Own safe string  array LineNo [ 0 : JobMax ];	! input  file line number ;
Own safe string  array CmdFile[ 0 : JobMax ];	! input  file name ;
Own safe string  array LogFile[ 0 : JobMax ];	! output file name ;
Own safe string  array MyName [ 0 : JobMax ];	! login username ;
Own safe string  array MySelf [ 0 : JobMax ];	! GFD username ;

Safe list array Par!!List[0:JobMax ];		! List of ordered parameters ;
Safe list array Par!!Set[ 0:JobMax ];		! Lists of named parameters;
Safe list itemvar array Par!List[ 0:JobMax ];	! List of Ordered parameters;
Safe set  itemvar array Par!Set[ 0:JobMax ];	! Set of Named parameters;

!	System variable definitions - currently defined
;

string	Item
	$Daytime		! Current time-of-day;
,	$Hour,$Minute,$Second	! Current time-of-day pieces;
,	$HH,$SS			! Current time-of-day pieces;
,	$HHMMSS,$HHMM,$MMSS	! Current time-of-day combinations;
,	$Date			! Current date dd-mmm-yy;
,	$Day,$Month,$Year	! Current day(dd),month(month),year(yyyy);
,	$Mon			! Current month(mmm);
,	$DD,$MM,$YY		! Current day(dd),month(mm),year(yy);
,	$Weekday		! Day of week, Sunday---Saturday;
,	$Yesterday,$Tomorrow	! Day of week, Sunday---Saturday;
,	$Delimiter;		! Delimiter variable;

boolean	Item
	$False			! FALSE value;
,	$Logging		! Logging variable;
,	$Substitution		! Substitution variable;
,	$Mail			! Mail variable;
,	$Numerics		! Numeric results variable;
,	$True;			! TRUE value;

integer	Item
	$TimeLimit		! Current Time Limit variable;
,	$TruLimit;		! Current TRU limit variable;


!	Support routines
;

Simple Boolean Procedure ClearFrame( Integer This );
begin "clear frame"

    if ( Frame[ This ] )		! anything here? ;
     then begin "frame must die"
	Frame[ This ]_ 0;		! clear frame position ;
     end "frame must die";

    if ( Port[ This ] )			! if any port assigned, zzzZap! ;
     then calli( Port[This], calli!ZAPCIR );

    If ( This = HighJob )		! check if was highest in use ;
     then for This_ HighJob downto 1	! seems so, so shrink any gaps ;
	   do if not( Frame[ This ] )	! in use? ;
	       then HighJob_ HighJob-1	! no, decrement high one again ;
	       else done;		! yes, time to stop ;

    return( false );			! give 'em what they came for ;

end "clear frame";


Boolean procedure EXIT(Integer Msg(0) );
begin
    Own Integer ErrorCondition;		! current error indicator (if any);

    If ( MyJob )			! if working on a job ;
     then begin "job exit"
	IntZap( Port[ MyJob ] );	! insure these are gone!!!!;
	ClearFrame( MyJob );		! send the frame away ;
     end "job exit";

    ErrorCondition _ Msg;		! set error condition and go home;

    If (Msg)				! if an error msg given;
     then begin
	 Status _ Status!ERROR;		!  then set error flag;
	 Usererr(0,0,"XEXEC error: "&
	      (case !lh(ErrorCondition) of (
		[0] Cvs( ErrorCondition ),
		[Error!LIC] "More License required",
		[Error!CFM] "Create Frame Error # ("&Cvos(!rh(ErrorCondition))&")",
		[Error!RFM] "Run Frame Error",
		[Error!LFM] "Logout Frame Error",
		[Error!FOE] "File Operation Error ("&Cvos(!rh(ErrorCondition))&")",
		[Error!FMT] "Formatting error",
		[Error!CMD] "Command error",
		[else] Cvs( ErrorCondition )  ))&
	      " -- XEXEC Aborting! ",
		(if ( !lh(ErrorCondition) = Error!LIC )
		  then "X"
		  else "C") );
     end;

    return( false );

end;


Simple Integer procedure File!Exit( Integer Chan; String Cmd );
begin

    print ("?file """,Cmd,""" ",case !rh(Chan)+1 of (
	[1-1] "device unavailable",
	[1+0] "not found",
	[1+1] "invalid user",
	[1+2] "protection failure",
	[1+3] "file being modified",
	[1+4] "already existing file",
	[1+5] "illegal sequence of UUOs",
	[1+6] "page i-o error",
	[1+'14] "no room - quota exceeded",
	[else] "LOOKUP error '"&cvos(!rh( Chan )) ),crlf);

    return( EXIT( !Xwd( Error!FOE,!rh( Chan ) ) ) );

end;

!	Initialization routines;

simple procedure LicenseCheck;
begin
  Ifcr PRELIMINARY thenc
    If ( ('777617 land lnot !lh( LC!HF ) )
	 neq !lh(calli(!xwd(-1,!GTLIC),calli!GETTAB)) )
  elsec
    If ( '777617 neq !lh(calli(!xwd(-1,!GTLIC),calli!GETTAB)) )
  endc
     then EXIT( Error!LIC lsh 18 );
end;
require LicenseCheck initialization;


procedure ParIni;
begin "parameter initialization"
    integer X;

    DoParam_ False;			! Insure no substitution;
    For X_ 0 upto JobMax
     do Delim!list[X]_ Del!Chr[X]_ "\";	! Default parameter escape;
    Setbreak( B!Quote_Getbreak,		! Initial breaktable for the;
		"\", null, "SINF");	!    parametization delimiter;
    Arrclr( Par!!List );		! Empty channel/file list;
    Arrclr( Par!!Set );			! Empty parameter set;
end;
require ParIni initialization;


simple procedure Fatal(String Msg);
begin
    Print(crlf, "?", Msg,
	If LineNo[MyJob] > 0
	 then " in line "&Cvs(LineNo[MyJob])
	 else "",crlf);
    Error!Text _ Msg;
    SetFlg( ERR!, MyJob );
end;


procedure SetTimeLimit( Integer TimeLimit );
begin
    Limit[MyJob]_ If TimeLimit = 0
		   then 0
		   else Calli( 0,-'143 ) + (60 * TimeLimit);
    calli(!xwd(2,TimeLimit),calli!SETTIM);	! set timer interrupt;
end;


procedure Set!Delimiter( String Character );
begin
    Del!Chr[MyJob] _ Character[1 for 1];		! one character width;
    If Del!Chr[MyJob] = 0 then Del!Chr[MyJob] _ "\";		! default to "\";
    Delim!list[MyJob]_Del!Chr[MyJob]&Delim!list[MyJob][2 to INF];	! change the delimiter list;
    Breakset(B!Quote, Del!Chr[MyJob], "I");		! change the break table;
    Ifcr PRELIMSUBS thenc
	print(" SetDelim(",Del!Chr[MyJob],")[",Delim!list[MyJob],"] ");
    endc
end;


simple procedure SYNC;
begin					! synchronize with slave;
    auxclv(PORT[MyJob],0,!axSYB);	! send yellow ball;
    If ( 0 < Trus[MyJob] < GetTRU(Frame[MyJob]) )
     then SetFlg( TRU!, MyJob );
end;


simple procedure OutPtr (integer PORT; string S);
begin "out pointer"
    while ( length(S) )			! while something to do ;
     do auxclv(PORT,lop(S),!axO8);	! send a character ;
    SYNC;				! send yellow ball & synch ;
end "out pointer";
! begin!code	! could use this but it won't do image mode;
!	MOVEI	1,!AXOPC;		! output SAIL string;
!	HRL	1,PORT;
!	AUXCAL	1,-1(SP);		! output through pointer;
! end ;


String Procedure BoolToStr( Boolean T );	! Boolean to String;
Return( If T
    then If ( DoNumerics land (1 lsh MyJob) ) then "1" else "TRUE"
    else If ( DoNumerics land (1 lsh MyJob) ) then "0" else "FALSE"
	);

Boolean Procedure StrToBool( String S );	! String to Boolean;
Return( Kequ(S,"1") or Kequ(S,"TRUE"[1 for length(S)]) );


procedure RW!Item( String Itemvar W,R; Reference Boolean B);
begin
    If ( R neq any )
     then B_ StrToBool( Datum(R) );	! Set from source if there;
    If ( W neq any )
     then Datum(W)_ BoolToStr( B );	! Return to dest if there;
    Ifcr PRELIMITEM thenc
	Print( "RW!I ",
		If R neq any then " R(" & Datum(R) & ")" else "",
		If W neq any then " W(" & Datum(W) & ")" else "",crlf);
    endc
end;


procedure RW!MyItem( String Itemvar W,R; Reference Boolean B);
begin
    If ( R neq any )
     then begin "source"		! Set from source if there;
	B_ B land lnot(1 lsh MyJob);	! clear bit first then ?set;
	B_ B lor  (StrToBool( Datum(R) ) lsh MyJob);
     end "source";
    If ( W neq any )			! Return to dest if there;
     then Datum(W)_ BoolToStr( B land (1 lsh MyJob) );
    Ifcr PRELIMITEM thenc
	Print( "RW!MyI ",
		If R neq any then " R(" & Datum(R) & ")" else "",
		If W neq any then " W(" & Datum(W) & ")" else "",crlf);
    endc
end;


procedure Date$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 0 );

procedure Day$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 1 );

procedure Daytime$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & ":" & CvS(MM) & ":" & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Delimiter$(String Itemvar W, R);
Begin
    If R neq any then Set!Delimiter(Datum(R));	! change the delimiter;
    If W neq any then Datum(W)_ Del!Chr[MyJob];	! return the current setting;
end;

procedure False$( String Itemvar W, R);
RW!Item( W, any, FALSE);			! return FALSE;

procedure Hour$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(HH);
    end;
end;

procedure HH$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH);
	SetFormat(T,D);
    end;
end;

procedure HHMM$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & CvS(MM);
	SetFormat(T,D);
    end;
end;

procedure HHMMSS$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & CvS(MM) & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Logging$( String Itemvar W, R);
If MakeLog[MyJob]				! log file output state;
    then begin
	IntMak( Int!CHR );			! input chars interrupt;
!	ProcessOutput;
	RW!MyItem( W, R, DoLog );		! if LogFile R|W;
    end
    else RW!MyItem( W, any, DoLog );		! if not LogFile R-only;

procedure Mail$( String Itemvar W, R);
RW!MyItem( W, R, DoMail );			! sending mail;

procedure Minute$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(MM);
    end;
end;

procedure MMSS$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(MM) & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure MM$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 7 );
procedure Mon$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 2 )[1 for 3];
procedure Month$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 2 );

procedure Numerics$( String Itemvar W, R);
RW!MyItem( W, R, DoNumerics );			! boolean representation;

procedure Second$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(SS);
    end;
end;

procedure SS$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Substitution$( String Itemvar W, R);
RW!MyItem( W, R, DoParam );			! parameter substitution;

procedure TimeLimit$(String Itemvar W, R);
begin
    If R neq any then SetTimeLimit( Cvd(Datum(R)) );
    If W neq any then Datum( W ) _
	CvS(If Limit[MyJob] = 0
	     then 0
	     else (Limit[MyJob] - Calli(0,-'143)) div 60);
end;

procedure True$( String Itemvar W, R);
RW!Item( W, any, TRUE);				! return TRUE;

procedure Trulimit$( String Itemvar W, R);
begin
    If R neq any then Trus[MyJob]_ If Cvd( Datum(R) ) = 0
				    then 0
				    else GetTru(Frame[MyJob]) + Cvd( Datum(R) );
    If W neq any then Datum( W ) _ Cvs( If Trus[MyJob] = 0
				   then 0
				   else Trus[MyJob] - GetTru(Frame[MyJob]) );
end;

procedure Tomorrow$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 5 );
procedure Weekday$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 4 );
procedure Yesterday$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 6 );

procedure Year$( String IteW, R);
If W neq any then Datum( W ) _ DatStr( 3 );
procedure YY$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 3 )[3 for 2];


procedure ItemIni;			! Alphabetical;
begin "procedure item initialization"
    Assign( $Date,       Date$);	! Current Date;
    Assign( $Day,        Day$);		! Current Day of Month;
    Assign( $Daytime,    Daytime$);	! Current Time of day;
    Assign( $DD,         Day$);		! Current Day of Month;
    Assign( $Delimiter,  Delimiter$);	! Delimiter value;
    Assign( $False,      False$);	! FALSE;
    Assign( $HH,         HH$);		! Current Hour of day 00-23;
    Assign( $HHMM,       HHMM$);	! Current Hour-minutes hhmm;
    Assign( $HHMMSS,     HHMMSS$);	! Current Hour-minutes-seconds;
    Assign( $Hour,       Hour$);	! Current Hour of day 0-23;
    Assign( $Logging,    Logging$);	! If logging to file;
    Assign( $Mail,       Mail$);	! If mail wanted at end;
    Assign( $Minute,     Minute$);	! Current Minutes of hour;
    Assign( $Mon,        Mon$);		! Current Month as Mmm;
    Assign( $Month,      Month$);	! Current Month of year;
    Assign( $MM,         MM$);		! Current Month as numeric;
    Assign( $MMSS,       MMSS$);	! Current Minutes-seconds;
    Assign( $Numerics,   Numerics$);	! If booleans are 1/0 or TRUE/FALSE;
    Assign( $Second,     Second$);	! Current seconds of minute;
    Assign( $SS,         SS$);		! Current seconds of minute SS;
    Assign($Substitution,Substitution$);! If parameter substitutions on;
    Assign( $Timelimit,  Timelimit$);	! Time-limit remaining (Minutes);
    Assign( $True,       True$);	! TRUE;
    Assign( $Trulimit,   Trulimit$);	! TRU-limit remaining (TRUs);
    Assign( $Weekday,    Weekday$);	! Day of Week;
    Assign( $Year,       Year$);	! Current Year;
    Assign( $YY,         YY$);		! Current Year as two digits;
end;
require ItemIni initialization;

procedure MOV ( itemvar DST,SRC );
begin
    string item TMP;
    own string itemvar SI;
    own real itemvar RI;
    own integer itemvar II;
    own integer BRK;
Ifcr PRELIMITEM thenc
    print("Mov: SRC[",typeit(SRC),"] ==> DST[",typeit(dst),"] ");
endc
    case typeit(SRC) of begin		! Convert ??? to string;
	[3] "string   " datum(TMP)_ datum(SI_SRC);
	[4] "real     " datum(TMP)_ cvf(datum(RI_SRC));
	[5] "integer  " datum(TMP)_ cvs(datum(II_SRC));
	[8] "procedure" apply( datum(SRC), arg!list(TMP,any) );
	else usererr( typeit(SRC),2,"?MOV: can't coerce src type " )
    end;
    case typeit(DST) of begin		! Convert string to ???;
	[3] "string   " datum(SI_DST)_ datum(TMP);
	[4] "real     " datum(RI_DST)_ realscan(datum(TMP),BRK);
	[5] "integer  " datum(II_DST)_ intscan(datum(TMP),BRK);
	[8] "procedure" apply( datum(DST), arg!list(any,TMP) );
	else usererr( typeit(DST),2,"?MOV: can't coerce dst type " )
    end;
end;

String procedure Substitute(Integer Chan; String Key);
begin
    String Item SITM;    String Itemvar SI;    Boolean Not!Defined;
    Integer Dummy;		! used in UPPERCASE macro ;

    Key _ Uppercase(Key);			! make sure this works;
    If Key neq "$" then Key _ Chan & Key;	! user keyword? ;
    SI _ Cvsi(Key, Not!Defined);		! lookup variable;
    If Not!Defined then Return( Null );		! return null if undefined;
    MOV( SITM, SI );				! convert ITM _ SI;
    Return( Datum(SITM) );			! return string;
end;

simple string procedure Get!Token(Reference string Par!Lst);
begin "get a parameter"
    String S, Old!Brk;
    Integer InQuote, Save!Brk;

    White( Par!Lst );					! Clear whitespace;
    Quoted _ False;					! Initialize flag;
    S _ Scan(Par!Lst, B!Sub, Brk);			! Get Token;
    If Brk = '177 or Brk = '42 or BRK = "'"
      then begin "in quote"				! We found a quote;
        Quoted _ InQuote _ True;    Save!Brk _ Brk;	! For matching pair;
	If Length(S) then begin				! not allowed yet;
	    Fatal("parameter text """&S&""" discarded");
	    S _ null;
	end;
	Old!Brk _ null;					! Start anew;
	While InQuote do begin "Matching quote"		! Match quotes! ;
	    S _ S & Old!Brk & Scan(Par!Lst, B!Sub, Brk);! Ignore other breaks;
	    If Brk = '42 and Save!Brk = '42 or		! Check for pairs;
	       Brk = "'" and Save!Brk = "'" or		!    of each type;
	       Brk = '177 and Save!Brk = '177		!    "for child";
		then If Brk = Par!Lst			! Match! Double?;
		    then begin "quote quote"		!  Yes - handle "";
			Old!Brk _ Null;			!   Clear break!char;
			S _ S & Lop(Par!Lst);		!   Add to string;
		    end "quote quote"			!  Continue;
		    else begin "done quote"		!  Not double - ;
			InQuote _ False;		! Set we are done;
			White( Par!Lst );		! Clear Whitespace;
			Scan(Par!Lst, B!Sub, Brk);	! Eat to next break*;
		    end "done quote"
		else Old!Brk _ If Brk = 0 then Null else Null & Brk;
	    If length(Par!Lst) = 0 then Done;		! If missing quote?;
	end "Matching quote";
      end "in quote";


!
  * --	It would be nice at this point to allow some kind of combination
	or other parameter tricks.  However... not so decided...  (YET)
;
    If Brk = "/" then Par!Lst _ "/" & Par!Lst;		! restore "/";
    If Brk = " " or Brk = #ht then begin
	White( Par!Lst );				! Clear whitespace;
	If Brk = "=" or Brk = ","			! Eat certain breaks;
	    then Brk _ Lop( Par!Lst );			!  so things work;
    end;
    Return(If Length( S ) then S else null);		! Return something;
end "get a parameter";

Procedure New!Parameter(Integer Chan; String Name, Initial!Value, New!Value);
begin
    String Itemvar SI;
    String Item ITM;
    Own Boolean Not!Defined;
    Integer Dummy;			! used in UPPERCASE macro ;

    Name _ Uppercase(Name);				! Force upper-case;
    If Name neq "$" then Name _ Chan & Name;		! Maybe add channel;
    Ifcr PRELIMITEM thenc
	print("NewP: ",Name," (",initial!value,") N(",New!value,")");
    endc
    SI _ Cvsi( Name, Not!Defined);			! See if PNAME exists;
    If Not!Defined then begin				! No, then;
	If Name = "$" then begin "don't allow $ vars"	!   if system var?;
	    Fatal("Illegal variable name """&Name&"""");!   illegal not found;
	    Return;					!     so bug out.;
	end;						!   else;
	New!Pname(SI _ New(Initial!Value), Name);	!     define it;
	Par!Set[MyJob] _ Lop(Par!!Set[MyJob]);		! Get current set;
	Put SI in Datum( Par!Set[MyJob] );		! Put new item in set;
	Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! Put set away;
    end;
    If length(New!Value) then begin			! If something there;
	Datum( ITM ) _ New!Value;			!   store as string;
	MOV( SI, ITM );					!   mov SI _ ITM;
    end;
    Ifcr PRELIMITEM thenc
	print(" Pname[ ",Cvis( SI, Not!defined )," ]",Crlf);
    endc
end;


simple procedure Set!Parameter(Reference string Par!Lst);
begin "build substitution table"
    String Par!,Name;    String Itemvar SI;
    Integer Par!Index;   Boolean Named!Parameters;

    Par!Set[MyJob]  _ New(Phi);				! Empty set;
    Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! First item in list;
    Par!List[MyJob] _ New(Nil);				! Empty list;
    Named!Parameters _ False;				! None at first;
    While Length(Par!Lst)
     do begin "reading parameters"
	Name _ null;					! Clear name;
	Par! _ Get!Token( Par!Lst );			! Read a parameter;
	If Brk = "=" then begin "named parameters"	! Assignment!;
	    If Quoted then				! To a string?;
		Fatal("Assignment to string """&Par!&"""");
	    Named!Parameters _ True;			!   Set flag;
	    Name _ Scan( Par!, B!Par, Brk );		!   Set name;
	    If Length(Par!) then begin			!   Error if non-null;
		Fatal("Illegal character """&Brk&	!     print message;
			""" in parameter");
		Name _ null;				!     clear name;
	    end;
	    Par! _ Get!Token( Par!Lst );		!   Set parameter;
	end "named parameters";
Ifcr PRELIMITEM thenc
    Print("List: {",Name,"}={",Par!,"}",Length(name),":",Length(par!),crlf);
endc
	If ( Length( Name ) ) then begin		! Named parameter;
	    SetFlg( DoParam, MyJob );			! Set flag true;
	    New!Parameter(IChan[MyJob],Name,Null,Par!)	! Create parameter;
	  end
	  else begin					! Ordered parameter;
	    If ( Named!parameters ) then Fatal(		!   ** ERROR **;
	     "Ordered parameter after Named parameter ignored: """&Par!&"""")
	    else begin
		SetFlg( DoParam, MyJob );		! Set flag true;
		SI _ New( Par! );			!   create item;
		Put SI in Datum(Par!List[MyJob]) after INF;  ! Put into list;
	    end;
	end;
    end "reading parameters";
    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! First item in list;
end "build substitution table";

Procedure Forget!substitutions;
begin
    String Itemvar SI;
    Ifcr PRELIMSUBS or PRELIMITEM thenc
	If Length( Par!!List[MyJob] ) or Length( Par!!Set[MyJob] )
	 then Print("Forget: ");
    endc
    If Length( Par!!List[MyJob] )
     then begin "zap list by 1"
	Par!List[MyJob] _ Lop( Par!!List[MyJob] );
	While Length( Datum(Par!List[MyJob]) )
	 do begin "ordered"
	    SI _ Lop( Datum(Par!List[MyJob]) );
	    Ifcr PRELIMSUBS or PRELIMITEM thenc
		Print(" ${",Datum(SI),"}");
	    endc
	    Delete( SI );
	 end "ordered";
	Delete( Par!List[MyJob] );
     end "zap list by 1";
    If Length( Par!!Set[MyJob] )
     then begin "zap set by 1"
	Par!Set[MyJob] _ Lop( Par!!Set[MyJob] );
	While Length( Datum(Par!Set[MyJob]) )
	 do begin "named"
	    SI _ Lop( Datum(Par!Set[MyJob]) );
	    Ifcr PRELIMSUBS or PRELIMITEM thenc
		begin
		    String PN; Integer Dummy;
		    PN _ Cvis( SI, dummy );
		    If PN < " " then PN _ "<"&CVOS(LOP(PN))&">" & PN;
		    Print(" ",PN,"{",Datum(SI),"}");
		end;
	    endc
	    Del!Pname( SI );
	    Delete( SI );
	 end "named";
	Delete( Par!Set[MyJob] );
     end "zap set by 1";
    Ifcr PRELIMSUBS or PRELIMITEM thenc
	If Length( Par!!List[MyJob] ) or Length( Par!!Set[MyJob] )
	 then Print(crlf);
    endc
end;


String procedure parametize(Value String S);
begin "parameter substitution"
    String L, Key;    Integer Par!Chr;

    Ifcr PRELIMSUBS thenc
	Print("R: ",S,crlf);
    endc
    L _ Null;					! Newline;
    While ( Length(S) )				! While we have a string ;
     do begin "have string"
      L_ L & Scan(S, B!Quote, Brk);		! Scan for a parameter;
      If ( Brk = Del!Chr[MyJob] )		! Null?;
       then begin "got one"
	Par!Chr_ Lop(S);			! Get next char;
	If ( Par!Chr = Del!Chr[MyJob] )		! Do we have quote quote?;
	  then L_ L & Par!chr			!  Yes, use a quote here;
	  else begin				!  No. ;
	    Key_ Par!Chr & Scan(S,B!Par,Brk);	!   Read keyword;
	    If ( Brk = Del!Chr[MyJob] )		! If followed by quote;
	     then Par!Chr_ Lop(S);		!   eat the quote;
	    L_L & Substitute(IChan[MyJob],Key);	!   Perform substitution;
	    Ifcr PRELIMSUBS thenc
		print("Par: Key(",key,") <= """,Substitute(IChan[MyJob],key),"""",crlf);
	    endc
	  end;
      end "got one";				! Done parameter;
    end "have string";				! Done Line;
    Ifcr PRELIMSUBS thenc
	Print("P: ",L,crlf);
    endc
    Return (L);					! So, Return it;
End;
	

simple boolean procedure MyCommand(String KW);
Return( BRK = "=" or length( KW ) = 0 or
       (Kq(KW,AFTER) or Kq(KW,COM) or Kq(KW,CONTINUE) or Kq(KW,DEFINE) or
	Kq(KW,ESCAPE) or Kq(KW,FIND) or Kq(KW,GO) or Kequ(KW,"GOTO") or
	Kq(KW,IF) or Kq(KW,LOOK) or Kq(KW,PAUSE) or Kq(KW,PARAMETERS) or
	Kq(KW,QUIT) or Kq(KW,REMARK) or Kq(KW,RESTART) or Kq(KW,SEND) or
	Kq(KW,STOP) or Kq(KW,TIME) or Kq(KW,UNLESS) or Kq(KW,WAIT)
	)
    );

simple boolean procedure ChkCommand( String Str );
begin "check command"
    String S, KW;
    Boolean Eof;

    if ( Str = "." or Str = "-" or Str = "@" or Str = "!" )
     then lop( Str );			! remove leading character ;

    S_ Tok( Str );			! get a small parcel ;

    If ( Brk = ":" )
     then return( true );		! seems to be a label ;

    If ( Brk = "=" )
     then return( true );		! seems to be a definition ;

    return( MyCommand( S ) );		! some "known" command? ;

end "check command";


simple boolean procedure Check!LogFile;
begin ":LogFile check"
    String S, KW;
    Boolean Eof;

    S _ null;					! Initially nothing there;
    Do S _ VMLine( IChan[MyJob], Brk )		! Read first line of file;
     until ( BRK = #lf ) or ( Eof_ Brk = 0 );	!  up to first LF;
    If ( EOF and Length(S)=0 )			! Nothing there? ;
     then Return(False);			! Return ;
    if ( lop(S) neq ":" )			! Is it a command?;
     then begin "no command"
	VMSetC( IChan[MyJob], 0 );		! No, reset file pointer;
	Return(False);				!     and Return;
     end "no command";
    If ( S = ":" )				! Yes, special case label;
     then Return( False );			!      by just returning ;
    KW_ Get!Token(S);				!   get first token;
    If ( Kq(KW,LogFile[MyJob]) )
     then return( true );			!   see if :LogFile;
    If ( MyCommand(KW) )			!   No, a legal command?;
	then VMSetC( IChan[MyJob], 0 )		!       Yes, reset pointer;
	else begin "Old style PERP header"	!       No, assume filename;
	    S _ KW & Brk & S;			!	    Restore line;
	    Print( Obnoxious!Message );		!         and print message;
	end "Old style PERP header";
    Return( False );				! Return FALSE;
end ":LogFile check";


simple boolean procedure Create!Child;
begin "birth procedure"
    Own Integer month, frame!index, frame!handle;

    Redefine CF!LIC = !bit(16);		! until UUOSYM.DEF is right;
    Redefine CF!LOG = 0;		! really !bit(17);

    Rec[ E!Runtime ]_ CF!LIC lor CF!LOG lor (E!License - E!Runtime);

    month_ 0;
    While ( 9 geq month_ month + 1 )	! we only get so many months;
     do begin "pregnancy"		!  to come to term ;
	begin!code			! take a trip to the hospital ;
	    protect!acs 1,2;
	    label frmerr;

	    SETOM !skip!;		! skip return;
	    HRLI 1,!foCFM;		! function: create frame;
	    uuo!FRMOP 1,Rec[E!Runtime];	! attempt to bear a child;
	      Jrst frmerr;		!   unbearable!;
	    MOVEM 1,frame!index;	! save the handle to the child;
	    ANDI  1,'777;		! use an absolute handle;
	    MOVE  2,['377777];		! 0b17,,3b20 77777b35;
	    MOVEI 3,0;			! maximum access rights;
	    HRLI  1,!foCFH;
	    uuo!FRMOP 1,2;		! create frame handle;
frmerr:	      SETZM !skip!;
	    MOVEM 1,frame!handle;	! save new handle (or error);
	end;

	if ( !skip! )			! what did the doctor say ;
	 then begin "bouncing"
	    Child!handle_ Frame!Handle;	! it's a bouncing baby frame ;
	    return( frame!index )	! remember to name the baby ;
	 end "bouncing"
	 else
	    If !rh(frame!index) < 2	! no capacity [0]disk, [1]frame ;
	     then calli( !Xwd(1,2), calli!HIBER )
	     else return( false );	! mis-carriage ;

     end "pregnancy";

    return( false );			! better get another father ;

end "birth procedure";


Simple boolean procedure SPROUT( Boolean NeedPort );
begin
    Own integer MyPort,APort;
    Own Safe Integer Array Pty[0:1];

    if ( NeedPort )			! does this job require a port ;
     then begin "need a port"		! yes, so setup a PTY-pair ;

	APort _ calli(0,calli!CREPTY);	! create the PTYs ;
	if not( !SKIP! )		! failed? ;
	 then return( false );		! then go home ;

	Port[MyJob]_MyPort_ !lh(APort);	! my pty port to remember ;

     end "need a port";

    If ( FD _ Create!child )		! create a child frame;
     then Frame[MyJob]_ FD Land '777	! remember child's name;
     else return( false );		! else go home ;

    if ( NeedPort )
     then begin "transfer port"

	auxcli(MyPort,'214,!axCFS);	! we are in image no echo;
	auxclv(MyPort,1,!axSOX);	! expand tabs for output ;

	Pty[0]_ !Xwd(      -1,FD );	! from self to child ;
	Pty[1]_ !Xwd( '200000,APort );	!  using this port ;
	calli( location(Pty[0]), calli!RETACH );

	if not( !SKIP! )		! can't attach port? ;
	 then return( false );		! go home ;

	IntPrt( MyPort );		! enable interrupts on port ;

     end "transfer port";

    return( true );

end;

simple boolean procedure FrontEnd;
begin "FrontEnd"
    own integer Array F[1:6];
    integer C, Chan, PBP, RunFlag, FileLicense;
    string Name, Cmd, Log, S;			! handy strings ;

  Ifcr PRELIMINARY thenc
    Print( "(", Cv6str(Rec[E!LogFile+F!User]),Cv6str(Rec[E!LogFile+F!User+1]),")",
	    Cv6str(Rec[E!LogFile+F!Name]),".",Cv6str(Rec[E!LogFile+F!Ext])[1 for 3],
	" = (",Cv6str(Rec[E!CmdFile+F!User]),Cv6str(Rec[E!CmdFile+F!User+1]),")",
	    Cv6str(Rec[E!CmdFile+F!Name]),".",Cv6str(Rec[E!CmdFile+F!Ext])[1 for 3],
	crlf );
  endc

    Cmd_ Cv6str( Rec[E!CmdFile+F!Device] ) & ":" & 
	 "("& Cv6str( Rec[ E!CmdFile + F!User ] ) &
	 Cv6str( Rec[ E!CmdFile + F!User+1 ] ) & ")" &
	 Cv6str( Rec[ E!CmdFile + F!Name ] ) &
	 (if ( Rec[ E!CmdFile + F!Ext ] )
	  then "."&cv6str( Rec[ E!CmdFile + F!Ext ] )[1 for 3]
	  else "");

!	Create frame & determine if PTY needed here. ;

    MyName[MyJob]_ cv6str(Rec[ E!Username ]) & cv6str(Rec[ E!Username+1 ]);

    If ( Rec[ E!AUN ] = Rec[ E!PPN ] )		! if same ppn/aun ;
     then MySelf[MyJob]_ MyName[MyJob]		!  then copy name ;
     else MySelf[MyJob]_ cvName(Rec[ E!PPN ]);	!  else generate. ;

!	setup input file 
;
    IChan[MyJob]_ VMFile( Cmd, VM$Read );	! open input file. ;
    if ( IChan[MyJob] leq 0 )			! if not available ;
     then return(File!Exit(IChan[MyJob],Cmd));	!  return an error ;

    If ( FileLicense_ VMGetC( IChan[MyJob],VM$Lic ) )	! if license, use it;
     then Rec[ E!License ]_ NewLic( Rec[E!License], FileLicense );
    License[ MyJob ]_ Rec[ E!License ];		! copy license ;

    If ( RunFlag_ Ldb( PPRunF(Rec) ) )		! if RUN program  ;
     then VMFree( Lop( IChan[MyJob] ) );	!  close file now ;

    If not( Sprout( Ldb( PPDetF(Rec) ) = 0 ) )	! create frame :: pty ;
     then return( ClearFrame( MyJob ) );	! if error then give up ;

!	Handle parameters here.  Note: Do this even if no parameters. ;

    S_ null;
    If ( Rec[ E!Parameters ] )		! some parameters ;
     then begin "build line"
	PBP_ point( 7,Rec[E!Parameters],-1 );
	While ( C_ILdb(PBP) ) do S_ S & C;
	Ifcr PRELIMPARS
	 thenc
	    Print( "Parameters: ", S, Crlf );
	 endc
     end "build line";

    If ( RunFlag ) and ( C_ Ldb( PPTmpN(Rec) ) lsh 18 )
     then begin "need tempfile"
	C_ VMFile( "("& MySelf[MyJob] &")" &
		    TmpJob & cv6str(C)&".TMP",   VM$Write );
	If ( ( C > 0 )  or  not( VMText( C, S & crlf ) ) )
	 then begin "TMP file error"	! can't open or can't write ;
	    VMFree( C );		! close out the TMP file ;
	    return( ClearFrame( MyJob ) );	! then abort... error ;
	 end "TMP file error";
	VMFree( C );			! close off the TMP file ok. ;
	S_ Null;			! if TMP:file, no parameters ;
     end "need tempfile";

    Set!Parameter(S);			! scan thru EOL;

    If not( RunFlag )
     then Check!LogFile;		! Ignore :LogFile filename;

    MakeLog[MyJob]_ Ldb( PPLog(Rec) );	! LogFile?;
    If ( MakeLog[MyJob] )		! If log file wanted ;
     then SetFlg( DoLog, MyJob )	!  then set flag ;
     else ClrFlg( DoLog, MyJob );	!  else clear flag ;

    LogDisp[MyJob]_ Ldb( PPDisp(Rec) );	! Log-Disp? ;

    Log_ Cv6str( Rec[E!LogFile+F!Device] ) & ":" &
	 "("& Cv6str( Rec[ E!LogFile + F!User ] ) &
	 Cv6str( Rec[ E!LogFile + F!User+1 ] ) & ")" &
	 Cv6str( Rec[ E!LogFile + F!Name ] ) &
	 (if ( Rec[E!LogFile + F!Ext] )
	  then "."&cv6str( Rec[ E!LogFile + F!Ext ] )[1 for 3]
	  else "");

    Ifcr PRELIMFILES thenc
	print( if LogDisp[MyJob] then "{"&Log&"}=" else "",
	       if RunFlag        then " Running "  else "",
		"{",Cmd,"}",Crlf);
    endc

!	open LOG file
;
    if ( ( DoLog land (1 lsh MyJob) ) )			! making a log file? ;
     then begin "get log file"

	If ( JL$Append leq MakeLog[MyJob] leq JL$Supersede )	! if logging ;
	 then begin "open LogFile"			!  setup file ;

	    If ( MakeLog[MyJob] = JL$Supersede )	! if supercede? ;
	     then begin "supercede"
		Chan_ VMFile( Log, VM$Write );		! $Write (re-open) ;
		If ( Chan > 0 )				! if no errors ;
		 then VMFree( Chan )			!  close it! (done) ;
		 else return( File!Exit(Chan,Log) );	!  write failure? ;
	     end "supercede";

	    Chan_ VMFile( Log, VM$Update );		! $Update ;
	    if ( Chan leq 0 )				! all ok? ;
	     then return( File!Exit(Chan,Log) );	!  oops.. ;

	    If ( MakeLog[MyJob] = JL$Append )		! if append? ;
	     then begin "set to end"
		if ( VMGetC( Chan,VM$Size ) )		! if not empty ;
		 then begin "position pointer"
		    C_ VMMove( Chan, -1 );		! backup one line ;
		    if ( C )				! if all ok ;
		     then C_ VMMove( Chan, 1 );		!  then forward ;
		    if not( C )				! if either fails ;
		     then return( Exit( !xwd(Error!FOE,JL$Append) ) );
		 end "position pointer";
	     end "set to end";

	 end "open LogFile"
	 else begin "spool LogFile"
	    ! not implemented in the monitor;	! ** Future LPT: ** ;
	 end "spool LogFile";

	OChan[ MyJob ]_ Chan;		! store proper output channel ;

    end "get log file";

    MyMail[MyJob]_ Ldb( PPMail(Rec) );	! Mail action;
    If ( MyMail[MyJob] )		! If any mail wanted ;
     then SetFlg( DoMail, MyJob )	!  then set flag ;
     else ClrFlg( DoMail, MyJob );	!  else clear flag ;

    SetFlg( DoNumerics, MyJob );	! Default setting ;
    SetTimeLimit( Ldb( PPTimL(Rec) ) );	! set user timeout in minutes;
    Trus[MyJob]_ Rec[ E!TruLim ];	! set user TRU limit;

    ClrFlg( NeedZap, MyJob );		! restore initial Zap state ;
    ClrFlg( NeedEscape, MyJob );	! restore initial Escape state ;
    Buffer[ MyJob ]_ Null;		! clear type-ahead msg buffer ;

  return( true );

end "FrontEnd";


procedure REASSIGN (string CMD);
begin "DEFINE COMMAND"
    string  Key, Val, Expr;

    While Length(CMD) do begin "scanning parameters"
	White( CMD );					! Clear whitespace;
	Key _ Scan( CMD, B!Par, Brk);			! Get name;
	Ifcr PRELIMPARS or PRELIMITEM thenc
	    Print(" Key(",Key,") Break(",Brk&Null,")[",Brk,"] CMD: ",CMD,crlf);
	endc
	If Brk = " " or Brk = #HT then White( Cmd );	! Eat whitestuff;
	If Brk = "=" then begin
	    Lop( CMD );					! Eat = ;
	    Expr _ Get!Token(CMD);			! Read next token;
	    Ifcr PRELIMPARS or PRELIMITEM thenc
		Print(" Expr(",Expr,") Break(",Brk&Null,")[",Brk,"] CMD: ",CMD,crlf);
	    endc
	    If not (quoted or Numeric(Expr) ) then begin
		Val _ Scan(Expr,B!Par,Brk);
		If length(Expr) then Fatal(
		    "Illegal character """&Brk&""" in parameter name")
		  else begin
		    Expr _ Substitute( IChan[MyJob], Val );
		    New!Parameter(IChan[MyJob], Key, Null, Expr )
		  end;
	    end
	    else New!Parameter(IChan[MyJob], Key, Null, Expr )
	end
	else begin
	    Fatal("Illegal format in assignment """&Brk&Cmd&"""");
	    Ifcr PRELIMPARS or PRELIMITEM thenc
		Print(" Key(",Key,") Break(",Brk&Null,")[",Brk,"] CMD: ",CMD,crlf);
	    endc
	    Done;
	end;
    end "scanning parameters";
end "DEFINE COMMAND";


procedure COM (string CMD);
begin "COM COMMAND"
    Integer Chan;
    String Name, Dev;
    Boolean Ext!Found, File!Error;

    Name _ GetFil(CMD, Dev_ Cv6str(Rec[E!CmdFile+F!Device]), Ext!Found, File!Error);	! read off filename;
    If ( File!Error ) then begin		! If error...;
	Fatal("COM Filename error """&Name&"""");
      end
      else begin				! add delimiter to list;
	Delim!list[MyJob]_ Del!Chr[MyJob] & Delim!list[MyJob];
	Set!Parameter(CMD);			! NOW setup parameters;
	Chan_ VMFile( Name );
	If ( Chan leq 0 ) and not Ext!Found	! if not there, then;
	 then Chan_ VMFile(Name&Default!Ext);	!  try other extension;
	If ( Chan leq 0 )
	 then Fatal( "COM File error ("&Cvs(!rh(Chan))&") for file: "&Name);
	IChan[MyJob] _ Chan & IChan[MyJob];	! add channel to list;
	Check!LogFile;				! skip :LogFile if any;
    end;
end;


Simple Boolean Procedure CommandMode;
return( calli( !Xwd( Frame[MyJob],!gtSTS ), calli!GETTAB ) geq 0 );

Simple Procedure FrmXct( Integer Frame, Arg, Funct );
begin!code
	Hrrz	1,Frame;		! Get frame number from array ;
	Trz	1,'770000;		! Clear high order handle bits ;
	Hrl	1,Funct;		! Get function ;
	Move	2,Arg;			! Get argument ;
	Setom	!skip!;			! Set skip return ;
	uuo!FRMOP  1,2;			! Halt frame ;
	  Setzm	!skip!;			! OOPS! too bad ;
end;


procedure ESCAPE;
begin "Escape"

    if ( CommandMode )				! if command mode ;
     then ClrFlg( NeedEscape, MyJob )		!  clear escape   ;
     else begin "halt frame"
	DEFINE !FOSTP = '41;
	FrmXct( Frame[MyJob], 0, !foSTP );	! stop the frame  ;
	SetFlg( NeedEscape, MyJob );		!  set NeedEscape ;
     end "halt frame";

    SYNC;

end "Escape";


Simple Procedure GOTO (string CMD);
if ( IChan[MyJob] > 0 )
 then begin "GOTO COMMAND"
    string S, SS, ST;
    integer Where;

    S _ "::" & (ST_ Tok( CMD ));		! Define label = ::name ;
    SS_ ST & ":";				!  also label = name: ;

    do begin "scanning file"

	LineNo[MyJob] _ LineNo[MyJob] + 1;	! Count source file lines;
	ST _ null;				! Initially nothing there;
	Where_ VMGetC( IChan[MyJob] );		! Remember start point ;

	Do ST_ ST & VMLine( IChan[MyJob], Brk )	! Read a line of the file;
	 until ( BRK = #lf ) or ( Brk = 0 );

	if Kequ( S, ST ) or Kequ( SS, ST )	! Compare S and SS to ST ;
	  or Kequ( SS_ SS & ":", ST )		!  also allow :: at end ;
	 then begin "got label"
	    VMSetC( IChan[MyJob], Where );	! Reset to start of line ;
	    return;				! If match, then "found";
	 end "got label"
	 else if ( OChan[MyJob] > 0 )		! Else put into log file ;
	       then VMText( OChan[MyJob], ST & Crlf );

     end "scanning file" until ( Brk = 0 );

    Fatal("end of file while scanning for label """&S&"""");

end "GOTO COMMAND";


Simple Procedure BackTo (string CMD);
if ( IChan[MyJob] > 0 )
 then begin "BACKTO COMMAND"

    VMSetC( IChan[MyJob], 0 );			! Reset to beginning of file;
    LineNo[MyJob]_ 0;
    GOTO( CMD );

end "BACKTO COMMAND";



procedure PARAMETERS(String CMD);
begin "PARAMETERS COMMAND"
    string Key, Par!Default, Par!Value;    String Itemvar SI;

    SetFlg( DoParam, MyJob );				! Set flag true;
    Par!List[MyJob] _ Lop( Par!!List[MyJob] );		! Get ordered list;
    While Length(CMD)
     do begin "scanning parameter names"
	Key _ Get!Token(CMD);				! Name;
	Par!Default _ If Brk = "=" or Brk = "_"		! Parameter or null;
	    then Get!Token(CMD)
	    else Null;
	If Length( Datum(Par!List[MyJob]) )		! If any in list;
	 then begin
	    SI _ Lop( Datum(Par!List[MyJob]) );		! Get Item;
	    Par!Value _ Datum( SI );			! Get string value;
	    Delete( SI );				! No longer needed;
	 end
	 else Par!Value _ Null;				! Get null value;
	New!Parameter(IChan[MyJob], Key, Par!Default, Par!Value );
     end "scanning parameter names";
    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! Restore list;
end "PARAMETERS COMMAND";


simple procedure QUIT;
SetFlg( STOP!, MyJob );

procedure SEND (string CMD);
begin	"SEND"
    string KW;
    KW _ Get!Token(CMD);
    If ( quoted )
     then KW _ Brk&KW&Brk;		! restore quoted string;
    Ifcr PRELIMINARY thenc
	Print("SEND ",KW," ");
    endc
    If Kequ(KW,"CHARACTER") then begin
	Ifcr PRELIMINARY thenc
	    integer K;
	    K _ Cvo(CMD);
	    Print("'",Cvos(K),crlf);
	    auxclv(PORT[MyJob],K,!axO8);
	elsec
	    auxclv(PORT[MyJob],Cvo(CMD),!axO8);
	endc
    end
    else if Kequ(KW,"STRING") then begin
	Ifcr PRELIMINARY thenc
	    KW _ Get!Token(CMD);
	    Print("""",KW,"""",crlf);
	    Outptr( Port[MyJob], KW );
	elsec
	    Outptr( Port[MyJob], Get!Token(CMD) );
	endc
    end
    else if Kequ(KW,"FILE") then begin "SEND FILE"
	String Name, Dev, L;  Integer LastBrk;
	Boolean Ext!Found, File!Error, Eof;

	Name _ GetFil(CMD, Dev, Ext!Found, File!Error);
	If ( File!Error )
	  then Fatal( "SEND FILE - File error: "&Name )
	  else begin "good filename"
	    IChan[MyJob] _ VMFile( Name ) & IChan[MyJob];
	    if ( IChan[MyJob] < 0 )
	      then Fatal( "SEND FILE - File error: "&Name )
	      else While not( Eof )
	       do begin "transmit file"
		  L_ VMLine( IChan[MyJob], Brk );
		  L_ L & (If VMGetC( IChan[MyJob],VM$ECR )
			   then #cr else if Brk then Brk&Null else "");
		  If length( L ) or ( Brk )
		   then begin "got line"
		      if not( length( Buffer[MyJob] ) )
		       then Outptr( Port[MyJob], L );
		      Buffer[MyJob]_ Buffer[MyJob] & L;
		   end "got line";
		  EOF_ Brk = 0;
	      end  "transmit file";
	    Scan( Buffer[MyJob], B!Cr, Brk );	! trim first time away ;
	  end "good filename"
    end "SEND FILE"
    else Fatal( "illegal SEND command: "&CMD );
end;


simple procedure STOP;
SetFlg( STOP!, MyJob );

procedure TIME (string CMD);
SetTimeLimit( cvd( Tok(CMD) ) );	! Time in minutes;


recursive procedure COMMAND (string CMD);
begin	"COMMAND"
    string KW;  integer Index;
    lop(CMD);				! Eat first char (colon,dot,dash) ;
    KW _ Get!Token(CMD);		! Get first token;
    Ifcr PRELIMINARY thenc Print("Cmd: ",KW," >> ",CMD,crlf); endc
    if ( Brk = "=" )
     then begin "fake define"
	CMD_ KW & Brk & CMD;
	KW_ "DEFINE";
	BRK_ " ";
     end "fake define";

  redefine XC(Text,Action) = {
    ifcr length( Cvps( Text ) )
     thenc
      ifc length( Cvps( Action ) )
       thenc  Action;
       elsec  begin end;
      endc
    endc
  };

    if ( KW = ":" )
     then				! ignore label here;	! Defer;
     else if ( Length(KW) )
	   then begin "my commands"
	      Case ( Index_ FndKey( KW, Commands ) + 1 ) of begin
		  Fatal( "Ambigious XEXEC command: "& KW );
		  Fatal( "Unknown XEXEC command: "& KW );
		  AllCommands
	      end;
	   end "my commands";

end	"COMMAND";


Simple Boolean Procedure NextRecord;
begin "next record"

    arrclr( Rec );			! clear record fields ;

    if ( NTQ! )				! if ( ^C or Notice-to-quit ) ;
     then return( false );		!  just return immediately ;

    dpb( Seq, PPSeq( Rec ) );		! set sequence number to select ;
    return( GetRec( Rec[E!Runtime] ) );	! oh, get on with it ;

end "next record";


Procedure SortQueue;
begin "sort queue"
    Integer ASeq;

    Seq_ 0;					! loop through them all ;

    ASeq_ ldb( PPSeq(Rec) );			! remember this a while ;

    njob_ active;				! begin at top of list  ;
    while ( njob_ job:Nxt[tjob_njob] )		!  until the empty list ;
     do if ( job:Seq[njob] = ASeq )		! if same record ;
	 then return;				!  then try again later ;

    njob_ passive;				! begin at top of list  ;
    while ( njob_ job:Nxt[tjob_njob] )		!  until the empty list ;
     do begin "new passive job"
	if ( Ldb(PPSeq(Rec)) = job:Seq[njob] )	!  if matching sequence ;
	 then return;				!   then no repeaters   ;
	if ( Rec[E!Runtime] < job:Run[njob] )	!  if runtime < job:Run ;
	 then done;				!   then fall to insert ;
     end "new passive job";

    tjob_ job:Nxt[tjob]_ new!record( job );	! create the new record ;
    job:Nxt[tjob]_ njob;			! keep any forward ptrs ;
    job:Opt[tjob]_ Rec[E!Action];		! copy all action flags ;
    job:Run[tjob]_ Rec[E!Runtime];		! copy runtime  & seq # ;
    job:Seq[tjob]_ ASeq;

  Ifcr PRELIMINARY thenc
    Print( "Addrec ",ASeq," at ", TymDay( Rec[E!Runtime] ), crlf );
  endc

end "sort queue";


Simple Integer Procedure SlotsAvailable;
begin "slots available"
    Own r!p (job) ajob;

    If not( active )			! if nothing specified, ;
     then active_ new!record(job);	! initialize queue list ;

    If not( passive )			! if nothing specified, ;
     then passive_ new!record( job );	! initialize queue list ;
    Seq_ -1;				! initialize sequencer  ;

    ! *** If ( LastSched neq ThisSched ) then  *** ;
    ! *** SetSch( LastSched_ now );		! specify last schedule ;
    While ( NextRecord )		! while records exist   ;
     do SortQueue;			!  sort/insert in list  ;

    For MyJob_ 1 upto JobMax		! for each slot ;
     do if not( Frame[ MyJob ] )	! if a frame # is not assigned ;
	 then done;			!  we have a chance ;
    if ( Frame[ MyJob ] )		! double check we didn't miss ;
     then return( 0 );			!  oops, must have overflowed ;
    HighJob_ HighJob max MyJob;		! keep track of highest slot used ;

    njob_ passive;			! begin with top of queue ;
    while ( njob_ job:Nxt[tjob_njob] )	! for each record ;
     do begin "process queue"

  Ifcr PRELIMINARY thenc
    Print( " * Try ", job:Seq[njob]," Run: ", TymDay( job:Run[njob] ), crlf );
  endc

	if ( NTQ! )			! if ( ^C or Notice-to-quit ) ;
	 then return( 0 );		!  just go home now... ;

	! ********************************************* ;
	! *** Put in all the use-me/avail code here *** ;
	! ********************************************* ;

	job:Nxt[tjob]_ job:Nxt[njob];	! delete NJOB record from list ;

	tjob_ active;			! ready to insert in active list ;

	while ( tjob_ job:Nxt[ajob_tjob] )	!  until the empty list ;
	 do if ( job:Run[njob]<job:Run[tjob] )	!  if runtime < job:Run ;
	     then done;				!   then fall to insert ;

	job:Nxt[njob]_ tjob;		! copy the current record pointer ;
	job:Nxt[ajob]_ njob;		! and insert this in active list ;

	return( job:Seq[njob] );	! return this record number ;

     end "process queue";

    return( 0 );			! nothing there to do ;

end "slots available";


Simple String Procedure JobStatus;
begin "job status"
    string str;

    Str_ Complete;
    if ( TIM! land (1 lsh MyJob) )
     then Str_ "aborted - timeout at line "& cvs(LineNo[MyJob]);
    if ( NTQ! land (1 lsh MyJob) )
     then Str_ "aborted - halted by operator at line "& cvs(LineNo[MyJob]);
    if ( (ZAP! land lnot NeedZap) land (1 lsh MyJob) )
     then Str_ "abended - lost circuit to slave at line "& cvs(LineNo[MyJob]);
    if ( STOP! land (1 lsh MyJob) )
     then Str_ "aborted - :STOP at line "& cvs(LineNo[MyJob]);
    if ( ERR! land (1 lsh MyJob) )
     then Str_ "aborted - ERROR( "& Error!Text &" ) at line "& cvs(LineNo[MyJob]);
    if ( TRU! land (1 lsh MyJob) )
     then Str_ "aborted - TRU limit exceeded at line "& cvs(LineNo[MyJob]);
    if ( LOS! land (1 lsh MyJob) )
     then Str_ Str & " [check for data lossage]";

    return( Str );

end "job status";


Simple Procedure Do!Cleanup;
begin "do cleanup"

    Disposition_ JobStatus;		! get job disposition ;
    Seq_ MySeq[MyJob];			! get sequence number ;
    If not( NextRecord )		!     and user record ;
     then begin "we're gone, fake it"	! not there? oops! ;
     end "we're gone, fake it";

!	send mail if indicated - inform user of disposition;

    if ( DoMail land (1 lsh MyJob) )
     then begin "sending mail"			! send mail ?;

	Buffer[MyJob]_
	    "To: "& MyName[MyJob] & crlf &
	    "From: XEXEC-Mailer " &
		    (If ( Ldb( PPMPrg(Rec) ) )	! if non-zero mailer;
		      then "(TUMS)"
		      else "(RPG)"   ) & crlf &
	    "Re: Job #" & cvs(MyJob) & " " & cv6str( Rec[E!CmdFile+F!Name] ) &
		" " & disposition & "." & crlf & crlf &
	    "; " &cv6str(calli(!xwd(-1,!GTNAM),calli!GETTAB))&
		" v"&Cvos(!lh(memory['137]))&"."&Cvos(!rh(memory['137])) &
		" - processed: "&
		(If MakeLog[MyJob] then LogFile[MyJob]&" = " else "") &
		CmdFile[MyJob]& crlf &		! Command file?;
	    "; Options: "& crlf &
	    "; Limits: "&
		"Time "  & cvs( Ldb( PPTimL(Rec) ) ) &
		" TRUs " & cvs( Rec[E!TruLim] ) & " " & crlf &
	    "; Status: " & disposition & "." & crlf;

	If ( MakeLog[MyJob] )
	 then Buffer[MyJob]_ Buffer[MyJob] &
	    "; Output recorded in file " & LogFile[MyJob] & "." &
		(If ( LogDisp[MyJob] = JD$DELETE ) or
		    ( LogDisp[MyJob] = JD$ERROR and Kequ(Disposition,Complete) )
		 then "  (LogFile[MyJob] Deleted.)" else "") & crlf & crlf;

    end "sending mail";

  ifcr PRELIMINARY thenc
    Print( "*** Job #",MyJob," ***"& crlf&crlf, Buffer[MyJob] );
  endc

    If ( MakeLog[MyJob] )
     then VMText( OChan[MyJob], Buffer[MyJob] );

    Buffer[MyJob]_ Null;

    If MakeLog[MyJob] and (
	( LogDisp[MyJob] = JD$DELETE ) or
	( LogDisp[MyJob] = JD$ERROR and Kequ(Disposition,Complete) ) )
     then VMFree( OChan[MyJob], -1 )	! delete the log-file ;
     else VMFree( OChan[MyJob] );	! or simply close it ;

    ClearFrame( MyJob );		! make it go away for real ;

end "do cleanup";

Simple procedure ClearFile;
begin "clear file"

    if ( length( IChan[ MyJob ] ) )	! anything left to do? ;
     then begin "are we done"

	Forget!Substitutions;		! clear current substitutions;

	VMFree( IChan[ MyJob ] );	! Free the channel ;

	if ( 1 = length(IChan[MyJob]) ) or ( ERR! land (1 lsh Myjob) )
	 then begin "clear slot"	! last eof or error ;

	    Escape;			! put into command mode ;
	    if ( Port[MyJob] )		! if port, send LOGOUT string ;
	     then Buffer[MyJob]_ "LOGOUT" & #cr
	     else begin
		! Kill-frame one way or another ;
	     end;			
	    SetFlg( NeedZap, MyJob );	! get ready for the end ;

	 end "clear slot";

	lop( IChan[ MyJob ] );		! clear out the channel and ;
	lop( LineNo[ MyJob ] );		!  the line # for this file ;
	lop( Delim!list[ MyJob ] );	! lop off the last delimiter;

	if ( Delim!list[MyJob] neq Del!Chr[MyJob] )	! if mangled, then ;
	 then Set!Delimiter( Delim!list[MyJob] );	! reset from stack ;

     end "are we done";

 end "clear file";


Simple Procedure PortLine;
begin "port line"
    Own Integer Chan, MyLen, MyPtr;
    String Line;
    Define LineLen = 64 * 5;		! constant length = 320 ;

    Line_ "################################################################" &
	  "################################################################" &
	  "################################################################" &
	  "################################################################" &
	  "################################################################";

    Chan_ Ochan[MyJob];			! setup channel variable ;

ifcr PRELIMINARY thenc
    Print( "TTY",cvos(Port[MyJob]),": " );
endc
    begin!code

	Label Loop, NoMore;
	Define ax = '13, ch = '14, ct = '15;

	Move	ax,Line;		! copy string pointer ;
	Movem	ax,MyPtr;		! save it for use ;
	Move	ax,MyJob;		! get job index ;
	Hrlz	ax,Port[0](ax);		! get port ;
	Hrri	ax,!axi8s;		! set to image mode skip ;
	Setzm	MyLen;			! start with null string ;
Loop:	Auxcal	ax,ch;			! get a character ;
	  Jrst	NoMore;			! no more ;
	Jumpe	ch,Loop;		! ignore nulls ;
	Skipn	Chan;			! if no channel open ;
	  Jrst	Loop;			! throw characters away ;
	Idpb	ch,MyPtr;		! deposit character ;
	Aos	ct,MyLen;		! count characters ;
	Caige	ct,LineLen;		! enough room? ;
	  Jrst	Loop;			! yes, go back for next ;
NoMore:
     end;				! end begin!code ;

    VMText( Chan, Line[1 for MyLen] );	! put text into file ;

    if ( MyLen neq LineLen )		! if no overflow, then ;
     then ClrFlg( CHR!, MyJob );	! clear BRK seen flag ;

ifcr PRELIMINARY thenc
    print( Line[1 for MyLen] );
endc
	
end "port line";


Simple Boolean Procedure OneLine;
begin "one line"
    string S, C;
    integer Brk,Cmd;

    If ( NeedEscape land (1 lsh MyJob) )	! Are we waiting for ESC? ;
     then begin "wait till next time"
	Escape;					! Do escape procedure ;
	return( true );				!  and come back later ;
     end "wait till next time";

    If ( length( Buffer[MyJob] ) )		! Do we have any leftovers? ;
     then begin "process leftovers"
	S_ Scan( Buffer[MyJob], B!Cr, Brk );	! Get one line from buffer ;
	OutPtr( Port[MyJob], S );		!  and send it along ;
	ClrFlg( ORG!, MyJob );			!  clear data flag ;
	return( true );				!  then return ;
     end "process leftovers";

    S_ VMLine( IChan[MyJob], Brk );		! Read first line of file;

    If ( VMGetC(IChan[MyJob], VM$ECR) )		! Was there a crlf? ;
     then C_ #Cr				!  yes, so make a string ;
     else C_ Null;				!  no,  make it empty ;

    if ( Length( S ) or Brk )			! End of File? If no line;
     then begin "got line"

	LineNo[MyJob]_ Lop( LineNo[MyJob] ) + 1 & LineNo[MyJob];

	If ( DoParam land (1 lsh MyJob) )	! if substitutions enabled ;
	 then S_ Parametize(S);			!  then parametize the line ;

    ifcr PRELIMINARY thenc
	print( "Stream #",Myjob,": ",S,crlf );
    endc
	Cmd_ true;				! default is a command ;

	if ( S = ":" )				! if "known-command" ;
	 then Command(S)			!  then process as a command ;
	 else if ( S = "." or S = "-" )		!  else check for want command ;
	     then if ( ChkCommand(S) )		!    then if a legal command ;
		 then Command(S)		!       then process a command ;
		 else begin "an escape"
		    ESCAPE;			! put into exec and ;
		    Cmd_ false;			!  clear command flag ;
		    Lop( S );			!  and remove esc flag ;
		 end "an escape"
	     else if ( S = "=" or S = "*" )
		 then begin "user mode"
		    If not( CommandMode )	! if at user level then ;
		     then Cmd_ false;		! clear command flag ;
		    If ( Lop( S ) = "=" )	! throw away char & compare ;
		     then C_ Null;		! use either Null or CR ;
		 end "user mode"		! don't forget labels:: ;
		 else Cmd_ false;

	if not( Cmd )
	 then begin "user data"
	    OutPtr( Port[MyJob], S&C );		! if data send it to the job ;
	    ClrFlg( ORG!, MyJob );		! clear data flag ;
	    return( true );			! and return ;
	 end "user data";

	return( not( (STOP! lor ERR! lor TRU!) land (1 lsh MyJob) ) );

     end "got line"
     else return( false );			! no line -- eof reached ;

end "one line";


Simple Procedure FileLine;
begin "each line"

    if ( Frame[MyJob] )			! if active frame ;
     then if ( OneLine )		! check for data to job ;
	   then				! all is ok, nothing more to do ;
	   else ClearFile		! if end, clear file and go on. ;
     else;				! log line to nonexistant frame ;

 end "each line";


Internal Simple Procedure GetInt( reference integer Flag; integer Why );
begin "get int"
    Own safe integer array Ports[ -1 : JobMax ];
    Own Integer Idx, MyP, MyJ;

    Arrclr( Ports );			! initialize data structure ;
    Ports[-1]_ JobMax + 1;		! specify length of list ;
    Idx_ Calli( Why + location(Ports[-1]), calli!POLPRT );
    if not( !Skip! )			! if cannot read ports list ;
     then return;			!  then ignore interrupt ;

    While ( 0 leq Idx_ Idx - 1 )	! for each possible port ;
     do if ( Ports[Idx] land Why )	! if condition set ;
	 then begin "find job port"

	    MyP_ !rh( Ports[Idx] );	! make it just a port ;

	    For MyJ_ 1 upto HighJob	! for each active job ;
	     do if ( Port[MyJ] = MyP )	! if the port matches ;
		 then begin "found one"
		    SetFlg( Flag,MyJ );	!  flag the port ;
		    done;		!  and finish loop ;
		 end "found one";

	 end "find job port";		! either port found or ignored ;

end "get int";


!	M A I N   program
;

IntIni;					! initialize my interrupts ;

While not( NTQ! )			! while it's ok to proceed ;
 do begin "the system is running"
    ifcr PRELIMINARY thenc
      if ( LOS! lor CHR! lor ORG! lor ZAP! )
       then print( "L:",cvos(LOS!), " C:",cvos(CHR!),
		  " O:",cvos(ORG!), " Z:",cvos(ZAP!), crlf );
    endc

    DoIf ( CHR!, JobMax )		! if *any* output is available ;
     then PortLine;			! read any data lines available ;

    DoIf ( ZAP!, JobMax )		! if *any* circuit zaps seen ;
     then begin "finish job"

	ClrFlg( ZAP!, MyJob );		! clear zap flag ;
	Port[ MyJob ]_ 0;		! clear port for clearframe ;

	if ( Frame[ MyJob ] )		! if active ;
	 then begin "cleanup job"
	    Do!CleanUp;			!   do mail, close files ;
	    ActiveCount_ ActiveCount-1;	!   lower count ;
	 end "cleanup job";

     end "finish job";

    If ( ActiveCount )			! any active slots? ;
     then begin "move some data"

	DoIf ( ORG!, HighJob )		! if *any* input requested ;
	 then FileLine;			! read any file lines available ;

     end "move some data"
     else if ( NTQ! )
	  then done;

    If ( NTQ! )				! if notice received ;
     then begin "kill jobs"		!  start genocide process ;
	! be nice and EVICT them first ;
	! remember we've evicted them and if no response after 1 minute ;
	! then kill them... try using a counter in lh when 0, zap! ;
	! initialize it to -1? ;
     end "kill jobs";

    While ( Seq_ SlotsAvailable )	! if any slots are available ;
     do begin "check availability"

	If ( NTQ! )			! if ( ^C or Notice-to-quit ) ;
	 then done;			!  just return immediately ;

	If ( NextRecord )		! got this record ;
	 then if ( FrontEnd )		! setup user and keep track ;
	       then ActiveCount_ ActiveCount + 1;

     end "check availability";

    calli( 1, calli!SLEEP );		! sleep for awhile (1 sec) ;
    ifcr PRELIMINARY thenc
	print( "|" );
    endc

 end "the system is running";

ClsQue;
!	Logoff;

end 	"XEXEC" $

   S@(H