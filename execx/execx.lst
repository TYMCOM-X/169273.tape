EXECX.SAI                       created 09-Apr-87 15:43                                  Page 1
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1	begin	"EXECX"
2	
3	require "EXECX.INF" source!file;
4	
5	Define EXECX!VERSION = (EXECX!!VER lsh 24) lor EXECX!!EDIT;
6	require EXECX!VERSION version;
7	
8	require "
9	
10	EXECX %"&CVOS(EXECX!VERSION lsh -24)&"("&CVOS(EXECX!VERSION land '777777)&")"&
11	     " - TYMCOM-X Periodic Processing Exec
12	
13	Assembly: Load @EXECX.CMD
14	
15	Sources:  EXECX.SAI                 Main program source file
16	          EXECX.INF                 Main release information file
17	          XEXEC.PAR                 Main parameter file
18		  XEXEC.REQ                 Global declaration file
19	          SAIL.DEF                  General macro definition file
20	          UUOSYM.DEF                System call definition file
21	          JQUEUE.DEF                Job queue definition file
22	
23	Library:  XEXSUB.REQ [SAI] [REL]    Main support routines
24	          JQUE.REQ   [SAI] [REL]    Job queue manipulation package
25	          XEXPKG.REQ [SAI] [REL]    Miscellaneous support package
26	          VMFILE.REQ [SAI] [REL]    VM input file mapping pacakge
27	          DAYTIM.REQ [SAI] [REL]    Date time conversion package
28	          XEXINT.REQ [SAI] [REL]    Interrupt package
29	
30	License:  ALL license bits!!!
31	          WC RC SY OP GD TD ST JL AC XC HF RA WA
32	
33	" message;
34	
35	require "(SAILIB)SAIL.DEF"  source!file;
36	require "(EXECX)XEXEC.PAR"  source!file;
37	require "(MPL)UUOSYM.DEF"   source!file;
38	
39	require "(EXECX)JQUEUE.DEF" source!file;
40	require "(EXECX)JQUE.REQ"   source!file;
41	require "(EXECX)XEXSUB.REQ" source!file;
42	require "(EXECX)XEXPKG.REQ" source!file;
43	require "(EXECX)XEXINT.REQ" source!file;
44	
45	require "(CARL)VMFILE.REQ"  source!file;
46	require "(CARL)DAYTIM.REQ"  source!file;
47	
48	require 10000 new!items,  pnames;
49	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 2
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

50	!	Definitions
51	;
52	
53	Define VersionString = { "%"&CVOS(EXECX!VERSION lsh -24) &
54				 "("&CVOS(EXECX!VERSION land '777777)&")" };
55	Define !gtRDV = '135, !gtRDI = '136, !gtRFN = '137;
56	
57	Define Rec(x) = { memory[ASlot+(x)] };	! record element ;
58	Define Sleep!Time = !Xwd(1,3);		! sleep period between lines;
59	Define Minute = 60;			! seconds in a minute ;
60	
61	Define Complete = {"completed"};! successful completion;
62	Define Default!Ext = {".CTL"};	! default command file extension;
63	Define Uppercase(x) = {Scan(x, B!Up, Dummy)};
64	Define White(x) = {Scan(x, B!Wht, Brk)};
65	
66	Define !Job(x)     = { ( (x) land '7777 ) };
67	Define Cvj(x)      = { cvs( !Job(x) ) };
68	Define Gettab(x,y) = { calli( !xwd( (x), (y) ), calli!GETTAB ) };
69	Define SetFlg(x)   = { x_ x lor MyBit };
70	Define ClrFlg(x)   = { x_ x land NoBit };
71	Define NewLic(x,y) = { ( ((x lor y) land '777717777700)  lor
72				 ((x land  '3) max (y land  '3)) lor
73				 ((x land '14) max (y land '14)) ) };
74	
75	Define DayStamp  = { cvSDat( !lh( GetTDT ) ) };		! day  only ;
76	Define TimeStamp = { cvSTim( !rh( GetTDT ) ) };		! time only ;
77	Define DateStamp = { TymDay( GetTDT ) };		! date-time ;
78	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 3
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

79	!	Command macro definitions
80	;
81	
82	Define KQ(x,y) = 		     {	Kequ(x,CvPS(y))
83	    ifcr length( CvPS(y) ) > 3 thenc or Kequ(x,CvPS(y)[1 for 3]) endc
84		};
85	
86	
87	Define AllCommands = {
88	    XC(AFTER)
89	    XC(BACKTO,    BACKTO(CMD))
90	    XC(BACK,      BACKTO(CMD))
91	    XC(CHECKPOINT,CHECKPOINT(CMD))
92	    XC(CHKPNT,    CHECKPOINT(CMD))
93	    XC(COM,       COM(CMD))
94	    XC(CONTINUE)
95	    XC(DEFINE,    REASSIGN(CMD))
96	    XC(ERROR,     SETERROR(CMD,true))
97	    XC(ESCAPE,    ESCAPE)
98	    XC(FIND)
99	    XC(GOTO,      GOTO(CMD))
100	    XC(GO,        GOTO(CMD))
101	    XC(IF)
102	    XC(LOOK)
103	    XC(LOGFILE)
104	    XC(NOERROR,   SETERROR(CMD,false))
105	    XC(PAUSE)
106	    XC(PARAMETERS,PARAMETERS(CMD))
107	    XC(QUIT,      QUIT)
108	    XC(REMARK)
109	    XC(RESTART)
110	    XC(REVIVE,    SILENCE(false))
111	    XC(SEND,      SEND(CMD))
112	    XC(SILENCE,   SILENCE(true))
113	    XC(STOP,      STOP)
114	    XC(TIMELIMIT, TIME(CMD))
115	    XC(TRULIMIT,  TRULIMIT(CMD))
116	    XC(UNLESS)
117	    XC(WAIT)
118	  };
119	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 4
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

120	!	Variable definitions for outer block;
121	
122	Internal integer
123		MyBit			! always 1 lsh myjob ;
124	,	MyJob			! current job slot ;
125	,	NoBit			! always lnot 1 lsh myjob ;
126	,	XEXJob			! processor job slot ;
127	;
128	
129	boolean
130		ERR!, STOP!		! true when error occurrs or we stop;
131	,	TRU!			! true when the tru limit is exceeded;
132	,	ALabel			! true when a label is seen on this line ;
133	,	OverTime		! true when time limit exceeded;
134	,	NeedBall		! true when a command is waiting;
135	,	NeedEscape		! true when waiting for command mode;
136	,	NeedExit		! true when waiting for exit in child;
137	,	NeedZap			! true when waiting for zapper on job;
138	,	Quoted			! true if parameter is quoted [Get!Token];
139	,	DoParam			! true if $Substitutions;
140	,	DoNumerics		! true if $Numerics;
141	,	DoLog			! true if $Logging;
142	,	DoError			! true if $Error (error seen);
143	;
144	
145	own integer 
146		Club			! club interlock variable ;
147	,	HighJob			! highest stream in use ;
148	,	Minutes			! how many minutes we've been here ;
149	,	Status			! current status of active stream;
150	;
151	
152	string	S, Disposition		! temp and completion variables;
153	,	Error!Text		! reason for error;
154	;
155	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 5
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

156	!	Array definitions
157	;
158	
159	  redefine CommandsLength = 0;
160	  redefine seperatorcharacter = {,};
161	  redefine XC(Text,Action) = {
162	    ifcr length( Cvps( Text ) ) thenc
163	      ifcr CommandsLength > 0 thenc seperatorcharacter endc
164	      redefine CommandsLength = CommandsLength + 1;
165	      Cvps( Text )
166	    endc
167	  };
168	Preset!with AllCommands;
169	Own safe string  array Commands[ 1 : CommandsLength ];
170	
171	Preset!with  JM$$Str;
172	Safe String  Array JM$$Nam[ 0:JM$$Knt-1 ];
173	Preset!with  JD$$Str;
174	Safe String  Array JD$$Nam[ 0:JD$$Knt-1 ];
175	Preset!with  JF$$Str;
176	Safe String  Array JF$$Nam[ 0:JF$$Knt-1 ];
177	
178	Own safe integer array OChan  [ 0 : E!JobMax ];	! Logfile channel ;
179	Own safe integer array PORT   [ 0 : E!JobMax ];	! port used for child i/o ;
180	Own safe integer array Zone   [ 0 : E!JobMax ];	! time zone for child ;
181	
182	Own safe string  array Delim!list[0:E!JobMax ];	! stack of delimiter chars ;
183	Own safe string  array Del!Chr[ 0 : E!JobMax ];	! delimiter character ;
184	Own safe string  array ErrChr [ 0 : E!JobMax ];	! error character ;
185	Own safe string  array ChrPos [ 0 : E!JobMax ];	! character position on line ;
186	Own safe string  array Buffer [ 0 : E!JobMax ];	! additional lines ;
187	Own safe string  array IChan  [ 0 : E!JobMax ];	! stack of nested input files ;
188	Own safe string  array LineNo [ 0 : E!JobMax ];	! input  file line number ;
189	
190	Safe list array Par!!List[0:E!JobMax ];		! List of ordered parameters ;
191	Safe list array Par!!Set[ 0:E!JobMax ];		! Lists of named parameters;
192	Safe list itemvar array Par!List[ 0:E!JobMax ];	! List of Ordered parameters;
193	Safe set  itemvar array Par!Set[ 0:E!JobMax ];	! Set of Named parameters;
194	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 6
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

195	!	System variable definitions - currently defined
196	;
197	
198	string	Item
199		$Daytime		! Current time-of-day;
200	,	$Hour,$Minute,$Second	! Current time-of-day pieces;
201	,	$HH,$SS			! Current time-of-day pieces;
202	,	$HHMMSS,$HHMM,$MMSS	! Current time-of-day combinations;
203	,	$Date			! Current date dd-mmm-yy;
204	,	$Day,$Month,$Year	! Current day(dd),month(month),year(yyyy);
205	,	$Mon			! Current month(mmm);
206	,	$DD,$MM,$YY		! Current day(dd),month(mm),year(yy);
207	,	$Weekday		! Day of week, Sunday---Saturday;
208	,	$Yesterday,$Tomorrow	! Day of week, Sunday---Saturday;
209	,	$Delimiter		! Delimiter variable;
210	,	$Directory		! Current GFD directory;
211	,	$UserName		! Logged in username;
212	;
213	
214	boolean	Item
215		$Error			! :ERROR character seen flag;
216	,	$False			! FALSE value;
217	,	$Logging		! Logging variable;
218	,	$Substitution		! Substitution variable;
219	,	$Mail			! Mail variable;
220	,	$Format			! Format variable;
221	,	$Numerics		! Numeric results variable;
222	,	$True;			! TRUE value;
223	
224	integer	Item
225		$TimeLimit		! Current Time Limit variable;
226	,	$TruLimit;		! Current TRU limit variable;
227	
228	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 7
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

229	!	Support routines
230	;
231	
232	Procedure Forget!substitutions;
233	begin
234	    String Itemvar SI;
235	
236	    If Length( Par!!List[MyJob] ) or Length( Par!!Set[MyJob] )
237	     then Logit( QFet$Subs lor QFet$Items, "Stream #"&cvs(MyJob)&" Forget: " );
238	
239	    If Length( Par!!List[MyJob] )
240	     then begin "zap list by 1"
241		Par!List[MyJob] _ Lop( Par!!List[MyJob] );
242		While Length( Datum(Par!List[MyJob]) )
243		 do begin "ordered"
244		    SI _ Lop( Datum(Par!List[MyJob]) );
245		    Logit( QFet$Subs lor QFet$Items, " ${"& Datum(SI) &"}" );
246		    Delete( SI );
247		 end "ordered";
248		Delete( Par!List[MyJob] );
249	     end "zap list by 1";
250	    If Length( Par!!Set[MyJob] )
251	     then begin "zap set by 1"
252		Par!Set[MyJob] _ Lop( Par!!Set[MyJob] );
253		While Length( Datum(Par!Set[MyJob]) )
254		 do begin "named"
255		    SI _ Lop( Datum(Par!Set[MyJob]) );
256			begin
257			    String PN; Integer Dummy;
258			    PN _ Cvis( SI, dummy );
259			    If PN < " " then PN _ "<"&CVOS(LOP(PN))&">" & PN;
260			    Logit( QFet$Subs lor QFet$Items,
261				  " "& PN &"{"& Datum(SI) &"}"  );
262			end;
263		    Del!Pname( SI );
264		    Delete( SI );
265		 end "named";
266		Delete( Par!Set[MyJob] );
267	     end "zap set by 1";
268	
269	end;
270	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 8
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

271	
272	simple procedure ClearFlags;
273	begin "clear flags"
274	
275	    forLC Arg_ (ECF!,ZAP!,ORG!,LOS!,CHR!,ERR!,STOP!,TRU!,
276			OverTime,NeedZap,NeedEscape,NeedExit,NeedBall,
277			DoParam,DoNumerics,DoLog,DoError)
278	     doC { Arg_ Arg land NoBit; }	! and clear out these flags ;
279	     endc
280	
281	end "clear flags";
282	
283	
284	
285	Simple Boolean Procedure ClearFrame;
286	begin "clear frame"
287	    own integer That;
288	
289	    If ( Port[ MyJob ] )		! if there is a port ;
290	     then begin "zzzZap the port"
291	
292		PrtDis( Port[ MyJob ] );	! clear interrupts and zzzZap! ;
293		calli( Port[ MyJob ], calli!ZAPCIR );
294	
295	     end "zzzZap the port";
296	
297	    if ( That_ QQF )			! anything here? ;
298	     then begin "frame must die"
299	
300		EcfDis( That );			! make sure ECF is cleared ;
301	
302		if not( calli( !Xwd(1,That), calli!EVICT ) )
303		 then calli( !Xwd(3,That), calli!HANG );
304	
305		QQF_ 0;				! clear frame position ;
306	
307	     end "frame must die";
308	
309	    ClearFlags;				! clear out all the job flags ;
310	
311	    while ( length( Par!!List[MyJob] ) or length( Par!!Set[MyJob] ) )
312	     do Forget!Substitutions;		! clear out all item storage ;
313	
314	    while ( length( IChan[MyJob] ) )	! any input files open? ;
315	     do VMFree( lop( IChan[MyJob] ) );	!  then close them ;
316	
317	    if ( OChan[MyJob] > 0 )		! any log file open? ;
318	     then VMFree( OChan[MyJob] );	!  then close it ;
319	
320	    return( false );			! give 'em what they came for ;
321	
322	end "clear frame";
323	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 9
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

324	
325	Simple procedure EXIT( String Msg(Null) );
326	begin
327	
328	    EscDis;				! disable any interrrupts ;
329	    NtqDis;				! for ESC, NTQ ;
330	    SiaDis;				! and from frame ;
331	
332	    LogInfo( Msg );			! notify them we have gone ;
333	
334	    if ( InQue land que$Map )		! check for logoff flag ;
335	     then begin "last minute things"
336	
337		if ( XEXJob = !Job( QQ( Process ) ) and
338		     QQ( HaveP ) = Gettab( XEXJob,!gtUID ) )
339		 then QQ( HaveP )_ QQ( Process )_ 0;
340	
341		ClearFeature( Shut );
342	
343		QQ( Flags )_ QQ( Flags ) land
344			    lnot ( ( QF$Log lor QF$Act ) lsh 18 );
345	
346	     end "last minute things";
347	
348	    calli(queAct lsh -9, calli!CLBRLI);	! release interlock here ;
349	    calli(queAct lsh -9, calli!CLBLEV);	! leave club on ACT page ;
350	
351	    calli((queAct lsh -9)+1, calli!CLBRLI);
352	    calli((queAct lsh -9)+1, calli!CLBLEV);
353	    ClsQue;
354	
355	    if not( !lh( Gettab(-1,!gtLIN) ) )	! set logout on stop if detached ;
356	     then calli( !bit(0) lor Gettab( -1,!gtPRV ), calli!SETPRV );
357	
358	    start!code uuo!EXIT end;		! just exit ;
359	
360	end;
361	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 10
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

362	
363	
364	Simple procedure Deactivate;
365	begin
366	
367	    if not( QQ( Schedule ) )		! no scheduler?  Watch out! ;
368	     then QQ( Active )_ ( QQ( Active ) - 1 ) max 0;
369	
370	    if ( MyJob = HighJob )		! are we at the limit? ;
371	     then begin "lower limit"		! yes -- go down ;
372	
373		for MyJob_ HighJob downto 0	! from here to 0 ;
374		 do if ( QQS )			! if a valid record ;
375		     then done;			!  then stop ;
376	
377		HighJob swap MyJob;		! switch back ;
378	
379	     end "lower limit";
380	
381	end;
382	
383	
384	
385	Simple Boolean procedure JobExit( Integer Msg(0) );
386	begin
387	
388	    LogInfo( "Stream #"& cvs(MyJob) &
389		     " JobExit: "& cvos(Msg lsh -6) &","& cvos(Msg land '77) );
390	    If ( MyJob )			! if working on a job ;
391	     then begin "job exit"
392	
393		ClearFrame;			! send the frame away ;
394		Dpb( Msg, PStap( QQS ) );	! after recording error code ;
395		Deactivate;			! crank down activity ;
396	
397	     end "job exit";
398	
399	    return( false );
400	
401	end;
402	
403	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 11
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

404	!	Initialization routines;
405	
406	simple procedure WhoShouldIBe;
407	begin
408	    LogWho( "Processor" );
409	    XEXJob_ calli( 0,calli!PJOB );
410	end;
411	require WhoShouldIBe initialization;
412	
413	
414	simple procedure LicenseCheck;
415	begin
416	    integer X;
417	    Define LicNeeded = Ifcr PRELIMINARY thenc '775617 elsec '777617 endc ;
418	
419	    X_ !lh( Gettab( -1,!GTLIC ) );
420	    if ( LicNeeded land ( lnot X ) )
421	     then Exit( "Not enough license, Notify support group" );
422	end;
423	require LicenseCheck initialization;
424	
425	
426	procedure ParIni;
427	begin "parameter initialization"
428	    integer X;
429	
430	    ALabel_ DoParam_ False;		! Insure no label, no substitution;
431	    For X_ 0 upto E!JobMax
432	     do Delim!list[X]_ Del!Chr[X]_ "\";	! Default parameter escape;
433	    Setbreak( B!Quote_Getbreak,		! Initial breaktable for the;
434			"\", null, "SINF");	!    parametization delimiter;
435	    Arrclr( Par!!List );		! Empty channel/file list;
436	    Arrclr( Par!!Set );			! Empty parameter set;
437	end;
438	require ParIni initialization;
439	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 12
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

440	
441	simple procedure MyLog( string Msg );
442	if ( DoLog land MyBit )			! See if want logging ;
443	   and ( OChan[MyJob] )			!   and a log file open ;
444	 then VMText( OChan[MyJob], Msg );	! yes, output message ;
445	
446	
447	simple procedure DumpLog( string Msg );
448	MyLog( #HT& Msg );			! dump to log in standard format ;
449	
450	
451	simple boolean procedure Fatal(String Msg);
452	begin "fatal error"
453	
454	    if ( OChan[MyJob] > 0 )		! Else put into log file ;
455	     then VMText( OChan[MyJob], crlf & "?" & Msg &
456		(If LineNo[MyJob] > 0
457		  then " in line "&Cvs(LineNo[MyJob])
458		  else "" ) & crlf );
459	
460	    Error!Text _ Msg;			! set error message for log ;
461	    SetFlg( ERR! );			! make error in flag ;
462	
463	    return( false );			! go bye bye ;
464	
465	end "fatal error";
466	
467	
468	procedure SetTimeLimit( Integer TimeLimit );
469	begin
470	    own safe integer array Limit[0:2];
471	    define calli!DAYTIM = -'143;
472	
473	    if TimeLimit = 0
474	     then Limit[0]_ 0
475	     else begin "new limit"
476		Limit[0]_ Calli( '20,calli!DAYTIM ) + (60 * TimeLimit);
477		Limit[2]_ !xwd( '600020,'500020 );	! old=TYM-SEC,,new=TYM-UDT ;
478		calli( location(Limit[0]), calli!DATUUO );
479	     end "new limit";
480	
481	    QQT_ Limit[0];
482	
483	end;
484	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 13
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

485	
486	procedure Set!Delimiter( String Character );begin
488	
489	    Del!Chr[MyJob] _ Tok(Character)[1 for 1];	! one character width;
490	
491	    If Del!Chr[MyJob] = 0			! default to "\";
492	     then Del!Chr[MyJob]_ "\";			! change the delimiter list;
493	
494	    Delim!list[MyJob]_Del!Chr[MyJob]&Delim!list[MyJob][2 to INF];
495	
496	  Logit( QFet$Subs," SetDelim("&Del!Chr[MyJob]&")["&Delim!list[MyJob]&"] ");
497	
498	end;
499	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 14
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

500	
501	simple procedure SYNC;
502	begin					! synchronize with slave ;
503	    ClrFlg( ORG! );			! clear ball flag ;
504	    auxclv(PORT[MyJob],0,!axSYB);	! send yellow ball ;
505	    If ( 0 < QQR < GetTRU( QQJ ) )	! passed TRU limit? ;
506	     then SetFlg( TRU! );
507	end;
508	
509	
510	simple procedure OutPtr (integer PORT; string S);
511	! ----------------------------------------------------------------------;
512	!									;
513	!	OutPtr		Routine to pass a string to the specified	;
514	!			aux-port.  Sends a yellow ball after the	;
515	!			string to coordinate handshaking with the	;
516	!			port.						;
517	!									;
518	! ----------------------------------------------------------------------;
519	begin "out pointer"
520	
521	    while ( length(S) )			! while something to do ;
522	     do auxclv(PORT,lop(S),!axO8);	! send a character ;
523	    SYNC;				! send yellow ball & synch ;
524	
525	end "out pointer";
526	
527	! begin!code	! could use this but it won't do image mode;
528	!	MOVEI	1,!AXOPC;		! output SAIL string;
529	!	HRL	1,PORT;
530	!	AUXCAL	1,-1(SP);		! output through pointer;
531	! end ;
532	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 15
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

533	
534	String Procedure BoolToStr( Boolean T );	! Boolean to String;
535	Return( If T
536	    then If ( DoNumerics land MyBit ) then "1" else "TRUE"
537	    else If ( DoNumerics land MyBit ) then "0" else "FALSE"
538		);
539	
540	Boolean Procedure StrToBool( String S );	! String to Boolean;
541	Return( Kequ(S,"1") or Kequ(S,"TRUE"[1 for length(S)]) );
542	
543	
544	procedure RW!Item( String Itemvar W,R; Reference Boolean B);
545	begin
546	    If ( R neq any )
547	     then B_ StrToBool( Datum(R) );	! Set from source if there;
548	    If ( W neq any )
549	     then Datum(W)_ BoolToStr( B );	! Return to dest if there;
550	    Logit( QFet$Items, "RW!I " &
551			(If R neq any then " R(" & Datum(R) & ")" else "") &
552			(If W neq any then " W(" & Datum(W) & ")" else "")  );
553	end;
554	
555	
556	procedure RW!MyItem( String Itemvar W,R; Reference Boolean B);
557	begin
558	    If ( R neq any )
559	     then begin "source"		! Set from source if there;
560		B_ B land NoBit;		! clear bit first then ?set;
561		B_ B lor  (StrToBool( Datum(R) ) lsh MyJob);
562	     end "source";
563	    If ( W neq any )			! Return to dest if there;
564	     then Datum(W)_ BoolToStr( B land MyBit );
565	    Logit( QFet$Items, "RW!MyI " &
566			(If R neq any then " R(" & Datum(R) & ")" else "") &
567			(If W neq any then " W(" & Datum(W) & ")" else "")  );
568	end;
569	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 16
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

570	
571	procedure Date$( String Itemvar W, R);
572	If W neq any then Datum( W ) _ DatStr( 0, Zone[ MyJob ] );
573	
574	procedure Day$( String Itemvar W, R);
575	If W neq any then Datum( W ) _ DatStr( 1, Zone[ MyJob ] );
576	
577	procedure Daytime$( String Itemvar W, R);	! Read-only * Time of day;
578	begin
579	    Integer T,D,HH,MM,SS;
580	    If W neq any then begin
581		Timer( HH, MM, SS, Zone[ MyJob ] );
582		Getformat(T,D); SetFormat(-2,0);
583		Datum(W) _ CvS(HH) & ":" & CvS(MM) & ":" & Cvs(SS);
584		SetFormat(T,D);
585	    end;
586	end;
587	
588	procedure Delimiter$(String Itemvar W, R);
589	Begin
590	    If R neq any then Set!Delimiter(Datum(R));	! change the delimiter;
591	    If W neq any then Datum(W)_ Del!Chr[MyJob];	! return the current setting;
592	end;
593	
594	procedure Error$( String Itemvar W, R);
595	RW!Item( W, R, DoError );
596	
597	procedure False$( String Itemvar W, R);
598	RW!Item( W, any, FALSE);			! return FALSE;
599	
600	procedure Format$( String Itemvar W, R);
601	begin
602	    integer M;
603	    if R neq any
604	     then begin
605		if ( JF$TYMCOMX leq M_ FndKey( Datum(R), JF$$Nam ) )
606		 then dpb( M, PForm( QQA ) );
607	     end;
608	    if W neq any
609	     then Datum(W)_ JF$$Nam[ LPForm( QQA ) ];
610	end;
611	
612	procedure Hour$( String Itemvar W, R);		! Read-only * Time of day;
613	begin
614	    Integer HH,MM,SS;
615	    If W neq any then begin
616		Timer( HH, MM, SS, Zone[ MyJob ] );
617		Datum(W) _ CvS(HH);
618	    end;
619	end;
620	
621	procedure HH$( String Itemvar W, R);		! Read-only * Time of day;
622	begin
623	    Integer T,D,HH,MM,SS;
624	    If W neq any then begin
625		Timer( HH, MM, SS, Zone[ MyJob ] );
626		Getformat(T,D); SetFormat(-2,0);
627		Datum(W) _ CvS(HH);
628		SetFormat(T,D);
629	    end;
630	end;
631	
632	procedure HHMM$( String Itemvar W, R);		! Read-only * Time of day;
633	begin
634	    Integer T,D,HH,MM,SS;
635	    If W neq any then begin
636		Timer( HH, MM, SS, Zone[ MyJob ] );
637		Getformat(T,D); SetFormat(-2,0);
638		Datum(W) _ CvS(HH) & CvS(MM);
639		SetFormat(T,D);
640	    end;
641	end;
642	
643	procedure HHMMSS$( String Itemvar W, R);	! Read-only * Time of day;
644	begin
645	    Integer T,D,HH,MM,SS;
646	    If W neq any then beginEXECX.SAI                       created 09-Apr-87 15:43                                  Page 16.1
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

647		Timer( HH, MM, SS, Zone[ MyJob ] );
648		Getformat(T,D); SetFormat(-2,0);
649		Datum(W) _ CvS(HH) & CvS(MM) & Cvs(SS);
650		SetFormat(T,D);
651	    end;
652	end;
653	
654	procedure Logging$( String Itemvar W, R);
655	If ( LPLog( QQA ) )				! log file output state;
656	 then RW!MyItem( W, R, DoLog )			! if LogFile R|W;
657	 else RW!MyItem( W, any, DoLog );		! if not LogFile R-only;
658	
659	procedure Mail$( String Itemvar W, R);
660	begin
661	    integer M;
662	    if R neq any
663	     then begin
664		if ( JM$None leq M_ FndKey( Datum(R), JM$$Nam ) )
665		 then dpb( M, PMail( QQA ) );
666	     end;
667	    if W neq any
668	     then Datum(W)_ JM$$Nam[ LPMail( QQA ) ];
669	end;
670	
671	procedure Minute$( String Itemvar W, R);	! Read-only * Time of day;
672	begin
673	    Integer T,D,HH,MM,SS;
674	    If W neq any then begin
675		Timer( HH, MM, SS, Zone[ MyJob ] );
676		Datum(W) _ CvS(MM);
677	    end;
678	end;
679	
680	procedure MMSS$( String Itemvar W, R);		! Read-only * Time of day;
681	begin
682	    Integer T,D,HH,MM,SS;
683	    If W neq any then begin
684		Timer( HH, MM, SS, Zone[ MyJob ] );
685		Getformat(T,D); SetFormat(-2,0);
686		Datum(W) _ CvS(MM) & Cvs(SS);
687		SetFormat(T,D);
688	    end;
689	end;
690	
691	procedure MM$( String Itemvar W, R);
692	If W neq any then Datum( W ) _ DatStr( 7, Zone[ MyJob ] );
693	procedure Mon$( String Itemvar W, R);
694	If W neq any then Datum( W ) _ DatStr( 2, Zone[ MyJob ] )[1 for 3];
695	procedure Month$( String Itemvar W, R);
696	If W neq any then Datum( W ) _ DatStr( 2, Zone[ MyJob ] );
697	
698	procedure Numerics$( String Itemvar W, R);
699	RW!MyItem( W, R, DoNumerics );			! boolean representation;
700	
701	procedure Second$( String Itemvar W, R);	! Read-only * Time of day;
702	begin
703	    Integer T,D,HH,MM,SS;
704	    If W neq any then begin
705		Timer( HH, MM, SS, Zone[ MyJob ] );
706		Datum(W) _ CvS(SS);
707	    end;
708	end;
709	
710	procedure SS$( String Itemvar W, R);		! Read-only * Time of day;
711	begin
712	    Integer T,D,HH,MM,SS;
713	    If W neq any then begin
714		Timer( HH, MM, SS, Zone[ MyJob ] );
715		Getformat(T,D); SetFormat(-2,0);
716		Datum(W) _ Cvs(SS);
717		SetFormat(T,D);
718	    end;
719	end;
720	
721	procedure Substitution$( String Itemvar W, R);
722	RW!MyItem( W, R, DoParam );			! parameter substitution;
723	EXECX.SAI                       created 09-Apr-87 15:43                                  Page 16.2
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

724	procedure TimeLimit$(String Itemvar W, R);
725	begin
726	    own safe integer array Limit[0:2];
727	
728	    if ( R neq any )
729	     then SetTimeLimit( Cvd(Datum(R)) );
730	
731	    if ( W neq any )
732	     then begin "read limit"
733	
734		if ( Limit[0]_ QQT )			! any limit? ;
735		 then begin "non zero"
736	
737		    Limit[0]_ Limit[0] - GetTDT;	! difference in time ;
738		    if ( Limit[0] > 0 )
739		     then begin "good limit"		! TYM-UDT => TYM-SEC ;
740			Limit[2]_ !xwd( '500020,'600020 );
741			calli( location(Limit[0]), calli!DATUUO );
742			Limit[0]_ Limit[0] div 60;	! convert to minutes ;
743		     end "good limit"
744		     else Limit[0]_ -1;			! past due = -1 ;
745	
746		 end "non zero";
747	
748		Datum( W )_ CvS( Limit[0] );		! zero or delta-TDT ;
749	
750	     end "read limit";
751	
752	end;
753	
754	procedure True$( String Itemvar W, R);
755	RW!Item( W, any, TRUE);				! return TRUE;
756	
757	procedure Trulimit$( String Itemvar W, R);
758	begin
759	    If R neq any then QQR_ If Cvd( Datum(R) ) = 0
760				    then 0
761				    else GetTru( QQJ ) + Cvd( Datum(R) );
762	    If W neq any then Datum( W )_ Cvs( If QQR = 0
763					        then 0
764					        else QQR - GetTru( QQJ ) );
765	end;
766	
767	procedure Tomorrow$( String Itemvar W, R);
768	If W neq any then Datum( W ) _ DatStr( 5, Zone[ MyJob ] );
769	procedure Weekday$( String Itemvar W, R);
770	If W neq any then Datum( W ) _ DatStr( 4, Zone[ MyJob ] );
771	procedure Yesterday$( String Itemvar W, R);
772	If W neq any then Datum( W ) _ DatStr( 6, Zone[ MyJob ] );
773	
774	procedure Year$( String Itemvar W, R);
775	If W neq any then Datum( W ) _ DatStr( 3, Zone[ MyJob ] );
776	procedure YY$( String Itemvar W, R);
777	If W neq any then Datum( W ) _ DatStr( 3, Zone[ MyJob ] )[3 for 2];
778	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 17
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

779	
780	procedure ItemIni;			! Alphabetical;
781	begin "procedure item initialization"
782	    Assign( $Date,       Date$);	! Current Date;
783	    Assign( $Day,        Day$);		! Current Day of Month;
784	    Assign( $Daytime,    Daytime$);	! Current Time of day;
785	    Assign( $DD,         Day$);		! Current Day of Month;
786	    Assign( $Delimiter,  Delimiter$);	! Delimiter value;
787	    Assign( $Error,      Error$);	! If :ERROR ? seen;
788	    Assign( $False,      False$);	! FALSE;
789	    Assign( $Format,     Format$);	! Current command file format;
790	    Assign( $HH,         HH$);		! Current Hour of day 00-23;
791	    Assign( $HHMM,       HHMM$);	! Current Hour-minutes hhmm;
792	    Assign( $HHMMSS,     HHMMSS$);	! Current Hour-minutes-seconds;
793	    Assign( $Hour,       Hour$);	! Current Hour of day 0-23;
794	    Assign( $Logging,    Logging$);	! If logging to file;
795	    Assign( $Mail,       Mail$);	! If mail wanted at end;
796	    Assign( $Minute,     Minute$);	! Current Minutes of hour;
797	    Assign( $Mon,        Mon$);		! Current Month as Mmm;
798	    Assign( $Month,      Month$);	! Current Month of year;
799	    Assign( $MM,         MM$);		! Current Month as numeric;
800	    Assign( $MMSS,       MMSS$);	! Current Minutes-seconds;
801	    Assign( $Numerics,   Numerics$);	! If booleans are 1/0 or TRUE/FALSE;
802	    Assign( $Second,     Second$);	! Current seconds of minute;
803	    Assign( $SS,         SS$);		! Current seconds of minute SS;
804	    Assign($Substitution,Substitution$);! If parameter substitutions on;
805	    Assign( $Timelimit,  Timelimit$);	! Time-limit remaining (Minutes);
806	    Assign( $True,       True$);	! TRUE;
807	    Assign( $Trulimit,   Trulimit$);	! TRU-limit remaining (TRUs);
808	    Assign( $Weekday,    Weekday$);	! Day of Week;
809	    Assign( $Year,       Year$);	! Current Year;
810	    Assign( $YY,         YY$);		! Current Year as two digits;
811	end;
812	require ItemIni initialization;
813	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 18
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

814	procedure MOV ( itemvar DST,SRC );
815	begin
816	    string item TMP;
817	    own string itemvar SI;
818	    own real itemvar RI;
819	    own integer itemvar II;
820	    own integer BRK;
821	Logit( QFet$Items,
822	    "Mov: SRC["&cvs(typeit(SRC))&"] ==> DST["&cvs(typeit(dst))&"] " );
823	
824	    case typeit(SRC) of begin		! Convert ??? to string;
825		[3] "string   " datum(TMP)_ datum(SI_SRC);
826		[4] "real     " datum(TMP)_ cvf(datum(RI_SRC));
827		[5] "integer  " datum(TMP)_ cvs(datum(II_SRC));
828		[8] "procedure" apply( datum(SRC), arg!list(TMP,any) );
829		else Fatal( "System error: "& typeit(SRC)
830			    &" ?MOV: can't coerce SRC type " )
831	    end;
832	    case typeit(DST) of begin		! Convert string to ???;
833		[3] "string   " datum(SI_DST)_ datum(TMP);
834		[4] "real     " datum(RI_DST)_ realscan(datum(TMP),BRK);
835		[5] "integer  " datum(II_DST)_ intscan(datum(TMP),BRK);
836		[8] "procedure" apply( datum(DST), arg!list(any,TMP) );
837		else Fatal( "System error: "& typeit(DST)
838			    &" ?MOV: can't coerce DST type " )
839	    end;
840	end;
841	
842	String procedure Substitute(Integer Chan; String Key);
843	begin
844	    String Item SITM;    String Itemvar SI;    Boolean Not!Defined;
845	    Integer Dummy;		! used in UPPERCASE macro ;
846	
847	    Key _ Uppercase(Key);			! make sure this works;
848	    If Key neq "$" then Key _ Chan & Key;	! user keyword? ;
849	    SI _ Cvsi(Key, Not!Defined);		! lookup variable;
850	    If Not!Defined then Return( Null );		! return null if undefined;
851	    MOV( SITM, SI );				! convert ITM _ SI;
852	    Return( Datum(SITM) );			! return string;
853	end;
854	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 19
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

855	simple string procedure Get!Token( Reference string Par!Lst );
856	begin "get a parameter"
857	    String S, Old!Brk;
858	    Integer InQuote, Save!Brk;
859	
860	    White( Par!Lst );					! Clear whitespace;
861	    Quoted _ False;					! Initialize flag;
862	    S _ Scan(Par!Lst, B!Sub, Brk);			! Get Token;
863	    If Brk = '177 or Brk = '42 or BRK = "'"
864	      then begin "in quote"				! We found a quote;
865	        Quoted _ InQuote _ True;    Save!Brk _ Brk;	! For matching pair;
866		If Length(S) then begin				! not allowed yet;
867		    Fatal("parameter text """&S&""" discarded");
868		    S _ null;
869		end;
870		Old!Brk _ null;					! Start anew;
871		While InQuote do begin "Matching quote"		! Match quotes! ;
872		    S _ S & Old!Brk & Scan(Par!Lst, B!Sub, Brk);! Ignore other breaks;
873		    If Brk = '42 and Save!Brk = '42 or		! Check for pairs;
874		       Brk = "'" and Save!Brk = "'" or		!    of each type;
875		       Brk = '177 and Save!Brk = '177		!    "for child";
876			then If Brk = Par!Lst			! Match! Double?;
877			    then begin "quote quote"		!  Yes - handle "";
878				Old!Brk _ Null;			!   Clear break!char;
879				S _ S & Lop(Par!Lst);		!   Add to string;
880			    end "quote quote"			!  Continue;
881			    else begin "done quote"		!  Not double - ;
882				InQuote _ False;		! Set we are done;
883				White( Par!Lst );		! Clear Whitespace;
884				Scan(Par!Lst, B!Sub, Brk);	! Eat to next break*;
885			    end "done quote"
886			else Old!Brk _ If Brk = 0 then Null else Null & Brk;
887		    If length(Par!Lst) = 0 then Done;		! If missing quote?;
888		end "Matching quote";
889	      end "in quote";
890	
891	
892	!
893	!  * --	It would be nice at this point to allow some kind of combination
894	!	or other parameter tricks.  However... not so decided...  (YET)
895	;
896	
897	    If Brk = " " or Brk = #ht then begin
898		White( Par!Lst );				! Clear whitespace;
899		If Brk = "=" or Brk = ","			! Eat certain breaks;
900		    then Brk _ Lop( Par!Lst );			!  so things work;
901	    end;
902	    Return(If Length( S ) then S else null);		! Return something;
903	end "get a parameter";
904	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 20
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

905	Procedure New!Parameter(Integer Chan; String Name, Initial!Value, New!Value);
906	begin
907	    String Itemvar SI;
908	    String Item ITM;
909	    Own Boolean Not!Defined;
910	    Integer Dummy;			! used in UPPERCASE macro ;
911	
912	    Name _ Uppercase(Name);				! Force upper-case;
913	    If Name neq "$" then Name _ Chan & Name;		! Maybe add channel;
914	    Logit( QFet$Items,
915		"NewP: "&Name&" ("&initial!value&") N("&New!value&")" );
916	
917	    SI _ Cvsi( Name, Not!Defined);			! See if PNAME exists;
918	    If Not!Defined then begin				! No, then;
919		If Name = "$" then begin "don't allow $ vars"	!   if system var?;
920		    Fatal("Illegal variable name """&Name&"""");!   illegal not found;
921		    Return;					!     so bug out.;
922		end;						!   else;
923		New!Pname(SI _ New(Initial!Value), Name);	!     define it;
924		Par!Set[MyJob] _ Lop(Par!!Set[MyJob]);		! Get current set;
925		Put SI in Datum( Par!Set[MyJob] );		! Put new item in set;
926		Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! Put set away;
927	    end;
928	    If length(New!Value) then begin			! If something there;
929		Datum( ITM ) _ New!Value;			!   store as string;
930		MOV( SI, ITM );					!   mov SI _ ITM;
931	    end;
932	    Logit( QFet$Items,
933		" Pname[ "& Cvis( SI, Not!defined ) &" ]" );
934	end;
935	
936	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 21
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

937	simple procedure Set!Parameter(Reference string Par!Lst);
938	begin "build substitution table"
939	    String Par!,Name;    String Itemvar SI;
940	    Integer Par!Index;   Boolean Keyword!Parameters;
941	
942	    Par!Set[MyJob]  _ New(Phi);				! Empty set;
943	    Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! First item in list;
944	    Par!List[MyJob] _ New(Nil);				! Empty list;
945	    Keyword!Parameters _ False;				! None at first;
946	    While Length(Par!Lst)
947	     do begin "reading parameters"
948		Name _ null;					! Clear name;
949		Par! _ Get!Token( Par!Lst );			! Read a parameter;
950		If Brk = "=" then begin "named parameters"	! Assignment!;
951		    If Quoted then				! To a string?;
952			Fatal("Assignment to string """&Par!&"""");
953		    Keyword!Parameters _ True;			!   Set flag;
954		    Name _ Scan( Par!, B!Par, Brk );		!   Set name;
955		    If Length(Par!) then begin			!   Error if non-null;
956			Fatal("Illegal character """&Brk&	!     print message;
957				""" in parameter");
958			Name _ null;				!     clear name;
959		    end;
960		    Par! _ Get!Token( Par!Lst );		!   Set parameter;
961		end "named parameters";
962	
963	Logit( QFet$Items,
964	    "List: {"&Name&"}={"&Par!&"}" &
965	    cvs(Length(name))&":"&cvs(Length(par!)) );
966	
967		If ( Length( Name ) ) then begin		! Named parameter;
968		    SetFlg( DoParam );				! Set flag true;
969		    New!Parameter(IChan[MyJob],Name,Null,Par!)	! Create parameter;
970		  end
971		  else begin					! Ordered parameter;
972		    If ( Keyword!parameters ) then Fatal(	!   ** ERROR **;
973		     "Positional parameter after keyword parameter ignored: """&Par!&"""")
974		    else begin
975			SetFlg( DoParam );			! Set flag true;
976			SI _ New( Par! );			!   create item;
977			Put SI in Datum(Par!List[MyJob]) after INF;  ! Put into list;
978		    end;
979		end;
980	    end "reading parameters";
981	    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! First item in list;
982	end "build substitution table";
983	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 22
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

984	
985	String procedure parametize(Value String S);
986	begin "parameter substitution"
987	    String L, Key;    Integer Par!Chr;
988	
989	    Logit( QFet$Subs, "R("&cvs(MyJob)&"): "& S );
990	
991	    Breakset(B!Quote, Del!Chr[MyJob], "I");	! setup the break table;
992	
993	    L _ Null;					! Newline;
994	    While ( Length(S) )				! While we have a string ;
995	     do begin "have string"
996	
997	      L_ L & Scan(S, B!Quote, Brk);		! Scan for a parameter;
998	      If ( Brk = Del!Chr[MyJob] )		! Null?;
999	       then begin "got one"
1000	
1001		Par!Chr_ Lop(S);			! Get next char;
1002		If ( Par!Chr = Del!Chr[MyJob] )		! Do we have quote quote?;
1003		  then L_ L & Par!chr			!  Yes, use a quote here;
1004		  else begin				!  No. ;
1005	
1006		    Key_ Par!Chr & Scan(S,B!Par,Brk);	!   Read keyword;
1007		    If ( Brk = Del!Chr[MyJob] )		! If followed by quote;
1008		     then Par!Chr_ Lop(S);		!   eat the quote;
1009		    L_L & Substitute(IChan[MyJob],Key);	!   Perform substitution;
1010		    Logit( QFet$Subs, "Par: Key("& key &") <= """ &
1011			    Substitute(IChan[MyJob],key) &"""" );
1012	
1013		  end;
1014	
1015	      end "got one";				! Done parameter;
1016	
1017	    end "have string";				! Done Line;
1018	
1019	    Logit( QFet$Subs, "P("&cvs(MyJob)&"): "& L );
1020	
1021	    Return (L);					! So, Return it;
1022	
1023	End;
1024		
1025	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 23
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1026	
1027	Simple boolean procedure SPROUT( Boolean NeedPort; Integer Cradle );
1028	begin
1029	    Own integer MyPort, APort;
1030	    Own Safe Integer Array Pty[0:1];
1031	
1032	    if ( NeedPort )			! does this job require a port ;
1033	     then begin "need a port"		! yes, so setup a PTY-pair ;
1034	
1035		APort _ calli(0,calli!CREPTY);	! create the PTYs ;
1036		if not( !SKIP! )		! failed? ;
1037		 then return( false );		! then go home ;
1038	
1039		Port[MyJob]_MyPort_ !lh(APort);	! my pty port to remember ;
1040	
1041	     end "need a port";
1042	
1043	    If ( QQF_ CChild( Cradle ) )	! create a frame;
1044	     then QQU_ Gettab( QQJ,!gtUID )	! remember name;
1045	     else return( false );		! else go home ;
1046	
1047	    if ( NeedPort )
1048	     then begin "transfer port"
1049	
1050		auxcli(MyPort,'214,!axCFS);	! we are in image no echo;
1051		auxclv(MyPort,1,!axSOX);	! expand tabs for output ;
1052	
1053		Pty[0]_ !Xwd( -1,QQJ );		! from self to child ;
1054		Pty[1]_ !Xwd( '200000,APort );	!  using this port ;
1055		calli( location(Pty[0]), calli!RETACH );
1056	
1057		if not( !SKIP! )		! can't attach port? ;
1058		 then return( false );		! go home ;
1059	
1060		PrtEnb( MyPort );		! enable interrupts on port ;
1061	
1062	     end "transfer port";
1063	
1064	    return( true );
1065	
1066	end;
1067	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 24
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1068	!	Command checking code
1069	;
1070	
1071	redefine XC(Text,Action) = { or Kq(S,Text) };    
1072	
1073	
1074	simple boolean procedure ChkCommand( String Str );
1075	begin "check command"
1076	    String S;
1077	
1078	    if ( Str = (case LPForm( QQA ) of ( ":", ".", "@" )) )
1079	     then lop( Str );			! remove leading character ;
1080	
1081	    if ( Str = ":" )
1082	     then if ( LPForm( QQA ) = JF$TYMCOMX )
1083		   then return( true )		! seems to be a ::label ;
1084		   else return( Fatal( "::label in mode "&cvs(LPForm( QQA )) ) );
1085	
1086	    S_ Tok( Str );			! get a small parcel ;
1087	
1088	    if ( Brk = "=" )
1089	     then return( true );		! seems to be a definition ;
1090	
1091	    require crlf&"commands:"&crlf & cvms(AllCommands) & crlf message;
1092	
1093	    return( ( length( S ) = 0 ) AllCommands );
1094	
1095	end "check command";
1096	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 25
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1097	
1098	simple boolean procedure CheckLabel( reference string S );
1099	begin "check label"
1100	    boolean colon;
1101	    integer index;
1102	
1103	    if ( S = (case LPForm( QQA ) of ( ":", ".", "@" )) )
1104	       or ( ( LPForm( QQA ) = JF$TYMCOMX ) and
1105		    kequ( "::", S[1 for 2] )	! "::label" for perp ;
1106		    or ( S = "." )		! or monitor command ;
1107		  )
1108	     then return( false );		!  so don't do anything ;
1109	
1110	    colon_ false;
1111	    for index_ 2 upto length( S )	! for each character ;
1112	     do if ( S[index for 1] = ":" )
1113		 then begin "one colon"
1114	
1115		    if ( colon )
1116		     then begin "a label"
1117	
1118			if ( "0" leq S leq "9" )
1119			 then return( Fatal( "labels must start with a letter" ) );
1120	
1121			if not( NeedBall land MyBit )	! if not a repeat ;
1122			 then MyLog( S[1 to index] );	! put label into log ;
1123	
1124	    Logit( QFet$Cmds, "Label: "& S[1 to index] &"<>"& S[index+1 to inf] );
1125	
1126			S_ S[index+1 to inf];	! fixup line from file ;
1127			SetFlg( ALabel );	! mark we have a label ;
1128			return( true );		! and return to caller ;
1129	
1130		     end "a label"
1131		     else colon_ true		! only one colon ;
1132	
1133		 end "one colon"
1134		 else begin "no colon"
1135	
1136		    if not( ( "A" leq (S[index for 1] land '137) leq "Z" )
1137			    or ( "0" leq S[index for 1] leq "9" ) )
1138		     then return( false );
1139	
1140		    colon_false;
1141	
1142		 end "no colon";
1143	
1144	    return( false );
1145	
1146	end "check label";
1147	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 26
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1148	
1149	Simple boolean Procedure GOTO (string CMD);
1150	if ( IChan[MyJob] > 0 )
1151	 then begin "GOTO COMMAND"
1152	    string S, SS, ST;
1153	    integer Count, Where;
1154	
1155	    S _ "::" & (ST_ Tok( CMD ));		! Define label = ::name ;
1156	    SS_ ST & "::";				!  also  label = name:: ;
1157	
1158	    Count_ LineNo[MyJob];			! remember where we started ;
1159	    if ( kequ( cvs(cvd(ST)), ST ) )		! we have a number! ;
1160	     then begin "skip lines"
1161	
1162		if not( VMMove( IChan[MyJob], cvd(ST) ) )
1163		 then return( Fatal( "eof while skipping "& ST &" lines." ) );
1164	
1165		LineNo[MyJob]_ (Count+cvd(ST)) & LineNo[MyJob][2 to inf];
1166		if ( length( IChan[MyJob] ) = 1 )	! if main command file ;
1167		 then QQN_ LineNo[MyJob];		! copy for safekeeping ;
1168	! ***	MyLog( "-- Skipped "& ST &" lines. --"& crlf );
1169		return( true );				! we made it ;
1170	 
1171	     end "skip lines"
1172	     else do begin "scanning file"
1173	
1174		LineNo[MyJob]_ LineNo[MyJob]+1 & LineNo[MyJob][2 to INF];
1175		if ( length( IChan[MyJob] ) = 1 )	! if main command file ;
1176		 then QQN_ LineNo[MyJob];		! copy for safekeeping ;
1177	
1178		Where_ VMGetC( IChan[MyJob] );		! Get character position ;
1179		ST_ VMLine( IChan[MyJob], Brk );	! Read a line of the file;
1180	
1181		if Kequ( S, ST )			! Compare ::name to ST ;
1182		  or Kequ( SS, ST[1 for length(SS)] )	! Compare name:: to ST ;
1183		 then begin "got label"			! If match, then "found";
1184		    LineNo[MyJob]_ LineNo[MyJob]-1 & LineNo[MyJob][2 to inf];
1185		    if ( length( IChan[MyJob] ) = 1 )	! if main command file ;
1186		     then QQN_ LineNo[MyJob];		! copy for safekeeping ;
1187	! ***	    MyLog( "-- Skiped "&cvs(LineNo[MyJob]-Count)&" lines. --"& crlf );
1188		    VMSetC( IChan[MyJob], Where );	! Reset to beginning of line ;
1189		    return( true );			!   and return ;
1190		 end "got label"
1191		 else DumpLog( ST & Crlf );		! dump skipped lines ;
1192	
1193	     end "scanning file" until ( Brk = 0 );
1194	
1195	    return( Fatal("end of file while scanning for label """&S&"""") );
1196	
1197	end "GOTO COMMAND";
1198	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 27
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1199	
1200	Simple Procedure BackTo (string CMD);
1201	if ( IChan[MyJob] > 0 )
1202	 then begin "BACKTO COMMAND"
1203	    string S, SS, ST;
1204	    integer Count;
1205	
1206	    S _ "::" & (ST_ Tok( CMD ));		! Define label = ::name ;
1207	    SS_ ST & "::";				!  also  label = name:: ;
1208	
1209	    Count_ LineNo[MyJob];			! remember start point ;
1210	    do begin "scanning file"
1211	
1212		LineNo[MyJob]_ LineNo[MyJob]-1 & LineNo[MyJob][2 to INF];
1213		if ( length( IChan[MyJob] ) = 1 )	! if main command file ;
1214		 then QQN_ LineNo[MyJob];		! copy for safekeeping ;
1215	
1216		ST_ VMLine( IChan[MyJob], Brk, -1 );	! Read a line of the file;
1217	
1218		if Kequ( S, ST )			! Compare ::name to ST ;
1219		  or Kequ( SS, ST[1 for length(SS)] )	! Compare name:: to ST ;
1220		 then begin "found label"
1221		    MyLog( crlf &"-- Backed-up "&
1222			    cvs(Count-LineNo[MyJob]-1) &" lines. --"& crlf&crlf );
1223		    return;				! If match, then "found" ;
1224		 end "found label";
1225	
1226	     end "scanning file" until ( Brk = 0 );
1227	
1228	    Fatal("end of file while scanning for label """&S&"""");
1229	
1230	end "BACKTO COMMAND";
1231	
1232	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 28
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1233	
1234	simple boolean procedure FrontEnd;
1235	begin "FrontEnd"
1236	    integer C, Chan, Labels, PBP, RunFlag, MakeLog, ASlot, AppendFlag;
1237	    string Cmd, Log, Match, S, Par;
1238	
1239	    ASlot_ QueAct + E!Length * (MyJob - 1);
1240	    ClearFlags;					! clear all flag bits ;
1241	
1242	    Zone[ MyJob ]_ LAPZone( ASlot );
1243	    Cmd_ InfNam( ASlot+E!CmdFile );
1244	
1245	!	setup input file
1246	;
1247	    if ( 0 geq IChan[MyJob]_ VMFile( Cmd, VM$Read ) )	! if not available ;
1248	     then begin "no input file"
1249		Dpb( !rh(IChan[MyJob]), APFErr(ASlot) );
1250		LogInfo( "Stream #"& cvs(MyJob) &" no input file ("&
1251			 cvos(!rh(IChan[MyJob])) &") "& Cmd );
1252		return( JobExit( Abort$Input ) );
1253	     end "no input file";
1254	
1255	    If ( RunFlag_ LAPRunF( ASlot ) )		! if RUN program  ;
1256	     then if not( VMFree( Lop(IChan[MyJob]) ) )	!  close file now ;
1257		   then return( JobExit( Abort$Input ) );
1258	
1259	!	Create frame & determine if PTY needed here.
1260	;
1261	    if ( LPProc( QQS ) leq PSS$Frame )
1262	     then If not( Sprout( LAPDetF(ASlot) = 0, ASlot+E!Runtime ) )
1263		   then if ( !rh(!skip!) < 2 )		! waiting for frame? ;
1264			 then dpb( PSS$Frame,PProc( QQS ) )
1265			 else return( JobExit( Abort$Frame ) );
1266	
1267	!	Handle parameters here.  Note: Do this even if no parameters. ;
1268	
1269	    Par_ null;
1270	    if ( Rec( E!Parameters ) )		! some parameters ;
1271	     then begin "build line"
1272		PBP_ point( 7, Rec(E!Parameters), -1 );
1273		for C_ 1 upto E!ParLength	! for each allowable character ;
1274		 do if ( ildb( PBP ) )		!  if it is non-null ;
1275		     then Par_ Par & ldb( PBP )	!   add it to string ;
1276		     else done;			!   else no more ;
1277		Logit( QFet$Pars, "Parameters: "& Par );
1278	     end "build line";
1279	
1280	    if not( LAPRunF( ASlot ) )		! don't chew item space ;
1281	     then Set!Parameter( S_ Par );	!  if no command file ;
1282	
1283	!	LOG file wanted?
1284	;
1285	    if ( MakeLog_ LAPLog( ASlot ) )			! If log file wanted ;
1286	     then begin "get log file"
1287	
1288		SetFlg( DoLog );				! set flag ;
1289		Log_ InfNam( ASlot+E!LogFile );			! remember name ;
1290	
1291		If ( MakeLog = JL$Supersede )			! if supercede? ;
1292		 then begin "supercede"
1293		    if ( 0 < Chan_ VMFile( Log,VM$Write ) )	! $Write (re-open)? ;
1294		     then VMFree( Chan )			!  close it! (done) ;
1295		     else begin "enter error"			!  write failure? ;
1296			LogInfo( "Stream #"& cvs(MyJob) &" file enter error ("&
1297				 cvos(!rh(Chan)) &") "& Cmd );
1298			Dpb( !rh(Chan), APFErr(ASlot) );	! remember error ;
1299			return( JobExit( Abort$Enter ) );	! and set status ;
1300		     end "enter error";
1301		 end "supercede";
1302	
1303		AppendFlag_ 0;					! initialize = 0 ;
1304		if ( MakeLog = JL$Append )			! if want append ;
1305		 then AppendFlag_ VM$Append;			!  set flag true ;
1306	
1307		if ( 0 geq Chan_ VMFile( Log, VM$Update lor AppendFlag ) )
1308		 then begin "update error"			! failure ;
1309		    LogInfo( "Stream #"& cvs(MyJob) &" file append error ("&EXECX.SAI                       created 09-Apr-87 15:43                                  Page 28.1
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1310			 cvos(!rh(Log)) &") "& Log );
1311		    Dpb( !rh(Chan), APFErr(ASlot) );
1312		    return( JobExit( Abort$Update ) );
1313		 end "update error";
1314	
1315		OChan[ MyJob ]_ Chan;		! store proper output channel ;
1316	
1317	    end "get log file";
1318	
1319	    SetTimeLimit( LAPTimL( ASlot ) );	! timeout in minutes;
1320	    SetFlg( DoNumerics );		! Default NUMERICS=$TRUE ;
1321	    Buffer[ MyJob ]_ Null;		! clear type-ahead msg buffer ;
1322	
1323	    LineNo[ MyJob ]_ 0;			! initialize starting line ;
1324	    if ( Labels_ memory[ ASlot+E!Label ] )	! label field specified ;
1325	     then begin "wants label"
1326	
1327		if ( Labels lsh -30 )			! check first character ;
1328		 then Match_ cv6str( Labels )		! sixbit or so it seems ;
1329		 else Match_ cvs( Labels );		! no, numeric - fake it ;
1330	
1331		if ( Chan_ OChan[ MyJob ] )		! tell them where it is ;
1332		 then VMText( Chan, "-- Starting at "&
1333				(if Labels lsh -30 then "label " else "line ") &
1334				cv6str( Labels ) &":: --"& crlf&crlf );
1335	
1336		if not( GoTo( Match ) )
1337		 then begin "no label"
1338		    dpb( 1, APFerr( ASlot ) );
1339		    return( JobExit( Abort$Error ) );
1340		 end "no label";
1341	
1342	     end "wants label";
1343	
1344	    if ( LAPRunF( ASlot ) )			! if RUN program  ;
1345	     then if ( RunJob( QQJ, ASlot, Par ) )	! if runnable ;
1346		   then begin "ok to go"
1347		      SetFlg( NeedExit );		! flag we expect an exit ;
1348		      dpb( Proc$Run, PStap( QQS ) );	! Processing, Run ;
1349		   end "ok to go"
1350		   else return( JobExit( Abort$Run ) );	! error ;
1351	
1352	  return( true );
1353	
1354	end "FrontEnd";
1355	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 29
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1356	
1357	procedure REASSIGN (string CMD);
1358	begin "DEFINE COMMAND"
1359	    string  Key, Val, Expr;
1360	
1361	    While Length(CMD) do begin "scanning parameters"
1362		White( CMD );					! Clear whitespace;
1363		Key _ Scan( CMD, B!Par, Brk);			! Get name;
1364		Logit( QFet$Pars lor QFet$Items,
1365			" Key("& Key &") Break("& Brk &")["& cvs(Brk) &
1366			"] CMD: "& CMD );
1367		If Brk = " " or Brk = #HT then White( Cmd );	! Eat whitestuff;
1368		If Brk = "=" then begin
1369		    Lop( CMD );					! Eat = ;
1370		    Expr _ Get!Token(CMD);			! Read next token;
1371		    Logit( QFet$Pars lor QFet$Items,
1372			" Expr("& Expr &") Break("& Brk &")["& cvs(Brk) &
1373			"] CMD: "& CMD );
1374		    If not (quoted or Numeric(Expr) ) then begin
1375			Val _ Scan(Expr,B!Par,Brk);
1376			If length(Expr) then Fatal(
1377			    "Illegal character """&Brk&""" in parameter name")
1378			  else begin
1379			    Expr _ Substitute( IChan[MyJob], Val );
1380			    New!Parameter(IChan[MyJob], Key, Null, Expr )
1381			  end;
1382		    end
1383		    else New!Parameter(IChan[MyJob], Key, Null, Expr )
1384		end
1385		else begin
1386		    Fatal("Illegal format in assignment """&Brk&Cmd&"""");
1387		    Logit( QFet$Pars lor QFet$Items,
1388			" Key("& Key &") Break("& Brk &")["& cvs(Brk) &
1389			"] CMD: "& CMD );
1390		    Done;
1391		end;
1392	    end "scanning parameters";
1393	end "DEFINE COMMAND";
1394	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 30
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1395	
1396	simple procedure CHECKPOINT( string CMD );
1397	begin "CHECKPOINT"
1398	    integer ASlot;
1399	
1400	    ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
1401	    Dpb( CvSIX(Get!Token(CMD)), Rec(E!Label) );	! set label - if any ;
1402	end "CHECKPOINT";
1403	
1404	
1405	procedure COM (string CMD);
1406	begin "COM COMMAND"
1407	    Integer Chan;
1408	    String Name, Dev;
1409	    Boolean Ext!Found, File!Error;
1410	
1411	    Name _ GetFil(CMD, Dev_ "DSK", Ext!Found, File!Error);	! read off filename;
1412	    If ( File!Error ) then begin		! If error...;
1413		Fatal("COM Filename error """&Name&"""");
1414	      end
1415	      else begin				! add delimiter to list;
1416		Delim!list[MyJob]_ Del!Chr[MyJob] & Delim!list[MyJob];
1417		Set!Parameter(CMD);			! NOW setup parameters;
1418		If ( Name neq "(" )			! username not specified;
1419		 then Name_ "(" & cv6str( Gettab( QQJ,'31 ) ) &
1420			    cv6str( Gettab( QQJ,'32 ) ) & ")" & Name;
1421		Chan_ VMFile( Name );
1422		If ( Chan leq 0 ) and not Ext!Found	! if not there, then;
1423		 then Chan_ VMFile(Name&Default!Ext);	!  try other extension;
1424		If ( Chan leq 0 )
1425		 then Fatal( "COM File error ("&Cvs(!rh(Chan))&") for file: "&Name);
1426		IChan[MyJob] _ Chan & IChan[MyJob];	! add channel to list;
1427	    end;
1428	end;
1429	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 31
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1430	
1431	Simple Boolean Procedure CommandMode;
1432	return( Gettab( QQJ,!gtSTS ) geq 0 );
1433	
1434	
1435	procedure ESCAPE;
1436	begin "Escape"
1437	
1438	    if ( CommandMode )			! if command mode ;
1439	     then ClrFlg( NeedEscape )		!  clear escape   ;
1440	     else begin "halt frame"
1441		DEFINE !FOSTP = '41;
1442		FrmXct( QQJ, 0, !foSTP );	! stop the frame  ;
1443		SetFlg( NeedEscape );		!  set NeedEscape ;
1444	     end "halt frame";
1445	
1446	!    SYNC;				! is this right? ;
1447	
1448	end "Escape";
1449	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 32
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1450	
1451	procedure PARAMETERS(String CMD);
1452	begin "PARAMETERS COMMAND"
1453	    string Key, Par!Default, Par!Value;    String Itemvar SI;
1454	
1455	    SetFlg( DoParam );					! Set flag true;
1456	    Par!List[MyJob] _ Lop( Par!!List[MyJob] );		! Get ordered list;
1457	    While Length(CMD)
1458	     do begin "scanning parameter names"
1459		Key _ Get!Token(CMD);				! Name;
1460		Par!Default _ If Brk = "=" or Brk = "_"		! Parameter or null;
1461		    then Get!Token(CMD)
1462		    else Null;
1463		If Length( Datum(Par!List[MyJob]) )		! If any in list;
1464		 then begin
1465		    SI _ Lop( Datum(Par!List[MyJob]) );		! Get Item;
1466		    Par!Value _ Datum( SI );			! Get string value;
1467		    Delete( SI );				! No longer needed;
1468		 end
1469		 else Par!Value _ Null;				! Get null value;
1470		New!Parameter(IChan[MyJob], Key, Par!Default, Par!Value );
1471	     end "scanning parameter names";
1472	    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! Restore list;
1473	end "PARAMETERS COMMAND";
1474	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 33
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1475	
1476	simple procedure QUIT;
1477	SetFlg( STOP! );
1478	
1479	
1480	simple procedure RESTART( string CMD );
1481	begin "RESTART"
1482	    Own integer ASlot;
1483	    ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
1484	    Dpb( CvSIX(Get!Token(CMD)), Rec(E!Label) );	! change label - if any ;
1485	    Dpb( PSP$Restart, PProc( QQS ) );		! set restart flag ;
1486	end "RESTART";
1487	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 34
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1488	
1489	procedure SEND (string CMD);
1490	begin	"SEND"
1491	    string KW;
1492	    KW _ Get!Token(CMD);
1493	    If ( quoted )
1494	     then KW _ Brk&KW&Brk;		! restore quoted string ;
1495	    If Kequ(KW,"CHARACTER"[1 for length(KW)]) then begin
1496		    integer K;
1497		    K _ Cvo(CMD);
1498		    Logit( QFet$Strs, "SEND "&KW&" '"& Cvos(K) );
1499		    auxclv(PORT[MyJob],K,!axO8);	! cvo(CMD),!axO8) ;
1500	    end
1501	    else if Kequ(KW,"STRING"[1 for length(KW)]) then begin
1502		    KW _ Get!Token(CMD);
1503		    Logit( QFet$Strs, "SEND S """&KW&""""&crlf );
1504		    Outptr( Port[MyJob], KW );		! Get!Token(CMD) );
1505	    end
1506	    else if Kequ(KW,"FILE"[1 for length(KW)]) then begin "SEND FILE"
1507		String Name, Dev, L;  Integer LastBrk;
1508		Boolean Ext!Found, File!Error, Eof;
1509	
1510		Name _ GetFil(CMD, Dev, Ext!Found, File!Error);
1511		If ( File!Error )
1512		  then Fatal( "SEND FILE - File error: "&Name )
1513		  else begin "good filename"
1514		    IChan[MyJob] _ VMFile( Name ) & IChan[MyJob];
1515		    if ( IChan[MyJob] < 0 )
1516		      then Fatal( "SEND FILE - File error: "&Name )
1517		      else While not( Eof )
1518		       do begin "transmit file"
1519			  L_ VMLine( IChan[MyJob], Brk );
1520			  L_ L & (If VMGetC( IChan[MyJob],VM$ECR )
1521				   then #cr else if Brk then Brk&Null else "");
1522			  If length( L ) or ( Brk )
1523			   then begin "got line"
1524			      if not( length( Buffer[MyJob] ) )
1525			       then Outptr( Port[MyJob], L );
1526			      Buffer[MyJob]_ Buffer[MyJob] & L;
1527			   end "got line";
1528			  EOF_ Brk = 0;
1529		      end  "transmit file";
1530		    Scan( Buffer[MyJob], B!Cr, Brk );	! trim first time away ;
1531		  end "good filename"
1532	    end "SEND FILE"
1533	    else Fatal( "illegal SEND command: "&CMD );
1534	end;
1535	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 35
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1536	
1537	simple procedure SETERROR( string CMD; boolean Flag );
1538	if not( Flag )
1539	 then ErrChr[MyJob]_ null
1540	 else if not( length( ErrChr[MyJob]_ Tok( CMD )[1 for 1] ) )
1541	       then ErrChr[MyJob]_ "?";
1542	
1543	
1544	simple procedure SILENCE( boolean Flag );
1545	if ( Flag )
1546	 then ClrFlg( DoLog )
1547	 else SetFlg( DoLog );
1548	
1549	
1550	simple procedure STOP;
1551	SetFlg( STOP! );
1552	
1553	
1554	simple procedure TIME (string CMD);
1555	SetTimeLimit( cvd( Tok(CMD) ) );	! Time in minutes;
1556	
1557	
1558	simple procedure TRULIMIT( string CMD );
1559	QQR_ GetTru( QQJ ) + Cvd( Tok(CMD) );	! TRUs remaining ;
1560	
1561	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 36
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1562	
1563	recursive procedure COMMAND( string CMD );
1564	begin	"COMMAND"
1565	    string KW;  integer Index;
1566	
1567	    if ( NeedBall land MyBit )		! waiting for ball? ;
1568	     then ClrFlg( NeedBall )		! yes, clear waiting flag ;
1569	     else begin "wait for ball"
1570		SetFlg( NeedBall );		! set waiting flag ;
1571		Sync;				! send yellow ball ;
1572		return;				! and return ;
1573	     end "wait for ball";
1574	
1575	    MyLog( CMD & crlf );		! note: ALabel land MyBit ;
1576	
1577	    lop( CMD );				! eat prefix character ;
1578	    KW _ Get!Token(CMD);		! Get first token;
1579	    Logit( QFet$Cmds, "Cmd: "& KW &" >> "& CMD );
1580	    if ( Brk = "=" )
1581	     then begin "fake define"
1582		CMD_ KW & Brk & CMD;
1583		KW_ "DEFINE";
1584		BRK_ " ";
1585	     end "fake define";
1586	
1587	  redefine XC(Text,Action) = {
1588	    ifcr length( Cvps( Text ) )
1589	     thenc
1590	      ifcr length( Cvps( Action ) )
1591	       thenc  Action;
1592	       elsec  begin end;
1593	      endc
1594	    endc
1595	  };
1596	
1597	    if ( KW = ":" )
1598	     then				! ignore label here;	! Defer;
1599	     else if ( Length(KW) )
1600		   then begin "my commands"
1601		      Case ( Index_ FndKey( KW, Commands ) + 1 ) of begin
1602			  Fatal( "Ambigious command: "& KW );
1603			  Fatal( "Unknown command: "& KW );
1604			  AllCommands
1605		      end;
1606		   end "my commands";
1607	
1608	    Sync;
1609	
1610	end	"COMMAND";
1611	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 37
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1612	
1613	Simple Integer Procedure SlotsAvailable;
1614	begin "slots available"
1615	
1616	    For MyJob_ 1 step 1 until E!JobMax
1617	     do begin "check each slot"
1618	
1619		if ( NTQ! or ESC! )		! if ( ^C or Notice-to-quit ) ;
1620		 then return( MyJob_ 0 );	!  just go home now... ;
1621	
1622		NoBit_ lnot (MyBit_ 1 lsh MyJob);
1623	
1624		If ( LPStat( QQS ) = ST$Sched )
1625		 then begin "consider slot"
1626	
1627		    if ( FrontEnd )		! setup user and keep track ;
1628		     then begin "user ready"
1629	
1630			LogInfo("Stream #"& cvs(MyJob) &
1631				" " & InfJob( queAct+(E!Length*(MyJob-1)) ) );
1632	
1633			Dpb( Proc$Run, PStap( QQS ) );
1634	
1635			if ( MyJob > HighJob )	! have we raised the limit? ;
1636			 then HighJob_ MyJob;	! yes -- set new value ;
1637	
1638			return( MyJob );	! give them the slot ;
1639	
1640		     end "user ready"
1641	
1642		 end "consider slot";
1643	     end "check each slot";
1644	
1645	    return( MyJob_ 0 );			! no slots to initialize ;
1646	
1647	end "slots available";
1648	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 38
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1649	
1650	Simple String Procedure JobStatus( integer ASlot );
1651	begin "job status"
1652	    string str;
1653	
1654	    define ifst(x,y,z,l) = {
1655		if ( x land MyBit )
1656		 then begin
1657		    dpb( LineNo[MyJob][inf for 1], APFErr( ASlot ) );
1658		    dpb( y, PStap( QQS ) );
1659		    Str_ z
1660		    ifcr length(cvps(l))
1661		     thenc & " at line " & cvs(LineNo[MyJob])
1662		     endc ;
1663		 end
1664	};
1665	    Str_ Complete;
1666	    if ( LPStat( QQS ) = ST$Proc )
1667	       and not ( LPProc( QQS ) = PSP$Restart )
1668	     then Dpb( Done$End, PStap( QQS ) );
1669	
1670	    ifst( OverTime, Abort$Time,["aborted - time limit exceeded"], line );
1671	    ifst( NTQ!,   Abort$Notice,["aborted - halted by operator"], line );
1672	    if ( ( ZAP! land MyBit ) and LAPLogF( ASlot ) )
1673	     then begin "allow zap"
1674		ifst( ZAP!, Done$End, ["completed - lost command port"], line );
1675		ClrFlg( ZAP! );
1676	     end "allow zap";
1677	    ifst( ZAP!,   Abort$Zap,   ["aborted - lost command port"], line );
1678	    ifst( STOP!,  Done$Stop,   ["completed - :STOP"], line );
1679	    ifst( ERR!,   Done$Error,  ["completed - :ERROR in job"], line );
1680	    ifst( TRU!,   Abort$Tru,   ["aborted - TRU limit exceeded"], line );
1681	    ifst( LOS!,   Done$Lost,   [Str & " [check for data lossage]"] );
1682	
1683	    return( Str );
1684	
1685	end "job status";
1686	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 39
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1687	
1688	Simple Procedure Cleanup;
1689	begin "cleanup"
1690	    Own integer ASlot;
1691	    String S;
1692	
1693	    if ( QQS )				! valid job pointer? ;
1694	     then begin "good job"
1695	
1696		ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
1697		Disposition_ JobStatus( ASlot );	! get job disposition ;
1698	
1699		while ( length( IChan[MyJob] ) )	! if any files open ;
1700		 do begin "each level"
1701		    while ( length( S_ VMLine( IChan[MyJob], Brk ) ) or ( Brk ) )
1702		     do DumpLog( S & Crlf );		! if more then dump it ;
1703		    VMFree( lop( IChan[MyJob] ) );	! then close the file ;
1704		 end "each level";
1705	
1706		LogInfo( "Stream #"& cvs(MyJob) &
1707			 " Req #" & cvs( LAPReq( ASlot ) ) & 
1708	!		 " " & InfJob( queAct+(E!Length*(MyJob-1)) ) &   ;
1709			 " * " & Disposition & " *" );
1710	
1711		If ( LPLog( QQA ) )
1712		 then VMText( OChan[MyJob], Crlf& "; Req #" & cvs(LAPReq( ASlot )) &
1713						  " " & Disposition & Crlf );
1714	
1715		If ( LPLog( QQA ) and (
1716		    ( LPDisp( QQA ) = JD$DELETE ) or
1717		    ( LPDisp( QQA ) = JD$ERROR and Kequ(Disposition,Complete) ) ) )
1718		 then VMFree( OChan[MyJob],-1 )	! delete the log-file ;
1719		 else VMFree( OChan[MyJob] );	! or simply close it ;
1720	
1721		OChan[MyJob]_ 0;		! forget channel number ;
1722	
1723	     end "good job";
1724	
1725	    ClearFrame;				! make it go away for real ;
1726	    Deactivate;				! crank down activity ;
1727	
1728	end "cleanup";
1729	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 40
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1730	
1731	Simple Procedure Do!Cleanup;
1732	begin "do cleanup"
1733	
1734	    if ( CHR! land MyBit )		! more characters to read? ;
1735	     then return;			! yes, wait till they're gone ;
1736	
1737	    if ( NeedZap land MyBit )		! waiting for a zapper? ;
1738	     then ClrFlg( ZAP! );		! don't complain here ;
1739	
1740	    Port[ MyJob ]_ 0;			! port was zapped already ;
1741	
1742	    if ( CHR! land MyBit )		! did it sneak in there ;
1743	     then SetFlg( ZAP! )		! yes, we may be back ;
1744	     else CleanUp;			! cleanup files etc. ;
1745	
1746	end "do cleanup";
1747	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 41
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1748	
1749	Simple Procedure FrameCheck;
1750	begin "frame check"
1751	    own safe integer array HSB[ 0:7 ];
1752	
1753	    ! ** This is what we get for sharing interrupts and either ** ;
1754	    ! ** condition is likely to occur by design or accident... ** ;
1755	
1756	    if ( !lh( Gettab( QQJ,!gtLIN ) ) )	! if have TTY ;
1757	     then "have port"			!  all ok -- really ECF ;
1758	     else begin "no port"		!  else really a zapper ;
1759		SetFlg( ZAP! );			! flag it ;
1760		if ( NeedZap land MyBit )	! are we waiting for it ;
1761		 then ClrFlg( ECF! );		!  yes -- clear wrong flag ;
1762		return;				!  and go ;
1763	     end "no port";
1764	
1765	    if ( QQF )				! frame number assigned? ;
1766	     then EcfDis( QQJ )			!  disable ecf interrupt ;
1767	     else LogInfo( "Spurious ECF for stream #"& cvs(MyJob) );
1768	
1769	    ClrFlg( ECF! );			! forget interrupt occurred ;
1770	    Logit( QFet$Jobs, "ECF for stream #"& cvs(MyJob) );
1771	
1772	    if ( NeedExit land MyBit )		! if waiting for exit ;
1773	     then begin "wait till done"
1774	
1775		ClrFlg( NeedExit );		! no longer waiting ;
1776	
1777		if Port[ MyJob ]		! we want to logout ;
1778		 then begin "say goodbye"
1779	
1780		    Buffer[ MyJob ]_ "LOGOUT" & #CR;
1781		    PrtEnb( Port[ MyJob ] );	! enable interrupts on port ;
1782		    SetFlg( ORG! );		! ready to send ;
1783		    SetFlg( NeedZap );		! wait for zap ;
1784		    return;			! back to main loop ;
1785	
1786		 end "say goodbye"
1787		 else LogInfo( "No port found ECF for stream #"& cvs(MyJob) );
1788	
1789	     end "wait till done"
1790	     else LogInfo( "Not waiting for ECF for stream #"& cvs(MyJob) );
1791	
1792	    CleanUp;				! why are we here??? ;
1793	
1794	end "frame check";
1795	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 42
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1796	
1797	Simple procedure ClearFile;
1798	begin "clear file"
1799	    string S;
1800	
1801	    if ( length( IChan[ MyJob ] ) )	! anything left to do? ;
1802	     then begin "are we done"
1803	
1804		Forget!Substitutions;		! clear current substitutions;
1805	
1806		while ( length( S_ VMLine( IChan[ MyJob ], Brk ) ) or ( Brk ) )
1807		 do DumpLog( S & Crlf );
1808	
1809		VMFree( IChan[ MyJob ] );	! Free the channel ;
1810	
1811		if ( 1 = length(IChan[MyJob]) ) or ( ERR! land MyBit )
1812		 then begin "clear slot"		! last eof or error ;
1813	
1814		    Escape;				! put into command mode ;
1815		    if ( Port[MyJob] )			! if port, send LOGOUT ;
1816		     then begin "logout job"
1817			Buffer[MyJob]_ "LOGOUT" & #cr;
1818			SetFlg( NeedZap );		! get ready for the end ;
1819		     end "logout job";
1820	
1821		    ClrFlg( DoParam );		! clear parametization ;
1822		    QQR_ QQT_ 0;		! and time/tru limits ;
1823	
1824		 end "clear slot";
1825	
1826		if not( (STOP! lor ERR! lor OverTime lor TRU!) land MyBit )
1827		 then lop( LineNo[ MyJob ] );	!  the line # for this file ;
1828	
1829		lop( IChan[ MyJob ] );		! clear out the channel and ;
1830		lop( Delim!list[ MyJob ] );	! lop off the last delimiter;
1831	
1832		if ( Delim!list[MyJob] neq Del!Chr[MyJob] )	! if mangled, then ;
1833		 then Set!Delimiter( Delim!list[MyJob] );	! reset from stack ;
1834	
1835	     end "are we done";
1836	
1837	 end "clear file";
1838	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 43
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1839	
1840	Simple Procedure PortLine;
1841	begin "port line"
1842	    Define LineLen = 64 * 10;		! constant length = 640 ;
1843	    Preset!with
1844		"################################################################" &
1845		"################################################################" &
1846		"################################################################" &
1847		"################################################################" &
1848		"################################################################" &
1849		"################################################################" &
1850		"################################################################" &
1851		"################################################################" &
1852		"################################################################" &
1853		"################################################################";
1854	    Own String array Line[0:0];
1855	    Own Integer Chan, MyLen, MyPtr, MyChr, MyPos;
1856	
1857	    Chan_ Ochan[MyJob];			! setup channel variable ;
1858	    MyChr_ ErrChr[MyJob];		! setup error character ;
1859	    MyPos_ ChrPos[MyJob];		! setup line position ;
1860	
1861	    begin!code
1862	
1863		Label Loop, NoMore;
1864		Define ax = '13, ch = '14, ct = '15, f = '1;
1865	
1866		Move	ax,Line[0];		! copy string pointer ;
1867		Movem	ax,MyPtr;		! save it for use ;
1868		Move	ax,MyJob;		! get job index ;
1869		Hrlz	ax,Port[0](ax);		! get port ;
1870		Hrri	ax,!axi8s;		! set to image mode skip ;
1871		Setzm	MyLen;			! start with null string ;
1872		Move	f,MyBit;		! get my bit flag ;
1873	Loop:	Auxcal	ax,ch;			! get a character ;
1874		  Jrst	NoMore;			! no more ;
1875		Jumpe	ch,Loop;		! ignore nulls ;
1876		Camn	ch,MyChr;		! error character ;
1877		Skipe	MyPos;			! yes, at beginning? ;
1878		 Caia;				! no, skip this ;
1879		  Iorm	f,DoError;		!  yes, set error seen ;
1880		Aos	MyPos;			! increment line position ;
1881		Caie	ch,'12;			! line feed? ;
1882		Cain	ch,'14;			! or form-feed ;
1883		  Setzm	MyPos;			!  then set newline ;
1884		Tdne	f,DoLog;		! if not logging or ;
1885		Skipn	Chan;			! if no channel open ;
1886		  Jrst	Loop;			! throw characters away ;
1887		Idpb	ch,MyPtr;		! deposit character ;
1888		Aos	ct,MyLen;		! count characters ;
1889		Caige	ct,LineLen;		! enough room? ;
1890		  Jrst	Loop;			! yes, go back for next ;
1891		 caia;				! no,  skip to finish ;
1892	NoMore:	Andcam	f,CHR!;			! no more characters ;
1893	     end;				! end begin!code ;
1894	
1895	    if ( MyLen )			! if any, put directly into file ;
1896	     then VMText(Chan, Line[0][1 for MyLen]);
1897	
1898	    ChrPos[MyJob]_ MyPos;		! remember line position ;
1899	
1900	!   Logit( QFet$Ports, "TTY"&cvos(Port[MyJob])&": "&Line[0][1 for MyLen] );
1901		
1902	end "port line";
1903	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 44
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1904	
1905	Simple Boolean Procedure OneLine;
1906	begin "one line"
1907	    own safe string array SavedLine[ 0 : E!JobMax ];
1908	    own safe integer array SavedBrk[ 0 : E!JobMax ];
1909	    string S, C;
1910	    integer Brk,Cmd;
1911	
1912	    if ( CHR! land MyBit )			! Output or Echo pending? ;
1913	     then return( true );			!  yes, take care of it ;
1914	
1915	    if ( ( STOP! lor ERR! lor TRU! lor OverTime ) land MyBit )
1916	     then return( false );			! return if error condition ;
1917	
1918	    if ( NeedEscape land MyBit )		! Are we waiting for ESC? ;
1919	     then begin "wait till next time"
1920		Escape;					! Do escape procedure ;
1921		return( true );				!  and come back later ;
1922	     end "wait till next time";
1923	
1924	    if ( length( Buffer[MyJob] ) )		! Do we have any leftovers? ;
1925	     then begin "process leftovers"
1926		S_ Scan( Buffer[MyJob], B!Cr, Brk );	! Get one line from buffer ;
1927		OutPtr( Port[MyJob], S );		!  and send it along ;
1928		return( true );				!  then return ;
1929	     end "process leftovers";
1930	
1931	    if ( length( IChan[MyJob] ) = 0 )		! Any input channel? ;
1932	     then return( false );			!  no -- skip this rot ;
1933	
1934	    if ( NeedBall land MyBit )			! waiting for a ball? ;
1935	     then begin "restore line"
1936		S_ SavedLine[ MyJob ];			! yes, retrieve line and ;
1937		Brk_ SavedBrk[ MyJob ];			!  the corresponding brk ;
1938	     end "restore line"
1939	     else S_ VMLine( IChan[MyJob], Brk );	! no, read line from file;
1940	
1941	    SavedLine[MyJob]_ S;			! always save line ;
1942	    SavedBrk[MyJob]_ Brk;			! and break character ;
1943	
1944	    if ( VMGetC(IChan[MyJob], VM$ECR) )		! Was there a crlf? ;
1945	     then C_ #Cr				!  yes, so make a string ;
1946	     else C_ Null;				!  no,  make it empty ;
1947	
1948	    if ( Length( S ) or Brk )			! End of File? If no line ;
1949	     then begin "got line"			! ignore Brk on saved line ;
1950	
1951		if not( NeedBall land MyBit )		! skip on repeated command ;
1952		 then LineNo[MyJob]_ LineNo[MyJob]+1 & LineNo[MyJob][2 to INF];
1953		if ( length( IChan[MyJob] ) = 1 )	! if main command file ;
1954		 then QQN_ LineNo[MyJob];		! copy for safekeeping ;
1955	
1956		If ( DoParam land MyBit )		! if substitutions enabled ;
1957		 then S_ Parametize(S);			!  then parametize the line ;
1958	
1959		Logit( QFet$Jobs lor QFet$Ports lor QFet$Subs,
1960		    "Stream #"&cvs(MyJob)&":("&cvs(LineNo[MyJob])&"): "& S );
1961	
1962		CheckLabel( S );			! is it a label? ;
1963	
1964		if ( S = (case LPForm( QQA ) of ( ":", ".", "@" )) )
1965		   and ( ChkCommand( S ) )		! if "known" command ;
1966		 then begin "known command"
1967		    Command( S );			!  then process ;
1968		    return( not( (STOP! lor ERR! ) land MyBit ) );
1969		 end "known command";
1970	
1971		if ( S = (case LPForm( QQA ) of ( ".", ".", "@" )) )
1972		 then begin "an escape"
1973		    Escape;				! put into exec and ;
1974		    Lop( S );				!  and remove esc char ;
1975		 end "an escape"
1976		 else if ( S = "=" or S = "*" )
1977			then begin "user mode"
1978			    if ( CommandMode )		! if at user level then ;
1979			     then DumpLog( S & Crlf );	! ** put into log? ** ;
1980			    if ( Lop( S ) = "=" )	! throw away char & compare ;EXECX.SAI                       created 09-Apr-87 15:43                                  Page 44.1
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1981			     then C_ Null;		! use either Null or CR ;
1982			end "user mode";
1983	
1984		OutPtr( Port[ MyJob ], S & C );		! send data to the job ;
1985		return( true );				! success! ;
1986	
1987	     end "got line"
1988	     else return( false );			! no line -- eof reached ;
1989	
1990	end "one line";
1991	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 45
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

1992	
1993	Simple Procedure FileLine;
1994	begin "each line"
1995	
1996	    if ( CHR! land MyBit )		! if we have chars to read ;
1997	     then return;			!  then don't do anything ;
1998	
1999	    if ( LPStat( QQS ) = ST$Proc )	! Job in-process ? ;
2000	     then begin "valid job slot"
2001	
2002		Case ( LPProc( QQS ) ) of	! Yes -- check state ;
2003		begin "each process type"
2004		    [PSP$Run]			! Run - normal mode ;
2005		    if ( QQF )			! if active frame ;
2006		     then if ( OneLine )	! check for data to job ;
2007			   then			! all is ok, nothing more to do ;
2008			   else ClearFile	! if end, clear file and go on. ;
2009		     else;			! log line to nonexistant frame ;
2010	
2011		    [PSP$Pause]			! Pause - wait at next statement ;
2012		    [PSP$Stop]			! Stop  - ^C/Halt job ;
2013			;			! do nothing if paused, stopped ;
2014	
2015		    [PSP$Restart]		! Restart - user/opr/job restart ;
2016		    [PSP$Cancel]		! Cancel  - user/opr abort job ;
2017		    if ( QQF )			! if active frame ;
2018		     then begin "finish job"
2019			while ( length( IChan[MyJob] ) )
2020			 do ClearFile;		!  clear file and set done flag ;
2021			if ( length( Buffer[MyJob] ) )
2022			 then OneLine;		!  send LOGOUT, etc. to line ;
2023		     end "finish job";
2024	
2025		    else
2026		end "each process type";
2027	
2028	     end "valid job slot"
2029	     else begin "invalid"
2030	
2031		LogInfo( "** invalid stream #"& cvs(MyJob) &" **" );
2032	
2033	     end "invalid";
2034	
2035	 end "each line";
2036	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 46
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

2037	
2038	Internal Simple Procedure GetInt( reference integer Flag; integer Why );
2039	begin "get int"
2040	    Own safe integer array Ports[ -1 : E!JobMax ];
2041	    Own Integer Idx, MyP, MyJ;
2042	
2043	    Arrclr( Ports );			! initialize data structure ;
2044	    Ports[-1]_ E!JobMax + 1;		! specify length of list ;
2045	    Idx_ Calli( Why + location(Ports[-1]), calli!POLPRT );
2046	    if not( !Skip! )			! if cannot read ports list ;
2047	     then return;			!  then ignore interrupt ;
2048	
2049	    While ( 0 leq Idx_ Idx - 1 )	! for each possible port ;
2050	     do if ( Ports[Idx] land Why )	! if condition set ;
2051		 then begin "find job port"
2052	
2053		    MyP_ !rh( Ports[Idx] );	! make it just a port ;
2054	
2055		    For MyJ_ 1 upto E!JobMax	! for each active job ;
2056		     do if ( Port[MyJ] = MyP )	! if the port matches ;
2057			 then begin "found one"
2058			    Flag_ Flag lor (1 lsh MyJ);	!  flag the port ;
2059			    done;		!  and finish loop ;
2060			 end "found one";
2061	
2062		 end "find job port";		! either port found or ignored ;
2063	
2064	end "get int";
2065	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 47
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

2066	
2067	simple procedure EveryMinute;
2068	begin "once a minute"
2069	    Own integer Date, Now;
2070	
2071	    SetTim( Minute );			! reset the watchdog timer ;
2072	    Minutes_ Minutes + 1;		! count the minutes ;
2073	
2074	    if ( !lh( GetTDT ) > Date )		! if new date, new files ;
2075	     then begin "setup new log"
2076		Date_ !lh( GetTDT );		! remember new date ;
2077		SetLog;				! set new YYMMDD name ;
2078	     end "setup new log";
2079	
2080	    QQ( Process )_ XEXJob;		! remember me? ;
2081	    QQ( HaveP )_ Gettab( XEXJob,!gtUID );
2082	
2083	    Now_ GetTDT;			! get current time ;
2084	    for MyJob_ 1 upto E!JobMax		! for each job ;
2085	     do begin "each job"
2086	
2087		NoBit_ lnot (MyBit_ 1 lsh MyJob);
2088	
2089		if ( 0 < QQT < Now )		! passed time limit? ;
2090		 then SetFlg( OverTime );	!  then mark the job ;
2091	
2092		if ( 0 < QQR < GetTRU( QQJ ) )	! passed TRU limit? ;
2093		 then SetFlg( TRU! );		!  then mark the job ;
2094	
2095	     end "each job";
2096	
2097	
2098	end "once a minute";
2099	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 48
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

2100	
2101	simple boolean procedure WaitForInterlock;
2102	begin "wait for interlock"
2103	
2104	    SetFeature( RProc );		! starting processor! ;
2105	    SetTim( 300 );			! wait 5 minutes (300 sec) ;
2106	    while not( TIM! )			! maximum for interlock ;
2107	     do begin "waiting"
2108	
2109		calli( 1, calli!SLEEP );	! sleep for a second ;
2110	
2111		if ( ClubInit( Club_ queAct lsh -9 ) )
2112		 then begin "got it"
2113	
2114		    if ( QQ( Process ) = 0 )		! no processor??? ;
2115		     then QQ( Process )_ XEXJob;	!  take it for me ;
2116	
2117		    QQ( ProcessUDT )_ QQ( HaveP );	! mark that I have it ;
2118		    QQ( Flags )_ QQ( Flags ) lor ( QF$Act lsh 18 );
2119	
2120		    LogInfo( "Got interlock" );		! let scheduler know ;
2121		    ClearFeature( RProc );		! starting processor ;
2122		    return( true );			! we're on our way ;
2123	
2124		 end "got it"
2125		 else Club_ !skip!;		! copy error code ;
2126	
2127	     end "waiting";
2128	
2129	    return( false );			! show our failure ;
2130	
2131	end "wait for interlock";
2132	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 49
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

2133	
2134	simple procedure SystemStartup;
2135	begin "system startup"
2136	
2137	    if not( OnlyMe )				! bogus EXECX running? ;
2138	     then Exit( "Processor already running" );	! sigh. ;
2139	
2140	    if not( OpnQue( que$Act ) )
2141	     then Exit( "Processor cannot access Job QUEUE" );
2142	
2143	    if not( ClubJoin(Club_ (queAct lsh -9)+1) )	! join club on ACT+1 page ;
2144	     then Exit( "No Club for Processor" );	!  or complain about it ;
2145	
2146	    if not( ClubInit(Club_ (queAct lsh -9)+1) )	! get interlock, nowait ;
2147	     then Exit( "Processor interlock in use" );	! or complain. ;
2148	
2149	    if not( ClubJoin( Club_ queAct lsh -9 ) )	! join club on ACT page ;
2150	     then Exit( "No Club for Processor" );	!  or complain about it ;
2151	
2152	    if not( ClubInit( Club_ queAct lsh -9 ) )	! get interlock, nowait ;
2153	     then begin "handshake"
2154	
2155		QQ( Flags )_ QQ( Flags ) land lnot ( QF$Act lsh 18 );
2156		if ( CBVPM# = Club_ !Skip! )		! bad page number ;
2157		 then Exit( "Processor not in club - bad page" );
2158		if ( CBAIL# = Club_ !Skip! )		! remember error code ;
2159		 then begin "notify"
2160	
2161		    QQ( Process )_ XEXJob;		! remember me? ;
2162		    QQ( HaveP )_ Gettab( XEXJob,!gtUID );
2163		    Loginfo( "Waiting for interlock" );	! notify scheduler & ;
2164		    if not( WaitForInterlock )		! wait for interlock ;
2165		     then Exit( "Processor Interlock Busy ("&cvos(Club)&")" );
2166	
2167		 end "notify"
2168		 else Exit( "Processor Interlock Error ("&Cvos(Club)&")" );
2169	
2170	     end "handshake"
2171	     else begin "got interlock"
2172	
2173		if ( QQ( Process ) = 0 )	! none? take it for me ;
2174		 then QQ( Process )_ XEXJob;
2175	
2176		QQ( ProcessUDT )_ QQ( HaveP )_ Gettab( XEXJob,!gtUID );
2177		QQ( Flags )_ QQ( Flags ) lor ( QF$Act lsh 18 );
2178	
2179	     end "got interlock";
2180	
2181	    LogInfo( cv6str( Gettab( -1,!gtNAM ) ) &" Job Processor "&
2182		     VersionString & " starting in frame "& cvs( XEXJob ) );
2183	    QQ( Flags )_ QQ( Flags ) lor ( QF$Log lsh 18 );
2184	
2185	    if ( TestFeature( Trigger ) )	! trigger software interrupts? ;
2186	     then SIAEnb;			! yes, enable interrupts ;
2187	    ESCEnb;				! enable trapping ESC/^C ;
2188	    NTQEnb;				! enable trapping NTQ ;
2189	
2190	end "system startup";
2191	
EXECX.SAI                       created 09-Apr-87 15:43                                  Page 50
Program Listing                 by CRFSYM %5 at 13-Apr-87 18:40

2192	
2193	!	M A I N   program
2194	;
2195	
2196	SystemStartup;				! crank it up to full ;
2197	SetTim( Minute );			! and start watchdog timer ;
2198	
2199	While ( QQ( HaveP )_ Gettab(XEXJob,!gtUID) )	! while we keep it honest ;
2200	 do begin "the system is running"		! proceed with the work ;
2201	
2202	    if ( TIM! )				! check watchdog timer ;
2203	     then EveryMinute;			!  time to look around ;
2204	
2205	    if ( LOS! lor CHR! lor ORG! lor ZAP! lor ECF!
2206		 lor OverTime lor TRU! lor ERR! )
2207	     then Logit( QFet$Ports lor QFet$Jobs,
2208			"Act: "& cvs( QQ( Active ) ) &" h "& Cvs(HighJob) &
2209			" O:"& cvos(ORG!) &" C:"& cvos(CHR!) &" L:"& cvos(LOS!) &
2210			" Z:"& cvos(ZAP!) &" E:"& cvos(ECF!) &
2211			" T:"& cvos(OverTime) &" Tru:"& cvos(TRU!) &
2212			" err:"& cvos(ERR!) );
2213	
2214	    if ( QQ( Active ) )			! anything happening? ;
2215	     then for MyJob_ 1 upto HighJob	! for each job slot ;
2216		   do begin "peddle wares"	!  do your thing ;
2217	
2218		    NoBit_ lnot(MyBit_1 lsh MyJob);	! setup logical flag bits ;
2219		    Minutes_ 0;				! clear timer ;
2220	
2221		    if ( ECF! land MyBit )	! if frame exit seen ;
2222		     then FrameCheck;		! verify status and terminate ;
2223	
2224		    if ( CHR! land MyBit )	! if output is available ;
2225		     then PortLine;		! read any data lines available ;
2226	
2227		    if ( ZAP! land MyBit )	! if circuit zaps seen ;
2228		     then Do!CleanUp;		!  close files, etc. ;
2229	
2230		    if ( ORG! land MyBit )	! if input requested ;
2231		     then FileLine;		! read any file lines available ;
2232	
2233		    if ( ( STOP! lor ERR! lor TRU! lor OverTime ) land MyBit )
2234		     then CleanUp;		! if limits exceeded - bye ;
2235	
2236		    if ( NTQ! or ESC! )  or	! if notice received or ;
2237		       ( TestFeature( Shut ) )	!    normal shut-down ;
2238		     then Cleanup;		!  shut everything down ;
2239	
2240		 end "peddle wares"
2241	     else if ( NTQ! or ESC! )  or	! if notice received or ;
2242		     ( TestFeature( Shut ) ) or	!    normal shut-down ;
2243		     ( not( QQ( Active ) ) and	!   check activity list ;
2244		       ( Minutes > 15 ) )	!   (no activity for 15?) ;
2245			 then done;		!    and exit if none ;
2246	
2247	    if not( SlotsAvailable )		! if no slots initialized ;
2248	     then calli( 5, calli!SLEEP );	!    sleep for awhile ;
2249	
2250	 end "the system is running";
2251	
2252	Exit( "Signing off." );
2253	
2254	end 	"EXECX" $
a
m