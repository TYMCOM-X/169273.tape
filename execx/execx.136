begin	"EXECX"

require "EXECX.INF" source!file;

Define EXECX!VERSION = (EXECX!!VER lsh 24) lor EXECX!!EDIT;
require EXECX!VERSION version;

require "

EXECX %"&CVOS(EXECX!VERSION lsh -24)&"("&CVOS(EXECX!VERSION land '777777)&")"&
     " - TYMCOM-X Periodic Processing Exec

Assembly: Load @EXECX.CMD

Sources:  EXECX.SAI                 Main program source file
          EXECX.INF                 Main release information file
          XEXEC.PAR                 Main parameter file
	  XEXEC.REQ                 Global declaration file
          SAIL.DEF                  General macro definition file
          UUOSYM.DEF                System call definition file
          JQUEUE.DEF                Job queue definition file

Library:  XEXSUB.REQ [SAI] [REL]    Main support routines
          JQUE.REQ   [SAI] [REL]    Job queue manipulation package
          XEXPKG.REQ [SAI] [REL]    Miscellaneous support package
          VMFILE.REQ [SAI] [REL]    VM input file mapping pacakge
          DAYTIM.REQ [SAI] [REL]    Date time conversion package
          XEXINT.REQ [SAI] [REL]    Interrupt package

License:  ALL license bits!!!
          WC RC SY OP GD TD ST JL AC XC HF RA WA

" message;

require "(SAILIB)SAIL.DEF" source!file;
require "(CARL)XEXEC.PAR"  source!file;
require "(MPL)UUOSYM.DEF"  source!file;
require "(CARL)JQUEUE.DEF" source!file;
require "(CARL)XEXSUB.REQ" source!file;
require "(CARL)XEXPKG.REQ" source!file;
require "(CARL)JQUE.REQ"   source!file;
require "(CARL)VMFILE.REQ" source!file;
require "(CARL)DAYTIM.REQ" source!file;
require "(CARL)XEXINT.REQ" source!file;

require 1000 new!items,  pnames;

!	Definitions
;

Define !gtRDV = '135, !gtRDI = '136, !gtRFN = '137;

Define Rec(x) = { memory[ASlot+(x)] };	! record element ;
Define Sleep!Time = !Xwd(1,3);		! sleep period between lines;

Define DoIf(Flg,Top) = {
    If (Flg) then for MyJob_ 1 upto (Top)
     do if ( (Flg) land (1 lsh MyJob) )
};

Define Complete = {"completed"};! successful completion;
Define Default!Ext = {".CTL"};	! default command file extension;
Define Uppercase(x) = {Scan(x, B!Up, Dummy)};
Define White(x) = {Scan(x, B!Wht, Brk)};

Define !Job(x)     = { ( (x) land '7777 ) };
Define Cvj(x)      = { cvs( !Job(x) ) };
Define Gettab(x,y) = { calli( !xwd( (x), (y) ), calli!GETTAB ) };
Define SetFlg(x,y) = { x_ x lor (1 lsh y) };
Define ClrFlg(x,y) = { x_ x land lnot(1 lsh y) };
Define NewLic(x,y) = { ( ((x lor y) land '777717777700)  lor
			 ((x land  '3) max (y land  '3)) lor
			 ((x land '14) max (y land '14)) ) };

Define DayStamp  = { cvSDat( !lh( GetTDT ) ) };		! day  only ;
Define TimeStamp = { cvSTim( !rh( GetTDT ) ) };		! time only ;
Define DateStamp = { TymDay( GetTDT ) };		! date-time ;

!	Command macro definitions
;

Define KQ(x,y) = 		     {	Kequ(x,CvPS(y))
    ifcr length( CvPS(y) ) > 3 thenc or Kequ(x,CvPS(y)[1 for 3]) endc
	};


Define AllCommands = {
    XC(AFTER)
    XC(BACKTO,    GOTO(CMD))
    XC(BACK,      GOTO(CMD))
    XC(CHECKPOINT,CHECKPOINT(CMD))
    XC(CHKPNT,    CHECKPOINT(CMD))
    XC(COM,       COM(CMD))
    XC(CONTINUE)
    XC(DEFINE,    REASSIGN(CMD))
    XC(ESCAPE,    ESCAPE)
    XC(FIND)
    XC(GOTO,      GOTO(CMD))
    XC(GO,        GOTO(CMD))
    XC(IF)
    XC(LOOK)
    XC(LOGFILE)
    XC(PAUSE,     PAUSE)
    XC(PARAMETERS,PARAMETERS(CMD))
    XC(QUIT,      QUIT)
    XC(REMARK)
    XC(RESTART,   RESTART(CMD))
    XC(SEND,      SEND(CMD))
    XC(STOP,      STOP)
    XC(TIME,      TIME(CMD))
    XC(UNLESS)
    XC(WAIT)
  };

!	Variable definitions for outer block;

Internal integer
	MyJob			! current job slot ;
,	XEXJob			! processor job slot ;
;

boolean
	ERR!, STOP!		! true when error occurrs or we stop;
,	TRU!			! true when the tru limit is exceeded;
,	NeedEscape		! true when waiting for command mode;
,	NeedZap			! true when waiting for zapper on job;
,	Logout			! true when need to logout ;
,	Quoted			! true if parameter is quoted [Get!Token];
,	DoParam			! true if $Substitutions;
,	DoNumerics		! true if $Numerics;
,	DoLog			! true if $Logging;
,	DoMail			! true if $Mail;
;

own integer 
	Seq			! current sequence number index;
,	Status			! current status of EXECX job;
;

string	S, Disposition		! temp and completion variables;
,	Error!Text		! reason for error;
;

!	Array definitions
;

  redefine CommandsLength = 0;
  redefine seperatorcharacter = {,};
  redefine XC(Text,Action) = {
    ifcr length( Cvps( Text ) ) thenc
      ifcr CommandsLength > 0 thenc seperatorcharacter endc
      redefine CommandsLength = CommandsLength + 1;
      Cvps( Text )
    endc
  };
Preset!with AllCommands;
Own safe string  array Commands[ 1 : CommandsLength ];

Own safe integer array OChan  [ 0 : E!JobMax ];	! Logfile channel ;
Own safe integer array PORT   [ 0 : E!JobMax ];	! port used for child i/o ;
Own safe integer array Limit  [ 0 : E!JobMax ];	! Timelimit ;
Own safe integer array Trus   [ 0 : E!JobMax ];	! TRU limit ;
Own safe integer array MakeLog[ 0 : E!JobMax ];	! Log file creation ;
Own safe integer array LogDisp[ 0 : E!JobMax ];	! Log file disposition ;
Own safe integer array MyMail [ 0 : E!JobMax ];	! Mail action info ;

Own safe string  array Delim!list[0:E!JobMax ];	! stack of delimiter chars ;
Own safe string  array Del!Chr[ 0 : E!JobMax ];	! delimiter character ;
Own safe string  array Buffer [ 0 : E!JobMax ];	! additional lines ;
Own safe string  array IChan  [ 0 : E!JobMax ];	! stack of nested input files ;
Own safe string  array LineNo [ 0 : E!JobMax ];	! input  file line number ;
Own safe string  array CmdFile[ 0 : E!JobMax ];	! input  file name ;
Own safe string  array LogFile[ 0 : E!JobMax ];	! output file name ;
Own safe string  array MyName [ 0 : E!JobMax ];	! login username ;
Own safe string  array MySelf [ 0 : E!JobMax ];	! GFD username ;

Safe list array Par!!List[0:E!JobMax ];		! List of ordered parameters ;
Safe list array Par!!Set[ 0:E!JobMax ];		! Lists of named parameters;
Safe list itemvar array Par!List[ 0:E!JobMax ];	! List of Ordered parameters;
Safe set  itemvar array Par!Set[ 0:E!JobMax ];	! Set of Named parameters;

!	System variable definitions - currently defined
;

string	Item
	$Daytime		! Current time-of-day;
,	$Hour,$Minute,$Second	! Current time-of-day pieces;
,	$HH,$SS			! Current time-of-day pieces;
,	$HHMMSS,$HHMM,$MMSS	! Current time-of-day combinations;
,	$Date			! Current date dd-mmm-yy;
,	$Day,$Month,$Year	! Current day(dd),month(month),year(yyyy);
,	$Mon			! Current month(mmm);
,	$DD,$MM,$YY		! Current day(dd),month(mm),year(yy);
,	$Weekday		! Day of week, Sunday---Saturday;
,	$Yesterday,$Tomorrow	! Day of week, Sunday---Saturday;
,	$Delimiter;		! Delimiter variable;

boolean	Item
	$False			! FALSE value;
,	$Logging		! Logging variable;
,	$Substitution		! Substitution variable;
,	$Mail			! Mail variable;
,	$Numerics		! Numeric results variable;
,	$True;			! TRUE value;

integer	Item
	$TimeLimit		! Current Time Limit variable;
,	$TruLimit;		! Current TRU limit variable;


!	Support routines
;

Simple Boolean Procedure ClearFrame( Integer This );
begin "clear frame"

    if ( QQF( This ) )			! anything here? ;
     then begin "frame must die"
	QQF( This )_ 0;			! clear frame position ;
     end "frame must die";

    if ( Port[ This ] )			! if any port assigned, zzzZap! ;
     then calli( Port[This], calli!ZAPCIR );

    return( false );			! give 'em what they came for ;

end "clear frame";


Simple procedure EXIT( String Msg(Null) );
begin
    own boolean Logout;

    EscDis;				! disable any interrrupts ;
    NtqDis;				! for ESC, NTQ ;
    SiaDis;				! and from frame ;

    LogInfo( Msg );			! notify them we have gone ;

    if ( InQue land que$Map )		! check for logoff flag ;
     then begin "last minute things"

	if ( XEXJob = !Job( QQ( Process ) ) and
	     QQ( HaveP ) = Gettab( XEXJob,!gtUID ) )
	 then QQ( HaveP )_ QQ( Process )_ 0;

	QQ( Feature )_ QQ( Feature ) land lnot QFet$Shut;

     end "last minute things";

    calli(queAct lsh -9, calli!CLBRLI);	! release interlock here ;
    calli(queAct lsh -9, calli!CLBLEV);	! leave club on ACT page ;
    ClsQue;

    if not( !lh( Gettab(-1,!gtLIN) ) )	! if no terminal attached ;
     then calli( 0, calli!LOGOFF )	!  then logout normally ;
     else start!code uuo!EXIT end;	!  else just exit ;

end;


Simple Boolean procedure JobExit(Integer Msg(0) );
begin

    If ( MyJob )			! if working on a job ;
     then begin "job exit"

	If ( Port[ MyJob ] )		! if there is a port ;
	 then PrtDis( Port[ MyJob ] );	! insure these are gone!!!!;
	ClearFrame( MyJob );		! send the frame away ;
	Dpb( Msg, PStap(QQS(MyJob)) );	! after recording error code ;

     end "job exit";

    return( false );

end;


!	Initialization routines;

simple procedure WhoShouldIBe;
begin
    LogWho( "Processor" );
    XEXJob_ calli( 0,calli!PJOB );
end;
require WhoShouldIBe initialization;


simple procedure LicenseCheck;
begin
    integer X;
    Define LicNeeded = Ifcr PRELIMINARY thenc '775617 elsec '777617 endc ;

    X_ !lh( Gettab( -1,!GTLIC ) );
    if ( LicNeeded land ( lnot X ) )
     then Exit( "Not enough license, Notify support group" );
end;
require LicenseCheck initialization;


procedure ParIni;
begin "parameter initialization"
    integer X;

    DoParam_ False;			! Insure no substitution;
    For X_ 0 upto E!JobMax
     do Delim!list[X]_ Del!Chr[X]_ "\";	! Default parameter escape;
    Setbreak( B!Quote_Getbreak,		! Initial breaktable for the;
		"\", null, "SINF");	!    parametization delimiter;
    Arrclr( Par!!List );		! Empty channel/file list;
    Arrclr( Par!!Set );			! Empty parameter set;
end;
require ParIni initialization;


simple procedure Fatal(String Msg);
begin

    if ( OChan[MyJob] > 0 )		! Else put into log file ;
     then VMText( OChan[MyJob], crlf & "?" & Msg &
	(If LineNo[MyJob] > 0
	  then " in line "&Cvs(LineNo[MyJob])
	  else "" ) & crlf );

    Error!Text _ Msg;
    SetFlg( ERR!, MyJob );
end;


procedure SetTimeLimit( Integer TimeLimit );
begin
    Limit[MyJob]_ If TimeLimit = 0
		   then 0
		   else Calli( 0,-'143 ) + (60 * TimeLimit);
    calli(!xwd(2,TimeLimit),calli!SETTIM);	! set timer interrupt;
end;


procedure Set!Delimiter( String Character );
begin
    Del!Chr[MyJob] _ Character[1 for 1];	! one character wi<dth;
    If Del!Chr[MyJob] = 0			! default to "\";
     then Del!Chr[MyJob]_ "\";			! change the delimiter list;
    Delim!list[MyJob]_Del!Chr[MyJob]&Delim!list[MyJob][2 to INF];
    Breakset(B!Quote, Del!Chr[MyJob], "I");	! change the break table;
  Logit( QFet$Subs," SetDelim("&Del!Chr[MyJob]&")["&Delim!list[MyJob]&"] ");
end;


simple procedure SYNC;
begin					! synchronize with slave;
    auxclv(PORT[MyJob],0,!axSYB);	! send yellow ball;
    If ( 0 < Trus[MyJob] < GetTRU(QQF(MyJob)) )
     then SetFlg( TRU!, MyJob );
end;


simple procedure OutPtr (integer PORT; string S);
! ----------------------------------------------------------------------;
!									;
!	OutPtr		Routine to pass a string to the specified	;
!			aux-port.  Sends a yellow ball after the	;
!			string to coordinate handshaking with the	;
!			port.						;
!									;
! ----------------------------------------------------------------------;
begin "out pointer"
    while ( length(S) )			! while something to do ;
     do auxclv(PORT,lop(S),!axO8);	! send a character ;
    SYNC;				! send yellow ball & synch ;
end "out pointer";
! begin!code	! could use this but it won't do image mode;
!	MOVEI	1,!AXOPC;		! output SAIL string;
!	HRL	1,PORT;
!	AUXCAL	1,-1(SP);		! output through pointer;
! end ;


String Procedure BoolToStr( Boolean T );	! Boolean to String;
Return( If T
    then If ( DoNumerics land (1 lsh MyJob) ) then "1" else "TRUE"
    else If ( DoNumerics land (1 lsh MyJob) ) then "0" else "FALSE"
	);

Boolean Procedure StrToBool( String S );	! String to Boolean;
Return( Kequ(S,"1") or Kequ(S,"TRUE"[1 for length(S)]) );


procedure RW!Item( String Itemvar W,R; Reference Boolean B);
begin
    If ( R neq any )
     then B_ StrToBool( Datum(R) );	! Set from source if there;
    If ( W neq any )
     then Datum(W)_ BoolToStr( B );	! Return to dest if there;
    Logit( QFet$Items, "RW!I " &
		(If R neq any then " R(" & Datum(R) & ")" else "") &
		(If W neq any then " W(" & Datum(W) & ")" else "")  );
end;


procedure RW!MyItem( String Itemvar W,R; Reference Boolean B);
begin
    If ( R neq any )
     then begin "source"		! Set from source if there;
	B_ B land lnot(1 lsh MyJob);	! clear bit first then ?set;
	B_ B lor  (StrToBool( Datum(R) ) lsh MyJob);
     end "source";
    If ( W neq any )			! Return to dest if there;
     then Datum(W)_ BoolToStr( B land (1 lsh MyJob) );
    Logit( QFet$Items, "RW!MyI " &
		(If R neq any then " R(" & Datum(R) & ")" else "") &
		(If W neq any then " W(" & Datum(W) & ")" else "")  );
end;


procedure Date$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 0 );

procedure Day$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 1 );

procedure Daytime$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & ":" & CvS(MM) & ":" & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Delimiter$(String Itemvar W, R);
Begin
    If R neq any then Set!Delimiter(Datum(R));	! change the delimiter;
    If W neq any then Datum(W)_ Del!Chr[MyJob];	! return the current setting;
end;

procedure False$( String Itemvar W, R);
RW!Item( W, any, FALSE);			! return FALSE;

procedure Hour$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(HH);
    end;
end;

procedure HH$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH);
	SetFormat(T,D);
    end;
end;

procedure HHMM$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & CvS(MM);
	SetFormat(T,D);
    end;
end;

procedure HHMMSS$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(HH) & CvS(MM) & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Logging$( String Itemvar W, R);
If MakeLog[MyJob]				! log file output state;
    then begin
	IntMak( Int!CHR );			! input chars interrupt;
!	ProcessOutput;
	RW!MyItem( W, R, DoLog );		! if LogFile R|W;
    end
    else RW!MyItem( W, any, DoLog );		! if not LogFile R-only;

procedure Mail$( String Itemvar W, R);
RW!MyItem( W, R, DoMail );			! sending mail;

procedure Minute$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(MM);
    end;
end;

procedure MMSS$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ CvS(MM) & Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure MM$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 7 );
procedure Mon$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 2 )[1 for 3];
procedure Month$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 2 );

procedure Numerics$( String Itemvar W, R);
RW!MyItem( W, R, DoNumerics );			! boolean representation;

procedure Second$( String Itemvar W, R);	! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Datum(W) _ CvS(SS);
    end;
end;

procedure SS$( String Itemvar W, R);		! Read-only * Time of day;
begin
    Integer T,D,HH,MM,SS;
    If W neq any then begin
	Timer( HH, MM, SS );
	Getformat(T,D); SetFormat(-2,0);
	Datum(W) _ Cvs(SS);
	SetFormat(T,D);
    end;
end;

procedure Substitution$( String Itemvar W, R);
RW!MyItem( W, R, DoParam );			! parameter substitution;

procedure TimeLimit$(String Itemvar W, R);
begin
    If R neq any then SetTimeLimit( Cvd(Datum(R)) );
    If W neq any then Datum( W ) _
	CvS(If Limit[MyJob] = 0
	     then 0
	     else (Limit[MyJob] - Calli(0,-'143)) div 60);
end;

procedure True$( String Itemvar W, R);
RW!Item( W, any, TRUE);				! return TRUE;

procedure Trulimit$( String Itemvar W, R);
begin
    If R neq any then Trus[MyJob]_ If Cvd( Datum(R) ) = 0
				    then 0
				    else GetTru(QQF(MyJob)) + Cvd( Datum(R) );
    If W neq any then Datum( W ) _ Cvs( If Trus[MyJob] = 0
				   then 0
				   else Trus[MyJob] - GetTru(QQF(MyJob)) );
end;

procedure Tomorrow$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 5 );
procedure Weekday$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 4 );
procedure Yesterday$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 6 );

procedure Year$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 3 );
procedure YY$( String Itemvar W, R);
If W neq any then Datum( W ) _ DatStr( 3 )[3 for 2];


procedure ItemIni;			! Alphabetical;
begin "procedure item initialization"
    Assign( $Date,       Date$);	! Current Date;
    Assign( $Day,        Day$);		! Current Day of Month;
    Assign( $Daytime,    Daytime$);	! Current Time of day;
    Assign( $DD,         Day$);		! Current Day of Month;
    Assign( $Delimiter,  Delimiter$);	! Delimiter value;
    Assign( $False,      False$);	! FALSE;
    Assign( $HH,         HH$);		! Current Hour of day 00-23;
    Assign( $HHMM,       HHMM$);	! Current Hour-minutes hhmm;
    Assign( $HHMMSS,     HHMMSS$);	! Current Hour-minutes-seconds;
    Assign( $Hour,       Hour$);	! Current Houray 0-23;
    Assign( $Logging,    Logging$);	! If logging to file;
    Assign( $Mail,       Mail$);	! If mail wanted at end;
    Assign( $Minute,     Minute$);	! Current Minutes of hour;
    Assign( $Mon,        Mon$);		! Current Month as Mmm;
    Assign( $Month,      Month$);	! Current Month of year;
    Assign( $MM,         MM$);		! Current Month as numeric;
    Assign( $MMSS,       MMSS$);	! Current Minutes-seconds;
    Assign( $Numerics,   Numerics$);	! If booleans are 1/0 or TRUE/FALSE;
    Assign( $Second,     Second$);	! Current seconds of minute;
    Assign( $SS,         SS$);		! Current seconds of minute SS;
    Assign($Substitution,Substitution$);! If parameter substitutions on;
    Assign( $Timelimit,  Timelimit$);	! Time-limit remaining (Minutes);
    Assign( $True,       True$);	! TRUE;
    Assign( $Trulimit,   Trulimit$);	! TRU-limit remaining (TRUs);
    Assign( $Weekday,    Weekday$);	! Day of Week;
    Assign( $Year,       Year$);	! Current Year;
    Assign( $YY,         YY$);		! Current Year as two digits;
end;
require ItemIni initialization;

procedure MOV ( itemvar DST,SRC );
begin
    string item TMP;
    own string itemvar SI;
    own real itemvar RI;
    own integer itemvar II;
    own integer BRK;
Logit( QFet$Items,
    "Mov: SRC["&cvs(typeit(SRC))&"] ==> DST["&cvs(typeit(dst))&"] " );

    case typeit(SRC) of begin		! Convert ??? to string;
	[3] "string   " datum(TMP)_ datum(SI_SRC);
	[4] "real     " datum(TMP)_ cvf(datum(RI_SRC));
	[5] "integer  " datum(TMP)_ cvs(datum(II_SRC));
	[8] "procedure" apply( datum(SRC), arg!list(TMP,any) );
	else usererr( typeit(SRC),2,"?MOV: can't coerce src type " )
    end;
    case typeit(DST) of begin		! Convert string to ???;
	[3] "string   " datum(SI_DST)_ datum(TMP);
	[4] "real     " datum(RI_DST)_ realscan(datum(TMP),BRK);
	[5] "integer  " datum(II_DST)_ intscan(datum(TMP),BRK);
	[8] "procedure" apply( datum(DST), arg!list(any,TMP) );
	else usererr( typeit(DST),2,"?MOV: can't coerce dst type " )
    end;
end;

String procedure Substitute(Integer Chan; String Key);
begin
    String Item SITM;    String Itemvar SI;    Boolean Not!Defined;
    Integer Dummy;		! used in UPPERCASE macro ;

    Key _ Uppercase(Key);			! make sure this works;
    If Key neq "$" then Key _ Chan & Key;	! user keyword? ;
    SI _ Cvsi(Key, Not!Defined);		! lookup variable;
    If Not!Defined then Return( Null );		! return null if undefined;
    MOV( SITM, SI );				! convert ITM _ SI;
    Return( Datum(SITM) );			! return string;
end;

simple string procedure Get!Token(Reference string Par!Lst);
begin "get a parameter"
    String S, Old!Brk;
    Integer InQuote, Save!Brk;

    White( Par!Lst );					! Clear whitespace;
    Quoted _ False;					! Initialize flag;
    S _ Scan(Par!Lst, B!Sub, Brk);			! Get Token;
    If Brk = '177 or Brk = '42 or BRK = "'"
      then begin "in quote"				! We found a quote;
        Quoted _ InQuote _ True;    Save!Brk _ Brk;	! For matching pair;
	If Length(S) then begin				! not allowed yet;
	    Fatal("parameter text """&S&""" discarded");
	    S _ null;
	end;
	Old!Brk _ null;					! Start anew;
	While InQuote do begin "Matching quote"		! Match quotes! ;
	    S _ S & Old!Brk & Scan(Par!Lst, B!Sub, Brk);! Ignore other breaks;
	    If Brk = '42 and Save!Brk = '42 or		! Check for pairs;
	       Brk = "'" and Save!Brk = "'" or		!    of each type;
	       Brk = '177 and Save!Brk = '177		!    "for child";
		then If Brk = Par!Lst			! Match! Double?;
		    then begin "quote quote"		!  Yes - handle "";
			Old!Brk _ Null;			!   Clear break!char;
			S _ S & Lop(Par!Lst);		!   Add to string;
		    end "quote quote"			!  Continue;
		    else begin "done quote"		!  Not double - ;
			InQuote _ False;		! Set we are done;
			White( Par!Lst );		! Clear Whitespace;
			Scan(Par!Lst, B!Sub, Brk);	! Eat to next break*;
		    end "done quote"
		else Old!Brk _ If Brk = 0 then Null else Null & Brk;
	    If length(Par!Lst) = 0 then Done;		! If missing quote?;
	end "Matching quote";
      end "in quote";


!
  * --	It would be nice at this point to allow some kind of combination
	or other parameter tricks.  However... not so decided...  (YET)
;
    If Brk = "/" then Par!Lst _ "/" & Par!Lst;		! restore "/";
    If Brk = " " or Brk = #ht then begin
	White( Par!Lst );				! Clear whitespace;
	If Brk = "=" or Brk = ","			! Eat certain breaks;
	    then Brk _ Lop( Par!Lst );			!  so things work;
    end;
    Return(If Length( S ) then S else null);		! Return something;
end "get a parameter";

Procedure New!Parameter(Integer Chan; String Name, Initial!Value, New!Value);
begin
    String Itemvar SI;
    String Item ITM;
    Own Boolean Not!Defined;
    Integer Dummy;			! used in UPPERCASE macro ;

    Name _ Uppercase(Name);				! Force upper-case;
    If Name neq "$" then Name _ Chan & Name;		! Maybe add channel;
    Logit( QFet$Items,
	"NewP: "&Name&" ("&initial!value&") N("&New!value&")" );

    SI _ Cvsi( Name, Not!Defined);			! See if PNAME exists;
    If Not!Defined then begin				! No, then;
	If Name = "$" then begin "don't allow $ vars"	!   if system var?;
	    Fatal("Illegal variable name """&Name&"""");!   illegal not found;
	    Return;					!     so bug out.;
	end;						!   else;
	New!Pname(SI _ New(Initial!Value), Name);	!     define it;
	Par!Set[MyJob] _ Lop(Par!!Set[MyJob]);		! Get current set;
	Put SI in Datum( Par!Set[MyJob] );		! Put new item in set;
	Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! Put set away;
    end;
    If length(New!Value) then begin			! If something there;
	Datum( ITM ) _ New!Value;			!   store as string;
	MOV( SI, ITM );					!   mov SI _ ITM;
    end;
    Logit( QFet$Items,
	" Pname[ "& Cvis( SI, Not!defined ) &" ]" );
end;


simple procedure Set!Parameter(Reference string Par!Lst);
begin "build substitution table"
    String Par!,Name;    String Itemvar SI;
    Integer Par!Index;   Boolean Named!Parameters;

    Par!Set[MyJob]  _ New(Phi);				! Empty set;
    Put Par!Set[MyJob] in Par!!Set[MyJob] before 1;	! First item in list;
    Par!List[MyJob] _ New(Nil);				! Empty list;
    Named!Parameters _ False;				! None at first;
    While Length(Par!Lst)
     do begin "reading parameters"
	Name _ null;					! Clear name;
	Par! _ Get!Token( Par!Lst );			! Read a parameter;
	If Brk = "=" then begin "named parameters"	! Assignment!;
	    If Quoted then				! To a string?;
		Fatal("Assignment to string """&Par!&"""");
	    Named!Parameters _ True;			!   Set flag;
	    Name _ Scan( Par!, B!Par, Brk );		!   Set name;
	    If Length(Par!) then begin			!   Error if non-null;
		Fatal("Illegal character """&Brk&	!     print message;
			""" in parameter");
		Name _ null;				!     clear name;
	    end;
	    Par! _ Get!Token( Par!Lst );		!   Set parameter;
	end "named parameters";

Logit( QFet$Items,
    "List: {"&Name&"}={"&Par!&"}" &
    cvs(Length(name))&":"&cvs(Length(par!)) );

	If ( Length( Name ) ) then begin		! Named parameter;
	    SetFlg( DoParam, MyJob );			! Set flag true;
	    New!Parameter(IChan[MyJob],Name,Null,Par!)	! Create parameter;
	  end
	  else begin					! Ordered parameter;
	    If ( Named!parameters ) then Fatal(		!   ** ERROR **;
	     "Ordered parameter after Named parameter ignored: """&Par!&"""")
	    else begin
		SetFlg( DoParam, MyJob );		! Set flag true;
		SI _ New( Par! );			!   create item;
		Put SI in Datum(Par!List[MyJob]) after INF;  ! Put into list;
	    end;
	end;
    end "reading parameters";
    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! First item in list;
end "build substitution table";

Procedure Forget!substitutions;
begin
    String Itemvar SI;

    If Length( Par!!List[MyJob] ) or Length( Par!!Set[MyJob] )
     then Logit( QFet$Subs lor QFet$Items, "Stream #"&cvs(MyJob)&" Forget: " );

    If Length( Par!!List[MyJob] )
     then begin "zap list by 1"
	Par!List[MyJob] _ Lop( Par!!List[MyJob] );
	While Length( Datum(Par!List[MyJob]) )
	 do begin "ordered"
	    SI _ Lop( Datum(Par!List[MyJob]) );
	    Logit( QFet$Subs lor QFet$Items, " ${"& Datum(SI) &"}" );
	    Delete( SI );
	 end "ordered";
	Delete( Par!List[MyJob] );
     end "zap list by 1";
    If Length( Par!!Set[MyJob] )
     then begin "zap set by 1"
	Par!Set[MyJob] _ Lop( Par!!Set[MyJob] );
	While Length( Datum(Par!Set[MyJob]) )
	 do begin "named"
	    SI _ Lop( Datum(Par!Set[MyJob]) );
		begin
		    String PN; Integer Dummy;
		    PN _ Cvis( SI, dummy );
		    If PN < " " then PN _ "<"&CVOS(LOP(PN))&">" & PN;
		    Logit( QFet$Subs lor QFet$Items,
			  " "& PN &"{"& Datum(SI) &"}"  );
		end;
	    Del!Pname( SI );
	    Delete( SI );
	 end "named";
	Delete( Par!Set[MyJob] );
     end "zap set by 1";

end;


String procedure parametize(Value String S);
begin "parameter substitution"
    String L, Key;    Integer Par!Chr;

    Logit( QFet$Subs, "R("&cvs(MyJob)&"): "& S );

    L _ Null;					! Newline;
    While ( Length(S) )				! While we have a string ;
     do begin "have string"
      L_ L & Scan(S, B!Quote, Brk);		! Scan for a parameter;
      If ( Brk = Del!Chr[MyJob] )		! Null?;
       then begin "got one"
	Par!Chr_ Lop(S);			! Get next char;
	If ( Par!Chr = Del!Chr[MyJob] )		! Do we have quote quote?;
	  then L_ L & Par!chr			!  Yes, use a quote here;
	  else begin				!  No. ;
	    Key_ Par!Chr & Scan(S,B!Par,Brk);	!   Read keyword;
	    If ( Brk = Del!Chr[MyJob] )		! If followed by quote;
	     then Par!Chr_ Lop(S);		!   eat the quote;
	    L_L & Substitute(IChan[MyJob],Key);	!   Perform substitution;
	    Logit( QFet$Subs, "Par: Key("& key &") <= """ &
		    Substitute(IChan[MyJob],key) &"""" );
	  end;
      end "got one";				! Done parameter;
    end "have string";				! Done Line;
    Logit( QFet$Subs, "P("&cvs(MyJob)&"): "& L );
    Return (L);					! So, Return it;
End;
	

simple boolean procedure MyCommand(String KW);
Return( BRK = "=" or length( KW ) = 0 or
       (Kq(KW,AFTER) or Kq(KW,CHECKPOINT) or Kq(KW,CHKPNT) or
	Kq(KW,COM) or Kq(KW,CONTINUE) or Kq(KW,DEFINE) or
	Kq(KW,ESCAPE) or Kq(KW,FIND) or Kq(KW,GO) or Kequ(KW,"GOTO") or
	Kq(KW,IF) or Kq(KW,LOOK) or Kq(KW,PAUSE) or Kq(KW,PARAMETERS) or
	Kq(KW,QUIT) or Kq(KW,REMARK) or Kq(KW,RESTART) or Kq(KW,SEND) or
	Kq(KW,STOP) or Kq(KW,TIME) or Kq(KW,UNLESS) or Kq(KW,WAIT)
	)
    );

simple boolean procedure ChkCommand( String Str );
begin "check command"
    String S, KW;
    Boolean Eof;

    if ( Str = "." or Str = "-" or Str = "@" )
     then lop( Str );			! remove leading character ;

    S_ Tok( Str );			! get a small parcel ;

    If ( Brk = ":" )
     then return( true );		! seems to be a label ;

    If ( Brk = "=" )
     then return( true );		! seems to be a definition ;

    return( MyCommand( S ) );		! some "known" command? ;

end "check command";


simple boolean procedure Create!Child( integer Cradle );
begin "birth procedure"
    Redefine CF!LIC = !bit(16);		! until UUOSYM.DEF is right;
    Redefine CF!LOG = 0;		! really !bit(17);

    memory[Cradle+E!Runtime]_ CF!LIC lor CF!LOG lor (E!License-E!Runtime-1);

    begin!code				! take a trip to the hospital ;
	Setom	!skip!;			! skip return;
	Hrli	1,!foCFM;		! function: create frame;
	Move	2,Cradle;		! get starting point;
	Addi	2,E!Runtime;		!  and offset ;
	uuo!FRMOP 1,(2);		! attempt to bear a child;
	  Setzm	!skip!;			!   unbearable!;
	Skipn	!skip!;			! successful birth? ;
	  Exch	1,!skip!;		! no, swap error code ;
    end;

end "birth procedure";


Simple boolean procedure SPROUT( Boolean NeedPort; Integer Cradle );
begin
    Own integer MyPort,APort;
    Own Safe Integer Array Pty[0:1];

    if ( NeedPort )			! does this job require a port ;
     then begin "need a port"		! yes, so setup a PTY-pair ;

	APort _ calli(0,calli!CREPTY);	! create the PTYs ;
	if not( !SKIP! )		! failed? ;
	 then return( false );		! then go home ;

	Port[MyJob]_MyPort_ !lh(APort);	! my pty port to remember ;

     end "need a port";

    If ( QQF(MyJob)_ Create!child( Cradle ) )		! create a frame;
     then QQU(MyJob)_ Gettab( QQF(MyJob),!gtUID )	! remember name;
     else return( false );				! else go home ;

    if ( NeedPort )
     then begin "transfer port"

	auxcli(MyPort,'214,!axCFS);	! we are in image no echo;
	auxclv(MyPort,1,!axSOX);	! expand tabs for output ;

	Pty[0]_ !Xwd( -1,QQF(MyJob) );	! from self to child ;
	Pty[1]_ !Xwd( '200000,APort );	!  using this port ;
	calli( location(Pty[0]), calli!RETACH );

	if not( !SKIP! )		! can't attach port? ;
	 then return( false );		! go home ;

	PrtEnb( MyPort );		! enable interrupts on port ;

     end "transfer port";

    return( true );

end;

simple boolean procedure FrontEnd;
begin "FrontEnd"
    own integer Array F[1:6];
    integer C, Chan, PBP, RunFlag, FileLicense, ASlot;
    string Name, Cmd, Log, S;

    ASlot_ QueAct + E!Length * (MyJob - 1);
    LogInfo( "Stream #" & cvs(MyJob) & " " & InfJob( ASlot ) );

    if ( LPProc(QQS(MyJob)) )		! if not initial status ;
     then Cmd_ CmdFile[ MyJob ]		!  then set up cmd name ;
     else begin "new job"		!  else do all the work ;

	CmdFile[ MyJob ]_		! copy string into cmdfile ;
	Cmd_ InfNam( ASlot+E!CmdFile );

	MyName[MyJob]_ cv6str(Rec(E!Username)) & cv6str(Rec(E!Username+1));

	If ( Rec( E!AUN ) = Rec( E!PPN ) )		! if same ppn/aun ;
	 then MySelf[MyJob]_ MyName[MyJob]		!  then copy name ;
	 else MySelf[MyJob]_ cvName(Rec( E!PPN ));	!  else generate. ;

     end "new job";

!	setup input file
;
    IChan[MyJob]_ VMFile( Cmd, VM$Read );	! open input file. ;
    if ( IChan[MyJob] leq 0 )			! if not available ;
     then begin "no input file"
	Dpb( !rh(IChan[MyJob]), PFErr(QQS(MyJob)) );
	LogInfo( "Stream #"& cvs(MyJob) &" no input file ("&
		 cvos(!rh(IChan[MyJob])) &") "& Cmd );
	return( JobExit( Abort$Input ) );
     end "no input file";

    If ( FileLicense_ VMGetC( IChan[MyJob],VM$Lic ) )	! if license, use it;
     then Rec( E!License )_ NewLic( Rec(E!License), FileLicense );

    If ( RunFlag_ LAPRunF( ASlot ) )		! if RUN program  ;
     then VMFree( Lop( IChan[MyJob] ) );	!  close file now ;

!	Create frame & determine if PTY needed here.
;
    if ( LPProc(QQS(MyJob)) leq PSS$Frame )
     then begin "new frame"
	If not( Sprout( LAPDetF(ASlot) = 0, ASlot+E!Runtime ) )
	 then begin "try later"
	    if ( !rh(!skip!) < 2 )		! waiting for frame? ;
	     then dpb( PSS$Frame,PProc(QQS(MyJob)) )
	     else dpb( Abort$Frame, PStap(QQS(MyJob)) );
	    LogInfo( "Stream #"& cvs(MyJob) &" no frame available" );
	    return( ClearFrame( MyJob ) );	! if error then give up ;
	 end "try later"
     end "new frame";

!	Handle parameters here.  Note: Do this even if no parameters. ;

    S_ null;
    If ( Rec( E!Parameters ) )		! some parameters ;
     then begin "build line"
	PBP_ point( 7,Rec(E!Parameters),-1 );
	While ( C_ILdb(PBP) ) do S_ S & C;
	Logit( QFet$Pars, "Parameters: "& S );
     end "build line";

    Set!Parameter(S);			! scan thru EOL;

    MakeLog[MyJob]_ LAPLog( ASlot );	! LogFile?;
    If ( MakeLog[MyJob] )		! If log file wanted ;
     then SetFlg( DoLog, MyJob )	!  then set flag ;
     else ClrFlg( DoLog, MyJob );	!  else clear flag ;

    LogDisp[MyJob]_ LAPDisp( ASlot );	! Log-Disp? ;

    Log_ InfNam( ASlot+E!LogFile );


!	open LOG file
;
    if ( ( DoLog land (1 lsh MyJob) ) )			! making a log file? ;
     then begin "get log file"

	If ( JL$Append leq MakeLog[MyJob] leq JL$Supersede )	! if logging ;
	 then begin "open LogFile"			!  setup file ;

	    If ( MakeLog[MyJob] = JL$Supersede )	! if supercede? ;
	     then begin "supercede"
		Chan_ VMFile( Log, VM$Write );		! $Write (re-open) ;
		If ( Chan > 0 )				! if no errors ;
		 then VMFree( Chan )			!  close it! (done) ;
		 else begin "enter error"		!  write failure? ;
		    Dpb( !rh(Chan), PFErr(QQS(MyJob)) );
		    return( JobExit( Abort$Enter ) );
		 end "enter error";
	     end "supercede";

	    Chan_ VMFile( Log,
		    (if MakeLog[MyJob] = JL$Append then VM$Append else 0)
		    lor VM$Update );			! $Update ;
	    if ( Chan leq 0 )				! all ok? ;
	     then begin "update error"			! failure ;
		Dpb( !rh(Chan), PFErr(QQS(MyJob)) );
		return( JobExit( Abort$Update ) );
	     end "update error";

	 end "open LogFile"
	 else begin "spool LogFile"
	    ! not implemented in the monitor;	! ** Future LPT: ** ;
	 end "spool LogFile";

	OChan[ MyJob ]_ Chan;		! store proper output channel ;
	LogFile[ MyJob ]_ Log;		! store name of logfile ;

    end "get log file";

    MyMail[MyJob]_ LAPMail( ASlot );	! Mail action;
    If ( MyMail[MyJob] )		! If any mail wanted ;
     then SetFlg( DoMail, MyJob )	!  then set flag ;
     else ClrFlg( DoMail, MyJob );	!  else clear flag ;

    SetFlg( DoNumerics, MyJob );	! Default setting ;
    SetTimeLimit( LAPTimL( ASlot ) );	! timeout in minutes;
    Trus[MyJob]_ Rec( E!TruLim );	! set user TRU limit;

    ClrFlg( NeedZap, MyJob );		! restore initial Zap state ;
    ClrFlg( NeedEscape, MyJob );	! restore initial Escape state ;
    Buffer[ MyJob ]_ Null;		! clear type-ahead msg buffer ;

  return( true );

end "FrontEnd";


procedure REASSIGN (string CMD);
begin "DEFINE COMMAND"
    string  Key, Val, Expr;

    While Length(CMD) do begin "scanning parameters"
	White( CMD );					! Clear whitespace;
	Key _ Scan( CMD, B!Par, Brk);			! Get name;
	Logit( QFet$Pars lor QFet$Items,
		" Key("& Key &") Break("& Brk &")["& cvs(Brk) &
		"] CMD: "& CMD );
	If Brk = " " or Brk = #HT then White( Cmd );	! Eat whitestuff;
	If Brk = "=" then begin
	    Lop( CMD );					! Eat = ;
	    Expr _ Get!Token(CMD);			! Read next token;
	    Logit( QFet$Pars lor QFet$Items,
		" Expr("& Expr &") Break("& Brk &")["& cvs(Brk) &
		"] CMD: "& CMD );
	    If not (quoted or Numeric(Expr) ) then begin
		Val _ Scan(Expr,B!Par,Brk);
		If length(Expr) then Fatal(
		    "Illegal character """&Brk&""" in parameter name")
		  else begin
		    Expr _ Substitute( IChan[MyJob], Val );
		    New!Parameter(IChan[MyJob], Key, Null, Expr )
		  end;
	    end
	    else New!Parameter(IChan[MyJob], Key, Null, Expr )
	end
	else begin
	    Fatal("Illegal format in assignment """&Brk&Cmd&"""");
	    Logit( QFet$Pars lor QFet$Items,
		" Key("& Key &") Break("& Brk &")["& cvs(Brk) &
		"] CMD: "& CMD );
	    Done;
	end;
    end "scanning parameters";
end "DEFINE COMMAND";


simple procedure CHECKPOINT( string CMD );
begin "CHECKPOINT"
    integer ASlot;

    ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
    Dpb( CvSIX(Get!Token(CMD)), Rec(E!Label) );	! set label - if any ;
end "CHECKPOINT";


procedure COM (string CMD);
begin "COM COMMAND"
    Integer Chan;
    String Name, Dev;
    Boolean Ext!Found, File!Error;

    Name _ GetFil(CMD, Dev_ "DSK", Ext!Found, File!Error);	! read off filename;
    If ( File!Error ) then begin		! If error...;
	Fatal("COM Filename error """&Name&"""");
      end
      else begin				! add delimiter to list;
	Delim!list[MyJob]_ Del!Chr[MyJob] & Delim!list[MyJob];
	Set!Parameter(CMD);			! NOW setup parameters;
	Chan_ VMFile( Name );
	If ( Chan leq 0 ) and not Ext!Found	! if not there, then;
	 then Chan_ VMFile(Name&Default!Ext);	!  try other extension;
	If ( Chan leq 0 )
	 then Fatal( "COM File error ("&Cvs(!rh(Chan))&") for file: "&Name);
	IChan[MyJob] _ Chan & IChan[MyJob];	! add channel to list;
    end;
end;


Simple Boolean Procedure CommandMode;
return( calli( !Xwd( QQF(MyJob),!gtSTS ), calli!GETTAB ) geq 0 );


procedure ESCAPE;
begin "Escape"

    if ( CommandMode )				! if command mode ;
     then ClrFlg( NeedEscape, MyJob )		!  clear escape   ;
     else begin "halt frame"
	DEFINE !FOSTP = '41;
	FrmXct( QQF(MyJob), 0, !foSTP );	! stop the frame  ;
	SetFlg( NeedEscape, MyJob );		!  set NeedEscape ;
     end "halt frame";

    SYNC;

end "Escape";


Simple Procedure GOTO (string CMD);
if ( IChan[MyJob] > 0 )
 then begin "GOTO COMMAND"
    string S, SS, ST;
    integer Where;

    S _ "::" & (ST_ Tok( CMD ));		! Define label = ::name ;
    SS_ ST & ":";				!  also label = name: ;

    do begin "scanning file"

	LineNo[MyJob]_ LineNo[MyJob]+1 & LineNo[MyJob][2 to INF];
	ST _ null;				! Count source file lines;
	Where_ VMGetC( IChan[MyJob] );		! Remember start point ;

	Do ST_ ST & VMLine( IChan[MyJob], Brk )	! Read a line of the file;
	 until ( BRK = #lf ) or ( Brk = 0 );

	if Kequ( S, ST )			! Compare ::name to ST ;
	  or Kequ( SS, ST[1 for length(SS)] )	! Compare name: to ST ;
	  or Kequ( SS_ SS & ":", ST[1 for length(SS)] )	! or name:: ;
	 then begin "got label"
	    VMSetC( IChan[MyJob], Where );	! Reset to start of line ;
	    return;				! If match, then "found";
	 end "got label"
	 else if ( OChan[MyJob] > 0 )		! Else put into log file ;
	       then VMText( OChan[MyJob], ST & Crlf );

     end "scanning file" until ( Brk = 0 );

    Fatal("end of file while scanning for label """&S&"""");

end "GOTO COMMAND";


Simple Procedure BackTo (string CMD);
if ( IChan[MyJob] > 0 )
 then begin "BACKTO COMMAND"

    string S, SS, ST;
    integer Where;

    S _ "::" & (ST_ Tok( CMD ));		! Define label = ::name ;
    SS_ ST & ":";				!  also label = name: ;

    do begin "scanning file"

	LineNo[MyJob]_ LineNo[MyJob]-1 & LineNo[MyJob][2 to INF];
	ST _ null;				! Count source file lines;

	Do ST_ ST & VMLine(IChan[MyJob],Brk,-1)	! Read a line of the file;
	 until ( BRK = #lf ) or ( Brk = 0 );

	if Kequ( S, ST )			! Compare ::name to ST ;
	  or Kequ( SS, ST[1 for length(SS)] )	! Compare name: to ST ;
	  or Kequ( SS_ SS & ":", ST[1 for length(SS)] )	! or name:: ;
	 then return;				! If match, then "found";

     end "scanning file" until ( Brk = 0 );

    Fatal("end of file while scanning for label """&S&"""");

end "BACKTO COMMAND";



procedure PARAMETERS(String CMD);
begin "PARAMETERS COMMAND"
    string Key, Par!Default, Par!Value;    String Itemvar SI;

    SetFlg( DoParam, MyJob );				! Set flag true;
    Par!List[MyJob] _ Lop( Par!!List[MyJob] );		! Get ordered list;
    While Length(CMD)
     do begin "scanning parameter names"
	Key _ Get!Token(CMD);				! Name;
	Par!Default _ If Brk = "=" or Brk = "_"		! Parameter or null;
	    then Get!Token(CMD)
	    else Null;
	If Length( Datum(Par!List[MyJob]) )		! If any in list;
	 then begin
	    SI _ Lop( Datum(Par!List[MyJob]) );		! Get Item;
	    Par!Value _ Datum( SI );			! Get string value;
	    Delete( SI );				! No longer needed;
	 end
	 else Par!Value _ Null;				! Get null value;
	New!Parameter(IChan[MyJob], Key, Par!Default, Par!Value );
     end "scanning parameter names";
    Put Par!List[MyJob] in Par!!List[MyJob] before 1;	! Restore list;
end "PARAMETERS COMMAND";


simple procedure PAUSE;
begin "PAUSE"
    Dpb( PSP$Pause, PProc(QQS(MyJob)) );
end "PAUSE";


simple procedure QUIT;
SetFlg( STOP!, MyJob );


simple procedure RESTART( string CMD );
begin "RESTART"
    Own integer ASlot;
    ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
    Dpb( CvSIX(Get!Token(CMD)), Rec(E!Label) );	! change label - if any ;
    Dpb( PSP$Restart, PProc(QQS(MyJob)) );	! set restart flag ;
end "RESTART";


procedure SEND (string CMD);
begin	"SEND"
    string KW;
    KW _ Get!Token(CMD);
    If ( quoted )
     then KW _ Brk&KW&Brk;		! restore quoted string ;
    If Kequ(KW,"CHARACTER"[1 for length(KW)]) then begin
	    integer K;
	    K _ Cvo(CMD);
	    Logit( QFet$Strs, "SEND "&KW&" '"& Cvos(K) );
	    auxclv(PORT[MyJob],K,!axO8);	! cvo(CMD),!axO8) ;
    end
    else if Kequ(KW,"STRING"[1 for length(KW)]) then begin
	    KW _ Get!Token(CMD);
	    Logit( QFet$Strs, "SEND S """&KW&""""&crlf );
	    Outptr( Port[MyJob], KW );		! Get!Token(CMD) );
    end
    else if Kequ(KW,"FILE"[1 for length(KW)]) then begin "SEND FILE"
	String Name, Dev, L;  Integer LastBrk;
	Boolean Ext!Found, File!Error, Eof;

	Name _ GetFil(CMD, Dev, Ext!Found, File!Error);
	If ( File!Error )
	  then Fatal( "SEND FILE - File error: "&Name )
	  else begin "good filename"
	    IChan[MyJob] _ VMFile( Name ) & IChan[MyJob];
	    if ( IChan[MyJob] < 0 )
	      then Fatal( "SEND FILE - File error: "&Name )
	      else While not( Eof )
	       do begin "transmit file"
		  L_ VMLine( IChan[MyJob], Brk );
		  L_ L & (If VMGetC( IChan[MyJob],VM$ECR )
			   then #cr else if Brk then Brk&Null else "");
		  If length( L ) or ( Brk )
		   then begin "got line"
		      if not( length( Buffer[MyJob] ) )
		       then Outptr( Port[MyJob], L );
		      Buffer[MyJob]_ Buffer[MyJob] & L;
		   end "got line";
		  EOF_ Brk = 0;
	      end  "transmit file";
	    Scan( Buffer[MyJob], B!Cr, Brk );	! trim first time away ;
	  end "good filename"
    end "SEND FILE"
    else Fatal( "illegal SEND command: "&CMD );
end;


simple procedure STOP;
SetFlg( STOP!, MyJob );

procedure TIME (string CMD);
SetTimeLimit( cvd( Tok(CMD) ) );	! Time in minutes;


recursive procedure COMMAND (string CMD);
begin	"COMMAND"
    string KW;  integer Index;
    lop(CMD);				! Eat first char (colon,dot,dash) ;
    KW _ Get!Token(CMD);		! Get first token;
    Logit( QFet$Cmds, "Cmd: "& KW &" >> "& CMD );
    if ( Brk = "=" )
     then begin "fake define"
	CMD_ KW & Brk & CMD;
	KW_ "DEFINE";
	BRK_ " ";
     end "fake define";

  redefine XC(Text,Action) = {
    ifcr length( Cvps( Text ) )
     thenc
      ifcr length( Cvps( Action ) )
       thenc  Action;
       elsec  begin end;
      endc
    endc
  };

    if ( KW = ":" )
     then				! ignore label here;	! Defer;
     else if ( Length(KW) )
	   then begin "my commands"
	      Case ( Index_ FndKey( KW, Commands ) + 1 ) of begin
		  Fatal( "Ambigious XEXEC command: "& KW );
		  Fatal( "Unknown XEXEC command: "& KW );
		  AllCommands
	      end;
	   end "my commands";

end	"COMMAND";


Simple Integer Procedure SlotsAvailable;
begin "slots available"

    For MyJob_ 1 step 1 until E!JobMax
     do begin "check each slot"

	if ( NTQ! or ESC! )		! if ( ^C or Notice-to-quit ) ;
	 then return( MyJob_ 0 );	!  just go home now... ;

	If ( LPStat( QQS(MyJob) ) = JS$Sched )
	 then begin "consider slot"

	    if ( FrontEnd )		! setup user and keep track ;
	     then begin "user ready"
		LogInfo("Stream #"& cvs(MyJob) &
			" seq " & cvs(Seq_ LPSeq(QQS(MyJob))) &
			" " & InfJob( queAct+(E!Length*(MyJob-1)) ) &
			" * activated *" );
		Dpb( Proc$Run, PStap( QQS(MyJob) ) );
		return( MyJob );	! give them the slot ;

	     end "user ready"

	 end "consider slot";
     end "check each slot";

    return( MyJob_ 0 );			! no slots to initialize ;

end "slots available";


Simple String Procedure JobStatus;
begin "job status"
    string str;

    define ifst(x,y,z,l) = {if ( x land (1 lsh MyJob) )
			     then begin
				Dpb( y, PStap(QQS(MyJob)) );
				Str_ z
				  ifcr length(cvps(l))
				   thenc & " at line " & cvs(LineNo[MyJob])
				  endc ;
			     end};
    Str_ Complete;
    if ( LPStat(QQS(MyJob)) = JS$Proc )
       and not ( LPProc(QQS(MyJob)) = PSP$Restart )
     then Dpb( Done$End, PStap(QQS(MyJob)) );

    ifst( TIM!, Abort$Time,  ["aborted - timeout"], line );
    ifst( NTQ!, Abort$Notice,["aborted - halted by operator"], line );
    ifst( ZAP!, Abort$Zap,   ["abended - lost circuit to slave"], line );
    ifst( STOP!,Done$Stop,   ["aborted - :STOP"], line );
    ifst( ERR!, Done$Error,  ["aborted - :ERROR in job"], line );
    ifst( TRU!, Abort$Tru,   ["aborted - TRU limit exceeded"], line );
    ifst( LOS!, Done$Lost,   [Str & " [check for data lossage]"] );

    return( Str );

end "job status";


Simple Procedure Do!Cleanup;
begin "do cleanup"
    Own integer ASlot;

    ASlot_ QueAct + E!Length * (MyJob - 1);	! setup slot pointer ;
    Disposition_ JobStatus;			! get job disposition ;
    Seq_ LPSeq( QQS(MyJob) );			! sequence number ;

    if ( DoMail land (1 lsh MyJob) )		! send mail, set flag ;
     then Dpb( MyMail[MyJob], PMail(QQA(MyJob)) );

    LogInfo("Stream #"& cvs(MyJob) &
	    " seq " & cvs(Seq_ LPSeq(QQS(MyJob))) &
	    " " & InfJob( queAct+(E!Length*(MyJob-1)) ) &
	    " * " & Disposition & " *" );

    If ( MakeLog[MyJob] )
     then VMText( OChan[MyJob], Buffer[MyJob] );

    Buffer[MyJob]_ Null;

    If MakeLog[MyJob] and (
	( LogDisp[MyJob] = JD$DELETE ) or
	( LogDisp[MyJob] = JD$ERROR and Kequ(Disposition,Complete) ) )
     then VMFree( OChan[MyJob], -1 )	! delete the log-file ;
     else VMFree( OChan[MyJob] );	! or simply close it ;

    ClearFrame( MyJob );		! make it go away for real ;

end "do cleanup";

Simple procedure ClearFile;
begin "clear file"

    if ( length( IChan[ MyJob ] ) )	! anything left to do? ;
     then begin "are we done"

	Forget!Substitutions;		! clear current substitutions;

	VMFree( IChan[ MyJob ] );	! Free the channel ;

	if ( 1 = length(IChan[MyJob]) ) or ( ERR! land (1 lsh Myjob) )
	 then begin "clear slot"	! last eof or error ;

	    Escape;			! put into command mode ;
	    if ( Port[MyJob] )		! if port, send LOGOUT string ;
	     then Buffer[MyJob]_ "LOGOUT" & #cr
	     else begin "kill frame"	!  otherwise evict or hang it ;
		if not( calli( !Xwd(1,QQF(MyJob)), calli!EVICT ) )
		 then calli( !Xwd(3,QQF(MyJob)), calli!HANG );
	     end "kill frame";

	    SetFlg( NeedZap, MyJob );	! get ready for the end ;

	 end "clear slot";

	lop( IChan[ MyJob ] );		! clear out the channel and ;
	lop( LineNo[ MyJob ] );		!  the line # for this file ;
	lop( Delim!list[ MyJob ] );	! lop off the last delimiter;

	if ( Delim!list[MyJob] neq Del!Chr[MyJob] )	! if mangled, then ;
	 then Set!Delimiter( Delim!list[MyJob] );	! reset from stack ;

     end "are we done";

 end "clear file";


Simple Procedure PortLine;
begin "port line"
    Define LineLen = 64 * 10;		! constant length = 640 ;
    Preset!with
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################" &
	"################################################################";
    Own String array Line[0:0];
    Own Integer Chan, MyLen, MyPtr;

    Chan_ Ochan[MyJob];			! setup channel variable ;

    begin!code

	Label Loop, NoMore;
	Define ax = '13, ch = '14, ct = '15;

	Move	ax,Line[0];		! copy string pointer ;
	Movem	ax,MyPtr;		! save it for use ;
	Move	ax,MyJob;		! get job index ;
	Hrlz	ax,Port[0](ax);		! get port ;
	Hrri	ax,!axi8s;		! set to image mode skip ;
	Setzm	MyLen;			! start with null string ;
Loop:	Auxcal	ax,ch;			! get a character ;
	  Jrst	NoMore;			! no more ;
	Jumpe	ch,Loop;		! ignore nulls ;
	Skipn	Chan;			! if no channel open ;
	  Jrst	Loop;			! throw characters away ;
	Idpb	ch,MyPtr;		! deposit character ;
	Aos	ct,MyLen;		! count characters ;
	Caige	ct,LineLen;		! enough room? ;
	  Jrst	Loop;			! yes, go back for next ;
NoMore:
     end;				! end begin!code ;

    VMText(Chan, Line[0][1 for MyLen]);	! put text directly into file ;

    if ( MyLen neq LineLen )		! if no overflow, then ;
     then ClrFlg( CHR!, MyJob );	! clear BRK seen flag ;

    Logit( QFet$Ports, "TTY"&cvos(Port[MyJob])&": "&Line[0][1 for MyLen] );
	
end "port line";


Simple Boolean Procedure OneLine;
begin "one line"
    string S, C;
    integer Brk,Cmd;

    If ( NeedEscape land (1 lsh MyJob) )	! Are we waiting for ESC? ;
     then begin "wait till next time"
	Escape;					! Do escape procedure ;
	return( true );				!  and come back later ;
     end "wait till next time";

    If ( length( Buffer[MyJob] ) )		! Do we have any leftovers? ;
     then begin "process leftovers"
	S_ Scan( Buffer[MyJob], B!Cr, Brk );	! Get one line from buffer ;
	OutPtr( Port[MyJob], S );		!  and send it along ;
	ClrFlg( ORG!, MyJob );			!  clear data flag ;
	return( true );				!  then return ;
     end "process leftovers";

    S_ VMLine( IChan[MyJob], Brk );		! Read first line of file;

    If ( VMGetC(IChan[MyJob], VM$ECR) )		! Was there a crlf? ;
     then C_ #Cr				!  yes, so make a string ;
     else C_ Null;				!  no,  make it empty ;

    if ( Length( S ) or Brk )			! End of File? If no line;
     then begin "got line"

	LineNo[MyJob]_ LineNo[MyJob]+1 & LineNo[MyJob][2 to INF];

	If ( DoParam land (1 lsh MyJob) )	! if substitutions enabled ;
	 then S_ Parametize(S);			!  then parametize the line ;

	Logit( QFet$Jobs lor QFet$Ports lor QFet$Subs,
	    "Stream #"& cvs(Myjob) &": "& S );
	Cmd_ true;				! default is a command ;

	if ( S = ":" )				! if "known-command" ;
	 then Command(S)			!  then process as a command ;
	 else if ( S = "." or S = "-" )		!  else check for want command ;
	     then if ( ChkCommand(S) )		!    then if a legal command ;
		 then Command(S)		!       then process a command ;
		 else begin "an escape"
		    ESCAPE;			! put into exec and ;
		    Cmd_ false;			!  clear command flag ;
		    Lop( S );			!  and remove esc flag ;
		 end "an escape"
	     else if ( S = "=" or S = "*" )
		 then begin "user mode"
		    If not( CommandMode )	! if at user level then ;
		     then Cmd_ false;		! clear command flag ;
		    If ( Lop( S ) = "=" )	! throw away char & compare ;
		     then C_ Null;		! use either Null or CR ;
		 end "user mode"		! don't forget labels:: ;
		 else Cmd_ false;

	if not( Cmd )
	 then begin "user data"
	    OutPtr( Port[MyJob], S&C );		! if data send it to the job ;
	    ClrFlg( ORG!, MyJob );		! clear data flag ;
	    return( true );			! and return ;
	 end "user data";

	return( not( (STOP! lor ERR! lor TRU!) land (1 lsh MyJob) ) );

     end "got line"
     else return( false );			! no line -- eof reached ;

end "one line";


Simple Procedure FileLine;
begin "each line"

    if ( LPStat( QQS(MyJob) ) = JS$Proc )
     then begin "valid job slot"

	Case ( LPProc( QQS(MyJob) ) ) of
	begin "each process type"
	    [PSP$Run]			! Run - normal mode ;
	    if ( QQF(MyJob) )		! if active frame ;
	     then if ( OneLine )	! check for data to job ;
		   then			! all is ok, nothing more to do ;
		   else ClearFile	! if end, clear file and go on. ;
	     else;			! log line to nonexistant frame ;

	    [PSP$Pause]			! Pause - wait at next statement ;
	    [PSP$Stop]			! Stop  - ^C/Halt job ;
		;			! do nothing if paused, stopped ;

	    [PSP$Restart]		! Restart - user/opr/job restart ;
	    [PSP$Cancel]		! Cancel  - user/opr abort job ;
	    if ( QQF(MyJob) )		! if active frame ;
	     then begin "finish job"
		while ( length( IChan[MyJob] ) )
		 do ClearFile;		!  clear file and set done flag ;
		if ( length( Buffer[MyJob] ) )
		 then OneLine;		!  send LOGOUT, etc. to line ;
	     end "finish job";

	    else
	end "each process type";

     end "valid job slot"
     else begin "invalid"
	Logit( QFet$Jobs, "** invalid stream #"& cvs(myjob) &" **" );
     end "invalid";

 end "each line";


Internal Simple Procedure GetInt( reference integer Flag; integer Why );
begin "get int"
    Own safe integer array Ports[ -1 : E!JobMax ];
    Own Integer Idx, MyP, MyJ;

    Arrclr( Ports );			! initialize data structure ;
    Ports[-1]_ E!JobMax + 1;		! specify length of list ;
    Idx_ Calli( Why + location(Ports[-1]), calli!POLPRT );
    if not( !Skip! )			! if cannot read ports list ;
     then return;			!  then ignore interrupt ;

    While ( 0 leq Idx_ Idx - 1 )	! for each possible port ;
     do if ( Ports[Idx] land Why )	! if condition set ;
	 then begin "find job port"

	    MyP_ !rh( Ports[Idx] );	! make it just a port ;

	    For MyJ_ 1 upto E!JobMax	! for each active job ;
	     do if ( Port[MyJ] = MyP )	! if the port matches ;
		 then begin "found one"
		    SetFlg( Flag,MyJ );	!  flag the port ;
		    done;		!  and finish loop ;
		 end "found one";

	 end "find job port";		! either port found or ignored ;

end "get int";


simple procedure ShutDown;
begin "shut down"			! start genocide process ;
    own boolean Blitzkreig;		! flag so only here once ;

    if ( Blitzkreig )			! deja vu? ;
     then return			! can only do this once ;
     else Blitzkreig_ true;		! else kilroy was here ;

    LogInfo( "Evicting all jobs:" &
	     (if NTQ! then " ntq" else "") &
	     (if ESC! then " esc" else "")    );

    For MyJob_ 1 upto E!JobMax
     do if ( QQS( MyJob ) and QQF( MyJob ) )
	 then begin "eviction notice"

	    if not( calli( !Xwd(1,QQF(MyJob)), calli!EVICT ) )
	     then calli( !Xwd(3,QQF(MyJob)), calli!HANG );

	 end "eviction notice";

end "shut down";


simple procedure SystemStartup;
begin "system startup"

    if not( OpnQue( que$Act ) )
     then Exit( "Processor cannot access Job QUEUE" );

    Seq_ queAct lsh -9;
    calli( Seq, calli!CLBADD );			! join club on ACT page ;
    if not( !Skip! )				! this should be easy ;
     then Exit( "No Club for Processor" );	!  otherwise weird... ;

    Seq_ calli(location(Seq),calli!CLBINI);	! get interlock, nowait ;
    if not( !Skip! )				! use SEQ double duty ;
     then begin "wait for interlock"

	if ( QQ( Schedule ) )			! if scheduler, notify ;
	 then QQ( HaveP )_ Gettab( XEXJob,!gtUID );

	SetTim( '300 );				! wait 5 minutes (300 sec) ;
	while not( TIM! )			! maximum for interlock ;
	 do begin "waiting"

	    calli( 1, calli!SLEEP );		! sleep for a second ;

	    Seq_ calli(location(Seq),calli!CLBINI);
	    if ( !skip! )			! if interlock gotten ;
	     then begin "got it"
		TimDis;				! clear timer interrupt ;
		TIM!_ false;			! and make sure clear ;
		QQ( ProcessUDT )_ QQ( HaveP );	! let scheduler know ;
		done;				!  we can go home ;
	     end "got it";

	 end "waiting";

	if ( TIM! )				! did we get interlock ;
	     and ( QQ( ProcessUDT ) neq Gettab( XEXJob,!gtUID ) )
	 then Exit( "Processor Interlock Busy ("&cvos(Seq)&")" );

     end "wait for interlock";

    LogInfo( "Processor starting in frame "& cvj( QQ(Process) ) );

!    SIAEnb;				! enable software interrupts ;
    ESCEnb;				! enable trapping ESC/^C ;
    NTQEnb;				! enable trapping NTQ ;

end "system startup";


!	M A I N   program
;

SystemStartup;				! crank it up to full ;

While ( QQ( HaveP )_ Gettab(XEXJob,!gtUID) )	! while we keep it honest ;
 do begin "the system is running"		! proceed with the work ;

    if ( LOS! lor CHR! lor ORG! lor ZAP! )
     then Logit( QFet$Ports,
		"L:"& cvos(LOS!) &" C:"& cvos(CHR!) &
		" O:"& cvos(ORG!) &" Z:"& cvos(ZAP!) );

    DoIf ( CHR!, E!JobMax )		! if *any* output is available ;
     then PortLine;			! read any data lines available ;

    DoIf ( ZAP!, E!JobMax )		! if *any* circuit zaps seen ;
     then begin "finish job"

	ClrFlg( ZAP!, MyJob );		! clear zap flag ;
	Port[ MyJob ]_ 0;		! clear port for clearframe ;

	if ( QQF( MyJob ) )		! if active ;
	 then Do!CleanUp;		!  close files, etc. ;

     end "finish job";

    If ( QQ( Active ) )			! any active slots? ;
     then begin "move some data"

	DoIf ( ORG!, E!JobMax )		! if *any* input requested ;
	 then FileLine;			! read any file lines available ;

	If ( NTQ! or ESC! )		! if notice received ;
	 then ShutDown;			! shut everything down ;

     end "move some data"
     else if ( NTQ! or ESC! )		! when inactive, check flags ;
	   then done;			!  and exit when done ;

    if not( SlotsAvailable )		! if no slots initialized ;
     then calli( 5, calli!SLEEP );	!    sleep for awhile ;

    if ( QQ( Feature ) land QFet$Shut )	! Normal-Shutdown ;
     then done;				!  we're out of here ;

 end "the system is running";

Exit( "Signing off." );

end 	"EXECX" $

     @