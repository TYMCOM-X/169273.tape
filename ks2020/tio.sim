! TIO -- TIO DRIVER ROUTINE (MAIN)

LOCAL TMP ! ALWAYS ASSUMED TO HAVE VALUE OF ZERO INIT (FOR GE-TOKEN)

! FIND'S FOR TIOPRM
FIND TYPETAB(0), LCHTAB(0), %PRM
FIND TYPEA(0),TYPEB(0),TYPEC(0),TYPED(0),TYPEE(0),TYPEF(0),TYPEG(0)
FIND TYPEJ(0),LCHA(0),LCHB(0),LCHC(0),LCHD(0),LCHE(0),LCHF(0)
FIND LCHG(0),LCHJ(0)

! FIND'S FOR COMMAND PACKAGE
FIND %GETOKEN, %NXLIN, %OUTNUM, %SETPRG, %INSC, %YELLOWBALL, %TUFHUB, %INFORMATION, %COPYSTRING, ERRTAB(1:14), %NXCMD, %ERR

! FIND'S FOR TIOIO
FIND %AUXCAL, %SETLCH, %GETLCH, %LCHSET, %TABLCHSET, %TABTYPESET

FIND JOBSA, JOBDDT, JOBVER, JOBREN


GLOBAL ALTMOD:, %CMDEXU, BEGIN:, PRMBUF(0:4), DOCMD:, DEBSW, ESW, INITIO:
GLOBAL ALTRET:, ALTDDT:, %LISOUT

! DEFINITIONS FOR BITS FOR TERMINAL PARAMETERS
! R.T.???       GETS THE PARTICULAR TERMINAL (AUXCAL) CHARACTERISTIC
! R.L.???       GETS THE PARTICULAR LINE (SETLCH) CHARACTERISTIC
! B.T.???       BITS FOR THAT PARTICULAR TERMINAL CHARACTERISTIC
! B.L.???       BITS FOR THAT PARTICULAR LINE CHARACTERISTIC
! S.T.???(X)    SETS THAT PARTICULAR TERMINAL CHARACTERISTIC
! S.L.???(X)    SETS THAT PARTICULAR LINE CHARACTERISTIC
DEF ON AS 1 ! TURN A CONDITION ON
DEF OFF AS 0 ! TURN A CONDITION OFF

DEF R.T.CARRIAGE.DELAY AS S.T.CARRIAGE.DELAY(-1)
DEF R.T.INPUT.BAUD AS S.T.INPUT.BAUD(-1)
DEF R.T.OUTPUT.BAUD AS S.T.OUTPUT.BAUD(-1)
DEF R.T.PARITY AS S.T.PARITY(-1)
DEF R.T.DUPLEX AS S.T.DUPLEX(-1)
DEF R.T.DELAY.A AS S.T.DELAY.A(-1)
DEF R.T.DELAY.B AS S.T.DELAY.B(-1)
DEF R.T.DELAY.C AS S.T.DELAY.C(-1)
DEF R.T.XOFF AS S.T.XOFF(-1)
DEF R.T.WIDTH AS S.T.WIDTH(-1)
DEF R.T.FILLER.1 AS S.T.FILLER.1(-1)
DEF R.T.FILLER.2 AS S.T.FILLER.2(-1)
DEF S.T.CARRIAGE.DELAY(X) AS AUXCAL(B.T.CARRIAGE.DELAY,X)
DEF S.T.INPUT.BAUD(X) AS AUXCAL(B.T.INPUT.BAUD,X)
DEF S.T.OUTPUT.BAUD(X) AS AUXCAL(B.T.OUTPUT.BAUD,X)
DEF S.T.PARITY(X) AS AUXCAL(B.T.PARITY,X)
DEF S.T.DUPLEX(X) AS AUXCAL(B.T.DUPLEX,X)
DEF S.T.DELAY.A(X) AS AUXCAL(B.T.DELAY.A,X)
DEF S.T.DELAY.B(X) AS AUXCAL(B.T.DELAY.B,X)
DEF S.T.DELAY.C(X) AS AUXCAL(B.T.DELAY.C,X)
DEF S.T.XOFF(X) AS AUXCAL(B.T.XOFF,X)
DEF S.T.WIDTH(X) AS AUXCAL(B.T.WIDTH,X)
DEF S.T.FILLER.1(X) AS AUXCAL(B.T.FILLER.1,X)
DEF S.T.FILLER.2(X) AS AUXCAL(B.T.FILLER.2,X)
DEF B.T.CARRIAGE.DELAY AS OCT 14
DEF B.T.INPUT.BAUD AS OCT 15
DEF B.T.OUTPUT.BAUD AS OCT 16
DEF B.T.PARITY AS OCT 17
DEF B.T.DUPLEX AS OCT 20
DEF B.T.DELAY.A AS OCT 21
DEF B.T.DELAY.B AS OCT 22
DEF B.T.DELAY.C AS OCT 23
DEF B.T.XOFF AS OCT 24
DEF B.T.WIDTH AS OCT 27
DEF B.T.FILLER.1 AS OCT 30
DEF B.T.FILLER.2 AS OCT 31
DEF R.L.TABS AS GETLCH BAND B.L.TABS
DEF R.L.NO.CRLF AS GETLCH BAND B.L.NO.CRLF
DEF R.L.LC AS GETLCH BAND B.L.LC
DEF R.L.LF AS GETLCH BAND B.L.LF
DEF R.L.FORM AS GETLCH BAND B.L.FORM
DEF S.L.TABS(X) AS SETLCH(B.L.TABS,X)
DEF S.L.NO.CRLF(X) AS SETLCH(B.L.NO.CRLF,X)
DEF S.L.LC(X) AS SETLCH(B.L.LC,X)
DEF S.L.LF(X) AS SETLCH(B.L.LF,X)
DEF S.L.FORM(X) AS SETLCH(B.L.FORM,X)
DEF B.L.TABS AS OCT 10.000000
DEF B.L.NO.CRLF AS OCT 200.000000
DEF B.L.LC AS OCT 20.000000
DEF B.L.LF AS OCT 2.000000
DEF B.L.FORM AS OCT 1.000000

TABLE ONOFF(0:6) [&
! 1! 'OFF', 0,&
! 2! 'ON', 0,&
! 3! 0,0]

TABLE PARA(0:8) [1,2,4,8,16,32,64,128,-1]

TABLE PARC(0:17) [0,1,2,3,4,5,7,10,14,19,26,36,50,69,95,131,-1]

TABLE BAUDRATE (0:7) [110,150,300,400,600,1200,-1]

TABLE BAUDWRD (0:22) [&
! 1! 'A', 0,&
! 2! 'B', 0,&
! 3! 'C', 0,&
! 4! 'D', 0,&
! 5! 'E', 0,&
! 6! 'F', 0,&
! 7! 'G', 0,&
! 8! 'J', 0,&
!10! 0,0]

TABLE PARWRD(0:10)[&
! 1! 'ON', CD.RETURN(1),&
! 2! 'EVEN', CD.RETURN(1),&
! 3! 'OFF', CD.RETURN(2),&
! 4! 'NONE', CD.RETURN(2),&
! 5! 0,0]

TABLE LFCRWRD(0:6) [&
! 1! 'LF', 0,&
! 2! 'CR', 0,&
! 3! 0,0]

TABLE MAST.SUB.TABLE(0:10) [&
CA.TABLE(-1), CA.CHANGE($,,CHRCTR), CA.CHANGE($ ,CHRCTR),&
CA.TABLE(1), CA.CHANGE($ ,RDELIMT),&
CA.TABLE(2), CA.CHANGE($ ,RDELIMT), CA.CHANGE($,,DELIMT),&
CA.TABLE(0)]

TABLE PARAM.SUB.TABLE(0:5) [&
CA.TABLE(-1), CA.CHANGE($,,DELIMT), CA.CHANGE($ ,RDELIMT)]


TABLE CMDWRD(0:72) [&
! 1! 'DDT', 0,&
! 2! 'LIST', CD.STAB(1),&
! 3! 'QUIT', 0,&
! 4! 'CREDITS', 0,&
! 5! 'CHARGES', 0,&
! 6! 'INSTRUCTIONS', 0,&
! 7! 'CAPABILITIES', 0,&
! 8! 'VERSION', 0,&
! 9! 'DELAY', CD.STAB(1),&
!10! 'INPUT', CD.STAB(1),&
!11! 'OUTPUT', CD.STAB(1),&
!12! 'PARITY', CD.STAB(1),&
!13! 'HALFDUPLEX', 0,&
!14! 'HDX', 0,&
!15! 'FULLDUPLEX', 0,&
!16! 'FDX', 0,&
!17! 'PARAMETERS', CD.STAB(1),&
!18! 'A', CD.STAB(1),&
!19! 'B', CD.STAB(1),&
!20! 'C', CD.STAB(1),&
!21! 'XON', CD.STAB(1),&
!22! 'LF', CD.STAB(1),&
!23! 'TAB', CD.STAB(1),&
!24! 'WIDTH', CD.STAB(1),&
!25! 'LC', CD.STAB(1),&
!26! 'FORM', CD.STAB(1),&
!27! 'CRLF', CD.STAB(1),&
!28! 'FFILL', CD.STAB(1),&
!29! 'TABFILL', CD.STAB(1),&
!30! 'FILLER', CD.STAB(1),&
!31! 'TIC', CD.STAB(1),&
!32! 'ID', CD.STAB(1),&
!33! 'EXPLAIN', CD.STAB(1),&
!34! 'TERMINAL', CD.STAB(1),&
!35! 'SAVE', CD.STAB(1),&
!36! 0,0]

TABLE TERMINAL (0:60) [&
! 1! 'CRT', CD.RETURN(1),&
! 2! 'TYM125', CD.RETURN(1),&
! 3! 'TYM225', CD.RETURN(1),&
! 4! 'TYM315', CD.RETURN(1),&
! 5! 'TYM325', CD.RETURN(1),&
! 6! 'TTY37', CD.RETURN(2),&
! 7! 'TYM300', CD.RETURN(3),&
! 8! 'TYM301', CD.RETURN(3),&
! 9! 'TYM310', CD.RETURN(3),&
!10! 'TYM311', CD.RETURN(3),&
!11! 'DCT500', CD.RETURN(3),&
!12! 'TTY33', CD.RETURN(4),&
!13! 'TTY35', CD.RETURN(4),&
!14! 'TYM200', CD.RETURN(4),&
!15! 'TYM201', CD.RETURN(4),&
!16! 'TYM100', CD.RETURN(5),&
!17! 'TYM110', CD.RETURN(5),&
!18! 'TYM211', CD.RETURN(5),&
!19! 'TYM212', CD.RETURN(5),&
!20! 'TYM213', CD.RETURN(5),&
!21! 'TYM221', CD.RETURN(5),&
!22! 'TI725', CD.RETURN(5),&
!23! 'TI733', CD.RETURN(5),&
!24! 'TI735', CD.RETURN(5),&
!25! 'NCR260', CD.RETURN(5),&
!26! 'EXECUPORT', CD.RETURN(5),&
!27! 'UNIVAC', CD.RETURN(6),&
!28! 'MEMOREX', CD.RETURN(7),&
!29! 'TERMINET360', CD.RETURN(7),&
!30! 0,0]

DEF LISLOW AS 4 ! LOWEST TOKEN FOR IMPLIED 'LIST'
DEF LISHGH AS 8 ! HIGHEST TOKEN FOR IMPLIED 'LIST'

TABLE LISWRD(0:56) [&
! 1! 'CREDITS', 0,&
! 2! 'CHARGES', 0,&
! 3! 'INSTRUCTIONS', 0,&
! 4! 'CAPABILITIES', 0,&
! 5! 'VERSION', 0,&
! 6! 'ALL', 0,&
! 7! 'ID', 0,&
! 8! 'FILLER', 0,&
! 9! 'PARAMETERS', 0,&
!10! 'A', 0,&
!11! 'B', 0,&
!12! 'C', 0,&
!13! 'INPUT', 0,&
!14! 'OUTPUT', 0,&
!15! 'DUPLEX', 0,&
!16! 'PARITY', 0,&
!17! 'LF', 0,&
!18! 'XON', 0,&
!19! 'WIDTH', 0,&
!20! 'TAB', 0,&
!21! 'LC', 0,&
!22! 'FORM', 0,&
!23! 'CRLF', 0,&
!24! 'FFILL', 0,&
!25! 'TABFILL', 0,&
!26! 'TIC', 0,&
!27! 'DELAY', 0,&
!28! 0,0]

! INIT THE PROGRAM
INITIO: SETPRG('TIO',OCT 5.000000,BEGIN,'TIO.HLP[')

BEGIN:  OFFALT                          ! TURN OFF ALL INTERRUPTS
        CMD.NO _ 1                      ! INITIAL PROMPT NUMBER
        IOCS(14*2)                      ! SET UP IOCS (2 BUF/CHAN)
        TERMCH_CAR.RET                  ! TURN OFF COMPLAINER

! DONE WITH INITIAL VARIABLE SETTING, SO,
! TYPE HOWDY MESSAGE
        MSG('$TIO - VERSION '); NUMOUT(LH(@JOBVER),10)
        PUT($.); IF RH(@JOBVER) < 10 THEN PUT($0)
        NUMOUT(RH(@JOBVER),10)
        IF RH(@JOBDDT) # 0 THEN MSG('$LOADED WITH DDT') ! IF DDT HERE, SAY SO
        PUT(CAR.RET)

! THIS IS THE MAIN COMMAND LOOP
! INTERRUPTS ARE ENABLED BEFORE A COMMAND WORD IS ACCEPTED AND IS
! DISABLED AFTER THE COMMAND EXECUTER (NXCMD) IS CALLED.
! NXCMD WILL DISABLE INTERRUPTS AFTER IT HAS DONE SOME PART OF THE
! COMMAND SUCH THAT AN ESCAPE WOULD BE FOOLISH (I.E., NON-EXECUTABLE)

DOCMD:  LOOP DO

! THIS IS THE COMPLAINER. TYPES OUT ANYTHING THAT WAS NOT SCANNED
! ON THE LAST COMMAND EXECUTE.  (IE, WHEN COMMAND SCANNER
! BECOMES SLOPPY)

        IF TERMCH # CAR.RET THEN DO ! EXTRA TEXT
          MSG('$$"')
          WHILE CHAR_NCHV POINTER#CAR.RET AND CHAR#E.O.LIT THEN PUT(CHAR)
          MSG('"$IS EXTRA AND HAS BEEN IGNORED.$')
          END

        ALTLOC _ ALTMOD ! SET ALTMOD CONTROL
        ONALT.C; IF NXCMD(-1,CMDWRD,FALSE,FALSE,'MQUMES','MHLMES',MAST.SUB.TABLE) = TRUE THEN INC CMD.NO
        OFF.ALT

        END ! OF THE COMMAND LOOP DO (DOCMD:)

ALTMOD: IF ESW = TRUE AND RH(@JOBDDT) # 0 THEN DO
          ALTLOC_ALTDDT; JOBSA _ DOCMD; MSG('$DDT$'); GO ^RH(@JOBDDT)
ALTDDT: ERR('$ESC FROM DDT: BREAKPOINTS NOT SET!$')
          END
ALTRET: ALTLOC_ALTMOD
         !ESCAPE HERE! OFF.ALT
          IF DEBSW=FALSE=ESW THEN DO
            CLOBUF; CLIBUF
            END

        ERR('$$(ESC)$')
        TERMCH _ CAR.RET ! TURN OFF COMPLAINER
        POINTER _ CHPT(@PRMBUF(4),-1) !NO MORE INPUT,CLEAR IMAGE LINE!
! FINISHED ESCAPE PROCESSING
        GO DOCMD

! *** PROCEDURE CMDEXU *** !
! ARG:1 IS THE COMMAND NUMBER FROM CMDWRD
! RETURNS 'TRUE' TO INCREMENT PROMPT,
! FALSE OTHERWISE
%CMDEXU(ARG.1,ARG.2)

LOCAL SAVFIDTBL(0:20) ! FOR SAVE COMMAND - FID TABLE
LOCAL TMP.1, TMP.2, TMP.3, TMP.4, TMP.5, TMP.6, TMP.7, TMP.8 ! TEMP VARIABLES
LOCAL SAVOERR: ! SAVE COMMAND OPEN ERROR LOC.

        TMP_0 ! TMP ALWAYS ASSUMED TO HAVE ZERO

        IF (LISLOW <= ARG.1 <= LISHGH) THEN DO
          TERMCH _ $ ; POINTER _ LASTOK; ARG.1 _ 2
          END

        IF ARG.2 # RESWRD THEN DO

! BAD CMD WRD

          EIF ARG.2 = BADRES THEN DO
            ERR('$Command not recognized$')
            YELLOWBALL; CLIBUF
            END
          ORIF GTYPE = FALSE THEN NULL
          ELSE GIVEUP ! DO ERROR PROCESSING
          TERMCH _ CAR.RET ! TURN OFF COMPLAINER
          RETURN FALSE
          END

! GOOD COMMAND WORD
        DO ARG.1 OF 1:40

1:      !DDT! IF (DEBSW=TRUE OR ESW=TRUE) AND RH(@JOBDDT) # 0 THEN DO
          INC CMD.NO
          ALTLOC _ ALTDDT
          RH(@JOBSA) _ DOCMD
          MSG('$DDT$'); GO ^RH(@JOBDDT)
          END
        GIVEIN

2:      !LIST! IF GETOKEN(0,LISWRD,FALSE,FALSE,'?.LIST','HELP.LIST','$OPTION: ',MAST.SUB.TABLE) # RESWRD THEN GIVEUP
        DO TOKEN OF 1:27

        1: MSG('WRITTEN BY TYMSHARE$'); RETURN FALSE
        2: MSG('NO PREMIUM CHARGE$'); RETURN FALSE
        3: INFORMATION('INSTXT'); RETURN FALSE
        4: INFORMATION('CAPTXT'); RETURN FALSE
        5: MSG('VERSION '); NUMOUT(LH(@JOBVER),10); PUT($.)
            IF LH(@JOBVER) < 10 THEN PUT($0)
            NUMOUT(RH(@JOBVER),10); PUT(CAR.RET); RETURN FALSE

        6: !ALL! FOR TMP.1 _ 10 TO 27 BY 1 LISOUT(TMP.1)
          RETURN FALSE
        7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27: LISOUT(TOKEN)
          RETURN FALSE
        END

        GIVEIN

3:      !QUIT! CLOSE.ALL; MSG('$E.O.J.$'); EXIT; HALT

LISHGH+1: !DELAY! IF GETOKEN(0,LFCRWRD,FALSE,FALSE,'?.DELAY','HELP.DELAY','$DELAY AFTER LF OR CR? ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.T.CARRIAGE.DELAY(IF TOKEN=1 THEN OFF ELSE ON); YELLOWBALL
        RETURN TRUE

LISHGH+2: !INPUT! IF GETOKEN(0,0,TRUE,FALSE,'?.INPUT','HELP.INPUT','$INPUT BAUD RATE? ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE BAUDRATE(INC TMP.1) # -1 AND BAUDRATE(TMP.1)#TOKEN
        IF BAUDRATE(TMP.1) = -1 THEN GIVEUP
        S.T.INPUT.BAUD(TMP.1) ! SET INPUT RATE!; YELLOWBALL
        RETURN TRUE

LISHGH+3: !OUTPUT! IF GETOKEN(0,0,TRUE,FALSE,'?.OUTPUT','HELP.OUTPUT','$OUTPUT BAUD RATE? ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE BAUDRATE(INC TMP.1) # -1 AND BAUDRATE(TMP.1) # TOKEN
        IF BAUDRATE(TMP.1) = -1 THEN GIVEUP
        S.T.OUTPUT.BAUD(TMP.1) ! SET OUTPUT RATE!; YELLOWBALL
        RETURN TRUE

LISHGH+4: !PARITY! IF GETOKEN(0, PARWRD,FALSE,FALSE,'?.PARITY','HELP.PARITY','$PARITY? ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.T.PARITY(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+5:LISHGH+6: !HALF-DUPLEX! S.T.DUPLEX(ON); YELLOWBALL
        RETURN TRUE

LISHGH+7:LISHGH+8: !FULL-DUPLEX! S.T.DUPLEX(OFF); YELLOWBALL
        RETURN TRUE

LISHGH+9: !PARAMETERS! GETOKEN(0, 0, TRUE, FALSE,'?.PARAM','HELP.PARAM','$A TO: ',PARAM.SUB.TABLE)
        IF GTYPE # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARA(INC TMP.1) # -1 AND PARA(TMP.1) # TOKEN
        IF PARA(TMP.1) = -1 THEN GIVEUP
        GETOKEN(0, 0, 2, FALSE,'?.PARAM1','HELP.PARAM1','$B TO: ',MAST.SUB.TABLE)
        IF GTYPE # NUMBER OR (NOT (0<= TOKEN <=7)) THEN GIVEUP
        TMP.2 _ TOKEN ! TMP.2 = PARAMETER 'B'
        GETOKEN(0, 0,TRUE,FALSE,'?.PARAM2','HELP.PARAM2','$C TO: ',MAST.SUB.TABLE)
        IF GTYPE # NUMBER THEN GIVEUP
        TMP.3 _ -1
        LOOP WHILE PARC(INC TMP.3) # -1 AND PARC(TMP.3) # TOKEN
        IF PARC(TMP.3) = -1 THEN GIVEUP
        S.T.DELAY.A(TMP.1); S.T.DELAY.B(TMP.2); S.T.DELAY.C(TMP.3); YELLOWBALL
        RETURN TRUE

LISHGH+10: !A! IF GETOKEN(0, 0, TRUE, FALSE, '?.A','HELP.A','$A TO: ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARA(INC TMP.1) # -1 AND PARA(TMP.1) # TOKEN
        IF PARA(TMP.1) = -1 THEN GIVEUP
        S.T.DELAY.A(TMP.1); YELLOWBALL
        RETURN TRUE

LISHGH+11: !B! IF GETOKEN(0, 0, TRUE, FALSE, '?.B','HELP.B','$B TO: ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <=7) THEN GIVEUP
        S.T.DELAY.B(TOKEN); YELLOWBALL
        RETURN TRUE

LISHGH+12: !C! IF GETOKEN(0, 0, TRUE, FALSE, '?.C','HELP.C','$C TO:',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARC(INC TMP.1) # -1 AND PARC(TMP.1) # TOKEN
        IF PARC(TMP.1) = -1 THEN GIVEUP
        S.T.DELAY.C(TMP.1); YELLOWBALL
        RETURN TRUE

LISHGH+13: !XON! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.XON','HELP.XON','$XON WHEN NECESSARY? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.T.XOFF(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+14: !LF! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.LF','HELP.LF','$ASSUME LF AFTER CR? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.L.LF(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+15: !TAB! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.TAB','HELP.TAB','$EXPAND TAB ON INPUT? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.L.TABS(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+16: !WIDTH! IF GETOKEN(0, 0, TRUE, FALSE, '?.WIDTH','HELP.WIDTH','$WIDTH OF TERMINAL (CHARS): ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        IF NOT (17 <= TOKEN <= 200) THEN GIVEUP
        S.T.WIDTH(TOKEN); YELLOWBALL
        RETURN TRUE

LISHGH+17: !LC! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.LC', 'HELP.LC', '$LOWER CASE ACCEPTED? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.L.LC(IF TOKEN=1 THEN OFF ELSE ON); YELLOWBALL
        RETURN TRUE

LISHGH+18: !FORM! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.FORM', 'HELP.FORM','$EXPAND FORM FEED ON OUTPUT? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.L.FORM(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+19: !CRLF! IF GETOKEN(0, ONOFF, FALSE, FALSE, '?.CRLF', 'HELP.CRLF', '$TYPE CRLF ON TTY WIDTH OVERFLOW? (ON OR OFF) ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        S.L.NO.CRLF(IF TOKEN=1 THEN ON ELSE OFF); YELLOWBALL
        RETURN TRUE

LISHGH+20: !FFILL! IF GETOKEN(0, 0, TRUE, FALSE, '?.FFILL', 'HELP.FFILL', '$FORM FEED FILLER COUNT TO: ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        IF NOT (0 <= TOKEN <= 3) THEN GIVEUP
        S.T.FILLER.1(TOKEN); YELLOWBALL
        RETURN TRUE

LISHGH+21: !TABFILL! IF GETOKEN(0, 0, TRUE, FALSE, '?.TABFILL', 'HELP.TABFILL', '$TAB FILLER COUNT TO: ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <=3) THEN GIVEUP
        S.T.FILLER.2(TOKEN); YELLOWBALL
        RETURN TRUE

LISHGH+22: !FILLER! IF GETOKEN(0, 0, TRUE, FALSE, '?.FILLER', 'HELP.FILLER', '$TAB AND FORM FEED FILLER COUNT TO: ',MAST.SUB.TABLE)&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <= 3) THEN GIVEUP
        S.T.FILLER.1(TOKEN); S.T.FILLER.2(TOKEN); YELLOWBALL
        RETURN TRUE

        ! THE WAY TIC/ID WORKS:
        ! TMP.2 - FOR INPUT SIDE, IS 'TRUE' IF TMP.3 CONTAINS
        !       AN ADDRESS, 'FALSE' IF TMP.3 CONTAINS A BAUD RATE
        ! TMP.3 - FOR TABLE ADR: LH=LCH TABLE, RH=TYPE TABLE
        !       FOR BAUD RATE: 0-7
        ! TMP.4,TMP.5 - SAME AS TMP.2,TMP.3 BUT FOR OUTPUT SIDE
LISHGH+23:LISHGH+24: !TIC!!ID!  GETOKEN(0, BAUDWRD, 2, FALSE, '?.TIC','HELP.TIC','$PARAMETERS: ',MAST.SUB.TABLE)
        EIF GTYPE=RESWRD THEN DO
          RH(@TMP.3) _ TYPETAB(TOKEN); LH(@TMP.3) _ LCHTAB(TOKEN)
          TMP.2 _ TRUE
          END
        ORIF GTYPE=NUMBER THEN DO
          TMP.3 _ -1
          LOOP WHILE BAUDRATE(INC TMP.3) # -1 AND BAUDRATE(TMP.3) # TOKEN
          IF BAUDRATE(TMP.3) = -1 THEN GIVEUP ! BAD BAUD RATE
          TMP.2 _ FALSE
          END
        ELSE GIVEUP ! WHAT WAS THAT ????
        EIF TERMCH = CAR.RET THEN DO
          TMP.4 _ TMP.2; TMP.5 _ TMP.3 ! SAME FOR INPUT AND OUTPUT
          END
        ELSE DO
          GETOKEN(0, BAUDWRD, TRUE, FALSE, '?.TIC1', 'HELP.TIC1', '$OUTPUT PARAMETER: ',MAST.SUB.TABLE)
          EIF GTYPE=RESWRD THEN DO
            RH(@TMP.5) _ TYPETAB(TOKEN); LH(@TMP.5) _ LCHTAB(TOKEN)
            TMP.4 _ TRUE
            END
          ORIF GTYPE=NUMBER THEN DO
            TMP.5 _ -1
            LOOP WHILE BAUDRATE(INC TMP.5) # -1 AND BAUDRATE(TMP.5) # TOKEN
            IF BAUDRATE(TMP.5) = -1 THEN GIVEUP ! BAD BAUD RATE
            TMP.4 _ FALSE
            END
          ELSE GIVEUP ! WHAT WAS THAT??
          END

        ! HERE ALL VARIABLES ARE SET UP, SO....
        IF NOT TMP.2 THEN S.T.INPUT.BAUD(TMP.3) ELSE DO
          TABLCHSET(LH(@TMP.3),TRUE,FALSE)
          TABTYPESET(RH(@TMP.3),TRUE,FALSE)
          END
        IF NOT TMP.4 THEN S.T.OUTPUT.BAUD(TMP.5) ELSE DO
          TABLCHSET(LH(@TMP.5),FALSE,TRUE)
          TABTYPESET(RH(@TMP.5),FALSE,TRUE)
          END
        YELLOWBALL
        RETURN TRUE


LISHGH+25: !EXPLAIN! GETOKEN(0, CMDWRD, TRUE, FALSE, '?.EXPLAIN','HELP.EXPLAIN','$COMMAND NAME? ',MAST.SUB.TABLE)
        EIF GTYPE = RESWRD THEN INFORMATION(CMDWRD((TOKEN-1)*2))
        ORIF GTYPE = NUMBER THEN INFORMATION('WHATS.A.NUMBER')
        ORIF GTYPE = DELIMT THEN INFORMATION('WHATS.A.DELIMETER')
        ELSE GIVEUP
   RETURN FALSE

LISHGH+26: !TERMINAL! IF GETOKEN(0, TERMINAL, FALSE, FALSE, '?.TERMINAL', 'HELP.TERMINAL', '$WHAT TYPE OF TERMINAL DO YOU HAVE? ',MAST.SUB.TABLE)&
        # RESWRD THEN GIVEUP
        DO TOKEN OF 1:10
        1: !CRT,TYM125,TYM225,TYM315,TYM325! TABTYPESET(TYPEA,TRUE,TRUE); TABLCHSET(LCHA,TRUE,TRUE)
        2: !TTY37! TABTYPESET(TYPEB,TRUE,TRUE); TABLCHSET(LCHB,TRUE,TRUE)
        3: !TYM300,TYM301,TYM310,TYM311,DCT500! TABTYPESET(TYPEC,TRUE,TRUE); TABLCHSET(LCHC,TRUE,TRUE)
        4: !TTY33,TTY35,TYM200,TYM201! TABTYPESET(TYPED,TRUE,TRUE); TABLCHSET(LCHD,TRUE,TRUE)
        5: !TYM100,TYM110,TYM211,TYM212,TYM213,TYM221,TI725,TI733,TI735,NCR260,EXECUPORT! TABTYPESET(TYPEE,TRUE,TRUE); TABLCHSET(LCHE,TRUE,TRUE)
        6: !UNIVAC! TABTYPESET(TYPEF,TRUE,TRUE); TABLCHSET(LCHF,TRUE,TRUE)
        7: !MEMOREX,TERMINET360! TABTYPESET(TYPEG,TRUE,TRUE); TABLCHSET(LCHG,TRUE,TRUE)
        END
        YELLOWBALL
        RETURN TRUE

LISHGH+27: !SAVE! IF TERMCH = CAR.RET THEN DO
          PRM('$TO FILE: '); POINTER _ NXLIN ! GET FNAME
          END
        TMP.1 _ TMP.2 _ POINTX(TOKBUF) ! POINTER TO TOKEN BUFFER
        COPYSTRING(POINTER,@TMP.1) ! COPY TO NEW LOCATION
        POINTER _ CHPT(''); TERMCH _CAR.RET ! TURN OFF COMPLAINER
        NCHV TMP.1 _ E.O.LIT !0TERMINATE FILE NAME
        SETFID(SAVFIDTBL,@TMP.2,OCT 634166.000000,SAVOERR)
        TMP.2 _ OPEN(-SAVFIDTBL,OUTMSG+DIRECT+WORD,SAVOERR,1)
!NOW, WRITE THE SAVE FILE
! THIS IS A CHEAT WAY, BUT ESSENTIALLY A 'SAVE' FILE IS REPRODUCED
DEF MOVEI AS OCT 201000.000000 ! FOR MOVING ARGUMENTS
DEF OUTSAVE(VAL) AS WX(TMP.2,VAL)
        OUTSAVE(OCT 777775000117); OUTSAVE(OCT 000231000141)
        OUTSAVE(OCT 000000000231); OUTSAVE(OCT 254200000000)
        OUTSAVE(OCT 777777000132); OUTSAVE(OCT 000230001777)
        OUTSAVE(OCT 777707000137); OUTSAVE(GETLCH)
        OUTSAVE(OCT 200000000140); OUTSAVE(OCT 051340000000)
        OUTSAVE(OCT 561040000014); OUTSAVE(MOVEI BOR R.T.CARRIAGE.DELAY); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000015); OUTSAVE(MOVEI BOR R.T.INPUT.BAUD); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000016); OUTSAVE(MOVEI BOR R.T.OUTPUT.BAUD); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000017); OUTSAVE(MOVEI BOR R.T.PARITY); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000020); OUTSAVE(MOVEI BOR R.T.DUPLEX); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000021); OUTSAVE(MOVEI BOR R.T.DELAY.A); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000022); OUTSAVE(MOVEI BOR R.T.DELAY.B); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000023); OUTSAVE(MOVEI BOR R.T.DELAY.C); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000024); OUTSAVE(MOVEI BOR R.T.XOFF); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000025); OUTSAVE(OCT 255000000000); OUTSAVE(OCT 255000000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000027); OUTSAVE(MOVEI BOR R.T.WIDTH); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000030); OUTSAVE(MOVEI BOR R.T.FILLER.1); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 561040000031); OUTSAVE(MOVEI BOR R.T.FILLER.2); OUTSAVE(OCT 042040000000); OUTSAVE(OCT 255000000000)
        OUTSAVE(OCT 047040000012); OUTSAVE(OCT 4000000227)
        OUTSAVE(OCT 254000000141); OUTSAVE(0)
        CLOSE(TMP.2)
        RETURN TRUE

SAVOERR: PUT(CAR.RET); MSG(ERRTAB(ERRNUM)); PUT(CAR.RET)
        RETURN FALSE

        END ! NEW COMMANDS BEFORE THIS 'END'

END CMDEXU

! PROCEDURE: LISOUT
! A = A NUMBER (AS PER LISWRD) TO LIST DATA FROM
%LISOUT(WRD)

LOCAL TMP.1, TMP.2

        DO WRD OF 7:27

        8: !FILLER! MSG('FORM FEED FILLER COUNT = '); NUMOUT(R.T.FILLER.1,10)
          MSG('$TAB FILLER COUNT = '); NUMOUT(R.T.FILLER.2,10); PUT(CAR.RET)
        9: !PARAMETERS! MSG('$A = '); NUMOUT(PARA(R.T.DELAY.A),10)
        MSG('$B = '); NUMOUT(R.T.DELAY.B,8)
        MSG('$C = '); NUMOUT(PARC(R.T.DELAY.C),10); PUT(CAR.RET)
       10: !A! MSG('A = '); NUMOUT(PARA(R.T.DELAY.A),10); PUT(CAR.RET)
       11: !B! MSG('B = '); NUMOUT(R.T.DELAY.B,8); PUT(CAR.RET)
        12: !C! MSG('C = '); NUMOUT(PARC(R.T.DELAY.C),10); PUT(CAR.RET)
       13: !INPUT! MSG('INPUT BAUD RATE = '); NUMOUT(BAUDRATE(R.T.INPUT.BAUD),10); PUT(CAR.RET)
       14: !OUTPUT! MSG('OUTPUT BAUD RATE = '); NUMOUT(BAUDRATE(R.T.OUTPUT.BAUD),10); PUT(CAR.RET)
       15: !DUPLEX! MSG(IF R.T.DUPLEX THEN 'HALF DUPLEX OPERATION$' ELSE 'FULL DUPLEX OPERATION$')
       16: !PARITY! MSG(IF R.T.PARITY THEN 'EVEN PARITY SENT$' ELSE 'NO PARITY SENT$')
       17: !LF! MSG(IF R.L.LF THEN 'LINE FEED NOT ASSUMED AFTER A CARRIAGE RETURN INPUT$' ELSE 'LINE FEED ASSUMED AFTER A CARRIAGE RETURN INPUT$')
       18: !XON! MSG(IF R.T.XOFF THEN 'XON-XOFF NEVER SENT$' ELSE 'XON-XOFF SENT AT APPROPRIATE TIMES$')
       19: !WIDTH! MSG('TERMINAL CARRIAGE WIDTH = '); NUMOUT(R.T.WIDTH,10); PUT(CAR.RET)
       20: !TAB! MSG(IF R.L.TABS THEN 'TABS NOT EXPANDED - SENT WITHOUT TRANSLATION$' ELSE 'TABS EXPANDED WHEN SENT$')
       21: !LC! MSG(IF R.L.LC THEN 'LOWER CASE CHARACTERS NOT CONVERTED TO UPPER CASE ON INPUT$' ELSE 'LOWER CASE CHARACTERS CONVERTED TO UPPER CASE ON INPUT$')
       22: !FORM! MSG(IF R.L.FORM THEN 'FORM FEEDS NOT EXPANDED - SENT WITHOUT TRANSLATION$' ELSE 'FORM FEEDS EXPANDED WHEN SENT$')
       23: !CRLF! MSG(IF R.L.NO.CRLF THEN 'NO CRLF TYPED WHEN TERMINAL CARRIAGE WIDTH OVERFLOW OCCURS$' ELSE 'CRLF TYPED WHEN TERMINAL CARRIAGE WIDTH OVERFLOW OCCURS$')
       24: !FFILL! MSG('FORM FEED FILLER COUNT = '); NUMOUT(R.T.FILLER.1,10); PUT(CAR.RET)
       25: !TABFILL! MSG('TAB FILLER COUNT = '); NUMOUT(R.T.FILLER.2,10); PUT(CAR.RET)
       26: !TIC! NULL
        27: MSG(IF R.T.CARRIAGE.DELAY THEN 'DELAY OCCURS AFTER THE CARRIAGE RETURN$' ELSE 'DELAY OCCURS AFTER THE LINE FEED$')
        END

        RETURN TRUE

END LISOUT

        \\-> INITIO
    S"Jµ