begin "TAKEIT"

require "SAIL.DEF" source!file;
require "(SAILIB)TYMINT.DEF" source!file;
require "FRMOP.DEF" source!file;
SetVersion(36);

! version 36 - /WRS released without modification;
! version 3518 - 7/13/80 W.R.Soley -
	1) change GRIPE to REMARK
	2) added nonimmune jobspec
	3) lengthened default takedown time to 5 mins
;
! version 3517 - 6/10/80 W.R.Soley -
	1) fixed typeo in help message.
	2) changed INSTR command to be INSTRUCTIONS as documented.
	3) added IMMUNE clause to job-specs.
;
! version 3516 - 5/27/80 W.R.Soley -
	1) fixed IMJobCount routine to not ILL ARY REF
;
! version 3515 - 5/16/80 W.R.Soley -
	1) changed output to CTY to include (please wait ...) msg.
;
! version 3514 - 5/15/80 W.R.Soley -
	1) restriceted BOOTS, ONCE, DSKCLN commands to WC users.
	2) changed HELP command to only list those commands that
		the user has enough license to do.
	3) added immunity.
;
! version 3513 - 4/23/80 W.R.Soley -
	1) added BOOTS, ONCE, DSKCLN commands.
	2) added RELOAD command for auto reloading takedown.
;
! version 3512 - 4/23/80 W.R.Soley -
	1) TALK command changed back to old format,
	2) SEND command implimented as TALK was in 3511.
;
! version 3511 (lost)
;
! version 3510 - 1/20/80 W.R.Soley -
	1) Changed program to always run SYS:LOGOUT[1,4]
;
! version 3509 - 12/18/79 W.R.Soley -
	1) fixed halt/evict/kill timeout mechanism.
	2) Changed behavoir for JACCT'd jobs (less complaints).
;
! version 3508 - 12/14/79 W.R.Soley -
	1) fixed problem where NTQ was not causing logout.  ABORT now
	checks Zapped and if set will do a LOGOFF rather than EXIT.
	2) changed halt time limit to 10 seconds.
;
! version 3507 - 12/13/79 W.R.Soley -
	1) fixed to trap SAIL errors (like no channel, etc.)
	2) fixed bug in opening ACCESS.MSG.
;
! version 3506 - 12/5/79 W.R.Soley - 
	1) fixed bug in procedure SCHED to not loop if waiting for
	super shut.
	2) changed system.msg to say going down immediately if its
	into grace.
;
! version 3505 - 12/4/79 W.R.Soley -
	1) Changed time limits for hung job to 10 minutes for evict,
	kill and halt.  Sligos complained that 1 minute is too short.
	Since it should never time out, no time limit should
	ever be to long.  If jobs refuse to go away, will add
	option to the kill command to ignore pending kill/evicts.
;
! version 3504 - 11/11/79 W.R.Soley -
	1) Added BITPOK to set JP.COR (max pages) to '377 to make
	sure that enough pages can be created for LOGOUT to run.
;
! version 3503 - 10/10/79 W.R.Soley - 
	1) Shortened min takedown and grace times for HU user.
	2) Changed the method of killing jobs (now does HALT,
	removes page 0 and replaces it with a private one,
	deposits a LOGOFF uuo in AC 1, a 0 in AC 0, and does
	a start at location 1).
	3) Uses TALK uuo to send stuff to other terminals now.
	4) ATTACH command requires WC license now.
	5) Added the OPER command to change oper names.
	6) TALK command format changed - now takes multiline messages
	and fills them before sending them.
	7) Slow Poll Rate is now 5 seconds (was 10).
	8) Added code to un-super-shut system whenever TAKEIT is not
	attached to.  It will remember if it is supposed to be shut
	and super-shut it when attached to.
	9) Changed msgs for more than one hour to show seconds so as
	not to confuse users.
	10) TAKEIT now gets NTQ interrupts.
;
! version 3502 - 7/10/79 W.R.Soley - fixes problem causing initials
	to be null string if user was WC license.
;
! version 3501 - 7/10/79 W.R.Soley - check for POKE failing.
	Make CloseLog a no-op the second time around.
	Make CleanUp safe to call more than once.
;
! version 35 - 6/6/79 W.R.Soley - no modification, transmitted to world.
;
! version 3403 - 6/1/79 W.R.Soley - put the word "in" back in the
	warning messages which was accidentially omitted.
;
! version 3402 - 5/31/79 W.R.Soley - fixed time scanner to work no
	matter what phase of the moon it is. (fixes "@HH:MM")
;
! version 3401 - 5/25/79 W.R.Soley - changed 2 minute warning to always
	occur.  It used to only happen if Grace < GraceMin.
;
! version 34 - 5/6/79 W.R.Soley - added CONFIG command and internal
	cosmetics.
;
! version 3307 - 5/2/79 W.R.Soley - added stuff to send message to
	CTY previous to hang or crash.
;
! version 3306 - 4/26/79 W.R.Soley - added abilities to cope with
	and trigger the "Notice to Quit" interrupt using the new
	EVICT uuo.  Happens at countdown=0 and at hang.
;
! version 3305 - 4/25/79 W.R.Soley - tracked down bug causing it
	to IO error if no TAKEIT.LOG found.
;
! version 3304 - 4/21/79 W.R.Soley - fixed bug cuasing bedlem at 
	countdown = 0.
;
! version 3303 - 4/20/79 W.R.Soley - put back 1 minute warning in
	the unconditional warning list
;
! version 3302 - 4/19/79 W.R.Soley - fixed bug in log file stuff.
	Log file doesn't update anymore - has to superceed.
;
! version 3301 - 4/9/79 W.R.Soley - cosmetic changes, log now in most
	recent first order, log will be truncated at 50 pages, log
	will be attempted 15 times at 1 sec intervals.
;
! version 33 - 4/1/79 W.R.Soley - added the device: argument to systat
	and job-specs.
;
! version 32 - 3/30/79 W.R.Soley - fixed echo problem as best as can
	be done by doing LevDef at end of every input.
;
! version 31 - 3/29/79 W.R.Soley - added "job-spec" parser to command
	which take job number.  May not detach another job.  Will
	also detect being hung and go away.  May now ^C from any
	dialogue and be returned to the command level.
;
! version 30 - 3/21/79 W.R.Soley - fixed a few things (hopefully),
	added the "GRIPE" command which just dumps stuff to the LOG
	file up to a ^D.
;
! version 29 - 3/21/79 W.R.Soley - removed "ABORT" command, several 
	bug fixes: fixed JBTPRV problem if bad oper password,
	fixed spaces in log file problem, fixed CANCEL command to
	leave user in manual mode, added "AUTO <time>[,<reason>]".
;
! version 28 - 3/17/79 W.R.Soley - fixed the problem preventing the
	slave from being stopped at the proper time.
;
! version 27 - 3/12/79 W.R.Soley - added the Exempt command.
	Miscelaneous bugfixes.
;
! version 26 - 3/11/79 W.R.Soley - changed Auto to force Watch.
	Setup for selective logging of commands.
;
! version 25 - 3/11/79 W.R.Soley - added logging to
	DSK:<myname>.LOG[fpn]
;
! version 24 - 3/12/79 W.R.Soley - fixed a few things about version
	23's changes.  Added the NXjobCount line back to TakeStat
	should it be in manual mode.
;
! version 23 - 3/11/79 W.R.Soley - major modification, created a
	manual mode - now requires "AUTO" command to perform as
	program did before.  New commands: AUTO, MANUAL, SCHED,
	CANCEL, QUIT
;
! version 22 - 1/30/79 W.R.Soley - shortened SlaveHung time limit.
	Rearranged b'cast messages - left only 10,5,2 and 1.  Set
	to shut system at 1 minute.
;
! version 21 - 1/11/79 W.R.Soley - fixed the GetLine routine to
	recognize that <line-waiting> is satisfied when a <brace>,
	<tilde> or <rub> are recieved as well as ctrl chars.  This
	was occasionally causing TAKEIT to hang in TI wait if
	one of these characters were sent without a line terminator.
;
! version 20 - 1/8/79 W.R.Soley - fixed bug in Update!Sys!Message
	routine causing garbage to print for minutes remaining.
	Fixed bug causing excessive type-ahead to hang things up.
	Fixed problem where typeing part of a line will hang
	the countdown.
;
! version 19 - 1/5/79 W.R.Soley - the first message will now be at
	the one hour mark or at takeit startup whichever is last.
	This way, takeit may be started several hours before the
	system is actually to be taken and will be completely
	dormant from other users point of view until T-1 hour.
	Also fixed MINS to give time in format HHH:MM as opposed to
	NNNNNN minute(s).  Also added the reason for takedown to
	the ACCESS.MSG thingy.  Reworked all of the countdown
	software.  Fixed bug reported by Ed Gauci about being
	unable to reattach - OPER-NAME wasn't being cleared.
;
! version 18 - 12/15/78 W.R.Soley - added "Kill (all jobs)" command,
	fixed TakeStat to show action=crash,  ** now kills detached
	jobs durring grace even if they're running **,  minimum grace
	period is now 5 minutes,  leading blanks are now ignored in
	commands, added "* STOPPED Job <n>, <SLAVE>" message.
;
! version 17 - 12/11/78 W.R.Soley - cosmetic changes.
;
! version 16 - 12/09/78 W.R.Soley - added the requirement of giving
	your oper-name upon reattaching to TAKEIT.  Added the 'set'
	command.  Added the 'crash' command.
;
! version 15 - 12/06/78 W.R.Soley - fixed infinite loop problem
	if slave port is zapped while setting up slave.  Also
	made cosmetic change to "?" msg for boots-loaded question.
	Also changed CheckAlone to ignore ^C's copies.  Also
	added "?" msgs for time and grace.
;
! version 14 - 12/05/78 W.R.Soley - added the use of the CONT UUO
	to put self in user mode if attached to while detached.
;
! version 13 - 12/05/78 W.R.Soley - changed spelling of immediately
	(from imediately) in broadcast message.
;
! version 12 - 12/04/78 W.R.Soley - changed EXEMPT to recognize 
	CHKPNT as the job with ACT: inited.  Also fixed HANG to
	indicate the name of a program running on an exempt job
	when it is hung.
;
! version 11 - 11/29/78 W.R.Soley - added check to see if another
	job is running takeit - if so it dies.  Also add ability
	to run to completion detached.
;
! version 10 - 11/28/78 W.R.Soley - added message to indicate what
	license(s) must be given to program.  Also improved the
	response(s) from typing "?" - all prompts now respond to
	"?" by producing a brief help message.
;
! version 9 - 11/27/78 W.R.Soley - added ability to realize that
	the OPER password file lacks WC license.
;
! version 8 - 10/26/78 W.R.Soley - added OPER password reading
	ability - will now run for any user with WC set on job
	or who supplies name and password of an oper-name with
	WC or HU.  In the case of HU, the 10 minute minimums will
	be enforced.;


string	Initials;		! operators initials (for msgs, log);
string	Reason;			! reason for going down (for msgs, etc);
string	SysName;		! name of system (for msgs, etc);
string	Monitor;		! monitor name to load;
string	MonitorVer;		! monitor version being loaded;
string	Com;			! command being processed;
integer	Job,J;			! job number (tmp);
integer	Grace;			! grace period in minutes;
integer	Next;			! ;
integer	JBTLIC;			! exec virtual address of JBTLIC;
integer	SysMsg;			! ;
integer	M;			! ;
integer	SchedSave;		! ;
integer	JBTSTS;			! exec virtual address of JBTSTS;
integer	JBTAUN;			! exec virtual address of JBTAUN;
integer	JBTPPN;			! exec virtual address of JBTPPN;
integer	JBTUN1;			! exec virtual address of JBTUN1;
integer	JBTUN2;			! exec virtual address of JBTUN2;
integer	JBTPRV;			! exec virtual address of JBTPRV;
integer	MyPPN;			! PPN TAKEIT is running under;
integer	MyJob;			! Frame number TAKEIT is running in;
integer	HighJob;		! exec virtual address of HGHJOB;
integer	JBTNAM;			! exec virtual address of JBTNAM;
integer	JBTFPN;			! exec virtual address of JBTFPN;
integer	DDBLDB;			! index into DDB of pointer to LDB;
integer	Brk;			! break chcracter;
integer	SchprvSave;		! value of SCHPRV when TAKEIT was run;
integer	Hold;			! holds time when HOLD cmd was given;

integer JBTUID, Time!0, jps, jpm, jph, JobN, Action, WC, Mode, PrvSave;
integer LastStates, LastPoll;
boolean Sys!Message, DownFlag, DetachFlag, BroadcastFlag, Watch;
boolean InitFlag, WantSuperShut;
ifc declaration(!SKIP!) thenc elsec external boolean !SKIP!; endc
define sub!title = {comment};
require "(SYS)GOGTAB.DEF" source!file;
external integer array GOGTAB[0:ENDREN];

define ForEachJob = {For Job_1 step 1 until peek(HighJob)};

sub!title	Define special parameters;

define	MinTakedown = 5;	! minimum minutes to take down;
define	MinGrace = 1;		! minimum minutes in grace period;
define	KillLimit = 600;	! seconds to allow job to take to die;
define	HaltLimit = 20;		! seconds to allow job to take to stop;
define	EvictLimit = 600;	! seconds to guarentee job for cleanup;
define	ShutTime = 1;		! shut system at time=1 minutes;
define	firstMsg = 30;		! minutes for first b'cast warning msg;
define	noSchPrv = true;	! don't run with SchPrv;
define	debug = false;		! don't compile for debugging;
define	SlowPollRate = 5;	! polling interval for manual mode;
define	LOL = 62;		! length of fill line for SEND msgs;

! *** don't change the order of these *** ;
define
  manual = 0,
  boots!loaded = 1,
  stand!alone = 2,
  deposit!30 = 3,
  reload = 4;

! these are break table identifiers;
define
  blanks = 1,
  digits = 2,
  nonBlanks = 3,
  comma = 4,
  noPunct = 5,
  SpecBreak = 6,
  noCrlf = 7,
  fcb = 8; 

! Mode values;
define
  Auto = 1;
! Manual = 0;		! already defined;

! Flags to pass to various procedures to modify their behavoir;
define
  Silent = true;

! Arguments and values related to UUO calls, etc.;
define	CoreMask = {('377*bit(17)+'377*bit(35))}; ! Bits in JBTPRV
			that control max core allowance;
define	DiscMask = {(bit(19)+bit(20))};	! Mask of bits in JBTPRV that
			control what to do if cmd port zapped;
define	DiscCont = {bit(19)};	! Bits to set continue on disconnect;
define	AttachUUO = -'6;	! Attach (or detach) a port;
define	BitpokUUO = -'120;	! Change certain bits in physical loc;
define	ContUUO = -'125;	! Continue a job from monitor mode;
define	CreauxUUO = -'44;	! Build a circuit;
define	DateUUO = '14;		! Obtain DEC-format date;
define	DatuuoUUO = -'55;	! Convert dates;
define	DevnamUUO = '64;	! Get physical device name;
define	EvictUUO = -'134;	! Hack the NTQ interrupt for some job;
define	GettabUUO = '41;	! Get miscelaneous garbage from system;
define	HangUUO = -'32;		! Zap a job (or port);
define	HiberUUO = '72;		! Sleep until something happens;
define	LogoffUUO = -'130;	! Run SYS:LOGOUT or such;
define	MstimeUUO = '23;	! Obtain MS past midnight;
define	PeekUUO = '33;		! Read physical core locations;
define	PjobUUO = '30;		! Get my job number;
define	PokeUUO = -'12;		! Write physical core locations;
define	RunUUO = '35;		! Run specified program;
define	SetjalUUO = -'21;	! Set some bits in JBTSTS;
define	SetnamUUO = '43;	! Set JBTNAM and clear JBTFPN;
define	SetotfUUO = -'126;	! Set other frame;
define	SetuuoUUO = '75;	! Speak to CTY:;
  define !BTSTR = '11;		! boots string function;
  define !REST = '12;		! restart option function;
define	SysdvfUUO = -'24;	! Return DDB's from DDB chain;
define	VclearUUO = -'66;	! Clear private page;
define	VcreatUUO = -'67;	! Create private page;
define	ZapcirUUO = -'45;	! Zap all circuits except command port;


! Handle debug stuff and other garbage;

ifc debug
  thenc redefine noSchPrv = true;
  elsec endc

sub!title	Inform person compiling about what's going on;

! The following glibble appears on the terminal at compile time as
well as in response tothe "CONFIGURATION" command...
;

define CFG(A) = {redefine ConfigMsg = cvms(ConfigMsg) & {& A & crlf}};
define ConfigMsg = {crlf & version & crlf};
ifc debug
    thenc CFG ("Debug version: HANG+CRASH+DETACH+SCHED+TALK disabled.");
    elsec CFG ("Production version.");
    endc
ifc compiler!switch("B")
    thenc CFG ("Loaded with BAIL.");
    elsec CFG ("No BAIL.");
    endc
CFG ("License required: WC RC OP SY JL WF.");
ifc noSchPrv
    thenc CFG ("SCHPRV disabled.");
    elsec CFG ("SCHPRV enabled.");
    endc
CFG ("Minimum takedown time is "&cvs(MinTakedown)&" minutes.");
CFG ("Minimum grace period is "&cvs(MinGrace)&" minutes.");
CFG ("First warning at "&cvs(FirstMsg)&" minutes.");
CFG ("System is shut at "&cvs(ShutTime)&" minutes.");
CFG ("Kill time limit is "&cvs(KillLimit)&" seconds.");
CFG ("Halt time limit is "&cvs(HaltLimit)&" seconds.");
CFG ("Evict time limit is "&cvs(EvictLimit)&" seconds.");
CFG ("Low priority polling interval is "&cvs(SlowPollRate)&" seconds.");
CFG ("Fill line length for SEND msgs is "&cvs(LOL)&" chars.");
CFG (null); 
require crlf&ConfigMsg message;

sub!title	Define commands;

define	ManMode = (1 lsh Manual);  ! command legal in manual mode only;
define	AutoMode = (1 lsh Auto);   ! command legal in auto mode only;
define	ReqWC = bit(16);	   ! command requires WC license;
define	Logit = bit(17);	   ! command gets logged;
define	AnyMode = '777777;	   ! command legal in any mode;

define
  comcnt = 0,
  comtxt = {},
  comhlp = {},
  comfoo = {},
  comflg = {},
  cdef (c,h,f) = {
    redefine comcnt = comcnt + 1;
    redefine comfoo = {com!}&cvps(c);
    evaldefine comfoo = comcnt;
    redefine comtxt = cvms(comtxt) & {,"} & 
	scanc(cvps(c),null," "&ht,"SINK") & {"};
    redefine comflg = cvms(comflg) & {,} & cvps(f);
    redefine comhlp = cvms(comhlp) & {,"} & cvps(h) & {"};
    };

! Add commands to following table: arguments are
    1 - command keyword,
    2 - command help line (pseudo BNF),
    3 - flag bits (combinations of...
	ManMode - allowed only in manual mode,
	AutoMode - allowed only in auto mode,
	AnyMode - allowed in any mode,
	Logit - command line will be entered in TAKEIT.LOG,
	ReqWC - available only to users with WC license)
;

cdef(action	,ACtion [{Manual|Boots|StandAlone|Crash|Reload}],
		AutoMode+Logit);
cdef(attach	,ATtach to <job-spec>, ManMode+Logit+ReqWC);
cdef(auto	,AUtomatic (takedown) [{@<time>|<mins>}[ <reason>]],
		ManMode+Logit);
cdef(boots	,Boots [{<string>|Manual|DEfault}] [Hang] [Crash] [{DIsk|NODisk}], 
		AnyMode+Logit+ReqWC);
cdef(cancel	,CAncel (takedown and notify users), AutoMode+Logit);
cdef(clear	,CLear (jbtsts bits for) <job-spec>,
		AnyMode+Logit+ReqWC);
cdef(configuration,CONFiguration (of TAKEIT), AnyMode);
cdef(continue	,CONTinue (countdown), AutoMode+Logit);
cdef(crash	,CRash (system), AnyMode+Logit+ReqWC);
cdef(detach	,DEtach {<null>|<job-spec>}, AnyMode+Logit);
cdef(dskcln	,DSkcln [{NONe|FAst|FUll|DEfault}] [Hang] [Crash] [{DIsk|NODisk}],
		AnyMode+Logit+ReqWC);
cdef(exempt	,Exempt <job-spec>, AnyMode+Logit);
cdef(grace	,Grace (period is) <minutes>, AutoMode+Logit);
cdef(hang	,HAng (system), AnyMode+Logit);
cdef(help	,HElp [<command>], AnyMode);
cdef(hold	,HOld (countdown), AutoMode+Logit);
cdef(immuMmune <job-spec>, AnyMode+Logit);
cdef(instructions,INstructions (for use of TAKEIT), AnyMode);
cdef(kill	,Kill <job-spec>, AnyMode+Logit);
cdef(once	,ONce [{Manual|Auto|DEfault}] [Hang] [Crash] [{DIsk|NODisk}], 
		AnyMode+Logit+ReqWC);
cdef(oper	,OPer <oper-name>, AnyMode+Logit);
cdef(quit	,Quit (from TAKEIT), ManMode+Logit);
cdef(reload	,RELoad (monitor) [{@<time>|<mins>}[ <monitor name>]],
		ManMode+Logit);
cdef(remark	,REMark <text>, AnyMode);
cdef(sched	,SChedule (is) [{Answer|SHut|SUpershut}],
		AnyMode+Logit);
cdef(send	,SENd <job-spec>, AnyMode+Logit);
cdef(set	,SET (countdown to) {@<time>|<mins>}, AutoMode+Logit);
cdef(systat	,SYstat [<job-spec>][HEADING], AnyMode);
cdef(talk	,Talk [{ALL|JOB #|TTY#:}] msg, AnyMode+Logit);
cdef(unexempt	,UNExempt <job-spec>, AnyMode+Logit);
cdef(unimmune	,UNImmune <job-spec>, AnyMode+Logit);
cdef(watch	,WATch {ON|OFF}, AnyMode+Logit);
cdef(warning	,WARning, AutoMode+Logit);
cdef(null	,<control-T> (type countdown), AnyMode);

redefine comtxt = cvms(comtxt)[2 to inf];
redefine comflg = cvms(comflg)[2 to inf];
redefine comhlp = cvms(comhlp)[2 to inf];
preset!with comtxt;
string array CMDS[1:comcnt];
preset!with comflg;
integer array CMDF[1:comcnt];
preset!with comhlp;
string  array CMDH[1:comcnt];

sub!title	Define "reasons" for take-down;

define
  reacnt = 0,
  reatxt = {},
  rdef (reas) = {
    redefine reacnt = reacnt + 1;
    redefine reatxt = cvms(reatxt)&{,"}&cvps(reas)&{"};
    };

rdef(System going down as per schedule.);
rdef(System going down to reload monitor.);
rdef(System going down for hardware maint.);
rdef(System going down for software maint.);
rdef(System going down for network maint.);
rdef(System going down for emergency maint.);
rdef(System going down for software development.);

redefine reatxt = cvms(reatxt)[2 to inf];
preset!with reatxt;
string array REAMSG[1:reacnt];


define comins = {"
For complete instructions, please see the TAKEIT manual.

To hang jobs, one at a time, as with HANGUP, use the command
        KILL job# (user)
where job# is the job number, (user) is the username of the job.
Other criteria may be given to kill a job or group of jobs, for
details, type ""KILL ?"".

To take the system down, in a courteous manner, use the command
        AUTO
and answer the questions as required.  If you are confused by a
question, type ""?"" and it will be explained in detail and reask.
This will automatically handle notification of users and shutting
the system.  Progress reports will be given.

For a complete (but brief) list of all available commands, say
        HELP
"};

sub!title	Main program block definition for dynamic allocation;

JobN _ rh(call(hl('15)+hr('11),"GETTAB"));
begin "MAIN"
    label CommandLevel;
    integer array JS[1:JobN];	! see below;
    integer array UID[1:JobN];	! universal frame ID for job;
    string array JU[1:JobN];	! User name for job N;
    string array JDev[1:JobN];	! Devices ass'd to job N;
    string array MsgQ[1:JobN];	! Messages pending for job;

! array JS description...
	bit(0)		- This jobs timer exceeded (hang/evict) limit
	bit(1:8)	- Seconds until job is tardy (timer)
	bit(9)		- This job has been evicted
	bit(10)		- This job has been halted
	bit(11)		- This job has been killed
	bit(16)		- This job is immune
	bit(17)		- This job is exempt
	bit(18:35)	- UUN of job
;
define
    hc(i) = {(i ash 27)},
    cvHc(i) = {(i ash -27)},
    expireFlag = {bit(0)},
    evictFlag = bit(9),
    haltFlag = bit(10),
    killFlag = bit(11),
    immuneFlag = bit(16),
    exemptFlag = bit(17),
    pendingMask = '777700000000,
    jsb(i) = {(i land (evictFlag+haltFlag+killFlag))};

sub!title	Forward procedure definitions;

forward simple integer procedure States;
forward simple procedure TALK(string MSG);
forward simple procedure Schedule(integer SCHED;boolean SilentFlag(false));
forward simple boolean procedure OPR;
forward procedure ABORT;
forward procedure FATAL(string msg);
forward simple integer procedure SailError(integer LOC; string MSG,RSP);
forward simple procedure CleanUp;
forward simple procedure SetOper;
forward boolean procedure CONFIRM;
forward simple boolean procedure Exist(integer JOB);
forward simple string procedure USER(integer JOB);
forward procedure Automatic (string Arg);
forward procedure AutoReload (string Arg);
forward procedure ClearAutomatic;
forward simple procedure Log (string Msg);
forward simple procedure CloseLog;
forward simple procedure OpenLog;
forward simple procedure HangJob (integer Job);
forward simple integer procedure Peek(integer Adr);
forward simple string procedure Queue(integer STS);
forward simple boolean procedure Exempt(integer Job);
forward simple boolean procedure Idle(integer Job);
forward simple string procedure JobLine (integer Job);
forward simple boolean procedure Detached (integer Job);
forward simple procedure Detach (integer Job(0));
forward simple boolean procedure OwnsDevice (integer Job,Dev);
forward simple boolean procedure Evict (integer Job);
forward simple string procedure DayTime;
forward simple procedure lprint(string msg);
forward simple procedure Talk!(integer Job);
forward string procedure Get!Monitor!Name(string ARG(null));

sub!title	ScanSpec and Apropos for parsing job specs;

integer	NameSpec,
	GanSpec,
	UunSpec,
	DevSpec,
	JobSpec;
boolean	AllSpec,
	IdleSpec,
	UnconditionalSpec,
	ExemptSpec,
	NonExemptSpec,
	ImmuneSpec,
	NonImmuneSpec,
	WaitSpec,
	DetSpec,
	HeadSpec,
	MySelfSpec,
	DefaultSpec;
string	QueueSpec,
	UserSpec;

integer	Jobs!;		! keep count of apropos jobs;

boolean procedure ScanSpec (string Spec);
begin "ScanSpec"
    string Token;
    integer Brk;
    simple boolean procedure Match (string T);
	return(equ(Token,T[1 for length(Token)]));
    define Conflict (Msg) = {begin
	print("?conflicting Msg specified",crlf);
	return(false);
	end};
    Jobs! _ 0;		! reset apropos job count;
    NameSpec_GanSpec_UunSpec_DevSpec_JobSpec_0;
    UserSpec_QueueSpec_null;
    HeadSpec_AllSpec_MySelfSpec_ImmuneSpec_NonImmuneSpec_
	ExemptSpec_NonExemptSpec_IdleSpec_WaitSpec_DetSpec_false;
    DefaultSpec_true;
    if Spec="?" then begin
	print("Job spec options are:
  (username)   - jobs logged into given username
  [gan,uun]    - jobs logged into this ppn
  [gan,*]      - jobs logged into this gan
  <program>    - jobs running this program
  job-number   - this job
  queue-name   - jobs in this queue (state)
  device:      - jobs owning this device
  IDLE         - only idle jobs
  DETACHED     - only detached jobs
  EXEMPT       - only exempt jobs
  NONEXEMPT    - only non-exempt jobs
  IMMUNE       - only immune jobs
  NONIMMUNE    - only non-immune jobs
  ALL          - all jobs (exempt too)
  WAIT         - ask for confirmation for each job
  UNCONDITIONAL- act regardless of any pending actions
    Note: the set of jobs acted upon by the command is the 
        intersection of the sets given.
    Note: NonExempt is implied by the absence of Exempt and All.
");
	return(false);
	end;
    while length(Spec) do begin "TokenLop"
	Token _ scan(Spec,SpecBreak,Brk);
	if length(Token)=0 then continue;
	case Brk of begin
	    [")"] if length(UserSpec)=0
		then UserSpec _ Token
		else Conflict(UserName);
	    [":"] if DevSpec=0
		then DevSpec _ cvsix(Token)
		else Conflict(Device);
	    [","] if GanSpec=0
		then GanSpec _ cvo(Token)
		else Conflict(GAN);
	    ["]"] if UunSpec=0
		then UunSpec _ cvo(Token)
		else Conflict(UUN);
	    [">"] if NameSpec=0
		then NameSpec _ cvsix(Token)
		else Conflict(Name);
	    else if cvd(Token) then if JobSpec=0
		then JobSpec _ cvd(Token)
		else Conflict(Job)
	    else if length(Token)=2 then if length(QueueSpec)=0
		then QueueSpec _ Token
		else Conflict(Queue)
	    else if Match("ALL") then AllSpec _ true
	    else if Match("WAIT") then WaitSpec _ true
	    else if Match("DETACHED") then DetSpec _ true
	    else if Match("IDLE") then IdleSpec _ true
	    else if Match("IMMUNE") then ImmuneSpec _ true
	    else if Match("NONIMMUNE") then NonImmuneSpec _ true
	    else if Match("EXEMPT") then ExemptSpec _ true
	    else if Match("NONEXEMPT") then NonExemptSpec _ true
	    else if Match("HEADING") then HeadSpec _ true
	    else if Match("UNCONDITIONAL") then UnconditionalSpec _ true
	    else begin
		print("?unrecognized token: ", Token, crlf,
		    " type ""?"" argument for help", crlf);
		return(false);
		end
	    end;
	end "TokenLop";
    if NonExemptSpec then ExemptSpec _ false;
    DefaultSpec _ not (NameSpec or GanSpec or UunSpec or JobSpec
	or QueueSpec or IdleSpec or ExemptSpec or DetSpec or DevSpec
	or AllSpec or UserSpec or NonExemptSpec or ImmuneSpec
	or NonImmuneSpec);
    return(true);
    end "ScanSpec";

simple boolean procedure Apropos (integer Job);
begin "Apropos"
    simple boolean procedure CheckJob (integer Job);
    begin "CheckJob"
	print(JobLine(Job),",");
	return(Confirm);
	end "CheckJob";
    boolean A;
    A _ (   not DefaultSpec
	and Exist(Job)
	and (MySelfSpec or (Job neq MyJob))
	and (NameSpec=0 or NameSpec=peek(JBTNAM+Job))
	and (GanSpec=0 or GanSpec=lh(peek(JBTAUN+Job)))
	and (UunSpec=0 or UunSpec=rh(peek(JBTAUN+Job)))
	and (JobSpec=0 or JobSpec=Job)
	and (length(UserSpec)=0 or equ(UserSpec,User(Job)))
	and (length(QueueSpec)=0 or
	    equ(QueueSpec,Queue(peek(JBTSTS+Job))))
	and (DetSpec=false or Detached(Job))
	and (AllSpec or ExemptSpec = Exempt(Job))
	and (ImmuneSpec=0 or JS[job] land immuneFlag)
	and (NonImmuneSpec=0 or not (JS[job] land immuneFlag))
	and (IdleSpec=false or Idle(Job))
	and (DevSpec=0 or OwnsDevice(Job,DevSpec))
	and (WaitSpec=0 or CheckJob(Job))
    );
    if A then Jobs! _ Jobs! + 1;
    return (A);
    end "Apropos";

simple string procedure Jobs;
case Jobs! of begin
    [0] return("No jobs");
    [1] return("1 job");
    else return(cvs(Jobs!)&" jobs") 
end;

sub!title	Parser for BOOTS, ONCE and DSKCLN commands ;
	
string	RPstring;
define	RPmanual=bit(1),
	RPdefault=bit(2),
	RPauto=bit(3),
	RPnone=bit(4),
	RPfast=bit(5),
	RPslow=bit(6),
	RPdisk=bit(7),
	RPnodisk=bit(8),
	RPhang=bit(9),
	RPcrash=bit(10),
	RPerror=bit(11);

simple integer procedure RParse (
	string ARG );
begin	"RParse"
    integer B;
    B _ 0;
    RPstring _ null;
    while length(ARG) do begin
	string S;		! scratch;
	simple boolean procedure Match(string S!);
	    return(equ(S,S![1 to length(S)]));
	simple procedure Setb(integer A1,A2);
	begin
	    if B land A2 then B_B lor RPerror;
	    B_B lor A1;
	end;
	define Grp1 = RPauto+RPmanual+RPnone+RPfast+RPslow+RPdefault;
	define Grp2 = RPdisk+RPnodisk;
	define Grp3 = RPhang+RPcrash;
	S _ scan(ARG,blanks,brk);
	if length(S)=0 then continue;
	if match("MANUAL") then Setb(RPmanual,Grp1)
	else if match("DEFAULT") then Setb(RPdefault,Grp1)
	else if match("UNDEFINED") then Setb(RPdefault,Grp1)
	else if match("AUTOMATIC") then Setb(RPauto,Grp1)
	else if match("FAST") then Setb(RPfast,Grp1)
	else if match("QUICK") then Setb(RPfast,Grp1)
	else if match("SLOW") then Setb(RPslow,Grp1)
	else if match("FULL") then Setb(RPslow,Grp1)
	else if match("NONE") then Setb(RPnone,Grp1)
	else if match("DISK") then Setb(RPdisk,Grp2)
	else if match("NODISK") then Setb(RPnodisk,Grp2)
	else if match("HANG") then Setb(RPhang,Grp3)
	else if match("CRASH") then Setb(RPcrash,Grp3)
	else RPstring _ S;
    end;
    if (B land RPcrash)=0 then B_B lor RPhang;
    return (B);
end	"RParse";

sub!title	BOOTS command ;

string procedure BootsString (
	string NewS(null) );
! call with ARG = new boots string;
! returns old string;
! to only return old string without changing, omit argument;
begin	"BOOTSSTRING"
    integer I;			! scratch pad;
    integer SS;			! string size;
    SS _ (calli(hl(!BTSTR)+hr(0),SetuuoUUO) +4) %5;
    if not !SKIP! then return("???");
    begin
	integer CW;		! control word;
	string OldS;		! old string;
	safe integer array SA[1:SS];
	CW _ location(SA[1]);	! get the old value;
	calli(hl(!BTSTR)+location(CW),SetuuoUUO);
	if not !SKIP! then return("???");
	OldS _ null;
	for I _ 1 upto SS do 
	    OldS _ OldS & cvastr(SA[i]);
	OldS _ scan(OldS,NoCrlf,!SKIP!);
	if length(NewS)=0 then return(OldS);
	NewS _ NewS &'15 &0;
	for I _ 1 upto SS do 
	    SA[i] _ cvasc(NewS[i*5-4 for 5]);
	CW _ bit(0) lor location(SA[1]); ! set the new value;
	calli(hl(!BTSTR)+location(CW),SetuuoUUO);
	if not !SKIP! then return("???");
	return(OldS);
    end;
end	"BOOTSSTRING";

string procedure BootsAction (
	string NewA(null) );
begin	"BOOTSACTION"
    simple string procedure cvBAS(integer RB);
    if RB land bit(0) = 0 
	then return("default")
	else if RB land bit(3) = 0 
	    then return(BootsString)
	    else return("manual");
    integer RB,B;		! scratch;
    string OldA;		! old action storred here as string;
    integer RestBits;		! restart bits;
    if NewA="?" then begin print("format is
  BOOTS [{<string>|MANUAL|DEFAULT} [{HANG|CRASH}] [{DISK|NODISK}] ]
where
  <string>	- specify file name to load from
  MANUAL	- ask for filename at BOOTS time
  DEFAULT	- do whatever is usual
  HANG		- do this on a HANG (default)
  CRASH		- do this on a CRASH
  DISK		- write action to disk (default)
  NODISK	- don't write action to disk
");
	return(null);
    end;
    RestBits _ calli(hl(!REST),SetuuoUUO);
    if not !SKIP! then RestBits _ 0;
    OldA _ cvBAS(RestBits lsh (35-7));
    if '220 land (RestBits xor (RestBits lsh (27-35))) then OldA _ OldA
	& "[hang] " & cvBAS(RestBits lsh (27-7)) & "[crash]";
    if length(NewA)=0 then return(OldA);
    B _ RParse(NewA);
    RB _ 0; 
    if RPstring then B_B lor RPauto;
    if (B land (RPerror+RPfast+RPslow+RPnone))
      or ((B land RPauto) and (B land (RPmanual+RPdefault)))
	then return("?illegal combination, type BOOTS ? for help");
    if RPstring then begin
	if DownFlag neq 7 then RPstring _ GET!MONITOR!NAME(RPstring);
	BootsString(RPstring);
    end;
    if B land RPauto then RB _ bit(0);
    if B land RPmanual then RB _ bit(0)+bit(3);
    if B land RPdisk then dpb(0,point(1,RestBits,19));
    if B land RPnodisk then dpb(1,point(1,RestBits,19));
    if B land RPhang then RestBits _
	(RestBits land (lnot ('220*bit(35)))) lor (RB lsh (7-35));
    if B land RPcrash then RestBits _
	(RestBits land (lnot ('220*bit(27)))) lor (RB lsh (7-27));
    NewA _ cvBAS(RestBits lsh (35-7));
    if (RestBits xor (RestBits lsh (27-35))) land '220 then NewA _ NewA 
	& "[hang] " & cvBAS(RestBits lsh (27-7)) & "[crash]";
    calli(hl(!REST)+hr(RestBits lor bit(18)),SetuuoUUO);
    if not !SKIP! then return("?cant set "&NewA);
    Log("BOOTS: "&NewA);
    return("set to "&NewA&" from "&OldA);
end	"BOOTSACTION";

sub!title	ONCE command ;

string procedure OnceAction (
	string NewA(null) );
begin	"ONCEACTION"
    simple string procedure cvOAS(integer RB);
    if RB land bit(1) = 0 
	then return("default")
	else if RB land bit(4) = 0 
	    then return("auto")
	    else return("manual");
    integer RB,B;		! scratch;
    string OldA;		! old action storred here as string;
    integer RestBits;		! restart bits;
    if NewA="?" then begin print("format is
  ONCE [{AUTO|MANUAL|DEFAULT} [{HANG|CRASH}] [{DISK|NODISK}] ]
where
  AUTO		- bypass once command level
  MANUAL	- stop at once command level
  DEFAULT	- do whatever is usual
  HANG		- do this on a HANG (default)
  CRASH		- do this on a CRASH
  DISK		- write action to disk (default)
  NODISK	- don't write action to disk
");
	return(null);
    end;
    RestBits _ calli(hl(!REST),SetuuoUUO);
    if not !SKIP! then RestBits _ 0;
    OldA _ cvOAS(RestBits lsh (35-7));
    if '110 land (RestBits xor (RestBits lsh (27-35))) then OldA _ Olda
	& "[hang] " & cvOAS(RestBits lsh (27-7)) & "[crash]";
    if length(NewA)=0 then return(OldA);
    B _ RParse(NewA);
    RB _ 0; 
    if (B land (RPerror+RPfast+RPslow+RPnone)) or length(RPstring)
	then return("?illegal combination, type ONCE ? for help");
    if B land RPauto then RB _ bit(1);
    if B land RPmanual then RB _ bit(1)+bit(4);
    if B land RPdisk then dpb(0,point(1,RestBits,19));
    if B land RPnodisk then dpb(1,point(1,RestBits,19));
    if B land RPhang then RestBits _
	(RestBits land (lnot ('110*bit(35)))) lor (RB lsh (7-35));
    if B land RPcrash then RestBits _
	(RestBits land (lnot ('110*bit(27)))) lor (RB lsh (7-27));
    NewA _ cvOAS(RestBits lsh (35-7));
    if '110 land (RestBits xor (RestBits lsh (27-35))) then NewA _ NewA
	& "[hang] " & cvOAS(RestBits lsh (27-7)) & "[crash]";
    calli(hl(!REST)+hr(RestBits lor bit(18)),SetuuoUUO);
    if not !SKIP! then return("?cant set "&NewA);
    Log("ONCE: "&NewA);
    return("set to "&NewA&" from "&OldA);
end	"ONCEACTION";
sub!title	DSKCLN command ;

string procedure DskClnAction (
	string NewA(null) );
begin	"DskClnACTION"
    simple string procedure cvDAS(integer RB);
    if RB land bit(2) = 0 
	then return("default")
	else case (RB lsh (7-35)) land 7 of begin
	    [0] return ("none");
	    [1] return ("fast");
	    [7] return ("full");
	    else return("<"&cvos(RB land 7)&">") end;
    integer RB,B;		! scratch;
    string OldA;		! old action storred here as string;
    integer RestBits;		! restart bits;
    if NewA="?" then begin print("format is
  DSKCLN [{NONE|FAST|FULL|DEFAULT} [{HANG|CRASH}] [{DISK|NODISK}] ]
where
  NONE		- do not run DSKCLN
  FAST		- run DSKCLN in fast mode
  FULL		- run DSKCLN in full mode
  DEFAULT	- do whatever is usual
  HANG		- do this on a HANG (default)
  CRASH		- do this on a CRASH
  DISK		- write action to disk (default)
  NODISK	- don't write action to disk
");
	return(null);
    end;
    RestBits _ calli(hl(!REST),SetuuoUUO);
    if not !SKIP! then RestBits _ 0;
    OldA _ cvDAS(RestBits lsh (35-7));
    if '047 land (RestBits xor (RestBits lsh (27-35))) then OldA _ OldA
	& "[hang] " & cvDAS(RestBits lsh (27-7)) & "[crash]";
    if length(NewA)=0 then return(OldA);
    B _ RParse(NewA);
    RB _ 0; 
    if (B land (RPerror+RPmanual+RPauto)) or length(RPstring)
	then return("?illegal combination, type DSKCLN ? for help");
    if B land RPnone then RB _ bit(2)+0*bit(7);
    if B land RPfast then RB _ bit(2)+1*bit(7);
    if B land RPslow then RB _ bit(2)+7*bit(7);
    if B land RPdisk then dpb(0,point(1,RestBits,19));
    if B land RPnodisk then dpb(1,point(1,RestBits,19));
    if B land RPhang then RestBits _
	(RestBits land (lnot ('047*bit(35)))) lor (RB lsh (7-35));
    if B land RPcrash then RestBits _
	(RestBits land (lnot ('047*bit(27)))) lor (RB lsh (7-27));
    NewA _ cvDAS(RestBits lsh (35-7));
    if '047 land (RestBits xor (RestBits lsh (27-35))) then NewA _ NewA
	& "[hang] " & cvDAS(RestBits lsh (27-7)) & "[crash]";
    calli(hl(!REST)+hr(RestBits lor bit(18)),SetuuoUUO);
    if not !SKIP! then return("?cant set "&NewA);
    Log("DSKCLN: "&NewA);
    return("set to "&NewA&" from "&OldA);
end	"DskClnACTION";

sub!title	String I/O routines - noop if detached;

simple procedure LevDef;
begin
    integer SKIP;
    Skip _ !Skip!;
    auxclv(-1,0,'11);
    !Skip! _ Skip;
end;

simple procedure XPrint(integer X;string S);
    ! This procedure is setup in GOGTAB to be called by the
	Print command;
begin "XPrint"
    auxcli(-1,location(S)-1,'67);
    LevDef;
end "XPrint";

define fullCase = {false},
       upperCase = {true};
string procedure get!line(integer Case(upperCase));
begin "G!L"
    integer I;
    string S;
    S _ null;
    do begin
	I _ auxclv(-1,0,'46);
	if I geq '173 then done;	! these are line breaks (ugh);
	if (I geq '140) and (Case = upperCase) then I _ I - '40;
	if I geq '40 then S _ S & I;
    end until I < '40;
    if I = cr then auxclv(-1,0,'46);
    LevDef;				! Try and get node to echo;
    if (I=ctrl("C") or I=esc) then begin
	if DetachFlag then Detach;
	auxclv(-1,0,6);		! clear input buffer;
	auxclv(-1,0,7);		! clear output buffer;
	if InitFlag
	    then goto CommandLevel
	    else while true do call(0,"EXIT");
    end;
    !SKIP! _ I;
    return(S);
end "G!L";

simple procedure force(string CMD);
begin
    auxclv(-1,0,6);			! clear input buffer;
    auxclv(-1,location(CMD),'33);	! force input;
end;

procedure CTYspeak(string MSG);
begin "CTY speak"
    integer array M[0:length(MSG)%5+1];
    integer I;
    Msg _ Msg & crlf;
    for i_0 step 5 until length(Msg)
	do M[i%5] _ cvasc(Msg[i+1 for 5]);
    calli(location(M[0]),SetuuoUUO);	! Send string to CTY:;
end "CTY speak";

simple procedure Talk! (integer Job);
if length(MsgQ[job]) then begin "Talk!"
    simple integer procedure BP(integer J);
	return(memory[location(MsgQ[J])]);
    own integer I;
    own integer array IA[0:1];
    SetOper;			! so they can say TALK OPR:;
    MsgQ[job] _ MsgQ[job] & 0;
    IA[0] _ Job;
    IA[1] _ BP(job);
    I _ calli(hl('10)+location(IA[0]),SetuuoUUO);
    if !SKIP! or I then begin 	! error or all done;
	MsgQ[job] _ null;
	return end;
    while IA[1] neq BP(job) do I_lop(MsgQ[job]);
    MsgQ[job] _ MsgQ[job][1 to inf-1];
end "Talk!";

simple string procedure CvJsb(integer X);
begin
    if X land haltFlag then return("halt");
    if X land evictFlag then return("evict");
    if X land killFlag then return("kill");
    return("????");
end;
sub!title	OPER name/password/license routines;

define XA (A) = {
  redefine XM = A-P;
  ifc XM 
    thenc redefine XX = cvms(XX) & {[} & cvms(XM) & {]'54,};
    elsec endc
  redefine P = A};

define X1 (A,B) = {
  XA (A);
  redefine XX = cvms(XX) & cvps(B) & {,};
  redefine P = A+1};

define X2 (A,B,C) = {
  XA (A);
  redefine XM = C;
  forc P _ A stepc 1 untilc B doc {
    redefine XX = cvms(XX) & cvms(XM) & {,};
    redefine XM = XM+1;
    } endc
  redefine P = B+1};

define P = '40;
define XM = 0;
define XX = {};

x1('40,'0);
x1('44,'54);
x1('47,'53);
x1('52,'52);
x2('54,'72,'33);
x1('100,'52);
x2('101,'132,'1);

XA('140);
redefine XX = cvms(XX)[1 to inf-1];

preset!with XX;
own integer array CHRTAB['40:'137];

long real procedure CVNAME(string NAME);
begin
  integer C,NM1,NM2;
  long real L;
  NAME _ (NAME & "            ")[1 for 12];
  NM1 _ NM2 _ 0;
  while length(NAME) do begin
    C _ CHRTAB[lop(name)];
    start!code
      MOVE 3,NM1;
      MOVE 1,NM2;
      IMULI 3,45;
      MULI 1,45;
      ADD 1,3;
      ADD 2,C;
      MOVEM 1,NM1;
      MOVEM 2,NM2;
      end;
    end;
  memory[location(L)] _ NM1;
  memory[location(L)+1] _ NM2;
  return(L);
  end;

integer procedure CVHASH(string PW);
begin
  integer C,FIVES,T1,T2,T3,T4;
  integer array X[0:4];
  X[0] _ X[2] _ X[4] _ '555555555555;
  X[1] _ X[3] _ '361275431652;
  FIVES _ '343277244615;
  T3 _ 0;
  while length(PW) do begin "PSWLP"
    C _ lop(PW);
    X[0] _ X[0] + C;
    X[3] _ X[3] + C;
    T4 _ '40;
    do begin "RAND"
      T1 _ X[T3];
      start!code
	MOVE 1,T1;
	MUL 1,FIVES;
	MOVEM 1,T1;
	MOVEM 2,T2;
	end;
      T3 _ T3 + 1;
      X[T3] _ X[T3] + T2;
      if T3 = 4 then begin
	T3 _ X[4] lsh -'42;
	X[0] _ X[0] + X[4];
	end;
      end "RAND" until (T4_T4-1) leq 0;
    end "PSWLP";
  return(X[0]);
  end;

string OPER!NAME;
integer procedure OPER!LICENSE (string OPN(null));
begin
  long real NAME;
  integer HASH,LIC,PTR,OP,EOF;
  integer array BUF[0:'777];
  string TMP;
  define bomb (X) = {begin
	print(X,crlf);
	release(OP);
	Oper!Name _ null;
	return(0) end};
  define
    bfnm1 = 0,
    bfnm2 = 1,
    bfpsw = 2,
    bflic = 3,
    nm1 = {location(NAME)},
    nm2 = {location(NAME)+1};
  if length(OPN) then TMP _ OPN else forever do begin
    print("Oper name: ");
    TMP _ get!line;
    if TMP = "?"
      then print("Enter your name as it appears in the OPER",
	" license file.",crlf)
      else done;
    end;
  if length(TMP)=0 then bomb("?no name given");
  NAME _ CVNAME (OPER!NAME _ TMP);
  auxclr(-1,memory['200],'64);
  forever do begin
    print("Password: ");
    TMP _ get!line;
    if TMP = "?"
      then print("?",crlf,
	"Enter your password associated with the OPER name ",
	OPER!NAME, ".",crlf)
      else done;
    end;
  HASH _ CVHASH (TMP);
  print(crlf);
  auxclr(-1,memory[0],'64);
  LevDef;
  open(OP_getchan,"SYS",'17,0,0,0,0,EOF_true);
  if EOF then bomb("?Can't init SYS:");
  begin "LOOKUP"
    define !CHLK = '4;		! CHANIO lookup function;
    define !RBLIC = '14;	! RIB address of file license;
    integer array XL[0:!RBLIC];
    XL[0]_arrinfo(XL,2);
    XL[2]_cvsix("DRWSPR");
    XL[3]_cvsix("EPO");
    chnior(OP,XL[0],!CHLK);
    if not !SKIP! then
	bomb("?OPER password file not found");
    if (XL[!RBLIC] land '400000)=0 then 
	bomb("?OPER password file has no license");
    end "LOOKUP";
  do begin "SEARCH"
    arryin(OP,BUF[0],'1000);
    if EOF then done "SEARCH";
    for PTR _ 0 step 7 until '770 do begin "TRY"
      if BUF[PTR+bfnm1] neq memory[nm1] then continue "TRY";
      if BUF[PTR+bfnm2] neq memory[nm2] then continue "TRY";
      EOF _ BUF[PTR+bfpsw] neq HASH;
      LIC _ BUF[PTR+bflic];
      done "SEARCH";
      end "TRY";
    end "SEARCH" until EOF;
  close(OP);
  release(OP);
  if EOF then begin
    print("?Bad name or password",crlf);
    return(0);
    end;
  return(LIC);
  end;


sub!title	Monitor IO routines;

define	uptime = {calli(hl('15)+hr('12),GettabUUO)};

simple integer procedure PEEK(integer ADR);
begin "PEEK"
    return(calli(ADR,PeekUUO));
    end "PEEK";

simple procedure POKE(integer ADR,VAL);
begin "POKE"
    own integer array ARG[0:1];
    ARG[0]_VAL;
    ARG[1]_ADR;
    calli(location(ARG[0]),PokeUUO);
    if not !SKIP! then fatal("POKE uuo failed");
    end "POKE";

integer procedure BITPOK(integer ADR,ANDCAM,IORM);
begin "BITPOK"
    integer array FOO[0:2];
    integer X,Y;
    FOO[0]_ADR;
    FOO[1]_ANDCAM;
    FOO[2]_IORM;
    Y_calli(location(FOO[0]),BitpokUUO);
    if not !SKIP! then Fatal("BITPOK uuo failed");
    return(Y);
    end "BITPOK";

simple procedure SetAdr;
begin "SA"
    own integer NUMTAB,I;
    external integer !ERRP!;
    !ERRP! _ location(SailError);! trap errors from SAIL;
    ttyup(true);
    jps_calli('26000011,GettabUUO);
    jpm_calli('27000011,GettabUUO);
    jph_calli('30000011,GettabUUO);
    setbreak(blanks," "&ht,null,"SINK");
    setbreak(NoCrlf,null,crlf,"FINS");
    setbreak(fcb," "&ht,null,"FINS");
    setbreak(digits,"0123456789",null,"RINK");
    setbreak(nonBlanks," "&ht,null,"RXNK");
    setbreak(comma," ,",null,"SINK");
    setbreak(noPunct,null,"!#$%&()*={}~:-[]^;@\+`|<>./_ "&ht,"SINK");
    setbreak(SpecBreak," :,])>","(<[","SINK");
    NUMTAB_rh(call('23000023,"GETTAB"));
    JBTUID_rh(peek(NUMTAB-'53));
    JBTSTS_rh(peek(NUMTAB));
    JBTLIC_rh(peek(NUMTAB-'20));
    JBTAUN_rh(peek(NUMTAB-'23));
    JBTUN1_rh(peek(NUMTAB-'22));
    JBTUN2_rh(peek(NUMTAB-'21));
    JBTNAM_rh(peek(NUMTAB+'3));
    JBTPRV_rh(peek(NUMTAB+'6));
    JBTFPN_rh(peek(NUMTAB-'25));
    I _ rh(call(lh(-1)+rh(10),"GETTAB"));
    MyJob_call(0,"PJOB");
    MyPPN_peek(JBTAUN+MyJob);
    SchprvSave_peek(JBTSTS+MyJob)land bit(23);
    SchedSave_States;
    PrvSave_peek(JBTPRV+MyJob);
    HighJob_rh(peek(NUMTAB+'12))+'20;
    SysName _ scanc (cvStr (calli ('11,GettabUUO)), "-", null, "SINK");
    for J _ 1 upto peek(HIGHJOB) do if Exist(J) then begin
	JS[j] _ rh(peek(JBTAUN+j));
	UID[j] _ peek(JBTUID+j);
	JU[j] _ user(j);
    end;
    LastPoll _ uptime;
    gogtab[$$PROU] _ location(xprint);
				! setup my own print - so will be noop
				  if job is detached;
    Initials _ user(MyJob);
    DetachFlag _ WantSuperShut _ false;
    DownFlag _ 0;
end "SA";

simple procedure CRASH;
begin "CRASH"
    ! will crash system by deposit in 30;
    Log ("* Crashing system.");
    CleanUp;
    print("Crashing system...");
    ifc debug thenc call(0,"EXIT") elsec endc;
    if Reason then CTYspeak(Reason);
    CTYspeak("Deposit in 30 by user "&User(MyJob)&
	" at "&DayTime&" /"&initials);
    CTYspeak("(please wait for ""BOOTS LOADED"")");
    call (5,"SLEEP");
    poke ('30,(if cvsix(Initials) 
	then cvsix(Initials) 
	else cvsix("TAKEIT")) );
    call(0,"SLEEP");
    fatal ("no response to deposit in 30");
end "CRASH";

sub!title	Frame operations;

simple procedure Halt!(integer job);
begin "halt"
    integer I;
    I _ FrmopV(job,0,!FOHLT);
    if not !SKIP! then case rh(I) of begin
	['22] lprint("?can't halt frame with JACCT: "&JobLine(job));
	['21] nothing;			! already halted;
	else lprint("??!FOHLT error '"&cvo(rh(I))&" for "&JobLine(job))
    end;
    JS[job] _ hc(haltLimit) + haltFlag + rh(JS[job]);
end "halt";

simple procedure Kill!(integer job);
begin "kill"
    integer Err;
    if peek(JBTSTS+job) < 0 then begin
	lprint("?running: "&JobLine(job));
	return end;
    BitPok(JBTPRV+job,0,CoreMask); ! make sure can get pages for LOGOUT;
    start!code
	label 	DEP,PROG,PROGORG,PROGST,PROGEND,XIT;
	MOVE 	1,Job;
	MOVEI 	1;		! 1 = can't set other frame;
	CALLI 	1,SetotfUUO;
	  JRST 	XIT;
	MOVE 	1,[bit(1)+1*bit(17)+0*bit(35)];
	CALLI 	1,VclearUUO;	! remove his page 0 if any;
	  JFCL;
	MOVE 	1,[bit(1)+3*bit(7)+1*bit(17)+0*bit(35)]; 
	MOVEI 	2;		! 2 = can't create page 0;
	CALLI 	1,VcreatUUO;	! page 0 R/W in other frame; 
	  JRST 	XIT;
	MOVE 	1,Job;
	HRLI 	1,!FOWVA;
	MOVEI 	3;		! 3 = can't deposit AC;
	MOVE 	2,PROGORG;	! addr to load PROG at in other frame;
	MOVEI 	4,PROG;		! 4/ -length,,PROG; 
	SUBI 	4,PROGEND;
	HRLI 	4,PROG;
	MOVSS 	4;
DEP:	MOVE 	3,(4);
	FRMOP 	1,2;		! deposit;
	  JRST 	XIT;
	ADDI 	2,1;
	AOBJN 	4,DEP;		! more?;
	MOVE 	1,Job;
	HRLI 	1,!FOSAA;
	HRROI	2,PROGST;	! start address=PROGST-PROG+(PROGORG);
	SUBI	2,PROG;
	ADD	2,PROGORG;	! program orign;
	MOVEI 	4;		! 4 = can't start frame;
	FRMOP	1,2;		! start frame;
	  JRST 	XIT;
	SETZ;			! no errors;
	JRST 	XIT;

	! program to deposit in other frame;
PROGORG:	'140;		! PROG origin in other frame;
PROG:	0 '141(1);		! location 140;
	1*cvsix("SYS");		! location 141;
	1*cvsix("LOGOUT");	! location 142;
	0;			! location 143;
	0;			! location 144;
	0 4(1);			! location 145;
	0;			! location 146;
PROGST:	MOVE 	1,'140;		! PROG start address;
	CALLI 	1,RunUUO;	! start LOGOUT;
	  JRST	4,;		! run failed (???);
PROGEND:! PRGEND-PROG = length of program;

XIT:	MOVEM Err;
    end;
    case Err of begin
	[1] lprint("?SETOTF failure: "&JobLine(Job));
	[2] lprint("?VCREAT failure: "&JobLine(Job));
	[3] lprint("?!FOWVA failure: "&JobLine(Job));
	[4] lprint("?!FOSAA failure: "&JobLine(Job));
	else end;
    JS[job] _ hc(killLimit) + killFlag + rh(JS[job]);
end "kill";

sub!title	Real time and countdown routines;

integer Tics, Mins, LastMin;

simple boolean procedure ReadClock;
begin
    own boolean ChangeingMin;
    if Mode = Manual then return(false);
    Tics _ (if Hold
	then Time!0-Hold
	else Time!0-uptime);
    if Tics < 0
	then Mins _ -(jpm%2-Tics)%jpm	! round to nearest if negative;
	else Mins _ (Tics+jpm-1)%jpm;	! round up if positive;
    ChangeingMin _ LastMin neq Mins;
    LastMin _ Mins;
    return (ChangeingMin);
    end;

simple procedure SetClock(integer T(bit(0)));
begin
    if T=bit(0) then T _ Tics;
    if Hold then Hold _ uptime;
    Time!0 _ uptime + T;
    Tics _ (if Hold
	then Time!0-Hold
	else Time!0-uptime);
    Mins _ (Tics + jpm-1)%jpm; ! always round up;
    LastMin _ bit(0);
    end;

define
    !sign = 4,
    !secs = 2,
    !spcl = 1;
string procedure CvTime (integer Format);
begin
    own integer T,M,S;
    string R;
    R _ null;
    T _ Tics;
    if T<0 then begin
	T _ -T;
	if Format land !sign then R _ "-";
	end;
    if Format land !secs
	then T _ ((T + jps%2)%jps)*jps
	else T _ ((T + jpm%2)%jpm)*jpm;
    if (T leq jph) and (Format land !spcl)
	then begin "nnnn minute(s)(, ss second(s))"
	    M _ (T % jpm);  S _ ((T % jps)mod 60);
	    R _ R & cvs(M) & " minute";
	    if M neq 1 then R _ R & "s";
	    if Format land !secs then begin
		R _ R & ", " & cvs(S) & " second";
		if S neq 1 then R _ R & "s";
	  	end;
	    end
	else begin "hhhh:mm(:ss)"
	    R _ R & cvs(T % jph);
	    setformat(-2,0);
	    R _ R & ":" & cvs((T % jpm)mod 60);
	    if Format land !secs
		then R _ R & ":" & cvs((T % jps)mod 60);
	    if Format land !spcl
		then R _ R & " hours";
	    setformat(0,0);
	    end;
    return (R);
    end;


sub!title	Warning message and talk control routines;

procedure Warning;
begin "WARN"
    own integer LastWarning;
    if LastWarning neq Mins then begin
	talk ("System " & SysName & " will leave timesharing " &
	    (if Mins=0 then "immediately" else "in "&CvTime(!spcl)) &
	    " /" & Initials);
	Log ("* Warning: " & CvTime(!Spcl) & " /" & Initials);
	end;
    LastWarning _ Mins;
   BroadcastFlag _ true;
  end "WARN";

simple procedure TALK(string MSG);
begin "TALK"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and jsb(JS[Job])=0
	and Job neq MyJob
	    then MsgQ[job]_ MsgQ[job] & bel & crlf &
		";;OPR: - " & msg & crlf & bel;
    print(";;OPR: - ",msg,crlf);
end "TALK";

sub!title	Routines to find about about who owns what devices;

simple procedure DeviceScan;
begin "DeviceScan"
    own integer array X[0:4];
    own integer Job;
    X[0]_X[1]_0;
    for Job_arrinfo(JDev,1) upto arrinfo(JDev,2)
	do JDev[Job] _ null;
    do begin
	calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO);
	if not !SKIP! then done;
	Job _ X[4] lsh -29;
	if Job then JDev[Job] _ JDev[Job] & "  " & cv6str(X[1]) & ":";
	end until X[1]=0;
    end "DeviceScan";

simple boolean procedure OwnsDevice (integer Job, Dev);
begin "OwnsDevice"
    own integer array X[0:4];
    if lh(Dev) = lh(cvsix("TTY"))
	then return (Dev = calli(hl(Job)+hr(-'27),GettabUUO))
	else begin
	    arrclr(X);
	    do 
		calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO)
	    until (X[1] = Dev) or (not !SKIP!);
	    return (if !SKIP! then (X[4] lsh -29)=Job else false);
	end;
end "OwnsDevice";

simple integer procedure ACTJOB; 
begin "ACTJOB"
    own integer array X[0:4];
    X[0]_X[1]_0;
    do
	calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO)
	until X[1]=cvsix("ACT") or not !SKIP!;
    return(if !SKIP!
	then (X[4] lsh -29)
	else 0);
    end "ACTJOB";


sub!title	Handle interrupt system;

boolean Zapped;			! flag gets set true when we should go;

simple procedure NTQservice;
Zapped _ true;

define
    NTQcause = '13,
    NTQchan = '10;

simple procedure NTQinit;
begin
    intmap(intass(NTQcause,NTQchan),NTQservice,0);
    enable(newenb(NTQchan));
end;

sub!title	Routines to tell about other jobs;

simple string procedure USER(integer JOB);
return(cv6str(peek(JBTUN1+job))&cv6str(peek(JBTUN2+job)));

simple string procedure QUEUE(integer STS);
begin "Q"
    own integer S,I;
    if STS geq 0 then return("^C");
    S_STS lsh -21 land '37;
    I_S/3;
    I_call(hl(I)+hr('25),"GETTAB")lsh (12*(S mod 3));
    return(cvxstr(I)[1 to 2]);
end "Q";

simple boolean procedure Exist(integer JOB);
return(peek(JBTSTS+JOB)land bit(3));

simple boolean procedure DETACHED(integer JOB);
return(lh(call(hl(JOB)+hr(-'27),"GETTAB"))=0);

simple boolean procedure IDLE(integer JOB);
return((peek(JBTSTS+JOB) land bit(0)) = 0);

simple boolean procedure EXEMPT(integer JOB);
begin "EXEMPT"
    if not Exist(Job) then return(false);
    if JOB = MyJob then return(true);
    if JS[job] land exemptFlag then return(true);
    if (cvsix("PJ")=peek(JBTUN1+JOB))
	and DETACHED(JOB)
	    then return(true);
    if Job=ActJob then return(true);
    return(false);
end "EXEMPT";

simple integer procedure NXJobCount;
begin "NXJC"
    own integer I,CNT;
    CNT_0;
    for I_1 upto peek(HIGHJOB) do
	if Exist(I) and not EXEMPT(I)
	    then CNT_CNT+1;
    return(CNT);
end "NXJC";

simple integer procedure IMJobCount;
begin "IMJC"
    own integer I,CNT;
    CNT_0;
    for I_1 upto peek(HIGHJOB) do
	if Exist(I) and (JS[I] land immuneFlag)
	    then CNT_CNT+1;
    return(CNT);
end "IMJC";

simple boolean procedure OneJob;
begin "1JOB"
    own integer J;
    for J _ 1 upto peek(HIGHJOB) do
	if Exist(J) and not (J=MyJob) then return(false);
    return(true);
end "1JOB";

simple procedure TakeStat;
begin "TakeStat"
    setformat(0,0);
    print((if States land '200000
	    then "System super-shut."
	    else (if States land '400000
		then "System shut."
		else "System answered.")), crlf);
    if Mode = Auto
	then print(
	    cvtime(!secs), (if Tics<0
	        then " into grace period."
	        else " remaining."), crlf,
	    (if Hold
	        then bel& "Countdown Holding." &bel&crlf
	        else null),
	    GRACE, " minutes grace.", crlf,
	    case ACTION of (null,
	        "System will be hung."&crlf,
	        "System will be stand alone."&crlf,
	        "System will crash."&crlf,
		"Syetem will reload "&MonitorVer&" from "&Monitor&crlf
		))
	else print(
	    "Manual mode.", crlf);
    if BootsAction neq "d" then print("BOOTS: ",BootsAction,crlf);
    if OnceAction neq "d" then print("ONCE: ",OnceAction,crlf);
    if DskClnAction neq "d" then print("DSKCLN: ",DskClnAction,crlf);
    print(NXJobCount, " non exempt jobs"&crlf);
    if IMJobCount then print(IMJobCount, " immune jobs"&crlf);
end "TakeStat";

procedure SYSTAT (string Arg(null));
begin "SYS"
    if not ScanSpec(Arg) then return;
    if DefaultSpec and not HeadSpec then begin
	DefaultSpec _ false;
	NonExemptSpec _ HeadSpec _ true;
	end;
    if HeadSpec then TakeStat;
    if not DefaultSpec then DeviceScan;
    MySelfSpec _ true;
    setformat(2,0);	! fixed format for job numbers;
    if not DefaultSpec then ForEachJob do
	if Apropos(Job)
	    then print(
		JOB, "  ",
		cvxstr(peek(JBTUN1+Job)),cvxstr(peek(JBTUN2+Job)),"  ",
		cvxstr(peek(JBTNAM+JOB)), "  ",
		QUEUE(peek(JBTSTS+JOB)), "  ",
		(if Detached(Job)
		    then "DETACH"
		    else cvxstr(calli(hl(JOB)+hr(-'27),GettabUUO))),
		JDev[Job],
		(if peek(JBTSTS+JOB)land bit(17)
		    then "  jacct" else null),
		(if peek(JBTSTS+JOB)land bit(20)
		    then "  jacct2" else null),
		(if peek(JBTSTS+JOB)land bit(23)
		    then "  schprv" else null),
		(if Exempt(Job)
		    then "  exempt" else null),
		(if JS[job] land immuneFlag
		    then "  immune" else null),
		(if calli(Job,EvictUUO) and !SKIP!
		    then "  NtQ" else null),
		(if Jsb(JS[job])
		    then "  ("&CvJsb(JS[job])&" "&cvs(cvHc(JS[job]))&")" else null),
		(if length(MsgQ[Job])
		    then "  (msgs)" else null),
		crlf);
    if Jobs!=0 and not HeadSpec then print("No job satisfying request");
    print(crlf);
    setformat(0,0);
end "SYS";

sub!title	Handle things queued for jobs;

procedure CheckQueues(integer Job);
begin "CQ"
    if length(MsgQ[job]) then Talk!(job);
    if (JS[job] land haltFlag) and (peek(JBTSTS+job) > 0) then 
	Kill!(job);
    if JS[job] < 0 then begin
	if JS[job] land (KillFlag lor EvictFlag) then
	    lprint("?no response to "&CvJsb(JS[job])&" by "&JobLine(job));
	Halt!(job);
    end;
end "CQ";
	
procedure POLL!JOBS;
begin "poll-jobs"
    integer Job,LastPoll!,Elapsed;
    LastPoll! _ LastPoll;
    Elapsed _ ((LastPoll_uptime)-LastPoll!+jps%2)%jps;
    for JOB _ 1 upto JobN do if Exist(job)
	then begin "job-Exists"
	    if UID[job] neq peek(JBTUID+job) then begin "different-job"
		if rh(JS[job]) and jsb(JS[job])=0
		    and Watch then print(
		    "* LOGOUT Job ", job,
		    ", user ", JU[job],
		    bel, crlf);
		JS[job] _ rh(peek(JBTAUN+job));
		UID[job] _ peek(JBTUID+job);
		JU[job] _ user(job);
		MsgQ[job] _ null;
		if Watch then print(
		    "* LOGIN   Job ", job,
		    ", user ", JU[job],
		    bel, crlf);
	    end "different-job";
	    if Jsb(JS[job]) then
	    	JS[job] _ JS[job] - hc(Elapsed);
	    CheckQueues(job);
	end "job-Exists"
	else begin "job-doesnt-Exist"
	    if rh(JS[job]) and jsb(JS[job])=0 
		and Watch then print(
		"* LOGOUT Job ", job,
		", user ", JU[job],
		bel, crlf);
	    JS[job] _ UID[job] _ 0;
	    MsgQ[job] _ JU[job] _ null;
	end "job-doesnt-Exist";
end "poll-jobs";

sub!title	System message control (SYS:ACCESS.MSG);

procedure Update!Sys!Message (integer Tics);
begin "USM"
  integer Flag;
  ifc debug thenc return endc;
  enter(SysMsg,"ACCESS.MSG",Flag);
  if Flag
    then usererr(0,1,"?Can't enter SYS:ACCESS.MSG")
    else begin
	if Tics < 0
	  then out(SysMsg, "System "& SysName& " will leave timesharing"&
		" immediately /"& Initials& crlf)
	  else out(SysMsg, "System "& SysName& " will leave timesharing"&
	    	" in " &CvTime(!spcl)& " /"& Initials& crlf);
	if length(Reason) then out(SysMsg, Reason & crlf);
	end;
  close(SysMsg);
  SYS!MESSAGE _ true;
end "USM";

procedure Save!Sys!Message;
begin "SSM"
  integer Flag;
  ifc debug thenc return endc;
  lookup(SysMsg,"ACCESS.MSG",Flag);
  if not Flag then rename(SysMsg,"TAKEIT.MSG",0,Flag);
  SYS!MESSAGE _ not Flag;
  close(SysMsg);
end "SSM";

procedure Restore!Sys!Message;
begin "DSM"
  integer Flag;
  ifc debug thenc return endc;
  if not SYS!MESSAGE then return;
  lookup(SysMsg,"ACCESS.MSG",Flag);
  if not Flag then rename(SysMsg,null,0,Flag);
  close(SysMsg);
  lookup(SysMsg,"TAKEIT.MSG",Flag);
  if not Flag then rename(SysMsg,"ACCESS.MSG",0,Flag);
  close(SysMsg);
  SYS!MESSAGE _ false;
end "DSM";

sub!title	System control routines;

simple procedure ContinueOnDisconnect;
    call(PrvSave land (lnot DiscMask) lor DiscCont,"SETPRV");

simple procedure AnswerSystem;
    Schedule ('000000);

simple procedure ShutSystem;
    Schedule ('400000);

simple procedure SuperShutSystem;
    Schedule ('600000);

define ClrSchprv = {calli(hl(7)+hr(false),SetuuoUUO)};

sub!title	Error handling routines;

procedure Fatal(string Msg);
begin "Fatal"
  print(crlf,"?FATAL: ",Msg,crlf);
  CTYspeak("?FATAL error in TAKEIT: "&Msg);
  Log("?FATAL: "&Msg);
  Abort;
end "Fatal";

simple integer procedure SailError (
	integer LOC;
	string	MSG;
	string	RSP );
! This routine is called by SAIL USERERR for all sail detected
  errors.  This should prevent things from not being cleaned up.
  Note that if this happens durring cleanup, it will NOT nest!;
begin
    external integer !ERRP!;
    !ERRP! _ 0;			! prevent recursion;
    if RSP then return(RSP);	! if from USERERR - really do it;
    MSG _ scan(MSG, NoCrlf, !SKIP!);! no crlf's in MSG;
    print (crlf, "??FATAL Sail error:", crlf, "??", MSG, crlf);
    CTYspeak ("??FATAL Sail error in TAKEIT:");
    CTYspeak ("??"& MSG);
    Log ("??FATAL Sail error:");
    Log ("?? "& MSG);
    Log ("?? at user "& cvos(LOC));
    Abort;
end;

procedure Abort;
begin "Abort"
  CloseLog;
  Restore!Sys!Message;
  call(PrvSave,"SETPRV");
  if not SchprvSave then ClrSchprv;
  if Zapped then call(0,LogoffUuo);
  while true do call(0,"EXIT");
end "Abort";

simple procedure CleanUp;
begin "Cleanup"
  CloseLog;
  Restore!Sys!Message;
  DownFlag _ 0;
end "Cleanup";

simple procedure SetJACCT;
  calli(bit(17) lor peek(JBTSTS+MyJob),SetjalUUO);

simple procedure ClearJACCT;
  calli((lnot bit(17)) land peek(JBTSTS+MyJob),SetjalUUO);

define SetSchprv = {ifc noSchPrv thenc elsec
	calli(hl(7)+hr(true),SetuuoUUO) endc};

simple procedure CLEAR(integer JOB);
begin "UNJ"
  own integer X;
  if JS[job] land immuneFlag then begin
	print("?job is immune: ",JobLine(JOB),crlf);
	return end;
  X_bitpok(JBTSTS+JOB,bit(17)+bit(20)+bit(23),0);
  if X land bit(17) then print("JACCT ");
  if X land bit(20) then print("JACCT2 ");
  if X land bit(23) then print("SCHPRV ");
  if X land(bit(17)+bit(20)+bit(23))
    then print("cleared for ", JobLine(Job), crlf)
    else print("No bits set for job ", JOB, crlf);
end "UNJ";

simple boolean procedure OPR;
begin "OPR"
  calli(cvsix("OPR"),DevnamUUO);
  return(!SKIP!);
end "OPR";

simple procedure SetOper;
begin "SetOper"
  calli(hl(5),SetuuoUUO);
end "SetOper";

simple procedure Schedule(integer SCHED;boolean SilentFlag(false));
begin "SCHED"
    integer Was;
    string S;
    Sched _ (Sched land '600000) lor ((Was_States) land '177777);
	! don't change bits other than shut and super-shut;
    if Sched land '200000 and Detached(myjob) then begin
	Sched _ Sched land '577777;
	WantSuperShut _ true;
	end;
    if Sched = Was then return;
    ifc not debug thenc calli(hl(1)+SCHED,SetuuoUUO); endc
    if Sched land '200000 then WantSuperShut _ false;
    LastStates _ Sched;
    Case (Sched lsh -15) land '6 of begin
	[0] S _ "System answered";
	[4] S _ "System shut";
	[2][6] S _ "System super shut";
	else end;
    Log ("* " & S & " ("&cvos(Was)&" -> "&cvos(Sched)&")");
    if not SilentFlag then print (S, crlf);
end "SCHED";

simple integer procedure States;
  return(rh(call('17000011,"GETTAB")));

simple procedure Detach (integer Job(0));
if Job=0
    then begin "DetachMe"
	DetachFlag _ true;
	if States land '200000 then begin
	    Schedule(States land '577777);
	    WantSuperShut _ true end;
	print("Detaching from job ",call(0,"PJOB"),"...");
	call(0,"ATTACH");
	setJacct;
    end "DetachMe"
    else begin "DetachHim"
	integer SavPrv;
	ifc debug thenc return; endc
	if not Exist(Job) then return;
	SavPrv _ BitPok(JBTPRV+Job,DiscMask,DiscCont);
				! Set continue on disconnect for job;
	calli(hl(1)+Job,HangUUO);	! Hang job - don't force logout;
	BitPok(JBTPRV+Job,DiscMask,DiscMask land SavPrv);
				! Restore his JBTPRV word;
	Log ("* detached " & JobLine(Job));
	print("* detached ", JobLine(Job), crlf);
    end "DetachHim";

procedure Attach (integer Job);
begin "ATTACH"
    Log ("* Attaching to "&JobLine(Job));
    call(hl(3)+hr(Job),"ATTACH");
    calli(hl(1),LogoffUUO);
    usererr(0,1,"?cant logout","X");
    end;

procedure CONT;
begin "CONT"
    calli(0,ContUUO);
    if not !SKIP! then begin "Gross Hack"
	force("CONT"&cr);
	call(0,"EXIT");
	end "Gross Hack";
    SetJACCT;
    print(crlf,
	"Attached to ",
	cv6str(peek(JBTNAM+MyJob)),
	" run by user ",
	user(MyJob),
	".",crlf);
    if not CONFIRM then DETACH;
    print("Type ""?"" for help.",crlf);
    begin "check-license"
	own integer LIC;
	LIC _ OPER!LICENSE;
  	Log ("* attached by " & Oper!Name);
	if LIC land (bit(16)+bit(18))
	    then WC _ (LIC land bit(18))
	    else begin
	 	Log ("* detached due to bad license");
		print("?write-core (WC) or hang-user (HU) license",
		    " required",crlf);
		DETACH;
		end;
	end "check-license";
    DetachFlag _ false;
    TakeStat;
    end "CONT";

sub!title	Initialization and support routines;

simple procedure CheckMyLicense;
begin "CML"
    own integer LIC;
    LIC_call(-'20,"GETTAB");
    if not LIC land bit(0) then usererr(0,1,"?WC license needed");
    if not LIC land bit(1) then usererr(0,1,"?RC license needed");
    if not LIC land bit(2) then usererr(0,1,"?OP license needed");
    if not LIC land bit(3) then usererr(0,1,"?SY license needed");
    if not LIC land bit(8) then usererr(0,1,"?JL license needed");
    if not LIC land bit(16) then usererr(0,1,"?WF license needed");
    end "CML";

simple boolean procedure CheckUserLicense;
begin "CUL"
    own integer LIC;
    LIC _ call(-'20,"GETTAB");
    if LIC land bit(18) then return(true);
    LIC _ OPER!LICENSE;
    Initials _ OPER!NAME;
    if LIC land bit(18) then return(true);
    if LIC land bit(16) then return(false);
    print("?User has insufficient license",crlf,
        "Hang User (HU) or Write Core (WC) license required",crlf);
    Abort;
    end "CUL";

simple procedure CheckAlone;
begin "CA"
    own integer FPN,NAM,J;
    FPN _ peek(JBTFPN+MyJob);
    NAM _ peek(JBTNAM+MyJob);
    for J _ 1 upto peek(HIGHJOB) do
        if (J neq MyJob)
	    and (peek(JBTFPN+J)=FPN)
	    and (peek(JBTNAM+J)=NAM)
	    and (peek(JBTSTS+J)<0)
	    then begin
		print("Warning: user ", user(J),
		    " already running ", cv6str(NAM),
		    " on job ", cvs(J), ".", crlf);
		end;
    end "CA";


sub!title	Perform action on other jobs;

simple string procedure JobLine (integer Job);
return ("job " & cvs(Job)
	& ", user " & User(Job)
	& " <" & cv6str(peek(JBTNAM+Job)) & "> "
	& Queue(peek(JBTSTS+Job)));

sub!title	procedures to remove jobs, etc.;

simple procedure HangSystem;
begin "HangSystem"
    if not OneJob then begin
	print("?can't hang system-system not stand alone",crlf);
	DownFlag _ 0;
	return; end;
    lprint("* Hanging system...");
    CleanUp;
    ifc debug thenc call(0,"EXIT") elsec calli(hl(4),HangUUO) endc;
    if !SKIP! 
	then begin "Logout"
	    if Reason then CTYspeak(Reason);
	    CTYspeak("System hung by user "&User(MyJob)&
		" at "&DayTime&" /"&initials);
	    CTYspeak("(please wait for ""BOOTS LOADED"")");
	    call(5,"SLEEP");
	    calli(hl(1),LogoffUUO);
	    call(0,"EXIT");	! just in case;
	end
	else FATAL("HANG uuo failed-can't hang system");
    DownFlag _ 0;
end "HangSystem";

simple procedure ReloadSystem;
begin "ReloadSystem"
    if not OneJob then begin
	print("?can't reload system-system not stand alone",crlf);
	DownFlag _ 0;
	return; end;
    lprint("* Reloading system...");
    CleanUp;
    BootsAction(Monitor);
    OnceAction("AUTO");
    DskClnAction("NONE");
    ifc debug thenc call(0,"EXIT") elsec calli(hl(4),HangUUO) endc;
    if !SKIP! 
	then begin "Logout"
	    CTYspeak("System hung by user "&User(MyJob)&
		" at "&DayTime&" /"&initials);
	    CTYspeak("Reloading "&MonitorVer&" from "&monitor);
	    CTYspeak("(please wait for ""MONITOR LOADED"")");
	    call(5,"SLEEP");
	    calli(hl(1),LogoffUUO);
	    call(0,"EXIT");	! just in case;
	end
	else FATAL("HANG uuo failed-can't reload system");
    DownFlag _ 0;
end "ReloadSystem";

simple procedure HangJob (integer Job);
begin "HangJob"
    if Job=ActJob then Schedule(States lor '400000);
    if JS[job] land immuneFlag then begin
	print("?job is immune: ",JobLine(job),crlf);
	return end;
    if not Exist(Job) then begin
	print("?can't hang job ",Job," - job doesn't Exist",crlf);
	return end;
    if UID[job] neq peek(JBTUID+job) then begin
	print("?job ",job," UID does not match",crlf);
	return end;
    if jsb(JS[Job]) and (JS[Job] land expireFlag)=0 then begin
	print("?job ",Job," still processing previous ",
	    CvJsb(JS[job]), crlf);
	return end;
    JS[job] _ JS[job] land lnot exemptFlag;
    if Evict(Job) then return;
    lprint("* Killed "&JobLine(Job));
    ifc not debug thenc Halt!(job) endc;
end "HangJob";

simple procedure HangIdleJobs;
begin "HangIdleJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and (JS[job] land immuneFlag)=0
	and jsb(JS[Job])=0
	and (Idle(Job) or Detached(Job))
	and not Exempt(Job)
	    then HangJob(Job);
end "HangIdleJobs";

simple procedure HangNXJobs;
begin "HangNXJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and (JS[job] land immuneFlag)=0
	and jsb(JS[Job])=0
	and not Exempt(Job)
	    then HangJob(Job);
end "HangNXJobs";

simple procedure HangAllJobs;
begin "HangAllJobs"
    integer Job;
    Schedule(States lor '400000);
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and (JS[job] land immuneFlag)=0
	and jsb(JS[Job])=0
	and Job neq MyJob
	    then HangJob(Job);
end "HangAllJobs";

simple boolean procedure Evict (integer Job);
begin "Evict"

    if JS[Job] land (evictFlag+immuneFlag)
	then return(false);	! don't do it twice or to immune one;
    if Job=ActJob then Schedule(States lor '400000);
    if calli(hl(1)+Job,EvictUUO)=0
	then return(false);	! wasn't enabled for it;
    if not !SKIP! then return(false);
    JS[Job] _ evictFlag + hc(evictLimit) + rh(JS[Job]);
    lprint("* Evicted "&JobLine(Job));
    return(true);
end "Evict";

simple procedure EvictAllJobs;
begin "EvictAllJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	Evict (Job);
end "EvictAllJobs";

sub!title	Get parameters from operator;

string procedure GET!OPER!NAME;
begin
    string X;
    forever do begin
	print("Enter your initials: ");
	X _ get!line;
	if length(X)=0 then X _ OPER!NAME;
	if length(X)=0 then X _ User(MyJob);
	if length(X) < 2
	    then print("One of the following:", crlf, 
		"  <initials> - a 2-3 character signature", crlf, 
		"  <cr> - to use your OPER name (if given)", crlf)
	    else return (X);
	end;
    end;

string procedure GET!REASON (string Arg(null));
begin
    string X;
    do begin "get-reason"
	if length(Arg)
	    then X _ Arg
	    else begin
		print("Enter reason for takedown (or ""?""): ");
		X _ get!line(fullCase);
		end;
	Arg _ null;
	if X = "?" then begin "help"
	    integer I;
	    print(
		"One of the following:", crlf,
		"  <cr>", crlf,
		"  <10-60 character message>", crlf,
		"  <reason number (see below)>", crlf);
	    for I _ 1 upto REACNT do
		print(
		    "    ", I, ". ", REAMSG[I], crlf);
	    continue "get-reason";
	    end "help";
	if cvd(X) then begin "number"
	    integer I;
	    I _ cvd(X);
	    if (I > REACNT) or (I < 1) then begin
		print(
		    "Not a valid reason number", crlf);
		continue "get-reason";
		end;
	    return (REAMSG[I]);
	    end "number";
	if length(X)=0 then return(null);
	if length(X) < 10
	    then print("Message must be more than 10 characters", crlf)
	else if length(X) leq 60
	    then return(X)
	    else print("Message must be less than 60 characters", crlf);
	end until false;
    end;

!   boots!loaded = 1,
    stand!alone = 2,
    deposit!30 = 3,
    reload = 4;
integer procedure GET!ACTION (string Arg(null));
begin
    forever do begin "ga"
	if length(Arg)=0 then begin
	    print("Enter takedown type: ");
	    Arg _ get!line;
	    end;
	case Arg of begin
	    ["B"][null] return(boots!loaded);
	    ["C"] if WC
		then return(Deposit!30)
		else print("?requires Write-Core (WC) license"&crlf);
	    ["M"] return(manual);
	    ["S"] return(stand!alone);
	    ["R"] begin
		monitor _ get!monitor!name;
		return(reload);
	    end;
	    else begin print(
"Enter action to be taken after all jobs have been killed:
  BootsLoaded: hang system (default)");
		if WC then print("
  Crash: deposit in 30 (for debugging only)");
		print("
  Manual: wait for operator action (left in TAKEIT)
  Reload: reload monitor from specified file (down for about 1 min)
  StandAlone: continue timesharing with only this job (super shut)
");	    end
	    end;
	Arg _ null;
	end "ga";
    end;

sub!title	Get monitor name and verify that its a monitor;

string procedure GET!MONITOR!NAME (string ARG(null));
forever do begin "GMN"
    integer Chan,Eof;		! stuff for file;
    if length(Arg)=0 then begin
	print("Enter monitor filename: ");
	Arg _ get!line;
    end;
    if length(ARG)=0 then Arg _ "SYSTEM";
    if ARG="?" then begin print(
"Enter the name of the file which contains the monitor to be loaded
when the system comes down.  The file must be a .SAV file.  The 
extension should not be specified; the default directory is (SYS).
");	Arg _ null;
	continue end;
    open(Chan_getchan,"DSK",bit(23)+'14,2,0, 0,0,EOF);
    if EOF then usererr(EOF,2,"?can't init SYS: ","X");
    if ARG neq "(" then ARG _ "(SYS)"&ARG;
    lookup(Chan,ARG,EOF);
    if EOF then lookup(Chan,ARG&".SAV",EOF);
    if EOF then begin
	print("?file not found, ",ARG,crlf);
	release(Chan);
	Arg _ null;
	continue end;
    begin "ExpandFile"		! get system version;
	integer	WordCnt,	! -Data words left until next IOWD;
		WordAdr,	! Current address in file (expanded);
		Word,		! A word from the file;
		ConfigAdr;	! Holds address of Config table;
	define	JobVer = '137;	! Pointer to CONFIG;
	define	SysName1 = 0;	! start of system name in ascii;
	define	SysName2 = 4;	! end of system name in ascii;
	integer array Config [SysName1:SysName2];
	ConfigAdr _ 0;
	WordCnt _ WordAdr _ -1;
	arrclr (Config);
	while not Eof do begin "NextBlock"
	    Word _ wordin (Chan);
	    WordAdr _ WordAdr + 1;
	    WordCnt _ WordCnt + 1;
	    if WordCnt
	      then begin "DataWord"
		if WordAdr = JobVer then ConfigAdr _ rh(Word);
		if  (WordAdr-ConfigAdr geq arrinfo(Config,1)) and
		    (WordAdr-ConfigAdr leq arrinfo(Config,2))
		    then Config[WordAdr-ConfigAdr] _ Word;
	      end "DataWord"
	      else begin "IOWord"
		WordAdr _ rh(Word);
		WordCnt _ (Word ash -18)-1;
		if (WordAdr>JobVer and ConfigAdr=0) then Eof_true;
	      end "IOWord";
	    if ConfigAdr and (WordAdr > ConfigAdr+arrinfo(Config,2)) 
		then done;
	end "NextBlock";
	MonitorVer _ null;
	if not EOF then for word _ SysName1 upto SysName2 do
	    MonitorVer _ MonitorVer & cvastr(Config[word]);
	if length(MonitorVer)=0
	    then EOF _ true
	    else begin "verify"	! control chars imply bogus file;
		string T;
		T _ MonitorVer;
		while length(T) do if lop(T)<32 then EOF_true;
	    end "verify";
    end "ExpandFile";
    close (Chan);
    release (Chan);
    if EOF then begin
	print ("?file SYS:",arg," is not a monitor",crlf);
	Arg _ null;
	continue end;
    return (arg);
end	"GMN";

sub!title	GetTakedownTime;

integer procedure GetTakedownTime (string Arg(null));
begin
    integer I;
    string L;
    do begin
	if length(Arg)
	    then L _ Arg
	    else begin
		print("Enter takedown time: ");
		L _ get!line;
		end;
	Arg _ null;
	if L="?" then begin
	    print("One of the following:",crlf,
		"  mmm     - minutes until takedown",crlf,
		"  @hh:mm  - local time of takedown",crlf);
	    continue; end;
	if L="@" then begin "absTime"
	    I _ cvd(scan(L,noPunct,Brk));	! ignore non-digits;
	    if I > (2400) or I mod 100 geq 60 then begin
		print("?bad time format, use @hhmm or @hh:mm",crlf);
		continue; end;
	    I _ ((I%100)*60)+(I mod 100);	! mins past 0000;
	    I _ (I*60000 - call(0,"MSTIME"))%60000;
	    while I < 0 do I _ I + (24*60);
	    I _ I mod (12*60);	! either 12/24 hr clk ok;
	    done; end;
	if L="0" or cvd(L) > 0 then begin
	    I _ cvd(L);
	    done; end;
	print("?bad time, type ""?"" for help",crlf);
	end until false;
    if (I < MinTakedown) and not WC then
	print("Minimum takedown is ", I _ MinTakedown, crlf);
    return (I * jpm);
    end;

integer procedure GET!GRACE!PERIOD;
begin
    integer I;
    string L;
    do begin
	print("Enter grace period in minutes: ");
	I _ cvd(L _ get!line);
	if length(L)=0 then
	    print("Grace period is ",I_MinGrace,crlf);
	if I=0 and L="0" then begin
	    print("You are nasty!!!",crlf);
	    done; end;
	if I=0 then begin
	    print("Enter time to allow active jobs to remain",
		" after Scheduled down time.", crlf);
	    end;
	end until I;
    if (I < MinGrace) and not WC then
	print("Minimum grace is ",I_MinGrace,crlf);
    return(I);
    end;

boolean procedure CONFIRM;
begin
    string S;
    forever do begin "CONF"
	print("    okay? ");
	S _ get!line;
	if S = "Y" then return(true);
   	if S = "N" then return(false);
	print ("Enter ""Y"" or ""N"" please...");
	end "CONF";
    end;


sub!title	Logging subroutines;

simple procedure lprint(string msg);
begin
    print(bel,msg,crlf);
    log(msg);
end;

require "(SAILIB)EXTEND" library;
external simple string procedure StDate (integer Date,Flag('31));

simple string procedure StTime (integer Time);
begin "StTime"
    integer A,B;
    string T;
    getformat(A,B); setformat(-2,0);
    T _ cvs(Time%3600000) & ":" & 
    	cvs(Time%60000 mod 60) & ":" &
    	cvs(Time%1000 mod 60);
    setformat(A,B);
    return(T);
    end "StTime";

simple procedure ReadDayTime (reference integer Date,Time);
    do begin
	Date _ calli(0,DateUUO);
	Time _ calli(0,MstimeUUO);
	end until Date = calli(0,DateUUO);

simple string procedure DayTime;
begin
    integer Date,Time;
    ReadDayTime (Date,Time);
    return (StDate (Date) & " " & StTime (Time));
end;

integer LogChan;
string LogName;

simple procedure Log (string Msg);
begin
    if not LogChan then return;
    out(LogChan, DayTime);
    out(LogChan, "  ");
    out(LogChan, Msg);
    out(LogChan, crlf);
end;

simple procedure OpenLog;
begin
    open(LogChan_getchan,"DSK",1,0,2, 0,0,!SKIP!);
    if !SKIP! then usererr(0,0,"?can't init DSK:","X");
    LogName _ cvs(MyJob) & cv6str(peek(JBTNAM+MyJob)) & ".TMP";
    enter(LogChan, LogName, !SKIP!);
    if !SKIP! then usererr(0,0,"?can't enter log file: "&LogName,"X");
    Log ("** Session begins: " & cv6str(peek(JBTNAM+MyJob))
	& " version " & cvs(memory['137]) & ".");
    if Oper!Name then Log ("* Opername: "&Oper!Name
			&", Username: "&User(MyJob))
		else Log ("* Username: "&User(MyJob));
    end;

simple procedure CloseLog;
if LogChan then begin
    own integer C,B,E,W,I;
    own string N;
    define MaxTry = 15;	! Max # seconds to try for log file interlock;
    define MaxSize = 500; ! Max size to allow log file to become 
				(in tenths of a page);
    Log ("** Session ends."&crlf);
    W _ LogChan;
    LogChan _ 0;
    close(W);
    open(C,"DSK",1,2,0, 256,B,E);
    if E then return;
    N _ cv6str(peek(JBTNAM+MyJob)) & ".LOG"
	& "[" & cvos(lh(peek(JBTFPN+MyJob)))
	& "," & cvos(rh(peek(JBTFPN+MyJob))) & "]";
    for i_1 upto MaxTry do begin
	close(W);
	enter(W,N,E);
	if E
	    then call(1,"SLEEP")
	    else done;
	end;
    if E then begin
	print("?can't update log, please notify OS group",crlf);
	release(C); release(W);
	return;
	end;
    lookup(C,LogName,E);
    while not E do out(W,input(C,0));
    rename(C,null,0,E);
    close(C);
    lookup(C,N,E);
    for i_1 upto MaxSize do begin
	if E then done;
	out(W,input(C,0));
	end;
    if not E then out(W,crlf&"** file truncated **"&crlf);
    close(C);
    close(W);
    release(W);release(C);
    end;


sub!title	Command scanner and handler;

procedure COMMAND;
begin "COM"
    string COM,ARG;
    integer I,C;
    define Error (MSG) = {begin
	print(MSG, crlf);
	return;
	end};
    ARG _ get!line;
    auxclv(-1,0,'6);	! clear input buffer - prevent jam;
    LevDef;
    scan(ARG,nonBlanks,BRK);
    COM _ scan(ARG,blanks,BRK);
    ifc compiler!switch("B") thenc if WC and equ(COM,"BAIL") then begin
	Log ("* Entering BAIL");
	usererr(0,0,0,"B");
	Log ("* Returning from BAIL");
	print(crlf,"Returning from BAIL",crlf);
	return;
	end; endc
    J_0;
    if COM=null then COM_"NULL";
    if COM="?" then COM_"HELP";
    for I _ arrinfo(CMDS,1) upto arrinfo(CMDS,2)
	do if equ(COM,CMDS[I][1 to length(COM)])
	    then begin
		J_J+1;
		C_I;
		end;
    if J < 1
	then error("?unrecognized command");
    if J > 1
	then error("?ambiguous command");
    if (CmdF[c] land ReqWC) and not WC 
	then error("?command requires Write-Core (WC) license");
    if 0=(1 lsh Mode land CMDF[C]) 
	then error("?command illegal in "&
	    (if Mode=Manual then "manual" else "automatic")&
	    " mode");
    if CMDF[C] land Logit then Log (CMDS[C] & " " & Arg);
    case C of begin "commands"
	[com!HELP] begin "HelpCmd"
	    integer C,I;
	    I _ 0;
	    if length(Arg)=0 then print("One of the following:",crlf);
	    for C _ arrinfo(CmdH,1) upto arrinfo(CmdH,2)
		do if (WC or (CmdF[c] land ReqWC)=0)
		  and equ(Arg,CmdS[c][1 to length(arg)])
		    then begin
			print("  ",CmdH[c],crlf);
			I _ I +1;
		    end;
	    if I=0 then print("?illegal command: """,Arg,""""&crlf);
	end "HelpCmd";
	[com!CONFIGURATION] print(configMsg);
	[com!INSTRUCTIONS] print(comins);
	[com!OPER] begin
	    WC _ Oper!License (arg);
	    if Oper!Name then print("okay.",crlf);
	    end;
	[com!NULL] print(
	    DayTime,";   ",
	    (if Mode=Auto then cvtime(!sign+!secs)&";   " else null),
	    NXJobCount, " non-exempt jobs.", crlf);
	[com!REMARK] if length(Arg) then begin
	    string G,T;
	    G _ ";";
	    do begin
		T _ " " & scan(Arg,blanks,Brk);
		if length(G)+length(T) geq 60 then begin
			Log (G);
			G _ ";";
			end;
		G _ G & T;
		end
	    until Brk=0;
	    if length(G) > 1 then Log (G);
	    print( "Thank you.",crlf );
	    end;
	[com!BOOTS] print(BootsAction(arg),crlf);
	[com!ONCE] print(OnceAction(arg),crlf);
	[com!DSKCLN] print(DskClnAction(arg),crlf);
	[com!EXEMPT] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do if Apropos(Job) 
		then JS[job] _ JS[job] lor exemptFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!UNEXEMPT] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ExemptSpec _ true;
	    ForEachJob do if Apropos(Job) 
		then JS[job] _ JS[job] land lnot exemptFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!IMMUNE] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do 
	      if (JS[job] land immuneFlag)=0 and Apropos(Job) 
		then JS[job] _ JS[job] lor immuneFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!UNIMMUNE] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do 
	      if (JS[job] land immuneFlag) and Apropos(Job) 
		then JS[job] _ JS[job] land lnot immuneFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!SCHED] case Arg of begin
	    ["A"]["0"] AnswerSystem;
	    ["S"] case Arg[2 for 1] of begin
		["H"] ShutSystem;
		["U"] SuperShutSystem;
		else end;
	    ["4"] ShutSystem;
	    ["2"]["6"] SuperShutSystem;
	    else if length(Arg)
		then error("?unrecognized state")
		else print("Schedule = ",cvos(States),crlf)
	    end;
	[com!WATCH] begin case Arg[2 for 1] of begin
	    [null] nothing;
	    ["N"] Watch_true;
	    ["F"]["I"] Watch_false;
	    else error("?unrecognized argument") end;
	    print("Watching ",
		(if Watch then "en" else "dis"), "abled.", crlf);
	    end;
	[com!QUIT] Abort;
	[com!CANCEL] begin
	    print("Cancel takedown,");
	    if not Confirm then return;
	    if BroadcastFlag then
		talk("Timesharing will continue until further notice");
	    Restore!Sys!Message;
	    print("Takedown canceled.",crlf,"Manual mode.",crlf);
	    Mode _ manual;
	    DownFlag _ 0;
	end;
	[com!SYSTAT] systat(arg);
	[com!CLEAR] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do
		if Apropos(Job) then Clear(Job);
	    print("[",jobs,"]",crlf);
	end;
	[com!HANG] begin "TAKE-IT"
	    print("Hang system ", SysName, ",");
	    if CONFIRM then DownFlag _ 4;
	end;
	[com!CRASH] begin
	    print("Crash system ", SysName, " by deposit in 30,");
	    if Confirm then Crash;
	end;
	[com!KILL] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do
		if Apropos(Job) then begin
		    if UnconditionalSpec 
			then JS[job] _ JS[job] land lnot pendingMask;
		    HangJob(Job);
		end;
	    if Jobs!=0 then print("[",jobs,"]",crlf);
	end;
	[com!TALK] begin "TALK"
	    string TOK,JS,MSG;
	    if ARG="?" then error("One of
  TALK ALL message
  TALK JOB # message
  TALK TTY#: message
");
	    TOK _ scan(ARG,blanks,brk);
	    if equ(TOK,"ALL") then JS _ "ALL"
	    else if equ(TOK,"JOB") then JS _ scan(ARG,blanks,brk)
	    else if equ(TOK[1 to 3],"TTY") then JS _ TOK
	    else begin
		JS _ "ALL";
		ARG _ TOK & ARG;
	    end;
	    Msg _ bel & crlf & ";;OPR: - " & Arg & crlf & bel;
	    if ScanSpec(JS) then begin
		ForEachJob do if not detached(job) then
		    if Apropos(job) then MsgQ[job] _ MsgQ[job] & Msg;
		print("[",Jobs,"]",crlf);
	    end;
	end "TALK";
	[com!SEND] if ScanSpec(Arg) then begin
	    string msg,lin,tok,T;
	    if DefaultSpec then error("?job spec expected");
	    print("Enter message (end with ^D):",crlf);
	    msg _ bel & crlf &
		";;message from OPR: (" & initials & ")..." & crlf;
	    lin _ null;
	    do begin "input"
		Poll!Jobs;
		print(";; ");
		T _ get!line(fullCase);
		while length(T) do begin "fill"
		    integer Brk;
		    tok _ scan(T,fcb,brk);
		    if length(tok)=0 then continue;
		    if length(lin)+length(tok)+4 > LOL 
			then begin
			    msg _ msg & bel & ";;" & lin & crlf;
			    lin _ " " & tok end
 			else lin _ lin & " " & tok;
		end "fill";
	    end "input" until !SKIP! = ctrl("D");
	    if length(lin) then msg _ msg & ";;" & lin & crlf;
	    msg _ msg & bel;
	    ForEachJob do if not detached(job) then
		if Apropos(job) then MsgQ[job] _ MsgQ[job] & Msg;
	    print(crlf,"[",Jobs,"]",crlf);
	    end;
	[com!WARNING] Warning;
	[com!AUTO] Automatic (Arg);
	[com!RELOAD] AutoReload (Arg);
	[com!GRACE]
	    if (I_cvd(Arg)) geq (J_(if WC then 0 else minGrace))
		then begin
		    Grace _ I;
		    print( "Grace period set",crlf );
		    end
		else error("?must be "&cvs(J)&" or more");
	[com!HOLD] begin
	    if Hold then error("?countdown already Holding");
	    Hold _ uptime;
	    print("Countdown Holding", crlf);
	    end;
	[com!CONTINUE] begin
	    if Hold=0 then error("?countdown not Holding");
	    Time!0 _ Time!0 + (uptime-Hold);
	    Hold _ 0;
	    print("Countdown continued", crlf);
	    end;
	[com!SET] begin "Set"
	    SetClock( GetTakedownTime( Arg ));
	    print( "Countdown set",crlf );
	    end "Set";
	[com!ACTION] begin "Action"
	    Action _ get!action( Arg );
	    print( "Action set",crlf );
	    end;
	[com!DETACH] if ScanSpec(Arg) then
	    if DefaultSpec
		then Detach
		else begin
		    ForEachJob do
			if Apropos(Job) then Detach(Job);
		    print("[",jobs,"]",crlf);
		    end;
	[com!ATTACH] if ScanSpec(Arg) then begin
	    integer JobNo;
	    if DefaultSpec then error("?job-spec expected");
	    DetSpec _ true;
	    ForEachJob do 
		if detached(job) and Apropos(job) then JobNo_Job;
	    if Jobs! = 0 then error("?no job satisfying request");
	    if Jobs! neq 1 then error("?job-spec is ambiguous");
	    attach (JobNo);
	    end;
	else error("?command not implimented")
	end;
    end;


sub!title	Once per second and once per minute code;

procedure PER!SECOND;
begin "PS"
    if Zapped then begin
	lprint ("* TAKEIT killed - aborting");
	Abort;
	end;
    if not DetachFlag and Detached(MyJob) then begin
	Log ("* circuit zapped");
	DetachFlag _ true;
    end;
    if DetachFlag and not Detached(MyJob) then Cont;
    auxclv(-1,0,'50);		! skip if line waiting;
    LevDef;
    if !SKIP! then COMMAND;
    if Mode = Auto then begin "Auto"
	SetOper;
	if Tics<0
	    then begin "GracePeriod"
		SuperShutSystem;
		if Action = Manual
		    then begin
			Mode _ manual;
			print(bel, "Manual mode.", crlf);
			end
		    else if (Mins leq -Grace) or (NXJobCount=0)
			then case Action of begin
			    [boots!loaded] DownFlag _ 4;
			    [deposit!30] DownFlag _ 5;
			    [stand!alone] DownFlag _ 6;
			    [reload] DownFlag _ 7;
			    else usererr(Action,0,"??bad Action: ")
			    end
			else DownFlag _ 1;
		end "GracePeriod"
	    else begin "NonGracePeriod"
		end "NonGracePeriod";
	end "Auto";
    POLL!JOBS;
    if States neq LastStates then begin
	print(bel, bel,
	    "**Schedule set to ",cvos(States)," by another job.",crlf,
	    "**Schedule was ",cvos(LastStates),crlf);
	Log ("* Another job set SCHED " & cvos(States)
	    & " from " & cvos(LastStates));
	LastStates _ States;
	end;
    if WantSuperShut then SuperShutSystem;
    if DownFlag geq 1 then HangIdleJobs;
    if DownFlag geq 2 then HangNXJobs;
    if DownFlag geq 3
	and NXJobCount=0 then HangAllJobs;
    if DownFlag geq 4
	and OneJob then begin "StandAlone"
	    print (Bel, "System is Stand-Alone", crlf);
	    case DownFlag of begin
		[4] HangSystem;
		[5] Crash;
		[6] Abort;
		[7] ReloadSystem;
		else usererr(DownFlag,2,"??bad value for DownFlag: ")
		end;
	    end "StandAlone";
    end "PS";

procedure PER!MINUTE;
begin "PM"
    print(bel,
	(if Mode = Manual then null else CvTime(!spcl+!sign)&", "),
	NXJobCount, " non-exempt jobs.", crlf);
    if Mode = Manual then return;
    if Mins=0 then SuperShutSystem;
    if Mins=ShutTime then ShutSystem;
    case Mins of begin
	[FirstMsg] begin
	    Warning;
	    if REASON then talk(REASON);
	    end;
	[10][5][2][1][0] Warning;
	else nothing end;
    Update!Sys!Message (tics);
end "PM";

simple boolean procedure Fast;
! return true if should be polling fast;
begin "fast"
    if (Mode neq Manual) and (Mins leq 5) then return(true);
    if DownFlag then return(true);
    for J _ 1 upto JobN do 
	if jsb(JS[j]) or length(MsgQ[j]) then return(true);
    return(false);
end "fast";

sub!title	Automatic takedown stuff;

procedure Automatic (string Arg);
begin "Auto"
    SetOper;			! make TTY: the OPR: terminal;
    Save!Sys!Message;		! rename SYS:ACCESS.MSG for later;
    if length(Arg)
	then begin "ShortForm"
	    if length(Oper!Name) 
		then Initials _ Oper!Name
		else Initials _ User(MyJob);
	    Reason _ Arg;
	    Arg _ scan(Reason,comma,Brk);
	    if Brk="," and length(Reason)=0
		then Reason _ null
		else Reason _ get!reason(Reason);
	    Action _ Boots!Loaded;
	    Tics _ GetTakedownTime(Arg);
	    Grace _ minGrace;
	    end "ShortForm"
	else begin "LongForm"
	    Initials _ get!oper!name;
	    Reason _ get!reason;
	    Action _ get!action;
	    Tics _ GetTakedownTime;
	    Grace _ get!grace!period;
	    end "LongForm";
    print(
	crlf,
	"System ", SysName,
	" will leave timesharing in ", cvTime(!spcl),
	" /", Initials, crlf,
	"Grace period is ", Grace, " minutes.", crlf,
	(if Reason then Reason&crlf else null),
	case ACTION of (null,
	    "System will be hung."&crlf,
	    "System will be stand alone."&crlf,
	    "System will crash."&crlf,
	    "System will reload "&MonitorVer&" from "&Monitor&"."&crlf
	) );
    if not CONFIRM then begin
	Restore!Sys!Message;
	Mode _ manual;
	print("Automatic takedown aborted",crlf);
	return;
    end;
    Log ("* Countdown = " & cvTime(!spcl) & ", Grace = "
	& cvs(Grace));
    if Reason then Log ("* """ & Reason & """");
    Mode _ Auto;
    SetClock;
    Watch _ true;
    if Mins < FirstMsg then begin
	Warning;
	if Reason then Talk(Reason);
    end;
end "Auto";

procedure ClearAutomatic;
begin "CA"
    print(bel,bel, "Manual mode.", crlf);
    Restore!Sys!Message;
    Mode _ manual;
    SetClock (0);
    Grace _ 0;
    Action _ 0;
end "CA";

sub!title	Automatic reload stuff;

procedure AutoReload (string Arg);
begin "Reload"
    SetOper;			! make TTY: the OPR: terminal;
    Save!Sys!Message;		! rename SYS:ACCESS.MSG for later;
    Action _ Reload;
    if length(arg)
	then begin "ShortForm"
	    if length(Oper!Name) 
		then Initials _ Oper!Name
		else Initials _ User(MyJob);
	    Monitor _ Arg;
	    Arg _ scan(Monitor,comma,Brk);
	    if not BRK then Monitor_"(SYS)SYSTEM";
	    Monitor _ get!monitor!name(monitor);
	    Tics _ GetTakedownTime(Arg);
	    Grace _ minGrace;
	end "ShortForm"
	else begin "LongForm"
	    Initials _ get!oper!name;
	    Monitor _ get!monitor!name;
	    Tics _ GetTakedownTime;
	    Grace _ get!grace!period;
	end "LongForm";
    Reason _ "System going down to reload monitor "& MonitorVer;
    print(
	crlf,
	"System ", SysName,
	" will leave timesharing in ", cvTime(!spcl),
	" /", Initials, crlf,
	Reason, crlf,
	"Grace period is ", Grace, " minutes.", crlf,
	"System will reload ", MonitorVer, " from ", Monitor, "."&crlf);
    if not CONFIRM then begin
	Restore!Sys!Message;
	Mode _ manual;
	print("Automatic takedown aborted",crlf);
	return;
    end;
    Log ("* Countdown = " & cvTime(!spcl) & ", Grace = " & cvs(Grace));
    Log ("* Reloading " & MonitorVer & " from " & Monitor);
    Mode _ Auto;
    SetClock;
    Watch _ true;
    if Mins < FirstMsg then begin
	Warning;
	if Reason then Talk(Reason);
    end;
end "Reload";

sub!title	*** M A I N   P R O G R A M ***;

    CheckMyLicense;		! make sure program has license;
    print("TAKEIT version ", memory['137], " at ", DayTime, crlf,
	(if Debug then "** DEBUG **"&crlf else null));
    SetAdr;			! get critical monitor addresses;
    LevDef;			! try and get node to do echoing;
    WC _ CheckUserLicense;	! make sure user has WC or HU;
    InitFlag _ true;		! indicates that we are init'd;
    CheckAlone;			! warning if someone else running this;
    SetJACCT;			! insure control;
    NTQinit;			! enable notice to quit interrupt;
    SetSchprv;			! in case someone else has it;
    OpenLog;			! log everything that happens;
    ContinueOnDisconnect;	! in case they hang up on us;
    open(SysMsg_getchan,"SYS",1,0,5,0,0,!SKIP!);
CommandLevel:			! a ^C jumps here (sometimes);
    print("Enter commands (type ""?"" for help):", crlf);
    forever do begin "MIN"
	do begin "SEC"
	    Per!Second;		! execute once per second;
	    calli(hl('21)+(if fast then 1 else SlowPollRate),HiberUUO);
	    end until ReadClock;
	Per!Minute;		! execute once per minute;
	end;
    end "MAIN";
end $

  0@R