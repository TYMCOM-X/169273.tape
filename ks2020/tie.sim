!This routine must be compiled with the (P) option.

\ENTRYNAME "I%TIE"
GLOBAL "I%TIE"=%TIE

!TIE IS A PROCEDURE THAT CREATES A BUFFER
!OF CHARACTERS CORRESPONDING TO A LINE IMAGE TYPED IN AT THE TERMINAL
!(THE ONE IN CONTROL OF THE JOB); IT ALSO CALLS PROCEDURES WHICH
!INITIALIZE OR SET CERTAIN LINE EDITING PARAMETERS.
!LINE IMAGE EDITING IS DONE AT THE TERMINAL,USING AN OLD LINE IMAGE, IF ANY.
!
!CARRIAGE RETURNS AND CONTROL CHARACTERS:
!UNLESS CALLER SPECIFIES OTHERWISE,
!IT IS MANDATORY THAT THE OLD LINE IMAGE PRESENTED TO THESE PROCEDURES
!CONTAIN NO CARRIAGE RETURN, OR ANY OTHER CONTROL CHARACTER, OR DELETE
!(RUBOUT). IF ANY OF THESE CHARACTERS IS FOUND IN THE IMAGE, AN ERROR
!CODE IS RETURNED BEFORE ANY WORK IS DONE.
!
!   IT IS THE INTENT OF THE DESIGN OF THIS PROGRAM THAT ALL CHARACTERS
!IN A LINE IMAGE ARE PRINTING CHARACTERS (WITH THE EXCEPTION OF
!SPACES). ALL OTHER CHARACTERS PERFORM ONLY A LOGICAL FUNCTION, AND ARE
!NOT NECESSARILY STORED IN THE TEXT. CARRIAGE RETURN ENDS A LINE, ALTHOUGH
!IT IS NEVER FOUND AT THE END OF A LINE IMAGE. LINE FEED ENDS THE LINE ALSO
!(WITH A CONTROL PROPERTY DESCRIBED ELSEWHERE).
!
!HOWEVER, ONE MAY SPECIFY THAT CONTROL CHARACTERS WILL BE ACCEPTED.
!
!IF CALLED FROM SIMPL, ONE INCLUDES THE STATEMENT:
!        FIND "I%TIE"=%TIE
!THE CALL IS TIE(TIRE), OR IN MACRO:
!        MOVEI 1,TIRE
!        PUSHJ 17,I%TIE
!
!THE PROGRAM RETURNS UPON LINE TERMINATION.
!UPON RECEIPT OF AN ACTIVATION CHARACTER OR IN THE EVENT OF AN ACTIVATION
!CONDITION, A CALLER SUPPLIED FUNCTION IS CALLED, AS SPECIFIED IN
!THE TERMINAL INPUT REQUEST ELEMENT (TIRE). IN THIS CASE,
!THIS PROGRAM CALLS A SPECIFIED CALLER FUNCTION THAT DECIDES WHETHER
!TO CONTINUE OR PROCESS THE ACTIVATION.
!CAUTION MUST BE TAKEN IN CONTINUING FROM AN ACTIVATION;
!IF THE LINE IMAGES ARE ALTERED DURING AN ACTIVATION, BEHAVIOR
!IS UNDEFINED.
!THE TIRE:
!
!THE TERMINAL INPUT REQUEST ELEMENT IS THE ONLY PARAMETER FOR THE
!%TIE ROUTINE. IT IS A BLOCK OF PARAMETERS OF VARIABLE LENGTH.
!THE LENGTH IS SPECIFIED BY THE ZEROETH PARAMETER, WHICH IS A COUNT OF
!ENTRIES TO FOLLOW. THE MINIMUM LENGTH IS 3 (NOT COUNTING THE COUNT ENTRY).
!THE STRUCTURE OF THE TIRE:
!
!WORD #         PARAMETER NAME
!
!0              COUNT
!1              RETURN.CODE
!2              UOBCB
!3              UNBCB
!4              %GETPROMPT
!5              TABS
!6              %SETALT
!7              %ACTIVATE
!8              ACT.CHR.WAS.TXT.P
!9              ACT.CHAR
!10             ACT.ON.D.P
!11             ACT.ON.Q.P
!12             ACT.ON.RING.P
!13             ACTIVATION.MASK
!14             BUFNUM
!15             OLWORK
!16             NLWORK
!17             %GETCHAR
!18             %OUTCHAR
!19             CONTROL.CHARS.P
!20             CONTROL.G.P
!21             LINE.CONTINUATION.P
!22             SEMI.EDIT.P
!23             KATA.KANA.P
!   THE PARAMETERS:
!
!COUNT IS THE COUNT OF ENTRIES TO FOLLOW IN THE TIRE. THE MINIMUM COUNT
!   IS 3.
!
!UOBCB AND UNBCB ARE THE ADDRESSES OF THE USER'S 'OLD' BUFFER CONTROL BLOCK
!   AND THE 'NEW'. EVERY BUFFER CONTROL BLOCK HAS THE SAME STRUCTURE
!   OF FIVE ELEMENTS:
!
!   ELEMENT 1: THE ADDRESS OF THE FIRST WORD OF THE BUFFER.
!   ELEMENT 2: THE LENGTH OF THE BUFFER IN CHARACTERS.
!   ELEMENT 3: THE COUNT OF CHARACTER POSITIONS TO THE LEFT OF THE LINE IMAGE.
!   ELEMENT 4: THE COUNT OF THE NUMBER OF POSITIONS IN THE BUFFER UP TO AND
!              INCLUDING THE LAST CHARACTER OF THE LINE IMAGE.
!   ELEMENT 5: A CURSOR INTO THE LINE IMAGE, WHICH IS THE COUNT OF CHARACTER
!              POSITIONS UP TO AND INCLUDING THE CHARACTER POINTED TO.
!
!PARTICULARS:
!   1) BUFFERS START ON WORD BOUNDARIES.
!   2) CURSORS ALWAYS POINT TO THE LAST CHARACTER ENTERED OR MENTIONED.
!      INITIALLY, CURSORS SHOULD POINT TO THE CHARACTER POSITION PRECEEDING
!      THE FIRST CHARACTER OF THE LINE IMAGE. THIS IS UNLIKE A
!      TYPEWRITER CURSOR, WHICH POINTS TO THE CHARACTER ABOUT TO BE TYPED.
!   3) THE CONTENTS OF EITHER BUFFER MAY BE CHANGED BY THIS PROGRAM.
!   4) THE LENGTH OF THE OLD BUFFER MUST EQUAL THE LENGTH OF THE NEW.
!
!%GETPROMPT IS THE ADDRESS OF A FUNCTION PROVIDED BY THE CALLER THAT
!    RETURNS THE ADDRESS OF THE BUFFER CONTROL BLOCK FOR THE PROMPT.
!    IF ELEMENT 3 EQUALS ELEMENT 4 THEN THE PROMPT IS NULL. ELEMENT 5 IS IGNORED.
!    IF %GETPROMPT IS ZERO, THEN THE PROMPT IS NULL ALSO.
!
!TABS IS THE ADDRESS OF THE FIRST WORD OF AN ARRAY OF ELEMENTS WHICH MAY
!     BE SUPPLIED UPON EACH CALL TO TIE. THE ELEMENTS SHOULD BE
!     ORDERED IN INCREASING VALUE, ALTHOUGH NO ERROR RETURN IS PROVIDED
!     IF THERE IS NO ORDERING.THE FIRST WORD OF TABS IS THE COUNT OF ELEMENTS.
!     A TAB STOP IS DEFINED AS AN INTEGER CORRESPONDING TO A PRINTER HEAD
!     POSITION ON A HYPOTHETICAL KEYBOARD SUCH THAT IF THE TYPIST IS AT THE
!     I-TH TABSTOP, THE NEXT PRINTING CHARACTER TYPED PRINTS AT THAT TABSTOP
!     POSITION. THE ALGORITHM TO SELECT THE NEXT TABSTOP INVOLVES
!     WALKING THROUGH THE ARRAY UNTIL AN INTEGER IS FOUND WHICH IS LARGER
!     THAN THE CURRENT NEW LINE PRINT POSITION PLUS ONE.
!     IF NO SUCH INTEGER IS FOUND,
!     THE NEXT TABSTOP IS DEFINED AS THE CURRENT POSITION PLUS TWO,
!     WITH THE RESULT OF ADDING ONE SPACE TO THE LINE IMAGE.
!     IF TABS IS ZERO, A DEFAULT SET OF 10 TABSTOPS IS USED:
!     9,17,22,27,32,37,42,47,52,57.
!
!
!%SETALT IS THE ADDRESS OF A FUNCTION PROVIDED BY THE CALLER THAT
!   ACCEPTS AS AN ARGUMENT (IN REGISTER 1) THE ADDRESS TO GO TO
!   IN THE EVENT OF AN ESCAPE. %SETALT MUST RETURN AS A VALUE
!   (IN REGISTER 1) THE PREVIOUS DISPATCH ADDRESS.
!
!%ACTIVATE IS THE ADDRESS OF A FUNCTION PROVIDED BY THE CALLER THAT
!   WILL BE CALLED ON ANY ACTIVATION CONDITION. IT MUST DECIDE WHETHER TO
!   SIMPLY RETURN AND HAVE THIS PROGRAM HANDLE THE CONDITION IN ITS
!   NORMAL MANNER, OR TO PROCESS THE ACTIVATION ITSELF. %ACTIVATE
!   WILL BE CALLED WITH THE ADDRESS OF THIS PROGRAM'S INTERNAL TIRE
!   AS THE FIRST ARGUMENT (IN REGISTER 1). CHANGES MAY BE MADE TO THIS
!   TIRE DURING AN ACTIVATION; WHEN %TIE RETURNS TO THE ORIGINAL CALLER,
!   INTERNAL TIRE ENTRIES ARE COPIED BACK INTO THE CALLER'S TIRE.
!   CALLER RETURNS A VALUE (IN REGISTER 1) OF 0 TO ABORT, INDICATING
!   HE WILL PROCESS THE ACTIVATION. TO REQUEST CONTINUATION OF INPUT,
!   CALLER RETURNS A VALUE OF 1, UNLESS HE HAS MADE CHANGES TO THE TIRE.
!   IN THIS CASE, HE MUST RETURN A VALUE OF 2.
!   IF %ACTIVATE IS NOT PROVIDED, THE FOLLOWING TIRE ELEMENTS ARE IGNORED:
!      ACT.ON.Q.P
!      ACT.ON.D.P
!      ACT.ON.RING.P
!      ACTIVATION.MASK
!      BUFNUM
!
!ACT.CHR.WAS.TXT.P IS NORMALLY SET BY THIS PROGRAM. IF TRUE (=1)
!   THEN THE ACTIVATION CHARACTER WAS TEXT, AS OPPOSED TO HAVING
!   A CONTROL FUNCTION. FOR EXAMPLE, IF A CONTROL R IS COPIED FROM
!   THE OLD LINE TO THE NEW, AND CALLER IS ACTIVATING ON CONTROL
!   CHARACTERS, THE ACTIVATION CHARACTER IS TEXT. IF THE CONTROL R
!   HAD BEEN TYPED DIRECTLY FROM THE KEYBOARD, IT WOULD NOT BE TEXT.
!
!ACT.CHAR CONTAINS THE CHARACTER RESPONSIBLE FOR THE ACTIVATION.
!   FOR THE LNGCOD RETURN IT IS THE CHARACTER THAT DIDN'T FIT INTO THE LINE.
!   FOR THE BELCOD RETURN IT IS THE CONTROL CHARACTER THAT CAUSED THE BEL
!   CONDITION.
!   FOR THE ACTCAR RETURN IT IS THE ACTIVATION CHARACTER. ACTIVATION CHARACTERS
!   ARE ALWAYS PRINTED BY THIS PROGRAM, BEFORE OR AFTER THE ACTIVATION CALL.
!   UPON AN ACTIVATION CALL TO %ACTIVATE, THE ACTIVATION CHARACTER MAY ALSO BE
!   FOUND IMMEDIATELY FOLLOWING THE LAST CHARACTER IN THE NEW LINE.
!
!ACT.ON.D.P IS TRUE (=1) IF CALLER WANTS TO BE ACTIVATED ON CONTROL D
!   TYPED AT THE BEGINNING OF A LINE (WHEN OLD AND NEW CURSORS ARE AT
!   MINIMUM VALUES). IF CALLER CONTINUES AFTER AN ACTIVATION, CONTROL D
!   WILL PERFORM ITS NORMAL FUNCTION OF COPYING THE REST OF THE OLD LINE
!   AND TERMINATING.
!
!ACT.ON.Q.P IS TRUE(=1) IF CALLER WANTS TO BE ACTIVATED ON CONTROL Q
!   TYPED AT THE BEGINNING OF A LINE. IF CALLER CONTINUES AFTER AN ACTIVATION,
!   CONTROL Q WILL RING BEL.
!
!ACT.ON.RING.P IS TRUE (=1) IF CALLER WANTS TO BE ACTIVATED WHEN A BEL
!   CONDITION OCCURS. THE CONTROL CHARACTER RESPONSIBLE FOR THE CONDITION
!   WILL BE IN ACT.CHAR. IF CALLER CONTINUES AFTER AN ACTIVATION,
!   BEL WILL BE RUNG AND PROCESSING  OF INPUT CONTINUES.
!
!ACTIVATION.MASK IS EIGHT (8) BITS RIGHT JUSTIFIED THAT SPECIFY WHICH
!   CHARACTERS SHOULD CAUSE ACTIVATION.
!
!SET    MASK    BIT#    MEMBERS
!
!  1     200      28    CONTROL M (CARRIAGE RETURN) AND CONTROL J (LINE FEED)
!  2     100      29    CONTROL I (HORIZONTAL TAB)
!3,4      60    30,31   ALL OTHER CONTROL CHARACTERS AND DEL
!  5      10      32    THE CHARACTERS / = _ ^
!  6       4      33    THE CHARACTERS % ; !
!  7       2      34    ALL ALPHANUMERICS AND SPACE
!  8       1      35    ALL OTHER PRINTING CHARACTERS
!
!   THIS PROGRAM NORMALLY RETURNS ON ^M AND ^J, SO SET 1 NEED
!   NOT BE SET TRUE (=1) FOR NORMAL OPERATION. SET 1 MUST BE TRUE IF
!   CALLER WANTS TO BE ACTIVATED WHEN ^J OR ^M IS COPIED FROM THE
!   OLD LINE OR ENTERED WITH CONTROL V.
!   TO ACTIVATE ON SET 3-4, BOTH BITS MUST BE SET.
!
!BUFNUM IS NON-ZERO WHEN CALLER WANTS COMMAND BUFFERS IMPLEMENTED.
!   IF CONTROL B IS TYPED, THIS PROGRAM TURNS OFF ECHO AND WAITS FOR THE USER TO TYPE
!   A CHARACTER. IN THE NORMAL CASE, IT IS A NUMBER BETWEEN 0 AND 9.
!   THE CHARACTER TYPED IS PLACED IN ACTCAR. THE CONTINUE OPTION AFTER AN
!   ACTIVATION IS NORMAL, AND CALLER IS EXPECTED TO HAVE PRINTED THE #1, ETC.
!   IF THE CHARACTER IS ILLEGAL, CALLER'S ACTIVATION ROUTINE SHOULD RETURN
!   AN ABORT  VALUE. BEL WILL THEN BE RUNG AND INPUT WILL CONTINUE.
!
!OLWORK AND NLWORK ARE THE ADDRESSES OF BLOCKS WHICH WILL BE USED IN THE
!   SYNCHRONIZATION OF THE OLD AND NEW LINE IMAGE CURSORS. THEY ARE
!   NECESSARY IF THE LINE BUFFER LENGTH IS GREATER THAN 256 CHARACTERS.
!   EACH BLOCK MUST CONTAIN 1 BIT FOR EACH CHARACTER.

!%GETCHAR IS THE ADDRESS OF A FUNCTION PROVIDED BY THE CALLER THAT
!   RETURNS A CHARACTER. IT IS USED IN THE IMPLEMENTATION OF
!   COMMAND BUFFERS, AS A SURROGATE FOR NORMAL TERMINAL INPUT. CARRIAGE
!   RETURN MUST BE FOLLOWED BY A LINE FEED.
!   IT WILL BE CALLED WITH THE ADDRESS OF THE INTERNAL TIRE AS AN
!   ARGUMENT (IN REGISTER 1), SO THAT IT CAN SET THE GETCHAR
!   ENTRY BACK TO ZERO.
!
!%OUTCHAR IS THE ADDRESS OF A FUNCTION PROVIDED BY THE CALLER THAT
!   ACCEPTS 1 CHARACTER FOR THE OUTPUT STREAM AS AN ARGUMENT (IN REGISTER 1).
!   IT IS USED IN THE IMPLEMENTATION OF COMMAND BUFFERS, AS A
!   SURROGATE FOR NORMAL TERMINAL OUTPUT.
!   IT WILL BE CALLED WITH THE ADDRESS OF THE INTERNAL TIRE AS AN ARGUMENT
!   (IN REGISTER 1), SO THAT IT CAN SET THE OUTCHAR ENTRY BACK TO ZERO.
!
!CONTROL.CHARS.P IS TRUE (=1) IF CALLER WANTS TO ALLOW CONTROL CHARACTERS
!   IN THE LINE IMAGES. IF FALSE, NO CONTROL CHARACTERS OR DEL ARE ALLOWED
!   IN THE OLD LINE UPON ENTRY, AND CONTROL V RINGS BEL.
!
!CONTROL.G.P IS TRUE (=1) IF CALLER WANTS A SPECIAL MODE FOR CONTROL G.
!   IF TRUE, WHEN CONTROL G IS TYPED A DEL (OCTAL 177) WILL BE ENTERED
!   INTO THE NEW LINE AND WILL PRINT AS AN EXCLAMATION POINT INSTEAD OF "&$".
!   DELS WILL BE ALLOWED INTO LINE IMAGES EVEN IF CONTROL.CHARS.P IS FALSE.
!
!LINE.CONTINUATION.P IS TRUE (=1) IF CALLER WANTS ^J (LINE FEED) TO PRINT
!   "&" FOLLOWED BY CARRIAGE RETURN INSTEAD OF "&J". IF TRUE, LINE FEEDS
!   WILL BE ALLOWED INTO LINE IMAGES EVEN IF CONTROL.CHARS.P IS FALSE.
!
!SEMI.EDIT.P IS TRUE (=1) IF CALLER WANTS ONLY CONTROL A AND CONTROL Q TO
!   HAVE AN EDITING FUNCTION. IF TRUE, ALL OTHER ALPHABETIC CONTROL CHARACTERS
!   ARE ENTERED INTO THE LINE IMAGE AS TEXT AS WITH CONTROL-V.
!
!KATA.KANA.P IS TRUE (=1) IF THE CALLERS COMMAND PORT IS EXTENDED ASCII (KATA KANA)
!
!  THE RETURN CODES:
!
!    ACTIVATION
!NUMBER         NAME    DESCRIPTION
!
!   1   Y      QCODE    ACT.ON.Q.P=TRUE AND ^Q WAS TYPED AT THE
!                       BEGINNING OF A LINE
!   2   N    ENDLINE    NORMAL END OF LINE (^D, ^F, ^M)
!   3   Y      DCODE    ACT.ON.D.P=TRUE AND ^D WAS TYPED AT THE
!                       BEGINNING OF A LINE
!   4   N    LNGCODE    LINE OVERFLOW. RESPONSIBLE CHARACTER IS
!                       IN ACT.CHAR.
!   5   Y    BUFCODE    BUFNUM=TRUE AND ^BX WAS TYPED. X IS IN BUFNUM.
!   6   N  SPLITLINE    ^J (LINE FEED) WAS TYPED. REQUEST FOR SPLIT LINE.
!   7   N   BADCHARS    CONTROL.CHRS.P=FALSE AND ILLEGAL CHARACTERS WERE
!                       FOUND IN THE OLD LINE.
!   8   N     BADLEN    OLD AND NEW LINE LENGTHS WERE NOT EQUAL.
!   9   N     ESCAPE    ESCAPE WAS TYPED.
!  10   Y     ACTCAR    ACTIVATION CHARACTER ENCOUNTERED.
!  11   Y    BELCODE    ACT.ON.RING.P=TRUE AND A BEL CONDITION OCCURRED.
!  12   N     BADREQ    SOME FAULT WAS FOUND IN THE TIRE REQUEST.
!
!THE CALLING PROGRAM SHOULD CHECK FOR A RETURN VALUE OTHER
!THAN THOSE LISTED, SINCE THE LIST MAY EXPAND IN THE FUTURE.
! L I N E   E D I T I N G   B E H A V I O R
!
!LINE EDITING BEHAVIOR IS BASICALLY THAT OF THE TYMSHARE EDITOR ON THE
!XDS-940. EXCEPTIONS FOLLOW.
!
!1: THE BACKSLASH CONVENTION FOR BACKWARDS DELETIONS AS EXISTS ON THE
!   PDP-10 TYMSHARE EDITOR WAS ADOPTED, RATHER THAN THE 940 BACKARROW
!   CONVENTION.
!2: IT IS NOT POSSIBLE, IN THIS VERSION, TO COPY THE END OF A LINE, AS
!   IT IS ON THE 940 AND THE 10; THERE IS NO TERMINATING CARRIAGE RETURN
!   TO COPY.
!3: LINE OVERFLOW IS HANDLED PER TYMSHARE EDITOR SPECIFICATION WITH THIS
!   EXCEPTION: IF OVERFLOW IS CAUSED BY A CONTROL CHARACTER OPERATION,
!   THE STATE VECTOR IS RESET SUCH THAT NO OPERATIONS ARE PERFORMED, EXCEPT
!   THE RINGING OF BELL.
!5: THE FOLLOWING CONTROL CHARACTERS ARE NOT IMPLIMENTED: T AND G, AND
!   ALL NON-ALPHABETIC CONTROL CHARACTERS.
!   T WAS JUDGED EQUIVALENT TO R, AND G HAD NO PREVIOUS LOGICAL FUNCTION.
!6: BELL, TEXT INSERTIONS, AND BACKWARDS DELETIONS WERE FORMALIZED, AS
!   FOLLOWS. THE DIFFERENCES RESULTING ARE RATHER WIDESPREAD. NEITHER
!   TYMSHARE EDITOR WAS EVER CONSISTENT.
!
! A: BELL.
!   1. [BELL IS RUNG] IS EQUIVALENT TO [NO ACTION IS TAKEN WITHIN INTRALINE]. THIS IS ALWAYS
!      THE CASE: IF BELL IS RUNG, THEN INSERTIONS OR DELETIONS HAVE NOT BEEN
!      COMPLETED; NOR HAVE ANY CHARACTERS BEEN ADDED TO THE NEW LINE;
!      NOR HAS OLD POINTER BEEN MOVED; NOR HAS ANY CHARACTER BEEN PRINTED.
!      IF AN OPERATION IS PERFORMED WHICH HAS NO EFFECT, BELL IS ALWAYS RUNG.
!
! B: TEXT INSERTIONS.
!   1. BACKWARDS BOUNDARIES FOR DELETIONS ARE SET AT THE BEGINNING OF THE
!      INSERTION.
!      ATTEMPTS TO BACKSPACE BEYOND THE BEGINNING OF INSERTIONS ARE NEVER
!      REALIZED.
!   2. THE PROPERTY [TEXT INSERTION IN PROGRESS] IMPLIES [OLD LINE POINTER
!      DOES NOT MOVE] IN THAT
!         A) TYPING CHARACTERS INTO THE NEW LINE DOES NOT ADVANCE THE OLD
!            POINTER.
!         B) BACKSPACING, AS WITH CONTROL-A, DOES NOT DECREMENT OLD POINTER.
!         C) ANY OPERATION WHICH FORCES THE MOVEMENT OF OLD POINTER FIRST
!            COMPLETES THE INSERTION. EXAMPLE:
!               ABC<DEF CONTROL-C      . IN THIS CASE, IF THERE IS A
!               CHARACTER TO COPY, THEN THE INSERTION IS COMPLETED WITH THE
!               OUTPUT OF '>' FOLLOWED BY THE CHARACTER COPIED.
!         D) ANY OPERATION WHICH TERMINATES A LINE COMPLETES THE INSERTION.
!            THE '>' IS ALWAYS OUTPUT, EXCEPT AFTER CARRIAGE RETURN, LINE
!            FEED, AND LINE OVERFLOW.
!
! C: BACKWARDS DELETIONS. CONTROL A, H, W, AND Q.
!   1. BACKWARDS DELETIONS ARE ALWAYS BOUND BY THE BEGINNING OF A TEXT
!      INSERTION OR THE BEGINNING OF THE NEW LINE.
!   2. OLD LINE CURSOR IS NOT MOVED DURING TEXT INSERTIONS.
!   3. DELETIONS, DELIMITED BY A PAIR OF BACKSLASHES, ARE ALWAYS COMPLETED
!      BY ANY OPERATION, EXCEPT THE OPERATION OF DELETION CHARACTERS.
!   4. THE ONE ADDITION TO 3 IS THAT A DELETION IS COMPLETED WHEN, IN THE
!      PROCESS OF DELETION, A BOUNDARY IS MET.
!
!7: CONTROL-D ONLY EXITS WITHOUT PRINTING WHEN OLD AND NEW POINTERS
!   ARE AT THE BEGINNING OF THE LINES.
!   940: EXITS WHEN NEW POINTER IS AT BEGINNING OF LINE.
!8: CONTROL-T DOES NOT COMPLETE AN INSERTION; A '<' IS OUTPUT AT THE
!   CORRECT SPOT IN THE NEW LINE TO MARK THE BEGINNING OF THE INSERTION.
!9: CONTROL-J, LINE FEED, EXITS WITH A SPECIAL CODE.
!   940: A LINE FEED COULD BE ENTERED INTO A LINE IMAGE BY TYPING IT.
!10: CONTROL-U 'COPIES' SPACES INTO THE NEW LINE IMAGE IF THERE ARE NO
!    CHARACTERS TO COPY FROM THE OLD LINE IMAGE.
!    940: CONTROL-U PAST OLD LINE END IS A NO-OP.
!11: CONTROL-T NEVER PRINTS A LINE OF ONLY BLANKS.
!12: CONTROL-Y DOES NOT COPY THE REST OF THE OLD LINE IMAGE.
!13: CONTROL-H IS NOW EQUIVALENT TO CONTROL-A. CONTROL-N GIVES THE
!    OLD CONTROL-H FUNCTION.
!THE STRUCTURE OF THIS PROGRAM:
!
!
!%INTRALINE :  CONTAINS ALL PROCEDURES.
!
!   %TIE :  RETURNS UPON LINE TERMINATION. RECOGNISES ACTIVATIONS.
!
!      %BACK.UP :  BACKS UP ONE CHARACTER, KEEPING OLD AND NEW CURSORS IN SYNCH.
!      %BACK.UP.OP :  BACKS UP THE OLD CURSOR AS MUCH AS NECESSARY.
!      %BEL.CONDITION :  CREATE A BEL CONDITION AND PRINT CONTROL-G (BEL).
!      %CASE :  HANDLES CONTROL CHARACTER OPERATIONS.
!      %CHECK.TIRE :  CHECKS TIRE AND SET SOME DEFAULT ENTRIES.
!      %COPY.P :  COPIES COUNT CHARACTERS FROM OLD LINE TO NEW.
!      %DELETE :  DELETES COUNT CHARACTERS FROM THE OLD LINE AND PRINTS '%'.
!      %FINISH :  COPIES REST OF OLD LINE AND TERMINATES THE LINE.
!      %GETCH.NO.ECHO :  GETS A CHARACTER WITH ECHOING TURNED OFF.
!      %NEWPUT :  ADDS SPECIFIED CHARACTER TO NEW LINE IMAGE AND CHECKS
!                 FOR LINE OVERFLOW.
!      %NL :  RETURNS THE CHARACTER OF THE NEW LINE IMAGE POINTED TO.
!      %NL.IN :  ENTERS A CHARACTER INTO THE NEW LINE
!      %NLPOS :  COMPUTES LENGTH OF THE NEW LINE
!      %NO.ABORT.P :  HANDLES ACTIVATIONS. RETURNS TRUE TO CONTINUE.
!      %NOT.NOOP.AND.NL.HAS.ROOM.P :  CHECKS FOR SPACE FOR N CHARS WITHOUT LINE OVERFLOW.
!      %OFF.DELETE.P :  COMPLETES A BACKWARDS DELETION IF ONE WAS IN PROGRESS.
!      %OFF.EMODE :  COMPLETES A TEXT INSERTION IF ONE WAS IN PROGRES      %OL :  RETURNS THE CHARACTER OF OLD LINE IMAGE POINTED TO.
!      %ON.DELETE :  STARTS A BACKWARDS DELETION.
!      %OTHER.CHARS :  HANDLES NON-CONTROL CHARACTER OPERATIONS.
!      %OUT :  OUTPUTS A CHARACTER.
!      %OUT.NOTRANSLATION :  OUTPUTS A CHARACTER WITHOUT TRANSLATION.
!      %OUT.TEXT :  OUTPUTS A TEXT CHARACTER IF ECHOING IS BEING DONE.
!      %PROMPT :  GETS THE PROMPT AND PRINTS IT.
!         %DO.PROMPT :  PHYSICALLY PRINTS THE PROMPT. CALLED IF FUNCTION
!                       NAME IS NON ZERO.
!      %SEARCH :  RETURNS DISPLACEMENT TO NEXT OCCURENCE OF SPECIFIED CHAR.
!      %TAB :  ENTERS SPACES INTO THE NEW LINE UNTIL A TABSTOP IS REACHED.
!      %TAB.DIST :  RETURNS DISTANCE TO NEXT TABSTOP FROM GIVEN POSITION.
!      %UP.SEARCH :  LIKE SEARCH, BUT DOESN'T LOOK AT FIRST CHARACTER.
!
!   %GETPROMPT :  RETURNS THE ADDRESS OF USER'S PROMPT BUFFER CONTROL BLOCK


FIND ".HMSG"   = %HMSG
FIND "TT.POS"  = %TTY.POS
FIND "TT.WID"  = %TTY.WIDTH
FIND "TEXT.P"  = %TEXT.P
FIND ".ACTIV"  = %ACTIV
FIND "IN%CHR"  = %INPUT.CHARACTER
FIND "VB%CH"   = %VBCH
FIND "V%CHPT"  = %VCHPT
FIND "CH%SET"  = %SETCH
FIND ".CNTRL"  = %CNTRL
FIND "NO.ECHO" = %ECHO.OFF
FIND "ON.ECHO" = %ECHO.ON
FIND ".SETUP"  = %PDP.SETUP
FIND ".R%RTN"  = %PDP.RETURN
FIND ".T%STS"  = %SET.PDP10.BREAK.SET

LOCAL %GETPROMPT



!DEFINITION STATEMENTS FOR USE THROUGHOUT THE GROUP OF PROCEDURES:

DEF LINE.LENGTH AS (256)
DEF TRUE AS 1
DEF FALSE AS 0

!DEFINE LINE IMAGE POINTERS IN TERMS OF THE BUFFER CONTROL BLOCKS:

DEF NP AS UNBCB(4)          !RUNNING CURSOR IN LINE IMAGE.
DEF OP AS UOBCB(4)

DEF MAXOP AS UOBCB(3)       !END OF LINE IMAGE POINTER.
DEF MAXNP AS UNBCB(3)

DEF NEWMAX AS UNBCB(1)      !LENGTH OF NEW LINE BUFFER.
DEF OLDMAX AS UOBCB(1)

DEF MINNP AS UNBCB(2)       !POINTER TO CHARACTER BEFORE BEGINNING OF IMAGE.
DEF MINOP AS UOBCB(2)
!DEFINE THE TIRE ENTRIES:

DEF TIRE.CNT AS         0
DEF RTN.CODE AS         1
DEF UOBCB.ADDR AS       2
DEF UNBCB.ADDR AS       3
DEF GETPRMT AS          4
DEF TABS.ADDR AS        5
DEF STALT AS            6
DEF ACTVT.ADDR AS       7
DEF AC.TXT.P AS         8
DEF ACT.CHR AS          9
DEF AC.ON.D.P AS        10
DEF AC.ON.Q.P AS        11
DEF AC.RNG.P AS         12
DEF ACT.MSK AS          13
DEF BFR.NMR AS          14
DEF OLWRK.ADDR AS       15
DEF NLWRK.ADDR AS       16
DEF GTCHR AS            17
DEF OTCHR AS            18
DEF CTL.P AS            19
DEF CTL.G.P AS          20
DEF CONTIN.P AS         21
DEF SEMI.P AS           22
DEF KATA.P AS           23

DEF MINARG AS UNBCB.ADDR
DEF MAX.TIRE.CNT AS KATA.P

DEF PUNCTUATION(MASK) AS (MASK BAND OCT 15)     !BREAK ON PUNCTUATION
DEF ALPHANUM(MASK) AS (MASK BAND OCT 2)         !BREAK ON ALPHANUMERICS AND SP

!DEFINE SOME OF THE TIRE ENTRIES:

DEF TIRE.COUNT AS               TIRE(TIRE.CNT)
DEF RETURN.CODE AS              TIRE(RTN.CODE)
DEF ACT.CHR.WAS.TXT.P AS        TIRE(AC.TXT.P)
DEF ACT.CHAR AS                 TIRE(ACT.CHR)
DEF ACTIVATE.ON.D.P AS          TIRE(AC.ON.D.P)
DEF ACTIVATE.ON.Q.P AS          TIRE(AC.ON.Q.P)
DEF ACT.ON.RING.P AS            TIRE(AC.RNG.P)
DEF ACTIVATION.MASK AS          TIRE(ACT.MSK)
DEF BUFNUM AS                   TIRE(BFR.NMR)
DEF OLWORK AS                   TIRE(OLWRK.ADDR)
DEF NLWORK AS                   TIRE(NLWRK.ADDR)
DEF CONTROL.CHRS.P AS           TIRE(CTL.P)
DEF CONTROL.G.P AS              TIRE(CTL.G.P)
DEF LINE.CONTINUATION.P AS      TIRE(CONTIN.P)
DEF SEMI.EDIT.P AS              TIRE(SEMI.P)
DEF KATA.KANA.P AS              TIRE(KATA.P)




!DEFINE THE RETURN CODES:

DEF NO.ERROR AS 0
DEF NO.RETURN AS 0
DEF QCODE AS 1
DEF ENDLINECODE AS 2
DEF DCODE AS 3
DEF LONGCODE AS 4
DEF BUFCODE AS 5
DEF SPLIT.LINE AS 6
DEF BAD.CHARS AS 7
DEF BAD.LENGTHS AS 8
DEF ESCAPE AS 9
DEF ACT.ON.CHR AS 10
DEF BELCODE AS 11
DEF BADREQ  AS 12


!DEFINE CONTROL CHARACTER VALUES:
!
DEF CONTROL.OFFSET AS (CARRET-$M)
DEF CONTROL.COM.AT AS ($@ + CONTROL.OFFSET)   !THE FIRST ASCII CONTROL CHAR.
DEF CONTROL.A AS ($A + CONTROL.OFFSET)
DEF CONTROL.B AS ($B + CONTROL.OFFSET)
DEF CONTROL.C AS ($C + CONTROL.OFFSET)
DEF CONTROL.D AS ($D + CONTROL.OFFSET)
DEF CONTROL.E AS ($E + CONTROL.OFFSET)
DEF CONTROL.F AS ($F + CONTROL.OFFSET)
DEF CONTROL.G AS ($G + CONTROL.OFFSET)
DEF CONTROL.H AS ($H + CONTROL.OFFSET)
DEF CONTROL.I AS ($I + CONTROL.OFFSET)
DEF CONTROL.J AS ($J + CONTROL.OFFSET)
DEF CONTROL.K AS ($K + CONTROL.OFFSET)
DEF CONTROL.L AS ($L + CONTROL.OFFSET)
DEF CONTROL.M AS ($M + CONTROL.OFFSET)
DEF CONTROL.N AS ($N + CONTROL.OFFSET)
DEF CONTROL.O AS ($O + CONTROL.OFFSET)
DEF CONTROL.P AS ($P + CONTROL.OFFSET)
DEF CONTROL.Q AS ($Q + CONTROL.OFFSET)
DEF CONTROL.R AS ($R + CONTROL.OFFSET)
DEF CONTROL.S AS ($S + CONTROL.OFFSET)
DEF CONTROL.T AS ($T + CONTROL.OFFSET)
DEF CONTROL.U AS ($U + CONTROL.OFFSET)
DEF CONTROL.V AS ($V + CONTROL.OFFSET)
DEF CONTROL.W AS ($W + CONTROL.OFFSET)
DEF CONTROL.X AS ($X + CONTROL.OFFSET)
DEF CONTROL.Y AS ($Y + CONTROL.OFFSET)
DEF CONTROL.Z AS ($Z + CONTROL.OFFSET)
DEF CONTROL.UNDERSCORE AS ($_ + CONTROL.OFFSET)   !THE LAST ASCII CONTROL CHAR.
DEF DEL       AS (OCT 177)


!FOLLOWING ARE DEFS AND DATA DEFINITIONS FOR PDP10.

DEF P AS ^OCT 17                      !USED AS THE STACK REGISTER

DEF PDP.SVLCH AS CHARACTERISTICS(0)   !CHARACTERISTICS IS ARRAY,
DEF PDP.NOTAB AS CHARACTERISTICS(1)   !DEFINED ELSEWHERE.
DEF PDP.SVSTS AS CHARACTERISTICS(2)   !TTY STATUS
DEF PDP.SVPRV AS CHARACTERISTICS(3)   !JBTPRV CONTAINS XEXEC/PDP BITS
DEF PDP.ACTAB AS CHARACTERISTICS(4)   !STATE OF TAB AS ACTIVATION CHAR
DEF PDP.FILL1 AS CHARACTERISTICS(5)   !FILLER CLASS 1 VALUE
DEF CHAR.WDS AS 5
DEF PDP.BIT28 AS OCT           200    !NO ECHO

DEF ECHO.WAS.OFF.P AS (PDP.SVSTS BAND PDP.BIT28)

!THE CURRENT TTY STATUS BITS:

FIND "GT.STS" = %STS.BITS

FIND %ST.OP.HK, %ST.NP.HK, %NL.HK, %OL.HK

DEF SET.NP.HOOK(VAL) AS ST.NP.HK(NP,VAL,NLWORK)
DEF SET.OP.HOOK(VAL) AS ST.OP.HK(OP,VAL,OLWORK)
DEF NL.HOOK AS (NL.HK(NP,NLWORK))
DEF OL.HOOK AS (OL.HK(OP,OLWORK))
%TIE(CALLERS.TIRE())

!THIS PROCEDURE,KNOWN EXTERNALLY, RETURNS TO THE CALLER ON AN ERROR, ON AN
!ACTIVATION, OR ON END OF LINE.

LOCAL %BACK.UP,%BACK.UP.OP,%BEL.CONDITION,%CASE,%CHECK.TIRE,%COPY.P,%DELETE,%FINISH
LOCAL %GETCH.NO.ECHO,%NEWPUT,%NL
LOCAL %NLPOS,%NO.ABORT.P
LOCAL %NOT.NOOP.AND.NL.HAS.ROOM.P
LOCAL %OFF.EMODE,%OFF.DELETE.P,%OL,%ON.DELETE,%OTHER.CHARS,%OUT,%OUT.NOTRANSLATION,%OUT.TEXT
LOCAL %PROMPT,%SEARCH,%TAB,%TAB.DIST,%UP.SEARCH

GLOBAL ".TTSTS" =  CHARACTERISTICS(0:CHAR.WDS)   !FOR SAVING MACHINE STATUS WORDS.
GLOBAL ".TIALT" = ALT:
GLOBAL ".LCALT" = ALTLOC
LOCAL P.SAVE
GLOBAL "I%CHAR" = CHAR
LOCAL TEMP
LOCAL MOVE.COUNT
GLOBAL "I%MASK" = MASK
LOCAL DELMODE, EMODE, LNP, LOP
LOCAL OLWORK.BLK(0:7), NLWORK.BLK(0:7)
GLOBAL "I%TIRE" =  TIRE(0:MAX.TIRE.CNT)
LOCAL UOBCB(), UNBCB()
LOCAL TABLE DEFAULT.TABS(11) [10,9,17,22,27,32,37,42,47,52,57]
DEF NL.IN AS SETCH(UNBCB(0),NP-1,CHAR)

DEF OUT.NOTRANS(X) AS OUT.NOTRANSLATION(X,TIRE(OTCHR))

DEF INCHAR(MASK) AS INPUT.CHARACTER(MASK,TIRE(GTCHR))

DEF RING(X) AS BEL.CONDITION(X)

DEF NOT.ABORTIVE.P(TXT.P,RTRN.CODE) AS NO.ABORT.P(TIRE(ACTVT.ADDR),TXT.P,RTRN.CODE)
DEF ABORTIVE.P(TXT.P,RTRN.CODE) AS (NOT NOT.ABORTIVE.P(TXT.P,RTRN.CODE))

DEF TAB.LENGTH AS TABS(0)
DEF NEXTAB AS TAB.DIST(TIRE(TABS.ADDR),NLPOS(PRINT.IMAGE))

DEF PRINT AS 1
DEF NOPRINT AS 0

!PRINT.IMAGE AND INTRALINE.IMAGE DESCRIBE OPTIONS OF COMPUTING THE LENGTH
!OF A LINE. PRINT.IMAGE SPECIFIES THE CARRIAGE POSITION ON A DEVICE,
!AFTER THE CHARACTERS HAVE BEEN SENT TO IT. INTRALINE.IMAGE ASSUMES
!THAT ALL CONTROL CHARACTERS AND DEL PRINT AS TWO-CHARACTER PAIRS.

DEF PRINT.IMAGE AS 0
DEF INTRALINE.IMAGE AS 1

DEF NOOP.OR.NO.ROOM(N) AS (NOT NOT.NOOP.AND.NL.HAS.ROOM.P(N))
DEF NO.ROOM.P(N) AS NOOP.OR.NO.ROOM(N)
DEF NL.HAS.ROOM.P(N) AS NOT.NOOP.AND.NL.HAS.ROOM.P(N)
   IF CALLERS.TIRE(TIRE.CNT)<MINARG THEN RETURN (CALLERS.TIRE(RTN.CODE) _ BAD.REQ)
   MOVE.COUNT _ MAX.TIRE.CNT MIN CALLERS.TIRE(TIRE.CNT)

   MOVE MAX.TIRE.CNT+1 FROM ALL 0 TO TIRE

   MOVE MOVE.COUNT FROM CALLERS.TIRE+1 TO TIRE+1
   TIRE.COUNT _ MAX.TIRE.CNT

   RETURN.CODE _ NO.RETURN

!FROM NOW ON, WE WORK MOSTLY WITHIN OUR TIRE.

!CHECK OUT THE TIRE, AND SET SOME DEFAULT ENTRIES.
!IF THE TIRE IS NO GOOD, RETURN TO CALLER.

   IF CHECK.TIRE#NO.RETURN THEN RETURN

!INITIALIZE EDITING VARIABLES:

   MASK _ ACTIVATION.MASK       !SET TO AVOID INDEXING AT EVERY REFERENCE
   DELMODE _ FALSE       !START IN NO DELETE MODE
   EMODE _ FALSE         !START IN NO INSERT MODE
   LOP _ OP _ MINOP      !OLD LINE IMAGE POINTERS POINT TO ZEROETH (NULL) CHAR
   LNP _ NP _ MINNP      !NEW LINE IMAGE POINTERS POINT TO ZEROETH (NULL) CHAR
   SET.NP.HOOK(1)        !INITIALIZE ZEROETH SYNCH MARK (FOR CONTROL Q)

   PROMPT(TIRE(GETPRMT))

!SAVE THE STACK REGISTER IN CASE WE GET AN ESCAPE AND WE NEED TO
!UNNEST THE STACK:

   P.SAVE _ P

   PDP.SETUP

!MAIN LOOP:

MAIN.LOOP: &
WHILE RETURN.CODE=NO.RETURN THEN DO

!INPUT A CHARACTER.
!IF DELETION MODE THEN WE NEED TO WAKE UP ON EVERY CHARACTER IN CASE
!IT MIGHT END THE DELETION.

   INCHAR(IF DELMODE THEN OCT 377 ELSE MASK)

!CHECK THE INPUT CHARACTER TO SEE IF IT IS AN ACTIVATION CHARACTER.
!^J AND ^M ARE NOT USUALLY ACTIVATION CHARACTERS IN THIS PROGRAM.
!IF THE CHARACTER IS AN ACTIVATION CHARACTER, SET THE APPROPRIATE ENTRIES
!IN THE TIRE AND CALL THE CALLER'S ROUTINE THROUGH NOT.ABORTIVE.P.
!NOT.ABORTIVE.P RETURNS TRUE IF CALLER DECIDES TO CONTINUE,
!IN WHICH CASE WE PROCESS THE CHARACTER IN OUR NORMAL WAY.

   IF NOT ACTIV OR NOT.ABORTIVE.P(TEXT.P,ACT.ON.CHR) THEN DO

      IF TEXT.P THEN OTHER.CHARS(CNTRL) ELSE CASE


   END

END     !OF MAIN.LOOP

RETURN.LOCATION: &
   MAXNP _ NP   !MAXNP NOT REALLY USED WITHIN TIE
   MOVE MOVE.COUNT FROM TIRE+1 TO CALLERS.TIRE+1
   PDP.RETURN
   RETURN (RETURN.CODE)


ALT:  RETURN.CODE _ ESCAPE
      P _ P.SAVE              !RESTORE STACK REGISTER TO PREVIOUS LEVEL
      GO RETURN.LOCATION



%BACK.UP

!BACKS UP ONE CHARACTER POSITION.

   BACK.UP.OP
   OUT.TEXT(NL(NP<==NP-1))
   IF LNP=NP THEN OFF.DELETE.P(PRINT)
   RETURN

END BACK.UP

%BACK.UP.OP

!BACKS UP THE OLD LINE IMAGE POINTER AS FAR AS NECESSARY, ACCORDING
!TO THE HOOKS THAT ARE SET BETWEEN THE OLD AND NEW LINES.

   IF (NL.HOOK) THEN DO
      WHILE (OP>MINOP) AND (NOT OL.HOOK) THEN DEC OP
      IF (OP>MINOP) THEN DEC OP
   END
   RETURN

END BACK.UP.OP

%BEL.CONDITION(CHARACTER)
   CHAR _ CHARACTER
   IF NOT ACT.ON.RING.P OR NOT.ABORTIVE.P(TEXT.P,BELCODE) THEN DO
   OUT.NOTRANS(CONTROL.G)
   END
   RETURN
END BEL.CONDITION


%CASE

!THIS IS THE LARGE CASE STATEMENT FOR CONTROL CHARACTERS,
!CALLED BY THIS PROGRAM'S PROCESSING LOOP.

!DESCRIPTIONS OF CONTROL CHARACTER OPERATIONS ARE WITHOUT REGARD
!TO LINE OVERFLOW.

LOCAL TEMP,TEMP1,COPY.DIST

   COPY.DIST _ MAXOP-OP    !QUITE OFTEN

   DO CHAR OF CONTROL.A:CONTROL.Z

!CONTROL-A BACKSPACES THE NEW LINE IMAGE POINTER ONE POSITION AND PRINTS
!THE DELETED CHARACTER UNLESS AN INSERTION BOUNDARY IS MET.
CONTROL.A: IF LNP=NP THEN RING(CONTROL.A) ELSE DO
              ON.DELETE
              BACK.UP
           END

!CONTROL-B IS A BUFFER CALL.
CONTROL.B: IF BUFNUM THEN DO
              GETCH.NO.ECHO
              IF ABORTIVE.P(TRUE,BUFCODE) THEN DO
                 RING(CONTROL.B)
                 RETURN.CODE _ NO.RETURN
              END
           END ELSE RING(CONTROL.B)

!CONTROL-C COPIES AND PRINTS THE NEXT OLD LINE IMAGE CHARACTER TO NEW IMAGE.
!IF NONE, RINGS.
CONTROL.C:  IF OP>=MAXOP OR NO.ROOM.P(1) THEN RING(CONTROL.C) ELSE DO
               COPY.P(PRINT,1)
            END

!CONTROL-D HAS TWO FUNCTIONS: THE FIRST IS TO COPY AND PRINT THE REST OF THE
!OLD LINE AND THEN TERMINATE THE NEW LINE. THE SECOND IS TO SIGNAL THE CALLING
!PROGRAM. THE SIGNAL IS SENT ONLY WHEN BOTH LINE POINTERS ARE AT MINIMUM,
!AND WHEN CALLER REQUESTS THE OPTION OF GETTING THIS SIGNAL.
CONTROL.D: &
            IF NOT (ACTIVATE.ON.D.P AND (NP=MINNP) AND (OP=MINOP) AND NOT EMODE) OR &
              NOT.ABORTIVE.P(FALSE,DCODE) THEN &
            FINISH(PRINT,COPY.DIST,CONTROL.D)

!CONTROL-E TOGGLES THE INSERTION MODE. IT ALWAYS COMPLETES DELETION MODE
!(DELIMITED BY BACKSLASHES). ENTERING AN INSERTION IMPLIES SETTING REAR
!BOUNDARIES ON THE ACTION OF CONTROL A,N,W, AND Q,AND FREEZING
!THE OLD LINE IMAGE POINTER, OP. IF ANY OPERATION IS PERFORMED WHICH MOVES OP,
!INSERTION MODE (EMODE) IS FIRST TERMINATED, AND THE REAR
!BOUNDARIES VANISH.
CONTROL.E:  IF NOT EMODE THEN DO
               EMODE _ TRUE
               OFF.DELETE.P(PRINT)
               OUT($<)
               LOP _ OP
               LNP _ NP
            END ELSE OFF.EMODE

!CONTROL-F TERMINATES THE LINE.
CONTROL.F:  FINISH(NOPRINT,COPY.DIST,CONTROL.F)

!IF CALLER REQUESTS, CONTROL G ENTERS A NUL INTO THE NEW LINE AND PRINTS
!A EXCLAMATION POINT. IF THIS BEHAVIOR IS NOT REQUESTED,
!CONTROL-G IS A NO-OP.
CONTROL.G: &
            IF CONTROL.G.P AND NL.HAS.ROOM.P(1) THEN DO
               CHAR _ DEL
               IF NOT ACTIV OR NOT.ABORTIVE.P(TRUE,ACT.ON.CHR) &
                  THEN OTHER.CHARS(PRINT)
            END ELSE &
            RING(CONTROL.G)

CONTROL.H:  HMSG

CONTROL.I:  TAB

!CONTROL-J PERFORMS THE LOGICAL FUNCTION OF RETURNING TO THE CALLER WITH A
!SPECIAL CODE. IT IS EXPECTED TO HAVE THE EFFECT OF TERMINATING
!THE NEW LINE, AND REPLACING THE OLD LINE IMAGE WITH THE REMAINDER OF
!THE OLD LINE.
CONTROL.J:  TEMP _ OFF.DELETE.P(PRINT)  !GET PREVIOUS STATE
            OUT.NOTRANS(CARRET)  !WE DO OUR OWN ECHOING
            IF TEMP OR ECHO.WAS.OFF.P THEN OUT.NOTRANS(LNFEED) !ECHO WAS OFF.
            RETURN.CODE _ SPLIT.LINE

CONTROL.K:  IF OP < MAXOP THEN DO
               OFF.EMODE
               OUT.TEXT(OL(INC OP)); SET.OP.HOOK(0)
             END ELSE RING(CONTROL.K)

CONTROL.L:  IF NOOP.OR.NO.ROOM(COPY.DIST) THEN RING(CONTROL.L) ELSE DO
               IF COPY.P(NOPRINT,COPY.DIST) THEN OUT($+)
            END

!IF ECHO WAS OFF WHEN THE CARRIAGE RETURN WAS TYPED (DELETION WAS IN PROGRESS)
!THEN WE MUST ECHO THE CR LF SEQUENCE OURSELVES.
CONTROL.M:  IF OFF.DELETE.P(PRINT) OR ECHO.WAS.OFF.P THEN [OUT.NOTRANS(CARRET); OUT.NOTRANS(LNFEED)]
            RETURN.CODE _ ENDLINECODE

CONTROL.N:  IF NOOP.OR.NO.ROOM(COPY.DIST) THEN RING(CONTROL.N) ELSE DO
               COPY.P(PRINT,COPY.DIST)
            END

CONTROL.O:  IF NOT.NOOP.AND.NL.HAS.ROOM.P(TEMP _ UP.SEARCH(GETCH.NO.ECHO)-1) THEN DO
               COPY.P(PRINT,TEMP)
            END ELSE RING(CONTROL.O)

CONTROL.P:  IF (TEMP _ UP.SEARCH(GETCH.NO.ECHO)-1 > 0) THEN DELETE(TEMP) ELSE RING(CONTROL.P)

!CONTROL-Q ALSO HAS TWO FUNCTIONS: THE FIRST IS TO 'RESTART' THE LINE OR THE
!INSERT; IN THIS CASE, COMPLETION OF DELETION MODE IS NOT VISIBLE.
!THE SECOND FUNCTION IS TO SIGNAL THE CALLER WITH A SPECIAL CODE, EXPECTED TO
!REQUEST LINE BACK-UP. THIS CODE IS SENT ONLY WHEN NP AND OP ARE MINIMUM,
!AND WHEN CALLER REQUESTS THIS OPTION.
CONTROL.Q:  IF (NP=LNP) AND (LOP=OP) THEN DO
               IF EMODE OR NOT ACTIVATE.ON.Q.P OR NOT.ABORTIVE.P(FALSE,QCODE) THEN RING(CONTROL.Q)
            END ELSE DO
               OUT($^)
               WHILE NP>LNP THEN [BACK.UP.OP; DEC NP]

!BACK UP OVER DELETIONS MADE AT THE BEGINNING OF THE OLD LINE BY DOING 1 EXTRA
!BACK UP OP OPERATION. THE ZEROETH SYNCH MARK WAS SET TO 1 TO MAKE THIS WORK.

               IF NOT EMODE THEN BACK.UP.OP
               OFF.DELETE.P(NOPRINT)      !CONTROL-Q PRINTS NO "\"
               IF EMODE=FALSE THEN DO
                  OUT.NOTRANS(CARRET)
                  OUT.NOTRANS(LNFEED)
                  PROMPT(TIRE(GETPRMT))
               END
            END

!CONTROL-R COMPLETES ANY DELETION, BUT NOT INSERTION. ONLY IF THERE ARE ANY
!CHARACTERS LEFT IN THE OLD LINE ARE THEY PRINTED, PRECEDED BY
!BLANKS, IF NECESSARY. THE POINT OF INSERTION IS SHOWN BY AN '<'
!IN THE NEW LINE. A FULL LINE OF BLANKS IS, HOWEVER, NEVER OUTPUT.
CONTROL.R:  OFF.DELETE.P(PRINT)

LOCAL CONT:

   DEF PROMPT.LENGTH AS &
      IF TIRE(GETPRMT)=0 THEN 0 ELSE (^((TEMP1 _ GETPROMPT(TIRE(GETPRMT)))+3)-^(TEMP1+2))

            IF OP<MAXOP THEN DO

!PROVIDE SPACE TO MATCH PROMPT.

               TEMP _ PROMPT.LENGTH

               IF EMODE THEN INC TEMP !AN EXTRA SPACE FOR '<', IF ANY.

!IF LINE.CONTINUATION.P IS TRUE, THEN CONTROL.J WILL PRINT AS & CARRET
!SO THAT THE OFFSET FOR THE NEW LINE PROMPT OR THE EMODE GLITCH NEED NOT BE INCLUDED
!IN THE OLD LINE OFFSET:

               IF LINE.CONTINUATION.P THEN DO
                  TEMP1 _ MINNP
                  WHILE INC TEMP1 <= NP THEN IF NL(TEMP1)=CONTROL.J THEN TEMP _ 0
               END

               !ADD LENGTH OF NEW IMAGE TO GET TOTAL NUMBER OF PRECEEDING
               !BLANKS:
               TEMP _ TEMP + (NLPOS(INTRALINE.IMAGE))

               TEMP1 _ TTY.WIDTH

               !MAKE SURE THAT NO MORE THAN ONE WINDOW OF BLANKS IS PRINTED:
               TEMP _ TEMP MOD TEMP1

   !TYPE OUT THE CORRECT NUMBER OF SPACES.

               TEMP1 _ TTY.POS

               IF TEMP1 <= TEMP THEN DO
                  OUT.NOTRANS(LNFEED)
                  REPEAT(TEMP-TEMP1) OUT($ )
               END ELSE DO
                  OUT.NOTRANS(CARRET)
                  OUT.NOTRANS(LNFEED)
                  REPEAT (TEMP) OUT($ )
               END

               TEMP _ OP
               WHILE TEMP<MAXOP THEN OUT.TEXT(OL(INC TEMP))

            END

            OUT.NOTRANS(CARRET)
            OUT.NOTRANS(LNFEED)
            IF PROMPT.LENGTH#0 THEN PROMPT(TIRE(GETPRMT))

            TEMP _ MINNP
            WHILE TEMP<LNP THEN OUT.TEXT(NL(INC TEMP))
            IF EMODE THEN OUT($<)
            WHILE TEMP <NP THEN OUT.TEXT(NL(INC TEMP))

CONTROL.S:  IF OP < MAXOP THEN DELETE(1) ELSE RING(CONTROL.S)

!CONTROL-T IS UNIMPLEMENTED.
CONTROL.T:  RING(CONTROL.T)

!CONTROL-U COPIES CHARACTERS FROM THE OLD LINE IMAGE OR SPACES
!TO REACH THE NEXT TABSTOP IN THE NEW LINE IMAGE. SOME COPIED
!CONTROL CHARACTERS MAY EFFECT THE PRINT POSITION OF THE NEW LINE,
!THEREBY CHANGING ON THE FLY THE "DISTANCE" TO THE NEXT TABSTOP.

LOCAL FINISHED.P, DESTINATION, RAN.OUT.OF.ROOM.P, OLD.NP, OLD.OP

CONTROL.U:  FINISHED.P _ FALSE
            RAN.OUT.OF.ROOM.P _ FALSE
            OLD.NP _ NP
            OLD.OP _ OP

            TEMP _ NLPOS(PRINT.IMAGE)
            DESTINATION _ TEMP+TAB.DIST(TIRE(TABS.ADDR),TEMP)

            WHILE NOT (FINISHED.P OR RAN.OUT.OF.ROOM.P) AND OP<MAXOP THEN DO
               CHAR _ OL(INC OP)
               IF NL.HAS.ROOM.P(1) THEN DO
                  INC NP
                  SETCH(UNBCB(0),NP-1,CHAR)
                  IF NLPOS(PRINT.IMAGE)=DESTINATION THEN FINISHED.P _ TRUE
               END ELSE RAN.OUT.OF.ROOM.P _ TRUE
            END

            COPY.DIST _ NP-OLD.NP
            TEMP _ IF FINISHED.P THEN 0 ELSE NEXTAB   !# SPACES NEEDED
            NP _ OLD.NP
            OP _ OLD.OP
            IF RAN.OUT.OF.ROOM.P OR NO.ROOM.P(COPY.DIST+TEMP) THEN RING(CONTROL.U) ELSE DO
               IF COPY.P(PRINT,COPY.DIST) AND NOT FINISHED.P THEN TAB
            END

!CONTROL-V ENTERS A CHARACTER INTO THE NEW LINE IF CALLER ALLOWS NON-PRINTING CHARACTERS.
CONTROL.V:  IF NOT CONTROL.CHRS.P OR NO.ROOM.P(1) THEN RING(CONTROL.V) ELSE DO
               CHAR _ GETCH.NO.ECHO
               TEMP _ $a - $A
               EIF $a <= CHAR <= $z THEN CHAR _ CHAR-TEMP
               ELSE IF $A <= CHAR <= $Z THEN CHAR _ CHAR+TEMP
               IF NOT ACTIV OR NOT.ABORTIVE.P(TRUE,ACT.ON.CHR) THEN OTHER.CHARS(PRINT) ELSE OUT.TEXT(CHAR)
            END

CONTROL.W:  IF NP=LNP THEN RING(CONTROL.W) ELSE DO
               ON.DELETE
               WHILE (NP>LNP) AND ((NL(NP)=$ ) OR (NL(NP)=CONTROL.I) OR (NL(NP)=OCT 240)) THEN BACK.UP
               WHILE (NP>LNP) AND (NL(NP)#$ ) AND (NL(NP)#CONTROL.I) AND (NL(NP)#OCT 240) THEN BACK.UP
            END

CONTROL.X:  IF TEMP _ SEARCH(GETCH.NO.ECHO)>0 THEN DELETE(TEMP) ELSE RING(CONTROL.X)

!CONTROL-Y  MOVES THE ENTIRE
!NEW LINE TO THE OLD BUFFER AND RESETS POINTERS. THIS OPERATION IS THE
!JUSTIFICATION FOR THE REQUIREMENT THAT THE OLD LINE BUFFER BE AS LARGE
!AS THE NEW.
CONTROL.Y:  OFF.EMODE
            MAXOP _ NP-MINNP
            TEMP _ VCHPT(UOBCB(0),-1)!POINT TO BEFORE 1ST CHAR IN OLD BUFF.
            TEMP1 _ VCHPT(UNBCB(0),MINNP-1)
            REPEAT (MAXOP) NCHV(TEMP) _ NCHV(TEMP1)
            MINOP _ OP _ 0
            LNP _ NP _ MINNP
            SET.NP.HOOK(1)
            LOP _ 0

            OUT.NOTRANS(CARRET)
            OUT.NOTRANS(LNFEED)
            PROMPT(TIRE(GETPRMT))

CONTROL.Z:  IF NOT.NOOP.AND.NL.HAS.ROOM.P(TEMP _ SEARCH(GETCH.NO.ECHO)) THEN DO
               COPY.P(PRINT,TEMP)
            END ELSE RING(CONTROL.Z)

        END
   RETURN
END CASE

%CHECK.TIRE

!THIS PROCEDURE MAKES CHECKS ON THE INTEGRITY OF THE TIRE AND
!ALSO FILLS IN SOME OF THE ENTRIES.

   LOCAL CHTEMP

   UOBCB _ TIRE(UOBCB.ADDR)
   UNBCB _ TIRE(UNBCB.ADDR)

!CHECK BUFFER LENGTHS: LENGTH OF OLD MUST EQUAL LENGTH OF NEW.

   IF OLDMAX # NEWMAX THEN RETURN (RETURN.CODE _ BAD.LENGTHS)

!CHECK TO SEE THAT IF A LINE LENGTH GREATER THAN LINE.LENGTH IS REQUESTED, BOTH
!OLWORK AND NLWORK WORK AREAS ARE PROVIDED.

   IF OLDMAX >LINE.LENGTH AND (OLWORK=0 OR NLWORK=0) &
      THEN RETURN (RETURN.CODE _ BAD.LENGTHS)

!IF NLWORK OR OLWORK ARE NOT PROVIDED, USE OUR OWN.

   IF OLWORK=0 THEN OLWORK _ OLWORK.BLK
   IF NLWORK=0 THEN NLWORK _ NLWORK.BLK

!CHECK OLD IMAGE CHARACTERS:

   IF CONTROL.CHRS.P=FALSE THEN DO
      CHTEMP _ CHAR
      TEMP _ MINOP
      WHILE INC TEMP<=MAXOP THEN IF CNTRL(CHAR _ VBCH(UOBCB(0),TEMP-1)) AND &
         (NOT LINE.CONTINUATION.P OR CHAR#CONTROL.J) AND &
         (NOT CONTROL.G.P OR CHAR#DEL) THEN &
         [CHAR _ CHTEMP; RETURN (RETURN.CODE _ BAD.CHARS)]
      CHAR _ CHTEMP
   END

!IF THE ARRAY TABS IS NOT PROVIDED, USE OUR OWN DEFAULT VERSION.

   IF TIRE(TABS.ADDR)=0 THEN TIRE(TABS.ADDR) _ DEFAULT.TABS

!IF %ACTIVATE IS NOT PROVIDED, ZERO OUT THE ACTIVATION REQUESTS.

   IF TIRE(ACTVT.ADDR)=0 THEN DO
      TIRE(AC.ON.Q.P) _ 0
      TIRE(AC.ON.D.P) _ 0
      TIRE(AC.RNG.P) _ 0
      TIRE(BFR.NMR) _ 0
   END

   RETURN (RETURN.CODE)

END CHECK.TIRE


%COPY.P(PRINT.OPTION.P,COUNT)

!COPIES CHARACTERS FROM THE OLD LINE TO THE NEW LINE AND PRINTS THEM IF
!REQUESTED. THERE MUST BE ROOM IN THE NEW LINE FOR COUNT CHARACTERS.

LOCAL TEMP, TEMP1

   OFF.EMODE

   TEMP _ CHAR
   TEMP1 _ VCHPT(UOBCB(0),OP-1)
   REPEAT COUNT DO

      CHAR _ NCHV(TEMP1)
      IF PRINT.OPTION.P THEN OUT.TEXT(CHAR)

      IF NOT ACTIV OR NOT.ABORTIVE.P(TRUE,ACT.ON.CHR) THEN DO

      NEWPUT

      END ELSE [CHAR _ TEMP; RETURN(FALSE)]

   END

   CHAR _ TEMP
   RETURN (TRUE)

END COPY.P

%DELETE(COUNT)

!DELETES COUNT CHARACTERS IN THE OLD LINE , PRINTING '%'

   OFF.EMODE
   REPEAT COUNT DO
      INC OP; SET.OP.HOOK(0)
      OUT($%)
   END
   RETURN

END DELETE

%FINISH(PRINT.OPTION.P,COPY.DIST,RESPONSIBLE.CHARACTER)
!COPIES THE REST OF THE OLD LINE IF THERE IS ENOUGH ROOM AND
!TERMINATES THE LINE.

   EIF COPY.DIST<=0 THEN DO
      OFF.EMODE
      OUT.NOTRANS(CARRET)
      OUT.NOTRANS(LNFEED)
      RETURN.CODE _ ENDLINECODE
   END
   ELSE DO
      IF NL.HAS.ROOM.P(COPY.DIST) THEN DO
         IF COPY.P(PRINT.OPTION.P,COPY.DIST) THEN DO
            OUT.NOTRANS(CARRET)
            OUT.NOTRANS(LNFEED)
            RETURN.CODE _ ENDLINECODE
         END
      END ELSE RING(RESPONSIBLE.CHARACTER)
   END

   RETURN
END FINISH


%GETCH.NO.ECHO

!TURNS ECHO OFF, GETS A CHARACTER AND THEN IF APPROPRIATE TURNS ECHO BACK ON.

   ECHO.OFF
   INCHAR(OCT 377)     !MAKE SURE TO ACTIVATE ON ALL CHARACTERS
   IF NOT ECHO.WAS.OFF.P THEN ECHO.ON
   RETURN(CHAR)

END GETCH.NO.ECHO


%NEWPUT
!NEWPUT PLACES THE CHARACTER CHAR INTO THE NEW LINE IMAGE.
!TAKES CARE OF INCREMENTING OP IF APPROPRIATE.

   INC NP
   IF (NOT EMODE) AND OP<MAXOP THEN DO
      INC OP
      SET.OP.HOOK(1); SET.NP.HOOK(1)
   END ELSE SET.NP.HOOK(0)
   RETURN (NL.IN)

END NEWPUT


%NL(INDEX)   !RETURNS THE CHARACTER OF THE NEW LINE IMAGE POINTED TO BY INDEX
   RETURN (VBCH(UNBCB(0),INDEX-1))
END NL



%NLPOS(IMAGE.TYPE)

!COMPUTES THE LENGTH OF THE NEW LINE ACCORDING TO WHETHER IT IS PRINTED ON A
!HYPOTHETICAL PRINTER (IMAGE.TYPE=PRINT.IMAGE) OR DISPLAYED WITH ALL
!CONTROL CHARACTERS PRINTED AS TWO CHARACTER PAIRS (IMAGE.TYPE=INTRALINE.IMAGE).

LOCAL POSITION, CURSOR, CHAR.TEMP

   CHAR.TEMP _ CHAR
   POSITION _ 0
   CURSOR _ MINNP

   WHILE INC CURSOR <= NP THEN DO

      CHAR _ NL(CURSOR)
      EIF CNTRL THEN DO
         IF IMAGE.TYPE=PRINT.IMAGE THEN DO
            EIF CHAR=CARRET THEN POSITION _ 0
            ORIF CHAR=CONTROL.H THEN IF DEC POSITION < 0 THEN POSITION _ 0
            FIF CHAR=CONTROL.I THEN POSITION _ POSITION+TAB.DIST(TIRE(TABS.ADDR),POSITION)
         END ELSE DO
            EIF CONTROL.G.P AND CHAR=DEL THEN INC POSITION
            ORIF LINE.CONTINUATION.P AND CHAR=CONTROL.J THEN POSITION _ 0
            ELSE POSITION _ POSITION + 2
         END
      END
      ELSE INC POSITION

   END
   CHAR _ CHAR.TEMP
   RETURN (POSITION)

END NLPOS


%NO.ABORT.P(%USER.ROUTINE,TXT.P,CODE)

!CALLS USER.ROUTINE TO DECIDE WHETHER THIS ACTIVATION CONDITION
!IS TO BE HANDLED BY CALLER OR US.
!PUTS THE ACTIVATION CHARACTER AT THE END OF THE NEW LINE WITHOUT
!MODIFYING POINTERS OR OTHER VARIABLES.
!IF WE ARE TO HANDLE IT, WE RESET RETURN.CODE AS IF NOTHING HAD
!HAPPENED. OTHERWISE, IF IT WAS A CHARACTER ACTIVATION WE DO A LITTLE
!CLEAN-UP IN THE FORM OF CLOSING DELETION MODE, AND PRINTING
!THE CHARACTER IF DELETION MODE HAD BEEN ON (AND ECHOING WAS THEREFORE OFF).

   ACT.CHAR _ CHAR
   ACT.CHR.WAS.TXT.P _ TXT.P
   IF (RETURN.CODE _ CODE) = ACT.ON.CHR THEN SETCH(UNBCB(0),NP,CHAR)
   IF CODE _ USER.ROUTINE(TIRE)>0 THEN DO    !HE IS NOT ACTIVATING
      RETURN.CODE _ NO.RETURN

!CALLER WANTS TO CONTINUE PROCESSING. IF HE HAS CHANGED THE TIRE,
!WE MUST CHECK IT OUT AND SET SOME DEFAULT ENTRIES.

      IF CODE=2 THEN DO
         IF CHECK.TIRE#0 THEN RETURN(FALSE)
         MASK _ ACTIVATION.MASK
         SET.PDP10.BREAK.SET
      END
      RETURN (TRUE)
   END ELSE DO
      IF OFF.DELETE.P(PRINT) AND RETURN.CODE=ACT.ON.CHR AND TEXT.P THEN OUT.TEXT(CHAR)
      RETURN (FALSE)
   END

END NO.ABORT.P


%NOT.NOOP.AND.NL.HAS.ROOM.P(CHAR.CNT)

!RETURNS TRUE IF THERE IS ENOUGH ROOM IN THE NEW LINE IMAGE BUFFER FOR
!CHAR.CNT CHARACTERS.
!RETURNS FALSE ALSO IF THE CHAR.CNT IS ZERO OR NEGATIVE, INDICATING A NO-OP.

   IF CHAR.CNT<=0 THEN RETURN(FALSE)
   IF (NP+CHAR.CNT) > NEWMAX THEN RETURN (FALSE) ELSE RETURN (TRUE)

END NOT.NOOP.AND.NL.HAS.ROOM.P

%OFF.DELETE.P(PRINT.OPTION.P)
   IF DELMODE THEN DO
      IF PRINT.OPTION.P THEN OUT($\)
      DELMODE _ FALSE
      IF NOT ECHO.WAS.OFF.P THEN ECHO.ON
      RETURN (TRUE)  !DELMODE WAS ON
   END
   RETURN (FALSE)
END OFF.DELETE.P

%OFF.EMODE
   OFF.DELETE.P(PRINT)
   IF EMODE THEN DO
      EMODE _ FALSE
      LNP _ MINNP
      LOP _ MINOP
      OUT($>)
   END
   RETURN
END OFF.EMODE

%OL(INDEX)

 RETURN (VBCH(UOBCB(0),INDEX-1))

END OL


%ON.DELETE

!ECHOING IS OFF DURING DELETION SO THAT THE DELETION MAY BE COMPLETED
!AND A BACKSLASH OUTPUT BEFORE THE CHARACTER PRINTS.

   IF DELMODE=FALSE THEN DO
      ECHO.OFF(CHARACTERISTICS)
      OUT($\)
      DELMODE _ TRUE
   END
   RETURN

END ON.DELETE

%OTHER.CHARS(PRINT.OPTION.P)
!ENTERS A CHARACTER INTO THE NEW LINE IMAGE, AFTER
!VALIDATING THE CHARACTER AS LEGAL, AND MAKING SURE
!THE CHARACTER IS ECHOED. IF PRINT.OPTION.P IS TRUE THEN THE CHARACTER HAS NOT
!YET BEEN ECHOED OR PRINTED AND NEEDS TO BE.

LOCAL TEMP
   IF (NOT CONTROL.CHRS.P) AND CNTRL THEN [RING(CHAR); RETURN]
   IF NO.ROOM.P(1) THEN DO
      RETURN.CODE _ LONG.CODE
      RETURN (ACT.CHAR _ CHAR)
   END
   IF OFF.DELETE.P(PRINT) OR PRINT.OPTION.P THEN OUT.TEXT(CHAR)
   NEWPUT
   RETURN

END OTHER.CHARS


%OUT(CHAR)

!TYPES CHAR.
!CONTROL CHARACTERS ARE TRANSLATED UPON INPUT TO THIS ROUTINE TO TWO
!CHARACTERS: '&' FOLLOWED BY THE ALPHABETIC INTERPRETATION OF THE
!CHARACTER. ALSO, DEL IS TRANSLATED TO '&$'.

   EIF CONTROL.COM.AT <= CHAR <=CONTROL.UNDERSCORE THEN DO
      EIF LINE.CONTINUATION.P AND CHAR=CONTROL.J THEN DO
         OUT.NOTRANS($&)
         OUT.NOTRANS(CARRET)
         OUT.NOTRANS(LNFEED)
      END
      ELSE DO
         OUT.NOTRANS($&)
         OUT.NOTRANS(CHAR-CONTROL.OFFSET)
      END
   END

   ORIF CHAR=DEL THEN DO
      EIF CONTROL.G.P THEN OUT.NOTRANS($!)
      ELSE [OUT.NOTRANS($&); OUT.NOTRANS($$)]
   END

   ORIF KATA.KANA.P < 0 THEN DO
      IF CHAR>128 THEN OUT.NOTRANS($!) ELSE OUT.NOTRANS(CHAR)
   END

   ELSE OUT.NOTRANS(CHAR)

   RETURN (CHAR)

END OUT


%OUT.NOTRANSLATION(CHAR,%USER.OUTCHAR)

!THIS ENTRY POINT ENTAILS NO TRANSLATION OF CONTROL LETTERS OR CARRIAGE
!CONTROL

   IF %USER.OUTCHAR#0 THEN [USER.OUTCHAR(CHAR); RETURN (CHAR)]

   TTY _ (CHAR)
   RETURN (CHAR)

END OUT.NOTRANSLATION


%OUT.TEXT(CHAR)

!PRINTS CHAR, ONLY IF ECHO WAS ON AT PROGRAM ENTRY.

   IF ECHO.WAS.OFF.P THEN RETURN(CHAR)
   RETURN (OUT(CHAR))

END OUT.TEXT


%PROMPT(GETPROMPT.ADDR)

!TYPES THE PROMPT GIVEN BY %GETPROMPT

   LOCAL %DO.PROMPT

   IF GETPROMPT.ADDR=0 THEN RETURN
   DO.PROMPT(GETPROMPT(GETPROMPT.ADDR))
   RETURN

%DO.PROMPT(UPBCB())

   LOCAL POINT,COUNT,START
   POINT _ 0
   COUNT _ UPBCB(3) - (START _ UPBCB(2))
   WHILE POINT+1 <= COUNT THEN [OUT(VBCH(UPBCB(0), POINT + START)); INC POINT]
   RETURN
END DO.PROMPT
END PROMPT


%SEARCH(CHAR)

!RETURNS DISPLACEMENT TO CHAR OR ZERO IF NOT FOUND.

LOCAL TEMP

   TEMP _ 0
   GO SRCH

%%UP.SEARCH(CHAR)

!LIKE SEARCH, RETURNS THE DISPLACEMENT TO THE NEXT
!OCCURENCE OF CHAR (0 IS RETURNED IF CHAR IS NOT FOUND)
!BUT UNLIKE SEARCH,UP.SEARCH STARTS SEARCHING STARTING
!AT OP + 2. USED FOR CONTROL-O,CONTROL-P.

   TEMP _ 1
SRCH: WHILE (OP+TEMP)<MAXOP THEN IF (CHAR=OL(OP+INC TEMP)) THEN RETURN (TEMP)
   RETURN (0)

END SEARCH

%TAB

!ADDS SPACES TO THE NEW LINE TO REACH THE NEXT TABSTOP.

LOCAL TEMP

   IF NL.HAS.ROOM.P(TEMP _ NEXTAB) THEN DO
      OFF.DELETE.P(PRINT)
      CHAR _ $ 
      REPEAT TEMP DO

         OUT.TEXT($ )
         IF NOT ACTIV OR NOT.ABORTIVE.P(TRUE,ACT.ON.CHR) THEN &
         NEWPUT
      END
   END ELSE RING(CONTROL.I)

END TAB

%TAB.DIST(TABS(),COLUMN.POSITION)

! GIVEN A COLUMN POSITION, RETURNS DISTANCE TO NEXT TABSTOP.

   LOCAL TEMP,DIST

   TEMP _ 0
   WHILE TEMP<TAB.LENGTH THEN &
      IF (DIST _ TABS(INC TEMP)-COLUMN.POSITION-1) > 0 THEN RETURN (DIST)
   RETURN (1)

END TAB.DIST

END TIE
%GETPROMPT(%PROMPT.ROUTINE)

!CALLS PROMPR.ROUTINE

   RETURN (PROMPT.ROUTINE)

END GETPROMPT

I"6Ü