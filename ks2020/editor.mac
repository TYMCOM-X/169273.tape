;DEFINE VERSION NUMBER

        TYMSPC==35              ;TYMSHARE SPECIFICATION
        TYMREL==5               ;TYMSHARE RELEASE

DEFINE TTL(TS,TR)<
TITLE   EDITOR - VERSION TS'.'TR
SUBTTL  HAVE I GOT AN EDITOR FOR YOU......
VEDI==BYTE(18)TS,TR
IF1,<PRINTX VERSION 'TS'.'TR>
>

        TTL(\TYMSPC,\TYMREL)

        LOC     <JOBVER==137>
        VEDI

        LOC     <JOB41==41>
        JSR     UUOH                    ;THE UUO HANDLER

        LOC     <JOBREN==124>
        JRST    GETCOM                  ;RE-ENTER ADDRESS

        RELOC
        MLON

        JOBUUO== 40

OPDEF DEC[1B8]
OPDEF PRMSG [2B8]       ;PRINT MESSAGE
OPDEF PRICHR [4B8]      ;PRINT VALUE BUFFERED

;AC DEFINITIONS
P=17
F=16
NEW=15  ;USUALLY CONTAINS POINTER TO 'NEW'[CURRENT] LINE
OLD=14  ;USUALLY CONTAINS POINTER TO 'OLD'[IMAGE] LINE
CH=13
NUM=12
DIC=11  ;HOLDS DICTIONARY POINTER
LINE=10 ;USED AS COUNTER TO BE SAVED(USUALLY LINE NO)
SERCH==7 ;USED IN ADRCAL
SPT==SERCH       ;USED AS SEARCH POINTER IN FNDTXT
SCH==6 ;SEARCH CHAR
TXP==5 ;TEXT POINTER
X4=4
X3=3
X2=2
R0=0
X1=1

; PROGRAM OPTIONS
   LINLEN==^D256
   NOUPBK==1            ;NUMBER OF BLOCKS IN UPDATE AREA
   NOBLKS==1            ;NUMBER OF BLOCKS PER WINDOW
   NOWNDS==2            ;NUMBER OF WINDOWS
   BLKSIZ=200           ;SIZE OF A BLOCK
   TABLEN==12           ;LENGTH OF DEFAULT TAB TABLE
   TBSLEN==60           ;LENGTH OF USER TAB TABLE
   NOBUFS==^D9          ;NUMBER OF COMMAND BUFFERS NOT COUNTING 0
   BUFLNS==^D8          ;NUMBER OF SYMBOLIC LINES ALLOWED PER BUFFER
IFNDEF PDLSIZ,<PDLSIZ==200>
IFNDEF %CIPFLG,<%CIPFLG==0>     ;TURN THIS ON FOR CIPHERING
IFNDEF COMPRESS,<COMPRESS==0>    ;TURN THIS ON FOR BLANK COMPRESSION
IFNDEF PURE,<PURE==1>
IFNDEF FTRTYCHG,<FTRTYCHG==1>           ;1 IF RTYCHG ELSE 0

	KATAFG==1		; 1=> we are prepared to handle extended ascii(kata kana)
        KK.OFF==^O200           ;Offset from ascii to Kata Kana

IFN PURE,<
        TWOSEG                  ;TWO SEGMENTS
        RELOC   400000          ;GO TO HI-SEG
>

        EXTERN  JOBFF, JOBREL, JOBAPR, JOBTPC
;DEFS GENERAL

   IFE  KATAFG,< BUFLEN==LINLEN/5+1 >
   IFN  KATAFG,< BUFLEN==LINLEN/4+1 >
   BUFFRD==0    ;A REQUEST FOR BUFFERED OUTPUT
   DIROUT==-1   ;A REQUEST FOR DIRECT OUTPUT

        MAGNUM==4               ;PROCESSOR NUMBER FOR MAGNUM
        MAGCOD==^D10024         ;RTYCHG CODE NO FOR MAGNUM EDITOR
        PCODE1==^D10018         ;RTYCHG CODE NO FOR SYSTEM EDITOR

        SEXTERN RTYRTN
        SEXTERN RTYBUF
        DEFINE RTYCHG(TYPE<1>,%XLAB)<
         IFN FTRTYCHG,<
           SKIPE [RTYRTN]       ;;RTYRTN LOADED?
           SKIPN [RTYBUF]       ;;RTYBUF TOO?
           JRST %XLAB           ;;NO
           MOVEM 0,SAVAC        ;;SAVE ACCUMULATORS
           MOVE 0,[1,,SAVAC+1]
           BLT 0,SAVAC+17       ;;INTO SAVAC ARRAY
           MOVEI X1,TYPE        ;;ARGUMENT TO RTYRTN
           MOVE X2,PCODNO       ;;2ND ARGUMENT TO RTYRTN: PROGRAM NUMBER
           MOVNI X3,1           ;;3RD ARGUMENT TO RTYRTN: CHANNEL TO USE
           MOVEI 17,RTYBUF      ;;CALL STACK
           PUSHJ 17,RTYRTN      ;;CALL RTYCHG
           MOVE 0,[SAVAC+1,,1]
           BLT 0,17             ;;RESTORE REGISTERS
           MOVE 0,SAVAC
%XLAB:!>>


        DEFINE IFNBFR(X,%A)<
           SKIPN BUFFR          ;;IN A BUFFER?
           SKIPE COMBFR         ;;OR IN A COMMAND FILE?
           JRST %A              ;;YES-DO NOT EXECUTE STUFF
           X
%A:!>


        DEFINE ENDBUF<
           TRZ F,COMF.F!BUF.F   ;;TURN OFF BUFFER AND COMMAND FILE
           SETZM COMBFR         ;;TURN OFF COM FILE LOOK AHEAD
           SETZM CMWBFR         ;;RESET COMMAND WAIT BUFFER WAS ON FLAG
           SETZM BUFFR          ;;TURN OFF BUFFER LOOK AHEAD
           SETZM TIRE+ACRING
           SETZM TIRE+%GTCHR
           SETZM TIRE+%OTCHR>
;I/O CHANNEL DEFINITIONS
TTY==0   ;TTY I/O CHANNEL
TMP==1   ;DSK .TMP FILE FOR EDITING
INF==2   ;"READ" I/O CHANNEL
OUTF==3  ;"WRITE" I/O CHANNEL
COMF==4  ;COMMAND FILE I/O CHANNEL
SYS==5   ;DSK .TMP FILE FROM RPG
REPF==7  ;REPLACE FILE CHANNEL

;TTY STATUS BITS
;THE PROGRAM HAS THE CHOICE OF BEING ACTIVATED BY THE MONITOR AS FOLLOWS:
;   1. ON EVERY CHARACTER       MUST USE INCHRW MONITOR CALL
;   2. ON END OF LINE           ASCII LINE MODE
;   3. ON PUNCTUATION           ASCII LINE MODE, PUNC BREAK SET
;
;FOR MOST EDITOR PROCESSING OF TTY INPUT, THE THIRD OPTION IS USED.
;THIS ALLOWS ACTIVATION ON THE / ^ AND LF IN COMMAND MODE. DURING
;AN INSERT OR APPEND, THE SECOND OPTION IS USED. FINALLY, THE FIRST OPTION
;MUST BE USED WHEN AN OPERATION IMMEDIATELY REQUIRES A CHARACTER. THESE
;INCLUDE ^O ^P ^X ^Z ^B ^V, THE YORN ROUTINE, THE FILE CONFIRMATION ROUTINE,
;AND WHEN A INTRALINE DELETION IS IN PROGRESS (ECHO IS OFF AND WE ARE
;WAITING FOR A CHARACTER TO END THE DELETION AND PRINT A /).

ST.ASC==0
ST.LIN==1
ST.ALL==100     ;LET US HANDLE ^A AND ^Q
ST.NEC==200     ;NO ECHO
ST.PUN==1000    ;ACTIVATE ON PUNCTUATION


;FLAG DEFINITIONS

;CHARACTER FLAGS

        EXTERN  .CTTAB, UPFLG, CRFLG, EQFLG

        PUNC.F==      1 ;Punctuation other than below
        ALPHA==       2 ;Lower and Upper case alpha, numerics and space
        DDT.F==       4 ;% ; ! (DDT activation characters)
        ACEDIT==     10 ;/ = _ ^ (EDITOR activation characters)
        CNTRL==      60 ;Control characters and DEL
        CTL.I==     100 ;Control I (TAB)
        ACMCJC==    200 ;Control M (Carriage Return) and Control J (Line Feed)
        B.LOAD==    400 ;Control chars that have a function while loading a buffer
        DEL.F==    1000 ;Character is a text delimeter
        ADD2.F==   2000 ;Delimeter character whose match is char+2
        TEX.F==    4000 ;Text delimeter: ' " [ ]
        LET.F==   10000 ;Lower and upper case alpha but not space
        NUM.F==   20000 ;Numeral

        ACT.F==CNTRL!ACMCJC!ACEDIT
        TERM.F==ACMCJC



        SEXTERN PRFINI,PRFWRT
;FLAGS (LEFT HALF)

                ;LEVEL CODE, NOT INTRA-LINE EDITING.
DELIM.F==200000 ;Used when passing through quoted strings
COMBLK== 100000 ;Compress blanks in WRITE command (not used)
FIRST==   40000 ;FIRST ATOM CALCULATED
IGNOR==   20000 ;FLAG TO IGNOR BLANKS
TAG.F==   10000 ;Used in ADRCAL to indicate TAG search
MOVE.F==   4000 ;MOVE command as opposed to COPY
TELLNO==   2000 ;ALL PURPOSE SHORT FLAG
EDI.F==    1000 ;EDIT MODE FLAG
CRORBL==    200 ;CR OR BLANK USED IN :ADRCAL:
LOAD.F==    100 ;USED TO INDICATE LOAD COMMAND
APPEN.F==    20 ;APPEND COMMAND
SUBMAD==      4 ;USED FOR SUBST MADE IN FNDTXT AND MAKSUB
PAG.F==       2


;FLAGS (RIGHT HALF)
;THESE FLAGS REMAIN CONSTANT FROM COMMAND TO COMMAND

COMF.F==400000  ;TAKING COMMANDS FORM A COMMAND FILE
BUF.F==200000   ;TAKING COMMANDS FROM A BUFFER
ONR.F==40000    ;:RINBUF: HAS BUFFER POINTER - 'ONRING' SET
FND.F==20000    ;FIND COMMAND
MARK.F==10000   ;ONTROLS PRINTING OF 'TOTAL'
KEEPV==4000     ;EDIT MODE TO KEEP ^V FLAG SET
WAIT.F==400     ;WAIT FOR OK FROM USER TO SUBSTITUTE
COMMA==200      ;COMMA SEEN
INS.F==40       ;INSERT,APPEND,CHANGE MODE
RPG.F==20       ;ENTERED FROM RPG
FIL.EQ==10      ;ASK FOR FILE NAME ON EXIT,GO
;UUO HANDLER
UUOHAN: PUSH P,UUOH     ;RETURN ADDRESS ON PDL
        LDB X1,[POINT 9,40,8]   ;GET THE NUMBER OR UUO

        JRST @.(X1)
        EXP DEC
        EXP PRTMES
        EXP PRTVAL
        EXP PRIADR

;TIE definitions.

        extern  i%tie

;TIRE entries:

TIRCNT==0
RTNCOD==1
OB.ADR==2
NB.ADR==3
PROMPT==4
TABADR==5
%STALT==6
%ACTVT==7
TEXT.P==8
ACTCHR==^D9
ACONDP==^D10
ACONQP==^D11
ACRING==^D12
ACTMSK==^D13
BUFNUM==^D14

%GTCHR==^D17
%OTCHR==^D18
CTL.P==^D19
CTLG.P==^D20
CONTNP==^D21
SEMI.P==^D22
KATA.P==^D23

;Activation masks:

ACEDIT==^O10            ; mask for command input: ^ / _ =
ACNTRL==^O60            ; mask for all control characters to catch ^D
ACMCJC==^O200           ; mask to catch ^V^M

;return codes:

QCODE==1
NORMAL==2
DCODE==3
LONGCD==4
BUFCOD==5
SPLITL==6
ESCAPE==^D9
CHRACT==^D10
BELCOD==^D11

;Buffer control block entries:

BCBADR==0
BCBLEN==1
BCBMIN==2
BCBMAX==3
BCBPNT==4
;COMMAND LIST- 1ST LIST IS THE NUMBER OF CHARACTERS REQUIRED
;SECOND LIST RT HALF IS ADRES WHERE TO GET FULL COMAND
; LFT HALF IS INCREMENT TO ADD TO RT HALF AS THE DISPATCH ADR
;  (BECAUSE CMD DISPATCHER IS TOO STUPID TO GO  OVER THE
;   ASCIZ STMT AT THE DISPATCH ADDRESS, SO THIS IS THE NUMBER
;   OF WORDS THE ASCIZ STMT AT DISPADR TAKES! HOW DUMB)

; BITS FOR LH OF SECOND TABLE
        NAB==400000      ;NOTHING ALLOWED BEFORE COMAND
        ONE==200000      ;MUST HAVE ONLY 1 THING BEFORE
        MHSB==100000     ;MUST HAVE SOMETHIG BEFORE
        AFTER==40000     ;MUST HAVE INFO AFTER
        NOAFT==20000     ;NO INFO ALOW AFTER
        ONORN==10000     ;ONE ONLY OR NOTHING ALLOWED BEFORE
        FND==4000        ;MAY BE USED WITH FIND
        MRK==2000        ;MAY BE USED WITH MARK


; COMMAND DISPATCH TABLE
; FORMAT IS:
; U <#1>, <#2>
; (OR, OPTIONALLY, U1 <#3>,<#2>)
; WHERE: <#1> = FIRST ABBREVIATABLE CHARS FOR CMD
;        <#2> = N1,N2
;               N1 = BITS (AS DESCRIBED ABOVE)
;               N2 = ADDRESS TO GO FOR COMMAND
;       <#3> = DIRECTIVE TO GENERATE CMD CHARS (IE, BYTE)
DEFINE %CMACRO<
        U <A>,<MRK!FND!2,APPEND>
        U <B>,<ONE!NOAFT!2,BUFFER>
        U <C>,<MHSB!NOAFT!2,CHANGE>
        U <CHE>,<NAB!NOAFT!2,CHECKPOINT>
IFN %CIPFLG,<U <CI>,<NAB!NOAFT!1,CIPHER>>
        U <CL>,<MRK!NOAFT!1,CLEAR>
        U <COM>,<NAB!2,COMMND>
        U <COP>,<ONE!AFTER!1,COPY>
       U <D>,<MRK!FND!NOAFT!2,DELETE>
        U <DO>,<NAB!0,DOCMD>
        U <E>,<MRK!FND!NOAFT!1,EDIT>
        U <EX>,<NAB!1,EXITCM>
        U <F>,<MRK!AFTER!1,FIND>
        U <G>,<MRK!FND!MHSB!NOAFT!1,GET>
        U <GO>,<0,GO>
        U <I>,<MRK!FND!NOAFT!2,INSERT>
        U <J>,<ONE!NOAFT!1,JOIN>
        U <K>,<ONE!NOAFT!1,KILL>
        U <LIN>,<NAB!1,LINES>
        U <LIS>,<MRK!FND!1,LIST>
        U <L>,<MRK!FND!1,LOAD>
        U <MA>,<MRK!FND!MHSB!AFTER!1,MARK>
        U <M>,<MRK!FND,M>
        U <M>,<MRK!FND!2,MODIFY>
        U <MOV>,<ONE!AFTER!1,MOVE>
        U <O>,<NAB!2,ONRING>
        U <OFFC>,<NAB!NOAFT!1,OFFCOLON>
        U <ONC>,<NAB!NOAFT!1,ONCOLON>
        U <PA>,<MRK!FND!1,PAGE>
        U <P>,<MRK!FND!NOAFT!1,PRINT>
        U <Q>,<NAB!NOAFT!1,QUIT>
        U <R>,<ONORN!1,READ>
        U <REP>,<MRK!FND!1,REPLAC>
        U <SA>,<MRK!FND!1,SAVE>
        U <SP>,<NAB!2,SPACNG>
        U <S>,<MRK!FND!NOAFT!2,SUBSTI>
        U <T>,<NAB!1,TABS>
        U <U>,<MRK!FND!MHSB!AFTER!2,UNMARK>
        U <V>,<NAB!NOAFT!2,VERSN>
        U <W>,<MRK!FND!1,WRITE>
        U1 <BYTE(7)15,0,0,0,0>,<FND,CARRET>
        U1 <BYTE(7)12,0,0,0,0>,<NAB,LINEFD>
        U <^>,<NAB,UPCOM>
        U </>,<MRK!FND,SLCOM>
        U <_>,<MRK!FND!ONE,BKCOM>
        U <=>,<MRK!FND!ONE,EQCOM>
> ; COMMAND DISPATCH TABLE %CMACRO
DEFINE U(A,B)<ASCIZ *A*>
DEFINE U1(A,B)<A>

CMDLST: %CMACRO
CMDEND==.-CMDLST

DEFINE U(A,B)<XWD 'B>
DEFINE U1(A,B)<XWD 'B>

CMDADR: %CMACRO
;START OF ACTUAL EDITOR (YUK!) CODE

START0: JRST [SETZM RPG
                JRST STAR01]
        SETOM RPG
STAR01: RESET
IFN PURE,<
        MOVE    0,[XWD HIGH,LOW];BLT LO SEG DATA DOWN
        BLT     0,LOWEND-1      ; FRM HISEEG WHERE STORED
>
        SETZM PBLOCK+1
        MOVE 0,[PBLOCK+1,,PBLOCK+2]
        BLT 0,LASTZR
        MOVE X1,JOBREL
        MOVEM X1,SVJOB
        MOVEI X1,PCODE1         ;NORMAL RTYCHG CODE NO.
        CAME 17,[SIXBIT/KLUDGE/];A KLUDGE ENTRY?
        JRST NOKLUG             ;NO
        SETOM KLUDGE            ;YES, SET KLUDGE FLAG
        MOVEM 16,PROCNO         ;AND SAVE PROCESSOR NUMBER
        MOVEM 15,KLUCOD         ;AND KLUDGE CODE
        CAIN 16,MAGNUM          ;FROM MAGNUM?
        MOVEI X1,MAGCOD         ;YES, USE MAGNUM RTYCHG CODE NO
NOKLUG: MOVEM X1,PCODNO         ;SET RTYCHG CODE NO.
        SETZ F,
        SKIPE RPG
        TRO F,RPG.F
        MOVE    P,PLIST         ;SET UP PDL
START:  PUSHJ   P,STARTA        ;GET INITIAL TTY STUFF SET UP
        MOVEI X1,GETREE
        MOVEM X1,JOBREN
        PUSHJ P,%OFFESC         ;TURN OFF ESCAPES UNTIL COMMAND MODE
        MOVEI X1,TRPENT
        MOVEM X1,JOBAPR
         PUSHJ P,APR
        MOVE P,PLIST
        MOVEI X1,DICT
        MOVEM X1,LASLIN
        MOVEM X1,CURLIN

        SETZM   FLMDET  ; WORKSPACE FILE MODE HAS NOT BEEN DETERMINED
        SETZM   WSFLMD  ; BUT TIE ASSUMES NORMAL ASCII UNTILL IT IS DETERMINED

        PUSHJ P,RESTAB          ;RESTORE (INITIALIZE) TAB STOPS
        PUSHJ   P,INITUP
        PUSHJ P,INITMP  ;INITIALIZE TMP FILE
        PUSHJ P,INITTY
        SKIPE [PRFINI]          ;SKIP IF PROFILE MODULE NOT LOADED
        PUSHJ P,PRFINI          ;INITIALIZE PROFILE MODULE
        RTYCHG                  ;CALL RTYCHG
        TRNN F,RPG.F
        JRST GETCOM
        MOVE X1,[2,,BLOCK]      ;START TMPCOR UUO
        TMPCOR X1,      ;READ AND DELETE
        PUSHJ P,NOCORF  ;POOEY
        MOVE NEW,[POINT 7,BUFFA]
        ILDB CH ,NEW
        CAIN CH," "     ;BLANK?
        JRST .-2
        SKIPN CH
        JRST QUEST

        MOVEI X1,^D50           ;COUNT OF CHARS
        MOVE X2,PFNPNT          ;POINTER INTO PFNAME
OBLOOP: CAIE CH,"."
        CAIN CH,","
        JRST OBINC
        CAIE CH,"("
        CAIN CH,")"
        JRST OBINC
        CAIE CH,"["
        CAIN CH, "]"
        JRST OBINC
        CAIGE CH,60             ;ZERO
        JRST ENDOBJ
        CAIG CH,71              ;9
        JRST OBINC
        CAIGE CH,101            ;A
        JRST ENDOBJ
        CAIG CH,132             ;Z
        JRST OBINC
        CAIGE CH,141            ;a
        JRST ENDOBJ
        CAILE CH,172            ;z
        JRST ENDOBJ
        SUBI CH,40              ;LOWER TO UPPER CASE
OBINC:  IDPB CH,X2              ;DEPOSIT INTO PFNAME
        ILDB CH,NEW             ;LOAD NEXT CHAR
        SOJG X1,OBLOOP

ENDOBJ: CAIE CH,"!"             ;BANG MEANS DONT LET USER GO TO XEXEC
        JRST NOBANG
        SETOM NOESC             ;USER MAY NOT QUIT SYSTEM
        ILDB CH,NEW             ;ADVANCE CHAR POS
NOBANG: MOVEI X1,12             ;TEST FOR LF IF NOT ESCAPE 175
        MOVEI X3,0
        IDPB X3,X2              ;DEPOSIT A ZERO
        CAIE CH,175             ;ESCAPE 175 INDICATES CREATE COMMAND
        JRST NOTCRE
        SETOM CRECMD
        MOVEI X1,0              ;0 AFTER 175 DECIDES WHETHER HASH FOLL
NOTCRE: ILDB CH,NEW             ;GET NEXT CHAR
        CAMN CH,X1              ;IS THERE A HASH FILENAME?
        JRST NOHASH             ;NO
        MOVEI X1,9              ;THERE MUST BE 9 SIXBIT TYPE CHARS
        MOVE X2,RPGPNT          ;POINTER INTO FILE BLOCK
HSHNAM: CAIL CH,40
        CAILE CH,137
        JRST NOHASH
        SUBI CH,40              ;MAKE SIXBIT
        IDPB CH,X2              ;DEPOSIT
        ILDB CH,NEW             ;NEXT
        SOJG X1,HSHNAM
        SETOM WRIPFN            ;WRITE PFNAME NAME FLAG
        CAIE    CH,"["          ;does PPN follow real file name
        JRST    CHKEXT
        SETZB   X1,X2
HSHPP1: ILDB    CH,NEW
        CAIN    CH,","
        JRST    HSHPP2
        SUBI    CH,"0"
        LSH     X1,3
        ADD     X1,CH
        JRST    HSHPP1
HSHPP2: ILDB    CH,NEW
        CAIN    CH,"]"
        JRST    HSHPP3
        SUBI    CH,"0"
        LSH     X2,3
        ADD     X2,CH
        JRST    HSHPP2
HSHPP3: HRL     X2,X1
        MOVEM   X2,RPGFIL+3
        JRST CHKEXT             ;GOT ALL NINE- GO LOOK AT EXTENSION
NOHASH: MOVEI X1,RPGFIL         ;WHERE TO PUT FILE NAME
        MOVE NEW,PFNPNT ;WHERE TO GET CHARS FROM
        ILDB CH,NEW             ;LOAD UP FIRST CHAR FOR FILNAM
        PUSHJ P,FILNAM          ;GET THE FILE NAME
CHKEXT: SETZM COLON
        HLRZ X1,RPGFIL+1
        CAIE X1,(SIXBIT/SIM/)
        CAIN X1,(SIXBIT/MAC/)
        SETOM COLON
        CAIN X1,(SIXBIT/FAL/)
        SETOM COLON
        SKIPE CRECMD
        JRST STARTC             ;NEWFILE - CREATE COMMAND

;MODIFY COMMAND

;CHECK FOR EXAMINE COMMAND: REG17=SIXBIT/KLUDGE/, REG15=1

        SKIPN KLUDGE            ;KLUDGE ENTRY?
        JRST MDCONT             ;NO
        MOVE 1,KLUCOD           ;YES, GET KLUDGE CODE
        CAIN 1,1                ;EXAMINE MODE IS CODE #1
        SETOM EXAMIN            ;YES
MDCONT: MOVE X1,[RPGNAM,,INNAM] ;MODIFY COMMAND- READ IT IN
        BLT X1,INFIL+3
        SETZ F,
        TRO F,RPG.F
        TLO F,TELLNO
        SETZM FLRNG
        JRST READ+1


FILIUS: ASCIZ /File already exists, DELETE? /

PFNPNT: POINT 7,PFNAME
RPGPNT: POINT 6,RPGFIL
; HERE WHEN CREATE COMMAND (FILE NAME TERMINATED WITH ESC 175)
; IF FILE IN EXISTANCE, SAY SO AND QUIT, ELSE ALLOW CREATE
STARTC: INIT SYS,17
        SIXBIT/DSK/
        0
        JRST %DSFAL
        ENTER SYS,RPGFIL
        JRST    [RELEASE SYS,
                HRRZ X1,RPGFIL+1;GET ERROR CODE
                OUTSTR @%ERCOD(X1) ;TYPE ERROR MESSAGE
                OUTSTR CRLF     ;TYPE CRLF
                JRST LEAVE]     ;GOODBYE
; NOW, DETERMINE IF OLD OR NEW...
        SETOM   CRECMD          ;ITS A CREATE COMMAND
        LDB     0,[POINT 1,RPGFIL+1,18];1 IF OLD 0 IF NEW
        CLOSE SYS,40            ;CLOSE IT UP
        RELEASE SYS,
        JUMPE   0, GETCOM       ;IF FILE IS NEW GO GET COMMAND
; FILE EXISTS... MAKE SURE IT'S OK WITH USER
        OUTSTR  FILIUS
        PUSHJ   P,YORN          ;SEE WHAT HE WANTS
        JRST    LEAVE           ;NOT OK-GOODBYE...
        JRST GETCOM             ;ANSWER IS YES - CONTINUE PROCESSING

LEAVE:  SETZM RPG               ;BAD DEFAULT NAME - WIPE IT OUT
        JRST EGRESS             ;LEAVE EDITOR

NOCORF: PJOB
        MOVEI X3,3
        IDIVI 0,12
        ADDI X1,20
        LSHC X1,-6
        SOJG X3,.-3
        HLLM X2,SYSTMP
        INIT SYS,17
        SIXBIT/DSK/
        0
        JRST %DSFAL
        LOOKUP SYS,SYSTMP
        JRST %TMFAL
        INPUT SYS,BLOCK+1
        POPJ P,

STARTA: MOVEI   X1,KATA.P
        MOVEM   X1,TIRE+TIRCNT
        MOVEI   XBCB
        MOVEM   X1,TIRE+OB.ADR
        MOVEI   X1,NEWBCB
        MOVEM   X1,TIRE+NB.ADR
        MOVEI   X1,TABES
        MOVEM   X1,TIRE+TABADR
        MOVEI   X1,SETALT
        MOVEM   X1,TIRE+%STALT
        MOVEI   X1,TIEACT
        MOVEM   X1,TIRE+%ACTVT
        SETOM   TIRE+CTL.P
        POPJ    P,


;QUIT ROUTINES:

;ROUTINE TO LEAVE EDITOR. DECIDES WHETHER TO RETURN TO MONITOR MODE
;OR TO RUN RPG

EGRESS: PUSHJ P,CLENUP          ;CLEAN UP UNIVERSE
        SKIPN NOESC             ;LET HIM BACK TO MONITOR LEVEL?
        JRST BYEBYE             ;YES
        MOVE 15,FILCHE          ;NO, RETURN VALUE WHETHER FILE CHECKPOINTED.
        JRST RUNRPG             ;NO

;ROUTINE TO RUN RPG

RUNRPG: MOVSI X1,1              ;RUN INCREMENT OF 1
        HRRI X1,RUNBLK          ;SET UP RUN BLOCK
        RUN X1,                 ;RUN RPG
         JRST %RNFAL            ;RUN FAILED

RUNBLK: SIXBIT/SYS/
        SIXBIT/RPG/
        0
        0
        0
        0
;ROUTINE TO RETURN TO MONITOR LEVEL

BYEBYE: EXIT 1,                 ;BYE
        JRST .-1                ;STAY AWAY FOR CONTINUE COMMAND

;ROUTINE TO CLEAN UP UNIVERSE BEFORE LEAVING EDITOR

CLENUP: SKIPE [PRFWRT]          ;SKIP IF PROFILE MODULE NOT LOADED
        PUSHJ P,PRFWRT          ;WRITE PROFILE INFO TO FILE
        RTYCHG(2)               ;FINAL CALL TO RTYCHG
        RELEAS TTY,0            ;RELEASE THE TTY
        MOVEI X1,QUIREE
        MOVEM X1,JOBREN         ;PLACE TO GO ON REENTER
        SETZ F,                 ;RESET FLAGS
        POPJ P,

;ROUTINE TO WRITE THE DEFAULT FILE NAME OUT IF
;NECESSARY OR TO WRITE TO THE FILE NAME GIVEN IN THE EXIT OR GO
;COMMAND.

AUTOWR: TLNE CH,TERM.F          ;IS THERE A FILE NAME GIVEN?
        JRST NOFILE             ;NO
        SETOM IMPMOD            ;YES-AN IMPLICIT MODIFICATION
        JRST NODFLT
NOFILE: SKIPN RPG               ;IS THERE  A DEFAULT FILE NAME?
        JRST NODFLT             ;NO
        SKIPE EXAMIN            ;EXAMINE MODE?
        POPJ P,                 ;YES-IGNORE ATTEMPT TO WRITE TO THE DEFAULT FILE
        TRO F,FIL.EQ            ;FLAG TO PRINT DEFAULT NAME AND NO CONF
        MOVE X1,[RPGNAM,,OUTNAM];SET UP FILE TO WRITE TO
        BLT X1,OUTFIL+3
NODFLT: PUSHJ P,WRIFIL          ;FIND OUT IF WE NEED TO DO A WRITE
        SKIPN X1                ;NEED TO?
        JRST NOWRIT             ;NO
        TRO F,RPG.F             ;YES-RETURN FROM WRITE ROUTINE
        PUSHJ P,WRITE+1         ;WRITE OUT TEXT
NOWRIT: POPJ P,

;ROUTINE TO DECIDE WHETHER THE TEXT NEEDS TO BE WRITTEN OUT OR NOT.

WRIFIL: SETZ X1,                ;SET UP RETURN VALUE
        SKIPN MODMAD            ;ANY MODS?
        SKIPE IMPMOD            ;AN IMPLICIT MODIFICATION?
        SKIPA                   ;YES
        POPJ P,                 ;NO-RETURN ZERO
        MOVE X2,LASLIN          ;YES. ANY TEXT?
        CAIE X2,DICT
        MOVEI X1,1              ;YES-RETURN TRUE
        SETZM IMPMOD            ;RESET IMPLICIT MODIFICATION
        POPJ P,

;ROUTINES TO MANAGE MODMAD
;MODMAD IS NON-ZERO IF MODIFICATIONS HAVE BEEN MADE

;ROUTINE TO RECOGNISE A MODIFICATION
;IN EXAMINE MODE, THE FIRST MODIFICATION CAUSES A WARNING.

INCMOD: SKIPE MODMAD            ;IS THIS THE FIRST MODIFICATION?
        JRST DOINC              ;NO
        SKIPE EXAMIN            ;YES-CHECK FOR EXAMINE MODE
        OUTSTR CAUTION          ;EXAMINE MODE-PRINT WARNING MESSAGE
DOINC:  AOS MODMAD              ;INCREMENT MODIFICATIONS COUNTER
        POPJ P,

CAUTION: ASCIZ/

Caution: EXAMINE mode

/

; ROUTINES TO SET THE WORKSPACE FILE MODE TO 0 FOR NORMAL, -1 FOR KATA KANA
; DWSMIF Determines Work Space Mode from Input File
; DWSMCP Determines Work Space Mode from the Command Port mode
;  FLMDET tels us if the mode is already determined or not
;  WSBYSZ is the workspace byte size

        EXP     ^D9     ; KATA KANA HAS 9 BIT BYTES
BYSZTB: EXP       7     ; NORMAL ASCII HAS 7 BIT BYTES

DWSMCP: SKIPE   FLMDET  ; HAS THE WORKSPACE FILE MODE ALREADY BEEN SET?
        POPJ    P,      ;  YES, RETURN
        MOVE    X1,CMDPTM       ; OTHERWISE WE SET IT TO THE COMMAND PORT MODE
        JRST    DWSM1

DWSMIF: SKIPE   FLMDET  ; IS IT ALREADY KNOWN?
        POPJ    P,      ;  YES, GO HOME
        MOVE    X1,KKINFL       ; OTHERWISE WE SET IT TO THE INPUT FILE MODE

DWSM1:  MOVEM   X1,WSFLMD       ; WORKSPACE FILE MODE IS SET
        MOVE    X1,BYSZTB(X1)   ; WORKSPACE BYTE SIZE IS SET
        MOVEM   X1,WSBYSZ
        SETOM   FLMDET          ; MARK THAT FILE MODE IS NOW KNOWN
        MOVEI   X1,^D36
        IDIV    X1,WSBYSZ       ;calculate number of bytes in a word
        MOVEM   X1,WSCHPW       ;store into Workspace CHaracters Per Word
        PUSHJ   P,INITUP        ; INIT UPDATE AREA POINTER AND COUNTER
                                ; (WE WERE WAITING TO LEARN THE FILE MODE)
        SKIPE   WSFLMD          ; IF KATA KANA, SAY SO
        OUTSTR  [ASCIZ/ workspace is kata kana
/]

        MOVE    X1,[POINT 7,]   ;SET pointers to 7-bit ascii unless:
        SKIPE   WSFLMD          ;IF THE WORKSPACE IS KATA KANA
        MOVE    X1,[POINT 9,0]  ; THEN make pointer 9-bit
        HLLM    X1,CMDPNT       ; MAKE COMMAND LINE KATA
        HLLM    X1,NEWPNT       ; MAKE NEW LINE KATA
        HLLM    X1,OLDPNT       ;MAKE OLD LINE KATA
        HLLM    X1,NTXPT        ; make subs ptr kana
        HLLM    X1,OLTXPT       ; make subs ptr kana
        HLLM    X1,FNDPNT       ; make find command kk
        POPJ    P,              ; AND RETURN


;ROUTINE TO UNDO 1 MODIFICATION:

DECMOD: SOS MODMAD
        POPJ P,

;ROUTINE TO RESET OR INITIALIZE THE MODIFICATIONS COUNTER:

INIMOD: SETZM MODMAD
        POPJ P,
; INITIALIZE THE UPDATE AREA POINTER AND COUNTER

INITUP: MOVE X2,WSFLMD	;check for Kata Kana
        MOVE    X1,INICNT(X2)	; X2=-1 => Kata Kana
        MOVEM X1,UPCNT	; X2=0  => normal ascii
        MOVE X1,INIPNT(X2)
        MOVEM X1,UPPNT
        POPJ P,

        4*BLKSIZ*NOUPBK
INICNT: 5*BLKSIZ*NOUPBK

        POINT 9,UPDATE
INIPNT: POINT 7,UPDATE

; HERE TO INITIALIZE TMP DICTIONARY FILE
; CALL: PUSHJ P,INITMP
INITMP: DATE    X1,             ;GET DATE
        TIMER   X2,             ;AND TIME
        LSH     X1,^D22         ;CONVERT THIS INFORMATION
        IOR     X1,X2           ;INTO A SCREWY TMP NAME
        MOVEM   X1,TMPFIL       ;SAVE THE NAME
        MOVSI   NEW,(SIXBIT/TMP/)
        MOVEM   NEW,TMPFIL+1    ;SET TMP NAME UP
        HLLZS   TMPFIL+1        ;CLEAR RH OF EXTENSION
        SETZM   TMPFIL+2
        SETZM   TMPFIL+3
        INIT    TMP,16
        SIXBIT  /DSK/
        0
        JRST    %DSFAL          ;NO DISK ?
        ENTER   TMP,TMPFIL      ;DO THE ENTER
        JRST    %NOTMP          ;FAILED, MAKE UP ANOTHER
        MOVEI   X1,1
        HRRM    X1,TMPBLK       ;NEXT BLOCK TO DO UPDATING
        POPJ    P,              ;NO, RETURN
; COMMAND WAIT MODE (COMMAND DISPATCHER & TRAP ROUTINES)


;REENTER AFTER A LEGAL EXIT FROM THE EDITOR (NOT FROM A DISCONNECT)

QUIREE: PUSHJ P,STARTA          ;SAVE CURRENT TERMINAL CHARACTERISTICS
        MOVEI X1,GETREE
        MOVEM X1,JOBREN
        PUSHJ P,INITTY          ;SET UP TTY CHANNEL
        RTYCHG                  ;MAKE AN INITIAL CALL TO RTYCHG
        JRST GETCOM

SETALT: EXCH    X1,ALTADR
        POPJ    P,

;REENTER AFTER A DISCONNECT:

GETREE: PUSHJ P,STARTA          ;SAVE AND SET TERMINAL CHARACTERISTICS
        PUSHJ   P,INITTY        ; COMMAND PORT MODE MAY HAVE CHANGED
        JRST REENTR             ;OHTERWISE, TREAT SIMILAR TO ESCAPE

TRPENT: AOS     ALTCNT          ;SET 'WE SEEN TRAP' FLAG
        SKIPN   ESCNTR          ;SAVING UP TRAPS? (ESCAPES DISABLED?)
        JRST    GOFALT          ;PROCESS THE ESCAPE
        SETOM   ALTFLG          ;SET "ESCAPE PENDING" FLAG
        JRST    ESCCON          ;DISMIS TO CONTINUE FROM THE ESCAPE

TRPIN1: JRSTF   @JOBTPC         ;RETURN FROM INTERRUPT

GOFALT: SETZM   ALTFLG          ;PENDING ESCAPE IS NOW HONORED
        MOVE    X1,ALTCNT       ;HOW MANY ESCAPES SEEN NOW?
        CAIG    X1,1            ;IF MORE THAN 1, WE MUST HONOR IT
        SKIPE   COMW.F          ;OR COMMAND WAIT ??
        JRST    GOFAL1          ;YES, GO TO COMMAND MODE
        OUTCHR  BING            ;GO DING
ESCCON: MOVEM   X1,ALTBLK+2     ;SAVE X1
        MOVEI   X1,TRPIN1       ;DISMISSAL PLACE
        JRST    GOFAL2          ;AND DISMISS

GOFAL1: MOVEM   X1,ALTBLK+2     ;REG FOR DISMISS UUO
        MOVE    X1,ALTADR       ;ADR TO DISMISS TO CMD MODE

GOFAL2: MOVEM   X1,ALTBLK+1     ;ADR TO GO TO
        MOVEI   X1,402000         ;APRENB BITS
        MOVEM   X1,ALTBLK+0     ;BLK: 0=BITS, 1=GOADR, 2=REG DATA
        MOVEI   X1,ALTBLK       ;ADR OF BLOCK
        DISMIS  X1,             ;DISMISS THE INTERRUPT

APR:    SKIPE [PRFINI]          ;SKIP IF PROFILE MODULE NOT LOADED
        POPJ P,                 ;DON'T ARM TRAPS WHEN DOING PROFILE
        MOVEI X1,402000
        APRENB X1,
        POPJ P,

GTFALT: CLRBFO                  ;CLEAR THE OUTPUT BUFFER
        CLRBFI                  ;CLEAR INPUT BUFFER
        OUTSTR  CRLF            ;TYPE CR-LF STUFF
        CLOSE   OUTF,40         ;MAKE SURE WRITE CHANNEL ABORTED
        RELEASE OUTF,           ;AS SO..
        RELEASE COMF,           ;RELEASE COMMAND FILE IS ANY
        CLOSE   REPF,40         ;MAKE SURE REPLACE CHANNEL ABORTED
        RELEASE REPF,           ;AS SO...
REENTR: PUSHJ P,APR             ;A REENTER FROM DETACH SIMILAR TO ALT MODE
        SETZM   OTTY+2
        SETZM TTYBUF+3
        MOVE 0 ,[XWD TTYBUF+3,TTYBUF+4]
        BLT 0,TTYBUF+22
        ENDBUF                  ;TURN OFF COMMAND FILE OR COMMAND BUFFER
        MOVE X1,PRECUR
        MOVEM X1,CURLIN
GETCOM: MOVE P,PLIST            ;CLEAR UP PUSH DOWN LIST
        PUSHJ P,%ONESC          ;GET ANY ESCAPES THAT HAPPENED
        SETZM   ALTCNT          ;RESET ESCAPE COUNTER
        SETZM   ESCNTR          ;RESET ESCAPE ENABLE-DISABLE FLAG
        SETZM DUMDUM
        MOVE X1,CURLIN
        MOVEM X1,PRECUR
        SETZM DONCHG
        TRZ F,37777             ;LEAVE COMF.F,BUF.F,ONR.F
        TLZ F,777777            ;CLEAR LEFT HALF LEAVE RIGHT
        MOVE DIC,CMDPNT         ;POINTER INTO LAST COMMAND
        PUSHJ P,SETOLD          ;MAKE IT THE OLD LINE FOR CMD ENTRY
        SKPINC                  ;RESET THE CONTROL \ "STOP PRINTING"
        JFCL                    ;MONITOR COMMAND
        SETOM COMW.F            ;SET MODE
        SKIPE ENABLE            ;LET BUFFERS EXECUTE INTO COMMAND MODE?
        JRST GETCM2             ;YES, NO MATTER WHO TURNED IT ON
        SKIPE CMWBFR            ;ONLY IF IT WAS TURNED ON IN COMMAND MODE
        JRST GETCM2
        SETZM BUFFR             ;IT WAS NOT SO DISABLE ANY BUFFER
        TRNE F,COMF.F
        JRST GETCM2
        SETZM TIRE+ACRING
        SETZM TIRE+%GTCHR
        SETZM TIRE+%OTCHR
        TRZE F,BUF.F
        OUTSTR CRLF             ;PRINT CRLF WHEN COMING BACK INTO COMMAND MODE
GETCM2: SETZM CMWBFR            ;RESET INDICATOR
        PUSHJ   P,GETCMD
        PUSHJ P,CMDCLR          ;CLEAR THE OLD COMMAND
        PUSHJ P,CMDSET          ;AND SAVE A NEW ONE
        SKIPE BUFFR             ;ARE WE EXECUTING A BUFFER?
        SETOM CMWBFR            ;YES-SET COMMAND WAIT BUFFER ENABLE
        JRST DECODE             ;GO CHECK SYNTAX AND CARRY ON

SETUP:  PUSHJ P,SETLI1          ;ZERO OUT NEW LINE
        MOVEI X1,LINLEN
        MOVNM X1,NCOUNT
        SETZM PCOUNT            ;COUNT OF PRINT CHAR POSITIONS IN NEW LINE
        MOVE OLD ,OLDPNT
        POPJ P,

CMDCLR: MOVE DIC,CMDPNT         ;POINT TO BEGINNING OF COMMAND LINE
        SETZM (DIC)             ;ZERO FIRST WORD
        HRR X1,DIC              ;GET ADDRESS
        AOJ X1,                 ;OF SECOND WORD
        HRL X1,DIC              ;ADDR OF FIRST WD IN LEFT HALF
        BLT X1,BUFLEN-1(DIC)    ;CLEAR OUT THE WHOLE THING
        POPJ P,

CMDSET: MOVE OLD,NEWPNT         ;BEGINNING OF NEW LINE IMAGE
        MOVE DIC,CMDPNT         ;BEGINNING OF CMD LINE IMAGE
CDSTLP: ILDB X1,OLD             ;PICK UP THE NEXT CHARACTER FROM NEW LINE
        IDPB X1,DIC             ;AND DEPOSIT IN CMDLIN
        CAMN OLD,NEW            ;UP TO CURRENT NEW LINE POSITION?
        JRST CMDCOP             ;YES, DONE
        CAIE X1,15
        JUMPN X1,CDSTLP         ;END OF LINE?
CMDCOP: MOVEI X1,15             ;YES
        IDPB X1,DIC             ;MAKE SUPER SURE CR ENDS THE LINE
        POPJ P,

;Routine to get a command line. Activates on / = _ ^ if not quoted.

GETCMD: MOVEI   X1,0            ;INDICATE COMMAND MODE
        PUSHJ   P,TIE
        CAIE    X1,SPLITL       ;^J - END THE LINE WITH ^J
        JRST    GTCMD1
        MOVEI   X1,12
        DPB     X1,NEW
        SETZ    X2,
        MOVE    X3,NEW
        IDPB    X2,X3
        JRST    GETCM$
GTCMD1: CAIE    X1,CHRACT       ;ACTIVATION?
        JRST    GETCM$          ;NO
        AOS     NCOUNT
        IBP     NEW
        SETZ    X2,
        MOVE    X3,NEW
        IDPB    X2,X3
        MOVE    X1,TIRE+ACTCHR
        CAIE    X1,"="
        CAIN    X1,"_"
        SKIPA
        PUSHJ   P,PRCRLF        ;/ ^ AND _ GET CRLF
GETCM$: POPJ    P,

PRCRLF: IFNBFR <OUTSTR CRLF>
        POPJ    P,
; %OFFESC - TURN OFF ESCAPES BY INCREMENTING ESCNTR
%OFFESC: AOS    ESCNTR  ;INCREMENT 'OFF ESCAPE' COUNTER
        POPJ    P,      ;AND RETURN

; %ONESC - TURN ON ESCAPES AND CHECK FOR PENDING ESCAPE (ALTCNT)
%ONESC: SKIPLE  ESCNTR  ;SKIP IF ESCAPES ALREADY ON
        SOSLE   ESCNTR  ;SKIP IF ESCAPES NEED TO BE ENABLED
        POPJ    P,      ;ALL IS A-OK
        SKIPN   ALTFLG          ;IS AN ESCAPE PENDING?
        POPJ    P,              ;NO, NO ACTION NECESSARY
        MOVEI   X1,ONESC1       ;TRAP ADDRESS TO CONTINUE PROCESSING
        MOVEM   X1,JOBTPC
        JRST    GOFALT          ;YES - FAKE AN ESCAPE

ONESC1: POPJ    P,              ;RETURN FROM WHERE WE CAME
;Routines to interface to the terminal input routine I%TIE.

;TIE - routine to call I%TIE.
;save/restores registers
;sets certain parameters according to input value (in X1) as follows:
; 0 - Command input
; 1 - Substitute (first string)
; 2 - Append/Insert
; 3 - Edit/Modify
; 4 - Load/Get (of command buffer)
; 5 - "Normal" terminal input (used for file confirmation etc)
; 6 - Substitute (second string)

;On return, checks for following conditions:
; escape
; bel condition in command file or buffer
; line overflow

TIE:    MOVEM   X1,TIEMOD
        MOVEM   16,SAVAC+16
        MOVEI   16,SAVAC
        BLT     16,SAVAC+15

;set prompt

        SKIPN   BUFFR           ; are we getting chars from a command buffer?
        SKIPE   COMBFR          ; or from a commands file?
        SKIPA
        SETZM   TIRE+%OTCHR     ; no, so allow the prompt to print

        XCT     PMTBLK(X1)
        MOVEM   X1,TIRE+PROMPT
        JRST    TIEB

TIEPMT: MOVEI   X1,TIEBCB
        POPJ    P,

PMTBLK: MOVEI   X1,STARPR
        MOVEI   X1,QUOTPR
        SETZ    X1,
        SETZ    X1,
        SETZ    X1,
        JRST    TIEA1
        MOVEI   X1,FORPR

ACTBLK: MOVEI   X1,ACEDIT
        MOVEI   X1,ACNTRL
        SETZ    X1,
        MOVEI   X1,ACMCJC
        MOVEI   X1,ACNTRL+ACMCJC
        SETZ    X1,
        MOVEI   X1,ACNTRL

TIEA1:  MOVEM   X2,TIEBCB       ;ADDRESS OF PROMPT
        SETZM   TIEBCB+2        ;BEGIN POSITION
        HRLI    X2,(POINT 7,0)  ; MAKE BYTE POINTER
        SKIPE   WSFLMD
        HRLI    X2,(POINT 9,0)  ; MAKE IT KATA KANA IF WORKSPACE MODE IS XA
        SETZ    X1,
        ILDB    X3,X2
        SKIPE   X3              ;END OF STRING?
        AOJA    X1,.-2
        MOVEM   X1,TIEBCB+1
        MOVEM   X1,TIEBCB+3
        MOVEI   X1,TIEPMT
        MOVEM   X1,TIRE+PROMPT
        JRST    TIEB

;Set ACONDP and ACONQP if TIEMOD=2 (Insert/Append)

TIEB:   SETZM   TIRE+ACONDP
        SETZM   TIRE+ACONQP
        MOVE    X1,TIEMOD
        CAIE    X1,2
        JRST    TIEC
        SETOM   TIRE+ACONDP
        SETOM   TIRE+ACONQP

; TELL TIE WHETHER THE COMMAND PORT IS KATA KANA

TIEC:   MOVN    X1,WSFLMD       ; TIRE(KATA.P) is set up as:
        SKIPN   CMDPTM          ; 1 for kata kana file and command port
        MOVN    X1,X1           ; -1 for kata kana file only
        MOVEM   X1,TIRE+KATA.P  ; 0 otherwise

;Set appropriate activation mask:

        MOVE    X1,TIEMOD
        XCT     ACTBLK(X1)
        MOVEM   X1,TIRE+ACTMSK

        SETOM   TIRE+BUFNUM
        MOVE    X1,TIEMOD
        SETZM   TIRE+CTLG.P
        CAIE    X1,0
        CAIN    X1,6
        SETOM   TIRE+CTLG.P     ;SET IN COMMAND AND SUBS-2 MODES

        SETZM   TIRE+SEMI.P
        CAIN    X1,4            ;LOAD/GET IS SPECIAL INPUT MODE
        SETOM   TIRE+SEMI.P

        PUSHJ   P,SETUP         ;clear out new line & pointers

        MOVEI   X1,TIRE
        PUSHJ   P,I%TIE

        MOVEM   X1,SAVAC+1
        HRLZI   16,SAVAC
        BLT     16,16

        CAILE   X1,0
        CAILE   X1,BELCOD
        JRST    BADTIE          ;BAD RETURN CODE
        JRST    TIERTN-1(X1)

TIERTN: JRST    TIEOK           ;QCODE
        JRST    TIEOK           ;NORMAL
        POPJ    P,              ;DCODE (NEW LINE BUFFER IS EMPTY)
        JRST    TOOLNG          ;LONGCD
        JRST    BADTIE          ;BUFCOD (SHOULD NEVER GET THIS)
        JRST    TIEOK           ;SPLITLINE
        JRST    BADTIE          ;BADCHARS
        JRST    BADTIE          ;BADLEN
        JRST    TIEESC          ;ESCAPE
        JRST    TIEOK           ;CHRACT- DO NOT APPEND CR ON CHAR ACTIVATION
        JRST    TIEBEL          ;BEL OONDITION IN BUFFER/COMMAND FILE.
        JRST    BADTIE          ;BADREQ

BADTIE: OUTSTR [ASCIZ /Bad return from input routine
/]
        POPJ    P,

        4
BYPRWD: 5       ; THIS TABLE INDEXED BY COMMAND PORT MODE GIVES # OF BYTES PER WORD
        POINT   9,0
BYTEPT: POINT   7,0     ; THIS ONE GIVES A BLANK BYTE POINTER



;TIEOK - normal return from I%TIE. Append CR NUL. Set NEW to
;point to the CR or to last character in line if char activation.
;Also set NCOUNT.

TIEOK:  MOVE    X1,NEWBCB+BCBPNT ;COUNT
        MOVEM   X1,NCOUNT
        MOVE    X3,WSFLMD       ;  Get workspace file mode
        IDIV    X1,BYPRWD(X3)
        ADD     X1,NEWBCB+BCBADR
        HLL     X1,BYTEPT(X3)
        SOJL    X2,.+3          ; X2 CONTAINS THE REMINDER FROM THE IDIV
        IBP     X1
        JRST    .-2

        MOVE    X2,SAVAC+1
        CAIE    X2,CHRACT
        JRST    TIEOK1
        MOVE    NEW,X1          ;CHAR ACTIVATION - SET NEW TO PT TO LAST CHR
        MOVE    X1,SAVAC+1
        POPJ    P,

TIEOK1: MOVEI   X2,15
        IDPB    X2,X1
        AOS     NCOUNT
        MOVE    NEW,X1          ;OTHER RETURNS, NEW POINTS TO CR.
        SETZ    X2,
        IDPB    X2,X1           ;APPEND NUL
        MOVE    X1,SAVAC+1

        POPJ    P,

TOOLNG: PUSHJ   P,SWITCH        ;PUT NEW LINE INTO OLD LINE
        OUTSTR  LONGLN
        OUTSTR [ASCIZ /Please re-enter; 1st 256 characters are in old line
/]
        ENDBUF
        MOVE    X1,TIEMOD       ;use same mode as previous call
        JRST    TIE             ;try again

TIEESC: JRST    GTFALT          ;HONOR THE ESCAPE

;BEL condition during buffer or command file:

TIEBEL: OUTCHR  BING
        ENDBUF
        JRST    GETCOM
;Routine to handle activations from I%TIE.
;BELCOD - bel condition
;BUFCOD - buffer call
;Act on Char - ^D ends input for LOAD, SUBSTITUTE; ^V^M trapped for Edit/Mod.
;Act on ^D and ^Q at beginning of line - ^D always return; ^Q check if there
; are more lines to back up in the insert or not.

TIEACT: MOVEM   X1,TIRADR
        MOVE    X2,RTNCOD(X1)
        CAIE    X2,BELCOD
        JRST    TIEAC2

;BELCOD activation - Bel about to be rung. We only get this one when
;we're in a command file or buffer. If in a buffer and ONRING has been
;specified then we activate the appropriate buffer and return to continue
;input. Else return to abort input.

        MOVE    F,SAVAC+F
        TRNE    F,ONR.F         ;ONRING SET?
        TRNN    F,BUF.F         ;AND IN A BUFFER?
        JRST    NOBFRS          ;NO
        MOVE    X1,RINBUF       ;THE "ONRING" BUFFER NUMBER
        PUSHJ   P,ONBUFR        ;TURN THAT BUFFER ON
        MOVEI   X1,1            ;CONTINUE PROCESSING, NO TIRE CHANGES
        POPJ    P,

;In this case we have a Bel condition in a command file or buffer and we must
;abort input processing (close files on return from TIE, not now).

NOBFRS: MOVEI   X1,0            ;TO ABORT
        POPJ    P,

TIEAC2: CAIE    X2,BUFCOD       ;BUFFER CALL?
        JRST    TIEAC3

;Buffer call. Check the buffer number. If bad, return an "abort"
;to I%TIE which will ring Bel and continue input. Otherwise, activate
;the specified buffer and return to TIE having set
; ACRING - activate on Bel conditions
; %GTCHR - routine to get characters from the buffer
; %OTCHR - routine to accept an output character (usually thrown away)

        MOVE    X1,ACTCHR(X1)   ;BUFFER NUMBER
        HLL     X1,.CTTAB(X1)    ;GET FLAGS
        TLNE    X1,NUM.F        ;NUMBER?
        JRST    GOTBUF          ;YES,OK
        MOVEI   X1,0            ;TO ABORT
        POPJ    P,

GOTBUF: HRLI    X1,0
        MOVE    F,SAVAC+F
        TRNE F,BUF.F!COMF.F
        JRST GOTBF1
        OUTCHI  "#"
        OUTCHR X1
GOTBF1: SUBI    X1,^O60
        PUSHJ   P,ONBUFR
        MOVEM   F,SAVAC+F
        MOVE    X1,TIRADR
        SETOM   ACRING(X1)
        MOVEI   X2,GT%CHR
        MOVEM   X2,%GTCHR(X1)
        MOVEI   X2,OT%CHR
        MOVEM   X2,%OTCHR(X1)
        MOVEI   X1,2            ;CONTINUE WITH TIRE CHANGES
        POPJ    P,

GT%CHR: MOVE    F,SAVAC+F
        MOVEM   X1,TIRADR
        PUSHJ   P,GNC
        MOVEM   F,SAVAC+F
        POPJ    P,

OT%CHR: POPJ    P,              ;THROW THE OUTPUT CHARCTER AWAY

TIEAC3: CAIE    X2,CHRACT       ;CHARACTER ACTIVATION?
        JRST    TIEAC4

        MOVE    F,SAVAC+F
        MOVE    X2,TIEMOD
        MOVEI   X1,1
        JRST    .+1(X2)

        JRST    CMDACT          ;HANDLE COMMAND LEVEL ACTIVATIONS
        JRST    SUBACT          ;SUBST - CHECK FOR ^D
        POPJ    P,              ;INSERT/APPEND - NEVER HAPPENS
        JRST    MODACT          ;EDIT/MODIFY - ^V^M
        JRST    SUBACT          ;BUFFER LOAD
        POPJ    P,              ;NORMAL CALL - NEVER GET HERE
        JRST    SUBACT

SUBACT: SETZ    X1,
        MOVE    X3,TIRADR
        MOVE    X2,ACTCHR(X3)
        MOVE    X4,TEXT.P(X3)
        CAIN    X2,15
        POPJ    P,              ;ABORT ON ANY CR DURING BUFFER LOAD
        CAIN    X2,4            ;^D?
        SKIPE   X4              ;AND TYPED DIRECTLY IN?
        MOVEI   X1,1            ;NO, IT WAS COPIED OR ENTERED WITH ^V
        POPJ    P,

MODACT: SETZ    X1,
        MOVE    X3,TIRADR
        MOVE    X2,ACTCHR(X3)
        MOVE    X4,TEXT.P(X3)
        CAIN    X2,15           ;^M?
        SKIPN   X4              ;^V^M?
        MOVEI   X1,1            ;NO, DO NOT ABORT INPUT
        POPJ    P,

TIEAC4: CAIE    X2,DCODE
        JRST    TIEAC5

        SETZ    X1,             ;ALWAYS ABORT ^D IN INSERT/APPEND
        POPJ    P,

;QCODE
TIEAC5: SETZ    X1,
        MOVE    X2,TMPLIN
        CAMN    X2,FLRNG        ;ANY LINES LEFT TO DELETE?
        MOVEI   X1,1            ;NO-CONTINUE INPUT BY RINGING BEL
        POPJ    P,

;Routine to process a command mode activation.
;Activate on unquoted / = _ ^ (return 0 if all quotes are paired, 1 if not).

CMDACT: SETZ    F,
        MOVE    X1,NEWBCB+BCBPNT        ;COUNT
        MOVE    NEW,NEWPNT
ACLOOP: SOJL    X1,ACTEND
        ILDB    CH,NEW
        MOVE    X2,CH
        HLL     CH,.CTTAB(CH)
        TLNE    CH,DEL.F        ;DELIMETER?
        JRST   [TLOE    F,DELIM.F ;YES, SET FLAG
                JRST    ACTLP1  ;CHECK IF MATCH
                TLNE    CH,ADD2.F ; ADD 2 TO MATCH?
                ADDI    X2,2
                MOVEM   X2,DELIM
                JRST    .+1]
        JRST    ACLOOP

;CHECK FOR DELIMITER MATCH:

ACTLP1: CAMN    X2,DELIM
        JRST    [TLZ F,DELIM.F    ;GO MATCH, UNSET FLAG
                SETZM   DELIM
                JRST    .+1]
        JRST    ACLOOP

ACTEND: SETZ    X1,
        TLNE    F,DELIM.F         ;INSIDE QUOTED STRING?
        MOVEI   X1,1            ;YES
        POPJ    P,

;Routine to return address of BCB for "*" prompt

STARPR: MOVEI   X1,PMTADR       ;  PMTADR CONTAINS SOME PROMPTS
        SKIPE   WSFLMD          ;  OR IF KATA KANA
        MOVEI   X1,KKPRMT       ;  USE KKPRMT
        MOVEM   X1,TIEBCB+BCBADR
        MOVEI   X1,1
        MOVEM   X1,TIEBCB+BCBLEN
        SETZM   TIEBCB+BCBMIN
        MOVEI   X1,1
        MOVEM   X1,TIEBCB+BCBMAX
        SETZM   TIEBCB+BCBPNT
        MOVEI   X1,TIEBCB
        POPJ    P,

;Routine to return address of BCB for '"' prompt

QUOTPR: MOVEI   X1,PMTADR       ; PMTADR CONTAINS SOME PROMPTS
        SKIPE   WSFLMD          ; BUT IF THE WORKSPACE IS KATA KANA
        MOVEI   X1,KKPRMT       ; USE KKPRMT
        MOVEM   X1,TIEBCB+BCBADR
        MOVEI   X1,2
        MOVEM   X1,TIEBCB+BCBLEN
        MOVEM   X1,TIEBCB+BCBMAX
        MOVEI   X1,1
        MOVEM   X1,TIEBCB+BCBMIN
        SETZM   TIEBCB+BCBPNT
        MOVEI   X1,TIEBCB
        POPJ    P,

;Routine to return address of BCB for 'FOR "' prompt

FORPR:  MOVEI   X1,PMTADR       ; PMTADR CONTAINS SOME PROMPTS
        SKIPE   WSFLMD          ; CHECK THE WORKSPACE MODE
        MOVEI   X1,KKPRMT       ; AND MAYBE USE THE KATA KANA PROMPTS
        MOVEM   X1,TIEBCB+BCBADR
        MOVEI   X1,7
        MOVEM   X1,TIEBCB+BCBLEN
        MOVEM   X1,TIEBCB+BCBMAX
        MOVEI   X1,2
        MOVEM   X1,TIEBCB+BCBMIN
        SETZM   TIEBCB+BCBPNT
        MOVEI   X1,TIEBCB
        POPJ    P,

;ROUTINE TO DETERMINE IF TOOMNY CHARS

CKCNT:  AOSGE NCOUNT            ;OVER LINLEN?
        JRST PCNTR              ;NO-GO ADJUST PRINT CHR COUNT AND RETURN
        CAIN CH,15      ;CR?
        POPJ P,; YES SO OK

TOOMNY: OUTSTR LONGLN
        MOVEI CH,15
        POPJ P ,


CPOPJ1: AOS     (P)
        POPJ    P,
;ROUTINE TO ADJUST PRINTING POSITION COUNT OF NEW LINE AS APPROPRIATE.
;CR AND FF RESET TO ZERO, CONTROL-H SUBTRACTS ONE, CONTROL-I ADDS CORRECT
;NUMBER OF SPACES, ALL OTHER CONTROL CHARACTERS HAVE NO EFFECT, AND THE
;REMAINING CHARACTERS ADD 1 TO THE COUNT.

PCNTR:  HRRZ X1,CH              ;CHAR WITHOUT FLAGS
        CAIGE X1,40             ;A PRINTING CHARACTER?
        JRST NPCHAR             ;NO
        AOS PCOUNT              ;ADD 1 TO PRINT COUNT
        POPJ P,
NPCHAR: CAIE X1,11              ;TAB?
        JRST NOTCTI             ;NO
        MOVE X1,PCOUNT          ;GET CURRENT PRINT POSITION
        PUSHJ P,TABDIS          ;COMPUTE NO. OF SP'S REPRESENTED
        ADDM X1,PCOUNT          ;AND ADD TO PCOUNT
        POPJ P,
NOTCTI: CAIE X1,15              ;CR?
        CAIN X1,14              ;OR FF?
        SKIPA                   ;YES
        JRST NTCRFF             ;NO
        SETZM PCOUNT            ;YES-RESET COUNTER
        POPJ P,
NTCRFF: CAIE X1,10              ;BACKSPACE?
        POPJ P,                 ;A CONTROL CHARACTER-NO CHANGE TO PRINT COUNT
        SOS PCOUNT              ;YES-SUBTRACT ONE FROM PRINTING COUNT
        POPJ P,

;ROUTINE TO CALC CHAR COUNT AND DEPOSIT IN OCNTR
DEPCNT: MOVEI X1,LINLEN
        ADD X1,NCOUNT
        MOVEM   X1,NCOUNT
        POPJ P,

;ROUTINE TO GET CHAR FROM TTY,COMMAND FILE OR INTERNAL BUFFER

GNC:    TRNE F,BUF.F    ;BUFFER FLAG?
        JRST GNC2       ;YES
        TRNE F,COMF.F   ;COM FILE?
        JRST GNC1
        INCHRW  X1
        MOVE    CH,X1
        POPJ    P,

CLSBFR: MOVE    X1,TIRADR
        SETZM   ACRING(X1)
        SETZM   %GTCHR(X1)
        SETZM   %OTCHR(X1)
        POPJ    P,
;COMMAND FILE LOGIC

GNC1:   SKIPE COMBFR            ;ALL DATA GONE?
        JRST GNCB               ;NO
        PUSHJ   P,CLSBFR        ;CLOSE BUFFER STUFF FOR TIE'S SAKE
        TRZ F,COMF.F            ;YES-CLOSE UP
        JRST GNC                ;AND GO GET A CHARACTER THE NORMAL WAY

GNCB:   ILDB CH,ICOMF+1         ;GET NEXT NON-ZERO CHARACTER
        SOS ICOMF+2             ;AND DECREMENT BUFFER COUNT
        PUSHJ P,GNCC            ;LOOK AHEAD TO NEXT NON-ZERO AND SET
                                ;COMBFR=0 IF APPROPRIATE
        CAIG    CH,^O177        ;IF KATA KANA CHAR, CHECK TO MAKE SURE WORKSPACE IS ALSO
        JRST    GNC3A           ;GOT A CHAR IN CH, CONTINUE
        SKIPN   WSFLMD          ;IS WORKSPACE KK?
        MOVEI   CH,"!"          ;NO, SO TRANSLATE CHAR TO !
        JRST    GNC3A

;ROUTINE THAT POSITIONS THE BUFFER POINTER TO PRECEDE THE NEXT
;NON-ZERO CHARACTER FROM THE COMMAND FILE. IF THERE IS NO NON-ZERO DATA
;LEFT, IT SETS COMBFR=0.
;THIS ROUTINE SHOULD BE CALLED WHEN A COMMAND FILE IS FIRST OPENED.

GNCC:   SOSGE ICOMF+2           ;DECREMENT BUFFER COUNT
        JRST GNCD               ;NO MORE CHARACTERS IN THIS BLOCK-GET NEXT
        ILDB X1,ICOMF+1         ;GET CHAR
        SKIPN X1                ;ZERO?
        JRST GNCC               ;YES-LOOP
        DEC ICOMF+1             ;NO-NOW BACK UP ONE
        AOS ICOMF+2
        POPJ P,                 ;AND RETURN

GNCD:   IN COMF,                ;INPUT THE NEXT BLOCK
        JRST GNCC               ;GOT IT-GO LOOK AT CONTENTS
        SETZM COMBFR            ;ALL GONE!
        POPJ P,                 ;SO JUST RETURN

;BUFFER FILE LOGIC

GNC2:   SKIPE BUFFR             ;ALL DATA GONE?
        JRST GNC2E              ;NO
        TRZ F,BUF.F             ;YES-CLOSE UP
        TRNN F,COMF.F           ;CLOSE TIE BUFFER STUFF IF HE'S NOT ALSO IN
        PUSHJ   P,CLSBFR        ;A COMMAND FILE
        SETZM DONZER            ;HAS TO DO WITH MRKDIC NOT GETTING CLOBBERED
        JRST GNC                ;AND GO GET A CHARACTER THE NORMAL WAY

GNC2E:  ILDB CH,BUFPT           ;PICK UP THE NEXT CHARACTER
        MOVE X1,BUFPT           ;MAKE TEMPORARY POINTER
        ILDB X2,X1              ;GET NEXT CHAR
        SKIPE X2                ;DID WE JUST PICK UP LAST CHAR OF THIS LINE?
        JRST    GNC3A           ;NO-GOT A CHARACTER IN CH, GO PROCESS IT
        AOS X1,BUFLIN           ;INCREMENT BUFLIN POINTER
        MOVE DIC,(X1)           ;GET DICTIONARY ENTRY FOR THIS LINE
        SKIPN DIC               ;EXISTS?
        JRST GNC2A              ;NO-EOF BUFFER MODE
        SETOM DONZER            ;DON'T CLOBBER MRKDIC MARK BITS
        PUSHJ P,MAKPNT          ;MAKE CHARACTER POINTER TO LINE
        JRST GNC2A              ;NO SUCH LINE-EOF BUFFER MODE
        SETZM DONZER
        PUSHJ P,PUTBCM          ;SET UP NEXT BUFFER
        SKIPN BUFCOM            ;DID WE PUUT ANYTHING IN IT?
        JRST GNC2A              ;NO-CLOSE IT UP
        JUMPE CH,GNC2E          ;IF CH IS ZERO, TRY AGAIN
        JRST GNC3A              ;AND GO PROCESS CH

GNC3A:  MOVE    X1,CH
        POPJ    P,

;ROUTINE TO SET UP THE NEXT LINE OF A BUFFER WITH THE TEXT POINTED TO BY DIC
;AND ENDING WITH AN ESC OR CR.

PUTBCM: PUSHJ P,SETBUF          ;CLEAR BUFFER AND INIT POINTER BUFPT
        MOVE X2,BUFPT

;MOVE NEXT LINE OF BUFFER INTO THE BUFFER BUFFER "BUFCOM"

GNC2C: ILDB X1,DIC
        IDPB X1,X2
        CAIE X1,33              ;FOUND AN ESC?
        JRST GNC2B              ;NO-LOOK FOR CR
        SETZ X1,                ;YES-MEANS THE END. TRANSLATE INTO A ZERO
        DPB X1,X2
        JRST GNC2D              ;ALL DONE WITH
GNC2B: CAIE X1,15
        JRST GNC2C              ;NOT CR-CONTINUE LOOP
        MOVEI X1,12
        IDPB X1,X2              ;CR GETS FOLLOWED BY LF NUL
        SETZ X1,
        IDPB X1,X2
GNC2D:  POPJ    P,

        POINT 9,BUFCOM
BUFPTR: POINT 7,BUFCOM

;TURN OFF BUFFER MODE FOR NEXT  CHARACTER (BUFFR=0)

GNC2A:  SETZM BUFFR             ;END OF BUFFER MODE FOR ANTICIPATORY TESTS
        JUMPE CH,GNC2           ;IN CASE OF NIL BUFFER LINE
        JRST GNC3A              ;CHAR IS IN CH-GO PROCESS IT

SETBUF: SETZM BUFCOM
        MOVE X1,[XWD BUFCOM,BUFCOM+1]
        BLT X1,BUFCOM+BUFLEN-1
        MOVE    X2,WSFLMD       ; LOAD BUFPT WITH CORRECT BYTE POINTER
        MOVE X1,BUFPTR(X2)
        MOVEM X1,BUFPT
        POPJ P,

ONBUFR: IMULI   X1,BUFLNS+1
        ADDI    X1,BUF0
        SOJ     X1,
        MOVEM   X1,BUFLIN
        PUSHJ   P,SETBUF
        TRO     F,BUF.F
        SETOM   BUFFR
        POPJ    P,


QUEST:  OUTSTR  QUESTN                  ;PUT OUT QUESTION-MARK
FQUEST: MOVE    X1,[42,,20]             ;SEND YELLOW BALL
        HIBER   X1,                     ;AS SO
         JFCL                           ;IGNORE ERROR RETURN..
        CLRBFI                          ;CLEAR INPUT BUFFER
        TRZE F,ONR.F
        JRST [PUSHJ P,QUEST1
                JRST GETCOM]
        ENDBUF
        JRST GETCOM
QUEST1: TRNN F,BUF.F    ;ARE WE USING BUFFER?
        POPJ P,
        MOVE X1,RINBUF
        PUSHJ P,ONBUFR          ;TURN ON THAT BUFFER
        POPJ P,
00000  
;ERROR MESSAGES
BIGCOR: ASCIZ/Out of core
/
BING: EXP 7
LONGLN: ASCIZ/Line too long
/
QUESTN: ASCIZ/?
/
BIGRNG: ASCIZ/Unable to interpret range--Too many arguments
/
CRLF: BYTE (7) 15,12,0,0,0

BUFFIL: ASCIZ/
Buffer Overflow
/
NOROOM: OUTSTR  BUFFIL
        JRST    GETCOM

; ERRORS WHICH ARE COMMAND-FATAL
%DSFAL: OUTSTR  [ASCIZ /
Can not init device DSK:
/]
        JRST GETCOM

%TMFAL: OUTSTR  [ASCIZ /
Can not open RPG TMP file
/]
        JRST GETCOM

%TTFAL: OUTSTR  [ASCIZ /
TTY: I-O error
/]
        JRST GETCOM

%TYFAL: OUTSTR  [ASCIZ /
Can not init device TTY:
/]
        JRST GETCOM

%COFAL: OUTSTR  [ASCIZ /
Can not get more core to complete command
/]
        JRST GETCOM

%RNFAL: OUTSTR  [ASCIZ /
RUN uuo failure on SYS:RPG
/]
        EXIT    1,      ;EXIT
        JRST .-1        ;STAY GONE...

%DVFAL: OUTSTR  [ASCIZ /
Can not open device
/]
        JRST GETCOM

;%IOFAL: X1 CONTAINS FILE STATUS BITS, X2=0 FOR READ, -1 FOR WRITE

%IOFAL: OUTSTR CRLF
        TRNN X1,400000          ;IOIMPM?
        JRST IODERR             ;NO
        SKIPE X2                ;READ?
        JRST IOIWRI             ;NO
        OUTSTR [ASCIZ/Input attempted from read protected file
/]
        SKIPA
IOIWRI: OUTSTR [ASCIZ/Write attempted on write protected file
/]
        OUTSTR [ASCIZ/or possible software detected failure (IOIMPM)
/]
IODERR: TRNN X1,200000          ;IODERR?
        JRST IODTER             ;NO
        OUTSTR [ASCIZ?Device I/O error (IODERR)
?]
IODTER: TRNN X1,100000          ;IODTER?
        JRST IOBKTL             ;NO
        OUTSTR [ASCIZ/Hardware data error (IODTER)
/]
IOBKTL: TRNN X1,40000           ;IOBKTL?
        JRST GETCOM             ;NO
        SKIPE X2                ;WRITE?
        OUTSTR [ASCIZ/Quota exceeded, or
/]
        OUTSTR [ASCIZ/File too large (RIB block or no room on disk)
or possible block or block number too large (IOBKTL)
/]
        JRST GETCOM

%NOTMP: OUTSTR  [ASCIZ /
Can not create TMP editing file
/]
        RESET           ;CLOSE ALL I/O DEVICES
        SETZM   JOBREN  ;NO RE-ENTER ADDRESS AFTER THIS
        HALT    %NOTMP  ;AND HALT...GIVING UP


;ROUTINE TO TYPE ERROR MESSAGE FROM FILE OPEN
;JRST WITH 'X1' CONTAINING FILE ERROR CODE
FOPERR: OUTSTR  @%ERCOD(X1)     ;TYPE CORRECT MESSAGE
        JRST    FQUEST          ;FINISH W/O ?

;ERROR MESSAGES
%EC00:  ASCIZ /File not found
/
%ECN01: ASCIZ /
File open not confirmed
/
%EC01:  ASCIZ /No such user
/
%EC02:  ASCIZ /Protection failure
/
%EC03:  ASCIZ /File busy
/
%EC06:  ASCIZ /Device I-O error
/
%EC14:  ASCIZ /Over allocation quota on device
/
%EC15:  ASCIZ /Device write-locked
/
%EC16:  ASCIZ /System has too many files open
/
%ECERR: ASCIZ /Systems error on file open
/

        EXP %ECN01
%ERCOD: EXP %EC00,%EC01,%EC02,%EC03,%ECERR,%ECERR,%EC06
        EXP %ECERR,%ECERR,%ECERR,%ECERR,%ECERR,%EC14
        EXP %EC15,%EC16,%ECERR,%ECERR,%ECERR,%ECERR,%ECERR
PRTCH:  CAIE CH,15
        CAILE CH,37
        JRST PRTCH1     ;NOT ^CHAR
        CAIN CH,12
        JRST PRTCH1
        PUSH P,CH
        MOVEI CH,46     ;&
        OUTCHR  CH
        POP P,CH
        ADDI CH,100
        OUTCHR  CH
        SUBI CH,100
        POPJ P,
PRTCH1: SKIPN   CMDPTM
        JRST    PRTC1A
        OUTCHR  CH
        POPJ P,

PRTC1A: CAILE   CH,^O200
        JRST    [ OUTCHR [ "!" ]
                  POPJ P, ]
        OUTCHR  CH
        POPJ    P,

;ROUTINE TO PRINT A CHARACTER BASED ON WHETHER THE NEXT CHARACTER INPUT
;FROM THE COMMAND SOURCE IS FROM A BUFFER OR COMMAND FILE.
;DIFFERS FROM PRTCHR IN THAT PRTCHR TESTS WHETHER THE CURRENT CHARACTER
;BEING PROCESSED CAME FROM A BUFFER OR COMMAND FILE.

PRTCH2: IFNBFR <JRST PRTCH>
        POPJ P,
;ROUTINE TO COMPUTE NUMBER OF CHARACTERS NEED TO REACH THE NEXT TABSTOP.
;IF THERE ARE NO MORE TABS IN THE TAB TABLE, THE VALUE 1 IS RETURNED.
;X1 ON ENTRY HAS THE CURRENT LINE POSITION.

TABDIS: ADDI X1,1               ;START FROM POS+1
        MOVE X2,TABES           ;GET LENGTH OF TAB TABLE
        MOVEI X3,1              ;INDEX INTO TABLE

TABNXT: MOVE X4,TABES(X3)       ;GET NEXT TABSTOP
        CAMGE X1,X4             ;TOO SMALL?
        JRST GOTTAB             ;NO, FOUND OUR TAB
        AOJ X3,                 ;INCREMENT INDEX INTO TABLE 
        CAMG X3,X2              ;ANY MORE TABSTOPS?
        JRST TABNXT             ;YES-CONTINUE
        MOVE X4,X1              ;NO-MAKE ONE UP
        ADDI X4,1               ;BY ADDING ONE

GOTTAB: SUB X4,X1               ;GET TAB DISTANCE
        MOVE X1,X4              ;AND RETURN VALUE IN X1
        POPJ P,

; ROUTINE TO BACK UP POINTER IN REF. IN 40 1 BYTE
DEC:    PUSH    P,X2
        LDB     X1,DECSIZ
        LDB     X2,DECDPL
        ADD     X2,X1           ;add size to displacement to get new displ
        CAIGE   X2,^D36
        JRST    DEC1
        MOVE    X2,X1
        MOVEI   X1,^D36         ;byte is in previous word
        IDIV    X1,X2
        SOS     @JOBUUO
DEC1:   DPB     X2,DECDPL
        POP     P,X2
        POPJ    P,

DECSIZ: POINT   6,@JOBUUO,11
DECDPL: POINT   6,@JOBUUO,5



;ROUTINE TO SWITCH POINTERS OF NEWLIN AND OLDLINE

SWITCH: MOVE X1,NEWPNT
        EXCH X1,OLDPNT
        MOVEM X1,NEWPNT
        HRLZI   4,OLDBCB
        BLT     4,4
        HRLI    5,NEWBCB
        HRRI    5,OLDBCB
        BLT     5,OLDBCB+BCBPNT
        HRRZI   5,NEWBCB
        BLT     5,NEWBCB+BCBMAX
        SETZM   NEWBCB+BCBPNT
        SETZM   NEWBCB+BCBMIN
        POPJ P,
;COMMAND DECODER ROUTINE

DECODE: MOVE NEW,NEWPNT
        SETZM COMW.F            ;WE ARE NO LONGER IN COMMAND WAIT MODE
        TLZ F,777777
        PUSHJ P,SETSRC  ;SETUP SEARCH LIST      FOR ADDRESSES
        PUSHJ P,FNDCOM  ;FIND THE COMMAND
        PUSHJ P,TSTCOM  ;SEE IF COMMAND HAS RIGHT NO OF ARGS
        PUSHJ P,ADRCAL  ;NOW CALC ADR IF COMMAND OK
        LDB CH,NEW
        HLL CH,.CTTAB(CH)
        JRST    @COMAN  ;AWAY WE GO

;ROUTINE TO GET CHAR AND FLAGS WITH POINTER CONTAINED IN NEW
;GETCH IMPLIES TO IGNOR BLANKS

GETCH:  TLO F,IGNOR
GETCHR: ILDB CH,NEW
        HLL CH,.CTTAB(CH)
        TLNN F,IGNOR    ;IGNOR BLANKS?
        POPJ P, ;NO
        PUSHJ   P,ISITSP      ;IS IT A SPACE?
         JRST   [TLZ F,IGNOR    ;NO
                 POPJ P,]
        JRST    GETCHR          ;YES, skip over and get next char


;ROUTINE TO TEST IF THE CHARACTER IN CH IS AN ASCII OR KATA KANA SPACE.
;SKIP RETURNS IF IT IS.

ISITSP: HRRZ    R0,CH           ;remove character flags
        CAIE    R0," "+KK.OFF   ;Kata Kana Space?
        CAIN    R0," "
        JRST    CPOPJ1          ;a Space, skip return
        POPJ    P,
;ROUTINE TO SETUP SRCH LST FOR ADRES RANGE
;THE FOLLOWING CODES ARE USED IN BITS 14-17 OF EACH WORD IN THE SEARCH LST
;
;0-END OF SEARCH LST
;1-AT THIS LOC-INCREM TOADD TO DICT 
;2-SEARCH FOR LABEL
;3-SEARCH FOR TEXT
;4-ADD THIS INCREMENT
;5-SUBTRACT THIS INCREM
;6-BEGIN SEARCH 2(END RANGE)
;7-SEARCH FOR TAG BUT IGNORE PRECEEDEING BLANKS
;10- USE VALUE OF CALCULATED CURRNET LINE
;11-BUFFER NO.
;12-MARK NO.

ACPNT:  POINT 4,SRCLST(LINE),17 ;POINTER AS DESCR ABOVE

SETSRC: SETOM FLRNG     ;USE FLRNG AS COUNTER -1= NOTHING BEFORE
        ;0=1 ADRS BEF
        ;>=1 MEASN MORE THAN 1 ADRES
        SETZM SRCLST
        MOVE 0,[XWD SRCLST,SRCLST+1]
        BLT 0,ENDSRC
        SETZ LINE,      ;LINE USED AS COUNTER INTO SRCLST
ATOM:   PUSHJ P,GETCH   ;GET CHAR IGNOR BLANKS
        CAMN CH,.CTTAB+"@"
        JRST AT

ATOM1:  TLNE CH,NUM.F   ;NUMBER?
        PUSHJ P,ATOM1A  ;YES
ATOMN:  TLNE CH,DEL.F   ;DELIM?
        JRST TAGTEX     ;YES
        CAMN CH,.CTTAB+"."      ; .?
        JRST CURRT      ;YES
        CAMN CH,.CTTAB+"$" ; $?
        JRST LAST       ;YES
        CAMN CH,.CTTAB+","; ,?
        JRST COMA       ;YES
ATOMED: CAMN CH,.CTTAB+";" ; ;?
        PUSHJ P,SEMI    ;YES
        TLNN CH,LET.F!ACT.F     ;BEGIN OF COMMAND?
        JRST QUEST      ;BAD 
        TLZE F,FIRST    ;FIRST ON?
        JRST [TRZ F,COMMA
        AOS FLRNG
        POPJ P,]
        TRZE F,COMMA    ;(FIRST OFF) IS COMMA ON?
        JRST QUEST      ;YES BAD
        POPJ P,

;ROUTINE TO INTERP. NUMBER
ATOM1A: PUSHJ P,MAKOCT ;MAKE NUMBER
        HRRZM NUM,SRCLST(LINE) ;DEPOSIT
        MOVEI X2,1      ;CODE
        PUSHJ P,DEPSR1  ;DEPOSIT
        TLO F,FIRST     ;TURN ON FLAG TO INDICAT PAST FIRST ATOM
        POPJ P,

;ROUTINE TO MAKE OCTAL NO AND PUT IN AC CALLED NUM.
;LOADS CH WITH NEXT NON-BLANK CHARACTER IN LINE.

MAKOCT: SETZ NUM,
MAK1:   TLNN CH,NUM.F   ;Number?
        JRST MAK2       ;NO
        HRRZ CH,CH
        SUBI CH,^O60
        IMULI NUM,^D10
        ADD NUM,CH
        PUSHJ P,GETCHR  ;DONT IGNOR BLANKS
        JRST MAK1
MAK2:   PUSHJ   P,ISITSP                ;a space?
        POPJ    P,              ;no
        PUSHJ   P,GETCH
        POPJ    P,
        PUSHJ P,GETCH   ;GET NEXT NON BLANK
        POPJ P,

;ROUTINE TO SETUP POINTER FOR TAG OR TEXT SEARCH

TAGTEX: TLNE CH,TEX.F   ;TEXT DELIMETER
        JRST TEX1       ;YES
        CAMN CH,.CTTAB+74  ; <?
        JRST TAG3       ;YES
        MOVEI X2,2
        JRST FINDA      ;GO FIND END OF STRING
TAG3: MOVE CH,.CTTAB+76  ; > (END OF STRING DELIM)
        MOVEI X2,7      ;CODE TO IGNORE PREC BLANKS
        JRST FINDA
TEX1: MOVEI X2,3        ;CODE FOR TEXT
        CAME CH,.CTTAB+133       ; [?
        JRST FINDA      ;NO
        MOVE CH,.CTTAB+135       ;]
FINDA:  MOVEM CH,DELIM
        PUSHJ P,DEPSRC  ;DEPOSIT POINTER AND CODE
FIND1:  PUSHJ P,GETCHR
        CAMN CH,.CTTAB  ;NULL?
        JRST QUEST      ;YES DIDNT FIND END OF STRING
        CAME CH,DELIM   ;SAME DELIM?
        JRST FIND1      ;NO
        JRST ADDATM     ;GO SEE IF HAS + OR - ATTACHED

;CODE FOR       USE OF .
CURRT:  TLNE F,FIRST    ;IS THIS A DOT AFTER A NUMBER OR SUMTHIN?
        JRST QUEST      ;VOUS ETES UNE JERK
                MOVEI X2,10
        PUSHJ P,DEPSR1
        JRST ADDATM

; CODE FOR $
LAST:   SKIPE EOF
        PUSHJ P,FINUP   ;TOO BAD POOPSIE
                MOVE X3,LASLIN
        SUBI X3,DICT
        HRRZM X3,SRCLST(LINE)
        MOVEI X2,1
        PUSHJ P,DEPSR1
        JRST ADDATM

;CODE FOR ,
COMA: TLZN F,FIRST      ;       DO WE HAVE COMPLETE NUMBER BEFORE?
        JRST QUEST      ;NO
        TROE F,COMMA    ;FIRST COMMA?(WAS FLAG ON)
        JRST QUEST      ;NOT FIRST,COMMA WAS ON
        AOS FLRNG
        MOVEI X2,6      ;BEGIN SRCH 2
        PUSHJ P,DEPSR1
        PUSHJ P,GETCH
        JRST ATOM1


;CODE FOR @-MARK LIST
AT:     PUSHJ P, GETCH
        TLNN CH,NUM.F
        JRST QUEST
        PUSHJ P,MAKOCT
        CAIL NUM,1
        CAILE NUM,2
        JRST QUEST
        HRRZM NUM,SRCLST(LINE)
        MOVEI X2,12
        PUSHJ P,DEPSR1
        AOS FLRNG
        TRO F,MARK.F
        SETZM POLISH
        SETZM ENDCM
        JRST ADDATM+1

;CODE FOR ; -IMPLIES NUMBER TO FOLLOW(BUFFER)
SEMI:   PUSHJ P,GETCH
        TLNN CH,NUM.F   ;NUMB?
        JRST QUEST      ;NO
        PUSHJ P, MAKOCT 
        HRRZM NUM,SRCLST(LINE)
        MOVEI X2,11     ;CODE FOR BUFFER
        PUSHJ P,DEPSR1
        AOS FLRNG
        POPJ P, ;GO GET COMMAND

;ROUTINE TO FIND + OR - AFTER ATOM

ADDATM: PUSHJ P,GETCH
        CAMN CH,.CTTAB+"+" ; +?
        JRST [MOVEI X2,4
        JRST ADD1]      ;YES ADD
        TLNE CH,NUM.F   ;NUMB?
        JRST    [MOVEI X2,4
        JRST ADD2       ]       ;YES DAT' S OK
        CAME CH,.CTTAB+"-" ; -?
        JRST TAGT1      ;NO NOT EITHER CONTINUE ON
        MOVEI X2,5
ADD1: PUSHJ P,GETCH     ;GET NUMBER HOPEFULLY TO FOLLOW
        TLNN CH,NUM.F   ;NO?
        JRST QUEST      ;NOPE
ADD2: PUSHJ P,MAKOCT
        HRRZM NUM,SRCLST(LINE)
        PUSHJ P,DEPSR1
TAGT1:  TRNE F,MARK.F
        JRST ATOMED
        TLO F,FIRST
        JRST ATOMN      ;OVER AGAIN
;ROUTINE TO GET CODING INTO SRCLST
DEPSRC: MOVEM NEW,SRCLST(LINE)
DEPSR1: DPB X2,ACPNT
        AOJ LINE,
        CAIGE LINE,ENDSRC
        POPJ P,
        OUTSTR   BIGRNG
        JRST GETCOM

WRDPNT: POINT 7,WORD
;ROUTINE TO FIND OUT WHICH COMMAND IS DESIRED

FNDCOM: SETZM WORD
        SETZM WORD+1
        MOVE X1,WRDPNT
        MOVEI X2,1
        PUSHJ P,BOOLUP  ;CONVERT TO UPPER CASE
        IDPB CH,X1      ;START BUILDING COMMAND IN WORD SPACE
LET1:   PUSHJ P,GETCHR
        TLNN CH,LET.F           ;LETTER
        JRST COMPAR
        PUSHJ   P,BOOLUP
        IDPB CH,X1
        CAIG X2,12      ;TOO MANY LETTERS
        AOJA X2,LET1    ;DO AGAIN
        JRST QUEST


COMPAR: PUSHJ   P,ISITSP        ;a space?
        SKIPA                   ;no
        PUSHJ P,GETCH   ;GET FIRST NONBLANK CHAR
        SETZ NUM,
COMP1:  MOVE X1,WRDPNT
        HRRI X2,CMDLST(NUM)
        HLL X2,WRDPNT
COMP10: ILDB X3,X1
        ILDB X4,X2
        SKIPN X4
        JRST COMP4      ;CHANGE POINTER
        CAMN X4,X3
        JRST COMP10     ;KEEP COMPARING
COMPA5: CAIL NUM,CMDEND ;DID WE COMPARE LAST ONE
        JRST QUEST      ;YUP    TOO BAD
        AOJA NUM,COMP1
COMP4:  HLL X2,WRDPNT
        HRR X2,CMDADR(NUM)      ;GET REST OF COMMAND
COMP4A: ILDB X4,X2      
        SKIPN X3        ;END OF COMMAND?
        JRST COMP3      ;YES
        SKIPN X4        ;IF BLANK U IN TROBS
        JRST COMPA5
        CAME X4,X3      ;SHOULD BE SAME
        JRST COMPA5
        ILDB X3,X1
        JRST COMP4A     ;
COMP3:  HLRZ X2,CMDADR(NUM)     ;GET ADRES
        TRZ X2,777000   ;CLEAR FLAGS
        ADD X2,CMDADR(NUM)      ;ADD ADRES
        HRRZM X2,COMAN
        POPJ P,


TSTCOM: HLRZ X2,CMDADR(NUM)     ;GET FLAGS
        TRNN F,MARK.F   ;MARK ADR?
        JRST TSTCO1     ;NO
        TRNN X2,MRK     ;ALOWED?
        JRST QUEST
        POPJ P,
TSTCO1: TRNN X2,NAB     ;NOTHING ALLOWED FLAG ON?
        JRST COMP5      ;NO
        SKIPL FLRNG
        JRST QUEST
        JRST COMP7
COMP5:  TRNN X2,ONE     ;ONLY AND MUST ONE FLAG ON?
        JRST COMP5A     ;NO
        SKIPE FLRNG
        JRST QUEST
        JRST COMP7
COMP5A: TRNN X2,ONORN   ;ONE OR NOTHING ALLOWED
        JRST COMP6      ;NOO
        SKIPLE FLRNG
        JRST QUEST
        JRST COMP7
COMP6:  TRNN X2,MHSB    ;MUST HAVE SOM BEFOR?
        JRST COMP7      ;NO
        SKIPGE FLRNG
        JRST QUEST
COMP7:  TRNN X2,AFTER   ;MUST HAVE SOM AFTER?
        JRST COMP8      ;NO
        CAME CH,UPFLG   ; ^ ?
        TLNE CH,TERM.F  ; TERMINAT?
        JRST QUEST      ;YES BAD
        POPJ P,
COMP8:  TRNN X2,NOAFT   ;NOTHING ALLOW AFTER
        POPJ P, ;NO
        CAME    CH,UPFLG
        TLNE CH,TERM.F  ;TERM?
        POPJ P, ;YES GOOD
        JRST QUEST      ;BAD
;ROUTINE TO EVALUATE SRCLST- AND SETUP RANGES FLRNG AND CERNG
;WILL ALSO CALC BUFFER NO IF INDICATED
;CURTMP IS CURRENT TEMPORY LINE BEING CALCULATED
;TMPLIN USED FOR CALC AND IS ZEROED AFTER BEING DEPOSITED

ADRCAL: SKIPL CURLIN
        JRST ADRCA1
        SKIPE EOF
        JRST ADRCA1
        MOVE X1,LASLIN
        MOVEM X1,CURLIN
        JRST ADRCA2
ADRCA1: MOVE X1,CURLIN ;GET WHERE WE'RE AT-BEGIN OF SEARCH
        SKIPN X1
        MOVEI X1,DICT+1
ADRCA2: MOVEM X1,CURTMP
        MOVEM X1,STSER  ;START SEARCH
        SETO LINE,
        SETZM TMPLIN
        SETZM FLRNG
        SETZM CERNG
        SETZM BUFNO
        SETZM MODMAR

ADRC1:  AOJ LINE,
        LDB X1,ACPNT    ;GET CODE AS DESC BEFORE SSETSRC
        JRST .+1(X1)
        JRST ENCAL      ;END OF CALC
        JRST USENO      ;USE LINE NO.
        JRST SERLAB     ;SERCH FOR LABEL
        JRST SERTEX     ;SERCH FOR TEXT
        JRST ADDINC     ;ADD INCREMENT
        JRST SUBINC     ;SUBTRACT INCREM
        JRST SECSER     ;START SECOND SERCH
        JRST SERTAG     ;SERCH FOR TAG
        JRST USE.       ;USE CURRENT POINTER
        JRST BNO        ;GET BUFFER NO.
        JRST MNO.       ;GET MARK NO.

USENO:  HRRZ X1,SRCLST(LINE)    ;GET NUMBER
        ADDI X1,DICT    ;GET ADDRES
        PUSHJ P,ADDIN1
        CAMLE X1,LASLIN
        JRST CHKLO
        HRRM X1,STSER
        HRRM X1,TMPLIN
        JRST ADRC1

CHKLO:  CAIG X1,DICT+11
        CAIGE X1,DICT
        JRST QUEST
        SKIPE SRCLST+1(LINE)
        JRST QUEST
        MOVE X2,COMAN
        CAIE X2,LOAD+1
        CAIN X2,BUFFER+2
        JRST CHKLO1
        CAIE X2,KILL+1
        JRST QUEST
CHKLO1:        HRRZM X1,TMPLIN
        JRST ENCAL

ADDINC: TRNE F,MARK.F
        JRST ADDIC1
         HRRZ X1,SRCLST(LINE)
        ADD X1,TMPLIN
        PUSHJ P,ADDIN1
        CAMLE X1,LASLIN
        JRST QUEST
        MOVEM X1,TMPLIN
        MOVEM X1,STSER
        JRST ADRC1

ADDIC1: HRLZI X1,271400         ;RANGE OF THE FORM: @i+n
        HRR X1,SRCLST(LINE)     ;MAKE INSTR: ADDI LINE,n
        MOVEM X1,MODMAR
        JRST ADRC1



ADDIN1: PUSH P,LINE
ADDINB: SKIPN EOF
        JRST ADDIN2
        CAMGE X1,LASLIN
        JRST ADDIN2
        PUSH P,X1               ;SAVE X1
        PUSHJ P,INLINE
        POP P,X1                ;RESTORE X1
        JRST ADDINB
ADDIN2: POP P,LINE
        POPJ    P,

SUBINC: TRNE F,MARK.F
        JRST[ HRLZI X1,275400
                JRST ADDIC1+1]
         HRRZ X1,TMPLIN
        HRRZ X2,SRCLST(LINE)
        SUB X1,X2
        CAIGE X1,DICT+1
        JRST QUEST
        HRRM X1,TMPLIN
        HRRM X1,STSER
        JRST ADRC1

SECSER: MOVE X1,TMPLIN
        MOVEM X1,FLRNG
        SETZM TMPLIN
        JRST ADRC1

BNO: MOVE X1,TMPLIN
        SKIPE FLRNG ;FLLOOR CALC?
        JRST BNO1       ;YES
        MOVEM X1,FLRNG
        JRST BNO2
BNO1: SKIPN CERNG       ;CEILING CALC?
        MOVEM X1,CERNG  ;NO
BNO2: HRRZ X1,SRCLST(LINE)
        CAIL X1,0
        CAILE X1,11
        JRST QUEST
        SKIPN X1
        SETO X1,
        MOVEM X1,BUFNO
        SETZM TMPLIN
        POPJ P, ;ALL DONE


MNO.:   HRRZ X1,SRCLST(LINE)
        MOVEM X1,MARKNO
        SETZM TMPLIN
        JRST ADRC1

ENCAL:  SKIPN TMPLIN    ;HAVE WE DEPOSITED ALL CALC?
        POPJ P, ;YES
        MOVE X1,TMPLIN
        SKIPE FLRNG
        JRST ENCAL1
        MOVEM X1,FLRNG
        POPJ P,
ENCAL1: SKIPE CERNG
        JRST ENCAL2
        MOVEM X1,CERNG
        POPJ P,
ENCAL2: SKIPN BUFNO
        MOVEM X1,BUFNO
        POPJ P,

USE.:   SKIPG CURTMP
        JRST [PUSHJ P,FINUP
                MOVE X1,LASLIN
                MOVEM X1,CURTMP
                MOVEM X1,STSER
                JRST USE1]
        MOVE X1,CURTMP
        CAML X1,LASLIN
        PUSHJ P,ADDIN1
        CAMLE X1,LASLIN
        JRST QUEST
USE1:   MOVEM X1,TMPLIN
        JRST ADRC1

SERTAG: TLO F,TAG.F
SERLAB: MOVE SERCH,SRCLST(LINE) ;GET POINTER
        TLZ SERCH,17    ;TURN OFF INDEX FIELD (CODE FIELD FOR US)
        MOVEM SERCH,SSER        ;SAV SERCH
        LDB CH,SERCH    ;GET DELIM
        CAIN CH,"<"
        MOVEI CH,">"
        MOVEM CH,DELIM
        PUSH P,LINE ;SAVE LINE
        HRRE LINE,STSER
        SKIPG LINE
        MOVE LINE,LASLIN
        CAIG LINE,DICT
        JRST QUEST
        MOVEM LINE,LINFND
        MOVEM LINE,ENDSER
        ILDB CH,SERCH   ;GET NEXT CHAR AFTER DELIM
        CAMN CH,DELIM   ;SAME?
        TLO F,CRORBL    ;YES SO LOOK FOR CR OR BLANK LEADING LINE
SERLA1: MOVE LINE,LINFND
        AOJ LINE,       ;GET NEXT LINE
        CAMLE LINE,LASLIN
        MOVEI LINE,DICT+1
        MOVEM LINE,LINFND
        MOVE DIC,(LINE)
        PUSHJ P,MAKPNT
        JRST SERLA0 ; DIC=0
        ILDB X1,DIC     ;get very first char in text line
        CAIE X1,^O14    ;is it a form feed (^L)?
        JRST SERLA6     ;no,continue
        CAIE CH,^O14    ;is search-string char also form feed?
        ILDB X1,DIC     ;no, so ignore the form feed in the line
        JRST SERLA6     ;yes, so go match normally
SERLA:  ILDB X1,DIC     ;get next char from text line
SERLA6: TLNE F,CRORBL   ;SHOULD WE TEST FOR CROR BLANK?
        JRST SERLA2     ;YES
        TLNN F,TAG.F    ;ARE WE SEARCH FRO TAG?
        JRST SERLA4     ;NO
        CAIE X1,11      ;TAB
        CAIN X1," "     ;BLANK?
        JRST SERLA      ;YES GET NEXT
        CAIN    X1," "+KK.OFF
        JRST    SERLA           ;KK SPACE
SERLA4: CAIN CH,177
        JRST [CAIN X1,15
                JRST SERLA0
                JRST SERLA7]
        CAME CH,X1      ;SAME
        JRST SERLA0     ;NO 
        CAIE CH,15
        JRST SERLA7
        ILDB CH,SERCH   ;GET NEXT
        CAMN CH,DELIM   ;END?
        JRST SERLA5     ;HURRAHHHHHH
SERLA9: CAML LINE,LASLIN
        JRST [SKIPN EOF
                JRST SERLA0
                PUSHJ P,ADDIN3
                JRST SERLA9]
        AOJ LINE,
        MOVE DIC,(LINE)
        PUSHJ P,MAKPNT
        JRST SERLA0 ;DIC=0
        JRST SERLA8
SERLA7: ILDB CH,SERCH   ;YES GET NEXT
        CAMN CH,DELIM   ;DELIM?
        JRST SERLA5     ;YES SUCCESS
SERLA8: ILDB X1,DIC     ;GET NEXT FILE GUY
        JRST SERLA4     ;COMPARE SOME MORE

SERLA0: MOVE LINE,LINFND
                CAMN LINE,ENDSER
        JRST [SKIPE EOF
                JRST SERLAA
                JRST QUEST]
SERLAA: MOVE SERCH,SSER ;GET POINTER
        ILDB CH,SERCH   ;GET FIRST CHAR
        JRST SERLA1+1

SERLA2: CAIN X1," "
        JRST SERLA3
        CAIE X1,11
        CAIN    X1," "+KK.OFF   ;KK SPACE?
        JRST SERLA3     ;YEAH!!!!
        JRST SERLA1     ;BOOOOOOO
SERLA5: CAIN CH,"!"
        JRST SERLA3     ;DON7T CHECKK FOR CR OR BLK
        ILDB X1,DIC
        CAIE X1," "
        CAIN X1,15
        JRST SERLA3
        CAIE    X1," "+KK.OFF           ;KK SPACE?
        CAIN X1,11
        JRST SERLA3
        TLNE F,TAG.F
        JRST SERLA0     ;BAD
        SKIPE COLON
        CAIE X1,":"
        JRST SERLA0
SERLA3: MOVE LINE,LINFND
        MOVEM LINE,STSER
                MOVEM LINE, CURTMP
        MOVEM LINE,TMPLIN
        POP P,LINE      ;RESTORE LINE
        TLZ F,CRORBL+TAG.F
        JRST ADRC1

SERTEX: MOVE SERCH,SRCLST(LINE)
        TLZ SERCH,17
        MOVEM SERCH,SSER
        PUSH P,LINE
        HRRE LINE,STSER
        SKIPG LINE
        MOVE LINE,LASLIN
        CAIG LINE,DICT
        JRST QUEST
        MOVEM LINE ,ENDSER
        MOVEM LINE,LINFND
        LDB CH,SERCH    ;GET DELIM
        CAIN CH,"["
        MOVEI CH,"]"
        MOVEM CH,DELIM

        JRST SERTE0
SERTE5: MOVE LINE ,LINFND
        CAMN LINE,ENDSER
        JRST [SKIPE EOF
                JRST SERTE0
                JRST QUEST]
SERTE0: MOVE SERCH,SSER
        AOJ LINE,
        CAMLE LINE,LASLIN
        MOVEI LINE ,DICT+1
        MOVEM LINE,LINFND
        MOVE DIC,(LINE)
        PUSHJ P,MAKPNT

        JRST SERTE5 ;DIC =0
        MOVEM DIC,BEGSER
        TLZ F,FIRST     ;HAVE NOT FOUND FIRST MATCH
SERTE3: ILDB CH,SERCH
        CAMN CH,DELIM
        JRST SERTE1     ;SUCCESS!
SERTE2: ILDB X1,DIC
        CAIN CH,177
        JRST [CAIN X1,15
                JRST SERTE5
                JRST SERTE3]
        CAME CH,X1
        JRST [CAIE X1,15
        JRST SERTE4
        JRST SERTE5]
        CAIE X1,15
        JRST SERTE6
        ILDB CH,SERCH   ;NEXT
        CAMN CH,DELIM
        JRST SERTE1     ;SUCCESS
SERTE8: CAML LINE,LASLIN
        JRST [SKIPN EOF
                JRST SERTE5
                PUSHJ P,ADDIN3
                JRST SERTE8]
        AOJ LINE,
        MOVE DIC,(LINE)
        PUSHJ P,MAKPNT
        JRST SERTE5 ;DIC=0
        JRST SERTE2
SERTE6: TLOE F,FIRST
        JRST SERTE3
                MOVEM DIC,BEGSER
        DEC BEGSER
        JRST SERTE3
SERTE4: IBP BEGSER
        CAME LINE,LINFND
        JRST    SERTE5
        MOVE DIC,BEGSER
        MOVE SERCH,SSER
        TLZ F,FIRST
        JRST SERTE3


SERTE1: MOVE LINE,LINFND
        MOVEM LINE,STSER
                MOVEM LINE, CURTMP
        MOVEM   LINE,TMPLIN
        POP P,LINE
        TLZ F,FIRST
        JRST ADRC1
; ^ COMMAND- PRINT PREV LINE ON TERMINAL
UPCOM:  SKIPL CURLIN
        JRST UPCOM2
        PUSHJ P,FINUP
        MOVE X1,LASLIN
        SOJ X1,
        MOVEM X1,CURLIN
        JRST LINEFD+1

UPCOM2: SOS X1,CURLIN
        CAIL X1,DICT            ;VALID?
        JRST LINEFD+1           ;YES
        MOVEI X1,DICT           ;NO
        MOVEM X1,CURLIN         ;REPLACE BY LINE 0
        JRST LINEFD+1
; SLASH COMMAND
; FORMAT R/

FNDSL: MOVEI X1,FNDPR
        MOVEM X1,COMAN
        POPJ P,

        JRST FNDSL
SLCOM:  SETOM   COMW.F          ;FOR ESC, STILL IN CMD MODE
        SKIPE FLRNG             ;NO RANGE?
        JRST .+4
        MOVE X1,LASLIN
        CAIN X1,DICT
        JRST GETCOM             ;NO LINES TO PRINT
        PUSHJ P,CKRNG           ;SET FLRNG,CERNG
        TRNE F,MARK.F
        JRST [  PUSHJ P,FNDSL   ;@
        JRST MARKST]
        MOVE LINE,FLRNG
        CAIN LINE ,DICT
        JRST QUEST
SLCOM2: MOVE DIC,(LINE)
        SKIPN DIC
        JRST SLCOM5
        PUSHJ P,MAKPN1
        JRST SLCOM5 ;DIC=0
        SETOM NOTPRN            ;NOT PRINT/PAGE COMMAND
        MOVEI X1,BUFFRD         ;REQUEST BUFFERED OUTPUT
        PUSHJ P,PRLINE          ;AND PRINT THE LINE
        SKIPN DONCHG
        MOVEM LINE,CURLIN       ;CHANGE DOT
        AOJ LINE,       ;GET NEXT LINE
        CAMG LINE,CERNG ;DONE
        JRST SLCOM2     ;NO
SLCOM5: SKIPLE OTTY+2   ;ANYMORE CHAR
        PUSHJ P,PRTTE1  ;YES
        JRST GETCOM
;ROUTINES TO INIT THE TTY
;INITTY SETS THE STATUS AS:
;       1. BREAK ON PUNCTUATION
;       2. LINE MODE INPUT
;       3. WE HANDLE ^A AND ^Q
INITTY: HRROI   X1,56           ; READ THE TERMINAL TYPE
        SETOM   X2
        AUXCAL  X1,X2
        SETZM   CMDPTM          ; AND FROM IT DETERMINE THE COMMAND PORT MODE
        CAIE    X2,2            ; 2 MEANS EXTENDED ASCII (KATA KANA)
CAIN X2,17 ; TEMPORARY KLUDGE UNTILL THE NETWORK GETS TTY TYPE STRAIGHT
        SETOM   CMDPTM

        MOVEI X1,1101           ;BREAK ON PUNCTUATION,HANDLE ^A AND ^Q, LINE MODE
        SKIPE   CMDPTM          ; is the terminal Kata Kana?
        MOVEI   X1,1102         ; yes, change to 1102
        MOVEM X1,TTYBLK         ;MOVE INTO OPEN BLOCK
        OPEN TTY,TTYBLK
        JRST    %TYFAL
        MOVEI   X1,TTYBUF       ;TTY BUFFER ADDRESS
        EXCH    X1,JOBFF        ;FOR BUFFER SET-UP
        OUTBUF  TTY,1           ;1 TTY BUFFER
        MOVEM   X1,JOBFF
        SKPINC                  ;THIS CAUSES OUTPUT SUSPENDED
        JFCL                    ;BY ^O OR ^\ TO BE REVOKED
        POPJ P,

ONECHO: HRROI   X1,-31          ;GET CURRENT BITS
        GETTAB  X1,             ;GETMOD
         JFCL
        TRZ X1,ST.NEC           ;RESET ECHO
        SETMOD  X1,             ;AND SET
        POPJ P,

;TURN OFF ECHO

SILENC: HRROI   X1,-31          ;GETMOD
        GETTAB  X1,
         JFCL
        TRO     X1,ST.NEC       ;TURN OFF ECHO
        SETMOD  X1,
        POPJ    P,
;PRTTEX IS ROUTINE TO PRINT TEXT OUT ON TTY
PRTTEX: PUSH    P,CH
        SKIPE   CMDPTM          ; can the command port handle kata kana?
        JRST    PRTTE0          ;  yes, leave CH alone
        CAILE   CH,^O200        ;  no, convert kata kana chars
        MOVEI   CH,"!"          ;  to bangs

PRTTE0: SOSG    OTTY+2
        PUSHJ P,PRTTE1
        IDPB CH,OTTY+1
        POP     P,CH
        POPJ P,

PRTTE1: OUT TTY,
        POPJ    P,
        JRST %TTFAL


PRTMES: PUSH P,CH
        PUSH P,X1
        HRLI X1,440700
        HRR X1,40
PRMS2:  ILDB CH,X1
        SKIPN CH
        JRST PRMS1
        PUSHJ P,PRTTEX
        JRST PRMS2
PRMS1:  POP P,X1
        POP P,CH
        POPJ P,

PRTVAL: PUSH P,CH
        HRRZ CH,40
        HRR CH,(CH)
        PUSHJ P,PRTTEX
        POP P, CH
        POPJ P,
;ROUTINE TO SEE IF FLRNG AND CERNG CALCULATED

CKRNG:  SKIPE FLRNG             ;LOWER BOUNDARY ALREADY SET?
        JRST CKRNG1             ;YES
        MOVEI X1,DICT+1
        MOVEM X1,FLRNG          ;SET LOWER DEFAULT BOUNDARY
        SKIPE EOF               ;END OF INPUT FILE?
        SKIPA X1,BIGNO          ;NOT YET - SET DEFAULT UPPER BOUND
        MOVE X1,LASLIN          ;WE KNOW UPPER BOUND
        MOVEM X1,CERNG
        SETOM DONCHG    ;DON7T CHANGE CURLIN
        JRST CKRNG2
CKRNG1: SKIPE CERNG             ;UPPER BOUND ALREADY SET?
        JRST CKRNG2             ;YES
        MOVE X1,FLRNG
        MOVEM X1,CERNG
CKRNG2: MOVE X1,FLRNG
        MOVE X2,CERNG
        CAMLE X1,X2
        JRST QUEST
        CAME X2,BIGNO
        CAMG X2,LASLIN
        CAIGE X1,DICT+1
        JRST QUEST
        POPJ P,
;EQUAL COMMAND
;PRINTS LINE NO OF LINE ADRESSED IN FLRNG

FNDEQ:  IFNBFR <OUTSTR  CRLF
        OUTSTR  FPRINT>         ;PRINT?
        SETZM FNEQPR            ;RESET SWITCH TO PRINT LINES FOUND
        PUSHJ P,YORN
        SKIPA                   ;NO
        SETOM FNEQPR            ;YES, PRINT
        MOVEI X1,FNDEQ1         ;COMMAND DISPATCH ADDRESS
        MOVEM X1,COMAN          ;YES
        POPJ P,

FNDEQ1: PUSH P,FLRNG            ;PRINT
        MOVEM LINE,FLRNG
        PUSHJ P,EQCOM1
        SKIPE FNEQPR            ;PRINT ONLY IF FNEQPR IS TRUE
        PUSHJ P,FNDPR
        POP P,FLRNG
        POPJ P,

        JRST FNDEQ
EQCOM: TRNE F,MARK.F
        JRST [SETZM FLRNG
        PUSHJ P,CKRNG
        PUSHJ P,FNDEQ
                SETOM GIVCNT
        JRST MARKST]
EQCOM1: MOVE X1,FLRNG
        CAILE X1,DICT
        CAMLE X1,LASLIN
        JRST QUEST
        SUBI    X1,DICT
        PUSHJ P,PRTNUM
        OUTSTR   CRLF
        TRNE F,FND.F!MARK.F
        POPJ P,
        JRST CARRET
; CAR RET.-SET CURRENT LINE TO THAT ADR IN FLRNG

FNDCAR: IFNBFR <OUTSTR  FPRINT>
        PUSHJ P,YORN
        JRST [MOVEI X1,POP
              MOVEM X1,COMAN
              POPJ P,]
        MOVEI X1,FNDPR
        MOVEM X1,COMAN
        POPJ P,

POP:    POPJ P,
FPRINT: ASCIZ/Print? /

FNDPR: MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        POPJ P, ;DIC=0
        SETOM NOTPRN            ;NOT PRINT COMMAND
        MOVEI X1,DIROUT         ;REQUEST DIRECT OUTPUT
        PUSHJ P,PRLINE          ;PRINT THE LINE
        POPJ P,

        JRST FNDCAR
CARRET: MOVE DIC,FLRNG
        SKIPN DIC
        JRST GETCOM
        CAILE DIC,DICT
        CAMLE DIC,LASLIN
        JRST QUEST
        MOVEM DIC,CURLIN
        JRST GETCOM


; LF COMMAND- PRINT NEXT LINE ON TERMINAL

LINEFD: AOS CURLIN
        MOVE X1,CURLIN
        CAML X1,LASLIN          ;IS CURRENT LINE IN DICTIONARY?
        PUSHJ P,ADDIN1          ;NO-GET CURRENT LINE
        SKIPE DIC,CURLIN
        CAMLE DIC,LASLIN
        JRST [SOS CURLIN
        JRST QUEST]
        CAIN DIC,DICT   ;LINE 0?
        JRST [AOS CURLIN
        JRST QUEST]
        MOVEM DIC,FLRNG
        MOVEM DIC,CERNG ;SETUP FOR SLASH
        JRST SLCOM
; _ COMMAND- PRINTS LINE LABEL OF ADRESS GIVEN OR CLOSEST LINE PRECEEDING
;FORMAT- A_

FNDBK: MOVEI X1,FNDBK2
        IFNBFR <OUTSTR  FPRINT>
        PUSHJ P,YORN
        MOVEI X1,FNDBK1
        MOVEM X1,COMAN
        POPJ P,

FNDBK2: PUSH P,LINE
         PUSHJ P,FNDBK1
        POP P ,LINE
        PUSHJ P,FNDPR
        POPJ P,
FNDBK1: PUSH P,FLRNG
        MOVEM LINE ,FLRNG
        PUSHJ P,BKCOMA
        POP P,FLRNG
        POPJ P,

        JRST FNDBK
BKCOM: TRNE F,MARK.F
        JRST [SETZM FLRNG
        PUSHJ P,CKRNG
        PUSHJ P,FNDBK
        JRST MARKST]
BKCOMA: SETZM TMPLIN    ;USE TMPLIN AS COUNTER
        MOVE LINE ,FLRNG
        CAIL LINE,DICT
        CAMLE LINE,LASLIN
        JRST QUEST
BKCOM1: CAIN LINE,DICT
        JRST [ MOVE X1,FLRNG
        SUBI X1,DICT
        JRST BKCOM4]
        MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        JRST BKCOM5 ;DIC=0
        ILDB CH,DIC
        CAIE    CH," "+KK.OFF           ;KK SPACE?
        CAIN CH,11
        JRST BKCOM6
        CAIE CH," "
        CAIN CH,15
        JRST BKCOM6
BKCOM2: OUTCHR  CH
        ILDB CH,DIC
        CAIE CH," "+KK.OFF              ;KK SPACE?
        CAIN CH,11
        JRST BKCOM5
        CAIE CH," "
        CAIN CH,15
        SKIPA
        JRST BKCOM2
BKCOM5: SKIPN X1,TMPLIN
        JRST BKCOM3
        OUTCHI  "+"             ;GIVE A +
BKCOM4: PUSHJ P,PRTNUM ;PRINT HOW FAR AWAY IT IS
BKCOM3: OUTSTR   CRLF
        TRNE F,FND.F
        POPJ P,
        MOVE X1,FLRNG
        MOVEM X1,CURLIN
        JRST GETCOM
BKCOM6: AOS TMPLIN
        SOJA    LINE,BKCOM1
;APPEND COMMAND
;FORMAT R APPEND FILENAME
;       N APPEND        N+1 INSERT
;       APPEND          $ APPEND
;FIND AND MARK CAN BE USED WITH APPEND ONLY IF AN APPEND TO FILENAME

FNDAP:  TLO F,APPEN.F
FNDWR:  TRO F,FND.F
        SETOM TRUTH             ;FLAG TO INDICATE A PARTIAL WRITE SHOULDN'T RESET MODIFICATIONS COUNTER
        PUSHJ P,FNDAP1          ;DO WRITE INITIALIZATION
        MOVEI X1,WRIT7
        MOVEM X1,COMAN          ;WRIT7 IS ITERATIVE PART OF WRITE FUNCTION
        MOVEI X1,FNDAP2
        MOVEM X1,ENDCM          ;FNDAP2 IS TERMINATION OF WRITE FUNCTION
        POPJ P,


        JRST FNDAP
APPEND: ASCIZ/PPEND/
        TLO F,APPEN.F
        CAME CH,CRFLG           ;CR? IF NOT, MUST BE APPEND TO FILE
        JRST WRITE+1            ;APPEND TO FILE
        TRNE F,MARK.F           ;"@" COMMAND?
        JRST [PUSHJ P,FNDWR     ;YES-FORCES AN APPEND TO FILE
             SETZM FLRNG
             JRST MARKST]

;NOT AN APPEND TO FILE COMMAND:

        PUSHJ   P,DWSMCP        ; IF WORKSPACE MODE IS UNKNOWN THEN SET IT
                                ; TO THE MODE OF THE COMMAND PORT
        SKIPE FLRNG             ;RANGE GIVEN?
        JRST RNGAPP             ;YES
        SKIPE EOF               ;NO-MEANS APPEND TO END OF TEXT AREA
                                ;MORE INPUT FILE TO READ IN?
        PUSHJ P,FINUP           ;YES-READ IT ALL IN TO GET TO LAST LINE
        MOVE X1,LASLIN
        AOJ X1,                 ;"INSERT" BEFORE LAST LINE+1
        MOVEM X1,FLRNG
        JRST INSERT+2
RNGAPP: SKIPE CERNG             ;MORE THAN 1 LINE INDICATED?
        JRST QUEST              ;YES-ILLEGAL
        AOS FLRNG               ;INSERT AFTER LINE IS INSERT BEFORE LINE+1
        JRST INSERT+2           ;DO THE INSERT
;COMMAND TO PRINT OUT CONTENTS OF BUFFER N
; FORMAT N BUFFER
BUFFER: ASCIZ/UFFER/
        MOVEI X1,BUFFRD         ;REQUEST BUFFERED OUTPUT
        MOVEM X1,OUTMOD         ;SET OUTPUT MODE (FOR ISUCN)

        MOVE LINE,FLRNG
        SUBI LINE,DICT  ;UNDO WORK OF ADRCAL
        CAIL LINE,0
        CAILE LINE,NOBUFS
        JRST QUEST
        MOVEI CH,42
        IMULI LINE,BUFLNS+1
        ADDI LINE,BUF0
BUFF3: MOVE DIC,(LINE)
        SKIPN DIC
        JRST BUFF1
        PUSHJ P,MAKPNT
        JRST BUFF1      ;DIC=0
 ILDB X1,DIC
        CAIN X1,33
        JRST BUFF1
        MOVEI CH,42
        PUSHJ P,PRTTEX
        MOVE CH,X1
        JRST BUFF4
BUFF2:  ILDB CH,DIC
        CAIN CH,33
        JRST BUFF1
BUFF4:  PUSHJ P,ISUCN 
        CAIE CH,15
        JRST [PUSHJ P,PRTTEX
                JRST BUFF2]
        MOVEI X4,1
BUFF6:  MOVEI CH,15
        PUSHJ P,PRTTEX
        MOVEI CH,12
        PUSHJ P,PRTTEX
        SKIPN X4
        JRST [MOVEI CH,42
                JRST BUFF7]
        MOVEI CH,42
        PUSHJ P,PRTTEX
        SOJGE X4,BUFF6
BUFF7:  AOJA LINE,BUFF3
BUFF1:  SKIPLE OTTY+2   ;HAVE WE SPIT IT ALL OUT
        PUSHJ P,PRTTE1  ;NO
        CAIE CH,42
        OUTCHR   .CTTAB+42       ;ANOTHER QUOTE
        OUTSTR   CRLF
        JRST GETCOM




ISUCN:  CAIE CH,15
        CAILE CH,37
        POPJ P,
        PUSH P,CH
        MOVEI CH,46     ;&
        PUSHJ P,PRINCH
        POP P,CH
        ADDI CH,100
        POPJ P,
;CHECKPOINT COMMAND
;SAVES TEXT ON FILE NAMED IN CREATE OR MODIFY COMMAND.


CHECKP: ASCIZ/CKPOINT/
        SKIPN RPG               ;MUST HAVE A DEFAULT FILE NAME
        JRST QUEST
        SKIPE EXAMIN            ;CHECKPOINT IS ILLEGAL IN EXAMINE MODE
        JRST [OUTSTR ILLCHE
              JRST GETCOM]
        PUSHJ P,AUTOWR          ;WRITE THE FILE IF NECESSARY
        JRST GETCOM

ILLCHE: ASCIZ/

Cannot CHECKPOINT in EXAMINE mode

/

;VERSION TO ACCEPT A FILE NAME:  (NOT CURRENTLY IMPLEMENTED)

;CHECKP: ASCIZ/CKPOINT/
;        TLNN CH,TERM.F          ;FILE NAME GIVEN?
;        JRST NEWRPG             ;YES-GO WRITE AND SET DEFAULT NAME
;        SKIPN RPG               ;NO-DEFAULT NAME REQUIRED
;        JRST QUEST              ;NONE IS ILLEGAL
;        PUSHJ P,AUTOWR          ;DO AUTOMATIC WRITE
;        JRST GETCOM
;
;NEWRPG: PUSHJ P,AUTOWR          ;DO AUTOMATIC WRITE
;        MOVE X1,[OUTNAM,,RPGNAM]
;        BLT X1,RPGFIL+3         ;MAKE NEW DEFAULT NAME
;        SETOM RPG               ;AND INDICATE IT EXISTS
;        JRST GETCOM
        IFN %CIPFLG,<
                             ;*****CIPHERING*****

;THE CIPHER ALGORITHM USED HERE IS A RUNNING KEY  ALGORITHM FROM STANFORD
;THAT USES THREE RANDOM NUMBER GENERATORS. DETAILS ARE AVAILABLE.
;THE RANDOM NUMBER GENERATORS ARE INITIALIZED BY A KEY. PART OF THIS KEY
;IS TYPED BY THE USER DURING THE CIPHER COMMAND, AND PART IS 
;PROVIDED BY THE SYSTEM WHEN THE CIPHER IS INITIALIZED. ON INPUT, THE
;SYSTEM PART IS READ FROM THE FIRST WORD OF THE CIPHERED FILE. ON OUTPUT,
;IT IS DERIVED BY COMBINING THE RESULTS OF TWO TIME UUOS. THE PURPOSE OF
;THIS IS TO CREATE A UNIQUE KEY FOR EACH ENCIPHERED FILE. CONTROL CHAR-
;ACTERS AND CHARACTERS NOT TYPEABLE ON A TTY33 ARE ILLEGAL IN THE KEY.
;AFTER A FULL KEY IS USED TO INITIALIZE THE CIPHER, THE SYSTEM PART OF IT IS
;DISCARDED WHILE THE USER PART IS RETAINED. THIS ENABLES THE PROGRAM TO
;PERFORM THE NEXT CIPHERING OPERATION WITH THE SAME TYPED KEY, SO THAT THE
;USER ONLY HAS TO PROVIDE THE KEY ONCE.

KEYMES: ASCIZ /Key: /
AGAIN:  ASCIZ /Again: /
KEYERR: ASCIZ   /Keys mismatch/
KTLONG: ASCIZ   /Key too long/
KEYMAX== 10              ;TOTAL LENGTH OF KEY BUFFER
CPTLEN== 103             ;LENGTH OF PART OF TABLE USED TO GET RUNNING KEY
CPRIMS== 200             ;TOTAL LENGTH OF CIPHER TABLE
CPVERS== 0               ;CURRENT VERSION NUMBER OF CIPHER


;CIPHER COMMAND--FORM: *CIPHER
;
;READ TYPED CIPHER KEY,  TWICE. MAXIMUM LENGTH OF KEY 70 CHARS.
;SET CIPHERING FLAG, CPFLAG. LEAVE KEYPTR AS BYTE POINTER TO LAST
;CHARACTER IN KEY. TYPED KEY IS NOT PRINTED.
;IF USER TYPES CARRET ONLY, TURN OFF CIPHERING.
;ALSO, READ IN ANY OPEN INPUT FILE SO THAT FUTURE READS
;WON'T BE MISTAKENLY CIPHERED.

CIPHER: ASCIZ /PHER/
        PUSHJ   P,SILENC                ;TURN OFF ECHO
        OUTSTR KEYMES
        
        SETZM   KEYBF2                  ;ZERO KEY SPACE
        MOVE    X1,[XWD KEYBF2,KEYBF2+1]
        BLT     X1,KEYBF2+KEYMAX-1
        SETZM   KEYBF1
        MOVE    X1,[XWD KEYBF1,KEYBF1+1]
        BLT     X1,KEYBF1+KEYMAX-1

        MOVE    X1,[POINT 7,KEYBF1]
        MOVEM   X1,KEYPT1
        PUSHJ   P,GETKEY                ;READ FIRST KEY
        JRST    CIPKTL
        SKIPE   KEYBF1                  ;SKIP IF C.R. ONLY TYPED
        JRST    CIPH1   
        PUSHJ   P,ONECHO        ;C.R. ONLY TYPED. TURN ECHO BACK ON
        SKIPN   EOF
        JRST    .+3             ;IF INPUT AVAILABLE, READ IT
        PUSHJ   P,FINUP
        PUSHJ P,INCMOD          ;& SET FILE-CHANGED FLAG
        OUTSTR  CRLF
        SETZM   CP1FLG
        SETZM   CP2FLG
        SETZM   CPFLAG                  ;TURN OFF CIPHERING
        JRST    GETCOM

CIPH1:  OUTSTR  CRLF
        OUTSTR  AGAIN
        MOVE    X1,[POINT 7,KEYBF2]
        MOVEM   X1,KEYPT1
        PUSHJ   P,GETKEY                ;GET KEY SECOND TIME
        JRST    CIPERR
        SETZ    X2,

CIPH2:  MOVE    X1,KEYBF2(X2)           ;COMPARE TWO KEYS
        CAME    X1,KEYBF1(X2)
        JRST    CIPERR                  ;MISMATCH
        AOJ     X2,
        JUMPN   X1,CIPH2                   ;MATCH, COMPARE NEXT WORD

        PUSHJ   P,ONECHO        ;ALL OK. TURN ECHO BACK ON.
        SKIPN   EOF             ;IS THERE INPUT COMING
        JRST    .+3             ;JUMP IF NOT
        PUSHJ   P,FINUP         ;ELSE READ NOW BEFORE SETTING CIPHER FLAG
        PUSHJ P,INCMOD
        OUTSTR  CRLF

        PUSHJ   P,%OFFESC       ;TURN OFF INTERRUPTS
        MOVE    X1,[XWD KEYBF2,KEYBUF]
        BLT     X1,KEYBUF+KEYMAX-1      ;MOVE KEY TO REAL BUFFER
        HRRZ    X1,KEYPT1
        ADDI    X1,KEYBUF
        SUBI    X1,KEYBF2
        HLL     X1,KEYPT1
        MOVEM   X1,KEYPTR       ;STORE REAL KEY POINTER
        SETOM   ,CPFLAG         ;SET CIPHERING  FLAG
        PUSHJ   P,%ONESC        ;START INTERRUPTS
        JRST    GETCOM

;GET A KEY STRING FROM TERMINAL
;MAKE SKIP RETURN UNLESS KEY TOO LONG, THEN MAKE NORMAL RETURN

GETKEY: MOVEI   X1,<KEYMAX-2>*5         ;MAX  NO. OF KEY CHARS
                                        ;(2 EXTRA FOR SYSTEM PART & LAST NULL)
        MOVEM   X1,KEYCNT
GETKY0: PUSHJ   P,GNC
        TLZ     CH,777777               ;GET CHAR & ZAP FLAGS IN CH
        CAIN    CH,15
        JRST    GETKY1                  ;IF CR, DONE.
        SOSGE   ,KEYCNT
        POPJ    P,                      ;TOO MANY CHARS. MAKE ERROR RETURN
        MOVE    X1,CH
        PUSHJ   P,CPCNV                 ;CONVERT CHAR
        SKIPL   ,X1
        IDPB    X1,KEYPT1
        JRST    GETKY0

GETKY1: PUSHJ   P,GNC           ;CLEAR L.F.
        AOS     ,(P)            ; MAKE NORMAL RETURN TO P+1
        POPJ    P,

CIPKTL: OUTSTR  CRLF            ;COME HERE IF KEY TOO LONG (SHOULD BE RARE)
        OUTSTR  KTLONG          ;SEND KEY TOO LONG MESSAGE
        OUTSTR  CRLF
        PUSHJ   P,ONECHO
        JRST    CIPHER+1

CIPERR: OUTSTR  CRLF            ;NO MATCH
        OUTSTR  KEYERR          ;SEND MSG
        OUTSTR  CRLF
        PUSHJ   P,ONECHO
        JRST    CIPHER+1

;SUBROUTINE TO CONVERT CIPHER KEY CHARS. INPUT: CHAR IN X1. CHANGES ONLY X1.
;CONVERTS LOWER CASE TO UPPER CASE, RETURNS -1 IN X1 IF CHAR IS CONTROL CHAR
;OR NOT TYPEABLE ON TTY33.
CPCNV:  CAIL    X1,141          ;LOWER CASE ALPHA TO UPPER CASE
        CAILE   X1,172
        SKIPA
        SUBI    X1,40
        CAIL    X1,40           ;IGNORE CON CHARS AND NON-TTY33 CHARS
        CAILE   X1,137
        SETO    X1,             ;RETURN -1 IF CTL CHAR OR NON-TTY33
        POPJ    P,

;COME HERE FROM INCHR WHEN CIPHERING.
;IF FIRST BUFFER, GET SECOND PART OF KEY FROM FIRST WORD OF FILE,AND
;ADD TO KEYBUF, ADJUST BYTE POINTER AND COUNTER IN BUFFER HEADER,
;AND INTIALIZE CIPHER. DECIPHER BUFFER. LEAVE KEY POINTER POINTING
;AT LAST CHAR OF TYPED KEY FOR USE IN NEXT FILE OP.
CPBUF:  SKIPN   ,CP1FLG          ;SKIP IF FIRST BUFFER
        JRST    CPBUF2
        PUSHJ   P,%OFFESC       ;TURN OFF INTS
        MOVE    X1,KEYPTR       ;SAVE KEY POINTER FOR POSS NEXT FILE
        MOVEM   X1,CPTMP
        MOVE    X2,IBUFR+3      ;get second part of key and version # word
        SETZ    X1,
        MOVEI   X3,5
CPBUF1: LSHC    X1,7            ;get key chars into X1 by shifting
        PUSHJ   P,CPCNV         ;CONVERT CHAR
        SKIPL   ,X1             ;IGNORE BAD CHARS
        IDPB    X1,KEYPTR
        SETZ    X1,
        SOJG    X3,CPBUF1       ;GET FIVE CHARACTERS

        MOVE    X1,IBUFR+3      ;EXTRACT VERSION NUMBER
        ANDI    X1,17
        MOVEM   X1,CPFVER       ;STORE IT
        MOVE    X1,IBUF+2       ;ADJUST WORD COUNT
        SUB     X1,WSCHPW       ;subtract number of characters in one word
        MOVEM   X1,IBUF+2
        AOS     IBUF+1          ;increment byte pointer to next word
        SETZM   ,IBUFR+3         ;ZAP FILE KEYWD TO HELP INCHR
        PUSHJ   P,CPIN          ;INITIALIZE STATE VCTRS AND TABLE
        PUSHJ   P,CPKFX         ;DISCARD SECOND PART OF KEY
        PUSHJ   P,%ONESC        ;INTS OK NOW

CPBUF2: HRRZ    X1,IBUFR+2      ;GET COUNT OF DATA WORDS
        ADDI    X1,IBUFR+2      ;MAKE ADDRESS OF LAST WORD
        MOVEM   X1,CPLAST       ;STORE IT
        MOVEI   X2,IBUFR+3      ;MAKE ADDRESS OF FIRST WORD
        SKIPE   ,CP1FLG
        AOJ     X2,             ;IGNORE FIRST WORD IF FIRST BUFFER
        SETZM   ,CP1FLG         ;RESET FLAG
CPBUF3: PUSH    P,X2            ;SAVE ADDRESS
        PUSHJ   P,CPRAN         ;GET ONE WORD OF RUNNING KEY TO X1
        POP     P,X2            ;RECOVER ADDR
        XORM    X1,(X2)         ;XOR WITH WORD IN BUFFER
        AOJ     X2,             ;INCR POINTER
        CAMLE   X2,CPLAST       ;CHECK FOR LAST WORD
        POPJ    P,              ;IF JUST DID IT, EXIT
        JRST    CPBUF3          ;ELSE LOOP

;INITIALIZE CIPHER FOR WRITE. COME HERE FROM OUTCHR AFTER FIRST OUT UUO.
;FORM SECOND PART OF KEY FROM UUOS, WRITE AS FIRST WORD OF FILE, AND ADD
;TO TYPED KEY. 2ND PART MUST CONTAIN AT LEAST 1 CHAR. LEAVE KEYPTR
;AS IT WAS AT START FOR NEXT FILE OP.
CPWIN:  MOVE    X1,KEYPTR       ;SAVE KEY PTR AS IS
        MOVEM   X1,CPTMP
        PUSHJ   P,%OFFESC       ;NO INTS WHILE INITING
        TIMER   X1,
        MSTIME  X2,
        HRL     X2,X1           ;FORM 2ND PART OF KEY FROM TIMES
        TRZ     X2,17
        IORI    X2,CPVERS       ;INSERT CURRENT VERSION IN FIRST WORD
        MOVEM   X2,OBUFR+3      ;AND WRITE AS FIRST WORD OF FILE
        SETZ    X1,
        MOVEI   X3,5
CPWIN1: LSHC    X1,7            ;GET A CHAR 
        PUSHJ   P,CPCNV
        SKIPL   ,X1             ;DON'T USE IF BAD
        IDPB    X1,KEYPTR
        SETZ    X1,
        SOJG    X3,CPWIN1       ;GET ANOTHER IF NOT DONE
        MOVE    X1,KEYPTR
        CAMN    X1,CPTMP        ;IF NO GOOD CHARS IN TIMES, TRY AGAIN
        JRST    CPWIN
        MOVE    X1,OBUF+2
        SUB     X1,WSCHPW       ;ADJUST BYTE COUNT according to # chars per word
        MOVEM   X1,OBUF+2
        AOS     ,OBUF+1
        PUSHJ   P,CPIN          ;INITIALIZE CIPHER ARRAYS
        PUSHJ   P,CPKFX         ;DISCARD SECOND PART OF KEY
        PUSHJ   P,%ONESC        ;INTS OK NOW
        SETOM   ,CP1FLG         ;SET FIRST-BUFFER-COMING FLAG
        POPJ    P,

;DECIPHER BUFFER. COME HERE FROM OUTCHR AFTER FIRST OUT UUO HAS GONE BY.
CPBFO:  HRRZ    X1,OBUF+1       ;GET LAST ADDRESS FROM PTR
        MOVEM   X1,CPLAST
        MOVEI   X2,OBUFR+3      ;GET FIRST ADDRESS
        SKIPE   ,CP1FLG
        AOJ     X2,             ;ADJUST IF FIRST BUFFER--1ST WD HAS KEY
        SETZM   ,CP1FLG
CPBFP:  PUSH    P,X2            ;SAVE ADDRESS
        PUSHJ   P,CPRAN         ;GET WORD OF RUNNING KEY
        POP     P,X2
        XORM    X1,(X2)         ;ENCIPHER DATA
        AOJ     X2,
        CAMLE   X2,CPLAST       ;RETURN IF JUST DID LAST WORD
        POPJ    P,
        JRST    CPBFP           ;ELSE LOOP


CPKFX:  MOVE    X2,CPTMP        ;DONE W/ KEY. ZERO KEY GOTTEN FROM FILE.
        SETZ    X1,
        MOVEI   X3,5
CPKFX1: IDPB    X1,X2
        SOJG    X3,CPKFX1       ;WRITE FIVE ZEROS
        MOVE    X1,CPTMP        ;RESTORE KEY POINTER
        MOVEM   X1,KEYPTR
        POPJ    P,

;INITIALIZE CIPHER STATE VECTORS AND TABLE. THIS ROUTINE WELL DEBUGGED.
CPIN:   MOVE    X1,[XWD CPINI,CPTAB]    ;COPY INIT VALS FOR PRIMES TABLE
        BLT     X1,CPTAB+CPRIMS-1
        MOVE    X1,[XWD IIY1,IY1]       ;AND FOR STATE VECTORS FOR RNGS.
        BLT     X1,IY9
        MOVE    X4,[POINT 7,KEYBUF]
CPIN1:  ILDB    X1,X4           ;GET KEY CHAR TO CHANGE STATE VECTORS WITH
        JUMPE   X1,CPIN3        ;IF ZERO, DONE HERE
        SUBI    X1,37
        MOVE    X2,CPTAB-1+CPRIMS/2(X1)         ;INDEX INTO 2ND HALF OF TABLE
        MOVE    X3,CPTAB-1(X1)
        MOVEI   X1,11           ;CHANGE ALL NINE S.V.S
CPIN2:  IMULM   X2,IY1-1(X1)
        ADDM    X3,IY1-1(X1)
        SOJG    X1,CPIN2
        JRST    CPIN1           ;DO NEXT KEY CHAR

CPIN3:  MOVEI   X3,11           ;NOW MAKE STATE VECTORS CONGR TO 1 MOD 4
CPIN4:  MOVE    X1,IY1-1(X3)
        LSH     X1,3
        ADDI    X1,2
        LSH     X1,-1
        MOVEM   X1,IY1-1(X3)
        SOJG    X3,CPIN4        ;DO ALL NINE

        MOVNI   X3,CPTLEN
        MOVE    X1,IY1          ;FILL FIRST 67 VALUES FROM RAN1
CPIN5:  IMUL    X1,IY2
        ADD     X1,IY3
        MOVEM   X1,CPTAB+CPTLEN(X3)
        AOJL    X3,CPIN5
        MOVEM   X1,IY1          ;RESTORE RAN1 STATE VECOTR
        POPJ    P,


;PRODUCES ONE WORD OF RUNNING KEY, WHICH IS XORED WITH ONE WORD OF TEXT.
;FOR AN EXPLNATION OF THE ALGORITHM, SEE THE STAND-ALONE CIPHER PROGRAM.
CPRAN:  MOVE    X3,IY7          ;RAN3
        IMUL    X3,IY8
        ADD     X3,IY9
        MOVEM   X3,IY7          ;STORE NEW RAN3 STATE VECTOR
        LSH     X3,-5
        ANDI    X3,17
        TRO     X3,4
        SOJ     X3,             ;X3 HAS ITERATION COUNT
        MOVEM   X3,CPCNT
        MOVE    X1,IY1
        MOVE    X2,IY4          ;RAN1 & RAN2 STATE VECTORS IN X1,X2

CPRAN1: IMUL    X2,IY5
        ADD     X2,IY6          ;RAN2
        HLRZ    X3,X2
        IDIVI   X3,CPTLEN      ;X4 NOW HAS TABLE INDEX
        IMUL    X1,IY2
        ADD     X1,IY3          ;RAN1
        MOVEM   X1,CPTAB(X4)            ;PUT NEW RNG VALUE IN TABLE
        IMUL    X2,IY5
        ADD     X2,IY6          ;RAN2
        HLRZ    X3,X2
        IDIVI   X3,CPTLEN
        IMUL    X1,IY2
        ADD     X1,IY3          ;RAN1
        MOVEM   X1,CPTAB(X4)    ;PUT NEXT RNG VALUE IN TAB
        SOSLE   ,CPCNT
        JRST    CPRAN1          ;LOOP CPCNT-1 TIMES

        IMUL    X2,IY5          ;LAST ITERATION STARTS HERE
        ADD     X2,IY6          ;RAN2
        HLRZ    X3,X2
        IDIVI   X3,CPTLEN
        IMUL    X1,IY2
        ADD     X1,IY3          ;RAN1
        MOVE    X3,X1
        EXCH    X3,CPTAB(X4)    ;FINALLY SWITCH RNG VALUE AND TABLE ENTRY
        LSH     X3,11           ;SHIFT ENTRY 9 BITS
        MOVEM   X3,CPTMP        ;SAVE IT
        IMUL    X2,IY5
        ADD     X2,IY6          ;RAN2
        HLRZ    X3,X2
        IDIVI   X3,CPTLEN
        IMUL    X1,IY2
        ADD     X1,IY3          ;RAN1
        MOVEM   X1,IY1
        MOVEM   X2,IY4          ;THROUGH W/ RNGS SO PUT STATE VECTORS BACK
        EXCH    X1,CPTAB(X4)    ;DO SECOND EXCHANGE
        LSH     X1,-11
        HLL     X1,CPTMP        ;COMBINE RESULTS OF 2 EXCHS
        POPJ    P,

>

;CLEAR COMMAND

ALL: ASCIZ/All? /
CLEAR:  ASCIZ/EAR/
        TRNE    F,MARK.F        ;CLEAR MARK BITS?
        JRST    CLEAR1          ;YES, CLEAR MARK BITS
        IFNBFR <OUTSTR  ALL>    ;ASK ALL? UNLESS IN A BUFFER OR COMFILE
        PUSHJ   P,YORN          ;GET ANSWER
         JRST   GETCOM          ;NO, FORGET COMMAND
        CLOSE   TMP,40          ;FORGET LAST TMP FILE

        MOVE    X2,[POINT 7,0]
        HLLM    X2,CMDPNT
        HLLM    X2,NEWPNT
        HLLM    X2,OLDPNT
        SETZM   FRSTZR          ;ZERO DATA AREA
        MOVE    X2,LASLIN       ;LAST DICT LINE
        MOVE    X1,[FRSTZR,,FRSTZR+1] ;BLT WORD
        BLT     X1,(X2)         ;ZERO ALL DATA
        PUSHJ P,RESTAB          ;RESTORE TAB STOPS
        HRRZ    X2,SVJOB        ;LAST CORE SAVED
        CORE    X2,             ;CONTRACT CORE
         JRST   TOOBIG          ;CAN'T?
        TRZ     F,RPG.F!ONR.F
        SETZM   RPG             ;FORGET ABOUT RPG
        JRST    START           ;AND RESTART

; HERE TO CLEAR A SPECIFIC MARK BIT
CLEAR1: MOVEI   LINE,DICT+1     ;GET DICT ADDRESS
        MOVE    X1,MARKNO       ;GET SPECIFIED MARK BIT
CLEAR2: MOVE    DIC,(LINE)      ;GET DIC PTR
        CAMN    DIC,MIN1        ;-1=> LINE NOT IN DICTIONARY YET; IS COMING IN
        JRST    GETCOM          ;FROM READ FILE- THUS ALL DONE
        TRZ     DIC,(X1)        ;CLEAR THE MARK BIT
        MOVEM   DIC,(LINE)      ;SAVE IT
        ADDI    LINE,1          ;INCREMENT LINE COUNTER
        CAMG    LINE,LASLIN     ;ARE WE DONE YET?
        JRST    CLEAR2          ;NO, CLEAR ALL BITS
        JRST    GETCOM          ;ALL DONE, EXIT.
; YORN - GET'S YES OR NO
; NOSKIP - NO
; SKIP - YES

YORN:   PUSHJ P,GNC
        HLLI    CH,0            ;LH(CH)=0
        CAIE    CH,156          ;LOWER-CASE N ?
        CAIN    CH,"N"          ;UPPER-CASE N ?
        JRST    [SETZM COMW.F
                TRNN F,COMF.F!BUF.F
                OUTSTR CRLF
                POPJ P,]        ;NOSKIP RETURN
        CAIE    CH,"Y"          ;UPPER-CASE Y ?
        CAIN    CH,171          ;OR LOWER-CASE Y ?
        JRST    [SETZM COMW.F
                TRNN F,COMF.F!BUF.F
                OUTSTR CRLF
                JRST CPOPJ1]    ;SKIP RETURN
        ENDBUF
        OUTSTR  CRLF            ;OUTPUT A CRLF
        MOVE    CH,[41,,24]     ;YELLOW BALL
        HIBER   CH,
         JFCL                   ;IGNORE ERROR RETURN
        CLRBFI                  ;CLEAR INPUT BUFFER
        OUTSTR  WHAT            ;WHAT WAS THAT ?
        JRST    YORN            ;AND ASK FOR IT AGAIN

WHAT:   ASCIZ /What? /
;COMMANDS - COMMAND, GET COMMANDS FROM A DSK FILE
;FORMAT - COMMAND FILENAME

COMMND: ASCIZ/MANDS/
        TLNE CH,TERM.F  ;ANYTHING AFTER?
        PUSHJ P,GETFIL  ;NO GET FILE NAME
        MOVEI X1,COMFIL
        PUSHJ P,FILNAM
        HLRZ X1,COMFIL
        CAIN X1,(SIXBIT'T')
        JRST COMM2      ;YES
        MOVEI   X1,COMFIL
        PUSHJ   P,X10215        ;EXTEND LOOKUP BLOCK TO 15 WORRDS
        INIT COMF,0
        SIXBIT/DSK/
        XWD 0,ICOMF
        JRST %DSFAL
        MOVEI X1,COMBUF
        MOVEM X1,JOBFF
        INBUF COMF,1
        HLRZ X1,COMFIL+3        ;GET EXTENSION
        SKIPE X1                ;NULL EXTENSION?
        JRST COMM3              ;NO-NO DEFAULT ACTION
        MOVEI X1,(SIXBIT'CMD')  ;DEFAULT EXTENSION IS '.CMD'
        HRLM X1,COMFIL+3        ;SET EXTENSION
        LOOKUP COMF,COMFIL
        JRST [HRRZ X1,COMFIL+3  ;GET ERROR CODE
              SKIPE X1          ;FILE NOT FOUND?
              JRST COMFAL       ;NO-SOME OTHER ERROR
              SETZ X1,
              HRLM X1,COMFIL+3  ;SET NULL EXTENSION
              JRST COMM3]       ;GO TRY TO OPEN IT
        JRST COMOK              ;GOT IT
COMM3:  LOOKUP COMF,COMFIL
COMFAL: JRST    [RELEASE COMF,
                HRRZ X1,COMFIL+3 ;GET ERROR CODE
                JRST FOPERR]    ;TYPE ERROR MESSAGE

COMOK:  SETZ    R0,
        LDB     X1,[POINT 4,COMFIL+4,12]        ;GET DATA MODE
        CAIN    X1,2    ;IS IT KATA KANA?
        SETO    R0,     ;YES
        LDB     X1,[POINT 1,COMFIL+14,9]        ;GET KK FLAG
        SKIPE   X1
        SETO    R0,
        JUMPE   R0,CFNOKK
        SETSTS  COMF,2
        HRLI    X1,(POINT 9,)
        HLLM    X1,ICOMF+1
CFNOKK: TRO F,COMF.F
        SETOM COMBFR
        SETOM   TIRE+ACRING
        MOVEI   X1,GT%CHR
        MOVEM   X1,TIRE+%GTCHR
        MOVEI   X1,OT%CHR
        MOVEM   X1,TIRE+%OTCHR
        PUSHJ P,GNCC            ;LOOK AHEAD TO NEXT NON-ZERO CHAR
        SKIPE COMBFR            ;NO DATA?
        JRST GETCOM
        OUTSTR [ASCIZ/File is empty
/]                              ;FILE HAD NO DATA
        TRZ F,COMF.F            ;CLOSE COMFILE
        JRST GETCOM

COMM2:  MOVE X1,[XWD COMBUF,COMBUF+1]
        SETZM COMBUF
        BLT X1,COMBUF+202
        TRZ F,COMF.F
        JRST GETCOM
;DO COMMAND
;SAME AS COMMANDS COMMAND

DOCMD:  JRST COMMND+2
;OFFCOLON AND ONCOLON COMMANDS

; OFFCOLON - DISABLE ':' IGNORE DURING LABLE SEARCH
OFFCOLON: ASCIZ /OLON/
        SETZM   COLON   ;DISABLE IGNORE OF ':'
        JRST    GETCOM  ;AND GET A COMMAND

; ONCOLON - ENABLE ':' IGNORE DURING LABLE SEARCH
ONCOLON: ASCIZ /OLON/
        SETOM   COLON   ;ENABLE IGNORE OF ':'
        JRST    GETCOM  ;AND GET A COMMAND
;COPY COMMAND
; FORMAT A COPY R1,R2

;THE COPY AND MOVE COMMANDS WORK AS FOLLOWS:
;AFTER CHECKING THE PARAMETERS, A (TMPLIN), R1 (FLRNG), R2 (CERNG),
;WE OPEN UP A SPACE IN THE IN-CORE DICTIONARY WHERE THE
;NEW ENTRIES WILL GO (R2-R1+1 WORDS) STARTING AT DICTIONARY LOCATION
;A.  THEN, WE COPY THE DICTIONARY ENTRIES TO MOVE OR COPY INTO THAT SPACE.
;THERE ARE THREE DIFFERENT METHODS FOR THIS DEPENDING ON WHERE A LIES
;WITH RESPECT TO R1 AND R2 (LOWER, HIGHER, OR IN BETWEEN).
;WE ALSO KEEP TRACK OF WHERE THE ORIGINAL R1-R2 RANGE OF DICTIONARY ENTRIES
;ARE, SO THAT THEY CAN BE DELETED FOR THE MOVE COMMAND.
;NOTE THAT MOVING OR COPYING DO NOT CREATE ANY NEW TEXT; DICTIONARY
;ENTRIES ARE SIMPLY COPIED, SO THAT TWO OR MORE ENTRIES MIGHT POINT
;TO THE SAME LINE THE .TMP FILE.  NOTE ALSO THAT THE MOVE COMMAND
;DOES NOT CHANGE THE SIZE OF THE DICTIONARY, AND SO IT IS NOT NECESSARY
;TO ADJUST READLN.

COPY:   ASCIZ/Y/
        MOVE X1,FLRNG           ;GET LINE TO BE INSERTED IN FRONT OF (A)
        CAIG X1,DICT
        MOVEI X1,DICT+1         ;DEFAULT LOWER LIMIT
        CAMG X1,LASLIN
        JRST .+3
        MOVE X1,LASLIN
        AOJ X1,                 ;DEFAULT UPPER LIMIT
        PUSH P,X1               ;SAVE A
        MOVEM X1,CURLIN
        PUSHJ   P,ISITSP        ;IS NEXT CHAR A BLANK
        DEC NEW                 ;NO SO BAK UP POINTER
        PUSHJ P,SETSRC          ;GET LINES TO BE COPIED
        TLNN CH,TERM.F          ;END OF COMMAND
        JRST QUEST              ;NO
        PUSHJ P,ADRCAL          ;FIND WHERE LINES ARE
        MOVE LINE,FLRNG         ;GET BEGINNG OF RANGE, R1
        SKIPN X2,CERNG
        MOVE X2,FLRNG
        CAMGE X2,LINE           ;SEE IF CERNG>=FLRNG
        JRST QUEST              ;NO
        CAIL LINE,DICT+1
        CAMLE X2,LASLIN
        JRST QUEST
        MOVEM X2,CERNG          ;SET R2
        POP P,X1                ;GET A BACK
        MOVEM X1,CURLIN
        MOVEM X1,TMPLIN
        TLNN F,MOVE.F           ;MOVE COMMAND?
        JRST COP00              ;NO, COPY

;IF THE MOVE COMMAND, THEN ANY ATTEMPT TO MOVE LINES TO SOMEWHERE WITHIN
;THEIR RANGE IS CONSIDERED A NO-OP:

        MOVE X1,TMPLIN          ;GET A
        CAML X1,FLRNG           ;A >= R1 ?
        CAMLE X1,CERNG          ;AND A <= R2 ?
        SKIPA                   ;NO, NOT WITHIN RANGE
        JRST GETCOM             ;WITHIN RANGE, NO-OP

COP00:  MOVE NUM,CERNG          ;START OPENING UP SPACE
        SUB NUM,FLRNG           ;R2-R1
        AOJ NUM,                ;NUMBER OF LINES IN RANGE
        ADD NUM,LASLIN          ;DICT ADDR OF NEW LAST LINE IN DICT
        CAMG NUM,JOBREL         ;ENOUGH ROOM?
        JRST .+3                ;YES
        PUSHJ P,GETCOR          ;NO
        JRST .-3
        MOVE X1,LASLIN          ;GET OLD LASLIN
        MOVEM NUM,LASLIN        ;MAKE NEW LASLIN

;NOW, MAKE THE EMPTY SPACE IN THE DICTIONARY. FROM THIS
;POINT ON, WE INHIBIT ESCAPES BECAUSE WE ARE FIDDLING WITH THE DICTIONARY.

COP0:   PUSHJ P,%OFFESC         ;TURN OFF ESCAPES
        PUSHJ P,INCMOD          ;AND NOTE A MODIFICATION
        CAMGE X1,TMPLIN         ;ARE WE DONE MOVING ENTRIES DOWN?
        JRST COP1               ;YES
        MOVE X2,(X1)
        MOVEM X2,(NUM)
        SOJ X1,
        SOJA NUM,COP0

;WE NOW COPY THE RANGE R1-R2 INTO THIS EMPTY SPACE AND KEEP TRACK OF THE LOCA-
;TIONS OF THESE LINES USING WORD AND WORD+1; THESE CONTAIN LH,,RH PAIRS
;DELIMITING THE BLOCK OF LINES. WORD+1 IS USED IF THE BLOCK IS BROKEN
;IN TWO PARTS (CASE WHERE R1 <= A <= R2).

COP1:   MOVE X1,TMPLIN          ;GET A
        CAMLE X1,FLRNG
        SKIPA                   ;A>R1
        JRST ALES               ;A<=R1<=R2
        CAMGE X1,CERNG
        SKIPA                   ;A<R2
        JRST AGRTA              ;A>=R2>=R1

;THIS MEANS R1<A<R2 ;MUST DO MOVE IN TWO STEPS

;FIRST STEP: MOVE TOP PART OG R1,R2 RANGE INTO THE TOP PART OF THE
;EMPTY SPACE.
;FIRST BLT- X1/ R1,A (FROM R1 TO A)
;X2/A+((A-1)-R1)=2A-R1-1 (THROUGH 2A-R1-1)

        HRL X1,FLRNG
        HLLM X1,WORD            ;STORE LOC OF 1ST DELETE ADDR
        HRR X1,TMPLIN
        HRRM X1,WORD
        SOS WORD                ;C(WORD)=R1,,A-1
        MOVE X2,TMPLIN
        IMULI X2,2
        SUB X2,FLRNG
        SOJ X2,
        PUSH P,X2               ;SAVE 2A-R1-1
        BLT X1,(X2)

;SECOND STEP: MOVE BOTTOM PART OF RANGE TO BOTTOM OF SPACE:
;X1/ A+R2-R1+1,,2A-R1 (FROM TOP OF SECOND RANGE BLOCK TO MIDDLE OF SPACE)
;X2/ R2-R1+A (THROUGH END OF SPACE)

        POP P,X1                ;GET ADDR OF MIDDLE OF SPACE
        MOVE X2,TMPLIN          ;GET A
        ADD X2,CERNG
        SUB X2,FLRNG            ;C(X2)=A+R2-R1 (LAST POS OF EMPTY SPACE)
        HRLM X2,X1              ;IS THE WORD BEFORE 1ST WD TO BE MOVED
        AOBJN X1,QUEST          ;C(X1)=A+R2-R1+1,,2A-R1
        HLLM X1,WORD+1          ;C(WORD+1)=A+R2-R1+1,,0
        HRRM X1,WORD+1          ;C(WORD+1)=A+R2-R1+1,,3A+R2-2R1 =
                                ;1ST WD OF 2ND BLOCK TEXT,, LAST WD OF BLOCK
        BLT X1,(X2)

;X2 IS LAST WD IN JUST FILLED AREA OF DICTIONARY.
;DELETE ORIGINAL RANGE IF MOVE COMMAND.

COP2:   MOVEM X2,DONCHG         ;SET CURLIN AND DONCHG SO DELLOC WON'T CHANGE
        MOVEM X2,CURLIN
        TLZN F,MOVE.F           ;MOVE COMMAND?
        JRST COP5               ;NO, COPY, NO NEED TO DELETE

;MOVE COMMAND: DELETE THE LINES ACCORDING TO THE CONTENTS OF ARRAY WORD.

        SETZ LINE,
COP4:   HLRZ X2,WORD(LINE)      ;GET DICT ADDR OF 1ST WD OF OLD RANGE
        SKIPN X2                ;IF ZERO, WE ARE DONE
        JRST COP3               ;SO GO TO COP3
        HRRM X2,FLRNG
        HRRZ X2,WORD(LINE)      ;DICT ADDR OF LAST WD OF OLD RANGE
        HRRM X2,CERNG
        CAMG X2,DONCHG          ;LAST DELETE WD FOLLOW LAST NEW ENTRY?
        PUSHJ P,RECALC          ;NO, DELETE WILL CHANGE DOT, RECALCULATE
        PUSH P,LINE
        PUSHJ P,DELLOC          ;DONCHG SET, DELLOC WON'T CHANGE DOT
        POP P,LINE
        AOJA LINE,COP4
COP3:   MOVE X1,DONCHG
        MOVEM X1,CURLIN
        JRST COPEND

;COME HERE IF COPY COMMAND, NOT MOVE:

COP5:   SKIPN EOF
        JRST COPEND
        MOVE X1,LASLIN
        MOVEM X1,READLN         ;COPY CHANGES DICTIONARY LENGTH, RESET READLN
        JRST COPEND

COPEND: PUSHJ P,%ONESC          ;TURN ESCAPES BACK ON
        JRST GETCOM

RECALC: MOVE    X1,DONCHG
        SUB X1,CERNG
        ADD X1,FLRNG
        SOJ X1,
        MOVEM X1,DONCHG
        POPJ P,

;A <= R1 <= R2

ALES:   MOVE X2,CERNG           ;C(X2)=R2
        AOJ X2,                 ;TOP OF TEXT=R1+(R2-R1+1)=R2+1
        HRL X1,X2
        HRR X1,TMPLIN           ;C(X1)=R2+1,,R1
        SOJ X2,
        SUB X2,FLRNG            ;R2-R1
        ADD X2,TMPLIN           ;A+R2-R1
        HLLM X1,WORD            ;C(WORD)=R2+1,,0
        HLR X3,X1
        ADD X3,CERNG
        SUB X3,FLRNG            ;C(X3)=R2+(R2-R1+1)=2R2-R1+1
        HRRM X3,WORD            ;C(WORD)=R2+1,,2R2-R1+1=TOP RANGE,,BOTTOM
        BLT X1,(X2)
        JRST COP2

;A >= R2 >= R1

AGRTA:  HRL X1,FLRNG            ;GET A
        HRR X1,TMPLIN           ;C(X1)=R1,,A
        HLLM X1,WORD
        MOVE X2,CERNG
        HRRM X2,WORD            ;C(WORD)=R1,,R2
        ADD X2,TMPLIN
        SUB X2,FLRNG            ;C(X2)=A+R2-R1=LAST WD OF EMPTY SPACE
        BLT X1,(X2)
        JRST COP2
;ROUTINE TO TAKE LINE WHOSE DICTIONARY ADDRESS IS IN X1
;AND PUT IT INTO THE OLD LINE. CALLS SETOLD.

SETLIN: CAIG X1,DICT            ;IS THE LINE IN DICTIONARY?
        JRST SETLI2             ;NO-CLEAR THE OLD LINE AND RETURN
        MOVE DIC,(X1)           ;GET DICTIONARY ENTRY
        SKIPN DIC               ;NON-EXISTENT LINE?
        JRST SETLI3             ;YES
        PUSHJ P,MAKPN1          ;CONVERT TO POINTER
        JRST SETLI3             ;DIC=0
        PUSHJ P,SETOLD          ;PUT THAT LINE INTO THE OLD LINE
        JRST SETLI3             ;AND RETURN

SETLI2: PUSHJ P,SETLI1          ;CLEAR NEW
        PUSHJ P,SWITCH          ;SWITCH TO OLD
SETLI3: POPJ P,

;ROUTINE TO PUT THE TEXT POINTED TO BY DIC INTO THE NEW LINE IMAGE.
;THE TEXT MUST END WITH A CARRIAGE RETURN OR A ZERO.

SETNEW: PUSHJ P,SETLI1          ;CLEAR OUT THE NEW LINE
        MOVEI X1,LINLEN
        MOVNM X1,NCOUNT
PUTNEW: MOVE OLD,DIC
PUT2:   ILDB CH,OLD
        JUMPE CH,PUT3           ;ALL DONE?
        CAIN CH,15              ;CARRIAGE RETURN?
        JRST PUT3
        PUSHJ P,CKCNT
        TLNE F,EDI.F
        PUSHJ P,PRTCH2
        IDPB    CH,NEW
        JRST    PUT2

PUT3:   PUSHJ   P,DEPCNT
        MOVEM   X1,NEWBCB+BCBMAX
        POPJ    P,

;ROUTINE TO PUT TEXT POINTED TO BY DIC INTO OLD LINE IMAGE

SETOLD: PUSHJ P,SETNEW
        PUSHJ P,SWITCH          ;MOVE CONTENTS TO OLD LINE
        POPJ P,                 ;AND RETURN

SETLI1: MOVE NEW ,NEWPNT
        SETZM (NEW)
        HRR X1,NEW
        AOJ X1,
        HRL X1,NEW
        BLT X1,BUFLEN-1(NEW)
        HRRM    NEW,NEWBCB+BCBADR
        SETZM   NEWBCB+BCBMIN
        SETZM   NEWBCB+BCBMAX
        SETZM   NEWBCB+BCBPNT
        POPJ P,
;CHANGE COMMAND
; FORMAT R CHANGE

CHANGE: ASCIZ/HANGE/
        PUSH P, FLRNG           ;SAVE FIRST ARGUMENT
        SKIPE CERNG             ;IS THERE SECOND ARGUMENT?
        JRST CHANG1             ;YES
        MOVE X1,FLRNG           ;MAKE DEFAULT SECOND ARGUMENT
        MOVEM X1,CERNG
CHANG1: PUSHJ P,DELLOC          ;DELETE THOSE LINES TO BE CHANGED
        MOVE X1,CURLIN          ;THE LINE BEFORE THE INSERT
        PUSHJ P,SETLIN          ;MAKE LINE BEFORE INSERT OLD LINE IMAGE
        POP P, TMPLIN
        TRO F,INS.F             ;INSERT MODE
        JRST INSRT              ;START INSERTING NEWLINE AT TMPLIN
;DELETE COMMAND
; FORMAT R DELETE OR DELETE(LF),OR DELETE ^

FNDDE:  IFNBFR <OUTSTR  WAIT>
        PUSHJ P,YORN
        TRZA F,WAIT.F
        TRO F,WAIT.F
        MOVEI X1,FNDDEL
        MOVEM X1,COMAN
        POPJ P,

FNDDEL: TRNN F,WAIT.F
        JRST FNDDE1
        PUSHJ P,FNDPR
        IFNBFR <OUTSTR  OK>
        PUSHJ P,YORN
        POPJ P,

FNDDE1: PUSH P,FLRNG
        PUSH P,CERNG
        MOVE X1,LINE
        MOVEM X1,FLRNG
        MOVEM X1,CERNG
        PUSHJ P,DELLOC
        MOVE X1,FLRNG
        CAMG    X1,SVLIN        ;IF DELETED LINE WAS AFTER THE FIND OR MARK SEARCH REFERENCE LINE,
        SOS     SVLIN           ;DO NOT ADJUST SEARCH CONTEXT
        POP P, CERNG
        POP P,FLRNG
        SOS CERNG
        POPJ P,

        JRST FNDDE
DELETE: ASCIZ/ELETE/
        TRNE F,MARK.F
        JRST [PUSHJ P,CKRNG
        PUSHJ P,FNDDE
        JRST MARKST]
        PUSHJ P,LFORUP  ;LFOR UPARW
        PUSHJ P,DELLOC
        JRST GETCOM


;ROUTINE TO SEE IF LF OR UPAR FOLLOWS COMMAND

LFORUP: SKIPE FLRNG     ;ANYTHING BEFORE COMMAND?
        JRST LFORU0     ;YES SO RANGE ALREADY CALC
        HLLI CH,0       ;CLEAR LEFT 
        CAIN CH,12      ;LF?
        JRST [MOVE X1,CURLIN
        AOJ X1,
        JRST LFORU2]
        CAIE CH,"^"
        JRST QUEST
        MOVE X1,CURLIN
        SOJ X1,
LFORU2: CAIN X1,DICT
        JRST QUEST
        MOVEM X1,FLRNG
        MOVEM X1,CERNG
        JRST CKRNG2
LFORU0: SKIPE CERNG
        JRST CKRNG2
        MOVE X1,FLRNG
        MOVEM X1,CERNG
        JRST CKRNG2

;ROUTINE TO DEL BLOCK OF LINES BEGING AT FLRNG AND END AT CERNG

DELLOC: PUSHJ P,DELDIC          ;DELETE THE LINES
        PUSHJ P,INCMOD          ;AND MAKE A MODIFICATION
        POPJ P,

DELDIC: MOVE X1,FLRNG
        CAIG X1,DICT
        MOVEI X1,DICT+1         ;DEFAULT LOWER BOUND
        MOVE X2,CERNG
        CAMG X1,X2
        CAMLE X2,LASLIN
        JRST QUEST
        SKIPN EOF               ;MORE TO READ IN FROM INPUT FILE?
        JRST DELEA              ;NO
        EXCH X1,X2              ;YES-READ IN ALL LINES OF RANGE
        PUSH    P,X1
        PUSHJ P,ADDIN1          ;UP TO CERNG
        POP P,X1
        EXCH X1,X2
DELEA:  SOJ X1,
        PUSHJ P,%OFFESC         ;DISABLE ESCAPES-KEEP ORDER IN HOUSE
        CAIN X1,DICT
        MOVEI X1,DICT+1         ;DEFAULT LOWER BOUND FOR CURLIN
        MOVEM X1,CURLIN         ;UPDATE CURLIN
        MOVE X1,LASLIN
        PUSH P,LASLIN           ;SAVE OLD LASLINE
        SUB X1,CERNG            ;X1 CONTAINS NO OF LINES AVAIL
                                ;TO MOVE BEG AT CERNG+1
        JUMPN X1,DELE3          ;DON'T NEED TO MOVE ANYTHING IF X1=0
        MOVE X2,FLRNG   ;DEL FROM FLRNG DOWN
        SOJ X2,
        JRST DELE4
DELE3:  MOVE X2,X1
        SOJ X2, ;X2/LASLIN-CERNG+FLRNG-1
        ADD X2,FLRNG            ;NEW LAST LINE
        MOVE X1,CERNG
        AOJ X1,
        HRL X1,X1
        HRR X1,FLRNG    ;X1 CONTAINDS [CERNG+1,FLRNG]
        BLT X1,(X2)
DELE4:  MOVEM X2,LASLIN
        CAIN X2,DICT
        MOVEM X2,CURLIN         ;UPDATE CURLIN ONLY IF ALL LINES WERE DELETED
        MOVE X1,X2
        AOJ X1,
        SETZM (X1)              ;PUT 0 AT END OF DICTIONARY
        POP P, X3               ;GET OLD LASLIN
        CAMN X1,X3
        JRST DELE5              ;DELETED 1 LINE
        HRL X1,X1               ;ZERO OUT REST OF DICT
        AOJ X1,
        BLT X1,(X3)
DELE5:  HRLI X2,0
        CORE X2,                ;SHRINK CORE IF NECESSARY
        JRST %COFAL
        PUSHJ P,%ONESC          ;RE-ENABLE ESCAPES
        SKIPN EOF
        POPJ P,
        MOVE X1,LASLIN
        MOVEM X1,READLN
        POPJ P,

MIN1:   -1
;EDIT COMMAND
; FORMAT- R EDIT OR EDIT(LF) OR EDIT ^

FNDMD:  CAME CH,CRFLG
        JRST QUEST
FNDMD1: TLZA F,EDI.F
FNDED:  TLO F,EDI.F
        TRO F,KEEPV
FNDED1: MOVEI X1,EDIT1
        MOVEM X1,COMAN
        POPJ P,
        JRST FNDED
EDIT:   ASCIZ/DIT/
        TLO F,EDI.F             ;EDIT MODE- IMPLIES PRINT LINE TO SUB D1
        TRO F,KEEPV
        TRNE F,MARK.F
        JRST [PUSHJ P,CKRNG
        PUSHJ P,FNDED1
        JRST MARKST]
        PUSHJ P,LFORUP          ;FIND OUT LF,UP OR RANGE?
        MOVE LINE,FLRNG
EDIT1:  MOVEM LINE,CURLIN
        MOVE X1,LINE            ;SET UP CALL TO SETLIN
        PUSHJ P,SETLIN          ;PUT LINE INTO OLDLIN AND PRINT AT SAME TIME IF EDIT MODE
        TLNE F,EDI.F            ;EDIT MODE?
        TRNE F,COMF.F!BUF.F     ;IF IN BUFFER OR COMFILE DO NOT PRINT LF
        SKIPA
        OUTSTR   CRLF           ;EDIT-MODE (NOT MODIFY) SO PRINT CRLF AFTER LINE
EDIT3:  MOVEI   X1,3
        PUSHJ   P,TIE
        CAIE    X1,NORMAL       ;NORMAL END OF LINE?
        JRST    EDISPL          ;NO-SPLIT LINE
        PUSHJ P,ADDLIN          ;EXIT HERE WHEN DONE- ADD LINE TO UPDATE AREA
        PUSHJ P,MAKDIC          ;MAKE A DICT POINTER
        SKIPN MRKDIC
        JRST EDIT2
        MOVE X1,MRKDIC
        TRO DIC,(X1)
EDIT2:  MOVEM DIC,(LINE)        ;ADD TO DICT
        MOVEM LINE,CURLIN
        PUSHJ P,INCMOD
        TRNE F,FND.F
        JRST [MOVEM LINE,SVLIN
                POPJ P,]
        AOJ LINE,
        CAMG LINE,CERNG         ;ARE WE THROUGH WITH RANGE
        JRST EDIT1              ;NO
        JRST GETCOM

EDISPL: PUSHJ   P,ADDLIN
        PUSHJ   P,MAKDIC
        SKIPN   MRKDIC
        JRST    EDISP2
        MOVE    X1,MRKDIC
        TRO     DIC,(X1)
EDISP2: MOVEM   LINE,TMPLIN
        PUSHJ   P,INSER
        MOVEM   LINE,CURLIN
        AOS     CERNG
        AOJ     LINE,
        MOVE    X1,OLDBCB+BCBPNT
        MOVEM   X1,OLDBCB+BCBMIN        ;OLD LINE IS WHAT'S LEFT
        JRST    EDIT3
; R EXIT COMMAND- WRITE FILE AND QUIT

EXITCM: ASCIZ/IT/
        PUSHJ P,AUTOWR          ;WRITE DEFAULT OR GIVEN FILE IF NEC.
        JRST EGRESS             ;AND LEAVE
;FIND COMMAND-
;FORMAT- R FIND (CONDITIONAL EXP) COMMAND
;FCMND-CONTAINS FIND COMMAND - STUFF AFTER "FIND" IN ASCII
;SOURCE- CONTAINS TOKEN CODES IN GIVEN ORDER
;SRCPNT- CONTAINS POINTERS TO THE STRINGS WITHIN FCMND
;POLISH- CONTAINS POLISH NOTATION OF CONDITIONAL EXPRES.
;OHIER- A STACK USED TO GET TOKENS IN REVERSE POLISH ORDER

POLPNT: POINT 7,POLISH
FIND: ASCIZ/IND/
        PUSHJ P,CKRNG           ;SET FLRNG,CERNG
        SETOM GIVCNT
        SETZM FCMND
        MOVE X1,[XWD FCMND,FCMND+1]
        BLT X1,OHIER+^D24
        MOVE OLD,FNDPNT
        IDPB CH,OLD
        ILDB CH,NEW             ;MOVE REST OF TEXT OF COMMAND INTO FCMND
        CAIE CH,0
        JRST .-3
        MOVE NEW,FNDPNT
        PUSHJ P,GETCH           ;GET NEXT NON-BLANK FROM NEW
        MOVEI LINE,1            ;COUNTER FOR SRCPNT
        MOVEI SPT,1             ;COUNTER FOR SOURCE
        SETZM OCOUNT            ;COUNTER FOR PARENTHESES NESTING LEVEL
        MOVEI SCH,101           ;BEG STRING NO.

;PARSE THE STRING EXPRESSION:
;TOKENS ARE DIVIDED INTO TWO GROUPS: OPERANDS AND OPERATORS.
;EACH OPERATOR HAS A SEVEN-BIT CODE (AND CAN THEREFORE BE TREATED AS
;ASCII CHARACTERS) AS FOLLOWS:
;   61  (
;   62  )
;   63  OR
;   64  AND
;   65  ...
;   66  NOT
;
;AN OPERAND IS A STRING TO SEARCH FOR OR A PREVIOUSLY PARSED STRING
;EXPRESSION. STRINGS ARE KNOWN BY A UNIQUE NUMBER STARTING AT OCTAL 101.
;THE CHARACTER POINTER ASSOCIATED WITH A STRING IS FOUND AT
;SRCPNT(NUMBER-100). THE POINTER POINTS TO THE DELIMITER PRECEDING THE STRING.
;
;ELLIPSES (...) IS TREATED IN A UNIQUE WAY, BECAUSE IT IS REALLY NEITHER
;AN OPERAND NOR OPERATOR, BUT A COMBINATION. IT IS THEREFORE SPLIT INTO
;TWO TOKENS: THE FIRST IS STORED IN THE POLISH STRING AS AN OPERAND.
;IT IS KNOWN BY CODE 100. BOTH THE FIRST AND THE SECOND CODES, HOWEVER,
;ARE TREATED AS OPERATORS DURING EXPRESSION MATCHING.

;THE FIND COMMAND GOES THROUGH THE FOLLOWING STEPS:
;1. GO THROUGH THE REST OF THE COMMAND, IDENTIFYING BOOLEAN TOKENS AND
;   STRINGS, PUTTING THEIR ASCII CODES INTO THE ARRAY SOURCE IN THE ORDER
;   IN WHICH THEY ARE FOUND.
;2. FIND THE EDITOR COMMAND AT THE END OF THE FIND COMMAND AND MAKE SURE
;   IT IS LEGAL TO USE WITH FIND. STORE THE DISPATCH ADDRESS.
;3. MAKE A POLISH EXPRESSION FROM THE ARRAY SOURCE. THE ARRAY OHIER IS
;   USED AS A STACK TO HOLD OPERATORS UNTIL THEY ARE ADDED TO THE
;   POLISH EXPRESSION.
;4. GO THROUGH THE POLISH EXPRESSION, MAKING SURE EVERY BINARY OPERATOR
;   HAS TWO OPERANDS AND EVERY UNARY OPERATOR HAS ONE.
;5. INITIALIZE THE EDITOR COMMAND IN QUESTION.
;6. FOR EACH LINE TO BE SEARCHED BY THE FIND COMMAND, GO THROUGH THE
;   POLISH STRING OF ASCII TOKEN CODES TO GET A TRUE OR FALSE VALUE ON 
;   THE EXPRESSION. THIS IS DONE USING THE CALL STACK TO STORE INTERMEDIATE
;   RESULTS, SO THAT AT THE END OF THE EVALUATION, ONLY ONE ELEMENT IS LEFT
;   ON THE STACK: THE VALUE OF THIS ELEMENT WILL BE THE VALUE OF THE
;   EXPRESSION.
;7. IF THE EXPRESSION IS TRUE, CALL THE COMMAND TO PROCESS THE LINE.

FIND5: TLNE CH,LET.F            ;LETTER?
        JRST FFIND1             ;YES
        TLNE CH,ACT.F           ;COULD BE SLASH,ETC
        JRST FIND7              ;BETTER BE COMMAND
        CAME CH,.CTTAB+"("
        CAMN CH,.CTTAB+")"
        JRST FIND2
        CAMN CH,.CTTAB+"."
        JRST FIND3
        TLNE CH,DEL.F           ;DELIMETER?
        JRST FIND4              ;YES
        CAMN CH,.CTTAB+";"
        JRST FNDSEM             ;BUFFER LOAD OR GET COMMAND
        TLNN CH,TERM.F          ;LINE TERMINATOR?
        JRST QUEST              ;NO
        CAMN CH,CRFLG           ;CAR RET?
        JRST FIND7              ;YES
        PUSHJ P,GETCH
        JRST FIND5              ;LF

FNDSEM: PUSHJ P,GETCH           ;BUFFER LOAD OR GET COMMAND-LOOK FOR BUFFER NO
        TLNN CH,NUM.F           ;HAS TO BE NUMERIC
        JRST QUEST
        PUSHJ P,MAKOCT
        CAIL NUM,0
        CAILE NUM,11            ;BUFFER NO MUST BE 0 TO 9
        JRST QUEST
        MOVEM NUM ,BUFNO
        TLNN CH,LET.F
        JRST QUEST
        JRST FIND7              ;BETTER BE LOAD OR GET COMMAND

DEFINE U(A)
<ASCIZ/A/
>

CONDIT: U(AND)
        U(AN)
        U(A)
        U(NOT)
        U(N)
        U(OR)
        U(O)
        U(ANN)
        U(ANNO)
CONEND==.-CONDIT

TCON:   U(4)
        U(4)
        U(4)
        U(6)
        U(6)
        U(3)
        U(3)
        U(46)           ;NOTE THAT CODE FOR ANNO IS EQUIV TO CODE FOR AND
        U(46)           ;FOLLOWED BY CODE FOR NOT.

;LOOK FOR A BOOLEAN OPERATOR:
;THE TOKEN FOUND IS PUT INTO WORD AND COMPARED TO THE ENTRIES OF THE
;ARRAY TCON.

FFIND1: SETZ X3,                ;LOOK FOR BOOLEAN
        SETZM WORD              ;PUT TOKEN IN WORD
        PUSH P,NEW              ;SAVE POINTER IN CASE NO BOOLEAN
        PUSH P,CH
        MOVE X2,WRDPNT
FIND1B: PUSHJ P,BOOLUP          ;CONVERT CH TO UPPER CASE
        IDPB CH,X2
        AOJ X3,                 ;COUNT OF CHARS ALREADY DEPOSITED
        PUSHJ P,GETCHR
        TLNN CH,LET.F
        JRST FIND1A             ;NOT A LETTER
        CAIGE X3,5
        JRST FIND1B
FIND1A: SETZ X3,                ;TOKEN NOW IS IN WORD
        MOVE NUM,WORD
FIND1C: CAMN NUM,CONDIT(X3)
        JRST FIND1D             ;MATCH
        AOJ X3,                 ;TRY NEXT OPERATOR
        CAIG X3,CONEND          ;ANY MORE?
        JRST FIND1C             ;YES
        POP P,CH                ;DIDN'T FIND A BOOLEAN; RESTORE POINTER & CH
        POP P,NEW
        JRST FIND7              ;HOPE IT'S A COMMAND

BOOLUP: HRRZ    CH,CH
        CAIL    CH,"a"
        CAILE   CH,"z"
        JRST    BOOL$
        SUBI    CH,^O40
BOOL$:  HLL     CH,.CTTAB(CH)
        POPJ    P,

;WE HAVE FOUND A BOOLEAN OPERATOR; TRANSFER ITS CODE SEQUENCE INTO THE
;ARRAY SOURCE AND THEN GO LOOK FFOR MORE TOKENS (FIND5).

FIND1D: MOVEI X2,TCON(X3)       ;FOUND A BOOLEAN OPERATOR
        HRLI X2,440700          ;MAKE A POINTER TO THE CODE
FIND1E: ILDB X3,X2
        SKIPN X3                ;END OF CODE?
        JRST FIND1F             ;YES
        MOVEM X3,SOURCE(SPT)    ;MOVE CODE INTO SOURCE ARRAY
        AOJ SPT,                ;AND INCREMENT ARRAY INDEX
        JRST FIND1E

;CODE FOR BOOLEAN OPERATOR SUCCESSFULLY IN ARRAY SOURCE:

FIND1F: PUSHJ   P,ISITSP        ;A SPACE?
        SKIPA                   ;NO
        PUSHJ P,GETCH           ;LOAD UP NEXT NON-BLANK
        POP P,
        POP P,
        JRST FIND5              ;AND GO LOOK FOR MORE STUFF

;FOUND A PARENTHESIS:

FIND2:  CAMN CH,.CTTAB+"("
        JRST FIND2A
        SOSGE OCOUNT            ;A RIGHT PAREN-- TOO MANY?
        JRST QUEST              ;YES
        MOVEI CH,62             ;TOKEN CODE FOR )
        JRST .+3
FIND2A: AOS OCOUNT              ;ADD ONE TO PARENTHESIS NESTING LEVEL COUNT
        MOVEI CH,61
        MOVEM CH,SOURCE(SPT)    ;DEPOSIT CODE INTO ARRAY SOURCE
        AOJ SPT,                ;AND INCREMENT ARRAY INDEX
        PUSHJ P,GETCH           ;LOAD UP THE NEXT NON-BLANK
        JRST FIND5              ;AND GO LOOK FOR MORE STUFF

;FOUND ... (ELLIPSIS)

FIND3:  MOVEI CH,65             ;CODE FOR ELLIPSIS
        MOVEM CH,SOURCE(SPT)    ;STORE IN SOURCE ARRAY
        PUSHJ P,GETCH
        CAMN CH,.CTTAB+"."      ;GET REST OF TOKEN
        JRST .-2
        AOJ SPT,                ;INCREMENT ARRAY INDEX
        JRST FIND5              ;AND GO LOOK FOR MORE STUFF

;DELIMETER - MUST BE A QUOTED STRING

FIND4:  MOVEM NEW,SRCPNT(LINE)   ;SAVE POINTER TO BEGINNING OF STRING
        TLNE CH,ADD2.F
        ADDI CH,2               ;ADD TWO TO GET ASCII OF MATCHING DELIMITER
        TLZ CH,777777
        MOVEM CH,DELIM
FIND4A: CAIN    CH,0            ;ARE WE AT THE END OF THE LINE?
        JRST QUEST              ;YES
        ILDB CH,NEW
        CAME CH,DELIM
        JRST FIND4A
        MOVEM SCH,SOURCE(SPT)   ;IF LEGAL, STORE CODE FOR THIS STRING IN ARRAY
        AOJ LINE,
        AOJ SCH,
        AOJ SPT,
        PUSHJ P,GETCH
        JRST FIND5

    ;GET A COMMAND

FIND7: SKIPE OCOUNT             ;ARE PARENS ALL PAIRED UP?
        JRST QUEST              ;NO
        PUSHJ P,FNDCOM          ;GET COMMAND
        HLRZ X2,CMDADR(NUM)
        TRNN X2,FND             ;ALLOWED?
        JRST QUEST
        MOVE X3,COMAN
        TRZ X2,777000           ;CLEAR FLAGS
        AOJ X2,
        SUB X3,X2               ;FIND ADR-1
        MOVEM X3,COMAN          ;COMAN CONTAINS PRELIM ADR
        MOVEM NEW,WORD+1        ;SAVE NEW

;NOW WE DO THE POLKA!!
;GET THE EXPRESSION IN REVERSE POLISH NOTATION (AS CHARACTER CODES IN
;ADDRESS POLISH):

        MOVE NEW,POLPNT         ;MAKE POINTER TO POLISH
        MOVEM SPT,WORD          ;SAVE ARRAY INDEX (LAST+1 ENTRY)
        SETZM SOURCE(SPT)       ;MAKE SURE IT'S ZERO
        MOVEI SPT,1             ;RENEW INDEX
        MOVEI SCH,2             ;USE AS INDEX TO STACK OHIER
        SETOM OHIER(SPT)        ;BOTTOM OF STACK GETS -1

POL3:  MOVE X1,SOURCE(SPT)      ;GET CODE FOR THE TOKEN
        CAIGE X1,100            ;OPERAND? (I.E., STRING?)
        JRST POL4               ;NO, OPERATOR
        IDPB X1,NEW             ;YES, DEP IN POLISH
        AOJ SPT,
        MOVE X1,OHIER-1(SCH)    ;GET LAST ENTRY IN STACK
        MOVE X2,SOURCE(SPT)     ;AND NEXT TOKEN CODE
POL6A:  CAILE X2,100
        SETZ X2,                ;OPERANDS HAVE LOWEST PRECEDENCE

POL6:   CAMGE X1,X2             ;IS LAST STACKED TOKEN (X1) HIGHER OR EQUAL
                                ;PRECEDENCE THAN TOKEN IN HAND (X2) ?
        JRST POL5               ;NO
        IDPB X1,NEW             ;YES, DEPOSIT IT FIRST
        SOJ SCH,                ;AND UNSTACK
        MOVE X1,OHIER-1(SCH)    ;DEPOSIT ALL STACK ENTRIES W/HIGHER PRECEDENCE
        JRST POL6

POL5:   CAMN SPT,WORD           ;DONE?
        JRST POLEND             ;YES
        JRST POL3

;AN OPERATOR.
;STACK IT, UNLESS RIGHT PAREN, WHERE WE UNSTACK THROUGH THE LEFT PAREN.

POL4:   SKIPN X1                ;CODE =0 ILLEGAL
        JRST QUEST
        CAIE X1,62              ;CODE FOR ")"
        JRST POL7               ;NORMAL OPERATOR

;GOT A RIGHT PAREN. EVERYTHING ALREADY UNSTACKED EXCEPT THE LEFT PAREN.

        AOJ SPT,
        SOJ SCH,                ;UNSTACK THE (
        MOVE X1,OHIER-1(SCH)
        MOVE X2,SOURCE(SPT)
        JRST POL6A              ;CONTINUE COMPARE

;NORMAL OPERATOR:

POL7:   MOVE X1,SOURCE (SPT)
        MOVEM X1,OHIER(SCH)     ;STACK IT
        AOJ SPT,
        AOJ SCH,
        CAIE X1,65              ;ELLIPSIS?
        JRST POL3               ;NO - CONTINUE
        MOVEI X1,100            ;DEPOSIT IT AS OPERAND WITH CODE 100
        IDPB X1,NEW
        JRST POL3

POLEND: SETZ SPT,               ;COUNTER FOR OPERAND-OPERATOR MATCHING
        MOVE NEW,POLPNT         ;POINTER TO FIRST POLISH TOKEN
WFF:    ILDB CH,NEW             ;GET TOKEN CODE
        CAIGE CH,100            ;STRING OR ELLIPSIS?
        JRST WFF1               ;NO,OPERATOR
        CAIE CH,100             ;ELLIPSIS?
        AOJ SPT,                ;NO- SO ADD 1 TO OPERAND COUNT
        JRST WFF
WFF1:   CAIE CH,0               ;END OF TOKENS?
        JRST WFF2               ;NO
        CAIE SPT,1              ;YES, BETTER HAVE EXACTLY ONE TOKEN LEFT
        JRST QUEST
        JRST FINDOK             ;HOORAY FOR HOLLYWOOD! EXPRESSION IS LEGAL.

WFF2:   CAIE CH,63              ;OR
        CAIN CH,64              ;AND
        JRST WFF3               ;A BINARY OPERATOR
        CAIN CH,65              ;... (ELLIPSIS) ?
        JRST WFF3               ;YES, BINARY OPERATOR
        JRST WFF3+1             ;UNARY OPERATOR
WFF3:   SOJ SPT,                ;DECREMENT OPERAND COUNT 1 FOR BINARY OP
        CAIG SPT,0              ;MAKE SURE THERE'S STILL AN OPERAND
        JRST QUEST
        JRST WFF


;BOOLEAN BYTES NOW PARSED AND IN POLISH FORM (IN WORD POLISH) AND LEGAL.
;GO THROUGH EVERY TEXT LINE IN THE GIVEN RANGE AND SEE IF THE BOOLEAN
;STRING EXPRESSION IS SATISFIED. USE THE CALL STACK TO HOLD INTERMEDIATE
;OPERANDS, POPPING THEM WHEN TIME TO OPERATE ON THEM. EVERY OPERAND
;CARRIES WITH IT IN THE STACK A CHARACTER POINTER TO THE END OF THE SEARCH
;ASSOCIATED WITH THAT OPERAND. THIS IS USED FOR THE ELLIPSIS OPERATOR.

        OPRA==X1                ;OPERAND A
        OPRB==X2                ;OPERAND B

FINDOK: MOVE NEW,WORD+1         ;POINTER INTO FCMND
        LDB CH,NEW
        HLL CH,.CTTAB(CH)        ;GET CHARACTER FLAGS
        TRO F,FND.F
        SETZM ENDCM
        PUSHJ P,@COMAN          ;INITIALIZE THE COMMAND
MARKST: MOVEM P,SVFNDP          ;SAVE STACK POINTER FOR LATER CLEANUPS
        SETZM NOFNDS            ;INIT THE "HOW MANY FOUND" COUNTER
        TRO F,FND.F
        MOVE LINE,FLRNG         ;START OF RANGE (ADDR IN DICT OF FIRST LINE)
FINDO1: MOVEM LINE,SVLIN        ;COME HERE AFTER INC OF LINE, SVLIN WAS
                                ;WHERE WE STARTED FROM
        MOVE X1,POLPNT          ;GET POINTER TO POLISH TOKENS
        MOVEM X1,POLPT          ;RENEW POINTER INTO POLISH FOR EACH LINE
        MOVE P,SVFNDP           ;CLEAN UP STACK
        MOVE DIC,(LINE)         ;GET DICTIONARY ENTRY
        TRNN F,MARK.F           ;@?
        JRST POLST3             ;NO
        PUSHJ P,TSTMAR          ;YES-IS LINE MARKED?
        JRST POLDO4             ;LINE NOT MARKED-NEXT LINE (GOES TO FINDO1)
        SKIPN MODMAR            ;LINE IS MARKED - SEE IF @i+n
        JRST POLST3             ;NO
        XCT MODMAR              ;YES, ADD n TO LINE
        CAIG LINE,DICT
        JRST POLDO1             ;NO SUCH LINE, GET NEXT MARKED LINE
        MOVE X1,LINE
        PUSHJ P,ADDIN1          ;MAKE SURE THE ENTRY IS IN CORE
        CAMLE X1,LASLIN         ;EXISTS?
        JRST POLDO5             ;NO, ALL DONE.
        MOVE DIC,(LINE)
POLST3: PUSHJ P,MAKPN1          ;GET CHAR POINTER INTO WINDOW OR UPDATE AREA
        JRST POLDO1             ;FAILURE-NO SUCH LINE, TRY NEXT
        MOVEM DIC,BEGDIC        ;SAVE ORIGINAL LINE POINTER FOR LATER ELLIPSIS
POLST2: ILDB X1,POLPT           ;GET NEXT TOKEN
        SKIPN X1
        JRST POLDON             ;NO MORE
        CAIG X1,100             ;A STRING?
        JRST FNDOPR             ;NO, AN OPERATOR, DO THE OP AND STACK THE RESULT, TRUE OR FALSE
        SUBI X1,100             ;GET STRING NO.
        MOVE X1,SRCPNT(X1)      ;POINTER TO STRING WITHIN FIND COMMAND
        PUSH P,                 ;MAKE AN EMPTY ENTRY FOR THIS OPERAND'S SVPTR
        PUSH P,X1               ;STACK THE OPERAND
        JRST POLST2

TSTMAR: CAMN DIC,MIN1           ;LINE IN DICTIONARY?
        JRST POLDO5             ;NO
         MOVE X1,MARKNO
        TRNE DIC,(X1)           ;IS THE LINE MARKED?
        AOS (P)                 ;YES-SKIP RETURN
        POPJ P,                 ;NO- NON-SKIP

FNDOPR: CAIN X1,100             ;ELLIPSIS?
        JRST FOLLOW             ;YES (THIS WAS IN POLISH AS OPERAND)
        SUBI X1,60              ;CODE FOR OPERATOR
        JRST .(X1)
        JFCL                    ;(
        JFCL                    ;)
        JRST OR                 ;OR
        JRST AND                ;AND
        JRST ELLIPS             ;ELLIPSIS
        JRST NOT                ;NOT

OR:     POP P,OPRB
        POP P,SVPTRB            ;GET SVPTR ENTRY FOR THIS OPERAND
        POP P,OPRA
        POP P,SVPTRA
        CAIE OPRA,1             ;OPERND A TRUE?
        JRST ORNTA1             ;NO
        MOVE X1,SVPTRA          ;YES
        MOVEM X1,SVPTR          ;SET POINTER
        JRST TRU
ORNTA1: CAIE OPRB,1             ;OPR B TRUE?
        JRST ORNTB1             ;NO
        MOVE X1,SVPTRB
        MOVEM X1,SVPTR          ;YES, SET POINTER
        JRST TRU
ORNTB1: MOVEM OPRB,SVOPRB       ;SAVE VALUE OF OPER B
        SKIPN OPRA              ;OPERAND A KNOWN TO BE FALSE?
        JRST ORNOTA             ;YES
        MOVE SERCH,OPRA         ;LOOK FOR OPRA
        MOVEM DIC,BEGSER        ;WHERE AT
        PUSHJ P,FNDTRT          ;LOOK FOR STR
        MOVE X1,TRUTH           ;GET RESULT
        CAIN X1,1               ;FOUND?
        JRST TRU                ;YES
ORNOTA: MOVE OPRB,SVOPRB        ;OPR A WAS FALSE - CHECK OPR B
        SKIPN OPRB              ;OPR B FALSE TOO?
        JRST FALS               ;YES
        MOVE SERCH,OPRB         ;LOOK FOR OPR B
        MOVEM DIC,BEGSER
        PUSHJ P,FNDTRT
        MOVE X1,TRUTH           ;GT RESULT
        CAIN X1,1               ;FIND OPR B?
        JRST TRU
        JRST FALS

FALS:   SETZM TRUTH
        PUSH P,SVPTR            ;PUT SVPTR ONTO STACK WITH VALUE
        PUSH P,TRUTH            ;STACK TRUE OR FALSE - THIS IS NOW AN OPERAND
        JRST POLST2             ;CONTINUE THROUGH EXPRESSION
TRU:    MOVEI X1,1
        MOVEM X1,TRUTH
        JRST FALS+1

AND:    POP P,OPRB
        POP P,SVPTRB
        POP P,OPRA
        POP P,SVPTRA
        SKIPN OPRA              ;OPRA KNOWN FALSE?
        JRST [MOVE X1,SVPTRA    ;YES
              MOVEM X1,SVPTR
              JRST FALS]
        SKIPN OPRB              ;OPRB KNOWN FALSE?
        JRST [MOVE X1,SVPTRB    ;YES
              MOVEM X1,SVPTR
              JRST FALS]
        MOVEM OPRB,SVOPRB       ;SAVE OPR B
        CAIN OPRA,1             ;OPR A KNOWN TRUE?
        JRST ANDA1              ;YES-VAL OF EXPR DEPENDS ON OPR B
        MOVE SERCH,OPRA         ;EVAL OPR A
        MOVEM DIC,BEGSER
        PUSHJ P,FNDTRT
        MOVE X1,TRUTH           ;GET RESULT
        CAIE X1,1
        JRST FALS
        MOVE X1,SVPTR
        MOVEM X1,SVPTRA         ;SET SVPTR FOR OPR A
ANDA1:  MOVE OPRB,SVOPRB        ;OPR A IS TRUE, EVAL OPR B
        CAIN OPRB,1             ;OPR B TRUE?
        JRST RETPTR             ;YES, RETURN TRUE
        MOVE SERCH,OPRB         ;EVAL OPR B
        MOVEM DIC,BEGSER
        PUSHJ P,FNDTRT
        MOVE X1,TRUTH
        SKIPN TRUTH
        JRST FALS
        MOVE X1,SVPTR
        MOVEM X1,SVPTRB         ;SET SVPTR FOR OPR B

;PUT LARGEST SVPTR INTO SVPTR AND GO TO TRU:

RETPTR: HRRZ X1,SVPTRA
        HRRZ X2,SVPTRB
        CAMLE X1,X2             ;COMPARE ADDRS
        JRST RETPTA             ;RETURN SVPTRA
        CAMGE X1,X2
        JRST RETPTB             ;RETURN SVPTRB
        HLRZ X1,SVPTRA          ;GET POINTER BITS
        HLRZ X2,SVPTRB
        CAMGE X1,X2
        JRST RETPTB
RETPTA: MOVE X1,SVPTRA
        SKIPA
RETPTB: MOVE X1,SVPTRB
        MOVEM X1,SVPTR
        JRST TRU

FOLLOW: CAMN P,SVFNDP           ;ANY OPERAND BEFORE?
        JRST POLST2             ;NO, IGNORE ...
        POP P,OPRA
        POP P,SVPTRA
        SKIPE OPRA              ;KNOWN FALSE?
        JRST FOLLA              ;NO, MUST EVAL
FOLFLS: MOVE X1,SVPTRA          ;OPR A FALSE
        MOVEM X1,SVPTR
        JRST FALS
FOLLA:  CAIE OPRA,1             ;KNOWN TRUE?
        JRST FOLLA1             ;NO, MUST EVAL
FOLTRU: SKIPN SVPTRA
        JRST FOLFLS             ;IF PTR=0 THEN CAN'T BE FOLLOWED
        MOVE DIC,SVPTRA         ;OPR A TRUE, CHANGE START SEARCH PLACE
        MOVEM DIC,SVPTR
        JRST TRU
FOLLA1: MOVE SERCH,OPRA
        MOVEM DIC,BEGSER        ;LOOK FOR OPR A
        PUSHJ P,FNDTRT
        MOVE X1,SVPTR
        MOVEM X1,SVPTRA         ;PUT POINTER INTO PTR FOR OPR A
        MOVE X1,TRUTH           ;GET RESULT
        CAIE X1,1
        JRST FOLFLS
        JRST FOLTRU

ELLIPS: POP P,OPRB
        POP P,SVPTRB
        POP P,OPRA
        POP P,SVPTRA
        SKIPE OPRA              ;OPR A KNOWN FALSE?
        JRST ELLB               ;OPR A KNOWN TRUE, LOOK AT OPR B
        MOVE X1,SVPTRA          ;A FALSE
        MOVEM X1,SVPTR
        JRST ELLFLS
ELLB:   SKIPN OPRB              ;OPR B KNOWN FALSE?
        JRST [MOVE X1,SVPTRB    ;YES
              MOVEM X1,SVPTR
              JRST ELLFLS]
        CAIE OPRB,1             ;KNOWN TRUE?
        JRST ELBVAL             ;NO, MUST EVAL
        MOVE X1,SVPTRB          ;B TRUE
        MOVEM X1,SVPTR
        JRST ELLTRU
ELBVAL: MOVE SERCH,OPRB
        MOVEM DIC,BEGSER
        PUSHJ P,FNDTRT
        SKIPE TRUTH
        JRST ELLTRU
        JRST ELLFLS

;END OF ELLIPSIS, RESTORE LINE POINTER TO BEGINNING OF LINE:

ELLFLS: MOVE DIC,BEGDIC
        JRST FALS

ELLTRU: MOVE DIC,BEGDIC
        JRST TRU

NOT:    POP P,OPRA
        POP P,SVPTRA
        SETZM SVPTR             ;NO POINTER ENTRY FOR NOT
        SKIPN OPRA              ;OPR KNOWN FALSE?
        JRST TRU                ;YES, RETURN TRUE
        CAIN OPRA,1             ;KNOWN TRUE?
        JRST FALS               ;YES, RETURN FALSE
        MOVE SERCH,OPRA         ;MUST EVAL
        MOVEM DIC,BEGSER
        PUSHJ P,FNDTRT
        SETZM SVPTR             ;NO POINTER ENTRY FOR NOT
        SKIPE TRUTH
        JRST FALS
        JRST TRU

FNDTRT: TLZ F,CRORBL
        SETZM TAGFLG
        SETZM EOR
        LDB CH,SERCH
        HLL CH,.CTTAB(CH)
        TLZE CH,ADD2.F
        ADDI CH,2
        TLZE CH,TEX.F
        JRST FTEX               ;GET STRING - DEL BY " ' OR []

;LOOK FOR A LINE LABEL:

        HLLI CH,0
        CAIN CH,">"
        SETOM TAGFLG
        MOVEM CH,DELIM

        ILDB CH,SERCH   ;GET FIRST CHAR TO MATCH
        CAMN CH,DELIM
        TLO F,CRORBL            ;HAVE !! OR <> OR :: - ACCEPT EMPTY LINE OR
                                ;LINE BEGINNING WITH A BLANK
FTLA:   ILDB X3,BEGSER          ;GET TEXT CHARACTER
        TLNE F,CRORBL           ;LOOKING FOR BLANK OR EMPTY LINE?
        JRST FTLA7              ;YES
        SKIPN TAGFLG            ;LOOKING FOR <STRING> ?
        JRST FTLA4              ;NO
        CAIE X3,11              ;YES, ACCEPT TABS & SPACES AT BEGIN OF LINE
        CAIN X3,40
        JRST FTLA
        CAIN    X3," "+KK.OFF
        JRST    FTLA            ;KK SPACE
FTLA4:  CAIN CH,177             ;WILD CARD CHAR?
        JRST [CAIE X3,15        ;YES, MATCH ON CR ILLEGAL
                JRST FTLA5      ;MATCH
                JRST FTLA0]
        CAME CH,X3              ;MATCH?
        JRST FTLA0              ;NO, FAIL
        CAIE CH,15              ;MATCHING CR'S?
        JRST FTLA5              ;NO, NORMAL MATCH
        ILDB CH,SERCH           ;GET NEXT CHAR
        CAMN CH,DELIM           ;THE END?
        JRST FTLA3              ;YES, WE PROBABLY FOUND SOMETHING
FTLA4B: CAML LINE,LASLIN        ;MATCH ACROSS LINES, GET LINE ETC.
        JRST [SKIPN EOF         ;LINE NOT IN DICT, MORE COMING FROM FILE?
                JRST FTLA0      ;NO, FAIL
                PUSHJ P,ADDIN3  ;GET LINE & SEE IF WE MADE IT
                JRST FTLA4B]
        AOJ LINE,               ;GET ADDR OF NEW LINE
        MOVE DIC,(LINE)
        PUSHJ P,MAKPN1          ;MAKE CHAR POINTER TO LINE
        JRST FTLA0              ;DIC = 0 , FAIL
        MOVEM DIC,BEGSER        ;RESET BEGSER
        JRST FTLA6              ;GET NEXT TEXT CHAR
FTLA5:  ILDB CH,SERCH           ;NEXT CHAR FROM SEARRCH STRING
        CAMN CH,DELIM           ;THE ENND?
        JRST FTLA3              ;YES, SUCCESS
FTLA6:  ILDB X3,BEGSER          ;NEXT TEXT CHAR
        JRST FTLA4              ;CONTINUE MATCHING

FTLA3:  CAIN CH,"!"             ;LOOKING FOR !STRING! ?
        JRST FTLA3B             ;YES, DON'T CHECK FOR FOLLOWING SPACES
        PUSH P,BEGSER
        ILDB X3,BEGSER          ;NEXT TEXT CCAR
        CAIE X3," "+KK.OFF
        CAIN X3,11
        JRST FTLA3A             ;TABS ARE GOOD
        CAIE X3," "
        CAIN X3,15
        JRST FTLA3A             ;CR AND BLANK GOOD ALSO
        SKIPE TAGFLG            ;<STRING>-FAILS, :STRING: OK IF MATCH :
        JRST [POP P,BEGSER
                JRST FTLA0]     ;BADDY
        SKIPE COLON             ;OK TO MATCH : ?
        CAIE X3,":"             ;YES, HAVE ONE?
        JRST .-3                ;NO , FAIL
FTLA3A: POP P,BEGSER            ;FOUND OUR LABEL
FTLA3B: CAIN X3,15              ;MATCHED TO LINE END?
                SETOM EOR       ;YES, SET FLAG
                MOVE X3,BEGSER
        MOVEM X3,SVPTR
        MOVEI X3,1
        MOVEM X3,TRUTH
        SETZM TAGFLG
        POPJ P,

FTLA0: SETZM TRUTH              ;RETURN FALSE
        CAIN X3,15
        SETOM EOR
        MOVE X3,BEGSER
        MOVEM X3,SVPTR
        SETZM TAGFLG
        POPJ P,

FTLA7:  CAIE    X3," "          ;ACCEPT TAB, SPACE OR EMPTY LINE
        CAIN    X3,^O15
        JRST    FTLA3B
        CAIE    X3,^O11
        CAIN    X3," "+KK.OFF
        JRST    FTLA3B
        JRST    FTLA0

FTEX:   HLLI CH,0
        MOVEM CH,DELIM
        MOVEM   SERCH,SSER      ;SAVE POINTER TO QUOTED STRING
        MOVE X4,BEGSER          ;CHAR POINTER INTO UPDATE AREA OR WINDOW
        MOVE SERCH,SSER         ;RENEW SEARCH STRING POINTER
        TLZ F,FIRST
FTEX3:  ILDB CH,SERCH
        CAMN CH,DELIM           ;END OF QUOTE?
        JRST FTEX1              ;YES-SUCCESS
FTEX2:  ILDB X3,X4              ;NOT YET END-GET NEXT TEXT CHARACTER
        CAIN CH,177             ;WILD CHARACTER?
        JRST [CAIE X3,15        ;YES-CR?
                JRST FTEX3      ;NOT CR-CONTINUE TO MATCH
                JRST FTEX5]     ;YES, FAIL
        CAME CH,X3              ;NOT WILD CHAR - MATCH?
        JRST [CAIE X3,15        ;NO MATCH - IS TEXT CHAR A CR?
        JRST FTEX4              ;NO-MOVE START UP 1 CHAR & CONTINUE SEARCH
        JRST FTEX5]             ;END OF LINE - FAIL
        CAIE CH,15              ;MATCH - ON CR?
        JRST FTEX6              ;NO, NORMAL MATCH
        ILDB CH,SERCH           ;NEXT SEARCH CHAR
        CAMN CH,DELIM           ;END OF QUOTE?
        JRST FTEX1              ;YES, ALL DONE
FTEX2B: CAML LINE,LASLIN
        JRST [SKIPN EOF         ;NEXT LINE NOT IN DICT-ANY MORE COMING FROM FILE?
                JRST FTEX5      ;NO, FAIL
                PUSHJ P,ADDIN3  ;GET LINE
                JRST FTEX2B]    ;AND SEE IF WE MADE IT
        AOJ LINE,               ;NEXT LINE
        MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        JRST FTEX5 ;DIC =0
        MOVEM DIC,X4            ;NEW POINTER
        JRST FTEX2              ;CONTINUE COMPARE
FTEX6:  TLOE F,FIRST            ;MATCH ON CHARACTER
        JRST FTEX3
        MOVEM X4,BEGSER         ;1ST CHAR MATCH-UPDATE SEARCH START
        DEC BEGSER              ;AND DECREMENT ONE BYTE
        JRST FTEX3
FTEX4:  CAME LINE,SVLIN         ;NO MATCH ON CHAR. MATCHING ACROSS LINES?
        JRST FTEX5              ;YES, FAIL-TEXT ON SECOND LINE MUST PRECISELY MATCH
                IBP BEGSER      ;START SEARCH AT NEXT CHAR OF TEXT
        MOVE X4,BEGSER
        MOVE SERCH,SSER         ;START SEARCH OVER-RENEW SEARCH STR POINTER
        TLZ F,FIRST             ;RESET "FIRST CHAR MATCHES" FLAG
        JRST FTEX3              ;TRY AGAIN
FTEX5: SETZM TRUTH              ;END OF LINE OR EOF, FAIL
        CAIN X3,15
        SETOM EOR               ;SET END OF LINE INDICATOR IF APPROPRIATE
        MOVEM X4,SVPTR          ;SAVE POINTER TO TEXT WHERE WE STOPPED
        TLZ F,FIRST
        POPJ P,
FTEX1: MOVEM X4,SVPTR           ;FOUND, GIVE POINTER TO WHERE SEARCH STOPPED
        CAIN X3,15
        SETOM EOR               ;IF END OF LINE, SET FLAG
        MOVEI X3,1
        MOVEM X3,TRUTH
        TLZ F,FIRST
        POPJ P,                 ;RETURN TRUE

;COME TO POLDON WHEN THE STRING EXPRESSION HAS BEEN EVALUATED DOWN TO
;ONE VALUE.

POLDON: CAMN P,SVFNDP           ;MORE TOKENS ON STACK?
        JRST POLDO2             ;NO
        POP P,OPRA              ;RETRIEVE OPERAND VALUE
        POP P,                  ;POP THE SVPTR ENTRY TOO
POLDO3: CAIN OPRA,1
        JRST POLDO2             ;=1, FINAL RESULT IS "FOUND"
        SKIPN OPRA
        JRST POLDO1             ;=0, NOT FOUND
        MOVE SERCH,OPRA         ;INFO IS POINTER INTO COMMAND
        MOVEM DIC,BEGSER        ;POINTER TO BEGIN SEARCH
        PUSHJ P,FNDTRT
        MOVE X1,TRUTH
        JRST POLDO3             ;SEE IF STR WAS FOUND
POLDO2: PUSHJ P,GOTOCM          ;TRUTH&WISDOM-FOUND SOMETHING,DO THE COMMAND
POLDO1: MOVE LINE,SVLIN         ;GET LAST LINE SEARCHED
POLDO4: AOJ LINE,               ;POINT TO NEXT LINE
        CAMG LINE,CERNG         ;CERNG SET TO -1 ON EOF
        JRST FINDO1             ;GO SEARCH THE LINE

POLDO5: SKIPE ENDCM             ;ALL DONE
        PUSHJ P,@ENDCM          ;DO FINAL PROCESS ON COMMAND
        TRZ F,FND.F
        TRNN F,MARK.F           ;ALWAYS GIVE A COUNT FOR FIND COMMANDS (NOT NECESSARILY FOR "@")
        JRST .+3
        SKIPN GIVCNT
        JRST GETCOM
        SETZM GIVCNT
        TRNE F,COMF.F!BUF.F     ;IF BUFFER OR COMFILE, DO NOT PRINT
        JRST GETCOM
        MOVE X1,NOFNDS
        PUSHJ P,PRTNUM
        OUTSTR  CRLF
        JRST GETCOM

GOTOCM: AOS NOFNDS              ;KEEP COUNT OF INSTANCES FOUND
        SKIPN MODMAR            ;@i+n TYPE
        MOVE LINE,SVLIN         ;NO, GET LINE WHERE WE STARTED
        MOVEM LINE,CURLIN       ;UPDATE CURLIN
        PUSHJ P, @COMAN         ;DO THE COMMAND
        POPJ P,

FNDLD:  TLO F,LOAD.F            ;INDICATE LOAD COMMAND (DO NOT DELETE LINES LOADED)
FNDGET: TRO F,FND.F             ;INDICATE FIND OR @ TYPE COMMAND
        SETZ X1,                ;NUMBER OF LINES TO BE LOADED UNKNOWN
        PUSHJ P,INIGET          ;INITIALIZE
        MOVEI X1,FNDGE1
        MOVEM X1,COMAN          ;SET ITERATIVE ROUTINE ADDRESS
        POPJ P,

FNDGE1: PUSHJ P,ITRGET          ;LOAD IT UP
        TLNN F,LOAD.F           ;LOAD OR GET?
        JRST FNDDE1             ;GET-DELETE LINE
        POPJ P,
;GET COMMAND
;FORMS: 1) N GET
;       2) R;N GET
; PLACE LINES IN RANGE R IN BUFFER N AND DELETE FROM DISK
        JRST    FNDGET
GET:    ASCIZ/ET/
        SKIPE BUFNO             ;2ND FORM?
        JRST GET1               ;YES-BUFNO ALREADY SET
        MOVE X1,FLRNG           ;FLRNG HAS BUFFER NO
        SUBI X1,DICT
        MOVEM X1,BUFNO
        MOVEI X1,DICT+1         ;SET UP DEFAULT RANGE
        MOVEM X1,FLRNG
        MOVE X1,LASLIN
        MOVEM X1,CERNG
        JRST GET2A
GET1:   SKIPG BUFNO
        SETZM BUFNO
        PUSHJ P,CKRNG

GET2A:  TRNE F,MARK.F           ;@?
        JRST [PUSHJ P,FNDGET    ;YES-INITIALIZE
             JRST MARKST]       ;AND GO DO IT
        PUSHJ P,GETCHK          ;MAKE SURE THE REQUESTED LINES EXIST
        MOVE X1,CERNG           ;LAST LINE OF RANGE
        SUB X1,FLRNG            ;FIRST LINE OF RANGE
        ADDI X1,1               ;# LINES TO BE LOADED
        PUSHJ P,INIGET          ;INITIALIZE

        MOVE LINE,FLRNG         ;GET FIRST LINE
GETLP:  PUSHJ P,ITRGET          ;LOAD THE LINE
        AOJ LINE,               ;NEXT LINE
        CAMG LINE,CERNG         ;ALL DONE?
        JRST GETLP              ;NO-LOOP

        TLZN F,LOAD.F           ;LOAD OR GET?
        PUSHJ P,DELLOC          ;GET- SO DELETE RANGE OF LINES
        JRST GETCOM

;INITIALIZATION FOR GET ROUTINE.
;X1 CONTAINS NUMBER OF LINES TO BE LOADED, 0 IF UNKNOWN (LOAD FROM TERMINAL,
;BY FIND OR @). BUFNO CONTAINS THE NUMBER OF THE BUFFER TO BE LOADED.

INIGET: PUSH P,X1
        PUSHJ   P,DWSMCP        ; WE MUST DETERMINE THE WORKSPCE MODE FROM THE
                                ; COMMAND PORT MODE HERE
        PUSHJ P,BUFRNG          ;GET LIMITS FOR THIS BUFFER
        POP P,X1
        SUBI X1,1               ;GET DISPLACEMENT
        ADD X1,WORD             ;LAST WORD WE'LL STORE INTO
        CAML X1,WORD+1          ;ENOUGH ROOM?
        JRST NOROOM             ;NO
        PUSHJ P,KILL1           ;CLEAR THIS BUFFER
        POPJ P,


;ITERATIVE PART OF THE GET ROUTINE, CALLED ONCE PER LINE TO BE LOADED.
;LINE CONTAINS ADDR OF LINE TO BE LOADED.

ITRGET: MOVE DIC,(LINE)         ;GET DICT ENTRY
        PUSHJ P,MAKPN1          ;MAKE A TEXT POINTER TO THE LINE
         POPJ P,                ;NO LINE
        PUSHJ P,SETNEW          ;PUT THE LINE INTO NEW LINE
        MOVEI X1,15
        IDPB X1,NEW
        AOS NCOUNT
        PUSHJ P,LOAD7           ;ENTER IT INTO BUFFER
        POPJ P,

;ROUTINE TO CHECK THE RANGE LIMITS FOR A "RANGE" GET OR LOAD TO 
;ENSURE THOSE LINES ACTUALLY EXIST

GETCHK: SKIPN EOF               ;ALL OF CURRENT INPUT FILE READ IN?
        POPJ P,                 ;YES
        MOVE X1,CERNG           ;LAST LINE OF RANGE
        PUSHJ P,ADDIN1          ;GET LINES UP THRU IT
        CAMLE X1,LASLIN         ;DID WE MAKE IT?
        JRST QUEST              ;NO, NOT ENOUGH LINES
        POPJ P,
; R GO COMMAND- WRITE FILE AND RUN RPG AT START+1

GO:     PUSHJ P,AUTOWR          ;WRITE TEXT TO DEFAULT OR GIVEN FILE IF
                                ;APPROPRIATE
        PUSHJ P,CLENUP          ;CLEAN UP UNIVERSE
        JRST RUNRPG             ;AND RUN RPG
; ROUTINE TO INSERT LINES OF TEXT
; FORMAT A INSERT
FNDINS: MOVEI X1,FNDIN1
        MOVEM X1,COMAN
        TRO F,INS.F
        POPJ P,
FNDIN1: PUSHJ P,FNDPR           ;PRINT THE LINE BEFORE WHICH INSERTION OCCURS
        MOVE X1,LINE            ;GET ADDR OF LINE
        MOVEM X1,TMPLIN         ;MAKE IT "LINE ABOUT TO BE INSERTED"
        SOJ X1,                 ;INDICATE LINE BEFORE THE INSERT FOR SETLIN
        PUSHJ P,SETLIN          ;SET UP OLD LINE IMAGE
        PUSHJ P,INSRT           ;DO AN INSERT
        MOVE X1,CERNG           ;UPDATE CERNG = CERNG + (TMPLIN-SVLIN)
        ADD X1,TMPLIN
        SUB X1,SVLIN
        MOVEM X1,CERNG
        MOVE X1,TMPLIN
        MOVEM X1,SVLIN          ;AND UPDATE SVLIN TO POINT TO LAST LINE OPERATED UPON.
        POPJ P,

        JRST FNDINS
INSERT: ASCIZ/NSERT/
        TRO F,INS.F
        TRNE F,MARK.F           ;'@' COMMAND?
        JRST [PUSHJ P,FNDINS    ;YES
                SETZM FLRNG
                PUSHJ P,CKRNG
        JRST MARKST]
        SKIPN FLRNG             ;ADDRESS GIVEN WITH COMMAND?
        PUSHJ P,LFORUP          ;NO-FIND OUT IF ^ OR LF
        MOVE X1,FLRNG
        CAIG X1,DICT
        MOVEI X1,DICT+1         ;MAKE DEFAULT ADDRESS OF FIRST LINE
        CAMG X1,LASLIN
        JRST SETINS             ;LINE IS WITHIN BOUNDS-GO SET INSERT ADDR
        MOVE X1,LASLIN
        AOJ X1,                 ;MAKE DEFAULT ADDRESS OF LAST LINE+1
SETINS: MOVEM X1,TMPLIN         ;SET INSERT FIRST LINE ADDRESS

        CAILE X1,DICT+1         ;DO NOT MAKE IMAGINARY LINE
        SOJ X1,                 ;SET CURLIN TO LINE PRECEDING THE INSERT
        MOVEM X1,CURLIN         ;SET CURLIN

        MOVE X1,TMPLIN          ;GET LINE # OF FIRST LINE OF INSERT
        SOJ X1,                 ;INDICATE LINE BEFORE INSERT FOR SETLIN
        PUSHJ P,SETLIN          ;SET UP OLD LINE IMAGE WITH LINE BEFORE INSERT
INSRT:  MOVEI   X1,2
        PUSHJ   P,TIE
        CAIN    X1,QCODE
        JRST    INS1A
        CAIN    X1,DCODE
        JRST    [TRNN F,FND.F
                 JRST GETCOM
                 POPJ P,]
        PUSHJ P,ADDLIN          ;ADD LINE TO UPDATE AREA
        PUSHJ P,MAKDIC          ;MAKE DICTIONARY ENTRY
        PUSHJ P,INSER           ;INSERT INTO DICTIONARY
        PUSHJ P,INCMOD          ;AND NOTE A MODIFICATION
        MOVE    X1,OLDBCB+BCBPNT
        MOVEM   X1,OLDBCB+BCBMIN;IF SPLIT LINE USE REST OF OLD LINE IMAGE ONLY
        MOVE    X1,TIRE+RTNCOD
        CAIN    X1,NORMAL       ;UNLESS SPLIT LINE,
        PUSHJ P,SWITCH          ;NEW LINE BECOMES OLD LINE FOR NEXT INSERTION
        MOVE X1,TMPLIN          ;GET ADDRESS OF LINE THAT WAS INSERTED
        MOVEM X1,CURLIN         ;MAKE A NEW CURRENT LINE
        AOS TMPLIN              ;LINE TO BE INSERTED IS NEXT ADDRESS
        JRST INSRT              ;GET ANOTHER LINE

INS1A:  TRNE    F,COMF.F!BUF.F
        JRST    INS1B
        OUTCHI  "^"
        OUTSTR  CRLF
INS1B:  MOVE    X1,TMPLIN
        SOJ X1,                 ;LAST LINE SO FAR INSERTED
        PUSH P,FLRNG
        PUSH P,CERNG
        MOVEM X1,FLRNG
        MOVEM X1,CERNG
        MOVEM X1,TMPLIN         ;RESET "LINE ABOUT TO BE INSERTED"
        PUSHJ P,SETLIN
        PUSHJ P,DELDIC          ;DELETE THAT LINE
        PUSHJ P,DECMOD          ;AND UNDO 1 MODIFICATION
        POP P,CERNG
        POP P,FLRNG
        JRST INSRT
;JOIN COMMAND
; FORMAT N JOIN- JOINS LINES N AND N+1 WITH A LF
JOIN: ASCIZ/OIN/
        MOVE LINE,FLRNG
        CAIG LINE,DICT
        JRST QUEST
        MOVEM LINE,CURLIN
        MOVE DIC,(LINE)
        PUSHJ P,MAKPNT
        JRST QUEST ;DIC=0
        PUSHJ P,SETNEW
        MOVE X1,NCOUNT
        SUBI X1,LINLEN
        MOVEM X1,NCOUNT
        MOVEI CH,12
        IDPB CH,NEW
        AOS NCOUNT
        PUSH P,NCOUNT
        AOJ LINE,
        MOVE DIC,(LINE) ;GET BEGIN NEXT LINE
        PUSHJ P,MAKPNT
        JRST QUEST ;DIC=0
        POP P,NCOUNT
        PUSHJ P,PUTNEW
        MOVEI X1,15
        IDPB X1,NEW
        AOS     NCOUNT
        PUSHJ P,ADDLIN
        PUSHJ P,MAKDIC
        MOVEM LINE,FLRNG
        MOVEM LINE,CERNG
        PUSHJ P,DELLOC
        SOJ LINE,
        MOVEM DIC,(LINE)
        JRST GETCOM
;COMMAND TO ERASE CONTENTS OF BUFFER N
;FORMAT N KILL

KILL:   ASCIZ/ILL/
        MOVE X1,FLRNG
        SUBI X1,DICT
        MOVEM X1,BUFNO
        PUSHJ P,BUFRNG          ;SET UP BUFFER LIMITS
        PUSHJ P,KILL1           ;DELETE THE BUFFER
        JRST GETCOM

KILL1:  SETZM BUF0              ;ANY KILL,GET, OR LOAD KILLS BUFFER 0
        MOVE X1,WORD            ;FIRST WORD OF THIS BUFFER'S DICTIONARY AREA
        SETZM (X1)              ;ZERO THE FIRST WORD
        HRL X1,X1               ;START OF BLT ADDR
        AOJ X1,
        MOVE X2,WORD+1          ;LAST WORD
        BLT X1,(X2)             ;ZERO IT OUT
        POPJ P,

;BUFNO CONTAINS THE BUFFER NUMBER

BUFRNG: MOVE X1,BUFNO
        CAIL X1,0
        CAILE X1,NOBUFS
        JRST QUEST              ;NOT BETWEEN 0 AND NUMBER OF BUFFERS
        IMULI X1,BUFLNS+1       ;NO LINES PER BUFFER PLUS ONE SAFETY
        ADDI X1,BUF0            ;GET ADDRESS
        MOVEM X1,WORD           ;SET FIRST LIMIT
        CAIN X1,BUF0            ;BUFFER 0?
        ADDI X1,<BUFLNS+1>*NOBUFS ;YES-MEANS  ALL BUFFERS CONCATENATED
        ADDI X1,BUFLNS          ;ADD DISPLACEMENT TO GET LAST WORD
        MOVEM X1,WORD+1         ;AND SET
        POPJ P,

;LINES COMMAND
; FORMAT LINES P

LINES:  ASCIZ/ES/
        CAMN CH,EQFLG
        JRST LINEEQ
        TLNE CH,TERM.F  ;TEMINATOR
        JRST [MOVEI NUM,^D54
                JRST LINES1]    ;YES RESTORE
        TLNN CH,NUM.F
        JRST QUEST
        PUSHJ P,MAKOCT
        SKIPE NUM               ;MUST NOT BE ZERO
        TLNN CH,TERM.F
        JRST QUEST
LINES1: MOVEM NUM,LINPAG
        JRST GETCOM
LINEEQ: MOVE X1,LINPAG
        PUSHJ P,PRTNUM
        OUTSTR  CRLF
        JRST GETCOM
;LIST COMMAND- SAME AS SLASH

        JRST FNDSL
LIST:   ASCIZ/T/
        JRST SLCOM+1
;COMMAND TO LOAD UP BUFFERS
; FORMS-
; 1) N LOAD- LOAD BUFFER N FROM TTY
; 2) R;N LOAD- SAME AS GET ONLY DON'T DELETE LINES
; 3) LOAD FILENAME
; 4) A LOAD FILENAME - 3&4 SAME AS READ
        JRST FNDLD
LOAD: ASCIZ/OAD/
        SKIPE FLRNG
        TLNN CH,TERM.F  ;EOF COM?
        JRST READ+1     ;NO MUST BE FILENAME AFTER
        TLO F,LOAD.F    
        SKIPE BUFNO
        JRST GET+1      ;SAME AS GET
        MOVE X1,FLRNG   ;MUST BE FORM 1
        SUBI X1,DICT    ;MAKE A NUMBER
        MOVEM X1,BUFNO
        SETZ X1,                ;DON'T KNOW HOW MANY LINES WILL BE LOADED
        PUSHJ P,INIGET
LOAD2:  MOVEI   X1,4
        PUSHJ   P,TIE
        MOVE    X1,TIRE+RTNCOD
        CAIE    X1,CHRACT       ;^D TYPED?
        JRST    LOAD3           ;NO
        MOVE    X1,TIRE+ACTCHR
        CAIE    X1,15
        JRST    LOAD2A
        IDPB    X1,NEW
        AOS     NCOUNT
        JRST    LOAD3
LOAD2A: TRNN    F,COMF.F!BUF.F
        OUTSTR  CRLF
        MOVEI   CH,33           ;YES, TERMINATE LINE WITH ESC
        IDPB    CH,NEW
        MOVEI   CH,15
        IDPB    CH,NEW
        MOVE    X1,NCOUNT
        ADDI    X1,2
        MOVEM   X1,NCOUNT
        PUSHJ   P,ADDLIN
        PUSHJ   P,MAKDIC
        MOVE    X1,WORD
        MOVEM   DIC,(X1)
        JRST    GETCOM

LOAD3:  PUSHJ   P,LOAD7
        JRST    LOAD2

;ROUTINE TO ADD LINE IN NEW LINE TO THE BUFFER.

LOAD7:  PUSHJ P,ADDLIN          ;ADD TO IN CORE UPDATE AREA
        PUSHJ P,MAKDIC          ;DIC ENTRY INTO DIC USING UPPNT AS START ADDR
                                ;UPDATE UPPNT
        MOVE X1,WORD            ;GET CURRENT POS IN BUFF DICT AREA
        CAML X1,WORD+1          ;ABOUT TO OVERFLOW?
        JRST NOROOM             ;YES
        MOVEM DIC,(X1)          ;PUT DICT ENTRY INTO DICT
        AOJ X1,
        MOVEM X1,WORD
        POPJ P,

FNDMAR: TRO F,FND.F
        PUSHJ P,FNDMA2          ;GET NUMBER
        MOVEM NUM,SVNUM
        MOVEI X1,FNDMA1         ;CHANGE COMMAND DISPATCH ADDR
        MOVEM X1,COMAN
        POPJ P,

FNDMA1: MOVE NUM,SVNUM
        PUSH P,CERNG
        PUSHJ P,MARK1
        POP P,CERNG
        POPJ P,
;MARK COMMAND

        JRST FNDMAR             ;FROM FIND COMMAND
MARK: ASCIZ/RK/
        PUSHJ P,CKRNG
        TRNE F,MARK.F
        JRST[ PUSHJ P,FNDMAR
        JRST MARKST]
FNDMA2: TLNN CH,NUM.F
        JRST QUEST
        PUSHJ P,MAKOCT
        CAIL NUM,1
        CAILE NUM,2
        JRST QUEST
        TRNE F,FND.F            ;FIND COMMAND?
        POPJ P,                 ;YES
        MOVE LINE,FLRNG
MARK1: MOVE DIC,(LINE)
        CAME DIC,MIN1           ;-1 DICT ENTRY?
        JRST .+3                ;NO
        PUSHJ P,MAKPN1          ;NORMAL RETURN IS SKIP
        JRST MARK2; DIC=0
        TRO DIC,(NUM)           ;TURN ON THE CORRECT MARK BIT
        
        MOVEM DIC,(LINE)        ;PUT BACK IN DICTIONARY
        MOVEM LINE,CURLIN
MARK2:  TRNE F,FND.F
        POPJ P,                 ;IF FIND COMMAND, RETURN
        AOJ LINE,
        CAMG LINE,CERNG
        JRST MARK1
        JRST GETCOM
;MODIFY COMMAND-SAME AS EDIT ONLY DON'T PRINT LINES BEING MODIFIED

        JRST FNDMD
MODIFY: ASCIZ/ODIFY/
MOD:    HRRZ X1,CH              ;GET CHAR PART
        CAIN X1,15              ;CR?
        JRST EDIT+2             ;YES-OK
        CAIE X1,"^"             ;OR "^"?
        CAIN X1,12              ;OR LF?
        JRST EDIT+2             ;YES-OK
        JRST QUEST              ;NO-ERROR

        JRST FNDOUT     ;WHICH IS IT?
M:      TLNE CH,NUM.F
        JRST MARK+1     ; DO WE MEAN MARKK?
        JRST MOD        ;AH WE MEAN MODIFY

FNDOUT: TLNE CH,NUM.F
        JRST FNDMAR
        JRST FNDMD1
;MOVE COMMAND
; FORMAT- A MOVE R

MOVE: ASCIZ/E/
        TLO F,MOVE.F    ;SET MOVE FLAG
        SETZM WORD
        SETZM WORD+1
        SETZM WORD+2
        JRST COPY+1
;COMMAND TO TELL EDITOR TO TAKE INSTRUCTIONS FROM BUFFER
; IF A BELL CONDITION OCCURS
; FORMAT ONRING N
ONRING: ASCIZ/NRING/
        CAMN CH,EQFLG
        JRST ONRGEQ
        CAMN CH,CRFLG
        JRST [SETOM RINBUF
              TRZ F,ONR.F
              JRST GETCOM]
        TLNN CH,NUM.F
        JRST QUEST
        PUSHJ   P,MAKOCT
        TLNN CH,TERM.F
        JRST QUEST
        CAIL NUM,0
        CAILE NUM,11
        JRST QUEST
        MOVEM NUM,RINBUF
        TRO F,ONR.F
        JRST GETCOM

ONRGEQ: SKIPGE X1,RINBUF
        JRST [OUTSTR [ASCIZ /None
/]
              JRST GETCOM]
        PUSHJ P,PRTNUM
        OUTSTR CRLF
        JRST GETCOM
;PAGE COMMAND

        JRST [PUSHJ P,PAGINI
              JRST FNDPT]       ;FOR FIND AND MARK COMMANDS

PAGE:   ASCIZ/GE/
        PUSHJ P,PAGINI          ;INITIALIZE FOR PAGE COMMAND
        JRST PRINT+1            ;THEN DO NORMAL PRINT LOGIC

PAGINI: SETZ NUM,               ;INITIALIZE PAGE NUMBER
        TLNN CH,NUM.F           ;DOES COMMAND CONTAIN A NUMBER?
        JRST PAG1               ;NO
        PUSHJ P,MAKOCT          ;GET NUMBER
PAG1:   MOVEM NUM,PAGNUM        ;SET PAGE NUMBER
        TLO F,PAG.F             ;INDICATES PAGE COMMAND
        POPJ P,


FNDPT:  TRO F,FND.F
        PUSHJ P,INIPRI          ;INITIALIZE PAGE/PRINT
        MOVEI X1,ITRFPR         ;ITERATE OF PAGE/PRINT FOR FIND
        MOVEM X1,COMAN
        MOVEI X1,TRMPRI         ;TERMINATION OF PAGE/PRINT
        MOVEM X1,ENDCM
        POPJ P,                 ;AND GO
;PRINT COMMAND

        JRST FNDPT
PRINT:  ASCIZ/RINT/
        PUSHJ P,CKRNG;
        TRNE F,MARK.F
        JRST[PUSHJ P,FNDPT
        JRST MARKST]

        PUSHJ P,INIPRI          ;INITIALIZE
        MOVE LINE,FLRNG         ;GET FIRST LINE

PRLOOP: MOVE DIC,(LINE)         ;GET LINE
        PUSHJ P,MAKPN1          ;MAKE POINTER; NORMAL RETUURN IS SKIP
        JRST ENDPRI             ;NO MORE LINES
        PUSHJ P,ITRPRI          ;PROCESS 1 LINE
        SKIPN DONCHG
        MOVEM LINE,CURLIN
        AOJ LINE,
        CAMG LINE,CERNG         ;ALL DONE?
        JRST PRLOOP             ;NO
ENDPRI: PUSHJ P,TRMPRI          ;YES
        JRST GETCOM

;ROUTINE TO INITIALIZE THE PAGE/PRINT COMMAND:

INIPRI: SETZ NUM,               ;RESET TEXT LINE COUNTER
        SETZM NOTPRN            ;THIS IS THE PRINT/PAGE COMMAND
        IFNBFR <OUTSTR DBLESP>  ;ASK IF HE WANTS DOUBLE SPACING
        PUSHJ P,YORN            ;YES OR NO?
        JRST NODBL              ;NO
        MOVEI X1,2              ;YES
        MOVEM X1,SPCING
        JRST INIRET
NODBL:  MOVEI X1,2
        CAME X1,SPCING          ;IS SPCING NOW DOUBLE?
        JRST INIRET             ;NO
        MOVEI X1,1              ;YES, SET TO 1
        MOVEM X1,SPCING
INIRET: PUSHJ P,PRITOP          ;PRINT TOP MARGIN OF LISTING
        POPJ P,

;ROUTINE WHICH CONVERTS LINE# INTO DIC POINTER FOR FIND COMMAND
;AND THEN CALLS ITRPRI, THE ITERATIVE PART OF PAGE/PRINT

ITRFPR: MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        POPJ P,                 ;LINE DOES NOT EXIST
        PUSHJ P,ITRPRI
        POPJ P,

;ROUTINE TO PROCESS 1 LINE

ITRPRI: SKIPN NUM               ;FIRST LINE OF PAGE?
        PUSHJ P,PRHEAD          ;YES, PRINT HEADING
        MOVEI X1,BUFFRD         ;REQUEST BUFFERED OUTPUT
        PUSHJ P,PRLINE          ;PRINT LINE
        AOJ NUM,                ;ADD TO COUNTER
        PUSHJ P,SPACER          ;PRINT SPACING IF ANY
        CAMN NUM,LINPAG         ;LAST LINE OF PAGE?
        PUSHJ P,PRFOOT          ;YES, PRINT PAGE FOOTING
        POPJ P,

;ROUTINE TO TERMINATE THE PAGE/PRINT
;PRINTS REMAINDER OF TEXT PART OF PAGE AND PAGE FOOTING IF NECESSARY,
;AND PRINTS VERY BOTTOM MARGIN.

TRMPRI: SKIPE NUM               ;ARE WE PARTIALLY THROUGH A PAGE?
        PUSHJ P,PAGEND          ;YES,, FILL OUT WITH BLANKS
        PUSHJ P,PRIBOT          ;PRINT VERY BOTTOM
        SKIPLE  OTTY+2          ;ANYTHING TO PRINT?
        PUSHJ P,PRTTE1          ;YES, GET IT OUT
        POPJ P,

;ROUTINE TO PRINT BLANK LINES  FOR SPACING IF NECESSARY
;SPACING=MIN(SPCING-1,LINPAG-NUM)
;ADD TO NUM APPROPRIATELY

SPACER: MOVE X1,LINPAG
        SUB X1,NUM              ;NUMBER OF LINES LEFT ON PAGE
        MOVE X2,SPCING
        SUBI X2,1               ;SPACING COUNT
        CAMLE X1,X2
        MOVE X1,X2              ;MOVE MIN INTO X1
        PUSHJ P,SKIPLF          ;PRINT THAT MANY BLANK LINES
        ADD NUM,X1              ;ADD NUMBER OF LINES TO THE COUNT
        POPJ P,

;ROUTINE TO PRINT 1 LINE OF TEXT:
;IF X1=BUFFRD IS A REQUEST FOR BUFFERED OUTPUT. X1=DIROUT FOR DIRECT OUTPUT.
;IF NOTPRN IS 0, FORM FEED IS SPECIAL TOP OF FORM OPERATOR. OTHERWISE IS 
;8 BLANK LINES. ALSO IF NOTPRN=0 CONTROL-H IS NOT TRANSLATED TO "&H".


PRLINE: SETZM PCOUNT            ;COUNT OF CHARACTERS OUTPUT THIS LINE
        MOVEM X1,OUTMOD         ;SET OUTPUT MODE, BUFFERED OR DIRECT
PRINLP: ILDB CH,DIC
        CAIGE CH,40             ;A PRINTING CHARACTER?
        JRST NPCHR              ;NO
        AOS PCOUNT              ;YES-PRINT COUNT INC BY 1
        PUSHJ P,PRINCH          ;PRINT IT
        JRST PRINLP             ;AND LOOP
NPCHR:  CAIE CH,14              ;FORMFEED?
        JRST NOTFRM
        PUSHJ P,FORMFD
        JRST PRINLP
NOTFRM: CAIE CH,12              ;LINEFEED?
        JRST NOTLFD
        PUSHJ P,LINFD
        JRST PRINLP
NOTLFD: CAIN CH,10              ;BACKSPACE? (CONTROL-H)
        SKIPE NOTPRN            ;AND PRINT/PAGE COMMAND?
        JRST NOTBSP             ;NO-TREAT LIKE ANY OTHER CONTROL CHARACTER
        SOS PCOUNT              ;YES-NO TRANSLATION OF ^H MEANS A BACKSPACE
        PUSHJ P,PRINCH          ;PRINT THE ^H
        JRST PRINLP             ;AND LOOP
NOTBSP: CAIE CH,11              ;CONTROL-I? (TAB)
        JRST NOTTAB             ;NOT A TAB
        MOVEI CH," "            ;LOAD UP A SPACE
        MOVE X1,PCOUNT
        PUSHJ P,TABDIS          ;X1= # OF SP'S NEEDED TO GET TO NEXT TABSTOP
        ADDM X1,PCOUNT          ;ADD # TO PRINT COUNT
        PUSHJ P,PRINCH          ;PRINT A SPACE
        SOJG X1,.-1             ;DO SO UNTIL COUNT REACHES ZERO
        JRST PRINLP
NOTTAB: PUSHJ P,ISUCN           ;PRINTS '&' IF CONTROL CH NOT CR
        PUSHJ P,PRINCH
        CAIE CH,15              ;CR?
        JRST PRINLP             ;NO
        MOVEI CH,12             ;YES, PRINT THE LINEFEED
        PUSHJ P,PRINCH
        SETZM PCOUNT            ;RESET THE PRINT COUNT
        POPJ P,                 ;AND RETURN

;ROUTINE TO HANDLE FORMFEEDS:

FORMFD: SETZM PCOUNT            ;RESET PRINT COUNT
        SKIPE NOTPRN            ;PRINT/PAGE COMMAND?
        JRST FRMFD              ;NO
        SKIPN NUM               ;ALREADY AT TOP OF PAGE?
        POPJ P,                 ;YES, DO NOTHING
        PUSHJ P,PAGEND          ;FILL OUT REMAINDER OF PAGE
        PUSHJ P,PRHEAD          ;PRINT HEADING OF NEXT PAGE
        POPJ P,
FRMFD:  MOVEI X1,10             ;SKIP 8 LINES
        PUSHJ P,SKIPLF
        POPJ P,

;ROUTINE TO HANDLE LINEFEEDS:

LINFD:  MOVEI CH,15
        PUSHJ P,PRINCH          ;PRINT A CR
        MOVEI CH,12
        PUSHJ P,PRINCH          ;AND A LF
        AOJ NUM,                ;ADD TO LINE COUNT BUT NO SPACING
        POPJ P,

;ROUTINE TO PRINT CHARACTERS, DIRECT OR BUFFERED DEPENDING ON OUTMOD.
;DOES CORRECT THING WITH PCOUNT.

PRINCH: SKIPE OUTMOD            ;BUFFERED?
        JRST PRIDIR             ;NO
        PUSHJ P,PRTTEX          ;YES
        POPJ P,
PRIDIR: SKIPN   CMDPTM
        JRST    PRDIRA
        OUTCHR  CH
        POPJ    P,

PRDIRA: CAILE   CH,^O200        ; convert kata kana
        JRST    [ OUTCHR [ "!" ] ; to bang
                  POPJ  P,  ]
        OUTCHR  CH
        POPJ    P,


;ROUTINE TO PRINT OUT MARGIN ABOVE THE FIRST PAGE:

PRITOP: MOVEI   X1,BUFFRD
        MOVEM   X1,OUTMOD
        MOVEI X1,6
        PUSHJ P,SKIPLF          ;6 BLANK LINES
        PRMSG DOT               ;PRINT DOT ALONE ON A LINE
        POPJ P,

;ROUTINE TO PRINT OUT MARGIN BELOW LAST PAGE:

PRIBOT: MOVEI X1,6
        PUSHJ P,SKIPLF          ;6 BLANK LINES
        POPJ P,

;ROUTINE TO PRINT THE HEADING OF A PAGE.
;ONLY IF THIS IS THE VERY FIRST PAGE OF A PAGE COMMAND
;WILL THE DATE, RATHER THAN A NUMBER, BE PRINTED.
;THE PRINT COMMAND HAS BLANKS FOR A HEADING.

PRHEAD: TLNE F,PAG.F            ;PAGE COMMAND?
        JRST PAGCOM             ;YES
        MOVEI X1,6
        PUSHJ P,SKIPLF          ;PRINT 6 BLANK LINES
        POPJ P,                 ;AND RETURN
PAGCOM: MOVEI X1,1
        PUSHJ P,SKIPLF          ;PRINT 1 BLANK LINE
        SKIPE PAGNUM            ;AT VERY FIRST PAGE (ZERO) ?
        JRST PRINUM             ;NO - PRINT PAGE NUMBER
        MOVEM DIC,PAGNUM        ;SAVE DIC VALUE OVER PRDAT CALL
        PUSHJ P,PRDAT           ;PRINT DATE
        MOVE DIC,PAGNUM         ;RESTORE OLD VALUE OF DIC
        SETZ NUM,               ;ALSO RESTORE (SET) LINE COUNTER
        MOVEI X1,1
        MOVEM X1,PAGNUM         ;AND SET PAGE NUMBER
        JRST TOPPAG
PRINUM: MOVEI CH," "            ;SPACE
        MOVEI X1,^D33           ;33 OF THEM
        PUSHJ P,PRTTEX
        SOJG X1,.-1             ;AND LOOP
        MOVE X1,PAGNUM
        PUSHJ P,PRIVAL          ;AND PRINT NUMBER
TOPPAG: MOVEI X1,5
        PUSHJ P,SKIPLF          ;PRINT 5 BLANKS
        POPJ P,

;ROUTINE TO PRINT FOOTING PART OF PAGE.
;FOOTING CONSISTS OF 6 LINES. THE LAST CONTAINS A PERIOD.
;OTHERS ARE BLANK.
;ALSO RESETS COUNTER NUM OF TEXT LINES AND INCS PAGE COUNTER.

PRFOOT: MOVEI X1,5
        PUSHJ P,SKIPLF
        SETZ NUM,
        PRMSG DOT
        AOS PAGNUM
        POPJ P,

;ROUTINE TO FINISH UP A PAGE. PRINTS REMAINDER OF TEXT AREA,
;FOOTING AND FINAL PERIOD.

PAGEND: MOVE X1,LINPAG
        SUB X1,NUM              ;NUMBER OF LINES LEFT IN TEXT AREA
        PUSHJ P,SKIPLF          ;FILL IT WITH BLANKS
        PUSHJ P,PRFOOT          ;PRINT PAGE FOOTING
        POPJ P,

;ROUTINE TTO PRINT (X1) CR LF'S.  RETURNS ORIGINAL X1 VALUE IN X1.

SKIPLF: MOVE X2,X1              ;COPY THE PARAMETER
LOOPLF: SOJGE X2,SKIPLN
        POPJ P,
SKIPLN: MOVEI CH,15
        PUSHJ P,PRINCH
        MOVEI CH,12
        PUSHJ P,PRINCH
        JRST LOOPLF

;ROUTINE TO PRINT DATE:

PRDAT:  MOVEI X1,^D35
        MOVEI CH," "
        PUSHJ P,PRTTEX
        SOJG X1,.-1
        CALL 11,[SIXBIT/DATE/]
        IDIVI 11,^D31
        MOVEM 11,13
        IDIVI 13,^D12
        AOJ 14,
        MOVEM 14,X1
        MOVEM CH,X4
        PUSHJ P,PRIVAL  ;GET MONTH
        PRICHR .CTTAB+55  ;-
        AOJ 12,
        MOVEM 12,X1
        PUSHJ P,PRIVAL
        PRICHR .CTTAB+55
        MOVE 13,X4      ;RESTOR CH
        ADDI 13,^D64    ;=1964-1900
        MOVEM 13,X1
        PUSHJ P,PRIVAL
        PRICHR .CTTAB +40
        PRICHR .CTTAB+40
        CALL 11,[SIXBIT/MSTIME/]
        IDIVI 11,^D1000
        IDIVI 11,^D60
        IDIVI 11,^D60
        MOVEM 11,X1
        PUSHJ P,PRIVAL
        PRICHR .CTTAB+72  ;:
        CAILE 12,11     ;TWO DIGITS?
        JRST PRDAT1     ;YES
        SETZ X1,        ;GIVE US A ZERO
        PUSHJ P,PRIVAL
PRDAT1: MOVEM 12,X1
        PUSHJ P,PRIVAL
        POPJ P,

DBLESP: ASCIZ/Double space? /
DOT:    ASCIZ/.
/
; QUIT COMMAND

QUIT:   ASCIZ/UIT/
        SKIPE EXAMIN            ;EXAMINE MODE?
        JRST QUITBY             ;YES-DON'T WORRY ABOUT NOT WRITING FILE
        PUSHJ P,WRIFIL          ;NEED TO WRITE A FILE?
        SKIPN X1
        JRST QUITBY             ;NO NEED
        IFNBFR <SKIPE RPG       ;IS THERE A DEFAULT FILE NAME?
           JRST RPGFNM          ;YES
           OUTSTR FILNWK        ;"File not written, Ok? "
           JRST FILANS          ;SKIP OVER WRITING OF DEFAULT FILE NAME
RPGFNM:    PUSHJ P,WRDFNM       ;GO WRITE DEFAULT FILE NAME
           OUTSTR NTCHKP>       ;"not written, Ok?"
FILANS: PUSHJ P,YORN            ;GET Y OR N ANSWER
        JRST GETCOM             ;N - BACK TO CMD LEVEL
QUITBY: JRST EGRESS             ;CLEAN UP UNIVERSE AND LEAVE

FILNWK: ASCIZ/File not written, Ok? /
NTCHKP: ASCIZ/ not written, Ok? /
;ROUTINE TO READ FILES IN
; ACCEPTED FORMS-
; A READ L1,L2 FILENAME
; A READ FILENAME
;A READ
;READ

BIGNO: EXP 777777

                ; OPEN specifications for the input file
INSPEC: EXP 1   ; bits,,status   the 1 means ascii line mode
        SIXBIT/DSK/     ; device name
        XWD 0,IBUF      ; output buffer header,,input buffer header

                ; OPEN specification for the output file. Used in 
                ; the WRITE and REPLACE commands.
OUSPEC: EXP 1   ; bits,,status   the 1 means ascii line mode
        SIXBIT/DSK/     ; device name
        XWD OBUF,IOBUF  ; output buffer header,,input buffer header

                ; OPEN specifications for Kata Kana output files.
                ; Used in the WRITE and REPLACE commands.
KKOSPC: EXP 2   ; bits,,status   the 2 means kata kana mode
        SIXBIT/DSK/     ; device name
        XWD OBUF,IOBUF  ; output buffer header,,input buffer header

; FOLLOWING ARE BYTE POINTERS INTO THE EXTENDED LOOKUP BLOCKS INFIL AND OUTFIL
; USED TO DETERMINE IF THE INPUT FILE OR OUTPUT FILE IS KATA KANA.

; BITS 9-12 OF WORD FOUR IS THE DATA MODE
INFLMD: POINT   4,INFIL+4,12    ; ... ... ... XXX X.. ...  ... ... ... ... ... ...
OTFLMD: POINT   4,OUTFIL+4,12   ; ... ... ... XXX X.. ...  ... ... ... ... ... ...
; BIT 9 OF WORD 14 IS THE OTHER PLACE TO CHECK. SOMTHING ABOUT KANA FILES
; CREATED IN UNBUFFERED MODE NOT HAVING DATA MODE OF XA (2)
INFKKB: POINT   1,INFIL+14,9    ; ... ... ... X.. ... ...  ... ... ... ... ... ...
OTFKKB: POINT   1,OUTFIL+14,9   ; ... ... ... X.. ... ...  ... ... ... ... ... ...

READ: ASCIZ/EAD/
        SKIPE EOF               ;DO WE HAVE TO FINISH READING ANY FILES?
        PUSHJ P,FINUP           ;YES,DO
        MOVEI X1,1
        MOVEM X1,FLLIN          ;SET DEFAULT FIRST LINE TO BE READ
        MOVE X1,BIGNO
        MOVEM X1,CELIN          ;SET DEFAULT LAST LINE TO BE READ
        TRNE F,RPG.F            ;FROM RPG (MODIFY)?
        JRST READ1A             ;YES - NO LINE #'S
        TLNN CH,NUM.F           ;IS FIRST NON-BLANK AFTER "READ" A NUMBER?
        TLOA F,TELLNO           ;NO LINE #'S,READ WHOLE FILE & PRINT "Chars"
        PUSHJ P,LINLIM          ;YES-GET #'S, PUT INTO FLLIN AND CELIN
        TLNE CH,TERM.F          ;END OF LINE?
        PUSHJ P,GETFIL          ;YES-ASK USER FOR FILE NAME
        MOVEI X1,INFIL          ;TELL FILNAM WHERE TO STORE INFO
        PUSHJ P,FILNAM          ;ANALYZE NAME
READ1A: MOVEI   X1,INFIL        ; TELL X 10 2 15 WHICH BLOCK
        PUSHJ   P,X10215        ; TO EXTEND TO 15 WORDS

        MOVE X1,FLLIN
        MOVEM X1,L1
        MOVE X1,CELIN
        MOVEM X1,L2
        OPEN INF,INSPEC
         JRST %DVFAL
        IFN %CIPFLG,<
        SETOM CP1FLG            ;SET FIRST BUFFER FLAG FOR CIPHERING>
        MOVEI X1,IBUFR          ;BUFFER ADDRESS
        MOVEM X1,JOBFF          ;TELL MONITOR WHERE BUFFER IS
        INBUF  INF,1
        LOOKUP INF,INFIL
        JRST [ HRRZ X1,INFIL+3  ;GET ERROR CODE
               OUTSTR @%ERCOD(X1) ;TYPE MESSAGE
               JRST NOREAD]

        SETZM   KKINFL          ; NOW WE DETERMINE IF THE FILE IS KATA KANA
        LDB     X1,INFLMD       ; GET THE DATA MODE
        CAIN    X1,2            ;  IS IT XA
        SETOM   KKINFL          ;   YES, KKINFL:= -1
        LDB     X1,INFKKB       ;  OR IS THE KANA BIT SET
        SKIPE   X1
        SETOM   KKINFL          ;   YES, KKINFL:= -1

        PUSHJ   P,DWSMIF        ; Determine WorkSpace Mode from Input File
        SKIPN   KKINFL          ; IF FILE IS KATA KANA
        JRST    NOTKK
        SETSTS  INF,2           ; THEN CHANGE MODE TO KATA KANA
        HRLI    X1,(POINT 9,)   ; AND TWIDLE WITH THE BYTE POINTER
        HLLM    X1,IBUF+1       ; IN THE BUFFER HEADER


NOTKK:  TLNE F,TELLNO           ;WHOLE FILE?
        PUSHJ P,GETCNT          ;YES, PRINT "Chars" MESSAGE

        MOVE X1,LASLIN          ;GET LAST LINE IN DICT
        SKIPE RPG               ;ORIGINALLY FROM ANOTHER PROCESSOR?
        TRNE F,RPG.F            ;YES.SET MOD UNLESS IN A MODIFY COMMAND
        TLZN F,TELLNO           ;OR IF WE ARE DOING A PARTIAL READ
        SKIPA
        CAILE X1,DICT           ;OTHERWISE, SET IT UNLESS THERE IS NO TEXT
        PUSHJ P,INCMOD          ;NEW STUFF IMPLIES MOD UNLESS TEXT AREA IS EMPTY

;SET UP RANGE PARAMETERS:

        SKIPE X1,FLRNG          ;WAS THERE A TARGET LINE NO SPECIFIED?
        JRST GOTNUM             ;YES
        ADD X1,LASLIN           ;NO, MAKE IT LASLIN+1
        AOJA X1,READB           ;AND CONTINUE
GOTNUM: SETOM RANGE             ;FLAG TO INDICATE TARGET LINE WAS GIVEN
        CAIG X1,DICT            ;IS LINE # GREATER THAN MIN?
        MOVEI X1,DICT+1         ;NO-SET DEFAULT LOWER LIMIT
        CAMG X1,LASLIN          ;GREATER THAN UPPER LIMIT?
        JRST RNGOK              ;NO,OK
        MOVE X1,LASLIN          ;YES,SET DEFAULT UPPER LIMIT
        AOJ X1,
RNGOK:  TLO F,FIRST             ;FLAG TO SWITCH PTRS AFTER FIRST LINE IS READ
READB:  MOVEM X1,TMPLIN         ;THE NEXT LINE NO TO BE INSERTED
        MOVEM X1,READLN         ;LINE TO BE READ

;SET COLON-MATCH SWITCH ACCORDING TO EXTENSION BUT DONT RESET PREVIOUS VALUE.

        HLRZ X1,INFIL+3         ;GET EXTENSION
        CAIE X1,(SIXBIT/SIM/)
        CAIN X1,(SIXBIT/MAC/)
        SETOM COLON
        CAIN X1,(SIXBIT/FAL/)
        SETOM COLON

        MOVEI LINE,1            ;LINE CONTAINS LINE NO OF FILE BEING READ
        MOVEM LINE,LINENO
        SETZM SEQNOS
        SETOM FRSTTM
        SETOM EOF
        SETO DIC,
        PUSHJ P,INSER           ;MAKE A -1 LINE TO INDICATE TO BE READ
        SOS READLN
        SETOM CURLIN            ;CURRENT LINE DETERMINED BY LAST LINE READ
        SKIPE RANGE             ;WAS TARGET ADDRESS SPECIFIED?
        JRST READ1B             ;YES-READ WHOLE FILE IN
        IFN %CIPFLG,<
        SKIPE CPFLAG            ;CIPHERED?
        JRST READ1B             ;YES-READ WHOLE FILE IN>
        PUSHJ P,READFL          ;READ 1 LINE IN NOW
        JRST GETCOM

READ1B: SETZM RANGE             ;RESET RANGE INDICATOR
        PUSHJ P,FINUP           ;READ ENTIRE FILE IN
        JRST GETCOM

NOREAD: RELEASE INF,
        TRNN F,RPG.F            ;FROM RPG?
        JRST FQUEST             ;NO
        TRZ F,RPG.F
        JRST EGRESS
;ROUTINE TO READ 1 LINE OF FILE IN
;SETS EOF=0 IF THERE WILL BE NO MORE LINES TO READ IN AT THE NEXT CALL.
;EOF IS A LOOK-AHEAD INDICATOR.
;CARRIAGE RETURN OR END OF FILE ENDS A LINE. THE LF IS OPTIONAL.
;DOES NOT CHANGE ANY REGISTERS (EXCEPT X1) NOR CURLIN OR TMPLIN.
;TURNS ESCAPES OFF WHILE READING THE LINE.
;RETURNS AS A VALUE THE DICTIONARY POSITION OF THE LAST LINE READ.

READFL: MOVE 0,[1,,SAVRD]       ;SET UP BLOCK TRANSFER TO SAVE REGISTERS
        BLT 0,SAVRD+15
        PUSHJ P,%OFFESC         ;AND TURN OFF ESCAPES UNTIL DONE WITH 1 LINE
        PUSH P,TMPLIN           ;SAVE TMPLIN
        PUSH P,CURLIN           ;SAVE CURLIN

READF2: MOVE LINE,LINENO
        CAMLE LINE,L2           ;LINE<=CELIN
        JRST [SETZM DONGET      ;1ST CHAR OF NEXT LINE DISCARDED
              JRST ENDRD]       ;WHEN DONE WITH RANGE READ (READ 5,15 FOO)
        CAMGE LINE,L1
        JRST READ2              ;TOO LITTLE-NEED TO READ PAST SOME LINES
        SKIPE DONGET            ;DO WE ALREADY HAVE THE FIRST CHAR OF LINE?
        JRST [MOVE CH,DONGET    ;YES
                SETZM DONGET
                JRST READF1]
        PUSHJ P,INCHR           ;GO GET FIRST CHAR
        JRST ENDRD              ;ALL GONE!!
READF1: MOVEI X1,LINLEN
        MOVNM X1,NCOUNT
        PUSH P,NEWPNT
        MOVE NEW,READPT
        SKIPE   KKINFL          ; is file in extended ascii (kata kana)?
        MOVE    NEW,KKRDPT      ;  yes, get kata kana read pointer
        MOVEM NEW,NEWPNT
        SETZM PCOUNT            ;COUNT OF CHARACTERS SO FAR ENTERED
        MOVE X1,READLN
        MOVEM X1,TMPLIN
READE:  PUSHJ P,CKRDCT
        SKIPE   WSFLMD          ; WORKSPACE EXTENDED ASCII
        JRST    READE1          ;  YES, THE CHARACTER IS FINE
        CAILE   CH,^O177        ;  NO, CHANGE EXTENDED ASCII CHARACTER
        MOVEI   CH,"!"          ;      TO BANG

READE1: CAIE CH,11              ;TAB?
        JRST RDNTAB             ;NO
        PUSHJ P,TRTAB           ;YES. TRTAB SKIPS IF NO EXPANSION DONE.
        JRST REDTAB             ;EXPANSION DONE. PCOUNT INCREMENTED.
RDNTAB: IDPB CH,NEW
        PUSHJ P,PCNTR           ;ADJUST PCOUNT AS APPROPRIATE
REDTAB: CAIN CH,15
        JRST READD              ;DONE WITH LINE
        PUSHJ P,INCHR
        MOVEI CH,15             ;NO MORE CHARS
        JRST READE

;GOT A LINE. ADD IT TO DICTIONARY AND UPDATE AREA:

READD:  PUSHJ P,DEPCNT
        PUSHJ P,ADDLIN          ;ADD LINE TO UPDATE AREA
        PUSHJ P,MAKDIC          ;MAKUP DICTIONARY POINTER
        PUSHJ P,INSER           ;INSERT OR APPEND
        POP P,NEWPNT
        JRST READ4

;ROUTINE TO READ PAST 1 LINE OF THE INPUT FILE. USED TO GET UP TO THE
;SPECIFIED LINE NO L1 (READ L1,L2 FOO)

READ2:  MOVE CH,DONGET          ;IF 1ST CHAR OF LINE ALREADY PICKED UP, GET IT
        SETZM DONGET            ;AND ZERO OUT SAVE-CELL

READ2B: CAIN CH,15              ;EOLINE?
        JRST READ2A             ;YES-GO TAKE CARE OF LF THAT MAY FOLLOW
        PUSHJ P,INCHR           ;GET NEXT CHAR
        JRST ENDRD              ;EOF
        JRST READ2B             ;AND LOOP
READ2A: PUSHJ P,INCHR
        JRST ENDRD
        CAIE CH,12
        MOVEM CH,DONGET
        AOS LINENO
        JRST READF2

;1 LINE SUCCESSFULLY READ IN AND ENTERED INTO DICTIONARY.
;CHECK TO SEE IF THERE ARE MORE CHARACTERS IN THE FILE:

READ4:  PUSHJ P,INCHR           ;GET NEXT NON-ZERO CHARACTER FROM FILE
        JRST ENDRD              ;NO MORE CHARACTERS
        AOS LINENO              ;INC POINTER INTO FILE
        CAIE CH,12              ;GOT A LINEFEED?
        JRST GOTNXT             ;NOT A LF-SAVE IN DONGET FOR NEXT CALL
        PUSHJ P,INCHR           ;GET NEXT CHAR AFTER LF (FIRST CHR OF NEXT LINE)
        JRST ENDRD              ;NONE LEFT
GOTNXT: MOVEM CH,DONGET         ;SAVE FOR NEXT CALL TO READFL
        JRST RDLDON             ;ALL DONE-GO CLEAN UP


READPT: POINT 7,RDLIN
KKRDPT: POINT 9,RDLIN

CKRDCT: AOSL NCOUNT             ;TOO MANY CHARACTERS?
        CAIN CH,15              ;AND NOT CR?
        POPJ P,                 ;NO
        CAIE CH,11              ;TAB?
        IDPB CH,NEW             ;NOT OK
        OUTSTR  LONGLN
        MOVEI CH,15
        POPJ P,

ENDRD:  SETZM EOF               ;RESET 'READING A FILE' INDICATOR
        SETZM DONGET            ;ZERO OUT ANY STRAY CHARACTER
        PUSH P,FLRNG
        PUSH P,CERNG
        MOVE X2,READLN
        MOVEM X2,FLRNG
        MOVEM X2,CERNG
        PUSHJ P,DELDIC          ;DELETE THE -1 DICT ENTRY THAT INDICATED WE
                                ;WERE PROCESSING A READ
        SETZM READLN
        POP P,CERNG
        POP P,FLRNG
        JRST RDLDON             ;ALL DONE- GO CLEAN UP

RDLDON: POP P,CURLIN            ;RESTORE CURLIN
        MOVE 0,[SAVRD,,1]       ;SET UP BLOCK TRANSFER TO RESTORE REGISTERS
        BLT 0,16
        PUSHJ P,%ONESC          ;RE-ENABLE ESCAPES
        MOVE X1,TMPLIN          ;RETURN TMPLIN AS A VALUE
        POP P,TMPLIN            ;AND THEN RESTORE OLD VALUE
        POPJ P,                 ;AND RETURN
;ROUTINE CALLED FROM MAKPNT TO READ 1 LINE OF FILE AND PUT INTO DICT.
;RELIES ON FACT THAT EOF IS A LOOK-AHEAD INDICATOR.
;ON RETURN, DIC=0 FOR FAILURE (NO MORE LINES). DIC=DICT POINTER OTHERWISE.

INLINE: SKIPN DIC,EOF           ;DIC=EOF. WAS EOF=0? (NO MORE LINES)
        POPJ P,                 ;YES
        PUSHJ P,READFL          ;READ 1 LINE OF THE INPUT FILE
        MOVE DIC,(LINE)         ;GET DICTIONARY ENTRY FOR LINE
        POPJ    P,              ;RETURN...



ADDIN3: PUSH P,X1
        MOVE X1,LINE
        PUSHJ P,ADDIN1
        MOVE LINE,X1
        POP P,X1
        POPJ P,
; ROUTINE TO FINISH UP READING FILE BEFORE STARTING ANOTHER


FINUP:  PUSHJ P,READFL          ;GET A LINE FROM THE INPUT FILE
        SKIPE EOF               ;ALL DONE WITH FILE INPUT? (EOF=0)
        JRST FINUP              ;CONTINUE READING
        SKIPLE CURLIN           ;CURLIN DEFINED?
        JRST FINU4              ;YES
        MOVEM X1,CURLIN         ;NO-MAKE IT LAST LINE READ
FINU4:  POPJ P,

;ROUTINE TO EXPAND TABS FROM INPUT FILE ACCORDING TO TAB TABLE

EXPAND: ASCIZ/Expand tabs?/

TRTAB:  SKIPN EXPTAB            ;SHALL WE EXPAND?
        JRST CPOPJ1             ;NO-SKIP RETURN
        MOVEI CH," "
        MOVE X1,PCOUNT          ;GET PRINT POSITION OF CURRENT LINE
        PUSHJ P,TABDIS          ;X1=DISTANCE TO NEXT TABSTOP
        ADDM X1,PCOUNT          ;ADJUST PCOUNT

TRTAB1: SOJL X1,TRTAB2          ;RETURN IF DONE
        PUSHJ P,CKRDCT          ;CHECK LENGTH
        IDPB CH,NEW
        CAIN CH,15      ;WERE WE TOO BIG FOR ME BRITCHES?
TRTAB2: POPJ P,         ;YAS SUH
        JRST TRTAB1
;ROUTINE TO GET NO OF CHARS OF FILE AND PUT OUT ON TTY

GETCNT: MOVE X1,INFIL+5         ; GET WORD COUNT OF FILE
        MOVEI   X2,5            ; FIGURE HOW MANY BYTES PER WORD
        SKIPGE  KKINFL          ; DO WE HAVE KATA KANA?
        MOVEI   X2,4            ;  YES, WELL THERES ONLY 4 BYTES THEN
GETCT:  IMUL  X1,X2     ; GET CHARACTER COUNT  (WE JUMP HERE FROM FNDAP4+
        TRNE F,COMF.F!BUF.F
        POPJ P,
        PUSHJ P,PRTNUM
        OUTSTR   CHARS
        POPJ P,

CHARS:  ASCIZ/ Chars
/

;ROUTINE TO OUTPUT DECI NOS 
;PRTDEC IS THE BASIC PROCEDURE. X3 VALUE IS -1
;FOR DIRECT OUTPUT, 0 FOR BUFFERED OUTPUT

PRTDEC: IDIVI X1,^D10           ;PRINT DECIMAL NUMBER
        JUMPE X1,PRTN1
        PUSH P,X2
        PUSHJ P,PRTDEC          ;GET NEXT DIGIT
        POP P,X2
PRTN1:  MOVEI CH,60(X2)
        SKIPN X3                ;BUFFERED OUTPUT?
        JRST PRTN2      ;YES
        OUTCHR  CH
        POPJ P,
PRTN2:  PUSHJ P,PRTTEX
        POPJ P,

PRIVAL: MOVEI X3,BUFFRD         ;BUFFERED DECIMAL OUTPUT
        PUSHJ P,PRTDEC
        POPJ P,

PRTNUM: MOVEI X3,DIROUT         ;DIRECT OUTPUT DECIMAL
        PUSHJ P,PRTDEC
        POPJ P,

PRIADR: HRRZ X1,40              ;UUO INSTRUCTION
        HRR X1,(X1)             ;EXTRACT ADDRESS PART
        MOVE CH,X1
        PUSHJ P,PRTTEX
        POPJ P,

;ROUTINE TO GET CHAR FROM INFIL
;SKIP RETURN ALL IS WEELL
;IMMED RETURN IMPLIES EOF

STRIPD: ASCIZ/Line numbers stripped from file
/
INCHR:  SOSLE IBUF+2
        JRST INOK
        IN INF,0
        JRST INOK0
        GETSTS INF,X1           ;GET FILE STATUS BITS INTO X1
        PUSHJ P,INFAL           ;FAILURE ON INPUT
        POPJ P,                 ;END OF FILE
INOK0:  IFN %CIPFLG,<
        SKIPE   ,CPFLAG
        PUSHJ   P,CPBUF         ;TEST CIPHER FLAG & MAYBE CIPHER BUFFER>
        SKIPE   KKINFL          ; Are we reading a Kata Kana file?
        JRST    INOK            ;  Yes, dont get confused over bit 35

        SKIPE SEQNOS    ;HAVE SEQ NOS?
        JRST INOK7      ;YES-GO SCAN THIS BLOCK
        SKIPN FRSTTM    ;FIRST INPUT BLOCK FROM THIS FILE?
        JRST INOK       ;NO

;SCAN THE BLOCK JUST INPUT FOR PAGE MARKS (EDIT10) AND SEQUENCE NUMBERS.
;AN EDIT10 PAGE MARK IS 2 WORDS, THE FIRST WITH BIT 35 TURNED ON:
; 1: ALL BLANKS
; 2: CR CR FF NUL NUL
;THE FIRST WORD IS ZEROED, THE SECOND IS ZEROED EXCEPT FOR THE LAST
;CHARACTER POSITION INTO WHICH IS DEPOSITED A FORM FEED.
;A SEQUENCE NUMBER IS PROCESSED AS A 1 WORD ENTITY; HOWEVER,
;MULTIPLE-WORD SEQUENCE NUMBERS WILL BE PROCESSED CORRECTLY (CFO OR SFO
;FILES). IT IS ASSUMED THAT THE FIRST CHARACTER IN THE WORD
;FOLLOWING THE SEQUENCE NUMBER IS A SP OR TAB AND IT IS ZEROED.

INOK7:  PUSHJ P,%OFFESC         ;DISABLE ESCAPES DURING SCAN OF BLOCK
        MOVEI X2,3              ;START AT FIRST WORD, LOOP THRU BLOCK

INOK3:  MOVE X1,IBUFR(X2)       ;PICK UP WORD FROM BUFFER BLOCK
        TRNN X1,1               ;IS BIT 35 ON?
        JRST INOK2              ;NO-NOT SEQ NOS
        CAMN X1,[<ASCII/     />+1];BLANKS WITH BIT 35 ON?
        JRST INOK4              ;YES-MUST BE FIRST WORD OF 2-WORD PAGE MARK
        SETZM IBUFR(X2)         ;NO-IS SEQUUENCE NUMBER-ZERO IT
        SETZ X3,
        DPB X3,[POINT 7,IBUFR+1(X2),6] ;ZERO THE TAB OR SP FOLLWNG LINE NO
        JRST INOK5

;PROCESS A PAGE MARK:

INOK4:  SETZM IBUFR(X2)         ;ZERO THE FIRST WORD
        AOJ X2,
        MOVEI X1,14_1           ;^L SHIFTED ONE LEFT (LAST CHAR POS)
        MOVEM X1,IBUFR(X2)      ;GOES INTO SECOND WORD OF PAGE MARK

INOK5:  SETOM SEQNOS            ;INDICATE THAT FILE HAS SEQ NOS OR PAGE MARKS
        PUSHJ P,INCMOD          ;ITS A MODIFICATION

;BOTTOM OF SCAN LOOP:

INOK2:  AOJ X2,                 ;NEXT WORD
        CAIG X2,202             ;ALL DONE?
        JRST INOK3              ;NO-LOOP
        PUSHJ P,%ONESC          ;SCAN DONE, RE-ENABLE ESCAPES
        SKIPE SEQNOS            ;DID WE FIND SEQEUNCE NUMBERS
        SKIPN FRSTTM            ;IN THE FIRST BLOCK OF THE FILE?
        JRST INOK               ;NO
        SETZM FRSTTM            ;YES-DONE WITH SCAN OF 1ST BLOCK OF CURRENT
                                ;INPUT FILE, RESET INDICATOR
        IFNBFR <OUTSTR STRIPD   ;TELL USER THAT SEQ NOS GET STRIPPED
        OUTSTR EXPAND>          ;ALSO ASK HIM WHETHER TO EXPAND TABS
        SETZM EXPTAB
        PUSHJ P,YORN            ;YES OR NO?
        SKIPA                   ;NO
        SETOM EXPTAB            ;YES,SET FLAG

;PICK UP NEXT CHARACTER:

INOK:   ILDB CH,IBUF+1
        JUMPE CH,INCHR  ;NULL
        AOS (P)
        POPJ P,

INFAL:  TRNN X1,740000          ;ERRORS BESIDES END OF FILE?
        POPJ P,                 ;NO- EOF- NON-SKIP RETURN FROM INCHR
        SETZ X2,                ;INDICATE READ
        JRST %IOFAL             ;NO-SOME OTHER DEVICE I/O ERROR

;ROUTINES TO GET FILE NAME FROM TTY

TO:     ASCIZ/To: /
TOKK:   BYTE (9) "T","o",":"," ",0
FROM: ASCIZ/From: /
FROMKK: BYTE (9) "F","r","o","m",":"," ",0

TOFIL:  MOVEI   X2,TO
        SKIPE   WSFLMD
        MOVEI   X2,TOKK         ; WE HAVE THE PROPER PROMPT
        JRST GETFI1
GETFIL: MOVEI   X2,FROM
        SKIPE   WSFLMD
        MOVEI   X2,FROMKK       ; ADDRESS OF PROMT IN X2
GETFI1: SETOM COMW.F
        MOVEI   X1,5
        PUSHJ   P,TIE
        MOVE NEW,NEWPNT
        PUSHJ P,GETCH   ;GET FIRST CHAR
        SETZM COMW.F
        POPJ P,

;ROUTINE TO SETUP FILNAME FOR LOOKUP OR ENTER IN ADDR SPEC IN X1
; USED FOR RPG FILES, COMMAND FILES, AND FILES FOR READ,REPLACE, AND WRITE CMDS
; SETS UP FOR THE SHORT LOOKUP BLOCK. THE ROUTINE X10215 IS USED TO
; EXTEND TO 15 WORDS THE LOOKUP BLOCK FOR THOSE WHO NEED TO USE THE
; EXTENDED LOOKUP BLOCK.

PT6: POINT 6,0
FILNAM: SETZM (X1)              ;ZERO OUT BLOCK. 1ST WD IS FILENAME
        SETZM 1(X1)             ;LH=SIXBIT EXTENSION
        SETZM 2(X1)             ;ALWAYS 0
        SETZM 3(X1)             ;USER NAME.RH IS ADDR OF 2 SIXBIT WORDS.OR PPN
        SETZM -2(X1)            ;USERNAME TEXT
        SETZM -1(X1)
        MOVE X4,X1
        CAMN CH,.CTTAB+"("
        PUSHJ P,USRNAM          ;STORES ADDR OF USRNAM INTO 3RD WD OF BLOCK
        MOVEI X2,1              ;COUNT
        HLL X1,PT6              ;SET UP SIX-BIT BYTE POINTER INTO BLOCK
FILN1:  HLL CH,.CTTAB(CH)
        TLNN CH,NUM.F!LET.F     ;NUMBER OR LETTER?
        JRST BRACKET            ;N0-LOOK FOR TRAILING PPN
        PUSHJ   P,BOOLUP        ;CONVERT TO UPPER CASE
        HLLI CH,0
        SUBI CH,40              ;CHANGE TO SIXBIT
        CAIG X2,6              ;FILNAM>6 TRUNCATE (DONT DEPOSIT)
        IDPB CH,X1              ;DEPOS CHAR
        ILDB CH,NEW             ;NEXT CHAR
        CAIE CH,175             ;CREATE COMMAND FROM RPG?
        CAIN CH,15              ;OR CR?
        POPJ P,                 ;YES,RETURN
        CAIN CH,0               ;OR 0?
        POPJ P,                 ;YES,RETURN
        CAIN CH,"."
        JRST FILEXT             ;GET EXTENSION
        AOJA X2,FILN1
FILEXT: AOJ X1,
        HLL X1,PT6
        MOVEI X2,1
FILEX1: ILDB CH,NEW
        CAIE CH,175             ;CREATE COMMAND FROM RPG END OF LINE
        CAIN CH,15
        POPJ P,
        CAIN CH,0               ;OR 0?
        POPJ P,                 ;YES,RETURN
        HLL CH,.CTTAB(CH)
        TLNN CH,NUM.F!LET.F     ;NOT ALPHANUM?
        JRST BRACKET    ;NO
        PUSHJ   P,BOOLUP        ;CONVERT TO UPPER CASE
        HLLI CH,0
        SUBI CH,40              ;MAKE SIXBIT
        CAIG X2,3              ;EXT>3 TRUNCATE (DONT DEPOSIT)
        IDPB CH,X1
        AOJA X2,FILEX1

BRACKET: CAME CH,.CTTAB+133      ;"["?
        JRST QUEST              ;UNRECOGNISABLE STUFF BEFORE LINE END
        MOVEI X1,","            ;CHARACTER WHICH TERMINATES THE NUMBER
GETNUM: SETZ X3,                ;THE NUMBER IN OCTAL
        MOVEI X2,1
BRAK2:  ILDB CH,NEW
        CAMN CH,X1              ;THE END OF THE ACCOUNT NUMBER?
        JRST BRAK1              ;YES,GO GT USER PPN
        CAILE X2,6
        JRST QUEST
        HLL CH,.CTTAB(CH)
        TLNN CH,NUM.F
        JRST QUEST
        HLLI CH,0
        SUBI CH,60
        IMULI X3,10
        ADD X3,CH
        AOJA X2,BRAK2
BRAK1:  CAIN X1,"]"             ;DID WE JUST GET THE SECOND NUMBER?
        JRST BRAK3              ;YES,ALL DONE
        PUSH P,X3               ;SAVE FIRST NUMBER
        MOVEI X1,"]"            ;SET TERMINATOR
        JRST GETNUM             ;GET SECOND NUMBER
BRAK3:  POP P,CH                ;RSTORE 1ST HALF NUMBER
        HRLM CH,3(X4)           ;STICK IN LH
        HRRM X3,3(X4)           ;SECND NUMBER IN RH
        ILDB CH,NEW     ;GET FILE NAME TERMINATING CHAR
        POPJ P,
;ROUTINE TO GET DIFFERENT PPN FROM USER

USRNAM: MOVEI X2,1
        MOVE X3,[POINT 6,-2(X1)]
GETPP2: ILDB CH,NEW
        CAIN CH,")"             ;END?
        JRST GETPP1             ;YES
        CAILE X2,14             ;USERNAME MUST BE <=12 CHARS
        JRST QUEST
        PUSHJ P,BOOLUP          ;CONVERT TO UPPER CASE
        HLLI    CH,0
        SUBI CH,40              ;CHANGE TO SIXBIT
        IDPB CH,X3
        AOJA    X2,GETPP2
GETPP1: ILDB CH,NEW
        MOVEI X2,-2(X1)
        MOVEM X2,3(X1)
        POPJ P,



; X10215 (pronounced EX TEN TWO FIFTEEN) IS USED TO EXTEND A SHORT
;  LOOKUP BLOCK AS SET UP BY FILNAM TO AN EXTENDED LOOKUP BLOCK OF 15
;  WORDS. IN THE SHORT LOOKUP BLOCK THE FILE NAME IS IN WORD 0, THE
;  EXTENSION IN WORD 1, AND THE PPN IN WORD 3. IN THE EXTENDED BLOCK THE
;  FILE NAME IS IN WORD 2, THE EXTENSION IN WORD 3, AND THE PPN IN WORD 1.

;  TO USE, PUT THE BLOCK ADDR IN X1 AND PUSHJ TO X10215


X10215: MOVEI   X2,14   ; WE PUT THE SIZE IN WORD 0
        EXCH    X2,0(X1)        ; MOVE NAME FROM WORD 0 TO WORD 2
        MOVEM   X2,2(X1)
        MOVE    X2,1(X1)        ; GET EXTENSION FROM WORD 1
        EXCH    X2,3(X1)        ; AND PUT IT INTO WORD 3, MOVING THE PPN
        MOVEM   X2,1(X1)        ; INTO WORD 1
        POPJ    P,              ; AND THAT IS ALL THERE IS TO THAT



;       ROUTINE TO SETUP LINE LIMITS IN FLLIN AND CELIN 
;AS SPECIFIED IN L1,L2 TYPE COMMANDS
LINLIM: PUSH P,CH
        PUSH P,NEW
        PUSHJ P,MAKOCT          ;CHANGES CH AND NEW
        MOVEM NUM,FLLIN         ;PUT VALUE INTO FLLIN - FIRST LINE
        CAME CH,.CTTAB+","      ;NEXT NON-BLANK A COMMA?
        JRST LINL2              ;NO,GIVE UP.NUM WAS PROB PART OF FILE NAME
        PUSHJ P,GETCH
        TLNE CH,NUM.F           ;NEXT CHAR A NUMBER?
        JRST LINL1              ;YES,CONVERT IT
        CAMN CH,.CTTAB+"$"      ;MAYBE "$"?
        JRST [MOVE NUM,BIGNO    ;YES,SET DEFAULT UPPER LIMIT
              PUSHJ P,GETCH     ;GET FIRST CHAR OF FILENAME
        JRST LINL1+1]
        JRST QUEST              ;NUMBER FOLLOWED BY COMMA THEN NON-NUM
LINL1:  PUSHJ P,MAKOCT          ;MAKE SECOND NUM
        MOVEM NUM,CELIN         ;SET LAST LINE TO READ
        PUSHJ   P,ISITSP        ;SPCE?
        SKIPA                   ;NO
        PUSHJ P,GETCH           ;YES GET FIRST NON BLANK
        POP P,                  ;THROW AWAY THE OLD VALUES
        POP P,
        POPJ P,
LINL2:  POP P,NEW               ;GIVE UP,RESTORE VARIABLES
        POP P,CH
        MOVEI X1,1
        MOVEM X1,FLLIN          ;SET DEFAULT FIRST LINE
        TLO F,TELLNO            ;LINE NOS NOT FOUND,OK TO GIVE CHR COUNT
        POPJ P,
;ROUTINE TO ADD LINE CONTAINED IN NEWLIN TO UPDATE AREA

ADDLIN: MOVE X1,NCOUNT  ;GET NO CHARS IN LINE
        ADDI X1,1       ;ADD 1 FOR THE LF WE'LL ADD TO THE LINE
        CAMLE X1,UPCNT  ;DO WE HAVE ENOUGH ROOM IN AREA
        PUSHJ P,OUTBUF  ;NO SO GET RID OF BUFFER-RENEW UPCNT AND UPPNT
        MOVE NEW,NEWPNT
        MOVE OLD,UPPNT  ;GET WHERE TO PLACE IN AREA

;MOVE THE ADDL1 LOOP INTO REGISTERS FOR SPEED:

        PUSH P,5
        PUSH P,6
        PUSH P,7
        MOVE X1,[XWD ADDL1,X2]
        BLT X1,7
        MOVE X1,UPCNT           ;GET COUNT INTO REGISTER ALSO
        JRST X2

ADDL1:  ILDB CH,NEW
        IDPB CH,OLD             ;DEPOSIT
        SOJ X1,                 ;AND COUNT
        CAIE CH,15              ;CR?
        JRST X2                 ;NO-CONTINUE
        JRST ADDL2              ;END OF LOOP

ADDL2:  POP P,7
        POP P,6
        POP P,5
        MOVEI CH,12
        IDPB CH,OLD
        SOJ X1,                 ;ACCOUNT FOR THE LF
        MOVEM X1,UPCNT          ;STORE NEW COUNT
        POPJ P,

;ROUTINE TO INPUT TMP FILE INTO WINDOW AREA

INBUF:  XCT INBLK       ;USETI (AS DETERMINED BEFORE ENTERING)
        INPUT TMP,WINLST
        POPJ P,
;ROUTINE TO OUTPUT UPDATE ARE TO TMP FILE

DSKRM:  ASCIZ /Out of disk room - file too large
/

OUTBUF: XCT TMPBLK              ;DO USETO
        STATZ TMP,60000         ;TOO LARGE?
         JRST [OUTSTR DSKRM
               SETSTS TMP,16    ;RESET FILE STATUS BITS
               JRST GETCOM]     ;YES
        OUTPUT TMP,TMPLST       ;WRITE THE BLOCK

        AOS TMPBLK              ;INCREASE BLOCK NO
        PUSHJ P,INITUP          ;INIT UPCNT,UPPNT

        POPJ P,

;  MAKDIC is always called right after an ADDLIN call
;ROUTINE TO CONVERT POINTER INTO DICTIONARY FORMAT
;UPPNT CONTAINS POINTER TO FIRST CHAR-POINTER TO BE CONVERTED
;OLD CONTAINS POINTER TO NEXT LINE
;FORMAT OF DIC POINTER
; BIT 0 ON IF INCORE (UPDATE AREA)
;BIT 1-17  IS BUFFER NO
;BIT 18-26 IS WORD NO WITHIN BUFFER
;BIT 27-29 FIRST 6 BITS OF REG POINTER (E.G. 44) CODED AS
;          5,4,3,2,1 OR 0 DEPENDING ON POSITION OF CHARACTER IN WORD.
;BIT 30-33 UNUUSED
;BIT 34-35 USED FOR MARK(1 OR 2)
;JUST ADD 000700 TO LEFT HALF
;ON EXIT DIC WILL CONTAIN POINTER TO BE INSERTED INTO DICTIONARY

MAKDIC: HRLZ DIC,TMPBLK ;GET BLOCK NO
        MOVEI X2,UPDATE ;GET ADDRESS OF BEGINNING OF UPDATE AREA
        HRRZ X3,UPPNT   ;GET ADDRESS FROM CHARACTER POINTER INTO UPDATE AREA
        SUB X3,X2       ;X2 COINTAINS WORD NO REL TO START OF UPDATE
        DPB X3,WRDDIC   ;DEPOSIT IN DIC
        LDB     X1,CHRUP        ; get Byte position from byte pointer
        IDIV    X1,WSBYSZ       ; divide by byte size (7 or 9)
        DPB     X1,CHRDIC       ; place in DIC pointer
        MOVEM OLD,UPPNT ;UPDATE POINTER
        POPJ P,

WRDDIC: POINT 9,DIC,26  ; ... ... ... ... ... ...  XXX XXX XXX ... ... ...
CHRUP: POINT 6,UPPNT,5  ; XXX XXX ... ... ... ...  ... ... ... ... ... ...
CHRDIC: POINT 3,DIC,29  ; ... ... ... ... ... ...  ... ... ... XXX ... ...



;ROUTINE TO CONVERT DIC POINTER IN DIC TO REG POINTER
;NORMAL RETURN IS SKIP
;IF DIC =0 SKIP RETURN


BIT34==2
BIT35==1

NORMBP: POINT   7,0,34  ; ... ... ... ... ... ...  ... ... ... .XX XXX XX.
        POINT   7,0,27  ; ... ... ... ... ... ...  ... XXX XXX X.. ... ...
        POINT   7,0,20  ; ... ... ... ... ..X XXX  XXX ... ... ... ... ...
        POINT   7,0,13  ; ... ... .XX XXX XX. ...  ... ... ... ... ... ...
        POINT   7,0,6   ; XXX XXX X.. ... ... ...  ... ... ... ... ... ...
        POINT   7,0     ; imagenary byte to the left of bit 0


KATABP: POINT   9,0,35  ; ... ... ... ... ... ...  ... ... ... XXX XXX XXX
        POINT   9,0,26  ; ... ... ... ... ... ...  XXX XXX XXX ... ... ...
        POINT   9,0,17  ; ... ... ... XXX XXX XXX  ... ... ... ... ... ...
        POINT   9,0,8   ; XXX XXX XXX ... ... ...  ... ... ... ... ... ...
        POINT   9,0     ; imaginary byte to the left of bit 0

MAKPN1: AOS (P)                 ;NORMAL RETURN IS SKIP
        CAME DIC,MIN1           ;DIC=-1 MEANS GET A LINE FROM THE INPUT FILE
        JRST MAKP2              ;LINE ALREADY ENTERED INTO DICTIONARY
        PUSHJ P,MAKPNT          ;GO GET LINE INTO DICTIONARY
        SOS (P)                 ;NO MORE LINES! NON-SKIP RETURN FROM MAKPN1
        SKIPN EOF               ;OUT OF LINES FROM INPUT FILE?
        SETOM CERNG             ;YES-END OF FILE LASLIN FOUND
                                ;SET RANGE BOUNDARY TO -1 FOR COMPARISON PURPOSES
        POPJ P,


MAKPNT: AOS (P)                 ;NORMAL RETURN IS SKIP
        CAMN DIC,MIN1           ;IF DIC=-1, GET LINE FROM INPUT FILE
        PUSHJ P,INLINE
        SKIPN DIC
        JRST [SOS (P)           ;NO MORE LINES-NON-SKIP RETURN FROM MAKPNT
                POPJ P,]
MAKP2:  SKIPN DONZER            ;DO WE PROPAGATE MARK BITS TO THE NEW LINE?
        SETZM MRKDIC            ;NO-ZERO THEM
        TRNN DIC,BIT34!BIT35    ;MARKED?
        JRST .+3                ;NO
        LDB X1,[POINT 2,DIC,35]
        MOVEM X1,MRKDIC         ;MRKDIC HAS THE TWO MARK BITS
         LDB X1,CHRDIC          ;GET CHAR OFFSET
        SKIPN   WSFLMD          ; if the workspace is normal ascii
        MOVE    X1,NORMBP(X1)   ;  then use a normal byte pointer
        SKIPE   WSFLMD          ; but if the work space is Kata Kana
        MOVE    X1,KATABP(X1)   ;  then use a Kata Kana byte pointer
        LDB X2,WRDDIC           ;GET WORD ADDRESS WITHIN ITS BLOCK
        HRR X1,X2               ;X1 HAS CHARACTER POINTER INTO LINE
        HLRZ X3,DIC
        HRRZ X2,TMPBLK          ;GET BLK NO OF IN CORE BLOCK (IN UPDATE AREA)
        CAMN X2,X3              ;HAVE THE REQUIRED LINE INCORE?
        JRST[   ADDI X1,UPDATE  ;YES
        MOVEM X1,DIC            ;DIC NOW HAS VALID POINTER INTO UPDATE AREA
        POPJ P,]                ;YES
        HRRM X3,INBLK           ;PREPARE FOR USETI-SET BLOCK NO
        ADDI X1,WINDOW  
        MOVE DIC,X1             ;GET INITIAL POINTER INTO DIC
        MOVEI X1,WINDOW-1
        HRRM X1,WINLST
        CAME X3,WNBLK1          ;HAVE THAT BLOCK IN FIRST WINDOW?
        JRST NT1BLK             ;NOT IN FIRST
        MOVEM X3,WNLAST         ;LAST BLOCK REFERENCED IS THIS ONE
        POPJ P,
NT1BLK: CAME X3,WNBLK2          ;IN SECOND WINDOW?
        JRST NT2BLK             ;NO
        ADDI DIC,BLKSIZ         ;POINT INTO THE SECOND WINDOW BLOCK
        MOVEM X3,WNLAST         ;LAST BLOCK REFERENCED IS THIS ONE
        POPJ P,
NT2BLK: MOVE X2,X3
        SUBI X2,1               ;COMPUTE BLOCK NO JUST BEFORE ONE NEEDED
        CAME X2,WNBLK1          ;EQUAL TO WHAT'S IN FIRST WINDOW?
        JRST CHBLK2             ;NO-GO SEE IF EQUAL TO SECOND WINDOW CONTENTS
RP1BLK: MOVEM X3,WNBLK1         ;YES-REPLACE SEQUENTIALLY FOLLOWING BLOCK
        MOVEM X3,WNLAST         ;INDICATE LAST REFERENCED BLOCK
        JRST INBUF
CHBLK2: CAMN X2,WNBLK2          ;BLOCK NEEDED FOLLOWS BLOCK IN SECOND WINDOW?
        JRST RP2BLK             ;YES-REPLACE SECOND WINDOW
        MOVE X2,WNLAST          ;LAST REFERENCED BLOCK NO
        CAME X2,WNBLK1          ;WAS THE BLOCK IN THE FIRST WINDOW?
        JRST RP1BLK             ;NO(WAS THE SECOND)-REPLACE THE FIRST
RP2BLK: ADDI DIC,BLKSIZ         ;POINT INTO THE SECOND WINDOW BLOCK
        MOVEI X1,BLKSIZ
        ADDM X1,WINLST
        MOVEM X3,WNBLK2
        MOVEM X3,WNLAST         ;INDICATE LAST REFERENCED BLOCK
        JRST INBUF              ;AND GO READ IT IN
;ROUTINE TO INSER A POINTER INTO DICTIONARY
;1 INSERTION AT A TIME
;TMPLIN CONTAINS LIN NO TO BE INSERTED
;DIC CONTAINS PTER TO BE INSERTED

INSER:  AOS NUM,LASLIN          ;INCREASE LASLINE IN DICT
        CAMLE NUM,JOBREL        ;ENOUGH SPACE?
        PUSHJ P,GETCOR  ;NO GET CORE

;LOAD THE INSERT LOOP INTO REGISTERS X2-6:

        PUSH P,5
        PUSH P,6
        MOVE X1,[XWD INSER1,X2]
        BLT 1,6
        JRST X2

INSER1: CAMN NUM,TMPLIN ;IS THIS THE LINE TO 
        JRST APPEN      ;YES STICK IT IN
        MOVE X1,-1(NUM)
        MOVEM X1,(NUM)
        SOJA NUM,X2
APPEN:  MOVEM DIC,(NUM) ;MAKE THE INSERT
        MOVEM NUM,CURLIN
        POP P,6
        POP P,5
        SKIPN EOF
        POPJ P,
        CAMG NUM,READLN
        AOS READLN
        POPJ P,

;ROUTINE TO EXPAND CORE FOR DICTIONARY

GETCOR: HRRZ X1,JOBREL
        ADDI X1,2000
        CORE    X1,             ;GET CORE
        JRST TOOBIG
        POPJ P,

TOOBIG: OUTSTR   BIGCOR
        JRST GETCOM

FNDREP: TRO F,FND.F
        PUSHJ P,FNDRE1
        MOVEM NUM,SVNUM
        MOVEI X1,STREP0
        MOVEM X1,COMAN
        MOVEI X1,FNDRE3
        MOVEM X1,ENDCM
        POPJ P,

FNDRE3: MOVE NUM,SVNUM
        JRST STREP2
;REPLACE COMMAND-
;FORMAT- R REPLACE L1,L2 FILE


REPSPE: 1
        SIXBIT/DSK/
        0,,RBUF

        JRST FNDREP
REPLAC: ASCIZ/LACE/
        PUSHJ P,CKRNG
        TRNE F,MARK.F
        JRST [PUSHJ P,FNDREP
        JRST MARKST]
FNDRE1: TLNN CH,NUM.F
        JRST QUEST
        PUSHJ P,LINLIM
        TLNE CH,TERM.F
        PUSHJ P,TOFIL
        MOVEI X1,REPFIL         ; TELL FILNAM WHERE THE LOOKUP BLOCK IS
        PUSHJ P,FILNAM          ; GET FILE NAME AND PPN INTO LOOKUP BLOCK
        MOVE X1,[XWD REPFIL,OUTFIL]
        BLT X1,OUTFIL+3

        MOVEI   X1,OUTFIL
        PUSHJ   P,X10215
        MOVEI   X1,REPFIL       ; TELL X 10 2 15 ABOUT REPFIL
        PUSHJ   P,X10215        ; AND MAKE IT AN EXTENDED BLOCK OF 15 WORDS
        OPEN REPF,REPSPE
        JRST %DVFAL
        MOVEI X1,RBUFR
        MOVEM X1,JOBFF
        INBUF REPF,1
        LOOKUP REPF,REPFIL
        JRST    [RELEASE REPF,
                HRRZ X1,REPFIL+3
                JRST FOPERR]    ;NO SUCH FILE

        SETZM   REPFLM          ; NOW WE DETERMINE IF THE FILE IS KATA KANA
        LDB     X1,[POINT 4,REPFIL+4,12]        ; WE LOOK AT DATA MODE
        CAIN    X1,2                            ; IS IT KK (MODE=2) ?
        SETOM   REPFLM                          ;  YES, REPFLM:= -1
        LDB     X1,[POINT 1,REPFIL+14,9]        ; OR IS THE KANA BIT SET?
        SKIPE   X1
        SETOM   REPFLM                          ;  YES, REPFLM:= -1

                        ; THE MODE OF THE WORKSPACE MUST EQUAL THE MODE OF THE REPLACE FILE

        SKIPE   WSFLMD
        JRST    REPCH1
        SKIPN   REPFLM
        JRST    MDMTCH  ; MODES MATCH, BOTH ARE NORMAL ASCII

        RELEASE REPF,   ; ERROR, REPLACE FILE IS KK, WORKSPACE IS NOT
        OUTSTR  [ASCIZ /
Replace file is Extended Ascii (Kata Kana), workspace is not
/]
        JRST    GETCOM          ; %DVFAL DOES THIS, SO ME DO TOO

REPCH1: SKIPE   REPFLM
        JRST    MDMTCH  ; MODES MATCH, BOTH ARE KATA KANA

        RELEASE REPF,   ; ERROR, REPLACE FILE IS NORMAL ASCII, WORKSPACE KK
        OUTSTR  [ASCIZ /
Workspace is Extended Ascii (Kata Kana), Replace file is not
/]
        JRST    GETCOM

MDMTCH: SKIPN   REPFLM
        JRST    REPKK0
        SETSTS  REPF,2
        HRLI    X1,(POINT 9,)
        HLLM    X1,RBUF+1
        OPEN    OUTF,KKOSPC
        JRST    %DVFAL
        MOVEI   X1,1
        DPB     X1,OTFKKB
        JRST    REPKK1

REPKK0: OPEN    OUTF,OUSPEC
        JRST    %DVFAL

REPKK1: MOVEI X1,OBUFR
        MOVEM X1,JOBFF
        ENTER OUTF,OUTFIL
        JRST    [RELEASE OUTF,
                HRRZ X1,OUTFIL+1 ;GET ERROR CODE
                JRST FOPERR]    ;TYPE MESSAGE
        OUTBUF OUTF,1
        MOVEI NUM,1
REP0:   PUSHJ P,RINCHR
        JRST STREPL
REP1:   CAML NUM,FLLIN
        JRST STREPL
REP3:   PUSHJ P,ROUCHR
        CAIN CH,15
        JRST REP2
        PUSHJ P,RINCHR
        JRST    STREPL
        JRST REP3
REP2:   MOVEI CH,12
        PUSHJ P,ROUCHR
        PUSHJ P,RINCHR
        JRST STREPL
        CAIN CH,12
        AOJA NUM,REP0
        AOJA NUM,REP1
STREPL: TRNE F,FND.F
        POPJ P,
        MOVE LINE,FLRNG
STREP0: MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        JRST STREP3 ;DIC=0
STREP1: ILDB CH,DIC
        PUSHJ P,ROUCHR
        CAIE CH,15
        JRST STREP1
        MOVEI CH,12
        PUSHJ P,ROUCHR
STREP3: TRNE F,FND.F
        POPJ P,
        SKIPN DONCHG
        MOVEM LINE,CURLIN
        AOJ LINE,
        CAMG LINE,CERNG
        JRST STREP0

STREP2: PUSHJ P,RINCHR
        JRST ENDREP
        CAIE CH,15
        JRST STREP2
        PUSHJ P,RINCHR
        JRST ENDREP
        CAIN CH,12
        AOJA NUM,END1
        AOJA NUM,END2

END1:   PUSHJ P,RINCHR
        JRST ENDREP
END2:   CAMLE NUM,CELIN
        JRST ENDREP

END4:   CAIN CH,15
        JRST END3
        PUSHJ P,RINCHR
        JRST ENDREP
        JRST END4
END3:   PUSHJ P,RINCHR
        JRST ENDREP
        CAIN CH,12
        AOJA NUM,END1
        AOJA NUM,END2

ENDREP: PUSHJ P,ROUCHR
        PUSHJ P,RINCHR
        JRST ENDRE1
        JRST ENDREP
ENDRE1: CLOSE OUTF,
        TRNE F,FND.F
        POPJ P,
        JRST GETCOM

RINCHR: SOSLE RBUF+2
        JRST RINOK
        IN REPF,0
        JRST RINOK
        GETSTS REPF,X1          ;GET FILE STATUS BITS INTO X1
        PUSHJ P,INFAL           ;FAILURE ON INPUT
        POPJ P,                 ;EOF
RINOK:  ILDB CH,RBUF+1
        JUMPE CH,RINCHR ;NULL
        AOS (P)
        POPJ P,

ROUCHR: SOSLE OBUF+2
        JRST ROUTOK
        OUT OUTF,0
        JRST ROUTOK
        GETSTS OUTF,X1
        CLOSE OUTF,40   ;DON'T DELETE PREV FILE
        RELEASE OUTF,
        SETO X2,                ;INDICATE WRITE
        JRST %IOFAL
ROUTOK:  IDPB CH,OBUF+1
        POPJ P,



;SAVE COMMAND

        JRST FNDWR
SAVE: ASCIZ/VE/
        JRST WRITE+1
;SPACING COMMAND
;FORMAT         SPACING P
;               SPACING
;               SPACING=

SPACNG: ASCIZ/ACING/

        CAMN CH,EQFLG           ;=FORMAT?
        JRST SPACEQ             ;YES
        TLNE CH,TERM.F          ;ANYTHING ELSE FOLLOWING COMMAND WORD?
        JRST [MOVEI NUM,1
              JRST SPACN1]      ;NO-RESTORE DEFAULT
        TLNN CH,NUM.F           ;NUMBER?
        JRST QUEST              ;NO, NOT A LEGAL FORM
        PUSHJ P,MAKOCT          ;MAKE A NUMBER
        SKIPE NUM               ;ZERO NOT ALLOWED
        TLNN CH,TERM.F          ;ANYTHING ELSE?
        JRST QUEST              ;IF SO, IT'S ILLEGAL
SPACN1: MOVEM NUM,SPCING                ;SET PARAMETER
        JRST GETCOM
SPACEQ: MOVE X1,SPCING          ;GET CURRENT VALUE
        PUSHJ P,PRTNUM          ;PRINT IT OUT
        OUTSTR CRLF
        JRST GETCOM
;SUBSTITUTE COMMAND

ENDQUO: ASCIZ /" /
WAIT:   asciz/Wait? /
OK: ASCIZ/Ok? /

FNDSUB: TRO F,FND.F
        PUSHJ P,FNDSU2          ;SETUP - GET STRINGS
        MOVEI X1,SUB1
        MOVEM X1,COMAN          ;SUB1 IS DISPATCH ADDR
        MOVEI X1,SUB2
        MOVEM X1,ENDCM          ;SUB2 IS FINISH-UP ADDR
        POPJ P,

        JRST FNDSUB
SUBSTI: ASCIZ/UBSTITUTE/
        TRNE F,MARK.F
        JRST [PUSHJ P,FNDSUB
        JRST MARKST]
FNDSU2: SETZM NEWCHS
        HRLI X1,NEWCHS
        HRRI X1,NEWCHS+1
        BLT X1,NEWCHS+^D103     ;ZERO NEWCHS AND OLDCHS
        PUSHJ P, CKRNG  ;SETUP RANGE
        MOVEI   X1,1
        PUSHJ P,SUBS1           ;GET FIRST JUNK TO SUBSTITUTE
        MOVE NEW,NTXPT
        PUSHJ P,SUBS2           ;PUT IN NEWCHS
        IFNBFR <OUTSTR   ENDQUO>
        PUSHJ   P,SWITCH
        MOVEI   X1,6
        PUSHJ P,SUBS1
        MOVE NEW,OLTXPT
        PUSHJ P,SUBS2           ;PUT IN OLDCHS
        CAMN NEW,OLTXPT
        JRST QUEST              ;MAKE SURE WE HAVE SOMETHING TO LOOK FOR
        TRNE F,COMF.F!BUF.F
        JRST FNDSU3
        OUTCHR  .CTTAB+42
        OUTSTR  CRLF
FNDSU3: IFNBFR <OUTSTR   WAIT>
        PUSHJ P, YORN
        TRZA F,WAIT.F           ;DON'T WAIT-NO ANSWER
        TRO F,WAIT.F            ;YES ANSWER
        SETZM NOSUBS            ;INIT COUNTER
        MOVE X1,CURLIN
        MOVEM X1,CHGCUR
        TRNE F,FND.F
        POPJ P,                 ;RETURN IF FIND-TYPE SUBSTITUTE
        MOVE LINE,FLRNG         ;INIT LINE POINTER
SUB1:   MOVE DIC,(LINE)         ;GET RELEVANT LINE
        PUSHJ P,MAKPN1          ;GET CHAR POINTER INTO WINDOW OR UPDATE AREA
        JRST SUB4 ;DIC=0
        PUSHJ P,SETUP           ;SET UP LINE IMAGES
        MOVEM LINE,ENDLIN
        MOVEM LINE,CURLIN
        MOVEM LINE,BEGLIN
        MOVEM LINE,TMPLIN
        MOVEM DIC,BEGPRT
        MOVEM DIC,BEGSER
        TLZ F,SUBMAD            ;NO SUBS HAVE BEEN MADE YET ON THIS LINE
        PUSHJ P,FNDTXT          ;FND THE TEXT,AND MAK SUB IF NECESSARY
SUB4:   TRNE F,FND.F
        POPJ P,
        MOVE X4,DONCHG          ;DONCHG SET BY MAKSUB
        MOVEM X4,CURLIN
        AOJ LINE,
        CAMG LINE,CERNG
        JRST SUB1
SUB2:   SKIPE NOSUBS            ;ANY ACTION?
        JRST .+3                ;YES
        MOVE X1,CHGCUR          ;NO ACTION-RESTORE CURLIN
        MOVEM X1,CURLIN
        TRNE F,COMF.F!BUF.F
        JRST SUB3
        MOVE X1,NOSUBS
        PUSHJ P,PRTNUM          ;PRINT NO OF SUBSTIT MADE
        OUTSTR  CRLF
SUB3:   TRZ F,WAIT.F
        JRST GETCOM



SUBS1:  PUSHJ   P,TIE
        SETZ    X2,
        IDPB    X2,NEW
        POPJ    P,

SUBS2:  MOVE OLD,NEWPNT
        ILDB CH,OLD
        CAIN CH,0
        POPJ P,
        IDPB CH,NEW
        JRST SUBS2+1
;ROUTINE TO FIND TEXT WITHIN FILE THAT MATCHES CHARS IN OLDCHS

;TXP/ PTER TO FILE TEXT
;SPT/ PTER TO SEARCH LST
;SCH/ CHA TO SEARCH FOR
;CH/ FILE TEXT CHAR
;BEGLIN/ BEGINN TEXT LINE TO START MAKING SUBST IF FOUND
;ENDLIN/ END    "       "       "       "       "       "       "       "
;BEGPT/ PTER TO FIRST CHAR TO START MAKING SUBST
;ENDPT/ END OF SUBSTI POINTER
;BEGSER/ WHERE TO START NEXT SEARCHING WITHIN LINE

FNDTXT: MOVE SPT,OLTXPT ;GET CHAR TO LOOK FOR POINTER
        MOVE TXP,BEGSER ;GET WHERE TO START
        ILDB SCH,SPT    ;GET FIRST SERCH CHAR
FNDTX1: ILDB CH,TXP
        CAIN SCH,177    ;NULL?
        JRST [CAIN CH,15
                JRST FNDTXX
                JRST FNDTX2]
        CAMN SCH,CH     ;OR EQUAL
        JRST FNDTX2     ;YES
        CAIE CH,15      ;EOF LINE?
        JRST FNDTXA     ;NO
FNDTXX: TLZE F,SUBMAD   ;YES HAVE WE MADE SUBSTIN THIS LINE
        PUSHJ P,MAKSU5  ;YES
        POPJ P,                 ;NO-TEXT NOT FOUND, RETURN

FNDTXA: TLNN F,SUBMAD   ;ANY SUBST MADE IN LINE YT?
        JRST FNDTX1     ;NO
        PUSHJ P,CKCNT           ;YES SO ADD THIS CHAR-LINE TOO LONG?
        IDPB CH,NEW
        JRST FNDTX1

   ;FIRST CHAR MATCHES - TRY TO MATCH REST OF STRING

FNDTX2: MOVEM TXP,BEGPT ;SAVE WHERE IT STARTS
        MOVEM TXP,BEGSER
FNDTX3: CAIN CH,15
        JRST ANOTER
        SKIPN TXP
        JRST FNDTX7
        ILDB SCH,SPT
        CAIN SCH,0      ;END?
        JRST FNDTX5     ;YES
FNDTX6: ILDB CH,TXP
        CAIN SCH,177
        JRST[CAIN CH,15
                JRST FNDTXY
                JRST FNDTX3]
        CAMN SCH,CH
        JRST FNDTX3     ;STILL GOING STRONG
FNDTXY: TLNN F,SUBMAD   ;ANY SUBS?
        JRST FNDTX7     ;NO
        LDB CH,BEGPT    ;GET LAST CHAR
        PUSHJ P,CKCNT
        IDPB CH,NEW
        JRST FNDTXT

FNDTX7: MOVE X1,BEGLIN
        CAMN X1,ENDLIN
        JRST FNDTXT             ;START NEW SEARCH WITHIN LINE
        MOVEM X1,LINE
        POPJ P,
FNDTX5: MOVEM TXP,ENDPT         ;FOUND COMPLETE MATCH
        JRST MAKSUB     ;START SUBSTITUTING

ANOTER: ILDB SCH,SPT    ;GET NEXT CHR - LF
        ILDB SCH,SPT    ;GET NEXT CHAR
        CAIN SCH,0      ;END?
        JRST [SETZM ENDPT       ;YES-ZERO ENDPT MEANS END OF LINE
                JRST MAKSUB]
        AOS ENDLIN              ;GET NEXT LINE
        MOVE X3,ENDLIN
        CAMLE X3,CERNG          ;WITHIN OUR RANGE?
        JRST SUB2               ;NO-THE END, CLEANUP
        MOVE DIC,(X3)
        PUSH P,LINE
        MOVE LINE,X3
        PUSHJ P,MAKPN1          ;GET POINTER TO LINE IN WINDOW OR UPDATE AREA
        JRST FNDTX7             ;END DIC=0
        POP P, LINE
        MOVE TXP,DIC            ;LOAD UP POINTER
        JRST FNDTX6             ;FINISH UP

;ROUTINE TO MAKE SUBSTITUTION USING INFO ABOVE (DESCRIBE BEFORE FNDTXT)
MAKSUB: MOVE X4,CURLIN
        MOVEM X4,DONCHG
        TRNN F,WAIT.F
        JRST MAKSU1             ;NO WAIT - MAK SUB
        MOVE DIC,(X4)
        PUSH P,LINE
        MOVE LINE,X4
        PUSHJ P,MAKPN1
        JFCL ;DIC CANNOT BE ZERO-HAH HAH  OH YEAH? TRY TO CONVINCE ME!
        POP P,LINE
        MOVE X2,BEGPRT
        MOVEI   X1,BUFFRD
        MOVEM   X1,OUTMOD
MAKSU0: ILDB CH,X2
        PUSHJ P,ISUCN           ;PRINT "&" IF CONTROL AND XLATE TO LETTER.
        PUSHJ P,PRTTEX          ;PRINT IT OUT
        CAIE CH,15
        JRST MAKSU0             ;TIL THE END
        MOVEI CH,12
        PUSHJ P,PRTTEX          ;MORE THAN 1 LINE?
        AOJ X4,
        CAMG X4,ENDLIN
        JRST [MOVE DIC,(X4)
        PUSH P,LINE
        MOVE LINE,X4
        PUSHJ P,MAKPN1
        JFCL    ;DIC CNNOT BE 0
        POP P ,LINE
        MOVE X2,DIC
        JRST MAKSU0]
        SKIPLE OTTY+2
        PUSHJ P,PRTTE1
        OUTSTR   OK
        PUSHJ P,YORN
        SKIPA   ;NO
        JRST MAKSU1             ;YES
        MOVE X1,BEGPT           ;NOT OK TO SUB
        LDB CH,X1
        TLNE F,SUBMAD           ;ANY SUB MADE?
        IDPB CH,NEW             ;YASMAM.ADD THIS STRAY CHAR TO NEW IMAGE
        MOVEM X1,BEGPRT         ;NEXT CHAR TO START SEARCH FROM
        MOVEM X1,BEGSER
        SKIPN ENDPT             ;ANY MORE TO SEARCH?
        POPJ P,                 ;NO, ENDPT=0
        JRST FNDTXT             ;TRY FO MORE
MAKSU1: MOVE X1,ENDPT           ;OK TO SUBS.
        MOVEM X1,BEGPRT         ;FOR CONTINUATION OF SEARCH
        MOVEM X1,BEGSER
        MOVE X4,CURLIN
MAKSU7: MOVE DIC,(X4)
        PUSH P,LINE
        MOVE LINE,X4
        PUSHJ P,MAKPN1          ;GET POINTER TO LINE IN WINDOW OR UPDATE AREA
        JFCL
        POP P,LINE
MAKSU3: ILDB CH,DIC             ;GO THRU TEXT LINE,ADDING TO NEW LINE TIL MATCH PLACE
        CAMN DIC,BEGPT          ;AT MATCH PLACE?
        JRST MAKSU2             ;YES-START SUBSTITUTING
        TLNE F,SUBMAD           ;HAVE WE MADE SUBSTITUTIONS?
        JRST[ CAIE CH,15        ;YES- ALREADY HAVE THE CHAR IN THE NEW LINE
        JRST MAKSU3
        AOJA X4,MAKSU7]         ;NEXT LINE
        PUSHJ P,CKCNT           ;NO- TOO MANY CHARS?
        IDPB CH,NEW             ;NO-ADD TO NEW LINE
        CAIE CH,15              ;CR ALREADY?
        JRST MAKSU3             ;NO
        PUSHJ P,MAKSU5          ;INSERT THE LINE
        AOJ X4,                 ;NEXT LINE FROM TEXT
        JRST MAKSU7
MAKSU2: MOVE SPT,NTXPT          ;GET STUFF TO SUBSTITUTE
        PUSHJ P,INCMOD
        TLO F,SUBMAD            ;IN CASE DELETING CHARS
MAKS2A: ILDB CH,SPT             ;GET NEW CHAR
        CAIN CH,0               ;END?
        JRST MAKSU4             ;YES-SEARCH REST OF LINE
        PUSHJ P,CKCNT
        IDPB CH,NEW             ;ADD TO NEW LINE
        TLO F,SUBMAD            ;INDIC SUBST MADE
        CAIE CH,15              ;CR SUB'T?
        JRST MAKS2A             ;NO, KEEP SUBBING
        IBP SPT                 ;GO PAST LF
        PUSHJ P,MAKIN1          ;INSERT THE NEW LINE
        PUSHJ P,SETUP           ;INIT NEW  LINE
        JRST MAKS2A             ;KEEP SUBBING

   ;INSERT THE NEW  LINE

MAKINS: PUSHJ P,CKCNT
        IDPB CH,NEW             ;ADD THE CR
MAKIN1: AOS NCOUNT              ;ADD 1 FOR LF
        PUSHJ P,DEPCNT          ;MAKE NCOUNT POSITIVE
        PUSHJ P,ADDLIN          ;ADD LINE TO UPDATE AREA-OLD POINTS TO LAST CHAR
        PUSHJ P,MAKDIC          ;CREATE DIC ENTRY-UPDATE UPPNT
        SKIPN MRKDIC
        JRST MAKIN2
        MOVE X1,MRKDIC          ;MARK THE NEW ENTRIES AS WAS ORIGINAL
        TRO DIC,(X1)
MAKIN2: PUSHJ P,INSER
        AOS BEGLIN
        AOS ENDLIN
        MOVE LINE,BEGLIN
        SOJ LINE,
        AOS TMPLIN
        AOS CERNG
        PUSHJ P,SETUP
        POPJ P,

MAKSU4: AOS NOSUBS              ;ADD TO NO OF SUBSTITUTIONS
        PUSHJ P,INCMOD          ;INDIC MOD MADE
        MOVE X1,ENDLIN
        MOVEM X1,CURLIN
        SKIPN ENDPT             ;ENDPT=0 MEANS SUB TO END OF LINE
        JRST MAKSU8+1           ;YES
        MOVE DIC,(X1)
        PUSH P,LINE
        MOVE LINE,X1
        PUSHJ P,MAKPN1
        JFCL
        POP P,LINE
        CAMN DIC,ENDPT          ;IS ENDPOINT BEG OF LINE?
        JRST MAKSU8             ;YES
        MOVE TXP,ENDPT          ;START MORE SEARCHES AT END OF SUB'D STRING
        MOVEM TXP,BEGPRT
        MOVEM TXP,BEGSER
        JRST FNDTXT
MAKSU8: SOS ENDLIN
        PUSHJ P,MAKSU5+1
        MOVE LINE ,BEGLIN
        SOJ LINE,
        POPJ P,
MAKSU5: PUSHJ P,MAKINS ;INSERT LINE
        PUSH P,FLRNG
        PUSH P,CERNG
        MOVE X3,BEGLIN
        MOVEM X3,FLRNG
        MOVE X4,ENDLIN
        MOVEM X4,CERNG
        PUSHJ P,DELLOC  ;DELL OLD BEGLIN-ENDLIN
        POP P ,CERNG
        POP P,FLRNG
        MOVE X3,BEGLIN
        MOVE X4,ENDLIN
        SUB X4,X3
        AOJ X4, ;HOW MANY LINES DELETED
        MOVE X3,CERNG
        SUB X3,X4
        MOVEM X3,CERNG
        PUSHJ P,SETUP   ;CLEAR COUNT AND SUCH
        POPJ P,
;TABS COMMAND
;FORMAT- TABS N1,N2,...,NN

TABS: ASCIZ/ABS/
        CAMN CH,CRFLG
        JRST RSTABS             ;RESTORE TABS
        CAMN CH,EQFLG   ;=?
        JRST TABEQ

;SET TAB TABLE
;FIRST MAKE ROOM FOR TEMPORARY TABLE AT END OF LOW CORE TO BUILD INTO.

        MOVE NUM,LASLIN         ;GET LAST USED LOW SEG ADDRESS
        ADDI NUM,2              ;ADDRESS OF 1ST NEW TAB STOP NUMBER
        MOVE X3,NUM             ;X3 WILL BE POINTER INTO NEW TAB TABLE
        PUSH P,X3
        ADDI NUM,TBSLEN-1       ;THE LAST ADDRESS WE'LL NEED
        CAMLE NUM,JOBREL        ;HAVE THE CORE ALREADY?
        PUSHJ P,GETCOR          ;NO-GET ANOTHER PAGE
        POP P,X3                ;GET POINTER BACK

;INITIALIZE COUNTERS:

        MOVEI X1,1              ;CNTR FOR CURRENT (OLD) TAB TABLE
        MOVEI X4,1              ;CNTR FOR NEW TAB TABLE

;ANALYZE TOKEN:

TABTOK: TLNE CH,TERM.F          ;DONE?
        JRST TABFIN             ;YES
        CAME CH,.CTTAB+","      ;COMMA?
        JRST NOTCOM             ;NO
        PUSHJ P,TABDFT          ;YES, MAKE 1 DEFAULT TAB STOP
        PUSHJ P,GETCH           ;AND GET NEXT TOKEN
        JRST TABTOK             ;AND LOOP
NOTCOM: TLNN CH,NUM.F           ;NUMBER?
        JRST QUEST              ;NO-ILLEGAL TOKEN FOUND
        PUSHJ P,MAKOCT          ;PUT NUMBER INTO NUM
        CAIG NUM,LINLEN         ;LESS THAN MAX LINE LENGTH?
        SKIPG NUM               ;AND GREATER THAN ZERO?
        JRST QUEST              ;NO-ILLEGAL NUMBER
        CAIN X4,1               ;FIRST NEW TAB?
        JRST TABORD             ;YES-DO NOT CHECK ORDER
        CAMG NUM,-1(X3)         ;LARGER THAN LAST ENTERED NEW TAB?
        JRST QUEST              ;NO-NUMBER OUT OF ORDER OR USER SPECIFIED
                                ;ILLEGAL COMBINATION OF DEFAULT AND NEW TABS
TABORD: MOVE X2,NUM             ;MOVE NUMBER INTO X2 FOR TABINC
        PUSHJ P,TABINC          ;STORE NUMBER AND INCREMENT COUNTERS
        CAME CH,.CTTAB+","      ;FOLLOWED BY A COMMA?
        JRST NOTCM2             ;NO
        PUSHJ P,GETCH           ;YES-GET NEXT TOKEN
        JRST TABTOK             ;AND ANALYZE IT
NOTCM2: TLNE CH,TERM.F          ;DONE?
        JRST TABFIN             ;YES
        JRST QUEST              ;ILLEGAL TOKEN FOUND

;ROUTINE TO ENTER 1 DEFAULT TAB STOP FROM THE OLD TABLE INTO THE NEW TABLE.
;FINDS THE FIRST OLD TAB STOP THAT IS LARGER THAN THE LAST ENTERED NEW TAB
;(OR SIMPLY TAKES THE 1ST OLD TAB IF IT'S FOR THE 1ST NEW TAB).

TABDFT: CAMLE X1,TABES          ;ANY TABS LEFT IN OLD TABLE?
        POPJ P,                 ;NO-DO NOTHING
        CAIN X4,1               ;FOR 1ST NEW TAB?
        JRST TBORD2             ;YES-NO ORDER CHECK
        MOVE X2,-1(X3)          ;GET LAST ENTERED NEW TAB
        CAML X2,TABES(X1)       ;OLD TAB EXCEEDS LAST ENTERED NEW?
        AOJA X1,TABDFT          ;NO,TRY NEXT OLD TAB
TBORD2: MOVE X2,TABES(X1)       ;GET OLD TAB TO BE USED
        AOJ X1,                 ;PREPARE FOR NEXT DEFAULT REQUEST
        PUSHJ P,TABINC          ;ENTER VALUE AND INCREMENT COUNTERS
        POPJ P,

;ROUTINE TO ENTER VALUE IN X2 INTO NEW TAB TABLE AT X3 AND INCREMENT POINTERS

TABINC: CAILE X4,TBSLEN         ;EXCEEDING NEW TABLE LENGTH?
        JRST QUEST              ;YES
        MOVEM X2,(X3)           ;STORE NEW TAB
        AOJ X3,                 ;INC POINTER TO NEW TAB TABLE
        AOJ X4,                 ;INC COUNTER TO NEW TAB TABLE
        POPJ P,

;ROUTINE TO MOVE THE REMAINDER OF THE OLD TABLE TO THE NEW AND
;FINISH UP

TABFIN: CAIG X4,TBSLEN          ;ROOM LEFT IN NEW TABLE?
        CAMLE X1,TABES          ;AND ANY TABS LEFT IN OLD TABLE?
        JRST TABDON             ;NO
        PUSHJ P,TABDFT          ;YES-MAKE A DEFAULT TAB STOP
        JRST TABFIN             ;AND ITERATE

;ALL DONE . TRANSFER NEW TABLE TO THE "CURRENT" TABLE

TABDON: MOVEI X1,TABES          ;ADDR OF CURRENT TABLE
        MOVE X2,LASLIN
        ADDI X2,1               ;ADDR OF START OF NEW TABLE
        SOJ X4,                 ;GET LENGTH OF NEW  TABLE
        MOVEM X4,(X2)           ;STORE INTO LENGTH ENTRY OF TABLE
        HRL X1,X2               ;XWD (LASLIN)+1,TABES
        BLT X1,TABES(X4)        ;STORE INTO CURRENT TABLE
        JRST GETCOM

;RESTORE TABS FROM DEFAULT TAB TABLE TABINT:

RSTABS: PUSHJ P,RESTAB
        JRST GETCOM

RESTAB: MOVE X1,[TABINT,,TABES]
        BLT X1,TABES+TABLEN
        POPJ P,

;PRINT CURRENT TABS:

TABEQ:  MOVEI X3,1              ;INIT COUNTER INDEX INTO  TAB TABLE
        MOVE X1,TABES(X3)
        PUSH P,X3               ;SAVE COUNTER
        PUSHJ P,PRTNUM
        POP P,X3                ;RESTORE COUNTER
        CAMN X3,TABES           ;PRINTED LAST NUMBER?
        JRST TABEQ1             ;YES
        OUTCHR  .CTTAB+54
        AOJA X3,TABEQ+1
TABEQ1: OUTSTR  CRLF
        JRST GETCOM


FNDUNM: TRO F,FND.F
        PUSHJ P,FNDUN3
        MOVEM NUM,SVNUM
        MOVEI X1,FNDUN1
        MOVEM X1,COMAN
        POPJ P,

FNDUN1: MOVE NUM,SVNUM
        PUSHJ P,FNDUN2
        POPJ P,
;UNMARK COMMAND
        JRST FNDUNM
UNMARK: ASCIZ/NMARK/
        PUSHJ P,CKRNG
        TRNE F,MARK.F
        JRST [PUSHJ P,FNDUNM
        JRST MARKST]
FNDUN3: TLNN CH,NUM.F
        JRST QUEST
        PUSHJ P,MAKOCT
        CAIL NUM,1
        CAILE NUM,2
        JRST QUEST
        TRNE F,FND.F
        POPJ P,
        MOVE LINE,FLRNG
FNDUN2: MOVE DIC,(LINE)
        TRZ DIC,(NUM)
        MOVEM DIC,(LINE)
        TRNE F,FND.F
        POPJ P,
        SKIPN DONCHG
        MOVEM LINE,CURLIN
        AOJ LINE,
        CAMG LINE,CERNG
        JRST FNDUN2
        JRST GETCOM
;VERSION COMMAND
VERSN: ASCIZ/ERSION/
        HLRZ    X1,JOBVER       ;GET TYMSPC PART
        PUSHJ P,PRTOCT
        OUTCHI  "."             ;TYPE A .
        HRRZ    X1,JOBVER       ;GET TYMREL PART
        PUSHJ   P,PRTOCT
        OUTSTR  CRLF
        JRST GETCOM

; PRINT OCTAL NO.
; X1 = NO. TO PRINT
PRTOCT: IDIVI X1,10
        JUMPE X1,PRTOC1
        PUSH P,X2
        PUSHJ P,PRTOCT
        POP P,X2
PRTOC1: MOVEI CH,60(X2)
        OUTCHR  CH
        POPJ P,
;WRITE COMMAND
;FORMAT- R WRITE (CR) OR R WRITE (LF)
; SHORT FORM- R WRITE FILENAME

OLDFIL: ASCIZ/ Existing file - Ok? /
OFILKK: BYTE (9) " ","E","x","i","s","t","i","n","g"," ","f","i"
        BYTE (9) "l","e"," ","-","O","K","?"," ",0
NEWFIL: ASCIZ/ New file - Ok? /
NFILKK: BYTE (9) " ","N","e","w"," ","f","i","l","e"," ","-","O","K","?"," ",0

        ASC2KK
KKMISM: KK2ASC

ASC2KK: ASCIZ/ Can't do because the workspace is ascii and the file is kata kana.
/

KK2ASC: ASCIZ/ Can't do because the workspace is kata kana and the file is ascii.
/

        JRST FNDWR
WRITE:  ASCIZ/RITE/
        SKIPE FLRNG             ;WAS A LINE RANGE GIVEN?
        SETOM RANGE             ;YES,SET FLAG TO NOT RESET MODIFICATIONS COUNTER
        PUSHJ P,CKRNG
        TRNE F,MARK.F
        JRST [PUSHJ P,FNDWR
        JRST MARKST]
FNDAP1: TLZ F,COMBLK            ;ASSUME NO COMPRESS BLANKS
        TLNN CH,TERM.F          ;END OF COMMAND?
        JRST WRIT1              ;NO,FILE NAME WAS GIVEN
        HLLI CH,0               ;YES,SEE WHAT KIND OF TERMINATION
        CAIN CH,12              ;LF? MEANS DON'T COMPRESS BLANKS-NOT IMP
        JRST QUEST;TLO F,COMBLK
        TRNN F,RPG.F            ;EXIT OR CHECKPOINT COMMAND?
        JRST WRIT1B             ;NO
        SKIPE RPG               ;ORIGINALLY FROM RPG?
        JRST WRIT1A             ;YES,WE HAVE A FILE NAME
WRIT1B: PUSHJ P,TOFIL   ;PUT OUT TO:
WRIT1:  MOVEI X1,OUTFIL         ; PUT THE FILE NAME
        PUSHJ P,FILNAM          ; INTO THE LOOKUP BLOCK 'OUTFIL'
WRIT1A: MOVEI   X1,OUTFIL       ; AND EXTEND IT TO A
        PUSHJ   P,X10215        ; 15 WORD LOOKUP BLOCK

        SKIPE   WSFLMD          ; IS THE WORKSPACE NORMAL ASCII?
        JRST    NOPE            ; NOPE

        OPEN    OUTF,OUSPEC     ; YEP, OPEN FIR NORMAL ASCII
        JRST    %DVFAL
        JRST    WRIT1C

NOPE:   OPEN    OUTF,KKOSPC     ; OPEN FOR KATA KANA
        JRST    %DVFAL

WRIT1C: MOVEI X1,1
        HRRM X1,OUTBLK


        LOOKUP  OUTF,OUTFIL     ;LOOKUP THE FILE
        JRST    [TLZ F,APPEN.F  ;FAILURE..ASSUME WRITE COMMAND,DON'T WORRY ABOUT MODE
                JRST WRIT2]

        SETZM   X2              ; GET DATA MODE OF FILE INTO X2
        LDB     X1,OTFLMD
        CAIN    X1,2
        SETO    X2,             ; DATA MODE=2 MEANS KATA KANA
        LDB     X1,OTFKKB       ; WE ALSO LOK AT THE KATA BIT
        SKIPE   X1
        SETO    X2,

        CAMN    X2,WSFLMD       ; DATA MODE MUST EQUAL WORKSPACE MODE
        JRST    WRIT2
                                ; OR WE GIVE AN ERROR
        RELEASE OUTF,           ; RELEASE THE CHANNEL
        OUTSTR  @KKMISM(X2)     ; GIVE KATA KANA MIS MATCH MESSAGE
        JRST    GETCOM          ; AND CONTINUE

WRIT2:  TLNN    F,APPEN.F       ; APPENDING?
        CLOSE   OUTF,           ; no, close the file so as not to get update mode
        TLNE    F,APPEN.F       ;IF APPENDING,
        PUSHJ   P,APPINB        ;INPUT LAST BLOCK, SET LAST BLOCK TO WRITE

        SETZM   OUTFIL+4        ;NO PROT, TIME
        SETZM   OUTFIL+14
        HLLZS   OUTFIL+3        ;ONLY EXT IS THERE
        MOVE    X1,WSFLMD       ;set normal ascii or kata kana
        DPB     X1,OTFKKB       ;in the extended ENTER block (as well as mode)
        ENTER   OUTF,OUTFIL     ;ENTER THE FILE
        JRST    [CLOSE OUTF,40  ;CLOSE THE FILE (CANCEL)
                RELEASE OUTF,   ;RELEASE THE CHANNEL
                HRRZ X1,OUTFIL+3 ;GET ERROR CODE
                JRST FOPERR]    ;ERROR


        LDB     0,[POINT 1,OUTFIL+3,18 ]        ; 1 IF OLD, 0 IF NEW
        TLNE    F,APPEN.F       ;APPENDING TO OLD FILE?
        SETO    0,              ;YES, SET OLD FILE
        TRNE    F,RPG.F         ;SKIP IF NOT RPG-TYPE COMMAND
        TRNN    F,FIL.EQ        ;SKIP IF ASK FOR NAME PRINTING
        JRST    NONRPG
        PUSHJ   P,WRIT4B        ;PRINT THE NAME
        JRST    FILEOK
NONRPG: SKIPE   WSFLMD  ; IS THE WORKSPACE KATA KANA?
        JRST    PRMTKK  ;  YES, GO DO KATA KANA PROMPTS

        SKIPE   0       ;SKIP IF NEW FILE
        MOVEI   X2,OLDFIL
        SKIPN   0
        MOVEI   X2,NEWFIL
        JRST    GITCON

PRMTKK: SKIPE 0         ; SKIP IF NEW FILE
        MOVEI   X2,OFILKK
        SKIPN   0
        MOVEI   X2,NFILKK

GITCON: MOVEI   X1,5    ; CALL TIE TO GET CONFIRMATION
        PUSHJ   P,TIE
        MOVE    NEW,NEWPNT
        ILDB    CH,NEW
        CAIN CH,15              ;A C.R ?
        JRST FILEOK             ;YES, FILE CONFIRMED
        CAIE CH,"Y"             ;OR A Y?
        CAIN CH,"y"             ;OR A LOWER CASE Y?
        JRST    FILEOK          ;YES
        CLOSE OUTF,40           ;NO, RELEASE FILE
        RELEASE OUTF,
        SETO X1,                ;ERR CODE -1: CONFIRM ERROR
        JRST FOPERR             ;TYPE MESSAGE
FILEOK: MOVEI   X1,OBUFR
        MOVEM   X1,JOBFF        ;WHERE BUFFERS GO
        OUTBUF  OUTF,1          ;ONLY EAT 1
        XCT OUTBLK              ;DO A USETO
        TLNN F,APPEN.F          ;Appending? if so, dump last buffer of
                                ;original file into output buffer
        JRST PENDON             ;no

DOAPP:  SOSGE IOBUF+2           ;count of chars in input buffer
        JRST PENDON             ;no more-all done
        ILDB CH,IOBUF+1
        JUMPE CH,DOAPP          ;ignore nulls
        PUSHJ P,OUTCHR          ;add char to output buffer
        JRST DOAPP
PENDON:
        IFN %CIPFLG,<
        SKIPE   ,CPFLAG
        SETOM   ,CP2FLG         ;SET FLAG FOR POSS. CIPHER INIT.>
        TRNE F,FND.F
        POPJ P,
        MOVE LINE,FLRNG
        MOVE X1,LASLIN
        CAIG X1,DICT
        JRST FNDAP3     ;NO TEXT
WRIT7:  MOVE DIC,(LINE)
        PUSHJ P,MAKPN1
        JRST FNDAP3 ;DIC=0
WRIT6:  ILDB CH,DIC
        IFN COMPRESS,<
        TLNN F,COMBLK   ;SHOULD WE CHECK FOR BLANKS
        JRST WRIT5
        CAIE CH,40      ;YES -IS IT ONE?
        JRST WRIT5
        MOVEI X2,1
        TLZ F,BLANK.F
WRIT6B: ILDB X1,DIC
        CAIE X1,40
        JRST WRIT6A
        AOJ X2, ;KEEP A COUNT OF HOW MANY BLANKS
        TLO F,BLANK.F
        JRST WRIT6B
WRIT6A: TLZE F,BLANK.F
        PUSHJ P,OUTTAB
        DEC DIC
>
WRIT5:  PUSHJ P,OUTCHR
        CAIE CH,15
        JRST WRIT6      
        MOVEI CH,12
        PUSHJ P,OUTCHR
FNDAP3: TRNE F,FND.F
        POPJ P,
        SKIPN DONCHG
        MOVEM LINE,CURLIN
        AOJ LINE,
        CAMG LINE,CERNG
        JRST WRIT7

FNDAP2: IFN %CIPFLG,<
        SKIPN   ,CPFLAG
        JRST    FNDAP4          ;JUMP IF NOT CIPHERING
        TLNN    F,APPEN.F       ;IGNORE CIPHERING IF APPENDING
        PUSHJ   P,CPBFO         ;CIPHER LAST BLOCK BEFORE CLOSE>

FNDAP4: CLOSE   OUTF,
        MOVEI X1,5              ; LOOKUP PPN AND SIZE
        MOVEM X1,OUTFIL         ;COUNT
        LOOKUP OUTF,OUTFIL
        JRST    [RELEASE OUTF,
                HRRZ X1,OUTFIL+3 ;THE ERROR CODE IS RH OF EXTENSION WORD
                JRST FOPERR]

        MOVE X1,OUTFIL+5        ;SIZE OF FILE
        MOVEI   X2,^D36         ; WORD LENGTH
        IDIV    X2,WSBYSZ       ; DIVIDED BY BYTE SIZE INTO R2
        PUSHJ P,GETCT           ;REPORT THE NO OF CHARS
        MOVE X1,OUTFIL+1        ;GET PPN OF THE WRITE FILE FOR COMPARISON
        SKIPN RANGE             ;PARTIAL (RANGE) WRITE?
        TLNE F,APPEN.F          ;OR APPENDING?
        JRST NOCHEK             ;YES-DOES NOT CONSTITUTE A CHECKPOINT
        SKIPN RPG               ;IS THERE A DEFAULT FILE NAME?
        JRST CHEKP              ;NO
        TRNE F,RPG.F            ;YES-EXIT,GO OR CHECKPOINT
        TRNN F,FIL.EQ           ;WITH DEFAULT FILE NAME IMPLIES A CHECKPOINT
        PUSHJ P,FILCMP          ;IF NAMES ARE NOT THE SAME SKIP
        SKIPA                   ;YES, A CHECKPOINT
        JRST NOCHEK             ;NOT A CHECKPOINT
        MOVEI X1,1              ;TRUE-SET FLAG
        MOVEM X1,FILCHE         ;NOTE THAT FILE HAS BEEN CHECKPOINTED
CHEKP:  PUSHJ P,INIMOD          ;IF THIS CONSTITUTES A CHECKPOINT, RESET MODIFICATIONS COUNTER
NOCHEK: SETZM RANGE             ;RESET RANGE FLAG
        TRZ F,FIL.EQ            ;RESET DEFAULT FILE FLAG
        TRNE F,FND.F!RPG.F
        POPJ P,
        JRST GETCOM

;ROUTINE TO COMPARE THE FILE NAME IN OUTFIL WITH THAT IN RPGFIL, USING
;THE CONTENTS OF X1 AS THE PPN FOR OUTFIL. IF THE TWO ARE THE SAME,
;RETURNS NORMALLY, ELSE TAKES THE SKIP RETURN.

FILCMP: GETPPN X2,              ;GET PPN OF CURRENT DIRECTORY
        SKIPN X1                ;IS OUTFIL PPN 0?
        MOVE X1,X2              ;YES, REPLACE WITH EQUIVALENT PPN
        SKIPN RPGFIL+3          ;IS RPGFIL PPN 0?
        MOVEM X2,RPGFIL+3       ;YES, REPLACE WITH EQUIVALENT PPN
        CAME X1,RPGFIL+3        ;PPN'S THE SAME?
        JRST CPOPJ1             ;NO, TAKE THE SKIP RETURN
        MOVE X1,OUTFIL+2        ;GET FILE NAME
        CAME X1,RPGFIL          ;SAME NAME?
        JRST CPOPJ1             ;NO, TAKE THE SKIP RETURN
        HLRZ X1,OUTFIL+3        ;GET EXTENSION
        HLRZ X2,RPGFIL+1
        CAME X1,X2              ;SAME EXTENSION?
        JRST CPOPJ1             ;NO, TAKE THE SKIP RETURN
        POPJ P,                 ;YES. SAME FILE NAME, RETURN NORMALLY
;ROUTINE TO WRITE FILE NAME CRLF

WRIT4B: PUSHJ P,WRFNAM
        OUTSTR CRLF
        POPJ P,

;ROUTINE TO WRITE FILE NAME CONTAINED IN OUTFIL
;OR "PRINT FILE NOMEN" IF IT EXISTS

WRFNAM: TRNE F,COMF.F!BUF.F
        POPJ P,                 ;IF BUFFER,DON'T BOTHER TO PRINT

        SKIPN WRIPFN            ;USE PRINT FILE NAME?
        JRST WRI4BB             ;NO
        OUTSTR PFNAME
        POPJ P,

;GET USERNAME:

WRI4BB: HLRZ X1,OUTFIL+1        ;GET LEFT HALF OF PPN
        SKIPN X1                ;IF ZERO,PRINT OUT USERNAME
        SKIPN OUTFIL+1          ;BUT NOT IF ALL ZERO
        JRST WRI4BA             ;NO USERNAME
        OUTCHR .CTTAB+50         ;"("
        MOVE NEW,[POINT 6,0]    ;SET UP SIXBIT POINTER
        HRR NEW,OUTFIL+1        ;GET ADDR OF USERNAME
        ILDB CH,NEW             ;GET FIRST CHAR
        MOVE X1,[600,,0]        ;SET UP END POINTER
        ADD X1,OUTFIL+1
        AOJ X1,                 ;GET POINTER TO LAST CHR OF USRNAM
        PUSHJ P,PRTSIX          ;PRINT OUT NAME
        OUTCHR .CTTAB+51         ;")"

WRI4BA: MOVE NEW,[POINT 6,OUTFIL+2]       ;SET UP START POINTER
        MOVE X1,[600,,OUTFIL+2]
        ILDB CH,NEW
        PUSHJ P,PRTSIX
        MOVE NEW,[POINT 6,OUTFIL+3]
        MOVE X1,[POINT 6,OUTFIL+3,17]
        ILDB CH,NEW
        SKIPN CH
        JRST LOKPPN
        OUTCHR  .CTTAB+56        ; .
        PUSHJ P,PRTSIX

;LOOK FOR PPN:

LOKPPN: HLRZ X1,OUTFIL+1        ;IS THERE A NON-ZERO LEFT HALF?
        SKIPN X1                ;YES, ITS A PPN
        JRST WRIT4C             ;NO
        SETOM X1
        GETPPN X1,              ;GET THIS USER'S PPN
        CAMN X1,OUTFIL+1        ;IS THIS HERS?
        JRST WRIT4C             ;YES,ALL DONE
        OUTCHR .CTTAB+133        ;"[". 
        HLRZ X1,OUTFIL+1
        PUSHJ P,PRTOCT
        OUTCHR .CTTAB+54         ;","
        HRRZ X1,OUTFIL+1
        PUSHJ P,PRTOCT
        OUTCHR .CTTAB+135        ;"]"

WRIT4C: POPJ P,

;ROUTINE TO WRITE THE DEFAULT FILE NAME.
;IF THERE IS A "PRINT FILE NOMEN" IT IS USED, OTHERWISE
;THE REAL FILE NAME. DOES NOT PRINT CRLF.

WRDFNM: DMOVE   X1,RPGNAM               ;MOVE FILE NAME TO OUTPUT FILE BLOCK
        DMOVEM  X1,OUTNAM
        DMOVE   X1,RPGFIL
        DMOVEM  X1,OUTFIL+2
        MOVE    X1,RPGFIL+3     ; THE PPN
        MOVEM   X1,OUTFIL+1
        PUSHJ P,WRFNAM
        POPJ P,

PRTSIX: SKIPN CH
        POPJ P,
        ADDI CH,40              ;CONVERT TO 7BIT
        OUTCHR  CH
        CAMN NEW,X1
        POPJ P,
        ILDB CH,NEW
        JRST PRTSIX

APPINB: MOVE X1,OUTFIL+5        ;size of file
        IDIVI X1,BLKSIZ         ;# full blks
        SKIPE   X2              ;was there a partially full block?
        AOJ X1,                 ;yes, add one
        HRRM X1,OUTBLK          ;last blk is 1st blk to output later
        HRRM X1,APPBLK          ;for USETI
        MOVEI X1,RBUFR          ;use the Replace buffer for this operation
        MOVEM X1,JOBFF
        INBUF OUTF,1            ;set up input buffers
        XCT APPBLK              ;do the USETI
        IN OUTF,0               ;input the last blk of the append file
        POPJ P,
        JRST OUTFAL
;PUT A CHARACTER IN OUTPUT BUFFER.
;IF BUFFER FULL, SEND IT WITH OUT UUO
;FIRST OUT UUO SETS UP BUFFERS BUT TRANSMITS NO DATA
;IF CIPHERING, USE 1ST UUO TO INIT CIPHER, AND CIPHER BUFFER
;BEFORE EACH SUBSEQUENT UUO
;IGNORE CIPHERING WHEN USING APPEND COMMAND.

OUTCHR: SOSLE   OBUF+2
        JRST    OUTOK

        IFN %CIPFLG,<       SKIPE CPFLAG
        JRST [TLNE F,APPEN.F
              JRST OUTCH1       ;APPENDING-DON'T CIPHER
              JRST OUTCIP]
>

OUTCH1: OUT     OUTF,0
        JRST    OUTOK
OUTFAL: GETSTS OUTF,X1
        CLOSE   OUTF,40
        RELEASE OUTF,
        SETO X2,                ;INDICATE WRITE
        JRST    %IOFAL          ;UUO ERROR--I/O FAILURE
OUTOK:  IDPB    CH,OBUF+1
        POPJ    P,

        IFN %CIPFLG,<
OUTCIP: SKIPN   ,CP2FLG
        PUSHJ   P,CPBFO         ;NOT FIRST OUT UUO, SO ENCIPHER BUFFER
        OUT     OUTF,0
        JRST    OUTCH2
        JRST    OUTFAL
OUTCH2: TLNE    F,APPEN.F
        JRST    OUTOK
        SKIPE   CP2FLG
        PUSHJ   P,CPWIN         ;FIRST OUT UUO. INIT CIPHER.
        SETZM   ,CP2FLG         ;KILL FLAG
        JRST    OUTOK
>

;**** LOW SEG. CODE -- NON-ZERO INFO ****
; ADD STUFF IN HERE WHICH IS **NOT** ZERO INFORMATION
        IFN     PURE,<
HIGH:   RELOC
LOW:    RELOC
        PHASE   LOW>

FNDPNT: POINT 7,FCMND   ;FOR FIND COMMAND
NTXPT:  POINT 7,NEWCHS  ;PTR FOR SUBS
OLTXPT: POINT 7,OLDCHS  ;PTR FOR SUBS
CMDPNT: POINT 7,CMDLIN  ;POINTER TO BEGINNING OF COMMAND LINE (SAVED)
NEWPNT: POINT 7,NEWLIN  ;SEE AC NEW: POINTER TO BEGINNING OF NEW[CURRENT] LINE
NEWBCB: EXP     NEWLIN,LINLEN,0,0,0
OLDPNT: POINT 7,OLDLIN  ;SEE AC OLD: POINTER TO BEGINNING OF OLD[IMAGE] LINE
OLDBCB: EXP     OLDLIN,LINLEN,0,0,0
ALTADR: EXP     GTFALT  ;ADDRESS TO DISMSS TO

; PMTADR contains three prompts in one asciz string
; three routines set up BCBs for them. they are:
;       *      set up in STARPR
;       "      set up in QUOTPR
;     for "    set up in FORPR

; KKPRMT is the kata kana version of the same

PMTADR: ASCIZ /*"for "/

KKPRMT: BYTE (9) "*",^O42,"f","o","r"," ",^O42,0
SYSTMP: SIXBIT  /###EDT/
        SIXBIT  /TMP/
        0
        0
BLOCK:  SIXBIT  /EDT/
        IOWD    ^D15,BUFFA
        0
TTYBLK: EXP 1101
        SIXBIT/TTY/
        XWD OTTY,0
TABINT: EXP     TABLEN,11,21,31,41,51,61,71,101,111,121
        IFN %CIPFLG,<
        ;INITIAL VALUES FOR PRIME TABLE

        RADIX   ^D10
CPINI:  EXP     3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47
        EXP     53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107
        EXP     109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167
        EXP     173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229
        EXP     233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283
        EXP     293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359
        EXP     367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431
        EXP     433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491
        EXP     499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571
        EXP     577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641
        EXP     643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709
        EXP     719, 727

;INITIAL VALUES FOR STATE VECTORS

IIY1:   EXP  5772156649
        EXP 3141592653
        EXP 1781072418
        EXP 2718281829
        EXP 1618033989
        EXP 2070869212
        EXP 6931471805
        EXP 1414213562
        EXP 8414709848
>
        RADIX   ^D8
PAGNUM: 2       ;PAGE NUMBER FOR PAGE/PRINT COMMAND
LINPAG: ^D54    ;NUMBER OF TEXT LINES PER PAGE FOR PAGE/PRINT COMMAND
SPCING: 1       ;SPACING FOR PAGE/PRINT COMMAND LINES. 1 IS NORMAL.
WINLST: IOWD    NOBLKS*BLKSIZ,WINDOW
        0
OUTBLK: USETO   OUTF,1          ;RIGHT HALVES OF THESE WDS ARE BLK NUMBERS
APPBLK: USETI   OUTF,1          ;ditto. for use in APPENDing.
INBLK:  USETI   TMP,1
TMPBLK: USETO   TMP,1
TMPLST: IOWD    NOUPBK*BLKSIZ,UPDATE
        0
UUOH:   0
        JRST    UUOHAN
RINBUF: -1                      ;BUFFER NUMBER TO CALL ON ONRING RING
PLIST:  IOWD    PDLSIZ,PBLOCK
;=== LOW SEG. CODE -- ZERO INFO ***
; ZERO INFORMATION GOES IN HERE
        IFN     PURE,<
ZZZ==.-LOW
        RELOC
LOW:    BLOCK   ZZZ>
LOWEND:                 ;LOW SEG START

; FROM HERE TO PBLOCK NOT ZEROED ON INITIALIZATION

RPG:    BLOCK   1       ;-1=RPG ENTRANCE, 0=NORMAL

; AREA FROM PBLOCK TO LASTZR ZEROED ON INITIALIZATION
; BUT NOT DURING A CLEAR COMMAND.
; THE ITEMS IN THIS GROUP NEED TO BE SAVED FOR QUITTING TIME
; OR HAVE TO DO WITH COMMAND FILES, SINCE THE
; CLEAR COMMAND CAN BE GIVEN FROM A COMMAND FILE WITHOUT BEING THE LAST
; THING IN IT.

PBLOCK: BLOCK PDLSIZ    ;PUSH DOWN LIST
NOESC:  BLOCK 1         ;IF -1, THEN DO NOT EXIT TO XEXEC
SVJOB:  BLOCK 1         ;ORIGINAL CORE SIZE-USED IN CLEAR COMMAND TO RESET
COMNAM: BLOCK 2         ;USERNAME FOR COMMAND FILE
COMFIL: BLOCK 15        ;COMMAND FILE LOOKUP BLOCK
ICOMF:  BLOCK 3         ;COMMAND FILE BUFFER HEADER
COMBUF: BLOCK 203       ;COMMAND FILE BUFFER
PCODNO: BLOCK 1         ;RTYCHG CODE NUMBER
FILCHE: BLOCK 1         ;TRUE (=1) IF DEFAULT FILE NAME HAS BEEN CHECKPOINTED
CMDPTM: BLOCK 1         ; 0 if command port(terminal) is ascii, -1 for Kata Kana


; DICT MUST ALWAYS END TEMPORARY AREA
; TBES REFILED ON CLEAR COMMAND
; AREA BETWEEN FRSTZR AND LASTZR ZEROED ON CLEAR COMMAND

FRSTZR: BLOCK 1         ;ZERO FROM HERE TO LASTZR ON CLEAR
TMPFIL: BLOCK 4         ;TEMPORARY WORK FILE 
WRIPFN: BLOCK 1         ;-1 IF PRINT FILE NAME IN PFNAME USED WHEN FILE NAME WRITTEN
TABES:  BLOCK TBSLEN+1  ;TAB TABLE
EXAMIN: BLOCK 1         ;IF -1, THEN WE ARE EXAMINING THE FILE, NOT MODIFYING,
                        ;AND WE MUST NOT WRITE TO IT.

FLMDET: BLOCK 1         ; -1 => workspace file mode has been determined
WSFLMD: BLOCK 1         ; workspace file mode: 0=normal  -1=Kata Kana
WSBYSZ: BLOCK 1         ; workspace byte size: 7 for normal  9 for Kata Kana
KKINFL: BLOCK 1         ; -1 if the input file is Kata Kana, 0 for normal ascii
REPFLM: BLOCK 1         ; -1 if the replace file id Kata kana, 0 for normal asccii
WSCHPW: BLOCK 1         ;number of characters per word in the workspace
KLUDGE: BLOCK 1         ;TRUE IF CONTENTS OF REGISTER 17 ON EDITOR ENTRY IS SIXBIT /KLUDGE/
PROCNO: BLOCK 1         ;CONTENTS OF REGISTER 16 ON EDITOR ENTRY: PROCESSOR NO
KLUCOD: BLOCK 1         ;CONTENTS OF REGISTER 15 ON EDITOR ENTRY: KLUDGE CODE
PFNAME: BLOCK ^D15      ;SPACE FOR PRINT FILE NAME
RPGNAM: BLOCK 2         ;USERNAME FOR RPGFIL-MUST IMM PRECEED
RPGFIL: BLOCK 4
BUFFA:  BLOCK ^D15      ;TMPCOR BUFFER AREA
CRECMD: BLOCK   1       ;-1 IF CREATE/MODIFY CMD ELSE 0
GIVCNT: BLOCK 1         ;-1 IF WE GIVE A COUNT AFTER FIND, ETC
ALTFLG: BLOCK 1         ;-1 IF AN ESCAPE IS PENDING IN %OFFESC MODE
ALTCNT: BLOCK 1         ;AOS ON ESCAPE, SETZ ON CMD
ESCNTR: BLOCK 1         ;0 IF %ONESC ELSE + IF %OFFESC
ALTBLK: BLOCK 3         ;ALT MODE CONTROL BLOCK FOR DISMISS
EOR:    BLOCK 1
CHGCUR: BLOCK 1
DONCHG: BLOCK 1
DONGET: BLOCK 1
DONZER: BLOCK 1
COLON:  BLOCK 1
MODMAR: BLOCK 1
EXPTAB: BLOCK 1         ;IF ZERO THEN DONT EXPAND TABS FROM THE INPUT FILE
LINFND: BLOCK 1
OUTMOD: BLOCK 1         ;0 FOR BUFFERED OUTPUT, -1 FOR DIRECT OUTPUT
PCOUNT: BLOCK 1         ;COUNT OF CHARS PUT OUT IN CURRENT PRINTED LINE
NOTPRN: BLOCK 1         ;IF -1, THEN NOT PAGE/PRINT COMMAND. 0 IF SO.
ENDSER: BLOCK 1
SAVAC: BLOCK 20         ;ARRAY IN WHICH TO SAVE ACCUMULATORS
SAVRD:  BLOCK 20        ;ARRAY IN WHICH TO SAVE ACCUMULATORS FOR READFL

SVNUM: BLOCK 1
;STOR FOR FIND COMMAND-MUST BEGIN WITH FCMND AND END WITH OHIER

FCMND: BLOCK BUFLEN               ;SEE FIND COMMAND
SOURCE: BLOCK ^D50
SRCPNT: BLOCK ^D50
POLISH: BLOCK ^D25
OHIER: BLOCK ^D25

NOFNDS: BLOCK 1
SVLIN: BLOCK 1
TRUTH: BLOCK 1          ;USED ONLY IN FIND COMMAND BOOLEAN LOGIC
RANGE: BLOCK 1          ;USED IN READ AND WRITE COMMANDS TO INDICATE RANGE GIVEN
POLPT: BLOCK 1
SVPTR: BLOCK 1          ;USED IN FIND COMMAND, PTS TO LAST CHR OF SEARCH
SVPTRA: BLOCK 1         ;SAVE PTR FOR OPERAND A
SVPTRB: BLOCK 1         ;SAVE PTR FOR OPERAND B
SVOPRB: BLOCK 1         ;SAVE OPERAND B
SVFNDP: BLOCK 1         ;CONTENTS OF STACK REG P AT START OF FIND EVALUATION
BEGDIC: BLOCK 1         ;ORIG DIC, RESTORE AFTER ELLIPSIS OP (...)
NOSUBS: BLOCK 1; COUNTER FOR NO OF SUBSTITU
BEGPRT: BLOCK 1 ;WHERE TO START PRINTING FROM IN MAKSUB
BEGLIN: BLOCK 1;        STRT LINE TO MAK SUBS IN
ENDLIN: BLOCK 1; END LINE TO MAK SUBST
BEGPT: BLOCK 1 ;POINTER TO FIRST CHAR TO START SUBS FOR
ENDPT: BLOCK 1 ;POINTER TO CHAR TO PICK UP
BEGSER: BLOCK 1 ;POINTER TO CHAR TO START SEARCH IN
FNEQPR: BLOCK 1         ;IF -1, LINES FOUND BY FIND= WILL PRINT
TAGFLG: BLOCK 1 ;FOR FIND COMMAND
NEWCHS: BLOCK BUFLEN
OLDCHS: BLOCK BUFLEN
OTTY: BLOCK 3
TTYBUF: BLOCK 23

REPNAM: BLOCK 2         ;USERNAME FOR REPLACE FILE
REPFIL: BLOCK 15        ; LOOKUP BLOCK FOR REPLACE FILE

RBUF:   BLOCK 3
RBUFR:  BLOCK 203
IBUF: BLOCK 3
IBUFR: BLOCK 203
INNAM:  BLOCK 2 ;USERNAME FOR INFIL
INFIL:  BLOCK 15 ;FILE TO READ FROM
IOBUF: BLOCK 3
OBUF:   BLOCK 3
OBUFR:  BLOCK 203
OUTNAM: BLOCK 2 ;USERNAME FOR OUTFIL - MUST PRECEED OUTFIL
OUTFIL: BLOCK 15 ;      FILE TO WRITE TO

WNBLK1: BLOCK 1         ;CONTAINS THE LAST BLOCK NO OF TMP FILE CONTAINED
                        ;IN FIRST WINDOW AREA
WNBLK2: BLOCK 1         ;CONTAINS THE LAST BLOCK NO OF TMP FILE CONTAINED
                        ;IN SECOND WINDOW AREA.
WNLAST: BLOCK 1         ;BLOCK NO LAST REFERENCED-USED IN REPLCEMENT ALGORITHM
WINDOW: BLOCK NOWNDS*NOBLKS*BLKSIZ

UPPNT:  BLOCK 1 ;POINTER TO UPDATE AREA
UPCNT:BLOCK 1
UPDATE: BLOCK NOUPBK*200        ;UPDATE AREA
SRCLST: BLOCK ^D50
ENDSRC: BLOCK 1
SSER:   BLOCK 1 ;SAVE POINTER- USED IN ADRCAL
STSER:  BLOCK 1
CURTMP: BLOCK 1; CURLIN USED IN CALCULTEING-DURING ADRCAL
MODMAD: BLOCK 1         ;IF NON-ZERO THEN MODIFICATIONS HAVE BEEN MADE.
                        ;SEE ROUTINES INCMOD, DECMOD, AND INIMOD
IMPMOD: BLOCK 1         ;IF -1, AN IMPLICIT MODIFICATION IS BEING MADE
L1:     BLOCK 1
L2:     BLOCK 1
SEQNOS: BLOCK 1 ; HAVE WE ENCOUNTERED STICKY LINE NUMBERS?
FRSTTM: BLOCK 1
LINENO: BLOCK 1
EOF:    BLOCK 1
READLN: BLOCK 1
FLLIN: BLOCK 1
CELIN: BLOCK 1
FLRNG:BLOCK 1           ;LOWER BOUNDARY TO RANGE IN TERMS OF DICTIONARY ADDR
CERNG:BLOCK 1           ;UPPER BOUNDARY TO RANGE
BUFNO:BLOCK 1
LASLIN: BLOCK 1 ;LAST LINE IN DICTIONARY
PRECUR: BLOCK 1 ;CURLIN BEFORE ALTMODE HIT-OIY
CURLIN: BLOCK 1 ;CURRENT LINE NO IN DICT
TMPLIN: BLOCK 1 ; TEMP LINE NO (CURRENT LINE DURING CALCULATIONS
COMAN:  BLOCK 1 ;ADRES TO GO TO(COMAND)
ENDCM: BLOCK 1          ;ADDR TO GO TO, TO FINISH UP A COMMAND
WORD:   BLOCK 3

NEWLIN: BLOCK BUFLEN

CMDLIN: BLOCK BUFLEN            ;SAVES TEXT OF LAST COMMAND ENTERED
OLDLIN: BLOCK BUFLEN
RDLIN:  BLOCK BUFLEN

TIRE:   BLOCK   ^D24    ;CALL BLOCK FOR I%TIE
TIRADR: BLOCK   1       ;ADDRESS OF TIRE
TIEMOD: BLOCK   1       ;MODE IN WHICH TIE HAS BEEN CALLED AS FOLLOWS:
                ; 0 - COMMAND LEVEL
                ; 1 - SUBSTITUTE FIRST STRING
                ; 2 - APPEND/INSERT
                ; 3 - EDIT/MODIFY
                ; 4 - LOAD/GET OF COMMAND BUFFER
                ; 5 - NORMAL CALL, X2 CONTAINS ASCIZ PROMPT
                ; 6 - SUBSTITUTE SECOND STRING
TIEBCB: BLOCK 5         ;BCB FOR PROMPT
NCOUNT: BLOCK 1
OCOUNT: BLOCK 1
DUMDUM: BLOCK 1
DELIM:  BLOCK 1

        IFN %CIPFLG,<
;CIPHERING VARIABLES
CP1FLG: BLOCK 1   ;FLAG TELLING THAT NEXT BFR WILL BE 1ST BFR PROCESSED
CP2FLG: BLOCK 1   ;FLAG TELLING THAT NEXT OUT UUO WILL BE FIRST FOR THIS FILE
CPCNT:  BLOCK 1   ;COUNTER FOR RUNNING-KEY GENERATOR
CPFVER: BLOCK 1   ;CIPHER VERSION OF CURRENT INPUT FILE (NEEDN'T BE =TO CPVERS)
CPTMP:  BLOCK 1   ;CIPHERING TEMP VAR
CPLAST: BLOCK 1   ;LAST ADDR IN BUFFER THAT WE'RE CIPHERING
CPTAB:  BLOCK CPRIMS   ;WORKING TABLE FOR CIPHER EXCHANGES
IY1:    BLOCK 1   ;NINE CIPHER STATE VECTORS
IY2:    BLOCK 1   ;THREE FOR EACH R.N.G.
IY3:    BLOCK 1
IY4:    BLOCK 1
IY5:    BLOCK 1
IY6:    BLOCK 1
IY7:    BLOCK 1
IY8:    BLOCK 1
IY9:    BLOCK 1
        
KEYCNT: BLOCK 1   ;CHECK THAT KEY LENGTH NOT TOO BIG
KEYPTR: BLOCK 1   ;POINTER INTO KEY BUFFER
KEYPT1: BLOCK 1    ;TEMP KEY POINTER USED DURING CIPHER CMD
CPFLAG: BLOCK 1   ;CIPHERING Y/N FLAG
KEYBUF: BLOCK KEYMAX
KEYBF1: BLOCK KEYMAX
KEYBF2: BLOCK KEYMAX>

MRKDIC: BLOCK 1
MARKNO: BLOCK 1 ;MARK NO TO USE
COMW.F: BLOCK 1 ;TRUE IF WE ARE IN COMMAND-WAIT MODE (SINGLE ESCAPE QUITS)
COMBFR: BLOCK 1         ;IF NON-ZERO THEN WE ARE PROCESSING THE LAST CHARACTER
                        ;OF THE COMMAND FILE
BUFFR:  BLOCK 1         ;IF NON-ZERO THEN WE ARE PROCESSING THE LAST CHARACTER
                        ;OF THE COMMAND BUFFER
ENABLE: BLOCK 1         ;IF NON-ZERO THEN LET A BUFFER THAT WAS CALLED DURING
                        ;THE EXECUTION OF A COMMAND TO REMAIN ENABLED AFTER
                        ;TERMINATION OF THE COMMAND (SET BY COMMAND-
                        ;NOT YET IMPLEMENTED)
CMWBFR: BLOCK 1         ;IF NON-ZERO THEN A BUFFER WAS ENABLED DURING COMMAND
                        ;WAIT MODE
BUFCOM: BLOCK   BUFLEN+1
BUFLIN: BLOCK 1         ;WORD ADDR OF CURRENT BUFFER IN BUF0
BUFPT: BLOCK 1          ;CHARACTER POINTER TO BUFFER IN USE
BUF0:   BLOCK <BUFLNS+1>*<NOBUFS+1>     ;DICTIONARY POINTERS TO BUFFER LINES



; THE CELL 'DICT' MUST BE THE LAST CELL IN THE LO-SEG
; OR THE LAST CELL IN THE PROGRAM (DEPENDING ON PURE).
; THE CELL 'LASTZR' IS THE LAST ADDRESS ZEROED BY BLT ON
; START-UP AND CLEAR COMMANDS.

IFE PURE,<
LASTZR: BLOCK   1       ;LAST PLACE TO ZERO
        LIT             ;LITERALS GO HERE
DICT:   BLOCK   1       ;LAST CELL IN PROGRAM>

IFN PURE,<
LASTZR:DICT: BLOCK 1    ;LAST PLACE TO ZERO, DICT IS HERE
        RELOC           ;GO TO HI-SEG
        LIT             ;DO LITERALS>

IF1,<PRINTX END PASS 1>
IF2,<PRINTX END PASS 2>
        END     START0
 .i