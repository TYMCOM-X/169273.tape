TITLE MICASM MICro ASseMbler
SUBTTL DSB
NOLIT
XALL

F=0
F.NID==200000
A=1	B=2	C=3	D=4
T=5	T1=6
PT=7	PT1=10
R=11	S=12
CH=13
TOK=14
TYP=15
FS=16
P=17
OPDEF CALL [PUSHJ P,]
OPDEF RET [POPJ P,]

EOFF0:	0
EOFF2:	0
IBUF:	BLOCK 3
OBUF:	BLOCK 3
CIBUF:	BLOCK 3
GETCH:	0
LOC:	0
HPOS:	0
WDLEN== =108	;LENGTH OF WORD IN BITS.
ADRPTR:	0
PDL:	-20,,.
	BLOCK 20
ZZ==1
MASK:	0
REPEAT 43,<
ZZ
ZZ==ZZ*2+1
>
	-1
FNHTL== =1001
FNHT:	BLOCK FNHTL
;FIELD NAME DESCRIPTORS.
   FDB==0
   FDR==1
   FDSIZ==2
FVHTL== =23
;FIELD VALUE NAME DESCRIPTORS.
   FVB==0
   FVV==1
   FVSIZ==2
;MICROINSTRUCTION DESCRIPTORS.
  MWA==0
  MWC==1
  MWSIZ==1+<WDLEN/44>+1

;MACROS FOR ERROR REPORTING.
DEFINE PARSE(X) <
	SKIP [ASCIZ\X\]
>
DEFINE ERROR(X,Y,Z) <
	XCT [	JSP T,PARERR
		X,,[ASCIZ\Y\]
		IFIDN <Z><><JRST PRTDFT>
		IFDIF <Z><><Z>
		]
>

REPEAT 0,<

THIS PROGRAM PARSES MICROCODE SYMBOL DEFINITIONS AND
ASSEMBLES SINGLE MICROWORDS DEFINED USING THOSE SYMBOLS.

THE ASSEMBLER OUTPUT IS ASSUMED TO CONSIST
OF TWO SECTIONS, THE FIRST BEING A LIST OF FIELD DEFINIIONS
AND SYMBOLIC NAMES FOR THE VALUES THE FIELD MAY ASSUME, THE SECOND
BEING THE ACTUAL MICROCODE.  THE HACKS IN THE SCANNER AND
PARSER ARE DUE TO THE FACT THAT THE LANGUAGE IS CONTEXT
SENSITIVE.

DATA STRUCTURES:
  FIELD NAME HASH TABLE (FNHT)
        THIS IS A HASH TABLE MAPPING FROM FIELD NAME TO FIELD
        DESCRIPTOR.  IT HAS FNHTL BUCKETS, CHAINED THROUGH THE
        FIRST WORD.
  FIELD DESCRIPTOR (ALLOCATED CONTIGUOUSLY)
        FDB: LH: POINTER TO 7 BIT FIELD NAME.
        FDB: RH: NEXT DESCRIPTOR IN THIS BUCKET.
        FDR: LH: BITS 0:8 LOWER BOUND OF FIELD
        FDR:     BITS 9:18 UPPER BOUND OF FIELD
        FDR: RH: ADDRESS OF HASH TABLE OF FIELD VALUE NAMES.
  FIELD VALUE HASH TABLES
	THIS IS A HASH TABLE OF LENGTH FVHTL MAPPING FROM FIELD VALUE NAMES TO
	NUMERIC VALUES.  ONE EXISTS FOR EACH FIELD DESCRIPTOR.
	FVB: LH: POINTER TO 7 BIT FIELD VALUE NAME.
        FVB: RH: NEXT DESCRIPTOR IN THIS BUCKET.
        FVV: VALUE.
  MICROINSTRUCTION DESCRIPTOR (ONE PER MICROINSTRUCTION PARSED).
	MWX: LH: UNUSED. RH: ADDRESS OF INSTR. IN CRAM.
	MWC: START OF WDLEN/44 WORDS CONTAINING THE DATA TO BE GIVEN TO SMFILE.
>

START:	RESET
	MOVE P,PDL
	OUTSTR	[ASCIZ /
KS-10 Microcode Assembler V1.0
/]
	CALL INI
   ;Process field definitions.
	OUTSTR [ASCIZ/
Loading symbols from /]
	CALL TYSFIL
	CALL INIF0		;PROCESS KS10.ULD FILE.
	CALL PARFLD
	MOVEI PT,[BYTE (7) 15,12]
	CALL EMISTR
    ;Assemble microcode.
	OUTSTR [ASCIZ /

[/]
	CALL TYIFIL
	OUTSTR [ASCIZ/ ==> /]
	CALL TYOFIL
	OUTSTR [ASCIZ /]
/]
	CALL INIF2		;PROCESS CODE FILE.
	CALL PARCOD
	MOVEI PT,[ASCIZ/END
/]
	CALL EMISTR
	OUTSTR [ASCIZ/
[Assembly complete]
/]
	CALL DONE
	EXIT


SYMFIL:	'KS10  '
SYMEXT:	'FLD   '
	OCT 0,0
INPFIL:	'KS10  '
INPEXT:	'MIC   '
	OCT 0,0
OUTFIL:	'KS10  '
OUTEXT:	'ULD   '
	OCT 0,0

O6BIT:	PUSH	P,1		;PRINT SIXBIT CONTENTS OF 1
	PUSH	P,2
	PUSH	P,3
	MOVE	3,[POINT 7,O6TEXT]
O6LOOP:	MOVE	2,1
	LSH	1,6
	LSH	2,0-=30
	ADDI	2," "		;CONVERT TO ASCII
	IDPB	2,3
	SUBI	2," "
	JUMPN	2,O6LOOP	;IF NOT A 0 CONTINUE
	DPB	2,3
	OUTSTR	O6TEXT
	POP	P,3
	POP	P,2
	POP	P,1
	RET
O6TEXT:	ASCIZ /123456 /

G6BIT:	SETZ	1,
	MOVE	2,[POINT 6,1]
	MOVEI	3,6
G6LOOP:	INCHWL	4
	CAIN	4,12		;LINEFEED
	  JRST	CPOPJ1		;SKIP RETURN ON LINE FEED
	CAIGE	4," "
	  JRST	G6LOOP		;IGNORE CONTROL CHARS
	CAIN	4,"."
	  JRST	CPOPJ		;NON-SKIP RETURN ON "."
	CAIL	4,"a"		;CONVERT TO LOWER CASE
	  SUBI	4,<"a"-"A">
	SUBI	4," "		;CONVERT TO SIXBIT
	IDPB	4,2		;DEPOSIT IN T2
	SOJG	3,G6LOOP	;CONTINUE FOR 6 CHARS
	JRST	CPOPJ		;THEN NON-SKIP RETURN

TYSFIL:	PUSH	P,1
	MOVE	1,SYMFIL
	CALL O6BIT
	OUTSTR	[ASCIZ /./]
	MOVE	1,SYMEXT
	HLLZ	1,1
	CALL O6BIT
	POP	P,1
	RET

TYIFIL:	PUSH	P,1
	MOVE	1,INPFIL
	CALL O6BIT
	OUTSTR	[ASCIZ /./]
	MOVE	1,INPEXT
	HLLZ	1,1
	CALL O6BIT
	POP	P,1
	RET

TYOFIL:	PUSH	P,1
	MOVE	1,OUTFIL
	CALL O6BIT
	OUTSTR	[ASCIZ /./]
	MOVE	1,OUTEXT
	HLLZ	1,1
	CALL O6BIT
	POP	P,1
	RET

EAT2LF:	PUSH	P,1
EAT1LF:	INCHWL	1
	CAIE	1,12
	  JRST	EAT1LF
	POP P,1
	RET

INI:
	OUTSTR	[ASCIZ /
Field definition file [/]
	CALL	TYSFIL
	OUTSTR	[ASCIZ /]: /]
	CALL G6BIT
	  CALL EAT2LF
	JUMPE	1,GINPFN	;default
	MOVEM	1,SYMFIL
 	OUTSTR	[ASCIZ /Now  enter  the  extention:   /]
	SETZM	SYMEXT
	CALL	TYSFIL
	CALL G6BIT
	  CALL EAT2LF
	MOVEM	1,SYMEXT
GINPFN:
	OUTSTR	[ASCIZ /Source file [/]
	CALL	TYIFIL
	OUTSTR	[ASCIZ /]: /]
	CALL G6BIT
	  CALL EAT2LF
	JUMPE	1,GOUTFN	;USE DEFAULT
	MOVEM	1,INPFIL
 	OUTSTR	[ASCIZ /Now enter the extention: /]
	SETZM	INPEXT
	CALL	TYIFIL
	CALL G6BIT
	  CALL EAT2LF
	MOVEM	1,INPEXT
GOUTFN:
	OUTSTR	[ASCIZ /Output file [/]
	CALL	TYOFIL
	OUTSTR	[ASCIZ /]: /]
	CALL G6BIT
	  CALL EAT2LF
	JUMPE	1,GOTFNS	;USE DEFAULT
	MOVEM	1,OUTFIL
	OUTSTR	[ASCIZ /Now enter the extention: /]
	SETZM	OUTEXT
	CALL	TYOFIL
	CALL G6BIT
	  CALL EAT2LF
	MOVEM	1,OUTEXT
GOTFNS:			;GOT ALL FILE NAMES NOW PRINT THEM
	OUTSTR	[ASCIZ /
[/]
	CALL TYSFIL
	OUTSTR	[ASCIZ /+/]
	CALL TYIFIL		;TYPE INPUT FILE
	OUTSTR	[ASCIZ / ==> /]
	CALL TYOFIL
	OUTSTR	[ASCIZ /]  Okay? /]
	INCHWL 1
	CALL EAT2LF
	CAIN	1,"Y"
	  JRST GO
	CAIN	1,"y"
	  JRST GO
	  JRST INI
;---------------------------------------------------
GO:	OPEN [0'DSK   'IBUF]
	  JRST 4,.
	LOOKUP 	SYMFIL		;['KS10  ''FLD   '00]
	 JRST [OUTSTR [ASCIZ /
Can't find /]
		CALL TYSFIL
		OUTSTR [ASCIZ /.  Bye.../]
		EXIT]
	INBUF 2
	OPEN 1,[0'DSK   'OBUF,,]
	 JRST 4,.
	ENTER 1,OUTFIL		;['KS10  ''ULD   '00]
	 JRST [OUTSTR [ASCIZ /
Can't find /]
		CALL TYIFIL
		OUTSTR [ASCIZ /.  Bye.../]
		EXIT]
	OUTBUF 1,2
	OPEN 2,[0'DSK   'CIBUF]
	 JRST 4,.
	LOOKUP 2,INPFIL		;['KS10  ''MIC   '00]
	 JRST [OUTSTR [ASCIZ /
Can't find /]
		CALL TYOFIL
		OUTSTR [ASCIZ /.  Bye.../]
		EXIT]
	INBUF 2,2
	MOVEI T,377777
	CORE T,
	 JRST 4,.
	MOVEI FS,20000
	SETZM ADRPTR
	SETZM EOFF0
	SETZM EOFF2
	MOVE T,[FNHT,,FNHT+1]
	SETZM -1(T)
	BLT T,FNHT+FNHTL-1
	RET

INIF2:	SKIPA T,[FI2INP]
INIF0:	 MOVEI T,FI0INP
	HRRZM T,GETCH
	CALL @GETCH
	SETZ F,
	CALL SCAN
	RET

DONE:	OUT 1,
	CLOSE 1,
	RELEAS
	RELEAS 1,
	RELEAS 2,
	RET

;SCANNER, CHARACTER INPUT. LOWEST LEVEL IS EITHER FI2INP OR FI0INP,
; FOR READING THE FIELD DEFINITION FILE OR THE MCODE FILE.
FI2INP:	SKIPE EOFF2
	 JRST FI2EOF
	SOSG CIBUF+2
	 IN 2,
	JRST FI2IN1
FI2EOF:	SETOM EOFF2
	JRST FI0IN2
FI2IN1:	ILDB CH,CIBUF+1
	MOVE A,@CIBUF+1
	TRNE A,1		;line number?
	 JRST [	AOS CIBUF+1
		MOVNI A,6
		ADDM A,CIBUF+2
		JRST FI2IN1]
	JUMPE CH,FI2INP
	RET
FI0INP:	SKIPE EOFF0
	 JRST FI0IN0
	SOSG IBUF+2
	 IN
	JRST FI0IN1
FI0IN0:	SETOM EOFF0
FI0IN2:	MOVEI CH,200
	RET
FI0IN1:	ILDB CH,IBUF+1
	MOVE A,@IBUF+1
	TRNE A,1
	 JRST [	AOS IBUF+1
		MOVNI A,6
		ADDM A,IBUF+2
		JRST FI0IN1]
	JUMPE CH,FI0INP
	CALL EMICHR		;COPY FIELD FILE TO .ULD FILE.
	RET

TOKTBL:
TOKNUM==0
DEFINE TOKEN(TOKNAM,TOKDES) <
TOKNAM==TOKNUM
TOKNUM==TOKNUM+1
[ASCIZ\TOKDES\],,
>
TOKEN(T.ID,Identifier)
TOKEN(T.NUM,<Octal or decimal number>)
TOKEN(T.LT,<Less than sign>)
TOKEN(T.GT,<Greater than sign>)
TOKEN(T.EQL,<Equals sign>)
TOKEN(T.OBR,<Open square bracket>)
TOKEN(T.CBR,<Close square bracket>)
TOKEN(T.COL,<Colon>)
TOKEN(T.EOF,<End of file>)
TOKEN(T.SC,<Semicolon>)
TOKEN(T.COM,<Comma>)
TOKEN(T.EOL,<End of line>)
TOKEN(T.SLA,<Slash>)

SCNIGN:	CALL @GETCH
SCAN:	JRST @SCNTBL(CH)

C.LET==400000	C.DIG==200000	C.BRK==100000
C.IGN==40000	C.EOL==20000
SCNTBL:	REPEAT 14-0+1,<C.IGN,,SCNIGN>
	C.EOL,,SCNEOL
	REPEAT 40-16+1,<C.IGN,,SCNIGN>
	REPEAT "+"-41+1,<C.LET,,SCNID>
	C.BRK,,SCNCOM
	REPEAT "."-"-"+1,<C.LET,,SCNID>
	C.BRK,,SCNSLA
	REPEAT "9"-"0"+1,<C.DIG+C.LET,,SCNNUM>
	C.BRK,,SCNCOL
	C.BRK,,SCNSC
	C.BRK,,SCNLT
	C.BRK,,SCNEQL
	C.BRK,,SCNGT
	REPEAT "Z"-"?"+1,<C.LET,,SCNID>
	C.BRK,,SCNOBR
	C.LET,,SCNID
	C.BRK,,SCNCBR
	REPEAT 177-"^"+1,<C.LET,,SCNID>
	C.BRK,,SCNEOF

SCNID:	HRRZI TOK,(FS)
	TLO TOK,440700
SCNID1:	IDPB CH,TOK
	CALL @GETCH
	HLL CH,SCNTBL(CH)
	JUMPL CH,SCNID1
	MOVEI TYP,T.ID
	SETZ T,
	IDPB T,TOK
	EXCH FS,TOK
	AOJ FS,
	RET

SCNEOL:	MOVEI TYP,T.EOL		;CR.
	CALL @GETCH		;SKIP LF.
	JRST @GETCH

SCNSC:	CALL @GETCH		;SEMICOLON, IGNORE TO EOL.
	CAIE CH,12
	 JRST SCNSC
	MOVEI TYP,T.EOL		;AND CALL IT EOL.
	JRST @GETCH

SCNGT:	SKIPA TYP,[T.GT]
SCNLT:	MOVEI TYP,T.LT
	JRST @GETCH
SCNOBR:	SKIPA TYP,[T.OBR]
SCNCBR:	MOVEI TYP,T.CBR
	JRST @GETCH
SCNEOF:	MOVEI TYP,T.EOF
	JRST @GETCH
SCNCOL:	SKIPA TYP,[T.COL]
SCNEQL:	MOVEI TYP,T.EQL
	JRST @GETCH
SCNSLA:	SKIPA TYP,[T.SLA]
SCNCOM:	MOVEI TYP,T.COM
	JRST @GETCH
;NUMBERS ARE RETURNED AS STRINGS OF 4 BIT DIGITS FORMED FROM EACH
; CHARACTER BY D:= (CH+1) AND 17.  THE STRING IS TERMINATED BY
; A 0 BYTE.  THE NUMBER PARSING ROUTINES CONVERT THIS STRING INTO
; AN OCTAL OR DECIMAL NUMBER AS APPROPRIATE, CHECKING THE RANGE OF
; THE DIGITS IN THE CASE OF AN OCTAL NUMBER.
SCNNUM:	TLNE F,F.NID
	 JRST SCNID
	HRRZI TOK,(FS)
	HRLI TOK,440400
SCNNU1:	AOJ CH,
	IDPB CH,TOK
	CALL @GETCH
	MOVSI T,C.DIG
	TDNE T,SCNTBL(CH)
	 JRST SCNNU1
	SETZ T,
	IDPB T,TOK
	EXCH FS,TOK
	AOJ FS,
	MOVEI TYP,T.NUM
	RET

;JSP T, HERE WHEN CAN'T PARSE A FIELD.
PARERR:	OUTSTR [ASCIZ/
Error parsing /]
	HRRZ A,-1(T)
	HLRZ B,1(A)
	OUTSTR @(B)			;Announce current production.
	OUTSTR [ASCIZ/ - /]
	HRRZ B,1(A)
	OUTSTR (B)			;Announce error.
	OUTSTR [BYTE (7) ".",15,12]
	XCT 2(A)			;Type offending token.
	JRST ERR
PRTID:	OUTSTR [ASCIZ/Offending token: /]
	OUTSTR (R)
	JRST ERR
PRTDFT:	OUTSTR [ASCIZ/Last token scanned: /]
	HLRZ B,TOKTBL(TYP)
	OUTSTR (B)
	JRST ERR

;SET PT1 TO CONCATINATION OF PT1 AND R.
APPSTR:	JUMPN PT1,APPST1
	MOVEI PT1,(R)
	RET
APPST1:	MOVE T,[440700+FS,,]
	MOVE T1,[440700+PT1,,]
	CALL COPSTR
	MOVEI PT1,40
	IDPB PT1,T
	MOVE T1,[440700+R,,]
	CALL COPSTR
	MOVEI PT1,
	IDPB PT1,T
	MOVEI PT1,(FS)
	ADDI FS,1(T)
	RET
;COPY STRING POINTED AT BY T1 TO STRING POINTED AT BY T.
	IDPB A,T
COPSTR:	ILDB A,T1
	JUMPN A,.-2
	RET
;COMPARE STRINGS IN R AND PT, SKIP IF EQUAL.
STRCMP:	MOVEI T,(PT)
	HRLI T,440700
	MOVEI T1,(R)
	HRLI T1,440700
STRCM1:	ILDB A,T
	ILDB B,T1
	CAIE A,(B)
	 RET
	JUMPN A,STRCM1
CPOPJ1:	AOS (P)
CPOPJ:	RET

;HASH FIELD NAME OR VALUE IN R, RETURN HASH IN B.
HASHFV:	SKIPA D,[FVHTL]
HASHFN:	MOVEI D,FNHTL
	MOVE T,[440700+R,,]
	SETZ A,
HID1:	ILDB B,T
	ROT A,1
	ADDI A,(B)
	JUMPN B,HID1
	MOVMS A
	IDIVI A,(D)
	RET

;PARSER
;PARSE IDENTIFIER, EMBEDDED SPACES ALLOWED
PARID1:	SETZ PT1,
PARI10:	CALL PARID
	CALL APPSTR
PARI11:	CAIN TYP,T.ID
	 JRST PARI10
	SKIPE PT1
	 MOVEI R,(PT1)
	RET
;PARSE EOL.
PAREOL:	PARSE(<End of line>)
	CAIE TYP,T.EOL
	 ERROR(PAREOL,<Token not end of line>)
	JRST SCAN
;PARSE IDENTIFIER
PARID:	PARSE(<Single word indentifier>)
	CAIE TYP,T.ID
	 ERROR(PARID,<Token not identifier>)
	MOVEI R,(TOK)
	JRST SCAN
;PARSE NUMBER.  THIS INVOLVES CONVERTING THE 4 BIT STRING SCANNED
; TO AN OCTAL OR DECIMAL NUMBER, CHECKING THE DIGITS ARE IN RANGE
; FOR OCTAL NUMBERS.
PARDEC:	PARSE(<Decimal number>)
	CAIE TYP,T.NUM
	 ERROR(PARDEC,<Token not a number>)
	HRRZ T,TOK
	HRLI T,440400		;CONVERT 4 BIT STRING TO DECIMAL NUMBER.
	SETZ R,
PD1:	ILDB A,T		;MUST BE IN RANGE.
	JUMPE A,SCAN
	IMULI R,12
	ADDI R,-1(A)
	JRST PD1
PAROCT:	PARSE(<Octal number>)
	CAIE TYP,T.NUM
	 ERROR(PAROCT,<Token not a number>)
	HRRZ T,TOK
	HRLI T,440400
	SETZ R,
PO1:	ILDB A,T
	JUMPE A,SCAN
	CAILE A,10		;BETTER BE DIGIT FROM 0 TO 7.
	 ERROR(PAROCT,<Digits not in range 0 to 7>)
	LSH R,3
	IORI R,-1(A)
	JRST PO1
;PARSE FIELD DESCRIPTIONS
;BUILDS FIELD NAME HASH TABLES, FIELD VALUE HASH TABLES.
PARFLD:	PARSE(<Field descriptions>)
	CALL PARID		;"RADIX"
	CALL PARDEC		;<NUM>
	CALL PAREOL		;EOL
	CALL PARID		;"FIELD"
PARFD1:	CALL PARFL		;PARSE FIELD DESCRIPTION.
	PUSH P,R
	SKIPGE ADRPTR
	 HRRZM S,ADRPTR
	HLRZ R,FDB(S)
	CALL HASHFN		;HASH FIELD NAME.
	HRRZ T,FNHT(B)		;CONS ONTO FRONT OF BUCKET.
	HRRM T,FDB(S)
	HRRZM S,FNHT(B)
	POP P,R
	CAIN TYP,T.ID
	 JRST PARFD1
	RET
;PARSE SINGLE FIELD DESCRIPTION.
PARFL:	MOVEI PT,[ASCIZ/FIELD/]
	CALL STRCMP
	 JRST [	MOVEI PT,[ASCIZ/ADDRESS/]
		CALL STRCMP
		 JSP T,ERR
		SETOM ADRPTR
		JRST .+1]
	CALL PARID1
	MOVEI S,(FS)
	ADDI FS,FDSIZ
	HRLZM R,FDB(S)		;FDB.LH:=FIELD NAME.
	SETZM FDR(S)
	CAIE TYP,T.EQL
	 JSP T,ERR
	CALL SCAN
	CAIE TYP,T.LT
	 JSP T,ERR
	CALL SCAN
	CALL PARDEC
	DPB R,[331100+S,,FDR]
	CAIE TYP,T.COL
	 JSP T,ERR
	CALL SCAN
	CALL PARDEC
	DPB R,[221100+S,,FDR]
	CAIE TYP,T.GT
	 JSP T,ERR
	CALL SCAN
	TLO F,F.NID
	CALL PAREOL
	TLZ F,F.NID
	MOVSI T,(FS)
	HLRM T,FDR(S)		;FDR.RH:=ADDRESS OF HASH TABLE OF FIELD VALUE
	HRRI T,1(FS)		;	NAMES.
	SETZM -1(T)		;CLEAR HASH TABLE.
	MOVEI A,(T)
	BLT T,FVHTL-1(A)
	ADDI FS,FVHTL
PARFL2:	CALL PARFV		;R:=FIELD VALUE NAME DESCRIPTOR.
	 RET
	PUSH P,R
	HLRZ R,FVB(R)
	CALL HASHFV		;B:=HASH OF FIELD VALUE NAME.
	HRRZ T,FDR(S)
	ADDI T,(B)		;BUCKET HEADER.
	HRRZ A,(T)		;CONS ONTO FRONT OF LIST.
	POP P,R
	HRRM A,FVB(R)
	HRRZM R,(T)
	JRST PARFL2
;PARSE SINGLE FIELD VALUE, RETURN R=FIELD VALUE NAME DESCRIPTOR.
PARFV:	CAIE TYP,T.ID
	 RET
	TLO F,F.NID
	CALL PARID
	TLZ F,F.NID
	MOVEI PT,[ASCIZ/FIELD/]
	CALL STRCMP
	 JRST [	MOVEI PT,[ASCIZ/ADDRESS/]
		CALL STRCMP
		 JRST .+2
		RET]
	 RET
	MOVEI PT1,(R)
	TLO F,F.NID
	CALL PARI11
	TLZ F,F.NID
	MOVEI C,(FS)
	ADDI FS,FVSIZ
	HRLZM R,FVB(C)		;FCVB.LH:=FIELD VALUE NAME.
	CAIE TYP,T.EQL
	 JSP T,ERR
	TLZ F,F.NID
	CALL SCAN
	TLO F,F.NID
	CALL PAROCT
	MOVEM R,FVV(C)
	CALL PAREOL
	TLZ F,F.NID
	HRRZI R,(C)
	JRST CPOPJ1

;PARSE AND ASSEMBLE THE CODE, EMITTING SINGLE WORDS OF CODE WHICH
; ARE TO BE APPENDED TO THE KS10.ULD FILE BEFORE RUNNING SMFILE
; TO GENERATE THE MICROCODE FILE.
;SYNTAX: 
; ADR: FIELD/VALUE{,FIELD/VALUE}
; COMMA JUST BEFORE EOL CAUSES EOL TO BE IGNORED; OTHERWISE, EOL
; TERMINATES THE MICRO WORD.
PARCOD:;;CALL EMISYM		;EMIT SYMBOLS (NYI).
PARCD1:	CALL PARMI		;PARSE A MICRO INSTRUCTION.
	 JRST PAREOF
	PUSH P,CH
	CALL EMIMI		;EMIT A MICRO INSTRUCTION.
	POP P,CH
	JRST PARCD1

PARMI0:	CALL SCAN
PARMI:	CAIN TYP,T.EOL		;SKIP BLANK LINES, COMMENT LINES.
	 JRST PARMI0
	MOVEI S,(FS)		;CREATE MICROINSTRUCTION DESCRIPTOR.
	MOVSI T,(FS)		;ZERO IT.
	HRRI T,1(FS)
	SETZM -1(T)
	BLT T,MWSIZ-1(S)
	ADDI FS,MWSIZ
	CALL PARMA		;PARSE ADDRESS.
	 RET
	CALL PARMW
	JRST CPOPJ1

PARMA:	PARSE(<microinstruction address field>)
	CAIE TYP,T.NUM
	 RET
	CALL PAROCT
	MOVEM R,MWA(S)
	CAIE TYP,T.COL
	 ERROR(PARMA,<Expecting a colon after location>)
	AOS (P)
	JRST SCAN

PARMW:	PARSE(<microinstruction fields and values>)
	CALL PARID1		;FIELD NAME.
	CALL FNDFN
	 ERROR(PARMW,<Unrecognizable field name>,<CALL PRTID>)
	PUSH P,C		;FIELD NAME DESCRIPTOR.
	CAIE TYP,T.SLA		;/
	 JRST PAR1B		;NONE, BETTER BE 1 BIT FIELD.
	TLO F,F.NID
	CALL SCAN
	CALL PARID1		;FIELD VALUE NAME.
	TLZ F,F.NID
	EXCH S,(P)
	CALL FNDFVN		;C:=FIELD VALUE DESCRIPTOR.
	 CALL PARNV		;SHOULD BE NUMBER THEN.
	EXCH S,(P)
	POP P,A			;FIELD NAME DESCRIPTOR.
	LDB B,[331100+A,,FDR]	;LEFTMOST BIT OF FIELD.
	LDB T,[221100+A,,FDR]	;RIGHTMOST BIT OF FIELD.
	MOVE A,FVV(C)		;VALUE TO INSERT.
PARMW1:	SUBI T,-1(B)		;WIDTH OF FIELD.
	MOVEI D,MWC(S)		;MICROWORD STARTS HERE.
	CALL PUTBYT		;DEPOSIT BYTE IN MICROWORD.
	CAIE TYP,T.COM
	 JRST PAREOL
	CALL SCAN
	CAIN TYP,T.EOL		;ALLOW ",<CRLF>" TO CONTINUE LINES.
	 CALL SCAN
	JRST PARMW
;HERE WHEN A FIELD VALUE WAS NOT IN THE FIELD VALUE NAME HASH TABLE.
; THIS IS AN ERROR UNLESS THE NAME CAN BE INTERPRETED AS A NUMBER ALSO.
PARNV:	PARSE(<Numeric field value>)
	SETZ A,
	MOVE T,[440700+R,,]
PARNV2:	ILDB B,T
	JUMPE B,PARNV1
	CAIL B,"0"
	 CAILE B,"7"
	  ERROR(PARNV,<Field value not defined symbol or octal number>,<CALL PRTID>)
	LSH A,3
	IORI A,-"0"(B)
	JRST PARNV2
PARNV1:	MOVEM A,(FS)
	MOVEI C,-FVV(FS)	;MAKE LIKE A VALUE DESCRIPTOR
	AOJA FS,CPOPJ

;HERE WHEN A FIELD NAME WAS SPECIFIED WITHOUT A FIELD VALUE NAME
; FOLLOWING IT.  THIS IS ALLOWED ONLY FOR ONE BIT FIELDS, AND
; CAUSES THE BIT TO BE SET.
PAR1B:	PARSE(<One bit field>)
	LDB B,[331100+C,,FDR]	;ONE BIT FIELD?
	LDB T,[221100+C,,FDR]
	CAIE B,(T)
	 ERROR(PAR1B,<No slash after field name and field not one bit>)
	MOVEI A,1
	ADJSP P,-1		;THROW OUT FIELD NAME DESCRIPTOR POINTER.
	JRST PARMW1

PAREOF:	PARSE(<End statement>)
	CALL PARID
	MOVEI PT,[ASCIZ/END/]
	CALL STRCMP
	 ERROR(PAREOF,<END not last token in file>,<CALL PRTID>)
	RET

;PUT BYTE IN A WHOSE LEFTMOST BIT IS IN B AND WHOSE
; WIDTH IS IN T INTO MICROWORD POINTED AT BY D.
;CANNOT INSERT MORE THAN 36. BITS.
PUTBYT:	CAILE T,44
	 JRST 4,.
	IDIVI B,44		;LOWEST WORD NUMBER.
	MOVE T1,C		;WITHIN LOWEST WORD, # BITS TO LEFT OF FIELD.
	ADDI B,(D)
	DMOVE C,(B)
	ADDI T1,-44(T)
	ROTC C,(T1)		;ALIGN BYTE TO BE REPLACED.
	ANDCM C,MASK(T)
	TDO C,A
	MOVNS T1
	ROTC C,(T1)
	DMOVEM C,(B)
	RET

;FIND FIELD VALUE NAME IN R IN FIELD VALUE NAME HASH TABLE OF FIELD NAME
;DESCRIPTOR IN S.  SKIP IF FOUND, LEAVING C POINTING TO THE FIELD
; VALUE NAME DESCRIPTOR; SINGLE RETURN OTHERWISE.
FNDFVN:	CALL HASHFV
	HRRZ C,FDR(S)
	ADDI C,(B)
	HRRZ C,(C)
	JUMPE C,CPOPJ
FNDFV1:	HLRZ PT,FVB(C)
	CALL STRCMP
	 SKIPA
	  JRST CPOPJ1
	HRRZ C,FVB(C)
	JUMPN C,FNDFV1
	RET

;FIND FIELD NAME IN R IN FIELD NAME HASH TABLE.
;SKIP IF FOUND, LEAVING C POINTING TO THE FIELD NAME DESCRIPTOR,
;SINGLE RETURN OTHERWISE.
FNDFN:	CALL HASHFN
	HRRZ C,FNHT(B)
	JUMPE C,CPOPJ
FNDFN1:	HLRZ PT,FDB(C)
	CALL STRCMP
	 SKIPA
	  JRST CPOPJ1
	HRRZ C,FDB(C)
	JUMPN C,FNDFN1
	RET

;EMIT SMFILE INPUT FOR MICROWORD DESCRIPTOR POINTED AT BY S.
EMIMI:	CALL EMILOC
	CALL EMICOD
	RET

EMILOC:	MOVEI CH,"["
	CALL EMICHR
	MOVE T,[140300+S,,MWA]	;ALL 4 DIGITS PRINT.
EMILO1:	ILDB CH,T
	IORI CH,"0"
	CALL EMICHR
	TLNE T,770000
	 JRST EMILO1
	MOVEI PT,[ASCIZ/]=/]
	JRST EMISTR

EMICOD:	MOVE T,[000300+S,,MWC-1]
	MOVEI T1,WDLEN/3
EMICD1:	ILDB CH,T
	IORI CH,"0"
	CALL EMICHR
	SOJG T1,EMICD1
	MOVEI CH,15
	CALL EMICHR
	MOVEI CH,12
	JRST EMICHR

ERR:	OUTSTR [ASCIZ/
Can't parse input file; quitting.
/]
	EXIT

;OUTPUT ROUTINES
EMIZER:	MOVEI CH,"0"
EMICHR:	SOSG OBUF+2
	 OUT 1,
	IDPB CH,OBUF+1
	RET

EMISTR:	HRLI PT,4407SKIPA
	 CALL EMICHR
	ILDB CH,PT
	JUMPN CH,.-2
	RET

EMIOCT:	LDB CH,[410300,,T]
	TLZ T,700000
	JUMPE CH,EMIR8
	IORI CH,"0"
	CALL EMICHR
EMIR8:	SKIPA C,[8]
EMIR10:	 MOVEI C,12
EMIRX:	IDIVI T,(C)
	HRLM T1,(P)
	SKIPE T
	 CALL EMIRX
	HLRZ CH,(P)
	ADDI CH,"0"
	JRST EMICHR
END START
ING IT.  THIS IS ALLOWED ONLY FOR ONE BIT FIELDS, AND
; CAUSES THE BIT TO BE SET.
PAR1B:	PARSE(<One bit field>)
	LDB B,[331100+C,,FDR]	;ONE BIT FIELD?
	LDB T,[221100+C,,FDR]
	CAIE B,(T)
	 ERROR(PAR1B,<No slash after field name and field not one bit>)
	MOVEI A,1
	ADJSP P,-1		;THROW OUT FIELD NAME DESCRIPTOR POINTER.
	JRST PARMW1

PAREOF:	PARSE(<End statement>)
	CALL PARID
	MOVEI PT,[ASCIZ/END/]
	CALL STRCMP
	 ERROR(PAREOF,<END not last token in file>,<CALL PRTID>)
	RET

;PUT BYTE IN A WHOSE LEFTMOST BIT IS IN B AND WHOSE
; WIDTH IS IN T INTO MICROWORD POINTED AT BY D.
;CANNOT INSERT MORE THAN 36. BITS.
PUTBYT:	CAILE T,44
	 JRST 4,.
	IDIVI B,44		;LOWEST WORD NUMBER.
	MOVE T1,C		;WITHIN LOWEST WORD, # BITS TO LEFT OF FIELD.
	ADDI B,(D)
	DMOVE C,(B)
	ADDI T1,-44(T)
	ROTC C,(T1)		;ALIGN BYTE TO BE REPLACED.
	ANDCM C,MASK(T)
	TDO C,A
	MOVNS T1
	ROTC C,(T1)
	DMOVEM C,(B)
	RET

;FIND FIELD VALUE NAME IN R IN FIELD VALUE NAME HASH TABLE OF FIELD NAME
;DESCRIPTOR IN S.  SKIP IF FOUND, LEAVING C POINTING TO THE FIELD
; VALUE NAME DESCRIPTOR; SINGLE RETURN OTHERWISE.
FNDFVN:	CALL HASHFV
	HRRZ C,FDR(S)
	ADDI C,(B)
	HRRZ C,(C)
	JUMPE C,CPOPJ
FNDFV1:	HLRZ PT,FVB(C)
	CALL STRCMP
	 SKIPA
	  JRST CPOPJ1
	HRRZ C,FVB(C)
	JUMPN C,FNDFV1
	RET

;FIND FIELD NAME IN R IN FIELD NAME HASH TABLE.
;SKIP IF FOUND, LEAVING C POINTING TO THE FIELD NAME DESCRIPTOR,
;SINGLE RETURN OTHERWISE.
FNDFN:	CALL HASHFN
	HRRZ C,FNHT(B)
	JUMPE C,CPOPJ
FNDFN1:	HLRZ PT,FDB(C)
	CALL STRCMP
	 SKIPA
	  JRST CPOPJ1
	HRRZ C,FDB(C)
	JUMPN C,FNDFN1
	RET

;EMIT SMFILE INPUT FOR MICROWORD DESCRIPTOR POINTED AT BY S.
EMIMI:	CALL EMILOC
	CALL EMICOD
	RET

EMILOC:	MOVEI CH,"["
	CALL EMICHR
	MOVE T,[140300+S,,MWA]	;ALL 4 DIGITS PRINT.
EMILO1:	ILDB CH,T
	IORI CH,"0"
	CALL EMICHR
	TLNE T,770000
	 JRST EMILO1
	MOVEI PT,[ASCIZ/]=/]
	JRST EMISTR

EMICOD:	MOVE T,[000300+S,,MWC-1]
	MOVEI T1,WDLEN/3
EMICD1:	ILDB CH,T
	IORI CH,"0"
	CALL EMICHR
	SOJG T1,EMICD1
	MOVEI CH,15
	CALL EMICHR
	MOVEI CH,12
	JRST EMICHR

ERR:	OUTSTR [ASCIZ/
Can't parse input file; quitting.
/]
	EXIT

;OUTPUT ROUTINES
EMIZER:	MOVEI CH,"0"
EMICHR:	SOSG OBUF+2
	 OUT 1,
	IDPB CH,OBUF+1
	RET

EMISTR:	HRLI PT,440700
	SKIPA
	 CALL EMICHR
	ILDB CH,PT
	JUMPN CH,.-2
	RET

EMIOCT:	LDB CH,[410300,,T]
	TLZ T,700000
	JUMPE CH,EMIR8
	IORI CH,"0
|V-­