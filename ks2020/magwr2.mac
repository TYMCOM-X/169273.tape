	TITLE MAGWRT
	ENTRY MAGWRT

TAC1=3
TAC2=4
TAC3=5
TAC4=6
TAC5=7
TAC6=10

P=17

;IO CHANNELS.
CHNTTY==0
CHNTAP==1
CHNMIC==2
CHNLOD==3
CHNMON==4


OPDEF PJRST [JRST]

MAGWRT: RESET
	MOVE	P,PDL		;SET UP PUSHDOWN LIST.

	OPEN	CHNTTY,OPNTTY	;OPEN THE TTY.
	HALT

	MOVEI	TAC1,[ASCIZ/
DO YOU WANT INSTRUCTIONS/]
	MOVE	TAC2,YES
	MOVE	TAC3,NO
	PUSHJ	P,ANSTWO
	PUSHJ	P,TYPINS	;HERE ON Y.
				;HERE ON N.

    ;GET THE TAPE DEVICE.
GETDEV:	MOVEI	TAC1,[ASCIZ/TAPE UNIT:/]
	PUSHJ	P,ANSDEV
	MOVEM	TAC4,OPNTAP+1
	OPEN	CHNTAP,OPNTAP
	JRST	[MOVEI TAC1,[ASCIZ/CANNOT OPEN UNIT.
/]
		PUSHJ P,OUTMSG
		JRST GETDEV]
	PUSHJ	P,ANSDEN
	MOVE	TAC1,OPNTAP	;SET THE DENSITY.
	IORI	TAC1,(TAC4)	;
	HRRM	TAC1,.+1	;
	SETSTS	CHNTAP,		;


    ;OPEN THE DISK DEVICES.
	OPEN	CHNMIC,OPNMIC
	JRST	DSKFAL	;
	OPEN	CHNLOD,OPNLOD
	JRST	DSKFAL	;
	OPEN	CHNMON,OPNMON
DSKFAL:	JRST	[MOVEI TAC1,[ASCIZ/
CANNOT OPEN DSK.
/]
		PJRST DIE]


    ;GET THE MICROCODE FILENAME.
GETMIC:	MOVEI	TAC1,[ASCIZ/WRITE MICROCODE OR FAKE IT/]
	MOVE	TAC2,WRITEE
	MOVE	TAC3,FAKE
	PUSHJ	P,ANSTWO
	JRST	.+2		;WRITE.
	JRST	[SETZM LOKMIC+LKBNAM ;FAKE.
		JRST GETLOD]
	MOVEI	TAC1,[ASCIZ/MICRO FILENAME:/]
	MOVEI	TAC2,LOKMIC
	PUSHJ	P,ANSFIL	;GET THE FILENAME FROM TTY.
	MOVEI	TAC2,CHNMIC	;LOOKUP THE
	PUSHJ	P,FNDFIL	;FILE.
	JRST	GETMIC		;NOT THERE.  ALREADY COMPLAINED.
	MOVE	TAC1,LOKMIC+LKBSIZ ;CALC TAC1/
	ADDI	TAC1,777	;THE NO. OF PAGES
	LSH	TAC1,-9		;IN THE UCODE FILE.
	MOVEM	TAC1,MICLEN	;SAVE FOR LATER.
	JUMPE	TAC1,.+3	;THE BOOT COMMANDS
	CAIG	TAC1,^D12	;EXPECT TWELVE PAGES
	JRST	GETLOD		;OF MICROCODE.
	MOVEI	TAC1,[ASCIZ/
MICROCODE FILE IS NULL OR GREATER THAN 12 PAGES.
/]
	PJRST	DIE

    ;GET THE LOADER FILENAME.
GETLOD:	MOVEI	TAC1,[ASCIZ/LOADER FILENAME:/]
	MOVEI	TAC2,LOKLOD
	PUSHJ	P,ANSFIL	;GET THE FILENAME FROM TTY.
	MOVEI	TAC2,CHNLOD	;LOOKUP THE
	PUSHJ	P,FNDFIL	;FILE.
	JRST	GETLOD		;NOT THERE.  ALREADY COMPLAINED.
	MOVE	TAC1,LOKLOD+LKBSIZ ;CHECK SIZE.
	ADDI	TAC1,777	;THE BOOT COMMANDS
	LSH	TAC1,-9		;EXPECT A
	CAIN	TAC1,1		;ONE PAGE
	JRST	GETMON		;LOADER.
	MOVEI	TAC1,[ASCIZ/
LOADER IS NOT 1 PAGE LONG.
/]
;*;	PJRST	DIE

    ;GET THE MONITOR(OR OTHER FILE) FILENAME.
GETMON:	MOVEI	TAC1,[ASCIZ/MONITOR FILENAME:/]
	MOVEI	TAC2,LOKMON	;
	PUSHJ	P,ANSFIL	;GET THE FILENAME FROM TTY.
	MOVEI	TAC2,CHNMON	;
	PUSHJ	P,FNDFIL	;LOOKUP THE FILE.
	JRST	GETMON		;NOT FOUND.
	SKIPE	LOKMON+LKBSIZ	;
	JRST	WRTTAP		;
	MOVEI	TAC1,[ASCIZ/
MONITOR FILE IS EMPTY.
/]
	PJRST	DIE


    ;NOW WRITE THE TAPE.
WRTTAP:	MTAPE	CHNTAP,1	;REWIND THE
	MTAPE	CHNTAP,0	;TAPE.

	SKIPN	TAC1,LOKMIC+LKBNAM ;REALLY WRITE THE MICROCODE?
	JRST	[MOVNI TAC4,^D12 ;NO, FAKE IT.
		JRST FAKMIC]	;
	MOVEI	TAC2,CHNMIC	;WRT UCODE FROM CHNL CHNMIC.
	PUSHJ	P,COPY		;
	MOVE	TAC4,MICLEN	;
	CAIL	TAC4,^D12	;NEED TO PAD?
	JRST	WRTTP2		;NO.
	SUBI	TAC4,^D12	;YES, PAD.
FAKMIC:	PUSHJ	P,ZERBUF	;
	OUT	CHNTAP,COM	;
	AOJL	TAC4,.-1	;
	JUMPN	TAC4,TAPERR	;

WRTTP2:	MTAPE	CHNTAP,3	;WRITE EOF AFTER MICROCODE
	MOVEI	TAC2,CHNLOD	;WRT LOADER FROM CHANNEL CHNLOD.
	PUSHJ	P,COPY
	MTAPE	CHNTAP,3	;WRT EOF AFTER TAPLOD

	MOVEI	TAC2,CHNMON	;WRT MONITOR FROM CHNL CHNMON.
	PUSHJ	P,COPY
	MTAPE	CHNTAP,3	;WRT EOF AFTER SYSTEM

	CLOSE	CHNTAP,		;WRITE TM'S ON TAPE.
	MOVEI	TAC1,[ASCIZ/TAPE WRITTEN
/]
	PJRST	DIE
;SUBR TO TYPE OUT INSTRUCTIONS.

TYPINS:	MOVEI	TAC1,INSMSG	;
	PUSHJ	P,OUTMSG	;
	PJRST	TTYOUT

INSMSG:	ASCIZ/
THIS PROGRAM WRITES A TAPE IN THE FORMAT ACCEPTABLE TO THE 2020
CONSOLE COMMANDS MB (BOOT MONITOR FROM TAPE) AND MT (BOOT MONITOR
AND MICROCODE FROM TAPE).

THE FORMAT OF THE TAPE IS AS FOLLOWS:

	12 RECORDS (ONE PAGE LONG EACH) OF MICROCODE
		OR 12 ZERO RECORDS.

	1 RECORD (ONE PAGE LONG) OF TAPE LOADER.

	SOME NUMBER OF RECORDS OF THE MONITOR FILE.

/
;SUBR TO TYPE OUT A MESSAGE AND GET ONE OF TWO ANSWERS.
;EXPECTS TAC1/ ADDR OF ASCIZ MSG, TAC2 AND TAC3 THE ASCIZ
;ANSWERS (ONE CHARACTER EACH).
;NON-SKIP RETURNS ON THE TAC2 CHARACTER MATCH SEEN, SKIP RETURNS
;ON THE TAC3 CHR MATCH SEEN.
;DESTROYS TAC4 AND TAC5.

ANSTWO:	PUSHJ	P,OUTMSG	;TYPE OUT THE MAIN MSG,
	DPB	TAC2,[POINT 7,PARMSG,^D13] ;
	DPB	TAC3,[POINT 7,PARMSG+1,^D13] ;
	PUSH	P,TAC1		;
	MOVEI	TAC1,PARMSG	;
	PUSHJ	P,OUTMSG	;
	POP	P,TAC1		;
	PUSHJ	P,TTYOUT	;
	PUSHJ	P,INCHR		;NOW GET THE ANSWER CHR IN TAC4.
	CAIL	TAC4,141	;LOWERCASE?
	CAILE	TAC4,172	;
	JRST	.+2		;NO.
	SUBI	TAC4,40		;CONVERT TO UPPERCASE.
	CAIE	TAC4,(TAC2)	;MATCHES
	CAIN	TAC4,(TAC3)	;ONE OF THE VALUES?
	JRST	.+2		;YES.
	JRST	[SETZM IBUF+2	;NO, ZAP THE BUFFER AND
		JRST ANSTWO]	;TRY AGAIN.
	MOVE	TAC5,TAC4	;
	PUSHJ	P,CKLNND	;CHECK FOR CR,LF.
	JRST	ANSTWO		;BAD NEWS.
	CAIE	TAC5,(TAC2)	;MATCHES FIRST CHR, OR SECOND?
CPOPJ1:	AOS	(P)		;SECOND.
CPOPJ:	POPJ	P,		;FIRST.

PARMSG:	ASCIZ/(Y OR N)?/

YES:	131	;Y.
NO:	116	;N.
FAKE:	106	;F.
WRITEE:	127	;W.
;SUBR TO TYPE OUT A MESSAGE AND THEN GET A FILENAME.
;EXPECTS TAC1/ ADDR OF ASCIZ MSG AND TAC2/ ADDR OF LOOKUP
;BLOCK TO BE SET UP.
;DESTROYS TAC2-TAC6.

ANSFIL:	PUSHJ	P,OUTMSG	;TYPE OUT THE REQ FOR THE NAME.
	PUSHJ	P,TTYOUT	;
	PUSHJ	P,INCHR		;A LEADING USER
	CAIN	TAC4,"("	;NAME?
	JRST	ANSFL2		;YES.
	SETZM	LKBUSR(TAC2)	;NO.
	AOS	IBUF+2		;BACK UP THE
	IBP	IBUF+1
	IBP	IBUF+1
	IBP	IBUF+1
	IBP	IBUF+1
	HRRZ	TAC4,IBUF+1	;
	MOVEI	TAC4,-1(TAC4)	;
	HRRM	TAC4,IBUF+1	;BYTE PNTR.
	JRST	ANSFL4		;

    ;HERE FOR USERNAME.
ANSFL2:	MOVEI	TAC4,USRNAM	;SET UP PNTR
	MOVEM	TAC4,LKBUSR(TAC2) ;TO IT.
	SETZM	USRNAM		;CLEAR OUT
	MOVE	TAC4,[XWD USRNAM,USRNAM+1] ;WHOLE
	BLT	TAC4,USRNME	;BLOCK.
	MOVEI	TAC6,USRNME-USRNAM+1 ;GET TAC6/ COUNT.
	SETZ	TAC5,		;GET TAC5/ OFFSET TO USRNAM.
ANSF24:	PUSHJ	P,GETALN	;GET ALPHAS AND NUMBERS ONLY.
	JUMPE	TAC4,ANSF26	;JUMP ON NOTHING THIS TIME.
	MOVEM	TAC4,USRNAM(TAC5) ;STORE THIS PART OF NAME.
	CAIN	TAC3,")"	;DONE?
	JRST	ANSFL4		;YES.
	SOJLE	TAC6,[JUMPN TAC3,ANSFER ;NO.  OUT OF ROOM?
		PUSHJ P,INCHR	;
		CAIN	TAC4,")" ;
		JRST ANSFL4	;
		JRST ANSFER]	;
	AOJA	TAC5,ANSF24	;NO, GET NEXT.
ANSF26:	SKIPE	USRNAM		;ANYTHING GOOD SEEN?
	CAIE	TAC3,")"	;YES.  RIGHT TERMINATER?
	JRST	ANSFER		;NO.
	JRST	ANSFL4		;


    ;HERE FOR FILENAME.
ANSFL4:	PUSHJ	P,GETSIX	;
	JUMPE	TAC4,ANSFER	;JUMP ON BAD SYNTAX.
	MOVEM	TAC4,LKBNAM(TAC2) ;
	CAIE	TAC3,"."	;AN EXTENSION FOLLOWS?
	JRST	[SETZM LKBEXT(TAC2) ;NO, GO CHECK FOR EO LINE.
		JRST ANSFL6]

    ;HERE FOR EXTENSION.
	PUSHJ	P,GETSIX	;
	HLLZM	TAC4,LKBEXT(TAC2) ;ZERO IS OKAY HERE.

ANSFL6:	PUSHJ	P,CHLN0		;
	JRST	ANSFIL		;NOT EO LINE.
	SETZM	LKBPRV(TAC2)	;
	SETZM	LKBSIZ(TAC2)	;
	POPJ	P,

ANSFER:	SETZM	IBUF+2		;ZAP THE INPUT BUFFER.
	JRST	ANSFIL		;

USRNAM: BLOCK ^D10
USRNME==.-1


;SUBR TO MAKE SURE A REQUESTED FILE EXISTS, AND TO COMPLAIN
;IF IT DOES NOT.
;SKIP RETURNS ON SUCCESS, ELSE NON-SKIP RETURNS.
;EXPECTS TAC2/ CHANNEL OF LOOKUP BLOCK.
;DESTROYS
FNDFIL:	XCT	LOKUP-CHNMIC(TAC2) ;
	JRST	.+2		;FAILURE.
	JRST	CPOPJ1		;SUCCESS RETURN.
	MOVEI	TAC1,[ASCIZ/
CANNOT FIND FILE.
/]
	PJRST	OUTMSG		;

LOKUP:	LOOKUP	CHNMIC,LOKMIC	;
	LOOKUP	CHNLOD,LOKLOD	;
	LOOKUP	CHNMON,LOKMON	;


;SUBR TO CHECK FOR EXPECTED END OF LINE.
;SKIP RETURNS IF OKAY, ELSE NON-SKIP RETURNS.
;DESTROYS TAC4.
CKLNND:	PUSHJ	P,INCHR		;
	CAIE	TAC4,15		;CR?
	JRST	CKLNER		;NO.
	PUSHJ	P,INCHR		;
	CAIN	TAC4,12		;LF?
CKLNN4:	AOS	(P)	;SUCCESS RETURN.
CKLNER:	SETZM	IBUF+2		;HERE ON ERROR  ZAP BUFFER
	POPJ	P,		;AND ERROR RETURN.


;SUBR TO CHECK IN A DIFFERENT WAY FOR EO LINE.
;SKIP RETURNS IF OKAY, ELSE NON-SKIP RETURNS.
;EXPECTS TAC3/ NXT CHR.
;DESTROYS NO ACS.
CHLN0:	CAIE	TAC3,15		;CR?
	JRST	CKLNER		;NO.
	PUSH	P,TAC4		;
	PUSHJ	P,INCHR		;
	MOVE	TAC3,TAC4	;
	POP	P,TAC4		;
	CAIE	TAC3,12		;LF?
	JRST	CKLNER		;NO.
	JRST	CKLNN4		;YES.


;SUBR TO OUTPUT A MSG.
;EXPECTS TAC1/ ADDR OF ASCIZ MSG.
;DESTROYS TAC4 AND TAC5.
OUTMSG:	MOVE	TAC5,[POINT 7,(TAC1)]
OUTMS2:	ILDB	TAC4,TAC5
	JUMPE	TAC4,CPOPJ
	PUSHJ	P,OUTCHR
	JRST	OUTMS2
;SUBR TO ACCEPT THE TAPE DEVICE NAME.
;EXPECTS TAC1/ ADDR OF ASCIZ MESSAGE.
;DESTROYS TAC3-TAC5.
;RETURNS TAC4/ THE DEVICE NAME.

ANSDEV:	PUSHJ	P,OUTMSG	;OUTPUT THE MESSAGE.
	PUSHJ	P,TTYOUT
	PUSHJ	P,GETSIX	;GET DEVICE NAME TO TAC4.
	JUMPE	TAC4,[SETZM IBUF+2 ;JUMP ON BAD SYNTAX.
		JRST ANSDEV]	;
	MOVE	TAC5,TAC4	;
	CAIE	TAC3,":"	;SKIP
	JRST	.+3		;OVER
	PUSHJ	P,INCHR		;A TRAILING
	MOVE	TAC3,TAC4	;":".
	PUSHJ	P,CHLN0		;CHECK FOR CR,LF.
	JRST	ANSDEV		;
	MOVE	TAC4,TAC5	;
	POPJ	P,


;SUBR TO ACCEPT THE REQUESTED DENSITY FOR THE TAPE UNIT.
;THIS SUBR ONLY KNOWS HOW TO DEAL WITH UNITS THAT HAVE A
;MAXIMUM OF THREE DIFFERENT DENSITIES.

    ;BITS RETURNED BY UGETF UUO.
DS6250==20
DS1600==10
DS800==4
DS556=2
DS200==1

    ;GET TAC2/ THE DENSITIES THE UNIT IS CAPABLE OF.
ANSDEN:	MOVEI	TAC1,2		;
	SETO	TAC2,		;
	UGETF	CHNTAP,TAC1	;
	MOVE	TAC1,TAC2	;CHECK FOR
	AOJE	TAC1,[MOVEI TAC1,[ASCIZ/
UGETF FAILURE.
/]
		PJRST DIE]
	HLRZS	TAC2		;
	ANDI	TAC2,DS6250!DS1600!DS800!DS556!DS200 ;
	JUMPE	TAC2,[MOVEI TAC1,[ASCIZ/
UNIT OR KONTROLLER HARDWARE ERROR.  NOT CAPABLE OF ANY OPERATIONS.
/]
		PJRST DIE]
	MOVEM	TAC2,DENSTY	;SAVE THE DENSITIES.

    ;ASK THE USER WHAT DENSITIES HE OR SHE WANTS.
    ;EXPECTS TAC2/ THE DENSITIES THE UNIT IS CAPABLE OF.
ANSDN1:	MOVEI	TAC1,[ASCIZ/DENSITY(/] ;
	PUSHJ	P,OUTMSG	;
	MOVEI	TAC6,DS6250	;
	SETZ	TAC3,		;TAC3 IS OFFSET TO STRING.
ANSDN2:	TRZE	TAC2,(TAC6)	;SAY THIS DENSITY?
	PUSHJ	P,DENMSG	;YES.
	LSH	TAC6,-1		;LOOK AT
	ADDI	TAC3,1		;NEXT BIT.
	JUMPN	TAC6,ANSDN2	;
	MOVEI	TAC1,[ASCIZ/)?/] ;END THE
	PUSHJ	P,OUTMSG	;MESSAGE.
	PUSHJ	P,TTYOUT	;

    ;GET AND CHECK THE USER'S ANSWER.  PUT DENSITY FLAG IN TAC3.
	PUSHJ	P,GETALN	;GET TAC4/ ANSWER.
	PUSHJ	P,CHLN0		;CHECK EO LINE.
	JRST	ANSDER		;BAD NEWS.
	JUMPE	TAC4,ANSFER	;
	MOVEI	TAC3,DENLEN	;SEE IF
	CAMN	TAC4,DENTB6-1(TAC3) ;THE ANSWER
	JRST	ANSDN4		;MATCHES
	SOJG	TAC3,.-2	;A
	JRST	ANSDER		;DENSITY.
ANSDN4:	MOVE	TAC3,DENFLG-1(TAC3) ;GET FLAG.
	TDNE	TAC3,DENSTY	;REQ=AVAIL?
	JRST	ANSDN5		;YES.
ANSDER:	MOVE	TAC2,DENSTY
	JRST	ANSDN1

    ;GET STATUS SETTING FOR THIS DENSITY.  FLAG IS IN TAC3.
    ;STATUS SETTING IS HIGH(3), MEDIUM(2), OR LOW(1), WHERE
    ;MEDIUM IS LOW IF THE UNIT HAS ONLY TWO DENSITIES.
ANSDN5:	MOVEI	TAC4,3		;TAC4/DENS=HIGHEST.
	MOVEI	TAC2,DS6250	;TAC2/ HIGHEST DENSITY.
ANSDN6:	CAIN	TAC2,(TAC3)	;IS THIS THE ONE WE WANT?
	JRST	ANSDN7		;YES.
	TDNE	TAC2,DENSTY	;NO.  IS THIS DENS AVAIL?
	SOS	TAC4		;YES, ADJUST STATUS SELECTION.
	LSH	TAC2,-1		;LOOK AT NEXT LOWER DENSITY.
	JUMPN	TAC2,ANSDN6	;
	MOVEI	TAC1,[ASCIZ/
PROGRAM LOGIC ERROR.
/]
DIE:	PUSHJ	P,OUTMSG
	PUSHJ	P,TTYOUT	;
	EXIT
ANSDN7:	LSH	TAC4,7		;RETURN TAC4/ STATUS SETTING.
	POPJ	P,

    ;EXPECTS TAC3 THE OFFSET TO THE DENSITY STRING.
    ;EXPECTS TAC2/ REST OF DENSITY BITS STILL TO DO.
    ;DESTROYS TAC1, AND TAC4-5.
DENMSG:	MOVEI	TAC1,DENTBL(TAC3);
	PUSHJ	P,OUTMSG	;
	JUMPE	TAC2,CPOPJ	;
	MOVE	TAC4,COMMA
	PJRST	OUTCHR

DENTBL:	ASCIZ/6250/
	ASCIZ/1600/
	ASCIZ/800/
	ASCIZ/556/
	ASCIZ/200/
DENLEN==.-DENTBL

DENTB6:	SIXBIT/6250/
	SIXBIT/1600/
	SIXBIT/800/
	SIXBIT/556/
	SIXBIT/200/

DENFLG: DS6250
	DS1600
	DS800
	DS556
	DS200

DENSTY:	Z
;SUBR TO COPY A FILE WHICH IS OPEN ON CHANNEL (TAC2) TO
;THE TAPE, WITHOUT WRITING EOF MARKS ON THE TAPE.
;DESTROYS TAC1 AND TAC4.

COPY:	MOVE	TAC4,LOKLST-CHNMIC(TAC2) ;GET
	MOVE	TAC4,LKBSIZ(TAC4) ;TAC4/
	ADDI	TAC4,777	;NO. OF PAGES
	LSH	TAC4,-9		;TO READ.
COPY2:	CAIN	TAC4,1		;CLEAR THE BUFFER AREA IF
	PUSHJ	P,ZERBUF	;THIS IS THE LAST PAGE.
	XCT	INPT-CHNMIC(TAC2)
	JRST	COPY4		;NO ERROR ON READ.
	XCT	STAZ-CHNMIC(TAC2) ;REAL ERROR?
	JRST	INPERR		;YES.
COPY4:	OUT	CHNTAP,COM
	SOJG	TAC4,COPY2
	JUMPE	TAC4,CPOPJ	;JUMP IF DONE WITH THIS FILE.
TAPERR:	MOVEI	TAC1,[ASCIZ/
UNRECOVERABLE TAPE ERROR ON WRITE.
/]
	PJRST	DIE
INPERR:	MOVEI	TAC1,[ASCIZ/
UNRECOVERABLE ERROR ON INPUT FILE.
/]
	PJRST	DIE

INPT:	IN	CHNMIC,COM
	IN	CHNLOD,COM
	IN	CHNMON,COM
STAZ:	STATZ	CHNMIC,740000
	STATZ	CHNLOD,740000
	STATZ	CHNMON,740000
LOKLST:	LOKMIC
	LOKLOD
	LOKMON


;SUBR TO ZERO BUF AREA.
;DESTROYS TAC1.

ZERBUF:	SETZM	BUF
	MOVE	TAC1,[XWD BUF,BUF+1]
	BLT	TAC1,BUF+777
	POPJ	P,
;SUBR TO ACCUMULATE A 6 CHARACTER DEVICE, FILENAME, EXTENSION,
;OR SIX CHARACTERS OF A USERNAME INTO TAC4, FROM THE TTY.
;GETSIX DOES DEVICE NAMES, FILENAMES, AND EXTENSIONS, GETALN
;DOES USERNAMES.
;
;GETSIX AND GETALN BOTH RETURN TAC4/ 0 IF NO CHARS BEFORE
;TERMINATING CHARACTER.
;GETSIX RETURNS TAC3/ THE NEXT CHARACTER.
;GETALN RETURNS TAC3/ THE NEXT CHARACTER ONLY IF LESS THAN SIX
;CHARACTERS WERE ASSEMBLED INTO TAC4, ELSE IT RETURNS TAC3/0.
;
;DESTROYS TAC3 AND TAC4.

GETSIX:	PUSH	P,TAC1		;
	MOVEI	TAC1,TSTSIX	;TAC1/ HOW TO TEST CHARACTERS.
	JRST	.+3		;

GETALN:	PUSH	P,TAC1		;
	MOVEI	TAC1,TSTALN	;

	PUSH	P,TAC2		;
	PUSH	P,TAC5		;
	PUSH	P,TAC6		;
	MOVEI	TAC2,6		;TAC2/ COUNTER.
	SETZ	TAC5,		;TAC5 ACCUMS CHARACTERS.
	MOVE	TAC3,[POINT 6,TAC5] ;TAC3/ BYTE PNTR TO TAC5.
GETSX2:	PUSHJ	P,INCHR		;GET TAC4/ NEXT CHARACTER.
	PUSHJ	P,(TAC1)	;TEST IT.
	JRST	GETSX4		;TERM CHAR.
	CAIL	TAC4,141	;CONVERT LOWERCASE
	MOVEI	TAC4,-40(TAC4)	;TO UPPERCASE.
	MOVEI	TAC4,-40(TAC4)	;OKAY CHR.  CONVERT TO SIXBIT.
	IDPB	TAC4,TAC3	;STORE IT IN TAC5.
	SOJG	TAC2,GETSX2	;COUNT THIS CHR.
	CAIN	TAC1,TSTALN	;
	TDZA	TAC4,TAC4	;
	PUSHJ	P,INCHR		;GET NXT CHR.
GETSX4:	MOVE	TAC3,TAC4	;RETURN NXT CHR IN TAC3.
	MOVE	TAC4,TAC5	;RETURN ANSWER IN TAC4.
	POP	P,TAC6		;RESTORE THE ACS.
	POP	P,TAC5		;
	POP	P,TAC2		;
	POP	P,TAC1		;
	POPJ	P,

    ;TEST HERE FOR ALPHAS OR NUMERICS ONLY.
TSTALN:	CAIL	TAC4,60		;
	CAILE	TAC4,172	;
	POPJ	P,		;
	CAILE	TAC4,70		;
	CAIL	TAC4,141	;
	JRST	CPOPJ1		;
	CAIL	TAC4,101	;
	CAILE	TAC4,132	;
	POPJ	P,
	JRST	CPOPJ1

    ;TEST HERE FOR DEVICE/FILE/EXT NAMES.
TSTSIX:	CAIL	TAC4,40		;IN SIXBIT
	CAILE	TAC4,172	;RANGE?
	POPJ	P,		;NO.  TERMINATING CHARACTER.
	MOVEI	TAC6,TBLLEN	;
	CAMN	TAC4,CHRTBL-1(TAC6) ;SPECIAL CHARACTER?
	POPJ	P,		;YES, TERMINATING CHARACTER.
	SOJG	TAC6,.-2	;
	JRST	CPOPJ1		;OKAY CHR.

CHRTBL:	51	;)
	50	;(
COMMA:	54	;,
	56	;.
	133	;[
	135	;]
	47	;'
	72	;:
TBLLEN==.-CHRTBL
;SUBR TO OUTPUT A CHARACTER TO THE TTY.
;EXPECTS THE CHARACTER IN TAC4.
;DESTROYS NO ACS.

OUTCHR:	SOSGE	OBUF+2		;
	JRST	OUTCH4		;
OUTCH2:	IDPB	TAC4,OBUF+1	;
	POPJ	P,
OUTCH4:	OUT	CHNTTY,
	JRST	OUTCHR		;
	HALT	.


;SUBR TO DO A TTY OUTPUT.

TTYOUT:	OUT	CHNTTY,
	POPJ	P,
	HALT	.


;SUBR TO INPUT A CHARACTER FROM THE TTY.
;RETURNS THE CHARACTER IN TAC4.
;DESTROYS TAC4.

INCHR:	SOSGE	IBUF+2		;
	JRST	INCH4		;
INCH2:	ILDB	TAC4,IBUF+1	;
	POPJ	P,
INCH4:	IN	CHNTTY,
	JRST	INCHR		;
	HALT	.
OPNTTY:	Z
SIXBIT /TTY/
XWD OBUF,IBUF

OBUF: BLOCK 3
IBUF: BLOCK 3

OPNTAP:	17
Z
Z

OPNMIC:	17
	SIXBIT/DSK/
	Z

OPNLOD:	17
	SIXBIT/DSK/
	Z

OPNMON:	17
	SIXBIT/DSK/
	Z

LKBUSR==1
LKBNAM==2
LKBEXT==3
LKBPRV==4
LKBSIZ==5

LOKMIC:	5
Z
Z
Z
Z
Z

LOKLOD: 5
Z
Z
Z
Z
Z

LOKMON: 5
Z
Z
Z
Z
Z

COM: IOWD 1000,BUF
Z

BUF: BLOCK 1000

PDL: IOWD 10,.+1
	BLOCK 10

MICLEN:	Z
END MAGWRT
    