BASE 0

!PROCEDURES

GLOBAL %NONAME

FIND %INITTTY, %HASH, %QUERY, %GETNUM, %GETOCT, %GETTOKEN, %LISTABLE
FIND %CHR.OUT, %OCTWD.OUT, %OCTOUT, %OUT, %NUMOUT, %SIXOUT, %MAKE.SIXBIT
FIND %CHOOSE, %DATOUT, %SHORT.OUT, %SPOUT
FIND %GETULC

LOCAL %CHK.IO.ERR, %CHECK.CHG, %HEADING
LOCAL %DUL.LOOK, %DUL.OVERFLOW
LOCAL %MAKE.ROOM, %KNOW.ACCT
LOCAL %OPEN.AND.LUD.LOOK, %OPEN.AND.DUL.LOOK
LOCAL %LUD.LOOK, %LUD.SEQ, %DUL.SEQ, %LIST.RECORD, %LUD.OVERFLOW
LOCAL %CHANGE.IT, %INITNONAME, %LIST.ALL.LISTS
LOCAL %GET.CHANGE, %ERROR, %LUD.CHK, %DUL.CHK
LOCAL %CALL.UUO

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)

GLOBAL NUMBER, NAME.HASH, LOC.HASH, P, CH.OUT
GLOBAL USER.NAME(2), LISTFLG

GLOBAL GETCMD:, LUD.ERR:, CHK.ERR:, CK.DUL:

LOCAL THIS.PPN, THIS.GAN, UUN, THIS.DIST, THIS.A.S, THIS.TYM, THIS.NAME(2)
LOCAL GOD, OPER, C.SER.FLG, CAN.LOOK, THIS.AREA
LOCAL DULFLG, SAVCP, BADBLK, BADFIL
LOCAL OLDBLK, TYPE, GAN, DIST, SITE, K.ALL
LOCAL CH.LUD, CH.DUL, IO.ADR, CMD, LIST
LOCAL SEQ.FLG
LOCAL D.INDEX, D.BLK(SIZE.BLK), D.BLKNO
LOCAL L.INDEX, L.BLK(SIZE.BLK), L.BLKNO
LOCAL LUD.SIZE, TEMP, TEMP1, CH.NUM, TEMP.INDEX, BUD.INDEX
LOCAL A.S.SAV, TYM.SAV, SUP.SAV, I.BIT.SAV, I.FILE.SAV, I.USER.SAV(2)
LOCAL ZONE.SAV, DAY.L.SAV, MODE.SAV
LOCAL Q.IN.SAV, Q.OUT.SAV, CORE.SAV, GFD.SAV, PC.SAV
LOCAL DETLOG.SAV, FDET.SAV, MLJOB.SAV, NOLOG.SAV

!COMMANDS
DEF CMD.LST AS 1
DEF CMD.CHANGE AS 2
DEF CMD.NAMES AS 3
DEF CMD.ENDIT AS 6
DEF CMD.HELP AS 4
DEF CMD.INSTR AS 5
DEF CMD.CHECK AS 7
DEF CMD.USER AS 8

!FLAGS IN LISTFLG
DEF USER.LST AS 1
DEF ACCT.LST AS 2
DEF CHANGE AS 4
DEF DIST.LST AS 3
DEF ALL.SET AS -1

!LISTING COMMANDS
DEF LST.USER AS 1	!LIST USER
DEF LST.GAN AS 2	!LIST GAN
DEF LST.PPN AS 3	!LIST PROJECT-PROGRAMMER
DEF LST.LUD AS 4	!LIST ALL USERS IN THE LUD
DEF LST.RUB AS 5	!LIST ALL USERS WITH RUB ON


!CHANGES TO BE MADE
DEF CH.MIN AS 4
DEF CH.LIC AS 4
DEF CH.MSG AS 5
DEF CH.INIT AS 6
DEF CH.ZONE AS 7
DEF CH.DET AS 8
DEF CH.MODE AS 9
DEF CH.STR AS 10
DEF CH.CORE AS 11
DEF CH.GFD AS 12
DEF CH.PC AS 13
DEF CH.DETL AS 17
DEF CH.FDET AS 18
DEF CH.MLJB AS 19
DEF CH.NOLG AS 20
DEF CH.MAX AS 20

!FLAGS IN STATUS
DEF NO.CHG AS 0
DEF OLD.OUT AS 1	!OLD BLK WAS WRITTEN OUT.WITHOUT THIS USER

LOCAL DET.SAV	  !ATTACH BITS
DEF DB.LOG AS 0		!LOGOUT ON DISCONNECT
DEF DB.D AS 1	 	!DETACH ON DISCONNECT - NO TIMEOUT
DEF DB.CONT AS 2	!DET ON DISCONNECT - NO TIMEOUT - CONT RUNNING
DEF DB.D.TO AS 3	!DETACH ON DISCONNECT - 15 MINUTE TIMEOUT

!SIZE OF TABLES
DEF N.U.CMDS AS 6	!NUMBER OF USER COMMANDS
DEF N.O.CMDS AS 8	!NUMBER OF OPER-ONLY COMMAND
DEF N.U.LST.CMDS AS 2	!NUMBER OF USER LIST COMMANDS
DEF N.O.LST.CMDS AS 5	!NUMBER OF OPER-ONLY LIST COMMANDS
DEF N.CMDS AS 8	!NUMBER OF PRIMARY COMMANDS
DEF N.TYPES AS 2
DEF N.MODES AS 4	!NUMBER OF MODES
DEF N.ZONES AS 26 	!NUMBER OF TIME ZONES

!TABLES

GLOBAL TABLE U.CMDS(1:N.U.CMDS)['LIST','CHANGE','NAMES','HELP',&
   'INSTRUCTIONS','QUIT']

GLOBAL TABLE O.CMDS(1:N.O.CMDS)[-1,-1,-1,-1,-1,-1,'CHECK','USER']

GLOBAL TABLE U.LST.CMDS(1:N.U.LST.CMDS)['USER','GAN']

GLOBAL TABLE O.LST.CMDS(1:N.O.LST.CMDS)[-1,-1,'PPN','LUD','RUB']

GLOBAL TABLE MODES(1:N.MODES)['PDP10','XEXEC','XEXECJ','SUDS']

GLOBAL TABLE ZONES(0:N.ZONES)[6(-1),'HAWAII AND ALASKA',-1,'PACIFIC',&
	'MOUNTAIN','CENTRAL','EASTERN','ATLANTIC',3(-1),'LONDON',&
	'WESTERN EUROPE',7(-1),'TOKYO','BRISBANE']

!ERROR MESSAGES FOR READ DATA ERRORS
DEF NODUL.BAD AS 1
DEF HASH.BAD AS 2
DEF BLKNO.BAD AS 3
DEF NOLUD.BAD AS 4
DEF GARBAGE AS 5
DEF BAD.PPNS AS 6
DEF OVER.BAD AS 7

!MACRO'S
DEF ACCT.GAN AS 4
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)
DEF BIG AS (LISTFLG = ACCT.LST OR LISTFLG = DIST.LST)
DEF COLON AS MSG(': ')
DEF COMMA AS MSG(', ')
DEF CHK.OPER AS [IF OPER = 0 THEN [MSG('$YOU MAY NOT EXECUTE THIS ');&
   MSG('COMMAND.'); GO GETCMD]]
DEF CHECK.NO.MORE.IN(A) AS [IF TEMP_NCHV P=EOLIT OR TEMP=CARRET THEN A;&
	 PCHV P]
DEF CORE1.LUD AS BYT(LUD(3),7,0)
DEF CORE2.LUD AS BYT(LUD(3),7,18)
DEF CR AS CHR.OUT(CARRET)
DEF C.S.BIT(A) AS BYT(A,1,20)
DEF DASH AS CHR.OUT($-)
DEF DAYLIG.BIT AS BYT(LUD(3),1,33)
DEF ATTACH.BIT AS BYT(LUD(3),2,15)
DEF DETLOG.BIT AS BYT(LUD(2),1,30)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DISTOUT AS [SPOUT(DIST.BITS,4); NUMOUT(DIST.BITS)]
DEF DOTS AS OUT('...')
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF EQUALS AS CHR.OUT($=)
DEF FDET.BIT AS BYT(LUD(2),1,29)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF L.GAN AS HW(@LUD(0),0)
DEF GAN.OUT AS OCTOUT(L.GAN)
DEF GFD.BIT AS BYT(LUD(2),1,32)
DEF GET.GAN AS [CHECK.NO.MORE.IN(MSG('$GLOBAL ACCOUNT: ')); GAN _ GETOCT]
DEF GET.UUN AS [CHECK.NO.MORE.IN(MSG('$UUN: ')); UUN _ GETOCT]
DEF GET.NAME(A) AS [IF OPER=1 OR THIS.A.S=1 THEN [&
   CHECK.NO.MORE.IN(A);GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER.NAME,12)] ELSE [&
   MOVE 72/CHARS.PER.WORD FROM ALL 0 TO IMAGE;&
   USER.NAME(0) _ THIS.NAME(0); USER.NAME(1) _ THIS.NAME(1)]]
DEF GET.PPN AS [GET.GAN; GET.UUN; HW(@TEMP,0) _ GAN;&
	HW(@TEMP,1) _ UUN]
DEF INIT.BIT AS BYT(LUD(2),1,8)
DEF INIT.LONG.LIST AS [HEADING; OPEN.LUD(INPUT); LUD.SEQ]
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP-_SIZE.BLK; SETCP(CH.LUD,TEMP)]
DEF JAPANESE AS 23
DEF LEGAL AS (OPER # 0 OR (THIS.A.S = 1 AND SAMACCT) OR SAMUSR)
DEF LEGAL.CH(A) AS (OCT 37 < A < OCT 133) OR A = 0
DEF LITTLE AS NOT(BIG)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.TEMP(A) AS LUD(TEMP.INDEX+A)
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,SIZE.BLK,L.BLK)]
DEF MLJOB.BIT AS BYT(LUD(2),1,28)
DEF MODE.BIT AS BYT(LUD(3),2,7)
DEF MOVE.DOWN AS [TEMP1_TRU.BIT;FOR TEMP_TEMP1+5 TO TEMP1+7 &
    LUD(TEMP+3) _ LUD(TEMP)]
DEF MSG.PAGES AS IF LITTLE THEN MSG('PAGES.')
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NAMOUT AS SIXOUT(@DUL(1),12)
DEF NO AS 0
DEF NOLOG.BIT AS BYT(LUD(2),1,35)
DEF NOT.VALID AS [MSG('$NOT A VALID USER'); GO GETCMD]
DEF NO.ZONE.CHG AS [MSG('$OPER CAN NOT HAVE ITS TIME ZONE CHANGED.');GO GETCMD]
DEF OPEN.LUD(A) AS CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+A+WORD,LUD.ERR)
DEF OPEN.TEL AS CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
DEF OPEN.DUL AS CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)
DEF OPER.PPN AS OCT 1000021
DEF OUT.WHERE AS [MSG('$OUTPUT TO: '); GETTOKEN(0); &
	CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF OV.BLK AS HW(@LUD(0),1)
DEF PC.BIT AS BYT(LUD(2),1,27)
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF PROT.FAILURE AS [MSG('$YOU DO NOT HAVE ACCESS TO THAT USER NAME$$'); GO GETCMD]
DEF RCM.BIT AS BYT(LUD(3),1,9)
DEF RUB.BIT AS BYT(LUD(2),1,33)
DEF SAMACCT AS THIS.GAN = L.GAN
DEF SAMUSR AS THIS.PPN = LUD(0)
DEF SET.TEMP AS [IF INIT.BIT = 1 THEN TEMP.INDEX _ 3;&
   IF BUD.INDEX _ TRU.BIT = 1 THEN INC TEMP.INDEX]
DEF SIZE.INC AS SIZE.LUD.ENT _ SIZE.LUD.ENT + 3
DEF SIZE.DEC AS SIZE.LUD.ENT _ SIZE.LUD.ENT - 3
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF SUPMSG.BIT AS BYT(LUD(2),1,34)
DEF TRU.BIT AS BYT(LUD(2),1,31)
DEF TYM.BIT AS BYT(LUD(3),1,14)
DEF TYPSPACE(A) AS [REPEAT A SP]
DEF USER.MISSING AS [PPN.OUT; OUT(' MISSING FROM DUL.$')]
DEF L.UUN AS HW(@LUD(0),1)
DEF UUN.OUT AS OCTOUT(L.UUN)
DEF VERSION AS 41
DEF WHAT AS [MSG('?$'); GO GETCMD]
DEF YES AS 1
DEF ZONE.BITS AS BYT(LUD(3),5,28)


%NONAME
	!MAINLINE
LOCAL ENDLUD:
START: INITNONAME
\\->START
GETCMD: SEQ.FLG _ IO.ADR _ 0; CLOSE.ALL
OPEN.TEL
CR; MSG('$: '); P _ GETLINE(TEL); GETTOKEN(0)
IF CMD _ CHOOSE(N.U.CMDS,U.CMDS) = 0 THEN DO
   IF OPER # 0 THEN DO
	IF CMD _ CHOOSE(N.O.CMDS,O.CMDS) = 0 THEN WHAT
   END ELSE WHAT
END

DO CMD OF 1:N.CMDS

CMD.LST: LOOP DO
   IF TEMP_NCHV P=EOLIT OR TEMP=CARRET THEN LIST.ALL.LISTS &
	ELSE PCHV P
   GETTOKEN(0)
   IF LIST _ CHOOSE(N.U.LST.CMDS,U.LST.CMDS) = 0 THEN DO
	IF OPER # 0 OR CAN.LOOK # 0 THEN DO
	   IF LIST_CHOOSE(N.O.LST.CMDS,O.LST.CMDS) # 0 THEN GO GOT.LST
	   LIST.ALL.LISTS
	END ELSE LIST.ALL.LISTS
   END ELSE GO GOT.LST
END


GOT.LST: DO LIST OF LST.USER:LST.RUB
LST.USER: GET.NAME(MSG(ENTER.NAME))
	LIST.FLG _ USER.LST
   L.LUD: IF OPEN.AND.LUD.LOOK(INPUT) = 0 THEN NOT.VALID
	IF LEGAL THEN LIST.RECORD(ALL.SET,OLD) ELSE PROT.FAILURE


LST.PPN: LIST.FLG _ USER.LST
   GET.PPN
   IF OPEN.AND.DUL.LOOK(TEMP) # 0 THEN DO
	USER.NAME(0) _ DUL(1); USER.NAME(1) _ DUL(2)
	GO L.LUD
   END ELSE [LUD(0) _ TEMP; USER.MISSING]



LST.GAN: LISTFLG _ ACCT.LST
   IF OPER # 0 THEN DO
	   IF KNOW.ACCT = 1 THEN &
		[CHECK.NO.MORE.IN(MSG('$ACCOUNT: ')); GETOCT]
   END ELSE NUMBER _ THIS.GAN
	INIT.LONG.LIST; INC SEQ.FLG
	LOOP DO
	   IF LEGAL AND NUMBER = L.GAN THEN LIST.RECORD(ALL.SET,OLD)
	   LUD.SEQ
	END


LST.RUB: CHK.OPER; IO.ADR _ ENDLUD
   OUT.WHERE; OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
   LOOP DO
	IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 AND RUB.BIT # 0 THEN &
	   [NAMOUT; SP; NUMOUT(TYM.BIT); CR]
	CLOSE(CH.DUL); LUD.SEQ
   END

LST.LUD: CHK.OPER; IO.ADR _ ENDLUD
   OUT.WHERE
   OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
   LOOP DO
      IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 THEN DO
	CLOSE(CH.DUL)
	NAMOUT; SP
	GAN.OUT; SP
	DISTOUT; SP
	NUMOUT(TYM.BIT); CR
      END
      LUD.SEQ
   END

END

CMD.CHANGE: GETNAME(MSG(ENTER.NAME))
	IF OPEN.AND.LUD.LOOK(INPUT) = 0 THEN NOT.VALID
	IF NOT(LEGAL) THEN PROT.FAILURE
	LISTFLG _ CHANGE; LIST.RECORD(ALL.SET,OLD)
	CLOSE(CH.LUD)
   LOOP DO
	MSG('$CHANGE WHICH ITEM - TYPE NUMBER:  ')
	CH.NUM _ GETNUM; CR
	IF GET.CHANGE = 1 THEN DO
	  IF CHECK.CHG = 1 THEN DO
		OFF.ALT
		OPEN.AND.LUD.LOOK(UPDATE)
		CHANGE.IT
		LUD.WRIT; CLOSE(CH.LUD)
		ON.ALT; MSG('$CHANGE COMPLETED.$')
	   END
	  IF QUERY('ANOTHER') = NO THEN GO GETCMD
	END ELSE MSG('ILLEGAL NUMBER.$')
   END

CMD.NAMES: IO.ADR _ ENDLUD; OUT.WHERE
   IF THIS.A.S # 0 THEN DO
	OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
	LOOP DO
	   IF SAMACCT THEN DO
		IF OPEN.AND.DUL.LOOK(LUD(0)) = 0 THEN &
		   USER.MISSING ELSE [NAMOUT; CR]
		CLOSE(CH.DUL)
	   END
	   LUD.SEQ
	END
   END ELSE [SIXOUT(THIS.NAME,12); CR]

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('$LEGAL COMMANDS ARE:$')
   IF OPER = 1 THEN &
	[MSG(O.CMDS(N.O.CMDS-1)); COMMA; MSG(O.CMDS(N.O.CMDS)); COMMA]
   LISTABLE(N.U.CMDS,U.CMDS); MSG('.$')

CMD.INSTR: MSG('$SEE (SYS)NONAME.INF')
   IF OPER = 1 OR THIS.GAN = ACCT.GAN THEN MSG('$ALSO (SYS)NONAME.OPR')

CMD.CHECK: OUT.WHERE; OPEN.LUD(INPUT); OPEN.DUL
   LUD.CHK
CK.DUL: DUL.CHK


CMD.USER: GET.PPN
   IF OPEN.AND.DUL.LOOK(TEMP) # 0 THEN [CR; NAMOUT] &
	ELSE [CR; LUD(0) _ TEMP; USER.MISSING]

END

ENDLUD: ON.ALT;  LISTFLG _ 0;  GO GETCMD

LUD.ERR: IF SEQ.FLG # 0 THEN GO GETCMD ELSE CHK.IO.ERR

%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
TEMP.INDEX _ 0
LOOP DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)<0 THEN LUD.OVERFLOW
	WHILE LUD(0) = 0 THEN LUD.READ
	IF LUD(4) # 0 THEN [SET.TEMP; RETURN]
END
END LUD.SEQ



%DUL.SEQ
	!READ NEXT SEQUENTIAL DUL ENTRY
LOCAL J
D.INDEX + _ 3
WHILE DUL(0) = 0 THEN DO
   LOOP DO
	FOR J _ 1 TO SIZE.BLK-1-D.INDEX &
	IF DUL(J)#0 THEN [BADBLK_D.BLKNO; ERROR(GARBAGE); REPEAT 0]
   REPEAT 0
   END
   INC D.BLKNO; DUL.READ
END
RETURN
END DUL.SEQ



%OPEN.AND.LUD.LOOK(MODE)
	!LOOK UP NAME IN ADR, ADR+1 IN LUD
OPEN.LUD(MODE)
RETURN LUD.LOOK(USER.NAME)
END OPEN.AND.LUD.LOOK


%LUD.LOOK(ADR)
TEMP.INDEX _ 0
HASH(^ADR,^(ADR+1))
OLDBLK _ LOC.HASH
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
END
SET.TEMP
RETURN 1
END LUD.LOOK



%OPEN.AND.DUL.LOOK(PP)
	!LOOK UP PP IN DUL
OPEN.DUL
%%DUL.LOOK(PP)
IF PP < 0 THEN [MSG('$ILLEGAL PPN.$'); GO GETCMD]
SETCP(CH.DUL,FIXCP((PP MOD 101)+1)); DUL.READ
WHILE DUL(0) # PP THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END OPEN.AND.DUL.LOOK


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS.
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
CLOSE.ALL; MSG('ERROR ON '); WFID(FIDP); MSG('...$'); OPEN.TEL
  DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
FBSERR: MSG('FILE BUSY')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK); OLDBLK _ OV.BLK
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITNONAME
	!INIT PROGRAM
LOCAL THIS.UUN
IOCS(2); INITTTY(GETCMD)
CMD _ 0
MSG('$USER VALIDATION PROGRAM - VERSION '); NUMOUT(VERSION)
CR; DATOUT
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THIS.PPN _ CALL.UUO(-OCT 23 BAND OCT 777777 BOR (-1 SHL 18),OCT 41,1)
 
OPEN.DUL; THIS.GAN _ HW(@THIS.PPN,0)
THIS.UUN _ HW(@THIS.PPN,1)
GOD _ IF THIS.UUN = OCT 113407 OR THIS.UUN = OCT 113406 THEN 1 ELSE 0
IF OPEN.AND.DUL.LOOK(THIS.PPN) = 0 THEN &
   [OCTWD.OUT(THIS.PPN); MSG(' NOT IN DUL'); EXIT]
THIS.NAME(0) _ DUL(1); THIS.NAME(1) _ DUL(2)
OPEN.LUD(INPUT); LUD.SIZE _ N.LUD.BLKS
IF LUD.LOOK(@DUL(1)) = 0 THEN [NAM.OUT; MSG(' NOT IN LUD'); EXIT]
THIS.DIST _ DIST.BITS; THIS.AREA _ THIS.DIST/10

THIS.A.S _ ACTSUP.BIT
THIS.TYM _ TYM.BIT
OPER _ BYT(TEMP _ CALL.UUO(-OCT 20,OCT 41,1),1,15)
IF OPER = 0 AND GOD = 1 THEN OPER _ 1
CAN.LOOK _ BYT(TEMP,1,3)	!1 IF RF LICENSE SET
C.SER.FLG _ -1	!-1 MEANS FLAG NOT SET AS YET;0 MEANS NOT C.SET; 1 MEANS C.SER
ALTLOC _ GETCMD; ONALT
RETURN
END INITNONAME



%LIST.RECORD(LISTNUM,WHICH)
	!LIST RECORD POINTED TO BY L.INDEX...LIST ONLY
	!ITEMS THAT CAN BE CHANGED IF USER WANTS TO CHANGE...LIST ONLY
	!SELECTIVE ITEMS IF ALL DIST OR ALL ACCT. REQUESTED
LOCAL SAV.LST
DEF HIGH.LST AS 20
LOCAL FLG, I
IF LISTNUM=ALL.SET THEN [LISTNUM_1; FLG_1] ELSE FLG _ 0
IF OPEN.AND.DUL.LOOK(LUD(0))=0 THEN [CLOSE(CH.DUL);USER.MISSING;RETURN]
CLOSE(CH.DUL)
LOOP DO

   DO LISTNUM OF 1:HIGH.LST

1: IF LITTLE THEN DO
   CR
   IF LISTFLG#CHANGE THEN MSG('1. ')
   MSG('USER NAME: ')
END
NAMOUT

2: IF LISTFLG#CHANGE THEN DO
   IF LITTLE THEN MSG('$2. DISTRICT: ')
   IF BIG AND ((OPER#0 AND LISTFLG=ACCT.LST) OR OPER=0) THEN DO
	DISTOUT; SP
   END ELSE IF LITTLE THEN DISTOUT
END

3: IF LISTFLG#CHANGE THEN DO
   IF LITTLE THEN DO
	MSG('$3. GLOBAL ACCOUNT: '); GAN.OUT
	MSG('$UNIVERSAL USER NO.: '); UUN.OUT
   END ELSE DO
	IF OPER # 0 THEN [IF LISTFLG = DISTLST THEN [GAN.OUT; SP]]
	UUN.OUT; SP
   END
END

4: IF LISTFLG # CHANGE OR OPER # 0 THEN DO
   IF LITTLE THEN MSG('$4. LICENSE: ')
   SAV.LST _ IF WHICH = OLD THEN TYM.BIT ELSE TYM.SAV
   IF SAV.LST = 1 THEN OUT('TYM. ') ELSE OUT('     ')
   SAV.LST _ IF WHICH = OLD THEN ACTSUP.BIT ELSE A.S.SAV
   IF SAV.LST = 1 THEN OUT('ACT.SUP.') ELSE OUT('        ')
   IF BIG THEN SP
END

5: SAV.LST _ IF WHICH = OLD THEN SUPMSG.BIT ELSE SUP.SAV
IF LITTLE THEN DO
   MSG('$5. '); IF SAV.LST = 0 THEN MSG('DO NOT ')
   MSG('SUPPRESS TYMSHARE MESSAGE AT LOGIN.')
END ELSE [IF SAV.LST=0 THEN OUT('TYP') ELSE OUT('SUP'); SP]


6: SAV.LST _ IF WHICH = OLD THEN INIT.BIT ELSE I.BIT.SAV
 IF LITTLE THEN MSG('$6. ')
   IF SAV.LST = 1 THEN DO
	IF LITTLE THEN MSG('INIT FILE: ')
	IF WHICH = OLD THEN DO
	   IF LUD(6+BUD.INDEX)#0 OR LUD(7+BUD.INDEX)#0 THEN &
		[CHR.OUT($();SIXOUT(@LUD(6+BUD.INDEX),12); CHR.OUT($))]
	END ELSE DO
	   IF I.USER.SAV(0) # 0 OR I.USER.SAV(1) # 0 THEN &
		[CHR.OUT($(); SIXOUT(I.USER.SAV,12); CHR.OUT($))]
	END
	IF WHICH = OLD THEN  SIXOUT(@LUD(5+BUD.INDEX),6) ELSE &
	   SIXOUT(@I.FILE.SAV,6)

   END ELSE IF LITTLE THEN MSG('NO INIT FILE.')
   IF BIG THEN [CR; NAMOUT; TYPSPACE(5)]

7: SAV.LST _ IF WHICH = OLD THEN ZONE.BITS ELSE ZONE.SAV
   IF LITTLE THEN DO
	MSG('$7. ')
	IF SAV.LST#0 THEN [MSG(ZONES(SAV.LST)); MSG(' TIME ZONE.')]&
	   ELSE MSG('TIME ZONE NOT SET.')
   END ELSE DO
	IF ZONES(SAV.LST)=-1 OR SAV.LST=0 THEN &
	   [OUT('NOT SET'); TYPSPACE(4); GO STRTAGN]
	TEMP_CHPT(ZONES(SAV.LST),-1)
	SHORT.OUT(TEMP,5)
   END
   IF BIG THEN DASH
   SAV.LST _ IF WHICH = OLD THEN DAYLIG.BIT ELSE DAY.L.SAV
   IF SAV.LST = 1 THEN DO
	IF LITTLE THEN MSG('$SUBJECT TO DAYLIGHT SAVINGS.')
	IF BIG THEN CHR.OUT($D)
   END ELSE IF BIG THEN CHR.OUT($S)
   IF BIG THEN TYPSPACE(4)

8: SAV.LST _ IF WHICH = OLD THEN ATTACH.BIT ELSE DET.SAV
IF LITTLE THEN DO
   MSG('$8. ')
   DO SAV.LST OF DB.LOG:DB.D.TO
DB.LOG: MSG('LOGOUT ON DISCONNECT.')
DB.D:   MSG('DETACH ON DISCONNECT - NO TIME OUT.')
DB.CONT: MSG('DETACH ON DISCONNECT - NO TIME OUT - CONTINUE RUNNING.')
DB.D.TO: MSG('DETACH ON DISCONNECT - TIME OUT SET.')
   END
END ELSE DO
   DO SAV.LST OF DB.LOG:DB.D.TO
DB.LOG: OUT('LOG    ')
DB.D: OUT('DET    ')
DB.CONT: OUT('DET-C  ')
DB.D.TO: OUT('DET-T  ')
   END
END

9: IF LISTFLG#CHANGE OR (THIS.AREA#JAPANESE AND DIST.BITS/10#JAPANESE) THEN DO
 SAV.LST _ IF WHICH = OLD THEN MODE.BIT ELSE MODE.SAV
IF LITTLE THEN [MSG('$9. MODE: '); MSG(MODES(SAV.LST+1))] ELSE &
   [TEMP_CHPT(MODES(SAV.LST+1),-1); SHORT.OUT(TEMP,6); SP]
END

10: IF LISTFLG # CHANGE OR OPER # 0 THEN DO
   SAV.LST _ (IF WHICH = OLD THEN LUD.TEMP(6) ELSE Q.IN.SAV)/4
   IF LITTLE THEN MSG('$10. QUOTA IN: '); SPOUT(SAV.LST,6)
   NUMOUT(SAV.LST); SP; MSG.PAGES
   SAV.LST _ (IF WHICH = OLD THEN LUD.TEMP(7) ELSE Q.OUT.SAV)/4
   IF LITTLE THEN MSG('$QUOTA OUT: '); SPOUT(SAV.LST,6)
   NUMOUT(SAV.LST); SP; MSG.PAGES
END

11: SAV.LST _ IF WHICH = OLD THEN CORE1.LUD ELSE CORE.SAV
IF LISTFLG # CHANGE OR OPER#0 THEN DO
   IF LITTLE THEN MSG('$11. AMOUNT OF CORE: ')
   IF TEMP _ SAV.LST = 0 THEN DO
	IF LITTLE THEN MSG('SYSTEM DEFAULT') ELSE OUT('DEF')
   END ELSE DO
	TEMP _ (TEMP+1) * 2
	IF BIG THEN SPOUT(TEMP,3)
	NUMOUT(TEMP)
   END
END

12: SAV.LST _ IF WHICH = OLD THEN GFD.BIT ELSE GFD.SAV
IF LITTLE THEN MSG('$12. ')
   IF SAV.LST = 0 THEN DO
	IF LITTLE THEN MSG('NO ') ELSE OUT(' NO ')
   END ELSE IF BIG THEN OUT(' ACC')
   IF LITTLE THEN MSG('GFD ACCESS')

13: SAV.LST _ IF WHICH = OLD THEN PC.BIT ELSE PC.SAV
   IF LITTEN MSG('$13. ')
   IF SAV.LST = 1 THEN DO
	IF LITTLE THEN MSG('NO ') ELSE OUT(' NO')
   END ELSE IF BIG THEN OUT(' REQ')
   IF LITTLE THEN MSG('PROJECT CODE REQUIRED')

14: IF LITTLE AND LISTFLG # CHANGE THEN DO
   MSG('$14. RUB: '); IF RUB.BIT # 1 THEN MSG('NOT '); MSG('SET')
   END

15: IF TYM.BIT AND LITTLE AND LISTFLG # CHANGE THEN DO
   MSG('$15. BUDGET: ')
   IF TRU.BIT = 0 THEN MSG('NOT SET') ELSE NUMOUT(LUD(5)/10000)
   END
16: IF LITTLE AND RCM.BIT = 1 THEN MSG('$16. RCM SET')

17: SAV.LST _ IF WHICH = OLD THEN DETLOG.BIT ELSE DETLOG.SAV
   IF LITTLE THEN DO
   MSG('$17. '); IF SAV.LST = 1 THEN MSG('DO NOT ')
    MSG('ALLOW ATTACH ON LOGIN.')
END

18: SAV.LST _ IF WHICH = OLD THEN FDET.BIT ELSE FDET.SAV
   IF LITTLE THEN DO
   MSG('$18. '); IF SAV.LST = 0 THEN MSG('DO NOT ')
  MSG('FORCE ATTACH.')
END

19:  SAV.LST _ IF WHICH = OLD THEN MLJOB.BIT ELSE MLJOB.SAV
    IF LITTLE THEN DO
   MSG('$19. '); IF SAV.LST = 1 THEN MSG('DO NOT ')
   MSG('ALLOW MULTIPLE JOBS.')
END

20: SAV.LST _ IF WHICH = OLD THEN NOLOG.BIT ELSE NOLOG.SAV
   IF LITTLE THEN DO
    MSG('$20. '); IF SAV.LST = 1 THEN MSG('DO NOT ')
    MSG('ALLOW USER TO LOGON UNDER THIS NAME.')
END
   END
STRTAGN: IF FLG = 0 OR INC LISTNUM > HIGH.LST THEN [CR; RETURN]
END
END LIST.RECORD



%GET.CHANGE
	!CHANGE ITEM CH.NUM IN LUD


LOCAL TMP1, C.CNT

IF CH.NUM < CH.MIN OR CH.NUM > CH.MAX THEN RETURN 0

	DO CH.NUM OF CH.MIN:CH.MAX

CH.LIC: IF OPER = 0 THEN RETURN 0
   A.S.SAV _ QUERY('ACCOUNT SUPERVISOR'); TYM.SAV _ QUERY('TYMSHARE')

CH.MSG: SUP.SAV _ QUERY('SUPRESS TYMSHARE MESSAGE AT LOGIN')

CH.INIT: I.FILE.SAV _ I.USER.SAV(0) _ I.USER.SAV(1) _ 0
IF I.BIT.SAV _ QUERY('DO YOU WANT TO SET AN INIT FILE') = YES THEN DO
   MSG('USER FILE BELONGS TO: '); GETTOKEN(2)
   MAKE.SIXBIT(TOKEN,I.USER.SAV,12)
   MSG('FILE NAME: '); GETTOKEN(0); C.CNT _ 0; P _ CHPT(TOKEN,-1)
   WHILE TEMP _ NCHV P # $. AND TEMP # 0 THEN INC C.CNT
   IF C.CNT > 6 THEN C.CNT _ 6
   MAKE.SIXBIT(TOKEN,@I.FILE.SAV,C.CNT)
END

CH.ZONE: IF LUD(0) = OPER.PPN THEN NO.ZONE.CHG
   LOOP DO
	MSG('ENTER TIME ZONE: '); GETTOKEN(0)
	WHILE ZONE.SAV _ CHOOSE(N.ZONES,ZONES) = 0
	MSG('$VALID TIME ZONES ARE '); LISTABLE(N.ZONES,ZONES); CR; CR
   END
   DAY.L.SAV _ QUERY('$SUBJECT TO DAYLIGHT SAVING')

CH.DET: IF QUERY('DETACH ON DISCONNECT') = YES THEN DO
   IF QUERY('SET 15 MINUTE TIME OUT') = YES THEN DET.SAV_DB.D.TO ELSE DO
      IF QUERY('CONTINUE RUNNING') = YES THEN DET.SAV_DB.CONT ELSE &
	DET.SAV_ DB.D
   END
END ELSE DET.SAV _ DB.LOG

CH.MODE: IF THIS.AREA = JAPANESE OR DIST.BITS/10 = JAPANESE THEN RETURN 0
LOOP DO
   MSG('MODE: '); GETTOKEN(0)
   WHILE MODE.SAV _ CHOOSE(N.MODES,MODES) = 0
   MSG('$VALID MODES ARE '); LISTABLE(N.MODES,MODES); CR; CR
END
MODE.SAV - _ 1

CH.STR:	IF TEMP _ GETULC < 0 THEN RETURN 0
IF C.S.BIT(TEMP) # 1 THEN RETURN 0
   MSG('$QUOTA IN (IN PAGES): '); Q.IN.SAV _ GETNUM*4
   MSG('QUOTA OUT (IN PAGES): '); Q.OUT.SAV _ GETNUM*4

CH.CORE: IF OPER = 0 THEN RETURN 0
   MSG('$ENTER AMOUNT OF CORE: ')
   IF GETNUM > 256 THEN NUMBER _ 256
   TMP1 _ NUMBER/2
   IF TMP1 * 2 # NUMBER THEN DO
	NUMBER+_1
	MSG('$AMOUNT OF CORE MUST BE EVEN.')
   END
   IF NUMBER # 0 THEN NUMBER _ (NUMBER/2)-1
   CORE.SAV _ NUMBER

CH.GFD: GFD.SAV _ QUERY('ALLOW ACCESS TO GFD')

CH.PC:	PC.SAV _ (QUERY('PROJECT CODE REQUIRED')+1) BAND 1

CH.DETL: DETLOG.SAV _ QUERY('DO NOT ALLOW ATTACH ON LOGIN')

CH.FDET:  FDET.SAV _ QUERY('FORCE ATTACH')

CH.MLJB:  MLJOB.SAV _ QUERY('DO NOT ALLOW MULTIPLE JOBS')

CH.NOLG:  NOLOG.SAV _ QUERY('DO NOT ALLOW USER TO LOGON UNDER THIS NAME')
END
RETURN 1
END GET.CHANGE



%MAKE.ROOM
	!MAKE ROOM FOR AN ADDITIONAL 3 WORD IN ENTRY...CREATE OVERFLOW
	!BLOCK IF NECESSARY
LOCAL TMP,I,SAVENT(20)
TMP _ SIZE.LUD.ENT
MOVE TMP FROM @LUD(0) TO SAVENT
MOVE SIZE.BLK-L.INDEX-TMP FROM @LUD(TMP) TO @LUD(0)
WHILE LUD(0)#0 THEN L.INDEX+_SIZE.LUD.ENT
MOVE TMP FROM SAVENT TO @LUD(0)
IF L.INDEX+SIZE.LUD.ENT+3<SIZE.BLK THEN RETURN
HW(@LUD(0),0) _ -1; OV.BLK _ LUD.SIZE+ _ 1
LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1)*SIZE.BLK)
L.INDEX _ 0
MOVE SIZE.BLK FROM ALL 0 TO LBLK
MOVE TMP FROM SAVENT TO @LUD(0)
RETURN
END MAKE.ROOM


%HEADING
OUT.WHERE
DATOUT
IF OPER # 0 THEN DO
   IF LISTFLG = ACCT.LST THEN [OUT('$GLOBAL ACCOUNT: ');&
	OCTOUT(NUMBER)]
   IF LISTFLG = DIST.LST THEN [OUT('$DISTRICT: ');NUMOUT(NUMBER)]
END ELSE [OUT('$GLOBAL ACCOUNT: '); OCTOUT(THIS.GAN)]
OUT('$$USER         ')
IF OPER = 0 OR LISTFLG=ACCT.LST THEN OUT('DIST ')
IF OPER # 0 AND LISTFLG=DIST.LST THEN OUT('GAN    ')
OUT('UUN      LICENSE     MSG INIT FILE$')
OUT('                   ZONE     DISC    MODE    Q-IN   Q-OUT  CORE GFD  PC$')
OUT('                                             (IN PAGES)$$')
RETURN
END HEADING




%CHANGE.IT

   DO CH.NUM OF CH.MIN:CH.MAX

CH.LIC: ACTSUP.BIT _ A.S.SAV
   TYM.BIT _ TYM.SAV

CH.MSG: SUPMSG.BIT _ SUP.SAV

CH.INIT: IF I.BIT.SAV = 1 THEN DO
   IF INIT.BIT # 1 THEN [INIT.BIT _ 1; MAKE.ROOM; MOVE.DOWN; SIZE.INC]
   MOVE 2 FROM I.USER.SAV TO @LUD(TRU.BIT+6)
   LUD(BUD.INDEX+5) _ I.FILE.SAV
END ELSE DO
   IF INIT.BIT = 1 THEN DO
	INIT.BIT _ 0; SIZE.DEC
   MOVE (SIZE.BLK-(L.INDEX+SIZE.LUD.ENT)) FROM &
	@LUD(BUD.INDEX+8) TO @LUD(BUD.INDEX+5)
   MOVE 3 FROM ALL 0 TO L.BLK(126)
   END
END

CH.ZONE: ZONE.BITS _ ZONE.SAV
   DAYLIG.BIT _ DAY.L.SAV

CH.DET: ATTACH.BIT _ DET.SAV

CH.MODE: MODE.BIT _ MODE.SAV

CH.STR: LUD.TEMP(6) _ Q.IN.SAV
   LUD.TEMP(7) _ Q.OUT.SAV

CH.CORE: CORE1.LUD _ CORE.SAV
   CORE.2.LUD _CORE.SAV

CH.GFD: GFD.BIT _ GFD.SAV

CH.PC:	PC.BIT _ PC.SAV

CH.DETL: DETLOG.BIT _ DETLOG.SAV

CH.FDET: FDET.BIT _ FDET.SAV

CH.MLJB: MLJOB.BIT _ MLJOB.SAV

CH.NOLG: NOLOG.BIT _ NOLOG.SAV

END
RETURN 1
END CHANGE.IT


%KNOW.ACCT
	!SEE IF USER KNOWS ACCT.NO. OR ASK HIM NAME
IF QUERY('$DO YOU KNOW THE GLOBAL ACCOUNT NUMBER') = YES THEN RETURN 1
 MSG('$ENTER A USERS NAME FROM THE ACCOUNT: '); GETTOKEN(2)
MAKE.SIXBIT(TOKEN,USER.NAME,12)
IF OPEN.AND.LUD.LOOK(INPUT) = 0 THEN NOT.VALID ELSE NUMBER _ L.GAN
RETURN 0
END KNOW.ACCT


%CHECK.CHG
	!ASK IF USER IS SURE HE WANTS TO MAKE CHANGE
	!1=YES, 0=NO
LIST.RECORD(CH.NUM,NEW)
TEMP _ QUERY('$OKAY'); RETURN TEMP
END CHECK.CHG


%LIST.ALL.LISTS
IF OPER = 1 THEN &
   [FOR TEMP _ 3 TO N.O.LST.CMDS [MSG(O.LST.CMDS(TEMP)); COMMA]]
LISTABLE(N.U.LST.CMDS,U.LST.CMDS)
COLON; P _ GETLINE(TEL)
RETURN
END LIST.ALL.LISTS



%CALL.UUO(AC,ADDR,SKPFLG)
LOCAL DIDIT:
^OCT 12 _AC
EXU(OCT 47, OCT 12, ADDR, DIDIT)
IF SKPFLG = 1 THEN [MSG('$UUO FAILED.'); EXIT]
DIDIT: RETURN ^OCT 12
END CALL.UUO



%LUD.CHK
	!READ THRU LUD, LOOKING UP AND CHECKING EACH ENTRY IN DUL
LOCAL %CK.LUD.SEQ, %L.FIRST
LOCAL DULFLG, LP1:
IO.ADR _ CK.DUL
MSG('$$LUD - DUL CHECK$$')
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.FIRST; GO LP1
LOOP DO
   LP1:WHILE LUD(4) = 0 THEN CK.LUD.SEQ
   IF DULFLG _ DUL.LOOK(LUD(0)) = 1 THEN DO
	HASH(DUL(1),DUL(2))
	IF NAME.HASH # LUD(4) THEN ERROR(HASH.BAD)
	IF LOC.HASH # L.BLKNO THEN ERROR(BLKNO.BAD)
   END ELSE ERROR(NODUL.BAD)
   CK.LUD.SEQ
END

%CK.LUD.SEQ
LOCAL J
L.INDEX + _ SIZE.LUD.ENT
%%L.FIRST
WHILE LUD(0) = 0 THEN DO
   LOOP DO
   FOR J_1 TO SIZE.BLK-1-L.INDEX IF LUD(J)#0 THEN &
	[BADBLK_L.BLKNO; ERROR(GARBAGE); REPEAT 0]
   REPEAT 0
   END
   INC L.BLKNO; LUD.READ
END
RETURN
END CK.LUD.SEQ
END LUDCHK



%DULCHK
	!READ THRU DUL, LOOKING UP ENTRY IN LUD
LOCAL ENDDUL:
IO.ADR _ ENDDUL
MSG('$$DUL - LUD CHECK$$')
DUL.READ; D.INDEX _ -3
LOOP DO
   DUL.SEQ
   IF LUD.LOOK(@DUL(1)) # 0 THEN DO
	IF LUD(0) # DUL(0) THEN ERROR(BAD.PPNS)
   END ELSE ERROR(NOLUD.BAD)
END
ENDDUL: RETURN
END DULCHK



%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
DO ERR OF NODUL.BAD:OVER.BAD
   NODUL.BAD: OUT('NO DUL ENTRY FOR ');  PPN.OUT
   HASH.BAD: OUT('HASH OF '); PPN.OUT; EQUALS
	OCTWD.OUT(NAME.HASH); CR; OUT('ENTRY IN LUD = ')
	OCTWD.OUT(LUD(4))
   BLKNO.BAD: OUT('HASH BLK. NO. OF '); PPN.OUT; EQUALS
	OCTOUT(LOC.HASH); CR; OUT('ENTRY IS IN BLK. NO. ')
	NUMOUT(L.BLKNO); DOTS; NAM.OUT
   NOLUD.BAD: OUT('NO LUD ENTRY FOR '); OCTWD.OUT(DUL(0)); DOTS
	NAM.OUT
   GARBAGE: OUT('GARBAGE IN BLOCK '); NUMOUT(BADBLK)
	OUT(' NOT FOUND')
   BAD.PPNS: OUT('LUD PPN = '); PPN.OUT; DOTS
	OUT('DUL PPN = '); OCTWD.OUT(DUL(0))
   OVER.BAD: OUT('OVERFLOW POINT IN '); OUT(BADFIL); OUT(' IS IN WORD ')
	NUMOUT(BADBLK); OUT(' BLOCK '); NUMOUT(L.BLKNO)
	CR; CLOSE.ALL; EXIT
END
CR
RETURN
END ERROR

END NONAME
   D0^