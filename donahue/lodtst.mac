	TITLE	LODTST
	SEARCH	LODUNV[14717,,216522]
	SUBTTL	CONTROL PROGRAM FOR MONITOR TEST SIMULATION SYSTEM


;ACCUMULATORS

T1==1			;TEMPORARY ACS
T2==2
T3==3
T4==4
T5==5
A==6			;SEMI-PERMANENT ACS
B==7
C==10
D==11
CH==16
P==17


;I/O CHANNELS

DSK==0			;DISK CHANNEL FOR CONTROL FILE
PTY==2			;PTY CHANNEL FOR LOGGING IN JOBS


;PARAMETERS

SYSPRJ==1		;PROJECT NUMBER FOR SYSTATS
SYSPRG==2		;PROGRAMMER NUMBER FOR SYSTATS
			;THIS PPN MUST HAVE HPQ PRIVILEGES


;OPDEFS

OPDEF	PJRST	[JRST]


;ASSEMBLY SWITCHES

SPOOL==1		;SET SPOOL SWITCH NON-ZERO TO SPOOL SYSTATS INSTEAD OF
			;SENDING THEM TO HARDWARE LPT:
DEBUG==0		;SET DEBUG SWITCH NON-ZERO FOR ADDITIONAL INFO ON LOGIN FAILURE
KILL==0			;SET KILL SWITCH TO ZERO FOR STANDARD EXIT PROCEDURE
			;SET NON-ZERO TO KILL JOBS AT END OF TEST
			;THIS DEFAULT CAN BE OVERRIDED WITH /KILL AND /NOKILL COMMANDS
	SUBTTL	MAIN PROGRAM


LODTST:	JFCL			;ENTRY POINT
	MOVE	P,PDP		;SET UP PDL POINTER
	PUSHJ	P,INITL		;INITIALIZE VARIABLES

MAIN:	PUSHJ	P,GETDEV	;SELECT INPUT DEVICE
	PUSHJ	P,PARAM		;GET PROGRAM OPTIONS
	SKIPE	JOBOPT		;WHICH OPTION?
	JRST	DOMOD		;MODULO OPTION
	PUSHJ	P,CATEGY	;DO CATEGORY OPTION
	JRST	LOGDIN		;GO START UP THE TEST
DOMOD:	PUSHJ	P,MODULO	;DO MODULO OPTION
LOGDIN:	SKIPE	SYSTIM		;SYSTATS REQUESTED?
	PUSHJ	P,LOGSYS	;LOGIN SYSTAT JOB
	PUSHJ	P,DOWAKE	;WAKE UP ALL JOBS
	SETZM	INPIND		;RETURN INPUT TO TTY:
	PUSHJ	P,DAYTIM	;OUTPUT TIME OF DAY
	OUTSTR	[ASCIZ/SIMULATION STARTED.
/]

SYSLUP:	PUSHJ	P,SNOOZE	;SLEEP UNTIL ITS TIME TO DO SOMETHING
	PUSHJ	P,CHKSYS	;CHECK IF TIME TO QUIT OR TIME TO DO SYSTAT
	JRST	FINISH		;NON-SKIP RETURN IF TIME TO STOP THE SIMULATION
	PUSHJ	P,CHKTTY	;SEE IF ANY TTY COMMANDS ISSUED
	JRST	SYSLUP		;NORMAL RETURN IF NO EXIT COMMAND GIVEN
				;SKIP RETURN IF AN EXIT COMMAND WAS TYPED

FINISH:	PUSHJ	P,DAYTIM	;OUTPUT TIME OF DAY
	OUTSTR	[ASCIZ/END OF SIMULATION. STARTING EXIT PROCEDURE.
/]
	PUSHJ	P,DOSYS		;DO FINAL SYSTAT
	PUSHJ	P,KILSYS	;STOP ALL JOBS
	JRST	FINERR		;COULDN'T GET RID OF ALL JOBS
	PUSHJ	P,DAYTIM	;OUTPUT TIME
	OUTSTR	[ASCIZ/END OF EXIT PROCEDURE. ALL JOBS STOPPED.
/]
	JRST	DONE		;SUCCESS
FINERR:	PUSHJ	P,DAYTIM	;OUTPUT TIME
	OUTSTR	[ASCIZ/EXIT TIME LIMIT REACHED.
SOME LODTST JOBS MAY STILL BE RUNNING.
/]
DONE:	OUTSTR	[ASCIZ/LODTST EXITING.
/]
	EXIT
	SUBTTL	MAIN PROGRAM BLOCKS


;INITL	- ROUTINE TO INITIALIZE VARIABLES


INITL:	RESET			;RESET ALL DEVICES
	SETZM	INPIND		;SET INPUT DEVICE TO TTY
	SETZM	SYSFLG		;FLAG WHETHER SYSTAT JOB HAS BEEN LOGGED IN
	SETZM	NJOBS		;NUMBER OF JOBS LOGGED IN ON PTYS
	MOVEI	T1,1		;PUT JOB IN HPQ 1
	HPQ	T1,		;WITH HPQ UUO
	JFCL			;IGNORE ERROR
	POPJ	P,



;GETDEV	- ROUTINE TO READ DEVICE SPECIFICATION


GETDEV:	OUTSTR	[ASCIZ/ENTER INPUT FILE SPEC (DEFAULT IS TTY:)
/]
	PUSHJ	P,GETSPC	;GET FILE SPEC
	SKIPN	OPENBL+1	;TTY?
	POPJ	P,		;YES
	SETOM	INPIND		;INDICATE DISK INPUT
	OPEN	DSK,OPENBL	;OPEN DISK FILE
	JRST	OPNERR		;NO SUCH DEVICE
	INBUF	DSK,1		;SET UP ONE BUFFER
	LOOKUP	DSK,LOOKBL	;FIND FILE
	JRST	LOKERR		;NO SUCH FILE
	POPJ	P,		;RETURN
OPNERR:	OUTSTR	[ASCIZ/? FAILURE OPENING INPUT DEVICE.
/]
	JRST	ABEND		;TERMINATE RUN
LOKERR:	OUTSTR	[ASCIZ/? FAILURE ON LOOKUP FOR INPUT FILE.
/]
	JRST	ABEND		;GIVE UP
;PARAM	- READ TIME BETWEEN SYSTATS, LENGTH OF TEST, AND JOB OPTION


PARAM:	OUTSTR	[ASCIZ/ENTER INTERVAL BETWEEN SYSTATS (MINS)
/]
	PUSHJ	P,GETDEC	;GET DECIMAL NUMBER
	JUMPE	CH,SYSOK	;JUMP IF LEGAL TERMINATOR
	OUTSTR	[ASCIZ/? ILLEGAL SYSTAT INTERVAL.
/]
	PUSHJ	P,ABCHK		;CHECK FOR DSK INPUT
	JRST	PARAM		;TRY AGAIN
SYSOK:	IMULI	T4,^D60		;CONVERT TO SECONDS
	MOVEM	T4,SYSTIM	;STORE SYSTAT INTERVAL

TSTLEN:	OUTSTR	[ASCIZ/ENTER LENGTH OF TEST (MINS)
/]
	PUSHJ	P,GETDEC	;INPUT RESPONSE
	JUMPE	CH,TSTOK	;CHECK FOR LEGAL TERMINATOR
	OUTSTR	[ASCIZ/? ILLEGAL TEST LENGTH.
/]
	PUSHJ	P,ABCHK		;CHECK FOR DSK
	JRST	TSTLEN		;TRY AGAIN
TSTOK:	IMULI	T4,^D60		;CONVERT TO SECONDS
	SKIPG	T4		;ANY LENGTH SPECIFIED?
	MOVSI	T4,200000	;NO, USE INFINITE NUMBER
	MOVEM	T4,TESTIM	;LENGTH OF TEST

GETOPT:	SETZM	JOBOPT		;DEFAULT TO CATEGORY OPTION
	OUTSTR	[ASCIZ/ENTER JOB DATA OPTION (CATEGORY OR MODULO)
/]
	PUSHJ	P,GATOM		;READ RESPONSE
	JUMPN	CH,OPTERR	;ILLEGAL TERMINATOR
	MOVE	T1,[-NUMOPT,,TABOPT] ;POINTER TO OPTION TABLE
	PUSHJ	P,MATCH		;LOOK FOR A MATCH
	JUMPL	T2,@1(T2)	;BRANCH TO PROPER ROUTINE
OPTERR:	OUTSTR	[ASCIZ/? ILLEGAL FORMAT. TYPE EITHER CAT OR MOD.
/]
	PUSHJ	P,ABCHK		;TERMINATE IF FROM DISK
	JRST	GETOPT		;TRY AGAIN

MODOPT:	SETOM	JOBOPT		;NON-ZERO MEANS MODULO
CATOPT:	POPJ	P,		;RETURN

TABOPT:	SIXBIT/MODULO/
	MODOPT
	SIXBIT/CATEGO/
	CATOPT
NUMOPT==.-TABOPT
;CATEGY	- ROUTINE TO LOG IN JOBS BY SPECIFIED PPN FOR EACH CATEGORY


CATEGY:	OUTSTR	[ASCIZ/ENTER PPN AND NUMBER OF JOBS (PROJ,PROG:NUMBER) ONE PER LINE.
EXTRA CARR RET TO GO TO NEXT CATEGORY.
/]
	SKIPA	C,[-NUMCLS,,0]	;AOBJN WORD
CATAOB:	AOBJP	C,CPOPJ		;RETURN WHEN THRU WITH ALL JOB TYPES
CATLUP:	OUTSTR	@PRGNAM(C)	;TYPE PROGRAM NAME
	OUTSTR	[ASCIZ/: /]
	PUSHJ	P,GETOCT	;READ PROJECT
	JUMPE	CH,CATAOB	;GO TO NEXT CATEGORY IF CR
	CAIE	CH,","		;OTHERWISE DELIMITER MUST BE COMMA
	JRST	CATERR		;NO, ERROR
	MOVEM	T4,CURPRJ	;STORE PROJECT
	PUSHJ	P,GETOCT	;READ PROGRAMMER
	CAIE	CH,COLON	;MUST BE COLON
	JRST	CATERR		;NOT COLON
	MOVEM	T4,CURPRG	;STORE PROGRAMMER NUMBER
	PUSHJ	P,GETDEC	;READ NUMBER OF JOBS
	JUMPE	CH,CATOK	;OK IF CR OR ALT
CATERR:	OUTSTR	[ASCIZ/? ILLEGAL CATEGORY SPECIFICATION.
TYPE PROJ,PROG:NUMBER (PROJ,PROG IN OCTAL, NUMBER IN DECIMAL).
/]
	PUSHJ	P,ABCHK		;CHECK IF DISK
	JRST	CATLUP		;RETRY

CATOK:	SKIPG	D,T4		;NUMBER OF JOBS TO LOGIN
	JRST	CATAOB		;NONE
CATLOG:	PUSHJ	P,DOLOG		;LOGIN A JOB
	PUSHJ	P,DORUN		;START IT RUNNING
	SOJG	D,CATLOG	;LOGIN THE REST OF THE JOBS
	JRST	CATLUP		;DO MORE JOBS OF THIS CATEGORY
;MODULO	- ROUTINE TO GENERATE JOBS WITH PROGRAMMER NUMBER MODULO A SPECIFIED RANGE


MODULO:	OUTSTR	[ASCIZ/ENTER BASE PPN (PROJ,PROG)
/]
	PUSHJ	P,GETOCT	;READ AN OCTAL NUMBER
	CAIE	CH,","		;DELIMITER SHOULD BE COMMA
	JRST	PPNERR		;WRONG DELIMITER
	MOVEM	T4,BASPRJ	;STORE BASE PROJECT
	PUSHJ	P,GETOCT	;READ PROG NUMBER
	JUMPE	CH,PPNOK	;DELIMITER SHOULD BE CR OR ALT
PPNERR:	OUTSTR	[ASCIZ/? ILLEGAL PROJ,PROG NUMBER FORMAT.
/]
	PUSHJ	P,ABCHK		;CHECK FOR DISK INPUT
	JRST	MODULO		;TRY AGAIN
PPNOK:	MOVEM	T4,BASPRG	;BASE PROG NUMBER

MODGET:	OUTSTR	[ASCIZ/ENTER MODULO NUMBER (DECIMAL)
/]
	PUSHJ	P,GETDEC	;READ DECIMAL
	JUMPN	CH,MODERR	;BAD DELIMITER
	JUMPG	T4,MODOK	;JUMP IF POSITIVE
	AOJG	T4,MODOK	;MAKE ZERO DEFAULT TO ONE
MODERR:	OUTSTR	[ASCIZ/? ILLEGAL MODULO NUMBER.
/]
	PUSHJ	P,ABCHK		;CHECK FOR DISK
	JRST	MODGET		;RETRY

MODOK:	MOVEM	T4,MODNUM	;STORE MOD NUMBER
	SETOM	CLASS		;INITIALIZE MODULO COUNTER
	MOVSI	C,-NUMCLS	;SET UP AOBJN WORD
MODLUP:	OUTSTR	@PRGNAM(C)	;TYPE PROGRAM NAME
	OUTSTR	[ASCIZ/: /]
	PUSHJ	P,GETDEC	;NUMBER OF JOBS TO LOG IN
	JUMPE	CH,NUMOK	;JUMP IF CR OR ALT
	OUTSTR	[ASCIZ/? ILLEGAL NUMBER OF JOBS.
/]
	PUSHJ	P,ABCHK		;TERMINATE IF DISK
	JRST	MODLUP		;RETRY
NUMOK:	SKIPG	D,T4		;ANY JOBS REQUESTED?
	JRST	MODAOB		;NO
MODLOG:	AOS	A,CLASS		;BUMP MODULO COUNTER
	IDIV	A,MODNUM	;GET MODULO IN B
	ADD	B,BASPRG	;ADD IN BASE PROG NUMBER
	MOVEM	B,CURPRG	;CURRENT PROG NUMBER
	MOVE	T1,BASPRJ	;BASE PROJECT
	MOVEM	T1,CURPRJ	;INTO CURRENT PROJECT
	PUSHJ	P,DOLOG		;LOGIN A JOB
	PUSHJ	P,DORUN		;START IT RUNNING
	SOJG	D,MODLOG	;LOGIN THE REST OF THE JOBS OF THIS TYPE
MODAOB:	AOBJN	C,MODLUP	;DO THE NEXT TYPE
	POPJ	P,		;RETURN
;LOGSYS	- LOGIN THE SYSTAT JOB UNDER 1,2


LOGSYS:	SETOM	SYSFLG		;FLAG THAT SYSTAT JOB HAS BEEN LOGGED IN
	MOVEI	T1,SYSPRJ	;PROJECT FOR SYSTAT
	MOVEM	T1,CURPRJ	;INTO CURRENT PORJECT
	MOVEI	T1,SYSPRG	;PROGRAMMER NUMBER FOR SYSTAT
	MOVEM	T1,CURPRG	;INTO CURRENT PROG
	PUSHJ	P,DOLOG		;LOG IT IN
	MOVEI	T1,[ASCIZ/SET HPQ 1
/]
	PUSHJ	P,PTYMSG	;PUT IT IN HPQ
	PUSHJ	P,CHKLOG	;WAIT TIL IT GETS BACK TO MONITOR LEVEL
	JFCL			;IGNORE ANY ERRORS
IFN SPOOL,<
	MOVEI	T1,[ASCIZ/SET SPOOL LPT
/]
	PUSHJ	P,PTYMSG	;USE SPOOLED PRINTER
	PUSHJ	P,CHKLOG	;WAIT FOR DOT TO COME BACK
	JFCL			;IGNORE ERRORS
>
	POPJ	P,		;RETURN
	POPJ	P,		;RETURN



;DOWAKE	- WAKE UP ALL JOBS


DOWAKE:	MOVE	T2,[20,,12]
	GETTAB	T2,		;GET HIGHJB
	MOVEI	T2,^D511	;IF ERROR ASSUME 511 JOBS
	MOVEM	T2,HIGHJB	;SAVE HIGHEST JOB LOGGED IN NOW
WAKLUP:	HRRZ	T1,T2		;SET UP FOR WAKE UUO
	WAKE	T1,		;WAKE UP THE JOB
	JFCL			;IGNORE ERRORS
	SOJG	T2,WAKLUP	;WAKE ALL JOBS
	MSTIME	T1,		;GET TIME IN MILLISEC
	IDIVI	T1,^D1000	;CONVERT TO SEC
	ADDM	T1,TESTIM	;ADD CURRENT TIME TO LENGTH OF TEST FOR EXIT TIME
	SKIPG	SYSTIM		;ANY SYSTAT INTERVAL?
	MOVSI	T1,200000	;NO, USE BIG NUMBER
	MOVEM	T1,NEXTIM	;TIME FOR FIRST SYSTAT
	POPJ	P,		;RETURN
;SNOOZE	- SLEEP UNTIL TIME TO PROCESS NEXT EVENT


SNOOZE:	MSTIME	A,		;GET TIME IN MILLISEC
	IDIVI	A,^D1000	;CHANGE TO SEC
	MOVEI	B,1(A)		;ADD ONE SEC AND STORE IN B FOR COMPARES
	MOVE	T1,TESTIM	;END OF TEST TIME
	CAMLE	T1,NEXTIM	;EARLIER THAN NEXT SYSTAT TIME?
	MOVE	T1,NEXTIM	;NO, USE SYSTAT TIME
	SUB	T1,A		;TIME INTERVAL TO NEXT EVENT
	JUMPLE	T1,CPOPJ	;RETURN IF ITS ALREADY TIME
	CAILE	T1,^D60		;GREATER THAN MAXIMUM SLEEP INTERVAL?
	MOVEI	T1,^D60		;MAKE IT 60
	MOVE	T2,T1		;HIBER INTERVAL
	IMULI	T2,^D1000	;IN MILLISEC
	TLO	T2,(1B13)	;WAKE ON TTY ACTIVITY (LINE MODE)
	HIBER	T2,		;TRY HIBER
	SLEEP	T1,		;IF IT FAILS TRY SLEEP
	POPJ	P,		;RETURN TO PROCESS ANY EVENT



;CHKSYS	- ROUTINE TO SEE IF TIME FOR SYSTAT OR EXIT (NON-SKIP RETURN IF EXIT)


CHKSYS:	CAMGE	B,TESTIM	;TIME FOR NORMAL EXIT?
	JRST	CHKNXT		;NO
	MOVE	A,KILLSW	;CURRENT VALUE OF END OF TEST FLAG
	POPJ	P,		;AND GIVE NON-SKIP RETURN

CHKNXT:	CAMGE	B,NEXTIM	;TIME FOR A SYSTAT?
	JRST	CPOPJ1		;NO - GIVE GOOD RETURN
	PUSHJ	P,DOSYS		;YES - WITHIN ONE SECOND
	SKIPG	T1,SYSTIM	;TIME BETWEEN SYSTATS
	MOVSI	T1,200000	;NO AUTO SYSTATS, USE LARGE NUMBER
	ADDM	T1,NEXTIM	;UPDATE TIME FOR NEXT SYSTAT
CPOPJ1:	AOS	(P)		;GIVE SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN
;CHKTTY	- ROUTINE TO MONITOR TTY FOR COMMANDS (SKIP RETURN IF EXIT COMMAND)


CHKTTY:	SKPINL			;SKIP IF ANY TTY INPUT READY
	POPJ	P,		;NONE - RETURN
	PUSHJ	P,GATOM		;READ A COMMAND
	JUMPN	CH,CHKERR	;ILLEGAL TERMINATOR
	MOVE	T1,[-NUMTTY,,TABTTY] ;POINTER TO TTY COMMAND TABLE
	PUSHJ	P,MATCH		;FIND A MATCH
	JUMPL	T2,@1(T2)	;IF SUCCESSFUL, BRANCH TO ROUTINE
CHKERR:	OUTSTR	[ASCIZ *? ILLEGAL COMMAND. COMMANDS ARE:
SYSTAT
EXIT
KILL
/EXIT
/KILL
/NOKILL (SAME AS /EXIT)
*]
	CLRBFI			;CLEAR ANY TYPE AHEAD
	JRST	CHKTTY		;LOOK FOR MORE INPUT

TABTTY:	SIXBIT/SYSTAT/
	CHKTTS
	SIXBIT/EXIT/
	CHKTTE
	SIXBIT/KILL/
	CHKTTK
	SIXBIT/:EXIT/
	CHKTTX
	SIXBIT/:KILL/
	CHKTTL
	SIXBIT/:NOKIL/
	CHKTTX
NUMTTY==.-TABTTY

CHKTTS:	PUSHJ	P,DOSYS		;DO A SYSTAT NOW
	JRST	CHKTTY		;LOOK FOR MORE

CHKTTE:	TDZA	A,A		;DO NORMAL EXIT CODE
CHKTTK:	SETO	A,		;DO KILL CODE
	PJRST	CPOPJ1		;GIVE SKIP RETURN

CHKTTL:	SETOM	KILLSW		;SET END OF TEST FLAG TO KILL
	JRST	CHKTTY		;CHECK FOR MORE COMMANDS

CHKTTX:	SETZM	KILLSW		;SET END OF TEST FLAG TO EXIT
	JRST	CHKTTY		;CHECK FOR MORE

;KILSYS	- TELL LODTST JOBS TO STOP


KILSYS:	MOVE	B,['ENDTST']
	JUMPE	A,KILA		;JUMP IF REGULAR EXIT
	HRLI	B,'KIL'		;CHANGE TO KJOB EXIT
	SKIPN	SYSFLG		;IS A SYSTAT JOB LOGGED IN?
	JRST	KILA		;NO
	MOVEI	T1,[ASCIZ/R LOGOUT
/]
	PUSHJ	P,PTYMSG	;FORCE A LOGOUT COMMAND
	PUSHJ	P,CHKJOB	;WAIT TILL IT GETS KJOBED
	JFCL			;IGNORE ERROR RETURN
KILA:	SETNAM	B,		;CHANGE PROGRAM NAME
	SOSLE	T1,NJOBS	;ANY LODTST JOBS LOGGED IN?
	JRST	KILC		;YES, GO WAIT FOR THEM TO EXIT
	JUMPL	T1,KILB		;IF NO JOBS LOGGED IN JUST SLEEP A MIN
	SKIPN	SYSFLG		;IF THERES ONE JOB AND ITS NOT THE SYSTAT JOB...
	JRST	KILC		;...GO WAIT FOR IT
KILB:	MOVEI	T1,^D60		;OTHERWISE SLEEP 60 SEC
	SLEEP	T1,		;SINCE WE DON'T KNOW WHO WE'RE WAITING FOR
	SLEEP	T1,		;AND ANOTHER MINUTE FOR GOOD MEASURE
	POPJ	P,		;ERROR RETURN
KILC:	IMULI	T1,^D10000	;NUMBER OF JOBS TIMES 10 SEC EACH
	ADDI	T1,^D60000	;PLUS 60 SEC
	MSTIME	C,		;CURRENT TIME
	ADD	C,T1		;TIME TO GIVE UP TRYING TO STOP JOBS
KILOOP:	MOVEI	T1,^D15		;FIRST SLEEP FOR 15 SEC
	SLEEP	T1,		;TO GIVE JOBS TIME TO EXIT
	SETZ	T4,		;COUNT OF JOBS FOUND
	MOVE	B,HIGHJB	;GET NUMBER OF JOBS ON SYSTEM
KILTST:	PUSHJ	P,BITMSK	;GET MASK AND ADDRESS IN BIT TABLE
	TDNN	T2,BITABL(T1)	;WAS THIS JOB LOGGED IN BY ME?
	JRST	KILE		;NO
	AOJ	T4,		;COUNT A JOB FOUND
	HRLZ	T3,B		;JOB NUMBER,,TABLE 0
	GETTAB	T3,		;GET JOBS STATUS WORD
	JRST	KILD		;HE'S GONE
	TLNN	T3,40004	;IS THIS JOB LOGGED IN?
	JRST	KILD		;NO, DELETE HIM FROM TABLE
	JUMPN	A,KILE		;IF KILL OPTION HE MUST ACTUALLY BE GONE
	HRLZ	T3,B		;JOB NUMBER IN LEFT HALF
	HRRI	T3,3		;3 IN RIGHT HALF
	GETTAB	T3,		;TO GET PROGRAM NAME
	JRST	KILD		;JOB DISAPPEARED
	HLRZ	T3,T3		;LOOK AT LEFT HALF OF JOB NAME
	CAIE	T3,'END'	;DID HE CHANGE HIS NAME TO ENDXXX?
	JRST	KILE		;NO, KEEP WAITING
KILD:	ANDCAM	T2,BITABL(T1)	;CLEAR TABLE ENTRY IF JOB HAS EXITED GRACEFULLY
	SOJ	T4,		;DISCOUNT THE JOB THAT WAS FOUND
KILE:	SOJG	B,KILTST	;TRY ALL JOBS
	JUMPLE	T4,CPOPJ1	;RETURN IF ALL JOBS STOPPED
	MSTIME	T1,		;GET TIME
	CAMGE	T1,C		;TIME LIMIT EXCEEDED?
	JRST	KILOOP		;NO, TRY AGAIN
	POPJ	P,		;GIVE UP
;ABCHK	- ABANDON TEST IF INPUT IS FROM DISK


ABCHK:	SKIPE	INPIND		;IS INPUT FROM DISK
	JRST	ABEND		;YES
	;PJRST	FLUSH		;OTHERWISE FLUSH THE REST OF THE LINE

FLUSH:	JUMPE	CH,CPOPJ	;RETURN IF CR OR ALT
	PUSHJ	P,GETCHR	;GET ANOTHER CHARACTER
	JRST	FLUSH		;LOOP UNTIL BREAK CHAR


ABEND:	OUTSTR	[ASCIZ/SIMULATION TERMINATED.
/]
	EXIT
	SUBTTL	MAIN SUBROUTINES


;DOLOG	- LOG IN A JOB ON A PTY


DOLOG:	PUSHJ	P,INTPTY	;INIT A PTY
	MOVEI	T1,LOGMSG	;START OF LOGIN MESSAGE
	PUSHJ	P,PTYSTR	;OUTPUT IT
	PUSHJ	P,PTYPPN	;OUTPUT PPN TO PTY
	MOVEI	T1,LOGTXT	;REMAINDER OF LOGIN MESSAGE
	PUSHJ	P,PTYMSG	;FORCE OUTPUT
	PUSHJ	P,CHKLOG	;SEE IF LOGGED IN
	JRST	LOGERR		;TIME LIMIT EXCEEDED
	MOVE	B,CURJOB	;JOB NUMBER CURRENTLY ON PTY
	PUSHJ	P,BITSET	;LIGHT THE BIT IN THE JOB TABLE
	AOS	NJOBS		;BUMP COUNT OF JOBS LOGGED IN
	POPJ	P,		;RETURN

LOGERR:	OUTSTR	[ASCIZ/? TIME LIMIT EXCEEDED LOGGING IN JOB UNDER PPN /]
	PUSHJ	P,TTYPPN	;OUTPUT PPN
	OUTSTR	[BYTE (7)".",15,12] ;OUTPUT CRLF
	POPJ	P,		;RETURN

PTYPPN:	SKIPA	T3,[PTYCHR]	;PRINT TO PTY
TTYPPN:	MOVEI	T3,TTYCHR	;PRINT TO TTY
	MOVE	T1,CURPRJ	;PROJ #
	PUSHJ	P,PRIOCT	;OUTPUT IN OCTAL
	MOVEI	T2,","		;COMMA
	PUSHJ	P,(T3)		;OUTPUT A CHAR
	MOVE	T1,CURPRG	;PROG #
	PJRST	PRIOCT		;OUTPUT OCTAL NUMBER
;DORUN	- CAUSE THE JOB ON THE PTY TO RUN THE PROGRAM SPECIFIED BY INDEX C


DORUN:	MOVEI	T1,[ASCIZ/RUN TST:/]
	PUSHJ	P,PTYSTR	;SEND RUN COMMAND
	MOVE	T1,PRGNAM(C)	;ADDRESS OF JOB NAME
	PUSHJ	P,PTYSTR	;OUTPUT ASCII JOB NAME
	MOVEI	T1,AREA		;AREA TO RUN FROM
	PUSHJ	P,PTYMSG	;FORCE OUT THE MESSAGE
	PUSHJ	P,CHKRUN	;CHECK IF RUNNING
	JRST	RUNERR		;TIME LIMIT EXCEEDED
RUNOK:	MOVEI	T1,1		;SLEEP A SECOND
	SLEEP	T1,		;DO SLEEP
	INPUT	PTY,		;INPUT ANY STUFF
	RELEAS	PTY,		;RELEASE PTY AND DETACH JOB
	POPJ	P,		;RETURN

RUNERR:	OUTSTR	[ASCIZ/? TIME LIMIT EXCEEDED TRYING TO RUN /]
	OUTSTR	@PRGNAM(C)	;OUTPUT THE PROGRAM NAME
	OUTSTR	[ASCIZ/ UNDER PPN /]
	PUSHJ	P,TTYPPN	;OUTPUT PPN TO TTY
	OUTSTR	[BYTE (7)".",15,12] ;OUTPUT CRLF
	JRST	RUNOK		;THEN IGNORE ERROR AND CONTINUE
;CHKLOG	- MAKE SURE JOB IS LOGGED IN AND AT MONITOR LEVEL (SKIP RETURN IF OK)
;CHKRUN	- MAKE SURE JOB IS LOGGED IN AND RUNNING (SKIP RETURN IF OK)
;CHKJOB	- MAKE SURE JOB IS LOGGED OUT (SKIP RETURN IF OK)


CHKJOB:	MOVEI	A,120000	;STATUS BITS FOR LOGGED OUT
	JRST	CHKALL		;GO CHECK
CHKRUN:	SKIPA	A,[600000]	;STATUS BITS FOR RUN
CHKLOG:	MOVEI	A,720000	;STATUS BITS FOR LOGGED IN AND MONITOR LEVEL
CHKALL:	MSTIME	T1,		;TIME IN MILLISEC
	ADDI	T1,^D60000	;PLUS 60 SEC
	MOVEM	T1,PTYLIM	;TIME LIMIT FOR RESPONSE FROM PTY
GETOUT:	MOVEI	T1,PTY		;CHECK PTY
	JOBSTS	T1,		;JOB STATUS
	JRST	STSERR		;NO JOBSTS UUO
	TLZ	T1,7777		;CLEAR ANY UNDEFINED BITS
				;(MIGHT GET ADDED IN FUTURE MONITORS)
	HRRZM	T1,CURJOB
	TLNN	T1,(1B3)	;OUTPUT READY?
	JRST	NOOUT		;NO
	INPUT	PTY,		;YES, GET IT
	SKIPN	IBUF+2		;ANY CHARACTERS IN BUFFER?
	JRST	GETOUT		;NO
	ILDB	T1,IBUF+1	;GET FIRST CHAR FROM TEXT
	CAIN	T1,"?"		;IS IT PART OF AN ERROR MESSAGE?
	OUTSTR	@IBUF+1		;IF SO LET OPERATOR SEE THE ACTUAL MESSAGE
	JRST	GETOUT		;WAIT FOR MORE PTY ACTIVITY

NOOUT:	HLRZ	T1,T1		;GET LEFT HALF OF STATUS
	CAIN	T1,(A)		;IS IT IN THE STATE WE DESIRE?
	JRST	CPOPJ1		;YES, GIVE SUCCESSFUL RETURN
	MSTIME	T2,		;NOT READY YET
	MOVE	T1,PTYLIM	;GET TIME LIMIT
	SUB	T1,T2		;MINUS CURRENT TIME
	JUMPLE	T1,CPOPJ	;ERROR RETURN IF LIMIT EXCEEDED
	CAILE	T1,^D60000	;GREATER THAN MAX SLEEP TIME?
	MOVEI	T1,^D1000	;CHECK STATUS ONCE A SECOND
	TLO	T1,(1B12)	;WAKE ON PTY ACTIVITY
	MOVEI	T2,1		;1 SECOND
	HIBER	T1,		;HIBER UNTIL PTY ACTIVE OR LIMIT EXCEEDED
	SLEEP	T2,		;SLEEP 1 SEC IF HIBER NOT IMPLEMENTED
	JRST	GETOUT		;GO CHECK AGAIN

STSERR:	OUTSTR	[ASCIZ/? JOBSTS UUO FAILED.
/]
	JRST	ABEND		;TERMINATE RUN
;DOSYS	- ROUTINE TO DO A SYSTAT


DOSYS:	SKIPN	SYSFLG		;IS SYSTAT JOB LOGGED IN YET?
	PUSHJ	P,LOGSYS	;NO, LOG IT IN
	OUTSTR	[BYTE (7)7,"*",7]
	MOVEI	T1,[ASCIZ *SYS/L
*]
	PUSHJ	P,PTYMSG	;SEND SYS/L OVER PTY
	MOVEI	T1,^D10		;SLEEP FOR 10 SEC
	SLEEP	T1,		;TO ALLOW SYSTAT TO COME OUT
	PUSHJ	P,CHKLOG	;WAIT TIL WE GET THE DOT BACK
	JFCL			;IGNORE ERROR RETURN
	POPJ	P,		;RETURN
;GETSPC	- READ A FILE SPEC FROM TTY AND MAKE DEFAULT ASSUMPTIONS


GETSPC:	SETZM	OPENBL		;CLEAR OPEN AND LOOKUP AREAS
	MOVE	T1,[OPENBL,,OPENBL+1]
	BLT	T1,LOOKBL+3	;ZERO THRU LOOKUP AREA
	MOVEI	T1,DSKBUF	;DSK BUFFER HEADER
	MOVEM	T1,OPENBL+2	;SET UP IN OPEN BLOCK

GETSPL:	PUSHJ	P,GATOM		;READ AN ATOM
	CAIN	CH,COLON	;COLON?
	JRST	GETSPD		;GET DEVICE
	JUMPE	T4,GETSPT	;NO NAME SPECIFIED
	SKIPE	LOOKBL		;FILE NAME SEEN YET?
	JRST	GETSPR		;YES, ERROR
	MOVEM	T4,LOOKBL	;NO, STORE FILE NAME
GETSPT:	JUMPE	CH,GETSPX	;END OF LINE
	CAIN	CH,"."		;PERIOD?
	JRST	GETSPE		;YES, GET EXTENSION
	CAIN	CH," "		;SPACE?
	JRST	GETSPL		;GET MORE
	CAIN	CH,"["		;LEFT BRACKET?
	JRST	GETSPP		;GET PPN
GETSPR:	OUTSTR	[ASCIZ/? ILLEGAL FILE SPEC.
/]
	JRST	ABEND		;BOMB AND MAKE HIM RERUN THE PROGRAM

GETSPD:	SKIPE	OPENBL+1	;SEEN DEVICE YET?
	JRST	GETSPR		;YES
	MOVEM	T4,OPENBL+1	;STORE DEVICE NAME
	JRST	GETSPL		;LOOP FOR MORE
GETSPE:		P,GATOM		;READ EXTENSION
	SKIPE	LOOKBL+1	;SEEN EXTENSION YET?
	JRST	GETSPR		;YES
	HLLZM	T4,LOOKBL+1	;STORE EXTENSION
	JRST	GETSPT		;CHECK FOR MORE

GETSPP:	SKIPE	LOOKBL+3	;SEEN PPN YET?
	JRST	GETSPR		;YES
	PUSHJ	P,GETOCT	;READ OCTAL PROJECT
	CAIE	CH,","		;DELIMITER MUST BE COMMA
	JRST	GETSPR		;ERROR
	HRLZM	T4,LOOKBL+3	;STORE PROJECT
	PUSHJ	P,GETOCT	;READ PROGRAMMER NUMBER
	HRRM	T4,LOOKBL+3	;STORE IT
	JUMPE	CH,GETSPX	;CARRIAGE RETURN IS LEGAL HERE
	CAIN	CH,"]"		;ONLY OTHER LEGAL CHAR IS RIGHT BRACKET
	JRST	GETSPL		;OK, GET NEXT ATOM
	JRST	GETSPR		;BAD DELIMITER

GETSPX:	SKIPN	T1,OPENBL+1	;ANY DEVICE SPECIFIED?
	JRST	GETSPY		;NO
	CAMN	T1,['TTY   ']	;YES, IS IT TTY?
	SETZM	OPENBL+1	;YES, CLEAR DEVICE
	POPJ	P,		;AND RETURN
GETSPY:	MOVSI	T1,'DSK'	;SIXBIT DSK
	SKIPE	LOOKBL		;FILE NAME SPECIFIED?
	MOVEM	T1,OPENBL+1	;YES, MUST BE DSK
	POPJ	P,		;RETURN
	SUBTTL	UTILITY SUBROUTINES


;GATOM	- READ A SIXBIT ATOM (WORD IN T4, MASK IN T5, TERMINAL CHAR IN T1)
;GETDEC	- READ DECIMAL (NUMBER IN T4, TERMINAL CHAR IN T1)
;GETOCT	- READ OCTAL (NUMBER IN T4, TERMINAL CHAR IN T1)


GATOM:	MOVEI	T5,1		;ONE IS FLAG FOR SIXBIT
	MOVE	T3,[POINT 6,T4]	;BYTE POINTER FOR BUILDING SIXBIT
	PJRST	GETNUM		;GO READ IT

GETDEC:	TDZA	T5,T5		;ZERO IS FLAG FOR DECIMAL
GETOCT:	MOVNI	T5,2		;MINUS TWO IS FLAG FOR OCTAL
GETNUM:	SETZ	T4,		;RESULT GOES INTO T4
	MOVEI	T2,6		;MAXIMUM OF SIX CHARS

GATOMA:	PUSHJ	P,GETCHR	;READ A CHAR
	JUMPE	CH,GATOMX	;DONE IF BREAK CHAR
	CAIN	CH," "		;SPACE?
	CAIE	T2,6		;AND NO CHARS SEEN YET?
	SKIPA			;NO
	JRST	GATOMA		;IGNORE LEADING SPACE
	CAIG	CH,"9"(T5)	;GREATER THAN 9 (7 FOR OCTAL)?
	CAIGE	CH,"0"		;OR LESS THAN 0?
	JRST	GATOMB		;YES, CANNOT BE A NUMBER
	SOJL	T2,GATOMA	;IGNORE ANY CHARS AFTER THE 6TH
	JUMPG	T5,GATOMC	;GO PROCESS SIXBIT IF ENTRY WAS GATOM
	IMULI	T4,^D10(T5)	;MULTIPLY BY 10 (8 FOR OCTAL)
	ADDI	T4,-"0"(CH)	;ADD IN NEW DIGIT
	JRST	GATOMA		;READ NEXT CHAR

GATOMB:	JUMPLE	T5,GATOMX	;ALL DONE IF DECIMAL OR OCTAL
	CAIG	CH,"Z"		;ALPHABETIC?
	CAIGE	CH,"A"		;(A THRU Z)
	JRST	GATOMX		;NOT ALPHA, MUST BE DELIMITER
	SOJL	T2,GATOMA	;IGNORE CHARS AFTER THE 6TH
GATOMC:	MOVEI	T1,-40(CH)	;CONVERT TO SIXBIT
	IDPB	T1,T3		;DEPOSIT INTO T4
	JRST	GATOMA		;READ ANOTHER CHAR

GATOMS:	PUSHJ	P,GETCHR	;READ ANOTHER CHAR UNTIL WE HIT NON-SPACE
GATOMX:	CAIN	CH," "		;IS DELIMITER A SPACE?
	JRST	GATOMS		;YES, IGNORE TRAILING SPACES
	JUMPLE	T5,CPOPJ	;ALL DONE IF OCTAL OR DECIMAL
	SETO	T5,		;SET UP TO BUILD MASK
	SKIPLE	T2		;SKIP IF ALL SIX CHARS SEEN
	LSH	T5,6		;SHIFT IN SIX ZERO BITS
	SOJG	T2,.-1		;LOOP UNTIL ALL SIX CHARS ACCOUNTED FOR
	POPJ	P,		;NOW RETURN
;MATCH	- ROUTINE TO FIND MATCH BETWEEN SIXBIT WORD IN T4
;	  AND TABLE POINTED TO BY T1. MASK IS IN T5.


MATCH:	HRRZ	T2,T1		;PRESET RESULT TO ZERO,,TABLE ADDR FOR NOMATCH
MATCHL:	MOVE	T3,(T1)		;GET NEXT WORD TO COMPARE WITH
	XOR	T3,T4		;SEE WHICH BITS MATCH
	TDNE	T3,T5		;CHECK MASKED BITS
	JRST	MATCHC		;NOT A MATCH
	JUMPGE	T2,MATCHB	;FIRST MATCH
	HRRZS	T2		;MORE THAN ONE MATCH FOUND
	POPJ	P,		;RETURN
MATCHB:	MOVE	T2,T1		;SAVE THE INDEX OF THE MATCH
MATCHC:	AOBJP	T1,.+1		;BUMP COUNTER PAST SECOND TABLE ENTRY
	AOBJN	T1,MATCHL	;LOOK THRU THE REST OF THE TABLE
	POPJ	P,		;RETURN




;BITMSK	- GENERATE A BIT MASK AND OFFSET INTO BIT TABLE OF JOBS LOGGED IN
;	  (JOB NUMBER IN B, MASK IN T2, OFFSET IN T1)


BITMSK:	MOVE	T1,B		;PUT JOB NUMBER IN T1
	IDIVI	T1,^D31		;MODULO 31
	HRLI	T2,400000	;SET UP BIT 0
	LSH	T2,-^D35(T2)	;SHIFT INTO PROPER POSITION AND CLEAR REMAINDER
	POPJ	P,		;RETURN

BITSET:	PUSHJ	P,BITMSK	;GET MASK
	IORM	T2,BITABL(T1)	;SET THE PROPER BIT
	POPJ	P,		;RETURN
;GETCHR	- READ A CHARACTER FROM TTY OR DISK, RETURN IN T1


	COLON=="/"		;CODE FOR A COLON
	SLASH==":"		;CODE FOR A SLASH
	COLASH==SLASH^!COLON	;MASK FOR INTERCHANGING SLASH AND COLON

GETCHR:	SKIPE	INPIND		;DISK OR TTY?
	JRST	CHRDSK		;DISK
	INCHWL	CH		;READ FROM TTY
	JUMPE	CH,.-1		;SHOULD NEVER HAPPEN

GETTST:	CAIN	CH,15		;CARRIAGE RETURN?
	JRST	GETCHR		;IGNORE IT
	CAIN	CH,12		;LINE FEED?
	JRST	CONLF		;CONVERT LINE FEED TO ZERO
	CAIE	CH,14		;FORM FEED?
	CAIN	CH,33		;OR ATLMODE?
	JRST	CONALT		;CONVERT TO LINE FEED
	CAIN	CH,11		;TAB?
	MOVEI	CH," "		;CONVERT TO SPACE
	CAIE	CH,"/"		;INTERCHANGE CODES FOR SLASH
	CAIN	CH,":"		;AND COLON
	TRC	CH,COLASH	;BY CHANGING DIFFERENCE BITS
	CAIG	CH,"z"		;LOWER CASE Z
	CAIGE	CH,"a"		;LOWER CASE A
	POPJ	P,		;NOT LOWER CASE
	SUBI	CH,40		;CONVERT LOWER CASE TO UPPER CASE
	POPJ	P,		;RETURN

CONALT:	OUTSTR	[BYTE (7)15,12]	;ECHO CRLF
CONLF:	MOVEI	CH,0		;ZERO FOR BREAK CHAR
	POPJ	P,		;RETURN
;CHRDSK	- READ A CHARACTER FROM DISK


CHRDSK:	SOSG	DSKBUF+2	;ANY CHARS LEFT?
	PUSHJ	P,INDSK		;NO, GET ANOTHER BUFFER
	ILDB	CH,DSKBUF+1	;GET NEXT CHAR
	JUMPE	CH,CHRDSK	;IGNORE NULL CHAR
	OUTCHR	CH		;ECHO CHAR ON TTY
	JRST	GETTST		;RETURN TO PROCESS CHARACTER

INDSK:	IN	DSK,		;INPUT A BUFFER
	POPJ	P,		;NO ERRORS
	OUTSTR	[ASCIZ/? INPUT ERROR ON CONTROL FILE.
/]
	JRST	ABEND		;TAKE ABNORMAL EXIT




;INTPTY	- INIT A PTY


INTPTY:	MOVEI	T1,PTY		;PTY CHANNEL
	RESDV.	T1,		;RESET THE CHANNEL
	JFCL			;IGNORE ERROR
	OPEN	PTY,PTYBLK	;OPEN PTY CHANNEL
	JRST	PTYERR		;INIT FAILURE
	INBUF	PTY,1		;ONE INPUT BUFFER
	OUTBUF	PTY,1		;ONE OUTPUT BUFFER
	POPJ	P,		;RETURN
PTYERR:	OUTSTR	[ASCIZ/? OPEN FAILURE ON PTY.
/]
	JRST	ABEND		;TERMINATE RUN
;PTYSTR	- OUTPUT ASCII TEXT TO PTY (ADDRESS IN T1)
;PTYMSG	- SAME AS PTYSTR BUT ALSO FORCES AN OUTPUT
;PTYCHR	- OUTPUT CHAR IN T2 TO PTY


PTYMSG:	PUSHJ	P,PTYSTR	;OUTPUT TEXT TO PTY
	OUTPUT	PTY,		;DO THE OUTPUT
	POPJ	P,		;RETURN


PTYSTR:	HRLI	T1,(POINT 7,0)		;SET UP BYTE POINTER
PTYBYT:	ILDB	T2,T1		;GET A CHAR
	JUMPE	T2,CPOPJ	;RETURN ON NULL CHAR
	PUSHJ	P,PTYCHR	;OUTPUT IT
	JRST	PTYBYT		;GET NEXT CHAR


PTYCHR:	PUSHJ	P,PTYCHK	;SEE IF ROOM FOR NEXT CHAR
	IDPB	T2,OBUF+1	;STASH CHAR
	POPJ	P,		;RETURN

PTYCHK:	SOSG	OBUF+2		;ANY ROOM?
	OUTPUT	PTY,		;NO, DUMP A BUFFER
	POPJ	P,		;RETURN




;PRIOCT	- OUTPUT OCTAL NUMBER IN T1 TO EITHER PTY OR TTY (ADDR IN T3)


PRIOCT:	IDIVI	T1,10		;CONVERT TO OCTAL
	HRLM	T2,(P)		;STORE FOR LATER
	SKIPE	T1		;ALL DONE?
	PUSHJ	P,PRIOCT	;NO
	HLRZ	T2,(P)		;GET LAST DIGIT
	ADDI	T2,"0"		;IN ASCII
	PJRST	(T3)		;BRANCH TO CHARACTER OUTPUT ROUTINE

TTYCHR:	OUTCHR	T2		;OUTPUT A CHAR TO TTY
	POPJ	P,		;RETURN



;PRDEC2 - PRINT A 2 DIGIT DECIMAL NUMBER IN T1


PRDEC2:	IDIVI	T1,^D10		;GET 2 DIGITS
PRDEC:	ADDI	T1,"0"		;CHANGE TO CHARACTER
	OUTCHR	T1		;OUTPUT IT
	ADDI	T2,"0"		;SAME WITH UNITS DIGIT
	OUTCHR	T2		;PRINT IT
	POPJ	P,		;RETURN



;DAYTIM - OUTPUT TIME OF DAY


DAYTIM:	OUTSTR	[ASCIZ/[/]
	MSTIME	T1,		;GET CURRENT TIME
	IDIVI	T1,^D1000	;IN SECONDS
	IDIVI	T1,^D3600	;GET HOURS
	IDIVI	T2,^D60		;GET MINS AND SECS
	PUSH	P,T2		;SAVE MINS
	IDIVI	T1,^D10		;GET TENS AND UNITS
	SKIPN	T1		;LEADING ZERO?
	MOVEI	T1,<" ">-<"0">	;CHANGE TO SPACE
	PUSHJ	P,PRDEC		;PRINT HOURS
	OUTSTR	[ASCIZ/:/]	;DELIMITER
	POP	P,T1		;GET BACK MINS
	PUSHJ	P,PRDEC2	;PRINT 2 DIGIT DECIMAL
	OUTSTR	[ASCIZ/:/]	;DELIMITER
	MOVE	T1,T3		;GET SECS
	PUSHJ	P,PRDEC2	;PRINT IT
	OUTSTR	[ASCIZ/] /]	;END BRACKET
	POPJ	P,		;RETURN
;DATA BASE


;INSTALATION DEPENDENT DATA


AREA:	ASCIZ/
/				;AREA PROGRAMS ARE STORED UNDER

PRGNAM:	[ASCIZ/LODIO/]		;PROGRAM NAMES
	[ASCIZ/LODCPU/]
	[ASCIZ/LODAVE/]
	[ASCIZ/LODPQ1/]
	[ASCIZ/LODSLP/]
	[ASCIZ/LODCOR/]
	[ASCIZ/LODOPN/]
NUMCLS==.-PRGNAM


;PARAMETERS


INPIND:	BLOCK	1		;0 IF INPUT FROM TTY, -1 IF FROM DISK
JOBOPT:	BLOCK	1		;OPTION, 0=CATEGORY, -1=MODULO
SYSTIM:	BLOCK	1		;TIME BETWEEN SYSTATS
NEXTIM:	BLOCK	1		;TIME OF NEXT SYSTAT
TESTIM:	BLOCK	1		;LENGTH OF TEST/TIME TO STOP TEST
MODNUM:	BLOCK	1		;MODULO NUMBER FOR MOD OPTION
CLASS:	BLOCK	1		;JOB COUNT FOR MODULO
BASPRJ:	BLOCK	1		;BASE PROJECT
BASPRG:	BLOCK	1		;BASE PROGRAMMER
CURPRJ:	BLOCK	1		;CURRENT PROJECT
CURPRG:	BLOCK	1		;CURRENT PROGRAMMER
CURJOB:	BLOCK	1	;JOB NUMBER OF JOB ON PTY
PTYLIM:	BLOCK	1		;TIME TO WAIT FOR PTY
SYSFLG:	BLOCK	1		;-1 WHEN SYSTAT JOB GETS LOGGED IN
KILLSW:	KILL			;SWITCH SET TO NON-ZERO TO KILL JOBS AT NORMAL EXIT
NJOBS:	BLOCK	1		;NUMBER OF JOBS LOGGED IN ON PTYS
HIGHJB:	BLOCK	1		;HIGHEST JOB NUMBER LOGGED IN WHEN WAKING JOBS


;DATA BLOCKS


PDL:	BLOCK	20		;PUSHDOWN LIST
PDP:	IOWD	20,PDL		;INITIAL PUSHDOWN POINTER
DSKBUF:	BLOCK	3		;DISK INPUT BUFFER HEADER
IBUF:	BLOCK	3		;PTY INPUT BUFFER HEADER
OBUF:	BLOCK	3		;PTY OUTPUT BUFFER HEADER
PTYBLK:	0			;PTY OPEN BLOCK
	'PTY   '
	OBUF,,IBUF
OPENBL:	BLOCK	3		;DISK OPEN BLOCK
LOOKBL:	BLOCK	4		;DISK LOOKUP BLOCK (MUST FOLLOW OPENBL)
BITABL:	BLOCK	21		;BIT TABLE FOR UP TO 512 JOBS
LOGMSG:	ASCIZ/LOG /		;START OF LOGIN MESSAGE
LOGTXT:	ASCIZ */NOOPTION/NOTICE:NEVER
*				;REST OF LOGIN MESSAGE



	END	LODTST
  ^i.¥