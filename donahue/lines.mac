	TITLE	LINES - W.M.U.
	SUBTTL	TAKE SYSTEM DATA ON A MINUTELY BASIS
	SALL

;ASSEMBLY PARAMETERS

FTSCHED==1		;1 IFF SCHEDULER STATISTICS ARE DESIRED
IFNDEF	FTSCHED,<FTSCHED==0>

;ACCUMULATORS

MV=0		;MONVER
GI=1		;ADDRESS OF GETTAB IMMEDIATE TABLE
A=2
B=3
C=4
D=5
E=6
G=7
H=10
I=11
T1=12
T2=13
T3=14
T4=15
N=15
Q=16
P=17

;OTHER FIXED VALUE SYMBOLS

DSK==1
PTY==2
SPYSEG==400000

;OPDEFS

	OPDEF	PJRST	[JRST]

;MACROS

DEFINE	TYPE	(STRING)
<	OUTSTR	[ASCIZ /STRING/]>

DEFINE	ERROR	(STRING)
<	JSP	T1,FATAL
	JFCL	[ASCIZ/ ? STRING - LINES STOPPED/]
>

;GETTAB CONSTANT DEFINITIONS

	DEFINE	T.(TABLE,VALUE)
<	TABLE==VALUE>
	DEFINE	I.(ITEM,VALUE)
<	ITEM==SPYSEG+VALUE>

T.(.GTSTS,0)

T.(.GTPPN,2)

T.(.GTTTY,10)

T.(.GTCNF,11)
	I.(%CNTIM,10)
	I.(%CNDAT,11)
	I.(%CNSJN,15)
	I.(%CNFRE,23)
	I.(%CNTTC,30)
	I.(%CNTTN,31)
	I.(%CNVER,34)
	I.(%CNDTM,53)

T.(.GTNSW,12)
	I.(%NSCMX,10)
	I.(%NSNXM,34)

T.(.GTLVD,16)
	I.(%LDUNI,7)
	I.(%LDSWP,10)

T.(.GTLIM,40)

T.(.GTC0V,56)
	I.(%CVUPT,5)
	I.(%CVNUL,37)
	I.(%CVOHT,42)

T.(.GTSST,115)
	I.(%SSSCD,22)

T.(.GTCRT,123)

T.(.GTPAR,142)
;VERSION
	VMAJOR==5
	VMINOR==0
	VEDIT==24
	VWHO==0

	LOC	137
	BYTE	(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT
	RELOC

;MAIN CONTROL LOOP

LINES:	RESET
	JSP	P,INITIA	;INITIALIZE
MAINLP:	PUSHJ	P,SNOOZE	;SLEEP FOR A WHILE
	PUSHJ	P,JOBS		;NUMBER OF JOBS AND LINES IN USE
	PUSHJ	P,CPUITL	;CPU UTILIZATION
	PUSHJ	P,DISK		;DISK PERFORMANCE
	PUSHJ	P,SWAPER	;SWAPPER INFO
	PUSHJ	P,CBUSED	;AMOUNT OF CORE BLOCKS USED
	PUSHJ	P,TTYUSD	;AMOUNT OF TTY CHUNKS USED
IFN	FTSCHED,<
	PUSHJ	P,GETPAR	;GET SCHEDULER PARAMETERS AND STATISTICS
	PUSHJ	P,GETCLS	;GET CLASS RUNTIMES
>
	PUSHJ	P,DMPMIN	;DUMP DATA FOR THIS MINUTE
	JRST	MAINLP		;LOOP
;INITIALIZATION CODE

INITIA:	SETZM	DBASE
	MOVE	Q,[DBASE,,DBASE+1]
	BLT	Q,DBEND-1
	MOVEM	P,PDL
	MOVE	P,[IOWD 27,PDL+1]
	MOVE	Q,[12,,11]
	GETTAB	Q,
	ERROR	(LNSGTB GETTAB 11 ERROR)
	SUBI	Q,1
	SPY	Q,
	ERROR	(LNSSPY SPY ERROR)
	MOVE	GI,[23,,23]	;ADDRESS OF GETTAB IMMEDIATE TABLE
	GETTAB	GI,
	ERROR	(LNSGTB GETTAB 23 ERROR)
	ADDI	GI,SPYSEG	;GET OUR ADDRESS
	MOVEM	GI,GETTBI	;SAVE IT
	MOVE	Q,.GTCNF(GI)	;ADDRESS OF CONFIG TABLE
	HRRZ	MV,%CNVER(Q)	;GET MONVER
	MOVEM	MV,MONVER
	POPJ	P,

;SLEEP TO BEGINNING OF NEXT MINUTE

SNOOZE:	MOVE	Q,.GTCNF(GI)	;ADDRESS OF CONFIG TABLE
	MOVE	A,%CNTIM(Q)	;GET TIME IN JIFFIES
	IDIVI	A,^D60*^D60
	ADDI	B,^D30
	IDIVI	B,^D60		;GET SECONDS ELAPSED IN THIS MINUTE
	MOVEI	A,^D75
	SUB	A,B		;TIME TO GO
	SLEEP	A,		;WAIT IT OUT
	MOVE	A,%CNDAT(Q)	;GET 15 BIT DATE
	MOVEM	A,THSDAT	;SAVE IT
	MOVE	A,%CNTIM(Q)
	IDIVI	A,^D60*^D60*^D60 ;GET THE HOUR
	MOVEM	A,HOUR
	IDIVI	B,^D60*^D60
	MOVEM	B,MINUTE	;SAVE THE MINUTE
	POPJ	P,
;COUNT NUMBER OF JOBS AND LINES ACTIVE

JB.LBT==1B10			;BATCH JOB BIT

JOBS:	SKIPE	A,JOBAOB	;FIRST TIME THROUGH?
	JRST	JOBS1		;NO
	MOVE	Q,.GTCNF(GI)	;ADDRESS OF CONFIG TABLE
	MOVN	A,%CNSJN(Q)	;GET -SEGN,,+JOBN
	MOVSI	A,(A)
	ADD	A,[1,,SPYSEG+1]	;MAKE AOBJN WORD
	MOVEM	A,JOBAOB
	MOVE	T1,.GTSTS(GI)	;ADDRESS OF JOB STATUS TABLE
	HRRM	T1,MOVSTS	;MODIFY INSTRUCTION
	MOVE	T1,.GTPPN(GI)	;ADDRESS OF PPN TABLE
	HRRM	T1,MOVPPN	;MODIFY INSTRUCTION
	MOVE	T1,.GTTTY(GI)	;ADDRESS OF JOB TO TERMINAL TABLE
	HRRM	T1,MOVTTY	;MODIFY INSTRUCTION
	MOVE	T1,.GTLIM(GI)	;ADDRESS OF BATCH PARAMETERS TABLE
	HRRM	T1,MOVLIM	;MODIFY INSTRUCTION
JOBS1:	SETZM	LNCNT
	SETZM	JBCNT
MOVSTS:	MOVE	T1,.GTSTS(A)	;GET JOB STATUS
	TLNN	T1,(1B3)	;JOB ASSIGNED?
	JRST	JOBS4		;NO
	AOS	JBCNT		;COUNT THE JOB
	TLNN	T1,(1B15)	;LOGGED IN?
	JRST	JOBS4		;NO
	HRLOI	T1,1
MOVPPN:	CAML	T1,.GTPPN(A)	;SYSTEMS NUMBER?
	JRST	JOBS4		;YES
MOVTTY:	SKIPN	T1,.GTTTY(A)	;TTY DDB FOR JOB?
	JRST	JOBS4		;NO
	MOVE	T2,SPYSEG(T1)	;GET TTY NAME
	TLNN	T2,-1		;ATTACHED?
	JRST	JOBS4		;NO
MOVLIM:	MOVE	T1,.GTLIM(A)	;GET BATCH PARAMETERS
	TLNN	T1,(JB.LBT)	;BATCH JOB
	AOS	LNCNT		;NO, COUNT THE LINE
JOBS4:	AOBJN	A,MOVSTS
	POPJ	P,
;COMPUTE PERCENTAGE OF USED CORE BLOCKS

CBUSED:	MOVE	Q,.GTCNF(GI)	;ADDRESS OF CONFIG TABLE
	MOVE	A,%CNFRE(Q)	;FREPTR AOBJN WORD
	HLRO	B,A
	MOVM	B,B
	IMULI	B,^D36
	MOVEM	B,TOTBIT	;TOTAL 4-WORD CORE BLOCKS
	SETZ	N,
WRDLP:	SKIPN	B,SPYSEG(A)	;GET FIRST WORD
	JRST	FREWRD		;THIS WORD IS EMPTY?
	TLZE	B,400000	;SIGN BIT ON?
	AOJ	N,		;YES
BITLP:	MOVN	C,B		;GET 2'S COMPLEMENT
	TDZE	B,C		;ANY ONES LEFT?
	AOJA	N,BITLP		;YES
FREWRD:	AOBJN	A,WRDLP
	IMULI	N,^D100
	IDIVM	N,TOTBIT	;THIS % IS USED
	POPJ	P,

;COMPUTE PERCENTAGE OF USED TELETYPE BUFFER AREA

TTYUSD:	MOVE	Q,.GTCNF(GI)	;ADDRESS OF CONFIG TABLE
	HLRZ	A,%CNTTC(Q)	;TOTAL TTY CHUNKS
	MOVE	B,%CNTTN(Q)	;CHUNKS FREE
	SUBM	A,B		;GET NO USED
	IMULI	B,^D100
	IDIV	B,A		;PERCENTAGE USED
	MOVEM	B,USDCNK
	POPJ	P,

;CPU DATA

CPUITL:	MOVE	Q,.GTC0V(GI)	;ADDRESS OF CPU0 CDB
	MOVE	A,%CVUPT(Q)	;UPTIME
	MOVEM	A,D		;SAVE UPTIME
	MOVE	B,%CVNUL(Q)	;GET NULL TIME
	MOVEM	B,E		;SAVE NULL TIME
	IMULI	B,^D100
	IDIV	B,A		;GET TOTAL NULL TIME
	MOVEM	B,TOTNUL
	SUB	D,OLDUP		;GET ELAPSED UPTIME
	ADDM	D,OLDUP		;UPDATE IT
	SUB	E,OLDNUL	;GET ELAPSED NULL TIME
	ADDM	E,OLDNUL	;UPDATE IT
	IMULI	E,^D100
	IDIV	E,D
	MOVEM	E,MINNUL	;PERCENT OF NULL TIME FOR LAST MINUTE
	MOVE	A,%CVOHT(Q)	;GET MONITOR OVERHEAD
	SUB	A,OLDOVH
	ADDM	A,OLDOVH	;UPDATE OLD OVERHEAD
	IMULI	A,^D100
	IDIV	A,D
	MOVEM	A,MINOVH	;MONITOR OVERHEAD FOR LAST MINUTE
;DISPLAY CPU UTILIZATION FOR LAST HOUR IN PROGRAM NAME 

	MOVE	A,MINDEX
	CAIGE	A,^D60
	JRST	.+3
	SETZ	A,
	SETOM	FRSFLG
	MOVE	D,MINNUL
	MOVEM	D,HRNULL(A)
	ADDI	A,1
	MOVEM	A,MINDEX
	SETZ	C,
	HRLZI	D,-^D60
	ADD	C,HRNULL(D)
	AOBJN	D,.-1
	SKIPE	FRSFLG
	MOVEI	A,^D60
	IDIV	C,A
	SUBI	C,^D100		;COMPLEMENT OF NULL TIME
	MOVMS	C
	CAIL	C,^D100		;100 %?
	JRST	[MOVE C,['  100%']
		JRST %100]
	IDIVI	C,^D10		;1ST DIG IN C, 2ND IN N
	LSH	C,^D12
	LSH	D,^D6
	IORI	C,'00%'(D)	;MAKE IT READABLE
%100:	TLNE	C,770000	;LEADING SPACES?
	JRST	%100A		;NO, CHANGE NAME
	LSH	C,6		;YES, THROW ONE AWAY
	JRST	%100		;AND LOOK AGAIN

%100A:	SETNAM	C,
	POPJ	P,
;DSK USEAGE ROUTINE

DISK:	MOVE	Q,.GTLVD(GI)	;ADR OF DISK PARAMETER TABLE
	HLRZ	A,%LDUNI(Q)	;GET ADDRESS OF FIRST UNIT
	SETZB	C,D		;ZERO FREE BLOCKS AND TOTAL BLOCKS
	SETZ	E,		;ZERO BLOCKS TRANSFERED
DSKLP0:	ADD	E,SPYSEG+16(A)	;BUFFERED READS
	ADD	E,SPYSEG+17(A)	;BUFFERED WRITES
	ADD	E,SPYSEG+20(A)	;DUMP READS
	ADD	E,SPYSEG+21(A)	;DUMP WRITES
	ADD	E,SPYSEG+22(A)	;MONITOR READS
	ADD	E,SPYSEG+23(A)	;MONITOR WRITES
	SUB	E,SPYSEG+24(A)	;SUBTRACT BLOCKS SWAPPED IN FROM MR
	SUB	E,SPYSEG+25(A)	;SUBTRACT BLOCKS SWAPPED OUT FROM MW
	MOVE	T1,SPYSEG(A)	;GET PHYSICAL UNIT NAME
	MOVEM	T1,DSKCHB	;STORE IN DSKCHR BLOCK
	MOVE	T2,[20,,DSKCHB]
	DSKCHR	T2,		;GET UNIT CHARACTERISTICS
	ERROR	(LNSDCH DSKCHR ERROR)
	ADD	C,DSKCHB+3	;ACCUMULATE TOTAL FREE BLOCKS
	ADD	D,DSKCHB+6	;ACCUMULATE TOTAL BLOCKS ON UNIT
	MOVE	T1,DSKCHB+12	;K FOR SWAPPING MUST BE SUBTRACTED
	LSH	T1,3		;CONVERT TO BLOCKS
	SUB	D,T1		;SUBTRACT SWAPPING SPACE
NOTPUB:	HLRZ	A,SPYSEG+3(A)	;ADDRESS OF NEXT UNIT
	JUMPN	A,DSKLP0	;CONTINUE IF MORE
	SUB	E,TOTDSK
	ADDM	E,TOTDSK	;TOTAL BLOCKS TRANSFERED
	MOVEM	E,MINDSK	;BLOCKS TRANSFERED IN LAST MINUTE
	IMULI	C,^D100
	IDIV	C,D
	SUBI	C,^D100
	MOVNM	C,DSKUSD	;PERCENT OF PUBLIC DISK SPACE USED
	POPJ	P,
;SWAPPING DATA

SWAPER:	SETZB	E,G
	SETZ	N,
	MOVE	Q,.GTLVD(GI)	;ADR OF DISK PARAMS TABLE
	HLRZ	D,%LDSWP(Q)	;ADR OF FIRST SWAP UNIT
SWLP1:	ADD	N,SPYSEG+24(D)	;GET R ON FHA
	ADD	N,SPYSEG+25(D)	;GET W ON FHA
	ADD	E,SPYSEG+31(D)	;P FREE FOR SWAPPING
	LDB	B,[POINT 13,SPYSEG+7(D),35]
	ADD	G,B		;K TO BEGIN WITH FOR SWAPPING
	HLRZ	D,SPYSEG+7(D)	;NEXT UNIT FOR SWAPING
	JUMPN	D,SWLP1		;LAST UNIT?
	LSH	G,1		;SINCE G HAS K AND E HAS PAGES
	SUB	E,G
	MOVNS	E		;PAGES USED FOR SWAPPING
	IMULI	E,^D100
	IDIV	E,G		;% OF SWAPPING SPACE USED
	MOVEM	E,SWUSED
	SUB	N,TOTSWP
	ADDM	N,TOTSWP	;UPDATE TOTAL BLOCKS SWAPPED
	MOVEM	N,MINSWP	;BLOCKS SWAPPED IN LAST MINUTE
	POPJ	P,
IFN	FTSCHED,<

;SCHEDULER PARAMETERS

NOPAR==^D34			;ACTUAL NUMBER OF PARAMETERS USED
NCLASS==^D16			;NUMBER OF SCHEDULER CLASSES
NPAR==NOPAR+NCLASS+^D20		;ROOM FOR UP TO 50 PARAMETERS + 20 TO SPARE

GETPAR:	SKIPGE	A,PARAOB	;FIRST TIME THRU?
	JRST	GETP1		;NO
	JUMPG	A,CPOPJ		;RETURN IF GETTAB DESN'T WORK
	AOS	PARAOB		;FLAG THAT WE HAVE BEEN THRU THIS CODE BEFORE
	MOVEI	A,.GTPAR	;GETTAB SCHEDULER PARAMETERS
	GETTAB	A,
	POPJ	P,		;NO SUCH GETTAB
	MOVE	B,.GTPAR(GI)
	ADDI	B,SPYSEG
	HRRM	B,GETP1
	HRRM	B,GETP2
	LDB	A,[POINT 9,B,8]
	CAILE	A,NOPAR-1	;MAXIMUM OF NOPAR ENTRIES
	MOVEI	A,NOPAR-1
	SUBI	A,^D8		;ACCOUNT FOR WASTE PAGES AND SWAP TIMES
	SETCA	A,
	HRLZ	A,A
	MOVEM	A,PARAOB	;SAVE AOBJN WORD
GETP1:	MOVE	B,.GTPAR(A)	;RH REPLACED BY ADR OF SPYSEG, ETC.
	EXCH	B,SAVPAR(A)
	SUB	B,SAVPAR(A)
	MOVNM	B,OUTPAR(A)	;USE DIFFERENCE WITH LAST VALUE
	AOBJN	A,GETP1
GETP2:	HRLZI	B,.GTPAR(A)	;RH REPLACED BY ADR OF SPYSEG, ETC.
	HRRI	B,NEWPAR
	BLT	B,NEWPAR+7	;DON'T LET THEM CHANGE IN THE MIDDLE
	DEFINE	YANK(X)
<	MOVE	B,X+NEWPAR	;GET 2 SINGLE WORD ENTRIES
	MOVE	C,X+NEWPAR+1	;GET 2 SINGLE WORD ENTRIES
	EXCH	B,X+SAVPAR(A)	;SAV THE NEW VALUES
	EXCH	C,X+SAVPAR+1(A)
	SUB	B,X+SAVPAR(A)	;GET DIFFERENCES
	SUB	C,X+SAVPAR+1(A)
	MOVNM	B,X+OUTPAR(A)	;STORE FOR OUTPUT
	MOVNM	C,X+OUTPAR+1(A)
	MOVE	B,X+NEWPAR+2	;GET 1 DOUBLE WORD ENTRY
	MOVE	C,X+NEWPAR+3	;GET 1 DOUBLE WORD ENTRY
	EXCH	B,X+SAVPAR+2(A)	;SAVE THE NEW VALUES
	EXCH	C,X+SAVPAR+3(A)
	MOVN	C,C		;TEST POSITIVE NUMBER
	ADD	C,X+SAVPAR+3(A)	;LOW ORDER WORD DIFFERENCE
	TLZE	C,400000	;BORROW?
	ADDI	B,1		;YES
	SUB	B,X+SAVPAR+2(A)	;HI ORDER WORD DIFFERENCE
	MOVNM	B,X+OUTPAR+2(A)	;STORE FOR OUTPUT
	MOVEM	C,X+OUTPAR+3(A)	;(ALSO NEGATE THIS ONE)
>
	YANK	0
	YANK	4
	POPJ	P,
;ROUTINE TO GRAB CLASS RUNTIMES

GETCLS:	SKIPGE	A,CLSAOB	;BEEN THRU HERE YET?
	JRST	GETCLA		;YES
	JUMPG	A,CPOPJ		;IF GETTAB DOESN'T WORK, RETURN
	AOS	CLSAOB		;ASSUME GETTAB DOESN'T WORK
	MOVEI	A,.GTCRT	;TRY IT
	GETTAB	A,
	POPJ	P,		;NO SUCH GETTAB
	MOVE	B,[%SSSCD-SPYSEG,,.GTSST]
	GETTAB	B,		;DOES SCDSET GETTAB WORK?
	POPJ	P,		;NO
	MOVE	B,.GTCRT(GI)	;GETTAB IMMEDIATE OF CLASS RUNTIMES
	ADDI	B,SPYSEG	;SPY ADDRESS
	HRRM	B,GETCLC	;STORE FOR LATER USE
	LDB	A,[POINT 9,B,8]	;HIGHEST CLASS
	CAILE	A,NCLASS-1	;MAXIMUM OF 16 CLASSES
	MOVEI	A,NCLASS-1
	SETCA	A,		;NEGATIVE NUMBER OF CLASSES
	HRLZ	A,A
	MOVEM	A,CLSAOB	;STORE AS CLASS AOBJN WORD
GETCLA:	MOVE	Q,.GTSST(GI)	;SCHEDULER STATISTICS TABLE
	MOVE	B,%SSSCD(Q)	;TIME THAT CLASS PERCENTS WERE LAST SET
	EXCH	B,SCDSET	;STORE FOR FUTURE COMPARE
	CAMN	B,SCDSET	;SAME AS LAST TIME?
	JRST	GETCLB		;YES
	SETZM	NOPAR+SAVPAR(A)	;NO IT CHANGED, SO ZERO OUR CUMULATIVE TABLE
	AOBJN	A,.-1
	MOVE	A,CLSAOB	;RESET A TO AOBJN POINTER
GETCLB:	SKIPN	SCDSET		;CLASS SCHEDULING?
	POPJ	P,		;NO, DON'T BOTHER GETTING STATISTICS
GETCLC:	MOVE	B,.GTCRT(A)	;GET CLASS RUNTIME FOR THIS CLASS
	EXCH	B,NOPAR+SAVPAR(A) ;STORE IN TABLE
	SUB	B,NOPAR+SAVPAR(A) ;COMPUTE DIFFERENCE FROM LAST VALUE
	MOVNM	B,NOPAR+OUTPAR(A) ;OUTPUT DIFFERENCE
	AOBJN	A,GETCLC	;REPEAT FOR ALL CLASSES
	POPJ	P,		;RETURN
>
;OUTPUT MINUTELY DATA

DMPMIN:	MOVE	A,THSDAT	;GET THIS DATE
	EXCH	A,LSTDAT
	JUMPN	A,DEVOPN	;JUMP IF NOT FIRST TIME THROUGH
	SETOM	LSTDAT		;MAKE COMPARISON FAIL NEXT TIME
	INIT	DSK,
	'DSK   '
	DOBUFF,,DIBUFF
	ERROR	(LNSCID CAN'T INIT DSK 2)
	OUTBUF	DSK,1		;ONLY 1 BUFFER
	POPJ	P,

DEVOPN:	CAME	A,THSDAT	;SAME DATE AS BEFORE?
	PUSHJ	P,FILVER	;NO, OPEN A NEW FILE
	MOVEI	A,VARCNT-1
	SKIPN	VARARA(A)
	SOJG	A,.-1
	SETCA	A,
	HRLZ	A,A
	HRRI	A,VARARA
	MOVE	Q,(A)		;GET A VARIABLE
	PUSHJ	P,DECOUT	;DUMP IT
	AOBJN	A,.-2		;DUMP THEM ALL
	MOVEI	Q,15
	PUSHJ	P,PUTCHR
	MOVEI	Q,12
	PJRST	PUTCHR


; HERE TO OPEN FILE AND STORE OUR VERSION IN IT
FILVER:	PUSHJ	P,FILOPN	;OPEN THE NEW FILE
	MOVEI	Q,^D25		;CODE FOR VERSION NUMBER RECORD
	PUSHJ	P,DECOUT	;OUTPUT IT
	MOVEI	Q,VMAJOR	;OUTPUT VERSION NUMBER
	PUSHJ	P,DECOUT	;IN DECIMAL
	MOVEI	Q,15		;CR
	PUSHJ	P,PUTCHR	;OUTPUT A CHAR
	MOVEI	Q,12		;LF
	PJRST	PUTCHR		;OUTPUT IT AND RETURN
;OPEN THE FILE OF THE DAY

FILOPN:	MOVE	T2,THSDAT
	IDIVI	T2,^D31
	ADDI	T3,1		;GET THE DAY
	IDIVI	T3,^D10		;SEPARATE DIGITS
	LSH	T3,6
	IORI	T3,'00'(T4)	;MAKE IT SIXBIT
	LSH	T3,6		;LEFT JUST
	MOVE	T1,T3
	IDIVI	T2,^D12
	HRL	T1,MONTAB(T3)	;ADD NAME OF MONTH
FILCLS:	CLOSE	DSK,		;CLOSE ANY OLD FILE
	MOVEI	T2,5
	MOVEM	T2,.RBCNT	;COUNT OF RIB ARGUMENTS
	SETZM	.RBPPN
	MOVEM	T1,.RBNAM
	MOVSI	T2,'DAT'
	MOVEM	T2,.RBEXT
	LOOKUP	DSK,.RBCNT	;DO EXTENDED LOOKUP
	JRST	MAKFIL		;NOT THERE, MAKE ZERO BLOCK FILE
	MOVSI	T2,'DAT'
	SETZB	T3,T4
	ENTER	DSK,T1		;ENTER IT
	ERROR	(LNSCEO CAN'T ENTER OUTPUT FILE 1)
	MOVE	T1,.RBSIZ
	ADDI	T1,177
	IDIVI	T1,200		;GET NUMBER OF BLOCKS
	USETO	DSK,1(T1)	;OUTPUT TO THAT ONE
	OUTPUT	DSK,		;SET UP BYTE POINTER AND COUNT
	POPJ	P,

MAKFIL:	MOVSI	T2,'DAT'
	MOVSI	T3,(157B8)
	SETZ	T4,
	ENTER	DSK,T1
	ERROR	(LNSCEO CAN'T ENTER OUTPUT FILE 2)
	JRST	FILCLS		;WRITE A NULL FILE
;IO ROUTINES

DECOUT:	PUSH	P,Q
	MOVEI	Q," "
	PUSHJ	P,PUTCHR
	MOVEI	Q,"-"
	SKIPGE	(P)
	PUSHJ	P,PUTCHR
	POP	P,T1
	MOVMS	T1
	PUSH	P,I
	SETZ	I,
	IDIVI	T1,^D10
	PUSH	P,T2
	ADDI	I,1
	JUMPN	T1,.-3
	POP	P,Q
	ADDI	Q,"0"
	PUSHJ	P,PUTCHR
	SOJG	I,.-3
	POP	P,I
	POPJ	P,

PUTCHR:	SKIPE	RECSIZ		;FIRST CHARACTER OF RECORD?
	JRST	NFSCHR		;NO
	MOVE	T1,[POINT 7,RECORD]
	MOVEM	T1,RECPNT
NFSCHR:	AOS	T1,RECSIZ	;KEEP RECORD SIZE
	IDPB	Q,RECPNT	;STORE THE BYTE
	CAIE	Q,12		;END OF LINE?
	POPJ	P,		;NO
	CAMG	T1,BYTCNT	;YES, WILL IT FIT?
	JRST	RECFTS		;YES
	OUT	DSK,		;DUMP THE BLOCK
	JRST	.+2
	ERROR	(LNSEOO ERROR ON DSK OUTPUT)
	PUSHJ	P,FILOPN	;CLOSE FILE AND REOPEN TO SAVE IN CASE OF CRASH
RECFTS:	MOVN	T1,RECSIZ
	ADDM	T1,BYTCNT
	SETZM	RECSIZ		;START NEW RECORD
	MOVE	T2,[POINT 7,RECORD]
	ILDB	T3,T2
	IDPB	T3,BYTPNT
	AOJL	T1,.-2
	POPJ	P,

MONTAB:	'JAN'
	'FEB'
	'MAR'
	'APR'
	'MAY'
	'JUN'
	'JUL'
	'AUG'
	'SEP'
	'OCT'
	'NOV'
	'DEC'

PTYWRT:	OPEN	PTY,PTYDEV	;INITIALIZE A PTY
	POPJ	P,		;NONE AVAILABLE

	PUSH	P,T1		;SAVE T1
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVSI	T4,-TTYLEN	;NUMBER OF TTYS TO SEND TO
PTYLP:	MSTIME	T1,
	ADDI	T1,^D3000	;CURRENT TIME + 3 SEC.
	MOVEM	T1,TIMLIM	;TIME LIMIT FOR PTY TO RETURN A DOT
	MOVEI	T1,[ASCIZ/SEND /]
	PUSHJ	P,ASCIIP
	MOVE	T1,TTYTAB(T4)	;TYPE TTY NAME
	PUSHJ	P,SIXBIP
	MOVE	T1,-1(P)	;GET ARG
	PUSHJ	P,ASCIIP	;PRINT IT
	MOVEI	T1,[ASCIZ/
/]
	PUSHJ	P,ASCIIP	;PRINT CRLF
	OUTPUT	PTY,		;FORCE AN OUTPUT
PTYTRY:	MOVEI	T1,PTY		;PTY CHANNEL NUMBER
	JOBSTS	T1,		;GET JOB STATUS
	JRST	PTYINP		;SHOULD NEVER HAPPEN
	TLC	T1,160000	;OUTPUT AVAILABLE, AT MONITOR COMMAND LEVEL
	TLCN	T1,160000	;READY FOR NEXT SEND?
	JRST	PTYINP		;YES
	MSTIME	T1,		;GET CURRENT TIME
	SUB	T1,TIMLIM	;MINUS TIME LIMIT
	JUMPGE	T1,PTYINP	;GIVE UP IF TIME LIMIT PASSED ALREADY
	MOVNS	T1		;NUMBER OF MS TO SLEEP
	HRLI	T1,(1B12)	;WAKE ON PTY ACTIVITY
	HIBER	T1,		;GO TO SLEEP
	SKIPA			;HIBER NOT IMPLEMENTED
	JRST	PTYTRY		;CHECK AGAIN
	MOVEI	T1,1
	SLEEP	T1,		;SLEEP A SEC
	JRST	PTYTRY		;NOW TRY

;INPUT FROM PTY
PTYINP:	INPUT	PTY,		;INPUT ANYTHING THATS THERE
	AOBJN	T4,PTYLP	;GO BACK TO SEND MESSAGE TO NEXT TTY
	RELEAS	PTY,		;GET RID OF PTY
	POP	P,.JBFF##	;RESTORE JOBFF
	POP	P,T1		;GET RID OF ARG
	POPJ	P,

;OUTPUT ASCII STRING TO PTY
ASCIIP:	TLO	T1,440700	;MAKE INTO BYTE POINTER
	ILDB	T2,T1		;GET NEXT CHAR
	JUMPE	T2,CPOPJ	;RETURN IF DONE
	PUSHJ	P,PTYP		;PRINT CHARACTER
	JRST	ASCIIP+1	;GET NEXT CHAR

;OUTPUT 6BIT WORD TO PTY
SIXBIP:	SETZ	T2,		;CLEAR JUNK FROM T2
	ROTC	T1,6		;ROTATE NEXT CHAR INTO T2
	JUMPE	T2,CPOPJ	;RETURN IF DONE
	ADDI	T2,40		;CHANGE TO ASCII
	PUSHJ	P,PTYP		;PRINT IT
	JRST	SIXBIP		;SAME FOR REST OF CHARACTERS

;STORE NUMBER IN T1 INTO ASCII STRING POINTED TO BY T4
DECP:	IDIVI	T1,^D10		;GET REMAINDER INTO T4
	HRLM	T2,(P)		;SAVE ON STACK
	SKIPE	T1		;DONE?
	PUSHJ	P,DECP		;NO, GET NEXT DIGIT
	HLRZ	T2,(P)		;RETRIEVE DIGIT
	ADDI	T2,60		;CHANGE TO CHAR
	IDPB	T2,T4		;STORE DIGIT
	POPJ	P,

;OUTPUT CHR TO PTY
PTYP:	SOSG	PTYOUT+2	;ANY ROOM LEFT
	OUTPUT	PTY,		;NO, DUMP BUFFER
	IDPB	T2,PTYOUT+1	;STORE BYTE IN BUFFER
CPOPJ:	POPJ	P,

FATAL:	MOVEI	T1,@(T1)
	MOVE	T4,['STOPED']
	SETNAM	T4,		;SET JOB NAME FOR SYSTAT
	GETLIN	T2,		;GET TTY NAME CONTROLING
	TLNN	T2,777777	;LEFT HALF ZERO?
	JRST	FATAL1		;YES - JOB DETACHED
	OUTSTR	(T1)		;NO - OK TO DO NORMAL OUTPUT
	OUTSTR	[ASCIZ/
/]
	CAIA
FATAL1:	PUSHJ	P,PTYWRT	;OUTPUT TO OPR THRU PTY
	EXIT	1,		;EXIT QUIETLY
	EXIT			;DONT ALLOW CONTINUE

LASTIM:	-1
TIMLIM:	BLOCK	1
PTYIN:	BLOCK	3
PTYOUT:	BLOCK	3
PTYDEV:	0
	'PTY   '
	PTYOUT,,PTYIN
TTYTAB:	'CTY   '
	TTYLEN==.-TTYTAB


;DATA BASE

DBASE:

;VARIABLES TO BE PRINTED EACH MINUTE

VARARA:
HOUR:	Z	;HOUR OF THE DAY
MINUTE:	Z	;MINUTE OF THE DAY
JBCNT:	Z	;NUMBER OF ACTIVE JOBS
LNCNT:	Z	;NUMBER OF ACTIVE LINES
TOTNUL:	Z	;PERCENT OF NULL TIME SINCE UP
MINNUL:	Z	;NULL TIME FOR LAST MINUTE
MINDSK:	Z	;NUMBER OF DSK BLOCKS TRANSFERED IN LAST MINUTE
TOTDSK:	Z	;TOTAL DSK BLOCKS TRANSFERED
MINSWP:	Z	;TOTAL BLOCKS SWAPPED IN LAST MINUTE
TOTSWP:	Z	;TOTAL BLOCKS SWAPPED
MINOVH:	Z	;MONITOR OVERHEAD FOR LAST MINUTE
USDCNK:	Z	;PERCENT OF TELETYPE CHUNKS USED
TOTBIT:	Z	;PERCENT OF CB USED
SWUSED:	Z	;PERCENT OF SWAPPING SPACE USED
DSKUSD:	Z	;PERCENT OF PUBLIC DSK SPACE USED
IFN	FTSCHED,<
OUTPAR:	BLOCK	NPAR	;SCHEDULER PARS
>

VARCNT==.-VARARA

;OTHER VARIABLES

IFN	FTSCHED,<
NEWPAR:	BLOCK	^D8
SAVPAR:	BLOCK	NPAR
PARAOB:	Z	;AOBJN WORD FOR SCHEDULER PARAMETERS
CLSAOB:	Z	;AOBJN WORD FOR CLASS RUN TIMES
SCDSET:	Z	;LAST TIME CLASS SCHEDULING PARAMETERS WERE CHANGED
>
DOBUFF:	Z
BYTPNT:	Z	;RING HEADER POINTER
BYTCNT:	Z	;RING HEADER BYTE COUNT
DIBUFF:	BLOCK	3
.RBCNT:	Z
.RBPPN:	Z
.RBNAM:	Z
.RBEXT:	Z
.RBPRV:	Z
.RBSIZ:	Z
PDL:	BLOCK	30
THSDAT:	Z	;CURRENT DATE
LSTDAT:	Z	;DATE LAST TIME THROUGH
MINDEX:	Z	;INDEX FOR THE MINUTE
FRSFLG:	Z	;HOUR FLAG FOR CPUITL
HRNULL:	BLOCK	^D60	;HOURS WORTH OF CPU DATA
OLDNUL:	Z	;OLD NULL TIME
OLDUP:	Z	;OLD UP TIME
OLDOVH:	Z	;OLD MONITOR OVERHEAD
RECSIZ:	Z	;SIZE OF CURRENT OUTPUT RECORD
RECPNT:	Z	;BYTE POINTER TO CURRENT OUTPUT RECORD
RECORD:	BLOCK	100	;RECORD BUFFER AREA
DSKCHB:	BLOCK	20	;SPACE FOR DSKCHR UUO
MONVER:	Z	;MONITOR VERSION NUMBER IN RT HALF
GETTBI:	Z	;ADDRESS OF GETTAB IMMEDIATES
JOBAOB:	Z	;AOB WORD FOR JOBS

DBEND:

LINES
   K>?ùK>?ùK>?ù