FRMRUN Subroutine                                                 Page 1


    This document describes the FRMRUN subroutine which was  designed as
    a general  purpose interface to  allow non-privilaged  user programs
    and procedures  to run another  program without leaving  the current
    program context.   The document is  structured in three  parts:  the
    description  of  the  subroutine and  its  calling  parameters, some
    simple programming examples and an appendix describing  the possible
    returned status codes.

    Description:


        The  FRMRUN  subroutine  will  run  an  arbitrary  program  in a
        temporary frame.  It  is currently available from  user programs
        written  in  FORTRAN-IV,  FORTRAN-10,  Pascal,  SAIL  and  other
        languages   which   recognize  the   standard   FORTRAN  calling
        sequences.  (In Pascal use the "OPTIONS FORTRAN" clause; in SAIL
        use "FORTRAN PROCEDURE" in the program declaration).


        There are  five parameters in  the subroutine, with  three major
        data types:  "asciz",  "logical" and "integer".   Depending upon
        the language used, these types have different meanings.


        In Fortran, (both FORTRAN-IV and FORTRAN-10) logical and integer
        should each be  declared as INTEGER.   Asciz should be  a quoted
        string parameter or an integer  array which has a zero  value in
        the last  element.  Packed arrays  may be created  using ENCODE,
        however  the  user  must  still remember  to  put  a  zero value
        character as the terminator.


        In  Pascal,  logical  and integer  should  be  declared  as type
        INTEGER.  Asciz parameters  should be declared as  "PACKED ARRAY
        [min..max] of CHAR" where min is usually 1 and max is the number
        of characters expected in the argument string.


        In SAIL, logical may be declared as BOOLEAN or INTEGER.  Integer
        may also be declared BOOLEAN but the user should use INTEGER for
        documentation purposes.  Asciz should be generated by packing an
        integer array  with repetitive  calls to  CVASC for  the FORTRAN
        version  and may  be declared  as STRING  for the  "native" SAIL
        version.


        In BLISS, there are  no strong data types  and it is up  to each
        user to insure that the proper values are passed to  the FORTRAN
        callable  subroutine.   For the  "native"  BLISS  version, (PLIT
        ASCIZ 'string') may be used for asciz.  It should  be remembered
        that parameters passed  by value are ".variable"  and parameters
        passed by reference are merely "variable" (no dot!).
FRMRUN Subroutine                                                 Page 2


    FRMRUN( PROGRAM, FLAGS, STATUS, CODE, TNAME, TDATA )


    PROGRAM    asciz    The name of the program to be run.

    FLAGS      logical  The options which FRMRUN should use.
                        For the default options, use 0 as the
                        value, otherwise think of each flag as
                        single "bits" which are ORed together.

          CCL    =  1   Start the specified program at the
                        CCL entry point.
          NOPASS =  2   Do not PASS the connected terminal
                        to the other frame.
          NOWAIT =  4   Do not WAIT for the other frame to
                        complete the specified program.
          NOCRLF =  8   Do not add CRLF at the end of the
                        last line of data to be put in the
                        temporary file.

    STATUS     reference integer
                        The status returned from the subroutine.
                        This will be 0 if there were no errors of
                        any kind.  If non-zero, then the error
                        code may be interpreted as described in
                        the appendix.

    CODE       reference integer
                        The error code returned from the program
                        in monitors which support the FAIL EXIT
                        monitor call.
                        This value is only valid when the STATUS
                        returned equals 10402 (FAIL EXIT).

    TNAME      asciz    The name to use for the temporary file.
                        This should be a three (3) character name
                        to be used to create the file "xxxNAM.TMP"
                        where "xxx" is the frame number used for
                        the temporary frame and "NAM" is the first
                        three characters of the string used for
                        TNAME.  (If TNAME equals 0 or null, then
                        no temporary file is used).

    TDATA      asciz    The data to be written into the temporary
                        file.  This is dependent upon the format
                        required by each individual program which
                        uses the CCL entry mechanism and temporary
                        files.  If TNAME is 0 or null, then this
                        data is ignored.
FRMRUN Subroutine                                                 Page 3


    As previously  indicated, the  FRMRUN subroutine  is designed  to be
    callable from procedures  and programs written in  FORTRAN-IV (F40),
    FORTRAN-10  (F-10)  and  languages which  use  the  standard FORTRAN
    calling  sequences.  Thus,  Pascal  and ALGOL,  which  have built-in
    features for calling  FORTRAN procedures may  also make use  of this
    routine.  Note: SAIL and  BLISS programmers should use  the "native"
    mode FRMRUN packages designed for each language.


    The first  two examples  below will work  regardless of  the FORTRAN
    compiler  used  to  assemble them.   Pascal  uses  the  DEC standard
    FORTRAN-10  calling sequence  when the  "OPTIONS FORTRAN"  clause is
    used.


    Examples:


                       FORTRAN-IV and FORTRAN-10

Example 1:

               INTEGER   STATUS,CODE
               EXTERNAL  FRMRUN

       C       CALL THE FRMRUN ROUTINE TO RUN THE PASSWORD PROGRAM
       C       THE CCL ENTRY POINT AND PASS A TMPCOR FILE TO CHANGE
       C       TWO USER NAMES: ONE AND TWO

               CALL FRMRUN('(SYS)PASSWO',1,STATUS,CODE,'PAS','ONE,TWO')
               IF (STATUS.NE.0) TYPE 10,STATUS
       10      FORMAT(/1X,'ERROR IN PASSWORD CHANGE: ',I5 )
               IF (STATUS.EQ.10402) TYPE 20,CODE
       20      FORMAT(/1X,'PROGRAM ERROR CODE: ',I5 )
               END
FRMRUN Subroutine                                                 Page 4


Example 2:

               INTEGER   PROG(16)
               INTEGER   FLAGS,STATUS,CODE
               INTEGER   TNAME
               INTEGER   TDATA(16)

               EXTERNAL  FRMRUN

       C       INITIALIZE TEXT ARRAYS TO SPACES

       10      DO 20 I=1,16
               PROG(I) = ' '
       20      TDATA(I) = ' '

       C       PROMPT AND ACCEPT PROGRAM NAME AND FLAGS

               TYPE 50
       50      FORMAT(/1x,'What program: '$)
               ACCEPT 60,PROG
       60      FORMAT(16A5)
               TYPE 70
       70      FORMAT('+Flags: '$)
               ACCEPT 80,FLAGS
       80      FORMAT(O)

       C       READ TEMP-FILE NAME (OR SPACES IF 'CR')

               TYPE 90
       90      FORMAT(1x,'Temp file name: '$)
               ACCEPT 60,TNAME
               IF (TNAME.EQ.'     ') TNAME = 0
               IF (TNAME.EQ. 0 ) GOTO 100
               TYPE 95
       95      FORMAT('+Temp file data: '$)
               ACCEPT 60,TDATA

       C       STRIP TRAILING SPACES (5 AT A TIME) AND SET TO NULL (0)

       100     DO 101 I=16,1,-1
               IF (PROG(I).EQ.'     ') PROG(I) = 0
               IF (TDATA(I).EQ.'     ') TDATA(I) = 0
       101     CONTINUE

       C       CALL THE FRAME RUN ROUTINE
               CALL FRMRUN( PROG, FLAGS, STATUS, CODE, TNAME, TDATA )

       C       TYPE OUT RESULTS FROM FRMRUN ROUTINE

               TYPE 200,STATUS
       200     FORMAT(/1X,'Status: ',I5 )
               IF (STATUS.EQ.10402) TYPE 201,CODE
       201     FORMAT(/1X,'Program error code: ',I5 )
               END
FRMRUN Subroutine                                                 Page 5


                                 Pascal


    Please note:  In Tymshare's Pascal there are types STRING and PACKED
    ARRAY  OF CHAR,  each  of which  may  be used  similarly  within the
    confines of the Pascal  language.  However, each of these  two types
    provides different  linkage information when  passed to  an external
    subprogram.  The current version of FRMRUN has only been tested with
    PACKED ARRAY OF  CHAR and the user  should ONLY user use  this type.
    Also, remember  in the description  above that the  character string
    passed to FRMRUN is of type "ASCIZ" and must be terminated by a null
    character (or a byte with the zero value).


Example 3:

       PROGRAM Ptest;

       TYPE
               T1 = PACKED ARRAY[ 1 .. 80 ] OF CHAR;
               T2 = INTEGER;
               T3 = PACKED ARRAY[ 1 .. 3 ] OF CHAR;

       VAR
               PROG   : T1;
               FLAGS  : T2;
               STATUS : T2;
               CODE   : T2;
               TNAME  : T3;
               TDATA  : T1;

       EXTERNAL PROCEDURE FRMRUN(
                   P1 : PACKED ARRAY[ 1..80 ] of CHAR;
                   P2 : INTEGER;
                   VAR P3 : INTEGER;
                   VAR P4 : INTEGER;
                   P5 : PACKED ARRAY[ 1..3 ] OF CHAR;
                   P6 : PACKED ARRAY[ 1..80 ] OF CHAR)
               OPTIONS FORTRAN;

       BEGIN
               PROG  := '(SYS)PASSWORD';
               FLAGS := 0;
               FRMRUN(PROG, FLAGS, STATUS, CODE, 0, 0);

               FLAGS := 1;
               PROG := '(SYS)PASSWORD';
               TDATA  := 'USER1,USER2';
               FRMRUN( PROG, FLAGS, STATUS, CODE, 'PAS', TDATA );
       END.
FRMRUN Subroutine                                                 Page 6


                                  SAIL



    Note:  SAIL  programs should  use the  "native" mode  package rather
    than the FORTRAN  package.  SAIL attempts  to manage its  own memory
    and file buffer allocation.   FRMRUN needs to allocate  file buffers
    for  the  temporary  file  it  creates.   This  may  sometimes cause
    "problems"  to  the SAIL  runtimes.   The native  mode  routines are
    written  in  SAIL  and  are  thus  fully  integrated  with  the SAIL
    runtimes.

    The  SAIL version  of  FRMRUN is  an  INTEGER FUNCTION  which  has a
    slightly different parameter list than the FORTRAN  version.  Status
    is the return value of the function.  (See below).

    Note:  The use of a  defined constant, CCL, to document the  call to
    the PASSWORD program.


Example 4:

       Begin "Frame run example"

               Define !    = "COMMENT";
               Define CRLF = "'15&'12";      ! It's nice to have CR-LF ;
               Define CCL  = 1;              ! Flag to use CCL entry ;

               External Integer Procedure FRMRUN(
                   String ProgramName;
                   Integer ProgramFlags;
                   Reference Integer ProgramCode;
                   String TempFileName, TempFileData );

               Require "(SAILIB)FRMRUN" library;

               Own Integer Flag, Status, Code;

               Begin "call password"
                   Status := FRMRUN( "(SYS)PASSWO", Flag:=CCL, Code,
                             "PAS", "USER1,USER2" );
                   If Status = 0
                    then Print("Return from PASSWORD successful.",CRLF)
                    else begin "read error code"
                       If Status = 10402
                        then Print("Program error: ",Error,CRLF)
                        else Print("Error status: ",Status,CRLF)
                    end "read error code"
               end "call password"

       end "Frame run example";
FRMRUN Subroutine                                                 Page 7


                               APPENDIX I
                          Status Code Summary




    When control returns  to the user  program after calling  the FRMRUN
    subroutine,  the  value  of  STATUS will  be  0  if  no  errors have
    occurred.  However when an error does occur, the user  can interpret
    the value  of STATUS  as a five  digit decimal  integer of  the form
    XCCTT containing three fields:  X, CC and TT.


    The individual fields are interpreted as follows:

        X     is the error status, ranging from 0 to 3.
        CC    is the halt class, ranging from 00 to 05.
        TT    is the halt type, or the UUO error code.
              The range varies for each error condition.


    For NO ERROR, all values are 0.  (i.e. STATUS is 0).

    For each error condition the following rules apply:

        X = 0 FRMRUN ERROR,     CC contains 0 but TT is as follows:

            TT = 01    Frame halted with no status (usually ^C)
            TT = 02    Could not get temporary file device (DSK)
            TT = 03    Could not create temporary file
            TT = 04    Could not write temporary file
            TT = 05    GETTAB UUO failed (possibly frame logged out)
            TT = 06    HIBER UUO failed
            TT = 07    Illegal file specification used for the name of
                       the program to run

        X = 1 MONITOR HALT,     CC is the class and TT is the type.
                                See page 2-26 of the TYMCOM-X YAMM.

        X = 2 FRMOP UUO ERROR,  CC is 0 and TT is the frmop error code.
                                See page 2-19 of the TYMCOM-X YAMM.

        X = 3 RETACH UUO ERROR, CC is 0 and TT is the retach error code.
                                See page 10-22 of the TYMCOM-X YAMM.



    If the value of STATUS  is 10402, (MONITOR HALT, Class:  Frame Exit,
    Type: Fail Exit),  then the value of  the program error  code (CODE)
    should be interpreted as documented by the individual program.
FRMRUN Subroutine                                                 Page 8


                              APPENDIX II
                 Status Code Values - Detailed Summary



         Normal completion code:

         00000     normal completion - no errors detected

         Unexpected error from FRMRUN subroutine:

         00001     Frame halted with no halt status (usually ^C)
         00002     Could not assign temporary file device.
         00003     Could not create temporary file.
         00004     Could not worte temporary file.
         00005     GETTAB failed (possibly frame logged out).
         00006     HIBER failed (could not wait for completion).
         00007     Illegal file specification used for the name
                   of the program to run.

         Unexpected error from child frame (halt status):

         10000     PC Out of Bounds
         10001     Illegal Memory Reference
         10002     Write Violation
         10003     Address Check for Device X
         10004     Ill Mem Ref in UUO
         10005     Illegal Interrupt Address
         10006     Address Break
         10007     PDL Overflow
         10100     Page I/O Error
         10101     Disk Full during copy of !PRCW page
         10102     Paging Hardware Error
         10103     Too many Pages Locked, Cannot handle fault
         10104     Context Page I/O Error
         10105     Parity Error(s). All Core Removed
         10200     Output device Cannot Input
         10201     Input device Cannot Output
         10202     Illegal Data Mode for device X
         10203     I/O to Unassigned Channel
         10204     Hung Device
         10205     Device X OPR action requested
         10300     Illegal UUO
         10301     UUO error
         10302     Illegal Instruction
         10303     Halt
         10402     Fail Exit (program's error code returned in CODE)
         10403     Time Limit Exceeded
         10404     <filename> setup
         10405     <filename> saved
         10406     frame cleared
         10500     Transmission Error
         10501     N Pages Required
         10502     Device Not Available
FRMRUN Subroutine                                                 Page 9


         10503     <filename.ext> not found
         10504     Not a Save File
         10505     <filename.ext> Attempted Enter UUO Failed
         10506     Core Argument Not specified (magtape only)
         10507     Magtape Hiseg Format Bad
         10508     Remap UUO Fatal error
         10509     Magtape GET failure
         10510     No Start Address

         Unexpected error from FRMOP:

         20001     no handle in slot
         20002     Bad (nonmatching) universal ID number
         20003     no rights to do operation
         20004     bad frame number
         20005     not enough license
         20006     undefined frame descriptor type
         20007     not a child
         20008     cannot lock context pages
         20009     bad access rights code
         20010     no parent
         20011     bad family dispatch type
         20012     bad handle index number in FD
         20013     bad FRMOP function code
         20014     address bad
         20015     page I/O error
         20016     already running
         20017     already halted
         20018     cannot stop frame with JACCT set
         20019     handle descriptor expected, not given
         20020     handle (index) already used
         20021     no frame handle indices left
         20022     bad count
         20023     bad table number
         20024     bad handle type
         20025     can't create handle (access failure)
         20026     bad start vector offset
         20027     cannot make child its own inferior in frame tree
         20028     cannot contirame
         20029     cannot do frame jump
         20030     rights exceed maximum

         Unexpected error from RETACH:

         30001     insufficient access rights to source frame
         30002     source frame does not exist
         30003     insufficient access rights  to target frame
         30004     target frame does not exist
         30005     specified port not attached to source frame
         30006     target frame already has port attached
         30007     forced command already pending on port
         30008     attaching aux circuit as command port
         30009     no room for new port DDB
   . SI