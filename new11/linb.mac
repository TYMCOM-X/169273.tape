	.TITLE	LINB   - LINE INTERFACE DRIVER TYPE B (DZV-11)
	.SBTTL	LINB   - NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

.IF NDF ..XTD				;DEFAULT IS NO EXTENDED FEATURES
  ..XTD=!0
.ENDC
.IF EQ ..SAT
  ..SAT=!0
.ENDC

	CODE

	.SBTTL	LINB   - RESET ROUTINE

;THIS ROUTINE IS CALLED WHEN THE NODE IS STARTED OR RESTARTED
;	C(R1) = OUTPUT BAUD RATE

ASBINT::TST	@ADBCSR#(R4)		;DOES THE HARDWARE FOR THIS LINE EXIST?
	NXMJMP	6$			;NO!
	BIS	#$S1AVL,SDSTS1#(SD)	;YES-INDICATE THIS LINE IS AVAILABLE
	MOVB	SDTRXA#(SD),R2		;GET INDEX FOR LINE ON INTERFACE
	BNE	4$			;CONTINUE IF NOT FIRST LINE
	BIS	#000020,@ADBCSR#(R4)	;FIRST LINE-RESET THE INTERFACE
2$:	TBBN	000020,@ADBCSR#(R4),2$	;WAIT UNTIL ITS RESET
	CLR	ADBMSB#(R4)		;CLEAR CURRENT MODEM BITS
	CLRB	ADBBRB#(R4)		;CLEAR BREAK BITS
	BISB	#$A1AVL,ADSTS1#(R4)	;INDICATE INTERFACE IS AVAILABLE
4$:	MOV	R2,R1			;Clear output buffer and flag
	ADD	R4,R1
	CLRB	ADBBFR#(R1)
	CLRB	ADBFLG#(R1)
	CLR	SDTXBP#(SD)		;Clear packet pointer too
	INC	R2			;IS THIS THE LAST LINE ON INTERFACE?
	CMPB	ADMAXI#(R4),R2
	BGT	RTN001			;NO
	MOV	#040140,@ADBCSR#(R4)	;ENABLE THE INTERFACE
	RETURN				;FINISHED

;HERE IF HARDWARE FOR INTERFACE DOES NOT EXIST

6$:	BICB	#$A1AVL,ADSTS1#(R4)	;Indicate hardware does not exist
RTN001:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LINB   - INTERRUPT LEVEL ROUTINES

;HERE FOR INPUT READY INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnIN:	PUSH	R4		;SAVE R4
;		MOV	#ADBn$,R4	;GET ADDRESS OF ADB
;		JMP	ASBINI		;GO TO COMMON ROUTINE

ASBINI::PUSH	R0			;SAVE R0
	PUSH	R1			;AND R1
INPGET:	MOV	@ADBRBF#(R4),R0		;GET CHARACTER
	BGE	DISMIS			;FINISHED IF NOTHING THERE
1$:	MOV	#.LFDAT,R1		;ASSUME NO BREAK
	TBBE	020000,R0,2$		;BREAK ON LINE?
	MOV	#.LFBRK,R1		;YES-FIX UP THE FUNCTION
2$:	BIC	#174000,R0		;REMOVE JUNK
	ADD	ADINDX#(R4),R0		;ADD THE LINE INDEX
.IF NE ..XTD
	CMP	R0,#MINXTR#		;IS THIS REALLY A TERMINAL LINE?
	BHIS	NOTTRM			;NO-IT IS DIFFERENT!
.ENDC
	CALL	TRINTR#			;CALL THE TERMINAL SERVICE
	BR	INPGET			;GO CHECK FOR ANOTHER CHARACTER

;HERE WITH INPUT INTERRUPT ON SPECIAL LINE (NOT TERMINAL)

.IF NE ..XTD
NOTTRM:	PUSH	R2			;SAVE ANOTHER AC
	MOV	R0,R2			;COPY TERMINAL INDEX
	SWAB	R2			;POSITION IT FOR INDEXING
	MOVB	R2,R2
	ASL	R2
	CALL	@DSXXTR#(R2)		;CALL ROUTINE FOR THIS LINE
	POP	R2			;RESTORE AC
	BR	INPGET			;AND DISMISS INTERRUPT
.ENDC

;HERE FOR OUTPUT DONE INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnOU:	PUSH	R4		;SAVE R4
;		MOV	#ADBn$,R4	;GET ADDRESS OF ADB
;		JMP	ASBOUI		;GO TO COMMON ROUTINE

ASBOUI::PUSH	R0			;SAVE R0
	PUSH	R1			;AND R1
	MOV	@ADBCSR#(R4),R0		;GET STATUS BITS FROM THE DZ11
	BIC	#174377,R0		;REMOVE ALL BUT LINE INDEX
	MOV	R0,R1
	SWAB	R1
	ADD	R4,R1
	TSTB	ADBFLG#(R1)		;Do we have any output now?
	BLE	OUTIDL			;No
	INC	COTCNT#			;Count the character
	MOVB	ADBBFR#(R1),@ADBTDR#(R4);Yes-output the character
	PUSH	R2			;Free up some more registers
	PUSH	R3
	MOV	R0,R2			;Find this line's SDB
	ADD	ADINDX(R4),R2           ;******PATCH*****8/20/80****
                                        ;****JWR****USED TO NOT HAVE**
                                        ;******"(R4)"*** IN LINE ABOVE**
	SWAB	R2
	ASL	R2
	MOV	T0SX#(R2),R2
	MOV	SDTXBP#(R2),R3		;Get output packet
	BEQ	6$			;If none
	TSTB	PKCNT(R3)		;Is it empty?
	BEQ	6$			;Yes
	PUSH	R0			;Free up R0
.IF EQ ..SAT
	MOVB	SDTRLW#(R2),R0		;Get line width
	BEQ	2$			;If none set
	CMPB	SDTRHP#(R2),R0		;Are we at the end of the line?
	BHIS	4$			;Yes-must stop now!
.ENDC
2$:	MOVB	PKPNT(R3),R0		;No-get next output character
	ADD	R3,R0
	MOVB	PKDATA-1(R0),R0
	TBBE	140,R0,4$		;Is this a printing character?
	INCB	PKPNT(R3)		;Yes-bump pointer
	DECB	PKCNT(R3)		;And reduce count
	INCB	SDTRHP#(R2)		;And bump horizontal position
	MOVB	R0,ADBBFR#(R1)		;Store character for next time
	POP	R0			;Restore R0
	POP	R3
	POP	R2
	BR	DISMIS			;And dismiss interrupt

;Here if must stop output now

4$:	POP	R0
6$:	POP	R3			;Restore registers
	POP	R2
	CLRB	ADBFLG#(R1)		;Clear buffer
	ADD	ADINDX#(R4),R0		;Get index for line
	CLR	R1			;Function = Output done
	CALL	TRINTR#			;Call terminal service
DISMIS:	POP	R1			;Restore R1
	POP	R0			;And R0
	POP	R4			;And R4
	RTI				;Dismiss interrupt

;HERE IF OUTPUT ON THIS LINE IS IDLE NOW

OUTIDL:
.IF NE ..XTD
	BMI	2$			;IF THIS IS NOT A TERMINAL LINE
.ENDC
	SWAB	R0			;GET INDEX IN LOW ORDER BITS
	BICB	ASBBIT(R0),@ADBTCR#(R4)	;DISABLE THE TRANSMITTER
	BR	DISMIS			;THATS ALL

;HERE FOR OUTPUT DONE INTERRUPT IF NOT A TERMINAL LINE

.IF NE ..XTD
2$:	ADD	ADINDX#(R4),R0		;ADD IN THE OFFSET
	CLR	R1			;FUNCTION = OUTPUT DONE
	BR	NOTTRM			;CONTINUE WITH COMMON CODE
.ENDC
	.PAGE
	.SBTTL	LINB   - OUTPUT ROUTINES

;Subroutine to output data - called only at main program level
;	C(R0) = Character to output
;	C(R1) = Address of output packet (if any)
;	C(R4) = Address of ADB
;	C(SD) = Address of SDB
;	CALL	ASBOUT

ASBOUT::MOVB	SDTRXA#(SD),R2		;GET OFFSET OF THIS LINE ON THE
					;  INTERFACE
	SETPSW	#340			;NO INTERRUPTS NOW!
	BISB	ASBBIT(R2),@ADBTCR#(R4)	;ENABLE TRANSMITTER
	ADD	R4,R2
	MOVB	R0,ADBBFR#(R2)		;Store character for interrupt level
	INCB	ADBFLG#(R2)		;SET BUFFER FULL FLAG
	MOV	R1,SDTXBP#(SD)		;Store address of packet (if any)
	CLRPSW				;INTERRUPTS OK NOW
	INC	COTCNT#			;Count the character
	RETURN				;FINISHED!

;SUBROUTINE TO PROFORM FUNCTION - CALLED ONLY AT MAIN PROGRAM LEVEL
;	C(R0) = FUNCTION
;	C(R1) = DATA (IF ANY)
;	C(R4) = ADDRESS OF ADB
;	C(SD) = ADDRESS OF SDB
;	CALL	ASBFNC
;	C:SET = ERROR

ASBFNC::MOVB	SDTRXA#(SD),R2		;GET INDEX THIS LINE
	CLR	R3			;GET BIT
	BISB	ASBBIT(R2),R3
	ADD	R0,PC			;DISPATCH ON THE FUNCTION
	BR	SNDBRK			;.LFSBK =  0  Send break
	BR	SETHWR			;.LFSET =  2  Set interface parameters
	BR	ANSWER			;.LFANS =  4  Answer line
	BR	HANGUP			;.LFFHG =  6  Force hang up
	BR	STPOUT			;.LFSTP = 10  Stop output
;	BR	ENDBRK			;.LFEBK = 12  End break sequence

;Here to end break sequence

ENDBRK:	BICB	R3,ADBBRB#(R4)		;Clear bit in saved array
	MOVB	ADBBRB#(R4),@ADBBRK#(R4) ;Move new value to break register
	RETURN

;Here to stop output immediately

STPOUT:	CLR	SDTXBP#(SD)		;Clear packet pointer to stop output
	RETURN				;And return

;HERE TO FORCE HANGUP ON LINE

HANGUP:	SWAB	R3			;GET BIT IN BOTH HALVES
	BISB	ASBBIT(R2),R3
	BIC	R3,@ADBTCR#(R4)		;CLEAR HARDWARE BITS
	BR	RTNCLC			;THATS ALL

;HERE TO ANSWER LINE

ANSWER:	SWAB	R3			;GET BIT IN LEFT HALF
	BIS	R3,@ADBTCR#(R4)		;TURN ON "DATA TERMINAL READY"
	BR	RTNCLC			;THATS ALL

;Here to setup interface parameters to match values stored in the SDB -
;  baud rate, character size, number of stop bits, parity enable, and parity
;  sense are setup

SETHWR:	MOVB	SDTRS3#(SD),R1		;Get output baud rate
	BIC	#^C$BRORT,R1
	ASL	R1			;For word indexing
	MOV	ASBRAT(R1),R0		;GET DATA FOR INTERFACE
	BEQ	RTNSEC			;ERROR IF NO DATA FOR THIS RATE
	TBBE	$T4PAR,SDTRS4#(SD),4$	;Do we want parity handling?
	TBBN	$T1IMO,SDTRS1#(SD),4$	;Really?
	TBBE	30,R0,4$		;Yes-can we do it for this baud rate?
	SUB	#10,R0			;Yes-adjust character size
	BIS	#100,R0			;Indicate want parity handling
	TBBE	$T4ODD,SDTRS4#(SD),4$	;Do we want odd parity?
	BIS	#200,R0			;Yes
4$:	BIS	R2,R0			;ADD IN THE LINE INDEX
	MOV	R0,@ADBLPR#(R4)		;SET BITS IN THE HARDWARE
RTNCLC:	CLC				;GIVE GOOD RETURN
	RETURN				;THATS ALL

;Here if error

RTNSEC:	SEC				;GIVE ERROR RETURN
	RETURN

;HERE TO SEND BREAK ON LINE

SNDBRK:	BISB	R3,ADBBRB#(R4)		;Set bit in saved array
	MOVB	ADBBRB#(R4),@ADBBRK#(R4) ;Move new value to break register
	RETURN
	.PAGE
	.SBTTL	LINB   - TEN-TIMES-A-SECOND ROUTINES

;GET HERE ONCE EACH TENTH SECOND AT MAIN PROGRAM LEVEL

	TNHSEC	ASBSEC			;PUT CALL INTO TEN-TIMES-A-SECOND LOOP

ASBSEC:	MOV	#ASBADB#,R4		;GET ADDRESS OF FIRST TYPE B ADB
ONCSE1:	TBBE	$A1AVL,ADSTS1(R4),ONCSE4;GO ON IF INTERFACE NOT AVAILABLE
	MOV	@ADBMSR#(R4),R2		;GET MODEM STATUS BITS
	MOV	ADBMSB#(R4),R1		;GET OUR SAVED BITS
	XOR	R2,R1			;SEE IF ANY HAVE CHANGED
	BEQ	ONCSE4			;NOPE
	MOV	R2,ADBMSB#(R4)		;YES-SAVE NEW BITS
	MOV	#100000,R0		;INITIALIZE MASK WORD
	MOV	#CARIER,R3		;SET ADDRESS OF ROUTINE
	CALL	CHKBTS			;CHECK THE 8 BITS
	MOV	#RNGIND,R3		;SET ADDRESS OF ROUTINE
	CALL	CHKBTS			;CHECK THE OTHER 8 BITS
ONCSE4:	MOV	ADNEXT#(R4),R4		;STEP TO NEXT ADB
	BNE	ONCSE1			;CONTINUE IF ANOTHER
RTN004:	RETURN				;NO MORE-FINISHED

;SUBROUTINE TO SERVICE THOSE DATASET BITS WHICH HAVE CHANGED SINCE LAST TIME
;	C(ADBMSB(R4)) = NEW BITS
;	C(R0)         = BIT MASK
;	C(R1)         = BITS WHICH HAVE CHANGED
;	C(R3)         = ADDRESS TO CALL FOR BITS WHICH HAVE CHANGED
;	CALL	CHKBTS

CHKBTS:	MOV	#8.,R2			;SET COUNTER
CHKBT2:	BIT	R0,R1			;DID THIS BIT CHANGE?
	BEQ	CHKBT4			;NO
	PUSH	R0			;YES-SAVE OUR REGISTERS
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
	MOVB	ADINDX#+1(R4),R1	;FIND THE SDB FOR THE LINE
	ADD	R1,R2
	ASL	R2
	MOV	T0SX#-2(R2),SD		;Note that R2 contained one more than
					;  the offset of the line on the
					;  interface
	CALL	(R3)			;CALL THE SERVICE ROUTINE
	POP	R4			;RESTORE REGISTERS
	POP	R3
	POP	R2
	POP	R1
	POP	R0
CHKBT4:	CLC				;MAKE SURE C IS CLEAR
	ROR	R0			;SHIFT THE MASK
	SOB	R2,CHKBT2		;CONTINUE IF MORE TO CHECK
	RETURN				;THATS ALL

;SUBROUTINE TO PROCESS CHANGE OF CARRIER DETECT BIT
;	CALL	CARIER

CARIER:
.IF NE ..XTD
	CMP	R2,#MINXT2#		;IS THIS A TERMINAL LINE?
	BHIS	4$			;NO
.ENDC
	BIT	R0,ADBMSB#(R4)		;YES-WHICH WAY DID THE BIT CHANGE?
	BEQ	2$			;IF JUST LOST CARRIER
	JMP	CARDET#			;TELL THE TERMINAL SERVICE WE HAVE
					;  CARRIER NOW

;HERE IF WE JUST LOST CARRIER

2$:	JMP	CARLOS#			;TELL THE TERMINAL SERVICE AND RETURN

;HERE FOR CARRIER CHANGE FOR NON-TERMINAL LINE

.IF NE ..XTD
4$:	MOV	#.LFCLS,R1		;ASSUME CARRIER LOSS
	BIT	R0,ADBMSB#(R4)		;RIGHT?
	BEQ	12$			;YES
	MOV	#.LFCDT,R1		;NO-ITS CARRIER DETECT
12$:	JMP	@DSXXTR#(R2)		;DISPATCH TO ROUTINE FOR THIS LINE
.ENDC

;SUBROUTINE TO PROCESS CHANGE OF RING INDICATOR BIT
;	CALL	RNGIND

RNGIND:
.IF NE ..XTD
	CMP	R2,#MINXT2#		;TERMINAL LINE?
	BHIS	RTN004			;NO-IGNORE THIS
.ENDC
	BIT	R0,ADBMSB#(R4)		;YES
	BEQ	RTN004			;IGNORE IT IF INDICATOR IS GOING AWAY
	JMP	RNGDET#			;TELL TERMINAL SERVICE WE HAVE A RING!
	.PAGE
	.SBTTL	LINB   - PURE DATA

	PURE

;TABLE OF BITS POSITIONED FOR EACH LINE

ASBBIT::.BYTE	001		;0TH LINE
	.BYTE	002		;1ST LINE
	.BYTE	004		;2ND LINE
	.BYTE	010		;3RD LINE
	.BYTE	020		;4TH LINE
	.BYTE	040		;5TH LINE
	.BYTE	100		;6TH LINE
	.BYTE	200		;7TH LINE

;TABLE OF VALUES FOR LPR FOR EACH BAUD RATE

ASBRAT:	.WORD	000000		; 0 =  AUTO-DETECT
	.WORD	010040		; 1 =    50   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	010440		; 2 =    75   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	011070		; 3 =   110   BAUD, 8 BITS, 2   STOP BITS
	.WORD	011720		; 4 =   134.5 BAUD, 7 BITS, 1   STOP BIT
	.WORD	012030		; 5 =   150   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		; 6 =   200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	012430		; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.WORD	012620		;10 =   300   BAUD, 7 BITS, 1   STOP BIT
	.WORD	000000		;11 =   400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	013030		;12 =   600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	013430		;13 =  1200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	014030		;14 =  1800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	014430		;15 =  2000   BAUD, 8 BITS, 1   STOP BIT
	.WORD	015030		;16 =  2400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	015430		;17 =  3600   BAUD, 8 BITS, 1   STOP BIT
	.WORD   016030		;20 =  4800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	016430		;21 =  7200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	017030		;22 =  9600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;23 = 19200   BAUD, 8 BITS, 1   STOP BIT

	.END

