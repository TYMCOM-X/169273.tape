	.TITLE	TRM   - TERMINAL SERVICE
	.SBTTL	TRM    - Nexilis/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

	.PSECT	ONCE,RW,I,LCL,REL,CON	;SET UP COMMENT IN CODE
	.ASCIZ	"TRM - TERMINAL SERVICE --DRE 12/1/80"
	.EVEN

	CODE

;Define conditional assembly defaults
.IF NDF ..X28		;--us701
  ..X28=!0
.ENDC
.IF NDF ..SAT
  ..SAT=!0			;Default is full terminal support (option is
.ENDC				;  for Tymsat support only)

;DEFINE SYMBOLS FOR INDEXES INTO THE CHARACTER DISPATCH TABLES

.CXNUL==!0		;NULL
.CXCNT==!2		;CONTROL CHARACTER
.CXBSP==!4		;BACK SPACE
.CXHTB==!6		;HORIZONTAL TAB
.CXLFD==!10		;LINE FEED
.CXVTB==!12		;VERTICAL TAB
.CXFFD==!14		;FORM FEED
.CXCRN==!16		;CARRIAGE RETURN
.CXDLE==!20		;DLE
.CXXON==!22		;X-ON
.CXDC2==!24		;DC2
.CXXOF==!26		;X-OFF
.CXCAN==!30		;CAN
.CXESC==!32		;ESCAPE
.CXUCA==!34		;UPPER CASE CHARACTER
.CXSMI==!36		;SEMI-COLON
.CXLCA==!40		;LOWER CASE CHARACTER
.CXHSP==!42		;HIGH SPECIAL CHARACTER
.CXRUB==!44		;RUB-OUT
.CXUNU==!46		;UNUSED NON-ASCII CODE
.CXUCS==!50		;UPPER CASE SHIFT (NON-ASCII INPUT ONLY)
.CXLCS==!52		;LOWER CASE SHIFT (NON-ASCII INPUT ONLY)
.CXPRE==!54		;PREFIX CODE
.CXEOT==!56		;EOT (2741 INPUT ONLY)
.IF NE ..X28
.CXCMA==!60		;comma
.CXDSH==!62		;dash
.IFF
.CXCMA==.CXUCA		;comma
.CXDSH==.CXUCA		;dash
.ENDC	;--us701
	.PAGE
	.SBTTL	TRM    - Initialization

;SUBROUTINE TO INITIALIZE TERMINAL SERVICE DDB
;	C(R4) = ADDRESS OF DDB
;	CALL	TRDDBI

TRDDBI::MAKPKT	.PLOPT#			;GET A PACKET
	BCC	2$			;OK IF GOT ONE
	FSTOP	NPA			;[NO PACKET AVAILABLE]
					;  THIS NODE IS IN BIG TROUBLE IS CANNOT
					;  GET A PACKET HERE!

2$:	ADD	#4,R1			;POINT TO FIRST BYTE TO USE
	MOV	R1,TRRNGP#		;INITIALIZE PUTTER POINTER
	MOV	R1,TRRNGT#		;AND TAKER POINTER
	RETURN				;THATS ALL

;SUBROUTINE TO INITIALIZE TERMINAL SERVICE SDB
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	TRSDBI

TRSDBI::MOV	#SDTRCZ#,R1		;NUMBER OF WORDS TO CLEAR
	MOV	#SDTRFC#,R2		;FIRST WORD TO CLEAR
	ADD	SD,R2
TRSDI2:	CLR	(R2)+			;CLEAR DEVICE DEPENDENT PART
	SOB	R1,TRSDI2
	MOV	#OUTIDL,SDTROD#(SD)	;SET INITIAL OUTPUT READY DISPATCH
	CALL	SETDFT#			;SETUP DEFAULT TYPE AND PROFILE
	PUSH	R4			;SAVE DDB ADDRESS
	MOV	SDTRAD#(SD),R4		;GET ADDRESS OF ADB FOR THIS LINE
	BEQ	6$			;IF NONE!
	CALL	@ADINIT#(R4)		;INITIALIZE THE INTERFACE
	TBBE	$S1AVL,SDSTS1#(SD),6$	;DOES THIS TERMINAL EXIST?
	TBBE	$T0HWR,SDTRS0#(SD),6$	;YES-HARDWIRED TERMINAL?
	CALL	SETRAT			;YES-SETUP BAUD RATE, ETC
	  NOP				;DON'T CARE IF AUTO-BAUD!
	CALL	ANSTRM			;"ANSWER" IT
6$:	POP	R4			;RESTORE ADDRESS OF DDB
RTN002:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	TRM    - Interrupt routines

;SUBROUTINE TO PROCESS INTERRUPT - THIS SUBROUTINE IS CALLED BY THE INTERFACE
;  DEPENDENT MODULES ON EACH INTERRUPT
;	C(R0) = LINE INDEX ,, DATA
;	C(R1) = FUNCTION
;	CALL	TRINTR

;*****	THE FOLLOWING 5 LINES OF CODE ADDED TO SOFT FAIL BETTER WITH BLOCK
;	MODE TERMINALS.  DRE 12/1/80
TRINTR::CMP	PKFCNT#,#.PLTRM#+7	;CHECK FOR ENOUGH PACKETS LEFT
	BGT	1$			;MORE THAN .PLTRM+2 PACKETS LEFT
	CMP	#.LFDAT,R1		;CHECK FOR DATA FUNCTION
	BNE	1$			;HANDLE NON-DATA FUNCTIONS
	CMPB	#37,R0			;CHECK FOR A CONTROL CHARACTER
;	BHIS	1$			;YES-STORE IT IN RING BUFFER
;	RETURN				;NO-LOSE CHARACTER-SORRY
	BLO	RTN002			;NO-LOSE CHARACTER-SORRY

1$:	PUSH	R1	      		;SAVE FUNCTION CODE
	MOV	TRRNGP#,R1		;GET PUTTER POINTER
	BIT	#77,R1			;AT END OF PACKET?
	BNE	6$			;NO-GO ON
	SUB	#100,R1			;YES-POINT TO START OF PACKET
	PUSH	R1			;SAVE ADDRESS OF PACKET
	MAKPKT	.PLTRM#			;GET ANOTHER PACKET
	BCC	2$			;GO ON IF GOT ONE
.IF NE  ..BUG
	FSTOP	OVX			;FOR DEBUGGING!!!
.ENDC
	ADD	#4,SP			;NO MORE-FIX UP THE STACK
	RETURN				;AND RETURN, DROPPING THE CHARACTER!

2$:	MOV	R1,@(SP)+		;LINK TO NEW PACKET
	ADD	#4,R1			;POINT TO FIRST DATA BYTE
6$:	MOV	R0,(R1)+		;STORE LINE + DATA
	POP	(R1)+			;STORE FUNCTION
	MOV	R1,TRRNGP#		;UPDATE PUTTER POINTER
	RETURN				;RETURN
	.PAGE
;	TEN TIMES A SECOND ROUTINE

	.SBTTL	TRM	- MOVCHR - MOVE CHARACTERS OUT AT EACH TENTH SEC CLOCK TICK


;This routine scans the terminal SDBs looking for one that need their buffers 
; sent along to the destinations

	TNHSEC	MOVCHR

MOVCHR:
	MOV	#T0$#,R4		;Set up DDB pointer
	MOV	#T0SX#,R2		;Set up SDB pointer
	MOV	#TRMTTL#,R1		;Set up count of terminals
5$:	MOV	(R2)+,SD
	TST	SDPKSP#(SD)		;Are there any packets on this SDB
	BEQ	20$			;No - look at next SDB
;.IF EQ ..SAT
	CMPB	#200,SDTRBS#(SD)	;Check for Tymshar mode
	BEQ	10$			;Not RSX or RSTS
	TBBE	$T1IMI,SDTRS1#(SD),30$	;Check for image mode
;.ENDC
10$:	PUSH	R1			;Image mode is send every char
	PUSH	R2
	MOV	SDPKSP#(SD),R2		;Get last packet in SRC list
	MOV	(R2),R1			;Get first packet in SRC list
	CLR	(R2)			;Clear end-around pointer
15$:	PUSH	(R1)			;Save address of next packet
	CALL	SNDPKT#			;Send this packet
	POP	R1			;Get address of next packet
	MOV	R1,SDPKSP#(SD)		;Make this the last packet
	BEQ	18$
	TST	(R1)			;Is this the last packet
	BNE	15$			;Continue if more than one left
	MOV	R1,(R1)			;Fix up end-around pointer
18$:	POP	R2
	POP	R1
20$:	SOB	R1,5$
	BR	TRMTEN			;Continue to clear block mode inhibit

;-----
;NOT TYMSHARE MODE, NOT IMAGE MODE INPUT.
;NOW CHECK FOR LINE EDITING FLAG, COMMAND MODE FLAG AND IDLE TIMER COUNT
;
; NO NEED TO RUN DOWN THE IDLE TIMER IF LINE EDITING IS ENABLED OR IN 
;  COMMAND MODE.
;-----
30$:
.IF	EQ	..SAT	
	TBBN	$T5EDT,SDTRS5#(SD),20$	;BRANCH IF LINE EDITING IS ENABLED
	TBBN	$T1CMD,SDTRS1#(SD),20$	;BRANCH IF IN COMMAND MODE
	PUSH	R1
	MOVB	SDTRT6#(SD),R1		;GET IDLE TIMER, IS IT ACTIVE?
	BEQ	40$			;NO, BRANCH
	DECB	R1			;EXPIRED?
	BEQ	35$			;YES, BRANCH
	DECB	R1			;TRY AGAIN, EVERY UNIT IS 1/20 OF A SECOND
35$:	MOVB	R1,SDTRT6#(SD)		;RESTORED THE UPDATED COUNTER
	BNE	40$			;UNEXPIRED, CONTINUE
	PUSH	R2
	CALL	SNDTRP#			;FORWARD WHAT'S BUFFERED SO FAR
	POP	R2
40$:	POP	R1
.ENDC
	BR	20$			;AND GO CHECK NEXT SDB

TRMTEN:	DECB	BLKMOK			;CLEAR UP BLOCK MODE INHIBIT
	BGE	10$
	CLRB	BLKMOK
10$:	RETURN
	.PAGE
	.SBTTL	TRM    - Once-a-second routines

	ONCSEC	TRSYNC			;INSERT INTO ONCE-A-SECOND LOOP

TRSYNC:
.IF EQ	..SAT
	MOV	CINCNT,R1		;Move statistics for listing
	MOV	R1,CINLST
	MOV	COTCNT,COTLST
	ADD	COTCNT,R1		;Start performing CPS calculation
	ADD	CPSLST,R1		;Addin old value
	ROR	R1			;OLD+NEW/2 -> R1
	ADD	R1,CPSLST		;(OLD + OLD + OLD + NEW)/2 -> OLD
	ROR	CPSLST			;(OLD + OLD + OLD + NEW)/4 -> OLD
	CLR	CINCNT			;Clear counters
	CLR	COTCNT
.ENDC
	DECB	TRSCNT			;Time for this yet?
	BGT	RTN001			;No
	MOVB	#3.,TRSCNT		;Yes-reset counter
	MOV	#TRMTTL#,R1		;GET NUMBER OF TERMINALS
	MOV	#T0SX#,R2		;POINTER TO SX TABLE
TRSYN1:	MOV	(R2)+,SD		;GET ADDRESS OF NEXT TERMINAL SDB
	TBBE	$T1ACX,SDTRS1#(SD),TRSYN4;GO ON IF NOT ACTIVE
	TBBE	$T1SYN,SDTRS1#(SD),TRSYN6;ACTIVE-GO FIX IT IF HUNG!
	BIC	#$T1SYN,SDTRS1#(SD)	;CLEAR SYNC BIT
TRSYN4:	SOB	R1,TRSYN1		;CONTINUE IF NOT FINISHED
RTN001:	RETURN				;YES

;HERE IF TERMINAL HAS HUNG

TRSYN6:	PUSH	R1			;SAVE COUNT
	PUSH	R2			;SAVE SX POINTER
	CALL	OUTRDY			;FAKE OUTPUT READY
	POP	R2			;RESTORE SX POINTER
	POP	R1			;RESTORE COUNT
	BR	TRSYN4			;CONTINUE

	.PAGE
	.SBTTL	TRM    - Main program routines

	MAINXX	TRMAIN			;INSERT CALL INTO MAIN PROGRAM LOOP

;SUBROUTINE CALLED FROM MAIN PROGRAM LOOP FOR NODE
;	NO REGISTERS SET UP
;	CALL	TRMAIN

TRMAIN:	CMP	TRRNGP#,TRRNGT#		;ANYTHING IN THE RING?
	BEQ	RTN001			;NO-JUST RETURN
	MOV	TRRNGT#,R1		;YES-GET POINTER
	BIT	#77,R1			;AT END OF PACKET?
	BNE	6$			;NO-GO ON
	SUB	#100,R1			;YES-POINT TO START OF PACKET
	PUSH	(R1)			;SAVE ADDRESS OF NEXT PACKET
	FREPKT				;GIVE UP THE EMPTY PACKET
	POP	R1			;RESTORE ADDRESS OF NEXT PACKET
	BNE	2$			;THERE MUST BE ONE!!
	FSTOP	BCL			;[BAD CHARACTER LIST]

2$:	ADD	#4,R1			;POINT TO FIRST CHARACTER
;*****	THE FOLLOWING CODE ADDED TO IMPROVE BLOCK MODE TERMINAL HANDLING
;	DRE	12/5/80
	MOV	R1,TRRNGT		;SAVE POINTER
	RETURN

6$:	CLR	R0
	BISB	(R1)+,R0		;GET DATA
	CLR	SD
	BISB	(R1)+,SD		;GET INDEX
	MOV	(R1)+,R2		;GET FUNCTION
	MOV	R1,TRRNGT		;UPDATE POINTER
	ASL	SD			;GET SDB ADDRESS
	MOV	T0SX#(SD),SD
;*****	DRE 12/5/80
;	THE FOLLOWING CHANGE MADE TO IMPROVE BLOCK MODE TERMINAL HANDLING
;	CJMP	@FNCDSP(R2)		;DISPATCH ON THE FUNCTION
	CALL	@FNCDSP(R2)		;DISPATCH ON THE FUNCTION
	BR	TRMAIN			;TRY FOR ANOTHER CHARACTER

;FUNCTION DISPATCH TABLE

	PURE

FNCDSP:	.WORD	OUTRDY			; 0 = .LFRDY   OUTPUT READY
	.WORD	TRDATA			; 2 = .LFDAT   DATA
	.WORD	RNGDET			; 4 = .LFRNG   RING DETECTED
	.WORD	BREAKR			; 6 = .LFBRK   BREAK RECEIVED
	.WORD	HUNGUP			;10 = .LFHNG   LINE HUNG UP
	.WORD	CARDET			;12 = .LFCDT   CARRIER DETECT
	.WORD	CARLOS			;14 = .LFCLS   CARRIER LOSS

	CODE
	.PAGE
	.SBTTL	TRM    - Input data ready

;SUBROUTINE TO PROCESS INPUT DATA FROM TERMINAL
;	C(R0) = DATA (8 BITS)
;	C(SD) = ADDRESS OF SDB FOR TERMINAL
;	CALL	TRDATA

TRDATA::
.IF EQ	..SAT
	INC	CINCNT			;COUNT THE CHARACTER
	MOVB	SDTRIT#(SD),SDTRT6#(SD)	;RESTART THE IDLE TIMER COUNT WHENEVER
					; INPUT IS DETECTED. (X.3 PARAMETER)
.ENDC
	MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@DATDSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR INPUT DATA

	PURE

DATDSP:	.WORD	DATA00		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	RTN001		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	RTN001		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	DATA06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	DATA10		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	DATA12		;.CSNRM = 12 - NORMAL
	.WORD	DATA06		;.CSBCL = 14 - CARRIER LOSS TIMEOUT - BAUD RATE DETECT
	.WORD	DATA10		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	DATA12		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN001		;.CSIGN = 22 - IGNORE EVERYTHING

.IF NE ..BUG
	IMPURE
NO377::	.BYTE	0		;NO. OF #377 GARBAGE PROCESSED BY DATA00
NORESY:	.BYTE	0		;NO. OF TIMES TO RESYNC PORT DUE TO TOO
				; MANY GARBAGE
	.BLKW	8.		;SOCKET 1 TO 8.
CT2741::.WORD	0
PT2741::.WORD	0
CR2741::.BLKB	20		;Storage to check CR of 2741
CREND=.
.ENDC

	CODE

;HERE FOR DATA CHARACTER FROM HUNG-UP TERMINAL

DATA00:	BIC	#^C177,R0		;GET JUST 7 BITS
	TBBN	$T0DDD,SDTRS0#(SD),22$	;US21- DO NOT ALLOW CR TO GET IN
					; SINCE PC MIGHT BE IN FILE TRANSFER
	TBBE	$T0HWR,SDTRS0#(SD),RTN001;IGNORE IT IF NOT HARDWIRED
	CMP	#CR,R0			;IS THIS RETURN?
	BEQ	1$			;YES-GO ON
22$:
.IF NE ..BUG
	TSTB	R0		;--US21
	BEQ	6$		;--US11, TREAT ZERO AS GARBAGE, HP444 BREAK
					;MIGHT GENERATE THESE.
	CMP	#177,R0			;IS THIS GARBAGE?
	BNE	2$			;NE, NO
6$:	
;	CLR	R1			;PREPARE TO USE R1
	MOVB	SDSOC#(SD),R1		;GET TERMINAL SOCKET NO.(1 orig.)
	ASL	R1			;WORD INDEX
	TSTB	NO377(R1)		;HOW MANY GARBAGE ALREADY?
	BMI	RTN001			;MI, TOO MANY
	BNE	4$			;NE, KEEP COUNTING
	INCB	NO377(R1)		;ELSE, =0, THE FIRST GARBAGE
	MOV	#JIFSEC#,R0		;MARK TIME FOR ONE SECOND
	MOV	#3$,R1			;WILL GOTO 3$
	CJMP	TIMREQ#
4$:	INCB	NO377(R1)		;ONE MORE
	CMPB	#100,NO377(R1)		;ARE THEY TOO MANY?
	BHI	RTN001			;HI, NOT QUITE
	MOVB	#200,NO377(R1)		;ELSE, SET FLAG SO NO MORE INCREMENT
	CJMP	BRDRST		;--US21, DISABLE RECEIVER
3$:
;	CLR	R1			;PREPARE TO USE R1
	MOVB	SDSOC#(SD),R1		;GET TERMINAL SOCKET NO.
	ASL	R1			;WORD INDEX
	TSTB	NO377(R1)		;HOW MANY GARBAGE ALREADY?
	BPL	5$			;PL, <64, IT IS NORMAL, IGNORE IT
;	PUSH	R1			;SAVE R1
;	CALL	CARD03			;ELSE, PRETEND AS CARRIER DETECT TO
;					; RESYNC THIS PORT
;	POP	R1			;RESTORE R1
	INCB	NORESY(R1)		;MAKE A NOTE
	INCB	NO377			;MAKE A TOTAL NOTE
5$:	CLRB	NO377(R1)		;CLEAR, SO NEXT GARBAGE WILL START
	RETURN				; TIMER AGAIN
.ENDC	;.IF NE ..BUG

2$:	CMP	#FS,R0			;NO-IS IT THE SPECIAL CMD MODE ENTRY?
	BNE	RTN001			;NO-IGNORE IT!
	BIS	#$T3ACA,SDTRS3#(SD)	;YES-DON'T LET AUTO-CONNECT HAPPEN!
1$:	CALL	SETDFT#			;SET UP DEFAULTS
DATA02:	JMP	STRCMD			;GO FINISH UP

;HERE FOR DATA CHARACTER WHEN STATE = .CSBRD

DATA06:	MOVB	SDTRBR#(SD),R1		;GET DETECT TYPE
	BIC	#^C$BRORT,R1
	JMP	@SDTRC1#(SD)		;DISPATCH TO DETECT ROUTINE

;HERE FOR DATA CHARACTER WHEN STATE = .CSSEL

DATA10:
.IF NE ..BUG
	MOV	PT2741,R1
	MOVB	R0,(R1)+
	INC	CT2741
	CMP	R1,#CREND
	BLO	2$
	MOV	#CR2741,R1
2$:	MOV	R1,PT2741
.ENDC
	BIC	#^C77,R0		;JUST 6 BITS
	CMP	#SLEOT,R0		;IS THIS AN EOT?
	BNE	RTN011			;NO-IGNORE IT
	MOVB	#.CSNRM,SDTRCS#(SD)	;YES-UPDATE THE STATE
	CALL	DATA12			;PROCESS THE EOT
	BR	DATA02			;AND GO TO COMMAND MODE
RTN011:	RETURN
;HERE FOR DATA CHARACTER WHEN STATE = .CSNRM

DATA12:	MOVB	SDTRXC#(SD),R2		;GET TRANSLATION INDEX
	BEQ	INPCH3			;GO ON IF ASCII
	TBBE	$T1IMI,SDTRS1#(SD),1$	;If not image mode input
	TBBE	$T1CMD,SDTRS1#(SD),INPCH3;If image mode and not command mode

;HERE FOR NON-IMAGE CHARACTER FOR NON-ASCII TERMINAL

1$:	BIC	#^C77,R0		;REDUCE CHARACTER TO 6 BITS
	TBBE	$T6EOA,SDTRS6#(SD),2$	;EXPECTING EOA NOW?
	BIC	#$T6EOA,SDTRS6#(SD)	;YES-BUT NOT ANY MORE!
	CMP	#SLEOA,R0		;IS THIS IT?
	BEQ	RTN011			;YES-IGNORE IT
2$:	TBBE	$T6ICX,SDTRS6#(SD),4$	;WAS LAST CHARACTER A PREFIX?
	CMPB	CODTSL#(R2),R0		;YES-IS THIS A SHIFT CHAR.?
	BEQ	4$			;YES
	CMPB	CODTSU#(R2),R0
	BEQ	4$
	BIC	#$T6ICX,SDTRS6#(SD)	;NO
	ADD	CODTIP#(R2),R0		;POINT TO ENTRY IN TABLE
	BR	6$			;CONTINUE

;HERE IF PREVIOUS CHARACTER WAS NOT PREFIX

4$:	TBBN	$T6ICU,SDTRS6#(SD),5$	;UPPER CASE?
	ADD	CODTIL#(R2),R0		;NO-LOWER CASE
	BR	6$			;CONTINUE

;HERE IF UPPER CASE CHARACTER

5$:	ADD	CODTIU#(R2),R0		;POINT TO TABLE ENTRY
6$:	MOVB	(R0),R0			;GET ASCII CHARACTER
	TBBE	$T4SEL,SDTRS4#(SD),INPCH3;GO ON IF NOT 2741 TERMINAL
	BIC	#^C377,R0		;REDUCE CODE TO 8 BITS
	BR	INPCH9			;CONTINUE

;HERE TO CONTINUE PROCESSING INPUT CHARACTER FOR ALL TERMINALS EXCEPT 2741

INPCH3:
.IF EQ ..SAT
	TBBN	$T1DEX!$T1CMD,SDTRS1#(SD),INPCH4;GO ON IF NOT DOING DEFERED
.IFF						;  ECHOING
	TBBN	$T1CMD,SDTRS1#(SD),INPCH9
.ENDC
	TBBE	$T6GBF,SDTRS6#(SD),INPCH9;IS A GREEN BALL OUTSTANDING?
	PUSH	R0			;YES-SAVE CHARACTER
	CALL	SNDRED			;SEND A RED BALL TO CANCEL THE GREEN
	POP	R0			;  BALL
.IF EQ ..SAT
	BR	INPCH9			;CONTINUE
.ENDC
	.PAGE
	.SBTTL	TRM    - Hold off input if output active

;HERE IF NOT DOING DEFERED ECHOING

.IF EQ ..SAT

INPCH4:	TBBE	$T1HIA!$T1CMD,SDTRS1#(SD),INPCH9;IF NOT BUFFERING INPUT WHEN
						;  OUTPUT IS ACTIVE
	TBBE	$T1ACT,SDTRS1#(SD),INPCH8;GO ON IF OUTPUT NOT ACTIVE NOW

;HERE IF WE HAVE INPUT WHEN OUTPUT IS ACTIVE (TYPE-AHEAD) - WE BUFFER THIS
;  INPUT USING THE PUTIHB-GETIHB ROUTINES UNTIL OUTPUT IS FINISHED - WE MUST
;  FIRST DETERMINE IF WE HAVE ONE OF THE FEW CHARACTERS WHICH MUST BE
;  PROCESSED AT THIS POINT - WE DO THIS WITH A DISPATCH TABLE FOR SPEED SINCE
;  ALMOST ALL INPUT CHARACTERS DO NOT REQUIRE PROCESSING HERE!

	TBBE	$T1IMI,SDTRS1#(SD),2$	;If not image input
	TBBE	$T1CMD,SDTRS1#(SD),TRXUCA;And not command mode
2$:	MOV	R0,R1			;Get 7 bits for dispatch
	BIC	#^C177,R1
	MOVB	CHRINX#(R1),R2		;GET DISPATCH INDEX
	JMP	@TRXDSP(R2)		;DISPATCH TO CHARACTER ROUTINE

;DISPATCH TABLE FOR PRE-INPUT PROCESSING

	PURE

TRXDSP:	.WORD	TRXUCA		;.CXNUL =  0 - NULL
	.WORD	TRXCNT		;.CXCNT =  2 - CONTROL CHARACTER
	.WORD	TRXUCA		;.CXBSP =  4 - BACK SPACE
	.WORD	TRXUCA		;.CXHTB =  6 - HORIZONTAL TAB
	.WORD	TRXUCA		;.CXLFD = 10 - LINE FEED
	.WORD	TRXUCA		;.CXVTB = 12 - VERTICAL TAB
	.WORD	TRXUCA		;.CXFFD = 14 - FORM FEED
	.WORD	TRXUCA		;.CXCRN = 16 - CARRIAGE RETURN
	.WORD	TRXUCA		;.CXDLE = 20
	.WORD	TRXXON		;.CXXON = 22 - X-ON
	.WORD	TRXUCA		;.CXDC2 = 24 - DC2
	.WORD	TRXXOF		;.CXXOF = 26 - X-OFF
	.WORD	TRXUCA		;.CXCAN = 30 - CAN
	.WORD	TRXCNT		;.CXESC = 32 - ESCAPE
	.WORD	TRXUCA		;.CXUCA = 34 - UPPER CASE CHARACTER
	.WORD	TRXUCA		;.CXSMI = 36 - SEMI-COLON
	.WORD	TRXUCA		;.CXLCA = 40 - LOWER CASE CHARACTER
	.WORD	TRXUCA		;.CXHSP = 42 - HIGH SPECIAL CHARACTER
	.WORD	TRXUCA		;.CXRUB = 44 - RUB-OUT
	.WORD	RTN007		;.CXUNU = 46 - NON-ASCII UNUSED CODE
	.WORD	TRXUCA		;.CXUCS = 50 - NON-ASCII UPPER CASE SHIFT
	.WORD	TRXUCA		;.CXLCS = 50 - NON-ASCII LOWER CASE SHIFT
	.WORD	TRIPRE		;.CXPRE = 52 - NON-ASCII PREFIX CODE
.IF NE ..X28
	.WORD	0		;54
	.WORD	0		;56
	.WORD	TRXUCA		;.CXCMA = 60 - COMMA
	.WORD	TRXUCA		;.CXDSH = 62 - DASH
.ENDC

	CODE

.ENDC		;.IF EQ ..SAT
	.PAGE
;HERE FOR CONTROL CHARACTER

.IF EQ ..SAT

TRXCNT:	CMPB	SDTRHI#(SD),R1		;IS THIS THE HARD INTERRUPT CHAR?
	BNE	INPCH5			;NO-GO ON
	CMPB	SDTRSI#(SD),R1		;YES-IS IT THE SAME AS THE SOFT
					;  INTERRUPT CHARACTER?
	BNE	TRXCC4			;NO-ITS ALWAYS HARD!
	TBBN	$T2ICI,SDTRS2#(SD),TRXCC2;YES-IS IT THE 2ND ONE?
	BIS	#$T2ICI,SDTRS2#(SD)	;NO-INDICATE WE SAW THE 1ST ONE
	BR	INPCH7			;AND JUST BUFFER IT

;HERE 2ND HARD INTERRUPT CHARACTER IN A ROW

TRXCC2:	PUSH	R0			;Save character
	CALL	CLRIHB#			;Clear any buffered input
	CALL	HLDOUT			;Hold output
	POP	R0			;Restore character
	BR	INPCH7			;Continue

;HERE ON HARD INTERRUPT CHARACTER WHICH IS DIFFERENT FROM SOFT INTERRUPT
;  CHARACTER

TRXCC4:	PUSH	R0			;SAVE CHARACTER
	CALL	CLRIHB#			;CLEAR INPUT HOLD BUFFER
	POP	R0			;RESTORE CHARACTER
	BR	INPCH6			;GO HOLD OUTPUT AND STORE CHARACTER

;HERE IF THIS IS NOT THE HARD INTERRUPT CHARACTER

INPCH5:	CMPB	SDTRCI#(SD),R1		;IS THIS THE COMMAND INTERRUPT CHAR?
	BEQ	INPCH6			;YES
	CMPB	SDTRSO#(SD),R1		;IS THIS THE SUPPRESS OUTPUT CHARACTER?
	BEQ	INPCH6			;YES
	BR	TRXUCA			;NO

;HERE FOR X-ON CHARACTER

TRXXON:	TBBE	$T4HOE,SDTRS4$(SD),TRXUCA;IF NOT ENABLED
	TBBN	$T5AOH,SDTRS5#(SD),TRXUCA;OR IF EXCESS SHOULD BE ACCEPTED
	RETURN				;ENABLED-IGNORE IT

;HERE FOR X-OFF CHARACTER

TRXXOF:	TBBE	$T4HOE,SDTRS4#(SD),TRXUCA;IS IT ENABLED?
INPCH6:	PUSH	R0			;Yes-save the character
	CALL	HLDOUT			;Hold output
	POP	R0			;Restore character

;HERE FOR ALL CHARACTERS WHICH DO NOT REQUIRE SPECIAL PROCESSING HERE

TRXUCA:	BIC	#$T2ICI,SDTRS2#(SD)	;INDICATE NOT HARD INTERRUPT CHAR.

INPCH7:	CALL	PUTIHB#			;Must buffer the character
	  NOP				;Ignore errors!
	RETURN

.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Process input character

;HERE WHEN WE ARE READY TO PROCESS INPUT CHARACTER - WE DO NOT PROCESS INPUT
;  UNLESS OUTPUT IS IDLE - IF OUTPUT IS NOT IDLE WHEN INPUT IS SEEN, THE
;  INPUT CHARACTERS ARE BUFFERED USING THE PUTIHB-GETIHB SUBROUTINES - WE
;  WILL EVENUTALLY GET HERE WITH THE CHARACTER WHEN OUTPUT IS IDLE (SEE CODE
;  AT OUTGET)

.IF EQ ..SAT
I:	BIS	#$T1ACT!$T1ACX!$T1SYN,SDTRS1#(SD);SET ACTIVE BITS
.ENDC
INPCH9:	TBBE	$T1IMI,SDTRS1#(SD),2$	;IF NOT IN IMAGE MODE
	TBBN	$T1CMD,SDTRS1#(SD),2$	;Or if command mode
	JMP	TRICNX			;IF IN IMAGE MODE

2$:	MOV	R0,R1			;COPY CHARACTER
	TSTB	SDTRXC#(SD)		;ASCII TERMINAL?
	BNE	4$			;NO
	BIC	#^C177,R1		;YES-JUST 7 BITS FOR COMPARES
;+--us701
.IF NE ..X28
	TBBE	$T1TLG,SDTRS1#(SD),4$	;if not allowed to get login mode
	BIC	#$T1TLG,SDTRS1#(SD)	;toggle off--disable login mode
	CMPB	R1,#'C			;is it a connect command?
	BEQ	3$			;Eq, yes
	CMPB	R1,#'c			;is it a connect command?
	BNE	4$			;NE, no
3$:	BIS	#$T3LGI,SDTRS3#(SD)	;get in login mode
.ENDC 
;---us701
4$:

.IF NE ..SAT

;CODE HERE FOR SPECIAL CHARACTER CHECKS FOR TYMSAT STUFF!!!!!

.ENDC

	.PAGE	
	.SBTTL	TRM    - Input of command interrupt character

;Here to check for command interrupt character

.IF EQ ..SAT
CHKCIC:
	CLR	R2
	MOVB	SDTRCI#(SD),R2		;PAD COMMAND RECALL POSSIBLE ?
	BEQ	CHKDEL			;NO, BRANCH
	CMPB	R2,#1			;YES, PAD RECALL USING <DLE> ?
	BNE	10$			;    NO, CHECK FOR OTHER CHAR.
	CMPB	R1,#DLE			;    YES, IS INPUT <DLE> ?
	BNE	CHKDEL			;	NO, BRANCH
	BR	20$			;	YES, TRY SWITCH TO CMD MODE
10$:
	CMPB	R2,R1			;NO, IS INPUT EQUAL TO PAD RECALL CHAR
	BNE	CHKDEL			;    NO, BRANCH
20$:
	TBBE	$T1CMD,SDTRS1#(SD),INPIC2;   YES-IN COMMAND MODE NOW?
INPIC1:	TBBE	$T6PND,SDTRS6#(SD),INPIC4;YES-COMMAND MODE IS OK IF IN COMMAND MODE!
					;IS A NETWORK HANDSHAKE PENDING?
	JMP	NOECHO			;Yes-ignore the character!

;HERE IF NOT CURRENTLY IN COMMAND MODE

INPIC2:	TBBE	$T0CMD,SDTRS0#(SD),CHKDEL;Is command mode allowed?

;HERE IF COMMAND MODE IS ALLOWED NOW

INPIC4:	PUSH	R0			;SAVE INPUT CHARACTER
	CALL	DELSRC#			;DELETE ALL BUFFERED INPUT
	  NOP				;Don't care if nothing there
	TBBN	$T4SEL,SDTRS4#(SD),2$	;Don't clear output hold for 2741's
	BIC	#$S1HLD,SDSTS1#(SD)	;Make sure hold is clear
2$:	BIC	#$T1SOP,SDTRS1#(SD)	;Also clear discard output
	BIC	#$T5AOX,SDTRS5#(SD)
	POP	R0			;RESTORE CHARACTER WHICH GOT US HERE
	TBBN	$T1DEX!$T1CMD,SDTRS1#(SD),6$;DOING DEFERRED ECHOING?
	TBBN	$T1ACT,SDTRS1#(SD),10$	;YES-FORGET ECHOING IF OUTPUT ACTIVE
6$:	CALL	ECHOIT			;ECHO IT
10$:	CALL	SETINU#		;--US801, MAKE SURE SOCKET IN USE
	MOV	#.CXCIN#,R2		;GET COMMAND DECODER INDEX
	JMP	CMDENT#			;GO TO COMMAND MODE!
.ENDC			;.IF EQ ..SAT

	.PAGE
	.SBTTL	TRM    - Input of character delete character

;Here to check for the character delete character

.IF EQ ..SAT

CHKDEL:	CMPB	SDTRDL#(SD),R1		;Is this the delete character?
	BNE	CHKLDC			;No-go check for line delete character
	TST	R1			;Maybe-Do we have a character delete char?
	BEQ	CHKLDC			;No-branch (or JMP CHKESQ)
	TBBN	$T1CMD,SDTRS1#(SD),2$	;Yes-if in command mode- ALWAYS ALLOW
	TSTB	SDTRES#(SD)		;PROCESSING INPUT ESC SEQUENCE?
	BNE	10$			;YES-JUNK THIS!
	BITB	#210,SDTRBS#(SD)	;NO-BREAK-ON-ALL CHRS OR TECO MODE?
	BNE	TRIDL9			;YES-JUST NORMAL CHARACTER
;------
;	TBBE	$T1HIA,SDTRS1#(SD),TRIDL9;ALSO NORMAL IF NOT HOLDING OFF INPUT
;  Disabled 06-11-82    IW
;  Don't want to hold input when output is active doesn't mean we don't
;   want line editing !
;------

;-------
; TREAT IT AS A NORMAL CHARACTER IF EDITING NOT ALLOWED
;	FOR X.3 PARAMETERS 15.-18.			06/03/82

	TBBE	$T5EDT,SDTRS5#(SD),TRIDL9

;-------
2$:	BIC	#$T2ICH!$T2ICI,SDTRS2#(SD);NOT HARD INTERRUPT CHARACTER
	TBBN	$T3LGI,SDTRS3#(SD),NOEC1O;IF LOGIN MODE
	TBBN	$T4EDB,SDTRS4#(SD),TRIDL4;IF SHOULD ECHO LIKE BACKSPACE
	CALL	DELCHR#			;DELETE A CHARACTER
	  BR	TRIDL3			;IF NOTHING TO DELETE
	TBBE	$T4LCP,SDTRS4#(SD),TRIDL1;GO ON IF NOT LOCAL COPY TERMINAL
	CMPB	#SPA,SDTRDL#(SD)	;IS THE DELETE CHARACTER NON-PRINTING?
	BGT	TRIDL1			;YES-ECHO EVEN IF LOCAL COPY
	CMPB	#DEL,SDTRDL#(SD)
	BEQ	TRIDL1			;YES
10$:	JMP	INPES2			;NO-FORGET IT

;Here if not local copy terminal

TRIDL1:	TBBE	$T1ECH!$T1ECM,SDTRS1#(SD),NOEC1O;FINISHED IF NO ECHO WANTED
	TBBE	$T1DEA,SDTRS1#(SD),2$	;IS DELETE ECHO ACTIVE?
	JMP	ECHOI2			;YES

2$:	BIS	#$T1DEA,SDTRS1#(SD)	;NO-BUT IT IS NOW!
	JMP	ECHOI1			;ECHO CHARACTER AFTER BACKSLASH

;HERE IF NOTHING TO DELETE NOW

TRIDL3:	TBBE	$T1DEA,SDTRS1#(SD),NOEC1O;FINISHED IF DELETE ECHO NOT ACTIVE
	BIC	#$T1DEA,SDTRS1#(SD)	;NOT ACTIVE ANY LONGER
	MOV	#'\,R0			;ECHO A BACKSLASH
	JMP	ECHOIT

;HERE TO ECHO DELETE CHARACTER LIKE BACKSPACE

TRIDL4:	TBBE	$T4LCP,SDTRS4#(SD),TRIDL6;JUST LIKE BACKSPACE IF NOT LOCAL COPY
	CALL	DELCHR#			;LOCAL COPY-DELETE CHARACTER
	  BR	NOEC1O			;IF NOTHING TO DELETE
	CMPB	#SPA,SDTRDL#(SD)	;IS DELETE CHARACTER NON-PRINTING?
	BGT	NOEC1O			;NO-FORGET IT
	CMPB	#DEL,SDTRDL#(SD)
	BEQ	TRIDL7			;YES-GO ECHO BACKSPACE
NOEC1O:	JMP	NOECHO			;NO

TRIDL6:	BIC	#$T2ICH!$T2ICI,SDTRS2#(SD);NOT HARD INTERRUPT CHARACTER
	CALL	DELCHR#			;DELETE A CHARACTER
	 JMP	INPES2			;FINISHED IF NOTHING TO DELETE
	TBBN	$T4LCP,SDTRS4#(SD),INPES2;OR IF LOCAL COPY TERMINAL
	TBBE	$T1ECH!$T1ECM,SDTRS1#(SD),INPES2;OR IF NO ECHO WANTED
	TBBN	$T4XBE,SDTRS4#(SD),TRIDL8;IF WANT EXTENDED ECHO
TRIDL7:	MOV	#BS,R0			;GET BACKSPACE CHARACTER
	JMP	OUTCH1			;AND GO OUTPUT IT

;HERE IF WANT EXTENDED ECHO (BS-SPA-BS)

TRIDL8:	MOV	#FPXBSE,R1		;GET FILLER POINTER
	JMP	STRFIL			;AND GO START OUTPUT

TRIDL9:	BR	INPTO4
.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Input of line delete character

;Here to check for line delete character

.IF EQ ..SAT

CHKLDC:	CMPB	SDTRLX#(SD),R1		;IS THIS THE LINE DELETE CHARACTER?
	BNE	CHKLRC			;No-go check for LINE DISPLAY CHARACTER
	TST	R1			;Maybe-do we have a line delete chr?
	BEQ	CHKLRC			;Nope-false alarm!
	TBBN	$T1CMD,SDTRS1#(SD),2$	;Yes-are we in command mode?
	TSTB	SDTRES#(SD)		;No-are we processing ESC sequence?
	BNE	INPES2			;YES-JUNK THIS!
	BITB	#210,SDTRBS#(SD)	;NO-BREAK-ON-ALL CHRS OR TECO MODE?
	BNE	INPTO4			;YES-JUST NORMAL CHARACTER
;------
;	TBBE	$T1HIA,SDTRS1#(SD),INPTO4;ALSO NORMAL IF NOT HOLDING OFF INPUT
;  Disabled 06-11-82    IW
;  Don't want to hold input when output is active doesn't mean we don't
;   want line editing !
;------

;-------
; TREAT IT AS A NORMAL CHARACTER IF LINE EDITING IS NOT ALLOWED.
;	FOR X.3 PARAMETER 15.-18. SUPPORT			06/03/82

	TBBE	$T5EDT,SDTRS5#(SD),INPTO4

;-------
2$:	BIC	#$T2ICH!$T2ICI,SDTRS2#(SD);NOT HARD INTERRUPT CHARACTER
	CALL	DELSRC#			;Delete the line
	  NOP
	CJMP	ECHOIF			;ECHO THE CHARACTER AND RETURN

.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Input of line retype character

;Here to check for line retype character

.IF EQ ..SAT

CHKLRC:	CMPB	SDTRRE#(SD),R1		;Is this the line retype character?
	BNE	CHKESQ			;No, GO CHECK FOR ESCAPE SEQUENCE
	TST	R1			;Maybe-Do we have a line retype char?
	BEQ	CHKESQ			;No-Input is null
	TBBN	$T1CMD,SDTRS1#(SD),4$	;ALLOW LINE EDITING IF IN CMD MODE
	BITB	#210,SDTRBS#(SD)	;Yes-Break-on-all-characters or Teco
					;  mode?
	BNE	2$			;Yes-also normal
;-------
; TREAT IT AS NORMAL CHARACTER IF LINE EDITING NOT ALLOWED
;	FOR X.3 PARAMETER 15.-18. SUPPORT			06/03/82

	TBBE	$T5EDT,SDTRS5#(SD),2$	;No-line editing allowed?
;-------
	TBBE	$T4LCP,SDTRS4#(SD),4$	;Yes-local copy terminal?
2$:	JMP	TRICNX			;Yes-just normal character

;Here to re-echo the current input line because the "line re-type" character
;  was input

4$:	TBBN	$T1ECH,SDTRS1#(SD),6$   ;BRANCH IF ECHOING
	JMP	NOECHO			;Ignore it if not echoing now
6$:	CALL	REECHO#			;Fix up the lists
	JMP	ECHOIT			;Go echo the character followed by
					;  the current input line

.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Input escape sequence processing

.IF EQ ..SAT

CHKESQ:	MOVB	SDTRES#(SD),R2		;GET ESC PROCESSING STATE
	ADD	R2,PC			;DISPATCH ON THE STATE
	BR	INPTO4			;.ESNRM = 0 - NORMAL
	BR	INPES0			;.ESSTR = 2 - START OF ESC SEQUENCE
	BR	INPTR1			;.ESTR1 = 4 - FIRST TRAILING CHARACTER
;	BR	INPTRL			;.ESTRL = 6 - LAST TRAILING CHARACTER

;HERE FOR LAST TRAILING CHARACTER

INPTRL:	CMP	#40,R1			;IS IT A CONTROL CHARACTER?
	BGT	INPTO4			;YES-JUST PROCESS IT!
INPTR0:	CLRB	SDTRES#(SD)		;NO-RESET STATE TO NORMAL
	BR	INPEST			;GO STORE CHARACTER

;HERE FOR FIRST TRAILING CHARACTER

INPTR1:	CMP	#40,R1			;IS IT A CONTROL CHARACTER?
	BGT	INPTO4			;YES-JUST PROCESS IT!
INPTR2:	MOVB	#.ESTRL,SDTRES#(SD)	;NO-UPDATE STATE
	BR	INPEST			;CONTINUE

;HERE FOR START OF ESC SEQUENCE

INPES0:	CMP	#40,R1			;IS IT A CONTROL CHARACTER?
	BGT	INPTO4			;YES-ITS ALMOST NORMAL!
	CMP	#60,R1			;NO-IS IT A NOISE CHARACTER?
	BGT	INPEST			;YES-JUST STORE IT
	CMP	#'O,R1			;DOES IT REQUIRE ONE TRAILING CHARACTER?
	BEQ	INPTR2			;YES
	CMP	#'P,R1
	BEQ	INPTR2
	CMP	#'?,R1
	BEQ	INPTR2
	CMP	#'Y,R1			;DOES IT REQUIRE TWO?
	BNE	INPTR0			;NO-THATS THE LAST ONE!
	MOVB	#.ESTR1,SDTRES#(SD)	;YES-UPDATE STATE
INPEST:	CALL	PUTCHR#			;STORE THE CHARACTER
	  BR	INPES2			;If failure
	TSTB	SDTRES#(SD)		;END OF ESC SEQUENCE?
	BNE	INPES2			;NO-GO ON
	CALL	SNDTRP#			;YES-SEND THE PACKET
INPES2:	JMP	NOECHO			;GO FINISH UP

.ENDC		;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Dispatch on input character

;HERE FOR NORMAL INPUT (NO ESC SEQUENCE IN PROGRESS)

INPTO4:	MOVB	CHRINX#(R1),R2		;GET INDEX
.IF EQ ..SAT
	TBBE	$T1CMD!$T1DEX,SDTRS1#(SD),2$;USE RIGHT TABLE IF DEFERRED MODE
	JMP	@TRIDSP(R2)		;GO PROCESS CHARACTER
.ENDC

2$:	TBBE	$T1ACT,SDTRS1#(SD),4$	;Is output active now?
	PUSH	R0
	PUSH	R1
	PUSH	R2
	CALL	DEFENT			;Yes-defer echoing
	  BR	10$			;If error
	POP	R2
	POP	R1
	POP	R0
4$:	JMP	@TRYDSP(R2)		;Dispatch

;HERE IF ERROR RETURN FROM DEFENT

10$:	ADD	#6,SP			;FIX UP THE STACK
	BR	NOEC2O			;THATS ALL
	.PAGE
	.SBTTL	TRM    - Input character dispatch tables

;DISPATCH TABLE FOR NORMAL TERMINALS OR TERMINALS IN COMMAND MODE

	PURE

.IF EQ ..SAT

TRIDSP:	.WORD	TRICNX		;.CXNUL =  0 - NULL
	.WORD	TRICNT		;.CXCNT =  2 - CONTROL CHARACTER
	.WORD	TRIBSP		;.CXBSP =  4 - BACK SPACE
	.WORD	TRIHTB		;.CXHTB =  6 - HORIZONTAL TAB
	.WORD	TRILFD		;.CXLFD = 10 - LINE FEED
	.WORD	TRIVTB		;.CXVTB = 12 - VERTICAL TAB
	.WORD	TRIFFD		;.CXFFD = 14 - FORM FEED
	.WORD	TRICRN		;.CXCRN = 16 - CARRIAGE RETURN
	.WORD	TRIDLE		;.CXDLE = 20 - DLE
	.WORD	TRIXON		;.CXXON = 22 - X-ON
	.WORD	TRIDC2		;.CXDC2 = 24 - DC2
	.WORD	TRIXOF		;.CXXOF = 26 - X-OFF
	.WORD	TRICAN		;.CXCAN = 30 - CAN
	.WORD	TRIESC		;.CXESC = 32 - ESCAPE
	.WORD	TRIUCA		;.CXUCA = 34 - UPPER CASE CHARACTER
	.WORD	TRISMI		;.CXSMI = 36 - SEMI-COLON
	.WORD	TRILCA		;.CXLCA = 40 - LOWER CASE CHARACTER
	.WORD	TRIHSP		;.CXHSP = 42 - HIGH SPECIAL CHARACTER
	.WORD	TRICNT		;.CXRUB = 44 - RUB-OUT
	.WORD	RTN007		;.CXUNU = 46 - NON-ASCII UNUSED CODE
	.WORD	TRIUCS		;.CXUCS = 50 - NON-ASCII UPPER CASE SHIFT
	.WORD	TRILCS		;.CXLCS = 52 - NON-ASCII LOWER CASE SHIFT
	.WORD	TRIPRE		;.CXPRE = 54 - NON-ASCII PREFIX CODE
	.WORD	TRIEOT		;.CXEOT = 56 - 2741 EOT
.IF NE ..X28
	.WORD	TRICMA		;.CXCMA = 60 - comma
	.WORD	TRIDSH		;.CXDSH = 62 - dash
.ENDC

.ENDC

;DISPATCH TABLE FOR TERMINALS USING DEFERED ECHO PROTOCOL

TRYDSP:	.WORD	TRYCNT		;.CXNUL =  0 - NULL
	.WORD	TRYCNT		;.CXCNT =  2 - CONTROL CHARACTER
	.WORD	TRYBSP		;.CXBSP =  4 - BACK SPACE
	.WORD	TRYHTB		;.CXHTB =  6 - HORIZONTAL TAB
	.WORD	TRILFD		;.CXLFD = 10 - LINE FEED
	.WORD	TRYCNT		;.CXVTB = 12 - VERTICAL TAB
	.WORD	TRYCNT		;.CXFFD = 14 - FORM FEED
	.WORD	TRICRN		;.CXCRN = 16 - CARRIAGE RETURN
	.WORD	TRYDLE		;.CXDLE = 20 - DLE
	.WORD	TRYXON		;.CXXON = 22 - X-ON
	.WORD	TRYDC2		;.CXDC2 = 24 - DC2
	.WORD	TRYXOF		;.CXXOF = 26 - X-OFF
	.WORD	TRYCAN		;.CXCAN = 30 - CAN
	.WORD	TRYESC		;.CXESC = 32 - ESCAPE
	.WORD	TRIUCA		;.CXUCA = 34 - UPPER CASE CHARACTER
	.WORD	TRISMI		;.CXSMI = 36 - SEMI-COLON
	.WORD	TRILCA		;.CXLCA = 40 - LOWER CASE CHARACTER
	.WORD	TRYHSP		;.CXHSP = 42 - HIGH SPECIAL CHARACTER
	.WORD	TRYCNT		;.CXRUB = 44 - RUB-OUT
	.WORD	RTN007		;.CXUNU = 46 - NON-ASCII UNUSED CODE
	.WORD	TRIUCS		;.CXUCS = 50 - NON-ASCII UPPER CASE SHIFT
	.WORD	TRILCS		;.CXLCS = 52 - NON-ASCII LOWER CASE SHIFT
	.WORD	TRIPRE		;.CXPRE = 54 - NON-ASCII PREFIX CODE
	.WORD	TRIEOT		;.CXEOT = 56 - 2741 EOT
.IF NE ..X28
	.WORD	TRIUCA		;.CXCMA = 60 - comma
	.WORD	TRIUCA		;.CXDSH = 62 - dash
.ENDC

	CODE
	.PAGE
	.SBTTL	TRM    - Process special input characters for non-ascii terminals

;HERE FOR UPPER CASE SHIFT CHARACTER FROM NON-ASCII TERMINAL

TRIUCS:	BIS	#$T6ICU,SDTRS6#(SD)	;INDICATE UPPER CASE INPUT NOW
	RETURN				;THATS ALL

;HERE FOR LOWER CASE SHIFT CHARACTER FROM NON-ASCII TERMINAL

TRILCS:	BIC	#$T6ICU,SDTRS6#(SD)	;INDICATE LOWER CASE INPUT NOW
	RETURN				;THATS ALL

;HERE FOR PREFIX CHARACTER FROM NON-ASCII TERMINAL

TRIPRE:	BIS	#$T6ICX,SDTRS6#(SD)	;INDICATE LAST CHARACTER WAS PREFIX
RTN007:	RETURN				;THATS ALL

;Here for EOT character from 2741 terminal - note that 2741's never use
;  the input hold-off stuff, even if the bits for the terminal say they
;  should! Thus the output active bits are always meaningful here!!

TRIEOT:	BIS	#$T6LMB,SDTRS6#(SD)	;INDICATE TERMINAL IS IN "LIMBO" NOW
	BIC	#$S1HLD,SDSTS1#(SD)	;DON'T HOLD OUTPUT NOW
	TBBE	$T1CMD,SDTRS1#(SD),4$	;GO ON IF NOT IN COMMAND MODE
	TBBE	$T6CMW,SDTRS6#(SD),6$	;OR IF NOT WAITING FOR A COMMAND
	JMP	ENBKEY#			;HE MUST HAVE TYPED ATTN-ENABLE K.B.

4$:	CALL	SNDGRX			;OTHERWISE SEND A GREEN BALL
6$:	TBBN	$T1ACT,SDTRS1#(SD),RTN007;Nothing more needed if output active
	JMP	OUTRD1			;Otherwise go start output
	.PAGE
	.SBTTL	TRM    - Input of non-printing character with defered echoing

;HERE FOR INPUT OF CONTROL CHARACTER WITH DEFERRED ECHOING

TRYCNT:	CALL	DEFENT			;ENTER DEFERRED ECHO MODE
	  BR	FAICTL			;IF CAN'T DO IT
2$:	CALL	PUTCHR#			;Store character
	  NOP				;Don't care about errors
	RETURN

FAICTL:	CALL	RNGBEL#			;Ring his bell
NOEC2O:	JMP	NOECHO
	.PAGE
	.SBTTL	TRM    - Input of non-printing character with normal echoing

;HERE FOR INPUT OF CONTROL CHARACTER WITH NORMAL ECHOING

	.PAGE
	.SBTTL	TRM    - Input of hard interrupt character

;Here to check for hard interrupt character

.IF EQ ..SAT
TRICNT:
CHKHIC:	CMPB	SDTRHI#(SD),R1		;Is this the hard interrupt character?
	BNE	CHKSIC			;No
	CMPB	SDTRSI#(SD),R1		;Yes-is the soft interrupt char the same?
	BNE	INPIN6			;NO
	TBBN	$T2ICH,SDTRS2#(SD),INPIN6;YES-IS THIS THE 2ND IN A ROW?
	BIS	#$T2ICH!$T2ICI,SDTRS2#(SD);NO-INDICATE WE HAVE ONE
					;AND FALL INTO SOFT INTERRUPT ROUTINE
.ENDC

	.SBTTL	TRM    - Input of soft interrupt character

;Here to check for soft interrupt character

.IF EQ ..SAT

CHKSIC:	CMPB	SDTRSI#(SD),R1		;Is this the soft interrupt character?
	BNE	CHKOSC			;No
	TBBN	$T1CMD,SDTRS1#(SD),INPIN8;If in command mode now
	PUSH	R0			;Yes-save character
	CALL	DELSRC#			;Delete the current line
	  NOP				;Don't care if nothing there
	TBBN	$T4SEL,SDTRS4#(SD),2$	;Don't clear output hold for 2741's
	BIC	#$S1HLD,SDSTS1#(SD)	;Make sure output hold is clear
2$:	BIC	#$T5AOX,SDTRS5#(SD)
	MOV	#.PTFUN,R0		;Build a function packet
	CALL	CTLPKT#
	BCC	INPIN3			;Go on if OK
FAICT2:	TST	(SP)+			;Error-fix up the stack
	JMP	FAICTL			;And fail

INPIN3:	MOV	#.FNSIN,R0		;Function = soft interrupt
INPIN4:	CALL	CTLSTR#
	MOV	(SP),R0			;Data = character typed
	CALL	CTLSTE#
	POP	R0			;Get character
	JMP	ECHOIT			;And go echo it

;Here to really do hard interrupt

INPIN6:	TBBN	$T1CMD,SDTRS1#(SD),INPIN8;IF IN COMMAND MODE NOW
	PUSH	R0			;SAVE THE CHARACTER
	CALL	DELSRC#			;DELETE ALL INPUT
	  NOP				;Don't care if nothing there
	TBBN	$T4SEL,SDTRS4#(SD),2$	;Don't clear output hold for 2741's
	BIC	#$S1HLD,SDSTS1#(SD)	;Clear output hold bit
2$:	BIS	#$T1SOP,SDTRS1#(SD)	;Set discard output bit
	BIC	#$T5AOX,SDTRS5#(SD)
	MOV	#.PTEAT,R0		;BUILD AN "EAT" PACKET
	CALL	CTLPKX#			;IGNORE PACKET QUOTAS
	BCS	FAICT2			;IF CAN'T MAKE PACKET
	MOV	#.FNHIN,R0		;FUNCTION = HARD INTERRUPT
	BR	INPIN4			;CONTINUE
INPIN8:	JMP	INPIC1			;
.ENDC
	.PAGE
	.SBTTL	TRM    - Input of output suppress character

;Here to check for the output suppress character

.IF EQ ..SAT

CHKOSC:	CMPB	SDTRSO#(SD),R1		;Is this the output suppress character?
	BNE	CHKSRC			;No
	TBBN	$T4SEL,SDTRS4#(SD),CHKSRC;Yes-ignore if 2741
	BIC	#$S1HLD,SDSTS1#(SD)	;Make sure output hold is clear
	BIC	#$T5AOX,SDTRS5#(SD)
	TBBE	$T1CMD,SDTRS1#(SD),TRISO2;IF NOT IN COMMAND MODE
	MOV	#$T1SOP,R1		;CHANGE STATE OF THE BIT
	XOR	R1,SDTRS1#(SD)
	CJMP	ECHOIT			;ECHO CHARACTER AND RETURN

;HERE IF NOT IN COMMAND MODE

TRISO2:	PUSH	R0			;SAVE CHARACTER TYPED
	BIS	#$T1SOP,SDTRS1#(SD)	;ALWAYS SET THE BIT HERE!
	MOV	#.PTINT,R0		;MAKE INTERRUPT PACKET
	CALL	CTLPKX#
	BCS	FAICT2			;IF CAN'T MAKE PACKET
	MOV	#.FNOPS,R0		;FUNCTION = SUPPRESS OUTPUT
	BR	INPIN4			;CONTINUE

.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Input of status request character

;Here to check for status request character

.IF EQ ..SAT

CHKSRC:	CMPB	SDTRSR#(SD),R1		;Is this the status reqeust character?
	BNE	TRICNX			;No
	TBBN	$T1CMD,SDTRS1#(SD),TRICNX;Yes-in command mode?
	BITB	#210,SDTRBS#(SD)	;No-break-on-all-character or teco mode?
	BNE	TRICNX			;Yes-this character is not special!
	MOV	#.PTINT,R0		;Make an interrupt packet
	CALL	CTLPKT#
	BCS	4$
	MOV	#.FNSRQ,R0		;Make it a status request packet
	CALL	CTLSTE#			;  and send it
4$:	JMP	NOECHO

.ENDC

;Here for normal control character

TRICNX:	CALL	PUTCHR#			;Store character
	  BR	NOEC3O			;If error
	JMP	ECHOIF			;Continue

NOEC3O:	JMP	NOECHO
	.PAGE
	.SBTTL	TRM    - Input of backspace character

;HERE FOR INPUT OF BACKSPACE WITH DEFERRED ECHO

.IF NE ..SAT
  TRIBSP:
.ENDC
TRYBSP:	TBBE	$T3LGI,SDTRS3#(SD),TRYBS2;Go on if not login mode
LGIBSP:	TBBE	$T1ECH,SDTRS1#(SD),TRYBS1;Check for password input
	BIS	#$T4LCP,SDTRS4#(SD)	;Not password - Indicate local copy terminal
TRYBS1:	CALL	PUTCHR#			;Send it on its way
	 NOP
	BR	TRIBS3			;Thats all

TRYBS2:	TBBE	$T5BDE,SDTRS5#(SD),TRIBS3;Should backspace be special?
	JMP	TRYCNT			;YES-GO DEFER ECHOING

;HERE FOR INPUT OF BACKSPACE WITH NORMAL ECHOING

.IF EQ ..SAT
TRIBSP:	TBBN	$T3LGI,SDTRS3#(SD),LGIBSP;If login mode
	TBBN	$T1CMD,SDTRS1#(SD),4$	;IF IN COMMAND MODE
	BITB	#210,SDTRBS#(SD)	;BREAK-ON-ALL CHRS OR TECO MODE?
	BNE	TRIBS3			;YES-JUST NORMAL CHARACTER
	TBBE	$T1HIA,SDTRS1#(SD),TRIBS3;ALSO NORMAL IF NOT HOLDING OFF INPUT
	TBBE	$T5BDE,SDTRS5#(SD),TRIBS3;ALSO NORMAL IF BACKSPACE DELETE NOT
					 ;  SET
4$:	JMP	TRIDL6
.ENDC

;Here if backspace is normal input character

TRIBS3:	TBBN	$T4LCP,SDTRS4#(SD),2$	;Local copy?
	JMP	TRICNX			;No

2$:	TSTB	SDTRHP#(SD)		;Yes-at beginning of line now?
	BEQ	NOEC3O			;Yes-don't mess up the count!
	DECB	SDTRHP#(SD)		;No-adjust position
	BR	NOEC3O
	.PAGE
	.SBTTL	TRM    - Input of horizontal tab with defered echoing

;Here for input of horizontal tab with defered echoing

TRYHTB:	TBBN	$T5EHT,SDTRS5#(SD),TRIHTB;Should we echo this?
	JMP	TRYCNT			;No

	.SBTTL	TRM    - Input of horizontal tab with normal echoing

;Here for input of horizontal tab with normal echoing

TRIHTB:	CALL	PUTCHR#			;Store character
	  BR	10$			;If error
	TBBE	$T4LCP,SDTRS4#(SD),ECHO4F;Go on if not local copy
.IF EQ ..SAT
	TBBE	$T4HTS,SDTRS4#(SD),4$	;Local copy-no echo unless simulated
	TBBE	$T1DEX!$T1CMD,SDTRS1#(SD),4$
	TBBE	$T1HIA,SDTRS1#(SD),2$	;Are we holding input?
	TBBN	$T1ACT,SDTRS1#(SD),NOEC4O;Yes-forget this if output active
2$:	CJMP	TROHT1			;Go simulate the horizontal tab
.ENDC

;Here for local copy terminal with real horizontal tab to adjust the
;  horizontal position on the line

4$:	BISB	#7,SDTRHP#(SD)		;Advance horizontal position
	INCB	SDTRHP#(SD)
10$:	BR	NOEC4O			;No echo
	.PAGE
	.SBTTL	TRM    - Input of veritcal tab with normal echoing

;Here for input of vertical tab with normal echoing

.IF EQ ..SAT
TRIVTB:	CALL	PUTCHR#			;Store character
	  BR	NOEC4O			;If error
	TBBE	$T4LCP,SDTRS4#(SD),ECHO4F;Go on if not local copy
	TBBE	$T4VTS,SDTRS4#(SD),NOEC4O;Local copy-no echo unless simulated
	TBBE	$T1HIA,SDTRS1#(SD),2$	;Are we holding input?
	TBBN	$T1ACT,SDTRS1#(SD),NOEC4O;Yes-forget this if output active
2$:	CJMP	TROVT1			;Go simulate the vertical tab
.ENDC

	.SBTTL	TRM    - Input of form feed with normal echoing

;Here for input of form feed with normal echoing

.IF EQ ..SAT
TRIFFD:	CALL	PUTCHR#			;Store character
	  BR	NOEC4O			;If error
	TBBE	$T4LCP,SDTRS4#(SD),ECHO4F;Go on if not local copy
	TBBE	$T4FFS,SDTRS4#(SD),NOEC4O;Local copy-no echo unless simulated
	TBBE	$T1HIA,SDTRS1#(SD),2$	;Are we holding input?
	TBBN	$T1ACT,SDTRS1#(SD),NOEC4O;Yes-forget this if output active
2$:	CJMP	TROFF1			;Go simulate the form feed
.ENDC

ECHO4F:	JMP	ECHOIF
	.PAGE
	.SBTTL	TRM    - Input of ESC

;HERE FOR INPUT OF ESCAPE IN DEFERED ECHO MODE

TRYESC:	TBBN	$T3LGI,SDTRS3#(SD),TRYES2 ;HANDLE ESCAPE IN LOGIN MODE
	TBBE	$T6ECE,SDTRS6#(SD),TRYC3T ;TREAT AS CONTROL INPUT
	JMP	TRIUCA			;JUST ECHO AND SEND TO HOST
TRYES2:	CALL	PUTCHR#			;SEND THE CHARACTER
	 NOP
	CJMP	SNDTRP#			;FLUSH THE BUFFER

;HERE FOR INPUT OF ESC IN NORMAL MODE

.IF EQ ..SAT
TRIESC:
;-----
; IF AN <ESC> IS RECEIVED IN TYMNET LOGIN MODE, THE COMMAND DECODER (CMDTYM)
; SHOULD BE ENTERED AT THE COMMAND INTERRUPT ENTRY POINT
;
	TBBE	$T3LGI,SDTRS3#(SD),10$	;BRANCH IF NOT IN LOGIN MODE
	JMP	INPIC4			;GO HANDLE <ESC> LIKE A CMD. INTERRUPT
10$:
;-----
	TBBE	$T5ESQ,SDTRS5#(SD),TRIC3T;SHOULD WE HANDLE ESC SEQUENCES?
	TBBN	$T1CMD,SDTRS1#(SD),TRIC3T;YES-BUT NEVER IN COMMAND MODE!
	MOVB	#.ESSTR,SDTRES#(SD)	;OK-SET INPUT STATE
	JMP	INPEST			;AND GO STORE THE ESC CHARACTER
.ENDC

	.SBTTL	TRM    - Input of control-X

;HERE FOR INPUT OF ^X WITH DEFERRED ECHOING
;
; **** Add checks for control characters in password portion
; **** of login string. gmt 2/23/82

TRYCAN:	TBBE	$T3LGI,SDTRS3#(SD),TRYC3T;NOT SPECIAL IF NOT LOGIN MODE
.IF NE ..SAT
  TRICAN:
.ENDC
LGICAN:	TBBE	$T1ECH,SDTRS1#(SD),TRYCC2;Check for password input  ***2/23/82
	BIS	#$T4HIE,SDTRS4#(SD)	;Not password -INDICATE INPUT HOLD ENABLED
	BR	NOEC4O			;THATS ALL

;HERE FOR INPUT OF ^X WITH NORMAL ECHOING

.IF EQ ..SAT
TRICAN:	TBBE	$T3LGI,SDTRS3#(SD),TRIC3T;NOT SPECIAL IF NOT LOGIN MODE
	BR	LGICAN
.ENDC
	.PAGE
	.SBTTL	TRM    - Input of control-P

;HERE FOR INPUT OF ^P WITH DEFERRED ECHOING

TRYDLE:	TBBE	$T3LGI,SDTRS3#(SD),TRYC3T;NOT SPECIAL IF NOT LOGIN MODE
.IF NE ..SAT
  TRIDLE:
.ENDC
LGIDLE:	TBBE	$T1ECH,SDTRS1#(SD),TRYCC2;Check for password input  ***2/23/82
	BIS	#$T4PAR,SDTRS4#(SD)	;Enable parity handling
	BIC	#$T4ODD!$T4CHK,SDTRS4#(SD);Even parity and no checking of input
	MOV	#.LFSET,R0		;Reset the interface hardware
	CALL	TRMFNC
	BR	NOEC4O			;Continue

;HERE FOR INPUT OF ^P WITH NORMAL ECHOING

.IF EQ ..SAT
TRIDLE:	TBBE	$T3LGI,SDTRS3#(SD),TRIC3T;NOT SPECIAL IF NOT LOGIN MODE
	BR	LGIDLE
.ENDC

	.SBTTL	TRM    - Input of control-R

;HERE FOR INPUT OF ^R WITH DEFERRED ECHOING

TRYDC2:	TBBN	$T3LGI,SDTRS3#(SD),LGIDC2;Only special if login mode
TRYC3T:	JMP	TRYCNT			;Otherwise not special

.IF NE ..SAT
  TRIDC2:
.ENDC
LGIDC2:	TBBE	$T1ECH,SDTRS1#(SD),TRYCC2;Check for password input  ***2/23/82
	BIS	#$T4HOE,SDTRS4#(SD)	;INDICATE OUTPUT HOLD ENABLED
NOEC4O:	JMP	NOECHO

;HERE FOR INPUT OF ^R WITH NORMAL ECHOING

.IF EQ ..SAT
TRIDC2:	TBBN	$T3LGI,SDTRS3#(SD),LGIDC2;Only special if login mode
TRIC3T:	JMP	TRICNT			;Otherwise normal
.ENDC

TRYCC2:	CALL	PUTCHR#			;Send char on its way   ***2/23/82
	 NOP				;   ***2/23/82
	BR	 NOEC4O			;   ***2/23/82

	.PAGE
	.SBTTL	TRM    - Input of control-S (X-Off)

;HERE FOR X-OFF (^S) [ASCII 023]

TRYXOF:	CALL	HNDXOF			;DO THE WORK
	  BR	NOEC4O			;If should not be input
	BR	TRYC3T			;If should be input

.IF EQ ..SAT
TRIXOF:	CALL	HNDXOF			;Do the work
	  BR	NOEC4O			;If should not be input
	BR	TRIC3T			;If should be input
.ENDC

	.SBTTL	TRM    - Input of control-Q (X-On)

;HERE FOR X-ON (^Q) [ASCII 021]

TRYXON:	CALL	HNDXON			;DO THE WORK
	  BR	NOEC4O			;IF DON'T WANT THE CHARACTER
	BR	TRYC3T			;ACCEPT CHARACTER AS INPUT

.IF EQ ..SAT
TRIXON:	CALL	HNDXON			;DO THE WORK
	  BR	NOEC4O			;IF DON'T WANT THE CHARACTER
	BR	TRIC3T			;ACCEPT CHARACTER AS INPUT
.ENDC

	.PAGE
	.SBTTL	TRM    - Input of carriage return

;HERE FOR INPUT OF CARRIAGE RETURN

TRICRN:	TBBE	$T3LGI,SDTRS3#(SD),TRICR2;ARE WE IN LOGIN MODE?
	CALL	TRICR2			;YES
.IF NE ..X28
	BIS	#$T1ECH!$T1ECM,SDTRS1#(SD);enable MODE--us701
.IFF
	BIC	#$T1ECH!$T1ECM,SDTRS1#(SD);CLEAR ECHO MODE
.ENDC
	CJMP	SNDTRP#			;FLUSH THE CHARS


TRICR2:	CALL	CHKTWO#			;SEE IF ROOM FOR TWO MORE CHARACTERS
	  BR	NOEC4O			;IF NOT
	CALL	PUTCHR			;STORE CARRIAGE RETURN CHARACTER
	  BR	NOEC4O			;BUT WE ALREADY CHECKED!
	TBBN	$T1CMD,SDTRS1#(SD),2$	;ALWAYS ADD L.F. IF COMMAND MODE
	TBBE	$T2SLC,SDTRS2#(SD),4$	;SHOULD WE ADD A L.F.?
2$:	PUSH	R0			;YES
	MOV	#LF,R0			;PICK UP A LINE FEED CHARACTER
	CALL	PUTCHR			;STORE IT TOO
	  NOP				;BUT WE ALREADY CHECKED!
	POP	R0			;RESTORE CHARACTER
4$:	TBBE	$T4LCP,SDTRS4#(SD),10$	;Go on if not local copy
	MOV	#FPLINF,R0		;Local copy-get filler pointer
	MOV	#$T2ELC,R1		;And bit to test
	CALL	CRNDLY			;Calculate C.R. delay
	BR	TRILF2			;Continue with common code

;Here if not local copy

10$:	TBBN	$T1HIA!$T1CMD,SDTRS1#(SD),ECHO3F;IF NOT HOLDING OFF INPUT FOR OUTPUT
	TBBE	$T1ACT,SDTRS1#(SD),ECHO3F;OR IF OUTPUT NOT ACTIVE NOW
.IF EQ ..SAT
	TBBE	$T1DEX,SDTRS1#(SD),NOEC4O;FORGET IT IF DOING DEFERED ECHOING
	TBBE	$T2ELC,SDTRS2#(SD),14$
	CALL	ECHBCK			;MUST ECHO FUNNY!
	MOV	#LF,R0			;ADD A L.F.
14$:	CJMP	ECHBCK
.IFF
	BR	NOEC4O
.ENDC

ECHO3F:	JMP	ECHOIF

	.PAGE
	.SBTTL	TRM    - Input of line feed

;HERE FOR INPUT OF LINE FEED

TRILFD:
.IF EQ ..SAT
	CALL	CHKTWO#			;SEE IF ROOM FOR TWO MORE CHARACTERS
	  BR	NOEC4O			;IF NOT
.ENDC
	CALL	PUTCHR			;STORE CHARACTER
	  BR	NOEC4O			;BUT WE ALREADY CHECKED!
.IF EQ ..SAT
	TBBN	$T1CMD,SDTRS1#(SD),4$	;DON'T ADD C.R. IF COMMAND MODE
	TBBE	$T2SCL,SDTRS2#(SD),4$	;OTHERWISE ADD IT IF HE WANTS IT!
	PUSH	R0
	MOV	#CR,R0			;PICK UP A C.R. CHARACTER
	CALL	PUTCHR			;STORE IT
	  NOP				;BUT WE ALREADY CHECKED!
	POP	R0			;RESTORE CHARACTER
.ENDC
4$:	TBBE	$T4LCP,SDTRS4#(SD),TRILF4;Go on if not local copy
	MOV	#FPCRTN,R0		;Local copy-get filler pointer
	MOV	#$T2ECL,R1		;Get bit to test
	CALL	LFDDLY			;Calculate delay
TRILF2:	TBBN	$T1HIA!$T1CMD,SDTRS1#(SD),2$;Are we holding input?
	TBBN	$T1ACT,SDTRS1#(SD),NOEC4O;No-forget the delay if output active
2$:	BIT	R1,SDTRS2#(SD)		;Should we insert C.R. or L.F.?
	BNE	4$			;Yes
	TBBE	$T1CMD,SDTRS1#(SD),6$	;Always do so if in command mode
4$:	MOVB	R0,SDTRFP#(SD)		;Store filler pointer
	BISB	#.OSFIL,SDTROS#(SD)	;Indicate filling
6$:	BIS	#$T1ACT!$T1SYN!$T1ACX,SDTRS1#(SD);Indicate output is active now
	TST	R2			;Do we need any delay?
	BEQ	10$			;No
	CALL	CHRDLY			;Yes-setup for it
10$:	CJMP	OUTDLY			;Delay and then start output
					;  needed)

;Here if not local copy

TRILF4:	TBBN	$T1HIA!$T1CMD,SDTRS1#(SD),ECHOIF;If holding off input for output
	TBBE	$T1ACT,SDTRS1#(SD),ECHOIF
.IF EQ ..SAT
	TBBE	$T1DEX,SDTRS1#(SD),NOECHO;Forget it if doing defered echoing
	TBBE	$T2ECL,SDTRS2#(SD),ECHBCK
	CALL	ECHBCK
	MOV	#CR,R0
	BR	ECHBCK
.IFF
	BR	NOEC4O
.ENDC
	.PAGE
	.SBTTL	TRM    - Input of high special characters

;HERE FOR INPUT OF "HIGH SPECIAL" CHARACTERS (ASCII 175 AND 176)

TRYHSP:	CMP	#TLD,R1			;Is it a tilde?
	BNE	TRIUCA			;No-normal character
	JMP	TRYCNT			;Yes-defer echoing

.IF EQ ..SAT
TRIHSP:	TBBE	$T4HSP,SDTRS4#(SD),TRIUCA;Should these codes be special?
	MOV	#ESC,R0			;Yes-change to escape
	JMP	TRICNT			;And go process it
.ENDC
	.PAGE
	.SBTTL	TRM    - Input of semi-colon

;HERE FOR INPUT OF SEMI-COLON WITH DEFERRED ECHOING

;Here for input of semi-colon to check for login mode

TRISMI:	TBBE	$T3LGI,SDTRS3#(SD),TRIUCA;NOT SPECIAL IF NOT LOGIN MODE
LGISMI:	CALL	TRIUCA			;PROCESS THE CHARACTER
	BIC	#$T1ECH!$T1ECM,SDTRS1#(SD);INDICATE NO ECHO
.if ne ..x28		;+--us701
	RETURN		;for x.28, ';' will not start command line process
.endc			;---us701
10$:	CJMP	SNDTRP#			;FORCE THIS TO BE A BREAK
.IF NE ..X28
TRIDSH:
TRICMA:	TBBE	$T3LGI,SDTRS3#(SD),TRIUCA;NOT SPECIAL IF NOT LOGIN MODE
	BIS	#$T1ECH!$T1ECM,SDTRS1#(SD);enable  ECHO
	BR	TRIUCA
.ENDC
	.PAGE
	.SBTTL	TRM    - Input of normal printing characters

;HERE FOR INPUT OF LOWER CASE CHARACTER

TRILCA:
.IF EQ ..SAT
	TBBN	$T5LCI,SDTRS5#(SD),TRIUCA;GO ON IF DON'T WANT TO TRANSLATE
	BIC	#40,R0			;CHANGE TO UPPER CASE
					;Fall into TRIUCA
.ENDC

;HERE FOR INPUT OF UPPER CASE CHARACTER

.IF NE ..SAT
  TRICNT:
  TRIXON:
  TRIXOF:
  TRIHSP:
.ENDC
TRIUCA:	CALL	PUTCHR#			;STORE CHARACTER
	  BR	NOECHO			;If error
	TBBE	$T4LCP,SDTRS4#(SD),ECHOIF;Continue if not local copy
	INCB	SDTRHP#(SD)		;Local copy-bump position
	BNE	NOECHO			;Go if didn't overflow
	DECB	SDTRHP#(SD)		;Overflow-do the best we can!
	BR	NOECHO			;And don't echo
	.PAGE
	.SBTTL	TRM    - Echo processing

;Here to echo if we should

ECHOIF:	TBBE	$T1ECH!$T1ECM,SDTRS1#(SD),NOECHO;NOTHING TO DO IF NOT ECHOING
ECHOIT:
.IF EQ ..SAT
	TBBN	$T1DEX!$T1CMD,SDTRS1#(SD),4$;GO ON IF NO DEFERRED ECHO STUFF
.ENDC
	TBBN	$T1DEM!$T1ACT,SDTRS1#(SD),RTN012;NOTHING TO DO IF ALREADY IN
						;  DEFERRED ECHO MODE OR IF
						;  OUTPUT IS ACTIVE NOW
4$:
.IF EQ ..SAT
	TBBN	$T1HIA!$T1CMD,SDTRS1#(SD),ECHOI0;IF BUFFERING INPUT
ECHBCK:	TBBE	$T1ACT,SDTRS1#(SD),ECHOI0 ;OR IF OUTPUT NOT ACTIVE!
	CJMP	ECHSLF#			  ;Go do it the hard way!

;Here when we can echo directly from here

ECHOI0:
	TBBE	$T1DEA,SDTRS1#(SD),ECHOI2;GO ON IF DELETE ECHO NOT ACTIVE
	BIC	#$T1DEA,SDTRS1#(SD)	;NOT ACTIVE ANY MORE!
;-----
; SHOULD CHECK HERE IF THE INPUT CHARACTER IS <LINE DELETE> CHAR
;  IF YES, ECHO "\<LINE DEL.CHAR.>XXX<CR><LF>"
;  ELSE DO FOLLOWING
;-----
ECHOI1:	MOV	#FPNEBS,R1		;GET FILLER POINTER
	JMP	STRFLC			;GO START FILLER OUTPUT

.ENDC			;.IF EQ ..SAT

;HERE IF DELETE ECHO NOT ACTIVE

ECHOI2:
;-----
; SHOULD CHECK IF INPUT IS <LINE DISPLAY> OR <LINE DELETE>
;  IF <LINE DISPLAY> ECHO <LINE DISPLAY CHAR.><CR><LF>
;  ELSE IF <LINE DEL.CHAR.> ECHO <LINE DEL.CHAR.>XXX<CR><LF>
;	ELSE DO FOLLOWING
;-----
	TBBE	$T1IMO,SDTRS1#(SD),1$	;Image output?
	TBBN	$T1CMD,SDTRS1#(SD),1$	;Yes-also command mode?
	JMP	TROCN2			;No-just echo it

1$:	MOV	R0,R1			;COPY CHARACTER
	BIC	#^C177,R1		;JUST 7 BITS
	MOVB	CHRINX#(R1),R1		;GET DISPATCH INDEX
	CJMP	@TREDSP(R1)		;DISPATCH TO CHARACTER ROUTINE

;Here if should not echo now

NOECHO:	TBBN	$T1HIA!$T1CMD,SDTRS1#(SD),OUTRD1;Are we holding input?
	TBBE	$T1ACT,SDTRS1#(SD),OUTRD1;No-$T1ACT means something here!
	RETURN

;Dispatch table for echo output

	PURE

TREDSP:	.WORD	TROCNT		;.CXNUL =  0 - NULL
	.WORD	TRECNT		;.CXCNT =  2 - Control character
	.WORD	TREBSP		;.CXBSP =  4 - Backspace
	.WORD	TREHTB		;.CXHTB =  6 - Horizontal tab
	.WORD	TRELFD		;.CXLFD = 10 - Line feed
	.WORD	TREVTB		;.CXVTB = 12 - Vertical tab
	.WORD	TREFFD		;.CXFFD = 14 - Form feed
	.WORD	TRECRN		;.CXCRN = 16 - Carriage return
	.WORD	TRECNT		;.CXDLE = 20 - DLE
	.WORD	TRECNT		;.CXXON = 22 - XON
	.WORD	TRECNT		;.CXDC2 = 24 - DC2
	.WORD	TRECNT		;.CXXOF = 26 - XOF
	.WORD	TRECNT		;.CXCAN = 30 - CAN
	.WORD	TREESC		;.CXESC = 32 - ESC
	.WORD	TROUCA		;.CXUCA = 34 - Upper case character
	.WORD	TROUCA		;.CXSMI = 36 - Semi-colon
	.WORD	TROUCA		;.CXLCA = 40 - Lower case character
	.WORD	TROUCA		;.CXHSP = 42 - High special character
	.WORD	NOECHO		;.CXRUB = 44 - Rub-out
.IF NE ..X28
	.WORD	0,0,0,0,0	;46,50,52,54,56
	.WORD	TROUCA		;.CXCMA = 60 - comma
	.WORD	TROUCA		;.CXDSH = 62 - dash
.ENDC

	CODE
	.PAGE
	.SBTTL	TRM    - Subroutine to resume output to packet service

;SUBROUTINE CALLED TO RESUME TRANSMISSION TO PACKET SERVICE AFTER IT HAS
;  BEEN STOPPED BY WARNING OR ERROR RETURN
;	CALL	TRRSUM

TRRSUM::TBBE	$T4HIE,SDTRS4#(SD),RTN012;NOTHING NEEDED IN INPUT HOLD NOT
	TBBE	$T2XOF,SDTRS2#(SD),RTN012;  ENABLED OR IF NO XOFF SENT
	BIS	#$T2QON,SDTRS2#(SD)	;REQUEST XON
	BISB	#.OSBEL,SDTROS#(SD)
	TBBE	$T1ACT,SDSTS1#(SD),OUTRD1;START OUTPUT IF NOT ACTIVE
RTN012:	RETURN				;OUTPUT ACTIVE-JUST RETURN FOR NOW
	.PAGE
	.SBTTL	TRM    - Output done

;SUBROUTINE TO PROCESS OUTPUT DONE FUNCTION FROM TERMINAL
;	C(SD) = ADDRESS OF SDB
;	CALL	OUTRDY

OUTRDY::TBBE	$T1ACX,SDTRS1#(SD),RTN012;IGNORE IF NOT EXPECTING THIS
OUTRD1::MOVB	SDTROS#(SD),R1		;GET OUTPUT STATE
	JMP	@OUTTBL(R1)		;DISPATCH ON THE STATE

;OUTPUT STATE DISPATCH TABLE

	PURE

OUTTBL:	.WORD	OUTRD5		;00000		    - Normal
	.WORD	OUTFIL		;00010  .OSFIL =  2 - Output filler character
	.WORD	OUTDLY		;00100  .OSDLY =  4 - Insert delay
	.WORD	OUTDLY		;00110
	.WORD	OUTBEL		;01000  .OSBEL = 10 - Output BELL, XON, XOF,
	.WORD	OUTBEL		;01010		        or 2741 keyboard enable
	.WORD	OUTBEL		;01100
	.WORD	OUTBEL		;01110
	.WORD	OUTESC		;10000  .OSESC = 20 - Last output character
	.WORD	OUTESC		;10010			was ESC
	.WORD	OUTESC		;10100
	.WORD	OUTESC		;10110
	.WORD	OUTESC		;11000
	.WORD	OUTESC		;11010
	.WORD	OUTESC		;11100
	.WORD	OUTESC		;11110

	CODE

;Here if last output character was ESC

OUTESC:	CALL	GETBYT#			;Get next character
	BNE	2$			;Go on if got something
	JMP	OUTIDL			;If nothing there

2$:	BCC	4$			;Do we have a control packet?
	JMP	OUTCPK#			;Yes

4$:	BICB	#.OSESC,SDTROS(SD)	;No-clear state bit
	TBBE	$T5ESQ,SDTRS5#(SD),6$	;Are we processing input ESC sequences?
	JMP	TROCN2			;Yes-go output image character

6$:	CMPB	#T.CRTB,SDTRTT#(SD)	;Check for block mode terminal (default)
	BNE	12$			;Not block mode - just output char
	MOV	R0,R1			;Get 7 bits for compare
	BIC	#^C177,R1
	CMP	#'5,R1			;Is this a send page foreground?
	BEQ	10$			;Yes
	CMP	#'S,R1			;Is this a send message sequence?
	BEQ	10$			;Yes
	CMP	#'7,R1			;Is this a send page all sequence?
	BEQ	10$			;Yes
	CMP	#'3,R1			;Is this a send page unformated?
	BNE	12$			;No-just output character

10$:	CMPB	#<12.-3>,BLKMOK		;Are block mode transfers inhibited
	BLOS	18$			;Yes-start timer
	CMP	#TRMPLM#,PKFCNT#	;Is enough space available now?
	BHI	18$			;No-start timer
	CMP	TRMPHL,PKFCNT#		;Check to see if the last one used any packets	
	BLOS	11$			;Br if free packet count is going up
	TSTB	BLKMOK			;Is the inhibit counter zero
	BNE	18$			;No - start timer
11$:	MOVB	#12.,BLKMOK		;Start 1.2 sec block mode inhibit
	MOV	PKFCNT#,TRMPHL		;Save packet count at start of sequence
12$:	JMP	OUTCHR			;Send the character
18$:	MOVB	R0,SDTRSC#(SD)		;Save the character
	BIC	#$T1ACX,SDTRS1#(SD)	;Indicate not expecting interrupt now
	MOV	#JIFO2#,R0		;Start 1/2 second timer
	MOV	#20$,R1
	CJMP	TIMREQ#			;And return

;Here .5 seconds later

20$:	MOVB	SDTRSC#(SD),R0		;Get character
	CLRB	SDTRSC#(SD)
	BR	10$			;Continue

;HERE WHEN NEED TO OUTPUT BELL, XON, OR XOFF

OUTBEL:	TBBE	$T2QOF,SDTRS2#(SD),2$	;Need XOF?
	BIC	#$T2QOF,SDTRS2#(SD)	;Yes-but not any more!
	BIS	#$T2XOF,SDTRS2#(SD)	;Remember that XOF was sent
	MOV	#DC3,R0			;Get character
	BR	TROC2N			;And go send it

;Here if do not need XOF

2$:	TBBE	$T2QON,SDTRS2#(SD),3$	;Need XON?
	BIC	#$T2QON!$T2XOF,SDTRS2#(SD);Yes-but not any more!
	MOV	#DC1,R0			;Get character
	BR	TROC2N			;And go send it

;Here if do not need XOF or XON

3$:	TSTB	SDTRBL#(SD)		;Need BELL?
	BEQ	5$			;No
	DECB	SDTRBL#(SD)		;Yes-reduce count
	MOV	#BEL,R0			;Get character
	BR	TROC2N			;And go send it

;Here if do not need XOF or XON or BEL

5$:	TBBE	$T2RKY,SDTRS2#(SD),7$	;Need to enable 2741 keyboard?
	BIC	#$T2RKY,SDTRS2#(SD)	;Yes-but not now!
	JMP	ENBKEY#			;Go do it

;Here if do not need XOF, XON, BEL or keyboard enable

7$:	BICB	#.OSBEL,SDTROS#(SD)	;Clear bit in output state
OUT2D1:	BR	OUTRD1			;Continue

;Here if need to output delay now

OUTDLY::CLR	R0			;Get delay amount
	BISB	SDTRDY#(SD),R0
	BEQ	OUTDL2			;IF FALSE ALARM!
	TBBE	$T0FWN,SDTRS0#(SD),OUTDL1;SHOULD WE FILL WITH NULLS?
	DECB	SDTRDY#(SD)		;YES-REDUCE THE COUNT
	CLR	R0			;GET A NULL
TROC2N:	JMP	TROCN2			;AND GO OUTPUT IT

;HERE TO DELAY USING THE TIMER

OUTDL1:	CLRB	SDTRDY#(SD)		;CLEAR REQUEST
	BICB	#.OSDLY,SDTROS#(SD)
	BIC	#$T1ACX,SDTRS1#(SD)	;DISABLE OUTPUT DONE
	MOV	#OUTRDT,R1
	JMP	TIMREQ#			;GO ENTER CLOCK REQUEST AND RETURN

;HERE IF DELAY REQUEST IS FALSE ALARM

OUTDL2:	BICB	#.OSDLY,SDTROS#(SD)	;FIX UP THE OUTPUT STATE
	BR	OUT2D1			;CONTINUE

;HERE FROM TIMER ROUTINE WHEN DELAY IS FINISHED

OUTRDT:	BIS	#$T1ACX,SDTRS1#(SD)	;ENABLE OUTPUT DONE NOW
	BR	OUT2D1			;CONTINUE

;HERE IF NEED FILLER CHARACTER OUTPUT

OUTFIL:	MOVB	SDTRFX#(SD),R1		;GET 1ST LEVEL FILLER POINTER
	BEQ	OUTFL2			;IF NOT SET
	INCB	SDTRFX#(SD)		;BUMP POINTER
	BR	OUTFL4			;CONTINUE

;HERE TO CHECK 2ND LEVEL FILLER POINTER

OUTFL2:	MOVB	SDTRFP#(SD),R1		;GET FILLER POINTER
	BEQ	FLREN2			;IF NOTHING TO DO HERE
	INCB	SDTRFP#(SD)		;BUMP POINTER
OUTFL4:	MOVB	FLBASE-1(R1),R0		;GET FILLER CHARACTER
	BGE	OUTCH4			;GO ON IF NOT FILLER FUNCTION
	JMP	@FILDSP-177600(R0)	;DISPATCH ON THE FILLER FUNCTION

;FILLER FUNCTION DISPATCH TABLE

	PURE

	.MACRO	FILTBL	AAA
.FL'AAA=!.-FILDSP+200
	.WORD	FLR'AAA
	.ENDM

FILDSP:	FILTBL	END		;200  End of 2nd level filler string
	FILTBL	ENX		;202  End of 1st level filler string
	FILTBL	COD		;204  Insert saved char without translation
.IF EQ ..SAT
	FILTBL	OSC		;206  Output saved char without processing but
				;	with translation
	FILTBL	NSP		;210  Insert N spaces
	FILTBL	NLF		;212  Insert N line-feeds
	FILTBL	ISC		;214  Insert saved character
	FILTBL	IEC		;216  Insert echo character
.ENDC

	CODE

;HERE ON END OF 1ST LEVEL FILLER STRING

FLRENX:	CLRB	SDTRFX#(SD)		;CLEAR FILLER POINTER
	MOVB	SDTRSX#(SD),R0		;GET SAVED CHARACTER
	BEQ	OUTFL2			;IF NONE SAVED
	CLRB	SDTRSX#(SD)		;CLEAR SAVED CHARACTER
	BR	OUTCH4			;AND GO OUTPUT IT

;HERE ON END OF 2ND LEVEL FILLER STRING

FLREND:	CLRB	SDTRFP#(SD)		;CLEAR FILLER POINTER
FLREN2:	BICB	#.OSFIL,SDTROS#(SD)	;UPDATE OUTPUT STATE
					;FALL INTO FLRISC TO CHECK FOR SAVED
					;  CHARACTER

;HERE TO OUTPUT SAVED CHARACTER

FLRISC:	MOVB	SDTRSC#(SD),R0		;IS THERE A SAVED CHARACTER?
	BEQ	OUT2D1			;NO-GO ON
	CLRB	SDTRSC#(SD)		;YES-CLEAR SAVED CHARACTER
	BR	OUTCH4			;AND GO OUTPUT IT

;Here to output saved character without output processing but with translation

.IF EQ ..SAT
FLROSC:	MOVB	SDTRSX#(SD),R0		;Get character
	CLRB	SDTRSX#(SD)		;Clear it
	JMP	TROCN2			;And go output it
.ENDC

;HERE TO OUTPUT SAVED CHARACTER WITHOUT ANY TRANSLATION

FLRCOD:	MOVB	SDTRSX#(SD),R0		;GET CHARACTER
	CLRB	SDTRSX#(SD)		;CLEAR IT
	CJMP	OUTCOD			;GO OUTPUT IT

.IF EQ ..SAT

;HERE TO ECHO SAVED CHARACTER

FLRIEC:	MOVB	SDTRSC#(SD),R0		;GET CHARACTER
	CLRB	SDTRSC#(SD)		;CLEAR IT
	CJMP	ECHOI2			;OUTPUT IT USING ECHO ROUTINES

;HERE TO OUTPUT N SPACES (C(SDTRSC(SD) = N+1)

FLRNSP:	MOV	#SPA,R0			;GET SPACE CHARACTER
	BR	FLRCOM			;CONTINUE

;HERE TO OUTPUT N LINE-FEEDS (C(SDTRSC(SD) = N+1)

FLRNLF:	MOV	#LF,R0			;GET LINE-FEED CHARACTER
FLRCOM:	DECB	SDTRSC#(SD)		;DECREMENT COUNT
	BEQ	OUTFIL			;FINISHED-GO GET NEXT FILLER CHAR
	DECB	SDTRFP#(SD)		;NOT FINISHED-BACK UP POINTER
	BR	OUTCH4			;AND GO OUTPUT CHARACTER

.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Get next output character

;HERE IF NO SPECIAL OUTPUT DONE PROCESSING IS NEEDED

OUTRD5:	TBBN	$S1HLD,SDSTS1#(SD),2$	;IF SHOULD HOLD OUTPUT
	JMP	@SDTROD#(SD)		;DISPATCH FOR OUTPUT DONE

;HERE IF OUTPUT SHOULD BE HELD NOW

2$:	CALL	GETPKT#			;Get current packet
	BEQ	INPGET			;If none
	TSTB	PKTYPE(R1)		;Is it a data packet
	BEQ	INPGET			;Yes-forget about it since we are
					;  holding output
	TBBN	$T1CMD,SDTRS1#(SD),INPGET;PROCESS NON-DATA PACKET IF NOT IN CMD MODE

;HERE FROM DISPATCH ON SDTROD UNLESS IN COMMAND MODE

OUTGET::CALL	GETBYT#			;GET NEXT OUTPUT CHARACTER
	BEQ	INPGET			;IF NOTHING THERE NOW
	BCC	OUTCHR			;IF NOT CONTROL PACKET
	JMP	OUTCPK#			;GO HANDLE CONTROL PACKET

;HERE IF NOT CONTROL PACKET

OUTCHR::TBBN	$T1SOP,SDTRS1#(SD),OUTRD5;If output is suppressed
OUTCH1:	TBBE	$T1IMO,SDTRS1#(SD),OUTCH4;Is image output in effect?
	TBBN	$T1CMD,SDTRS1#(SD),OUTCH4;Yes-also command mode?
	JMP	TROCN2			;No-just output it as-is!

;HERE IF NOT IMAGE OUTPUT

OUTCH4:	TBBE	$T6LMB,SDTRS6#(SD),10$	;IS TERMINAL IN LIMBO?
	BIC	#$T6LMB!$T6OCU,SDTRS6#(SD);YES-BUT NOT ANY MORE!
	MOV	#SLEOA,R3		;GET CODE TO SEND
	MOVB	#10.,SDTRDY#(SD)	;DELAY FOR 10 TICKS AFTER THE EOA
	BISB	#.OSDLY!.OSFIL,SDTROS#(SD)
	MOV	#FPDONX,R1		;GET FILLER POINTER
	BIS	#$T1ACT!$T1SYN!$T1ACX,SDTRS1#(SD);INDICATE OUTPUT ACTIVE
	JMP	TROCN4			;CONTINUE

;HERE IF TERMINAL IS NOT IN LIMBO NOW

10$:	MOV	R0,R1			;COPY CHARACTER
	BIC	#^C177,R1		;JUST 7 BITS
	MOVB	CHRINX(R1),R1		;GET INDEX
	JMP	@TRODSP(R1)		;GO OUTPUT CHARACTER

;DISPATCH FOR OUTPUT

	PURE

TRODSP:	.WORD	TROCNT		;.CXNUL =  0 - NULL
	.WORD	TROCNT		;.CXCNT =  2 - CONTROL CHARACTER
	.WORD	TROBSP		;.CXBSP =  4 - BACK SPACE
	.WORD	TROHTB		;.CXHTB =  6 - HORIZONTAL TAB
	.WORD	TROLFD		;.CXLFD = 10 - LINE FEED
	.WORD	TROVTB		;.CXVTB = 12 - VERTICAL TAB
	.WORD	TROFFD		;.CXFFD = 14 - FORM FEED
	.WORD	TROCRN		;.CXCRN = 16 - CARRIAGE RETURN
	.WORD	TROCNT		;.CXDLE = 20
	.WORD	TROCNT		;.CXXON = 22 - X-ON
	.WORD	TROCNT		;.CXDC2 = 24 - DC2
	.WORD	TROCNT		;.CXXOF = 26 - X-OFF
	.WORD	TROCNT		;.CXCAN = 30 - CAN
	.WORD	TROESC		;.CXESC = 32 - ESCAPE
	.WORD	TROUCA		;.CXUCA = 34 - UPPER CASE CHARACTER
	.WORD	TROUCA		;.CXSMI = 36 - SEMI-COLON
	.WORD	TROUCA		;.CXLCA = 40 - LOWER CASE CHARACTER
	.WORD	TROUCA		;.CXHSP = 42 - HIGH SPECIAL CHARACTER
	.WORD	TROCNT		;.CXRUB = 44 - RUB-OUT
.IF NE ..X28
	.WORD	0,0,0,0,0	;46,50,52,54,56
	.WORD	TROUCA		;.CXCMA = 60 - comma
	.WORD	TROUCA		;.CXDSH = 62 - dash
.ENDC

	CODE
	.PAGE
	.SBTTL	TRM    - Output idle

INPGET::
.IF EQ ..SAT
	CALL	GETIHB#			;NO OUTPUT-TRY FOR HELD INPUT CHARACTER
	  BR	OUTIDL			;Nothing there-really idle now
	JMP	INPCH8			;GOT ONE-GO PROCESS IT
.ENDC

OUTIDL::TBBE	$T1DEM,SDTRS1#(SD),OUTID4;GO ON IF NOT DEFERRED ECHO MODE
	TBBE	$T1ECH!$T1ECM,SDTRS1#(SD),OUTID4;OR IF NO ECHOING
	TBBN	$T1CMD,SDTRS1#(SD),OUTID4;OR IF IN COMMAND MODE
.IF NE ..SAT
	TBBN	$T3LGI,SDTRS3#(SD),OUTID4;OR IF TYMSAT AND IN LOGIN MODE
.ENDC
	TBBN	$T6RBF,SDTRS6#(SD),OUTID1;IF NEED TO SEND A RED BALL NOW
	CALL	SNDGRN			;SEND A GREEN BALL
	BR	OUTID4			;CONTINUE

;HERE IF NEED TO SEND A RED BALL NOW BECAUSE A TIME-OUT OCCURED WHILE OUTPUT
;  WAS ACTIVE

OUTID1:	CALL	SNDRED			;SEND A RED BALL
OUTID4:	BIC	#$T1ACT!$T1ACX,SDTRS1#(SD);NOTHING TO DO-INDICATE NOT ACTIVE
	RETURN				;AND RETURN

;HERE WHEN THE BALL TIMER TIMES OUT

BALTMO::BIS	#$T6RBF,SDTRS6#(SD)	;REQUEST A RED BALL WHEN OUTPUT IS IDLE
	TBBE	$T1ACT,SDTRS1#(SD),OUTIDL;IF OUTPUT IS IDLE NOW
	RETURN				;OTHERWISE WAIT UNTIL IT IS
	.PAGE
	.SBTTL	TRM    - Echo ESC

;HERE TO ECHO ESC CHARACTER

.IF EQ ..SAT
TREESC:	TBBE	$T1CMD,SDTRS1#(SD),TREES2;IN COMMAND MODE?
.IFTF
NOEC6O:	JMP	NOECHO			;YES-NEVER ECHO ESC!
.IFT

TREES2:	TBBE	$T5EED,SDTRS5#(SD),NOEC6O;SHOULD WE ECHO ESC AS "$"?
	MOV	#'$,R0			;YES-DO THAT
	BR	TROC4T
.ENDC

	.SBTTL	TRM    - Output ESC

;Here to output ESC character

TROESC:	CLRB	SDTRHP#(SD)		;CLEAR HORIZONTAL POSITION!
	BISB	#.OSESC,SDTROS#(SD)	;Indicate ESC was output last
TROC4T:	JMP	TROCNT			;Continue

	.SBTTL	TRM    - Echo control characters

;HERE TO ECHO CONTROL CHARACTER WHICH DOES NOT REQUIRE SPECIAL HANDLING

.IF EQ ..SAT
TRECNT:	TBBN	$T3LGI,SDTRS3#(SD),NOEC6O;NO ECHO IF IN LOGIN MODE
	MOV	R0,R1			;COPY CHARACTER
	BIC	#^C177,R1		;JUST 7 BITS
	BITB	#010,SDTRBS#(SD)	;DOING TECO MODE INPUT?
	BEQ	1$			;NO-GO ON
	CMPB	SDTRHI#(SD),R1		;YES-ONLY HARD INTERRUPT CHR IS
					;  SPECIAL FOR ECHOING
	BEQ	TRECN2			;ECHO HARD INTERRUPT CHR WITH CR-LF
	BR	3$			;ALL OTHERS GET ^ WITHOUT CR-LF

;HERE IF NOT TECO SUB-MODE

1$:	TBBN	$T1CMD,SDTRS1#(SD),11$	;BRANCH IF IN COMMAND MODE
	TBBE	$T5EDT,SDTRS5#(SD),3$	;BRANCH IF NO LINE-EDITING
11$:	MOV	#SDTRSL#,R2		;MAKE POINTER TO LIST OF SPECIAL
	ADD	SD,R2			;  CHARACTERS IN THE SDB
	MOV	#SDTRSN#,R3		;GET NUMBER OF SPECIAL CHAACTERS
2$:	CMPB	(R2)+,R1		;SEE IF THIS IS A SPECIAL CHARACTER
	BEQ	TRECN2			;YES-ALWAYS ECHO WITH UPARROW
	SOB	R3,2$
	TBBN	$T1CMD,SDTRS1#(SD),4$	;NOT SPECIAL-ALWAYS ECHO WITH UP-ARROW
					;  IF COMMAND MODE
3$:	TBBE	$T5ECC,SDTRS5#(SD),NOEC6O;NOT CMD MODE-WANT UPARROW ANYWAY?
4$:	MOV	#FPCNCH,R1		;YES-GET FILLER POINTER
	BR	TRECN4			;CONTINUE

;HERE WITH "SPECIAL" CHARACTER - ECHO PRECEEDED WITH UPARROW AND FOLLOWED BY
;  C.R.-L.F.

TRECN2:
;;;;;;;;;  ECHO LINE DELETE CHARACTER AS X.28 RECOMMENDED
	CMPB	R1,SDTRLX#(SD)		;IS IT LINE DELETE ?
	BNE	10$			;NO, BRANCH
	MOV	#FPCXCR,R1		;GET FILLER POINTER
	BR	TRECN3
10$:
;;;;;;;;;  1/31/83 ;;;;;
	MOV	#FPCCCR,R1		;GET FILLER POINTER
TRECN3:	TBBN	$T2CRO,SDTRS2#(SD),TRECN4;WAS LAST OUTPUT CHARACTER A C.R.?
	ADD	#2,R1			;NO-FIX UP THE FILLER POINTER
TRECN4:	BIS	#100,R0			;CHANGE TO PRINTING CHARACTER
	JMP	STRFLC			;GO START FILLER OUTPUT
.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - Echo and output backspace

;Here to echo backspace character

TREBSP:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC6O			;If no echo wanted
					;Otherwise fall into output routine

;Here to output backspace character

TROBSP:	TSTB	SDTRHP#(SD)		;AT BEGINNING OF LINE NOW?
	BEQ	2$			;YES-KEEP THE COUNT GOOD
	DECB	SDTRHP#(SD)		;NO-DECREMENT POSITION
2$:	MOVB	SDTRBD#(SD),R2		;GET DELAY COUNT
	BR	SETDLY			;AND GO DO OUTPUT
	.PAGE
	.SBTTL	TRM    - Echo horizontal tab character

;HERE TO ECHO HORIZONTAL TAB CHARACTER [ASCII 11]

TREHTB:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC6O			;If no echo wanted
					;Otherwise fall into output routine

	.SBTTL	TRM    - Output horizontal tab character

;HERE TO OUTPUT HORIZONTAL TAB CHARACTER [ASCII 11]

TROHTB:
.IF EQ ..SAT
	TBBE	$T4HTS,SDTRS4#(SD),TROHT4;GO ON IF NOT SIMULATING TABS
	TBBE	$T1DEX,SDTRS1#(SD),TROHT4;GO ON IF DOING DEFERED ECHOING

TROHT1:	MOVB	SDTRHP#(SD),R1		;GET LINE POSITION
	BIC	#^C7,R1			;MOD 8
	MOV	#11,R0			;CALCULATE NUMBER OF SPACES NEEDED
	SUB	R1,R0
	MOV	#FPNSPA,R1		;GET FILLER POINTER
	JMP	STRFLC			;CONTINUE
.ENDC

;HERE IF NOT SIMULATING HORIZONTAL TABS

TROHT4:

.IF EQ ..SAT
	BISB	#7,SDTRHP#(SD)		;ADVANCE HORIZONTAL POSITION
	INCB	SDTRHP#(SD)
.ENDC
	CLR	R2			;GET COUNT WITHOUT SIGN EXTEND
	BISB	SDTRHD#(SD),R2
SETDLY:	ASL	R2			;NEED ANY DELAY HERE?
	BEQ	4$			;NO-GO ON
	CALL	CHRDLY			;Yes-set it up
4$:	JMP	TROCNT			;AND GO OUTPUT CHARACTER
	.PAGE
	.SBTTL	TRM    - Echo vertical tab character

;HERE TO ECHO VERTICAL TAB CHARACTER [ASCII 13]

.IF EQ ..SAT
TREVTB:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC6O			;If no echo wanted
.ENDC					;Otherwise fall into output routine

	.SBTTL	TRM    - Output vertical tab character

;HERE TO OUTPUT VERTICAL TAB CHARACTER [ASCII 13]

TROVTB:
.IF EQ ..SAT
	TBBE	$T4VTS,SDTRS4#(SD),TROVT6;GO ON IF NOT SIMULATING VERTICAL TABS
	TBBE	$T1DEX,SDTRS1#(SD),TROVT6;NO SIMULATION IF DEFERED ECHOING
TROVT1:	TSTB	SDTRPG#(SD)		;IS A PAGE SIZE SET?
	BEQ	TROVT2			;NO-GO ON
	CLR	R1			;GET POSITION ON PAGE
	BISB	SDTRVP#(SD),R1
	MOVB	SDTRVT#(SD),R3		;GET VERTICAL TAB SPACEING
	CLR	R0			;POSITION MOD THE VERTICAL TAB SPACING
	DIV	R3,R0
	SUB	R3,R0			;CALCULATE NUMBER OF LINE-FEEDS NEEDED
	BR	TROVT4			;CONTINUE

;HERE FOR SIMULATED VERTICAL TAB WITH NO PAGE SIZE

TROVT2:	MOVB	SDTRVT#(SD),R0		;ALWAYS OUTPUT SPECIFIED NUMBER OF LF'S
	BNE	TROVT4			;IF NOT 0
	MOV	#4,R0			;IF 0, DEFAULT IS 4
TROVT4:	MOV	#FPNLFD,R1		;GET FILLER POINTER
	JMP	STRFLC			;GO SETUP FILLER OUTPUT
.ENDC

;HERE IF VERTICAL TAB IS NOT SIMULATED

.IF EQ ..SAT
TROVT6:	CALL	UPPPVT			;UPDATE POSITION ON PAGE
.ENDC
	CLR	R2			;GET FILL COUNT WITHOUT SIGN EXTEND
	BISB	SDTRVD#(SD),R2
SETD2Y:	BR	SETDLY			;CONTINUE
	.PAGE
	.SBTTL	TRM    - Echo form feed character

;HERE TO ECHO FORM FEED CHARACTER [ASCII 14]

.IF EQ ..SAT
TREFFD:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC8O			;If no echo wanted
.ENDC					;Otherwise fall into output routine

	.SBTTL	TRM    - Output form feed character

;HERE TO OUTPUT FORM FEED CHARACTER [ASCII 14]

TROFFD:
.IF EQ ..SAT
	TBBE	$T4FFS,SDTRS4#(SD),TROFF6;GO ON IF FORM-FEED IS NOT SIMULATED
	TBBE	$T1DEX,SDTRS1#(SD),TROFF6;NO SIMULATION IF DEFERED ECHOING
TROFF1:	CLR	R0			;GET VERTICAL POSITION
	BISB	SDTRVP#(SD),R0
	CLRB	SDTRVP#(SD)		;CLEAR VERTICAL POSITION
	CLR	R3			;GET PAGE SIZE
	BISB	SDTRPG#(SD),R3
	BEQ	TROFF2			;IF NO PAGE SIZE SPECIFIED
	SUB	R3,R0			;CALCULATE NUMBER OF LF'S NEEDED
	BR	TROFF3			;CONTINUE

;HERE FOR SIMULATED FORM FEED WITH NO PAGE SIZE

TROFF2:	MOV	#10,R0			;IF NO PAGE SIZE, ALWAYS OUTPUT 8 LF'S
TROFF3:	MOV	#FPNLFD,R1		;GET FILLER POINTER
	JMP	STRFLC			;GO START FILLER OUTPUT
.ENDC

;HERE IF FORM-FEED IS NOT SIMULATED
;  DELAY IS CALCULATED BY:
;	DELAY = D + <S-P>*16./2**V
;  WHERE:
;	D = FIXED DELAY PARAMETER FROM SDTRFD
;	V = VARIABLE DELAY PARAMETER FROM SDTRFV
;	S = PAGE SIZE FROM SDTRPG (IF NOT SET, 66. IS USED)
;	P = POSITION ON PAGE FROM SDTRVP

TROFF6:	CLR	R2			;GET FIXED DELAY PARAMETER WITHOUT
	BISB	SDTRFD#(SD),R2		;  SIGN EXTEND
.IF EQ ..SAT
	CLR	R1			;GET VARIABLE DELAY PARAMETER WITHOUT
	BISB	SDTRFV#(SD),R1		;  SIGN EXTEND
	BEQ	TROFF8			;IF NO VARIABLE DELAY
	MOV	R2,R4
	CLR	R2			;GET PAGE SIZE WITHOUT SIGN EXTEND
	BISB	SDTRPG#(SD),R2
	BNE	TROFF7			;IF SOMETHING SET
	MOV	#66.,R2			;NO SET-USE 66.
TROFF7:	CLR	R3			;GET VERTICAL POSITION WITHOUT SIGN
	BISB	SDTRVP#(SD),R3		;  EXTEND
	SUB	R3,R2			;CALCULATE AMOUNT TO FEED
	ASHI	4,R2			;CALCULATE VARIABLE AMOUNT
2$:	ASR	R2
	BEQ	4$
	SOB	R1,2$
4$:	ADD	R4,R2			;ADD TO FIXED AMOUNT
TROFF8:	CLRB	SDTRVP#(SD)		;CLEAR VERTICAL POSITION
.ENDC
	BR	SETD2Y			;CONTINUE
	.PAGE
	.SBTTL	TRM    - Echo carriage return character

;HERE TO ECHO CARRIAGE RETURN CHARACTER [ASCII 15]

TRECRN:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC8O			;If no echo wanted
	TBBN	$T2ELC,SDTRS2#(SD),TRECR2;Go on if want L.F. added
	TBBE	$T1CMD,SDTRS1#(SD),TROCRN;ALWAYS ADD L.F. IF COMMAND MODE
TRECR2:	MOVB	#FPCRLF,SDTRFX#(SD)	;WANT L.F. ADDED-SET FILLER POINTER
	JMP	STRFL2			;AND GO START FILLER OUTPUT

	.SBTTL	TRM    - Output carriage return character

;HERE TO OUTPUT CARRIAGE RETURN CHARACTER [ASCII 15]
;  DELAY IS CALCULATED BY:
;	DELAY = D + P/2**V
;  WHERE:
;	D = FIXED DELAY PARAMETER FROM SDTRCD
;	V = VARIABLE DELAY PARAMETER FROM SDTRCV
;	P = POSITION ON LINE FROM SDTRHP

TROCRN:	CALL	CRNDLY			;Calculate C.R. delay
	BEQ	TROCN2			;If none needed
	CALL	CHRDLY			;Set up for the delay
	BR	TROCN2			;Continue
	.PAGE
	.SBTTL	TRM    - Echo line feed character

;HERE TO ECHO LINE FEED CHARACTER [ASCII 12]

TRELFD:	CALL	CHKCCE			;See how we should echo this
	BVS	NOEC8O			;If no echo
	TBBN	$T2ECL,SDTRS2#(SD),TRECR2;If want carriage return added
TRELF4:	TBBE	$T4ALF,SDTRS4#(SD),TROLF2;Exactly like output if not auto-LF
	TBBE	$T2CRO,SDTRS2#(SD),TROLF2;Or if last character was not CR
	BIC	#$T2CRO,SDTRS2#(SD)	;Clear CR output flag
NOEC8O:	JMP	NOECHO			;No echo in this case

	.SBTTL	TRM    - Output line feed character

;HERE TO OUTPUT LINE FEED CHARACTER [ASCII 12]

TROLFD:	TBBE	$T4ALF,SDTRS4#(SD),TROLF2;GO ON IF NOT AUTO-LF
	TBBE	$T2CRO,SDTRS2#(SD),TROLF2;OR IF LAST CHARACTER WAS NOT CR
	BIC	#$T2CRO,SDTRS2#(SD)	;CLEAR CR OUTPUT FLAG
	JMP	OUTRD1			;NOTHING TO DO HERE

;HERE WHEN REALLY WANT TO OUTPUT A LF!

TROLF2:	CALL	LFDDLY			;Calculate line feed delay
	JMP	SETDLY			;Output the L.F. with delay
	.PAGE
	.SBTTL	TRM    - Echo and output printing characters

;Here to output or echo upper or lower case printing character

TROUCA:	INCB	SDTRHP#(SD)		;Increment horizontal position
	BNE	2$			;Go if didn't overflow
	DECB	SDTRHP#(SD)		;Overflow-do the best we can!
2$:
.IF EQ ..SAT
	CMPB	SDTRLW#(SD),SDTRHP#(SD)	;At end of line now?
	BHIS	4$			;No-just output character now
	TBBN	$T4NFC,SDTRS4#(SD),4$	;Yes-do we want a free CR?
	TBBN	$T5XFC,SDTRS5#(SD),4$	;Yes-can we have it?
	TSTB	SDTRLW#(SD)		;Yes-is a line width specified?
	BEQ	4$			;No-forget it!
	MOVB	R0,SDTRSX#(SD)		;Save character
	JMP	TRECR2			;And continue
.ENDC

4$:
.IF EQ ..SAT
	TBBN	$T2CRO,SDTRS2#(SD),TROCN1;Was last character a CR?
.ENDC
	BIS	#$T1ACT!$T1SYN!$T1ACX,SDTRS1#(SD);Indicate output is active
	MOVB	SDTRXC#(SD),R2		;Get code
	BNE	TROCN3			;If not ASCII
	TBBN	$T1CMD,SDTRS1#(SD),OUTCOD;Only single character if command mode
	TSTB	SDTROS#(SD)		;Special output?
	BNE	OUTCOD			;Yes-only single character
	TBBN	$S1HLD,SDSTS1#(SD),OUTCOD	;Only single character if output
					;  is being held now
	MOV	SDPKCP#(SD),R1		;Get address of current packet
	BR	OUTCO2			;Output string from packet at interrupt
					;  level if we can
	.PAGE
	.SBTTL	TRM    - Send character to terminal interface driver

;DEFINE SOME SYMBOLS WHICH ARE NOT USED IF THIS IS A TYMSAT VERSION - WE
;  SHOULD NEVER DISPATCH TO THESE LOCATIONS BUT IT WON'T DO ANY HARM TO
;  COME HERE IF WE DO!!!

.IF NE ..SAT
TRECNT:
TREVTB:
TREFFD:
TREESC:
.ENDC

;HERE TO OUTPUT CONTROL CHARACTER WHICH DOES NOT REQUIRE SPECIAL HANDLING

TROCNT::
.IF EQ ..SAT
	TBBE	$T2CRO,SDTRS2#(SD),TROCN2;Was the last character output a CR?
TROCN1:	BIC	#$T2CRO,SDTRS2#(SD)	;Yes-but not any more!
	TBBE	$T2XLC,SDTRS2#(SD),TROCN2;Want extra LF?
	MOV	R0,R2			;Yes-is this a LF?
	BIC	#^C177,R2
	CMP	#LF,R2
	BEQ	TROCN2			;Yes-so nothing special!
	CMP	#ESC,R2			;ESC is not special either!
	BEQ	TROCN2
	MOVB	R0,SDTRSX#(SD)		;Save character
	MOVB	#FPIXLF,SDTRFX#(SD)	;Store filler pointer
	BISB	#.OSFIL,SDTROS#(SD)
	MOV	#LF,R0			;Get a LF
.ENDC
TROCN2:	BIS	#$T1ACT!$T1SYN!$T1ACX,SDTRS1#(SD);Indicate output is active
	MOVB	SDTRXC#(SD),R2		;GET TRANSLATION INDEX
	BEQ	OUTCOD			;GO ON IF ASCII
TROCN3:	BIC	#^C177,R0		;NOT ASCII-MAKE SURE ONLY 7 BITS
	ADD	CODTOU#(R2),R0		;GET ADDRESS OF OUTPUT XLATE TABLE
	MOVB	(R0),R0			;TRANSLATE THE CHARACTER
	BITB	#300,R0			;DOES IT REQUIRE SPECIAL HANDLING?
;	BEQ	OUTCOD			;NO-JUST OUTPUT IT
	BEQ	OUTCO4			;NO-JUST OUTPUT IT
	BPL	TROCN5			;YES-BR IF REQUIRES MULTIPLE CHARACTERS
	TBBN	$T6OCU,SDTRS6#(SD),4$	;MUST WORRY ABOUT CASE-IS OUTPUT NOW
					;  UPPER CASE?
	TBBE	100,R0,TROCN6		;NO-IS THIS AN UPPER CASE CHARACTER
	BIS	#$T6OCU,SDTRS6#(SD)	;YES-INDICATE NOW UPPER CASE
	MOVB	CODTSU#(R2),R3		;GET UPPER CASE SHIFT CHARACTER
	BR	5$			;CONTINUE

;HERE IF NOW UPPER CASE

4$:	TBBN	100,R0,TROCN6		;IS THIS A LOWER CASE CHARACTER?
	BIC	#$T6OCU,SDTRS6#(SD)	;YES-INDICATE NOW LOWER CASE
	MOVB	CODTSL#(R2),R3		;GET LOWER CASE SHIFT CHARACTER
5$:	BIC	#^C77,R0		;ONLY 6 BITS
	bisb	ODDPAR(R0),R0		;2741 NEEDS ODD PARITY
	MOV	#FPCOUT,R1		;GET FILLER POINTER
	BISB	#.OSFIL,SDTROS#(SD)	;INDICATE FILLER OUTPUT TO DO
TROCN4:	MOVB	R1,SDTRFX#(SD)		;STORE FILLER POINTER
	MOVB	R0,SDTRSX#(SD)		;SAVE CURRENT CHARACTER
	MOV	R3,R0			;GET CODE IN RIGHT AC
	BR	OUTCOD			;AND GO OUTPUT IT

;HERE IF MUST OUTPUT PREFIX CHARACTER(S) FIRST

TROCN5:	BIC	#^C77,R0		;GET INDEX INTO NEXT TABLE
	bisb	CODTOX#(R2),R0		;GET bisbRESS OF TABLE
	MOVB	(R0),R0			;GET CHARACTER
	BISB	ODDPAR(R0),R0		;2741 NEEDS ODD PARITY
	DECB	SDTRHP#(SD)		;FIX UP THE HORIZONTAL POSITION
	MOV	#FPPRFX,R1		;GET FILLER POINTER
STRFLC:	MOVB	R0,SDTRSC#(SD)		;Store for output
STRFIL:	MOVB	R1,SDTRFP#(SD)		;STORE FILLER POINTER
STRFL2:	BISB	#.OSFIL,SDTROS#(SD)	;UPDATE OUTPUT STATE
	JMP	NOECHO			;GO START OUTPUT

TROCN6:	BIC	#^C77,R0		;JUST 6 BITS
OUTCO4:	BISB	ODDPAR(R0),R0		;2741 NEEDS ODD PARITY

;HERE WHEN FINALLY READY TO OUTPUT THE CHARACTER!

OUTCOD::CLR	R1			;Indicate no packet available
OUTCO2:	MOV	SDTRAD#(SD),R4		;Get address of ADB
	JMPI	(R4)			;Go output character and return

	PURE
ODDPAR:	.BYTE	100,0,0,100,0,100,100,0	;ODD PARITY FOR 0 TO 7
	.BYTE	0,100,100,0,100,0,0,100 ;10-17
	.BYTE	0,100,100,0,100,0,0,100 ;20-27
	.BYTE	100,0,0,100,0,100,100,0	;30-37
	.BYTE	0,100,100,0,100,0,0,100 ;40-47
	.BYTE	100,0,0,100,0,100,100,0	;50-57
	.BYTE	100,0,0,100,0,100,100,0	;60-67
	.BYTE	0,100,100,0,100,0,0,100 ;70-77
	CODE
	.PAGE
	.SBTTL	TRM    - Interface function routines

;Here for ring detect

RNGDET::TBBN	$T0DDD,SDTRS0#(SD),2$	;
	TBBN	$T0HWR,SDTRS0#(SD),RTN026;Ignore this if hardwired
2$:	MOVB	SDTRCS#(SD),R1		;Get terminal carrier state
	JMP	@RNGDSP(R1)		;Dispatch on it

;Dispatch table for ring detect

	PURE

RNGDSP:	.WORD	RNGD00		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	RTN026		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	HUNG04		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	HUNG06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	HANGUP		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	HANGUP		;.CSNRM = 12 - NORMAL
	.WORD	HUNG14		;.CSBCL = 14 - CARRIER LOSS TIMEOUT - BAUD RATE DETECT
	.WORD	HUNG20		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	HUNG20		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN026		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;HERE FOR STATE = .CSHNG - TERMINAL IS HUNG UP

RNGD00:	BIS	#$S1INU,SDSTS1#(SD)	;INDICATE TERMINAL IS IN USE NOW
	MOVB	#.CSCDT,SDTRCS#(SD)	;UPDATE STATE
	MOV	#JIFX15#,R0		;START TIMER
	MOV	#HUNGUP,R1
	CALL	TIMREQ#
ANSTRM:	MOV	#.LFANS,R0		;ANSWER THE PHONE
	CJMP	TRMFNC			;AND RETURN
	.PAGE
;HERE FOR CARRIER DETECT

CARDET::MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@CRDDSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR CARRIER DETECT

	PURE

CRDDSP:	.WORD	CARD00		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	CARD02		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	CARD06		;.CSCDD =  4 - CARRIER DETECT DELAY
;	.WORD	RTN026		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD   CARD01		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	HANGUP		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	HANGUP		;.CSNRM = 12 - NORMAL
	.WORD	CARD14		;.CSBCL = 14 - CARRIER LOSS TIMEOUT -BAUD RATE
	.WORD	CARD16		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	CARD20		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN026		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;HERE IF STATE = .CSHNG - TERMINAL IS HUNG UP

CARD00:	TBBN	$T0HWR,SDTRS0#(SD),CARD03;IS THIS A HARDWIRED TERMINAL?
RTN026:	RETURN				;NO-IGNORE CARRIER WITHOUT RING!

;HERE IF STATE = .CSBRD - BAUD RATE DETECT

CARD01:	CALL	BRDRST			;TURN OFF ALL THE TIMERS AND STUFF
;	BR	CARD02

;HERE IF STATE = .CSCDT - CARRIER DETECT TIMEOUT (THIS MEANS WE HAVE SEEN
;  RING AND ARE WAITING FOR CARRIER)

CARD02:	MOV	#HUNGUP,R1		;CLEAR THE TIMER
	CALL	TIMKIL#
CARD03:	MOVB	#.CSCDD,SDTRCS#(SD)	;ADVANCE STATE
	MOV	#JIFO2#,R0		;START THE NEXT TIMER
	MOV	#CARRDY,R1
	CJMP	TIMREQ#			;AND RETURN

;HERE FOR STATE = .CSCDD - CARRIER DETECT DELAY

CARD06:	TBBE	$T0HWR,SDTRS0#(SD),HUNG04 ;NOT NICE ON A DIALUP
	RETURN				;TYPICAL ON A HARDWARE

;HERE FOR STATE = .CSBCL - CARRIER LOSS TIMEOUT DURING BAUD RATE DETECT

CARD14:	MOV	#.CSBRD,R0		;GET NEXT STATE
	BR	CARD21			;CONTINUE

;HERE FOR STATE = .CSSCL - CARRIER LOSS TIMEOUT DURING 2741 SETUP

CARD16:	MOV	#.CSSEL,R0		;GET NEXT STATE
	BR	CARD21			;CONTINUE

;HERE FOR STATE = .CSNCL - CARRIER LOSS TIMEOUT (NORMAL)

CARD20:	MOV	#.CSNRM,R0		;GET NEXT STATE
CARD21:	MOVB	R0,SDTRCS#(SD)		;STORE NEW STATE
	MOV	#HUNGUP,R1		;CLEAR THE TIMER
	CJMP	TIMKIL#			;AND RETURN
	.PAGE
;HERE 1/2 SECOND AFTER GETTING CARRIER (STATE = .CSCDD - CARRIER DETECT DELAY)

CARRDY:	CALL	SETRAT			;SETUP BAUD RATE, ETC
	  RETURN			;FINISHED IF AUTO-BAUD TERMINAL
	BR	STRCMD			;NOT AUTO-BAUD - GO START COMMAND DECODER

;HERE FROM BAUD-RATE DETECT ROUTINE WHEN BAUD RATE HAS BEEN DETERMINED

BRDRDY::
	TBBE	$T4SEL,SDTRS4#(SD),STRCMD;IS THIS A SELECTRIC?
.IF NE ..BUG
	MOV	#SLEOT,R0		;PRETEND WE RECEIVE EOT
	MOVB	#.CSNRM,SDTRCS#(SD)	;UPDATE THE CARRIER STATE
	CALL	DATA12
	BR	STRCMD			;.IF NE ..BUG
	MOV	#CR2741,PT2741		;Prepare to collect EOT data
	CLR	CT2741			;Clear the count
.ENDC
	MOVB	#.CSSEL,SDTRCS#(SD)	;YES-USE THE RIGHT INITIAL STATE
	RETURN				;THATS ALL FOR NOW

;HERE WHEN READY TO START THE COMMAND DECODER

STRCMD:	MOVB	#.CSNRM,SDTRCS#(SD)	;UPDATE THE CARRIER STATE
;+--us801
	TBBE	$T0CMX,SDTRS0#(SD),RTN026 ;IF DEFAULT IS NOT COMMAND MODE
;---US801
	CALL	SETINU#			;Make sure terminal is "in-use"
	TBBE	$T0ASK,SDTRS0#(SD),2$	;SHOULD WE ASK HIM ABOUT HIS TERMINAL?
	BIS	#$T3TRM,SDTRS3#(SD)	;YES
2$:	MOV	#.CXCMD#,R2		;GET COMMAND DECODER INDEX
	JMP	CMDENT#			;GO TO COMMAND DECODER

;HERE ON AUTO-BAUD DETECT TIMEOUT - THIS TIMER IS SETUP BY THE
;  INDIVIDUAL AUTO-BAUD ROUTINES IF A TIMEOUT IS WANTED (NORMALLY ONLY USED
;  FOR DIAL-UP LINES, HARDWIRED LINES ARE GIVEN AS LONG AS THEY NEED FOR DETECT)

BRDTMO::CALL	HANGIT			;HANG IT UP
	CLRB	SDTRCS#(SD)		;UPDATE CARRIER STATE
					;FALL INTO BRDRST

;SUBROUTINE TO RESET AUTO-BAUD DETECT ROUTINE
;	CALL	BRDRST

BRDRST:	MOVB	SDTRBR#(SD),R1		;GET RATE
	BIC	#^C$BRORT,R1
	ASL	R1
	MOV	ATOTXX#(R1),R1		;GET ADDRESS OF DETECT TABLE
	CJMP	@4(R1)			;DISPATCH TO THE RESET ROUTINE
	.PAGE
;HERE FOR CARRIER LOSS

CARLOS::MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@CRLDSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR CARRIER LOSS

	PURE

CRLDSP:	.WORD	RTN026		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	HUNG20		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	HUNG04		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	CARL06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	CARL10		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	CARL12		;.CSNRM = 12 - NORMAL
	.WORD	HUNG14		;.CSBCL = 14 - CARRIER LOSS TIMEOUT -BAUD RATE
	.WORD	HUNG20		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	HUNG20		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN026		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;HERE FOR STATE = .CSBRD - BAUD RATE DETECT

CARL06:	CALL	BRDRST			;KILL THE FUNNY OUTPUT AND TIMERS
	MOV	#.CSBCL,R0		;GET NEW CARRIER STATE
	BR	CARL13			;GO START TIMER

;HERE FOR STATE = .CSSEL - 2741 INITIAL SETUP DELAY

CARL10:	MOV	#.CSSCL,R0		;GET NEW CARIER STATE
	BR	CARL13			;GO START TIMER

;HERE FOR STATE = .CSNRM - NORMAL

CARL12:	MOV	#.CSNCL,R0		;GET NEW CARRIER STATE
CARL13:	MOVB	R0,SDTRCS#(SD)		;UPDATE CARRIER STATE
	MOV	#JIFO2#,R0		;START TIMER
	MOV	#HUNGUP,R1
	CJMP	TIMREQ#
	.PAGE
;HERE FOR HANG UP DETECTED

HUNGUP::MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@HNGDSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR HANGUP

	PURE

HNGDSP:	.WORD	RTN026		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	HUNG20		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	HUNG04		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	HUNG06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	HANGUP		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	HANGUP		;.CSNRM = 12 - NORMAL
	.WORD	HUNG14		;.CSBCL = 14 - CARRIER LOSS TIMEOUT -BAUD RATE
	.WORD	HUNG20		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	HUNG20		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN026		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;HERE FOR STATE = .CSCDD - CARRIER DETECT DELAY

HUNG04:	MOV	#CARRDY,R1		;CLEAR TIMER
	BR	HUNG21

;HERE FOR STATE = .CSBRD - BAUD RATE DETECT DELAY

HUNG06:	CALL	BRDRST			;RESET AUTO-BAUD ROUTINE
	BR	HANGUP

;HERE FOR STATE = .CSBCL - CARRIER LOSS TIMEOUT DURING BAUD RATE DETECT

HUNG14:	CALL	BRDRST			;RESET AUTO-BAUD ROUTINE
					;FALL INTO HUNG20

;HERE FOR STATE = .CSSCL - CARRIER LOSS TIMEOUT DURING 2741 SETUP OR STATE =
;  .CSNCL - CARRIER LOSS TIMEOUT (NORMAL)

HUNG20:	MOV	#HUNGUP,R1		;KILL TIMER
HUNG21:	CALL	TIMKIL#
					;FALL INTO HANGUP

;HERE FOR STATE = .CSSEL - 2741 SETUP WAIT OR STATE = .CSNRM - NORMAL

HANGUP:	MOV	#JIFO2#,R0		;SET TIMER FOR 1/2 SEC
	MOV	#10$,R1			;GO TO HANGIT AFTER DELAY
	CJMP	TIMREQ#			;START TIMER

10$:	CALL	HANGIT			;HANG UP THE PHONE
	MOV	#.CXRST#,R2		;RESET THE COMMAND DECODER
	CALL	CMDENT
	CALL	RSTTRM			;RESET THE TERMINAL
	TSTB	SDSTS1#(SD)		;DISCONNECTED NOW?
	BEQ	HANGU4			;YES
	CALL	MAKDSC#			;NO-SEND A KILL PACKET
	MOVB	#.CSIGN,SDTRCS#(SD)	;CHANGE CARRIER STATE
	MOV	#JIFX10#,R0		;START TIMER TO BE SAFE!
	MOV	#HANGU6,R1
	CJMP	TIMREQ#			;AND GO AWAY UNTIL THE KILL FINISHES

;HERE IF DISCONNECTED NOW

HANGU4::MOV	#HANGU6,R1		;CLEAR TIMER
	CALL	TIMKIL#
	CALL	FRESOC#			;GIVE UP THE SOCKET
HANGU6:	CLRB	SDTRCS#(SD)		;UPDATE THE CARRIER STATE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; following three instructions removed so that "please enter teminal id..."
;   will be sent to a hardwired terminal after power-up instead
;   of after power-down.	10/09/81
;   
;	TBBE	$T0HWR,SDTRS0#(SD),RTN030;FINISHED IF NOT HARDWIRED
;	CALL	SETRAT			;IN THAT CASE, SETUP THE BAUD RATE
;	  NOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RTN030:	RETURN				;THATS ALL
	.PAGE
;HERE FOR BREAK ON LINE

BREAKR::MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@BRKDSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR BREAK

	PURE

BRKDSP:	.WORD	BREA00		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	RTN030		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	RTN030		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	BREA06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	RTN030		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	BREA12		;.CSNRM = 12 - NORMAL
	.WORD	BREA06		;.CSBCL = 14 - CARRIER LOSS TIMEOUT -BAUD RATE
	.WORD	RTN030		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	BREA12		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	RTN030		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;HERE FOR BREAK WHEN STATE = .CSBRD
BREA00:	TSTB	R0			;CHECK FOR TRUE BREAK
	BNE	RTN045			;NOT ONE, IGNORE IT
	JMP	CARD00			;HANDLE IT
RTN045:	RETURN				;JUST NOISE ON THE LINE

;HERE FOR BREAK WHEN STATE = .CSBRD

BREA06:	BIS	#100000,R0		;YES-INDICATE FRAMING ERROR
	JMP	DATA06			;AND GO PROCESS THE DATA SO AUT0-BAUD
					;  DETECT WILL WORK RIGHT

;Here for break when state = .CSNRM

BREA12:	TSTB	R0			;Check for real break
	BNE	RTN045			;Not a real break,ignore it
	TBBE	$T4SEL,SDTRS4#(SD),10$	;Is this a 2741?
	TBBE	$T1ACT,SDTRS1#(SD),4$	;Yes-is output active now?
	BIS	#$T2RKY,SDTRS2#(SD)	;Yes-request that the keyboard be
	BISB	#.OSBEL,SDTROS#(SD)	;  enabled when output is done
	BR	6$			;Continue

4$:	CALL	ENBKEY#			;Enable keyboard now
6$:	CJMP	CLRBAL#			;And clear the ball flags

;HERE FOR BREAK IF NOT 2741

;******	THE FOLLOWING LINE ADDED TO ALLOW GETTING BACK TO COMMAND MODE
;	WHEN A NETWORK FUNNY OCCURES.  DRE 12/1/80
10$:	TBBN	$T3LGI,SDTRS3#(SD),HUNGUP ;ALWAYS PROCESS BREAK IN LOGIN MODE
	TBBN	$T0ROB,SDTRS0#(SD),HUNGUP ;DOES HE WANT TO RELEASE ON BREAK?
	.PAGE
;HERE IF BREAK DID NOT CAUSE RELEASE, CHECK PROCEDURE ON BREAK

BREAK4:
.IF	EQ	..SAT
	PURE	
	.MACRO	POB
	XX	1,POBINT
	XX	2,POBRST
	XX	4,POBBRK
	XX	8.,POBESC
	XX	21.,POB21

	.ENDM

; GENERATE PROCEDURE ON BREAK OPTION TABLE

	.MACRO	XX	POBVAL,POBRTN
	.BYTE	POBVAL
	.ENDM

POBTBL:	POB
	.BYTE	0		;INDICATE END OF TABLE
	.EVEN

; GENERATE "PROCEDURE ON BREAK" DISPATCH TABLE

	.MACRO	XX	POBVAL,POBRTN
	.WORD	POBRTN
	.ENDM

POBDSP:	POB

	CODE
	TBBN	$T1CMD,SDTRS1#(SD),RTN040 ;IGNORE IT IF IN COMMAND MODE
	TSTB	SDTRPB#(SD)		;PROCEDURE ON BREAK ?
	BEQ	RTN040			;NOTHING
	MOV	#POBTBL,R0		;POINTS TO BEGINNING OF TABLE
10$:
	CMPB	(R0)+,SDTRPB#(SD)	;THIS ONE?
	BEQ	BREAK6			;YES, BRANCH
	TSTB	(R0)			;END OF TABLE REACHED?
	BNE	10$			;NO
RTN040: RETURN				;IGNORE THE BREAK

BREAK6:	PUSH	R0			;SAVE BRANCH ADDRESS
	CALL	SNDTRP#			;<BREAK> IS A DATA FORWARDING CONDITION
	POP	R0
	SUB	#<POBTBL+1>,R0		;GET OFFSET
	ASL	R0			;MAKE IT WORD INDEX
	JMP	@POBDSP(R0)		;AND DISPATCH

;-----
; HERE IF P.O.B. = 1,  SEND AN X.25 INTERRUPT PACKET, INTERRUPT USER DATA = 1
;-----
POBINT::
	MOV	#.PTINT,R0		; WANT AN INTERRUPT PACKET
	CALL	CTLPKT#	
	BCS	RTN040			; GIVE UP IF CAN NOT GET A PACKET
	MOV	#.FNXIT,R0		; FUNCTION = X.25 INTERRUPT
	CALL	CTLSTR#	
	MOV	#1,R0			; INTERRUPT USER DATA = 1
POBIN2:	CJMP	CTLSTE#			; GO SEND IT

;-----
; HERE IF P.O.B.=2, SEND AN X.25 RESET PACKET
;-----
POBRST::
	MOV	#.PTEAT,R0		; RESET SHOULD FLUSH THE CIRCUIT
	CALL	CTLPKT#			;
	BCS	RTN040			; GIVE UP IF CAN'T GET A PACKET
	BIS	#$T1SOP,SDTRS1#(SD)	; ENABLE THE SUPPRESS OUTPUT FLAG
	MOV	#.FNXRS,R0		; FUNCTION= X.25 RESET
	CALL	CTLSTR#
	CLR	R0			; RESET CAUSE = 0, DTE INITIATED
	BR	POBIN2			;GO SEND IT

;-----
; HERE IF P.O.B.=4, SEND AN INDICATION OF BREAK
;-----
POBBRK:
	MOV	#.PTFUN,R0		;MAKE A FUNCTION PACKET
	CALL	CTLPKT#
	BCS	RTN040			;FORGET IT IF CAN'T HAVE ONE
	MOV	#.FNBRK,R0		;MAKE IT A BREAK FUNCTION
	BR	POBIN2

;-----
; HERE IF P.O.B.=8, ESCAPE TO DATA TRANSFER STATE
;-----
POBESC:
	TBBE	$T0CMD,SDTRS0#(SD),RTN040  ;IGNORE IF CAN'T HAVE CMD MODE
	CLR	R0			;
	JMP	INPIC4

;-----
; HERE IF P.O.B.=21
;-----
POB21:
	MOV	#.PTINT,R0	;WANT TO SEND AN INTERRUPT PACKET
	CALL	CTLPKT#		;
	BCS	RTN040		;GIVE UP IF CAN'T GET A PACKET
	MOV	#.FNXIT,R0	;X.25 INTERRUPT
	CALL	CTLSTR#		;
	CLR	R0		;INTERRUPT USER DATA =0
	CALL	CTLSTE#		;SEND IT
	MOV	#.PTFUN,R0	;MAKE A FUNCTION PACKET
	CALL	CTLPKX#
	BCS	RTN040
	BIS	#$T1SOP,SDTRS1#(SD)  ;
	MOV	#.FNBRK,R0	;BREAK INDICATION
	CALL	CTLSTR#
	MOV	#8.,R0		;PARAMETER # 8, DISCARD OUTPUT
	CALL	CTLSTR#
	MOV	#1,R0		;  IS ON.
	BR	POBIN2		; GO SEND IT.
.IFF

;-----
; HERE JUST ACCEPT BREAK AS INPUT
;-----
	CALL	SNDTRP#			;SEND ANY PENDING SOURCE PACKETS
	MOV	#.PTFUN,R0		;MAKE A FUNCTION PACKET
	CALL	CTLPKT#
	BCS	RTN030			;FORGET IT IF CAN'T HAVE ONE
	MOV	#.FNBRK,R0		;MAKE IT A BREAK FUNCTION
	CJMP	CTLSTE#			;AND END THE PACKET AND RETURN
.ENDC
	.PAGE
;Subroutine to intialize carrier state when connecting to a terminal
;	CALL	CON2TR
;	   Error return -  bad state!
;	Normal return
;  This subroutine respects R1

.IF EQ	..SAT
CON2TR::PUSH	R1			;Save R1
	MOVB	SDTRCS#(SD),R1		;GET TERMINAL CARRIER STATE
	JMP	@CN2DSP(R1)		;DISPATCH ON IT

;DISPATCH TABLE FOR CON2TR

	PURE

CN2DSP:	.WORD	CN2T00		;.CSHNG =  0 - TERMINAL IS HUNG UP (IDLE)
	.WORD	CN2RTN		;.CSCDT =  2 - CARRIER DETECT TIMEOUT (WAITING
				;		 FOR CARRIER AFTER RING DETECT)
	.WORD	CN2RTN		;.CSCDD =  4 - CARRIER DETECT DELAY
	.WORD	CN2T06		;.CSBRD =  6 - BAUD RATE DETECT
	.WORD	CN2RTN		;.CSSEL = 10 - INITIAL SETUP WAIT FOR 2741
	.WORD	CN2T12		;.CSNRM = 12 - NORMAL
	.WORD	CN2RTN		;.CSBCL = 14 - CARRIER LOSS TIMEOUT - BAUD RATE
	.WORD	CN2RTN		;.CSSCL = 16 - CARRIER LOSS TIMEOUT - 2741 SETUP
	.WORD	CN2RTN		;.CSNCL = 20 - CARRIER LOSS TIMEOUT - NORMAL
	.WORD	CN2RTN		;.CSIGN = 22 - IGNORE EVERYTHING

	CODE

;+--us801
;HERE FOR STATE = .CSNRM - NORMAL
CN2T12:
	TBBE	$T1CMD,SDTRS1#(SD),CN2T00;if not in command mode
	BR	CN2RTN			;else, reject the connection
;---US801
;HERE FOR STATE = .CSBRD - BAUD RATE DETECT

CN2T06:	CALL	BRDRST			;RESET DETECT ROUTINE
					;FALL INTO CN2T00

;HERE FOR STATE = .CSHNG - HUNG UP

CN2T00:	CALL	SETRAT			;SETUP BAUD RATE
	  NOP
	MOVB	#.CSNRM,SDTRCS#(SD)	;UPDATE CARRIER STATE
	ADD	#2,2(SP)		;Give skip return
CN2RTN:	POP	R1			;Restore R1
	RETURN
.ENDC
	.PAGE
;SUBROUTINE TO HANG UP A TERMINAL
;	CALL	HANGIT

HANGIT::	TBBN	$T0DDD,SDTRS0#(SD),2$	;
	TBBN	$T0HWR,SDTRS0#(SD),RTN050;IGNORE THIS IF HARDWIRED
2$:	MOV	#.LFFHG,R0		;GET FUNCTION
	CALL	TRMFNC			;GO DO IT
	TBBE	$T0DDD,SDTRS0#(SD),RTN050
	MOV	#JIFSEC#,R0		;WAIT A WHOLE SECOND
	MOV	#ANSTRM,R1		;GO ANSWER IT
	CJMP	TIMREQ#

;SUBROUTINE TO RESET TERMINAL
;	CALL	RSTTRM

RSTTRM:	CALL	DELSRC#			;DELETE POSSIBLE INPUT
	  NOP
.IF EQ ..SAT
	CALL	CLRIHB#
	CALL	CLRCMC#
.ENDC
	MOV	#OUTGET,SDTROD#(SD)	;RESET OUTPUT DONE DISPATCH
	BICB	#.OSESC,SDTROS#(SD)	;Clear the escape processing flag
	BIC	#$T1SOP!$T1DEA!$T1CMD!$T1IMI!$T1IMO,SDTRS1#(SD)
	BIC	#$S1HLD,SDSTS1#(SD)	;CLEAR SOME BITS
	BIC	#$T5AOX,SDTRS5#(SD)
	BIC	#^C<$T3IRT!$T3ORT>,SDTRS3#(SD);CLEAR ALL BUT BAUD RATES
RTN050:	RETURN				;THATS ALL

;SUBROUTINE TO INITIALIZE TERMINAL BAUD RATE
;	CALL	SETRAT
;	  RETURN IF AUTO-BAUD
;	RETURN IF NOT AUTO-BAUD

SETRAT:	CALL	SETDFT#			;Set default terminal type and profile
	MOV	SDTRBR#(SD),R1		;Get baud rates
	BIC	#^C<$BRIRT!$BRORT>,R1
	CMPB	#RATAT0,R1		;AUTO-BAUD TERMINAL?
	BGE	2$			;NO
	MOVB	#.CSBRD,SDTRCS#(SD)	;YES-UPDATE CARRIER STATE
	MOVB	R1,R1			;GET ADDRESS OF DETECT TABLE
	ASL	R1
	MOV	ATOTXX#(R1),R1
	CJMP	@(R1)+			;GO SETUP AUTO-BAUD STUFF

;HERE IF NOT AUTO-BAUD TERMINAL

2$:	BIC	#$BRIRT!$BRORT,SDTRS3#(SD);STORE BAUD RATES IN THE SDB
	BIS	R1,SDTRS3#(SD)
	ADD	#2,(SP)			;GIVE SKIP RETURN
	MOV	#.LFSET,R0		;Setup the interface hardware
					;FALL INTO TRMFNC

;SUBROUTINE CALLED TO PREFORM ALL TERMINAL FUNCTIONS EXCEPT OUTPUTTING
;  DATA - TERMINAL MUST NOT BE BUSY
;	C(R0) = FUNCTION
;		.LFSBK =  0  Send break
;		.LFSET =  2  Setup interface hardware
;		.LFANS =  4  Answer line
;		.LFFHG =  6  Hang up line
;	C(SD) = ADDRESS OF SDB
;	CALL	TRMFNC

TRMFNC::PUSH	R1			;Respect R1
	PUSH	R4			;And R4
	MOV	SDTRAD#(SD),R4		;GET ADDRESS OF ADB
	CALL	@ADFUNC#(R4)		;CALL FUNCTION SUBROUTINE IN INTERFACE
					;  DEPENDENT ROUTINES
	POP	R4			;Restore registers
	POP	R1
	RETURN				;Finished
	.PAGE
	.SBTTL	TRM    - Local subroutines

;Subroutine to hold output when output is active
;	CALL	HLDOUT

HLDOUT:	BIS	#$S1HLD,SDSTS1#(SD)	;Set the hold output bit
TRMSTP::MOV	#.LFSTP,R0		;Stop the line driver
	CBR	TRMFNC			;And return

.IF EQ ..SAT

;SUBROUTINE TO UPDATE POSITION ON PAGE FOR LINE FEED
;	CALL	UPPPLF

UPPPLF:	TSTB	SDTRPG#(SD)		;IS THE PAGE SIZE SET?
	BEQ	RTN018			;NO-GO ON
	INCB	SDTRVP#(SD)		;YES-INCREMENT POSITION ON PAGE
	CMPB	SDTRPG#(SD),SDTRVP#(SD)	;BEYOND BOTTOM OF PAGE?
	BGT	RTN018			;NO
	CLRB	SDTRVP#(SD)		;YES-CLEAR VERTICAL POSITION
RTN018:	RETURN

;SUBROUTINE TO UPDATE POSITION ON PAGE FOR VERTICAL TAB
;	CALL	UPPPVT

UPPPVT:	TSTB	SDTRPG#(SD)		;IS A PAGE SIZE SET NOW?
	BEQ	RTN018			;NO-GO ON
	CLR	R1			;YES-GET CURRENT VERTICAL TAB WITHOUT
	BISB	SDTRVT#(SD),R1		;  SIGN EXTEND
	BNE	UPSDT2			;GO ON IF HAVE VT SET
	MOV	#4,R1			;DEFAULT IS 4 LINES
UPSDT2:	CLR	R2			;GET POSITION ON PAGE
	CLR	R3
	BIS	SDTRVP#(SD),R3
	ADD	R1,R3			;ROUND UP
	DEC	R3
	DIV	R1,R2			;ASDANCE TO NEXT VERTICAL TAB STOP
	MUL	R1,R2
	MOVB	R3,SDTRVP#(SD)		;STORE UPDATED VERTICAL POSITION
	RETURN				;FINISHED

.ENDC			;.IF EQ ..SAT
	.PAGE
;SUBROUTINE TO SEND A RED BALL
;	CALL	SNDBAL

SNDRED:	TSTB	SDPCNT#(SD)		;Any packets buffered now?
	BNE	2$			;Yes-forget it for this time
	MOV	#.PTFUN,R0		;MAKE A FUNCTION PACKET
	CALL	CTLPKT#
	BCS	2$			;JUST SET TIMER IF CAN'T GET ONE
	MOVB	#.FNRED,PKDATA(R1)	;MAKE THIS A RED BALL
	INCB	PKCNT(R1)
	CALL	SNDPKT#			;SEND THE PACKET
2$:	BIS	#$T6BOF,SDTRS6#(SD)	;REMEMBER WE HAVE SENT A RED BALL
	BIC	#$T6GBF!$T6RBF,SDTRS6#(SD)
	MOV	#BALTMO,R1		;START THE BALL TIMER
	MOV	#JIFX8#,R0		;8 SECONDS
	CJMP	TIMREQ#			;AND RETURN

;Subroutine to enter deferred echo mode
;	CALL	DEFENT
;	  error return
;	normal return

DEFENT:	TBBN	$T1DEM!$T1CMD,SDTRS1#(SD),2$;ALREADY IN DEFERRED ECHO MODE?
	TBBN	$T3LGI,SDTRS3#(SD),2$
	TBBN	$T4SEL,SDTRS4#(SD),2$	;NO-SELECTRIC TERMINAL?
	BIS	#$T1DEM,SDTRS1#(SD)	;NO-INDICATE DEFERED ECHO
	PUSH	R0			;SAVE CURRENT CHARACTER
	MOV	#.PTFUN,R0		;MAKE A FUNCTION PACKET
	CALL	CTLPKX#
	BCS	DEFERR			;IF CAN'T GET ONE
	MOV	#1*400+.FNDEM,PKDATA(R1);FUNCTION = DEFERRED ECHO MODE
	MOVB	#2,PKCNT(R1)		;SET COUNT
	CALL	SNDPKT#			;SEND THE PACKET
	POP	R0			;RESTORE CHARACTER
2$:	ADD	#2,(SP)			;Indicate success
RTN020:	RETURN				;AND RETURN

;HERE IF CAN'T MAKE CONTROL PACKET

DEFERR:	TST	(SP)+			;FIX UP THE STACK
	CJMP	RNGBEL#			;RING HIS BELL
	.PAGE
;SUBROUTINE TO SEND GREEN BALL IF WE CAN
;	CALL	SNDGRN

SNDGRN:	TSTB	SDPCNT#(SD)		;Any packets buffered now?
	BNE	RTN020			;Yes-forget this!
SNDGRX::TBBN	$T6BOF,SDTRS6#(SD),RTN020;IF WE ALREADY HAVE SENT A BALL
	MOV	#.PTFUN,R0		;MAKE A FUNCTION PACKET
	CALL	CTLPKT#
	BCS	RTN020			;FORGET IT IF CAN'T GET A PACKET
	MOVB	#.FNGRN,PKDATA(R1)	;MAKE THIS A GREEN BALL
	INCB	PKCNT(R1)		;PACKET CONTAINS 1 BYTE
	BIS	#$T6BOF!$T6GBF,SDTRS6#(SD);REMEMBER WE HAVE SENT A GREEN BALL
	CJMP	SNDPKT#			;Send it
	.PAGE
;SUBROUTINE TO DO THE WORK FOR X-OFF
;	CALL	HNDXOF
;	  return if should not process as input character
;	return if should be input character

HNDXOF:	TBBE	$T4HOE,SDTRS4#(SD),RTNSK2;Accept character if output hold
					 ;  disabled
	TBBN	$T4SEL,SDTRS4#(SD),RTNSK2;Or if from 2741
	BIS	#$S1HLD,SDSTS1#(SD)	;Enabled-hold output
;
;
;
;********PATCH***********JWR************9/25/80*****************
;****
;****
;****    THE FOLLOWING TWO LINES (INSTRUCTIONS) ARE ADDED EXTRA. *******
;****
;****
;**********************************************************************

;******PUSH AND POP OF R0 AFTER REPORTS OF ^S CHANGING TO BACKSPACE
;******DRE 11/18/80

	PUSH	R0			;Save the character over the calL
        MOV     #.LFSTP,R0              ;****ADDED AS A PATCH*******
        CALL    TRMFNC                  ;****ADDED AS A PATCH**********
	POP	R0			;Continue
;****
;****
;*******END OF PATCH******JWR*********9/25/80***************************
;
;
;
.IF EQ ..SAT
	MOV	#.FNOPH,R2		;Get function
	CALL	XNFSUB			;Send it if necessary
.ENDC
	TBBN	$T5AOX,SDTRS5#(SD),HNDXO4;First time?
	BIS	#$T5AOX,SDTRS5#(SD)	;Yes
2$:	RETURN				;Do not accept character as input

;HERE IF NOT FIRST TIME FOR X-OFF SINCE X-ON (OR X-ON SINCE X-OFF)

HNDXO4:
.IF EQ ..SAT
	TBBE	$T5AOH,SDTRS5#(SD),RTN022;SHOULD IT BE INPUT IN THIS CASE?
.ENDC
RTNSK2:	ADD	#2,(SP)			;Yes-give skip return
RTN022:	RETURN

;SUBROUTINE TO DO THE WORK FOR X-ON CHARACTER - ALSO CALLED BY THE "X-ON"
;  FUNCTION ROUTINE IN TRMF
;	CALL	HNDXON
;	  return if should not process as input character
;	return if should be input character

HNDXON::TBBN	$T4SEL,SDTRS4#(SD),RTNSK2;ACCEPT AS INPUT IF FROM 2741
	TBBE	$S1HLD,SDSTS1#(SD),RTNSK2;ACCEPT AS INPUT IF OUTPUT NOT HELD
	BIC	#$S1HLD,SDSTS1#(SD)	;ENABLED-CLEAR OUTPUT HOLD BIT
.IF EQ ..SAT
	MOV	#.FNOPA,R2		;GET FUNCTION
	CALL	XNFSUB			;SEND IT IF NECESSARY
.ENDC
	TBBE	$T5AOX,SDTRS5#(SD),HNDXO4;FIRST X-ON SINCE X-OFF?
	BIC	#$T5AOX,SDTRS5#(SD)	;YES
	RETURN				;Don't accept as input

;SUBROUTINE TO SEND INPUT HOLD OR INPUT ALLOW FUNCTION IF NECESSARY
;	C(R2) = FUNCTION TO SEND
;	CALL	XNFSUB
;  R0 IS PRESERVED

.IF EQ ..SAT
XNFSUB:	TBBN	$T1CMD,SDTRS1#(SD),4$	;IN COMMAND MODE?
	PUSH	R0			;NO-SAVE CHARACTER
	PUSH	R2			;SAVE FUNCTION
	MOV	#.PTINT,R0		;MAKE AN INTERRUPT PACKET
	CALL	CTLPKX#
	POP	R0			;GET FUNCTION
	BCS	2$			;FORGET IT IF ERROR!
	CALL	CTLSTE#			;FINISH UP WITH THE PACKET
2$:	POP	R0			;RESTORE CHARACTER
4$:	RETURN				;AND RETURN
.ENDC			;.IF EQ ..SAT
	.PAGE
	.SBTTL	TRM    - CHKCCE - Check for control character echoing

;Subroutine to determine how a control character should be echoed
;	CALL	CHKCCE
;	V:clr = Normal
;	V:set = No echo wanted

CHKCCE:	TBBE	$T5SCE,SDTRS5#(SD),4$	;Should we echo control characters?
	TBBN	$T1CMD,SDTRS1#(SD),4$	;No-echo anyway if command mode
	SEV				;Really no echo-set V
4$:	RETURN				;Thats all
	.PAGE
	.SBTTL	TRM    - CRNDLY - Calculate delay for carriage return

;Subroutine to calculate delay needed after a carriage return character is
;  output
;	CALL	CRNDLY
;	Z:set = No delay needed
;	C(R2) = Delay value

CRNDLY:	CLR	R2
	TBBE	$T4BLT,SDTRS4#(SD),1$	;Is this a belt type printer?
	BISB	SDTRLD#(SD),R2		;Yes-use the "line-feed" delay parameter
	BR	10$

;Here if not belt-type printer

1$:	BISB	SDTRCD#(SD),R2		;Get fixed delay parameter
	MOVB	SDTRCV#(SD),R3		;Get variable delay parameter
	PUSH	R0			;Save character
	CLR	R0			;Get horizontal position without
	BISB	SDTRHP#(SD),R0		;  sign extend
	TST	R3			;Make sure not zero!
	BLE	3$
2$:	ASR	R0			;Calculate variable amount
	BEQ	4$
	SOB	R3,2$
3$:	ADD	R0,R2			;Add to fixed delay
4$:	POP	R0			;Restore character
	CMPB	SDTRCM#(SD),R2		;Is this result too large?
	BHIS	10$			;No-its OK
	CLR	R2			;Yes-use the limiting value
	BISB	SDTRCM#(SD),R2
10$: .IF NE ..BUG
	MOVB	SDTRHP#(SD),R3		;Get the line position
	SUB	#70.,R3			;Scale the line position
	BLT	12$			;Less than 70
	CMP	R3,#10.			;Check to see if in range 70 to 80
	BGT	12$	
	ASL	R3			;Convert to word index
	INC	LINLEN(R3)		;Count ending position in line
.ENDC
12$:	CLRB	SDTRHP#(SD)		;Clear horizontal position
	BIS	#$T2CRO,SDTRS2#(SD)	;Indicate carriage return was output
	ASL	R2			;Adjust value and set Z to right thing
	RETURN				;Finished
	.PAGE
	.SBTTL	LFDDLY - TRM - Calculate delay for line feed

;Subroutine to calculate delay for line feed character
;	CALL	LFDDLY
;	Z:set = No delay needed
;	C(R2) = Delay value

LFDDLY:
.IF EQ ..SAT
	CALL	UPPPLF			;Update position on page
.ENDC
	CLR	R2			;Get fill count without sign extend
	TBBE	$T4BLT,SDTRS4#(SD),2$	;Is this a "belt type" terminal?
;;;;;;;;;;;;;;;;;;;;;;;; change made based on TYMNET-I spec. IW 09/30/81 ;;;;
;	MOV	#5,R2			;Yes-use a delay factor of 5!!!
;
	CMPB	#1,SDTRHP#(SD)		;yes, the delay formular should be
	BNE	100$			;  if n=1 then delay factor=par. A
	MOVB	SDTRCV#(SD),R2		;  else delay factor=max(0,
	BR	103$			;         F(par. C)-n) + par. B
					;  n = current carriage position
					;  n is then reset to 1
100$:
	BISB	SDTRCM#(SD),R2		;get max. <CR> delay
	PUSH	R0			;respect R0
	CLR	R0
	BISB	SDTRHP#(SD),R0		;get current carriage position
	SUB	R0,R2			;
	BPL	102$			;use it if >= 0
	CLR	R2			;use 0 otherwise
102$:
	CLR	R0			;
	BISB	SDTRCD#(SD),R0		;get fixed <CR> delay
	ADD	R0,R2			;
	POP	R0			;restore R0
103$:
	MOVB	#1,SDTRHP#(SD)		;reset carriage position to 1
;	INCB	SDTRHP#(SD)		;
	TST	R2			;set/clear Z bit
;;;;;;;;;;;;;;;;;;;;;;;;; end of update 9/30/81 ;;;;;;;;;;;;;;;;;;;;;;;;;;
	RETURN				;Finished

;Here if not "belt type" terminal

2$:	BISB	SDTRLD#(SD),R2		;Get normal LF delay parameter
	RETURN				;Finished
	.PAGE
	.SBTTL	TRM    - CHRDLY - Setup character delay

;Subroutine to setup for delay after a character
;	C(R0) = Character to output
;	C(R2) = Delay value
;	CALL	CHRDLY

CHRDLY::TBBE	$T0FWN,SDTRS0#(SD),1$	;Go on if want to use time delay
	MOV	SDTRS3#(SD),R4		;Get baud rate of line
	BIC	#^C$T3ORT,R4
	MOVB	FILMUL#(R4),R3		;Calculate number of nulls needed
	MUL	R3,R2
	MOVB	FILDIV#(R4),R4
	DEC	R4
	ADD	R4,R3
	ADC	R2
	INC	R4
	DIV	R4,R2
1$:	CMP	#377,R2			;Too much delay?
	BHIS	2$			;No-go on
	MOV	#377,R2			;Yes-just give him as much as we can!
2$:	MOVB	R2,SDTRDY#(SD)		;Set delay count
	BEQ	4$			;If no delay needed here
	BISB	#.OSDLY,SDTROS#(SD)	;Need delay-set output state bit
4$:	RETURN				;Finished
	.PAGE
	.SBTTL	TRM    - Filler strings

	PURE

	.MACRO	FILL  NAME,STRING
NAME==!.-FLBASE+1
	.BYTE	STRING
	.ENDM

FLBASE:
FILL	FPCRLF,<CR,LF>			;C.R.-L.F. (This must fall into FPDONX!)
FILL	FPDONX,<.FLENX>
FILL	FPCOUT,<.FLCOD,.FLENX>		;Output saved character without
					;  translation
FILL	FPLINF,<LF,.FLEND>		;L.F.
FILL	FPCRTN,<CR,.FLEND>		;C.R.
FILL	FPPRFX,<'_,BS,.FLEND>		;Output underline-backspace followed by
					;  saved character
.IF EQ ..SAT
FILL	FPIXLF,<.FLOSC,.FLENX>		;Output extra line feed after CR
FILL	FPNSPA,<.FLNSP,.FLEND>		;Insert N spaces
FILL	FPNLFD,<.FLNLF,.FLEND>		;Insert N line-feeds
FILL	FPCNCH,<'^,.FLEND>		;Control character echo
FILL	FPCCCR,<CR,LF,'^,.FLISC,CR,LF,.FLEND>;Echo for non-printing special
					     ;  character
FILL	FPCXCR,<CR,LF,'^,.FLISC,'X,'X,'X,CR,LF,.FLEND> ; ECHO LINE DELETE CHAR
						; FOLLOWED BY 'XXX'<CR><LF>
FILL	FPNEBS,<'\,.FLIEC,.FLEND>	;Echo character after backslash
FILL	FPXBSE,<BS,' ,BS,.FLEND>	;Extended delete echo
.ENDC
	.EVEN

	.SBTTL	TRM    - Impure storage

	IMPURE

.IF EQ	..SAT
CINCNT:: .WORD	0			;Characters in per second
COTCNT:: .WORD	0			;Characters out per second
.ENDC
.IF NE ..BUG
LINLEN:	.BLKW	11.			;Mini histogram array for line length
.ENDC
CINLST:: .WORD	0			; Value at end of last second
COTLST:: .WORD	0			; Last value
CPSLST:: .WORD	0			;Al chars, weighted moving average
TRSCNT:	.BYTE	0			;Counter for sync routine
BLKMOK:	.BYTE	0			;BLOCK MODE INHIBIT COUNTER
TRMPHL:	.WORD	0			;PACKET COUNT AT BEGINING OF BLOCK MODE
	.END

D@P