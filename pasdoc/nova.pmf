#document(NOVA Pascal Implementation Notes,<:October 3, 1980:>,,5)
#sect(Thread Machine Overview)
An overview of the threaded code approach used by the NOVA
cross-compiler is given in this section.
#beginlevel
#sect(The thread list)
For each Pascal routine the compiler generates a data structure
known as a ^Uthread list|U.
The thread list is simply a sequential list of relocatable
addresses.
(There is one exception to this; the first three words of the thread
list for a routine contain non-relocatable values.)
During the execution of a user program a cursor is maintained
which defines a current location in the thread list.
This cursor is called the ^Uthread pointer|U and is stored
in auto-increment location 20(8) of page zero.
Bit zero of this location is the indirect bit and is always
set to one.
#sect(The thread list entries)
The thread list entries may be divided into groups of one
to seven addresses.
The first address in each group is the address of a ^Uthread routine|U.
Each of these thread routine entry points represents the
implementation of a ^Uthread machine instruction|U.
The thread routine address is followed by zero to six addresses
of ^Uaccess routines|U.
Each access routine returns the address or value of an operand
of the corresponding thread machine instruction.
The number of access routines, and, whether a value or an address
is returned, is fixed for each thread machine instruction.
#sect(The thread routines)
The thread routine entry points are in a one-to-one correspondence
with the thread machine instructions.
Control is transferred directly from one thread routine to the
next thread routine in the thread list.
This is implemented by having each thread routine end with an
indirect jump through the thread pointer (JMP\\\@20).
All thread routines reside in the Pascal runtime object library (PASLIB.LB)
and are bound with the user program at link time.
Each operand of a given thread machine instruction has an access
type and data type associated with it.
The ^Uaccess type|U indicates whether the operand is read only,
written only, read and written ('modified') or that only the
operand address is used.
These access types are designated by the characters R, W, M and A.
The ^Udata type|U of an operand is either byte, word, longword,
quadword, float, double or aggregate.
The data types are indicated by the one letter identifiers
B, W, L, Q, F, D and A.
#sect(The access routines)
Access routines fetch the operands or operand addresses expected
by the thread machine instructions.
They are either generated by the compiler, or, for certain common
cases, pulled from the Pascal runtime library.
The access routines are subroutines called from the thread routines
via a 'JSR\\\@20'.
The access routines return control to the thread routine via a
'JMP\\\0,AC3'.
The value or address fetched by the access routine is returned to
the thread routine in AC2.
In general, a value is expected by the thread routine if the
operand's access type is Read and the data type is Byte or Word;
otherwise an address is expected.
#sect(The thread machine registers)
The thread machine is a general register machine with 19
registers.
TP is the thread pointer, and, as indicated earlier, is stored
in auto-increment location 20(8).
SP and FP are the stack pointer and frame pointer respectively.
They are realized on the NOVA via the corresponding NOVA hardware
registers.
R0 through R15 are 16-bit general
registers.
These registers are realized via page zero locations on the NOVA.
Some thread machine instructions treat adjacent general registers
as single 32 or 64-bit registers.
#endlevel
#sect(The Access Routines)
This section describes the thread machine's addressing modes,
discusses the access routines in detail and describes
the generation and pooling of the access routines.
#beginlevel
#sect(Thread machine addressing modes)
The thread machine has eight basic addressing modes.
Each of these is described below.
In the syntax specifications, 'n' indicates a general register
number, 'm' indicates a displacement value and 'f' indicates
a count of static levels.
$ski
$ind +3
$par -3
1.\^URegister mode|U.\\A general register (i.e., R0 through R15)
is specified.
The address of the register is the operand address.
$par
Syntax:  Rn
$par -3
2.\^UDisplacement mode|U.\\A word displacement and either FP or a
general register are specified.
The word displacement is added to the contents
of the register.
The result is the address of the operand.
$par
Syntax:\\m(Reg)
$par -3
3.\^UDisplacement deferred mode|U.\\A word displacement and either 
FP or a general register are specified.
The word displacement is added to
the contents of the register.
The result is the address of the operand address.
$par
Syntax:\\@m(Reg)
$par -3
4.\^UDirect mode|U.\\The direct address of the operand is specified.
$par
Syntax:\\<symbol name>
$par -3
5.\^UDirect deferred mode|U.\\The direct address of the operand address
is specified.
$par
Syntax:\\@<symbol name>
$par -3
6.\^UImmediate mode|U.\\The value of the operand is specified.
$par
Syntax:\\#<immediate value>
$par -3
7.\^UNon-local mode|U.\\The number of static levels back to the stack frame
containing the operand, and,  the displacment in that stack frame, are
specified.
The frame pointer for that stack frame is added to the displacement 
specified.
The result is the operand address.
$par
Syntax:\\m(NLf)
$par -3
8.\^UNon-local deferred|U.\\The number of static levels back to the stack
frame containing the operand address, and, the displacement in that stack
frame, are specified.
The frame pointer for that stack frame is added to the displacement
specified.
The result is the address of the operand address.
$par
Syntax:\\@m(NLf)
$ind -3
#sect(Addressing mode/access routine correspondence)
Each access routine may be characterized by its ^Uaccess mode|U.
The access routine has ^Uvalue access mode|U if it returns the
value of the corresponding thread machine operand, and, 
has ^Uaddress access mode|U if it returns the address of the
coresponding operand.
Each access routine is specific to: (1) an address mode,
(2) an access mode, and, (3) the 'parametric component(s)'
of the addressing mode.
The parametric components of each addressing mode are summarized
below:
$ind +3
$ver
1.\Register mode - the register number,
2.\Displacement mode - the register number and the displacement
   value,
3.\Displacement deferred mode - the register number and the
   displacement value,
4.\Direct mode - the direct address,
5.\Direct deferred mode - the direct address,
6.\Immediate - the immediate value,
7.\Non-local mode - the number of levels back and the displacement
   value,
8.\Non-local deferred mode - the number of levels back and the
   displacement value.
$jus
$ind -3
$ski
Some examples of specific access routines are presented below.
Recall that access routines are subroutines called from thread 
routines.
The return address is in accumulator AC3 and the operand
value or address is returned in AC2.
$ski
The access routine for a static variable 'S_VAR' using address
access mode is given below:
$ski
$tabs 9,17,25,33,41,49,57,65,73
$ver
                S_VAR			; word with addr of S_VAR
	ENTRY:	LDA	AC2,.-1		; load the static's address
		JMP	0,AC3		; return to thread routine
$jus
$ski
The example below shows the access routine for register address
mode and value access mode using R3.
$ski
$ver
	ENTRY:	LDA	AC2,<address of R3>	; load the value
		JMP	0,AC3		; return to thread routine
$jus
$ski
Most of the access routines generated by the compiler
(i.e., not the common cases contained in PASLIB) will
load the parametric portion of the address mode and
then jump to an ^Uepilogue routine|U which is specific only
to the address mode and to the access mode.
For example, the access routine and corresponding epilogue routine
for the address '36(FP)' and address access mode is shown below:
$ski
$need 11
$ver
		36			; word containing disp
	ENTRY:	LDA	AC1,.-1		; load displacement
		JMP	@FP_DISP_A	; jump to epilogue,
					;   indirect through page 0
		.
		.
		.
	FP_DISP_A_ENTRY:			
		MFFP	AC2		; load acc with frame ptr
		ADD	AC1,AC2		; add disp to frame ptr
		JMP	0,AC3		; return to thread routine
$jus
$ski
The address of most of the epilogue routines are stored on page
zero.
Some of the infrequently used combinations (displacement and
displacement deferred address modes with high numbered registers)
 either do not use epilogues (i.e., the compiler generates
the entire access routine), or, the address of the epilogue 
routine is generated as part of the compiler generated
access routine prologue.
The compiler's use of page zero is summarized in a later section.
$ski
The access routines for the two non-local address modes are
implemented in two different ways.
If the levels back parameter is one, the prologue code will simply
load the displacement into an accumulator and then jump
to an epilogue routine specific to the case where the static
chain is followed back one level.
If the levels back parameter is greater than one, then
the prologue code loads both the number of levels and the
displacement and jumps to an epilogue routine for this
general case.
#sect(Access routine generation and pooling)
Certain common access routines will reside in PASLIB.
The access routines which are placed in PASLIB include those
for small immediate values and those for small displacements 
from FP.
However most of the access routines will be generated by the
compiler.
The compiler generates an object library file rather than
an object file.
The structure of the object library generated from a
compilation is shown in the following figure.
$ski
$need 18
$ver
	+-------------------------------+
	|				|
	|  Object module one		|
	|   - the thread list		|
	|   - constants larger than	|
	|     one word			|
	|   - access routines for	|
	|     statics and constants     |
	|     larger than one word	|
	|  Force load bit set		|
	|				|
	+-------------------------------+
	|				|
	|  Object module two		|
	|   - remaining access routines |
	|				|
	|				|
	+-------------------------------+
$jus
$ski
Each object library generated contains two object modules.
The first object module contains the thread list, constants
larger than  one word and the access routines for static
variables and constants larger than one word.
The force load bit for the module is set;
whenever the linker searches this library file the first
module will always be pulled from the library.
The second object module contains all the remaining access routines
which the compiler has to generate.
$ski
At link time the user gives the binder the list of object
libraries produced by the compiler and, at the end of the list,
includes the Pascal runtime library, PASLIB.LB.
The binder will pull all of the access routines from the first
object library in the list.
As a result of  the use of a uniform naming scheme for the access routines,
only access routines not already pulled from previous libraries
will be pulled from the second object module in subsequent libraries.
The net result is that all access routines except those for multi-word
constants and public variables are pooled across the
entire program.
Access routines for multi-word constants and public variables
are pooled across a compilation unit.
#sect(Access routine names)
A uniform naming system is used for naming all access routines
except those associated with direct and direct deferred address
modes.
This system is summarized below based on the address mode associated
with the access routine.
The first two characters always indicate either the register
involved or the addressing mode.
The third character is always either an 'A' for address access mode
routines or a 'V' for value access mode routines.
The fourth character is always a period to distinguish the
access routine name from user symbols.
$ski
$ver
1. Register mode.
   Characters 1 and 2: the register name with the register number
      in hex ('FP', 'R0'..'RF').
   Character 3: 'A' if address access mode; 'V' if value access mode.
   Character 4: the character '.'.
2. Displacement and displacement deferred modes.
   Characters 1 and 2: the register name with the register number
      in hex ('FP', 'R0'..'RF').
   Character 3: 'A' if address access mode; 'V' if value access mode.
   Character 4: the character '.'.
   Characters 5 - 8: the displacement as 4 hex digits.
   Character 9: '@' if deferred mode; otherwise null.
3. Immediate mode.
   Characters 1 and 2: the characters 'IM'.
   Character 3: 'A' if address access mode; 'V' if value access mode.
   Character 4: the character '.'.
   Characters 5-8: the immediate value as 4 hex digits.
4. Non-local and non-local deferred modes.
   Characters 1 and 2: the characters 'NL'.
   Character 3: 'A' if address access mode; 'V' if value access mode.
   Character 4: the character '.'.
   Character 5: the number of static levels back expressed as a 
      single hex digit.
   Characters 6 - 9: the displacement as 4 hex digits.
   Character 10: '@' if deferred mode; otherwise null.
$jus
#endlevel
#sect(Storage Allocation)
Storage allocation for all Pascal data types except record and
arrays is shown in the table below.
In unpacked contexts, all allocation is done in multiples of words and
all data items are word aligned.
Booleans, enumerated types, characters and integers may be 
allocated in smaller units and with smaller alignments in a packed
context.
Arrays and records are always word aligned.
The size of an array or record is derived from the size and
alignment of its components.
The size of a set is always a multiple number of words.
The set element corresponding to bit zero of every word of
the set has the value zero modulo 16.
$ski 2
$need 15
$ver
		  unpacked		       packed
^Udata type|U	^Ualign|U	^Usize|U		^Ualign|U		^Usize|U

boolean		word	word		byte		byte
enumerated	word	word		byte/word	byte/word
char		word	word		byte		byte
integer 16	word	word		byte/word	byte/word
integer 32	word	long		byte/word	byte/word/long
real		word	long		word		long
double		word	quad		word		quad
pointer		word	word		word		word
file		word	word		word		word
proc/func	word	long		word		long
set		word	n words		word		n words
string		word	n+2 bytes	word		n+2 bytes
$jus
#sect(The Pascal Stack)
This section describes the conventions governing the use of
the stack and the format of a stack frame.
#beginlevel
#sect(Stack frame conventions)
The NOVA registers SP and FP are used as the top of stack and
topmost stack frame pointers respectively.
The stack top is always adjusted upwards by explicitly storing
into SP.
The NOVA PSHA and SAV instructions are ^Unever|U used by the thread routines
or the access routines.
This is necessary to avoid stack overflow traps when a 255 word
boundary is crossed during the execution of these two instructions.
The thread routines check for stack overflow both when a user
procedure is entered and when a dynamic temporary is allocated.
The stack grows up towards the top of memory;
the heap starts at the top of (user) memory and grows down
toward the stack.
#sect(Stack frame format)
The format of a stack frame is shown in the following figure.
Most of the entries should be self-explanatory;
however the following section on procedure calling conventions
describes the contents in more detail.
$ver
$need 36
	+-----------------------+   +  (higher addresses)
  SP -->|	dynamic		|      (top of stack)
	|	  temps		|
	+-----------------------+
	|    reg save count	| 
	+-----------------------+
	|      saved regs       | 
	|      (R2 - Rn)	|
	+-----------------------+
	|	static		|
	|	  temps		|
	+-----------------------+
	|	local		|
	|	  variables	|
	|			|  4(FP)
	+-----------------------+
	|  trace block address	|  3(FP)
	+-----------------------+
	|   reg save pointer	|  2(FP)
	+-----------------------+
	|	static link	|  1(FP)
	+-----------------------+
  FP -->|	old TP		|   (FP)
	+-----------------------+
	|	old FP		| -1(FP)
	+-----------------------+
	|    arg block size	| -2(FP)
	+-----------------------+
	|	argument	| -3(FP)
	|	  block		|
	+-----------------------+
	| dynamic temps required|
	| during parameter	|
	| evaluation, if any	|
	+-----------------------+
	|			|   -  (lower addresses)
$jus
#endlevel
#sect(Procedure Calling Conventions)
This section discusses the procedure calling conventions
of the thread machine.
#beginlevel
#sect(Parameter passing)
The argument words are pushed onto the stack after all the
actual parameters are evaluated.
This guarantees that any dynamic temporaries required
for parameter evaluation are allocated before
the argument block is pushed onto the stack.
Thus the arguments are at fixed offsets from the new frame
pointer;
parameters are addressed as negative offsets from the 
frame pointer.
$ski
VAR parameters are passed by address.
Function return values are treated as an implicit initial
VAR parameter.
Record, array, varying string and non-flexible nonvarying string
value parameters are passed
by address.
Flexible nonvarying string value parameters are passed by byte pointer.
If the type of the formal is a flexible type, then the address or
byte pointer is preceded by an argument giving the upperbound of the
flexible array or string.
Sets longer than four words are passed by address;
other sets are passed by value.
All other value parameters are passed by value.
#sect(Routine entry blocks)
At the beginning of each procedure's or function's thread list,
three data words constituting a ^Uroutine entry block|U are generated.
The first word is the size in words of the fixed size portion 
of the routine's stack frame.
The second word is the number of registers to save on entry to
the routine.
This value is the number of contiguous registers to save starting
with R2 and continuing upwards toward higher registers.
The third word contains the size of the argument block for
the rout
All of the values in the routine entry block are used by the
thread machine call instructions.
#sect(The procedure call instructions)
The CALL1 and CALLN instructions are used for calling Pascal procedures.
If the called procedure is known at compile time to be declared
at lexic level one, then the CALL1 instruction is used;
otherwise the CALLN instruction is used.
The CALL1 instruction has one operand: the address of the start of
the thread list (i.e., the address of the routine entry block)
 for the called procedure.
The CALLN instruction has an additional operand, the address of
the static link for the called routine.
The call instructions perform the following actions:
$ver
1. allocate space for the new stack frame and check for stack
   overflow,
2. save the address of the register save count word of the
   new stack frame in the new stack frame,
3. save the register save count in the new stack frame,
4. save R2 through Rn, where Rn is determined from the value
   in the routine entry mask,
5. save the argument block size in the new stack frame,
6. save the old FP and TP in the new stack frame,
7. save or clear the static link field in the new stack frame,
8. zero the trace block address field in the new stack
   frame,
9. set the new values of FP and TP,
10. transfer control to the called routine via the normal indirect
   jump through the thread pointer.
$jus
The general registers which are saved are stored in the new stack
frame above the locals and static temporaries.
This simplifies the code generators addressing of locals, static
temporaries and parameters.
#endlevel
#sect(Debugging Aids)
A stack trace back will be provided following any fatal 
errors detected by the Pascal runtime system.
The trace will also be available by explicit calls to
the predefined procedure TRACE.
When the TRACE compiler option is used, the first thread machine
instruction of each routine will move the address of a
^Utrace block|U to a fixed offset in the stack frame.
The trace block consists of one word containing the length
in characters of the procedure's name, followed immediately
by the text of the name, stored one character per byte.
#sect(Use of Page Zero)
The cross-compiler's use of page zero is summarized in this section.
Currently this section merely lists the uses made of page zero.
The exact amount of space used and the addresses assigned each
usage are not yet determined.
#beginlevel
#sect(The thread machine registers)
The thread machine registers R0 through R15 occupy
16(10) words of page zero storage.
#sect(Auto-increment and auto-decrement locations)
Location 20(8) is used as the thread pointer.
Several other locations are used internally by thread
routines.
#sect(Constants)
The values of a as yet undetermined range of small constants
will be stored on page zero.
These values will be used both as immediate operands and for
common register displacements.
#sect(Addresses of epilogue routines)
The table below summarizes which access routine epilogue addresses
will be stored on page zero.
$ski
$need 13
$ver
					      ^Uaccess mode|U
^UAddress mode|U				     ^Uvalue  address  size|U
Disp mode for FP, R2 - R7			x	x      14
Disp deferred mode for FP, R2 - R7		x	x      14
Direct						x		1
Direct deferred					x	x	2
Immediate					x		1
Non-local (1 level back)			x	x	2
Non-local (>1 level back)			x	x	2
Non-local deferred (1 level back)		x	x	2
Non-local deferred (>1 level back)		x	x	2

TOTAL:							       40
$jus
#endlevel

$ski 4
(pasdev6)nova.pmf

#toc
    r@ 	