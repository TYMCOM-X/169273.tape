












                        PROPRIETARY DOCUMENT INFORMATION
                        ----------- -------- -----------


     The  material  contained  in  this   document   is   proprietary   and
     confidential  to  Tymshare,  Incorporated,  and  is  not  to  be used,
     reproduced or disclosed except in accordance with program  license  or
     with   written   permission  from  the  legal  division  of  Tymshare,
     Incorporated, 20705 Valley Green Drive, Cupertino, California 95014.


                   Copyright (C) 1979, 1980 by Tymshare, Inc.






























































                               TYM-PASCAL REPORT
                                February 8, 1980




     Abstract:   This   document   defines   the    TYM-Pascal    language,
     incorporating  existing  and planned changes to "standard" Pascal.  It
     supersedes the Jensen/Wirth "PASCAL User Manual and  Report"  and  the
     various appendices to be found in the "TYM-Programming Manual".










































     TABLE OF CONTENTS


     1.           INTRODUCTION                                       %

     2.           SUMMARY OF THE LANGUAGE                            %

     3.           NOTATION AND TERMINOLOGY                           %

     4.           LEXICAL SYNTAX                                     %

     5.           PROGRAM STRUCTURE                                  %

     5.1          Kinds of Compilations                              %
     5.1.1        Main Programs                                      %
     5.1.2        Subroutine Modules                                 %
     5.1.3        Data Modules                                       %
     5.2          Block Structure                                    %

     6.           DECLARATION AND USE OF NAMES                       %

     6.1          Declarations                                       %
     6.2          Scope of Names                                     %
     6.3          Label Declarations                                 %
     6.4          Constant Declarations                              %
     6.5          Variable Declarations                              %
     6.6          Other Declarations                                 %

     7.           PROCEDURES AND FUNCTIONS                           %

     7.1          Declaration of Actual Subroutines                  %
     7.2          Parameters                                         %
     7.3          Subroutine Invocation                              %
     7.4          Subroutine Values                                  %

     8.           TYPES                                              %

     8.1          The Definition of Types                            %
     8.2          Simple Types                                       %
     8.2.1        Scalar Types                                       %
     8.2.1.1      Integer                                            %
     8.2.1.2      Character                                          %
     8.2.1.3      Enumerated Types                                   %
     8.2.1.4      Boolean                                            %
     8.2.2        Real                                               %
     8.2.3        Subrange Types                                     %
     8.3          Pointer Types                                      %
     8.4          Set Types                                          %
     8.5          Subroutine Types                                   %
     8.6          File Types                                         %
     8.7          Structured Types                                   %
     8.7.1        Array Types                                        %
     8.7.1.1      Fixed Length Arrays                                %













     8.7.1.2      Flexible Arrays                                    %
     8.7.1.3      Generic Arrays                                     %
     8.7.1.4      Assignment of Arrays                               %
     8.7.2        String Types                                       %
     8.7.3        Record Types                                       %
     8.8          Implicit Type Conversion                           %
     8.9          Explicit Type Conversion                           %

     9.           REFERENCES                                         %

     9.1          Entire References                                  %
     9.2          Field References                                   %
     9.3          Indexed References                                 %
     9.4          Substring References                               %
     9.5          Pointer References                                 %
     9.6          Function References                                %
     9.7          Component References                               %

     10.          EXPRESSIONS                                        %

     10.1         Simple Expressions                                 %
     10.1.1       Primitive Expressions                              %
     10.1.2       Set Expressions                                    %
     10.1.3       Arithmetic Operators                               %
     10.1.3.1     Unary Operators                                    %
     10.1.3.2     Arithmetic Operators                               %
     10.1.3.3     Relational Operators                               %
     10.1.4       Boolean Operators                                  %
     10.1.5       Set Operators                                      %
     10.1.6       String Operators                                   %
     10.2         Composite Expressions                              %
     10.2.1       Record Expressions                                 %
     10.2.2       Array Expressions                                  %

     11.          STATEMENTS                                         %

     11.1         Simple Statements                                  %
     11.1.1       Assigment Statements                               %
     11.1.2       Call Statements                                    %
     11.1.3       Goto Statements                                    %
     11.1.4       Return Statements                                  %
     11.1.5       Stop Statements                                    %
     11.2         Structured Statements                              %
     11.2.1       Compound Statements                                %
     11.2.2       With Statements                                    %
     11.2.3       Conditional Statements                             %
     11.2.3.1     If Statements                                      %
     11.2.3.2     Case Statements                                    %
     11.2.4       Repetitive Statements                              %
     11.2.4.1     While Statements                                   %
     11.2.4.2     Repeat Statements                                  %
     11.2.4.3     For Statements                                     %
     11.2.4.4     Loop Statements                                    %













     11.2.4.5     Exit Statements                                    %

     12.          POINTERS AND DYNAMIC ALLOCATION                    %

     12.1         Allocation and Deallocation of Pointers            %
     12.1.1       Allocation                                         %
     12.1.2       Deallocation                                       %
     12.2         Operations on Pointers                             %
     12.3         Pointers to Records with Variants                  %
     12.4         Pointers to Flexible Arrays                        %
     12.5         Pointer Coercions                                  %

     13.          EXCEPTIONAL CONDITION HANDLING                     %

     14.          INPUT/OUTPUT                                       %

     14.1         File Types, Variables, and Modes                   %
     14.2         Association with Physical Files and Devices        %
     14.2.1       Association                                        %
     14.2.2       Disassociation and Multiple Associations           %
     14.3         Textfile Input/Output                              %
     14.3.1       Textfile Structure                                 %
     14.3.2       Basic Character Input/Output                       %
     14.3.2.1     Character Set and the ASCII Option                 %
     14.3.2.2     Carriage Control and the CONTROL Option            %
     14.3.3       Character Input/Output Conversions                 %
     14.3.3.1     Default Input Conversions                          %
     14.3.3.2     Default Output Conversions                         %
     14.3.4       Formatted Input/Output                             %
     14.3.4.1     Formatted Input                                    %
     14.3.4.2     Formatted Output                                   %
     14.3.5       Interactive Textfile Input/Output                  %
     14.3.6       IMAGE Input/Output                                 %
     14.4         Typed Input/Output                                 %
     14.4.1       The Pascal Typed File Model                        %
     14.4.2       Association of Typed Files                         %
     14.4.3       Data Transfer Operations for Typed Files           %
     14.4.4       Random File Operations                             %
     14.5         Binary Files                                       %
     14.5.1       Extension of the Typed Formalism for Binary Files  %
     14.6         Errors in Input and Output                         %
     14.6.1       The Predefined Type IO_STATUS                      %
     14.6.2       Fatal and Non-fatal I/O Errors                     %
     14.6.3       Meanings of I/O Error Codes                        %
     14.6.4       Extended Status                                    %

     15.          STANDARD FUNCTIONS                                 %

     15.1         Arithmetic Functions                               %
     15.1.1       Ordinary Mathematical Functions                    %
     15.1.2       Generic Mathematical Functions                     %
     15.1.3       Miscellaneous                                      %
     15.2         Type Conversion Functions                          %













     15.2.1       Arithmetic Conversions                             %
     15.2.2       Scalar and Pointer Conversions                     %
     15.3         Operations on Simple Types                         %
     15.4         String Functions                                   %
     15.5         File Predicates                                    %
     15.6         Environment Inquiries                              %
     15.7         Attribute Inquiries                                %
     15.8         Predefined Constants                               %
     15.9         Functions in Constant Expressions                  %

     Appendix     SYNTAX                                             %



















































                                                        TYM-Pascal Report/1
                                                           February 8, 1980


     1.  INTRODUCTION

     The  TYM-Pascal  language  is  an  extended  version  of  the language
     described in the Pascal User Manual and Report  (K. Jensen,  N. Wirth,
     Springer-Verlag,  New  York: 1974).  The  extensions make possible the
     construction of  large,  sophisticated  software  systems  in  Pascal,
     without  compromising  their  machine  independence.  It is a suitable
     implementation language for both business and scientific applications,
     as  well  as  certain types of higher-level systems programs.  We have
     written  a  compiler,  a  database   system,   and   two   substantial
     applications  in the language.  All are portable.  Some provisions are
     made in the language for writing  programs  which  interface  directly
     with  hardware  or  operating  systems.  Although programs using these
     features may  not  be  portable,  we  do  not  feel  that  this  is  a
     significant  limitation,  as  such  programs  are seldom moved between
     machines.

     TYM-Pascal removes many arbitrary restrictions imposed  by  the  basic
     Pascal  language.  A  full type definition may be used in places where
     previously only a type identifier was allowed.  An expression  with  a
     constant  value  may  be  used  where  before,  a  simple constant was
     required.  A function  may  return  a  value  of  any  type  except  a
     procedure,  rather  than  only  a  scalar  or a pointer.  We have also
     removed troublesome limitations of Pascal which have often been  noted
     elsewhere.  Actual  arrays  of varying length may be bound to a formal
     parameter of "flexible"  array  type.  Additional  standard  functions
     returning  the  actual bounds of array parameters make construction of
     routines   manipulating   array   parameters   of   variable    length
     straightforward.

     Other  extensions  provide completely new capabilities.  Some of these
     simplify the programming of certain  common  manipulations  previously
     difficult  to  accomplish  in Pascal.  An example is the addition of a
     string type, allowing character arrays whose lengths vary at run  time
     to  be  defined  and then manipulated via such operations as substring
     extraction and concatenation.  We feel that the  remaining  extensions
     are simply needed to produce production quality software.  The ability
     to detect, isolate, and, in some instances, to  recover  from  certain
     exceptional conditions without execution termination is an example.

     We  have  endeavored  to  make the new syntax consistent with the base
     language.  A few minor incompatibilites are  necessitated  by  certain
     extensions.  Efficient  compilation remains possible in a single pass,
     and the  language  continues  to  exhibit  high  redundancy,  allowing
     considerable  program  verification to be performed by the compiler or
     by compiler-generated  run-time  checking  code.  TYM-Pascal  broadens
     Pascal's  scope  of  applicability  without  compromising its original
     goals.

     The remainder of this document describes the TYM-Pascal language in  a
     manner  similar  to  that used in the Pascal Report.  The intent is to
     describe the language precisely and  completely,  independent  of  any
     implementation.









                                                        TYM-Pascal Report/2
                                                           February 8, 1980


     2.  SUMMARY OF THE LANGUAGE

     A  Pascal  program  consists  of  a  main program and other separately
     compiled modules containing only subroutines and/or data.

     The main program is organized as a block with  a  declaration  section
     and  a  statement  section.  The declaration section defines the data,
     procedures and functions to be used.  The statement section gives  the
     actions  to be performed.  The procedure and function declarations are
     themselves blocks and may contain further "local"  declarations.  This
     nesting  of  blocks  within  one another is called block structure and
     delimits the scope of the names declared.

     Subroutine and data modules contain only a declaration section,  which
     may  be  viewed  as  an adjunct to that of the main program.  However,
     declarations  are  not  automatically  shared  between  modules.   For
     sharing  to  occur, a name must be defined in one module with a public
     declaration,  and  referenced  in  other  modules  with  an   external
     declaration.  External declarations may also refer to names defined in
     modules written in other languages.

     The declarations define six categories of names:  labels, which  label
     statements used as potential targets of gotos; consts, which are named
     constant values used to parameterize the program  and  to  store  data
     which  is  not  modified; vars, which are program variables; procedure
     and function identifiers, which are the names by which subroutines are
     referenced,   and  types,  which  are  essentially  macros  describing
     commonly used classes of data.  Except for type names, all names  must
     be declared before they are referenced in other declarations or in the
     program text.

     A label declaration introduces numeric labels which are later  defined
     by their appearance in the statement section of the block.

     A  const declaration defines an identifier of a specified (or implied)
     type which has a fixed value, and  thus  cannot  be  assigned  to.  An
     external  const  declaration  does  not  specify the value, as that is
     given in the corresponding public declaration in another module.

     A var declaration defines an identifier as a variable of some type.  A
     variable's  lifetime  is normally the same as the block in which it is
     declared.  Variables declared in the outermost block of a compilation,
     or  declared  as  static, have the same lifetime as the program block,
     i.e., they exist throughout program execution.  Initial values may  be
     specified for such variables.

     A  procedure  declaration binds an identifier to a parameterized block
     describing some  operation.  Each  parameter  is  denoted  within  the
     procedure  by  an  identifier,  called  the formal parameter,h is
     defined as part of the procedure declaration.  An  invocation  of  the
     procedure  must  specify an actual quantity to be bound to each formal
     parameter.  There  are  two  kinds  of   parameters:   value   (input)
     parameters and var (input/output) parameters.  With a value parameter,









                                                        TYM-Pascal Report/3
                                                           February 8, 1980


     the actual parameter is an expression  which  is  evaluated  once  and
     bound  to the formal parameter.  Within the procedure, assignment to a
     formal value parameter  is  not  allowed.  With  var  parameters,  the
     actual  parameter  is  an  evaluated  reference to a variable, and the
     formal parameter stands for this variable.

     An external procedure declaration only gives the kind (value, var) and
     type   of   the   parameters.  Formal  parameter  identifiers  may  be
     optionally specified.

     Functions are declared analogously to procedures, with  the  exception
     that the type of the result returned by a function is specified in its
     declaration.  The  value  returned  is  taken  from  a  special  local
     variable   named  with  the  function  identifier.  Thus,  within  the
     function, assignment to the function identifier sets the return value;
     use  of  the  function  identifier  in an expression denotes use of an
     intermediate result.  In the latter case, a recursive invocation of  a
     function is syntactically distinguished from a reference to the return
     value by the presence of an actual parameter list, which may be empty.

     The Pascal language  is  strongly  typed.  All  constants,  variables,
     parameters  and  functions have a data type which regulates their use.
     The data type essentially defines the values which may be assumed by a
     variable  of  the  type  and  the operations which may be performed on
     these values.  A data type may  be  either  directly  described  in  a
     declaration  or  may  be referenced through an identifier defined in a
     type declaration.

     The simple types encompass  the  basic  computational  values  in  the
     language:  scalar  types  and reals.  Scalars are used as cardinal and
     ordinal values, and include the so-called  enumerated  types  and  the
     standard  types  boolean,  integer  and character.  An enumerated type
     defines an ordered list of values where each value  is  denoted  by  a
     constant  identifier.  Booleans are the logical values true and false;
     integer values are written as octal and decimal integer  numbers;  and
     character   values   are   given  as  single  characters  enclosed  in
     apostrophes.  Reals are floating point values entered  as  numbers  in
     fractional (fixed point) or exponential (floating point) notation.

     A  type  may  also be defined as a subrange of a simple type by giving
     the smallest and largest value of the range.  A real subrange  may  be
     further  defined  with  a  precision  factor  specifying  the required
     precision of values, i.e., the number of significant decimal digits in
     the mantissa (fraction).

     Pointer  type  values  address variables of a single, specified target
     type.  A pointer may be assigned to or compared with  another  pointer
     without  accessing  their  target variables.  The target variable of a
     pointer is accessed by dereferencing the pointer variable.  There is a
     single  pointer constant, denoted by nil, which points to no variable.
     Other pointer values are generated  in  one  of  three  ways:  (1)  by
     dynamic  allocation  of  storage  for a variable (the variable must be
     freed before the pointer is discarded), (2) by taking the address of a









                                                        TYM-Pascal Report/4
                                                           February 8, 1980


     program  variable  declared in the usual way, and (3) by converting an
     integer to an address.  The latter two represent  relaxations  on  the
     restrictions  placed on pointers in "standard" Pascal, and provide the
     ability to manipulate addresses directly, often  required  in  systems
     programming.

     Procedure  and function types define the kinds and types of the formal
     parameters to a subroutine, and, in the case of a function, the result
     type.  Procedure and function types are used to designate variables or
     formal parameters which indirectly reference actual subroutines.

     File types define variables through which input  from  and  output  to
     physical files and devices is performed.  Sequential and random access
     to blocks of data which may vary in length  is  provided,  along  with
     additional  conversion and formatting facilities for files composed of
     lines of characters.

     A set type defines a powerset of  some  specified  scalar  base  type,
     i.e., the set of all subsets of the type.

     In  addition to these elementary types, there are the structured types
     containing one or more components which may be separately  referenced.
     These  components  may, in turn, be of either elementary or structured
     type.  There  are  three  such  types  available:  arrays,   character
     strings, and records.

     An array is a homogeneous structure addressed by a computable index of
     some scalar type.  The type of the index and the component  are  given
     in   the  array  type  definition.  Multi-dimensional  arrays  may  be
     declared and each dimension may be indexed by a different scalar type.
     They  are  equivalent  to  arrays  whose  components are other arrays.
     Flexible array types are those for which the  bound(s)  of  the  index
     type  are  not  specified.  They  may  be  used as the types of formal
     parameters, which  assume  the  bounds  of  the  corresponding  actual
     parameter and as components of data dynamically allocated.  Array type
     values are written as parenthesized, row-major lists of values of  the
     component type.

     Character strings are variable length arrays of characters, indexed by
     a subrange of integers from one to some fixed maximum length.  At  any
     time,  only  the  leftmost  n  (0 <= n <=  maximum  length)  character
     positions need be occupied.  The value n is called the current  length
     of  the  string.  Values  of  type  string  are  denoted by characters
     enclosed by apostrophes.  In assignment, comparison and special string
     operations,  values  of  type  CHAR and certain fixed length arrays of
     CHAR are interchangeable with strings.

     A record type  is  a  heterogeneous  structure  of  components  called
     fields.  A  field  selector  is  not a computable value, but rather an
     identifier, unique  in  the  record,  denoting  the  component  to  be
     accessed.  The  field identifiers and their associated component types
     are declared in the record definition.  In effect, a record  describes
     a specific storage layout with named and typed constituents.









                                                        TYM-Pascal Report/5
                                                           February 8, 1980


     A  record  may  be  declared as having several overlaid substructures,
     called variants, which differ in the number and types of the contained
     fields.  This  means  that  variables  of the same record type may, in
     fact,  have  different  structures,  and  that  the  structure  of   a
     particular   record   may  change  during  the  course  of  execution.
     Normally, the different variants are discriminated by the value of  an
     explicitly declared component called the tag field.  When no tag field
     exists, the record is an undiscriminated  union,  and  describes  data
     items which have been "equivalenced" in the FORTRAN sense.

     The  storage  allocated  to  data  of  a particular type is ordinarily
     determined by the compiler, but may  be  controlled  with  the  packed
     attribute.  Simple  values may be placed in the minimum number of bits
     or in a specific number of bits.  Packing an array  or  record  causes
     its  components  to  be  packed  together  according  to  their sizes.
     Pointer, procedure, function, set and string types may not be  packed.
     By  judicious  use  of  padding  fields  and bit packing, most storage
     layouts can be achieved.

     The statement  section  of  a  main  program,  procedure  or  function
     consists of one or more sequentially executed statements.

     The  most  fundamental  statement  is  the assignment statement.  This
     causes a newly computed  value  to  be  assigned  to  a  variable  (or
     component   of   a   variable).   Expressions  consist  of  variables,
     constants, sets, and operator  and  function  invocations.  Of  these,
     Pascal  defines  certain standard constants, functions and conditions,
     and the set of operators, which may be subdivided as follows:

       1.  Arithmetic operators, of addition, subtraction, sign  inversion,
           multiplication,  integer division, real division, exponentiation
           and modulus.

       2.  A string operator, concatenation.

       3.  Logical operators, of  negation,  conjunction,  and  disjunction
           which  operate  on  booleans.  Also, the short-circuited logical
           operators andif and orif.  "Short-circuited" means that the left
           operand  is evaluated first, then the right only if its value is
           needed to determine the result.

       4.  Set operators of union, intersection, and set difference.

       5.  Relational operators, of  equality,  inequality,  ordering,  set
           membership, and set inclusion.  These yield boolean results.

     The call statement invokes a procedure.

     Grouping   of  several  statements  to  be  executed  sequentially  is
     specified by the compound statement; conditional execution, by the  if
     statement  and  the  case  statement; and repetitive execution, by the
     loop, for, repeat and while statements.










                                                        TYM-Pascal Report/6
                                                           February 8, 1980


     The  if  statement  executes  a  statement  dependent  on  a   boolean
     predicate;  the  case  statement  selects from among many alternatives
     according to the value of a scalar expression.

     The loop statement iterates indefinitely; the for  statement  is  used
     when  a bound on the number of executions is known beforehand; and the
     repeat  and  while  statements  are  used  otherwise.  All  repetitive
     constructs  may contain exit if statements specifying loop termination
     predicates and optional actions.

     The with statement opens the scope containing the field identifiers of
     specified record variable(s).  Thus, within the component statement of
     the with, fields of the specified record(s) may be referenced by their
     identifiers alone.

     There  are  three  kinds of statements which alter the regular flow of
     control:  the  stop  statement,  which  halts  execution;  the  return
     statement, which causes a return from a procedure or function, and the
     goto statement,  which  jumps  to  a  designated  statement,  possibly
     aborting subroutine invocations or loops.

     The on statement specifies statement(s), referred to as "handlers", to
     be executed when  certain  asychronous  events  occur  during  program
     execution.






































                                                        TYM-Pascal Report/7
                                                           February 8, 1980


     3.  NOTATION AND TERMINOLOGY

     In  this report, a modified version of traditional Backus-Naur form is
     used to describe the syntax of the language.  Syntactic constructs are
     denoted  by  descriptive  phrases enclosed in the angular brackets '<'
     and '>'.  The symbol '::=' separates the name of a syntactic construct
     (to  the  left)  from  its  definition  (to  the  right).  Alternative
     definitions of a construct  are  separated  by  vertical  bars  ('|').
     Constructs   enclosed   in   square  brackets  are  optional.  If  the
     terminating bracket is immediately  followed  by  an  asterisk,  i.e.,
     ']*',  the  enclosed constructs may be repeated zero or more times.  A
     list of alternatives is enclosed in parentheses if one  of  them  must
     appear.  Underlined  words  represent  reserved words which may not be
     used as program identifiers.  Other special symbols, primarily graphic
     characters, are enclosed in apostrophes, e.g., ';'.

          <special symbol> ::= '+' | '-' | '*' | '/' | '**' | '=' | '<' |
             '>' | '<>' | '<=' | '>=' | ':=' | '(' | ')' | '[' | ']' |
             '.' | '|' | ',' | ';' | ':' | '^' | '..' | <reserved word>

          <reserved word> ::= and | andif | array | begin | case | const |
             datamodule | div | do | downto | else | end| exit | external |
             file | for | forward | function | getstring | goto | if | in |
             label | loop | mod | module | nil | nilf | not | of | on |
             options | or | orif | others | packed | prec | procedure |
             program | public | putstring | read | readln | readrn |
             record | repeat | return | set | static | stop | string |
             then | to | type | until | var | while | with | write |
             writeln | writern


     Commentary  is  also  used  in  the  BNF  of  the language to describe
     syntactical restrictions or properties which would  otherwise  not  be
     apparent.  Symbols  of  the  form  <something  reference>,  <something
     expression>, and <constant something> are understood to be  equivalent
     to   <reference>,   <expression>  and  <constant>,  respectively.  The
     qualifier describes semantic attributes of the symbol.

























                                                        TYM-Pascal Report/8
                                                           February 8, 1980


     4.  LEXICAL SYNTAX

     Identifiers must begin with a letter and may contain letters,  digits,
     and underbars (sometimes printed as backarrows).  All characters in an
     identifier  are  significant.  Upper  and  lower  case   letters   are
     equivalent  in  all contexts except as elements of character or string
     constants.  For  example,  "BEGIN",  "begin",  and  "Begin"  are   all
     acceptable spellings of the reserved word begin.

          <letter> ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
          a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z

          <octal digit> ::= 0|1|2|3|4|5|6|7

          <digit> ::= 0|1|2|3|4|5|6|7|8|9

          <identifier> ::= <letter> [ <letter> | <digit> | '_' ]*

     Numbers  may be either real or integer.  Integer numbers may be either
     decimal or octal, with the latter  being  indicated  by  a  B  (or  b)
     appended to the octal digit(s).  Integer numbers are always considered
     to be non-negative, and thus must be preceded  by  a  minus  ('-')  to
     produce  a  negative  value.  This implies that, on a two's complement
     computer, the most negative number cannot  be  explicitly  used  as  a
     numeric constant in a program, since the numeric portion of a negative
     integer constant is evaluated as a positive integer and then  negated.
     To obtain this value, the constant "minimum(integer)" may be used.

          <unsigned integer> ::= <octal integer> | <decimal integer>

          <decimal integer> ::= <digit> [ <digit> ]*

          <octal integer> ::=
             <octal digit> [ <octal digit> ]* ('B'|'b')

     A  real  number  is  a  decimal integer followed by a decimal point, a
     fractional part, and/or an exponent.  An exponent specifies a power of
     ten.

          <unsigned real> ::=
             <decimal integer> [ '.' [ <decimal integer> ] ]
                [ ( E | e ) [ '+' | '-' ] <decimal integer> ]

     String  constants are enclosed in apostrophes (').  An apostrophe in a
     string constant is indicated by two adjacent apostrophes.  Strings may
     not  extend  across  line boundaries.  Character constants are strings
     containing a single character.  Any printable ASCII  character  (space
     through   '~')   may  be  used  in  string  and  character  constants.
     Non-printing ASCII character constants may be created using the  "CHR"
     function,  which  returns the ASCII character with a specified integer
     value.  For example, "chr(15b)" represents the  carriage  return  (CR)
     character.  Strings  which  are  longer than one line or which contain
     non-printing  characters  may  be  created  by  concatenating  shorter









                                                        TYM-Pascal Report/9
                                                           February 8, 1980


     strings, for example:

          const pw_mask := 'XXX' || chr(15b) || '###'

     which  would  overstrike  the  second string on the first, as might be
     done when printing a password mask.

     Identifiers, numbers, string and character constants, special  symbols
     and  reserved words are all called "tokens".  Text between the symbols
     '(*' and '*)' is treated as commentary,  and  has  no  effect  on  the
     meaning  of  a program.  Comments may be nested, i.e., one comment may
     be contained within another.  Blanks, ends of lines and  comments  are
     considered  as separators.  Any number of separators may occur between
     adjacent tokens, but no separators are allowed within a single  token.
     Adjacent  identifiers,  numbers,  and  reserved  words  (but not other
     special symbols) must be separated by at least one separator.














































                                                       TYM-Pascal Report/10
                                                           February 8, 1980


     5.  PROGRAM STRUCTURE

     A Pascal program  consists  of  one  or  more  independently  compiled
     modules  whose  internal  organization is a recursive block structure.
     Both the division into modules and the intra-module structure serve to
     control access to names.


     5.1  Kinds of Compilations

     Three  different  types  of modules or compilations are distinguished:
     <main program>s, <subroutine module>s and <data module>s:

          <compilation> ::=
             <main program> | <subroutine module> | <data module>

     Each type of compilation is organized as a block with a heading and  a
     body.  The  heading  designates  the  type  of  the module, optionally
     specifies extralingual options which apply during the  compilation  of
     the  body  of the block, and gives the name of the module.  The module
     name has no significance within  the  compilation,  and  need  not  be
     distinct  from  other  names used within it.  The contents of the body
     depend on the type of the module.


     5.1.1  Main Programs

     The body of a <main program> contains an optional declaration part and
     a  required statement part.  The declaration part may include any kind
     of declaration.  The statement part defines the action to be performed
     by the program.

          <main program> ::=
             <program heading> <body> '.'

          <program heading> ::=
             program <identifier> [ <options clause> ] ';'

          <body> ::=
             [ <declaration part> ';' ] <statement part>

          <options clause> ::= options <option> [ ',' <option> ]*

     The syntax of <option>s is not specifically defined by the language.


     5.1.2  Subroutine Modules

     A  <subroutine  module>  contains  only  a declaration part.  Anything
     except a label may be declared, but at least one public  procedure  or
     function must be defined.











                                                       TYM-Pascal Report/11
                                                           February 8, 1980


          <subroutine module> ::=
             <module heading> <module declaration part> '.'

          <module heading> ::=
             module <identifier> [ <options clause> ] ';'

          <module declaration part> ::=
            <module declaration> [ ';' <module declaration> ]*

          <module declaration> ::=
            <data declaration> | <subroutine declaration>


     5.1.3  Data Modules

     A <data module> contains only a declaration part which defines a group
     of data items.  Only types, constants  and  public  variables  may  be
     declared in a data module.

          <data module> ::=
             <data module heading> <data declaration part> end '.'

          <data module heading> ::=
             datamodule <identifier> [ <options clause> ] ';'

          <data declaration part> ::=
            <data declaration> [ ';' <data declaration> ]


     5.2  Block Structure

     A  main  program or subroutine module block may have additional blocks
     nested within it in the form of local subroutine  declarations.  These
     have  a  heading, optional declarations of any kind (including further
     local subroutine declarations), and a required statement part.

     The block  corresponding  to  an  entire  compilation  is  called  the
     "outermost" or "level 1" block.  Subroutine blocks defined within this
     outermost block are at "level 2", and  so  forth.  A  block  which  is
     defined  within  another block is said to be "local" to it; a block is
     "inferior" to another block if it is nested at any level  within  that
     block.




















                                                       TYM-Pascal Report/12
                                                           February 8, 1980


     6.  DECLARATION AND USE OF NAMES

     A  name  may  refer  to  an item belonging to one of seven categories:
     labels,  constants,  types,  variables,  subroutines  (procedures   or
     functions),  field  names,  and formal parameters.  All item names are
     identifiers, except for labels which are denoted by unsigned integers.


     6.1  Declarations

     A name is associated with an item by means of a declaration.  All  but
     parameters  and field names are declared by specific statements in the
     declaration part of a block.

          <declaration part> ::=
             <declaration> [ ';' <declaration> ]*

          <declaration> ::=
             <label declaration> | <data declaration> |
             <subroutine declaration>

          <data declaration> ::=
             <const declaration> | <type declaration> |
             <var declaration>

     Formal parameters are declared in the parameter list of  a  subroutine
     declaration.  Fields  are  declared in the field list of a record type
     declaration.

     A declaration is considered to be at the same level as  the  block  in
     which  it  appears.  For  example, a declaration made in the outermost
     block is at level 1.  The name of a  subroutine  is  declared  in  the
     block  enclosing  the subroutine; the names of parameters are declared
     within the subroutine block and are therefore at a level  one  greater
     than that of the subroutine's name.


     6.2  Scope of Names

     Within  a  compilation,  a  name may refer to more than one item.  The
     block  structure  is  used  to  delimit  the  scope  of  a  particular
     declaration  in order to distinguish between different uses of a name.
     A name is known (i.e., its declaration applies) within  the  block  in
     which  it  is declared and within any inferior block in which there is
     not a local declaration of the same name.  There may not  be  multiple
     declarations of the same name in a single block.

     The  use  of  a function name constitutes an exception to this scoping
     rule.  Within the body of the function, the function  name  may  refer
     either  to  the  function  itself, for recursive invocation, or to the
     function return value.  The two  are  distinguished  by  context.  The
     name  refers  to  the  function  when  it is used in a context where a
     function  is  expected:  (1)  in  a  <function   reference>,   denoted









                                                       TYM-Pascal Report/13
                                                           February 8, 1980


     syntactically  by  a parameter list following the function identifier,
     (2)  as  an  actual  parameter  being  passed  to  a  formal  function
     parameter,  or  (3)  as  the  right  hand  side  of an assignment to a
     function variable.  In  all  other  cases,  the  name  refers  to  the
     function  return  value.  Note  that  only in case (1) is the function
     actually called.

     Within its scope, a name may not be referenced before it is  declared,
     except  in certain cases where a name is used as a type identifier.  A
     type name used in the declaration of an external constant, an external
     variable,  or  an  external subroutine (as a parameter or result type)
     need only be declared before the item is used in the program.  If  the
     item is never used, the type need not be declared at all.  A type name
     used as the target of a pointer type need only be declared before  any
     pointer  having  that  target  type  is  dereferenced  (i.e., before a
     variable pointed to by such a pointer is referenced) or is passed in a
     call to NEW (see Section 12).  Pointers bound to undeclared type names
     may be used freely, so long as they are not dereferenced or passed  to
     NEW.

     If  a  name is declared in both an inner block and an enclosing block,
     and is used before it  is  declared  in  the  inner  block,  then  the
     declaration from the enclosing block will apply.

     Names  are not automatically known in all the compilations composing a
     program.  For sharing to occur, a name must be declared as  public  in
     one  module,  and  as  external  in  another.  A  public  or  external
     designation may only be applied to a constant, variable or  subroutine
     declaration  at  level  1.  The  public declaration defines the actual
     item; the external declaration is only a reference.  Thus, the body of
     a  subroutine,  the  value  of  a  constant, or an initial value for a
     variable is only given  with  the  public  declaration.  The  external
     declaration  must  be identical to the public declaration in all other
     respects.

     The  language  defines  a  number  of  "standard"  constants,   types,
     procedures and functions.  The names of these items are predeclared in
     a scope which  effectively  encloses  the  entire  compilation.  Thus,
     redeclaration  of  a  standard  name,  anywhere  within a compilation,
     overrides the standard declaration.


     6.3  Label Declarations

     A label declaration introduces a numeric label which is to be used  as
     the target of a goto statement.

          <label declaration> ::=
             label <label> [ ',' <label> ]*

          <label> ::= <unsigned integer>

     A label thus declared must be defined by its appearance on a statement









                                                       TYM-Pascal Report/14
                                                           February 8, 1980


     in the same block in which it is declared.


     6.4  Constant Declarations

     Constants are items whose values  are  defined  at  compile  time  and
     cannot  be  modified  by  the  executing  program.  An  identifier  is
     declared as denoting a constant value in a <const declaration>,  which
     specifies a type and/or value.

          <const declaration> ::=
             [ public | external ] const
                <constant definition> [ ';' <constant definition> ]*

          <constant definition> ::=
             <identifier> ':' <type> |
             <identifier> [ ':' <type> ] ( '=' | ':=' ) <constant>

     A  local  constant  is  defined  when  neither  public nor external is
     specified.  A value must be specified for a local constant.  If a type
     is  given,  the value must be compatible with the type; otherwise, the
     apparent type of the value is used.  A type is required when the value
     is  a  <structured  expression>.  A  local  constant  may be used as a
     synonym for its value.

     If  public  is  specified,  the  name  is  made  accessible  to  other
     compilations.  Both  a  type  and  a  value  must be given in a public
     declaration.  The primary use of public constants  is  to  define  and
     initialize  constant tables of information, but, like local constants,
     they may be used anywhere a constant value is needed in the module.

     An external constant declaration permits one  module  to  reference  a
     public  constant  defined  in  another.  Only  the  type is specified.
     Since the value of the constant is not known during  compilation,  the
     name cannot be used where a constant value is required.


     6.5  Variable Declarations

     A  variable declaration consists of a list of identifiers denoting the
     new variables, followed by their type and an optional initial value.

          <var declaration> ::=
             [ public | external | static ] var
                  <var definition> [ ';' <var definition> ]*

          <var definition> ::=
             <identifier list> ':' <type> [ ':=' <constant> ]

          <identifier list> ::= <identifier> [ ',' <identifier> ]*












                                                       TYM-Pascal Report/15
                                                           February 8, 1980


     A variable declaration may specify that the variables  are  static.  A
     non-static  variable  is  created  whenever  the  block in which it is
     declared is entered, and is destroyed when  the  block  terminates.  A
     non-static  variable  in a recursive routine may have several distinct
     versions  in  existence   simultaneously.   Static   variables   exist
     throughout  the  program  execution,  and can thus be used to preserve
     information between calls to a subroutine.  Variables declared in  the
     outermost block of a compilation are always static; variables local to
     a subroutine are normally non-static.

     Only static and public variables  may  be  given  initial  values.  An
     initial  value  must  be  a  constant  which  could be assigned to the
     variable.  The variable receives its initial value when the program is
     loaded.


     6.6  Other Declarations

     Subroutine   declarations   are   described   in   Section  7.1.  Type
     declarations are described in Section 8.1.










































                                                       TYM-Pascal Report/16
                                                           February 8, 1980


     7.  PROCEDURES AND FUNCTIONS

     Procedures and functions (referred to collectively as subroutines) are
     parameterized  blocks  representing  actions  and  computations.  Such
     subroutines may be referenced by an actual subroutine  name  which  is
     permanently  bound  to a particular block, or by a subroutine variable
     or parameter which indirectly references some actual subroutine.


     7.1  Declaration of Actual Subroutines

     A <subroutine declaration> declares an  actual  subroutine  identifier
     and  gives it a type specifying its usage (procedure or function), the
     kinds of parameters which are required by the subroutine, and, in  the
     case of a function, the type of the value it returns.  There are three
     forms:

          <subroutine declaration> ::=
             <actual subroutine declaration> |
             <forward subroutine declaration> |
             <external subroutine declaration>

     An <actual subroutine declaration> specifies the subroutine  body,  in
     addition   to   the  parameterization  specified  in  all  three.  The
     <parameter list> in the  declaration  gives  each  parameter  a  name,
     called  the formal parameter, by which it is referenced in the body of
     the subroutine.  The <options clause> specifies  extralingual  options
     which  apply  during  compilation  of  the subroutine and its inferior
     blocks.  An option setting  in  a  <subroutine  heading>  overrides  a
     setting  established  in  an enclosing block.  The declaration part of
     the body defines the  local  data  and  subroutines  used  within  the
     subroutine; the statement part gives the operations to be performed by
     the subroutine.

          <actual subroutine declaration> ::=
             [ public ] <subroutine heading> ';' <body>

          <subroutine heading> ::=
             <procedure heading> | <function heading>

          <procedure heading> ::=
             procedure <identifier>
                [ <parameter list> ] [ <options clause> ]

          <function heading> ::=
             function <identifier> [ <parameter list> ]
                ':' <type> [ <options clause> ]

     In general, a subroutine must be declared before it can be called.  If
     two  subroutines  each  call  each  other,  then  one  of them must be
     pre-declared with a <forward subroutine declaration> which  gives  its
     type and options clause, but not its body.










                                                       TYM-Pascal Report/17
                                                           February 8, 1980


          <forward subroutine declaration> ::=
             [ public ] <subroutine heading> ';' forward

     The   subroutine   body   must  be  given  in  an  <actual  subroutine
     declaration> later in the same block.  The subroutine heading  in  the
     actual  declaration is ignored; it should either duplicate the heading
     in the forward declaration or consist only  of  the  subroutine  name.
     For example:

          procedure a (x, y: real); forward;

          procedure b;
            begin          (* the body of b *)
            . . .          (* calls a *)
            end;

          procedure a;
            begin          (* the body of a *)
            . . .          (* calls b *)
            end;

     When  public is specified in the declaration of a subroutine, the name
     of the subroutine is made accessible to other compilations.  In  order
     to  reference  the  subroutine,  another  compilation  must include an
     <external subroutine declaration>.  This defines only the name of  the
     subroutine  and the types of the parameters.  The body is omitted, and
     the names of the formal parameters may be omitted as well.

          <external subroutine declaration> ::=
             external <subroutine heading>


     7.2  Parameters

     There are two kinds of parameters:  value (input) parameters  and  var
     (input/output)  parameters.  A  value parameter may not be modified by
     the subroutine, while a var parameter may be.

     The parameters of a subroutine are declared  in  a  <parameter  list>.
     Two  forms  are  recognized:  a  <long parameter list>, which contains
     both the names and the types of the parameters, and a <short parameter
     list>, which contains only the parameter types.  The long form must be
     used  in  actual  and  forward  subroutine  declarations,  since   the
     parameters  must be referenced by name in the subroutine body.  Either
     form is permitted in the declaration of an external  subroutine  or  a
     subroutine type.

          <parameter list> ::=
             <long parameter list> | <short parameter list>

          <long parameter list> ::=
             '(' [ <parameter definition>
                           [ ';' <parameter definition> ]* ] ')'









                                                       TYM-Pascal Report/18
                                                           February 8, 1980


          <parameter definition> ::=
             [ var ] <identifier list> ':' <type>

          <short parameter list> ::=
             '(' [ <parameter description>
                           [ ';' <parameter description> ]* ] ')'

          <parameter description> ::= [ var ] <type>

     A parameter definition or parameter description which does not contain
     the var tag denotes a value parameter.  A parameter  definition  which
     contains  more  than  one  identifier  is  equivalent  to  independent
     declarations of each of the individual identifiers with the same  mode
     (var  or  value)  and type.  There are no restrictions on the types of
     parameters.



     7.3  Subroutine Invocation

     A procedure is invoked by a <call  statement>  designating  an  actual
     procedure name, a procedure parameter or a procedure variable.

     A  function is invoked by a <function reference> designating an actual
     function name,  a  function  parameter,  or  a  function  variable.  A
     function  with  no  parameters  may  be  invoked  with an empty actual
     parameter list or no parameter list at all.  A parameter list must  be
     used  when  a function calls itself recursively, since within the body
     of the function, the function name without a parameter list refers  to
     the function return value.

     An  invocation  of  a subroutine must specify an actual quantity to be
     bound to each formal  parameter.  An  actual  value  parameter  is  an
     expression  which is evaluated once, converted to a compatible type if
     necessary, and bound to the formal parameter.  This process is  termed
     "value binding." 

     An  actual  var parameter is a variable reference.  Within the body of
     the subroutine, the formal parameter refers to  the  actual  variable.
     The  types  of  the  formal  and  actual  parameters  must be strictly
     compatible.  The parameter binding is established when a subroutine is
     invoked;  thus, modification within a subroutine of a pointer or index
     variable which was used in selecting a var parameter does  not  affect
     the  binding.  A  substring  reference  may  not  be  passed  as a var
     parameter.  A component of a packed array or record may not be  passed
     as a var parameter unless it is itself an array, record or string.

     It  is  an  error  if  a subroutine references and modifies a variable
     passed to it as a var or value parameter by a non-local  reference  to
     the  actual variable, or by referencing another var parameter bound to
     the actual variable.  The results of such modifications are undefined,
     and the compiler may assume that they are not made.










                                                       TYM-Pascal Report/19
                                                           February 8, 1980


     Invocation  of  a  subroutine suspends execution of the calling block,
     creates a new generation of  the  nonstatic  variables  local  to  the
     called  subroutine,  and begins execution of the statement part of the
     called subroutine.  Normally, execution of the caller resumes when the
     subroutine  returns.  This  occurs  when  either  a  return  statement
     (11.1.4)  or  the  last  statement  in  the  subroutine  is  executed.
     Execution of the caller may also be resumed by execution of a nonlocal
     goto to a label defined in the caller.

     While  execution  of  a  subroutine  is  ongoing  or  suspended,   the
     subroutine  is  said  to  be  "active".  Because  subroutines  may  be
     recursively invoked, there may in fact be several distinct activations
     of  a  particular  subroutine  at  any given time.  Each activation is
     associated with a different version of local variables, and the copies
     of  a  single  variable  in  the different versions may have different
     values.  Further,  each  activation  may  have  been  called  from   a
     different location.

     If an expression containing a function call is assigned to a variable,
     and the execution of the function is terminated by  a  nonlocal  goto,
     then the value of the variable is undefined.


     7.4  Subroutine Values

     Parameters  and  variables  may  be  declared with a formal subroutine
     type.  Such an item may receive, via parameter binding or  assignment,
     a "subroutine value", and then may be used to invoke that subroutine.

     A subroutine value denotes an actual subroutine and its "environment".
     The latter has the following meaning.  When a subroutine  is  invoked,
     it  may  access  the variables declared in enclosing blocks; moreover,
     since blocks may be recursively invoked, only the most recent  version
     of  those variables is accessible.  Therefore, when a subroutine value
     is  created,  the  versions  of  variables  that  would  currently  be
     accessible  to  the  actual  subroutine  is  saved as its environment.
     Later, when the subroutine  value  is  invoked  through  a  subroutine
     variable or parameter, it can only access variables in that version.

     A  subroutine  value  remains  valid  only  so  long as the version of
     variables given by the display continues to exist.  In the case  of  a
     subroutine  declared  in  the outermost block, the value remains valid
     for the rest of the program.  In the case of a subroutine declared  in
     an  inner  block,  it  remains  valid  until  the  activation  of  its
     containing block, is  terminated.  This  means,  in  essence,  that  a
     subroutine  value  may not be used outside of the block containing the
     actual subroutine.

     A standard procedure or function name may not be used as a  subroutine
     value.












                                                       TYM-Pascal Report/20
                                                           February 8, 1980


     8.  TYPES

     All  constants,  variables,  parameters  and functions have data types
     which regulate their use.  The data type defines the values which  may
     be  assumed  by a variable of the type and the operations which may be
     performed on these values.

     The operations in the language require their operands to be compatible
     with   one   another  or  with  some  specified  type.  Two  kinds  of
     compatibility   are   defined:   value   compatibility   and    strict
     compatibility.

     Value  compatibility  (or just "compatibility") with a particular type
     is a requirement for assignment, use as a value parameter, or  use  as
     an  operand.  It means that a value is either of the required type, or
     convertible to that type by some implicit conversion.  Specific  value
     compatibility rules are given in Sections 8.2 through 8.8.

     Strict  compatibility  with a particular type is a requirement for use
     as an actual var parameter.  In addition to  being  value  compatible,
     two  strictly  compatible items have the same internal representation.
     Intuitively, two strictly compatible items can replace each  other  on
     the  left  hand  side  of an assignment statement (but see Section 8.2
     about packing).  That is, any assignment valid for one item  is  valid
     for the other.

     To help define strict compatibility, the concept of identical types is
     used.  All  objects  declared  in  the  same  identifier  list  in   a
     declaration,   or  declared  using  the  same  type  identifier,  have
     identical types.  Further, two distinct type identifiers are identical
     if one is declared to be identical to the other (e.g., "type a = b;").
     Finally,  distinct  type  definitions  may  define  identical   types,
     depending  on  the  kinds  of the types in question; identity for each
     kind of type is described  in  Sections  8.2  through  8.7.  Identical
     types are strictly compatible.


     8.1  The Definition of Types

     A  data  type  in  a  declaratin  may  either  be  specified  by fully
     describing it  (using  the  general  <type>  syntax),  or  by  a  type
     identifier which is defined elsewhere in a type declaration.

          <type declaration> ::=
             type <type definition> [ ';' <type definition> ]*

          <type definition> ::= <type identifier> '=' <type>

          <type> ::=
             <type identifier> | <simple type> | <pointer type> |
             <set type> | <subroutine type> | <file type> |
             <structured type>










                                                       TYM-Pascal Report/21
                                                           February 8, 1980


          <type identifier> ::= <identifier>

     The  properties  of  the  various  kinds  of  types  order them into a
     hierarchy which is not quite the same as that indicated by the  syntax
     of the language.

























































                                                       TYM-Pascal Report/22
                                                           February 8, 1980


                           HIERARCHY OF PASCAL TYPES
                           _________ __ ______ _____


                                     TYPES












        SIMPLE     POINTER     FILES     SUBROUTINE     SET     STRUCTURED


                    "PTR"


          SUBRANGE         BINARY  TYPED     PROCEDURE  FUNCTION




     "REAL"         SCALAR      "TEXT" 





     "INTEGER"    "CHAR"   ENUMERATED             ARRAYS  STRINGS  RECORDS





              "IO_OPTIONS"  "IO_STATUS"  GENERIC  FLEXIBLE  FIXED  VARYING

                                                                GENERIC


                   "BOOLEAN"    USER ENUMERATED TYPES
















                                                       TYM-Pascal Report/23
                                                           February 8, 1980


     8.2  Simple Types

     The  simple  types are the basic computational values of the language.
     Their values are strictly ordered.  The simple types are divided  into
     scalars, reals and subranges of the two.

          <simple type> ::=
             [ <packing clause> ] <unpacked simple type>

          <packing clause> ::=
             packed [ '[' <constant width> ']' ]

          <unpacked simple type> ::=
             <enumerated type> | <subrange type>

     The  standard type identifiers "integer", "boolean", "char" and "real"
     also denote simple types.

     A subrange type consists of a  contiguous  range  of  values  from  an
     enumerated  or  simple  standard  type  called  the "base type" of the
     subrange.  All subrange types having the same base type are compatible
     with  each other and with their base type.  If no packing or precision
     clauses  are  specified,  they  are   all   stored   in   a   standard
     representation  and  are therefore also strictly compatible.  Unpacked
     simple types are identical if their base types are identical and their
     upper and lower bounds are the same.  An enumerated or standard simple
     type is identical to the subrange type containing all  of  its  values
     (e.g., "char" is identical to "minimum(char) ..  maximum(char)").

     Packing  specifies  a possible reduction in the number of bits used to
     represent a value of the packed type.  If no width is explicitly given
     in  the  packing  clause,  an  appropriate  width  is  selected by the
     compiler.  A specified width must be at least as large as the  largest
     number  of bits required to store any value of the type.  The compiler
     has the option of using a larger width to achieve better  performance,
     and  will  always  select  the  same  width  for  types  with the same
     specified  width,  so  that  strict  compatibility  of  types  is  not
     affected.

     Packed types are strictly compatible only if their widths are the same
     and their base types are identical.  A packed and an unpacked type are
     never  strictly  compatible.  If two unpacked simple or subrange types
     are identical, their packed counterparts are  also  identical  if  the
     same packing clause is used.

     There are two standard functions which may be applied to a simple type
     identifier or a variable reference of a simple type.

        minimum     returns the minimum value of the type.
        maximum     returns the maximum value of the type.












                                                       TYM-Pascal Report/24
                                                           February 8, 1980


     8.2.1  Scalar Types

     The values of a scalar type can be mapped  onto  an  interval  of  the
     integers.  Scalar  types  may  be used as indices of arrays and as the
     domains of set types.

     In addition to minimum and maximum, there are  three  functions  which
     may be applied to an item of a scalar type:

        succ        returns  the  successor of its argument.  The successor
                    of the maximum value of the type is undefined.
        pred        returns  the   predecessor   of   its   argument.   The
                    predecessor  of  the  minimum  value  of  the  type  is
                    undefined.
        ord         returns  the  ordinal  value  of  (i.e.,  the   integer
                    corresponding to) its argument.


     8.2.1.1  Integer

     A value of the standard type integer is denoted by a unsigned integer.
     (Negative integers may be denoted by a constant expression of the form
     " - <unsigned  integer>".)  The  standard name "integer" refers to the
     subrange of integral values from -2**31 to (2**31)-1.  A compiler  may
     provide  extra-lingual  options  allowing  the  definition  and use of
     integral values outside the standard range.


     8.2.1.2  Character

     A character value may be selected from the set of ASCII characters.  A
     printable character value is denoted by a single character enclosed in
     apostrophes (e.g., 'a').  The ordinal value  of  a  character  is  its
     numeric  representation  in ASCII.  The standard name "char" refers to
     the entire character set.


     8.2.1.3  Enumerated Types

     An enumerated type is an ordered set of values,  each  denoted  by  an
     identifier.

          <enumerated type> ::=
             '(' <identifier> [ ',' <identifier> ]* ')'

     Each  identifier  is  declared as a constant within the block in which
     the  type  is  defined.  The  ordinal  value  assigned  to  the  first
     identifier  is 0; the second, 1; and so on.  Distinct enumerated types
     are not compatible.













                                                       TYM-Pascal Report/25
                                                           February 8, 1980


     8.2.1.4  Boolean

     The name "boolean" is  predefined  as  the  enumerated  type  "(false,
     true)".  Logical  operators may be applied to values of this primitive
     type, and the comparision operators yield boolean results.


     8.2.2  Real

     Reals are floating point values with an exponent  and  a  fraction  of
     some specified precision.  The default representation is determined by
     the precision of the fraction; thus, reals with  different  precisions
     are  value compatible but not strictly compatible.  Real constants are
     denoted by unsigned numbers in  fractional  or  exponential  notation.
     The  precision  of  a  real  constant is equal to the number of digits
     appearing  in  its  external  value  (not  including  digits  in   the
     exponent).  The standard name "real" denotes an implementation-defined
     "standard" range and precision for floating-point numbers.


     8.2.3  Subrange Types

     A type may be defined as a subrange of some other simple type,  called
     its  "base  type",  by  specifying  the  upper and lower limits of the
     range.  A real subrange may include a precision specification.

          <subrange type> ::=
             <constant lower limit> '..' <constant upper limit>
                   [ prec <constant precision> ]

     The base type is implied by the types of the limits.  A subrange of an
     enumerated  type  is  defined  when  values  of  that type are used as
     limits.  A real subrange is defined using integer or real limits;  the
     presence of either a real limit or a precision specification implies a
     real subrange.  An integer subrange is defined when  both  limits  are
     integer values and there is no precision specification.

     The  precision factor specifies the required precision of the fraction
     of a real value as a number of decimal digits.  For example, "1..10e12
     prec  5"  indicates  that the fraction must be accurate to one part in
     10**5.  The compiler chooses a storage representation which allows  at
     least  the  required precision.  A precision factor must be a positive
     integer constant.  If the precision factor is omitted,  the  precision
     of the standard type "real" is used.

     The  minimum  and maximum functions may be used to refer to the limits
     of a subrange type.















                                                       TYM-Pascal Report/26
                                                           February 8, 1980


     8.3  Pointer Types

     Values of a pointer type refer indirectly to variables of a  specified
     target type.

          <pointer type> ::= '^' <type>

     A pointer value may be assigned to another pointer.  Its actual target
     variable may be accessed by dereferencing  the  pointer  (see  Section
     9.5).

     The  declaration  of  a  type  identifier used as the target type of a
     pointer need not precede the declaration  of  the  pointer  type.  The
     target  type  identifier may, in fact, remain undeclared so long as no
     variable of the pointer type is dereferenced or used in a call to NEW.

     There is a single pointer constant, denoted by the standard name  nil,
     which  points  to no variable.  It is therefore an error to attempt to
     access the actual target variable of a pointer whose value is nil.  It
     may  be  assigned  to  pointers having any target type.  Other pointer
     values  are  created  when  storage  for  a  variable  is  dynamically
     allocated  with the NEW or ALLOCATE standard procedures.  (The ADDRESS
     and pointer coercion functions  also  return  pointer  values  --  see
     Sections 15.2.2 and 15.7.)

     The  target  types  of pointer types must be identical for the pointer
     types to be either compatible or  strictly  compatible.  However,  the
     standard  type  identifier "ptr" is defined as a pointer type which is
     strictly compatible with any other pointer type.  The target  type  of
     "ptr" is not defined, and values of this type may not be dereferenced.
     The "ptr" type  allows  utility  routines  operating  on  pointers  of
     multiple types to be written.

     The  use  of  pointers,  particularly  those  whose  target types have
     flexible or variant properties, is  discussed  in  further  detail  in
     Section 12.


     8.4  Set Types

     Values of a set type are sets of values from some scalar domain type.

          <set type> ::= [packed] set of <domain type>

          <domain type> ::= <type identifier> | <unpacked simple type>

     The  domain type may be any scalar or scalar subrange type, except for
     an integer subrange with a negative lower bound.














                                                       TYM-Pascal Report/27
                                                           February 8, 1980


     The operators which may be applied to sets are as follows:

        +           union
        *           intersection
        -           difference
        <=, >=      subset, superset
        in          membership

     A set value may be created with a set expression (see Section 10.1.2).
     The  expression  "[]",  denoting the empty set, is compatible with any
     set type.

     Sets whose domain types have the same base type (e.g.  all  sets  over
     integer  ranges) are value compatible.  Two set types are identical if
     and only if  their  domain  types  are  identical  and  their  packing
     attributes  are  the  same.  Aside  from  this, there is no difference
     between packed and unpacked set types.


     8.5  Subroutine Types

     A procedure type describes a class of  procedures  by  specifying  the
     types  and  kinds (value or var) of their parameters.  A function type
     describes a class of functions by specifying the types  and  kinds  of
     their parameters and their return type.

          <subroutine type> ::=
             procedure [ <parameter list> ]  |
             function [ <parameter list> ] ':' <type>

     The  values  of  a procedure or function type are actual procedures or
     functions.  Actual subroutine  names  take  the  place  of  subroutine
     constants (const declarations with a subroutine type are not allowed).
     A variable or parameter with a subroutine type may be called  like  an
     ordinary subroutine, and has an actual subroutine as its value.

     Two  procedure  types  are  identical  if  their  corresponding formal
     parameters are of identical type and kind.  In the  case  of  function
     types, their return types must also be identical.

     Within  a  function,  the function name normally designates the return
     value.  However, when it is assigned to a function variable or  passed
     as  a  function  parameter,  it  designates  the  function itself.  No
     ambiguity is possible, since the return value of a function may not be
     of a subroutine type.

















                                                       TYM-Pascal Report/28
                                                           February 8, 1980


     8.6  File Types

     File  types define templates and mechanisms for transferring data into
     and  out  of  programs.  Variables  of  file  types  are   dynamically
     associated  with  physical  files  and devices, and data transfers are
     achieved by standard  procedures  and  functions  operating  on  these
     variables.

          <file type> ::= [packed] file of ( <type> | '*' )

     A  file  type includes a "component type" which specifies the data the
     file contains.  Each file variable  has  a  "component  variable",  or
     "buffer  variable",  which  is  of  the  file's  component  type.  The
     component variable of a file variable f is referenced as f^.

     The standard type TEXT is defined as "packed file of char".  Variables
     of  type  TEXT are associated with physical files composed of lines of
     characters.  Special  conversion  and  formatting  operations  may  be
     performed on such files.

     Files  without  an  explicit  component  type,  i.e., file of *, allow
     variable length data transfers directly to and from program variables.
     Such files are referred to as "binary" files.  No component is defined
     for a binary file variable.

     Sequential access is provided through all file variables,  and  random
     access  and intermixed input/output through all variables except those
     of type TEXT.  File types and their associated standard procedures and
     functions are described further in Section 14.

     File types are identical if their component types are identical, or if
     both are binary, and their packing attributes are the same.  Variables
     of  identical  file  types  may  be  assigned, compared, and passed as
     parameters as described in Section 14.

     There is a single file constant, denoted by the  standard  name  nilf,
     which  may  be  assigned to all file variables.  It indicates that the
     variable is not associated with a physical file or device.


     8.7  Structured Types

     Structured types contain  some  number  of  components  which  may  be
     separately  referenced  and which may, in turn, have either elementary
     or structured types.  There are three  classes  of  structured  types:
     arrays, character strings and records.

          <structured type> ::=
             <array type> | <string type> | <record type>

     Arrays  and  records  may  be packed, indicating that the compiler may
     select a more compact representation for the components, even  at  the
     expense of efficiency of access.  However, if a component has a packed









                                                       TYM-Pascal Report/29
                                                           February 8, 1980


     simple type with an explicit bit size, the compiler  is  not  free  to
     pack  the  item  further.  Packing has two effects on the meaning of a
     program.  First, a packed structured type is not  compatible  with  an
     unpacked  structured  type.  Second,  nonstructured  components  of  a
     packed structured type may not be used as actual var parameters.


     8.7.1  Array Types

     An array is a homogeneous structure whose  components  are  referenced
     with  a  computable index of some scalar type.  The types of the index
     and the components are given in the array type definition.

          <array type> ::=
             [ packed ] array
                '[' <index type> [ ',' <index type> ]* ']' of <type>

          <index type> ::=
             <type identifier> | <unpacked simple type> |
             <constant lower bound> '..' '*' | '*'

     An  array  of  arrays  is   called   a   multidimensional   array.   A
     multidimensional  array  may  be defined as "array [idxtype1] of array
     [idxtype2] of ...";  this  may  be  contracted  to  "array  [idxtype1,
     idxtype2]  of  ...".  The  first  index of a multidimensional array is
     referred to as the first dimension, the second  index  is  the  second
     dimension,  etc.  The  index  of  a one-dimensional array is its first
     (and only) dimension.

     There are three distinct classes of arrays, differentiated by the form
     of  their  index  type:  fixed  length  arrays,  flexible  arrays, and
     generic arrays.  These are described in detail below.

     There are three functions which may  be  applied  to  any  array  type
     identifier or array reference:

        lowerbound  returns the minimum index value of some dimension of an
                    array.
        upperbound  returns the maximum index value of some dimension of an
                    array.
        dimension   returns the number of index values in some dimension of
                    an array.

     A <structured expression> listing the individual elements of an  array
     in row major order may be used in array initialization, assignments to
     arrays, and parameter lists.  Provided that the number of elements  is
     correct,  such array expressions implicitly acquire the index type and
     bounds appropriate to context.  The expressions take on  the  required
     index types provided that they have the correct number of elements.

     Two  array  types  are  identical  if their component types and all of
     their index types  are  identical.  Two  array  types  are  (strictly)
     compatible  if  their  component  types  are identical and their index









                                                       TYM-Pascal Report/30
                                                           February 8, 1980


     types agree in a manner dependent on the classes of the arrays.


     8.7.1.1  Fixed Length Arrays

     A fixed length array is defined when the index  type  is  an  unpacked
     simple  type.  Fixed  length arrays are (strictly) compatible if their
     index types have the same base type and the same minimum  and  maximum
     values, i.e., the arrays have the same lower and upper bounds.


     8.7.1.2  Flexible Arrays

     The  size  of  a  flexible  array  is not determined until runtime.  A
     flexible array is defined when a range with a '*' upper bound is given
     as  the index type.  As a variable of such a type cannot be statically
     allocated, the type may be used only  (1) as  the  target  type  of  a
     pointer,  (2)   as the type of a trailing field of a record (or record
     variant) type which is itself the target type of a pointer, or  (3) as
     the  type  of  a  formal parameter.  In the first two cases, the upper
     bound of the array is specified upon  allocation  (Section  12.4).  In
     the  third  case  the  formal  parameter assumes the upper bound of an
     actual array parameter bound to it.  A flexible  array  is  (strictly)
     compatible  with a flexible or fixed length array if the base types of
     their index types are identical and their lower bounds are  the  same.
     For  a  flexible  array to be bound to a fixed array formal parameter,
     their upper bounds must be the same at runtime as well.



     8.7.1.3  Generic Arrays

     An array type with an unspecified index type is defined by giving  '*'
     in  place of the index type.  Such a type can only be used as the type
     of a formal parameter.  This indicates that the actual  parameter  may
     be  an  array with any index type and the same component type.  Within
     the subroutine, the formal  array  parameter  is  indexed  by  integer
     values;  its bounds are the ordinal values of the bounds of the actual
     array parameter.  A generic array is (strictly)  compatible  with  any
     other array.

     If  an  array  expression is passed to a generic array parameter, 1 is
     used for the lower bound and the length of  the  list  for  the  upper
     bound.

     Note  that  the  component  type  of an array may not be a flexible or
     generic  array  type.  Therefore,  only  the  first  dimension  of   a
     multi-dimensional array may be variable.


     8.7.1.4  Assignment of Arrays

     Assignment  of  one  array  to another is legal only if the two arrays









                                                       TYM-Pascal Report/31
                                                           February 8, 1980


     have the same lower and upper bounds at runtime, even though they  may
     be otherwise compatible.


     8.7.2  String Types

     Character   strings   are   packed   arrays  of  characters  used  for
     representing printable text.  They may be used like arrays, and  there
     are  several  special  operations  which  are  particularly useful for
     manipulating text.  There are  two  kinds  of  strings:  fixed  length
     strings and varying length strings.

     A  fixed  length  string is declared as a "packed array [indextype] of
     char", where the indextype is an integer subrange with a  lower  bound
     of  1.  The  upper  limit  may  be "*" to define a fixed-length string
     whose length will be determined at run-time, as with ordinary arrays.

     A varying length string is declared as:

          <string type> ::=
             string [ '[' (<constant maximum length> | '*' ) ']' ]

     The maximum length must be a non-negative integer constant; if  it  is
     omitted,  an  implementation dependent value is used.  A "*" indicates
     that the maximum length will be determined at runtime, and may be used
     either  for formal parameters corresponding to actual parameters whose
     maximum lengths will differ, or as (components of) dynamic  variables,
     similar to flexible arrays.

     All  strings  have  a  current  length  and  a  maximum length.  For a
     fixed-length string, the current and maximum  lengths  are  the  same.
     For  a varying length string, the current length may vary from zero to
     the maximum length during execution.  At any given  time,  only  those
     characters in the string with indices between 1 and the current length
     are defined.  when a string value is  assigned  to  a  varying  length
     string  variable,  the  current length of the variable is updated (see
     Section 8.8).

     There are seven functions which may be used with strings:

        lowerbound  is, by definition, 1.
        upperbound  returns the maximum length of a string.
        length      returns the current length of a string.
        substr      references a substring.
        index       locates a string within another string.
        search      locates the first occurrence in a string of  any  of  a
                    set of characters.
        verify      locates the first occurrence in a string of a character
                    which is not a member of a specified set.

     There  is  one  operator  defined  for  strings:  concatenation  (||).
     Strings  may  be  indexed  like arrays to access a specific character.
     Substrings may be extracted and assigned using the SUBSTR function  or









                                                       TYM-Pascal Report/32
                                                           February 8, 1980


     a substring reference.

     String  values  are  written  as  strings  of  characters  enclosed in
     apostrophes.  The null string is denoted by ''.

     Fixed length strings and varying length strings are value  compatible.
     Padding  and  truncation  to achieve the required length are performed
     automatically.  Two varying string types or two fixed string types are
     identical  if  their  maximum  lengths  are the same, and are strictly
     compatible if either is flexible.  A fixed and a  varying  string  are
     not strictly compatible.


     8.7.3  Record Types

     A  record  type is a heterogeneous structure containing a fixed number
     of  components  called  fields.  Each  field  is  designated   by   an
     identifier  called a field name which may be used in a field reference
     or under the control of a with statement to refer  to  the  particular
     component.  The  field  names need not be distinct from names declared
     outside of the record type definition.

          <record type> ::=
             [packed] record [<field list>] [';'] end

          <field list> ::=
             <fixed part> [ ';' <variant part> ] |
             <variant part>

          <fixed part> ::=
             <field definition> [ ';' <field definition> ]*

          <field definition> ::=
             <identifier list> ':' <type>

     Use of more than one identifier in a <field definition> is  equivalent
     to separate definitions of each identifier.

     A  record may be declared as having several alternative substructures,
     called variants, which differ in the number and types of the contained
     fields.  Variants are listed in a case construction, labeled by values
     of a scalar type.  Normally, the different variants are  discriminated
     by the value of a component, called the tag field, which is defined in
     the case heading.  At any given time, only the fields in  the  variant
     selected  by the current value of the tag field are defined.  When the
     tag field is omitted, the record is said to  be  undiscriminated,  and
     the fields in any variant may be referenced.

          <variant part> ::=
             case [ <identifier> ':' ] <type> of
                <variant> [ ';' <variant> ]*











                                                       TYM-Pascal Report/33
                                                           February 8, 1980


          <variant> ::=
             <case label list> ':' '(' [ <field list> ] [ ';' ] ')'

          <case label list> ::= <range list> | others

     The case label values must be unique and contained within the range of
     the scalar tag field type given in  the  heading.  If  no  variant  is
     specified  for  a  particular  value, the value is associated with the
     others variant.  If there is no others  variant,  the  omitted  values
     have null variants.

     As  noted  in  Section  8.7.1.2, the last field of a record or variant
     within a record may  be  a  flexible  array.  However,  all  variables
     having  such  record types must be dynamic, i.e., explicitly allocated
     at runtime, and hence such record types may appear only as the  target
     type  of  pointers and as the types of formal parameters in a program.
     Further, no field of a record may have  a  record  type  containing  a
     flexible array.

     When  the  required type is clear from the context, a record value may
     be created with a record expression (see Section 10.2.1).

     Separately defined record types are incompatible, even if the  textual
     definitions   of   the   records  are  identical.  Intuitively,  every
     occurrence of the keyword record creates  a  type  distinct  from  all
     other record types.  Thus record types are compatible only if they are
     identical.  Compatible  records  may  be  assigned,  but  may  not  be
     compared.  Further,  while  compatible  records  whose last field is a
     flexible array may  be  assigned,  records  with  variants  ending  in
     flexible arrays may not be assigned.


     8.8  Implicit Type Conversions

     Implicit type conversions are performed in contexts where the required
     type is well determined:  in assignment, initialization  of  constants
     and  static  variables,  and in value binding in parameter lists.  The
     following conversions are defined:

        scalar to scalar of a different range
           The base types of the scalars must be the  same.  The  operation
           is in error if the value being converted is outside the range of
           the target type.

        integer to real
           The integer is floated and rounded to the precision of the  real
           type.

        real to real of a different precision
           The source value is rounded to the precision of the target.












                                                       TYM-Pascal Report/34
                                                           February 8, 1980


        fixed or varying string to varying string
           Let  LS be the (current) length of the source string; let MLT be
           the maximum length of the target string.  If LS > MLT  then  the
           target  is  set to the first MLT characters of the source string
           and  its  current  length  becomes  MLT;  otherwise,   only   LS
           characters  are  copied  to  the  target  and its current length
           becomes LS.

        fixed or varying string to fixed string
           Let LS be the (current) length of the source string, and LT  the
           fixed  length  of  the target.  If LS < LT, the source string is
           padded with (LT-LS)  blanks;  otherwise,  the  trailing  (LS-LT)
           characters are truncated.

        char to string
           The  conversion  is  performed  as if the character value were a
           fixed string of length 1 (one).

        set to set of different domain
           The base types of the domains of the sets must be the same.  The
           source  set  is  intersected  with the domain of the target set,
           effectively truncating elements outside of the range.


     8.9  Explicit Conversions

     There are several additional conversions which can  be  performed  but
     must  be  explicitly programmed using special conversions:  integer to
     enumerated scalar, scalar to integer, real to  integer  (truncated  or
     rounded),  pointer  to  pointer,  integer  to  pointer, and pointer to
     integer.  See Section 15.2.2.































                                                       TYM-Pascal Report/35
                                                           February 8, 1980


     9.  REFERENCES

     A reference designates  some  named  item  (a  variable,  constant  or
     parameter),  a  component  of  an  item,  a  variable  referenced by a
     pointer, or the value returned by a function.  A reference may be used
     in  an  expression to access the designated (component) value.  It may
     also be used on the left hand side of an assignment or  as  an  actual
     var  parameter,  to  designate the item to be modified.  In this case,
     the reference must be a variable reference, that is, a reference to an
     item  that  can  be  modified.  Note  that a variable reference is not
     strictly synonymous with a variable:  it may, for example, be a  field
     within a record variable.

          <reference> ::=
             <entire reference> | <field reference> |
             <indexed reference> | <substring reference> |
             <pointer reference> | <function reference> |
             <component reference>


     9.1  Entire References

     An  entire  reference denotes the value of a named item, and is of the
     type declared for the name.

          <entire reference> ::= <identifier>

     The reference is variable only if the  identifier  is  declared  as  a
     variable  or  a  var  parameter.  If  the  identifier  is a field name
     accessed under control of a with statement, the reference is  variable
     if the containing record value is variable.


     9.2  Field References

     A  field  reference  selects a component of a record valued reference.
     The reference is variable if the base record is variable.

          <field reference> ::= <reference> '.' <identifier>

     The identifier must name a field defined in the record type.  Further,
     if  the  field  is  in  a variant part which is discriminated by a tag
     field, then the current value of the tag field must select the variant
     containing the field.


     9.3  Indexed References

     An  indexed reference selects an element of an array valued reference,
     or a character from  a  string  valued  reference.  The  type  is  the
     component  type  of  the array.  The reference is variable if the base
     array or string is variable.










                                                       TYM-Pascal Report/36
                                                           February 8, 1980


          <indexed reference> ::=
             <reference> '[' <expression> [ ',' <expression> ]* ']'

     Use of more than one index expression is  equivalent  to  the  use  of
     separate  subscripting.  That  is,  "a[idx1, idx2]"  is  the  same  as
     "a[idx1] [idx2]".  Each index expression must be compatible  with  the
     declared index type, and within the actual bounds of the array.


     9.4  Substring References

     A  substring  reference  designates  some substring of a string valued
     reference.

          <substring reference> ::=
             <reference> '[' <expression> ':' <expression> ']'

     The first expression gives the position of the first character of  the
     substring;  the  second  expression  gives  its  length.  They must be
     integer expressions satisfying the following constraint.  Let SIDX  be
     the  starting  index;  SLEN, the length of the substring; and RLEN the
     length of the base string.  Then, 1 <= SIDX <= SIDX + SLEN <=  RLEN  +
     1.  This constraint permits zero length substrings.

     A  substring  reference  is  variable  if the base string is variable.
     However, it may only be used as the target of an assignment, not as an
     actual var parameter.

     Assigning  to  a  substring reference does not alter the length of the
     base string, even if the value assigned is longer or shorter than  the
     computed  length of the substring.  The assigned value is converted to
     the required length  (Section  8.7).  A  substring  reference  in  any
     context can also be specified with the standard function SUBSTR.


     9.5  Pointer References

     A  pointer  reference  designates  the target variable of some pointer
     valued reference.  The type of the result is the target  type  of  the
     pointer.  Accessing the target variable of a pointer in this manner is
     referred to as "dereferencing" the pointer.

          <pointer reference> ::= <reference> '^'

     A pointer reference is always variable.  However, if the  pointer  has
     been  generated  by taking the address of a value parameter, assigning
     to the reference is an error, and the effect is undefined.















                                                       TYM-Pascal Report/37
                                                           February 8, 1980


     9.6  Function References

     A function reference designates  an  invocation  of  a  function.  The
     value  of  a  user  defined  function  has  the  declared result type.
     Standard functions are described in Section 15.

          <function reference> ::=
             <reference> [ <actual parameter list> ]

          <actual parameter list> ::=
             '(' [ <expression> [ ',' <expression> ]* ] ')'

     A function of  no  parameters  may  be  invoked  without  an  explicit
     parameter  list.  However,  in  order to invoke such a function by its
     actual name from within its body, a null parameter list, "()", must be
     given, since the function name alone indicates the return value.

     If  the  return  value  of  a function is an array, string, record, or
     pointer, then the function reference can be used as the base reference
     in an array, substring, field, or pointer reference.

     In  general,  a  function  reference  is  not  a  variable  reference.
     However, the standard  function  SUBSTR  is  treated  as  a  substring
     reference,  and  may be used on the left-hand side of an assignment to
     modify a substring of a string variable.


     9.7  Component References

     A component reference accesses the "component"  or  "buffer"  variable
     associated  with  all  but  binary  files  (file  of *), which have no
     associated component variable.

          <component reference> ::= <reference> '^'

     A component reference is always variable, and may be assigned.


























                                                       TYM-Pascal Report/38
                                                           February 8, 1980


     10.  EXPRESSIONS

     The data elements of a  program  are  constant  values  (described  in
     Section  4)  and  the  values  of  variables, which are accessible via
     references (Section 9).  To create new values, these data elements may
     be combined to form expressions.  An expression defines a new value of
     some simple or structured type in terms of existing values.

          <expression> ::=
             <simple expression> | <composite expression>


     10.1  Simple Expressions

     A simple expression generally defines a  value  of  some  unstructured
     type.  (A  reference  to a structured constant, variable, or parameter
     is a simple expression, but defines a structured value.)   All  simple
     expressions  are ultimately composed of primitive expressions (Section
     10.1.1), combined by operators:

          <simple expression> ::=
             <term> [ <relational operator> <term> ]

          <term> ::=
             <factor> [ <adding operator> <factor> ]*

          <factor> ::=
             <power expression>
                [ <multiplying operator> <power expression> ]*

          <power expression> ::=
             <unary expression> [ '**' <unary expression> ]

          <unary expression> ::=
             [ '+' | '-' | not ] <primitive expression>

          <relational operator> ::=
             in | '=' | '<' | '>' | '<>' | '<=' | '>='

          <adding operator> ::=
             '+' | '-' | or | orif | '||'

          <multiplying operator> ::=
            '*' | '/' | div | mod | and | andif

     Observe that the precedence of the operators is:

          (highest) unary operators ('+', '-', not)
                    exponentiation ('**')
                    multiplying operators
                    adding operators
          (lowest)  relational operators










                                                       TYM-Pascal Report/39
                                                           February 8, 1980


     Note that the  logical  operators  have  higher  precedence  than  the
     relational operators.  This means, for example, that "a<b or c>d" will
     be grouped as "a < (b or c) < d", which is erroneous.


     10.1.1  Primitive Expressions

     A primitive expression may be a literal constant,  a  reference  to  a
     previously  defined value, a set expression, or an expression enclosed
     in parentheses:

          <primitive expression> ::=
             <unsigned integer> | <unsigned real> | <string> |
             <reference> | '(' <simple expression> ')' |
             <set expression>

     An unsigned integer, unsigned  real,  or  string  denotes  a  constant
     value,  according  to the rules in Section 4.  A reference denotes the
     current value of the referenced variable, parameter, or constant.  The
     value  of  a  parenthesized  expression  is  simply  the  value of the
     expression.  Set expressions are described in the next section.


     10.1.2  Set Expressions

          <set expression> ::= '[' [ <range list> ] ']'

          <range list> ::= <range> [ ',' <range> ]*

          <range> ::= <scalar expression> [ '..' <scalar expression> ]

     A <set expression> specifies a value of a  set  type  by  listing  the
     elements  of  the  set, either individually or as ranges of values.  A
     range of the form  "val1..val2"  specifies  that  the  elements  val1,
     succ(val1),  ...,  val2  are  all to be included in the set; if val2 <
     val1, no elements are included.  All of the scalar  expressions  in  a
     set  expression  must  be expressions with simple, non-real types, and
     they must all be compatible with one another.  The base  type  of  the
     set  expression  is  the  type  of the scalar expressions in its range
     list.  (The empty set constant, "[]" is defined to be compatible  with
     any set type.) 


     10.1.3  Arithmetic Operators


     10.1.3.1  Unary Operators

          +    used  as a unary operator represents the identity operation.
               It may be applied to any integer or real number.

          -    used as a unary operator negates  its  operand.  It  may  be
               applied to any integer or real number.









                                                       TYM-Pascal Report/40
                                                           February 8, 1980


     10.1.3.2  Arithmetic Operators

     These  operators  all  take  two  operands.  Except  where noted, each
     operand may be either an integer or a real number.  If  both  operands
     are  integers,  the  result  of  the operation is an integer.  If both
     operands are  reals,  the  result  of  the  operation  is  real,  with
     precision  at  least as great as that of the more precise operand.  If
     one operand is real and one is an integer, then the  integer  argument
     is converted to standard type "real" or to a real number with at least
     the precision of the real argument, whichever is more precise.

          +    returns the sum of its arguments.

          -    returns the difference of its arguments.

          *    returns the product of its arguments.

          div  requires that both its arguments be integers, and returns an
               integer  representing  their  quotient,  with  the remainder
               discarded (that is, the quotient is truncated towards zero).

          /    converts both its arguments to real numbers, if they are not
               already, and returns their real quotient.

          mod  requires  that  both  its arguments be integers, and returns
               the integer value of "op1 mod  op2",  which  is  defined  as
               "op1 - (op1 div op2)*op2".

          **   is  the  exponentiation  operator.  Note that a ** b ** c is
               erroneous, and must be written as (a ** b) ** c or a  **  (b
               **   c),   to   indicate   the   order  of  evaluation.  The
               restrictions on the values of the operands, and  the  result
               of  the operation, are defined according to the types of the
               operands (but note that in all cases, 0 ** 0 is undefined):

               integer ** integer  [ op2 > 0 ]
                    yields an integer result.

               real ** integer
                    yields a real result.

               real ** real  [ op1 > 0 ]
                    yields a real result.

               integer ** real  [ op1 > 0 ]
                    converts the integer argument to real,  and  returns  a
                    real result.


     10.1.3.3  Relational Operators

     The  relational  operators  are  "<",  ">", "<=", ">=", "=", and "<>",
     representing "less than", "greater than", "less  than  or  equal  to",









                                                       TYM-Pascal Report/41
                                                           February 8, 1980


     "greater  than or equal to", "equal to", and "not equal to".  They may
     be  used  to  compare  any  two  compatible  scalar  values  (integer,
     character,  boolean,  real, enumerated and subranges thereof), as well
     as strings (see Section 10.1.6).  They perform an  integer  comparison
     if  both operands are integers, and a real comparison (with conversion
     if necessary) if either argument is  real.  The  relational  operators
     return a boolean value of "true" or "false".

     The  relational  operators  "=" and "<>" (but not the others, since no
     ordering is defined) may also be used to compare compatible values  of
     pointer  or  file  types.  No comparison between operands of record or
     array types is allowed.


     10.1.4  Boolean Operators

     The boolean operators  are  not,  and,  or,  andif,  and  orif.  These
     operators all take boolean operands and return a boolean result.  Not,
     and, and or perform the standard logical operations.  Andif  and  orif
     are  equivalent  to  and  and  or, except with respect to the order of
     evaluation of their operands.  And and or may evaluate their  operands
     in  either  order,  and may evaluate both operands or only one.  Andif
     and orif always evaluate  their  left  operand  first;  if  the  first
     operand  of  andif is false or the first operand of orif is true, then
     they return a result without evaluating the second operand at all.

     All the relational operators can also be used with  boolean  operands,
     since  "boolean"  is  defined  as a scalar type with "false" < "true".
     This  means  that  the  relational  operators  provide  the  following
     standard logical operations:

               relation | operation
               ---------|--------------
                p <= q  |  p implies q
                p >= q  |  q implies p
                p = q   |  equivalence
                p <> q  |  exclusive or


     10.1.5  Set Operators

     The  following  set operations are defined if "x" and "y" are two sets
     with the same base type, and "a" is a value of the base  type  of  "x"
     and "y".

          x + y  returns the union of the two sets.

          x * y  returns the intersection of the two sets.

          x - y  returns  the  difference of the two sets; that is, all the
                  elements that are in x and are not in y.











                                                       TYM-Pascal Report/42
                                                           February 8, 1980


          x <= y returns true if x is a subset of y.  Note that this is the
                  "subset-or-equality"  relation,  not  the "proper subset"
                  relation.

          x >= y returns true if y is a subset of x.

          x = y  returns true if the two  sets  contain  exactly  the  same
                  elements.

          x <> y returns  true  if  the two sets do not contain exactly the
                  same elements.

          a in x returns true if the element a is in the set x.


     10.1.6  String Operators

     The operator "||" takes two string  operands,  and  returns  a  single
     string which is the concatenation of the two operands.

     All  of  the  relational  operators  are  applicable  to  strings.  In
     comparing two strings, "s1" and "s2", they are scanned  from  left  to
     right.  If  all  the  character  positions  of the two strings are the
     same, then the two strings are equal.  If a difference is found in the
     "i"th character position, then (s1 < s2) if (s1[i] < s2[i]), and (s1 >
     s2) if (s1[i] >  s2[i]).  When  comparing  two  strings  of  differing
     lengths,  the  shorter  string  is  padded on the right with blanks to
     match the length of the  longer  string.  Characters  are  treated  as
     strings of length 1.


     10.2  Composite Expressions

     A  composite  expression defines a value of some structured type.  All
     composite expressions  have  the  form  of  a  parenthesized  list  of
     expressions:

          <composite expression> ::=
             '(' [ <expression> [ ',' <expression> ]* ] ')'

     Since  it  is  not  possible  to  determine  the  type  of a composite
     expression just by examining it, composite expressions  are  permitted
     only  in contexts in which their type can be determined unambiguously.
     These are:  (1) as the value of a constant or the initial value  of  a
     variable  of  a  structured  type;  (2)  on  the right hand side of an
     assignment statement, whose destination is of a  structured  type;  or
     (3)  as an actual parameter in a procedure or function call, where the
     formal parameter has a structured type.


     10.2.1  Record Expressions

     In a composite expression representing a record value, the expressions









                                                       TYM-Pascal Report/43
                                                           February 8, 1980


     in  the  parenthesized list correspond to the fields of the record, in
     the order of their definition.  They must be value compatible with the
     corresponding field types.  A composite expression defining a value of
     an undiscriminated union record type must  contain  a  value  for  the
     variant  tag  field  (to  allow selection of the proper variant), even
     though this is not stored as part of the record value.


     10.2.2  Array Expressions

     In a composite expression representing an array value, the expressions
     in  the  parenthesized  list  correspond to the elements of the array,
     ordered by index  value.  They  must  be  value  compatible  with  the
     element  type  of  the  array.  If  a  composite expression is used to
     define a flexible or generic array value, the number  of  elements  in
     the list determines the number of elements in the array.

     A  special  rule  allows  multi-dimensional  array  expressions  to be
     written without all the parentheses which are needed to write them  as
     arrays of arrays.  Suppose that an array has the form:

          array [index1,index2,...indexn] of elements,

     where  index1, index2, ...  indexn can take on m1, m2, ...  mn values,
     respectively.  The standard form for an array expression of this  type
     would be a list of m1 sublists, each containing m2 sublists, ..., each
     containing mn elements.  For convenience, whenever a multi-dimensional
     array  expression  could be written as a list of sublists, it may also
     be written as a single list, with the elements of the sublists  listed
     one  after  another.  This substitution may be repeated as long as the
     sublist elements are array expressions themselves.  For  example,  the
     following declarations are all equivalent:

          const x: array [1..2,1..2,1..3] of 1..12 =
                     ( ((1, 2, 3), (4, 5, 6)),
                       ((7, 8, 9), (10, 11, 12)) );

          const x: array [1..2,1..2,1..3] of 1..12 =
                     ( (1, 2, 3), (4, 5, 6),
                       (7, 8, 9), (10, 11, 12) );

          const x: array [1..2,1..2,1..3] of 1..12 =
                     ( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 );

     (Note that this shorthand notation may not be used to write a flexible
     or generic array of arrays, since  in  a  flexible  or  generic  array
     expression,  the  number of elements in the list determines the actual
     array size.)














                                                       TYM-Pascal Report/44
                                                           February 8, 1980


     11.  STATEMENTS

     The statement part of a main program, procedure or  function  consists
     of  one  or  more  sequentially  executed statements, which denote the
     actions to be performed by the program.

          <statement part> ::= begin <statement list> end

          <statement list> ::= <statement> [ ';' <statement> ]*

     Statements may be prefixed with a label to be  referenced  in  a  goto
     statement (Section 11.2.3).

          <statement> ::=
             [ <label> ':' ] <unlabeled statement>

          <unlabeled statement> ::=
             <simple statement> | <structured statement> |
             <exit statement>


     11.1  Simple Statements

     A  simple  statement  denotes a single imperative operation.  The null
     statement consists of no symbols and denotes no action.

          <simple statement> ::=
             <assignment statement> | <call statement> |
             <goto statement> | <return statement> |
             <stop statement> | <null statement>

          <null statement> ::= (* nothing *)


     11.1.1  Assignment Statements

     An assignment statement causes a new computed  value  to  replace  the
     previous value of a variable or a component of a variable.

          <assignment statement> ::=
             <variable reference> ':=' <expression>

     The variable reference and the expression must be of compatible types.
     Implicit conversions are performed between certain nonidentical types.
     When  a  value  of  a  simple type is assigned, it must lie within the
     range of values specified by the variable's type.
















                                                       TYM-Pascal Report/45
                                                           February 8, 1980




     11.1.2  Call Statements

     The call statement denotes the invocation of a procedure.

          <call statement> ::=
             <procedure reference> [ <actual parameter list> ]

          <actual parameter list> ::=
             '(' [ <expression> [ ',' <expression> ]* ] ')'

     A procedure invocation must specify an actual parameter to be bound to
     each corresponding formal parameter given in the type of the procedure
     reference.  The rules governing invocation of a subroutine  are  given
     in further detail in Section 7.3.


     11.1.3  Goto Statements

     Execution  of  a  goto  statement alters the normal sequential flow of
     control by branching to the statement associated with the label.

          <goto statement> ::= goto <label>

     The label must have been declared in the declaration part of a  block,
     and  defined by use as a label on a statement in the statement part of
     the block.

     A goto to a label defined within a containing block is permitted,  and
     is  termed a "nonlocal" goto.  Execution of a nonlocal goto terminates
     all active subroutines called from the most recent activation  of  the
     block where the label is defined.

     A "local" goto may not branch into a structured statement from outside
     that statement.  Thus, local gotos may only be used to exit structured
     statements or to branch within the body of a structured statement.


     11.1.4  Return Statements

          <return statement> ::= return

     A  return  statement  may  only  appear  in  the  statement  part of a
     subroutine, and causes an immediate return from the  subroutine.  When
     used  in a function, a value must have been previously assigned to the
     return value for it to be defined.















                                                       TYM-Pascal Report/46
                                                           February 8, 1980


     11.1.5  Stop Statements

          <stop statement> ::= stop

     A stop statement halts execution of a program.


     11.2  Structured Statements

     Structured statements  are  groups  of  statements  which  are  to  be
     executed  either  in sequential order (compound statement), within the
     scope  of  a  record  (with  statement),  conditionally   (conditional
     statements), or repetitively (repetitive statements).

          <structured statement> ::=
             <compound statement> | <with statement> |
             <conditional statement> | <repetitive statement>


     11.2.1  Compound Statements

     A  compound  statement serves to group together one or more statements
     for execution as  a  single  unit.  The  statements  are  executed  in
     sequential order.

          <compound statement> ::=
             begin <statement list> end


     11.2.2  With Statements

     A  with statement opens a record value, so that within the body of the
     with statement, the fields of  the  record  may  be  accessed  without
     qualification.

          <with statement> ::=
             with <record reference> [ ',' <record reference> ]* do
                <unlabelled statement>

     Use  of  multiple  references  is  an  abbreviation  for  nested  with
     statements.  That  is,  "with r1,  ... rn   do"   is   equivalent   to
     "with r1 do ...  with rn do".

     Each  record  reference  is  evaluated  once  upon  entry  to the with
     statement.  Within the unlabelled statement, modifying a subscript  or
     pointer  used  in  the  reference  does  not alter the identity of the
     record item whose fields are to be accessed.  An  assignment  made  to
     any  of  the record items is permitted and has the effect of assigning
     to each of the  fields.  The  record  reference  itself  can  also  be
     assigned  a  new  value,  which  in  general  changes the value of its
     fields.











                                                       TYM-Pascal Report/47
                                                           February 8, 1980




     11.2.3  Conditional Statements

     A conditional statement selects one of its  component  statements  for
     execution.

          <conditional statement> ::=
             <if statement> | <case statement>


     11.2.3.1  If Statements

     An if statement selects one of two alternative actions on the basis of
     a boolean predicate.  If the predicate  is  true  then  the  statement
     tagged  with  then  is  executed;  if  false,  the  else  statement is
     executed, if present.  Omitting the else part implies that  no  action
     is to be performed when the predicate is false.

          <if statement> ::=
             if <expression> then <unlabelled statement>
                 [ else <unlabelled statement> ]

     An else part is associated with the closest preceding then part.


     11.2.3.2  Case Statements

     A case statement selects one of a set of alternative statements on the
     basis of a scalar valued expression.

          <case statement> ::=
             case <expression> of
                <case member> [ ';' <case member> ]* [';'] end

          <case member> ::=
             <case label list> ':' <unlabelled statement>

          <case label list> ::= <range list> | others

          <range list> ::= <range> [ ',' <range> ]*

          <range> ::= <scalar expression> [ '..' <scalar expression> ]

     Each alternative is labelled with a list  of  constant  values  and/or
     ranges  of  constant  values  compatible with the type of the selector
     expression.  The case label lists  must  be  disjoint.  The  statement
     whose  label  list  includes  the  computed  value  of the selector is
     executed.  The label others may be used to designate a statement to be
     executed  if  none of the other labels applies.  If there is no others
     case and no label applies, no  action  is  performed  other  than  the
     computation of the selector expression.










                                                       TYM-Pascal Report/48
                                                           February 8, 1980




     11.2.4  Repetitive Statements

     Repetitive  statements  specify  repeated  execution  of  one  or more
     statements.  The  loop  statement  iterates  indefinitely;   the   for
     statement  is  used  when a bound on the number of iterations is known
     beforehand; the repeat and while statements are used when iteration is
     to be controlled by complex predicates.  All repetitive statements may
     be terminated by  an  exit  statement  which  contains  a  termination
     predicate  and  optional action.  A goto statement may also be used to
     exit a repetitive statement.

          <repetitive statement> ::=
             <while statement> | <repeat statement> |
             <for statement> | <loop statement>


     11.2.4.1  While Statements

          <while statement> ::=
             while <expression> do <unlabelled statement>

     The expression must yield a boolean value.  The  unlabelled  statement
     is executed repeatedly while this predicate is true.  The predicate is
     evaluated and tested  before  each  iteration;  therefore,  if  it  is
     initially false, the controlled statement is never executed at all.


     11.2.4.2  Repeat Statements

          <repeat statement> ::=
             repeat <statement list> until <expression>

     The  expression  must  evaluate to a boolean value.  The statements in
     the body are executed repeatedly until this expression  is  true.  The
     predicate is evaluated and tested after each iteration; therefore, the
     body of the repeat statement is executed at least once.


     11.2.4.3  For Statements

     A for statement repetitively executes  a  statement,  while  assigning
     successive  values  from  a  computed range to its "control variable".
     Iteration terminates when the range is exhausted.

          <for statement> ::=
             for <identifier> ':=' <for range> do
                <unlabelled statement>

          <for range> ::=
             <initial expression> to <final expression> |
             <initial expression> downto <final expression>









                                                       TYM-Pascal Report/49
                                                           February 8, 1980


     The control variable and the initial and final expressions must be  of
     compatible  scalar  types.  The  control  variable  is  denoted  as an
     <identifier> only, and thus can reference only an entire variable, not
     a component of a variable.  It is further required that the identifier
     designate a local variable.  That is, it  cannot  be  declared  in  an
     enclosing  scope,  and  it  cannot  be a parameter.  Assignment to the
     control variable within the body of a for statement is prohibited.

     The initial and final expressions are each evaluated once, upon  entry
     to  the  for  statement.  The control variable is assigned the initial
     value for the first iteration, and then on each subsequent  iteration,
     successive  values from the range.  The values are increasing if to is
     specified and decreasing if downto is specified.  The  last  iteration
     is  performed when the control value is equal to the final expression.
     If the initial value is greater than the final value (to) or less than
     the final value (downto), the body is never executed at all.

     Upon normal termination of the for statement, the value of the control
     variable is undefined; if the for statement is exited with an exit  or
     goto  statement,  the  control variable contains the value assigned at
     the start of the last iteration.



     11.2.4.4  Loop Statements

          <loop statement> ::= loop <statement list> end

     The loop statement specifies that  its  body  is  to  be  repetitively
     executed.  There  is no termination condition associated with the loop
     statement itself.  The only way to escape from a loop is with an exit,
     goto, return, or stop statement.


     11.2.4.5  Exit Statements

          <exit statement> ::=
             exit if <expression> [ do <unlabelled statement> ]

     Any  repetitive statement may contain one or more exit statements.  If
     the boolean valued expression yields true,  the  optional  termination
     action  is executed, if present, and execution continues following the
     repetitive  statement.  Otherwise,  execution   continues   with   the
     statement following the exit statement.

     An  exit  statement  must  be  executed  on  each  repetition  of  the
     repetitive statement.  That is, it may not be under the control  of  a
     conditional statement within the repetitive statement.

     The  optional termination action is part of the body of the repetitive
     statement.  Thus, any with statements  enclosing  the  exit  statement
     apply to the termination action as well.










                                                       TYM-Pascal Report/50
                                                           February 8, 1980


     12.  POINTERS AND DYNAMIC ALLOCATION

     Variables  in  Pascal  generally  have a lifetime equal to that of the
     block in which they are declared.  A variable  local  to  a  recursive
     procedure  may  have  several  versions.  Static variables are created
     once, and exist throughout  the  execution  of  the  program.  Dynamic
     variables, however, are created under direct program control, and have
     lifetimes independent of any block's activation.  They are created and
     destroyed  in  a  storage  area  called  the "heap" through the use of
     standard procedures.  Dynamic variables have no names, and are instead
     referenced through pointers.

     Pointer  types are bound by their declaration to a single target type.
     When a dynamic variable is created, its type is the target type of the
     pointer  which  references  it.  For  example,  when  creating dynamic
     variables  of  type  integer,  one  uses  pointer  variables  of  type
     "^integer" to reference them.  Pointer expressions yield references to
     dynamic variables when they  are  "dereferenced",  denoted  by  a  "^"
     immediately  following the pointer expression.  For example, if p is a
     pointer  variable  (or  a  pointer  expression),  p^  references   the
     associated dynamic variable of the target type of p.

     As  mentioned  in  Section  8.3,  pointer  types  are  compatible (and
     identical) only if their target types  are  identical.  Several  means
     exist  for  deliberate  violation  of this compatibility rule (Section
     12.5).  The predefined pointer constant nil  is  compatible  with  all
     pointer  types,  and  a  pointer  with this value refers to no dynamic
     variable.  A pointer variable  which  does  not  point  to  a  dynamic
     variable,  but  may  be  examined,  should  be  set to nil.  A pointer
     expression equal to nil may not be dereferenced.

     Recursive data structures may be easily defined in Pascal through  the
     use  of  a structured type containing pointers to itself.  Records are
     typically used here, with a  field  or  fields  containing  data,  and
     pointer  fields  linking  the  node  to  its neighbors in the network.
     Special cases of the network are the tree and the list.

          type
            net_pointer = ^ net_node;
            net_node = record
              data1, data2, ... , datan: data_type;
              link1, link2, ... , linkm: net_pointer
              end;

            b_tree_element = record
              key: b_tree_key;
              next_leaf:  ^b_tree_node
              end;

            b_tree_node =
              array [1 .. ((b_tree_order + 1) div 2)]
                of b_tree_element;










                                                       TYM-Pascal Report/51
                                                           February 8, 1980


     The use of "net_node" in the definition of "net_pointer" occurs before
     its  definition,  since  the  definition  of  "net_node"  requires the
     definition of "net_pointer".  The definition of field  "next_leaf"  in
     the  second  example  uses  a similar reference to type "b_tree_node".
     Such forward references are permitted in Pascal for pointer  types  to
     permit  declaration of self-referent types.  Further, if no pointer of
     a given pointer type is ever dereferenced or used in a  call  to  NEW,
     then the target type of the pointer type need not be defined.  Thus, a
     routine  may  pass  and  assign  pointers  without  knowledge  of  the
     pointer's target type (see Section 8.3).


     12.1  Allocation and Deallocation of Pointers

     The  lifetime  of  a  dynamic  variable  is  completely  under program
     control.  Standard procedures are used to create and  destroy  dynamic
     variables, whose existence is independent of scope.


     12.1.1  Allocation

     The  predefined  procedures  NEW (p)  and  ALLOCATE (p,n)  are used to
     create, or allocate, a dynamic variable of pointer  p's  target  type.
     Here,  p  must  be a pointer reference; p is assigned a pointer to the
     new dynamic variable (i.e. p^ references the new  variable).  After  a
     NEW  or ALLOCATE operation, p points to a distinct dynamic variable of
     its target type, independent  of  any  previous  NEW  operations.  The
     variable  p^ is not initialized by NEW or ALLOCATE, with the exception
     that tag fields whose values are explicitly specified in the  call  to
     NEW  are  set  to  those  values  (see  Section 12.4).  It is strongly
     suggested that any requisite  initialization  of  a  dynamic  variable
     should immediately follow its allocation.

     NEW  and  ALLOCATE  both  take a pointer variable or expression (which
     must be assignable) as their  first  parameter.  In  NEW,  a  list  of
     values  selecting  variants  and/or  a flexible array upperbound to be
     defined in the dynamic variable  may  optionally  follow.  An  integer
     valued  expression  is  specified to ALLOCATE as its second parameter,
     giving the number of storage units  to  be  allocate  to  the  dynamic
     variable.   The  number  of  storage  units  to  allocate  is  usually
     determined via the SIZE or EXTENT functions, as described in  Sections
     12.3 and 12.4.


     12.1.2  Deallocation

     The   predefined   procedure   DISPOSE(px)  is  used  to  destroy,  or
     deallocate, a dynamic variable.  Here, px  is  a  pointer  expression.
     The   dynamic   variable  px^  is  deallocated  and  invalidated.  Any
     subsequent references to px^ are  undefined,  so  any  pointers  whose
     values are equal to the value of px should be set to nil.











                                                       TYM-Pascal Report/52
                                                           February 8, 1980


     It is essential that allocation and deallocation be properly used when
     manipulating dynamic structures.  In order for  storage  allocated  to
     dynamic  variables  which have become unnecessary to be reallocated to
     new  dynamic  variables,  unnecessary  dynamic   variables   must   be
     explicitly   deallocated   with  DISPOSE.  Further,  if  all  pointers
     referencing a  dynamic  variable  are  destroyed  because  the  blocks
     containing  them  are  no  longer  active,  or  the  dynamic variables
     containing them have been deallocated, then the storage  allocated  by
     the  dynamic  variable  is  "lost" to the program, i.e., will never be
     reallocated.  Thus, failure to DISPOSE dynamic  variables  will  cause
     the  heap  to  become full of unused, and likely inaccessible, dynamic
     variables.  On  the  other  hand,  a  dynamic  variable  must  not  be
     referenced  once  it  has been DISPOSEd, nor may it be DISPOSEd again.
     All pointers to it must be reassigned; failure  to  do  so  creates  a
     "dangling  reference".  Dereferencing  a dangling pointer is an error,
     thus the programmer should insure that such references are not made.

     In the example below, type "bin" is a binary tree, with fields  "left"
     and  "right"  as  self-referent  pointers.  The subroutine KILL_BRANCH
     prunes a branch from such a tree.

          procedure kill_branch (
            var p: ^bin);

            begin
            if p <> nil then
              with p^ do begin
                kill_branch (left);
                kill_branch (right);
                dispose (p);
                p := nil
                end
            end;

     Notice that the  nodes  of  the  binary  tree  are  deallocated  in  a
     post-order  walk  (that  is,  the  children  of a node are deallocated
     before the node).  The only dangling pointers in  this  routine  exist
     between  the  DISPOSE operation and the assignment of p.  At all other
     points in the routine, the original subtree is a valid tree.


     12.2  Operations on Pointers

     Pointers may be assigned, dereferenced, and passed as parameters.  The
     comparison operators "=" and "<>" may also be used with pointers.

     The with statement (see Section 11.2.2), when used with a pointer type
     whose target type is a record, provides a convenient  way  of  walking
     linked data structures without using extra temporary variables.  Since
     a with reference is evaluated once, at the start of the  statement,  a
     with  reference  such  as p^ frees the pointer p for use in operations
     within the with statement.  Using such a statement within an iterative
     construct,  p  may  be assigned to the next operand at any time during









                                                       TYM-Pascal Report/53
                                                           February 8, 1980


     the iteration without affecting the with reference.  At the  start  of
     the  next iteration, the with reference will be evaluated again, using
     the new value of p.

     The logical operators andif and orif (see Section 10.1.4)  are  useful
     in  manipulating  recursive  structures.  For  example,  in structures
     where a nil pointer indicates the end of a subchain, a  search  for  a
     desired value may be performed easily by:

          p := first;
          while (p <> nil) andif (p^.value <> desired) do
            p := p^.next;
          (* if p = nil then failure else success;  *)

     If  p  is nil, the loop terminates without an erroneous dereference of
     p.


     12.3  Pointers to Records with Variants

     Many applications require more flexibility in creating structures than
     can  be  obtained  using  identical nodes.  For example, if nodes in a
     list structure can contain one of several disjoint sets of data, it is
     wasteful  to  allocate sufficient space for each node to hold all data
     sets simultaneously.  Variant record types permit records of a  single
     type to have different structures.

     A  list  of  scalar  constants  may  be  specified in a call to NEW to
     allocate a record whose variants are selected by the constants.

          <variant part> ::=
             case [ <identifier> ':' ] <type> of
                <variant> [ ';' <variant> ] *

     The tag fields -- the <identifier> in the definition of <variant part>
     above -- will be initialized by NEW if they are specified in the call.
     NEW will allocate only as much space as is required for the  specified
     variant;  if  a  tag  field  is  unspecified,  the size of the largest
     variant will be allocated.























                                                       TYM-Pascal Report/54
                                                           February 8, 1980


          type
            foo = record
              a, b: integer;
              case c: boolean of
                true:  ();     (* the null variant *)
                false: (
                  d, e: integer;
                  f: char;
                  case integer of
                    0..4: (g: integer);
                    5,7,9:(h, i: integer);
                    6,8:  (j, k: char);
                    10:   (m: real);
                    others: () )  (* null *)
            end (* of record definition *);

     Every record of type foo contains fields a, b, and c.  A value for the
     tag  field  c  may  be  specified  to  NEW as a constant following the
     pointer variable reference, which both initializes c and  selects  the
     substructure  for  the  rest of the record.  Selecting true creates no
     additional fields, and limits the size of the record to that  required
     for a, b, and c.  Every record for which c is false contains fields d,
     e, and f.  A second nested variant part follows, for which a tag field
     value  may  also  be  specified  to  NEW  to  select the variant to be
     defined; if none is specified, the "5,7,9" variant will be  chosen  as
     it  is the largest.  Notice that the case for the second variant has a
     type but not a field name.  This is an undiscriminated union of fields
     in  a record definition.  No tag field is allocated in the record, and
     the integer used in the call to NEW is lost.  This  prohibits  runtime
     checking   of  the  tag  field  in  record  references;  in  fact,  an
     undiscriminated union is similar to a FORTRAN EQUIVALENCE in  which  a
     single  area  of  memory  may  be  referenced  by  multiple names with
     different data types.  Notice in the example above that  field  g  may
     reference  its  storage within the record as an integer, while field m
     may reference the same area of the record as a real.  No runtime check
     can  restrict  references to the variant given to NEW upon creation of
     the record; the programmer must ensure that  any  references  made  to
     fields  within  an undiscriminated union actually exist.  For example,
     the call NEW(p, false, 3) would create a p^ for which field "i"  would
     not  exist;  a  subsequent reference to "p^.i" is invalid at run time,
     but would not be detected as an error.

     The Pascal I/O system (see Section 14) requires fixed length  entities
     in  its  typed files.  For example, the data type "file of foo" (using
     the above example) would contain  constant  size  records  whose  size
     corresponds  to the "false, 5" variant list.  However, variable length
     dynamic variables may be written to a file using the  EXTENT  function
     in conjunction with Pascal binary I/O.  If the program writes the size
     of each variable to the file immediately before the  variable  itself,
     the  file  will  contain  enough  information to reread the variables.
     EXTENT(p), where p is a pointer, returns the size of p^ only if p^  is
     a  dynamic  variable  (i.e.,  is  allocated on the heap), and is not a
     subrecord of another record.  Thus,









                                                       TYM-Pascal Report/55
                                                           February 8, 1980


          write (f, extent(p), p^: extent(p))

     will first write out the size of the variable p^, and then the  actual
     variable  p^.  Notice  that the size specification for the write of p^
     is necessary, since its actual allocated size is not known at  compile
     time.

     To write the length of a variable which is not a dynamic variable to a
     file, the SIZE function should be  used.  SIZE  and  EXTENT  are  both
     described in more detail in Section 15.7.

     To  read  variables from such files, ALLOCATE may be used.  The use of
     NEW would be awkward since the program must somehow determine the  tag
     fields  of  the  record  being  read, and then use a case statement to
     select an appropriate NEW call (since NEW must be passed constants  to
     select  tag  fields).  No initialization is performed by ALLOCATE, but
     in this case, none is needed since the entire variable  will  be  read
     into p^.  Thus, to reconstruct p^ from a binary file, given an integer
     i:

          read (f, i);
          allocate (p, i);
          read (f, p^: i);

     suffices.

     If the dynamic variables written to a file are deallocated after being
     written,  or  if  the  file  was  written by another program, then any
     pointer values read from the file are invalid.  Before a  variable  is
     written  to  a file, any pointer components can be "fixed up" to refer
     to the correct variable by coercing pointer  values.  One  method  for
     doing  so  is  to order the nodes in a network, and then to write each
     node in order.  This strategy requires one extra integer component per
     node,  and entails two traversals of the network.  The first traversal
     assigns increasing integer values to  each  extra  component  in  each
     node;  the second traversal coerces each pointer component in the node
     to the integer value of the node to which it refers, and  then  writes
     the  record.  Notice that this method works with any network, and that
     special cases of networks may reduce this overhead  considerably.  For
     example,  a list need only have its data written out in order; linkage
     information is unnecessary.

     The following  warnings  are  given  concerning  the  use  of  variant
     records:

        1. The  program  should  not  change  tag  fields in a record whose
           values were specified on the  call  to  NEW  which  created  the
           record, unless the new tag field selects the same variant.
        2. Assignments of record values to records created on the heap with
           variants may be unsafe, since the maximum record size is copied.
           If  the  record  on  the  heap  is  smaller  than  this maximum,
           locations outside the record may be modified, with indeterminate
           results.









                                                       TYM-Pascal Report/56
                                                           February 8, 1980


     12.4  Pointers to Flexible Arrays

     Variant  record  types  (see  Section  12.3)  can  be used to allocate
     variable length records.  Similarly, pointers to flexible  arrays  can
     be  used  to  allocate  variable length arrays.  The declaration of an
     array type whose index specification gives an upper bound of "*" is  a
     flexible array declaration.  Flexible arrays, records whose last field
     is a flexible array, and variants whose last field is a flexible array
     all  can  be  created by calls to NEW with user-specified upper bounds
     for the flexible item.  Since the flexible item  is  always  last,  an
     integer-compatible  expression  appears  as the last parameter to NEW,
     indicating the upper bound for the flexible item.  Specification of an
     upper  bound  for  a  flexible  item  is  required.  Thus, if a record
     containing one or more variants ending in flexible items is allocated,
     all  tag  field  values  must  be  specified if a variant containing a
     flexible item is selected.  Upper bound specifications may be run time
     variable expressions, while tag field values must be constant.

     The  upper bound of a flexible item may be accessed after its creation
     by UPPERBOUND.  The actual size of such an item may be acccessed using
     a special form of the SIZE function (see Section 15.7) which takes the
     upper bound of such an array as parameter.

     Although EXTENT is recommended for generating the size  of  a  variant
     record  when writing to a binary file, SIZE may be used for a flexible
     array.  The item preceding the array  should  be  the  array's  actual
     upperbound.  For example:

          write (f, upperbound (p^),
              p^: size (p^, upperbound (p^));

     will  write  the  flexible array's upper bound, and then its elements.
     Rereading proceeds as follows:

          read (f,i);
          new (p,i);
          read (f,p^: size (p^,i));

     For non-variant records containing a trailing flexible field, the item
     preceding  the record may either be the length (via EXTENT or SIZE) of
     the  record,  or  the  upperbound   of   the   flexible   field.   For
     reconstruction, ALLOCATE or NEW would be used, respectively.

     When using the former approach, SIZE is recommended over EXTENT, since
     in  general,  EXTENT(p)>=SIZE(p^).  This  is  because  EXTENT  is   an
     implementation dependent function which returns the actual size of the
     dynamic variable allocated by the heap manager.  In  some  cases,  the
     manager may allocate a larger area of storage than is required; EXTENT
     returns the actual size of the variable as allocated.  In other words,
     a dynamic variable is always as large as it needs to be, but it may be
     larger; repeated writes and rereads may increase the actual  sizes  of
     the dynamic variables involved.  Since EXTENT must be used for variant
     records, this problem with repeated rereading cannot be avoided.









                                                       TYM-Pascal Report/57
                                                           February 8, 1980


          type
            flex = array [1..*] of integer;
            flexptr = ^flex;
            flexrec = record
              a: integer;
              case b: boolean of
                true:  (c: integer);
                false: (d: flex)
              end;

          var
            f: flexptr;
            g: ^flexrec;

     Given the above declarations, the following NEW calls could be made:

          new (f, 100);         (* allocates 100 element array *)
          new (g, true);        (* fields a, b, and c only *)
          new (g, false, 30);   (* fields a, b, d with u. b. = 30 *)

     Note that both of the following are invalid because of the  previously
     noted restrictions on allocating records containing flexible items:

          new (g);              (* must have upper bound *)
          new (g, false);       (* still must have upper bound *)

     The  following warnings are given concerning the use of flexible array
     items:

        1. The upper bound of a flexible array cannot be changed once it is
           created.
        2. Assignment  of records with a final flexible array field is safe
           only if the lower and actual upper bounds of the array  are  the
           same.  Assignment  of  records with variants containing flexible
           arrays is prohibited.


     12.5  Pointer Coercions

     Pointer types are compatible (and  identical)  only  if  their  target
     types  are  identical.  Given  the  existence  of  variant  record and
     flexible array types, this compatibility rule need not be violated for
     most applications.  In some cases, however, bending this compatibility
     rule  is  necessary  or  desirable  for  reasons  of   efficiency   or
     simplicity.  Also,  in  certain  cases,  it  becomes necessary to form
     pointers to variables which were  not  created  on  the  heap,  or  to
     perform  "pointer arithmetic".  The creation of a pointer value by any
     means other than NEW, ALLOCATE, or  the  predefined  constant  nil  is
     called   a  pointer  coercion.  Pascal  provides  explicit  conversion
     functions  which  permit  the  programmer  to  coerce  pointers  in  a
     straightforward  manner.  It should be noted that, in general, careful
     use of these functions does not  compromise  machine  independence  of
     programs,  although  relatively  simple  operations  can easily do so.









                                                       TYM-Pascal Report/58
                                                           February 8, 1980


     Since  pointer  coercions  are  explicit,  it  is   the   programmer's
     responsibility to use coerced pointers correctly.

     The most general pointer coercion function is

          pointer_type_name(p)    or    pointer_type_name(n)

     where   p  is  an  expression  of  any  pointer  type,  and  n  is  an
     integer-compatible expression.  These constructions form a pointer  of
     the  pointer  type  identified by pointer_type_name whose value equals
     the value of p or n.  For example,

          type
            foo = ^integer;
            bar = ^foo;

          var
            a: foo;
            b: bar;

     creates the functions "foo" and "bar", which are available for pointer
     coercions such as:

          a := foo (b);      (* convert a bar to a foo *)
          b := bar (1923);   (* integer constant *)

     The  predefined  function  ORD (x) returns an integer-compatible value
     corresponding to the integer value of a pointer if x is of  a  pointer
     type,  or the zero-based ordinal of a scalar if x is of a scalar type.
     Using ORD permits construction of pointer arithmetic expressions, such
     as:

          a := foo (ord (b) + 13);      (* dangerous!! *)
          a := foo (ord (b) + size (b)) (* better form *)

     Using  integer  constants in pointer expressions is a primary cause of
     machine  dependence.  The  SIZE  function  can  usually  replace  such
     integer constants, preserving machine independence.

     The predefined type PTR is a pointer type which is compatible with all
     other pointer types.  This type is especially useful  as  a  parameter
     type  for routines which perform some function independent of the type
     of the pointer.  Note that this also defines the  function  PTR(p)  or
     PTR(n), as for all other pointer types.

     The  predefined  function ADDRESS(x) returns a value of type PTR which
     is a pointer to the reference x.  The ADDRESS function can be used  to
     form  pointers  to  items  not  on  the  heap,  and  to aid in pointer
     arithmetic operations.  Again, careful use of ADDRESS  and  SIZE  will
     not compromise machine independence.












                                                       TYM-Pascal Report/59
                                                           February 8, 1980


     The following restrictions exist for arguments to ADDRESS:

        1. The argument must be a valid reference.
        2. The  argument cannot be a packed component (that is, a component
           of a packed array or packed record which is not itself a record,
           array, or string).
        3. The argument cannot be a substring.

     It is possible to form pointers to subrecords within a record by using
     the ADDRESS function.

     Notice that modification of a "foo" heap variable above (for  example)
     via  a  "bar"  pointer,  or  modification of a non-heap variable whose
     address is accessible via a pointer,  may  cause  errors  in  a  given
     implementation.   Specifically,   standard   optimization   techniques
     involving the detection of common subexpressions and the  analysis  of
     data  flow  assume  that pointers of a given type can only reference a
     group of variables (the base type)  whose  elements  are  inaccessible
     except  through  pointers of that type.  Modifying base type variables
     through other pointers, or using  the  pointers  to  modify  variables
     other   than   those   of  the  base  type,  may  invalidate  compiler
     optimization assumptions, and cause the generation of incorrect  code.
     For a specific implementation, such operations are documented as being
     potentially dangerous.






































                                                       TYM-Pascal Report/60
                                                           February 8, 1980


     13.  EXCEPTIONAL CONDITION HANDLING

     The condition mechanism provides the ability to intercept  exceptional
     conditions such as an attention interrupt and arithmetic traps.

     A  condition  is  intercepted  by  a "handler" which is functionally a
     sequence of statements invoked only when the condition is "signalled".
     A  handler  is dynamically bound to the condition, and the binding may
     be  nested.  The  on  statement  defines  both  the  handler  and  the
     condition  to  which  it  is  bound.  Various  standard procedures and
     functions provide additional control over conditions.

     (Subsequent subsections to be supplied.)

















































                                                       TYM-Pascal Report/61
                                                           February 8, 1980


     14.  INPUT/OUTPUT

     Transfer of data between a Pascal program and a peripheral  device  is
     accomplished  through a file variable.  A file variable in the program
     may be associated with a physical file or device at runtime.  The name
     of  the  file  variable  may  be referred to as its "file identifier".
     Each physical file is identified by the  contents  of  some  character
     string; this string is called its "file name".

     Pascal  input/output  is  device independent, in that the standard I/O
     operations are not restricted  to  particular  devices.  Any  specific
     information about the location, device, physical structure, etc., of a
     physical file is encoded in its file name, which is a string passed to
     a standard procedure associating a physical file with a file variable.
     This means that the format of a file name may  vary  from  one  Pascal
     implementation  to  another.  Pascal also makes special provisions for
     communications with the interactive terminal (if  any)  controlling  a
     program.


     14.1  File Types, Variables, and Modes

     A  file  variable,  like  all variables in PASCAL, has a type, in this
     case, a file type, declared as follows:

         <file name> ::= [packed] file of (<type> | '*')

     Adopting terminology from pointer types, for reasons which will become
     clear later, we say that a file type is bound to the type specified in
     the file type declaration.  The type to which a file type is bound  is
     referred    to   as   its   component   type.   The   component   type
     determines:  (1) the format of individual data items (commonly  called
     "records"  in  other  programming  languages)  composing the file, and
     (2) an attribute referred to as the mode of  the  file.  A  file  type
     with an asterisk instead of a component type is not bound to any type.
     Data items (records) of any type and length may be written to and read
     from such a file.

     There  are  three file modes:  text, typed, and binary.  Textfiles are
     of the type packed file of CHAR.  TEXT is a predefined identifier  for
     this  type.  Files  of  any  other  component type are "typed".  Files
     without a component type (file of *)  are  "binary"  files.  Textfiles
     are  accessed  sequentially, and certain conversion operations on them
     are provided, allowing variables of  types  besides  character  to  be
     input  or  output.  Files  of other modes may be accessed sequentially
     and/or randomly, and no conversions are provided.  It  is  recommended
     that  textfiles be maintained in the "standard" installation character
     file format so that they may be manipulated with system utilities, but
     this  decision  is implementation dependent.  While access to files of
     other modes, overviewed in other sections, is  always  the  same,  the
     physical formats of such files are implementation dependent.

     File  types  are  not  compatible  unless  they  have  the  same mode.









                                                       TYM-Pascal Report/62
                                                           February 8, 1980


     Furthermore, for two typed files to be compatible, they must have  the
     same component type.  For two files having the same mode, both must be
     packed or both must be unpacked to be compatible.  (Packed  files  may
     be  maintained in a more compact format with potentially longer access
     times than unpacked files.)

     Several operations between compatible file variables are defined.  The
     first  is  assignment of one compatible file variable to another.  The
     result of assigning two file variables is that either may subsequently
     be  used  to access a single physical file, namely, the one associated
     with the file variable from which assignment was made.  This result is
     analogous to assigning two pointers, as subsequently both refer to the
     same dynamic variable.  If the file variable to  which  assignment  is
     made was associated with some other physical file, the association may
     be "lost", since the file variable is now associated with a  different
     file,  but  the  file  with which it was previously associated has not
     been closed.  When a pointer already referring to an item on the  heap
     is  assigned  to,  the  effect is similar.  Finally, assignment from a
     file variable not associated with a physical file is vacuous, the same
     as  assignment  from  a  pointer  which  does  not  refer to a dynamic
     variable.

     File variables are thus very much like pointers, in that they are used
     to  refer  "indirectly" to something, in this case, physical files and
     devices.  It is not surprising then, that in addition  to  assignment,
     comparisons  for  equality  (=)  and inequality (<>) may also be made.
     Normally, two file variables separately associated with files will not
     be  equal,  even  if  they are associated with the same physical file.
     Two file variables can only  become  equal  by  assignment,  with  the
     exception  of  those  associated  with the terminal, for which special
     provisions are made.  Parameters of file  type  may  be  declared  and
     passed  to  routines.  However,  since  the  state of their associated
     physical files will be altered if such parameters  are  referenced  at
     all, they must be declared as var parameters.

     Finally,  a  predefined constant nilf, compatible with all file types,
     may be assigned to file variables.  A file variable with value nilf is
     not  associated  with  any  physical file or device.  Nilf may be used
     with files in a manner analogous to nil with pointers.

     There are no restrictions on the declaration of file  variables.  They
     may  be  declared as components of arrays, records, etc., and as local
     variables of a routine.  In the latter case, if the file  variable  is
     not static, its association with a physical file is not preserved, nor
     is the file automatically closed when the enclosing  routine  returns.
     The  association  is  thus  "lost", if the routine does not explicitly
     close the file, just as storage associated with local  pointers  which
     is  not  disposed  is lost.  Component types of file variables may not
     contain  flexible  or  generic  arrays.   While   they   may   contain
     subroutine,  pointer, and even file types, it is important to remember
     that values of variables  of  these  types  are  "program  dependent".
     Thus,  when  such variables are read in one program from files written
     by another program, their values should be considered to be undefined.









                                                       TYM-Pascal Report/63
                                                           February 8, 1980


     For every file variable having an explicit component type,  i.e.,  all
     except  binary,  a  special variable of the component type is defined.
     This variable is referred to as the file variable's  "buffer".  For  a
     file variable F of type file of T, F^ is its buffer variable, which is
     of type T.  The significance of the buffer variable is that all I/O is
     performed through it, i.e., when an item is read (via the GET routine)
     from the file, it is read into the buffer variable, and when  an  item
     is  written  (PUT),  the  contents of the buffer variable are written.
     The buffer may be visualized as the program's "window" on the physical
     file, as it always contains the current data item on the file.

     The  definition and use of a buffer variable in this fashion is unique
     to Pascal.  It offers several advantages, in particular, the fact that
     only  the  file  variable  need  be  passed to routines performing I/O
     instead of a parameter specifying the file and  another  parameter  to
     hold  the  data.  Its disadvantage is that data must be copied into or
     out of the buffer variable prior to or after  I/O.  For  this  reason,
     additional  standard  I/O routines are provided (READ and WRITE) which
     automatically move data from the buffer  to  program  variables  after
     input, or into the buffer before output.  Since a binary file does not
     have a component type, it does not have a buffer (F^,  where  F  is  a
     binary  file,  is  erroneous).  Thus, only the READ and WRITE routines
     may be used with such files.


     14.2  Association with Physical Files and Devices

     Before communication with a physical file or device can take place, it
     must be associated with a Pascal file variable.  As noted earlier, the
     mode of the physical file and the logical structure of data to be read
     from  or  written  to it are defined by the type of the file variable.
     In addition to the file name, which identifies the  physical  file  or
     device,  certain  other  information  is  specified  at  the  time  of
     association.


     14.2.1  Association

     The direction of subsequent data transfer is defined by  the  standard
     routine  called  to  associate a file variable with a physical file or
     device, as follows:

         OPEN     --  Input, valid only with textfiles.
         RESET    --  Input.
         REWRITE  --  Output.
         UPDATE   --  Both input and output, invalid with textfiles.

     A set of options selected from the following  predefined  scalar  type
     IO_OPTIONS may also be specified:

         SEEKOK    --  allow random access (calls to SEEK allowed).
         IMAGE     --  transfer characters without conversion.
         PRESERVE  --  do not delete previous contents of file.









                                                       TYM-Pascal Report/64
                                                           February 8, 1980


         ASCII     --  do not skip/ignore non-printing characters.
         CONTROL   --  interpret first character of output lines as 
                       carriage control.
         RETRY     --  on fatal I/O errors, return control to program
                       for recovery attempt.

     Each of these options is discussed in greater detail later.  SEEKOK is
     valid only with typed and binary files, IMAGE, CONTROL, and ASCII only
     with textfiles, and RETRY with all files.

     The format for a call on any of these standard routines is

         <operation>(<file variable>[,<file name>][,<option set>])

     for example:

         RESET    (F,[ASCII,PRESERVE]);
         REWRITE  (F,'string',[PRESERVE]);
         UPDATE   (F,S1||S2).

     If  no  file  name  appears,  as  in the call to RESET above, the file
     variable is associated with an implementation dependent physical file.
     This  "default" physical file is a function of the file identifier, so
     identical file identifiers in different programs  will  be  associated
     with   the  same  default  file.  A  file  variable  which  cannot  be
     referenced by a single identifier (for  example,  a  component  of  an
     array)  cannot  be  associated  without  an  explicit  file  name.  In
     addition, the predefined file variables TTY  and  TTYOUTPUT,  both  of
     type  TEXT, are automatically associated with the interactive terminal
     controlling a program if no file name is specified.  They are  public,
     i.e.,  references  to them in all modules refer to the same variables.
     Further, the identifier TTYOUTPUT is implicitly  substituted  for  TTY
     when TTY appears in the parameter list of any standard output routine,
     e.g., REWRITE.  If the following associations are made:

         OPEN(TTY) or RESET(TTY);
         REWRITE(TTY); (*TTYOUTPUT substituted for TTY*)

     the only instances where TTYOUTPUT must be specified explicitly as the
     "output side" of the terminal are:

         1.  when passed as an actual file parameter, and
         2.  when accessing the file buffer variable.

     These conventions provide the appearance of two way communication with
     the controlling terminal through a  single  file  identifier,  without
     actually associating the identifier with UPDATE, an operation which is
     not allowed on textfiles.

     There are two other predefined, public file variables  of  type  TEXT,
     named  INPUT  and  OUTPUT.  If a file variable is omitted in a call to
     certain standard input routines, INPUT is assumed.  Similarly,  if  no
     file  variable  appears  in  calls  to  some standard output routines,









                                                       TYM-Pascal Report/65
                                                           February 8, 1980


     OUTPUT is assumed.  These assumptions are made for the convenience  of
     programmers.  Aside  from their predeclaration and use as default file
     identifiers  in  certain  routines,  INPUT  and  OUTPUT   are   normal
     textfiles.

     As  noted  earlier,  options  may be specified when a physical file is
     associated.  If no options are specified, the following  defaults  are
     assumed by the various routines:

         OPEN, RESET  --  the file must already exist, and its contents are
             preserved.  Only  printable  characters  will  be  input  from
             textfiles, with others being ignored.

         REWRITE  --  the  contents  of the file are deleted, if it already
             exists.  Otherwise, an empty file  is  created.  Any  and  all
             characters may be written to character files.

         UPDATE  --  the  contents  of an existing file are preserved, with
             an empty file being created  otherwise.  Additionally,  random
             access is allowed.

     In the cases where contents of a file are normally preserved, deletion
     of contents cannot be specified via an option, but may be accomplished
     by a subsequent call to a standard routine, EMPTY.

         EMPTY(<file variable>)  --  deletes the contents of the associated
             physical file which must have been associated with REWRITE  or
             UPDATE.  Default  deletion  of  contents  by  REWRITE  may  be
             overriden by specifying PRESERVE.

     Suppression of non-printing characters on input may  be  overriden  by
     specifying the ASCII option.  Finally, if random input or output is to
     be performed on a file not associated  with  UPDATE,  SEEKOK  must  be
     specified.

     The  implications  of  specifying  the IMAGE and RETRY options will be
     discussed later.

     Finally, the file name associated with a file variable may be obtained
     by calling the standard function FILENAME.

         FILENAME(<file  variable>)  returns  the  name  of  the associated
             physical file or device as a string of the predefined  varying
             string  type FILE_NAME, whose maximum length is implementation
             dependent.  The result returned by FILENAME when called with a
             file  variable which is not associated with a physical file or
             device is undefined.


     14.2.2  Dissociation and Multiple Associations

     All physical files and devices associated with file variables  when  a
     program  terminates normally are automatically dissociated.  Files may









                                                       TYM-Pascal Report/66
                                                           February 8, 1980


     also be dissociated during program execution by calling either or  two
     standard routines:

         CLOSE[(<file  variable>)]  --  Normal  dissociation.  If  the file
             variable is omitted, all  files  are  dissociated  as  if  the
             program had terminated.

         SCRATCH(<file  variable>)  --  The  specified  file  variable  and
             physical file  are  dissociated,  and  the  physical  file  is
             deleted.  If  deletion  fails  or is otherwise impossible, the
             effect is the same as CLOSE.

     Situations requiring explicit dissociation  during  program  execution
     include:  (1) deletion  of  a  temporary  "working" file when it is no
     longer needed, (2) before performing a sequence of operations  on  one
     physical  file  which  have  been  performed on another, (3) to make a
     physical file which has been  modified  available  to  other  programs
     while the program making the modifications continues to execute.

     As suggested in (2) above, a file variable may be dissociated from one
     physical file and then associated with another, i.e.,  file  variables
     may  be  multiply  associated  during  the  execution  of  a  program.
     Normally, CLOSE or SCRATCH must be called before the  second  call  to
     OPEN,  REWRITE,  etc.,  or  the  first association will be "lost".  In
     other words, the  external  environment  of  the  program,  e.g.,  the
     operating system, will still view the physical file as associated with
     the program, yet the program will have no way of  further  referencing
     the  file.  If,  however,  one associated file variable is assigned to
     another, either can safely be associated with  another  physical  file
     without  an  intervening  CLOSE  or  SCRATCH.  In  fact, if a CLOSE or
     SCRATCH  is  performed  on  one,  the  same  operation  is  implicitly
     performed  on  the  other.  Finally, CLOSE and SCRATCH should never be
     called with a file which is not associated.

     Thus, association and dissociation  of  file  variables  and  physical
     files  is  analogous  to allocation and deallocation of pointers.  For
     instance, omitting/performing CLOSE before RESET on  a  file  variable
     previously associated is similar to omitting/performing DISPOSE before
     NEW on a pointer previously allocated.

     A certain amount of additional "clean-up" is provided with  files,  in
     that all associated files, whether "lost" or not, are dissociated by a
     CLOSE call without arguments and by normal program termination.

     At certain points while  writing  a  file,  it  may  be  desirable  or
     necessary  to  insure  that  all  write  operations  which  have  been
     performed by the program are reflected in the physical file, which may
     not  be  the  case  if  I/O  is  buffered  in the implementation.  The
     standard procedure BREAK should be called at these points:

         BREAK [ (<file variable>) ] -- insures that  the  results  of  all
             previous  write  operations are reflected in the physical file
             associated with the  specified  file  variable.  If  the  file









                                                       TYM-Pascal Report/67
                                                           February 8, 1980


             variable  is  omitted, TTYOUTPUT is assumed.  The use of BREAK
             with interactive I/O is discussed further in Section 14.3.5.



     14.3  Textfile Input/Output

     Sequential character input and output  is  the  most  basic  and  most
     commonly  used  mode.  In  Pascal,  this  is accomplished through file
     variables of the predefined type TEXT.


     14.3.1  Textfile Structure

     A  Pascal  textfile  is  best  viewed  as  a  sequence  of  characters
     punctuated  with  marks  signifying  the  end of lines, pages, and the
     file.  Characters are read one at a  time  into  the  file  variable's
     buffer  variable.  Whenever a mark is input, instead of inputting some
     special character, a standard boolean function is set to  return  TRUE
     and  a blank is placed in the file's buffer variable.  When characters
     which are not marks are input, all of these standard functions  return
     FALSE.  Similarly, characters are output one by one to a file from the
     buffer variable, and routines are called to write marks,  rather  than
     writing  special  characters.  This  approach  frees programs from the
     implementation dependent formats for lines, pages and the file itself.


     14.3.2  Basic Character Input/Output

     The basic character I/O routines are:

         GET      --  input next character into buffer.
         PUT      --  output the character currently in buffer.
         EOLN     --  TRUE if end of line just encountered on input.
         EOPAGE   --  TRUE if end of page just encountered on input.
         EOF      --  TRUE if end of file just encountered on input.
         writeln  --  terminate the current line.
         PAGE     --  terminate the current page.

     The file on which to perform the operation is a parameter  to  all  of
     these  routines.  If  omitted,  file  OUTPUT  is  assumed  for  output
     operations  and  file  INPUT   for   input   operations.   Files   are
     automatically  terminated  when dissociated, hence there is no routine
     to output a  file  terminator.  Note  that  writeln,  while  it  is  a
     standard  routine name, is also a reserved word, for reasons discussed
     later.

     Page marks always occur at the end of lines and are signalled  at  the
     same  time as end of lines, i.e., if EOPAGE(F)=TRUE then EOLN(F)=TRUE.
     To insure that this is always the case,  PAGE(F)  always  performs  an
     implicit  writeln(F)  if  an  explicit  writeln(F) has not immediately
     preceded it.  EOF, however, becomes TRUE when an attempt  to  GET  the
     first  character  of  a  line after the last line of the file is made,









                                                       TYM-Pascal Report/68
                                                           February 8, 1980


     i.e., at the end of the last line EOLN is TRUE, then, after  the  next
     GET,  EOLN  is  FALSE  and  EOF  becomes  TRUE.  The following program
     fragment copies file INPUT to OUTPUT and demonstrates the use  of  the
     basic I/O functions.


         RESET(INPUT);    (*RESET performs an implicit GET*)
         REWRITE(OUTPUT);
         while not EOF do begin
              while not EOLN do begin
                   OUTPUT^:=INPUT^;
                   PUT;   (*OUTPUT is assumed file variable*)
                   GET    (*INPUT is assumed file variable*)
              end;
              writeln;    (*INPUT^=' ' at this point*)
              if EOPAGE then PAGE;
              GET         (*first character of next line*)
         end;
         CLOSE            (*all files*)

     Writeln  on  output  devices  such  as  line  printers or the terminal
     returns the carriage and advances to  the  next  physical  line.  PAGE
     similarly  advances to the top of the next physical page, although its
     effect on an interactive terminal is implementation dependent, and  it
     may  be  ignored.  EOPAGE  may never become TRUE on the terminal (TTY)
     depending on the implementation.  EOF may become TRUE on the terminal,
     if  the  implementation  provides  a means of inputting an end of file
     from the terminal, but it is not an error to continue  to  input  from
     it.  Thus,  it  is advisable to ignore EOF from the terminal to insure
     program portability.  On all other files, an attempt  to  input  after
     EOF becomes TRUE is an error.


     14.3.2.1  Character Set and the ASCII Option

     Any  of  an  implementation dependent set of characters may be used to
     terminate an input line.  Normally, the terminating character  is  not
     passed  to  the  program,  the  file  buffer is set to blank, and EOLN
     becomes TRUE.  Also, as noted previously, non-printing characters  are
     ignored,   i.e.,  skipped  on  input.  Finally,  horizontal  tabs  are
     translated into blanks according to an implementation dependent set of
     tab stops.

     If  the  ASCII  option  is  specified  in  RESET  or  OPEN, characters
     terminating a line are placed in the  file  buffer  (with  EOLN  still
     TRUE),  and non-printing characters are not skipped.  Horizontal tabs,
     if passed directly to programs by the operating system, are placed  in
     the  file  buffer, and not translated into blanks.  As the handling of
     such  special  characters  varies  from  system  to  system,  programs
     invoking  the  ASCII  option  are  likely  to  be  machine  dependent.
     Constants of type CHAR can be defined for special characters  via  the
     CHR function, e.g.,










                                                       TYM-Pascal Report/69
                                                           February 8, 1980


         const tab = chr(11B)


     14.3.2.2  Carriage Control and the CONTROL Option

     PAGE  and  writeln  provide  a  certain  amount of carriage control on
     output devices.  Additional control may be exercised on those  devices
     permitting it by specifying the CONTROL option in REWRITE.  If this is
     done, writeln terminates lines but does not affect the position of the
     carriage.  The  initial character of all output lines, i.e., the first
     character written to the file or the first character after a  writeln,
     determines the positioning of the carriage, as follows:

         ' ' :  advance to beginning of next line (single space)
         '0' :  advance to beginning of line after next (double space)
         '1' :  advance to beginning of next page (top of form)
         '+' :  return carriage but do not advance (overprint)
         any other : advance to beginning of next line (single space)

     The  initial  character  is printed unless it is in the set [' ', '0',
     '1', '+'].  As noted before,  the  effect  of  writeln  is  merely  to
     terminate  lines  under  the  CONTROL option.  PAGE is equivalent to a
     writeln followed by a PUT of '1', and thus  should  generally  not  be
     used  with  the CONTROL option, since the character output immediately
     after a PAGE will not be interpreted as carriage control, and will  be
     printed.

     The  character  devices  for which the CONTROL option may be specified
     are implementation dependent, as is  the  effect  of  reading  a  file
     written  with the CONTROL option.  It is thus advisable to specify the
     CONTROL option only when directly writing to an output device or  when
     writing  to  a  file which will be copied to such a device later.  The
     recommended interpretation on reading a file written with the  control
     option is as follows:

         ' ' :  equivalent to terminating previous line with writeln
         '0' :  previous line terminated with writeln; writeln
         '1' :  previous line terminated with PAGE
         '+' :  ignored, although some character may be passed if
                ASCII in effect

     Finally,  to  facilitate tabular input and output, a standard function
     CURSOR   is    defined.    CURSOR(<file    variable>)    returns    an
     integer-compatible  result  indicating  the number of characters which
     have been read from or written to the current line.  Thus, immediately
     after  a  writeln  or  PAGE,  CURSOR  returns  zero.  After  the first
     character is output (with PUT), CURSOR returns 1, after the second, 2,
     etc.  On  input,  CURSOR  returns the number of characters from a line
     which have preceded the character currently in the buffer.  Thus, when
     the  first character after the end of line is input (with GET), CURSOR
     returns 0, and when EOLN is TRUE on an input file, CURSOR returns  the
     number  of  characters previously read from the line, i.e., the length
     of the line not counting the end of line character.









                                                       TYM-Pascal Report/70
                                                           February 8, 1980


     Note that special characters read (if ASCII is in effect)  or  written
     are  counted  as  single  characters by CURSOR, no matter how they are
     echoed or printed.  CURSOR is simply a character count, and  does  not
     always reflect the physical position of the carriage on I/O devices.


     14.3.3  Character Input/Output Conversions

     A constant or variable of certain types may be converted to a sequence
     of characters forming an external (printable)  representation  of  its
     value.  Conversely,  the  value  of a variable of certain types may be
     set by  converting  a  sequence  of  characters  forming  an  external
     representation  of  a constant of the same or compatible type.  In the
     former case, the sequence of characters may be output  directly  to  a
     character  file  or may be placed in a string-compatible variable.  In
     the latter, the sequence may be input from a character file  or  taken
     from  a string-compatible expression.  These conversions are specified
     by standard routines whose names are also reserved words, as follows:

         write and writeln  convert value(s) and output to character
                            file
         read and readln    input from character file and convert
                            value(s)
         putstring          convert value(s) into string-compatible
                            variable
         getstring          convert value(s) from string-compatible
                            expression

     Putstring   and   getstring   perform   conversions   to   and    from
     string-compatible  items,  instead  of  output  or  input  streams.  A
     writeln is the same as a  write  with  an  identical  parameter  list,
     except  that  writeln  outputs  a line mark after all conversions have
     been made and output.  Similarly, readln is the same as  read,  except
     that  after  all  conversions  have  been  made,  the remainder of the
     current input line (if any) is discarded, and the first  character  of
     the  next line is input into the file buffer.  The syntax of a call to
     these routines is as follows:

         <i/o conversion> ::= <input conversion> | <output conversion>

         <input conversion> ::= (read | readln)
            [ '(' [ <input list> | <file reference>
               [ ',' <input list> ] ] ')' ]

         <output conversion>::= (write | writeln)
            [ '(' [ <output list> | <file reference>
               [',' <output list> ] ] ')' ]

         <string conversion>::= <putstring> | <getstring>

         <putstring>::= putstring
             '(' <string variable reference> ',' <output list> ')'










                                                       TYM-Pascal Report/71
                                                           February 8, 1980


         <getstring>::= getstring
             '(' <string expression> ',' <input list> ')'

         <output list>::= <output item> [',' <output item>]*
         <output item>::= <expression> [<output format>]
         <input list>::= <input item> [','<input item>]*
         <input item>::= <variable reference> [<input format>]


     Calls to these routines look much like calls to any other, except that
     formatting  directives may be appended to parameters in the list.  For
     this  reason,  the  names  of  the  routines  are  reserved.  Explicit
     formatting is discussed in Section 14.3.4.  The first parameter of the
     I/O routines is the file on which I/O is to be  performed,  while  the
     first  parameter of the string conversion routines is the string being
     operated upon.  If the file variable is omitted in the  I/O  routines,
     INPUT  or  OUTPUT is assumed.  The remaining parameters (I/O items) of
     all routines specify either variables into which converted values  are
     to  be stored (read, readln, getstring) or expressions which are to be
     converted (write, writeln, putstring).  Zero or more I/O items may  be
     specified to writeln and readln while one or more must be specified to
     read, write, and string conversions.

     The I/O conversion routines use the basic  routines  GET  and  PUT  to
     perform  I/O.  The first character examined on any input conversion is
     the one currently in the file buffer, e.g.,  for  INPUT,  the  current
     value   of  INPUT^.  The  character  in  the  buffer  after  an  input
     conversion is the one which terminated  the  converted  sequence,  and
     will  be the first one examined by the next conversion, if there is no
     intervening GET.  On an output conversion, characters  are  stored  in
     the  buffer  and  PUT  one  by one.  Thus, the character in the buffer
     after an output conversion will be the  final  one  in  the  converted
     sequence.  Also,

         read(F,V1,...,Vn)

     and

         write(F,V1,...Vn)

     are equivalent to

         read (F,V1); ...  ;read(F,Vn)

     and

         write(F,V1); ...  ;write(F,Vn)

     respectively,  thus  it  is  sufficient  to  describe  the conversions
     performed on individual items to define completely  the  operation  of
     the conversion routines.

     In  getstring,  characters are taken in sequence from the string until









                                                       TYM-Pascal Report/72
                                                           February 8, 1980


     either values have been converted into all items, or the  end  of  the
     string  is  reached.  In  the latter case, the value(s) of item(s) not
     processed are  unchanged,  and  the  routine  returns.  In  read  (and
     readln)  characters  are  read  from  the  file  until  all  items are
     processed, crossing as many line and page boundaries as necessary.  It
     is  an  error  if the end of file is encountered before all items have
     been processed.  The difference between read and  readln  is  that  in
     readln,  after  all  items  are  processed, the following operation is
     effectively performed:


         while not EOLN(F) do GET(F);
         GET(F)

     In putstring, items are processed until  the  maximum  length  of  the
     string  is  reached  or  all items have been processed.  In the latter
     case, if the string is varying, its length is set to the total  number
     of characters generated in processing the items, while if it is fixed,
     its remaining characters are blanked.  This  treatment  is  consistent
     with  string  assignment  in  PASCAL.  In putstring, either all of the
     characters generated by an individual item conversion  are  stored  in
     the  string, or none are.  In write (and writeln) all items are always
     processed.


     14.3.3.1  Default Input Conversions

     The manner in which variables or expressions in items are converted is
     determined  by their types.  The default conversions, applied in read,
     readln, and getstring, i.e.,  those  applied  when  no  formatting  is
     specified, are as follows:

     Character-compatible  variables,  i.e.,  variables  of  type  CHAR and
     subranges thereof cause the next character in sequence to be stored in
     the variable.  Thus, read or readln of a character-compatible variable
     V from textfile F is defined as:

         V:=F^;GET(F)

     Note that a character will be  transferred  from  the  buffer  to  the
     variable   even  when  EOLN=TRUE.  String-compatible  variables  cause
     characters to be taken in sequence until either the maximum length  of
     the  variable  or  the end of the current input line (read, readln) or
     the end of the argument string (getstring) is reached.  This  sequence
     of  characters,  of length less than or equal to the maximum length of
     the variable is then assigned to the variable.  Thus, if the  variable
     is  a  varying  string,  its  length  becomes  the length of the input
     sequence and, if the variable is  a  fixed  string,  the  sequence  is
     padded  with  blanks  before assignment if its length is less than the
     length of the variable.  Note that the character returned at  the  end
     of  the  line is not stored in the string variable, and that reading a
     string when EOLN=TRUE returns a null string.










                                                       TYM-Pascal Report/73
                                                           February 8, 1980


     An integral constant conforming to  the  syntactical  rules  for  such
     constants   may   be   converted   into   an   integer-compatible   or
     real-compatible variable, and a valid real constant may  be  converted
     into  a  real-compatible  variable.  In  either case, blanks are first
     skipped, crossing line boundaries  if  necessary,  until  a  non-blank
     character  is  encountered.  If  the  characters  which  follow do not
     constitute a valid numeric constant, the corresponding variable is set
     to  zero  and the conversion terminates on the first invalid character
     encountered.  An  error  also  occurs  unless  the   first   non-blank
     character  is a comma, in which case the corresponding variable is set
     to zero, and the conversion terminates without error.  A valid numeric
     constant   may   be   terminated   by  any  character.  The  character
     terminating the conversion will be the first one examined by the  next
     conversion, unless it is a comma.  To facilitate separation of numeric
     values with commas, when a  numeric  conversion  is  terminated  by  a
     comma,  the  character  after the comma is input into the file buffer,
     i.e., the comma is not treated like other terminating  characters  and
     is considered to be part of the constant instead.  Thus,

         read (F,A,B,C)

     where  A,  B, and C are all real-compatible variables may be satisfied
     by the input line

         -4,,2.36

     which sets A=-4.0, B=0.0, and C=2.36.  F^=',' after the conversion  of
     A (the second comma).  The second conversion sets B to 0.00 and F^='2'
     (the character after the comma).  Finally, C is set to  2.36  and  the
     conversion is terminated by the end of a line.  Normally, F^ would now
     contain a blank, unless the ASCII option had been  specified.  In  any
     case,  the  character  in  the  file  buffer  when  EOLN=TRUE is never
     examined by  a  numeric  conversion,  since  an  end  of  line  either
     terminates  a  conversion  in  process or is skipped before conversion
     begins.  In fact, the character in the file buffer when EOLN=TRUE will
     only be transferred by a read or readln into a character variable.


     14.3.3.2  Default Output Conversions

     When  write,  writeln,  or  putstring  are  called  with a variable or
     expression without formatting, the characters written or stored in the
     target  string by putstring depend on the type of value.  The contents
     of  character-compatible  and  string-compatible  values  are  written
     without modification, while numeric values are converted as follows:

     An  integer-compatible  value  is  converted  to  a  string of decimal
     digits, preceded by a minus sign if the value is negative and a  space
     otherwise.  Only  significant  digits  are  printed,  i.e., no leading
     zeroes are printed except for zero itself  which  is  output  as  '0'.
     Thus, for an integral value e, the number of characters printed is p+1
     where 10**(p-1) <= abs(e) < 10**p.










                                                       TYM-Pascal Report/74
                                                           February 8, 1980


     A  real-compatible  value  is  converted  either  to  a  fixed   point
     representation,  e.g.,  '237.8' or to a floating point representation,
     e.g., '2.378E+02', depending on the magnitude  and  precision  of  the
     value.  The  fraction  of  floating point representations is between 1
     and 10, excluding 10, while fixed point representations have at  least
     one  digit  before  the  decimal  point.  In  either case, the minimum
     number of digits printed is equal to the precision of the value, which
     is  either  the specified (via prec) or default (precision of standard
     type real) precision if the value is a variable,  or  is  the  maximum
     precision  of  any  of  the operands if the value is an expression.  A
     fixed point representation is printed if it requires fewer  characters
     than   the   equivalent   floating  point  representation.  Otherwise,
     floating point is used.  Whether fixed or floating  point  is  chosen,
     the  representation  is  preceded  by  a  minus  sign  if the value is
     negative and a space otherwise.  Thus, if NEXP characters are required
     to  print  an  exponent  and PR is the precision of a value E, a fixed
     representation is used if 10**-NEXP <= E < 10**(PR+NEXP) and  floating
     point otherwise.


     14.3.4  Formatted Input/Output

     Input  and output conversions may be controlled by the program through
     formats.  Formats specify the number  of  characters  to  be  read  or
     written  (the  field  width) in all cases, and for numeric values, the
     representation to be read or written as well.


     14.3.4.1  Formatted Input

     An input format consists of an integral expression, referred to as the
     field  width,  appended  to  the  variable  and separated from it by a
     colon.  Formats appended to an integer-compatible  variable  may  also
     include  a  ':O'  (either  upper or lower case) after the field width,
     specifying that input constant is to be interpreted as an octal rather
     than  decimal value.  Similarly, ':H' (either case) may be appended to
     specify hexadecimal input interpretation.

          <input format> ::=
             ':' <expression> [ ':O' | ':o' | ':H' | ':h' ]

     The field width specifies the number of characters to  be  taken  from
     the  argument  string  in  getstring or read from the file in read and
     readln.  Characters are taken until the field width is exhausted,  the
     end  of  the input string is reached (getstring) or an end of line (or
     page)  is  encountered  (read,  readln).  These  characters  are  then
     processed according to the type of the item.

     Formats  may  not  be  used  with character-compatible variables.  The
     sequence  of  characters  is  merely  assigned  to   string-compatible
     variables.  The  only  difference  between a formatted and unformatted
     string input operation is the additional  limit  on  characters  taken
     from  the  input  source  imposed by the field width.  That is, enough









                                                       TYM-Pascal Report/75
                                                           February 8, 1980


     characters are taken, if available, to satisfy the field width;  these
     characters are then assigned to the string-compatible variable.

     A  formatted  numeric  input  operation is identical to an unformatted
     operation with the exception that the conversion terminates at the end
     of   the  sequence  of  characters  defined  above.  If  no  non-blank
     character or an invalid numeric constant is encountered, the  variable
     is set to zero.  In the latter instance, an error also occurs.

     ':O'   or  ':o'  may  be  appended  to  a  field  width  following  an
     integer-compatible variable if an octal input conversion  is  desired.
     Similarly,  ':H'  or  ':h'  may  be  appended  to  a  field width if a
     hexadecimal input conversion is desired.  Only characters from the set
     ['0'..'7']  optionally  preceded  by  a  minus sign are allowed in the
     input constant for  octal  conversion,  while  hexadecimal  conversion
     allows  any  decimal  digit, plus the characters ['A'..'F'], in either
     upper or lower case, optionally preceded by a minus  sign.  Note  that
     an explicit radix character ('B' or 'b' signifying octal, for example)
     following the constant is not required; if it is  not  valid  for  the
     type  of  input, it will in fact be treated as a non-numeric character
     terminating the conversion.


     14.3.4.2  Formatted Output

     Output formats provide parameters for text conversion, and differ with
     the type of the item being converted to external form.

         <output format> ::= <string format> | <integer format> |
                             <real format> | <boolean format>

         <string format> ::= ':' <expression> [ ':L' | ':l' ]

         <integer format> ::=
            ':' <expression> [ ':O' | ':o' | ':H' | ':h' ]

         <real format> ::=
            ':' <expression> [ ':' <expression> [ ':E' | ':e' ] ]

         <boolean format> ::= ':' <expression>


     The initial expression in an output format, which must be integral, is
     referred to  as  the  field  width.  For  real  formats,  the  initial
     expression  is  sometimes  referred  to  as  the total field width, to
     distinguish it from the second integral expression which  may  appear,
     referred to as the fractional field width or the precision factor.

     In  general,  the  (total) field width specifies the minimum number of
     characters which will result from the conversion.  Numeric  conversion
     overflow  may  cause  this  field  width  to be exceeded, as discussed
     below.  Also, all putstring conversions are checked against the number
     of available character positions available in the target string before









                                                       TYM-Pascal Report/76
                                                           February 8, 1980


     any characters are stored.  Regardless of any explicit output formats,
     no  characters  will  be  stored in the target string if the putstring
     would overflow the remaining character positions.

     A string or character expression with a format is output with  leading
     spaces if the length of the string expression is less than or equal to
     the specified field width, such that the total  number  of  characters
     output  equals  the  specified field width.  Character expressions are
     treated as strings  of  length  one.  If  the  length  of  the  string
     expression is greater than the field width, the string is truncated on
     the right such that the number of characters output equals  the  field
     width.  If  ':L'  or  ':l'  is  specified,  string expressions will be
     output with trailing spaces, instead of leading spaces,  to  fill  the
     specified  field  width.  The  effect  is  to  left justify the string
     within a field of spaces.

     An integral expression is converted to a string of decimal  digits  in
     the  same  manner  as  in the unformatted case, but the string is then
     output with sufficient leading spaces (right justified)  to  fill  the
     specified field width.  If the length of the converted integer exceeds
     the field width, the conversion overflows, and the converted string is
     simply  output,  producing more characters than specified by the field
     width.  When outputting a  non-negative  number  which  overflows  the
     field width, no leading space is printed.  Thus, by specifying a field
     width which will always overflow  (zero,  for  example),  the  leading
     blank which precedes non-negative integers with default formatting may
     be suppressed.

     If ':O' or ':o' is appended to the field width expression, the integer
     is  converted  to  a  string  of  octal,  instead  of decimal, digits.
     Similarly, ':H' or ':h' will convert the  integer  to  a  hexadecmimal
     representation.  The  lowest  order digits in the hexadecimal or octal
     representation are output,  completely  filling  the  specified  field
     width.  A  loss  of  significance can occur, since the field width for
     octal or hexadecimal integer output is never exceeded; only the lowest
     order digits are output.  When the field width provides more room than
     required for  full  significance,  leading  zeroes  are  supplied  for
     non-negative  integer  expressions,  while  negative  expressions  are
     padded on the left with either the character '7' (for  octal)  or  'F'
     (for hexadecimal).

     There  are  three  ways  of  specifying  format  parameters  for  real
     expressions to be output.  The first method is to specify an  explicit
     total  field  width, such as 'X:12'.  This produces the floating point
     format, or the so-called 'E' format in  FORTRAN,  in  which  the  real
     number  is printed as the product of a 'mantissa' between 1.0 and 10.0
     and an integral power of 10.  Such a format specification  causes  the
     output   field  to  be  filled  completely.  Assume  there  exists  an
     implementation dependent value NEXP, which is the number of characters
     needed  to  represent  any possible signed decimal exponent value (for
     example, NEXP=3 will cover the range -38..+38).  Then the output  item
     'X:TFW'  uses  the  following algorithm:  store a sign character using
     blank  or  minus  as  appropriate;  store  a  (TFW-NEXP-2)   character









                                                       TYM-Pascal Report/77
                                                           February 8, 1980


     representation  of  the  mantissa  between 1.0 and 10.0, including the
     decimal  point;  store  the  character  'E'  or  'e'   (implementation
     dependent);  store  the  NEXP  character representation of the decimal
     exponent.  Note  that  the  field  width  must  be  at  least  NEXP+5,
     requiring  at least two digits precision in the mantissa (for example,
     '-2.3E-10').

     The second method is to specify an explicit total field width  and  an
     explicit fractional field width, such as 'X:12:3'.  This specifies the
     fixed point, or  FORTRAN  'F',  format.  The  fractional  field  width
     specifies  the  number of digits which will appear to the right of the
     decimal point, while the total field width specifies the total  number
     of  characters  to be output.  If the magnitude of the real expression
     is either too large or too small to  be  represented  in  fixed  point
     format  without  overflowing  the field width, the field width will be
     exceeded  up  to  an  implementation  defined  number  of   characters
     (possibly  zero).  Beyond  this,  the  number  will  be converted into
     floating point, using the specified total field width, in  the  manner
     described  above.  If  the  expression will fit in the field width, it
     will be right justified.  Note that a leading blank  for  non-negative
     expressions is not required, as it is in the floating point format.

     The  third  method is to specify the characters ':E' or ':e' after two
     formatting expressions, such as 'X:12:3:E'.  This specifies  'explicit
     E'  format.  The  second  integral expression in this case is called a
     precision factor.  A format such as 'X:TFW:PR:E' specifies a  floating
     point  format  with  PR  digits  represented  in  the  mantissa, right
     justified within a field width of TFW.  PR must be at  least  two;  if
     the  real  expression  is  non-negative,  and  if  TFW  is  less  than
     PR+3+NEXP, the field width TFW will  be  exceeded.  Similarly,  for  a
     negative  real  expression,  if  TFW is less then PR+2+NEXP, the field
     width will be exceeded.  Thus, as  with  integers,  the  specification
     'X:0:5:E'  will  produce the output string 'n.nnnnE+nn', with the zero
     value for total field width removing the leading  space  for  positive
     expressions.

     Boolean   output  formatting  follows  the  rules  for  string  output
     formatting, with the fixed length strings 'TRUE' or  'FALSE'  used  as
     appropriate.  The  field width will never be exceeded.  Note that ':L'
     or ':l' for left justification of  strings  cannot  be  specified  for
     boolean output items.


     14.3.5  Interactive Textfile Input/Output

     (To be supplied.)


     14.3.6  IMAGE Input/Output

     (To be supplied.)











                                                       TYM-Pascal Report/78
                                                           February 8, 1980


     14.4  Typed Input/Output

     So  far  this discussion has concerned textfile input and output, that
     is, files containing lines of characters.  While  it  is  possible  to
     read  and  write  character  strings representing integers, reals, and
     more complex structures such as  sets,  records,  and  arrays,  it  is
     simpler  and  more efficient to read and write the actual bit patterns
     to and from memory.  Typed files provide a facility for such input and
     output.

     All  file  types are bound to a component type.  This type effectively
     defines the template for interpreting fixed  length  bit  patterns  in
     physical  files  as  Pascal  data entities.  As with text files, typed
     files have an associated buffer  component,  f^,  which  contains  the
     current  file element.  For typed files, f^ is of the file's component
     type.


     14.4.1  The Pascal Typed File Model

     A file composed of fixed length elements may be thought of as an array
     with an unlimited upper bound.  The operations on typed files transfer
     individual elements of the array to and from  the  buffer.  They  also
     affect  certain  attributes  and state information associated with the
     file variable.  A procedural definition of typed  file  operations  is
     presented below.


     A typed file, defined by:

          var f: file of <type>

     has the following hidden entities associated with it:

          f.mode: ( readonly, writeonly, readwrite );
          f.extent: 0 .. *;
          f.cursor: 1 .. *;
          f.data: array [1 .. f.extent] of <type>
          f.buffer: <type>

     Mode  is  a state variable which retains the permissible operations on
     the file variable from association  time.  Extent  is  the  number  of
     elements  in the file, while cursor selects one element as the current
     one.  The data array contains the components of the file,  indexed  by
     cursor,  and  representing the physical file itself, and buffer is the
     buffer component described above.  The programmer accesses these  data
     as follows:

          EXTENT(f)         returns f.extent
          CURSOR(f)         returns f.cursor
          EOF(f)            returns (f.cursor > f.extent)
          f^                references f.buffer










                                                       TYM-Pascal Report/79
                                                           February 8, 1980


     Note  that  CURSOR for a textfile is different from CURSOR for a typed
     file.  Here, CURSOR represents the current index in the virtual  array
     f.data.  Note  also  that EOF only reflects the position of the cursor
     relative to the end of the file.


     14.4.2  Association of Typed Files

     The association operations for typed file  variables  are  defined  as
     follows:


     RESET (f)    (* initialize for input only *)

          f.mode := readonly;
          f.extent := "the number of elements in the file";
          f.cursor := 1;
          if f.cursor <= f.extent then
            f.buffer := f.data [f.cursor]


     REWRITE (f)  (* initialize for output only *)

          f.mode := writeonly;
          if "preserve in open options" 
            then f.extent := "the number of elements in the file"
            else f.extent := 0;
          f.cursor := f.extent + 1;
          f.buffer := "undefined"


     UPDATE (f)   (* initialize for input/output *)

          f.mode := readwrite;
          f.extent := "the number of elements in the file";
          f.cursor := 1;
          if f.cursor <= f.extent then
            f.buffer := f.data [f.cursor]


     The  OPEN  operation  is  not  provided  for  typed files.  The quoted
     strings above represent operations whose  form  is  dependent  on  the
     implementation  but  whose meanings should be clear; for example, "the
     number of elements in the file" is the file size if the  file  is  not
     empty,  and  zero  if  the file is either empty or does not exist.  If
     f.extent is zero,  the  error  code  returned  upon  association  will
     distinguish the latter two cases (see Section 14.6).


     14.4.3  Data Transfer Operations for Typed Files

     The data transfer operations for typed files are defined as follows:










                                                       TYM-Pascal Report/80
                                                           February 8, 1980


     GET (f)      (* input *)

          if f.mode = writeonly then error;
          if f.cursor > f.extent then error;
          f.cursor := f.cursor + 1;
          if f.cursor <= f.extent then
            f.buffer := f.data [f.cursor]


     PUT (f)      (* output *)

          if f.mode = readonly then error;
          if f.cursor > f.extent then f.extent := f.cursor;
          f.data [f.cursor] := f.buffer;
          f.cursor := f.cursor + 1


     The   word   "error"  above  implies  that  the  operation  terminates
     immediately, setting an error code (see Section 14.6).

     The primitive operations above are sufficient for sequential input and
     output.  Several  points  are  worthy  of  note.  On input operations,
     CURSOR is incremented before the actual transfer operation,  while  on
     output  operations,  it  is  incremented  after the transfer.  In both
     cases, CURSOR represents the current  index  into  the  virtual  array
     f.data.  Notice  that  RESET  and  UPDATE  effectively  perform  a GET
     operation as they fill the buffer with the first datum  in  the  file.
     Also,  a GET which increments f.cursor past f.extent does not fill the
     buffer, and EOF becomes true.  This also holds for a RESET of  a  file
     which exists but is empty.  Finally, note that PUT extends the file if
     necessary.


     14.4.4  Random File Operations

     Random access is provided through the  SEEK  operator  for  all  files
     associated  with  the  SEEKOK  option.  SEEKOK  is  assumed  for files
     associated with UPDATE.  SEEK is defined below:


     SEEK (f, n)

          f.cursor := n;
          if (f.mode <> writeonly) and (f.cursor <= f.extent) then
            f.buffer := f.data [f.cursor]


     SEEK is used to reposition  CURSOR  to  another  place  in  the  file.
     Notice  that  if  input  is  permitted,  SEEK  will  perform  an input
     operation if the new CURSOR value is within the file, thus insuring f^
     is  always  defined.  The programmer should make every effort to avoid
     redundant GET operations by remembering that SEEK  keeps  f^  updated.
     For   example,   the   sequence  "SEEK(n);  GET;  f^..."  contains  an









                                                       TYM-Pascal Report/81
                                                           February 8, 1980


     unnecessary GET, since a SEEK(n+1) would have loaded  f^  as  desired.
     Similarly,  to update the n-th element of an update file, the sequence
     "SEEK(n); f^ := newvalue; PUT" suffices; no  GET  is  needed.  Notice,
     however,  that  after  the  PUT,  even  though f.cursor is now n+1, f^
     contains the (new) n-th element.  At this point, to update the (n+1)th
     element,  a  "SEEK(n+1)" is required to load f^; a GET would increment
     f.cursor before loading f^, loading the (n+2)th element instead of the
     (n+1)th.

     For  convenience,  the  following  shorthand translations are provided
     (read "=>" as "is equivalent to"):

          read (f, x)  =>                x := f^; GET (f)
          write (f, x)  =>               f^ := x; PUT (f)

          read (f, x1, ... , xn)  =>     read(f, x1);...;read(f, xn)
          write (f, x1, ... , xn)  =>    write(f, x1);...;write(f, xn)

          readrn(f, m, x1, ..., xn)  =>  SEEK(f,m);read(f,x1,...,xn)
          writern(f, m, x1, ..., xn)  => SEEK(f,m);write(f,x1,...,xn)


     The read and write functions are most useful for sequential operations
     over  the  entire  file,  or over several contiguous elements.  Notice
     that a read (or readrn) operation always GETs the next  element  after
     the one just read.


     14.5  Binary Files

     It is often desirable or necessary to read and write blocks of data of
     arbitrary size.  The file type which is bound  to  no  component  type
     ("file  of  *")  provides  this  capability.  Such binary files may be
     defined in terms of  the  model  presented  in  the  previous  section
     (Section  14.4).  The  difference is that there are no restrictions on
     the  types  of  elements  written  or  read   (typed   files   require
     compatibility with the component).


     14.5.1  Extension of the Typed Formalism for Binary Files

     Any  variable  x  can  be  viewed  as  an array of "storageunits" with
     upperbound SIZE(x), where a storageunit is  the  smallest  addressable
     unit  of  storage  for  a given machine.  Assuming for the moment that
     storageunit is a type (which, of course, it is not),  and  that  x.[i]
     references  a unit of storage whose address is "ADDRESS(x)+i-1" within
     variable x, we may define the various binary file operators (read "=>"
     as "is conceptually") as:














                                                       TYM-Pascal Report/82
                                                           February 8, 1980


          file of *  =>           file of storageunit

          read (f, x:m)  =>       for i := 1 to m do read (f, x.[i])
          write (f, x:m)  =>      for i := 1 to m do write(f, x.[i])

          read (f, x)  =>         read (f, x: SIZE (x))
          write (f, x)  =>        write (f, x: SIZE (x))


     The  operations  readrn  and writern, as well as read and write with a
     list of arguments, are defined in terms  of  a  single  element  read,
     write,  and  the  SEEK operation identically for both typed and binary
     files (see Section 14.4.4).  SEEK sets the file cursor  for  the  next
     operation,  and  read  and  write  effect  input  and output transfers
     respectively.  The cursor is maintained in storage units,  thus  calls
     to  SEEK  may  utilize  SIZE,  EXTENT,  or  both  to  preserve machine
     independence (see Sections 12.3 and 12.4).  No buffer variable (f^) is
     defined  for  binary files, thus the GET and PUT operations may not be
     used.

     However, binary files may be viewed  as  having  a  "internal  buffer"
     which is not directly accessible.  While GET, PUT, and the file buffer
     f^, which are used to define the read and write operations  for  typed
     files,  cannot  be  used  with binary files, the model given for typed
     file operations is still valid for  binary  files  if  the  programmer
     visualizes  the  operations  in  terms  of the storageunit type and an
     internal buffer.  For example, after a RESET on a binary file,  CURSOR
     is 1 (and is subsequently adjusted in storageunit increments), and the
     internal buffer contains the first storageunit.  If  a  read  is  then
     performed,  for a variable which is one storageunit in size, the first
     storageunit in the file will be transferred into the variable from the
     internal  buffer,  and  the  next storageunit in the file will be read
     into the internal buffer.  Through a similar line  of  reasoning,  the
     operation  readrn  (f,  3,  x)  will  get  x  starting  at  the  third
     storageunit in  the  file.  Note  that  no  internal  buffer  actually
     exists, and thus the read operation does not really load file elements
     into it.


     14.6  Errors in Input and Output

     Errors in the Pascal  I/O  system  fall  into  two  distinct  classes.
     Certain  errors  indicate  catastrophic environmental conditions which
     are certain  to  affect  the  program's  subsequent  performance  (for
     example,  a  hard  disk error).  After such errors, further operations
     are prohibited on the file where  the  error  occurred.  Other  errors
     signal irregular results from standard functions which will not affect
     subsequent operations.














                                                       TYM-Pascal Report/83
                                                           February 8, 1980


     14.6.1  The Predefined Type IO_STATUS

     The Pascal I/O system  communicates  error  information  to  the  user
     program through values of the predefined type IO_STATUS:

        type
          io_status = 
          ( io_ok,   io_novf, io_povf, io_dgit, io_govf, io_intr,
            io_rewr, io_eof,  io_outf, io_inpf, io_seek, io_illc,
            io_nemp, io_opnf );

   The meaning of each value is explained in Section 14.6.3.

   There is an error code associated with every file variable, which is set
   on every I/O operation.  The predefined function IOSTATUS(f) returns the
   current  value  of the error code for the file variable f, and resets it
   to IO_OK.  IOSTATUS with no parameter returns the most recent error code
   set  by the I/O system, which is set for every text formatting operation
   (i.e., getstring and putstring) as well as every I/O operation.

   It is important to note that every item in an  I/O  list  represents  an
   individual  operation,  and  that an error occuring on the processing of
   one item may be reset by the next item.

        scratch(f);
        if iostatus (f) = io_nemp then    (* f not there any more *)
          writeln (tty, 'Couldn''t delete scratch file.');


        getstring (str, i);
        local := iostatus;                (* call without parameter *)
        if local = io_govf then
          writeln (tty, 'Couldn''t find any integer there.')
        else if local = io_novf then
          writeln (tty, 'Integer too big.');


        reset (f, fname, options);
        if eof (f) then
          if iostatus (f) = io_opnf then
            writeln (tty, 'File not found.')
          else writeln (tty, 'File is empty.');


   14.6.2  Fatal and Non-fatal I/O Errors

   The error codes in the previous  section  may  be  subdivided  into  two
   classes   --   fatal   and   non-fatal.  Non-fatal  errors  signal  some
   "interesting" condition which may be ignored by the  I/O  system.  Fatal
   errors,   with   one   exception,   cause  immediate,  abnormal  program
   termination unless the file variable in question was associated with the
   RETRY  option.  This  option  defers  program termination until the next
   file operation, to permit examination of  IOSTATUS(f).  If  no  call  to









                                                       TYM-Pascal Report/84
                                                           February 8, 1980


   IOSTATUS(f)  is  made,  the  next call to any I/O system routine using f
   will cause abnormal program termination with the same error condition as
   would  have  occurred  previously, if f had not been associated with the
   RETRY option.  Since IOSTATUS(f) clears the file variable's error  code,
   it  is  the  programmer's  responsibility to avoid subsequent operations
   which may be damaging.


   14.6.3  Meanings of I/O Error Codes

   The conditions signalled by each of the values  of  type  IO_STATUS  are
   listed below.  The following are the non-fatal conditions:

   IO_OK   - the initial and default value.  No error condition.

   IO_NOVF - arithmetic  overflow  on  conversion.  An  attempt was made to
             convert an external value to  an  integer  which  exceeds  the
             allowed   range   of   values.  Subrange  limits  are  checked
             independently.  The value of the integer item is not modified.

   IO_POVF - putstring overflow.  Conversion of a data item to its external
             representation  would  have exceeded the maximum length of the
             string-compatible target.  The external representation is  not
             stored in the object string of the putstring.

   IO_DGIT - invalid   numeric  input.  For  integer  reads,  a  digit  was
             encountered which is not within the base of the  read  (e.g. a
             '9'  seen  during  an  octal read), terminating the read.  For
             integer or real reads, the first non-blank character seen  was
             not  acceptable  for  the  conversion,  and  the corresponding
             variable is set to zero.

   IO_GOVF - getstring  overflow.  The  end  of  the  object   string   was
             encountered  before  acceptable  characters  for  the  desired
             conversion (e.g., a blank string for an  integer  conversion).
             The target reference's value is not modified.

   The following are the fatal conditions:

   IO_INTR - internal  error  in  I/O  system.  An implementation dependent
             error has been detected.

   IO_REWR - rewrite required.  An attempt was made to write  onto  a  file
             which  was  open  for input only.  Subsequent input operations
             will work.

   IO_EOF  - attempt  to  read  beyond  EOF.  Input  operations  cannot  be
             performed  once  end of file has been encountered.  This error
             code is also returned from an attempt  to  read  from  a  file
             which  was open for output only.  Subsequent output operations
             will work.  If the file was associated with the SEEKOK option,
             the error may be recovered by SEEKing within the file limits.










                                                       TYM-Pascal Report/85
                                                           February 8, 1980


   IO_OUTF - output  failure.  An environmental error occurred on an output
             operation.  Subsequent output operations may be damaging.

   IO_INPF - input failure.  An environmental error occurred  on  an  input
             operation.  Subsequent input operations may be damaging.

   IO_SEEK - attempt   to  SEEK  non-random  file.  A  SEEK  operation  was
             performed on a file not associated  with  the  SEEKOK  option.
             This error requires no correction.

   IO_ILLC - illegal  cursor value.  A non-positive cursor value was passed
             to SEEK.  This error requires no correction.

   IO_NEMP - can't empty file.  The EMPTY operation on  the  file  variable
             failed,  or  a  SCRATCH  failed and performed a CLOSE instead.
             The file variable should be CLOSEd by the program if EMPTY was
             attempted.

   IO_OPNF - association   failure.   The   file   variable  could  not  be
             associated as requested.  The file variable need not be CLOSEd
             after  such an error.  This is the only fatal error which will
             not cause immediate termination -- it is always  deferred,  as
             if  RETRY  had  been  specified.  In addition, EOF can be used
             after  an  association  operation  as  an  error  check.   For
             input-only  and  input-output  files,  EOF  will be TRUE if an
             error occurred; for output-only files, EOF will be FALSE if an
             error  occurred.  Performing  a  RESET with an empty file will
             also set EOF TRUE, but the IOSTATUS(F)  error  return  may  be
             used to distinguish between the two conditions.


   14.6.4  Extended Status

   The  predefined  function  EXTSTATUS returns an integer compatible value
   which further  describes  I/O  errors  in  an  implementation  dependent
   fashion.  The default value of EXTSTATUS is zero.  For example,


        open (f, filename, options);
        if iostatus (f) = io_opnf then begin
          local := extstatus;
          writeln (tty, 'File failed, code [', local:12:o, ']')
          end;

   will  print  the message 'File failed, code [000000000001]' if EXTSTATUS
   returns the value 1.  Note that the local variable was  needed  to  save
   the  value  of EXTSTATUS, since the writing of the constant string 'File
   failed, code [' would have reset EXTSTATUS to zero.














                                                       TYM-Pascal Report/86
                                                           February 8, 1980


   15.  STANDARD FUNCTIONS


   15.1  Arithmetic Functions


   15.1.1  Ordinary Mathematical Functions

   Each of the following functions takes a single real argument (except for
   ARCTAN--see  note  3)  and  returns a real result.  The precision of the
   result is at least as  great  as  the  precision  of  the  argument.  An
   integer  argument is converted to type REAL.  These functions have their
   conventional mathematical meanings.

          SQRT          LN (1)         LOG (2)        EXP
          SIN           ARCSIN         SINH           COS
          ARCCOS        COSH           TAN
          ARCTAN (3)    TANH           COTAN

     Notes:
          (1)  LN returns the base e logarithm of its argument.
          (2)  LOG returns the base 10 logarithm of its argument.
          (3)  ARCTAN may take two arguments.  ARCTAN(x,y) =
               ARCTAN(x/y), except that it is defined even if
               y is zero.


     15.1.2  Generic Mathematical Functions

          ABS(x) = |x|
          SQR(x) = x*x

     When called with  an  integer  argument,  these  functions  return  an
     integer  result.  When called with a real argument, they return a real
     result with at least the precision of the argument.

          MIN(x1,x2,...,xn)
          MAX(x1,x2,...,xn)

     MIN returns the smallest of its arguments, and MAX returns the largest
     of  its  arguments.  If  all  of  the arguments are integers, then the
     result is an integer.  If any of the arguments are real, then  all  of
     the arguments are converted to real, and the result is real.


     15.1.3  Miscellaneous

          ODD(x)  is  a  predicate  which  takes  an  integer argument, and
               returns TRUE if its argument is odd,  and  FALSE  if  it  is
               even.












                                                       TYM-Pascal Report/87
                                                           February 8, 1980


          RANDOM(x)  returns  a  pseudo-random  real  number with a uniform
               distribution from the interval 0 <= RANDOM(x) < 1,  using  x
               as the seed for the random number generator.

          RANDOM() is the same as RANDOM(x), but it uses the value returned
               by the last call to RANDOM for its seed.  On the first  call
               to RANDOM, a standard seed is used.


     15.2  Type Conversion Functions

     15.2.1  Arithmetic Conversions

          TRUNC(x)   takes   a   real  argument,  and  returns  an  integer
               representing  the  integral  part  of  its  argument.  TRUNC
               always truncates towards zero.

          ROUND(x)  takes a real argument, and returns the integer which is
               closest to its argument.

               ROUND(x)   = TRUNC(x+0.5), if x > 0.
                          = TRUNC(x-0.5), if x < 0.

          ROUND(x,n).  ROUND may also  take  a  second,  integer  argument.
               When  called  in  this  form,  ROUND  returns  a real result
               representing its first  argument,  rounded  to  the  decimal
               place indicated by its second argument.

                    ROUND(x,n) = ROUND(x/(10**n)) * (10**n)

               For  example,  ROUND(3.1415,-2)  =  3.14; ROUND(1495.27,2) =
               1500.


     15.2.2  Scalar and Pointer Conversions

          ORD(s) takes an argument of  any  scalar  type,  and  returns  an
               integer  representing the ordinal of the argument in the set
               of values making up its type.  The elements of an enumerated
               scalar  type  have ordinals 0, 1, ...  n-1, corresponding to
               their positions in the list defining the type.  If s  is  an
               integer, then ord(s) = s.

          ORD(ptr).  The ORD function may also be applied to a pointer, and
               will return an integer representing the address in memory of
               the object pointed to by ptr.

          CHR(n)  takes an integer argument, and returns the n-th character
               in  the  ASCII  character  set.  That  is,  CHR(n)  is   the
               character with numeric representation n in ASCII.

     Let  T  be  the  name of any simple type, and let P be the name of any
     pointer type.  Then the following functions are defined:









                                                       TYM-Pascal Report/88
                                                           February 8, 1980


          T(n).  A simple type name may be used as a function  which  takes
               an  integer  argument,  and  returns the n-th element of the
               type T.  CHR is equivalent to the type name CHAR used  as  a
               function.

          P(ptr).  A  pointer  type  name  may  be used as a function which
               takes any pointer as an argument, and returns a  pointer  of
               type  P  which  points to the same location in memory as its
               argument pointer.  Unwise use of  this  feature  may  easily
               compromise  program portability, in much the same way as use
               of undiscriminated unions in record types.

          P(n).  A pointer type name may also be used as a function with an
               integer  argument.  It returns a pointer of type P, pointing
               to the absolute memory location n.


     15.3  Operations on Simple Types

          SUCC(v) takes an argument of any simple  type  except  real,  and
               returns  the next element of that type.  If v is the largest
               value of its type, this is an error.  ORD(SUCC(v)) =  ORD(v)
               + 1.

          PRED(v)  takes  an  argument  of any simple type except real, and
               returns the previous element of  that  type.  If  v  is  the
               smallest   element   of   its   type,   this  is  an  error.
               ORD(PRED(v)) = ORD(v) - 1.

          MINIMUM(v) takes an argument of any simple type, and returns  the
               smallest value of that type.  The argument to MINIMUM may be
               either a reference of a simple type,  or  the  name  of  the
               simple type itself.

          MAXIMUM(v)  takes an argument of any simple type, and returns the
               largest value of that type.  The argument to MAXIMUM may  be
               either  a  reference  of  a  simple type, or the name of the
               simple type itself.

          MIN and MAX  may  be  called,  not  only  with  integer  or  real
               arguments,  but with arguments of some scalar type.  All the
               arguments must be of the same type, and MIN or  MAX  returns
               the smallest or the largest of the arguments, respectively.


     15.4  String Functions

     In   the   following   descriptions,  s,  s1,  and  s2  represent  any
     string-compatible expressions (i.e., a fixed or varying string,  or  a
     character);  ind,  len, and default are integer values; and chars is a
     set of characters.











                                                       TYM-Pascal Report/89
                                                           February 8, 1980


          LENGTH(s) takes a string, and returns an integer representing its
               length.  The  length  of a character is always 1; the length
               of a fixed string is the declared length of the string;  and
               the  length  of  of  a varying string is the current length,
               which is between zero and the declared maximum length of the
               string.

          UPPERCASE(s)  takes  a string, and returns an identical string in
               which all the lowercase letters have been  replaced  by  the
               corresponding uppercase letters.

          LOWERCASE(s)  takes  a string, and returns an identical string in
               which all the uppercase letters have been  replaced  by  the
               corresponding lowercase letters.

          SUBSTR(s,ind[,len])  takes  a  string,  an index, and an optional
               length.  If  the  length  is  omitted,  SUBSTR  returns  the
               substring  of  the original string from the ind-th character
               to the end of the string.  If the length is specified,  then
               SUBSTR returns len characters from the string, starting with
               the ind-th character.  The arguments to SUBSTR must  satisfy
               the relations:

               1 < ind < LENGTH(s) + 1, if len is omitted.
               1 < ind < ind + len < LENGTH(s) + 1,
                  if len is specified.

               Unlike  any  other  function,  SUBSTR may also appear on the
               left side of an assignment statement.  In this case, s  must
               be  a  variable reference (see section 10.1), and the effect
               is to replace the specified  characters  of  the  referenced
               string  by  the string expression from the right side of the
               assignment.

          INDEX(s1,s2[,default]) returns the  index  in  s1  of  the  first
               character  of the leftmost occurrence of s2.  If s2 does not
               occur in s1, then INDEX returns zero if the default argument
               is omitted, or the default argument if it is specified.

          SEARCH(s,chars[,default])  returns  the  index  of  the  leftmost
               character in s which is in the chars set.  If  there  is  no
               such  character  in  the string, then SEARCH returns zero if
               the default argument is omitted, or the default argument  if
               it is specified.

          VERIFY(s,chars[,default])  returns  the  index  of  the  leftmost
               character in s which is not in the chars set.  If  there  is
               no such character in the string, then VERIFY returns zero if
               the default argument is omitted, or the default argument  if
               it is specified.












                                                       TYM-Pascal Report/90
                                                           February 8, 1980


     15.5  File Predicates

          EOF(file)  takes  a  file as an argument, and returns TRUE if the
               current position in the file is at or beyond  its  end,  and
               FALSE  otherwise.  EOF  should  always be true for an output
               file not associated with the SEEKOK option.  If EOF is  true
               for  an  input  file  not associated with the SEEKOK option,
               then any further attempt to read from the file will cause an
               error.

          EOLN(file)  takes a text file as an argument, and returns TRUE if
               the file is positioned at the  end  of  a  line,  and  FALSE
               otherwise.  When  a  text file is positioned at the end of a
               line, the file buffer (file^) contains a space character  if
               not  associated  with  the  ASCII  option.  The  file can be
               advanced to the start of the next line by doing a GET  or  a
               readln.

          EOPAGE(file)  takes  a text file as an argument, and returns TRUE
               if the file is positioned at the end of a  page,  and  FALSE
               otherwise.  EOPAGE implies EOLN, so the file may be advanced
               by doing a GET or readln.

          CURSOR(file) takes a file as argument.  For a text  file,  CURSOR
               returns  an  integer-compatible  position within the current
               line.  For non-text  files,  CURSOR  returns  the  one-based
               index into the file corresponding to the current position in
               the file.  For typed files, f^ contains the CURSORth element
               in the file.

          IOSTATUS(file)  may  take a file as argument, and returns a value
               of type  IO_STATUS  indicating  any  errors  that  may  have
               occurred  on  the  last  file  operation.  If no argument is
               given, the result of the last operation (including putstring
               and getstring) is returned.

          EXTSTATUS()    returns   an   integer-compatible   value   giving
               implementation-dependent extended status of  the  last  file
               operation.

          EXTENT(file)  returns  the  number  of actual elements in a typed
               file or the number of actual storage units in a binary file.
               EXTENT may not be used with text files.

          FILENAME(file)  returns  the  name of the physical file or device
               associated with a file as a string of the predefined varying
               string    type    FILE_NAME,   whose   maximum   length   is
               implementation dependent.














                                                       TYM-Pascal Report/91
                                                           February 8, 1980


     15.6  Environment Inquiries

          DATE() returns a nine-character string,  containing  the  current
               date in the format DD-MMM-YY (e.g., '17-Apr-78').

          TIME() returns an integer representing the number of milliseconds
               which have elapsed since midnight.

          RUNTIME() returns an integer representing milliseconds of elapsed
               CPU  time.  The  value  of  RUNTIME  at the start of program
               execution is  not  specified,  but  the  difference  between
               RUNTIME  at the start of program execution and RUNTIME at an
               arbitrary time during execution will always be the number of
               CPU milliseconds used by this program.


     15.7  Attribute Inquiries

          LOWERBOUND(a[,dim])  returns  the  lower  bound of an array (in a
               specified dimension), of a string, or of a set.  If a is  an
               array   reference  or  the  name  of  an  array  type,  then
               LOWERBOUND returns the lower  bound  of  the  array  in  the
               dimension specified by dim, which must be a positive integer
               constant.  If the dim argument is omitted, it defaults to  1
               (the  leftmost  dimension).  When  applied  to  a  fixed  or
               flexible array, LOWERBOUND returns a constant, which may  be
               of  any  simple  type.  When  applied  to  a  generic  array
               parameter, LOWERBOUND returns the ordinal value of the lower
               bound   of   the   corresponding   actual  array  parameter.
               LOWERBOUND returns 1 when applied to a string  reference  or
               type  name,  and  the  lower  bound  of  the set domain when
               applied to a set reference or type name.

          UPPERBOUND(a[,dim]) is the same as  LOWERBOUND,  except  that  it
               returns  the upper bound of an array, string, or set instead
               of its lower bound.  When applied to an array, the result of
               UPPERBOUND  is  a  constant unless the argument is a generic
               array parameter or a flexible array reference.  When applied
               to a string reference, UPPERBOUND returns the maximum length
               of the string type.  When applied to a set, it  returns  the
               upper bound of the domain of the set type.

          DIMENSION(a[,dim])  is  related to LOWERBOUND and UPPERBOUND.  It
               returns an integer indicating the number of elements  in  an
               array,  the maximum number of characters (maximum length) of
               a string, or the number of elements in the domain of  a  set
               type.  In all cases, DIMENSION(a,n) = ORD(UPPERBOUND(a,n)) -
               ORD(LOWERBOUND(a,n)) + 1.

          ADDRESS(v) returns a value of type PTR  representing  the  memory
               address  of  the  variable v.  V may be a variable reference
               (see section 9) which is not  a  substring  reference  or  a
               scalar  component  of a packed structured variable; or v may









                                                       TYM-Pascal Report/92
                                                           February 8, 1980


               be a value parameter.

          EXTENT(ptr) returns an integer representing the number of storage
               units  (generally, the minimum addressable amount of storage
               on a machine) occupied by the dynamic variable ptr^, if  the
               dynamic variable was allocated by a NEW or ALLOCATE.

          SIZE(x)  returns  an  integer  representing the number of storage
               units required for the storage of its  argument.  X  may  be
               either  a  variable reference or a type name.  The type of x
               may not be a  packed  scalar  type,  and  x  may  not  be  a
               reference  to  a non-structured field of a packed structured
               type.  When applied to a flexible array,  SIZE  can  take  a
               second  argument  specifying  the upper bound for the array.
               When applied to a generic array parameter,  SIZE  takes  two
               additional  arguments  specifying the lower and upper bounds
               respectively.  When applied to a record with variants,  SIZE
               can  take constant tag values to select variants to be used.
               When applied to a record with a trailing flexible component,
               SIZE  can  take  a final argument specifying the upper bound
               for the array.


     15.8  Predefined Constants

          COMPDATE()  returns  a  nine-character  string,  containing   the
               compilation  date  of  the  module  in  the format DD-MMM-YY
               (e.g., '17-Apr-79').

          COMPTIME() returns a eight-character string, containing the  time
               of  day  of  the  compilation  in the format HH:MM:SS (e.g.,
               "14:22:03").


     15.9  Functions in Constant Expressions

     All of the standard functions may be  used  in  constant  expressions,
     except for the following:

          RANDOM        EOLN           EOF            DATE
          TIME          RUNTIME        ADDRESS        CURSOR
          EOPAGE        IOSTATUS       EXTSTATUS      EXTENT
          FILENAME

     If  a  function is used in a constant expression, all the arguments of
     the function must be constant expressions, unless the function is  one
     of  the  following,  which  return information about the type of their
     arguments rather than about their values:

          MINIMUM       MAXIMUM        LOWERBOUND     UPPERBOUND
          DIMENSION     SIZE











                                                       TYM-Pascal Report/93
                                                           February 8, 1980


     Appendix    SYNTAX

     In the BNF which follows, symbols of the form  <something  reference>,
     <something  expression>  and  <constant  something>  (except <constant
     definition>) are understood to produce  to  <reference>,  <expression>
     and <constant> respectively.  The qualifier in the symbol name is used
     as semantic commentary.


     <compilation> ::=
        <main program> | <subroutine module> | <data module>

     <main program> ::= <program heading> <body> '.'

     <program heading> ::=
        program <identifier> [ <options clause> ] ';'

     <body> ::=
        [ <declaration part> ';' ] <statement part>

     <subroutine module> ::=
        <module heading> <module declaration part> '.'

     <module heading> ::=
        module <identifier> [ <options clause> ] ';'

     <data module> ::=
        <data module heading> <data declaration part> end '.'

     <data module heading> ::=
        datamodule <identifier> [ <options clause> ] ';'

     <declaration part> ::=
        <declaration> [ ';' <declaration> ]*

     <module declaration part> ::=
        <module declaration> [ ';' <module declaration> ]*

     <module declaration> ::=
        <data declaration> | <subroutine declaration>

     <declaration> ::=
        <label declaration> | <data declaration> |
        <subroutine declaration>

     <data declaration part> ::=
        <data declaration> [ ';' <data declaration> ]*

     <data declaration> ::=
        <const declaration> | <type declaration> |
        <var declaration>











                                                       TYM-Pascal Report/94
                                                           February 8, 1980


     <label declaration> ::=
        label <label> [ ',' <label> ]*

     <const declaration> ::=
        [ public | external ] const
           <constant definition> [ ';' <constant definition> ]*

     <constant definition> ::=
        <identifier> ':' <type> |
        <identifier> [ ':' <type> ] ( '=' | ':=' ) <constant>

     <var declaration> ::=
        [ public | external | static ] var
           <var definition> [ ';' <var definition> ]*

     <var definition> ::=
        <identifier list> ':' <type> [ ':=' <constant> ]

     <identifier list> ::= <identifier> [ ',' <identifier> ]*

     <type declaration> ::=
        type <type definition> [ ';' <type definition> ]*

     <type definition> ::= <type identifier> '=' <type>

     <type identifier> ::= <identifier>

     <subroutine declaration> ::=
        <actual subroutine declaration> |
        <forward subroutine declaration> |
        <external subroutine declaration>

     <actual subroutine declaration> ::=
        [ public ] <subroutine heading> ';' <body>

     <forward subroutine declaration> ::=
        [ public ] <subroutine heading> ';' forward

     <external subroutine declaration> ::=
        external <subroutine heading>

     <subroutine heading> ::=
        <procedure heading> | <function heading>

     <procedure heading> ::=
        procedure <identifier> [ <parameter list> ]
           [ <options clause> ]

     <function heading> ::=
        function <identifier> [ <parameter list> ]
           ':' <type> [ <options clause> ]











                                                       TYM-Pascal Report/95
                                                           February 8, 1980


     <parameter list> ::=
        <short parameter list> | <long parameter list>

     <long parameter list> ::=
        '(' [ <parameter definition>
                [ ';' <parameter definition> ]* ] ')' 

     <parameter definition> ::=
        [ var ] <identifier list> ':' <type>

     <short parameter list> ::=
        '(' [ <parameter description>
                [ ';' <parameter description> ]* ] ')'

     <parameter desciption> ::= [ var ] <type>

        (* A <short  parameter  list>  may  only  appear  in  an  <external
           subroutine declaration> or a <subroutine type> *)

     <options clause> ::=
        options <option> [ ',' <option> ]*

        (* The  syntax  of  <option>s  is  not  specifically defined by the
           language *)


     <type> ::=
        <type indentifier> | <simple type> | <pointer type> |
        <set type> | <subroutine type> | <file type> |
        <structured type>

     <simple type> ::=
        [ <packing clause> ] <unpacked simple type>

     <packing clause> ::=
        packed [ '[' <constant width> ']' ]

     <unpacked simple type> ::=
        <enumerated type> |  <subrange type>

     <subrange type> ::=
        <constant lower limit> '..' <constant upper limit>
                 [ prec <constant precision> ]

     <enumerated type> ::=
        '(' <identifier> [ ',' <identifier> ]* ')'

     <pointer type> ::= '^' <type>

     <set type> ::= [packed] set of <domain type>












                                                       TYM-Pascal Report/96
                                                           February 8, 1980


     <domain type> ::= <type identifier> | <unpacked simple type>

     <subroutine type> ::=
        procedure [ <parameter list> ] |
        function [ <parameter list> ] ':' <type>

     <file type> ::=
        [ packed ] file of ( <type> | '*' )

     <structured type> ::=
        <array type> | <string type> | <record type>

     <array type> ::=
        [ packed ] array
         '[' <index type> [ ',' <index type> ]* ']' of <type>

     <index type> ::=
        <type identifier> | <unpacked simple type> |
        <constant lower bound> '..' '*' | '*'

     <string type> ::=
        string [ '[' (<constant maximum length>| '*' ']' ]

     <record type> ::=
        [ packed ] record [ <field list> ] [ ';' ] end

     <field list> ::=
        <fixed part> [ ';' <variant part> ] |  
        <variant part>

     <fixed part> ::=
        <field definition> [ ';' <field definition> ]*

     <field definition> ::=
        <identifier list> ':' <type>

     <variant part> ::=
        case [ <identifier> ':' ] <type> of
           <variant> [ ';' <variant> ]*

     <variant> ::=
        <case label list> ':' '(' [ <field list> ] [ ';' ] ')'

     <case label list> ::= <range list> | others

     <statement part> ::= begin <statement list> end

     <statement list> ::= <statement> [ ';' <statement> ]*

     <statement> ::=
        [ <label> ':' ] <unlabelled statement>











                                                       TYM-Pascal Report/97
                                                           February 8, 1980


     <unlabelled statement> ::=
        <simple statement> | <structured statement> |
        <exit statement>

     <simple statement> ::=
        <assignment statement> | <call statement> |
        <goto statement> | <return statement> |
        <stop statement> | <null statement>

     <assignment statement> ::=
        <variable reference> ':=' <expression>

     <call statement> ::=
        <procedure reference> [ <actual parameter list> ]

     (* Standard I/O conversion routines read, readln, write,
        writeln, putstring and getstring have non-standard
        parameter lists and reserved identifiers. *)

     <goto statement> ::= goto <label>

     <return statement> ::= return

     <stop statement> ::= stop

     <null statement> ::= (* nothing *)

     <structured statement> ::=
        <compound statement> | <with statement>
        <conditional statement> | <repetitive statement> |

     <compound statement> ::=
        begin <statement list> end

     <with statement> ::=
        with <record reference> [ ',' <record reference ]* do
           <unlabelled statement>

     <conditional statement> ::=
        <if statement> | <case statement>

     <if statement> ::=
        if <expression> then <unlabelled statement>
           [ else <unlabelled statement> ]

     <case statement> ::=
        case <expression> of
           <case member> [ ';' <case member> ]* [';'] end

     <case member> ::=
        <case label list> ':' <unlabelled statement>











                                                       TYM-Pascal Report/98
                                                           February 8, 1980


     <repetitive statement> ::=
        <while statement> | <repeat statement> |
        <for statement> | <loop statement>

     <while statement> ::=
        while <expression> do <unlabelled statement>

     <repeat statement> ::=
        repeat <statement list> until <expression>

     <for statement> ::=
        for <identifier> ':=' <for range> do
           <unlabelled statement>

     <for range> ::=
        <initial expression> to <final expression> |
        <initial expression> downto <final expression>

     <loop statement> ::=
        loop <statement list> end

     <exit statement> ::=
        exit if <expression> [ do <unlabelled statement> ]

        (* An exit statement  is  used  as  an  escape  from  a  repetitive
           construct.  It  can  only appear in the body of such a statement
           or in a with statement which  itself  appears  in  a  repetitive
           statement.  *)

     <reference> ::=
        <entire reference> | <field reference> | 
        <indexed reference> | <substring reference> |
        <pointer reference> | <function reference> |
        <component reference>

     <entire reference> ::= <identifier>

     <field reference> ::=
        <reference> '.' <identifier>

     <indexed reference> ::=
        <reference> '[' <expression> [ ',' <expression> ]* ']'

     <substring reference> ::=
        <reference> '[' <expression> ':' <expression> ']'

     <pointer reference> ::= <reference> '^'

     <function reference> ::=
        <function reference> [ <actual parameter list> ]












                                                       TYM-Pascal Report/99
                                                           February 8, 1980


     <actual parameter list> ::=
        '(' [ <expression> [ ',' <expression> ]* ] ')'

     <component reference> ::= <reference> '^'

     <constant> ::= <expression>

        (* Any  expression  may  be  used  as a <constant> provided that it
           yields a constant value.  Most of the standard functions may  be
           used.  *)

     <expression> ::=
        <simple expression> | <composite expression>

     <simple expression> ::=
        <term> [ <relational operator> <term> ]

     <relational operator> ::=
        in | '=' | '<' | '>' | '<>' | '<=' | '>='

     <term> ::=
        <factor> [ <adding operator> <factor> ]*

     <adding operator> ::=
        '+' | '-' | or | orif | '||'

     <factor> ::=
        <power expression>
           [ <multiplying operator> <power expression> ]*

     <multiplying operator> ::=
        '*' | '/' | div | mod | and | andif

     <power expression> ::=
        <unary expression> [ '**' <unary expression> ]

     <unary expression> ::=
        [ '+' | '-' | not ] <primitive expression>

     <primitive expression> ::=
        <unsigned integer> | <unsigned real> | <string> |
        <reference> | '(' <simple expression> ')' | 
        <set expression>

     <composite expression> ::=
        '(' [ <expression>  [',' <expression> ]* ] ')'

        (* A  structured  expression  can only be used in a context where a
           value of a structured type is expected.  *)

     <set expression> ::= '[' [ <range list> ] ']'











                                                      TYM-Pascal Report/100
                                                           February 8, 1980


     <range list> ::= <range> [ ',' <range> ]*

     <range> ::= <scalar expression> [ '..' <scalar expression> ]

























































 iq