OPTVAR.TXT, last modified 10/24/83, zw

                    Optimization of Programs
                    with Structured Variables

     The problems presented by structured  variables  are  seldom
considered   in  standard  algorithms  for  common  subexpression
elimination.  We have modified  the  value  number  algorithm  of
Cocke  and  Schwartz  to  allow  considerable  flexibility in the
treatment of data references, and have developed heuristics which
allow  efficient optimization of expressions involving structured
variables within basic  blocks.  Our  approach  can  be  extended
naturally to handle global common subexpression elimination.

1.   Introduction

     Common  subexpression  elimination  within  a basic block is
well understood.  A number of algorithms have been published (for
example,  Aho and Ullman [1,2], Gries [4] and Hecht [5]), most of
them based to some extent on the value number method of Cocke and
Schwartz   [3].  While  these  algorithms  will  produce  optimal
results in programs with only simple variables,  their  treatment
of  structured  variables  is limited.  In general, they consider
only array variables, and treat an assignment to any component of
an array as a redefinition of the entire array.

     Structured  variables  are  entities  such as arrays, Pascal
records,  and  strings,   which   are   made   up   of   multiple
sub-variables.   These  sub-variables  may  be  referred  to  and
modified independently, or a structured variable may be  referred
to or modified in its entirety.

     In  modern  programming languages such as Pascal, structured
variables are used extensively.  Therefore,  when  we  began  the
implementation  of  an  optimizing  Pascal  compiler,  a  primary
consideration was that the programmer should not have to pay  for
his   use  of  structured  variables  with  reduced  optimization
effectiveness.

2.   The Basic Idea

     The algorithm of Cocke and Schwartz [3] maintains a "current
value"  for  each  variable  symbol,  and a hash table of current
expressions, each with a unique value number.  An  expression  is
tested  for  redundancy by looking it up in the hash table, using
the value numbers of its subexpressions to compute the hash  key.
Assignment  to  a  simple variable simply sets its current value;
assignment to an array element gives the  array  variable  a  new
value   number,   so   that   no  previously  known  element  can
subsequently be recognized as a common subexpression.

     Our new algorithm also  keeps  a  value  for  each  symbolic
variable and a hash table of expressions.  However, we update the
value number of a structured variable (i.e., an array or  record)
only  when an assignment is made to the entire variable.  We also
keep an auxiliary list of statements which modify variables,  and
when  we  find  a  common subexpression which is a component of a
structured variable,  we  check  the  list  to  see  whether  any
statement   has   been  processed  which  could  invalidate  this
expression.

3.   The Invalidation Test

     Our new algorithm is  more  expensive  than  the  Cocke  and
Schwartz  algorithm,  since it requires a search of the modifying
statements list whenever a common component reference  is  found.
Our  return  comes  in  the  latitude  which  we have in deciding
whether a statement invalidates a reference.  This test may be as
simple or as complex as the compiler writer desires; it may check
for special cases where that seems appropriate;  and  it  may  be
modified   to   allow   for   different   data   types.   In  our
implementation,  we  chose  a  simple  recursive  test   function
(presented  in  the  appendix).  Following  are  some examples of
cases which it can detect:

  o  Assignment to A[I] does not invalidate A[I+1], but  it  does
     invalidate   A[J]  (assuming  nothing  is  known  about  the
     relation between I and J).

  o  After the assignment "A[I]:=A[J]", both A[I]  and  A[J]  are
     available  as  common  subexpressions.  (Either I=J or I<>J.
     In either case, the value of A[J] is unchanged.)

  o  Similarly, after the assignment "P^:=Q^", both P^ and Q^ are
     available.

  o  If  R  is  a record with fields F1 and F2, and F1 and F2 are
     not in different variants, then an assignment to  R.F1  does
     not invalidate R.F2.

  o  Given the declaration:
          var P, Q: ^ record
                        case F1: BOOLEAN of
                          TRUE: (F2: INTEGER);
                          FALSE: (F3: CHAR)
                      end;
     An  assignment to P^.F2 does not invalidate Q^.F3.  (P and Q
     must not point to the same record.  If they did, then either
     the  assignment  to  field  F2  or the reference to field F3
     would be illegal, since in Pascal it is illegal to refer  to
     a  field  in  a  variant record which is not selected by the
     current value of the tag field.)

  o  If the variant record in the previous example  had  been  an
     undiscriminated  union  (i.e.,  if  the  tag  field  F1 were
     omitted),  then  the  assignment   to   P^.F2   would   have
     invalidated  Q^.F3,  since  now  assignments  to overlapping
     fields of the same record would be legal.

4.   Global Common Subexpressions

     References to an expression X can be replaced by  references
to  an expression Y only if expression Y must be evaluated before
expression X on every control flow path through the program.  But
this  simply  means  that  either  Y precedes X in the same basic
block, or the basic block containing Y dominates the basic  block
containing  X  in  the  program  flow graph.  Thus, global common
subexpression  elimination  may  be  performed  with   the   same
algorithm  as local common subexpression elimination, by applying
the algorithm along  paths  in  the  flow  graph  dominator  tree
instead of within basic blocks.

     We  compute  the  dominator tree with an algorithm by Tarjan
[7].  The only additional information we  need  is  the  sets  of
variables which can be modified along some control flow path from
a dominating block to a dominated block.  We compute  these  sets
with  an  algorithm by Reif [6].  However, since Reif's algorithm
manipulates sets (represented as bit vectors), we have to  select
some set of variables for the algorithm to work with.

     Rather  than  using the actual variables of the program, and
having to decide whether A[i] and A[j] are two distinct variables
or   only   one,   we   introduce  a  set  of  "Formal  Reference
Expressions", or FREs.  The FREs are defined recursively:

  o  If X is  a  symbolic  variable,  then  there  is  an  FRE  X
     representing X.

  o  If  F  is an FRE representing an array, then there is an FRE
     F[~] representing all of the elements of F.

  o  If P is a pointer type, then there is an FRE P^ representing
     all  of the dynamically allocated variables which a variable
     of type P might point to.

  o  If F is an FRE representing a record with a field  fi,  then
     there is an FRE F.fi representing that field of F.

     It  is  a  straight-forward problem to determine the sets of
input and output FREs for each  basic  block,  and  given  these,
Reif's  algorithm can be used to determine the information needed
for global common subexpression elimination.

Appendix.   The Invalidation Test Function

     For optimizing Pascal programs,  the  following  recursively
defined function gives good results when used as the invalidation
test in the common subexpression algorithm described  in  section
2.  Given  two  expressions  X1  and  X2,  an  assignment  to  X1
invalidates X2 (written "Invalidates(X1,X2)") if:

  o  X1 and X2 are references to the same variable symbol.

  o  X1 and X2 are pointer references P1^ and P2^, where  P1  and
     P2 have the same pointer type.

  o  X1  and  X2  are  array  references  A1[i1]  and A2[i2], and
     Invalidates(A1,A2) is true,  and  DistinctIndices(i1,i2)  is
     false.

  o  X1  and  X2  are  field  references  R1.f1  and  R2.f2,  and
     Invalidates(R1,R2) and InvFields(f1,f2) are true.

  DistinctIndices(i1,i2) is true if i1 and i2 have the  forms  c1
     and  c2  or  x+c1  and  x+c2,  where  c1  and c2 are unequal
     constants, and x is some common expression.

  InvFields(f1,f2) is true if f1 and f2 are field  names  in  the
     same  record type, and either (1) f1 and f2 are in different
     variants of an undiscriminated union, or  (2)  f2  is  in  a
     variant of a discriminated union, and f1 is the tag field of
     the discriminated union.

     References

1.   Aho, A.V., and Ullman, J.D.  Optimization of Straight Line
Programs.  SIAM J. Comput. 1, 1 (March 1972), 1-19.

2.   Aho, A.V., and Ullman, J.D.  Principles of Compiler Design.
Addison-Wesley, Reading, Mass., 1977.

3.   Cocke, J., and Schwartz, J.T.  Programming Languages and
their Compilers:  Preliminary Notes.  New York University, 1970.

4.   Gries, D.  Compiler Construction for Digital Computers.
Wiley, New York, 1971.

5.   Hecht, M.S.  Flow Analysis of Computer Programs.
North-Holland, New York, 1977.

6.   Lengauer, T., and Tarjan, R.E.  A Fast Algorithm for Finding
Dominators in a Flow Graph.  ACM Trans. on Prog. Lang. and
Systems 1, 1 (July 1979), 121-141.

7.   Reif, J.H.  Combinatorial Aspects of Symbolic Program
Analysis.  Ph.D.  Th., Harvard U., 1977.
