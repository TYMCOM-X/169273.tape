#DOCUMENT(<:VAX Exceptional Condition Handling Design Notes:>,<:August 17, 1981:>)
#SECT(Introduction)
This document describes the design of exceptional condition
handling for MDSI Pascal on the VAX. The functional
specification for condition handling is described in,
^ULanguage Enhancement Notes #2B, Exceptions, Conditions,
and Handlers|U (hereafter refered to as: LEN-#2B).
Specification for the exceptional conditional handling mechanism
for the PDP-10 implementation of MDSI Pascal is also
contained in LEN-#2B.
$skip
This document will first discuss the classes of exceptions
that can occur on the VAX. Second, the document will describe
the data structures produced by the MDSI Pascal compiler that
contain the information required by the exception handling
mechanism. Finally, the document will describe the runtime
exception handler and how it handles the exceptional conditions.
$skip
The appendices at the end of the document describe, in detail,
the data structures that the compiler must create, and the
condition handling entry points in the VAX Pascal runtime. The
appendices also show the calling sequences for the entry
points.
#SECT(General approach)
The general approach to handling exceptional conditions is the same
on the VAX as it is on the PDP-10. A slot in the call stack frame
is reserved for the address of a handler branch table
(for the offset of the
table and the format of the handler branch table, see section 3).
When an exception is detected, the runtime exception handler
will examine the handler branch tables until it finds a handler
for the condition, or until it reaches the top of the stack. If
it reaches the top of the call stack, the runtime routine
will issue a diagnostic indicating the condition and exit the
program. If a handler for the condition is found, the stack is
unwound to the handler, and execution of the program is resumed
beginning with the user's code that handles the given condition.
$skip
On the VAX, the exceptional conditions can be divided into four
categories: user conditions, attention interrupts (control C's),
Pascal runtime conditions, and VAX hardware conditions. These
classes are descibed in the following sections. They are separated
into these classes because each of these classes of exceptional
conditions will be signaled in a different way;
for example,
attentions will be signaled by an asynchronous system trap,
user-signaled conditions will be signaled by a call to PAX_EXC.SIGNAL.
#BEGINLEVEL
#SECT(Types of exceptional conditions)
This section describes each class of exceptional conditions: how the
condition is signaled, runtime entry points, and general
requirements of each of the condition classes.
#BEGINLEVEL
#SECT(User-signaled conditions)
User-signaled conditions are user defined conditions that
are a result of the user's program calling SIGNAL.
The user-signaled conditions are all handled through the
runtime routine, PAX_EXC.SIGNAL. The compiler generates all the
calls to PAX_EXC.SIGNAL. The macro code emitted by the compiler
should look like:
#BEGINFIGURE
PUSHAL        condition
CALLS        #1,PAX_EXC.SIGNAL
#ENDFIGURE
The routine that signals user conditions will then trigger the
runtime condition signaling mechanism by calling the runtime
exception manager (see section 3).
$skip
Note that a call to the Pascal function SIGNAL without a condition,
i.e. SIGNAL(), is not actually a call to SIGNAL, but rather
a call to RESIGNAL. The compiler should emit the following code for
a call to signal without a condition:
#BEGINFIGURE
CALLS       #0,PAX_EXC.RESIGNAL
#ENDFIGURE
The compiler must insure that SIGNAL may only be called with a user-defined
condition. If SIGNAL is called with a standard condition, a compilation
error should occur.
#SECT(Pascal runtime conditions)
This section describes the conditions that are detected by the Pascal
runtime system on the VAX. All the following conditions are
detected in the software within the runtime. Some of the
exceptions, such as "insufficient virtual memory", are detected
during calls to system routines, but are indicated via return
values from those routines and therefore must be checked for
within the runtime.
$skip
The following procedure should be used to maintain the status
types for the exceptional condtions
(this procedure should also be taken for all subsequent versions
of the Pascal exception handling mechanism). The scalar
types will be changed to include the VAX-specific sub-conditions.
Any PDP-10 sub-conditions not used by the VAX will not be
removed. The order of the sub-conditions will also remain the
same, and all VAX sub-conditions will be appended to the list.
This procedure will allow users to write code that is more
portable, because there will be one type file for all exception
conditions, and the user's code can check for all possible
sub-conditions, even though some of them may not occur.
#BEGINLEVEL
#SECT(Program checking exceptions)
Program exceptions are those errors that are detected as a result
of the /CHECK compiler option. When a program check exception
occurs, the PROGRAM_ERROR condition will be signaled.
The runtime will signal the condition, calling the runtime
exception manager with the address of the proper sub-condition
descriptor (see sections 3 and 4).
The calling sequence for a runtime exception will be
insured by using the following macro (see section 4):
#BEGINFIGURE
_EXCEPT        <exception addr>, <condition>
#ENDFIGURE
The condition cells are known by the runtime.
Since the runtime is actually handling the checking of exceptions, the
addresses of the condition descriptors need only be known by the runtime.
A PROGRAM_ERROR handler can determine which user exception which
occurred by calling the standard function PROGRAMSTATUS.
The compiler should generate the following code for a call to
PROGRAMSTATUS:
#BEGINFIGURE
CALLS     #0,PAX_EXC.PROGSTAT
MOVB       R0,<variable to hold sub-condition>
#ENDFIGURE
PROGRAMSTATUS returns the value in the enumerated type PROGRAM_STATUS.
For the definition and values of PROGRAM_STATUS, see appendix F.
#SECT(Input/Output exceptions)
Input/output exceptions will be signaled through the standard routine
IO_ERROR. An IO_ERROR handler can determine the particular
I/O exception by calling the standard function EXIOSTATUS. The I/O
exceptions will be signaled via the same mechanism as program exceptions.
The code generated by the compiler for a call to EXIOSTATUS is:
#BEGINFIGURE
CALLS       #0,PAX_EXC.EXIOSTAT
MOVB       R0,<variable to hold sub-condition>
#ENDFIGURE
For a description of the values that can be returned by EXIOSTATUS
see appendix F.
#SECT(Storage exceptions)
On the PDP-10 there are two storage exceptions, STACK_OVERFLOW and
STORAGE_OVERFLOW (heap overflow). On the VAX there is only one
storage exception, STORAGE_OVERFLOW. This is because on the VAX
stack space is automatically increased when more is needed
(note that this is not true of versions of VMS before VMS 2.0).
Therefore, on the VAX, a stack overflow is only possible
when all available virtual memory is exhausted, which is
the STORAGE_OVERFLOW condition.
#SECT(Miscellaneous exceptions)
These exceptions include things like addressing exception and
attempts to dispose an already freed pointer. These exceptions are
also triggered via calls to PAX_EXC.EXCEPT with the proper
condition descriptor. These exceptions will cause the standard
condition SPECIAL_ERROR to be signaled. The standard
function SPECIALSTATUS can be called to determine the specific
exception that occurred. The compiler generates the following code
for a call to SPECIALSTATUS:
#BEGINFIGURE
CALLS     #0,PAX_EXC.SPECSTAT
MOVB       R0,<variable for status condition>
#ENDFIGURE
The SPECIALSTATUS routine returns a scalar of the
enumerated type SPECIAL_STATUS.
For specification of the enumerated type SPECIAL_STATUS see
appendix F.
#ENDLEVEL
#SECT(Hardware exception conditions)
This class of conditions are those that are detected
by the VAX hardware. The VAX, upon detecting an exceptional
condition, calls the routine whose address is 0(FP) to have the
exception handled. If 0(FP) is 0, the VAX unwinds the procedure
call stack until the address of a handler is found, or until
it reaches the top of the stack.
$skip
To use the capabilities of the VAX, we are going to use the first
two longwords of the handler branch table to contain a procedure
entry mask and a JSB to a handler for the hardware condition.
This routine will decode the hardware exception into one of the
SPECIAL_STATUS, PROGRAM_STATUS, or MATH_STATUS exceptions,
push the condition descriptor onto the
stack and call PAX_EXC.EXCEPT.
The compiler must emit a zero word for the procedure entry mask
followed by a "JSB PAX_EXC.VAXCOND" (implementors take note that
the procedure entry mask will be zero, therefore any registers
other than R0,R1 must be explicitly saved by PAX_EXC.VAXCOND).
This means that the first 2 longwords, 8 bytes, of the handler branch
table are reserved for runtime exceptions.
For more information
on the handler branch table, see section 3.
Note that for this system to work correctly, it must never be
triggered asynchronously.
$skip
There is a side-effect of this implementation.
The user may not use Pascal exceptional condition handling, and
the VAX hardware condition handling simultaneously
(i.e. LIB$SIGNAL will not work properly if the user
establishes an ALLCONDITION handler or a handler for the
SPECIAL_STATUS or MATH_STATUS functions).
#SECT(Keyboard entered attentions)
This class of exception contains the user-typed attention, i.e. control-c.
The attention exception is a special case because it is handled
via an asychronous system trap, AST. This means that the program
tells the system to perform a special action when an attention
exception occurs; an AST is
declared and the program does whatever it does to handle this AST.
$skip
The attention exception handling mechanism on the VAX will require two
changes to the VAX runtime. First, code must be added
to LIB$INITIALIZE that will always declare an attention AST
handler at the
beginning of a program. Second, PAX_EXC.ESCAPE must be set
up to handle the attention interrupt. PAX_EXC.ESCAPE must
redeclare the AST handler, and call
PAX_EXC.EXCEPT with the ATTENTION condition
to have the attention exception handled.
$skip
Use of some mechanism in the sharable Pascal library
that would have the effect of only declaring an attention AST if
the program contained a reference to ATTENTION or ALLCONDITION..
was considered.
The idea was dismissed because even if the program did contain
a reference to the attention condition, the runtime must
act properly if there is no active handler for the
attention condition when it occurs.
#ENDLEVEL
#SECT(Extents and limitations)
The exception handling mechinism supplied on the VAX will be the
complete Pascal exception handling described in LEN-#2B. The
sole limitations, or omissions, are as follows. There is no STACK_OVERFLOW
condition on the VAX and there is no NOUNDERFLOW option on the
VAX.
The VAX will not trap on STACK_OVERFLOW because the stack is
automatically expanded when its declared size is exceeded.
The NOUNDERFLOW/UNDERFLOW compiler option available on the
DEC-10 is not available on the VAX, and furthermore the
default is NOUNDERFLOW on the VAX and UNDERFLOW on the PDP-10.
This means that UNDERFLOWS on the VAX will always be converted to
zeroes, whereas on the PDP-10 UNDERFLOWS trigger an exception
unless the NOUNDERFLOW option is provided.
$skip
The compiler should perform the following actions for each of the
above conditions.
The compiler should ignore the STACK_OVERFLOW condition. It is of
no consequence.
#ENDLEVEL
#SECT(Representation of Conditions)
In a user's program there is a condition cell for each of the
exceptional conditions. The formats for user-defined conditions
and standard conditions differ. The formats are described
in the following sections.
#BEGINLEVEL
#SECT(User-defined conditions)
A condition cell for a user-defined condition is a longword containing
its own address. A condition which is declared within a module
will have its cell allocated in the code/constant area for that
module. If the condition is declared public, its cell address must
also be denoted by a global symbol in that module. This means
that the compiler must produce the following code for user-defined
conditions:
#BEGINFIGURE
Public condition:
$skip
$para+3
CONDITION_NAME:: .Address CONDITION_NAME
$skip
Locally declared condition:
$skip
$para+3
CONDITION_NAME: .Address CONDITION_NAME
#ENDFIGURE
The condition address of an external user-defined condition is the value
of the global symbol with the same name, which
is the address of the condition cell in the module where it
is defined to be public.
#SECT(Standard conditions)
A condition cell for a standard condition is a longword allocated
in the static portion
of the runtime exception manager (see section 4).
The standard conditions are stored in a table to facilitate searching
for the MASK and UNMASK routines.
A standard
condition contains the following information in the following format:
$skip
$indent+12
$skip
$para-7
Bits\0..7\contain the value of the standard condition. This is used so the
runtime exception manager and the Pascal compiler refer to the
same item within the handler state block.
This is defined at load time and should never be changed.
$para-7
$skip
Bit\8\=\1 if the condition is maskable, 0 if it is not. This is
defined at load time and should never be changed.
$skip
$para-7
Bit\9\=\1 if a masked condition is pending, 0 if it is not.
This byte is cleared at load time, when PENDING is called, or
when the condition is unmasked and signaled. It is set
if an exception occurs while the condition is masked.
$skip
$para-7
Bits\16..31\represent the masking count.
This is initialized to zero
at load time. It is incremented by a call to MASK and
decremented by a call to UNMASK. If it is zero, the
condition is not masked. If it is non-zero, the
condition is masked. If it is ever decremented below zero or
incremented over 2**16, a runtime error will occur.
$indent-12
$skip
The runtime exception manager contains a public symbol for each
standard condition. The public symbol is a value
used by the compiler and the runtime to uniquely identify each standard
condition. The runtime refers to this symbol when searching through
the handler branch table.
The value for the public condition is in the condition cell for each
standard condition.
See appendices C and D for specifications of the condition cells and
condition descriptors.
$skip
For each standard condition and sub-condition there is a
^Ucondition descriptor|U. The condition descriptor is only
used by the runtime. The condition descriptor contains
the following information:
$skip
$indent+8
$para-3
1.\The address of the standard
condition cell.
$skip
$para-3
2.\The sub-condition code.
$skip
$para-3
3.\An address of the unique message associated with this particular
sub-condition.
$skip
$para-3
4.\A flag indicating whether the program can continue after
this particular sub-condition occurs.
$indent -8
$skip
#SECT(Handler state block)
The handler state block is a 2-longword block used to store information
about the state of a handler. The handler state block contains the
following information:
$skip
$indent+8
$para-3
1.\An indication of whether or not the current handler is active.
This is an implicit value, i.e. if a exception address is present
the handler is active, if not, the handler is not active.
$skip
$para-3
2.\The address of where the exception occured, or the instruction
immediatly following the one where the exception occured.
$skip
$para-3
3.\The address of the condition cell for user-signaled conditions
or the address of the condition descriptor for standard conditions.
$indent-8
$skip
The handler state block is accessed via the handler branch
table. For exact offsets see section 3.4. The handler state
block is initialized by the routine PAX_EXC.SET. PAX_EXC.SET
is called at the start of the code controlled by a handler
clause. PAX_EXC.SET marks the handler state block as
"ready to handle a signaled condition".
For the specification of the handler state block see appendix B.
#SECT(Handler branch table)
The handler branch table is the compiler's representation of
the handler clause. The seventh word in the handler branch table
contains a self-relative address of the handler common entry code.
To invoke one of the handler's in the table, the runtime
exception manager loads the handlers address into R0, and
then branches to the common entry code, which cleans up the
program state -- "with" registers, for example -- and
branches to the handler address contained in R0.
$skip
The first two longwords in the handler branch table are
used to handle VAX hardware exceptional conditions, see section
2.1.4 for further information.
$skip
The fifth word in the handler branch table contains the
address of the next outer handler table in the same
procedure, or zero if there is none. This mechanism is maintained
by the Pascal compiler via the generated code.
The compiler activates handlers by calling the runtime
routines PAX_EXC.SET and PAX_EXC.RESTORE.
The calling sequences generated by the compiler for PAX_EXC.SET and
PAX_EXC.RESTORE are:
#BEGINFIGURE
^USET|U
PUSHAL    hbt
CALLS      #1,PAX_EXC.SET
$skip
^URESTORE|U
PUSHAL      hbt
CALLS      #1,PAX_EXC.RESTORE
#ENDFIGURE
The sixth word in the handler branch table contains the
offset from the current stack frame for the handler state block
(see section 3.3).
$skip
The ramainder of the table contains pairs of a longword self-relative
address followed by self-relative word address.
The longword in the pair contains a self-relative address of
a condition cell fur user-defined conditions, or a value assigned to
the standard condition.
The second word contains the handler address for the condition
specified in the first longword  address is simply the
self-relative
address of the code for the particular handler). The last pair
in the table indicate the default action that is
to be taken if none of the preceding condition addresses
matches the signaled condition. A longword containing all
the bits set indicates an others case. A longword with all the
bits except the zero bit set indicates an allconditions case.
The second word may contain a normal handler address, or
it may contain a zero, indicating that the condition is not
handled by this handler clause, and should be resignaled.
$skip
For format of the handler branch table see appendix A.
#ENDLEVEL
#SECT(Runtime exception handler)
The runtime exception manager consists of an exception intercept for
each standard condition, plus a central signal manager. Each
exception routine receives control when its exception occurs.
The exception routine does any exception-specific processing, and
then calls the central signal manager, "PAX_EXC.EXCEPT".
$skip
The central signal manager needs the following information:
$skip
$indent+8
$para-3
1.\The address where the exception occurred (actually the
address of the instruction immediately following the instruction
where the exception occurred).
$skip
$para-3
2.\The address of the condition cell for user-signaled exceptions,
or the address of the condition descriptor for standard conditions.
The condition descriptor contains the value of the standard condition,
an indication of the particular sub-condition, and an indication
whether the program can continue after the particular exception.
$skip
$indent-8
The calling sequence for PAX_EXC.EXCEPT is:
#BEGINFIGURE
For standard conditions:
$skip
$indent+3
PUSHL       <addr after exception>
PUSHAL  <condition descriptor>
CALLS   #2,PAX_EXC.EXCEPT
$indent-3
$skip
For user-signaled conditions:
$skip
$indent+3
PUSHL     <addr after exception>
PUSHL   <condition cell address>
CALLS #2,PAX_EXC.EXCEPT
$indent-3
$skip
To facillitate calling PAX_EXC.EXCEPT the following macro
can be used:
$skip
$indent+3
_EXCEPT <condition cell or descriptor addr>,-
 <addr after exception>
$indent-3
#ENDFIGURE
#BEGINLEVEL
#SECT(Determination of the active handler)
The handler branch table is always pointed to by the first
word in the procedure's
stack frame, i.e. 0(FP). All active handler clauses for a routine
can be located starting with the current handler branch table, and
then following the links through the third word of the handler
branch table (see appendix A). This chain of handler branch tables
may contain handler branch tables both for clauses which are
ready to handle a signaled condition, and
for handler clauses that are in-progress. The two kinds of handler
clauses may be distinguised by their handler state blocks
(see section 3.3).
$skip
The compiler must keep the handler branch table addresses current
by calling PAX_EXC.SET and PAX_EXC.RESTORE.
PAX_EXC.SET is called at the start of every handler clause.
It sets the current handler branch table address, and marks the
handler state block as "ready to handle a signaled condition".
PAX_EXC.RESTORE is called to remove the current handler branch table.
PAX_EXC.RESTORE has no effect on the handler state block.
PAX_EXC.RESTORE is called with one parameter, the address
of the replacing HBT. If there is no HBT to restore, the compiler
should call restore with a HBT address of zero.
$skip
The following steps are taken by PAX_EXC.EXCEPT to handle a condition:
$skip
$indent+8
$para-3
1.\Locate the active handler clause.
$skip
$para-3
2.\If there is no active handler clause for the proper condition, or
for the allconditions case, leave the procedure call stack intact, and
branch to the monitor via SYS$CLI system call.
$skip
$para-3
3.\Unwind the procedure call stack
to the first OTHERS, ALLCONDITION, or matching condition
handler. This can most easily be accomplished using the following
algorithm. Search through the procedure call stack looking for a 
match to the given condition. A match is defined as the condition
that is being handled or an allcondition. During this search,
remember the first others condition that is found. When the
search is finished we would either have found a matching condition
or not. If not, then exit the user's program using the
SYS$CLI system call. If a match is found, then unwind the
procedure call stack to the first matching condition and proceed.
Matching condition is defined as the first others, allcondition,
or specific condition handler that is found.
$para-3
$skip
4.\Load the address of the handler code into R0.
$skip
$para-3
4.\Branch to the common code for this handler block. The common
code will perform any necessary clean-up, 
and then jump to the code at the address contained in R0.
$indent-8
#SECT(Cases requiring special attention)
This section describes the exception conditions that have
special properties.
The [NO]UNDERFLOW exception is a property of a Pascal program on the
DEC-10. Attention exceptions are handled via asynchronous system
traps, and are acheived via QIO system calls.
#BEGINLEVEL
#SECT(Integer overflow)
Integer overflows are normally handled by seting the overflow bit in the
PSW. This allows for code to locally handle the integer overflow.
To allow the Pascal Exception handling mechanism to detect integer overflows,
the VAX provides a ficility which allows a program to specify that integer
overflows are to cause a hardware exception. Integer overflows will
generate hardware exceptions if the IV, integer overflow, bit is set in the
PSL. Unfortunately this bit in the PSL is cleared on every procedure called
via the CALLS or CALLG instruction. To insure that this bit is set after
a CALLS or CALLG instruction the VAX permits a program to provide an
initialization value for the IV bit in the procedure entry mask.
The compiler must set bit 14 in the procedure entry mask for all procedures
and functions. The runtime must also insure that the IV bit is set.
The runtime can accomplish this using the _ENTRY macro.
$skip
This modification means that any Pascal programs that once ran, even
though an integer overflow occured somewhere within the program, will
probably not run once this mechanism is installed.
#SECT(Underflow and NO-underflow)
The UNDERFLOW exception condition is not available on the VAX. To
support this on the VAX, every routine which performed floating
point arithmetic would have to set the FU, floating underflow,
bit in the PSW to a value specified by the compiler.
Also note that on the DEC-10 the default condition is that
underflow conditions will be signaled, whereas on the VAX floating
underflow conditions will never be signaled.
#SECT(Attention exceptions)
Attention interrupts will be handled via the VAX's asynchronous
system traps.
An AST routine will be declared at program initialization time.
This operation gives the address of a routine that will be called
when a control-C is entered from the keyboard. This routine
will then proceed to redeclare the AST routine for any subsequent
control-C's (AST's have their own internal mechanism which
prohibits an AST from being interrupted by another AST, i.e. built-in
protection).
$skip
A routine will be added to the VAX runtime that is called at
program initialization time to declare a control-C AST.
This means that even programs that do not have attention
handlers will trap control-C's.
$skip
Attention exceptions have two unique properties which necessitate
special consideration. First, since the attention exception is the
only exception that happens asynchronously there must be code
in the runtime which handles attentions exceptions that occur
during the processing of another attention. If an attention
exception occurs during the processing of another attention exception
the system should ignore the second exception, i.e. treat the
multiple exceptions as if only one exception was detected.
If the attention exception occurs during the processing of another
exception, let the exception override the first exception.
The second special attribute of attention exceptions
is that the system has a stak frame inserted between the routine that
was executing when the attention was signaled, and the runtime
routine that handles the attention exception. This system routine
must be completed or the sequencing of AST's becomes incorrect.
To handle this the routine that handles attention exceptions
insures that the system routine finishes processing by modifing
the return address of the system routine to be a label in the
runtime routine, and then returning to the system routine
so that it may finish its processing.
#ENDLEVEL
#SECT(Exceptions with sub-conditions)
The runtime exception manager simply handles sub-conditions
by storing the address of the condition descriptor in the
handler state block. The
routines which return sub-conditions simply refer to the handler
state block to return the desired sub-conditions.
Appendix F contains the declaration for the scalar types that comprise
the sub-conditions.
#SECT(Signaling of multiple conditions)
Multiple conditions are handled in one of two ways. If an
attention exception is in progress, then no other exception
will be honored. On the PDP-10 if an attention interrupt is
in progress, and another attention interrupt is triggered,
the program goes to the dot. This will not be possible on the
VAX because another attention AST will be delayed until the
first attention is completed. Also, attention interrupts are
the only exceptions that need to be masked.
Other multiple exceptions will be handled as they occur.
#SECT(Exception masking within the runtime)
Attention exceptions are the only exceptions that need to be masked.
Other exceptions should be handled using the general exception mechanism.
If the general MASK and UNMASK routines prove to be lengthy,
faster, more efficient routines can be written for the VAX runtime.
The runtime will call MASK(Attention) and UNMASK(Attention) with two
parameters instead of one. This is done so that the MASK and UNMASK
routines will know that they are being called by the runtime.
This is to provide for the runtime to handle exceptions via a non-local
goto mechanism. MASK and UNMASK, when called from within the runtime,
will save the value of the current attention mask count in
PAX_EXC.SAVMASK. When an error is handled via a non-local goto,
the runtime can restore the attention masking count by placing PAX_EXC.SAVMASK
into the attention condition cell and call MASK and UNMASK,
so that thing are restored, and any masked attentions are now honored.
#ENDLEVEL
#SECT(Interaction with Link Management)
There are only two restrictions concerning exception handling
and link management. First, all public conditions must be
defined within the resident portion of the code. Second, all
public conditions referenced from within an overlay must be defined
in the transfer vector for that overlay.
$skip
Since the condition cell for each user-defined condition contains
its own address, the compiler can access the symbol by simply
indirecting through the symbol. For the standard symbols the
compiler simply references the symbols in the shareable library.
#BEGINLEVEL
#SECT(User transfer vectors)
The transfer vectors for the user's program will only contain
references to user-defined conditions. Since user-defined
conditions contain thier own addresses, exceptional conditions will
immdiately function with the current link management system.
#SECT(VAX runtime transfer vectors)
Standard exceptions will always be linked into the program and
overlays from the sharable library. These symbols will simply be
values defined in the runtime transfer vector.
#SECT(Future versions of VMSRTL)
When VMS version 3.0 is released, the problem of defining base
addresses for the sharable libraries should be fixed. This may
have implications on exception handling as well as link management.
The issues will have to be addressed at that time.
#ENDLEVEL
#SECT(Future considerations)
This section deals with the changes that may become necessary
as changes are made to the VAX compiler.
#BEGINLEVEL
#SECT(The Pascal Debugger)
Since the debugger has not yet been designed, the exact implications
are unknown. The addition of a Pascal language debugger will
cause significant changes to both the VAX runtime and to
the stack frame of the Pascal program.
#SECT(Masking and unmasking)
It is known that the Pascal debugger will need special
protection from exceptional conditions. The attention condition
can be masked and unmasked where applicable, just like in the
VAX runtime. The debugger should not need to be protected from the
other types of conditions, but there will need to be some mechanism
to keep the Pascal debugger up to date with the changes that
will be made to the flow of the user's program. These will have to
be addressed when the debugger is designed.
#SECT(<:"Standard" Pascal:>)
As soon as there is a standard this document will probably change
to conform to that standard.
#ENDLEVEL
#APPENDIX(Appendix A - Format of Handler Branch Table)
#BEGINFIGURE
+--------+--------+--------+--------+
| JSB  "%xEF"     |    0   |    0   |
+--------+--------+--------+--------+
| Address of PAX_EXC.VAXCOND        |
+--------+--------+--------+--------+
| HSB offset (FP) | HBT rel. offset |
+--------+--------+--------+--------+
                  | Common code addr|
+--------+--------+--------+--------+
| Condition cell for exception A    |
+--------+--------+--------+--------+
                  | Addr of code for A, 0 if none
                  +--------+--------+
               .
             .
     "n" pairs of longword, word
   1 pair for each condition
     just like condition A above
           .
             .
+--------+--------+--------+--------+
|11111111 11111111 11111111 11111111| Others clause
+--------+--------+--------+--------+  Bit 0=0->allcondition
                  | Code addr, 0 -> RESIGNAL
                  +--------+--------+
#ENDFIGURE
In the above diagram, all entries not beginning at the left margin
are WORD values. All word values contain self-relative addresses.
$skip
The offset for the HSB is not self-relative, but rather FP relative.
$skip
For standard conditions, the value in the handler branch table is
the value assigned to the transfer vector symbol used by the compiler
and runtime to uniquely identify each standard condition (see appendix C).
#APPENDIX(Appendix B - Format of Handler State Block)
#BEGINFIGURE
^UUser-signaled condition|U
$skip
+--------+--------+--------+--------+
| Address of the exception.         |
+--------+--------+--------+--------+
| Condition cell address            |
+--------+--------+--------+--------+
$skip
^UFor standard conditions|U
$skip
+--------+--------+--------+--------+
| Address of the exception.         |
+--------+--------+--------+--------+
| Condition descriptor address.     |
+--------+--------+--------+--------+
#ENDFIGURE
Longword 1 contains the address of the instruction where the exception
occured (usually this will be the address of the instruction immediatly
following the instruction that was executing when the exception
occured).
$skip
Longword 2 contains the address of the condition cell for user-signaled
conditions and the address of the condition descriptor for standard
conditions.
$skip
The runtime exception manager will maintain the second longword
with the value of zero, indicating that the handler state block
is "ready to handle condition".
$skip
The runtime exception manager can determine which type of
exception, user vs. standard, by examining the value of the
second longword of the handler state block with the value
pointed to by the value of the second longword of the handler
state block. For user conditions, these values will be the
same. For standard conditions, these values will be different.
#APPENDIX(Appendix C - Standard condition cells)
#BEGINFIGURE
$para-5
A standard condition cell has the following format:
$skip
+--------+--------+--------+--------+
|   Mask  count   |      PM|Std. Val|
+--------+--------+--------+--------+
#ENDFIGURE
$skip
$indent+10
$para-5
Bits\0..7\contain the value of the public symbol used
to represent this standard condition.
$skip
$para-5
Bit\8\contains a 1 if this condition is maskable,
a 0 if the condition is not maskable.
$skip
$para-5
Bit\9\contains a 1 if a masked condition is pending,
0 if there is not a condition pending.
$skip
$para-5
Bits\16..31\contain the masking count.
$indent-10
$skip2
The following are the public symbols that the compiler
uses to refer to the standard condition cells. These values
are used to uniquely identify each of the standard conditions and to
insure that the runtime can determine whether a given condition is
user-defined or a standard condition.
$skip
#BEGINFIGURE
^UPascal symbol|U             ^URuntime Symbol|U              ^UValue|U
$skip
ATTENTION             PAX_EXC.ATTN            -3
IO_ERROR            PAX_EXC.IO              -4
MATH_ERROR          PAX_EXC.MATH            -5
PROGRAM_ERROR               PAX_EXC.USER            -6
SPECIAL_ERROR               PAX_EXC.SPEC            -7
STORAGE_OVERFLOW    PAX_EXC.STOR            -8
#ENDFIGURE
These symbols need to be defined as ^Uuniversal|U in the sharable VAX
runtime. To do this a linker directive is necessary.
#APPENDIX(Appendix D - Condition descriptors)
#BEGINFIGURE
$para-5
A condition descriptor has the following format:
$skip
+--------+--------+--------+--------+
| Address of Standard condition cell|
+--------+--------+--------+--------+
|  sub-condition  |        |       C|
+--------+--------+--------+--------+
| Address of message for sub-cond   |
+--------+--------+--------+--------+
#ENDFIGURE
$indent+10
$para-5
Longword\1\contains the address of the standard condition cell
for this class of exceptional conditions.
$skip
$para-5
Bit\0\of\longword\2\contains a 0 if the program may be continued
after this condition has been encountered, or a 1 of the program
may not be continued.
$para-5
$skip
Bits\16..31\of\longword\2\contain the scalar value for this
particular sub-condition.
$skip
$para-5
Longword\3\contains the address of the message for this particular
sub-condition. This is the address of the message that is printed when
EXCEPTION_MESSAGE is called.
$indent-10
#APPENDIX(Appendix E - Pascal routine entry points)
#BEGINFIGURE
^USource Code|U                    ^UCompiler output|U
$skip
SIGNAL (cond);                      PUSHAL  cond
                          CALLS   #1,PAX_EXC.SIGNAL
$skip
SIGNAL ();                    CALLS   #0,PAX_EXC.RESIGNAL
$skip
MASK (cond);                        PUSHAL  cond
                          CALLS   #1,PAX_EXC.MASK
$skip
UNMASK (cond);                  PUSHAL  cond
                          CALLS   #1,PAX_EXC.UNMASK
$skip
a := MASKED (cond);           PUSHAL  cond
                          CALLS   #1,PAX_EXC.TSTMASK
                            MOVB    R0,a
$skip
a := PENDING (cond);               PUSHAL  cond
                          CALLS   #1,PAX_EXC.TSTPEND
                            MOVB    R0,a
$skip
EXCEPTION_MESSAGE ();              CALLS   #0,PAX_EXC.MSG
$skip2
^UOther public entry points:|U
$skip
To initialize handler:           PUSHAL  hbt
                           CALLS   #1,PAX_EXC.SET
$skip
To restore handler:              PUSHAL  hbt
                           (PUSHL  #0, if no HBT)
                                CALLS   #1,PAX_EXC.RESTORE
$skip
a := EXIOSTATUS;             CALLS   #0,PAX_EXC.EXIOSTAT
                           MOVB    R0,a
$skip
a := PROGRAMSTATUS;                CALLS   #0,PAX_EXC.PROGSTAT
                           MOVB    R0,a
$skip
a := SPECIALSTATUS;                CALLS   #0,PAX_EXC.SPECSTAT
                           MOVB    R0,a
$skip
a := MATHSTATUS;           CALLS   #0,PAX_EXC.MATHSTAT
                           MOVB    R0,a
#ENDFIGURE
#APPENDIX(Appendix F - Machine Dependant Status Types)
#BEGINFIGURE
Type PROGRAM_STATUS = ( (* VAX PROGRAM_EXCEPTION type *)
      PROGRAM_OK,
   PROGRAM_ASSERTION,      (* FALSE arg to assert *)
     PROGRAM_CASE,           (* Case not found *)
  PROGRAM_COMPATIBILITY,  (* Array compat. error *)
     PROGRAM_FILE,           (* Unassociated file var *)
   PROGRAM_POINTER,        (* dereference of NIL ptr *)
  PROGRAM_SUBSTRING,      (* bad index or length *)
     PROGRAM_SUBSCRIPT,      (* subscript bounds *)
        PROGRAM_VALUE           (* subrange exceded *)
                );
$skip2
Type SPECIAL_STATUS = (     (* VAX SPECIAL_ERROR type *)
  SPECIAL_OK,
   SPECIAL_ILL_MEM_REF,    (* Addressing exception *)
    SPECIAL_ILL_INST,       (* NOT USED ON THE VAX *)
     SPECIAL_NEW_NEG,        (* NEW 0 or neg size *)
       SPECIAL_DISP_PTR,       (* Bad ptr to dispose *)
      SPECIAL_DISP_TWICE,     (* DISPOSE of freed ptr *)
    SPECIAL_SUCC_PRED,      (* Overflow/Underflow *)
      SPECIAL_VAX_INDEX       (* VAX index instruction *)
           );
$skip2
Type MATH_STATUS = (        (* VAX Math exceptions *)
     MATH_OK,
      MATH_FLT_UND,   (* NOT USED ON THE VAX *)
     MATH_FLT_OVF,   (* Floating overflow *)
       MATH_INT_OVF,   (* Integer overflow *)
        MATH_ZERO_DIVID,(* Division by zero *)
        MATH_ARG_ARCSIN,(* NOT USED ON THE VAX *)
     MATH_ARG_ARCCOS,(* NOT USED ON THE VAX *)
     MATH_SQRT_NEG,  (* Square root of negative val *)
     MATH_BAD_LOG,   (* 0 or neg log value *)
      MATH_BAD_ARG,   (* Bad argument to math routine *)
    MATH_LOST_SIGN  (* Lost significance, COS, SIN *)
             );
$skip2
Type IO_STATUS = (  (* VAX I/O Exceptions *)
      IO_OK,          (* No error condition *)
      IO_NOVF,        (* Arithmetic overflow *)
     IO_POVF,        (* Putstring overflow *)
      IO_DGIT,        (* Invalid numeric input *)
   IO_GOVF,        (* Getstring overflow *)
      IO_INTR,        (* Internal error in I/O System *)
    IO_REWR,        (* Rewrite required *)
        IO_EOF,         (* Attempt to read beyond EOF *)
      IO_OUTF,        (* Output failure *)
  IO_INPF,        (* Input failure *)
   IO_SEEK,        (* Seek on non-random file *)
 IO_ILLC,        (* Illegal cursor value *)
    IO_NEMP,        (* Can't empty file *)
        IO_OPNF         (* Association failure *)
             );
#ENDFIGURE
$skip2
Note that this type is just the DEC-10 type file expanded to contain
the VAX specific types. The DEC-10 specific types are simply
left as holes in the VAX implementation.
#APPENDIX(Appendix G - Internal exception handling routines)
$indent+17
$para-17
PAX_EXC.EXCEPT\\\General runtime exception manager. This routine is responsible
for handling the exception. Unwinding the stack, determining the proper
handler, recovery for the cases that are not handled.
$skip
$para-17
PAX_EXC.VAXCOND\\This routine is responsible for decoding the hardward
runtime condition into the Pascal exception condition, and calls
PAX_EXC.EXCEPT to have the condition handled.
$skip
$para-17
PAX_EXC.ESCAPE\\\This routine handles user-typed attentions. This routine
is responsible for declaring another attention AST, and calling
PAX_EXC.EXCEPT to have the condition handled.
$indent-17
#TOC
        ç