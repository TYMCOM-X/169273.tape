$DECAP ON
$NUMBER OFF
$BOTTOM 0
$CENTER
$SKIP 3
\$$$$$$$$$     $$$         $$$   $$$$$$$$$$\
\\$$     $$     $$$       $$$     $$      $\
\\$$      $$    $ $$     $ $$     $$      \\
\\$$      $$    $  $$   $  $$     $$      \\
\\$$     $$     $   $$ $   $$     $$   $  \\
\\$$$$$$$       $    $$    $$     $$$$$$  \\
\\$$            $          $$     $$   $  \\
\\$$            $          $$     $$      \\
\\$$            $          $$     $$      \\
\\$$            $          $$     $$      \\
\$$$$          $$$        $$$$   $$$$     \\
$SKIP 4
\\                                                  $$         \\
\\                                                  $$         \\
\$$$$   $$$     $$$$$ $   $$$$$$$$$$   $$$$$$$$$     $   $$$$$ $\
\\$$     $     $     $$    $$      $    $$     $$   $   $     $$\
\\$$     $    $       $    $$           $$      $$     $       $\
\\$$     $    $$           $$   $       $$     $$      $$      \\
\\$$     $     $$$$$$      $$$$$$       $$$$$$$$        $$$$$$ \\
\\$$     $      $$$$$$     $$   $       $$   $           $$$$$$\\
\\$$     $           $$    $$           $$    $               $$\
\\$$     $    $       $    $$           $$    $$       $       $\
\\ $$   $     $$     $     $$      $    $$    $$ $     $$     $\\
\\  $$$$      $ $$$$$     $$$$$$$$$$   $$$$    $$      $ $$$$$ \\
$SKIP 6
\\  $$$$$$ $   $$$$   $$$   $$$$$$   $$$$$$$$      $$$$$$$$$$\
\\ $$     $$    $$     $      $$      $$    $$      $$      $\
\\$$       $    $$     $      $$      $$     $$     $$      \\
\$$             $$     $      $$      $$      $$    $$   $  \\
\$$             $$     $      $$      $$      $$    $$$$$$  \\
\$$   $$$$$$$   $$     $      $$      $$      $$    $$   $  \\
\$$       $$    $$     $      $$      $$      $$    $$      \\
\\$$      $$    $$     $      $$      $$     $$     $$      \\
\\ $$    $$$     $$   $       $$      $$    $$      $$      $\
\\  $$$$$$ $      $$$$      $$$$$$   $$$$$$$$      $$$$$$$$$$\
$VERBATIM
$SKIP 5
*PREPARED BY:  *R. *N. *FAIMAN
*LAST *UPDATED:  28 *APRIL 1978
@PMF@ *VERSION 1.1
$BOTTOM 6
$TITLE LEFT '@PMF USER''S GUIDE@                                                *PAGE I'
$FOOTNOTE LEFT '28 *APRIL 1978'
$PAGE
$SKIP 3
$CENTER
@TABLE OF CONTENTS@
$VERBATIM
$SKIP 2
$TAB 69

0.   *INTRODUCTION	 1

1.   *INTRODUCTORY *EXAMPLES	 1
1.1     *SIMPLE *TEXT *SUBSTITUTION WITH #@LITERAL@	 1
1.2     *PARAMETERIZED *DEFINITIONS WITH #@DEFINE@	 2
1.3     *NESTED *MACRO AND *LITERAL *CALLS	 2
1.4     *NESTED *MACRO AND *LITERAL *DEFINITIONS	 3

2.   *MACRO *PROCESSING *DESCRIPTION	 4
2.1     *TOKENS	 4
2.2     *THE *SCANNING *ALGORITHM	 4
2.3     *MACRO *CALLS AND *ARGUMENTS *LISTS	 4

3.   *MACRO *DEFINITION	 6
3.1     #@DEFINE@ (NAME,PARM-1,...PARM-N,DEFINITION)	 6
3.2     #@LITERAL@ (NAME,DEFINITION)	 7
3.3     #@OPSYN@ (NAME-1,NAME-2)	 7
3.4     #@UNDEF@ (NAME)	 8
3.5     #@ASSIGN@ (NAME,PARM-1,...PARM-N,DEFINITION)	 9
3.6     #@SAVE@ (FILE-NAME)	 9
3.7     #@LIB@ (FILE-NAME)	 9

4.   *ADVANCED *TECHNIQUES	10
4.1     *MARKING *PARAMETERS WITH |	11
4.2     *SEPARATING *TOKENS WITH &&	11
4.3     *INPUT *LINE *CONTINUATION WITH &&	12
4.4     *TEXT *QUOTATION WITH <: AND :>	12
4.5     *EVALUATED *ARGUMENTS WITH "	12

5.   *NUMERIC AND *STRING *OPERATIONS	15
5.1     #@NUM@ (EXPRESSION)	15
5.2     #@STR@ (TEXT)	15
5.3     #@LENGTH@ (TEXT)	16
5.4     #@SUBSTR@ (TEXT,IND,LEN)	17
5.5     #@INDEX@ (TEXT,TARGET,DEFAULT)	17
5.6     #@VERIFY@ (TEXT,CHARS,DEFAULT)	17
5.7     #@SEARCH@ (TEXT,CHARS,DEFAULT)	17
5.8     #@UPC@ (TEXT) AND #@LWC@ (TEXT)	17

6.   *CONDITIONAL *MACRO *EXPANSION	18
6.1     #@IF@ (TEST,THEN-VALUE,ELSE-VALUE)	18
6.2     #REL*N (NUM-1,NUM-2) -- *NUMERIC *PREDICATES	18
6.3     #REL*C (STR-1,STR-2) -- *STRING *PREDICATES	18
6.4     #@AND@ (P1,P2,...PN)	19
6.5     #@OR@ (P1,P2,...PN)	19
6.6     #@NOT@ (P)	19
$TITLE LEFT '@PMF USER''S GUIDE@                                               *PAGE II'
$PAGE
$CENTER
@TABLE OF CONTENTS@ (*CONTINUED)
$VERBATIM
$SKIP 2
7.   *MISCELLANEOUS	20
7.1     #@EVAL@ (STRING)	20
7.2     #@ERROR@ (MESSAGE)	20
7.3     #@MACRO@ (NAME)	20
7.4     *ASSORTED *NOTES	20
$SKIP 1
8.   *OPERATING *INSTRUCTIONS	21
8.1     /@MACRO@	21
8.2     /@COMPILE@:OPTIONS	22
8.3     /@PASCAL@	22
8.4     /@LIB@:FILE	23
8.5     /@SAVE@:FILE	23
8.6     /@DUMP@:DUMP DESCRIPTOR LIST	24
8.7     /@SET@:SWITCH:VALUE	24
8.8     /@EXIT@	24
$SKIP 1
9.   *ERROR *HANDLING	25
9.1     *COMMAND *ERRORS	25
9.2     *MACRO *PROCESSING *ERRORS	25
9.3     *USING THE /@DUMP@ *SWITCH	27
$NUMBER 1
$TITLE LEFT ''
$FOOTNOTE '28 *APRIL 1978                                    *INTRODUCTORY *EXAMPLES'
$TOP 3
$PAGE
$CENTER
&*U S E R& ' &S   *G U I D E   T O   @P M F@& - -
$SKIP 1
&*A   *P A S C A L   *M A C R O   *F A C I L I T Y&
$TITLE LEFT '@PMF USER''S GUIDE@                                               *PAGE \'
$TOP 6
$JUSTIFY
$SKIP 3
0.\\&*INTRODUCTION&
$SKIP 1
$PARA 5
@PMF@ IS A PROGRAM WHICH PERFORMS MACRO-PROCESSING ON *PASCAL SOURCE FILES.
*THIS DOCUMENT PROVIDES AN INTRODUCTION TO THE FEATURES AND USES OF @PMF@.
$SKIP 1
$PARA 5
@PMF@ READS A FILE CONTAINING *PASCAL SOURCE TEXT, MACRO DEFINITIONS, AND MACRO
CALLS.  *IT PRODUCES AN OUTPUT FILE, WHICH IS A COPY OF THE INPUT FILE WITH ALL
THE MACRO CALLS EXPANDED.
$SKIP 2
1.\\&*INTRODUCTORY *EXAMPLES&
$SKIP 1
1.1\\&*SIMPLE *TEXT *SUBSTITUTION WITH #@LITERAL@&
$SKIP 1
$PARA 5
*LITERALS ARE A SPECIAL CLASS OF MACROS WHICH NEVER TAKE PARAMETERS.  *LITERAL
DEFINITIONS ALLOW THE REPLACEMENT OF A SYMBOL BY AN ARBITRARY STRING OF TEXT
WHEREVER IT OCCURS IN THE PROGRAM (EXCEPT IN COMMENTS OR LITERAL STRINGS).
*A LITERAL IS DEFINED WITH THE #@LITERAL@ SYSTEM MACRO. (*A SYSTEM MACRO IS
SIMPLY A MACRO WHICH IS DEFINED BY @PMF@.)\  *A CALL TO #@LITERAL@ HAS THE
FORMAT:
$SKIP 1
$PARA 5
#@LITERAL@ (NAME,DEFINITION)
$SKIP 1
*FOR EXAMPLE, SUPPOSE THE INPUT FILE CONTAINS:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
TYPE COLORS = ( RED, ORANGE, YELLOW, GREEN,
                BLUE, INDIGO, VIOLET );
#LITERAL (PRIMARIES,[RED,BLUE,GREEN])

VAR
    INT_COLOR, EXT_COLOR: COLORS;
...
  IF INT_COLOR IN PRIMARIES THEN
    EXT_COLOR := EXT_COLOR - PRIMARIES;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THEN THE OUTPUT FILE WILL CONTAIN:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
TYPE COLORS = ( RED, ORANGE, YELLOW, GREEN,
                BLUE, INDIGO, VIOLET );

VAR
    INT_COLOR, EXT_COLOR: COLORS;
...
  IF INT_COLOR IN [RED,BLUE,GREEN] THEN
    EXT_COLOR := EXT_COLOR - [RED,BLUE,GREEN];
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$PAGE
1.2\\&*PARAMETERIZED *DEFINITIONS WITH #@DEFINE@&
$SKIP 1
$PARA 5
*THE PROBLEM WITH LITERAL DEFINITIONS IS THAT A LITERAL PRODUCES EXACTLY THE
SAME TEXT EACH TIME IT IS CALLED.  *IN MANY CASES, WE WOULD LIKE TO PRODUCE
A STRING OF TEXT, PARTS OF WHICH VARY EACH TIME IT IS CALLED.  *THIS CAN BE
ACCOMPLISHED BY DEFINING A MACRO.  *A MACRO, LIKE A LITERAL, IS REPLACED BY
A STRING OF TEXT WHEREVER IT OCCURS IN THE PROGRAM.  *HOWEVER, A MACRO CALL
MAY ALSO TAKE A LIST OF ARGUMENTS, WHICH WILL BE INSERTED AT SELECTED POINTS
IN THE REPLACEMENT TEXT.  *MACROS ARE DEFINED WITH THE #@DEFINE@ SYSTEM MACRO,
WHICH IS CALLED WITH THE FORMAT:
$SKIP 1
$PARA 5
#@DEFINE@ (NAME,PARM-1,...PARM-N,DEFINITION)
$SKIP 1
*FOR EXAMPLE, SUPPOSE THE INPUT FILE CONTAINS:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (INCREMENT,X,Y,X := X + Y)
...
  IF ACCEPTABLE THEN
    INCREMENT (COUNTER,1)
  ELSE
    INCREMENT (COUNTER,DEL_CTR);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THEN THE OUTPUT FILE WOULD CONTAIN:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
  IF ACCEPTABLE THEN
    COUNTER := COUNTER + 1
  ELSE
    COUNTER := COUNTER + DEL_CTR;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 2
1.3\\&*NESTED *MACRO AND *LITERAL *CALLS&
$SKIP 1
$PARA 5
*MACRO AND LITERAL CALLS MAY BE NESTED IN THE DEFINITIONS OF OTHER MACROS AND
LITERALS.  *FOR EXAMPLE,
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#LITERAL (ONE,1)
#DEFINE  (INCREMENT,X,Y,X := X + Y)
#DEFINE  (BUMP,X,INCREMENT (X,ONE))
...
  I := ONE;
...
  IF ACCEPTABLE THEN
    BUMP (GOOD_COUNT)
  ELSE
    INCREMENT (BAD_COUNT,BAD_INCR);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$PAGE
*THIS CODE WOULD EXPAND TO:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
  I := 1;
...
  IF ACCEPTABLE THEN
    GOOD_COUNT := GOOD_COUNT + 1
  ELSE
    BAD_COUNT := BAD_COUNT + BAD_INCR;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
$PARA 5
*IT IS POSSIBLE TO INCLUDE A MACRO CALL IN THE ARGUMENT LIST OF ANOTHER MACRO
CALL.
*THIS IS A SOMEWHAT MORE ADVANCED TECHNIQUE, AND IS DISCUSSED IN SECTION 4.5
(*EVALUATED *ARGUMENTS WITH ").
$SKIP 2
1.4\\&*NESTED *MACRO AND *LITERAL *DEFINITIONS&
$SKIP 1
$PARA 5
*MACRO AND LITERAL DEFINITIONS MAY ALSO CONTAIN THE DEFINITIONS OF OTHER MACROS
OR LITERALS.  *FOR EXAMPLE,
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (DEF_IDENT,MAC,A,#LITERAL (MAC,A IS A))
DEF_IDENT (IDENT_A,A)
DEF_IDENT (IDENT_A2,=IDENT_A=)
DEF_IDENT (IDENT_B,BUSINESS)
...
IDENT_A
IDENT_A2
IDENT_B
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THIS WOULD PRODUCE AN OUTPUT FILE CONTAINING:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
A IS A
=A IS A= IS =A IS A=
BUSINESS IS BUSINESS
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$PAGE
$FOOTNOTE '28 *APRIL 1978                             *MACRO *PROCESSING *DESCRIPTION'
2.\\&*MACRO *PROCESSING *DESCRIPTION&
$SKIP 1
2.1\\&*TOKENS&
$SKIP 1
$PARA 5
*THE INPUT TO @PMF@ IS MADE UP OF TOKENS.  *TOKENS ARE ALPHANUMERIC
SYMBOLS, *PASCAL LITERAL CHARACTER STRINGS, *PASCAL COMMENTS, AND ALL OTHER
INDIVIDUAL CHARACTERS OF THE SOURCE PROGRAM.  *ALL MACRO PROCESSING IS
PERFORMED AT THE TOKEN LEVEL--@PMF@ NEVER LOOKS "INSIDE" A TOKEN.  *FOR
EXAMPLE, SUPPOSE A MACRO NAMED "@THIS@" HAS BEEN DEFINED.  *THEN IF THE SYMBOL
"@THIS@" IS SEEN IN THE SOURCE TEXT, IT WILL BE RECOGNIZED AS A MACRO CALL.
*HOWEVER, IF THE SAME SYMBOL OCCURS IN A LITERAL STRING ('@THIS IS IT@') OR IN
A COMMENT @(* READ THIS LINE *)@, IT WON'T BE EXPANDED, SINCE IT WON'T
BE RECOGNIZED AS A DISTINCT TOKEN.  *SIMILARLY, "@THIS@" WILL NOT BE
RECOGNIZED IN THE TOKEN "@THIS_ONE@", OR IN THE PAIR OF TOKENS "@TH@", "@IS@".
$SKIP 1
$PARA 5
*LITERAL CHARACTER STRINGS AND COMMENTS ARE RECOGNIZED ACCORDING TO THE *PASCAL
RULES.  *SYMBOLS ARE THE SAME AS IN *PASCAL, EXCEPT THAT THE CHARACTER '#' IS
TREATED AS AN ALPHANUMERIC CHARACTER AND MAY OCCUR ANYWHERE IN A SYMBOL.
*SUCH SYMBOLS ARE MEANINGFUL ONLY TO THE MACRO PROCESSOR, OF COURSE--*PASCAL
STILL WON'T RECOGNIZE THEM.  *THIS EXTENSION WAS ALLOWED PRIMARILY SO THAT MACRO
NAMES (PARTICULARLY SYSTEM MACRO NAMES) COULD BE DEFINED WHICH COULD NOT
POSSIBLY CONFLICT WITH THE SYMBOLS IN ANY *PASCAL PROGRAM.
$SKIP 1
$PARA 5
@PMF@ CAN ALSO BE RUN IN A "NON-*PASCAL" MODE.
*IN THIS MODE, THE RULES FOR RECOGNIZING SYMBOLS ARE THE SAME.
*LITERAL CHARACTER STRINGS AND COMMENTS ARE NOT RECOGNIZED, HOWEVER.
*THAT IS, IN NON-*PASCAL MODE, THE SINGLE QUOTE MARK IS JUST AN ORDINARY
CHARACTER, AND A LEFT PARENTHESIS FOLLOWED BY AN ASTERISK HAS NO SPECIAL
SIGNIFICANCE.
*NON-*PASCAL MODE IS USEFUL WHEN @PMF@ IS BEING USED WITH TEXT FILES OTHER
THAN *PASCAL SOURCE FILES.
*FOR EXAMPLE, A DOCUMENTATION FILE FOR INPUT TO @SCRIBE@ WILL PROBABLY
CONTAIN APOSTROPHES USED AS APOSTROPHES, RATHER THAN AS QUOTES.
$SKIP 1
$PARA 5
@PMF@ REGARDS THE END OF A TEXT LINE AS A DISTINCT CHARACTER.  *THIS
CHARACTER (REFERRED TO BELOW AS A NEW-LINE) IS TREATED LIKE ANY OTHER
CHARACTER DURING THE MACRO PROCESSING, AND IS ULTIMATELY CONVERTED BACK
TO THE END OF A TEXT LINE IN THE OUTPUT FILE.
$SKIP 2
2.2\\&*THE *SCANNING *ALGORITHM&
$SKIP 1
$PARA 5
*THE BASIC RULE USED BY THE @PMF@ PROCESSOR IS VERY SIMPLE.
@PMF@ COPIES THE INPUT FILE TO THE OUTPUT FILE.
*WHENEVER @PMF@ FINDS A MACRO CALL OR A LITERAL NAME IN THE INPUT FILE, IT
LOOKS UP THE MACRO OR LITERAL DEFINITION.
@PMF@ THEN REPLACES THE CALL BY ITS DEFINITION, AND CONTINUES COPYING
THE INPUT FILE, &STARTING AT THE BEGINNING OF THE REPLACED TEXT&.
(@PMF@ DOESN'T ACTUALLY CHANGE THE CONTENTS OF THE INPUT FILE, OF COURSE, BUT
THE EFFECT IS AS THOUGH IT WERE TO REMOVE THE CALL, REPLACE IT WITH THE
DEFINITION, BACKSPACE THE FILE TO THE BEGINNING OF THE DEFINITION, AND
CONTINUE COPYING.)
$PAGE
2.3\\&*MACRO *CALLS AND *ARGUMENT *LISTS&
$SKIP 1
$PARA 5
*A MACRO CALL
CONSISTS OF THE NAME OF A MACRO, OPTIONALLY FOLLOWED BY AN ARGUMENT
LIST.  *IF THE MACRO NAME IS FOLLOWED BY AN ARGUMENT LIST, THEY MAY BE
SEPARATED BY ANY NUMBER OF SPACES, NEW-LINES, OR COMMENTS.  (*NOTE THAT THIS IS
THE SAME AS THE RELATION BETWEEN A PROCEDURE OR FUNCTION NAME AND ITS PARAMETER
LIST IN *PASCAL.)\ *ANY SPACING OR COMMENTS BETWEEN A MACRO NAME AND ITS
ARGUMENT LIST ARE DISCARDED, I.E., ARE NOT COPIED TO THE OUTPUT FILE.
$SKIP 1
$PARA 5
*AN ARGUMENT LIST CONSISTS OF AN OPENING PARENTHESIS OR BRACKET ('(' OR '['),
FOLLOWED BY ANY NUMBER OF ARGUMENTS SEPARATED BY COMMAS (','), FOLLOWED BY A
CLOSING PARENTHESIS OR BRACKET (')' OR ']').  *AN ARGUMENT MAY BE ANY STRING
OF CHARACTERS WHICH DOES NOT CONTAIN A COMMA OR A RIGHT PARENTHESIS OR
BRACKET.  *ACTUALLY, @PMF@ COUNTS PARENTHESES AND BRACKETS, SO AN ARGUMENT
STRING MAY CONTAIN RIGHT PARENTHESES AND BRACKETS, IF THEY ARE MATCHED
WITH PRECEDING LEFT PARENTHESES AND BRACKETS, AND IT MAY CONTAIN COMMAS,
IF THEY ARE ENCLOSED BETWEEN MATCHING PARENTHESES OR BRACKETS.
*FOR EXAMPLE, CONSIDER THE ARGUMENT LIST:
$SKIP 1
$PARA 5
@(F(X),P(A,B[1,7],C),,3)@
$SKIP 1
*THIS LIST CONTAINS FOUR ARGUMENTS:  @"F(X)", "P(A,B[1,7],C)"@, "", AND "3".
$SKIP 1
$PARA 5
*THE ARGUMENT LIST IN A MACRO CALL IS NOT SUBJECT TO THE SAME PROCESSING
AS THE REST OF THE INPUT TEXT TO @PMF@.
*WHEN @PMF@ SEES THE OPENING PARENTHESIS OF AN ARGUMENT LIST, IT STARTS SIMPLY
SAVING THE ARGUMENTS, PAYING ATTENTION ONLY TO PARENTHESES, BRACKETS, AND
COMMAS.
*FOR EXAMPLE, IN THE DEFINITION OF @DEF_IDENT@ IN SECTION 1.4, THE CALL
TO THE SYSTEM MACRO #@LITERAL@ IS NOT EXPANDED WHEN IT IS FOUND IN THE
ARGUMENT LIST TO #@DEFINE@.
*ITS EXPANSION IS DELAYED UNTIL THE @DEF_IDENT@ MACRO IS CALLED AND SCANNING
IS CONTINUED AT THE BEGINNING OF THE REPLACEMENT TEXT.
$SKIP 1
$PARA 5
*ANY COMMENTS WITHIN AN ARGUMENT LIST ARE SIMPLY DISCARDED.
*THIS ALLOWS YOY TO INCLUDE EXPLANATORY COMMENTS IN A MACRO DEFINITION,
FOR EXAMPLE, AND NOT HAVE THEM INCLUDED IN THE EXPANSION OF THE MACRO.
$FOOTNOTE '28 *APRIL 1978                                         *MACRO *DEFINITION'
$PAGE
3.\\&*MACRO *DEFINITION&
$SKIP 1
$PARA 5
*THIS SECTION DISCUSSES THE VARIOUS SYSTEM MACROS FOR MANIPULATING MACRO
DEFINITIONS.  *THE 'NAME' AND 'PARM' ARGUMENTS TAKEN BY THESE MACROS MUST BE
ALPHANUMERIC SYMBOLS NO MORE THAN 40 CHARACTERS LONG.  *THESE 'NAME' AND 'PARM'
ARGUMENTS MAY HAVE LEADING AND/OR TRAILING SPACES OR NEW-LINES, BUT THERE MAY
NOT BE ANY SPACING IN THE SYMBOL ITSELF, NOR MAY THE ARGUMENT CONTAIN ANY
SPECIAL CHARACTERS.  *FOR EXAMPLE, THE FOLLOWING WOULD ALL BE LEGAL NAME
ARGUMENTS IN A CALL TO THE @#DEFINE@ MACRO:
$SKIP 1
$INDENT LEFT 5
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (MACRO_1,....
#DEFINE (#USER_MAC,...
#DEFINE (    TEST ,...
#DEFINE (
    A23 ,...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$INDENT LEFT -5
$SKIP 1
*THE FOLLOWING NAME ARGUMENTS ALL HAVE ERRORS:
$SKIP 1
$INDENT LEFT 5
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (25,...
#DEFINE (NAME-2,...
#DEFINE (LOAD IT,...
#DEFINE (FOO=,...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$INDENT LEFT -5
$SKIP 1
$PARA 5
*THE MACROS DESCRIBED IN THIS SECTION ARE IMPORTANT FOR THEIR SIDE EFFECTS
(I.E., THEIR EFFECTS
ON THE MACRO DEFINITION TABLE) RATHER THAN FOR THE TEXT THEY EXPAND INTO.
*THEREFORE, WHEN A DEFINITION MACRO IS EXPANDED, IT IS SIMPLY REPLACED BY THE
EMPTY STRING (I.E., NO CHARACTERS).
$SKIP 2
3.1\\&#@DEFINE@ (NAME,PARM-1,...PARM-N,DEFINITION)&
$SKIP 1
$PARA 5
#@DEFINE@ IS USED TO DEFINE A PARAMETERIZED MACRO.
'*NAME' IS THE NAME OF THE MACRO BEING DEFINED.
'*PARM-1' THROUGH 'PARM-N' (N MAY BE ZERO) ARE THE DUMMY PARAMETER NAMES
FOR THE MACRO DEFINITION.
'*DEFINITION' IS A TEXT STRING WHICH IS TO BE STORED AS THE MACRO DEFINITION.
*BEFORE THE DEFINITION IS STORED, ANY OCCURRENCES OF PARAMETER NAMES IN THE
DEFINITION TEXT ARE REPLACED BY ARGUMENT SUBSTITUTION MARKERS, WHICH WILL
BE REPLACED BY THE ACTUAL ARGUMENTS WHEN THE MACRO IS CALLED.
*THE PARAMETER NAMES ARE NOT STORED AS PART OF THE MACRO DEFINITION.
$PARA 5
*A MACRO NEED NOT BE CALLED WITH THE SAME NUMBER OF PARAMETERS IT WAS
DEFINED WITH.
*IF THERE ARE TOO MANY ARGUMENTS IN AN ARGUMENT LIST, THE EXCESS ONES
ARE IGNORED.
*IF THERE ARE TOO FEW ARGUMENTS, ANY MISSING ONES ARE SET TO "".
*IF A MACRO IS CALLED WITHOUT AN ARGUMENT LIST, ALL OF ITS ARGUMENTS ARE SET 
TO "".
$PAGE
3.2\\&#@LITERAL@ (NAME,DEFINITION)&
$SKIP 1
$PARA 5
#@LITERAL@ IS USED TO DEFINE LITERALS, THAT IS, MACROS THAT NEVER TAKE AN
ARGUMENT LIST.  *ACTUALLY, THE CALL FORMAT FOR #@LITERAL@ IS EXACTLY THE
SAME AS THAT FOR #@DEFINE@, AND ALL THE COMMENTS ABOUT #@DEFINE@ APPLY
EQUALLY WELL HERE, EXCEPT THAT LITERALS NEVER TAKE ARGUMENT LISTS.
*ACTUALLY, IT WOULD BE PERFECTLY LEGAL TO DEFINE A LITERAL WITH PARAMETERS.
*HOWEVER, ALL THE PARAMETERS WOULD ALWAYS BE THE EMPTY STRING, SO IT WOULD
BE A POINTLESS EXERCISE.
$SKIP 1
$PARA 5
*IN MOST CASES, A MACRO DEFINED WITH NO PARAMETERS WILL BEHAVE THE SAME AS
A LITERAL.
*FOR AN EXAMPLE OF A CASE IN WHICH THEY WILL NOT BEHAVE THE SAME, CONSIDER
AN ATTEMPT TO USE A MACRO DEFINITION TO CHANGE A PROCEDURE NAME WHEREVER
IT OCCURS.
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (PROC,NEW_NAME)
...
  PROC (A,B,C);
...
#LITERAL (PROC,NEW_NAME)
...
  PROC (A,B,C);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THESE TWO CALLS WOULD BE EXPANDED DIFFERENTLY:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
  NEW_NAME;
...
...
  NEW_NAME (A,B,C);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*WHEN "@PROC@" WAS A LITERAL, THE SYMBPROC@" WAS SIMPLY REPLACED BY ITS
DEFINITION, "@NEW_NAME@", WHICH WAS WHAT WE WANTED.
*HOWEVER, WHEN "@PROC@" WAS A MACRO, IT TOOK "@(A,B,C)@" AS AN ARGUMENT LIST
(REMEMBER THAT A MACRO MAY BE CALLED WITH MORE ARGUMENTS THAN IT NEEDS), SO
THE ENTIRE CALL "@PROC (A,B,C)@" WAS REPLACED BY "@NEW_NAME@".
$SKIP 2
3.3\\&#@OPSYN@ (NAME-1,NAME-2)&
$SKIP 1
$PARA 5
#@OPSYN@ IS USED TO GIVE 'NAME-1' A COPY OF THE DEFINITION OF 'NAME-2'.
*FOR EXAMPLE, BY CALLING "#@OPSYN\(MY_DEF,#DEFINE)@", @MY_DEF@ COULD BE
MADE EQUIVALENT TO #@DEFINE@.
#@DEFINE@ COULD THEN BE REDEFINED, LEAVING @MY_DEF@ TO PERFORM #@DEFINE@'S
ORIGINAL FUNCTION.
#@OPSYN@ IS &NOT& THE SAME AS #@LITERAL@.
*AFTER A CALL '#@OPSYN(A,B)@', ANY CALLS ON '*A' WILL BE EXPANDED ACCORDING
TO THE DEFINITION '*B' HAD AT THE TIME OF THE #@OPSYN@ CALL.
*AFTER A CALL '#@LITERAL(A,B)@', ON THE OTHER HAND, ANY REFERENCES TO '*A' WILL
BE REPLACED BY '*B', WHICH WILL BE EXPANDED ACCORDING TO ITS MOST RECENT
DEFINITION.
*THIS IS ILLUSTRATED IN THE FOLLOWING TWO EXAMPLES:
$PAGE
$INDENT LEFT +5
$VERBATIM
$TAB 35
$DECAP OFF
#OPSYN (DEF,#DEFINE)	#LITERAL (DEF,#DEFINE)
#DEFINE (#DEFINE,X,Y,X := Y)	#DEFINE (#DEFINE,X,Y,X := Y)
...	...
DEF (PUT_LINE,WRITELN)	DEF (PUT_LINE,WRITELN)
...	...
PUT_LINE;	PUT_LINE;
...	...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THE EXPANSIONS OF THESE EXAMPLES WOULD BE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...	...
...	PUT_LINE := WRITELN
WRITELN;	...
...	PUT_LINE;
	...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 2
3.4\\&#@UNDEF@ (NAME)&
$SKIP 1
$PARA 5
#@UNDEF@ WILL REMOVE THE CURRENT DEFINITION OF THE SYMBOL 'NAME', LEAVING
THINGS AS THEY WERE BEFORE 'NAME' WAS LAST DEFINED.
*IF 'NAME' IS NOT A MACRO OR LITERAL NAME, THEN #@UNDEF@ WON'T DO ANYTHING.
$SKIP 1
$PARA 5
*WHEN #@DEFINE@ OR #@LITERAL@ IS USED TO DEFINE A SYMBOL WHICH ALREADY HAS
A DEFINITION, THE OLD DEFINITION IS NOT LOST.
*THE NEW DEFINITION TAKES ITS PLACE, BUT IF THE NEW DEFINITION IS EVER
REMOVED WITH #@UNDEF@, THE OLD DEFINITION WILL ONCE AGAIN TAKE EFFECT.
*IN FACT, IT IS POSSIBLE TO STACK UP ANY NUMBER OF DEFINITIONS FOR A SYMBOL
IN THIS WAY.
$SKIP 1
*EXAMPLE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
MACRO
#DEFINE (MACRO,OLD MAC)
MACRO
#DEFINE (MACRO,NEW MAC)
MACRO
#UNDEF (MACRO)
MACRO
#UNDEF (MACRO)
MACRO
#UNDEF (MACRO)
MACRO
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*EXPANSION:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
MACRO
OLD MAC
NEW MAC
OLD MAC
MACRO
MACRO
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$PAGE
3.5\\&#@ASSIGN@ (NAME,PARM-1,...,PARN-N,DEFINITION)&
$SKIP 1
$PARA 5
*IN SOME CASES, YOU MAY WANT TO REPLACE THE CURRENT DEFINITION OF A SYMBOL WITH
A NEW ONE, RATHER THAN STACKING THE NEW DEFINITION ON TOP OF THE OLD ONE AS
WITH #@DEFINE@ OR #@LITERAL@.
*THIS CAN BE ACCOMPLISHED WITH #@ASSIGN@, WHICH DELETES THE CURRENT DEFINITION
OF A MACRO OR A LITERAL AND SAVES A NEW DEFINITION IN ITS PLACE.
#@ASSIGN@ CAN BE USED TO REDEFINE EITHER A MACRO OR A LITERAL, BUT ITS 'NAME'
ARGUMENT MUST HAVE SOME EXISTING DEFINITION TO BE REPLACED.
$SKIP 2
3.6\\&#@SAVE@ (FILE-NAME,TEXT)&
$SKIP 1
$PARA 5
*THE 'FILE-NAME' PARAMETER MUST BE A LEGAL *DEC-10 FILE NAME.
*IF THE EXTENSION IS OMITTED, '.@PML@' WILL BE USED.
*IF THE 'FILE-NAME' PARAMETER IS OMITTED, THE NAME OF THE @PMF@ OUTPUT FILE
WITH AN EXTENSION OF '.@PML@' WILL BE USED (SEE SECTION 9).
*THE #@SAVE@ MACRO WILL WRITE ALL THE CURRENT NON-SYSTEM MACRO DEFINITIONS
OUT ONTO THE SPECIFIED FILE, SO THAT THEY CAN BE USED IN THE PROCESSING OF
SOME OTHER SOURCE FILE.
*THE 'TEXT' PARAMETER IS OPTIONAL.
*IF IT IS NOT OMITTED, THEN THE SPECIFIED TEXT WILL ALSO BE WRITTEN TO THE
LIBRARY FILE, FOR INCLUSION IN SOME OTHER SOURCE FILE.
$SKIP 2
3.7\\&#@LIB@ (FILE-NAME)&
$SKIP 1
$PARA 5
*THE 'FILE-NAME' PARAMETER MUST BE A LEGAL *DEC-10 FILE NAME.
*IF THE EXTENSION IS OMITTED, '.@PML@' WILL BE USED.
*IF THE 'FILE-NAME' PARAMETER IS OMITTED, THE NAME OF THE @PMF@ OUTPUT FILE
WITH AN EXTENSION OF '.@PML@' WILL BE USED (SEE SECTION 9).
#@LIB@ WILL READ THE SPECIFIED @PMF@ LIBRARY FILE, WHICH MUST HAVE BEEN
CREATED BY THE #@SAVE@ MACRO, AND WILL DEFINE ALL THE MACROS AND LITERALS
FROM THE FILE SO THAT THEY CAN BE USED IN THE CURRENT SOURCE FILE.
*IF A 'TEXT' PARAMETER WAS INCLUDED IN THE #@SAVE@ CALL THAT CREATED THE
LIBRARY FILE, THEN THE #@LIB@ MACRO CALL WILL BE REPLACED BY A COPY OF
THE 'TEXT' PARAMETER FROM THE #@SAVE@ MACRO CALL.
*IF THE 'TEXT' PARAMETER WAS OMITTED, THEN #@LIB@ WILL DELETE PRECEDING
SPACES AND A FOLLOWING NEW-LINE, JUST LIKE ALL THE OTHER DEFINITION MACROS.
$PAGE
$FOOTNOTE '28 *APRIL 1978                                      *ADVANCED *TECHNIQUES'
4.\\&*ADVANCED *TECHNIQUES&
$SKIP 1
4.1\\&*MARKING *PARAMETERS WITH |&
$SKIP 1
$PARA 5
*WHEN A MACRO IS DEFINED, ALL REFERENCES TO PARAMETER NAMES ARE REPLACED IN THE
STORED DEFINITION TEXT BY UNIQUE ARGUMENT MARKER FLAGS.
*A PROBLEM SOMETIMES ARISES, HOWEVER, IN RECOGNIZING PARAMETER NAMES IN THE
DEFINITION.
*NORMALLY THIS IS NO PROBLEM, BUT CONFUSION CAN ARISE WHEN A PARAMETER NAME
OCCURS RIGHT NEXT TO OTHER ALPHANUMERIC CHARACTERS.
*FOR EXAMPLE, SUPPOSE YOU WANT TO DEFINE A MACRO '@SYM_SAVE@', SO THAT
THE CALLS:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
  SYM_SAVE (A);
  SYM_SAVE (3);
  SYM_SAVE (TEXT);
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
WILL BE EXPANDED INTO:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
  SYM_A_SAVE := SYM_A;
  SYM_3_SAVE := SYM_3;
  SYM_TEXT_SAVE := SYM_TEXT;
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THE OBVIOUS THING TO TRY WOULD BE:
$SKIP 1
$PARA 5
@#DEFINE (SYM_SAVE,X,SYM_X_SAVE := SYM_X)@
$SKIP 1
*BUT GIVEN THIS DEFINITION, THE THREE CALLS ABOVE WOULD ALL EXPAND INTO THE
SAME OUTPUT LINE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
  SYM_X_SAVE := SYM_X;
  SYM_X_SAVE := SYM_X;
  SYM_X_SAVE := SYM_X;
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*THE PROBLEM, OF COURSE, IS THAT '@SYM_X_SAVE@' IS A SINGLE SYMBOL, AND @PMF@
HAS NO WAY OF KNOWING THAT THE '@X@' IN THE MIDDLE IS SUPPOSED TO BE A
PARAMETER REFERENCE.
*THIS CONFUSION IS RESOLVED IN @PMF@ BY THE USING THE BACK-SLASH (|).
*A BACK-SLASH MAY ALWAYS BE INCLUDED BEFORE OR AFTER A PARAMETER NAME IN
A MACRO DEFINITION.
*SUCH BACK-SLASHES SERVE TO SEPARATE A PARAMETER NAME FROM ANY ALPHANUMERIC
CHARACTERS WHICH OTHERWISE WOULD HAVE BEEN RIGHT NEXT TO IT.
*THEY ARE &NOT& STORED AS PART OF THE MACRO DEFINITION.
*THUS, THE CORRECT DEFINITION FOR '@SYM_SAVE@' IS:
$SKIP 1
$PARA 5
@#DEFINE (SYM_SAVE,X,SYM_|X|_SAVE := SYM_|X)@
$SKIP 1
$PARA 5
*THE BACK-SLASH ONLY SERVES THIS SPECIAL FUNCTION WHEN IT OCCURS RIGHT NEXT
TO A PARAMETER NAME IN A MACRO DEFINITION.
*OTHER BACK-SLASHES ARE TREATED LIKE ANY OTHER CHARACTERS.
*ONE CONSEQUENCE OF THIS IS THAT
IF '@X@' AND '@Y@' ARE PARAMETERS, AND YOU WANT THE STRING '@X|Y@'
IN YOUR MACRO DEFINITION, YOU HAVE TO CODE IT AS '@X|||Y@'.
*THE FIRST BACK-SLASH WILL BE DELETED BECAUSE IT IS NEXT TO '@X@', THE
LAST ONE WILL BE DELETED BECAUSE IT IS NEXT TO '@Y@', AND ONLY THE MIDDLE
ONE WILL BE STORED IN THE DEFINITION.
$SKIP 2
4.2\\&*SEPARATING *TOKENS WITH &&&
$SKIP 1
$PARA 5
@PMF@ NEVER LOOKS "INSIDE" AN INPUT TOKEN.
*FOR EXAMPLE, IF YOU HAVE DEFINED LITERALS '@NAME@' AND '@SIZE@', THEN THE
STRING '@NAMESIZE@' WILL BE RECOGNIZED AS A SINGLE TOKEN, AND NOT AS A PAIR
OF LITERAL NAMES.
*NORMALLY, THIS IS EXACTLY WHAT YOU WANT AND EXPECT.
*HOWEVER, THERE MIGHT COME A TIME WHEN YOU WANT TO PRODUCE AN OUTPUT FILE
CONTAINING THE VALUE OF '@SIZE@' RIGHT AFTER THE VALUE OF '@NAME@'.
*WHAT YOU NEED IS SOME WAY TO LET @PMF@ KNOW THAT THESE ARE TWO DISTINCT
TOKENS, WITHOUT HAVING ANYTHING APPEAR BETWEEN THEIR EXPANSIONS IN THE
OUTPUT FILE.
*YOU CAN DO THIS BE PLACING AN AMPERSAND (&&) BETWEEN ANY TWO TOKENS
(FOR EXAMPLE, '@NAME&&SIZE@').
*DURING NORMAL TEXT SCANNING (I.E., NOT DURING ARGUMENT LIST SCANNING) SUCH
AN AMPERSAND INDICATES THAT THE TOKENS PRECEDING AND FOLLOWING IT ARE DISTINCT
TOKENS.
*IT WILL NOT BE COPIED TO THE OUTPUT, HOWEVER.
*TO OBTAIN AN AMPERSAND IN THE OUTPUT FILE, YOU MUST ENCLOSE IT IN TEXT QUOTES
(SEE SECTION 4.4).
(*NOTE THAT AN AMPERSAND DOES NOT HAVE ANY SPECIAL SIGNIFICANCE IN A CHARACTER
STRING LITERAL OR A COMMENT.)
$SKIP 1
*EXAMPLE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (TEST,CODE,IF CODE = ACODE THEN
  FLAG&&ACODE := TRUE)
...
#LITERAL (ACODE,10)
  TEST (CTR_3);
...
#ASSIGN (ACODE,FIN)
  TEST (FILLER);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*EXPANSION:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
  IF CTR_3 = 10 THEN
    FLAG10 := TRUE;
...
  IF FILLER = FIN THEN
    FLAGFIN := TRUE;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
$PARA 5
*YOU MAY BE WONDERING WHAT THE DIFFERENCE IS BETWEEN THE AMPERSAND AND THE
BACK-SLASH.
*THE BACK-SLASH IS RELEVANT ONLY IN THE DEFINITION TEXT ARGUMENT OF A
#@DEFINE@, #@LITERAL@, OR #@ASSIGN@ MACRO CALL.
*THE AMPERSAND, ON THE OTHER HAND, IS MEANINGFUL DURING INPUT TEXT SCANNING,
AND MAY SERVE TO DELIMIT ANY TWO TWO TOKENS.
(*FOR EXAMPLE, YOU COULD GET THE CHARACTERS '(**' IN THE OUTPUT FILE BY
INCLUDING THE CHARACTERS '(&&**' IN THE INPUT FILE.)
$PAGE
4.3\\&*INPUT *LINE *CONTINUATION WITH &&&
$SKIP 1
$PARA 5
*THE AMPERSAND SERVES ANOTHER FUNCTION IN @PMF@.
*WHEN AN AMPERSAND IS THE LAST CHARACTER OF A LINE IN THE INPUT FILE,
@PMF@ PRETENDS THAT IT DIDN'T SEE EITHER THE AMPERSAND OR THE END OF THE
LINE.
*HERE THE AMPERSAND FUNCTIONS AS AN INPUT LINE CONTINUATION CHARACTER.
*THERE IS NO WAY TO GET @PMF@ TO TAKE AN INPUT LINE ENDING WITH AN AMPERSAND.
*YOU CAN, OF COURSE, ALWAYS HAVE AN INPUT LINE ENDING WITH AN AMPERSAND
FOLLOWED BY A BLANK.
$SKIP 1
$PARA 5
&*NOTE:&  *UNLIKE THE OTHER SPECIAL CHARACTERS, RECOGNITION OF AMPERSAND AS
AN INPUT LINE CONTINUATION CHARACTER OCCURS BEFORE THE INPUT HAS BEEN
BROKEN INTO TOKENS.
*THE AMPERSAND WILL THEREFORE FUNCTION AS A LINE CONTINUATION CHARACTER EVEN
IF IT OCCURS IN A COMMENT OR A CHARACTER STRING LITERAL.
*SIMILARLY, IF THE END OF ONE LINE IS '@...\XYZ&&@', AND THE BEGINNING OF THE
NEXT LINE IS '@ABC\...@', THEN @PMF@ WILL SEE A SINGLE TOKEN '@XYZABC@'.
$SKIP 2
4.4\\&*TEXT *QUOTATION WITH <: AND :>&
$SKIP 1
$PARA 5
*THE SCANNING ACTIVITIES OF EXPANDING MACRO CALLS AND DISCARDING AMPERSANDS
ARE NORMALLY APPLIED TO ALL THE TEXT PROCESSED BY @PMF@.
*IF YOU WANT TO COPY AN AMPERSAND OR A SYMBOL WHICH HAPPENS TO BE A MACRO
NAME INTO THE OUTPUT FILE, THIS PRESENTS A PROBLEM.
*THEREFORE, @PMF@ RECOGNIZES THE SPECIAL SYMBOLS <: AND :> AS TEXT QUOTE
BRACKETS.
*ANY TEXT ENCLOSED IN TEXT QUOTES IS SIMPLY COPIED, REGARDLESS OF WHAT IT IS;
AND THE TEXT QUOTES THEMSELVES ARE DISCARDED.
*SINCE TEXT QUOTES COME IN MATCHING PAIRS, THE TEXT ENCLOSED IN THEM MAY
CONTAINS OTHER MATCHED PAIRS OF TEXT QUOTES.
*FOR EXAMPLE, EVEN IF '*A' AND '*B' WERE DEFINED MACROS, THE INPUT TEXT
'@X+<:A&&B+<:C:>&&D:>+Y@' WOULD PRODUCE THE OUTPUT TEXT '@X+A&&B+<:C:>&&D+Y@'.
*TEXT QUOTES ARE NOT RECOGNIZED WITHIN CHARACTER STRING LITERALS OR COMMENTS.
*WITHIN MACRO ARGUMENTS, TEXT QUOTES ARE NOT DISCARDED, BUT THEY MUST OCCUR
IN MATCHED PAIRS.
*INSIDE THEM, ANY COMBINATION OF PARENTHESES, BRACKETS, AND COMMAS IS ALLOWED.
*AN AMPERSAND AT THE END OF A LINE IN THE INPUT FILE INDICATES LINE
CONTINUATION, EVEN WITHIN TEXT QUOTES.
$SKIP 2
4.5\\&*EVALUATED *ARGUMENTS WITH "&
$SKIP 1
$PARA 5
*THE RULE THAT MACRO ARGUMENTS ARE NOT EVALUATED IS GENERALLY CONVENIENT.
*THERE ARE, HOWEVER, CASES IN WHICH YOU WOULD LIKE TO HAVE AN ARGUMENT
EVALUATED BEFORE PASSING IT TO A MACRO.
*FOR EXAMPLE, THE MACRO CALL '#@ASSIGN (X,A)@' WILL ASSIGN THE CHARACTER '*A'
TO THE LITERAL '*X', EVEN IF THERE IS A DEFINED LITERAL NAMED '*A'.
*IF YOU WANTED TO ASSIGN THE &VALUE& OF '*A' TO '*X', THIS ASSIGNMENT WOULDN'T
WORK.
$SKIP 1
$PARA 5
*THEREFORE, IF THE FIRST CHARACTER OF A MACRO ARGUMENT IS A DOUBLE-QUOTE MARK
("), @PMF@ WILL DISCARD THE QUOTE MARK AND EVALUATE THE ARGUMENT BEFORE
EXPANDING THE MACRO.
*YOU COULD ASSIGN THE VALUE OF '*A' TO '*X' WITH THE CALL '#@ASSIGN (X,"A)@'.
*THIS EVALUATION IS DONE BY PUSHING THE ARGUMENT BACK INTO THE INPUT (JUST
AS THOUGH IT WERE THE VALUE OF A MACRO CALL THAT HAD JUST BEEN EXPANDED), AND
THEN APPLYING THE NORMAL @PMF@ SCANNING ALGORITHM TO IT.
*INSTEAD OF THE RESULTS BEING COPIED TO THE OUTPUT FILE, HOWEVER, THEY ARE
SAVED; AND WHEN THE RESCANNING IS COMPLETE, THE SAVED RESULTS REPLACE THE
ORIGINAL ARGUMENT.
$SKIP 1
*EXAMPLE:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
#LITERAL (Y,0)
#LITERAL (TEST0,X := Y)
#LITERAL (TEST1,"X := Y)
#LITERAL (TEST2,<:X := Y:>)
#LITERAL (TEST3,"<:X := Y:>)
#LITERAL (Y,1)
...
  TEST0;
  TEST1;
  TEST2;
  TEST3;
...
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*EXPANSION:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
...
  X := 1;
  X := 0;
  X := Y;
  X := 1;
...
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*THE DEFINITION STORED FOR '@TEST0@' IS SIMPLY '@X := Y@', AND WHEN '@TEST0@'
IS EXPANDED, '*Y' IS REPLACED BY ITS CURRENT VALUE, WHICH IS '1'.
*WHEN '@TEST1@' IS DEFINED, THE EVALUATION FLAG CAUSES THE STRING '@X := Y@'
TO BE EVALUATED, SO THAT THE DEFINITION WHICH IS STORED FOR '@TEST1@' IS
'@X := 0@'.
*THE STRING '@<:X := Y:>@' IS STORED FOR '@TEST2@', AND WHEN THIS IS EXPANDED,
THE EFFECT OF THE SCANNING ALGORITHM IS TO STRIP OFF THE TEXT QUOTES, COPYING
THEIR CONTENTS VERBATIM.
*THE EVALUATION FLAG IN THE DEFINITION OF '@TEST3@' CAUSES THE STRING '@<:X
:= Y:>@' TO BE EVALUATED; BUT THE ONLY EFFECT OF THE EVALUATION IS TO REMOVE
THE TEXT QUOTES, SO THE DEFINITION STORED FOR '@TEST3@' IS THE SAME AS THAT
FOR '@TEST0@', '@X := Y@'.
$SKIP 1
$PARA 5
&*NOTE\1:&
*THE DOUBLE-QUOTE MARK IS ONLY AN IMMEDIATE EVALUATION FLAG IF IT IS THE FIRST
CHARACTER IN THE ARGUMENT.
*THAT MEANS THERE MAY BE &NO& CHARACTERS, NOT EVEN SPACES, BETWEEN THE ARGUMENT
DELIMITER (THE COMMA OR THE OPENING PARENTHESIS OF THE ARGUMENT LIST) AND THE
DOUBLE-QUOTE MARK.
$SKIP 1
$PARA 5
&*NOTE\2:&
*THE ONLY WAY TO WRITE AN ARGUMENT CONTAINING A COMMA THAT ISN'T ENCLOSED
BETWEEN MATCHING PARENTHESES OR BRACKETS IS TO ENCLOSE THE ARGUMENT IN
TEXT QUOTES AND THEN PUT AN EVALUATION FLAG IN FRONT OF IT.
*FOR EXAMPLE, '#@DEFINE (DCL_LABELS,LABEL 100, 200;)@' IS A BAD DEFINITION,
SINCE '@LABEL 100@' WILL BE INTERPRETED AS A PARAMETER NAME.
*THE DEFINITION SHOULD HAVE BEEN CODED '#@DEFINE (DCL_LABELS,"<:LABEL 100,
200;:>)@'.
$PAGE
$FOOTNOTE '28 *APRIL 1978                            *NUMERIC AND *STRING *OPERATIONS'
5.\\&*NUMERIC AND *STRING *OPERATIONS&
$SKIP 1
5.1\\&#@NUM@ (EXPRESSION)&
$SKIP 1
$PARA 5
*THE #@NUM@ MACRO ALLOWS YOU TO PERFORM ARITHMETIC WITH NUMERIC STRINGS.
*THE VALUE OF A #@NUM@ MACRO CALL IS THE RESULT OF EVALUATING ITS 'EXPRESSION'
PARAMETER, EXPRESSED AS A STRING OF DIGITS AND PREFIXED WITH A MINUS SIGN IF
IT IS NEGATIVE.
*THE 'EXPRESSION' MAY CONTAIN INTEGER CONSTANTS, CONNECTED BY THE OPERATORS
'+', '-', '**', AND '/'.
*THE INTEGER CONSTANTS ARE SIMPLY STRINGS OF DIGITS.
*AN INTEGER CONSTANT MAY ALSO SIMPLY BE OMITTED, IN WHICH CASE ITS VALUE IS
ASSUMED TO BE ZERO.
*FOR EXAMPLE, THE EXPRESSION '3**+4/(-7)' IS EQUIVALENT TO '3**0+4/(0-7)'.
*THE EXPRESSION MAY CONTAIN SPACES AND NEW-LINES ANYWHERE EXCEPT IN THE MIDDLE
OF AN INTEGER CONSTANT.
*DIVISION BY ZERO IS NOT DIAGNOSED AS AN ERROR, BUT WILL RETURN A ZERO RESULT.
$SKIP 1
*EXAMPLE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (DECLARE_TABLE,SYM,SIZE,
CONST SYM|_SIZE = SIZE;
TYPE  SYM|_INDEX = 0 .. #NUM(SIZE+1);
VAR   SYM|_TABLE: PACKED ARRAY [1..#NUM(5*SIZE+5)] OF CHAR;)
...
DECLARE_TABLE (KEY,20)
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*EXPANSION:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...

CONST KEY_SIZE = 20;
TYPE  KEY_INDEX = 0 .. 21;
VAR   KEY_TABLE: PACKED ARRAY [1..105] OF CHAR;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
$PARA 5
&*NOTE\1:&  *REMEMBER THAT AN EXPRESSION LIKE '5**-7' WILL BE EVALUATED, NOT AS
'-35', BUT AS '-7' ('5**0-7').  *IF ONE OF THE FACTORS IN A PRODUCT IN #@NUM@
MIGHT BE A NEGATIVE NUMBER, YOU SHOULD ENCLOSE IT IN PARENTHESES, JUST TO BE
SAFE.
$SKIP 1
$PARA 5
&*NOTE\2:&  '#@NUM@()' IS A PERFECTLY LEGITIMATE CALL TO THE #@NUM@ MACRO,
AND WILL EXPAND TO '0'.
$SKIP 2
5.2\\&#@STR@ (TEXT)&
$SKIP 1
$PARA 5
*YOU MAY RECALL THAT @PMF@ REGARDS *PASCAL CHARACTER STRING LITERALS AS TOKENS.
*ONE OF THE CONSEQUENCES OF THIS IS THAT THERE IS NO WAY TO WRITE A MACRO WHICH
CREATES A CHARACTER STRING LITERAL.  *FOR EXAMPLE, IN THE DEFINITION
$SKIP 1
$PARA 5
@#DEFINE (MAKE_STRING,TEXT,'TEXT')@
$SKIP 1
THE DEFINITION CONTAINS A SINGLE TOKEN, THE LITERAL "'@TEXT@'".
*A CALL ON THE #@STR@ MACRO EXPANDS INTO A CHARACTER STRING LITERAL WHICH
CONSISTS OF THE 'TEXT' ARGUMENT, WITH SINGLE QUOTES (') STUCK ON THE
BEGINNING AND END.
*FOR EXAMPLE:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#STR (ABC)
#STR ()
#STR (I CAN''T)
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*EXPANSION:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
'ABC'
''
'I CAN''T'
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 2
5.3\\&#@LENGTH@ (TEXT)&
$SKIP 1
$PARA 5
*THE LENGTH MACRO SIMPLY RETURNS THE NUMBER OF CHARACTERS IN ITS ARGUMENT,
EXPRESSED AS A DIGIT STRING.
*FOR EXAMPLE,
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
#DEFINE (DCL_STR,NAM,STR,&&
VAR NAM: STRING [#LENGTH(STR)];
INITPROCEDURE;
BEGIN
  NAM := #STR(STR);
END)
...
DCL_STR (ALPHA,MESSAGE TEXT 1);

DCL_STR (BETA);
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$SKIP 1
*EXPANSION:
$SKIP 1
$INDENT LEFT +5
$VERBATIM
$DECAP OFF
...
VAR ALPHA: STRING [14];
INITPROCEDURE;
BEGIN
  ALPHA := 'MESSAGE TEXT 1';
END;

VAR BETA: STRING [0];
INITPROCEDURE;
BEGIN
  BETA := '';
END;
...
$DECAP ON
$JUSTIFY
$INDENT LEFT -5
$PAGE
5.4\\&#@SUBSTR@ (TEXT,IND,LEN)&
$SKIP 1
$PARA 5
*THE #@SUBSTR@ MACRO RETURNS A SUBSTRING OF THE FIRST ARGUMENT, BEGINNING AT
THE CHARACTER SPECIFIED BY THE SECOND ARGUMENT, AND TAKING THE NUMBER OF
CHARACTERS SPECIFIED BY THE THIRD ARGUMENT.
*THE SECOND AND THIRD ARGUMENTS MUST BE CONSTANT NUMERIC EXPRESSIONS OF THE
SORT ACCEPTED BY #@NUM@.
*THE THIRD ARGUMENT MAY BE OMITTED, IN WHICH CASE THE REMAINDER OF THE FIRST
ARGUMENT WILL BE TAKEN (STARTING AT THE CHARACTER SPECIFIED BY THE SECOND
ARGUMENT).
*IF 'IND' IS GREATER THAN THE LENGTH OF THE STRING OR 'LEN' IS ZERO OR LESS,
#@SUBSTR@ WILL RETURN THE EMPTY STRING.
*A VALUE OF 'IND' LESS THAN ONE IS EQUIVALENT TO ONE, AND A VALUE OF 'LEN'
THAT IS MORE THAN THE LENGTH OF THE REST OF THE STRING  WILL TAKE THE REST
OF THE STRING.
$SKIP 2
5.5\\&#@INDEX@ (TEXT,TARGET,DEFAULT)&
$SKIP 1
$PARA 5
*THE #@INDEX@ MACRO RETURNS A DIGIT STRING REPRESENTING THE LOCATION IN THE
FIRST ARGUMENT OF THE FIRST OCCURRENCE OF THE COMPLETE TEXT OF THE SECOND
ARGUMENT.
*IF THE SECOND ARGUMENT DOES NOT OCCUR ANYWHERE IN THE FIRST ARGUMENT,
THEN #@INDEX@ RETURNS THE EMPTY STRING IF THE THIRD ARGUMENT IS OMITTED,
OR SIMPLY RETURNS A COPY OF THE THIRD ARGUMENT IF IT IS NOT OMITTED.
$SKIP 2
5.6\\&#@VERIFY@ (TEXT,CHARS,DEFAULT)&
$SKIP 1
$PARA 5
*THE #@VERIFY@ MACRO RETURNS A DIGIT STRING REPRESENTING THE LOCATION IN THE
FIRST ARGUMENT OF THE FIRST OCCURRENCE OF SOME CHARACTER WHICH IS NOT IN THE
SECOND ARGUMENT.
*IF ALL OF THE CHARACTERS IN THE FIRST ARGUMENT ARE ALSO IN THE SECOND ARGUMENT,
THEN #@VERIFY@ RETURNS THE EMPTY STRING IF THE THIRD ARGUMENT IS OMITTED,
OR SIMPLY RETURNS A COPY OF THE THIRD ARGUMENT IF IT IS NOT OMITTED.
$SKIP 2
5.7\\&#@SEARCH@ (TEXT,CHARS,DEFAULT)&
$SKIP 1
$PARA 5
*THE #@SEARCH@ MACRO RETURNS A DIGIT STRING REPRESENTING THE LOCATION IN THE
FIRST ARGUMENT OF THE FIRST OCCURRENCE OF ANY OF THE CHARACTERS IN THE SECOND
ARGUMENT.
*IF NONE OF THE CHARACTERS IN THE SECOND ARGUMENT ARE ALSO IN THE FIRST,
THEN #@SEARCH@ RETURNS THE EMPTY STRING IF THE THIRD ARGUMENT IS OMITTED,
OR SIMPLY RETURNS A COPY OF THE THIRD ARGUMENT IF IT IS NOT OMITTED.
$SKIP 2
5.8\\&#@UPC@ (TEXT) AND #@LWC@ (TEXT)&
$SKIP 1
$PARA 5
*THE #@UPC@ MACRO RETURNS A COPY OF ITS TEXT ARGUMENT, WITH ALL LOWERCASE
LETTERS REPLACED BY THE CORRESPONDING UPPERCASE LETTERS.
*THE #@LWC@ MACRO RETURNS A COPY OF ITS TEXT ARGUMENT, WITH ALL UPPERCASE
LETTERS REPLACED BY THE CORRESPONDING LOWERCASE LETTERS.
$PAGE
$FOOTNOTE '28 *APRIL 1978                              *CONDITIONAL *MACRO *EXPANSION'
6.\\&*CONDITIONAL *MACRO *EXPANSION&
$SKIP 1
6.1\\&#@IF@ (TEST,THEN-VALUE,ELSE-VALUE)&
$SKIP 1
$PARA 5
*THE #@IF@ MACRO MAKES IT POSSIBLE TO WRITE A MACRO WHOSE EXPANSION DEPENDS ON
ITS PARAMETERS IN SOME WAY MORE INTERESTING THAN SIMPLE SUBSTITUTION.
*IF THE FIRST ARGUMENT IN A CALL TO THE #@IF@ MACRO IS ANYTHING OTHER THAN
THE EMPTY STRING, THEN THE VALUE OF THE #@IF@ MACRO CALL
WILL BE A COPY OF THE SECOND ARGUMENT.
*IF THE FIRST ARGUMENT IS THE EMPTY STRING, THEN THE VALUE OF THE #@IF@ MACRO
CALL WILL BE A COPY OF THE THIRD ARGUMENT.
(*THE THIRD ARGUMENT MAY BE OMITTED, IN WHICH CASE, IF THE FIRST ARGUMENT IS
THE EMPTY STRING, THE VALUE OF THE #@IF@ MACRO CALL WILL BE THE EMPTY STRING.)\
$SKIP 1
$PARA 5
*THIS MIGHT NOT SEEM TO BE VERY USEFUL; AND BY ITSELF, IT PROBABLY WOULDN'T BE.
*HOWEVER, @PMF@ ALSO PROVIDES A SET OF NUMERIC AND STRING PREDICATES.
*THESE PREDICATES ARE MACROS WHICH RETURN EITHER THE EMPTY STRING OR THE
DIGIT '1', DEPENDING ON THEIR ARGUMENTS.
*THUS, BY CODING A PREDICATE MACRO AS THE 'TEST' ARGUMENT IN AN #@IF@ MACRO
CALL, IT IS POSSIBLE TO EXPAND CODE CONDITIONALLY ON THE BASIS OF ALMOST
ANY RELATION.
$SKIP 2
6.2\\&#REL*N (NUM1,NUM2)& -- &*NUMERIC PREDICATES&
$SKIP 1
$PARA 5
@PMF@ PROVIDES A SET OF SIX NUMERIC PREDICATES: @#EQN, #NEN, #LTN, #LEN,
#GTN@, AND @#GEN@.
*THESE MACROS TEST FOR THE NUMERIC RELATIONS =, <>, <, <=, >, AND >=,
RESPECTIVELY.
*THE 'NUM1' AND 'NUM2' ARGUMENTS MUST BE CONSTANT NUMERIC EXPRESSIONS OF THE
SORT ACCEPTED BY #@NUM@.
*THE SECOND ARGUMENT MAY BE OMITTED, IN WHICH CASE THE FIRST ARGUMENT IS
COMPARED TO ZERO.
*IF THE INDICATED RELATION HOLDS BETWEEN THE ARGUMENTS, THESE MACROS
RETURN '1'.
*OTHERWISE, THEY RETURN THE EMPTY STRING.
$SKIP 2
6.3\\&#REL*C (STR1,STR2)& -- &*STRING *PREDICATES&
$SKIP 1
$PARA 5
@PMF@ ALSO PROVIDES A CORRESPONDING SET OF SIX STRING PREDICATES: @#EQC, #NEC,
#LTC, #LEC, #GTC@, AND @#GEC@.
*THE ARGUMENTS TO THESE MACROS MAY BE ANY STRINGS TO BE COMPARED.
*THE SECOND ARGUMENT MAY BE OMITTED, IN WHICH CASE THE FIRST ARGUMENT IS
COMPARED TO THE EMPTY STRING.
*THE STRING RELATIONS ARE THE SAME AS THOSE USED BY *PASCAL, EXCEPT THAT
TWO STRINGS OF DIFFERENT LENGTHS WILL NEVER BE EQUAL.
*IF THEY ARE EQUAL UP TO THE LENGTH OF THE SHORTER STRING, THEN THE SHORTER
STRING IS DEFINED TO BE LESS THAN THE LONGER STRING.
*THE ORDERING ON THE CHARACTERS IS THE SAME *ASCII ORDERING THAT IS USED BY
*PASCAL, EXTENDED WITH THE NEW-LINE CHARACTER, WHICH IS LESS THAN ANY OTHER
CHARACTER WHICH CAN OCCUR IN AN ARGUMENT.
$PAGE
6.4\\&#@AND@ (P1,P2,...PN)&
$SKIP 1
$PARA 5
*THE #@AND@ MACRO WILL RETURN '1' IF NONE OF ITS ARGUMENTS IS THE EMPTY STRING.
*IF ANY OF ITS ARGUMENTS IS THE EMPTY STRING, THEN #@AND@ RETURNS THE EMPTY
STRING.
$SKIP 2
6.5\\&#@OR@ (P1,P2,...PN)&
$SKIP 1
$PARA 5
*THE #@OR@ MACRO WILL RETURN '1' IF IT HAS AT LEAST ONE ARGUMENT WHICH IS NOT
THE EMPTY STRING.
*IF ALL OF ITS ARGUMENTS ARE THE EMPTY STRING, #@OR@ RETURNS THE EMPTY STRING.
$SKIP 2
6.6\\&#@NOT@ (P)&
$SKIP 1
$PARA 5
*THE #@NOT@ MACRO WILL RETURN '1' IF ITS ARGUMENT IS THE EMPTY STRING, AND WILL
RETURN THE EMPTY STRING IF ITS ARGUMENT IS NOT THE EMPTY STRING.
$PAGE
$FOOTNOTE '28 *APRIL 1978                                            *MISCELLANEOUS'
7.\\&*MISCELLANEOUS&
$SKIP 1
7.1\\&#@EVAL@ (STRING)&
$SKIP 1
$PARA 5
*THE VALUE OF THE #@EVAL@ MACRO IS SIMPLY A COPY OF ITS PARAMETER.
*AS AN EXAMPLE OF A SITUATION IN WHICH THIS MIGHT BE USEFUL, SUPPOSE THAT
'@SYM1@'
THROUGH '@SYM9@' ARE LITERALS, AND THAT '@N@' IS A LITERAL WHOSE VALUE IS
ONE OF THE DIGITS '1' THROUGH '9'.
(*WE'LL ASSUME THAT IT IS ACTUALLY '3' IN THIS CASE.)\
*THEN THE EXPRESSION '@SYM&&N@' WILL EVALUATE TO '@SYM3@'.
*IF YOU WANT TO OUTPUT THE VALUE OF THE '@SYM@' LITERAL INDEXED BY '@N@',
HOWEVER, THEN YOU NEED TO MAKE @PMF@ SCAN THE CONCATENATED TEXT AGAIN.
*WHEN THE EXPRESSION '@#EVAL("SYM&&N)@' IS EVALUATED, '@SYM&&N@' WILL BE
REDUCED TO '@SYM3@' DURING THE PARAMETER SCAN.
*THEN THIS WILL REPLACE THE #@EVAL@ CALL IN THE INPUT, AND @PMF@ WILL SCAN
THE SYMBOL '@SYM3@' AND REPLACE IT BY ITS VALUE.
$SKIP 2
7.2\\&#@ERROR@ (MESSAGE)&
$SKIP 1
$PARA 5
*A CALL TO THE #@ERROR@ MACRO CAUSES @PMF@ TO STOP PROCESSING THE INPUT FILE
IMMEDIATELY AND PRINT A "@% CALL TO #ERROR@" ERROR MESSAGE.
*ANY PARAMETERS OF THE CALL WILL BE PRINTED AS PART OF THE STANDARD ERROR
MESSAGE PRINTING PROCEDURE.
*THUS, THIS MACRO CAN BE USED TO PRINT A MESSAGE AND ABORT IF THE PARAMETERS
TO SOME USER-DEFINED MACRO ARE INCORRECT.
$SKIP 2
7.3\\&#@MACRO@ (NAME)&
$SKIP 1
$PARA 5
#@MACRO@ IS A SPECIAL PREDICATE, WHICH WILL RETURN '1' IF 'NAME' IS A DEFINED
MACRO OR LITERAL, AND WILL RETURN THE EMPTY STRING OTHERWISE.
$SKIP 2
7.4\\&*ASSORTED *NOTES&
$SKIP 1
$PARA 5
(1)\ *WHEN LOOKING UP LITERAL AND MACRO NAMES, @PMF@ FIRST CHANGES ALL
LOWER-CASE LETTERS TO UPPER-CASE.
$SKIP 1
$PARA 5
(2)\ @PMF@ REMOVES ALL TRAILING BLANKS FROM THE ENDS OF OUTPUT LINES,
AND CONVERTS LEADING BLANKS TO TABS WHEREVER POSSIBLE.
$FOOTNOTE '28 *APRIL 1978                                   *OPERATING *INSTRUCTIONS'
$PAGE
8.\\&*OPERATING *INSTRUCTIONS&
$SKIP 1
$PARA 5
@PMF@ IS IN LIBRARY @RND:@, AND MAY BE EXECUTED BY TYPING '@RUN RND:PMF@' AT
THE DOT.
@PMF@ CUES FOR COMMAND LINES WITH A STAR (**).
*AS SOON AS IT FINISHES PROCESSING ONE COMMAND, IT WILL PROMPT FOR ANOTHER.
*INSTEAD OF ENTERING A COMMAND, YOU MAY SPECIFY A COMMAND FILE BY TYPING
'@@FILE NAME'.
@PMF@ WILL OPEN THE SPECIFIED FILE AND READ COMMAND LINES FROM IT.
*IF NO EXTENSION IS SPECIFIED FOR THE COMMAND FILE, '.@CMD@' WILL BE ASSUMED.
*LINES READ FROM THE COMMAND FILE WILL BE PRINTED AT THE TERMINAL, PREFIXED
WITH A '>' CHARACTER.
*WHEN @PMF@ REACHES THE END OF THE COMMAND FILE, IT WILL PROMPT WITH A '**' FOR
ANOTHER COMMAND FROM THE TERMINAL.
*IF @PMF@ READS A BLANK LINE FROM THE TERMINAL, IT WILL STOP IMMEDIATELY.
*BLANK LINES IN A COMMAND FILE WILL BE IGNORED.
$SKIP 1
$PARA 5
*COMMAND LINES TO @PMF@ HAVE THE FORMAT:
$SKIP 1
$PARA 5
*[OUTPUT FILE=][INPUT FILE][/SWITCHES]
$SKIP 1
*THE INPUT AND OUTPUT FILE NAMES ARE BOTH OPTIONAL.
*IF THEY ARE BOTH OMITTED, THEN NO MACRO PROCESSING WILL BE DONE.
*THIS COMBINATION IS USEFUL WITH THE /@DUMP@, /@SAVE@, /@SET@, AND
/@EXIT@ SWITCHES.
*IF THE INPUT FILE IS SPECIFIED AND THE OUTPUT FILE IS OMITTED, THEN THE
OUTPUT FILE WILL HAVE THE SAME NAME AS THE INPUT FILE, WITH AN EXTENSION
OF '.@TMP@'.
*IF THE OUTPUT FILE IS SPECIFIED AND THE INPUT FILE IS OMITTED, THEN THE
OUTPUT FILE WILL BE WRITTEN.
*HOWEVER, WITH NO INPUT FILE TO BE READ FOR MACRO PROCESSING, THE OUTPUT FILE
WILL BE EMPTY UNLESS A /@LIB@ SWITCH IN THE COMMAND CAUSES TEXT TO BE
COPIED FROM A LIBRARY FILE.
*IF THE EXTENSION IS OMITTED FROM THE OUTPUT FILE NAME, A DEFAULT EXTENSION
OF '.@PAS@' WILL BE USED.
*IF THE EXTENSION IS OMITTED FROM THE INPUT FILE NAME, A DEFAULT EXTENSION
OF '.@PMF@' WILL BE USED (EXCEPT IN /@NOMACRO@ MODE--SEE BELOW).
$SKIP 1
$PARA 5
*A SWITCH HAS THE FORM '/KEYWORD[:VALUE]'.
*EACH SWITCH IN A COMMAND LINE MUST BE PRECEDED BY A SLASH.
*ANY SWITCH EXCEPT /@SET@ MAY BE ABBREVIATED AS MUCH AS YOU LIKE;
AT LEAST TWO CHARACTERS MUST BE TYPED FOR /@SET@, SO THAT IT CAN BE
DISTINGUISHED FROM /@SAVE@.
*A SWITCH MAY BE COMPLEMENTED BY PRECEDING IT WITH '@NO@': E.G.,
/@NODUMP@ OR /@NOSAVE@.
$SKIP 2
8.1\\&/@MACRO@&
$SKIP 1
$PARA 5
*THE /@MACRO@ SWITCH INSTRUCTS @PMF@ TO PERFORM MACRO PROCESSING ON THE INPUT
FILE TO PRODUCE THE OUTPUT FILE.
*THIS IS THE DEFAULT CONDITION.
*IF /@NOMACRO@ IS SPECIFIED, THEN ANY OUTPUT FILE NAME IS IGNORED
COMPLETELY, AND THE INPUT FILE NAME EXTENSION DEFAULTS TO '.@PAS@' INSTEAD
OF TO '.@PMF@'.
/@NOMACRO@ IS PRIMARILY USED IN CONJUNCTION WITH THE /@COMPILE@ SWITCH,
FOR FILES WHICH ARE TO BE COMPILED WITH *PASCAL, BUT WHICH DO NOT REQUIRE
MACRO PROCESSING.
*THE /@MACRO@ SWITCH IS IRRELEVANT IF NEITHER AN INPUT NOR AN OUTPUT FILE
IS SPECIFIED, SINCE MACRO PROCESSING IS NEVER PERFORMED IN THIS CASE.
$PAGE
8.2\\&/@COMPILE@:OPTIONS&
$SKIP 1
$PARA 5
*THE /@COMPILE@ SWITCH INSTRUCTS @PMF@ THAT AFTER MACRO PROCESSING IS COMPLETE,
THIS FILE SHOULD BE COMPILED BY *PASCAL.
*WHEN @PMF@ TERMINATES, IT CHECKS WHETHER ANY OF THE FILES IT PROCESSED
WERE MARKED WITH A /@COMPILE@ SWITCH.
*IF SO, @PMF@ EXECUTES THE *PASCAL COMPILER, PASSING IT THE NAMES OF THOSE
FILES.
*THE /@COMPILE@ SWITCH IS IGNORED IF NEITHER AN INPUT NOR AN OUTPUT FILE IS
SPECIFIED, IF THE /@NOMACRO@ OPTION IS SET AND NO INPUT FILE IS SPECIFIED,
OR IF AN ERROR OCCURS DURING MACRO PROCESSING.
*IN /@MACRO@ MODE, @PMF@ PASSES THE NAME OF THE OUTPUT FILE TO *PASCAL.
*IN /@NOMACRO@ MODE, @PMF@ PASSES THE NAME OF THE INPUT FILE TO *PASCAL.
(*NOTE THAT IN BOTH OF THESE CASES, THE DEFAULT FILE-NAME EXTENSION IS
'@.PAS@'.)\
$SKIP 1
$PARA 5
*IF THE /@COMPILE@ SWITCH IS WRITTEN WITH AN 'OPTIONS' ARGUMENT, THEN THE
ARGUMENT TEXT IS SIMPLY ATTACHED TO THE *PASCAL COMMAND LINE AS AN OPTION LIST.
*FOR EXAMPLE, SUPPOSE THE COMMANDS TO @PMF@ ARE:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
*TEST1=TEST2/COMPILE
*TEST3=TEST4/COMPILE/NOMACRO
*TEST5/COMPILE:NOS,TR,P
*TEST6=/COMPILE/NOMACRO
*/COMPILE
*/EXIT
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*THEN THE COMMAND FILE FOR *PASCAL WILL CONTAIN:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
TEST1.PAS
TEST4.PAS
TEST5.TMP/NOS,TR,P
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*THE OUTPUT FILE FROM THE FIRST COMMAND, @TEST1@, IS PASSED TO *PASCAL.
*BECAUSE OF THE /@NOMACRO@ SWITCH, THE OUTPUT FILE NAME IN THE SECOND COMMAND
WILL BE IGNORED, SO THE INPUT FILE, @TEST4@, IS USED INSTEAD.
*THE OUTPUT FILE FROM THE THIRD COMMAND IS @TEST5.TMP@, SO THIS IS PASSED TO
*PASCAL ALONG WITH THE SPECIFIED SWITCHES.
*THE FOURTH COMMAND WILL NOT GENERATE A COMMAND LINE FOR *PASCAL, SINCE
/@NOMACRO@ MODE WAS SPECIFIED AND NO INPUT FILE WAS GIVEN;
AND THE LAST /@COMPILE@ COMMAND WILL NOT GENERATE A COMMAND FOR *PASCAL, SINCE
NEITHER AN INPUT NOR AN OUTPUT FILE IS GIVEN.
(*ACTUALLY, THE FILE NAMES PASSED TO *PASCAL ARE FULL PATH NAMES, SUCH AS
'@D13C:TEST1.PAS[52250,246]@'.)
$SKIP 2
8.3\\&/@PASCAL@&
$SKIP 1
$PARA 5
*THE /@PASCAL@ SWITCH INSTRUCTS @PMF@ TO PARSE THE INPUT FILE IN *PASCAL MODE --
THAT IS, TO TREAT LITERAL CHARACTER STRINGS AND COMMENTS AS SINGLE TOKENS.
*THIS IS THE DEFAULT MODE.
*IF /@NOPASCAL@ IS SPECIFIED, THEN SINGLE QUOTES AND PARENTHESES, EVEN WHEN
PRECEDED BY ASTERISKS, WILL BE TREATED LIKE ANY OTHER CHARACTERS.
$PAGE
8.4\\&/@LIB@:FILE&
$SKIP 1
$PARA 5
*THE /@LIB@ SWITCH IS RELEVANT ONLY IF MACRO PROCESSING IS BEING PERFORMED
(THAT IS, IN /@MACRO@ MODE WITH AN INPUT OR OUTPUT FILE NAME SPECIFIED).
*IN THIS CASE, @PMF@ WILL LOAD THE DEFINITIONS FROM THE SPECIFIED LIBRARY
FILE BEFORE IT STARTS PROCESSING THE INPUT FILE;
AND IF THE #@SAVE@ MACRO SAVED A 'TEXT' ARGUMENT IN THE LIBRARY FILE,
THIS WILL BE PROCESSED BEFORE THE INPUT FILE.
*THE EFFECT OF A /@LIB@ SWITCH ON A COMMAND LINE IS EXACTLY THE SAME AS THE
EFFECT OF AN EQUIVALENT #@LIB@ MACRO CALL AT THE BEGINNING OF THE INPUT
FILE.
*IF NO FILE ARGUMENT IS SPECIFIED ON THE /@LIB@ SWITCH, THEN @PMF@ WILL
LOOK FOR A LIBRARY FILE WITH THE SAME NAME AS THE OUTPUT FILE AND AN
EXTENSION OF '.@PML@'.
*IF THERE IS NO INPUT FILE, THEN THE ONLY TEXT WRITTEN TO THE OUTPUT FILE
WILL BE THAT WHICH THE #@SAVE@ MACRO STORED IN THE LIBRARY FILE.
*AN ERROR IN THE /@LIB@ SWITCH (E.G., A BAD FILE NAME OR A BAD LIBRARY FILE)
WILL SUPPRESS ANY FURTHER PROCESSING OF THIS COMMAND LINE:
NO OUTPUT FILE WILL BE WRITTEN, AND A /@COMPILE@ SWITCH WILL BE IGNORED.
$SKIP 2
8.5\\&/@SAVE@:FILE&
$SKIP 1
$PARA 5
*IN A COMMAND WHICH CAUSES MACRO PROCESSING TO BE PERFORMED, THE EFFECT OF A
/@SAVE@ SWITCH IS THE SAME AS THE EFFECT OF AN EQUIVALENT #@SAVE@ MACRO
CALL AT THE END OF THE INPUT FILE, EXCEPT THAT THE /@SAVE@ SWITCH WILL
CAUSE ANY DEFINITIONS FROM THE PROGRAM TO BE SAVED ON THE LIBRARY FILE
EVEN IF AN ERROR OCCURS DURING MACRO PROCESSING.
*IN A COMMAND WHICH DOES NOT CAUSE MACRO PROCESSING (NO INPUT OR OUTPUT FILE,
OR /@NOMACRO@ MODE), THE /@SAVE@ SWITCH WILL SAVE THE DEFINITIONS FROM THE
LAST PROGRAM WHICH WAS PROCESSED.
*IF NO COMMAND TO @PMF@ HAS CAUSED MACRO PROCESSING TO BE PERFORMED YET,
THE /@SAVE@ SWITCH IS SIMPLY IGNORED.
*THERE IS NO WAY TO SPECIFY A 'TEXT' PARAMETER ON THE /@SAVE@ SWITCH.
*IF NO FILE ARGUMENT IS GIVEN, THEN @PMF@ WILL CREATE A LIBRARY FILE
WITH THE SAME NAME AS THE OUTPUT FILE AND AN EXTENSION OF '.@PML@'.
*FOR EXAMPLE, SUPPOSE @PMF@ GETS THE FOLLOWING COMMANDS:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
*A=B/SAVE
*D
*C/NOMACRO
*/DUMP
*/SAVE:L1
*/EXIT
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*THE FIRST COMMAND WILL PERFORM MACRO PROCESSING FROM @B.PMF@ TO @A.PAS@,
AND WILL WRITE OUT THE DEFINITIONS FROM THE PROCESSING ONTO LIBRARY FILE
@A.PML@.
*THE SECOND COMMAND WILL PERFORM MACRO PROCESSING FROM @D.PMF@ TO @D.PAS@.
*THE THIRD AND FOURTH COMMAND LINES DO NOT CAUSE ANY MACRO PROCESSING, SO
THE EFFECT OF THE FIFTH COMMAND LINE IS TO WRITE THE DEFINITIONS FROM
@D.PAS@ ONTO LIBRARY FILE @L1.PML@.
*IF THE FILE NAME @L1@ HAD NOT BEEN SPECIFIED, THE DEFINITIONS WOULD HAVE
BEEN WRITTEN TO @D.PML@.
$PAGE
8.6\\&/@DUMP@:DUMP\DESCRIPTOR\LIST&
$SKIP 1
$PARA 5
*THE /@DUMP@ SWITCH IS USED TO OBTAIN DETAILED INFORMATION ABOUT AN ERROR
THAT OCCURRED DURING MACRO PROCESSING.
*LIKE THE /@SAVE@ SWITCH, THE /@DUMP@ SWITCH MAY APPLY EITHER TO THE CURRENT
COMMAND LINE, IF IT CAUSES MACRO PROCESSING TO BE PERFORMED, OR TO THE
MOST RECENTLY PROCESSED PROGRAM.
*IT IS IGNORED UNLESS A MACRO ERROR OCCURRED DURING THE PROCESSING OF THAT
PROGRAM.
*THE USE OF THE /@DUMP@ SWITCH IS DESCRIBED IN SECTION 9.3 (*USING THE
/@DUMP@ *SWITCH).
$SKIP 2
8.7\\&/@SET@:SWITCH:VALUE&
$SKIP 1
$PARA 5
*THE /@SET@ SWITCH IS USED TO MODIFY THE DEFAULT SWITCH SETTINGS FOR
SUBSEQUENT COMMAND LINES.
*THE SWITCH ARGUMENT MUST BE A LEGAL COMMAND SWITCH; AND IF THE VALUE ARGUMENT
IS SPECIFIED, IT MUST BE A LEGAL VALUE FOR THAT SWITCH.
*ONCE A SWITCH HAS BEEN SET WITH /@SET@, IT WILL AUTOMATICALLY BE APPLIED TO
ALL SUBSEQUENT COMMAND LINES, UNLESS IT IS OVERRIDEN WITH ANOTHER /@SET@ OR
EXPLICITLY SPECIFIED ON A COMMAND LINE.
*NOTE THAT A DEFAULT SWITCH SETTING FROM /@SET@ DOES NOT TAKE EFFECT UNTIL
THE &NEXT& COMMAND LINE.
$SKIP 1
*EXAMPLE:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
*/SET:LIB:SYSTEM
*/SET:COMPILE:NOS,TR,P
*FILE1
*FILE2/NOLIB
*FILE3/NOMACRO
*FILE4/LIB:USER/NOCOMPILE
*/EXIT
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 1
*THESE ARE EQUIVALENT TO THE COMMANDS:
$SKIP 1
$VERBATIM
$INDENT LEFT +5
$DECAP OFF
*FILE1/LIB:SYSTEM/COMPILE:NOS,TR,P
*FILE2/COMPILE:NOS,TR,P
*FILE3/LIB:SYSTEM/COMPILE:NOS,TR,P/NOMACRO
*FILE4/LIB:USER
*/EXIT/LIB:SYSTEM/COMPILE:NOS,TR,P
$DECAP ON
$INDENT LEFT -5
$JUSTIFY
$SKIP 2
8.8\\&/@EXIT@&
$SKIP 1
$PARA 5
@PMF@ WILL TERMINATE IMMEDIATELY WHEN IT READS A COMMAND LINE CONTAINING A
/@EXIT@ SWITCH.
*NO OTHER PROCESSING WILL BE PERFORMED ON THE COMMAND LINE.
*A BLANK LINE FROM THE TERMINAL IS EQUIVALENT TO A /@EXIT@ SWITCH.
$FOOTNOTE '28 *APRIL 1978                                           *ERROR *HANDLING'
$PAGE
9.\\&*ERROR *HANDLING&
$SKIP 1
9.1\\&*COMMAND *ERRORS&
$INDENT LEFT +5
$SKIP 1
$PARA -5
@%\BAD INDIRECT FILE@ <NAME>.
*AN INPUT LINE FROM THE TERMINAL HAD THE FORM '@@FILE NAME', BUT THE SPECIFIED
FILE DIDI NOT EXIST OR WAS EMPTY.
$SKIP 1
$PARA -5
@%\BAD INPUT FILE@ <NAME>.
*THE SPECIFIED INPUT FILE IN A COMMAND LINE DID NOT EXIST OR WAS EMPTY.
$SKIP 1
$PARA -5
@%\BAD LIBRARY FILE@ <NAME>.
*THE LIBRARY FILE FOR A /@LIB@ SWITCH DID NOT EXIST OR WAS EMPTY, OR THE
LIBRARY FILE NAME FOR A /@SAVE@ SWITCH WAS INVALID.
*A /@LIB@ SWITCH ERROR SUPPRESSES ANY PROCESSING OF THE REMAINDER OF THE COMMAND
LINE.
*A /@SAVE@ SWITCH ERROR ONLY PREVENTS THE WRITING OF THE LIBRARY FILE.
$SKIP 1
$PARA -5
@%\BAD OUTPUT FILE@ <NAME>.
*THE SPECIFIED OUTPUT FILE NAME IN A COMMAND LINE WAS INVALID.
$SKIP 1
$PARA -5
@%\NESTED INDIRECT COMMAND IGNORED@.
*INDIRECT COMMAND FILE SPECIFICATIONS ('@@FILE NAME') MAY ONLY BE ENTERED
FROM THE TERMINAL.
*IF ONE IS FOUND IN A COMMAND FILE, IT WILL BE IGNORED.
$SKIP 1
$PARA -5
@%\TOO MANY OPTIONS@.
*NO MORE THAN SEVEN SWITCHES MAY BE SPECIFIED ON A COMMAND LINE.
*A COMMAND LINE WITH MORE THAN SEVEN SWITCHES WILL NOT BE PROCESSED AT ALL.
$SKIP 1
$PARA -5
@%\UNKNOWN OPTION /@<NAME>.
*AN UNRECOGNIZABLE SWITCH WAS FOUND ON THIS COMMAND LINE.
*THIS COMMAND LINE WILL NOT BE PROCESSED, EXCEPT THAT ANY /@SET@ SWITCHES WHICH
PRECEDED THE INVALID SWITCH IN THE COMMAND LINE WILL ALREADY HAVE BEEN
PROCESSED.
$INDENT LEFT -5
$SKIP 2
9.2\\&*MACRO *PROCESSING *ERRORS&
$SKIP 1
$PARA 5
*WHEN @PMF@ DETECTS AN ERROR DURING MACRO PROCESSING, IT WILL IMMEDIATELY
STOP PROCESSING THE INPUT FILE AND PRINT AN ERROR MESSAGE.
*THE MESSAGE WILL GIVE AN ERROR DESCRIPTION, AND FOR SOME ERRORS WILL IDENTIFY
THE MACRO THAT WAS BEING PROCESSED WHEN THE ERROR OCCURRED AND THE ARGUMENTS
WITH WHICH THE MACRO WAS CALLED.
(*ONLY THE FIRST SIXTY CHARACTERS OF EACH ARGUMENT WILL BE DISPLAYED.)
*THE INPUT LINE WHICH WAS BEING PROCESSED WILL ALSO BE DISPLAYED, WITH A FLAG
AT THE POINT WHERE THE ERROR WAS DETECTED.
$SKIP 1
$PARA 5
*THE ERROR MESSAGES GIVEN BY @PMF@ ARE:
$INDENT LEFT +5
$SKIP 1
$PARA -5
@%\BAD LIBRARY FILE IN CALL TO@ <MACRO>.  @PMF@ WAS UNABLE TO OPEN THE
SPECIFIED LIBRARY FILE, DUE TO A BAD NAME, A NON-EXISTENT INPUT FILE, OR
SOME OTHER ERROR.  *THE ARGUMENTS OF THE MACRO CALL WILL BE PRINTED.
$PAGE
$PARA -5
@%\BAD NUMERIC EXPRESSION IN ARG LIST FOR@ <MACRO>.  *SOME ARGUMENT WHICH IS
REQUIRED TO BE AN ARITHMETIC EXPRESSION CONTAINED A CHARACTER OTHER THAN
A DIGIT OR ARITHMETIC OPERATOR, OR HAD A SPACE IN THE MIDDLE OF A NUMBER.
*THE ARGUMENTS OF THE MACRO CALL WILL BE PRINTED.
$SKIP 1
$PARA -5
@%\BAD SYMBOL IN ARG LIST FOR@ <MACRO>.  *A NAME PARAMETER IN A CALL TO ONE OF
THE DEFINITION MACROS WAS NOT A LEGAL MACRO OR PARAMETER NAME.  *THE ARGUMENTS
TO THE CALL WILL BE PRINTED.
$SKIP 1
$PARA -5
@%\COMMENT LINE TOO LONG@.  @PMF@ CANNOT HANDLE A LINE CONTAINING MORE THAN 256
CHARACTERS OF COMMENT TEXT.
$SKIP 1
$PARA -5
@%\END OF FILE IN ARG LIST FOR@ <MACRO>.  @PMF@ HAS ENCOUNTERED THE END OF
THE INPUT FILE WHILE IT WAS SCANNING THE ARGUMENT LIST FOR A CALL ON THE
INDICATED MACRO.  *SUCH ARGUMENTS AS HAD ALREADY BEEN COLLECTED WILL BE
PRINTED.
$SKIP 1
$PARA -5
@%\END OF FILE IN COMMENT@.  @PMF@ HAS ENCOUNTERED THE END OF THE INPUT
FILE WHILE IT WAS IN THE MIDDLE OF A COMMENT.
$SKIP 1
$PARA -5
@%\END OF FILE IN QUOTED TEXT@.  @PMF@ ENCOUNTERED THE END OF THE INPUT FILE
WHILE SCANNING TEXT ENCLOSED IN TEXT STRING QUOTES (<:\...\:>).
$SKIP 1
$PARA -5
@%\END OF LINE IN LITERAL STRING@.  @PMF@ HAS ENCOUNTERED THE END OF AN INPUT
LINE WHILE IT WAS SCANNING A *PASCAL CHARACTER STRING LITERAL.
$SKIP 1
$PARA -5
@%\INPUT STACK OVERFLOW@.  @PMF@ HAS SAVED UP MORE THAN 5000 CHARACTERS OF
TEXT TO BE RE-SCANNED.  *THIS ERROR PROBABLY INDICATES EXCESSIVE (POSSIBLY
INFINITE) RECURSION IN SOME MACRO EXPANSION.
$SKIP 1
$PARA -5
@%\LITERAL STRING TOO LONG@.  @PMF@ CANNOT READ A *PASCAL CHARACTER STRING
LITERAL WHICH IS LONGER THAN 256 CHARACTERS, INCLUDING ALL THE QUOTE MARKS.
$SKIP 1
$PARA -5
@?\PMF FAILURE-BAD ARG INDEX IN CALL TO@ <MACRO>.  *THIS MESSAGE INDICATES
THAT AN ERROR HAS OCCURRED IN @PMF@ ITSELF.  *PLEASE REPORT THIS PROBLEM
FOR CORRECTION.
$SKIP 1
$PARA -5
@%\TEMP STACK OVERFLOW@.  *A MACRO NAME WAS FOLLOWED BY TOO MANY CHARACTERS
OF SPACING, NEW-LINES, AND COMMENTS.  *SINCE THE INPUT STACK AND THE TEMP
STACK SHARE THE SAME STACK AREA, THIS MESSAGE IS PROBABLY DUE TO EXCESSIVE
MACRO CALL RECURSION.
$SKIP 1
$PARA -5
@%\TOKEN TOO LONG@.  @PMF@ CANNOT READ A TOKEN LONGER THAN 256 CHARACTERS.
$SKIP 1
$PARA -5
@%\TOO FEW ARGUMENTS IN CALL TO@ <MACRO>.  *A REQUIRED ARGUMENT WAS OMITTED IN
A CALL TO THE INDICATED MACRO.
$SKIP 1
$PARA -5
@%\UNDEFINED MACRO NAME IN CALL TO@ <MACRO>.  *A MACRO NAME PARAMETER IN A CALL
TO ONE OF THE DEFINITION MACROS HAS NOT BEEN DEFINED PREVIOUSLY.  *THE
ARGUMENTS TO THE CALL WILL BE PRINTED.
$SKIP 1
$PARA -5
@%\UNMATCHED STRING QUOTES IN ARGUMENT TO@ <MACRO>.
*AN ARGUMENT IN A CALL ON THE SPECIFIED MACRO WAS MARKED WITH AN EVALUATION
FLAG, BUT WHEN IT WAS EVALUATED, THE RESULTING TEXT CONTAINED AN UNMATCHED
LEFT STRING QUOTE BRACKET (<: ...).
*THE ARGUMENTS TO THE CALL WILL BE PRINTED.
$INDENT LEFT -5
$SKIP 2
9.3\\&*USING THE /@DUMP@ *SWITCH&
$SKIP 1
$PARA 5
*DURING MACRO PROCESSING, @PMF@ KEEPS A STACK OF ALL LITERAL AND MACRO
CALLS WHICH ARE CURRENTLY BEING EXPANDED, OR FOR WHICH ARGUMENTS ARE
CURRENTLY BEING COLLECTED.
*A MACRO OR LITERAL NAME IS PUSHED ONTO THIS STACK WHEN IT IS SEEN IN THE
INPUT, AND IS POPPED OFF THE STACK WHEN @PMF@ RETURNS TO THE INPUT AFTER
HAVING PROCESSED ALL OF THE EXPANSION TEXT FOR THE CALL.
*THUS, THE TOP-MOST ENTRY IN THE STACK IS THE MOST RECENTLY CALLED MACRO,
AND THE BOTTOM OF THE STACK IS THE MACRO WHICH WAS ENTERED FIRST.
*WHEN A MACRO PROCESSING ERROR OCCURS, THE CONTENTS OF THIS STACK MAY BE OF
VALUE IN DEBUGGING YOUR MACRO DEFINITIONS.
*THE /@DUMP@ SWITCH ALLOWS YOU TO SELECTIVELY EXAMINE THIS MACRO CALL STACK.
$SKIP 1
$PARA 5
*THE /@DUMP@ SWITCH TAKES A DUMP DESCRIPTOR LIST AS AN ARGUMENT.
*THIS DUMP DESCRIPTOR LIST SIMPLY CONSISTS OF ONE OR MORE DUMP DESCRIPTORS.
*EACH DUMP DESCRIPTOR CONSISTS OF AN OPERATOR AND A SELECTOR.
*THE OPERATOR IS ONE OF THE LETTERS '*S', '*D', OR '*A'.
*THE '*S' OPERATOR DISCARDS MACRO CALLS FROM THE TOP OF THE STACK, DOWN TO THE
ONE SPECIFIED BY THE SELECTOR.
*THE '*D' OPERATOR LISTS THE NAMES OF THE MACROS ON THE TOP OF THE STACK, DOWN
TO THE ONE SPECIFIED BY THE SELECTOR, AND DISCARDS THEM.
*THE '*A' OPERATOR IS THE SAME AS THE '*D' OPERATOR, EXCEPT THAT IF ARGUMENTS
WERE BEING COLLECTED FOR A MACRO CALL, THEN THE ARGUMENTS WILL BE LISTED ALONG
WITH THE MACRO NAME (UP TO SIXTY CHARACTERS EACH).
*IF THE SELECTOR IS AN INTEGER, N, IT MEANS TO APPLY THE OPERATOR TO THE
TOP-MOST N MACROS ON THE STACK.
*IF THE SELECTOR IS AN INTEGER PRECEDED BY A MINUS SIGN, -N, IT MEANS TO
APPLY THE OPERATOR TO ALL MACROS ON THE STACK, DOWN TO BUT NOT INCLUDING THE
N-TH CALL FROM THE BOTTOM.
*A SELECTOR MAY BE A SINGLE QUOTE MARK FOLLOWED BY A MACRO NAME, 'NAME,
WHICH CAUSES THE OPERATOR TO BE APPLIED TO ALL MACROS ON THE STACK DOWN TO,
BUT NOT INCLUDING, THE TOP-MOST (MOST RECENTLY ENTERED) CALL TO THE MACRO
WITH THE SPECIFIED NAME; OR IT MAY BE A MINUS SIGN FOLLOWED BY A QUOTE MARK
AND A MACRO NAME, -'NAME, MEANING TO APPLY THE OPERATOR TO ALL MACROS DOWN
TO, BUT NOT INCLUDING, THE BOTTOM-MOST (FIRST ENTERED) CALL TO THE NAMED
MACRO.
*A MACRO NAME SELECTOR WHICH REFERS TO A MACRO WHOSE NAME IS NOT ON THE STACK
IS EQUIVALENT TO A SELECTOR OF "0", REGARDLESS OF WHETHER IT IS PRECEDED BY
A MINUS SIGN.
*A MACRO NAME SELECTOR MAY BE FOLLOWED BY A PLUS OR MINUS SIGN FOLLOWED BY
AN INTEGER, +N OR -N, TO SELECT THE CALL WHICH IS N ENTRIES ABOVE OR BELOW THE
NAMED MACRO IN THE STACK, RESPECTIVELY.
*INTEGER ARGUMENTS MAY BE OMITTED, IN WHICH CASE THEY ARE ASSUMED TO BE ZERO.
*THE ENTIRE DUMP DESCRIPTOR LIST MAY BE OMITTED FROM THE /@DUMP@ SWITCH, WHICH
IS EQUIVALENT TO SPECIFYING "*D-0" (THAT IS, PRINT ALL THE MACRO NAMES IN THE
STACK).
$PAGE
$PARA 5
*THE DESCRIPTOR "*D3" MEANS, LIST THE NAMES OF THE TOP THREE MACROS ON THE
STACK, AND REMOVE THEM FROM THE STACK.
"*A-6" MEANS TO PRINT THE NAMES OF ALL BUT THE BOTTOM SIX MACROS ON THE STACK,
PRINT THEIR ARGUMENTS IF THEY WERE COLLECTING ARGUMENTS, AND REMOVE THEM FROM
THE STACK.
"*S3*D3" MEANS TO DISCARD THE TOP THREE MACROS FROM THE STACK, AND THEN PRINT
THE NAMES OF AND DISCARD THE NEXT THREE.
"@A'TEST1@" MEANS TO PRINT THE NAMES AND ARGUMENTS OF ALL MACROS DOWN TO THE
TOP-MOST CALL TO @TEST1@.
"@S-'LISTER+2D-0@" WILL PRINT THE MACRO NAMES IN THE STACK, FROM THE SECOND
MACRO ABOVE THE FIRST CALL TO @LISTER@, DOWN TO THE BOTTOM OF THE STACK.
   a