#DOCUMENT(MDSI Pascal Version 2A,<:9 September, 1982:>,45)
#MEMO(All Ann Arbor Employees,Nancy J. Egan/Development Software,<:9 September, 1982:>,
MDSI Pascal Version 2A)
#SECT(Release Schedule)
#PAR
Version 2A of MDSI Pascal is now availale on account [52250,261] on
ADP systems 12 and 13, along with compatible versions of the Pascal library
(PASLIB), debugger, utilities library (RDLIB), and utilities.  If
no serious problems are reported with the new compiler system by
???, then between ?? and ?? on ???:
*** What date will it be released?
#BEGINITEM()
#ITEM()
Version 1V(231) of the compiler system will be removed from account
[52250,234].
#ITEM()
Version 2(345) of the compiler system will be transferred from account
[52250,220] to account [52250,234].
#ITEM()
Version 2A of the compiler system will be transferred from account
[52250,261] to account [52250,220].  Version 2A will also remain
on account [52250,261] until ???.
#ENDITEM()
#PAR()
This schedule is tentative.  For updates and further details, check
the message file RELEAS.NOT[52250,261].
#PAR()
Code generated by version 2A of the compiler is compatible with code
generated by version 2.  A few source code changes are required to
use the new compiler with existing source modules.  These are as follows:
#BEGINITEM()
#ITEM()
All references to the switch [NO]LIBRARY should be removed.
#ITEM()
The DATAMODULE keyword should be changed to the MODULE keyword.
#ITEM()
Generic arrays can no longer be used.  This affects only programs
compiled for the DEC-10 systems.
#ITEM()
NEW no longer implicitly initializes the storage allocated for a user.
Code which relied on this initialization must perform explicit
initialization.
#ENDITEM()
#SECT(Enhancements and Modifications)
#BEGINLEVEL
#SECT(:TARGET M68)
The new compiler fully supports the :TARGET M68 compiler command
as well as the :TARGET VAX and :TARGET P10 commands.  The
:TARGET M68 command causes code to be generated for the 
Motorola 68000.
*** F.R. 478, 464
#SECT(M68 PEEPHOLE OPTIMIZER)
#SECT(/[NO]EXTLENGTH(length))
The new compiler switch, [NO]EXTLENGTH(length), allows the user to specify the
number of characters which should be checked for uniqueness on public
and external symbol declarations.  This switch causes the
compiler to warn the user when apparently unique symbols cannot be
differentiated within the given length.  Normally the compiler will check symbols
for uniqueness using the full length of the symbol.  This switch is useful since
There are symbol length limits imposed by the linkers on different machines.
#PAR()
Using the switch as follows:
#BEGINFIGURE()
/EXTLENGTH(6)
#ENDFIGURE()
will cause the compiler to warn the user that the symbols
PARSE_RECORD and PARSE_COMMAND are not unique within the given length
of 6 characters.
#PAR()
The length given must be between 1 and 255.  NOEXTLENGTH is the
default and uses the full length of the symbol for uniqueness checking.
*** F.R. 500
#SECT(/HELP SWITCH)
#PAR()
The new compier switch, /HELP, prints instructions on the use of the compiler.
The form "/HELP" prints a basic message, "/HELP:*" prints all available
information, and "/HELP:name" or "/HELP:(name1,name2,...,name-n)" prints
information on selected topics.
*** F.R. 449
#SECT(/CHECK:STACK suboption)
*** F.R. 471
#SECT(/RUN:file-name switch)
The /RUN:file-name switch directs the compiler to run the specified file.
The default ersatz :SYS is used unless some other device or ersatz is
specified.  If a PPN is specified, the device must also be specified.   
This switch is useful when the compiler is run from another program.  At
the end of the the .COM file read by the compiler "/RUN:LINK" may be
specified to run the linker.  This allows the ability to chain programs together.
*** F.R. 447
#SECT(/RUNOFFSET[:offset] switch)
#PAR()
The /RUNOFFSET switch specifies a ccl offset for the program
specified with the /RUN switch.  The default offset is 0 if the
/RUNOFFSET switch is not specified.  The defaut is 1 if the [:offset]
portion is left off the switch.  This allows the use of the standard DEC convention
of ccl offsets.  An offset of 1 tells the program that it was run from
another program.  It will will then look for a .COM file for input rather
than promting for input at a terminal.
*** F.R. 447
#SECT(/NOSEARCH switch)
#PAR()
The new switch, /NOSEARCH, will cancel the effect of any previously
specified search list.
*** F.R. 446
#SECT([NO]LIBRARY switch removed)
#PAR()
The /[NO]LIBRARY switch has been removed.  Library search requests are
emitted only for main program compilations.
This switch should be removed wherever it is currently used.
*** F.R. 466
#SECT(DATAMODULE keyword removed)
#PAR()
The DATAMODULE keyword is no longer valid.  MODULE has been generalized
to not require any code in the module and thus fills the function of
the DATAMODULE keyword.
The DATAMODULE keyword should be changed to MODULE werever it is 
currently used.
*** F.R. 472
#SECT(New warning messages)
#PAR()
Warning messages are now put out by the compiler when:
#BEGINITEM()
#ITEM()
Parentheses are not used around each level of array constructors or,
#ITEM()
Octal constant are specified in the form "<number>B".
#ENDITEM()
Full parenthisization is necessary to avoid ambiguity when repeat
counts are added to the language.
*** F.R. 474
#SECT(Improved Assembly Listing)
#PAR()
The assembly listings generated for any system now cleary show all
public symbols.
*** F.R. 502
#SECT(Allocation using NEW)
NEW no longer initializes the storage it allocates to zero.
Code that relied on implicit initialization must now perform
explicit initialization.
*** F.R. 480
#SECT(Generic Arrays Removed)
#PAR()
Generic arrays are no longer valid on the DEC-10's.
Any code using generic arrays must be modified to not use them.
***F.R. 473
#SECT(Improved compiler exception handling)
#PAR()
The exception handling has been improved in all passes of the compiler.
This should give the user more useful information in the case of
a problem with the compiler.
*** F.R. 533
#SECT(TTY and TTYOUTPUT)
#PAR()
The files TTY and TTYOUTPUT are now automatically associated with the user's
terminal at the start of execution.  Any call to OPEN, RESET or REWRITE
specifying the user's terminal will associate the specified file variable with
the existing input or output file.  Such a call will change the ASCII
and RETRY options on the associated file in accordance with the options
parameter in the call.  The user's terminal would never be closed;
CLOSE(TTY) has no effect and CLOSE(TTYOUTPUT) has the same effect as BREAK(TTYOUTPUT).
#PAR()
No changes are necessary to any existing program.
*** F.R. 481
#ENDLEVEL()
#SECT(Bug Fixes)
#BEGINLEVEL()
#SECT(I/O Fixes)
#PAR()
All reported bugs on all systems have been fixed in the I/O 
routines.  In particular, the following changes have been made:
#BEGINITEM()
#ITEM()
EMPTY on a text or typed file opened for output only on the VAX
was not allowed.  The file association was incorrect and has been
fixed.
*** F.R. 517
#ITEM()
READs from a binary file opened for output only on the VAX were
allowed.  This has been corrected to result in an error.
*** F.R. 516
#ITEM()
WRITEs to a text or binary file opened for input only on the VAX were
allowed.  This has been corrected to result in an error.
*** F.R. 515
#ITEM()
Reading beyond end of file on a binary file opened with update on the
DEC-10's resulted in an illegal instruction.  The error condition is now
handled properly.
*** F.R. 506
#ITEM()
Attempting to do a number of SEEKs on typed files on the VAX sometimes
resulted in an integer overflow.  This was caused by a count of the number
of eof errors encountered.  The problem has been fixed.
*** F.R. 509
#ITEM()
Association of a file having a one character name did not work on the DEC-10's.
It now works properly.
*** F.R. 490
#ITEM()
Typed file reads were reading the minimum size of the type rather
than reading the size needed for a variable of that type.  The 
correct amount of data is now read.
*** F.R. 437
#ITEM()
Checking the status of or closing a file whose's open failed
sometimes caused unexpected results.  Better checking is now done as
to whether a file is associated or not.
*** F.R. 425
#ITEM()
A binary file read on the VAX of a flex array did not work properly.
The read did not check for flex arrays or records and read data on
top of the upperbound longword.  These reads are now handled properly.
*** F.R. 441
#ENDITEM()
#SECT(Compiler Death and Assertion Failures)
The compiler occasionally died or got unexpected assertion failures.
The following improvements have been made:
#BEGINITEM()
Problems with the compiler's register handling caused the compiler to
die or to generate bad code at times.  The register handling has
been cleaned up.
#PAR()
[  The following is a wordier description of what was in the fix
reports.  I plan to take it out.
#ITEM()
Double register compares often failed or gave bad code because the
second register of the pair was not being unlocked.  This no longer
happens.
*** F.R. 439
The code generator will now get an assertion failure if there are
no available registers when one is needed.
*** F.R. 438
The DEC-10 code generator at times got an assertion failure
on an attempt to free a register already having no uses.  This
no longer happens.
*** F.R. 456.  ]
#ITEM()
The optimizing code generator's recursive processing sometimes
would cause a PDL overflow.  This problem has been resolved.
#PAR()
[  The following is a wordier description of the Fix Report.
I plan to take it out.
Since the code generator processed the dominator tree recursively,
it would get a PDL overflow on a very deep dominator tree on the
flow graph.  The recursion has been removed and very deep dominator
trees can now be processed.
*** F.R. 435.  ]
#ITEM()
The instructions:
#BEGINFIGURE()
X:=ADDRESS(Y);  Z:=X^;
#ENDFIGURE()
did cause the compiler to get an illegal memory reference.  It now
works properly.
*** F.R. 426
#ITEM()
The compiler got an illegal memory reference on the following
sequence of code:
#BEGINFIGURE()
PROGRAM FOO;
EXCEPTION = EX1;
BEGIN  END;
#ENDFIGURE()
since there was no valid definition for the condition declaration.
This no longer kills the compiler.
*** F.R. 476
#ITEM()
An ENVIRON command specifying a nonexistant environment file no
longer causes the compiler to die.
*** F.R. 445
#ITEM()
A SEARCH list specified before a :TARGET or :ENVIRON command now
works properly.  It used to die when it tried to use the SEARCH
list.
*** F.R. 444
#ITEM()
The VAX and DEC-10 code generators got assertion failures processing the
use of aggregate constructors with trailing flex arrays.  This has been
fixed.
#PAR()
[  The following is a wordier description.  I plan to take it out.
On the VAX and DEC-10's the upperbounds of flex records, where trailing 
flex array is supplied as an aggregate constructor and so UFB is known
at compile time, are being generated in I/F as CST_REFS.  With this
change, agg_val tuples no longer have users after aggregate
expansion is performed, and reclaim can remove them, and their
usages of the operands.  This fixes assertion failures.
*** F.R. 483.  ]
#ITEM()
ANDIF/OFIF boolean expressions passed as parameters now work
properly.  They did cause assertion failures due to register counts.
*** F.R. 423
#ITEM()
Using a TYPE in an external definition before it had been declared
caused an assertion failure in the VAX code generator.  It now
works properly.
*** F.R. 534
#ITEM()
Attempting to pass a varying string to a FORTRAN external
routine no longer results in an assertion failure in the
VAX code generator.
*** F.R. 530
#ITEM()
PASS1 of the compiler no longer infinite loops on 
#BEGINFIGURE()
WITH PTR(<expression>)
#ENDFIGURE
It did not work before because the "WITH" did not refer to a record.
*** F.R. 475
#ITEM()
An assertion failure no longer results from code like:
#BEGINFIGURE()
READ(<file of X>,<ptr to flex>^:
      SIZE(<ptr to flex>^,LEN))
#ENDFIGURE()
Now only the type of the first argument to SIZE is used rather
than all information about it.
*** F.R. 428
#ENDITEM()
#SECT(Optimizing Compiler Bad Code)
#PAR()
The following changes have been made in the optimizing-code generator
to fix bugs:
#BEGINITEM()
#ITEM()
The call list of a procedure was being built backwards.  It
is now properly generated.
*** F.R. 455
#Item()
Bad code was generated for "ptr_type(constant integer)".
The code generator was trying to replace the base pointer by the value
of the base point but constants do not have target types.  The
generated code is now correct.
*** F.R. 454
#ITEM()
The assumption that an operand of any normal n-ary operator may be
freely replaced by its value caused the instructions:
#BEGINFIGURE()
X:=Y;
A:=ADDRESS(X);
#ENDFIGURE()
to assign the address of Y to A rather than the address of X.  It now
works properly.
*** F.R. 451
#ITEM()
Bad code was sometimes generated for some array subscript computations.
The type desc was being set wrong on a mem ref.  Now the array
subscripts are handled properly.
*** F.R. 442
#ITEM()
Bad code was generated for handling common display op expressions.
The mode is now being correctly set.
*** F.R. 461
#ITEM()
Bad code was generated for:
#BEGINFIGURE()
<ptr>:=PTR(<integer>-1);
#ENDFIGURE()
A full word was loaded with signed-value alignment but only 18 bits
precision was desired.  The correct code is now generated.
*** F.R. 459
#ITEM()
Code was sometimes generated which overwrote register 15, the
Pascal runtime PDA pointer.  This no longer happens.
The optimizing code generator bookeeping of register use has been improved.
At times bad code was generated because of improper handling of registers.
#PAR()
[  The following is a wordier description.  i plan to take it out.
*** F.R. 443
If op1 is loaded into a register and a register is then needed to make
op2 available, and there are no registers free, then the register
containing op1 may be displaced without allowance being made for it.
This resulted in bad code being generated.  It no longer happens.
*** F.R. 429.  ]
#ENDITEM()
#SECT(Miscellaneous Fixes)
#BEGINITEM()
#ITEM()
An attempt to read or write a flexible argument from/to a binary file
without specifying an explicit size was not diagnosed as an error by
the compiler.  The compiler now prints an error message when an
explicit size is not given.
*** F.R. 450
#ITEM()
PTR:=ADDRESS(procedure name) was allowed by the first pass of
the compiler, but was not supported by the code generators.
It is now supported by the code generators.
*** F.R. 498
#ITEM()
Passing a substring of a fixed string to a fixed string formal 
did not work properly when both strings were nonflex and the
length of the actual was greater than the length of the formal.
This now works properly.
*** F.R. 430
#ITEM()
Constant aggregate constructors containing arrays sometimes did not
get initialized properly.  They are now handled correctly.
*** F.R. 526
#ITEM()
FOR loops containing procedure calls in a main program did not
work properly.  This has been corrected.
*** F.R. 469, 507
#ITEM()
Substrings were not passed properly to nonflex nonvarying formals
on the DEC-10's if the actual substring had a fixed length 
identical to that of the formal.  They are now passed correctly.
*** F.R. 494, 495
#ITEM()
Assignment of a longword integer to a packed word field is
now handled properly when the field is unsigned but the expression
is signed on the VAX.
*** F.R. 492
#ITEM()
Packed fields in unpacked records are now having their packed
attribute taken into account on the VAX.
*** F.R. 491
Sign/size information is now correctly set for integer unary
negation and absolute value.
*** F.R. 468
#ITEM()
The VAX compiler generated code to compare integer values against
(2**31)-1 and -2**32.  Limits of an arbitrary integer expression
should be the min/max of a machine word on the target machine, not
on the host.  This has been corrected.
*** F.R. 467
#ITEM()
Runtime value checks were being generated for scalar type conversions 
even when compiled with /NOCHECK.  The checks are no longer generated.
*** F.R. 465
#ITEM()
Code for the coercion of an integer to a scalar is now properly
generated for the VAX.
*** F.R. 462
#ITEM()
Bad code was generated for aggregate constructors for flexible
arrays such as:
#BEGINFIGURE()
A^:=(fld1,fld2,...,fld-n,'string')
#ENDFIGURE()
There was not enough context information to do the expansion
properly.  These aggregate constructors are now handled properly.
*** F.R. 477, 470, 436
#ITEM()
Nested WITHs now have the usages properly transfered from the outer
WITH to the inner WITH.
*** F.R. 431
#ITEM()
Use of stack overflow conditions on the VAX will no longer result
in undefined symbols in the link.  The conditions are still not
used.
*** F.R. 453
#ITEM()
Bad code was generated for constructs like:
#BEGINFIGURE()
ORD(A^.B)
#ENDFIGURE()
where B is a pointer into a packed record.  It is now handled properly.
*** F.R. 457
#ITEM()
Calling a variable procedure now works on the VAX.  A dynamic
temporary was being allocated on the stack between pushing the
parameters and making the procedure call.
*** F.R. 496
#ITEM()
The use of "OPTIONS ASSEMBLY" on a block now causes an assembly
listing of only that block.  A listing of the entire module had 
been being generated.
*** F.R. 513
#ITEM()
Range checking is now done for <char>:=CHR(<integer>) on the
DEC-10's.
*** F.R. 532
#ITEM()
The correct code is now generated for the VAX for 
<string>:=CHR(<integer>).  CHR(<integer>) was put into a
register and a move was attempted which cannot accept a
register as a location of a string.
*** F.R. 440,452
#ITEM()
Procedure and function variables were always passed as value
parameters on the DEC-10's.  Passing them as VAR parameters
now works properly.
*** F.R. 529
#ITEM()
Concatenation of constant length substrings now uses the resulting
string length for tngth of the temporary string rather than 
using the maximum length of the string.
*** F.R. 510
#ITEM()
The upper bound word for a flex string parameter on the VAX had
been missing.  The size of the bound word was being added to the
parameter offset before alignment rather than after.  This has
been corrected.
*** F.R. 501
#ITEM()
The compiler will now diagnose references to an non-addressable
flexible non-varying string value parameter when an addressable reference
is required (e.g. ADDRESS(FOO) or WRITE(<binary-file>,FOO)).
*** F.R. 448
#ITEM()
The compiler checks a set to see if it is the null set before
generating code for a SEARCH.  If the set is null, just the
result is set up rather than making the call.  The check to
see if the set was null was incorrect and has been fixed.
*** F.R. 427
#ENDITEM()
#SECT(Debugger Fixes)
#BEGINITEM()
#ITEM()
Use of the [file] option on the .DISPLAY PAGES[module@][file]
command no longer results in an improper termination error when
it is used.
*** F.R. 527
#ITEM()
The stack is now left intact after a program failure.  Not enough
room was being requested for the debugger static area $DBBASE.
An assignment into a field near the end of that area overwrote data in
 $STBASE.  The result was at times a "FATAL DEBUGGER ERROR".
*** F.R. 508
#ITEM()
A WITH command is now remembered across single steps.
*** F.R. 488
#ITEM()
The Debugger has been modified to eliminate may machine
dependancies.
*** F.R. 463
#ENDITEM()
#ENDLEVEL()
#TOC
pOIà