$len terminal
$mar 10 $wid 79 $num off $tab 9,17,25,33,41,49,57,65
$title right 'PVM V2 Spec.' right 'February, 1981' right 'Page \'
#sect(Introduction)
This document describes the architecture of PVM V2,
a "virtual computer" (i.e., a machine architecture intended
to be interpreted in software rather than hardware).
It is our second attempt at defining such an architecture
which will be suitable for representing MDSI Pascal
programs to be interpreted on 16-bit minicomputers.
The first version is documented in "Specification of
Pascal Virtual Machine, Version 1.1" (D. Gorgen and S. Roush,
May 5, 1980).
As described in a memo to A. Kortesoja ("Results of PVM
simulator performance testing", D. Gorgen and P. Lee,
August 18, 1980),
this first attempt was determined by means of a trial
implementation to be not capable of efficient implementation
on a representative minicomputer.
$ski
Like the first version, PVM V2 has many operations and
characteristics in common with DEC's VAX-11 architecture.
Unlike the first version, it has fixed instruction formats,
that is, the opcode field determines the format as well
as the function of the instruction.
These new formats are similar to those of the
IBM 360/370 series computers.
$ski
PVM V2 is intended only for representing Pascal programs,
and therefore it has several features oriented specifically
toward block-structured languages.
These include stack operations;
lack of implicit condition code settings;
tailored CALL instructions;
and addressing modes that allow direct memory addressing,
immediate operands, base-displacement addressing, and indexing
based on data size.
$ski
The rest of this specification consists of a definitions section,
a description of the general, "underlying" architecture,
and specific descriptions of data and instruction formats
and instruction functions.
#numpagsect(1,Definitions)
#numsubsect(2,Terminology)
^UContext|U refers to the way an instruction accesses an operand.
This includes access type and data type.
The context of an instruction operand is specified by a two-character
symbol composed of the access type abbreviation followed by
the data type abbreviation.
$ski
^UAccess type|U refers to the kind of access an instruction makes
to an operand.
The possible access types are defined in the table below.
$ski $ver $need 8
Type	Abbrev	Meaning
----	------	-------
none	  -	operand is ignored
address	  a	operand's address is used (not a memory reference)
branch	  b	operand is a branch displacement
read	  r	operand is read only
modify	  m	operand is read, potentially modified and written
write	  w	operand is written
$ski $jus
^UData type|U refers to one of the basic data types of PVM V2.
These are listed below.
$ski $ver $need 9
Type	Abbrev	Meaning
----	------	-------
none	  -	instruction's operand has no data type
byte	  b	8-bit integer
word	  w	16-bit integer
longword  l	32-bit integer
quadword  q	64-bit integer
floating  f	32-bit floating point number
double	  d	64-bit floating point number
$ski $jus
#numsubsect(2,Format diagrams)
In this document, format diagrams have one bit position per
column.
Fields are separated by vertical bars; the vertical bar corresponds
to the first bit position of the field to its right.
The vertical bar at the end of the diagram is not part of
any field; it is shown one position to the right of the
end of the item.
Thus the diagram
$ski
$ver
$need 7
    Bit positions:
              1
    0123456789012345

    +---+-----------+
X:  | A |     B     |
    +---+-----------+
$jus
$ski
shows a 16-bit item whose A field (4 bits wide) spans bits 0-3
and whose B field (12 bits wide) spans bits 4-15.
#numsubsect(2,Instruction mnemonics)
Instruction mnemonics consist of from one to six letters
followed by a digit.
Their style has been borrowed from the mnemonics of the
VAX-11 architecture.
In particular, the last letter in the names of the arithmetic
and comparison instructions is the abbreviation of the data
type on which that instruction operates.
The last two letters in the names of the conversion instructions
are the abbreviations of the source and destination data
types; most of the simple transfer instructions use the last
one or two letters in the same way.
$ski
The last character of a mnemonic is always a digit;
it specifies the format of the instruction.
There are many functions which are performed by several different
instructions that differ only in their format.
$ski
In the instruction descriptions, groups of instructions
may be denoted by leaving off the digit, or by
using a lowercase "x" as a placeholder to stand for all possible characters
in its position.
#numpagsect(1,Underlying architecture)
#numsubsect(2,Address space)
Memory addresses of PVM V2 are 32 bits long.
The virtual address space is a vector of bytes (8-bit quantities)
indexed by the addresses.
Longer quantities (e.g., 2, 4, or 8 bytes) can be addressed
by specifying the address of the first byte in the quantity.
(I.e., the rest of the bytes occupy the next higher addresses.)
In this case, the first byte of the quantity is considered
the highest-order byte, and its address must be even.
$ski
The address space is divided into pages of 512 bytes each,
starting with a byte whose address is a multiple of 512.
Since PVM V2 is designed to provide demand-paged virtual
memory, any given page may or may not be resident in the
primary memory of the execution agent (the interpreter) at a given time.
When the program refers to the contents of a page,
the page will be made resident if it is not already.
This action will be invisible to the user program.
$ski
Pages have protection attributes:
they may be independently protected against reading, writing,
or execution.
An attempt by the program to violate protection will cause an exception.
#numsubsect(2,Runtime stack)
An area of virtual memory of a running program is reserved
for a runtime stack.
This stack is manipulated by the subprogram call and return
instructions, and the stack control instructions.
It grows in the direction of increasing virtual addresses.
There are two internal registers used to maintain this stack:
the stack pointer (SP), which is not directly accessible
by user programs, and the frame pointer (FP), which is
usable as a base register only.
These registers are described in the next section.
$ski
No special checking is done to detect stack overflow or underflow.
However, if the stack area is bounded by protected pages,
these stack errors will be detected as protection violations.
#numsubsect(2,Registers)
#numsubsect(3,Internal registers)
PVM V2 has three special purpose longword registers whose effects
are visible to the user program:
the program counter (PC), the stack pointer (SP),
and the frame pointer (FP).
The program counter holds the virtual address of the instruction
being executed; the point in the execution cycle at which it is
updated is not defined, but transfers of control take precedence
over sequential execution, of course.
$ski
As mentioned above, the SP and FP are used to maintain
the runtime stack.
This stack grows in the direction of increasing addresses;
stack space is allocated or deallocated in longword units,
therefore the SP and FP, which contain the addresses of
certain special cells in the stack, always have values divisible
by four.
The SP always contains the address of the topmost longword
in the stack (the latest pushed).
It is updated by the ADJSP, SETSP, CALLSx, JSB, RET, RSB and
PUSHx instructions.
The FP contains the address of the current stack frame,
a structure created by the CALLSx instruction and deleted
by the RET instruction.
Within a stack frame, information local
to a procedure activation is kept.
The FP is updated by these two instructions, and can
be used as a base register in instructions that use
base-displacement addressing.
#numsubsect(3,Program registers)
Fifteen general purpose registers, each 32 bits wide, are provided for use as
local storage, temporary locations and base and index registers.
These registers are named R1 through R15.
In addition, there is a register, called R0,
which is defined always to hold the current frame pointer.
This register can be used only as a base register.
$ski
Instructions that reference registers as source operands
(read access type) can do so with any context.
Instructions that reference registers as destination operands
(modify or write access type) always do so
with longword or quadword (or floating or double) context.
When the context is shorter than longword, the low-order part
of the longword register is used.
When the context is eight bytes long, the register referred to is the high-order
part of the quadword, and the next succeeding register is the
low-order part.
References to R15 as a quadword
have unpredictable effects.
$ski
A value of zero in a base or index register field
has a special meaning, as explained later.
#numsubsect(2,Condition codes)
The PVM V2 architecture includes three condition codes,
named N, Z and C, which store information about the last
test or compare instruction for use by conditional
branch instructions.
These codes are global to a program activation.
Their setting and use are described in detail with
the individual instruction descriptions.
#numsubsect(2,Exceptions)
PVM V2 can cause three types of exceptions:
arithmetic exceptions, user exceptions, and miscellaneous exceptions.
An exception causes control to be forced from its
current location.
Where or whether control returns to the user program
depends on what functions of the runtime exception manager
have been invoked by the user program.
The PVM V2 runtime interface is documented elsewhere.
$ski
The following table lists the possible exceptions
and the instructions that can cause them.
$ski $ver $need 21
Exception			Instructions
---------			------------
Arithmetic:
  Integer divide by zero	DIVi,MODi
  Floating overflow		ADDr,SUBr,MULr,DIVr
  Floating divide by zero	DIVr
  Floating underflow		MULr,DIVr

User:
  Value				CHKRNG
  Subscript			CHKSUB
  Substring			CHKSTR
  File				CHKFIL
  Pointer			CHKPTR

Miscellaneous:
  Access violation		Any instruction referencing memory
$ski $jus
where "i" can be B, W or L, and where "r" can be F or D.
#numsubsect(2,Program initialization)
At program entry, the stack looks like this:
$ski $ver $need 18
	+-------------------------------+
 SP -->	|	local variables,	|
 12(FP)	|	  static temps		|
	+-------------------------------+
  8(FP)	|    reserved for traceback	|
	+-------------------------------+
  4(FP)	|reserved for exception handling|  owned by main program
	+-------------------------------+-----------------------
 FP --> |		0		|  owned by system
	+-------------------------------+
	|		0		|
	+-------------------------------+
	|		0		|
	+-------------------------------+
	|		0		|
	+-------------------------------+
	|		0		|
	+-------------------------------+
$ski $jus
A complete stack frame is pictured in the section
on subprogram transfer instructions.
$ski
The longwords at 4(FP) and 8(FP) in the diagram above
are initially zero.
The condition codes are initially clear (zero);
the registers' initial contents are zero, except for R0
whose initial contents are the value of the initial frame pointer.
The initial value of the PC is set from a location
in the header of the image file (the file containing
a description of the initial memory contents of the PVM V2
program).
The initial PC points to a program entry field of two words.
The first word must be zero;
the second contains the number of longword cells to be allocated
for local variables and static temporaries at program entry.
Immediately following the program entry field is the
first instruction of the program.
#numpagsect(1,Formats)
#numsubsect(2,Data formats)
The basic data types of PVM V2 are integer and floating point,
each of which come in different lengths.
Integers may be 8, 16, 32 or 64 bits in length, called
"byte," "word," "longword," and "quadword," and abbreviated
B, W, L and Q, respectively.
Depending on the instruction, they may be interpreted as
signed two's complement integers, unsigned magnitudes, or simple
bit strings.
Floating point numbers may be 32 or 64 bits long, called
"floating" and "double floating," and abbreviated F and D.
Their formats are as follows:
$ski
$ver
$need 11
    Bit positions:
              1         2         3         4         5         6
    0123456789012345678901234567890123456789012345678901234567890123

    ++------+-----------------------+
F:  S| Expn |       Fraction        |
    ++------+-----------------------+

    ++------+-------------------------------------------------------+
D:  S| Expn |                       Fraction                        |
    ++------+-------------------------------------------------------+
$jus
$ski
The representation is sign-magnitude, excess-64 exponent of 16,
with the implicit binary point just to the left of the fraction field.
The results of floating point operations are kept normalized,
so that at least one of the high-order four bits of the fraction
is a 1, unless the number is floating zero.
Floating zero is represented by all bits zero.
$ski
All data items in memory longer than a byte must be word-aligned,
that is, they must start in a byte whose address is even.
#numsubsect(2,Instruction formats)
All PVM V2 instructions are multiples of 2 bytes in length.
The address of the first byte of each instruction must be even.
$ski
The following table shows the eight possible instruction
formats for PVM V2.
They are denoted by the digits 1 through 8.
Following the table are descriptions of the meanings of
the various fields.
$ver $control off
$need 41
    Bit positions:
              1         2         3         4
    012345678901234567890123456789012345678901234567
                    /               /               /
    +-------+-------+
1:  |opcode |  Br   |
    +-------+-------+
                    /               /               /
    +-------+---+---+
2:  |opcode |R1 |R2 |
    +-------+---+---+
                    /               /               /
    +-------+---+-------------------+
3:  |opcode |R1 |         I         |
    +-------+---+-------------------+
                    /               /               /
    +-------+---+---+---+-----------+
4:  |opcode |R1 | X |B1 |    D1     |
    +-------+---+---+---+-----------+
                    /               /               /
    +-------+---+---+-------------------------------+
5:  |opcode |R1 | X |               A               |
    +-------+---+---+-------------------------------+
                    /               /               /
    +-------+---+-------------------+---+-----------+
6:  |opcode |R1 |         I         |B2 |    D2     |
    +-------+---+-------------------+---+-----------+
                    /               /               /
    +-------+---+---+---+-----------+---+-----------+
7:  |opcode |R1 | X |B1 |    D1     |B2 |    D2     |
    +-------+---+---+---+-----------+---+-----------+
                    /               /               /
    +-------+-------+
8:  |opcode |sub-op |  0 <= n <= 7
    +-------+-------+
    |     arg 1     |
    +---------------+
    |      ...      |
    +---------------+
    |     arg n     |
    +---------------+
$jus $control on
$ski
The opcode field is a value from 0 to 255 which determines
the particular instruction to be executed, including its
format.
$ski
The Br field gives a branch displacement which is used
in the conditional branch instructions for transfers of
control over short distances.
If the branch is taken, the address branched to is
the address of the following word in the instruction stream,
plus the sign-extended value of the branch displacement
multiplied by two.
In other words, the displacement is the number of words
forward or backward (according to whether the displacement
is positive or negative) from the word following the
branch instruction.
$ski
The R1 and R2 fields hold values from 0 to 15 which
denote one of the general registers;
for input, the value in the register is used,
for output, the result is stored in the register.
An operand in a register may be modified in one instruction:
its current contents are used as input, then replaced by a result.
$ski
The X field holds a value from 0 to 15; if nonzero,
this denotes a register used as an index register to
modify the address specified immediately following the X field.
The value in the index register, times the size of the data
type of the operand, is added to the address that would
otherwise be used.
If the X field is zero, it is ignored; R0 cannot be used
as an index register.
$ski
The I field is 20 bits wide and holds an immediate operand.
If the data type required by the instruction is shorter
than 20 bits, the high-order part of the field is ignored.
If it is longer than 20 bits, the internal operation to
extend it to the length required depends on the data type
and instruction.
For integer operations, where the operand is
interpreted as a two's complement number,
it is sign-extended, otherwise it is zero-extended, on the left;
for floating-point operations, the field is considered to hold
the most significant part of the value, containing the sign,
exponent and most significant part of the fraction; the
value is internally extended with zeroes on the right to the
length required.
$ski
The A field contains a complete 32-bit unsigned number which
is the virtual address of the operand.
For input, the value is read from this address;
for output, the result is stored at this address.
$ski
The B1 and D1, and B2 and D2, ("base" and "displacement")
fields together specify a
virtual memory address which for input is the location
from which the value is taken and for output is
the location where the result is stored.
This address is calculated by sign-extending the 12-bit
D field to 32 bits, and internally adding it to the
contentshe register denoted by the value in the
B field (which like other register fields holds a value
from 0 to 15).
Unlike the X field, all values of the B field, including zero,
denote legal base registers.
$ski
In format 8, the sub-op field specifies a sub-function,
depending on the opcode, for the instruction.
The arg fields' interpretation depends on the opcode and sub-op;
see the section on environment interface instructions.
$ski
The X, B1 and D1 fields together may be referred to as the
M1 field, the X and A fields together as the M field,
and the B2 and D2 fields together as the M2 field.
In formats 2 through 7, the operand specified in the R1
field may be referred to as the first operand,
the operand specified in the R2, I, M1 or M field may be
referred to as the second operand, and the operand specified in
the M2 field may be referred to as the third operand.
$ski
All addresses are completely resolved before the instruction
operation begins.
#numpagsect(1,Instruction set)
#numsubsect(2,Arithmetic)
All arithmetic instructions leave their result in a register
(or register pair for double floating operations).
Unary operations move their second operand to the
destination register (first operand) as they perform the operation;
binary operations use the previous first operand contents as
the other input operand, and destroy this value when
they write the result in the register.
Note that the data transfer instructions could be considered
as unary arithmetic instructions (identity operation, possibly
with a format conversion);
they are listed separately to reduce the size of this category.
#numsubsect(3,Unary arithmetic)
$ver
LDECB4
LDECL4	MDECL2
LDECW4	MDECW2
LINCB4
LINCL4	MINCL2
LINCW4	MINCW2
LNEGB4
LNEGD4	MNEGD2
LNEGF4	MNEGF2
LNEGL4	MNEGL2
LNEGW4	MNEGW2
$ski $jus
These instructions decrement (xDECx), increment (xINCx),
and negate (xNEGx) numbers.
Lxxxx4 takes its input from memory, Mxxxx2 from a register.
#numsubsect(3,Binary arithmetic)
$ver
ADDD2	ADDD3	ADDD4
ADDF2	ADDF3	ADDF4
ADDL2	ADDL3	ADDL4
ADDW2	ADDW3	ADDW4
DIVD2	DIVD3	DIVD4
DIVF2	DIVF3	DIVF4
DIVL2	DIVL3	DIVL4
DIVW2	DIVW3	DIVW4
MODL2	MODL3	MODL4
MODW2	MODW3	MODW4
MULD2	MULD3	MULD4
MULF2	MULF3	MULF4
MULL2	MULL3	MULL4
MULW2	MULW3	MULW4
SUBD2	SUBD3	SUBD4
SUBF2	SUBF3	SUBF4
SUBL2	SUBL3	SUBL4
SUBW2	SUBW3	SUBW4
$ski $jus
These operations perform addition (ADDx), subtraction (SUBx),
multiplication (MULx), division (DIVx), and remaindering (MODx)
on two's complement integers and floating point numbers.
ADDx and MULx are of course commutative;
SUBx subtracts the second operand
from the first operand;
DIVx takes the quotient of the first operand divided by the
second operand;
and MODx takes the remainder of the first operand divided by the
second operand (with the sign of the first operand).
All these operations replace the first operand with the result.
#numsubsect(3,Shifting)
$ver
ASHL2	ASHL3
ASHQ2	ASHQ3
$ski $jus
These operations perform arithmetic shifting on the contents of
a register or register pair (the first operand),
with the number of bit positions
to shift and the direction specified by a two's complement
signed integer in the second operand.
Positive values cause a shift left with zero propagation, negative values
cause a shift right with sign propagation.
#numsubsect(3,Bitwise logical)
$ver
ANDB2	ANDB3	ANDB4
ORB2	ORB3	ORB4
$ski $jus
These operations perform boolean operations on their
operands on a bit-by-bit basis.
ANDB performs a boolean And,
and ORB performs a boolean Or.
All operations replace the first operand with the result.
#numsubsect(2,Checking)
$ver
CHKFIL4
CHKPTR4
CHKRNG7
CHKSTR7
CHKSUB7
$ski $jus
These operations perform runtime checks, causing
a user exception to occur if the check fails.
CHKFIL4 fails if the longword at the second operand can be determined from its
value to be an uninitialized file variable;
CHKPTR4 fails if the second operand can be determined from its
value to be a nil or uninitialized pointer variable;
CHKSTR7 fails if the first operand is not greater than zero,
if the second operand is negative,
or if the sum of the first and second operands minus one
is greater than the third operand;
and CHKRNG7 and CHKSUB7 both fail if the first operand is less than the
second operand or greater than the third operand.
#numsubsect(2,Comparison)
$ver
CMPB3	CMPB4
CMPD3	CMPD4
CMPF3	CMPF4
CMPL3	CMPL4
CMPRNG7
CMPW3	CMPW4
TSTB2	TSTB4
TSTD2	TSTD4
TSTF2	TSTF4
TSTL2	TSTL4
TSTW2	TSTW4
$ski $jus
These instructions affect only the condition codes,
and are used to influence the outcome of subsequent
conditional branch instructions.
CMPx compares the first operand with the second operand.
The N code will be set iff the first operand is less than
the second (signed compare);
the Z code will be set iff the operands are equal;
and the C code will be set iff the instruction is
CMPB, CMPW or CMPL and, considered as unsigned integers, the first operand
is less than the second.
CMPRNG7 compares the first operand with the second and third operands.
The Z code will be set iff the first operand is greater than or
equal to the second and less than or equal to the third (signed
comparisons).
The N and C codes will always be cleared.
$ski
TSTx2 compares the first operand with zero;
TSTx4 compares the second operand with zero.
The N code will be set iff the operand is negative;
the Z code will be set iff the operand is zero;
the C code will always be cleared.
#numsubsect(2,Control)
#numsubsect(3,Unconditional control transfer)
$ver
CASE3	CASE6
JMP5
BR3
$ski $jus
These instructions cause control to be transferred by
specifying a new value for the PC.
JMP5 causes the address of its second operand to replace the PC.
BR3 causes the PC to be replaced by the sum of the address of
the instruction following the BR3 instruction and twice the BR3 instruction's
second operand;
in effect, the next instruction executed is at the location
^Un|U words away from the immediately following instruction,
where ^Un|U is the number in the I field of the BR3 instruction.
The direction of the branch is
forward if ^Un|U is positive, backward if ^Un|U is negative.
$ski
The CASE instructions cause multi-way branching depending on the
value of a variable.
Let ^Un|U be the number in the I field of the CASE instruction.
The CASE instruction is followed in the instruction
stream by ^Un|U+1 words, each of which is a displacement to
a possible transfer destination.
The case selector, which is the first operand for CASE3
and the third operand for CASE6, determines which displacement
is used.
If the case selector is less than or
equal to ^Un|U and not negative, then the (case selector + 1)th displacement is
taken, otherwise the PC is replaced by the sum of the address
of the first displacement in the list and 2^Un|U + 2,
thus skipping the
list of displacements.
If a displacement is taken, the next instruction executed is
at the address which is the sum of the address of the first
displacement in the list and twice the value of the displacement taken.
#numsubsect(3,Branching)
$ver
BEQL1
BGEQ1
BGEQU1
BGTR1
BGTRU1
BLEQ1
BLEQU1
BLSS1
BLSSU1
BNEQ1
BR1
$ski $jus
Format 1 instructions are called branch instructions.
They cause a transfer of control by adding a signed value to
the current PC.
All except BR1 are conditional branches, that is,
they transfer control only when the condition codes
have certain values.
BR1 always transfers control.
The method of transferring control is described in the section
on instruction formats.
The conditions under which branching takes place are
described in the following table:
$ski $ver $need 12
	Instr	Condition for branching
	-----	-----------------------
	BEQL1	Z=1
	BGEQ1	N=0
	BGEQU1	C=0
	BGTR1	N=0 and Z=0
	BGTRU1	C=0 and Z=0
	BLEQ1	N=1 or Z=1
	BLEQU1	C=1 or Z=1
	BLSS1	N=1
	BLSSU1	C=1
	BNEQ1	Z=0
$jus
#numsubsect(3,Loop control)
$ver
AOBLEQ6
SOBGEQ6
$ski $jus
These instructions cause the modification of a loop control
variable and the transfer of control if the loop is not
exhausted.
The first operand is the loop control variable, the second is
a branch displacement, and the third is the iteration limit.
AOBLEQ6 increments the first operand, SOBGEQ6 decrements it.
If the first operand is then less than or equal to the iteration limit
(for AOBLEQ6), or greater than or equal to it (for SOBGEQ6),
then control is transferred by using the I field in the
same way as for the BR3 instruction.
#numsubsect(3,Stack operations)
$ver
ADJSP2	ADJSP4
SETSP4
$ski $jus
These operations allocate and deallocate space on the runtime
stack by adjusting and setting the contents of the stack pointer.
ADJSP adds to the SP a value equal to its signed
longword integer second operand.
The old value of the SP, plus four, is returned in the first operand.
This is the first address of the newly allocated area,
if the second operand was positive.
SETSP4 sets the stack pointer to the address of the second operand.
#numsubsect(3,Subprogram control transfer)
$ver
CALLSI5
CALLSO5
JSB5
RET2
RSB2
$ski $jus
These instructions transfer control while
saving context information that allows execution flow
to be restored to the instruction after the transfer at a later time.
JSB5 causes control to pass to the address of its second operand,
like JMP5, but also pushes the address of the next instruction
onto the runtime stack.
RSB2 pops a longword from the runtime stack and causes execution
to continue at the address represented in the longword,
thus returning from a subroutine called by JSB5.
The CALLSx instructions perform the same kind of transfer,
but with the creation of a new stack frame that becomes the current one;
RET2 returns control
and deletes the current stack frame.
The code transferred to by a CALLSx instruction is called
a procedure.
The following diagram shows a complete stack frame.
$ski $ver $control off $tra '\' '\'
$need 36
                       /|\
                      / | \
                        |
                  stack | higher
                 growth | addresses
                        |
                        |
        +-------------------------------+
 SP -->	|	local variables,	|
	|	  static temps		|
	+-------------------------------+
4n+8(FP)|    reserved for traceback	|
	+-------------------------------+
4n+4(FP)|reserved for exception handling|  owned by called procedure
	+-------------------------------+----------------------------
	|    saved registers R1...Rn	|  owned by calling procedure
        +-------------------------------+
 FP -->	|	  saved R0 (FP)		|
        +-------------------------------+
 -4(FP)	|  highest register saved (n)	|
        +-------------------------------+
 -8(FP)	|	     saved PC		|
        +-------------------------------+
-12(FP)	|	    static link		|
        +-------------------------------+
-16(FP)	|      argument block size	|
        +-------------------------------+
-20(FP)	|	    argument		|
	|	      block		|
        +-------------------------------+
	|	 dynamic temps		|
	|     for calling procedure	|
        +-------------------------------+
        |               .               |
        |               .               |
        |               .               |
$ski $jus $control on $tra
The CALLSx instructions create the part of the stack frame
down to "argument block size."
"Argument block" and "dynamic temps" are created by PUSHx and ADJSP
instructions within a procedure.
The RET2 instruction deletes the entire stack frame.
"Dynamic temps" may also be deleted by ADJSP or SETSP4 instructions.
$ski
The CALLSI5 and CALLSO5 instructions differ only in how they
fill in the "static link" field:
the former inserts its first operand, the latter fills in zero.
The address of the second operand of both instructions is the address
of four bytes called the entry field of the called procedure.
This address must be even.
The first byte contains the number of longword arguments
the procedure expects to find on the stack; these arguments will be popped
by the RET2 instruction.
The second byte contains the number of the highest register
to be saved in the stack frame.
The third and fourth bytes contain the number of longword local variable cells
that are to be allocated for the procedure.
Directly after the entry field is the first instruction of the
procedure.
$ski
The exact sequence of operations for the CALLSx instructions is
as follows.
The unsigned byte value at the entry field address is
zero-extended to longword size and pushed
on the stack.
The static link (first operand or zero, as explained above) is
pushed on the stack.
The address of the instruction following the CALLSx is pushed on
the stack.
The unsigned byte value at the entry field address plus one
is zero-extended to longword size and pushed on the stack.
If this value is called n, then
registers R0 through Rn are pushed on the stack, in ascending order.
Two longword zeroes are pushed on the stack.
The value of four times the unsigned word value at
the entry field address plus two is added to the stack pointer.
The FP and R0 are set to the address of the longword in which R0 was saved.
The PC is replaced by the entry field address plus four.
$ski
The exact sequence of operations for the RET2 instruction is
as follows.
The longword value at -4(FP) is called n.
The SP is set to the value of the FP plus 4n.
Longwords are popped from the stack into Rn through R0;
the value popped into R0 is also copied to the FP.
A longword is popped and discarded.
A longword is popped into the PC.
A longword is popped and discarded.
A longword is popped, and its unsigned value is
multiplied by four and the result subtracted from the SP.
#numsubsect(3,Miscellaneous control functions)
$ver
BPT2
NOP2
$ski $jus
The BPT2 instruction is used only by debugging features that
may exist in some implementations of PVM V2.
When executed, it causes control to be passed to a debugging system.
The NOP2 instruction has no effect other than to update the PC
to execute the next instruction.
It might be used to patch a PVM V2 image.
#numsubsect(2,Data transfer)
#numsubsect(3,Simple transfer)
$ver
CLRB4	CLRB5
CLRL2	CLRL4	CLRL5
CLRQ2	CLRQ4	CLRQ5
CLRW4	CLRW5
LODA4	LODA5
LODL3	LODL4	LODL5	MOVL2	MOVL7	STOL4	STOL5	STOL6
LODQ3	LODQ4	LODQ5	MOVQ2	MOVQ7	STOQ4	STOQ5
LODI4	LODI5	STOI4	STOI5
LODZBL4	LODZBL5	MOVZBL2	MOVZBL7
LODZWL4	LODZWL5	MOVZWL2	MOVZWL7
MOVB7	STOB4	STOB5	STOB6
MOVW7	STOW4	STOW5	STOW6
PUSHA4	PUSHA5
PUSHL2	PUSHL3	PUSHL4	PUSHL5
PUSHQ2	PUSHQ3	PUSHQ4	PUSHQ5
PUSHI4	PUSHI5
PUSHZB4	PUSHZB5
PUSHZW4	PUSHZW5
$ski $jus
These instructions move data from memory or registers to
memory or registers.
CLRx sets an integer or floating variable to zero.
LODA puts the address of its second operand into its first operand
(a register).
LODx instructions move two's complement data from memory,
or immediate data, to registers,
MOVx instructions move data from registers to registers or
memory to memory,
and STOx instructions move data from registers, or immediate data, to memory.
LODI moves a longword to a register using the longword specified
by its second operand as the address of the longword to be loaded;
STOI moves a longword from a register to memory using the longword
specified by its second operand as the address of the location to
be written.
xxxZxL instructions extend byte or word data on the left
with zeroes to longword length as they transfer.
PUSHA pushes the address of its second operand onto the
runtime stack.
PUSHx2 pushes its first operand; PUSHx3, PUSHx4 and PUSHx5 push
their second operand;
PUSHI pushes a longword onto the stack using the longword specified by
its second operand as the address of the longword to be pushed;
PUSHZx instructions zero-extend their byte or word second operand,
like xxxZxL, as they push it.
Format 6 and 7 instructions ignore their first operand.
#numsubsect(3,Conversion)
$ver
CVTBL2	CVTBL4
CVTDF2	CVTDF4
CVTDL2	CVTDL4
CVTFD2	CVTFD4
CVTFL2	CVTFL4
CVTLD2	CVTLD4
CVTLF2	CVTLF4
CVTRDL2	CVTRDL4
CVTRFL2	CVTRFL4
CVTWL2	CVTWL4
$ski $jus
These instructions perform conversions among data types.
CVT[R]xy converts its second operand, of data type x,
to data type y and stores it in its first operand.
Integer to integer conversions (CVTBL, CVTWL) are by sign extension.
CVTDF is rounded, CVTFD is exact.
CVTLF is rounded, CVTLD is exact.
CVTFL and CVTDL are truncated, CVTRFL and CVTRDL are rounded.
#numsubsect(2,Environment interface)
$ver
SYSCAL3
XFA8
XFB8
XFC8
XFD8
XFE8
XFF8
XFG8
XFH8
$ski $jus
These instructions are for invocation of system-dependent functions
and language-defined out-of-line routines (i.e., the runtime system).
SYSCAL3 invokes a system routine corresponding to the
value in the I field of the instruction.
This routine may have side effects, including modification
of the condition codes or the runtime stack.
XFx8 performs a runtime function depending on the sub-opcode field.
The XFA8 through XFH8 instructions have zero through seven
16-bit argument fields following the opcode/sub-opcode word, respectively.
The meaning of these arguments depends on the particular function.
#pagsect(Appendix:  Lists of instructions)
This appendix lists the instruction set of PVM V2 by mnemonic
and by mnemonic within format classes.
Since the machine will be implemented in software,
little would be gained by using a fancy bit-encoding scheme
to assign opcode values to instructions;
therefore values have been assigned in alphabetical order
and the first list is also in order of opcode value.
$pag
#subsect(Instructions listed by mnemonic)
$ver
1C	ADDD	2	md,rd
1D	ADDD	3	md,rd
1E	ADDD	4	md,rd
1F	ADDF	2	mf,rf
20	ADDF	3	mf,rf
21	ADDF	4	mf,rf
22	ADDL	2	ml,rl
23	ADDL	3	ml,rl
24	ADDL	4	ml,rl
25	ADDW	2	ml,rw
26	ADDW	3	ml,rw
27	ADDW	4	ml,rw
28	ADJSP	2	wl,rl
29	ADJSP	4	wl,rl
2A	ANDB	2	ml,rb
2B	ANDB	3	ml,rb
2C	ANDB	4	ml,rb
2D	AOBLEQ	6	ml,rl,rl
2E	ASHL	2	ml,rb
2F	ASHL	3	ml,rb
30	ASHQ	2	mq,rb
31	ASHQ	3	mq,rb
32	BEQL	1	b-
33	BGEQ	1	b-
34	BGEQU	1	b-
35	BGTR	1	b-
36	BGTRU	1	b-
37	BLEQ	1	b-
38	BLEQU	1	b-
39	BLSS	1	b-
3A	BLSSU	1	b-
3B	BNEQ	1	b-
3C	BPT	2	--,--
3D	BR	1	b-
3E	BR	3	--,rl
3F	CALLSI	5	rl,ab
40	CALLSO	5	--,ab
41	CASE	3	rl,rl
42	CASE	6	--,rl,rl
43	CHKFIL	4	--,rl
44	CHKPTR	4	--,rl
45	CHKRNG	7	rl,rl,rl
46	CHKSTR	7	rl,rl,rl
47	CHKSUB	7	rl,rl,rl
48	CLRB	4	--,wb
49	CLRB	5	--,wb
4A	CLRL	2	wl,--
4B	CLRL	4	--,wl
4C	CLRL	5	--,wl
4D	CLRQ	2	wq,--
4E	CLRQ	4	--,wq
4F	CLRQ	5	--,wq
50	CLRW	4	--,ww
51	CLRW	5	--,ww
52	CMPB	3	rb,rb
53	CMPB	4	rb,rb
54	CMPD	3	rd,rd
55	CMPD	4	rd,rd
56	CMPF	3	rf,rf
57	CMPF	4	rf,rf
58	CMPL	3	rl,rl
59	CMPL	4	rl,rl
5A	CMPRNG	7	rl,rl,rl
5B	CMPW	3	rw,rw
5C	CMPW	4	rw,rw
5D	CVTBL	2	wl,rb
5E	CVTBL	4	wl,rb
5F	CVTDF	2	wf,rd
60	CVTDF	4	wf,rd
61	CVTDL	2	wl,rd
62	CVTDL	4	wl,rd
63	CVTFD	2	wd,rf
64	CVTFD	4	wd,rf
65	CVTFL	2	wl,rf
66	CVTFL	4	wl,rf
67	CVTLD	2	wd,rl
68	CVTLD	4	wd,rl
69	CVTLF	2	wf,rl
6A	CVTLF	4	wf,rl
6B	CVTRDL	2	wl,rd
6C	CVTRDL	4	wl,rd
6D	CVTRFL	2	wl,rf
6E	CVTRFL	4	wl,rf
6F	CVTWL	2	wl,rw
70	CVTWL	4	wl,rw
71	DIVD	2	md,rd
72	DIVD	3	md,rd
73	DIVD	4	md,rd
74	DIVF	2	mf,rf
75	DIVF	3	mf,rf
76	DIVF	4	mf,rf
77	DIVL	2	ml,rl
78	DIVL	3	ml,rl
79	DIVL	4	ml,rl
7A	DIVW	2	ml,rw
7B	DIVW	3	ml,rw
7C	DIVW	4	ml,rw
7D	JMP	5	--,ab
7E	JSB	5	--,ab
7F	LDECB	4	wl,rb
80	LDECL	4	wl,rl
81	LDECW	4	wl,rw
82	LINCB	4	wl,rb
83	LINCL	4	wl,rl
84	LINCW	4	wl,rw
85	LNEGB	4	wl,rb
86	LNEGD	4	wd,rd
87	LNEGF	4	wf,rf
88	LNEGL	4	wl,rl
89	LNEGW	4	wl,rw
8A	LODA	4	wl,ab
8B	LODA	5	wl,ab
8C	LODI	4	wl,rl
8D	LODI	5	wl,rl
8E	LODL	3	wl,rl
8F	LODL	4	wl,rl
90	LODL	5	wl,rl
91	LODQ	3	wq,rq
92	LODQ	4	wq,rq
93	LODQ	5	wq,rq
94	LODZBL	4	wl,rb
95	LODZBL	5	wl,rb
96	LODZWL	4	wl,rw
97	LODZWL	5	wl,rw
98	MDECL	2	wl,rl
99	MDECW	2	wl,rw
9A	MINCL	2	wl,rl
9B	MINCW	2	wl,rw
9C	MNEGD	2	wd,rd
9D	MNEGF	2	wf,rf
9E	MNEGL	2	wl,rl
9F	MNEGW	2	wl,rw
A0	MODL	2	ml,rl
A1	MODL	3	ml,rl
A2	MODL	4	ml,rl
A3	MODW	2	ml,rw
A4	MODW	3	ml,rw
A5	MODW	4	ml,rw
A6	MOVB	7	--,wb,rb
A7	MOVL	2	wl,rl
A8	MOVL	7	--,wl,rl
A9	MOVQ	2	wq,rq
AA	MOVQ	7	--,wq,rq
AB	MOVW	7	--,ww,rw
AC	MOVZBL	2	wl,rb
AD	MOVZBL	7	--,wl,rb
AE	MOVZWL	2	wl,rw
AF	MOVZWL	7	--,wl,rw
B0	MULD	2	md,rd
B1	MULD	3	md,rd
B2	MULD	4	md,rd
B3	MULF	2	mf,rf
B4	MULF	3	mf,rf
B5	MULF	4	mf,rf
B6	MULL	2	ml,rl
B7	MULL	3	ml,rl
B8	MULL	4	ml,rl
B9	MULW	2	ml,rw
BA	MULW	3	ml,rw
BB	MULW	4	ml,rw
BC	NOP	2	--,--
BD	ORB	2	ml,rb
BE	ORB	3	ml,rb
BF	ORB	4	ml,rb
C0	PUSHA	4	--,ab
C1	PUSHA	5	--,ab
C2	PUSHI	4	--,rl
C3	PUSHI	5	--,rl
C4	PUSHL	2	rl,--
C5	PUSHL	3	--,rl
C6	PUSHL	4	--,rl
C7	PUSHL	5	--,rl
C8	PUSHQ	2	rq,--
C9	PUSHQ	3	--,rq
CA	PUSHQ	4	--,rq
CB	PUSHQ	5	--,rq
CC	PUSHZB	4	--,rb
CD	PUSHZB	5	--,rb
CE	PUSHZW	4	--,rw
CF	PUSHZW	5	--,rw
D0	RET	2	--,--
D1	RSB	2	--,--
D2	SETSP	4	--,ab
D3	SOBGEQ	6	ml,rl,rl
D4	STOB	4	rb,wb
D5	STOB	5	rb,wb
D6	STOB	6	--,rb,wb
D7	STOI	4	rl,rl
D8	STOI	5	rl,rl
D9	STOL	4	rl,wl
DA	STOL	5	rl,wl
DB	STOL	6	--,rl,wl
DC	STOQ	4	rq,wq
DD	STOQ	5	rq,wq
DE	STOW	4	rw,ww
DF	STOW	5	rw,ww
E0	STOW	6	--,rw,ww
E1	SUBD	2	md,rd
E2	SUBD	3	md,rd
E3	SUBD	4	md,rd
E4	SUBF	2	mf,rf
E5	SUBF	3	mf,rf
E6	SUBF	4	mf,rf
E7	SUBL	2	ml,rl
E8	SUBL	3	ml,rl
E9	SUBL	4	ml,rl
EA	SUBW	2	ml,rw
EB	SUBW	3	ml,rw
EC	SUBW	4	ml,rw
ED	SYSCAL	3	--,rl
EE	TSTB	2	rb,--
EF	TSTB	4	--,rb
F0	TSTD	2	rd,--
F1	TSTD	4	--,rd
F2	TSTF	2	rf,--
F3	TSTF	4	--,rf
F4	TSTL	2	rl,--
F5	TSTL	4	--,rl
F6	TSTW	2	rw,--
F7	TSTW	4	--,rw
F8	XFA	8
F9	XFB	8
FA	XFC	8
FB	XFD	8
FC	XFE	8
FD	XFF	8
FE	XFG	8
FF	XFH	8
$jus
$pag
#subsect(Instructions listed by format)
$ver
$ski
Format 1:  opcode Br
$ski
32	BEQL	1	b-
33	BGEQ	1	b-
34	BGEQU	1	b-
35	BGTR	1	b-
36	BGTRU	1	b-
37	BLEQ	1	b-
38	BLEQU	1	b-
39	BLSS	1	b-
3A	BLSSU	1	b-
3B	BNEQ	1	b-
3D	BR	1	b-
$ski
Format 2:  opcode R1,R2
$ski
1C	ADDD	2	md,rd
1F	ADDF	2	mf,rf
22	ADDL	2	ml,rl
25	ADDW	2	ml,rw
28	ADJSP	2	wl,rl
2A	ANDB	2	ml,rb
2E	ASHL	2	ml,rb
30	ASHQ	2	mq,rb
3C	BPT	2	--,--
4A	CLRL	2	wl,--
4D	CLRQ	2	wq,--
5D	CVTBL	2	wl,rb
5F	CVTDF	2	wf,rd
61	CVTDL	2	wl,rd
63	CVTFD	2	wd,rf
65	CVTFL	2	wl,rf
67	CVTLD	2	wd,rl
69	CVTLF	2	wf,rl
6B	CVTRDL	2	wl,rd
6D	CVTRFL	2	wl,rf
6F	CVTWL	2	wl,rw
71	DIVD	2	md,rd
74	DIVF	2	mf,rf
77	DIVL	2	ml,rl
7A	DIVW	2	ml,rw
98	MDECL	2	wl,rl
99	MDECW	2	wl,rw
9A	MINCL	2	wl,rl
9B	MINCW	2	wl,rw
9C	MNEGD	2	wd,rd
9D	MNEGF	2	wf,rf
9E	MNEGL	2	wl,rl
9F	MNEGW	2	wl,rw
A0	MODL	2	ml,rl
A3	MODW	2	ml,rw
A7	MOVL	2	wl,rl
A9	MOVQ	2	wq,rq
AC	MOVZBL	2	wl,rb
AE	MOVZWL	2	wl,rw
B0	MULD	2	md,rd
B3	MULF	2	mf,rf
B6	MULL	2	ml,rl
B9	MULW	2	ml,rw
BC	NOP	2	--,--
BD	ORB	2	ml,rb
C4	PUSHL	2	rl,--
C8	PUSHQ	2	rq,--
D0	RET	2	--,--
D1	RSB	2	--,--
E1	SUBD	2	md,rd
E4	SUBF	2	mf,rf
E7	SUBL	2	ml,rl
EA	SUBW	2	ml,rw
EE	TSTB	2	rb,--
F0	TSTD	2	rd,--
F2	TSTF	2	rf,--
F4	TSTL	2	rl,--
F6	TSTW	2	rw,--
$ski
Format 3:  opcode R1,I
$ski
1D	ADDD	3	md,rd
20	ADDF	3	mf,rf
23	ADDL	3	ml,rl
26	ADDW	3	ml,rw
2B	ANDB	3	ml,rb
2F	ASHL	3	ml,rb
31	ASHQ	3	mq,rb
3E	BR	3	--,rl
41	CASE	3	rl,rl
52	CMPB	3	rb,rb
54	CMPD	3	rd,rd
56	CMPF	3	rf,rf
58	CMPL	3	rl,rl
5B	CMPW	3	rw,rw
72	DIVD	3	md,rd
75	DIVF	3	mf,rf
78	DIVL	3	ml,rl
7B	DIVW	3	ml,rw
8E	LODL	3	wl,rl
91	LODQ	3	wq,rq
A1	MODL	3	ml,rl
A4	MODW	3	ml,rw
B1	MULD	3	md,rd
B4	MULF	3	mf,rf
B7	MULL	3	ml,rl
BA	MULW	3	ml,rw
BE	ORB	3	ml,rb
C5	PUSHL	3	--,rl
C9	PUSHQ	3	--,rq
E2	SUBD	3	md,rd
E5	SUBF	3	mf,rf
E8	SUBL	3	ml,rl
EB	SUBW	3	ml,rw
ED	SYSCAL	3	--,rl
$ski
Format 4:  opcode R1,M1
$ski
1E	ADDD	4	md,rd
21	ADDF	4	mf,rf
24	ADDL	4	ml,rl
27	ADDW	4	ml,rw
29	ADJSP	4	wl,rl
2C	ANDB	4	ml,rb
43	CHKFIL	4	--,rl
44	CHKPTR	4	--,rl
48	CLRB	4	--,wb
4B	CLRL	4	--,wl
4E	CLRQ	4	--,wq
50	CLRW	4	--,ww
53	CMPB	4	rb,rb
55	CMPD	4	rd,rd
57	CMPF	4	rf,rf
59	CMPL	4	rl,rl
5C	CMPW	4	rw,rw
5E	CVTBL	4	wl,rb
60	CVTDF	4	wf,rd
62	CVTDL	4	wl,rd
64	CVTFD	4	wd,rf
66	CVTFL	4	wl,rf
68	CVTLD	4	wd,rl
6A	CVTLF	4	wf,rl
6C	CVTRDL	4	wl,rd
6E	CVTRFL	4	wl,rf
70	CVTWL	4	wl,rw
73	DIVD	4	md,rd
76	DIVF	4	mf,rf
79	DIVL	4	ml,rl
7C	DIVW	4	ml,rw
7F	LDECB	4	wl,rb
80	LDECL	4	wl,rl
81	LDECW	4	wl,rw
82	LINCB	4	wl,rb
83	LINCL	4	wl,rl
84	LINCW	4	wl,rw
85	LNEGB	4	wl,rb
86	LNEGD	4	wd,rd
87	LNEGF	4	wf,rf
88	LNEGL	4	wl,rl
89	LNEGW	4	wl,rw
8A	LODA	4	wl,ab
8C	LODI	4	wl,rl
8F	LODL	4	wl,rl
92	LODQ	4	wq,rq
94	LODZBL	4	wl,rb
96	LODZWL	4	wl,rw
A2	MODL	4	ml,rl
A5	MODW	4	ml,rw
B2	MULD	4	md,rd
B5	MULF	4	mf,rf
B8	MULL	4	ml,rl
BB	MULW	4	ml,rw
BF	ORB	4	ml,rb
C0	PUSHA	4	--,ab
C2	PUSHI	4	--,rl
C6	PUSHL	4	--,rl
CA	PUSHQ	4	--,rq
CC	PUSHZB	4	--,rb
CE	PUSHZW	4	--,rw
D2	SETSP	4	--,ab
D4	STOB	4	rb,wb
D7	STOI	4	rl,rl
D9	STOL	4	rl,wl
DC	STOQ	4	rq,wq
DE	STOW	4	rw,ww
E3	SUBD	4	md,rd
E6	SUBF	4	mf,rf
E9	SUBL	4	ml,rl
EC	SUBW	4	ml,rw
EF	TSTB	4	--,rb
F1	TSTD	4	--,rd
F3	TSTF	4	--,rf
F5	TSTL	4	--,rl
F7	TSTW	4	--,rw
$ski
Format 5:  opcode R1,M
$ski
3F	CALLSI	5	rl,ab
40	CALLSO	5	--,ab
49	CLRB	5	--,wb
4C	CLRL	5	--,wl
4F	CLRQ	5	--,wq
51	CLRW	5	--,ww
7D	JMP	5	--,ab
7E	JSB	5	--,ab
8B	LODA	5	wl,ab
8D	LODI	5	wl,rl
90	LODL	5	wl,rl
93	LODQ	5	wq,rq
95	LODZBL	5	wl,rb
97	LODZWL	5	wl,rw
C1	PUSHA	5	--,ab
C3	PUSHI	5	--,rl
C7	PUSHL	5	--,rl
CB	PUSHQ	5	--,rq
CD	PUSHZB	5	--,rb
CF	PUSHZW	5	--,rw
D5	STOB	5	rb,wb
D8	STOI	5	rl,rl
DA	STOL	5	rl,wl
DD	STOQ	5	rq,wq
DF	STOW	5	rw,ww
$ski
Format 6:  opcode R1,I,M2
$ski
2D	AOBLEQ	6	ml,rl,rl
42	CASE	6	--,rl,rl
D3	SOBGEQ	6	ml,rl,rl
D6	STOB	6	--,rb,wb
DB	STOL	6	--,rl,wl
E0	STOW	6	--,rw,ww
$ski
Format 7:  opcode R1,M1,M2
$ski
45	CHKRNG	7	rl,rl,rl
46	CHKSTR	7	rl,rl,rl
47	CHKSUB	7	rl,rl,rl
5A	CMPRNG	7	rl,rl,rl
A6	MOVB	7	--,wb,rb
A8	MOVL	7	--,wl,rl
AA	MOVQ	7	--,wq,rq
AB	MOVW	7	--,ww,rw
AD	MOVZBL	7	--,wl,rb
AF	MOVZWL	7	--,wl,rw
$ski
Format 8:  opcode subop
$ski
F8	XFA	8
F9	XFB	8
FA	XFC	8
FB	XFD	8
FC	XFE	8
FD	XFF	8
FE	XFG	8
FF	XFH	8
$jus
$title off $top 3 $bot 3
#toc
 dwSM¯