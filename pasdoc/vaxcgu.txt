VAXCGU.TXT, last modified 10/24/83, zw

Improvement of Generated VAX Code...

There is a great deal of room for improvement in the  quality  of  the
code  generated  by  the  existing  VAX  cross-compiler.  Some of this
improvement could only be realized via a code generator  which  worked
in  conjunction  with  the  Pascal  optimizer  routines.  The benefits
possible via an optimizer will  not  be  discussed  here,  except  for
mention   of  the  following  two  points.  First  the  existing  code
generator already works harder at generating locally high quality code
than   the  old  Pascal  PDP-10  compiler.  Thus  the  30%  code  size
improvement achieved with the optimizer would probably not be achieved
with  the VAX cross-compiler.  Second, the VAX does have the advantage
that optimizations which  produced  only  a  speed  advantage  on  the
PDP-10,  will  produce  a  space  advantage  as  well on the VAX.  For
example, more intelligent usage of registers is particularly  valuable
on  the  VAX  since  register  addresses  require only a singe byte to
specify.

A second approach to improving the quality of the VAX  code  generated
would  be  to  simply improve the quality of the local code generated.
There are a large number of improvements possible which fall into this
category.  Taken individually, any of these changes would produce very
modest code  size  reductions.  In  aggregate  the  improvement  would
probably  be  substantial,  but  a priori is difficult to quantify.  A
disadvantage to this approach is that a large  number  of  distributed
changes are required.

A  third  category of possible improvements will be considered in more
detail.  These changes are particularly attractive because they  offer
the  potential for a fairly large payoff with relatively minor changes
to the VAX code generator.  The first two techniques attempt to reduce
the  number of large operand specifiers.  Operands on the VAX range in
size from one to five bytes.  Five byte addresses  include  references
to  the  constant  area,  the  static  area, external data references,
external procedure references and runtime routine  references.  Static
area  references are currently done via longword displacements off the
program counter.  An alternative would be to load the address  of  the
relevant  static  area  into  a register on entry to a procedure.  The
variable could then be referenced via a known,  and  generally  small,
offset  from  the  register.  The  percentage  reduction  in code size
achievable via this technique was determined with a program which read
the  assembly  listing  files  of the sample programs.  The percentage
improvement  was  calculated  based  on  the  actual   size   of   the
displacement  into the static area for each reference.  The assumption
was made that a static area register would only be used if it actually
resulted in a reduction in the code size (for byte displacements, this
requires  three  or  more  static  area  references).  The  code  size
reductions  possible  ranged  from zero to 6.7%.  The sample of DESIGN
programs contained no  static  area  references  and  thus  would  not
benefit  at  all  from  this technique.  Three of the five ANC modules
also would not benefit at all.  The remaining two ANC modules would be
reduced in size by 0.7% and 5.4%.  For the three miscellaneous modules
the percenatages were 0.0, 3.5 and 6.7.  While static  area  addresses
emitted  by  the  cross-compiler  are  lengthy, they also appear to be
fairly infrequent.  The average code  area  reduction,  based  on  the
total  of  the bytes saved and the total of the individual code areas,
is 2.6%.

A register could also be used to point to the transfer vector used  to
call the runtime routines.  A byte displacement would be sufficient to
address a large majority of the existing runtime routines.  Note  that
a  register  would be dedicated solely for this purpose and would only
have to be loaded once.  Even a single runtime address in a  procedure
would  benefit  from  this  change.  The  percent  code size reduction
possible using this method was calculated by FINDing the runtime calls
in  the  assembly listing files with QED.  All but three of the sample
modules  would  be  reduced  in  size  by  this  change.  The  percent
reductions  range  from  0.1% to 4.9% (in an ANC module).  The average
reduction, computed as described above for the first suggestion, would
be  1.6%.  If either the DEBUG or CHECK options had been used with the
sample programs, the savings would have been much larger.

The  third  technique,  which  we  will  call  "targeting",   involves
exploiting  the  VAX's multiple operand, memory to memory instructions
and incorporating more context into  the  code  generator  algorithms.
Currently  a  simple  assignment  is always done via a move or convert
instruction.  The VAX's two and three operand arithmetic  instructions
would  permit  the assignment to be done simultaneously with the final
evaluation  of  the  right  hand  side  expression  in   many   cases.
Similarly,  a  temporary  is  always  allocated  for  the  result of a
function call returning an aggregate value.  When this value was to be
immediately  assigned  to a variable, the temporary could be dispensed
with.  The same idea could also be applied when expressions for simple
value  parameters  are  evaluated  and  then  placed on the stack.  No
quantitative analysis of the possible benefits from this technique has
been  attempted.  However,  an  informal estimate suggests the savings
are signifigantly larger than either of the above two methods, perhaps
in  the  five  to ten percent range.  A preliminary examination of the
effort required to incorporate targeting in  the  VAX  code  generator
suggests it would be fairly modest.

A  study  of  the  sample  programs  compiled with the TRACE option on
indicated that over 9% of the code area was  taken  up  by  the  trace
blocks.  For  one of the DESIGN modules the trace blocks occupied over
50% of the code area.  The current trace facility on the VAX also adds
one  instruction  to  the beginning of each procedure.  An alternative
approach would be to use a seperate trace table with entries for  each
procedure.  Each table entry would include the start of address of the
corresponding code, the ending address and  the  procedure  name.  The
trace  routine  would  then  use  the  current program counter and the
return addresses in the stack frame to provide the stack  trace.  This
scheme  effectively  increases  the density of the code area, which is
particularly  valuable  on  a  virtual  memory  machine.   The   pages
containing  the  trace  table  would normally never need to be brought
into main memory.  In addition the instruction which pushes the  trace
block  address  onto  the  stack  upon  entry  to a procedure could be
eliminated.

Modifying the VAX addressing modes...
The VAX has 16 basic addressing modes.  In this  section  we  consider
four  modifications  to  those  addressing  modes,  all  of  which are
attempts to reduce code  size.  The  VAX  operand  specifier  encoding
effectively   limits  the  number  of  addressing  modes  to  16.  The
addressing  modes  described  below  could  only  be  incorporated  by
replacing  some  of  the  existing  VAX  modes.  There  are four clear
candidates for replacement.  First, the code generator never generates
the  autoincrement  deferred mode.  Second, four addressing mode codes
are used for literal mode.  Literal mode special-cases short immediate
values.  Our  operand  specifier  analysis  indicates  that  80  to 90
percent of these cases can be handled using a single addressing mode.

The  first  three  modes  discussed  are  functionally  equivalent  to
existing  VAX  addressing  modes.  They  attempt to encode very common
operand specifications in fewer bytes by special-casing them.  Two  of
the  most  common  forms  of  addresses are byte displacements off the
argument pointer and indirect  byte  displacements  off  the  argument
pointer.  Both  of  these  forms of addresses require two bytes on the
VAX.  A special addressing mode could be created which used four  bits
for  the  mode code, one bit to indicate indirection and three bits to
encode the longword displacement off the argument pointer.  This would
permit  the first seven (possibly eight) parameters of a routine to be
addressed with a single  byte.  The  analysis  of  operand  specifiers
indicates  savings  ranging  from 1.3% to 8.8% would be possible using
this mode.  The weighted average savings is  3.2%.  These  percentages
assume  all  byte  displacements  off  the  argument  pointer could be
represented using the special case mode.

A similar strategy can be used to  specify  small,  negative  longword
offsets  off  the  frame  pointer.  Local  variables  are addressed as
displacements from  the  frame  pointer.  A  program  was  written  to
analyze  the  displacement  sizes  from  the  frame pointer, using the
assembly listing files as input.  Percentage savings  were  calculated
assuming all displacements between -1 and -256 could be addressed with
this new addressing mode.  The savings ranged from 0.7% to 10.8%, with
a  weighted average of 5.5%.  Assuming the displacement in the operand
specifier byte represented minus the required number of  longwords  of
displacement, four addressing modes would be required to represent the
range -1 to -256.  Fewer addressing modes could be dedicated  to  this
special case if the displacement range was more restrictive.

A third special case which was considered was attempting to encode two
successive register mode operands in a  single  byte.  This  technique
does not appear profitable for two reasons.  First, an analysis of the
opcode specifiers for the sample programs indicated that the number of
instructions  with  multiple register mode operands never exceeded one
percent.  Second, we were unable to devise a scheme for  encoding  two
registers  in  single  byte  while  retaining  the basic byte oriented

Operand Specifier Encoding of the VAX...
Finally,  a  new  addressing   mode   which   actually   extends   the
functionality of the present VAX addressing modes was considered.  The
VAX index mode permits the contents of a register  to  be  used  as  a
displacement  from  the effective address calculated from the previous
operand specifier.  This permits a displacement to be added to a  base
address  which  is  indirect.  The  new  mode  would work in a similar
fashion except that the displacement would be taken from  the  operand
specifier   itself   rather  than  from  a  register.  This  would  be
particularly useful for addressing fields  within  records  which  are
accessed  via  pointers  or  are  parameters  passed by address.  This
addressing mode would be more useful to a non-optimizing compiler than
to  an optimizing one.  If multiple references to fields of the record
exist, and the compiler is aware of that fact, then simply  loading  a
register  with  the  base  address makes more sense.  At this point we
have made no attempt to estimate the savings which would  result  from
this  change.  An accurate estimate would require a manual examination
of the generated code.

Defining new opcodes...
A  variety  of  new  instructions  could  be  defined.  Defining   new
instructions is far more compatible with the existing VAX architecture
than is modifying the operand formats.  Modifications to  the  operand
specifiers  would  force  full  software interpretation of the virtual
machine even on the VAX.  If the operand  specifier  formats  remained
unchanged,  additional  instructions  could  be  implemented as traps,
while  retaining  hardware   execution   of   existing   instructions.
Estimates  of  the  space  savings  resulting  from  the following new
instructions  are  not  available  in  most  cases.  For   any   given
instruction,  the  savings  would  be modest.  The total however would
probably be significant.

The procedure calling instructions are the most obvious candidates for
enhancements.   The   procedure   call  instruction  and  the  various
instructions for pushing operands and addresses onto the  stack,  were
almost  always  among  the  most  frequent  instructions in the sample
programs.  The CALLS  instruction  used  by  the  VAX  code  generator
already  does  much  of  the  work  necessary to establish a new stack
frame.  However, it does not attempt to deal  with  nested  scopes.  A
new  call  instruction could be defined which incorporated some of the
functions now done by the four prologue instructions at the  beginning
of   each   routine.   In   particular,   the  static  link  could  be
automatically pushed onto the stack and the new argument pointer could
also  be saved on the stack.  This enhancement, along with a reworking
of the stack trace facility, could reduce the  routine  prologue  from
four  instructions  to  one  (the  instruction for subtracting the new
stack frame size from the stack pointer would  be  retained).  If  the
call  instruction  included the number of static levels back the lexic
parent frame was, then any  instructions  previously  present  at  the
point  of  call  for explicitly chasing the static chain would also be
eliminated.

The conditional branch instructions of the VAX all use a self-relative
byte  displacement.  When  the  target of the branch is not within the
range  of  a  byte  displacement,  a  conditional  branch  around   an
unconditional,  word  displacement  branch  instruction is used.  This
five byte, two instruction sequence could  be  replaced  by  a  single
three   byte  instruction  if  word  displacement  conditional  branch
instructions were available.  The percentage  of  branch  instructions
which  required  a  word displacement ranged from 0.0% to 43.1% in the
sample programs.  Some of these were unconditional branches  to  begin
with  and  would  not benefit from this change.  The program analyzing
the opcode-operand specifiers dump file did not  distinguish  the  two
cases.  The  weighted  percentage  of  word  displacement branches was
16.8%.  This change could use up a large number of opcodes;  it  would
have  to  be  considered in light of the number of other opcodes added
and the number of existing VAX opcodes which could be dispensed with.

The VAX instruction set includes a set of  string  instructions  which
have  proven  very appropriate for implementing the MDSI Pascal string
operations.  Unfortunately, no corresponding set of instructions exist
for   Pascal   set   operations.   Clearly  a  group  of  instructions
specifically oriented towards Pascal set operations could be  defined.
The  details of a possible instruction set have not been worked out at
this point.  An alternative possiblity would be to simply augment  the
existing  instruction  set  with  some instructions which functionally
extended  existing  instructions.  Examples  of  this  would   include
quadword test, compare, AND, and OR instructions.

The  fact  that runtime routine addresses currently require five bytes
could also be dealt with by defining new  opcodes.  A  straightforward
approach  would  be  to  have a 'runtime call' instruction whose first
argument was an index into a  transfer  vector.  Parameters  could  be
either additional arguments or could be pushed onto the stack prior to
the call.

Finally, several miscellaneous instructions would be useful.  The  VAX
instructions for format conversions, arithmetic and logical complement
and arithmetic shifting all take two operands.  Often code size  could
be  reduced  by  performing these operations in place.  Single operand
variations of these instructions would make  this  possible.  The  VAX
also  lacks a logical AND instruction and a logical shift instruction.
Both of these functions are useful  for  set  operations.  Though  our
studies  have  all been done assumming the NOCHECK option, it would be
possible to substantially reduce the cost of  the  runtime  checks  by
defining  explicit check instructions.  For example, an explicit range
check would save the space required by the operand specifier  for  the
value  to  be  checked,  the  space  for the call to the runtime error
routine and two additional bytes.  The savings  would  be  substantial
enough  that  they  could easily make the difference in whether or not
CHECK mode was feasible for a program.
   