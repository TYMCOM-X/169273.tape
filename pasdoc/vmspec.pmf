$number off
$cen
Specification of #pvm, Version 1.0
$ski 4
$title right '#pvm Spec.' right 'April 1, 1980' right 'Page \'
$tab 9,17,25,33
$jus
#sect(Introduction)
This document specifies the architecture of the #pvm, version 1.0.
It is divided into three sections:
Section 1 specifies the instruction set of the machine.
Section 2 specifies characteristics of the "underlying" architecture,
such as the provisions for exception handling and the design
of the address space.
Section 3 contains preliminary specifications of the memory
management features of the #pvm, including paging and overlay handling.
$ski
The #pvm architecture is derived from that of DEC's
VAX-11 family (see [2]).
Therefore, understanding of this specification requires familiarity with
the VAX-11; [1] gives details.
In particular, chapters 4 through 9 describe data representations,
instruction formats, addressing modes and instructions on
which the #pvm architecture is based.
Since the #pvm is a virtual computer, it has no provision for
process contexts or processor access modes.
It is a single-user system, and
all of its instructions are available to user programs.
$ski
Since this architecture will be implemented in software,
the boundary between instructions and run-time functions is
not clear cut.
In particular, certain run-time functions will be implemented
via virtual machine instructions.
However, the formal specification of these instructions
will be supplied in a later version of this document.
#numsect(1,Instruction set architecture)
This section describes the #pvm instruction set.
It supplements chapters 5 through 9 of [1].
A brief summary of the VAX architecture,
supplementary data type information, and descriptions
of #pvm addressing modes and instructions follow.
#numsubsect(2,Summary of VAX-11 architecture)
DEC's VAX-11 architecture is a 32-bit byte-addressable
virtual memory machine.
Its instructions are of varying lengths, with opcodes one or two bytes
long, and with zero to six operands, each consisting of one
operand specifier byte optionally followed by one, two or four
bytes of displacement or immediate data.
Its repertoire of instructions is quite flexible, allowing
for hardware manipulation of many data types.
Not all of these data types are part of the #pvm;
for instance, queues and packed decimal integers are not supported.
The data types that are supported are:
byte, word, longword and quadword integer;
single and double precision floating point;
character string;
and variable length bit field.
These data types are described in [1], chapter 4.
$ski
The #pvm has a virtual address 32 bits long, as does the VAX.
It has a set of 16 registers that function
identically to the VAX's registers; see [1], chapter 3.
However, the other address space and processor status information
in that chapter does not apply to the #pvm;
these aspects of the specified machine are described in section 2 below.
#numsubsect(2,Special values)
A few of the newly defined #pvm instructions explicitly assume certain values
of Pascal data types.
Although these values do not really belong to the hardware
data types mentioned above, they should be defined here.
The values are:
$ski $ver
	FALSE	0
	TRUE	1
	NIL	^XFFFFFF80
	NILF	^XFFFFFF80
$jus
#numsubsect(2,Addressing modes)
This section describes the addressing modes used by the #pvm
instructions.
Most of them have been taken unchanged from the VAX-11 architecture.
The ten unchanged modes retain their mode specifier values;
the other six mode specifier values have new meanings described
below and in Appendix A.
Following the mode descriptions is a section giving considerations
which led to these particular choices of addressing modes.
#numsubsect(3,New modes)
The addressing modes of the #pvm are identical to those of the VAX-11,
with four exceptions.
First literal mode operands have been restricted to the range 0 to
15.
Literal mode floating point operands are not currently defined, but may
be in the future.
Second, modes one through three are now used to specify FP mode addressing.
This mode permits FP displacement addresses to be specified in a single
byte when the displacement lies in the range -4 to -192 and is a
multiple of 4.
Third, autoincrement deferred mode is not available
on the #pvm.  
It has been replaced by AP mode.
AP mode permits small AP displacements to be specified with a single
byte when the displacement lies in the range 4 to 32 and is a multiple
of 4.
Finally, the longword offsets of displacement and displacement
deferred modes have been replaced by three byte displacements.
One and two byte displacements are available also.
$ski
Individual descriptions for the addressing modes which differ from
those of the VAX-11 are given in Appendix A.
#numsubsect(3,Motivation)
All the addressing mode changes had the primary goal of reducing
the space requirements of programs from the amount required
by the VAX architecture.
References to procedure arguments via positive displacements from AP,
and local variables via negative displacements from FP, are common occurrences.
In contrast, use of literal values between 16 and 63 is relatively rare,
and the autoincrement deferred address mode is not applicable to
Pascal at all.
Therefore, even though equivalent code for these functions would
be longer for the #pvm than for the VAX, the new modes produce
significant net savings in space.
$ski
Eliminating the fourth byte of long displacements reduces the
magnitude of the maximum displacement from 2 gigabytes to 8 megabytes.
Since external references will use the three byte PC-relative mode,
this restricts the maximum size of a program to the neighborhood
of 8 megabytes.
We judged this limitation reasonable in view of the sizes of
current Pascal programs:
the maximum size of a PDP-10 program, for example, is 256 kilowords.
#numsubsect(2,Instructions)
This section describes the instruction set of the #pvm.
As with the addressing modes, most of the opcodes have been
taken unchanged from the VAX architecture.
Those opcodes that are unchanged retain both the mnemonics
and opcode values that the VAX uses.
Therefore, newly defined instructions must have new mnemonics,
and must have opcode values of VAX instructions that will never
be in the #pvm definition.
This section consists of a
discussion of the VAX instruction set, including a classification of its
opcodes according to their role in the #pvm, a description
of the new instructions,
and some remarks on motivation for the various choices these
specifications embody.
$ski
Appendices B and C contain exact instruction specifications.
#numsubsect(3,Classification of VAX instructions)
VAX instructions fall into three categories:
those that will never be #pvm instructions;
those that are not now but may be in the future;
and those that are part of this #pvm specification.
In the first group are all VAX privileged instructions
except HALT, instructions that use data types not supported
by the #pvm, and DEC reserved opcodes.
In the second group are HALT, BPT, and instructions which
use supported data types but are not clearly useful to
Pascal programs.
VAX instructions clearly applicable to Pascal comprise the third group.
Appendix B lists this classification by opcode.
#numsubsect(3,New instructions)
The new #pvm instructions fall into five groups.
These are:  a set of six logical AND instructions;
some additional instructions to push values on the stack;
extensions of the procedure call instructions;
system call instructions;
and instructions to perform run-time checking.
Group descriptions and instruction specifications
are given in Appendix C.
#numsubsect(3,Motivation)
Each group of new instructions is for a specific purpose in supporting a
Pascal implementation.
However, the underlying motivation for each instruction was
to reduce the size of compiler generated code.
Logical AND instructions are useful in set manipulation.
The new stack-pushing instructions round out the VAX repertoire;
these instructions facilitate argument passing in a block-structured language.
The procedure call instructions were extended to do a few things
that block-structured languages require which were not in the VAX
definition.
The system call facility was added to reduce space requirements
for run-time calls from a high-level language.
The run-time check instructions can be considered a special case
of system calls; they conditionally cause the current flow of
control to be aborted.
If checking is used, the frequency of code sequences to perform
checks justifies special instructions for that purpose.
#numsect(1,Underlying architecture)
This section deals with the non-instruction-set architecture
of the #pvm.
It corresponds roughly to chapters 3 and 12 of [1], although aspects
of the VAX architecture that support multiprocessing have no
counterparts in this specification.
In particular, registers, the PSW, exceptions, and the address
space are described here.
#numsubsect(2,Registers)
The #pvm has 16 32-bit "general purpose" registers, which have
roles quite similar to those of the VAX-11 register set.
See [1], p.49, for details.
The functions of the #pvm registers are summarized here:
$ski $ver $need 28
Registers  "Hardware" use         Conventional Software Use
-----------------------------------------------------------
R0         Length counter in      Function results (not saved
           character instructions or restored on procedure call)

R1         Address counter in     Function results (not saved
           character instructions or restored on procedure call)

R2,R4      Length counter in      Any
           character instructions

R3,R5      Address counter in     Any
           character instructions

R6:R11     None                   Any

AP (R12)   Argument pointer saved Argument pointer (base address
           and loaded by CALL,    of argument list)
           restored by RET

FP (R13)   Frame pointer saved    Frame pointer; exception
           and loaded by CALL,    signalling
           used and restored by
           RET

SP (R14)   Stack pointer          Stack pointer

PC (R15)   Program counter        Program counter
$jus
#numsubsect(2,Processor Status Word (PSW))
The #pvm gathers certain state variables together into a
16 bit word called the Processor Status Word.
These are a subset of the variables in the VAX's PSL (see [1], p. 52).
They are: the N, Z, V and C condition codes;
and two trap-enable flags, the IV bit and the FU bit.
These bits have the same meanings as in the VAX-11;
see also the next section for information on traps in the #pvm.
The format of the PSW is:
$ski $ver $need 4
 15              7   6   5   4   3   2   1   0
+------------------+---+---+---+---+---+---+---+
|        MBZ       |FU |IV |MBZ| N | Z | V | C |
+------------------+---+---+---+---+---+---+---+
$jus
#numsubsect(2,Exception handling)
VAX-11 exceptions are described in [1], chapter 12.
Certain events cause changes from the flow of control
explicitly specified in the instruction stream.
The VAX architecture calls these events either interrupts
or exceptions, and classifies exceptions as being either
traps, faults or aborts.
Errors detected by software that cause similar changes in
the flow of control are called conditions.
$ski
The #pvm is a single-process machine whose I/O is handled
exclusively by synchronous system calls, and therefore it
has no interrupt mechanism.
The instruction descriptions in [1] and in Appendix C
list exceptions that may occur in the #pvm.
Since MDSI Pascal condition handling features have not yet
been specified, the handling of exceptions and conditions
specified below is primitive.
This specification will need to be extended to efficiently deal with
the envisioned Pascal condition handling facility when it is specified.
$ski
One longword in each stack frame, the one pointed to by FP
when the frame is current, is reserved for the use of
exception/condition handling.
This longword is initialized to zero by the CALL instruction.
$ski
The occurrence of an exception and/or the
signalling of a condition will result in some default
action by the system that depends on the particular event.
This action will be either continued execution, with the
use of some default value if an arithmetic exception makes
it impossible to use the correct result, or termination of
execution and printing of an appropriate error message.
#numsubsect(2,Address space design)
The address space of the #pvm is modeled on that of the VAX,
but is somewhat simpler.
This section describes the address space into which #pvm
programs are loaded and in which they execute.
#numsubsect(3,Addresses)
#pvm addresses are 32 bits long.
The address space, unlike the VAX's, is not divided up into
regions with different purposes; code and data may be relocated by
the linker to any 32 bit address below ^XFFFFFE00.
The uppermost page is reserved for special purposes.
#numsubsect(3,Pages)
The #pvm address space is divided into pages of 512 bytes each.
The first byte on a page has an address divisible by 512.
Pages have attributes; these will include at least the following:
executable or not, readable or not, and writable or not.
A #pvm implementation may or may not enforce any of these attributes.
#numsubsect(2,Information in image file)
An image in execution by the #pvm consists of two parts:
the contents of memory and the volatile state.
(Actually in a single-process machine such as the #pvm
the distinction between these is not sharp;
register and PSW contents are as permanent as the memory contents.)
A file representing an image must therefore contain
the initial contents of memory and the initial state.
The format of such a file is not defined here,
but the information in it must include, at a minimum:
$ski
$par 5
- the initial instructions and data in the image
$par 5
- the initial contents of the 16 registers
$par 5
- the initial contents of the PSW
$par 5
- a list of all accessible pages and their attributes.
#numsect(1,Memory management architecture (preliminary))
This section deals in a general way with memory management
features of the #pvm architecture.
Further research and experimentation must be done before
the specific workings of paging and overlaying can be specified.
#numsubsect(2,Paging)
The #pvm is not only a virtual machine, but a virtual memory machine.
That is, it performs demand-paging of the executing image.
At any given time, only the instructions and data actually
being used need be directly accessible in the memory of
the execution agent (i.e., the interpreter).
This feature allows programs that are larger than available
memory to execute as though sufficient memory were available.
When an instruction or a datum is needed which is not in
memory, the page on which it lies is brought in from secondary
storage.
If available memory is full, another page will be displaced by
the new one.
If a page has been modified since it was last read in, it
must be written out to secondary storage before being displaced.
The collection of pages in the interpreter's memory at any
given time is called the working set.
$ski
Good performance requires that the page to be displaced be
chosen judiciously.
Various heuristics exist to make this choice;
each implementation of the #pvm is free to use any such heuristic.
Some implementations may use a heuristic which establishes
pages in certain parts of the address space as locked into
the working set;
this scheme would make address translations for these pages
simpler and make the pages effectively non-virtual.
Placing often-used code or data in these pages would
improve execution speed.
#numsubsect(2,Overlays)
The #pvm will use an overlay database similar to that
provided for MDSI Pascal-10 programs.
Routines corresponding to the Pascal-10 overlay system
kernel and overlay manager will be incorporated into
#pvm implementations.
These routines will keep overlay handling transparent
to the program except for the establishment of a new
version of a module as the current version.
$ski
The exact workings of these routines will be specified later.
In particular, they may be explicitly invoked via system calls,
or they may be invoked from within the interpreter, keeping them
invisible at the machine language level.
$ski
Also, each #pvm implementation may choose the action to be
performed on an overlay swap.
In a virtual memory computer, the new overlay need not actually
be read in; it is sufficient to page out the old overlay
and remap its virtual addresses to the new one.
On the other hand, all or part of the new overlay may actually
be paged into the working set automatically when the swap
takes place.
This action would be necessary if the overlay included pages
defined to be locked into the working set.
#pagsect(Appendix A:  New addressing modes)
On the following pages are specifications of the new
addressing modes.
They are given in the format of [1], chapter 5.
#newmode
Literal Mode
#assemb(S^^<:#literal:>)
#specif(0)
#modeformat
 7      4 3      0
+--------+--------+
| 0 0 0 0| literal|
+--------+--------+

The S^ syntax can be used to force literal mode;
otherwise, the assembler will force literal or
immediate mode, whichever is more appropriate.
#descr&Literal mode addressing provides an efficient means of specifying
integer constants in the range from 0 to 15 (decimal).
This is called short literal.
Literal values above 15 can be obtained by immediate mode.
Literal mode is currently only defined for integer values.
However, a mapping to 16 floating point values may be defined
in the future.
#newmode
FP Mode
#assemb(F^D(FP))
#specif(<:1, 2 or 3:>)
#modeformat
 7  6 5          0
+----+------------+
| 0 0| n + ^X10   |
+----+------------+

The F^ syntax can be used to force FP mode;
otherwise, the assembler will force FP or
displacement mode, whichever is more appropriate.
#descr&FP mode provides an efficient means of specifying small,
negative offsets from ter FP.
The constant ^X10 is subtracted from the value contained in bits
0 through 5 of the operand specifier byte.
This value is zero extended to 32 bits, incremented by one,
and multiplied by -4.
The contents of FP is then added to this value to form the
address of the operand.
#newmode
AP Mode
#assemb(A^D(AP))
#specif(9)
#modeformat
 7      4 3 2    0
+--------+-+------+
|    9   |@|   n  |
+--------+-+------+

The A^ syntax can be used to force AP mode;
otherwise, the assembler will force AP mode,
diplacement mode, or displacement deferred
mode, whichever is more appropriate.
#descr&AP mode provides an efficient means of specifying small
displacements from register AP.
The contents of bits 0 through 2 of the operand specifier byte are
zero extended to 32 bits, incremented by one, and multiplied by 4.
The contents of AP is then added to this value.
If bit 3 is zero, then the result is the operand address.
If bit 3 is one, then the result is the address 
of the operand address.
#newmode
Displacement Mode
#assemb(D(Rn)-general displacement)
#assemb(B^D(Rn)-forces byte displacement)
#assemb(W^D(Rn)-forces word diplacement)
#assemb(L^D(Rn)-forces long (3 byte) displacement)
#specif(A-(byte displacement))
#specif(C-(word displacement))
#specif(E-(3 byte displacement))
#modeformat
\\\\\\\\ 15        8 7      4 3      0
\\\\\\\\+-----------+--------+--------+
\\\\\\\\|   disp    |    A   |   Rn   |
\\\\\\\\+-----------+--------+--------+

\\\\ 23            8 7      4 3      0
\\\\+---------------+--------+--------+
\\\\|     disp      |    C   |   Rn   |
\\\\+---------------+--------+--------+

 31                8 7      4 3      0
+-------------------+--------+--------+
|        disp       |    E   |   Rn   |
+-------------------+--------+--------+
#descr&The displacement is sign extended to 32 bits and added to the
contents of register Rn.
The result is the operand address.
#newmode
Displacement Deferred Mode
#assemb(@D(Rn)-general displacement)
#assemb(@B^D(Rn)-forces byte displacement)
#assemb(@W^D(Rn)-forces word diplacement)
#assemb(@L^D(Rn)-forces long (3 byte) displacement)
#specif(B-(byte displacement))
#specif(D-(word displacement))
#specif(F-(3 byte displacement))
#modeformat
\\\\\\\\ 15        8 7      4 3      0
\\\\\\\\+-----------+--------+--------+
\\\\\\\\|   disp    |    B   |   Rn   |
\\\\\\\\+-----------+--------+--------+

\\\\ 23            8 7      4 3      0
\\\\+---------------+--------+--------+
\\\\|     disp      |    D   |   Rn   |
\\\\+---------------+--------+--------+

 31                8 7      4 3      0
+-------------------+--------+--------+
|        disp       |    F   |   Rn   |
+-------------------+--------+--------+
#descr&The displacement is sign extended to 32 bits and added to the
contents of register Rn.
The result is the longword address of the operand address.
$ind 0
#pagsect(Appendix B:  Opcode classification)
The following table lists the VAX-11 instruction set.
The first column describes the status of each opcode with
respect to the #pvm Version 1.0.
"Yes" means the instruction as specified in [1] is in the #pvm.
"No" means it is not and never will be; thus these opcode values
are free to be reassigned.
Some reassignments have already been made; these are shown on the right.
"Reserved" means the instruction is not in this specification,
but may be included in the future if it is judged necesssary.
$page $ver $tab 11,15,23,42,50
Reserved	00	HALT
Yes	01	NOP
No	02	REI
Reserved	03	BPT
Yes	04	RET
Yes	05	RSB
No	06	LDPCTX
No	07	SVPCTX		CHKLOW	rl,rl
No	08	CVTPS	rw,ab,rw,ab	CHKHGH	rl,rl
No	09	CVTSP	rw,ab,rw,ab	CHKRNG	rl,rl,rl
Yes	0A	INDEX	rl,rl,rl,rl,rl,wl
No	0B	CRC	ab,rl,rw,ab,wl	CHKPTR	rl
No	0C	PROBER	rb,rw,ab	CHKFIL	rl
No	0D	PROBEW	rb,rw,ab	CHKASS	rb
No	0E	INSQUE	ab,wl	CHKSTR	rl,rl,rw
No	0F	REMQUE	ab,wl
Yes	10	BSBB	bb
Yes	11	BRB	bb
Yes	12	BNEQ	bb
Yes	13	BEQL	bb
Yes	14	BGTR	bb
Yes	15	BLEQ	bb
Yes	16	JSB	ab
Yes	17	JMP	ab
Yes	18	BGEQ	bb
Yes	19	BLSS	bb
Yes	1A	BGTRU	bb
Yes	1B	BLEQU	bb
Reserved	1C	BVC	bb
Reserved	1D	BVS	bb
Yes	1E	BGEQU	bb
Yes	1F	BLSSU	bb
$page
No	20	ADDP4	rw,ab,rw,ab
No	21	ADDP6	rw,ab,rw,ab,rw,ab
No	22	SUBP4	rw,ab,rw,ab	ANDB2	rb,mb
No	23	SUBP6	rw,ab,rw,ab,rw,ab	ANDB3	rb,rb,wb
No	24	CVTPT	rw,ab,ab,rw,ab	ANDW2	rw,mw
No	25	MULP	rw,ab,rw,ab,rw,ab	ANDW3	rw,rw,ww
No	26	CVTTP	rw,ab,ab,rw,ab	ANDL2	rl,ml
No	27	DIVP	rw,ab,rw,ab,rw,ab	ANDL3	rl,rl,wl
Yes	28	MOVC3	rw,ab,ab
Yes	29	CMPC3	rw,ab,ab
Reserved	2A	SCANC	rw,ab,ab,rb
Reserved	2B	SPANC	rw,ab,ab,rb
Yes	2C	MOVC5	rw,ab,rb,rw,ab
Yes	2D	CMPC5	rw,ab,rb,rw,ab
Yes	2E	MOVTC	rw,ab,rb,ab,rw,ab
Reserved	2F	MOVTUC	rw,ab,rb,ab,rw,ab
Yes	30	BSBW	bw
Yes	31	BRW	bw
Yes	32	CVTWL	rw,wl
Yes	33	CVTWB	rw,wb
No	34	MOVP	rw,ab,ab	PUSHZB	rb
No	35	CMPP3	rw,ab,ab	PUSHZW	rw
No	36	CVTPL	rw,ab,wl
No	37	CMPP4	rw,ab,rw,ab
No	38	EDITPC	rw,ab,ab,ab
Yes	39	MATCHC	rw,ab,rw,ab
Reserved	3A	LOCC	rb,rw,ab
Reserved	3B	SKPC	rb,rw,ab
Yes	3C	MOVZWL	rw,wl
Yes	3D	ACBW	rw,rw,mw,bw
Yes	3E	MOVAW	aw,wl
Yes	3F	PUSHAW	aw
$page
Yes	40	ADDF2	rf,mf
Yes	41	ADDF3	rf,rf,wf
Yes	42	SUBF2	rf,mf
Yes	43	SUBF3	rf,rf,wf
Yes	44	MULF2	rf,mf
Yes	45	MULF3	rf,rf,wf
Yes	46	DIVF2	rf,mf
Yes	47	DIVF3	rf,rf,wf
Reserved	48	CVTFB	rf,wb
Reserved	49	CVTFW	rf,ww
Yes	4A	CVTFL	rf,wl
Yes	4B	CVTRFL	rf,wl
Yes	4C	CVTBF	rb,wf
Yes	4D	CVTWF	rw,wf
Yes	4E	CVTLF	rl,wf
Reserved	4F	ACBF	rf,rf,mf,bw
Yes	50	MOVF	rf,wf
Yes	51	CMPF	rf,rf
Yes	52	MNEGF	rf,wf
Yes	53	TSTF	rf
Reserved	54	EMODF	rf,rb,rf,wl,wf
Reserved	55	POLYF	rf,rw,ab
Yes	56	CVTFD	rf,wd
No	57	reserved	PUSHF	rf
No	58	ADAWI	rw,mw
No	59	reserved
No	5A	reserved
No	5B	reserved
No	5C	INSQHI	ab,wl
No	5D	INSQTI	ab,wl
No	5E	REMQHI	ab,wl
No	5F	REMQTI	ab,wl
$page
Yes	60	ADDD2	rd,md
Yes	61	ADDD3	rd,rd,wd
Yes	62	SUBD2	rd,md
Yes	63	SUBD3	rd,rd,wd
Yes	64	MULD2	rd,md
Yes	65	MULD3	rd,rd,wd
Yes	66	DIVD2	rd,md
Yes	67	DIVD3	rd,rd,wd
Reserved	68	CVTDB	rd,wb
Reserved	69	CVTDW	rd,ww
Yes	6A	CVTDL	rd,wl
Yes	6B	CVTRDL	rd,wl
Yes	6C	CVTBD	rb,wd
Yes	6D	CVTWD	rw,wd
Yes	6E	CVTLD	rl,wd
Reserved	6F	ACBD	rd,rd,md,bw
Yes	70	MOVD	rd,wd
Yes	71	CMPD	rd,rd
Yes	72	MNEGD	rd,wd
Yes	73	TSTD	rd
Reserved	74	EMODD	rd,rb,rd,wl,wd
Reserved	75	POLYD	rd,rw,ab
Yes	76	CVTDF	rd,wf
No	77	reserved	PUSHD	rd
Yes	78	ASHL	rb,rl,wl
Yes	79	ASHQ	rb,rq,wq
Yes	7A	EMUL	rl,rl,rl,wq
Yes	7B	EDIV	rl,rq,wl,wl
Yes	7C	CLRQ	wq
Yes	7D	MOVQ	rq,wq
Yes	7E	MOVAQ	aq,wl
Yes	7F	PUSHAQ	aq
$page
Reserved	80	ADDB2	rb,mb
Reserved	81	ADDB3	rb,rb,wb
Reserved	82	SUBB2	rb,mb
Reserved	83	SUBB3	rb,rb,wb
Reserved	84	MULB2	rb,mb
Reserved	85	MULB3	rb,rb,wb
Reserved	86	DIVB2	rb,mb
Reserved	87	DIVB3	rb,rb,wb
Yes	88	BISB2	rb,mb
Yes	89	BISB3	rb,rb,wb
Yes	8A	BICB2	rb,mb
Yes	8B	BICB3	rb,rb,wb
Yes	8C	XORB2	rb,mb
Yes	8D	XORB3	rb,rb,wb
Yes	8E	MNEGB	rb,wb
Yes	8F	CASEB	rb,rb,rb
Yes	90	MOVB	rb,wb
Yes	91	CMPB	rb,rb
Yes	92	MCOMB	rb,wb
Yes	93	BITB	rb,rb
Yes	94	CLRB	wb
Yes	95	TSTB	rb
Yes	96	INCB	mb
Yes	97	DECB	mb
Yes	98	CVTBL	rb,wl
Yes	99	CVTBW	rb,ww
Yes	9A	MOVZBL	rb,wl
Yes	9B	MOVZBW	rb,ww
Yes	9C	ROTL	rb,rl,wl
Yes	9D	ACBB	rb,rb,mb,bw
Yes	9E	MOVAB	ab,wl
Yes	9F	PUSHAB	ab
$page
Yes	A0	ADDW2	rw,mw
Yes	A1	ADDW3	rw,rw,ww
Yes	A2	SUBW2	rw,mw
Yes	A3	SUBW3	rw,rw,ww
Yes	A4	MULW2	rw,mw
Yes	A5	MULW3	rw,rw,ww
Yes	A6	DIVW2	rw,mw
Yes	A7	DIVW3	rw,rw,ww
Yes	A8	BISW2	rw,mw
Yes	A9	BISW3	rw,rw,ww
Yes	AA	BICW2	rw,mw
Yes	AB	BICW3	rw,rw,ww
Yes	AC	XORW2	rw,mw
Yes	AD	XORW3	rw,rw,ww
Yes	AE	MNEGW	rw,ww
Yes	AF	CASEW	rw,rw,rw
Yes	B0	MOVW	rw,ww
Yes	B1	CMPW	rw,rw
Yes	B2	MCOMW	rw,ww
Yes	B3	BITW	rw,rw
Yes	B4	CLRW	ww
Yes	B5	TSTW	rw
Yes	B6	INCW	mw
Yes	B7	DECW	mw
Reserved	B8	BISPSW	rw
Reserved	B9	BICPSW	rw
Reserved	BA	POPR	rw
Reserved	BB	PUSHR	rw
No	BC	CHMK	rw
No	BD	CHME	rw
No	BE	CHMS	rw
No	BF	CHMU	rw
$page
Yes	C0	ADDL2	rl,ml
Yes	C1	ADDL3	rl,rl,wl
Yes	C2	SUBL2	rl,ml
Yes	C3	SUBL3	rl,rl,wl
Yes	C4	MULL2	rl,ml
Yes	C5	MULL3	rl,rl,wl
Yes	C6	DIVL2	rl,ml
Yes	C7	DIVL3	rl,rl,wl
Yes	C8	BISL2	rl,ml
Yes	C9	BISL3	rl,rl,wl
Yes	CA	BICL2	rl,ml
Yes	CB	BICL3	rl,rl,wl
Yes	CC	XORL2	rl,ml
Yes	CD	XORL3	rl,rl,wl
Yes	CE	MNEGL	rl,wl
Yes	CF	CASEL	rl,rl,rl
Yes	D0	MOVL	rl,wl
Yes	D1	CMPL	rl,rl
Yes	D2	MCOML	rl,wl
Yes	D3	BITL	rl,rl
Yes	D4	CLRL	wl
Yes	D5	TSTL	rl
Yes	D6	INCL	ml
Yes	D7	DECL	ml
Reserved	D8	ADWC	rl,ml
Reserved	D9	SBWC	rl,ml
No	DA	MTPR	rl,rl
No	DB	MFPR	rl,wl
Reserved	DC	MOVPSL	wl
Yes	DD	PUSHL	rl
Yes	DE	MOVAL	al,wl
Yes	DF	PUSHAL	al
$page
Yes	E0	BBS	rl,vb,bb
Yes	E1	BBC	rl,vb,bb
Reserved	E2	BBSS	rl,vb,bb
Reserved	E3	BBCS	rl,vb,bb
Reserved	E4	BBSC	rl,vb,bb
Reserved	E5	BBCC	rl,vb,bb
No	E6	BBSSI	rl,vb,bb
No	E7	BBCCI	rl,vb,bb
Reserved	E8	BLBS	rl,bb
Reserved	E9	BLBC	rl,bb
Reserved	EA	FFS	rl,rb,vb,wl
Reserved	EB	FFC	rl,rb,vb,wl
Yes	EC	CMPV	rl,rb,vb,rl
Yes	ED	CMPZV	rl,rb,vb,rl
Yes	EE	EXTV	rl,rb,vb,wl
Yes	EF	EXTZV	rl,rb,vb,wl
Yes	F0	INSV	rl,rl,rb,vb
Yes	F1	ACBL	rl,rl,ml,bw
Yes	F2	AOBLSS	rl,ml,bb
Yes	F3	AOBLEQ	rl,ml,bb
Yes	F4	SOBGEQ	ml,bb
Yes	F5	SOBGTR	ml,bb
Yes	F6	CVTLB	rl,wb
Yes	F7	CVTLW	rl,ww
No	F8	ASHP	rb,rw,ab,rb,rw,ab	CALLG1	ab,ab
No	F9	CVTLP	rl,rw,ab	CALLS1	rl,ab
No	FA	CALLG	ab,ab	CALLGN	ab,ab,ab
No	FB	CALLS	rl,ab	CALLSN	rl,ab,ab
Yes	FC	XFC
No	FD	reserved	SYSCAL	sb
No	FE	reserved
No	FF	reserved
$jus $tab 9,17,25,33
#pagsect(Appendix C:  New instructions)
On the following pages are specifications of the new
instrucions, along with general descriptions of the procedure
and system call instructions, and the checking instructions.
They are given in the format of the instruction definitions in [1].
#newinst(AND)Logical And
#purpose&perform logical AND of two integers
#instformat
opcode mask.rx,dst.mx	2 operand
opcode mask.rx,src.rx,dst.wx	3 operand
#oper
dst <- dst AND mask		2 operand
dst <- src AND mask		3 operand
#cond(dst LSS 0,dst EQL 0,0,C)
#except&none
#opcode(22,ANDB2)Logical AND byte 2 operand
#opcode(23,ANDB3)Logical AND byte 3 operand
#opcode(24,ANDW2)Logical AND word 2 operand
#opcode(25,ANDW3)Logical AND word 3 operand
#opcode(26,ANDL2)Logical AND long 2 operand
#opcode(27,ANDL3)Logical AND long 3 operand
#descr&In 2 operand format, the mask operand is ANDed with the
destination operand and the destination operand is replaced
by the result.  
In 3 operand format, the mask operand is ANDed with the source operand
and the destination operand is replaced by the result.
#newinst(PUSHZ)Push Zero-Extended
#purpose&push an unsigned byte or word onto the stack,
converting it to a longword
#instformat
opcode src.rx
#oper
-(SP) <- src
#cond(0,src EQL 0,0,C)
#except&none
#opcode(34,PUSHZB)Push Zero-Extended Byte 
#opcode(35,PUSHZW)Push Zero-Extended Word 
#descr&The operand is zero-extended to 32 bits and pushed on the stack.
#notes&1.\\PUSHZx is equivalent to MOVZxL src,-(SP), but is one byte
shorter.
#newinst(PUSH)Push on Stack
#purpose&push source operand on stack
#instformat
opcode src.rx
#oper
-(SP) <- src;
#cond(src LSS 0;,src EQL 0;,0;,C)
#except&reserved operand (floating point)
#opcode(DD,PUSHL)Push Long
#opcode(57,PUSHF)Push Float
#opcode(77,PUSHD)Push Double
#descr&The source operand is pushed on the stack.
#notes&1.\\PUSHx is equivalent to MOVx src,-(SP), but is one byte
shorter.
$page
$ind 0
<:&Procedure Call Instructions& :>
$ski
Four new instructions have been defined for calling procedures.
These new instructions extend the functions of the VAX CALLS and
CALLG instructions in the following three ways.
$ski
First, the static link is automatically saved by the new instructions
at -4(FP) in the callee's frame.
The information necessary to make this possible is provided in one of two ways.
The CALLS1 and CALLG1 instructions may be used for calling level one
procedures; -4(FP) is cleared by these instructions.
The CALLSN and CALLGN instructions are used for calling routines whose
lexic level is unknown (i.e., procedure variables or parameters) or
whose level is known and is greater than 1.
These instructions require that the address of the stack frame of
the callee's lexic parent be included as an operand of the instruction.
$ski
Second, all of these instructions save a copy of the new contents of
AP at -8(FP) in the callee's frame.
$ski
Finally, the procedure entry mask has been expanded.
The VAX procedure entry mask is a word containing a register save mask
and a bit for enabling or disabling integer overflow traps.
Routines called by the four new instructions must have an additional
second entry word.
This word is a count of the number of longwords which the procedure
requires for local variables and fixed-length temporaries.
The call instructions zero extend this word to 32 bits,
multiply it by 4, and subtract the result from the stack pointer.
#newinst(CALLG)Call a Procedure With
General Argument List
#purpose&call a procedure with
actual arguments from anywhere in memory
#instformat
opcode arglist.ab,dst.ab  	level 1
opcode arglist.ab,slink.ab,dst.ab	level n
#oper
{align stack}
{create stack frame}
{set arithemetic trap enables}
{set new values of AP, FP}
SP <-- SP - 4 * ZEXT(bits 31:16 of mask longword)
PC <-- dst + 4
#cond(0,0,0,0)
#except&none
#opcode(F8,CALLG1)Call level 1 routine with
#opcode()general argument list
#opcode(FA,CALLGN)Call level n routine (n > 1)
#opcode()with general argument list
#descr&SP is saved in a temporary and then bits 1:0 of SP are replaced
by 0 so that the stack is longword aligned.
The procedure entry mask is scanned from bit 11 to bit 0 and
the contents of registers whose number corresponds to set bits
in the mask are pushed on the stack.
PC, FP, and AP are pushed on the stack as longwords.
The condition codes are cleared.
A longword containing the saved two low bits of SP in bits 31:30,
a 0 in bit 29, a 0 in bit 28, the low 12 bits of the procedure entry
mask in bits 27:16, and the PSW in bits 15:0 is
pushed on the stack.
A longword 0 is pushed on the stack.
The CALLG1 instruction pushes a 0 on the stack; the CALLGN instruction
pushes the slink operand on the stack.
The arglist operand is pushed on the stack.
FP is replaced by the contents of SP plus eight.
AP is replaced by the arglist operand.
The trap enables in the PSW are set to a known state.
Integer overflow is affected according to
bit 14 of the entry mask.
Floating underflow is cleared.
Bits 31:16 of the entry mask are zero extended to form a 32 bit value,
the 32 bit value is multiplied by 4, and
then subtracted from SP.
PC is replaced by the sum of the destination operand and 4, which
transfers control to the called procedure at the byte beyond the
entry mask.
#newinst(CALLS)Call a Procedure With
Stack Argument List
#purpose&call a procedure with actual
arguments or addresses on the stack
#instformat
opcode numarg.rl,dst.ab  	level 1
opcode numarg.rl,slink.ab,dst.ab	level n
#oper
{push arg count}
{align stack}
{create stack frame}
{set arithemetic trap enables}
{set new values of AP, FP}
SP <-- SP - 4 * ZEXT(bits 31:16 of mask longword)
PC <-- dst + 4
#cond(0,0,0,0)
#except&none
#opcode(F9,CALLS1)Call level 1 routine with
#opcode()stack argument list
#opcode(FB,CALLSN)Call level n routine (n > 1)
#opcode()with stack argument list
#descr&The number of arguments operand is pushed on the stack
as a longword.
SP is saved in a temporary and then bits 1:0 of SP are replaced
by 0 so that the stack is longword aligned.
The procedure entry mask is scanned from bit 11 to bit 0 and
the contents of registers whose number corresponds to set bits
in the mask are pushed on the stack.
PC, FP, and AP are pushed on the stack as longwords.
The condition codes are cleared.
A longword containing the saved two low bits of SP in bits 31:30,
a 1 in bit 29, a 0 in bit 28, the low 12 bits of the procedure entry
mask in bits 27:16, and the PSW in bits 15:0 is
pushed on the stack.
A longword 0 is pushed on the stack.
The CALLS1 instruction pushes a 0 on the stack; the CALLSN instruction
pushes the slink operand on the stack.
The saved SP (pointing to the argument count word) is pushed on
the stack.
FP is replaced by the contents of SP plus eight.
AP is set to the saved SP.
The trap enables in the PSW are set to a known state.
Integer overflow is affected according to
bit 14 of the entry mask.
Floating underflow is cleared.
Bits 31:16 of the entry mask are zero extended to form a 32 bit value,
the 32 bit value is multiplied by 4, and
then subtracted from SP.
PC is replaced by the sum of the destination operand and 4, which
transfers control to the called procedure at the byte beyond the
entry mask.
$page
$ind 0
<:&System Calls&:>
$ski
Two mechanisms exist for invoking what are traditionally regarded as
operating system or runtime system functions.
First, these functions may be performed by virtual machine
instructions.
Generally, such instructions will use a two byte opcode,
with "XFC" (FC hexadecimal) as the first byte.
In all other respects such instructions are normal virtual
machine instructions;
in particular, their operands use the standard operand specifier
notation and addressing modes.
This is the preferred method for well established functions which
have a fixed number of arguments.
$ski
The second mechanism is the SYSCAL instruction.
This instruction has a single byte opcode and a single operand.
The operand specifier for the SYSCAL instruction has a format
unique to this instruction.
The specifier is a single byte whose value indicates the specific
function to be invoked.
Arguments are passed by explicitly pushing them onto the stack.
#newinst(SYSCAL)System Call
#purpose&call a Virtual Machine system routine
#instformat
opcode number.sb
#oper
{invoke system defined function}
#cond((function dependent),(function dependent),(function dependent),(function dependent))
#opcode(FD,SYSCAL)System Call
#descr&Invoke the system routine corresponding to operand number.
#notes&1.\\Specific system routines may have side effects.
In particular, the stack pointer or the condition codes may
be modified.
See the descriptions of the individual routines.
$page
$ind 0
<:&Variable Length Bit Field Instructions&:>
$ski
The bit field instructions of the #pvm are identical to those of 
the VAX-11.
However, one of the restrictions on the position operand of these
instructions has been relaxed.
In the VAX architecture, if the base operand designates a register
then the position operand must have a value in the range 0 through
31.
The #pvm architecture permits the position operand to have a value
in the range 0 to 63 (when the base operand designates a register).
However, the sum of the position operand and the size operand must
be less than or equal to 64.
$page
$ind 0
<:&Check Instructions&:>
$ski 1

Explicit instructions have been defined corresponding to Pascal
value, assertion, file, pointer and substring checks.
These instructions test whether or not a certain condition is
met.
If the condition does not hold, the instruction causes an
exception.
$ski
Subscript checks are done automatically by the INDEX instruction.
Compatibility checks must be done explicitly with comparison instructions.
Compatibility and case check exceptions are produced by calling
a special runtime routine.
This runtime routine has a single parameter which is a number indicating the
exception to be caused.

#newinst(CHKLOW)Low Range Check
#purpose&check that a value is not less than a given limit
#instformat
opcode value.rl,limit.rl
#oper
value - limit
#cond(N,Z,V,C)
#except&value check
#opcode(07,CHKLOW)Check Low
#descr&The value operand is compared to the limit operand.
A value exception occurs if the value operand is less than
the limit operand.
#newinst(CHKHGH)High Range Check
#purpose&check that a value is not greater than a given limit
#instformat
opcode value.rl,limit.rl
#oper
limit - value
#cond(N,Z,V,C)
#except&value check
#opcode(08,CHKHGH)Check high
#descr&The value operand is compared to the limit operand.
A value exception occurs if the value operand is greater
than the limit operand.
#newinst(CHKRNG)Check Range
#purpose&check that a value lies within a given range
#instformat
opcode value.rl,low.rl,high.rl
#oper
value - low
high - value
#cond(N,Z,V,C)
#except&range check
#opcode(09,CHKRNG)Check Range
#descr&If the value operand does not lie between the low and high
operands inclusively a value check exception occurs.
#newinst(CHKPTR)Pointer Check
#purpose&Check that a pointer value is non-zero and non-NIL.
#instformat
opcode ptr.rl
#oper
ptr - 0
ptr - NIL
#cond(N,Z,V,C)
#except&Pointer check
#opcode(0B,CHKPTR)Check Pointer
#descr&A pointer check exception is generated if the ptr operand is
zero or NIL.
#newinst(CHKFIL)File Check
#purpose&Check that a file variable's value is non-zero and non-NILF.
#instformat
opcode file.rl
#oper
file - 0
file - NILF
#cond(N,Z,V,C)
#except&File Check
#opcode(0C,CHKFIL)Check File
#descr&A file check exception is generated if the file operand is
zero or NILF.
#newinst(CHKASS)Check Assertion
#purpose&Check that the result of an ASSERT expression is true.
#instformat
opcode src.rb
#oper
src - ord( TRUE )
#cond(N,Z,V,C)
#except&Assertion check
#opcode(0D,CHKASS)Check Assertion
#descr&An assertion check exception is generated if the src operand does not
have the value true.
#newinst(CHKSTR)Substring Check
#purpose&Check the validity of a substring specification
#instformat
opcode start.rl,sublen.rl,baselen.rw
#oper
sublen - 0
start - 0
(start + sublen - 1) - ZEXT( baselen )
#cond(N,Z,V,C)
#except&Substring check
#opcode(0E,CHKSTR)Check Substring
#descr&A substring check exception is generated if any of the following
three tests yield the value false:
$ind +3
1.\sublen >= 0
$par
2.\start > 0
$par
3.\start + sublen - 1 <= baselen
$ind -3
$ind 0
#pagsect(References)
$jus $ski $ind left 9
<:
$par -5
	\1.\\Digital Equipment Corporation.  &VAX-11 Architecture Handbook,
		1979-80&, 1979.
$par -5
	\2.\\Gorgen, D.\P. and S.\M.\Roush.  "Choice of basis for architecture
		of MDSI Pascal Virtual Machine", memo 2/29/80 to
		A.\A.\Kortesoja.
:>
    2@~i