P10CGU.INC	
{Page 1}...
  blt~_area: code_list;			(* chain for BLT~ control words *)
...
external function gen_blt~ (source_offset: code_address; source_reloc: rel_syllable;

-----------------------------------------------------------------------
P10OPC.INC	
{Page 1}...
	ADJSP~ = 105B;
...
	DSUB~ = 115B;
...
	IBP~ = 133B;
	ADJBP~ = 133B;
...
	BLT~ = 251B;

-----------------------------------------------------------------------
P10GEN.INC	
{Page 1}...
external procedure do_blt~ (source, dest, units: expr; density: int_type);

-----------------------------------------------------------------------
Q10GEN.INC	
{Page 1}...
external procedure do_blt~ (src_addr, dest_addr, width_addr: addr_desc);

-----------------------------------------------------------------------
P10SEL.PAS
{Page 1}...
   the byte pointer.  The initial alignment is maintained as in the ADJBP~ 

-----------------------------------------------------------------------
P10GEN.PAS	
{Page 1}...
$PAGE do_blt~
(* DO BLT~ generates the code necessary to move multiple memory words with a BLT~
...
public procedure do_blt~ (source, dest, width: expr; density: elem_sizes );
...
      time, the BLT~ control word may be generated as a constant and
...
    if cst_addr (src_addr) then begin (* constant BLT~ word *)
...
      gen (move, r, 0, 0, gen_blt~ (src_addr.offset, src_addr.reloc, dest_addr.offset, dest_addr.reloc));
...
    else begin (* construct BLT~ word *)
...
  else begin (* destination address unknown - construct BLT~ word *)
...
  (*  Once the BLT~ control word is in register r, several different code
...
          BLT~    r, dest+len-1
...
          BLT~    r, nd+len-1(rd)
...
          BLT~    r, len-1(r1)
...
          BLT~    r, dest-1(r1)
...
          BLT~    r, 0(r1)                                               *)
...
      (*  The destination address and width are both known.  The BLT~ control
...
          address for the transfer, and then perform the BLT~.  *)
...
      gen_rm (blt~, r, dest_addr);
...
      gen_rm (blt~, r, dest_addr);
...
          be copied from the BLT~ word.  *)
...
        gen_rm (blt~, r, dest_addr);
...
        gen (blt~, r, r1, n_words-1, none);
...
      gen (blt~, r, r1, 0, none);
...
 end (* do_blt~ *);
...
          of a BLT~, which allows for lots of ingenuity.  *)
...
            to be moved.  This length expression is freed once by "do_blt~",
...
        do_blt~ (rhs^.operand[1], lhs^.operand[1], lhs^.operand[2], 1);
...
    gen (adjsp~, sb, 0, 0, reldef (stack_frame));
...
  gen (adjsp~, sb, 0, 0, reldef (stack_frame));
...
  emit_code (blt~_area, loc_cst, prog_options.semantic_options);

-----------------------------------------------------------------------
P10CGU.PAS	
{Page 1}...
  blt~_area: code_list;                  (* chain for BLT~ control words *)
...
  blt~_area.first := nil;     blt~_area.last := nil;
...
$PAGE gen_blt~
(* GEN BLT~ generates a constant word whose left and right halfwords are
...
   in the blt~ area, and a rel_syllable denoting the address of the generated
...
public function gen_blt~ (source_offset: code_address;
...
   blt~def: def;
...
  bscan := blt~_area.first;
...
    blt~def := blast^.defname
...
    blt~def := make_def (constant_def);
    mark_def (blt~_area, blt~def);
...
    gen_emit (blt~_area, cr);
...
  gen_blt~ := reldef (blt~def);

-----------------------------------------------------------------------
P10EXP.PAS	
{Page 1}...
    else gen (ior, reg, 0, 0, gen_blt~ (lh, none, rh, none));
...
    else gen (move, reg, 0, 0, gen_blt~ (lh, none, rh, none));
...
            gen_rm (adjbp~, bpreg, mem);         (* index it *)
...
              then begin                        (* operand of adjsp~ is normally E, no need to make it immediate *)
...
                gen_rm (adjsp~, sb, mem);
...
                gen_rx (adjsp~, sb, reg2);

-----------------------------------------------------------------------
P10DSC.PAS	
{Page 1}...
        ADJSP~   17,-2           ; pop the argument list
...
  gen_ri (adjsp~, sb, -2);
...
        gen (move, reg, 0, 0, gen_blt~ (1000000b - set_size, none, 0, maddr.reloc));
...
  do_blt~ (rhs^.operand[1], lhs^.operand[1], lhs^.operand[3], 36);
...
    gen (move, reg, 0, 0, gen_blt~ (1000000b - set_size, none, laddr.offset, laddr.reloc));

-----------------------------------------------------------------------
P10MAC.PAS	
{Page 1}...
        'USETI USETO LOOKUPENTER UJEN  ***101***102***103***104ADJSP~ ',
        '***106***107DFAD  DFSB  DFMP  DFDV  DADD~  DSUB~  DMUL~  DDIV~  ',
...
        'FSC   IBP~   ILDB  LDB   IDPB  DPB   FAD   FADL  FADM  FADB  ',
...
        'ASH   ROT   LSH   JFFO  ASHC  ROTC  LSHC  ***247EXCH  BLT~   ',

-----------------------------------------------------------------------
Q10GEN.PAS	
{Page 1}...
$PAGE do_blt~
(* DO BLT~ generates the code necessary to move multiple memory words with a BLT~ instruction.
...
   addr_desc representing the number of words to be moved.  DO BLT~ will free all three of these
...
public procedure do_blt~ (src_addr, dest_addr, width_addr: addr_desc);
...
  (*  If both the source and destination addresses are known at compile time, the BLT~
...
    gen (move, r, 0, 0, gen_blt~ (src_addr.offset, src_addr.reloc,
...
  (*  Once the BLT~ control word is in register r, several different code
...
	    BLT~    r, dest+len-1
...
	    BLT~  r, nd+len-1(rd)
...
	    BLT~    r, len-1(r1)
...
	    BLT~    r, 0(len_reg)                                                *)
...
    gen_rm (blt~, r, temp_addr);
...
    gen (blt~, r, r1, width_addr.offset - 1, none)
...
    gen_rx (blt~, r, r1)
...
      do_blt~ (raddr, laddr, width_addr)
...
    def_value (stack_frame, temp_max, false); (* fill in ADJSP~'s value *)
...
    gen (adjsp~, sb, 0, 0, reldef (stack_frame));
...
  gen (adjsp~, sb, 0, 0, reldef (stack_frame));
...
  emit_code (blt~_area, loc_cst, prog_options.semantic_options);

-----------------------------------------------------------------------
Q10EXP.PAS	
{Page 1}...
       bound are known at compile time, an ADJBP~ instruction will be
...
         into a reg first - the ADJBP~ instruction does not work with
...
      gen ( ibp~, reg, 0, 0, gen_bptr ( base_addr ) );
...
      gen_rr (adjbp~, reg, reg2);
...
      gen_rm (adjbp~, reg, temp_addr);
...
      gen_rm (adjbp~, reg, base_addr);

-----------------------------------------------------------------------
Q10SET.PAS	
{Page 1}...
  if test_lwb or test_upb then (* must check it before doing adjbp~ *) begin
...
  gen (adjbp~, elem_reg, 0, 0, gen_bptr (set_loc.arg[1]));
...
      do_blt~ (sdesc.arg[1], duplicate_addr (temp_addr), int_value ((ctxt_len + 35) div 36))
...
    do_blt~ (laddr, temp_addr, int_value (set_size - 1))
...
     sets by utilizing adjbp~ *)
...
        do_blt~ (rhs_desc.arg[1], laddr, int_value ((lhs^.desc.set_length + 35) div 36))

-----------------------------------------------------------------------
Q10DSC.PAS	
{Page 1}...
  gen (adjsp~, sb, len_reg, 0, none);
...
	    taddr.reloc := gen_blt~ (440700b - ((index_value - 1) mod 5) * 70000b, none,
...
	  gen_rr (adjbp~, index_reg, reg);
...
	  gen_rm (adjbp~, reg, text_addr);
...
      gen_rm (adjbp~, reg, base_desc.text_addr);
...
    gen_ri (adjsp~, sb, -2);

-----------------------------------------------------------------------
1) "adjsp"      13
2) "adjbp"	14
3) "ibp"	3
4) "dadd"	1
5) "dsub"	5
6) "dmul"	1
7) "ddiv"	1
8) "blt"	78
