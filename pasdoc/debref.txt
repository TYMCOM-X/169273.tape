Tymshare Pascal Debugger User's Guide               Page i

             PROPRIETARY DOCUMENT INFORMATION
             ----------- -------- -----------

The material contained in this document is proprietary  and
confidential  to  TYMSHARE,  Incorporated, and is not to be
used, reproduced, or disclosed except  in  accordance  with
program  license  or with written permission from the legal
division of  TYMSHARE,  Incorporated,  20705  Valley  Green
Drive, Cupertino, California 95014.

                         May 1981


Tymshare  Pascal Debugger User's Guide             Page ii

                         Contents


Tymshare Pascal Debugger User's Guide               Page 1

1 INTRODUCTION

This  document  describes  the Tymshare Pascal debugger.  A
complete description of the various commands  is  given.  A
sample debugger session is also provided.  Appendix A shows
a  program  listing  from  the  sample  debugger   session.
Appendix  B  shows  the debugger's syntax and describes the
notation used throughout this document.

User input shown in examples is underscored.

Other documents included in the  Tymshare  Pascal  Language
series are:

      o   Tymshare  Pascal Compiler User's Guide--describes
          how to use the Tymshare Pascal compiler.

      o   Tymshare Pascal Language Reference  Manual--gives
          the complete specification of the Tymshare Pascal
          language.

1.1 Compiling a Module in DEBUG Mode

The Tymshare Pascal debugger is  an  interactive,  symbolic
debugging  package which is loaded automatically by LINK-10
when at least one Pascal module has been compiled with  the
DEBUG   option.   The   debugger   allows  examination  and
modification of program variables, and permits control over
program statement execution.

A  module  may  be compiled in DEBUG mode by specifying the
DEBUG option either on the compiler command line  or  as  a
block  option  following the PROGRAM, MODULE, or DATAMODULE
statement.  An entire module  must  be  compiled  in  DEBUG
mode.   There   is  no  provision  for  compiling  selected
routines within a module in DEBUG mode.

Introduction
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 2

1.2 Entering and Reentering the Debugger

When a program containing a module or modules  compiled  in
DEBUG  mode  is  run,  the  debugger  will be automatically
entered before the first statement of the main  program  is
executed.  The  debugger  may be reentered after a run-time
error by typing  "DDT"  at  the  monitor  prompt;  however,
program  execution  may  not  be  resumed.  If the user has
pressed the break key, the debugger  may  be  reentered  by
typing  "DDT"  at  the monitor prompt; typing CONTINUE will
cause resumption of program execution without entering  the
debugger.  However,  if  the  break occurred while in DEBUG
mode, then both "CONTINUE" and "DDT" will cause  resumption
of  debugger  execution  at  the  point where the break was
typed.  After an  error  or  a  trap,  the  user  can  type
"REENTER"  to  obtain  a trace of the Pascal run-time stack
(i.e., a list  of  currently  active  routines).  When  the
monitor  prompt reappears, the user should enter "CONTINUE"
and the stack trace will be printed.

1.3 Identifier Length

Tymshare Pascal allows  identifiers  of  arbitrary  length.
The debugger, however, retains only the first 40 characters
of identifiers entered by the user.  If the user enters  an
identifier longer than 40 characters, it is truncated to 40
characters.  When it is looked up in the  symbol  table  of
the  .DEB file, the symbol table entries are also truncated
to  40  characters   before   being   compared   with   the
user-entered identifier.

1.4 The Debugger Symbol Table File

When  a module is compiled in DEBUG mode, special blocks of
information used  by  the  debugger  are  inserted  in  the
generated  code,  and a file containing the run-time symbol
table is produced.  This file has  the  same  name  as  the
relocatable  binary file but has the extension ".DEB".  The
."DEB" file is always written in the same directory as  the
relocatable  file.  The  name  of  the  symbol  table file,
including the directory where it was written,  is  recorded

Introduction
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 3

in  a  special  "program"  block  in the code, i.e., in the
".REL" file.  When the debugger must open the symbol  table
file  for  a  module,  it first attempts to open the symbol
file recorded in the .REL file.  If this fails, it attempts
to  open  a  symbol  file  of  the  appropriate name in the
current directory search  list.  If  this  also  fails,  an
error  message  is printed, and the debugger is exited.  To
avoid this kind of a problem:

      (1)  a .DEB file should  be  left  in  the  directory
           where it was created, or,
      (2)  it  should be moved to a directory in the search
           list of every user who may run a  version  of  a
           program  built with the corresponding DEBUG mode
           .REL file.  One effective way of doing  this  is
           to move .REL and .DEB files around together.

In either case, .DEB files must be read-accessible to users
running programs built with corresponding DEBUG  mode  .REL
files.

The  date  and time of the compilation are recorded in both
the .DEB file and the  .REL  file.  When  a  .DEB  file  is
opened,  the  date  and time in it are compared to the date
and time in the corresponding .REL file.  If the  date  and
time  do  not  match, then the debugger treats the relevant
Pascal module as if it were not  compiled  in  DEBUG  mode.
Consequently, displaying or assigning to variables would be
forbidden.  Such a day/time  mismatch  can  occur  if,  for
example,  a  module  is  recompiled  but  the corresponding
program is run before it is reLINKed.  If a  mismatch  does
occur, then an error message to that effect will be printed
along with the name of the  source  file.  The  file  named
should  then  be  recompiled  and  the  program  should  be
reLINKed.

1.5 Debugging Overlay Programs

The Pascal debugger has certain restrictions on the use  of
module  names  where the named module resides in an overlay
program.  The debugger  uses  the  LINK-10  (the  DECsystem
Linking  Loader) symbol table to locate modules whose names
are given as  parameters  to  debugger  commands.  However,
since the link symbol table available in an overlay program
is the one resulting from the build of the resident portion
of   the   program,   the  names  of  overlay  modules  are
inaccessible to the debugger.  Thus in  any  command  which

Introduction
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 4

takes  a  module  name  as  a  parameter  only the names of
modules in the resident  portion  of  the  program  may  be
specified.  This  includes the .BREAKPOINT, .DISPLAY FILES,
.DISPLAY PAGES, .OPEN, and .KIND commands.

To set a breakpoint in an overlay module or to display  the
files  in  an  overlay module the user need only first open
the module  using  the  .OPEN  command.  The  name  of  the
overlay  module  may  not  be  used  to  open  the  module.
However, if a routine within the  module  is  active,  then
that  routine  may  be  opened  by specifying a stack frame
number (from the .DISPLAY STACK command).  Alternately, the
user  may  open an active or inactive routine of the module
using the syntax:

     .OPEN     routine-name':' [ routine-name':' ]      ...
        [ '('invocation')' ]

The first-named routine must be PUBLIC and must be declared
in the MDL (Memory Language  Description)  of  the  overlay
program.

When  using  the  debugger  with  an  overlay  program, the
following should be kept in mind.  The name of a module  in
an  overlay  should  never  be included as a parameter to a
debugger  command.  Instead,  the  relevant  module  should
first  be  .OPENed  using  one of the two methods described
above.  Commands may then be given without the module name.
By default, the debugger will use the module containing the
currently open scope.

Public variables and constants  declared  in  overlays  may
only  be  accessed  when  the  Pascal module containing the
PUBLIC declaration is open.  If the variable or constant is
declared  "EXTERNAL"  in the currently open module, then it
is not accessible.  This restriction is  also  due  to  the
fact  that  public  symbols  are  accessed  via the LINK-10
symbol table.

Introduction
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 5

2 DEBUGGER COMMAND SYNTAX

2.1 The Command Line

The  debugger  prompts  for  input  with  two  greater-than
symbols,  ">>".  There are two classes of inputs:  debugger
commands and debugger display or modify requests.  Debugger
commands  are  preceded  by  a period (".").  Each debugger
command begins with  a  keyword,  which  may  generally  be
abbreviated,  and  is  followed  by  one or more parameters
separated by spaces.  Display or modify requests are simply
Pascal data references or assignment statements.  Any input
prefaced with a period will be interpreted  as  a  debugger
command;  all  other  inputs  are interpreted as display or
modify requests.

Any number of commands or display or modify requests may be
typed  on  one command line, separated by semicolons (";").
They will be executed sequentially from left to right, and,
if  one  is in error, the following one(s) will be ignored.
If an error in a command line does occur, the command  line
is  printed  along  with  an  up-arrow ("^") indicating the
approximate position of the error.  A command line may  not
exceed 150 characters.  Command lines are not retained when
execution of the user program  is  resumed.  Thus  commands
which  cause  resumption  of  the  user program (the .STEP,
.SSTEP, and .PROCEED commands) should not  be  followed  by
more debugger commands on the same command line, since they
will be ignored.

2.2 Syntax of User-Entered Constants

Integers may be entered in octal by appending an (uppercase
or  lowercase) "B" to the integer.  String constants may be
delimited by either a single (') or double (") quote  mark.
The  opening and closing delimiters must be identical.  The
delimiting character may  be  included  in  the  string  by
entering  it twice.  Having two string delimiter characters
available is especially convenient in  breakpoint  strings.
For example:

Command Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 6

     .BREAKPOINT 1 'ERROR_MSG:="ILLEGAL VALUE";.P'

Real numbers are entered using the standard Tymshare Pascal
syntax.  Note that at least one digit (possibly  the  digit
zero) must precede the decimal point.  Set constants may be
entered using the standard Pascal syntax.

2.3 Referencing Program Text

Several commands require parameters which reference  source
program  text,  e.g., the command for setting a breakpoint.
Source program  lines  are  referenced  hierarchically,  as
follows:

Module (MODULE, PROGRAM, or DATAMODULE identifier)

  File (Name or number of primary source file 
           or $INCLUDE file)

    Page (Page name or number based on $PAGE directives)

      Line (Line number within page within file)

The syntax of a fully qualified reference, referred to as a
source reference, is:

               module'@'file'-'page'/'line-number

The characters "@", "-", and  "/"  serve  to  identify  the
preceding components of the source reference.  For example,
a file name or number must always be followed  by  "-".  If
the  file name or number is omitted (defaults are discussed
in the individual command descriptions), then the character
"-" should be omitted also.

The  module  is  simply  the  identifier  which follows the
PROGRAM, MODULE, or DATAMODULE statement.  A  file  may  be
either  the  primary  source  file or a file included via a
$INCLUDE or $SYSTEM directive.  The file number is assigned
by the compiler and appears in compiler-generated listings.
A file identifier is the file name and may  be  up  to  six
characters  long.  Pages are defined by $PAGE directives in
the  source  program.   Page   numbers   appear   both   in
compiler-generated  listings  and  in listings generated by
the FORMAT utility program.  Page names are all  contiguous
alphanumeric and underbar characters following the "$PAGE".
For example, "$PAGE ref_num_info--returns a descriptor  for

Command Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 7

a  ref_num"  would  have  page  name  "ref_num_info".  When
printing a source reference, the debugger will omit a  file
or  page  number  of  zero.  On  input, any components of a
source reference except the line  number  may  be  omitted.
The  .DISPLAY  FILES and .DISPLAY PAGES commands are useful
for determining file and page numbers and names for modules
compiled in DEBUG mode.

Referencing  statements  by line number within page, rather
than by line  number  within  file,  generally  allows  old
listings  to be used longer.  An edit only affects the line
numbers within the particular page rather than  within  the
entire  file.  The  compiler,  the  FORMAT program, and the
LIST command in QED all produce listings with line  numbers
within pages.

Lines  containing  the  beginning of a Pascal statement, an
UNTIL clause, or an END  keyword  may  be  referenced.  The
beginning  of  statements  are  indicated  by  the keywords
identifying them, e.g., IF, CASE, etc.,  or  by  the  first
identifier  in  a  procedure  call  or  assignment.  A line
containing  only  a  BEGIN,  ELSE,  or  label  may  not  be
referenced.

If  the beginning of two or more statements (IF X THEN IF Y
THEN X:=2), or the ENDs (BEGIN...END; y:=0;) of two or more
compound  statements  appear  on  a  line,  only  the first
statement can be referenced (the REPEAT UNTIL statement  is
not  affected).  (A  breakpoint  may  be  set  on  an END.)
Consequently, typing more than one statement on a line  may
complicate debugging a program.

2.4 Referencing Program Data

Whenever the debugger is entered, all identifiers which are
in scope at the point where program execution was suspended
are   available  for  display  or  modification.  Thus  all
identifiers of the current routine and  those  declared  in
any  routines  which  lexically enclose the current routine
are available.  If the routine was recursively called, then
the  local variables from the most recent invocation of the
routine are available.  The location of the last  statement
executed   may  be  displayed  via  the  .DISPLAY  LOCATION
command.  A PUBLIC variable or constant may be displayed or
modified   whenever   the  module  containing  the  current
statement includes a PUBLIC or EXTERNAL declaration for it.

Command Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 8

The  set  of   identifiers   available   for   display   or
modification on entry to the debugger is called the initial
scope.  This scope may be changed by the user via the .OPEN
command;  the  current  scope  is  the  set  of identifiers
currently available  for  display  or  modification,  i.e.,
either  the scope last opened via the .OPEN command, or, if
no .OPEN command has been given since the debugger was last
entered,  then the initial scope.  The current scope may be
displayed with the .DISPLAY SCOPE command.

The .OPEN command enables the user to  change  the  current
scope.  The  .OPEN  command  permits  the  new  scope to be
specified in one of three ways:

      (1)  the scope of any active routine may be opened by
           specifying the number of its stack frame.  Stack
           frame numbers can be determined via the .DISPLAY
           STACK  command.  Frames  are  numbered  from  1,
           where 1 refers to the main program's frame;

      (2)  the scope of any routine of any module  compiled
           in  DEBUG  mode may also be opened.  The routine
           need  not  be  currently  active,  though  local
           variables   of  inactive  routines  may  not  be
           examined.  Using this method the  .OPEN  command
           takes  a  "scope reference" as its parameter.  A
           scope reference has the following syntax:

                scope-reference ::=

                   [module'@'] routine-name':' 
                   [routine-name':']
                   ... ['('invocation-number')']

           or

                scope-reference ::= module'@'

           Each routine named must be declared  within  the
           routine or module which precedes it.  The module
           name  and  "@"  may  be  omitted  only  if   the
           first-named  routine is PUBLIC.  "Invocation" is
           an (optional) integer constant  which  specifies
           which invocation of a recursively called routine
           should  be  opened.   Invocation   numbers   are
           described  in  more detail in the description of
           the .OPEN command;

      (3)  the current scope may be reset  to  the  initial
           scope  by  giving  the .OPEN command without any
           parameters.

Command Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide          Page 9

           The  current  scope  also  defines  the  current
           module.   If  a  module  name  is  omitted  from
           commands referencing  files,  pages,  or  lines,
           then  the  current module is used as the default
           module (not the module  containing  the  initial
           scope).

Command Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 10

3 DEBUGGER COMMAND DESCRIPTIONS

Most  of  the  examples  used in the following descriptions
refer to a sample program contained in Appendix A.  Minimum
acceptable abbreviations of keywords are underscored.

3.1 Inquiry Commands

.DISPLAY option

     Displays  the  information  specified  by  the option.
     Possible options include:

     MODULES

        Lists all Pascal modules in  the  program.  Modules
        not compiled in DEBUG mode are also indicated.

     FILES [module'@']

        Lists  all file(s) and their number(s) in a module,
        or the current module, if none is  specified.  This
        command  may  not  be  used with modules which lack
        executable Pascal statements, e.g., data modules.

     PAGES [module'@'] [file]

        Lists  all  pages  in  a  file  (within  a  module)
        generated   by   $PAGE   compiler  directives.  The
        current module and/or  file  zero  are  assumed  if
        parameter(s)  are omitted.  This command may not be
        used  with  files   within   modules   which   lack
        executable Pascal statements, e.g., data modules.

        For example, in the sample program:

          >>.DISPLAY MODULES
          TEST F
          >>.DISPLAY FILES
          0 FORMAT
          >>.DISPLAY PAGES
          2 mainline
          1 f format
          0

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 11

     LOCATION

     Prints  the  location of the current statement and the
     reason the debugger was entered (only the location  is
     printed  if  the  entry  is  due  to a .STEP or .SSTEP
     command).  The  name   of   the   routine   (and   its
     invocation)  containing  the current statement is also
     printed.  In all location printouts, if the number  of
     the page or file is zero, it is omitted.

     BREAKPOINTS

     Prints  the location(s) and number(s) of all currently
     set breakpoints.

     For example, at the first statement of routine CNVT in
     the sample program:

          >>.DISPLAY LOCATION
          Breakpoint #0 in routine CNVT at TEST_F@17
          >>.DISPLAY BREAKPOINTS
          0 TEST F@17
          1 TEST F@1/26

     SCOPE

     Prints the module and routine(s) whose identifiers are
     currently in scope.  The module is printed first,  and
     then  routine(s) from outermost to innermost.  Several
     memory addresses are also printed.  HISEG is the first
     word  of  the  module's  high-segment  (code) section,
     while LOWSEG is the beginning of  its  static  storage
     section.  BASIS  is  the  address of a routine's stack
     frame.  It shows which frame of a  recursively  called
     routine   is   currently  in  scope,  as  the  example
     following the next option demonstrates.  If the module
     corresponding to the default scope was not compiled in
     DEBUG mode, an error message is printed.

     STACK [ number of frames ]

     Displays the current state of the stack.  If a  number
     of  frames is not specified, information on the entire
     stack is printed.  If a number of frames is specified,
     that  number  of  frames,  starting with the innermost
     (the frame  of  the  current  routine),  are  printed.
     BASIS is the stack frame address, and LVL, the lexical
     level of the routine  [0=Main,  1=first-level  routine
     (potentially  PUBLIC),  etc.].  LOC is the location of
     the first executable  statement  of  the  routine  and

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 12

     CALL, the location of the statement within the calling
     routine where the  call  was  made.  A  debugger-style
     location  is  printed  if the corresponding module was
     compiled in  DEBUG  mode;  otherwise,  a  high-segment
     address  is printed.  The procedure name is printed if
     the corresponding module  was  compiled  in  DEBUG  or
     TRACE  mode;  otherwise,  "Mainline"  or  "Unknown" is
     printed.

     For example, after  the  second  (recursive)  call  to
     routine  CNVT,  the  following  output  from  .DISPLAY
     SCOPE/STACK results.  Note that the BASIS in SCOPE  is
     the  second  (innermost) BASIS of CNVT in the .DISPLAY
     STACK output.

          Breakpoint #0 in routine CNVT at TEST_F@17
          >>.DISPLAY SCOPE
          TEST FORMAT   (HISEG=400010,LOWSEG=140)
          I FORMAT      (BASIS=7310)
          CNVT          (BASIS=7327)
          >>.DISPLAY STACK
          5 CNVT        BASIS=7351 LVL=2 LOC=TEST F@17
                          CALL=TEST F@18
          4 CNVT        BASIS=7327 LVL=2 LOC=TEST F@17
                          CALL=TEST F@25
          3 I FORMAT  BASIS=7310 LVL=1 LOC=TEST F@25
                          CALL=TEST F@1/25
          2 F FORMAT BASIS=7250 LVL=1 LOC=TEST F@1/20 
                          CALL=TEST F@2/26
          1 TEST FORMAT BASIS=7235 LVL=0 LOC=TEST F@2/7

     IOSTATUS

     Displays the most recent error code  set  by  the  i/o
     system.  The  value  displayed  will  be  one  of  the
     members of  the  predefined  type  IO_STATUS  such  as
     "IO_OK".   The  information  obtained  by  using  this
     display command is the same as the user program  would
     obtain  by using the predefined IOSTATUS function with
     no  parameter  (see  the  Tymshare   Pascal   Language
     Reference Manual for more information).

     EXTSTATUS

     Displays  the  same  information that the user program
     would  obtain  by  calling  the  predefined   function
     EXTSTATUS,  which  returns an integer value describing
     i/o errors  in  an  implementation-dependent  fashion.
     The integer value will be printed in octal format.

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 13

.HELP or .COMMANDS

     Lists all debugger commands.

.KIND source-reference

     Lists  the  "kind"  of the referenced statement, where
     statement kinds are:  assignment statement,  procedure
     call,  IF  statement,  FOR  statement, LOOP statement,
     WHILE statement, CASE statement, WITH statement,  GOTO
     statement,   i/o  statement,  RETURN  statement,  STOP
     statement,   EXIT   clause,   UNTIL   clause,   REPEAT
     statement,   and   END  keyword.  The  only  mandatory
     component of the source reference is the line  number.
     Defaults  for omitted components are the same as those
     described under  the  .BREAKPOINT  command  (which  is
     described in Section 3.3).

.VERSION

     Prints the debugger's version number.

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 14

3.2 Display/Modify Requests, Related Commands

.OPEN [ scope-reference | [ stack-frame-number ]

     Allows identifiers in other than the initial scope (as
     defined by the current point in program execution)  to
     be  accessed.  It  also  defines  the  current module,
     which is used as the  default  in  commands  taking  a
     module name, for example, BREAKPOINT.  A new scope can
     be specified by (1)  completely  elaborating  it  from
     module'@'routine':'routine':' . . . ,   the  outermost
     level, (2) specifying a stack frame to be  opened,  or
     (3) specifying .OPEN with no parameters.  (2) is often
     the most convenient way to open a particular recursive
     invocation  of  a  routine,  although  (1) may also be
     used.  (3) allows the user to  reset  to  the  initial
     scope.

     For  instance,  after  the  second (recursive) call to
     CNVT in the sample program, the situation is this:

     Breakpoint #0 in routine CNVT at TEST F@17
     >>.DISPLAY SCOPE
     TEST FORMAT   (HISEG=400010,LOWSEG=140)
     I FORMAT      (BASIS=7310)
     CNVT          (BASIS=7327)
     5 CNVT        BASIS=7351 LVL=2 LOC=TEST F@17 
                     CALL=TEST F@18
     4 CNVT        BASIS=7327 LVL=2 LOC=TEST F@17 
                     CALL=TEST F@25
     3 I FORMAT    BASIS=7310 LVL=1 LOC=TEST F@25 
                        CALL=TEST F@1/25
     2 F FORMAT    BASIS=7250 LVL=1 LOC=TEST F@1/20 
                        CALL=TEST F@2/26
     1 TEST FORMAT BASIS=7235 LVL=0 LOC=TEST F@2/7

     At this  point,  identifiers  defined  in  the  second
     invocation of CNVT, I FORMAT, and the main program are
     in scope.  However, as both I FORMAT and CNVT  have  a
     parameter  NUM,  and CNVT is currently being accessed,
     requesting NUM would access the identifier defined  in
     CNVT, whose current value is 10.

     To examine NUM in I FORMAT, the scope of I FORMAT must
     be OPENed, without including CNVT.  This can  be  done
     by entering:

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 15

          >>.OPEN TEST FORMAT@I FORMAT:
          >>NUM
          100
          >>.DISPLAY SCOPE
          TEST FORMAT       (HISEG=400010,LOWSEG=140)
          I FORMAT          (BASIS=7310)
     Alternately,  I FORMAT's  stack  frame could have been
     specified, e.g.,

          >>.OPEN 3
          >>.DISPLAY SCOPE
          TEST FORMAT       (HISEG=400010,LOWSEG=140)
          I FORMAT          (BASIS=7310)
          >>NUM
          100

     The number 3 was obtained from the  previous  .DISPLAY
     STACK.  Note  that  since frames are numbered from the
     main program down, the number of an  invocation  of  a
     routine  does not change so long as that invocation is
     active, thus obviating the need to .DISPLAY STACK each
     time the user wants to open the same invocation.

     To  examine  the  value of NUM the first time CNVT was
     called, an invocation number can be specified  on  the
     first form of .OPEN, e.g.,

          >>.OPEN TEST FORMAT@I FORMAT:CNVT:(2)
          >>NUM
          100

     Invocation 1 corresponds to the most recent invocation
     of a routine, and is  the  default  if  no  number  is
     specified.  2  is  the  next most recent; 3 is the one
     previous to it, etc.

     In this form of .OPEN, if  the  specified  or  default
     invocation  of  the rightmost routine cannot be found,
     the least recent invocation is used.  If no invocation
     of  the  rightmost  routine  is  found,  the  stack is
     examined for  an  invocation  of  the  next  rightmost
     routine  with  the  proper  invocation  number.  If no
     invocation of this routine is found,  the  process  is
     repeated  with  the remaining routines specified, from
     right to left.

     Instead of specifying an invocation number, the  first
     invocation  of  CNVT  could  have  been opened via its
     stack number, e.g.,

          >>.OPEN 4

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 16

     Finally,  at  any  time,  the  default  scope  can  be
     reestablished by merely entering .OPEN, e.g.,

          >>.OPEN

.WITH [record-reference [','record-reference] ...  ]

     The  .WITH  command  allows  the identifiers of fields
     within record variable(s)  to  be  referenced  without
     qualification.  For  example,  if  F FORMAT  is in the
     current scope:

          >>.OPEN TEST FORMAT@F FORMAT:
          >>.WITH FMT DESC
          >>FIELD WIDTH
          6
          >>FRAC WIDTH
          2

     Each  .WITH  command  overrides  the  previous   .WITH
     command.  However,  the  reference(s) in the new .WITH
     are resolved in the scope of the previous .WITH; i.e.,
     fields  of  record  type  within  a previously .WITHed
     record may be  directly  referenced  in  a  subsequent
     .WITH.  The  advantage  of  this  is that the user can
     sequence through a chain of records via  a  series  of
     .WITHs, e.g.,

          TYPE P:^RECORD
                   ...
                   NEXTP:P;
                   ...
                  END;
          VAR HEADP:P;

          >>.WITH HEADP^
             access first record
          >>.WITH NEXTP^    (in HEADP^record)
             access second
          >>.WITH NEXTP^    (in second)
             etc.

     To  simultaneously  open the scope of several records,
     the user should type all the names on the  same  .WITH
     command,  separating  each by a comma.  All the record
     references  given  will  be  resolved  in  the   scope
     existing prior to the command.

     If  .WITHs  are  in  effect  when program execution is

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 17

     resumed, they will continue to be in effect  when  the
     debugger  is  reentered  if the routine containing the
     current statement has not changed.  Thus, the user can
     establish  .WITHs  once,  and  step through a routine.
     However, if  the  routine  is  different  on  debugger
     entry, all active .WITHs will cease to be in effect.

     If  a  .WITH  command is given without any parameters,
     all active .WITHs are cleared.  An .OPEN command  also
     clears any existing .WITHs.

Display requests--

     reference

     Displays  the  value of the specified program variable
     or constant.  The  use  of  a  string  constant  as  a
     display   request   may  be  useful  in  the  commands
     associated with the breakpoint command to  include  an
     informative  message  when  the breakpoint is entered.
     Array subscripting, e.g., ( off_array[x,y] ),  pointer
     dereferencing e.g., ( oof_ptr^ ), and field selection,
     e.g.,  ( oof_rec.field1 )  are  all   permissible.   A
     string  constant  may  be used as a display request in
     the commands associated with the BREAKPOINT command to
     include  an informative message when the breakpoint is
     entered.  Array subscripts may be any reference of the
     appropriate type.  Integers and arrays of integers may
     be printed in octal by appending ":o" or ":O"  to  the
     reference.

     The  reference  may  be  to  an  object  of  any type,
     including records and arrays.  The only restriction is
     that  the object may not be a record which includes an
     undiscriminated union (i.e., a variant part for  which
     a  tag type but no tag field identifier is given).  If
     an array is specified, the entire  array  is  printed.
     If a record is specified, the entire record is printed
     with field values labeled with the corresponding field
     identifier.  Part  of  an  array  (  a  "slice" of the
     array)  may  also  be  printed  as  in  the  following
     example:

        some_array[m..n]

     This ".." notation will cause elements "m" through "n"
     of array some_array to be displayed.  The elements may
     be  of any type except that undiscriminated unions are
     not allowed.  Multiple indexes may  also  be  present.
     However,  only  one slice may be specified and it must

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 18

     be the last "index" given.  Examples are given  below.
     Substrings    may    also   be   printed   using   the
     "some_string[start:length]" syntax.

     Examples:
          A2D is a two-dimensional array:
          >>A2D
             1   2   3   4   5
             5   4   3   2   1
           507 508 509 510 511
          >>A2D[2..3]
             5   4   3   2   1
           507 508 509 510 511
          >>A2D[3,2..4]
           508 509 510

          SOME_STRING is a (fixed- or varying-length) 
             string:
          >>SOME_STRING
          'STUDENTS SCORES WERE:'
          >>SOME_STRING[10:12]
          'SCORES WERE:'

Modification requests--

          reference := constant | reference

          The  value  of  any  elementary   (SET,   STRING,
          integer, character, boolean, real, pointer, FILE,
          and enumerated types)  program  variable  may  be
          changed.  Constants  and value parameters may not
          be changed.  The  elementary  value  may  be  any
          constant or reference of type compatible with the
          left-hand-side  object.  Thus  any   nonaggregate
          (i.e.,   not   an  array  or  record)  assignment
          statement may be  typed.  In  addition,  pointers
          may  be  assigned user-entered integer constants.
          In this context, the integer constant is  assumed
          to  be  octal, even if not terminated with a "b".
          Pointer variables may be assigned  the  value  of
          another  pointer  of compatible type.  Substrings
          of strings may also be assigned to by  using  the
          [start:length]  syntax  on  the left-hand side of
          the assignment.

          Examples:
               >>CURRENT_NODE := 14307 (Ptr assign,
                                         RHS octal*)
               >>COLORS := [RED..GREEN,CHARTREUSE]
                                 (*Set asgmt*)

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 19

               >>MESSAGE := 'BAD INPUT LINE'
                                   (*String asgmt*)
               >>MESSAGE[5:10] := 'VIBES' 
                                     (*Substring asgmt*)
               >>MESSAGE
               'BAD VIBES     '

     .WHERE reference

          Prints the  memory  address  of  any  addressable
          reference  (which  may  be  of  any type).  Local
          variables of inactive routines  and  user-entered
          constants are not addressable.

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 20

     3.3 Execution Control Commands

          .STOP

          Terminates  program  execution, closes all files,
          and returns to  the  monitor.  Program  execution
          may not be resumed subsequently.

     .ABORT

          Exit  to  the  monitor without closing any files.
          If the  user  reenters  the  debugger  and  types
          ".CONTINUE", program execution may be resumed and
          a TRACE will be produced.

     .BREAKPOINT source-reference [string-constant]

          Sets a  breakpoint  at  the  specified  line  and
          prints the breakpoint number assigned.  Up to ten
          breakpoints are allowed.  The default module,  if
          none is specified in the source reference, is the
          current module,  i.e.,  the  one  containing  the
          currently open scope.  If a file, but no page, is
          specified, page zero in the file is  assumed.  If
          a  page,  but  no file, is specified, the page is
          assumed to be  in  file  zero.  If  only  a  line
          number is specified:

      (1)  if  at  the first statement in the main program,
           or if the  current  (default)  module  does  NOT
           contain  the  current  statement  (which  can be
           determined with .DISPLAY  LOCATION),  then  page
           zero  in  file  zero  in  the  current module is
           assumed;

      (2)  if  the  current  module  contains  the  current
           statement,  then  the  line number is assumed to
           refer to a statement in the page containing  the
           current statement.

           If  a  breakpoint cannot be set on the specified
           line, the debugger will ask the user if he wants
           it  on  the closest line with a larger number on
           which a breakpoint can be set.  Enter  "YES"  or
           "Y",  or  press  RETURN  to  set the breakpoint;
           enter "NO" or "N" to  cancel  the  command.  For

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 21

           example,  on  the  first  debugger  entry in the
           sample program:

          >>.BREAKPOINT 1
          Line 17 instead?
          <cr>
          Break #0 set.
          >>.BREAKPOINT F FORMAT/26
          Break #1 set.

     If  a  string  is  specified,  its  contents  will  be
     automatically  executed  as  a  line  of command input
     every time  the  breakpoint  is  encountered  and  the
     debugger is entered.  Any and all commands or requests
     may be included in the string.  In the example  above,
     to  always print the value of NUM and execute the next
     statement, enter:

          >>.BREAKPOINT 1 'NUM;.SSTEP'

.CLEAR [ breakpoint-number ]

     Clears the  specified  breakpoint.  To  determine  the
     number  of  a  breakpoint, .DISPLAY BREAKPOINTS can be
     used.  If no number is entered, the  debugger  assumes
     that  all  breakpoints are to be cleared, and requests
     confirmation before clearing them.  For example,

          >>.DISPLAY BREAKPOINTS
          0 TEST F@1/38
          1 TEST F@1/26
          >>.CLEAR
          Clear all?
          <cr>

.IF boolean-expression THEN debug-statement
[ ELSE debug-statement ]

     The .IF  command  provides  conditional  execution  of
     debugger   commands.  The  boolean  expression  is  an
     arbitrary  Pascal  boolean  expression   composed   of
     references,       the       relational       operators
     ( =,<>,<=,<,>=,> ), the IN operator, parentheses,  and
     the operators AND, OR, and NOT.  Note:  Function calls
     are not allowed in a debugger boolean  expression.  In
     addition,  the relational operators have been extended
     to permit pointers,  file  variables,  and  subroutine
     variables  to  be  compared  to (user-entered) integer
     constants.  When an integer is compared to a  pointer,
     file  variable,  or  subroutine variable, the radix of
     the constant is assumed to be  octal.  Otherwise,  the

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 22

     debugger  enforces  the same restrictions which Pascal
     places  on  the  use  of  relational  operators.   For
     example,  pointers  may  only  be  compared  using the
     operators "=" and "<>".  The  debug  statement  is  an
     arbitrary   debugger  command  or  display  or  modify
     request.  Multiple  commands  or   requests   may   be
     included  in the THEN or ELSE clause by bracketing the
     statements with BEGIN and END (see the example below).

     The .IF command allows  conditional  breakpoints.  For
     example,  it  can  provide a means to stop at a source
     line in the middle of a loop.  If  a  linked  list  is
     being  traversed  and  the  user  wishes  to stop when
     "OOF_PTR" is pointing to a specific  list  node,  then
     the following command could be used.

          .BREAKPOINT 14 '.IF OOF_PTR <> 43772 THEN .P'

     In  addition,  conditional  breakpoints can be used to
     detect when a variable is assigned an unexpected value
     at  some  unknown  time.  The  following command would
     stop the program when the value of NUM is outside  the
     range of values 0 to 255:

          .BREAKPOINT 21 '.IF (NUM >= 0) AND (NUM <= 255)
               THEN .P  ELSE BEGIN "NUM OUT OF RANGE: ";
               NUM END'

     In  certain  circumstances the .IF command may also be
     used to "patch" an incorrect program.  In  the  sample
     debugger  session,  routine CNVT is patched so that it
     works correctly in subsequent testing.  This  is  done
     with the following command:

          .BREAKPOINT 20 '.IF NUM = 10 THEN CNVT := "10";
               .P'

.PROCEED [ breakpoint-count ]

     Resumes  program  execution.  A  count may be given to
     cause the debugger to  ignore  breakpoints  until  the
     specified  number of breakpoints is encountered.  If n
     is the count  given,  the  debugger  will  ignore  n-1
     breakpoints  until  the  n-th breakpoint which will be
     processed normally.

.SSTEP [ debug-statement-count ]

     Executes  the  specified  number  of  statements   and
     returns  to  the  debugger.  If  no  number  is given,
     execute only the next  statement.  The  debugger  will

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 23

     also  be entered if a breakpoint is encountered before
     the step count is exhausted.  .SSTEP counts statements
     executed  in  routines  called  from the routine where
     execution was resumed,  i.e.,  it  steps  into  called
     routines.   Note   that   the   statement   count   is
     decremented  only  if  the   module   containing   the
     statement was compiled in DEBUG mode.

.STEP [ debug-statement-count ]

     Same as .SSTEP except routine calls are counted as one
     statement (unless a breakpoint  is  encountered  in  a
     called  routine,  in which case stepping ceases).  For
     example, in the sample  program,  a  .STEP  issued  at
     TEST F@1/26  in  F FORMAT  returns  to the debugger at
     TEST F@1/28:

          Breakpoint #1 in routine F FORMAT at TEST F@1/26
          >>.STEP
          in routine F_FORMAT at TEST_F@1/28

     A .SSTEP at  TEST F@18  in  CNVT  stops  at  TEST F@17
     (first  executable  statement  in  recursive  call  to
     CNVT):

          >>.SSTEP
          in routine CNVT at TEST_F@18
          >>.SSTEP
          in routine CNVT at TEST_F@17

Command Descriptions
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 24

4 COMMAND AND SYNTAX SUMMARY

The following is a summary of the debugger commands and  of
the   syntax  of  some  of  the  parameters.  The  complete
debugger syntax is given in Appendix B.  A variant form  of
BNF is used and is defined as follows:

::=         means "is defined as"

[  ]        encloses optional item

...         indicates  one or more occurrences of preceding
            item

|           means "choose one of"; indicates alternatives

lowercase   indicates category name

UPPERCASE   indicates reserved word

-           unites a compound variable name

' '         indicates the literal character  or  characters
            enclosed by the single quotes.

{  }        indicates  that  the contents of the braces are
            to be treated as a single item

.ABORT

.BREAKPOINT source-reference [string-constant]

.CLEAR [breakpoint-number]

.COMMANDS

.DISPLAY BREAKPOINTS
         EXTSTATUS
         FILES [module'@']
         IOSTATUS
         LOCATION
         MODULES
         PAGES [module'@'] [file]
         SCOPE
         STACK [number-of-frames]

Command and Syntax Summary
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 25

.HELP

.IF boolean-expression THEN  debug-statement  
     [ELSE debug-statement]

.KIND source-reference

.OPEN [ scope-reference ] [ stack-frame-number ]

.PROCEED [breakpoint-count]

.SSTEP [debug-statement-count]

.STEP [debug-statement-count]

.STOP

.VERSION

.WITH [record-reference [','record-reference] ... ]

.WHERE reference

Command and Syntax Summary
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 26

5 DEBUGGER ERROR MESSAGES

Boolean value required.

Breakpoint not set:  too many.

Cannot display value.

Closing string delimiter missing.

Command expected.

Compilation times of REL file and DEB file do not match.

Constant or reference expected.

Currently open module not compiled with DEBUG option.

Debugger entered abnormally--not properly initialized.

Decimal constant illegal in this context.

Display option expected.

"END" expected.

Execution command must be final command of line.

External name not defined.

External symbol undefined.

Fatal error -

Error Messages
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 27

File not found.

File NUM (filename) instead?

Format code expected.

Function not active or not in scope.

Identifier expected.

Identifier not declared or not in scope.

Illegal command.

Illegal set element type.

Illegal stack frame number.

Illegal value or range.

Index type incorrect.

Integer constant expected.

Invalid subroutine.

Lhs object may not be assigned to.

Line NUM instead?

Module contains no executable statements.

Module not compiled in DEBUG mode.

Error Messages
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 28

Module not found.

No such breakpoint.

No such field.

Nonpointer/file dereferenced.

Not a Pascal module.

Not addressable.

Octal or hex format valid for integer values only.

Operator invalid for type of operands.

Page not found.

Page NUM (subtitle) instead?

Pointer or file target type unknown.

Pointer value is NIL.

Pointer value is not initialized.

Real number has illegal format.

Record contains undiscriminated union.

Record type expected.

Right bracket expected.

Error Messages
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 29

Right parenthesis expected.

Routine containing variable is not active.

Scalar or real out of range.

Set too large.

Subscript follows nonarray/string.

Symbol is of illegal type.

Syntax error in scope reference.

"THEN" expected.

Too many subscripts for array.

Too many WITHs.

Type incompatibility.

Unknown error code, please report.

The value of IOSTATUS isn't in  range  of  predefined  type
IO_STATUS.

Error Messages
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 30

6 SAMPLE DEBUGGER SESSION

This  annotated debugger session shows a user finding a bug
in the attached sample program.  The  program  exercises  a
simplistic   routine   to   print   a   real  number  in  a
FORTRAN-style F format.  The bug is that  100  in  an  F6.2
format is written as ":0.00".  Since the bug must be in the
conversion of the integer part, the user begins by  setting
two  breakpoints, one at the beginning of routine CNVT, and
the  other  in  F FORMAT  immediately  after  the  call  to
I FORMAT which converts the integer part.

>>.DISPLAY MODULES         (display status information 
                            for later use)
TEST_F                      
>>.DISPLAY FILES
0 FORMAT
>>.DISPLAY PAGES
2 mainline
1 f_format
0
.BREAKPOINT 1  (default page at beginning of
Line 17 instead?  program execution is zero;
  <cr>  i.e., the one containg I_FORMAT)
Break #0 set.              
>>.BREAKPOINT F_FORMAT/26  (after 
                           call to I_FORMAT)
Break #1 set.
>>.DISPLAY BREAKPOINTS  (make sure 
                            breakpoints were
0 TEST/F@17              set correctly
1 TEST F@1/26
>>.PROCEED                 
total_fw: 6
frac fw: 2
*100
Breakpoint #0   in routine CNVT at TEST F@17
>>.DISPLAY SCOPE
TEST FORMAT   (HISEG=400010,LOWSEG=140)
I FORMAT (BASIS=7310)
CNVT     (BASIS=7327)
>>.DISPLAY LOCATION        (where you want to be)
Breakpoint #0 in routine CNVT at TEST F@17 
>>.SSTEP                   (step the IF test)
in routine CNVT at TEST F@18 
>>.SSTEP                   (step into CNVT for the 
                       second time)
in routine CNVT at TEST_F@17 
>>.DISPLAY STACK  (make sure two calls to CNVT

Sample Debugger Session
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 31

                            on stack)
5 CNVT         BASIS=7351 LVL=2 LOC=TEST F@17 
                  CALL=TEST F@18
4 CNVT         BASIS=7327 LVL=2 LOC=TEST F@17 
                  CALL=TEST F@25
3 I FORMAT   BASIS=7310 LVL=1 LOC=TEST F@25 
                   CALL=TEST F@1/25
2 F FORMAT   BASIS=7250 LVL=1 
                    LOC=TEST F@1/20
                    CALL=TEST F@2/26
1 TEST FORMAT  BASIS=7235 LVL=0 
                    LOC=TEST_F@2/7
>>NUM                      (parameter value to second call 
                   of CNVT)
10
>>.SSTEP                   (step IF test again)
in routine CNVT at TEST_F@19  (oops-CNVT not 
                              called again!)
>>.OPEN TEST_FORMAT@I_FORMAT: (check  
                     everything in sight
                     to find error)
>>NUM                      (parameter to I_FORMAT)
100
>>.DISPLAY SCOPE           (make sure OPEN worked)
TEST FORMAT (HISEG=400010,LOWSEG=140)
I FORMAT   (BASIS=7310)
>>.OPEN 3                  (open by stack frame to be sure)
>>.DISPLAY SCOPE           (notice scope is the same 
                         as above)
TEST FORMAT (HISEG=400010,LOWSEG=140)
I FORMAT   (BASIS=7310)
>>NUM                      (as is the parameter)
100
>>.OPEN TEST_FORMAT@F_FORMAT:  (check format passed 
                                to F_FORMAT)
>>.WITH FMT_DESC           (open the scope of the record)
>>FIELD_WIDTH              (in FMT_DESC)
6
>>FRAC_WIDTH               (in FMT_DESC)
2
>>RNUM                     (parameter to F_FORMAT)
100.0000000
>>.OPEN TEST_FORMAT@I_FORMAT:CNVT:(2)
>>NUM                      (check parameter to CNVT on 
                        first call)
100
>>.OPEN                    (everything's OK--return to 
>>.SSTEP                   default scope)
in routine CNVT at TEST F@20 
>>CNVT  (here's the bug--">" in F should
':'                        be ">=")

Sample Debugger Session
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 32

>>CNVT:='10'               (correct the answer)
>>.CLEAR 0                 (clear breakpoint in CNVT)
>>.BREAKPOINT 26           (after first call to CNVT 
                         in I_FORMAT)
Break #0 set.
>>.PROCEED
Breakpoint #0 in routine I FORMAT at 
                    TEST F@26
>>I_FORMAT  (check answer returned by I_FORMAT)
'100'
>>.CLEAR 0                 (it's OK--clear this breakpoint)
>>.PROCEED                 (return from I_FORMAT)
Breakpoint #1 in routine F FORMAT at 
                    TEST F@1/26
>>.STEP                    (step over call to I_FORMAT
in routine F FORMAT at TEST F@1/28
                 for fraction
>>.DISPLAY SCOPE
TEST FORMAT    (HISEG=400010,LOW=140)
F FORMAT   (BASIS=7250)
>>INTPART                  (check values of variables 
'100'                      in F_FORMAT)
>>FRACPART
'00'
>>.STEP  (looks good--step ACTUAL_FW
                 computation
in routine F FORMAT at TEST F@1/29 
>>ACTUAL_FW
6
>>.BREAKPOINT 39           (set breakpoint at end 
                         of F_FORMAT.
Line 38 instead?           Notice that default page is one
<cr>                       containing current statement.)
Break #0 set.
>>.PROCEED
Breakpoint #0 in routine F FORMAT at TEST F@1/38 
>>F_FORMAT                 (check the answer--it's OK)
'100.00'
>>.DISPLAY BREAKPOINTS
0 TEST F@1/38
1 TEST F@1/26
>>.CLEAR                   (clear all breakpoints)
Clear all?
<cr>
>>.BREAKPOINT 20 '.IF NUM = 10 THEN CNVT := "10"; .P'
                           (patch so error won't show
Break #0 set.               up in subsequent testing)
>>.PROCEED                 (continue to print the answer)
100.00                     (ta-dum--the right answer)
*<cr>
total fw: 6                (try again with patch in)

Sample Debugger Session
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 33

frac_fw: 2
*100
100.00

Sample Debugger Session
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 34

               APPENDIX A - PROGRAM LISTING

Program Listing
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 35

Program Listing
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 36

Program Listing
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 37

               APPENDIX B - DEBUGGER SYNTAX

The  debugger's  syntax  is listed in full below.  The same
conventions used earlier are used here also.

abort-command            ::= .ABORT

boolean-expression       ::= term [ relop-term ]

breakpoint-command       ::= .BREAKPOINT source-reference
                               [ string-constant ]

breakpoint-count         ::= integer-constant

breakpoint-number        ::= integer-constant

clear-command            ::= .CLEAR [ breakpoint-number ]

command-line             ::= debug-statement 
                           [ ';'debug-statement ]
                           ... end-of-line

commands-command         ::= .COMMANDS

compound-debug-statement ::= BEGIN debug-statement  
                           [ ';'debug-statement ] ... END

constant                 ::= integer-constant 
                           | real-constant  
                           | string-constant
                           | set-constant

Debugger Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 38

debugger-command         ::= abort-command  
                           | breakpoint-command
                           | clear-command
                           | commands-command 
                           | display-command 
                           | help-command 
                           | if-command 
                           | kind-command 
                           | open-command 
                           | proceed-command 
                           | sstep-command 
                           | step-command 
                           | stop-command 
                           | version-command 
                           | where-command 
                           | with-command 

debug-statement          ::= compound-debug-statement 
                           | simple-debug-statement

debug-statement-count    ::= integer-constant

digit                    ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
                           | 8 | 9 

display/modify-request 
                         ::= display-request 
                           | modify-request

display-command          ::= .DISPLAY display-option

display-option           ::= BREAKPOINTS 
                           | EXTSTATUS
                           | FILES [ module'@' ]
                           | IOSTATUS 
                           | LOCATION 
                           | MODULES 
                           | PAGES [ module'@' ] [ file ] 
                           | SCOPE 
                           | STACK [ number-of-frames ] 

display-request          ::= {constant | reference}

factor                   ::= unary-expr 
                           [ AND unary-expr ] ...
 
field-ref                ::= other-ref.identifier

file                     ::= identifier | integer-constant

Debugger Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 39

help-command             ::= .HELP

identifier               ::= letter [ letter | digit
                           | '_' ] ...

if-command               ::= .IF boolean-expression 
                           THEN debug-statement
                           [ ELSE debug-statement ]

indexed-ref              ::= other-ref 
                           '[' {constant | reference} 
                           [ ','{constant | reference} ] 
                           ... ']'

invocation-number        ::= integer-constant

kind-command             ::= .KIND source-reference

letter                   ::= A | B | C | D | E | F | G
                           | H | I | J | K | L | M | N
                           | O | P | Q | R | S | T | U
                           | V | W | X | Y | Z
                           | a | b | c | d | e | f | g
                           | h | i | j | k | l | m | n
                           | o | p | q | r | s | t | u
                           | v | w | x | y | z

line-number              ::= integer-constant

modify-request     ::= 
                           reference := 
                           {constant | reference}

module                   ::= identifier

number-of-frames         ::= integer-constant

open-command             ::= .OPEN   [ scope-reference 
                           | stack-frame-number ]

other-ref                ::= field-ref | indexed-ref
                           | pointer-ref | identifier

page                     ::= identifier | integer-constant

pointer-ref              ::= other-ref^

primitive-expr           ::= {constant | reference} 
                           | '(' boolean-expression ')'

proceed-command          ::= .PROCEED [ breakpoint-count ]

Debugger Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 40

range                    ::= {constant | reference}..
                           {constant | reference}

record-reference         ::= reference

reference                ::= substring-ref | slice-ref 
                           | other-ref

relop                    ::= IN | = | <> | <= | < 
                           | >= | >

routine-name             ::= identifier

scope-reference          ::= module'@'  
                           | [ module'@' ] routine-name':' 
                             [ routine-name':' ] ... 
                             [ '('invocation-number')' ]

set-constant             ::= '[' [ set-element 
                           [','set-element ] ... ] ']'

set-element              ::= {constant | reference}
                           | range

simple-debug-statement   ::= debugger-command   
                           | display/modify-request

slice-ref                ::= other-ref '[' 
                           [ {constant | reference}',' ]
                           ... range ']'

source-reference         ::= [ module'@' ] [ file'-' ] 
                           [ page'/' ]
                           line-number

sstep-command            ::= .SSTEP 
                           [ debug-statement-count ]

stack-frame-number       ::= integer-constant

step-command             ::= .STEP 
                           [ debug-statement-count ]

stop-command             ::= .STOP

Debugger Syntax
                              
                              
                              


Tymshare Pascal Debugger User's Guide               Page 41

substring-ref            ::= other-ref '[' 
                           {constant | reference}':'
                           {constant | reference} ']'

term                     ::= factor [ OR factor ] ...

unary-expr               ::= [ NOT ] primitive-expr

version-command          ::= .VERSION

where-command            ::= .WHERE reference

with-command             ::= .WITH 
                           [ record-reference 
                           [ ','record-reference ] ... ]

Debugger Syntax


Tymshare Pascal Debugger User's Guide               Page 42

SECTION     HEADING                                   PAGE

1        INTRODUCTION                                 1

1.1      Compiling a Module in DEBUG Mode             1

1.2      Entering and Reentering the Debugger         2

1.3      Identifier Length                            2

1.4      The Debugger Symbol Table File               2

1.5      Debugging Overlay Programs                   3

2        DEBUGGER COMMAND SYNTAX                      5

2.1      The Command Line                             5

2.2      Syntax of User-Entered Constants             5

2.3      Referencing Program Text                     6

2.4      Referencing Program Data                     7

3        DEBUGGER COMMAND DESCRIPTIONS                10

3.1      Inquiry Commands                             10

3.2      Display/Modify Requests, Related Commands    14

3.3      Execution Control Commands                   20

4        COMMAND AND SYNTAX SUMMARY                   24

5        DEBUGGER ERROR MESSAGES                      26

6        SAMPLE DEBUGGER SESSION                      30

APPENDIX A - PROGRAM LISTING                          34

APPENDIX B - DEBUGGER SYNTAX                          37

Debugger Syntax
                    

     
