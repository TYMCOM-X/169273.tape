#define(#sect,title,
$ski 2
$need 4
$section
$entry '^#	title	\'
^#.\\^U&title&|U
$ski
)
#sect(Introduction)
This document reports the results of an examination of code produced
by the OMSI Pascal compiler (Version 1.2) and the associated runtime
routines for the RT-11 operating system.
This evaluation had two goals.
First, an attempt was made to identify Pascal constructs which resulted
in high space overhead.
Second, the runtime environment and runtime routine calling conventions
were examined.
#sect(Storage Allocation)
The storage required for the elementary Pascal types is summarized in
a table given at the end of this section.
The PACKED qualifier is ignored by the compiler, so the sizes given
also apply to the types when they are components of packed structures.
Any elementary object larger than a single byte is allocated on a word boundary
(the PDP-11 hardware essentially mandates this).
This is important to keep in mind when declaring records.
For example, the first record declaration given below requires one more byte
than the second:
$tabs 9,17,25,33
$ver
$ski
        big = record
          b: boolean;
          i: integer;
          c: char
        end;
        small = record
          b: boolean;
          c: char;
          i: integer
        end;
$ski 3 $need 4
	^U&Type&|U		^U&Size in Bytes&|U
	boolean			1
	char			1
	integer			2
	pointer			2
	single real		4
	double real		8
	sets			8
$jus
$ski 1
#sect(Register Usage)
R6 is used as the stack pointer.
Parameters and local variables are addressed relative to it.
However, the offset from R6 of a local or parameter is not necessarily
constant for the duration of a procedure.
For example, at the start of a FOR loop six bytes of temporaries are
pushed onto the stack.
The compiler then generates the offsets adjusted by this amount until
the end of the FOR loop.
R5 points to the base of the static storage area.
Note that this is possible because static variables declared in a
separately compiled module are assumed to exactly match those declared
in the main program, i.e., static variables are treated similarly
to variables declared in a Fortran unnamed common area.
R0 - R4 are used for expression evaluation.
WITH registers are allocated downward starting at R3.
With the exception of WITH registers, R0 - R4 are not allocated
across Pascal statements.
This means that the compiler need save only registers currently allocated
as WITH registers across procedure calls.
Functions invoke a runtime routine to save R0 - R3 (and the global
variable $FILE used by the I/O runtime routines).
For calls to routines at lexic level greater than one, R4 is used
to pass the address of the caller's static link (a pointer to the static
link of the routine lexically containing the caller).
#sect(Pascal Procedure Calls)
The prologue instructions emitted at the beginning of each Pascal
routine are variable in number but generally only one or two are
necessary.
The one glaring exception to this is the table of nine 'MOV (R4),R4'
instructions preceding all routines declared at lexic level two or
greater.
Callers enter the routine at the point appropriate in the
table for chasing the static chain and setting up the static link
in the callee's frame.
One instruction is generated to allocate space in the stack for the
local variables of the routine, if necessary.
For procedures, if stack overflow checking is enabled a call to
a runtime routine is generated next.
For functions a call to a runtime routine is always generated for
saving R0 - R3 and $FILE and for checking for stack overflow.
$ski
Pascal routine calls also tend to be fairly short.
If the routine is a function then enough zero words are pushed onto
the stack to reserve space for the return value.
If the called routine is at lexic level greater than or equal to two
the start of the static chain is moved to R4.
Next the parameters are pushed onto the stack.
Value parameters have their actual values pushed; 
VAR parameters have their addresses pushed.
Finally, the routine is called with a 'JSR PC,<routine addr>'.
Upon return the parameters have been popped from the stack.
Any function return value is at the top of the stack.
$ski
A stack frame has the following format:
$ski
$ver $need 14
	|		|
	+---------------+
	| fcn ret value |   +
	+---------------+
	| parameters    |
	|		|
	+---------------+
	| return addr   |
	+---------------+
	| local vars    |
	|		|
	+---------------+
   R6-->| static link   |
	+---------------+   -
	|		|
$jus
#sect(Compiler Generated Code)
The code generated by the compiler is generally good in a
local sense (i.e., good given that the compiler uses very
little context).
For example, shifts are used for integer divides and multiplies
by powers of two.
The source construct 'I := I + 1' will generate a single increment
instruction.
Two words of local variables are allocated on the stack with a
'CMP -(R6),-(R6)' instruction.
This section documents a number of miscellaneous observations
about the code generated.
Most of the comments describe language constructs which generated
relatively large amounts of code.
$ski
The NIL pointer value is internally represented as zero.
$ski
All code for string operations (string assignments and
comparisons) is generated in line.
This can be lengthy; for example, a string compare for which
a boolean value is actually generated requires approximately 40(8) bytes.
$ski
All set operations are done via runtime routines.
The parameters to the runtime routines are passed on the
stack and the result of the operation is left on the stack.
The code to push a set onto the stack is not generated in-line;
a runtime routine is passed the address of the set and does
the actually pushing of the set onto the stack.
Thus a set IN operation generates the following code: the address
of the set is pushed onto the stack, a runtime routine is called
to push the set onto the stack, the value to be tested for 
membership is pushed onto the stack, a runtime routine is called
to do the IN test.
The result is left on the stack.
If the set is not zero based code is also generated in-line
to subtract the lower bound of the set from the test value.
Note that always operating through the stack produces especially bad
code for set assignments where the right hand side is a constant
set or a set reference.
The sequence generated is: push the address of the right hand side
set onto the stack, call a runtime routine to push the set onto the
stack, push the address of the destination set variable, call a runtime
routine to pop the set from the stack into the left hand side variable.
$ski
The code for double precision real number operations is similar in that
all operations are done by first pushing the operands onto the stack.
The one difference is that pushing and popping of double real values
onto the stack is done by in-line code rather than runtime routines.
Thus an assignment of a double real constant or reference requires a
minimum of eight in-line instructions - four to push the value
onto the stack and four to move it from the stack to the target
variable.
$ski
Case statements generate a jump table plus approximately 32(8)
bytes of prologue instructions.
The case table requires ord(<highest case label>) - ord(<lowest case label>)
+ 1 one word entries.
$ski
Constants in the code area are generated once for each time they
appear in the code, if they cannot be generated as immediate
values (booleans, integers, chars and enumerated types are
generated as immediate operands).
Thus if a constant is to be used in more than one
place a named constant should be used if permitted.
$ski
Whenever an external procedure or function declaration is encountered
a jump instruction to the external symbol is generated.
Subsequent calls to the routine generate an JSR to 
the jump instruction.
Thus external routine declarations should be used only
if the routine is actually called.
$ski
The compiler optionally emits stack overflow checks and array
subscript checks.
The stack overflow checks require 4 extra bytes per procedure,
no extra overhead is incurred for a function declaration.
Subscript checks generate approximately 20(8) bytes per
array indexing operation.
$ski
Integer multiplications and additions are done via runtime
routines.
This is done so that the compiler generated code is independent
of whether or not a machine has the EIS option (which supplies
hardware integer multiply and divide instructions).
Single precision real addition, subtraction, multiplication and
division instructions are emitted in-line.
If the machine lacks these instructions (they are supplied by the
FIS option) they are interpreted by trap routines in the runtime.
#sect(Runtime Routine Calling Conventions)
The runtime routine calling conventions are simple and consistent.
Parameters are pushed onto the stack before the call and popped
from the stack by the runtime routine.
A 'JSR PC,<rt addr>' is used for the actual call.
The return value, if any, is left on the stack;
the runtime routine shuffles the return address around if necessary
before returning.
The two routines which have multiple output parameters (RESET and
REWRITE) pass the output parameters by reference and then pop
all argument words from the stack.
File variables passed to I/O runtime routines are special cased.
If the file variable is INPUT or OUTPUT (which are associated with
the terminal by default), a special entry point to the routine is
used.
Otherwise the file variable's address is stored in the global
variable $FILE by in-line code.
The compiler tracks the file currently in $FILE and generates
code to load it only if necessary.
All runtime routines preserve all registers.
A few routines (double real comparison and set IN routines)
return with the condition codes set to meaningful values.
#sect(Miscellaneous Runtime Notes)
The runtime routines may be classified into five groups: I/O routines,
mathematical functions, software double precision routines, heap
management routines, set operations and miscellaneous routines.
The miscellaneous routines are few in number and include routines
to save and restore registers for functions, the program
initialization routine, and the run time check and error routines.
The routines are split up into many modules;
a program will pull very little unused code from the runtime library.
Some of the routines are quite lengthy;
the best example is the code for RESET and REWRITE.
These two routines and a helper module occupy 3433(8) bytes.
$ski
The dynamic memory management routines, for implementing NEW and DISPOSE,
have two interesting properties.
First, a new of a record with variants will always result in space for the
largest possible variant being allocated.
One of the motivations for this is that allocated blocks contain no
length word; the deallocation routine must be passed both the pointer
to the block and the length of the block.
Second, both the allocation and deallocation routines may throw away
small blocks; these blocks are then permanently inaccessible.
This occurs when a block is too small (less than 4 bytes) to contain
the necessary control information needed to link the block on to
the free list.
A dispose of a block of less than 4 bytes will cause the block to be lost
if it cannot be coalesced with an adjacent block.
During a new operation if the allocated block is larger than required,
the trailing unused portion of the block is added to the free list.
If this unused portion is less than four bytes and cannot be coalesced
with the following block, then it will also be lost.
For example, both of the following programs cause a heap overflow even
though they new and dispose of the same amount of space on each
iteration of the loops.
$ski
$ver
program smr001;
var
  intptrx, inptra, intptrb: ^integer;
begin
  new(intptrx);
  new(intptra);
  while 1 <> 2 do begin
    new(intptrb);
    dispose(intptra);		(* too small - space lost *)
    intptra := intptrb;
  end
end.
$ski
program smr002;
type
  pa12 = packed array [1..2] of char;
  pa14 = packed array [1..4] of char;
  pa16 = packed array [1..6] of char;
var
  pa12a: ^pa12;
  pa14a: ^pa14;
  pa16x, pa16a, pa16b: ^pa16;
begin
  new(pa16x);
  new(pa16a);
  while 1 <> 2 do begin
    new(pa16b);
    dispose(pa16a);		(* ok so far *)
    new(pa14a);			(* 2 bytes lost when block split *)
    pa16a := pa16b;
    dispose(pa14a);
    new(pa12a);			(* 2 more bytes lost during split *)
    dispose(pa12a);		(* too small - final 2 bytes lost *)
  end
end.
$jus
$ski
#sect(OMSI and MDSI Pascal Incompatabilites)
OMSI Pascal is largely a subset of MDSI Pascal.
There are some obvious but unavoidable syntactic differences
between the two languages.
There are also some semantic incompatabilites beteen the two languages.
These semantic incompatabilities can, in most cases, be avoided by
following certain coding conventions.
Since an MDSI Pascal cross compiler will probably be availble for
the MPS target system at some future date, these incompatible features
should be avoided where possible.
$ski
MDSI Pascal forbids assignments to value parameters;
OMSI Pascal permits such assignments.
Such assignments are easily avoided by assigning the parameter
to a local variable and then subsequently modifying the local
variable when necessary.
Note also that the OMSI compiler passes all value parameters by
copying them (MDSI passes all large value parameters by address).
Thus large records and arrays should usually not be passed as
value parameters.
$ski
Even though the PACKED attribute is ignored by the OMSI compiler,
it may not be by future compilers and should be used where
appropriate.
$ski
When declaring procedure or function variables or formal parameters
the OMSI compiler does not require that the number, kind or types
of the parameters be declared.
MDSI Pascal does require this information; thus procedure or
function variables should only be used with actual procedure or
function values which have matching parameter declarations.
$ski
OMSI associates INPUT and OUTPUT with the terminal by default;
MDSI Pascal uses TTY and TTYOUTPUT for this purpose.
For compatability, it may be best to explicitly declare all
file variables and explicitly name all files.
It is also a good idea to encapsulate all file opening and closing
in routines expressly for that purpose since the parameters to
the open routines are also different in the two languages.
$ski
As previously mentioned, OMSI Pascal uses a Fortran common area approach
to global variables.
This can easily lead to subtle errors if the variable declarations
in different compilations do not match exactly.
One solution to this problem is to declare all public variables in
a separate file.
The OMSI compiler does permit multiple input files.
Thus the file of public variables could be compiled with all modules
of the program requiring access to publics.
#sect(Conclusion)
The important points for space efficient coding in OMSI Pascal are:
order fields of records so that odd length fields are grouped together,
avoid unnecessary external procedure declarations, avoid the declaration
of procedures and functions at lexic levels greater than or equal to
two, and use named constants for large constant values when permitted.
In addition, for compatability with MDSI Pascal the suggestions in the
preceding section should be followed.
 