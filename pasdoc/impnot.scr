$num off
$center
PASCAL-10 Implementation Notes
$ver
$ski4
$tab 15
1.\\	INTRODUCTION

2.	RUNTIME ENVIRONMENT

2.1.	Memory layout
2.2.	Initialization
2.3.	The stack
2.4.	The heap

3.	CODE GENERATION

3.1.	Register allocation
3.2.	Processor dependent code
3.3.	Runtime range checking
3.3.1.	Pointers
3.3.2.	Scalars and subranges
3.3.3.	Subscripts
3.4.	Data representation
3.4.1.	PDP-10 word formats
3.4.2.	INTEGER
3.4.3.	REAL
3.4.4.	CHAR
3.4.5.	BOOLEAN
3.4.6.	STRING
3.4.7.	SET
3.4.8.	Pointers and NIL
3.4.9.	Subranges
3.4.10.	Scalars
3.4.11.	ARRAY
3.4.12.	RECORD
3.4.13.	FILE
3.5.	Address generation
3.5.1.	Out of scope variables
3.5.2.	Indirection
3.5.3.	Record fields
3.5.4.	Array elements
3.5.5.	String elements
3.6.	Parameters and procedure/function calls
3.6.1.	Formal versus actual
3.6.2.	Parameter storage allocation
3.6.3.	Formal procedure/function parameters
3.6.4.	Function return values
3.7.	General code layout
3.8.	Boolean expressions
3.8.1.	AND
3.8.2.	OR
3.8.3.	NOT
3.8.4.	ANDIF
3.8.5.	ORIF
3.8.6.	Relationals
3.9.	Arithmetic expressions
3.9.1.	Addition, subtraction
3.9.2.	Multiplication
3.9.3.	Division
3.9.4.	Exponentiation
3.10.	Set manipulation
3.10.1.	Union
3.10.2.	Intersection
3.10.3.	Difference
3.10.4.	Equality
3.10.5.	Inclusion
3.10.6.	Membership
3.11.	Strings
3.11.1.	Descriptors
3.11.2.	LENGTH
3.11.3.	Substring
3.11.4.	UPPERCASE and LOWERCASE
3.11.5.	Runtime support
3.12.	Control constructs
3.12.1.	FOR
3.12.2.	WHILE
3.12.3.	REPEAT
3.12.4.	LOOP
3.12.5.	EXIT IF
3.12.6.	WITH
3.12.7.	CASE
3.12.8.	IF...THEN...ELSE
3.12.9.	GOTO
3.13.	Calling non-PASCAL routines
3.13.1.	MACRO
3.13.2.	COBOL, ALGOL
3.13.3.	FORTRAN
3.14.	Standard procedures and functions

4.	RUNTIME SUPPORTS

4.1.	Initialization and termination
4.2.	Stack manipulation, procedure calls/returns
4.3.	Heap management
4.4.	I/O
4.5.	Strings
4.6.	Conversion
4.7.	Exponentiation
4.8.	Miscellaneous
4.9.	Error interception
4.10.	Double precision floating point

5.	PASCAL REL FILE FORMAT

5.1.	LINK-10 item types
5.2.	Common sources of LINK-10 load-time errors

6.	DEBUGGER INTERFACE

6.1.	Program link word
6.2.	Procedure block
6.3.	Program block
6.4.	Statement block
6.5.	Page block
6.6.	File block
$page
$num 1

1.\\&Introduction&
$ski
$title left 'PASCAL-10 IMPLEMENTATION NOTES' left 'May 1978' left 'Page \'
This document provides information on the data
structures, code emission, library routines,
runtime environment, and to some extent, the LINK-10
and debugger interfaces of the MDSI PASCAL-10
compiler as of April 1978.
Sufficient detail has been included to enable
a reasonably competent programmer to
monitor the runtime workings of a PASCAL
program.
$ski
$cen

Written in May, 1978, by Stephen Medlin
$jus
$page
2.\\&Runtime Environment&
$ski
2.1.\\&Memory layout&
$ski
Memory on the PDP-10 is divided into a high (code)
segment and a low (storage) segment:
$skip 2
$ver
       |               | (highest address)
       |  code and     |                       high "clean"
       |  constants    |                        segment
       |               |
       |---------------| <-- 400000b
       
       |               |
       |  heap         |
       |               |                       low "dirty"
       |---------------|                        segment
       |               |
       |  stack        |
       |               |
       |---------------|
       |               |
       |  static       |
       |  storage      |
       |               | <-- 141B
       |---------------|
       |               | <-- 140B
       | job data area |
       |               |
       |---------------| <-- 0
$jus
$skip 3
2.2.\\&Initialization&
$ski
The main procedure calls a runtime routine 
INITP.\to obtain core for the stack, to perform a RESET,
and to initialize the main program's stack frame.
$ski
2.3.\\&The Stack&
$ski

On return from INITP.\the stack pointers in
registers BASIS (16B) and TOPP (17B) are as follows:
$ski
$ver
    (BASIS) = 0,,stack address
     (TOPP) = 40B-stack size,,stack address
$ski
$jus
$page
40 locations are reserved in the stack for the runtime
routines.
The main program allocates any required storage with
an ADJSP\TOPP,n, resulting in the
basic stack:
$ski2
$ver
                  |              |  (bottom of stack)
                  +--------------+
     BASIS------->|  "link" word |
                  +--------------+
                  |              |
                  |              |
                  |    local     |
                  |   storage    |
                  |              |
     TOPP-------->|              |
$ski2
$jus
During program execution BASIS always points to the bottom of
the current stack frame and TOPP to the top.
With the exception of the main program,
whose BASIS has a zero left half, both halves
of BASIS are identical.
The "link" word stored in the stack
is the address of the word following the call
to INITP.
Procedures and functions employ a runtime routine
(generally PNTRY.) to initialize the
header block of the local stack frame.
After return from PNTRY.\and allocation of the frame
with an ADJSP, a procedure's stack is:
$ski2
$ver
              |                                |
              +--------------------------------+
     BASIS--->| flags,,return address          |
              +--------------------------------+
       +1     | caller's BASIS,,parent's BASIS |
              +--------------------------------+
       +2     | TOPP on entry                  |
              +--------------------------------+
       +3     | 0,,1+procedure address         |
              +--------------------------------+
              |                                |
              | local storage                  |
              |                                |
     TOPP---->|                                |
$jus
$ski2
The "caller's BASIS" is the base address of the
&calling& routine's stack frame and the "parent's
BASIS" is the base address of the stack frame of the 
&called& routine's &parent& or enclosing routine.
These two pointers form, respectively, what's known as the
&dynamic chain&, linking the stack frames of all
procedures which have been called and not yet
returned, and the &static chain&, linking the frames
of all routines in enclosing levels of scope.
The entry point of a local or "internal" procedure
is preceded by one or more instructions:
$ski
$ver
\\\\\HRR	BASIS,1(BASIS)
$jus
$ski
which set up the static chain (see section 3.6.).
The "link" word at 3(BASIS) is merely the address
of the word following the call to PNTRY.\and
provides linkage to TRACE and DEBUG informaion
(see section 6).
$ski
$ver
    PROGRAM MAIN;
    PUBLIC PROCEDURE P;
       PROCEDURE Q;
       BEGIN
          TRACE
       END;
       PROCEDURE R;
       BEGIN
          Q
       END;
    BEGIN (* P *)
       R
    END;
    BEGIN (* MAIN *)
       P
    END.
$jus
$ski
Just before the call to TRACE the stack is:
$need 20
$skip 2
$ver
                 |                  |
                 | main stack frame |<-+
                 |                  |  |
              +->| P return address |<---+---+
              |  |   0          ----|--+ |   |  see note below
     dynamic  |  |                  |    |   |
      chain   |  | P stack frame    |    |   |  static
              |  |                  |    |   |   chain
            +-|->| R return address |    |   |
            | +--|----          ----|----+   |  caller of R is P
            |    |                  |        |  parent of R is P
            |    | R stack frame    |        |
            |    |                  |        |
     BASIS--|--->| Q return address |        |
            +----|----          ----|--------+  caller of Q is R
                 |                  |           parent of Q is P
                 | Q stack frame    |
     TOPP------->|                  |
$skip 2
$jus
A public or level 1 procedure or function has
no parent and merely saves and restores the 
BASIS of the calling routine.
$ski
File buffers are allocated dynamically at the top
of the stack by the runtime.
$page
2.4.\\&The Heap&
$ski
The heap is managed by the runtime with a "quick
fit" allocation scheme.
Briefly, a heap consists of storage and a
twenty word header block containing a pointer
to the previous heap (since they may be
stacked by MARK), a pointer to the end of
the heap, and the head pointers of eighteen
free-list chains (individual lists are maintained
for blocks less than eighteen words in length
and one list for blocks eighteen words or
larger).
An allocated block has a "hidden"
word with the negative of its size at one
less than the address returned by NEW.
Free blocks are kept on doubly-linked lists
with previous and next pointers
in the left and right halfwords, respectively, of the
first word of each block.
$ski
Expansion of the low segment and splitting/joining
free blocks are performed as required and are not
detailed in this document.
$page
3.\\&Code Generation in PASCAL-10&
$ski2
Much of the code produced by the PASCAL compiler
occurs in patterns, necessarily varied according to
addressing modes and data types.
The following sections describe the general
code patterns for particular aspects of the language.
$ski
3.1.\\&Register allocation&
$ski
BASIS and TOPP (registers 16B and 17B, respectively)
are the local stack frame pointers as described in
previous sections.
Registers AC0 and AC1 are used for
address computation and linkage or the passing
of parameters to some of the runtime routines.
AC2 through AC7 (commonly known as REG, REG1,
..., REG5) are used to pass parameters to 
PASCAL procedures and functions.
WITH registers are assigned from AC14 downward,
while expressions are evaluated starting
with AC2 and working upward.
$ski
3.2.\\&Processor dependent code&
$ski
The emission of certain instructions may be
suppressed by specifying the KA10 or KI10 options.
In particular, the KL10 (the default) has an
ADJSP (adjust stack pointer) instruction
lacking in the other processors.
For the KA and KI the ADJSP emitted in the
entry code of a procedure is replaced by a three-word
sequence to achieve the same result.
For the KL the compiler also emits an
ADJBP (adjust byte pointer, actually
LDB with a non-zero AC) in the rare occurance
of a substring of a substring.
$ski
The KA10 lacks the double-word moves DMOVE
and DMOVEM frequently emitted for sets and
ALFA names.
Under the KA10 option the words are moved
independently.
$ski
3.3.\\&Runtime range checking&
$ski
Under the CHECK option code is generated
to intercept certain data errors at runtime.
$ski
3.3.1.\\&Pointers&
$ski
Pointers are checked for zero and NIL prior
to dereference:
$ski
$tabs5,12,30
$ver
	MOVE	REG,PTR	;loads pointer
	SKIPE	REG	;if zero
	CAIN	REG,377777	;or if NIL
	JSP	AC0,PTRER.	;then print error message
	\	\	;else continue
$ski
$jus
3.3.2.\\&Assignment&
$ski
Values assigned to variables of type scalar
or subrange are subject to comparison
with the minimum and maximum of the type:
$ski
$ver
	VAR\I:	MIN..MAX;
	...
	I\:=\2 * MIN;

	MOVEI	REG,2
	IMULI	REG,MIN
	CAIG	REG,MAX	;if greater than MAX
	CAIGE	REG,MIN	;or if less than MIN
	JSP	AC0,SRERR.	;then trap error and stop
	MOVEM	REG,I
$ski
$jus
3.3.3.\\&Arrays and strings&
$ski
Array subscripts are compared with the minimum
and maximum indices.
Constant subscripts are checked
at compile time, while subscript expressions are subject
to runtime verification:
$ski
$ver
	VAR\I:\\INTEGER;
	\\\\A:\\ARRAY[MIN..MAX] OF INTEGER;
	...
	I :=\A[I]

	MOVE	REG,I	;get subscript
	SUBI	REG,MIN	;if MIN>0. If MIN<0 this
	\	\	;is ADDI REG,-MIN
	CAIL	REG,0	;if I-MIN<0
	CAILE	REG,MAX-MIN+1	;or if I-MIN>MAX-MIN
	JSP	AC0,INXER.	;then trap error
	etc.	                  ;else get array element
$ski
$jus
String subscripts must be greater than zero and not
greater than the current length of the string:
$ski
$ver
	VAR\CH:CHAR; I:INTEGER;
	\\\\\S:STRING[40B];
	...
	\\\\CH:=S[I];

	MOVE	REG,I	;get subscript
	MOVE	AC14,S	;load length of S
	CAIL	REG,1	;if subscript<1
	CAMLE	REG,AC14	;or greater than current length
	JSP	AC0,INXER.	;than trap error
	etc.	\	;else continue.
$jus
$ski
Subscripts generated by SUBSTR may be zero
or one greater than the current length:
$ski
$ver
	CH:=SUBSTR(S,I,1);
$ski
	MOVE	REG,I
	MOVE	AC14,S	;get current length of S
	CAIL	REG,0	;if subscript<0
	CAILE	REG,1(AC14)	;or greater than length+1
	JSP	AC0,INXER.	;then error.
	etc.
$jus
$ski
3.4.\\&Data representation&
$ski
Code generation is, of course, highly dependent
on data structure.
$ski
3.4.1.\\&PDP-10 word formats&
$ski
Storage consists of 36-bit words which may
be manipulated as two 18-bit halfwords.
Any consecutive sequence of bits within a word
may be accessed through a &byte pointer&
(see &System Reference Manual&).
The compiler emits or constructs byte pointers
to reference &packed& fields unless occupying a full
or half-word.
$ski
3.4.2.\\&INTEGER&
$ski
Full 36-bit signed quantity; never packed.
$ski
3.4.3.\\&REAL&
$ski
Single precision (36-bit) DEC-10 format floating
point; never packed.
Under the DOUBLE option, double precision (72-bit)
floating point.
$ski
3.4.4.\\&CHAR&
$ski
Standard 7-bit ASCII (0..177B); may be packed.
$ski
3.4.5.\\&BOOLEAN&
$ski
Generally FALSE=0 and TRUE=1; occupies a 
single bit if packed, otherwise right-justified in a full 
word.
$ski
3.4.6.\\&STRING&
$ski
One word is reserved for the current length of the
string, followed by storage reserved for the maximum
length at five characters per word left-justified
(rightmost bit of each word is unused).
A string of zero length is the null string.
$ski
No "range-checking" is performed on the standard types
INTEGER, REAL, CHAR and BOOLEAN, though STRING is
subject to minimum/maximum length checks.
$ski
3.4.7.\\&SET&
$ski
A set is stored as 72 bits (two words) with the first
bit representing the lowest element of the set
and the last bit the highest.
Thus a set of 0..71 maps directly onto these bits,
however for a set of CHAR the first bit represents 40B
(ASCII space) and the last bit 147B (ASCII 'g').
$ski
3.4.8.\\&Pointers and NIL&
$ski
If packed, a pointer occupies 18 bits, usually
halfword aligned due to relocation restrictions,
otherwise it is right-justified in a full word.
The NIL pointer is defined to be 377777B.
$ski
3.4.9.\\&Subranges&
$ski
Normally treated as integers, though subject to
runtime range checking; may be packed if the
lowerbound is nonnegative.
A packed subrange is allocated the maximum
number of bits required to represent its
upperbound, i.e.,
$ski
$ver
	CEIL\(LOG2(upperbound)).
$ski
$jus
For example:
$ski
$ver
	Type A = 0..3;		(*BITSIZE(A)\=\2\*)
	\\\\\B = 0..100;	\(*BITSIZE(B)\=\7\*)
	\\\\\C = -10..10;	\(*BITSIZE(C)\=\36*)
$jus
$ski
3.4.10.\\&Scalars&
$ski
Scalars are assigned values sequentially
from zero. Thus
$ski
$ver
	TYPE COLOR = (RED,BLUE,GREEN,HAZEL);
$ski
$jus
is essentially:
$ski
$ver
	CONST RED:=0; BLUE:=1; GREEN:=2; HAZEL:=3;
	TYPE COLOR = RED..HAZEL;
$jus
$ski
It should be noted, however, that scalars and integer
constants are NOT type compatible.
Even though ORD(BLUE) is 1, the statement IF BLUE=1 THEN...generates
an error if BLUE is a scalar.
$ski
3.4.11.\\&ARRAY&
$ski
Multiply-dimensioned arrays are allocated
storage in row-major order (i.e., arrays of arrays).
An array &always& starts on a fullword boundary
and occupies an integral number of words.
Storage is allocated sequentially for each
element from the lowerbound to the upperbound.
The elements of an array may be packed if and
only if each element can be stored in 18 or fewer
bits.
$ski
Consider:
$ski
$ver
	VAR A: PACKED ARRAY [0..10] OF 0..377B;
$jus
$ski
Each element requires eight bits of storage, thus four elements
may be packed into 36-bit word, left-justified.
Figure 3.1 shows the layout of the array.
Unused bits in a packed array are truly
unused and may not be allocated to other variables.
Every attempt is made to assure that
unused bits in packed structures are zero:
$ski
$ind left 8
$par-4
1.\\Static storage is initialized to zero
by the operating system.
$ski
$par-4
2.\\Stack frames containing packed entities are
zeroed in the prologue of a procedure.
$ski
$par-4
3.\\Blocks allocated by NEW are zeroed.
$ind left 0
$ski
A potential problem may arise if any such bits
should be set in that two arrays could be unequal
even if each of their corresponding elements were equal.
$ski
A special type of array is a &packed array of CHAR&
with a lowerbound of one, which is essentially a fixed length
STRING whose length is always the upperbound of the array.
$skip 2
$need 8
$ver
         0        7 8     15 16    23 24    31 32   35
          +--------+--------+--------+--------+----+
     A    |    0   |    1   |    2   |    3   |    |
          +--------+--------+--------+--------+----+
     A+1  |    4   |    5   |    6   |    7   |    |
          +--------+--------+--------+--------+----+
     A+2  |    8   |    9   |   10   |             |
          +--------+--------+--------+-------------+

        Figure 3.1.  Memory layout for
                       VAR A: PACKED ARRAY[0..10] OF 0..377B
$jus
$skip 2
3.4.12.\\&RECORD&
$ski
Generally, fields within a record are allocated
sequential storage locations:
$ski
$ver
$tabs 5,10,20
	VAR R: RECORD
	\	CHAR1:CHAR;
	\	CHAR2:CHAR;
	\	VALID:BOOLEAN
	\\\\END;
$ski3
             0                    35
              +------------------+
     R        |       CHAR1      |
     R+1      |       CHAR2      |
     R+2      |       VALID      |
              +------------------+
$ski3
$jus
If, however, multiple fields are specified with a
single type they are allocated in reverse order.
$ski3
$ver
	VAR R2: RECORD
		CHAR1,
		CHAR2:CHAR;
		VALID:BOOLEAN
	\\\\END
$SKIP            0                    35
              +------------------+
     R        |       CHAR2      |
     R+1      |       CHAR1      |
     R+2      |       VALID      |
              +------------------+
$ski3
$jus
This is a common source of confusion in deciphering

compiler-generated code.
$ski
A tagfield allows multiple use of record storage:
$page
$ver
$ski3
	VAR STATS: RECORD
		SUM-OF-X: INTEGER;
		SUM-OF-X2:INTEGER;
		NUMBER-OF-X: 0..100;
		CASE TAG: BOOLEAN OF
		TRUE: (SUM-OF-X3:INTEGER);
		FALSE: (SUM-OF-Y: INTEGER;
		\\\\\\\(SUM-OF-Y2: INTEGER)
	END:
$ski3
    0               35           0               35
     +-------------+    STATS     +-------------+
     | SUM-OF-X    |      +1      | SUM-OF-X    |
     | SUM-OF-X2   |      +2      | SUM-OF-X2   |
     | NUMBER-OF-X |      +2      | NUMBER-OF-X |
     | TAG=TRUE    |      +3      | TAG=FALSE   |
     | SUM-OF-X3   |      +4      | SUM-OF-Y    |
     |  (unused)   |      +5      | SUM-OF-Y2   |
     +-------------+              +-------------+
$jus
$ski4
Fields in a packed record are also allocated
sequentially, packed from left to right
within a word wherever possible.
$page
$ver
$tabs 6,16,45
TYPE  ELEMENT=  PACKED RECORD
	\\\\NEXT:  ^ELEMENT;	(*18 bits*)
	\\\CLASS:  0..777B;	(*9 bits*)
	\\\\\LAB:  CHAR;	(*7 bits*)
	PREVIOUS:  ^ELEMENT;	(*18 bits*)
	\\\VALUE:  INTEGER;	(*full word*)
	\\CASE V:  BOOLEAN OF	(*1 bit*)
	\\\\TRUE:  (COUNT:INTEGER;	(*full word*)
		\\LEFT,RIGHT: ^ELEMENT);	(*18 bits each*)
	\\\FALSE:  (CH:CHAR;	(*7 bits*)
		FLAGS:PACKED ARRAY [1..3]	(*full word*)
		\\\\\OF BOOLEAN;
		ERROR:  0..10)	(*4 bits*)
	END;
$skip 3
$ver
             +------------------+------------------+
     ELEMENT |      NEXT        |  CLASS |  LAB |  |
             +------------------+------------------+
        +1   |    PREVIOUS      |                  |
             +------------------+------------------+
        +2   |                VALUE                |
             +------------------+------------------+
        +3   |V|                                   |
             +------------------+------------------+
        +4   |                COUNT                |
             +------------------+------------------+
        +5   |      RIGHT       |      LEFT        |
             +------------------+------------------+

                    (a)  "TRUE" variant


             +------------------+------------------+
        +3   |V|  CH  |                            |
             +------------------+------------------+
        +4   |FLAGS|                               |
             +------------------+------------------+
        +5   |ERROR|                               |
             +------------------+------------------+

                    (b) "FALSE" variant


        Figure 3.2.  Storage layout for an ELEMENT record
$jus
$page
NEXT is assigned bits 0-17 in the first word, CLASS
the next 9 and LAB the next 7.
Since a pointer requires 18 bits and only two remain unused
in the first word, PREVIOUS is allocated in the second word of the
record.
An integer must occupy a full word, so VALUE fills the third.
The Boolean tagfield is assigned the first bit of the fourth
word and the remainder of the record is
overlaid by fields within the variants.
COUNT requires a word to itself, while
LEFT and RIGHT are packed into a single
word (note the reversal!).
In the second variant CH is allocated
bits 1-7 in the word with V.
Even though FLAGS is an array requiring only three bits
it is assigned a full word and ERROR must be allocated
in the following word.
$ski
In this example VALUE and COUNT are addressed
as fullwords and NEXT, RIGHT, LEFT and PREVIOUS
as halfwords.
Byte pointers are emitted to access CLASS, LAB,
V, CH and ERROR.
A byte pointer is generated dynamically
at runtime to access the elements of FLAGS.
$ski
As in the case of packed arrays, unused
bits within a packed record may raise havoc with
record comparisons.
The problem may also occur, even in records which are not
packed, if the tagfield is changed.
Consider:
$ski3
STATIC VAR  R,S: RECORD
$tab 10
$ver
	FIELD1:  CHAR;
	CASE TAG:  BOOLEAN OF
	TRUE:  (FIELD2:  REAL;
	\\\\\\\\FIELD3:  CHAR);
	FALSE:  (FIELD4:  CHAR)
	END;
	...
	R.FIELD1:= '3';
	R.TAG:=  FALSE;
	R.FIELD4:=  'T';
	S:=R;
	S.TAG:=  TRUE;
	S.FIELD3:=  '+';
	S.TAG:=  FALSE;
	IF S=R THEN...
$ski
$jus
A field by field comparison of S and R would
show them equal,  though the full record
comparison fails since S.FIELD3 is '+' and
R.FIELD3 has not been initialized.
$ski
3.4.13 &FILE&
$ski
Files are represented by a &file block& of a
minimum 25B words plus storage for one component
of the file's type.
Manipulation of the file block is performed
by the runtime support routines and is described
in section 3.15.  The file block
has the following general layout:
$page
$ver
$tabs 12,21,34
F:	XWD	0,COMPONENT	;pointer to file component
			;e.g., "F^"
	Z		;Boolean EOLN
	Z		;Boolean EOF
	OPEN	STATUS	;OPEN instruction for XCT
	LOOKUP	NAME	;file lookup
	ENTER	NAME	;file creation
	IN	0	;read or get
	OUT	0	;write or put
	RELEASE	0	;CLOSE
STATUS:	Z		;file status: 0=ASCII,else 14B
	SIXBIT	/DSK\\\/	;file device
	Z		;pointer to buffer header
NAME:	SIXBIT	/FILNAM/	;file name
	SIXBIT	/EXT/	;extension
	Z		;protection
	Z		;PPN
	XWD	0,0	;left half=channel number
			;right half=buffer block address
	Z		;link in list of file blocks
	Z		;read=0, write=-1
	Z		;if ASCII mode, ASCII line number
	Z		;if ASCII; left half=character count
			;else left half=negative count of
			;words in component.
			;right half=address of first word
			;in component.

COMPONENT:  Z		;first word of component.
$jus

$ski
3.5.\\&Address generation&
$ski
Variables in the local stack frame and static
and public variables are accessed directly since their
address or offset is known at the time of compilation.
Out of scope variables, parameters passed by address,
and external variables generally require an
index register load prior to each reference.
AC1 is commonly used as a temporary base register
during address computation as well as a byte pointer
index register in access to record fields and array elements.
$ski
3.5.1.\\&Out of scope variables&
$ski
A reference to an out of scope variable requires
that the pointer to the stack frame in which the
variable is stored be loaded into the temporary
register AC1.
Thus if a variable I local to a procedure
at level 2 is referenced from a procedure at level 4 with:
I:=2, the code generated is:
$ski
$ver
	MOVEI	REG,2
	HRR	AC1, 1(BASIS)	;chase static chain
	HRR	AC1, 1(AC1)	;back two levels
	MOVEM	REG, 5(AC1)	;I:=2
$ski
$jus
3.5.2.\\&Indirection&
$ski
A variable which must be accessed indirectly,
e.g., a VAR parameter or any external variable in an
OVERLAY compilation, is &always& loaded  prior to any
reference:
$ski
$ver
	PROCEDURE P (VAR B:  BOOLEAN);
	VAR C:  BOOLEAN;
	BEGIN
	\\\\C:=  FALSE;
	\\\\B:=  FALSE;
	...

generates:

	SETZM 	5(BASIS)	;C:=  FALSE
	MOVE 	REG,4(BASIS)	;gets address of B
	SETZM	0(REG)	;B:=  FALSE.
$jus
$ski
3.5.3.\\&Record fields&
$ski
A field in a record which is not packed or a
fullword or halfword field in a packed record
is addressed as a displacement from the first word
of the record, requiring a base register only for external
records or parameters passed by address.
A truly packed field has an associated
byte pointer which assumes AC1 as a base register.
$ski
$ver
$tabs 5,12,25
	STATIC VAR REC:  PACKED RECORD
		\\\LEFT:  0..777777B; (*left halfword*)
		\\\\\CH:  CHAR
		END;
	\\\...
		REC.LEFT:=  3;
		REC.CH\\:=  ' ';

	MOVEI	REG,3	
	HRLM	REG,REC	;accessed directly
	HRRZI	REG,40	;ASCII space
	MOVEI	AC1,REC	;base address
	DPB	REG,400001	;deposit through pointer
	...
400001:XWD	130701,0	;POINT 7,0(AC1),25
$ski
$jus
3.5.4.\\&Array elements&
$ski
The general strategy followed to access as element
of an array which is not packed is:
$ski
$ind left 8
$ski
$par-4
1.\\Evaluate the subscript and if the lowerbound
is greater/less than zero then normalize by
subtracting/adding the absolute value of the lowerbound.
$ski
$par-4
2.\\If runtime checking is is effect, verify that the subscript
expression is within bounds.
$ski
$par-4
3.\\If the size of the array element is greater
than one word, multiply by the element size.

$ski
$par-4
4.\\Use the calculated expression as a displacement 
from the start of the array (may require adding the
array address).
$ind left 0
$ski
This method is repeated for each subscript
of a multidimensional array.  Example:
$ski
$ver
PUBLIC VAR A: ARRAY[1..10] OF ARRAY[-5..5] OF SET OF CHAR;
	...
	A[I,J]:=['A'..'Z'];

	MOVE 	REG,I	;first subscript
	SUBI 	REG,1	;normalized
	CAIL 	REG,0	;only if
	CAILE 	REG,11	;CHECK option
	JSP 	AC0,INXER.	;in effect
	IMULI 	REG,26	;size (A[I])=(5-(-5)+1)*2
			;  =22 words
	MOVE 	REG1,J	;second subscript
	ADDI 	REG1,5	;normalize
	CAIL 	REG1,0	;if CHECK
	CAILE 	REG1,12
	JSP 	AC0,INXER.
	IMULI 	REG1,2	;size (SET)=2
	ADD 	REG,REG1	;net offset within A
	DMOVE 	REG1,['A'...'Z']
	DMOVEM  REG1,A(REG)	;stores element set
$jus
$ski
If A were external its address would be added to the
subscript expression prior to the DMOVEM:
$ski
$ver
	MOVEI 	REG,A(REG)
	DMOVEM  REG1,0(REG)
$jus
$ski
A packed array involves somewhat more
computation to construct a byte pointer:
$ski
$ind left 8
$ski
$par-4
1.\\Evaluate the subscript expression and normalize
if necessary.
$ski
$par-4
2.\\Divide the subscript by the number of elements
packed in each word, resulting in a word displacement within
the array and a byte displacement within the word.
$ski
$par-4
3.\\Form a "basic" byte pointer based on the element
bitsize and increment with an IBP to reflect
the byte displacement determined in (2).  The 
initial pointer is
$ski
$par-4
\\\\\\\POINT bitsize,0(AC1),0
$par
or XWD\\\(440001+bitsize*100),0
$ski
$par-4
4.\\Load into AC1 the base address of the array plus the
word displacement generated in (2).
$ski
$par-4
5.\\Load/store the element with LDB/DPB.
$ind left 0
$ski
Though various other code may precede and follow
this always involves a highly recognizable sequence of
five consecutive instructions:
$tabs 5,12,38
$ski
$ver
	HRREI	REG+1,subscript
	HRLZI	REG,440001+bitsize*100	;make pointer
	IDIVI	REG+1,# elements per word
	IBP	REG	;advance byte pointer
	SOJGE	REG+2,.-1	;by byte offset
$ski
$jus
Consider the array:
$ski
$ver
	VAR\A:\\PACKED\ARRAY[1..100]\OF\0..377B;
$ski
$jus
Each element occupies eight bits, packed four to a word.
$ski
$ver
		A[I]:=3;
	
	MOVE	REG,I
	SUBI	REG,1	;normalize subscript
	CAIL	REG,0	;only if
	CAILE	REG,143	;runtime
	JSP	AC0,INXER.	;checking
	HRREI	REG1,0(REG)
	HRLZI	REG,441001	:bitsize=10B
	IDIVI	REG1,4	;(REG1)=word offset
			;(REG2)=byte offset
	IBP	REG1	;advance pointer
	SOJGE	REG2,.-1	;to correct byte
	HRRZI	REG2,3
	MOVEI	AC1,A(REG1)	;(AC1)=A+word offset
	DPB	REG2,REG
$ski
$jus
If runtime range checking is disabled the normalization
is combined with the HRREI:
$ski
$ver
	MOVE	REG,I
	HRREI	REG1,-1(REG)
$ski
$jus
For a constant subscript (e.g., A[4]) the normalization and
range check are performed at compile time, reducing the
first six instructions to simply:
$ski
$ver
	HRREI	REG1,3
$jus
$ski
3.5.5.\\&String elements&
$ski
Disregarding the length word, a string is
merely a packed array of char, five elements
to a word and seven bits to an element, however,
since strings are so common, their manipulation has
been optimized somewhat over that of packed arrays.
$ski
$ver
	VAR S: STRING; I:INTEGER;
	...
	S[I]:= 'A';

	MOVE	REG,I
	MOVE	AC14,S	;borrow a WITH register
			;and load current length
	CAIL	REG,1	;I must be between 1
	CAMLE	REG,AC14	;and current length
	JSP	AC0,INXER.	;if CHECKing
	IDIVI	REG,5	;word+byte offset
	ADDI	REG,S+1	;address of word containing S[I]
	ADD	REG,CBPSS.(REG1)	;make a byte pointer
	HRRZI	REG1,101	;ASCII 'A'
	IDPB	REG1,REG	;store character
$ski
$jus
Note that characters within strings are loaded/stored
with ILDB/IDPB rather than LDB/DPB.
CBPSS.\is merely a table of basic type pointers,
indexed by the byte offset within a word.
If runtime checking were not in effect the length
would not be loaded.
$ski
A constant subscript enables further simplification
by the compiler:
$ski
$ver
		S[7]:= 'B';
	
	MOVE	AC14,S	;if CHECK, load current length
	CAIGE	AC14,7	;must be >=7
	JSP	AC0,INXER.
	MOVEI	REG,S+2	;know word is S+1+(7 DIV 5)
	HRLI	REG,350700	;byte offset also known
	HRRZI	REG1,102
	IDPB	REG1,REG	;S[7]:= 'B'
$jus
$ski

3.6.\\&Procedure/function calls and parameters&
$ski
All PASCAL procedures and functions are called with a
PUSHJ TOPP, and return via POPJ TOPP,0.
A parameter is passed as one or two words
either in registers REG through REG4 or in
a parameter block addressed by REG5.

$ski
Public or level 1 procedures and functions
may be called from any level, however internal routines
must complete the static chain in BASIS on entry.
This is done by targeting the PUSHJ call at an
appropriate point in the HRR table preceding the
actual entry point (the JSP AC1,PNTRY.) of each
internal routine.
If a routine P defined at level L is called
from level N (L>1, N>=L-1), the actual call is
$ski
$ver
	PUSHJ	TOPP,P-(N-L+1)
$jus
$ski
If P is called by its own parent then L=N+1 and this
simplifies to PUSHJ TOPP,P since no adjustment
of BASIS is necessary.
If P recurses then L=N and the call
$ski
$ver
	PUSHJ	TOPP,P-1
$ver
$jus
$ski
executes one HRR BASIS,1(BASIS), again
setting the right half of BASIS to its
parent's stack frame, completing
the static chain.
$ski
3.6.1.\\&Formal versus actual parameters&
$ski
Formal, i.e. VAR, parameters are always passed by
address.
Actual or value parameters are passed by address
if greater than two words in size, otherwise the
value itself is passed to the called routine.
$ski
3.6.2.\\&Parameter storage allocation&
$ski
On entry to a procedure or function the parameter
words are stored at assigned locations within
the local stack frame.
If there are more than five words of
parameters, the rest are loaded into AC1 and/or
AC0, indexing  on REG5, prior to transfer
to local storage.
Locations within the stack frame are assigned
to parameters in the order declared; thus:
$ski
$ver
	TYPE SETOFCHAR\=\SET OF CHAR;
	PROCEDURE P (I:\CHAR;\J:\CHAR;\CHARSET:\SETOFCHAR);
$ski
$jus
has the following entry code
$ski
$ver
P:	JSP	AC1,PNTRY.	;stack setup
	XWD	0, trace block address or NIL
	ADJSP	TOPP,10	;stack size
	MOVEM	REG,4(BASIS)	;I
	MOVEM	REG1,5(BASIS)	;J
	DMOVEM	REG2,6(BASIS)	;CHARSET
$ski
$jus
Had I and J been declared "I,J:\CHAR" their
assigned storage locations would have been reversed:
$ski
$ver
	MOVEM	REG,5(BASIS)	;I
	MOVEM	REG1,4(BASIS)	;J
	DMOVEM	REG2,6(BASIS)	;CHARSET
$ski
$jus
3.6.3.\\&Formal procedure/function parameters&
$ski
Procedures and functions are passed as a single
parameter word, the right half of which is the routine's
address and the left half zero if level 1,
otherwise its parent's stack frame pointer.
A call to a formal procedure or function is made by passing the
parameter word to a runtime routine PCALL.:

$ski
$ver
	TYPE FORMAL\=\PROCEDURE;
	PROCEDURE P (Q: FORMAL);
	BEGIN
	Q;
	END;

P:	JSP	AC1,PNTRY.
	XWD	0,trace block address
	ADJSP	TOPP,n
	MOVEM	REG,4(BASIS)	;store parameter word
	MOVE	AC1,4(BASIS	;preparation for
	PUSHJ	TOPP,PCALL.	;actual call
	...

PCALL.:
	TLNE	AC1,777777	;if not a level 1 procedure then
	HLR	BASIS,AC1	;set parent's stack frame pointer
	JRST	0(AC1)	;actual call
$jus
$ski
3.6.4.\\&Function return values&
$ski
Functions always reserve two words at 4(BASIS)
and 5(BASIS) for their return value, though the second
word is used only if required.
If the return value is greater than two words in size,
the calling routine must pass in AC0 the address of
a block of storage for this value.
On return from the function its return value
is at 5(TOPP) and 6(TOPP).
$ski
3.7.\\&General code layout&
$ski
The code emitted for a PASCAL procedure has
the general order:
$ind left 8
$ski
$par-4
1.\\initialized constants
$ski
$par-4
2.\\byte pointers
$ski
$par-4
3.\\internal procedures
$ski
$par-4
4.\\trace block if in TRACE or DEBUG mode
$ski
$par-4
5.\\if level > 1, HRR BASIS,1(BASIS) table
$ski
$par-4
6.\\stack initialization + parameter save
$ski
$par-4
7.\\procedure body
$ski
$par-4
8.\\return
$ski
$par-4
9.\\literal constants
$ski
$par-8
For a MAIN compilation:
$ski
$par-4
1.\\initialized constants
$ski
$par-4
2.\\byte pointers
$ski
$par-4
3.\\procedures
$ski
$par-4
4.\\trace block if in TRACE or DEBUG
$ski
$par-4
5.\\body of main procedure
$ski
$par-4
6.\\STOP
$ski
$par-4
7.\\main entry point, environment initialization, and
GOTO(5)
$ski
$par-4
8.\\literal constants for main program
$ski
$ind left 0
The first high-segment word emitted in any
compilation provides information for the debugger
(see section\6.1.).
$ski
3.8.\\&Boolean Expressions&
$ski
Boolean values TRUE and FALSE are represented by 1 and 0,
respectively, however, Boolean expressions are often
tested as if TRUE were any non-zero value.
Two methods of expression evaluation are employed:
one leaves a Boolean value in a register while
the other tests and skips on a particular condition.
The method of evaluation is dependent on the
construct in which the expression appears
(assignment, IF...THEN, etc.) and the complexity
of the expression itself.
$ski
For example, the code emitted for:
$ski
$ver
	FLAG := I>J;

is:	MOVEI	REG,1	;"true"
	MOVE	REG1,I
	CAMG	REG,J
	SETZ	REG,	;if I<=J
	MOVEM	REG,FLAG

while the statement:

	IF I>J then FLAG:=TRUE;

is compiled as:

	MOVE	REG,I
	CAMG	REG,J
	JRST	FALSE
	MOVEI	REG,1	;"true"
	MOVEM	REG,FLAG
\\\FALSE:
$ski
$jus
Note that the operands of AND and OR are always
evaluated, though not necessarily in the order they
appear.
If A and B are Boolean variables, then
A AND NOT B is actually evaluated as NOT B AND A.
$ski
3.8.1.\\&AND&
$ski
The operation is performed with the
PDP-10 "AND" or "ANDI" instruction.
$ski
3.8.2.\\&OR&
$ski
Evaluated with "IOR" or "IORI".
$ski
3.8.3.\\&NOT&
$ski
The operand is loaded into a register and
complemented with the instruction:
$ski
$ver
	ANDCAI	REG,1
$ski
$jus
which inverts the rightmost bit and zeroes the rest.
$ski
3.8.4.\\&ANDIF&
$ski
The first operand is loaded and, if false, the evaluation
of the second operand is suppressed.
Consider:
$ski
$ver
	VAR A: BOOLEAN;
	\\\\P: ^INTEGER;
	...
	A:= (P<>NIL) AND (P^<>3);
$ski
$jus
which compiles as:
$ski
$ver
	MOVEI 	REG,1
	MOVE	REG1,P
	CAIN	REG1,377777	;test for NIL
	SETZ	REG,
	MOVE	REG1,P
	MOVEI	REG2,1
	MOVE	REG1,0(REG1)	;gets P^
	CAIN	REG1,3
	SETZ	REG2,
	AND	REG,REG2
	MOVEM	REG,A
$ski
$jus
If P is NIL then the second expression is still evaluated
and the dereference of P^ will cause a memory trap.
With ANDIF, however:
$ski
$ver
	A:= (P<>NIL) ANDIF (P^<>3);

	MOVEI	REG,1
	MOVE	REG1,P
	CAIN	REG1,377777
	SETZ	REG,
	JUMPE	REG,LABEL	;skip second operand evaluation
			;if P=NIL.
	MOVE	REG,P	;note reuse of register
	MOVEI	REG1,1	
	MOVE 	REG,0(REG)	;P^
	CAIN	REG,3
	SETZ	REG1,
	MOVE	REG,REG1	;since first operand left its 
			;result in REG.
LABEL:
	MOVEM	REG,A
$jus
$ski
3.8.5.\\&ORIF&
$ski
Similar to ANDIF, however, the evaluation of the
second operand occurs only if the first is false.
Were ORIF used rather than ANDIF in the previous
example, the JUMPE REG,LABEL instruction would 
become JUMPN REG,LABEL.
$ski
3.8.6.\\&Relational&:\\<,\>,\<=,\>=,\=,\<>.
$ski
Comparison of integers, scalar, single precision real, Boolean,
pointer, and char operands is performed with instructions
from the CAI and CAM groups.
String comparison is addressed in section 3.11. and
comparison of sets in 3.10.
$ski
Double precision real numbers are compared for 
equality like sets (see 3.10.4.).
The other relationals require comparison of
both words of the real:
$ski
$ver
	$OPTIONS DOUBLE
	VAR X,Y:REAL; B:BOOLEAN;
	\\\\...
	\\\\B:=X>=Y;

	MOVEI	REG,1	;"true"
	DMOVE	REG1,X
	DMOVE	REG3,Y
	CAMGE	REG1,REG2	;compare first word
	JRST	FALSE	;if <
	CAME	REG1,REG3	;compare second word only
	JRST	TRUE	;if first words equal
	CAMGE	REG2,REG4
FALSE:
	SETZ	REG,
TRUE:
	MOVEM	REG,B
$ski
$jus
$ski
Arrays and records may be tested only for equality or 
inequality, with the single exception of packed arrays of char,
which are handled as strings.
Arrays or records whose maximum size is one word are
compared directly with CAI or CAM, while those with a
maximum size of two words are compared like sets
(see section 3.10.).
Larger records and arrays are compared word by word until
exhausted or an inequality occurs.
For example:
$ski
$ver
	VAR A: BOOLEAN;
	\\\\R,S:  RECORD
	\\\\\\F1, F2, F3, F4:  REAL
	\\\\END; (*size of record is 4 words*)
	\\\\...
	\\\\A:= R = S;

	MOVEI	REG,1	;Boolean result left here
	MOVEI	REG1,R
	MOVEI	REG2,S
	MOVEI	AC0,4	;record size
LOOP:
	MOVE	REG3,0(REG1)	;gets a word of R
	CAME	REG3,0(REG2)	;compare with word of S
	AOJA	REG2,DONE	;if unequal advance 'S'
			;address and stop test
	AOJ	REG1,	;next word of R
	AOJ	REG2,	;next word of S
	SOJG	AC0,LOOP	;iterate comparison

	At DONE, if R=S then

		(REG1) = address (R)+4
		(REG2) = address (S)+4
		(REG3) = last word of R (at R+3)
$ski
$jus
If R<>S, i.e., if the n&th& word of the
records is unequal, then
$ski
$ver
		(REG1) = address (R)+n-1
		(REG2) = address (S)+n
		(REG3) = word at R+n-1
$jus
$ski
Thus the equality of the records can be determined
by comparing the word in REG3 with the word at
S+n-1 or -1(REG2):
$ski
$ver
DONE:
	CAME	REG3,-1(REG2)
	SETZ	REG,
	MOVEM	REG,A
$ski
$jus
For inequality the CAME instruction at
DONE becomes CAMN.
$ski
As noted elsewhere, comparison of
arrays or records may fail where an element
by element or field by field comparison
would succeed, given
the presence of unused bits or modification
of tagfields and variant fields.
$ski
3.9.\\&Arithmetic expressions:\\+,\-,\/,\DIV,\MOD,\*,\**&
$ski
All arithmetic expressions are generally evaluated in single precision
and all operators except DIV and MOD accept either integer or real operands.
If one operand is real and the other integer, the integer
is converted to real format.
Conversion of integer constants is performed at compile
time, while runtime conversions are performed by a runtime
routine INTRL.
in single precision or INDRL. in double precision.
$ski
In the following examples it is assumed that:
$ski
$ver
	VAR I,J,K:\\INTEGER;
\\	\\\\X,Y,Z:\\REAL;
$jus
$ski
3.9.1.\\&Addition, subtraction&:
$ski
Performed via ADD, SUB, FADR, FSBR, DFAD, or DFSB. ADDI/SUBI
may be used to add/subtract integer constants:
$ski
$ver
	I := J+K-3;

	MOVE	REG,J
	ADD	REG,K
	SUBI	REG,3
	MOVEM	REG,I
$ski
$jus
3.9.2.\\&Multiplication&
$ski
Performed with IMUL, IMULI, FMPR, or DFMP:
$ski
$ver
	X := Y*I

	MOVE	REG,Y
	MOVE	REG1,I
	MOVEI	AC1,REG1	;tells runtime where I is
	PUSHJ	TOPP,INTRL.	;I replaced by floated value
	FMPR	REG,REG1
	MOVEM	REG,X
$ski
$jus
3.9.3.\\&Division&
$ski
There are three division operators:
$ski
3.9.3.1.\\&/&
$ski
Both operands are converted to floating
point if necessary and the division performed
with an FDVR or DFDV.
$ski
3.9.3.2.\\&DIV&
$ski
Both operands must be integers.
The quotient of the IDIV or IDIVI is the result
of the operation:
$ski
$ver
	I := J DIV K;

	MOVE	REG,J
	IDIV	REG,K	;remainder goes in REG1
	MOVEM	REG,I	;result is quotient
$ski
$jus
3.9.3.3.\\&MOD&
$ski
Both operands must be integers.
The result of the operation is the remainder resulting
from the IDIV or IDIVI:
$ski
$ver
	I := J MOD K+5
	
	MOVE	REG,J
	IDIV	REG,K	;remainder in REG1
	MOVE	REG,REG1	;result of MOD is remainder
	ADDI	REG,5
	MOVEM	REG,I
$ski
$jus
3.9.4.\\&Exponentiation&
$ski
An integer raised to a real exponent is converted
to floating point, otherwise no conversion is performed.
There are, therefore, three possible type combinations:
$ski
3.9.4.1.\\&I**J (integer**integer)&
$ski
If J is a constant the exponentiation
is performed inline:
$ski
$ver
	J<0:  a zero result is loaded
	J=0:  result of operation is 1
	J=1:\\result is I
	J=2:  I is loaded and multiplied by itself
	J>2:  I is loaded and copied into another
	\\\\\\register.  If J=3 or 4 then I is
	\\\\\\multiplied by the copied value J-1 times:

	K := I**3
	
	MOVE	REG,I
	MOVE	REG1,REG	;copy value
	IMUL	REG,REG1	;I squared
	IMUL	REG,REG1	;I cubed
	MOVEM	REG,K

If J>4 then a loop is set up and I multiplied by its copy J-1 times:

	K := I**7

	MOVE	REG,I
	MOVE	REG1,REG	;copy value
	MOVEI	AC1,6	;exponent-1
	IMUL	REG,REG1
	SOJG	AC1,.-1
	MOVEM	REG,K
$ski
$jus
If J is not a constant both I and J are loaded
into registers and passed to a runtime routine
EXPII., which performs the exponentiation:
$ski
$ver
	K := I**J;

	MOVE	REG,I
	MOVE	REG1,J
	MOVEI	AC0,REG1	;informs runtime of
	MOVEI	AC1,REG	;whereabouts of I and J
	PUSHJ	TOPP,EXPII.
	MOVEM	REG,I	;result returned in "I" register
$ski
$jus
3.9.4.2.\\&X**I (real**integer)&
$ski
X and I are loaded and passed to the runtime EXPRI.
for exponentiation.
The calling sequence is the same as for EXPII.
If I is negative the expression is evaluated as
(1/X)**(-I).  DXPRI is called in double precision.
$ski
3.9.4.3.\\&X**Y(real**real)&
$ski
X and Y are passed to EXPRR. (DXPRR. in double precision)  for evaluation.
While EXPII. and EXPRI. exponentiate by
interative multiplication, EXPRR. evaluates the
result as:
$ski
$ver
	X**Y = EXP(Y*LN(X))
$ski
$jus
or in double precision.
$ver
	X**Y=DEXP(Y*DLOG(X))
$jus
$ski
The LN, EXP, DEXP, and DLOG functions are pulled from the FORTRAN
library.
$ski
3.10.\\&Set manipulation&
$ski
The operations performed on sets are union, intersection,
difference and tests for
equality, membership and inclusion.
In the following examples it is assumed that:
$ski
$ver
	VAR I,J:  0..71;
	\\\\SET1, SET2, SET3: SET of 0..71;
	\\\\A: BOOLEAN;
$ski
$jus
3.10.1.\\&Union (+)&
$ski
An OR of the respective words of each set:
$ski
$ver
	SET1 := SET2+SET3;

	DMOVE	REG,SET2
	IOR	REG1,SET3+1
	IOR	REG,SET3
	DMOVEM	REG,SET1
$ski
$jus
3.10.2.\\&Intersection (*)&
$ski
An AND of each word of the sets.
Same as previous example with IOR replaced by AND.
$ski
3.10.3.\\&Difference (-)&
$ski
The first set is ANDed with the complement
of the second, effectively removing from the first
set any element in the second:
$ski
$ver
	SET1 := SET2-SET3;

	DMOVE	REG,SET2
	ANDCM	REG1,SET3+1	;clears any bits which
	ANDCM	REG,SET3	;were set in SET3
	DMOVEM	REG,SET1
$ski
$jus
3.10.4.\\&Equality (=,<>)&
$ski
The first and second words of the sets are tested in pairs:
$ski
$ver
	A := SET1 = SET2;

	MOVEI	REG,1
	DMOVE	REG1,SET1
	DMOVE	REG3,SET2
	CAME	REG1,REG3	;compare first word
	JRST	UNEQUAL
	CAME	REG2,REG4	;compare second
UNEQUAL:
	SETZ	REG,
	MOVEM	REG,A

Inequality generates slightly different code:

	A := SET1<>SET2

	MOVEI	REG,1
	DMOVE	REG1,SET1
	DMOVE	REG3,SET2
	CAME	REG1,REG3
	JRST	TRUE	;sets unequal
	CAMN	REG2,REG4
	SETZ	REG,
TRUE:
	MOVEM	REG,A
$ski
$jus
3.10.5.\\&Inclusion (<=,>=)&
$ski
SET1 is a subset of SET2 if the intersection of SET1 with
the complement of SET2 is the empty set:
$ski
$ver
	A := SET1<=SET2

	MOVEI	REG,1
	DMOVE	REG1,SET1
	ANDCM	REG2,SET2+1	;intersect SET1 with the
	ANDCM	REG1,SET2	;complement of SET2
	SKIPN	REG2	;both words of resultant
	SKIPE 	REG1	;set must be zero
	SETZ	REG,	;for the empty set
	MOVEM	REG,A

If the test is reversed:

	A := SET1>=SET2

$jus
then the ANDCM becomes ANDCA (complement
SET1 and intersect with SET2).
$ski
3.10.6.\\&Set formation&
$ski
A set may be created dynamically:
$ski
$ver
	SET1 := [I];

	MOVE	REG2,I
	MOVN	REG2,REG2	;will shift set right
	HRLZI	REG,400000	;forms basic set
	SETZ	REG1,	;in REG and REG1
	LSHC	REG,0(REG2)	;shifts bit for I into
			;correct position
	DMOVEM	REG,SET1
$ski
$jus
Constant elements of such a set are factored
out at compile time and a union is performed
on the constant and dynamically created sets:
$ski
$ver
	SET1 := [1, I, 3..10];

	MOVE	REG2,I
	MOVN	REG2,REG2
	HRLZI	REG,400000
	SETZ	REG1,
	LSHC	REG,0(REG2)
	IOR	REG1,CONST+1
	IOR	REG,CONST
	DMOVEM	REG,SET1
	...
CONST:
	XWD	277600,0	;[1,3..10]
	Z
$ski
$jus
3.11.\\&Strings&
$ski
Strings are generally manipulated character by character,
facilitating compatibility with CHAR variables and packed
arrays of char.
$ski
3.11.1.\\&Descriptors&
$ski
There are three types of string descriptors:
$ind left 8
$ski
$par-4
A.\\FIXED (F-format)
$ski
(REG) is the address of the first word of the string
$par
(REG+1) is its length
$ski
$par-4
B.\\VARYING (V-format)
$ski
(REG) is the address of the length word
$ski
$par-4
C.\\Substring (S-format)
$ski
(REG) is a byte pointer to the first character
$par
(REG+1) is the length of the substring.
$ind left 0
$ski
All parameters to runtime string manupulation routines
are represented in one of the above formats.
$ski
3.11.2.\\&LENGTH&
$ski
The length word of the string is simply loaded.
$ski
3.11.3 &Substring&
$ski
Both forms of substring:
$ski
$ver
	SUBSTR (string, first ,length ) and
	string [first:length]

result in an S-format descriptor.

	VAR S: STRING;
	\\\\I,J: INTEGER;
	...
	SUBSTR (S,I,J)

	MOVE	REG,I	
	IDIVI   REG,5	;word and byte offsets
	ADDI	REG,S+1	;word within S
	ADD	REG,CBPSS.(REG1)	;byte pointer
	MOVE	REG1,J	;substring length
$ski
$jus
3.11.4.\\&UPPERCASE and LOWERCASE&
$ski
The string is moved character by character into
a temporary location in the stack, converting to upper/lowercase
if necessary.
$ski
$ver
	S := UPPERCASE (S)

	MOVEI	REG,S+1
	HRLI	REG,440700	;generate byte pointer
	MOVE	REG1, -1(REG)	;load current length
	MOVEM	REG1,temp(BASIS)	;store length of temp
	JUMPE	REG1,DONE	;null string?
	MOVEI	REG2,temp+1(BASIS)	;generate pointer
	HRLI	REG2,440700	;to temporary
LOOP:
	ILDB	REG3,REG	;get a character
	CAIL	REG3,141	;"a"
	CAILE	REG3,172	;"z"
	CAIA
	SUBI	REG3,40	;converts to uppercase
	IDPB	REG3,REG2	;store in temp string
	SOJG	REG1,LOOP	
DONE:
	HRLI	REG,temp(BASIS)	;since temp string is
	HRRI	REG,S	;same size as S,
	BLT	REG,S+size(S)	;assign with BLT
$ski
$jus
For LOWERCASE the test and conversion following
LOOP is:
$ski
$ver
	CAIL	REG3,101	;'A'
	CAILE	REG3,132	;'Z'
	CAIA
	ADDI	REG3,40	;converts to lowercase
$ski
$jus
3.11.5.\\&Runtime supports&
$ski
Most string functions are performed by MACRO 
routines with entry points for various operand types.
The calling sequences and parameters are detailed in section 4.
The operations performed by these routines and
their associated entry points are:
$ski
$ind left 4
$ver
Assignment:  CMFF., CMSF., CMSSR.
Comparison:  CMPSS.
Concatenation:  CTSS.
INDEX:  IXSS., IX3SS.
SEARCH:  SRSS., SR3SS.
VERIFY:  VFSS., VF3SS.
$jus
$ski
$ind left 0
3.12.\\&Control constructs&
$ski
3.12.1.\\&FOR statement&
$ski
The initial assignment to and increment or
decrement of the iteration variable occurs
prior to comparison with the limit of iteration.
$ski
$ver
	FOR I := 1 to 100B DO <statement>;

	MOVEI	REG,1
	MOVEM	REG,I	;initialization

FORLOOP:
	CAILE	REG,100
	JRST	OUT
	<statement>
	AOS	REG,I	;increment
	JRST	FORLOOP
\\\OUT:
$ski
$jus
If the limit of iteration is a directly addressible
variable (e.g., static, local, etc.) it is
referenced at FORLOOP with a CAM instruction.
Code for DOWNTO is similar, with CAILE and AOS
replaced by CAIGE and SOS, respectively.
$ski
3.12.2.\\&WHILE statement&
$ski
The Boolean expression is tested prior to execution
of the following statement.
$ski
$ver
	WHILE I = 3 DO <statement>;

LOOP:
	MOVE	REG,I
	CAIE	REG,3
	JRST	OUT
	<statement>
	JRST	LOOP
OUT:
$ski
$jus
3.12.3.\\&REPEAT statement&
$ski
The expression following UNTIL is evaluated after
execution of the intervening statements.
$ski
$ver
	REPEAT <statement 1> ;...<statement n>  UNTIL I>0;

	LOOP: <statement 1>
	...
	<statement n>
	MOVE	REG,I
	CAIG	REG,0
	JRST	LOOP
$ski
$jus
3.12.4.\\&LOOP statement&
$ski
The statements prior to END are unconditionally executed
until a GOTO or EXIT IF exits the loop.
$ski
3.12.5.\\&EXIT IF&
$ski
The EXIT IF clause may be used to conditionally terminate
a FOR, WHILE, REPEAT, or LOOP statement.
$ski
If followed by DO <statement> the statement is
executed prior to termination.
$ski
$ver
	LOOP
	\\\I := I+3;
	EXIT IF I>J DO I := J;
	\\\J := J-2;
	END;

LOOP:
	MOVE	REG,1
	ADDI	REG,3
	MOVEM	REG,I
	MOVE	REG,I
	CAMG	REG,J	;EXIT IF test
	JRST	LOOP1
	MOVE	REG,J	;only if DO
	MOVEM	REG,I	;<statement> used
	JRST	OUT
LOOP1:
	MOVE	REG,J
	SUBI	REG,2
	MOVEM	REG,J
	JRST	LOOP
OUT:
$ski
$jus
3.12.6.\\&WITH statement&
$ski
Pointers are generally loaded into AC1 prior to
transfer to a WITH register.
$ski
$ver
	VAR P: ^type;
	...
	WITH P^ DO <statement>;

	MOVE	AC1,P
	CAIE	AC1,0	;only if
	CAIN	AC1,377777	;CHECK option
	JSP	AC0,PTRER.	;in effect
	MOVEI	AC14,0(AC1)	;loads WITH register
	<statement>
$ski
$jus
Allocated WITH base registers are always saved
before and restored after calls
to routines other than the runtime supports.
$ski
3.12.7.\\&CASE statement&
$ski
The subsequent expression is evaluated and, if
within the range of the minimum and maximum case
labels, used as an index into a jump table.
Values for which no case label is given terminate
the CASE statement or enter the OTHERS case,
as appropriate.
$ski
$ver
	CASE I OF
	1: <statement 1>;
	2,3: <statement 2,3>;	
	6: <statement 6>;
	OTHERS: <others>
	END;

	MOVE	REG,I
	CAIL	REG,1	;minimum case
	CAILE	REG,6	;maximum case
	JRST	OTHERS	;or JRST OUT if no OTHERS
	JRST 	@TABLE-1(REG)	;jump through table
CASE 1:
	<statement 1>
	JRST	OUT
CASE 23:
	<statement 2,3>
	JRST 	OUT
CASE 6:
	<statement 6>
	JRST	OUT
OTHERS:
	<others>
	JRST	OUT
TABLE:
	EXP	CASE1	;I=1
	EXP	CASE23	;I=2
	EXP	CASE23	;I=3
	EXP	OTHERS	;I=4, no case
	EXP	OTHERS	;I=5, no case
	EXP	CASE6	;I=6
OUT:
$ski
$jus
3.12.8.\\&IF statement&
$ski
The value of the Boolean expression determines whether
the statement following THEN is executed.
$ski
$ver
	IF FLAG THEN <true statement>
	\\\\\\\\ELSE <false statement>

	MOVE	REG,FLAG
	JUMPE	REG,FALSE
	<true statement>
	JRST	OUT	;only if ELSE specified
FALSE:
	<false statement>	;only if ELSE
OUT:
$ski
$jus
3.12.9.\\&GOTO statement&
$ski
A GOTO is merely a JRST to the specified location,
however, a GOTO out of a procedure into an
enclosing procedure requires restoration of the
stack pointers of the target procedure.
This is known as UNWINDing the stack and is
accomplished by a runtime UNWND. prior to the JRST.
$ski
$ver
	PROGRAM MAIN;
	LABEL 1;
	\\PROCEDURE OUTER;
	\\LABEL 2;
	\\\\PROCEDURE MIDDLE;
	\\\\\\PROCEDURE INNER;
	\\\\\\BEGIN
	\\\\\\\\GOTO 2
	\\\\\\END;
	\\\\BEGIN END;
	\\BEGIN
	\\\2: GOTO 1
	\\END
	BEGIN
	\\1:
	END.
$ski
$jus
The GOTO from INNER to OUTER exits two levels of scope:
$ski
$ver
	HRRZ	AC1,1(BASIS)	;follow parent chain
	HRRZ	AC1,1(AC1)	;back two levels
	PUSHJ	TOPP,UNWND.	;unwinds the stack
	JRST	LABEL2	;actual GOTO
$ski
$jus
A GOTO from a public or level 1 routine into
the mainline is a special case since a level 1
procedure has no parent.
The stack is simply unwound until the main
stack frame is found:
$ski
$ver
	DMOVE	BASIS,1(BASIS)	;back up one frame
	TLNE	BASIS,777777	;at main yet?
	JRST	.-2	;no, keep going
	POP	TOPP,	;yes, reset TOPP
	JRST	LABEL1	;and GOTO 1
$ski
$jus
3.13.\\&Calling non-PASCAL routines&
$ski
3.13.1.\\&MACRO&
$ski
Parameters and calling sequences for MACRO routines
are identical to those for PASCAL procedures and
functions.
It is the responsibility of the
called routine to allocate and maintain the stack.
$ski
3.13.2.\\&COBOL and ALGOL&
$ski
Though allowed by the compiler, calls to COBOL
and ALGOL programs probably will not work since
the calling sequence generated is the same as that for
FORTRAN.
$ski
3.13.3.\\&FORTRAN&
$ski
Since FORTRAN  assumes a parameter list
address in BASIS, FORTRAN calls involve considerable
register shuffling.
The format of the parameter list is:
$ski
$ver
	\0,parm n address	(highest address)
	...
	\0,parm 2 address	
	\0,parm 1 address	<--BASIS
	-n,0		(lowest address).
$ski
$jus
VAR parameters are actually passed by address.
Value parameters are copied into temporary locations,
the addresses of which are passed in the parameter list.
The general sequence of events is:
$ind left 8
$ski
$par-4
1.\\Allocate temporary locations for the value parameters
and the parameter list by adding an offset to TOPP.
$ski
$par-4
2.\\For each parameter, if formal then load its address,
else transfer its value into a temp and load
the address of that location.
Store the address in the parameter list.
Generally AC7 and AC10 are used for this purpose.
$ski
$par-4
3.\\Create and store the parameter count word (XWD\-n,0).
$ski
$par-4
4.\\Save BASIS in a temporary and load into BASIS
the address of the parameter list.
$ski
$par-4
5.\\Call the routine with PUSHJ TOPP,.
$ski
$par-4
6.\\On return, subtract the offset from TOPP
to free the allocated temps.
$ski
$par-4
7.\\If a function, fake a PASCAL function return
by storing AC0 at 5(TOPP).
$ski
$par-4
8.\\Restore the saved BASIS.
$ski
$ind left 0
As an example:
$ski
$ver
	TYPE STRING40=STRING[40B]
	\\\\\SETOFCHAR=SET OF CHAR;
	VAR I:INTEGER;
	\\\\X:REAL;
	\\\\S:STRING40;
	\\\\CHARSET:SETOFCHAR;

	EXTERNAL FUNCTION F (INTEGER; SETOFCHAR;
	\\\\
	\\\\VAR REAL; STRING40):INTEGER;
	...

	I := F(5, CHARSET, X, S);

	MOVEI	AC7,5
	ADDI	TOPP,22	;allocates temps
	MOVEM	AC7,-13(TOPP)
	HRRI	AC7,-13(TOPP)	;address of temp
	HRRZM	AC7,-17(TOPP)	;to parameter list
	DMOVE	AC7,CHARSET
	DMOVEM	AC7,-12(TOPP)
	HRRI	AC7,-12(TOPP)	;address of temp
	HRRZM	AC7,-16(TOPP)
	MOVEI	AC7,X	;pass actual address
	HRRZM	AC7,-15(TOPP)
	HRLI	AC7,S	;move S with a BLT
	HRRI	AC7,-10(TOPP)
	BLT	AC7,-1(TOPP)
	MOVEI	AC7,-10(TOPP)
	HRRZM	AC7,-14(TOPP)
	HRLZI	AC0,-4	;parameter count word
	MOVEM AC0,-20(TOPP)
	MOVEM	BASIS,-22(TOPP)	;save BASIS
	MOVEI	BASIS,-17(TOPP)	;address parameter list
	PUSHJ	TOPP,F	;finally
	SUBI	TOPP,22	;free temps
	MOVEM	AC0,5(TOPP)	;fake return value
	MOVE	BASIS,0(TOPP)	;restore stack pointer
	MOVE	REG,5(TOPP)	;get value returned
	MOVEM	REG,I
$ski
$jus
This is the FORTRAN-10 calling sequence, which
is incompatible with the standard Cyphernetics
FORTRAN-40.
$ski
3.14.\\&Standard procedures and functions&
$ski
$tabs 8,24
$ver
	ABS	loads an absolute value with MOVM

	ADDRESS	generates an address computation
$ski
	ARCCOS	calls FORTRAN ACOS. (see 4.10.)

	ARCSIN	calls FORTRAN ATAN. (see 4.10.)

	BREAK	see BREAK. in 4.4.

	CHANNEL 	loads the channel number from a file block

	CHR	compile-time type conversion only

	CLOSE	see CLOSE. in 4.4.

	COS	calls FORTRAN COS. or DCOS.

	COSD	calls FORTRAN COSD. (see 4.10.)

	COSH	calls FORTRAN COSH. (see 4.10.)

	CV&\&REAL	see STR2R. in 4.6.

	DATE	calls FORTRAN DATE.

	DISPOSE	see DSPOS. in 4.3.

	EOF	loads end-of-file flag from a file block

	EOLN	loads end-of-line flag from a file block

	EXP	calls FORTRAN EXP. or DEXP.
$ski
	FLOAT	see INDRL. and INTRL. in 4.6.

	FREECHANNEL	see FRECN. in 4.4.

	GET	see GET. in 4.4.

	GETCHANNEL	see GETCN. in 4.4.

	GETLINENR	loads the line number from a file block

	GETLN	see GETLN. in 4.4.

	INDEX	see 4.5.

	INPUT	standard file block

	LENGTH	loads string lengthword

	LN	calls FORTRAN ALOG. or DLOG.

	LOG	calls FORTRAN ALOG10 or DLOG10

	LOWERBOUND	compile-time constant

	LOWERCASE	see 3.11.4.

	MARK	see MARK. in 4.3.

	MAXIMUM	compile-time constant

	MINIMUM	compile-time constant

	NEW	see NEW. in 4.3.

	ODD	isolates right-most bit with ANDI REG,1

	OPEN	see OPEN. in 4.4.

	ORD	type conversion at compile-time only

	OUTPUT	standard file block

	PACK	no longer supported

	PAGE	see PUTPG. in 4.4.

	PRED	subtracts one and performs routine check
		if in effect.

	PROTECTION	obsolete

	PTR	type conversion at compile-time only

	PUT	see PUT. in 4.4.

	PUT8BITSTOTTY	executes IONEOU TTCALL.

	PUTLN	see PUTLN. in 4.4.

	RANDOM	see RANDM. in 4.8. and DRND. in 4.10.

	READ	according to the type of the parameters,
		calls READC., READI., READD., and/or READR.
		see section 4.4.

	READLN	performs functions of READ, if necessary,
		followed by call to GETLN. (see 4.4.)

	RELEASE	see RLEAS. in 4.3.

	RESET	see RESET. in 4.4.

	RETURN	from main program, same as STOP,
		otherwise generates a JRST to PNTRY.,
		KI10X., or KA10X.

	REWRITE	see REWRT. in 4.4.

	ROUND.	see ROUND. in 4.6.

	RUNTIME	executes a PJOB-UUO (CALLI 30) and a
		RUNTIM-UUO (CALLI 27)

	SEARCH	see 4.5.

	SIN	calls FORTRAN SIN. or DSIN.

	SIND	calls FORTRAN SIND. (see 4.10.)

	SINH	calls FORTRAN SINH. (see 4.10.)

	SIZE	compile-time constant

	SQR	squares expression with IMUL, FMPR, or DFMP

	SQRT	calls FORTRAN SQRT. or DSQRT.

	STOP	generates a JRST EXIT.

	SUBSTR	see 3.11.2.

	SUCC	adds one and performs runtime check,
		if in effect.

	TANH	calls FORTRAN TANH. (see 4.10.)

	TIME	executes an MSTIME-UUO (CALLI 23)

	TRACE	calls TRACE

	TRUNC	see TRUNC. and TRUND. in 4.6.

	TTY	standard file block

	TTYOUTPUT	standard file block

	UNPACK	no longer supported

	UPPERBOUND	currently a compile-time constant.

	UPPERCASE	see 3.11.4.

	VERIFY	see 4.5.

	WRITE	depending on the parameters, calls
		WRBOL., WRHEX., WRINT., WRITC.,
		WROCT., WRPST., WRSST., WRTRL.,
		WRUST., and/or WRUST.  The file block
		address is loaded in REG and kept
		there over subsequent runtime calls.
		See 4.4.

	WRITELN	performs the functions of WRITE, if
		necessary, followed by a call to
		PUTLN.  (see 4.4.).

$jus
$page
4.\\&PASCAL Runtime Support Routines&
$ski
This section describes all runtime entry points
and their respective parameters.
$ski
4.1.\\&Initialization and termination&
$ski
$tab 5
$ver
	DIE.
$jus
$ski
After a runtime error, reached by JRST DIE.
Simply an EXIT\1,.
$ski
$ver
	END.,EXIT.
$jus
$ski
Normal program termination point (EXIT\0,).
$ski
$ver
	INITP.
$ski
$jus
Called from the main program with
JSP\AC7,INITP.
On entry (BASIS) is the desired stack size.
Obtains required storage, initializes BASIS, TOPP,
and main's link word, returning with
JRST\1(AC7).
$ski
$ver
	TRACE
$ski
$jus
Called like a PASCAL procedure from the runtime
after a REENTER/CONTINUE sequence or
explicitly from PASCAL programs.
Prints a stack traceback to the terminal.
$ski
$ver
	WRTPC.
$ski
$jus
Writes "at user PC xxxxxx" to the terminal.
The right half of AC0 contains the address
to be printed.
Called with PUSHJ\TOPP, after most error messages.
Returns with POPJ\TOPP,.
$ski
4.2.\\&Stack manipulation, procedure calls/returns&
$ski
$ver
	KA10N.,KA10X.
$ski
$jus
Entry/exit code for the KA10. Similar to
 PNTRY./PRTRN.
$ski
$ver
	KI10N.,KI10X.
$ski
$jus
Entry/exit code for the KI10.  Merely synonyms
for PNTRY./PRTRN.
$ski
$ver
	PCALL.
$ski
$jus
Intercepts calls to formal procedures and functions.
(AC1) contains the address of the routine and its
parent's stack frame pointer, if appropriate.
Called with PUSHJ\TOPP, and completes call
with JRST\0(AC1).
$ski
$ver
	PNTRY.
$ski
$jus
Stack initialization for the KL10/KI10.
Called via JSP\AC1,PNTRY. and returns with
JRST\1(AC1).
$ski
$ver
	PRTRN.
$ski
$jus
Stack restoration for the KL10/KI10.
Entered with a JRST and completes return with
POPJ\TOPP,.
$ski
$ver
	UNWND.
$ski
$jus
Unwinds the stack for a non-local GOGO.
(AC1)=pointer to target stack frame.
Called/returns with PUSHJ/POPJ\TOPP,.
$ski
4.3.\\&Heap management&
$ski
All are PUSHJ/POPJ calls.
$ski
$ver
	DSPOS.
$ski
$jus
(REG) points to the block to be DISPOSEd.
Returns NIL in AC1.
$ski
$ver
	MARK.
$ski
$jus
Returns in REG1 the current heap pointer and 
initializes a new heap.
$ski
$ver
	NEW.
$ski
$jus
On entry (REG)=number of words requested.
Returns a pointer to the allocated area in REG.
$ski
$ver
	RLEAS.
$ski
$jus
(REG)=pointer to heap to be restored.
$ski
4.4.\\&I/O&
$ski
Most I/O routines maintain the address of the
file block in REG and the address of its buffer in AC11.
$ski
$ver
	BFPAD.
$ski
$jus
Contains the address of the last file buffer
allocated at the top of the stack.
$ski
$ver
	BREAK.

Forces output of the buffer.

	CLOSE.

Closes the file.

	FRECN.

(AC0)=channel number to be released.

	GETCH.

Gets a character from a TEXT file buffer.

	GETCN.

Allocates a channel, returning its number in AC0.

	GETLN.

Gets a line from a TEXT file.

	GET.

Gets a component from a non-TEXT file.

	INPUT

File block for the standard file INPUT.

	OPEN.

Opens a file for input.  On entry:

	(REG)\=file block address.
	(REG1)=byte pointer to string file name.
	(REG2)=length of the string.

	OUTPUT

File block for the standard file OUTPUT.

	PRFID.
$ski
$jus
Parses a file name and places the formatted
information in a PASCAL file block.
Parameters are the same as for OPEN.
If the parse is successful PRFID.\skips on
return, otherwise it returns with no skip.
$ski
$ver
	PUTCH.
$ski
$jus
Stores the character in AC0 in the TEXT file buffer.
$ski
$ver
	PUTLN.
$ski
$jus
Writes a carriage return and line feed to a
TEXT file buffer.
$ski
$ver
	PUTPG.
$ski
$jus
Writes a carriage return and form feed to a
TEXT file buffer.
$ski
$ver
	PUT.
$ski
$jus
Places a component in a non-TEXT file buffer.
$ski
$ver
	READC.
$ski
$jus
Reads a character and stores it in the location
addressed by (REG1).
$ski
$ver
	READD.
$jus
$ski
Reads a double-precision real number and
stores it at 0(REG1) and zeroes 1(REG1).
$ski
$ver
	READI.
$ski
$jus
Reads an integer and stores it in the location
addressed by (REG1).
$ski
$ver
	READR.
$ski
$jus
Reads a real number and stores it at 0(REG1).
$ski
$ver
	RESET.
$ski
$jus
Opens a file and gets the first line or component.
Parameters are the same as for OPEN.
$ski
$ver
	REWRT.
$ski
$jus
Opens a file for output.
Parameters are the same as for OPEN., except
if REG3 is non-zero the file is rewritten
in "append" mode.
$ski
$ver
	TTY
$ski
$jus
File block for the standard file TTY.
$ski
$ver
	TTYOP.
$ski
$jus
Forces a blank line and an "*" to TTYOUTPUT.
$ski
$ver
	TTYOUT
$ski
$jus
File block for the standard file TTYOUTPUT.
$ski
$ver
	TWAIT.
$ski
$jus
Called prior to the OUTSTR of error messages.
Determines if TTYOUT is open for output and, if so, 
executes a BREAK(TTYOUTPUT).
$ski
$ver
	WRBLK.
$ski
$jus
Writes blanks.
(REG2)=number of blanks to be written.
$ski
$ver
	WRBOL.
$ski
$jus
Writes a Boolean value as an ASCII string.
(REG1)=Boolean value, (REG2)=format field width.
$ski
$ver
	WRHEX.
$ski
$jus
Writes a number in hexadecimal.
(REG1)=value to be written, (REG2)=field width.
$ski
$ver
	WRINT.
$ski
$jus
Writes a decimal integer.
Parameters same as WRHEX.
$ski
$ver
	WRITC.
$ski
$jus
(REG1)=character to be written.  (REG2)=field width.
$ski
$ver
	WRMIN.
$ski
$jus
Writes a minus sign.
$ski
$ver
	WROCT.
$ski
$jus
Writes an octal number.
Parameters same as WRHEX.
$ski
$ver
	WRPST.
$ski
$jus
Writes a packed string (packed array of char).
(REG1) and (REG2) contain a V-formal descriptor.
(REG3)=field width.
$ski
$ver
	WRSGN.
$ski
$jus
Writes a minus sign if (REG4) is negative.
$ski
$ver
	WRSST.
$ski
$jus
Writes a substring.
(REG1) and (REG2) contain an S-format descriptor.
(REG3)=field width.
$ski
$ver
	WRTRL.
$ski
$jus
Writes a real number in a specified format.
(REG1)=real value, (REG2)=total field width,
(REG3)=number of digits to right of decimal point.
$ski
$ver
	WRUST.
$ski
$jus
Writes an unpacked string (array of char
which is not packed). 
(REG1) and (REG2) contain a V-format descriptor.
(REG3)=field width.
$ski
$ver
	WRVST.
$ski
$jus
Writes a varying string.
(REG1) and (REG2) contain an S-format descriptor.
(REG3)=field width.
$ski
4.5.\\&Strings&
$ski
Routines which move, compare, and concatenate
two strings STRING1 and STRING2 require two descriptors in four
contiguous registers, the first of which is
addressed by AC1, i.e.,STRING1's descriptor is at
0(AC1) and 1(AC1), STRING2's at 2(AC1) and 3(AC1).
$ski
$ver
	CBPSS.
$ski
$jus
Table of constants for generation of string
byte pointers.
$ski
$ver
	CMFF.
$ski
$jus
Moves STRING1 to STRING2, both in F-format.
$ski
$ver
	CMPSS.
$ski
$jus
Compare STRING1 and STRING2, both in S-format.
The distinguishing characters are left in AC0 and
AC1 and "TRUE" in 1(AC1).
$ski
$ver
	CMSF.
$ski
$jus
Moves STRING1 (S-format) to STRING2 (F-format).
$ski
$ver
	CMSSR.
$ski
$jus
Moves STRING2 to STRING1, both S-format.
$ski
$ver
	CTSS.
$ski
$jus
Concatenates STRING1 and STRING2, both in S-format.
4(AC1) contains the address for the
resultant string.
$ski
$ver
	IX3SS.
$ski
$jus
INDEX with three parameters.
(REG) and (REG1) contain the S-format
descriptor for the string to be scanned, (REG2)
and (REG3) an S-format descriptor for the
search string, and (REG4) the value to be
returned if the index is unsuccessful.
$ski
$ver
	IXSS.
$ski
$jus
Same as IX3SS., except that REG4 is zeroed on entry.
$ski
$ver
	SR3SS.
$ski
$jus
SEARCH with three parameters.
(REG) and (REG1) contain an S-format descriptor,
(REG2) and (REG3) the character set and (REG4)
the return value for an unsuccessful search.
$ski
$ver
	SRSS.
$jus
$ski
Same as SR3SS., except that REG4 is zeroed on entry.
$ski
$ver
	VF3SS.,VFSS.
$ski
$jus
VERIFY.
Parameters are the same as for SR3SS.\and SRSS.
$ski
4.6.\\&Conversion&
$ski
$ver
	CNVTOR,CVTOR.
$ski
$jus
Converts a string to real number.
(REG) contains the address of the  string,
(REG1) an address for the result.
$ski
$ver
	CVTOI.
$ski
$jus
Converts a string to an iteger.
Same parameters as CNVTOR.
$ski
$ver
	DRND.
$jus
$ski
Rounds a double precision floating
point number to an integer.
Value and result are addressed by AC1.
$ski
$ver
	INDRL.
$ski
$jus
Converts an integer value to double precision
floating point.
The value to be converted is addressed
by AC1 and the result is stored at 0(AC1) and 1(AC1).
$ski
$ver
	INTRL.
$ski
$jus
Converts an integer to single precision floating
point.
Value and result are addressed by AC1.
$ski
$ver
	ROUND.
$ski
$jus
Rounds a single precision floating point
number to an integer.
Value and result are indicated by AC1.
$ski
$ver
	STR2R.
$ski
$jus
Converts a string to a real number.
(REG) contains the address of the string.
Returns the result
as a function value (actually calls
CNVTOR).
$ski
$ver
	TRUNC.
$ski
$jus
Same as ROUND.\with truncation.
$ski
$ver
	TRUND.
$ski
$jus
Same as DRND.\with truncation.
$ski
4.7.\\&Exponentiation&
$ski
Each routine has two parameters:
AC0 indicates the register containing the
exponent and AC1 the register containing
the number to be exponentiated.
The result is returned in 0(AC1).
$ski
$ver
$tabs 5,15
	EXPII.	integer**integer

	EXPRI.	real**integer (single precision)

	EXPRR.	real**real (single precision)

	XPRET.	common return and error check code
		for above routines.
$ski
	DXPRI.	real**integer (double precision)

	DXPRR.	real**real (double precision)

	DXRET.	common return for DXPRI. and DXPRR.
$ski
$jus
Double precision exponentiation routines
store their result at 0(AC1) and 1(AC1).
$ski
4.8.\\&Miscellaneous&
$ski
$ver
	FLTRCC
$ski
$jus
Called as a PASCAL procedure to tell runtime
to filter control characters on input (normal
condition).
$ski
$ver
	LINK
$ski
$jus
Invoked as a FORTRAN routine to perform a
LINK UUO and run another program.
$ski
$ver
	PASSCC
$ski
$jus
The converse of FLTRCC, tells runtime to
pass along control characters on input.
$ski
$ver
	RANDM.
$ski
$jus
PASCAL version of FORLIB's SETRAN and RAN 
random number generators.
(REG) contains the seed which is
replaced by the result.
$ski
4.9.\\&Error interception&
$ski
All are entered with a JSP AC0, empty the
TTYOUTPUT buffer, print a message to the terminal,
call WRTPC. and finally JRST\DIE.
The entry points and their associated message are:
$ski
$ver
     CONER.:  ?Input data error in file
     CORER.:  ?Stack overrun.  Increase S parameter
               and re-run.
     FORER.:  ?Error in FORTRAN procedure
     INXER.:  ?Array index out of bounds
     PTRER.:  ?Uninitialized pointer
     SRERR.:  ?Scalar out of range

$jus
Other error messages and the routines which
print them are:
$ski
$ver
	\GET.:	?Attempt to read beyond EOF on file-name
     PUT.:    ?Rewrite (file-name) required
              ?Output error:  Disk space exhausted for file
     GETCN.:  ?Too many I/O channels in use
     Exponentiation:  ?Error:  negative number to real exponent
                      ?Error:  zero to exponent less than 1
                      ?Arithmetic exponentiation overflow
                      ?Exponentiation underflow
                      ?Exponentiation overflow
     NEW.:    ?Heap overflow.  Try again with more core.
     DSPOS.:  ?Bad pointer in DISPOSE
              ?Attempt to free freed block
     RLEAS.:  ?Invalid Heap pointer in RELEASE

$jus
4.10.\&Double precision floating point&\
$ski
Not all functions may be performed in
double precision.
The following routines are invoked when the
DOUBLE option has been specified.
Each calls the appropriate single precision routine
and zeroes AC1 (the low-order word of the
double precision result):
$ski
$ver
$tabs5,20,35
	&function&	&entry point&	&FORTRAN routine called&

	\ARCCOS	\\\DACOS.	\\\\\\\ACOS.
	\ARCSIN	   DASIN.	       ASIN.
	 COSD	   DCOSD.	       COSD.
	 COSH	   DCOSH.	       COSH.
	 SIND	   DSIND.	       SIND.
	 SINH	   DSINH.	       SINH.
	 TANH	   DTANH.	       TANH.

$jus
In addition, the double precision RANDOM routine is DRAND.
$page
5.\\&PASCAL REL file format&
$ski
The object code produced by the PASCAL compiler
is in the form of LINK-10 records
(see &LINK-10 Programmer's Reference Manual&).
Briefly, each record consists of an &item type&, a
count of data words, one word of relocation
bits and up to 18 words of data or code
(see figure 5.1).
The left and right halves of the data words are
relocated according to their corresponding
relocation bits (see Table 5.1), with addresses
greater than 400000B relocated in the
high segment.
$ski
$tabs 10,30
$ver
	&Relocation bits&	&Interpretation&

	\\\\\\\00	no relocation
	\\\\\\\01	relocate right halfword
	\\\\\\\10	relocate left halfword
	\\\\\\\11	relocate both halfwords

	Table 5.1:  LINK-10 halfword relocation
$ski
$jus
5.1.\\&LINK-10 item types&
$ski
Only nine of the possible item
types are currently emitted:
$ski
&Link item type 1&:  CODE
$ski
The first data word specifies the (relocatable) address at
which the next word in the record is to be placed.
As an example, the PASCAL statement:
$ski
$ver
$tab 10
	I := 2+3;
$ski
$jus
might produce three instructions starting
at location 400200:
$ski
$tabs 10,20,30
$ver
	400200	MOVEI	2,2
	400201	ADDI	2,3
	400202	MOVEM	2,I
$ski
$jus
A CODE record containing only these instructions
would be:
$ski
$ver
$tabs 10,30
	000001,,000004	item type=1, length=4 words
	202000,,0	relocate code address and I
	000000,,400200	code address
	201100,,000002	MOVEI 2,2
	271100,,000003	ADDI  2,3
	202100,,address (I)	MOVEM 2,I
$ski
$jus
The addressing of symbols is discussed
under item type 2.
$ski
&Link item type 2&:  SYMBOLS
$ski
Each symbol is represented by two words;
the first contains a left-justified 4-bit
code and the radix-50 representation of the symbol.
Only three code types are emitted:
$ski
$ind left 8
$par-4
code type 04B:  global definition (i.e., PUBLIC).
The second word of the pair gives the address
of the symbol.
$ski
$par-4
code type 10B:  local symbol.  Public procedures/functions
and the program or module name are defined once as
a global (04) and once as a local (10B).  The second
word of the pair is the start address of the routine.
$ski
$par-4
code type 60B:  global request. 
The second word of the pair is the address of a
&backlink chain& of references
to the global symbol.
In each request the right half of the word
gives the address of the next request.
The backlink chain terminates with a 
non-relocatable zero in the right halfword.
$ind left 0
$ski
Thus a program fragment:
$ski
$ver
$tabs 10,20,30
	\\\EXTERNAL VAR I: 1..10;
	\\\\\...
	400030	I := I+1;	(* first and recond references to I*)
	400033	...
$ski
$jus
might generate the following code and symbol records:
$ski
$ver
$tabs 10,30
	000001,,000004	item type=code, 4 words
	202000,,0	relocate code address and
		\\\second reference to I
	\\\\\0,,400030	code addres
	200100,,000000	MOVE 2,0 (actually MOVE 2,I)
	271100,,000001	ADDI 2,1
	202100,,400030	MOVEM 2,400030 (actually MOVEM 2,I)

	000002,,000002		item type=symbols
	600000,,000011	code=60B, radix-50 name of I=11B
	\\\\\0,,400032	backlink chain of requests to I
$ski
$jus
&Link item type 3&:  HISEG
$ski
Identical for every REL file and always
the third record emitted, consisting of 3 words:
$ski
$ver
	000003,,000001	item type 3, 1 word of data
	\\\\\0,,0	no relocation
	400000,,400000	
$ski
$jus
The data word indicates that relocatable addresses
less than the left halfword are to be located in the
low segment (relocated from zero) and that addresses
greater than or equal to the right halfword are to be located
in the high segment (relocated from 400000).
$ski
&Link item type 4&:  ENTRY
$ski
Always the first item in the REL file, this
record contains 3 words:
$ski
$ver
	000004,,000001	item 4, 1 data word
	\\\\\0,,0	no relocation
	\\\\\\?	radix-50 name of source file or of
		"program/module" name from 
		PROGRAM/MODULE statement
$jus
$ski
&Link item type 5&:  END
	
$ski
always the last record in the REL file,
consisting of 4 words:
$ski
$ver
	000005,,000002	item 5, 2 data words
	240000,,000000	relocate right half of next 2 words
	\\\\\0,,400000+	high segment break
	\\\\\0,,000000+	low segment break
$ski
$jus
The high segment break is one greater than the
highest address used in the high segment.
Similarly, the low segment break gives the first free
location in the low segment.
At least one low-segment location is allocated
in each PASCAL compilation.
$ski
&Link item type 6&:  NAME
$ski
Immediately follows the ENTRY record and consists of
3 words:
$ski
$ver
	000006,,000001	item 6, 1 data word
	\\\\\0,,0	no relocation
	\\\\\\?	same radix-50 name as
		in ENTRY record
$ski
$jus
&Link item type 7&:  START ADDRESS
$ski
Emitted only in a MAIN compilation.
The data word gives the address at which
execution should begin:
$ski
$ver
	000007,,000001	item 7, 1 data word
	200000,,0	relocate start address
	\\\\\0,,?	address of main's entry point
$ski
$jus
The start address is emitted after the library
requests (item type 17B) and before the END
record.
$ski
&Link item type 10B&:  INTERNAL REQUEST
$ski
Generated primarily for forward references.
Each data word has a value in the right halfword
and the address of a backlink chain in the
left halfword, as for global requests.
However, if the data word is -1, the requests are
chained in the left halfword rather than the right.
$ski
As an example, assume the following code has been
processed by LINK-10:
$ski
$ver
$tabs 5,15,30,45
	address	relocation	lefthalf	righthalf

	400100	\\\\no	\\\\0	\\\\0
	400101	\right	\\\\0	400100
	400102	\\\\no	\\\\0	\\\\0
	400103	\\both	400100	400101

and an internal request is encountered:

$tabs 10,30

	000010,,000001	item 10, 1 data word
	600000,,0	relocate both halves
	400103,,400200	backlink,,value


$jus
This indicates that each entry in the backlink
chain which starts with the right halfword at location
400103 is to be replaced by the relocatable value
400200.
Thus the right halfwords at locations 400103, 400101 and 400100 become
400200:
$ver

$tabs 5,15,30,45
	400100	\right	\\\\0	400200
	400101	\right	\\\\0	400200
	400102	\\\\no	\\\\0	\\\\0
	400103	\\both	400100	400200

Another internal request:

$tabs 10,30
	000010,,000002	item 10, 2 data words
	140000,,0	relocate both halves of second word
	777777,,777777	-1
	400103,,440000	backlink,,value

$jus
indicates that the backlink chain starts with
the &left& halfword at locations 400103
(since the data word is "-1") and the left
halfwords at locations 400103 and 400100 are
replaced by the relocatable value 440000:
$ver
$tabs 5,15,30,45

	400100	\\both	440000	400200
	400101	\right	\\\\0	400200
	400102	\\\\no	\\\\0	\\\\0
	400103	\\both	440000	400200
$jus
$ski
&Link item type 17B&:  LIBRARY REQUEST
$ski
The data words appear in triplets, the first word
of which is the file name in SIXBIT, the
second is the UFD, and the third word is the device
in SIXBIT.
For PASLIB the device is "DSK" and the UFD is the
PPN of the compiler itself, i.e., RND:PASCAL
references RND:PASLIB.
For other libraries the device is "SYS" and the
UFD zero.
The PASLIB request is always emitted first.
$ski
Example record:
$ski
$tabs 10,30
$ver
	000017,,000006	item 17B, 6 data words
	\\\\\0,,0	no relocation
	604163,,545142	'PASLIB'
	052250,,000222	UFD of compiler
	446353,,0	'DSK'
	455762,,545142	'FORLIB' in SIXBIT
	\\\\\0,,0	zero UFD
	637163,,0	'SYS' in SIXBIT
$jus
$ski
The general sequence of link records in a REL file is:
$ski
$ver
	ENTRY	first
	NAME	second
	HISEG	third
	CODE
	INTERNAL REQUEST	intermixed with CODE
	\...	\\as required
	SYMBOLS
	LIBRARY REQUEST
	START ADDRESS	only in MAIN
	INTERNAL REQUEST	if required prior to END
	END	always last
$jus
$ski
5.2.\\&Common sources of link-10 load-time errors&
$ski
$ind left 8
$par-4
1.\\&Symbol name conflict& - since identifiers are
truncated to six characters, 'NAME100' and 'NAME101'
are identical to LINK and a diagnostic is
generated by the multiple definition of the
symbol 'NAME10'.
$ski
$par-4
2.\\&Improper relocation& of a non-relocatable value,
particularly NIL (377777B) or zero.
Rarely occurs.
$ski
$par-4
3.\\Broken or improper termination of &backlink chains&.
The most insidious of all since LINK will blindly
relocate the world until a zero
is encountered.
This may cause infinite loops, illegal memory references
in LINK, completely abnormal program behavior,
and nerve-wracked programmers, or it may simply
 not be detectable at all.
$ind left 0
$page
6.\\&Debugger interface&
$ski
The information supplied for the PASCAL debugger
is a highly interwoven data structure
comprised of &procedure& blocks, a &program&
block, and &statement&, &page&, and &source-file& blocks.
$ski
The compiler's symbol table is dumped in a
specific format to a file with the extension
.DEB and all pointers into and within this
table are offset from zero.
$ski
6.1.\\&Program link word&
$ski
The first (high-segment) word emitted in a 
compilation contains in its right half a pointer
to the program block or NIL if not in DEBUG mode.
The left half of this word contains the right
eighteen bits of the RADIX50 name of the
program from the PROGRAM or MODULE statement
and is used by the debugger to locate
PASCAL compilations from the LINK-10
symbol table.
$ski
6.2.\\&Procedure blocks&
$ski
Also emitted in TRACE mode, a procedure block consists
of four words:
$ski
$ind left 8
$par-6
1,2:\\procedure/function/PROGRAM/MODULE name
 (ten characters)
$par-4
3:\\left half\=\level
$par
right half\=\symbol table index for this routine
$par-4
4:\\left half\=\pointer to program block or NIL
$ski
$ind left 0
The word following a JSP\AC1,PNTRY. or
JSP\AC7,INITP. contains the address of the
procedure block or NIL if neither DEBUG nor
TRACE is in effect.
$ski
6.3.\\&Program block&
$ski
Ten words are emitted:
$ski
$ind left 4
$ver
1:\\\left half\=\pointer to last emitted source-file block
\\\\right half = symbol table index of last level 1 procedure or
                 function
2:   left half = high segment relocation base
    right half = low segment relocation base
3:   left half = symbol table index to a chained list
                 of "standard" identifiers
    right half = symbol table index for type INTEGER
4:  right half = symbol table index for type REAL
5:  right half = symbol table index for type CHAR
6:  right half = symbol table index for type BOOLEAN
7:  source file device in SIXBIT
8:  source file name in SIXBIT
9:  source file extension in SIXBIT
$par-1
10:  source file PPN.
$ski
$ind left 0
$jus
6.4.\\&Statement block&
$ski
For the first executable statetment on a line
the compiler emits a call to a runtime routine STMT.\followed
by a one-word statement block, the right half of which
is the line number within the page and the left half is
a pointer to the previous statement block.
The first such block points to the page
block itself.
The sequence is:
$ski
$ver
     JSP   AC1,STMT.
     XWD   address (previous), line number
$ski
$jus
6.5.\\&Page block&
$ski
A four word block of information is emitted
for each page containing executable code:
$ski
$ver
$ind left 4
1:   left half = pointer to previous page block
    right half = pointer to last statement block in 
                 this page
2:  right half = page number
$par-2
3,4:  page subtitle or blanks (ten characters)
$ski
$jus
$ind left 0
The left half of the first word points to the file
block if the first page in the file.
A page block is emitted inline, preceded by a
JRST\.+5 unless immediately preceded by a file block.
Note that the pointer to the last statement
and the statement block "previous" pointers form
a &ring& structure.
$ski
6.6.\\&File block&
$ski
Also a four word block skipped by a JRST\.+9 (skips page block which immediately follows):
$ski
$ind left 4
$ver
1:   left half = pointer to previous file block
    right half = pointer to last page in this file
2:   left half = pointer to "program link word"
$par-2
3,4:  ASCII file name (less device, ten characters).
$ski
$ind left 0
$jus
Like the statement pointers, the page block pointers form a ring.
$ski8
dc
$par
    D@/