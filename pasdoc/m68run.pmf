$TOP 4
#define(#note,text,&
$SKI
[? text ?]
$SKI)
#document(MDSI Pascal M68000 Runtime Specification,<:January 5, 1982:>,48)
#sect_default(4)
#footnotes(left)
#title_page_1(MDSI Pascal Motorola 68000,Runtime Specification,#date)
#sect(Introduction)
This document describes the overall design and the interface
specifications for the runtime routine package for the
Motorola 68000 implementation of MDSI Pascal.
Implementors and maintainers of the runtime should also see
the document ^UMDSI Pascal M68000 Runtime Conventions And Standards|U.
The I/O runtime is described in the document ^UMC68000 Pascal
I/O Runtime Notes|U.
#sect(Procedure Calling Conventions)
This section describes the stack frame format, parameter passing
conventions and procedure calling and returning code.
#beginlevel
#sect(Stack Frame Format)
The format of a stack frame is shown in the figure below.
Most of the fields are self-explanatory; however, the
remaining subsections on procedure calling conventions
describe the contents and maintenance of the stack in
more detail.
Register A6 is reserved for use as the frame pointer.
#beginfigure(26,0)
	|			|	    ^
	+-----------------------+	    |
	|	 locals		|<-- SP	    |
	|	  and		|         lower
	|	 temps		|       addresses
	|			| -4(A6)
	+-----------------------+
	|	old A6		|<-- A6
	+-----------------------+
	|	HBT addr	|  4(A6)
	+-----------------------+
	|    proc block addr	|  8(A6)
	+-----------------------+
	|   old SP offset	| 12(A6)
	+-----------------------+
	|    return address	| 16(A6)
	+-----------------------+
	|   [static link]	| 20(A6)    (only if lvl > 1)
	+-----------------------+
	|			| 20(A6) or 24(A6)
	|       arguments	|
	|			|
	+-----------------------+
	|	caller's	| 
	|       dynamic		|
	|	 temps		|
#endfigure
#sect(Parameter Passing)
This section describes the argument block and the conventions used in
passing parameters to Pascal routines.
#beginlevel
#sect(The Argument Block)
Addresses in an argument block occupy four bytes and are
word aligned.
Flex upperbound words for strings occupy two bytes and are
word aligned.
Flex upperbound words for arrays occupy four bytes and are
word aligned.
A parameter passed by value has, with one exception, the same storage allocation
and alignment as a simple variable of the same type.
^CThe one exception is that simple variables which normally occupy
a single byte will occupy a word in the argument block.
This is due to the fact that an auto-decrement of the stack pointer
for a byte value subtracts two from the stack pointer in order to
guarantee word alignment of the stack.|C
#sect(VAR Parameters)
All VAR parameters are passed by address.
If the type of the formal is a flexible type, then the
address is preceded by an upperbound word or longword.
#sect(Value Parameters)
All strings, records, arrays and sets are passed by address.
If the type of the formal is a flexible type, then the address
is preceded by an upperbound word or longword.
All other value parameters are passed by value.
#sect(Function Return Values)
Function return values are always treated as an implicit
zeroth VAR parameter.
Note that the code generator is free to treat a return value as
a local and upon return copy it to the location whose
address is passed in.
#endlevel
#sect(Calling A Non-quick Routine)
This section describes the code used to call, enter and exit
a non-quick routine.
#beginlevel
#sect(Calling Code)
Arguments are passed by pushing them onto the stack.
The callee will reference arguments as positive offsets
from the callee's frame pointer.
The caller saves any registers in use after pushing the
arguments onto the stack, but before transfering control
to the callee.
The code which appears at the call point is described in
the figure below:
#beginfigure(6)
<fetch any args which might require dynamic temps>
<push arguments onto stack>
MOVEM.L  <regs in use>,K(SP)	; use MOVE.L if only 1 reg
[ <code to push static link> ]	; only if callee's level > 1
JSR      <callee's entry point>
MOVEM.L	 K(SP),<regs in use>	; use MOVE.L if only 1 reg
#endfigure
The calling sequence begins with a scan of the intermediate form
for each argument, checking for any tuples which might
require a dynamic temp during the evaluation.
Any parameters which might require a dynamic temp
are evaluated, but not pushed onto the stack.
This is necessary to prevent a dynamic temp from 
splitting the argument block.
Next, all of the arguments are evaluated if necessary and
then pushed onto the stack.
Next any registers in use, other than A5, A6 or SP,
are saved by moving them to a static temp.
Note that registers should only be allocated at this point
if the subroutine being called is a function appearing
in an expression which has been partially evaluated already.
#par
If the lexical level of the callee is greater than one, then
the callee's static link is pushed onto the stack.
The static link field of the stack frame is not present for
routines at lexical level zero or one.
#par
The callee is then called with a JSR instruction.
Upon return the registers saved before the call
are restored.
#sect(Entry Code)
The following section describes the code present at the entry point
when the NOCHECK(STACK) option is in effect.
The section following that one describes the case where stack overflow
checking is enabled.
#beginlevel
#sect(Entry Without Stack Overflow Checking)
The following code and data appears at the routine's entry point:
#beginfigure(7,0)
	MOVEQ	#K1,D0		; save offset from new frame
	MOVE.L	D0,-(SP)	;    ptr to old top of stack
	BSR	L1		; save debug addr,
				; skip debug block
	<procedure block>
L1:	CLR.L	-(SP)		; clear HBT address
	LINK	A6,#-<frame size> ; set frame ptr, allocate frame
#endfigure
The first two instructions save on the stack the number of bytes
occupied by the argument block and all the fields of
the stack frame above the argument block up to and including
the old frame pointer field.
This information will be used in deallocating the stack frame
when the routine returns.
The "BSR" instruction both skips over the procedure block
following it and also saves the address of the procedure
block on the stack.
The format of a procedure block is described in the section
on debugging aids.
If the NOTRACE option is in effect, then both the BSR instruction
and the procedure block are replaced by a "CLR.L\\\-(SP)"
instruction which zeroes the procedure block address in the stack
frame.
The next instruction clears the handler branch table address.
The LINK instruction sets the new frame pointer, saves the old frame
pointer and allocates space for the locals and static temps of
the new frame.
#sect(Entry With Stack Overflow Checking)
When stack overflow checking is enabled, a routine entry runtime routine
is called.
The following code appears at the entry point.
#beginfigure(7)
	MOVEQ	#K1,D0		; save offset from new frame
	MOVE.L	D0,-(SP)	;    ptr to old top of stack
	BSR	L1		; save debug addr,
				;    skip debug block
	<procedure block>
L1:	MOVE.L	#-frame_size,D0	; often a MOVEQ will work
	JSR	M.ENTRY		; call entry runtime routine
#endfigure
If NOTRACE is in effect, then the BSR instruction and the procedure
block are replaced by a "CLR.L\\\-(SP)" instruction.
The stack frame size in the move instruction must include
four bytes for the old frame pointer field as well as
the space for locals and static temps;
thus the stack frame size used in this case is four
bytes larger than that used when stack overflow checking
is disabled.
A possible coding of the routine entry runtime routine is shown below:
#beginfigure(10)
M.ENTRY:
	MOVEA.L	(SP),A0		; save return address
	CLR.L	(SP)		; clear HBT address
	ADD.L	SP,D0		; calc new stack pointer
	CMP.L	M.STKEND(A5),D0	; compare with stack limit
	BLS	L2		; branch if OK
	<signal stack overflow>
L2:	LINK	A6,#0		; set new frame pointer
	MOVEA.L	D0,SP		; set new stack pointer
	JMP	(A0)		; return
#endfigure
#endlevel
#sect(Return Code)
The only instruction which appears at a return point
is a jump instruction to the subroutine exit runtime
routine, "JMP\\\\M.RETURN".
#par
A possible coding of the subroutine exit routine is shown below.
#beginfigure(7)
SF.OLDSP EQU	12		; offset of old SP offset

M.RETURN:
	MOVEA.L	SF.RET(A6),A0	; save return address
	UNLK	A6		; cut stack back some and
				;    restore old frame ptr
	ADDA.L	SF.OLDSP(SP),SP	; ^Crestore caller's SP|C
	JMP	(A0)		; return to caller
#endfigure
#endlevel
#sect(Calling A Quick Routine)
This section describes the code at the point of call, at the entry
point and at the exit point of a quick-blocked routine.
#beginlevel
#sect(Calling Code)
The following code appears at the point of a call to a quick routine:
#beginfigure(4)
<move args to argument block>
MOVEM.L	<regs in use>,K(A6)
JSR	<callee's entry point addr>
<code to restore regs>
#endfigure
When calling a quick routine,
the argument block is allocated at a fixed offset in
the frame of the owner of the callee.
The argument block is allocated in that portion of the frame 
corresponding to the routine which is the immediate dominator of the callee.
The space allocated for the argument block is dedicated to that purpose and
is allocated as long as the immediate dominator is active, i.e.,
the argument block is treated just like the local variables of
the immediate dominator.
#note(<:The argument block could also be allocated in that portion of the
owner's frame corresponding to the owner.
This would be less space efficient (in stack space), but would
be easier to implement.:>)
#par
The calling sequence begins with code to move the arguments
to the argument block.
Next any registers currently in use, other than A5, A6 and SP,
are saved.
The callee is then called with a JSR instruction.
After the point of the call, any registers
saved before the point of the call are restored.
#sect(Entry Code)
No special entry code is required at the entry point of a quick routine.
#sect(Return Code)
At an exit point, an RTS instruction is used
to return to the caller.
Note that all dynamic temps must be deallocated at
the time of the return.
#endlevel
#endlevel
#sect(Memory Organization)
This section describes the layout of the data segment and the usage
of the "sections" which form the basis of the linker's memory allocation.
#beginlevel
#sect(Section Allocation)
All code and data must be generated in a section numbered from zero
to fifteen.
The linker groups sections into at least one and at most four
"segments".
Compiler generated code and constants are generated in section ten.
Runtime code and constants are generated in section nine.
Compiler generated and
runtime read/write data are placed in section one.
#par
The grouping of sections into segments is determined at link time.
However, the linker's default action, given the above section
allocations, will be to place the runtime and compiler generated
code and constants into a single read-only segment named "SEG1".
By default, the runtime and compiler generated read/write data
will be placed in a read/write segment named "SEG0".
#sect(Static Storage)
The approach taken to code sharing on an unmapped system
prohibits reserving any read/write data at compile, assembly
or link time.
The data segment for static storage, the stack and the heap
will be created at execution time by the Pascal
initialization runtime routine.
The size of the segment created will be the sum of the
size of the "static" storage reserved in the image file
and the size of the stack and the initial heap
(as described below, the stack and heap sizes are the
values of certain global symbols).
#par
True static storage is prohibited by this scheme.
However, both the Pascal programmer and the runtime
will be permitted to declare "static" storage using
the following approach.
Static storage will be generated at compile or
assembly time in the normal fashion.
However, all references in the code to static storage will
be made as displacements from a dedicated static storage
pointer register, A5.
After linking the image file will be modified to inhibit
the loader from allocating and initializing a data segment.
The Pascal initialization routine will load the initial
contents of the data segment from the image file
after it has dynamically created the data segment.
This scheme also requires that the data segment be linked
at a fixed starting address; 
the value zero will be used as the fixed base.
In order to permit 64K bytes of static, register A5 will point
to 32768 bytes past the base of the static storage area.
This will require that a static variable "FOO" be referenced
as "FOO-32768(A5)" rather than simply as "FOO(A5)".
#sect(Data Section Layout)
The layout of the data segment created by the initialization
routine is shown below.
#beginfigure(15)
	+-----------------------+
	|	    ^		|  high addresses
	|	    |		|
	|	    |		|
	|      initial heap	|
	+-----------------------+
	|	  stack		|
	|	    |		|
	|	    |		|
	|	    v		|
	+-----------------------+
	|			|
	|     static storage	|
	|			|
	+-----------------------+  low addresses
#endfigure
The stack will have a default size of 8192 bytes.
A user may explicitly set the stack size by using the
compiler's STORAGE option.
If the user explicitly sets the stack size via the STORAGE option,
then the compiler must emit a global definition for the symbol
M.STKSIZ, where the the value of the symbol is the 
(non-relocatable) user specified stack size.
#par
The default size of the initial heap will be 32K bytes.
This value may be overridden at link time by defining
the symbol H.INISIZ, giving it as a value the desired
initial heap size.
The total heap size may expand and contract at execution
time, see the section on heap management for details.
#sect(Stack Overflow Checking)
The area reserved for the stack is fixed in size.
A stack overflow may occur at routine entry and whenever
a dynamic temp is allocated.
A compiler block option will determine if stack overflow
checking is done at these times.
A new CHECK suboption, the STACK suboption, will be used for
this purpose.
As with other CHECK options the default value will be
checking enabled.
#endlevel
#sect(Runtime Calling Conventions)
This section describes the runtime calling conventions
relevant to the caller.
All the runtime routines are called with a JSR instruction;
the effective address field of the instruction is a 32 bit
direct address.
All registers except those used to return results are preserved.
Any arguments pushed onto the stack are popped off before the
runtime routine returns.
However, some runtime routines may return a value on top
of the stack.
Two general approaches are used for parameter passing.
Each of these schemes is described below.
These descriptions are intended only to present the
general approaches used to pass parameters to the runtime;
the descriptions of the individual routines must be consulted
for specifics.
#beginlevel
#sect(The Standard Conventions)
The parameter passing conventions described in this section
are used in most cases.
Input and input/output parameters are pushed onto the
stack before the call to the runtime routine.
The parameters may be passed either by value or by address.
It is important to note that if more than one parameter is
passed via the stack, then the code generator must evaluate
all the parameters before pushing any of them onto the stack.
This is necessary to avoid having a dynamic temp allocated
on the stack between two of the parameters.
#par
Output parameters (return values) may be handled in one of three
ways.
^CThe first approach, which is the preferred approach, is to leave
return values on top of the stack.|C
#par
In the second approach, the value is returned in a register.
Since none of the registers are volatile and the code
generator controls register allocation for the in-line code,
for a given function several entry points will be provided which
perform the same function but return the result in different
registers.
Typically, a given function will have entry points for
returning the result in some subset of either the data
or address registers and an 'escape' entry point which
returns the result in a memory location whose
address is passed in on the stack.
The multiple entry points can be implemented by providing multiple
short wrapper routines for a central routine which actually implements
the given function.
The wrappers would each be placed in a separate object module so
that only the wrappers actually required by a user program
would be pulled from the runtime object library.
This approach would clearly complicate maintainance of the
runtime and should only be used for frequently called
runtime routines.
#par
^CThe third approach is to push the address of the location to
receive the result onto the stack before the call.|C
#sect(A More Space Efficient Approach)
The following approach would require less code in-line,
but would require many wrapper routines.
It may be an appropriate technique for very frequently
called runtime routines such as floating point add,
subtract, multiply and divide and integer multiply and
divide, if they require runtime calls.
#par
In this approach, input and input/output parameters as well
as output arguments could be passed in the registers.
As in the second approach to handling output arguments
discussed above, many registers or register combinations
would be made available through the use of multiple
entry points and wrapper routines.
A number of variations are possible.
For example, consider floating point addition.
A set of wrapper routines might be available  
where one operand was in a register and the other
operand was in memory.
The address of the memory operand would be pushed onto the stack
and the result would overwrite the register operand.
Another possibility would be to have wrappers specific to
two registers.
Both operands would be in registers and the result would
be left in one of the registersndlevel
#sect(Debugging Aids)
This section describes the supports necessary for a stack
traceback facility and for the Pascal debugger.
The supports proposed for the debugger represent a fundamentally
different approach to providing the debugger with line number
information.
Rather than adding debugger blocks to the code, all debugging
information, except that required to support a stack traceback,
is generated in a disk file at compile time.
This debug file will also contain the symbol table information
which is present in the ".DEB" file in the DEC10 implementation.
#par
Several other departures from the DEC10 debugger implementation
are also assumed;
however, these changes have a relatively modest impact on the issues discussed
in this section.
These changes include making the DEBUG and QBLOCK options independent.
Another possibility is having the debugger run as a separate process,
i.e., in a separate address space from the program being debugged.
This approach would primarily impact the debugger code rather than
the runtime structures and therefore is not discussed in any detail
in this section.
#par
The approach of placing line number information in the debug file
represents a substantial departure from the approach used on the
DEC10.
There are numerous advantages to this approach;
the major ones are listed below:
#beginitem(3)
#item()Since a debug compilation would only cost file space,
during development it could be the normal mode of compilation.
This would make recompilation for debugging unnecessary.
#item()Debug mode code would execute at the same speed as
non-debug code.
#item()If a separate process debugger was also used, then
use of the debugger would not change the memory layout
of user programs.
On the DEC10 compiling in debug mode and linking the debugger in
often completely changes the symptoms of a bug.
#item()Since all debugging information is in disk files, a user
program cannot become too large for physical memory when the
debug option is used;
this frequently occurs on the DEC10.
#item()If overlays are used, a single area size is appropriate for
both debug and non-debug code.
Again, on the DEC10, overlay area sizes are generally defined
as one size in a development environment and as a second,
smaller size for the production version of the program.
#item()If a separate process debugger is used, then the functionality
of the debugger need not be overly restricted by concern with the
size of the debugger.
#enditem
#beginlevel
#sect(User Visible Debugger Changes)
This section describes proposed functional changes which would
be visible to users of the debugger.
The major change would be a restriction on the debugger's single
stepping capability.
Single stepping would only be permitted in code which was
compiled with the debug option.
An attempt to single step while in a non-debug module, or an
attempt to single step into a non-debug subroutine from debug
code, will result in a debugger error message.
#par
Currently, a single step command in non-debug code will cause
execution to resume and continue until the first statement of
a subroutine compiled in debug mode.
The primary use of this feature is in overlaid DEC10 programs,
where it is difficult to set breakpoints in overlays.
Using the scheme proposed here, breakpoints could be set anywhere
in debug mode code, with one restriction.
Any code in a "link management" module would have to be associated
before breakpoints could be set in it.
This restriction seems like a minor one,
with the slight inconvenience of this restriction outweighed by 
the advantages of this approach.
#par
The second user visible change is that the DEBUG and QBLOCK options
would be totally independent.
The debugger would be somewhat restricted in the information
which it could supply when debugging quick routines.
A more detailed discussion of the interaction of debug mode and
quick blocking is given in a later section.
#sect(Data Structures)
This section describes the data structures which must be
generated by the compiler to support the debugging tools.
The first subsection discusses data structures generated
in the relocatable object file when either the TRACE or
DEBUG options are used.
The second section describes the contents of the debug file
which is generated when the DEBUG option is used.
#beginlevel
#sect(Object File Data Structures)
Two data structures are generated in the object file.
Both of these data structures are generated in their
entirety if the TRACE option is used (the DEBUG option
must imply the TRACE option).
If the NOTRACE option is used, then neither of
these data structures is generated.
#beginlevel
#sect(The Program Block)
One program block is generated for each compilation unit.
The block is generated as the first item in the code area.
The program block layout is shown below.
#beginfigure(10)
      31           16 15            0
     +-------+-------+-------+-------+
     |     compilation day/time      |
     +-------+-------+-------+-------+
		     | static offset |
     +-------+-------+-------+-------+
     |  object file name  (6 chars)  |
     |               +---------------+
     |               |
     +-------+-------+
#endfigure
The compilation day/time is the low order 32 bits of the
DEC10 internal day/time.
The debugger simply considers it an arbitrary bit pattern which
must be matched by a corresponding value in the debug file.
In a debug compilation
the static offset is the displacement from A5 of this module's
contribution to the static data area.
In a non-debug compilation this field must be set to zero.
The six character object file name is generated as the final
field.
File names shorter than six characters are padded with null bytes.
The full object file pathname is not stored since the MC68000
compiler will be a cross-compiler.
#sect(Procedure Blocks)
A procedure block is generated near the
entry point of each routine.

The layout of a procedure block is shown below.
#beginfigure(11)
      31           16 15            0
     +-------+-------+-------+-------+
     |     program block address     |
     +-------+-------+-------+-------+
                     | routine table |
                     +-------+-------+
                     |  name length  |
     +-------+-------+-------+-------+
     |       procedure name          |
     |          text ...             |
     +-------+-------+-------+-------+
#endfigure
The routine table field contains the byte offset from the
start of the routine table (in the debug file) to the routine
table entry corresponding to the subroutine.
Routine tables are discussed in the section describing
the debug file's contents.
This field is zero if the NODEBUG option is used.
#endlevel
#sect(Debugger File Data Structures)
This section describes those data structures which are generated
in the debug file whenever the DEBUG option is used.
The debug file is named using the file name of the object file
and the extension ".PD" (^UP|Uascal ^UD|Uebugger).
Extensions under VERSAdos are limited to two characters;
the extension ".DB" is used for the VERSAdos linker generated
debug file.
#beginlevel
#sect(Overall Layout Of The Debug File)
The layout of the various tables in the debug file is
shown in the figure below.
This layout is based on two factors.
First, pointers from one data structure within the debug file
to another are stored as byte offsets from the start of the
debug file.
Given the layout shown below, it is assumed that offsets
to the statement lists, the cross reference tables, the
page tables, the file table and the start of the symbol
table may be stored in two bytes.
Second, an attempt has been made to layout the tables
in an order which makes generating the debug file 
as convenient as possible.
#beginfigure(20)
     +-----------------------+
     |    header block       |
     +-----------------------+
     |   statement lists     |
     |                       |
     +-----------------------+
     |     page/statement    |
     |    cross reference    |
     |         tables        |
     +-----------------------+
     |      page tables      |
     |                       |
     +-----------------------+
     |      file table       |
     +-----------------------+
     |      symbol table     |
     |                       |
     +-----------------------+
     |    routine table      |
     +-----------------------+
#endfigure
#sect(The Header Block)
The header block contains the file offset of certain tables or
table entries.
In particular, offsets are given for the start of the symbol
table, the file table, the routine table and the symbol table
type nodes for the standard types integer, real, boolean and
character.
As noted above, some of these offsets are assumed to fit in
two bytes;
four bytes are allocated for others.
All offsets are zero-based, byte offsets.
The layout of the header block is shown in the figure below.
#beginfigure(16)
                      15            0
                     +---------------+
                     | symtab offset |
                     +---------------+
      31             |file tab offset|
     +---------------+---------------+
     |     routine table offset      |
     +-------------------------------+
     |   integer type node offset    |
     +-------------------------------+
     |     real type node offset     |
     +-------------------------------+
     |     char type node offset     |
     +-------------------------------+
     |  boolean type node offset     |
     +-------------------------------+
#endfigure
#sect(The File Table)
One file table is generated for the compilation unit.
The file table has one entry for each source file
for which executable code has been generated.
The last file table entry is followed by a zero word.
The format of an entry is shown below:
#beginfigure(12)
      15                    0
     +-----------------------+
     |   page table offset   |
     +-----------------------+
                 | file num  |
     +-----------+-----------+
     |   file name length    |
     +-----------------------+
     |       file name       |
     |        text ...       |
     +-----------------------+
#endfigure
The page table offset is the offset within the debug file of
the page table corresponding to this file table entry.
The file number is the compiler assigned number of the
source file.
The file name length and text, in Pascal string format,
is the final entry.
#sect(Page Tables)
One page table exists for each file table entry.
Each page table has one entry for each page, within the corresponding
file, for which executable code has been generated.
Each page table is terminated by a zero word.
The format of a page table entry is shown below.
#beginfigure(13)
      15                    0
     +-----------------------+
     |    xref table offset  |
     +-----------------------+
     |      page number      |
     +-----------------------+
     |file table entry offset|
     +-----------------------+
     | page ID string length |
     +-----------------------+
     |     page ID string    |
     |         text...       |
     +-----------------------+
#endfigure
The "xref table offset" field is the offset within the
debug file of the page/statement cross reference table
for the page.
The page number is the compiler assigned page number of
the corresponding source file page.
The file table entry offset is the debug file offset of
the file table entry corresponding to the current page.
The length and text of the page title are the final table entries.
#sect(Page/Statement Cross Reference Tables)
A page/statement cross reference table is generated for each
page table entry.
Each cross reference table has one entry for each procedure
which has executable code generated from source code on
the corresponding page.
Each cross reference table is terminated with a zero word.
The format of a cross reference table entry is shown below.
#beginfigure(7)
      15                    0
     +-----------------------+
     | stmt list entry offset|
     +-----------------------+
     | offset w/in module of |
     |   first stmts code    |
     +-----------------------+
#endfigure
The first field is the (16 bit) offset within the debug file
of the statement list entry for the first source statement
in the given statement list which is also on the given page.
The second field is the (32 bit) offset within the compilation unit's
code of the first byte of code generated for the statement
designated by the first field.
The cross reference table entries are sorted into ascending order
based on the contents of this second field
(i.e., the statement list entry pointers appear in the
same order in which the corresponding statements appear in
the source code).
#sect(Statement Lists)
A statement list is generated for each routine in the compilation unit.
Statement list entries correspond to individual Pascal statements
and are generated in the same circumstances in which a
statement block is generated in the DEC10 implementation.
The entries appear in the same order in which the corresponding
source statements appear in the source files
(i.e., statement list entries are sorted by line number
within page).
Each statement list is terminated with a word in which all
bits are set to one.
A statement list entry is pictured below.
Note that the size and line number fields may be either
one or two bytes and that the line number and page offset
fields are not always present.
#beginfigure(21)
     +-+-+-----------+ - - - - - - - +
     |W|L|         size              |
     +-+-+-----------+ - - - - - - - +
     |    kind       |
     +-+-+-----------+ - - - - - - - +
     ||A|P|        line               |
     +-+-+---------------------------+
     |    page table entry offset    |
     +-------------------------------+

     W = 0  - size field is 6 bits
       = 1  - size field is 14 bits

     L = 0  - line and page fields are not present
       = 1  - the line field is present

     A = 0  - line field is a 6 bit line number increment
       = 1  - line field is a 14 bit absolute line number

     P = 0  - the page entry is not present
       = 1  - the page entry is present
#endfigure
#note(<:To be changed - "W" and "L" bits will be moved to the
byte containing the kind code and that byte will be made
the first byte of the entry.:>)
The size field is the size in ^Uwords|U of the code generated
for the source statement.
In the case of a compound statement, the size only includes the code 
generated at the beginning of the compound statement.
The size associated with an END keyword is the size of any code
terminating the compound statement.
In essence, the size of a statement is the number of bytes of code
which would be generated between two adjacent statement blocks
in the DEC10 approach.
Note that in some circumstances a size field of zero will
be generated, e.g., for a LOOP or REPEAT statement.
The zero length entries will serve the purpose of
allowing breakpoints to be set on the lines containing
the loop keywords.
#par
The size field may be either 6 or 14 bits depending on the
setting of the "W" bit.
The kind field indicates the type of the source statement;
this information is necessary to implement the ".KIND" command.
The line and page fields may or may not be present depending on the
setting of the "L" bit.
If the line field is not present, then the line
number corresponding to the statement is assumed
to be one greater than the last line number,
and, the page containing the statement is assumed
to be unchanged since the previous entry.
#par
If the "A" bit is set, then the line field is 14 bits
and represents an absolute line number;
otherwise, the line number field is 6 bits and represents
the change in line number from the previous statement.
The line field is always unsigned.
An absolute line number is always used in the first
entry in a statement list and in any entry in which
the page field is present.
#par
The page field is present only if the "P" bit is set.
The page field contains the offset from the start of
the debug file to the page table entry corresponding
to the statement.
If the page field is not present, then the page is assumed to be
unchanged since the previous entry.
#sect(The Routine Table)
There is exactly one routine table in each debug file.
The routine table contains one entry for each subroutine
defined in the compilation unit.
The routine table is terminated by a zero word.
The format of a routine table entry is shown below.
#beginfigure(10)
      15                    0
     +-----------------------+
     |    stmt list offset   |
     +-----------------------+
     |  offset of code for   |
     |     first statement   |
     +-----------------------+
     |   offset of block     |
     | node in symbol table  |
     +-----------------------+
#endfigure
The first field is the (16 bit) offset of the start of the
statement list for the routine.
The second field is the (32 bit) offset within the compilation unit's
code of the first statement of the routine.
The third field is the (32 bit) offset within the debug file
of the block node for the routine.
#sect(The Symbol Table)
The symbol table is simply the compiler's symbol table.
It is generated just as it currently is on the DEC10.
The start of the symbol table section of the DEBUG file
must be on a (Motorola) disk block boundary
(e.g., a 256 byte boundary).
#endlevel
#endlevel
#sect(Critical Algorithms)
This section describes the critical debugger algorithms
which have a substantially different implementation
given the debugger changes outlined at the beginning of this section.
#par
The discussions which follow assume the existence of some means
of translating a Pascal module name to the base address of the code
for that module.
On the DEC10 this is done using the global symbol table produced
by the linker.
It is not yet known how this can be accomplished under VERSAdos.
A symbolic debugger has just been added to the VERSAdos system
and a symbol table file is now produced by the linker.
However, the format of this file is not yet known.
Note that this capability is required no matter which approach
to supplying line number information is used.
#par
The term "source reference" is used throughout the following
subsections to refer to a Pascal source statement designation
in the debugger's "module@file-page/line" format.
#par
The approach to line number identification described here does
require making certain assumptions about the format of
a stack frame.
The compiler must save the current frame pointer before calls
to routines declared with the Fortran calling sequence
option.
The instruction to do this save must be the last instruction
generated before the JSR to the routine.
A longword labelled with the symbol M.FP_SAVE is used for
this purpose.
Immediately after the return from the routine, an instruction
must be generated to clear the longword at that location.
#par
If the user is concerned with the proper function of the debugger
after an attention or exceptional event in non-Pascal code which
is not called as external Fortran routines, then the following
conventions must be observed.
Either the frame pointer (address register A6) must be left
unmodified by the routine or the routine must establish
a Pascal compatible stack frame.
To be "Pascal compatible" the stack frame fields for the
old frame pointer, the return address and the procedure block address
must exist in the same locations and have the same semantics as
Pascal frames.
The safest approach is to simply use the Pascal runtime entry
and exit routines to establish a stack frame.
The RDLIB routines for the Motorola should probably be written to
both use the standard Pascal entry and exit runtime routines and
set up standard procedure blocks.
The standard procedure blocks can both indicate that the
code is non-debug mode code and supply the subroutine name
for stack tracebacks.
Non-Pascal, non-Fortran code which does establish a compatible
frame can simply set the procedure block address field to zero
and not use the runtime entry and exit routines.
The runtime and debugger will interpret a procedure block
address of zero as an indication of NOTRACE code.
#par
On entry to each runtime routine, except the procedure entry
and exit routines, the return address to the Pascal caller
will be saved in a longword labelled M.RET_ADDR.
Immediately before returning each runtime routine will clear
this location.
This will permit the debugger to print the current
location in the user's Pascal code after an attention
occurs while a runtime routine is executing.
#beginlevel
#sect(Stack Traceback)
Both the runtime error handling routines and the Pascal
debugger are capable of printing stack tracebacks.
The runtime's trace is simpler than the debugger's;
only routine names are printed.
The algorithm used by the runtime is straightforward.
If the saved frame pointer cell, M.FP_SAVE, is non-zero
then the address in the cell is used as the topmost
frame; otherwise the contents of A6 are used as the
topmost frame address.
Starting at the topmost frame, the procedure block address
in each frame is used to access the routine's procedure
block.
The procedure block contains the text of the routine's
name.
#par
^CThe runtime traceback is also produced whenever a user calls
the predefined parameterless procedure TRACE.
For a user call to TRACE, the compiler simply emits a
call to the runtime routine "M.TRACE".|C
#par
The traceback printed by the debugger prints source references
for the point of each call and the first statement in each
routine (if the corresponding code was compiled with the DEBUG option).
The location of the first line of code in each routine
is determined as follows.
The procedure block address is obtained as described above.
If the routine table offset field is non-zero, then the routine
was compiled with the DEBUG option.
The procedure block contains the address of the program block;
the program block contains the name of the object file,
from which the name of the debug file is derived.
The routine table in the debug file gives the offset of the
code for the first statement of the routine.
The base address of the module's code is added to this offset
to yield the address of the start of the routine.
The algorithm for mapping an address to a source reference
(described in a later section) is then applied to yield
the desired source reference.
#par
The location of each call is obtained by applying the
address to source reference mapping algorithm to the
return address field of each frame.
#sect(Mapping An Address To A Source Reference)
The debugger must map an address to a source reference as part
of the display location and display stack commands.
In addition to an address in the code area, the debugger
also has available an associated stack frame pointer.
In most circumstances the address and the stack frame
are known to correspond, i.e., the code address is known
to be in the routine for which the stack frame was established.
When the address and stack frame are known to correspond,
the translation of the address to a source reference
proceeds as follows.
The procedure block address in the stack frame is used to access
the procedure block for the routine.
The procedure block supplies the name of the debug file
and the offset within the routine table of the entry for the routine
containing the address.
The routine table contains the starting offset of
the statement list for the routine.
The statement list is searched sequentially until a
statement containing the desired address is found.
At this point the line number of the source reference is known.
The statement list entry also establishes the page table
entry for the source reference. 
The page table entry contains the offset of the corresponding
file table entry.
#par
The situation is more complex when the address and stack
frame may not correspond.
The one circumstance in which this may occur is in the
display location command.
For example, if the debugger is entered after an unhandled
attention, the address at which the attention occurred
need not correspond to the top stack frame.
The address may be in the runtime,
 in a quick blocked Pascal routine, in Fortran code, in an
assembly language routine or in some other non-Pascal code.
Thus for the display location command, the following
case analysis must be done:
#beginitem(3)
#item()If location M.FP_SAVE is non-zero then the address is
in Fortran code. 
In this case the current location is known only as an address;
no symbolic information is available.
If the stack is displayed, the display begins with the frame
whose address was saved in M.FP_SAVE.
The location within that routine, i.e., the point of the
call to the Fortran routine, is unknown.
#item()If the address is within either a procedure entry or exit
runtime routine, then the location is either the point of
call or the first line of the callee.
The exact location within the entry and exit routines determines
which location is used and which stack frame is used.
#item()If the location M.RET_ADDR is non-zero then the address
is within the runtime.
The address in M.RET_ADDR is used as the current location
address and the topmost stack frame is the associated stack frame.
#item()If the instruction at the given address is a JSR to a procedure
entry runtime routine, then the procedure block address
is obtained from the routine entry block following the JSR,
rather than from the top stack frame.
#note(The new procedure entry sequence complicates
this case considerably.)
#item()In all other cases the topmost stack frame's entry
block address is used to find the procedure block for
the frame.
If the routine corresponding to that procedure block is
not in DEBUG mode (i.e., if the routine table offset in
the procedure block is zero), the the current location
is simply displayed as an address.
If the routine is in debug mode then the current address is
looked up in the statement list for the routine.
If the address is within the routine, then a full source
reference can be displayed.
If the address is not within the routine, then the current
location must be either in a quick routine or in non-Pascal,
non-Fortran code.
The routine table is searched for the largest starting code
address which is smaller than the search address.
The statement list corresponding to that routine is searched
to determine if the address lies within that routine.
If it does, then a full source reference can be displayed.
Otherwise, the address is assumed to be in a non-Pascal, non-Fortran
routine and the location can only be displayed as an address;
the location of the call to the "foreign" routine from
within the Pascal routine is unknown.
#enditem
#sect(Mapping A Source Reference To An Address)
A source reference must be mapped to an address in order to
implement the debugger's BREAKPOINT command.
The mapping proceeds as follows.
The module name is used to obtain the base address of the
module's code.
#note(This step is currently magic.)
The program block is at that address and contains the object
file name;
the debug file name is derived from the object file name.
The debug file begins with the header block which contains
the file table offset.
The file table is searched sequentially for a match with the
file name or number specified in the source reference.
The matched file table entry contains the address of
the page table for the file;
the page table is searched sequentially for a match with the
page name or number specified.
The page table entry contains the offset of the page/statement 
cross reference table.
Each statement list pointed at by a cross reference table entry
is seached sequentially until one of the following conditions is
met:
(1.) the statement list ends,
(2.) the page changes,
(3.) a line number match is found,
(4.) a line number greater than that desired is found.
As the statement lists are scanned the starting address
of each statement is kept track of.
If all the statement lists are traversed without finding
the desired line or a greater numbered line, then the
last entry found (i.e., the largest numbered line on the
page)  is used.
#sect(Single Stepping)
Since single stepping will only be permitted from debug mode code,
whenever single stepping is initiated the starting address and
code size for the statement being stepped are known.
The single stepping will be implemented by using the trace bit
trapping capability of the MC68000;
when the trace bit in the status register is set the processor
traps after every instruction executed.
#par
The algorithm for single stepping in the "step over called
subroutines" mode is straightforward.
After each trap the value of the program counter (PC) is
examined.
If the next instruction to be executed lies outside the range
of the instruction being stepped then the debugger is invoked.
Otherwise, if the instruction to be executed next is a JSR
instruction, then a breakpoint is set following the JSR instruction
and trace bit trapping is turned off.
If the next instruction is not a JSR then one more instruction is
single stepped, i.e., the trace bit trap handler returns with
trapping still enabled.
#par
The following procedure is used when the "step into called
routines" command is used.
After a trap the PC is examined to see if it lies outside
the range of the current instruction.
If so, the debugger is entered.
If it does not, then the next instruction to be executed
is examined.
If it is not a JSR instruction then the trap routine returns
with trapping enabled and one more instruction is executed.
If the instruction is a JSR then the destination address
must be decoded.
If the address is within the current module then the
debugger is invoked with the destination address.
Note that this will handle all calls to quick routines.
If the address lies outside the current module then
the instruction at the destination address is examined.
If it is a "MOVE.L\\\(SP),M.RET_ADDR" then the call
is a runtime routine call.
A breakpoint is set following the JSR and the trap routine
returns with trace trapping disabled.
If the entry point instruction is a JSR to one of the
subroutine entry runtime routines, then the routine
entry block gives the procedure block address.
#note(The new procedure entry sequence complicates this
analysis considerably.)
If the called routine is in debug mode then the debugger is
invoked with the entry point address.
If the called routine is not in debug mode then
the debugger is also invoked but with some indication
that an error has occurred and with the current location
set to the point of the call.
If the called routine does not begin with a JSR to
a subroutine entry runtime routine, then the user
is attempting to step into non-Pascal code.
As above the debugger is invoked with an error indication
and the current location is set to the point of the call.
#note(Non-local GOTOs must be dealt with also.)
#sect(Interaction With Quick Blocking)
The algorithms presented for mapping a source reference to
an address and for single stepping will work without
restriction on quick routines.
Thus a user may either set a breakpoint or single step into
a quick routine which was compiled in debug mode.
Moreover, whenever the current location is in a debug mode
quick routine, the debugger has available all the information
necessary to establish scope, display scope and display
all in-scope variables.
#par
The major restrictions in dealing with quick routines are
as follows.
The display stack command will only show full frames,
i.e., only non-quick routines will show up.
The only way to initially open the scope of a quick routine
will be to enter the debugger while the quick routine is
executing, i.e., single step into it or set a breakpoint
in it.
The parameterless version of the ".OPEN" command can
always be used to reestablish scope.
#endlevel
#endlevel
#sect(Exceptional Condition Handling)
This section describes the implementation of the MDSI Pascal
exceptional condition handling facility.
The implementation is similar to the previous DEC10 and
VAX implementations.
The presentation consists of four major sections.
The first section presents the terminology used throughout
the discussion and defines the data structures used.
The second section gives pseudo-code descriptions of
each of the runtime routines.
The third section describes the data structures and
runtime routine calling sequences generated by the compiler.
Finally, several miscellaneous issues are discussed.
#note(<:This section is a revision of the corresponding section in the
"ANC MicroEclipse Runtime Design Notes".
The references related to user code overlaying have been left in
pending design of an overlay system.:>)
#beginlevel
#sect(Data Structures)
Descriptions of each of the major data structures used by the
exception handling system are given in this section.
#beginlevel
#sect(Exception Blocks)
Exception blocks contain read-only information which is
specific to a subcondition.
For user conditions, subcondition codes and messages are not
meaningful;
the exception block for a given user condition includes all information
relevant to that condition.
In contrast, a standard condition may have many corresponding
exception blocks.
An additional data structure, the condition cell,
contains information about standard conditions which is
invariant for all the corresponding subconditions.
The format of an exception block is shown below;
note that only the first word is present for user
conditions.
$TRA '\' '\'
#beginfigure(16)
 15		       0
+-----------+-----------+
|  cond cell or ^X7FFF	|
+-----------+-----------+
| sub cond||C|   msg len | \
+-----------+-----------+  |
|       text of         |  |
|    error message      |  |-- standard
|           .           |  |   conds only
|           .           |  |
|           .           | /
+-----------+-----------+

C = 0  ==>  may not continue after exception
  = 1  ==>  may continue after exception
#endfigure
For user conditions, the first (and only) word of the exception block
contains the hex constant ^X7FFF.
For standard conditions, the first word contains the
offset from the static area pointer register to the condition cell.
Condition cells are discussed in the next section.
#par
The constant ^X7FFF in an exception block for a user condition serves 
only to distinguish it from standard conditions;
the primary purpose of the existence of an exception block
for a user condition is to provide, via the exception block
address, a unique name for the condition.
#par
Exception blocks for user conditions are allocated in the
same section in which user static data is allocated.
Exception blocks for standard conditions are allocated in the
same section in which the runtime's static data is allocated.
Although exception blocks contain only read only information,
they are allocated in read/write sections in order to
guarantee that their addresses are unique.
Code addresses may not be unique if the code is overlaid.
#note(Reevaluate this decision after an overlay system is specified.)
#sect(Condition Cells)
Condition cells exist for standard conditions only;
they contain information specific to a given condition.
The first longword of the condition cell is always present.
The second longword is present only for maskable conditions.
The format of a condition cell is shown below.
$TRA '\' '\'
#beginfigure(13)
      31		    0
     +-----------+-----------+
     |M|P|  masking count    |
     +-----------+-----------+
     | exception block addr  | -- present for maskable
     +-----------+-----------+    conditions only

     M = 0  ==>  condition is not maskable
       = 1  ==>  condition is maskable

     P = 0  ==>  exception not pending for condition
       = 1  ==>  exception is pending for condition
#endfigure
$TRA '\' ' '
The condition cell address serves as a unique identifier for
standard conditions, much as the exception block address
does for user conditions.
The exception block address is the address of the exception
block for the last signaled exception for the condition;
this address is set when an exception occurs and the
corresponding condition is masked.
#par
Condition cells are allocated in the runtime's static
storage section.
#sect(Handler Branch Tables)
A handler branch table (HBT) is generated by the compiler
for each handler clause in the compilation unit.
They are read-only and are generated in the code area.
The format of a handler branch table is shown below.
#beginfigure(21)
      31       16 15        0
     +-----------+-----------+
     |handler entry code addr|
     +-----------+-----------+
     |  next outer hbt addr  |
     +-----------+-----------+
		 | hsb offset|
		 +-----------+
		 | cond addr |
     +-----------+-----------+
     |    handler address    |
     +-----------+-----------+
     |           .           |
     |           .           |
     |           .           |
     +-----------+-----------+
		 | -1 or -2  |
     +-----------+-----------+
     | handler address or 0  |
     +-----------+-----------+
#endfigure
The first entry in the table is the address of the common
entry code for the handler clause.
The second entry is the address of the HBT for  the next outer handler
clause within the procedure or zero if no outer handler
exists.
The third entry is the offset within the corresponding
stack frame of the handler state block (described in the
next section) for the handler.
Starting with the fourth entry is a list of address pairs.
The first address is an address known as the ^Ucondition address|U.
For standard conditions, the condition address is the (16 bit)
offset of the condition cell from the static area pointer
register.
For user conditions, the condition address is the (16 bit)
offset of the exception block from the static area pointer register.
The second part of the pair is the address of the handler
corresponding to that condition.
The list is terminated by a final pair of fields.
The first field contains a -1 if the handler clause contains
an others handler, a -2 if an allconditions handler is present
and a -1 if neither is present.
The second field contains either the address of the others or
allconditions handler or a 0 if neither was present.
#par
The address of the current handler branch table (or zero if
no handler is current) is stored at offset four from the
frame pointer in the current stack frame.
The compiler emits runtime calls to update this location.
#sect(Handler State Blocks)
Handler state blocks (HSB) are used to contain read/write state information
associated with a given handler clause.
One HSB exists for each handler clause;
the compiler insures that they will be allocated on the stack
as statically-sized temporaries.
The format of a handler state block is shown below.
#beginfigure(7)
      31       16 15        0
     +-----------+-----------+
     |   exception address   |
     +-----------+-----------+
		 ||ovl mod num|
     +-----------+-----------+
     |  exception block addr |
     +-----------+-----------+
#endfigure
The first field of the block contains the address at which the last
exception occurred if the corresponding handler clause is active.
This cell is used by the runtime as a "handler active" flag;
it will be zero if the correspondng handler clause is not active.
The next two fields are meaningful if the first word of
the block is non-zero, i.e., if the corresponding handler
clause is active.
The second field contains the overlay module number of the overlay
in which the exception occured, or, zero if the exception occured
while the runtime was executing.
The final field contains the address of the exception
block corresponding to the condition whose signaling activated
the handler clause.
#sect(The Manager Active Flag)
The manager active flag is a one longword flag maintained by the
runtime to indicate when the exception manager is active.
If the exception manager is active it will contain the 
address of the exception block for the exceptional condition
which was signaled;
otherwise, it will be zero.
The exception block address, rather than a simple boolean, is
used so that the runtime can determine what condition the manager
is handling when an asynchronous interrupt occurs.
#endlevel
#sect(Exception Handling Runtime Routines)
#figure_default(3)
This section describes the exceptional condition handling
runtime routines.
The routines are presented in an informal pseudo-code.
While these descriptions are not necessarily detailed,
they are intended to be complete and accurate at the
given level of presentation.
Thus any details lacking should be clearly a part of an
unelaborated routine used in the pseudo-code descriptions.
#beginlevel
#sect(MASK)
MASK is called with a single parameter - the address of a condition
cell for a standard condition.
#beginfigure(12)
procedure mask ( std_cond );

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = #H3FFFFFFF then begin
    m$fatal ( <ret addr>, 'Masking count overflow' );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count + 1;
  end;
end;
#endfigure
#sect(UNMASK)
The one argument to UNMASK is the address of a condition cell
for a standard condition.
#beginfigure(16)
procedure unmask ( std_cond )

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = 0 then begin
    m$fatal( <ret addr>, 'Improperly nested call to UNMASK' );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count - 1;
    if (std_cond^.masking_count = 0) and
       (std_cond^.pending) then begin
      std_cond^.pending := false;
      except_mgr ( std_cond^.exc_block, <unmask ret addr> );
    end;
  end;
end;
#endfigure
#sect(MASKED)
The one parameter to MASKED is the address of a condition cell for
a standard condition.
#beginfigure(6)
function masked ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  masked := (std_cond^.masking_count > 0);
end;
#endfigure
#sect(PENDING)
The one parameter to PENDING is the address of the condition
cell for a standard condition.
#beginfigure(8)
function pending ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  assert ( not ( (std_cond^.pending ) and 
		 (std_cond^.masking_count = 0) ) );
  pending := std_cond^.pending;
  std_cond^.pending := false;
end;
#endfigure
#sect(EXCEPTION_MESSAGE)
The pseudo-code description of EXCEPTION_MESSAGE is at
a somewhat higher level than the descriptions given earlier.
In particular, the first action described is a search of the
stack for the topmost active handler.
This search procedure must be executed from several places in
the runtime and will be a separate routine.
The outline of the search is straightforward;
the handler branch table pointer in each
stack frame is used to find the current innermost handler branch
table.
The handler branch table contains the offset of the corresponding
handler state block.
A handler is active if the exception address field of the handler
state block is non-zero.
The outer HBT address field of the handler branch table is
followed when the current handler is not active.
If the outer HBT address is zero, then the dynamic link
is followed and the procedure is repeated for the next stack 
frame.
#par
The presence of overlays will complicate this process 
since handler branch tables are generated in the code area.
The runtime must load overlays as it follows the dynamic
chain down the stack and must restore the caller's overlay
before returning.
The algorithm for determining the overlay module number
corresponding to a stack frame is discussed in the
section on debugging aids and will not be described 
here.
#beginfigure(15)
procedure exception_message;

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    M$FATAL( <ret addr>,
	     'Exc msg called with no handler active' );
  end 
  else begin
    if hsb^.exc_block^.cond_cell = ^X7FFF
      then writeln ( tty, 'User signaled condition' )
      else writeln ( tty, hsb^.exc_block^.message );
    write ( tty, 'Overlay:', hsb^.ovl_mod_num );
    writeln ( tty, '   PC:', hsb^.exc_addr:8:H );
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(The Status Routines)
The status routines are all parameterless functions which return
a subcondition code for a standard condition.
The pseudo-code description of the MATH_STATUS routine is
given below.
The other status routines are almost identical (in fact they
may be implemented as multiple entry points to a common 
routine).
#beginfigure(16)
function mathstatus: math_status;

begin
  mathstatus := 0;
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    M$FATAL ( <ret addr>, 'Error - no handler active' );
  end
  else begin
    if hsb^.exc_block^.cond_cell = math_error_cond_cell
      then mathstatus := hsb^.exc_block^.sub_cond
      else M$FATAL ( <ret addr>,
		     'Top handler not for math error' );
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(SIGNAL)
This section describes the routine for signaling a user
condition.
The one parameter to the routine is the address of the
exception block for the user condition.
The exception manager runtime routine, EXCEPT_MGR, is 
described in a later section.
#beginfigure(5)
procedure signal ( user_cond );

begin
  except_mgr ( user_cond, <signal return address> )
end;
#endfigure
#sect(Resignal)
This section describes the parameterless version of SIGNAL,
i.e., the routine for resignaling the last signaled condition.
#beginfigure(14)
procedure signal();

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    m$fatal( <ret addr>, 'Resignal with no active handler' );
  end
  else begin
    with hsb^.exc_block^ do begin
      masked := (cond_cell <> ^X7FFF) andif
                (cond_cell^.maskable) andif
                (cond_cell^.masking_count <> 0);
      if masked then begin
        cond_cell^.pending := true;
        cond_cell^.exc_block := hsb^.exc_block;
      end
      else except_mgr ( hsb^.exc_block, hsb^.exc_addr );
    end  (* with *) ;
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(Establish A Handler)
This section describes the runtime routine for establishing
a new handler.
The compiler emits calls to this routine whenever the
scope of a handler is first entered.
The one parameter to the routine is an handler branch table
address.
#beginfigure(7)
procedure set_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
  hsb := frame_pointer + hbt_addr^.hsb_offset;
  hsb^.exc_addr := 0;         (* flag handler inactive *)
end;
#endfigure
#sect(Restore A Handler)
This section describes the runtime routine for reestablishing
a handler when the scope of the handler is reentered.
The compiler emits calls to this routine whenever
necessary.
"Reestablishing" a handler may include calling this
routine with a parameter of zero when leaving the scope of a handler
and entering a block of code which is not in the scope of a handler.
The one parameter to the routine is an handler branch table
address.
#beginfigure(5)
procedure reestablish_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
end;
#endfigure
#sect(Nonmaskable Exception Intercept Routines)
This section describes the runtime routines which intercept
nonmaskable standard conditions, e.g., floating overflow.
The pseudo-code below is based on several assumptions.
First, the address of the instruction causing the exception,
or of the instruction following the exception, is assumed
to be passed to the intercept routine (generally by the
operating system).
The assertion that the exception manager is not active is
based on the assumption that nonmaskable exceptions
occuring when the exception manager is active may be
considered to be bugs in the runtime and that generation
of a fatal error is appropriate.
Finally, the intercept routines are specific to a subcondition
of a given standard condition and thus the appropriate exception
block address is available to the intercept routine.
#beginfigure(7)
procedure nonmaskable_intercept ( exc_addr );

begin
  assert ( mgr_active = 0 );
  mgr_active := exc_block_addr;
  except_mgr ( exc_block_addr, exc_addr );
end;
#endfigure
#sect(Maskable Exception Intercept Routines)
The only maskable condition will be attention;
thus this section describes the intercept routine
for attention.
Currently, the specifics of the attention handling facilities
provided by OZMOS are unknown.
For now, we assume that attentions may be intercepted and
that further attentions are ignored or delayed until attention
interception is reenabled.
#note(Update for VERSAdos)
The stack search procedure referenced in the pseudo-code below
is different from previous active handler search routines in
that it does not necessarily stop at the first active handler.
The routine will search until either a handler is found which
is active for an attention or until the entire stack has
been searched.
Note that the "ATTN_INTERCEPT_ACTIVE" variable referred to is
a static variable.
#par 
#beginfigure(10)
procedure attention_intercept ( exc_addr );
 
begin
  if attn_intercept_active then begin
    reenable attentions;
    return;
  end;
  attn_intercept_active := true;
  reenable attentions;

  mgr_active_for_attn := mgr_active = attn_exc_block;
  if not mgr_active_for_attn
    then found := search_for_handler_active_for_attn;

  if mgr_active_for_attn orif found then begin  (* ignore *)
    attn_intercept_active := false;
    return;
  end
  else if (mgr_active <> 0) or		(* pend *)
          (attn_cond_cell.masking_count > 0) then begin
    attn_cond_cell.pending := true;
    attn_cond_cell.exc_block := attn_exc_block;
    attn_intercept_active := false;
    return;
  end
  else begin                          (* signal *)
    mgr_active := attn_exc_block;
    attn_intercept_active := false;
    except_mgr ( attn_exc_block, exc_addr );
  end;
end;
#endfigure
#sect(The Exception Manager)
The exception manager is the central runtime routine
called by all the intercept routines.
It has two parameters,
the exception block address for the condition being signaled
and the address associated with the exception.
#par
Note that the common entry code for a handler clause is branched
 to with the specific handler address on top of the stack.
#beginfigure(7)
procedure except_mgr ( exc_block, exc_addr );

begin
  find the topmost inactive handler for either the
    signaled condition or allconditions.
    set FOUND equal to true if such a handler is
    found and to false otherwise.
    As the search proceeds, set variable HBT to
    the handler branch table for the first hbt
    found for the signaled condition or others
    or allconditions.
  if found then begin
    unwind any frames above one corresponding to hbt;
    frame_pointer^.hbt_addr := hbt;
    hsb := handler state block corresponding to HBT;
    if exc_addr is in the runtime
      then hsb^.ovl_mod_num := nil_ovl_mod_num
    else if not called by resignal
      then hsb^.ovl_mod_num := current_overlay_mod_num;
    hsb^.exc_addr := exc_addr;
    hsb^.exc_block := exc_block;
    if (attn_cond_cell^.pending) and
       (attn_cond_cell^.masking_count = 0) then begin
      exc_block := attn_exc_block;
      exc_addr := <label 100>;
      attn_cond_cell^.pending := false;
      goto except_mgr;
    end;
100:
    mgr_active := 0;
    push handler address onto stack;
    goto handler common entry code;
  end
  else begin
    if exc_block^.cond_cell = ^X7FFF
      then writeln ( tty, 'Unhandled user condition' )
      else writeln ( tty, exc_block^.message );
    exit;
  end;
end;
#endfigure
#endlevel
#figure_pop
#sect(Compiler Interface)
The data structures and runtime calls which the compiler
must generate are described in this section.
#beginlevel
#sect(Data Structures Generated)
The compiler must generate and completely initialize the
handler branch table corresponding to each handler clause in
the compilation unit.
For standard conditions, the condition address field
is initialized to the value of an external symbol.
The names of these symbols are given in the final section on
miscellaneous topics.
The HBT is generated in the code area.
#par
The compiler must allocate stack space for, but need not
initialize, the handler state block corresponding to each
handler clause.
#par
For each user condition, the compiler must emit an exception
block in the static area.
The exception blocks must be initialized with  
the constant ^X7FFF.
Public user conditions must also have a global definition emitted
which defines the value of the symbol to be the 
offset from the static area pointer register to
the exception block.
#sect(Runtime Routine Calls Generated)
This section describes the interface to the exception handling
runtime routines which are called from compiler generated code.
The input arguments listed are pushed onto the stack before the
call.
The output arguments are left on top of the stack when the routine
returns.
#define(#rt_name,id,&
#item("#upc(id))
#literal(#emit_input,1)&
#literal(#emit_output,1))

#define(#call,name,&
$PAR -7  $VER
CALL:\\JSR\\\\\#upc(name)
$JUS)

#define(#input,label,desc,&
#if("#eqc("#emit_input,1),&
$ski   $par -7  $need 2
INPUTS:
#assign(#emit_input,0))&
$par -5
label:\\desc)

#define(#output,label,desc,&
#if("eqc("#emit_output,1),&
$ski  $par -7  $need 2
OUTPUTS:
#assign(#emit_output,0))&
$PAR -5
label:\\desc)
#beginitem(12,3)
#rt_name(MASK)
#call(e.mask)
#input(1.,Condition cell address)
#rt_name(UNMASK)
#call(e.unmask)
#input(1.,Condition cell address)
#rt_name(MASKED)
#call(e.mskd)
#input(1.,Condition cell address)
#output(1.,boolean return value)
#rt_name(PENDING)
#call(e.pend)
#input(1.,Condition cell address)
#output(1.,boolean return value)
#rt_name(EXCEPTION_MESSAGE)
#call(e.msg)
#rt_name(MATHSTATUS)
#call(e.mathst)
#output(1.,Value of enumerated type MATH_STATUS.)
#rt_name(EXIOSTATUS)
#call(e.iost)
#output(1.,Value of enumeraed type IO_STATUS.)
#rt_name(PROGRAMSTATUS)
#call(e.progst)
#output(1.,Value of enumerated type PROGRAM_STATUS.)
#rt_name(SPECIALSTATUS)
#call(e.spcst)
#output(1.,Value of enumerated type SPECIAL_STATUS.)
#rt_name(SIGNAL(<user condition>))
#call(e.signal)
#input(1.,User exception block address.)
#rt_name(SIGNAL())
#call(e.resig)
#rt_name(Establish A Handler)
#call(e.hset)
#input(1.,Handler branch table address)
#rt_name(Restore A Handler)
#call(e.hrest)
#input(1.,Handler branch table address or zero)
#rt_name(Signaling Program Errors)
$SKI
$ind -7
The specific entry point names for signalling program errors
(i.e., CHECK option errors) are given in the next section.
$ind +7
$SKI
#call(<error specific entry point>)
#enditem
#endlevel
#sect(Miscellaneous)
This section discusses several miscellaneous issues concerning
exceptional condition handling.
#beginlevel
#sect(Link Management Interaction)
#note(<:This section must be rethought after a link management scheme
is designed.:>)
The information required by the exception handling system
is either passed to the runtime directly or is found
via pointers in the stack;
thus the link management system has virtually no impact on
the exception handling system.
The standard restrictions on PUBLIC declarations do apply, however.
PUBLIC conditions may only be defined in MAIN, i.e., outside
of LINKs.
Like public variables, public conditions referenced from a LINK
must be declared in the transfer vector and the compiler must
access them with an extra level of indirection.
#sect(Compiler Options)
The compiler options to control underflow handling and attention
masking will be implemented.
#note(Some global symbol names are needed for the compiler
to pass the request on to the runtime.)
#sect(Status Enumerated Types)
Initially, the enumerated status types will be identical to those
of the VAX implementation.
Additional values will be added at the end of the enumeration
lists if necessary.
#sect(Standard Condition Cell Names)
The external symbol names by which the compiler may refer to
standard condition cells are given below.
The compiler uses these symbols in initializing handler
branch tables and in calls to MASK, UNMASK, MASKED and PENDING.
#beginfigure(7)
MATH_ERROR		E.CMATH
IO_ERROR		E.CIO
PROGRAM_ERROR		E.CPROG
ATTENTION		E.CATTN
STORAGE_OVERFLOW	E.CHEAP
STACK_OVERFLOW		E.CSTACK
SPECIAL_ERROR		E.CSPEC
#endfigure
#sect(Program Error Entry Points)
The following are the entry point names for each of the possible
subconditions of the standard condition PROGRAM_ERROR.
#beginfigure(8)
PROGRAM_ASSERTION	E.ASSERT
PROGRAM_CASE		E.CASE
PROGRAM_COMPATIBILITY	E.COMPAT
PROGRAM_FILE		E.FILE
PROGRAM_POINTER		E.PTR
PROGRAM_SUBSTRING	E.SUBSTR
PROGRAM_SUBSCRIPT	E.INDEX
PROGRAM_VALUE		E.VALUE
#endfigure
#endlevel
#endlevel
#sect(Program Initialization And Termination)
This section describes the initial format of certain runtime data
structures, e.g., the initial stack, and also describes the functions
performed by the runtime initialization and termination routines.
#beginlevel
#sect(The Initial Stack)
The code which should appear at the entry point for
the main routine is identical to that which would appear at
the entry point for a level one, parameterless procedure.
The runtime will define the runtime initialization
routine, "M.INIT", as the start address of the program.
The compiler must emit a global definition of the symbol "M.START",
where the value of the symbol is the entry point of the main routine.
#par
M.INIT will allocate an initial frame, logically below
that of the main routine, which corresponds to
the initialization routine.
The return address through old frame pointer fields will
all be present and will all be permanently zero.
M.INIT will then call the main routine with a JSR instruction.
When the main routine is called, A6 will be pointing to the
old frame pointer field of the initialization routine's frame.
After the standard entry code is executed at the beginning
of the main routine, the entire stack appears as follows:
#beginfigure(23)
	+-----------------------+	 ^
	|			|	 |
	|      main's temps	|	 |
	+-----------------------+ lower addresses
    +---|       old A6		|<---A6
    |	+-----------------------+
    |   |  HBT address  (0)     |  4(A6)
    |   +-----------------------+
    |   |   proc block address  |  8(A6)
    |	+-----------------------+
    |   |  old SP offset  (20)  | 12(A6)
    |	+-----------------------+
    |   |  return address	| 16(A6)
    |   +-----------------------+
    +-->|	   0		|
	+-----------------------+
	|	   0		|
	+-----------------------+
	|	   0		|
	+-----------------------+
	|	   0		|
	+-----------------------+
	|	   0		|
	+-----------------------+
#endfigure
The old frame pointer field of main's frame points to the
frame of the intialization routine.
The handler branch table address field is initially zero but may
change if a handler clause is declared in the main routine.
The procedure block address points to a valid procedure block
if the TRACE option is enabled and is zero otherwise.
The old SP offset field contains the offset from main's old
frame pointer field to the old frame pointer field of
the initial frame.
The return address field points to the instruction following
the instruction of M.INIT which calls the main routine.
Main's frame is distinguished by the fact that its old
frame pointer value points to a location containing zero.
#sect(The Initial Heap)
#par
Static heap variables H.ROVER and H.CURSEG (described
below) are initialized as follows:
#par(1,5)
H.ROVER <-- H.HEAPBASE + 16
#par(0,5)
H.CURSEG <-- H.HEAPBASE
#par
The heap (starting at H.HEAPBASE) is initialized as follows:
#par(0,5)
0(H.HEAPBASE) <-- H.HEAPBASE     ; next seg addr (points to itself)
#par(0,5)
4(H.HEAPBASE) <-- H.INISIZ       ; this segment size
#par(0,5)
8(H.HEAPBASE) <-- H.HEAPBASE + 16   ; the first free block
#par(0,5)
12(H.HEAPBASE) <-- "H."00   ; segment name
#par(0,5)
16(H.HEAPBASE) <-- segment size - 16     ; low order bit  = 0
#par(0,5)
20(H.HEAPBASE) <-- H.HEAPBASE + 16  ; BLINK
#par(0,5)
24(H.HEAPBASE) <-- H.HEAPBASE + 16  ; FLINK
#sect(The Initialization Routine)
The program initialization runtime routine must perform the following
actions:
#beginitem(3)
#item()Open the program's image file and determine the size
of the static storage area.
#item()Create the initial data segment.
#item()Set A5 to point to the base of the initial data
segment plus 32768.
#item()Initialize A6, SP, the static cell M.STKEND, and the 
initial stack frame.
#item()Load the initial static storage contents from the image file.
#item()Initialize the state information for the initial heap.
#item()Initiate interception of the standard conditions.
#item()Call the main routine.
#enditem

#sect(The Termination Routine)
The termination routine should be called once at the end of
the main routine.
It requires no parameters; 
its name is "M.STOP".
A call to this routine is also generated for the Pascal
STOP
statement.
#endlevel
#sect(Math Routines)
#sect(Heap Management )
Dynamic memory allocation is controlled via routines NEW and DISPOSE
(described below) and the static heap variables
H.ROVER and H.CURSEG (also described below).
The basic idea is as follows:
#par
Initially, one segment is allocated as free space for the heap.  
There is a free chain, connecting the blocks of available
memory within that segment.  If more heap storage is 
requested than can be supplied within that segment, an 
additional segment is allocated, and a free chain is
also maintained in that segment.
#par
The first word of every segment contains the address
of the first word in the next segment on the free chain.
If the heap completely resides in the initial
segment allocated, this word contains its own address.
The free
chain does not skip around in different segments, except 
through this header.  Within a given segment, free chain entries are 
doubly, circularly linked.
#par
The second word of each segment contains the segment size.
#par
The third word in each segment is a pointer to an arbitrary node
on the free chain in the segment.  This is useful
in connection with routine DISPOSE, described below.
#par
The fourth word in each segment is the segment name, 
which is a four byte entity consisting of the
ASCII characters "H." followed by two hex digits.
#par
All memory blocks, whether free or used have the following 
two fields:
#beginitem(2)
#item()Length (in bytes) of the block.  Since all blocks are to 
be word aligned, it follows that the length of each block should
be an even number, allowing the second field,
#item()Free/used flag, in the low order bit of the length field.
0 = free; 1 = allocated.
#enditem
#par
Free blocks also have another two words of control
information:
#beginitem(2)
#item()FLINK -- pointer to the next free block in this segment.
#item()BLINK -- pointer to the previous free block in this segment.
#enditem
#par
FLINK and BLINK are actual addresses -- not offsets from the 
start of the segment.
#par
The static storage requirements are as follows:
#par(1,5)
1)  H.ROVER   (4 bytes)
#par(0,9)
A pointer that is actually an address to an 
arbitrary entry on the free chain.
#par(1,5)
2)  H.CURSEG   (4 bytes)
#par(0,9)
Pointer to the beginning of the segment that
H.ROVER is in at any given time.
#beginlevel
#sect(NEW -- routine to allocate a storage block)
Input -- block size requested
#par(0)
Output -- the address of a sufficiently large block is 
returned on top of the stack.
#par
Calling sequence:
#par(0,5)
MOVE.L\\\\SIZE,-(SP)
#par(0,5)
JSR\\\\\\\H.NEW      ; from PASCAL code ... or 
#par(0,5)
JSR\\\\\\\H.INEW     ; from other runtime routines
#par
Algorithm -- start at current position of H.ROVER (which is 
in segment starting at H.CURSEG).  Walk through the free chain in this
segment via FLINKs, until either a large enough block has been found, 
or we reach our starting point (H.ROVER) which indicates that 
we'll have to look in another segment; if all segments are searched
without satisfaction, allocate another segment.
#par
After allocation, leave H.ROVER pointing to an 
entry on the free chain.  If there are no entries
left on the free chain (in any segment) set a flag
(e.g. H.ROVER\<--\\0) to indicate that a new 
segment must be allocated at the next call to NEW.
#par
During the traversal of the free chain, try to collapse contiguous
memory blocks, by examining the free/used_flag@[addr(free_node)+size(free_node)]
to determine if the next block of contiguous physical memory
(has nothing to do with BLINKs and FLINKs) is also on the free
chain.  If so, collapse into a single free chain entry.  
Do this recursively, so that if there are several contiguous
free blocks they will all be coalesced at once.  Fix FLINKs 
and BLINKs appropriately, one at a time.
#par
Possible error conditions:
#par(0,5)
1)  Requested size > available size
#par(0,5)
2)  Requested size <= 0
#sect(DISPOSE -- liberate a block)
Input -- address of block to be liberated
#par(0)
Output -- None
#par
Calling sequence:
#par(0,5)
MOVE.L\\\\BLKADDR,-(SP)
#par(0,5)
JSR\\\\\\\H.DISPOSE\\\\\\; from PASCAL code ... or
#par(0,5)
JSR\\\\\\\H.IDISPOSE\\\\\; from other runtime routines
#par
Algorithm -- Walk through the segment links (i.e. the links in
the first word of each segment, starting at H.HEAPBASE) to determine which
segment the block to be freed is in.  If the address
supplied is not of an allocated block, signal an error and
return.  Otherwise, set H.ROVER\<--\freed\block\addr;
H.CURSEG\<--\seg\addr\of\H.ROVER.
#par
Now we're at the block to be disposed.  Play the same
recursive arithmetic game as on NEW, to determine 
if contiguous blocks are to be coalesced.
#beginfigure(6)
     e.g.  X := SIZE@ROVER + ROVER
           IF FREE@X THEN
             FLINK@BLINK@X := FLINK@X
             BLINK@FLINK@X := BLINK@X
             SIZE@ROVER  := SIZE@ROVER + SIZE@X
           ENDIF  (* coalesces free blocks *)
#endfigure
#par
If, on the other hand, the next physical block is not free, then
link this block into the free chain at a place indicated by the 
third word in the segment header.  (That is the only purpose 
this word serves.)
#par
Having done all that, start at the first physical block in the
segment (begins at the fifth word) and, if it is free, 
play the same collapsing game with contiguous
blocks.  If it turns out that the entire segment
is free, (and it is not the initial segment) delete it from the segment
list, and return the segment to the operating system.
Once again, find a home for H.ROVER in some
other segment, and update H.CURSEG accordingly.
#par
Possible error condition:
#par(0,5)
Given address points to block not currently allocated.
#endlevel
#sect(Environmental Routines)
#sect(Miscellaneous Routines)
#beginlevel
#sect(I4MULT -- four byte signed integer multiplication)
This routine accepts two 32 bit multiplicands and returns
a 32 bit product.  Both input parameters are passed on
the stack, and the return value is left on the stack at
the routine return.
#par
Calling sequence:
#par(0,5)
MOVE.L\\\\MULTIPLICAND1,-(SP)
#par(0,5)
MOVE.L\\\\MULTIPLICAND2,-(SP)
#PAR(0,5)
JSR\\\\\\\G.I4MULT
#par
Possible error condition:
#par(0,5)
Integer overflow -- either positive or negative.
#sect(I4DIV -- four byte signed integer division)
This routine accepts a 32 dividend and a 32 bit divisor,
and returns either a 32 bit quotient or a 32 bit remainder.
There are two entry points, G.I4DIV, for returning 
the quotient, and G.I4REM, for returning the remainder.
Both input parameters are passed on the stack, and
the return value is left on the stack at routine
return.
#par
Calling sequence:
#par(0,5)
MOVE.L\\\\DIVIDEND,-(SP)
#par(0,5)
MOVE.L\\\\DIVISOR,-(SP)
#par(0,5)
JSR\\\\\\\G.I4DIV\\\(*\for\four\byte\quotient\\*)\\...or...
#par(0,5)
JSR\\\\\\\G.I4REM\\\(*\for\four\byte\remainder\*)
#par
Possible error condition:
#par(0,5)
Division by zero.
#endlevel
#sect(String Routines)
#sect(Set Routines)
#toc
$ski 3
(pasdev4)m68run.pmf
Ajr