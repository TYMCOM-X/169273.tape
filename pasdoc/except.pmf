#document(AEV Runtime - Exceptions Section,<:July 15, 1981:>)
This section describes the implementation of the MDSI Pascal
exceptional condition handling facility.
The implementaion is similar to the previous DEC10 and
VAX implementations.
The presentation consists of four major sections.
The first section presents the terminology used throughout
the discussion and defines the data structures used.
The second section gives pseudo-code descriptions of
each of the runtime routines.
The third section describes the data structures and
runtime routine calling sequences generated by the compiler.
Finally, several miscellaneous issues are discussed.
#beginlevel
#sect(Data Structures)
#beginlevel
#sect(Exception Blocks)
Exception blocks contain read-only information which is
specific to a subcondition.
For user conditions, subcondition codes and messages are not
meaningful;
the exception block for a given user condition includes all information
relevant to that condition.
In contrast, a standard condition may have many corresponding
exception blocks.
An additional data structure, the condition cell,
contains information about standard conditions which is
invariant for all the corresponding subconditions.
The format of an exception block is shown below;
note that only the first two words are present for user
conditions.
$TRA '\' '\'
#beginfigure(16)
    +-----------+-----------+
     | cond cell or except   |
     + - - - - - - - - - - - +
     |     block address     |
     +-----------+-----------+
     |  sub cond |C| msg len | \
   +-----------+-----------+  |
  |       text of         |  |
  |    error message      |  |-- standard
       |           .           |  |   conds only
     |           .           |  |
  |           .           | /
   +-----------+-----------+

   C = 0  ==>  may not continue after exception
          = 1  ==>  may continue after exception
#endfigure
$TRA '\' ' '
For user conditions, the first two words contain the (virtual)
address of the exception block, i.e., just the address
of the first word.
For standard conditions a condition cell exists and the (virtual)
condition cell address is contained in the first two words.
Note that user and standard exception blocks may be distinguished
by determining if the first two words contain their own
virtual address.
#par
The information in an exception block for a user condition serves 
only to distinguish it from standard conditions;
the primary purpose of the existance of an exception block
for a user condition is to provide, via the exception block
address, a unique name for the condition.
#par
Exception blocks for user conditions are allocated in the
virtual static segment.
We are assuming that user conditions are really used for
'exceptional' conditions and thus the exception blocks
will be accessed infrequently.
Exception blocks for standard conditions are also 
allocated in a virtual segment.
Whether this will be the virtual static segment or a special
runtime virtual storage segment has not yet been determined.
User exception blocks are 32 bit values; the code generator
and linker must guarantee that they are 32 bit aligned and
thus will not cross page boundaries.
The implementors of the runtime must guarantee that exception
blocks for standard conditions do not cross page boundaries.
#sect(Condition Cells)
Condition cells exist for standard conditions only;
they contain information specific to a given condition.
The first word of the condition cell is always present.
Words two and three are present only for maskable conditions.
The format of a condition cell is shown below.
$TRA '\' '\'
#beginfigure(13)
     +-----------+-----------+
     |M|P|  masking count    |
     +-----------+-----------+
     | exception block addr  | \
   + - - - - - - - - - - - +  |--present for maskable
    |for last signalled cond|  /  conditions only
 +-----------+-----------+

   M = 0  ==>  condition is not maskable
          = 1  ==>  condition is maskable

        P = 0  ==>  exception not pending for condition
          = 1  ==>  exception is pending for condition
#endfigure
$TRA '\' ' '
The condition cell address serves as a unique identifier for
standard conditions, much as the exception block address
does for user conditions.
#par
Like exception blocks, condition cells are allocated
in a virtual segment.
The implementors of the runtime must guarantee that
condition cells do not cross page boundaries in the
segment.
#sect(Handler Branch Tables)
A handler branch table (HBT) is generated by the compiler
for each handler clause in the compilation unit.
They are read-only and are generated in the code area.
The format of a handler branch table is shown below.
#beginfigure(21)
    +-----------+-----------+
     |handler entry code addr|
     +-----------+-----------+
     |next outer handler addr|
     +-----------+-----------+
     | hsb stack frame offset|
     +-----------+-----------+
     |   exception block or  |
     + - - - - - - - - - - - +
     | condition cell address|
     +-----------+-----------+
     |    handler address    |
     +-----------+-----------+
     |           .           |
     |           .           |
     |           .           |
     +-----------+-----------+
     | -1(others) or -2(all) |
     +-----------+-----------+
     | handler address or 0  |
     +-----------+-----------+
#endfigure
The first word of the table is the address of the common
entry code for the handler clause.
The second word is the address of the next outer handler
clause within the procedure or zero in no outer handler
exists.
The third word is the offset within the corresponding
stack frame of the handler state block (described in the
next section) for the handler.
Starting with the fourth word is a list of address pairs.
The first address  is a 32 bit virtual address of the
corresponding exception block for user conditions or the
condition cell for standard conditions.
The list is terminated by a two word pair.
The first word contains a -1 if the handler clause contains
an others handler, a -2 if an allconditions handler is present
and a -1 if neither is present.
The second word contains either the address of the others or
allconditions handler or a 0 if neither was present.
#par
The address of the current handler branch table (or zero if
no handler is current) is stored at offset two from the
frame pointer in the current stack frame.
The compiler emits runtime calls to update this location.
#sect(Handler State Blocks)
Handler state blocks (HSB) are used to contain read/write state information
associated with a given handler clause.
One HSB exists for each handler clause;
the compiler insures that they will be allocated on the stack
as statically-sized temporaries.
The format of a handler state block is shown below.
#beginfigure(7)
      +-----------+-----------+
     |   exception address   |
     +-----------+-----------+
     |     exception block   |
     + - - - - - - - - - - - +
     |        address        |
     +-----------+-----------+
#endfigure
The first word of the block contains the address at which the last
exception occurred if the corresponding handler clause is active.
This cell is used by the runtime as a "handler active" flag;
it will be zero if the correspondng handler clause is not active.
The exception block address is meaningful if the first word of
the block is non-zero, i.e., if the corresponding handler
clause is active.
It contains the (virtual) address of the exception
block corresponding to the condition whose signalling activated
the handler clause.
#sect(The Manager Active Flag)
The manager active flag is a two word flag maintained by the
runtime to indicate when the exception manager is active.
If the exception manager is active it will contain the (virtual)
address of the exception block for the exceptional condition
which was signalled;
otherwise, it will be zero.
The exception block address, rather than a simple boolean, is
used so that the runtime can determine what condition the manager
is handling when an asynchronous interrupt occurs.
#endlevel
#sect(Exception Handling Runtime Routines)
#figure_default(3)
This section describes the exceptional condition handling
runtime routines.
The routines are presented in an informal pseudo-code.
While these descriptions are not necessarily detailed,
they are intended to be complete and accurate at the
given level of presentation.
Thus any details lacking should be clearly a part of an
unelaborated routine used in the pseudo-code descriptions.
#beginlevel
#sect(MASK)
MASK is called with a single parameter - the address of a condition
cell for a standard condition.
#beginfigure(12)
procedure mask ( std_cond );

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = #O37777 then begin
    writeln ( tty, 'Masking count overflow' );
    call debugger ( <mask return address> );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count + 1;
  end;
end;
#endfigure
#sect(UNMASK)
The one argument to UNMASK is the address of a condition cell
for a standard condition.
#beginfigure(16)
procedure unmask ( std_cond )

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = 0 then begin
    writeln ( tty, 'Improperly nested call to UNMASK.' );
    call debugger ( <unmask ret addr> );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count - 1;
    if (std_cond^.masking_count = 0 ) and
       (std_cond^.pending) then begin
      std_cond^.pending := false;
      except_mgr ( std_cond^.exc_block, <unmask ret addr> );
    end;
  end;
end;
#endfigure
#sect(MASKED)
The one parameter to MASKED is the address of a condition cell for
a standard condition.
#beginfigure(6)
function masked ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  masked := (std_cond^.masking_count > 0);
end;
#endfigure
#sect(PENDING)
The one parameter to PENDING is the address of the condition
cell for a standard condition.
#beginfigure(8)
function pending ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  assert ( not ( (std_cond^.pending ) and 
            (std_cond^.masking_count = 0) );
  pending := std_cond^.pending;
  std_cond^.pending := false;
end;
#endfigure
#sect(EXCEPTION_MESSAGE)
The pseudo-code description of EXCEPTION_MESSAGE is at
a somewhat higher level than the descriptions given earlier.
In particular, the first action described is a search of the
stack for the topmost active handler.
This seach procedure must be executed from several places in
the runtime and will be a separate routine.
The outline of the search is straightforward;
the handler branch table pointer at offset two in each
stack frame is used to find the current innermost handler branch
table.
The handler branch table contains the offset of the corresponding
handler state block.
A handler is active if the exception address field of the handler
state block is non-zero.
The outer handler address field of the handler branch table is
followed when the current handler is not active.
If the outer handler address is zero, then the dynamic link
is followed and the procedure is repeated for the next stack 
frame.
The presence of overlays will complicate this procedure 
since handler branch tables are generated in the code area.
The runtime must load overlays as it follows the dynamic
chain down the stack and must restore the caller's overlay
before returning.
The algorithm for determining the overlay module number
corresponding to a stack frame is discussed in the
section on debugging aids and will not be described 
here.
#beginfigure(15)
procedure exception_message;

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    writeln( tty, 'Exc msg called with no handler active' );
  end 
  else begin
    if hsb^.exc_block^.cond_cell = hsb^.exc_block
      then writeln ( tty, 'User signalled condition' )
      else writeln ( tty, hsb^.exc_block^.message );
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(The Status Routines)
The status routines are all parameterless functions which return
a subcondition code for a standard condition.
The pseudo-code description of the MATH_STATUS routine is
given below.
The other status routines are almost identical (in fact they
may be implemented as multiple entry points to a common 
routine).
#beginfigure(16)
function mathstatus: math_status;

begin
  mathstatus := 0;
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    writeln ( tty, 'Error - no handler active' );
  end
  else begin
    if hsb^.exc_block^.cond_cell = math_error_cond_cell
      then mathstatus := hsb^.exc_block^.sub_cond
      else writeln ( tty, 'Top handler not for math error' );
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(SIGNAL)
This section describes the routine for signalling a user
condition.
The one parameter to the routine is the address of the
exception block for the user condition.
The exception manager runtime routine, EXCEPT_MGR, is 
described in a later section.
#beginfigure(5)
procedure signal ( user_cond );

begin
  except_mgr ( user_cond, <signal return address> )
end;
#endfigure
#sect(Resignal)
This section describes the parameterless version of SIGNAL,
i.e., the routine for resignalling the last signalled condition.
#beginfigure(14)
procedure signal();

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    writeln ( tty, 'Resignal with no active handler' );
    call debugger ( <signal return address> );
  end
  else begin
    except_mgr ( hsb^.exc_block, hsb^.exc_addr );
  end;
  load_overlay ( top_ovl_mod_num );
end;
#endfigure
#sect(Establish A Handler)
This section describes the runtime routine for establishing
a new handler.
The compiler emits calls to this routine whenever the
scope of a handler is first entered.
The one parameter to the routine is an handler branch table
address.
#beginfigure(7)
procedure set_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
  hsb := frame_pointer + hbt_addr^.hsb_offset;
  hsb^.exc_addr := 0;         (* flag handler inactive *)
end;
#endfigure
#sect(Restore A Handler)
This section describes the runtime routine for reestablishing
a handler when the scope of the handler is reentered.
The compiler emits calls to this routine whenever
necessary.
The one parameter to the routine is an handler branch table
address.
#beginfigure(5)
procedure reestablish_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
end;
#endfigure
#sect(Nonmaskable Exception Intercept Routines)
This section describes the runtime routines which intercept
nonmaskable standard conditions, e.g., floating overflow.
The pseudo-code below is based on several assumptions.
First, the address of the instruction causing the exception,
or of the instruction following the exception, is assumed
to be passed to the intercept routine (generally by the
operating system).
The assertion that the exception manager is not active is
based on the assumption that nonmaskable exceptions
occuring when the exception manager is active may be
considered as bugs in the runtime and that generation
of a fatal error is appropriate.
Finally, the intercept routines are specific to a subcondition
of a given standard condition and thus the appropriate exception
block address is available to the intercept routine.
#beginfigure(7)
procedure nonmaskable_intercept ( exc_addr );

begin
  assert ( mgr_active );
  mgr_active := exc_block_addr;
  except_mgr ( exc_block_addr, exc_addr );
end;
#endfigure
#sect(Maskable Exception Intercept Routines)
The only maskable condition will be attention;
thus this section describes the intercept routine
for attention.
Currently, the specifics of the attention handling facilities
provided by OZMOS are unknown.
For now, we assume that attentions may be intercepted and
that further attentions are ignored until attention
interception is reenabled.
The stack search procedure referenced in the pseudo-code below
is different from previous active handler search routines in
that it does not necessarily stop at the first active handler.
The routine will search until either a handler is found which
is active for an attention or until the entire stack has
been searched.
Note that the "ATTN_INTERCEPT_ACTIVE" variable referred to is
a static variable.
#beginfigure(10)
procedure attention_intercept ( exc_addr );
 
begin
  if attn_intercept_active then begin
    reenable attentions;
    return;
  end;
  attn_intercept_active := true;
  reenable attentions;

  mgr_active_for_attn := mgr_active = attn_exc_block;
  if not mgr_active_for_attn
    then found := search_for_handler_active_for_attn;

  if mgr_active_for_attn orif found then begin  (* ignore *)
    attn_intercept_active := false;
    return;
  end
  else if mgr_active <> 0 then begin        (* pend *)
    attn_cond_cell.pending := true;
    attn_intercept_active := false;
    return;
  end
  else begin                          (* signal *)
    mgr_active := attn_exc_block;
    attn_intercept_active := false;
    except_mgr ( attn_exc_block, exc_addr );
  end;
end;
#sect(The Exception Manager)
The exception manager is the central runtime routine
called by all the intercept routines.
It has two parameters,
the exception block address for the condition being signalled
and the address associated with the exception.
#beginfigure(7)
procedure except_mgr ( exc_block, exc_addr );

begin
  mask ( attention );
  masked := (exc_block^.cond_cell <> exc_block) andif
         (exc_block^.cond_cell^.maskable) andif
        (exc_block^.cond_cell^.masking_count > 0);
  if masked then begin
    exc_block^.cond_cell^.pending := true;
    exc_block^.cond_cell^.exc_block := exc_block;
    mgr_act= 0;
    goto exc_addr;
  end
  else begin
    find the topmost inactive handler for either the
      signalled condition or allconditions.
      set FOUND equals true if such a handler is
      found and to false otherwise.
      As the search proceeds, set variable HBT to
      the handler branch table for the first hbt
      found for the signalled condition or others
      or allconditions.
    if found then begin
      unwind any frames above one corresponding to hbt;
      set stack_frame^.hbt_addr in frame corresponding
        to HBT.
      hsb := stack_frame + hbt^.hsb_offset;
      hsb^ := (exc_addr, exc_block);
      unmask( attention );
      mgr_active := 0;
      goto handler;
    end
    else begin
      if exc_block^.cond_cell = exc_block
        then writeln ( tty, 'Unhandled user condition' )
        else writeln ( tty, exc_block^.message );
      call debugger ( exc_addr );
    end;
  end;
end;
#endfigure
#endlevel
#figure_pop
#sect(Compiler Interface)
The data structures and runtime calls which the compiler
must generate are described in this section.
#beginlevel
#sect(Data Structures Generated)
The compiler must generated and completely initialize the
handler branch table corresponding to each handler clause in
the compilation unit.
The HBT is generated in the code area.
#par
The compiler must allocate stack space for, but need not
initialize, the handler state block corresponding to each
handler clause.
#par
For each user condition, the compiler must emit an exception
block in the virtual static area. (Note that the exception
blocks are read-only; if a read-only, permanently resident
segment existed, then the exception blocks would be allocated
 in that area.)
The exception blocks must be initialized with their own address
and must be 32-bit aligned.
Public user conditions must also have a global definition emitted
which defines the value of the symbol to be the address of
the exception block.
#sect(Runtime Routine Calls Generated)
This section describes the interface to the exception handling
runtime routines which are called from compiler generated code.
#define(#rt_name,id,&
$ski 3  $par -12
id
#literal(#emit_input,1)&
#literal(#emit_output,1))

#define(#call,name,&
$par -7
CALL:\\PSHJ\\\\#upc(name))

#define(#input,label,desc,&
#if("#eqc("#emit_input,1),&
$ski   $par -7
INPUTS:
#assign(#emit_input,0))&
$par -5
label:\\desc)

#define(#output,label,desc,&
#if("eqc("#emit_output,1),&
$ski  $par -7
OUTPUTS:
#assign(#emit_output,0))&
$PAR -5
label:\\desc)
#beginmargin(12)
#rt_name()MASK
#call(e.mask)
#input(AC0,User exception block address (high 16 bits))
#input(AC1,User exception block address (low 16 bits))
#rt_name(UNMASK)
#call(e.unmask)
#input(AC0,User exception block address (high order 16 bits))
#input(AC1,User exception block address (low order 16 bits))
#rt_name(MASKED)
#call(e.mskd)
#input(AC0,user exception block address (high order 16 bits))
#input(AC1,user exception block address (low order 16 bits))
#output(AC0,boolean return value)
#rt_name(PENDING)
#call(e.pend)
#input(AC0,User exception block address (high order 16 bits))
#input(AC1,User exception block address (low order 16 bits))
#output(AC0,boolean return value)
#rt_name(EXCEPTION_MESSAGE)
#call(e.msg)
#rt_name(MATHSTATUS)
#call(e.mathst)
#rt_name(EXIOSTATUS)
#call(e.iost)
#rt_name(PROGRAMSTATUS)
#call(e.progst)
#rt_name(SPECIALSTATUS)
#call(e.spcst)
#rt_name(SIGNAL(<user condition>))
#call(e.signal)
#input(AC0,User exception block address (high order 16 bits))
#input(AC1,User exception block address (low order 16 bits))
#rt_name(SIGNAL())
#call(e.resig)
#rt_name(Establish A Handler)
#call(e.hset)
#input(AC0,Handler branch table address)
#rt_name(Restore A Handler)
#call(e.hrest)
#input(AC0,Handler branch table address)
#rt_name(Signalling Program Errors)
#call(e.perr)
#input(AC0,PROGRAM_STATUS value for signalled exception)
#endmargin
#endlevel
#sect(Miscellaneous)
This section discusses several miscellaneous issues concerning
exceptional condition handling.
#beginlevel
#sect(Link Management Interaction)
The information required by the exception handling system
is either passed in to the runtime directly or is found
via pointers in the stack;
thus the link management system has virtually no impact on
the exception handling system.
The standard restrictions on PUBLIC declarations do apply, however.
PUBLIC conditions may only be defined in MAIN, i.e., outside
of LINKs.
Like public variables, public conditions referenced from a LINK
must be declared in the transfer vector and the compiler must
access them with an extra level of indirection.
#sect(Compiler Options)
The compiler options to control underflow handling and attention
masking will be implemented if the hardware and OZMOS permit.
These options will be conveyed to the runtime through an options
set placed in the image file header by the linker.
#sect(Status Enumerated Types)
To be supplied.
#endlevel
#endlevel
  
 :Ne«