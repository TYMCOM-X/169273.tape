
.TITLE  TTRACE - DIAGNOSTIC CONSOLE SIGNAL TRACER VER 1.0

        $VER=1          ;VERSION 1
        $REV=0          ;REVISION 0

        .LIST   MC,MD,MEB
        .NLIST  BEX,CND

        $OPSEL=1                ;ALLOW"/COMMANDS" FOR USE BY DIAGNOSTIC
        $MBOX=1                 ;FOR MBOX DIAGNOSTICS
        $LOAD=1 
        $MSK36R=1
        DTEASB=1                ;ASSEMBLE DTE20 DEFS
        DTEDEF=1                
        KWASB=1                 ;ASSEMBLE CLOCK PARAMETERS
  
 
        .ENABL  ABS,AMA
        ERCRLF=PCRLF            ;ERROR MESSAGES TO CTY
        ERROCT=PNTOCT   
        $CONEX=1                ;ENABLE MSUB CONSOLE FEATURES
 
        SUBEND=CMDTAB-SUBTAB    ;MAX CONTROL COMMAND INDEX
        CMDEND=MCNTRL-SUBTAB    ;MAX COMMAND INDEX
        CONNUM=CMDTAB-SUBTAB-2  ;CONSOLE COMMAND INDEX
        EDEND=MCNTRL-CMDTAB
        ENDED=EDENT-EDTAB       ;MAX EDIT INDEX
 
        OVLAY1=1000             ;J FILE/ CDUMP OVERLAY AREA 1000-2776
        COMBUF=64000            ;POINTER TO END OF COMMAND BUFFER
        DATBUF=COMBUF+2         ;POINTER TO END OF ARGUMENT DATA BUFFER
        COMST=DATBUF+2          ;START OF COMMAND BUFFER
        COMEND=COMST+370        ;MAXIMUM COMMAND BUFFER END
        DATST=COMEND+2          ;START OF ARGUMENT DATA BUFFER
        DATEND=DATST+2240       ;MAXIMUM ARGUMENT BUFFER END
        INSBUF=DATEND+140       ;INSERT BUFFER END
        CMONID=INSBUF+2         ;MONITOR I.D. FOR CRASH DUMP
        CTIME=CMONID+2          ;TIME POINTER
        CDATE=CMONID+4          ;DATE POINTER
        CRBUF=CMONID+6          ;DIAG SIG CRASH STORAGE
        $CCICPT=100106          ;KLDCP ^C INTERCEPT LOCATION
        OVRFF=CRBUF+<8.*40.>    ;FIRST FREE AFTER BUFFER
        DSTSIZ=142.             ;SIZE OF SIGNAL BYTE STORAGE, MUST BE EVEN
 
        .=3000
        PXCT=   256

   
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTR
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFINITIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM







.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE




.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
MOVN=   210
LSH=    242
BLT=    251
AOBJN=  253
JRST=   254
JFCL=   255
XCT=    256
MAP=    257
JSP=    265
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
CAMN=   316
JUMPL=  321
JUMPLE= 323
JUMPA=  324
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOS=    350
SOJE=   362
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
IOR=    434
IORI=   435
SETCA=  450
SETCAM= 452
SETOM=  476
HRLI=   505
HLLZS=  513
HRLZI=  515
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TRZ=    620
TRZN=   626
TRC=    640
TRCE=   642


.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM

.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM


;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.LIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.NLIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        R00=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB



.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000


.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT


.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND



.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT22S       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S



.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD



.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR



.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


.MACRO ERRMSG   MSG
        PMSG    <MSG>
.ENDM   ERRMSG
 
 
 
 




 


;SEQ124

.SBTTL  *TRACON* OVERLAY CONTROL - TRACON.A11

START:  MOV     R0,R2           ;GET SP FROM KLDCP
        TST     SPSAVE          ;ONE-TME INITIALIZATION DONE?
        BEQ     1$              ;ZERO,LOAD OVERLAY
        BPL     STARTA          ;POSITIVE, NO LOAD
        BR      TRACON          ;NEG, BYPASS ONE-TIME INIT
1$:     CLR     R1              ;
        CLKPRM                  ;GET CLOCK PARAMETERS
        TST     -(R0)           ;PROCESSOR TYPE DETERMINED?
        BNE     2$              ;YES
        MOV     #TYPMSG,R0      ;ASK FOR PROCESSOR TYPE
        PNTAL
        TTILNW                  ;GET REPLY
        TTICHR                  ;CHECK A OR B
        CMP     R0,#'A          ;MODEL A?
        BR      3$              ;
2$:     TSTB    (R0)            ;MODEL A?
3$:     BEQ     4$              ;YES
        INC     R1              ;NO, MODEL B
        INC     R1              ;
4$:     PNTCI,"P                ;BUILD P COMMAND
        MOV     PRTXT(R1),R0    ;GET PRGM TEXT POINTER
        PNTAL                   ;PUT IN OUTPUT BUFFER
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD
        BCC     STARTA          ;LOAD IK
        $PMSG,MNTTXT            ;LOAD BAD, ASK USER TO MOUNT
        MOV     PRTXT(R1),R0    ;POINT TO LOAD TEXT
        PNTAL                   ;
        MOV     #TXREST,R0      ;
        PNTAL                   ;PRINT IT
        PRGHLT                  ;WAIT FOR USER RESTART
        BR      4$              ;TRY AGAIN

PRTXT:  ATRACE,BTRACE           ;TYPE POINTERS
ATRACE: .ASCIZ  %DGQFA.A11%
BTRACE: .ASCIZ  %TTRACE.A11%
MNTTXT: .ASCIZ  %MOUNT %

TXREST: .ASCIZ  %, HC TO RETRY\%
TYPMSG: .ASCIZ  %A OR B TYPE CPU? _%
        .EVEN


;SEQ125

.SBTTL          TRACON COMMAND HANDLER - TTRACE.A11
.REM    %
        EXTENSION TO KLDCP.  TYPE H FOR HELP.  CONSOLE COMMANDS 
MAY BE ENTERED DIRECTLY IF NO NAMING OCNFLICTS OCCUR.  IF A
CONSOLE COMMAND WITH THE SAME NAME AS TRACON COMMAND IS DESIRED,
PRECEED THE COMMAND NAME WITH A PERIOD.
%

SPSAVE: .WORD   'X              ;STACK AT ENTRY GOES HERE

STARTA: JSR     R5,INITM                ;INITLIZE MSUB
        MOV     BASE20,R0               ;GET DTE20 BASE ADDRESS
        ADD     #30,R0          ;MAKE POINTER TO DIAG1
        MOV     R0,DTDIAG       ;SAVE POINTER
        MOV     R0,CHFLAG               ;RM DOES AN EXTRA 34 TICKS
        INC     $$FF            ;MAKE FIRST FREE EVEN
        BIC     #1,$$FF         ;
        MOV     R2,SPSAVE               ;SAVE STACK POINTER AT ENTRY
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,TTYBUF               ;SAVE ITS LOCATION
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TTRACE      TRACON UTILITY  >
        PNTVER                  ;PRINT VERSION

        PCRLF                   ;CR/LF
        MOV     #COMST,COMBUF   ;RESET COMMAND BUFFER
        MOV     #DATST,DATBUF   ;RESET DATA BUFFER
        JSR     PC,SWTDFL               ;DO FREE SWITCH THING
        MOV     $CCICPT,KCCLOC  ;SAVE KLDCP CONTROL C ADDRES
        MOV     #1,CONSOL-2             ;SET INITIALIZATION DONE
TRACON: CLR     AUTOIN          ;CLEAR AUTO INSERT MODE
        CLR     CRSHFG          ;CLEAR CRASH DUMP FLAG
        CLR     TICK            ;RESET TICK OCUNTER
        CLR     LCHANG          ;CLEAR LAST CHANGE TICK MEM
        MOV     $$FF,CORFF      ;RESET FREE CORE POINTER
        JSR     PC,IANDOR       ;CLR EBUS BIT STATUS REGS
        TTICCL                  ;RUNNING FROM I OR J FILE?
        BCS     INDRST          ;NOP
        INC     CCLFLG          ;YES, SET I OR J FILE ACTIVE
        INCB    CCLFLG+1        ;SET BUFFER VALID
        BR      CCLGO           ;CONTINUE
        ;CNTROL C & BUFFER LOAD RETURN POINT

INDRST: CLR     CCLFLG  ;CLEAR I OR J FILE
        MOV     SPSAVE,SP               ;RESET STACK POINTER
CCLGO:  CLR     BRKFLG          ;CLEAR FUNCTION BREAK OCNTINUE
        MOV     #INDRST,CCRET   ;SET LOCAL CONTROL C
        CLR     TRCMEM          ;CLEAR EMMORY TRACE FLAG
        CLR     QUEBUF          ;CLEAR QUEUE
        MOV     #QUEUE,QUEPTR   ;
        MOV     #QUEUE,QUEPOS   ;


;SEQ126

;RETURN POINT FOR CONTROL FUNCITONS & BUFFER OPERATIONS

CONTPT: CLR     PRINT.          ;CLEAR BUFFER PRINT FLAG
        CLR     LOOP.           ;CLEAR COMMAND BUFFER LOOP FLAG
        CLR     XCT.            ;CLEAR BUFFER EXECTUION

        ;COMMAND ENTRY ROUTINE

CONBAK: CLR     DUMPFG          ;CLEAR DUMP FLAG
        CLR     TTALFG          ;CLEAR ALTMODE FLAG
        MOV     KCCLOC,$CCICPT  ;RESTORE KLDCP CONTROL C ADDRESS
        TST     CCLFLG          ;I OR J FILE ACTIVE?

        BEQ     2$              ;NO
        TSTB    CCLFLG+1        ;BUFFER VALID?
        BEQ     1$              ;NO
        CLRB    CCLFLG+1        ;CLEAR BUFFER VALID
        BR      4$              ;PROCESS IT
1$:     TTICCL                  ;GET LINE FROM I OR J FILE
        BCC             4$              ;GOT IT, CONTINUE
        CLR     CCLFLG          ;CLR I OR J FILE ACTIVE
2$:     PFORCE                  ;FORCE TYPEOUTS
        MOV     #PROMPT,R0      ;TYPE PROMPT CHARACTER
        PNTAL                   ;*
3$:     TTILNW                  ;GET REPLY
        MOV     #INDRST,$CCICPT ;SET LOCAL CONTROL C
4$:     TTICHR                  ;GET FIRST CHARACTER
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     CONTPT          ;YES, IGNORE LINE
        CMP     R0,#'.          ;PERIOD?
        BNE     MESCAN          ;NO, DO COMMAND SCAN
        BR      CONCOM          ;YES, CONSOLE CCMMAND

PROMPT: .ASCIZ  %*	_%      ;PROMPT CHARACTER IS *
        .EVEN

        ;COMMAND ERROR RETURN POINT

CMDERR: PMSG    < ?\>           ;PRINT?

        CLR     CCLFLG          ;CLEWAR I OF J FILE ACTIVE
        BR      CONBAK                  ;CONTINUE

;SEQ127

        ;COMMAND SCANNER

MESCAN: MOV     R0,R5           ;SAVE FIRST CHASRACTER
        TTICHR                  ;GET 2ND CHARACTER
        CLR     R1              ;CLEAR SEARCH INDEX
1$:     CMPB    R5,SUBTAB(R1)   ;SCAN COMMAND LIST
        BNE     4$              ;NOT FOUND YET
        CMPB    SUBTAB+1(R1),#SPACE     ;SPECIAL CHARACTER?
        BEQ     3$              ;YES, CHECK SYNTAX
        CMPB    SUBTAB+1(R1),R0        ;NO DIRECT MATCH
        BNE     4$              ;NO MATCH
2$:     CMP     R1,#SUBEND      ;
        BGE     EXFN            ;TRACON FUNCTION
        JSR     PC,@MCNTRL(R1)  ;CONTROL FUNCTION
        BR      CONBAK          ;NEXT COMMAND
3$:     CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     2$              ;YES, SYNTAX OK
        CMP     R0,#SPACE       ;SPACE?
        BEQ     2$              ;SYNTAX OK
        CMP     R0,#TAB         ;TAB?
        BEQ     2$              ;SYNTAX OK
        CMP      R0,#60         ;VALID NUMBER?
        BLT     4$              ;
        CMP     R0,#71          ;
        BGT     4$              ;NO
        TTBACK                  ;YES, BACKUP INPUT POINTER
        BR      2$              ;MATCH FOUND
4$:     INC     R1              ;UPDATE SEARCH INDEX
        INC     R1              ;
        CMP     R1,#CMDEND      ;END OF LIST?
        BLE     1$              ;NO, CONTINUE SCAN
CONSED: TTBACK                  ;BACK UP INPUT BUFFER
        TTBACK                  ;
CONCOM: MOV     #CONNUM,R1              ;INDEX = -2 FOR CONSOLE

        ;PARAMETER INPUT HANDLING
EXFN:   SUB     #SUBEND,R1      ;COUNT BY 2 FROM CMDTAB
        MOVB    R1,@COMBUF      ;SAVE COMMAND TYPE
        MOV     DATBUF,R3       ;GET DATA POINTER
        MOV     FMTTAB(R1),R2   ;FORMAT ROUTINE?
        BEQ     1$              ;NO
        JSR     PC,(R2)         ;GET PARAMETERS
        BCS     CMDERR          ;PARAMETER ENTRY ERROR


;SEQ128


        
        ;BUFFER HANDLING & COMMAND EXECUTION

1$:     MOV     R0,R2           ;SAVE R0
        PNORML                  ;CLEAR FORCE TYPEOUTS FLAG
        MOVB    @COMBUF,R5      ;GET INDEX
        TST     AUTOIN          ;AUTO INSERT?
        BEQ     3$              ;NO
        INC     COMBUF          ;UPDATE COMMAND POINTER
        CMP     COMBUF,#COMEND  ;OUT OF ROOM?
        BLT     2$              ;NO
        INC     OVFLAG          ;YES, SET OVERFLOW FLAG
2$:     TST     QUEBUF          ;USE QUEUE BUFFER?
        BEQ     4$              ;NO
3$:     TST     QUEBUF          ;USE QUEUE BUFFER?
        BEQ     5$              ;NO
        MOV     R3,QUEBUF       ;YES, UPDATE QUEUE DATA POINTER
4$:     MOV     R3,DATBUF       ;UPDATE DATA POINTER
        CMP     R3,#DATEND      ;OUT OF ROOM?
        BLT     5$              ;NO
        INC     OVFLAG          ;YES, SET OVERFLOW FLAG
5$:     JSR     PC,@ENTPT(R5)   ;CALL PROGRAM

        BCS     7$              ;ERROR?
        TSTB    CMPARE          ;COMPARE ACTIVE?
        BEQ     7$              ;NO
        TSTB    CMPARE+1                ;COMPARE RESULT
        BNE     6$              ;YES
        INCB    CMPARE+1        ;NO, NEXT TIME
        BR      7$              ;
6$:     JSR     PC,BUFCOM       ;DO COMPARE
7$:     TST     OVFLAG          ;OVERFLOW?
        BEQ     9$              ;NO, NEXT COMMAND
        TST     AUTOIN          ;AUTO INSERT?
        BEQ     8$              ;NO, NEXT COMMAND
        PMSG    <TABLE OVERFLOW, RESETTING AUTO INSERT MODE\>

        CLR     AUTOIN          ;CLEAR FLAG
        BR      9$              ;RETURN
8$:     PMSG    <WARNING, QUEUE FULL\>
        CLR     QUEBUF          ;CLEAR QUEUE DATA FLAG
9$:     JMP     CONTPT  ;BACK TO COMMAND MODE


;SEQ129

        ;COMMAND NAME SEARCH LIST

SUBTAB: .BYTE   'H,CR           ;PRINT HELP FILE
        .BYTE   '/,CR           ;SET SIGNAL SWITCHES
        .BYTE   'E,CR           ;ENTER EDIT MODE
        .BYTE   'A,CR           ;ENTER AUTO INSERT MODE
        .BYTE   'T,CR           ;TYPE COMMAND PROGRAM
        .BYTE   'X,CR           ;ESECUTE COMMAND PROGRAM
        .BYTE   'L,CR           ;LOOP COMAND PROGRAM
        .BYTE   'M,CR           ;MULTI-BURST STEP AND TRACE
        .BYTE   'K,CR           ;KILL COMMAND PROGRAM BUFFER
        .ASCII  %LC%            ;LOAD COMMAND PROBRAM
        .ASCII  %DC%            ;DUMP COMMAND PROGRAM
        .ASCII  %KA%            ;KILL AUTO INSERT & LOOP MARKER
        .ASCII  %ML%            ;MARK LOOP START
        .ASCII  %FB%            ;SET FUNCTION BREAKPOINT
        .ASCII  %FC%            ;FUNCTION BREAK CONTINUE
        .ASCII  %CB%            ;CLEAR FUNCTION BREAKPOINT
        .ASCII  %RG%            ;PRINT FN BREAK REGISTERS
        .ASCII  %HE%            ;PRINT HELP FILE
        .ASCII  %^Z%    ;RETURN TO KLDCP


;SEQ130


CMDTAB: .ASCII  %RM%            ;RESET MBOX/CHANNELS
        .ASCII  %CN%            ;COMPARE NEX RESULT
        .ASCII  %B %            ;BURST #
        .BYTE   'C,CR           ;CONTINUE
        .ASCII  %D %            ;DUMP MACHINE STATE
        .ASCII  %F %            ;FIND TICK #
        .BYTE   'G,CR           ;GO REPORT CHANGES
        .BYTE   'I,CR           ;INITIALIZE TICK COUNTER
        .BYTE   'P,CR           ;PRINT EBUS ACTIVITY
        .BYTE   'R,CR           ;REPORT CHANGES
        .BYTE   'S,CR           ;SINGLE PULSE & REPORT CHANGES
        .BYTE   'W,CR           ;CRASH DUMP
        .ASCII  %EM%            ;EXAMINE KL  EMORY
        .ASCII  %EN%            ;EXAMINE NEXT MEMORY LOCATION
        .ASCII  %DM%            ;DEPOSIT INTO KL MEMORY
        .ASCII  %DN%            ;DEPOSIT INTO NEXT LOCATION
        .ASCII  %EX%            ;EXECUTE
        .ASCII  %CE%            ;CONFIGURE EPT
        .ASCII  %SC%            ;SIMULATE CBUS COMMAND
        .ASCII  %QC%            ;QUEUE CBUS COMMAND
        .ASCII  %T1%            ;TRACE 1 MEMORY REFERENCE
        .ASCII  %TM%            ;TRACE ALL MEMORY REFERENCES
        .ASCII  %CA%            ;PRINT CCW ADDRESS
        .ASCII  %NC%            ;NEXT CHANNEL (UPDATE DEFUALT)
        .ASCII  %CH%            ;PRINT DEFAULT CHANNEL
        .ASCII  %CU%            ;CACHE USE LOAD
        .ASCII  %C0%            ;USE LOAD CACHE 0
        .ASCII  %C1%            ;USE LOAD CACHE 1
        .ASCII  %C2%            ;USE LOAD  CACHE 2
        .ASCII  %C3%            ;USE LOAD CACHE 3
        .ASCII  %IC%            ;INVALIDATE CACHE
        .ASCII %VC%            ;VALIDATE CORE
        .ASCII  %SE%            ;SET PMA, CACHE EN, CH DEFAULT
        .ASCII  %CL%            ;CLR PMA, CACHE EN, CH DEFAULT


;SEQ131

        ;ENTRY POINT TABLE FOR TRACON CONTROL FUNCTIONS

MCNTRL: .WORD   HELP.           ;H
        .WORD   CSWT            ;/
        .WORD   CEDIT           ;E
        .WORD   AUTOI           ;A
        .WORD   CMDTYP          ;T
        .WORD   CMDEX           ;X
        .WORD   CMDLP           ;L
        .WORD   COMM            ;M
        .WORD   CMDCLR          ;K
        .WORD   LDCMD           ;LC
        .WORD   CDCMD           ;DC
        .WORD   CLRINS          ;KA
        .WORD   CMDMRK          ;ML
        .WORD   FNSET           ;FB
        .WORD   CONBRK          ;FC
        .WORD   FNCLR           ;CB
        .WORD   PREGS           ;RG
        .WORD   HELP.           ;HE
        .WORD   KBACK           ;^Z


;SEQ132


        ;CONSOLE EXTENSION EXTRY POINT TABLE

        .WORD   COMCON          ;CONSOLE COMMANDS
ENTPT:  .WORD   XRESET          ;RM
        .WORD   XCMPRE          ;CN
        .WORD   COMB            ;B
        .WORD   COMC            ;D
        .WORD   COMD            ;D
        .WORD   COMF            ;F
        .WORD   COMG            ;G
        .WORD   COMI            ;I
        .WORD   COMP            ;P
        .WORD   COMR            ;R
        .WORD   COMS            ;S
        .WORD   COMW            ;W
        .WORD   XEXAM           ;EM

        .WORD   XEXMN           ;EN
        .WORD   XDEPOS          ;DM
        .WORD   XDEPN           ;DN
        .WORD   XEXCT           ;EX
        .WORD   XCEPT           ;CE
        .WORD   XSIMC           ;SC
        .WORD   XQSIM           ;QC
        .WORD   XTRC1           ;T1
        .WORD   XTRC            ;TM
        .WORD   XCCWA           ;CA
        .WORD   XNEXTC          ;NC
        .WORD   XCHPNT          ;CH
        .WORD   XUSE            ;CU
        .WORD   XC0             ;C0
        .WORD   XC1             ;C1
        .WORD   XC2             ;C2
        .WORD   XC3             ;C3
        .WORD   XINVAL          ;IC
        .WORD   XVALCR          ;VC
        .WORD   XSET            ;SET
        .WORD   XCLR            ;CLR


;SEQ133

        ;ENTRY POINT TABLE FOR PARAMETER

        .WORD   FTCON           ;CONSOLE COMMANDS

FMTTAB: .WORD   0               ;RM - NO PARAMETERS
        .WORD   FASCII          ;CN-ASCII STRING
        .WORD   FTICK           ;B - # OF TICKS
        .WORD   0               ;C-NO PARAMETERS
        .WORD   0               ;D-NO PARAMETERS
        .WORD   FTICK           ;F-# OF TICKS
        .WORD   0               ;G - NO PARAMETERS
        .WORD   0               ;I - NO PARAMETERS
        .WORD   0               ;P - NO PARATMETERS
        .WORD   0               ;R - NOP PARAMETERS
        .WORD   0               ;S - NO PARAMETERS
        .WORD   0               ;W - NO PARAMETERS
        .WORD   FTADR2          ;EM-STARTING ADR:, ENDING ADR:
        .WORD   0               ;EN- NO PARAMETERS
        .WORD   ADRDAT          ;DM-ADDRESS:, DATA:
        .WORD   FTDAT           ;DN-DATA:
        .WORD   FTINST          ;EX-INSTRUCTION:
        .WORD   FTCHCW          ;CE -CHANNEL:, CONTROL WORD:
        .WORD   FTCSIM          ;SC - CHANNEL:, EBUS DATA:
        .WORD   FTQSIM                  ;QC-CHANNEL:,EBUS DATA:
        .WORD   0               ;T1-NO PARAMETERS
        .WORD   0               ;TM-NO PARAMETERS
        .WORD   0               ;CA-NO PARAMETERS
        .WORD   0               ;NC - NO PARAMETERS
        .WORD   0               ;CH - NO PARAMETERS
        .WORD   0               ;CU-NO PARAMETERS
        .WORD   0               ;C0-NO PARAMETERS
        .WORD   0               ;C1-NO PARAMETERS       
        .WORD   0               ;C2-NO PARAMETERS
        .WORD   0               ;C3-NO PARAMETERS
        .WORD   0               ;IC-NO PARAMETERS
        .WORD   0               ;VC - NO PARAMETERS
        .WORD   SFLAG           ;SET-PMA, CACHE EN, CH DEFAULT
        .WORD   CFLAG           ;CLR-PMA,CACHE EN, CH DEFAULT


;SEQ134

        ;ENTRY POINT TABLE FOR PARAMETER RETRIEVAL

        .WORD   GASCII          ;CONSOLE COMMANDS
GETTAB: .WORD   0               ;RM-NO PARAMETERS
        .WORD   GASCII          ;CN-GET ASCII STRING
        .WORD   GETDEC          ;B - # OF TICKS
        .WORD   0               ;C - NO PARAMETERS
        .WORD   0               ;D - NO PARAMETERS
        .WORD   GETDEC          ;F - # OF TICKS
        .WORD   0               ;G - NO PARAMETERS
        .WORD   0               ;I - NO PARAMETERS
        .WORD   0               ;P - NO PARAMETERS
        .WORD   0               ;R - NO PARAMETERS
        .WORD   0               ;S - NO PARAMETERS
        .WORD   0               ;W - NO PARAMETERS
        .WORD   GET222          ;EM - GET 2 22-BIT ADDRESSES
        .WORD   0               ;EN - NO PARAMETERS
        .WORD   GT2236          ;DM - GET 22-BIT & 36-BIT DATA
        .WORD   GET36           ;DN-GET 36-BIT DATA
        .WORD   GET36           ;EX-GET 36-BIT DATA
        .WORD   GETC36          ;CE - GET CHANNEL, 36-BIT DATA
        .WORD   GETC36          ;SC-GET CHANNEL, 36-BIT DATA
        .WORD   GETC36          ;QC - GET CHANNEL, 36-BIT DATA
        .WORD   0               ;T1 - NO PARAMETERS
        .WORD   0               ;TM - NO PARAMETERS
        .WORD   0               ;CA - NO PARAMETERS
        .WORD   0               ;NC - NO PARAMETERS
        .WORD   0               ;CH - NO PARAMETERS
        .WORD   0               ;CU - NO PARAMETERS
        .WORD   0               ;C0 - NO PARAMETERS
        .WORD   0               ;C1 - NO PARAMETERS
        .WORD   0               ;C2 - NO PARAMETERS
        .WORD   0               ;C3 - NO PARAMETERS
        .WORD   0               ;IC - NO PARAMETERS
        .WORD   0               ;VC - NO PARAMETERS
        .WORD   GSFLAG          ;SET - GET FLAG
        .WORD   GCFLAG          ;CLR - GET FLAG
 


;SEQ135

.SBTTL          CONTROL FUNCTIONS

        ;PRINT HELP FILE

HELP.:  PMSG    <H TRACON.HLP\>
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;PRINT THE FILE
        RTS     PC              ;RETURN

        ;SET AUTO-INSERT MODE

AUTOI:  TST     OVFLAG          ;OVERFLOW?
        BEQ     1$              ;NO
        JMP     CMDERR          ;YES, CANNOT SET IT
1$:     INC     AUTOIN          ;SET THE FLAG
        RTS     PC              ;RETURN

        ;CLEAR AUTO-INSERT MODE

CLRINS: CLR     AUTOIN          ;CLEAR AUTO INSERT
        CLR     MARK.           ;CLEAR LOOP MARK
        RTS     PC              ;RETURN


        ;MARK LOOP START

CMDMRK: JSR     PC,FTLINE               ;GET LINE #
        MOV     R0,MARK.                ;MARK LOOP START
        RTS     PC              ;RETURN

        ;TYPE THE COMMAND BUFFER


CMDTYP: INC     PRINT.          ;SET THE PRINT FLAG 
        JSR     PC,BUFSUB               ;PROCESS THE BUFFER
        CLR     PRINT.          ;CLEAR THE PRINT FLAG
        RTS     PC              ;RETURN

        ;BACK TO KLDCP

KBACK:  MOV     KCCLOC,$CCICPT  ;RESTORE KLDCP ^C ADDRESS
        JMP     $CONSL          ;JUMP TO CONTINUE J FILE


;SEQ136


        ;DO MULTI-BURST STEP AND REPORT CHANGES

COMM:   MOV     #1000,DTESTA    ;SET HALT LOOP BIT
        CLR     TICK            ;CLEAR TICK COUNTER
        INC     XCT.            ;SET EXECUTE BUFFER
        JSR     PC,BUFSUB               ;DO COMMAND BUFFER
        BCC     1$
        RTS     PC              ;SOMETHING WRONG
        
1$:     JSR     PC,READIN               ;GET INITIAL STATE
        MOV     #-1,BSTFG       ;SET BURT MODE
        JMP     COMC            ;FINISH USING C COMMAND

        ;LOOP ON THE COMMAND BUFFER

CMDLP:  INC     XCT.            ;SET EXECUTE
        INC     LOOP.           ;SET LOOP
        CLR     TICK            ;CLEAR TICK COUNTER
        BR      DOBUF           ;PEROXCWAA RTHE BUFFER

        ;EXECUTE THE COMMAND BUFFER

CMDEX:  CMP     #COMST,COMBUF   ;BUFFER EMPTY?
        BEQ     DOBUF           ;YES
        CLR     TICK            ;CLEAR TICK COUNTER
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BNE     1$              ;YES, DON'T PRINT SOURCE
        PMSG    <PRINT SOURCE? _>
        TTILNW                  ;WAIT FOR REPLY

        TTIYES                  ;YES OR NO?
        BCS     BUFERR          ;GARBAGE
        BMI     1$              ;NO
        INC     PRINT.          ;YES, SET PRINT FLAG
1$:     INC     XCT.            ;SET EXECUTE


;SEQ137


;PROCESS COMMAND BUFFER

DOBUF:  POP     R0              ;DISCARD ENTRY POINT

        PUSH    #CONTPT ;SET NEW RETURN POINT
BUFSUB: CMP     #COMST,COMBUF   ;BUFFER EMPTY?
        BNE     ALLBUF          ;NO
        PMSG    <BUFFER EMPTY\>

BUFERR:RTS      PC              ;RETURN
ALLBUF: PNORML
        CLR     CMDNUM          ;CLEAR COMMAND #
        MOV     #COMST,R4       ;GET COMMAND START
        MOV     #DATST,R3               ;GET DATA START
1$:     CMP     R4,COMBUF               ;END COMMAND BUFFER?
        BGE     9$              ;YES
        JSR     PC,INCHK                ;DO INPUT CHECK
        BCC     10$             ;ALTMODE DETECTED
        INC     CMDNUM          ;NEXT LINE #
        MOVB    (R4),R2         ;GET COMMAND INDEX
        TST     PRINT.          ;PRINT IT?
        BEQ     3$              ;NO, BYPASS PRINT
        JSR     PC,LINPNT       ;PRINT LINE #
        TST     R2              ;CONSOLE COMMAND?
        BPL     2$              ;NO, PERFORM LOOKUP
        PNTCI                   ;PRINT A PERIOD
                '.              ;
        BR      3$              ;BYPASS LOOKUP
2$:     MOVB    CMDTAB(R2),R0   ;GET FIRST CMD CHARACTER
        PNTCHR                  ;PRINT IT
        MOVB    CMDTAB+1(R2),R0 ;GET 2ND CHARACTER
        PNTCHR                  ;PRINT IT
        PSPACE                  ;
3$:     MOV     GETTAB(R2),R2   ;ANY PARAMETERS?
        BEQ     4$              ;NO
        JSR     PC,(R2)         ;YES, GET THEM
4$:     TST     PRINT.          ;PRINT?
        BEQ     5$              ;NO
        PUSH    R0

        JSR     PC,CRIN         ;YES, FINISH OUTPUT
        POP     R0

        BCC     10$             ;ALTMODE DETECTED
5$:     MOVB    (R4)+,R2        ;UPDATE COMMAND INDEX
        TST     XCT.            ;EXECUTE?
        BEQ     1$              ;NO


;SEQ138

        
        ;COMMAND EXECUTION

        PUSH    <R3,R4>

        JSR     PC,@ENTPT(R2)   ;DO COMMAND
        POP     <R4,R3>


        ;RETURN FROM COMMAND
        BCC     6$              ;NO ERROR DETECTED
        PNTCI,'?                ;PRINT?
        BR      8$              ;HANDLE ERROR
6$:     TSTB    CMPARE          ;COMPRE ACTIVE?
        BEQ     1$              ;NO, NEXT COMMAND
        TSTB    CMPARE+1        ;COMPARE RESULT?
        BNE     7$              ;YES
        INCB    CMPARE+1        ;NO, NEXT TIME
        BR      1$              ;NEXT COMMAND
7$:     JSR     PC,BUFCOM       ;DO COMPARE
        BCC     1$              ;NEXT COMMAND IF NO ERROR
8$:     TST     PRINT.          ;SOURCE PRINTED?
        BNE     9$              ;YES, CHECK LOOP
        PMSG    <FAULT AT LINE >
        MOV     CMDNUM,R0               ;PRINT LINE #
        PNTDEC
        JSR     PC,CRIN         ;FINISH OUTPUT
9$:     TST     LOOP.           ;LOOP ACTIVE?
        BEQ     10$             ;NO, DONE
        MOV     MARK.,R5        ;LOCAL LOOP?
        BEQ     ALLBUF          ;NO, ENTIRE BUFFER
        JSR     PC,SEARCH               ;GET TO LOOP START
        DEC     CMDNUM          ;
        DFXCTT                  ;SYNC @ A36,E1
                74              ;
        BR      1$              ;RETURN TO LOOP
10$:    RTS     PC              ;RETURN


;SEQ139

        ;LOAD A COMMAND PROGRAM

LDCMD:  CLR     MARK.           ;CLEAR LOOP MARKER
        JSR     PC,FILNAM               ;GET THE FILENAME
        PMSG    <LE >           ;LE CMD TO OUTPUT BUFER
        MOV     R1,R0           ;
        PNTAL                   ;FILENAME
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;PERFORM THE LAOD
        JMP     INDRST          ;RESET QUEUES & EXECUTION FLAGS

        ;DUMP    A COMMAND PROGRAM

CDCMD:  JSR     PC,FILNAM               ;GET THE FILENAME
        JSR     PC,PNTCDA       ;SDETUP FOR CORE DUMP
        MOV     R1,R0           ;
        PNTAL                   ;FILENAME
        PSPACE                  ;
        MOV     #COMBUF,R0      ;STARTING ADRESS
        PNTOCS                  ;
        PCOMMA                 ;
        MOV     DATBUF,R0               ;ENDING ADDRESS
        PNTOCS                  ;
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;DO CORE DUMP
        RTS     PC              ;RTURN

FILNAM: MOV     DATBUF,R3       ;POINT TO DATA BUFFER
        TTISDL                  ;NAME SPECIFIED?
        BCC     1$              ;NO, IMPROPER FORMAT
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BNE     2$              ;NO, USE IT
1$:     PMSG    <FILENAME: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     JSR     PC,FTCON                ;SAVE INPUT
        RTS     PC              ;RETURN


;SEQ140

CMDCLR: PMSG    <CONFIRM: _>

        TTILNW                  ;WEAIT FOR A K REPLY
        TTICHR                  ;GET CHARACTER
        CMP     R0,#'K          ;K?
        BNE     1$              ;NO, DON'T RESET
        MOV     #COMST,COMBUF   ;RESET COMMAND POINTER
        MOV     #DATST,DATBUF   ;RESET DATA BUFFER
        CLR     MARK.           ;CLEAR LOOP MARKER
        CLR     OVFLAG          ;CLEAR OVERFLOW
        PMSG    <BUFFER RESET\>

1$:     RTS     PC              ;RETURN

        ;SET FUNCTION BREAKPOINT

FNSET:  POP     COMRET          ;SET RETURN ADDRESS

        JMP     FB..            ;GO TO CLKCON

        ;CEAR FUNCTION BREAKPOINT

FNCLR:  POP     COMRET          ;SET RETURN ADDRESS
        
        JMP     CB..            ;GO TO CLKCON

        ;FUNCTION  BREAKPOINT CONTINUE

CONBRK: POP     COMRET          ;SET RETURN ADDRESS

        JMP     FC..            ;GO TO CLKCON

        ;PRINT BREAK REGISTERS

PREGS:  POP     COMRET          ;SET RETURN ADDRESS

        JMP     RG..            ;GO TO CLKCON


;SEQ141

        ;FINISH OUTPUT & THEN CHECK INPUT

CRIN:   PCRLF                   ;CARRIAGE RETURN/ LINEFEED

        ;INPUT CHECK ROUTINE

INCHK:  TTLOOK          ;ANY INPUT?
        BCS     4$              ;NO, CONTINUE
        CMP     R0,#17  ;CONTROL 0?
        BNE     1$              ;NO
        CLR     PRINT.          ;YES, CLEAR PRINT FLAG
        BR      3$              ;RETURN
1$:     CMP     R0,#3           ;CONTROL C?
        BNE     2$              ;NO, CHECK ALTMODE
        PMSG    < ^C\>  ;ECHO ^C
        JMP     @CCRET          ;BACK TO COMMAND MODE
2$:     CMP     R0,#ALTMOD      ;ALTMODE?
        BNE     3$              ;NO, C-BIT RETURN
        PMSG    < $\>   ;ECHO $

        INC     TTALFG          ;SET ALTMODE FLAG
        CLC                     ;VLRST C-BIT
        BR      4$              ;RETURN
3$:     SEC                     ;SET C-BIT
4$:     RTS     PC              ;RETURN


;SEQ142

.SBTTL          COMMAND FILE EDITOR

EDERR:  PMSG    < ?\>           ;COMMAND ERROR

CEDIT:  MOV     #EDIT,CCRET     ;SET LOCAL CONTROL C
EDIT:   MOV     SPSAVE,SP       ;RESET STACK POINTER
        MOV     #INDRST,$CCICPT ;SET CONTROL C POINT
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <!	_>      ;!
        CLR     XCT.            ;CLEAR BUFFER EXECUTE
        CLR     PRINT.          ;CLEAR BUFFER PRINT
        CLR     LOOP.           ;CLEAR BUFFER LOOP
1$:     TTILNW                  ;GET REPLY
        MOV     #EDIT,$CCICPT   ;SET LOCAL CONTROL C
        TTICHR                  ;GET A CHARACTER
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     EDIT            ;YES
        CLR     R1              ;CLEAR SCAN INDEX
2$:     CMPB    R0,EDTAB(R1)    ;SCAN EDIT COMMAND LIST
        BEQ     3$              ;FOUND IT
        INC     R1              ;UPDATE INDEX
        CMP     R1,#ENDED               ;END OF LISY?
        BLT     2$              ;NO, CONTINUE SCAN
        BR      EDERR           ;YES, ENTRY ERROR
3$:     ASL     R1              ;MULITPLY INDEX BY 2

        JSR     PC,@EDENT(R1)   ;GO TO PROPER SUBROUTINE
        BCS     EDERR           ;COMMAND ERROR
        BR      EDIT            ;BACK TO EDIT

EDTAB:  .BYTE   'E              ;ENTER
        .BYTE   'D              ;DELETE
        .BYTE   'I              ;INSERT
        .BYTE   'T              ;TYPE
        .BYTE   'R              ;REPLACE
        .BYTE   'K              ;KILL
        .BYTE   'X              ;EXIT
        .BYTE   'H              ;HELP

EDENT:  .WORD   ENTER           ;E
        .WORD   DELETE          ;D
        .WORD   INSERT          ;I
        .WORD   CMDTYP          ;T
        .WORD   RPLCE           ;R
        .WORD   CMDCLR          ;K
        .WORD   INDRST          ;X
        .WORD   EDHLP           ;H



;SEQ143

        ;EDIT HELPER

EDHLP:  PNORML                  ;NORMAL TYPEOUTS
        MOV     #HLPED,R0       ;PRINT MESSAGE
        PNTAL
        RTS     PC              ;RETURN

HLPED:
.ASCII  %  EDIT COMMANDS ARE:\%
.ASCII  %\	E	- ENTER COMMANDS INTO FILE\%
.ASCII  %	D	- DELETE COMMAND AT LINE #\%
.ASCII  %	I	- INSERT COMMAND BEFORE LINE #\%
.ASCII  %	T	- TYPE COMMAND FILE\%
.ASCII  %	R	- REPLACE COMMAND AT LINE #\%
.ASCII  %	K	- KILL COMMAND FILE (CONFIRM WITH K)\%
.ASCIZ  %	^C	- EXIT TO TRACON COMMAND MODE\%
        .EVEN


;SEQ144

        ;ENTER LINES INTO BUFFER

ENTER:  MOV     #501.,R5        ;
        JSR     PC,SEARCH       ;FIND END OF BUFFER
1$:     CMP     R3,#DATEND      ;OVERFLOW?
        BGE     FULL    ;
        CMP     COMBUF,#COMEND  ;

        BGE     FULL            ;YES
        INC     CMDNUM  ;NEXT LINE #
        JSR     PC,LINPNT       ;PRINT LINE #
        JSR     PC,CMDGET               ;GET COMMAND DATA
        MOV     R3,DATBUF       ;UPDATE DATA POINTER
        INC     COMBUF          ;UPDATE COMMAND POINTER
        BR      1$              ;

FULL:   INC     OVFLAG          ;SET OVERFLOW
        PMSG    <BUFFER FULL\>  ;

        RTS     PC              ;RETURN

        ;DELETE A LINE

DELETE: JSR     PC,FTLINE       ;GET LINE #
        MOV     R0,RLINE        ;SAVE LINE #
        MOV     R0,R5           ;
        JSR     PC,SEARCH       ;SEARCH FOR COMMAND
        CMP     R5,CMDNUM       ;LINE # O.K.?
        BNE     BADLIN          ;NO
        MOV     R3,R5           ;DATA INDEX TO R5
        MOVB    (R4),R2 ;GET FORMAT
        MOV     GETTAB(R2),R2   ;
        BEQ     2$              ;NO DATA
        JSR     PC,(R2) ;UPDATE R3 DATA POINTER
1$:     MOVB    (R3)+,(R5)+     ;PUT A BYTE IN DATA HOLE
        CMP     R3,DATBUF       ;DONE?
        BLT     1$              ;NO, CONTINUE
        MOV     R5,DATBUF               ;SET DATA BUFFER END
2$:     MOVB    1(R4),(R4)+     ;BACK COMMANDS UP ONE
        CMP     R4,COMBUF       ;
        BLT     2$              ;
        DEC     COMBUF          ;SET COMMAND BUFFER END
        RTS     PC





;SEQ145

        ;INSERT A LINE

INSERT: JSR     PC,FTLINE               ;GET LINE #
        MOV     R0,R5           ;
        BCC     INSRTA          ;LINE OK, CONTINUE
        RTS     PC              ;COMMAND ERROR
INSRTA: JSR     PC,SEARCH       ;SEARCH FOR COMMAND
        CMP     R5,CMDNUM       ;LINE # O.K.?
        BEQ     1$              ;YES
        INC     CMDNUM          ;MAYBE
        CMP     R5,CMDNUM               ;NEXT LINE>?
        BNE     BADLIN          ;NO
        BR      ENTER           ;YES, UES ENTER ROUTINE

1$:     CMP     R3,#DATEND      ;OVERLOW?
        BGE     FULL            ;
        CMP     R4,#COMEND      ;
        BGE     FULL            ;YES
        JSR     PC,LINPNT               ;PRINT LINE #
        MOV     R3,LOOP.        ;SAVE DATA POINTER
        MOV     R4,XCT.         ;SAVE COMMAND POINTER
        MOV     #INSBUF,R3      ;SET TEMPORARY DATA POINTER
        JSR     PC,CMDGET       ;GET COMMAND DATA
        MOVB    @COMBUF,R1      ;GET COMMAND TYPE
        INC     COMBUF          ;UPDATE COMMAND POINTER
        MOV     COMBUF,R4       ;
2$:     MOVB    -2(R4),-(R4)    ;PUT A HOLE IN COMMAND BUFFER
        CMP     R4,XCT.         ;
        BGT     2$              ;
        MOVB    R1,@XCT.        ;FILL THE HOLE WITH COMMAND
        MOV     LOOP.,R5        ;GET INSERT POINYTER
        MOV     #INSBUF,R2      ;GET TEMPORARY DATA POINTERR
3$:     CMP     R2,R3           ;ANDY DATA LEFT?
        BEQ     5$              ;NO, RETURN
        INC     DATBUF          ;YES, UPDATE DATA POINTER
        MOV     DATBUF,R4       ;
4$:     MOVB    -2(R4),-(R4)    ;PUT A HOLE IN DATA BUFFER
        CMP     R4,R5           ;
        BGT     4$              ;
        MOVB    (R2)+,(R5)+     ;FILL THE HOLE
        BR      3$              ;CONTINUE
5$:     RTS     PC              ;RETURN

BADLIN: PMSG    <NO SUCH LINE\>
        POP     R0              ;GET STACK RIGHT

        JMP     EDIT            ;RETURN TO EDIT MOE


;SEQ146

        ;REPLACE  LINE

RPLCE:  POP     XCT.            ;SAVE ENTRY POINT
        JSR     PC,DELETE               ;DELETE THE LINE
        PUSH    XCT.            ;RESTORE ENTRY POINT

        MOV     RLINE,R5                ;LINE # TO R5
        JMP     INSRTA          ;DO INSERT


        ;ROUTINE TO GET A COMMAND



CMDGET: TTILNW                  ;GET COMMAND 
        TTICHR                  ;GET FIRST CHARACTER
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     4$              ;YES, DONE

        CMP     R0,#ALTMOD      ;ALTMODE?
        BEQ     4$              ;YES, DONE
        CMP     R0,#'.          ;PERIOD?
        BEQ     2$              ;YES, CONSOLE COMMAND
        MOV     R0,R1           ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0              ;
        BIS     R1,R0           ;
        CLR     R1              ;CLEAR SCAN INDEX
1$:     CMP     R0,CMDTAB(R1)   ;SCAN COMMAND LIST
        BEQ     3$              ;FOUND IT
        INC     R1              ;UPDATE INDEX
        INC     R1              ;
        CMP     R1,#EDEND               ;END LIST?
        BLT     1$              ;NO, CONTINUE SCAN
        TTBACK                  ;
        TTBACK                  ;
2$:     MOV     #-2,R1          ;INDEX FOR CONSOLE COMMANDS
3$:     MOVB    R1,@COMBUF      ;SAE COMMAND TYPE
        MOV     FMTTAB(R1),R2   ;FORMAT ROUTINE?
        BEQ     5$              ;NO,RETURN
        JSR     PC,(R2)         ;GET PARAMETERS
        BR      5$              ;RETURN
4$:     POP     R0              ;BACK-UP ONE CALL LEVEL

5$:     RTS     PC              ;RETURN


;SEQ147

        ;POSITIONS COMMAND & DATA BUFFER POINTERS AT THE
        ;COMMAND # IN R5.  RETURNS POINTERS IN R4 & R3.

SEARCH: CLR     CMDNUM          ;CLEAR LINE #
        MOV     #COMST,R4       ;GET COMMAND START
        MOV     #DATST,R3       ;GET DATA START
1$:     CMP     R4,COMBUF               ;END OF FILE?
        BGE     2$              ;YES RETURN
        INC     CMDNUM          ;UPDATE LINE #
        CMP     CMDNUM,R5               ;EQUAL R5?
        BGE     2$              ;YES, DONE
        MOVB    (R4)+,R2        ;UPDATE COMMAND POINTER
        MOV     GETTAB(R2),R2   ;GET FORMAT ENTRY
        BEQ     1$              ;NO DATA MOVE ON
        JSR     PC,(R2)         ;UPDATE DATA POINTER
        BR      1$              ;CONTINUE
2$:     RTS     PC              ;RETURN

        ;SOLICIT A LINE #
FTLINE: TTISDL                  ;LINE # SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <LINE #: _>     ;NO, SOLICIT ONE
        TTILNW                  ;WAIT FOR REPLY
2$:     TTIDEC          ;CONVERT DECIMAL #
        BCS     3$              ;NOT DECIMAL
        TST     R0              ;ONLY POS LIENS
        BLE     1$              ;
3$:     RTS     PC              ;RETURN

        ;ROUTINE TO PRINT THE LINE #

LINPNT: MOV     CMDNUM,R1       ;
        MOV     R1,R0           ;
        PNTDEC                  ;PRITN IT
        CMP     R1,#99.         ;1 SPACE FI 3 DIGITS
        BGT     2$              ;
        CMP     R1,#9.          ;2 SPACES IF 2 DIGITS
        BGT     1$              ;
        PSPACE                  ;3 SPACES IF 1 DIGIT
1$:     PSPACE                  ;
2$:     PSPACE                  ;
        RTS     PC              ;RETURN


;SEQ148

.SBTTL          PARAMETER ENTRY SUBROUTINES
.REM    \
        REGISTER R3 IS USED FOR A PARAMETER INDEX.  PARAMETERS
ARE RETURNED IN R0 & R1 AS APPLICABLE.

\

        ;ROUTINES TO SOLICIT 36-BIT DATA

FTINST: TTICHR                  ;GET NEX CHARACTER
 
        CMP     R0,#'T          ;EXT COMMAND?
        BNE     1$              ;NO
        MOVB    #-2,@COMBUF     ;SET INDEX FOR CONSOLE COMMAND
        JMP     CONSPC          ;SPECIAL ENTRY FOR CONSOLE COMMAND
1$:     TTBACK                  ;BACK UP INPUT POINTER
        MOV     #IPROMT,R2      ;PROMT INSTRUCTION POINTER
        BR      DATFT           ;TEST FOR INPUT

FTDAT:  MOV     #DPROMT,R2      ;PROMT TEXT POINTER TO R2
        BR      DATFT           ;TEST FOR INPUT

FTCCW:  MOV     #CPROMT,R2      ;PROMPT COMMAND WORD POINTER
        BR      DATFT           ;TEST FOR INPUT

DATFT:  TTISDL                  ;DATA SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     MOV     R2,R0           ;POINT TO PROMTING TEXT
        PNTAL                   ;PRINT IT
        TTILNW                  ;GET REPLY
        
2$:     TTI36                   ;
        BCC     SAVDAT                  ;REPLY O.K.
        RTS     PC              ;ERROR RETURN
SAVDAT: MOV     #5,R2           ;
1$:     MOVB    (R0)+,(R3)+     ;SAVE DATA
        DEC     R2              ;
        BGT     1$              ;
        MOV     R3,R0           ;
        SUB     #5,R0           ;RO POINTS TO DATA
        RTS     PC              ;RETURN

DPROMT: .ASCIZ  %DATA: _%
IPROMT: .ASCIZ  %INSTRUCTION: _%
CPROMT: .ASCIZ  %COMMAND WORD: _%
        .EVEN


;SEQ149


        ;SOLICIT A CBUS COMMAND

FTCBUS: TTISDL          ;DATA SPECIFIED?
        BCS     1$              ;NO
        TTI36                   ;YES, 36-BIT FORMAT?
        BCC     11$             ;YES, SAVE IT
        BR      12$             ;NO, ERROR
1$:     CLR             EXAREA          ;CLEAR 36-BIT BUFFER
        CLR     EXAREA+2        ;
        CLRB    EXAREA+4        ;
        CMP     R0,#LF          ;CARRIAGE RETUR?
        BNE     3$              ;NO, SCAN COMMAND LIST
2$:     PMSG    <CBUS COMMAND: _>
        TTILNW                  ;GET REPLY
        BR      FTCBUS          ;GOT IT
3$:     CMP     R0,#'S          ;FIRST CHARACTER AN S?
        BNE     4$              ;NO
        TTICHR                  ;YES, GET NEXT CHARACTER
4$:     MOV     R0,R2           ;ASSEMBLE 2 CHARACTERS
        TTICHR
        SWAB    R0              ;
        BIS     R2,R0           ;
5$:     CLR     R2              ;CLEA COMMAND INDEX
6$:     CMP     R0,CBCMD(R2)    ;DO LOOKUP
        BEQ     7$              ;COMMAND FOUND
        INC     R2              ;UPDATE COMMAND INDEX
        INC     R2              ;
        CMP     R2,#12          ;

        BLE     6$              ;NEXT LOOKUIP   
        BR      12$             ;ERROR
7$:     BIS     CBBIT(R2),EXAREA+2      ;SET AN EBUS DTA BIT
8$:     TTICHR                  ;NEXT CHARACTER
        BCS     12$             ;BUFFER EMPTY
        CMP     R0,#40          ;SPACE?
        BEQ     12$             ;YES, ILLEGAL
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     10$             ;YES, DONE
        CMP     R0,#'/          ;SLASH?
        BEQ     9$              ;YES, GET NEXT COMMAND
        CMP     R0,#',          ;COMMA?
        BNE     8$              ;NO, SEARCH FOR PARAMETER
9$:     TTICHR                  ;GET FIRST CHARACTER
        BR      3$              ;NEXT COMMAND
10$:    MOV     #EXAREA,R0      ;POINT TO ASSEMBLED DATA
11$:    JMP     SAVDAT          ;SAVE DATA
12$:    SEC                     ;
        RTS     PC              ;ERROR RETURN


;SEQ150

        ;CBUS COMMAND LIST

CBCMD:  .ASCII  %RE%            ;RESET
        .ASCII  %TA%            ;START
        .ASCII  %DO%            ;DONE
        .ASCII  %CT%            ;CTOM
        .ASCII  %TO%            ;STORE
        .ASCII  %LO%            ;SLOW DATA REQUEST
        .ASCII  %FA%            ;FAST DATA REQUEST

CBBIT:  .WORD   BIT13           ;RESET
        .WORD   BIT12           ;START
        .WORD   BIT10           ;DONE
        .WORD   BIT9            ;CTOM
        .WORD   BIT8            ;STORE

        .WORD   BIT7            ;SLOW
        .WORD   BIT6            ;FAST

        ;SPECIAL ENTRY FOR 3 CHARACTERS SYNTAX CONSOLE COMMAND

CONSPC: TTBACK                  ;BACK UP INPUT 3 CHARACTERS
        TTBACK
        TTBACK

        ;ROUTINE TO SAVE ASCII TEXT & CONSOLE COMMANDS
FTCON:  MOV     R3,R1           ;SAVE DATA POINTER
1$:     TTICHR          ;GET A CHARACTER
        BCS     2$              ;END OF INPUT
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     2$              ;YES, TERMINATE
        MOVB    R0,(R3)+        ;NO SAVE CHARACTER
        BR      1$              ;GTET NEXT ONE
2$:     CLRB            (R3)+           ;STORE TERMINATOR
        MOV     R1,R0           ;POINT TO COMMAND
        RTS     PC              ;RETURN


;SEQ151

        ;ROUTINE TO SOLICIT AN ADDRESS

FTADR:  TTISDL                  ;ADDRESS SPECIFIED?
        BCC     RDADR           ;YES, USE IT
        BVS     ADRLST          ;COLON OR /, USE LAST ADDR
FTADX:  PMSG    <ADDRESS: _>    ;SOLICIT ADDRESS
        TTILNW          ;GET REPLY

RDADR:  TTI36                   ;
        BCC     SAVADR          ;GOT IT
        TST     R0              ;LAST ADR IF CR
        BEQ     ADRLST                  ;YES, USE LAST ADR
        SEC                     ;BAD REPLY, SET ERROR
        RTS     PC              ;RETURN

ADRLST: MOV     #LSTADR,R0      ;GET POINTER TO LAST ADDRESS

SAVADR: CMPB    2(R0),#17               ;FORMAT O.K.?
        BGT     FTADX           ;NO, TOO BIG
        MOVB    (R0),(R3)+      ;;SAVE DATA
        MOVB    (R0)+,LSTADR    ;UPDATE LAST ADDRESS
        MOVB    (R0),(R3)+      ;
        MOVB    (R0)+,LSTADR+1   ;
        MOVB    (R0),(R3)+      ;
        MOVB    (R0)+,LSTADR+2  ;
        MOV     R3,R0           ;
        SUB     #3,R0           ;R0 POINTS TO DATA
        RTS     PC              ;RETURN

        ;ROUTINE TO SOLICIT ADDRESS & DATA

ADRDAT: JSR     PC,FTADR                ;GET ADDRESS
        MOV     R0,R1           ;SAVE POINTER
        JSR     PC,FTDAT        ;DATA POINTER TO R0
        RTS     PC              ;RETURN

        ;ROUTINE TO SOLICIT # OF TICKS

FTICK:  TTISDL                  ;TICK COUNT SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <# OF TICKS: _>
        TTILNW
2$:     TTIDEC                  ;DECIMAL
        BCS     3$              ;FORMAT ERROR
        BMI     1$              ;NOT NEGATIVE
        MOVB    R0,(R3)+        ;SAVE COUNT
        SWAB    R0              ;
        MOVB    R0,(R3)+        ;
        SWAB    R0              ;
3$:     RTS     PC              ;RETURN


;SEQ152


        ;ROUTINE TO SOLICIT EXPECTED DATA

FASCII: TTISDL                  ;DELETE SPACES
        BCC     1$              ;NUMBER, BUFFER O.K.
        CMP     R0,#CR          ;CARRIAGE RETURN?
        BEQ     2$              ;YES, SOLICIT INPUT
        TTBACK                  ;NO, BACKUP INPUT
1$:     JMP     FTCON           ;SAVE STRING
2$:     PMSG    <EXPECTED: _>
3$:     TTILNW                  ;GET REPLY
        BR      FASCII

        ;ROUTINE TO SOLICIT A BEGINNING & ENDING ADDRESS
FTADR2: TTISDL                  ;1ST ADDRESS SPECIFIED?
        BCC     1$              ;YES, USE IT
        BVC     5$              ;NOT COLON OR /
        INCB    @COMBUF ;CHANGE COMMAND TO EN
        INCB    @COMBUF         ;
        CLC                     ;
        BR      9$              ;RETURN
1$:     TTI36                   ;YES, GET DATA
        BCS     9$              ;FORMAT BAD
        JSR     PC,SAVADR               ;YES, SAVE IT
        MOV     R0,R1           ;SAVE POINTER
        TTISDL                  ;GET 2ND ADR
        BCC     2$              ;GOT IT
        CMP     R0,#LF          ;CARRIAGE RETURN?
        BNE     4$              ;FORMAT ERROR
        MOV     R1,R0           ;SAVE SAME DATA
        BR      3$              ;
2$:     TTI36                   ;GET DATA
        BCS     4$              ;FORMAT ERROR
3$:     JSR     PC,SAVADR               ;SAVE 2ND ADR
        BR      8$              ;CLEANUP & RETURN
4$:     SUB     #3,R3           ;ERROR, BACKUP POINTER


;SEQ153

5$:     TST     CCLFLG          ;I OR J FILE ACTIVE?
        BNE     6$              ;YES, NO PROMPT
        PMSG    <STARTING ADDRESS: >

        TTILNW                  ;GET REPLY
        TTI36                   ;ADDRESS SPECIFIED?
        BCC     7$              ;YES
        TST     R0              ;NO, CARRIAGE RETURN?
        BEQ     6$              ;YES, USE LAST ADR
        SEC                     ;NO, ERROR
        BR      9$              ;RETURN
6$:     MOV     #LSTADR,R1              ;USE LAST ADDRESS
        MOV     R1,R0           ;
        JSR     PC,SAVADR               ;SAVE LAST ADDRESS TWICE
        JSR     PC,SAVADR       ;
        BR      9$              ;RETURN
7$:     JSR     PC,SAVADR       ;SAVE ADDRESS
        MOV     R0,R1           ;SAVE POINTER
        PMSG    <ENDING >       ;REQUEST SECOND ADDRESS
        JSR     PC,FTADX                ;SAVE IT
8$:     MOV     R0,R2   ;INTERTCHANGE R0 & R1
        MOV     R1,R0           ;
        MOV     R2,R1   ;
9$:     RTS     PC              ;RETURN


;SEQ154



        ;ROUTINE TO SOLICIT A CHANNEL #
FTCHAN: TTISDL                  ;CHANNEL SPECIFIED>
        BCC     GETCN           ;YES, USE IT
        TST     CHDFLT          ;DEFAULT SPECIFIED?
        BEQ     FTCHX           ;NO, SOLICIT #
        MOVB    CHDFLT,R0               ;UES, USE IT
        BR      SAVCH           ;
FTCHX:  PMSG    <CHANNEL #: _>  
        TTILNW
GETCN:  TTIOCT                  ;CONVERT OCTAL #
        BCS     CHERR           ;ERROR, NOT OCTAL
        CMP     R0,#7           ;CHECK SIZE
        BGT     CHERR           ;TOO BIG
SAVCH:  MOVB    R0,(R3)+        ;SAVE IT
        BMI     CHERR           ;ERROR IF NEGATIVE
        CLC                     ;
        RTS     PC              ;RETURN

CHERR:  SEC                     ;SET ERROR
        RTS     PC              ;RETURN

        ;SOLICIT CHANNEL AND COMMAND WORD

FTCHCW: JSR     PC,FTCHAN               ;GET CHANNEL
        BCS     1$              ;ERROR
        MOV     R0,R1           ;SAVE IT
        JSR     PC,FTCCW        ;GET CHANNEL COMMAND WORD
        MOV     R0,R2           ;POINTER TO R2
        MOV     R1,R0           ;CHANNEL TO R0
        MOV     R2,R1           ;POINTER TO R1
1$:     RTS     PC              ;RETURN

        ;SOLICIT CHANNEL EBUS DATA

FTQSIM: TST     AUTOIN          ;AUTO INSERT MODE?
        BNE     FTCSIM          ;YES, NO NEED FOR DATA QYUEUE
        TST     QUEBUF          ;DATA QUEUE SET?
        BNE     FTCSIM          ;YES, NO NEED TO SET QUEUE

        MOV     DATBUF,QUEBUF           ;QUEUE TO END OF DATA BUFFER


;SEQ155

FTCSIM: JSR     PC,FTCHAN               ;GET CHANNEL
        BCS     1$                      ;ERROR
        MOV     R0,R1           ;SAVE IT
        JSR     PC,FTCBUS               ;GET EBUS DATA
        MOV     R0,R2           ;POINTEW TO R2
        MOV     R1,R0           ;CHANNEL TO R0
        MOV     R2,R1           ;POINTER TO R1
1$:     RTS     PC              ;RETURN

        ;SOLICIT FLAG TO SET

SFLAG:  TTICHR
        CMP     R0,#'T          ;MUST BE A T
        BEQ     FTFLAG          ;O.K.
        TTBACK                  ;BACKUP POINTER
        POP     R0              ;DISCARD ENTRY POINT

        JMP     CONSED          ;SE OR SED CONSOLE COMMAND

        ;SOLICIT FLAG TO CLEAR

CFLAG:  TTICHR              ;NEXT CHARACTER
        CMP     R0,#'R          ;MUST BE AN R
        BEQ     FTFLAG          ;OK
        SEC                     ;ERROR
        RTS     PC              ;RETURN

FTFLAG: TTISDL                  ;DELETE SPACES
        BCS     2$              ;NUMBER?
1$:     TTIOCT                  ;YES, CONVERT TO OCTAL
        BCS     13$             ;NOT OCTAL, ERROR
        CMP     R0,#7          ;VALID CHANNEL #?
        BGT     12$             ;NO, TOO BIG
        BR      7$              ;USE FOR DEFAULT CHANNEL
2$:     CMP     R0,#CR          ;CARRIAGE RETURN?
        BNE     4$              ;DO, DON'T PROMPT
3$:     PMSG    <EBR, PMA, CACHE OR CHAN: _>
        TTILNW                  ;WAIT FR REPLY
        TTISDL          ;DELETE SPACES
        BCC     1$              ;NUMBER?


;SEQ156

4$:     CMP     R0,#'P          ;PMA FLAG?

        BEQ     7$              ;YES, DONE
        CMP     R0,#'E          ;EBR?
        BEQ     7$              ;YES
        CMP     R0,#'C          ;CACHE OR CHANNEL?
        BNE     12$             ;NO, ERROR
        TTICHR                  ;YES, NEXT CHARACTER
        CMP     R0,#'A          ;CACHE?
        BEQ     7$              ;YES, DONE
        CMP     R0,#'H          ;CHANNEL?
        BNE     12$             ;NO, ERROR
        CMP     R2,#SFLAG       ;SET FLAG?
        BNE     7$              ;NO, DONE
5$:     TTICHR                  ;SEARCH FOR SPACE OR END
        BCS     6$              ;END
        CMP     R0,#40          ;
        BEQ     1$              ;SPACE
        CMP     R0,#CR          ;
        BNE     5$              ;NEXT CHARACTER
6$:     JMP     FTCHX           ;SAVE CHANNEL #
7$:     MOVB    R0,(R3)+        ;SAVE CODE
        CMP     R0,#'E          ;PMA?
        BNE     11$             ;NO
8$:     TTICHR                  ;SEARCH FOR SPACE OR CR
        BCS     13$             ;ERROR
        CMP     R0,#40          ;
        BEQ     10$             ;
        CMP     R0,#CR          ;
        BNE     8$              ;CONTINUE SEARCH 
9$:     PMSG    <BASE PAGE: _>
        TTILNW                  ;GET REPLY
10$:    TTISDL                  ;SPACE DELETE
        BCS     13$             ;NON-NUMBER
        TTIOCT                  ;CONVERT TO OCTAL
        BCS     13$             ;ERROR, NOT OCTAL
        CMP     R0,#17777       ;TEST RANGE
        BGT     12$             ;ERROR, TOO BIG
        MOV     R0,EBRFLG       ;SET EBR FLAG
        MOVB    R0,(R3)+        ;SAVE PAGE
        SWAB    R0              ;
        MOVB    R0,(R3)+        ;
        MOV     #'E,R0          ;PUT E BACK IN R0
11$:    TST     R0              ;
        BPL     13$             ;ERROR IF NEGATIVE
12$:    SEC                     ;SET ERROR FLAG
13$:    RTS     PC              ;RETURN


;SEQ157

.SBTTL          PARAMETER RETRIEVAL SUBROUTINES
.REM    \
        REGISTER R3 IS USED FOR A PARAMETER INDEX.  R4 MUST NOT BE
DESTROYED.
\

        ;ROUTINE TO GET AN ASCII STRING

GASCII: MOV     R3,R1           ;POINT TO COMMAND
1$:     MOVB    (R3)+,R0        ;GET A CHARACTER
        BEQ     2$              ;TERMINATOR
        TST     PRINT.          ;PRINT?
        BEQ     1$              ;NO, CONTINUE SEARCH
        PNTCHR                  ;YES, PRINT A CHARACTER
        BR      1$              ;CONTINUE SEARCH
2$:     MOV     R1,R0           ;GET POINTER
        RTS     PC              ;RETURN

;ROUTINE TO ET A 22-BIT ADDRESS

GET22:  MOV     R3,R0           ;GET POINTER
        ADD     #3,R3           ;UPDAT BUFFER POINTER
        TST     PRINT.          ;PRINT?
        BEQ     1$              ;NO, RETURN
        MOV     R0,R2           ;
        PNT22S          ;PRINT ADDRESS
        MOV     R2,R0           ;
1$:     RTS     PC              ;RETURN

;ROUTINE TO GET 36-BIT DATA

GET36:  MOV     R3,R0           ;GET DATA POINTER
        ADD     #5,R3           ;UPDATE BUFFER POINTER
        TST     PRINT.          ;PRINT?
        BEQ     1$              ;NO, RETURN
        MOV     R0,R2           ;
        PNT36                   ;PRINT 36-BIT FORMAT
        MOV     R2,R0           ;
1$:     RTS     PC              ;RETURN


;SEQ158


        ;ROUTINE TO GET AN ADDRESS & 36-BIT OF DATA

GT2236: MOV     R3,R1           ;GET POINTER TO ADR
        ADD     #3,R3           ;UPDATE BUFFER POINTER
        MOV     R3,R0           ;GET POINTER TO DATA
        ADD     #5,R3           ;UPDAT BUFFER POINTER
        TST     PRINT.          ;PRINT?
        BEQ     1$              ;NO, RETURN
        MOV     R0,R2           ;
        MOV     R1,R0           ;
        PNT22S                          ;
        PMSG    <: >            ;
        MOV     R2,R0           ;
        PNT36                   ;PRINT DATA
        MOV     R2,R0           ;
1$:     RTS     PC              ;RETURN

        ;ROUTINE TO GET A STARTING & ENDING ADDRESS

GET222: MOV     R3,R0           ;GET FIRST ADR POINTER
        ADD     #3,R3           ;UPDATE BUFFER POINTER
        MOV     R3,R1           ;GET 2ND ADRT POINTER
        ADD     #3,R3           ;UPDATE BUFFER POINTER
        TST     PRINT.          ;PRINT?
        BEQ     3$              ;NO, RETURN
        MOV     R0,R2           ;
        PNT22S                  ;PRINT 1ST ADDRESS
        CMPB    (R1),(R2)       ;1ST & 2ND THE SAME?
        BNE     1$              ;
        CMPB    1(R1),1(R2)
        BNE     1$
        CMPB    2(R1),2(R2)     ;
        BEQ     2$              ;YES, DONT PRINT 2ND
1$:     PCOMMA                  ;
        MOV     R1,R0           ;
        PNT22S                  ;PRINT 2ND ADDRESS
2$:     MOV     R2,R0           ;
3$:     RTS     PC              ;RETURN


;SEQ159

        ;ROUTINE TO GET 16 BIT DECIMAL VALUE

GETDEC: PUSH    R1
        CLR     R1
        BISB    (R3)+,R1        ;GET LOW-ORDER BYTE
        MOVB    (R3)+,R0        ;GET HIGH-ORDER BYTE
        SWAB    R0              ;MAKE IT HIGH ORDER
        BIS     R0,R1           ;COMBINE THEM
        TST     PRINT.          ;PRINT?
        BEQ     1$              ;NO
        MOV     R1,R0           ;YES
        PNTDEC
1$:     MOV     R1,R0
        POP     R1

        RTS     PC


;SEQ160

        ;ROUTINE TO GET CHANNEL & 36-BITS OF DATA

GETC36: MOVB    (R3)+,R2                ;CHANNEL TO R2
        TST     CHDFLT          ;DEFAULT SET?
        BEQ     1$              ;NO
        MOVB    CHDFLT,R2               ;YES, USE DEFAULT
        TST     XCT.            ;EXECUTE?
        BEQ     2$              ;NO, DON'T PRINT CHANNEL
1$:     TST     PRINT.          ;PRINT?
        BEQ     2$              ;NO
        MOV     R2,R0           ;YES, PRINT CHANNEL
        PNTOCS                  ;
2$:     MOV     R3,R1           ;POINT TO DATA
        ADD     #5,R3           ;UPDATE BUFFER POINTER
        TST     PRINT.          ;PRINT SOURCE?
        BEQ     3$              ;NO
        PCOMMA                  ;YES, PRINT A COMMA
        MOV     R1,R0           ;PRINT THE DATA
        PNT36                   ;
3$:     MOV     R2,R0           ;CHANNEL TO R0
        RTS     PC              ;RETURN

        ;ROUTIENS TO GET FLAG PARAMETERS

GSFLAG: MOVB    (R3)+,R0        ;GET FLAG PARAMETER
        CMP     R0,#'E          ;EBR?
        BNE     1$              ;NO
        MOVB    (R3)+,EBRFLG    ;YES, SET EBR FLAG
        MOVB    (R3)+,EBRFLG+1  ;
1$:     TST     PRINT.          ;PRINT SOURCEW?
        BEQ     2$              ;NO, RETURN
        MOV     R0,R1           ;YES, SAVE PARAMETER
        PNTBAK                  ;DISCARD SPACE
        PMSG    <T >            ;EXTEND COMMAND
        BR      PRFLAG          ;PRINT FLAG PARAMETER
2$:     RTS     PC


;SEQ161

GCFLAG: MOVB    (R3)+,R0        ;GET FLAG PARAMETER
        CMP     R0,#'E          ;EBR?
        BNE     1$              ;NO
        CLR     EBRFLG          ;YES, CLEAR EBR FLAG
1$:     TST     PRINT.          ;PRINT SOURCE?
        BEQ     2$              ;NO, RETURN
        MOV     R0,R1           ;YES, SAVE PARAMETER
        PNTBAK          ;DISCARD SPACE
        PMSG    <R >            ;EXTEND COMMAND
        BR      PRFLAG          ;PRINT FLAG PARAMETER
2$:     RTS     PC              ;RETURN

        ;PRINT FLAG PARAMETER

PRFLAG: CMP     R1,#'A          ;CACHE>?
        BNE     1$              ;NO
        PMSG    <CACHE EN>      
        BR      4$              ;DONE
1$:     CMP     R1,#'P          ;PMA?
        BNE     2$              ;NO
        PMSG    <PMA TO ERG>
        BR      4$              ;DONE
2$:     CMP     R1,#'E          ;EBR?
        BNE     3$              ;NO
        PMSG    <EBR >

        MOV     EBRFLG,R0               ;VALUE>
        BEQ     4$              ;NO
        PNTOCS                  ;YES, PRINT IT
        BR      4$              ;DONE
3$:     PMSG    <CHAN >
        CMP     R1,#'H          ;CLEAR DEFAULT?
        BEQ     4$              ;YES, DONE
        MOV     R1,R0           ;NO, PRINT CHANNEL
        PNTOCS                  ;
4$:     MOV     R1,R0           ;FLAG PARAMETER TO R0
        RTS     PC              ;RETURN



;SEQ162

.SBTTL          EXTENSION COMMAND SUBROUTINES
.REM    \
        REGISTERS R3 & R4 ARE RESERVED FOR BUFFER OPERATIONS AND
MUST NOT BE DESTROYED.
\

        ;CONSOLE COMMANDS

COMCON: CMPB    (R0),#'P        ;FIRST CHARACTER A P?
        BNE     3$              ;NO
        MOV     R0,R1           ;SAVE POINTER
        INC     R1              ;POINT TO NEXT CHARACTER
        MOVB    (R1)+,R2        ;GET A CHARACTER
        CMPB    R2,#SPACE       ;P COMMAND?
        BNE     5$              ;NO
1$:     MOVB    (R1)+,R2        ;SEARCH FOR PERIOD OR TERMINATOR
        BEQ     5$              ;NO EXTENSION, FORMAT OK
        CMPB    R2,#'.          ;
        BNE     1$              ;PERIOD NOT FOUND
        CMPB    (R1)+,#'B       ;.BIN FORMAT?
        BEQ     2$              ;YES, ILLEGAL
        INC     R1              ;BYPASS NEXT CAHRACTDER
        CMPB    (R1),#'1         ;A11 FORMAT?
        BNE     5$              ;NO
2$:     PNTCI                   ;PRINT?
                '?              ;
        JMP     INDRST          ;TREAT LIKE ^C
3$:     CMPB    (R0),#'I         ;I COMMAND?
        BEQ     4$              ;YES
        CMPB    (R0),#'J        ;J COMMAND?
        BNE     5$              ;NO
4$:     INC     CCLFLG          ;SET I OR J FILE ACTIVE
5$:     TST     CMPARE          ;COMPAE RESULT?
        BNE     7$              ;YES, DO IT
        PRGCMD                  ;NO, DO CONSOLE COMMAND
        BCC     9$              ;ERROR?
        BPL     9$              ;YES,R ETURN
6$:     PMSG    <^C\>           ;CONTROL C, ECHO IT
        JMP     INDRST          ;BACK TO COMMAND MODE
7$:     PRGNPT          ;CONSOLE COMMAND, NO PRINT
        BCC     8$              ;O.K.
        BMI     6$              ;CONTROL C
        PNTCI                   ;KLDCP DETECTED ERROR
                NULL            ;PRINT ERROR MSG
        SEC                     ;SET ERROR FLAG
        BR      9$              ;RETURN
8$:     PNTBAK                  ;DIUSCARD CR/LF
        PNTBAK                  ;
        JSR     PC,BUFCOM       ;COMPARE ACTUAL & EXPECTED
9$:     RTS     PC              ;RETURN

;SEQ163

        ;RESET MBOX

XRESET: JSR     R5,RSTMBX               ;DO MBO9X RESET ROUTINE
        RTS     PC              ;RETURN


        ;ASCII STRING COMPARE ROUTINE

BUFCOM: CLR     CMPARE          ;CLEAR COMPARE FLAG
        MOV     CMPPTR,R0               ;GET COMPARE POINTER
        MOV     TTYBUF,R1       ;GET TTY BUFFER POINTER
1$:     TSTB    (R0)            ;COMPARE DONE?
        BEQ     5$              ;YES
        CMPB    (R0)+,(R1)+     ;NO, COMPARE A BYTE
        BEQ     1$              ;COMPARE O.K. ?
        CMPB    -1(R0),#'?     ;NO, WILD CARD?
        BEQ     1$              ;YES
        CMPB    -1(R0),#'*     ;IGNORE SOME TEXT?
        BNE     4$              ;NO, ERROR
2$:     CMPB    (R0),(R1)+      ;NEXT COMPARE FOUND?
        BNE     3$              ;NO
        INC     R0              ;YES, UPDATE COMPARE POINTER
        BR      1$              ;CONTINUE COMPARISON

3$:     TSTB    -1(R1)          ;END OF TTY BUFFER?
        BNE     2$              ;NO, CONTINUE
4$:     PMSG    < RECEIVED>     ;NO, PRINT VALUE RECEIVED

        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        MOV     CMPPTR,R0       ;
        PNTAL                   ;PRINT VAALUE EXPECTED
        PMSG    <  EXPECTED\>

        SEC                     ;SET ERROR FLAG
        BR      8$              ;RETURN
5$:     TSTB    (R1)            ;END OF ACTUAL?
        BEQ     6$              ;YES, DONE
        CMPB    (R1),#SPACE     ;SPACE?
        BNE     4$              ;NO, ERROR
6$:     TST     PRINT.          ;PRINT FLA SET?
        BNE     7$              ;YES, PRINT RESULT
        PNTRST          ;RESET OUTPUT BUFFER
        BR      8$              ;RETURN
7$:     PCRLF                   ;PRINT BUFFER
8$:     RTS     PC


;SEQ164

        ;EXAMIN MEMORY

XEXAM:  MOVB    (R0),LSTADR     ;SAVE FIRST ADR

        MOVB    1(R0),LSTADR+1  ;
        MOVB    2(R0),LSTADR+2  ;
        MOV     #LSTADR,R2      ;POINT TO IT
        MOV     R2,R0           ;
        JSR     PC,EXAMR0       ;DO EXAMINE
        BCS     5$              ;ERROR,RETURN
1$:     MOV     R1,R5           ;
        MOV     R2,R0           ;
2$:     CMPB    (R0)+,(R5)+     ;LAST ADR = CURRENT ADR?
        BNE     3$              ;NO, NEXT ONE
        CMP     R0,LSTADR+2     ;
        BLE     2$              ;
        BR      5$              ;YES, RETURN
3$:     JSR     PC,INCHK        ;CHECK INPUT    

        BCC     4$              ;ALTMODE
        JSR     PC,XEXMN                ;EXAMINE NEXT
        BCS     5$              ;ERROR, RETURN
        BR      1$              ;CHECK DONE
4$:     JMP     INDRST          ;BACK TO COMMAND LEVEL
5$:     RTS     PC              ;RETURN

        ;EXAMINE NEXT MEMORY LOCATION

XEXMN:  ADD     #1,LSTADR               ;UPDATE LAST ADDRESS
        ADC     LSTADR+2        ;
        MOV     #LSTADR,R0      ;POINT TO IT
        JSR     PC,EXAMR0       ;DO EXAMINE
        RTS     PC              ;RETURN

EXAMR0: SPCEXM
        BCS     HALTER          ;ERROR
        PUSH    R0
        MOV     #LSTADR,R0      ;
        PNTADR          ;PRINT ADDRESS
        PNTCI           ;PRINT /
                '/              ;
        POP     R0
        PNT36              ;PRINT DATA
ENDOUT: TST     CMPARE          ;COMPARE ACTIVE?
        BNE     1$              ;YES, DON'T PRINT YET
        PCRLF                   ;
1$:     RTS     PC              ;RETURN


;SEQ165

        ;DEPOSIT MEMORY

XDEPOS: MOVB    (R1),LSTADR     ;SAVE ADDRESS
        MOVB    1(R1),LSTADR+1  ;
        MOVB    2(R1),LSTADR+2  ;
        BR      DODEP           ;DO DEPOSIT
XDEPN:  ADD     #1,LSTADR       ;DEPOSIT NEXT
        ADC     LSTADR+2        ;
        MOV     #LSTADR,R1      ;ADDRESS POINTER
DODEP:  SPCDEP
        BCS     HALTER          ;ERROR
        RTS     PC              ;RETURN

        ;CONSOLE EXECUTE

XEXCT:  JSR     R5,XQT          ;DO EXECUTE
        BCS     HALTER          ;HALT LOOP ERROR
        RTS     PC              ;O.K., RETURN

HALTER: PMSG    <EX HALTLP ERR\>

        SEC                     ;SET C-BIT
        RTS     PC              ;ERROR RETURN

        ;ENABLE CACHE
ECACHE: MOV     #-1,CSHFLG      ;SET FLAG
        MOV     #CSHALW,R0      ;SET LOOK & LOAD
        XQT                     ;WILL REPEAT ON NEXT RM
        BCC     1$              ;O.K.
        JMP     HALTER          ;HALT LOOPERROR
1$:     RTS     PC              ;RETURN

        ;DISAVLEW CACHE

DCACHE: CLR     CSHFLG          ;CLEAR FLAG
        MOV     #CSHCLR,R0              ;CLEAR LOOK & LOAD
        JSR     R5,XQT  ;
        BCC     1$              ;O.K.
        JMP     HALTER          ;HALT LOOPE RROR
1$:     RTS     PC              ;RETURN


;SEQ166

        ;CONFIGURE EPT

XCEPT:  MOV     R1,CHFLAG               ;SET CHANNEL FLAG
        JSR     R5,SETEPT               ;DO IT
        BCC     1$              ;ERROR?
        PMSG    <DEPOSIT ERROR\>

        SEC                     ;YES, SET ERROR FLAG
1$:     RTS     PC              ;RETURN

        ;SIMULATE CBUS COMMAND

XSIMC:  JSR     R5,SIMBUS               ;DO IT
        BCC     1$              ;ERROR?
        PMSG    <CBUS SEL TIMEOUT\>
        SEC                     ;YES, SET ERROR FLAG
1$:     RTS     PC              ;RETURN

        ;QUEUE CBUS COMMAND

XQSIM:  MOV     QUEPTR,R0       ;GET QUEUE POINTER
        DEC     R1              ;BACKUP DATA POINTER
        MOV     R1,(R0)+        ;SAVE COMMAND INFO POINTER
        CMP     R0,#QUEUE+128.  ;QUEUE FULL?
        BGE     1$              ;YES
        MOV     R0,QUEPTR               ;NO, UPDATE QUEUE POINTER
        TST     PMAFLG          ;PMA TO ERG ENABLED?
        BNE     2$              ;YES, RETURN
        JMP     EPMA            ;NO, ENABLE IT
1$:     PMSG    <QUEUE FULL\>

        SEC                     ;SET ERROR FLAG
2$:     RTS     PC              ;RETURN

QUEPOS: .WORD   QUEUE           ;CURRENT POSITION IN QUEUE
QUEPTR: .WORD   QUEUE           ;DEPTH QUEUE LOADED
QUEUE:  .BLKW   64.             ;QUEUE, MAX IS 64


;SEQ167

        ;TRACE 1 MEMORY REFERENCE
XTRC1:  INCB    TRCMEM          ;SET RACE ONE MEM REF
        BR      MEMTRC          ;DO TRACE

        ;TRACE ALL MEMORY REFERENCES
XTRC:   INCB    TRCMEM+1                ;SET TRACE ALL MEM REFS

MEMTRC: CLR     NOHDR           ;ALLOW HEADER
        CLR     QUEBUF          ;CLEAR QUEUE DATA FLAG
        DFWRTT                  ;ENABLE PMA TO ERG
                KLB26,76        ;

1$:     CMP     QUEPOS,QUEPTR   ;QUEUE EMPTY?
        BEQ     5$              ;YES, BYPASS CBUS SIM
        MOV     @QUEPOS,R1      ;GET QUEUE ENTRY
        MOVB    (R1)+,R0        ;GET CHANNEL
        TST     CHDFLT          ;DEFAULT ACTIVE?
        BEQ     2$              ;NO
        MOVB    CHDFLT,R0       ;YES, USE IT
2$:     JSR     PC,XSIMC                ;SIMULATE COMMAND
        BCS     10$             ;ERROR
        ADD     #2,QUEPOS               ;UPDATE QUEUE POSITION
        CMP     QUEPOS,QUEPTR   ;QUEUE EXHAUSTED?
        BLT     3$              ;NO
        MOV     #QUEUE,QUEPTR   ;YES, RESET QUEUE
        MOV     #QUEUE,QUEPOS   ;
3$:     TST     MEMRQ           ;MEM REF  DETECTED?
        BEQ     4$              ;NO
        JSR     PC,PNTMEM               ;YES, PRINT IT
4$:     TST     TRCMEM          ;DONE?
        BNE     1$              ;NO, CHEKC QUEUE
5$:     DFRDT                   ;SBUS ADR HOLD?
                162             ;
        TBIT    31              ;
        BNE     7$              ;YES
        TST     TRCMEM          ;DONE?
        BEQ     7$              ;YES
6$:     FIND    <162,31,1>      ;GET TO SBUS ADR HOLD
        BCS     9$              ;NO REFERENCE, DONE
        GETMEM

        JSR     PC,PNTMEM               ;PRINT IT
7$:     FIND    <162,31,0>      ;WAIT FOR -SBUS ADR HOLD
        BCC     8$              ;
        PMSG    <MBOX HUNG\>
        SEC                     ;SBUS ADR HOLD STUCK ON
        BR      10$             ;ERROR RETURN


;SEQ168

8$:     TST     TRCMEM          ;DONE WITH TRACE?
        BNE     6$                      ;NO
9$:     CLR     TRCMEM          ;YES, CLEAR TRACE FLAG
10$:    JMP     ENDOUT          ;FINISH OUTPUT

        ;PRINT MEM STATUS

PNTMEM: JSR     PC,CRIN         ;CR/LF - CHECK FOR INPUT
        BCS     1$              ;NOT ALTMODE
        JMP     INDRST          ;ABORT
1$:     TST     NOHDR           ;FLAG SET?

        BNE     2$              ;YES, BYPASS HEADER
        PMSG    <RQ0  RQ1  RQ2  RQ3  RD  WR  SBUS ADR\>
        INC     NOHDR           ;SET NO HEADER FLAG
        JSR     PC,INCHK                ;CHEKC FOR INPUT
        BCS     2$              ;NOT ALTMODE
        JMP     INDRST          ;ABORT
2$:     PSPACE
        MOV     MEMTAB,R1       ;GET REQUEST DATA
        SWAB    R1              ;LEFT JUSTIFY
        PUSH    R2
        MOV     #4,R2           ;RQ COUNT
3$:     JSR     PC,PNTRQ                ;PRINT A REQUEST
        PSPACE
        DEC     R2              ;RQS DONE?
        BGT     3$              ;NO, LOOP AGAIN
        JSR     PC,PNTRQ        ;PRINT RD RQ
        JSR     PC,PNTRQ         ;PRINT WR RQ
        PNT22S  MEMTAB+1        
        CLRB    TRCMEM          ;CLEAR ONCE-ONLY TRACE
        POP     R2
        RTS     PC              ;RETURN


;SEQ169

PNTRQ:  CLR     R0              ;PRINT A BIT
        ROL     R1              ;GET BIT FROM R1
        ROL     R0              ;PUT IT IN R0
        PNTOCS                  ;PRINT IT
        PSPACE                  ;3 SPACES
        PSPACE                  ;
        PSPACE                  ;
        RTS     PC              ;RETURN

NOHDR:  .WORD   0               ;ZERO FOR HEADER

        ;PRINT CCW ADDRESS REGISTER

XCCWA:  JSR     R5,CCWRD                ;GET IT
        JSR     R5,PNT22A       ;PRINT IT
        JMP     ENDOUT          ;ENDOIUTPUT

        ;UPDATE DEFAULT CHANNEL

XNEXTC:TST      CHDFLT          ;DEFAULT SET
        BNE     1$              ;YES
        INCB    CHDFLT  ;NO, SET DEFAULT = CH0
        BR      2$              ;DONE
1$:     INCB    CHDFLT          ;UPDATE DEFAULT
        BICB    #370,CHDFLT     ;CLEAR EXTRA BITS
        BNE     2$              ;BACK TO CHANNEL 0?
        SEC                     ;YES, SET END
        BR      3$              ;
2$:     CLC                     ;CLEAR END DEFAULT
3$:     RTS     PC              ;RETURN
 
        ;PRINT DEFAULT CHANNEL
 
XCHPNT: TST     CHDFLT          ;DEFAULT SET?
        BNE     1$              ;YES
        PMSG    <NO DEFAULT\>
        SEC                     ;SET ERROR
        BR      2$              ;RETURN
1$:     PMSG    <CHANNEL >
        MOVB    CHDFLT,R0       ;PRINT IT
        PNTOCS
        JMP     ENDOUT          ;END OUTPUT
2$:     RTS     PC              ;RETURN

;SEQ170

        ;SET COMMAND

XSET:   CMP     R0,#'A          ;ENABLE CACHE?
        BNE     1$              ;NO
        JMP     ECACHE          ;YES, DO IT
1$:     CMP     R0,#'P          ;ENABLE PMA TO ERG?
        BNE     2$              ;NO
        JMP     EPMA            ;YES, DO IT
2$:     CMP     R0,#'E          ;EBR?
        BEQ     EBRSET          ;YES, SET EXEC BASE
        MOVB    R0,CHDFLT       ;SET CHANNEL DEFAULT
        INCB    CHDFLT+1        ;
        CLC                     ;
        RTS     PC              ;RETURN

        ;CLR COMMAND

XCLR:   CMP     R0,#'A          ;DISABLE CACHE?
        BNE     1$              ;NO
        JMP     DCACHE          ;YES, DO IT
1$:     CMP     R0,#'P          ;DISABLE PMA TO ERG?
        BNE     2$              ;NO
        JMP     DPMA            ;YES, DO IT
2$:     CMP      R0,#'E         ;EBR?
        BEQ     EBRSET          ;YES, CLEAR EXEC BASE
        CLR     CHDFLT          ;CLEAR CHANNEL DEFAULT
        RTS     PC              ;RETURN

        ;SET EXEC BASE REGISTER

EBRSET: JSR     R5,SETEBR               ;CALL EBR SUBROUTINE
        RTS     PC              ;RETURN

        ;ENABLE PMA TO ERGH

EPMA:   MOV     R0,PMAFLG               ;SET PMA FLAG
        DFWRTT                  ;ENABLE PMA TO ERG
                KLB26           ;
                76              ;
        RTS     PC              ;RETURN

;       DISABLE PMA TO ERG

DPMA:   CLR     PMAFLG          ;CLEAR PMA FLAG
        DFWRTT                  ;DIABLE PMA TO ERG
                ZERO..          ;L
                76              ;
        RTS     PC              ;RETURN

KLB26:  WD36    0000,0000,1000

        .EVEN


;SEQ171

        ;STANDARD CACHE REFILL ALGORITHM LOAD.  DESTROYS AC1-AC17

XUSE:   CRRSTD
        BCS     ERRUSE          ;ERROR
        RTS     PC              ;RETURN

        ;USE ALGORITHM FOR  1 CACHE.  DESTROYS AC1-AC6

XC0:    CLR     R0              ;USE CACHE 0
        BR      XONE            ;
XC1:    MOV     #1,R0           ;USE CACHE 1
        BR      XONE            ;
XC2:    MOV     #2,R0           ;USE CACHE 2
        BR      XONE           ;
XC3:    MOV     #3,R0           ;USE CACHE 3
XONE:   CRRONE
        BCS     ERRUSE          ;ERROR
        RTS     PC              ;RETURN

ERRUSE: PMSG    <USE PROGRAM TIMEOUT\>

        SEC                     ;SET C-BIT
        RTS     PC              ;RETURN

        ;INVALIDATE CACHE.  DESTROYS AC1-AC4

XINVAL: INVAL

        BCS     CCAERR          ;ERROR
        RTS     PC              ;O.K., RETURN

        ;VALIDATE CORE, DESTROYS AC1-AC4

XVALCR: VALCOR
        BCS     CCAERR          ;ERROR
        RTS     PC              ;O.K., RETURN

CCAERR: PMSG    <CCA TIMEOUT\>
        SEC                     ;SET C-BIT
        RTS     PC              ;RETURN


;SEQ172

        ;COMPARE NEXT RESULT

XCMPRE: MOV     R0,CMPPTR               ;SAVEW COMPARE POINTER
        INCB    CMPARE          ;SET COMPARE NEXT FLAG
        CLC                     ;CLEAR ERROR
        RTS     PC

        ;DO A SPECIFIED BURST AND REPORT CHANGES

COMB:   ADD     R0,TICK         ;INCREASE TICK CTR
        JSR     PC,LBURST               ;DO THE BURST
        JSR     PC,COMR         ;READ AND REPORT CHANGES
        RTS     PC

        ;FIND A TICK BY SINGLE STEPPIN N TIMES

COMF:   MOV     R0,LCHANG      ;SAVE DESTINATION
        CLR     BSTFG           ;MAKE SURE NO BURSTS
1$:     CMP     LCHANG,TICK             ;THERE OR MAYBE PAST?
        BLE     2$              ;NO TICKS, THAT'S CERTAIN
        JSR     PC,TICKIT
        JSR     PC,READIN       ;READ NEW STATE
        BR      1$              ;TRY AGAIN

2$:     BNE     3$              ;CANT "UNTICK"
        JSR     PC,REPCHG               ;REPOT LATEST CHANGES
        CLC
        RTS     PC

3$:     SEC                     ;SET ERROR FLAG
        RTS     PC


;SEQ173

        ;GO FOREVER SINGLE STEPPING AND REPORTING

COMG:   MOV     #1000,DTESTA    ;SET HALT LOOP BIT
        JSR     PC,READIN               ;READ STATE
        CLR     TICK
        CLR     BSTFG           ;NOT BURST MODE

        ;CONTINUE EITHER A PAUSED COMG OR COMM

COMC:   JSR     PC,TICKIT               ;DO STEP OR BURST
        JSR     PC,READIN               ;READ NEW STATES
        JSR     PC,REPCHG               ;FIND AND REPORT CHANGES
        BCC     1$              ;KEEP GOING
        RTS     PC              ;TOO MANY TICKS, NO CHANGE
        
1$:     BIT     #BIT15!BIT14,TSWITCH    ;ARE EITHER E OR MBOX ENABLED?
        BEQ     3$              ;IF NOT, DON'T LOOK AT HALTED
        BIT     #1000,@DTDIAG   ;HALTED?
        BEQ     2$              ;NO
        BIT     #1000,DTESTA    ;WAS IT BEFORE?
        BNE     3$              ;YES,M NOTHING NEW
        MOV     @DTDIAG,DTESTA  ;NO, SAVE NEW STATE
        PFORCE
        PMSG    <\** EBOX HALTED **\>

        RTS     PC              ;QUIT
2$:     CLR     DTESTA          ;OUT OF HALT LOOP
3$:     TST     TTALFG          ;TRYING TO STOP ME ?
        BEQ     COMC            ;KEEP GOING
        RTS     PC              ;RETURN


;SEQ174

        ;READ ALL ACTIVE REGISTERS AND BITS AND STORE AWAY


COMR:   JSR     PC,READIN
        JSR     PC,REPCHG
        RTS     PC

READIN: MOV     #DSTSIZ/2,R0    ;NBR OF WORDS IN BUFFERS
        MOV     #NEWSTA,R1      ;POINT TO LAST STATE OF BITS
        MOV     #OLDSTA,R2      ;MOVE TO HERE
1$:     MOV     (R1)+,(R2)+     ;MAKE OLD LIKE NEW
        DEC     R0
        BNE     1$
;NOW LOOK AT REQUESTS FOR 8-READ GROUPS
        CLR     R2              ;REQUEST Q INDEX
;NOW FILL BUFFER WITH 8 DIAG WORDS AND STORE AWAY
2$:     JSR     PC,RDGRP                ;DO 8 READS TO INPUT BUFFER
        JSR     PC,EBSTAT               ;GATHER EBUS BIT ACTIVITY
        MOV     COMRQ(R2),RQCURR      ;GET NEXT REQUEST BIT WORD
        BEQ     5$              ;BR IF NONE FOR THIS GROUP
        MOV     #1,RQMSK        ;RESET REQUEST DETECTION MASK
        MOV     R2,R2SAV                ;FREE UP REGISTER
        MOV     COMRP(R2),RQLIST        ;PTR TO CHAIN
3$:     BIT     RQMSK,RQCURR    ;TEST NEXT REQUEST BIT
        BEQ     4$              ;NOT ON, ADVANCE POINTERS
        BIC     RQMSK,RQCURR    ;SHUT OFF IF ONE
        MOV     @RQLIST,R5      ;GET FIRST LINK OF CHAIN
        JSR     PC,DFSTOR       ;GO FOLLOW STORAGE LIST
4$:     ASL     RQMSK           ;POINT TO NEXT RQ BIT
        ADD     #2,RQLIST               ;ADVANCE CHAIN POINTER
        TST     RQCURR          ;BY ANY CHANCE FINISHED?
        BNE     3$              ;BR IF NOT
        MOV     R2SAV,R2        ;YES, RESTORE Q INDEX
5$:     TST     (R2)+
        CMP     R2,#2*8.
        BNE     2$              ;DO FOR 8 GROUPS
        RTS     PC

        ;DO ONE SINGLE STEP

COMS:   CLR     BSTFG
        JSR     PC,TICKIT
        JSR     PC,READIN               ;READ NEW STATE
        MOV     TICK,LCHANG
        JSR     PC,REPCHG               ;REPORT ANY CHANGES
        CLC
        RTS     PC


        ;CLEAR THE TICK COUTNER AND CHANGE TICK MEMORY

COMI:   CLR     TICK
        CLR     LCHANG
        RTS     PC


;SEQ175

        ;PRINT EBUS BIT ACTIVITY STATISTICS

COMP:   TST     TTALFG          ;DUMP STOPPED>
        BNE     2$              ;YES, DON'T PRINT
        PMSG    <\		EBUS BIT ACTIVITY>

        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        PMSG    <		SINCE LAST P OR D>

        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        PMSG    <FR GRP    LOGICAL AND   >

        PMSG    <	LOGICAL OR>

        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        PMSG    <          (1'S ALWAYS HIGH)>

        PMSG    <	(0'S ALWAYS LOW)>

        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        CLR     R2              ;SET INDEX


;SEQ176


1$:     PMSG    <FR 1>

        MOV     R2,R0           
        ASR     R0              ;MAKE TENS DIGIT
        ADD     #60,R0          ;CNVRT TO ASCII
        PNTCHR
        PMSG    <X	>
        MOV     EBSAND(R2),R0   ;POINT TO .AND.
        PNT36
        PNTCI,"		;2 TABS
        MOV     EBSOR(R2),R0    ;POINT TO .OR.
        PNT36
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        TST     (R2)+
        CMP     R2,#20
        BLT     1$              ;DO EIGHT LINES
        JSR     PC,TOTANR               ;COMPUT TOTALS
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        BCC     2$              ;ALTMODE?
        PMSG    <TOTAL	>
        MOV     #GRDAND,R0      ;GET FRAND.AND.
        PNT36
        PNTCI,"		;2 TABS
        MOV     #GRDOR,R0               ;GET GRAND .OR.
        PNT36
        PCRLF
2$:     JSR     PC,IANDOR               ;CLLEAR AALL BUFFERS
        RTS     PC


;SEQ177

        ;SWITCH SETTING/CLEARING DIAGLOGUE.




CSWT:   JSR     PC,CLEARQ       ;SHUT ALL OFF FIRST
        PFORCE
        PMSG    <ANSWER Y, N, OR "CR" (NO CHANGE)\>

        PMSG    <DO YOU WANT (SIGNALS)?:\>

        MOV     #BIT15,R3       ;SWITCH MASK
        CLR     R4
1$:     MOV     SWTNAM(R4),R0   ;PTR TO NAME
        PNTAL                   ;PRINT IT
        MOV     #DEFY,R0        ;ASSUME Y IS DEFAULT
        BIT     R3,TSWITCH              ;TEST IT
        BNE     2$              ;BR IF ON (Y)
        MOV     #DEFN,R0        ;NO, OFF
2$:     PNTAL           ;PRINT CURRENT STATE
        TTILIN
        BCS     CSWT            ;IF INPUT TIMEOUT
        TTIYES          ;GET ANSWER
        BCS     4$              ;USE DEFUALT
        BMI     3$              ;TURN OFF (NO)
        BIS     R3,TSWITCH      ;TURN ON (YES)
        BR      4$              
3$:     BIC     R3,TSWITCH      ;TURN OFF SWITCH
4$:     BIT     R3,TSWITCH      ;TEST NEW STATE
        BEQ     5$              ;NOT ON,D O NOTHING
        PUSH    R3

        JSR     PC,@SWTACT(R4)  ;GO TURN ON CODE
        POP     R3

5$:     CLC
        ROR     R3              ;MASK TO NEW POS
        TST     (R4)+           ;UP INDEX
        CMP     SWTNAM(R4),#REGIS
        BNE     6$
        PMSG    <DO YOU WANT (REGISTERS)?:\>

6$:     CMP     R4,#16.         ;LOOK FOR DONE
        BLT     1$              ;MORE

        CLR     ALLRFG
        PMSG    <PRINT UNCHANGED REGS?  N/   _>
        TTILIN
        BCS     CSWT
        TTIYES
        BCS     62$
        BMI     62$
        MOV     #-1,ALLRFG      ;FORCE ALL REGISTER PRINT
        BR      63$


;SEQ178

62$:    CLR     ALLRFG          ;PRINT ONLY CHANGED REGS

63$:
        PMSG    <NO CHANGE LIMIT >
        MOV     NTLIMT,R0       ;CURRENT VALUE
        PNTDEC
        PMSG    </   _>

7$:     TTILIN
        BCS     7$
        TTIDEC          ;GET NEW VALUE
        BCS     8$              ;
        TST     R0              ;SEE IF LEGIT
        BMI     8$
        BEQ     8$
        MOV     R0,NTLIMT       ;SET NEW VALUE
8$:     CLR     EBAFLG          ;NO EBUS PRINT
        PMSG    <PRINT EBUS ACTIVITY EVERY CLOCK TICK N/  _>
        TTILIN
        BCS     9$
        TTIYES
        BCS     9$
        BMI     9$
        MOV     #-1,EBAFLG      ;FORCE EBUS ACTIVITY PRINT
9$:     MOV     #-1,SHRTPT      ;SET PRINT TRUE ONLY
        PMSG    <DUMP ONLY TRUE SIGNALS  Y/  _>
        TTILIN
        BCS     10$
        TTIYES
        BCS     10$
        BPL     10$
        CLR     SHRTPT          ;FULL PRINT - TRUE AND FALSE

10$:    PNORML
        CLC
        RTS     PC              ;RETURN


;SEQ179

        ;DEFAULT SWITCH SETTER, USES TSWITCH

SWTDFL: JSR     PC,CLEARQ               ;CLEANM SLATE
        MOV     #BIT15,R3       ;START MASK
        CLR     R4              ;START TABLE INX
1$:     BIT     R3,TSWITCH              ;TEST DEFAULT
        BEQ     2$      ;DO NOTHING IF OFF
        PUSH    R3
        JSR     PC,@SWTACT(R4)  ;TURN ON THINGS
        POP     R3

2$:     CLC
        ROR     R3              ;NEXT MASK
        TST     (R4)+           ;NEX INX
        CMP     R4,#16. 
        BLT     1$              ;DO ANOTHER
        MOV     #-1,ALLRFG      ;PRINT UNCHANGED REGS
        MOV     #30.,NTLIMT     ;TIMEOUT 16 TICKS
        CLR     EBAFLG          ;NO AUTO EBUS ACT PRINT
        MOV     #-1,SHRTPT      ;DUMP TRUES ONLY
        RTS     PC


;SEQ180

        ;DUMP COMMAND.  IF AN ARGUMENT IS SUPPLIED, IT IS THE NAME
;OF A FILE CREATED BY THE 'W' CRASH WRITE COMMAND.

COMD:   TTICHR
        BCS     CMDP            ;NO ARG
        CMPB    R0,#LF          ;LINEFEED?
        BEQ     CMDP            ;YES, NO ARG
        MOV     R0,R1           ;SAVE NAME POINTER
        PMSG    <LE >
        MOV     R1,R0           ;RESTORE NAME POINTER
        BR      2$      ;SAVE NAME
1$:     TTICHR                  ;GET NAME CHAR
        BCS     3$              ;QUIT IF THRU
        CMPB    R0,#15          ;CR?
        BEQ     3$
        CMPB    R0,#33          ;ALT?
        BEQ     3$
2$:     PNTCHR          ;END OUT
        BR      1$              ;GET ANOTHER
3$:     CLR     R0              ;
        PNTCHR          ;TERMINATE BUFFER
        MOV     #-1,R0          ;PONT TO OUTPUT BUFFER
        PRGCMD
        BCC     4$              ;IF NO ERROR
        PFORCE
        PMSG    <\FILE READ ERROR OR NOT FOUND\>
        RTS     PC
4$:     PMSG    <\	CRASH STATE DUMP\>
        PMSG    <	MONITOR I. D.  >
        MOV     CMONID,R0
        PNTAL
        PMSG    <	CRASH TIME:  >
        MOV     CTIME,R0
        PNTAL
        PMSG    <	CRASH DATE:  >

        MOV     CDATE,R0
        PNTAL
        PCRLF
        MOV     #-1,CRSHFG      ;SET FLAG FOR READIN


;SEQ181

        ;DUMP COMMAND, SECOND ENTRY IS REGISTER CHANGE SCAN.
CMDP:   JSR     PC,READIN               ;READ
        INC     DUMPFG          ;SET FORCED PRINT FLAG
        JSR     PC,REPREG

        JSR     PC,SIGDMP       ;DUMPE NABLED SIGNALS
        JSR     PC,CRET ;FLUSH BUFFER, NEW LINE
        CLR     DUMPFG          ;DISABLE FORCED PRINT
        CLR     CRSHFG          ;CLEAR FILE INPUT FLAG
        JSR     PC,COMP         ;PRINT AND RESET EBUS STATS
        RTS     PC

        ;CORE DUMP INIT

PNTCDA: CMP     OVLAY1+4,CDUMP  ;CHECK IF CDUMP LOADED
        BNE     1$              ;NO, LOAD IT
        CMP     OVLAY1+6,CDUMP+2
        BEQ     2$              ;YES, PUT CDA IN OUTPUT BUFFER
1$:     PMSG    <P CDUMP.A11>

        MOV     #-1,R0          ;POINT TO OUTPIT BUFFER
        PRGNPT          ;LOAD IT
        BCC     2$              ;LOAD OK
        PNTCI,NULL              ;PRINT ERROR MESSAGE
        PMSG    <MOUNT CDUMP.A11 - HC TO RETRY LOAD\>
        PRGHLT
        BR      1$              ;RETRY
2$:     PNTRST          ;RESET OUTBUT BUFFER
        PMSG    <CDA >
        RTS     PC              ;RETURN

CDUMP:  .RAD50  %CDUMP%
        .EVEN


;SEQ182

        ;CRASH DUMP WRITER - W COMMAND

COMW:   PFORCE
        PMSG    <\CRASH STATE WRITER\>
1$:     PMSG    <MONITOR I. D.:  _>
        TTILIN
        BCS     1$      
        PUSH    CORFF

        MOV     #OVRFF,CORFF            ;POINT TO STRING STORAGE AREA
        MOV     #OVRFF,CMONID           ;MON I.D. STRING POINTER
        CLR     R0
        JSR     PC,STRLIN               ;SAVE MON I.D.
        MOV     CORFF,CTIME
2$:     PMSG    <CRASH TIME:  _>
        TTILIN
        BCS     2$
        CLR     R0
        JSR     PC,STRLIN               ;SAVE CRASH TIME
        MOV     CORFF,CDATE
        
3$:     PMSG    <CRASH DATE:  _>
        TTILIN
        BCS     3$
        CLR     R0
        JSR     PC,STRLIN               ;SDAVE CRASH DATE
        MOV     CORFF,CDEND
4$:     PMSG    <FILE  NAME.EXT  _>
        TTILIN
        BCS     4$
        CLR     R0
        JSR     PC,STRLIN               ;SAVE FILE NAME.EXT
        MOV     CORFF,R0
        POP     CORFF

        ;NOW GET RID OF FILE NAME TERNINATOR
5$:     CMPB    -(R0),#15       ;FIND CR
        BEQ     6$              ;
        CMPB    (R0),#33                ;OR ALT
        BNE     5$
6$:     CLRB    (R0)            ;PUT IN NULL

;SEQ183

        ;NOW READ DF100-177 INTO BUFFER

        MOV     #100,R0 ;FIRST FUNCTION
        MOV     #CRBUF,R1               ;START OF STORGE
7$:     PUSH    <R0,R1>
        DFRDMV                  ;READ SIGNALS
        POP     <R1,R0>

        INC     R0              ;NEXT FDUNCTION
        ADD     #5,R1           ;NEXT BUFFER WORD
        CMP     R0,#200
        BLT     7$              ;MORE TO DO
        JSR     PC,PNTCDA               ;SETUP FOR CORE DUMP
        MOV     CDEND,R0        ;FILE NAME
        PNTAL
        PSPACE
        MOV     #CMONID,R0
        PNTOCS          ;FIRST ADDR
        PCOMMA
        MOV     CDEND,R0                ;LLAST ADDR
        INC     R0
        BIC     #BIT0,R0       ;MAKE .EVEN
        PNTOCS
        MOV     #-1,R0
        PRGCMD          ;ASK KLDCP      O DUMP IT
        BCC     8$              ;IF NO ERR
        PMSG    <\HC TO RETRY DUMP\>
        PRGHLT
        BR      1$              
8$:     PMSG    <\DONE !\>
        RTS     PC

;SEQ184

STRLIN: PUSH    R1
        MOV     CORFF,R1        ;POIN TO FREE CORE
        TST     R0              ;STORE FIRST IF NON-ZERO
        BNE     2$
1$:     TTICHR          ;GET A CHAR
        BCS     3$              ;BRE IF BUFFER EMPTY
2$:     MOVB    R0,(R1)+        ;STORE A CHAR
21$:    BR      1$              ;GET ANOTHER
3$:     CLRB    (R1)+   ;ADD TERMINATOR
        MOV     CORFF,R0        ;RETURN POINTER
        MOV     R1,CORFF                ;REMEMBER FOR NEXT TIME
        POP     R1
        RTS     PC              ;RETURN

;SEQ185

.SBTTL          COMMAND SUPPORT ROUTINES

RDGRP:  MOV     R2,R0           ;GET INDEX
        ASL     R0              ;CONVERT TO 10,20, ETC.
        ASL     R0
        ADD     #100,R0 ;MAKE 100,110, 120, ETC.
        MOV     #FRINBF,R1      ;POINT TO BUFFER
1$:     PUSH    <R0,R1>

        TST     CRSHFG          ;READING CRASH FILE?
        BEQ     2$              ;BR IF NOT
        JSR     PC,RDCRSH               ;FAKE A DF READ FROM BUFFER
        BR      3$
2$:     DFRDMV          ;READ TO BUFFER
3$:     POP     <R1,R0>
        INC     R0              ;NEW FUNC CODE
        ADD     #5,R1           ;NEXT BUFFER WORD
        CMP     R1,#FRINBF+40.
        BNE     1$              ;DO 8 READS
        RTS     PC

RDCRSH: PUSH    R2
        BIC     #100,R0
        MOV     R0,R2           ;SAVE A COPY
;MULTIPLY DF-100 BY 5
        ASL     R0
        ASL     R0
        ADD     R2,R0
        ADD     #CRBUF,R0       ;ADD BUFFER BASE
        MOV     #5,R2           ;SET BYTE COUNT
        
1$:     MOVB    (R0)+,(R1)+     ;MOVE A DF BYTE
        DEC     R2
        BNE     1$              ;DO 5 BYTES
        POP     R2

        RTS     PC


;SEQ186

REPREG: MOV     #BIT11,DMSK     ;INIT MASK
        JSR     PC,TOPEN                ;START A CLEAN LINE
        MOV     #TCMICR,R0      ;FIRST TYPEOUT HEADER
1$:     BIT     DMSK,TSWITCH   ;THIS GROUP ENABLED?
        BEQ     2$              ;BR IF NOT
        MOV     (R0),R5 ;YES, GET START OF LIST
        PUSH    R0
        JSR     PC,REGSCN       ;DUMP THEM
        POP     R0
2$:     TST     (R0)+           ;INC PTR
        ASR     DMSK            ;NEXT MASK
        BIT     #BIT7,DMSK
        BEQ     1$              ;BER IF NOT DONE
        JSR     PC,CRET ;FLUSH BUFFER
        RTS     PC

DFSTOR: MOVB    SRI(R5),R4      ;GET DISP INDEX
        JSR     PC,@STORIT(R4)  ;DO IT
        MOV     SLK(R5),R5      ;LIMK TO NEXT
        BNE     DFSTOR          ;CONTIN IF NOT ZERO
        RTS     PC

CLEARQ: MOV     #COMRQ,R0
1$:     CLR     (R0)+           ;CLEAR REQUEST BITS
        CMP     R0,#COMRQ+<2*8.>
        BNE     1$              ;DO EIHT ITEMS
        
;CLR SIGNAL DUMP ENABLE MASK TABLE
        MOV     #DMPMSK,R0
2$:     CLR     (R0)+
        CMP     R0,#DMPMSK+DSTSIZ
        BNE     2$
        RTS     PC
LBURST: MOV     R0,TEMP
        BIC     #177600,R0      ;TRIM<200
        JSR     R5,BRST1        ;DO THE BURST
        ROL     TEMP
        SWAB    TEMP
        CLRB    TEMP+1
1$:     DEC     TEMP
        BMI     2$              ;DONE
        MOV     #200,R0
        JSR     R5,BRST1                ;DO A 200 PACKAGE
        BR      1$
2$:     RTS     PC


;SEQ187


COMRQ:  .WORD   0,0,0,0,0,0,0,0
COMRP:  .WORD   SC10X,SC11X,SC12X,SC13X
        .WORD   SC14X,SC15X,SC16X,SC17X

DEFY:   .ASCIZ  % (Y)/  _%
DEFN:   .ASCIZ  % (N)/  _%

SWTNAM: .WORD   1$,2$,3$,4$,5$,6$,7$,8$
1$:     .ASCIZ  %EBOX%
        
2$:     .ASCIZ  %MBOX%
3$:     .ASCIZ  %CHAN%
4$:     .ASCIZ  %CYCLIC%
        REGIS=.
5$:     .ASCIZ  %MICRO%
        
6$:     .ASCIZ  %DATA/ADDR%
7$:     .ASCIZ  %METER%
8$:     .ASCIZ  %CHAN ADDR%

SWTACT: .WORD   SWEBOX,SWMBOX,SWCHAN,SWCYCL
        .WORD   SWMICR,SWDAAD,SWMETR,SWCHAD

SWEBOX: BIS     #BIT1,COMRQ
        BIS     #BIT1,COMRQ+2
        BIS     #BIT1,COMRQ+6
        BIS     #BIT1,COMRQ+10
        BIS     #BIT1,COMRQ+12
        MOV     TDEBX,R5        ;ENABLE DUMP MASK
        JSR     PC,ENBDMP
        MOV     #ECYC,R5
        JSR     PC,OFFCYC               ;MASK OFF CYCLICS
        RTS     PC

SWMBOX: BIS     #BIT1,COMRQ+14
        BIS     #BIT1,COMRQ+16
        MOV     TDMBX,R5
        JSR     PC,ENBDMP
        MOV     #MCYC,R5
        JSR     PC,OFFCYC               ;MASK OFF CYCLICS
        RTS     PC

;SEQ188


SWCHAN: BIS     #BIT2,COMRQ+16
        MOV     TDCHN,R5
        JSR     PC,ENBDMP
        MOV     #CCYC,R5        ;CYCLICS NORMALLY OFF
        JSR     PC,OFFCYC
        RTS     PC
SWCYCL: BIT     #BIT1,COMRQ     ;EBOX ON?
        BEQ     1$              ;BR IF NOT
        MOV     #ECYC,R5
        JSR     PC,ONCYC                ;TURN ON EBOX CYCLICS
1$:     BIT     #BIT1,COMRQ+14  ;MBOX ON ?
        BEQ     2$              ;BR IF NOT
        MOV     #MCYC,R5        ;
        JSR     PC,ONCYC                ;TURN ON MBOX CYCLICS
2$:     BIT     #BIT2,COMRQ+16  ;CHAN ON ?
        BEQ     3$              ;BR IF NOT
        MOV     #CCYC,R5        ;POINT AT CHAN CYC TABLE
        JSR     PC,ONCYC                ;TURN 'EM ON
3$:     RTS     PC

SWMICR: BIS     #BIT2,COMRQ+6
        BIS     #BIT0,COMRQ+10
        RTS     PC

SWDAAD: BIS     #BIT0,COMRQ
        BIS     #BIT0,COMRQ+2
        BIS     #BIT0,COMRQ+4
        BIS     #BIT0,COMRQ+6
        BIS     #BIT0,COMRQ+12
        BIS     #BIT0,COMRQ+14
        RTS     PC

SWMETR: BIS     #BIT2,COMRQ+2
        RTS     PC

SWCHAD: BIS     #BIT0,COMRQ+16
        RTS     PC


;SEQ189


OFFCYC: JSR     PC,CYCINR       ;SET UP MASK, INDEX
        BNE     1$
        RTS     PC              ;END OF LIST
1$:     BICB    R3,DMPMSK(R2)   ;CLEAR THE MASK
        BR      OFFCYC

ONCYC:  JSR     PC,CYCINR       ;SET UP MASK,INDEX
        BNE     1$
        RTS     PC              ;END OF LIST
1$:     BISB    R3,DMPMSK(R2)   ;SET MASK TO ENABLE
        BR      ONCYC

CYCINR: CLR     R2
        BISB    (R5)+,R2        ;GET TBLE INDEX
        CLR     R3
        BISB    (R5)+,R3        ;GET MASK
        RTS     PC

;CYCLIC POINTER TABLES.  FIRST BYTE IS OFFSET (INDEX) INTO
;DIAGNOSTIC SIGNAL MASK TABLE SECOND BYTE ON PAIR IS MASK
;USED BY BIS OR BIC INSTRUCTION.  SEE 'SIGNAL BIT SPEC TABLES'
;FOR OFFSET INFORMATION

ECYC:   .BYTE   0,40            ;EBUS CLK
        .BYTE   0,20            ;SBUS CLK
        .BYTE   13,1            ;PI TIMER DONE
        .BYTE   14,4            ;EBOX SOURCE
        .BYTE   5,4             ;SYNC
        .BYTE   10,4            ;EBOX CLK
        .WORD   0,0,0,0 ;SPARES, LAST MUST BE 0

MCYC:   .BYTE   133,10          ;A CHANGE COMING
        .BYTE   137,1           ;B CHANGE COMING
        .BYTE   140,40          ;PHASE CHANGE COMING
        .WORD   0,0,0,0,0,0     ;SPARES, LAST MUST BE 0
        
CCYC:   .BYTE   167,1           ;CH T0
        .BYTE   172,1           ;CH T1
        .BYTE   175,1   ;CH T2
        .BYTE   200,1     ;CH T3
        .BYTE   166,200         ;CBUS SEL 0
        .BYTE   171,200        ;CBUS SEL 1
        .BYTE   174,200 ;CBUS SEL 2
        .BYTE   177,200         ;CBUS SEL 3
        .BYTE   202,200 ;CBUW SEL 4
        .BYTE   205,300         ;CBUS SEL 5, CH SEL 8A
        .BYTE   210,200         ;CBUS SEL 6
        .BYTE   213,200         ;CXBUS SEL 7
        .BYTE   207,7           ;CRC SEL 1D,2D,3D L
        .WORD   0,0             ;SPARE AND TERMINATOR


;SEQ190

;TURN ON A SECTION OF BITS FOR DUMPING
ENBDMP: MOV     PST(R5),R0      ;GET BYTE OFFSET
        MOV     R5,R3
        ADD     #PRO,R3 ;POINT AT PICKUP COUNTS
1$:     MOV     (R3)+,R1        ;GET WORD
        BIC     #177600,R1      ;PRESERVE BYTE COUNT
        BEQ     3$              ;IF ZERO QUIT
2$:     MOVB    #-1,DMPMSK(R0)  ;TURN ON
        INC     R0
        DEC     R1
        BNE     2$
        BR      1$              ;GET NEW COUNT
3$:     MOV     TPL(R5),R5      ;LINK TO NEXT GROUP
        BNE     ENBDMP
        RTS     PC              ;QUIT ON ZERO LINK
;LOOK FOR AND PRINT CHANGES, CHECK TIMEOUT ON NO CHANGE
REPCHG: CLR     RDELTA          ;CLR REGISTER CHANGE FLAG
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        PMSG    <------	CLOCK: >
        MOV     TICK,R0
        PNTDEC                  ;REPORT TICK NUMBER
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        TST     TTALFG          ;ALTMODE?
        BNE     3$              ;YES, EXIT
        MOV     ALLRFG,DUMPFG   ;DO ACCORDING TO USER
        BEQ     11$             ;NORMAL CHANGE PRINT
        DFRDT
        104                     ;CHECK EBOX SOURCE
        BIT     #BIT2,@.DAT3    ;BIT 33
        BNE     11$             ;PRINT IF HIGH
        CLR     DUMPFG  ;BUT LOOK FOR CHANGES IF NOT HIGH
11$:    JSR     PC,REPREG       ;DO THE REGISTERS
        JSR     PC,SIGPRT       ;DO THE SIGNALS
        JSR     PC,CRET
        TST     EBAFLG          ;WANT "P" COMMAND?
        BEQ     12$             ;BR IF NOT
        JSR     PC,COMP         ;ADD EBUS ACTIVITY

;SEQ191

;NOW CHECK FOR ANY CHANGE

12$:    CLR     R0
        BIS     RDELTA,R0       ;OR ALL FLAGS TOGETHER
        BIS     TRUPNT,R0
        BIS     FALPNT,R0
        TST     R0
        BEQ     2$              ;NOTHING CHANGED
        MOV     TICK,LCHANG     ;REMEMBER THIS TICK
1$:     CLC                     ;GIVE "OK" RETURN
        RTS     PC

2$:     MOV     TICK,R0
        SUB     LCHANG,R0       ;FIND OUT HOW LONG
        CMP     R0,NTLIMT               ;TEST VS. THRESHOLD
        BLT     1$              ;STILL OK
        PFORCE
        PNTDEC                  ;PRINT THRESHOLD
        PMSG    < TICKS WITHOUT CHANGE\>
3$:     MOV     TICK,LCHANG     ;SETUP FOR OCNTINUE
        SEC                     ;SET STOP FLAG
        RTS     PC

;TICK OR BURST THE CLOCK
TICKIT: INC     TICK            ;UPDATE TICK COUNT
        TST     BSTFG           ;BURST MODE ?
        BNE     1$              ;BR IF YES
        STEP                    ;STEP THE CLOCK
        RTS     PC              ;
1$:     JSR     PC,ALLBUF               ;GET TO STATE 0
        BCS     1$              ;TRY AGAIN
        MOV     TICK,R0         ;NEW BURST COUNT
        JSR     PC,LBURST       ;DO BURST
        RTS     PC              ;RETURN


;SEQ192


;ROUTINES FOR P COMMAND

;INITIALIZE AND AND OR ACCUMULATORS

IANDOR: MOV     EBSAND,R0       ;POINT TO 8-WORD AND AREA
1$:     MOV     #-1,(R0)+       ;CLEAR TO ALL ONES
        CMP     R0,#EBSAND+56.
        BLT     1$              ;CLEAR 40 BYTES
        MOV     EBSOR,R0                ;POINT TO 8-WORD OR AREA
2$:     CLR     (R0)+           ;CLEAR TO ZERO
        CMP     R0,#EBSOR+56.
        BLT     2$
        MOV     #GRDAND,R0
3$:     MOVB    #-1,(R0)+
        CMP     R0,#GRDOR
        BLT     3$
4$:     CLRB    (R0)+
        CMP     R0,#GRDOR+5
        BLT     4$
        RTS     PC


;SEQ193

;ACCUMULATE EBUS STATS FOR ONE EIGHT-WORD DIAG FCN GROUP
EBSTAT: PUSH    <R1,R3>

        MOV     #8.,R3
        MOV     #FRINBF,R0      ;POINT TO DF INPUT BUFFER
1$:     MOV     EBSAND(R2),R1           ;POINT TO RIGHT .AND. ACCUM
        JSR     PC,WRDAND               ;DO THE .AND.
        DEC     R3
        BGT     1$              ;DO 8 WORDS
        MOV     #8.,R3
        MOV     #FRINBF,R0      ;POINT TO DF INPUT BUFFER
2$:     MOV     EBSOR(R2),R1    ;POINT TO RIGHT .OR. ACCUM
        JSR     PC,WRDOR                ;DO THE .OR.
        DEC     R3
        BGT     2$              ;DO 8 WORDS
        POP     <R3,R1>

        RTS     PC

;ACCUMULATE GRAND TOTAL .AND. AND .OR.
TOTANR: MOV     EBSAND,R0              ;POINT TO FIRST ACCUM
        MOV     #8.,R2
        
1$:     MOV     #GRDAND,R1      ;POINT TO GRAND.AND.
        JSR     PC,WRDAND               ;DO THE .AND.
        DEC     R2
        BGT     1$              ;DO 8 WORDS
        MOV     #8.,R2
        MOV     EBSOR,R0                ;POINT TO FIRST .OR. ACCUM
2$:     MOV     #GRDOR,R1               ;POINT TO GRTAND .OR.
        JSR     PC,WRDOR                ;DO THE .OR.
        DEC     R2
        BGT     2$              ;DO 8 WORDS
        RTS     PC


;SEQ194

;LOGICAL .AND. TWO 36-BIT WORDS
WRDAND: PUSH<R2,R3>

        MOV     #5,R3           ;BYTE COUNT
1$:     MOVB    (R0)+,R2        ;GET SOURCE BYTE
        COMB    R2              ;TWO INSTR. AND.
        BICB    R2,(R1)+        ;TO RESULT BYTE
        DEC     R3
        BGT     1$              ;DO 5 BYTES
        POP     <R3,R2>

        RTS     PC

;LOGICAL .OR. TWO 36-BIT WORDS
WRDOR:  PUSH     R3
        MOV     #5,R3
1$:     BISB    (R0)+,(R1)+     ;DO OR OF BYTE
        DEC     R3
        BGT     1$
        POP     R3

        RTS     PC


;SEQ195

.SBTTL          STORAGE ROUTINES
;
;STORAGE LIST HEADERS
SC10X:  PIH
        EBX0
SC11X:  FBA
        EBX1
        METR

SC12X:  AR

SC13X:  SC
        EBX3
        DRD

SC14X:  CRL
        EBX4

SC15X:  VMA
        EBX5

SC16X:  ERG
        MBX6

SC17X:  CBA
        MBX7
        CHN7

;STORAGE ROUTINES INDEXES

SBYT=0
SWRD=2
SCRM=4
SVMA=6
SCHB=10
SCHA=12
SCLK=14
SBITS=16
SLBYT=20
SPSC=22

;STORAGE DISPATCH TABLE

STORIT: BYTSMS          ;NORMAL BYTE THINGY
        STWORD          ;5 BYTE WORD

        STCRAM          ;CRAM SPECIAL

        STVMA           ;VMA, PC, ETC.
        STCHBF          ;CH BUF ADR SPECIAL
        STCHA           ;CCW CHA SPECIAL
        STCLK           ;CLK ENABLES SPECIAL
        SSIGNL          ;SIGNAL BITS
        BYTLOW          ;BYTE WITH LOW TRUTH
        STPRSC          ;PREV SECTION REGISTER


 


;SEQ196

;INDEXES FOR SHIFT COUNT AND MASK TABLES

S2M177=0
S2M357=1
S0M40=2
S4M77=3

S0M3=4
S0M77=5
S0M23=6
S0M17=7
S0M16=10
S0M377=11
S0M7=12
S5M177=13
S0M37=14
S2M77=15
S2M7=16
S2M17=17
S2M37=20
S7M3=21
S6M37=22
S6M77=23
S1M77=24
S1M17=24
S1M17=25
S2M57=26
S7M17=27
S6M17=30
;SHIFT COUNT TABLE

SHC:    .BYTE   2,2,0,4,0,0,0,0
        .BYTE   0,0,0,5,0,2,2,2
        .BYTE   2,7,6,6,1,1,2,7,6

;MASK TABLE

MK:     .BYTE   200,20,337,300,374,300,354,360
        .BYTE   361,0,370,200,340,300,370,360
        .BYTE   340,374,340,300,300,360,320,360,360


;SEQ197

;GENERAL BYTE-BY-BYTE STORING ROUTINES
;
BYTLOW: MOV     #-1,FLGLOW      ;FLAG LOW-FLAVOR

BYTSMS: JSR     PC,SSETUP       ;SET UP STORAGE POINTERS
        PUSH    R5              ;PRESERVE TABLE BASE

1$:     MOVB    BI(R5),R0      ;GET BYTE INDEX
        BIC     #177600,R0      ;
        MOVB    FRINBF(R0),TEMP ;GET 2 BYTES
        MOVB    FRINBF+1(R0),TEMP+1
        MOVB    PRO(R5),R0      ;GET PROCESS INDEX
        MOVB    SHC(R0),R1      ;GET SHIFT COUNT
        BEQ     3$              ;BR IF NO SHIFTS
2$:     ASR     TEMP            ;SHIFT RIGHT
        DEC     R1
        BNE     2$
3$:     TST     FLGLOW          ;NED TO COMPLEMENT?
        BEQ     35$
        COM     TEMP
35$:    BICB    MK(R0),TEMP     ;TRIM IT
        MOVB    (R4),(R3)+      ;MOVE OLD DOWN
        MOVB    TEMP,(R4)+      ;STORE NEW
        TSTB    BI(R5)  ;TEST END BIT
        BMI     4$              ;BR IF DONE
        TST     (R5)+   ;POINT TO NEXT PAIR
        BR      1$
4$:     CLR     FLGLOW          ;RESET COMPLEMENT FLAG
        POP     R5

        RTS     PC

;STORE A 5-BYTE 36-BIT WORD

STWORD: JSR     PC,SSETUP               ;SET UP STORAGE POINTERS
        MOVB    BI(R5),R0       ;POINT TO FIRST BYTE
        BIC     #177600,R0
        ADD     #FRINBF,R0     ;ADD BUFFER BASE
        MOV     #5,R1
1$:     MOVB    (R4),(R3)+      ;SAVE OLD
        MOVB    (R0)+,(R4)+     ;STORE INPUT
        DEC     R1
        BNE     1$
       RTS      PC



;SEQ198

;STORE CRAM DATA LOOSELY PACKED IN 16 BYTES

STCRAM: JSR     PC,SSETUP               ;SET UP STORAGE POINTERS
        MOVB    SIB(R5),R0      ;GET SIZE
        PUSH    R4              ;SAVE START
1$:     MOVB    (R4)+,(R3)+     ;SAVE OLD
        DEC     R0              ;COUNT BYTES
        BNE     1$
        POP     R4              ;RETRIEVE POINTER

;PICK UP AND STORE CRAM ADDRESS
        MOVB    FRINBF+34.,(R4)
        MOVB    FRINBF+33.,1(R4)
        CLC
        ROLB    1(R4)
        ROLB    (R4)
        ROLB    1(R4)
        ROLB    (R4)
        BICB    #300,(R4)
        CLRB    1(R4)
        MOV     FRINBF+38.,R0
        BIC     #174077,R0
        BIS     R0,(R4)+
        JSR     PC,$RCRAM               ;GO ASSEMBLE DATA LIKE KLDCP
        MOV     #11.,R2
2$:     MOVB    (R0)+,(R4)+     ;STORAGE DATA IN MY AREA
        DEC     R2
        BNE     2$
        RTS     PC


;SEQ199

;STORE PC,VMAH,ADR BRK, OR VMA AS 3 BYTES OF 22-BIT ADDRESS.
;THE SPEC TABLE BYE, BI, IS UUSED TO ACCESS THE APPROPRIATE SETUP
;ABLE ENTRY FOR THE REGISTER OF CONCERN./

STVMA:  MOVB    BI(R5),R0       ;GET REGISTER CODE
        BIC     #177600,R0      
        MOV     VMSK(R0),VMASK  ;INIT MASK
        MOV     VINP(R0),R3     ;INPUT BUFFER PTR
        MOV     #4,R0           ;OUTER LOOP COUNT
        CLR     VBF             ;CLEAR 23-BIT BUFFER
        CLR     VBF+2
2$:     MOV     #3,R1           ;INNER LOOP CNT
        MOV     #VTM,R4         ;TEMP BUFF PTR
3$:     MOVB    (R3)+,(R4)      ;INPUT TO TEMP
        BICB    VMASK,(R4)+     ;MASK UNWANTED BITS
        DEC     R1
BNE     3$              ;GET 3 BYTES
        JSR     PC,ROTBUF               ;ROT VBF LEFT, PTR TO R2
        MOV     #VTM,R4 ;RESET TEMP PTR
        MOV    #3,R1           ;INNER LOOP CNT
4$:     BISB    (R4)+,(R2)+     ;IOR TEMP TO BUFF
        DEC     R1
        BNE     4$              ;OR IN 3 BYTES
        SUB     #8.,R3  ;RESET INPUT PTR
        DEC     R0
        BNE     2$              ;DO 4 GROUPS
        BIT     #BIT0,VMASK     ;NEED FINAL SHIFT?
        BEQ     6$              ;VE ID NO
        JSR     PC,SHFBUF       ;SH VBF RIGHT 2
6$:     MOV     #3,R1           ;INER LOOP CNT
        MOV     #VBF,R2 ;POINT TO RESULT
        JSR     PC,SSETUP       ;SET UP STORAGE POINTERS
5$:     MOVB    (R4),(R3)+      ;SAVE OLD
        MOVB    (R2)+,(R4)+     ;RESULT TO NEW
        DEC     R1
        BNE     5$              ;DO 3 BYTES
        BICB    #200,-(R4)      ;NO BIT 12, PLEASE
        RTS     PC

;SEQ200

;PACK THE CHANNEL BUFFER ADDRESS BITS (7) INTO 1 BYTE.

STCHBF:CLR      R0
        MOV     #FRINBF+4,R1    ;POINT TO FIRST BYTE
1$:     ASL     R0              ;SHIFT PREVIOUS TO LEFT
        BITB    #BIT3,(R1)      ;TEST THE BIT
        BEQ     2$              ;IF ZERO, GOT IT
        BIS     #BIT0,R0        ;COPY IF 1
2$:     ADD     #5,R1           ;NEXT BTE
        CMP     R1,#FRINBF+39.  
        BNE     1$              ;PICK UP 7 BITS
STCHB1=.                        ;ENTRY FROM STPRSC BELOW
        JSR     PC,SSETUP               ;SET STORAGE PTRS
        MOVB    (R4),(R3)+      ;SAVE OLD
        MOVB    R0,(R4)                 ;STORE NEW
        RTS     PC

;STORE CCW CHA IN 4 6-BIT BYTES.

STCHA:  JSR     PC,SSETUP               ;SET UP STORAGE PTRS
        MOV     #FRINBF+18.,R0  ;INPUT BFR PTR
1$:     MOVB    (R4),(R3)+      ;SAVE OLD
        MOVB    (R0),(R4)       ;GET NEW
        RORB    (R4)            ;OVER 1
        BICB    #300,(R4)+      ;MASK UNWANTED
        ADD     #5,R0           ;NEXT BYTE
        CMP     R0,#FRINBF+38.
        BNE     1$              ;DO 4 BYTES
        BICB    #360,-(R4)      ;LAST BYTE SMALLER
        RTS     PC

;STORE RANDOM CLOCK ENABLE BITS IN 4 BYTES.

STCLK:  JSR     PC,SSETUP               ;SET STORAGE PTRS
        MOV     #FRINBF+20.,R0  ;PTR TO 1ST BYTE
        MOV     #CLKMSK,R1      ;PTR TO MASK TABLE
1$:     MOVB    (R4),(R3)+      ;SAVE OLD
        MOVB    (R0),(R4)       ;STORE NEW
        BICB    (R1)+,(R4)+     ;TRIM
        ADD     #5,R0           ;NEXT BYTE
        CMP     R0,#FRINBF+40.
        BNE     1$              ;DO 4
        RTS     PC

CLKMSK: .BYTE   364,360,361,360


;SEQ201

;STORE A GROUP OF SIGNAL BITS
SSIGNL: MOV     PST(R5),R0      ;STORASGE BYTE POINTER
        MOV     R5,R3
        ADD     #PRO,R3         ;POINT TO PICKUP POINTER
1$:     MOVB    (R3)+,R1        ;GET BYTE COUNT
        BEQ     3$              ;QUIT ON ZERO
        MOVB    (R3)+,R2        ;GET INPUT POITER

2$:     MOVB    FRINBF(R2),NEWSTA(R0)   ;STORE A BYTE
        INC     R2              ;NEXT INPUT
        INC     R0              ;NEXT STORGE BYTE
        DEC     R1              ;COUNT
        BNE     2$
        BR      1$              ;GET NEXT POINTER SET
3$:     RTS     PC

;PICK AND PACK 5 VMA PREV SEC BITS (UPSIDE DOWN ORDER)


STPRSC: CLR     R0              ;START WITH RESULT=0
        MOV     #FRINBF+38.,R1  ;FIRST BYTE IN 4-11 OF FR 157
        
1$:     ASL     R0              ;SHIFT PREV RESLT
        BITB    #BIT0,(R1)      ;TEST EBUS BIT11
        BEQ     2$              ;BR IF A ZERO
        BIS     #BIT0,R0        ;COPY I A ONE
2$:     SUB     #5,R1           ;BACK UP ONE D.F. IN BUFFER
        CMP     R1,#FRINBF+18.  ;DONE D.F. 153??
        BGE     1$              ;DO 5 BITS IN ALL
        JMP     STCHB1  ;GO STORE RESULT AND EXIT


;SEQ202


SSETUP: MOV     (R5),R4 ;GET PTR TO "NEW" STORAGE
        MOVB    SIB(R5),R3      ;GET STORAGE SIZE
        ADD     (R5),R3         ;FORM PTR TO "OLD"
        RTS     PC

ROTBUF: MOV     #VBF,R2         ;POINT TO BUFFER
        CLC
        ROL     2(R2)
        CLC
        ROL     (R2)
        ADC     2(R2)
        RTS     PC

SHFBUF: MOV     #VBF,R2 ;PTR TO BUFFER
        CLC
        ROR     2(R2)
        ROR     (R2)
        CLC
        RORB    2(R2)           ;REPEAT FOR 2 RIGHT
        ROR     (R2)
        RTS     PC
TEMP:   .WORD   0
        VBF:    .WORD   0,0
        VTM:    .WORD   0,0
VMASK:  .WORD   0
;ORDER: PC,VMAH,ADR BRK, VMA
VMSK:   .WORD   273,273,356,356
VINP:   FRINBF+15.
        FRINBF+35.
        FRINBF+15.
        FRINBF+35.

;SEQ203

;READ THE C-RAM FROM FRINBF, JUST A REWORK OF KLDCP CODE
$RCRAM: PUSH    <R1,R2,R3,R4>

        CLR     SIGNL2
        CLR     SIGNL3
        
1$:     MOV     #BUFRC+10.,R3   ;GET BUFFER ADDR
        MOV     #RDLST,R4       ;GET FRINBF ADDR LIST PTR
2$:     MOVB    (R4)+,R0        ;FIRST ADDRESS
        ADD     #FRINBF,R0
        MOV     #WREADY,R1      ;WORKING BUFFER ADDR
        JSR     PC,WRDXFR               ;MOVE IT
        JSR     PC,SQASH        ;GO CLR BLANKS
        MOV     #WREADY+3,R0    ;ADDRESS OF DATA JUST MOVED
        MOVB    -(R0),-(R3)     ;BITS 16-19 TO BUFFER
        TST     SIGNL2          ;TEST FLAG
        BNE     4$              ;TIOME TO ROTATE
3$:     MOVB    -(R0),-(R3)     ;BITS 20-27 TO WORK AREA
        MOVB    -(R0),-(R3)     ;BITS 28-35 TO WORK AREA
        COM     SIGNL2          ;CHANGE FLAG
        BR      2$
;RORING CODE
4$:     ASLB    (R3)
        ASLB    (R3)
        ASLB    (R3)
        ASLB    (R3)
        PUSH    R0              ;SAVE DATA ADDRESS
        MOV     #4,R0
10$:    MOV     R3,R2           ;DATA DDR TO R2
        ROLB    (R2)+
        ROLB    (R2)+
        ROLB    (R2)+
        ROLB    (R2)+
        DEC     R0
        BNE     10$             ;ASSEMBLE COMPELTE HALF BYTE
        POP     R0              ;RESTOREE DATA ADDRESS
        
        TSTB    (R3)+           ;FIX DEST ADDRESS
        TST     SIGNL3          ;CHECK FLAG
        BNE     15$             ;DONE IF NEG
        COM     SIGNL3          ;CHANGE SIGNAL
        BR      3$              ;CONTINUE

;SEQ204

15$:    MOVB    WREADY+1,-(R3)  ;ENDING UP
        MOVB    WREADY,-(R3)    ;CRAM 0-15 TO BUFFER
        COM     SIGNL3          
        COM     SIGNL2          ;RESET FLAGS
        MOV     FRINBF+8.,R0     ;FGET DISP FLD
        ASL     R0
        ASL     R0
        SWAB    R0              ;POSITION TO RIGHT
        BIC     #177700,R0      ;OFF GARBAGE
        MOVB    R0,BUFRC+12    ;PUT IN BUFFER
        MOV     #BUFRC+2,R0     ;DATA ADDR TO R0
        BIC     #5,(R0)         ;CLR PARITY BITS
        BIC     #52525,-(R0)    ;AND FIX ADDRESS

        POP     <R4,R3,R2,R1>



        RTS     PC              ;RETURN
RDLST:  .BYTE   35.,30.,25.,20. ;FRINBF OFFSETS
        
BUFRC:  .BLKW   6
WREADY: .BLKW   3
        
SIGNL2: 0
SIGNL3: 0


;SEQ205

SQASH:  PUSH    R5
        MOV     WREADY,R1       ;GET STRETCHED BITS 8-19
        MOV     WREADY+2,R2     ;GET STRETCHED BITS 0-7
        CLR     R0              ;CLR DEST
        SEC                     ;SET DONE FLAG
        ROR             R0              ;INTO R0
1$:     MOV     #4,R5           ;FOUR PER GROUP
2$:     DEC     R5
        BLT     20$             ;IF DONE
        ASR     R2              ;SOURCE BITS TO RIGHT
        ROR     R1
        ROR     R0
        BCC     2$
;HERE TO FINISH UP
        ASR     R1              ;MAKE LAST BLANKS
        ASR     R1
        MOV     R0,WREADY               ;STORE IN CORE
        MOV     R1,WREADY+2
        POP     R5
        RTS     PC

20$:    ASR     R2              ;SHIFT AWAY
 
        ROR     R1
        ASR     R2
        ROR     R1
        BR      1$              ;BLANKS AL GONE!

WRDXFR: PUSH    R2
                MOV     #5,R2
1$:     MOVB    (R0)+,(R1)+     ;MOV A BYTE
        DEC     R2
        BNE     1$              ;DO 5
        POP     R2
        RTS     PC


;SEQ206

.SBTTL          REGISTER TYPEOUT STUFF
;       TYPEOUT LIST HEADERS
;
TCMICR: IR
TCDAAD: ABK
        TCMETR: METR
TTCHAN: CBA
TDEBX:  EBX0
TDMBX:  MBX6
TDCHN:  CHN7

;
;INDEXES TO THE TUPEOUT DISPATCH TABLE
;
F0T7B=32
F1T7B=34
; 0 THRU 13 ARE USED AS TABLE INDEXES BY OCTGET
F0T1O=0
F0T2O=1
F6T2O=2
F0T3O=3
F2T3O=4
F0T4O=5
F2T4O=6
F4T4O=7
F0T6O=10
F0T8O=11
F7T8O=12
F0T12O=13
;
F0TCRM=22
F0TDRM=24
F0TDSP=26
F0TFM=30
F0TRV=36

;TYPEOUT DISPATCH TABLE, INDEXED BY ABOVE, FOR TYPING REGISTERS
;ONLY NUMBERS 20 AND GREATER ARE USED FOR DISPATCH

TYPTAB: DONOTH
        TYPCRM          ;TYPE CRAM DATA
        TYPDRM          ;TYPE DRAM DATA
        DONOTH          ;TYPE DISP. PARITY
        TYPFM           ;TYPE FAST MEM BLOCK, ADR
        TYP7B           ;TYPE 7-BIT BINARY
TYPECS          ;TYPE EBUS CS IN 7-BIT FORM
        TYPREV          ;TYPE RESEVERSED DIGIT (CRC SEL)


;SEQ207

TYPCRM: JSR     PC,TOPEN                ;FLUSH HEADING
        PMSG    <CONTROL RAM:>
        MOV     (R5),R1
        CLR     R0
        BISB    1(R1),R0        ;GET ADDRESS TO R0
        SWAB    R0
        BISB    (R1),R0
        ADD     #2,R1           ;POINT AT CRAM DATA
        PNTCRM                  ;GET CONSOLE TO PRINT
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        RTS     PC

TYPDRM: MOV     (R5),R3         ;POINT TO DATA
        MOVB    (R3),R0
        JSR     PC,PUTNLD       ;A-FIELD
        JSR     PC,PUTSPA
        MOVB    (R3)+,R0
        JSR     PC,PUTOCT               ;B-FLD
        JSR     PC,PUTSPA
        MOVB    (R3),R0
        JSR     PC,PUTNLD               ;J-FIELD
        MOVB    (R3)+,R0
        JSR     PC,PUTOCT
        MOVB    (R3),R0
        BIC     #177740,R0      ;GET RD OF PAR BIT
        JSR     PC,PUTNLD
        MOVB    (R3),R0
        JSR     PC,PUTOCT
        JSR     PC,PUTSPA
        MOVB    (R3),R0
        ASR     R0
        ASR     R0
        JSR     PC,PUTNLD       ;PARITY BIT
        JSR     PC,PUTSPA
        RTS     PC

TYPFM:  MOV     (R5),R3 ;POINT TO DATA
        MOVB    (R3),R0
        ASR     R0
        JSR     PC,PUTNLD       ;FM BLOCK
        JSR     PC,PUTSPA
        MOVB    (R3),R0
        BIC     #177760,R0      ;CLEAR OUT BLOCK
        JSR     PC,PUTNLD               ;ADDRESS
        MOVB    (R3),R0
        JSR     PC,PUTOCT
        JSR     PC,PUTSPA
        RTS     PC

TYP7B:  MOV     (R5),R4 ;POINT AT DATA
        MOVB    (R4),R3 ;GET DATA
TYPBIN: MOV     #'^,R0
        JSR     PC,PUTCHR               ;PRINT ^B IND BINARY


;SEQ208

        MOVB    #'B,R0
        JSR     PC,PUTCHR
        SWAB    R3
        ROL     R3
        MOV     #7,R4
1$:     CLC
        CLR     R0
        ROL     R3              ;BIT TO C-BIT
        ROL     R0              ;TO R0 LOW
        JSR     PC,PUTOCT
        DEC     R4
        BNE     1$
        JSR     PC,PUTSPA
        RTS     PC

TYPECS: MOV     (R5),R4 ;DATA POINTER
        MOVB    (R4),-(SP)      ;SAVE BYTES ON STACK
        MOVB    1(R4),-(SP)
        ROLB    1(R4)
        ROLB    1(R4)
        CLC
        ROLB    1(R4)
        ROLB    (R4)
        CLC     
        ROLB    (R4)            
        ADCB    (R4)            ;END-AROUND
        CLC
        ROLB    (R4)
        ADCB    (R4)
        MOVB    (R4),R3         ;DATA TO LOW 7 OF R3
        MOVB    (SP)+,1(R4)     ;GET ORIGINAL DATA BACK
        MOVB    (SP)+,(R4)
        JMP     TYPBIN
TYPREV: MOV     (R5),R3         ;GET DATA DDRESS
        MOVB    (R3),R4 ;GET DATA BYTE
        MOVB    REVTAB(R4),R0   ;GET REVERSED ASCII BYTE
        JMP     PUTCHR          ;PUT AND EXIT


;SEQ209

;SUPPORT FOR SPECIAL TYPERS
PUTNLD: ASR     R0              ;GET NEXT-TO-LEAST DIGIT
        ASR     R0
        ASR     R0
PUTOCT: BIC     #177770,R0      ;CLEAN LSD
        ADD     #60,R0          ;MAKE ASCII
        JMP     PUTCHR          ;GO OUTPUT

PUTSPA: MOV     #' ,R0  ;GET A SPACW
        JMP     PUTCHR          ;ADD TO OUTPUT

;REGISTER SCANNER.  CALLED WITH A POINTER IN R5 TO THE
;FIRST REGISTER SPEC TABLE IN A TYUPEOUT LIST.  IT FOLLOWS
;HE LIST CHECKING FOR CHANGES IN REGISTER CONTENTS AND
;PRINTING THE RESULT.  PORINTOUT OF ALL REGISTERS IN THE
;LIST IS FORCED IF CALLER SETS "DUMPFG" TO NON-ZERO
;
REGSCN: MOV     PST(R5),R1      ;GET BUFFER PTR TO EW
        MOVB    SIB(R5),R2      ;GET SIZE
MOV     R2,R3
        ADD     R1,R2           ;POINT TO OLD
        ADD     R2,R3   ;STOPPER ADDRESS
1$:     TST     DUMPFG  ;FORCED?
        BNE     2$              ;BR IF SO
        CMPB    (R1)+,(R2)+     ;COMP
        BNE     2$              ;CHANGE FOUND
        CMP     R2,R3           ;DONE?
        BNE     1$              ;NO CHANGE, KEEP GOING
        BR      3$              ;NO CHANGE, NEXT REGISTER
;NOW POSITION TO A SPOT WHERE THIS FITS
2$:     MOV     #-1,RDELTA      ;SET CHANGE FLAG
        MOVB    HPO(R5),R0      ;GET SIZE TABLE CODE
        MOV     HPTABL(R0),R4   ;TABLE BASE
        ADD     TABSTP,R4       ;OFFSET BY CURRENT POSITION
        JSR     PC,@(R4)                ;DO WHAT'S NEEDED
        JSR     PC,REGTYP       ;NOW TYPE NAME AND CONTENTS
3$:     MOV     TPL(R5),R5      ;LINK TO NEXT PSEC
        BEQ     4$
        JMP     REGSCN          ;DO ANOTHER LIST
4$:     RTS     PC              ;ZERO IS END OF CHAIN


;SEQ210

;ROUTINE TO PRINT REGISTER NAME, CONTENTS.  DOES
;STRAIGHTFORWARD OCTAL PRINTS HERE, DISPATCHES TO OTHER
;ROUTINES FOR ODDBALL THINGS LIKE CRAM.
REGTYP: JSR     PC,TRGNAM               ;DO NAME THING
        MOVB    TFX(R5),R0      ;GET FORMAT CODE
        CMP     R0,#20          ;IS IT SPECIAL?
        BGE     3$              ;YES, GO DISPATCH
        MOVB    SIB(R5),R4      ;GET SIZE
        ADD     PST(R5),R4      ;FORM DECREMENTING POINTER
        MOVB    RTBSZ(R0),BYTSZ ;GET BYTE SIZE IN BITS-1
        MOVB    RTNDG(R0),R2    ;NBR OF DIGITS TO PRINT
        MOVB    RTFDG(R0),R3    ;FIRST DIGIT POSITION
        CLR     R1              ;START CLEAN FOR OR-ING
        MOV     #-1,BITCNT      ;FORCE FIRST BYTE GET
1$:     JSR     PC,OCTGET               ;GET AN ASCII-OCTAL DIGIT
        JSR     PC,PUTCHR               ;STUFF IT
        MOV     #3,R3           ;RESET DIGIT-BIT CTR
        CMP     R2,#7           ;NEED A SPACE?
        BNE     2$              ;BR IF NOT
        MOV     #40,R0          
        JSR     PC,PUTCHR               ;SPACE OVER
2$:     DEC     R2              ;COUNT DIGITS
        BNE     1$              ;MORE
        RTS     PC


;DISPATCH TO SPECIAL TYPERS
3$:     SUB     #20,R0          ;SHORTEN TABLE
        JMP     @TYPTAB(R0)     ;GO AND RETURN DIRECTLY


;SEQ211

;ROUTINE TO OUTPUT 'REGISTER NAME' '/'

TRGNAM: MOVB    (R3)+,R0        ;GET NAME BYTES
        BEQ     4$              ;IF END
        JSR     PC,PUTCHR
        BR      TRGNAM
4$:     MOVB    #'/,R0
        JSR     PC,PUTCHR
        RTS     PC

;GET NEXT OCTAL DIGIT OUT OF REGISTER, CONVERT TO ASCII
;
OCTGET: TST     BITCNT          ;ANY LEFT?
        BPL     2$              ;YES
        CMP     R4,(R5)         ;GOT ALL ?
        BLE     1$              ;YES, NO GARBAGE
        BISB    -(R4),R1        ;NO, GET NEXT BYTE, OR IN
1$:     MOV     BYTSZ,BITCNT    ;START COIUNT OVER
2$:     DEC     R3              ;COUNT SHIFTS
        BMI     3$              ;BR IF HAVE DIGIT
        ASL     R1
        DEC     BITCNT          ;COUTN BITS TAKEN
        BR      OCTGET          ;CHECK BYTE SIZE AGAIN
3$:     MOV     R1,R0           ;GHET RESULT
        BIC     #174377,R0      ;MASK LOW ORDER OF LEFT
        SWAB    R0              ;TTO     RIGHT
        ADD     #60,R0          ;MAKE ASCII
        RTS     PC


;SEQ212

;HORIZONTAL POSITIONING DISPATCH TABLES.
;USED TO MAKE ROOM FOR A NAME AND CONTENTS ON THE PAPER.
;TABLES ARE INDEXBY BY A TAB-STOP COUNTER
HP1=0
HP3=2
HP4=4
HPSIG=6
HPTABL: .WORD   ONELIN,THRLIN,FORLIN,SIGLIN

;ONE ITEM PER LINE

        DONOTH
ONELIN: CRET
        CRET
        CRET
        CRET
        CRET
        CRET
        CRET
        CRET
        CRET
        CRET

;THREE ITEMS PER LINE
        DONOTH
THRLIN: TAB3
        TAB2
        TAB1
        TAB3
        TAB2
        TAB1
        CRET
        CRET
        CRET
        CRET

;FOUR ITEMS PER LINE
        DONOTH
FORLIN: TAB2
        TAB1
        TAB2
        TAB1
        TAB2
        TAB1
        CRET
        CRET
        CRET
        CRET




;SEQ213

;SIGNAL NAMES
        DONOTH
SIGLIN: TAB3
        TAB2
        TAB1
        TAB3
        TAB2
        TAB1
        CRET
        CRET
        CRET
        CRET
;SETUP TABLES FOR GENERAL OCTAL TYPER
;INDEXED BY TFX OF REGISTER SPEC TABLE.

;SIZE OF BYTES IN BITS-1
RTBSZ:  .BYTE   7,7,1,7,5,7,5,4,7,7,5,7

;NUMBER OF DIGITS TO TYPE OUT
RTNDG:  .BYTE   1,2,2,3,3,4,4,4,6,8.,8.,12.

;NUMBER OF LEFT SHIFTS TO GET THE FIRST DIGIT OUT OF THE FIRST BYTE
RTFDG:  .BYTE   8.,5,7,2,8.,7,5,4,1,3,5,7


;SEQ214

;PUT A CHAR IN THE OUTPUT LINE BUFFER AND TRACK POSITION

PUTCHR: MOVB    R0,@CHPPTR
        TST     TABSTP
        BPL     11$
        CLR     TABSTP
11$:    INC     CHPPTR          ;ADVANCE POINTER
        INC     CHRPOS          ;COUNT CHARS
        BITB    #7,CHRPOS               ;AT A TAB STOP?
        BNE     1$              ;NO
        ADD     #2,TABSTP       ;YES, KEEP STRAIGHT
        
1$:     RTS     PC

;A DISPATCH NO-OP
DONOTH: RTS     PC

;POSITION TO A NEW LINE, FLUSH LINE BUFFER
CRET:   TST     CHRPOS          ;BUFFER EMPTY?
        BEQ     1$              ;BR IF YES
        CLR     R0
        JSR     PC,PUTCHR               ;TERMINATE WILL NULL
        JSR     PC,INCHK                ;TEST FOR ALT MOD
        MOV     #TYPBUF,R0      ;POINT TO LINE
        PNTAL                   ;PRINT
        PCRLF                   ;LINE SPACE
        JSR     PC,INCHK                ;TEST FOR ALTM MOD
        CLR     CHRPOS          ;RESET CHAR POS CTR
1$:     MOV     #TYPBUF,CHPPTR  ;RESET BUFFER POINTER
        MOV     #-2,TABSTP      ;INDICATE CLEAN, NEW LINE
        RTS     PC


;SEQ215

;DO TAB SPACING
TAB3:   MOV     #3,R1
        BR      TABX
TAB2:   MOV     #2,R1
        BR      TABX
TAB1:   MOV     #1,R1

TABX:   MOV     #'	,R0
        MOVB    R0,@CHPPTR
        INC     CHPPTR          ;SOTE AND MOVE PTR
        ADD     #2,TABSTP       ;COUNT THEM
        ADD     #8.,CHRPOS
        DEC     R1
        BNE     TABX
        BIC     #7,CHRPOS
        RTS     PC

TOPEN:  CLR     CHRPOS          ;FORCE EMPTY BUFFER
        JMP     CRET            ;DO THING AND RETURN DIRECTLY


;SEQ216

.SBTTL          SIGNAL CHANGE PRINTER

SIGPRT: CLR     TRUPNT          ;IND CLEAN PAPER
        CLR     FALPNT          ;IND NO FALSES YET
        MOV     #SIGLKT,R5      ;POINT TO SCAN TABLE
1$:     MOVB    (R5)+,R3        ;GET BIT MASK
        CLR     R4
        BISB    (R5)+,R4        ;GET BYTE OFFSET
        MOV     (R5)+,R2        ;GET NAME POINTER
        BEQ     5$              ;BR IF HIT BOTTOM
        BITB    DMPMSK(R4),R3   ;THIS ONE ENABLED?
        BEQ     1$              ;NEXT IF NOT
        BITB    NEWSTA(R4),R3   ;TEST CURRENT STATE
        BNE     2$              ;BR IF HIGH NOW
        BITB    OLDSTA(R4),R3   ;NOW LOW, TEST OLD
        BEQ     1$              ;NO CHANGE, GET NEXT
        CMP     R5,#HLBRK       ;IT CHANGED, TEST TRUTH
        BGE     3$              ;BR IF TRUE NOW
        JSR     PC,STKFLS       ;STACK IT - FALSE
        BR      1$              ;LOOK FOR MORE

2$:     BITB    OLDSTA(R4),R3
        BNE     1$              ;BR IF NO CHANGE (HIGH)
        CMP     R5,#HLBRK       ;NOW HIGH, TEST TRUTH
        BLT     3$              ;TRUE - PRINT IT
        JSR     PC,STKFLS               ;FALSE, STACK IT
        BR      1$              ;LOOK FOR MORE

3$:     JSR     PC,TRUOUT               ;OUTPUT A TRUE SIGNAL
        BR      1$              ;LOOK FOR MORE

;SEQ217

;HERE WHEN ALL TRUES ARE PRINTED
FALOUT=.
5$:     TST     FALPNT          ;ANYTHING FALSE TO PRINT?
        BNE     6$              ;BR IF SO
        CLC
        TST     TRUPNT          ;CHANGE DETECTED ?
        BEQ     51$             ;BR IF NOT
        SEC                     ;SET C TO MEAN CHANGE
51$:    RTS     PC              ;NO - ALL DONE

6$:     JSR     PC,CRET         ;FINISH TRUTE BUFFER
        PMSG    <	*** FALSE:>
        JSR     PC,CRIN         ;CR/LF - CHECK INPUT
        MOV     FALSTP,R5               ;START OF STACK
7$:     TST     DUMPFG          ;DUMP MODE?
        BEQ     71$             ;BR IF NOT
        TST     TTALFG          ;WANT TO WQUIT?
        BNE     8$              ;YUP
71$:    MOV     (R5)+,R2        ;GET NAME STRING POINTER
        JSR     PC,SIGOUT       ;UNPACK AND PRINT
        CMP     R5,FALTND       ;DONE ?
        BLT     7$              ;NO, CONTI UE PRINTING
        SEC                     ;SET TO SHOW CHANGE
8$:     RTS     PC              ;YES, RETURN


;SEQ218

TRUOUT: TST     TRUPNT          ;HAVE WE PRINTED "TRUE"?
        BNE     1$              ;BR IF SO
        INC     TRUPNT          ;NO - PRINT AND REMEMBER
        PMSG    <	*** TRUE:>
        JSR     PC, CRIN                ;CR/LF - CHECK INPUT
1$:     JSR     PC,SIGOUT               ;PRINT SIGNAL NAME
        RTS     PC

;DUMP ALL ENABLED SIGNALS
SIGDMP: CLR     TRUPNT
        CLR     FALPNT
        MOV     #SIGLKT,R5      ;POINT TO SCAN L8IST
1$:     TST     TTALFG  ;WANT TO QUIT?
        BEQ     11$             ;BR IF NOT
        RTS     PC
11$:    MOVB    (R5)+,R3        ;GET MASK
        CLR     R4
        BISB    (R5)+,R4        ;GET INDEX
        MOV     (R5)+,R2        ;GET NAME POINTER
        BEQ     5$              ;ZERO IS END
        BITB    DMPMSK(R4),R3   ;ENABLED?
        BEQ     1$              ;BR IF NOT
        BITB    NEWSTA(R4),R3   ;TEST STATE
        BEQ     2$              ;NOW LOW
        CMP     R5,#HLBRK       ;TEST TRUTH
        BLT     3$              ;HIGH-TRUE,PRINT IT
        JSR     PC,STKFLS               ;LOW-FALSE,SAVE IT
        BR      1$              ;GET NEXT
2$:     CMP     R5,#HLBRK               ;TEST TRUTH
        BGE     3$              ;BR IF LOW TRUE
        JSR     PC,STKFLS       ;HIGH-FALSE, SAVE IT
        BR      1$
3$:     JSR     PC,TRUOUT
        BR      1$
        
5$:     TST     SHRTPT          ;DUMP TRUES ONLY?
        BNE     6$              ;BR IF YES
        JMP     FALOUT         ;PRINT FALSES AND QUIT
6$:     CLC
        RTS     PC              ;RETURN


;SEQ219

;SAVE POINTERS TO FALSE SIGNALS ON A FIFO STACK
STKFLS: TST     FALPNT          ;FIRST TIME?
        BNE     1$              ;BR IF NOT
        INC     FALPNT          ;REMEMBER
        MOV     CORFF,FALSTP    ;POINT TO FREE SPACE
        INC     FALSTP          ;MAKE IT EVEN!
        BIC     #BIT0,FALSTP
        MOV     FALSTP,FALTND   ;NEW POINTER FOR STORAGE
1$:     MOV     R2,@FALTND      ;SAVE STRING PTR
        ADD     #2,FALTND       ;BUMP STORAGE PTR
        RTS     PC

;UNPACK, TRANSLATE, AND PRINT A SIGNAL NAME
SIGOUT: MOV     #SIGLIN,R4      ;POINT TO POSITIONER TABLE
        ADD     TABSTP,R4       ;OFFSET BY CURRENT POS
        JSR     PC,@(R4)        ;MAKE A PLACE FOR IT
        CLR     R4
        BISB    (R2)+,R4        ;GET FIRST STRING ITEM
        ASL     R4              ;MAKE A WORD PTR
        ADD     #FSWDTB,R4      ;OFFSET INTO :FIRST WORD" TABLE
        BR      4$              ;GO PUT EXLATION INTO BUFFER
1$:     MOVB    (R2)+,R4        ;GET A STRING BYTE
        BMI     3$              ;BR IF TO TRANSLATE
2$:     BEQ     21$             ;IF DONE
        MOVB    R0,R1           ;SAVE PREGIOUS CHAR
        MOVB    R4,R0           ;THIS CHAR
        JSR     PC,PUTCHR       ;STUFF IT
        BR      1$              ;GET NEXT
21$:    CMP     R1,#'           ;MAKE SURE SPACE AT END
        BEQ     22$
        MOVB    #' ,R0
        JSR     PC,PUTCHR
22$:    RTS     PC

3$:     BIC     #177600,R4      ;SAVE SEVEN BITS
        ASL     R4              ;MAKE WORD PTR
        ADD     #SBSTAB,R4      ;OFFSET INTO WORD SUBS TABLE
4$:     MOV     (R4),R3         ;GET STRING PTR
5$:     MOVB    R0,R1           ;SDAVE PREVIOUS CHAR
        MOVB    (R3)+,R0        ;GET CHAR
        BEQ     6$              ;BR IF DONE
        JSR     PC,PUTCHR               ;STUFF IT
        BR      5$
6$:     CMPB    R1,#'/          ;CHECK SPECIAL CASE     
        BEQ     1$              ;NO SPACE WANTED
        MOVB    #' ,R0
        JSR     PC,PUTCHR               ;ADD SPACE
        BR      1$              ;CONTINUE


;SEQ220

.SBTTL          MACROS
;
;MACRO TO BUILD A REGISTER SPECIFICATION TABLE
;

.MACRO  RS      N,SR,SI,TP,HP,SL,TL,P1,S1,P2,S2,P3,S3,P4,S4
        .NARG   NBR
        NBR=NBR-7
        .NLIST  SRC
        $$CLIT
        .LIST   SRC
        .NLIST
        $$CLC=.
        .=$$CLIT
        .BLKB   <2*SI>
        .ASCIZ  %N%
        $$CLIT=.
        .=$$CLC
        .LIST
        .NLIST  SRC
        .BYTE   SR,SI,TP,HP
        .WORD   TL
        .WORD   SL
        .LIST   SRC
        .IIF    EQ      NBR,.MEXIT

        SW      P1,S1
        .IIF    EQ              NBR,.MEXIT
        SW      P2,S2
        .IIF    EQ      NBR,.MEXIT
        SW      P3,S3
        .IIF    EQ      NBR,.MEXIT
        SW      P4,S4
        .ENDM   RS

;MACRO TO HANDLE THE STORAGE POINTER BYTES

.MACRO  SW      A,BB
        .NLIST  SRC
        B=^D'BB
        F=0
        NBR=NBR-2
        .IIF    EQ      NBR,F=200
        .BYTE   A,<F!B>
        .LIST   SRC
        .ENDM   SW

;SEQ221

;MACRO TO MAKE A SPEC TABLE FOR BIT STORAGE.
.MACRO  BS      A,LK
        .NLIST  SRC
        .WORD   A,SBITS,0,LK,0
        .LIST   SRC
        .ENDM   BS

.MACRO  S       L,R
        .NLIST  SRC
        LL=^D'L
        .BYTE   R,LL
        .LIST   SRC
        .ENDM   S

        .MACRO  SBW     W
        .NLIST  SRC
        .WORD   $$CLIT
        $$CLC=.
        .=$$CLIT
        .ASCIZ  %W%
        $$CLIT=.
        .=$$CLC
        .LIST   SRC
        .ENDM   SBW

        .MACRO  SIG     B,M,N
        .NLIST  SRC
        BB=^D'B
        .BYTE   M,BB
        .WORD   $$CLIT
        $$CLC=.
        .=$$CLIT
        .ASCIZ  N
        $$CLIT=.
        .=$$CLC
        .LIST   SRC
        .ENDM   SIG


;SEQ222

.SBTTL          REGISTER SPEC TABLES
.REM    %
        THESE REGISTER SPECIFICATION TABLES AE EACH MEMBERS OF TWO
LISTS.  ONE IS THE TYPEOUT LIST WHICH LINKS TOGETHER ALL THOSE REGISTERS
BELONGING TO ONE OF THE GROUPS SELECTABLE BY THE USER FOR TRACING.  IN
THAT LIST, THE TABLES ARE LINKED IN THE ORDER IN WHICH THEY ARE SCANNED
WHEN CHECKING FOR CHANGES.  THE OTHER LIST IS THE STORAGE LIST, A
        
SUBSET OF THE TYPEOUT LIST OCMPRISING THOSE REGITSTERS READ BY A
PARTICULAR DIAGNOSTIC READ FUNCTION GROUP, E.G. 10X, 13X.
        DIAGNOSTIC READS ARE ALWAYS PERFORMED IN GROUPS OF EIGHT, THE
INFORMATION BEING PLACED IN A FORTY-BYTE BUFFER.  PART OF THE SPEC TABLE
DESCRIBES TO THE STORAGE ROUTIEN HOW TO GET THE PIECES OF A REGISTER
OUT OF THE INPUT BUFFER AND TO UPDATE THE "NEW-CONTENTS, OLD-COINTENTS"
STORAGE.  THE RESET OF THE SPEC TABLE DESCRIBES HOW TO FORMAT THE
STORED DATA FOR TYPING.
                ********************
                *       PST        *
                ********************
               *  SIB   *   SRI  *
                ********************
                *   HP0   *   TFX   *
                ********************
                *       TPL        *
                ********************
                *       SLK        *
                ********************
                *0*BI(1)* PR0(1)**
                *********************
                .       .          .
                .       .          .
                *1*BI(N)*  PRO(N)*
                **********************
%

;SEQ223

.REM    %
                REGISTER SPEC TABLE


        PST     STORAGE POINTER:  POINTS TO BASE OF A BUFFER
                CONTAINING "SIB" BYTES OF NEW CONTENTS, "SIB" BYTES
                OF OLD CONTENTS.  FOLLOWED BY THER EGISTER NAME
                IN .ASCIZ FORMAT.
        SRI     STORAGE ROUTINE INDEX:  INDEXES A DISPATCH TABLE
                WHICH POINTS TO THE ROUTINE USED TO TRANSFER
                REGISTER CONTENTS FROM NEW TO OLD, AND INPUT TO NEW.
        SIB     STORAGE IN BYTES: THE SIZE OF THE NEW CONTENTS OR
                OLD CONTENTS BUFFER.
        TFX     TYPEOUT FORMAT INDEX:  INDEXES A DISPATCH TABLE
                WHICH POINTS TO THE ROUTINE USED TO FORMAT AND
                TYPE THE REGISTER CONTENTS.
        HPO     HORIZONTAL POSITION:  USED TO ACCESS A TABLE WHICH
                CAUSES TABBING OR CRLF TO MAKE ROOM FOR THIS REGISTER
                PRINTOUT.

        TPL     TYPEOUT LINK:    THE WORD LINK TO THE NEXT
                SPEC TABLE IN THE TYPEOUT LIST.
        SLK     STORAGE LINK:  POINTER TO THE NEXT MEMBER OF THE
                STORAGE LIST, OR IS ZERO IF THIS REGISTRER ENDS A LIST.
        PRO     PROCESS INDEX:  INDEXES INTO SHIFT COUNT AND MASK
        TABLES USED BY STORING ROUTINE.
        B1      BYTE POSITION INDEX:  POINTS AT A BYTE OR THE LOWEST
                OF TWO BYTES IN THE 40-BYTE INPUT BUFFER.
        (THERE MAY BE FROM 0 TO 4 PRO-BI PAIRS IN THE SPEC TABLE.)
        %
;
;REGISTER SPEC TABLE OFFSETS
;
PST=0
SRI=2
SIB=3
TFX=4
HPO=5
TPL=6
SLK=10
PRO=12
BI=13

        .LIST   BEX


;SEQ224


PIH:    RS <PI HOLD>,SBYT,1,F0T7B,HP3,PIO,PIO,S2M177,3
PIO:    RS <PI ON>,SBYT,1,F0T7B,HP3,PIG,EBC,S2M177,2
PIG:    RS <PI GEN>,SBYT,1,F0T7B,HP3,EBC,PIH,S2M177,7
EBC:    RS <EBUS CS>,SBYT,2,F1T7B,HP3,VOP,BST,S2M357,12,S0M40,17
        
VOP:    RS <VMAH OR PC>,SBYT,2,F2T4O,HP3,BST,AD,S4M77,6,S4M77,1
BST:    RS <BURST>,SBYT,2,F2T3O,HP3,0,0,S0M77,5,S0M3,0
METR:   RS <TIME>,SBYT,2,F0T6O,HP3,PRF,PRF,S0M377,0,S0M377,1
PRF:    RS <PRF CNT>,SBYT,2,F0T6O,HP3,ECN,ECN,S0M377,5,S0M377,6


;SEQ225
ECN:    RS <EBX CNT>,SBYT,2,F0T6O,HP3,CCN,CCN,S0M377,10,S0M377,11
CCN:    RS <CSH CNT>,SBYT,2,F0T6O,HP3,ITV,ITV,S0M377,15,S0M377,16
ITV:    RS <INTRVL>,SBYT,2,F0T4O,HP3,PRD,PRD,S0M377,20,S0M17,21
PRD:    RS <PERIOD>,SBYT,2,F0T4O,HP3,MPI,MPI,S0M377,25,S0M17,26
MPI:    RS <MTR PIA>,SBYT,1,F0T1O,HP3,0,0,S0M7,30
FBA:    RS <FM BLOCK,ADR>,SBYT,1,F0TFM,HP3,ACP,VMA,S5M177,22
AR:     RS <AR>,SWRD,5,F0T12O,HP3,ARX,ARX,0,0


;SEQ226

ARX:    RS <ARX>,SWRD,5,F0T12O,HP3,BR,MQ,0,25
BR:     RS <BR>,SWRD,5,F0T12O,HP3,BRX,BRX,0,5
BRX:    RS <BRX>,SWRD,5,F0T12O,HP3,AD,ERG,0,20
AD:     RS <AD>,SWRD,5,F0T12O,HP3,ADX,ADX,0,35
ADX:    RS <ADX>,SWRD,5,F0T12O,HP3,FM,FM,0,30
FM:     RS <FM>,SWRD,5,F0T12O,HP3,MQ,AR,0,15
MQ:     RS <MQ>,SWRD,5,F0T12O,HP3,0,BR,0,10
SC:     RS <SC>,SBYT,2,F4T4O,HP3,FE,PIG,S0M37,3,S0M37,8


;SEQ227

FE:     RS <FE>,SBYT,2,F4T4O,HP3,IR,SC,S0M37,13,S0M37,18
IR:     RS <DR ADR(IR)>,SBYT,2,F2T3O,HP3,ACFM,ACFM,S2M77,7,S2M7,2
ACFM:   RS <AC>,SBYT,1,F0T2O,HP3,TRM,DRD,S2M17,12
TRM:    RS <TRP MIX>,SBYT,2,F6T2O,HP3,0,CSA,S7M3,38,S7M3,33
CSA:    RS <CRA STK ADR>,SBYT,1,F0T2O,HP3,CRD,CRD,S6M17,3
PSC:    RS <PREV SEC>,SPSC,1,F0T2O,HP3,0,ACP
ACP:    RS <AC+#>,SBYT,1,F0T2O,HP3,0,FE,S2M17,7
DRD:    RS <DRAM A B J P>,SBYT,3,F0TDRM,HP3,0,CRL,S2M77,17,S2M17,22,S2M57,27

;SEQ228

CRL:    RS <CR ADR>,SBYT,2,F2T4O,HP3,SBR,SBR,S6M77,23,S6M37,28
SBR:    RS <SBR RET>,SBYT,2,F2T4O,HP3,CSA,TRM,S6M77,13,S6M37,18
CRD:    RS <CONTROL RAM>,SCRM,13.,F0TCRM,HP1,0,0
VMA:    RS <VMA>,SVMA,3,F0T8O,HP3,VMH,VMH,0,6
VMH:    RS <VMAH>,SVMA,3,F0T8O,HP3,ABK,VOP,0,2
ABK:    RS <ADR BRK>,SVMA,3,F0T8O,HP3,TPC,TPC,0,4
TPC:    RS <PC>,SVMA,3,F0T8O,HP3,PSC,FBA,0,0

;SEQ229

ERG:    RS <EBUS RG>,SWRD,5,F0T12O,HP3,0,PSC,0,35
CBA:    RS <CHB ADR>,SCHB,1,F0T3O,HP3,CHA,CHA
CHA:    RS <CCW CHA>,SCHA,4,F7T8O,HP3,CRCA,CRCA
CRCA:   RS <CRC CH ADR>,SLBYT,1,F0T2O,HP3,CPT,CPT,S7M17,38
CPT:    RS <CRC MEM PTR>,SBYT,1,F0T2O,HP3,CSD,CSD,S7M17,33
CSD:    RS <CRC SEL D>,SLBYT,1,F0TRV,HP3,0,0,S0M7,29


;SEQ230

.SBTTL          SIGNAL BIT SPEC TABLES
.REM    %
        THESE SIGNAL BIT SPEC TABLES SPECIFY UNPACKING AND STORING
OF DIAGNOSTIC BIT BYTES.  THE DIAGNOSTIC FUNCTIONS ARE READ IN GROUPS
OF 8 INTO A 40-BYTE BUFFER AND THEN SIGNAL BITS ARE STORED INTO
A TABLE WHERE THEY ARE TESTED BY THE SIGNAL CHANGED PRINTER OR SIGNA
DUMPER.  THE BS MACRO GENERATES A SPEC TABLE ENTRY IN
AFORMAT COMPATIBLE WITH THE REGISTER SPEC TABLE AS FAR AS LINKING
IS CONCERNED.  THE FIRST ARGUMENT OF THE BS MACRO IS THE OFFSET FOR
THE FOLLOWING GROUP OF SIGNAL BYTES DEFINED BY S MACROS.
        THE S MACRO HAS 2 ARGUMENTS. THE FIRST SPECIFIES A STARTING
BYTE IN THE 40-BYTE INPUT BUFFER, WHILE THE SECOND SPECIFIES HOW 
MANY CONSECUTIVE BYTS TO ADDRESS AND MOVE TO THE SIGNAL STORAGE
TABLE.
        %
EBX0:   BS      0,EBX1          ;THIS PART STARTS AT OFFSET 0

;                       D.F. - EBUS BITS
        S       0,2             ;100 - 28-35,20-27
        S       3,1             ;100 - 4-11
        S       5,2             ;101 - 28-35,20-27
        S       10,3            ;102 - 28-35,20-27,12-19
        S       15,4            ;103 - 28-35,20-27,12-19,4-11
        S       20,3            ;104 - 28-35,20-27,12-19
        S       25,3            ;105 - 28-35,20-27,12-19
        S       30,3            ;106 - 28-35,20-27,12-19
        S       35,3            ;107 - 28-35,20-27,12-19
        0                       ;TABLE TERMINATOR


;SEQ231
EBX1:   BS      30,EBX3         ;THIS PART STARTS AT OFFSET 30

;                       D.F. - EBUS BITS
        S       2,3             ;110 - 12-19,4-11,0-3
        S       7,2             ;111 - 12-19,4-11
        S       12,2            ;112 - 12-19,4-11
        S       17,2            ;113 - 12-19,4-11
        S       22,2            ;114 - 12-19,4-11
        S       27,2            ;115 - 12-19,4-11
        S       32,2            ;116 - 12-19,4-11
        S       37,2            ;117 - 12-19,4-11
        S       26,1            ;115 - 20-27
        S       31,1            ;116 - 20-27
        S       36,1            ;117 - 20-27
        0                       ;TABLE TERMINATOR

EBX3:   BS      54,EBX4         ;THIS PART STARTS AT OFFSET 54

;                       D.F. - EBUS BITS
        S       1,4             ;130 - 20-27,12-19,4-11,0-3
        S       6,4             ;131 - 20-27,12-19,4-11,0-3
        S       11,4            ;132 - 20-27,12-19,4-11,0-3
        S       16,4            ;133 - 20-27, 12-19,4-11,0-3
        S       21,4            ;134 - 20-27,12-19,4-11,0-3
        S       26,4            ;135 - 20-27,12-19,4-11,0-3
        S       31,4            ;136 - 20-27,12-19,4-11,0-3
        S       36,4            ;137 - 20-27,12-19,4-11,0-3
        0                       ;TABLE TERMINATOR


;SEQ232

EBX4:   BS      114,EBX5                ;THIS PART STARTS AT OFFSET 114

;                       D.F. - EBUS BITS
        S       3,2             ;140 - 4-11,0-3
        S       19,1            ;143 - 0-3
        S       29,1            ;145 - 0-3
        0                       ;TABLE TERMINATOR

EBX5:   BS      120,0           ;THIS PART STARTS AT OFFSET 120

;                       D.F. - EBUS BITS
        S       3,1             ;150 - 04-11
        S       8,1             ;151 - 04-11
        S       13,1            ;152 - 04-11
        S       17,1            ;153 - 12-19
        S       37,1            ;157 - 12-19
        0                       ;TABLE TERMINATOR
MBX6:   BS      125,MBX7        ;THIS PART STARTS AT OFFSET 125
;                       D.F. - EBUS BITS
        S       0,3             ;160 - 28-35,20-27,12-19
        S       5,3             ;161 - 28-35,20-27,12-19
        S       10,3            ;162 - 28-35,20-27,12-19
        S       15,2            ;163 - 28-35,20-27
        S       20,2            ;164 - 28-35, 20-27
        S       25,2            ;165 - 28-35,20-27
        S       30,2            ;166 - 28-35,20-27
        0                       ;TQABLE TERMINATOR


;SEQ233

MBX7:   BS      146,0           ;THIS PARTSTARTS AT OFFSET 146

;                       D.F. - EBUS BITS
        S       0,2             ;170 - 28-35,20-27
        S       5,2             ;171 - 28-35,20-27
        S       10,2            ;172 - 28-35,20-27
        S       15,2            ;173 - 28-35,20-27
        S       20,2            ;174 - 28-35,20-27
        S       25,2            ;175 - 28-35,20-27
        S       30,2            ;176 - 28-35,20-27
        S       35,2            ;177 - 28-35,20-27
        0                       ;TABLE TERMINATOR
CHN7:   BS      166,0           ;THIS PART STARTS AT OFFSET 166

;                       D.F. - EBUS BITS
        S       2,3             ;170 - 12-19,4-11,0-3
        S       7,3             ;171 - 12-19,4-11,0-3
        S       12,3            ;172 - 12-19,4-11,0-3
        S       17,3            ;173 - 12-19,4-11,0-3
        S       22,3            ;174 - 12-19,4-11,0-3
        S       27,3            ;175 - 12-19,4-11,0-3
        S       32,3            ;176 - 12-19,4-11,0-3
        S       37,3            ;177 - 12-19,4-11,0-3
        0                       ;TABLE TERMINATOR
        .EVEN


;SEQ234

.SBTTL          VARIABLES AND CONSTANTS

KCCLOC: .WORD   0               ;KLDCP CONTROL C ADDRESS GOES HERE
CCRET:  .WORD   0               ;WHERE TO GO IF CONTROL C
AUTOIN: .WORD   0               ;AUTO INSERT FLAG
OVFLAG: .WORD   0               ;OVERFLOW FLAG
CCLFLG: .WORD   0               ;I OR J FILE FLAG
CMDNUM: .WORD   0               ;COMMAND #
RLINE:  .WORD   0               ;LINE# FOR REPLACE
LSTADR: .WORD   0,0             ;LAST ADDRESS STOREAGE
SBOUT:  .BLKW   3               ;TEMPORARY STORAGE

PRINT.: .WORD   0               ;BUFFER PRINT FLAG
XCT.:   .WORD   0               ;BUFFER EXECUTION FLAG
LOOP.:  .WORD   0               ;COMMAND LOOP FLAG
MARK.:  .WORD   0               ;BEGINNING OF LOOP
QUEBUF: .WORD   0               ;QUEUE DATA POINTER
CHDFLT: .WORD   0               ;DEFAULT CHANNEL
CMPARE: .WORD   0               ;COMAPRE FLAG
TTYBUF: .WORD   0               ;LOCATION OF COMPARE TEXT
CMPPTR: .WORD   0               ;LOCATION OF COMPARE TEXT
HOLSIZ: 0               
LCHANG: 0
NTLIMT: 30.                     ;THRESHOLD FOR TICKS WITHOUT CHANGE
CDEND:  0                       ;CRASH DUMP END ADDRESS HOLDER
DTESTA: 0                       ;CURRENT DRTE20 HALT STATE HOLDER
DTDIAG: 0               ;POINTER TO DIAG1
DMSK:   0
RDELTA: 0
CRSHFG: 0                       ;READING CRASH FILE FLAG - 0 IS OFF
EBAFLG: 0                       ;AUTO EBUS ACTIVITY PRINT FLAG - 0 IS OFF
DUMPFG: 0                       ;DUMP GLAG, -1 MEANS PRINT EVERYTHING
TABSTP: 0                       ;TAB POSITION COUNTER
CHRPOS: 0                       ;CHARACTER POSITION COUNTER
BYTSZ:  0                       ;BYTE SIZE FOR REGTYP
BITCNT: 0                       ;BIT COUNTER FOR REGTYP
CHPPTR: 0                       ;CHARACTER POINTER FOR TYPBUF
;BIT15=EBOX, BIT14=MBOX,BIT13=CHAN,BIT12=CYCLIC
;BIT11=MICRO, BIT10=DATA, BIT09=METER, BIT08CHAN
TSWITCH:        146000
SHRTPT: -1                      ;IF SET, PRINT ONLY TRUE SIGNALS
ALLRFG: 0                       ;IF SET, PRINT ALL RES WHEN E-CLOCK TRUE
ONCEFG: 0
BSTFG:  0
TTALFG: 0
EDITFG: 0
FLGLOW: 0                       ;LOW TRUTH DIGIT FLAG
;       REVERSED DIGIT TABLE
REVTAB: .BYTE   60,64,62,66,61,65,63,67
TICK:   0
EDLINT: 0
        .BLKW   29.
TRUPNT: 0
FALPNT: 0
NEWSTA: .BLKB   DSTSIZ

;SEQ235

OLDSTA: .BLKB   DSTSIZ

DMPMSK: .BLKB   DSTSIZ
;EBUS BIT STATISTIC ACCUMULATORS
EBSAND: 1$,2$,3$,4$,5$,6$,7$,8$


1$:     .BLKB   5
2$:     .BLKB   5
3$:     .BLKB   5
4$:     .BLKB   5
5$:     .BLKB   5
6$:     .BLKB   5
7$:     .BLKB   5
8$:     .BLKB   5
EBSOR:  1$,2$,3$,4$,5$,6$,7$,8$


1$:     .BLKB   5
2$:     .BLKB   5
        
3$:     .BLKB   5
4$:     .BLKB   5

5$:     .BLKB   5
6$:     .BLKB   5
7$:     .BLKB   5
8$:     .BLKB   5
GRDAND: .BLKB   5
GRDOR:  .BLKB   5
;END OF EBUS BIT STATISTICS ACCUMULATORS

RQCURR: 0
RQLIST: 0
RQMSK:  0
R2SAV:  0
FALSTP: 0
FALTND: 0
CORFF:  0
FRINBF:
TYPBUF: .BLKB   80.
        .EVEN


;SEQ236
        .SBTTL  SIGNAL NAME CONVERTER - SNOBOL

.REM    \

* THIS IS A SNOBOL PROGRAM USED TO CONVERT A FILE OF DIAGNOSTIC SIGNALS
* INTO A FORM USEABLE BY THE TRACON PROGRAM.  THE INPUT FILE IS SORTED
* IN ASCENDING ORDER BY SIGNAL NAME AND HAS RECORDS OF THE FOLLOWING
* FORM:
*<TAB>  DF  <TAB BIT <TAB> DWNG <TAB> M#### <TAB> SIGNAL NAME
* WHERE DF IS DIAGNOSTIC READ CODE, BIT IS EBUS BIT NUMBER, DWNG IS THE
* DRAWING NAME OF THE SIGNAL SOURCE, M#### IS THE BOARTD HAVING THE
* DIAGNOSTIC MULTIPLEXER, SIGNAL NAME IS THE PROPER NAME BEGINNING
* WITH A DRAWING PREFIX AND ENDING WITH H OR L.
*
* THE OUTPUT OF THE PROGRAM IS A FILE CONTAINING THREE TABLES. THE FIRST
* FSWDTB, CONTAINS ALL THE DRAWING NAMES MINUS THE PAGE NUMBER CHARACTER
* AT THE END.  THE SECOND, SBSTAB, CONTAINS TGE 128 WORDS USED MOST
* OFTEN INT HE SIGNAAL NAMES.  (MORE PROPERLY THOSE WHOSE PRODUCT OF SIZE
* AND FREQUENCY OF USAGE IS GREATEST.)  THE LAST IS A TRANSLATION OF
* THE INPUT FILE AS FOLLOWS:
* ALL LINES BEGINNING WITH ";" ARE UNMODIFIED.
* DF AND BIT ARE TRANSFORMED INTO AN INDEX AND MASK USED TO ACCESS
* THE SIGNAL BIT IN TRACON'S SIGNAL STORAGE TABLES.
* THE DWNG, BOARD AND NAME ARE OUTPUT AS A COMMENT.
* A COMPRESSED FORM OF THE NAME IS OUTPUT HAVING THE DRAWING PREFIX AND
* OTHER WORDS REPLACED BY CHARACTERS SERVING S INDICES INTO THE FIRST
* TWO TABLES MENTIONED. THIS LAST TABLE IS OUTPUT FURTHER SORTE BY
* H AND L AND THOSE CHARACTERS ARE DROPPED FROM THENANES.,  ONE LINE
* HLBRK=. SIGNIFIES THE TRANSITION FROM THE H HALF TO THE L HALF OF
* THE TABLE.
*

        &DUMP = 0
        $TRIM = 1
        $



        &DUMP = 0
        &TRIM = 1
        &ANCHOR = 1
        DEFINE('SORTXX()I')
        DEFINE('SWITCH(1)TEMPW,TEMPC')
        DEFINE('BUBBLE(J)')

*
*
        NULL =
        XDF = TABLE (150,10)
        SBSTAB = TABLE(700,50)
        FSWDTB = TABLE(50,10)
        BMK = ARRAY(8)
        F = BREAK('     ') SPAN('       ')


;SEQ237

*
* PATTERNS
*
 
DFBIT = SPAN('  ') BREAK('      ') . DF SPAN('  ') BREAK('      ') . BIT

WORD = (('SPEC'  !  'COND'  !  'SKIP') '/')  '/') . WD NULL . BC ! BREAK('      ') .  WD
* SPAN('        ') . BC  !  LEN(1)  . WD
        PASS = '1'
* DEFINE BYTE MASK BALUES USED IN DIAG BIT TRANSLATION
        BMK<1>  = '1'
        BMK<2>  =       '2'
        BMK<3>  = '4'
        BMK<4>  = '10'
        BMK<5>  = '20'
        BMK<6>  = '40'
        BMK<7>  =       '100'
        BMK<8>  = '200'

* NOW FILL TABLE USED TO GENERATE STORAGE INDICES FROM DIAGNOSTIC
* FUNCTION -BYTE
        INPUT('DFBYTE','XLAT.SBL')
        INDEX = 
FILLX   SDF<DFBYTE> = CONVERT(INDEX,'STRING')   :F(ENDX)
        INDEX = INDEX + 1               :(FILLX)
ENDX    ENDFILE('XLAT.SBL')
        INPUT('INPUT','PROTO.NAM')

*
*
* READ A LINE, DISCARD IF STARTS WITH ;, OTHERWISE STRIP OFF
* FIRST FOUR COLUMNS TO GET TO THE SIGNAL NAME.
*
STOP1
COM1
GETLINE LINE = INPUT            :F( $('ENDP' PASS) )
        LINE    ';'                     :S( $('COM' PASS) )
        WDN = '0'
        LINE DFBIT =
        TAG = LINE

        LINE F F F =
        TSIGNAM = EQ(PASS,'1') TSIGNAM + 1
* NOW GET A WORD AT A TIME AND PROCESS IT.  THE FIRST WORD
* OF THE NAME GOES TO FSWDTB.  ALL OTHERS GO TO SBSTAB.
GETWORD BC =
        LINE WORD =                     :F(HLERROR)
        WD      ('H' ! 'L')

;SEQ238

* END OF FIRST PASS, PREPARE FOR SEOOND

ENDP1   REWIND('PROTO.NAM')
        OUTPUT(DSH','DSIGS.P.11')
        OUTPUT('DSL','DSIGS.TMP')

        PASS = '2'
* PROCESS THE FIRST WORD SUBSTITUTION TABLE

        FSWDTB = CONVERT(FSWDTB,'ARRAY')
        DSH = '.PAGE'
        DSH = '.SBTTL   SIGNAL NAMES'
        DSH = '; FIRST WORD SUBS TABLE (DRAWING NAMES)'
        DSH = 'FSWDTB:'

WRFSW   K = K + 1
        FSWDTB<K,2> = CONVERT(K - 1,'STRING')   :F(WRFEND)
        DSH     = ' SBW         <'FSWDTB<K,1>  '>'      ;S(WRFSW)
WRFEND  DSH = '.PAGE'

* NOW GENERATE AND OUTPUT THE IN-TEXT SWORD SUBS TABLE

        DSH = '; IN-TEXT WORD SUBS TABLE'
        DSH = 'SBSTAB:'
        SBSTAB = CONVERT(SBSTAB,'ARRAY')

* CALCULATE A FIGURE OF MERIT BASED ON WORD LENGTH AND USAGE.
* SORT ON THIS AND KEEP HIGHEST 128 ENTRIES.

CALMERIT        L = L + 1
        SBSTAB<L,2> = (SBSTAB<L,2> - 1) * SIZE(SBSTAB<L,1>) - 3  :S(CALMERIT)

* MAKE SURE INPUT/OUTPUT ASSOCIATION CHECKS DONT SLOW DOWN
* THE SORTING.
        &INPUT = 0
        &OUTPUT = 0
        SORTXX()
        &INPUT = 1
        &OUTPUT = 1

WRSBS   J = J + 1
        SBSTAB<J,2> = CONVERT(J + 127,'STRING')
        DSH = LT(J,129)  '      SBW     <'SBSTAB<J,1>  '>'      :S(WRSBS)
        SBSTAB<J,2> = NULL              :S(WRSBS)
        DSH = '.PAGE'
        DSH = ';SIGNAL NAME STORAGE'
        DSH = 'STGLKT:'
        FSWDTB = CONVERT(FSWDTB,'TABLE')
        SBSTAB = CONVERT(SBSTAB,'TABLE')        :(GETLINE)

* COME HERE ON FIRST WORD OF NAME DURING SECOND PASS

PR002   EBIT = CONVERT(BIT,'INTEGER')
        WRIT = 35 - EBIT
        BYTE = WBIT / 8
        BBIT = WBIT - (8 * BYTE) + 1
        DFB = DF CONVERT(BYTE,'STRING')

;SEQ239

OL = 'SIG       ' XDF<DFB> '    ' BMK<BBIT>
        
OL = OL  '      <<' FSWDTB<WD> '.>'
        
OLD = 'TRA'             :(NXTWD)


;SEQ240

* HERE ON ALL BUT FIRST SIGNAL WORDS IN PASS 2

PRO12   GT(SIZE(SBSTAB<WD>),0)          :F(  $(OLD 'ASC')  )S(  $(OLD 'TRA')  )
FSTASC  OL = OL WD              :(CURASC)
FSTTRA  OL = OL '%<' SBSTAB<WD> '.>'    :(CURTRA)

ASCASC  OL =OL ' '              ;(FSTASC)
ASCTRA  OL = OL ' '             :(FSTTRA)
***NOTE THAT 44 LINES OF ADDITONAL COMMENTS NOT INPUT HERE***
\
;SEQ241

.SBTTL SIGNAL NAMES
;FIRST WORD SUBS TABLE (DRAWING NAMES)
FSWDTB:
        SBW     <APR6>
        SBW     <CRC4>
        SBW     <SCD4>
        SBW     <CCW4>
        SBW     <CRC5>
        SBW     <SCD5>
        SBW     <CCW5>
        SBW     <CRC6>
        SBW     <CCW6>
        SBW     <CHA3>
        SBW     <CON1>
        SBW     <CON2>
        SBW     <CON3>
        SBW     <CON4>
        SBW     <MTR2>
        SBW     <CON5>
        SBW     <MTR3>
        SBW     <CHC1>


;SEQ242

        SBW     <CHC2>
        SBW     <MEM5>
        SBW     <MCL1>
        SBW     <MTR5>
        SBW     <CHC3>
        SBW     <VMA1>
        SBW     <MCL2>
        SBW     <MCL3>
        SBW     <PAG5>
        SBW     <VMA3>
        SBW     <CHC5>
        SBW     <MBX1>
        SBW     <VMA4>
        SBW     <MCL4>
        SBW     <MBX2>
        SBW     <MBX3>
        SBW     <MCL5>
        SBW     <MCL6>
        SBW     <MBX4>


;SEQ243

        SBW     <MBX5>
        SBW     <MBX6>
        SBW     <CLK1>
        SBW     <MBZ1>
        SBW     <SHD1>
        SBW     <CTL1>
        SBW     <PIC1>
        SBW     <PIC2>
        SBW     <CLK2>
        SBW     <CTL2>
        SBW     <PIC3>
        SBW     <CTL3>
        SBW     <CLK3>
        SBW     <MBZ3>
        SBW     <SHM1>
        SBW     <MBZ4>
        SBW     <CLK4>
        SBW     <PIC5>


;SEQ244

        SBW     <MBZ5>
        SBW     <CSH1>
        SBW     <CLK5>
        SBW     <CSH2>
        SBW     <MBZ6>
        SBW     <MBC1>
        SBW     <CSH3>
        SBW     <CSH4>
        SBW     <MBC2>
        SBW     <CSH5>
        SBW     <MBC3>
        SBW     <CSH6>
        SBW     <MBC4>
        SBW     <MBC5>
        SBW     <CSH7>
        SBW     <IRD1>
        SBW     <CCL1>
        SBW     <IRD3>
        SBW     <IRD4>


;SEQ245

        SBW     <CCL2>
        SBW     <CCL3>
        SBW     <EDP3>
        SBW     <CCL4>
        SBW     <CCL5>
        SBW     <CRA3>
        SBW     <CCL6>
        SBW     <APR1>
        SBW     <EBUS>
        SBW     <CHX2>
        SBW     <APR2>
        SBW     <SCD1>
        SBW     <APR3>
        SBW     <CHX3>
        SBW     <CCW1>
        SBW     <CRC1>
        SBW     <CHX4>
        SBW     <CRC2>
        SBW     <APR4>


;SEQ246

        SBW     <SCD2>
        SBW     <CRC3>
        SBW     <APR5>
        SBW     <CCW3>


;SEQ247


;IN-TEXT WORD SUBS TABLE
SBSTAB:
        SBW     <SEL>
        SBW     <CSH>
        SBW     <PAR>
        SBW     <EBOX>
        SBW     <IN>
        SBW     <EN>
        SBW     <ADR>
        SBW     <MEM>
        SBW     <REQ>
        SBW     <ERR>
        SBW     <CACHE>
        SBW     <WR>
        SBW     <DATA>
        SBW     <LOAD>
        SBW     <PAGE>
        SBW     <VMA>
        SBW     <HOLD>
        SBW     <CHAN>



;SEQ248


        SBW     <CBUS>
        SBW     <MBOX>
        SBW     <REFILL>
        SBW     <CRY>
        SBW     <CYC>
        SBW     <MB>
        SBW     <CORE>
        SBW     <SBUS>
        SBW     <DONE>
        SBW     <1>
        SBW     <2>
        SBW     <SPEC/>
        SBW     <STORE>
        SBW     <VALID>
        SBW     <ANY>
        SBW     <RQ>
        SBW     <EBUS> 
        SBW     <INSTR>


;SEQ249

        SBW     <CLR>
        SBW     <CCA>
        SBW     <ODD>
        SBW     <VAL>
        SBW     <FAIL>
        SBW     <USER>
        SBW     <WRITEBACK>
        SBW     <USE>
        SBW     <A>
        SBW     <TO>
        SBW     <MATCH>
        SBW     <ERROR>
        SBW     <FORCE>
        SBW     <BLOCK>
        SBW     <DIR>
        SBW     <NICOND>
        SBW     <TRAP>


;SEQ250

        SBW     <ACT>
        SBW     <NXM>
        SBW     <DIAG>
        SBW     <AR>
        SBW     <PRIVATE>
        SBW     <BIT>
        SBW     <CYCLE>
        SBW     <START>
        SBW     <CHECK>
        SBW     <T2>
        SBW     <READY>
        SBW     <STATE>
        SBW     <COND/>
        SBW     <WRITE>
        SBW     <RAM>
        SBW     <PUBLIC>
        SBW     <AD>


;SEQ251

        SBW     <RD>
        SBW     <EXTENDED>
        SBW     <BUSY>
        SBW     <TEST>
        SBW     <COMP>
        SBW     <INTERVAL>
        SBW     <COND>
        SBW     <E>
        SBW     <PULSE>
        SBW     <ENA>
        SBW     <CTL>
        SBW     <CTR>
        SBW     <UCODE>
        SBW     <RESET>
        SBW     <INH>
        SBW     <REG>
        SBW     <0>


;SEQ252

        SBW     <CURRENT>
        SBW     <SECTION>
        SBW     <36>
        SBW     <REVERSE>
        SBW     <FM>
        SBW     <FLAG>
        SBW     <18>
        SBW     <WORD>
        SBW     <COMING>
        SBW     <DISP>
        SBW     <READ>
        SBW     <CH>
        SBW     <CHX>
        SBW     <ARR>
        SBW     <ARX>
        SBW     <CCWF>
SBW     <DRAM>


;SEQ253

        SBW     <AC+#>
        SBW     <SOURCE>
        SBW     <CHANGE>
        SBW     <CODE>
        SBW     <3>
        SBW     <SWEEP>
        SBW     <FETCH>
        SBW     <SHORT>
        SBW     <DIS>
        SBW     <APR>
        SBW     <BUF>
        SBW     <CCL>
        SBW     <OUT>
        SBW     <ADX>
        SBW     <REF>
        SBW     <WD>
        SBW     <1777>
        SBW     <ACCT>


;SEQ254

        SBW     <INTR>
        SBW     <LONG>
        SBW     <VMAX>
        SBW     <T1>
        SBW     <T3>
        SBW     <T4>


;SEQ255

;SIGNAL NAME STORAGE
SIGLKT:
;       SCD2    M8524   SCD2    .GE.    36 H
SIG     70      20      <<93.>%.GE. %<217.>>



;;      131     07      SCD2    M8524   SCD2 00 H
;;      131     08      SCD2    M8524   SCD2 01 H
;;      131     09      SCD2    M8524   SCD2 02 H
;;      131     10      SCD2    M8524   SCD2 03 H
;;      131     11      SCD2    M8524   SCD2 04 H
;;      130     07      SCD2    M8524   SCD2 05 H
;;      130     08      SCD2    M8524   SCD2 06 H
;;      130     09      SCD2    M8524   SCD2 07 H
;;      130     10      SCD2    M8524   SCD2 08 H
;;      130     11      SCD2    M8524   SCD2    09 H
;       15X     13-35   VMA2    M8542   VMA2    13-35 H **NOTE
;       CLK4    M8526YA CLK4    1777    EN H
SIG     8       1       <<53.><248.><133.>>


;       MCL5    M8544   MCL5    18      BIT     EA      H
SIG     19      40      <<34.><221.><186.>%EA%>


;       MCL5    M8544   MCL5    23 BIT EA H
SIG     16      40      <<34.>%23 %<186.>%EA%>


;       132     14      IRD1    M8522   IRD1    AC 09 H
;;      132     15      IRD1    M8522   IRD1    AC 10 H
        
;;      132     16      IRD1    M8522   IRD1 AC 11 H
;;      132     17      IRD1    M8522   IRD1    AC 12 H
;       APR4    M8545   APR4 AC+# 09 H
SIG     27      40      <<92.><232.>%09%>

;       APR4    M8545   APR4 AC+# 10 H
SIG     27      20      <<92.><232.>%10%>

;       APR4    M8545   APR4 AC+# 11 H
SIG     27      10      <<92.><232.>%11%>

;       APR4    M8545   APR4 AC+# 12 H


;SEQ256

SIG     27      4       <<92.><232.>%12%>
;       MTR2    M8538   MTR2    ACCT ON H
SIG     42      20      <<14.><249.>%ON%>

;       CCW3    M8534   CCW3    ACT CTR 0 EN H
        
SIG     125     100     <<96.><181.><209.><214.><133.>>

;       CRC2    M8535   CRC2 ACT CTR 0R H
SIG     129     4       <<91.><181.><209.>%0R%>

;       CCW3    M8534   CCW3    ACT CTR 1 EN H
SIG     125     40      <<96.><181.><209.><155.><133.>>

;       CRC2    M8535   CRC2 ACT CTR 1R H
SIG     129     2       <<91.><181.><209.>%1R%>

;       CCW3    M8534   CCW3    ACT CTR 2 EN H
SIG     125     20      <<96.><181.><209.><156.><133.>>
;       CRC2    M8535   CRC2 ACT CTR 2R H
SIG     129     1       <<91.><181.><209.>%2R%>
;       CRC1    M8535   CRC1    ACT FLAG ENA H
SIG     132     4               <<89.><181.><220.><207.>>

;       CCW5    M8534   ACT FLAG REQ ENA H
SIG     119     10      <<6.><181.><220.><136.><207.>>
;       CCL2    M8536   CCL2 ACT FLAG REQ H
SIG     133     2       <<74.><181.><220.><136.>>

;       PIC1    M8532   PIC1 ACTIVE H


;SEQ257

SIG     2       2       <<43.>%ACTIVE%>
;       127     0-35    EDP3    M8512   EDP3 AD 0 TO 35 H
;       IRD4    M8522   IRD4 AD CRY -02 A H
SIG     69      4       <<73.><197.><149.>%-02 %<172.>>

;       IRD4    M8522   IRD4 AD CRY 12 H
SIG     73      200     <<73.><197.><149.>%12%>
;       IRD4    M8522   IRD4 AD CRY 18 H
SIG     73      100     <<73.><197.><149.><221.>>

;       IRD4    M8522   IRD4    AD CRY 24 H
SIG     73      40      <<73.><197.><149.>%24%>

;       IRD4    M8522   IRD4 AD CRY 36 H
SIG     73      20      <<73.><197.><149.><217.>>

;       CTL1    M8543   CTL1 AD LONG H
SIG     19      10      <<42.><197.><251.>>

;;      145     01      CRA1    M8541   CRA1    ADR     00      F       H
;;      145     02      CRA1    M8541   CRA1    ADR 01 F H
;;      145     03      CRA1    M8541   CRA1    ADR 03 F H
;;      145     05      CRA1    M8541   CRA1    ADR 04 F H
;;      144     00      CRA1    M8541   CRA1 ADR 05 F H
;;      144     01      CRA1    M8541   CRA1    ADR 06 F H
;;      144     02      CRA2    M8541   CRA2    ADR 07 F H
;;      14      03      CRA2    M8541   CRA2    ADR 08 F H
;;      144     04      CRA2    M8541   CRA2    ADR 09 F H
;;      144     05      CRA2    M8541   CRA2    ADR 10 F H
;       SCD5    M8524   SCD5 ADR BREAK PREVENT H
SIG     74      40      <<5.><134.>%BREAK PREVENT%>


;SEQ258

;       15X     13-35   VMA3    M8542   VMA3 ADR BRK 13-35 H **NOTE
;       SCD5    M8524   SCD5 ADR BRK CYC H
SIG     74      100     <<5.><134.>%BRK %<150.>>

;       SCD5    M8524   SCD5 ADR BRK INH H
SIG     75      2       <<5.><134.>%BRK %<212.>>

;       CSH3    M8513YA CSH 3 ADR PMA EN H
SIG     111     1       <<61.><134.>%PMA %<133.>>
;       126     0-35    EDP3    M8512   EDP3 ADX 0 TO 35 H
;       IRD4    M8522   IRD4 ADX CRY 12 H
SIG     73      10      <<73.><245.><149.>%12%>
;       IRD4    M8522   IRD4 ADX CRY 24 H
SIG     73      4       <<73.><245.><149.>%24%>
;       CTL1    M8543   CTL1 ADX CRY 36 A H
SIG     19      4       <<42.><245.><149.><217.><172.>>
;       CTL1    M8543   CTL1 ADX CRY 36 H
SIG     16      4       <<42.><245.><149.><217.>>
;       CCW3    M8534   CCW3 ALU C2 OUT H
SIG     119     2       <<96.>%ALU C2 %<244.>>
;       CCW3    M8534   CCW3 ALU C8 OUT H
SIG     119     4       <<96.>%ALU C8 %<244.>>
;       APR2    M8545   APR2 ANY EBOX ERR FLG H


;SEQ259
SIG     38      1       <<84.><160.><131.><137.>%FLG%>
;       CSH3    M8513YA CSH3 ANY VAL HOLD H
SIG     103     2       <<61.><160.><167.><144.>>
;       APR2    M8545   APR2 APR INTERRUPT H
SIG     24      40      <<84.><241.>%INTERRUPT%>
;;      120     00      EDP1    M8512   EDP AR 00 H
;       CTL2    M8543   CTL2 AR 00-11 CLR H
SIG     12      200     <<46.><184.>%00-11 %<164.>>
;;      120     01      EDP1    M8512   EDP1 AR 01 H
;;      120     02      EDP1    M8512   EDP1 AR 02 H
;;      120     03      EDP1    M8512   EDP1    AR 03 H
;;      120     04      EDP1    M8512   EDP1    AR 05 H
;;      120     05      EDP1    M8512   EDP1 AR 05 H
;;      120     06      EDP1    M8512   EDP1 AR 06 H
;;      120     07      EDP1    M8512   EDP1    AR 07 H
;;      120     08      EDP1    M8512   EDP1 AR 08 H
;;      120     09      EDP1    M8512   EDP1 AR 09 H
;;      120     10      EDP1    M8512   EDP1 AR 10 H
;;      120     11      EDP1    M8512   EDP1 AR 11 H
;       120     12-35   EDP1    M8512   EDP1 AR 12 TO 35 H
;       CTL2    M8543   CTL2 AR 12-17 CLR H
SIG     15      200     <<46.><184.>%12-17 %<164.>>
;       CON4    M8525   CON4 AR 36 H
SIG     69      2       <<13.><184.><217.>>
;       SHM1    M8540   SHM1 AR EXTENDED H
SIG     27      200     <<51.><184.><199.>>
;       CON4    M8525   CON4 AR LOADED H
SIG     52      20      <<13.><184.>%LOADED%>


;SEQ260

;       SHD1    M8537   SHD1 AR PAR ODD A H
SIG     87      4       <<41.><184.><130.><166.><172.>>
;       SHD1    M8526YA SHD1 AR PAR ODD H
SIG     15      20      <<41.><184.><130.><166.>>
;       CTL2    M8543   CTL2 ARL SEL 1 H
SIG     4       2       <<46.>%ARL %<128.><155.>>
;       CTL2    M8543   CTL2 ARL SEL 2 H
SIG     1       2       <<46.>%ARL %<128.><156.>>
;       CTL2    M8543   CTL2 ARL SEL 4 H
SIG     8       200     <<46.>%ARL %<128.>%4%>
;       CTL2    M8543   CTL2 ARR CLR H
SIG     18      200     <<46.><228.><164.>>
;       CTL2    M8543   CRTL2 ARR SEL 1 H
SIG     9       2       <<46.><228.><128.><155.>>
;       CTL2    M8543   CTL2 ARR SEL 2 H
SIG     6       2       <<46.><228.><128.><156.>>
;       125     0-35    EDP2    M8512   EDP2 ARX 0 TO 35 H
;       CON4    M8525   CON4 ARX 36 H
SIG     73      2       <<13.><229.><217.>>
;       CTL2    M8543   CTL2 ARX LOAD H
SIG     5       200     <<46.><229.><141.>>


;SEQ261

;       SHD1    M8526YA SHD1 ARX PAR ODD H
SIG     18      20      <<41.><229.><130.><166.>>
;       CTL2    M8543   CTL2    ARXL    SEL 2 H
SIG     13      2       <<46.>%ARXL %<128.><156.>>
;       CTL2    M8543   CTL2 ARXR SEL 1 H
SIG     22      2       <<46.>%ARXR %<128.><155.>>
;       CTL2    M8543   CTL2 ARXR SEL 2 H
SIG     19      2       <<46.>%ARXR %<128.><156.>>
;       121     0-35    EDP4    M8512   EDP4    BR 0 TO 35 H
;       124     0-35    EDP4    M8512   EDP4    BR X 0 TO 35 H
;       CCL2    M8536   CCL2 BUF ADR 3 H
SIG     136     2       <<74.><242.><134.><236.>>

;       101     35      CLK5    M8526YA CLK5 BURST 01 H
;;      101     34      CLK5    M8526YA CLK5 BURST 02 H
;;      101     33      CLK5    M8526YA CLK5 BURST 04 H
;;      101     32      CLK5    M8526YA CLK5 BURST 08 H
;;      100     34      CLK5    M8526YA CLK5 BURST 128 H
;;      101     31      CLK5    M8526YA CLK5 BURST 16 H
;;      101     30      CLK5    M8526YA CLK5 BURST 32 H
;;      100     35      CLK5    M8526YA CLK5 BURST 64 H
;       CLK5    M8526YA CLK5 BURST CNT=0 H
SIG     0       4       <<57.>%BURST CNT=0%>
;       APR2    M8545   APR2    C DIR P ERR EN IN H
SIG     30      2       <<84.>%C %<178.>%P %<137.><133.><132.>>
;       APR2    M8545   APR2 C DIR P ERR IN H
SIG     25      2       <<84.>%C %<178.>%P %<137.><132.>>


;SEQ262

;       MBX1    M8529YA MBX1 CACHE BIT H
SIG     102     40      <<29.><138.><186.>>

;       113     20-35   MTR1    M8538   MTR1    CCHE COUNT 02-17 H
;       CON3    M8525   CON3    CACHE LOAD EN H
SIG     49      1       <<12.><138.><141.><133.>>
;       CON3    M8525   CON3 CACHE LOOK EN H
SIG     49      2       <<12.><138.>%LOOK %<133.>>
;       MBX2    M8529YA MBX2 CACHE TO MB 34 H
SIG     104     40      <<32.><138.><173.><151.>%34%>
;       MBX2    M8529YA MBX2 CACHE TO MB 35 H
SIG     106     40      <<32.><138.><173.><151.>%35%>
;       MBX4    M8529YA MBX4 CACHE TO MB DONE H
SIG     108     40      <<36.><138.><173.><151.><154.>>
;       MBC2    M8531YA MBC2 CACHE WR 00 A H
SIG     92      1       <<63.><138.><139.>%00 %<172.>>
;       MBC2    M8531YA MBC2 CACHE WR 09 A H
SIG     91      200     <<63.><138.><139.>%09 %<172.>>
;       MBC2    M8531YA MBC2 CACHE WR 18 A H
SIG     91      100     <<63.><138.><139.><221.><172.>>
;       MBC2    M8531YA MBC2 CACHE WR 27 A H
SIG     91      40      <<63.><138.><139.>%27 %<172.>>



;SEQ265

;       CSH6    M8513YA CSH6 CACHE WR IN H
SIG     103     20      <<66.><138.><139.><132.>>
;;      141     00      CRA4    M8541   CRA4 CALL, RESET H
;       MBC1    M8531YA MBC1 CAM SEL 1 H
SIG     99      1       <<60.>%CAM %<128.><155.>>
;       MBC1    M8531YA MBC1 CAM SEL 2 H
SIG     98      200     <<60.>%CAM %<128.><156.>>
;       CHC1    M8533   CHC1 CBUS ERROR E H
SIG     137     1       <<17.><146.><175.><205.>>
;       CHC1    M8533   CHC1 CBUS LAST WORD E H
SIG     134     1       <<17.><146.>%LAST %<222.><205.>>
;       MBZ5    M8537   MBZ5 CBUS PAR LEFT TE H
SIG     90      10      <<55.><146.><130.>%LEFT TE%>
;       MBZ5    M8537   MBZ5 CBUS PAR RIGHT TE H
SIG     93      10      <<55.><146.><130.>%RIGHT TE%>
;       CHC1    M8533   CHC1 CBUS READY E H
SIG     131     1       <<17.><146.><191.><205.>>
;       CHC1    M8533   CHC1 CBUS REQ H
SIG     140     1       <<17.><146.><136.>>
;       CHC5    M8533   CHC5 CBUS SEL 0 E H
SIG     118     200     <<28.><146.><128.><214.><205.>>

;SEQ264

;       CHC5    M8533   CHC5 CBUS SEL 1 E H
SIG     121     200     <<28.><146.><128.><155.><205.>>
;       CHC5    M8533   CHC5 CBUS SEL 2 E H
SIG     124     200     <<28.><146.><128.><156.><205.>>
;       CHC5    M8533   CHC5 CBUS SEL 3 E H
SIG     127     200     <<28.><146.><128.><236.><205.>>
;       CHC5    M8533   CHC5 CBUS SEL 4 E H
SIG     130     200     <<28.><146.><128.>%4 %<205.>>
;       CHC5    M8533   CHC5 CBUS SEL 5 E H

SIG     133     200     <<28.><146.><128.>%5 %<205.>>
;       CHC5    M8533   CHC5 CBUS SEL 6 E H
SIG     136     200     <<28.><146.><128.>%6 %<205.>>
;       CHC5    M8533   CHC5    CBUS    SEL 7 E H
SIG     139     200     <<28.><146.><128.>%7 %<205.>>
;       MBX1    M8529YA MBX1 CCA ALL PAGES CYC H
SIG     116     40      <<29.><165.>%ALL PAGES %<150.>>
;       MBX1    M8529YA MBX1 CCA SEL 1 H
SIG     104     20      <<29.><165.><128.><155.>>
;       MBX1    M8529YA MBX1 CCA SEL 2 H
SIG     106     20      <<29.><165.><128.><156.>>


;SEQ265

;       CCW4    M8534   CCW4 CCL CCW REG LOAD H
SIG     137     40      <<3.><243.>%CCW %<213.><141.>>
;       CCW3    M8534   CCW3    CCL WC=1 H
SIG     140     10      <<96.><243.>%WC=1%>
;       CCW3    M8534   CCW3 CCL WC=2 H
SIG     140     4       <<96.><243.>%WC=2%>
;       CCW3    M89534  CCW3    CCL WC=3 H
SIG     137     100     <<96.><243.>%WC=3%>
;       CCW6    M8534   CCW6 CCWF REQ ENA H
SIG     119     40      <<8.><230.><136.><207.>>
;       CCL2    M8536   CCL2 CCWF REQ H
SIG     133     10      <<74.><230.><136.>>
;       CCL3    M8534   CCW6 CCWF WAITING H
SIG     124     10      <<75.><230.><190.>>
;       CCW6    M8534   CCW6    CCWF WAITING H
SIG     122     2       <<8.><230.>%WAITING%>
;;      170     00      CRC6    M8535   CRC6 CH BUF ADR 0 H
;;      171     00      CRC6    M8535   CRC6 CH BUF ADR 2 H
;;      172     00      CRC6    M8535   CRC6 CH BUF ADR 2 H
;;      173     00      CRC6    M8535   CRC6 CH BUF ADR 3H
;;      174     00      CRC6    M8535   CRC6 CH BUF ADR 4 H
;;      175     00      CRC6    M8535   CRC6    CH BUF ADR 5 H
;;      176     00      CRC6    M8535   CRC6 CH BUF ADR 6 H
;       CCL4    M8536   CCL4    CH MB SEL 1 H


;SEQ266

SIG     127     2       <<77.><226.><151.><128.><155.>>

;       CCL4    M8536   CCL4    CH MB SEL 2 H
SIG     127     10      <<77.><226.><151.><128.><156.>>
;       176     07-10   CCW2    M8534   CCW2 CHA 14-17 H
;       175     05-10   CCW2    M8534   CCW2 CHA 18-23 H
;       174     05-10   CCW2    M8534   CCW2 CHA 24-29 H
;;      173     05      CCW2    M8534   CCW2 CHA 30 H
;;      173     06      CCW2    M8534   CCW2    CHA 31 H
;;      173     07      CCW2    M8534   CCW2 CHA 32 H
;;      173     08      CCW2    M8534   CCW2 CHA 33 H
;;      173     09      CCW2    M8534   CCW2 CHA 34 H
;;      173     10      CCW2    M8534   CCW2 CHA 35 H
;       MBZ1    M8537   MBZ1 CHAN CORE BUSY H
SIG     86      40      <<40.><145.><152.><200.>>
;       CCL3    M8536   CCL3 CHAN EPT H

SIG     130     2       <<75.><145.>%EPT%>
;       CCL3    M8536   CCL3    CHAN REQ H
SIG     130     10      <<75.><145.><136.>>
;       CCL4    M8536   CCL4 CHAN TO MEM H
SIG     130     1       <<77.><145.><173.><135.>>
;       CHC1    M8533   CHC1    CHX CTOM H
SIG     130     100     <<17.><227.>%CTOM%>
;       CHC1    M8533   CHC1    CHX     DONE H
SIG     124     100     <<17.><227.><154.>>
;       CHC1    M8533   CHC1 CHX RESET H
SIG     118     100     <<17.><227.><211.>>

;SEQ267

;       CHC1    M8533   CHC1 CHX START H
SIG     121     100     <<17.><227.><188.>>
;       CHC1    M8533   CHC1 CHX STORE H
SIG     127     100     <<17.><227.><158.>>
;       CON2    M8524   CON2 CLR PRIVATE INSTR H
SIG     58      100     <<11.><164.><185.><163.>>
;       CON2    M8525   CON2 COND ADR 10 H
SIG     72      40      <<11.><204.><134.>%10%>
;       CON2    M8525   CON2 COND INSTR ABORT H
SIG     56      40      <<11.><204.><163.>%ABORT%>
;       CTL1    M8543   CTL1 COND/AR GET EXP H
SIG     6       4       <<42.><193.><184.>%GETS EXP%>
;       CON1    M8525   CON1 COND/LOAD VMA HELD H
SIG     61      1       <<10.><193.><141.><143.>%HELD%>
;       CON1    M8525   CON1    XCOND/VMA GETS # H
SIG     57      1       <<10.><193.><143.>%GETS #%>
;       CHC2    M8533   CHC2    CONTR CYC H
SIG     139     100     <<18.>%CONTR %<150.>>
;       CHC2    M8533   CHC2 CONTR REQ H
SIG     133     40      <<18.>%CONTR %<136.>>

;SEQ268

;       MBC4    M8531YA MBC4 CORE ADR 34 H
SIG     96      10      <<67.><152.><134.>%34%>
;       MBC4    M8531YA MBC4 CORE ADR 35 H
SIG     96      4       <<67.><152.><134.>%35%>
;       MBC5    M8531YA MBC5 CORE BYUSY B H
SIG     94      200     <<68.><152.><200.>%B%>
;       MBZ1    M8537   MBZ1    CORE BYSY H
SIG     87      20      <<40.><152.><200.>>
;       MBC4    M8531YA MBC4 CORE RD IN PROG A H
SIG     98      10      <<67.><152.><198.><132.>%PROG %<172.>>
        
;       147     08-11   CRM5    M8548   CRM5 CRAM 00-03 H
;       147     14-17   CRM5    M8548   CRM5 CRAM 04-07 H
;       147     20-23   CRM5    M8548   CRM5 CRAM 08-11 H
;       147     26-29   CRM5    M8548   CRM5    CRAM 12-15 H
;       147     32-35   CRM5    M8548   CRM5 CRAM 16-19 H
;       146     08-11   CRM5    M8548   CRM5 CRAM 20-23 H
;       146     14-17   CRM5    M8548   CRM5    CRAM 24-27 H
;       146     20-23   CRM5    M8548   CRM5    CRAM 28-31 H


;       146     26-29   CRM5    M8548   CRM5 CRAM 32-35 H
;       146     32-35   CRM5    M8548   CRM5 CRAM 36-39 H
;       145     08-11   CRM5    M8548   CRM5 CRAM 40-43 H
;       145     14-17   CRM5    M8548   CRM5CRAM 44-47 H
;       145     20-23   CRM5    M8548   CRM5 CRAM 48-51 H
;       145     26-29   CRM5    M8548   CRM5 CRAM 52-55 H
;       145     32-35   CRM5    M8548   CRM5 CRAM 56-59 H
;;      144     08      CRM5    M8548   CRM5 CRAM 60 H
;;      144     10      CRM5    M8548   CRM5 CRAM 62 H
;;      144     14      CRM5    M8548   CRM5 CRAM 64 H
;;      144     16      CRM5    M8548   CRM5 CRAM 66 H
;;      144     20      CRM5    M8548   CRM5 CRAM 68 H
;;      144     22      CRM5    M8548   CRM5 CRAM 70 H
;;      144     26      CRM5    M8548   CRM5 CRAM 72 H
;;      144     28      CRM5    M8548   CRM5 CRAM 74 H
;;      144     32      CRM5    M8548   CRM5 CRAM 76 H
;;      144     34      CRM5    M8548   CRM5    CRAM 78 H
;;      144     11      CRM5    M8548   CRM5 CRAM PAR 00 H
;;      144     17      CRM5    M8548   CRM5 CRAM PAR 04 H


;SEQ269

;;      144     23      CRM5    M8548   CRM5 CRAM 08 H
;;      144     29      CRM5    M8548   CRM5 CRAM PAR 12 H
;;      144     35      CRM5    M8548   CRM5 CRAM PAR 16 H
;;      144     09      CRM5    M8548   CRM5 CRAM PAR 1ST 00 H
;;      144     15      CRM5    M8548   CRM5 CRAM PAR 1ST 04 H
;;      144     21      CRM5    M8548   CRM5 CRAM PAR 1ST 08 H
;;      144     27      CRM5    M8548   CRM5 CRAM PAR 1ST 12 H
;;      144     33      CRM5    M8548   CRM5 CRAM PAR 1ST 16 H
;       CLK3    M8526YA CLK3 CRAM PAR ERR H
SIG     12      40      <<49.>%CRAM %<130.><137.>>
;       SCD4    M8524   SCD4 CRY0 H
SIG     51      1       <<2.>%CRY0%>
;       SCD4    M8524   SCD4 CRY1 H
SIG     50      200     <<2.>%CRY1%>
;;      102     14      PIC4    M8532   EBUS    CS00 E H
;;      102     15      PIC4    M8532   EBUS CS01 E H
;;      102     16      PIC4    M8532   EBUS CS02 E H
;;      102     17      PIC4    M8532   EBUS CS03 E H
;;      103     14      PIC4    M8532   EBUS CS04 E H
;;      102     11      PIC4    M8532   EBUS CS05 E H
;;      102     12      PIC4    M8532   EBUS CS06 E H
;       MBC2    M8531YA MBC2 CSH ADR WR PULSE H
SIG     85      10      <<63.><129.><134.><139.><206.>>
;       MBX1    M8529YA CSH CCA INVAL CS H
SIG     110     20      <<29.><129.><165.>%INVAL %<129.>>
;       MBX1    M8529YA CSH CCA VAL CORE H
SIG     112     20      <<29.><129.><165.><167.><152.>>
;       CHX4    M8515   CHX4 CSH DIR 0 PAR ODD H
SIG     111     200     <<90.><129.><178.><214.><130.><166.>>
;       CHX4    M8515   CHX4 CSH DIR 1 PAR 0DD H
SIG     113     200     <<90.><129.><178.><155.><130.><166.>>

;SEQ270

;       CHX4    M8515   CHX4 CSH DIR 2 PAR ODD H
SIG     115     200     <<90.><129.><178.><156.><130.><166.>>
;       CHX4    M8515   CHX4 CSH DIR 3 PAR ODD H
SIG     117     200     <<90.><129.><178.><236.><130.><166.>>
;       CHX3    M8513YA CHX3 CSH LRU 1 H
SIG     109     4       <<87.><129.>%LRU %<155.>>
;       CHX3    M8513YA CHX3 CSH LRU 2 H
SIG     107     4       <<87.><129.>%LRU %<156.>>
;       MBZ6    M8537   MBZ6 CSH PAR BIT A H
SIG     89      2       <<59.><129.><130.><186.><172.>>
;       MBZ6    M8537   MBZ6 CSH PAR BIT B H
SIG     92      2       <<59.><129.><130.><186.>%B%>
;       MBZ6    M8537   MBZ6 CSH PAR BIT H
SIG     90      2       <<59.><129.><130.><186.>>
;       MBZ5    M8537   MBZ5 CSH PAR BIT IN H
SIG     93      4       <<55.><129.><130.><186.><132.>>
;       MBC2    M8531YA MBC2 CSH SEL LRU H
SIG     88      40      <<63.><129.><128.>%LRU%>


;SEQ271

;       CHX3    M8515   CHX3 CSH USE ADR 2 H
SIG     113     100     <<87.><129.><171.><134.><156.>>
;       CHX3    M8515   CHX3 CSH USE ADR 3 H
SIG     115     100     <<87.><129.><171.><134.><236.>>
;       CHX3    M8515   CHX3 CSH USE ADR 4 H
SIG     117     100     <<87.><129.><171.><134.>%4%>
;       CHX3    M8515   CHX3 CSH USE IN 0 H
SIG     103     100     <<87.><129.><171.><132.><214.>>
;       CHX3    M8515   CHX3 CSH USE IN 1 H
SIG     105     100     <<87.><129.><171.><132.><155.>>
;       CHX3    M8515   CHX3 CSH USE IN 2 H
SIG     107     100     <<87.><129.><171.><132.><156.>>
;       CHX3    M8515   CHX3    CSH USE IN 3 H
SIG     109     100     <<87.><129.><171.><132.><236.>>
;       CHX3    M8515   CHX3 CSH USE IN 4 H
SIG     111     100     <<87.><129.><171.><132.>%4%>
;       MBC3    M8531YA MBC3    CSH VAL SEL ALL H
SIG     94      100     <<65.><129.><167.><128.>%ALL%>
;       MBC3    M8513YA MBC3    CSH VAL WR DATA H
SIG     94      40      <<65.><129.><167.><139.><140.>>


;SEQ272

;       MBC2    M8531YA MBC2 CSH VAL WR PULSE H
SIG     88      20      <<63.><129.><167.><139.><206.>>
;       MBC3    M8531YA MBC3 CSH WR SEL ALL H
SIG     94      20      <<65.><129.><139.><128.>%ALL%>
;       MBX4    M8529YA MBX4 CSH WR WD 0 EN H
SIG     114     20      <<36.><129.><139.><247.><214.><133.>>
;       MBX4    M8529YA MBX4 CSH WR WD 1 EN H
SIG     116     20      <<36.><129.><139.><247.><155.><133.>>
;       MBX4    M8529YA MBX4 CSH WR WD 2 EN H
SIG     102     10      <<36.><129.><139.><247.><156.><133.>>
;       MBX4    M8529YA MBX4 CSH WR WD 3 EN H
SIG     104     10      <<36.><129.><139.><247.><236.><133.>>
;       MBC3    M8513YA MBC3 CSH WR WR DATA H
SIG     94      10      <<65.><129.><139.><139.><140.>>
;       MBC2    M8531YA MBC2 CSH WR WR PULSE H
SIG     88      10      <<63.><129.><139.><139.><206.>>
;       CHC3    M8533   CHC3 CTOM H
SIG     130     40      <<22.>%CTOM%>




;SEQ273

;       APR5    M8545   APR5 CURRENT BLOCK 1 H
SIG     28      10      <<95.><215.><177.><155.>>
;       APR5    M8545   APR5 CURRENT BLOCK 2 H
SIG     28      20      <<95.><215.><177.><156.>>
;       APR5    M8545   APR5 CURRENT BLOCK 4 H
SIG     28      40      <<95.><215.><177.>%4%>
;       CSH1    M8513YA CSH1 CYC TYPE HOLD H
SIG     117     1       <<56.><150.>%TYPE %<144.>>
;       MBX3    M8529YA MBX3 DATA CODE 1 H
SIG     110     10      <<33.><140.><235.><155.>>
;       MBX3    M8529YA MBX3 DATA CODE 2 H
SIG     112     10      <<33.><140.><235.><156.>>
;       MBC3    M8531YA MBC3 DATA VALID A OUT H
SIG     94      4       <<65.><140.><159.><172.><244.>>
;       MBC3    M8531YA MBC3 DATA VALID B OUT H
SIG     97      1       <<65.><140.><159.>%B %<244.>>
;       CON3    M8525   CON3 DELAY REQ H
SIG     65      2       <<12.>%DELAY %<136.>>
;       PIC2    M8532   EBUS DEMAND E H
SIG     7       100     <<82.>%DEMAND %<205.>>

;SEQ274

;       CTL3    M8543   CTL3 DIAG MEM RESET H
SIG     22      4       <<48.><183.><135.><211.>>


;;      141     01      CRA3    M8541   CRA3 DISP 00 H
;;      141     02      CRA3    M8541   CRA3 DISP 01 H
;;      141     03      CRA3    M8541   CRA3 DISP 02 H
;;      141     04      CRA3    M8541   CRA3 DISP 03 H
;;      141     05      CRA3    M8541   CRA3 DISP 04 H
;;      145     00      CRA3    M8541   CRA3 DISP PARITY H
;       SCD4    M8524   SCD4 DIV CHK H
SIG     50      40      <<2.>%DIV CHK%>
;       CRC4    M8535   CRC4 DONE IN H
SIG     120     1               <<1.><154.><132.>>
;       CHC2    M8533   CHC2 DONE INTR H
SIG     124     40      <<18.><154.><250.>>
;;      130     15      IRD1    M8522   IRD1    DR ADR 00 A H
;       130     16      IRD1    M8522   IRD1 DR ADR 01 A H
;;      130     17      IRD1    M8522   IRD1 DR ADR 02 A H
;;      131     13      IRD1    M8522   IRD1    DR ADR 03 AH
;;      131     13      IRD1    M8522   IRD1 DR ADR 04 A H
;;      131     14      IRD1    M8522   IRD1 ADR 05 A H
;;      131     15      IRD11   M8522   IRD1 DR ADR 06 A H
;;      131     16      IRD1    M8522   IRD1 DR ADR 07 A H
;;      131     17      IRD1    M8522   IRD1 DR ADR 08 A H
;;      133     12      IRD1    M8522   IRD1 DRAM A 00 H
;;      133     13      IRD1    M8522   IRD1    DRAM A 01 H
;;      133     14      IRD1    M8522   IRD1 DRAM A 02 H
;;      133     15      IRD1    M8522   IRD1 DRAM B 00 H
;;      133     16      IRD1    M8522   IRD1 DRAM B 01 H
;;      133     17      IRD1    M8522   IRD1 DRAM B 02 H
;;      134     14      IRD1    M8522   IRD1 DRAM J 01 H
;;      134     15      IRD1    M8522   IRD1 DRAM J 02 H
;;      134     16      IRD1    M8522   IRD1 DRAM J 03 H
;;      134     17      IRD1    M8522   IRD1 DRAM J 04 H
;;      135     14      IRD1    M8522   IRD1 DRAM J 07 H
;;      135     15      IRD1    M8522   IRD1    DRAM J 08 H
        ;;      135     16      IRD1    M8522   IRD1 DRAM J 09 H
;;      135     17      IRD1    M8522   IRD1 DRAM J 10 H
;       IRD3    M8522   IRD3 DRAM ODD PARITY H
SIG     65      100     <<72.><231.><166.>%PARITY%>


;SEQ275

;       CLK3    M8526YA CLK3 DRAM PAR ERR H
SIG     8       40      <<49.><231.><130.><137.>>
;;      135     12      IRD1    M8522   IRD1 DRAM PAR H
;       CSH2    M8513YA CSH2 E CACHE WR CYC H
SIG     115     1       <<58.><205.><138.><139.><150.>>
;       APR6    M8545   APR6 EBOX CCA H
SIG     35      200     <<0.><131.><165.>>
;       112     20-35   MTR1    M8538   MTR1 EBOX COUNT 02-17 H
;       CLK5    M8526YA CLK5 EBOX CRM DIS H
SIG     15      4       <<57.><131.>%CRM %<240.>>
;       CLK5    M8526YA CLK5 EBOX CTL DIS H
SIG     21      4       <<57.><131.><208.><240.>>
;       APR3    M8545   APR3 EBOX DISABLE CS H
SIG     36      2       <<86.><131.>%DISABLE CS%>
;       APR6    M8545   APR6 EBOX EBR H
SIG     39      200     <<0.><131.>%EBR%>
;       CLK5    M8526YA CLK5 EBOX EDP DIS H
SIG     18      4       <<57.><131.>%EDP %<240.>>
;       APR6    M8545   APR6 EBOX ERA H
SIG     35      100     <<0.><131.>%ERA%>
;       CSH6    M8513YA CSH6 EBOX LOAD REG H
SIG     105     4       <<66.><131.><141.><213.>>

;SEQ276

;       CLK4    M8526YA CLK4 EBOX REG H
SIG     5       10      <<53.><131.><136.>>
;       APR6    M8545   APR6 EBOX SBUS DIAG H
SIG     35      40      <<0.><131.><153.><183.>>


;       APR3    M8545   APR3 EBOX SEND F02 H
SIG     40      2       <<86.><131.>%SEND F02%>
;       CLK3    M8526YA CLK3 EBOX SOURCE H
SIG     12      4       <<49.><131.><233.>>
;       APR6    M8545   APR6 EBOX SPARE H
SIG     39      100     <<0.><131.>%SPARE%>
;       APR6    M8545   APR6 EBOX UBR H
SIG     37      200     <<0.><131.>%UBR%>
;       CLK1    M8526YA CLK1 EBUS CLK H
SIG     0       40      <<39.><162.>%CLK%>
;       APR3    M8545   APR3 EBUS DEMAND H
SIG     40      4       <<86.><162.>%DEMAND%>
;       APR3    M8545   APR3 EBUS F01 E H
SIG     38      2       <<86.><162.>%F01 %<205.>>
;       PIC5    M8532   PIC5 EBUS PI GRANT H
SIG     10      200     <<54.><162.>%PI GRANT%>

;SEQ277

;       CON3    M8525   CON3 EBUS REL H
SIG     56      200     <<12.><162.>%REL%>
;       PIC5    M8532   PIC5    EBUS REQ H
SIG     10      4       <<54.><162.><136.>>
;       APR3    M8545   APR3 EBUS RETURN H
SIG     36      4       <<86.><162.>%RETURN%>
;       IRD3    M8522   IRD3 EN AC H
SIG     53      100     <<72.><133.>%AC%>
;       IRD3    M8522   IRD3    EN I/O, JRST H
SIG     53      200     <<72.><133.>%I/O, JRST%>
;       APR6    M8545   APR6 EN REFILL RAM WR 4
SIG     37      100     <<0.><133.><148.><195.><139.>>
;       CRC3    M8535   CRC3    ERR IN H
SIG     126     1       <<94.><137.><132.>>
;       CCL1    M8536   CCL1 ERR REQ H
SIG     139     10      <<71.><137.><136.>>

;       CLK1    M8526YA CLK1 ERROR STOP H
SIG     5       40      <<39.><175.>%STOP%>
;       MTR2    M8538   MTR2 EXEC ACT EN H
SIG     42      40      <<14.>%EXEC %<249.><133.>>

;SEQ278

;       APR4    M8545   APR4 F02 EN H
SIG     33      20      <<92.>%F02 %<133.>>
;;      133     07      SCD2    M8524   SCD2    FE 00 H
;;      133     08      SCD2    M8524   SCD2 FE 01 H
;;      133     09      SCD2    M8524   SCD2 FE 02 H
;;      133     10      SCD2    M8524   SCD2 FE 03 H
;;      133     11      SCD2    M8524   SCD2    FE 04 H
;;      132     07      SCD2    M8524   SCD2 FE 05 H
;;      132     08      SCD2    M8524   SCD2    FE 06 H
;;      132     09      SCD2    M8524   SCD2 FE 07 H
;;      132     10      SCD2    M8524   SCD2 FE 08 H
;;      132     11      SCD2    M8524   SCD2 FE 09 H
;       SCD2    M8524   SCD2 FE SIGN H
SIG     66      20      <<93.>%FE SIGN%>
;       APR3    M8545   APR3 FETCH COMP H
SIG     32      4       <<86.><238.><202.>>
;       123     0-35    EDP4    M8512   EDP4 FM 0 TO 35 H
;       APR3    M8545   APR3 FM 36 H
SIG     33      10      <<86.><219.><217.>>
;;      114     14      APR4    M8545   APR4 FM ADR 1 H
;;      114     11      APR4    M8545   APR4    FM ADR 2 H
;;      114     12      APR4    M8545   APR4 FM ADR 4 H
;;      114     10      APR5    M8545   APR5 FM BLOCK 1 H
;;      114     09      APR5    M8545   APR5 FM BLOCK 2 H
;;      114     08      APR5    M8545   APR5 FM BLOCK 4 H
;       APR3    M8545   APR3 FM EXTENDED H
SIG     27      100     <<86.><219.><199.>>
;       APR3    M8545   APR3    FM ODD PARITY H
SIG     33      4       <<86.><219.><166.>%PARITY%>
;       CLK3    M8526YA CLK3 FM PAR ERR H
SIG     15      40      <<49.><219.><130.><137.>>

;SEQ279

;       CLK4    M8526YA CLK4 FORCE 1777 H
SIG     5       1       <<53.><176.><248.>>
;       MBX1    M8529YA MBX1 FORCE NO MATCH H
SIG     106     10      <<29.><176.>%NO %<174.>>
;       MBC5    M8531YA MBC5 FORCE VALID MATCH 0 H
SIG     86      1       <<68.><176.><159.><174.><214.>>
;       MBC5    M8531YA MBC5 FORCE VALID MATCH 1 H
SIG     85      200     <<68.><176.><159.><174.><155.>>
;       MBC5    M8531YA MBC5 FORCE VALID MATCH 2 H
SIG     85      100     <<68.><176.><159.><174.><156.>>
;       MBC5    M8531YA MBC5 FORCE VALID MATCH 3 H
SIG     85      40      <<68.><176.><159.><174.><236.>>
;       SCD4    M8524   SCD4 FOV H
SIG     55      1       <<2.>%FOV%>
;       SCD4    M8524   SCD4 FPD H
SIG     46      40      <<2.>%FPD%>
;       CLK3    M8526YA CLK3 FS ERROR H
SIG     18      40      <<49.>%FS %<175.>>
;       SCD4    M8524   SCD4    FXU H
SIG     54      200     <<2.>%FXU%>

;SEQ280

;       CSH3    M8513YA CSH3 GATE VMA 27-33 H
SIG     113     1       <<61.>%GATE %<143.>%27-33%>
;;      101     11      PIC1    M8532   PIC1 GEN 1 H
;;      101     12      PIC1    M8532   PIC1 GEN 2 H
;;      101     13      PIC1    M8532   PIC1 GEN 3 H
;;      101     14      PIC1    M8532   PIC1 GEN 4 H
;;      101     15      PIC1    M8532   PIC1    GEN 5 H
;;      101     16      PIC1    M8532   PIC1    GNE 6 H
;;      101     17      PIC1    M8532   PIC1    GEN 7 H
;       IRD4    M8522   IRD4    GEN CRY 36 H
SIG     69      10      <<73.>%GEN %<149.><217.>>
;       15X     13-35   VMA4    M8542   VMA4 HELD 13-35 H **NOTE
;       PIC2    M8532   PIC2 HONOR INTERNAL H
SIG     10      20      <<44.>%HONOR INTERNAL%>
;       IRD1    M8522   IRD1    I/0 LEGAL H
SIG     69      100     <<70.>%I/O LEGAL%>
;       APR1    M8545   APR1    I/O PF ERR EN IN H
SIG     30      10      <<81.>%I/O PF %<137.><133.><132.>>
;       APR1    M8545   APR1 I/O PF ERR IN H
SIG     25      10      <<81.>%I/O PF %<137.><132.>>
;       MBZ1    M8537   MBZ1 IN SEL 1 H
SIG     86      200     <<40.><132.><128.><155.>>
;       MBZ1    M8537   MBZ1 IN SEL 2 H
SIG     89      200     <<40.><132.><128.><156.>>

;SEQ281

;       MBZ1    M8537   MBZ1    IN SEL 4 H
SIG     92      200     <<40.><132.><128.>%4%>
;       MTR5    M8538   MTR5    INCR SEL 1 H
SIG     43      40      <<21.>%INCR %<128.><155.>>
;       MTR5    M8538   MTR5    INCR SEL 2 H
SIG     43      100     <<21.>%INCR %<128.><156.>>
;       MBC3    M8531YA MBC3    INH 1ST MB REQ H
SIG     96      200     <<65.><212.>%1ST %<151.><136.>>
;       CLK4    M8526YA CLK4 INSTR 1777 H
SIG     0       10      <<53.><163.><248.>>
;       114     24-35   MTR1    M8538   MTR1 INTERVAL 06-17 H
;       MTR3    M8538   MTR3 INTERVAL DONE H
SIG     41      40      <<16.><203.><154.>>
;       MTR3    M8538   MTR3    INTERVAL ON H
SIG     41      100     <<16.><203.>%ON%>
;       MTR3    M8538   MTR3 INTERVAL OVRFLO H
SIG     41      20      <<16.><203.>%OVRFLO%>
;       SCD5    M8524   SCD5 KERNEL MODE H
SIG     66      200     <<5.>%KERNEL MODE%>
;       SCD5    M8524   SCD5 KERNEL OR USER IOT H

;SEQ282

SIG     71      2       <<5.>%KERNEL OR %<169.>%IOT%>
;       CRC3    M8535   CRC3 LAST WORD IN H
SIG     126     2       <<94.>%LAST %<222.><132.>>
;       SCD5    M8524   SCD5 LEAVE USER H
SIG     63      1       <<5.>%LEAVE %<169.>>
;       CON2    M8525   CON2 LOAD ACCESS COND H
SIG     60      40      <<11.><141.>%ACCESS %<204.>>
;       MCL2    M8544   MCL2 LOAD AR H
SIG     17      2       <<24.><141.><184.>>
;       MCL2    M8544   MCL2 LOAD ARX H
SIG     20      2       <<24.><141.><229.>>
;       CON2    M8525   CON2 LOAD DRAM H
SIG     68      40      <<11.><141.><231.>>
;       SCD5    M8524   SCD5 LOAD FLAGS A H
SIG     59      1       <<5.><141.>%FLAGS %<172.>>
;;      147     01      CRA3    M8541   CRA3 LOC 00 H
;;      147     02      CRA3    M8541   CRA3    LOC 01 H
;;      147     03      CRA3    M8541   CRA3 LOC 02 H
;;      147     04      CRA3    N8541   CRA3 LOC 03 H
;;      147     05      CRA3    M8541   CRA3    LOC 04 H
;;      146     00      CRA3    M8541   CRA3    LOC 05 H
;;      146     01      CRA3    M8541   CRA3 LOC 06 H
;;      146     02      CRA3    M8541   CRA3 LOC 07 H
;;      146     03      CRA3    M8541   CRA3 LOC 08 H
;;      146     04      CRA3    M8541   CRA3 LOC 09 H
;;      146     05      CRA3    M8541   CRA3 LOC 10 H

;SEQ283

;       CRC4    M8535   CRC4 LONG WC ERR H
SIG     122     200     <<1.><251.>%WC %<137.>>
;       VMA3    M8542   VMA3 MATCH 13-35 H
SIG     84      20      <<27.><174.>%13-35%>
;       PAG5    M8537   PAG5 MB 00-17 PAR H
SIG     92      4       <<26.><151.>%00-17 %<130.>>
;       PAG5    M8537   PAG5 MB 18-35 PAR H
SIG     86      2       <<26.><151.>%18-35 %<130.>>
;       APR1    M8545   APR1 MB PAR ERR EN IN H
SIG     30      4       <<81.><151.><130.><137.><133.><132.>>
;       APR1    M8545   APR1 MB PAR ERR IN H
SIG     25      4       <<81.><151.><130.><137.><132.>>
;       MBX5    M8529YA MBX5 MB REQ IN H
SIG     102     4       <<37.><151.><136.><132.>>
;       CHC1    M8533   CHC1 MB REQ INH H
SIG     136     100     <<17.><151.><136.><212.>>
;       CCL3    M8536   CCL3 MB REQ T2 H
SIG     124     2       <<75.><151.><136.><190.>>
;       CCL3    M8536   CCL3 MB RIP A H
SIG     121     10      <<75.><151.>%RIP %<172.>>

;       CLK4    M8526YA CLK4 MB XFER H
SIG     8       10      <<53.><151.>%XFER%>
;       MBX6    M8529YA MBX6    MB0     HOLD IN H
SIG     110     4       <<38.>%MB0 %<144.><132.>>
;       MBX6    M8529YA MBX6    MB1 HOLD IN H
SIG     112     4       <<38.>%MB1 %<144.><132.>>
;       MBX6    M8529YA MBX6 MB2 HOLD IN H
SIG     114     4       <<38.>%MB2 %<144.><132.>>
;       MBX6    M8529YA MBX6 MB3 HOLD IN H
SIG     116     4       <<38.>%MB3 %<144.><132.>>
;       APR5    M8545   MBOX CTL 03 H
SIG     34      20      <<95.><147.><208.>%03%>
;       APR5    M8545   APR5 MBOX CTL 06 H
SIG     36      20      <<95.><147.><208.>%06%>
;       MCL5    M8544   MCL5 MBOX CYC REQ H
SIG     22      40      <<34.><147.><150.><136.>>
;       CLK5    M8526YA CLK5 MBOX CYCLE DIS H
SIG     12      1       <<57.><147.><187.><240.>>
;       MBC4    M8531YA MBC4 MEM ADR PAR H
SIG     98      4       <<67.><135.><134.><130.>>

;SEQ285

;       CCW1    M8534   CCW1 MEM ADR=0 H
SIG     122     4       <<88.><135.>%ADR=0%>
;       MBZ1    M8537   MBZ1 MEM BUSY H
SIG     92      100     <<40.><135.><200.>>
;       MBX3    M8529YA MBX3 MEM DATA TO MEM H
SIG     108     10      <<33.><135.><140.><173.><135.>>
;       CCL3    M8536   CCL3 MEM PTR EN H
SIG     139     1       <<75.><135.>%PTR %<133.>>
;       CRC1    M8535   CRC1 MEM PTR0 H
SIG     138     4       <<89.><135.>%PTR0%>
;       CRC1    M8535   CRC1    MEM PTR1 H
SIG     138     2       <<89.><135.>%PTR1%>
;       CRC1    M8535   CRC1    MEM PTR 2 H
SIG     138     1       <<89.><135.>%PTR2%>
;       CRC1    M8535   CRC1 MEM PTR3 H
SIG     137     200     <<89.><135.>%PTR3%>
;       MBC4    M8531YA MBC4 MEM RD RQ B H
SIG     101     1       <<67.><135.><198.><161.>%B%>
;       MBX5    M8529YA MBX5 MEM RD RQ IN H
SIG     106     2       <<37.><135.><198.><161.><132.>>


;SEQ286

;       MBC4    M8531YA MBC4 MEM RQ 0 H
SIG     100     200     <<67.><135.><161.><214.>>
;       MBC4    M8531YA MBC4 MEM RQ 1 H
SIG     100     100     <<67.><135.><161.><155.>>
;       MBC4    M8531YA MBC4 MEM RQ 2 H
SIG     100     40      <<67.><135.><161.><156.>>
;       MBC4    M8531YA MBC4 MEM Q 3 H
SIG     100     20      <<67.><135.><161.><236.>>
;       CCW6    M8534   CCW6 MEM STORE ENA H
SIG     119     20      <<8.><135.><158.><207.>>
;       CCL2    M8536   CCL2 MEM STORE REQ H
SIG     133     1       <<74.><135.><158.><136.>>
;       MBX3    M8529YA MBX3 MEM TO C SEL 1 H
SIG     108     2       <<33.><135.><173.>%C %<128.><155.>>
;       MBX3    M8529YA MBX3 MEM TO C SEL 2 H
SIG     110     2       <<33.><135.><173.>%C %<128.><156.>>
;       MBX5    M8529YA MBX5 MEM WR RQ IN H
SIG     112     2       <<37.><135.><139.><161.><132.>>
;       MCL1    M8544   MCL1 MEM/ARL IND H
SIG     7       1       <<20.>%MEM/ARL IND%>


;SEQ287

;       122     0-35    EDP2    M8512   EDP2 MQ 0 TO 35 H
;       CTL2    M8543   CTL2 MQ SEL 1 H
SIG     16      1       <<46.>%MQ %<128.><155.>>
;       CTL2    M8543   CTL2 MQ SEL 2 H
SIG     13      1       <<46.>%MQ %<128.><156.>>
;       CTL2    M8543   CTL2 MQM EN H
SIG     19      1       <<46.>%MQM %<133.>>
;       CTL2    M8543   CTL2 MQM SEL 1 H
SIG     9       1       <<46.>%MQM %<128.><155.>>
;       CTL2    M8543   CTL2    MQM SEL 2 H
SIG     6       1       <<46.>%MQM %<128.><156.>>
;       CON2    M8525   CON2 NICOND 07 H
SIG     64      100     <<11.><179.>%07%>
;       CON2    M8525   CON2 NICOND 08 H
SIG     68      100     <<11.><179.>%08%>
;       CON2    M8525   CON2 NICOND 09 H
SIG     72      100     <<11.><179.>%09%>
;       SCD4    M8524   SCD4 NICOND 10 H
SIG     58      40      <<2.><179.>%10%>
;       CON2    M8525   CON2 NICOND TRAP EN H
SIG     60      100     <<11.><179.><180.><133.>>

;SEQ288

;       IRD3    M8522   IRD3 NORM 08 H
SIG     45      200     <<72.>%NORM 08%>
;       IRD3    M8522   IRD3 NORM 09 H
SIG     45      100     <<72.>%NORM 09%>
;       IRD3    M8522   IRD3 NORM 10 H
SIG     45      40      <<72.>%NORM 10%>
;       MBZ3    M8537   MBZ3    NXM ACKN H
SIG     86      100     <<50.><182.>%ACKN%>
;       APR1    M8545   APR1 NXM ERR EN IN H
SIG     30      20      <<81.><182.><137.><133.><132.>>
;       APR1    M8545   APR1    NXM ERR IN H
SIG     25      20      <<81.><182.><137.><132.>>
;       MBZ4    M8537   MBZ4 NXM T2 H
SIG     92      20      <<52.><182.><190.>>
;       CCW4    M8534   CCW4    ODD ADR PAR H
SIG     140     2       <<3.><166.><134.><130.>>
;       CCL5    M8536   CCL5 ODD WC PAR H
SIG     118     10      <<78.><166.>%WC %<130.>>
;;      100     11      PIC1    M8532   PIC1 ON 1 H
;;      100     12      PIC1    M8532   PIC1 ON 2 H
;;      100     13      PIC1    M8532   PIC1 ON 3 H
;;      100     14      PIC1    M8532   PIC1 ON 4 H
;;      100     15      PIC1    M8532   PIC1 ON 5 H


;SEQ289

;;      100     16      PIC1    M8532   PIC1 ON 6 H
;;      100     17      PIC1    M8532   PIC1 ON 7 H
;       CRC3    M8535   CRC3 OP CODE 00 H
SIG     132     1       <<94.>%OP %<235.>%00%>

;       CRC3    M8535   CRC3 OP CODE 01 H
SIG     131     200     <<94.>%OP %<235.>%01%>
;       SCD4    M8524   SCD4 OV H
SIG     51      2       <<2.>%OV%>
;       CRC4    M8535   CRC4 OVN ERR IN H
SIG     123     2       <<1.>%OVN %<137.><132.>>
;       MCL3    M8544   MCL3 PAGE ADDRESS COND H
SIG     16      200     <<25.><142.>%ADDRESS %<204.>>
;       CALL    M8526YA CLK4 PAGE ERROR H
SIG     8       2       <<53.><142.><175.>>
;       CSH4    M8513YA CSH4 PAGE FAIL DLY H
SIG     117     10      <<62.><142.><168.>%DLY%>
;       CLK4    M8526YA CLK4 PAGE FAIL H
SIG     21      20      <<53.><142.><168.>>
;       MCL3    M8544   MCL3 PAGE ILL ENTRY H
SIG     19      200     <<25.><142.>%ILL ENTRY%>
;       MCL3    M8544   MCL3 PAGE TEST PRIVATE H
SIG     6       200     <<25.><142.><201.><185.>>

;SEQ290

;       MCL6    M8544   MCL6 PAGE UEBR REF H
SIG     13      200     <<35.><142.>%UEBR %<246.>>
;       MBZ5    M8537   MBZ5    PAR BIT IN H
SIG     87      2       <<55.><130.><186.><132.>>
;       MBX3    M8529YA MBX3 PAR H
SIG     114     10      <<33.><130.>>
;       MEM5    M8537   MEM5 PAR IN H
SIG     90      4       <<19.><130.><132.>>
;       15X     13-35   VMA3    M8542   VMA3 PC 13-35 H **NOTE
;       SCD4    M8524   SCD4    PCP H
SIG     59      2       <<2.>%PCP%>
;       111     20-35   MTR1    M8538   MTR1 PERF COUNT 02-17 H
;       115     24-35   MTR3    M8538   MTR3 PERIOD 06-17 H
;       MTR2    M8538   MTR2 PI ACCT EN H
SIG     42      100     <<14.>%PI %<249.><133.>>
;       CON5    M8525   CON5 PI CYCLE H
SIG     52      10      <<15.>%PI %<187.>>
;       PIC3    M8545   PIC3 PI3 APR PIA O1 H
SIG     24      4       <<47.>%PI3 %<241.>%PIA 01%>
;       PIC3    M8545   PIC3 PI3        APR PIA 02 H
SIG     24      10      <<47.>%PI3 %<241.>%PIA 02%>


;SEQ291

;       PIC3    M8545   PIC3 PI3 APR PIA 04 H
SIG     24      20      <<47.>%PI3 %<241.>%PIA 04%>

;;      116     35      PIC3    M8538   PIC3 PI3 MTR PIA 01 H
;;      116     34      PIC3    M8538   PIC3 PI3 MTR PIA 02 H
;;      116     33      PIC3    M8538   PIC3 PI3 MTR PIA 04 H
;;      100     03      PIC1    M8532   PIC1 PIH1 H
;;      100     04      PIC1    M8532 PIC1 PIH2 H
;;      100     05      PIC1    M8532   PIC1 PIH3 H
;;      100     06      PIC1    M8532   PIC1 PIH 4 H
;;      100     07      PIC1    M8532   PIC1 PIH5 H
;;      100     08      PIC1    M8532   PIC1 PIH6 H
;;      100     09      PIC1    M8532   PIC1 PIH7 H
;       APR5    M8545   APR5 PREV BLOCK 1 H
SIG     28      1       <<95.>%PREV %<177.><155.>>
;       APR5    M8545   APR5 PREV BLOCK 2 H
SIG     28      2       <<95.>%PREV %<177.><156.>>
;       APR5    M8545   APR5 PREV BLOCK 4 H
SIG     28      4       <<95.>%PREV %<177.>%4%>
;;      157     11      VMA4    M8542   PREV SEC 13 H
;;      156     11      VMA4    M8542   PREV SEC 14 H
;;      155     11      VMA4    M8542   PREV SEC 15 H
;;      154     11      VMA4    M8542   PREV SEC 16 H
;;      153     11      VMA4    M8542   PREV SEC 17 H
;       CRC1    M8535   CRC1 PTR DIF=0 H
SIG     141     10      <<89.>%PTR DIF=0%>
 
 
;       SCD5    M8524   SCD5    PUBLIC A H
SIG     67      1       <<5.><196.><172.>>
 
;       SCD5    M8524   SCD5    PUBLIC PAGE H
SIG     62      40      <<5.><196.><142.>>
 
;SEQ292

;       APR2    M8545   APR2 PWR FAIL EN IN H
SIG     29      200     <<84.>%PWR %<168.><133.><132.>>
;       APR2    M8545   APR2    PWR FAIL IN H
SIG     24      200     <<84.>%PWR %<168.><132.>>
;       CCW6    M8534   CCW6 RAM ADR 1 H
SIG     140     100     <<8.><195.><134.><155.>>
;       CCW6    M8534   CCW6 RAM ADR 2 H
SIG     140     40      <<8.><195.><134.><156.>>
;       CCW6    M8534   CCW6 RAM ADR 4 H
SIG     140     20      <<8.><195.><134.>%4%>
;       CRC2    M8535   CRC2 RAM CYC H
SIG     128     200     <<91.><195.><150.>>
;       CLK5    M8526YA CLK5 RATE SEL 1 H
SIG     21      10      <<57.>%RATE %<128.><155.>>
;       CLK5    M8526YA CLK5 RATE SEL 2 H
SIG     18      10      <<57.>%RATE %<128.><156.>>
;       APR3    M8545   APR3 READ COMP H
SIG     32      2       <<86.><225.><202.>>
;       PIC2    M8532   PIC2 READY H
SIG     10      10      <<44.><191.>>


;SEQ293

;       CRC3    M8535   CRC3 READY IN H
SIG     126     4       <<94.><191.><132.>>
;       CSH1    M8513YA CSH1 READY TO GO A H
SIG     107     2       <<56.><191.><173.>%GO %<172.>>
;       MBX3    M8529YA MBX3 REFILL HOLD H
SIG     114     2       <<33.><148.><144.>>
;       167     00-08   MBZ2    M8537   EBUS REG 00-08 H
;       167     14-26   MBZ2    M8537   EBUS REG 14-26 H
;       167     27-33   MBC1    M8531YA EBUS REG 27-33 H
;       167     34,35   MBZ2    M8537   EBUS REG 34,35 H
;       MCL6    M8544   MCL6 REG FUNC H
SIG     19      20      <<35.><213.>%FUNC%>
;       MBX2    M8529YA MBX2 REQ HOLD H
SIG     116     10      <<32.><136.><144.>>
;       CHC2    M8533   CHC2 RESET INTR H
SIG     118     40      <<18.><211.><250.>>
;       CCL4    M8536   CCL4 REVERSE H
SIG     124     1       <<77.><218.>>
;       CHC1    M8533   CHC1 REVERSE H
SIG     136     40      <<17.><218.>>
;       CRC3    M8535   CRC3 REVERSE IN H
SIG     125     200     <<94.><218.><132.>>
;       CRC4    M8535   CRC4 RH20 ERR IN H
SIG     123     4       <<1.>%RH20 %<137.><132.>>

;SEQ294

;       MBX5    M8529YA MBX5 RQ 0 IN H
SIG     116     2       <<37.><161.><214.><132.>>
;       MBX5    M8529YA MBX5 RQ 1 IN H
SIG     102     1       <<37.><161.><155.><132.>>
;       MBX5    M8529YA MBX5 RQ 2 IN H
SIG     104     1       <<37.><161.><156.><132.>>
;       MBX5    M8529YA MBX5 RQ 3 IN H
SIG     106     1       <<37.><161.><236.><132.>>

;       MBC2    M8531YA MBC2 RQ HOLD FF H
SIG     88      4       <<63.><161.><144.>%FF%>

;       APR2    M8545   APR2 S ADR P ERR EN IN H
SIG     30      1       <<84.>%S %<134.>%P %<137.><133.><132.>>
;       APR2    M8545   APR2    ADR P ERR IN H
SIG     25      1       <<84.>%S %<134.>%P %<137.><132.>>

;;      143     01      CRA4    M8541   CRA4    SBR RET 00 H
;;      143     02      CRA4    M8541   CRA4    SBR RET 01 H
;;      143     03      CRA4    M8541   CRA4    SBR RET 02 H
;;      143     04      CRA4    M8541   CRA4    SBR     RET 03 H
;;      143     05      CRA4    M8541   CRA4    SBR RET 04 H
;;      142     00      CRA4    M8541   CRA4    SBR RET 05 H
;;      142     01      CRA4    M8541   CRA4    SBR RET 06 H
;;      142     02      CRA4    M8541   CRA4    SBR RET 07 H
;;      142     03      CRA4    M8541   CRA4    SBR RET 08 H
;;      142     04      CRA4    M8541   CRA4    SBR RET 09 H
;;      142     05      CRA4    M8541   CRA4    SBR RET 10 H
;       MBX2    M8529YA MBX2 SBUS ADR 34 H
SIG     108     1       <<32.><153.><134.>%34%>
;       MBX2    M8529YA MBX2 SBUS ADR 35 H

;SEQ295

SIG     110     1       <<32.><153.><134.>%35%>
;       MBC2    M8531YA MBC2 SBUS ADR HOLD H
SIG     91      20      <<63.><153.><134.><144.>>
;       CLK1    M8526YA CLK1    SBUS CLK H
SIG     0       20      <<39.><153.>%CLK%>
;       APR1    M8545   APR1 SBUS ERR EN IN H
SIG     30      40      <<81.><153.><137.><133.><132.>>
;       APR1    M8545   APR1 SBUS ERR IN H
SIG     25      40      <<81.><153.><137.><132.>>

;       MBX2    M8529YA MBX2 SEL 1 H
SIG     104     4       <<32.><128.><155.>>
;       MBX2    M8529YA MBX2 SEL 2 H
SIG     106     4       <<32.><128.><156.>>
;       CHC5    M8533   CHC5 SEL 8A H
SIG     133     100     <<28.><128.>%8A%>
;       MBX2    M8529YA MBX2 SEL HOLD H
SIG     108     4       <<32.><128.><144.>>
;       MBZ3    M8537   MBZ3 SEQUENTIAL RQ H
SIG     93      2       <<50.>%SEQUENTIAL %<161.>>
;       MCL4    M8544   MCL4 SHORT STACK H
SIG     9       20      <<31.><239.>%STACK%>


;SEQ296

;       CRC4    M8535   CRC4 SHORT WC ERR H
SIG     123     1       <<1.><239.>%WC %<137.>>
;       SCD2    M8524   SCD2 SIGN H
SIG     62      20      <<93.>%SIGN%>
;       CLK5    M8526YA CLK5 SOURCE SEL 1 H
SIG     15      10      <<57.><233.><128.><155.>>
;       CLK5    M8526YA CLK5 SOURCE SEL 2 H
SIG     12      10      <<57.><233.><128.><156.>>
;       CTL1    M8543   CTL1 SPEC/CLR FPD H
SIG     4       10      <<42.><157.><164.>%FPD%>
;       CTL1    M8543   CTL1 SPEC/FLAG CTL H
SIG     13      10      <<42.><157.><220.><208.>>
;       CTL1    M8543   CTL1 SPEC/GEN CRY 18 H
SIG     6       10      <<42.><157.>%GEN %<149.><221.>>
;       CTL1    M8522   CTL1 SPEC/GEN CRY 18 H
SIG     69      20      <<42.><157.>%GEN %<149.><221.>>
;       CTL     M8543   CTL1 SPEC/SCM ALT H
SIG     1       10      <<42.><157.>%SCM ALT%>
;       CTL1    M8543   CTL1 SPEC/SP MEM CYCLE H
SIG     16      10      <<42.><157.>%SP %<135.><187.>>


;SEQ297
;       CTL1    M8543   CTL1 SPEC/STACK UPDAT H
SIG     9       10      <<42.><157.>%STACK UPDATE%>
;       CON3    M8525   CON3 SR 00 H
SIG     60      200     <<12.>%SR 00%>
;       CON3    M8525   CON3    SR 01 H
SIG     64      200     <<12.>%SR 01%>
;       CON3    M8525   CON3 SR 02 H
SIG     68      200     <<12.>%SR 02%>
;       CON3    M8525   CON3 SR 03 H
SIG     72      200     <<12.>%SR 03%>
;;      140     05      CRA4    M8541   CRA4 STACK ADR 01 H
;;      140     04      CRA4    M8541   CRA4 STACK ADR 02 H
;;      140     03      CRA4    M8541   CRA4 STACK ADR 04 H
;;      140     02      CRA4    M8541   CRA4 STACK ADR 10 H
;       CHC2    M8533   CHC2    START H
SIG     139     40      <<18.><188.>>
;       CHC2    M8533   CHC2 START INTRE H
SIG     121     40      <<18.><188.><250.>>
;       PIC2    M8532   PIC2 STATE HOLD H
SIG     10      100     <<44.><192.><144.>>
;       CCL4    M8536   CCL4 STORE CCW H
SIG     136     10      <<77.><158.>%CCW%>


;SEQ298

;       CHC2    M8533   CHC2 STORE H
SIG     127     40      <<18.><158.>>
;       CRC4    8535    <<1.><158.><132.>>
SIG     119     200     <<1.><158.><132.>>
;       APR1    M8545   APR1 SWEEP BUSY EN H
SIG     26      4       <<81.><237.><200.><133.>>
;       APR2    M8545   APR2 SWEEP DONE EN IN H
SIG     29      100     <<84.><237.><154.><133.><132.>>
;       APR2    M8545   APR2 SWEEP DONE IN H
SIG     24      100     <<84.><237.><154.><132.>>
;       CLK3    M8526YA CLK3 SYNC H
SIG     5       4       <<49.>%SYNC%>
;       CHC1    M8533   CHC1 T0 H
SIG     119     1       <<17.>%T0%>
;       CHC1    M8533   CHC1 T1 H
SIG     122     1       <<17.><253.>>
;       CHC1    M8533   CHC1 T2 H
SIG     125     1       <<17.><190.>>
;       CHC1    M8533   CHC1 T3 H
SIG     128     1               <<17.><254.>>
;       IRD3    M8522   IRD3 TEST SATISFIED H
SIG     61      200     <<72.><201.>%SATISFIED%>


;SEQ299

;       110     20-35   MTR1    M8538   MTR1 TIME 02-17 H
;       MTR2    M8538   MTR2 TIME ON H
SIG     42      4       <<14.>%TIME ON%>
;       PIC2    M8532   PIC2 TIMER DONE H
SIG     11      1       <<44.>%TIMER %<154.>>
;       SCD4    M8524   SCD4 TRAP CYC 1 H
SIG     46      200     <<2.><180.><150.><155.>>
;       SCD4    M8524   SCD4 TRAP CYC 2 H
SIG     47      1       <<2.><180.><150.><156.>>
;       CON3    M8525   CON3 TRAP EN H
SIG     48      40      <<12.><180.><133.>>
;;      136     03      SCD3    M8524   SCD3 TRAP MIX 32 H
;;      136     04      SCD3    M8524   SCD3 TRAP MIX 33 H
;;      137     03      SCD3    M8524   SCD3 TRAP MIX 34 H
;;      137     04      SCD3    M8524   SCD3 TRAP MIX 35 H
;       SCD4    M8524   SCD4 TRAP REQ 1 H
SIG     46      100     <<2.><180.><136.><155.>>
;       SCD4    M8524   SCD4 TRAP REQ 2 H
SIG     47      2       <<2.><180.><136.><156.>>
;       CON4    M8525   CON4 UCODE STATE 01 H
SIG     60      20      <<13.><210.><192.>%01%>
;       CON4    M8525   CON4 UCODE STATE 03 H
SIG     64      20      <<13.><210.><192.>%03%>
;       CON4    M8525   CON4 UCODE STATE 05 H


;SEQ300

SIG     68      20      <<13.><210.><192.>%05%>
;       CON4    M8525   CON4 UCODE STATE 07 H
SIG     72      20      <<13.><210.><192.>%07%>
;       CSH6    M8513YA CSH6 USE HOLD H
SIG     107     1       <<66.><171.><144.>>
;       CSH6    M8513YA CSH6 USE WR EN H
SIG     113     20      <<66.><171.><139.><133.>>
;       APR3    M8545   APR3 USER COMP H
SIG     31      200     <<86.><169.><202.>>
;       SCD5    M8524   SCD5    USER IOT A H
SIG     70      100     <<5.><169.>%IOT %<172.>>
;       MTR5    M8538   MTR5 VECTORREQ H
SIG     43      200     <<21.>%VECTOR %<136.>>
;       MCL5    M8544   MCL5 VMA ADR ERR H
SIG     9       100     <<34.><143.><134.><137.>>
;       MCL6    M8544   MCL6 VMA FETCH H
SIG     22      200     <<35.><143.><238.>>
;       MCL4    M8544   MCL4 VMA GETS AD H
SIG     6       40      <<31.><143.>%GETS %<197.>>
;       SCD4    M8524   SCD4 VMA HELD OR PC 00 H
SIG     55      2       <<2.><143.>%HELD OR PC 00%>

;SEQ301

;;      100     18      MCL3    M8544   MCL3 VMA HELD OR PC 01 H
;;      100     19      MCL3    M8544   MCL3 VMA HELD OR PC 02 H
;;      100     20      MCL3    M8544   MCL3 VMA HELD OR PC 03 H
;;      100     21      MCL3    M8544   MCL3 VMA HELD OR PC 04 H
;;      100     22      MCL3    M8544   MCL3 VMA HELD OR PC 05 H
;;      100     23      MCL3    M8544   MCL3 VMA HELD OR PC 06 H
;;      101     18      MCL3    M8544   MCL3 VMA HELD OR PC 07 H
;;      101     19      MCL3    M8544   MCL3 VMA HELD OR PC 08 H
;;      101     20      MCL3    M8544   MCL3 VMA HELD OR PC 09 H
;;      101     21      MCL3    M8544   MCL3 VMA HELD OR PC 10 H
;;      101     22      MCL3    M8544   MCL3 VMA HELD OR PC 11 H
;;      101     23      MCL3    M8544   MCL3 VMA HELD OR PC 12 H
;       MCL4    M8544   MCL4 VMA INC H
SIG     9       40      <<31.><143.>%INC%>
;       MCL2    M8544   MCL2 VMA PAUSE H
SIG     10      2       <<24.><143.>%PAUSE%>
;       MCL2    M8544   MCL2 VMA PUBLIC H
SIG     17      1       <<24.><143.><196.>>
;       MCL2    M8544   MCL2 VMA READ H
SIG     7       2       <<24.><143.><225.>>
;       MCL6    M8544   MCL6 VMA UPT H
SIG     9       200     <<35.><143.>%UPT%>
;       MCL2    M8544   MCL2 VMA USER H
SIG     14      1       <<24.><143.><169.>>
;       MCL2    M8544   MCL2 VMA WRITE H
SIG     14      2       <<24.><143.><194.>>
;       MCL4    M8544   MCL4    VMAX SEL 1 H
SIG     19      100     <<31.><252.><128.><155.>>




;SEQ302

;       MCL4    M8544   MCL4 VMAX SEL 2 H
SIG     16      100     <<31.><252.><128.><156.>>
;       CCL5    M8536   CCL5 WC GE4 H
SIG     118     2       <<78.>%WC GE4%>
;       CCW4    M8534   CCW4 WD READY H
SIG     119     100     <<3.><247.><191.>>
;       CCW4    M8534   CCW4 WD0 REQ H
SIG     122     100     <<3.>%WD0 %<136.>>
;       CCW4    M8534   CCW4 WD1 REQ H
SIG     122     40      <<3.>%WD1 %<136.>>
;       CCW4    M8534   CCW4 WD2 REQ H
SIG     122     20      <<3.>%WD2 %<136.>>
;       CCW4    M8534   CCW4 WD3 REQ H
SIG     122     10      <<3.>%WD3 %<136.>>
;       CON3    M8525   CON3 WR EVEN PAR ADR H
SIG     45      2       <<12.><139.>%EVEN %<130.><134.>>
;       CON3    M8525   CON3 WR EVEN PAR DATA H
SIG     45      1       <<12.><139.>%EVEN %<130.><140.>>
;       CON3    M8525   CON3 WR EVEN PAR DIR H
SIG     44      200     <<12.><139.>%EVEN %<130.><178.>>

;SEQ303

;       APR5    M8545   APR5    WR PT SEL 0 H
SIG     38      20      <<95.><139.>%PT %<128.><214.>>
;       APR5    M8545   APR5 WR PT SEL 1 H
SIG     40      20      <<95.><139.>%PT %<128.><155.>>
;       APR3    M8545   APR3 WRITE COMP H
SIG     32      1       <<86.><194.><202.>>
;       MBC1    M8531YA MBC1 WRITE OK H
SIG     85      20      <<60.><194.>%OK%>
;       CSH4    M8513YA CSH4 WRITEBACK T1 A H
SIG     109     1       <<62.><170.><253.><172.>>
;       MCL4    M8544   MCL4 XR PREVIOUS H
SIG     6       100     <<31.>%XR PREVIOUS%>
;       MCL4    M8544   MCL4 XR SHORT H
SIG     6       20      <<31.>%XR %<239.>>
HLBRK=.
;       MBC3    M8531YA MBC3 A CHANGE COMING A L
SIG     91      10      <<65.><172.><234.><223.><172.>>
;       VMA1    M8542   VMA1 AC REF A L
SIG     84      100     <<23.>%AC %<246.><172.>>
;       MBC4    8531YA  MBC4 ACKN PULSE L


;SEQ304

SIG     96      20      <<67.>%ACKN %<206.>>
;       IRD4    M8524   IRD4 AD CRY -02 A L
SIG     54      40      <<73.><197.><149.>%-02 %<172.>>
;       EDP3    M8524   EDP3 AD CRY 01 L
SIG     50      100     <<76.><197.><149.>%01%>
;       EDP3    M8524   EDP3 AD OVERFLOW 00 L
SIG     54      100     <<76.><197.>%OVERFLOW 00%>
;       IRD3    M8522   IRD3 AD=0 L
SIG     69      200     <<72.>%AD=0%>
;       CRC1    M8535   CRC1 AF REQ ENA L
SIG     134     200     <<89.>%AF %<136.><207.>>
;       CCL3    M8536   CCL3 AF T2 L
SIG     127     1       <<75.>%AF %<190.>>
;       CCL3    M8536   CCL3 ALU MINUS L
SIG     121     2       <<75.>%ALU MINUS%>
;       MBC3    M8531YA MBC3 ANY SBUS RQ IN L
SIG     91      4       <<65.><160.><153.><161.><132.>>
;       CTL2    M8543   CTL2 AR 00-08 LOAD L
SIG     0       200     <<46.><184.>%00-08 %<141.>>


;SEQ305
;       CTL2    M8543   CTL2 AR 09-17 LOAD L
SIG     3       200     <<46.><184.>%09-17 %<141.>>
;       CLK5    M8526YA CLK5 AR/ARX PAR CHECK L
SIG     18      1       <<57.>%AR/ARX %<130.><189.>>
;       CTL2    M8543   CTL2 ARR LOAD A L
SIG     1       1       <<46.><228.><141.><172.>>
;       CTL2    M8543   CTL2 ARR LOAD B L
SIG     4       1       <<46.><228.><141.>%B%>
;       CON4    M8525   CON4 ARX LOADED L
SIG     56      20      <<13.><229.>%LOADED%>
;       CTL2    M8543   CTL2 ARXL SEL 1 L
SIG     16      2       <<46.>%ARXL %<128.><155.>>
;       MBC3    M8531YA MBC3 B CHANGE COMING L
SIG     95      1       <<65.>%B %<234.><223.>>
;       CCW1    M8534   CCW1 BUF ADR 0 L
SIG     125     10      <<88.><242.><134.><214.>>
;       CCW1    M8534   CCW1 BUF ADR 1 L
SIG     125     4       <<88.><242.><134.><155.>>
;       CCW1    M8534   CCW1 BUF ADR 2 L
SIG     125     2       <<88.><242.><134.><156.>>

;SEQ306

;       CLK2    M8526YA CLK2 BURST L
SIG     8       20      <<45.>%BURST%>
;       CSH1    M8513YA CSH1 CACHE IDLE L
SIG     110     100     <<56.><138.>%IDLE%>
;       MBX4    M8529YA MBX4 CACHE TO MB T2 L
SIG     110     40      <<36.><138.><173.><151.><190.>>
;       MBX4    M8529YA MBX4 CACHE TO MB T3 L
SIG     112     40      <<36.><138.><173.><151.><254.>>
;       MBX4    M8529YA MBX4 CACHE TO MB T4 A L
SIG     114     40      <<36.><138.><173.><151.><255.><172.>>
;       CSH6    M8513YA CSH6 CCA CYC DONE L
SIG     107     20      <<66.><165.><150.><154.>>
;       CSH1    M8513YA CSH1 CCA CYC L
SIG     106     200     <<56.><165.><150.>>
;       CSH6    M8513YA CSH6 CCA INVAL T4 L
SIG     115     40      <<66.><165.>%INVAL %<255.>>
;       MBX1    M8529YA MBX1 CCA REQ L
SIG     102     20      <<29.><165.><136.>>
;       CSH7    M8513YA CSH7 CCA WRITEBACK L
SIG     108     200     <<69.><165.><170.>>
;       CRC6    M8535   CRC6 CH ADR 0C L
SIG     141     4       <<7.><226.><134.>%0C%>

;SEQ307

;       CRC6    M8535   CRC6 CH ADR 1 C L
SIG     141     2       <<7.><226.><134.>%1C%>
;       CRC6    M8535   CRTC6 CH ADR 2 C L
SIG     141     1       <<7.><226.><134.>%2C%>
;       CRC6    M8535   CRC6 CH ADR 3C L
SIG     140     200     <<7.><226.><134.>%3C%>
;       CCL4    M8536   CCL4 CH TEST MB PAR L
SIG     121     1       <<77.><226.><201.><151.><130.>>
;       MBZ4    M8537   MBZ4 CHAN ADR PAR ERR L
SIG     93      20      <<52.><145.><134.><130.><137.>>
;       MBZ3    M8537   MBZ3 CHAN MEM REF L
SIG     89      20      <<50.><145.><135.><246.>>
;       MBZ3    M8537   MBZ3 CHAN NXM ERR L
SIG     86      4       <<50.><145.><182.><137.>>
;       MBZ4    M8537   MBZ4 CHAN PAR ERR L
SIG     87      10      <<52.><145.><130.><137.>>
;       CSH5    M8513YA CSH5 CHAN RD T5 L
SIG     105     40      <<64.><145.><198.>%T5%>
;       MBZ1    M8537   MBZ1 CHAN READ L
SIG     93      1       <<40.><145.><225.>>
;       CSH5    M8513YA CSH 5 CHAN T4 L
SIG     107     10      <<64.><145.><255.>>


;SEQ308

;       CSH6    M8513YA CSH6 CHAN WR CACHE L
SIG     107     40      <<66.><145.><139.><138.>>
;       MBX2    M8529YA MBX2 CHAN WR CYC L
SIG     108     20      <<32.><145.><139.><150.>>
;       CSH5    M8513YA CSH5 CHAN WR T5 L
SIG     105     1       <<64.><145.><139.>%T5%>
;       CON1    M8525   CON1 COND EN 00-07 L
SIG     53      2       <<10.><204.><133.>%00-07%>
;       CON1    M8525   CON1 COND/MBOX CTL L
SIG     52      200     <<10.><193.><147.><208.>>
;       CON1    M8525   CON1 COND/SEL VMA L
SIG     53      1       <<10.><193.><128.><143.>>
;       MTR3    M8538   MTR3 CONO MTR, L
SIG     43      4       <<16.>%CONO MTR,%>
;       MBC4    M8531YA MBC4 CORE DATA VAL -1 L
SIG     98      100     <<67.><152.><140.><167.>%-1%>
;       MBC4    M8531YA MBC4 CORE DATA VALID -2 L
SIG     98      40      <<67.><152.><140.><159.>%-2%>
;       MBC4    M8531YA MBC4 CORE DATA VALID L
SIG     98      20      <<67.><152.><140.><159.>>

;SEQ309

;       CLK5    M8526YA CLK5 CRAM PAR CHECK L
SIG     15      2       <<57.>%CRAM %<130.><189.>>
;       CHX2    M8515   CHX2 CSH 0 ANY VAL L
SIG     103     200     <<83.><129.><214.><160.><167.>>
;       CHA3    M8513YA CHA3 CSH 0 ANY WR L
SIG     117     4       <<9.><129.><214.><160.><139.>>
;       CHX2    M8515   CHX2 CSH 1 ANY VAL L
SIG     105     200     <<83.><129.><155.><160.><167.>>
;       CHA3    M8513YA CHA3 CSH 1 ANY WR L
SIG     113     4       <<9.><129.><155.><160.><139.>>
;       CHX2    M8515   CHX2 XSH 2 ANY VAL L
SIG     107     200     <<83.><129.><156.><160.><167.>>
;       CHA3    M8513YA CHA3 CSH 2 ANY WR L
SIG     115     4       <<9.><129.><156.><160.><139.>>
;       CHX2    M8515   CHX2 CSH 3 ANY VAL L
SIG     109     200     <<83.><129.><236.><160.><167.>>
;       CHA3    M8513YA CHA3 CSH 3 ANY WR L
SIG     111     4       <<9.><129.><236.><160.><139.>>

;SEQ310

;       CCL6    M8536   CCL6 CSH CHAN CYC L
SIG     139     2       <<80.><129.><145.><150.>>
;       MBC2    M8531YA MBC2 CSH DATA CLR DONE IN L
SIG     85      4       <<63.><129.><140.><164.><154.><132.>>
;       MBC2    M8531YA MBC2 CSH DATA CLR T1 L
SIG     89      1       <<63.><129.><140.><164.><253.>>
;       MBC2    M8531YA MBC2 CSH DATA CLR T2 L
SIG     88      200     <<63.><129.><140.><164.><190.>>
;       MBC2    M8531YA MBC2 CSH DATA CLR T3 L
SIG     88      100     <<63.><129.><140.><164.><254.>>
;       MBZ1    M8537   MBZ1 CXSH EN CSH DATA L
SIG     87      1       <<40.><129.><133.><129.><140.>>
;       CSH5    M8513YA CSH5 CSH T0 L
SIG     111     2       <<64.><129.>%T0%>
;       CSH4    M8513YA CSH4 DATA CLR DONE L
SIG     103     1       <<62.><140.><164.><154.>>
;       CSH6    M8513YA CSH6 DATA DLY 1 L
SIG     117     20      <<66.><140.>%DLY %<155.>>
;       CTL3    M8543   CTL3 DIAG LOAD EBUS REG L
SIG     22      1       <<48.><183.><141.><162.><213.>>

;SEQ311
;       CRA3    M8541   CRA3 DISP EN 00-03 L
SIG     77      4       <<79.><224.><133.>%00-03%>
;       CRA3    M8541   CRA3 DISP EN 00-07 L
SIG     77      10      <<79.><224.><133.>%00-07%>
;       CRA3    M8541   CRA3    DISP EN 30-37 L
SIG     78      10      <<79.><224.><133.>%30-37%>
;       CTL1    M8543   CTL1 DISP RET L
SIG     9       4       <<42.><224.>%RET%>
;       CLK5    M8526YA CLK5 DRAM PAR CHECK L
SIG     18      2       <<57.><231.><130.><189.>>
;       CSH2    M8513YA CSH2 E CORE RD RQ A L
SIG     111     40      <<58.><205.><152.><198.><161.><172.>>
;       CSH7    M8513YA CSH77   M8513YA CSH 7 E WRITEBACK L
SIG     114     200     <<69.><205.><170.>>
;       MCL6    M8544   MCL6    EBOX CACHE L
SIG     13      20      <<35.><131.><138.>>

;       CLK4    M8526YA CLK4 EBOX CLK L
SIG     8       4       <<53.><131.>%CLK%>
;       CSH1    M8513YA CSH1 EBOX CYC B L
SIG     110     200     <<56.><131.><150.>%B%>

;       APR6    M8544   APR6 EBOX LOAD REG L


;SEQ312

SIG     35      10      <<0.><131.><141.><213.>>
;       MCL6    M8544   MCL6 EBOX MAP L
SIG     22      20      <<35.><131.>%MAP%>
;       MCL6    M8544   MCL6 EBOX MAY BE PAGED L
SIG     16      20      <<35.><131.>%MAY BE PAGED%>
;       APR6    M8545   APR6 EBOX READ REG L
SIG     35      4       <<0.><131.><225.><213.>>
;       CSH2    M8513YA CSH2 EBOX REQ EN L
SIG     106     100     <<58.><131.><136.><133.>>
;       CSH2    M8513YA CSH2 EBOXC RETRY REQ L
SIG     113     40      <<58.><131.>%RETRY %<136.>>
;       CLK2    M8526YA CLK2 EBOX SS L
SIG     12      20      <<45.><131.>%SS%>
;       CSH4    M8513YA CSH4 EBOX TO L
SIG     115     10      <<62.><131.>%T0%>
;       CSH4    M8513YA CSH4 EBOX T1 L
SIG     104     100     <<62.><131.><253.>>
;       CSH4    M8513YA CSH4 EBOX T2 L
SIG     108     100     <<62.><131.><190.>>
;       CSH4    M8513YA CSH4 EBOX T3 L
SIG     102     100     <<62.><131.><254.>>

;SEQ313
;       CSH4    M8513YA CSH4 EBOX WR T4 L
SIG     116     100     <<62.><131.><139.><255.>>
;       APR3    M8545   APR3 EBUS REQ L
SIG     38      4       <<86.><162.><136.>>
;       CLK5    M8526YA CLK5 ER STOP EN L
SIG     21      1       <<57.><137.>%STOP %<133.>>
;       CLK3    8526YA  CLK3 ERROR L
SIG     21      40      <<49.><175.>>
;       CSH7    M8513YA CSH7 FILL CACHE RD L
SIG     105     2       <<69.>%FILL %<138.><198.>>
;       CLK5    M8526YA         CLK5    FM PAR CHECK L
SIG     12      2       <<57.><219.><130.><189.>>
;       CON5    M8545   CON5 FM WRITE PAR L
SIG     40      1       <<15.><219.><194.><130.>>
;       CON5    M8525   CON5 FM WRITE PAR L
SIG     60      10      <<15.><219.><194.><130.>>
;       CON5    M8525   CON5 FM XFER L
SIG     68      10      <<15.><219.>%XFER%>
;       CLK5    M8526YA CLK5 FS CHECK L
SIG     21      2       <<57.>%FS %<189.>>
;       CLK2    M8526YA CLK2 GO L

;SEQ314

SIG     5       20      <<45.>%GO%>
;       MBZ3    M8537   MBZ3 HOLD ERA L
SIG     92      40      <<50.><144.>%ERA%>
;       CTL1    M8543   CTL1 INH CRY 18 L
SIG     22      10      <<42.><212.><149.><221.>>
;       CTL1    M8522   CTL1 INH CRY 18 L
SIG     69      40      <<42.><212.><149.><221.>>
;       CON2    M8525   CON2 INSTR GO L
SIG     64      40      <<11.><163.>%GO%>
;       IRD3    M8522   IRD3 JRST 0, L
SIG     61      100     <<72.>%JRST 0,%>
;       CON3    M8525   CON3 KL10 PAGING MODE L
SIG     48      100     <<12.>%KI10 PAGING MODE%>
;       CON2    M8525   CON2 LOAD IR L
SIG     52      40      <<11.><141.>%IR%>
;       CTL1    M8543   CTL1 LOAD PC L
SIG     13      4       <<42.><141.>%PC%>
;       CON1    M8525   CON1 LOD SPEC INSTR L
SIG     65      1       <<10.><141.>%SPEC %<163.>>
;       MCL4    M8544   MCL4    LOAD VMA CONTEXT L


;SEQ315

SIG     13      40      <<31.><141.><143.>%CONTEXT%>
;       VMA1    M8542   VMA1 LOCAL AC ADDRESS L
SIG     83      20      <<23.>%LOCAL AC ADDRESS%>
;       CON2    M8525   CON2 LONG EN L
SIG     52      100     <<11.><251.><133.>>
;       CSH1    M8513YA CSH1 MB CYC L
SIG     112     200     <<56.><151.><150.>>
;       CSH3    M8513YA CSH3 MB TEST PAR A IN L
SIG     113     10      <<61.><151.><201.><130.><172.><132.>>
;       CSH3    M8513YA CSHE MB WR RQ CLR NXT L
SIG     104     200     <<61.><151.><139.><161.><164.>%NXT%>
;       MBZ4    M8537   MBZ4 MBOX ADR PAR ERR L
SIG     90      20      <<52.><147.><134.><130.><137.>>
;       MBZ4    M8537   MBZ4 MBOX MB PAR ERR L
SIG     92      10      <<52.><147.><151.><130.><137.>>
;       MBZ3    M8537   MBZ3 MBOX NXM ERR L
SIG     89      40      <<50.><147.><182.><137.>>
;       CSH6    M8513YA CSH6    MBOX PT DIR WR L
SIG     103     10      <<66.><147.>%PT %<178.><139.>>

;SEQ316

;       CSH2    M8513YA CSH2 MBOX RESP L
SIG     109     20      <<58.><147.>%RESP%>
;       CLK5    M8526YA CLK5 MBOX RESP SIM L
SIG     15      1       <<57.><147.>%RESP SIM%>
;       MBZ4    M8537   MBZ4    MBOX SBUS ERR L
SIG     89      10      <<52.><147.><153.><137.>>
;       CON5    M8525   CON5 MBOX WAIT L
SIG     64      10      <<15.><147.>%WAIT%>
;       CON5    M8525   CON5 MEM CYCLE L
SIG     56      10      <<15.><135.><187.>>
;       MBX3    M8529YA MBX3 MEM DIAG L
SIG     104  2       <<33.><135.><183.>>
;       MBC4    M8531YA MBC4 MEM START L
SIG     100     10      <<67.><135.><188.>>
;       CRC4    M8535   CRTC4 MEM STORE ENA L
SIG     120     2       <<1.><135.><158.><207.>>
;       MBZ1    M8537   MBZ1 MEM TO C DIAG EN L
SIG     90      1       <<40.><135.><173.>%C %<183.><133.>>
;       MBC3    M8531YA MBC3    TO C EN L
SIG     96      100     <<65.><135.><173.>%C %<133.>>

;SEQ317

;       MBX5    M8529YA MBX5 MEM TO C EN L
SIG     102     2       <<37.><135.><173.>%C %<133.>>
;       MBC4    M8531YA MBC4    MEM WR RQ L
SIG     100     4       <<67.><135.><139.><161.>>
;       MCL1    M8545   MCL1 MEM/REG FUNC L
SIG     35      20      <<20.>%MEM/REG FUNC%>
;       VMAT    M8542   VMA1 MISC=0 L
SIG     83      100     <<23.>%MISC=0%>
;       MBZ3    M8537   MBZ3 NXM ANY L
SIG     86      20      <<50.><182.><160.>>
;       MBZ3    M8537   MBZ3 NXM DATA VAL L
SIG     89      4       <<50.><182.><140.><167.>>
;       MBZ4    M8537   MBZ4 NXM T6,7 L
SIG     86      10      <<52.><182.>%T6,7%>
;       CSH2    M8513YA CSH2 ONE WORD RD A L
SIG     109     40      <<58.>%ONE %<222.><198.><172.>>
;       CSH4    M8526YA CLK4 PAGE FAIL EN L
SIG     112     100     <<62.>%ONE %<222.><139.>%T0%>
;       CLK4    M8526YA CLK4 PAGE FAIL EN L
SIG     5       2       <<53.><142.><168.><133.>>
 
;SEQ318
;       CSH6    M8513YA CSH6 PAGE FAIL HOLD L
SIG     111     20      <<66.><142.><168.><144.>>
;       CSH4    M8513YA CSH4 PAGE FAIL T2 L
SIG     105     10      <<62.><142.><168.><190.>>
;       CSH5    M8513YA CSH5 PAGE REFILL COMP L
SIG     103     40      <<64.><142.><148.><202.>>
;       CSH6    M8513YA CSH6 PAGE REFILL ERROR L
SIG     117     40      <<66.><142.><148.><175.>>
;       CSH5M8513YA CSH 5 PAGE REFILL T10 L
SIG     117     2       <<64.><142.><148.>%T10%>

;       CSH5    M8513YA CSH5 PAGE REFILL T4 L
SIG     114     100     <<64.><142.><148.><255.>>
;       CSH5    M8513YA CSH5 PAE REFILL T8 L
SIG     115     20      <<64.><142.><148.>%T8%>
;       CSH5    M8513YA CSH5 PAGE REFILL T9,12 L
SIG     111     10      <<64.><142.><148.>%T9,12%>
;       MCL6    M8544   MCL6 PAGED FETCH L
SIG     22      100     <<35.>%PAGED %<238.>>
;       VMA3    M8542   VMA3 PC SECTION 0 L
SIG     81      1       <<27.>%PC %<216.><214.>>

;SEQ319

;       CON4    M8525   CON4 PC+1 INH L
SIG     56      100     <<13.>%PC+1 %<212.>>
;       VMA4    M8542   VMA4 PCS SECTION 0 L
SIG     82      1       <<30.>%PCS %<216.><214.>>
;       MBC3    M8531YA MBC3 PHASE CHANGE COMING L
SIG     96      40      <<65.>%PHASE %<234.><223.>>
;       CON5    M8524   CON5 PI CYCLE A L
SIG     62      200     <<15.>%PI %<187.><172.>>
;       CON5    M8525   CON5 PI DISMISS L
SIG     72      10      <<15.>%PI DISMISS%>
;       SCD5    M8524   SCD5 PRIVATE INSTR EN L
SIG     66      40      <<5.><185.><163.><133.>>
;       SCD5    M8524   SCD5 PRIVATE INSTR L
SIG     66      100     <<5.><185.><163.>>
;       APR5    M8545   APR5 PT DIR WR L
SIG     38      10      <<95.>%PT %<178.><139.>>
;       APR5    M8545   APR5 PT WR L
SIG     40      10      <<95.>%PT %<139.>>
;       SCD5    M8524   SCD5    PUBLIC EN LL
SIG     67      2       <<5.><196.><133.>>

;SEQ320

;       CSH2    M8513YA CSH2 RD PAUSE 2ND HALF L
SIG     116     200     <<58.><198.>%PAUSE 2ND HALF%>

SIG     109     10      <<58.><198.>%PSE 2ND %<136.><133.>>
;       MBZ1    M8537   MBZ1 RD-PSE-WR REF L
SIG     89      100     <<40.>%RD-PSE-WR %<246.>>
;       CSH4    M8513YA CSH4 REFILL RAM WR L
SIG     102     200     <<62.><148.><195.><139.>>
;       MCL1    M8544   MCL1    REQ EN L
SIG     10      1       <<20.><136.><133.>>
;       CRC4    M8535   CRC4 RESET IN L
SIG     120     4       <<1.><211.><132.>>
;       MBX3    M8529YA MBX3 SBUS DIAG 3 L
SIG     112     1       <<33.><153.><183.><236.>>
;       MBX3    M8529YA MBX3 SBUS DIAG CYC L
SIG     114     1       <<33.><153.><183.><150.>>
;       SCD1    M8524   SCD1    SCAD=0 L
SIG     58      200     <<85.>%SCAD=0%>
;       CRC6    M8535   CRC6 SEL 1D L
SIG     135     4       <<7.><128.>%1D%>


;SEQ321
;       CRC6    M8535   CRC6 SEL 2D L
SIG     135     2       <<7.><128.>%2D%>
;       CRC6    M8535   CRC6 SEL 4D L
SIG     135     1       <<7.><128.>%4D%>
;       APR5    M8545   APR5 SET PAGE FAIL L
SIG     36      10      <<95.>%SET %<142.><168.>>
;       CONT    M8525   CON1    SKIP EN 40-47 L
SIG     57      2       <<10.>%SKIP %<133.>%40-47%>
;       CON1    M8525   CON1 SKIP EN 50-57 L
SIG     61      2       <<10.>%SKIP %<133.>%50-57%>
;       CTL2    M8543   CTL2 SPEC CALL L
SIG     21      200     <<46.>%SPEC CALL%>
;       CTL1    M8543   CTL1 SPEC MTR CTL L
SIG     4       4       <<42.>%SPEC MTR %<208.>>
;       CTL1    M8543   CTL1 SPEC/SAVE FLAGS L
SIG     1       4       <<42.><157.>%SAVE FLAGS%>
;       CCL4    M8536   CCL4 START MEM L
SIG     136     1       <<77.><188.><135.>>
;       MCL2    M8544   MCL2 STORE AR L


;SEQ322

SIG     23      2       <<24.><158.><184.>>
;       CSH5    M8513YA CSH5 T1 L
SIG     109     2       <<64.><253.>>
;       CSH5    M8513YA CSH5 T2 L
SIG     115     2       <<64.><190.>>
;       CSH5    M8513YA CSH5 T3 L
SIG     113     2       <<64.><254.>>
;       SCD4    M8524   SCD4 TRAP CLEAR L
SIG     74      20      <<2.><180.>%CLEAR%>
;       SCD5    M8524   ACD5 USER A L
SIG     63      2       <<5.><169.><172.>>
;       SCD5    M8524   SCD5 USER EN L
SIG     62      100     <<5.><169.><133.>>
;       SCD5    M8524   SCD5 USER IOT EN L
SIG     70      40      <<5.><169.>%IOT %<133.>>
;       MCL2    M8544   MCL2 VMA EXTENDED L
SIG     23      1       <<24.><143.><199.>>
;       MCL2    M8544   MCL2 VMA PREVIOUS L
SIG     20      1       <<24.><143.>%PREVIOUS%>
;       VMA1    M8542   VMA1 VMA SECTION 0 L
SIG     80      1       <<23.><143.><216.><214.>>

;SEQ323
;       CON1    M8525   CON1    VMA SEL 1 L
SIG     73      1       <<10.><143.><128.><155.>>
;       CON1    M8525   CON1 VMA SEL 2 L
SIG     69      1       <<10.><143.><128.><156.>>
;       MCL5    M8544   MCL5 VMAX EN L
SIG     13      100     <<34.><252.><133.>>
;       CCL5    M8536   CCL5 WC=0 L
SIG     118     1       <<78.>%WC=0%>
;       APR2    M8545   APR2 WR BAD ADR PAR L
SIG     36      1       <<84.><139.>%BAD %<134.><130.>>
;       CSH6    M8513YA CSH6 WR DATA RDY L
SIG     105     20      <<66.><139.><140.>%RDY%>
;       CRC5    M8535   CRC5 WR RAM L
SIG     132     2       <<4.><139.><195.>>
;       CSH2    M8513YA CSH2 WR TEST L
SIG     103     4       <<58.><139.><201.>>
;       MBX4    M8529YA MBX4 WRITEBACK T2 L
SIG     116     1       <<36.><170.><190.>>

        .WORD   0,0             ;TERMINATE NAME TABLE


;SEQ324

.SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #FATAL,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   $REV            ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   $VER            ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN

;SEQ326

.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN


;SEQ266

SPCRST: MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/ LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES,SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT                  ;ENABLE CONDITIONS
       
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;NO
        JSR     R5,BRST1        ;YES,BUTST 34 TICKS
4$:     RTS     PC              ;RETURN


;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5


;SEQ268


.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT


.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        JMP     INDRST          ;RETURN TO COMMAND MODE


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15

;SEQ342

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0



.REM    %
READ17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1

        MOV     #HDWEXA,R0       ;
        EXCT                    ;DO A SUB AC17 17
        MOV     #ZERO..,R0      ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1

        
        RTS     R5              ;RETURN


        
HDWEXA: I10     SUB AC17,,17


        .EVEN
EXAREA: WD36    0,0,0


        .EVEN
                

;SEQ345

.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;


;SEQ346


.SBTTL          22-BIT ADDRESS PRINT ROUTINE
.REM    %
PNT22S - 22-BIT ADDRESS PRINT ROUTINE.
%
PNT22S: MOV     (R5)+,R0                ;GET ADDESS POINTER
PNT22A: PUSH    R1

        MOVB    (R0)+,SCRWD     ;GET LEAST SIGNIFICANT BYTE
        MOVB    (R0)+,SCRWD+1   ;NEXT TO MAKE WORD
        MOVB    (R0),R1         ;UPPER BITS TO R1
        MOV     SCRWD,R0        ;LOWER BITS TO R0
        BIC     #177700,R1      ;CLEAR NON-ADDRESS BITS
        BEQ     2$              ;UPPER ADDRESS BITS?
        MOV     R1,R0           ;INTERCHANGE R0 & R1
        MOV     SCRWD,R1        ;
        ROL     R1              ;SHIFT 1
        ROL     R0              ;
        PNTOCS                  ;PRINT UPPER PART
        PUSH    R2
 

        MOV     #5,R2           ;DIGIT COUNT
1$:     CLR     R0              ;
        .REPT   3               ;GET A DIGIT
        ROL     R1
        ROL     R0
.ENDR
        PNTOCS                  ;PRINT A DIGIT
        DEC     R2              ;DONE?
        BGT     1$              ;NO, NEXT DIGIT
        POP     R2
        BR      3$              ;YES
        MOV     R1,R0           ;GET ADDRESS
2$:     PNTOCS                  ;PRINT IT
3$:     POP     R1              ;
        RTS     R5              ;RETURN
 
;SEQ347
 
.SBTTL          MEM REF SUBROUTINE
.REM    %
        
GETMEM - ROUTINE TO SAVE THE STATUS OF A MEMORY REFERENCE.  PUTS
RQ0, RQ1, RQ2, RQ3, RD & WR RQS & THE SBUS ADR IN TABLE MEMTAB:
%
GETMEM: PUSH    R1
        DFRDT                   ;READ REQUESTS
                166             ;
        MOV     @.DAT3,R1       ;
        BIC     #177417,R1      ;CLEAR GARBAGE
        TBIT    27              ;RD?
        BEQ     1$              ;NO
        BIS     #10,R1          ;YES
1$:     TBIT    33              ;WR?
        BNE     2$              ;NO
        BIS     #4,R1           ;YES
2$:     MOVB    R1,MEMTAB               ;PUT RQS IN FIRST BYTE
        DFRDT                   ;GET EBUS REG (PMA)
                167             ;
        MOV     .DAT3,R0        ;
        MOV     #MEMTAB+1,R1    ;
        MOVB    (R0)+,(R1)+     ;PUT IN NEXT 3 BYTES
        MOVB    (R0)+,(R1)+     ;
        MOVB    (R0),(R1)       ;
        BICB    #300,(R1)       ;CLEAR GARBAGE
        MOV     #MEMTAB+1,R1    ;
        BICB    #3,(R1)         ;CLEAR OUT PMA 34 & 35
        DFRDT
                173
        TBIT    35              ;TEST SBUS ADR 34
        BEQ     3$              ;CLEAR
        BISB    #2,(R1)         ;SET
3$:     DFRDT
                174
        TBIT    35              ;TEST SBUS ADR 35
        BEQ     4$              ;CLEAR
        INCB    (R1)            ;SET
4$:     MOV     #MEMTAB,R0              ;TABLE POINTER TO R0
        MOV     R0,MEMRQ        ;SET FLAG
        POP     R1
        RTS     R5              ;RETURN
MEMTAB: .WORD   0,0             ;MEM RQ STATUS
MEMRQ:  .WORD   0               ;MEM STATUS FLAG

    
ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN


.SBTTL          CACHE REFILL SUBROUTINES
.REM    %
REFILL - ROUTINE TO LOAD ANY REFILL ALGORITHM.
%
REFILL: MOV     R5,BRKPC        ;SAVE PC
REF1:   MOV     (R5)+,$REFPT    ;SAVE TABLE ADDRESS
        REGSAV
        CLR     $RFCNT          ;THE 5-DIGIT COUNT
        CLR     $RFADR          ;THE RAM ADDRESS
        MOV     $REFPT,R4       ;PTR TO TABLE OF DATA
        MOV     #9.,R3          ;CNT GROUPS OF 14 LOCS

1$:     MOV     #REFI1,R5       ;POINT TO BLKO TABLE
        JSR     PC,$RFMAK       ;BUILD 14 BLKO'S
        JSR     R5,LOAD         ;LOAD AC'S
        .WORD   1
        .WORD   -15.
        .WORD   REFI1
        JSR     R5,RUNPR1       ;DO IT
        .WORD   1               ;STARTING ADDRESS
        DEC     R3      
        BNE     1$              ;CONTINUE

        MOV     #REFI2,R5       ;POINT TO LAST 2 BLKO'S
        JSR     PC,$RFMAK       ;BUILD LAST 2
        JSR     R5,LOAD         ;LOAD THEM
        .WORD   15
        .WORD   -3
        .WORD   REFI2
        JSR     R5,RUNPR1       ;DO IT
        .WORD   15              ;STARTING ADDRESS

        REGRST
        RTS     R5

$RFMAK: JSR     PC,$RFBYT       ;GET DATA DIGIT
        JSR     PC,$RFMOD       ;PUT DATA ADDRESS IN BLKO
        INC     $RFADR          ;UP RAM ADDRESS
        ADD     #5,R5           ;NEXT BLKO
        CMP     R5,#REFI2+5.
        BLE     $RFMAK          ;DO MORE
        RTS     PC


;SEQ350

$RFMOD: MOV     $RFADR,R0       ;GET RAM ADDR
        ASL     R0
        ASL     R0
        MOVB    R0,(R5)
        SWAB    R0
        MOVB    R0,1(R5)        ;PUT IN ADDRESS

        SWAB    R2              ;SWAP DATA
        ASR     R2
        BISB    R2,1(R5)        ;BIT 20
        SWAB    R2
        MOVB    R2,2(R5)        ;BITS 18,19
        RTS     PC

$RFBYT: TST     $RFCNT          ;NEED A WORD?
        BNE     1$              ;IF NOT
        MOV     (R4)+,R1        ;GET 5 DATA DIGITS
        ROL     R1              ;LEFT JUSTIFY
        MOV     #5,$RFCNT       ;SET COUNT

1$:     CLR     R2
        CLC
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2              ;NOW R2 HAS NEW DATUM
        DEC     $RFCNT          ;COUNT IT
        RTS     PC


$REFPT: .WORD   0               ;REFILL DATA TABLE PTR
$RFCNT: .WORD   0               ;DIGIT COUNTER
$RFADR: .WORD   0               ;REFILL RAM ADDRESS CTR


;SEQ291

REFI1:  .REPT   12.
        IO10    BLKO APR,,0
        .ENDR

























REFI2:  .REPT   2.
        IO10    BLKO APR,,0
        .ENDR






        I10     JRST 4,,17


        .EVEN


;SEQ292

.REM    %
CRRSTD - ROUTINE TO LOAD STANDARD REFILL CODE
%
CRRSTD: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,REF1
        .WORD   REFSTD          ;PTR TO STANDARD TABLE
        RTS     R5

;CACHE REFILL RAM DATA TABLE FOR STANDARD CACHE OPERATION

REFSTD: .WORD   01234
        .WORD   56731
        .WORD   23212
        .WORD   37127
        .WORD   11276
        .WORD   56755
        .WORD   67032
        .WORD   30223
        .WORD   01234
        .WORD   56707
        .WORD   77000
        .WORD   74666
        .WORD   44643
        .WORD   13311
        .WORD   13077
        .WORD   70007
        .WORD   01234
        .WORD   56745
        .WORD   57454
        .WORD   70122
        .WORD   01210
        .WORD   56605
        .WORD   60456
        .WORD   54564
        .WORD   01234
        .WORD   56700




;SEQ353

.REM    %
CRRONE - ROUTINE TO LOAD A CACHE USE ALGORITHM TO ACCESS ONLY ONE
CACHE.
%
CRRONE: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LDREF1       ;LOAD CODE
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   2               ;STARTING ADDRESS
        RTS     R5              ;RETURN

LDREF1: PUSH    R1

        ROR     R0              ;POSITION CACHE TO USE
        ROR     R1              ;
        BIC     #177774,R0      ;
        MOV     R0,USEADR+2     ;PUT IN INDEX WORD
        BIC     #77777,R1       ;
        MOV     R1,USEADR       ;
        POP     R1

        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -6
        .WORD   USEADR
        RTS     R5

USEADR: WD36    0,0,0

        IO10    BLKO APR,,0,1   ;LOAD AN ADDRESS

        I10     ADDI AC1,,4     ;NEXT ONE
    
        I10     TRNE AC1,,774   ;DONE?

        I10     JRST,,,2        ;NO, LOOP AGAIN

        I10     JRST,4,,2       ;YES, HALT


;SEQ294

.SBTTL          CACHE SWEEP ROUTINES
        
.REM    %
INVAL - INVALIDATES THE CACHE.
%
INVAL:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CSHSWP
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   1               ;STARTING ADDRESS
        RTS     R5              ;RETURN

CSHSWP: IO10    DATAI CCA,,0


        IO10    CONSZ APR,,200000

        I10     JRST,,,2


        I10     JRST,4,,1



;SEQ354
 
.REM    %
VALCOR - VALIDATES CORE
%
VALCOR: MOV     R5,BRKPC                ;SAVE PC
        JSR     R5,LOAD                 ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CORVAL
        JSR     R5,RUNPR1               ;RUN IT
        .WORD   1                       ;STARTING ADDRESS
        RTS     R5                      ;RETURN
 
CORVAL: IO10    BLKO CCA,,0
        IO10    CONSZ APR,,200000
        I10     JRST,,,2
        I10     JRST,4,,1
        .EVEN
 

;SEQ355

.SBTTL          DEPOSIT & EXAMINE ROUTINES
.REM    %
SPCEXM - THIS SUBROUTINE PERFORMS MUCH THE SAME FUNCTION AS AN
EXAMINE.  DOES NOT USE THE PI SYSTEM.  DOES ESUPPORT FUNCTION
BREAKPOINTS.  KL ADDRESS POINTER IN R0 ( 18 BITS).  RETURNS 11
DATA POINTER IN R0.
%
SPCEXM: MOV     R5,BRKPC        ;SAVE PC
SPEXM1: PUSH    <R2,R1,R0>

        JSR     R5,READ17               ;GET & CLEAR AC17
        MOV     R0,R1           ;BUFFER ADDRESS
        POP     R0
        BCS     3$              ;ERROR
        MOVB    (R0)+,FRMEM     ;16 BITA RO MOCW SSEWAA
        MOVB    (R0)+,FRMEM+1  ;
        MOVB    (R0),R2         ;GET UPPER 2 BITS
        BIC     #177774,R2      ;
        BNE     1$              ;ADDRESS = 17?
        CMP     FRMEM,#17       ;
        BEQ     2$              ;YES, BYPASS MOVE
        
1$:     BIC     #3,FRMEM+2      ;
        BIS     R2,FRMEM+2      ;UPPER 2 TO ADDRESS
        MOV     #FRMEM,R0      ;
        JSR     R5,XQT1         ;PUT DATA IN AC17
        BCS     3$              ;ERROR
        MOV     #HDWEXA,R0      ;
        EXCT                    ;DO A SUB AC17,17
        BCS     3$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXMBUF,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT DATA IN BUFFER
2$:     MOV     #EXAREA,R0      ;
        JSR     R5,LOAD17       ;RESTORE AC17
        MOV     R1,R0           ;DATA POINTER TO R0
3$:     POP     <R1,R2>
        RTS     R5              ;RETURN
FRMEM:  I10     MOVE,AC17,,0
        .EVEN
EXMBUF: WD36    0,0,0
        .EVEN


;SEQ356

.REM    %
SPCDEP - THIS SUBROUTINE PERFORMS MUCH THE SAME FUNCTION AS A
DEPOSIT.  DOES NOT USE THE PI SYSTEM.  DOES SUPPORT FUNCTION BREAKPOINTS.
KL ADDRESS POINTER IN R1 ((18 BITS).  KL DATA
POINTER TIN R0.
%
SPCDEP: MOV     R5,BRKPC                ;SAVE PC
SDEP1:  PUSH    R0

        MOVB    (R1)+,TOMEM     ;ADDRESS TO MOVEM
        MOVB    (R1)+,TOMEM+1   ;
        MOVB    (R1),R1 ;
        BIC     #177774,R1      ;
        BNE     1$              ;ADDRESS - 177
        CMP     TOMEM,#17       ;
        BNE     1$              ;NO
        POP     R0              ;YES, USE LOAD17

        BR      2$              ;
1$:     BICB    #3,TOMEM+2      ;
        BISB    R1,TOMEM+2      ;UPPER 2 TO ADDRESS
        JSR     R5,READ17       ;SAVE AC 17
        POP     R0

        BCS     3$              ;ERROR
        JSR     R5,LOAD17       ;DATA TO AC17
        BCS     3$              ;ERROR
        MOV     #TOMEM,R0       ;
        JSR     R5,XQT1         ;DO MOVEM
        BCS     3$              ;ERROR
        MOV     #EXAREA,R0      ;POINT TO AC17 BUFFER
2$:     JSR     R5,LOAD17       ;STORE OR RESTORE AC17
3$:     RTS     R5              ;RETURN

TOMEM:  I10     MOVEM AC17,,0

        .EVEN

;SEQ357
 
.REM    %
LOAD17 - LOADS AC17 WITH DATA POINTED TO BY R0.
%
LOAD17: PUSH    R1
        MOVB    (R0)+,RHALF     ;20-35 TO HRRI
        MOVB    (R0)+,RHALF+1
        MOVB    (R0),R1
        BIC     #177774,R1
        BIC     #3,RHALF+2      ;18  & 19 TO HARRI
        BIS     R1,RHALF+2
        MOVB    (R0)+,SCRWD
        MOVB    (R0)+,SCRWD+1
        MOV     SCRWD,R1
        MOVB    (R0),R0
        ROR     R0              ;POSITION 0-17
        ROR     R1

        ROR     R0
        ROR     R1
        MOV     R1,LHALF                ;2-17 TO HRLI
        BIC     #177774,R0
        BIC     #3,LHALF+2      ;0 & 1 TO HRLI
        BIS     R0,LHALF+2
        MOV     #RHALF,R0
        EXCT                    ;LOAD AC17 RIGHT
        BCS     1$              ;ERROR
        MOV     #LHALF,R0
        EXCT                    ;LOAD AC17 LEFT
1$:     POP     R1
        RTS     R5              ;RETURN
 
RHALF:  I10     HRRI AC17,,0
        .EVEN
LHALF:  I10     HRLI AC17,,0
        .EVEN
 
        .SBTTL CHANNEL UTILITY SUBROUTINES  11-DEC-75

.REM    %
        ROUTINE TO CONDITION THE EPT FOR A CHANNEL.  CHANNEL IN
R0; DATA POINTER IN R1.  CLEARS STATUS WORD 1.
%
SETEPT: MOV     R5,BRKPC                ;SAVE PC FOR FN. BREAK
        SL      R0,2            ;CHANNEL * 4
        MOVB    R0,EBRADR       ;TO ADDRESS LOWER
        MOV     EBRFLG,R0               ;GET EPT BASE PAGE
        ASL     R0              ;POSITION AT 1K BOUNDARY
        MOV     R0,EBRADR+1     ;PUT IN ADDRESS
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        MOV     R1,R0           ;DATA POINTER
        MOV     #EBRADR,R1      ;ADDRESS
        DPOSVR                  ;DEPOSIT & VERIFY
        BCS     1$              ;ERROR
        INCB    EBRADR          ;EPT +1
        MOV     #ZERO..,R0      ;
        DPOS                    ;CLEAR IT
        TSTB    CSHCLR          ;EBR SET?
        BEQ     SETEBR          ;NO, SET IT
1$:     RTS     R5              ;RETURN
.REM    %
        SUBROUTINE TO SET THE EBR TO THE VALUE IN EBRFLG.
ALSO SETS CACHE LOOK & LOAD IF CSHFLG SET.
%
SETEBR: MOV     EBRFLG,CSHCLR   ;NO, SET EBR DEFAULT
        MOV     EBRFLG,CSHALW   ;
        TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO, JUST SET ERR
        XQT     CSHALW          ;YRS, ALSO SET LOOK & LOAD
        BR      2$              ;
1$:     XQT     CSHCLR          ;SET EBR TO DEFAULT
2$:     RTS     R5              ;RETURN
CSHCLR: IO10    CONO PAG,,0     ;MUST BE EVEN ADDRESS
EBRADR: WD22    0               ;MUST BE ODD ADDRESS
EBRFLG: .WORD   0               ;MUST BE EVEN ADDRESS


;SEQ519

.REM    %
        ROUTINE TO READ THE CCW ADR.  RETURNS A POINTER TO THE
22-BIT VALUE IN R0.
%
CCWRD:  PUSH    R1
        CLR     ADRL            ;CLEAR ADDRESS BUFFER
        CLR     ADRH            ;
        MOV     #173,R1         ;FIRST DIAG FUNCTION
        JSR     PC,CCWCHA       ;GET BITS 30-35
        SWAB    R0              ;POSITION
        ASR     R0              ;
        BIC     #177700,R0      ;CLEAR GARBAGE
        BIS     R0,ADRL         ;PUT IN ADDRESS BUFFER
        JSR     PC,CCWCHA       ;GET BITS 24-39
        SR      R0,3            ;POSITION
        BIC     #170077,R0      ;CLEAR GARBAGE
        BIS     R0,ADRL         ;PUT IN ADDRESS BUFFER
        JSR     PC,CCWCHA               ;GET BITS 18-23
        ASL     R0              ;POSITION
        ROL     R0              ;UPPER 2 TO ADRH
        ROL     ADRH            ;
        ROL     R0              ;
        ROL     ADRH            ;
        BIC     #7777,R0        ;CLEAR GARBAGE
        BIS     R0,ADRL         ;REST TO ADRL
        JSR     PC,CCWCHA       ;GET BITS 14-17
        SWAB    R0              ;POSITION
        ASL     R0              ;
        BIC     #177703,R0      ;CLEAR GARBAGE
        BIS     R0,ADRH         ;PUT IN BUFFER
        MOV     #ADRL,R0                ;POINT TO BUFFER
        POP     R1
        RTS     R5              ;RETURN
CCWCHA: MOV     R1,R0           ;GET CURRENT DIAG FN.
        DFRD                    ;DO DIAG READ
        MOV     @.DAT2,R0               ;GET RESULT
        INC     R1              ;NEXT FUNCTION
        RTS     PC              ;5-19 IN R0


;SEQ520

.REM    %
        ROUTINE TO PERFORM A CBUS SELECT.  CHECKS FOR CBUS SEL
XE & STEPS THE CLOCK UNTIL IT BECOMES TRUE.  R0 EQUALS THE
CHANNEL NUMBER.  SETS THE C-BIT IF TIMEOUT.
%
CHSEL:  PUSH    <R1,R2>
        BIC     #177770,R0      ;ONLY LEGAL CHANNELS
        ADD     #170,R0         ;MAKE INTO DIAG READ FN.
        MOV     R0,R1           ;SAVE FUNCTION
        DFXCTT                  ;STOP THE CLOCK
                STPCLK          ;
        MOV     #48.,R2         ;MAX CLOCK COUNT
1$:     DFRDT           ;READ FUNCTION 170
                170             ;
        TBIT    11              ;TEST CH T0
        BEQ     2$              ;NOT SET
        MOV     R1,R0           ;
        DFRD                    ;READ PROPER FUNCTION
        TBIT    12              ;TEST CBUS SEL XE
        BNE     3$              ;MATCH?
2$:     JSR     R5,MEMTST       ;NO, STEP CLOCK
        DEC     R2              ;TIMEOUT?
        BGT     1$              ;NO, TRY AGAIN
        SEC                     ;SET C-BIT
3$:     POP     <R2,R1>
        RTS     R5              ;RETURN


;SEQ521

.REM    %
        ROUTINE TO GET TO POINT IN CHANNEL TIMING WHERE C-BUS
REQUESTS SHOULD APPEAR.  THIS IS 12 TICKS AFTER THE C-BUS SEL.
(D TIME).  R0 EQUALSA THE CHANNEL NUMBER.  SETS THE C-BIT IF
TIMEOUT.
%
CHSELD:         BIC     #177770,R0      ;ONLY LEGAL CHANNELS
        ASL     R0              ;CHANNEL * 2
        JMP     DSELCT(R0)      ;DISPATCH
DSELCT: BR      CH0D
        BR      CH1D
        BR      CH2D
        BR      CH3D
        BR      CH4D
        BR      CH5D
        BR      CH6D
        BR      CH7D
CH0D:   MOV     #3,R0           ;CBUS SEL = 3
        JMP     CHSEL           ;
CH1D:   JSR     R5,TST8A                ;4,5 THIS SCAN?
        BNE     1$              ;NO, 6,7
        MOV     #4,R0           ;CBUS SEL = 4
        JMP     CHSEL           ;
1$:     MOV     #6,R0           ;CBUS SEL = 6
        JMP     CHSEL           ;
CH2D:   JSR     R5,TST8A        ;4,5 THIS SCAN?
        BNE     1$              ;NO, 6,7
        MOV     #5,R0           ;CBUS SEL = 5
        JMP     CHSEL           ;
1$:     MOV     #7,R0           ;
        JMP     CHSEL           ;
CH3D:   CLR     R0              ;CBUS SEL = 0
        JMP     CHSEL           ;
CH4D:   MOV     #1,R0           ;CBUS SEL = 1
        BR      CH4.5D  ;
CH5D:   MOV     #2,R0           ;CBUS SEL = 2
CH4.5D: JSR     R5,CHSEL                ;SELECT IT
        BCS     1$              ;EXIT IF TIMEOUT
        JSR     R5,TST8A        ;4,5 LAST SCAN?
        BNE     1$              ;YES
        JSR     R5,SCAN1        ;NO, DO 1 SCAN
1$:     RTS     R5              ;RETURN
CH6D:   MOV     #1,R0           ;CBUS SEL = 1
        BR      CH6.7D          ;
CH7D:   MOV     #2,R0           ;CBUS SEL = 2
CH6.7D: JSR     R5,CHSEL                ;SELECT IT
        BCS     1$              ;EXIT IF TIMEOUT
        JSR     R5,TST8A                ;6,7 LAST SCAN?
        BEQ     1$              ;YES
        JSR     R5,SCAN1        ;NO, DO 1 SCAN
1$:     RTS     R5              ;RETURN

TST8A:  DFRDT           ;TEST CCW SEL 8A


;SEQ522

                175             ;
        TBIT    13              ;
        RTS     R5              ;RETURN WITH COND

.REM    %
        ROUTINE TO GENERATE A CBUS COMMAND.  ACCEPTS THE
COMMAND WORD IN T1 & GENERATES IT FOR 4 CLOCKS.  FAST MODE
MAY ALSO BE SET OR CLEARED.
%
CSIM:   PUSH    <R2,R1>
        MOV     #LDCHAN,R0      ;DO FUNCTION
        DFWRT                   ;
        MOV     #4,R2           ;STEP CLOCK 4 TIMES
        TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     1$              ;YES
        MOV     R2,R0           ;NO, BURST CLOCK
        JSR     R5,BRST1                ;NO, BURST CLOCK
        BR      2$              ;
1$:     JSR     R5,MEMTST       ;
        DEC     R2              
        BGT     1$
2$:     MOV     #MODES+2,R1     ;FAST MODE BUFFER AREA
        MOV     (SP),R0         ;GET FUNCTION DONE
        MOVB    2(R0),(R1)      ;FAST TO BUFFER
        BIC     #177677,(R1)    ;CLEAR EXTRA BITS
        DFWRTT          ;CLEAR ALL EXCEPT FAST
                MODES           ;
                LDCHAN          ;
        POP     <R1,R2>
        RTS     R5              ;RETURN

MODES:  .WORD   0,0,0           ;BUFFER AREA


;SEQ523

.REM    %
        GENERATES A SLOW RQ FOR THE CHANNEL IN R0.
%
SLOWRQ: JSR     R5,CHSEL                ;GET TO CBUS SELECT
        BCS     3$              ;TIMEOUT
        PUSH    <R1,R2>

        MOV     #8.,R2          ;STEP CLOCK 8 TIMES
        TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     1$              ;YES
        MOV     R2,R0           ;NO, BURST CLOCK
        JSR     R5,BRST1
        BR      2$              ;
1$:     JSR     R5,MEMTST               ;
        DEC     R2              ;
        BGT     1$              ;
2$:     MOV     #SLOW,R1                ;SLOW BIT POINTER
        JSR     R5,CSIM ;SIMULATE COMMAND
        POP     <R2,R1>
        CLC                     ;
3$:     RTS     R5              ;RETURN
SLOW:   WD36    0000,4000,0000
.EVEN


;SEQ524

.REM   %
        ROUTINE TO SIMULATE A REQUEST FOR CHANNEL R0.  THE EBUS
DATA IS POINTED TO BY R1.  SETS THE C-BIT IF THE CORRECT CHANNEL
CANNOT BE SELECTED.  RETURNS THE POINTER TO MEMORY REQUEST DATA
IN R0 IF A MEMORY CYCLE WAS INITIATED.
%
SIMBUS: MOV     R5,BRKPC                ;SAVE PC
        PUSH    R2
        MOV    R0,R2           ;
        DFXCTT                  ;STOP THE CLOCK
                STPCLK          ;
        MOV     R2,R0           ;
        CLR     MEMRQ           ;CLEAR MEM RQ FLAG
        CLR     R2              ;CLEAR SLOW RQ FLAG
        BITB    #BIT7,2(R1)
        BEQ     1$              ;NO
        PUSH    R0

        JSR     R5,SLOWRQ               ;GENERATE IT
        POP     R0

        BCS     3$              ;TIMEOUT
        TSTB    3(R1)           ;ANY OTHER REQUESTS?
        BEQ     2$              ;NO
        INC     R2              ;YES, SET FLAG
        BICB    #BIT7,2(R1)     ;CLEAR SLOW RQ BIT
1$:     JSR     R5,CHSELD       ;GET TO D-TIME
        BCS     2$              ;TIMEOUT
        JSR     R5,CSIM         ;SIMULATE REQUEST
        TST     R2              ;SLOW REQUEST?
        BEQ     2$              ;NO
        BISB    #BIT7,2(R1)     ;YES, RESTORE IT
2$:     MOV     MEMRQ,R0                ;GET MEM STATUS
3$:     POP     R2
        RTS     R5              ;RETURN


;SEQ525

        ;STEPS THE CLOCK.  TESTS FOR LEADING EDGE OF RQ HOLD
        ;IF TRCMEM SET.  GETS MEM STATUS IF EVENT DETECTED.

MEMTST: TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     TSTMEM          ;YES, TRACE
        JSR     R5,STEP1                ;STEP THE CLOCK
        RTS     R5              ;RETURN
TSTMEM: MOV     RQHOLD,R0       ;TEST FOR SBUS ADR HOLD
        JSR     R5,EVENT1       ;
        BCS     1$              ;NO MEM REF
        JMP     GETMEM          ;GET MEM STATUS
1$:     CLR     R0              ;
        RTS     R5              ;RETURN

        ;EITHER BURSTS THE CLOCK 24 TIMES OR SINGLE STEPS THE
        ;CLOCK 24 TIMES WHILE TESTING FOR A MEMORY REFERENCE.
SCAN1:  TST     TRCMEM          ;ASELECT PRINT MEMORY?
        BEQ     2$              ;NO, DONT TRACE
        PUSH    R2              
        MOV     #24.,R2         ;CLOCK COUNT
1$:     JSR     R5,TSTMEM               ;CHECK FOR MEM REF
        DEC     R2              ;
        BGT     1$              ;DONE?
        POP     R2              ;YES
        BR      3$              ;
2$:     MOV     #24.,R0 ;BURST CLOCK 24
        JSR     R5,BRST1        ;
3$:     RTS     R5              ;RETURN

TRCMEM: .WORD   0               ;MEMORY TRACE FLAG
RQHOLD: S10.    162,31,1                ;SBUS ADR HOLD
 
;SEQ366

.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
  }@)