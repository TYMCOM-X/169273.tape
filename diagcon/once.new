TITLE	ONCE - ONCE ONLY OPERATOR DIALOGUE AND I/O DEVICE INITIALIZATION V664
SUBTTL	T. HASTINGS/CHW/RCC/AF/DAL	11 FEB 77
	SEARCH	F,S
	$RELOC
	$LOW
;***COPYRIGHT 1973,1974,1975,1976,1977 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***
XP VONCE,664
		;PUT VERSION NUMBER IN GLOB LISTING AND LOADER STORAGE MAP



;"ONCE" SHOULD BE THE LAST LOADED PROGRAM (AFTER SYSMAK AND DDT)

; THUS IF IT OVERFLOWS INTO THE USER AREA NO HARM IS DONE.
;HOWEVER, SINCE THE DISK REFRESHING ROUTINES HAVE NOW
; BEEN MADE INTO SEPARATE SUBPROGRAMS FOR LEVEL C
; (FHDREF, MDFREF, DPDREF, ETC.), THEY MAY BE LOADED FOLLOWING ONCE.
;HOWEVER, HOWEVER, UNDER LEVEL D, "ONCE" MUST BE LOADED AFTER
; REFSTR AND ONCMOD SINCE ONCEND IS USED AS THE STARTING ADDRESS OF
; FREE CORE USED BY DATA STUCTURES CREATED DURING ONCE TIME.


;ONCE ONLY CODE IS DIVIDED INTO 3 PARTS
; 1. MANDATORY ONCE ONLY (LINKSR) - NO CTY NEEDED
;	(GOOD FOR REPEATED STARTUPS DURING DEBUGGING)
; 2. USUAL SHORT ONCE ONLY CODE (ONCE) - CTY FOR DATE AND TIME
; 3. OPTIONAL ONCE ONLY CODE - CTY DIALOG TO CHANGE MONITOR
;	OR REFRESH DISK(S) - (ALT-MODE INSTEAD OF CR AFTER TIME)
;INITIALIZE PRIORITY CHANNELS AND SETUP INTERRUPT SERVICE ROUTINE CHAIN

;LINK TO SERVICE ROUTINES

INTERNAL LINKSR,FT2REL,ONCEND
EXTERNAL JOBSYM,DEVLST,LINKDB,ONCPDL,MPTRAP,CPUN,CTYTYP,SYSDSP

LINKSR:	0			;CALLED WITH JSR FROM SYSINI
	SKIPN	JRSTI1		;BEEN THROUGH JRSTI1 ALREADY?
	JSR	JRSTI1		;SETUP LOCS 40 THRU 61 & TEST FOR 2 RELOC HARDWARE
	MOVEI	P,ONCPDL

IFN FTDISK, <

;INITIALIZE DISK(S)

	EXTERNAL FILMAN
	PUSHJ	P,FILMAN	;INITIALIZE ALL DISK(S)
				; BEFORE OVERWRITING ONCE WITH DDB'S
>
	MOVE	T1,JRSTI
	MOVEM	T1,LINKSR+1	;DO ONCE ONLY
	SKIPN	DEVLST		;HAVE DEVICE DATA BLOCKS BEEN LINKED ?
	JRST	LINKDB		;NO, GO LINK DATA BLOCKS
				;RETURN @LINKSR
				;MULTIPLE DEVICE DATA BLOCKS ARE CREATED
				;AS SPECIFIED BY SYSSIZ AND MAY ERASE PART
				;OF ONCE ONLY CODE
JRSTI:	JRST	@LINKSR		;YES, RETURN

;CODE TO SET MONITOR FOR DEBUGGING SESSION WITH EXEC DDT
;MAKE STARTUP BE FAST
;SYSTEM PROGRAMMER TYPES DEBUG$G OR DEBUG$X TO START MONITOR
;ALLOW SAME COPY OF MONITOR TO BE USED FOR REGULAR SYSTEM
;SIMPLY BY NOT STARTING AT DEBUG.
DEBUG=:<JRST .>

	MOVEI	T1,DDTEND##	;END OF DDT
	HRRM	T1,PATSIZ	;INCLUDE DDT IN SYSTEM SIZE
IFN FTLOCK,<
	MOVEI	T1,0		;NO LIMIT TO AMOUNT OF LOCKED CORE
	HRRM	T1,LOKLIM##	;
>
	SKIPA	T1,.+1		;OPR

;PATCH DDTOPR - SIXBIT OPR FOR DEBUGGING
DDTOPR:	SIXBIT	/CTY/		;ASSUME CTY - PATCH TO OTHER
	MOVEM	T1,DEVOPR##	;OPR SIXBIT NAME

	MOVSI	T1,400000	;
	IORM	T1,DEBUGF	;FLAG DEBUGGING MODE
				; SO WHY RELOAD, LONG DIALOG
				; UNITS OFF-LINE NOT ASKED
				;ALSO, CHANGES .SET CORMIN TO JUMP TO EDDT.
				; RETURN IS BY GOBACK$G OR GOBACK$X
				;ALSO, NOTICES 21 NON-ZERO (OR S.S.6 ON KI-10)
				;  RETURN IS BY GOBACK$G OR GOBACK$X
IFN FTBOOT,<
	MOVSI	T1,(DF.NAR)	;NO AUTO RELOAD IF WE USE
	IORM	T1,DEBUGF##	; DEBUG$G
>
	MOVEI	T1,ST.NRT	;TURN OFF REMOTE
	IORM	T1,STATES##	;TTY'S
	MOVSI	T1,TTVRMT##
	MOVEI	T2,TCONLN##
	ANDCAM	T1,LINTAB##(T2)	;MAKE SURE CTY ISN'T REMOTE IF DEBUGGING
	JRST	SYSDSP##	;START UP SYSTEM (400)
IFN FTBOOTRD,< ;ONLY IF WE DO THE AUTO RELOAD
;SUBROUTINE TO BUILD UP COMMAND STRING FOR BOOTS
;
BOOTFX:
	MOVEI	U,ONCEND+40000	;FIRST PAGE TO LOOK IN
	ANDI	U,740000	;CLEAR LOW BITS
IFE FTKL10,<
	ADDI	U,36000		;OFFSET FROM START OF BLOCK TO START OF
				; BOOTS.
>
IFN FTKL10,<
	ADDI	U,34000	;RH20 BOOTS STARTS AT XX4000
>
	MOVEI	R,0		;ASSUME NO BOOTS
	MOVEI	T2,CORBLK##
	LSH	T2,P2WLSH##
BOOTLP:	PUSHJ	P,REFMEM##
	CAMN	T1,[CONO APR,200000] ;IS THIS BOOTS?
	MOVE	R,U		;YES--REMEMBER THE PLACE
IFN FTKL10,<
	TRNN	U,3000
	ADDI	U,1000
>
	ADDI	U,1000
	TRNE	U,2000
	JRST	BOOTLP
IFE FTKL10,<
	ADDI	U,36000		;NO--STEP TO NEXT 16K BLOCK
>
IFN FTKL10,<
	ADDI	U,34000
>
	CAMGE	U,T2		;DID WE FALL OFF THE END
	JRST	BOOTLP		;NO--KEEP LOOKING
IFN FTKA10!FTKI10,<
	CONO	APR,NXM##	;CLEAR NXM FLAG SINCE WE MAY HAVE SET IT
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM
>
	JUMPE	R,CPOPJ		;EXIT IF NO BOOTS ELSE R CONTAINS THE
				; ADDRESS OF THE HIGHEST BOOTS IN CORE. WE
				; USE THE HIGHEST TO AVOID FINDING A
				; MATCH IN THE SYMBOL TABLE.
	SUBI	R,1000		;POINT TO DATA PAGE
	MOVE	U,R
BOOTOK:	ADDI	U,140		;ANY DEVICE?
	PUSHJ	P,REFMEM##
	MOVEM	T1,DEVICE
	ADDI	U,1		;FILE NAME
	PUSHJ	P,REFMEM##
	MOVEM	T1,FNAME
	ADDI	U,1		;EXTENSION
	PUSHJ	P,REFMEM##
	HLLZM	T1,FEXT
	ADDI	U,1		;PPN
	PUSHJ	P,REFMEM##
	MOVEM	T1,PPN
CPOPJ:	POPJ	P,		;DONE
BSTRNG:	JUMPE	R,CPOPJ		;RETURN IF COULDN'T FIND BOOTS
	MOVEI	T1,BOOTYO	;ROUTINE TO BUILD UP STRING
	MOVEM	T1,COMTOA##	; SAVE AS TTY OUTPUT ROUTINE
	MOVE	T1,[POINT 7,BOOTXT##] ;BYTE POINTER
	MOVEM	T1,BOOTBP	;STORE THE POINTER
	MOVEI	T1,[ASCIZ ./D .];FIRST DO A DUMP
	PUSHJ	P,CONMES##	; ..
	SKIPN	T2,DEVICE	;A DEVICE SPECIFIED?
	POPJ	P,		;NO, LEAVE DEFAULT ALONE
	PUSHJ	P,PRNAME##	;YES--PUT IN COMMAND STRING
	MOVEI	T1,[ASCIZ /:/]	;DELIMIT WITH A COLON
	PUSHJ	P,CONMES##	; ..
BSTRN1:	SKIPN	T2,FNAME	;FILE NAME?
	JRST	BSTRN2		;NO
	PUSHJ	P,PRNAME##	;PUT IN NAME
	HLLZ	T2,FEXT		;PICK UP EXTENSION
	JUMPE	T2,BSTRN2	;NONE--LOOK FOR PPN
	LSH	T2,-6		;PUT IN A DOT
	TLO	T2,(16B5)	; ..
	PUSHJ	P,PRNAME##	;TOSS IN EXT
BSTRN2:	SKIPN	PPN		;A PPN?
	JRST	BSTRN3		;NO
	PUSHJ	P,PRLBK##	;FIRST A BRACKET
	HLRZ	T1,PPN		;GET PROJECT
	PUSHJ	P,PRTDI8##	;PRINT IN OCTAL
	PUSHJ	P,PRCOM##	;ADD A COMMA
	HRRZ	T1,PPN		;GET PROG NUMBER
	PUSHJ	P,PRTDI8##	;PRINT PROG
	PUSHJ	P,PRRBK##	;ADD IN RIGHT SQUARE BRACKET
BSTRN3:	MOVEI	T3,15
	IDPB	T3,BOOTBP
	MOVEI	T3,0
	IDPB	T3,BOOTBP
	POPJ	P,0

BOOTYO:	IDPB	T3,BOOTBP	;STORE BYTE IN STRING
	POPJ	P,0		;RETURN

BOOTBP:	POINT	7,BOOTXT##	;RELOAD STRING POINTER

> ;END FTBOOTRD
;ONCE ONLY CODE - OPERATOR SETUP DIALOGUE

	DEFINE	SETTYO <PUSHJ P,OTSET>
	DEFINE	TYPE <PUSHJ P,COMTYO##>
	DEFINE	NEXTC <PUSHJ P,COMTYI##>

PATSYS::MOVEI	P,0		;FLAG NO P.D.L.
	JSR	PATFIX		;HERE ON 406 START (SYSIN2-COMMON)
	JRST	JSR2##		;  & SKIP DIALOG
PATFIX:	0			;ROUTINE TO FIXUP FOR PATCHES
	MOVE	T1,[RADIX50 4,PAT]
	MOVE	T2,DDTSYM	;FIND "PAT" GLOBAL
	CAMN	T1,(T2)		;IN SYMBOL TABLE
	JRST	GOTPAT		;YES
	AOBJN	T2,.+1		;ADVANCE
	AOBJN	T2,.-3		; ..LOOPING
	JRST	PATSIZ		;NOT FOUND
GOTPAT:	HRRZ	T1,1(T2)	;GET VALUE
	HRRZ	T2,PATSIZ	;CHECK WITH PATCHED INDICATION
	CAIGE	T1,(T2)		;USE MAX
PATSIZ::MOVEI	T1,PAT##	;SET SIZE OF SYSTEM TO BEGINING OF PATCH AREA IN CASE
	MOVEM	T1,SYSSIZ##	; ONCE ONLY DIALOG RESTARTED BEFORE OVERWRITTEN
				;PATSIZ SHOULD BE UPDATED EVERY TIME A PATCH IS MADE
	MOVEI	T2,$1B##	;SEE IF BKP TABLE EXISTS
	JUMPE	T2,PATNBK	;NO--HENCE NO BREAKPOINTS
	MOVSI	T2,-^D8		;SEE IF ANY
PATBKL:	ADDI	T2,2		;  BREAKPOINTS
	SKIPN	$1B##-2(T2)	;  ARE SET
	AOBJN	T2,PATBKL	;  ..
	JUMPGE	T2,PATNBK	;NO--OK TO PROCEED
	CAIL	T1,DDTEND##	;YES--SEE IF EDDT
	JRST	PATNBK		;YES--CONSISTENT SO PROCEED
;HERE WHEN BREAKPOINTS BUT NO EDDT
	JUMPE	P,PATKBK	;IF 406 START, KEEP EDDT
	MOVEI	T1,[ASCIZ /?BREAKPOINTS BUT NO EDDT
DO YOU WANT TO KEEP EDDT? (Y OR <CR>) /]
	PUSHJ	P,YESNO		;ASK QUES. GET ANSWER
	  JRST	.+2		;NO--REMOVE BREAKPOINTS
	JRST	PATKBK		;YES--KEEP EDDT
	MOVEI	T1,[ASCIZ /TYPE "$B 400$G"
/]
	PUSHJ	P,ICONM		;OUTPUT STATEMENT
	PUSHJ	P,OPOUT		;ISSUE IT
	XCT	SYSDDT##	;GO TO EDDT
	STOPCD	.,HALT,NED,	;++NO EXEC DDT
PATKBK:	MOVEI	T1,DDTEND##	;KEEP EDDT
	MOVEM	T1,SYSSIZ##
PATNBK:	MOVSI	T2,(CAI)
	CAIL	T1,DDTEND##	;SEE IF EDDT INTACT
	HLLM	T2,IOG5##	;YES--LEAVE 401 ALONE

	JRST	@PATFIX		

	ENTRY	ONCE
ONCE:	0
IFN FTKI10!FTKL10,<
	MOVEI	T1,PM.ACC+PM.WRT+NUPMPP##
	HRLM	T1,NLUPMP##+.MUPMP
	CLRPGT	(0)
>
	MOVEI	P,ONCPDL	;WE NEED A PUSH DOWN LIST
IFN FTBOOTRD,<
	PUSHJ	P,BOOTFX	;FIND OUT WHERE THE MONITOR WAS READ FROM
>	;END FTBOOTRD
IFN FT2SEGMON,<
HIDONE:	JFCL	HIGHIN		;PATCHED TO A JRST WHEN THE HIGH SEGMENT HAS
				; BEEN MAPPED (TO MAKE RESTARTS WORK)
IFE FTEXE,<
	PUSH	P,R		;SAVE THE ADDRESS OF BOOTS
	MOVE	T1,SYSTEM	;DEFAULT READ-FILE NAME
	SKIPN	FNAME		;NAME SUPPLIED?
	MOVEM	T1,FNAME	;NO. PLUG IN DEFAULT.
	PUSH	P,FEXT		;SAVE THE EXTENSION THAT THE OPR TYPED
	PUSH	P,DEVICE	;AND THE FILE NAME
	MOVSI	T1,(SIXBIT /SHR/)
	MOVEM	T1,FEXT		;TRY 'SHR' FIRST
	SETZB	S,P1		;ZERO ACS THAT ARE USED IN LOOKUP/READ
	PUSHJ	P,LOOK		;LOOKUP FNAME.SHR
	  CAIA			;NOT FOUND
	JRST	ONCE0		;FOUND, GO READ IT
	MOVSI	T1,(SIXBIT /HGH/)
	MOVEM	T1,FEXT		;TRY 'HGH'
	MOVE	T1,(P)		;GET THE DEVICE BACK
	MOVEM	T1,DEVICE	;DO THE LOOKUP ON THE DEVICE THE OPR SAID
	PUSHJ	P,LOOK		;TRY TO FIND FILE
	  PUSHJ	P,ERROR		;NOT FOUND, LOSE
ONCE0:	POP	P,DEVICE	;RESTORE THE DEVICE NAME THE OPR TYPED FOR
				; AUTO-RELOAD
	POP	P,FEXT		; AND THE EXTENSION
	MOVE	T1,LENGTH	;LENGTH OF THE FILE
	TRZE	T1,PG.BDY##	;ROUND UP TO A PAGE BOUNDARY
	ADDI	T1,PAGSIZ##	; ..
>;END IFE FTEXE
IFN FTEXE,<
	MOVEI	T1,MONTOP-MONORG  ;HIGHEST ADDRESS CONTAINING DATA IN THE HI SEG
	IORI	T1,PG.BDY##	;ROUND UP
	ADDI	T1,1		;LENGTH OF THE HIGH SEGMENT IN WORDS
>;END IFN FTEXE
	MOVEM	T1,SYSLEN##	;STORE THE LENGTH OF THE HIGH SEGMENT
>;END FT2SEGMON
	PUSHJ	P,SUNXMT	;SETUP NXMTAB AND FIND HIGHEST EXISTANT
				; PAGE IN MEMORY
IFN FTBOOT,<
	MOVSI	T1,(JFCL)	;PATCH OUT CALL TO SETUP NXMTAB TO READ IN
	MOVEM	T1,BNXMTS##	; BOOTS IF DEBUGGING
>				;END FTBOOT CONDITIONAL
IFN FT2SEGMON,<
	LSH	T4,W2PLSH##	;PAGE NUMBER OF HIGHEST EXISTANT PAGE
	MOVE	T1,T4
	TRZE	T1,PG.BDY##	;ROUND UP TO 256K BOUNDARY
	ADDI	T1,PP256K##
	IDIVI	T1,^D36
	MOVNI	T1,1(T1)	;NUMBER OF WORDS IN NXMTAB
	HRLI	T1,NXMTAB##
	MOVSM	T1,NXMPTR##	;STORE AOBJN POINTER
	MOVE	T1,T4		;WHERE TO PUT THE HIGHEST PAGE OF THE MONITOR
	IDIVI	T1,^D36		;WORD WITHIN NXMTAB
	MOVNS	T2		;BIT POSITION WITHIN NXMTAB
	SKIPN	T2		;EVEN MULTIPLE OF 36?
	SUBI	T1,1		;YES, BACK UP ONE
	MOVSI	T3,400000	;ASSUME AFTER A WORD BOUNDARY
	ROT	T3,1(T2)	;POSITION TO CORRECT BIT IN NXMTAB
	MOVEI	T2,MONORG-400000+MPGSIZ##  ;WHERE MAPPING OF THE MONITOR STARTS IN THE EXEC MAP
	ADD	T2,SYSLEN##	;HIGHEST WORD IN THE MONITOR RELATIVE TO THE EXEC MAP
	LSH	T2,W2PLSH##	;CONVERT TO HIGHEST PAGE
IFN FTKL10,<
	PUSH	P,T2		;SAVE TO MAP EPT (FOR RH20'S)
>
	MOVEI	T4,PM.ACC+PM.WRT!<IFN FTKL10,<PM.CSH>>-1(T4)
ONCE1:	TDNN	T3,NXMTAB##(T1)	;DOES THIS PAGE EXIST?
	JRST	ONCE3		;YES, SETUP THE MAP
ONCE2:	SKIPG	T3		;NO, NEXT PAGE (SKIP IF ON A WORD BOUNDARY)
	SUBI	T1,1		;ON A WORD BOUNDARY, BACK UP
	ROT	T3,1		;NEXT BIT IN NXMTAB
	SOJA	T4,ONCE1	;SEE IF NEXT PAGE EXISTS
ONCE3:	ROT	T2,-1		;PAGE NUMBER/2
	SKIPGE	T2		;EVEN OR ODD PAGE?
	JRST	[HRRM T4,.EPPM##(T2)
		JRST ONCE4]	;ODD
	HRLM	T4,.EPPM##(T2)	;EVEN, SETUP THE MAPPING
ONCE4:	ROT	T2,1		;RESTORE THE CURRENT PAGE NUMBER
	CAILE	T2,<MONORG>_-^D9-400
	SOJA	T2,ONCE2	;LOOP UNTIL DONE
	CLRPGT	(0)		;CLEAR THE A.M. SO PROCESSOR SEES THE NEW MAPPING
	ANDI	T4,17777	;LOWEST PAGE MAPPED
	LSH	T4,P2WLSH##	;CONVERT TO ADDRESS
	MOVEM	T4,SYSORG##	;STORE THAT AS THE ABSOLUTE ORIGIN OF THE
				; MONITOR
IFN FTKL10,<
	POP	P,T2		;RESTORE HIGHEST VIRTUAL ADDRESS
	AOS	T1,T2		;USE THE NEXT MAP SLOT
	ROT	T2,-1
	MOVEI	T3,PM.ACC+PM.WRT+PM.CSH+0
	SKIPGE	T2
	HRRM	T3,.EPPM##(T2)	;MAP THE EPT SO THAT RH20S CAN
	SKIPL	T2		; SET UP CHAN CNTRL WRDS IN EPT+0
	HRLM	T3,.EPPM##(T2)
	SETZ	P2,		;CHANGE ICWA ADDRESSES FOR RH20S SO
	ADDI	T1,400		;MAKE T1 POINT AT REAL PAGE
	PUSHJ	P,RH2INI##	; THAT THEY GO THROUGH THAT MAP SLOT
>
IFE FTEXE,<
	PUSHJ	P,RFILE		;READ THE HIGH SEGMENT
	POP	P,R		;RESTORE THE ADDRESS OF BOOTS
>;END IFE FTEXE

IFN FTEXE,<
	HRRZ	T1,JOBCOR##	;HIGHEST ADDRESS - 1 IN THE MONITORS LOW SEG
	ADD	T1,SYSLEN##	;HIGHEST ADDRESS - 1 IN THE MONITORS HI SEG
	LSH	T1,W2PLSH##	;CONVERT TO HIGHEST PAGE - 1
	MOVEI	T1,PM.ACC(T1)	;ALLOW READING
	HRRM	T1,.EPMP##+.MECKS
	HRRI	T1,MONORG	;STARTING VIRTUAL ADDRESS OF THE MONITORS HI SEG
	ADD	T1,SYSLEN##	;HIGHEST VIRTUAL ADDRESS IN MONITORS HI SEG
	HRRZ	T2,T1		;COPY THAT
	MOVE	T3,SYSLEN##	;LENGTH OF THE MONITORS HI SEG
	LSH	T3,W2PLSH##	;NUMBER OF PAGES IN THE MONITORS HI SEG
	HRLI	T1,.ECKSM	;BLT HIGH SEG FROM THIS V.A.
ONCE5:	CLRPGT	(0,.ECKSM)	;LET THE PROCESSOR KNOW ABOUT THE CHANGE IN THE MAP
	SUBI	T1,PAGSIZ##	;DESTINATION
	PUSH	P,T1		;SAVE ACROSS THE BLT
	BLT	T1,-1(T2)	;BLT A PAGE OF THE HIGH SEG FROM WHERE IT
				; WAS READ TO WHERE IT IS TO LIVE
	POP	P,T1		;RESTORE THE BLT POINTER
	SOS	.EPMP##+.MECKS	;POINT THE MAP AT THE NEXT LOWEST PAGE
	SUBI	T2,PAGSIZ##	;NEXT LOWEST PAGE BOUNDARY
	SOJG	T3,ONCE5	;LOOP UNTIL ALL HI SEG PAGES HAVE BEEN MOVED
	MOVSI	T1,(JRST)	;PREVENT ANOTHER ATTEMPT TO SETUP THE
	HLLM	T1,HIDONE	; MAPPING FOR THE HIGH SEGMENT
>;END IFN FTEXE
> ;END FT2SEGMON
HIGHIN:	PUSHJ	P,BSTRNG	;CONVERT ARGUMENTS TO BOOTS TO A STRING
				; FOR AUTO-RELOAD
IFN FTKL10,<
	PUSHJ	P,ONCINT	;START INTERVAL TIMER GIVING CLOCK TICKS
				; FOR ONCE, SET UP ONCKLT SO APRINT AND
				; OPRFIL CAN USE IT TO START UP TIMER AGAIN.
>;END IFN FTKL10
	SETTYO
	SKIPGE	DEBUGF##	;IF DEBUGGING DO NOT
	JRST	ONCE6		; DO SYSCHK
	HLRZ	T1,SYSCKI##
	CAIE	T1,(JSR)
	JRST	ONCE6
	MOVEI	P,ONCPDL##	;SET UP STACK
	MOVEI	T1,[ASCIZ /SYSCHK(N,Y):/]
	MOVEI	T2,[ASCIZ /NO ;DEFAULT ANSWER/]
	PUSHJ	P,ASKDEF	;ASK THE QUESTION
	  JRST	ONCE6		;JUST CR-LF
	PUSHJ	P,ALTM##
	PUSHJ	P,COMTYI##
	CAIN	T3,"Y"
	XCT	SYSCKI##
ONCE6:	MOVEI	P,ONCPDL
IFN FTCCLX,<
	MOVEI	T1,TTFCXI##
	SKIPGE	DEBUGF##
	SETZM	TTFCOM##(T1)
>
	SETTYO
	PUSHJ	P,CRLF
	JSR	MOVSTP		;MOVE .JSYM TO DDTSYM
	JSR	PATFIX
	MOVEI	T1,CONFIG##
	PUSHJ	P,CONMES##
	MOVEI	T1,[ASCIZ / /]
	PUSHJ	P,CONMES
	MOVEI	T1,SYSDAT##
	PUSHJ	P,CONMES
	PUSHJ	P,CRLF##	;ADD CRLF
	PUSHJ	P,OPOUT
;HERE TO DETERMINE IF THIS CPU IS A 166, KA10, OR
;  KI10 AND SETUP THE NUMBER OF CLOCK TICKS PER
;  SECOND ACCORDING TO POWER LINE FREQUENCY.
	EXTERN	M.TPS,TICSEC,TICMIN,STATES,MIDNIT,.C0TYP


	MOVEI	F,CT.P6		;ASSUME A 166 (PDP-6) PROCESSOR
	MOVEI	T4,M.TPS	;ASSUME LINE FREQUENCY UNKNOWN
				;EXCEPT FROM MONGEN
	JFCL	17,.+1		;CLEAR ALL FLAGS
	JRST	.+1		;SET PC CHANGE FLAG IF CPU IS A 166
	JFCL	1,CPU166	;BRANCH IF PDP-6
IFN FTKL10,<
	SETZ	T1,		;THE TEST FOR A KL10 PROCESSOR
	BLT	T1,0		;IS A NO-OP BLKT LEAVING AC NON-ZERO
	JUMPN	T1,CPKL10	;JUMP IF KL10
>
	HRLOI	T1,020640	;WE HAVE A KA OR KI, FIND ITS TYPE
	IBP	T1		; ..
	TLNN	T1,1		;SKAP IF KA10
	JRST	CPKI10		;NO--MUST BE KI10
;HERE IF CPU IS A KA10.  DETERMINE LINE FREQUENCY BY
;TIMING ROTATES
;DEPENDS ON:
;MAX. POWER LINE FREQUENCY VARIATION OF PLUS OR MINUS 2 HERTZ.
;SHIFT TIME IN KA10 OF 150NS. PLUS OR MINUS 5%

CPKA10:	MOVEI	F,CT.KA		;REMEMBER THIS IS A KA10
	CONSZ	TTY,20		;WAIT TILL TYPING THROUGH
	JRST	.-1		; BEFORE DOING CONO CLEAR
	MOVE	T1,[JSP 17,TIMEI0]
	MOVEM	T1,MPTRAP+2	;SETUP INTERRUPT LOCATION
	MOVE	T1,[ROT 17,377]	;19 MICROSECONDS IN SHIFT TIME
	MOVE	T2,[AOJA T1]
	PUSHJ	P,TIMEIT	;TIME ROTATE
	MOVE	T3,0		;SAVE THE RESULT
	MOVE	T1,[ROT 17,377-^D100] ;11.7 MICROSECONDS IN SHIFT TIME
	PUSHJ	P,TIMEIT	;TIME ROTATE
	MOVE	T1,0		;GET THE RESULT
	IMUL	T1,T3		;MULTIPLY BY PREVIOUS RESULT
	SUB	0,T3		;DIFFERENCE IN RESULTS
	IDIV	T1,0
	CAIL	T1,^D102406/4	;LESS THAN WORST CASE 60 HERTZ NO?
	CAILE	T1,^D146199/4	;OR GREATER THAN BEST CASE 50 HERTZ NO?
	JRST	CPU166		;YES, NOT WITHIN TOLERANCES.  USE MONGEN NO.
	CAIGE	T1,^D120922/4	;IN THE 60 HERTZ RANGE?
	JRST	HRTZ60		;YES, 60 HERTZ POWER LINE FREQUENCY
	CAIGE	T1,^D122100/4	;IN THE 50 HERTZ RANGE?
	JRST	CPU166		;NO, IN BETWEEN SO CAN'T TELL.  USE MONGEN NO.
	JRST	HRTZ50		;YES, 50 HERTZ POWER LINE FREQUENCY
;HERE IF KL10
IFN FTKL10,<
CPKL10:	APRID	T1		;READ SERIAL NUMBER
	ANDI	T1,7777		;MASK OUT UCODE VER
	MOVEM	T1,.C0ASN##	;SAVE AS REAL #
	MOVEI	F,CT.KL		;SET TYPE AS KL10
	JRST	CPU166		;NO CLOCK ON A KL
>;END FTKL10
;HERE IF CPU IS A KI10.  CHECK APR STATUS BIT
CPKI10:	CONI	PAG,T1		;READ THE PROCESSORS SERIAL NUMBER
	LSH	T1,-^D26	;RIGHT ADJUST IT
	MOVEM	T1,.C0ASN##	;STORE IT FOR PROPRIETARY PROGRAMS
	MOVEI	F,CT.KI		;REMEMBER THIS IS A KI10
	CONI	APR,T1		;GET APR STATUS
	TLNE	T1,(IP.50H)	;50 HERTZ POWER?
HRTZ50:	SKIPA	T4,[EXP ^D50]	;50 HERTZ POWER LINE FREQUENCY
HRTZ60:	MOVEI	T4,^D60		;60 HERTZ POWER LINE FREQUENCY
CPU166:	CAME	F,.C0TYP	;DO WHAT THE MONITOR WAS BUILT FOR AND
				; THE CURRENT MACHINE AGREE?
	JRST	CPUBAD		;NO, GO COMPLAIN
	MOVEM	T4,TICSEC	;NUMBER OF CLOCK TICKS PER SECOND
	MOVSI	T1,(ST.CYC)	;SET BIT SIX OF STATES IF 50 HZ POWER
	CAIN	T4,^D50		;50 HERTZ POWER?
	IORM	T1,STATES	;YES
	IMULI	T4,^D60		;NUMBER OF TICS PER MINUTE
	MOVEM	T4,TICMIN	;SAVE THAT
	IMULI	T4,^D60*^D24	;NUMBER OF TICS PER DAY
	MOVEM	T4,MIDNIT	;SAVE THAT FOR MIDNIGHT CHECKING
	JRST	WHYLOP		;GO ASK WHY RELOAD


;SETUP INTERNAL TIMER ON KL10 TO MIMIC CLOCKS OF EARLIER CPUS.

IFN FTKL10,<
ONCINT:	CONO	MTR,0		;MAKE SURE INT. TIME DOESNT INTERRUPT
	MOVEI	T2,^D1666+TO.SIT+TO.CTD  ;WORD TO KEEP TIMER GOING
	MOVE	T1,STATES	;GET STATES
	TLNE	T1,(ST.CYC)	;50 HZ?
	MOVEI	T2,^D2000+TO.SIT+TO.CTD  ;50 HZ WORD TO KEEP TIMER GOING
	MOVEM	T2,ONCKLT	;CONO TIM,@ONCKLT STARTS TIMER GOING AGAIN
	CONO	TIM,TO.CIT(T2)	;CLEAR INTERNAL TIMER & START FIRST TIME
	POPJ	P,		;RETURN
>;END IFN FTKL10

;ASK OPERATOR REASON FOR RELOAD
;ANSWER WILL BE PUT IN LOG FILE DAEMON
;ALONG WITH ARBITRARY OPERATOR COMMENT, IF ANY.
;ALLOW UNIQUE ABBREVIATION

IFN FTWHY,<			;WHY RELOAD FEATURE?
	EOL==12			;END OF LINE CHARACTER IN ONCE

WHYLOP:	SETZM	CRSHAC		;CLEAR OUT CRASH AC AREA FOR OPERATOR COMMENT
	MOVE	T1,[XWD CRSHAC,CRSHAC+1]
	BLT	T1,CRSHAC+17
	SKIPL	DEBUGF##	;DEBUGGING STAND-ALONE?
	JRST	WHY0		;NO,
	MOVE	T1,SACOD	;YES, FLAG STAND-ALONE
	MOVEM	T1,WHYCOD##	;FOR DAEMON
	JRST	DATLOP		;GO ASK DATE
WHY0:
	HRRZ	T1,CRSWHY##	;GET STOPCD CODE FROM PREVIOUS LOAD
	JUMPE	T1,WHY01	;JUMP IF NONE
	HRLI	T1,'S..'	;YES--SET STOPCD PREFIX
	MOVEM	T1,WHYCOD##	;AND STORE AS REASON FOR RELOAD
	JRST	DATLOP		;SKIP QUESTION
WHY01:	MOVEI	T1,[ASCIZ /WHY RELOAD: /]
	MOVEI	T2,[ASCIZ /OTHER ;OPR DID NOT ANSWER/]
	PUSHJ	P,ASKDEF	;TYPE OUT AND WAIT FOR INPUT
	  JRST	WHYSHT		;JUST CR TYPED, GIVE SHORT HELP
	PUSHJ	P,CTEXT##	;GET FIRST WORD LEFT JUSTIFIED SIXBIT IN T2
	JUMPN	T2,WHY1		;ANYTHING BEFORE FIRST BREAK?
	CAIN	T3,"/"		;NO, IS BREAK A SLASH?
	JRST	WHYLNG		;YES, ASSUME /H AND GIVE LONG HELP
	JRST	WHYSHT		;NO, GIVE SHORT HELP

WHY1:	MOVE	P1,T3		;SAVE BREAK
	MOVE	T1,[-WHYLEN,,WHYTAB]	;POINT TO TABLE
	PUSHJ	P,FNDNAM	;LOOKUP ABBREV.
	  JRST	WHYSHT		;GIVE HELP
	MOVE	TTAB(T1)	;NO, GET UNABBREVIATED SIXBIT CODE
	MOVEM	T1,WHYCOD##	;AND STORE IN GETTAB FOR DAEMON
	JUMPE	P1,DATLOP	;YES, END OF MESSAGE (GETLIN FORCES NULL)?
				; IF YES, GO GET DATE
;HERE TO GET OPERATOR COMMENT AND STORE IN CRASH ACS
	MOVEI	T1,20*5-1	;YES, NO. OF ASCIZ CHAR IN 20 WORDS
				;OF CRASH ACS. SAVE ROOM FOR NULL
	MOVEM	T1,WHYCNT	;STORE FOR LOOP COUNT
	MOVE	P1,[POINT 7,CRSHAC##] ;BYTE PTR FOR WHERE TO PUT
WHY4:	PUSHJ	P,COMTYI##	;GET NEXT CHARACTER (EVEN IF ;)
	JUMPE	T3,WHY5		;END OF STRING (GETLIN STORES NULL)
	CAIL	T3,12		;NO, END OF LINE CHAR?
	CAILE	T3,15		;"
	SKIPA			;NO
	JRST	WHY5		;YES, DO NOT STORE, JUST GO STORE NULL
	SOSG	WHYCNT		;ANY MORE ROOM IN CRSHAC BLOCK?
	JRST	WHY5		;NO, GO STORE NULL AND QUIT
	IDPB	T3,P1		;YES, STORE ASCIZ CHARACTER
	JRST	WHY4		;GO GET MORE

;HERE WHEN FINISHED COPYING OPERATOR COMMENT TO CRASH ACS
WHY5:	MOVEI	T3,0		;NULL
	IDPB	T3,P1		;STORE ON END SO ASCIZ
	JRST	DATLOP		;GO ASK FOR DATE

;HERE TO TYPE SHORT HELP MESSAGE ON ANY ERROR
WHYSHT:	MOVEI	T1,WHYMS1	;ADR OF SHORT HELP MESSAGE
	PUSHJ	P,ICONM		;INITIALIZE BUFFER AND MOVE CHAR
	PUSHJ	P,OPOUT		;START TYPING
	JRST	WHYLOP		;GO BACK TO ASK WHY RELOAD AGAIN

;HERE TO TYPE LONG HELP MESSAGE ON /H
WHYLNG:	MOVEI	T1,WHYMS2	;ADR OF LONG HELP MESSAGE
	PUSHJ	P,ICONM		;INITIALIZE AND MOVE CHAR TO OUTPUT BUFFER
	PUSHJ	P,OPOUT		;START TYPING
	JRST	WHYLOP		;GO BACK AND ASK WHY RELOAD AGAIN

WHYCNT:	0			;COUNT FOR NO CHAR LEFT IN CRASH ACS

;LIST OF POSSIBLE WHY RELOAD ANSWERS (CAN BE ABBREVIATED)
; ORDER IS IMPORTANT. OPERATOR SHOULD ANSWER THE EARLIEST ONE
; IN TABLE WHICH APPLIES (WHEN MORE THAN ONE DOES)

WHYTAB:

;PREVIOUS SYSTEM PROBLEM:

	SIXBIT	/OPR/
	SIXBIT	/PARITY/
	SIXBIT	/POWER/
	SIXBIT	/STATIC/
	SIXBIT	/HARDWA/
	SIXBIT	/NXM/
	SIXBIT	/HALT/
	SIXBIT	/LOOP/
	SIXBIT	/HUNG/
;PREVIOUS NON-TIMESHARED USE OF SYSTEM:
	SIXBIT	/PM/
	SIXBIT	/CM/
SACOD:	SIXBIT	/SA/
;DIFFERENT MONITOR WANTED:
	SIXBIT	/NEW/
	SIXBIT	/SCHED/
;OPERATOR DOESNT KNOW OR NOT IN TABLE (YET):
	SIXBIT	/OTHER/		;ALWAYS LAST OF TABLE
WHYLEN==.-WHYTAB		;LENGTH
;ADD ENTRIES IN MIDDLE ACCORDING TO PRECEDENCE, NOT AT END

;SHORT MESSAGE FOR JOGGING MEMORY
WHYMS1:	ASCIZ "OPR,PARITY,POWER,STATIC,HARDWARE
NXM,HALT,LOOP,HUNG
PM,CM,SA
NEW,SCHED
OTHER
/H FOR HELP
"
;LONG MESSAGE FOR /H
WHYMS2:	ASCIZ	/Type first word which applies (abbreviations ok)followed by
any comment:
OPR operator error
PARITY memory parity stop
POWER power failure
NXM non-existent memory stop
STATIC static electric
HARDWARE hardware malfunction
HALT program stop

LOOP loop in exec mode
HUNG no response

PM preventative maint
CM corrective maint
SA stand alone

NEW new monitor
SCHED scheduled reload

OTHER you dont know why or not any of the above
/
BUFLEN==.-WHYMS2		;LENGTH OF ONCE TTY BUFFER
				; MAKE IT LONG ENOUGH FOR THIS BIG MESSAGE
>	;END FTWHY


;ASK FOR TODAY'S DATE AND CONVERT
;DATE STORED AS ((Y-64)*12.+M-1)*31.+D-1

	EXTERNAL THSDAT,TICMIN

DATLOP:	SKIPA	T1,[[ASCIZ /DATE: /]]
DATHLP:	MOVEI	T1,[ASCIZ /PLEASE TYPE TODAY'S DATE AS MON-DD(-YY)
/]
	SETZM	LOCSEC##	;NO TIME KNOWN YET
	HLRZ	T4,CRSDTM##	;SEE IF SAVED AFTER CRASH
	HRRZ	T2,CRSDTM##	; ..
	HLRZ	T3,CRSWHY##	; ..
	ADD	T2,T4		; ..
	ADDI	T2,507601
	TLZ	T2,-1
	SUBI	T2,(T3)		; ..
	JUMPN	T2,GOASK	; ..
	MOVE	T2,T4		;COPY DATE
	ANDI	T2,17		;MASK OUT MONTH
	MOVEM	T2,LOCMON##	;STORE
	MOVE	T1,T4
	LSH	T1,-4		;SHIFT OFF MONTH
	MOVE	T2,T1		;COPY DATE
	ANDI	T2,37		;MASK OUT DAY
	MOVEM	T2,LOCDAY##	;STORE IN COMMON
	LSH	T1,-5		;SHIFT OFF DAY
	ADDI	T1,^D1970	;ADD IN BASE
	MOVEM	T1,LOCYER##	;STORE
	HRRZ	T1,CRSDTM##	;GET TIME
	ADDI	T1,^D90		;TIME TO RELOAD
	IDIVI	T1,^D60*^D60	;GET HOURS
	IDIVI	T2,^D60		;GET MIN
	MOVEM	T1,LOCHOR##	;STORE HOURS
	MOVEM	T2,LOCMIN##	;STORE MIN
	MOVEM	T3,LOCSEC##	;STORE SECONDS
	PUSHJ	P,CHKMNT##	;SEE IF PASSED THROUGH MIDNIGHT WHILE RELOADING
	AOS	LOCSEC##	;MAKE NON-ZERO
	HRRZS	CRSWHY##	;DO NOT LOOP
	MOVE	T1,DEFSP	;GET DEFAULT STRING POINTER
	MOVEM	T1,DEFPTR	;STORE AS POINTER
	MOVE	T1,LOCMON##	;GET MONTH
	PUSHJ	P,DECDEF	;DO THE DEFAULT STUFF
	MOVEI	T1,"-"		;ADD A DASH
	IDPB	T1,DEFPTR	; ..
	MOVE	T1,LOCDAY##	;GET THE DAY
	PUSHJ	P,DECDEF	;STORE AS PART OF DEFAULT
	MOVEI	T1,"-"		;ADD 1 MORE DASH
	IDPB	T1,DEFPTR	; ..
	MOVE	T1,LOCYER	;GET THE YEAR
	PUSHJ	P,DECDEF	;ADD THAT ON
	MOVEI	T1,0		;MAKE ASCIZ
	IDPB	T1,DEFPTR	;STORE
	MOVEI	T1,[ASCIZ /DATE: /]
	MOVEI	T2,DEFBUF
	PUSHJ	P,ASKDEF	;ASK QUESTION
	  JRST	DATLO2
	JRST	GOASK1		;GO PARSE THE ANSWER
GOASK:	PUSHJ	P,ASKGET
	  JRST	DATHLP
GOASK1:	MOVEI	T1,LOCYER##
	PUSHJ	P,GTDATE##	;GET DATE
	  JRST	DATHLP		;ERROR
	MOVE	T2,LOCYER
	SUBI	T2,^D1900
	CAIGE	T2,M.YEAR
	JRST	DATHLP
	MOVE	T1,LOCMON##	;NOW CK DAY ARG.
	SOS	T1
	LDB	T2,PMONTB##
	AOS	T2
	SOJN	T1,DATLO1	;JUMP IF NOT FEB
	MOVE	T1,LOCYER	;LEAP YEAR?
	TRNN	T1,3
	AOS	T2		;YES - 29 DAYS
DATLO1:	CAML	T2,LOCDAY##	;CK DAY ARG.
	JRST	DATLO2		;OK
	MOVEI	T1,[ASCIZ/?ILLEGAL DAY
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	JRST	DATLOP

DATLO2:	PUSHJ	P,THSDA##	;COMPUTE & STORE THSDAT

;CODE TO VALIDATE THE DATE JUST TYPED IN

VALID:	MOVE	T1,ONCMON	;FORM 12 BIT DATE FOR COMPARISON
	IMULI	T1,^D31
	MOVEM	T1,CHKDAT
	MOVE	T1,ONCDAY
	SUBI	T1,1+^D31
	ADDM	T1,CHKDAT
	MOVE	T1,ONCYER
	SUBI	T1,^D64		;ADJUST TO T=0
	IMULI	T1,^D12*^D31
	ADD	T1,CHKDAT
	CAMG	T1,THSDAT
	JRST	TIMLOP		;OK IF TODAY .GE. CREATION DAY

	MOVEI	T1,[ASCIZ /
%Today's date is prior to monitor creation date.
Creation date:  /]
	PUSHJ	P,ICONM		;QUESTION EARLY DATE
	MOVEI	T1,SYSDAT##
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /
Today's date:   /]
	PUSHJ	P,ICONM
	MOVE	T1,LOCMON
	PUSHJ	P,RADX10##
	PUSHJ	P,DASH
	MOVE	T1,LOCDAY##
	PUSHJ	P,RADX10
	PUSHJ	P,DASH
	MOVE	T1,LOCYER
	SUBI	T1,^D1900
	PUSHJ	P,RADX10
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /
IS THIS CORRECT? (Y OR N)/]
	PUSHJ	P,YESNO
	  JRST	DATHLP		;NO, TRY AGAIN
	JRST	TIMLOP		;HE LIKES IT ANYWAY

DASH:	MOVEI	T1,[ASCIZ /-/]
	PJRST	CONMES

;CONSTANTS, MONTH,DAY,YEAR FROM MONGEN

ONCMON:	M.MON##
ONCDAY:	M.DAY##
ONCYER:	M.YEAR##
CHKDAT:	Z			;LOCAL STORAGE FOR DATE (12 BIT)
;GET TIME OF DAY

	EXTERNAL TIME,SYSTOP,SYSCRH

TIMLOP:	SKIPA	T1,[[ASCIZ /TIME: /]]
TIMHLP:	MOVEI	T1,[ASCIZ /PLEASE TYPE TIME AS HHMM
/]
	SKIPN	LOCSEC##	;DO WE KNOW TIME
	JRST	ASKTIM		;NO--GO ASK FOR IT
	MOVE	T1,DEFSP
	MOVEM	T1,DEFPTR
	MOVE	T1,LOCHOR##	;SETUP DEFAULT
	PUSHJ	P,DECDEF	; ..
	MOVE	T1,LOCMIN	; ..
	PUSHJ	P,DECDEF	; ..
	MOVEI	T1,0		; ..
	IDPB	T1,DEFPTR	; ..
	MOVEI	T1,[ASCIZ /TIME: /]
	MOVEI	T2,DEFBUF
	PUSHJ 	P,ASKDEF	;GO ASK ABOUT TIME
	  JRST	HAVTIM		;JUST A CR
	JRST	RDTIM
ASKTIM:	PUSHJ	P,ASKGET
	  JRST	TIMHLP		;JUST A CR
RDTIM:	PUSHJ	P,DECIN##	;READ THE TIME (1-4 CHARACTERS)
	JRST	TIMHLP		;NO ARGUMENT
	JRST	TIMHLP		;ILLEGAL CHARACTER
	MOVE	T1,T2
	IDIVI	T1,^D100	;T1=HRS,T2=MINS
	SKIPL	T1		;HRS NEGATIVE ?
	CAILE	T1,^D23		;OR .GREATER THAN. 23 ?
	JRST	TIMHLP		;OUT OF BOUNDS
	CAILE	T2,^D59		;MINUTES .GREATER THAN. 59 ?
	JRST	TIMHLP		;OUT OF BOUNDS
	MOVEM	T1,LOCHOR##	;STORE GETTAB HOUR
	MOVEM	T2,LOCMIN##	;  & MINUTE
	SETZM	LOCSEC##	;  & SECOND
HAVTIM:	MOVE	T1,LOCHOR##
	MOVE	T2,LOCMIN##
	IMULI	T1,^D60		;CONVERT TO MINUTES
	ADD	T1,T2		;MINUTES SINCE MIDNIGHT
	IMUL	T1,TICMIN	;JIFFIES SINCE MIDNIGHT
	MOVEM	T1,TIME		;TIME=JIFFIES SINCE MIDNIGHT
	PUSH	P,J		;SAVE ALT-MODE TYPED FLAG


;MOVE SYMBOL TABLE UP IN MEMORY
;EXEC MUST BE LOADED IN 15K OR LESS IF GOING INTO 16K MACHINE
;FIRST FIND THE FIRST LOCATION OF NON-EXISTENT MEMORY

	EXTERNAL DDTSYM,DDTUSY,NWCORE

BYPSYM:
BYPSY0:	SETZ	P2,		;FOR CALLS TO A SUBROUTINE IN SYSINI
	SETZB	U,P4
	MOVEI	P1,CORBLK##	;IN CASE MEMORY HAS NO NON-EXISTANT BANKS
BYPSY1:
IFN FTKA10!FTKI10,<
	CONO	APR,NXM##	;CLEAR NON-EX MEM FLAG
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM ;CLEAR NXM FLAG ON A KL
>
BYPSY2:	ADDI	U,PAGSIZ##	;TRY NEXT 1K BLOCK
	SETZB	T2,P3
BYPS2A:	PUSH	P,U
	ADDI	U,(P3)
	PUSHJ	P,REFMEM##	;REFERENCE THIS LOCATION
	POP	P,U
	CONSO	APR,NXM##	;NON:EXISTANT?
	TLOA	T2,200000	;NO, REMEMBER EXISTANT MEMORY SEEN
	TLO	T2,400000	;YES, REMEMBER THAT
	CAIE	P3,MEMITL##-1	;LOOKED AT ENOUGH WORDS IN THIS PAGE
	AOJA	P3,BYPS2A	; TO DETECT INTERLEAVING ERROR?
	JUMPG	T2,BYPS2B	;JUMP IF NO NXM SEEN
	TLNN	T2,200000	;NXM, SOME EXISTANT ALSO?
	JRST	BYPS2C		;NO, NOT AN INTERLEAVING PROBLEM
	MOVEI	T1,[ASCIZ  /?MEMORY INTERLEAVING ERROR
/]
	PUSHJ	P,ICONM		;TELL THE OPR ABOUT THE PROBLEM
	PUSHJ	P,OPOUT
	STOPCD	.,STOP,MIW,	;++MEMORY INTERLEAVING IS WRONG
BYPS2B:	SOJG	P1,BYPSY2	;NO, KEEP LOOKING AS LONG AS NOT TOP OF MEMORY
BYPS2C:	SKIPN	P4		;FIRST TIME THROUGH?
	MOVE	P4,U		;YES, REMEMBER LOCATION OF LOWEST NON-EX MEM
	SOJL	P1,BYPSY4	;ACCOUNT FOR MISSED SOJ AND SEE IF FINISHED
	MOVE	P3,U		;NOW SEE IF ANY MEMORY EXISTS HIGHER UP
BYPSY3:	;CLEAR THE NON-EX-MEM FLAG
IFN FTKA10!FTKI10,<
	CONO	APR,NXM##
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM
>
	ADDI	P3,PAGSIZ##	;TRY NEXT 1K BLOCK
	PUSH	P,U		;SAVE U
	MOVE	U,P3		;SET ARG FOR REFMEM
	PUSHJ	P,REFMEM##	;REFERENCE IT
	POP	P,U		;RESTORE U
	CONSZ	APR,NXM##	;IS IT THERE?
	SOJG	P1,BYPSY3	;NO, LOOP THROUGH ALL 256K
	SOJLE	P1,BYPSY4	;JUMP IF NO MORE EXISTANT MEMORY
	PUSHJ	P,MEMBAD	;TELL THE OPERATOR HE HAS HOLES IN MEMORY
	  JRST	BYPSY0		;HE SAID HE FIXED IT. GO SEE IF HE DID.
IFN FTMONL,<
	  JFCL			;OFF-LINE
>
	  MOVE	U,P3		;HE SAID ITS BROKEN
	JRST	BYPSY1		;GO SEE IF THERE ARE ANY MORE HOLES
BYPSY4:	SKIPL	DEBUGF##	;SYS PROG DEBUGGING MONITOR?
				; NOTE - ALREADY TOLD HIM IF HOLE IN MIDDLE
;PATCH TO NO. OF WORDS OF CORE TO BE CHECKED FOR ALL-ON-LINE
PATNWC::CAML	U,NWCORE	;NOW SEE IF THERE IS AT LEAST AS MUCH MEMORY AS THERE
				; WAS AT MONGEN TIME
	JRST	BYPSY5		;THERE IS SO NO REASON TO COMPLAIN
	MOVE	P3,NWCORE	;REMIND HIM OF HOW MUCH MEMORY HE HAD AT MONGEN TIME
	PUSHJ	P,MEMBAD	;TELL THE OPERATOR THERE'S NOT THAT MUCH THERE
	  JRST	BYPSY0		;HE SAID HE FIXED IT. SEE IF HE REALLY DID.
IFN FTMONL,<
	  MOVEM	U,NWCORE##	;HE SAID DOWN, DON'T ALLOCATE EXTRA CORE FOR
				; PAGTAB AND MEMTAB
				;HERE IF HE SAID OFF LINE
>

;OK, HE'S WILLING TO BRING IT UP WITHOUT ALL THE MEMORY ON LINE (LET'S HOPE ITS DOWN)
BYPSY5:
IFN FT22BIT,<
	CAMG	U,[XWD 1,0]	;MORE THAN 256K?
	SETZ	U,		;NO
	MOVEM	U,FLG256##	;SET GTR THAN 256K FLAG
>
	MOVE	U,P4		;MAKE ROOM FOR BOOTS AND ITS BUFFERS AT THE TOP OF CORE
	SUBI	U,2000
IFN FTKI10!FTKL10,<
	MOVE	T1,.C0TYP
	CAIN	T1,CT.KA
	JRST	STO0
	CAIL	U,^D112*^D1024	;LESS THAN 112K OF MEMORY?
	MOVEI	U,^D112*^D1024	;NO, PUT SYMBOLS AT 112K
IFN FT2SEGMON,<
	CAMLE	U,SYSORG##
	MOVE	U,SYSORG##
> ;END FT2SEGMON
	SKIPL	DEBUGF		;DEBUGGING?
	JRST	STULPT		;NO, DON'T MAKE CORE CONTAINING
				; SYMBOLS LOOK LIKE NXM
	HLRE	T3,DDTSYM	;-LENGTH OF SYMBOL TABLE
	JUMPE	T3,STULPT	;NOTHING TO DO IF NO S.T.
	MOVNS	T1,T3		;T1=T3=LENGTH OF S.T.
	LSH	T3,W2PLSH##	;T3=# OF PAGES REQUIRED FOR S.T.
	TRNE	T1,PG.BDY##
	ADDI	T3,1		;ROUND UP
	SUBM	U,T1		;T1=WHERE S.T. WILL START
	JUMPL	T1,STULPT	;MUST BE MOVING S.T. UP
	LSH	T1,W2PLSH##	;T1=FIRST PAGE WHICH WILL
				; CONTAIN THE SYMBOL TABLE
	IDIVI	T1,^D36		;BIT POSITION AND REL LOC IN NXMTAB
	MOVNI	T2,-^D36(T2)	;BIT 0=36, BIT 1=35,...
	HRLM	T2,T4		;CSETOS WANTS THAT IN LH(T4)
	HRRI	T4,NXMTAB##(T1)	;POINT TO WORD IN NXMTAB
	PUSHJ	P,CSETOS##	;MARK THE PAGES WHERE
				; THE S.T. WILL BE MOVED AS
				; NON-EXISTANT

;STILL IN FTKI CONDITIONAL
;HERE TO INITIALIZE LOWTAB (CORE BLOCKS FOR IOWD'S)
STULPT:	MOVE	T1,LOWPTR##	;ABOJN POINTER TO LOWTAB
	SETOM	(T1)		;SET IT TO ALL ONES
	AOBJN	T1,.-1		; ..
	MOVEI	P1,LTINIT##	;ADDRESS OF TABLE CONTAINING ADDRESSES OF
				;  LOWER CORE FOUR WORD BLOCKS
	HRRZ	P2,LTINIT##	;ADDRESS OF FIRST FOUR WORD BLOCK
	MOVEM	P2,LOWLOC##	;STORE THAT AS ORIGIN OF FOUR WORD IOWD SPACE
STULP1:	SKIPN	T2,(P1)		;NEXT CHUNK OF FOUR WORD SPACE
	JRST	STO0		;ALL DONE
	HLRZ	T1,(P1)		;NUMBER OF FOUR WORD BLOCKS IN THIS CHUNK
	HRRZS	T2		;0,,STARTING ADDRESS OF THIS CHUNK
	SUBI	T2,(P2)		;RELATIVE ADDRESS WITHIN IOWD SPACE
	LSH	T2,-2		;FOUR WORDS PER BLOCK
	IDIVI	T2,^D36		;NUMBER OF BITS REPRESENTING FOUR WORD BLOCKS
	HRLS	T2		;WHERE THEY START IN THE TABLE
	ADD	T2,LOWPTR##	;MAKE AN AOBJN POINTER TO THE TABLE
	PUSHJ	P,SETZRS##	;INDICATE THAT THOSE BLOCKS ARE AVAILABLE
	AOJA	P1,STULP1	;LOOP UNTIL ALL CHUNKS ARE MARKED IN THE BIT TABLE
>	;END FTKI
STO0:	HLRE	T2,DDTSYM	;-LENGTH OF S. T.
				;NOTE THAT THE SYMBOL TABLE POINTER IS MOVED FROM
				; JOBSYM(R) TO DDTSYM(R) BY SYSMAK WHEN THE SYSTEM
				; IS FIRST CREATED.
	JUMPE	T2,STO2		;0 IF NO S. T. TO MOVE UP
	MOVNS	T2		;+LENGTH
	HRRZ	T1,DDTSYM	;FIRST ADDRESS
	ADDI	T1,(T2)		;LENGTH+FIRST ADDRESS
	HRL	T1,T2		;XWD LENGTH,LENGTH+FIRST ADDRESS
	SUBI	U,1(T1)		;NEW LAST+1-OLD LAST+1
	HRRM	U,STO1		;DIST. TO MOVE
	MOVE	T2,DDTSYM	;-N,FIRST ADD.
	ADDI	T2,1(U)		;FORM NEW S.T. POINTER
	MOVEM	T2,DDTSYM	;STORE IN LOWER CORE
	SKIPE	T2,DDTUSY	;GET UNDEFINED SYMBOLS
	ADDI	T2,1(U)		;INCREMENT POINTER IF ANY
	MOVEM	T2,DDTUSY	;STORE BACK
	SKIPE	T2,DDTUSY	;SEE IF SOME UND. SYM.
	MOVE	T2,DDTSYM	;GET START OF S.T.
	SUB	T2,DDTUSY	;GET LEN. U.S.T.
	HRLZ	T2,T2		;POSITION
	ADD	T1,T2		;ADVANCE COPY COUNT

	MOVE	T2,-1(T1)
STO1:	MOVEM	T2,.-.(T1)
	SUB	T1,[XWD 1,1]
	JUMPGE	T1,.-3

IFN FTKI10!FTKL10,<
	MOVE	T2,.C0TYP
	CAIE	T2,CT.KA
	JRST	STO2
>
	MOVEI	T2,@STO1	;GET ADDRESS OF LAST STORE-1
	SUBI	T2,17		;CHANGE TO START OF S.T.-8 SYMBOLS
	LSH	T2,W2PLSH##	;CONVERT TO PAGES
DBGMNU::MOVEI	T1,MINMAX##	;PATCH TO MIN. SAVED FOR USER
	ADDI	T1,3*^D1024+DDTEND##  ;ALLOW FUDGE FOR MON. TABLES
	LSH	T1,W2PLSH##	;CONVERT TO PAGES
	CAMGE	T2,T1		;SEE IF ENOUGH SPACE
	MOVE	T2,T1		;NO-- CUT SOME SYMBOLS
	SKIPGE	DEBUGF		;SEE IF DEBUGGING
	HRRM	T2,SYSLIM##	;YES--PRESERVE SYMBOL TABLE

STO2:	JSR	JRSTI1		;SETUP LOCS 40 THRU 61 & TEST FOR 2 RELOC. HARDWARE
	MOVE	T1,[JRST LOADMS]	;ONLY MOVE SYMBOLS ONCE
	MOVEM	T1,BYPSY5
LOADMS:	MOVEI	T1,SYSTOP	;NOW PATCH 147 START HDR SO THAT STATE
	HRRM	T1,SYSCRH	;OF MACHINE WILL BE SAVED. (ON TOP OF SYSINI).
				; THUS MONITOR PROGRAMMERS CAN GO TO 147
				; BEFORE MONITOR IS STARTED TO GET TO BOOTS
				; TO WRITE OUT PATCHED MONITOR

	SKIPGE	(P)		;SKIP IF ALTMODE TERMINATED DATE
	JRST	LONGD		;DO THE LONG DIALOGUE IF THE LAST LINE
				; TYPED IN (NAMELY TIME OF DAY) WAS TERMINATED BY
				; AN "ALT MODE".  (PUSH-DOWN LIST IS SET UP
				; IN THE "GETLIN" SUBROUTINE CALLED ABOVE.)


;TYPING ESCAPE DURING ONCE WILL BRING YOU BACK HERE TO TRY AGAIN.

SHORTD::
	SETZB	P1,SHUTUP##	;CLEAR SHORT FLAG
	SKIPGE	DEBUGF
	JRST	QUICK
	MOVEI	T1,[ASCIZ/
STARTUP OPTION: /]
	MOVEI	T2,[ASCIZ /QUICK  ;DEFAULT/]
	PUSHJ	P,ASKDEF	;ASK QUESTION
	JRST	ONCHLP		;GIVE SOME HELP
	PUSHJ	P,CTEXT##	;GET FIRST WORD
	JUMPN	T2,LNG1		;JUMP IF WORD GIVEN
	CAIN	T3,"/"		;SEE IF /H
	JRST	LNGHLP		;YES--LONG HELP
	JRST	ONCHLP		;NO--SHORT HELP

LNG1:	MOVE	T1,[-OPTLEN,,OPTTAB]
	PUSHJ	P,FNDNAM##	;LOOKUP NAME
	  JRST	ONCHLP		;GIVE SOME HELP
	XCT	OPTXCT(T1)	;DO YOUR THING

	JRST SHORTD

;DONE BY XCT ABOVE

OPTXCT:	PUSHJ	P,SHRTPM##
	PUSHJ	P,SHRTST##
	JRST	QUICK
	PUSHJ	P,FILOPT##
	JRST	PVQCK
	JRST	QUICKN
	PUSHJ	P,SHRTRF##
	PUSHJ	P,SHRTID##

PVQCK::
	SETOM	OPTQIK##
	JRST	QUICK

;SHORT HELP
ONCHLP:	MOVEI	T1,[ASCIZ "
CHANGE,DESTROY,GO,LONG,QUICK,NO INITIA,REFRESH,UNITID
/H FOR HELP
"]
	JRST	ONCHL1		;TYPE THAT OUT
LNGMSG:	ASCIZ "
CHANGE	- CHANGE DISK PARAMETERS
DESTROY	- REBUILD ALL DISKS.  DELETES ALL FILES, SETS ALL DEFAULTS.
GO	- START THE SYSTEM IF ALL IS OK.
LONG	- ENTERS LONG DIALOGUE
QUICK	- SAME AS GO BUT DO NOT ASK ABOUT OFF-LINE DEVICES.
NO INITIA	- GO, BUT DONT BRING UP OPSER,ETC
REFRESH	- REFRESH SELECTED STRUCTURES
UNITID	- CHANGE UNIT ID'S
"
IFNDEF	BUFLEN,<BUFLEN==.-LNGMSG>
IFL	BUFLEN-<.-LNGMSG>,<BUFLEN==.-LNGMSG>
LNGHLP:	MOVEI	T1,LNGMSG
ONCHL1:	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	JRST	SHORTD

OPTTAB:	SIXBIT	/CHANGE/
	SIXBIT	/DESTRO/
	SIXBIT	/GO/
	SIXBIT	/LONG/
	SIXBIT	/QUICK/
	SIXBIT	/NO/
	SIXBIT	/REFRES/
	SIXBIT	/UNITID/

OPTLEN==.-OPTTAB
;THE LONG DIALOGUE BEGINNETH HERE.....

LONGD:	SETOM	(P)		;SET "ALTMOD"-TYPED FLAG

	INTERNAL FTDISK
IFN FTDISK, <
	EXTERNAL FILOPT
	PUSHJ	P,FILOPT	;GO THROUGH THE REFRESH DIALOGUE(S) [LEVEL C]
				; TYPE STATE OF WHOLE DISK SYSTEM, THEN
				; ACCEPT CHANGES TO UNITS AND STR'S & REFRESH [LEVEL D]
>
REPEAT	0,<	;HISTORIC FEATURES
;PRINT I/O CONFIGURATION

	EXTERNAL TCONLN,INLMES,PRNAME,INTTB1,INTTAB,OCTPNT
IFN FTDISK,<EXTERNAL KONTAB,KONINT,UNINAM,UNYKTP,MKNMXU>

	MOVEI	T1,[ASCIZ /LIST CONFIGURATION ? (Y OR <CR>)
/]
	PUSHJ	P,YESNO
	  JRST ONCEOP		;BYPASS CONFIGURATION TYPE-OUT
	MOVEI	T1,CRLFMS	;PRINT CRLF
	PUSHJ	P,ICONM
	MOVE	T1,TICSEC	;GET # OF CLOCK TICKS PER SECOND
	PUSHJ	P,RADX10	;PRINT IT
	PUSHJ	P,INLMES
	ASCIZ	/ HZ. LINE FREQ.
/
	PUSHJ	P,OPOUT

IFN FT2REL, <
	MOVEI	T1,CRLFMS	;PRINT CRLF
	PUSHJ	P,ICONM
	MOVEI	T1,1		;ASSUME 1
	SKIPE	TWOREG
	MOVEI	T1,2
	PUSHJ	P,RADX10	;NO, SECOND REG EXISTS
	PUSHJ	P,INLMES
	ASCIZ	/ RELOC. REG.
/
	PUSHJ	P,OPOUT
>
;UNDER REPEAT 0
	MOVEI	T1,[ASCIZ #I/O CONFIGURATION
#]
	PUSHJ	P,ICONM
	HLRZ	P1,DEVLST
	JUMPN	P1,ALRLNK	;DEVICE DATA BLOCKS ALREADY LINKED ?
	MOVSI	R,INTNUM	;NO, NOT LOADED BY BUILD, -NUMBER OF DEVICES*2
CONFLP:	SKIPN	P1,INTTB1(R)	;INT LOC HAVE DEV DATA BLOCK ?
	JRST	NODDB		;NO, GO GET NEXT DEVICE DATA BLOCK
	LDB	M,[POINT 8,INTTAB(R),8]	;YES, NUMBER OF DEVICE DATA BLOCKS
IFN FTDISK,<JUMPE M,TLDD	;SEE IF LEVEL D DISK>
NLDD:	HRRZ	T1,M		;PRINT
	PUSHJ	P,RADX10	;IN DECIMAL
	PUSHJ	P,INLMES	;PRINT 1 SPACE
	ASCIZ	/ /
	HLLZ	T2,DEVNAM(P1)	;DEVICE NAME
	PUSHJ	P,PRNAME	;PRINT IT
	SOJLE	M,SINGLE	;IS THIS JUST A SINGLE DEVICE ?
	PUSHJ	P,INLMES	;NO, APPEND 'S TO DEVICE NAME
	ASCIZ	/'S/
SINGLE:	PUSHJ	P,CRLF		;PRINT CR LF
	PUSHJ	P,OPOUTX	;TYPE OUT UNLESS ^O IS IN FORCE
	PUSHJ	P,OTSET		;REINITIALIZE BUFFER
NODDB:	AOBJN	R,.+1		;
	AOBJN	R,CONFLP	;FINISHED ALL DEVICES ?
	JRST	PRSCLN		;YES
;UNDER REPEAT 0
;UNDER REPEAT 0
IFN FTDISK,<
TLDD:	HRRZ	P1,INTTB1(R)	;ADDR OF DDB
	HLRZ	P1,DEVNAM(P1)	;LH OF DEVICE NAME
	CAIE	P1,(SIXBIT .DSK.)
	JRST	NLDD		;NOT REALLY DISK
	MOVNI	M,KONINT	;OFFSET FOR INT. LOCS
	ADD	M,INTTAB(R)	;ADDR OF KONT DB
	MOVEI	M,KONTAB(M)	;ADDR OF ADDR OF 1ST UNIT
	HRLI	M,T1		;ALLOW FOR INDEXING ON INDIRECT
	MOVE	P1,(M)		;P1=ADDR OF 1ST UNIT
	MOVEI	P1,UNINAM-DEVNAM(P1)	;POINT P1 TO UNIT NAME
	MOVSI	T1,MKNMXU	;-MAX NUMBER OF UNITS ON KONTROLLER
	SKIPE	@M		;SKIP IF NO MORE UNITS
	AOBJN	T1,.-1		;LOOP FOR MAX UNITS ON KONTROLLER
	HRRZ	M,T1		;M=NUMBER OF UNITS ON KONTROLLER
	JUMPE	M,NODDB		;JUMP IF NO UNITS
	JRST	NLDD		;OK, PRINT KONTROLLER
>
;UNDER REPEAT 0
ALRLNK:	MOVEI	T1,1
	HLLZ	J,DEVNAM(P1)
ALRLK2:	HLRZ	P1,DEVSER(P1)
	JUMPE	P1,ALRLK4
	HLLZ	T2,DEVNAM(P1)
	CAMN	T2,J
	AOJA	T1,ALRLK2
ALRLK4:	MOVE	R,T1		;SAVE NUMBER
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/ /
	MOVEI	M,3
	MOVE	T1,[POINT 6,J]
ALRLK6:	ILDB	T3,T1
	ADDI	T3,40
	TYPE
	SOJG	M,ALRLK6
	MOVEI	T1,[ASCIZ /'S/]
	CAILE	R,1
	PUSHJ	P,CONMES
	PUSHJ	P,CRLF
	PUSHJ	P,OPOUTX	;TYPE OUT EACH LINE
	JUMPN	P1,ALRLNK
PRSCLN:	MOVEI	T1,CRLFMS
	PUSHJ	P,ICONM
	MOVEI	T1,TCONLN	;PRINT NUMBER OF TTY SCANNER LINES
	PUSHJ	P,OCTPNT
	PUSHJ	P,INLMES
	ASCIZ	/ (OCTAL) TTY SCANNER LINES
/
	PUSHJ	P,OPOUTX
	JRST	ONCEOP		;GO GET OPR CONSOLE
;UNDER REPEAT 0
;ASK FOR OPERATORS CONSOLE TO BE SPECIFIED

	EXTERNAL DEVOPR,CTEXT,DEVPHY,PUNIT,TCONLN
ONCEO2:	POP	P,T1		;GET RID OF LAST ANSWER WHICH WAS FAULTY

ONCEOP:	MOVEI	T1,[ASCIZ /TYPE NAME OF OPR CONSOLE
/]
	PUSHJ	P,ASKGET
	  JRST ONCDDT		;JUST CR
	PUSHJ	P,CTEXT
	MOVE	T1,T2
	PUSH	P,T1		;SAVE ANSWER
	CAMN	T1,[SIXBIT /CTY/]	;CTY ?
	JRST	ONCEO1		;YES. JUST STORE IT.
	CAMN	T1,[SIXBIT /OPR/]	;IGNORE CUTE ANSWERS
	JRST	ONCEO2
	CAMN	T1,[SIXBIT /TTY/]
	JRST	ONCEO2
	CAMN	T1,[SIXBIT /SYS/]
	JRST	ONCEO2
	PUSHJ	P,DEVPHY
	  JRST ONCEO2		;PHYSICAL NAME NOT FOUND
	MOVE	T2,DEVMOD(F)
	TLNN	T2,DVTTY	;IS SPECIFIED DEVICE A TELETYPE?
	JRST	ONCEO2		;NO, TRY AGAIN, WISE GUY.
	LDB	T2,PUNIT
	CAIL	T2,TCONLN	;A REAL TELETYPE?
	JRST	ONCEO2		;NO, PTY'S MAY NOT BE OPR...
ONCEO1:	POP	P,DEVOPR	;STORE NEW NAME
;UNDER REPEAT 0
	EXTERNAL DDTEND,SYSSIZ,SYSSNP,DECIN,CORLIM,USRLIM

;IS EXEC DDT WANTED ?

ONCDDT:	MOVEI	T1,[ASCIZ /DO YOU WANT EXEC DDT ? (Y OR <CR>)
/]
	PUSHJ	P,YESNO
	  JRST ONCSI		;NO
	MOVEI	T1,DDTEND	;FIRST FREE LOCATION ABOVE EXEC DDT
	MOVEM	T1,SYSSIZ	;SET NEW MONITOR SIZE

ONCSI:	MOVEI	T1,ENDSYS##	;END OF SYSINI
	CAMG	T1,SYSSIZ	;SKIP IF SYSINI WILL BE OVERLAYED
	JRST	ONCCOR		;NO, NO NEED TO ASK ABOUT IT
	MOVEI	T1,[ASCIZ /SYSINI?
/]
	PUSHJ	P,YESNO		;ASK IF WANT TO KEEP SYSINI
	  JRST	ONCCOR		;NO
	MOVEI	T1,ENDSYS##	;FIRST FREE LOCATION ABOVE SYSINI
	MOVEM	T1,SYSSIZ	;SET NEW MONITOR SIZE

ONCCOR:	MOVEI	T1,[ASCIZ /MAX. K CORE FOR SINGLE USER IS /]
	PUSHJ	P,ICONM
	MOVEI	T1,USRLIM
	PUSHJ	P,RADX10
	PUSHJ	P,CRLF
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /TYPE DESIRED MAX. (DECIMAL), TYPE <CR> IF OK AS IS
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	PUSHJ	P,GETLIN
	  JRST ONCLOK		;LEAVE LIMIT AS SET BY MONGEN QUESTION.
	PUSHJ	P,DECIN
	JRST	ONCLOK
	JRST	ONCLOK
	SKIPE	T2		;UNLESS HE SAID 0 LIKE IN MONGEN,
	HRRM	T2,CORLIM	; PATCH CORLIM FOR USER CORE SIZE LIMIT.
				; IF NOT PATCHED, LEAVE COMMON'S VALUE.
;UNDER REPEAT 0
ONCLOK:

	INTERNAL FTLOCK

IFN FTSWAP,<
IFN FTLOCK,<
	EXTERNAL LOKLIM,LOKASK,LOKMAX
	MOVEI	T1,LOKASK	;LOCK UUO INCLUDED AT MONGEN TIME?
	JUMPE	T1,ONCLK6	;JUMP IF NO
	MOVEI	T1,[ASCIZ /MINIMUM AMOUNT OF CORE GUARANTEED TO SWAPPABLE JOBS IS /]
	PUSHJ	P,ICONM
	HRREI	T1,LOKMAX
	SKIPG	T1
	HRRZ	T1,CORLIM
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/K
/
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /TYPE DESIRED MIN. DECIMAL, CR IF OK AS IS
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	PUSHJ	P,GETLIN
	JRST	ONCLK2		;SET IT TO CORMAX
	PUSHJ	P,DECIN
	JRST	ONCLK2
	JRST	ONCLOK
	JRST	ONCLK4
ONCLK2:	HRREI	T2,LOKMAX
	SKIPG	T2
	HRRZ	T2,CORLIM
ONCLK4:	HRRM	T2,LOKLIM
ONCLK6:
>>
;UNDER REPEAT 0
;SET TIME ACCOUNTING OPTIONS

;	STATES WORD BITS SELECT OPTIONS (INITIALIZED BY MONGEN)

	MOVE	P1,STATES##

;	SAY WHAT PRECISION IS

	MOVEI	T1,[ASCIZ/Runtime accounting is /]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ/high precision(DK10)
/]
	TLNN	P1,(ST.HPT)
	MOVEI	T1,[ASCIZ/low precision(APR clock)
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX

;	LET HIM CHANGE IT IF HE HAS A DK10

	XCT	CKDK10##	;CK FOR DK10S ON ALL CPUS
	JRST	ONCTI2		;NO DK10-NO HIGH PRECISION
	MOVEI	T1,[ASCIZ/Is this OK(Y,N): /]
	PUSHJ	P,NOYES
	  JRST	ONCTI2		;YES - DOESN'T WANT TO CHANGE
	MOVEI	T1,[ASCIZ/High precision(=DK10, Low=APR clock)(Y,N): /]
	PUSHJ	P,NOYES
	  TLOA	P1,(ST.HPT)	;YES - SET BIT FOR HIGH PRECISION
	TLZ	P1,(ST.HPT)	;NO - CLEAR BIT FOR LOW
ONCTI2:

;UNDER REPEAT 0
;	SAY WHETHER MONITOR OVERHEAD INCLUDED OR NOT
;	AND LET HIM CHANGE IT IF HE WANTS

	MOVEI	T1,[ASCIZ/Monitor overhead is /]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ/excluded from/]
	TLNN	P1,(ST.EMO)
	MOVEI	T1,[ASCIZ/included in/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	MOVEI	T1,[ASCIZ/ user runtime
Is this OK(Y,N): /]
	PUSHJ	P,NOYES
	  JRST	ONCTI4		;YES - IT'S OK
	MOVEI	T1,[ASCIZ/Exclude overhead(Y,N): /]
	PUSHJ	P,NOYES
	  TLOA	P1,(ST.EMO)	;YES - SET BIT TO EXCLUDE OVERHEAD
	TLZ	P1,(ST.EMO)	;NO - CLEAR BIT TO INCLUDE
ONCTI4:

;	STORE (POSSIBLY) MODIFIED STATES WORD
;	SYSINI WILL INITIALIZE TIME ACCOUNTING (GETIME) ACCORDING TO STATES

	MOVEM	P1,STATES##
>	;END REPEAT 0
;FIND CORE TO BE USED FOR MULTIPLE DEVICE DATA BLOCKS
; INCLUDING DISK

	EXTERNAL CNTDB

;GO, BUT NO INITIA
QUICKN:
	SETOM	OPTQIK
IFN FTCCLX,<
	MOVEI	T1,TTFCXI##	;INDEX OF INITIA
	SETZM	TTFCOM##(T1)	;CLEAR ENTRY FROM FORCED COMMAND TABLE
				;AND FALL INTO QUICK
>
QUICK:			;THIS IS THE SHORT-CUT EXIT TO BY-PASS MOST OF THE DIALOGUE.
IFN FTDISK,<
	SKIPN	HICORE##	;HICORE BEEN UPDATED?
	PUSHJ	P,REDHOM##	;NO, DO SO NOW
	  JFCL
>
	PUSH	P,SYSSIZ	;SAVE CURRENT SIZE
	JSP	T1,CNTDB	;UPDATE SYSSIZ BY SPACE USED
				; FOR DEVICE DATA BLOCKS FOR DSK,DTA,MTA,TTY,PTY)

	POP	P,T1		;POP OFF CURRENT SYSTEM SIZE
	EXCH	T1,(P)		;EXCH WITH ALTMODE TYPED FLAG
	JUMPGE	T1,QUICK1	;JUMP IF QUICK DIALOGUE - DONT TYPE MONITOR SIZE

;PRINT OCTAL SIZE OF MONITOR

	MOVEI	T1,[ASCIZ /
EXEC IS /]
	PUSHJ	P,ICONM
	MOVE	T1,SYSSIZ
	PUSHJ	P,OCTPNT##
	MOVEI	T1,[ASCIZ / OCTAL LOCATIONS LONG.
/]
	PUSHJ	P,CONMES
	PUSHJ	P,CRLF
	PUSHJ	P,OPOUT
QUICK1:			;THIS IS THE SHORT-CUT EXIT TO BY-PASS MOST OF THE DIALOGUE.
	POP	P,SYSSIZ	;RESTORE SYSSIZ PRIOR TO ACTUAL CREATION
				; OF DEVICE DATA BLOCKS


INTERNAL FTCHECK

IFN FTCHECK, <
	PUSHJ	P,CK		;CHECKSUM THE MONITOR AND SAVE THE ANSWER.
>

	JRST	@ONCE		;***EXIT FROM THE "ONCE-ONLY CODE"***...........



;ROUTINE TO FIND THE EXEC DDT SYMBOL TABLE POINTER AND MOVE IT TO THE PLACE
;WHERE EXEC DDT EXPECTS IT (DDTSYM=36)

;CALL:	JSR MOVSTP
;CALLED FROM MANDATORY ONCE ONLY CODE AND 141 START CODE (WHICHEVER OCCURS FIRST)

	EXTERNAL .JBSYM,.JBUSY,DDTX,SYSDDT

MOVSTP:	0			;JSR HERE FROM MANDATORY ONCE ONLY CODE AND
				; FIRST JUMP TO EXEC DDT IF BEFORE MONITOR STARTED
MOVJMP:	JRST	.+1		;PATCHED TO SETUUO AFTER FIRST EXECUTION
	MOVE	T1,.JBSYM	;ASSUME LOADED BY TIME SHARING MONITOR AND LOADER
	MOVEM	T1,DDTSYM	;STORE THE SYMBOL TABLE POINTER FOR EXEC DDT
	MOVE	T1,.JBUSY	;ALSO GET UNDEFINED TABLE
	MOVEM	T1,DDTUSY	;AND SAVE IT
	MOVEI	T1,DDTX		;MAKE SYSTEM STARTUP LOC(141) GO DIRECTLY  TO EXEC
				; DDT AND BY PASS THIS FOOLISHNESS 
	HRRM	T1,SYSDDT
	MOVEI	T1,SETUUO	;MAKE SURE THIS IS DONE ONLY ONCE
	HRRM	T1,MOVJMP
SETUUO:	JRST	@MOVSTP		;RETURN

;HERE IF EXEC DDT IS STARTED UP BEFORE MONITOR (TO MAKE A PATCH FOR EXAMPLE)

PATSYM::JSR	MOVSTP		;MOVE DDT SYMBOL TABLE POINTER SO EXEC DDT WILL
				; FIND IT AND PATCH 141 TO GO DIRECTLY TO EXEC DDT
	JRST	DDTX##		;AND GO DIRECTLY TO EXEC DDT
JRSTI1:	0

IFN FT2REL, <
;SET LOC TWOREG TO -1 IF MACHINE HAS TWO RELOC REG, TO 0 IF ONLY ONE RELOC REG

EXTERNAL TWOREG,SEGN,SEGPTR,AND2RG

IFN FTKI10!FTKL10,<
	MOVE	P3,.C0TYP##	;GET CPU TYPE
	PUSH	P,.EPPM##	;SAVE FIRST ENTRY IN EXEC MAP
	CAIN	P3,CT.KA	;IS THIS A KA10?
	JRST	JRSTI2		;YES
IFN FTKI10!FTKL10,<
	MOVE	T1,[JRST APRRES##]  ;POWER FAIL-AUTO-RESTART INSTR.
	MOVEM	T1,ARSLOC##	;STORE IN AUTO-RESTART LOCATION
>;END IFN FTKI10!FTKL10
	MOVEI	T1,PM.ACC+PM.WRT+0	;SETUP EXEC MAP
	HRLM	T1,.EPPM##	; SO THAT SHADOW ACS
	CAIN	P3,CT.KI
	DATAO	PAG,.C0EBR##	; PARITY ERRORS AND DDT
	CAIN	P3,CT.KL
	CONO	PAG,@.C0EBR##
	JRST	JRSTI3		; PAGE FAULTS ON SPY SEGMENTS
>
JRSTI2:	MOVE	P1,MPTRAP+1	;SAVE 41
	MOVE	P2,MPTRAP+2	;AND 42
	MOVE	T1,[JSR TSTAPR]	;REPLACE UUO JSR WITH A JSR HERE IN ONCE
	MOVEM	T1,MPTRAP+1
	MOVEM	T1,MPTRAP+2	;PUT A JSR IN CHANNEL 1 INTERRUPT LOCATION
	CONO	APR,674551	;TURN ON PI AND ASSIGN ILM FLAG, CLEAR
				; ALL APR FLAGS (DISABLE CLK)
				; FOR POSSIBLE ILLEGAL MEMORY REF BELOW
	CONO	PI,712300	;CLEAR PI SYSTEM, ACTIVATE PI SYSTEM AND CHANNEL 1
				;CLEAR MEMORY PARITY IN CASE ON, AND
				; DISABLE PARITY INTERRUPT
	DATAO	APR,[XWD 376776,000400]	;SET LOW AND HIGH SEG TO 128K LONG
					; EACH STARTING AT ABSOLUTE LOCATION 0
				; RELOC. FOR HIGH SEG IS 400000 TO DO THIS
	JRST	1,.+1		;ENTER USER MODE .+1
	MOVE	T1,400100	;TRY TO REFERENCE REL LOC 100 IN HIGH SEG
				; AVOID SHADOW ACS WHICH LIKELY HAVE BAD
				; PARITY CAUSED BY POWER TURN ON AND TURN OFF
JRSTI3:	MOVEI	17,400000	;MOVE HARDWARE AC'S INTO SHADOW AC'S TO CLEAR PARITY
				;IF HARDWARE AC'S TURNED OFF, AC'S WILL BE PRESERVED
	BLT	17,400017	;STOP WITH SHADOW AC 17
	SETZ	T2,		;ZERO AC T2
	SETOM	400000+T2	;SET SHADOW AC T2
IFN FTKI10!FTKL10,<
	CAIE	P3,CT.KA	;KA10?
	JRST	JRSTI4		;NO--SKIP ON
>
	CALL			;COME BACK TO EXEC MODE AT TSTAPR

TSTAPR:	0			;PLACE TO STORE JSR PC
	MOVEM	P1,MPTRAP+1	;RESTORE 41
	MOVEM	P2,MPTRAP+2	;AND 42
JRSTI4:	SETZM	TWOREG		;ASSUME NO SECOND REG.
	CONSO	APR,@.C0ILM##	;WAS MEMORY REF OUT OF BOUNDS ?
	SETOM	TWOREG		;NO, MUST HAVE SECOND REG. HARDWARE, SET -1
	CONO	APR,@.C0ILM##	;CLEAR APR FLAGS AGAIN
	MOVEI	T1,AND2RG	;=O IF SOFTWARE CANNOT HANDLE 2 SEG (NULSEG LOADED)
	ANDM	T1,TWOREG	;=-1 IF IT CAN (SEGCON LOADED)
				;TWOREG SET TO THE "LOGICAL AND" OF SOFTWARE AND
				; HARDWARE CAPABILITIES
	CONO	PI,10000	;CLEAR PI SYSTEM
IFN FTKI10!FTKL10,<
	POP	P,.EPPM##	;RESTORE EXEC MAP
>
	JUMPE	T2,FACOK	;FAST AC'S ARE TURNED ON
	MOVEI	T1,[ASCIZ/
[CPU0 FAST AC'S ARE OFF (FM ENB)]
/]
				;BECAUSE OF MULTI-PROCESSING WE HAVE
				;TO SET UP A TEMPORARY PUSH-DOWN LIST IN THE
				;AC'S FOR THE CALL TO CTYTYP
	PUSH	P,P1		;WE NEED TWO LOCATIONS + ONE FOR P
	PUSH	P,P2
	PUSH	P,P3
	MOVE	P1,P		;SAVE CURRENT PDP
	MOVEI	P,P1		;SET UP NEW PDL (P2-P3)
	PUSHJ	P,CTYTYP	;TYPE OUT MESSAGE
	MOVE	P,P1		;RESTORE OLD PDP
	POP	P,P3		;RESTORE SAVED AC'S
	POP	P,P2
	POP	P,P1
	MOVEI	T1,CPUN		;GET NUMBER OF CPU'S
	CAIE	T1,1		;IF ONLY ONE THEN FAST ACS ARE NOT NEEDED
	HALT	SYSDSP		;IF 2 OR MORE CPU'S THEN HALT. (SPLIT CYCLE ENABLED)

FACOK:
>
;SETUP LOCATIONS 40 THRU 61

	MOVE	T1,[XWD LOC40,40]	;SETUP LOWER CORE PI LOCATIONS
	BLT	T1,61
	MOVE	T1,[JRST NPDUFL##]	;STOP ON NULL PDL UNDERFLOW
	MOVEM	T1,NULPDL##	;STOP ON NULL PUSHDOWN LIST UNDERFLOW
IFN FTMS,<
	MOVEM	T1,NU1PDL##	;ALSO FOR CPU1
>
;LINK DEVICE SERVICE ROUTINES TOGETHER

	EXTERNAL INTNUM,INTTAB,INTTB1
IFN FTDISK,<EXTERN DDBNUM,KONINT,KOYPI>

	SKIPE	DEVLST		;HAVE SERVICE ROUTINES BEEN CHAINED TOGETHER YET ?
	JRST	@JRSTI1		;YES, MUST HAVE BEEN LOADED WITH BUILD
	MOVSI	T1,INTNUM	;NO, NEGATIVE NUMBER OF SERVICE ROUTINES*2
INTLOP:	LDB	U,PINTCH##	;GET NEXT PI NUMBER

IFN FTDISK,<
	LDB	J,DDBNUM	;NUMBER OF DDBS
	JUMPN	J,NTLVDD	;JUMP IF NOT LEVEL D DISK
	HRRZ	J,INTTB1(T1)	;ADDRESS OF DDB
	JUMPE	J,NTLVDD	;JUMP IF REALLY NO DDBS
	HLRZ	J,(J)		;IS LEVEL D DISK, GET LH OF DEVICE NAME
	CAIE	J,(SIXBIT .DSK.)	;SKIP IF IS REALLY A DISK
	JRST	NTLVDD		;NO
	MOVNI	J,KONINT	;YES, GET OFFSET FOR INTERRUP LOCS
	ADD	J,INTTAB(T1)	;PLUS INTERRUPT LOC=KONT DB
	DPB	U,KOYPI		;STORE PI CHANNEL
>	;END CONDITIONAL ON FTDISK

NTLVDD:	LSH	U,1		;SHIFT LEFT ONE SO MATCH PI LOCATIONS
	JUMPE	U,NOPICH	;DOES THIS DEVICE HAVE A PI CHANNEL (PTY) ?
IFN FTMS,<
	SKIPGE	INTTAB##+1(T1)	;IS THIS DEVICE TO GO ON SLAVE CHANNELS?
	SKIPA	J,.E1IL##(U)	;YES, GET CORRECT JRS CH1'N
>
	MOVE	J,.EPIL##(U)		;YES, PICK UP JSR CH'N FROM LOWER CORE
INTLP1:	MOVE	U,J		;SAVE IT IN U (EITHER A JRST DEV'NT OR
				; JEN @CH'N
	MOVE	J,1(U)		;PICK UP INSTR. FOLLOWING INTERRUPT CONSO
	TLNN	J,000740	;IS IT A JEN ?
	JRST	INTLP1		;NO, KEEP LOOKING
	MOVE	T2,INTTAB(T1)	;YES, LAST DEVICE SO FAR, GET DEV'NT
	HRLI	T2,(JRST)	;MAKE JRST INSTR.
	MOVEM	T2,1(U)		;CHANGE JEN @CH'N TO JRST DEV'NT
	MOVEM	J,1(T2)		;MAKE DEV'NT+1 BE JEN @CH'N
NOPICH:	AOBJN	T1,.+1		;PICKUP EVERY OTHER WORD
	AOBJN	T1,INTLOP	;ANY MORE INTERRUPT SERVICE ROUTINES ?
	JRST	@JRSTI1		;NO, EXIT
	EXTERNAL UUO40,UUO60,CH1,CH2,CH3,CH4,CH5,CH6,CH7

LOC40:	0			;UUO PC
INTERNAL UUOTRP
UUOTRP:	JSR	UUO40		;TO UUO HANDLER
	JSR	CH1
	JSR	PIERR##
	JSR	CH2
	JSR	PIERR##
	JSR	CH3
	JSR	PIERR##
	JSR	CH4
	JSR	PIERR##
	JSR	CH5
	JSR	PIERR##
	JSR	CH6
	JSR	PIERR##
	JSR	CH7
	JSR	PIERR##
	0		;LOC 60/61 TRAPPED TO FOR UNIMPLEMENTED OP CODES ON PDP-10
			;OP CODE 100 IS USED TO DISMISS USER MODE
			;INTERRUPTS (SEE TRPSET UUO)
	JSR	UUO60		;GO SEE IF OP CODE 100 OR SOME OTHER ONE
;ROUTINE TO READ A LINE FROM OPERATORS CONSOLE
;CALL:	PUSHJ P,GETLIN
;	JUST A CR TYPED IN
;	NORMAL RETURN (NOT A BLANK LINE)

	INTERNAL GETLIN,OPOUT,ICONM,YESNO
	EXTERNAL TPOPJ

GETLIN:	HRLOI	T1,377777	;DO NOT ALLOW A DEFAULT
	MOVEM	T1,DEFLAG	;STORE FLAG
GETLI0:	MOVE	T1,LINEP
	MOVEM	T1,ONCTIP	;INITIAL STORAGE POINTER
	MOVEI	T3,40		;PRIME COMMAND ROUTINES WITH A SPACE
	MOVEM	T3,TTCMCH	; ..
	MOVEI	J,0		;FLAG NO ALTMODE SEEN, ZERO CHARACTER COUNT (RH
				; OF J), CLEAR DELETE FLAG (LH OF J)
GET1:
	PUSHJ	P,XTYI		;WAIT FOR A CHARACTER
	SKIPGE	DEFLAG		;NEED A DEFAULT?
	ILDB	T3,DEFPTR	;YES--GET BYTE
	SKIPL	DEFLAG		;NEED A DEFAULT?
IFN FTKA10!FTKI10,<
	DATAI	TTY,T3		;GET IT
>
				;STRIP PARITY
IFN FTKL10,<
	MOVE	T3,FROM11	;GET CHAR FROM WHERE IT WAS SAVED
>
	ANDI	T3,177
	CAIN	T3,177		;RUBOUT?
	JRST	DELETE		;YES
	TLZE	J,1
	PUSHJ	P,BKSLSH	;TERMINAL BACKSLASH IF WE HAD BEEN DELETING
	CAIE	T3,"$"		;ACCEPT DOLLAR-SIGN AS AN ALT-MODE
	CAIN	T3,33		;ALTMODE/ESCAPE?
	JRST	GETLN1		;YES
	CAIE	T3,175		;OTHER ALTS?
	CAIN	T3,176		; ..
	JRST	GETLN1		;YES
GET2:	PUSHJ	P,XTYO		;ECHO
	CAIL	T3,140		;LOWER CASE?
	TRZ	T3,40		;YES. MAKE UPPER
	IDPB	T3,T1		;STORE IN INPUT BUFFER
	CAIE	T3,15		;CAR RET?
	AOJA	J,GET1		;NO. LOOP TILL BREAK
	MOVEI	T3,12		;YES. ADD LF
	PUSHJ	P,XTYO		;OUTPUT LF
	MOVEI	T3,0		;TERMINATE INPUT STRING IN BUFFER
	IDPB	T3,T1		; ..
	JUMPN	J,CPOPJ1	;IF NON-NULL LINE, SKIP RET
	POPJ	P,0		;NULL. NON-SKIP RET
DELETE:	TRNN	J,-1		;AT BEGINNING OF LINE ?
	JRST	DELET1		;YES
	TLON	J,1		;SET DELETE FLAG
	PUSHJ	P,BKSLSH	;TYPE BACKSLASH IF JUST STARTING TO DELETE
	LDB	T3,T1		;GET PREVIOUS CHARACTER
	PUSHJ	P,XTYO		;ECHO IT AS WE DELETE IT
	ADD	T1,[XWD 070000,0]	;BACK UP BYTE POINTER
	TLNE	T1,400000	;FINISHED THIS WORD YET ?
	ADD	T1,[XWD 347777,-1]	;YES, BACK UP ADDRESS
	SOJA	J,GET1

DELET1:	TLZE	J,1
	PUSHJ	P,BKSLSH	;TERMINAL BACKSLASH IF DELETED ANY CHARS
	MOVEI	T3,15
	PUSHJ	P,XTYO
	MOVEI	T3,12
	PUSHJ	P,XTYO
	JRST	GETLIN

BKSLSH:	PUSH	P,T3
	MOVEI	T3,134		;TYPE BACKSLASH
	PUSHJ	P,XTYO
	POP	P,T3
	POPJ	P,0

GETLN1:	MOVEI	T3,"$"		;OUTPUT DOLLAR SIGN IF ALT-MODE TYPED
	PUSHJ	P,XTYO
	HRROS	J		;MECHANISM USED TO BY-PASS PART OF DIALOGUE
	MOVEI	T3,15		; WHEN ALTMODE IS TYPED (J NEGATIVE ON
	JRST	GET2		; RETURN FROM GETLIN).
;ROUTINE TO TYPE A LINE ON OPERATOR CONSOLE
;ECHO CHECK STOPS LINE AND RETURNS
;CALL:	ONCTOP SET TO END OF MESSAGE


;CALL OPOUTX FOR MESSAGE CONTINUATIONS TO BE SUPPRESSED IF
; THE PREVIOUS PART OF THE MESSAGE WAS ^O'D
OPOUTX:	SKIPE	CNTRLO		;^O IN EFFECT ?
	PJRST	OTSET		;YES, JUST CLEAR BUFFER AND GO AWAY

OPOUT:	SETZM	CNTRLO		;CLEAR ^O FLAG
	MOVEI	T3,0		;MAKE SURE STRING ENDS
	IDPB	T3,ONCTOP	;WITH A NULL
	MOVE	T1,LINEP	;AND RESTART AT BEGINNING
	MOVEM	T1,ONCTOP	; ..
IFN FTKA10!FTKI10,<
	CONO	TTY,1000	;CLEAR INPUT FLAG
OPOUT1:	CONSZ	TTY,40		;MAKE SURE NOT BEING INTERRUPTED
	JRST	OPOUT2		;INPUT FLAG
>
IFN FTKL10,<
OPOUT1:	PUSHJ	P,SPCGTI##	;WAIT FOR INPUT, SKIP WITH CHAR IN T3
	  JRST	.+2		;NOT READY YET
	JRST	OPOUT2		;YES
>
	ILDB	T3,ONCTOP	;GET CHAR TO TYPE
	JUMPE	T3,CPOPJ	;QUIT ON NULL
	PUSHJ	P,XTYO		;TYPE CHAR
	JRST	OPOUT1		;LOOP

;HERE WHEN KEY STRUCK DURING TYPEOUT
OPOUT2:	SETOM	CNTRLO		;SET ^O FLAG
	MOVEI	T3,"^"
	PUSHJ	P,XTYO
	MOVEI	T3,"O"
	PUSHJ	P,XTYO
	MOVEI	T3,15
	PUSHJ	P,XTYO		;TYPE OUT CRLF
	MOVEI	T3,12
	PUSHJ	P,XTYO
IFN FTKA10!FTKI10,<
	CONO	TTY,1000	;CLEAR INPUT FLAG
>
	JRST	OTSET		;RESET OUTPUT BUFFER, RETURN FROM OPOUT

CNTRLO:	0			;SUPPRESS TYPE-OUT WHEN -1
IFN FTKA10!FTKI10,<
;WAIT TILL OUTPUT BUSY OFF BEFORE TYPING OUT CHAR.

	EXTERNAL TCONLN,PEVEN8	;CONSOLE LINE NUMBER, PARITY

XTYO:	PUSH	P,T1		;SAVE A WORKING AC
IFN FTMS,<	EXTERNAL .C0OK,TWOMAS,ONCCHK
	SETZM	.C0OK		;ZERO THE MASTER OK WORD
	SETZB	T1,ONCCHK	;INITIALIZE AC AND MEMORY WORD FOR CHECK
>
XTYO1:	PUSHJ	P,APRCHK	;CHECK CLOCK
IFN FTMS,<
	AOS	T1		;COUNT UP THE AC
	AOS	ONCCHK		;AND THE MEMORY WORD
	CAME	T1,ONCCHK	;ARE THEY STILL THE SAME (COULD BE CHANGED IN SYSINI)
	JRST	TWOMAS		;NO, GO TYPE OUT MESSAGE
>
	CONSZ	TTY,20
	JRST	XTYO1
	PUSHJ	P,PEVEN8
	DATAO	TTY,T3
	TRZ	T3,200
	PUSHJ	P,OPRFIL##	;ADD FILLERS
IFN FTMS,<
	SKIPGE	.C0OK		;IS THE MASTER ALREADY RUNNING MONITOR
	JRST	TWOMAS		;YES, THEN TYPE MESSAGE AND HALT
>
	JRST	TPOPJ
>
IFN FTKL10,<
XTYO:	PUSHJ	P,PEVEN8##	;GET GOOD PARITY FOR CHAR
	PUSHJ	P,SPCTYO##	;TYPE OUT
	PUSHJ	P,OPRFIL##	;DO FILLERS
XTYO1:	PUSHJ	P,APRCHK	;UPDATE TIME
	PUSHJ	P,SPCWTO##	;WAIT FOR OUTPUT DONE
	  JRST	XTYO1		;NOT DONE, WAIT SOME MORE
	ANDI	T3,177		;TAKE AWAY PARITY FOR COMPARES IN GETLIN
	POPJ	P,		;RETURN
>

;WAIT TIL INPUT DONE ON BEFORE RETURNING WITH NEXT CHAR.

	EXTERNAL .C0OK
XTYI:	PUSH	P,T1		;SAVE AN AC
IFN <FTKA10!FTKI10>&FTMS,<
	SETZM	.C0OK		;INITIALIZE MASTER OK WORD
	SETZB	T1,ONCCHK	; AND AC AND MEMORY LOCATION
>
XTYI1:	PUSHJ	P,APRCHK
IFN <FTKA10!FTKI10>&FTMS,<
	AOS	T1		;COUNT UP THE AC
	AOS	ONCCHK		; AND THE MEMORY LOCATION
	CAME	T1,ONCCHK	;ARE THEY STILL THE SAME?
	JRST	TWOMAS		;NO, THEN THERE MUST BE TWO CPU'S IN ONCE
>
	SKIPGE	DEFLAG
	JRST	XTYI2
IFN FTKA10!FTKI10,<
	CONSO	TTY,40
>
IFN FTKL10,<
	PUSHJ	P,SPCGTI##	;SKIP IF CHAR PRESENT, WITH IT IN T3
>;END IFN FTKL10
	JRST	XTYI1
IFN FTKL10,<
	MOVEM	T3,FROM11	;SAVE CHARACTER FOR USE LATER
>
	HRLOI	T1,777		;RESET THE TIMER
	MOVEM	T1,DEFLAG	; SO WE DON'T START UP
	MOVEM	T1,OPRCNT
	SETZM	DEFALW
IFN <FTKA10!FTKI10>&FTMS,<
	SKIPGE	.C0OK		;IS THERE ANOTHER CPU ALREADY STARTED
	JRST	TWOMAS		;YES, GO HALT THIS ONE
>
	JRST	TPOPJ		;RETURN AND RESTORE T1

;CHECK APR FOR CLOCK FLAG SO TIME USER TYPES IN WILL BE ACCURATE

APRCHK:
IFN FTKA10!FTKI10,<
	CONSO	APR,XP.CLK	;IS CLOCK FLAG ON?
>
IFN FTKL10,<
	CONSO	TIM,TI.ITD	;TIMER ON KL10 FINISHED WITH ITS TICK?
>
	POPJ	P,		;NO
IFN FTKA10!FTKI10,<
	CONO	APR,XP.CCF	;YES, CLEAR CLOCK FLAG
>
IFN FTKL10,<
	CONO	TIM,@ONCKLT	;YES, CLEAR INTERNAL TIMER DONE AND START UP AGAIN
>
	AOS	TIME		;INCREMENT TIME
	SOS	DEFLAG		;SEE IF TIME FOR DEFAULT
	POPJ	P,
XTYI2:	SETOM	DEFALW
	JRST	TPOPJ##

IFN FTKL10,<
ONCKLT::BLOCK	1		;PLACE TO KEEP BITS FOR KL10 INTERVAL TIMER
FROM11:BLOCK	1		;PLACE TO KEEP CHAR AFTER XTYO GETS IT
>

ONCTYO:	SOSLE	ONCCNT		;COUNT CHARACTERS
	IDPB	T3,ONCTOP	;PUT IN BUFFER
	POPJ	P,0		;AND RETURN

EXTERN TTCMCH

ONCTYI:	ILDB	T3,ONCTIP	;GET INPUT CHARACTER
	MOVEM	T3,TTCMCH	;STORE FOR RE-READS
	POPJ	P,0		;AND RETURN TO CALLING ROUTINE

TIMEIT:	CONO	APR,AP.IOR	;I/O RESET
	MOVEI	0,0		;CLEAR ITERATION COUNT
	MOVEI	U,^D25		;TIME FOR 25 TICKS
	CONO	PI,PI.CPI+PI.TNP+PI.ON+PI.SC1
				;CLEAR PI AND TURN ON PI CHANNEL 1
	CONO	APR,XP.CCF	;CLEAR THE CLOCK FLAG
	CONSO	APR,XP.CLK	;CLOCK FLAG?
	JRST	.-1		;NO, WAIT UNTIL IT COMES UP
	CONO	APR,XP.CCF+AP.ECI+1
				;CLEAR CLOCK FLAG, SET CLOCK ENABLE AND PIA=1
	JRST	T1		;EXECUTE ROTATE LOOP
TIMEI0:	SOJLE	U,TIMEI1	;25 TICKS YET?
	CONO	APR,XP.CCF+AP.ECI+1	;NO, CLEAR FLAG
	JEN	(17)		;AND DISMISS INTERRUPT
TIMEI1:	CONO	APR,AP.IOR	;DONE, RESET I/O
	CONO	PI,PI.CPI	;CLEAR CH1 PI IN PROGRESS SO WATCHERS WON'T GET SHOOK
	POPJ	P,		;AND RETURN
ICONM:	SETTYO			;INITIALIZE LINE BUFFER
	JRST	CONMES		;OUTPUT MESSAGE

INTERN OTSET
EXTERN COMTIA,COMTOA,ALTM	;ADDRESSES FOR COMMAND ROUTINES

OTSET:	MOVEI	T3,ONCTSZ	;SIZE OF BUFFER
	MOVEM	T3,ONCCNT	;SO CANT OVERFLOW
	MOVEI	T3,ONCTYI	;ADDRESS FOR READ ROUTINES TO GO TO
	MOVEM	T3,COMTIA	; ..
	MOVEI	T3,ONCTYO	;ADDRESS FOR TYPEOUT ROUTINES TO GO TO
	MOVEM	T3,COMTOA	; ..
	MOVE	T3,LINEP	;INITIAL OUTPUT POINTER
	MOVEM	T3,ONCTOP
	POPJ	P,0

YESNO:	PUSHJ	P,ASKGET	;ASK QUESTION, GET ANSWER
	  POPJ P,0		;JUST C-R
YESN:	PUSHJ	P,ALTM
	NEXTC
	TRZ	T3,40		;FIRST CHAR OF RESPONSE (U.C.)
	CAIN	T3,"Y"		;WAS IT A Y ?
	AOS	0(P)		;YES. SKIP
	POPJ	P,		;NO, MAYBE IT WAS "N". SO DON'T SKIP


	REPEAT	0,<
;SAME AS YESNO EXCEPT RETURN IS INVERTED (SKIP IF NO, NONSKP IF YES OR CR)
NOYES::	PUSHJ	P,ASKGET
	  POPJ	P,
	PUSHJ	P,YESN
	  AOS	(P)
	POPJ	P,
>	;END OF REPEAT 0

ASKGET:	PUSHJ	P,ICONM		;OUTPUT THE QUESTION
	PUSHJ	P,OPOUT
	PJRST	GETLIN		;GET ANSWER





IFN FTDISK, <
TTYWNZ::SETTYO
	POPJ	P,0

SKPWNZ::POPJ	P,0
>
;CONSTANTS AND PUSHDOWN LIST

ONCEPN=20
ONCEPD:	BLOCK	ONCEPN		;PUSHDOWN LIST
ONCTIP:	0			;TYPE-IN POINTER
ONCTOP:	0			;TYPE-OUT POINTER
ONCCNT:	0			;COUNTER FOR TYO
LINEP:	POINT	7,LINBUF	;INPUT AND OUTPUT LINE BUFFER
LINBUF:	BLOCK	BUFLEN		;LINE BUFFER (LONG ENOUGH FOR WHY RELOAD /H MESSAGE)
ONCTSZ=<BUFLEN*5>-1		;CHARACTERS WHICH FIT IN OUTPUT BUFFER

CRLFMS:	ASCIZ	/
/

;ASK A QUESTION WITH A DEFAULT ANSWER
;CALL WITH:
;	MOVEI	T1,[ASCIZ /QUESTION/]
;	MOVEI	T2,[ASCIZ /ANSWER/]
;	PUSHJ	P,ASKDEF
;	  RETURN HERE ON CRLF
;	ELSE RETURN HERE
;
ASKDEF::PUSH	P,T2		;SAVE T2
	PUSHJ	P,ICONM		;OUTPUT QUESTION
	PUSHJ	P,OPOUT		; ..
	POP	P,T1		;RESTORE ANSWER
	MOVE	T2,DEFSP	;GET BYTE POINTER
	HLL	T1,T2		; ..
ASKDF1:	ILDB	T3,T1		;COPY STRING
	IDPB	T3,T2		; ..
	JUMPN	T3,ASKDF1	; ..
	MOVEI	T3,15		;ADD ON A CR
	IDPB	T3,T2		; ..
	MOVE	T1,OPRCNT	;ALLOW 60 SEC.
	IMULI	T1,JIFSEC##	; ..
	MOVEM	T1,DEFLAG	;STORE AS A FLAG
	MOVEI	T1,1
	SKIPGE	DEFALW
	MOVEM	T1,DEFLAG
	MOVE	T1,DEFSP	;SETUP POINTER
	MOVEM	T1,DEFPTR	; ..
	JRST	GETLI0
DEFSP:	POINT	7,DEFBUF
DEFLAG:	-1
DEFPTR:	POINT	7,DEFBUF
DEFBUF:	BLOCK	24
OPRCNT:	EXP	^D60

DEFALW:	0			;-1 TO TAKE DEFAULT ALWAYS
;SUBROUTINE TO PUT A DECIMAL STRING INTO THE DEFAULT BUFFER
DECDEF:	MOVEI	T2,"0"		;ALWAYS FORCE 2 DIGITS
	CAIGE	T1,^D10		;WILL WE GET MORE THAN ONE ANYWAY?
	IDPB	T2,DEFPTR	;NO--ADD IN LEADING DIGIT
DCDFLP:	IDIVI	T1,12
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,DCDFLP
	HLRZ	T1,(P)
	ADDI	T1,"0"
	IDPB	T1,DEFPTR
	POPJ	P,0
INTERNAL FTCHECK
IFN FTCHEC, <

EXTERNAL CHKBEG,CHKEND,CHECK,MONPTR,MONSUM

CK:	MOVEI	T1,CHKBEG
	SUBI	T1,CHKEND
	HRLI	T1,CHKBEG
	MOVSS	T1
	PUSHJ	P,CHECK		;COMPUTE AND STORE CHECKSUM OF THE PURE AREA OF
	MOVEM	T2,MONSUM	; THE TIME-SHARING MONITOR.
	POPJ	P,
>


IFN FTDISK, <

INTERNAL REFLOG

REFLOG:	SETTYO
	PUSHJ	P,INLMES##	;CALLED BY DSKWNZ ROUTINE IN COMMON WHEN
				; ONE OR MORE DISKS HAVE BEEN REFRESHED.
	ASCIZ	/TO AUTOMATICALLY LOG-IN UNDER [1,2] TYPE "LOGIN"

/
	JRST	OPOUT
>

CPUBAD:	MOVEI	T1,[ASCIZ/?THIS MONITOR WAS BUILT FOR A /]
	PUSHJ	P,ICONM
	MOVE	T1,.C0TYP	;REPORT THE TYPE OF CPU IT WAS BUILT FOR
	MOVE	T2,CPTYPS-1(T1)
	PUSHJ	P,PRNAME##
	MOVEI	T1,[ASCIZ/ AND WILL NOT RUN PROPERLY ON A /]
	PUSHJ	P,CONMES
	MOVE	T2,CPTYPS-1(F)	;REPORT THE TYPE OF CPU CURRENTLY RUNNING ON
	PUSHJ	P,PRNAME
	PUSHJ	P,CRLF		;END IT PROPERLY
	PUSHJ	P,OPOUT		;NOW WRITE IT OUT ON DUM-DUM'S CTY
	HALT	.		;AND END THE NONSENSE

CPTYPS:	SIXBIT	/PDP-6/
	SIXBIT	/KA10/
	SIXBIT	/KI10/

MEMBAD:	MOVEI	T1,[ASCIZ /%MEMORY FROM /]
	PUSHJ	P,ICONM
	MOVE	T1,U
IFE FTOPRERR,<
	PUSHJ	P,OCTPNT##
>
IFN FTOPRERR,<
	PUSHJ	P,PRT22A##
>
	MOVEI	T1,[ASCIZ / TO /]
	PUSHJ	P,CONMES
	MOVE	T1,P3
	SUBI	T1,1
IFE FTOPRERR,<
	PUSHJ	P,OCTPNT##
>
IFN FTOPRERR,<
	PUSHJ	P,PRT22A##
>
	MOVEI	T1,[ASCIZ / IS OFF LINE
/]
	PUSHJ	P,CONMES
	PUSHJ	P,OPOUT
IFE FTMONL,<
	MOVEI	T1,[ASCIZ /DO YOU WANT IT TO BE 1) ON LINE, OR 2) DOWN? (TYPE #)
/]
>
IFN FTMONL,<
	MOVEI	T1,[ASCIZ/DO YOU WANT IT TO BE 1) ON LINE, 2) OFF LINE, OR 3) DOWN? (TYPE #)
/]
>
	MOVEI	T2,[ASCIZ /2	;DEFAULT/]
	PUSHJ	P,ASKDEF
	  JRST	MEMBAD
	PUSHJ	P,DECIN
	  JRST	MEMBAD
	  JRST	MEMBAD
	SOJE	T2,CPOPJ
IFN FTMONL,<
	SOJE	T2,CPOPJ2##
>
	SOSE	T2
	JRST	MEMBAD
CPOPJ1:	AOS	(P)
	POPJ	P,
SUNXMT::PUSH	P,P1		;SAVE WORKING ACS
	PUSH	P,P2
	PUSH	P,P3
	SETZB	T4,NXMTAB##	;ZERO HIGHEST EXISTANT ADDRESS SEEN, AND NXMTAB
	MOVE	T1,[NXMTAB##,,NXMTAB##+1]
	MOVEI	T2,NXMTAB##	; ..
	BLT	T1,NXMTBL##-1(T2)
	MOVEI	P1,CORBLK##	;NUMBER OF PAGES OF CORE POSSIBLE
	MOVE	T2,[POINT 1,NXMTAB##]
	MOVEI	T3,1		;TO MARK A PAGE AS NON-EXISTANT
	SETZB	P2,U		;ZERO P2 TO CALL A ROUTINE IN SYSINI,
				; START LOOKING FOR NXM AT 0
SUNXM0:
IFN FTKA10!FTKI10,<
	CONO	APR,NXM		;CLEAR NXM FLAG
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM  ;CLEAR NXM FLAG
>
			
	IBP	T2		;NEXT BYTE IN NXMTAB
	MOVEI	P3,MEMITL##	;NUMBER OF WAYS THE MEMORY CAN BE INTERLEAVED
SUNXM1:	PUSH	P,U		;SAVE THE CURRENT ADDRESS
	ADDI	U,-1(P3)	;CHECK PAGE PLUS INTERLEAVE OFFSET
	PUSHJ	P,REFMEM##	;REFERENCE TIS ADDRESS
	POP	P,U		;RESTORE THE CURRENT ADDRESS
	SOJG	P3,SUNXM1	;LOOK AT NEXT ADDRESS WITHIN THIS PAGE
	CONSO	APR,NXM		;NON-EXISTANT MEMORY SEEN?
	JRST	SUNXM2		;NO
	DPB	T3,T2		;YES, MARK THE PAGE AS NON-EXISTANT
	JUMPN	T4,SUNXM3	;JUMP IF THE LAST PAGE LOOKED AT WAS NXM
	SKIPA	T4,U		;NOT SO, SO REMEMBER THE ADDRESS OF HIGHEST
				; EXISTANT PAGE SEEN SO FAR
SUNXM2:	MOVEI	T4,0		;MEMORY EXISTS, HAVEN'T SEEN THE HIGHEST EXISTANT PAGE YET
SUNXM3:	ADDI	U,PAGSIZ##	;GO ON TO THE NEXT PAGE OF MEMORY
	SOJG	P1,SUNXM0	; PROVIDED ALL POSSIBLE MEMORY HASN'T BEEN CHECKED
SUNXM4:	IDPB	T3,T2		;ONES TO THE END OF THIS WORD IN NXMTAB
	TLNE	T2,770000	; ..
	JRST	SUNXM4		; ..
	SKIPN	T4		;SKIP IF THE HIGHEST POSSIBLE PAGE OF MEMORY DIDNT EXIST
	MOVE	T4,U		;IT DID, SO U CONTAINS THE ADDRESS OF THE HIGHEST PAGE
	POP	P,P3		;RESTORE ACS
	POP	P,P2
	POP	P,P1
	POPJ	P,
IFN FT2SEGMON,<
IFE FTEXE,<
BOOTWD=22			;DF-10 LOCS IN LOWER CORE
				; (LEVEL C RP-10 DF-10 LOCS)
LOWCMD=BOOTWD			;USE LOC 22 AND 23 FOR THE DF10

;I/O DEVICE PARAMETERS

DPC=250				;DEVICE KONTROLLER NUMBER FOR RP10
DPC2=254			;SECOND RP10
O.SEEK==4			;DISK OP FOR SEEK FOR RP10
O.READ==0			;DISK OP FOR READ FOR RP10
O.WRIT==1			;DISK OP FOR WRITE FOR RP10

FHD=170				;DEVICE NUMBER FOR RC10 KONTROLLER
FHD2=174			;SECOND RC10
FH.WRT==1000			;BIT IN DATAO FOR WRITE ON RC10

DHX==270			;FIRST RH10/RP04 DEVICE CODE
DHX2==274			;SECOND RH10/RP04
DH.RED==71			;READ
;FLAGS, RIGHT HALF OF S

R.KDEV=177			;BITS 29-35=KONTROLLER DEVICE CODE
R.TYPE==200			;TYPE OF UNIT ON KONTROLLER
R.DSKW==400			;WILD DISK NAME. TRY ALL.
R.SRIB==1000			;NEED TO SKIP A BLOCK (RIB AT START)
R.STRT==2000			;ON IF LOAD AND GO. OFF IF JUST LOAD


;SYSTEM PARAMETERS WHICH MUST AGREE WITH COMMOD

HOMBK1==1			;ADDRESSES OF HOME BLOCKS
HOMBK2==12			; ..
CODHOM=707070			;VERIFICATION CODE OF HOME BLOCK
CODRIB=777777			;VERIF CODE OF A RIB BLOCK
BLKCOD==176			;WORD ADDRESS OF VERIF CODE
BLKSLF==177			;WORD ADDRESS OF SELF POINTER
RIBFIR==0			;WORD ADDRESS OF RIB AOBJN PTR
RIBNAM==2			;W A OF NAME OF FILE IN THE RIB
RIBEXT==3			;W A OF EXT OF FILE IN THE RIB
RIBSIZ==5			;LENGTH OF FILE IN WORDS

HOMSNM==4			;STRUCTURE NAME IN SIXBIT
HOMLUN==10			;LOGICAL UNIT NUMBER (OCT) IN STR
HOMBSC==14			;BLOCKS PER SUPERCLUSTER IN HOME BLOCK
HOMSCU==15			;SUPERCLUSTERS PER UNIT
HOMCNP==16			;POINTER TO CLUSTER COUNT IN A RET PTR
HOMCKP==17			;POINTER TO CHECKSUM IN A RET PTR
HOMCLP==20			;POINTER TO CLUSTER ADDRESS IN A RET PTR
HOMBPC==21			;BLOCKS PER CLUSTER
HOMREF==23			;NEED TO REFRESH IF NON-ZERO
HOMCRS==41			;LBN IN STR OF CRASH.SAV RIB
HOMMFD==46			;LBN IN STR OF MFD RIB
;HERE WHEN FILE FOUND. FIRST RIB FOR FILE IS IN CORE.

RFILE:	MOVEI	P4,MONORG
RFILE1:	PUSHJ	P,RWORD
	  POPJ	P,
	MOVEM	W,(P4)
	AOJA	P4,RFILE1


;SUBROUTINE TO READ A DATA WORD FROM THE FILE.

RWORD1:	MOVE	P1,DBUFP	;PREPARE TO COUNT DATA WORDS
RWORD:	JUMPGE	P1,RWNXTB	;NEED ANOTHER BLOCK?
	MOVE	W,0(P1)		;NO. GET A WORD.
	AOBJN	P1,.+1		;COUNT IT.
	JRST	CPOPJ1		;RETURN FROM RWORD
RWNXTB:	PUSHJ	P,RDDATA	;NO. READ NEXT DATA BLOCK, IF ANY
	  POPJ	P,		;END OF FILE
	JRST	RWORD1		;READ FROM THIS BLOCK
;SUBROUTINE TO LOOK FOR FILE

LOOK:	MOVS	T1,DEVICE	;GET DEVICE NAME
	SKIPE	T1		;BLANK?
	CAIN	T1,(SIXBIT /DSK/)	;OR JUST DSK?
	TROA	S,R.DSKW	;YES. FLAG WILD DISK NAME
	JRST	LOOK1		;NO. USE SUPPLIED NAME
	MOVE	T1,[SIXBIT /DSK@/]	;START AT DSKA
	MOVEM	T1,DEVICE	;STORE NAME AWAY

LOOK2:	MOVEI	T1,010000	;INCREMENT WILD DSK NAME
	ADDB	T1,DEVICE	; ..
	TRNE	T1,200000	;TRIED UP TO DSKO?
	POPJ	P,		;YES. GIVE UP, IT AINT THERE.

LOOK1:	MOVE	T1,DEVICE	;DEVICE NAME TO LOOK FOR
	MOVEM	T1,STRUCT	;TO ARG OF SEARCH ROUTINE
	SETZM	SLUNIT		;CLEAR LOGICAL UNIT NUMBER
	PUSHJ	P,FNDUNI	;TRY TO FIND SUCH A UNIT
	  JRST NOTFND		;NOT THERE.
LOOK3:	SKIPN	F,PPN		;FIRST SEARCH FOR THE UFD
	MOVE	F,SYSPPN	;IF NONE, ASSUME 1,4
	MOVSI	U,(SIXBIT /UFD/)	;EXTENSION IS UFD FOR FILE DIR
	MOVE	T1,HBUF+HOMMFD	;LBN IN STR OF MFD RIB
	PUSHJ	P,SRCHFD	;SEARCH FOR THE REQUESTED UFD
	  JRST NOTFND		;NOT THERE.
	MOVE	F,FNAME		;NAME OF FILE TO SEARCH FOR
	MOVSI	U,(SIXBIT /SAV/)	;ASSUME SAV EXTENSION
	SKIPE	FEXT		;UNLESS ONE SUPPLIED
	HLLZ	U,FEXT		;IN WHICH CASE, USE IT.
	HRRZ	T1,1(T1)	;SUPERCLUSTER ADDRESS OF THE UFD
	IMUL	T1,HBUF+HOMBSC	;MAKE IT A BLOCK NUMBER
	PUSHJ	P,SRCHFD	;SEARCH FOR THE FILE IN THE UFD
	  JRST NOTFND		;NO SUCH FILE.
	HRRZ	M,1(T1)		;SUPERCLUSTER OF START OF THE FILE
	IMUL	M,HBUF+HOMBSC	;CONVERT TO LOGICAL BLOCK NUMBER
	PUSHJ	P,SETRIB	;GET THE RIB, CHECK IT
	  JRST NOTFND		;NO LUCK. ASSUME FILE NOT THERE.
	HLLZ	T1,RBUF+RIBEXT	;GET THE EXTENSION FROM RIB
	CAMN	T1,U		;DESIRED EXTENSION?
	CAME	F,RBUF+RIBNAM	;AND NAME?
	  PUSHJ P,ERROR		;NO. QUIT, RIB BAD.
	JRST	CPOPJ1		;SUCCESS RETURN

NOTFND:	TRNE	S,R.DSKW	;WILD DEVICE ARGUMENT?
	JRST	LOOK2		;YES. INCREMENT IT
	POPJ	P,
;SUBROUTINE TO SET UP A RIB BLOCK AND CHECK IT.

SETRIB:	PUSHJ	P,LBNSEL	;MAKE SURE ON RIGHT UNIT
	  POPJ P,0		;NOT THERE
	MOVEI	T1,RBUF-1	;ADDRESS OF THE RIB BUFFER
	PUSHJ	P,RDBLK		;READ THE FILE'S RIB
	  POPJ P,0		;COULDN'T READ IT
	SETZM	CLUCNT		;NO CLUSTERS LEFT
	SETZM	BLKCNT		;NO BLOCKS LEFT IN CLUSTER
	MOVE	T1,RBUF+RIBSIZ	;LENGTH OF FILE
	MOVEM	T1,LENGTH	;SAVE FOR EOF TEST
	TRO	S,R.SRIB	;WANT TO SKIP THE RIB WHEN READING
	MOVE	P2,RBUF+RIBFIR	;POINTER TO REAL RIB DATA
	JRST	CPOPJ1		;SUCCESSFUL RETURN
;SUBR TO SEARCH T1 UFD OR MFD FOR FILE & EXT.
; RIB M IN STR OF THE FD IN T1

SRCHFD:	SKIPG	M,T1		;STORE BLOCK TO READ RIB FROM.
	PUSHJ	P,ERROR		;SHOULDNT BE EOF
	PUSHJ	P,SETRIB	;SET UP THE RIB
	  POPJ P,0		;CAN'T READ IT
SCHL1:	PUSHJ	P,RDDATA	;READ THE FILE DIR DATA FROM THIS FD
	  POPJ P,0		;ERROR RETURN
	MOVE	T1,DBUFP	;POINTER TO THE DATA BUFFER
SCHL2:	MOVE	T2,0(T1)	;GET A FILE NAME
	CAME	T2,F		;IS NAME RIGHT?
	JRST	SCHN2		;NO. MOVE ON.
	HLLZ	T2,1(T1)	;CHECK THE EXTENSION
	CAMN	T2,U		;IS IT RIGHT TOO?
	JRST	CPOPJ1		;YES. GOOD RETURN, ANSWER AT (T1)
SCHN2:	AOBJN	T1,.+1		;MOVE ON TO NEXT FILE IN FD
	AOBJN	T1,SCHL2	;COUNT FILE, EXT. CHECK NEXT FILE IN FD
SCHN1:	JRST	SCHL1		;READ ON.

;SUBR TO SELECT CORRECT UNIT FROM M

LBNSEL:	MOVE	T1,M		;GET DESIRED BLOCK NUMBER
	MOVE	T2,HBUF+HOMBSC	;COMPUTE SIZE OF UNIT
	IMUL	T2,HBUF+HOMSCU	; ..
	IDIV	T1,T2		;SCALE LBN INTO A UNIT AND LOCAL LBN
	MOVE	M,T2		;LBN WITHIN THE UNIT
	CAMN	T1,HBUF+HOMLUN	;ALREADY AT THIS UNIT?
	JRST	CPOPJ1		;YES. NO NEED TO CHANGE UNITS
	MOVEM	T1,SLUNIT	;NO. NEED TO FIND IT.
	PUSH	P,M		;SAVE THE LBN WITHIN DESIRED UNIT
	PUSHJ	P,FNDUNI	;FIND THE UNIT
	  SOS -1(P)		;NOT THERE. SET FOR NON-SKIP RETURN.
	POP	P,M		;RESTORE UNIT LBN
	JRST	CPOPJ1		;AND SKIP RETURN.

;SUBROUTINE TO READ NEXT BLOCK OF DATA INTO DBUF

RDDATA:	SKIPGE	LENGTH		;ANY DATA LEFT?
	POPJ	P,0		;NO.
	MOVNI	T1,200		;SEE IF ANY LEFT
	ADDB	T1,LENGTH	;COUNT FILE SIZE DOWN
	PUSHJ	P,SELBLK	;SELECT NEXT DATA BLOCK OF FILE
	  POPJ P,0		;NONE LEFT.
	MOVEI	T1,DBUF-1	;SELECT DATA BUFFER
	PJRST	RDBLK		;READ THE BLOCK AND RETURN
				; SKIP RETURN IF NO ERROR
;SUBROUTINE TO SELECT NEXT BLOCK OF DATA
; THE DATA IS FOUND USING RIB'S STARTING AT 0(P2), OR
; IF STUFF LEFT OVER FROM CURRENT RIB, VIA CLUCNT, BLKCNT, CLBN

SELBLK:
SEL5:	AOS	M,CLBN		;ASSUME WILL USE NEXT BLOCK
	SOSL	BLKCNT		;ANY BLOCKS LEFT IN CURRENT CLUSTER?
	JRST	SEL1		;YES. GO PICK ONE.
	SOSL	CLUCNT		;ANY CLUSTERS LEFT IN CURRENT RET PTR?
	JRST	SEL2		;YES. PICK ONE.
SEL4L:	SKIPGE	P2		;FAIL IF OUT OF POINTERS
	SKIPN	T1,RBUF(P2)	;NEED ANOTHER RET PTR. EOF YET?
	POPJ	P,0		;YES. FAIL RETURN.
	AOBJN	P2,.+1		;COUNT POINTER FOR NEXT RIB
	MOVE	T3,HBUF+HOMCNP	;GET THE COUNT POINTER
	PUSHJ	P,RIBBYT	;GET COUNT OF CURRENT RET PTR
	JUMPN	T2,SEL3		;IF NON-ZERO, GO GET CLUSTER
	MOVE	T3,HBUF+HOMCLP	;NEW UNIT. GET UNIT LOGICAL NUMBER
	PUSHJ	P,RIBBYT	; ..
	CAMN	T2,HBUF+HOMLUN	;IS THIS UNIT RIGHT ALREADY?
	JRST	SEL4		;YES. DON'T SEARCH
	MOVEM	T2,SLUNIT	;NO. SAVE LOG UNIT NUMBER FOR SEARCH
	PUSHJ	P,FNDUNI	;FIND THE UNIT
	  POPJ P,0		;NOT FOUND. ERROR.
SEL4:	JRST	SEL4L		;READ NEXT RIB ON NEW UNIT

SEL3:	SUBI	T2,1		;COUNT CLUSTER ABOUT TO BE USED.
	MOVEM	T2,CLUCNT	;AND SAVE REMAINDER.
	MOVE	T3,HBUF+HOMCLP	;GET THE CLUSTER ADDRESS
	PUSHJ	P,RIBBYT	; ..
	IMUL	T2,HBUF+HOMBPC	;CONVERT TO AN LBN
	MOVEM	T2,M		;PUT IN CORRECT AC
SEL2:	MOVE	T1,HBUF+HOMBPC	;BLOCKS IN A CLUSTER
	SUBI	T1,1		;MINUS THE ONE ABOUT TO BE READ
	MOVEM	T1,BLKCNT	;SAVE THIS COUNT
SEL1:	MOVEM	M,CLBN		;SAVE CURRENT LBN
	TRZE	S,R.SRIB	;SKIP RIB?
	JRST	SEL5		;YES. GO THROUGH THIS ROUTINE AGAIN
;CHECKSUM HERE?
	JRST	CPOPJ1		;SUCCESSFUL RETURN FROM SELBLK
;ROUTINE TO FIND A PARTICULAR LOGICAL UNIT IN THE SYSTEM
;ARGUMENTS ARE: STRUCTURE F (SIXBIT) IN STRUCT, AND
;UNIT NUMBER WITHIN STRUCTURE IN SLUNIT.
;SKIP RETURN IF FOUND.

FNDUNI:	SETZM	TTYPE		;CLEAR SEARCH TEMPS
FNDUL1:	SETZM	TUNIT		; ..
FNDUL2:	MOVE	J,TTYPE		;GET KONTROLLER TYPE
	MOVE	P3,TUNIT	;AND UNIT NUMBER
	PUSHJ	P,HOME		;TRY TO READ ITS HOME BLOCK
	  JRST FNDUNX		;NO GOOD. ON TO NEXT.
	MOVE	T1,HBUF+HOMSNM	;FOUND THIS UNIT. IS IT DESIRED ONE?
	MOVE	T2,HBUF+HOMLUN	; ..
	CAMN	T1,STRUCT	;CHECK AGAINST SUPPLIED ARGS
	CAME	T2,SLUNIT	; ..
FNDUNX:	AOSA	T1,TUNIT	;NO GOOD. ON TO NEXT.
	JRST	CPOPJ1		;CORRECT. SKIP RETURN.
	CAIG	T1,UNIMAX	;TOO BIG?
	JRST	FNDUL2		;NO. GO CHECK THIS ONE
	AOS	T1,TTYPE	;YES. COUNT TO NEXT TYPE OF KONTROLLER
	CAIG	T1,TYPEMX	;ALL OF THOSE GONE BY?
	JRST	FNDUL1		;NO. TRY THIS ONE.
	POPJ	P,0		;ALL TRIED. GIVE FAIL RETURN.

RIBBYT:	HRRI	T3,T1		;WHERE THE WORD IS
	LDB	T2,T3		;GET THE DESIRED BYTE
	POPJ	P,0		;AND RETURN
;ROUTINE TO DETERMINE WHETHER A UNIT EXISTS, AND IF SO, TO READ
;ITS HOME BLOCK INTO THE HOME BUFFER

;CALLING SEQUENCE:
;J/	KONTROLLER TYPE INDEX
;P3/	UNIT NUMBER, 0-7
;	PUSHJ P,HOME
;	  NOT THERE RETURN
;	OK RETURN

;AT THIS POINT, ANY NEEDED UNIT PARAMETERS ARE SAVED, SUCH AS R.TYPE
; AND THE HOME BLOCK IN HBUF
HOME:	TRZ	S,R.TYPE	;ASSUME UNIT TYPE IS RD10 OR RP02
	MOVEM	P3,CUNIT	;SAVE CURRENT UNIT NUMBER
	MOVEM	J,CTYPE		;AND KONTROLLER TYPE
	MOVE	T3,J
	LSH	T3,-1		;DF10C CONI BIT FOR APPROPRIATE CONTROLLER
	MOVE	T3,[40000,,0
		       20,,0
		     4000,,0](T3)
	MOVEM	T3,DFBIT	;STORE THE BIT IN CORE.
	MOVEI	T3,UNIINI	;ABS ADR OF INI TABLE BASE(ARG FOR SETCHN)
	TLO	T3,J		;SET INDEX FIELD FOR RELOCATION BY J(KONT. TYPE)
	LDB	T1,[POINT 7,@T3,9]	;KONTROLLER DEVICE CODE FROM INI TABLE
	TRZ	S,R.KDEV	;CLEAR KONTROLLER FIELD
	TRO	S,(T1)		;SET KONTROLLER FIELD
	MOVEI	M,HOMBK1	;WANT TO READ FIRST HOME BLOCK
	MOVEI	T1,DBUF-1	;BUFFER FOR TEST I/O
	PUSHJ	P,SETCHN	;SET UP CHANNEL COMMAND LIST
				; AND CALL INITIALIZE KONT. ROUTINE
	  POPJ P,0		;ERROR. NOT THERE.
HOM1:	MOVEI	T1,HBUF-1	;READ HOME BLOCK INTO ITS BUFFER
	PUSHJ	P,RDBLK		;TRY TO READ THE HOME BLOCK
	  JRST HOM2		;CAN'T READ THAT ONE
	MOVE	T1,HBUF+BLKCOD	;GET THE CODE WORD
	CAIN	T1,CODHOM	;IS IT RIGHT?
	SKIPE	HBUF+HOMREF	;AND NOT NEEDING REFRESHING?
	JRST	HOM2		;NO GOOD.
	JRST	CPOPJ1		;OK RETURN.

HOM2:	CAIN	M,HOMBK2	;TRIED BOTH BLOCKS?
	POPJ	P,0		;YES. GIVE FAIL RETURN
	MOVEI	M,HOMBK2	;NO TRY ANOTHER ONE.
	JRST	HOM1		;READ SECOND HOME BLOCK

;INITIALIZE KONTROLLER ROUTINES (CONSO IRRELEVANT - USED TO GET DEVICE CODE

UNIINI:	CONSO	FHD,FHDINI	;FIRST FHD
	CONSO	FHD2,FHDINI	;SECOND FHD
	CONSO	DPC,DPCINI	;FIRST DPC
	CONSO	DPC2,DPCINI	;SECOND DPC
	CONSO	DHX,DHXINI	;FIRST DHX
	CONSO	DHX2,DHXINI	;SECOND DHX
TYPEMX==.-UNIINI-1		;MAXIMUM KONTROLLER ROUTINE
UNIMAX==7			;MAX NUMBER OF UNITS ON A KONTROLLER
;INITIALIZATION FOR RC10 FIXED HEAD DISK/DRUM

FHDINI:	CAILE	P3,3		;ONLY 3 UNITS ON FHD KONTROLLER
	POPJ	P,0		;ASKED FOR UNIT OVER 3. ERROR RETURN.
	ROT	P3,-2		;INTO UNIT NUMBER FIELD
	TLO	P3,160		;TRACK 0, SECTOR 70 BCD. ILLEGAL ON RM10B
	HRRI	P3,LOWCMD	;CHANNEL COMMAND ADDRESS
	MOVE	T3,[DATAO P3]	;SET UP DATAO FROM P3
	PUSHJ	P,IOXCT		;PERFORM DATAO ON RIGHT DEVICE
	PUSHJ	P,IOWAIT	;WAIT FOR DONE OR TIMEOUT
	JUMPLE	T2,CPOPJ	;QUIT IF TIMED OUT
	MOVEI	T1,170220	;ERROR FLAGS?
	PUSHJ	P,IOCNSZ	;DO A CONSZ
	POPJ	P,0		;ERRORS OR NOT DONE. FAIL RETURN
	MOVEI	T1,200000	;SEARCH ERROR?
	PUSHJ	P,IOCNSZ	; ..
	TRO	S,R.TYPE	;YES. PROBABLY A DRUM.
	JRST	CPOPJ1		;GIVE GOOD RETURN

;INITIALIZATION FOR PACKS

DPCINI:	CAILE	P3,7		;LEGAL DRIVE NUMBER?
	POPJ	P,0		;NO. NON-EXISTENT RETURN.
	DPB	P3,PDRIVE	;SAVE FOR IO
	MOVEI	T1,37		;T1 BAD SURFACE FOR ALL PACKS
	DPB	T1,PSURF	;STORE FOR DATAO
	DPB	P3,PSEC		;STORE FOR DATAO
	MOVE	T3,[DATAO DATAOW]	;SET UP T1 DATAO TO PACKS
	PUSHJ	P,IOXCT		;DATAO ON RIGHT DEVICE
	PUSHJ	P,IOWAIT	;TIMEOUT OR DONE FLAG
	JUMPLE	T2,CPOPJ	;TIMED OUT?
	MOVEI	T1,2000		;DRIVE NOT THERE?
	PUSHJ	P,IOCNSZ	; ..
	POPJ	P,0		;NOT THERE. ERROR RETURN.
	MOVE	T3,[DATAI T1]	;SET UP TO GET UNIT TYPE
	PUSHJ	P,IOXCT		; ..
	TRNE	T1,2000		;SKIP IF NOT RP03
	TRO	S,R.TYPE	;FLAG AS RP03
	JRST	CPOPJ1		;SUCCESS RETURN

;INITIALIZATION FOR RH10/RP04

DHXINI:	CAILE	P3,7
	POPJ	P,
	MOVSI	T1,60000(P3)
	PUSHJ	P,IODTI		;READ DRIVE TYPE REGISTER
	LDB	T2,[POINT 9,T1,35]
	TLNN	T1,5000
	CAIE	T2,20
	POPJ	P,		;NO DEVICE OR NOT AN RP04
	MOVSI	T1,4000(P3)
	HRRI	T1,23		;DO A PACK ACKNOWLEDGE
	PUSHJ	P,IODTO		;JUST IN CASE
	JRST	CPOPJ1

IODTI:	MOVE	T3,[DATAO T1]
	PUSHJ	P,IOXCT
	TLZA	T3,100		;TURN IT INTO A DATAI
IODTO:	MOVE	T3,[DATAO T1]
	PJRST	IOXCT

IOWAIT:	SETOB	T1,T2		;LOOK FOR ALL FLAG BITS
	PUSHJ	P,IOCNSO	;ANYTHING THERE?
	  POPJ P,0		;NO SUCH DEVICE AT ALL
	MOVEI	T2,^D50000	;TIMEOUT
	MOVEI	T1,10		;DONE FLAG, ALL KONTROLLERS
	PUSHJ	P,IOCNSO	;LOOK FOR DONE
	SOJG	T2,.-2		;NOT YET. COUNT DOWN AND LOOP
	POPJ	P,0		;DONE OR TIMED OUT.
;ROUTINE TO READ T1 BLOCK FROM THE DEVICE KONTROLLER AND UNIT IN
;CTYPE AND CUNIT INTO THE BUFFER AT (T1)+1, FROM LOGICAL BLOCK NUMBER
;IN LBN. SKIP RETURN IF SUCCESSFUL, NON-SKIP IF ANY HARDWARE ERRORS

RDBLK:	PJSP	T3,SETCHN	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER READ ROUTINE BELOW DEP. ON TYPE

	Z	FHDRED		;RC10
	Z	FHDRED		;SECOND FHD
	Z	DPCRED		;RP10
	Z	DPCRED		;SECOND RP10
	Z	DHXRED		;RH10/RP04
	Z	DHXRED		;SECOND RH10/RP04

;SUBROUTINE TO SETUP CHANNEL, THEN DISPATCH TO DEVICE DEP ROUTINE
;CALL:	MOVEI T1,ABS. ADR. OF FIRST DATA WORD-1
;	HRRI T3,ABS. ADR. OF FIRST WORD IN DISPATCH TABLE
;	PUSHJ P,SETCHN
;	ERROR RETURN
;	OK RETURN

SETCHN:	HRRM	T1,LOWCMD	;SAVE ADDRESS
	MOVE	J,CTYPE		;GET CONTROLLER TYPE
	ADD	J,T3		;ADDRESS OF TABLE ENTRY
	MOVE	T3,[CONI T3]	;READ THE CONI BITS
	PUSHJ	P,IOXCT		; ..
	MOVSI	T2,-200		;ASSUME 18 BIT DF10
	TDNE	T3,DFBIT	;SKIP IF NOT DF10-T3
	LSH	T2,4		;22-BIT DF10 MOVE WORD COUNT
	HLLM	T2,LOWCMD	;STORE COMMAND
	SETZM	LOWCMD+1	;ALSO CLEAR FINAL CONTROL WORD ADDR
	SKIPG	T1,M		;GET AND CHECK BLOCK NUMBER
	PUSHJ	P,ERROR		;SHOULD BE .GT. 0
	PJRST	@(J)		;CALL DISPATCH ENTRY AS A SUBROUTINE RETURN
;READ FROM RC10. LBN IS IN T1, CHANNEL IS SET UP FOR ONE BLOCK (128 WDS)
;R.TYPE=0 IF RD10, 1 IF RM10B. UNIT NUMBER IS IN CUNIT, AND IS
;ASSUMED LEGAL.
;NOTE:	AN RD10 DISK HAS 200. TRKS OF 80. SECT OF 32. WDS =4000.*128. WDS
;	AN RM10B DRUM HAS 90. TRKS OF 60. SECT OF 64. WDS =2700.*128. WDS

FHDRED:	PUSHJ	P,FHDCNV	;SET UP DATAO WORD WITH ITS BCD STUFF
	MOVE	T3,[DATAO P3]	;SET UP DATAO TO RC10
	PUSHJ	P,IOXCT		;DO THE DATAO TO RIGHT DEVICE
	PJRST	DPCWAT		;WAIT FOR IO AND CHECK ERRORS
				; SKIP RETURN IF NO ERRORS.

FHDCNV:	MOVEI	T3,^D20		;ASSUME RD10
	TRNE	S,R.TYPE	;WHICH IS IT?
	MOVEI	T3,^D30		;RM10B
	IDIVI	T1,0(T3)	;T1_TRACK, T2_#OF 128 WORD SECTOR ON TRK
	PUSH	P,T2		;SAVE SECTOR*P3
	IDIVI	T1,12		;CONVERT TO BCD
	CAIL	T1,12		;..
	ADDI	T1,6		; ..
	LSH	T1,4		;POSITION TRACK ADR
	IOR	T1,T2		;BOTH DIGITS
	ROT	T1,-13		;TO PLACE FOR DATAO
	EXCH	T1,0(P)		;SAVE ON STACK. GET SECTOR ADDR
	LSH	T1,1		;TO 64. WD "SECTORS"
	TRNN	S,R.TYPE	;RD10?
	LSH	T1,1		;YES. MAKE IT 32. WD SECTORS
	IDIVI	T1,12		;NOW CONVERT TO BCD
	LSH	T1,4		;SHIFT HIGH DIGIT LEFT
	IOR	T1,T2		;OR IN LOW DIGIT
	HRLZS	T1		;POSITION FOR DATAO
	IORM	T1,0(P)		;STORE SECTOR
	MOVE	T1,CUNIT	;GET UNIT NUMBER
	ROT	T1,-2		;POSITION FOR RC10 DATAO
	IORM	T1,0(P)		;COMPLETE WORD
	POP	P,P3		;RESTORE TO AN AC
	TRO	P3,LOWCMD	;PUT IN CHANNEL ADDRESS
	POPJ	P,0		;DONE AT LAST
;READ ROUTINES FOR THE DISK PACKS

DPCRED:	PUSHJ	P,DPCCNV	;CONVERT AND SEEK FOR BLOCK
	  POPJ P,0		;BAD BLOCK NUMBER
	MOVEI	T1,O.READ	;SET OPERATION TO READ BLOCK
	JRST	DPCOPR		;READ THE BLOCK (CHANNEL ALL SET)

DPCCNV:	IDIVI	T1,12		;GET SECTOR NUMBER
	DPB	T2,PSEC		;SAVE IT
	IDIVI	T1,24		;GET SURF AND CYL
	DPB	T2,PSURF	;STORE SURFACE
	DPB	T1,PCYL		;STORE CYLINDER
	HRRZI	T2,200000	;EXTENDED CYLINDER ADDRESS IF RP03
	TRZE	T1,400		;SKIP IF NOT EXTENDED CYLINDER
	IORM	T2,DATAOW	;IS EXTENDED, SET PROPER BIT
	MOVE	P3,CUNIT	;CURRENT UNIT
	DPB	P3,PDRIVE	;STORE THAT TOO.
	TRNN	S,R.TYPE	;SKIP IT RP03
	CAIG	T1,^D202	;NOT RP03, SKIP IF CYLINDER NOT ON DISK
	CAILE	T1,^D405	;RP03 - SKIP IF OK
	PUSHJ	P,ERROR		;TOO BIG A LBN
	MOVEI	T1,O.SEEK	;MAKE DISK SEEK TO THE CYLINDER
DPCOPR:	DPB	T1,OPPNT	;STORE THE OPERATION
	MOVE	T3,[DATAO CLRATN]	;SET UP DATAO
	PUSHJ	P,IOXCT		;DO DATAO WITH RIGHT DEVICE
	HRRI	T3,DATAOW	;NEW ADDRESS(R IN INDEX FIELD ALREADY)
	XCT	T3		;SEND THIS WORD TOO

;SUBROUTINE TO WAIT FOR IO AND CHECK ERRORS

DPCWAT:	PUSHJ	P,IOWAIT	;WAIT FOR DONE FLAG OR TIMEOUT
	JUMPLE	T2,CPOPJ	;IF TIMED OUT, GIVE UP.
	MOVEI	T1,177720	;ANY ERRORS?
				;FALL INTO IOCNSZ(SKIP RETURN IF GOOD)

IOCNSZ:	SKIPA	T3,[CONSZ 0(T1)]	;SET UP I/O INSTR.
IOCNSO:	MOVSI	T3,(CONSO (T1))	;SETUP IO INSTR.
IOXCT:	DPB	S,[POINT 7,T3,9]	;PUT IN I/O DEVICE FIELD
	XCT	T3		;DO THE IO
	POPJ	P,		;NO SKIP RETURN
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;NO SKIP RETURN
;READ ROUTINES FOR RH10/RP04

DHXRED:	HRLI	P3,DH.RED
	IDIVI	T1,^D380
	HRLI	T1,124000(P3)
	PUSHJ	P,IODTO		;DESIRED CYLINDER
	IDIVI	T2,^D20
	DPB	T2,[POINT 5,T3,27]
	MOVSI	T1,54000(P3)
	HRR	T1,T3
	PUSHJ	P,IODTO		;DESIRED SECTOR, SURFACE
	MOVS	T1,P3
	TDO	T1,[404000,,200000!LOWCMD_6]
	PUSHJ	P,IODTO		;START THE IO
	PUSHJ	P,IOWAIT
	JUMPLE	T2,CPOPJ
	MOVSI	T1,10000(P3)
	PUSHJ	P,IODTI		;READ STATUS REGISTER
	TRNE	T1,40000
	POPJ	P,
	MOVEI	T1,736320
	PJRST	IOCNSZ


SYSPPN:	XWD	1,4		;DEFAULT PROJ-PROG
SYSTEM:	SIXBIT	/SYSTEM/	;DEFAULT FILENAME
CRASH:	SIXBIT	/CRASH/		;DEFAULT DUMP F
DBUFP:	XWD	-200,DBUF	;POINTER TO DATA BLOCK
BLTXWD:	XWD	40,41		;FOR CORE-CLEARING
SIXPTR:	XWD	440600,W	;POINTER FOR SIXBIT F

PDRIVE:	POINT	3,DATAOW,5	;DRIVE NUMBER FOR DATAO
PCYL:	POINT	8,DATAOW,13	;CYLINDER NUMBER FOR DATAO
PSURF:	POINT	5,DATAOW,18	;SURFACE NUMBER FOR DATAO
PSEC:	POINT	5,DATAOW,23	;SECTOR NUMBER FOR DATAO
OPPNT:	POINT	3,DATAOW,2	;OPERATION FOR DATAO
CLRATN:	XWD	500000,776	;CLEAR ATTENTION FLAGS.
DATAOW:	EXP	LOWCMD		;LOW CORE ADR FOR DF10

SWITCH:	BLOCK	1
CTYPE:	BLOCK	1
CUNIT:	BLOCK	1
TTYPE:	BLOCK	1
TUNIT:	BLOCK	1
STRUCT:	BLOCK	1
SLUNIT:	BLOCK	1
CLUCNT:	BLOCK	1
BLKCNT:	BLOCK	1
CLBN:	BLOCK	1
LENGTH:	BLOCK	1
DFBIT:	BLOCK	1

;BUFFERS FOR HOME BLOCK, DATA, AND RIB
HBUF:	BLOCK	200
RBUF:	BLOCK	200
DBUF:	BLOCK	200
ERROR:	STOPCD	.,HALT,HNF,	;++HI-SEG NOT FOUND
>;END IFE FTEXE
> ;END FT2SEGMON
;MONITOR EXPECTS TO FIND DEVICE, FILE, U AND PPN HERE
DEVICE:	BLOCK	1
FNAME:	BLOCK	1
FEXT:	BLOCK	1
PPN:	BLOCK	1

RADIX 10
MONTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334

RADIX 8

XLIST	;LITERALS

LIT


LIST

VAR
	$HIGH
MONTOP==.-1
	$LOW
ONCEND:	END
 !q3z