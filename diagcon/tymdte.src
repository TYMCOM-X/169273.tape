 
.TITLE  TYMDTE   DTE20 DIAGNOSTIC                VER. 1.0
                MCNNUM=1
                VERNUM=0
                MAXADD=157776   ;28K CORE REQUIRED
                DTEASB=1        ;ASSEMBLE DTE20 DEFS
                $DTE=1          ;DON'T ASSEMBLE FUNCTION BREAKPOINTS
                KWASB=1         ;ASSEMBLE CLOCK PARAMETERS
                RELEASE=-1
                .NLIST CND,TOC,BEX
                .ENABL  ABS,AMA
                .=3000



                ;COPYRIGHT (C) 1975, 1976, 1977, 1978
                ;DIGITAL EQUIPMENT CORP.
                ;146 MAIN STREET, MAYNARD, MASS.

                ;ASSEMBLE AS FOLLOWS:
                ;DGDTET,PRM11,DIACON,DGDTE,STOR11


.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,RO           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN RO, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #




























;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUCTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL-=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*200+<I*100+<XR*4>>+<ADH/2>>
 M .BYTE <DP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST
  .BYTE <ADL&377>,<<ADL/400>!ADH*200&377>>,<XOP&1*200*<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM











































































































































































































































































































































































































.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE















































































































































































































































































































































































.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN   .LIST    SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        SWITCH                  ;GET SWITCH REG
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>






        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        JSR     PC,(R3)                 ;DO INITIALIZATION
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
CONVRG:        .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR REPORTING SUBROUTINES    15-JUL-77
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


.SBTTL          SCOPE SYNC SUBROUTINES  16-MAR-77
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SUNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN AALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     CONSOL          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        ASDSH=55        ;DASH
        ASQT=42 ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        ESTSIZ=100      ;ERR STACK SIZE
        OVERLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FTNON           ;14 - FT8 NOT USED
        FTT     FTNON           ;20 - FT9 NOT USED
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTNON           ;30 - FTMEM NOT USED
        FTT     FTPRM           ;32
        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %



.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S=4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S=4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

        
.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-5
        %


.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %


.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+7     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT:         PMSG    <\TEST NUMBER - >
        MOV     R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;RINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESES THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT


.SBTTL          REPORT HEADINGS

        ;ERROR REPORT HEADINGS AND "NOISE WORD"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>


.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER



.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER



.REM    %
        STACK ENTRY IS 16-BIT EXPECED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
STACK POINTS TO BYTE POOINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN FMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER



;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT         ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,39.,25.,27.,0.,23.,12. ;30-39
        .BYTE   28.,12.,28.,12.,28.,11.,10.,30.,22.,12. ;40-49
        .BYTE   28.,12.,28.,12.,24.
                                                        ;50-54
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
U       UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        RTS     PC


;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ157

.SBTTL  *CONSTANTS,ADDRESSES,BIT ASSIGNMENTS, AND WORK LOCATIONS

DLYCNT: 0
DEXWD3: 0
DEXWD2: 0
DEXWD1: 0
TENAD1: 0
TENAD2: 0
TO10BC: 0
TO11BC: 0
TO10AD: 0
TO11AD: 0
TO10DT: 0
TO11DT: 0
DIAG1:  0
DIAG2:  0
STATUS: 0
DIAG3:  0

SAVE:   0               ;TEMPORARY STORAGE
P1FLG1: 0               ;FIRST PASS FLAG
P1NPRF: 0               ;PASS 1 NPR FLAG.
P1INTF: 0               ;PASS 1 INTERRUPT FLAG.
LOWADD: 0               ;ADDRESS OF LOWEST 10/11 INTERFACE
TABLE:  .BLKW   4       ;4 WORD TABLE FOR EXISTING DTE ADDRESSES
        .WORD   175434  ;ADDRESS IN 2ND LP20 SPACE
VECTOR: 0               ;RECEIVES ADDRESS OF VECTORED INTERRUPT FOR
                        ;INTEFACE BEING TESTED
NPRLOC: 0               ;NPR'S WILL BE DIRECTED TO THIS ADDRESS
TIMOFG: 0               ;BUS TIMEOUT FLAG.
MASK:   0               ;RECEIVES COMPARISON PRINTER MASK
RMFLAG: 0               ;FLAG TO INDICATE RESTRICTED DTE20
FILL5:  .ASCIZ  %TF 5%  ;KLDCP TTY FILL 5 COMMAND
MR:     .ASCIZ  %MR%    ;KLDCP MASTER RESET COMMAND
        .EVEN

;SEQ158

.SBTTL  *COMMON SUBROUTINES
;
;PULSE (NO BIT9)
;
DIAGPU: MOV     #PULSE!D1011,@DIAG1     ;PULSE THE CLOCK
        NOP
        NOP
        RTS     PC

;PULSE

DIAG9P: MOV     #DS05!PULSE!D1011,@DIAG1
        NOP
        NOP
        RTS     PC

;DIAGNOSTIC RESET

DIAGRT: MOV     #DRESET,@DIAG2  ;DIAGNOSTIC RESET
        NOP
        NOP
        RTS     PC

;SET DIAG MODE

DIAGME: MOV     #D1011,@DIAG1   ;SET DIAGNOSTIC MODE
        NOP
        NOP
RTS     PC

TOTRAP: MOV     #-1,TIMOFG      ;SET TO IND TIMEOUT
        RTI

;DO A MASKED COMPARE

MCMP16: MOV     ACTUAL,R0       ;GET ACTUAL
        BIC     CORECT,R0       ;CLEAR OUT EXPECTED DATA
        BIC     MASK,R0 ;CLEAR OUT MASKED BITS
        RTS     PC      ;RO = ANY BITS IN ERROR

;SEQ159

;SETS ACTUAL = DIAGNOSTIC WORD 2 & SETS MASK TO ALL BUT RFMAD'S

RAMASK: MOV     @DIAG2,ACTUAL           ;GET ADIAGNOSTIC WORD 2.
        MOV     #^C<RFMAD0!RFMAD1!RFMAD2!RFMAD3>,MASK   ;GET RID OF ALL BUT RFMAD'S
        RTS     PC

;MACRO DEFINITIONS
.MACRO  DIAGRS
        JSR     PC,DIAGRT       ;DIAGNOSTIC RESET
.ENDM

.MACRO  DIAGMD
        JSR     PC,DIAGME       ;SET DIAGNOSTIC MODE
.ENDM

.MACRO  DIAGP9
        JSR     PC,DIAG9P               ;PULSE
.ENDM

.MACRO  DIAGPL
        JSR     PC,DIAGPU               ;PULSE
.ENDM

.MACRO  MCMP16
        JSR     PC,MCMP16               ;MASKED 16-BIT COMPARE
.ENDM
;CORRECT AND ACTUAL DATA REGISTERS

CORECT: 0
ACTUAL: 0
DTE1=174400
DTE2=174440
DTE3=174500
DTE4=174540
PRTOFF=BIT11
DRESET=BIT6

;SEQ160

.SBTTL  *INITIALIZATION AND TEST DISPATCH TABLES

TESTAB: <LASTST-TESTAB>/2       ;TEST COUNT
        ADDR3                   ;TEST1
        REST1
        DIA1
        ADDR4
        ADDR5
        ADDR6
        STAT1
        STAT2
        STAT3
        STAT4                   ;TEST10
        RM1
        RM2
        RM3
        RM4
        INT1
        INT2A
        INT2B
        INT2C
        INT2D
        INT2E                   ;TEST20
        DIA2
        CLK1
        CLK2
        CLK3
        CLK4
        CLK9
        RAM1
        RAM11
        RAM2
        RAM22                   ;TEST30
        RAM3
        RAM4
        RAM5
        RAM6
        RAM7
        SC1
        SC20
        SC21
        SC21A
        SC22                    ;TEST40
        SC3
        SC4
        SC5
        SC6
        OPR1
        OPR2
        ABC1
        ABC2
        ABC3
        ABC4                    ;TEST50
        ABC5
        ABC6
        NPR1

;SEQ161

        NPR2
        NPR3
        NPR3A
        NPR3B
        NPR3C
        NPR3D
        NPR3E                   ;TEST60
        NPR4
        NPR5
        NPR6
        NPR7
        NPR8
        NPR9
        T10B
        T10B1
        TO10C
        TO11A
        EBUF1
        EBUF2
        EBUF3
        EBUF4
        EBH1
        EBH2
CHECKL: DI0

;*********************************************************************
;*THE FOLLOWING TESTS ARE EXECUTED ONLY IF THE DIAGNOSTIC BUS IS ENABLED
;*********************************************************************

        DI2             ;TEST78
        DIA3
        DIA4            ;TEST80
        EB1
        EB2
        EB3
        EB4
        CLK5
        CLK6
        DEXF1A
        DEXF2A
        DEXF3A
        EPAR1           ;TEST90
        EPAR2
LASTST: EPAR3           ;LAST TEST TEST92

INITAB: I.000
        .REPT   <LASTST-TESTAB+2>/2
        .WORD   0
        .ENDR
        
;SEQ162


.SBTTL  *TEST INITIALIZOR

;*******************************************************************
;PROGRAM BY:    LARRY ROGERS
;MADE TO WORK WITH KLDCP BY:    JIM KELLY
;MADE COMPATIBLE WITH DIACON BY:        DICK BEAVEN
        ;BACK TO JIM KELLY
;BACK TO LARRY
;AND FINALLY (??) TO JIM JONES
;NOPE...HANDOFF TO DALE COOK
;*******************************************************************

I.000:  MOV     #170,R2         ;POSSIBLE VECTOR ADDRESS TO R2
        MOV     #100.,R0
        EOPSET                  ;TYPE EVERY 100 PASSES
        MOV     #<LASTST-TESTAB>/2,TESTAB       ;WOW!
        CLR     P1FLG1          ;CLEAR FIRST PASS FLAGH
        PFORCE
        PMSG    <\TYMSHARE DIAGNOSTIC SYSTEM-TYMDTE\DTE20 DIAGNOSTIC    VER. >
        MOV     #MCNNUM,R0              ;GET MCN NUMBER
        PNTDEC
        MOV     #VERNUM,R0              ;GET VERSION NUMBER
        PNTDEC
        PNTBAK                  ;DISCARD PERIOD
        PCRLF
        MOV     #FILL5,R0               ;POINT TO FILL 5 COMMAND
        PRGCMD          ;HAVE KLDCP DO IT

;SEQ163


.SBTTL  *ADDRESS SELECTION

;************************************************************************

.REM    %
        THERE ARE FOUR LEGAL SETS OF ADDRESSES FOR THE 10/11 INTERFACE.
(VIZ. 174400-174436, 174440-174500-174536 AND174540-174576).
SELAD1 TRIES TO FIND AT LEAST ONE OF THESE ADDRESSES WHICH DOES NOT
CAUSE AN INSTRUCTION TI MEOUT.
%
;************************************************************************
SELAD1: JSR     PC,RSETER               ;GO DO A RESET TO UNHANG IF HUNG
        MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR WITH "TOTRAP"
        MOV     #TOTRAP,4
        MOV     #DTE1+34-40,R0          ;LOAD R0 W/ADDRESS OF LOWEST STATUS REG. -40
SELADA: ADD     #40,R0                  ;INCREMENT R0 TO NEXT ADDRESS
        CMP     R0,#DTE4+40             ;INCREMENTED PAST LAST LEGAL ADDRESS
        BGT     SELAER          ;YES-NO ADDRESS ANSWERED-ERROR
        TST     (R0)            ;NO-THIS WILL TIME OUT IF ADDRESS DOESN'T ANSWER

        INC     TIMOFG          ;TEST FOR TIMEOUT
        BEQ     SELADA          ;BR IF TIME OUT
        MOV     R0,LOWADD               ;IT DIDN'T TIMEOUT-SAVE IN LOWADD= STATUS REG ADDRESS
        MOV     SAVE,4          ;RESTORE TIMEOUT VECTOR
        BR      SELAD2          ;AND PROCEED TO NEXT TEST

SELAER: ERROR   <\NO DTE20 DETECTED>

;***********************************************************************
.REM    %
        PROGRAM GETS INSTRUCTION TIMEOUT WHEN ADDRESSSING THE FOUR
LEGAL ADDRESSES FOR 10/11 INTERFACES. CHECK.

        1. UBUS MSYN L                                  (INT1 C-5)
        2. INT1 MSYN OUT H                              (INT1 C-5)
        3. ADDRESS SELECTION BITS FEEDING DPS1 ADR SEL H (DPS1 B-2)
        4. OR MAYBE IT'S SOMETHING MORE BASIC, LIKE THERE IS NO 10/11
           INTERFACE CONNECTED TO THE SYSTEM, OR IT'S NOT POWERED UP,
                        OR SOMETHING...
%
;***********************************************************************

;SEQ164



;*************************************************************************
.REM    %
        KNOWING THAT AT LEAST ONE 10/11 INTERFACE EXISTS, THE PROGRAM HERE
WILL PRINT OUT THE ADDRESS(ES) OF THE INTERFACE(S) IT FINDS ACTIVE.  THE
PROGRAM WILL PAUSE TO ALLOW THE OPERATOR TO SELECT AND VERIFY A TEST
ADDRESS.
%
;************************************************************************

SELAD2: MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR WITH "TOTRAP"
        MOV     #TOTRAP,4
        MOV     #TABLE,R1       ;POINT TO A 4-WORD TABLE
        MOV     #DTE1+34,R0     ;ADDRESS OF LOWEST STATUS REG TO R0
1$:     TST     (R0)            ;DOES ADDRESS RESPOND?
        INC     TIMOFG          ;TIMEOFLG=-1 IF NO RESPONSE
        BEQ     2$              ;BR IF TIMEOUT
        MOV     R0,(R1)+        ;IT MUST EXIST, PUT IN A TABLE
        BR      3$              ;
2$:     CLR     (R1)+           ;DOESN'T EXIST, CLEAR TABLE ENTRY
3$:     ADD     #40,R0          ;NEXT INTERFACE ADDRESS
        CMP     R0,#DTE4+34     ;LAST ONE CHECKED?
        BLOS    1$              ;NO, CC INUE

SELADB: MOV     SAVE,4          ;RESTORE TIMEOUT VECTOR
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <\THE FOLLOWING 10/11 INTERFACE(S) EXIST\>
        CLR     R1              ;DTE # *2
        CLR     R2              ;# OF DTES
1$:     TST     TABLE(R1)       ;CHECK IF THIS ONE EXISTS
        BEQ    2$              ;NO
        INC     R2              ;YES, COUNT IT
        PMSG    <\DTE #>        ;TELL HIM ABOUT IT
        MOV     R1,R0           ;
        ASR     R0              ;MAKE DTE #
        PNTOCS                  ;PRINT IT
                
        PMSG    <		ADDRESS >
        MOV     TABLE(R1),R0    ;AND ADDRESS
        PNTOCT                  ;
2$:     INC     R1              ;NEXT DTE
        INC     R1              ;
        CMP     R1,#6           ;ALL CHECKED?
        BLE     1$              ;NO, CONTINUE
        PCRLF                   ;YES, FINISH MESSAGE
        DEC     R2              ;ONLY ONE?
        BLE     DFAULT          ;YES, DEFAULT TO IT
;SEQ165


WAIT1:  PMSG    <\TYPE DTE # TO BE TESTED\>
        TTILIN          ;READ FROM KEYBOARD
        BCS     WAIT2           ;NOTHING WAS TYPED

        TTIOCT                  ;READ OCTAL NUMBER FROM KEYBOARD
        BCS     1$              ;NON-OCTAL #
        TST     R0      ;MUST BE 0-3
        BMI     1$              ;
        CMP     R0,#3           ;
        BGT     1$              ;
        ASL     R0              ;MAKE INTO WORD INDEX
        MOV     TABLE(R0),R0    ;GET ADDRESS
        BNE     GOLOAD          ;O.K. IF ENTRY IN TABLE

1$:     PMSG    <\ EH? \>       ;NO MATCH-ASK AGAIN
        BR      WAIT1           ;TRY IT AGAIN, YOU CRETINOUS MORON

WAIT2:  PMSG    <\I'LL TEST >
        MOV     LOWADD,R0       ;GET ADDRESS FOUND IN FIRST TEST
        PNTOCT
        PCRLF

DFAULT:        MOV     LOWADD,R0               ;GET DEFAULT ADDRESS
GOLOAD: MOV     #DLYCNT,R1      ;FIRST ADDRESS TO R1
        SUB     #34,R0          ;CONVERT STATUS ADDRESS TO DELAY CNT ADDRESS
GOLD1:  MOV     R0,(R1)+                ;STORE AND INCREMENT ADDRESS
        ADD     #2,R0           ;BUMP R0
        CMP     R1,#DIAG3       ;NO-DO IT AGAIN!
        BLE     GOLD1           ;NO-DO IT AGAIN
        PNORML                  ;RESTORE NORMAL PRINT
        RTS     PC              ;RETURN TO TEST DISPATCHER

;SEQ166



.SBTTL  *ADDRESS TESTING
;*********************************************************************
.REM    %
        ADDR3 TAKES THE ADDRESS TO BE TESTED (AS DETERMINED BY SELAD2)
AND INDIVIDUALLY COMPLEMENTS THE HIGH ORDER NINE BITS.  USING THIS MODIFIED
ADDRESS, THE PROGRAM EXPECTS AN INTRUCTION TIMEOUT.  FAILURES IN THIS TEST
ARE CAUSED BY MALFUNCTIONS OF THE SELECTION LOGIC ON THE DPS1 PRINT AT
B-2 B-5 (DSP1 UB ADR SEL H).
%
;*********************************************************************
ADDR3:  SWITCH          ;GET SWITCH REGISTER
        BIT     #INHCSH,R0      ;DO ADDR3 TEST?
        BEQ     ADDR3E          ;NO, DO NEXT TEST
        MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR
        MOV     #TOTRAP,4                       ;WITH "TOTRAP"
        MOV     #BIT6,R1                ;BIT MASK TO R1
ADDR3A: CLC                     ;CLEAR CARRY PRIOR TO ROTATE
        ROL     R1              ;SLIDE BIT MASK LEFT
        BEQ     ADDR3D          ;TO ADDR3D IF ALL BITS TESTED
        MOV     STATUS,R0               ;ADDRESS OF TESTED STATUS REG. TO R0
        BIC     R1,R0           ;TRY CLEARING AN ADDRESS BIT
        CMP     R0,STATUS            ;DID IT CHANGE?
        BNE     ADDR3B          ;YEA-IT MUST HAVE BEEN A 1
        BIS     R1,R0           ;NO-IT WAS A 0, MAKE IT A 1
ADDR3B: CMP     R0,#MAXADD     ;MAKE SURE WE HAVEN'T GOT A VALID ADDRESS
        BLO     ADDR3A          ;IF WE DO, DON'T TEST IT
        MOV     #TABLE+12,R2    ;TABLE OF EXISTING INTERFACE ADDRESSES
1$:     CMP     R0,-(R2)        ;DID WE BUILD AN EXISTING ADDRESS?
        BEQ     ADDR3A          ;YES-THEN DON'T EXPECT A TIMEOUT
        CMP     R2,#TABLE       ;NO-CHECKED ENTIRE TABLE?
        BGE     1$              ;NO-CHECK AGAIN
        MOV     R0,ACTUAL       ;SAVE ACTUAL DATA
        TST     (R0)            ;THIS SHOULD TIME OUT
        INC     TIMOFG
        BEQ     ADDR3A          ;BR IF TIMEOUT
        MOV     SAVE,4          ;RESTORE IF ERROR
        ERRMSG  <PROGRAM DID NOT GET AN INSTRUCTION TIMEOUT WHEN ADDRESSING >
        MOV     ACTUAL,R0       ;GET FAILING ADDRESS
        ERROCT
        ERCRLF
        FAULT
;*************************************************************************
.REM    %
        THE PROGRAM EXPE TED AN INSTRUCTION TIMEOUT WHEN ADDRESSING THE
PRINTED LOCATION (CONTENTS OF R0).  POSSIBLE FAULTS INCLUDE:
        1.  THE NETWORK WHICH PROVIDES "DPS1 UB ADR SEL H" (DPS1 B-2 B-5)
        2.  THE INDIVIDUAL DPS1 ADDRESS BITS WHICH RUN ACROSS THE TOP OF THE
        DPS6 AND DPS7 PRINTS.
        A SCOPE SYNCH POINT FOR THIS PROBLEM WOULD BE "INT1 MSYN OUT H"
AT INT1 C-5.
%
;*************************************************************************
ADDR3D: MOV     SAVE,4          ;RESTORE TIME OUT VECTOR
ADDR3E: JMP     NORMAL          ;GET NEXT TEST
;SEQ167

;************************************************************************
.REM    %
        KNOWING THAT IT IS POSSIBLE TO ADDRESS THE DTE20 STATUS REGISTER
WITHOUT AN INSTRUCTION TIMEOUT, ADDR4 NEXT TRIES TO ADDRESS DIAGNOSTIC
WORD 1.
%
;************************************************************************

ADDR4:  MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR
        MOV     #TOTRAP,4       ;GO TO TOTRAP IF TIMEOUT
        TST     @DIAG1          ;THIS SHOULD NOT TIME OUT
        INC     TIMOFG          ;BUMP THE FLAG
        BNE     ADDR4X          ;EXIT IF IT DIDN'T TIMEOUT
        MOV     SAVE,4  ;IT FAILED-REPLACE TIMEOUT TRAP
        ERRMSG  <INSTRUCTION TIMEOUT WHILE ADDRESSING DIAG WORD 1. (ADDRESS = >
        MOV     DIAG1,R0              ;GET THE ADDRESS
        ERROCT
        ERRMSG  <)\>
        FAULT

;************************************************************************
.REM    %
        PROGRAM COULD SUCCESSFULLY ADDRESS STATUS REGISTER BUT TIMED
OUT WHEN ADDRESSING DIAGNOSTIC REGISTER #1.
%
;************************************************************************
ADDR4X: MOV     SAVE,R0         ;RESTORE TIMEOUT TRAP
        JMP     NORMAL          ;AND EXIT TO DISPATCHER
;SEQ168


;**********************************************************************
.REM    %
        ADDR5 IS SIMILAR TO ADDR4 EXCEPT THAT IT ATTEMPTS TO ADDRESS
DIAGNOSTIC WORD 2.
%
;***********************************************************************

ADDR5:  MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR
        MOV     #TOTRAP,4       ;TRAP TO TOTRAP IF TIMEOUT
        TST     @DIAG2         ;THIS SHOULD NOT TIME OUT
        INC     TIMOFG          ;DID WE TIME OUT?
        BNE     ADDR5X          ;EXIT IF IT WORKED
        MOV     SAVE,4          ;IT DIDN'T RESTORE TIMEOUT VECTOR
        ERRMSG  <INSTRUCTION TIMEOUT WHILE ADDRESSING DIAG WORD 2.(ADDRESS = >
        MOV     DIAG2,R0        ;GET THE FAILING ADDRESS
        ERROCT
        ERRMSG   <)\>
        FAULT

;************************************************************************
.REM    %
        PROGRAM COULD SUCCESSFULLY ADDRESS STATUS AND DIAG1 REGISTERS
BUT TIMED OUT WHEN ADDRESSING DIAGNOSTIC WORD 2.
%
;*************************************************************************

ADDR5X: MOV     SAVE,4          ;RESTORE TIMEOUT TRAP
        JMP     NORMAL          ;AND RETURN TO TEST DISPATCHEWR

;SEQ169


;*************************************************************************
.REM    %
        ADDR6 IS SIMILAR TO ADDR4 AND ADDR5 EXCEPT IT TRIES TO ADDRESS
DIAGNOSTIC WORD #3.
%
;*************************************************************************

ADDR6:  MOV     4,SAVE          ;SAVE TIMEOUT TRAP
        MOV     #TOTRAP,4               ;TRAP TO TOTRAP IF TIMEOUT
        TST     @DIAG3          ;THIS SHOULD NOT TIME OUT
        INC     TIMOFG          ;DID IT?
        BNE     ADDR6X          ;EXIT IF NO TIMEOUT
        MOV     SAVE,4          ;IT TIMEOUT RESTORE TRAP

        ERRMSG  <INSTRUCTION TIMEOUT WHILE ADDRESSING DIAG WORD 3. (ADDRESS = >
        MOV     DIAG3,R0                ;GET THE ADDRESS
ERROCT
        ERRMSG  <)\>
        FAULT

;***********************************************************************
.REM    %
        THE PROGRAM COULD SUCCESSFULLY ADDRESS THE DTE20 STATUS REGISTER
AND DIAGNOSTIC WORDS 1 AND 2 BUT GOT AN INSTRUCTION TIMEOUT WHEN
ADDRESSING DIAGNOSTIC WORD 3.
%
;***********************************************************************
ADDR6X: MOV     SAVE,4          ;RESTORE TIMEOUT TRAP
        JMP     NORMAL          ;RETURN TO TEST DISPATCHER

;SEQ170


.SBTTL  *RESET TESTING

;***********************************************************************
.REM    %
        REST1 PERFORMS A RESET INSTRUCTION, READS THE 10/11 STATUS
REGISTER INTO ACTUAL, AND CHECKS THAT THE FOLLOWING STATUS FLOPS ARE
CLEAR:
        1. DPS5 11 TO10 NORM TERM       (DPS5 C-4)      BIT 15
        2. DPS5 11 TO10 ERR TERM        (DPS5 C-7)      BIT 13
        3. DPS5 PAR ERR (DPS5 D-6)      BIT 9
        4. DPS5 REQ 10 INT      (DPS5 B-5)      BIT 8
        5. DPS5 11 TO11 NORM TERM       (DPS5 C-5)      BIT 7
        6. DPS5 NULL STOP               (DPS5 D-4)      BIT 5
        7. DPS5 EBUS PARITY ERROR       (DPS5 B-2)      BIT 4
        8. DPS5 11 TO11 ERR TERM        (DPS5 C-6)      BIT 1
        MASSIVE FAILURES IN THIS TEST PROBABLY INDICATE A FAILURE
OF THE MST CLEAR SIGNAL; INDIVIDUAL FAILURES MAY BE STUCK FLOPS.
%
;*****************************************************************

REST1:  JSR     PC,RSETER               ;GO DO THE RESET
        CLR     CORECT
        MOV     @STATUS,ACTUAL  ;STATUS WORD TO ACTUAL (THIS IS THE FIRST
                                ;TIME WE TRY TO READ ANYTHING FROM THE INTERFACE)

        MOV     #^C<TO10DN!TO10ER!D11MPE!TO11DB!TO11DN!TO11ER!BPARER!NULSTP>,MASK
                                ;ABOVE BLANKS ALL BUT TESTED BITS
MCMP16
        BEQ     REST1X          ;GO TO REST1X IF ALL BITS ARE OFF

ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        THE PROGRAM EXPECTED THE ABOVE-LISTED FLOPS TO BE CLEAR AFTER
        A RESET INSTRUCTION.  POSSIBLE FAULTS INCLUDE:

        1. UBUS INIT L                          (INIT1 D-5)
        2.INT1 MST CLR L                        (INT1 D-3)
        3. DPS5 MST CLEAR A L                   (DPS5 A-5)
        4. DPS5 MST CLEAR D L                   (DPS5 A-5)
5. THE INDIVIDUAL STATUS FLOPS STUCK ON ONE.
6. THE 4WIDE AND 2WIDE MIXERS EXTENDING ACROSS THE BOTTOM OF DPS6.
7. CNT2 UB MIX SEL 2 + 1                        (CNT2 C-7)
8. CNT2 REG ADRH                                (CNT2 C-7)

        A SCOPE SYNCH POINT FOR THIS PROBLEM IS THE TRAILING EDGE OF
        UBUS INIT L     (INIT1 C-5).
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
REST1X: JMP     NORMAL








;SEQ171

.SBTTL  *DIAGNOSTIC REGISTER TESTING (BASIC)

;*******************************************************************
.REM    %
        DIA1 IS SIMILAR TO THE PREVIOUS TEST EXCEPT THIS TIME
DIAGNOSTIC WORD 1 IS CHECKED FOR ZEROES AFTER THE RESET INSTRUCTION.
THE TESTED LOGIC IS CONTAINED MOSTLY ON THE CNT3 PRINT. THIS TEST
PRIMARILY CHECKS THE CNT3 UNIBUS TRANSCEIVERS.
%
;**********************************************************************

DIA1:   JSR     PC,RSETER               ;GO DO THE RESET
        CLR     CORECT                  ;
        MOV     @DIAG1,ACTUAL           ;GET DIAGNOSTIC WORD 1
        MOV     #^C<D1011!DCOMST>,MASK ; CLEAR ALL BUT TESTED BITS
        MCMP16
        BEQ     DIA1D                   ;ALL BITS CLEARED?
        ERR16   CORECT,ACTUAL,MASK,<PDP11 RESET LEAVES DIAG WORD 1="ACTUAL"\>

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        THE PROGRAM EXPECTED A RESET INSTRUCTION TO CLEAR
DIAG COM START AND DIAG 10/11 INDIAGNOSTIC WORD 1.
POSSIBE SINGLE FAULTS INCLUDE:

        1. THE CNT3 DIAG DS OUT H TRANSCEIVERS  (CNT3 B-2 THRU 7)
        2. THE CNT3 UNIBUS TRANSCEIVERS         (CNT3 D-1 THRU 7)
        3. CNT3  SEL DIAG L                     (CNT3 C-4)
        4. CNT2 SEL DIAG 1                      (CNT2 C-4)
        5. INT1 MST CLR A L                     (INT1 D-3)
        6. THE ABOVE LISTED FLOPS STUCK @1      (CNT3 A-8 & A-6)


        A USABLE SCOPE SYNCH POINT FOR THIS PROBLEM IS THE TRAILING EDGE
OF UBUS INITL (INIT1 C-5)
%
;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

DIA1D:  JMP     NORMAL          ;GET NEXT EST

;SEQ172

.SBTTL  *STATUS REGISTER CHECKING (BASIC)

;************************************************************************
.REM    %
        STAT1   TRIES TO SET THE FOLLOWING STATUS FLOPS:
        1. DPS5 11 TO10 NORM TERM       (DPS5 C-4)      BIT 15
        2. DPS5 11 TO10 ERR TERM        (DPS5 C-7)      BIT 13
        3. DPS5 10 REQ INT      (DPS5 D-7)      BIT11
        4. DPS5 REQ 10 INT              (DPS5 B-5)      BIT 8
        5.DPS5 11 TO11 NORM TERM        (DPS5 C-5)      BIT 7
        6. DPS5 EBUS PARITY ERROR       (DPS5 B-2)      BIT 4
        7. DPS5 11 TO11 ERR TERM        (DPS5 C-6)      BIT 1
        8. DPS5 11 INTERRUPT EN         (DPS5 B-4)      BIT 0
        INDIVIDUAL FAILURES MAY BE CAUSED BY THE FLOPS STUCK AT
ZERO OR UNIBUS TRANSCEIVER FAULTS.  MASSIVE FAILURES ARE PROBABLY
CAUSED BY FAULTY SELECTION OR UNIBUS CONTROL SIGNALS
%
;**********************************************************************

STAT1:  MOV     #PR7,PS         ;BLOCK INTERRUPTS
        MOV     #TO10DN!TO10ER!TO11DB!TO11DN!TO11ER!TO10DB!BPARER!INTSON,CORECT
                                        ;THE ABOVE LOADS THE COMPARISON WORD
        MOV     #DON11S!DON10S!ERR10S!TO11DB!ERR11S!INT10S!INTRON!EBUSPS,@STATUS
                                        ;THE ABOVE SETS THE STATUS FLOPS
        MOV     @STATUS,ACTUAL          ;STATUS WORD TO ACTUAL
        MOV     #^C<TO10DN!TO10ER!TO11DB!TO11DN!TO11ER!TO10DB!BPARER!INTSON>,MASK
                                        ;ABOVE CLEARS ALL BUT TESTED BITS
MCMP16                                  ;DID THEY SET?
        BEQ     STAT1A                  ;EXIT IF THEY DID
        ERR16   CORECT,ACTUAL,MASK,<PROGRAM UNABLE TO SET STATUS FLOPS IN "CORRECT"\>

;+-+-+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM UNABLE TO SET ONE OR MORE OF THE ABOVE LISTED STATUS FLOPS.
        IF ONLY ONE OF THE FLOPS IS NOT SET CHECK:
        1. THE SPECIFIED FLOP                           (DPS5)
        2. THE UNIBUS TRANSCEIVER FOR THE CORRESPONDING BIT (CNT3 D-1 THRU           7)
        3. THE 2X4 OR 4X2 UBIC MIXER FOR THE BIT                (DPS6 BOTTOM)

        IF MORE THAN ONE OF THE FLOPS ARE NOT SET, CHECK:
        1. CNT2 UNIBUS 1 EN L OR UNIBUS DIS L           (DPS6 C-7)
        2. CNT2 UB MIX SEL 1 & 2                        (CNT2 C-7)
        3. CNT2 SEL STATUS L                            (CNT2 D-7)
        4. INT1 DATOH OR INT1 DATIH                     (INT1 B6 & B7)
        5. THE UNIBUS I/O CONTROL FUNCTIONS CO + C1     (INT1 C-6)

        A SCOPE SYNCH POINT FOR THIS PROBLEM IS
INT1 DAT0H (INT1 B-6).
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

STAT1A: JMP     NORMAL          ;GET NEXT TEST

;SEQ173


;*************************************************************************
.REM    %
        KNOWING THAT THE SEVEN STATUS FLOPS CAN SET, STAT2 TRIES TO CLEAR
THEM WITH A RESET INSTRUCTION.
%
;*************************************************************************

STAT2:  CLR     CORECT          ;SET UP FOR COMPARISON
        MOV     #PR7,PS                 ;BLOCK INTERRUPTS
        MOV     #DON10S!ERR10S!TO11DB!DON11S!ERR11S!INT11S!INT10S!INTRON!EBUSPC,@STATUS
                                        ;THE ABOVE SETS THE STATUS FLOPS
        JSR     PC,RSETER               ;GO DO THE RESET
        MOV     @STATUS,ACTUAL          ;GET CLEARED STATUS REGISTER
        MOV     #^C<TO10DN!TO10ER!TO11DB!TO11ER!BPARER!INTSON!TO11DN>,MASK
                                        ;ABOVE CLEARS ALL BUT TESTED BITS
        MCMP16                          ;CLEAR?
        BEQ     STAT2A                  ;YES-GET NEXT TEST
        ERR16   CORECT,ACTUAL,MASK,<PDP11 RESET LEAVES "ACTUAL" STATUS BITS SET\>

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        RESET INSTRUCTION WILL NOT CLEAR THE SEVEN STATUS FLOPS LISTED 
        ABOVE.  IF A SINGLE FLOP IS SET, CHECK THE FLOP ITSELF. IF MORE
        THAN ONE FLOP IS SET CHECK:

        1. DPS5 MST CLR A L AND DPS5 MST CLR B L        (DPS5 A-5)
        2. INT1 MST CLR L                       (INT1 D-4)
%
;+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


STAT2A: JMP     NORMAL          ;GET NEXT TEST

;*RSETER                ROUTINE TO EXECUTE PDP11 RESET INSTRUCTION

RSETER: MOV     PASS,R0         ;GET PASS COUNT
        NEG     R0              ;MAKE IT TWO'S COMP
        RESET                   ;DISPLAY PASS COUNT WHILE RESETTING
        CLR     KWLKS           ;CLEAR CLOCK FLAG
1$:     TST     KWLKS           ;     WAIT FOR IT
        BEQ     1$              ;     SET AGAIN
        CLR     KWLKS           ;CLEAR IT AGAIN (GUARANTEES 16.7 MSEC DELAY)

2$:     TST     KWLKS          ;     WAIT
        BEQ     2$              ;     AGAIN
        RTS     PC              ;AND RETURN

;SEQ174


;**************************************************************************
.REM    %
        STAT3 COMPARES THE EFFECT OF THE DIAGNOSTIC RESET FUNCTION TO
THAT OF THE PDP11 RESET INSTRUCTION.  SINCE WE ALREADY KNOW THAT THE
RESET INSTRUCTION CLEARS ALL SEVEN FLOPS, ONLY ONE OF THEM NEED BE TESTED
(VIZ.  DPS5 11 TO10 ERR TERM).
(VIZ.  D
%
;**************************************************************************
STAT3:  CLR     CORECT          ;SET UP FOR COMPARISON
        MOV     #PR7,PS         ;BLOCK INTERRUPTS
        MOV     #ERR10S,@STATUS ;SET TO10 ERROR
        DIAGRS                  ;DO THE DIAGNOSTIC RESET
        MOV     @STATUS,ACTUAL  ;GET THE RESET STATUS REGISTER
        BIC     #^C<TO10ER>,ACTUAL ; CLEAR ALL BUT TESTED FLOP
        CMP     CORECT,ACTUAL           ;DID IT CLEAR?
        BEQ     STAT3A          ;YES-EXIT
        ERRMSG  <TO10 ERROR CLEARS WITH PDP11 RESET BUT NOT WITH DTE20 DIAGNOSTIC RESET\>
        FAULT
;+-+-+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        DIAGNOSTIC RESET WILL NOT CLEAR STAT 11 TO10 ERROR BUT
PDP11 RESET INSTRUCTION WILL.  CHECK:

        1. UBIC MST CLR L               ;(UBIC A2)
        2. BCON UN DAT 06 H             (BCON A3)
        3. ACON DIAG COM STR B H                (ACON C1)
        4. ACON SEL DIAG 2 L            (ACON A1)
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+-+-+-+-+-+-+-+

STAT3A: JMP     NORMAL          ;GO TO NEXT TEST

;SEQ175


;**********************************************************************
.REM    %
      
STAT4 TRIES TO CLEAR TO10 DONE, TO10 ERROR, 10 REQ INT, 11 TO 10 NORM
TERM, 11 TO10 ERR TERM, 10 REQ INT, 11 TO11 NORM TERM, AND
11 INTERRUPT ENABLE VIA THE INDIVIDUAL RESET GATES WITH BITS 14,12,10,
06,03, AND 00.
%
;**********************************************************************

STAT4:  MOV     #PR7,PS         ;BLOCK INTERRUPTS
        MOV     #DON10S!ERR10S!TO11DB!DON11S!ERR11S!INT10S!INTRON!EBUSPC,@STATUS
                                ;THE ABOVE SETS THE STATUS FLOPS
        MOV     #DON10C!ERR10C!INT11C!DON11C!ERR11C!INTROF,@STATUS
                                ;THE ABOVE CLEARS THEM
        CLR     CORECT          ;
        MOV     @STATUS,ACTUAL  ;CLEARED FLOPS TO ACTUAL
        MOV     #^C<DON10S!ERR10S!TO11DB!DON11S!ERR11S!BPARER!INTSON>,MASK
                                ;THE ABOVE CLEARS ALL BUT TESTED BITS
        MCMP16
        BEQ     STAT4B          ;EXIT IF THEY CLEARED
        ERR16   CORECT,ACTUAL,MASK,<STATUS FLOPS IN "ACTUAL" WON'T SET TO 0\>

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        THE ABOVE LISTED STATUS FLOPS WILL NOT CLEAR WITH INDIVIDUAL
UNIBUS BITS BUT CAN BE RESET VIA RESET INSTRUCTION.
CHECK:
        1. THE INDIVIDUAL STATUS FLOPS          (DPS5)
        2. THE UNIBUS DRIVERS BITS 14, 12, 10, 6, 3, AND 0      (DPS6 C1                 
                                                                THRU C-7)
        A SCOPE SYNCH FOR THIS PROBLEM IN INT1 DATOH (INT1 B-6).
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

STAT4B: JMP     NORMAL          ;GO TO NEXT TEST

;SEQ176

.SBTTL  *RESTRICTED/PRIVILEGED MODE TESTING

;*****************************************************************
.REM    %
        RM1-4 CHECK THE RESTRICTED MODE BIT FOUND IN THE STATUS REGISTER.
RM1 REPORTS THE CONDITIN OF THE BIT IN THE FIRST PAS.  IF THE TESTED DTE20
IS PRIVILEGED, THE PROGRAM DOES A LIMITED AMOUNT OF DIAGNOSTIC BUS TESTING
LEADING UP TO THE ISSUANCE OF A MSTER RESET IN TEST RM4.  IF THE TESTED
DTE20 IS RESTRICTED, THE FOUR TESTS ARE DUMMIES.
%
;**************************************************&********************

RM1:    MOV     #-1,RMFLAG              ;SET RESTRICTED FLAG
        BIT     #RM,@STATUS             ;RESTRICTED MODE BIT SET?
        BNE     RM1A                    ;TO RM1A IF RESTRICTED
        CLR     RMFLAG          ;NO-MUST BE PRIVILEGED
        
RM1A:   TST     P1INTF          ;DONE FIRST PASS INTERRUPT TEST YET?
        BNE     3$      ;YES-DON'T BOTHER PRINTING
        PMSG    <TESTED DTE20 IS >
        TST     RMFLAG          ;PRIVELEGED?
        BEQ     1$                      ;YEA-REPORT
        PMSG    <RESTRICTED\>
        JMP     NORMAL          ;AND EXIT
1$:     PMSG    <PRIVELEGED\>
2$:     JMP     DI2             ;EXIT VIA FIRST DS TEST
3$:     TST     RMFLAG          ;RESTRICTED?
        BEQ     2$      ;NO-GO DO D12
        JMP     NORMAL          ;YES-SIMPLY EXIT

RM2:    TST     RMFLAG                  ;RESTRICTED?
        BNE     1$                      ;YES-SIMPLY EXIT
        JMP     DIA3            ;NO-DO SECOND DES TEST
1$:     JMP     NORMAL          ;EXIT WITHOUT CHECKING DS'S

RM3:    TST     RMFLAG          ;RESTRICTED?
        BNE     1$              ;YES-SIMPLY EXIT
        JMP     DIA4            ;NO-LAST DS TEST
1$:     JMP     NORMAL          ;YES-SIMPLY EXIT

RM4:    TST     RMFLAG          ;RESTRICTED?
        BNE     1$              ;YES-SIMPLY EXIT
        MOV     #MR,R0          ;NO, PERFORM MASTER RESET
        PRGNPT                  ;USE PROGRAM COMMAND TO ENSURE
                                ;THAT KLDCP WILL RETURN
        PNTRST                  ;THROW AWAY ANY ERROR MESSAGE
1$:     JMP     NORMAL          ;AND EXIT

;SEQ177


.SBTTL  *INTERRUPT TESTING

;***********************************************************************
.REM    %
        THIS ONE MUST BE DONE VERY CAREFULLY BECAUSE FAILURES IN THE
VECTORED INTERRUPT LOGIC CAN CAUSE TRAPS TO ALMOST ANYWHERE.  FIRST THE
PROGRAM MUST DETERMINE THE VECTOR ADDRESS FOR THE TESTED INTERFACE...
%
;************************************************************************

INT1:   TST     P1INTF          ;PASS 1?
        BNE     1$              ;NO
        PMSG    <\ENTERING INTERRUPT TEST PASS 1 (INT 1) PC= >
        MOV     PC,R0           ;PC, TO R0
        PNTOCT                  ;PRINT CONTENTS OF PC.
        PCRLF
;*DETERMINE VECTOR ADDRESS OF TESTED DTE20

1$:     BIT     #BIT6,DLYCNT    ;3RD OR 4TH INTERFACE?
        BNE     INT1B           ;YES
        BIT     #BIT5,DLYCNT    ;NO-IS IT THE 2ND?
        BNE     INT1A           ;YES
        MOV     #DTEIV0,R1      ;STORE ADDRESS FOR 1ST INTERFACE
        BR      INT1D           ;AND CONTINUE
INT1A:  MOV     #DTEIV1,R1      ;STORE ADDRESS FOR 2ND INTERFACE
        BR      INT1D           ;AND CONTINUE
INT1B:  BIT     #BIT5,DLYCNT    ;IS IT THE 3RD INTERFACE
        BNE     INT1C           ;NO
        MOV     #DTEIV2,R1      ;STORE ADDRESS FOR 3RD INTERFACE
        BR      INT1D           ;AND CONTINUE
INT1C:  MOV     #DTEIV3,R1              ;STORE ADDRESS FOR 4TH INTERFACE

;**********************************************************************
.REM    %
        WITH THE CORRECT VECTOER ADDRESS ESTABLISHED, THE PROGRAM NEXT
PUSHES THE CONTENTS OF THAT ADDRESS AND THE FOLLOWING WORD ONTO A
STACK AND LOADS THE VECTOR ADDRESS TO TRAP TO INT10K IF AN INTERRUPT 
OCCURS.  (VECTOR +2 IS SET TO 340 TO BLOCK  FURTHER INTERRUPTS).
%
;****************(******************************************************

INT1D:  MOV     R1,VECTOR               ;VECTOR=INTERFACE VECTOR ADDRESS
        MOV     (R1),-(SP)              ;PUSH CONTECTS OF VECTOR AWAY
        MOV     #INT1OK,(R1)+           ;TRAP TO "INT1OK" IF INTERRUPT
        MOV     #PR7,(R1)               ;SET PS TO BLOCVK FURTHER INTERRUPTS

        
;SEQ178

;************************************************************************
.REM    %
        WITH THE CORRECT VECTOR ADDRESS STORED AND LOADED.  THE PROGRAM
NEXT PUSHES THE CONTENTS OF THE SEVEN MOST LIKELY FAILING ADDRESS ONTO THE
TEMPORARY STACK, AND LOADS THESE ADDRESES WITH POINTERS TO FOURTEEN
SEPARATE ERROR ROUTINES (INT115-INT12).  ASSUMING SINGLE FAULTS, THE
MOST LIKELY FAILING ADDRESSES ARE OBTAINED BY COMPLEMENTING BITS 15
AND 7 THRU 2 OF THE CORRECT VECTOR ADDRESS.
%
;***********************************************************************

        MOV     #INERTB,R2              ;INERTB IS SEVEN WORDS LONG AND
                                        ;CONTAINS ERROR ADDRESSES INT115
                                        ;THRU INT12.
        MOV     #BIT15,R0               ;BIT MASK
        MOV     VECTOR,R1               ;VECTOR ADDRESS TO R1
        BIS     #BIT15,R1               ;SET BIT 15
        CMP     R1,#MAXADD              ;HAVE WE BUILT AN ILLEGAL ADDRESS?
        BGE     INT1EA                  ;YES-DON'T BOTHER WITH IT
        MOV     (R1),-(SP)              ;STORE ITS CONTENTS ON STACK
        MOV     2(R1),-(SP)             ;AND ITS CONTENTS +2
        MOV     #INT115,(R1)+           ;GOTO INT115 IF BIT 15 FAILS
        MOV     #PR7,(R1)               ;BLOCK ADDITIONAL INTERRUPTS

INT1EA: MOV     #BIT8,R0                ;BIT MASK TO R0
INT1E:  MOV     VECTOR,R1               ;CORRECT VECTOR ADDRESS TO R1
        BIC     R0,R1                   ;TRY CLEARING AN ADDRESS BIT
        CMP     R1,VECTOR               ;WAS IT A ONE INITIALLY?
        BNE     INT1F           ;YES
        BIS     R0,R1                   ;NO-SO MAKE IT A ONE NOW
INT1F:  MOV     (R1),-(SP)              ;STORE CONTENTS OF MODIFIED ADDRESS
        
        MOV     2(R1),-(SP)             ;AND MODIFIED ADDRESS +2
        MOV     (R2)+,(R1)+             ;ERROR POINTER TO MODIFIED ADDRESS
        MOV     #PR7,(R1)               ;SET PS TO 7 IF ERROR INTERRUPT
        CLC                             ;CLEAR CARRY BEFORE ROTATE
        ROR     R0                      ;MOVE THE BIT MASK
        BIT     #BIT1,R0                ;SHIFTED ALL THE WAY TO BIT 1?
        BEQ     INT1E                   ;NO-SAVE AND LOAD ANOTHER ADDRESS

;*ANOTHER SINGLE FAULT COULD BE AN INTERRUPT TO LOCATION 00



        MOV     0,-(SP)                 ;SAVE 0
        MOV     2,-(SP)                 ;AND 2
        MOV     #INT00,0                ;TRAP TO INTOO
        MOV     #PR7,2                  ;BLOCK FURTHER INTERRUPTS

;SEQ179

;*******************************************************************
.REM    %
        HAVING LOADED THE VECTOR ADDRESS, THE PROGRAM MAY NOW ATTEMPT
INTERRUPTING BY SETTING TO10 DONE, TO11 DONE AND 10 REQ INTERRUPT,
POSSIBLE ERRORS ARE INT1NO IF NO INTERRUPT
OCCURS. INTERL IF THE 10/11 INTERFACE INTERRUPTS WITHOUT ONE OF THE THREE
FLOPS SET, INT115 THUR INT12 IF THE PROGRAM INTERRUPTS TO VECTOR
ADDRESSES WITH BITS 15 THRU 2 COMPLEMENTED  AND INTNO IF A BUS TIM;EOUT 
OCCURS.
%
;************************************************************************

        DIAGRS                          ;DIAGNOSTIC RESET
        MOV     4,SAVE                  ;SAVE TIME OT VECTOR
        MOV     #TOTRAP,4               ;TRAP TO TOTRAP IF TIMEOUT
        MOV     #INTRON,@STATUS         ;ENABLE INTERRUPTS
        CLR     R4                      ;FLAG TO CHECK WHEN INTERRUPTED
        CLR     PS                      ;SET PS TO 0 (ALLOW INTERRUPTS)
        NOP                             ;       THESE SHOULD
        NOP                             ;       NOT BE
        NOP                             ;       INTERRUPTED
        TST     R4                      ;BEEN INTERRUPTED?
        BEQ     1$                      ;NO, PROCEED
        JMP     INTERL                  ;YES, REPORT EARLY INTERRUPT
1$:     MOV     #DON10S!TO11DB!DON11S,@STATUS   ;THIS SHOULD CAUSE INTER-
                                                ;RUPT
        NOP                             ;       THESE ALLOW
        NOP                             ;       TIME FOR
        NOP                             ;       INTERRUPT
        INC     TIMOFG                  ;CHECK FOR TIMEOUT
        BNE     INT1G                   ;TO INT1G IF NO TIMEOUT
        JSR     PC,INEXIT               ;CLEAN UP BEFORE REPORTING
INTIMO: ERRMSG  <INSTRUCTION TIMEOUT WHILE ATTEMPTING VECTORED INTERRUPT\>
        FAULT

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        INSTRUCTION TIMEOUT WHILE ATTEMPTING VECTORED INTERRUPT.
%
;+-+-+-+-=-+-+-+-+-+-+-+-+-+_-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ180


INT1G:  MOV     @STATUS,ACTUAL          ;GRAB THE STATUS REGISTER
        MOV     #INTROF,@STATUS         ;DISABLE INTERRUPTS
        TST     R4                      ;BEEN INTERRUPTED
        BEQ     INT1NO                  ;BR IF NOT
        BMI     2$                      ;BR IF TO WRONG PLACE
        JSR     PC,INEXIT               ;OK, CLEAN UP
        JMP     NORMAL                  ;AND EXIT

2$:     JSR     PC,INEXIT               ;CLEAN UP
        ERRMSG  <STATUS REGISTER = >
        MOV     ACTUAL, R0
        ERROCT                          ;ACTUAL TO ERROR STACK
        FAULT                           ;

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        INTERRUPT WAS TO A WRONG LOCATION AS NOTED IN TYPEOUT
        DUE TO A SINGLE BIT FAILURE.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;********************************************************************
.REM    %
        THE PROGRAM WILL COME TO INT1NO IF NO INTERRUPT OCCURS.
%
;*******************************************************************

INT1NO: JSR     PC,INEXIT                      ;CLEAN UP
        ERRMSG  <NO DTE20 INTERRUPT\DTE20 STATUS = >
        MOV     ACTUAL,R0
        ERROCT
        FAULT
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM EXPECTED VECTORED INTERRUPT BUT DID NOT GET ONE.
        CHECK:
        1. DPS5 11 INT L                (DPS5 B-2)
        2.INT2 BG SYNCH                 (INT2 D-7)
        3. INT2 UN BG IN L                    (INT2 D-8)
        4. INT2 BG SACK                 (INT2 D-6)
        5. INT1 SACK OUT H                      (INT1 B-4)
        6. UBUS SACK L                  (INT1 D-3)
        7. INT2 BG BBSY                 (INT2 D-5)

        A SCOPE SYNCH POINT FOR THIS PROBLEM IS THE ONE SIDE OF ONE OF
        THE THREE STATUS FLOPS - TO10 DONE, OR 10 REQ INT ON THE
        DPS5  PRINT.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ181


;*******************************************************************
;*THE PROGRAM WILL COME TO INTERR IF AN ADDRESSING ERROR OCCURS.
;*******************************************************************
INTERR: MOV     #INTROF,@STATUS         ;DISABLE INTERRUPTS
        BIS     #BIT15,R4
INTCOM: CLR     CORECT
        MOV     @STATUS,ACTUAL
        JSR     PC,DIAGRT               ;RESET
        RTI                             ;BACK TO CODE

;*******************************************************************
;*THE PROGRAM WILL COME TO INTOK IF EVERYTHING WORKS FINE.
;*******************************************************************

INT1OK: MOV     #1,R4
        BR      INTCOM

;***********************************************************************
;*THE PROGRAM WILL COME TO INTERL IF PREMATURELY INTERRUPTED.
;************************************************************************

INTERL: JSR     PC,INEXIT               ;CLEAN UP
        ERRMSG  <INTERRUPT DETECTED WITHOUT SETTING ANY FUNCTION TO CAUSE ONE.\  DTE20 STATUS REG. = >
        MOV     ACTUAL,R0               ;GET THE STORED STATUS REGISTER
        ERROCT                          ;PRINT IT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+
.REM    %
        PROGRAM GOT AN INTERRUPT WITHOUT SETTING TO10 DONE, 10 REQ INT,
OR TO11 DONE.  CHECK THE FUNCTIONS LISTED FOR THE PREVIOUS ERROR
(INT1NO).  A SCOPE SYNCH FOR THIS PROBLEM IS INT1 MST CLR H(INT1 D-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ182


;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        THE FOLLOWING SEVEN ERRORS ARE CAUSED BY THE 10/11 INTERFACE
INTERRUPTING TO AN INCORRECT VECTOR ADDRESS.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

INT115:  ERRMSG  <\BIT15 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT17:  ERRMSG  <\BIT07 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT16:  ERRMSG  <\BIT 06 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT15:  ERRMSG  <\BIT 05 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT14:  ERRMSG  <\BIT 04 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT13:  ERRMSG  <\BIT 03 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR

INT12:  ERRMSG  <\BIT 02 OF VECTOR ADDRESS INCORRECT\>
        BR      INTERR


;*************************************************************
;*INT00 WILL BE ENTERED IF THE INTERFACE INTERRUPTS TO ADDRESS 00
;**************************************************************

INT00:  ERRMSG  <\DTE20 INTERRUPTED TO LOCATION 0\>
        BR      INTERR          ;NO ADDRESS LOADED BY INT1 BG BBSY

;****************************************************************
;*INERTB IS A TABLE OF THE ABOVE SEVEN ERROR ADDRESSES FOR VECTOR LOADING
;*****************************************************************

INERTB: INT115
        INT17
        INT16
        INT15
        INT14
        INT13
        INT12

;SEQ183


;*********************************************************************
;*INEXIT RESTORES THE VECTOR ADDRESSES
;*********************************************************************

INEXIT: POP     R4              ;SAVE RETURN PC IN R4
        MOV     #PR7,PS         ;SET PROCESSOR TO BLOCK INTERRUPTS
        MOV     SAVE,4          ;RESTORE TIMEOUT VECTOR
        MOV     (SP)+,2         ;       FIRST RESTORE LOCATIONS 2
        MOV     (SP)+,0         ;       AND ZERO

        MOV     #BIT2,R0                ;BIT MASK TO R0
INT1H:  MOV     VECTOR,R1               ;VECTOR ADDRESS TO R1
        BIC     R0,R1           ;TRY CLEARING THE BIT
        CMP     R1,VECTOR       ;WAS BIT INITIALLY A ONE?
        BNE     INT1I           ;YES
        BIS     R0,R1           ;NO-MAKE IT ONE
INT1I:  MOV     (SP)+,2(R1)     ;RESTORE AND ADDRESS +2
        MOV     (SP)+,(R1)      ;AND AN ADDRESS
        CLC                     ;CLEAR THE CARRYBEFORE ROTATING
        ROL     R0              ;SHIFT THE BIT MASK
        BIT     R0,#BIT9        ;DONE ALL SIX RESTORATIONS?
        BEQ     INT1H           ;NO-DO IT AGAIN!
        MOV     VECTOR,R1       ;RELOAD CORRECT VECTOR ADDRESS
        BIS     #BIT15,R1       ;FORCE BIT 15
        CMP     R1,#MAXADD      ;DID WE BUILD AN ILLEGAL ADDRESS?
        BGE     INLAST          ;YES-FORGET IT
        MOV     (SP)+,2(R1)     ;RESTOREVECTOR+2
        MOV     (SP)+,(R1)      ;AND THE VECTOR ITSELF
INLAST: MOV     (SP)+,@VECTOR   ;RELOAD CORRECT VECTOR
        PUSH    R4              ;RESTORE RETURN PC
        RTS     PC

;SEQ184

;*******************************************************************
.REM    %
        KNOWING THAT IT IS POSSIBLE TO GET A VECTORED INTERRUPT
FROM THE 10/11 INTERFACE, INT2A - INT2E TEST TO MAKE SURE THAT EACH
OF THE FUNCTIONS WHICH CAN CAUSE AN INTERRUPT CAN DO SO.
%
;*******************************************************************

;*CHECK DPS5 11 TO10 NORM TERM GENERATING INTERRUPTING

INT2A:  JSR     PC,INTXST               ;DO SETUP
        CLR     PS                      ;ALLOW INTERRUPTS
        MOV     #DON10S!INTRON,@STATUS          ;SET TO10 DONE
        NOP                             ;       ONE OF
        NOP                             ;       THESE SHOULD
        NOP                             ;       BE INTERRUPTED
        TST     INTFLG                  ;INTERRUPTED?
        BEQ     1$                      ;BR IF NO
        JSR     PC,INT2EX                ;CLEAN UP
        JMP     NORMAL                  ;AND LEAVE
1$:     MOV     @STATUS,ACTUAL          ;GET THE STATUS REG.
        JSR     PC,INT2EX               ;CLEAN UP
        ERRMSG  <TO10 DONE NOT GENERATING INTERRUPT\DTE20 STATUS REG. = >
        MOV     ACTUAL,R0               ;GET STORED STATUS REG
        ERROCT                  ;PRINT IT
        FAULT


;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO10 DONE NOT GENERATING INTERRUPT.  CHECK SET OF
DPS5 11 INT L (DPS5 B-2).  A SCOPE SYNCH IS THE ONE SIDE
DPS5 11 TO10 NORM TERM (DPS5 C-3).
%
;*-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ185


;***************************************************************
;*NEXT CHECK IF 10 REQUEST INTERRUPT CAN GENERATE AN 11 INTERRUPT
;****************************************************************


INT2B:  JSR     PC,INTXST       ;SETUP
        CLR     PS              ;ALLOW INTERRUPTS
        MOV     #TO11DB!INTRON,@STATUS  ;DPS510 REQ INT
        NOP                     ;       ONE OF
        NOP                     ;       THESE SHOULD
        NOP                     ;       BE INTERRUPTED
        TST     INTFLG          ;WERE THEY?
        BEQ     1$              ;BR IF NO INTRUPT
        JSR     PC,INT2EX                ;CLEN UP
        JMP     NORMAL          ;EXIT
1$:     MOV     @VECTOR,ACTUAL
        JSR     PC,INT2EX               ;CLEAN UP
        ERRMSG  <10 REQ INT NOT GENERATING INTERRUPT\DTE20 VECTOR ADDRESS = >
        MOV     ACTUAL,R0       ;
        ERROCT                  ;
FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        10 REQ INT NOT GENERATING INTERRUPT.  CHECK SET OF DPS5 11 INT
L (DPS5 B-2).  A SCOPE SYNCH IS THE ONE SIDE OF DPS5 10 INT
        
(DPS5 D-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ186


;*********************************************************************
;*NEXT CHECK TO11 DONE SETTING INTERRUPT
;*********************************************************************

INT2C:  MOV     #DON11C,@STATUS         ;CLR TO11 DONE
        JSR     PC,INTXST                       ;SETUP
        CLR     PS              ;ALLOW INTERRUPTS
        MOV     #DON11S!INTRON,@STATUS  ;SET TO11 DONE
        NOP                             ;       ONE OF
        NOP                             ;       THESE SHOULD
        NOP                             ;       BE INTERRUPTED
        TST     INTFLG                  ;INTERRUPTED?
        BEQ     1$                      ;BR IF NOT
        JSR     PC,INT2EX               ;CLEAN UP
        JMP     NORMAL
1$:     MOV     @VECTOR,ACTUAL
        JSR     PC,INT2EX               ;CLEAN UP
        ERRMSG  <TO11 DONE NOT GENERATING INTERRUPT\DTE20 VECTOR ADDRESS = >
        MOV     ACTUAL,R0               ;
        ERROCT                          ;
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO11 DONE NOT CAUSING INTERRUPT BUT TO10 DONE AND TEN DOORBELL
DO.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ187


;*********************************************************************
;*TEST DOES TO10ER CAUSE AN INTERRUPT
;**********************************************************************

INT2D:  JSR     PC,INTXST               ;SETUP
        CLR     PS                      ;ALLOW INTERRUPTS
        MOV     #ERR10S!INTRON,@STATUS  ;SET TO10ER
        NOP                             ;       ONE OF
        NOP                             ;       THESE SHOULD
        NOP                             ;       BE INTERRUPTED
        TST     INTFLG                  ;TEST FOR INTERRUPT
        BEQ     1$                      ;BR IF NO INTERRUPT
        JSR     PC,INT2EX               ;CLEAN UP
        JMP     NORMAL                  ;EXIT
99$:    RTS     PC
1$:     MOV     @VECTOR,ACTUAL
        JSR     PC,INT2EX
        ERRMSG  <TO10 ERROR NOT GENERATING INTERRUPT\DTE20 VECTOR ADDRESS. = >
        MOV     ACTUAL,R0               ;
        ERROCT                          ;
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO10 ERROR NOT GENERATING INTERRUPT BUT TO10 DONE, TEN DOORBELL,
AND TO11 DONE ALL DO.
%
;*********************************************************************
;SEQ188


;******************************************************************
;*CHECK DOES TO11ER CAUSE AN INTERRUPT
;******************************************************************

INT2E:  JSR     PC,INTXST       ;SETUP
        CLR     PS              ;ALLOW INTERRUPTS
        MOV     #ERR11S!INTRON,@STATUS  ;SET TO11ER
        NOP                     ;       ONE OF
        NOP                     ;       THESE SHOULD
        NOP                     ;       BE INTERRUPTED
        TST     P1INTF          ;PASS 1?
        BNE     98$             ;NO!
        PMSG    <\EXITING INTERRUPT TEST PASS 1\>
        INC     P1INTF
98$:     TST     INTFLG          ;TEST FOR INTERRUPT
        BEQ     1$              ;BRANCH IF NO INTERRUPT
        JSR     PC,INT2EX       ;CLEAN UP
        JMP     NORMAL          ;AND EXIT
99$:    RTS     PC
1$:     MOV     @VECTOR,ACTUAL
        JSR     PC,INT2EX
        ERRMSG<TO11 ERROR NOT GENERATING INTERRUPT\DTE20 VECTOR ADDRESS. = >
        MOV     ACTUAL,R0       ;
        ERROCT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO11 ERROR NOT CAUSING INTERRUPT BUT TO10 DONE, TEN DOORBELL,
TO11 DONE, AND TO11 ERROR ALL DO.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;*******************************************************************
;*COMMON INTERRUPT ROUTINE AND SET UP AND EXIT ROUTINES FOR INT2A - INT2E
;********************************************************************

INT2XX: MOV     #-1,INTFLG
        JSR     PC,DIAGRT       ;RESET
        RTI                     ;BACK TO TEST CODE

INTXST: DIAGRS                  ;RESET
        CLR     INTFLG
        MOV     @VECTOR,SAVE
        MOV     #INT2XX,@VECTOR
        RTS     PC
INTFLG: 0                       ;SET TO -1 IF INTERRUPT
INT2EX: DIAGRS
        MOV     #PR7,PS         ;BLOCK FURTHER INTERRUPTS
        MOV     SAVE,@VECTOR    ;RESTORE VECTOR
        RTS     PC

;SEQ189

;*******************************************************************
.REM    %
        DIAG2 TRIES TO SET AND CLEAR 10/11 DIAGNOSTIC MODE.
%
;*******************************************************************

DIA2:   MOV     #D1011,CORECT           ;SET BIT FOR COMPARISON
        DIAGMD                          ;SET DIAGNOSTIC MODE
        MOV     @DIAG1,ACTUAL           ;GET THE DIAGNOSTIC WORD
        MOV     #^C<D1011>,MASK         ;CLEAR ALL BUT DIAGNOSTIC MODE BIT
        
        MCMP16                          ;DID IT SET?
        BEQ     DIA21                   ;YES-TRY TO CLEAR IT
        ERR16   CORECT,ACTUAL,MASK,<D1011 DIDN'T SET\>

;*-+-+-+-+-+-+-+-+-+_+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM UNABLE TO SET 10/11 DIAGNOSTIC MODE. CHECK:

        1.  CNT3 DIAG 10/11 FLOP                (CNT3 B-7)
        2.  UNIBUS DATA TRANSCEIVER FOR BIT05   (CNT3 D-4)
        3.  CNT3 SEL DIAGL                      (CNT3 D-4)
        4.  CNT2 SEL DIAG1 H                    (CNT2 C-4)

                A SCOPE WYNCH FOR THIS PROBLEM IN INT1 DAT1 H (INT1 B-6).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

DIA21:  CLR     @DIAG1          ;CLEAR IT
        CLR     CORECT          ;AND COMPARISON WORD
        MOV     @DIAG1,ACTUAL   ;CAPTURE DIAG WORD 1
        MOV     #^C<D1011>,MASK ;MASK   OFF
        MCMP16                  ;DID IT CLEAR?
        BEQ     DIA2A           ;YES-TRY MASTER CLEAR
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        CNT3 DIAG 10/11 WILL NOT CLEAR WITH BIT0 OF DIAG WORD 1=0.
CHECK THE FLOP (CNT3 B-7).  A SCOPE SYNCH FOR THIS PROBLEM IS CNT2 DIAG 1
STRB H (CNT2 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ190

;*********************************************************************
;*NOW TRY DIAGNOSTIC RESET OF 10/11 DIAGNOSTIC MODE
;*********************************************************************

DIA2A:  DIAGMD                  ;SET DIAGNOSTIC MODE AGAIN
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     @DIAG1,ACTUAL   ;GET DIAG WORD 1
        MOV     #^C<D1011>,MASK ;CLEAR ALL BUT 10/11 DIAG MODE BIT
        MCMP16                  ;DID IT CLEAR?
        BEQ     DIA2EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK,<UNABLE TO FORCE RESET 10/11 DIAG MODE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        CNT3 DIAG 10/11 FLOP CAN HOLD A ZERO BUT WILL NOT CLEAR WITH
DIAGNOSTIC RESET.  CHECK THE RESET GATE ON THE FLOP (CNT3 A-8). A GOOD SCOPE
SYNCH FOR THIS PROBLEM IS CNT3 DIAG CLR (CNT3 A-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
DIA2EX: JMP     NORMAL          ;EXIT TO DISPATCHER

;SEQ191




.SBTTL  *CLOCK TESTING

;**********************************************************************
.REM %  THIS IS THE BEGINNING OF THE CLOCK TESTING.  CLK1
SIMPLY READS DIAGNOSTIC WORD 1 200(8) TIMES AND EXPECTS TO
SEE EACH OF THE MAJOR STATE FLOPS SET AT LEAST ONCE.
%
;**********************************************************************
CLK1:   MOV     #DEX!TO10!TO11,CORECT   ;ALL 3 SHOULD BE SET
        DIAGRS                          ;DIAGNOSTIC RESET
        CLR     ACTUAL                  ;WE'LL "OR" THE FLOPS INTO ACTUAL
        MOV     #200,R1                 ;R1 WILL BE THE COUNTER
CLK1A:  BIS     @DIAG1,ACTUAL           ;"OR" TJHE REGISTER INTO ACTUAL
        ;****NEXT 4 INSTRS ADDED TO PREVENT SYNCHRONIZATION PROBLEM*****
        MOV     R1, R0                  ;COPY OF COUNT
        BIC     #177770,R0              ;KEEP LEAST SIGNIFICANT 3 BITS
CLK1B:  ASR     R0                      ;SHIFT ONCE
        BNE     CLK1B                   ;GO BACK 0, 1 OR 2 TIMES
        DEC     R1                      ;DOWNCOUNT CTR
        BGT     CLK1A                   ;DO IT 200 TIMES
        MOV     #^C<DEX!TO10!TO11>,MASK ;BANK OUT ALL BUT MAJOR STATE FLOPS
        MOV     ACTUAL,R0                       ;GET ACTUAL
        BIC     MASK,R0                 ;MASK IT
        CMP     CORECT,R0                       ;DID ALL 3 SET?
        BEQ     CLK1EX          ;YES-THAT'S GOOD
        TST     R0                      ;NO-DID ANY BITS SET?
        BEQ     CLKERA                  ;TO CLKERA IF NONE SET
CLK1ER: ERR16   CORECT,ACTUAL,MASK,<ALL MAJOR STATE FLOPS WON'T SET\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        AFTER READING THE MAJOR STATE FLOPS (CNT4 TO11 TRANS, CNT4
TO10 TRANS. AND CNT4 DEX) 200 (8) TIMES.  THE PROGRAM FINDS THAT
ONE OR TWO OF THEM DID NOT SET CHECK:
        1.  THE INDIVIDUAL FLOPS                (CNT4 D-1 THRU D-3)
        2.  CNT4 STATE HOLD STUCK ON A ONE      (CNT4 C-4)
        3.  THE CLOCK GENERATION NEWTWORK AT THE TOP OF THE CNT7 PRINT
        4.  CDS2 EBUS 10/11 CLK                 (CNT7 C-5)
        5.  UNIBUS TRANSCEIVER OR SELECTOR FOR APPROPRIATE BIT
                (MIXER CNT3C-6 - XCEIVER CNT3 D-5-C-6)
        A SCOPE SYNCH POINT FOR THIS PROBLEM IS INT1 MST CLRH (INT1 D-3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
CLKERA: ERR16   CORECT,ACTUAL,MASK,<CLOCKS NOT RUNNING-"ACTUAL" = DIAG WORD 1\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        AFTER READING THE MAJOR STATE FLOPS (CNT4 TO11 TRANS, CNT4
TO10 TRANS, AND CNT4 DEX), 200 (8) TIMES, THE PROGRAM FINDS THAT NONE
OF THEM SET.  CHECK:
        1. THE THREE FLOPS              (CNT4 D-2 THRU D-3)
        2. THE CLOCK GENERATION NETWORK ON TOP OF THE CNT7 PRING.
        A SCOPE SYNCH FOR THIS PROBLEM IS INT1 MST CLR H (INT1 D-3).
%
;SEQ192

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

CLK1EX: JMP     NORMAL          ;GET NEXT TEST
;SEQ193


;******************************************************************
.REM    %
        CLK2 SETS DIAG 10/11 WHICH SHOULD SET CNT4 INH CLK CNT4 INH CLK
SHOULD INHIBIT THE GATED CLK PULSES WHICH WILL PREVENT THE MAJOR STAFF
FLOPS FROM CYCLING.
%
;*********************************************************************

CLK2:   DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        CLR     R0              ;MAJOR STATES WILL BE "OR'ED" INTO R0
        MOV     #20,R1          ;20 TRIES SHOULD BE ENOUGH
CLK2A:  BIS     @DIAG1,R0       ;GET THE MAJOR STATE(S)
        DEC     R1              ;DOWN COUNT CTR
        BGT     CLK2A
        BIC     #^C<DEX!TO10!TO11>,R0   ;CLEAR ALL BUT MAJOR STATES
        MOV     R0,ACTUAL               ;DIAG WORD 1 TO ACTUAL
        CMP     R0,#TO10                ;TO10 XFER ONLY?
        BEQ     CLK2EX          ;YES-EXIT
        CMP     R0,#TO11        ;NO-TO11 XFER ONLY?
        BEQ     CLK2EX          ;YES-EXIT
        CMP     R0,#DEX         ;NO-HOW ABOUT DEX?
        BEQ     CLK2EX          ;YES-EXIT
        ERRMSG  <\GATED CLOCKS WHILE DIAGNOSTIC MODE IS SET\>
FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        GATED CLKS OCCUR WHILE DIAG 10/11 IS SET.  CHECK:

        1.  CNT4 INH CLK FLOP           (CNT4 C-5)
        2.  CNT5 SINGLE PULSE FLOP (SHOULD BE CLEAR)    (CNT5 D-1)
        3.  CNT4 GO ST CLK (H)          (CNT4 C-5)

        A SCOPE SYNCH FOR THIS PROBLEM IS CNT3 DIAG 10/11 (CNT3 A-7)
UBIC MST CLR H (UBIC A2)
%
;*-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

CLK2EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ194


;*******************************************************************
.REM    %
        CLK3 SETS 10/11 DIAGNOSTIC MODE, DETECTS WHICH MAJOR STATE IS ON,
AND SINGLE PULSES THE CLOCK TO SEE IF THE MAJOR STATES ADVANCE CORRECTLY.
SINCE WE ALRREADY KNOW THAT TGHE MAJOR STATES ALL SET, ONE SINGLE PULSE
IS ADEQUATE  TO CHECK THE SINGLE PULSE LOGIC.
%
;*******************************************************************

CLK3:   DIAGRS                  ;MASTER CLEAR
        DIAGMD                  ;SET DIAGNOSTIC MODE
        MOV     #^C<DEX!TO10!TO11>,MASK  ;CLEAR ALL BUT STATEFLOPS
        MOV     @DIAG1,ACTUAL   ;SET ACTUAL TO DIAG1.
        BIC     MASK,ACTUAL     ;MASK OFF ALL BUT STATE FLOPS

        BIT     #TO11,ACTUAL    ;STOPPED @ TO11 XFER?
        BNE     CLTO11          ;YES
        BIT     #TO10,ACTUAL    ;NO-HOW ABOUT TO10 XFER?
        BNE     CLTO10          ;YES
        DIAGPL                  ;MUST BE DEX - PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATE
        BIC     MASK,ACTUAL     ;MASK OFF ALL BUT STATE FLOPS
        MOV     #TO11,CORECT    ;SET CORECT DATA.
        BIT     #TO11,ACTUAL    ;DID IT ADVANCE TO TO11 XFER?
        BEQ     CLK3ER          ;NO-ERROR
        CLK3EX: JMP     NORMAL          ;YES-EXIT
CLTO11: DIAGPL                  ;PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATE
        BIC     MASK,ACTUAL     ;MASK OFF ALL BUT STATE FLOPS
        MOV     #TO10,CORECT    ;SET CORECT DATA REGISTER.
        BIT     #TO10,ACTUAL    ;DID IT ADVANCE TO TO10 XFER?
        BEQ     CLK3ER          ;NO-ERROR
        BR      CLK3EX          ;YES-EXIT
CLTO10: DIAGPL                  ;PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATE
        BIC     MASK,ACTUAL     ;MASK OFF ALL BUT STATE FLOPS
        MOV     #DEX,CORECT     ;SET CORECT DATA REGISTER.
        BIT     #DEX,ACTUAL     ;DID IT ADVANCE TO DEX?
        BNE     CLK3EX          ;YES-EXIT
CLK3ER: ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-=_=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        CNT5 SINGLE PLS DOES NOT ALLOW CLOCK TO CYCLE ONCE.

CHECK:
        1.  CNT5 SINGLE PLS FLOP        (CNT5 D1)
        2.  CNT4 INH CLK FLOP           (CNT4 C5)

        A SCOPE SYNCH FOR THIS PROBLEM IS CNT3 DIAG 10/11 (CNT3 A-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ195


;*********************************************************************
.REM    %
        CLK4 CHECKS THE CLOCK STATE HOLD FLOP.  THE PROGRAM SETS 10/11
DIAGNOSTIC MODE AND DS05.  IT NEXT SINGLE PULSES THE CLOCK AND CHECKS
TO SEE THAT THE MAJOR STATE FLOPS DO NOT ADVANCE.
%
;**********************************************************************

CLK4:   DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #D1011!DS05,@DIAG1  ;SET 10/11 DIAG & DSO5 (HOLD "CLKS STATEHOLD"SET>
        NOP                     ;       A LITTLE TIME
        NOP                     ;       TO SET DIAG MODE
     MOV        @DIAG1,CORECT   ;GET THE MAJOR STATE FLOPS
        MOV     #^C<DEX!TO10!TO11>,MASK ;BLANK OUT ALL BUT MAJOR STATE
        DIAGP9                  ;SINGLE PULSE
        MOV     @DIAG1,ACTUAL   ;STATUS TO ACTUAL       
        MCMP16                  ;MAJOR STATE CHANGED?
        CMP     CORECT,ACTUAL   ;MAJOR STATE CHANGED?
        BEQ     CLK4EX          ;NO-EXIT
        ERR16   CORECT,ACTUAL,MASK,<STATES ADVANCED FROM "CORRECT" TO "ACTUAL"\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM FINDS THAT MAJOR STATE FLOPS ADVANCE AFTER
        TRYING TO SET CNT4 STATE HOLD FLOP.  CHECK:

        1.  CNT3 DIAG 10/11 FLOP                (CNT3 A-7)
        2.  CNT4 STATE HOLD FLOP                (CNT4 C-2)

A
        A SCOPE SYNCH FOR THIS PROBLEM IS INT1 MST CLR H (INT1 D-3)/
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

CLK4EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ196


;********************************************************************
.REM    %
        CLK9 MAKES SURE THAT EACH MAJOR STATE IS PRESENT BY ITSELF. AND
THAT THE MAJOR STATE COUNTER ADVANCES CORRECTLY FROM DEX TO TO11 XFER
TO TO10 XFER AND BACK TO DEX.
%
;********************************************************************

CLK9:   MOV     #DEX,CORECT     ;WE"LL START WITH DEX
        DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        MOV     @DIAG1,ACTUAL   ;GET DIAG WORD ONE (WITH STATE FLOPS)
        BIT     #DEX,@DIAG1     ;DID WE STOP IN DEX STATE?
        BNE     CLK9A           ;YES-PROCEE
        DIAGPL                  ;NO-PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATES AGAIN
        BIT     #DEX,@DIAG1     ;ARE WE THERE YET?
        BNE     CLK9A           ;YES-CONTINUE
        DIAGPL                  ;NO-THIS HAD BETTER DO IT
        BIT     #DEX,@DIAG1     ;WE SHOULD BE AT DEX
        BNE     CLK9A           ;WE ARE-CONTINUE
        ERRMSG  <UNABLE TO SINGLE PULSE INTO DEX\>
FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM UNABLE TO SINGLE PULSE INTO DEX MAJOR STATE.  SYNCH YOUR
        SCOPE ON CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK:

        1.  CNT4 STATE HOLD FLOP (SHOULD BE CLEAR       (CNT4 C-2)
        2.  CNT4 DEX FLOP                               (CNT4 D-1_)
%
;*-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+

        
CLK9A:  MOV     #^C<DEX!TO11!TO10>,MASK ;GET RID OF ALL BUT THESE THREE
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATES
        MCMP16                  ;ONLY DEX UP?
        BEQ     CLK9B           ;YES-CONTINUE TESTING
        ERR16   CORECT,ACTUAL,MASK,<ONLY DEX SHOULD BE SET\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MORE THAN ONE MAJOR STATE IS SET (ONLY DEX SHOULD BE TRUE).
SYNCH YOUR SCOPE ON THE CNT3 10/11 FLOP (CNT3 B-7) AND CHECK THE OTHER
TWO MAJOR STATE FLOPS.
%

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ197


CLK9B:  MOV     #TO11,CORECT    ;NEXT ADVANCE TO TO11 MAJOR STATE
        DIAGPL                  ;PULSE THE CLOCK (SHOULD ADVANCE TO TO11
                                ;XFER)
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATES
        MCMP16                  ;;TO11 ONLY?
        BEQ     CLK9C           ;YES-CONTINUE
        ERR16   CORECT,ACTUAL,MASK,<ONLY TO11 SHOULD BE SET\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MORE THAN ONE MAJOR STATWE FLOP SET (ONLY TO11 SHOULD BE TRUE),
OR MAJOR STATE COUNTER STUCK AT DEX. SYNCH YOUR COPE ON THE CNT4 DEX FLOP
(CNT4 D-1) AND CHECK THE CNT4 TO11 XFER FLOP AND THE CNT4 TO10 XFER FLOPS.
%
;*-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+

CLK9C:  MOV     #TO10,CORECT    ;FINALLY CHECK TO10 MAJOR STATE
        DIAGPL                  ;PULSE THE CLOCK (SHD ADVANCE TO TO10 XFER)
        MOV     @DIAG1,ACTUAL   ;GET MAJOR STATES
        MCMP16                  ;TO 10 ONLY?
        BEQ     CLK9D           ;YES-CONTINUE
        ERR16   CORECT,ACTUAL,MASK,<ONLY TO10 SHOULD BE SET\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+_+-+-+-+-+_=_=-+-+-+-+-+-+-+-+
.REM    %
        MORE THAN ONE MAJOR STAT FLOP SET (ONLY TO10 SHOULD BE TRUE), OR
MAJOR STATE COUNTER STUCK AT TO11 XFER.  SYNCH YOUR SCOPE ON CNT4 TO11
XFER FLOP (CNT4 D-3) AND CHECK THE OTHER TWO MAJOR STATE FLOPS.
%

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+
CLK9D:  MOV     #DEX,CORECT     ;NOW TRY TO GET BACK TO DEX
        DIAGPL                  ;PULSE THE CLOCK (SHOULD BRING US BACK
                                ;TO DEX)
        MOV     @DIAG1,ACTUAL   ;HET MAJOR STATES
        MCMP16                  ;BACK AT DEX?
        BEQ     CLK9EX          ;YES-EXIT TEST
        ERR16   CORECT,ACTUAL,MASK,<CAN'T SINGLE PULSE INTO DEX STATE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

.REM    %
        MAJOR STATE COUNTER NOT ADVANCING CORRECTLY FROM TO10 XFER TO DEX.
SYNCH YOUR SCOPE ON THE CNT4 TO10 XFER FLOP (CNT4 D-2), AND CHECK THE
OTHER TWO MAJOR STATE FLOPS.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-=_+_+-+-+-+-+-=_=_+-+_=_=-+-+-+-=

CLK9EX: JMP     NORMAL          ;GET TEXT TEST

;SEQ198


.SBTTL  *RAM TESTING

;*************************************************************************
.REM    %
        HERE BEGINS RAM TESTING.  UP TO THIS POINT, THE PROGRAM HAS NOT
ADDRESSED ANY OF THE TWELVE ACTIVE RAM LOCATIONS.  A FAIR AMOUNT OF
UNTESTED LOGIC (PRINCIPALLY THE CNT1 FUNCTIONS LEADING TO "CNT1 RAM
CYC") IS USED FOR THE FIRST TIME.  RAM1 TIRES TO ADDRESS ALL TWELVE RAM
LOCATIONS AND USES AN INSTRUCTION TIMEOUT AS AN ERROR INDICATOR.
%
;**********************************************************************

RAM1:   MOV     4,SAVE          ;REPLACE TIMEOUT VECTOR WITH "RAM1ER"
        MOV     #RAM1ER,4
        DIAGRS          ;DIAGNOSTIC RESET
        MOV     DLYCNT,R0       ;1ST RAM ADDRESS R0

RAM1A:  MOV     R0,CORECT       ;AND CORECT FOR COMPARISON
        TST     (R0)+           ;THIS SHOULDN'T TIME OUT
        CMP     R0,DIAG1        ;DONE LAST RAM ADDRESS YET?
        BNE     RAM1A           ;NO-CHECK NEXT RAM ADDRESS
        BR      RAM1EX          ;YES-EXIT
RAM1ER: ERRMSG  <TIMEOUT WHILE ADDRESSING CONTENTS OF >
        MOV     CORECT,R0
        ERROCT
        FAULT

;*-+-+-+-+-+_+_+_+_+-+-+-+-+-+-+-+-=-+-=-+-+-=-=-=-+-+-+-+-=-=-+-+
.REM    %
        PROGRAM GOT INSTRUCTION TIMEOUT WHILE ADDRESSING RAM ADDRESS
STORED IN R0.  IF THE FILING ADDRESS IS THAT OF THE DELAY COUNTER
(I.E., THE FIRST RAM ADDRESS), CHECK:

        1.  CNT2 RAM ADR                (CNT2 C-7)
        2.  THE NETWORK WHICH SET CNT1 D-8 THRU D-5)
        3.  THE NETWORK WHICH YIELDS CNT2 SSYN OUT (CNT2 C-4)
        IF AN ADDRESS OF THER THAN THAT OF THE DELAY COUNT FAILED, THE
PROBLEM IS PROBABLY IN THE DECODER WHICH PRODUCES THE INDICATED
SELECTION LEVEL (CNT2 D-7).  A SCOPE SYNCH FOR THIS PROBLEM IS INT1
MST CLR (INT1 D-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+

RAM1EX: MOV     SAVE,4          ;RESTORE TIME OUT VECTOR
        JMP     NORMAL  ;AND GET NEXT TEST

;SEQ199


;*******************************************************************
.REM    %
        RAM11 SIMPLY TRIES TO WRITE ALL ZEROES INTO THE DELAY COUNTER
AND READ THEM BACK.  NOTE THAT THIS IS THE FIRST TIME WE TRY TO READ
ANYTHING FROM THE RAM.
%
;*******************************************************************

RAM11:   CLR     CORECT          ;CLEAR COMPARISON LOCATION
        DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        MOV     #0,@DLYCNT      ;THE DELAY COUNT IS THE MOST
                                ;INNOCUOUS RAM LOCATION
        MOV     @DLYCNT,ACTUAL  ;READ IT BACK
        BEQ     RAM11X          ;EXT IF ALL ZEROES
        ERR16   CORECT,ACTUAL,,<TRYING TO READ ZEROES FROM DELAY COUNTER\>


;*-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        WHILE ATTEMPTING TO WRITE ZEROES INTO THE DELAY COUNTER,
THR PROGRAM READ ONE OR MORE ONES.  CHECK:

        1.CNT2 SEL DLY CNT L                    (CNT2 D-7)
        2. THE DPS1 AND DPS4 MIXERS FOR THE FAILING BITS        (DPS1-DPS4)
        3. THE RAM OUTPUTS(S) FOR THE FAILING BITS      (DPS4 D-7 THRU D-1)
        4. THE UNIBUS TRANSCEIVERS FOR THE FILING BITS (DPS6 C-1 THRU C-7)

        SA SCOPE SYNCH FOR THIS PROBLEM IS THE CNT3 DIAG 10/11 FLOP
                                                        (CNT3 B-7).
%
;*-_-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+

RAM11X: JMP     NORMAL          ;GET NEXT TEST

;SEQ200


;*****************************************************************
.REM    %
        RAM2 WRITES ZEROES IN ALL ACTIVE RAM LOCATIONS AND READS THEM BACK.
TWO ERRORS ARE POSSIBLE: RM2ER1 IF NON-ZEROES ARE RETURNED AND RM2ER2
IF ZEROES ARE RETURNED BUT THE FUNCTION "RFM=0" (AVAILABLE IN STATUS
REG.) IS RETURNED FALSE.
%
;*********************************************************************



RAM2:   MOV     DLYCNT,R1       ;FIRST RAM ADDRESS TO R1
RAM2A:  DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        CLR     (R1)+           ;LOAD RAM LOCATION WITH ZEROES
        CMP     R1,DIAG1                ;LOADED LAST RAM LOCATION?
        BNE     RAM2A           ;NOPE-LOAD NEXT
RAM2B:  DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        MOV     -(R1),ACTUAL    ;RAM CONTENTS TO ACTUAL
        BNE     RM2ER1          ;TO RM2ER1 IF NON-ZEWRO
        BIT     #RAMISO,@STATUS ;DID RFM=0 SET?
        BEQ     RM2ER2          ;NO-ERROR
        CMP     R1,DLYCNT               ;BACK DOWN TO DLYCNT YET?
        BGT     RAM2B           ;NO-CHECK ANOTHER RAM LOCATION
        BR      RAM2EX          ;YES-GET OUT
RM2ER1: ERRMSG  <PROGRAM EXPECTED ZEROES IN LOCATION >
        MOV     R1,R0           ;GET FAILING ADDRESS
        ERROCT
        ERRMSG  < BUT READ >
        MOV     ACTUAL,R0       ;GET FAILING WORD
        ERROCT
        ERCRLF
FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        WHILE ATTEMPTING TO WRITE ZEROES IN A RAM LOCATION PROGRAM
DETECTED A NON-ZERO WORD.  THE WORD IS IN ACTUAL; THE ADDRESS IN R1.
CHECK:

        1. CNT2 SEL FUNCTION WHICH IS USED FOR THE TESTED ADDRESS
        (THE INTERFACE MAYBE SELECTING A NON-RAM LOCATION)
                                                (CNT2 D-7)
        2. THE DPS1 AND DPS4 MIXERS FOR THE FAILING BIT(S) 
                                                (DPS1 &DPS4)
        3. ACTUAL RAM OUTPUT(S) (-DPS4 DAT 00 - -DPS4 DAT 15)
                                                (DPS4 D2 THRU D-7)

        A GOOD SCORE SYNCH FOR THIS PROBLEM IS CNT1 WR PLS (CNT1 A-2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ201


RM2ER2: MOV     @STATUS,ACTUAL  ;GET STATUS WORD
        ERRMSG  <RAM=0 FALSE WITH ALL 0'S.  STATUS = >
        MOV     ACTUAL,R0
        ERROCT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-=-=-+-+-+
.REM    %
        RAM=0 FALSE WHEN READING ALL ZEROES FROM RAM.
CHECK:
        
        1. DPS4 RAM=0                   (DPS4 B-1)
        2. UNIBUS MIXER DPS4 DATA 12 MIX H      (DPS4 B-6)

        A SCOPE SYNCH FOR THIS PROBLEM IS INT1 MST CLR L (INT1 D-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+

RAM2EX: JMP     NORMAL

;SEQ202


;*********************************************************************
.REM    %
        RAM22 IS SIMILAR TO RAM11 EXCEPT THIS TIME ALL ONES ARE WRITTEN
INTO THE DELAY COUNTER.
%

;*****************************************************************

RAM22:  MOV     #-1,CORECT      ;WE'LL COMPARE FOR ONES
        DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
        MOV     #-1,@DLYCNT     ;SEND THE ONES
        MOV     @DLYCNT,ACTUAL  ;READ THEM BACK TO ACTUAL
        CMP     CORECT,ACTUAL   ;DID THEY GET THERE?
        BEQ     RAM22X          ;YES-EXIT
        ERR16   CORECT,ACTUAL,,<TRYING TO READ ALL ONES FROM DELAY COUNTER\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
.REM    %
        WHILE ATTEMPTING TO READ ALL ONES FROM THE DELAY COUNTER, ONE OF
MORE ZEROES WERE DETECTED.  SYNCH YOUR SCOPE ON BCON DIAG 10/11 (BCON D2)
AND CHECK THE FUNCTIONS LISTED IN THE ERROR REMARKS FOR SUBTEST RAM11
ABOVE.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

RAM22X: JMP     NORMAL  ;GET NEXT TEST

;SEQ203


;********************************************************************
.REM    %
        RAM3 IS SIMILAR TO RAM2 EXCEPT THIS TIME ALL ONES ARE WRITTEN
INTO THE TWELVE RAM LOCATIONS.
%
;********************************************************************

RAM3:   MOV     DLYCNT,R0       ;FIRST RAM ADDRESS TO R0
RAM3A:  DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SETDIAGNOSTIC MODE
        MOV     #-1,(R0)+       ;SET A LOCATION TO ALL ONES
        CMP     R0,DIAG1        ;LAST RAM LOCATION LOADED?
        BNE     RAM3A           ;NO-DO IT AGAIN!

RAM3B:  MOV     #-1,CORECT      ;SET UP FOR COMPARISON PRINT OUT
        DIAGRS                  ;REET AGAIN
        DIAGMD                  ;SET DIAG MODE OR NPR'S WILL OCCUR.
        MOV     -(R0),ACTUAL    ;RAM CONTENTS TO ACTUAL
2$:     CMP     CORECT,ACTUAL   ;ALL ONES?
        BNE     RAM3ER          ;NO-ERROR

3$:     CMP     R0,DLYCNT       ;DONE?
        BGT     RAM3B           ;NO-CHECK NEXT WORD
        BR      RAM3EX          ;YES-EXIT

        
RAM3ER: ERRMSG  <PROGRAM EXPECTED TO READ ALL ONES FROM LOCATION >
        ERROCT                  ;R0 ALREADY HAS THE FAILING ADDRESS
        ERRMSG  < BUT READ >
        MOV     ACTUAL,R0       ;GET FAILING DATA WORD
        ERROCT
        ERCRLF
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+-+-+-+_+_+-+-+-+-=+-+
.REM    %
        WHILEE ATTEMPTING TO READ ALL ONES FROM A RAM LOCATION, PROGRAM
DETECTED A WORD WITH ONE OR MORE ZEROES.  CHECK:
        1. CNT1 WRPLS L (MAYBE NOTHING WAS WRITTEN)     (CNT1 A-2)
        2. THE DPS1 MIXER(S) FOR THE FAILING BITS(S)   (DPS1 D-E
                                                (DPS1 D-3 THRU D-7)
        3. THE ACTUAL RAM OUTPUTS (-DPS4 DAT 00 - DPS4 DAT 15)
                                                (DPS4 D-2 THRU D-7)
        4. THE UNIBUS TRANCEIVERS FOR THE FAILING BITS (DPS4 C-1 THRU C-4)

        A SCOPE SYNCH FOR THIS PROBLEM IS INT1 MST CLR L (INT1 D-4)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+

RAM3EX: JMP     NORMAL          ;RETURN TO NEXT TEST

;SEQ204


;*********************************************************************
.REM    %
        RAM4 MAKES SURE THAT CNT1 SWAP H IS NOT STUCK TRUE.  IT LOADS
THE DELAY COUNT WITH 0000377 AND MAKES SURE THAT IT DOESN'T READ AS
T177400.
%
;**********************************************************************

RAM4:   MOV     #377,CORECT     ;SETUP FOR COMPARISON
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #377,@DLYCNT    ;8 ZEROES AND 8 ONES TO DELAY COUNT
        MOV     @DLYCNT,ACTUAL  ;GET THE RAM LOCATION
        CMP     CORECT,ACTUAL   ;DID IT CHANGE?
        BEQ     RAM4EX          ;NO-EXIT
        CMP     #177400,ACTUAL  ;YES-IS IT SWAPPED?
        BNE     RM4ER2          ;NO-SIMPLE COMPARISON ERROR
RM4ER1: ERR16   CORECT,ACTUAL,,<SWAP FAILURE\>

;*-+-+-+-+-+-+-+_+_+-+-=_=_+_+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=
.REM    %
        RIGHT AND LEFT BYTES OF RAM ARE SWAPPED.  CHECK CNT1 SWAP H
(CNT1 C-7).  A SCOPE SYNCH FOR THIS PROBLEM IS CNT1 WR PLS L (CNT1 A-2).
%
;*-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+

RM4ER2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        RAM DATA COMPARISON ERROR.  DELAY COUNT SHOULD CONTAIN 0000377.
A SCOPE SYNCH FOR THIS PROGLEM IS CNT1 WR PLS (CNT1 A-2).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

RAM4EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ205


;*******************************************************************
.REM    %
        RAM5 IS THE FIRST SERIOUS RAM DATA TEST.  IT FILLS RAM WILL ALL
ONES.  IT HTEN READS ONES FROM EACH LOCATION AND WRITES ZEROES BACK.
ADDRESSING PROBLEMS WILL CAUSE ZEROES TO APPEAR WHERE ONES ARE EXPECTED.
%
;*******************************************************************

RAM5:   MOV     DLYCNT,R0       ;FIRST RAM ADDRESS TO R0
        DIAGRS                  ;DIAAGNOSTIC RESET
        DIAGMD                  ;SET DIAG MODE OR NPR'S WILL OCCUR.
RAM5A:  MOV     #-1,(R0)+       ;LOAD A RAM LOCATION WITH ONES
        CMP     R0,DIAG1        ;LOADED ENTIRE RAM?
        BNE     RAM5A           ;NO-DO IT AGAIN

        MOV     DLYCNT,R0       ;RELOAD R0
RAM5B:  MOV     #-1,CORECT      ;SET UP FOR COMPARISON
        MOV     (R0),ACTUAL     ;READ RAM DATA
        CMP     CORECT,ACTUAL   ;ONES GET THERE?
        BNE     RM5ER1          ;NO-SIMPLE COMPARISON ERROR
        CLR     (R0)+           ;YES-FILL IT WITH ZEROES
        CMP     R0,DIAG1        ;DONE LAST REGISTER?
        BNE     RAM5B           ;NO-DO IT AGAIN

RAM5C:  CLR     CORECT          ;YES,NOW COMPARE FOR ZEROES
        TST     -(R0)           ;NOW SEE IF IT'S LL ZEROEOS
        BNE     RM5ER2          ;TO RM5ER2 IF A LOCATION ISN'T CLEAR
        CMP     R0,DLYCNT       ;DONE?
        BGT     RAM5C           ;NO-CHECK AGAIN
        BR      RAM5EX
RM5ER1: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+
.REM    %
        RAM ADDRESS SELECTION PROGLEM.  R0 CONTAINS A RAM ADDRESS WHICH
SHOULD CONTAIN ALL ONES BUT DOESN'T DUE TO WRITING ZEROES IN A LOWER
ADDRESSED RAM LOCATION.
CHECK:

        1. CNT1 ADDRESS MIXER           (CNT1 B-5)
        2. THE ACTUAL RAM CHIPS         (DPS4 D-2 THRU D-7)

        A SCOPE SYNCH POINT FOR THIS PROBLEM MIGHT BE THE CNT2 SEL LEVEL
        ASSOCIATED WITH THE FAILING ADDRESS (E.G., CNT2 SEL DW1 L.
        CNT2 SEL ADR 2L,ETC.)  @ CNT2 D-7.
%
;*-+-+-+-=-=-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ206


RM5ER2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-=-+
.REM    %
        PROGRAM FILLED RAM WITH ONES, CHECKED EACH LOCATION
FOR ONES,AND REWROTE ZEROES.  AFTER COMPLETING THIS, A SCAN OF RAM FOUND
A NON-ZERO LOCATION.  CHECK:

        1.      CNT1 ADDRESS MIXER              (CNT1 B-5)
        2.      THE ACTUAL RAM CHIPS            (DPS4 D-2 THRU D-7)

        A SCOPE SYNCGH POINT FOR THIS PROBLEM IS THE CNT2 SEL LEVEL
ASSOCIATED WITH THE ADDRESS STORED IN R0 (E.G., CNT2 SEL DW1L, CNT2 SEL
ADR2L, ETC.) ON THE CNT2 PRINT @ D-7.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

RAM5EX: JMP     NORMAL

;SEQ207

;*********************************************************************
.REM    %
        RAM6 IS YOUR TRYPICAL MEMORY ADDRESS TEST.  THE FIRST RAM 
LOCATION (THE DELAY COUNT) IS LOADED WITH FOUR FOUR-BIT BYTES OF ZEROES,
THE SECOND LOCATION (DEX WORD 1) GETS FOUR FOUR-BIT BYTES OF 2, THE
THIRD 4, ETC., BY USING FOUR FOUR-BIT BYTES A MEASURE OF ISOLATION TO
THE FOUR INDIVIDUAL 7489 RAM CHIPS IS PROVIDED.
%
;*******************************************************************
RAM6:   MOV     DLYCNT,R0       ;ADDRESS OF FIRST RAM LOC. TO R0
        CLR     R1                      ;START WITH 4 BYTES OF 0000
        DIAGRS                          ;DIAGNOSTIC RESET
        DIAGMD                          ;SET DIAGNOSTIC MODE
RAM6A:  MOV     R1,(R0)+        ;LOAD A RAM LOCATION
        ADD     #21042,R1       ;NEW BYTE = OLD BYTE?
        CMP     R0,DIAG1        ;LOADED LAST REGISTER?
        BNE     RAM6A           ;NO-DO IT AGAIN!
RAM6B:  SUB     #21042,R1       ;GENERATE COMPARE PATTERN
        MOV     R1,CORECT       ;SET UP COMPARISON WORD
        MOV     -2(R0),ACTUAL   ;SAVE ACTUAL DATA
        CMP     R1,-(R0)        ;PATTERN CORRECT?
        BNE     RAM6ER          ;ERROR
        TST     R1              ;DONE ALL PATTERNS?
        BNE     RAM6B           ;NO-DO IT AGAIN
        BR      RAM6EX          ;YES-EXIT
RAM6ER: ERRMSG  <RAM ADDRESSING FAILURE. LOC. >
        ERROCT                  ;R0 CONTAINS THE ADDRESS
        ERRMSG  < SHOULD BE "CORRECT" BUT IS "ACTUAL"\>
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+
.REM    %
        COMPARISON ERROR IN RAM ADDRESSING TEST.  R0 CONTAINS TRESTED RAM
ADDRESS ,R1 CONTAINS CORRECT CONTENTS.  IF ALL FOUR FOUR-BIT BYTES ARE
INCORRECT, THE PROBLEM IS MOST LIKELY ION THE CNT1 ADDRESS MIXER (CNT1
ADR3-ADR1 @ B-5).  IF ONLY ONE FOUR-BIT BYTE IS INCORRECT, THE PROBLEM
IS PROBABLY IN THE INTERNAL ADDRESSING LOGIC OF THE 7493 RAM CHIP WHICH
HOLDS THESE FOUR BITS (DPS4 D-2 D-7).  A USABLE SCOPE SYNCH POINT FOR
THIS PROBLEM IS THE CNT2 SEL LEVEL ASSOCIATED WITH THE FAILING ADDRESS
(E.G., CNT2 SEL DLY CNT L, CNT2 SEL TO10 BC L, ETC.) (CNT2 D-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-=-+-+-+-+-+-+-+-+

RAM6EX: JMP     NORMAL

;SEQ208


;*****************************************************************
.REM    %
        RAM7 IS A SIMPLE TEST OF THE RAM ZERO DETECTION LOGIC (RAM=0).
RAM2 HAS ALREADY DHCKED TO SEE THAT RAM=0 WILL SET WHEN ALL ZEROES ARE
READ FROM THE RAM.  RAM7 WILL MAKE SURE THAT IT DOESN'T SET WITH A
FLOATING ONE COMING OUT OF THE RAM.
%;*****************************************************************

RAM7:   DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #BIT0,R0        ;START WITH BIT0
RAM7A:  MOV     R0,@DLYCNT      ;LOAD DELAY COUNT WITH PATTERN
        MOV     @STATUS,ACTUAL  ;STATUS REG. HOLDS RFM=0 BIT
        BIT     #RAMISO,@STATUS ;DID RFM=0 SET?
        BNE     RAM7ER          ;YES-REPORT ERROR
        CLC                     ;DLEAR CARRY PRIOR TO ROTATE
        ROL     R0              ;SHIFT ONE BIT TO LEFT
        BNE     RAM7A           ;CHECK AGAIN IF NON-ZERO
        BR      RAM7EX          
RAM7ER: ERRMSG  <RFM=0 TRUE WHEN READING >
        MOV     ACTUAL,R0
        ERROCT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        RAM=0 TRUE WITH A ONE BIT COMING OUT OF RAM. CHECK GATING
NETWORK @ DPS4 B-2.  A SCOPE SYNCH POINT IS THE RAM DATA OUTPUT FOR THE
FAILING BIT (DPS4 DAT 15 H - DPS4 DAT 00 H) ON THE DPS4 PRINT (D-2 - D-7)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+

RAM7EX: JMP     NORMAL

;SEQ209


.SBTTL  *STATE COUNT TESTING

;*******************************************************************
.REM    %
        SC1 LOCKS THE 10/11 INTERFACE IN DEX MODE AND LOADS THE STATE
COUNT WITH A BINARY COUNT OF 0-4. IT READS THE RAM ADDRESS ASSOCIATED
WITH EACH OF THE DEX MINOR STATES.
%
;*********************************************************************

SC1:    JSR     PC,LOKDEX       ;LOCK MACHINE IN DEX MAJOR STATE
        CLR     R2              ;WE'LL USE R2 FOR LOADING STATE COUNT
        MOV     #DEXTAB,R1      ;DEXTAB IS A TABLE OF RFM ADDRESSES
SC1C:   MOV     (R1)+,CORECT    ;SET CORRECT DATA REGISTER
        INC     R5              ;NEXT SUBTEST
        MOV     R2,@DIAG2       ;PUT A COUNT IN THE STATE COUNTER
        JSR     PC,RAMASK       ;GET DATA AND STRIP.
        MCMP16                  ;GADDRESS SAME AS ON TABLE?
        BNE     SC1ER           ;NO-ERROR
        TST     (R1)            ;AT END OF DEXTAB?
        BEQ     SC1EX           ;YES,EXIT
        INC     R2              ;NO - DO IT AGAIN
        INC     R2
        BR      SC1C            ;
SC1ER:  ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+-=-+-+-+
.REM    %
        FAILURE DURING CHECK OF STATE COUNT DURING DEX.  DIAG3 CONTAINS
INCORRECT COUNT; ADDRESS POINT TO BY R1 CONTAINS CORRECT COUNT.
CHECK:

        1. 7493 BIN CTR                 (CNT4 B-6)
        2. 7442 DEXADR DECODER          (CNT4 B-6)
        3. NETWORK WHICH YIELDS CNT 1 ADROH - CNT1 ADR3H (CNT4 B-5)
        4. UNIBUS DATA MIXERS FOR BITS 12-15    (DPS6 B-8 THRU B-6)

        A SCOPE SYNCH POINT FOR THIS PROGRAM IS CNT3 DIAG 10/11 (CNT3 B-7)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC1EX:  JMP     NORMAL

;SEQ210


;*********************************************************************
;*DEXTAB IS A TABLE OF RFM ADDRESSES AS SEEN BY
;*DIAG3 DURING A DEPOSIT OR EXAMINE
;*********************************************************************


DEXTAB: RFMAD1          ;SUBTEST 1 - ADDRESS=10 (10 ADDRESS WORD 1)
        RFMAD3!RFMAD1          ;SUBTEST 2 - ADDRESS=12 (10 ADDRESS WORD 2)
        RFMAD3!RFMAD2           ;SUBTEST 3 - ADDRESS=02 (DEX WORD 1)
        RFMAD2                  ;SUBTEST 4 - ADDRESS=04 (DEX WORD 2)
        RFMAD3                  ;SUBTEST 5 - ADDRESS=06 (DEX WORD 3)
        0                       ;NULL TO DELIMIT TABLE

;*********************************************************************
;*LOKDEX WILL LOCK THE 10/11 INTERFACE INTO THE DEX MAJOR STATE
;*********************************************************************

LOKDEX: DIAGRS
        
LOCDEX: DIAGMD
LKDEXA: BIT     #DEX,@DIAG1     ;DID WE STOP IN DEX MODE?
        BNE     LKDEXB          ;YES-EXIT
        DIAGPL                  ;NO-PULSE THE CLOCK
        BR      LKDEXA          ;AND TRY AGAIN
LKDEXB: MOV     #D1011!DS05,@DIAG1      ;SET STATE HOLD
        NOP                     ;       A LITTLE TIME
        NOP                     ;       TO SET DIAG MODE
        RTS     PC              ;AND RETURN

;SEQ211



;*******************************************************************
.REM    %
        SC20 LOCKS THE INTERFACE IN DEX STATE, LOADS A STATE COUNT OF
17(8), AND SINGLE PULSES THE CLOCK.  IT THEN CHECKS THE RAM ADDRESS BITS
TO SEE IF THE STATE COUNTEWR HAS ADVANCED TO 00(8).  SINCE WE ALREADY
KNOW THAT THE SINGLE PULSE LOGIC WORKS, AND THAT THE STAE COUNTER CAN
PRODUCE THE CORRECT DEX MINOR STATE, FAILURES IN THE TEST MOST LIKELY
INDICATE FAILURES IN THE 74193 UP COUNTER CHIP.
%
;******************************************************************


SC20:   MOV     #RFMAD1,CORECT  ;SET CORRECT DATA REGISTER
        JSR     PC,LOKDEX       ;LOCK INTERFACE IN DEX MODE
        MOV     #36,@DIAG2      ;SET STATE COUNT TO ALL ONES
        DIAGP9                  ;STATE COUNT SHOULD ADVANCE TO 00
        JSR     PC,RAMASK       ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                  ;ADVANCED TO 00?
        BEQ     SC20EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE IN STATE COUNTER ADVANCE FROM 17 TO 00.  SYNCH YOUR SCOPE
ON CNT2 DIAG COM STRB (CNT2 A-7) AND CHECK:
        1. 74193 UP COUNTER             (CNT4 B-6)
        2. INT1 BUS COMP FLOP (SHOULD BE RESET) (INT1 B-1)
        3. CNT5 SINGLE PLS              (CNT5 D-1)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC20EX: JMP     NORMAL

;SEQ212


;****************************************************************
.REM    %
        SC21 LOCKS THE INTERFACE IN DEX MODE, FORCES A MINOR STATE COUNT
OF 00, PULSES THE CLOCK AND CHECKS (VIA READING THE RFM AD BITS FROM
DIAG3) TO SEE IF THE COUNT HAS ADVANCED TO 01.
        IF THIS WORKS, THE PROGRAM AGAIN PULSES THE CLOCK AND READS THE
RFM ADDRESS BITS TO MAKE SURE THE COUNT DOES NOT ADVANCE TO 02 (TH AD=
RFM ADDRESS BITS TO MAKE SURE THE COUNT DOES NOT ADVANCE TO 02 (THE AD=
VANCE SHOULD BE INHIBITED SINCE INT1 BUS COMP(0) SHOULD HOLD CNT4 INH
CLK SET).
%
;**********************************************************************
SC21:   MOV     #RFMAD1!RFMAD3,CORECT   ;SET CORRECT DATA REGISTER
        JSR     PC,LOKDEX               ;LOCK INTERFACE IN DEX STATE
        CLR     @DIAG2                  ;FORCE MINOR STATE "DEX ADR1"
        DIAGP9                          ;ADVANCE TO "DEXWD1"
        JSR     PC,RAMASK         ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                          ;ADVANCED TO 01?
        BEQ     SC21A                   ;YES-CONTINUE TESTING
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+_+_+-+_+_+-+-=_=_+_+-=-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR STATE COUNTER NOT ADVANCING FROM 00 TO 01 CORRECTLY.  SYNCH
YOUR SCOPE ON INT1 MST CLR L (INT1 D-4) AND CHECK THE 74193 MINOR STATE
COUNTER CHIP (CNT4 B-6).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;*********************************************************************
.REM    %
        KNOWING THAT THE 74193 STATE COUNTER CAN ADVANCE TO MINOR STATE
'DEX ADR2", THE PROGRAM WILL NEXT ATTEMPT TO SINGLE PULSE TO MINOR STATE
"DEX WD1", THE INCREMENTATION OF THE MINOR STATE COUNTER SHOU,D BE
INHIBITED SINCE THE INT1 BUS COMP FLOP BEING RESET SHOULD HOLD THE CNT4
INH CLK FLOP SET.
%
;*********************************************************************
SC21A:  MOV     #RFMAD1!RFMAD3,CORECT   ;SET CORRECT DATA REISTER
        DIAGPL                          ;TRY TO PULSE THE CLOCK
        JSR     PC,RAMASK               ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                          ;CLOCK ADVANCE?
        BEQ     SC21EX                  ;NO (THAT'S GOOD!)
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+_+_+_+_+-+-+-+-+-+-+-+-+-+-+_+-+-+-+-+-+-+-+-+-+-+
.REM    %
CLOCK CYCLING WHILE INT1 BUS COMPLETE FALSE.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+_+_=_=_+_=_=_+_+-+-+-+-+-+-+-+-+-+-+-+-+

SC21EX: JMP     NORMAL

;SEQ213


;*****************************************************************
.REM    %
        SC22 LOCKS THE INTERFACE IN DEX MODE AND FORCES MINOR STATE "DEX
ADR2" TRUE WITH THE EBDONE SET BIT TRUE.  THE TEST THEN PULSES THE CLOCK
TO SEE IF THE MINOR STATE WILL ADVANCE TO "DEX WD1".
        IF THIS WORKS, THE ROUTINE CONTINUES PULSING THE CLOCK, CHECKING
FOR DECODES "DEX WD2" AND "DEX WD3".
%
;**********************************************************************

SC22:   MOV     #RFMAD1!RFMAD3,CORECT   ;SET CORRECT DATA REGISTER
        JSR     PC,LOKDEX       ;LOCK INTERFACE IN DEX MODE
        MOV     #2!EDONES,@DIAG2        ;FORCE "DEX ADR2" AND BUS DONE
        DIAGP9                          ;PULSE THE CLOCK
        JSR     PC,RAMASK               ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                          ;STILL AT MINOR STATE,"DEX ADR2"?
        BNE     SC22A                   ;NO-GO SEE IF IT IS AT "DEX WD1"
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+
.REM    %
        MINOR STATE COUNT NOT ADVANCING FROM 01 TO 02 DURING DEX WHI8LE TRYING

TO SET INT1 BUS COMP.  CHECK:

        1. CNT2 BUS DONE SET L                  (CNT2 D-1)
        2. INT1 BUS COMP FLOP                           (INT1 B-1)
        3.      AINPUT GATING NEWTORK TOCNT4 INH CLK FLOP  (CNT4 C-5)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE MINOR STATE DECODE
"CNT4 DEX ADR 2 L" (CNT4 B-5).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-=-=-=-+-=-+-=-+-+-+-+-+-+

;*******************************************************************
.REM    %
        KNOWING THAT THE MINOR STATE COUNTER CAN ADVANCE PAST 01, THE RE-
MAINDER OF THIS TEST STEPS THROUGH THE REST OF THE DEX MINOR STATE,
READING THE ASSOCIATED RFM ADDRESS BITS VIA DIAG WORD 3.
%
;********************************************************************

SC22A:  MOV     #RFMAD3!RFMAD2,CORECT   ;SET UP FOR NEXT MAJOR STATE
        MCMP16                          ;DID COUNTER STEP TO DECODE "DEX WD1"?
        BEQ     SC22B                   ;YES-CONTINUE CHECKING
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR STATE COUNTER INCREMENTING INCORRECTLY FROM 01 TO 02 SYNCH
YOUR SCOPE ON MINOR STATE DECODE "CLKS DEX ADR2 L", AND CHECK
OUTPUTS OF THE 74193 UP COUNTER CHIP (CLKS D1).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ214


SC22B:  MOV     #RFMAD2,CORECT   ;NEXT MINOR STATE TO CORRECT
        DIAGP9                  ;STEP DEXWD1 TO DEXWD2
        JSR     PC,RAMASK               ;MASK OUT BUT RAM ADDRESS BITS
        MCMP16                  ;ADDRESS = 02?
        BEQ     SC22C   ;YES-STEP ONCE AGAIN
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR STATE COUNTER NOT INCREMENTING FROM 02 TO 03 
CORRECTLY.  SYNCH YOUR SCOPE ON THE MINOR STATE DECODE "CNT4 DEX WD1 L"
(CNT4 B-5) AND CHECK THE 74193 COUNTER CHIP. (CNT4 B-6)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC22C:  MOV     #RFMAD3,CORECT  ;SET UP NEXT MINOR STATE FOR COMPARISON
        DIAGP9                  ;PULSE THE CLOCK DEXWD2 TO DEXWD3
        JSR     PC,RAMASK       ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                  ;ADRESS = 3?
        BEQ     SC22EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR STATE COUNTER INCREMENTING INCORRECTLY FROM 03 TO 04 DURING
DEX.  SYNCH YOUR SCOPE ON THE MINOR STATE DECODE "CNT4 DEX WD2 L" AND
CHECK THE 74193 UP COUNTER CHIP (CNT4 B-6).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC22EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ215


;********************************************************************
.REM    %
        SC3 IS SIMILAR TO SC1 EXCEPT THIS TIME, THE PROGRAM LOCKS THE
INTERFACE IN THE TO10 MAJOR STATE AND CHECKS THE RAM ADDRESSING.
%
;*******************************************************************

SC3:    JSR     PC,T10LOK        ;LOCK INTERFACE IN TO10 MAJOR STATE
        MOV     #T10TAB,R1      ;T10TAB IS A TABLE OF RAM ADDRESSES
        CLR     R2              ;WE'LL XFER COUNTS FROM R2 TO STATE CTR
        
SC3A:   CMP     R2,#14          ;IS R2 @ COUNT OF 14?
        BEQ     SC3B            ;YES-DON'T USE IT (CAUSES NPR)
        INC     R5              ;NEXTSUBTEST
        MOV     R2,@DIAG2       ;NO-LOAD ADDRESS
        JSR     PC,RAMASK        ;MASK OFF ALL BUT RAM ADDRESSES
        MOV     (R1)+,CORECT    ;GET NEXT ADDRESS FROM TABLE
        MCMP16                  ;ADDRESS SAME AS ON TABLE?
        BNE     SC3ER           ;NO-ERROR
SC3B:   ADD     #2,R2           ;OK-ADVANCE R2
        CMP     (R1),#-1                ;AT END OF T10TAB?
        BNE     SC3A            ;NO-DO IT AGAIN
        BR      SC3EX           ;YES-EXIT

SC3ER:  ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING CHECK OF STATE COUNT DURING TO10 XFER.  DIAG3
CONTAINS INCORRECT COUNT; ADDRESS POINTED TO BY R1+2 CONTAINS CORRECT
COUNT.  CHECK:

        1. 74193 BIN COUNTER (THIS IS THE FIRST CHECK OF BINARY COUNTS
           PAST 4(8)                    (CNT4 B-6)
        2. TO10 MINOR STATE DECODER     (CNT4 B-4)
        3. NEWTORK WHICH YIELDS CNT1 ADR0H-CNT1 ADR3H (CNT 1 A-6 THRU B-6)

        A SCOPE SYNCH FOR THIS PROBLEM IN INT1 MST CLRL  (INT1 D-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC3EX:  JMP     NORMAL

;SEQ216


;********************************************************************
;*T10TAB IS A TABLE OF RFM ADDRESSES AS SEEN BY DIAG3
;*DURING A TO10 TRANSFER.
;********************************************************************

T10TAB: 0       ;SUBTEST 1 - ADDRESS=0 (DELAY COUNT)  SC=0
        0       ;SUBTEST 2 - ADDRESS=0 (DELAY COUNT)  SC=1
        RFMAD1!RFMAD2   ;SUBTEST 3 - ADDRESS=6 (TO10 BYTE COUNT)  SC=2
        0       ;SUBTEST 4 - ADDRESS=0 (DELAY COUNT)  SC=3
        RFMAD1!RFMAD2   ;SUBTEST 5 - ADDRESS=6 (TO10 BYTE COUNT SC=4
        RFMAD0  ;SUBTEST 6 - ADDRESS=10 (TO10 11 ADDRESS)  SC=5
                ;SUBTEST 6 - ADDRESS=12 (TO10 DATA)          SC=6
        RFMAD0!RFMAD2   ;SUBTEST 7 - ADDRESS=12 (TO10 DATA)  SC=7
        RFMAD0  ;SUBTEST 8 - ADDRESS=10 (TO10 11 ADDRESS)  SC=1-
        -1      ;TABLE DELIMITER

;*******************************************************************
;*T10LOK WILL LOCK THE INTERFACE IN THE TO10 XFER MAJOR STATE
;******************************************************************

T10LOK: DIAGRS
T10LOC: DIAGMD
T10LKA: BIT     #TO10,@DIAG1    ;IN TO10 MODE?
        BNE     T10LKB          ;YES-EXIT
        DIAGPL                  ;NO-PULSE THE CLOCK
        BR      T10LKA          ;AND TRY AGAIN
T10LKB: MOV     #D1011!DS05,@DIAG1      ;SET STATE HOLD
        NOP                     ;       A LITTLEW TIME
        NOP                     ;       TO SET DIAG MODE
        RTS     PC              ;AND RETURN

;SEQ217


;******************************************************************
.REM    %
        SC4 IS SIMILAR TO SC2 EXCEPT THAT THIS TIME THE PROGRAM SINGLE
STEPS THROUGH A TO10 XFER.  THE ROUTINE BYPASSES A COUNT OF 6 (WHICH
CAUSES AN UNTESTED NPR REQUEST) AND INCREMENTS TO 10(8).
%
;**********************************************************(********

SC4:    JSR     PC,T10LOK       ;LOCK INTERFACE IN TO10 XFER
        MOV     #36,R2          ;START AT STATE COUNT OF ZERO
        MOV     #T10TAB,R1      ;R1 POINTS TO FIRST DECODE IN TABLE
SC4A:   CMP     R2,#12          ;COUNT=12?
        BEQ     SC4B            ;YES-DON'T TEST (CAUSES NPR)
        INC     R5              ;NEXT SUBTEST
        MOV     #EDONES,@DIAG2  ;NO-SET EBUS DONE
        MOV     R2,@DIAG2       ;AND LOAD STATE COUNT
        DIAGP9                  ;ADVANCE TO NEXT STATE COUNT
        JSR     PC,RAMASK       ;MASK OFF ALL BUT RAM ADDRESS BITS
        MOV     (R1)+,CORECT    ;SET CORRECT DATA REGISTER.
        MCMP16                  ;WORDS MATCH?
        BNE     SC4ER           ;N0-ERROR
SC4B:   ADD     #2,R2           ;R2 WILL KEEP TRACK OF WHERE WE ARE
        BIC     #^C<36>,R2      ;BLANK OUT ALL BUT STATE COUNT & STATE HOLD
        CMP     (R1),#-1        ;AT END OF T10TAB?
        BNE     SC4A            ;NO-INCREMENT AGAIN
        BR      SC4EX           ;YES-EXIT

SC4ER:  ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR STATE COUNTER INCREMENTING INCORRECTLY DURING TO10 XFER
CHECK THE 74193 BIN COUNT (CNT4 B-6).  A GOOD SCOPE SYNCH FOR THIS
PROBLEM IS THE ONE SIDE OF "CNT4 TO10 TRANS" FLOP @ CNT4 D-2.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC4EX:  JMP     NORMAL


;SEQ218


;******************************************************************
.REM    %
        SC5, LIKE SC1 AND SC3, LOCKS THE INTERFACE IN A MAJOR STATE
(THIS TIME TO11 XFER) AND APPLIES VARIOUS INPUT TO THE MINOR STATE
COUNTER, OBSERVING THE RAM ADDRESS BITS VIA DIAGNOSTIC WORD3.
%
;********************************************************************

SC5:    JSR     PC,T11LOK       ;LOCK INTERFACE IN TO11 STATE
        MOV     #T11TAB,R1      ;T11TAB IS A TABLE OF RAM ADDRESSES
        CLR     R2              ;R2 WILL GO TO DIAG2
SC5A:   CMP     R2,#16          ;R2=16?
        BEQ     SC5B            ;YES-DON'T USE IT (CAUSES NPR)
        INC     R5              ;NEXT SUBTEST
        MOV     R2,@DIAG2       ;NO-LOAD MINOR STATE COUNTER
        JSR     PC,RAMASK       ;MASK OFF ALL BUT REAM ADDRESS BITS
        MOV     (R1)+,CORECT    ;GET CORRECT ADDRESS FROM TABLE
        MCMP16                  ;ADDRESS SAME AS ON TABLE?
        BNE     SC5ER           ;NO-ERROR
SC5B:   ADD     #2,R2           ;ADVANCE TO NEXT COUNT
        CMP     (R1),#-1        ;AT END OF TABLE?
        BNE     SC5A            ;NO-TEST NEXT ADDRESS
        BR      SC5EX           ;YES-EXIT

SC5ER:  ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+_+-+-+-+-+-+
.REM    %
        FAILURE DURING CHECK OF STATE COUNT DURING TO11 XFER.  DIAG3
CONTAINS INCORRECT RAM ADDRESS:  ADDRESS POINTED TO BY (R1)-2 CONTAINS
CORRECT COUNT.  CHECK:

        1.  74193 BIN COUNTER (THIS IS THE FIRST CHECK OF
            BINARY COUNTS PAST 10(8)            (CNT4 B-6).
        2.  TO11 MINOR STATE DECODER            (CNT4 B-2).
        3. NETWORK WHICH YIELDS CNT1 ADROH-CNT1 ADR3H  (CNT1 A-6 THRU B-6).

        A SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF THE CNT4 TO11
TRANS FLOP (CNT4 D-3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+

SC5EX:  JMP     NORMAL

;SEQ219


;********************************************************************
;*T11LOK LOCKS THE 10/11 INTERFACE IN THE TO11 MAJOR STATE.
;********************************************************************

T11LOK: DIAGRS
T11LOC: DIAGMD
T11LKA: BIT     #TO11,@DIAG1    ;IN TO11 MAJOR STATE?
        BNE     T11KB           ;YES-LOCK UP AND EXIT
        DIAGPL                  ;NO-PULSE THE CLOCK
        BR      T11LKA          ;AND CHECK AGAIN
T11KB:  MOV     #D1011!DS05,@DIAG1      ;SET STATE HOLD
        NOP                     ;       A LITTLE TIME
        NOP                     ;       TO SET DIAG MODE
        RTS     PC              ;AND RETURN

;*********************************************************************
;*T11TAB IS A TABLE OF RFM ADDRESSES AS SEEN
;*BY DIAG3 DURING A TO11 XFER.
;**********************************************************************

T11TAB: 0                       ;SUBTEST 1 - ADDRESS=0 (DELAY COUNT) SC=0
        RFMAD3                  ;SUBTEST 2 - ADDRESS=1  (DEX WD1 - IRREVALANT)  SC=1
        RFMAD1!RFMAD2!RFMAD3    ;SUBTEST 3 - ADDRESS=7 (TO11 BYTE COUNT) SC=2
        RFMAD3          ;SUBTEST 4 - ADDRESS=1 (DEX WD1 -IRRELEVANT)SC=3
        RFMAD1!RFMAD2!RFMAD3    ;SUBTEST R - ADDRESS=7) (TO11 BYTE COUNT)SC=4

        RFMAD0!RFMAD3   ;SUBTEST 6 - ADDRESS=11 (TO11 11 ADDRESS)SC=5
        RFMAD0!RFMAD2!RFMAD3    ;SUBTEST 7 - ADDRESS=13 (TO11 DATA)SC=6
                        ;SUBTEST 7 - ADDRESS=13 (TO11 DATA)SC=7
        RFMAD3          ;SUBTEST 8 - ADDRESS=1 (DEX WD1 - IRRELEVANT)SC=10
        RFMAD0!RFMAD3   ;SUBTEST 9 - ADDRESS=11 (TO11 11 ADDRESS)SC=11
        -1              ;TABLE DELIMITER

;SEQ220


;**********************************************************************
.REM    %
        SC6 CHECK THE INCREMENTATION OF THE MINOR STATE COUNTER FROM
1O(8) TO11(8) DURING A TO11 XFER.
%
;*********************************************************************

SC6:    MOV     #RFMAD0!RFMAD3,CORECT   ;SET UP COMPARISON WORD
        JSR     PC,T11LOK               ;LOCK INTERFACE IN TO11 STATE
        MOV     #20,@DIAG2              ;PULSE THE CLOCK
        DIAGP9                          ;PULSE THE CLOCK
        JSR     PC,RAMASK               ;MASK OFF BUT RAM ADDRES BITS
        MCMP16                          ;ADDRESS=11?
        BNE     SC6ER                   ;NO-EROR
        BR      SC6EX                   ;YES-EXIT

SC6ER:  ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+
.REM    %
        MINOR STATE COUNTER WILL NOT INCREMENT FROM 10(8) TO 11(8).
CHECK COUNTER (CNT4 B-6).  A SCOPE SYNCH FOR THIS PROGLEM IS CNT4 GD
ST CLK H (CNT4 D-5).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SC6EX:  JMP     NORMAL

;SEQ221


.SBTTL  *OPERATION INITIATION TESTING

;*******************************************************************
.REM    %
        THE NEXT TWO TEST (OPR1 AND OPR2) TRY TO INITIATE DEX AND TO11
XFER OPERATIONS (THE INITIATION OF A TO10 XFER IS CHECKED LATER IN TEST
EBH1).
        OPR1 LOCKS THE INTERFACE IN 10/11 DIAGNOSTIC MODE, SINGLE
PULSES INTO THE DEX MAJOR STATE, LOADS DEX ADDRESS 2 (TO SET CNT5 DEX
START). PULSES THE CLOCK, AND CHECKS TO SEE THAT THE MAJOR STATE HAS
NOT ADVANCED.
%
;*******************************************************************

OPR1:   MOV     #DEX,CORECT     ;WE'LL TRY TO GET TO DEX
        DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
OPR1A:  BIT     #DEX,@DIAG1     ;IN DEX MAJOR STATE?
        BNE     OPR1B           ;YES-PROCEED?
        DIAGPL                  ;NO-STEP THE SLOCK
        BR      OPR1A           ;GO CHECK AGAIN

OPR1B:  CLR     @TENAD2         ;THIS SHOULD SET CNT5 DEX START
        DIAGPL                  ;PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET THE MAJOR STATE FLOPS
        MOV     #^C<DEX!TO10!TO11>,MASK  ;CLEAR ALL BUT MAJOR STATES
        MCMP16                  ;STILL IN DEX MAJOR STATE?
        BEQ     OPR1EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+
.REM    %
        INTERFACE NOT STAYING LOCKED IN DEX MAJOR STATE AFTER LOADING
DEX ADDRESS 2.  CHECK:

        1.CNT5 DEX START FLOP                           (CNT5 D-5)
        2. CNT4 DEX &DCRG DEX START INPUT TO CNT4 STATE HOLD FLOP
                                                        (CNT4 C-4)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF THE CNT3
DIAG 10/11 FLOP  (CNT3 B-7).
%

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

OPR1EX: JMP     NORMAL                  ;EXIT TO NEXT TEST

;SEQ222



;******************************************************************
.REM    %
        OPR2 IS SIMILAR TO OPR1 EXCEPT THIS TIME THE PROGRAM TRIES TO
INITIATE A TO11 TRANSFER.  THE ROUTINE PUTS THE INTERFACE IN THE TO11
XFER MAJOR STATE, LOADS THE TO11 ADDRESS AND BYTE COUNT (WHICH SHOULD
SET CNT5 TO11 RDY), PULSES THE CLOCK AND CHECKS TO SEE IF THE INTERFACE
REMAINS LOCKED IN THE TO11 MAJOR STATE.
%
;******************************************************************

OPR2:   MOV     #TO11,CORECT    ;WE'RE TRYING FOR TO11 THIS TIME
        DIAGRS                  ;DIAGNOSTIC RESET
        DIAGMD                  ;SET DIAGNOSTIC MODE
OPR2A:  BIT     #TO11,@DIAG1    ;INTERFACE IN TO11 MAJOR STATE?
        BNE     OPR2B           ;YES-CONTINUE
        DIAGPL                  ;NO-PULSE THE CLOCK
        BR      OPR2A           ;AND CHECK AGAIN

OPR2B:  CLR     @TO11BC         ;LOAD THE BYTE COUNT
        CLR     @TO11AD         ;AND THE ADDRESS (SHOULD SET TO11 RDY)
        DIAGPL                  ;PULSE THE CLOCK
        MOV     @DIAG1,ACTUAL   ;GET THE MAJOR STATE FLOPS
        MOV     #^C<TO11>,MASK  ;CLEAR ALL BUT TO11 MAJOR STATE
        MCMP16                  ;STILL IN TO11?
        BEQ     OPR2EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        INTERFACE NOT STAYING LOCKED IN TO11 MAJOR STATE AFTER LOADING
TO11 BYTE COUNT AND ADDRESS.  CHECK:

        1.  CNT5 TO11 BC LD             (CNT5 D-3)
        2.  CNT5 TO11 ADR LD            (CNT5 C-4)
        3. CNT5 TO11 RDY H              (CNT5 C-1)
        4.  CNT4 TO11 XFER & CNT5 TO11 RDY INPUT TO CNT4 STATE HOLD(CNT4                                         (C-3)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE CNT3 DIAG 10/11
FLOP (CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

OPR2EX: JMP     NORMAL          ;EXIT


;SEQ223



.SBTTL  *ABC REGISTER TESTING

;******************************************************************
.REM    %
        ABC1 CHECKS TO SEE IF THE ABC REGISTER CAN HOLD ZEROES.  THE
ROUTINE PROCEEDS AS FOLLOWS:

        1.  LOAD ONES INTO THE TO11 11 ADDRESS.
        2. LOAD ZEROES INTO THE DELAY COUNT.
        3.  LOCK THE INTERFACE IN THE TO11 XFER MAJOR STATE
        4.  SET MINOR STATE TO11 DLY RD.
        5.  PULSE THE CLOCK (XFER DELAY COUNT TO ABC REG)
        6.  SET MINOR STATE TO11 ADR INC
        7.  PULSE THE CLOCK (XFER ABC TO TO11 BYTE COUNT)
        8.  COMPARE TO11 11ADDRESS FOR ALL ZEROES.
%
;*****************************************************************



ABC1:   CLR     CORECT          ;WE'LL COMPARE FOR ZEROES
        DIAGRS                          ;DIAGNOSTIC RESET
        MOV     #-1,@TO11AD     ;ONES TO TO11 11 ADDRESS
        CLR     @DLYCNT         ;AND ZEROES TO DELAY COUNT
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 STATE
        MOV     #36,@DIAG2      ;SET MINOR STATE TO11 DLYCNT RD
ABC11:  DIAGP9                  ;PULSE THE CLOCK (XFERS DLY COUNT TO ABC                               ;REG
        MOV     #20,@DIAG2      ;SET MINOR STATE TO11 ADR INC
ABC12:  DIAGP9                  ;PULSE THE CLOCK (XFERS
                                ;ABC REG TO TO11 BYTE COUNT)
        CMP     @TO11AD,#0      ;DID THE ZEROES GET TO THE TO11 ADDRESS?
        BEQ     ABC1EX          ;YES-EXIT
        MOV     @TO11AD,ACTUAL  ;NO-CAPTURE WHAT WE DID GET
        CMP     #-2,ACTUAL      ;STILL ONES?
        BNE     AB1ER2          ;NO-MUST BE BIT PICKUP
AB1ER1: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        ABC REGISTER HOLDING ALL ONES WHEN ZEROES ARE EXPECTED.
EITHER THE REGISTER WAS NOT LOADED FROM THE DELAY COUNTER BY ABC11
ABOVE, OR IT DID NOT LOAD INTO THE BYTE COUNTER AT ABC12.  CHECK:

        1.  CNT1 ABC LOADL                      (CNT1 C-2)
        2.  CNT2 DPS4 SEL 2 & CNT2 DPSR SEL 1   (CNT2 B-2)

        A USABLE SCOPE SYNCH POINT FOR THIS PROBLEM IS
THE ONE SIDE OF THE CNT4 TO11 TRANS FLOP (CNT4 D-3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ224


        AB1ER2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO11 11 ADDRESS SHOULD CONTAIN ALL ZEROES FROM ABC REGISTER.  IF
A SINGLE BIT ISD A ONE.  CHECK:

        1.  CORRESPONDING ABC REGISTER BIT              (DPS1)
        2.  RAM INPUT MIXER FOR CORRESPONDING BIT       (DPS4)
        IF MORE THAN ONE BIT IS ON A ONE, CHECK:
        1.  CNT2 DPS4 SEL 2 & CNT2 DPS4 SEL 1   (CNT2 B-2).
        A USABLE SCOPE SYNCH POINT FOR THIS PROBLEM IS THE ONE SIDE OF
CNT4 TO11 TRANS (CNT4 D-3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ABC1EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ225


;******************************************************************

.REM    %
        ABC2 IS SIMILAR TO ABC1 EXCEPT THAT IT CHECKS TO SEE IF THE
ABC REGISTER CAN HOLD ONES.
%
;****************************************************************

ABC2:   DIAGRS                  ;DIAGNOSTIC
        MOV     #-1,CORECT      ;SET CORECT DATA REGISTER.
        CLR     @TO11AD         ;ZEROES TO TO11 11 ADDRESS
        MOV     #-1,@DLYCNT     ;ONES TO DELAY COUNT
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 STATE
        MOV     #36,@DIAG2      ;SET MINOR STATE "TO11 DLYCNT RD"
        DIAGP9                  ;PULSE THE CLOCK (XFERS DELAY
                                ;COUNT TO ABC REGISTER)
        MOV     #20,@DIAG2       ;SET MINOR STATE "TO11 ADR INC"
        DIAGP9                  ;PULSE THE CLOCK (XFERS ABC
                                ;REGISTER TO 1  ATO11 BYTE COUNT)
        MOV     @TO11AD,ACTUAL  ;TO11AD TO ACTUAL
        CMP     CORECT,ACTUAL   ;ONES GET THERE?
        BEQ     ABC2EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-=-+-+-+-+-+-=-=-+-=-+
.REM    %
        ABC REGISTER DROPPING ONES.  CHECK:

        1.  ABC REGISTER LOCATION CONTAINING 0  (DPS1)
        2. RAM INPUT MIXER FOR BIT CONTAINING ZERO      (DPS4)

        A SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF CNT4 TO11
TRANS (CNT4 D-3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+
ABC2EX: JMP     NORMAL          ;EXIT TO NEXT TEST


;SEQ226


;**********************************************************************
.REM    %
        ABC3 ACHECKS ABC REGISTER INCREMENTATION.  USING A DATA
PATTERN OF 00,01,03,07,17,ETC., THE PROGRAM LOADS THE ABC REGISTER.
AFTER  INCREMENTATION.  THE PROGRAM LOADS THE ABC REGISTER.  AFTER
INCREMENTATION.  THE PROGRAM READS THE INCREMENTED COUNT AND CHECKS FOR
OUTPUTS OF 01,02,04,10,20,ETC.
%
;**********************************************************************

ABC3:  DIAGRS                   ;DIAGNOSTIC RESET
        CLR     R0              ;WE'LL USE R0 AS OUR COUNT
ABC3A:  MOV     R0,CORECT       ;       AND COMPAR INCREMENTED
        INC     CORECT          ;       COUNT TO "CORECT"
        MOV     R0,@DLYCNT      ;WE'LL START COUNT IN DELAY COUNT
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 STATE
        MOV     #36,@DIAG2      ;SET MINOR STATE "TO11 DLY RD"
        DIAGP9                  ;TRANSFER COUNT TO ABC REGISTER
        MOV     #4,@DIAG2       ;SET MINOR STATE "TO11 BC INC"
        DIAGP9                  ;INCREMENT THE ABC REGISTER
        MOV     #20,@DIAG2      ;SET MINOR STATE "TO 11 ADR INC"
        DIAGP9                  ;XFER ABC REGISTER TO TO11 ADDRESS
        MOV     @TO11AD,ACTUAL  ;NOW GET THE DATA
        CMP     CORECT,ACTUAL   ;ABC INCREMENTED CORRECTLY?
        BNE     ABC3ER          ;NO-REPORT ERROR
        CMP     R0,#-1          ;YES-CHECKED ALL 16 BITS?
        BEQ     ABC3EX          ;YES-EXIT
        SEC                     ;NO-SET CARRY PRIOR TO ROTATE
        ROL     R0              ;ROTATE A ONE INTO R0
        BR      ABC3A           ;AND CHECK NEW PATTERN

ABC3ER: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+

.REM    %
        ABC REGISTER INCREMENTATION FAILURE.RO CONTAINS
CONTENTS OF ABC REGISTER BEFORE INCREMENTATIO: CORECT CONTAINS
WHAT IT SHOULD BE AFTER INCREMENTATION.  TO11 ADDRESS (RAM LOCATION
XXX22) HOLDS WHAT IT ACTUALLY CONTAINS.  IF NO INCREMENTATION
HAS OCCURED (R0=TO11) CHECK CNT1 ABC INC (CNT1 C-2).

IF ALL ZEROES APPEAR IN THE ABC REGISTER, CHECK CARRY INPUT TO ABC
REGISTER BIT CONTAINED IN R1.

IF MORE THAN ONE 1 BIT APPEARS IN TO11 ADDRESS, CHECK THE ABC REGISTER
POSITION CONTAINING THE RIGHTMOST ONE BIT.

        A SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF "CNT3
DIAG 10/11 " (CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+

ABC3EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ227


;*****************************************************************
.REM    %
        THE PREVIOUS TEST (ABC3) USED THE TO11 INPUT TO "CNT1 DLYINC"
TO INCREMENT THE ABC REGISTER.  ABC4 CHECKS THE TO1- INPUT TO CNT1 DLY INC.
%
;*****************************************************************

ABC4:   MOV     #1,CORECT               ;WE'LL LOOK FOR ALL ONES
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @DLYCNT         ;LOAD DELAY COUNT WITH ZEROES
        MOV     #-1,@TO10AD     ;A MINUS 1 IS A GOOD BACKGROUND
        JSR     PC,T10LOC       ;LOCK INTERFACE IN TO10 STATE
        MOV     #36,@DIAG2      ;SET "TO10 DLY RD" MINOR STATE
        DIAGP9                  ;XFER DELAY COUNT (ZEROES) TO ABC REG
        DIAGP9                  ;INCREMENT ABC REG TO 1
        MOV     #16,@DIAG2      ;SET "TO10 EB REQ" MINOR STATE
        DIAGP9                  ;XFER ABC REG. TO "TO10 ADDRESS"
        MOV     @TO10AD,ACTUAL  ;AND BRING THE DATA IN FOR COMPARISON
        CMP     CORECT,ACTUAL   ;INCREMENTED TO 01?
        BEQ     ABC4EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        "CNT4 TO10 DLY INC  L" INPUT TO CNT1 DLY INC L (CNT1 C-4)
WILL NOT ALLOW INCREMENTATION BUT "CNT4 TO11 DLYINC L" WORKS OK.        
        A SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF CNT3 DIAG
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ABC4EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ228


;**************************************************************
.REM    %
        ABC5 CHECKS THE "CNT4 TO11 ADR ADD" INPUT TO "CNT1 ABC INC".
THE PROGRAM LOADS THE TO11 11 ADDRESS LOCATION IN THE RAM WITH 01 (TO
SET TO11 WORD), INCREMENTS, AND CHECKS TO SEE IF THE 1 IS STILL THERE.
%
;********************************************************************
ABC5:   MOV     #1,CORECT       ;WE'LL COMPARE FOR THIS ONE
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #TO11BM,@TO11BC ;LOAD WITH BIT0 (SETS TO11 WORD)
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 STATE
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;XFER 01 TO ABC REG.
        MOV     #EDONES,@DIAG2  ;SET EB DONE
        NOP                     ;MAKE SURE YOU'VE GOT IT
        MOV     #16,@DIAG2      ;SET MINOR STATE "TO11 ADR ADD"
        DIAGP9                  ;INCREMENT ABC REG AND
                                ;ADVANCE TO "TO11 ADR INC" MINOR STATE
        DIAGP9                  ;XFER ABC REG TO TO11 11 ADDRESS
        MOV     @TO10AD,ACTUAL  ;CAPTURE THE WORD
        CMP     CORECT,ACTUAL   ;ADDRESS INCREMENTED TO 1?
        BEQ     ABC5EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        ABC REGISTER WILL NOT INCREMENT VIA "CNT1 TO11 ADR ADD H"
INPUT GATE TO "CNT4 ABC INC L"
(CNT4 C-2).  CHECK:

        1.  CNT5 TO11 BYTE MODE FLOP (SHOULD BE CLEAR)  (CNT5 B-7).
        2.  INPUT GATING TO CNT1 ABC INC L              (CNT1 C-1).

        A SCOPE SYNCH POINT FOR THIS PROBLEM IS CNT3 DIAG 10/11 FLOP
(CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-_=-=-+-+-+

ABC5EX: JMP     NORMAL          ;GET NEXT TREST

;SEQ229


;*********************************************************************
.REM    %
        ABC6 IS SIMILAR TO ABC5 BUT CHECKS THE "CNT4 TO10 EBUF FILL H"
INPUT TO "CNT1 ABC INCL".
%
;********************************************************************

ABC6:   MOV     #1,CORECT               ;WE'RE LOOKING FOR A SINGLE ONE
        DIAGRS                          ;DIAGNOSTIC RESET
        MOV     #TO10BM,@DIAG3          ;SET TO10 BYTE MODE
        JSR     PC,T10LOC               ;LOCK INTERFACE IN TO10 STATE
        MOV     #10,@DIAG2              ;SET MINOR STATE "TO10 ADR"
        DIAGP9                          ;XFER T10AD TO ABC REG
        MOV     #14,@DIAG2              ;SET MINOR STATE "TO10 E-BUF FILL"
        DIAGP9                          ;INCREMENT ABC REG AND
                                        ;ADVANCE TO MINOR STATE "T10EB REQ".
        DIAGP9                          ;TRANSFER ABC REG TO TO10 ADR.
        CMP     CORECT,ACTUAL           ;INCREMENTED TO 1?
        BEQ     ABC6EX                  ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+_+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        ABC REGISTER WILL NOT INCREMENT VIA "CNT4 TO 10 E-BUFF FILL H"
INPUT TO "CNT1 ABC INC L".  CHECK:

        1.THE ABOVE MENTIONED GATE.
        2. CNT5 TO10 BYTE MODE FLOP (SHOULD BE RESET)  (CNT5 R-2)

        A SCOPE SYNCH FOR THIS PROBLEM IS CNT3 DIAG 10/11 (1) H
(CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-=-+-+

ABC6EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ230


.SBTTL  *NPR TESTING

;*********************************************************************
.REM    %
        NPR'S, LIKE VECTORED INTERRUPTS, MUST BE HANDLED VERY
CAREFULLY.  AN NPR TRANSFER WITH AN ADDRESSING FAULT CAN CUMP DATA INTO
ALMOST ANYWHERE IN THE PROGRAM.
%
;*******************************************************************

NPR1:   TST     P1NPRF          ;PASS 1?
        BNE     1$              ;NO
        PMSG    <\ENTERING NPR TEST PASS 1 PC= >
        MOV     PC,R0
        PNTOCT
        PCRLF
1$:     DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,@TO11AD  ;NPR SHOULD TRANSFER DATA INTO NPRLOC
        MOV     #-1,@TO11DT     ;A WORD OF -1 WILL BE TRANSFERRED
        CLR     @NPRLOC         ;ZERO OUT CONTENTS OF TARGET ADDRESS

;********************************************************************
.REM    %
        IN ADDITION TO CLEARING NPRLOC, THE PROGRAM MUST ALSO SAVE
THE CONTENTS OF LOCATION 0 ON A TEMPORARY SRTACK IN CASE NO ADDRESS IS
DELIVERED TO THE UNIBUS ADDRESS LINES WHEN UBIC NPG BBSY SETS.
%
;*********************************************************************

        MOV     #HOLDAR,R3      ;USE R3 AS TEMPORARY STACK POINTER
        MOV     0,(R3)+         ;PUSH CONTENTS OF 0 ON STACK
        CLR     0               ;AND SET IT TO 0

;*********************************************************************
.REM    %
        IN ADDITION TO PROTECTING LOCATION 0. THE PROGRAM MUST ALSO
COMPLEMENT EACH BIT OF THE NPR DATA ADDRESS (NPRLOC) AND SAVE THE CONTENTS
OF THIS MODIFIED ADDRESS ON THE STACK TO GUARD AGAINST SINGLE
BIT FAILURE IN THE UMTR UNIBUS ADDRESS DRIVERS.
%
;*********************************************************************

        MOV     NPRLOC,R2       ;THE COMPAD ROUTINE LOOKS AT R2 FOR
                                ;THE UNMODIFIED ADDRESS
        MOV     #BIT1,R1        ;R1 IS THE BIT MASK FOR COMPAD
NPR1A:  JSR     PC,COMPAD       ;COMPLEMENTED ADDRESS WILL BE
                                ;RETURNED IN R0
        CMP     R0,#MAXADD      ;GREATER THAN MAXIMUM ADDRESS?
        BGT     NPR1AA          ;YES-DON'T TRY TO STORE IT
        MOV      (R0),(R3)+      ;NO-SAVE CONTENTS ON STACK
        CLR     (R0)            ;AND SET IT TO 0
NPR1AA:  CLC                     ;CLEAR CARRY BEFORE ROTATE
        ROL     R1              ;SLIDE BIT MASK LEFT
        BNE     NPR1A           ;STORE AGAIN IF MASK NOT EQUAL TO 0

;SEQ231


;********************************************************************
.REM    %
        HAVING SAVED THE CONTENTS OF THE "MOST LIKELY" FAILING NPR
ADDRESSES, THE PROGRAM MUST NOW ZERO OUT 4 BITS OF THE NPR ADDRESS
(SINCE THE ADDRESSING ONUMTR IS DONE ON A 4 WIDE BASIS) AND SAVE THE
CONTENTS OF THIS ADDRESS ON THE STACK.  THIS PROCESS IS REPEATED FOUR
TIMES FOR A FULL 16 BIT ADDRESS.
%
;*******************************************************************
        MOV     #17,R1          ;FOUR BITES TO R1
NPR1BB: MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        BIC     R1,R0   ;CLEAR FOUR BITS
        CMP     R0,NPRLOC       ;DID ADDRESS CHANGE?
        BEQ     NPR1BA          ;NO-DON'T BOTHER WITH IT
        MOV     (R0),(R3)+      ;STORE CONTENTS ON STACK
        CLR     (R0)            ;AND ZERO IT
NPR1BA: JSR      PC,R14LFT       ;SLIDE MASK 4 PLACES LEFT       
        TST     R1              ;ALL DONE?
        BNE     NPR1BB          ;DO IT AGAIN IF NON-ZERO

;SEQ232


;******************************************************************
.REM    %
        HAVING SVE THE MOST LIELY FAILING ADDRESS, THE PROGRAM MAY
NOW ATEMPT THE NPR.
%
;*****************************************************************

        JSR     PC,T11LOK               ;LOCK INTERFACE IN TO11 STATE
        CLR     @TO11BC         ;LOAD A BYTE COUNTE (NNEDED TO
                                ;SET CNT5 TO11 RDY)
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLOCK (XFER TO11 ADDRESS TO 
                                ;ABC REG)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     @STATUS,ACTUAL  ;GET THE STATUS REGISTER
        BIT     #TO11ER,ACTUAL  ;TIMEOUT OR BUS ERROR?
        BEQ     NPR1C           ;NO-CONTINUE CHECKING
NP1ERA: JSR     PC,NPR1EX       ;YES-CLEAN UP
        ERRMSG  <TO11 ERROR DURING NPR.  STATUS REG. = >
        MOV     ACTUAL,R0
        ERROCT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        NPR REQUEST TIMES OUT BEFORE COMPLETION AND CAUSE TO11 ERROR.
THIS IS APARTICULARLY UNPLEASANT PROBLEM.  TO BEGIN WITH CHECK:
        1.  STAT TO11 ERROR FLOP AND IT'S ASSOCIATED UNIBUS DRIVER
                                        (DPS5 C-6, DPS6 C-2)
        2.  CNT2 TO11 ERR SET L         (CNT2 D-1)
        3.  CNT8 BUSER                  (CNT8 C-3)
        4.  ETC.
        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF
THE CNT4 REQ FLOP (CNT4 D-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPROUT: JSR     PC,NPR1EX       ;CLEAN UP
        JMP     NORMAL          ;EXIT

NPR1C:  TST     @NPRLOC         ;NO BUS TIMEOUT - WERE THE ZEROES REPLACED?
        BNE     NPROUT          ;WHEW!-WE MADE IT

;SEQ233


;***********************************************************************
.REM    %
        KNOWING THAT NO BUS TIMEOUT OCCURED AND YET THE DATA WAS NOT
DELIVERED TO NPRLOC, WE COME TO THE REALIZATION THAT WE'VE GOT A WHOLE
WORLD OF HURTS.  THE PROBLEM IS TO FIND WHERE THE DATA WAS DELIVERED TO...
        WE'LL TRY LOCATION ZERO FIRST (BECAUSE IT'S EASIEST)
%
;********************************************************************

        MOV     NPRLOC,CORECT   ;ASSUME ADDRESSING PROBLEM
        TST     0               ;DOES 0 STILL CONTAIN ZERO?
        BEQ     NPR1D           ;YES-DAMN IT!!
NP1ERB: JSR     PC,NPR1EX       ;NO-CLEAN UP
        ERRMSG  <NPR TO LOCATION 0, CORRECT = >
        MOV     CORECT,R0
        ERROCT
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        NPR DELIVERED DATA TO LOCATION 0 RATHER THAN TO LOCATION
NPR LOC.  SYNCH SCOPE ON THE CNT4 REQ FLOP (CNT4 D-7) AND
CHECK "INT2 NPG BBSY (1) L" AND "UNIBUS DIS L" INPUT GATING TO
UNIBUS ADDRESS TRANSCEIVERS (DPS6 D-7)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-=-+-+-+
;SEQ234



;********************************************************************
.REM    %
        WITH NO BUS TIMEOUT AND NO DATA DELIVERED TO NPRLOC, EITHER AB
ADDRESSING PROBLEM DELIVERED THE DATA TO THE WRONG ADDRESS OR THE NPR
JUST DIDN'T OCCUR.  WE'LL HAVE TO CHECK THE ADDRESSING FIRST.

FIRST WE'LL CHECK CONTENTS OF NPRLOC MODIFIED BY CLEARING FOUR BITS OF
THE ADDRESS.
%
;*******************************************************************

NPR1D:  MOV     #17,R1          ;4 BIT MASK TO R1
        MOV     NPRLOC,CORECT   ;CORRECT ADDRESS FOR COMPARISON PRINTER
NPR1E:  MOV     NPRLOC,R0       ;CORRECT ADDRESS TO R0
        BIC     R1,R0           ;CLEAR FOUR BITS
        MOV     R0,ACTUAL       ;MODIFIED ADDRESS FOR COMPARIOSN PRINTER
        CMP     R1,NPRLOC       ;WAS ADDRESS CHANGED?
        BEQ     1$              ;NO-DON'T BOTHER CHECKING IT
        TST     (R0)            ;MODIFIED ADDRESS CONTAIN ZEROES?
        BNE     NP1ERC          ;NO-REPORT ERROR
        
1$:     JSR     PC,R14LFT       ;SHIFT BIT MASK 4 PLACES LEFT
        TST     R1      ;SHIFTED ALL BITS OUT?
        BNE     NPR1E           ;NO-CHECK AGAIN
        BR      NPR1G           ;YES-CONTINUE TESTING
        
NP1ERC: JSR     PC,NPR1EX       ;CLEAN UP
        ERR16   CORECT,ACTUAL,,<NPR TO "ACTUAL" RATHER THAN "CORRECT"\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        AN EASY PROBLEM.  CHECK UNIOBUS ADDRESS GATE WHICH DELIVERS THE
FOUR BITS OF THE ABC REGISTER CORRESPONDING TO THWE FOUR ONE BITS STORED
IN R1.  YOU MAY SYNCH YOUR SCOPE ON THE CNT4 REQ FLOP (CNT4 D-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ235


;********************************************************************
.REM    %
        CONTINUING OUR SEARCH FOR ADDRESSING ERRORS, THE NEXT
ROUTINE WILL LOOK FOR SINGLE BIT FAILURE IN THE UNIBUS
ADDRESS DRIVERS.
%
;*********************************************************************
.REM    %
        CONTINJUING OUR SEARCH  FOR ADDRESSING ERROR, THE
NEXT ROUTINE WILL LOOK FOR SINGLE BIT FAILURE IN THE UNIBUS
ADDRESS DRIVERS.
%
;*******************************************************************

NPR1G:  MOV     #2,R1           ;ONE BIT MASK TO R1
        
NPR1H:  MOV     NPRLOC,R2               ;LOAD R2 FOR COMPAD SUBROUTINE
        JSR     PC,COMPAD               ;COMPLEMENT ONE BIT OF ADDRESS
        CMP     R0,#MAXADD              ;DID WE BUILD AN ILLEGAL ADDRESS?
        BGT     NPR1I           ;YES-DON'T USE IT
        MOV     R0,ACTUAL       ;NO-SAVE IT FOR COMPARISON PRINTER
        TST     (R0)            ;LOCATION=0?
        BNE     NP1ERD          ;TO NP1ERD IF ANY ONES
        
NPR1I:  CLC                     ;CLEAR CARRY PRIOR TO ROTATE
        ROL     R1              ;SLIDE MASK LEFT
        BNE     NPR1H           ;AND CGHECK AGAIN IF NON-ZERO
        BR      NP1ERE          ;ALL DONE-YOU'VE GOT BIG TROUBLE BOY!!
NP1ERD: JSR     PC,NPR1EX       ;CLEAN UP
        ERR16   CORECT,ACTUAL,,<NPR TO "ACTUAL" RATHER THAN "CORRECT"\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        AN EASY PROBLEM.  UNIBUS ADDRESS FOR NPR INCORRECT
BY ONE BIT.  SYNCH YOUR SCOPE ON THE CLKS REQ FLOP (CLKS B2) AND
CHECK THE UNIBUS ADDRESS BIT (ON THE TOP OF THE UMTR PRINT) CORRESPONDING
TO THE BIT IN R1.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-=-=-+-+-+-+-+

;SEQ236


;********************************************************************
.REM    %
        IF WE GET THIS FAR, WE KNOW THAT THE NPR DID NOT
CAUSE A BUS TIMEOUT AND THERE IS NO SINGLE FAULT IN
THE UNIBUS ADDRESSING.  SINCE NOTHING WAS DELIVERED TO
THE TO11 ADDRESS, WE MUST PRESUME THAT THE NPR DID NOT
OCCUR.
///////////////////////////CAUTION////////////////////////////

        BEFORE YOU CONTINUE TO TROUBLE SHOOT HTIS
PROBLEM, ARE YOU ABSOLUTELY SURE THAT IT IS NOT
AN 11 PROCESSOR MALFUNCTION?  ARE YOU CERTAIN THAT
THE PDP11 KNOWS WHAT TO DO WITH NPR REQUESTS?  THINK
ABOUT IT...
///////////////////////////CAUTION///////////////////////////

%
;*******************************************************************
NP1ERE: ERRMSG  <NO BUS TIMEOUT BUT NPR DIDN'T DELIVER ANY DATA.  HMM!!\>
        FAULT

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        SYNCH YOUR SCOPE ON THE MINOR STATE DECODE "CLKS TO11 FILE RD"
(CNT4 B-2) AND CHECK:

        1.  CNT4 REQ FLOP               (CNT4 D-7)
        2.  INT2 NPG SYNCH FLOP         (INT2 D-4)
        3.  INT2 UN NPG IN L            (INT2 C-5)
        4.  INT2 NPG BBSY FLOP          (INT2 D-2)
        5.  INT2 NPG SACK FLOP          (INT2 D-3)
        6.  INT2 SEND MSYN FLOP         (INT2 A-1)

        IF SEND MSYN SET AND THE NPR DIED, A BUS TIMEOUT
WOULD HAVE OCCURRED (SEE INT1 TIMEOUT @ C-2)
WHICH WOULD HAVE BEEN DETECTED BY NP1ERA.  IF NOT 
SOMETHING RATHER PECULIAR IS GOING ON...
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-=-=-+-+-+-+-+-+-+-+

;SEQ237


;********************************************************************
.REM    %
        BEFORE EXITING, THE VARIOUS ADDRESSED MODIFIED BY THIS
TEST MUST BE RESTORED.
%
;****************************************************************

NPR1EX: MOV     #170000,R1      ;FOUR ONE BITS L.H SIDE OF R1
NPR1K:  MOV     NPRLOC,R0       ;BASE ADDRESS TO R0
        BIC     R1,R0           ;CLEAR FOUR ADDRESS BITS
        CMP     R0,NPRLOC       ;ADDRESS CHANGED?
        BEQ     NPR1KA          ;NO-DON'T BOTHER WITH IT
        MOV     -(R3),(R0)      ;RESTORE A LOCATION FROM THE STACK
NPR1KA: CLC                     ;CLEAR CARRY PRIOR TO ROTATING
        ROR     R1              ;       SHIFT
        CLC
        ROR     R1              ;       MASK
        CLC
        ROR     R1              ;       RIGHT
        CLC
        ROR     R1              ;       FOUR TIMES
        BNE     NPR1K           ;AND RESTORE AGAIN IF NOT ZERO

;*************************************************************
;*NEXT RESTORE THE INDIVIDUALLY BIT COMPLEMENTED ADDRESSES
;**************************************************************

        MOV     #BIT15,R1       ;BIT MASK IN L.H. SIDE OF R1
NPR1L:  MOV     NPRLOC,R2       ;CORRECT ADDRESS TO R2 FOR COMPAD
        JSR     PC,COMPAD       ;COMPLEMENT ONE ADDRESS BIT
        CMP     R0,#MAXADD     ;HAVE WE GENERATED ILLEGAL ADDRESS?
        BGT     NPR1M   ;YES-DON'T USE IT
        MOV     -(R3),(R0)      ;NO-RESTORE AN ADDRESS
NPR1M:  CLC                     ;CLEAR CARRY PRIOR TO ROTATE
        ROR     R1              ;SLIDE MASK RIGHT ONE BIT
        BNE     NPR1L           ;AND RESTORE AGAIN IF NON-ZERO

;*****************************************************************
;*FINALLY LOCATION ZERO MUST BE RESTORED
;*****************************************************************

        MOV     -(R3),0 ;WE'ERE DONE
        RTS     PC

;SEQ238



;********************************************************************
;*R14LFT ROTATES R1 FOUR PLACES LEFT
;********************************************************************
R14LFT: CLC
        ROL     R1
        CLC
        ROL     R1
        CLC
        ROL     R1
        CLC
ROL     R1
        RTS     PC

;********************************************************************
;*COMPAD COMPLEMENTS ONE BIT OF THE ADDRESS STORED IN
;*R2 WITH A BIT FROM R1 AND DELIVERS THE MODIFIED ADDRESS TO R0
;*********************************************************************

COMPAD: MOV     R2,R0   ;PUT THE ADDRESS IN R0
        BIS     R1,R0           ;TRY SETTING A BIT
        CMP     R2,R0           ;WAS THE BIT INITIALLY A ZERO?
        BNE     COMPEX          ;YES-EXIT
        BIC     R1,R0           ;NO-SO MAKE IT ONE NOW
COMPEX: RTS     PC

;SEQ239


;*******************************************************************
.REM    %
        NPR2 LOADS THE TO11 BYTE COUNT WITH MINUS 1 (WHICH SETS 
"CNT5 TO11 BC LD").  PERFORMS A MST CLEAR, LOADS THE TO11 11 ADDRESS.
PAUSES FOR A WHILE AND CHECKS TO SEE THAT THE TO11 ADDRESS IS NOT 
MODIFIED.  IF IT HAS BEEN INCREMENTED, IT MEANS THAT
THE NPR OCCURRED.  THIS IMPLIES THAT "CNT5 TO11 BCLD" WAS
NOT CLEARED BY MST CLR.
%
;*****************************************************************

NPR2:   MOV     NPRLOC,CORECT   ;SET CORRECT DATA REGISTER
        MOV     #7777,@TO11BC   ;LOAD BYTE COUNT (SET TO11 BCLD)
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,@TO11AD  ;LOAD TO11 11 ADDRESS
        NOP                     ;       KILL
        NOP                     ;       SOME
        NOP                     ;       TIME
        MOV     @TO11AD,ACTUAL  ;READ ACTUAL RESULTS
        CMP     CORECT,ACTUAL   ;DID ADDRESS GET MODIFIED?
        BEQ     NPR2EX          ;NO-EXIT
        ERR16   CORECT,ACTUAL,,<TO11 BC LOAD STUCK ON>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO11 XFER NPR OCCURRED AFTER PROGRAM ATTEMPTED TO
RESET CNT5 TO11 BC LD VIA MSI CLR.  CHECK:

        1.  CNT5 TO11 BC LD FLOP                (CNT5 B-7)
        2.  CNT1 TO11 DONE SET                  (CNT1 D-2)

        A SCOPEW SYNCH FOR THIS PROBLEM IS THE ONE SIDE F
THE CNT5 TO11 ADR LO FLOP (CNT5 C-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR2EX: JMP     NORMAL          ;TEST EXIT

;SEQ240



;***************************************************************
.REM    %
        NPR3 DOES ANOTHER NPR TRANSFER (AGAIN WITH A BYTE
COUNT OF MINUS 1) AND CHECKS THE TO11 ADDRESS TO DETERMINE IF IT
IS INCREMENTED DURING MINOR STATE "TO11 FILE READ".  SINCE
BIT 0 OF THE TO11 11 ADDRESS IS 1, THE EXTRA INCREMENT OF THE
ABC REGISTER AT MINOR STATE "TO11 ADR ADD" SHOULD NOT OCCUR.
%
;*************************************************************

NPR3:   MOV     NPRLOC,CORECT   ;SET CORRECT DATA REGISTER
        INC     CORECT          ;MAKE IT PLUS ONE
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TOR0
        ADD     #2,R0           ;MAKE IT PLUS 2
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 MAJOR STATE
        MOV     #TO11BM!7777,@TO11BC ;LOAD BYTE COUNT
        MOV     NPRLOC,@TO11AD  ;LOAD TO11 ADDRESS
        MOV     #10!EDONES,@DIAG2  ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLOCK (XFER TO11 ADDRESS TO ABC)
                                ;       (ALSO ADVANCE TO MINOR STATE
                                ;       "TO11 E-BUF STORE")
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLOCK (INCREMENT ABC REG)
                                ;       AND ADVANCE TO MINOR STATE
                                ;       "TO11 ADR ADD"
        MOV     #20,@DIAG2      ;FORCE MINOR STATE "TO11 ADR INC"
        DIAGP9                  ;       WRITE ABC REGISTER
                                ;       INTO "TO11 ADDRESS"
        MOV     @TO11AD,ACTUAL  ;SAVE RESULTS
        CMP     CORECT,ACTUAL   ;INCREMENT CORRECTLY
        BEQ     NPR3EX          ;I GUESS SO-EXIT
        BGT     NP3ER2          ;NO-EXTRA INCREMENT?
NP3ER1: ERR16   CORECT,ACTUAL,,<NO ABC INCREMENT\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=
.REM    %
        ABC REGISTER NOT INCREMENTING DURING MINOR STATE
"TO11 FILE READ" SYNCH SCOPE ON CNT5 TO11 ADR LD FLOP
(CNT5 C-4) AND CHECKCNT2 NPG BBSY INPUT TO CNT1 ABC INC (CNT1 C-2).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=_=-+-+-+

;SEQ241


NP3ER2: ERR16   CORECT,ACTUAL,,<EXTRA ABC INCREMENTATION\>

;*-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+
.REM    %
        ABC REGISTER BEING INCREMENTED MORE THAN ONCE
DURING SINGLE-BYTE TO11 NPR XFER.  SYNCH SCOPE ON CNT5
TO11 ADR LD FLOP (CNT5 C-3) AND CHECK:

        1.  "CNT4 TO11 ADR ADD" AND "CNT5 TO11 BYTE MODE (0) CNT1
            ABC INCL (SHOULDN'T PCCIR)          (CNT1 C-3)
        2.  "CNT1 BC INC L" INPUT TO CNT1 ABC INC L  (CNT1 C-2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+

NPR3EX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ242


;******************************************************************
.REM    %
        NPR3 DOES ANOTHER SINGLE-BYTE TO11 TRANSFER.  THE PROGRAM 
CLEARS THE NPR TARGET ADDRESS, LOADS THE TO11 DATA WORD WITH SIXTEEN
ONES (-1) AND STEPS THROUGH A TO11 XFER.  AT THE COMPLETION OF THIS
OPERATION, THE DATA IN THE NPR TARGET ADDRESS IS COMPARED TO A WORD OF
377 (8) (EIGHT ZEROES AND EIGHT ONES).
%
;******************************************************************

NPR3A:  MOV     #377,CORECT     ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        CLR     (R0)            ;ZERO IT OUT
        MOV     #-1,@TO11DT     ;ALL ONES FOR DATA
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 XFER MAJOR STATE
        MOV     #TO11BM!7777,@TO11BC ;LOAD BYTE COUNT AND BYTE MODE
        MOV     R0,@TO11AD      ;AND TO11 ADDRESS
        MOV     #10!EDONES, @DIAG2 ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLK (XFER TO11 ADDR. TO ABC)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLK (INITIATE NPR)
        MOV     @NPRLOC,ACTUAL  ;GET THE DATA DELIVERED BY NPR

        CMP     CORECT,ACTUAL   ;DID THE 377 GET THERE?
        BEQ     NPR3AX          ;LOOKS OK-EXIT
        CMP     #-1,ACTUAL      ;NO-IS IT ALL ONES
        BNE     NPR3A2          ;N0-SIMPLE COMPARISON ERROR
NPR3A1: ERR16   CORECT,ACTUAL,,<BYTE TRANSFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        SINGLE BYTE (8 BIT) TO11 XFER DELIVERING 16 BITS TO 11 MEMORY.
SYNCH YOUR SCOPE ON CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK:

        1.  CNT5 TO11 BYTE MOD FLOP     (CNT5 B-7)
        2.  UNIBUS CO L                 (INT1 C-6)

%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR3A2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        DATA COMPARISON ERROR DURING TO11 BYTE XFER.  PROGRAM SHOUD
HAVE TRANSFERRED 000377 TOP 11 MEMORY BUT DIDN'T.  SYNCH YOUR SCOPE ON
CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK THE RAM TO UNIBUS DATA PATH.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-=-=-+-+-+-+-+-+-+-+-+

NPR3AX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ243



;**************************************************************
.REM    %
        NPR3B IS SIMILAR TO NPR3A.  THIS TIME THE ROUTIONE DOES A FULL
WORD TRANSFER AND CHECK THAT TWO EIGHT BIT BYTES ARE DELIVERED
TO THE PDP11.
%
;*****************************************************************
NPR3B:  MOV       #-1,CORECT      ;SET CORRECT DATA REGISTER
        DIAGRS          ;DIAGNOSTIC RESET
        CLR     @NPRLOC ;ZERO OUT TARGET ADDRESS
        MOV     #-1,@TO11DT     ;LOAD ALL ONES
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 MAJOR STATE

        MOV     #7777,@TO11BC   ;TRANSFER ONE WORD
        MOV     NPRLOC,@TO11AD  ;LOAD ADDRESS
        MOV     #10!EDONES,@DIAG2 ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLK (XFER ADR, TO ABC)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLK (INITIATE NPR)
        MOV     @NPRLOC,ACTUAL  ;GET THE DATA DELIVERED BY NPR
        CMP     CORECT,ACTUAL   ;DID THE ONES GET THERE?
        BEQ     NPR3BX          ;YES-EXIT
        CMP     #377,ACTUAL     ;NO-IS IT A SINGLE BYTE OF ONES?
        BEQ     NP3ER3               ;IF SO REPORT
        CMP     #177400,ACTUAL  ;MAYBE ITS THE OTHER BYTE
        BEQ     NP3ER4          ;IF SO REPORT
        BR      NP3ER5          ;NOT A BYTE PROBLEM
NP3ER3: ERR16   CORECT,ACTUAL,,<TO11 WORD XFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-=-=-=-+
.REM    %
        FULL WORD TO11 TRANSFER DELIVERING ONLY RIGHT HAND 
8 BITS TO 11 MEMORY.  SYNCH YOUR SCOPE ON CNT3 DIAG10/11 (CNT3 B-7)
AND CHECK:
        1.  CNTT TO11 BYTE MODE FLOP            (CNT5 B-7)
        2.  UNIBUS CO L                                 (INT1 C-6)
%
;*-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NP3ER4: ERR16   CORECT,ACTUAL,,<TO11 WORD XFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FULL WORD TO11 XFER DELIVERING ONLY LEFT HAND 8 BITS TO 11
MEMORY.  SEE PREVIOUS ERROR CALL OUT FOR SCOPE SYNCH AND POSSIBLE 
FAULTS.
%
;*-0+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+-+-+-=-=-=-+-=-+-+-+-+

;SEQ244


;*HERE ON SIMPLE DATA COMPARISON ERROR

NP3ER5:        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+
.REM    %
        DATA COMPARISON ERROR DURING TO11 WORD XFER.  PROGRAM SHOULD HAVE
TRANSFERRED MINUS 1 TO 11 MEMORY BUT DIDN'T.  SYNCH YOUR SCOPE ON CNT3
DIAG 10/11 (CNT3 B-7) AND CHECK THE RAM TO UNIBUS DATA PATH.
%

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+

NPR3BX: JMP     NORMAL          ;EXIT TO DISPATCHER

;SEQ245


;*******************************************************************
.REM    %
        NPR3C TRIES TRANSFERRING ZEROES DURING A TO11 BYTE XFER.  THE
ROUTINE IS THE SAME AS NPR3A EXCEPT THAT A BYTE OF EIGHT ZEROES IS CUMPED
ON TOP OF A BACKGROUND OF ONES (RATHER THAN ONES DUMPED ON TOP OF
ZEROES)..
%
;*******************************************************************

NPR3C:  MOV     #177400,CORECT  ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        MOV     #-1,(R0)        ;BACKGROUND OF ALL ONES
        CLR     @TO11DT         ;ALL ZEROES FOR DATA
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 XFER MAJOR STATE
        MOV     #TO11BM!7777,@TO11BC  ;LOAD BYTE COUNT AND BYTE MODE
        MOV     R0,@TO11AD      ;AND TO11 ADDRESS
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLK (XFER TO11 ADDR. TO ABC)
        MOV     #14,@DIAG2       ;SET MINOR STATE "TO11 FILE READ"



        DIAGP9                  ;PULSE THE CLK (INITIATE NPR)
        MOV     @NPRLOC,ACTUAL  ;GET THE DATA DELIVERED BY NPR
        CMP     CORECT,ACTUAL   ;DID THE ZEROES GET THERE?
        BEQ     NPR3CX          ;LOOKS OK-EXIT
        CMP     #0,ACTUAL       ;NO-IS IT ALL ZEROES
        BNE     NPR3C2          ;NO-SIMPLE COMPARISON ERROR
NPR3C1: ERR16   CORECT,ACTUAL,,<BYTE TRANSFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+
.REM    %
        SINGLE BYTE (8 BIT) TO11 XFER DELIVERING 16 BITS TO 11 MEMORY
SYNCH YOUR SCOPE ON CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK:


        1.  CNT5 TO11 BYTE MODE FLOP    (CNT5 B-7)
        2.  UNIBUS CO L                 (INT1 C-6)
%
;*-+-+-=-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR3C2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+
.REM    %
        DATA COMPARISON ERROR DURING TO11 BYTE XFER.  PROGRAM SHOULD HAVE
TRANSFERRED 177400 TO 11 MEMORY BUT DIDN'T.  SYNCH YOUR SCOPE ON CNT3
DIAG 10/11 (CNT3 B-7) AND CHECK THE RAM TO UNIBUS DATA PATH.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-+-+-+-+-+-=-=-=-=-=-=-+-+-+-+-+

NPR3CX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ246


;********************************************************************
.REM    %
        NPR3ED IS THE FIRST TEST OF THE BYTE SWAP LOGIC DURING THE TO11
BYTE TRANSFER.  IT CLEARS THE NPR TARGET ADDRESS, LOADS THE TO11 DATA
WORD WITH ALL ONES, SETS BYTE MODE, AND INITIATES THE XFER TO AN ODD
ADDRESS.  WHEN ALL OF THIS IS DONE IT EXPECTS TO FIND A 177400 IN THE
NPR LOCATION.
%
;********************************************************************

NPR3D:  MOV     #177400,CORECT  ;SET CORTRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        CLR     (R0)            ;BACKGROUND OF ALL ZEROES
        INC     R0              ;MAKE NPR ADDRESS ODD
        MOV     #-1,@TO11DT     ;ALL ONES FOR DATA
        JSR     PC,T11LOC               ;LOCK INTERFACE IN TO11 XFER MAJOR            
                                ;STATE
        MOV     #TO11BM!7777,@TO11BC ;LOAD BYTE COUNT AND BYTE MODE
        MOV     R0,@TO11AD      ;AND TC11 ADDRESS
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLK (XFER TO11 ADDR. TO ABC)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLK (INITIATE NPR)
        MOV     @NPRLOC,ACTUAL  ;GET THE DATA DELIVERED BY NPR
        CMP     CORECT,ACTUAL   ;DID THE ONES GET THERE?
        BEQ     NPR3DX          ;LOOKS OR-EXIT
        CMP     #-1,ACTUAL      ;NO-IS IT ALL ONES
        BNE     NPR3D2          ;NO-SIMPLE COMPARISON ERROR
NPR3D1: ERR16   CORECT,ACTUAL,,<BYTE TRANSFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-=-+-=-+-+-+-+-+-+
.REM    %
        SINGLE BYTE (8 BIT) TO11 XFER DELIVERING 16 BITS TO 11 MEMORY.
SYNCH YOUR SCOPE ON CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK:

        1.  CNT5 TO11 BYTE MODE FLOP    (CNT5 B-7)
        2.  UNIBUS CO L         (INT1 C-6)
%

;*-+-+-+_+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-=-=-=-+-=-+-+-+-+

NPR3D2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        DATA COMPARISON ERROR DURING TO11 BYTE XFER.  PROGRAM SHOULD HAVE
TRANSFERRED 177400 TO 11 MEMORY BUT DIDN'T.  SYNCH YOUR SCOPE ON CNT3
DIAG 10/11 (CNT3 B-7) AND CHECK THE RAM TO UNIBUS DATA PATH.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR3DX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ247



;*******************************************************************
.REM    %
        NPR3E IS THE LAST OF THE TO11 BYTE MODE TESTS.  IT IS THE
EFFECTIVE COMPLEMENT OF TEST NPR3D.  IT TRIES TO DELIVER EIGHT ZEROES TO
THE LEFT HAND SIDE OF AN NPR LOCATION BY INITIATING A BYTE TRANSFER
WITH AN ODD ADDRESS.
%
;*******************************************************************

NPR3E:  MOV     #377,CORECT     ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        MOV     #-1,(R0)        ;BACKGROUND OF ALL ONES
        INC     R0              ;MAKE NPR ADDRESS ODD
        CLR     @TO11DT         ;ALL ZEROES FOR DATA
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 XFER MAJOR STATE
        MOV     #TO11BM!7777,@TO11BC ;LOAD BYTE COUNT AND BYTE MODE
        MOV     R0,@TO11AD      ;AND TO11 ADDRESS
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLK (XFER TO11 ADDR. TO ABC)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLK (INITIATE NPR)
        MOV     @NPRLOC,ACTUAL  ;GET THE DATA DELIVERED BY NPR
        CMP     CORECT,ACTUAL   ;DID THE ZEROES GET THERE?
        BEQ     NP3EX           ;LOOKS OK-EXIT
        CMP     #0,ACTUAL       ;NO-IS IT ALL ZEROES
        BNE     NPR3E2    ;NO-SIMPLE COMPARISON
NPR3E1: ERR16   CORECT,ACTUAL,,<BYTE TRANSFER FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        SINGLE BYTE (8 BIT) TO11 XFER DELIVERING 16 BITS TO 11 MEMORY.
SYNCH YOUR SCOPE ON CNT3 DIAG 10/11 (CNT3 B-7) AND CHECK:

        1.  CNT5 TO11 BYTE MODE FLOP            (CNT5 B-7)
        2.  UNIBUS CO L                         (INT1 C-6)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-=-+-+-=-+-+-+-+-+-+-+

NPR3E2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+_+-+-=-+-=-=-=-=-=-+-=-+-+-+-+
.REM    %
        DATA COMPARISON ERROR DURING TO11 BYTE XFER.  PROGRAM SHOULD HAVE
TRANSFERRED 377 TO 11 MEMORY BUT DIDN'T.  SYNCH YOUR SCOPE ION CNT3
DIAG 10/11 (CNT3 B-7) AND CHECK THE RAM TO UNIBUS DATA PATH.
%
;*-+-=-+-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-=-+-+-+-+-=-+-+

NP3EX:  JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ248

;***********************************************************************
.REM    %
        NPR4 LOADS A BYTE COUNT OF 00, PERFORMS A ONE BYTE
TO11 XFER AND CHECKS THE TO11 DONE FLAG.
%
;**********************************************************************

NPR4:   MOV     #TO11DN,CORECT  ;SET COMPARISON BIT
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TO11BC         ;LOAD BYTE COUNT
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,@TO11AD  ;LOAD THE ADDRESS
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 XFER
        CLR     @TO11BC         ;SET "TO11 BY LD"
        CLR     @DIAG2          ;START AT MINOR STATE "TO11 DLY RD"
        CLR     @DIAG1          ;TURN CLOCK BACK ON
NPR4A:  BIT     #TO11,@DIAG1    ;STILL IN TO11 XFER STATE?
        BNE     NPR4A           ;YES-WAIT UNTIL WE LEAVE
        
NPR4B:  BIT     #TO11,@DIAG1    ;       NOW WAIT FOR IT
        BEQ     NPR4B           ;       TO SET AGAIN
        NOP                             ;KILL A LITTLE TIME
        MOV     @STATUS,ACTUAL  ;NOW CAPTURE STATUS
        BIT     #TO11DN,ACTUAL  ;DID IT MAKE IT?
        BNE     NPR4EX          ;YES-EXIT
        MOV     #177577,MASK    ;SET UP FOR COMPARISON MASK
        ERR16   CORECT,ACTUAL,MASK,<CAN'T SET TO11 DONE-ACTUAL = STATUS\>

;*-+-+-+-+-+-+-+-=-+-+-+-+-+-=-+-+-=-+-+-+-=-+-=-+-+-=-=-=-=-+-=-+-+
.REM    %
        DPS5 TO11 DONE FLOP NOT SETTING WITH BYTE COUNT OF
00, BUT CAN BE SET DIRECTLY VIA UNIBUS BIT 07, SWITCH
SYNCH SCOPE ON MINOR STATE DECODE CNT4 TO11 BC RD (CNT4 B-2). AND CHECK
"CNT1 TO11 DONE SET L" (CNT1 D-2).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=

NPR4EX: JMP     NORMAL          ;YES-EXIT


;SEQ249


;******************************************************************
.REM    %
        NPR5 CHECKS THE TO11 NULL STOP LOGIC.  THE ROUTINE:

        1.  LOADS A TO11 BYTE COUNT WITH THE NULL STOP BIT TRUE
        2.  LOADS A WORD OF ALL ZEROES INTO THE TO11 DATA WORD
        3.  STARTS AN NPR TRANSFER AT MINOR STATE "TO11 FILE READ"
        4.  WAITS FOR TO11 DONE
        5.  CHECKS FOR "DPS5 NULL STOP"
%
;******************************************************************

NPR5:   MOV     #NULSTP,CORECT  ;WE'COMPARE FOR NULL STOP BIT
        JSR     PC,T11LOK       ;LOCK INTERFACE IN TO11 MAJOR STATE
        MOV     #ZSTOP!37777,@TO11BC  ;SET NULL STOP BIT
        CLR     @TO11DT         ;DATA WORD =0
        MOV     NPRLOC,@TO11AD  ;LOAD NPR ADDRESS
        MOV     #10!EDONES,@DIAG2       ;SET MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLOCK (XFER TO11 ADDRESS TO ABC)
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO11 FILE READ"
        DIAGP9                  ;PULSE THE CLOCK (ALLOW NPR)
        MOV     @STATUS,ACTUAL  ;SEE IF IT SET
        MOV     #^C<NULSTP>,MASK        ;CLEAR ALL BUT NULL STOP
        MCMP16                  ;DID NULL STOP SET?
        BEQ     NPR5EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-=-=-=-+-+-+-+-+-+-+-+-+
.REM    %
        DPS5 NULL STOP FLOP NOT SETTING WITH NULL DATA
DURING TO11 XFER.  CHECK:

        1.  CNT5 TO11 NULL STOP FLOP            (CNT5 C-7)
        2.  CNT1 TO11 NULL SETL                 (CNT1 D-2)
        3.  DPS5 NULL STOP FLOP                 (DPS5 D-4)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS CNT4 TO11 FILE READ
(CNT4 B-2) WHICH COMES UP AS THE TO11 BYTE COUNT IS LOADED.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-=-+-+-+-+

NPR5EX: DIAGRS                  ;DIAGNOSTIC RESET
        JMP     NORMAL          ;EXIT

;SEQ250


;*******************************************************************
.REM    %
        NPR6 IS THE FIRST TEST OF THE TO10 NPR.  NEW
LOGIC CHECKED IS PRIMARILY IN THE AREA OF SETTING
OF THE CNT4 REQ FLOP VIA MINOR STATE CNT4 TO10 FL WR.
%
;*******************************************************************

NPR6:   MOV     #-1,CORECT       ;WE'LL XFER A -1
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #-1,@NPRLOC     ;-1 TO NPRLOC IN PDP11 MEMORY
        CLR     @TO10DT         ;CLEAR RAM DATA WORD
        MOV     NPRLOC,@TO10AD  ;XFER DATA FROM NPRLOC
        JSR     PC,T10LOC       ;LOCK INTERFACE IN TO10 MAJOR STATE
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO10 ADR RD"
        DIAGP9                  ;LOAD TO10 AD INTO ABC & ADVANCE
                                ;TO MINOR STATE "TO10 FILE WRITE"
        DIAGP9                  ;INITIATE NPR
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     @TO10DT,ACTUAL  ;GET THE DATA WORD
        CMP     CORECT,ACTUAL   ;-1 GET THERE?
        BEQ     NPR6EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO10 XFER NPR NOT DELIVERING DATA WORD FROM
PDP11 MEMORY TO RAM LOCATION "TO10 DATA", BUT TO11
XFER NPR WORKS.  SYNCH SCOPE ON MINOR STATE "CNT4 TO10
ADR RD L" (CNT4 B-3) AND CHECK SET OF "CNT4 REQ" FLOP
(CNT4 D-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR6EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ251


;******************************************************************
.REM    %
        NPR7 CHECKS ABC REGISTER INCREMENTATION DURING
MINOR STATE "TO10 E-BUF FILL" AND DURING "TO10 FILE WE".
%
;****************************************************************

NPR7:   DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,CORECT           ;NPR ADDRESS TO CORECT
        ADD     #1,CORECT       ;MAKE CORECT = NPRLOC+2
        MOV     NPRLOC,@TO10AD  ;SEND IT OUT
        JSR     PC,T10LOC       ;LOCK INTERFACE IN 1010 XFER
        MOV     #10,@DIAG2      ;SET MINOR STATE "TO10 ADR RD"
        DIAGP9                  ;XFER TO10 ADDRESS-> ABC
        MOV     #EDONES,@DIAG2  ;FORCE E BUS DONE
        NOP                     ;MAKE SURE IT GETS THERE
        MOV     #14,@DIAG2      ;SET MINOR STATE "TO10 E-BUFF FILL"
        DIAGP9                  ;CINREMENT ABC REG AND
                                ;ADVANCE TO MINOR STATE
                                ;"TO10 E-B REQ"
        DIAGP9                  ;STORE ABC REG IN TO10 ADDRESS
        MOV     @TO10AD,ACTUAL  ;GET ABC REG.
        CMP     CORECT,ACTUAL   ;INCREMENTED CORRECTLY
        BEQ     NPR7EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        ABC REGISTER NOT INCREMENTING DURING MINOR STATE
"TO10 E-BUF FILL".  CHECK:

        1.  CNT5 TO10 BYTE MODE FLOP    (CNT5 C-2)
        2.  INPUT TO CNT1 ABC INC L     (CNT1 C-1)

        A SCOPE SYNCH FOR THIS PROBLEM IS THE MINOR
STATE DECODE "CNT4 TO10 BUF FILL L" (CNT4 C-4)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

NPR7EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ252


;


;********************************************************************
.REM    %
        NPR8 TESTS THE BUS TIMEOUT LOGIC.  THE ROUTINE STARTS AN NPR TO
A NON-EXISTANT 11 ADDRESS AND EXPECTS THE NOMINAL 50 MICROSECOND BUS
TIMEOUT DELAY TO COMPLETE THE UNIBUS CYCLE AND SET STAT TO11 ERROR.
%
;*****************************************************************

NPR8:   TST     P1NPRF          ;PASS 1?
        BNE     1$              ;NO!
        PMSG    <\TESTING >
        PMSG    <BUS >          ;THE PROGRAM IS ATTEMPTING AN NPR TO A NON-EXISTANT
        PMSG    <TIMEOUT >      ;ADDRESS. IF THE BUS TIMEOUT LOGIC AND ITS
        PMSG    <LOGIC \>       ;ASSOCIATED ONE-SHOT FAIL THE PROCESSOR WILL HANG.
1$:     MOV     #TO11ER,CORECT
        MOV     #40000,@DLYCNT   ;????
        JSR     PC,T11LOK       ;LOCK INTERFACE IN TO11 STATE
        MOV     #MAXADD,R0      ;GET MAXIMUM MEMORY ADDRESS
        ADD     #10,R0  ;RO SHOULD CONTAIN A NON-EXISTANT ADDRESS
        MOV     R0,@TO11AD      ;LOAD NPR ADDRESS
        MOV     #10!EDONES,@DIAG2       ;FORCE MINOR STATE "TO11 SHIFT"
        DIAGP9                  ;PULSE THE CLOCK (XFER TO11 ADDRESS TO ABC
        MOV     #14,@DIAG2      ;FORCE MINOR STATE "TO11 FILE READ"
        DIAGP9          ;PULSE THE CLOCK (INITIATE NPR)
        MOV     @STATUS,ACTUAL  ;CAPTURE THE STATUS REG.
        MOV     #^C<TO11ER>,MASK        ;CLEAR ALL BUT THER ERROR BIT
        MCMP16          ;IF WE GET THIS FAR, WE DIDN'T HANG
                        ;(FANTASTIC DEDUCTION - WOW!!!)
        BEQ     NPR8EX  ;EXIT IF TO11 ERROR SET
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++
.REM    %
        NPR TO NON-EXISTANT ADDRESS TIMEOUG OUT SUCCESSFULLY, BUT DID NOT
SET "DPS5 TO11 EROR".  SYNCH YOUR SCOPE ON "UBIC TIMEOUT" AND
CHECK:

        1.CNT8 BUS ERR H                (CNT8 C-3)
        2.  CNT2 TO11 ERR SET L         (CNT2 D-1)
        3.  DPS5 11 TO11 ERROR FLOP             (DPS5 C-6)
%
;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+


NPR8EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ253


;********************************************************************
.REM    %
        NPR9 IS SIMILAR TO NPR8 EXCEPT IT DOES A TO10 PR FROM A 
NON-EXISTANT 11 ADDRESS AND EXPECTS THE TO10 ERROR STATUS FLOP TO SET.
%
;********************************************************************

NPR9:   MOV     #TO10ER,CORECT  ;SET THE BIT FOR COMPARISON
        MOV     #40000,@DLYCNT  ;????
        JSR     PC,T10LOK       ;LOCK INTER FACE IN TO10 STATE
        MOV     #MAXADD,R0      ;MAXIMUM MEMORY ADDRESS TO R0
        ADD     #10,R0          ;R0 SHOULD CONTAIN A NON-=EXISTANT ADDRESS
        MOV     R0,@TO10AD      ;LOAD NPR ADDRESS
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO10 ADR READ"
        DIAGP9                  ;PULSE THE CLOCK
                                ;       LOAD TO10 AD INTO ABC REG &
                                ;       ADVANCE TO MINOR STATE "TO10 FILE                 
                                ;WRITE"
        DIAGP9                  ;PULSE THE CLOCK INIT NPR
        MOV     @STATUS,ACTUAL  ;CAPTURE STATUS REG.
        MOV     #^C<TO10ER>,MASK        ;CLEAR ALL BUT ERROR BIT
        MCMP16                  ;DID TO10 ERROR SET?
        BEQ     NPR9EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL,MASK

;*******************************************************************
.REM    %
        DPS5 11 TO10 ERR TERM NOT SETTING WHILE DOING A TO10 TRANSFER
FROM A NON-EXISTANT 11 ADDRESS.  SYNCH YOUR SCOPE ON "INT1 TIMEOUT"
(INT1 C-1) AND CHECK:

        1.  CNT2 TO10 ERR SET L         (CNT2 D-1)
        2.  DPS5 11 TO10 ERROR FLOP     (DPS5 C-7)
%
;*******************************************************************

NPR9EX: CLR     @DLYCNT
        TST     P1NPRF  ;PASS 1?
        BNE     1$              ;NO
        PMSG    <\EXIT FROM NPR TESTING PASS 1\>
        INC     P1NPRF
1$:     JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ254


.SBTTL  *MISCELLANEOUS TESTING OF TO10 XFER

;*******************************************************************
.REM    %
        T10B CHECKS THE BYTE SWAP LOGIC.  IT LOADS THE TO10 ADDRESS
WITH AN ODD ADDRESS (BIT00=1) AND FORCES A TO10 E B REQ CYC.  IT
THEN CHECKS THE TO10 DATA WORD FOR A SWAP.
%
;******************************************************************

T10B:MOV        #377,CORECT     ;WE'LL COMPARE FOR THIS BYTE
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TO10DT              ;CLEAR DATA WORD
        MOV     #177400,@NPRLOC ;WE'LL TRANSFER 8 ZEROES AND 8 ONES
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        MOV     #TO10BM,@DIAG3  ;SET BYTE MODE
        JSR     PC,T10LOC       ;LOCK INTERFACE INTO TO10 XFER
        INC     R0              ;MAKE AN ODD BYTE ADDRESS
        MOV     R0,@TO10AD      ;LOAD TO10 ADDRESS WITH ODD ADDRESS
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO10 ADR"
        DIAGP9                  ;PULSE THE CLOCK (TO10 ADR TO ABC REG)
                                ;       (ALSO SET MINOR STATE
                                ;       "TO10 FILE WRITE")
        DIAGP9                  ;SWAP AND TRANSFER DATA TO TO10 DATA
        MOV     @TO10DT,ACTUAL  ;CAPTURE DATA BYTE
        CMP     CORECT,ACTUAL   ;SWAPPED SUCCESSFUL?
        BEQ     T10BEX          ;YES-EXIT
        CMP     #177400,ACTUAL  ;NO-IS IT SWAPPED
        BEQ     T10BE2          ;YES-REPORT SWAP FAILURE
T10BE1: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        TO10 BYTE SWAP CARBLING DATA.  RAM LOCATION "TO10 DATA"
SHOULD CONTAIN 377 (8).  CHECK THE 4X2 MIXER FOR THE
ERRONEOUS BIT(S) ON THE DPS4 PRINT.  A SCOPE SYNCH POINT FOR THIS
PROBLEM IS THE MINOR STATE DECODE "CNT4 TO10 E B REQ L" (CNT4 B-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+

T10BE2: ERR16   CORECT,ACTUAL,,<TO10 BYTE SWAP FAILURE\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        SWAP NOT OCCURRING DURING TO10 BYTE XFER.  CHECK CNT1 SWAP H
(CNT1 C-7).  A SCOPE SYNCH FOR THIS PROBLEM IS
THE MINOR STATE DECODE "CNT4 TO10 E-B REQ L" (CNT4 B-4).
%
;*-+-+-+-+-+-+-+-=-=-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

T10BEX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ255


;********************************************************************
.REM    %
        KNOWING THAT IT IS POSSIBLE TO SWAP EIGHT ONES, THE PROGRAM EXIT
TRIES TO PERFORM THE COMPLEMENT OF THAT OPERATION.  (.E. SWAP EIGHT
ZEROES).
%
;*******************************************************************

T10B1:  CLR     CORECT          ;ALL ZEROES SHOULD APPEAR
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #-1,@TO10DT     ;ALL ONES FOR BACKGROUND
        MOV     #377,@NPRLOC    ;TRANSFER 8 ZEROES FROM LH BYTE
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        MOV     #TO10BM,@DIAG3  ;SET BYTE MODE
        JSR     PC,T10LOC       ;LOCK INTERFACE IN TO10 XFER
        INC     R0              ;MAKE AN ODD BYTE ADDRESS
        MOV     R0,@TO10AD      ;LOAD TO10 ADDRESS WITH ODD ADDRESS
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO10 ADR"
        DIAGP9                  ;PULSE THE CLOCK (TO10 ADR TO ABC REG)
                                ;(ALSO SET MINOR STATE "TO10 FILE WRITE")
        DIAGP9                  ;SWAP AND XFER NPR DATA TO TO10 DATA
        MOV     @TO10DT,ACTUAL  ;CAPTURE SEAPPED(?) DATA WORD
        CMP     CORECT,ACTUAL   ;SWAPPED SUCCESSFULLY?
        BEQ     T10B1X          ;YES-EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM COULD SUCCESSFULLY SWAP A BYTE OF 177400 INTO A 377
BUT FAILED TO SWAP EIGHT ZEROES FROM A LEFT HAND BYTE.  SEE SCOPE SYNCH
POINTS AND ERROR CALL OUTS FOR THE PREVIUS TWO ERRORS (T10BE1 AND
T10B3).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+

T10B1X: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ256


;*******************************************************************
.REM    %
        TO10C IS SIMILAR TO TO10B EXCEPT A WORD OF 17777 (8)
SHOULD BE SWAPPED INTO THE TO10 DATA WORD AS 000377(8).
%
;*********************************************************************
TO10C:  MOV     #377,CORECT     ;SET BYTE FOR COMPARISON
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,R0       ;NPR ADDRESS TO R0
        MOV     #TO10BM,@DIAG3  ;SET BYTE MODE.
        MOV     R0,@TO10AD      ;LOAD ADDRESS (SHOULD SET TO10 BYTE)
        CLR     @TO10DT         ;CLEAR DATA WORD
        MOV     #-1,@NPRLOC     ;ALL ONES
        JSR     PC,T10LOC       ;LOCK INTERFACE IN TO10 XFER
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO10 ADR"
        DIAGP9                  ;TO10 ADDRESS TO ABC REGISTER
        DIAGP9                  ;SWAP AND XFER DATA TO TO10 DATA
        MOV     @TO10DT,ACTUAL  ;CAPTURE DATA BYTE
        CMP     CORECT,ACTUAL   ;IS IT 377?
        BEQ     T10CEX           ;YES-EXIT
        ERR16   CORECT,ACTUAL
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        SWAP SELECT LOGIC FAILS TO STRIP LEFTMOST EIGHT BITS OF DATA
BYTE.  CHECK CNT1 SWAP SEL LT L (CNT1 C-7).  A SCOPE SYNCH FOR THIS
PROBLEM IS THE MINOR STATE DECODE "CNT4 TO10 E-B REQ L" (CNT4 B-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-=-+-+-+-+-+-+-+-+-=-+-+-+-+

T10CEX: JMP     NORMAL          ;GET NEXT TEST

;SEQ257

.SBTTL  *MISCELLANEOUS TESTING OF TO11 XFER

;*****************************************************************
.REM    %
        TO11A IS REALLY OBSCURE.  THE ROUTINE CHECKS THE SWAP OF THE
E BUFFER INTO THE RAM.  IT PROCEEDS AS FOLLOWS:

        1.  LOADS RAM LOCATION DEX ADDRESS 1 WITH A WORD OF ZEROES.
        2.  PERFORMS A DIAGNOSTIC RESET TO ALLOW THE CLOCK TO FREE RUN.
        3.  AS MAJOR STATE DEX COMES UP THE ZEROES FROM TEN ADDRESS
        WORD 1 IS READ INTO THE E BUFFER
        4. LOCKS THE DTE20 IN TO11 MAJOR STATE.
        5.  LOADS THE TO11 DATA WORD WITH ALL ONES FOR A BACKGROUND.
        5A.  LOADS THE TO11 ADDRESS WITH AN ODD NUMBER.
        6.  SETS TO11 BYTE MODE AND A BYTE COUNT OF 1.
        7.  FORCES MINOR STATE "TO11 SHIFT"
        8.PULSES THE CLOCK ONCE WHICH BRINGS UP CNT1 SWAP H AND
        ADVANCES TO MINOR STATE "TO11 EBUF STOR".
        9.  PULSES THE CLOCK AGAIN WHICH TRANSFERS THE SWAPPED E BUFFER
        INTO RAM LOCATION  TO11 DATA WORD.
        10. COMPARES THE TO11 DATA WORD FOR ZEROES

        IF ALL OF THIS FAILS, GOOD LUCK!!
(NOTE:  THIS TEST WILL PRODUCE AN ERRONEOUS ERROR PRINTOUT
        IF THE ECO WHICH CORRECTS THE MISSING ETCH ON THE
        EBUFFER SWAP LOGIC IS NOT INSTALLED.)
%
;*******************************************************************

TO11A:  CLR     CORECT          ;SET UP FOR COMPARISON
        CLR     @TENAD1         ;STEP #1
        DIAGRS                  ;STEP #2
        JSR     PC,T11LOC       ;STEP #4
        MOV     #-1,@TO11DT     ;STEP #5
        MOV     NPRLOC,R0       ;GET AN ADDRESS
        INC     R0              ;MAKE IT ODD
        MOV     R0,@TO11AD      ;STEP #5A
        MOV     #TO11BM!7777,@TO11BC  ;STEP #6
        MOV     #10!EDONES,@DIAG2  ;STEP #7
        DIAGP9                  ;STEP #8
        DIAGP9                  ;STEP #9
        MOV     @TO11DT,ACTUAL  ;CAPTURE THE SWAPPED E BUFFER
        CMP     CORECT,ACTUAL   ;SWAP CORRECTLY?
        BEQ     T11AEX          ;EXIT IF CORRECT
        ERR16   CORECT,ACTUAL

;*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING SWAP OF EBUFFER.  READ THE ABOVE TEST
DESCRIPTION, SYNCH YOUR SCOPE ON CNT1 SWAP H (CNT1 B-7) AND CHECK:

        1.  4X2 SWAP MIXER(S) FOR FAILING BIT(S) WHICH RUN ACROSS THE TOP
            OF THE DPS1 PRINT.

        2.  CNT1 SWAP SEL LT (SHOULD BE FALSE)    (CNT1 B-7)

;SEQ258



                (NOTE:  IF THE ACTUAL PRINTOUT IS "0 001 000 000 000
                        000", YOU PROBABLY DON'T HAVE THE ETCH CORRECTION
                                EC0.)

%
;*-+-+-+-+-+_=-+-+-+-+-=-=-+-=-=-=-=-+-=-=-+-=-+-=-+-+-+-+-+-+-+-+-+-+

T11AEX: JMP     NORMAL          ;EXIT TO TEST DISPATCHER

;SEQ259

.SBTTL  *E BUFFER TESTING

;*******************************************************************
.REM    %
        HERE BEGINS TESTING OF THE E BUFFER.  EBUF1 LOADS 10 ADR
WORD 1 WITH ZEROES AND TRANSFERS IT TO THE E BUFFER BITS 20-35.  IT THEN
SHJIFTS THE ZEROES INTO E BUFFER BITS 4-19 AND TRANSFERS THESE BITS BACK
INTO DEX WORD2.
%
;********************************************************************

EBUF1:  CLR     CORECT          ;WE'LL LOOK FOR ZEROES
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TENAD1 ;A      ;SET UP FOR EXAMINE (THESE ARE THE
                                ;ZEROES WE'LL CHECK FOR
        MOV     #-1,@DEXWD2     ;WE'LL USE A BACKGROUND OF ALL ONES
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX MODE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR 1"
        DIAGP9                  ;XFER TEN ADR1 TO EBUF 20-35
        MOV     #4,@DIAG2       ;FORCE MINOR STATE "DEXWD2"
        DIAGP9                  ;SHIFT ZEROES FROM EBUF 20-35
                                ;INTO EBUF 4-19
        MOV     #4,@DIAG2       ;AGAIN FORCE "DEX WD2"
        DIAGP9                  ;XFER EBUF 4-19 INTO DEXWD2 IN RAM
        MOV     @DEXWD2,ACTUAL  ;DID THE ZEROES GET THERE?
        BEQ     EBF1EX          ;YES-EXIT
        CMP     #-1,ACTUAL      ;NO-IS IT STILL ALL ONES
        BEQ     EB1ER2          ;IF SO REPORT
EB1ER1: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING TEST OF E BUFFER'S ABILITY TO HOLD ZEROES.  RAM
LOCATION DEXWD2 SHOULD CONTAIN ALL ZEROES BUT DOESN'T.  CHECK:
        1.  E BUFFER BITS 20-35 CORRESPONDING TO FAILING BIT    (DPS2)
        2.  RAM INPUT MIXER FOR BITS 4-19 CORRESPONDING TO FAILING BIT
                (DPS4).
          A USABLE SCOPE SYNCH FOR THIS PROBLEM IS CNT3 DIAG 10/
                11 (CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


EB1ER2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+
.REM    %
        ZEROES NOT BEING TRANSFERRED FROM EBUF 4-19 TO RAM DEX WORD 2.  EITHER
THEY WERE NOT TRANSFERRED INTO EBUF 20-35 (CHECK CNT2 E-BUF CLK H
@ CNT2 D-4), THEY WERE NOT SHIFTED FROM EBUF 20-35 TO EBUF 4-19
(CHECK CNT6 EBUF SEL H @ CNT6 B-6 IT SHOULDN'T SET), OR THE DATA IS NOT
BEING GATED FROM THE EBUFFER TO THE RAM.
        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS CNT3 DIAG 10/11
(CNT3 B-7).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EBF1EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ260



;*******************************************************************


.REM    %
        EBUF2 IS SIMILAR TO EBUF1 EXCEPT THAT IT SHIFTS ONES.
%
;*********************************************************************

EBUF2:  DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #167777,@TENAD1 ;SET UP FOR EXAMINE (WE'LL CHECK FOR THESE      
                                ;ONES)
        CLR     @DEXWD2         ;A BACKGROUND OF ZEROES TO DEX WD2
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR1"
        DIAGP9                  ;MOVE ONES TO EBUF 20-35
        MOV     #4,@DIAG2        ;NOW FORCE "DEXWD2"
        DIAGP9                  ;SHIFT ONES INTO EBUF 4-19
        MOV     #4,@DIAG2       ;SET "DEX WD2" AGAIN
        DIAGP9                  ;XFER EBUF 4-19 TO RAM
        CMP     #167777,@DEXWD2 ;DID THE ONES MAKE IT?
        BEQ     EBF2EX          ;YES-EXIT
        MOV     #167777,CORECT  ;NO-SET UP FOR PRINT
        MOV     @DEXWD2,ACTUAL  ;GET THE DELIVERED DATA

;SEQ261



        BEQ     EB2ER2          ;TO EB2ER2 IF STILL ALL ZEROES
EB2ER1: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING TEST OF E BUFFER'S ABILITY TO HOLD ONES.  RAM
LOCATION DEX WORD 2 SHOULD CONTAIN 7777 (8) BUT DOESN'T.  CHECK:
        1.  E BUFFER BITS 4-35 CORRESPONDING TO FAILING BIT     (DPS2)
        2.  RAM INPUT MIXER FOR BITS 4-19 CORRESPONDING TO FAILING BIT
            (DPS4)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS 
CNT3 DIAG 10/11 (CNT3 B-7).
%

;*-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EB2ER2: ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

.REM    %
        ONES NOT BEING TRANSFERRED FROM EBUF 4-19 TO RAM DEX WORD 2.
        1.  THEY MAY NOT HAVE BEEN TRANSFERRED FROM THE RAM
            INTO EBUF 20-35 - CHECK CNT2 E-BUF CLK H (CNT2 D-4).
       
        2.  THEY MAY NOT HAVE BEEN SHIFTED FROM EBUF 20-35 TO EBUF
            4-19 - CHECK CNT6 EBUF SEL H ( IT SHOULDN'T SET) (CNT6 B-6).
        3.  OR THE DATA MAY NOT BE GATING INTO THE RAM.
        CHECK:
                A.  INPUT GATING TO CNT2 SEL1 AND SEL2 (CNT2 B-3).

                B.  THE CNT5 DEP FLOP MAY BE STUCK ON A ONE (CNT5 D-7).
        USEFUL SCOPE SYNCH POINTS FOR THIS PROBLEM ARE LISTED ABOVE IN
        THE COMMENTS FOR EB2ER1.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


EBF2EX: JMP     NORMAL          ;EXIT TO NEXT TEST
;SEQ262


;*********************************************************************
.REM    %
        EBUF3 TESTS THE ABILITY OF E BUFFER BITS 0-4 TO HOLD ZEROES.
%
;********************************************************************

EBUF3:  DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #-1,@DEXWD1     ;ALL ONES FOR BACKGROUND
        CLR     @TENAD1         ;ZEROES FOR DATA & FORCE EXAMINE
        MOV     #-1,@DEXWD2     ;NEXT 16 BITS ARE ONES
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR 1"
        DIAGP9                  ;XFER ONES TO EBUF 32-35
                                ;AND ADVANCE TO MINOR STATE "DEX ADR 2"
        DIAGP9                  ;TRANSFER EBUF 20-35 INTO EBUF 4-19
                                ;AND LOAD ONES INTO EBUF 20-35
MOV     #4,@DIAG2               ;NOW FORCE MINOR STATE "DEX WD2"
        DIAGP9                  ;SHIFT ZEROES INTO EBUF 0-3, ONES TO 4-35
        MOV     #2!EDONES,@DIAG2        ;FORCE MINOR STATE "DEX WD1"
        DIAGP9                  ;XFER EBUF 0-3 INTO RAM
        MOV     @DEXWD1,ACTUAL  ;CAPTURE DATA WORD
        BIT     #17,ACTUAL      ;ALL BITS ZERO?
        BEQ     EBF3EX          ;YES-EXIT
        MOV     ACTUAL,CORECT   ;NO-SET UP FOR PRINTER
        BIC     #17,CORECT      ;GET RID OF FAILING BITS IN CORECT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING TEST OF ABILITY OF E BUFFER BITS 0-3 TO
HOLD ZEROES.  CHECK:

        1.  THE EBUFF FLOPS FOR BITS 0-3
        2.  THE DPS4 SPECIAL MULTIPLEX OF BITS DPS4 PM 00-03 
                (DPS4 D-7)
        3.  THE DPS4 2X4 MIXERS FOR BITS 0-3  (DPS4 1-4 & A-5)

A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE ONE
SIDE OF THE CNT4 DEX FLOP (CNT4 D-1).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EBF3EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ263


;******************************************************************
.REM    %
        EBUF4 IS IDENTICAL TO EBUF3 EXCEPT THAT THIS TIME
WE TRY TO PUT ONES IN EBUF 00-03.
%
;******************************************************************

EBUF4:  TST     RMFLAG          ;RESTRICTED?
        BNE     EBF4EX          ;YES,SKIP THIS TEST
        MOV     #17,CORECT      ;WE'LL COMPARE FOR FOUR ONES

        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #167777,@TENAD1 ;FORCE AN EXAMINE - ALL ONES FOR DATA
        CLR     @DEXWD2         ;NEXT 16 BITS ARE ZEROES
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR 1"
        DIAGP9                  ;XFER ONES EBUFF 32-35
                                ;AND ADVANCE TO MINOR STATE "DEX ADR 2"
        DIAGP9                  ;XFER ONES TO EBUFF 4-19, ZEROES TO 20-35
                                ;AND ADVANCE TO MINOR STATE "DEXWD1"
        MOV     #4,@DIAG2       ;NOW FORCE MINOR STATE "DEX WD2"
        DIAGP9                  ;ONES TO EBUFF 0-3, ZEROES TO 4-35
        CLR     @TENAD1         ;FORCE EXAMINE-ZEROES FOR BACKGROUND
        MOV     #2!EDONES,@DIAG2        ;FORCE MINOR STATE "DEX WD1"
        DIAGP9                  ;XFER EBUF 0-3 TO DEX WORD 1
        MOV     @DEXWD1,ACTUAL  ;GET DEX WORD 1
        CMP     CORECT,ACTUAL   ;FOUR ONES IN DEX WORD 1?
        BEQ     EBF4EX          ;YES-EXIT
        ERR16   CORECT,ACTUAL
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING TEST OF E-BUFFER BITS 0-3'S ABILITY
TO HOLD ONES.  CHECK:

        1.  THE E-BUFF FLOPS FOR BITS 0-3               (EBBM B2)
        2.  THE DPS4 SPECIAL MULTIPLEXOR BITS DPS4 SPM 00-03
                (DPS4 D-7)
        3.  THE DPS4 MIXERS FOR BITS 0-3        (DPS4 A-4 & A-5)

        A USABLE SCOPE WYNCH FOR THIS PROBLEM IS THE ONE
SIDE OF THE CNT4 DEX FLOP (CNT4 D-1)./
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EBF4EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ264



.SBTTL  *EBH REGISTER AND CONTROL LOGIC TESTS

;*************************************************************
.REM    %
        EBH1 TRIES TO INITIATE A TO10 TRANSFER BY USING A SPECIAL
DECODE OF THE TO11 MINOR STATE COUNT DECODER.  THE PROGRAM:

        1.  LOADS THE TO10 ADDRESS TO SET "CNT5 TO11 ADR LD"  (CNT5 C-3)
        2.LOCKS THE INTERFACE IN TO11 XFER MAJOR STATE.
        3.  SENDS A COUNT OF 16(8) TO THE STATE COUNTER WHICH
        SHOULD BRING UP DECODE "CNT4 EBH SET L" (WHICH SETS CONT5 TO10
          BC LD)
        4.  SENDS BIT 0 ONLY TO DIAGNOSTIC WORD 1 WHICH LEAVES THE INTERFACE
        IN 10/11 DIAGNOSTIC MODE BUT RESETS "CNT4 STATE HOLD"  (CNT4 C-2)

        5.PULSE THE CLOCK SO THAT TO10 IS TRUE.
        6.  SINGLE PULSES THE CLOCK UNTIL TO10 XFER COMES TRUE.
        7.  MOVE TO THE TO10 MAJOR STATE AGAIN.  (TO10 READY IS NOT
            SET UNTIL EBH CYC GOES FALSE).
        8.  PULSES THE CLOCK ONCE MORE TO MAKE SURE THAT THE INTERFACE
            IS LOCKED IN THE TO10 XFER MAJOR STATE.

        (NOTE:  THE PERCEPTIVE READER WILL NOTICE THE SIMILARITRIES BETWEEN
TTHIS TEST AND PREVIOUSLY EXECUTED TESTS OPR1 AND OPR2.)
%
;**************************************************************************

EBH1:   CLR     @DLYCNT         ;CLEAR HIORD PDP11 BITS.
        MOV     #TO10,CORECT    ;WE'LL TRY TO GET INTO TO10 STATE
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     NPRLOC,@TO10AD  ;STEP #1 ABOVE
        JSR     PC,T11LOC       ;STEP #2 ABOVE
        MOV     #34,@DIAG2      ;STEP #3 ABOVE
        DIAGMD                  ;SET DIAGNOSTIC MODE
        DIAGPL                  ;STEP #5 ABOVE
1$:     DIAGPL                  ;STEP #6 ABOPVE
        BIT     #TO10,@DIAG1    ;ARE WE AT TO10 XFER YET?
        BEQ     1$              ;NO-TRY AGAIN
        
2$:     DIAGPL                  ;STEP #7 ABOVE
        BIT     #TO10,@DIAG1    ;AT TO10 STATE AGAIN?
        BEQ     2$              ;N0 - TRY IT AGAIN
        DIAGPL                  ;PULSE ONCE MORE (SHOULDN'T ADVANCE)
        MOV     @DIAG1,ACTUAL   ;CAPTURE MAJOR STATE
        MOV     #^C<TO10>,MASK  ;CLEAR ALL BUT TO10 STATUS BIT
        MCMP16                  ;ARE WE STILL IN TO10?
        BEQ     EBH1EX          ;YES-EXIT

;SEQ265


        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        INTERFACE NOT STAYING LOCKED IN TO10 XFER AFTER LOADING TO10
BYTE COUNT AND 11 ADDRESS.  CHECK:

        1.  CNT5 TO10 ADR LD                    (CNT5 B-4)
        2.  CNT4 EBH SET L                      (CNT4 B-2)
        3.      CNT1 EBH STORE                  (CNT1 C-6)
        4.CNT5 TO10 BC LD                       (CNT5 D-3)
        5.  TO10  XFER SET GATE ON CNT4 STATE HOLD FLOP  (CNT4 C-3)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM ISBCON DIAG 10/11 (BCON D2)%
;*-+-+-+-+-+-+-=-=-=-=-=-=-=-=-+-+-=-+-=-+-+-=-=-+-+-+-+-+-+-+-+-+-+

EBH1EX: JMP     NORMAL          ;EXIT

;SEQ266

;******************************************************************
.REM    %
        EBH2 CHECKS THE ABILITY OF THE EB HOLD REGISTER TO HOLD ZEROES.
THE PROGRAM FIRST GFENERATES MST CLR (WHICH SHOULD CLEAR THE REGISTER).
IT NEXT LOADS THE TO10 BYTE COUNT WITH ALL ONES.  THE EB HOLD IS NEXT
TRANSFERRED TO THE TO10 BYTE COUNT LOCATION IN RAM, WHERE A TEST FOR
ZEROES IS PERFORMED.
        SINCE THE ONLY WAY TO LOAD THE EBH REGISTER IS VIA A DATAO 
INSTRUCTION FROM A WORKING KL10 PROCESSOR,THIS TEST IS ALL THAT WE CAN DO.
SO BE IT...
%
;******************************************************************

EBH2:   DIAGRS                  ;DIAGNOSTIC RESET
        CLR     CORECT
        MOV     #-1,@TO10BC     ;ALL ONES TO BYTE COUNT
        JSR     PC,T11LOC       ;LOCKINTERFACE IN "TO11 XFER" STATE
        MOV     #34,@DIAG2      ;FORCE "CLKS EBH SET L" DECODE
        CLR     @DIAG1          ;LET THE CLOCK FEREE RUN FROM HERE
        NOP                     ;A LITTLE TIME FOR THE CLOCK TO COME BACK ON
        TST     @TO10BC         ;WERE ALL ZEROES LOADED?
        BEQ     EBH2EX          ;YES-AMAZING!
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        FAILURE DURING EBUF HOLD DATA TEST.  ROUTINE SHOULD HAVE LOADED
ZEROES INTO RAM LOCATION "TO10 BYTE COUNT".  IF ALL ONES ARE IN THIS
LOCATION, THE EBUF HOLD TO RAM TRANSFER DID NOT OCCUR.  CHECK:
                
        1.  CNT1 EBH STORE FLOP                 (CNT1 C-6)
        2.  CNT1 EBH CYCL                       (CNT1 C-7)
        3.  INPUTS TO CNT1 ADR1H AND CNT1 ADR2H  (CNT1 B-6)
        4.  CNT1 EBH CYCL INPUT TO CNT1 WR PLS H  (CNT1 B-3)
A USEFUL SCOPE SYUNCH FOR THIS PROBLEM IS THE MINOR STATE DECODE "CNT4
EBH SET L" (CNT4 B-1).
        IF THE TO10 BYTE COUNT CONTAINS OTHER THAN ALL ONES, THE FAILURE
IS MOST LIKELY IN:
        1.  THE DPS2 EBHOLD FLOP FOR THE FAILING BIT(S)    (DPS2)
        2.  THE EBHOLD INPUT TO THE RFM MIXER FOR THE FAILING BITS.
        AGAIN, THE MINOR STATE DECODE "CNT4 EBH SET L" (CNT4 B-1)
PROVIDES A USEFUL SCOPE SYNCH.
%
;*-+-+-+-+-+-+-+-=-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-=

EBH2EX: JMP     NORMAL          ;EXIT TO NEXT TEST

;SEQ267


;***********************************************************************
.REM    %
D10 READS THE DIAGNOSTIC BUS ENABLE SWITCH (VIA BIT 3 OF THE STATUS
REGISTER) AND MAKES THE DECISION WHETHER OR NOT TO PERTURBATE THE
DIAGNOSTIC AND  E BUSSES.
%
;***********************************************************************

DI0:    DIAGRS                  ;DIAGNOSTIC RESET
        TST     P1FLG1          ;CHECK FIRST PASS FLAG
        BNE     NPAS1A          ;LAST PASS TESTED BUSS.
                                ;STILL ZERO - MUST BE PASS ONE.
;*COME HERE ON FIRST PASS ONLY

PASS1:  BIT     #RM,@STATUS             ;RESTRICTED?
        BEQ     NPASS1          ;NO

;*COME HERE IF DTE-20 IS RESTRICTED

NPASS2: PMSG    <NOT TESTING E OR DIAGNOSTIC BUSSES\>
        MOV     #1,P1FLG1       ;SET FLAG TO 1.
        MOV     #<CHECKL-TESTAB>/2,TESTAB ;SHORTEN TEST LIST
NPAS1A: JMP     NORMAL

;*COME HERE IF NOT RESTRICTED

NPASS1: PMSG    <TESTING E AND DIAGNOSTIC BUSSES\>
        MOV     #-1,P1FLG1
        JMP     NORMAL

;SEQ268


.SBTTL  *DS REGISTER TESTS

;******************************************************************
.REM    %
        DI2 SETS KL10 DIAGNOSTIC MODE (THIS WILL DISTURB THE KL10) AND
SENDS ALL ZEROES TO THE SEVEN KL10 DIAGNOSTIC FUNCTIONS (DS00 DS06).
IT THEN READS DIAGNOSTIC WORD 1 AND LOOKS FOR A ONE IN BIT 1
(KL10 DIAGNOSTIC MODE) AND ZEROES IN BITS 09-15 (THE DS FLOPS).
%
;******************************************************************

DI2:    CLR     CORECT          ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #DIKL10!DFUNC,@DIAG1 ;KL10 DIAG. MODE & ZEROES TO THE
                ;DS FLOPS
        MOV     @DIAG1,ACTUAL   ;DIAG WORD 1 TO ACTUAL
        MOV     #^C<DS00!DS01!DS02!DS03!DS04!DS05!DS06>,MASK
                                ;CLEAR ALL BUT THE DS FLOPS
        MCMP16                  ;COMPARE
        BEQ     DI2EX           ;TEST OKAY
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        ONE OR MORE OF THE DS FLOPS (AS SEEN VIA DIAG1) STUCK AT ONE.  CHECK:

        1.  THE RELEVANT FLOP(S)                        (CNT3 A8-A6)
        2.  THE UNIBUS TRANSCEIVERS FOR THE DS FLOPS    (CNT3 D1-D3)

        A USABLE SCOPEW SYNCH FOR THIS PROBLEM IS CNT2 DIAG 1
        STRB H (CNT3 A8).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

DI2EX:  JMP     NORMAL          ;GET NEXT TEST

;SEQ269


;***********************************************************************
;*TEST DS00- 06 FLOPS WITH ONES
;**********************************************************************

DIA3:   MOV     #DS00!DS01!DS02!DS03!DS04!DS05!DS06,CORECT
                                ;WE'LL TEST FOR THE BITS ABOVE
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #DS00!DS01!DS02!DS03!DS04!DS05!DS06!DFUNC,@DIAG1
                                ;SET 'EM
        MOV     @DIAG1,ACTUAL   ;READ 'EM
        MOV     #^C<DS00!DS01!DS02!DS03!DS04!DS05!DS06>,MASK  ;MASK 'EM
        MCMP16                  ;TEST RESULTS
        BEQ     DIA3EX          ;EXIT IF THEY ALL SET
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=
.REM    %
        ONE OR MORE OF THE DIAGNOSTIC CONTROL FLOPS (BCON
DS00-DS06) STUCK ON A ZERO.  IF THEY ARE ALL ZERO CHECK BCON DIAG BUS EN
(BCON D2).  IF A SINGLE FLOP IS AT ZERO CHECK:
        
        1.  THE INDICATED DS FLOP               (CNT3 A8-A6)
        2.  THE BCON UNIBUS TRANSCEIVER FOR THE FAILING BIT (CNT3 D1-D3)
        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS "CNT2 DIAG1 STRB H"
        (CNT3 A8).

%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

DIA3EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ270


;****************************************************************
;CHECK DS00-06'S ABILITY TO BE LOADED WITH ZEROES
;********************************************************************


DIA4:   CLR     CORECT  ;SET CORRECT DATA REGISTER
        DIAGRS          ;DIAGNOSTIC RESET
        MOV     #DS00!DS01!DS02!DS03!DS04!DS05!DS06,@DIAG1 ;SEND ONES
        MOV     #DFUNC,@DIAG1   ;NOW SEND ZEROES
        MOV     @DIAG1,ACTUAL   ;NOW CAPTURE THEM
        BIT     #DS00!DS01!DS02!DS03!DS04!DS05!DS06,ACTUAL ;ALL CLEAR?
        BEQ     DIA4EX          ;YES -EXIT
        MOV     #777,MASK       ;SET MASK FOR COMPARISOSN PRINT
        ERR16   CORECT,ACTUAL,MASK,<"ACTUAL" = DIAG WORD 1\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+
.REM    %
        ONE OR MORE OF THE KL10 DIAGNOSTIC FLOPS (CNT3 DS00-DS06)
CAN BE CLEARED BY MST CLR BUT WILL NOT LOAD WITH ZEROES VIA UNIBUS.
CHECK INDICATED FLOP(S) WHILE SYNCHIG ON "CNT3 DIAG1 STRBH"
(CNT3 A8).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+-+

DIA4EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ271


.SBTTL  *EBUS TESTING

;********************************************************************
.REM    %
        EB1 IS THE FIRST TEST OF THE EBUS.  IT CLEARS THE BUFFER,
SETS EBUS LOOP AND READS THE EBUFFER BACK INTO RAM WHERE BITS 00-19
ARE CHECKED FOR ZEROES.
%
;***********************************************************************

EB1:    CLR     CORECT          ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TENAD1         ;EXAMINE WITH ZERO ADDRESS
        CLR     @DEXWD3         ;ZEROES FOR DATA
        CLR     @DEXWD2         ;ZEROES FOR DATA
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR 1"
        DIAGP9                  ;LOAD DEX ADR1 TO EBUF 32-35
        MOV     #36,@DIAG2      ;AGAIN, FORCE "DEX ADR 1"
        DIAGP9                  ;LOAD DEX ADR1 TO EBUF 20-35 SHIFT EBUF
        MOV     #36,@DIAG2      ;AND STILL AGAIN FORCE "DEX ADR 1"
        DIAGP9                  ;THIS SHOULD LEAVE EBUF FILLED WITH ZEROES
        MOV     #12,@DIAG2      ;FORCE SPECIAL MINOR STATE "EBUS LOOP"
        DIAGP9                  ;BOUNCE DATA FROM EBUF TO EBUS TO EBUF
        MOV     #-1,@DEXWD3     ;ONES FOR BACKGROUND
        MOV     #-1,@DEXWD2     ;   "    "     "



        MOV     #2!EDONES,@DIAG2 ;FORCE MINOR STATE "DEXWD1"
        DIAGP9                  ;XFER EBUF 0-3 INTO DEX WORD 1
        DIAGP9                  ;XFER EBUF 4-19 INTO DEX WORD 2
        MOV     @DEXWD1,ACTUAL  ;DATA TO ACTUAL
        CMP     CORECT,ACTUAL   ;DID THE ZEROES MAKE IT TO BITS 00-03
        BEQ     EB1A            ;YES - CHECK DEX WORD 3
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-=_+_+-+_=_+-+_=-+-+-=_=
.REM    %
        EBUS BITS 0-3 SHOULD BEW ALL ZEROES BUT AREN'T.  SYNCH SCOPE
ON SPECIAL MINOR STATE DECODE "CNT4 E-BUS LOOPL" (CNT4 B-5) AND CHECK:

        1.  E BUS DRIVER/RECEIVER(S) FOR FAILING BIT(S) (DPS3 D-6 & D-7)
        2.  INPUTS TO EBUFFER FOR FAILING BIT(S)        (DPS2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
;SEQ272

;NEXT CHECK BITS 4-19

EB1A:   CLR     CORECT          ;ZEROS FOR COMPARISION
        MOV     @DEXWD2,ACTUAL  ;DID THE ZEROES GET TO BITS 4-19?
        CMP     CORECT,ACTUAL
        BEQ      EB1EX               ;YES-EXIT
        ERR16    CORECT,ACTUAL

;*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-=-=-+-=
.REM    %
                E BUS BITS 4-19 SHOULD BE ALL ZEROES BUT AREN'T.  SYNCH SCOPE
ON SPECIAL MINOR STATE DECODE "CNT4 E-BUS LOOPL"(CNT4 B-5 AND CHECK:

        1. EBUS DRIVERS/RECIEVERS FOR FAILING BIT(S). (DPS3)
        2. INPUTS TO EBUS FOR FAILING BIT(S). (DPS2)
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

EB1EX:  JMP     NORMAL          ;GET NEXT TEST

;SEQ273



;********************************************************************
;*EB2 CHECKS TO SEE IF BITS 20-35 OF THE E BUS WILL HOLD ZEROES.
;********************************************************************

EB2:    CLR     CORECT          ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TENAD1         ;EXAMINE WITH ZEROE'S FOR ADDRESS
        JSR     PC,LOCDEX               ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR 1"
        DIAGP9                  ;XFER DEX ADR1 TO EBUF 20-35
        MOV     #12,@DIAG2      ;FORCE "E-BUS LOOP"
        DIAGP9                  ;BOUNCE EBUF TO EBUS TO EBUF
        MOV     #4,@DIAG2       ;BACK TO DEX WD1
        DIAGP9                  ;SHIFT EBUF 20-35 INTO EBUF 4-19
        MOV     #-1,@DEXWD1     ;PUT IN AN ALL ONES BCKGROUND
        MOV     #4,@DIAG2        ;BACK TO DEX WD2
        DIAGP9                  ;XFER EBUF 4-19 INTO DEX WORD 2
        MOV     @DEXWD2,ACTUAL  ;CAPTURE
        CMP     CORECT,ACTUAL   ;DID THE ZEROES GET THERE
        BEQ     EB2EX           ;YEST - EXIT
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        EBUS BITS 20-35 SHOULD BE ZEROES BUT AREN'T.  SYNCH SCOPE
ON SPECIAL MINOR STATE DECODE "CNT4 E-BUS LOOP L" (CNT4 B-5)
AND CHECK:

        1.  EBUS DRIVER/RECEIVER(S) FOR FAILING BIT(S)  (DPS3)
        2.  INPUT(S) TO EBUFFER FOR FAILING BIT(S)      (DPS2)
%
;*-+-+-+-+-+-+-+-=-=-=-=-=-+-+-+-+-=-=-=-=-=-=-=-=-+-=-=-=-=-=-+-+-=

EB2EX:  JMP     NORMAL          ;GET NEXT TEST

;SEQ274


;************************************************************
.REM    %
        EB3 IS SIMILAR TO TEST EB1 EXCEPT THAT IT CHECKS TO SEE IF 
EBUS BITS 00-19 CAN HOLD ONES.
*
%
;*******************************************************************

EB3:    MOV     #17,CORECT      ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #167777,@TENAD1 ;EXAMINE WITH ADDRESS OF ALL ONES
        JSR     PC,LOCDEX               ;LOCK IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINOR STATE "DEX ADR1"
        DIAGP9                  ;XFER DEX ADR1 TO EBUF 32-35
        MOV     #36,@DIAG2      ;AGAIN FORCE "DEX ADR 1"
        DIAGP9                  ;XFER DEX ADR1 TO EBUF 20-35, AND SHIFT LEFT
        MOV     #36,@DIAG2      ;AND STILL ONCE MORE FORCE "DEX ADR 1"
        DIAGP9                  ;SHIFT LEFT
        MOV     #12,@DIAG2      ;FORCE SPECIAL MINOR STATE DECODE
        DIAGP9                  ;THIS DOES E-BUS LOOP
        CLR     @DEXWD3         ;A BACKGROUND OF ZE$OES
        CLR     @DEXWD2         ;"       "      "    "
        MOV     #2!EDONES,@DIAG2        ;NOW FORCE MINOR STATE "DEXWD1"
        DIAGP9                  ;XFER EBUF 0-3 INTO DEX WD 1
        DIAGP9                  ;XFER EBUF 4-19 INTO DEX WD 2
        MOV     @DEXWD1,ACTUAL  ;GHET  BITS 0-3
        CMP     CORECT,ACTUAL   ;WERE THEY ALL ONES?
        BEQ     EB3A            ;YES - GO CHECK DEX WORD2
        ERR16   CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        EBUS BITS 0-3 SHOULD BE ALL ONES BUT AREN'T.  SYNCH SCOPE ON SPECIAL
MINOR STATE DECODE "CNT4 E-BUS LOOP L" (CNT4 B-5) AND CHECK:
        1.  EBUS DRIVER/RECEIVER(S) FOR FAILING BIT(S)  (DPS3)
        2.      INPUTS TO EBUF MIXER(S) FOR FAILING BIT(S) (DPS2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EB3A:   MOV     #167777,CORECT  ;NOW CHECK FOR ALL ONES
        MOV     @DEXWD2,ACTUAL  ;GET THE WORD FOR COMPARISON
        CMP     CORECT,ACTUAL   ;DID THE ONES MAKE IT?
        BEQ     EB3EX           ;EXIT IF IT WAS ALL ONES
        ERR16    CORECT,ACTUAL

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        EBUS BITS 5-19 SHOULD BE ALL ONES BUT AREN'T.  SYNCH SCOPE
ON SPECIAL MINOR STATE DECODE "CNT4 E-BUS LOOPL" (CNT4 B-5) AND CHECK:
        1.  EBUS DRIVER/RECEIVER(S) FOR FAILING BIT(S)  (DPS3)
        2.  INPUTS TO EBUF MIXER(S) FOR FAILING BIT(S)  (DPS2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
EB3EX:  JMP     NORMAL          ;GET NEXT TEST



;SEQ275


;*******************************************************************
.REM    %
        EB4 IS SIMILAR TO EB2 EXCEPT THAT IT CHECKS BITS 20-35
FOR ONES RATHER THAN ZEROES.
%
;*******************************************************************

EB4:    MOV     #167777,CORECT  ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     #167777,@TENAD1 ;EXAMINE WITH ADDRESS OF ALL ONES
        JSR     PC,LOCDEX       ;LOCK INTERFACE IN DEX STATE
        MOV     #36,@DIAG2      ;FORCE MINORSTATE "DEX ADR 1"
        DIAGP9                  ;XFER DEX ADR1 TO EBUF 20-35
        MOV     #12,@DIAG2      ;FORCE EBUS LOOP
        DIAGP9                  ;XFER EBUF TO EBUS TO EBUF
        MOV     #4,@DIAG2       ;BACK TO DEX WD2
        DIAGP9                  ;SHIFT EBUF 20-35 INTO 4-19
        CLR     @DEXWD1         ;ZEROES FOR BACKGROUND
        MOV     #4,@DIAG2       ;MINOR STATE = "DEXWD2"
        DIAGP9                  ;XFER EBUF 4-19 TO DEX WORD 2
        MOV     @DEXWD2,ACTUAL  ;CAPTURE THE ONES
        CMP     CORECT,ACTUAL   ;DID THEY GET THERE?
        BEQ     EB4EX           ;EXIT IF IT MADE IT
        ERR16   CORECT,ACTUAL

;*-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        EBUS BITS 20-35 SHOULD BE ONES BUT AREN'T.  SYNCH SCOPE ON
SPECIAL MINOR STATE DECODE "CNT4 E-BUS LOOP L" (CNT4 B-5) AND CHECK:

        1.  EBUS DRIVER/RECEIVER(S) FOR FAILING BIT(S)  (DPS3)
        2.  INPUTS TO EBUF MIXER(S) FOR FAILING BIT(S)  (DPS2)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EB4EX:  JMP     NORMAL          ;GET NEXT TEST

;SEQ276


.SBTTL  *EBUS CYCLE TESTING

;*********************************************************************
.REM    %
        CLK5 FORCES MINOR STATE "TO11 IO FUNCTION" AND READS THE RAM
ADDRESS (WHICH SHOULD BE 07 - "TO11 BYTE CNT").  THE ROUTINE NEXT
SINGLE PULSES THE CLOCK (WHICH SHOULD HAVE NO EFFECT SINCE "CLKS INH CLK"
IS SET WAITING FOR "UBIC BUS COMP") AND READS THE RAM ADDRESS TO MAKE
SURE THAT IT DOESN'T ADVANCE TO 11(8), INDICATING MINOR STATE "TO11 
SHIFT".
        FOLLOWING THIS, THE PROGRAM FORCES EBUS CYCLE COMPLETE (VIA
 BIT 14 OF DIAGNOSTIC WORD 2) AND READS THE RAM ADDRESS TO SEE IF IT
HAS ADVANCED TO 11(8) (MINOR STATE "TO11 SHIFT")
%
;*********************************************************************

CLK5:   MOV     #RFMAD1!RFMAD2!RFMAD3,CORECT    ;SET CORRECT DATA REGISTER
        DIAGRS          ;DIAGNOSTIC RESET
                        ;IT SHOULD CLEAR PIA FLOPS
        JSR     PC,T11LOC       ;LOCK INTERFACE IN TO11 MAJOR STATE
        MOV     #10,@DIAG2      ;FORCE MINOR STATE "TO11 I/O FUNC"
        JSR     PC,RAMASK       ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                  ;ADDRESS = 7?
        BEQ     CLK5A           ;YES - PROCEED
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=_=-+-+-+
.REM    %
        INCORRECT RAM ADDRESS DECODE GENERATED BY MINOR STATE DECODE
"TO11 I/O FUNC".  CHECK:

        1.  TO11 MINOR STATE DECODER    (74154 @ CNT4 B-3)
        2.  CNT1 BC STORE               (CNT1 B-4)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE ONE SIDE OF TH
"CNT5 SINGLE PLS" FLOP (CNT5 D-2).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ277

;***********************************************************************
.REM    %
        HAVING ADVANCED TO MINOR STATE "TO11 I/O FUNC". THE STATE
COUNTER SHOULD NOT  RESPOND TO SINGLE PULSING SINCE "CNT4 INH CLK" IS
BEING HELD SET BY "TO11 I/O FUNCTION" AND "INT1 BUS COMP (0)".
%
;*******************************************************************

CLK5A:  MOV     #RFMAD1!RFMAD2!RFMAD3,CORECT  ;SET CORRCT DATA REGISTER
        DIAGP9          ;PULSE THE CLOCK (SHOULD NOT ADVANCE STATE 
                                ;COUNTER
        JSR     PC,RAMASK        ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16          ;DID STATE COUNT ADVANCE?
        BEQ     CLK5B   ;NO - CONTINUE CHECKING
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        CNT4 INH CLK ALLOWING CLOCK TO RUN WHILE EBUS REQUEST IS TRUE
CHECK:
        
        1.  INPUT GATING NET WORK TO "CNT4 INH XLK" FLOP WITH
                    
         (CNT4 TO11 I/O FUNCTION" AND "INT1 BUS COMP(0)" (CNT4 C-6)
        2.  INT1 BUS COMP FLOP  (INT1 B-1)

        A USABLE SSCOPE SYMCH FOR THIS PROBLEM IS THE ONE SIDE OF THE
CNT5 SINGLE PLS FLOP (CNT5 D-2).  IT SHOULD SET TWICE.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ278

;*********************************************************************
.REM    %
        KNOWING THAT THE EBUS REQUEST CAN STOP THE CLOCK, THE PROGRAM
NEXT FAKES EBUS COMPLETE VIA VBIT 14 OF DIAG WORD 2 AND CHECKS TIO SEE
IF THE MINOR STATE COUNTER ADVANCES.
%
;*****************************************************************

CLK5B:  DIAGRS          ;DIAGNOSTIC RESET
        JSR     PC,T11LOK       ;LOCK INTERFACE IN TO11 STATE
        MOV     #RFMAD0!RFMAD3,CORECT  ;SET CORECT DATA REGISTER
        MOV     #10!EDONES,@DIAG2 ;SAME MINOR STAT BUT SET E B DONE
        DIAGP9                          ;PULSE THE CLOCK
        JSR     PC,RAMASK       ;MASK OUT ALL BURT RAM ADDRESS BITS
        MCMP16                  ;DID ADDRESS CHANGE TO 11(8)?
        BEQ     CLK5EX          ;YES - EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+
.REM    %
        INT1 BUS COMP WILL NOT ALLOW CNT4 INH CLK TO RESET FOLLOWING
MOV OF BIT 14 TO DIAG WORD 2.  CHECK:

        1.  CNT2 BUS DONE SET L (CNT2 D-1)
        2.  INT1 BUS COMPP FLOP STUCK AT ZERO  (INT1 B-1)
        3.  BUS COMP (0) INPUT TO CNT4 INH CLK FLOP STUCK @ ONE (CNT4 C-6)

        A USABLE SCOPY SYNCH FOR THS PROBLEM IS THE ONE SIDE OF THE
CNT5 SINGLE PULSE FLOP (SHOULD SET 3 TIMES) (CNT5 D-2).
%
;*-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

CLK5EX: JMP     NORMAL          ;GET NEXT TEST

;SEQ279


;*********************************************************************
.REM    %
        CLK6 IS SIMILAR TO BUT SIMPLER THAN CLK5.  THE ROUTINE MAKES
SURE THAT MINOR STATES "TO10 E-B REQ" AND "DEX ADR2"CAN ALSO STOP THE
CLOCK.  (IN ADDITION, SINCE THIS IS THE FIRST TIME WE'VE PRODUCED THESE
MINOR STATES, THE ASSOCIATED RAM ADDRESSES ARE CHECKED).
%
;**********************************************************************


CLK6:   MOV     #RFMAD0,CORECT  ;SET CORRECT DATA REGISTER
        DIAGRS                  ;DIAGNOSTIC RESET
        JSR     PC,T10LOC       ;LOCK INTERFACE IN MAJOR STATE "TO10 XFER"
        MOV     #20,@DIAG2      ;SET MINOR STATE "TO10 E-BUF FILL"
        DIAGP9                  ;ADVANCE TO MINOR STATE "TO10 E-B REQ"
        JSR     PC,RAMASK       ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                  ;RAM ADDRESS = 10(8)?
        BEQ     CLK6A           ;YES - PROCEED
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+
.REM    %
        INCORRECT RAM ADDRESS FOR MINOR STATE DECODE "TO10 E-B REQ."
CHECK:

        1.  MINOR STATE DECODE "CNT4 TO10 E-B REQ L"  (CNT4 B-3)
        2.  CNT1 ADDRESSING NETWORK THAT YIELDS "CNT1 ADR00H-ADRO4H.
                                                        (CNT1 A-6&B-6)

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS MINOR STATE DECODE
CNT4  TO10 E-BUF FILL (CNT4 B-4).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=_=_+-+-+-+-+-+-+-+

CLK6A:  MOV     #RFMAD0,CORECT  ;SET CORRECT DATA REGISTER
        DIAGP9                  ;TRY TO PULSE CLOCK (SHOULDN'T HAPPEN)
        MCMP16                  ;STILL AT MINOR STATE "TO10 E-B REQ"?
        BEQ     CLK6B           ;YES-PROCEED.
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+
.REM    %
        MINOPR STATE DECODE "TO10 E-B REQ" NOT HOLDING "CNT4
INH CLK" SET.  SYNCH SCOPE ON CNT5 SINGLE PULSE FLOP (CNT5 D-1)
AND CHECK INPUT GATE TO CNT4 INH CLK FLOP (CNT4 C-6).
%
;*-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ280


CLK6B:  MOV     #RFMAD1!RFMAD3,CORECT  ;SET CORRECT DATA REGISTER
        JSR     PC,LOKDEX               ;RESET & LOCK INTERFACE IN DEX
        MOV     #2,@DIAG2       ;FORCE MINOR STATE "DEX ADR2"
        JSR     PC,RAMASK       ;MASK OUT ALL BUT RAM ADDRESS BITS
        MCMP16                  ;RAM ADDRESS = 5?
        BEQ     CLK6C           ;YES - PROCEED
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        INCORRECT RAM ADDRESS FOR MINOR STATE DECODE "DEX ADR 2".
CHECK:
        1.  MINOR STATE DECODE "CNT5 DEX ADR 2L" (CNT5 B-5)

        2.  CNT1 ADDRESSING NETWORK THAT YIELDS "CNT1 ADROH - ADR3H"
                                (CNT1 A-6 & B-6).

        A USABLE SCOPE SYNCH FOR THIS PROBLEM IS THE MAJOR STATE FLOP
CNT4 DEX (CNT4 D-1).
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

CLK6C:  MOV     #RFMAD1!RFMAD3,CORECT   ;SET CORRECT DATA REGISTER
        DIAGP9                          ;TRY TO PULSE THE CLOCK (SHOULDN'T
                                        ;WORK)
        JSR     PC,RAMASK               ;MASK OUT ALL BU RAM ADDRESS BITS
        MCMP16                          ;STILL AT MINOR STATE "DEX ADR2"?
        BEQ     CL6EX                   ;YES - EXIT
        ERR16   CORECT,ACTUAL,MASK

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        MINOR   STATE DECODE "DEX ADR2" NOT HOLDING "CNT4 INH CLK"
SET.  SYNCH SCOPE ON THE STATE DECODE (CNT4 B-5) AND CHECK
INPUT GATE TO CNT4 INH CLK FLOP.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+

CL6EX:  JMP     NORMAL          ;GET NEXT TEST

HOLDAR: .BLKW   20.
        NPRTST: 0

;SEQ281




;******************************************************************
.REM    %
        THIS TEST AND THE TWO FOLLOWING WILL TEST THE E-BUS USING A
FLOATING I/O PATTERN. I.E. A SINGLE ONE BIT WILL BE FLOATED THROUGFH
THE E-BUSS AND THE RESULTS CHECKED
%
;******************************************************************

DEXF1A: MOV     #LSTFA1,R1      ;SET UP TEST LIST.
 1$:     MOV     (R1)+,CORECT    ;SET CORECT DATA REGISTER.
        TST     CORECT          ;END OF LIST YET?
        BEQ     DEX1EX          ;YES-EXIT
        DIAGRS                  ;DIAGNOSTIC RESET
        MOV     CORECT,@TENAD1  ;PUT AN ENTRY FROM LIST INTO TEN ADDR1
        JSR     PC,LOCDEX               ;LOCK IN DEX STATE.
        MOV     #36,@DIAG2      ;"DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #36,@DIAG2      ;"DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #36,@DIAG2      ;"DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #12,@DIAG2      ;SPECIAL MINOR DECODE.
        DIAGP9                  ;PULSE THE CLOCK
        CLR     @DEXWD3         ;CLEAR BACKGROUND
        CLR     @DEXWD2         ;  "      "
        MOV     #2!EDONES,@DIAG2        ;"DEX WD1"
        DIAGP9                  ;EBUF 0-3 TO DEXWD1
        DIAGP9                  ;EBUF 4-19 TO DEXWD2
        MOV     @DEXWD1,ACTUAL  ;GET THE TESTED BIT
        CMP     CORECT,ACTUAL   ;DID IT MAKE IT?
        BEQ     1$              ;YES-GET NEXT PATTERN
        ERR16   CORECT,ACTUAL

DEX1EX: JMP     NORMAL          ;EXIT TEST

LSTFA1: 1
        2
        4
        10
        0

;SEQ282



;*******************************************************************
;TEST BITS 4-19
;*******************************************************************

DEXF2A: MOV     #LSTFA2,R1               ;SET CORRECT DATA REGISTER.
1$:     MOV     (R1)+,CORECT     ;SET CORRECT DATA REGISTER.
        TST     CORECT          ;END OF LIST YET?
        BEQ     DEX2EX          ;YES!
        DIAGRS                  ;NO-RESET
        MOV     CORECT,@TENAD1  ;GET PATTERN FROM TABLE
        JSR     PC,LOCDEX       ;LOCK IN DEX MAJOR STATE
        MOV     #36,@DIAG2      ;"DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #36,@DIAG2      ;DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #36,@DIAG2      ;"DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #12,@DIAG2      ;SPECIAL MINOR STATE DECODE
        DIAGP9                  ;PULSE THE CLOCK
        CLR     @DEXWD3         ;CLEAR BACKGROUND
        CLR     @DEXWD2         ;  "     "
        MOV     #2!EDONES,@DIAG2        ;"DEX WD1"
        DIAGP9                  ;PULSE THE CLOCK
        DIAGP9                  ;PULSE THE CLOCK
        MOV     @DEXWD2,ACTUAL  ;CAPTURE THE BIT
        CMP     CORECT,ACTUAL   ;DID IT GET THERE?
        BEQ     1$              ;YES-AMAZING!
        ERR16   CORECT,ACTUAL

DEX2EX: JMP     NORMAL
LSTFA2: 1
        2
        4
        10
        20
        40
        100
        200
        400
        1000
        2000
        4000
        20000
        40000
        100000
        0

;SEQ283


;********************************************************************
;TEST EBUS BITS 20-35
;********************************************************************

DEXF3A: MOV     #LSTF1B,R1      ;SET UP TEST LIST ADDRESS.
1$:     MOV     (R1)+,CORECT    ;SET CORECT DATA REGISTER.
        TST     CORECT          ;AT THE END ALL ZEROES?
        BEQ     DEX3EX          ;YES! EXIT
        DIAGRS                  ;DIAGNOSTIC RESET.
        MOV     CORECT,@TENAD1  ;SET ADDRESS
        JSR     PC,LOCDEX               ;LOCK INTO DEX STATE.
        MOV     #36,@DIAG2      ;MINOR STATE "DEX ADR1"
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #12,@DIAG2      ;FORCE EBUS LOOP.
        DIAGP9                  ;PULSE THE CLOCK
        MOV     #4,@DIAG2               ;BACK TO DEX WD2
        DIAGP9                  ;PULSE THE CLOCK
        CLR     @DEXWD1         ;ZEROES FOR BACKGROUND.
        MOV     #4,@DIAG2       ;DEX WD2.
        DIAGP9                  ;PULSE THE CLOCK
        MOV     @DEXWD2,ACTUAL  ;CAPTURE THE WORD
        CMP     CORECT,ACTUAL   ;DID IT MAKE IT?
        BEQ     1$              ;YES-GET NEXT PATTERN
        ERR16   CORECT,ACTUAL

DEX3EX: JMP     NORMAL
LSTF1B: 1
        2
        4
        10
        20
        40
        100
        200
        400
        1000
        2000
        4000
        20000
        40000
        100000
        0

;SEQ284


;********************************************************
.REM    %
        HERE BEGINSCHECKING OF THE EBUS PARITY LOGIC.  EPAR1 STARTS
A SINGLE BYTE TO11 TRANSFER AT MINOR STATE "TO11 FILE READ".  SINCE NO
DATA HAS BEEN LOADED INTO THE E BUFFER, ALL ZEROES SHOULD PRODUCE A
PARITY ERROR.  THE ROUTINE CHECKS FOR THE ABSENCE OF TO11 DONE (AN AB-
NORMAL TERMINATION) AND THE PRESENCE OF BOTH TO11ER (STATUS REG BIT 1)
AND BPARER (STATUS REG BIT 4).
%
;******************************************************************

EPAR1:  MOV     #TO11ER!BPARER,CORECT ;ST UP FOR COMPARISOPN
        DIAGRS                  ;DIAGNOSTIC RESET
        CLR     @TO11BC         ;LOAD CYTE COUNT OF ZERO
        DIAGRS                  ;ANOTHER DIAGNOSTIC RESET
        MOV     NPRLOC,@TO11AD  ;LOAD NPR ADDRESS
        JSR     PC,T11LOC               ;LOCK INTERFACE IN TO11 MAJOR               
                                ;STATE
        CLR     @TO11BC         ;SET "TO11 BC LOAD"
        MOV     #14,@DIAG2              ;FORCE MINOR STATE "TO11 FILE READ"
        CLR     @DIAG1          ;LET THE CLOCK FREE RUN
EPAR1A: BIT     #TO11,@DIAG1    ;IN TO11 MAJOR STATE?
        BNE     EPAR1A  ;YES-WAIT UNTIL WE LEAVE
EPAR1B: BIT     #TO11,@DIAG1    ;       NOW WAIT FOR IT
;;NO
        BEQ     EPAR1B  ;       TO SET AGAIN
        NOP                     ;KILL A LITTLE TIME
        MOV     #177555,MASK    ;SET UPA COMPARISON MASK
        MOV     @STATUS,ACTUAL  ;CAPTURE STATUS
        BIT     #TO11ER,ACTUAL  ;DID WE GET THE ERROR?
        BNE     EPAR1C          ;YES-DO MORE TESTS.
        BIT     #BPARER,ACTUAL  ;NO, DID WE GET BUS PARITY ERROR AT LEAST?
        BEQ     EPAR1D          ;NOT EVEN THAT MUCH
        ERR16   CORECT,ACTUAL,MASK,<BPARER WITHOUT TO11 ERROR. ACTUAL=STATUS\>

;*******************************************************************

.REM    %
        EBUS PARITY ERROR NOT SETTING TO11 ERROR DURING TO11 XFER BUT
PROGRAM KNOWS THAT TO11 ERROR CAN BE SET VIA THE DIRECT SET GATE.
%
;********************(**********************************************

;SEQ285


;*HERE IF TO11 ERROR

EPAR1C: BIT     #BPARER,ACTUAL  ;DID WE GET BUS PARITY ERROR AS WELL?
        BNE     EPAR1E          ;YES-MAKE SURE WE DON'T HAVE TO11 DONE
        ERR16   CORECT,ACTUAL,MASK,<TO11 ERROR WITHOUT BPARER. ACTUAL=STATUS\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+_+
.REM    %
        PROGRAM EXPECTED BOTH BUS PARITY ERROR AND TO11 ERROR BUT ONLY
GOT TO11 ERROR.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;*HERE IF NEITHER ERROR SET

EPAR1D: BIT     #TO11DN,ACTUAL  ;DID WE GET A NORMAL TERMINATION?
        BEQ     EPAR1F          ;NO (VERY STRANGE!)
        ERR16   CORECT,ACTUAL,MASK,<NO PARITY ERROR DETECTED. ACTUAL=STATUS\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM ATTEMPTED TO FORCE AN EBUS PARITY ERROR BY READING A
CLEARED EBUFFER DURING MINOR STATE "TO11 FILE READ".  THIS FAILED AND
TO11 TRANSFER TERMINATED NORMALLY.
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;*HERE IF BOTH ERROS SET

EPAR1E: BIT     #TO11DN,ACTUAL  ;DID TO11 DONE SET (IT SHOULDN'T HAVE)?
        BEQ     EPR1EX          ;NOPE-EVERYTHING'S FINE
        ERR16   CORECT,ACTUAL,MASK,<"ACTUAL" = STATUS REGISTER\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM FORCED AN EBUS PARITY ERROR AND THE STATUS BITS "BPARER"
AND "TO11ER" BOTH SET.  UNFORTUNATELY, SO DID "TO11 DONE".
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;*HERE IF NONE OF THE EXPECTED STATUS BITS SET

EPAR1F: ERR16   CORECT,ACTUAL,MASK,<"ACTUAL" = STATUS REGISTER\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM ATTEMPTED TO SET EBUS PARITY ERROR AND FAILED.  TO11
DONE QLSO REFUSED TO SET.  HMMM!!!!!
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EPR1EX: JMP     NORMAL          ;EXIT TEST

;SEQ286


;*********************************************************************
.REM    %
        EPAR2 MARKS THE BEGINNING OF SERIOUS TESTING OF THE DPS4 PARITY
CHECKING LOGIC.  THE ROUTINE SIMPLY READS THE DPS4 PARITY FLOP AFTER
PERFORMING A CON STATE CLEAR TO MAKE SURE THE FLOP CAN HOLD A ZERO.
%
;******************************************************************

EPAR2:  DIAGRS                  ;DIAGNOSTIC RESET
                                ;(SHOULD ALLOW CON ST CLR)
        CLR     CORECT          ;SET UP FOR COMPARISON
        MOV     @DIAG3,ACTUAL   ;CAPTURE DIAGNOSTIC WORD #3
        BIT     #CAB08,ACTUAL   ;PARITY BIT SET?
        BEQ     EPAR2X          ;NO - (THAT'S GOOD)
        MOV     #^C<CAB08>,MASK ;YES - SET MASK FOR ERROR PRINT
        ERR16   CORECT,ACTUAL,MASK,<"ACTUAL = DIAG WD #3\>

;*-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        DPS4 PARITY FLOP STUCK ON A ONE.  SYNCH YOUR SCOPE ON INT1 MST
CLR (INT1 D-4) AND CHECK:
        1.  DPS4 PARITY         (DPS4 C-4)
        2. DPS6 DATA MIXER FOR UBUS BIT 14      (DPS6 B-7)
%
;*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EPAR2X: JMP     NORMAL          ;RETURN TO TEST DISPATCHER

;SEQ287


;*******************************************************************
.REM    %
        EPAR3 FORCES THE DPS4 PARITY CHECKING NETWORK TO READ SEVEN
ESPECIALLY SELECTED TEST PATTERNS.  THE FIRST TWO PATTERNS (00 AND
153721(8)) HAVE AN EVEN NUMBER OF ONE BITS, THEREFORE THE DPS4
PARITY FLOP SHOULD REMAIN CLEARED.  THE REMAINING FIVE PATTERNS 
(175747(8), 62132(8), 42002(8), 70066(8), AND 102332(8)) ALL CONTAIN
AN ODD NUMBER  OF ONE BITS AND SHOULD SET THE PARITY FLOP.
%
;*-+-+-+-+-+-+***********************************************



EPAR3:  DIAGRS                  ;DIAGNOSTIC RESET
                
        MOV     #14,R3          ;WE'LL USE R3 TO INDEX THRU PATTERN TABLE
EPAR3A: INC     R5              ;NEXT SUBTEST
        MOV     PARTAB(R3),@DEXWD1      ;LOAD A PATTERN FROM THE TABLE
        JSR     PC,LOKDEX       ;LOCK INTERFACE IN DEX MODE
        MOV     #2,@DIAG2       ;FORCE MINOR STATE "DEX WD1"
        DIAGP9                  ;PULSE THE CLOCK (APPLY RAM
                                ;OUTPUTS TO DPS4 PARITY NETWORK)
        CMP     R3,#10          ;PROCESSING FIRST TWO PATTERNS?
        BGT     EPAR3B          ;YES - PARITY BIT SHOULD BE FALSE
        BIT     #CAB08,@DIAG3   ;NO - IS PARITY BIT TRUE?
        BNE     EPAR3C          ;TO EPAR3C IF IT'S OK
        ERRMSG  <\PARITY FLOP RESET WHEN READING >
        MOV     PARTAB(R3),R0   ;GET FAILING WORD
        ERROCT
        ERRMSG  < FROM RAM\>
        FAULT

;*+-+-+-_+-+-+-+-+-+-+-+-+-=-=-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        PROGRAM EXPECTED DPS4 PARITY FLOP TO BE SET WHEN READING THE
PRINTED PATTERN FROM RAM LOCATION DEX WORD #1.  SYNCH YOUR SCOPE ON MINOR
STATE DECODE CNT4 DEX WD1 (CNT4 B5) AND CHECK:
        1.  DPS4 PARITY FLOP                    (DPS4 C-4)
        2.  CNT2 PARITY CLOCK                   (CNT2 A-5)
        3.  DPS4 PARITY GENERATION NETWORK      (DPS4 C-6 & C-7)
%
;+-+-+-=-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;SEQ288

;*HERE IF PARITY IS SUPPOSED TO BE EVEN

EPAR3B: BIT     #CAB08,@DIAG3   ;PARITY BIT SET?
        BEQ     EPAR3C          ;TO EPAR3C IF IT'S OK
        ERRMSG  <\PARITY FLOP SET WHEN READING >
        MOV     PARTAB(R3),R0   ;GET TROUBLEMAKING PATTERN
        ERROCT
        ERRMSG  < FROM RAM\>
        FAULT

;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.REM    %
        DPS4 PARITY FLOP (AS SEEN IN DIAG WORD #3) WAS SET WHEN READING
PRINTED PATTERN FROM RAM LOCATION DEX WORD 1.  SYNCH YOUR SCOPE ON MINOR
STATE DECODE "CNT4 DEX WD1" (CNT4 B-5) AND CHECK:
        1.  DPS4 PARITY FLOP            (DPS4 C-4)
        2.  DPS4 PARITY GENERATION NETWORK      (DPS4 C-6 & C-7)
%
;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-=-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

EPAR3C: TST     -(R3)   ;DECREMENT INDEX REG
        BGE     EPAR3A  ;GO BACK IF MORE PATTERNS
EPAR3X: JMP     NORMAL  ;ALL DONE - EXIT

;*PARTAB IS A TABLE OF PARITY NETWORK TEST PATTERNS

PARTAB: 102332                  ;SUBTEST 1 - ODD PARITY
        70066                   ;SUBTEST 2 - ODD PARITY
        42002                   ;SUBTEST 3 - ODD PARITY
        62132                   ;SUBTEST 4 - ODD PARITY
        175747                  ;SUBTEST 5 - EVEN PARITY
        153721                  ;SUBTEST 6 - EVEN PARITY
        0

.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
Qf&:U