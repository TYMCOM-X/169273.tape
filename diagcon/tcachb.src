;SEQ042

.TITLE  TCACHB  KL10B CACHE RAM BANGER DIAGNOSTIC.  VER 1.0


        .LIST   MC,MD,MEB
        .NLIST  BEX,CND

        $OPSEL=1                ;ALLOW"/COMMANDS" FOR USE BY DIAGNOSTIC
        $MBOX=1         ;FOR MBOX DIAGNOSTICS
        $LOAD=1 
        $MSK36R=1
        DTEASB=1                ;ASSEMBLE DTE20 DEFS
        DTEDEF=1                
        KWASB=1         ;ASSEMBLE CLOCK PARAMETERS
        $DFTBP=1        ;DEFAULT BACKPLANE IS 1 (DMA20/DIA20)
        DEXWDS=.DAT3    
        .ENABL  ABS,AMA
        .=3000
PXCT=   256
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
  .NLIST    SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
  .LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM











































































































































































































































































































































































































.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE















































































































































































































































































































































































.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


        .SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        TTIBRK                  ;GET LAST CHARACTER TYPED
        CMP     R0,#'/          ;SWITCH SPECIFIED?
        BNE     1$              ;NO
        JSR     PC,USERSW       ;YES, GO TO USER SWITCH ROUTINE
1$:     SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        MOV     #DIACOM,COMRET          ;SET COMMAND RETURN
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        CMP     R0,#'/                  ;SLASH?
        BNE     NOPSEL                  ;NO
        JSR     PC,USERSW               ;YES, GO DO USER SWITCH ROUTINE
        BR      DIACOM                  ;BACK TOCOMMAND MODE
NOPSEL: MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM
        .BYTE   'F,'B           ;FB - SET FUNCTION BREAKPOINT
        .BYTE   'F,'C           ;FC - FUNCTION BREAK CONTINUE
        .BYTE   'C,'B           ;CB - CLEAR FUNCTION BREAKPOINT
        .BYTE   'R,'G           ;RG - PRINT FN BREAK REGISTERS
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
        .WORD   FB..
        .WORD   FC..
        .WORD   CB..
        .WORD   RG..

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    </	PROGRAM DEFINED SWITCHES\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
        PMSG    <FP	SET FUNCTION BREAKPOINT\>
        PMSG    <FC	FUNCTION BREAK CONTINUE\>
        PMSG    <CB	CLEAR FUNCTION BREAK\>
        PMSG    <RG	PRINT BREAK REGISTERS\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        JSR     PC,USRHLP       ;PRINT USER HELP INFORMATION
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKPOINTS DURING INITIALIZATION
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKS DURING INITIALIZATION
        JSR     PC,(R3)                 ;DO INITIALIZATION
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
                "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  16-MAR-77
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SUNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN AALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        ESTSIZ=100      ;ERR STACK SIZE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL                  FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FT8             ;16
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTMEM           ;30
        FTT     FTPRM          ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

FT8T:FTM.        <HEDSCT,ENTSCT>

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

FTMEMT:FTM.     <HEDMRQ,ACTMRQ,EXPMRQ>

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACTMRQ:ACMRQ
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
ENTSCT:ENSCT
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXPMRQ:XPMRQ
HEDMRQ:HDMRQ
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ % CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>
        .LIT ERMRQ,<.ASCIZ %         RQ0 RQ1 RQ2 RQ3 RD  WR  SBUS ADR\%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER
.REM    %
        PRINT ACTUAL MEMORY RQ'S AND 22-BIT ADDRESS
        %
ACMRQ:  $PMSG,ERACT             ;PRINT MESSAGE
MRQCOM: JSR     PC,TYPRQS       ;TYPE REQUEST BITS
        MOV     R5,R0   
        ADD     #3,R5           ;SKIP OVER INFO
        PNT22                   ;SBUS ADR IN OCTAL
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER




.REM    %
        
STACK HAS ONE OR MORE ENTRIES TO REPORT SCANOUT ERRORS.
WORD1:DIAG FN,,SIZE ((CHAN OR MBOX TABLE ID)
        NEXT 2 OR 3 BYTES:EXPECTED DATA
        NEXT 2 OR 3 BYTES :ACTUAL DATA
        WHETHER 2 OR 3 BYTES IS DETERMINED BY SIZE AND DIAG FN, WHICH
        ALSO DETERMINES THE E-BUS BIT NUMBER CORRESPONDENCE.
        %

ENSCT:  CLRB    FT8DUN          ;CLR DONE FLAG
1$:     JSR     PC,GNSCT                ;GET ONE ENTRY FROM ERROR STACK

;NOW TEST ALL THE BITS IN THIS ENTRY AND PRINT DIFFERENCES
        JSR     PC,PRDBYT
        TSTB    FT8DUN          ;LAST ENTRY?
        BEQ     1$              ;NO, DO IT AGAIN
        RTS     PC              ;RETURN TO SCANNER



;SET UP AN ENTRY FOR REPORTING
GNSCT:  MOVB    (R5)+,FT8SIZ            ;GET SIZE PARAM
        MOVB    (R5)+,FT8DF             ;GET DIAG FCN
        BPL     2$              ;BR IF NO LAST ENTRY FLAG
        INCB    FT8DUN          ;SET DONE FLAG
        BICB    #200,FT8DF      ;AND CLEAN DF BUFFER
2$:     CLR     R3              ;INIT INDEX
        CMPB    FT8SIZ,#CSIZE   ;CHANNEL?
        BEQ     3$              ;BR IF SO
        INC     R3              ;NEXT INDEX
        CMPB    FT8DF,#163      ;FIND WHICH MBOX GROUP
        BLT     3$              
        INC     R3              ;2-BYTE GROUP
3$:     ASL     R3              ;MAKE WORD INDEX
        ADD     F8SIZT(R3),R5   ;POINT BEYOND EXPECTED
        MOV     R5,R1           ;MAKE EXPECTED PTR
        DEC     R1
        ADD     F8SIZT(R3),R5   ;POINT BEYOND ACTUAL
        MOV     R5,R2           ;MAKE ACTUAL PTR
        DEC     R2
        MOV     F8BITT(R3),F8BTF        ;GET # OF FIRST, LAST BITS
        MOV     F8MSKT(R3),R3   ;GET IRST BIT MASK
        RTS     PC              ;RETURN


;SEQ119

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
        PRINT EXPECTED DATA, MEM RQ AND 22-BIT ADDRESS
        %
XPMRQ:  $PMSG,ERCOR     ;PRINT MESSAGE
        JMP     MRQCOM  ;TYPE BITS, ADDRESS



.REM    %
REPORT MEMORY REQUESTS AND 22-BIT SBUS ADDRESS.
PRINT HEADER LINE
        %
HDMRQ:  $PMSG,ERMRQ     ;PRINT MESSAGE
        RTS     PC



.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


.SBTTL          REPORT SUBROUTINES
;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE MEMORY REQUESTS AND READ/WRITE BITS

TYPRQS: MOV     #6,R2   ;BIT COUNT
        MOVB    (R5)+,R1        ;GET BIT WORD
        SWAB    R1              ;POSITION TO SHF INTO SGN
        PSPACE                  ;SPACE 1
1$:     MOV     #'0,R0          ;ASSUME A ZERO
        TST     R1              ;
        BPL     2$              ;BR IF ZERO
        MOV     #'1,R0          ;ITS A ONE
2$:     PNTCHR
        PSPACE,PSPACE,PSPACE    ;SPACE3
        ROL     R1              ;NEXT BIT
        DEC     R2              ;COUNT
        BGT     1$              ;DO MORE
        RTS     PC


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT         ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=1                        ;DEFAULT BP SET TO 1
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138


.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
LSH=    242
BLT=    251
AOBJN=  253
JRST=   254
XCT=    256
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
JUMPL=  321
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOS=    350
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
IOR=    434
IORI=   435
SETOM=  476
HRLI=   505
HLLZS=  513
HRLZI=  515
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TRZ=    620
TRZN=   626
TRC=    640
TRCE=   642


.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM

.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM


;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.NLIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.LIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        R00=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ.HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36
        .IIF NB,WID,W=WD
.IIF    NDF,TRAPS,      JSR     R4,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        ;WORD 1
        .IIF NE <XXX-1>,                        ;.WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS        TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        S10.    EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG,CLK
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD CLK
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   P5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR,R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
        NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDG,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS       JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN



;SEQ185

.SBTTL  RAM TESTS INIT & TEST DISPATCH 05-0CT-76 EDIT #126  JAB29857

INITAB: I.0                     ;0-ONE TIME INIT
        .WORD   I.1!BIT15       ;1-LOAD CACHE REFILL RAM TEST PRGM
        .WORD   I.2!BIT15       ;2-INIT FOR CACHE BANK 0
        .WORD   I.3!BIT15       ;3-INIT FOR CACHE BANK 1
        .WORD   I.4!BIT15       ;4-INIT FOR CACHE BANK 2
        .WORD   I.5!BIT15       ;5-INIT FOR CACHE BANK 3
        .WORD   I.6!BIT15       ;6-INIT FOR CACHE BANK 0
        .WORD   I.7!BIT15       ;7-INIT FOR CACHE BANK 1
        .WORD   I.8!BIT15       ;8-INIT FOR CACHE BANK 2
        .WORD   I.9!BIT15       ;9-INIT FOR CACHE BANK 3
        .WORD   I.10!BIT15      ;10-INIT FOR CACHE BANK 0 ONLY
        .WORD   I.11!BIT15      ;11-INIT FOR CACHE BANK 1 ONLY
        .WORD   I.12!BIT15      ;12-INIT FOR CACHE BANK 2 ONLY
        .WORD   I.13!BIT15      ;13-INIT FOR CACHE BANK 3 ONLY
        .WORD   I.14            ;124-CLEANUP FOR TEST#10 TO TEST#13
        .WORD   I.15!BIT15      ;15-CACHE BANK 0
        .WORD   I.16!BIT15      ;16-CACHE BANK 1
        .WORD   I.17!BIT15      ;17-CACHE BANK 2
        .WORD   I.18!BIT15      ;18-CACHE BANK 3
        .WORD   I.19!BIT15      ;19-CACHE BANK 0 INIT
        .WORD   I.20!BIT15      ;20-CACHE BANK 1 INIT
        .WORD   I.21!BIT15      ;21-CACHE BANK 2 INIT
        .WORD   I.22!BIT15      ;22-CACHE BANK 3 INIT
        .WORD   ENDPAS          ;23-GENERATION PASS ROUTINE


;SEQ186

TESTAB: .WORD   $NT!BIT15       ;NUMBER OF TESTS
        .WORD   T.1             ;1-REFILL RAM TEST
        .WORD   T.2                     ;2-CACHE DIRECTORY RAM TEST
        .WORD   T.3             ;3-CACHE DIRECTORY RAM TEST
        .WORD   T.4             ;4-CACHE DIRECTORY RAM TEST
        .WORD   T.5             ;5-CACHE DIRECTORY RAM TEST
        .WORD   T.6             ;6-CACHE 0 VALID BIT RAM TEST
        .WORD   T.7             ;7-CACHE 1 VALID BIT RAM TEST
        .WORD   T.8             ;8-CACHE 2 VALID BIT RAM TEST
        .WORD   T.9             ;9-CACHE 3 VALID BIT RAM TEST
        .WORD   T.10            ;10-CACHE WRITTEN BIT RAM TEST
        .WORD   T.11            ;11-CACHE WRITTEN BIT RAM TEST
        .WORD   T.12            ;12-CACHE WRITTEN BIT RAM TEST
        .WORD   T.13            ;13-CACHE WRITTEN BIT RAM TEST
        .WORD   NORMAL          ;14-
        .WORD   T.15            ;15-CACHE DATA RAM TEST
        .WORD   T.16            ;16-CACHE DATA RAM TEST
        .WORD   T.17            ;17-CACHE DATA RAM TEST
        .WORD   T.18            ;18-CACHE DATA RAM TEST
        .WORD   T.19            ;19-CACHE DATA PARITY RAM TEST
        .WORD   T.20            ;20-CACHE DATA PARITY RAM TEST
        .WORD   T.21            ;21-CACHE DATA PARITY RAM TEST
        .WORD   T.22            ;22-CACHE DATA PARITY RAM TEST
        .WORD   0               ;23-NO TEST
$NT=26


;SEQ187

.REM    %
        ONE TIME INIT FOR THE CACHE RAM BANGER DIAGNOSTIC.
        %
I.0:    PFORCE
        JSR     R5,INITM                ;INITIALIZE MSUB ROUTINES
;-----PRINT TITLE IF NOT INHIBITED.
        SWITCH                          ;GET SWITCHES
        BIT     #CHAIN,R0               ;IS CHAIN MODE SWITCH ON?
        BNE     1$                      ;IF YES, SKIP TITLE PRINT
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TCACHB\CACHE RAM BANGER DIAGNOSTIC >

        PNTVER                          ;OUTPUT VERSION.REVLEVEL
        PMSG    <\SWITCHES:>

        SWITCH,PNTOCT
;-----SECTION TO LOAD OR VERIFY EXISTING MICROCODE.
1$:     CLR     R2                      ;ZAP UCODE LOADED SWITCH
2$:     SM                              ;TRY A SM
        BCC     4$                      ;BR IF OK
        TST     R2                      ;ELSE ERR...DID WE LOAD UCODE?
        BEQ     3$                      ;BR IF NO...GO LOAD & RETRY
        ERROR   <\MICROCODE START ERR.>

3$:     MOV     #17$,R0                  ;ELSE LOAD UCODE VIA A PROGRAM CMD
        PRGCMD
        BCS     7$                      ;BR IF CMD NOT SUCCESSFUL
        INC     R2                      ;IND WE .,LOADED UCODE
        BR      2$                      ;GO RETRY UCODE
4$:     XQT     16$                     ;DO APRID INSTR
        BCC     5$                      ;BR IF SUCCESSFUL
        TST     R2                      ;DID WE LOAD UCODE?
        BEQ     3$                              ;NO...GO LOAD IT & RETRY
        ERROR   <\APR ID INSTR ERR.>

5$:     EXAMT,AC17,WD1                  ;GET APRID RESULTS
        BCC     6$                      ;BR IF EXAMINE OK
        TST     R2                      ;ELSE DID WE LOAD UCODE?
        BEQ     3$                      ;NO...GO LOAD IT
        ERROR   <\CAN'T EXAM AC.>


;SEQ188

6$:     BITB    #2,WD1+4                ;DO WE HAVE DIAGNOSTIC MICROCODE?
        BNE     8$                      ;YES... GO USE IT
        TST     R2                      ;DID WE LOAD UCODE?
        BEQ     3$                      ;BR IF NO... GO LOAD IT
7$:     PMSG    <\LOAD> 

        $PMSG,17$+1
        PMSG    < & .HC\>

        PRGHLT
        MOV     #1,R2                   ;MARK UCODE AS LOADED
        BR      2$                      ;GO CHECK UCODE


;SEQ189

;-----SECTION TO MAKE SURE MEMORY IS CONFIGURED AND WORKING.
8$:     TST     IMEMCF          ;CONF SAVED?
        BNE     11$             ;YES....DONT RESAVE IT
        FNDM16  MCBASA          ;FIND MEMORY
        BCS     9$              ;BR IF NONE FOUND IN FIRST 256K
        TST     MCBASA          ;AT 0?
        BEQ     10$             ;YES...OK
9$:     PMSG    <\MEM NOT CONFG OR BAD.  FIX & RETRY.>

        PRGHLT
10$:    SAVMCN                  ;ELSE SAVE IT
        INC     IMEMCF          ; & MARK AS SAVED
;-----SET UP THE CACHE IF PRESENT & DESIRED
11$:    MOV     #-1,CSHFLG      ;TAKE CARE OF THE CACHE SITUATION
        JSR     R5,RSTMBX       ;RESET MBOX, SET CACHE LOOK/LOAD
        DFRDT,170               ;DO WE HAVE CACHE?
        TBIT    30


        BEQ     12$             ;BR IF NO
        SWITCH                  ;WE HAVE CACHE...DOES OPR WANT TO USE?
        BIT     #INHCSH,R0
        BEQ     13$             ;BR IF YES
12$:    CLR     CSHFLG          ;ELSE SHUT OFF CACHE FLAG


;SEQ190

;-----SECTION TO PRINT ALL THE REST OF THE TITLE JUNK.
13$:    SWITCH                  ;GET SWITCHES AGAIN
        BIT     #CHAIN,R0       ;CHAING MODE SET?
        BNE     20$             ;IF YES, DONT PRINT THIS JUNK
        PMSG    <\MICROCODE VERS >

        MOV     WD1+2,R0
        ASR     R0
        ASR     R0
        BIC     #177400,R0
        PNTOCS,PNTCI,", 
        TST     CSHFLG          ;CACHE OR NO CACHE?
        BNE     14$
        PMSG    <NO >

14$:    PMSG    <CACHE, CLOCK RATE >

        CLKPRM
        MOV     (R0),R0
        BIC     #177774,R0
        PNTNBR
        PMSG   <, PROCESSOR ID #>

        MOV     WD1,R0
        BIC     #170000,R0
        PNTDEC,PCRLF
20$:    TST     CSHFLG          ;DO WE HAVE CACHE?
        BNE     15$             ;YES... GO DO THE DIAGNOSTIC
        PMSG    <DIAGNOSTIC ABORTED -- NO CACHE OR INHCSH SW SET\>

        ERREOP
15$:    PNORML
        RTS     PC

16$:    WD36    7000,0000,0017  ;APRID AC17

17$:    .ASCIZ  %P DIAGB,RAM%   ;MODEL B DIAGNOSTIC UCODE
        .EVEN
IMEMCF: 000000                  ;MEM CONF SAVED IF  .NE. 0


;SEQ191

.SBTTL          COMMAND PARSER FOR / TYPE CMDS TO DIAGNOSTIC

.REM    %

THE COMMANDS CURRENTLY RECOGNIZED ARE:

/P              DO A ROUTINE TO AID IN PATCHING THE DIAGNOSTIC.

TERMINATING THE LAST INPUT TO A COMMAND WITH AN ALTMOD (ESCAPE) CAUSES
THE DIAGNOSTIC TO BE STARTD IMMEDIATEELY.
        %
;-----GET THE COMMAND LETTER(S) & GO TO THE CORRECT ROUTINE.
USERSW: TTICHR                  ;GET THE FIRST CHAR
        CMP     R0,#'P          ;PATCH CMD?
        BEQ     2$              ;YES...DO IT
;-----COMMAND NOT RECOGNIZED.
        PMSG    <\?\>           ;SEN ERR MSG

        TTPINI                  ;RESET I/O
        RTS     PC              ;RETURN TO DIACON
;-----SECTION FOR P COMMAND.
$$PATCH=1                       ;FORCE ASSEMBLY OF PATCH SUBROUTINE
2$:     JSR     R5,PATCH        ;CALL PATCHER ROUTINE
        ;BR     FDCB            ;EXIT GRACEFULLY
;-----SECTION TO EXIT TO DIACON OR THE DIAGNOSTIC.
FDCB:   TTBACK                  ;COME HERE AFTER NUMERIC PARAMS
FDC:    TTICHR                  ;HERE AFTER NON-NUMERIC PARAMS
        CMP     R0,#ALTMOD      ;CMD TERMINATED WITH ALTMODE?
        BEQ     1$              ;YES...GO START DIAGNOSTIC
        RTS     PC              ;ELSE JUST RETURN TO DIACON CMD PARSE
1$:     POP     R0              ;DEL RET ADR FROM STK

        JMP     MX..            ;GO START DIAGNOSTIC
;-----HELP COMMAND EXTENSION.
USRHLP: PMSG    <\P  PATCH DIAGNOSTIC\>

        RTS     PC


;SEQ192

.SBTTL          NON CACHE-0 INITS AND CACHE SELECTION SUBROUTINES

;-----CACHE BANK 1 INITIALIZATIONS.
I.3:
I.11:
I.16:
I.20:   RTS     PC              ;SKIP INIT ON LOOPS
        BR      SELC1           ;GOSELFCT CACHE BANK 1
;-----CACHE BANK 2 INITIALIZATIONS.
I.4:
I.12:
I.17:
I.21:   RTS     PC              ;SKIP INIT ON LOOPS
        BR      SELC2           ;GO SELECT CACHE BANK 2
;-----CACHE BANK 3 INITIALIZATIONS.
I.5:    
I.13:
I.18:
I.22:   RTS     PC              ;SKIP INIT ON LOOPS
        BR      SELC3           ;GO SELECT CACHE BANK 3

;-----SUBROUTINE TO SELECT A CACHE BNK DEPENDING ON ENTRY POINT.
        ;ALSO SETS UP THE VARIABLE "CSHNBR".
SELCO:  PUSH    #0              ;SAVE CACHE NUMBER

        BR      SELC            ;GO TO COMMON ROUTINE
SELC1:  PUSH    #1              ;SAVE CACHE NUMBER

        BR      SELC            ;GO TO COMMON ROUTINE
SELC2:  PUSH    #2              ;SAVE CACHE NUMBER

        BR      SELC            ;GO TO COMMON ROUTINE
SELC3:  PUSH    #3              ;SAVE CACHE NUMBER

SELC:   SM                      ;RESET THE MACHINE
        POP     R0              ;GET CACHE BANK #

        MOV     R0,CSHNBR       ;SAVE IT
        CRRONE                  ;CONFIGURE ONE CACHE BANK
        INVAL                   ;CLR THE CACHE, NIT THE USE ALG. RAMS
        RTS     PC              ;RETURN TO CALLER


;SEQ193

.SBTTL          RAM TEST MACROS AND SUBROUTINES

;-----QUICKIE ROUTINES TO GET CONI APR & ERA DATA.
.MACRO  GERA
          JSR   PC,GERA         ;GO TO ROUTINE TO READ ERA DATA TO WD3
.ENDM   GERA

.MACRO  GAPR
          JSR   PC,GAPR         ;GO TO ROUTINE TO READ APR DATA TO WD4
.ENDM   GAPR

GERA:   XQT     RDERA0          ;MOVE ERA TO AC0
        JSR     PC,CHKX         ;MAKE SURE XQT FINISHED
        EXAMT,AC0,WD3           ;NOW MOVE ERA DATA TO WD3
        JMP     CHKED           ;CHK EXAM & RET IF OK

GAPR:   XQT     CIAPR0          ;CONI APR DATA TO AC0
        JSR     PC,CHKX
        EXAMT,AC0,WD4           ;NOW MOVE IT TO WD4
        JMP     CHKED           ;CHK EXAM & RET IF OK


;SEQ194

;-----MACRO & SUBROUTINE TO PRINT (TO THE ERROR STACK) THE CACHE BANK
;       NUMBER.  IF GIVEN (FIRST ARG) THE DEFAULT CACHE BANK
;       (CSHNBR) IS NOT USED.  THE SECOND ARG DETERMINES <CRLF>S:
;       2=LEADING, 0=NONE,
;       1=TRAILING, 3=BOTH.
.MACRO  PCB     C,F
          JSR   R5,PCB          ;GO STACK CACHE BANK INFORMATION
.IIF    B,C,    .BYTE -1,F
.IIF    NB,C,   .BYTE C,F
.ENDM   PCB

PCB:    MOVB    (R5)+,R0        ;GET CACHE NUMBER
        BGE     1$              ;BR IF GIVEN
        MOV     CSHNBR,R0       ;ELSE GET DEFAULT (CURRENT) CACHE #
1$:     PUSH    R0              ;SAVE IT

        MOV     #4$,R0          ;ADR OF MSG
        BITB    #2,(R5)         ;LEADING <CRLF> DESIRED?
        BNE     2$              ;YES...GO PRINT MSG
        INC     R0              ;ELSE BYPASS \
2$:     ERRCOM  PNTAL           ;MSG TO ERR STK
        POP     R0              ;GET BACK CACHE #

        ERRCOM  PNTOCS          ;PRINT IT
        BITB    #1,(R5)+        ;TRAILING <CRLF> DESIRED?
        BEQ     3$              ;NO...DON'T PRINT IT
        ERRCOM  PCRLF
3$:     RTS     R5              ;RETURN TO CALLER
4$:     .ASCIZ  %\CACHE BANK %
        .EVEN
;SEQ195

;-----MACRO AND SUBROUTINE USED TO CALL OUT AN E # ON A BOARD IN A
;       PARTICULAR SLOT.  E# IS PASSED TO THE SUBROUTINE IN R0, THE SLOT
;       NUMBER IS THE ARGUMENT TO THE MACRO CALL.  IF NO SLOT NUMBER IS
;       GIVEN, IT SHOULD BE LOADED IN R1.
.MACRO  CALRAM  SLOTNO
.IF     B,SLOTNO
          JSR   R5,CLRAM2       ;CALL OUT RAM E# IN R0 FOR SLOT # IN R1
        
.IFF
          JSR   R5,CALRAM       ;CALL OUT RAM E# IN R0 FOR...
        .WORD SLOTNO            ; ...SLOT NUMBER SLOTNO
.ENDC
.ENDM   CALRAM
CALRAM: PUSH    R1              ;SAVE R1
        
        MOV     (R5)+,R1        ;GET SLOT #
        BR      CLRAM2+2        ;SKIP PUSH BELOW
CLRAM2: PUSH    R1              ;SAVE SLOT #

        PUSH    R0              ;SAVE E #

        ERRMSG  <\RAM ASSOCIATED WITH FAULT: BACKPLANE 4, SLOT >

        MOV     R1,R0
        ERRCOM  PNTDEC          ;SLOT # TO ERR STK
        ERRMSG  <, E>

        POP     R0              ;GET BACK E#

        ERRCOM  PNTDEC          ;TO ERR STK
        POP     R1              ;RESTORE R1

        RTS     R5              ;RETURN TO CALLER

;SEQ196

;-----MACRO AND SUBROUTINE TO MAKE SURE THE APR FLAGS ARE WHAT THEY
;       SHOULD BE.  IF THEY ARE CONTROL RETURNS TO CALLER.  IF NOT, AN
;       ERROR IS REPORTED WITH OTHER INFORMATION.
.MACRO CHKAPR  XVAL,TSTNAM,FUDGE
          JSR  R5,CHAPR'FUDGE  ;MAKE SURE APR FLAGS ARE CORRECT
        .WORD XVAL,$$CLIT       ;36 BIT XPCTD VALUE PTR, ASCIZ TEST NAME
.NLIST  SRC
$$CLC=.
.=$$CLIT
.ASCIZ  %TSTNAM%        ;NAME OF TEST
$$CLIT=.
.=$$CLC
.LIST   SRC
.ENDM   CHKAPR

CHAPR:  GAPR                    ;GET THE CONI APR WORD
CHAPR2: MOV     (R5)+,1$+2      ;XPCTD PTR TO MASK36 PARAM LIST
        ERRMSG  <\CONI APR DATA:>

        JSR     R5,MASK36
1$:       .WORD ZERO..,000000,WD4       ;MASK,EXPECTED, ACTUAL
        MOV     (R5)+,R0                ;GET TES NAME PTR
        BCS     2$              ;BR IF CARRY SET...APR FLAGS IND ERROR
        SUB     #6,ERSP..       ;ERRMSG NOT NEEDED...DEL FROM ERROR STK
        RTS     R5              ;ELSE RETURN...APR FLAGS OK
2$:     PUSH    R1              ;SAV R1

        MOV     #6$,R1          ;MOVE TEST NAME TO ERROR MESSAGE
3$:     MOVB    (R0)+,(R1)+
        BNE     3$
        TSTB    -(R1)           ;DEL TRAILING 0
        MOV     #7$,R0          ;MOVE " TEST " TO ERR MSG
4$:     MOVB    (R0)+,(R1)+
        BNE     4$
        ERRMSG  <\ERA WORD: >
        GERA                    ;READ THE ERA ALSO
        ERRCOM  PNT36B          ;ERA STUFF TO ERR STK
        MOV     #5$,R0          ;MSG PTR TO PARAM REG
        ERRCOM  PNTAL           ;DUMP WARNING MSG TO ERR STK
        POP     R1              ;GET BACK R1

;SEQ197

        RTS     R5              ;RETURN TO CALLER
5$:     .ASCII  %\UNEXPECTED APR FLAG IN CACHE %
6$:     .BLKB   30.             ;TEST NAME GOES HERE
7$:     .ASCIZ  % TEST\%
        .EVEN
;SEQ 198

;----COMMON DATA AREAS & WORK SPACE.
WD1:    .WORD   0,0,0   ;SCRATCH FOR 36 BIT WORD
WD2:    .WORD   0,0,0   ;SCRATCH FOR 36 BIT WORD
WD3:    .WORD   0,0,0   ;SCRATCH FOR 36 BIT WORD
WD4:    .WORD   0,0,0   ;SCRATCH FOR 36 BIT WORD
ADR1:   .WORD   0,0,0   ;SCRATCH FOR 22 BIT ADDRESS
ADR2:   .WORD   0,0,0   ;SCRATCH FOR 22 BIT ADDRESS
ADR3:   .WORD   0,0,0   ;SCRATCH FOR 22 BIT ADDRESS
ADR4:   .WORD   0,0,0   ;SCRATCH FOR 22 BIT ADDRESS

CIAPR0: IO10    CONI,APR,,0     ;APR DATA TO AC0


RDERA0: IO10    BLKI,PI,0    ;ERA DATA TO ACO


CAMBSD: WD36    0000,0000,0420  ;XPCID VAL:  CONI, APR, MB PAR, SWP DONE


CIASDS:  WD36    0000,0000,0020  ;XPCTD VAL:  CONI APR, SWP DONE


        .EVEN

;SEQ199

.SBTTL          CACHE REFILL RAM TEST

.REM    %
        THIS IS THE CACHE REFILL RAM TEST.  THIS TEST IS DESIGNED TO FIND
BIT INTERFERENCE WITHIN THE REFIL RAMS (E15,E20, & E25 ON THE CHXBOARD).
HARD FAILURE OF THESE RAMS SHOULD BE DETECTED BY DGMCA.
        %

;-----THE INIT FOR THE REFIL RAM TEST SIMPLY LOADS THE AC PROGRAM.
I.1:    RTS     PC              ;NO INIT ON LOOPS
        SM                      ;RESET THE MACHINE

        CRRSTD                  ;THE FOLLOWING IS XOR INITIALIZATION
        INVAL
        LOADAC  ACC0+ACC1+ACC2+ACC3,1$  ;LOAD AC PRGM (ACO-3)
        RUN     AC1             ;RUN PRMSG TO CLR CACHE DATA WDS
        INVAL                           ;XOR INIT DONE

        LOADAC  REFPM,REFPRG    ;LOAD THE AC PROGRAM (ACO-15)
        RTS     PC      

;-----SMALL AC PROGRAM TO CLEAR ALL WORDS OF CACHE.
        BLK10   0
1$:     WD36    0010,0000,1001  ;0--BLT WORD
        I10     SETZM,,,1000    ;1--ZERO TO FIRST WD OF CACHE
        I10     BLT,0,,4777     ;2--CLR REST OF 4 CACHE PAGES
        I10     JRST,4,,3       ;3--HALT
        ENDBLK


;SEQ200

;-----THE REFILL RAM TEST PROGRAM.  THE PATTERN THIS PROGRAM GENERATES
;       IS: 1) ONES TO TEST LINE, ZEROS TO EVERYTHING ELSE.  2) ZEROS TO
;       TEST LINE, ONES TO EVERYTHING ELSE.  3) SELECT NEXT TEST LINE.
;       NOTE: THE PRGM MODIFIES ITSELF TO GET COMPLEMENTARY PATTERNS.
        BLK10   0
REFPRG: I10     HRRI,4,,700000          ;0--<START HERE> RESET WRFIL INSTRUCTIONS
        I10     HRRI,6,,000000          ;1--
        I10     MOVEI,16,,774            ;2--INIT TEST LINE ADDRESS
        I10     MOVEI,17,,774           ;3--INIT NON-TEST LINE ADR
        IO10    WRFIL,,,700000,16       ;4--SEND A PATTERN TO TEST LINE
        I10     CAIE,17,,0,16           ;5--SKIP IF PTG TO TEST LINE..DONT WR IT
        IO10    WRFIL,,,000000,17        ;6--SEND COMPL PTRN TO NON-TEST LINE
        I10     SUBI,17,,3              ;7--
        I10     SOJGE,17,,5             ;10-LOOP IF MORE NON-TEST LINES TO GO
        I10     JRST,4,,12              ;11-STOP SO PDP11 CAN CHK USE RAMS
        I10     TRC,4,,700000           ;12-SET FIRST WRFIL TO OTHER PTRN
        I10     TRCE,6,,700000          ;13-COMPL 2ND WRFIL PTRN, SKIP IF 1 DONE
        I10     SUBI,16,,4              ;14-ELSE MOVE ON TO NXT TEST LINE
        I10     JRST,,,3                ;15-LOOP (PDP11 WILL STOP THIS)
                                        ;16-TEST LINE "ADDRESS"
                                        ;17-SCRATCH "ADDRESS"
ENDBLK  REFPM

;SEQ201

;-----THE CACHE REFILL RAM TEST PROGRAM.  THEORY OF OPERATION IS AS
;       FOLLOWS.  THE PDP11 STARTS THE AC PROGRAM AND WAITS FOR IT TO
;       HALT.  THE AC PROGRAM WRITES A PATTERN INTO THE USE RAMS WHICH
;       HOPEFULLY WILL CAUSE A BAD RAM TO FAIL.  WHEN THE AC PROGRAM
;       HALTS THE 11 PROGRAM RE-EXECUTES THE WRFIL LAST DONE TO THE
;       TEST LINE.  BEFORE THE WR INTO THE RAMS, THE 11 LOOKS TO SEE
;       WHAT THE CURRENT STATE OF THE BITS IS USING DIAG FUNC READS.  IF
;       NOTHING IS WRONG THE 11 JUST CONTINUES THE 10 WHO THEN WRITES
;       THE NEXT PATTERN INTO THE RAMS.  THIS PROCEDURE REPEATS 256
;       TIMES AS REQUIRED BY THE PATTERN BEING USED.
;-----START UP.  LOAD THE LOOP COUNT, RUN THE PROGRAM, SYNCH EVERYTHING
;       UP & RE-EXECUTE THE LAST WRFIL TO THE TEST LINE.
        
T.1:    MOV     #256.,R1                ;MASTER LOOP COUNTER
        RUN     AC0                     ;START THE PROGRAM
1$:     JSR     PC,CHKED                ;MAKE SURE IT HALTED
        STEXCT  8$                      ;EXECUTE THE WRFIL IN AC4
        SOBAC   <116,13.,1>,52          ;APR EN REFILL RAM WR H
        BCC     2$                      ;BR IF SIGNAL FOUND
        ERROR   <"APR EN REFILL RAM WR H" NOT FOUND>

2$:     SOBAC   <171,29.,0>,2           ;CSH EBOX T1 L(JUST BEFORE WRITE)
        BCC     3$                      ;BR IF SIGNAL FOUND
        ERROR   <"CSH EBOX T1 L" NOT FOUND>

;-----NOW DO 3 DIAG FUNC READS (174-172, BIT 21.) TO MAKE SURE THE RAM
;       OUTPUT BITS ARE THE CORRECT FLAVOR, DEPENDING ON THE MASTER LOOP
;       COUNT.
3$:     MOV     #2,R2                   ;LITTLE LOOP COUNT
4$:     MOV     R2,R0                   ;CALC DFRD #
        ADD     #172,R0 
        DFRD                            ;DO IT
        MOV     @.DAT3,R0               ;GET WD W/BIT IN IT
        BIT     #1,R1                   ;CHANGE SENSE OF THINGS?
        BNE     5$                      ;NO
        COM     R0                      ;ELSE COMPLEMENT THE BIT
5$:     BIC     #137777,R0              ;AND ISOLATE IT
        BEQ     6$                      ;BR IF CORRECT
        MOVB    9$(R2),R0               ;GET RAM E #
        CALRAM  28.                     ;CALL OUT RAM ON BD IN SLOT 28.
        FAULT   <CACHE REFILL RAM ERROR>


;SEQ202

6$:     DEC     R2              
        BGE     4$              ;LOOP TIL ALL 3 DFRD S DONE
;-----OK THIS TIME... TRY NEXT PATTERN IF ANY LEFT.
        DFXCTT,STRCLK           ;RESTART THE 10 CLOCK
        DEC     R1      
        BGT     7$              ;BR IF MORE TO DO
        NORMAL                  ;ELSE TEST DONE
7$:     RUN     AC12            ;CONTINUE THE PDP10 AC PRGM FOR NXT PTRN
        BR      1$              ;GO AGAIN

8$:     I10     XCT,,,4         ;DO THE WRFIL ALREADY IN AC4


9$:     .BYTE   15.,20.,25.     ;THE REFILL RAM E NUMBERS
        .EVEN

;SEQ203


.SBTTL          CACHE DIRECTORY RAM VERIFY
.REM    %
        TEST#2 THROUGH TEST#5 ARE THE CACHE DIRECTORY TESTS.  WITH EACH
LINE (4 WORDS) OF THE CACHE IS ASSOCIATED A PAGE NUMBER.  THIS NUMBER IS
HELD IN THE CACHE DIRECTORY RAMS ON THE "CHA" (M8514) BOARD  AND THE RAMS
WHICH HOLD IT ARE THE SUBJECT OF THIS TEST.  NOTE THAT THERE IS ONLY
ONE PAGE NUMBER PER 4 WORDS, THEREFORE, ONLY THE FIRST WORD OF EACH LINE
NEED BE REFERENCED TO EXERCISE THE DIRECTORY.  THERE ARE THREE PARTS TO
THESE TESTS:  INITIALIZATION, FAULT DETECTION, AND FAULT ISOLATION.
        THE INITIALIZATIONS MERELY SELECT WHICH CACHE BANK IS TO BE USED
BY THE TEST.  IN ADDITION TEST#2 INIT LOADS THE AC PROGRAM TO BE USED BY
ALL 4 OF THE TESTS, DOES XOR INIT AND SHUTS OFF MEMORY.
        THE TEST ITSELF IS DONE ALMOST ENTIRELY FROM THE KL AC BLOCKS.
THERE IS A GREAT DEAL OF OVERHEAD INVOLVED WITH THIS.  IN PARTICLAR, 
POINTERS MUST BE MAINTAINED SEPERATELY IN EACH BLOCK, AND CONTROL MUST
BE PASSED FROM ONE BLOCK TO THE NEXT.  AC15-17 PERFORM THIS LATTER FUNCTION
AND ARE NOT PART OF "THE TEST".
        THE ERRORS THAT THIS TEST IS LOOKING FOR ARE CACHE DIRECTORY PARITY
AND NON-EX MEM (NXM).  IF A DIRECTORY BIT IS ALTERED BY THE WRITING OF
ANOTHER BIT IN THE DIRECTORY RAM, THEN A C DIR PAR ERR WILL OCCUR.
IF IT WAS THE HI PAG ADR WHICH WAS MODIFIED, A NXM WILL ALSO OCCUR, AND
THIS WILL LOCK UP THE ERROR ADDRESS REGISTER.  THE NXM OCCURS BECAUSE
THE WORDS IN CACHE WERE WRITTEN.  CHANGING THE ADDRESS WILL CAUSE NO
MATCH, WHICH CAUSES A WRITEBACK TO THE ADDRESS SPECIFIED IN THE DIRECTORY.
THE SAME CAN OCCUR WITH THE LO PAGE WORDS AND A C DIR PAR ERROR
WILL RESULT ALSO.  ONCE THE FAULT ISOLATION ROUTINE HAS THE ERR ADR, IT IS
A SIMPLE MATTER TO TRANSLATE THIS TO THE CHIP NUMBER.
        %

;----INITIALIZATION ROUTINES.  TEST#2 TO TEST#5 TEST CACHE DIRECTORIES
;       IN BANKS 0 TO 3, RESPECTIVELY.
I.2:    RTS  PC                         ;ON LOOPS JUST RETURN TO DIACON
        MOV     #-1,MEMFLG              ;INDICATE MEMORY SHUT6 OFF
        MOV     #-1,EXTFLG              ;SET FORCE-EXTEND FOR MODEL B MACHINE
        SM                              ;RESET THE MACHINE
        ACBLK   1                       ;AC BLOCK TO LOAD
        LOADAC  CDV1PM,CDV1             ;LOAD AC PRGM (AC2-17)
        ACBLK   2                       ;AC BLOCK TO LOAD
        LOADAC  CDV2PM,CDV2             ;LOAD AC PRGM (AC3-17)
        ACBLK   3                       ;AC BLOCK TO LOAD

;SEQ204

        LOADAC  CDV3PM,CDV3             ;LOAD AC PRGM (AC6-17)
        ACBLK   4                       ;AC BLOCK TO LOAD
        LOADAC  CDV4PM,CDV4             ;LOAD AC PRGM (AC3-17)
        JMP     SELCO                   ;GO TURN ON CACHE BANK 0


;SEQ205

;-----CACHE DIRECTORY VERIFICATION PROGRAM, AC BLOCK 1
;       INITIAL STARTING PC=6.  INVALIDATE ALL PAGES IN CACHE.
;       CLEAR APR FLAGS.  MOVE ZEROS TO THE "HIGH PAGE" IN CACHE.
;       NOTE HERE THAT THERE ARE TWO ADDRESS PATTERNS IN USE:  THE HIGH PAGE
;       ADDRESS AND THE LOW PAGE ADDRESS.  REMEMBER THAT WE ARE TESTING
;       THE ABILITY OF THE CACHE TO HOLD ADDRESSES.  THE HI & LO
;       ADDRESSES ARE COMPLEMENTARY PATTERNS.  THE HI PAGE ADR IS WRITTEN
;       TO THE "TEST LINE" AND THE LO PAG ADR IS WRITTEN TO ALL THE
;       OTHERS.  CONTINUING:  NOW READ BACK THE HI PAG WD TO MAKE SURE
;       THAT THE VALID BIT IS SET.  IF IT WAS NOT, THE RESULTANT READ
;       WILL CAUSE A NXM.
CDV1:   BLK10   2                       ;0--RESERVED FOR PDP11
                                        ;1--HIGH PAGE TEST LINE ADDRESS
        I10     SETZM,,,0,1             ;2--WRITES WD TO HI PAG TST LINE
        I10     SKIP,,,0,1              ;3--READS BACK THAT WD
        I10     TRNN,1,,777             ;4--SKIP IF NOT ALL CACHE LINES TESTED
        I10     JRST,4,,,0              ;5--ELSE HALT...NO ERRS DETECTED
        IO10    SWPIA,,,0               ;6--<START HERE>SWPIA... INVAL ALL CACHE
        IO10    CONSZ,APR,,200000       ;7--SKIP IF SWPIA NOT BUSY
        I10     JRST,,,7                ;10-ELSE LOOP
        IO10    CONO,APR,,27700         ;11-CLR ANY ERRS WHICH MAY BE AROUND
        I10     XCT,,,2                 ;12-DO SETZM
        I10     XCT,,,3                 ;13-DO SKIP
        I10     ADDI,1,,4               ;14-ADDR OF TST LINE FOR NXT TIME
        IO10    DATAO,PAG,,17           ;15-GO TO NXT AC BLK
        I10     JRST,,,4                ;16-GO START UP THIS AC BLOCK
        WD36    4021,0000,0000          ;17-WD FOR DATAO,PAG
        ENDBLK  CDV1PM


;-----CACHE DIRECTORY VERIFICATION PROGRAM.  AC BLOCK2
;       MAKE SURE THERE WAS NO ERROR FROM READING BACK THE HI PAG WD.
;       NOW GO INTO A LOOP WHICH WILL WRITE LO PAGE WORDS TO ALL CACHE
;       LINES EXCEPT THE TEST LINE.
CDV2:   BLK10   3                       ;0--RESERVED FOR PDP11
                                        ;1--LOW PAGE TEST LINE ADDRESS
                                        ;2--SCRATCH
        IO10    CONSZ,APR,,7700         ;3--SKIP ON NO ERRORS
        I10     JRST,4,,1               ;4--ELSE HALT...VALID BIT PROBLEM
        I10     HRRZI,2,,0,1            ;5--INIT SCRATCH REG
        I10     TRZ,2,,777              ;6--
        I10     CAIE,2,,0,1             ;7--SKIP WRTG TO TST LIN
        I10     SETZM,,,0,2             ;10--ELSE SET ZERO TO LO PG WD
        I10     ADDI,2,,4               ;11-PT TO NXT ONE
        I10     TRNE,2,,777             ;12-SKIP IF LOOP DONE
        I10     JRST,,,7                ;13-ELSE CONTINUE TIL DONE
        I10     ADDI,1,,4               ;14-ADDR OF TST LINE FOR NXT TIME
        IO10    DATAO,PAG,,17           ;15-GO TO NXT AC BLK
        I10     JRST,,,3                ;16-GO START UP THIS AC BLOCK
        WD36    4032,0000,0000          ;17-WD FOR DATAO,PAG
        ENDBLK  CDV2PM

;SEQ206

;-----CACHE DIRECTORY VERIFICATION PROGRAM, AC BLOCK 3
;       READ THE TEST LINE AGAIN.  IF THE ADDRESS IN THE C DIR TEST LINE
;       WAS MODIFIED, THEN NO MATCH WILL OCCUR, AND A MEMORY REFERENCE
;       WILL OCCUR CAUSING A NXM.  CHECK FOR THAT NXM.  IF OK, WRITE THE
;       TEST LINE WORD AGAIN.
CDV3:   BLK10   6                       ;0--RESERVED FOR PDP11
                                        ;1--HIGH PAGE TEST LINE ADDRESS
                                        ;2--
                                        ;3--
                                        ;4--
                                        ;5--
        I10     SKIP,,,0,1              ;6--READS TST LIN WD FROM HI PAG
        I10     SETZM,,,0,1             ;7--WRITES A ZERO TO SAME
        I10     XCT,,,6                 ;10-READ HI PG TST LIN WD
        IO10    CONSZ,APR,,7700         ;11-SKIP ON NO ERRORS
        I10     JRST,4,,2               ;12-ELSE ERR HALT...DIR BIT WIPED
        I10     XCT,,,7                 ;13-WR HI PG WD AGAIN TO TRY WIPEOUT
        I10     ADDI,1,,4               ;14-ADDR OF TST LINE FOR NXT TIME
        IO10    DATAO,PAG,,17           ;15-GO TO NXT AC BLK
        I10     JRST,,,10               ;16-GO START UP THIS AC BLOCK
        WD36    4043,0000,0000          ;17-WD FOR DATAO,PAG
        ENDBLK  CDV3PM


;-----CACHE DIRECTORY VERIFICATION PROGRAM, AC BLOCK 4
;       DO A LOOP WHICH READS BACK ALL BUT THE TEST LINE.  IF ANY OF
;       THESE HAVE BEEN MODIFIED AN ERROR WILL OCCUR.  CHECK FOR THAT
;       ERROR.  IF NO ERRORS, GO BACK TO AC BLOCK 1 AND TRY THE NEXT
;       TEST LINE.  REPEAT UNTIL ALL LINES OF CACHE HAVE BEEN TESTED.
CDV4:   BLK10   3                       ;0--RESERVED FOR PDP11
                                        ;1--LOW PAGE TEST LINE ADDRESS
                                        ;2--SCRATCH
        I10     HRRZI,2,,0,1            ;3--INIT SCRATCH REG
        I10     TRZ,2,,777              ;4--
        I10     CAIE,2,,0,1             ;5--SKIP IF WE'VE COME TO TST LIN
        I10     SKIP,,,0,2              ;6--ELSE RD WD TO SEE IF DIR CLOBBERED
        IO10    CONSZ,APR,,7700         ;7--SKIP ON NO ERRORS
        I10     JRST,4,,3               ;10-ELSE ERR HALT... DIR BIT WIPED.
        I10     ADDI,2,,4               ;11-PT TO NXT WD
        I10     TRNE,2,,777              ;12-SKIP ALL WDS DONE
        I10     JRST,,,5                ;13-ELSE LOOP TIL THEY ARE
        I10     ADDI,1,,4               ;14-ADDR OF TST LINE FOR NXT TIME
        IO10    DATAO,PAG,,17           ;15-GO TO NXT AC BLK
        I10     JRST,,,3                ;16-GO START UP THIS AC BLOCK
        WD36    4014,0000,0000          ;17-WD FOR DATAO,PAG
        ENDBLK  CDV4PM


;SEQ207

;-----THE CACHE DIRECTORY RAM VERIFICATION TEST.  THE FIRST SECTION OF
;       THIS TEST GETS THE ADDRESSES, LOADS THEM INTO THE AC PROGRAM,
;       AND RUNS THE AC PROGRAM.
T.2:
T.3:
T.4:
T.5:    MOV     #CDVPAT,R2              ;ADDRESS PATTERN POINTER
1$:     MOV     (R2)+,R0                ;GET + FORMAT HI PG ADR
        ASL     R0
        MOV     R0,CDVHA+1
        MOV     (R2)+,R0                ;GET & FORMAT UP LO PG ADR
        ASL     R0
        MOV     R0,CDVLA+1
        MEMRST                          ;RESET MACHINE CACHE ON, MEMORY OFF
        DFXCTT,STRCLK                    ;CLOCK ON
        ACBLK   4                       ;AC BLOCK TO USE
        DPOST,AC1,CDVLA                 ;LOAD INIT ADR
        JSR     PC,CHKED
        ACBLK   3                       ;AC BLOCK TO USE
        DPOST,AC1,CDVHA                 ;LOAD INIT ADR
        JSR     PC,CHKED
        ACBLK   2                       ;AC BLOCK TO USE
        DPOST,AC1,CDVLA                 ;LOAD INIT ADR
        JSR     PC,CHKED
        ACBLK   1                       ;AC BLOCK TO USE
        DPOST,AC1,CDVHA                 ;LOAD INIT ADR

        JSR     PC,CHKED
        INSYNC                          ;XXXXXSUBTESTS 1 & 2XXXXX
        RUNBIG  AC6,5
        JSR     PC,CHKP
;-----AC PROGRAM HAS BEEN RUN.  CHECK FOR FAULT & FIGURE OUT WHAT'S
;       GOING ON IF ERR, ELSE JUST CONTINUE TEST OR NORMAL.    
        DFPC                            ;GET KL PGRM CNTR
        JSR     PC,CHKED
        CMP     (R0),#1                 ;PC= 0, 1, OR (2,3)?
        BLT     2$                      ;0...PROGRAM HALTED NORMALLY
        BGT     3$                      ;2 OR 3...CONI APR DETECTED ERROR
        PCB                             ;PRINT CURRENT CACHE BANK
        ERROR   <UNEXPECTED CACHE VALID BIT (WD0) PROBLEM: CACHE DIR TEST>

;SEQ208



2$:     CMP     R5,#1           ;SUBTEST 1 OR 2
        BEQ     1$              ;ONE...GO DO 2
        NORMAL                  ;ELSE ALL DONE... NORMAL HAL
3$:     GAPR                    ;CONI APR WD TO WD4
        ERRMSG  <CONI APR DATA:>

        MSKDAT  CIASDS          ;MASK DATA TO ERR STK
        BIT     #2200,WD4       ;NXM OR CACHE DIR ERR FOUND?
        BNE     CDVICC          ;YES...EXPECTED ERR TYPE
        PCB                     ;PRINT CURRENT CACHE BANK
        ERROR   <UNEXPECTED ERROR TYPE DURING CACHE DIRECTORY TEST.>


;SEQ209

;-----SECTION  TO FIGURE OUT WHICH RAM IC MAY HAVE BEEN INVOLVED WITH
;       THE DETECTED FAILURE.
CDVICC: GERA                    ;ERA WORD TO WD3
        MOV     WD3+2,R1        ;GET & FMT ERA PG #
        BIC     #177600,R1      
        SWAB    R1
        BISB    WD3+1,R1
        ASR     R1              ;ERA PG # NOW IN R1
        BIT     #2000,WD4       ;WAS NXM FOUND?
        BNE     1$              ;YES...PROBABLE CACHE DIR BIT ERR
        ERRMSG  <\CACHE DIRECTORY PARITY BIT ERROR.>
        MOV     CSHNBR,R4
        MOVB    CDPREN(R4),R0   ;E # NOW IN R0
        CALRAM  27.             ;DUMP SLOT # & E #
        BR      CDVFLT
1$:     MOV     #ADR4,R3        ;SCRATCH-STACK POINTER
        JSR     PC,CDVNE        ;CALC # ERR BITS FOR LO PAG #
        JSR     PC,CDVNE        ;CALC # ERR BITS FOR HI PG #
        CMP     (R2)+,(R2)+     ;REPAIR PG # PTR
        CMP     (R3),6(R3)      ;WHICH HAS FEWER DIFS?
        BLT     2$              ;BR IF HI PG # HAS FEWER DIFS...USE IT
        ADD     #6,R3           ;ELSE POP HI PG STUFF OFF STK..USE LO PG
2$:     TST     (R3)+           ;DEL ERR CNT FROM STK
        BGT     3$              ;BR IF THERE ARE DIFFERENCES
        ERRMSG <FAILING BD IS PROBABLY "CHA", BACKPLANE 4, SLOT 27, E?>

 
        BR      CDVFLT          ;GO TYPE REST OF JUNK
3$:     MOV     (R3)+,R2        ;DIFS WD TO R2
        ASL     (R3)            ;EDIT XPCTD PG # FOR INSERTION INTO ADR
        MOV     (R3)+,WD4+2     ;MAK 36 BIT ADR FOR ERR INFO
        ERRMSG  <\ERA DATA:>

        MASK36  WD4+1,WD2,PGNMSK        ;ERA DATA TO ERR STK
;-----LOOP TO PRINT OUT RAMS ASSCIATED WITH ERROR BITS
        CLR     R3              ;BIT NUMBER INIT
4$:     BIT     #1,R2           ;DID THIS BIT FAIL?
        BEQ     5$              ;BR IF NO...JUST GO LOOK AT NXT ONE


;SEQ210

        MOV     R3,R4           ;CALC E#
        ASL     R4
        ASL     R4
        ADD     CSHNBR,R4
        MOVB    CDREN(R4),R0    ;E # TO R0
        CALRAM  27.             ;DUMP SLOT & E #
5$:     INC     R3              ;BUMP BIT #
        ASR     R2      
        BNE     4$              ;LOOP IF MORE ERR BITS


;SEQ211

;-----SECTION TO PRINT OUT CACHE BANK NUMBER & ERR MSG
CDVFLT: PCB     ,2              ;PRINT CURRENT CACHE # W/ LEADING CRLF
        FAULT   <CACHE DIRECTORY ERROR.  POSSIBLE DIRECTORY RAM FAULT.>

;-----LOCAL SUBROUTINE TO COUNT BIT DIFFERENCES.  LEAVES THE EXPECTED
;       PAGE #, THE DIFFERENCE BITS WORD, AND THE DIFFERENCE BIT COUNT
;       ON THE TOP-OF-STACK.
CDVNE: MOV     -(R2),R0        ;GET XPCTD PG #
        MOV     R0,-(R3)        ;SAV ON STK
        EXOR    R1,R0           ;GET DIFS FROM ERA PG # (R1)
        MOV     R0,-(R3)        ;SAVE THAT TOO
        CLR     -(R3)           ;INIT DIFS CNT ON STK
1$:     BIT     #1,R0           ;IS THERE A DIF IN THIS BIT?
        BEQ     2$              ;BR IF NO
        INC     (R3)            ;ELSE INC DIFFERENCE COUNT
2$:     ASR     R0              ;NOW SHIFT TO LOOK AT NXT BIT
        BNE     1$              ;BR IF MORE TO DO
        RTS     PC              ;ELSE DONE... RETURN


;-----DATA SECTIONS AND WORK AREAS.

;CACHE DIRECTORY RAM E NUMBERS.  BIT 26, CACHE 0 (E55) IS FIRST, THEN
;BIT 26, CACHE 1 (E60), ALL THE WAY DOWN TO BIT 14, CACHE 3 (E46).
CDREN:  .BYTE   55.,60.,65.,70.,79.,78.,87.,76.,74.,73.,82.,71.
        .BYTE   84.,83.,77.,81.,89.,88.,72.,86.,69.,68.,67.,66.
        .BYTE   64.,63.,62.,61.,54.,53.,52.,56.,59.,58.,57.,51.
        .BYTE   44.,43.,37.,36.,34.,33.,32.,31.,39.,38.,42.,41.
        .BYTE   49.,48.,47.,46.

;CACHE DIRECTORY RAM PARITY BIT E NUMBERS:  CACHE 0 TO CACHE 3.
CDPREN: .BYTE   75.,80.,85.,90.

;MASKS, SCRATCH WORDS, EXPECTED VALURES, ETC.
PGNMSK: WD36    7777,6000,0777  ;MASK TO USE PAGE NUMBER ONL

                
        .ODD
CDVHA:  WD36    0000,1777,7000  ;HIGH PAG ADR (AS OPPOSED TO PAG #)



        .ODD
CDVLA:  WD36    0000,0017,7000  ;LO PAG ADR


        .EVEN

;SEQ212

;PAGE NUMBERS FOR SUBTEST 1 & 2.
CDVPAT: .WORD   17607,170
        .WORD   17770,7


;SEQ213

.SBTTL          CACHE VALID BIT RAM TEST

.REM    %
        TEST#6 THROUGH TEST#9 ARE THE CACHE VALID BIT RAM TESTS.  EACH
WORD OF THE CACHE HAS A BIT ASSOCIATED WITH IT WHICH INDICATES WHETHER
THE WORD CONTAINS VALID DATA OR GARBAGE.  THE RAMS WHICH HOLD THESE BITS
ARE THE SUBJECT OF THIS TEST.  THE RAMS ARE LOCATED ON THE CHX BOARD.  AS
IN THE OTHER TESTS IN THIS DIAGNOSTIC, MOST OF THE TESTING IS DONE BY
THE MULTI-BLOCK AC PROGRAM, WITH THE PDP-11 JUST PROVIDING SUPPORT.  
BASICALLY SPEAKING THE TEST WORKS AS FOLLOWS:  ALL THE VALID BITS ARE CLEARED
BY AN INVALIDATING SWEEP.  A TEST BIT IS CHOSEN.  ALL OTHER VAL BITS IN
THE RAM ARE SET BY WRITING TO THE OTHER CACHE LOCATIONS.  THE TEST
LOCATION IS THEN READ.  IF A CORE READ WAS DONE, EVERYTHING IS OK.  THE TEST
LOCATION VALID BIT IS NOW SET.  ALL OTHER LOCATIONS ARE NOW INVALIDATED
AND ANOTHER READ IS DONE TO THE TEST LOCATION.  IF THE TEST VAL BIT IS
STILL SET NO MEM READ IS DONE AND ALL IS WELL.  THE NEXT LOCATION IS
NOW SELECTED AND THE PROCESS REPEATED UNTIL ALL BITS OF THE SELECTED
CACHE HAVE BEEN TESTED.
        NOTE THAT OTHER STRANGE THINGS ARE GOING ON DURING THE TEST:
PAGE 1 OF PHYSICAL MEMORY IS FILLED WITH BAD PARITY WORDS.  THIS ENABLES
THE TEST TO FIND OUT IF A MEM READ HAS BEEN DONE VIA THE PRESENCE OR ABSENCE
OF AN MB PARITY ERROR (NO READ = NO PAR ERR).  ALSO, EFFORTS ARE
MADE TO MAKE SURE THAT THE DIRECTORY WORDS ARE OF KNOWN VALUES SO THAT
VALID BIT ERRORS CAN BE PROPERLY DETECTED.  THIS IS NECESSARY BECAUSE
OF THE INTERLOCKING NATURE OF THE VALID BITS AND THE DIRECTORY.
        NOTE FURTHER THAT DUE TO SPACE RESTRICTIONS THE AC PROGRAM IN
BLOCK ZERO IS RUN SEPARATELY FROM THE REST OF THE PROGRAM.  THIS IS OF
NO CONSEQUENCE TO YOU.
        SEE THE INDIVIDUAL AC PROGRAM BLOCKS FOR A MORE DETAILED 
DESCRIPTION OF WHAT IS GOING ON.
        %


;
;SEQ214

;-----THE VALID BIT TEST INITIALIZATIONS MEARLY SELECT WHICH CACHE BANK
;       IS TO BE USED.  IN ADDITION, CACHE 0 INIT TURNS MEMORY BACK ON
;       AND LOADS THE AC PROGRAM USED BY THE TEST.
I.6:    RTS     PC              ;SKIP INIT ON LOOPS
        CLR     EXTFLG          ;RESET FORCE-EXTEND FLAG
        SM                      ;RESET THE MACHINE
        CMEMEN                  ;TURN MEMORY BACK ON...WE NNED IT NOW
        LOADAC  CVB0PM,CVBP0    ;LOAD AC0-17, AC BLOCK 0
        ACBLK   1               ;SELECT AC BLOCK 1
        LOADAC  CVB1PM,CVBP1    ;LOAD AC4-17
        ACBLK   2               ;SELECT AC BLOCK 2
        LOADAC  CVB2PM,CVBP2    ;LOAD AC4-17
        ACBLK   3               ;SELECT AC BLOCK 3        
        LOADAC  CVB3PM,CVBP3    ;LOAD AC5-17
        ACBLK   4               ;SELECT AC BLOCK 4
        LOADAC  CVB4PM,CVBP4    ;LOAD AC3-17
        ACBLK   5               ;SELECT AC BLOCK 5
        LOADAC  CVB5PM,CVBP5    ;LOAD AC3-17
        MOV     #0,CSHNBR       ;CACHE NUMBER
I.7:    RTS     PC
        MOV     #1,CSHNBR               ;CACHE 1
I.8:    RTS     PC
        MOV     #2,CSHNBR       ;CACHE 2
I.9:    RTS     PC
        MOV     #3,CSHNBR       ;CACHE 3
        RTS     PC


;SEQ215

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 0.  THIS BLOCK IS RUN
;       SEPARATELY FROM THE OTHERS DUE TO SPACE RESTRICTIONS.  ITS PUR-
;       POSE IS TO PLACE KNOWN PAGE NUMBERS IN THE DIRECTORS OF THE
;       3 CACHES NOT CURRENTLY BEING TESTED SO THAT THERE IS NO WAY THAT
;       THERE CAN BE ANY INTER-CACHE INTERFERENCE.  IT ALSO SETS UP THE
;       REFILL RAMS SO THAT THE TEST CACHE CAN BE TESTED.
        .ODD
        BLK10   0
CVBP0:  I10     SETZM,,,775000  ;0--SET PAG # IN CACHE DIR WD
        I10     ADDI,0,,4       ;1--GO TO NXT LINE IN CURRENT CACHE BANK
        I10     TRNE,00,,774    ;2--SKIP IF DONE WITH CUR CACHE
        I10     JRST,,,0        ;3--ELSE GO BACK & DO NXT LINE
        I10     ADDI,6,,100000   ;4--<START HERE>SELECT NXT CACHE BANK
        I10     TRZ,6,,477777   ;5--FORCE WRAP-AROUND FROM CACHE 3 TO GO
CVBP0N: IO10    WRFIL,,,000000  ;6--(WRFIL) LOAD REFILL RAM WD
        I10     ADDI,6,,4       ;7--PT TO NXT REFILL RAM WD
        I10     TRNE,6,,774     ;10-SKIP IF REFILL RAM FULL...DONE
        I10     JRST,,,6        ;11-ELSE LOOP TIL RAM FULL
        IO10    SWPIA,,,0       ;12-INVAL ALL CACHE
        IO10    CONSZ,APR,,200000       ;13-SKIP IF SWEEP NOT BUSY  (DONE)
        I10     JRST,,,13       ;14-ELSE LOOP TIL IT ISNT
        I10     TLNE,0,,1       ;15-SKIP IF NOT ALL CACHES INITD
        I10     JRST,4,,16      ;16-HALT WHEN DONE...CACHE DIR INIT'D
        I10     JRST,,,0        ;17-GO BACK & INIT NXT CACHE
        ENDBLK  CVB0PM

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 1.  THIS AC BLOCK IS USED
;       ONLY ONCE DURING THE TEST.  FIRST IT MAKES SURE THAT THE DIRECTORY
;       WORD OF CACHE LINE 0 OF THE SELECTED CACHE POINTS TO PAGE 1
;       SO THAT IF A VALID BIT POPS UP A "VALID MATCH" WILL OCCUR LEADING
;       TO A DETECTABLE ERROR.  IT THEN SHUTS THE CACHE OFF AND
;       FILLS CORE PAGE 1 WITH BAD PARITY WORDS SO THAT DATA MOVEMENT
;       CAN BE EASILY MONITORED.
CVBP1:  BLK10   4               ;0--SCRATCH USE ONLY
                                ;1--INDEX/COUNTER
                                ;2--
                                ;3--
        I10     SETZM,,,1000    ;4--<START HERE>INIT DIR WORD FOR LINE 0
        IO10    SWPIA,,,0       ;5--INVALIDATE ALL CACHE
        IO10    CONO,PAG,,0     ;6--TURN OFF CACHE SO WE CAN WR TO MEM
        I10     MOVEI,1,,777    ;7--INIT INDEX
        IO10    CONO,PI,,200000 ;10-FORCE WR BAD DATA PARITY
        I10     SETZM,,,1000,1  ;11-WR 0 WITH BAD PAR TO MEM
        I10     SOJGE,1,,11     ;12-LOOP UNTIL PG 1 FULL OF BAD STUFF
        IO10    CONO,PI,,0      ;13-RESET FRC-BAD-DATA-PAR
        IO10    CONO,APR,,27700  ;14-CLEAR ANY ERRORS HANGING AROUND
        IO10    DATAO,PAG,,17   ;15-GO TO AC16 IN NXT AC BLK
        I10     JRST,,,4        ;16-GO DO THIS AC BLK
        WD36    4021,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CVB1PM


;SEQ216

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 2.  THIS AC BLOCK IS ALSO
;       RUN JUST ONCE FOR EACH TEST.  IT TURNS THE CACHE BACK ON AND
;       THEN MOVES A ZERO INTO AC1 OF BLOCKS 3 TO 5.  THIS RE-INITIALI-
;       ZATION MEANS THAT THE ACS DON'T HAVE TO BE RELOADED EACH TIME
;       THE TEST IS RUN, WHICH IS A GREAT SAVINGS IN OVERHEAD.
CVBP2:  BLK10   4               ;0--SCRATCH USE ONLY
                                ;1--
                                ;2--
                                ;3--
        WD36    0001,0000,0000  ;4--PREV AC BLK DECREMENTER
        I10     SETZM,,,1       ;5--MOVES INIT WD ADR TO PREV AC BLK
        IO10    CONO,PAG,,600000        ;6--TURN ON THE CACHE
        I10     HRLZI,0,,402500 ;7--INIT PREV AC BLK #
        IO10    DATAO,PAG,,0    ;10-SET PREV AC BLK # TO HARDWARE
        I10     PXCT,4,,5       ;11-XCT AC5 (MOVEM) IN PREV BLK MODE
        I10     SUB,0,,4        ;12-GET NXT AC BLK 3
        I10     TLNE,0,,600     ;13-SKIP IF BLKS 5 TO 2 DONE
        I10     JRST,,,10       ;14-ELSE LP TIL DONE
        IO10    DATAO,PAG,,17   ;15-GO TO AC16 INNXT AC BLK
        I10     JRST,,,6        ;16-GO DO THIS AC BLK
        WD36    4032,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CVB2PM

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 3.  THIS IS THE FIRST AC
;       BLOCK OF THE MAIN LOOP OF THE TEST.  THIS PART OF THE PROGRAM
;       WRITES TO EVERY 4TH WORD OF THE CACHE EXCEPT THE TEST WORD (WHOSE
        
;       NUMBER IS IN AC1).  THIS MEANS THAT ALL THE VALID BITS OF THE
;       SELECTED RAM (BY ADR 34 &35 AND CACHE #) EXCEPT THE TEST WORD
;       BIT WILL BE SET.  INTERFERENCE HERE WILL CAUSE THE VAL BIT TO BE
;       SET ERRONEOUSLY.  SUCH AN ERROR IS DETECTED IN THE NEXT BLOCK.
CVBP3:  BLK10   5               ;0--SCRATCH USE ONLY
                                ;1--TEST WORD RELATIVE ADDRESS
                                ;2--SCRATCH ADR REG
                                ;3--
                                ;4--
        I10     MOVEI,2,,0,1    ;5--CREATE AOBJN WORD IN AC2
        I10     ANDI,2,,3       ;6--ISOLATE TEST WD NUMBER (0,1,2, OR 3)
        I10     HRLI,2,,777600  ;7--SET LOOP CNT FOR WR NON-TST WORDS
        I10     CAIE,1,,0,2     ;10-SKIP IF POINTING TO TST WORD
        I10     SETZM,,,3000,2  ;11-SET VALID BIT OF NON-TEST EVEN WD
        I10     ADDI,2,,3       ;12-ADJ TEMP ADR WD
        I10     AOBJN,2,,10     ;13-LOOP UNTIL ALL NON-TEST WDS DONE
        I10     ADDI,1,,1       ;14-UPDATE TEST WORD REL ADR
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,5        ;16-GO TO FIRST INSTR OF THIS BLOCK
        WD36    4043,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK CVB3PM


;SEQ217

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 4.  WAIT FOR NOT SWEEP-BUSY.
;       NOW READ THE TEST WORD FROM PAGE 1.  IF THE VAL BIT WAS ERRONE-
;       OUSLY SET NO MEM READ WILL BE DONE.
;       THIS IS DETECTED BY LACK OF A PARITY ERROR.  IF THE PAR ERROR OCCURS, OK.
;       NOW SWEEP THE NON-TEST WORDS (WHICH WERE WRITTEN TO PAGE 3
;       ORIGINALLY) CAUSING ALL NON-TEST VAL BITS TO BE CLEARED.  WAIT
;       FOR SWEEP NOT BUSY.
CVBP4:  BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--TEST WORD RELATIVE ADDRESS
                                ;2--
        IO10    CONSZ,APR,,200000       ;3--SKIP IF SWEEP NOT  BUSY (IE DONE)
        I10     JRST,,,3        ;4--ELSE LOOP UNTIL IT ISN'T
        I10     SKIP,,,1000,1   ;5--RD TST WD....DOES MEM RD IF VAL CLR
        IO10    CONSO,APR,,400  ;6--SKIP IF MB PAR ERR...MEM RD DONE.. OK
        I10     JRST,4,,1       ;7--NO ERR...NO MEM RD DONE...ERROR
        I10     SETZM,,,1000,1  ;10-"MOVE" TST-WORD TO PG 1 NOW
        IO10    SWPIO,,,3       ;11-NOW INVAL PG 3 (ALL NON-TST WORDS)
        I10     ADDI,1,,1       ;12-UPDATE TEST WORD RE ADR
        IO10    CONSZ,APR,,200000       ;13-SKIP IF SWEEP NOT BUSY (IE DONE)
        I10     JRST,,,13       ;14-ELSE LOOP UNTIL IT ISN'T
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO TO FIRST INSTR OF THIS BLOCK
        WD36    4054,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CVB4PM

;-----CACHE VALID BIT TEST PROGRAM, AC BLOCK 5.  CLEAR ANY ERRORS AND
;       RE-READ THE TEST WORD.  THE VALID BIT SHOULD STILL BE SET SO
;       NO MEM READ SHOULD BE DONE.  IF THE VAL BIT WAS CLEARED, THE
;       READ WILL CAUSE AN MB PAR ERR WHICH WILL HALT THE PROGRAM WITH
;       AN ERROR CODE.  IF THERE IS NO ERROR, AND ALL BITS HAVE BEEN
;       TESTED, HALT.  ELSE, IN WD 0 OF  LINE IS NEXT TO BE TESTED,
;       MAKE SURE THAT THE DIR ENTRY FOR THAT LINE HAS PAGE 1 IN IT.
;       NOW INVALIDATE ALL CACHE LOCATIONS WHICH POINT TO PAGE 1.  CACHE
;       IS COMPLETELY INVALID.  GO BACK TO BLK 3 & TEST NEXT VAL BIT.
CVBP5:  BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--TEST WORD RELATIVE ADDRESS
                                ;2--
        IO10    CONO,APR,,27700 ;3--CLR ANY ERRORS
        I10     SKIP,,,1000,1   ;4--REREAD TST WD.  SHD STILL BE IN CACHE
        IO10    CONSZ,APR,,7700 ;5--SKIP IF NO ERRS (IE NO RD DONE)
        I10     JRST,4,,2       ;6--HALT..RD DONE..BAD PAR WD THRU M
        I10     ADDI,1,,1       ;7--UPDATE TEST WORD REL ADR
        I10     TRNN,1,,777     ;10-SKIP        IF NOT ALL TST WORDS DONE
        I10     JRST,4,,0       ;11-ELSE DO NORML HALT...TST COMPLETE
        I10     TRNN,1,,3       ;12-SKIP IF NOT WD 0 ON NXT PASS
        I10     SETZM,,,1000,1  ;13-ELSE INIT DIR FOR THE NEW CACHE LINE
        IO10    SWPIO,,,1       ;14-INVAL ANY PAGE 1 WDS IN CACHE
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO TO FIRST INSTR OF THIS BLOCK
        WD36    4035,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CVB5PM


;SEQ218

;-----THE CACHE VALID BIT RAM TEST.  GET THE CACHE NUMBER.  LOAD INTO
;       AC BLOCK 0 & RUN IT.  THEN RUN THE REST OF THE PROGRAM AND CHECK
;       FOR ERROR STOPS.  IF NONE, EXIT, OTHERWISE CALL OUT THE APPROPRIATE
;       RAM & DIE.
T.6:    
T.7:
T.8:
T.9:    SM                      ;RESET THE MACHINE
        XQT     CSHALW          ;TURN ON THE CACHE
        JSR     PC,CHKX
        MOV     CSHNBR,R0       ;GET & FORMAT TEST CACHE NMBER
        SWAB    R0
        ASR     R0
        BIC     #77777,CVBP0N+1 ;CACHE NUMBER TO WRFIL INSTRUCTION
        BIS     R0,CVBP0N+1
        LOADAC  101,<CVBP0,CVBP0N>      ;RELOAD AC0&6: SETZM & WRFIL INSRS
        RUN     AC4             ;RUN PRGM TO INIT DIR WDS & SEL TST CACHE
        JSR     PC,CHKP         ;MAKE SURE IT FINISHED
        ACBLK   1               ;STATING AC BLOCK
        RUNBIG  AC4,10.         ;RUN THE PROGRAM
        JSR     PC,CHKP         ;MAKE SURE IT FINISHED
        DFPC                    ;GET HALTED PC (THE STOP CODE)
        MOV     (R0),R1         ;TO R1
        BGT     1$              ;NON-ZERO STOP CODE...ERROR
        NORMAL                  ;ELSE ALL DONE
1$:     DEC     R1              ;WHICH STOP CODE?
        BGT     2$              ;BR IS 2...VAL BITS WENT AWAY

;-----HALT CODE (PC) IS 1.  THE VALID BIT UNDER TEST WAS ERRONEOUSLY
;       SET BY WRITING INTO ANOTHER RAM BIT (IN AC BLOCK 3).
        CHKAPR  CIASDS,<VALID BIT>      ;MAKE SURE APR FLAGS CORRECT

        EXAMT,AC1,WD1           ;GET TEST WORD RELATIVE ADDR
        JSR     PC,CHKED
        JSR     R5,3$           ;GO CALL OUT E # AND CACHE BANK
        FAULT   <CACHE WORD ERRONEOUSLY VALID>


;SEQ219


;-----SECTION TO HANDLE THE ERROR STOP CODE (PC) 2.  THE TEST VALID BIT
;       WAS ERRONEOUSLY CLEARED WHEN ANOTHER BIT WAS CLEARED DURING AN
;       INVALIDATING SWEEP (IN AC BLOCK 4).
2$:     CHKAPR  CAMBSD,<VALID BIT>      ;MAKE SURE MB PAR & SWEEP DONE SET

        GERA                            ;READ THE ERA
        JSR     R5,3$                   ;GO CALL OUT E # AND CACHE BANK
        FAULT   <CACHE WORD ERRONEOUSLY INVALID>


;SEQ220

;-----LOCAL SUBROUTINE TO CALL OUT VALID BIT RAM NUMBERS AND CACHE BANK.
3$:     BIC     #177774,(R0)            ;ISOLATE WORD NUMBER
        MOV     CSHNBR,R1               ;FIGURE OUT E#
        SL      R1,2


        ADD     (R0),R1
        MOVB    4$(R1),R0               ;E# NOW IN R0
        CALRAM  28.                     ;CALL OUT RAM ON BOARD IN SLOT 28.
        PCB     ,2                      ;CALL OUT CACHE BANK
        RTS     R5                      ;RETURN TO CALLER

;-----CACHE VALID BIT RAM E NUMBERS.  THESE RAMS ARE LOCATED IN THE
;       "CHX" (M8515) BOARD, SLOT 28.
4$:     .BYTE   2.,7.,12.,17.           ;CACHE 0, WDS 0123
        .BYTE   3.,8.,13.,18.           ;CACHE 1
        .BYTE   22.,27.,32.,37.         ;CACHE 2
        .BYTE   23.,28., 33.,38.                ;CACHE 3


;SEQ221

.SBTTL          CACHE WRITTEN BIT RAM TEST
.REM    %
        TEST#10 THROUGH TEST#13 ARE THE CACHE WRITTEN BIT TESTS.  ONE OF
THESE BITS IS ASSOCIATED WITH EACH WORD IN THE CACHE.  IF THE WITTEN
BIT IS SET, IT MEANS THAT THE WORD IN THE CACHE WAS CREATED IN THE CPY
AND SOONER OR LATER HAS TO GO TO MEMORY.  THIS TEST IS DESIGNED TO MAKE
SURE THAT THE WRITTEN BIT RAMS WORK.  THE TEST COMES IN THREE PARTS:

1)      THE INITIALIZATIONS SELECT WHICH CACHE BANK IS BEING TESTED.  IN
ADDITION, THE FIRST INIT OF THIS SERIES OF TESTS LOADS THE AC PROGRAM.
NOTE THAT IT IS A MULTIPLE AC BLOCK (1-6) PROGRAM.

2)      THE TEST ITSELF RUNS ENTIRELY FROM THE KL ACS.  THE PDP11 DOES
NOTHING MORE THAN START THE KL.  SEE COMMENTS WITH EACH AC BLK TO 
GET DESCRIPTION OF OPERATION.


3)      ONCE A FAULT HAS BEEN FOUND THE ERROR ISOLATOR LOOKS AT THE ERA
TO GET THE ERROR WORD NUMBER.  THIS PLUS THE CACHE BANK NUMBER LEADS
DIRECTLY TO THE CHIP NUMBER.

        TEST#14 INIT IS USED ONLY TO CLEAN UP THE BAD PARITY WORDS LEFT
AROUND BY THE WRITTEN BIT TESTS.  THE TEST ITSELF IS A NO-OP.
        %

;-----CACHE WRITTEN BIT TEST INITIALIZATIONS.
I.10:   RTS     PC              ;NO INIT ON LOOPS
        SM                      ;RESET THE MACHINE
        ACBLK   1               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV1PM,CWV1     ;LOAD THIS BLK'S AC PRGM (AC2-17)
        ACBLK   2               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV2PM,CWV2     ;LOAD THIS BLK'S AC PRGM (AC1-17)
        ACBLK   3               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV3PM,CWV3     ;LOAD THIS BLK'S AC PRGM (AC2-17)
        ACBLK   4               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV4PM,CWV4     ;LOAD THIS BLK'S AC PRGM (AC4-17)


;SEQ222

        ACBLK   5               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV5PM,CWV5     ;LOAD THIS BLK'S AC PRGM (AC2-17)
        ACBLK   6               ;SET DEFAULT AC BLOCK FOR LOADAC
        LOADAC  CWV6PM,CWV6     ;LOAD THIS BLK'S PRGM (AC2-17)
        JMP     SELCO           ;GO TURN ON CACHE BANK 0

;-----THIS DUMMY TEST INITIALIZATION CLEANS UP BAD PAR IN MEM PAGE 1.
I.14:   SM                      ;RESET THE MACHINE
        CSHPAG  MINUS1,1        ;-1S TO PAGE 1
        RTS     PC


;SEQ223

;-----AC PROGRAM SEGMENT FOR AC BLOCK 1.
;THE AC PROGRAM WORKS BY WRITING A PAGE OF ZEROS WITH BAD PARITY TO
;"PAGE A".
CWV1:   BLK10   2               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
                                ;1--SCRATCH
        WD36    4012,0000,0000  ;2--TO MAKE AC BLK 2 THE PREV BLK
        I10     HLLZS,,,1       ;3--RESETS THE MASTER TEST LINE PTR
        I10     MOVEI,1,,777    ;4--<START HERE>LP CNT FOR WRG BD PAR TO PAGE A
        IO10    CONO,PI,,200000  ;5--SET "WR BAD DATA PAR" FLAG
        I10     SETZM,,,1000,1  ;6--WR O W/ BAD PAR TO PAGE A
        I10     SOJGE,1,,6      ;7--LP TIL PAGE A FILLED W/BD PAR
        IO10    CONO,PI,,0      ;10-RESET "WR BAD DATA PAR" FLAG
        IO10    DATAO,PAG,,2    ;11-MAKE AC BLK 2 THE PREV AC BLK
        I10     PXCT,4,,3       ;12-RESET MASTER TEST LINE REL ADR
        IO10    CONO,APR,,27700 ;13-CLR ERR FROM PREV WRITES
        IO10    SWPIA,,,0       ;14-START SWPIA (ALL PGS, INVAL, -UPD)
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,14       ;16- GO TO AC BLK START UPON ENTRY
        WD36    4021,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV1PM

;-----AC PROGRAM SEGMENT FOR AC BLOCK 2.
;NEXT IT COMMUNICATES THE "TEST LINE" ADDRESS TO ALL THE OTHER AC BLOCKS.
CWV2:   BLK10   1               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
        WD36    7777,7400,0000  ;1-- -4,,<TEST LINE RELATIVE ADR>
        WD36    0001,0000,0000  ;2--PREV AC BLK # DECREMENTOR
        I10     MOVEM,1,,1      ;3--MOV MASTER TST LIN REL ADR TO PREV
        I10     TRNE,1,,7000    ;4--SKIP IF NOT ALL TST LINES DONE
        I10     JRST,4,,0       ;5--ELSE HALT IF THE ARE ...ALL DONE
        I10     HRLZI,0,,402600 ;6--INIT PREV AC BLK WD
        IO10    DATAO,PAG,,0    ;7--SET PREV AC BLK
        I10     PXCT,4,,3       ;10--MOV MASTER TST LIN REL ADR TO PREV
        I10     SUB,0,,2        ;11-SEL NXT PREV AC BLK
        I10     TLNE,0,,600     ;12-SKIP IF NO MORE TO DO
        I10     JRST,,,7        ;13-ELSE DO NXT ONE
        I10     ADDI,1,,4       ;14-INC MASTER FOR NXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,4        ;16-GO TO AC BLK START UPON ENTRY
        WD36    4032,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV2PM


;SEQ224

;-----AC PROGRAM SEGMENT FOR AC BLOCK 3.
;THEN IT WRITES ZEROS TO THE TEST LINE AND READS THEM BACK TO FILTER OUT
;VALID BIT PROBLEMS.
CWV3:   BLK10   2               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
                                ;1-- -4,,<TEST LINE RELATIVE ADR>
        IO10    CONO,PAG,,600000        ;2--TURN ON CACHE
        IO10    CONSZ,APR,,200000       ;3--SKIP IF SWPIA DONE
        I10     JRST,,,3        ;4--ELSE LOOP & WAIT FOR IT
        IO10    CONO,APR,,27700  ;5--CLR ANY ERRS HANGING AROUND
        I10     SETZM,,,1000,1  ;6--WR WD TO TST LIN
        I10     AOBJN,1,,6      ;7--GO BAK & DO NXT WD, IF ANY LEFT
        I10     HRLI,1,,777774  ;10-RESTORE -4 FOR AOBJN
        I10     SKIP,,,774,1    ;11-RD TST LIN WD TO CHK FOR VALID ERR
        I10     AOBJN,1,,11     ;12-GO BAK & DO NXT WD, IF ANY LEFT
        IO10    CONSZ,APR,,7700 ;13-SKIP "HALT" BELOW IF NO ERRORS...OK
        I10     JRST,4,,1       ;14-ELSE HALT...CACHE VALID BIT ERROR
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,2        ;16-GO TO AC BLK START UPON ENTRY

        WD36    4043,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV3PM
;-----AC PROGRAM SEGMENT FOR AC BLOCK 4.
;WE NOW HAVE A LINE FULL OF VALID PARITY WORDS IN THE CACHE WITH PAGE A
;ADDRESSES.  THE PROGRAM NOW READS THE PAGE A WORDS INTO ALL OF THE OTHER
;LINES (BAD PARITY AND ALL) TO CLEAR THE WRITTEN BITS IN ALL THE OTHER
;RAM LOCATIONS.  THEN THE ERROR FLAGS ARE CLEARED, AND A READ IS DONE TO
;TEST LINE ON "PAGE B".  THIS SHOULD CAUSE A 4 WORD WRITEBASCK FROM
;THE TEST LINE TO MEMORY UNLESS SOME OF THE WRITTEN BITS HAVE BEEN
;CLEARED BY SETTING NOT WRITTEN TO ALL THE OTHER RAM LOCATIONS.
CWV4:   BLK10   4               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
                                ;1-- -4,,<TEST LINE RELATIVE ADR>
                                ;2--SCRATCH
                                ;3--
        I10     HRLZI,2,,777600 ;4--INIT LP CNT FOR RDG PAG A INTO CACHE
        I10     SKIP,,,1000,2   ;5--RD FIRST OF 4 WDS FRCG 4 WD RD
        I10     ADDI,2,,3       ;6--PT TO NXT 4 WD GROUP
        I10     AOBJN,2,,5      ;7--GO BACK & DO NEXT LINE, IF ANY LEFT
        I10     SKIP,,,1777     ;10-WAIT FOR LAST CACHE LINE TO FILL UP
        IO10    CONO,APR,,27700 ;11-CLR ALL ERRORS
        I10     SETZM,,,3000,1  ;12-WR TO PAGE B CAUSES PAGE A TST LIN WRTBK
        IO10    CONSZ,APR,,7700 ;13-SKIP "HALT" BELOW IF NO ERRORS...OK
        I10     JRST,4,,2       ;14-HALT IF CACHE DATA PAR BIT RAM BAD
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,4        ;16-GO TO AC BLK START UPON ENTRY
        WD36    4054,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV4PM


;SEQ225

;-----AC PROGRAM SEGMENT FOR AC BLOCK 5.
;NOW WE TURN OFF THE CACHE AND MAKE SURE THERE ARE 4 WORDS WITH GOOD
;PARITYS IN THE TEST LINE IN PAGE "A" CORE.  IF THERE ARE NOT, IT MEANS NO
;WRITEBACK WAS DONE FOR THIS WORD, HENCE THE WRITTEN BIT WAS SHUT OFF.
;IF EVERYTHING IS OK, BAD PARITY WORDS ARE RESTORED TO CORE AND THE CACHE
;TURNED BACK ON.
CWV5:   BLK10   2               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
                                ;1-- -4,,<TEST LINE RELATIVE ADR>
        IO10    CONO,PAG,,0     ;2--SHUT OFF CACHE SO WE CAN LOOK AT CORE
        I10     SKIP,,,1000,1   ;3--RD TST LIN WD FROM CORE
        I10     AOBJN,1,,3      ;4-- GO BAK & DO NXT WD, IF ANY LEFT
        IO10    CONSZ,APR,,7700 ;5--SKIP "HALT" BELOW IF NO ERRORS...OK
        I10     JRST,4,,3       ;6--HALT ON ERR... WRTN BIT RAM ERR
        I10     HRLI,1,,777774  ;7--RESET AOBJN LP CNTR
        IO10    CONO,PI,,200000 ;10-SET FORCE-BAD-DATA-PAR BIT
        I10     SETZM,,,774,1   ;11-RESTORE BD PAR WD TO CORE
        I10     AOBJN,1,,11     ;12-GO BAK & DO NXT WD, IF ANY LEFT
        IO10    CONO,PI,,0      ;13-RESET FORCE-BAD-DATA-PAR BIT
        IO10    CONO,PAG,,600000        ;14-TURN CACHE BACK ON
        IO10    DATAO,PAG,,17    ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,2        ;16-GO TO AC BLK START UPON ENTRY
        WD36    4065,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV5PM

;-----AC PROGRAM SEGMENT FOR AC BLOCK 6.
;FINALLY A SWEEP OF PAGE A IS DONE WHILE WRITING TO TEST LINE PAGE B.
;SINCE NONE OF THE PAGE A LINES WERE "WRITTEN" NONE SHOULD BE SWEPT BACK,
;AND NO PARITY ERRORS WILL OCCUR.  MAKE SURE THAT NONE DO OCCUR, AND THEN
;GO BACK TO AC BLOCK 1 TO SELECT THE NEXT TEST LINE.  REPEAT UNTIL ALL.
;CACHE LINES HAVE BEEN TESTED IN THIS MANNER.
CWV6:   BLK10   2               ;0--SCRATCH WORD USED RANDOMLY BY PDP11
                                ;1-- -4,,<TEST LINE RELATIVE ADR>
        I10     MOVEI,0,1,10    ;2--GET INTERFERENCE LP CNT FROM CAIN
        IO10    CONO,APR,,27700 ;3--CLEAR LEFT OVER PAR ERRS
        I10     SETZM,,,3003,1  ;4--DO THESE WRITES TO PAGE B WHILE
        I10     SETZM,,,3002,1  ;5--...SWEEPING PAGE A IN AN ATTEMPT TO
        I10     SETZM,,,3001,1  ;6--...ERRONEOUSLY SET A WRITTEN BIT.
        I10     SETZM,,,3000,1  ;7--
        I10     CAIN,0,,40      ;10-STRT SWEEP AFTER FIRST LOOP
        IO10    SWPUO,,,1       ;11-SWPUO...SWEEP PAGE A
        I10     SOJG,0,,4       ;12-LP ON INTERFERENCE WRITES
        IO10    CONSZ,APR,,7700 ;13-SKIP "HALT" BELOW IF NO ERROR...OK
        I10     JRST,4,,4       ;14-ELSE HALT...WRTN BIT ERRONEOUSLY SET
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK...SEL NXT TST LIN
        I10     JRST,,,2        ;16-GO TOAC BLK START UPON ENTRY
        WD36    4016,0000,0000  ;17-WD FOR DATAO PAG IN AC15
        ENDBLK  CWV6PM


;SEQ226

;-----THE CACHE WRITTEN BIT RAM TESTS.
T.10:
T.11:
T.12:
T.13:   SM                      ;RESET THE MACHINE
        ACBLK   1               ;STARTING AC BLOCK
        RUNBIG  AC4,7           ;RUN THE AC PRGM
        JSR     PC,CHKP
        DFPC                            ;GET THE HALTED PC (STOP CODE)
        MOV     (R0),R1         ;SAVE IT
        BNE     1$              ;BR IF NOT ZERO...ERROR
        NORMAL
1$:     ERRMSG  <ERA DATA: >

        GERA                    ;MOVE ERA WD TO WD3
        ERRCOM  PNT36B
        ERRMSG  <\CONI APR: >

        GAPR                    ;MOVE CONI APR WORD TO WD4
        ERRCOM  PNT36B
        PCB     ,2              ;PRINT CURRENT CACHE BANK #
        ERRMSG  <, WORD >

        MOVB    WD3+4,R0        ;GET & POSITION WORD NUMBER FROM ERA
        ASR     R0      
        ASR     R0
        ERRCOM  PNTOCS          ;STACK IT
        CMP     R1,#2           ;ERROR PC =1, 2, OR (3,4)?
        BGE     2$              ;BR IF 2,3,4


;SEQ227

        ERROR   <UNEXPECTED VALID BIT ERR DURING CACHE WRITTEN BIT TEST>

2$:     BGT     3$              ;BR IF ERR TYPE 3 OR 4
        ERROR   <UNEXPECTED DATA ERROR DURING CACHE WRITTEN BIT TEST>

;-----A WRITTEN BIT ERROR HAS OCCURED.  ISOLATE THE FAILING CHIP.
3$:     MOVB    WD3+4,R0        ;GET WORD NUMBER
        BIC     #177763,R0      ;SHUT OFF JUNK BITS
        ADD     CSHNBR,R0       ;ADD IN CACHE NUMBER
        MOVB    4$(R0),R0       ;GET E NUMBER
        CALRAM  27.             ;DUMP RAM LOCATION STUFF
        FAULT   <CACHE WRITTEN BIT RAM OR WRITEBACK LOGIC FAILURE>


;-----CACHE WRITTEN BIT RAM E NUMBERS.  FIRST WORD 0, CACHE 0, NEXT,
;       WORD 0 CACHE 1, ETC., OUT TO WORD 3 CACHE 3 LAST.
4$:     .BYTE   16.,18.,17.,35.,11.,13.,12.,40.
        .BYTE   6.,8.,7.,45.,2.,4.,3.,50.


;SEQ228

.SBTTL          CACHE DATA WORD RAM TEST
.REM    %
        TEST#15 THROUGH TEST#18 ARE THE CACHE DATA WORD TESTS, TEST#9
CHECKING CACHE BANK 0, ETC.  ALL TESTING IS DONE BY A MULTI-AC-BLOCK
PROGRAM.  ALL OF THE PDP11 CODE IS USED EITHER TO LOAD, RUN OR ANALYZE
THE RESULTS OF THIS AC PROGRAM.

        THE CACHE DATA RESIDES IN THE M8521 ("CHD") BOARDS.  EACH WORD
IN THE CACHE IS SPLIT ACROSS ALL 4 OF THE CHD BOARDS AS FOLLOWS:
                        BITS 00-08 --> SLOT 25
                        BITS 09-17 --> SLOT 24
                        BITS 18-26 --> SLOT 19
                        BITS 27-35 --> SLOT 17

        THESE TESTS ARE DESIGNED PRIMARILY TO EXERCISE THE CACHE DATA 
RAMS (TYPE 10144).  IF AN ERROR IS FOUND, THEY CALL OUT THE RAM(S) WHICH
CORRESPOND TO THE ERROR DATA.  IF THE ERROR WAS CAUSED BY NON-RAM CHIPS,
THEN THE E NUMBERS CALLED OUT WILL BE ERRONEOUS, THOUGH THEY MAY HELP
LEAD TO THE FAILING CHIP.  IN OTHER WORDS, THINK BEFORE YOU GRAB THE
SOLDERING IRON.

        
        NOTE THAT THE 10144S ARE 256X1 RAMS.  BECAUSE OF THIS, THE NTH 
BITS OF THE 4 WORDS OF A CACHE "LINE" RESIDE IN 2 (NOT 4) RAM CHIPS; THE
EVEN BITS GOING TO ONE, THE ODD BITS TO THE OTHER.  HENCE, THE TEST AND
ASSOCIATED CODE REFER TO EVEN/ODD PAIRS RATHER THAN LINES.  SEE THE
INDIVIDUAL AC PROGRAM BLOCKS FOR DESCRIPTION OF OPERATION.

WARNING:  SINCE THE RAM OUTPUTS ARE WIRE-ORED AND THE INPUTS ARE DRIVEN AS
A GROUP, A STUCK-AT-ONE CONDITION MAY RESULT IN THE WRONG CHIP BEING
CALLED OUT.  THE EVEN WORD CHIP WILL BE CALLED OUT EVEN IF AN ODD WORD
BIT IS STUCK.  WATCH YOURSELF!

GENERAL:  THERE IS A LOT OF OVERHEAD INVOLVED IN SWITCHING BETWEENTHE
        AC BLOCKS AND MAINTAINING SEPARATE PARAMETERS IN EACH AC BLOCK.
        DON'T LET THIS (NECESSARY) OVERHEAD CONFUSE YOU.

INITIALIZATIONS FOR THE CACHE DATA RAM TESTS.  THE INITS SELECT
        WHICH CACHE BANK WILL BE TESTED:  TEST#15 CHECKS BANK 0, ETC.
        IN ADDITION, TEST#15 INIT LOADS THE AC PROGRAM FOR ALL TESTS.
        %

;-----CACHE DATRA TEST INIT FOR CACHE BANK 0.
I.15:   RTS     PC              ;SKIP INIT ON LOOPS
        SM                      ;RESET THE MACHINE
        ACBLK   1               ;SET AC BLOCK TO LOAD
        LOADAC  CDT1PM,CDATV1   ;LOAD AC PRGM, BLOCK 1, AC3-17
        ACBLK   2               ;SET AC BLOCK TO LOAD


;SEQ229

        LOADAC  CDT2PM,CDATV2   ;LOAD AC PRGM, BLOCK 2, AC3-17
        ACBLK   3               ;SET AC BLOCK TO LOAD
        LOADAC  CDT3PM,CDATV3   ;LOAD AC PRGM, BLOCK 3, AC2-17
        ACBLK   4               ;SET AC BLOCK NUMBER TO PARAM REG
        LOADAC  CDT4PM,CDATV4   ;LOAD AC PRGM, BLOCK 4, AC3-17
        ACBLK   5               ;SET AC BLOCK TO LOAD
        LOADAC  CDT5PM,CDATV5   ;LOAD AC PRGM, BLOCK 5, AC3-17
        ACBLK   6               ;SET AC BLOCK TO LOAD
        LOADAC  CDT6PM,CDATV6   ;LOAD ACS FROM CONTIGUOUS 11 MEM
        JMP     SELCO           ;GO TURN ON CACHE BANK 0


;SEQ230

;-----CACHE DATA RAM VERIFICATION PROGRAM, AC BLOCK 1.
;TURNS ON THE CACHE AND INITIALIZES THE ADDRESS OF THE FIRST
;EVEN/ODD PAIR IN EACH OF THE OTHER AC BLOCKS.  THIS IS SO
;THE PDP11 DOESN'T HAVE TO DO IT EACH TIME.
CDATV1: BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--
                                ;2--
        WD36    0000,0000,1000  ;3--INITIAL WD PAIR ADDRESS
        WD36    0001,0000,0000  ;4--PREV AC BLK DECREMENTER
        I10     MOVEM,3,,1      ;5--MOVES INIT WD PR ADR TO PREV AC BLK
        IO10    CONO,PAG,,600000        ;6--<START HERE> TURN ON THE CACHE
        I10     HRLZI,0,,401600 ;7--INIT PREV AC BLK #
        IO10    DATAO,PAG,,0    ;10-SET PREV AC BLK # TO HARDWARE
        I10     PXCT,4,,5       ;11-XCT AC5 (MOVEM) IN PREV BLK MODE
        I10     SUB,0,,4        ;12-GET NXT AC BLK #
        I10     TLNE,0,,600     ;13-SKIP IF BLKS 6 TO 2 DONE
        I10     JRST,,,10       ;14-ELSE LP TIL DONE
        IO10    DATAO,PAG,,17   ;15-GO TO AC16 IN NXT AC BLK
        I10     JRST,,,6        ;16-GO DO THIS AC BLK
        WD36    4021,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CDT1PM

;-----CACHE DATA RAM TEST PROGRAM FOR AC BLOCK 2.
;WRITES -1 TO THE TEST PAIR WORDS AND ZEROS TO ALL THE OTHER
;WORDS IN THE CACHE BANK IN AN ATTEMPT TO CAUSE INTER-BIT INTERFERENCE.
CDATV2: BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--ADR OF TEST PAIR EVEN WORD
                                ;2--TEMP NON-TEST PAIR INDEX REGISTER
        I10     SETOM,,,0,1     ;3--ONES TO EVEN WD OF TEST PAIR
        I10     SETOM,,,1,1     ;4--ONES TO ODD WD OF TEST PAIR
        I10     MOVEI,2,,776    ;5--INIT TEMP NDX TO NON TST PAIRS
        I10     CAIN,1,,1000,2  ;6--SKIP IF NDX PTS TO NON-TST PAIR
        I10     JRST,,,12       ;7--ELSE BYPASS SET INSTRUCTIONS
        I10     SETZM,,,1000,2  ;10-ZEROS TO EVEN WD OF NON-TEST PAIR
        I10     SETZM,,,1001,2  ;11-SAME TO ODD WD
        I10     SUBI,2,,1       ;12-DECREMENT NON-TEST PAIR INDEX
        I10     SOJGE,2,,6      ;13-DECR IT AGAIN & JUMP IF MORE TO DO
        I10     ADDI,1,,2       ;14-GEN ADR OF TEST PAIR FOR NXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO DO FIRST INSTR OF THIS BLOCK
        WD36    4032,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CDT2PM


;SEQ231

;-----CACHE DATA RAM TEST PROGRAM FOR AC BLOCK 3.
;STARTS A SWEEP OF CACHE TO MAKE SURE ALL WORDS CAN BE READ
;WITHOUT ERROR.  WHILE THE SWEEP IS RUNNING IT READS & RE-READS THE TEST
;PAIR TO KEEP THE CACHE  BUSY AND TO MAKE SURE THAT THOSE WORDS ARE OK.
CDATV3: BLK10   2               ;0--SCRATCH USE ONLY
                                ;1--ADDR OF TEST PAIR EVEN WORD
MINUS1: WD36    7777,7777,7777  ;2--MINUS 1 FOR COMPARISON
        IO10    SWPVA,,,0       ;3--START SWPVA(UPD MEM, LV CACHE VALID)
        I10     MOVE,0,,0,1     ;4--GET TEST PAIR WD
        I10     CAME,2,,0       ;5--MAKE SURE IT'S OK
        I10     JRST,4,,1       ;6--ELSE HALT .. ERROR

        I10     TRCE,1,,1       ;7--SW TO OTHER WD...SKP ON EVEN WD DONE
        IO10    CONSZ,APR,,200000       ;10-SKP IF SWEEP NOT BUSY (IE DONE)
        I10     JRST,,,4        ;11-ELSE LOOP UNTIL IT ISNT BUSY
        IO10    CONSZ,APR,,7700 ;12-SKIP IF NO ERRORS DETECTED
        I10     JRST,4,,2       ;13-ELSE HALT ... ERROR FOUND
        I10     ADDI,1,,2       ;14-GEN ADR OF TEST PAIR FOR NXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO DO FIRST INSTR OF THIS BLOCK
        WD36    4043,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CDT3PM
;-----CACHE DATA RAM TEST PROGRAM FOR AC BLOCK 4.
;WRITES ZERO TO THE TEST PAIR WORDS AND MINUS ONE TO EVERYTHING
;ELSE, AGAIN IN AN ATTEMPT TO PRODUCE BIT INTERFERENCE.
CDATV4: BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--ADDR OF TEST PAIR EVEN WORD
                                ;2--TEMP NON-TEST PAIR INDEX REGISTER
        I10     SETZM,,,0,1     ;3--ZEROS TO EVEN WD OF TEST PAIR
        I10     SETZM,,,1,1     ;4--SAME TO ODD WD
        I10     MOVEI,2,,776    ;5--INIT TEMP NDX TO NON TST PAIRS
        I10     CAIN,1,,1000,2  ;6--SKIP IF NDX PTS TO NON-TST PAIR
        I10     JRST,,,12       ;7--ELSE BYPASS SET INSTRUCTIONS
        I10     SETOM,,,1000,2  ;10-ONES TO EVEN WD OF NON-TEST PAIR
        I10     SETOM,,,1001,2  ;11-SME TO ODD WD
        I10     SUBI,2,,1       ;12-DECREMENT NON-TEST PAIR INDEX
        I10     SOJGE,2,,6      ;13-DECR IT AGAIN & JUMP IF MORE TO DO
        I10     ADDI,1,,2       ;14-GEN ADR OF TEST PAIR FOR NXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO DO FIRST INSTR OF THIS BLOCK
        WD36    4054,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CDT4PM



;SEQ232.OK


;-----CACHE DATA RAM TEST PROGRAM FOR AC BLOCK 5.
; DOES MUCH THE SAME THING AS AC BLOCK 3, BUT IN A SLIGHTLY
; DIFFERENT MANNER.
CDATV5: BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--ADDR OF TEST PAIR EVEN WORD
                                ;2--TEST WD FROM MEM GOES HERE
        IO10    SWPVA,,,0       ;3--START SWPVA(UPD MEM, LV CACHE VALID)
        I10     SKIPE,2,,0,1    ;4--GET EVEN WD...SKIP IF OK
        I10     JRST,4,,3       ;5--ELSE HALT
        I10     SKIPE,2,,1,1    ;6--GET ODD WD...SKIP IF OK
        I10     JRST,4,,4       ;7--ELSE HALT
        IO10    CONSZ,APR,,200000       ;10-SKIP IF SWEEP NOT BUSY (DONE)
        I10     JRST,,,4        ;11-ELSE LOOP UNTIL IT ISNT BUSY
        IO10    CONSZ,APR,,7700 ;12-SKIP IF NO ERRORS DETECTED
        I10     JRST,4,,5       ;13-ELSE HALT...ERROR FOUND
        I10     ADDI,1,,2       ;14-GEN ADR OF TEST PAIR FOR NXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-GO DO FIRST INSTR OF THIS BLOCK
        WD36    4065,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CDT5PM

;-----CACHE DATA RAM TEST PROGRAM FOR AC BLOCK 6.
; HALTS IF ALL TEST PAIRS HAVE BEEN DONE, OTHERWISE IT JUST
; GOES BACK TO AC BLOCK 2 TO DO THE NEXT PAIR.
CDATV6: BLK10   12              ;0--SCRATCH USE ONLY
                                ;1--ADDR OF TEST PAIR EVEN WORD
                                ;2--
                                ;3--
                                ;4--
                                ;5--
                                ;6--
                                ;7--                    
                                ;10-
                                ;11-
        I10     ADDI,1,,2       ;12-GEN ADR OF TEST PAIR FOR NXT TIME
        I10     TRNN,1,,777     ;13-SKIP IF NOT ALL TEST PAIRS DONE
        I10     JRST,4,,0       ;14-ELSE DO NORMAL HALT
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,12       ;16-GO DO FIRST INSTR OF THIS BLOCK
        WD36    4026,0000,0000  ;17-POINTER TO NEXT AC BLOCK
        ENDBLK  CDT6PM

;SEQ233

.REM    %
        THE CACHE DATA RAM TEST.  ALL TESTING IS DONE BY THE AC PROGRAM.
IF THE PROGRAM FINDS NO ERROR, THE PDP11 JUST MOVES ON TO THE
NEXT TEST,  MOST OF THE CODE HERE IS USED FOR GENERATING ERROR TYPEOUTS.

        %
T.15:
T.16:
T.17:
T.18:   SM                      ;RESET THE MACHINE
        ACBLK   1               ;SET STARTING AC BLOCK
        RUNBIG  AC6,28.         ;RUN THE AC PROGRAM
        JSR     PC,CHKP         ;MAKE SURE PROGRAM HALTED
        DFPC                    ;GET HALTED PC
        MOV     (R0),R0         ;HALTED PC TO R0
        CLR     R4              ;SET ERR EVEN WD
        MOV     #1$,R3          ;SET XPCTED PTRN PTR TO PT TO ZEROS
        CGOTO   <NORMAL,5$,9$,7$,6$,10$>        ;GO TO RTN APPRP FOR HLT CODE
1$:     WD36    0000,0000,0000  ;TABLE OF EXPECTED PATTERNS


        WD36    7777,7777,7777



        WD36    0000,0000,0000



        .EVEN
;-----LITTLE SUBROUTINE WHICH ACCEPTS PARITY ERRS ON EXAMINES.
2$:     BCC     4$              ;BR IF NO ERROR AT ALL
        BEQ     3$              ;BR IF NOT PAR ERR
        BPL     3$              ;BR IF NOT PAR ERR
        BVS     4$              ;BR IF PAR ERR
3$:     JMP     CHKED+4         ;GO CALL OUT ERROR IF NOT PAR ERR
4$:     RTS     PC              ;RETURN IF NO ERR OR PARITY ERR

;-----SECTION FOR READ BACK FAILURE... ONES EXPECTED.
5$:     ADD     #5,R3           ;INDICATE ONES PATTERN EXPECTED
        EXAMT,AC1,WD2   ;GET TEST PAIR ADR
        JSR     PC,CHKED
        MOV     WD2,R4          ;SET UP EVEN/ODD FLAG
        BIC     #-2,R4
        EXAMT,AC0,WD1           ;GET ACTUAL PATTERN
        BR      8$              ;GO ANALYZE
;-----SECTION FOR READBACK FAILURE... ZEROS EXPECTED.
6$:     INC     R4              ;SET ODD WD FLAG FOR ERR PC=4
7$:     EXAMT,AC2,WD1           ;GET ACTUAL PATTERN
8$:     JSR     PC,2$           ;CHK EXAMINE BUT ALLOW PAR ERRS


;SEQ234


        JSR     R5,CDTCNT               ;COUNT ERRS...DO APPROP THING IF TOO MANY
        JSR     R5,CDTCEB               ;CALL OUT ERR RAMS
        FAULT   <CACHE DATA ERR DETECTED ON READ>


;SEQ235

;-----SECTION FOR FAILURE DURING SWEEP.
9$:     ADD     #5,R3           ;IND ONES PTRN XPCTD FOR TST PAIR
10$:    CHKAPR  CAMBSD,<DATA RAM>       ;MAKE SURE APR STUFF IS EXPECTED

        EXAMT,AC1,WD2           ;GET TEST PAIR ADR
        GERA                    ;MOVE ERA WORD TO WD3
        MOVB    WD3+4,R4        ;GET & POSITION ERROR WORD #
        SR      R4,2


        BIC     #177774,R4
        MOV     (R0),R0         ;GET FIRST WD ADR & INSERT ERR WD #
        BIC     #3,R0
        BIS     R4,R0
        BIC     #2,R4           ;ISOLATE EVEN/ODD BIT FOR EVEN/ODD FLAG
        MOV     R0,12$+2        ;PUT ERROR WD ADR IN EXAMINE
        EXOR    WD2,R0,R1       ;CALC TST PAIR ADR/ERA ADR DIFFERENCES
        BIC     #1,R0           ;EXCEPT LO ORD BIT
        BEQ     11$             ;BR IF SAME (IE, XPCTD PTRN IS OK)
        ADD     #5,R3           ;ELSE SET OTHER XPCTD PTN
11$:    SM                      ;RESET THE MACHINE (OFF THE CACHE)
12$:    EXAMT ,000000,WD1       ;GET BAD WD SWEPT TO MEM
        JSR     PC,2$           ;CHK EXAM... ALLOW PAR ERRS
        JSR     R5,CDTCNT       ;COUNT ERRS.  DO APPROP THING
        JSR     R5,CDTCEB       ;CALL OUT RAN(S) ASSOCIATED WITH ERR
        FAULT   <CACHE DATA ERROR DETECTED DURING SWEEP>


;SEQ236
;SUBROUTINE TO DUMP THE ERROR INFO TO THE STACK, COUNT THE NUMBER
;       OF ERR BITS, & DECIDE WHAT TO DO.
CDTCNT: REGSAV
        MOV     R3,1$+2         ;SAV XPCTD PTRN PTR IN MASK36 PARAM LIST
        JSR     R5,MASK36       ;ERR INFO TO ERR STK
1$:       .WORD ZERO..,000000,WD1       ;MASK, EXPECTED, ACTUAL
        PCB                     ;CACHE BANK TO ERR STK
        TST     R4              ;EVEN OR ODD WD?
        BNE     2$              ;BR IF GOOD
        ERRMSG  <, EVEN WORD.>

        BR      3$
2$:     ERRMSG  <, ODD WORD.>

3$:     MOV     #WD1,R4         ;ADR OF ACTUAL
          CLR   R0              ;ERR CNT=0
4$:     MOVB    (R3)+,R2        ;CALC ERR BITS
        MOVB    (R4)+,R1
        EXOR    R1,R2,R5
        BIC     #177400,R2
5$:     BIT     #1,R2           ;NOW DO LOOP TO COUNT # BITS IN ERROR
        BEQ     6$
        INC     R0
6$:     ASR     R2
        BNE     5$
        CMP     R4,#WD1+5       ;LOOP DONE?
        BLO     4$              ;NO..GO BAK & DO OUTER LOOP AGAIN
        TST     R0              ;ANY DATA BIT ERR(S) AT ALL?
        BNE     7$              ;YES... CONTINUE
        REGRST                  ;ELSE MUST HAVE BEEN PAR BIT ERR.
          POP     R5            ;...GO TO PAR BIT TEST & CALL OUT RAM
        ERRMSG  <\CACHE DATA TEST DETECTED PAR BIT FAILURE\>

        JMP     T1316           ;GO TO MIDDLE OF PAR BIT TEST
7$:     CMP     R0,#4.          ;MORE THAN 4 ERRORS?
        BGT     8$              ;YES...PROBABLE CONTROL LOGIC ERROR
        REGRST                  ;ELSE RESTORE REGS & RET
        RTS     R5


;SEQ237

8$:     REGRST
        POP     R5              ;GET BACK SUBTEST #

        FAULT   <PROBABLE CACHE DATA CONTROL/VALID BIT ERROR.>


;SEQ 238

;-----SUBROUTINE TO CALL OUT FAILING BOARD AND RAM E NUMBER BASED ON
;       EVEN/ODD FLAG (R4=0/1), CACHE NUMBER (CSHNBR), AND ACTUAL VS.
;       EXPECTED WORDS (WD1 VS (R3)).
CDTCEB: REGSAV
        CLR     4$+2            ;CLR "BOARD #"
        PUSH    R4              ;SAVEEVEN/ODD FLAG

        MOV     #WD1,R5         ;LOAD POINTERS
        MOV     #8.,R4          ;INIT "BIT NUMBER"
1$:     MOVB    (R5)+,R2        ;GET ACT & XPCTD BYTES
        MOVB    (R3)+,R1
        EXOR    R1,R2,R0
        BIC     #177400,R2      ;CLR GARBAGE
        MOV     #8.,R1          ;SET INNER LOOP COUNT
2$:     BIT     #1,R2           ;ERROR IN THIS BIT POSITION?
        BEQ     3$              ;NO...GO DO NXT BIT
        PUSH    R1              ;SAV R1 ON STK TEMPORARILY

        MOV     4$+2,R1         ;GET "BOARD #"
        MOVB    7$(R1),R1       ;TRANSLATE TO REAL SLOT #
        MOV     R4,R0           ;COMBINE BIT #, CHSNUM, & EVEN/ODD
        SL      R0,2            ; ...TO GET E NUMBER


        ADD     CSHNBR,R0
        ASL     R0
        INC     R0              ;(HACK TO REVERSE MEANING OF EVEN/ODD)
        SUB     2(SP),R0
        MOVB    6$(R0),R0       ;TRANSLATE TO E NUMBER
        CALRAM                  ;DUMP RAM LOCATION INFORMATION
        POP     R1              ;RESTORE R1


3$:     ASR     R2              ;MOV NXT DIF BIT INTO PLACE
        DEC     R4              ;CALC NXT "BIT #"
        BGE     5$              ;BR IF OK
        MOV     #8.,R4          ;ELSE RE-INIT "BIT #"
4$:     INC     #000000         ;AND INCREMENT "BOARD #"
5$:     DEC     R1              ;DEC INNER LOOP CNT
        BGT     2$              ;BR IF MORE TO DO IN INNER LOOP
        CMP     R5,#WD1+5       ;OUTER LOOP DONE?
        BLO     1$              ;BR IF NO...GO DO SOME MORE
        TST     (SP)+           ;DEL EVEN/ODD FLAG FRM STK
        REGRST                  ;RESTORE REGS
        RTS     R5              ;RET TO CALLER


;SEQ239

;-----TRANSLATION TABLES:  THE  E # TABLE HAS ITS ENTRIES IN THE
;       FOLLOWING ORDER.
;       BIT N+00, CACHE 0, EVEN; BIT N+00, CACHE 0, ODD;
;       BIT N+00, CACHE 1, EVEN; ....
;                                       ....BIT N+08, CACHE 3, ODD.

6$:     .BYTE   93.,94.,95.,96.,88.,89.,91.,90. ;BIT N+00
        .BYTE   92.,87.,82.,78.,86.,81.,77.,72. ;BIT N+01
        .BYTE   73.,68.,63.,58.,67.,62.,57.,52. ;BIT N+02
        .BYTE   76.,71.,66.,61.,75.,70.,65.,60. ;BIT N+03
        .BYTE   56.,51.,46.,41.,55.,50.,45.,40. ;BIT N+04
        .BYTE   36.,31.,26.,21.,35.,30.,25.,20. ;BIT N+05
        .BYTE   47.,42.,37.,32.,43.,38.,33.,28. ;BIT N+06
        .BYTE   27.,22.,17.,12.,23.,18.,13.,09. ;BIT N+07
        .BYTE   08.,07.,06.,05.,04.,03.,02.,01. ;BIT N+08

7$:     .BYTE   17.,19.,24.,25.         ;"BOARD #" TO REAL SLOT # TABLE


;SEQ240

.SBTTL          CACHE DATA PARITY RAM TEST
.REM    %
        TEST#19 THROUGH TEST#22 ARE THE CACHE DATA PARITY BIT RAM TESTS.
THEY ARE VERY MUCH THE SAME AS THE CACHE DATA TESTS (QV) WITH CERTAIN
DIFFERENCES:  FIRST, THE ARRANGEMENT OF THE PARITY BITS WITH RESPECT TO
SLOTS IS DIFFERENT:

                CACHE BANK 0 PARITY --> SLOT 25
                CACHE BANK 1 PARITY --> SLOT 24
                CACHE BANK 2 PARITY --> SLOT 19
                CACHE BANK 3 PARITY --> SLOT 17

        SECOND, BECAUSE THERE ARE ONLY 2 PARITY RAMS/BOARD (EVEN & ODD
WORDS), CALLING OUT WHICH RAM IS VERY EASY.

        THIRD, SINCE COMPLEMENTARY PATTERNS IN A DATA PATH WITH AN EVEN
NUMBER OF BITS GENERATE THE SAME PARITY BIT VALUE, DIFFERENT PATTERNS
ARE USED; 0 FOR THE NON-TEST PAIRS, 1 (NOT -1) FOR THE TEST PAIR.  THIS
IS THE REAL REASON FOR HAVING SEPARATE DATA & PARITY BIT TESTS.

        FINALLY (I HOPE), SINCE WE ARE TESTING THE PARITY BIT, THE TEST
NEVER LOOKS AT THE DATA PATTERNS BUT ONLY DOES SWEEPS FOLLOWED BY A
CHECK OF THE APR FLAGS.  IF A PARITY BIT WAS BAD, THE MB PARITY ERROR
FLAG WILL BE SET, WITH THE ERA INDICATING WHICH WORD WAS IN ERROR.
        %


;SEQ241

.REM    %
        INITIALIZATIONS FOR THE CACHE DATA PARITY TESTS.  THE INITS
SELECT WHICH CACHE BANK WILL BE TESTED:  TEST#19 CHECKS BANK 0, ETC.
IN ADDITION, TEST#19 INIT LOADS THE AC PROGRAM FOR ALL 4 TESTS.
        %
;-----CACHE DATA PARITY TEST INIT FOR CACHE BANK 0.
I.19:   RTS     PC              ;SKIP INIT ON LOOPS
        SM                      ;RESET THE MACHINE
        ACBLK   1               ;SET AC BLOCK TO LOAD
        LOADAC  CDP1PM,CDPV1    ;LOAD AC PRGM, BLOCK 1, AC3-17
        ACBLK   2               ;SET AC BLOCK TO LOAD
        LOADAC  CDP2PM,CDPV2    ;LOAD AC PRGM, BLOCK 2, AC3-17
        ACBLK   3               ;SET AC BLOCK TO LOAD
        LOADAC  CDP3PM,CDPV3    ;LOAD AC PRGM, BLOCK 3, AC5-17
        ACBLK   4               ;SET AC BLOCK TO LOAD
        LOADAC  CDP4PM,CDPV4    ;LOAD AC PRGM, BLOCK 4, AC4-17
        ACBLK   5               ;SET AC BLOCK TO LOAD
        LOADAC  CDP5PM,CDPV5            ;LOAD AC PRGM, BLOCK 5, AC6-17
        JMP     SELCO           ;GO TURN ON CACHE BANK 0


;SEQ242

;-----CACHE DATA PARITY BIT RAM VERIFICATION PROGRAM, AC BLOCK 1.
CDPV1=CDATV1                    ;0--SCRATCH USE ONLY
CDP1PM=CDT1PM                   ;1--
                                ;2--
        ;WD36   0000,0000,1000  ;3--INITIAL WD PAIR ADDRESS
        ;WD36   0001,0000,0000  ;4--PREV AC BLK DECREMENTER
        ;I10    MOVEM,3,,1      ;5--MOVES INIT WD PR ADR TO PREV AC BLK
        ;IO10   CONO,PAG,,600000        ;6--<START HERE> TURN ON THE CACHE
        ;I10    HRLZI,0,,401600 ;7--INIT PREV AC BLK #
        ;IO10   DATAO,PAG,,0    ;10-SET PREV AC BLK # TO HARDWARE
        ;I10    PXCT,4,,5       ;11-XCT AC5 (MOVEM) IN PREV BLK MODE
        ;I10    SUB,0,,4        ;12-GET NXT AC BLK #
        ;I10    TLNE,0,,600     ;13-SKIP IF BLKS 6 TO 2 DONE
        ;I10    JRST,,,10       ;14-ELSE LP TIL DONE
        ;IO10   DATAO,PAG,,17   ;15-GO TO AC16 INNEXT AC BLK
        ;I10    JRST,,,6        ;16-GO DO THIS AC BLK
        ;WD36   4021,0000,0000  ;17-PTR TO NXT AC BLK

;----CACHE DATA PARITY BIT RAM VERIFICATION PROGRAM, AC BLOCK?
CDPV2:  BLK10   3               ;0--SCRATCH USE ONLY
                                ;1--EVEN WD ADR OF TEST WD PAIR
                                ;2--TEMP INDEX TO NON-TEST PAIR WDS
        I10     SETZM,,,0,1     ;3--ODD PARITY TO EVEN TEST WORD
        I10     SETZM,,,1,1     ;4--ODD PARITY TO ODD TEST WORD
        I10     MOVEI,2,,776    ;5--INIT NON-TEST PAIR INDEX
        I10     CAIN,1,,1000,2  ;6--SKIP IF NOT TEST PAIR
        I10     JRST,,,12       ;7--ELSE JUMP...DONT CNG PAR OF TEST WDS
        I10     HRRZM,4,,1000,2 ;10-EVEN PARITY TO EVEN NON-TEST WD
        I10     HRRZM,4,,1001,2 ;11-EVEN PARITY TO ODD NON-TEST WD
        I10     SUBI,2,,2       ;12-PT TO NXT NON-TEST PAIR
        I10     JUMPGE,2,,6     ;13-LOOP UNTIL ALL NON-TEST PAIR DONE
        I10     ADDI,1,,2       ;14-PT TO NEXT TEST PAIR
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,3        ;16-ON ENTRY HERE, GO TO FIRST INSTR
        WD36    4032,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CDP2PM

;-----CACHE DATA PARITY BITR RAM VERIFICATION PROGRAM, AC BLOCK 3.
CDPV3:  BLK10   5               ;0--SCRATCH USE ONLY
                                ;1--EVEN WD ADR OF TEST WD PAIR
                                ;2--
                                ;3--
                                ;4--
        IO10    SWPVA,,,0       ;5--SWPVA...UPDATE MEM...LV CSH VALID
        IO10    CONSZ,APR,,200000       ;6--SKIP IF SWEEP NOT BUSY (IE DONE)
        I10     JRST,,,6        ;7--ELSE WAIT UNTIL IT ISN'T
        IO10    CONSZ,APR,,7700 ;10-SKIP IF NO ERRORS FOUND
        I10     JRST,4,,1       ;11-ELSE HALT...ERR FND
        I10     HRRZM,11,,0,1   ;12-EVEN PAR TO EVEN TEST WD
        I10     HRRZM,11,,1,1   ;13-EVEN PARITY TO ODD TEST WD
        I10     ADDI,1,,2       ;14-PT TO NEXT TEST PAIR
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,5        ;16-ON ENTRY HERE, GO TO FIRST INSTR
        WD36    4043,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CDP3PM


;SEQ243

;-----CACHE DATA PARITY BIT RAM VERIFICATION PROGRAM, AC BLOCK 4.
CDPV4:  BLK10   4               ;0--SCRATCH USE ONLY
                                ;1--EVEN WD ADR OF TEST WD PAIR
                                ;2--TEMP INDEX TO NON-TEST PAIR WDS
                                ;3--
        
   
        I10     MOVEI,2,,776    ;4--INIT NON-TEST PAIR INDEX
        I10     CAIN,1,,1000,2  ;5--SKIP IF NOT TEST PAIR
        I10     JRST,,,11       ;6--ELSE JUMP...DONT CNG PAR OF TEST WDS
        I10     SETZM,,,1000,2  ;7--ODD PARITY TO EVEN NON-TEST WD
        I10     SETZM,,,1001,2  ;10-ODD PARITY TO ODD NON-TEST WORD
        I10     SUBI,2,,2       ;11-PT TO NXT NON-TEST PAIR
        I10     JUMPGE,2,,5     ;12-LOOP UNTIL ALL NON-TEST PAIR DONE
        IO10    SWPVA,,,0       ;13-SWPVA...UPDATE MEM...LV CACHE VALID
        I10     ADDI,1,,2       ;14-PT TO NEXT TEST PAIR
        IO10    DATAO,PAG,,17   ;15-
        I10     JRST,,,4        ;16-ON ENTRY HERE,GO TO FIRST INSTR
        WD36    4054,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CDP4PM

;-----CACHE DATA PARITY BIT RAM VERIFICATION PROGRAM, AC BLOCK 5.
CDPV5:  BLK10   6               ;0--SCRATCH USE ONLY
                                ;1--EVEN WD ADR OF TEST WD PAIR
                                ;2--
                                ;3--
                                ;4--
                                ;5--
        IO10    CONSZ,APR,,200000  ;6--SKIP IF SWEEP NOT BUSY (IE DONE)
        I10     JRST,,,6                ;7--ELSE WAIT UNTIL IT ISN'T
        IO10    CONSZ,APR,,7700 ;10-SKIP IF NO ERRORS FOUND
        I10     JRST,4,,1       ;11-ELSE HALT...ERR FND
        I10     ADDI,1,,2       ;12-PT TO NEXT TEST PAIR
        I10     TRNN,1,,777     ;13-SKIP IF NOT ALL TEST PAIRS DONE
        I10     JRST,4,,0       ;14-ELSE DO NORMAL HALT
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        I10     JRST,,,6        ;16-ON ENTRY HERE, GO TO FIRST INSTR
        WD36    4025,0000,0000  ;17-PTR TO NXT AC BLK
        ENDBLK  CDP5PM


;SEQ244

.REM    %
        THE CACHE DATA PARITY RAM TESTS.  ALL TESTING IS DONE BY THE AC
PROGRAM.  IF THE PROGRAM FINDS NO ERROR, THE PDP11 JUST MOVES ON TO THE
NEXT TEST.  MOST OF THE CODE HERE IS USED FOR GENERATING ERROR TYPEOUTS.
        %

T.19:   
T.20:
T.21:
T.22:   SM                      ;RESET THE MACHINE
        ACBLK   1               ;SET STARTING AC BLOCK
        RUNBIG  AC6,28.         ;RUN THE AC PROGRAM
        JSR     PC,CHKP         ;MAKE SURE PROGRAM HALTED
        DFPC                    ;GET HALTED PC
        TST     (R0)            ;ZERO OR NON-ZERO PC?
        BNE     1$              ;BR IF NONZERO...ERROR FOUND
        NORMAL                  ;ELSE TEST DONE
;-----AN ERROR HAS OCCURED.  MAKE SURE IT IS OF THE EXPECTED TYPE.
1$:     PCB     ,1              ;PRINT CACHE BANK #
        CHKAPR  CAMBSD,<DATA PARITY RAM>

;-----ERROR WAS PARITY ERROR.  THEREFORE THERE WAS A FAILURE IN THE
;       CACHE PARITY BIT RAM OR IN ITS ASSOCIATED LOGIC.  CALL OUT THE
;       RAM ASSOCIATED WITH THE ERROR.
        GERA                    ;GET ERA WORD TO WD3
T1316:  MOV     CSHNBR,R1       ;GET CACHE NUMBER UNDER TEST
        MOVB    2$(R1),R1       ;TRANSLATE TO SLOT #
        MOV     #83.,R0         ;ASSUME EVEN WD PAR BIT BAD
        BIT     #4,WD3+4        ;WAS IT EVEN OR ODD WD?
        BEQ     1$              ;BR IF EVEN...ALREADY HAVE E # IN R0
        MOV     #53.,R0         ;ELSE PUT ODD WD PAR BIT E # IN R0
1$:     CALRAM                  ;RAM LOC INFO TO ERR STK
        FAULT   <ERROR IN CACHE PARITY RAM/CONTROL LOGIC.>


2$:       .BYTE 25.,24.,19.,17. ;SLOT CONVERSION TABLE FOR CACHE PAR


;SEQ245

;-----END OF GENERATION PASS ROUTINE.
ENDPAS: DEC     TESTAB          ;SET CORRECT # OF TESTS TO TESTAB
        CLR     IMEMCF          ;MARK MEMORY CONFIGURATION NOT SAVED
        PMSG    <DHMCB GEN PASS DONE\>

        GETVER                  ;GET PRGM VERSIONNUMBER
        PMSG    <CD DHMCB 3000.>        ;SET UP CMD FOR EXEC

        MOV     $$FF,R0
        PNTOCS
        PNTVER
        PCRLF
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;DUMP THIS PROGRAM
        BCC     1$              ;BR IF DUMP OK
        PMSG    <PRGM DUMP ERR\>


1$:     PRGHLT


;SEQ246

        .SBTTL  MBOX TEST SUBROUTINE LIBRARY 20-MAY-77
.REM    %
        TRAP HANDLER.  EMULATES AN R5 CALLING CONVENTION.
%
$TRAP:  MOV     R5,$SAVE        ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC
        MOVB    -2(R5),R5       ;GET TRAP #
        CMP     R5,#130         ;VALID TRAP?
        BLE     1$              ;YES
        CLR     R5              ;NO,UNDEFINED
1$:     ASL     R5              ;MULTIPLY BY 2
        MOV     $TRBAS(R5),$LINK        ;GET ENTRY POINT
        POP     R5              ;TRAP PC TO R5

        PUSH    #2$

        RTT                     ;RESTORE USER STATUS
2$:     PUSH    $SAVE           ;ORIGINAL R5 TO STACK

        JMP     @$LINK          ;CALL PROGRAM

$LINK:  .WORD   0               ;TRAP LINKAGE SCRATCH
        $SAVE:  .WORD   0               ;R5 FOR CALLING CONVENTION

$UNDEF: PMSG    <UNDEF. TRAP AT PC >

        MOV     R5,R0
        DEC     R0              ;
        DEC     R0              ;
        PNTOCS                  ;PRINT TRAP LOCATION
        POP     R5              ;RESTORE R5

        FATAL


;SEQ247

$TRBAS: .WORD   $UNDEF  ;ILLEGAL TRAP
        .WORD   $UNDEF  ;TRAP 1 RESERVED
        .WORD   $UNDEF  ;TRAP 2 RESERVED
        .WORD   $UNDEF  ;TRAP 3 RESERVED
        .WORD   SAV.3   ;TRAP 4
        .WORD   RST.3   ;TRAP 5
        .WORD   SAV.5   ;TRAP 6
        .WORD   RST.5   ;TRAP 7
        .WORD   RUNPRG  ;TRAP 10
        .WORD   CONTIN  ;TRAP 11
        .WORD   RUNBIG  ;TRAP 12
        .WORD   STEP    ;TRAP 13
        .WORD   FIND    ;TRAP 14
        .WORD   EVENT   ;TRAP 15
        .WORD   STEP10  ;TRAP 16
        .WORD   STPCON  ;TRAP 17
        .WORD   BRST    ;TRAP 20
        .WORD   $UNDEF  ;TRAP 21 RESERVED
        .WORD   $UNDEF  ;TRAP 22 RESERVED
        .WORD   MSK36R  ;TRAP 23
        .WORD   MASK36  ;TRAP 24
        .WORD   MSKDAT  ;TRAP 25
        .WORD   $UNDEF  ;TRAP 26 RESERVED
        .WORD   $UNDEF  ;TRAP 27 RESERVED
        .WORD   ACBLK   ;TRAP 30
        .WORD   $UNDEF  ;TRAP 31 RESERVED
        .WORD   RANGE   ;TRAP 32
        .WORD   $UNDEF  ;TRAP 33 RESERVED
        .WORD   $UNDEF  ;TRAP 34 RESERVED
        .WORD   $UNDEF  ;TRAP 35 RESERVED
        .WORD   $UNDEF  ;TRAP 36 RESERVED
        .WORD   LOAD    ;TRAP 37
        .WORD   $UNDEF  ;TRAP 40 RESERVED
        .WORD   $UNDEF  ;TRAP 41 RESERVED
        .WORD   $UNDEF  ;TRAP 42 RESERVED
        .WORD   $UNDEF  ;TRAP 43 RESERVED
        .WORD   READ17  ;TRAP 44
        .WORD   $UNDEF  ;TRAP 45 RESERVED
        .WORD   STEXCT  ;TRAP 46
        .WORD   XQT     ;TRAP 47
        .WORD   MEMRST  ;TRAP 50     
        .WORD   RSTMBX  ;TRAP 51
        .WORD   $UNDEF  ;TRAP 52 RESERVED
        .WORD   $UNDEF  ;TRAP 53 RESERVED
        .WORD   $UNDEF  ;TRAP 54 RESERVED
        .WORD   $UNDEF  ;TRAP 55 RESERVED
        .WORD   $UNDEF  ;TRAP 56 RESERVED
        .WORD   $UNDEF  ;TRAP 57 RESERVED
        .WORD   $UNDEF  ;TRAP 60 RESERVED
        .WORD   CRRSTD  ;TRAP 61
        .WORD   $UNDEF  ;TRAP 62 RESERVED
        .WORD   CRRONE  ;TRAP 63
        .WORD   INVAL   ;TRAP 64


;SEQ248

        .WORD   $UNDEF  ;TRAP 65 RESERVED
        .WORD   $UNDEF  ;TRAP 66 RESERVED
        .WORD   $UNDEF  ;TRAP 67 RESERVED
        .WORD   $UNDEF  ;TRAP 70 RESERVED
        .WORD   $UNDEF  ;TRAP 71 RESERVED
        .WORD   SOBAC   ;TRAP 72
        .WORD   $UNDEF  ;TRAP 73 RESERVED
        .WORD   PNTUML  ;TRAP 74
        .WORD   CMP.E   ;TRAP 75
        .WORD   CMP.F   ;TRAP 76
        .WORD   $UNDEF  ;TRAP 77  RESERVED
        .WORD   $UNDEF  ;TRAP 100 RESERVED
        .WORD   $UNDEF  ;TRAP 101 RESERVED
        .WORD   $UNDEF  ;TRAP 102 RESERVED
        .WORD   $UNDEF  ;TRAP 103 RESERVED
        .WORD   $UNDEF  ;TRAP 104 RESERVED
        .WORD   CSHPAG  ;TRAP 105
        .WORD   $UNDEF  ;TRAP 106 RESERVED
        .WORD   $UNDEF  ;TRAP 107 RESEVED
        .WORD   CMEMEN  ;TRAP 110
        .WORD   $UNDEF  ;TRAP 111 RESERVED
        .WORD   $UNDEF  ;TRAP 112 RESERVED
        .WORD   ACSCAT  ;TRAP 113
        .WORD   ACLOAD  ;TRAP 114
        .WORD   BACKPL  ;TRAP 115
        .WORD   $UNDEF  ;TRAP 116 RESERVED
        .WORD   $UNDEF  ;TRAP 117 RESERVED
        .WORD   $UNDEF  ;TRAP 120
        .WORD   $UNDEF  ;TRAP 121 RESERVED
        .WORD   $UNDEF  ;TRAP 122 RESERVED
        .WORD   FNDM16  ;TRAP 123
        .WORD   SAVMCN  ;TRAP 124
        .WORD   PNTID   ;TRAP 125
        .WORD   GETVER  ;TRAP 126
        .WORD   PNTVER  ;TRAP 127
        .WORD   $UNDEF  ;TRAP 130 RESERVED


;SEQ249

.REM    %
        SUBROUTINE TO MAKE SURE THAT EXAM/DEPOSIT, EXECUTE, OR PROGRAM
RUN FINISHED UP CORRECTLY.  CHECKS C-BIT.  RETURNS IF CLEAR, ELSE DOES
ERROR WITH MESSAGE DEPENDING ON ENTRY POINT (CHKED, CHKX, OR CHKP).
        %
CHKED:  BCS     1$              ;BR IF ANY ERROR(S)
        RTS     PC              ;ELSE RETURN TO CALLER
1$:     MOV     #ERRED,R0       ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CCODE
CHKX:   BCS     1$              ;BR IF ERR BIT SET
        RTS     PC              ;ELSE RETURN
        
1$:     MOV     #ERRX,R0        ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKP:   BCS     1$              ;BR IF CARRY SET...ERR
        RTS     PC              ;ELSE RET
1$:     MOV     #ERRP,R0        ;POINT TO ERROR MESSAFE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKCOM:ERRCOM   PNTAL           ;PRINT ERROR MESSAGE
        ERRMSG  <\REAL ERROR PC: >

        POP     R0              ;GET REAL ERR PC

        SUB     #4,R0           ;ADJ
        ERRCOM  PNTOCT          ;PRINT IT
        TST     R5              ;CHK SUBTEST # FOR REASONABLE VAALUE
        BLE     1$              ; .LE. 0... NG
        CMP     R5,#3000
        BGT     1$              ;NG
        ERRMSG  <  SUBTEST: >

        MOV     R5,R0           ;SUBTEST # TO PARAM REG
        ERRCOM  PNTDEC          ;PRINT IT
1$:     ERROR

        ERRED:  .ASCIZ  %EXAMINE/DEPOSIT ERROR%
        ERRX:   .ASCIZ  %INSTRUCTION EXECUTE ERROR%
        ERRP:   .ASCIZ  %PROGRAM DIDN'T HALT%
        .EVEN


;SEQ250

.REM    %
        SUBROUTINE CGOTO JUMPS TO THE NTH ADDRESS FROM A LIST OF ADDRESSES,
WHERE THE N COMES FROM R0.  A VALUE OF 0 IN RO WILL CAUSE A JUMP
TO THE FIRST ADDRESS IN THE LIST.  CGOTO ALSO CHECKS THE RANGE OF THE 
JUMP INDEX VS. THE SIZE OF THE LIST.
        %
CGOTO:  CMP     R0,(R5)+        ;CHK NCX AGAINST UPPER LIMIT
        BGT     1$              ;BR IF TOO HIGH
        ASL     R0              ;DOUBLE IT TO MAKE IT WORD INDEX
        BLT     1$              ;ERR IF <0
        ADD     R0,R5           ;CALC ADR WD ADR
        MOV     (R5),R5         ;SET RETURN ADR 
        RTS     R5              ;RETURN TO DESIRED ADDRESS
1$:     ERRMSG  <REAL ERR PC=>

        MOV     R5,R0
        ERRCOM  PNTOCT
        ERROR   <CGOTO PARAM ERROR>


;SEQ251

.REM    %
        ROUTINE TO REPORT BIT ERROR FOR TBIT PDP-10 BIT TEST
        %
BITERR: BNE     1$              ;FIND OUT BIT FLAVOR
        CLR     R0              ;WAS A ZERO
        BR      2$      
1$:     MOV     #200,R0         ;WAS A ONE
2$:     PUSH    <R1,R3>


        MOV     ERSP..,R3               ;GET ERR STACK POINTER
        MOV     #FT9,(R3)+              ;STORE FORMAT TYPE
        BISB    DFSAVE,R0               ;GET DIAG PN
        MOVB    R0,(R3)+                ;STACK BYTE
        MOVB    ERBIT,(R3)+             ;STACK BIT NBR IN LEFT
        MOV     R3,ERSP..               ;SAVE POINTER
        POP     <R3,R1>


        RTS     R5              ;RETURN


;SEQ252

.SBTTL          COMPARE ROUTINES
.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON
OF 5-BYTES OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,MSK36R
        R2 = POINTER TO MASK (0S IMPLY TEST)
        R3 = POINTER TO EXPECTED DATA
        R4 = POINTER TO ACTUAL DATA

%
MSK36R: PUSH    <R1,R5>


        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #5,R0           ;LOOP COUNT
1$:     MOVB    (R3)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R2),R1         ;MASK IT
        MOVB    (R4)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R2)+,R5        ;MASK IT
        CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGT     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     3$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R2           ;RESOTRE MASK POINTER
        MOV     R2,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R4           ;RESTORE ACTUAL POINTER
        MOVB    (R4)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        SUB     #5,R3           ;RESTORE POINTER TO EXPECTED
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
3$:     POP     <R5,R1>


        RTS     R5              ;RETURN

FFLAG:  .WORD                   ;FAULT FLAG


;SEQ253

.REM    %
        36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).
USES MSK36R.
CALL IS:
        JSR     R5,MASK36
        ENTRY+2 = POINTER T MASK (OS IMPLY TEST)
        ENTRY+4 = POINTER TO EXPECTED DATA
        ENTRY+6 = POINTER TO ACTUAL DATA
%
MASK36: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     (R5)+,R4        ;ACTUAL POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM THE TEST
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN


.REM    %
        36-BIT DTE-20 DATA COMPARE ROUTINE (TRAILING PARAMETERS)
USES MSK36R.
CALL IS:
        JSR     R5,MSKDAI
        ENTRY+2 = POINTER TO MASK
        ENTRY+4 = POINTER TO EXPECTED DATA
%
MSKDAT: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;DO COMPARISON
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN


;SEQ254

.SBTTL          36-BIT ERROR PARSER  06-AUG-75
.REM    %
RANGE - ROUTINE TO TEST THE ERROR STACK TO DETERMINE THE BIT RANGE
OF 36-BIT DATA PATH ERRORS.  THE CALL IS JSR R5,RANGE.  REGISTER
R3 MUST POINT TO THE FTM36 FORMAT ENTRY ON THE ERROR STACK.
RETURNS AN INDEX OF BIT POSITION, RANGES IN R0.  INDEXES ARE AS
FOLLOWS:
        0:      BITS 30-35
        2:      BITS 27-29
        4:      BITS 24-26
        6:      BITS 18-23
        10:     BITS 12-17
        12:     BITS 09-11
        14:     BITS 06-08
        16:     BITS 00-05
        20:     BOTH HALVES
        22:     LOWER HALF
        24:     UPPER HALF
%
RANGE:  REGSAV                  ;SAVE REGISTERS
        CMP     (R3)+,#FTM36    ;FORMAT CORRECT?
        BNE     2$              ;NO, FATAL ERROR
        CLR     R4              ;CLEAR INDEX
1$:     JSR     PC,RANCOM       ;COMPARE A BIT RANGE
        BNE     3$              ;MISMATCH FOUND
        INC     R4              ;NEXT BIT RANGE
        INC     R4              
        CMP     R4,#20          ;ALL DONE?
        BLT     1$              ;NO, ERROR STACK O.K.
2$:     FATAL                   ;ERROR STACK ERROR
3$:     TST     R4              ;BITS 30-35?
        BEQ     4$              ;YES, TEST LOWER HALF
        CMP     R4,#10          ;BITS 12-17?
        BNE     5$              ;NO,SET INDEX & RETURN
        MOV     R4,TEM.         ;SAVE INDEX
        MOV     #16,R4          ;UPPER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 0-5
        BEQ     6$              ;NOT UPPER HALF
        MOV     #24,TEM.        ;SET INDEX = UPPER HALF
        BR      6$              ;CLEANUP & RETURN
4$:     MOV     R4,TEM.         ;SAVE INDEX
        MOV     #6,R4           ;LOWER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 18-23
        BEQ     6$              ;NOT LOWER HALF
        MOV     #22,TEM.        ;SET INDEX = LOWER HALF
        MOV     #10,R4          ;BOTH HALVES TEST
        JSR     PC,RANCOM       ;CHK BITS 12-17
        BEQ     6$              ;LOWER HALF
        MOV     #20,TEM.        ;SET INDEX = BOTH HALVES
        BR      6$              ;CLEANUP & RETURN
5$:     MOV     R4,TEM.         ;GET INDEX
6$:     REGRST                  ;RESTORE REGISTERS
        MOV     TEM.,R0         ;GET INDEX
        RTS     R5              ;RETURN


;SEQ255

        ;SUBROUTINE TO COMPARE ACTUAL & EXPECTED FOR THE RANGE
        ;SPECIFIED FOR THE INDEX VALUE IN R4.

RANCOM: PUSH    R4

        MOV     BRCNT(R4),SPCNT ;GET SHIFT COUNT
        MOV     R3,R4           ;GET ERROR STACK POINTER
        INC     R4              ;POINT TO ACTUAL
        INC     R4              
        JSR     PC,RANPOS       ;GET MASK & POSITION ACTUAL
        PUSH    R0              ;SAVE SHIFTED ACTUAL

        JSR     PC,RANPOS       ;GET, MASK & POSITION EXPECTED
        POP     <R1,R4>         ;RESTORE ACTUAL & INDEX


        MOV     BRMASK(R4),R2   ;GET MASK
        BIC     R2,R0           ;MASK EXPECTED
        BIC     R2,R1           ;MASK ACTUAL
        CMP     R0,R1           ;COMPARE THEM
        RTS     PC              ;RETURN

;TAKES THE DATA POINTED TO BY R4, MASKS IT & RETURNS THE
;BIT RANGE DESIRED RIGHT JUSTIFIED IN R0.
RANPOS: MOV     (R3),R5         ;GET MASK POINTER
        CLR     R0              ;BITS 20-35
        JSR     PC,RANP0        ;GET & MASK 28-35
        JSR     PC,RANP0        ;GET & MASK 20-27
        CLR     R1              ;BITS 4-19
        JSR     PC,RANP1        ;GET & MASK 12-19
        JSR     PC,RANP1        ;GET & MASK 4-11
        CLR     R2              ;BITS 0-3
        BISB    (R4)+,R2        ;SET 0-3
        BICB    (R5),R2         ;MASAK 0-3
        MOV     SPCNT,R5                ;GET SHIFT COUNT
1$:     DEC     R5              ;SHIFT DONE?
        BLT     2$              ;YES, RETURN
        ASR     R2              ;NO, SHIFT 3 WORDS RIGHT
        ROR     R1              ;
        ROR     R0
        BR      1$              ;LOOP AGAIN
2$:     RTS     PC              ;DATA IN R0, RETURN


RANP0:  BISB    (R4)+,R0        ;SET A BYTE
        BICB    (R5)+,R0        ;POSITION IT
        SWAB    R0              ;POSITION IT
        RTS     PC

RANP1:  BISB    (R4)+,R1        ;SET A BYTE
        BICB    (R5)+,R1        ;MASK A BYTE
        SWAB    R1              ;POSITION IT
        RTS     PC


;SEQ256

        ;TABLE OF SHIFT COUNT TO RIGHT JUSTIFY BITS LISTED

BRCNT:  .WORD   0       ;30-35
        .WORD   6.      ;27-29
        .WORD   9.      ;24-26
        .WORD   12.     ;18-23
        .WORD   18.     ;12-17
        .WORD   24.     ;09-11
        .WORD   27.     ;06-08
        .WORD   30.     ;00-05

        ;TABLE OF BIT CLEAR MASKS FOR EACH BIT RANGE

BRMASK: .WORD   177700  ;30-35
        .WORD   177770  ;27-29
        .WORD   177770  ;24-26
        .WORD   177700  ;18-23
        .WORD   177700  ;12-17
        .WORD   177770  ;09-11
        .WORD    177770     ;06-08
        .WORD   177700  ;00-05


;

;SEQ257


.SBTTL          ERROR STACK COMPARE ROUTINES  22-SEP-75
.REM    %
        ROUTINES TO TEST THE ERROR STACK FOR THE PRESENCE OF DIAGNOSTIC
FUNCTION BIT ENTRIES OF FORMAT TYPE FT8 OR FT9.  SETS A BIT
IN A UML TABLE FOR EACH DIAGNOSTIC FUNCTION BIT FOUND TO CORRESPOND
TO A SPECIFIED LIST.  THE CALL IS JSR R5,CMP.E TO TEST ALL LIST
ENTRIES AND CMP.F TO SCAN FOR THE FIRST ERROR.  THE TRAILING
PARAMETER IS A POINTER TO A BYTE TABLE OF DIAGNOSTIC FUNCTIONS
AND BIT NUMBERS TO BE TESTED.  THE END OF THE TABLE IS DESIGNATED
BY SETTING BIT 7 OF THE LAST BYTE.  R0 MUST POINT TO THE ERROR
STACK FORMAT ENTRY OF FORMAT TYPE FT8 OR FT9.  THE C-BIT IS SET
AND A POINTER TO THE UML TABLE IS RETURNED IN R0 IF ANY MATCH IS
FOUND:  OTHERWISE R0 IS UNCHANGED.
%
CMP.E:  MOVB    #-1,EFLAG       ;SET ALL ERRORS FLAG
        BR      CMP.G           ;
CMP.F:  CLRB    EFLAG           ;CLEAR ALL ERRORS FLAG
        
CMP.G:  MOV     R0,DIF.         ;SAVE ERROR STACK POINTER
        MOV     (R5)+,TEM.      ;GET SPEC TABLE POINTER
        REGSAV
        MOV     TEM.,R4         ;GET SPEC TABLE POINTER
        CLRB    ISOFLG          ;CLEAR UML MATCH FLAG
        CLR     ISOUML          ;CLEAR UML TABLE
        CLR     ISOUML+2        ;
        CLR     ISOUML+4        ;
        CLR     ISOUML+6        ;
1$:     MOVB    (R4)+,R0        ;GET SPEC TABLE ENTRY
        BIT     #100,R0         ;DIAG. FN. OR BIT?
        BEQ     2$              ;BIT
        MOVB    R0,DFD8         ;SAVE FUNCTION
        BR      1$              ;GET BIT
2$:     BIC     #177600,R0      ;CLEAR END BIT
        CLRB    FT8DUN         ;CLEAR ERROR STACK DONE FLAG
        MOV     DIF.,R5         ;GET ERROR STACK POINTER
        CLR     FT9FLG          ;
        CMP     (R5)+,#FT8      ;FORMAT TYPE 8?
        BEQ     3$              ;YES
        MOV     #2,FT9FLG       ;
        CMP     -2(R5),#FT9     ;FORMAT TYPE 9?
        BEQ     3$              ;YES
        FATAL                   ;IMPROPER FORMAT



;SEQ258

3$:     MOV     FT9FLG,R1       ;GET FORMAT FLAG
        JSR     PC,@TSTERS(R1)  ;COMPARE AN ERROR STACK ENTRY
        BNE     4$              ;NO MATCH FOUND
        MOVB    FT8DF,R0        ;GET DIAGNOSTIC FUNCTION
        MOVB    R0,ISOFLG       ;SET UML FLAG
        SR      R0,2            ;DIVIDE DIAG. FN. BY 8


        BIC     #177761,R0      ;
        MOV     R0,DFD8         ;SAVE FOR SBOARD
        JSR     R5,SBOARD       ;SET PROPER BIT IN UML TABLE
                ISOUML          ;
        TSTB    EFLAG           ;ALL ERRORS?
        BNE     5$              ;YES, CONTINUE SCAN
        BR      6$              ;NO, CLEANUP & RETURN
4$:     TSTB    FT8DUN          ;DONE WITH STACK?
        BEQ     3$              ;NO, NEXT STACK ENTRY
5$:     TSTB    -1(R4)          ;DONE WITH SPEC TABLE?
        BPL     1$              ;NO, TRY NEXT
6$:     REGRST
        TSTB    ISOFLG          ;ANY FOUND?
        BEQ     7$              ;NO
        MOV     #ISOUML,R0      ;POINT TO UML TABLE
        SEC                     ;YES, SET C-BIT
7$:     RTS     R5              ;RETURN


;SEQ259

        ;COMPARE A FORMAT TYPE 8 ENTRY

ERSFT8: JSR     PC,GNSCT        ;GET ENTRY FROM ERROR STACK
        CMPB    DFD8,FT8DF      ;THIS DIAGNOSTIC  FUNCTION?
        BNE     6$              ;NO, RETURN
1$:     BITB    R3,(R1)         ;TEST EXPECTED = ACTUAL
        BEQ     2$
        BITB    R3,(R2)         ;
        BEQ     3$              ;NO, ERROR FOUND
        BR      4$              ;YES, MOVE ON
2$:     BITB    R3,(R2)         ;
        BEQ     4$              ;YES, MOVE ON
3$:     CMPB    R0,F8BTF        ;THIS BIT?
        BEQ     6$              ;YES, RETURN
4$:     ASR     R3              ;NEXT BIT
        BNE     5$              ;DONE WITH BYTE?
        BISB    #200,R3         ;YES, START NEXT
        DEC     R1              ;
        DEC     R2              ;
5$:     INC     F8BTF           ;INCREMENT BIT #
        CMPB    F8BTF,F8BTL    ;LAST BIT DONE?
        BLE     1$              ;NO, KEEP ON A PLUGGIN
6$:     RTS     PC              ;RETURN


        ;COMPARE A FT9 ENTRY

ERSFT9: MOVB    (R5)+,FT8DF     ;GET DIAG FN.
        BPL     1$              ;MAKE IT POSITIVE
        NEGB    FT8DF           ;
1$:     MOVB    (R5)+,F8BTF     ;GET BIT
        BMI     2$              ;DONE?
        INCB    FT8DUN          ;YES, SET FLAG & DO COMPARE
        BR      3$              ;
2$:     BICB    #BIT7,F8BTF     ;NO, CLEAR FLAG BIT
3$:     CMPB    DFD8,FT8DF      ;THIS DIAG FN.?
        BNE     4$              ;NO, RETURN
        CMPB    R0,F8BTF        ;COMPARE BITS
4$:     RTS     PC              ;RETURN

TSTERS:         ERSFT8          ;ENTRY POINT FOR FT8
                ERSFT9          ;ENTRY POINT FOR FT9
ISOFLG: .BYTE   0               ;UML TABLE SET FLAG
EFLAG:  .BYTE   0               ;ALL ERRORS FLAG
FT9FLG: .WORD   0               ;SET FOR FT9

DFSAVE: .WORD   0               ;LAST DIAG FN

ISOUML: .WORD   0,0,0,0         ;UML TABLE


;SEQ260

.REM    %
CSHPAG
        WRITES ONE PAGE OF DATA.  TRAILING ARGUMENTS ARE A POINTER TO A
        36-BIT DATA WORD AND THE PHYSICAL
        PAGE NUMBER.
        %

CSHPAG: MOV     (R5)+,R0        ;GET DATA PTR
        MOV     #CPGDAT,R1
1$:     MOVB    (R0)+,(R1)+
        CMP     R1,#CPGDAT+5
        BNE     1$
        MOV     (R5)+,R0        ;GET PHYS PAGE
        ASL     R0
        MOVB    R0,CPGADR+1
        SWAB    R0
        MOVB    R0,CPGADR+2
        LOAD    1,CPGCOD,8.
        BCC     15$
        ERRORA  LODERR          ;CODE FAILED TO LOAD
15$:    RUN     1
        BCC     2$              
        ERRORA  ERRP            ;PROGRAM TIMEOUT
2$:     RTS     R5
CPGCOD: I10     XCT     0,,5    ;EXTENDED ADDRESS


        I10     AOS             0,,6


        I10     SOJG    10,,1


        I10     JRST    4,,1


        I10     MOVEM   7,,0,6


CPGADR: WD36    0,0,0


CPGDAT: WD36    0,0,0


;SEQ261

        WD36    0,0,1000


        .EVEN


;SEQ262

        .SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #$TRAP,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   0               ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   1               ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN


;SEQ264

.SBTTL          PROGRAM PATCHER JAB29857        09-SEO-76  EDIT#11

;-----THIS IS A SMALL SUBROUTINE TO AID IN THE PATCHING OF PROGRAM.
;       IT IS STARTED VIA A KLDCP 'SE<ADR>' COMMAND.  FIRST IT ASKS FOR
;       ADDITIONS TO THE PATCH AREA, THEREAFTER IT REQUESTS AN ADR.
;       ANY NON-NUMERIC INPUT TERMINATES THE CURRENT ADR CHAIN.
$PATCH: JSR     R5,PATCH        ;<START HERE FOR SE<ADR> TYPE START>
        PRGHLT
        BR      $PATCH          ;LOOP ON 'HC' COMMAND
PATCH:  MOV     #$$FF,R3        ;PTR SAVES A WORD
        MOV     (R3),R1         ;POINT THE ADR REG AT THE PATCH AREA
        CLR     R2              ;IND ERR MSG NOT SENT
        INC     R1              ;MAKE SURE IT'S AN EVEN ADR
        BR      10$             ; (BR TO BIC SAVES A WORD)
1$:     CMP     R1,#70000       ;IN OVERLAY AREA?
        BLO     2$              ;BR IF NO
        TST     R2              ;HAVE WE SENT MESSAGE?
        BNE     2$              ;BR IF YES...DONT RESEND IT
        PMSG    <WARNING: IN OVERLAY AREA\>

        INC     R2              ;INDICATE ERR MSG SENT
2$:     MOV     R1,R0           ;GET & PRINT <ADR>/<CONTENTS>
        PNTOCT,PNTBAK,PSLASH
        MOV     (R1),R0
        PNTOCT
        PMSG    <    >

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     4$              ;BR ON NON-NUMBER...END OF INPUT
3$:     MOV     R0,(R1)+        ;PUT DATA IN MEMORY
        CMP     R1,(R3)         ;SHD WE SAV UPDATED ADR?
        BLOS    1$              ;NO
        MOV     R1,(R3)         ;SAV UPDATED ADR
        BR      1$              ;LOOP FOR NEXT DATA WORD
4$:     CLR     R2              ;INDICATE MUST REPRINT ERR MSG IF NEC.
        PMSG    <ADDRESS: _>

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     9$              ;BR ON NON-NUMBER...END OF INPUT
5$:     MOV     R0,R1           ;MOVE ADR TO ADR REG
10$:    BIC     #BIT0,R1        ;FORCE TO EVEN ADR
        BR      1$              ;GO GET DATA INPUT
8$:     PMSG    <?\>            ;PRINT ERR INDICATOR

7$:     TTILNW,TTISDL           ;WAIT FOR INPUT, BYPASS JUNK
        BCS     9$              ;BR ON NO INPUT
        TTIOCT                  ;GET NUMBER
        BCS     8$              ;BR ON BAD #
9$:     RTS     R5              ;RETURN


;SEQ265

.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN


;SEQ266

SPCRST: MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/ LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES,SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT                  ;ENABLE CONDITIONS
       
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;NO
        JSR     R5,BRST1        ;YES,BUTST 34 TICKS
4$:     RTS     PC              ;RETURN


;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5


;SEQ268


.SBTTL          ROUTINE TO CHANGE THE CURRENT AC BLOCK

.REM    %
        SUBROUTINE ACBLK SETS THE CURRENT AC BLOCK NUMBER ACCORDING TO
        THE VALUE IN R0 WITHOUT USING AN AC OR MEMORY.  PREVIOUS AC
        BLOCK NUMBER IS SET TO ZERO.
%

ACBLK:  MOV     R5,BRKPC        ;FOR FUNC BREAKPOINT
ACBLK1: BIC     #177770,R0      ;SHUT OF JUNK BITS
        SL      R0,3            ;POSITION



        MOVB    R0,2$+3         ;AC BLK # TO WORD
        STEXCT   1$              ;START DATAO PAG
        MOV     #18.,R0         ;BURST COUNT
        JSR     R5,BRST1        ;SKIP SOME TICKS TO SAVE TIME
        JSR     R5,FIND1        ;TICK UNTIL AR LOADED (WITH GARBAGE)
        S10.    132,23,1        ;"CON AR LOADED H"
        BCS     3$              ;ERR IF NOT FOUND
        DFXCTT,CECLK            ;BRING EBOX CLOCK DOWN
        DFWRTT,2$,LDAR          ;PUT THE DATA WE REALLY WANT IN THE AR
        DFXCTT,STRCLK           ;RESTART THE CLOCK TO FINISH UP
3$:     RTS     R5              ;DONE...RETURN
1$:     IO10    DATAO,PAG,,0    ;INSTR TO SET AC BLOCK NUMBER

2$:     WD36    4000,0040,0000  ;WD USED BY THE ABOVE


        .EVEN


;SEQ269

.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT


;SEQ272

.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        ERROR                   ;EBOX ERROR


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15


;SEQ282

.REM    %
        
-----JAB29857 19-FEB-75  SUBROUTINE TO PERFORM THE SAME FUNCTION
        AS "STPCON" WITH THE EXCEPTION THAT, HAVING ONCE
        ESTABLISHED THE BURST COUNT, IT MAKES SURE THAT THE EVENT
        OCCURS AGAIN AT THE END OF THE BURST ON SUBSEQUENT CALLS.
%

SOBAC:  MOV     R5,BRKPC                ;SAV PC FOR FUNC. BRKPT.
SOBAC1: MOV     (R5)+,R0        ;GET BURST CNT
        BLT     1$              ;BR ON NO BURST CNT YET
        DEC     R0              ;BURST FOR 1 CLK LESS THAN CNT
        JSR     R5,BRST1        ;BURST
        MOV     (R5)+,R0        ;FUNCTION TO RO FOR 'EVENT1'
        JSR     R5,EVENT1       ;CLK & TEST FOR OCCURENCE OF EVENT
        RTS     R5              ;RET W/ C-BIT: CLR=FOUND, SET=NOT FOUND
1$:     MOV     (R5)+,R0        ;GET FUNCTION FOR 'FIND'
        JSR     R5,FIND2        ;STEP UNTIL EVENT OCCURS
        BCS     2$              ;IF EVENT DIDNT OCCUR, DONT SAV BRST CNT
        MOV     R0,-4(R5)       ;ELSE SAV BRST CNT FOR FUTURE USE
2$:     RTS     R5              ;RET W/C-BIT SET/CLR AS ABOVE

.REM    %
        
-----A DYNAMIC-DATA CALLER FOR SOBAC.  DOES THE SAME THING, EXCEPT
        THAT IT SHUFFLES DATA PASSED AND RETURNED.  BURST COUNTS ARE
        ASSUMED IN A LIST POINTED TO BY BCLA.  UPDATES COUNT IN LIST
        AND ADDRESS IN BCLA IF SOBAC WAS SUCCESSFUL.
%
SOBACF: MOV     (R5)+,R0        ;ENTRY FOR STATIC FUNC #
DSOBAC: MOV     R5,BRKPC        ;SAV PC FOR FUNC BRK PNT
        MOV     R0,2$           ;MOV FUNC TO PARAM LST
        MOV     @BCLA,1$        ;MOV BURST CNT TO PARAM LIST
        JSR     R5,SOBAC1       ;GO AND DO SOBAC
1$:      000000                 ;BURST CNT TO BE SUPPLIED
2$:      000000                 ;FUNCTION TO BE SUPPLIED
          BCS   3$              ;ON FAILURE, DONT UPDATE ANYTHING
        MOV     BCLA,R0         ;SAV BURST CNT & UPDATED ADR...
        MOV     1$,(R0)+        ;W/0 MODFG C-BIT
        MOV     R0,BCLA
3$:     RTS     R5

BCLA:   .WORD   -1              ;BURST COUNT LIST ADDRESS
                                ;TO BE SUPPLIED BY CALLER


;SEQ283

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0


;SEQ285

.REM    %
        SUBROUTINE TO PERFORM A "RANDOM" LOAD OF THE KL10 AC'S.  EDIT#4
        METHOD OF CALL IS AS FOLLOWS:
        JSR     R5,ACLOAD
        .WORD   ACMASK,11-ADR
-----OR-----
        JSR     R5,ACSCAT
        .WORD   ACMASK,ADR1,ADR2,...,ADRN
        -----WHERE-----
        ACMASK SPECIFIES WHICH KL10 AC'S ARE TO BE LOADED: BIT 0 SET
        MEANS ACO GETS LOADED, ETC.
        A CALL TO ACLOAD SAYS THAT THE KL10 WORDS ARE CONTIGUOUS WITHIN
        PDP11 MEMORY, STARTING AT "11-ADR".
        A CALL TO ACSCAT SAYS THAT THE KL10 WORDS ARE SCATTERED IN PDP11
        MEMORY. AND ARE POINTED TO BY ADR1, ADR2, ETC., ON ADR/WORD.
        THE C-BIT IS CLEAR UPON RETURN FOR SUCCESSFUL COMPLETION.
        %

ACLOAD: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        MOV     (R5)+,R2        ;ADR OF LOAD STRING TO R2
        BR      ACLDCM          ;GO TO COMMON ROUTINE
ACSCAT: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        CLR     R2              ;INDICATE SCATTERED LOAD WORDS
ACLDCM: CLR     3$+2            ;SET KL10 ADR=AC0, CLR C-BIT
        DFXCTT,STRCLK           ;MAKE SURE CLOCK IS RUNNING
1$:     ROR     R1              ;MOV MASK BIT TO C-BIT
        BCC     4$              ;BR IF THIS AC IS NOT BE BE LOADED
        MOV     R2,3$+4         ;MOV PDP11 ADR TO DPOST ADR LIST
        BEQ     2$              ;BR IF NOT CORRECT ADR
        ADD     #5,R2           ;ELSE PT TO KL WD FOR NXT TIME
        BR      3$              ;GO DO THE DPOSIT
2$:     MOV     (R5)+,3$+4      ;FOR SCATTERED LOAD, MOV NXT ADR
3$:     DPOST,000000,000000     ;DEPOSIT (KL ADR & PDP11 ADR TO BE SUP.)
        BCC     4$              ;BR IF NO ERROR ON DEPOSIT
        ERRMSG  <REAL ERR PC=>

        MOV     R5,R0           ;RETURN PC TO PARAM REG
        ERRCOM  PNTOCT          ;RET PC TO ERR SKT
        ERROR   <AC PROGRAM LOAD ERR>

4$:     INC     3$+2            ;NXT KL ADR
        TST     R1              ;ANY MORE AC'S TO BE LOADED?


;SEQ286

        BGT     1$              ;BR IF YES
        POP     <R2,R1>         ;RESOTRE REGS


        RTS     R5

.REM    %
READ17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1

        MOV     #HDWEXA,R0       ;
        EXCT                    ;DO A SUB AC17 17
        MOV     #ZERO..,R0      ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1

        
        RTS     R5              ;RETURN


        
HDWEXA: I10     SUB AC17,,17


        .EVEN
EXAREA: WD36    0,0,0


        .EVEN

;SEQ287

.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;


;SEQ288

ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN


;SEQ289

.SBTTL          CACHE REFILL SUBROUTINES
.REM    %
REFILL - ROUTINE TO LOAD ANY REFILL ALGORITHM.
%
REFILL: MOV     R5,BRKPC        ;SAVE PC
REF1:   MOV     (R5)+,$REFPT    ;SAVE TABLE ADDRESS
        REGSAV
        CLR     $RFCNT          ;THE 5-DIGIT COUNT
        CLR     $RFADR          ;THE RAM ADDRESS
        MOV     $REFPT,R4       ;PTR TO TABLE OF DATA
        MOV     #9.,R3          ;CNT GROUPS OF 14 LOCS

1$:     MOV     #REFI1,R5       ;POINT TO BLKO TABLE
        JSR     PC,$RFMAK       ;BUILD 14 BLKO'S
        JSR     R5,LOAD         ;LOAD AC'S
        .WORD   1
        .WORD   -15.
        .WORD   REFI1
        JSR     R5,RUNPR1       ;DO IT
        .WORD   1               ;STARTING ADDRESS
        DEC     R3      
        BNE     1$              ;CONTINUE

        MOV     #REFI2,R5       ;POINT TO LAST 2 BLKO'S
        JSR     PC,$RFMAK       ;BUILD LAST 2
        JSR     R5,LOAD         ;LOAD THEM
        .WORD   15
        .WORD   -3
        .WORD   REFI2
        JSR     R5,RUNPR1       ;DO IT
        .WORD   15              ;STARTING ADDRESS

        REGRST
        RTS     R5

$RFMAK: JSR     PC,$RFBYT       ;GET DATA DIGIT
        JSR     PC,$RFMOD       ;PUT DATA ADDRESS IN BLKO
        INC     $RFADR          ;UP RAM ADDRESS
        ADD     #5,R5           ;NEXT BLKO
        CMP     R5,#REFI2+5.
        BLE     $RFMAK          ;DO MORE
        RTS     PC


;SEQ290

$RFMOD: MOV     $RFADR,R0       ;GET RAM ADDR
        ASL     R0
        ASL     R0
        MOVB    R0,(R5)
        SWAB    R0
        MOVB    R0,1(R5)        ;PUT IN ADDRESS

        SWAB    R2              ;SWAP DATA
        ASR     R2
        BISB    R2,1(R5)        ;BIT 20
        SWAB    R2
        MOVB    R2,2(R5)        ;BITS 18,19
        RTS     PC

$RFBYT: TST     $RFCNT          ;NEED A WORD?
        BNE     1$              ;IF NOT
        MOV     (R4)+,R1        ;GET 5 DATA DIGITS
        ROL     R1              ;LEFT JUSTIFY
        MOV     #5,$RFCNT       ;SET COUNT

1$:     CLR     R2
        CLC
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2              ;NOW R2 HAS NEW DATUM
        DEC     $RFCNT          ;COUNT IT
        RTS     PC


$REFPT: .WORD   0               ;REFILL DATA TABLE PTR
$RFCNT: .WORD   0               ;DIGIT COUNTER
$RFADR: .WORD   0               ;REFILL RAM ADDRESS CTR


;SEQ291

REFI1:  .REPT   12.
        IO10    BLKO APR,,0
        .ENDR

























REFI2:  .REPT   2.
        IO10    BLKO APR,,0
        .ENDR






        I10     JRST 4,,17


        .EVEN


;SEQ292

.REM    %
CRRSTD - ROUTINE TO LOAD STANDARD REFILL CODE
%
CRRSTD: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,REF1
        .WORD   REFSTD          ;PTR TO STANDARD TABLE
        RTS     R5

;CACHE REFILL RAM DATA TABLE FOR STANDARD CACHE OPERATION

REFSTD: .WORD   01234
        .WORD   56731
        .WORD   23212
        .WORD   37127
        .WORD   11276
        .WORD   56755
        .WORD   67032
        .WORD   30223
        .WORD   01234
        .WORD   56707
        .WORD   77000
        .WORD   74666
        .WORD   44643
        .WORD   13311
        .WORD   13077
        .WORD   70007
        .WORD   01234
        .WORD   56745
        .WORD   57454
        .WORD   70122
        .WORD   01210
        .WORD   56605
        .WORD   60456
        .WORD   54564
        .WORD   01234
        .WORD   56700


;SEQ293

.REM    %
CRRONE - ROUTINE TO LOAD A CACHE USE ALGORITHM TO ACCESS ONLY ONE
CACHE.
%
CRRONE: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LDREF1       ;LOAD CODE
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   2               ;STARTING ADDRESS
        RTS     R5              ;RETURN

LDREF1: PUSH    R1

        ROR     R0              ;POSITION CACHE TO USE
        ROR     R1              ;
        BIC     #177774,R0      ;
        MOV     R0,USEADR+2     ;PUT IN INDEX WORD
        BIC     #77777,R1       ;
        MOV     R1,USEADR       ;
        POP     R1

        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -6
        .WORD   USEADR
        RTS     R5

USEADR: WD36    0,0,0

        IO10    BLKO APR,,0,1   ;LOAD AN ADDRESS

        I10     ADDI AC1,,4     ;NEXT ONE
    
        I10     TRNE AC1,,774   ;DONE?

        I10     JRST,,,2        ;NO, LOOP AGAIN

        I10     JRST,4,,2       ;YES, HALT


;SEQ294

.SBTTL          CACHE SWEEP ROUTINES
        
.REM    %
INVAL - INVALIDATES THE CACHE.
%
INVAL:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CSHSWP
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   1               ;STARTING ADDRESS
        RTS     R5              ;RETURN

CSHSWP: IO10    DATAI CCA,,0


        IO10    CONSZ APR,,200000

        I10     JRST,,,2


        I10     JRST,4,,1


;SEQ295

.SBTTL          MEMORY CONFIGURATION SAVE & RESTORE
;FIND A MEMORY THAT RESPONDS AND SAVE ITS BASE ADDRESS.  IF 
;NO MEMORY IS FOUND WITH FOUR CONSECUTIVE REFERENCES WITHIN THE
;FIRST 256K THEN AN ERROR RETURN IS GIVEN.

FNDM16: PUSH    R1

        MOV     (R5)+,R1        ;GET ADDRESS
        LOAD    1,FND16K,17     ;LOAD AC PRGM (AC1-17)
1$:     RUNBIG  1,20            ;RUN IT, LONG TIMEOUT
        BCC     2$
        ERRORA  ERRP            ;AC CODE HUNG UP - DO 'ALL' CMD
2$:     READ17                  ;GET BASE ADDR
        MOVB    1(R0),(R1)+     
        MOVB    2(R0),(R1)      ;SAVE BASE FOR USERS
        BITB    #BIT2,(R1)+     ;VALID?
        BEQ     3$              ;BR IF O.K.
        SEC                     ;SET ERROR FLAG
        BR      4$
3$:     CLC                     ;CLEAR ERROR FLAG
4$:     POP     R1

        RTS     R5


MCBASA: 0


;SEQ296

FND16K: IO10    CONO,PAG,,0     ;1--CLEAR CACHE, PAGING


        I10     MOVEM,16,,100,17;2--WRITE -1


        I10     CAME,16,,100,17 ;3--COMPARE IT


        I10     JRST,0,,11      ;4--NO COMPARE, NEXT 16K PLEASE


        I10     AOS,0,,17       ;5--INDEX THRU NEXT 3
        

        I10     TRZN,17,,4      ;6--DONE 4 CONSECUTIVE?


        I10     JRST,0,,2       ;7--DO MORE CONSECUTIVE


        I10     JRST,4,,10      ;10-FOUND 4 CONSEC. - HALT


        I10     TRZ,17,,3       ;11-CLEAR ADR 34,35


        I10     ADDI,17,,40000   ;12-GO TO NXT 16K ADR
        

        I10     TLNN,17,,1      ;13-SKIP IF NO MORE TO DO


        I10     JRST,0,,2       ;14-ELSE GO & TRY AGAIN


        I10     JRST,4,,15      ;15-HALT - NONE FOUND

        WD36    7777,7777,7777  ;16- -1 FOR COMPARISON

        WD36    0000,0000,0000  ;17-INITIAL PAGE INDEX



        .EVEN

;SEQ297

.REM    %
        SAVMCN SAVES THE EXISTING MEMORY CONFIGURATION.  THE CONFIGURATION IS
ASSUMED TO BE VALID.  FOR MF20S, ONLY A MAP OF CONFIGURED, USABLE CONTROLLERS
IS KEPT.  THIS MEANS THAT IF POWER IS SHUT OFF THE CONFIGURATION IS DESTROYED.
A C-BIT SET RETURN IS DONE ONLY IS 2 MF20S RESPOND TO ADDRESS 0.  
A VARIABLE (TCWRTO) IS SET TO THE NUMBER OF THE CONTROLLER RESPONDING
TO ADDRESS C (DMA20 IS ASSUMBED IF NO MA20/MB20/MF20 HAS THAT ADDRESS).
        %

NUMCON=5                ;CURRENT MAXIMUM NUMBER OF CORE MEMORY CONTROLLERS

SAVMCN: PUSH    R1              ;SAV REG


;-----HERE TO RECORD STATE OF MA20,MB20/DMA20 MEMORY.

        LOAD    1,GTMCNF,13     ;LOAD AC PRGM (AC1-13)
        MOV     #CONTAB,R1      ;PTR TO CONF TABLE SAVES TIME & SPACE
        RUN     1
        BCS     2$              ;AC ROUTINE HUNG
1$:     READ17                  ;GET FUNCTION 0 RESULT
        MOVB    3(R0),(R1)+     ;INTERLEAVE BITS TO TABLE
        CONTIN                  ;DO FUNCTION 1
        BCS     2$              ;AC ROUTINE HUNG
        READ17                  ;GET FUNCTION 1 RESULT
        MOVB    (R0)+,(R1)+     ;REQUEST ENABLE BITS TO TABLE
        BIC     #170317,-2(R1)  ;CLR JUNK FROM INT & R0 EN BITS
        MOVB    (R0)+,(R1)+     ;MOV ADR BOUNDS STUFF
        MOVB    (R0)+,(R1)+     ;DITTO
         
        BIC     #140003,-2(R1)  ;CLR JUNK BITS FROM ADR BOUNDS
        CONTIN                  ;NEXT FUNCTION 0
        BCC     3$
2$:     ERRORA  ERRP            ;AC ROUTINE HUNG?
3$:     CMP     R1,#CONTAB+<4*NUMCON>   ;DONE WITH ALL CONTRS YET?
        BLO     1$              ;NO...KEEP GOING


;SEQ298

;-----THIS CODE GOES AND GETS MF20 INFO: USABLE MF20 & DESELECTED-AT-0 MAPS.

        LOAD    0,GMFUMP,20     ;LD AC 0-17
        RUN     0               ;RUN THE AC PRGM
        BCS     2$              ;BR ON ERR
        READ17                  ;GET RESULT DATA
        MOV     (R0)+,R1        ;USABLE MF20 MAP TO R1 (BIT0=MF20 #10, ETC)
        MOV     (R0),R0         ;GET DESELECTED-AT-0 MAP INTO R0        
        MOV     R1,UMFMAP       ;SAV USABLE MF20 MAP

;-----FIND OUT WHICH MF20,IF ANY, RESPONDS TO ADDRESS 0.

        COM     R1              ;CALC UNUSABLE MF20 MAP
        BIS     R1,R0           ;CALC UNUSABLE .OR. DESEL-AT-O MAP
        COM     R0              ;CALC USABLE .AND. SEL-AT-0 MAP
        BEQ     5$              ;NO MF20 RESPONDS AT 0.. GO TRY FOR MA20/MB20
        MOV     #7,R1           ;INI MF20 # FOR SEARCH THRU MAP IN R0
4$:     INC     R1              ;NXT MF20
        CLC     
        ROR     R0              ;IS THIS MF20 USABLE & SELECTED-AT-0?
        BCC     4$              ;NO.. TRY NXT
        BNE     10$             ;YES BUT THERE IS ANOTHER TOO.. ERROR! C SET RET
        BR      9$              ;OK, JUST 1 MF RESPONDS TO 0.. GO SAV ITS #

;----HERE TO FIND OUT WHICH MA20/MB20, IF ANY, RESPONDS TO ADDRESS 0.  IF NONE
;DOES THEN WE ASSUME THAT THE DMA20 IS RESPONDING TO 0.

5$:     CLR     R1              ;INI TABLE SRCH NDX
6$:     BIT     #37700,CONTAB+2(R1)     ;IS CONTR LO ADR BOUND AT 0?
        BNE     7$              ;NO.  TRY NEXT MA/MB
        BIT     #4000,CONTAB(R1)        ;DOES CONTR RESP TO RQ 0?
        BEQ     7$              ;NO. TRY NXT MA/MB
        TSTB    CONTAB(R1)      ;IS CONTR TURNED ON (IE INTRL NOT 0)?
        BNE     8$              ;YES.  THIS IS THE ONE, GO RECORD ITS #
7$:     ADD     #4,R1           ;ELSE LOOK AT NXT MA20/MB20
        CMP     R1,#12.         ;TRIED THEM ALL?
        BLE     6$              ;NO, LOOP.  IF YES, JUST ASSUME DMA20.
8$:     ASR     R1              ;DIVIDE NDX BY 4 TO GET CONTR #
        ASR     R1              

;-----HERE TO SET THE CONTROLLER NUMBER WHICH RESPONDS TO 0 AND EXIT.

9$:     MOV     R1,TCWRT0       ;SAV # OF THE CONTROLLER WHICH RESPONDS TO 0
        CLC                     ;IND NO ERROR
10$:    POP     R1              ;GET BACK REG SAVED EARLIER

        RTS     R5              ;RETURN TO CALLER


;SEQ299

;-----THE CORE MEMORY CONFIGURATION TABLE. 2 BYTES AND A WORD PER CONTROLLER.
CONTAB: .REPT   NUMCON
        .BYTE   000             ;THE INTERLEAVE BITS (00II0000)
        .BYTE   000             ;THE WORD REQUEST ENABLE BITS (0000RRRR)
        .WORD   000000          ;THE ADR BOUNDS BITS (00SSSSLLLLUUUU00)
        .ENDM

TCWRT0: .WORD   0               ;NUMBER OF THE CONTR WHICH RESPONDS TO 0.  IF NO
                                ;MA20/MB20/MF20 IS AT 0, THEN WE ASSUME DMA20.


;SEQ300

;-----AC PROGRAM TO READ SBUS DIAGS FROM DIFFERENT CORE MEMORY CONTROLLERS
;SO THAT THE EXISTING CONFIGURATION CAN BE DETERMINED.

GTMCNF: I10     SETZM,0,,16     ;1--


        I10     IOR,16,,12      ;2--


        IO10    SBDIAG,,,16     ;3--


        I10     JRST,4,,5       ;4--
   
        I10     AOS,0,,16       ;5--


        IO10    SBDIAG,,,16     ;6--


        I10     JRST,4,,10      ;7--


        I10     ADD,12,,13      ;10-


        I10     JRST,0,,1       ;11-


        WD36    0100,0000,0000  ;12-


        WD36    0200,0000,0000  ;13-


;-----THIS AC PROGRAM CREATES 2 MAPS:  ONE WHICH SAYS WHICH MF20S ARE USABLE,
;AND ANOTHER SAYING WHICH MF20S ARE DESELECTED AT ADDRESS 0.  THE BITS IN THE
;MAPS CORRESPOND POSITIONALLY.  IF THE MF20 IS NOT USABLE THEN THE DESELECTED
;BIT IS MEANINGLESS.  THE PROGRAM IS HARDCODED TO LOOK AT CONTROLLERS 10-17.
;THE TWO MAPS ARE BUILT IN AC17.  THE "USABLE" MAP IS IN BITS 28-35, BIT 35
;IS FOR MF20 #10.  34 IS FOR #11, ETC.  THE OTHER MAP IS IN  BITS 12-19.  THESE
;BIT POSITIONS ARE USED TO ERASE WORK DONE BY THE DPD-11.  A USABLE CONTROLLER
;IS (1) AN MF20, (2) IN SOFTRWARE STATE 2 OR 3, AND (3) IS NOT DISABLED.

GMFUMP: I10     LSH,17,,1               ;0-<START> SHIFT CTL/OUTPUT WD PRIOR TO NXT MF20


        IO10    SBDIAG,,,15             ;1-DO FCN 1 TO GET MF20 STATUS


        I10     LSH,16,,777767          ;2-GET STATUS INFO INTO RHE OF AC16


;SEQ301

        I10     CAIN,16,,500001 ;3-SKIP IF -USABLE (-MF20,-SS 2/3, OR DISABLED)


        I10     IORI,17,,1      ;4-ELSE MARK CONTR AS USABLE
        

        I10     HRRI,15,,12     ;5-TURN FCN 1 INTO FCN 12 FOR ADRESP RAM RD


        IO10    SBDIAG,,,15     ;6-RD ADRESP RAM WD 0

        I10     TLNE,16,,10     ;7 - SKIP IF DESFL BIT IS 0

        I10     IORI,17,,2000000        ;10-ELSE SET DESEL BIT IN MAP TOO


        I10     SUB,15,,14      ;11-TURN FCN 12 INTO FCN 1, NXT CONTR #


        I10     JUMPL,17,,0     ;12-LP TIL ALL MF20S DONE (AC17 BIT 00 = 0)


        I10     JRST,4,,0       ;13-HALT WHEN DONE


        WD36    0200,0000,0011  ;14-SUB FROM SBDIAG WD TO GET FCN 1, NXT MF


        WD36    3600,0000,0001  ;15-FCN 1 SBDIAG FOR HIGHEST MF20.. MODIFIED


        WD36    0000,0000,0000  ;16-FCN 1 & 12 RESULT GOES HERE


        WD36    7760,0000,0000  ;17-LHF IS CONTROL # OF LPS.  MAPS BUILT HERE


        .EVEN


;SEQ302

.REM    %
        ROUTINE TO RESTORE A PREVIOUSLY SAVED MEMORY CONFIGURATION AND CLEAR
MEMFLG.  EACH TEST WHICH NEEDS MEMORY SHOULD CALL THIS ROUTINE.  IF A PREVIOUS
TEST HAS CALLED THIS ROUTINE, THEN A QUICK EXIT IS TAKEN.  IF MEMORY WAS NOT
AVAILABLE FOR SAVING THEN THIS ROUTINE PRINTS A MESSAGE AND EXITS.
        %


CMEMEN: TST     MEMFLG          ;WAS MEMORY OFF LINE?
        BEQ     2$              ;BR IF NOT.. DONT BOTHER WITH RESTORE
        CLR     MEMFLG          ;CLEAR THE FLAG
        RSTMBX                  ;CLEAR THE HDW DISABLE
        TST     IMEMCF          ;WAS THERE A MEMORY?
        BEQ     1$              ;NO.. PUNT RIGHT NOW
        JSR     R5,RSTMCN       ;ELSE ATTEMPT TO RESTORE MEM
        BCC     2$              ;BR IF RESTORE OK
1$:     PFORCE                  ;TELL USER OFF
        PMSG    <CAN'T PROCEED BEYOND TEST >

        MOV     TSTNUM,R0       ;GET TEST NBR
        DEC     R0              ;MAKE PREVIOUS
        PNTDEC
        PMSG    < WITHOUT MEMORY!\>

        ERREOP                  ;RETIRE
2$:     RTS     R5              ;RETURN


;SEQ303

.REM    %
        RSTMCN RESTORES THE MEMORY CONFIGURATION SVED BY SAVMCN.  ONLY DOES A
C-BIT SET RETURN IF MF20 CONFIGURATION WAS BLOWN BY POWER OFF AND WE DO NOT HAVE
A CORE MEMORY AT ADDRESS 0.
        %

RSTMCN: PUSH    <R3,R4,R5>      ;SAVE REGS


        
        LOAD    1,7$,3          ;LOAD THE AC PROGRAM (AC1-3)
        CLR     R5              ;INIT CONTROLLER NUMBER
        MOV     #CONTAB,R3      ;CONF TABLE PTR INIT
;-----SBUS DIAG FUNCTION 0 SETUP
1$:     MOV     #CNFWD0+3,R4    ;DIAG WD PTR SAVES TIME & SPACE
        MOVB    (R3)+,(R4)      ;INTERLEAVE BITS TO WORD
        BISB    (R3)+,(R4)      ;WD RQ BITS TO WORD
        PUSH    R5              ;SCRATCH CONTR # ON STACK

        ROR     (SP)            ;SPLIT CONTR # 4-1
        BCC     2$              ;BR IF EVEN CONTR
        BISB    #200,(R4)       ;ELSE SET ODD CONTR BIT IN WD
2$:     BISB    #100,(R4)+      ;SET CLR 0-5 BIT IN WD
        MOVB    (SP)+,(R4)      ;HI ORD 4 BITS OF CONTR # TO WD


;SEQ304

;-----SBUS DIAG FUNCTION 1 WORD SETUP
        TST     (R4)+           ;SKIP DIAG WD STUFF TO LEAVE ALONE
        MOV     (R3)+,(R4)      ;MOV ADR BOUNDS BITS TO WD
        BIS     #2,(R4)+        ;SET LOAD BOUNDS BIT IN WD
        MOV     R5,(R4)         ;CONTR # TO WORD
        SWAB    (R4)            ;POSIITON IT PROPERLY
        ASR     (R4)
;-----LOAD SBUS DIAG WORDS AND RUN PROGRAM
        DPOST,4,CNFWD0          ;AC4
        DPOST,6,CNFWD1          ;AC6
        RUN     1
        BCC     4$              
3$:     ERRORA  ERRP            ;AC PROGRAM DIDN'T HALT
;-----SELECT NEXT CORE MEMORY CONTROLLER OR GO ON TO MF20S.
4$:     INC     R5              ;BUMP CONTR #
        CMP     R5,#NUMCON      ;DONE YET?
        BLT     1$              ;NO...CONTINUE

;-----THIS SECTION REENABLES ANY MF20S WHICH EXISTED AND WERE USABLE WHEN
;SAVMCN WAS CALLED.

        LOAD    1,RSTMFP,16     ;LOAD THE AC PROGRAM
        RUN     1               ;RUN IT
        BCS     3$              ;BR ON ERROR
        DFPC                    ;GET THE HALTED PC
        TST     (R0)            ;PC 0 OR NOT 0?
        BEQ     5$              ;0.. NORMAL COMPLETION
        CMP     TCWRT0,#4       ;IS THE CONTR WHICH RESPONDS TO 0 A CORE MEM?
        BLE     5$              ;YES..WE STILL HAVE MEM AT 0
        SEC                     ;MF20S POWERED OFF.. CONFIG BLOWN
        BR      6$              ;EXIT WITH C-BIT SET
5$:     CLC
6$:     POP     <R5,R4,R3>      ;RESTORE REGS


        RTS     R5


;SEQ305

;-----AC PROGRAM TO DO SBDIAGS TO SET CORE MEM CONF.
        .ODD            ;FORCE EVEN ALLIGNMENT FOR CNFWD0
7$:     IO10    SBDIAG,,,4      ;1--DO SBUS DIAG FUNC 0


        IO10    SBDIAG,,,6      ;2--DO SBUS DIAG FUNC 1


        I10     JRST,4,,1       ;3--HALT


CNFWD0: WD36    0100,4000,0000  ;4--SBUS DIAG FUNCTION 0 WORD


                                ;5--
CNFWD1: WD36    0000,0000,1001  ;6--SBUS DIAG FUNCTION 1 WORD


                                ;7--

;-----THIS AC PROGRAM SCANS THRU THE MF20S AND REENABLES THOSE MF20S WHICH WERE
;ON AT THE TIME SAVMCN WAS CALLED.  SINCE IT TAKES SO MUCH DATA TO BRING UP AN
;MF20 AFTER POWER ON WE PUNT IF AN MF20 WHICH WAS ON IS NO LONGER ON, IE IT WAS
;POWERED OFF FOR SOME REASON.  THE MAP UMFMAP IS CREATED AND SVAED HERE BY
;SAVMCN.  AN MF20 WAS USABLE IF A MAP BIT IS SET.  BIT35=MF20#10.  34=#11, ETC.

        .EVEN                   ;FORCE UMFMAP TO EVEN BOUNDARY
                                ;0 - NOT USED
RSTMFP: IO10    SBDIAG,,,16     ;1-<START>DO FCN 1 TO GET STATE OF MF20


        I10     HRRI,16,,1201   ;2-CNG FCN 1 TO LD SS 2, NOT DISABLE


        I10     TRNN,15,,1      ;3-WAS THIS MF20 USABLE WHEN SAVMCN WAS RUN?


        I10     JRST,,,10       ;4--HERE IF NO.  DONT SET SS 2.


        I10     TRNN,17,,1000    ;5-SKIP IF MF20 AT SS 2 (IE NOT POWERED OFF)


        I10     JRST,4,,7       ;6-ELSE HALT.  MEM CONFIG BLOWN BY POWER OFF


        IO10    SBDIAG,,,16     ;7-ALL OK.  SET SS2, NOT DISABLED


        I10     ADD,16,,14      ;10-CNG SBDIAG WD BAK TO FCN 1 RD, NXT MF20


        I10     LSH,15,,777777   ;11-LOOK AT NXT CTL BIT


;SEQ306

        I10     JUMPN,15,,1     ;12-LOOP IF MORE MF20S TO DO


        I10     JRST,4,,0       ;13-ELSE HALT.. ALL DONE OK


        WD36    0177,7777,6600  ;14-CHANGES FCN 1 SET -DIS/SS2 TO FCN 1 RD, NXT


UMFMAP: WD36    0000,0000,0000  ;15-MAP OF USABLE MF20S (BIT35=10,BIT34=11,ETC)


        WD36    2000,0000,0001  ;16-FCN 1 RD SBDIAG WD, MF20 #10 FIRST


                                ;17-ECHO FROM FCN 1

        .EVEN


.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
R+