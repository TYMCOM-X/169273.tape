;SEQ042

.TITLE  TCACHA  KL10B MCA20 CACHE OPTION DIAGNOSTIC, VERS 1.0

        $OPSEL=1                ;ALLOW"/COMMANDS" FOR USE BY DIAGNOSTIC
        $MBOX=1         ;FOR MBOX DIAGNOSTICS
        $LOAD=1 
        $MSK36R=1
        DTEASB=1                ;ASSEMBLE DTE20 DEFS
        DTEDEF=1                
        KWASB=1         ;ASSEMBLE CLOCK PARAMETERS
        $DFTBP=4        ;DEFAULT BACKPLANE IS 1 (DMA20/DIA20)
        DEXWDS=.DAT3    
        .ENABL  ABS,AMA
        .=3000
 
 
JUSLOD=4                ;PROGRAM JUST LOADED
PWRUP=2                 ;MACHINE JUST REPOWERED
HAVMEM=1                ;USER HAS CONFIGURED MEMORY AND WE SAVED IT
   
PXCT=   256
   
   
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3 (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM











































































































































































































































































































































































































.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE















































































































































































































































































































































































.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        MOV     #DIACOM,COMRET          ;SET COMMAND RETURN
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM
        .BYTE   'F,'B           ;FB - SET FUNCTION BREAKPOINT
        .BYTE   'F,'C           ;FC - FUNCTION BREAK CONTINUE
        .BYTE   'C,'B           ;CB - CLEAR FUNCTION BREAKPOINT
        .BYTE   'R,'G           ;RG - PRINT FN BREAK REGISTERS
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
        .WORD   FB..
        .WORD   FC..
        .WORD   CB..
        .WORD   RG..

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
        PMSG    <FB	SET FUNCTION BREAKPOINT\>
        PMSG    <FC	FUNCTION BREAK CONTINUE\>
        PMSG    <CB	CLEAR FUNCTION BREAK\>
        PMSG    <RG	PRINT BREAK REGISTERS\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKPOINTS DURING INITIALIZATION
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKS DURING INITIALIZATION
        JSR     PC,(R3)                 ;DO INITIALIZATION
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
                "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        ESTSIZ=100      ;ERR STACK SIZE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FT8             ;16
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTMEM           ;30
        FTT     FTPRM           ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

FT8T:FTM.        <HEDSCT,ENTSCT>

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

FTMEMT:FTM.     <HEDMRQ,ACTMRQ,EXPMRQ>

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACTMRQ:ACMRQ
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
ENTSCT:ENSCT
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXPMRQ:XPMRQ
HEDMRQ:HDMRQ
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>
        .LIT ERMRQ,<.ASCIZ %         RQ0 RQ1 RQ2 RQ3 RD  WR  SBUS ADR\%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER
.REM    %
        PRINT ACTUAL MEMORY RQ'S AND 22-BIT ADDRESS
        %
ACMRQ:  $PMSG,ERACT             ;PRINT MESSAGE
MRQCOM: JSR     PC,TYPRQS       ;TYPE REQUEST BITS
        MOV     R5,R0   
        ADD     #3,R5           ;SKIP OVER INFO
        PNT22                   ;SBUS ADR IN OCTAL
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER




.REM    %
        
STACK HAS ONE OR MORE ENTRIES TO REPORT SCANOUT ERRORS.
WORD1:DIAG FN,,SIZE ((CHAN OR MBOX TABLE ID)
        NEXT 2 OR 3 BYTES:EXPECTED DATA
        NEXT 2 OR 3 BYTES :ACTUAL DATA
        WHETHER 2 OR 3 BYTES IS DETERMINED BY SIZE AND DIAG FN, WHICH
        ALSO DETERMINES THE E-BUS BIT NUMBER CORRESPONDENCE.
        %

ENSCT:  CLRB    FT8DUN          ;CLR DONE FLAG
1$:     JSR     PC,GNSCT                ;GET ONE ENTRY FROM ERROR STACK

;NOW TEST ALL THE BITS IN THIS ENTRY AND PRINT DIFFERENCES
        JSR     PC,PRDBYT
        TSTB    FT8DUN          ;LAST ENTRY?
        BEQ     1$              ;NO, DO IT AGAIN
        RTS     PC              ;RETURN TO SCANNER



;SET UP AN ENTRY FOR REPORTING
GNSCT:  MOVB    (R5)+,FT8SIZ            ;GET SIZE PARAM
        MOVB    (R5)+,FT8DF             ;GET DIAG FCN
        BPL     2$              ;BR IF NO LAST ENTRY FLAG
        INCB    FT8DUN          ;SET DONE FLAG
        BICB    #200,FT8DF      ;AND CLEAN DF BUFFER
2$:     CLR     R3              ;INIT INDEX
        CMPB    FT8SIZ,#CSIZE   ;CHANNEL?
        BEQ     3$              ;BR IF SO
        INC     R3              ;NEXT INDEX
        CMPB    FT8DF,#163      ;FIND WHICH MBOX GROUP
        BLT     3$              
        INC     R3              ;2-BYTE GROUP
3$:     ASL     R3              ;MAKE WORD INDEX
        ADD     F8SIZT(R3),R5   ;POINT BEYOND EXPECTED
        MOV     R5,R1           ;MAKE EXPECTED PTR
        DEC     R1
        ADD     F8SIZT(R3),R5   ;POINT BEYOND ACTUAL
        MOV     R5,R2           ;MAKE ACTUAL PTR
        DEC     R2
        MOV     F8BITT(R3),F8BTF        ;GET # OF FIRST, LAST BITS
        MOV     F8MSKT(R3),R3   ;GET IRST BIT MASK
        RTS     PC              ;RETURN


;SEQ119

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
        PRINT EXPECTED DATA, MEM RQ AND 22-BIT ADDRESS
        %
XPMRQ:  $PMSG,ERCOR     ;PRINT MESSAGE
        JMP     MRQCOM  ;TYPE BITS, ADDRESS



.REM    %
REPORT MEMORY REQUESTS AND 22-BIT SBUS ADDRESS.
PRINT HEADER LINE
        %
HDMRQ:  $PMSG,ERMRQ     ;PRINT MESSAGE
        RTS     PC



.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE MEMORY REQUESTS AND READ/WRITE BITS

TYPRQS: MOV     #6,R2   ;BIT COUNT
        MOVB    (R5)+,R1        ;GET BIT WORD
        SWAB    R1              ;POSITION TO SHF INTO SGN
        PSPACE                  ;SPACE 1
1$:     MOV     #'0,R0          ;ASSUME A ZERO
        TST     R1              ;
        BPL     2$              ;BR IF ZERO
        MOV     #'1,R0          ;ITS A ONE
2$:     PNTCHR
        PSPACE,PSPACE,PSPACE    ;SPACE3
        ROL     R1              ;NEXT BIT
        DEC     R2              ;COUNT
        BGT     1$              ;DO MORE
        RTS     PC


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT        ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138


.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
LSH=    242
BLT=    251
AOBJN=  253
JRST=   254
JFCL=   255
XCT=    256
MAP=    257
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
CAMN=   316
JUMPL=  321
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOS=    350
SOJE=   362
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
IOR=    434
IORI=   435
SETCA=  450
SETCAM= 452
SETOM=  476
HRLI=   505
HLLZS=  513
HRLZI=  515
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TRZ=    620
TRZN=   626
TRC=    640
TRCE=   642


.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM

.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM


;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.LIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.NLIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        R00=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ.HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36
        .IIF NB,WID,W=WD
.IIF    NDF,TRAPS,      JSR     R4,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        ;WORD 1
        .IIF NE <XXX-1>,                        ;.WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        S10.    EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD -1                              ;STEP TO EVNT, OR BRS & CHK EVNT
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   P5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR,R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE,<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
.IIF    NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDF,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS       JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN



;SEQ185

.SBTTL  *CACHE* DIAGNOSTIC TEST ROUTINES 05-OCT-76  EDIT #28

.REM    %
        CACHE DIAGNOSTIC DISPATCH TABLES FOLLOW.  TABLE INITAB
IS USED TO REFERENCE INITIALIZATION ROUTINES; TESTAB REFERENCES
THE ACTUAL TESTS.
%
                                        
                                
                        ;BIT 15 IS SET IF THE ENTRY POINT IS TO BE INCREMENTED
                        ;BY 2 EXCEPT DURING LOOPS.

INITAB: .WORD   I.000   ;0-ONE TIME INITIALIZATION
        I.C01           ;1-
        I.C02           ;2-
        I0.C03          ;3-
        I0.C04          ;4-
        I0.C05          ;5-
        I0.C06          ;6-
        I0.C07          ;7-
        I1.C03          ;8
        I1.C04          ;9-
        I1.C05          ;10-
        I1.C06          ;11-
        I1.C07          ;12-
        I2.C03          ;13-
        I2.C04          ;14-
        I2.C05          ;15-
        I2.C06          ;16-
        I2.C07          ;17-
        I3.C03          ;18-
        I3.C04          ;19-
        I3.C05          ;20-
        I3.C06          ;21-
        I3.C07          ;22-
        I0.C08          ;23-
        I0.C09          ;24-
        I0.C10          ;25-
        I0.C11          ;26-
        I1.C08          ;27-
        I1.C09          ;28-
        I1.C10          ;29-
        I1.C11          ;30-
        I2.C08          ;31-
        I2.C09          ;32
        I2.C10          ;33-
        I2.C11          ;34-
        I3.C08          ;35-
        I3.C09          ;36-
        I3.C10          ;37-
        I3.C11          ;38-
        I.C20           ;39-
        I.C22           ;40-
        I.C13           ;41-
        I.C14           ;42-
        I.C15           ;43-
        I.C16           ;44-
        I.C17           ;45-


;SEQ207

        I.C18           ;46-
        I.C19           ;47-
        I.C21           ;48-
        I.C23           ;49-
        I.C24           ;50-
        ENDPAS          ;51-END OF PASS/GENERATION CONTROL


;SEQ208

TESTAB: .BYTE   $NT,'K!BIT7     ;0-NBR OF TESTS AND ISO FILE KEY
        T.C01                   ;1-REFILL RAM TEST
        T.C02                    ;-REFILL AND USE RAM TEST
        T0.C03                  ;3-WRITE TO CACHE TEST /CACHE 0
        T0.C04                  ;4-SWEEP, VALID, WRITTEN TEST /CACHE 0
        T0.C05                  ;5-DIRECTORY RAM TEST /CACHE 0
        T0.C06                  ;6-DIRECTORY DISTURB TEST A /CACHE 0
        T0.C07                  ;7-DIRECTORY DISTURB TEST B/CACHE 0
        T1.C03                  ;8-WRITE TO CACHE TEST /CACHE 1
        T1.C04                  ;9-SWEEP,VALID, WRITTEN TEST /CACHE 1
        T1.C05                  ;10-DIRECTORY RAM TEST /CACHE 1
        T1.C06                  ;11-DIRECTORY DISTURB TEST A /CACHE 1
        T1.C07                  ;12-DIRECTORY DISTURB   TEST B /CACHE 1
        T2.C03                  ;13-WRITE TO CACHE TEST /CACHE 2
        T2.C04                  ;14-SWEEP, VALID, WRITTEN TEST /CACHE 2
        T2.C05                  ;15-DIRECTORY RAM TEST /CACHE 2
        T2.C06                  ;16-DIRECTORY DISTURB TEST A /CACHE 2
        T2.C07                  ;17-DIRECTORY DISTURB  TEST B /CACHE 2
        T3.C03                  ;18-WRITE TO CACHE TEST /CACHE3 3
        T3.C04                  ;19-SWEEP, VALID, WRITTEN TEST /CACHE 3
        T3.C05                  ;20-DIRECTORY RAM TEST /CACHE 3
        T3.C06                  ;21-DIRECTORY DISTURB TEST A /CACHE 3
        T3.C07                  ;22-DIRECTORY DISTURB TEST B /CACHE 3
        T0.C08                  ;23-CACHE READ AND DATA DISTURB /CACHE 0
        T0.C09                  ;24-TIED DATA BIT TEST /CACHE 0
        T0.C10                  ;25-DIRECTORY PARITY TEST /CACHE 0
        T0.C11                  ;26-WRITEBACK ONE WORD TEST /CACHE 0
        T1.C08                  ;27-CACHE READ AND DATA DISTURB /CACHE 1
        T1.C09                  ;28-TIED DATA BIT TEST /CACHE 1
        T1.C10                  ;29-DIRECTORY PARITY TEST /CACHE 1
        T1.C11                  ;30-WRITEBACK ONE WORD TEST /CACHE 12
        T2.C08                  ;31-CACHE READ AND DATA DISTURB /CACHE
        T2.C09                  ;32-TIED DATA BIT TEST /CACHE 2
        T2.C10                  ;33-DIRECTORY    PARITY TEST /CACHE 2
        T2.C11                  ;34-WRITEBACK ONE WORD TEST /CACHE 2
        T3.C08                  ;35-CACHE READ AND DATA DISTURB /CACHE 3
        T3.C09                  ;36-TIED DATA BIT TEST /CACHE 3
        T3.C10                  ;37-DIRECTORY PARITY TEST /CACHE 3
        T3.C11                  ;38-WRITEBACK ONE WORD TEST /CACHE 3
        T.C20                   ;39-TWO WORD WRITEBACK TEST
        T.C22                   ;40-WRITEBACK ADDRESS PATH TEST
        T.C13                   ;41-WRITE FORCING WRITEBACK
        T.C14                   ;42-READ FORCES WRITEBACK, 4-WD. READ
        T.C15                   ;43-READ WITH LOOK ONLY
        T.C16                   ;44-READ-PAUSE-WRITE DATA IN CACHE
        T.C17                   ;45-READ-PAUSE-WRITE DATA NOT IN CACHE
        T.C18                   ;46-ERROR ADDRESS REGISTER CHECK
        T.C19                   ;47-CSH DIR PAR ERR INHIBITS CACHE
        T.C21                   ;48-CACHE TO MEMORY DATA EXERCISE
        T.C23                   ;49-CACHE/PAGED REFERENCES
        T.C24                   ;50-DMA20 THREE WORD OPS
        .WORD   NORMAL          ;51-NO TEST
$NT=<.-TESTAB>/2-1              ;NUMBER OF TESTS


;SEQ209

.SBTTL  CACHE DIRECTORY TEST DISPATCH
.MACRO  CACHE   C,TS
I'C'.C'TS':       MOV   #C,CSHNBR
          MOV   #''C,CMSGN1
          JMP   I.C'TS

T'C'.C'TS':       JMP   T.C'TS
.ENDM   CACHE
        CACHE   0,03
        CACHE   0,04
        CACHE   0,05
        CACHE   0,06
        CACHE   0,07
        CACHE   1,03
        CACHE   1,04
        CACHE   1,05
        CACHE   1,06
        CACHE   1,07


;SEQ210

        CACHE   2,03
        CACHE   2,04
        CACHE   2,05
        CACHE   2,06
        CACHE   2,07
        CACHE   3,03
        CACHE   3,04
        CACHE   3,05
        CACHE   3,06
        CACHE   3,07


.SBTTL  CACHE CONTROL AND DATA TEST DISP.

        CACHE   0,08
        CACHE   0,09
        CACHE   0,10
        CACHE   0,11
        CACHE   1,08
        CACHE   1,09
        CACHE   1,10
        CACHE   1,11
        CACHE   2,08
        CACHE   2,09
        CACHE   2,10


;SEQ212

        CACHE   2,11

        CACHE   3,08
        CACHE   3,09
        CACHE   3,10
        CACHE   3,11


;SEQ213

.SBTTL  START/RESTART ROUTINE

.REM    %
THIS ROUTINE PERFORMS INITIALIZATION OF THE TEST ENVIRONMENT UPON
INITIAL START OR RESTART.  ITS OPERATION IS DRIVEN BY THE STATE OF
THREE MAJOR FLAGS:
        0STATE:  = 'JUSLOD' AT LOAD, = 0 FOR ALL RESTARTS
        CONSOL-2 = POSITIVE UNLESS
        THE PROGRAM HASN'T BEEN STARTED SINCE THE LAST
        POWER UP.
IMEMCF = 0 AT LOAD OR IF NO CONFIGURED MEMORY EXISTS, = 'HAVEMEM' IF
                A MEMORY CONFIGURATION HAS BEEN DETECTED AND SAVED.
REGISTER R5 IS LOADED WITH THE SUM OF THE ABOVE BY THE
STATIN ROUTINE TO PRODUCE A 3-BIT STAFF COUNT.

ACTIONS PERFORMED:
OSTATE  CONSOL-2        IMEMCF  ACTIONS

0       +       0               ATTEMPT TO SAVE MEMORY CONFIGURATION
                                BUT DON'T ASK IF NOT FOUND.

0       +       'HAVMEM'        NO ACTION REQUIRED

0       0       0               LOAD MICROCODE, ATTEMPT TO FIND AND SAVE
                                MEMORY CONFIGURATION

0       0       'HAVMEM'        LOAD MICROCODE, RESTORE MEMORY CONFIGURATION.

'JUSLOD'    +    0              PRINT TITLE, TEST MICROCODE, REPORT
                                PROCESSOR NUMBER, ATTEMPT TO SAVE MEMORY CONFIGURATION
                                PERFORM CONSISTENCY CHECK OF CACHE OPTION
                                INDICATORS, INITIALIZE SUBROUTINE FLAGS AND
                                POINTERS.  IF MICROCODE TEST FAILS THE
                                STATE IS CHANGED TO LOOK LIKE BELOW.
   
'JUSLOD'    +    'HAVMEM'       UNREACHABLE STATE

'JUSLOD'    0    0              PRINT TITLE, LOAD MICROCODE, REPORT
                                PROCESSOR NUMBER, ATTEMPT TO SAVE MEMORY
                                CONFIGURATION, PERFORM CONSISTENCY CHECK
                                OF CACHE OPTION INDICATORS.
                                INITIALIZE SUBROUTINE FLAGS AND POINTERS.

'JUSLOD'    0    'HAVMEM'               UNREACHABLE STATE.

        %


;SEQ214

I.000:  JSR     R5,INITM        ;INIT MBOX ROUTINES
        JSR     PC,STATIN       ;COMPUTE NEW STATE
;
;THE FOLLOWING ARE ALL CONDITIONAL ON 'INACTS' TABLE FLAGS
;
        JSR     PC,IPTITL       ;PRINT TITLE
        JSR     PC,IUCODL       ;LOAD MICROCDE
        JSR     PC,IPRONR       ;READ/PRINT PROCESSOR I.D.
        JSR     PC,IOPTST       ;TEST FOR CACHE, BOTH WAYS
        JSR     PC,IMSAVE       ;FIND/SAVE MEM CONFIG
        JSR     PC,IMRSTR       ;RESTORE MEM CONFIG
        CLR     OSTATE          ;INDICATE RESTART
        RTS     PC

;FLAG BITS WHICH DETERMINE OPERATIONS TO BE DONE IN PARTICULAR STATE.


FTITL=BIT0                      ;PRINT TITLE
FULOD=BIT1                      ;LOAD DIAGB.RAM MICROCODE
FPRNO=BIT2                      ;READ AND REPORT PROCESSOR NO.
FSAVE=BIT3                      ;FIND AND SAVE MEMORY CONFIGURATION
FASKM=BIT4                      ;ASK FOR MEMORY TO BE CONFIGURED
FRSTR=BIT5                      ;RESTORE MEMORY CONFIGURATION
FOPTT=BIT6                      ;CONSISTENCY CHECK OF CACHE PRESENT

INACTS: .BYTE FSAVE             ;RESTART, NO MEM.
        .BYTE 0                 ;RESTART,MEM.
        .BYTE FULOD!FSAVE       ;REPOWER, NO MEM.
        .BYTE FULOD!FRSTR       ;REPOWER, MEM

        .BYTE   FTITL!FPRNO!FSAVE!FASKM!FOPTT  ;LOADED, UCODE PROB O.K.
        .BYTE 0                 ;UNREACHABLE
        .BYTE FULOD!FTITL!FPRNO!FSAVE!FASKM!FOPTT  ;LOADED, POWERUP
        .BYTE 0                 ;UNREACHABLE




;SEQ215

STATIN: MOV     OSTATE,R5               ;GET OLD STATE
        ADD     IMEMCF,R5               ;GET MEM CONFIG STATE
        TST     CONSOL-2                ;
        BEQ     1$                      ;BR IF POWERUP
        SM                              ;TRY TO START UCODE
        BCC     2$                      ;BR IF SUCCESSFUL
1$:     ADD     #PWRUP,R5               
2$:     CLR     MEMFLG
        CLR     PMAFLG
        MOV     #-1,EXTFLG              ;FORCE EXTENDED ADDRESSING
        RTS     PC

IPTITL: BITB    #FTITL,INACTS(R5)       ;WANT TO PRINT TITLE?
        BEQ     1$                      ;BR IF NOT
        PCRLF
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TCACHA\>
        PMSG    <CACHE DIAGNOSTIC>
        PNTVER
1$:     PMSG    <\SWITCHES = >
        SWITCH                          ;GET CONSOLE SWITCHES
        PNTOCT                          ;PRINT THEM
        PCRLF                           ;CR/LF
        RTS     PC

;-----SECTION TO LOAD MICROCODE OR VERIFY EXISTING MICROCODE.
IUCODL: CLR     R2                      ;ZAP UCODE LOADED SWITCH
1$:     SM                              ;TRY A SM
        BCC     3$                      ;BR IF OK
        TST     R2                      ;ELSE ERR...DID WE LOAD UCODE?
        BEQ     2$                      ;BR IF NO...GO LOAD & RETRY
        ERROR   <\MICROCODE START ERR.>

2$:     MOV     #6$,R0                  ;ELSE LOAD UCODE VIA A PROGRAM CMD
        PRGCMD
        BCS     4$                      ;BR IF CMD NOT SUCCESSFUL
        INC     R2                      ;IND WE LOADED UCDE
        BR      1$                      ;GO RETRY UCODE
3$:     JSR     PC,RDAPRI               ;READ THE APRID DATA
        BITB    #2,4(R0)                ;DO WE HAVE DIAGNOSTIC MICROCODE?
        BNE     5$                      ;YES... GO USE IT
        TST     R2                      ;DID WE LOAD UCODE?
        BEQ     2$                      ;BR IF NO... GO LOAD IT
4$:     PMSG    <\LOAD>

        $PMSG,6$+1


;SEQ216

        PMSG    < & RESTART DIAGNOSTIC\>

        PRGHLT
        FATAL                           ;PUNT IF HE TRIES TO CONTINUE US
5$:     MOV     #1,CONSOL-2             ;INDICATE GOOD UCODE
        RTS     PC
 
6$:     .ASCIZ  "P DIAGB.RAM"
        .EVEN


IPRONR: BITB    #FPRNO,INACTS(R5)       ;WANT TO PRINT PROC # ?
        BEQ     1$
        JSR     PC,RDAPRI               ;READ IT AND OPTION BIT
        PMSG    <PROC # >

        MOV     PROCID,R0               ;GET THE PROC. NO.
        BIC     #170000,R0
        PNTDEC                          ;PRINT IT
        PCRLF
1$:     RTS     PC


;SEQ217


IMSAVE: BITB    #FSAVE,INACTS(R5)      ;SAVE MEMORY?
        BEQ     1$                      ;BR IF NOT
        FNDM16  MCBASA                  ;SEARCH FOR MEM
        BCC     2$                      ;BR IF FOUND
        BITB    #FASKM,INACTS(R5)       ;SHOULD ASK FOR IT?
        BEQ     1$                      ;BR IF NOT
        PMSG    <PLEASE CONFIGURE MEMORY AND 'SED'.\>

        PMSG    <'HC' WILL RUN TESTS NOT NEEDING MEMORY.\>
        PRGHLT
1$:     RTS     PC
2$:     MOV     #HAVMEM,IMEMCF          ;SHOW HAVE MEMORY
        SAVMCN                          ;SAVE CONFIG
        JSR     R5,RSTDMA               ;RESTORE DMA20 CONFIG
        FNDM16  DMABAS                  ;SEE IF DMA20 REALLY THERE
        BCC     3$                      ;IT SEEMS TO BE
        MOV     #-1,DMABAS              ;MARK IT ABSENT
        MOV     #-1,MEMFLG              ;MARK MEM OFF-LINE
3$:     RTS     PC

IMRSTR: BITB    #FRSTR,INACTS(R5)       ;SHOULD RESTORE?
        BEQ     1$                      ;BR IF NOT
        JSR     R5,RSTMCN               ;RESTORE CONFIG
1$:     RTS     PC

;-----SUBROUTINE TO SET EXTERNAL MEMORY CONFIGURATION.
RSTDMA: MEMRST                          ;RESET ALL MEM CONTR
        MOVB    CONTAB+16.,CNFWD0+3     ;CONTR 4 (DMA20) INTRLV TO SBDIAG WD
        BISB    #100,CNFWD0+3           ;SET CLR0-5 BIT IN SBUS DIAG WD
        MOVB    #4,TSTCON               ;SET CONTR # =4 (DMA20)
        SBUSDG  CNFWD0                  ;TURN DMA20 BACK ON AGAIN
        RTS     R5                      ;RETURN TO CALLER


;SEQ218

IOPTST: BITB    #FOPTT,INACTS(R5)      ;TEST FOR CACHE?
        BEQ     3$                      ;BR IF NOT
        MOV     #-1,CSHFLG              ;SET LOOK AND LOAD ENABLE
        RSTMBX                          ;CLEAR MACHINE
        DFRDT
        170
        TBIT    30                      ;TEST CACHE BIT


        BNE     1$
        CLR     CSHFLG                  ;CLEAR IF NO CACHE BIT
1$:     CMPB    CSHFLG,CSHOPT           ;CONSISTENCY CHECK
        BEQ     4$
        BLT     2$
        ERRMSG  <OPTION BIT 19 INDICATES CACHE BUT 'CACHE BIT'>
        ERRMSG  < IS FALSE\>
        ERROR   <	M8529 OR M8530>

2$:     PMSG    <OPTION BIT 19 INDICATES NO CACHE BUT 'CACHE BIT'>

        PMSG    < IS TRUE - TEST WILL PROCEED\>

3$:     RTS     PC
4$:     TST     CSHFLG
        BNE     3$
        PMSG    <BOTH OPTION BIT 19 AND 'CACHE BIT' INDICATE\>
        PMSG    <NO CACHE IN THIS CPU - TEST ABORTED\>

        ERREOP

RDAPRI: XQT     APRID           ;READ PROCESSOR CONFIG
        BCC     1$              ;NO FAILURE
        CLR     CONSOL -2       ;RESTART LOOKS LIKE REPOWER
        ERROR   <APRID INSTRUCTION FAILED EXECUTION>
1$:     READ17                  ;GET IT
        MOV     (R0),PROCID     ;BITS 20-35


;SEQ219

        CLRB    CSHOPT
        BIT     #BIT0,2(R0)     ;TEST BIT 19
        BEQ     2$
        DECB    CSHOPT          ;SET OPTION FLAG
2$:     RTS     PC



APRID:  IO10    APRID,,,17      ;READ JUMPERS




        .EVEN
DMABAS: -1                      ;DMA20 BASE ADDRESS, -1 IF NO DMA
PROCID: 0                       ;TEMP PROC ID 20-35
CSHOPT: 0                       ;CACHE OPTION + LAG
IMEMCF: 0                       ;MEMORY CONFIGURED = 'HAVMEM'
OSTATE: JUSLOD                  ;LOADED = 'JUSLOD', RESTART = 0
        EBUSRG=167


;SEQ220

.SBTTL          TEST#1 - REFILL RAM TEST

.REM    %
THIS TEST CHECKS ADDRESSING AND DATA PATHS OF THE CACHE REFILL ALGORITHM
RAM ON THE CHX(M8515) BOARD.  THE REFILL RAM CONSISTS OF THE 3 10147
RAMS ON CHX3 WHOSE OUTPUTS ARE CALLED "CSH USE IN 2, CSH USE IN 3, AND
CSH USE IN 4 H".  WHEN WRITING INTO THIS RAM, THE DATA AND ADDRESS
COME FROM THE VMA(M8523).  A PDP10 INSTRUCTION "WRFIL" 700100,,Y
WRITES ONE ADDRESS OF THIS THREE-BIT RAM.  THE DIAGNOSTIC CAN READ THE
RAM ADDRESS INPUTS AND DATA OUTPUTS BY DOING DIAGNOSTIC READS FROM THE
PDP-11.
FIRST, A REFILL RAM WRITING PROGRAM IS RUN IN THE KL10 AC'S TO
TRY AND CLEAR THE RAM TO ALL ZEROES.  THEN A PROGRAM TO WRITE ONES
IS LOADED INTO THE AC'S BUT NOT RUN.  INSTEAD IT IS SINGLE-
PULSED BY THE PDP11 THROUGH 128 WRITES OF THE RAM.
THE PROGRAM CHECKS THE DATA AND THE ADDRESS AT THE RAM 2 TIMES DURING
EACH OF THE 128 WRITES -- ONCE JUST BEFORE THE WRITE PULSE TO CHECK FOR ONES
JUST WRITTEN.
IN THE ERROR MESSAGE, 16 BITS ARE TYPED OUT.  THE LEFT HALF IS
THE ADDRESS LINES, THE RIGHT IS THE DATA :
        0 AAA AAA A00 000 DDD   WHERE A IS ADDRESS BIT, DI IS DATA BIT


SUBTEST 1 CHECKS FOR CORRECT ADDRESS COUNT AND FOR ZERO DATA.
        IF THE ADDRESS IS ZERO AND THE DATA ISN'T, THEN THE ORIGINAL
        WRITE OF ALL ZEROES MAY NOT HAVE WORKED BECAUSE OF FAILING
        WRITE PULSE GENERATION.  IF THE ADDRESS ISN'T ZERO, BUT THE
        DATA IS, THEN THERE IS AN ADDRESS PATH FAILURE SOMEWHERE.
        A FAILURE BECAUSE OF NON-ZERO DATA IS MOST LIKELY A FAILURE
        OF THE 10147 RAM.


SUBTEST 2 RECHECKS ADDRESSING AND CHECKS THE DATA FOR ONES.  AN
        ERROR IN AN ADDRESS BIT IS PROBABLY DUE TO A DATA BIT
        BEING TIED TO THE ADDRESS BIT.  ZEROES IN THE DATA CAN BE
        AN OPEN PATH IN THE DATA INPUT OR A FAILED 10147.

AN ERROR REPORT WITH NO SUBTEST NUMBER AND NO DATA TYPEOUT MEANS
THAT THE WRITE REFILL RAM INSTRUCTION CONTROL LOGIC IS NOT WORKING
AND THE MBOX NEVER GOT TO CSH EBOX T1 OR CSH EBOX 13.

LOOP:   FOR SEQUENCING PROBLEMS, MICROCDE HANGS, DO:
        (CONSOLE COMMANDS)
        R SM,EX 700100 0        ;REPEAT START MICROCODE, EXECUTE
                                ; A WRITE REFILL RAM INSTRUCTION

        FOR DATA/ADDRESS PROBLEMS:
        (CONSOLE COMMANDS)
        SM                      ;RESET AND START MICROCODE
        DM 0/700100 000AAA      ;WRITE ZERO TO RAM ADDR 'AAA'
        DN 700100 700AAA        ;WRITE ONES TO DITTO
        DN 254000 0             ;LOOP
        STO                     ;START AT AC0
%

;SEQ221

;BEGINNING OF PASS INITIALIZATION IS INCLUDED IN TEST#1 INITIALIZATION
;
I.C01:  MOV     #EMASK1,EMASK   ;SET EBOX SCAN MASK
        MOV     #MASKC1,MMASK   ;SET SCANOUT MASK
        MOV     #-1,CSHFLG      ;SET LOOK AND LOAD
        MOV     #-1,MEMFLG      ;INHIBIT MEMORY
        MOV     #-1,PMAFLG      ;LOAD EBUS REG FROM PMA
        MOV     #7,CLKFLG       ;ENABLE CRAM/DRAM PARITY/FS STOP
        CLR     R0
        SETMPH                  ;MAKE SURE LODAR AT STANDARD PHASE

;
;THE ABOVE LINES ARE THE BEGINNING OF PASS INITIALIZATION.
;
        RSTMBX                  ;CLEAR CPY
        CRRONE  0               ;ZERO REFILL RAM
        INVAL                   ;SWEEP AND ZERO USE BIT RAM
        MOV     #"AN,CMSGN1
        MOV     #'Y,CMSGN1+2
        RTS     PC

T.C01:  RSTCHK
        CLRB    T1OLD+1         ;START ADDRESSES AT ZERO
        CLRB    T1NEW+1
        LDREF1  7               ;LOAD WRITE ONES CODE
        SETPC   2               ;POINT PC AT AC2
1$:     INSYNC                  ; ***** SUBTEST 1, SYNC CONDITIONAL *****
        RRFONW                  ;STEP AND READ OLD AND NEW
        BCS     4$              ;BRANCH IF CONTROL ERROR
        CLR     R2              ;0 MASK
        MOV     T1OLD,R4        ;EXPECTED DATA
        MOV     (R1)+,R3        ;CHECK BEFORE WRITE PULSE
        MSK16R                  ;LOOK FOR ERROR
        BCC     2$              ;BR IF OK
        FAULTC  <REFILL RAM ADDRESS, DATA - M8515>


2$:     INSYNC                  ; ***** SUBTEST 2*****
        INCB    T1OLD+1         ;UP ADDRESS FORNEXT TIME
        MOV     T1NEW,R4        ;EXPECTED DATA
        MOV     (R1),R3 
        MSK16R                  ;LOOK AFTER WRITE PULSE


;SEQ222

        BCC     3$              ;BR IF OK
        FAULTC   <REFILL RAM ADDRESS, DATA - M8515>

3$:     INCB    T1NEW+1         ;UP ADDR FOR NEXT TIME
        CLR     R5              ;BACK TO SUBTEST 1
        CMPB    T1NEW+1,#128.
        BNE     1$              ;DO 128 LOOPS
        CONTIN                  ;RUN OUT THE AC CODE
        JMP     NORMAL          ;SUCCESSFUL COMPLETION
4$:     CLR     R5              ;FORCE SUBTEST ZERO
        FAULTC  <WRITE REFILL RAM SEQUENCE FAILURE>

T1NEW:  7
T1OLD:  0


;SEQ223

.SBTTL          TEST#2 - REFILL AND USE RAM TEST
.REM    %
THIS TEST IS CHECKING THE REFILL RAM AND THE USE BIT RAM TOGETHER
BY USING A CACHE SWEEP.  THE USE BIT RAM IS THE 5 10147'S ON CHX3
WHOSE INPUTS ARE CALLED "CSH USE IN 0 (1,2,3,4) H".  DURING AN
ALL PAGES SWEEP THIS RAM IS WRITTEN INTO 4 TIMES FOR EACH ADDRESS.
ITS OUTPUTS ARE USED AS PART OF THE ADDRESS FOR READING THE REFILL
RAM.  THE REFILL RAM'S OUTPUTS ARE PART OF THE DATA WRITTEN INTO
THE USE BIT RAM.
THE TEST WRITES ALL ZEROES TO THE REFILL RAM AND DOES A SWEEP AT
FULL CLOCK SPEED.  THIS SHOULD CAUSE ALL ZEROES TO BE
WRITTEN INTO THE USE BIT RAM BY THE SWEEP.  NEXT, A SPECIAL
REPATING TEST PATTERN IS WRITTEN INTO THE REFIL RAM.
THE TEST THEN BURST-PULSES A SWEEP ALL PAGES INVALIDATING CACHE
AND CHECKS AT EACH CCA INVAL T4 THAT 1. THE CCA ADDRESS COUNTER HAS
COUNTED DOWN CORRECTLY (IT GOES FROM 777 TO 000) AND 2.  THAT THE USE RAM
OUTPUTS INDICATE THAT THE RAM IS BEING WRITTEN CORRECTLY.
 

SUBTEST 1 CHECKS ALL OF THE MBOX DIAGNOSTIC FUNCTIONS TO SEE IF
        THE SWEEP CORRECTLY GOT TO CCA INVAL T4 FOR THE FIRST TIME.
SUBTEST 2 ERRORS WILL ONLY OCCUR DURING PROGRAM DEVELOPMENT.
SUBTEST 3 CHECKS THE CCA ADDRESS BY CLOCKING THE PMA ADDRESS LINES
        INTO THE EBUS REGISTER WHICH IS READ BY DIAGNOSTIC FUNCTION.
SUBTEST 4 READS THE DATA AND ADDRESS SIGNALS FROM THE M8515 BOARD
        AND CHECKS THE USE RAM AND REFILL RAM.  THE ERROR PRINTOUT SHOWS
16 BITS AS IN TEST#1.  ERRORS IN THE LEFT EIGHT BITS MAY BE CAUSED
BY BAD 10147'S, AN UNTERMINATED ADDRESS LINE, FAULTY USE BIT WRITE
        PULSES, OR FAILURE OF CSH USE HOLD(M8513) TO HOLD THE REFILL
ADDRESS DURING A SWEEP.  IF THERE IS A FAILURE ONLY IN THE RIGHT-
HAND THREE BITS OF THE TYPEOUT, THERE ARE PROBABLY TWO REFILL RAM
        OUTPUTS TIED TOGETHER.

LOOP:   FOR SEQUENCE PROBLEMS:
        R EX701440 0, TD 20  ,OR
        R SM,EX701440 0,TD 20

        THE TD TIME DELAY MAY BE ADJUSTED OR OMITTED TO SUIT YOURSELF.

AC LOOP WHICH WAITS FOR SWEEP DONE AND LOADS THE EBUS REGISTER
        WITH THE SWEEPER ADDRESS AS IN SUBTEST 3:
        SM
        DM 0/700200 20020       ;CONSO APR, CLEAR SWEEP DONE
        DN 701440 0             ;START INVALIDATING SWEEP
        DN      700340 20       ;CONSO APR, SWEEP DONE?
        DN 254000 2             ;WAIT FOR DONE
        DN      254000 0        ;LOOP
        EW                              
        FW76/1000               ;SET PMA TO EBUS REG ENABLE
        ST0                     ;RUN IT

SYNC:   CSH CCA CYC, CSH USE HOLD
        %


;SEQ224

I.C02:  MOV     #MASKC1,MMASK    ;SET SCANOUT MASK
        MOV     #-1,PMAFLG
        RSTMBX                  ;RESET
        CRRONE  0               ;CLEAR REFILL RAM
        INVAL                   ;CLEAR USE RAM
        REFILL  T2PAT           ;LOAD CACHE REFILL RAM
        RTS     PC
;THE FOLLOWING PATTERN IS PLACED
;IN THE REFILL RAM TO SERVE AS A STIMULUS IN
;CHECKING THE USE BIT RAM'S ABILITY TO HOLD DATA.
;THE REFILL RAM IS ADDRESSED BY 7 BITS.  DURING LOADING, THESE
;COME FROM VMA BITS 27-33.  DURING NORMAL CACHE OPERATIONS,
;INCLUDING A SWEEP, THEY ARE SUPPLIED AS FOLLOWS
;CC MM T LL
; CC IS THE CACHE CURRENTLY MATCHED, IN THE CASE OF A SWEEP ALL
; PAGES, THESE BITS COME FROM CCA 34,35.
;MM IS THE MOST RECENTLY USED CACHE, FROM THE USE RAM.
;T IS THE 'TOGGLE' BIT FROM THE USE RAM AND
;LL IS THE LEAST RECENTLY USED CACHE FROM THE USE RAM.

;REFILL RAM PATTERN:
;000/12467350
;010/12467350
;020/12467350
;ET CETERA, (REPEATING EVERY EIGHT LOCATIONS)
T2PAT:  .REPT   4
        .WORD   12467,35012,46735,01246
        .WORD   73501,24673,50124,67350
        .ENDR
T.C02:  MOV     #777,T2PMA      ;FIRST SWEEP ADDRESS
        INSYNC                  ; ***** SUBTEST 1 *****
        STEREQ  T2SWP,T02EBX    ;SWEEP TO AR
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR SWEEP>


;SEQ225

1$:     MSCAN   T2SCTB,<10>             ;CCA INVAL T4 L
        BCC     5$              ;BR IF GOT THERE
        FAULTC  <SWEEP SEQUENCING ERROR - M8513>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        CMP     T2PMA,#776      ;2ND TIME IS MORE CLOCKS
                                ;BECAUSE EBOX GOING TO HALTLP
        BNE     3$
        STPCON  7               ;CCA INVAL T4 L
        BCS     4$              ;SAME ERROR
        BCC     6$              ;IF OK
3$:     STPCON  7               ;CCA INVAL T4 L
        BCC     6$
4$:     FAULTC  <SWEEPER HUNG UP? - M8513>

5$:     INC     R5              ;HERE AFTER FIRST TIME ONLY


;SEQ226

6$:     INSYNC                  ; ***** SUBTEST 3 *****
        FNRD    EBUSRG          ;READ SWEEP ADDRESS
        MOV     @DEXWDS,R3      ;GET 20-35
        MOV     #177000,R2      ;MASK
        MOV     T2PMA,R4        ;EXPECTED
        MSK16R                  ;LOOK FOR ERROR
        BCC     7$              ;BR IF ALL OK
        FAULTC  <SWEEPER ADDRESS - M8518>


7$:     INSYNC                  ; ***** SUBTEST 4 *****
        RDRFIL                  
        MOVB    T2PMA,R1
        BIC     #177774,R1      ;MAKE ADDRESS AN INDEX
        ASL     R1              ;DOUBLE IT
        ADD     #T2EXP,R1       ;ADD IN TABLE BASE
        CLR     R2              ;MASK
        MOV     (R0),R3         ;ACTUAL
        MOV     (R1),R4         ;EXPECTED
        MSK16R                  ;LOOK FOR ERROR
        BCC     8$              ;CONTINUE IF OK
        FAULTC  <REFILL OR USE RAM ERROR - M8515>

8$:     MOV     #1,R5           ;RESET SUBTEST
        DEC     T2PMA           ;DOWNCOUNT CCA ADDRESS
        BPL     2$              ;DO 512 PASSES
        JMP     NORMAL          ;OK RETURN
T2PMA:  0
T2EXP:  .BYTE   7,14,4,62,2,131,1,140   ;REFILL AND USE RAM OUTPUTS
T2SWP:  IO10    SWPIA,,,0       ;SWEEP ALL INVAL


        .EVEN
;DRIVE TABLE FOR CHECKING SWEEP FUNCTION BITS
;IN ORDER CSH CCA VAL CORE H,CSH CCA INVAL CSH H,
;CCA ALL PAGES CYC H
SWSTAT: DF.     175

        BP.     31
        DF.     174
        BP.     31
        DF.     177
        BP.     -30

;_____

;SEQ227


;-----NOTE-----

        ;SEQUENCE 227 IS A BLANK MICROFICHE FRAME.



;SEQ228

.SBTTL          TEST#3+5C --- WRITE TO CACHE TEST

.REM    %
TEST#3  CACHE 0
TEST#8  CACHE   1
TEST#13 CACHE 2
TEST#18 CACHE 3

THIS TEST CHECKS THE CONTROL LOGIC SEQUENCING OF A WRITE THAT SHOULD
GO TO CACHE.  FOR THE SAKE OF SYMMETRY THIS TEST IS
PERFORMED ON EACH CACHE SEPERATELY ALTHOUGH ALMOST ALL OF THE
CONTROL LOGIC INVOLVED IS THE SAME FOR EACH CACHE.  THE ONE DIFFERENCE IS
THE DIRECTORY FOR THE CACHE BEING TESTED, AND THE GATE THAT
DETECTS ANY WRITTEN.  THE CACHE UNDER TEST SHOULD HAVE HAD ALL
WRITTEN BITS CLEARED OUT OF ITS DIRECTORY BY THE CACHE SWEEP.  IF
THE CONTROL LOGIC DETECTS ANY WRITTEN BITS, IT WILL TRY TO DO A
WRITEBACK TO CORE BEFORE ALLOWING THE WRITE TO CACHE.

SUBTEST 1 CHECKS THE STATE OF MBOX SIGNALS AT CLEAR WR T0.  THIS
        CHECK IS PERFORMED AT A FIXED NUMBER OF CLOCKS AFTER THE START
        OF THE WRITE INSTRUCTION, SO ANY FAILURE IN THE SEQUENCE OF TIME
        STATES - INCLUDING A BRANCH INTO THE WRITEBACK LOGIC - WILL CAUSE
        AN ERROR IN THIS SUBTEST.  ALSO FAILURE OF CON CACHE LOOK AND CON CACHE
        LOAD EN WILL CAUSE A REFERENCE TO CORE INSTEAD OF CACHE.

SUBTEST 2 CHECKS WHETHER THE CSH LOGIC SEQUENCES TO CSH DATA CLR T2.
        IT CHECKS THE STATE OF ALL MBOX SIGNALS AT THIS TIME.

SUBTEST 3 ADVANCES TO CSH EBOX WR T4 AND CHECKS THE MBOX
        DIAGNOSTIC SIGNALS AT THIS STATE.

SUBTEST 4 CHECKS THE ADDRESS OF THE WRITE INSTRUCTION BY CLOCKING
                THE PMA LINES INTO THE EBUS REGISTER AND CHECKING THE EBUS REGISTER
        CONTENTS USING A DIAGNOSTIC READ.

SUBTEST 5 RUNS THE CLOCK AND CHECKS THAT THE
        MBOX GIVES MP RESP AND THAT THE EBOX MICROCODE THEN SEQUENCES BACK TO
        THE HALT LOOP.

LOOP:   FOR SEQUENCING PROBLEMS DO:
        R SM,EX 701200 600000,EX 202000 1777

FOR LOOPING IN THE AC'S:
        SM
        DM 0/701200 600000      ;SET  CON CACHE LOOK, LOAD
        DN 202 400 1777         ;MOVE TO CACHE
        DN254000 1              ;LOOP

        DM 10/"DATA"
        ST0                     ;START IT GOING

SYNC:

        %

;SEQ229

I.C03:  RSTMBX                  ;CLEAR CPU
        MOV     CSHNBR,R0       ;GET CACHE TO BE TESTED
        MOV     #MASKC2,MMASK   ;SCAN TABLE MASK
        MOV     #T3TABS,R1      ;SET UP TABLE POINTERS
        MOV     R0,R2
1$:     BEQ     2$              ;DONE, OR CACHE 0
        ADD     #6*MSIZE,R1     ;SKIP 3 TABLES
        DEC     R2
        BR      1$              ;SKIP SOME MORE
2$:     MOV     R1,T3TEM        ;SAVE FOR LATER
        CRRONE                  ;PUT IN REFILL RAM
        INVAL                   ;SWEEP ALL INVALIDATING
        RTS     PC

T.C03:  MOV     T3TEM,R1
        MOV     R1,1$
        ADD     #2*MSIZE,R1
        MOV     R1,3$
        ADD     #2*MSIZE,R1
        MOV     R1,5$
        LDWRIT  ZERO..,1777     ;LOAD WRITE AND HALT CODE
        SETPC   1               ;SET RUN AND PC=1
        INSYNC                  ; ***** SUBTEST 1 *****
        JSR     R5,MSCAN
1$:     0                       ;TABLE PTR GOES HERE
        S10.    45              ;CSH WR TEST L (CLEAR WR TO)
        BCC     2$              ;OK GOT THERE
        FAULTC  <WRITE CACHE SEQUENCING ERROR - M8513>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        JSR     R5,MSCAN
3$:     0                       ;TABLE PTR GOES HERE
        S10.    2               ;CSH DATA CLR T2
        BCC     4$
        FAULTC  <STATES AT CSH DATA CLR T2, IF WE GOT THERE>

4$:     INSYNC                  ; ***** SUBTEST 3 *****
        JSR     R5,MSCAN
5$:     0                       ;TABLE PTR GOES HERE
        S10.    4               ;CSH EBOX WR T4
        BCC     6$              ;BR IF OK
        FAULTC  <DIDN'T FIND EBOX WR T4 FROM DATA CLR T2>

;SEQ230

6$:     INSYNC                          ; ***** SUBTEST 4 *****
        FNRD    EBUSRG
        MOV     DEXWDS,7$
        JSR     R5,CMP22
7$:     0
        TC3ADR
        BCC     8$
        FAULTC  <WRONG PMA OR VMA ADDRESS>

;SEQ231

8$:     INSYNC                  ; ***** SUBTEST 5 *****
        DFXCTT
        STRCLK                  ;START THE CLOCK
        CONTIN
        BCC     9$              ;BR IF OK
        FAULTC  <EBOX DIDN'T RESTART AFTER CACHE WRITE>


9$:     JMP     NORMAL          ;ALL OK RETURN

T3TEM:  0
TC3ADR: .BYTE   377,3,0

        .EVEN


;SEQ232


.SBTTL          TEST#4+5C --- SWEEP, VALID, WRITTEN TEST
        
.REM    %
TEST#4  CACHE 0
TEST#9  CACHE 1
TEST#14  CACHE 2
TEST#19 CACHE 3


THIS TEST USES AND CHECKS AN INVALIDATING CACHE SWEEP OF ONE PAGE.
AT  THE SAME TIME THAT THE SWEEP IS BEING CHECKED, WE ARE ALSO
CHECKING THAT A WRITE LIKE THE ONE USED IN THE PREVIOUS TEST
ACTUALLY SUCCEEDED IN WRITING A VALID AND
A WRITTEN BIT IN CACHE LOCATION 1777.  SINCE THE ONE-PAGE SWEEP
AND THE ALL PAGES SWEEP (TESTED EARLIER) ARE VERY SIMILAR, ONLY THE
DIFFERENCES ARE TESTED.  THE MAIN DIFFERENCE IS THAT THE CCA COUNTER
ON THE PMA BOARD COUNTS DOWN BY FOUR INSTEAD OF BY ONE, AND THAT THE
LOW TWO ADDRESS BITS ARE DETERMINED BY WHICH CACHE'S DIRECTORY (IF

ANY DO) MATCHES THE PHYSICAL PAGE IN VMA 14-26.

SUBTEST 1 SINGLE-PULSES THE SWEEP TO THE FIRST CSH T3 (CCA T3) AND
        CHECKS THE STATE OF ALL MBOX DIAGNOSTIC SIGNALS.

SUBTEST 2 CHECKS THE CCA AND PAGE ADDRESS BY CLOCKING THE PMA OUTPUTS
        TO THE EBUS REGISTER AND READING THE REGISTER WITH A DIAGNOSTIC FUNCTION.

SUBTEST 3 CHECKS THE CSH N ANY VALID AND CSH N ANY WRITTEN SIGNALS,
        WHERE 'N' IS THE CACHE NUMBER CURRENTLY BEING TESTED.  ALTHOUGH THE
        PREVIOUS TEST (3,8,13,18) CHECKED THE CONTROL LOGIC USED FOR WRITING
        THE VALID A BITS, WE DON'T KNOW THAT M8514 (CHA) OR M8515(CHX) DID STORE THOSE
        BITS.  A FAILURE IN THIS SUBTEST MEANS THAT
        EITHER A MOVE TO CACHE IS FAILING OR THAT THE SWEEP IS UNABLE TO
        READ OUT THESE BITS.

SUBTEST 4 BURST-PULSES THE SWEEP TO THE SECOND CCA T3 AND AGAIN CHECKS
        THWE SWEEP ADDRESS TO BE SURE IT GOT DECREMENTED BY 4 AND NOT 1.
        (ACTUALLY CCA 34 AND CCA 35 KEEP ON DECREMENTING BY 1 BUT THE CARRY OR
        BORROW BETWEEN BIT 34 AND BIT 33 IS DISABLED.)

SUBTEST 5 RUNS THE CLOCK TO FINISH THE SWEEP AND STARTS A NEW SWEEP
        BY BURST-STEPPING IT TO CCA T3.

SUBTEST 6 CHECKS THE VALID AND WRITTEN BITS TO SEE IF THEY GOT CLEARED
        BY THE PREVIOUS SWEEP AS THEY SHOULD.

LOOP:   TO LOOP ON A WRITE FOLLOWED BY A ONE-PAGE INVALIDATING SWEEP:
        SM
        DM 0/701200 600000      ;SET CON CACHE LOOK,LOAD
        DN      700200 20020    ;CLEAR SWEEP DONE
        DN 202400 1777          ;MOVEM 10,1777
        DN 701640 1             ;SWEEP INVALIDATING PAGE 1
        DN 700340 20            ;CHECK SWEEP DONE
        DN 254000 4             ;WAIT FOR IT
        DN 254000 1             ;LOOP
%

;SEQ233

I.C04:  RSTMBX                  ;CLEAR CPU
        INVAL   
        XQT     LDWMOV          ;WRITE TO CACHE WORD
        MOV     #MASKC2,MMASK   ;SCANOUT MASK
        MOV     #1777,T4PMA     ;EXPECTED CCA ADR
        RTS     PC

T.C04:  MOV     CSHNBR,R0
        ASL     R0
        MOV     T4TAB1(R0),2$   ;SET UP TABLE PTRS
        MOV     T4TAB2(R0),9$
        INSYNC                  ; ***** SUBTEST 1 *****
        STEREQ  T4SWP,T04EBX    ;START SWEEP
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR SWEEP>

1$:     JSR     R5,MSCAN
2$:     0                       ;TABLE PTR GOES HERE
        S10.    7               ;CSH T3
        BCC     3$
        FAULTC  <ONE PAGE SWEEP SEQUENCING PROBLEM>


3$:     CMP.S   SWSTAT,2                ;CHECK 'INVAL, ONE PAGE'
        BCC     4$              ;BR IF OK
        FAULTC  <WRONG SWEEP SETUP>

4$:     INC     R5              ; ***** SUBTEST 2 *****
        FNRD    EBUSRG          ;READ PMA
        MOV     DEXWDS,5$
        JSR     R5,CMP22
5$:     0                       ;PTR 10 ACTUAL
        T4PMA                   ;PTR TO EXPECTED
        BCC     6$              ;BR IF OK
        FAULTC  <BAD CCA ADDRESS, ONE PAGE SWEEP>


;SEQ234

6$:     INSYNC                  ; ***** SUBTEST 3 *****
        MOV     CSHNBR,R0
        MOVB    T4VWX(R0),R0
        MOVB    R0,13$          ;EXPECTED DATA
        COM     R0              ;MAKE A MASK
        MOV     R0,7$
        MOV     R0,14$
        JSR     R5,CMPS.
        0                       ;EXPECTED DATA
        T4VAW                   ;PSW TABLE
7$:     177400                  ;MASK
        BCC     8$              ;BR IF OK       
        FAULTC  <PROBLEM WITH VALID OR WRITTEN BITS>

8$:     INSYNC                  ; ***** SUBTEST 4 *****
        JSR     R5,MSCAN
9$:     0                       ;TABLE PTR GOES HERE
        S10.    7               ;SECOND CSH T3
        FNRD    EBUSRG          ;GET NEW CCA ADDRESS
        MOV     DEXWDS,10$
        JSR     R5,MASK16
0                               ;MASK
10$:    0                       ;ACTUAL PTR
        T4PINC                  ;EXPECTED PTR
        BCC     11$
        FAULTC  <CCA INCREMENT PROBLEM, ONE PAGE>

11$:    INSYNC                  ; ***** SUBTEST 5 *****
        DFXCTT
        STRCLK                  ;FINISH THE SWEEP
        STEP10  T4SWP,43                ;CSH13
        BCC     12$
        FAULTC  <SECOND SWEEP HUNG UP?>

12$:    INC     R5              ; ***** SUBTEST 6 *****
        JSR     R5,CMPS.        ;CHECK VALID,WRITTEN CLEARED
13$:    0                       ;EXPECTED
        T4VAW                   ;DRIVE TABLE
14$:    0                       ;MASK
        BCC     15$     
        FAULTC  <FIRST SWEEP DIDN'T CLEAR BITS?>


;SEQ235

15$:    JMP     NORMAL          ;ALL OK


;SEQ236

;TABLE FOR CHECKING VALID AND WRITTEN BITS, LEFT TO RIGHT:
;CSH 0 ANY VAL, CSH 1 ANY VAL, CSH 2 ANY VAL, CSH 3 ANY VAL,
;CSH 0 ANY WR, CSH 1 ANY WR, CSH 2 ANY WR, CSH 3 ANY WR

T4VAW:  DF.     170

        BP.     20

        DF.     171

        BP.     20

        DF.     172

        BP.     20

        DF.     173

        BP.     20

        DF.     177

        BP.     25

        DF.     175

        BP.     25

        DF.     176

        BP.     25

        DF.     174

        BP.     -25

;ONE PAGE SWEEP OF PAGE 1 (1000-1777)
T4SWP:  IO10    SWPIO,,,1


        .EVEN

T4VWX:  .BYTE   210,104,42,21

T4PMA:  .WORD   0,0
        T4PINC: 1772            ;CCA INCREMENTED, ONE PAGE


;SEQ237

.SBTTL          TEST#5+5C --- DIRECTORY RAM TEST
.REM    %
TEST#5  CACHE 0
TEST#10 CACHE 1
TEST#15 CACHE 2
TEST#20 CACHE 3

THIS IS A TEST OF THE CACHE DIRECTORY ADDRESS, VALID, AND WRITTEN
BITS.  THE CACHE IS TESTED ONE (OUT OF EVERY FOUR) WORD AT A
TIME, THAT IS, ALL 128 'WORD 3'S' ARE TESTED, THEN WORD 2'S, AND SO
ON UNTIL  ALL 512 WORDS OF THE CACHE ARE TESTED.
EACH TIME THT 128 WORDS ARE WRITTEN, A SWEEP IS PULSED BY THE
PDP11 PROGRAM AND STOPPED AT EACH OF THE 128 CCA INVAL T4'S THAT
OCCUR.  AT THIS TIME STATE, THE PROGRAM CHECKS CSH 'N' ANY VALID
AND CSH 'N' ANY WRITTEN , AS WELL AS THE CACHE DIRECTORY PARITY
BIT FOR ERRORS.

AFTER THE ENTIRE CACHE HAS BEEN CHECKED AND SWEPT, A SECOND
SWEEP OF THE SAME TYPE IS SINGLE-STEPPED THRU COMPLETELY TO MAKE
SURE THAT NO VALID AND WRITTEN BITS REMAIN STUCK TRUE.

SUBTEST NUMBERS 0 THRU 511 ARE THE DECIMAL ADDRESS OF THE FAILING
        CACHE LINE.  SOME DIRECTORY BITS (E.G., "VALID") ARE STORED BY
        WORD NUMBER, WHICH IS THE LOW 2 BITS OF THE ADDRESS.
        IF THE LOW ADDRESS DIGIT IS:  THE WORD NUMBER IS:
                        0,4,8           0
                        1,5,9                   1
        
                        2,6             2
                        3,7             3
        IF IT NOT CONVENIENT FOR YOU TO CONVERT ADDRESSES FROM DECIMAL TO OCTAL, 
        YOU CAN USE THE CONSOLE 'ERG' COMMAND TO TYPE THE EBUS REGISTER AFTER 
        THE TEST HAS HALTED.  THE RIGHT 3 OCTAL DIGITRS ARE ADDRESS BITS 27-35.

        IF YOU GET A CACHE DIR PAR ODD ERROR, YOU CAN LOCATE
        THE BIT BY THE FOLLOWING PROCEDURE:
        SET THE HALT ON ERROR SWITCH AND RUN THE TEST UP TO THIS
        ERROR.  LOCATE THE BACKPLANE PINS ON THE M8514 DRAWING
        FOR THE CSH DIR BITS 14 THRU 26.  MAKE VERY SURE YOU HAVE
        THE BITS FOR THE FAILING CACHE!!  THERE ARE FOUR SETS OF DIR BITS!!
        THEN USE A SCOPE ON THE BACKPLANE TO CHECK THESE BITS.  ONLY
        BIT 26 SHOULD BE HIGH AT THIS TIME, ALL OTHERS (14-25) SHOULD
        BE LOW.  REPLACE THE BAD 10144.

SUBTEST 512 CHECKS THE SWEEP CONTROL BITS TO BE SURE THEY ATE
        STILL THE SAME AS IN THE BEGINNING.

SUBTEST 513 CHECKS THE CACHE AFTER THE FIRST SWEEP AND REPORTS THE
        FIRST ADDRESS IT FOUND THAT HAD EITHER A VALID OR A WRITTEN
        BIT STILL TRUE.  THE FAILING ADDRESS IS TYPED OUT IN BINARY.

LOOP:   SEE LOOPING INSTRUCTIONS FOR TEST#4.

%


;SEQ238
I.C05:  RSTMBX                  ;CLEAR CPU
        MOV     #MASKC1,MMASK   ;SCANOUT MASK TABLE
        RTS     PC

T.C05:  MOV     CSHNBR,R0       ;GET CACHE NUMBER
        MOVB    T4VWX(R0),R0
        COM     R0              ;MAKE A MASK
        MOV     R0,4$
        MOV     R0,6$
        MOV     R0,12$
        MOV     #3,2$           ;STARTING WORD
1$:     CLR     R5              ;RESET INNER LOOP COUINT
        CSHWRD  ZERO..,1        ;WRITE A PAGE, 1 OUT 4 WORDS
WRDNBR=.                        ;OUTER LOOP CONTROL, ALSO SELECTS 1 OF EACH 4 WORDS
2$:     0
        STEP10  T4SWP,43                ;CSH T3
        BCC     3$
        ERROR   <SWEEP DIDN'T START>

3$:     INSYNC                  ; ***** SUBTEST/LOOP COUNT *****
        JSR     R5,CMPS.        ;CHECK VALID AND WRITTEN
        0                       ;EXPECTED DATA
        T4VAW                   ;TABLE
4$:     0                       ;MASK
        BCC     5$              ;BR IF OK
        JSR     PC,CLINSB       ;FIX UP R5
        FAULTC  <WRITTEN OR VALID BIT ERROR>
5$:     JSR     R5,CMPS.
        17                      ;EXPECTED
        T5PTAB                  ;TABLE
6$:     0                       ;MASK
        BCC     7$              
        JSR     PC,CLINSB       ;MAKE R5 A LINE NBR
        FAULTC  <PARITY BIT ERROR>
7$:     CMP     R5,#128.
        BGE     9$
        CMP     R5,#1           ;FIRST TIME?
        BNE     8$              ;NO
        STPCON  7               ;CSH T3, EBOX NOT AT HALT
        BR      3$              
8$:     STPCON  7               ;CSH T3


;SEQ239

        BR      3$


;SEQ240

9$:     MOV     #1000,R5                ; ***** SUBTEST 512. *****
        CMP.S   SWSTAT,2                ;SEE IF SWEEP BITS HAVE CHANGED
        BCC     10$             ;BR IF STILL O.K.
        FAULTC  <SWEEP TYPE CHANGED!>

10$:    BRST    50.             ;FINISH
        DEC     2$
        BPL     1$              ;DO NEXT WORD OF CHUNK
        MOV     #1001,R5        ; ***** SUBTEST 513. *****
        MOV     #T4SWP,R0
        LODAR                   ;GET SWEEP INTO AR
        BCC     11$
        ERROR   <U-CODE HUNG>

11$:    DFXCTT
        CONBUT                  ;PRESS CONTINUE
        FIND    <176,22,0>      ;LOOK FOR CCA INVAL T4
        BCS     14$             ;GOOD IF WE DON'T
;GOT VALID MATCH WHEN ALL SHOULD HAVE BEEN CLEAR
          
        JSR     R5,CMPS.
        377
        T4VAW
12$:    0                       ;MASK FOR CACHE
        FNRD    EBUSRG          ;GET CCA ADDR
        MOV     DEXWDS,13$
        JSR     R5,MASK16
        0
13$:    0
        ZERO..                  ;EXPECTED TO FORCE MISMATCH
        FAULTC  <SWEEP DIDN'T CLEAR THIS LOCATION>

14$:    JMP     NORMAL          ;ALL OK




;SEQ241

T5CEXP: 0

;CACHE DIRECTORY PARITY TABLE, LEFT-RIGHT:      CSH 0 - CSH 3
;
T5PTAB: DF.     174

        BP.     20

        DF.     175

        BP.     20

        DF.     176

        BP.     20

        DF.     177

        BP.     -20

.EVEN
T5PARS: .BYTE   10,4,2,1
        ;
;CONVERT R5 TO A CACHE ADDRESS
CLINSB: SUB     #128.,R5                ;CONVERT SUBTEST TO CHUNK
        NEG     R5
        ASL     R5              ;MAKE ROOM FOR 2 BITS
        ASL     R5
        BIS     WRDNBR,R5       ;STUFF IN WORD SELECT BITS
        RTS     PC


;SEQ242

.SBTTL          TEST#6+5C --- DIRECTORY DISTURB TEST A
.REM    %
TEST#6  CACHE 0
TEST#1  CACHE 1
TEST#16 CACHE 2
TEST#21 CACHE 3

THIS IS A TEST OF CACHE DIRECTORY ADDRESSING.  IT AND THE
NEXT TEST IN SEQUENCE, TOGETHER DETERMINE WHETHER THE INTERNAL
ADDRESS DECODERS OF THE CACHE DIRECTORY AND EXTENSION RAM'S
ARE WORKING PROPERLY.  FOR INITIAL CONDITIONS, IT COUNTS ON THE FACT
THAT THE INITIALIZATION HAS WRITTEN PAGE 1 WITH CORRECT DIRECTORY PARITY
IN ALL LOCATIONS, AND THAT THE VALID AND WRITTEN BITS HAVE ALL BEEN
SWEPT OFF.  PASSING THE PREVIOUS TEST MAKES THIS ASSUMPTION VALID.
THE TEST THEN WRITES FOUR WORDS TO EACH OF SEVEN QUADWORDS
IN CACHE.  THE QUADWORD ADDRESSES ARE DETERMINED BY FLOATING
A ONE THRU ADDRESS BITS 27 TO 33.  THE PAGE WRITTEN IS THE COMPLEMENT
OF PAGE 1, THAT IS BITS 14-26 = 17776.  THE THEORY IS THAT IF A CHIP'S
ADDRESS DECODING IS WRONG, WRITING THE 28 DISTURBER WORDS WILL CAUSE
A DETECTABLE ERROR IN ONE OF THE LOCATIONS CONTAINING PAGE 1, OR
A CLEARED VALID OR WRITTEN BIT.  THE TEST STEPS THRU A SWEEP CHECKING
CACHE DIRECTORY PARITY, AND LOOKING FOR VALID OR WRITTEN BITS THAT
GOT TURNED ON.
SUBTEST 0 TO 511.  THE SUBTEST NUMBER IS THE DECIMAL ADDRESS OF
        THE CACHE LINE HAVING THE FAILURE OCCURRED.
        IN THE CASE OF A PARITY ERROR, THE DIAGNOSTIC CAN NOT TELL YOU
        WHICH DIRECTORY BIT WAS PICKED.  HOWEVER, IF YOU HAVE A SCOPE, YOU
        CAN CHECK ON THE BACKPLANE THE SIGNALS CALLED CSH DIR 14 'N' THRU
        CSH DIR 26 'N' H.  ('N' IS THE CACHE NUMBER PRINTED IN THE
        ERROR MESSAGE.  ONLY BIT 26 SHOULD BE HIGH.  ANY OTHER HIGH BIT
IS AN ERROR.  THE MBOX IS AT CCA T3 (CSH T3) OF A SWEEP.
%



I.C06:  RSTMBX                  ;CLEAR CPU
        MOV     CSHNBR,R0
        MOVB    T5PARS(R0),T6PMSK
        COM     T6PMSK
        MOVB    T4VWX(R0),T6VWMK
        COM     T6VWMK
        MOV     ERSP..,SVERSP   ;SAVE STACK PTR
        CSHPAG  ZERO..,1        ;WRITE ZEROES IN PAGE 1
        INVAL
        RTS     PC


;SEQ243

T.C06:  CLR     WRDNBR          ;N/A
        DSTRBC  17776           ;DISTURB PATN TO PAGE 17776
        STEP10  T4SWP,43                ;CSH 13
        BCC     T6CLP
        ERROR   <SWEEP FAILED>
T6CLP:  INSYNC                  ; ***** SUBTEST/LOOP COUND 88888
        JSR     R5,CMPS.        ;CHECK VALID AND WRITTEN BITS
        377                     ;EXPECTED
        T4VAW                   ;DRIVE TABLE
T6VWMK: 0                       ;MASK
        BCC     1$
        JSR     PC,TDERCK       ;SEE IF AN ERROR
        BCC     T6CONT          ;BR IF A DISTURBER LOC
        FAULTC  <WRITTEN OR VALID BITS DISTURBED>

1$:     JSR     R5,CMPS.        ;CHECK PARITY
        17                      ;EXPECTED
        T5PTAB            ;DRIVE TABLE
T6PMSK: 0                       ;MASK
        BCS     T6PERR          ;BR IF ERROR
        CMP     R5,#128.
        BGE     T6END           ;DO 128 TIMES
T6CONT: CMP     R5,#1           ;FIRST CONTINUE?
        BNE     1$              ;NO
        STPCON  6               ;CSH T3 EBOX NOT HALTED
        BR      T6CLP
1$:     STPCON  6               ;NEXT CSH T3
        BR      T6CLP           ;LOOK AGAIN
T6END:  BRST    50.             ;RUN OUT CLOCK
        JMP     NORMAL          ;ALL OK


;SEQ244


;CHECK TO SEE WHETHER ADDRESS IS IN DISTURBER REGION
;AND RETURN WITH C-BIT CLEAR IF SO.  ELSE IF REALLY AN
;ERROR, SET THE C-BIT.
TDERCK: PUSH    R5

        JSR     PC,CLINSB       ;MAKE UP A CHUNK ADDRESS
        MOV     #T6DOM,R0
1$:     CMP     R5,(R0)+
        BEQ     2$              ;NOT AN ERROR
        CMP     R0,#T6DOM+16    ;DONE?
        BLT     1$              ;BR IF NOT
        POP     R0              ;ERROR - CLEAN STACK

        SEC                     ;SET ERROR FLAG
        RTS     PC

2$:     POP     R5              ;NO ERROR - RESTORE

        MOV     SVERSP,ERSP..   ;FLUSH ERROR
        CLC                     ;NOT AN ERROR
        RTS     PC              ;CONTINUE

T6PERR: JSR     PC,CLINSB       ;CONVERT TO CHUNK ADDR
        FAULTC  <PARITY OR ADDRESS BIT DISTURBED>

T6DOM:  .WORD   400,200,100,40,20,10,4


;SEQ245

.SBTTL          TEST#7+5C --- DIRECTORY DISTURB TEST B
.REM    %
        
TEST#7  CACHE   0
TEST#12 CACHE   1
TEST#17 CACHE   2
TEST#22 CACHE   3

THIS TEST IS A COMPANION OF THE PREVIOUS TEST AND COMPLETES THE
'DISTURB' TESTING OF THE CACHE DIRECTORY BY USING A DIFFERENT PAIR
OF PAGES (5252 AND 12521) THAN BEFORE.  THE TEST PROCEDURE IS THE
SAME AS TEST#6.

SUBTEST 0-511.  AS IN TEST#6, THE SUBTEST NUMBER IS THE DECIMAL ADDRESS
        OF THE FAILING CACHE LINE.  IN THE CASE OF A DIRECTORY PARITY ERROR,
        THE EXPECTED DATA ON CSH DIR 14 'N' THRU CSH DIR 26 'N' IS 5252.
        THAT IS, BITS 15,17,19,21,23, AND 25 SHOULD BE HIGH AND ALL OTHERS LOW.
        %

I.C07:  RSTMBX                  ;CLEAR CPU
        CSHPAG  ZERO..,5252     ;WRITE ALL PAGE 5252
        INVAL                   ;AND SWEEP OUT
        MOV     CSHNBR,R0
        MOVB    T5PARS(R0),T7PMSK  ;SET MASK FOR TEST
        COM     T7PMSK
        RTS     PC

T.C07:  DSTRBC  12521           ;WRITE DISTURB PAIN TO PAGE 12521
        STEP10  T7SWP,43                ;CSH T3
T7CLP:  INSYNC
        JSR     R5,CMPS.        ;TEST PARITY BIT
        17                      ;EXPECTED
        T5PTAB                  ;DRIVE TABLE
T7PMSK: 0                       ;MASK
        BCC     1$              ;BR IF NO ERROR
        JSR     PC,CLINSB       ;CONVERT SUBTEST TO ADDRESS
        FAULTC  <PARITY OR ADDRESS BIT DISTURBED>

1$:     CMP     R5,#128.
        BGE     3$
        CMP     R5,#1           ;FIRST CONTINUE?
        BNE     2$              ;BR IF NOT
        STPCON  6               ;CSH T3


;SEQ246

        BR      T7CLP   
2$:     STPCON  6               ;NEXT CSH T3
        BR      T7CLP           ;CONTINUE TEST
3$:     BRST    50.             ;FINISH SWEEP
        JMP     NORMAL
T7SWP:  IO10    SWPIO,,,5252    ;SWEEP PAGE 5252

.EVEN


;SEQ247


.SBTTL            TEST#23+4C --- CACHE READ AND DATA DISTURB

.REM    %
TEST#23 CACHE 0
TEST#27 CACHE 1
TEST#31 CACHE 2
TEST#35 CACHE 3


THIS TEST CHECKS THE FIRST READ TO CACHE AND THEN PERFORMS A ONES
AND ZEROES DATA TEST ON THE CACHE.  ALL OF PAGE 1
IS FIRST WRITTEN WITH ZEROS.  A SKIP 1770 IS BURST-STEPPED AND THE STATE
OF THE MBOX DIAGNOSTIC SIGNALS CHECKED AT TWO PLACES IN THE EXECUTION.
THEN A SUBROUTINE RUNNING IN THE KL10 AC'S IS USED TO PERFORM A FULL-SPEED
DATA TEST OF THE WHOLE PAGE.  AS THE ADDRESSES ARE COUNTED FROM 1000 TO
1777, THE CACHE DATA IS CHECKED FOR ZEROES AND REPLACED WITH ONES.  THE
PROCESS IS REPEATED, CHECKING FOR ONES AND REPLACING WITH ZEROES.
THE FIRST ERROR DETECTED IS REPORTED.

SUBTEST 1 BURST -STEPS THE SKIP1770 TO CSH EBOX T2 AND CHECKS ALL THE
        MBOX DIAGNOSTIC SIGNALS.
SUBTEST 2 BURST-STEPS THE INSTRUCTION TO THE FIRST EBOX CLOCK AFTER
        MB RESP AND CHECKS ALL MBOX SIGNALS.
SUBTEST3 ONLY FAILS IF THE AC PROGRAM HANGS UP AND FAILS TO REACH
        A HALT INSTRUCTION.
SUBTEST 4 REPORTS THE ADDRESS AND FAILING TEST PATTERN OF A DATA ERROR.
        IF THE EXPECTED DATA IS ALL ZEROES AND:
        A) THE ACTUAL DATA HAS ONE OR TWO BITS AT 1, THE PROBLEM
        IS MOST LIKELY A BAD RAM CHIP.  IT COULD ALSO BE THE
        WRITE PULSE CSH WRITE A,B,C ETC. ON M8521.
        B) THE ACTUAL DATA HAS ONES IN ONLY ONE OF THE FOUR
        NINE-BIT GROUPS, THE PROBLEM MAY BE THE ADDRESS LINES
        ONTHE M8521 CONTAINING THOSE NINE BITS, ALSO THE WRITE
        PULSE CACHE WR 00,09,ETC. MAY NOT BE REACHING THE M8521.
        C) THE ACTUAL DATA HAS ONES IN MORE THAN ONE
        NINE-BIT GROUP, THE PROBLEM MAY BE THE CACHE ADR LINES
        COMING FROM M8531.
        IF THE EXPECTED DATA IS ALL ONES AND THE ACTUAL DATA CONTAINS
        ONE OR TWO ZEROES, THE FAILURE MAY BE A RAM CHIP OR OPEN DATA 
        PATH ETCH ON THE M8521.  KEEP IN MIND THAT IF THE PROGRAM GOT THIS
        FAR, THE ALL ZEROES CASE PASSED THE TEST.  THE
        PROBLEM IS NOT LIKELY TO BE ADDRESSING OR WRITE PULSES.
SUBTEST 5 SHOULD ONLY FAIL IN PROGRAM DEVELOPMENT.
LOOP:   FOR SEQUENCING PROBLEMS:
        R SM,EX701200 600000,EX332000 1770      ;REPEAT START UCODE
                                ;SET LOOK AND LOAD, AND SKIPE 1770

        TO LOOP IN AC'S, USING A MOVE INSTEAD OF SKIPE:
        SM              
        DM 0/701200 600000      ;SET LOOK AND LOAD
        DN 202400 1770          ;WRITE DATA FROM 10
        DN 200440 1770          ;READ DATA TO 11
        DN254000 11             ;LOOP

        %


;SEQ248

I.C08:  MOV     #EMASK1,EMASK   ;SET EBOX SCAN MASK
        RSTMBX
        MOV     CSHNBR,R0       ;GET CACHE TO TEST
        CRRONE                  ;LOAD REFILL RAM
        INVAL
        CSHPAG  ZERO..,1                ;CLEAR ALL
        LOAD    0,CDTCHK,16.    ;LOAD TESTER
        RTS     PC

T.C08:  MOV     CSHNBR,R0
        ASL     R0              ;MAKE WORD INDEX
        MOV     TC8TB1(R0),2$
        MOV     TC8TB2(R0),4$   ;SET UP TABLE POINTERS
        STEREQ  TC8RD,T08EBX    ;LOAD A MOVE
        BCC     1$                      ;IF NO ERROR
        ERROR   <WRONG EBOX SETUP FOR CACHE READ>


1$:     INSYNC                  ; ***** SUBTEST 1 ****
        JSR     R5,MSCAN
2$:     0
        S10.    3               ;CSH EBOX T2 L
        BCC     3$              ;IF NO ERROR
        FAULTC  <FIRST READ FROM CACHE AT EBOX T2>


3$:     INSYNC                  ; ***** SUBTEST 2 *****
        JSR     R5,MSCAN
4$:     0
        S10.    3               ;CLK EBOX SOURCE
        BCC     5$              ;IF O.K.
        FAULTC  <FIRST READ FROM CACHE - EBOX CLOCK AFTER RESP>

5$:     INSYNC                  ; ***** SUBTEST 3 *****
        RUN     0               ;DO THE TEST IN AC'S
        BCC     6$              ;IF O.K.


;SEQ249

        FAULTC  <READ LOOP PROGRAM IN AC'S HUNG UP>
6$:     INSYNC                  ; ***** SUBTEST 4 *****
        DFRDT
        150
        BIT     #BIT2,@DEXWDS   ;TEST PC35
        BNE     7$              ;SOME ERROR
        NORMAL
7$:     JSR     PC,GTRSLT       ;READ BACK DATA,ADDR
        BCS     8$              ;PARITY ERROR BRANCHES
        JSR     PC,T8STUF       ;FILL ERROR STACK
        FAULTC  <DATA COMPARE ERROR>

8$:     INSYNC                  ; ***** SUBTEST 5 *****
        JSR     PC,T8STUF       ;LOAD ERROR STACK
        ERRMSG  <MB PARITY ERROR FLAG SET\>

        FAULTC  <PARITY ERROR DURING DATA TEST>


TC8RD:  I10     SKIPE,0,,1770


        .EVEN





;SEQ250

CDTCHK: IO10    CONO,APR,,27760         ;0-CLEAR FLAGS

        I10     MOVE,15,,0,17           ;1-GET CACHE DATA

        I10     CAME,16,,15             ;2-COMPARE TO EXPECTED

        I10     JRST,4,,3               ;3-DATA-ERROR HALT

        IO10    CONSZ,APR,,400          ;4- CHECK MB PART ERR FLAG

        I10     JRST,4,,5               ;5-PARITY ERROR HALT

        I10     SETCAM,16,,0,17         ;6-COMPLEMENT DATA

        I10     AOBJN,17,,1             ;7-COUNT ADDRESS
        I10     SETCA,16,,16            ;10-COMPLEMENT TEST PATTERN

        I10     MOVE,17,,14             ;11-RESTORE 1ST ADDRESS

        I10     JUMPN,16,,1             ;12-SECOND PASS OR QUIT

        I10     JRST,4,,10              ;13-NO-ERROR HALT 

        WD36    7770,0000,1000          ;14-ADDDRESS CONSTANT

        WD36    0000,0000,0000          ;15-DATA FROM MEMORY

        WD36    0000,0000,0000          ;16-DATA TO MEMORY

        WD36    7770,0000,1000          ;17-AOBJN ADDRESS COUNTER

        .EVEN

T8STUF: ERRMSG  <CACHE ADDR:>



;SEQ251

MOV     #T8FLAD,R0
        ERRCOM  PNT23
        ERRMSG  <\ACTUAL :>
        MOV     #T8ACT,R0
        ERRCOM  PNT36
        ERRMSG  <\CORRECT:>
        MOV     #T8EXP,R0
        ERRCOM  PNT36
        ERCRLF
        RTS     PC

GTRSLT: READ17
        BCS     3$              ;IF FAILURE
        MOV     (R0)+,T8FLAD    ;GET FAILED ADDRESS
        MOVB    (R0)+,T8FLAD+2  
        BICB    #374,T8FLAD+2

        MOVB    #15,T8ADBF
        MOV     #T8ADBF,R0
        EXAM
        BCS     3$              ;IF ERROR
        MOV     (R0)+,T8ACT     ;GET ACTUAL FAILED DATA
        MOV     (R0)+,T8ACT+2
        MOVB    (R0),T8ACT+4

        MOVB    #16,T8ADBF      ;GET EXPEDCTED DATA
        MOV     #T8ADBF,R0
        EXAM    
        BCS     3$              ;IF ERROR
        MOV     (R0)+,T8EXP
        MOV     (R0)+,T8EXP+2
        MOVB    (R0),T8EXP+4

        MOV     #4,R0
1$:     CMPB    T8EXP(R0),T8ACT(R0)
        BNE     2$
        DEC     R0
        BPL     1$
        SEC     
        RTS     PC              ;MUST'VE BEEN PARITY
2$:     CLC
        RTS     PC              ;WAS DATA ERROR
3$:     ERROR   <EXECUTE OR EXAMINE>

T8FLAD: .WORD   0,0
T8ADBF: .WORD   0,0
T8ACT:  .WORD   0,0,0
T8EXP:  .WORD   0,0,0

;SEQ253

.SBTTL          TEST#24+4C -- TIED DATA BIT TEST
.REM    %
TEST#24 CACHE 0
TEST#28 CACHE 1
TEST#32 CACHE 2
TEST#36 CACHE 3

THIS TEST COMPLETES THE CACHE DATA TEST BY CHECKING FOR CACHE
DATA INPUTS OR OUTPUTS TIED TOGETHER.  IT USES SIX PATTERNS HAVING
ONES AND ZEROES GROUPED IN VARIOUS COMBINATIONS.
LOCATION 1000 OF THE CACHE IS WRITTEN WITH THE PATTERN AND THEN
READ AND CHECKED.

SUBTEST 1 THRU 6 ARE THE PATTERN NUMBERS.  THE EXPECTED AND ACTUAL
DATA ARE SHOWN IN THE ERROR TYPEOUT.

LOOP:   TO LOOP IN AC'S:
        NOTE - AC'S 0 TO 5 CONTAIN THE SIX PATTERNS.  SUBTRACT 1
        FROM THE FAILING SUBTEST NUMBER TO GET THE AC NUMBER.

        SM
        DM10/701200 600000      ;SET CACHE LOOK,LOAD
        DN 200740 1000          ;READ FROM 1000 INTO 17
        DN 254000 10            ;LOOP ON IT

        IF YOU WANT TO LOOP ON THE WRITE INSTEAD, CHANGE AC11
        TO A MOVEM WITH AN AC FIELD 0 TO  5 TO SELECT THE
        PATTERN YOU WANT. E.G..DM11/202140 1000 TO WRITE THE AC3 PATTERN.
        %

;SEQ254
I.C09:  RSTMBX
        INVAL
        LOAD    0,TC9PAT,6
        RTS     PC

T.C09:  MOV     #TC9PAT,R3
        MOV     #ZERO..,R2
        MOV     #10000,T9MOVM+2         ;START AT ACO

1$:     INSYNC                          ;NEXT SUBTEST (1-6)
        XQT     T9MOVM                  ;PATTERN TO CACHE
        BCC     2$              ;IF NO ERROR
        ERROR   <EXECUTE MOVEM>

2$:     DFXCTT                          ;ENSURE CLOCK RUNNING
        STRCLK                          ;
        MOV     #T9MOVM,R0              ;ADDRESS TO EXAMINE
        EXAM
        BCC     3$                      ;IF NO ERROR
        ERROR   <EXAMINE>

3$:     MOV     R0,R4
        JSR     R5,MSK36R               ;COMPARE RESULT
        BCC     4$                      ;IF NO ERROR
        FAULTC  <DATA BITS TIED TOGETHER SOMEWHERE>

;NOTE:  ISOLATION WILL HAVE TO DO SOME WORK TO IDENTIFY
;ONE OF FOUR CACHE DATA BOARDS!

4$:     ADD     #200,T9MOVM+2   ;NEXT PATTERN CAC=AC+1)
        SUB     #5,R2           ;RESTORE MASK PTE
        CMP     R5,#6
        BLT     1$              ;DO 6 PATTERNS
        NORMAL  

T9MOVM: I10      MOVEM,0,,1000

TC9PAT: WD36    5252,5252,5252

        WD36    6314,6314,6314


;SEQ255

        WD36    7417,0360,7417

        WD36    7760,0377,0017

        WD36    7777,7400,0017

        WD36    7777,7777,7760


.EVEN


;SEQ256

.SBTTL          TEST#25+4C --- DIRECTORY PARITY TEST
.REM    %
TEST#25 CACHE 0
        
TEST#29 CACHE 1
TEST#33 CACHE 2
TEST#37 CACHE 3

THIS TEST CHECKS THE CACHE DIRECTORY PARITY NETWORK AND ERROR
DETECTION LOGIC BY USING EIGHT TEST PATTERNS.  EACH TEST PATTERN IS
A PHYSICAL PAGE NUMBER AND EITHER EVEN OR ODD PARITY BIT.
THE SENSE OF THE PARITY BIT IS CHANGED BY DOING A CONO PI.
WITH BIT 20=1 FOR WRITING EVEN (BAD) DIRECTORY PARITY OR BIT 20=0
FOR WRITING ODD (CORRECT) PARITY.
        A ROUTINE RUNS IN THE KL10 AC'S WHICH WRITES, READS, AND
CHECKS ONE PATTERN EACH TIME IT IS STARTED FROM THE ELEVEN.  THE
ROUTINE DOES A CONI APR, AND THE PDP11 PROGRAM CHECKS THE CACHE
DIRECTORY PARITY ERROR BIT (28) FOR THE PROPER RESULT.

SUBTEST 1-4 ARE WRITING PATTERNS WITH ODD PARITY AND EXPECT NOT
        DIRECTORY PARITY ERRORS.

SUBTEST5-8 ARE WRITING PATTERNS WITH EVEN PARITY AND EXPECT A
        DIRECTORY PARITY ERROR.

LOOP:  IF THE PROGRAM STOPS ON AN ERROR, THE TEST CODE IS IN
        THE KL10 AC'S AND MAY BE LOOPED BY CHANGING THE CONTENTS
        OF THE LOCATION 10 TO 254000 0.  (IT WAS A 254200 0).
        %




I.C10:  MOV     #EMASK1,EMASK   ;SET EBOX SCAN MASK
        RSTMBX
        INVAL
        LOAD    0,CSHPTS,16     
        RTS     PC


;SEQ257

T.C10:
1$:     INSYNC                  ; ***** SUBTEST 1-8 *****
        MOV     R5,R4
        ASL     R4              ;MAKE WORD INDEX FROM SUBTEST
        MOV     TC10AD-2(R4),2$ ;POINT AT ADDRESS PATTERN
        JSR     R5,LOAD
        14                      ;AC14
        -1
2$:     0                       ;LOAD AC14 WITH SECTION ADDRESS
        MOV     R5,R4
        DEC     R4
        ASR     R4
        BIC     #BIT0,R4
        MOV     TC10MD(R4),3$   ;GET CONO PI BITS
        MOV     TC10XP(R4),5$   ;EXPECTED CONI APR DATA
        JSR     R5,LOAD
        15                      ;AC15
        -1
3$:     0                       ;PARITY WRITE-CONTROL BITS
        RUN     0               ;DO THE TEST
        BCC     4$
        ERROR   <AC CODE HUNG>

4$:     READ17
        MOV     R0,6$
        JSR     R5,MASK36       ;TEST THE RESULT
        TC10MK                  ;BIT MASK
5$:     0                       ;EXPECTED
6$:     0                       ;ACTUAL
        BCC     7$              ;BR IF O.K.
        FAULTC  <WRONG CACHE DIR PARITY>


7$:     CMP     R5,#8.
        BLT     1$              ;DO 8 SUBTESTS
        NORMAL

TC10MD:         1$,2$
1$:     WD36    0000,0000,0000

2$:     WD36    0000,0010,0000  ;EVEN DIR PAR


TC10XP: 1$,2$
1$:     WD36    0000,0000,0000


;LISTED AS SEQ258 S/B SEQ257
;CORRECTED BY S.S. 11-20-80


;SEQ258

2$:     WD36    0000,0000,0200  ;D DIR P ERR


;SEQ259

TC10AD: 1$,2$,3$,4$,5$,6$,7$,8$
1$:     WD36    0000,1671,4000  ;PHY PAG 16714

2$:     WD36    0000,1224,4004  ;PHY PAC 12244

3$:     WD36    0000,1536,3010  ;PHY PAG 15363

4$:     WD36    0000,1163,3014  ;PHY PAG 11633

5$:     WD36    0000,0000,0020  ;PHY PAG 0

6$:     WD36    0000,0347,7024  ;PHY PAG 3477

7$:     WD36    0000,0712,7030  ;PHY PAG 7127
  
8$:     WD36    0000,0455,0034  ;PHY PAG 4550

TC10MK: WD36    7777,7777,7577


.EVEN

CSHPTS: IO10    CONO,APR,,27760 ;0-CLEAR FLAGS

        IO10    CONO,PI,,0,15   ;1-SET PARITY GENERATOR ODD OR EVEN

   
        I10     XCT,0,,11       ;DO THE WRITE
   
        IO10    CONO,PI,,0      ;3-RESTORE NORMAL PARITY GENERATION

        IO10    CONO,APR,,27760 ;4-CLEAR FLAGS AGAIN

        I10     XCT,0,,12       ;5-DO THE READ REFERENCE

CNIAPR: IO10    CONI,APR,,17    ;6-GET APR ERROR FLAGS
     
        I10     JFCL,0,,10      ;7-SPACE FILLER

        I10     JRST,4,,0       ;10-HALT


;SEQ260

        I10     MOVEM,13,,100,14        ;11-
        I10     MOVE,16,,100,14         ;12-

      
        WD36    0000,0000,0000  ;13-

        WD36    0000,0000,0000  ;14-

        WD36    0000,0000,0000  ;15-


.EVEN

;SEQ261

.SBTTL          TEST#26+4C --- WRITEBACK ONE WORD TEST
.REM    %
TEST#26 CACHE 0
TEST#30 CACHE 1
TEST#34 CACHE   2
TEST#38 CACHE 3

THIS IS THE FIRST TEST OF THE WRITEBACK LOGIC.  IT USES A SWEEP
AND UPDATE CORE INSTRUCTION TO REQUEST ONE WORD OF A QUADWORD TO
BNE WRITTEN BACK TO CORE AND TO INVALIDATE THE WORD IN CACHE.  THE
TEST IS REPEATED FOR EACH WORD OF A QUADWORD TO BE SURE THAT THE
CORRECT WORD REQUEST TO MEMORY IS BROUGHT UP IN EACH CASE.  ALL
        CORE MEMORIES ARE DIABLES.  SO A NON-EXISTENT MEMORY TIMEOUT
WILL OCCURE FOR EACHG MEMORY REFERENCE.

SUBTEST 1 WRITES WORD 0 OF A QUADWORD IN CACHE, THEN BURST-STEPS A
        SWEEP ONE PAGE UPDATE AND INVALIDATE INSTRUCTION
        TO WRITEBACK  T1 TIME STATE.  THE STATE OF ALL MBOX SIGNALS
        IS VERIFIED.

SUBTEST 2 THIS SUBTEST BURST-STEPS THE SWEEP TO A POINT WHERE THE
        MEMORY REQUEST IS ACTIVE AND CHECKS THE STATE OF THE MBOX.

SUBTEST 3 THIS SUBTEST CHECKS AFTER THE NXM TIMEOUT HAS COMPLETED
        THE MEMORY REQUEST.  IT MAKES SURE THAT THE SWEEP CORRECTLY
        GETS TO CCA INVAL T4 TO INVALIDATE THE WORD WHICH HAS BEEN
        WRITTEN BACK.

SUBTEST 4,5,6 ARE THE SAME AS 1,2,3 BUT FOR WORD 1

SUBTESTS 7,8,9 ARE THE SAME AS 1,2,3 BUTFOR WORD 2

SUBTESTS 10,11,12 ARE THE SAME AS 1,2,3 BUT FOR WORD 3
        %




I.C11:  MOV     #EMASK2,EMASK   ;SET EBOX SCAN MASK
        RSTMBX                  ;RESET THINGS
        MOV     #MASKC1,MMASK   ;SCAN TABLE MASK
        INVAL
        MOV     CSHNBR,R0      
        CRRONE                  ;SET UP REFILL RAM
        INVAL                   ;CLEAR CACHE
        RTS     PC


;SEQ262

T.C11:  CLR     R4              ;SET TABLE INDEX
1$:     MOV     T11STA(R4),3$   ;SET UP SCAN TABLE POINTERS
        MOV     CSHNBR,R0
        ASL     R0
        ADD     T11STB(R4),R0
        MOV     (R0),5$
        MOV     T11STC(R4),8$
        MOV     T11STT(R4),R0
        JSR     R5,XQT          ;DO SETOM TO CACHE WORD
        STEREQ  T11SWP,T11EBX   ;LOAD SWEEP FOR STEPPING
        BCC     2$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR SWEEP>

2$:     INSYNC                  ; ***** SUBTEST 1, 4, 7, 10 *****
        JSR     R5,MSCAN
3$:     0
        S10.    10              ;WRITEBACK T1 A H
        BCC     4$
        FAULTC  <ONE WORD WRITEBACK PROBLEM>

4$:     INSYNC                  ; ***** SUBTEST 2, 5, 8, 11 *****
        MOV     #MASKC3,MMASK   ;SCAN TABLE MASK

        JSR     R5,MSCAN
5$:     0
        S10.    10                      ;CACHE IDEL L
        BCC     6$
        FAULTC  <ONE WORD WRITE BACK PROBLEM>

6$:     BRST    2035.
         
        FIND    <160,23,0>              ;NKM ANY L
        BCC     7$
        ERROR   <NO NXM>

7$:     INSYNC                  ; ***** SUBTEST 3, 6, 9, 12 *****
          
        MOV     #MASKC1,MMASK   ;SCAN TABLE MASK
        JSR     R5,MSCAN
8$:     0
        S10.    15                      ;CCA INVAL T4
        BCC     9$
        FAULTC  <SHOULD INVALIDATE AFTER UPDATE>


9$:     TST     (R4)+


;SEQ263

        CMP     R5,#12.
        BGE     10$             ;4 LOOPS, 8 SUBTESTS
        JMP     1$
10$:    NORMAL
T11SWP: IO10    SWPUO,,,1       ;SWEEP ONE INVALID AND UPDATE

        
.EVEN

T11STT: 1$,2$,3$,4$
1$:     I10     SETOM,0,,1774   ;WORD 0

2$:     I10     SETOM,0,,1775   ;WORD 1

3$:     I10     SETOM,0,,1776   ;WORD 2

4$:     I10     SETOM,0,,1777   ;WORD 3

.EVEN


;SEQ264

.SBTTL          TEST#39 - TWO WORD WRITEBACK TEST
.REM    %
TEST#39

        THIS TEST TRIES THREE TWO-WORD WRITEBACKS AND COUNS ACKN
PULSES.  IT IS PRIMARILY CONCERNED WITH CHECKING THE REQUEST COUTING
LOGIC ON THE MBHC BOARD.  IN EACH TEST CASE, RQ0 IS PARED WITH
ONE OF THE OTHER THREE REQUESTS - RQ1, RQ2, OR R33.  THE TEST WRITES A
PAIR OF WORDS TO CACHE AND THEN STEPS A SWEEP-AND-UPDATE-CORE IN ORDER
TO CAUSE A WRITEBACK REQU4ST.  THE PAIRS OF LOCATIONS USED ARE:

        SUBTEST ADDRESS REQUESTS
        1 AND 2 1774,1775 RQ0,RQ1
        3 AND 4 1774,1776       RQ0,RQ2
        5 AND 6 1774,1777       RQ0,RQ3

        %


I.C20:  MOV     #EMASK2,EMASK   ;SET EBOX SCAN MASK
        RSTMBX
        CRRSTD
        INVAL
        RTS     PC

T.C20:  MOV     #T11STT,R4      ;POINT TO SETOM TABLE
        TST     (R4)+           ;START AT RQ1
1$:     MOV     T11STT,R0       ;GET POINTER TO SETOM 1774
        JSR     R5,XQT          ;DO IT
        MOV     (R4)+,R0        ;GET SECOND WORD REQUEST SETCM
        JSR     R5,XQT          ;DO IT
        STEREQ  T11SWP,T20EBX   ;PUT SWEEP IN AR
        BCC     2$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP>

2$:     BRST    2050.           ;GO THRU NXM TIMOUT
        FIND    <160,23,0>      ;NXM ANY
        BCC     3$              ;IF FOUND
        ERROR   <NO NXM>

3$:     INSYNC                  ; ***** SUBTEST 1,3,5 *****
        FIND    <160,21,1>      ;NXM ACKN H
        BCC     4$              ;IF O.K.
        FAULT   <DIDN'T GET AN ACKN FOR RQ0>


;SEQ265

4$:     INSYNC                  ; ***** SUBTEST 2,4,6 *****
        FIND    <160,21,1>      ;NXM ACKN H AGAIN
        BCC     5$              ;IF O.K.
        FAULT   <SECOND NXM ACKN FAILED TO OCCUR.>

5$:     CMP     R5,#6
        BLT     1$              ;3 LOOPS, 6 SUBTESTS
        NORMAL





;SEQ266

.SBTTL          TEST#40 - WRITEBACK ADDRESS PATH TEST
.REM    %

        THIS TEST CHECKS THE ADDRESS PATHS FROM THE 
CACHE DIRECTORY THRU THE CAM 14-26 MIXERS ON THE CHX BOARD, THRU
THE PMA ADDRESS MIXERS TO THE EBUS REGISTER.  THE E-BUS REGISTER
IS FORCED TO LOAD FROM THE PMA SO THAT IT CAN BE CHECKED FOR THE
PROPER ADDRESS AT MEM START TIME.  SIXTEEN ENTRIES ARE WRITTN IN
THE CACHE DIRECTORY AND FORCED OUT ONE ATA TIME BY SINGLE-STEPPING
A SWEEP.  THE PAGE NUMBERS OF THE SIXTEEN ENTRIES ARE CHOSEN TO
DETECT ANY MULTIPLE SELECTION PROBLEMS IN THE CAM MIXERS.

SUBTEST NUBMERS 1 THRU 8 IDENTIFY THE PATTERN BEING USED.,  THE
CACHE BEING SELECTED BY EACH SUBTEST IS:
        CACHE   SUBTESTS
        -----   --------
          3     1,5,9,13
          2     2,6,10,14
          1     3,7,11,15
          0     4,8,12,16
        %
I.C22:  MOV     #EMASK1,EMASK           ;SET EBOX SCAN MASK
        MOV     #-1,PMAFLG              ;MAKE EBUS REG GET LOADED
        RSTMBX
        CRRSTD
        INVAL
        RTS     PC

T.C22:  LOAD    0,T22CD1,17
        RUN     0                       ;WRITE 8 PATTERNS TO CACHE
        LOAD    6,T22CD2,9.
        RUN     0                       ;WRITE 8 MORE
        STEREQ  T22SWP,T22EBX   ;LOAD AR WITH SWEEP INSTR
        BCC     1$              ;IF NO ERR
        ERROR  <WRONG EBOX SETUP>

1$:     MOV     #T22XP1,4$      ;EXPECTED DATA POINTER
 

;SEQ267

2$:     INSYNC                  ;NEW SUBTEST NUMBER
        FIND    <166,32,0>      ;MEM START L
        BCC     3$
        FAULT   <MEM START DIDN'T OCCUR !>

3$:     JSR     R5,MSKDF        ;GO READ AND COMPARE
        EBUSRG                  ;WHAT TO READ
        T22MSK                  ;COMPARE BITS 14-33
4$:     0                       ;EXPECTED DATA PTR GOES HERE
        BCC     5$
        FAULT   <BAD WRITEBACK ADDRESS PATH>

5$:     ADD     #5,4$           ;NEXT DATA POINTER
        CMP     R5,#10  
        BNE     6$
        ADD     #5,4$           ;SKIP AOBJN POINTER
6$:     CMP     R5,#20          
        BLT     2$              ;DO 16 SUBTESTS
        NORMAL


;SEQ268

T22CD1: I10     MOVE,5,,0,6     ;0-NEXT PATTERN

        I10     XCT,0,,4                ;1-DO 23-BIT ADR-SETOM

        I10     AOBJN,6,,0      ;2-NEXT PATTERN POINTER
        
        I10     JRST,4,,3               ;3-STOP

        I10     SETOM,0,,0,5    ;4-WRITE INSTR.

        WD36    0000,0000,0000  ;5-23-BIT ADDR GOES HERE

        WD36    7777,7000,0007  ;6-AOBJN PTR  -10,,7


;FIRST EIGHT DATA PATTERNS,  AC7-16.
T22XP1: WD36    0000,0000,1777  ;7-

        WD36    0000,0000,2777  ;10-

        WD36    0000,0000,4777  ;11-

        WD36    0000,1777,0777  ;12-

        WD36    0000,0000,2773  ;13-

        WD36    0000,0000,4773  ;14-
        WD36    0000,1777,0773  ;15-

        WD36    0000,0000,1773  ;16-

;SECOND EIGHT PATTERNS GET LOADED TO AC 7-16, POINTER TO 6.
T22CD2: WD36    7777,7000,0007  ;NEW AOBJN PTR

        WD36    0000,0000,4767  ;7-

        WD36    0000,1777,0767  ;10-


;SEQ269

        WD36    0000,0000,1767  ;11-

        WD36    0000,0000,2767;12-

        WD36    0000,1777,0763  ;13-

        WD36    0000,0000,1763  ;14-

        WD36    0000,0000,2763  ;15-

        WD36    0000,0000,4763  ;16-

.EVEN
T22MSK: WD36    7777,6000,0003  ;ALLOW BITS 14-33

T22SWP: IO10    SWPVA,,,17777   ;SWEEP ALL UPDATING - THE

                                ;ADDRESS IS ONES FOR FUN

.EVEN


;SEQ270

.SBTTL          TEST#41 - WRITE FORCING WRITEBACK
.REM    %
THIS TEST CAUSES A WRITEBACK BY WRITING TO A QUADWORD OF CACHE
THAT IS OCCUPIED BY A WORD WRITTEN TO A DIFFERENT PAGE.  IF
CHECKS THE MBOX STATE WHEN THE WRITEBACK SHOULD AHAPPEN AND WHEN THE
NEW WORD SHOULD BE GETTING WRITTEN INTO THE CACHE.  CACHE 1 IS
USED FOR THIS TEST.

SUBTEST 1 WRITES A WORD TO LOCATION 357 IN CACHE THEN STARTS
        EXZECUTION OF A WRITE TO LOCATION 1357.  BURST-STEPPING
        TO WHERE WRITEBACK T1 SHOULD BE TRUE.  THE STATE OF THE MBOX
        IS CHECKED AT THIS POINT.

SUBTEST 2 BURST-STEPS THE INSTRUCTION MEM START AND CHECKS THE MBOX
        STATE AS IT SHOULD BE WRITING INTO CACHE.

SUBTEST 4 CHECKS STATES AT THE END OF THE WRITE TO CACHE.
        %

I.C13:  RSTMBX
        MOV     #MASKC3,MMASK   ;SCAN TABLE MASK
        MOV     #1,CSHNBR
        MOV     #'1,CMSGN1
        CRRONE  1
        INVAL
        RTS     PC
T.C13:  XQT     T13ST1          ;MAKE A WRITTEN ENTRY
        STEREQ  T13ST2,T13EBX   ;START SETOM 1357
        BCC     1$              ;IF NO ERROR
        ERROR   <WRONG EBOX SETUP FOR SETOM>
1$:     INSYNC                  ; ***** SUBTEST 1 *****
        MSCAN   T13TB1,4                ;WRITEWBACK T1 A H
        BCC     2$
        FAULTC  <WRITE SHOULD HAVE CAUSED WRITEBACK>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        MSCAN   T13TB2,7                ;MEM START L


;SEQ271

        BCC     3$      
        FAULTC  <WRONG CONDITIONS AT WRITEBACK MEM START>
3$:     INSYNC          ; ***** SUBTEST 3 *****
        MSCAN   T13TB3,13               ;CSH EBOX WR T4
       BCC      4$
        FAULTC  <SHOULD BE WRITING TO CACHE>
4$:     INSYNC                  ; ***** SUBTEST 4 *****
        MSCAN   T13TB4,4                ;CSH EBOX CYC B FALSE
        BCC     5$
        FAULTC  <END OF WRITE TO CACHE AFTER WRITEBACK>

5$:     NORMAL
T13ST1: I10     SETOM,0,,357

T13ST2: I10     SETOM,0,,1357   ;YES, THEY ARE THE SAME LINE NBR

.EVEN


.SBTTL          TEST#42 - READ FORCES WRITEBACK, 4-WD. READ
.REM    %

TEST#42
THIS TEST USES A READ TO CAUSE A WRITEBACK.  CACHE 2 IS CONFIGURED
AND ONE WORD WRITTEN TO CACHE.  A READ OF THE SAME QUADWORD OF A
DIFFERENT PAGE IS USED TO CAUSE A WRITEBACK AND ALSO TO CHECK
WRITING INTO CACHE OF THE FOUR WORDS FETCHED FROM CORE.  MEMORY
IS NOT CONFIGURED FOR THIS TREST, SO THE NXM TIMEOUT LOGIC IS RELIED
ON TO SIMULATE MEMORY RESPONSES.

SUBTEST 1 BURST-STEPS THE READ TO CSH EBOX T3 AND CHECKS MBOX
        STATES.

SUBTEST 2 CHECKS THE MBOX STATES JUST AFTER THE WRITEBACK TO MEMORY
        HAS BEEN STARTED.

SUBTEST 3 CHECKS MBOX STATES AFTER THE NXM LOGIC HAS FINISHED
        THE WRITEBACK.

SUBTEST 4 CHECKS THE MBOX STATE AT THE TIME  ORE READ IN PROG GOES
        TRUE FOR THE FOUR WORD READ.

SUBTEST 5 CHECKS STATES WHEN MBOX RESP SHOULD BE TRUE TO 'DELIVER'
        THE READ WORD (WORD 3) TO THE EBOX.

SUBTEST 6 CHECKS THE MBOX AS IT SHOUD BE WRITING WORD 3 TO CACHE.

SUBTEST 7 CHECKS THE MBOX AS IT SHOULD BE WRITING WORD 0 TO CACHE.

SUBTEST 8 CHECKS THE MBOX AS IT SHOULD BE WRITING WORD 1 TO CACHE

SUBTEST 9 CHECKS THE MBOX AS IT SHOULD BE WRITING WORD 2 TO CACHE.

%




I.C14:  RSTMBX
        MOV     #2,CSHNBR
        MOV     #'2,CMSGN1
        CRRONE  2               ;USE CACHE 2
        INVAL   
        RTS     PC


;SEQ273

T.C14:  XQT     T13ST1          ;MAKE A WRITTEN WORD
        STEREQ  T14MOV,T14EBX   ;START MOVE 2357
        BCC     1$              ;IF NO ERROR
        ERROR   <WRONG EBOX SETUP FOR MOVE>

1$:     INSYNC                  ; ***** SUBTEST 1 *****
        MSCAN   T14TB1,4                ;CSH EBOX T3
        BCC     2$
        FAULTC  <READ SHOULD START A WRITEBACK>

2$:     INSYNC                  ; ***** SUBEST 2 *****
        MSCAN   T14TB2,10               ;NOT CSH USE HOLD H
         BCC    3$
        FAULTC  <MEM START OF WRITEBACK CAUSED BY READ>

3$:     BRST    2035.
        FIND    <160,23,0>      ;NXM ANY
        INSYNC                  ; ***** SUBTEST 3 *****
        MSCAN   T14TB3,13               ;.NOT. CACHE IDLE
        BCC     4$
        FAULTC  <END OF READ AFTER WRITEBACK>


4$:     INSYNC          ; ***** SUBTEST 4 *****
        MSCAN   T14TB4,11               ;CORE RD IN PROG
        BCC     5$
        FAULTC  < >
5$:     BRST    2035.


;SEQ274

        FIND    <160,23,0>      ;NXM ANY
        INSYNC                          ; ***** SUBTEST 5 *****
        MSCAN   T14TB5,5                ;MBOX RESP
        BCC     6$
        FAULTC  < >
6$:     INSYNC
        MSCAN   T14TB6,2                ;MB TEST PAR A IN
        BCC     7$
        FAULTC  <WRITING FIRST READ WORD TO CACHE>

7$:     INSYNC          ; ***** SUBTEST 7 *****
        MSCAN   T14TB7,10               ;MB TEST PAR A IN
        BCC     8$
        FAULTC  <WRITING SECOND READ WORD TO CACHE>

8$:     INSYNC                  ; ***** SUBTEST 8 *****
        MSCAN   T14TB8,6                ;MB TEST PAR A IN
        BCC     9$
        FAULTC  <WRITING THIRD READ WORD TO CACHE>

9$:     INSYNC                  ; ***** SUBTEST 9 *****
        MSCAN   T14TB9,6                ;MB TEST PAR A IN
        BCC     10$
        FAULTC  <WRITING FOURTH READ WORD TO CACHE>
10$:    BRST    200.            ;RUN OUT THE UCODE A WAYS
        NORMAL

T14MOV: I10     MOVE,0,,2357    ;SAME Y AS T13ST1 (LINE ONLY)


;SEQ275


.EVEN


;SEQ276

.SBTTL          TEST#43 - READ WITH LOOK ONLY
.REM    %
TEST#43

THIS TEST CHECKS CACHE OPERATION WITH CACHE LOOK EN TRU BUT CACHE
LOAD EN FALES.  A CACHE WORD IS WRITTEN AND THEN A READ IS PERFORMED
AND CHECKTO SEE THAT IT DOES NOT CAUSE A WRITEBACK OF THE WORD IN
CACHE (A DIFFERENT PAGE, OF COURSE) AND THAT THE WORD READ FROM CORE
DOES NOT GET WRITTEN INTO CACHE.  CACHE 2 IS USED.

SUBTEST 1 STARTS EXECUTING THE READ AND CHECKS MBOX STATES AT
        CACHE EBOX T2.

SUBTEST 2       CHECKS THE START OF THE MEMORY REFERENCE AT CSH DATA CLR
        DONE.

SUBTEST 3 CHECKS MBOX STATES AT THEH END OF THE READ SWEQUENCE.
SUBTEST 4 STEPS A READ OF THE ORIGINAL WORD IN CACHE AND CHECKS
        STATES AT CSH EBOX T3 TO BE SURE THE CACHE DIRECTORY
        IS STILL INTACT.
        %




I.C15:  RSTMBX
        MOV     #MASKC3,MMASK   ;SCAN TABLE MASK
        CRRONE  2               ;USE CACHE 2
        INVAL
        JSR     R5,IQUADR       ;INITIALIZE MB'S
        20                      ;FIRST ADDRESS OF QUAD WORD
        INVAL                   ;CLEAR AGAIN
        XQT     T19COD          ;CONO APR,CLEAR FLAGS
        RTS     PC


;SEQ277

T.C15:  XQT     T13ST2          ;WRITE IN CACHE
        XQT     SETLK           ;SET LOOK ONLY
        INSYNC                  ; ***** SUBTEST 1 *****
        STEREQ  T14MOV,T15EBX   ;START MOVE INSTR
        BCC     1$
        ERROR   <WRONG EBOX SETUP FOR MOVE>

1$:     MSCAN   T15TB1,3                ;CSH EBOX T2
        BCC     2$
        FAULTC  <READ SHOULD GO TO CORE WITH NO WRITEBACK>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        MSCAN   T15TB2,5                ;CSH DATA CLR DONE L
        BCC     3$
        FAULTC  < >
3$:     BRST    2035.
        FIND    <160,23,0>      ;NXM ANY
        BCC     4$
        ERROR   <NO NXM>

4$:     INSYNC                  ; ***** SUBTEST 3 *****
        MSCAN   T15TB3,5                ;READY TO GO
        BCC     5$
        FAULTC  < >
5$:     STEP10  T15MOV,23               ;EBOX REQUEST
;CHECK THAT WE CAN STILL READ FROM CACHE WITH LOOK ONLY
        INSYNC                  ; ***** SUBTEST 4 *****


;SEQ278

        MSCAN   T15TB4,4                ;CSH EBOX T3 L
        BCC     6$
        FAULTC  <READ SHOULD GO TO CACHE>

6$:     NORMAL
T15MOV: I10     MOVE,0,,1357

        
SETLK:  IO10    CONO,PAG,,400000


.EVEN

;SEQ279

.SBTTL          TEST#44 - READ-PAUSE-WRITE DATA IN CACHE
.REM    %
TEST#44

THIS TEST DOES A READ-PAUSE-WRITE WITH CACHE TURNED ON AND
CHECKS TO SEE THAT IT GETS TURNED INTO A READ REFERENCE FOLLOWED
BY A WRITE REFERENCE WHEN THE DATA IS ALREADY IN CACHE.
LOCATION 357 IS WRITTEN IN CACHE AND AN A0S 357 IS USED AS THE
READ-PULSE-WRITE REFERENCE INSTRUCTION.  THE CACHE IS CONFIGURED
TO OPERATE IN ALL FOUR CACHES.  THIS TEST SHOULD USE CACHE 3.

SUBTEST 1 STARTS THE AOS INSTRUCTION AND BURST-STEPS TO WHERE
        MB RESP SHOULD BE TRUE AND CHECKS MBOX STATES.

SUBTEST 2 BURST STEPS TO THE MB RESP OF THE WRITE
        REFERENCE AND CHECKS MBOX STATES.
        %




I.C16:  RSTMBX
        MOV     #MASKC3,MMASK   ;SCAN TABLE MASK
        CRRSTD                  ;ALL CACHES
        JSR     PC,MSCALL       ;CHANGE MESSAGE
        INVAL
        RTS     PC
ALLC:   .ASCIZ  %ALL%

T.C16:  XQT     T13ST1          ;LOAD CACHE
        STEREQ  T16AOS,T16EBX   ;START AOS 357
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR AOS>

1$:     INSYNC                  ; ***** SUBTEST 1 *****
        MSCAN   T16TB1,4                ;MBOX RESP
        BCC     2$
        FAULTC  <END OF R-P-W READ FROM CACHE>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        MSCAN   T16TB2,11               ;MBOX RESP


;SEQ280

        BCC     3$
        FAULTC  <END OF R-P-W WRITE TO CACHE>

3$:     NORMAL
T16AOS: I10     AOS,0,,357

.EVEN


;SEQ281

.SBTTL          TEST#45 - READ-PAUSE-WRITE DATA NOT IN CACHE
.REM    %
TEST#45

THIS TEST CHECKS A READ PAUSE WRITE OPERATION WITH THE CACHE
CONTAINING THE RIGHT QUADWORD BUT NOT THE DESIRED WORD.
THE READ REFERENCE SHOULD CAUSE A THREE WORD 'FILL READD'
TO BE PERFORMED AND THE WRITE REFERENCE SHOULD WRITE TO CACHE.

SUBTEST 1 CHECKS AT CSH EBOX T3 OF THE READ REQUEST.

SUBTEST 2 CHECKS AFTER THE NXM TIMEOUT WHEN MB RESP FOR THE READ
        SHOULD BE TRUE.

SUBTEST 3 CHECKS MBOX STATES DURING THE WRITING OF WORD 1 FROM
        MEMORY TO CACHE.

SUBTEST 4 CHECKS MBOX STATES DURING THE WRITING OF WORD 2 FROM
        MEMORY TO CACHE.

SUBTEST 5 CHECKS MBOX STATES DURING THE WRITING OF WORD 3 FROM
        MEMORY TO CACHE.

SUBTEST 6 CHECKS MBOX STATES WHEN CACHE IDEL SHOULD BE TRUE
        AT THE END OF THE WRITE REFERENCE OF THE READ-PAUSE-WRITE.
        %




I.C17:  RSTMBX
        MOV     #MASKC3,MMASK   ;SCAN TABLE MASK
        CRRSTD                  ;USE WHOLE CACHE
        INVAL
        JSR     R5,IQADW4               ;INIT 4 QUADWORDS IN CACHE
        70                      ;FIRST ADDRESS
        INVAL                   ;CLEAR VALIDS
        MOV     #4,R1
        CLRB    T17STO+1
;
;NOW WRITE TO 70,1070,2070, AND 3070 OF CACHE
;
1$:     MOV     #T17STO,R0
        XQT
        INCB    T17STO+1
        INCB    T17STO+1
        DEC     R1
        BLT     1$
        RTS     PC


;SEQ282

T.C17:  STEREQ  T17AOS,T17EBX   ;START AOS 2071
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR AOS>

1$:     INSYNC                  ; ***** SUBTEST 1 *****
        MSCAN   T17TB1,4                ;CSH EBOX T3
        BCC     2$
        FAULTC  <READ OF R-P-W SHOULD GO TO CORE>
2$:     BRST    2035.
        FIND    <160,23,0>      ;NXM ANY
        BCC     3$
        ERROR   <NO NXM>
3$:     INSYNC                  ; ***** SUBTEST 2 *****
        MSCAN   T17TB2,5                ;MBOX RESP
        BCC     4$
        FAULTC  <WORD FROM CORE TO EBOX>

4$:     INSYNC                  ; **** SUBTEST 3 ****
        MSCAN   T17TB3,2                ;MB TEST PAR A IN
        BCC     5$
        FAULTC  <WRITING FIRST WORD>

5$:     INSYNC
        MSCAN   T17TB4,12               ;MB TEST PAR A IN
        BCC     6$
        FAULTC  <WRITING SECOND WORD>

6$:     INSYNC                  ; **** SUBTEST 5 *****
        MSCAN   T17TB5,6                ;MB TEST PAR A IN


;SEQ283

        BCC     7$
        FAULTC  <WRITING THIRD WORD>

7$:     INSYNC                  ; ***** SUBTEST 6 *****
        MSCAN   T17TB6,1                ;CACHE IDLE L
        BCC     8$
        FAULTC  <END OF WRITE OF R-P-W TO CACHE>

8$:     NORMAL
T17STO: I10     SETOM,0,,70

T17AOS: I10     AOS,0,,2071

.EVEN


;SEQ284

.SBTTL          TEST#46 - ERROR ADDRESS REGISTER CHECK
.REM    %
TEST#46

        THIS TEST FORCES ERRORS DURING CACHE OPERATIONS AND
CHECKS THAT THE ERROR ADDRESS REGISTER GETS THE RIGHT INFORMATION.
CACHE 3 IS USED FOR THE TEST.

SUBTEST 1 WRITES A WORD OF BAD DATA PARITY INTO CACHE AND THEN USES
        S ASWEEP TO WRITE IT BACK TO MEMORY.  THE WRITEBACK OPERATION
        SHOULD DETECT THE PARITY ERROR.

SUBTEST 2 WRITES A WORD IN CACHE WITH BAD DATA PARITY.  A WRITE
        TO THEW SAME LINE OF A DIFFERENT PAGE IS 
        USED TO CAUSE A WRITEBACK
        DURING WHICH THE DATA PARITY ERROR SHOULD BE CAUGHT.

SUBTEST 3 WRITES A WORD IN MEMORY WITH BAD PARITY AND DOES A READ-PAUSE-
        WRITE REFERENCE TO IT WITH THE CACHE TURNED ON.

%

I.C18:  CLR     PMAFLG          ;NO .LOAD OF EBUS REG
        RSTMBX
        CRRONE  3
        MOV     #'3,CMSGN1      
        INVAL
        CMEMEN                  ;TURN MEM BACK ON
        CLR     RPAG
        RTS     PC

T.C18:  MOV     R5,R4
        INSYNC                  ; ***** SUBTEST 1,2,3 *****
        ASL     R4              ;MAKE WORD INDEX
        MOV     T18CFT(R4),CSHFLG
        RSTMBX
        MOVB    T18PIT(R4),T18CPI+1
        MOVB    T18PIT+1(R4),T18CPI+2
        XQT     T18CPI          ;COND PI, FORCE BAD PAR
        MOV     #36,RPAG
        MOV#T18STP,R0
        INMBAS  MCBASA
        XQT                     ;WRITE TEST DATA
        XQT     CSHPTS          ;RESET APR FLAGS


;SEQ285

        MOV     T18INS(R4),R0   ;GET TEST INSTR
        MOV     T18PGT(R4),RPAG
        BEQ     1$              ;ZERO MEANS DON'T DO IT
        INMBAS  MCBASA

;SEQ286

1$:     XQT             ;CAUSE THE ERROR
        XQT     RDERA   ;READ THE ERA TO AC17
        READ17          ;GET AC 17
        MOV     R0,3$
        MOV     T18XDT(R4),R0   ;GET EXPECTED DATA
        MOV     #36,RPAG
        INMBAS  MCBASA
        MOV     R0,2$
        JSR     R5,MASK36       ;GO CHECK ERA DATA
        T18MSK          ;MASK
2$:     0               ;EXPECTED
3$:     0               ;ACTUAL
        BCC     4$              ;BR IF NO ERROR
        FAULTC  <ERROR ADDRESS REGISTER NOT AS EXPECTED>
4$:     CMP     R5,#3           ;DONE?
        BLT     T.C18           ;DO 3 SUBTESTS
        NORMAL

T18CFT: .WORD   -1,-1,0
T18PIT: 400                     ;EVEN CSH DATA PAR
        400                     ;EVEN CSH DATA PAR
        400                     ;EVEN MEM DATA PAR
T18INS: 1$,2$,3$
1$:     IO10    SWPUA,,,0
2$:     I10     SETOM,0,,12525
3$:     I10     AOS,0,,36525
T18CPI: IO10    CONO,PI,,0
T18STP: I10     SETOM,0,,36525
RDERA:  IO10    RDERA,,,17      ;READ ERA TO AC17
T18MSK: WD36    0037,6000,0000
.EVEN
T18XDT: 1$,2$,3$


;SEQ287

1$:     WD36    3340,0003,6525

2$:     WD36    2340,0003,6525

3$:     WD36    2000,0003,6525

.EVEN
T18PGT: 0,12,36



;SEQ288

.SBTTL          TEST#47 - CSH DIR PAR ERR INHIBITS CACHE
.REM    %
TEST#47

THIS TEST CAUSES A CACHE DIRECTORY PARITY ERROR AND CHECKS THAT
CACHE BIT IS HELD FALSE AND FORCE NO MATCH IS HELD TRUE FROM THEN
UNTIL THE APR CSH DIR PAR ERR FLAG IS CLEARED.  IT CHECKS THAT
CLEARING THE APR FLAG RESTORES THE CACHE TO OPERATION.

SUBTEST 1 WRITES A WORD WITH BAD DIRECTORY PARITY TO
        CACHE LOCATION 777.  IT THEN STEPS A READ WHICH WILL
        CAUSE A WRITEBACK (MOVE 17,1777).  THE CSH DIR PAR ERR WILL
        BE DETECTED DURING THE WRITEBACK.  A FULL SCAN OF MBOX STATES
        IS TAKEN AT THE TIME WHEN APR C DIR P ERR IN IS TRUE.
SUBTEST 2 BURSTS THE CCLOCK TO FINISH THE MOVE AND THEN CHECKS
        THAT C DIR P ERR IS HOLDING THE CACHE OFF.

SUBTEST 3 CLEARS THE C DIR P ERR FLAG AND CHECKS THAT CACHE
        BIT GOES TRUE AND FORCE NO MATCH GOES FALSE.

        %

I.C19:  RSTMBX
        CRRONE  2               ;USE CACHE 2
        INVAL
        JSR     R5,IQUADW       ;WRITE A QUADWORD IN CACHE
        774                     ;FIRST ADDRESS
        INVAL                   ;CLEAR VALIDS
        MOV     #2,CSHNBR
        MOV     #'2,CMSGN1
        CMEMEN                  ;ENABLE MEMORY
;
;NOW WRITE BAD DIRECTORY PARITY IN 777
;
        LOAD    1,T19COD,11
        RUN     1               ;DO SETUP
        RTS     PC


;SEQ289

T.C19:  INSYNC                  ; ***** SUBTEST 1 *****
        STEREQ  TC19MV,T19EBX   ;START A READ
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP>
1$:     FIND    <173,27,1>      ;WRITEBACK T1 A H
        MSCAN   T19TAB,10               ;D DIR P ERR IN H
        BCC     2$              ;IF NO ERR
        FAULTC  <WRONG STATES>

2$:     BRST    4500.           ;FINISH READ, NXM OR NOT
        INSYNC                  ; ***** SUBTEST 2 *****
        CMP.S   T19STA,6        ;APR C DIR P ERR SHOULD BE
                                ;HOLDING OFF CACHE NOW.
        BCC     3$              ;IF NO ERROR
        FAULTC  <CACHE NOT BEING INHIBITED>


3$:     XQT     T19COD          ;CLEAR APR FLAGS
        INSYNC                  ; ***** SUBTEST 3 *****
        CMP.S   T19STA,1        ;CACHE BIT SHOULD COME BACK ON
        BCC     4$              ;IF NO ERR
        FAULTC  <CSH ADR PAR ERR DIDN'T CLEAR, MAYBE>

4$:     NORMAL

T19COD: IO10    CONO,APR,,27760 ;1-CLEAR FLAGS


;SEQ290

        IO10    SWPIA,,,0               ;2-SWEEP CACHE

        IO10    CONSO,APR,,20   ;3-SWEEP DONE?

        I10     JRST,0,,3       ;4-WAIT
        IO10    CONO,PAG,,600000        ;5-TURN ON CACHE

        IO10    CONO,PI,,100000 ;6-ENABLE EVEN DIR PAR
        I10     SETOM,0,,777    ;7-WRITE TO CACHE

        IO10    CONO,PI,,0      ;10-RESTORE ODD PARITY GEN

        I10     JRST,4,,1       ;11-HALT

.EVEN

;TOP TO BOTTOM:APR C DIR P ERR IN H, FORCE NO MATCH H
;CACHE BIT H

T19STA: DF.     110

        BP.     10

        DF.     172

        BP.     32
        DF.     170

BP.     -30

.EVEN
TC19MV: I10     MOVE,17,,1777


.EVEN


;SEQ291

.SBTTL          TEST#48 - CACHE TO MEMORY DATA EXERCISE
.REM    %
THIS TEST RUNS A READ/WRITE PROGRAM IN THE AC'S AND MONITORS THE RESULTS.
THE AC PROGRAM COMPARES THE DATA READ WITH THAT WRITTEN AND ALSO CHECKS
APR FLAGS FOR:  SUBUS ERROR, NXM, MB PAR ERR, AND CSH
DIR PAR ERR.  IF THE 11 PROGRAM FINDS THAT THE AC PROGRAM MADE AN
ERROR HALT, THE INFORMATION PERTAINING TO THE TYPE OF ERROR IS
COLLECTED AND PRINTED.  (CONI APR DATA, ERROR ADDRESS REGISTER, DATA
ADDRESS, EXPECTED AND ACTUAL DATA.)

THE AC PROGRAM WRITES 8 PAGES (4096 WORDS) OF DATA THROUGH THE CACHE
INTO MEMORY AND THEN READS AND CHECKS 8 PAGES.  ADDRESSES ARE DOWN-
COUNTED FROM X17777 TO X10000.  (X IS NORMALLY ZERO, BUT
IT DEPENDS ON WHERE THE LOWEST 16K MEMORY MODULE WAS CONFIGURED IN
THE ADDRESS SPACE.)  THE DATA WORD IS DOWN-COUNTED IN EACH OF THREE
12-BIT GROUPS, CHANGING FROM 777777 777777 TO 777677 767776 FOR EXAMPLE.
THIS PATTERN GIVES EVERY BIT A CHANCE TO CHANGE WHILE CAUSING PARITY
TO CHANGE ON EVERY WORD.
        %
I.C21:  CLR     PMAFLG  ;NO AUTO-LOAD OF EBUS REG
        RSTMBX
        CRRSTD
        JSR     PC,MSCALL               ;ALL CACHES
        INVAL   
        CMEMEN                  ;ENABLE MEMORY
        MOV     #10,RPAG        ;PAGE 10, RELATIVE
        MOV     #T21CAM,R0
        INMBAS  MCBASA
        MOV     #T21MVM,R0      
        INMBAS  MCBASA
        RTS     PC

T.C21:  LOAD    0,T21COD,16
        RUNBIG  0,4             ;RUN THE TEST
        BCC     1$
        ERROR   <AC CODE HUNG>


1$:     DFRDT
        150                     ;GET THE PC


;SEQ292

        BIT     #BIT2,@DEXWDS   ;CHECK BIT 35
        BNE     2$              ;OD MEANS ERROR
        NORMAL
2$:     JSR     PC,GET21R       ;READ BACK ALL RESULTS
        MOVB    G21STA,R5
        NEG     R5
        ADD     #2,R5           ; ***** SUBTEST 1 - WRITE, 2 - READ *****
        JSR     PC,P21CNI       ;PRINT CONI APR DATA
        JSR     PC,P21ERA       ;PRINT ERR ADR REG
        JSR     PC,P21ADR       ;PRINT DATA ADDRESS
        JSR     PC,P21GDD       ;PRINT EXPECTED DATA
        JSR     PC,P21BDD       ;PRINT ACTUAL DATA
        ERCRLF          ;END WITH CARRIAGE RETN
        FAULT


;SEQ293

;ROUTINES TO READ BACK RESULTS FROM THE 10 SIDE

GET21R: MOVB    #15,GETADB              ;FIRST ADDR
        MOV     #G21STA,R2      ;START OF BUFFER
1$:     MOV     #GETADB,R0      ;POINT ADDRESS
        EXAM
        BCS     2$              ;IF ERROR
        JSR     PC,GT21XF       ;STORE IN BUFFER
        INCB    GETADB          ;NEXT ADDRESS
        CMP     GETADB,#17      ;DONE?
        BLE     1$              ;DO THREE TIMES

        DECB    GETADB  ;17 AGAIN
        XQT     RDERA           ;MOVE ERA TO 17
        MOV     #GETADB,R0
        EXAM
        BCS     2$              ;IF ERROR
        JSR     PC,GT21XF       ;MOVE TO BUFFER

        XQT     CNIAPR          ;DO CONI APR,17
        MOV     #GETADB,R0      ;POINT TO ADDR
        EXAM
        BCS     2$              ;IF ERROR
        JSR     PC,GT21XF       ;COPY TO BUFFER

        MOV     #G21ADR,R0      ;DATA ADDRESS
        INMBAS  MCBASA
        EXAM            ;EXAMINE THE LOC.
        BCS     2$              ;IF ERROR
        JSR     PC,GT21XF       ;MOVE TO BUFFER
        RTS     PC
2$:     ERROR   <EXAMINE>

GT21XF: MOV     #5,R1           ;LOOP COUNT
        
1$:     MOVB    (R0)+,(R2)+     ;MOVE A BYTE TO BUFFER
        DEC     R1              
        BGT     1$              ;DO 5 TIMES
        RTS     PC


;SEQ294

;BUFFERS TO STORE RESULTS FROM 10

G21STA:         .BYTE   0,0,0,0,0       ;STATE  1=WRITE, =READ
G21EXD: .BYTE   0,0,0,0,0               ;EXPECTED DATA
G21ADR: .BYTE   0,0,0,0,0       ;ADDRESS
G21ERA: .BYTE   0,0,0,0,0       ;ERA REG CONTENTS
        
G21CNI: .BYTE   0,0,0,0,0       ;CONI APR BITS
G21ACD: .BYTE   0,0,0,0,0       ;ACTUAL DATA
        GETADB: .BYTE   0,0,0           ;EXAMINE ADDRESS BUFFER
        
.EVEN

;ERROR STACK LOADING ROUTINES

P21CNI: ERRMSG  <CONI APR: >

        MOV     #G21CNI,R0
        ERRCOM  PNT36
        RTS     PC
P21ERA: ERRMSG  <\ERA REG:  >

        MOV     #G21ERA,R0
        ERRCOM  PNT36
        RTS     PC
P21ADR: ERRMSG  <\ADDRESS:	 >

        MOV     #G21ADR,R0
        ERRCOM  PNT23
        RTS     PC
P21GDD: ERRMSG  <\EXP DATA: >

          MOV   #G21EXD,R0
        ERRCOM  PNT36
        RTS     PC
P21BDD: ERRMSG  <\ACT DATA: >




;SEQ295

        MOV     #G21ACD,R0
        ERRCOM  PNT36
        RTS     PC

;-----CACHE TO MEM EXERCISER AC PROGRAM.
T21COD: IO10    CONO,APR,,27760 ;0-CLEAR FLAGES

        I10     MOVEI,17,,7777   ;1-FIRST ADDRESS

I10     SETOM,0,,16     ;2-SET INITIAL DATA

        I10     XCT,0,,13,15    ;3-DO MOVEM OR CAMN

        IO10    CONSZ,APR,,6600 ;4-CHECK ERROR STATUS

        I10     JRST,4,,5               ;5-ERROR HALT

        I10     SUB,16,,12      ;6-NEXT DATA PATTERN

        I10     SOJGE,17,,3     ;7-NEXT ADDRESS

        I10     SOJE,15,,1      ;10-CHANGE FROM WRITE TO READ

        I10     JRST,4,,0       ;11-NORMAL HALT

        WD36    0001,0001,0001  ;12-DATA DECREMENT
T21CAM: I10     CAMN,16,,10000,17       ;13-DATA COMPARE

T21MVM: I10     MOVEM,16,,10000,17      ;14-DATA WRITE

        WD36    0000,0000,0001  ;15-STATE CTR, 1=MOVEM  0=CAMN

                                ;16-DATA
                                ;17-ADDRESS

.EVEN


;SEQ296



.SBTTL          TEST#49 - CACHE /PAGED REFERENCES

.REM    %
TEST#49

THIS EST CHECKS THE CONTROL AND DATA PATHS USED TO
FETCH PAGE REFILL ENTRIES FROM THE CACHE.  IT ALSO CHECKS THAT THE
CACHE BIT SIGNAL IS CONTROLLED BY PT CACHE WHEN PAGING IS ENABLED.
        %

I.C23:  MOV     #-1,PMAFLG              ;ENABLE PMA LOAD OF EBUS REG
        CLR     CSHFLG          ;DO SET UP WITH CACHE OFF
        RSTMBX                  ;RESET
        CRRSTD
        INVAL   
        CMEMEN                  ;ENABLE USE OF MEMORY
        LOAD    1600,TC23PT,4   ;LOAD DUMMY PAGE TABLE 
        XQT     T23PAG          ;ENABLE KI PAGING
        XQT     T23MAP          ;FORCE A REFILL
        RTS     PC

T.C23:  MOV     #-1,CSHFLG      ;ENABLE LOOK AND LOAD
        RSTMBX
        LOAD    1600,TC23CD,1   ;PUT 1 PAGE PTR IN CACHE
        XQT     T23CPG                  ;CONO PAG, LOOK+LOAD+TRAP EN
        INSYNC                  ; ***** SUBTEST 1 *****
        STEREQ  T23INS,T23EBX   ;START PAGED CACHE REF.
        BCC     1$              ;IF NO ERR
        ERROR   <WRONG EBOX SETUP FOR SETOM>

1$:     FIND    <176,29,0>      ;REFILL T4


;SEQ297

        MSCAN   T23TB1,14               ;MEM START
        BCC     2$              ;BR IF OK
        FAULT   <PAGE REFILL WORD 0 SHOULD BE IN CACHE>

2$:     INSYNC                  ; ***** SUBTEST 2 *****
        FIND    <170,22,0>      ;PAGE REFILL COMP
        MSCAN   T23TB2,4                ;CSH DATA CLR T1
        BCC     3$              ;BR IF OK
        FAULT   <PT CACHE SHOULD MAKE THIS WRITE TO CACHE>

3$:     NORMAL
TC23PT: WD36    7000,0070,0001

        WD36    7000,0270,0003

        WD36    7000,0470,0005

        WD36    7000,0670,0007

TC23CD: WD36    7200,1072,0011

T23INS: I10     SETOM,0,,200

T23CPG: IO10    CONO,PAG,,620001        ;LOOK,LOAD,PAGING

T23PAG: IO10    CONO,PAG,,20001 ;PAGING ONLY

T23MAP: I10     MAP,17,,200     ;MAP TO FORCE REFILL

.EVEN


;SEQ298

.SBTTL          TEST#50 - DMA20 THREE WORD OPS
.REM    %
TEST#50
        THIS TEST PERFORMS THREE WORD READS AND WRITES TO THE DMA20
TO CHECK ITS MULTI-WORD REQUEST AND ACKNOWLEDGE
COUNTING LOGIC.  THIS TEST IS IS DGMCA BECAUSE USING THE CACHE IS
THE OINLY WAY TO CAUSE MULTIWORD WRITES TO THE DMA20 ON A KL WITHOUT
INTERNAL CHANNELS.

SUBTEST 1       
        PERFORMS 512 33-WORD WRITES.  ONE CACHE (CACHE 1)
        IS FIGURED SO THAT WRITEBACKS WILL OCCUR ON
        THE FIRST OF THREE WRITES TO A NEW PAGE.  A PROGRAM
        RUNNING IN THE AC'S WRITES TO THE CACHE IN THIS 
        SEQUENCE:       (ADDRESSES)
        XXX703,XXX702,XXX701    XX1700,XX1703,XX1702
        XXX701,XXX700,XXX703    XX1702,XX1701,XX1700

        THE XX'S DEPEND ON THE ADDRESS OF THE LOWEST MEMORY
        CONFIGURED ON THE DMA20.

        THE WRITE TO CACHE ADDRESS      CAUSES DMA 3-WORD REQUESTS
        XX1700                          3,2,1
        XXX701                          0,3,2
        XX1702                          1,0,3
        XXX703                          2,1,0

SUBTEST 2       CAUSES THREE WORD REDS AND A ONE-WORD WRITE)
        BY USING A MODIFICATION OF THE SAME
        AC PROGRAM AS ABOVE.  IT WRITES ONE WORD OF A PAGE THEN
        READS A DIFFERENT WORD CAUSING THE CACHE TO READ THE
        REMAINING (UNWRITTEN) WORDS FROM THE DMA20.  THE
        WRITE WILL CAUSE A ONE-WORD WRITEBACK OF THE WORD
        WRITTEN TO THE P[REVSIOUS PAGE.

        PROGRAM SEQUENCE                CACHE AND MEMORY ACTIONS
        WRITE   XXX703                  WRITEBACK 1702
        READ    XXX702                  3-WORD READ 702,700,701
        READ    XXX701                  READ CACHE 701

        WRITE   XX1700                  WRITEBACK 703
        READ    XX1703                  3-WORD READ 1703,1701,1702
        READ    XX1702                  READ CACHE 1702

        WRITE   XXX701                  WRITEBACK 1700
        READ    XXX700                  3-WORD READ 700,702,703
        READ    XXX703                  READ CACHE 703

        WRITE   XX1702                  WRITEBACK 701
        READ    XX1701                  3-WORD READ 1701,1703,1700
        READ    XX1700                  READ CACHE 1700

%


;SEQ299

I.C24:  MOV     #-1,CSHFLG              ;MAKE SURE CACHE IS ON
        CLR     PMAFLG
        TST     DMABAS                  ;SEE IF DMA20 EXISTS
        BMI     1$                      ;BR IF NOT
        JSR     R5,RSTDMA               ;CONFIGURE ONLY DMA20
        MOV     DMABAS,TEM.
        BR      2$
1$:     CMEMEN
        MOV     MCBASA,TEM.
2$:     CRRONE  1                       ;USE CACHE #1
        INVAL   
        CLR     RPAG
        MOV     #T24RW3,R0
        INMBAS  TEM.                    ;OFFSET TO MEMORY BASE
        LOAD    0,T24RW3,16.    
        RTS     PC

T.C24:  INSYNC                          ; ***** SUBTEST 1,  3-WORD WRITES *****
        XQT     CDTCHK          ;CVLEAR APR FLAGS
        RUNBIG  0,10            ;DO TEST IN AC'S
        BCC     1$              ;IF RAN O.K.
        ERROR   <AC CODE HUNG>

1$:     DFRDT
        150
        BIT     #BIT2,@DEXWDS          ;TEST PC35
        BNE     3$              ;GO GET ERROR DATA

        LOAD    6,T24RD3,2              ;MODIFY FOR READS NOW
        LOAD    16,T24REP,1     ;RESET REPETITION COUNT


;SEQ300


        INSYNC          ; ***** SUBTEST 2, 3-WORD READS *****
        RUNBIG  0,10
        BCC     2$              
        FAULT   <AC CODE HUNG?>

2$:     DFRDT
        150
        BIT     #BIT2,@DEXWDS           ;TEST PC35
        BNE     3$                      ;GO GET ERROR DATA
        NORMAL

3$:     READ17                          ;GET CONI APR, DATA
        MOV     #G21CNI,R2
          JSR   PC,GT21XF               ;MOVE TO BUFFER
        JSR     PC,P21CNI               ;DO ERROR MESSAGE
        ERCRLF
        FAULT   <MEMORY 3-WORD READ OR WRITE ERROR>


;SEQ301

;AC PROGRAM TO DO 3-WORD WRITES OR READS.
T24RW3:
;               LOOP TO HERE IF DOING 3-WORD WRITES
        I10     SETOM,0,,700,14 ;0-WRITE, INDEXED BY 14

;               LOOP TO HERE TO CHECK STATUS ON 3-WORD READS
        IO10    CONI,APR,,17    ;1-GET APR FLAGS

        I10     TRNE,17,,6700   ;2-SKIP IF NO ERROR FLAGS

        I10     JRST,4,,3       ;3-ERROR HALT

        I10     SOJGE,14,,6     ;4-SELECT NEXT ADDRESS

        I10     MOVEI,14,,3     ;5-WRAP AROUND 0 TO 3

        I10     JFCL,0,,7       ;6-DO NOTHING (READ GOES HERE)

        I10     SOJGE,15,,0     ;7-COUNT 3 OPERATIONS


        I10     MOVEI,15,,2     ;10-RESET FOR NEXT 3

        I10     TRC,0,,1000     ;11-ALTERNATE PAGES

        I10     SOJGE,16,,0     ;12-COUNT REPETITIONS

        I10     JRST,4,,12      ;13-NO ERROR HALT

        WD36    0000,0000,0003  ;14-ADDRESS INDEX

        WD36    0000,0000,0002  ;15-OPERATION COUNT

T24REP: WD36    0000,0000,1000  ;16-REPETITION COUNT

        WD36    0000,0000,0000  ;17-DATA BUFFER

.EVEN

;OVERLAY FOR AC 6 AND 7 FOR 3-WORD READ TEST


;SEQ302

T24RD3: I10     MOVE,17,1,0     ;6-USE ADDRESS OF SETOM, INDIRECTLY

        I10     SOJGE,15,,1     ;7-LOOP TO CONI NOW
 
.EVEN


;SEQ303

ENDPAS: MRESET                  ;RESET THE CPU
        JSR     R5,RSTMCN       ;RESTORE MEMORY CONFIGURATION
        TST     SCANWD          ;UPDATE IN PROGRESS?
        BEQ     2$              ;NO
        JSR     PC,SCPASS       ;DO END SCANOUT PASS CONTROL
        TST     SCANWD          ;LAST PASS COMPLETED>
        BNE     2$              ;NO,RETURN
        MOV     #JUSLOD,OSTATE  ;RESET TO 'JUST LOADED'
        CLR     IMEMCF          ;AND 'NO MEMORY'
        CLR     CSHOPT          ;CLEAR CACHE OPTION FLAG
        GETVER
1$:     
        PMSG    <CD DHMCA.A11 3000,>
        
        MOV     $$FF,R0         ;GET ADDR OF END OF PROG.
        PNTOCS                  ;CORE DUMP TO OUTPUT BUFFER
        PNTVER
        PCRLF                   ;PRINT THE COMMAND
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;DUMP THIS PROGRAM
        BCC     2$              ;DUMP O.K.
        PMSG    <ERR, PLS DUMP PRGM - HC WHEN READY>

        PRGHLT
        BR      1$              ;TRY AGAIN
2$:     RTS     PC              ;RETURN


;SEQ304

;QUADWORDS INITIALIZORS TO ELIMINATE PARITY FLAVOR PROBLEMS
;WHEN LOOPING INDIVIDUAL TESTS.
;
IQUADR: MOV     #QREAD,R1       ;POINT AT MOVE INSTR
        BR      IQCOM           ;TO COMMON EXECUTION CODE

IQUADW: MOV     #QWRIT,R1       ;POINT AT SETOM INSTR

IQCOM:  MOV     #4,R2           ;LOOP COUNT
        MOV     (R5)+,(R1)      ;SET FIRST ADDRESS
1$:     MOV     R1,R0           ;POINT TO INSTRUCTION
        XQT
        INC     (R1)            ;NEXT WORD ADDRESS
        DEC     R2
        BNE     1$              ;DO 4 WORDS
        RTS     R5

QREAD:  I10     MOVE,0,,0

.EVEN
QWRIT:  I10     SETOM,0,,0


.EVEN

IQADR4: MOV     (R5)+,2$        ;GET FIRST ADDRESS
        MOV     #4,R3           ;PAGE COUNT
1$:     JSR     R5,IQUADR       ;READ A QUADWORD
2$:     0                       ;FIRST PAGE ADDRESS HERE
        ADD     #1000,2$                ;NEXT PAGE
        DEC     R3
        BNE     1$              ;DO 4 PAGES
        RTS     R5

IQADW4: MOV     (R5)+,2$        ;GET FIRST ADDRESS
        MOV     #4,R3           ;PAGE COUNT
        
1$:     JSR     R5,IQUADW               ;WRITE A QUADWORD
2$:     0                       ;FIRST PAGE ADDRESS HERE
        ADD     #1000,2$
        DEC     R3
        BNE     1$
        RTS     R5              ;DO  4 PAGES


;SEQ305

.SBTTL          SCANOUT TABLE STORAGE
;SCANOUT MASK TABLE FOR FIRST TESTS
;
MASKC1: .BYTE   0               ;USED FOR STATUS BITS
        .BYTE   201             ;163     26-34
        .WORD   1743            ;160     20-35  PAG MB 18-35 PAR H
                                ;  AND FORCE VALID MATCH 0,1,2,3
        .BYTE   2               ;160     12-19  MB PAR BIT IN
        .BYTE   1               ;164     26-34
        .WORD   21003           ;161     20-35  MBOX NXM ERR.CSH PAR BIT A
        .BYTE   36              ;161     12-19  MBOX ADR PAR ERR
                                ;CBUS PAR LEFT TE, MEM PAR IN,CSH PAR BIT
        .BYTE   341             ;165     26-34  CAM SEL 1,2
        .WORD   7001            ;162    20-35  MBOX MB PAR ERR
                                ;PAG MB 00-17 PAR, CSH PAR BIT B
        .BYTE   14              ;162     12-19  CBUS PAR RIGHT TE
                                ;CSH PAR BIT IN
        .BYTE   1               ;166     26-34
        .WORD   140000          ;170     20-35
        .WORD   140000          ;171     20-35
        .WORD   142000          ;172     20-35
        .WORD   142000          ;173     20-35
        .WORD   142020                  ;174     20-35
        .WORD   142020          ;175     20-35
        .WORD   142010          ;176     20-35
        .WORD   142000          ;177     20-35




MASKC2: .BYTE   0               ;USED FOR STATUS BITS
        .BYTE   201             ;163     26-34
        .WORD   1743            ;160    20-35
                                ;FORCE VALID MATCH 0,1,2,3
        .BYTE   0               ;160     12-19  MB PAR BIT IN
        .BYTE   1               ;164     26-34
        .WORD   3               ;161     20-35  CCH PAR BIT A
        .BYTE   10              ;161     12-19  CBUS PAR LEFT TE
        .BYTE   341             ;165     26-34  CAM SEL 1,2
        .WORD   2001            ;162     20-35
        .BYTE   10              ;162     12-19  CBUS PAR RIGHT TE
        .BYTE   1               ;166     26-34
        .WORD   140000          ;170     20-35
        .WORD   140000          ;171     20-35
        .WORD   142000          ;172     210-35
        .WORD   142000          ;173     20-35
        .WORD   142020          ;174     20-35
        .WORD   142020          ;175     20-35
        .WORD   142010          ;176     20-35
        .WORD   142000          ;177     20-35


;SEQ306

MASKC3: .BYTE   0               ;USED FOR STATUS BITS
        .BYTE   301             ;163     26-34
        .WORD   0               ;160     20-35
        .BYTE   340             ;160     12-19
        .BYTE   1               ;164     26-34
        .WORD   3               ;161     20-35
        .BYTE   370             ;161     12-19  CBUS P[AR LEFT TE
        .BYTE   201             ;165     26-34
        .WORD   13              ;162     20-35
        .BYTE   350             ;162     12-19  CBUS PAR RIGHT TE
        .BYTE   1               ;166     26-34
        .WORD   0               ;170     20-35
        .WORD   0               ;171     20-35
        .WORD   0               ;172     20-35
        .WORD   0               ;173     20-35
        .WORD   0               ;174     20-35
        .WORD   0               ;175     20-35
        .WORD   0               ;176     20-35
        .WORD   0               ;177     20-35

EMASK1: .WORD   0,0,0           
EMASK2: .WORD   0,20004,0       ;APR NXM ERR IN, APR ANY EBOX ERR FLAG


;SEQ307
T2SCTB: .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027014          ;BxL
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000006          ;  F
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034430          ;CdX
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   035355          ;Ckm
        .WORD   015365          ;Aku
        .WORD   031745          ;COe
T3TABS: .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037016          ;CxN
        .WORD   176700          ;Ow@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   024662          ;Bfr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   024004          ;B D
        .WORD   016034          ;Ap\
        .WORD   037016          ;CxN
        .WORD   176570          ;Oux
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   035755          ;Com
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   012004          ;APD
        .WORD   016020          ;ApP
        .WORD   017016          ;AxN
        .WORD   177730          ;O?X
        .WORD   015021          ;AhQ
        .WORD   004756          ; gn
        .WORD   003025          ; XU
        .WORD   026362          ;Bsr
        .WORD   035732          ;CoZ
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035745          ;Coe
        .WORD   031605          ;CNE
        .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037016          ;CxN
        .WORD   176700          ;Ow@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   024662          ;Bfr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   024004          ;B D
        .WORD   016034          ;Ap\
        .WORD   037016          ;CxN
        .WORD   176570          ;Oux
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   035755          ;Com
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   012004          ;APD
        .WORD   016020          ;ApP
        .WORD   017016          ;AxN
        .WORD   177730          ;O?X
        .WORD   015021          ;AhQ
        .WORD   004756          ; gn
        .WORD   003025          ; XU
        .WORD   026362          ;Bsr
        .WORD   035732          ;CoZ
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035745          ;Coe
        .WORD   031605          ;CNE
        .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037016          ;CxN
        .WORD   176700          ;Ow@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   024662          ;Bfr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   024004          ;B D
        .WORD   016034          ;Ap\
        .WORD   037016          ;CxN
        .WORD   176570          ;Oux
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   035755          ;Com
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   012004          ;APD
        .WORD   016020          ;ApP
        .WORD   017016          ;AxN
        .WORD   177730          ;O?X
        .WORD   015021          ;AhQ
        .WORD   004756          ; gn
        .WORD   003025          ; XU
        .WORD   026362          ;Bsr
        .WORD   035732          ;CoZ
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035745          ;Coe
        .WORD   031605          ;CNE
        .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037016          ;CxN
        .WORD   176700          ;Ow@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   024662          ;Bfr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   024004          ;B D
        .WORD   016034          ;Ap\
        .WORD   037016          ;CxN
        .WORD   176570          ;Oux
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   035755          ;Com
        .WORD   035765          ;Cou
        .WORD   031705          ;COE
        .WORD   012004          ;APD
        .WORD   016020          ;ApP
        .WORD   017016          ;AxN
        .WORD   177730          ;O?X
        .WORD   015021          ;AhQ
        .WORD   004756          ; gn
        .WORD   003025          ; XU
        .WORD   026362          ;Bsr
        .WORD   035732          ;CoZ
        .WORD   034620          ;CfP
        .WORD   035321          ;CkQ
        .WORD   035155          ;Cim
        .WORD   025755          ;Bom
        .WORD   035745          ;Coe
        .WORD   031605          ;CNE
T4TAB1: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037010          ;CxH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037010          ;CxH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037010          ;CxH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   037010          ;CxH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
T4TAB2: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   026010          ;BpH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026742          ;Bwb
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035754          ;Col
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   026010          ;BpH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026742          ;Bwb
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035754          ;Col
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   026010          ;BpH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026742          ;Bwb
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035754          ;Col
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   026010          ;BpH
        .WORD   076700          ;Gw@
        .WORD   015021          ;AhQ
        .WORD   004016          ;  N
        .WORD   003021          ; XQ
        .WORD   026742          ;Bwb
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035754          ;Col
        .WORD   024355          ;Bcm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
TC8TB1: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   024010          ;B H
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   027762          ;B?r
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035222          ;CjR
        .WORD   035154          ;Cil
        .WORD   035755          ;Com
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   024010          ;B H
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   027762          ;B?r
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035222          ;CjR
        .WORD   035154          ;Cil
        .WORD   035755          ;Com
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   024010          ;B H
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   027762          ;B?r
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035222          ;CjR
        .WORD   035154          ;Cil
        .WORD   035755          ;Com
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   024010          ;B H
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   027762          ;B?r
        .WORD   035722          ;CoR
        .WORD   034620          ;CfP
        .WORD   035222          ;CjR
        .WORD   035154          ;Cil
        .WORD   035755          ;Com
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
TC8TB2: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   034014          ;C L
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   035220          ;CjP
        .WORD   035322          ;CkR
        .WORD   035654          ;Cnl
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   034014          ;C L
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   035220          ;CjP
        .WORD   035322          ;CkR
        .WORD   035654          ;Cnl
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   034014          ;C L
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   035220          ;CjP
        .WORD   035322          ;CkR
        .WORD   035654          ;Cnl
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   034014          ;C L
        .WORD   056700          ;Ew@
        .WORD   014001          ;A A
        .WORD   000014          ;  L
        .WORD   003021          ; XQ
        .WORD   026762          ;Bwr
        .WORD   035722          ;CoR
        .WORD   035220          ;CjP
        .WORD   035322          ;CkR
        .WORD   035654          ;Cnl
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
T11STA: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027010          ;BxH
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000006          ;  F
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035723          ;CoS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027010          ;BxH
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000006          ;  F
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035723          ;CoS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027010          ;BxH
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000006          ;  F
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035723          ;CoS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027010          ;BxH
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000006          ;  F
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035723          ;CoS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031705          ;COE
T11STB: 1$,6$,11$,16$
1$:     2$,3$,4$,5$
2$:     .WORD   024004          ;B D
        .WORD   017404          ;A D
        .WORD   024032          ;B Z
        .WORD   076700          ;Gw@
        .WORD   035007          ;ChG
        .WORD   047024          ;DxT
        .WORD   040021          ;D@Q
        .WORD   026742          ;Bwb
        .WORD   135722          ;KoR
        .WORD   135630          ;KnX
        .WORD   135136          ;Ki^
        .WORD   137674          ;K> 
        .WORD   127375          ;J =
        .WORD   137377          ;K ?
        .WORD   133315          ;K[M
3$:     .WORD   024004          ;B D
        .WORD   017204          ;AzD
        .WORD   024032          ;B Z
        .WORD   076700          ;Gw@
        .WORD   035007          ;ChG
        .WORD   047024          ;DxT
        .WORD   040021          ;D@Q
        .WORD   126742          ;Jwb
        .WORD   075722          ;GoR
        .WORD   135630          ;KnX
        .WORD   137136          ;Ky^
        .WORD   177674          ;O> 
        .WORD   127375          ;J =
        .WORD   177377          ;O ?
        .WORD   133315          ;K[M
4$:     .WORD   024004          ;B D
        .WORD   017104          ;AyD
        .WORD   024032          ;B Z
        .WORD   076700          ;Gw@
        .WORD   075007          ;GhG
        .WORD   047024          ;DxT
        .WORD   040021          ;D@Q
        .WORD   166742          ;Nwb
        .WORD   135722          ;KoR
        .WORD   037630          ;C>X
        .WORD   175136          ;Oi^
        .WORD   137674          ;K> 
        .WORD   167375          ;N =
        .WORD   137377          ;K ?
        .WORD   133315          ;K[M
5$:     .WORD   024004          ;B D
        .WORD   017044          ;Axd
        .WORD   024032          ;B Z
        .WORD   076700          ;Gw@
        .WORD   075007          ;GhG
        .WORD   047024          ;DxT
        .WORD   040021          ;D@Q
        .WORD   166742          ;Nwb
        .WORD   175722          ;OoR
        .WORD   137630          ;K>X
        .WORD   077136          ;Gy^
        .WORD   177674          ;O> 
        .WORD   167375          ;N =
        .WORD   177377          ;O ?
        .WORD   133315          ;K[M
6$:     7$,8$,9$,10$
7$:     .WORD   024004          ;B D
        .WORD   017404          ;A D
        .WORD   025032          ;BhZ
        .WORD   076700          ;Gw@
        .WORD   034007          ;C G
        .WORD   047024          ;DxT
        .WORD   020021          ;B@Q
        .WORD   026742          ;Bwb
        .WORD   135726          ;KoV
        .WORD   135630          ;KnX
        .WORD   135136          ;Ki^
        .WORD   137674          ;K> 
        .WORD   127375          ;J =
        .WORD   137357          ;K o
        .WORD   133335          ;K[]
8$:     .WORD   024004          ;B D
        .WORD   017204          ;AzD
        .WORD   025032          ;BhZ
        .WORD   076700          ;Gw@
        .WORD   034007          ;C G
        .WORD   047024          ;DxT
        .WORD   020021          ;B@Q
        .WORD   126742          ;Jwb
        .WORD   075726          ;GoV
        .WORD   135630          ;KnX
        .WORD   137136          ;Ky^
        .WORD   177674          ;O> 
        .WORD   127375          ;J =
        .WORD   177357          ;O o
        .WORD   133335          ;K[]
9$:     .WORD   024004          ;B D
        .WORD   017104          ;AyD
        .WORD   025032          ;BhZ
        .WORD   076700          ;Gw@
        .WORD   074007          ;G G
        .WORD   047024          ;DxT
        .WORD   020021          ;B@Q
        .WORD   166742          ;Nwb
        .WORD   135726          ;KoV
        .WORD   037630          ;C>X
        .WORD   175136          ;Oi^
        .WORD   137674          ;K> 
        .WORD   167375          ;N =
        .WORD   137357          ;K o
        .WORD   133335          ;K[]
10$:    .WORD   024004          ;B D
        .WORD   017044          ;Axd
        .WORD   025032          ;BhZ
        .WORD   076700          ;Gw@
        .WORD   074007          ;G G
        .WORD   047024          ;DxT
        .WORD   020021          ;B@Q
        .WORD   166742          ;Nwb
        .WORD   175726          ;OoV
        .WORD   137630          ;K>X
        .WORD   077136          ;Gy^
        .WORD   177674          ;O> 
        .WORD   167375          ;N =
        .WORD   177357          ;O o
        .WORD   133335          ;K[]
11$:    12$,13$,14$,15$
12$:    .WORD   024004          ;B D
        .WORD   017404          ;A D
        .WORD   026032          ;BpZ
        .WORD   076700          ;Gw@
        .WORD   034007          ;C G
        .WORD   047024          ;DxT
        .WORD   010021          ;A@Q
        .WORD   026752          ;Bwj
        .WORD   135722          ;KoR
        .WORD   135634          ;Kn\
        .WORD   135136          ;Ki^
        .WORD   137674          ;K> 
        .WORD   127375          ;J =
        .WORD   137357          ;K o
        .WORD   133315          ;K[M
13$:    .WORD   024004          ;B D
        .WORD   017204          ;AzD
        .WORD   026032          ;BpZ
        .WORD   076700          ;Gw@
        .WORD   034007          ;C G
        .WORD   047024          ;DxT
        .WORD   010021          ;A@Q
        .WORD   126752          ;Jwj
        .WORD   075722          ;GoR
        .WORD   135634          ;Kn\
        .WORD   137136          ;Ky^
        .WORD   177674          ;O> 
        .WORD   127375          ;J =
        .WORD   177357          ;O o
        .WORD   133315          ;K[M
14$:    .WORD   024004          ;B D
        .WORD   017104          ;AyD
        .WORD   026032          ;BpZ
        .WORD   076700          ;Gw@
        .WORD   074007          ;G G
        .WORD   047024          ;DxT
        .WORD   010021          ;A@Q
        .WORD   166752          ;Nwj
        .WORD   135722          ;KoR
        .WORD   037634          ;C>\
        .WORD   175136          ;Oi^
        .WORD   137674          ;K> 
        .WORD   167375          ;N =
        .WORD   137357          ;K o
        .WORD   133315          ;K[M
15$:    .WORD   024004          ;B D
        .WORD   017044          ;Axd
        .WORD   026032          ;BpZ
        .WORD   076700          ;Gw@
        .WORD   074007          ;G G
        .WORD   047024          ;DxT
        .WORD   010021          ;A@Q
        .WORD   166752          ;Nwj
        .WORD   175722          ;OoR
        .WORD   137634          ;K>\
        .WORD   077136          ;Gy^
        .WORD   177674          ;O> 
        .WORD   167375          ;N =
        .WORD   177357          ;O o
        .WORD   133315          ;K[M
16$:    17$,18$,19$,20$
17$:    .WORD   024004          ;B D
        .WORD   017404          ;A D
        .WORD   027032          ;BxZ
        .WORD   076700          ;Gw@
        .WORD   035007          ;ChG
        .WORD   047024          ;DxT
        .WORD   004021          ;  Q
        .WORD   026742          ;Bwb
        .WORD   135736          ;Ko^
        .WORD   135634          ;Kn\
        .WORD   135136          ;Ki^
        .WORD   137674          ;K> 
        .WORD   127375          ;J =
        .WORD   137357          ;K o
        .WORD   133315          ;K[M
18$:    .WORD   024004          ;B D
        .WORD   017204          ;AzD
        .WORD   027032          ;BxZ
        .WORD   076700          ;Gw@
        .WORD   035007          ;ChG
        .WORD   047024          ;DxT
        .WORD   004021          ;  Q
        .WORD   126742          ;Jwb
        .WORD   075736          ;Go^
        .WORD   135634          ;Kn\
        .WORD   137136          ;Ky^
        .WORD   177674          ;O> 
        .WORD   127375          ;J =
        .WORD   177357          ;O o
        .WORD   133315          ;K[M
19$:    .WORD   024004          ;B D
        .WORD   017104          ;AyD
        .WORD   027032          ;BxZ
        .WORD   076700          ;Gw@
        .WORD   075007          ;GhG
        .WORD   047024          ;DxT
        .WORD   004021          ;  Q
        .WORD   166742          ;Nwb
        .WORD   135736          ;Ko^
        .WORD   037634          ;C>\
        .WORD   175136          ;Oi^
        .WORD   137674          ;K> 
        .WORD   167375          ;N =
        .WORD   137357          ;K o
        .WORD   133315          ;K[M
20$:    .WORD   024004          ;B D
        .WORD   017044          ;Axd
        .WORD   027032          ;BxZ
        .WORD   076700          ;Gw@
        .WORD   075007          ;GhG
        .WORD   047024          ;DxT
        .WORD   004021          ;  Q
        .WORD   166742          ;Nwb
        .WORD   175736          ;Oo^
        .WORD   137634          ;K>\
        .WORD   077136          ;Gy^
        .WORD   177674          ;O> 
        .WORD   167375          ;N =
        .WORD   177357          ;O o
        .WORD   133315          ;K[M
T11STC: 1$,2$,3$,4$
1$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027014          ;BxL
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   015365          ;Aku
        .WORD   031705          ;COE
2$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027014          ;BxL
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   015365          ;Aku
        .WORD   031705          ;COE
3$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027014          ;BxL
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   015365          ;Aku
        .WORD   031705          ;COE
4$:     .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   027014          ;BxL
        .WORD   056700          ;Ew@
        .WORD   015001          ;AhA
        .WORD   000016          ;  N
        .WORD   003021          ; XQ
        .WORD   027742          ;B?b
        .WORD   035722          ;CoR
        .WORD   034420          ;CdP
        .WORD   035323          ;CkS
        .WORD   035755          ;Com
        .WORD   025355          ;Bkm
        .WORD   015365          ;Aku
        .WORD   031705          ;COE
T13TB1: .WORD   024004          ;B D
        .WORD   016027          ;ApW
        .WORD   027016          ;BxN
        .WORD   176700          ;Ow@
        .WORD   035001          ;ChA
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   126662          ;Jvr
        .WORD   035722          ;CoR
        .WORD   134620          ;KfP
        .WORD   137721          ;K?Q
        .WORD   177175          ;Oy=
        .WORD   105755          ;Hom
        .WORD   177765          ;O?u
        .WORD   133705          ;K_E
T13TB2: .WORD   024004          ;B D
        .WORD   017207          ;AzG
        .WORD   037036          ;Cx^
        .WORD   076700          ;Gw@
        .WORD   034007          ;C G
        .WORD   067020          ;FxP
        .WORD   004021          ;  Q
        .WORD   126762          ;Jwr
        .WORD   075736          ;Go^
        .WORD   134635          ;Kf]
        .WORD   137377          ;K ?
        .WORD   177775          ;O?=
        .WORD   127355          ;J m
        .WORD   177157          ;Oyo
        .WORD   133715          ;K_M
T13TB3: .WORD   012004          ;APD
        .WORD   017223          ;AzS
        .WORD   007036          ; x^
        .WORD   177730          ;O?X
        .WORD   034005          ;C E
        .WORD   046764          ;Dwt
        .WORD   004025          ;  U
        .WORD   126362          ;Jsr
        .WORD   175736          ;Oo^
        .WORD   134624          ;KfT
        .WORD   137335          ;K ]
        .WORD   177175          ;Oy=
        .WORD   127755          ;J?m
        .WORD   177755          ;O?m
        .WORD   133615          ;K^M
T13TB4: .WORD   024004          ;B D
        .WORD   017025          ;AxU
        .WORD   027034          ;Bx\
        .WORD   076700          ;Gw@
        .WORD   034005          ;C E
        .WORD   046024          ;DpT
        .WORD   004021          ;  Q
        .WORD   126762          ;Jwr
        .WORD   135736          ;Ko^
        .WORD   135224          ;KjT
        .WORD   137336          ;K ^
        .WORD   177274          ;Oz 
        .WORD   127755          ;J?m
        .WORD   137355          ;K m
        .WORD   133315          ;K[M
T14TB1: .WORD   024004          ;B D
        .WORD   016027          ;ApW
        .WORD   037014          ;CxL
        .WORD   076700          ;Gw@
        .WORD   075001          ;GhA
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   126662          ;Jvr
        .WORD   135722          ;KoR
        .WORD   036620          ;CvP
        .WORD   175723          ;OoS
        .WORD   137175          ;Ky=
        .WORD   147755          ;L?m
        .WORD   135365          ;Kku
        .WORD   133705          ;K_E
T14TB2: .WORD   024004          ;B D
        .WORD   017024          ;AxT
        .WORD   037034          ;Cx\
        .WORD   076700          ;Gw@
        .WORD   074005          ;G E
        .WORD   046024          ;DpT
        .WORD   004021          ;  Q
        .WORD   126762          ;Jwr
        .WORD   135736          ;Ko^
        .WORD   137324          ;K T
        .WORD   175336          ;Ok^
        .WORD   137674          ;K> 
        .WORD   127355          ;J m
        .WORD   137155          ;Kym
        .WORD   133315          ;K[M
T14TB3: .WORD   024004          ;B D
        .WORD   016024          ;ApT
        .WORD   024014          ;B L
        .WORD   056700          ;Ew@
        .WORD   074001          ;G A
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   126762          ;Jwr
        .WORD   135722          ;KoR
        .WORD   036220          ;CrP
        .WORD   175323          ;OkS
        .WORD   137175          ;Ky=
        .WORD   167755          ;N?m
        .WORD   133165          ;KYu
        .WORD   133705          ;K_E
T14TB4: .WORD   014004          ;A D
        .WORD   016103          ;AqC
        .WORD   057034          ;Ex\
        .WORD   056700          ;Ew@
        .WORD   076001          ;GpA
        .WORD   144020          ;L P
        .WORD   175021          ;OhQ
        .WORD   166363          ;Nss
        .WORD   134723          ;KgS
        .WORD   136633          ;Kv[
        .WORD   175321          ;OkQ
        .WORD   117177          ;Iy?
        .WORD   167355          ;N m
        .WORD   137367          ;K w
        .WORD   133707          ;K_G
T14TB5: .WORD   014004          ;A D
        .WORD   043103          ;DYC
        .WORD   043034          ;DX\
        .WORD   056700          ;Ew@
        .WORD   072001          ;GPA
        .WORD   146020          ;LpP
        .WORD   175021          ;OhQ
        .WORD   166363          ;Nss
        .WORD   134737          ;Kg_
        .WORD   136637          ;Kv_
        .WORD   165325          ;NkU
        .WORD   117177          ;Iy?
        .WORD   167355          ;N m
        .WORD   137357          ;K o
        .WORD   133713          ;K_K
T14TB6: .WORD   014004          ;A D
        .WORD   006121          ; qQ
        .WORD   044030          ;D X
        .WORD   076720          ;GwP
        .WORD   076001          ;GpA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166362          ;Nsr
        .WORD   135736          ;Ko^
        .WORD   136634          ;Kv\
        .WORD   175326          ;OkV
        .WORD   137165          ;Kyu
        .WORD   163345          ;N[e
        .WORD   137347          ;K g
        .WORD   133715          ;K_M
T14TB7: .WORD   014004          ;A D
        .WORD   006124          ; qT
        .WORD   005030          ; hX
        .WORD   074720          ;GgP
        .WORD   066001          ;FpA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166760          ;Nwp
        .WORD   135722          ;KoR
        .WORD   136230          ;KrX
        .WORD   175326          ;OkV
        .WORD   137364          ;K t
        .WORD   163145          ;NYe
        .WORD   137367          ;K w
        .WORD   133715          ;K_M
T14TB8: .WORD   014004          ;A D
        .WORD   006124          ; qT
        .WORD   006034          ; p\
        .WORD   074720          ;GgP
        .WORD   066001          ;FpA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166760          ;Nwp
        .WORD   135726          ;KoV
        .WORD   136230          ;KrX
        .WORD   175326          ;OkV
        .WORD   137364          ;K t
        .WORD   163145          ;NYe
        .WORD   137347          ;K g
        .WORD   133735          ;K_]
T14TB9: .WORD   014004          ;A D
        .WORD   016124          ;AqT
        .WORD   004034          ;  \
        .WORD   076720          ;GwP
        .WORD   075001          ;GhA
        .WORD   044744          ;Dgd
        .WORD   003021          ; XQ
        .WORD   166770          ;Nwx
        .WORD   135722          ;KoR
        .WORD   136234          ;Kr\
        .WORD   175326          ;OkV
        .WORD   137364          ;K t
        .WORD   163145          ;NYe
        .WORD   137347          ;K g
        .WORD   133715          ;K_M
T15TB1: .WORD   024004          ;B D
        .WORD   016027          ;ApW
        .WORD   027014          ;BxL
        .WORD   076700          ;Gw@
        .WORD   075001          ;GhA
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   126722          ;JwR
        .WORD   135722          ;KoR
        .WORD   036620          ;CvP
        .WORD   175223          ;OjS
        .WORD   137165          ;Kyu
        .WORD   167745          ;N?e
        .WORD   135365          ;Kku
        .WORD   133705          ;K_E
T15TB2: .WORD   014004          ;A D
        .WORD   016023          ;ApS
        .WORD   055034          ;Eh\
        .WORD   076700          ;Gw@
        .WORD   075001          ;GhA
        .WORD   044020          ;D P
        .WORD   105021          ;HhQ
        .WORD   126322          ;JsR
        .WORD   134722          ;KgR
        .WORD   136633          ;Kv[
        .WORD   155321          ;MkQ
        .WORD   117167          ;Iyw
        .WORD   167345          ;N e
        .WORD   135365          ;Kku
        .WORD   133705          ;K_E
T15TB3: .WORD   014004          ;A D
        .WORD   042023          ;DPS
        .WORD   043034          ;DX\
        .WORD   076700          ;Gw@
        .WORD   073001          ;GXA
        .WORD   144020          ;L P
        .WORD   105021          ;HhQ
        .WORD   126322          ;JsR
        .WORD   134736          ;Kg^
        .WORD   037637          ;C>_
        .WORD   145325          ;LkU
        .WORD   117167          ;Iyw
        .WORD   167345          ;N e
        .WORD   135345          ;Kke
        .WORD   133311          ;K[I
T15TB4: .WORD   024004          ;B D
        .WORD   016027          ;ApW
        .WORD   077016          ;GxN
        .WORD   077700          ;G?@
        .WORD   075003          ;GhC
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   166622          ;NvR
        .WORD   135722          ;KoR
        .WORD   037620          ;C>P
        .WORD   165323          ;NkS
        .WORD   137065          ;Kxu
        .WORD   167745          ;N?e
        .WORD   135365          ;Kku
        .WORD   133305          ;K[E
T16TB1: .WORD   024004          ;B D
        .WORD   016027          ;ApW
        .WORD   037012          ;CxJ
        .WORD   077700          ;G?@
        .WORD   074003          ;G C
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   166662          ;Nvr
        .WORD   175722          ;OoR
        .WORD   137620          ;K>P
        .WORD   065323          ;FkS
        .WORD   135075          ;Kh=
        .WORD   167755          ;N?m
        .WORD   177365          ;O u
        .WORD   133305          ;K[E
T16TB2: .WORD   012004          ;APD
        .WORD   016063          ;Aps
        .WORD   007016          ; xN
        .WORD   177700          ;O?@
        .WORD   074003          ;G C
        .WORD   004004          ;  D
        .WORD   003025          ; XU
        .WORD   166362          ;Nsr
        .WORD   175732          ;OoZ
        .WORD   137620          ;K>P
        .WORD   065321          ;FkQ
        .WORD   135075          ;Kh=
        .WORD   167755          ;N?m
        .WORD   177745          ;O?e
        .WORD   133305          ;K[E
T17TB1: .WORD   024004          ;B D
        .WORD   016105          ;AqE
        .WORD   035012          ;ChJ
        .WORD   077700          ;G?@
        .WORD   074003          ;G C
        .WORD   004000          ;  @
        .WORD   003021          ; XQ
        .WORD   166663          ;Nvs
        .WORD   135723          ;KoS
        .WORD   176633          ;Ov[
        .WORD   035320          ;CkP
        .WORD   155177          ;Mi?
        .WORD   167755          ;N?m
        .WORD   177367          ;O w
        .WORD   133707          ;K_G
T17TB2: .WORD   014004          ;A D
        .WORD   042101          ;DQA
        .WORD   041030          ;DHX
        .WORD   076700          ;Gw@
        .WORD   073001          ;GXA
        .WORD   144020          ;L P
        .WORD   175021          ;OhQ
        .WORD   166363          ;Nss
        .WORD   134727          ;KgW
        .WORD   176633          ;Ov[
        .WORD   125324          ;JkT
        .WORD   155177          ;Mi?
        .WORD   167351          ;N i
        .WORD   177347          ;O g
        .WORD   133737          ;K__
T17TB3: .WORD   014004          ;A D
        .WORD   006101          ; qA
        .WORD   046030          ;DpX
        .WORD   076720          ;GwP
        .WORD   077001          ;GxA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166362          ;Nsr
        .WORD   135726          ;KoV
        .WORD   176630          ;OvX
        .WORD   135326          ;KkV
        .WORD   175165          ;Oiu
        .WORD   163345          ;N[e
        .WORD   177347          ;O g
        .WORD   133735          ;K_]
T17TB4: .WORD   014004          ;A D
        .WORD   046124          ;DqT
        .WORD   003030          ; XX
        .WORD   076720          ;GwP
        .WORD   073001          ;GXA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166770          ;Nwx
        .WORD   135722          ;KoR
        .WORD   174334          ;Oc\
        .WORD   137326          ;K V
        .WORD   175364          ;Okt
        .WORD   163145          ;NYe
        .WORD   137347          ;K g
        .WORD   173711          ;O_I
T17TB5: .WORD   014004          ;A D
        .WORD   046124          ;DqT
        .WORD   000030          ;  X
        .WORD   076720          ;GwP
        .WORD   073001          ;GXA
        .WORD   144764          ;Lgt
        .WORD   175021          ;OhQ
        .WORD   166760          ;Nwp
        .WORD   135736          ;Ko^
        .WORD   174334          ;Oc\
        .WORD   137326          ;K V
        .WORD   175360          ;Okp
        .WORD   163145          ;NYe
        .WORD   137347          ;K g
        .WORD   173715          ;O_M
T17TB6: .WORD   014000          ;A @
        .WORD   006124          ; qT
        .WORD   017030          ;AxX
        .WORD   076700          ;Gw@
        .WORD   074001          ;G A
        .WORD   144004          ;L D
        .WORD   177021          ;OxQ
        .WORD   166760          ;Nwp
        .WORD   135736          ;Ko^
        .WORD   075334          ;Gk\
        .WORD   137322          ;K R
        .WORD   175264          ;Ojt
        .WORD   167145          ;Nye
        .WORD   137347          ;K g
        .WORD   173315          ;O[M
T19TAB: .WORD   024004          ;B D
        .WORD   017024          ;AxT
        .WORD   037034          ;Cx\
        .WORD   076700          ;Gw@
        .WORD   074005          ;G E
        .WORD   046024          ;DpT
        .WORD   004021          ;  Q
        .WORD   126722          ;JwR
        .WORD   135736          ;Ko^
        .WORD   137334          ;K \
        .WORD   175336          ;Ok^
        .WORD   137674          ;K> 
        .WORD   127355          ;J m
        .WORD   137155          ;Kym
        .WORD   133315          ;K[M
T23TB1: .WORD   024004          ;B D
        .WORD   017024          ;AxT
        .WORD   035034          ;Ch\
        .WORD   076700          ;Gw@
        .WORD   075001          ;GhA
        .WORD   064020          ;F P
        .WORD   135021          ;KhQ
        .WORD   167723          ;N?S
        .WORD   175723          ;OoS
        .WORD   136623          ;KvS
        .WORD   075326          ;GkV
        .WORD   135775          ;Ko=
        .WORD   167355          ;N m
        .WORD   177365          ;O u
        .WORD   133715          ;K_M
T23TB2: .WORD   024004          ;B D
        .WORD   017024          ;AxT
        .WORD   034016          ;C N
        .WORD   176300          ;Os@
        .WORD   075001          ;GhA
        .WORD   004004          ;  D
        .WORD   003021          ; XQ
        .WORD   106762          ;Hwr
        .WORD   135722          ;KoR
        .WORD   136620          ;KvP
        .WORD   177320          ;O P
        .WORD   177174          ;Oy 
        .WORD   127755          ;J?m
        .WORD   137765          ;K?u
        .WORD   133705          ;K_E
T02EBX: .WORD   020232          ;BBZ
        .WORD   001430          ; LX
        .WORD   000046          ;  f
T04EBX: .WORD   020232          ;BBZ
        .WORD   001430          ; LX
        .WORD   000046          ;  f
T08EBX: .WORD   120032          ;J@Z
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T11EBX: .WORD   020232          ;BBZ
        .WORD   001430          ; LX
        .WORD   000046          ;  f
T20EBX: .WORD   020232          ;BBZ
        .WORD   001430          ; LX
        .WORD   000046          ;  f
T22EBX: .WORD   020232          ;BBZ
        .WORD   001430          ; LX
        .WORD   000046          ;  f
T13EBX: .WORD   022032          ;BPZ
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T14EBX: .WORD   120032          ;J@Z
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T15EBX: .WORD   120232          ;JBZ
        .WORD   001070          ; Hx
        .WORD   000044          ;  d
T16EBX: .WORD   120032          ;J@Z
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T17EBX: .WORD   120032          ;J@Z
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T19EBX: .WORD   020032          ;B@Z
        .WORD   001070          ; Hx
        .WORD   000046          ;  f
T23EBX: .WORD   022012          ;BPJ
        .WORD   001070          ; Hx
        .WORD   000046          ;  f

        .SBTTL  MBOX TEST SUBROUTINE LIBRARY  15-SEP-78
.REM    %
        TRAP HANDLER.  EMULATES AN R5 CALLING CONVENTION.
%
$TRAP:  MOV     R5,$SAVE        ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC
        MOVB    -2(R5),R5       ;GET TRAP #
        CMP     R5,#130         ;VALID TRAP?
        BLE     1$              ;YES
        CLR     R5              ;NO,UNDEFINED
1$:     ASL     R5              ;MULTIPLY BY 2
        MOV     $TRBAS(R5),$LINK        ;GET ENTRY POINT
        POP     R5              ;TRAP PC TO R5

        PUSH    #2$

        RTT                     ;RESTORE USER STATUS
2$:     PUSH    $SAVE           ;ORIGINAL R5 TO STACK

        JMP     @$LINK          ;CALL PROGRAM

$LINK:  .WORD   0               ;TRAP LINKAGE SCRATCH
$SAVE:  .WORD   0               ;R5 FOR CALLING CONVENTION

$UNDEF: PMSG    <UNDEF. TRAP AT PC >
     

        MOV     R5,R0
        DEC     R0              ;
        DEC     R0              ;
        PNTOCS                  ;PRINT TRAP LOCATION
        POP     R5              ;RESTORE R5

        FATAL


;SEQ312

$TRBAS: .WORD   $UNDEF  ;ILLEGAL TRAP
        .WORD   CMPS.   ;TRAP 1
        .WORD   CMPSR.  ;TRAP 2
        .WORD   $UNDEF  ;TRAP 3 RESERVED
        .WORD   SAV.3   ;TRAP 4
        .WORD   RST.3   ;TRAP 5
        .WORD   SAV.5   ;TRAP 6
        .WORD   RST.5   ;TRAP 7
        .WORD   RUNPRG  ;TRAP 10
        .WORD   CONTIN  ;TRAP 11
        .WORD   RUNBIG  ;TRAP 12
        .WORD   STEP    ;TRAP 13
        .WORD   FIND    ;TRAP 14
        .WORD   EVENT   ;TRAP 15
        .WORD   STEP10  ;TRAP 16
        .WORD   STPCON  ;TRAP 17
        .WORD   BRST    ;TRAP 20
        .WORD   $UNDEF  ;TRAP 21 RESERVED
        .WORD   MSK16R  ;TRAP 22 
        .WORD   $UNDEF  ;TRAP 23 RESERVED
        .WORD   MASK36  ;TRAP 24
        .WORD   $UNDEF  ;TRAP 25 RESERVED
        .WORD   MSKDF   ;TRAP 26
        .WORD   MSKDFR  ;TRAP 27
        .WORD   $UNDEF  ;TRAP 30 RESERVED
        .WORD   $UNDEF  ;TRAP 31 RESERVED
        .WORD   RANGE   ;TRAP 32
        .WORD   $UNDEF  ;TRAP 33 RESERVED
        .WORD   CMP22R  ;TRAP 34
        .WORD   CMP22   ;TRAP 35
        .WORD   $UNDEF  ;TRAP 36 RESERVED
        .WORD   LOAD    ;TRAP 37
        .WORD   $UNDEF  ;TRAP 40 RESERVED
        .WORD   $UNDEF  ;TRAP 41 RESERVED
        .WORD   $UNDEF  ;TRAP 42 RESERVED
        .WORD   $UNDEF  ;TRAP 43 RESERVED
        .WORD   READ17  ;TRAP 44
        .WORD   $UNDEF  ;TRAP 45 RESERVED
        .WORD   STEXCT  ;TRAP 46
        .WORD   XQT     ;TRAP 47
        .WORD   MEMRST  ;TRAP 50     
        .WORD   RSTMBX  ;TRAP 51
        .WORD   $UNDEF  ;TRAP 52 RESERVED
        .WORD   $UNDEF  ;TRAP 53 RESERVED
        .WORD   $UNDEF  ;TRAP 54 RESERVED
        .WORD   $UNDEF  ;TRAP 55 RESERVED
        .WORD   SBUSDG  ;TRAP 56
        .WORD   $UNDEF  ;TRAP 57 RESERVED
        .WORD   $UNDEF  ;TRAP 60 RESERVED
        .WORD   CRRSTD  ;TRAP 61
        .WORD   REFILL  ;TRAP 62
        .WORD   CRRONE  ;TRAP 63
        .WORD   INVAL   ;TRAP 64


;SEQ313

        .WORD   $UNDEF  ;TRAP 65 RESERVED
        .WORD   $UNDEF  ;TRAP 66 RESERVED
        .WORD   $UNDEF  ;TRAP 67 RESERVED
        .WORD   $UNDEF  ;TRAP 70 RESERVED
        .WORD   $UNDEF  ;TRAP 71 RESERVED
        .WORD   $UNDEF  ;TRAP 72 RESERVED
        .WORD   $UNDEF  ;TRAP 73 RESERVED
        .WORD   PNTUML  ;TRAP 74
        .WORD   CMP.E   ;TRAP 75
        .WORD   CMP.F   ;TRAP 76
        .WORD   ISORST  ;TRAP 77
        .WORD   SETPC   ;TRAP 100
        .WORD   RDRFIL  ;TRAP 101
        .WORD   LDWRIT  ;TRAP 102
        .WORD   CSHWRD  ;TRAP 103
        .WORD   DSTRBC  ;TRAP 104
        .WORD   CSHPAG  ;TRAP 105
        .WORD   RRFONW  ;TRAP 106
        .WORD   $UNDEF  ;TRAP 107 RESERVED
        .WORD   CMEMEN  ;TRAP 110
        .WORD   INMBAS ;TRAP 111
        .WORD   LDREF1  ;TRAP 112
        .WORD   $UNDEF  ;TRAP 113 RESERVED
        .WORD   $UNDEF  ;TRAP 114 RESERVED
        .WORD   BACKPL  ;TRAP 115
        .WORD   CMPSG.  ;TRAP 116
        .WORD   $UNDEF  ;TRAP 117 RESERVED
        .WORD   $UNDEF  ;TRAP 120 RESERVED
        .WORD   STEREQ  ;TRAP 121
        .WORD   $UNDEF  ;TRAP 122 RESERVED
        .WORD   FNDM16  ;TRAP 123
        .WORD   SAVMCN  ;TRAP 124
        .WORD   PNTID   ;TRAP 125
        .WORD   GETVER  ;TRAP 126
        .WORD   PNTVER  ;TRAP 127
        .WORD   $UNDEF  ;TRAP 130 RESERVED



;SEQ314

.SBTTL          MASTER RESET TEST SUBROUTINE    19-AUG-76
.REM    %
        
RSTCHK - ROUTINE TO PERFORM AN MBOX RESET & TEST THE RESULT.
RETURNS ONLY IF THE RESET IS PROPER.  RESTORES MR RESET TO THE
CONDITION DETERMINED BY THE RSTMBX FLAGS.  THE FOLLOWING SIGNALS
ARE MASKED FROM THE SNAPSHOT:

        -A CHANGE COMING
        -B CHANGE COMING
         CAM SEL 1, 2 (SIGNALS)
         CBUS PAR LEFT TE
         CBUS PAR RIGHT TE
         CSH CCA INVAL CSH
         CSH CCA VAL CORE
         CSH 0,1,2 & 3 ANY VAL (SIGNALS)
        -CSH 0,1,2, & 3 ANY WR SIGNALS
         CSH 0,1,2, & 3 DIR PAR ODD (SIGNALS)
         CSH LRU 1 & 2 (SIGNALS)
         CSH USE ADR 2,3 & 4 (SIGNALS)
         CSH USE IN 2,3 & 4 (SIGNALS)
         MB PAR BIT IN
        MEM ADR PAR
         PAG MB 00-17 PAR
         PAG MB 18-35 PAR
%
RSTCHK: PUSH    PMAFLG          ;SAVE STATE OF LOAD ERG FLAG

        INC     PMAFLG          ;SET LOAD ERG FROM PMA
        JSR     PC,SPCRST       ;DO SPECIAL RESET CONTROL
        POP     PMAFLG          ;RESTORE LOAD ERG FLAG

        CLR     SCFLAG          ;MBOX SNAPSHOT ONLY
        PUSH    MMASK           ;SAVE DEFAULT MASK POINTER

        SETMSK  RSTMSK      
        MOV     #RSTTAB,R0      ;POINT TO SCAN TABLE
        JSR     R5,SNAP         ;DO SNAPSHOT
        POP     MMASK           ;RESTORE DEFAULT MASK

        BCS     1$              ;ERROR - GO TO FAULT
        DFVMA                   ;READ VMA
        MOVB    2(R0),ERGRST+2  ;PUT BITS 14-26 IN EXPECTED
        BIC     #300,ERGRST+2   ;
        MOVB    1(R0),ERGRST+1  ;
        BIC     #BIT8,ERGRST    ;CLEAR BIT 27
        MSKDF   167,ERGRST,ERGMSK
        BCC     2$              ;O.K.


;SEQ315

1$:     ERRMSG  <  CALL PC = >

        MOV     R5,R0           ;GET USER PC
        SUB     #4,R0           ;
        ERROCT                  ;PUT IT ON ERROR STACK
        ERCRLF
        CLR     R5              ;CLEAR SUBTEST #
        FAULT   <MR ERROR>

2$:     TST     PMAFLG          ;ENABLE PMA?
        BNE     3$              ;YES
        JMP     RSTMBX          ;NO, RESET & RETURN
3$:     TST     CSHFLG          ;SET LOOK & LOAD?
        BEQ     4$              ;NO
        JMP     CSHSET          ;YES, DO IT & RETURN
4$:     RTS     R5              ;RETURN


;SEQ316

        ;TABLE OF VALUES FOR MBOX MASTER RESET (+ 1 TICK).

RSTTAB: .BYTE   0               ;UNUSED
        .BYTE   050             ;163 27-34
        .WORD   016024          ;160 20-35
        .BYTE   014             ;160 12-19
        .BYTE   050             ;164 27-34
        .WORD   076700          ;161 20-35
        .BYTE   021             ;161 12-19
        .BYTE   070             ;165 27-34
        .WORD   004004          ;162 20-35
        .BYTE   021             ;162 12-19
        .BYTE   6               ;166 27-34
        .WORD   026722          ;170 20-35
        .WORD   035722          ;171 20-35
        .WORD   035230  ;172 20-35
        .WORD   035322          ;173 20-35
        .WORD   035654          ;174 20-35
        .WORD   025355          ;175 20-35
        .WORD   035365          ;176 20-35
        .WORD   031305          ;177 20-35



        ;TABLE OF MASK BITS FOR MBOX MASTER RESET (+ 1 TICK)


RSTMSK: .BYTE   0                       ;UNUSED
        .BYTE   200             ;163 27-34
        .WORD   001000          ;160 20-35
        .BYTE   002             ;160 12-19
        .BYTE   0               ;164 27-34
        .WORD   0               ;161 20-35
        .BYTE   010             ;161 12-19
        .BYTE   302             ;165 27-34
        .WORD   002010          ;162 20-35
        .BYTE   010             ;162 12-19
        .BYTE   0               ;166 27-34
        .WORD   100000          ;170 20-35
        .WORD   100000          ;171 20-35
        .WORD   142000          ;172 20-35
        .WORD   142000          ;173 20-35
        .WORD   142020          ;174 20-35
        .WORD   142020          ;175 20-35
        .WORD   142010          ;176 20-35
        .WORD   142000          ;177 20-35

ERGRST: WD36    0,0,0           ;BUFFER FOR EXPECTED ERG DATA

ERGMSK: WD36    3770,0,0        ;MASK PAGE FAIL CODES





;SEQ317

.REM    %
ISORST - ROUTINE TO TRANSFER CONTROL TO HE MBOX MASTER RESET
ISOLATION ROUTINE.
%
ISORST: MOV     TESTSP,SP               ;RESET THE STACK POINTER
1$:     PMSG    <P A4.A11>              ;SETUP FILENAME


        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG               ;LOAD PROGRAM
        BCC     2$              ;LOAD ERROR?
        PMSG    <MOUNT A4.A11  HC WHEN READY\>


        PRGHLT                  ;LOOKUP OR LOAD ERROR
        BR      1$              ;TRY AGAIN
2$:     JMP     ISOPRM          ;GO TO DIACON FOR CALL

;SEQ318

.REM    %
        SUBROUTINE TO MAKE SURE THAT EXAM/DEPOSIT, EXECUTE, OR PROGRAM
RUN FINISHED UP CORRECTLY.  CHECKS C-BIT.  RETURNS IF CLEAR, ELSE DOES
ERROR WITH MESSAGE DEPENDING ON ENTRY POINT (CHKED, CHKX, OR CHKP).
        %
CHKED:  BCS     1$              ;BR IF ANY ERROR(S)
        RTS     PC              ;ELSE RETURN TO CALLER
1$:     MOV     #ERRED,R0       ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CCODE
CHKX:   BCS     1$              ;BR IF ERR BIT SET
        RTS     PC              ;ELSE RETURN
        
1$:     MOV     #ERRX,R0        ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKP:   BCS     1$              ;BR IF CARRY SET...ERR
        RTS     PC              ;ELSE RET
1$:     MOV     #ERRP,R0        ;POINT TO ERROR MESSAFE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKCOM:ERRCOM   PNTAL           ;PRINT ERROR MESSAGE
        ERRMSG  <\REAL ERROR PC: >

        POP     R0              ;GET REAL ERR PC

        SUB     #4,R0           ;ADJ
        ERRCOM  PNTOCT          ;PRINT IT
        TST     R5              ;CHK SUBTEST # FOR REASONABLE VAALUE
        BLE     1$              ; .LE. 0... NG
        CMP     R5,#3000
        BGT     1$              ;NG
        ERRMSG  <  SUBTEST: >

        MOV     R5,R0           ;SUBTEST # TO PARAM REG
        ERRCOM  PNTDEC          ;PRINT IT
1$:     ERROR

        ERRED:  .ASCIZ  %EXAMINE/DEPOSIT ERROR%
        ERRX:   .ASCIZ  %INSTRUCTION EXECUTE ERROR%
        ERRP:   .ASCIZ  %PROGRAM DIDN'T HALT%
        .EVEN



;SEQ319

.REM    %
ROUTINES TO GET AND COMPARE A PSEUDO-STATUS WORD REGISTER
TO AN EXPECTED VALUE.  BOTH ARE MASKED BEFORE A COMPARISN.
CMPS.  IS CALLED BY JSR R5,CMPS.
                 .WORD <EXPECTED DATA>
                .WORD <ADDRESS OF SPEC TABLE>
                .WORD   <MASK USED WITH BIC>

CMPSR.  IS THE SAME EXCEPT THAT IN PLACE OF EXPECTED DATA
IS A MOV R'N',R1 WHERE N IS A REGISTER 1-4 THAT POINTS
AT THE EXPECTED DATA (PRESUMABLY IN A TABLE).

UPON RETURN FROM EITHER ROUTINE, THE "C-BIT" IS A ONE IF A
MISTMATCH WAD DETECTED.  THE ACTUAL DATA IS RETURNED IN R0, MASKED 

ERRORS CAUSE AN ERROR STACK ENTRY OF TYPE 'FT9'. AS MANY
WORDS ARE PUT ON THE STACK AS THERE ARE BVITS IN ERROR.  THE
LAS ENTRY HAS A ZERO SIGN BIT.
  
CMPSG. ENTRY ONLY:
   
ON A DIAGNOSTIC GENERATION PASS (SCANWD=X2X000), THE EXPECTED
DATA WILL BE CORRECTED AND NO ERRORS FLAGGED.
%

CMPSG.: BIT     #NOTVAL,SCANWD  ;TABLE VALID?
        BEQ     CMPS.           ;YES, DO COMPARE
        MOV     R5,CPXDAD       ;SAVE EXPECTED DATA ADDRESS
        BR      CMPS.1          ;JOIN COMMON CODE

CMPS.:CLR       CPXDAD          ;NO DATA GENERATION!
CMPS.1: PUSH    R1

        MOV     (R5)+,R1        ;GET EXPECTED DATA
        BR      CMPSC.          ;DO COMMON OPERATION

CMPSR.: CLR     CPXDAD          ;NO DATA GENERATION
        PUSH    R1


        MOV     (R5)+,1$        ;GET DATA GETTER
1$:     MOV     R1,R1           ;**PROTO - REPLACED DURING EXECUTION


;SEQ320

CMPSC.: PUSH    <R2,R3,R4>



        JSR     PC,CMPSM.       ;SET UP BIT SELECT MASK
        MOV     (R5)+,R4                ;POINT AT TABLE
        CLR     TEM.            ;FIRST ERROR FLAG
1$:     MOVB    (R4),R0         ;GET NEXT CONTROL BYTE
        BMI     3$              ;GO DO DIAG READ
        BIT     R3,(R5)         ;ENABLED?
        BNE     4$              ;NO, GET NEXT BYTE
        MOV     R0,R2           ;COPY BIT PTR
        BIC     #174,R0         ;PRESERVE WORD BITS
        ASL     R0              ;MULT BY 2
        MOVB    R0,ERBIT+1
        ADD     .DAT3,R0        ;R3 NOW POINTS TO DEXWD
        CLC
        BIC     #177703,R2      ;SAVE BIT # FIELD
        ROR     R2              ;POSITION TO SELECT WORD
        MOVB    R2,ERBIT
        BIT     R3,R1           ;TEST EXPCTED
        BNE     5$              ;IT A ONE
        BIT     MTBL(R2),(R0)   ;TEST THE DIAG BIT
        BEQ     4$              ;WAS IT A ZERO?
        MOV     #200,R0
        BR      8$              ;ERROR IS H NOT L


;SEQ321

;REQUEST A READ OF THIS DIAGNOSTIC MUX
;
3$:     BIC     #177600,R0      ;CLEAN OUT SIGN BITS
        MOV     R0,DFSAVE
        DFRD
        TSTB    (R4)+           ;BUMP SPEC PTR
        BR      1$              ;AND RETURN TO COMMON CODE
4$:     CLC
        ROR     R3
        BITB    #100,(R4)+
        BEQ     1$              ;DO ANOTHER
        POP     <R4,R3,R2,R1>   ;DONE




        TST     (R5)+
        CLC                     ;CLEAR ERROR FLAG
        TST     TEM.
        BEQ     41$             ;IF NO ERROR
        SEC                     ;SET ERROR FLAG
41$:    RTS     R5
5$:     BIT     MTBL(R2),(R0)
        BNE     4$              ;H IS OK
        CLR     R0
8$:     TST     CPXDAD          ;GENERATE EXPECTED?
        BEQ     81$             ;BR IF NOT
        BIS     R3,@CPXDAD      ;SET EXPECTED DATA
        TST     R0      ;REALLY WANT TO SET?
        BNE     4$              ;YES, WE DID
        BIC     R3,@CPXDAD      ;NO, MAKE EXPECTED AERO
        BR      4$              ;CONTINUE TESTING
81$:    TST     TEM.            ;FIRST ERROR?
        BNE     10$             ;BR IF NOT
        MOV     ERSP..,R2
        MOV     #FT9,(R2)+
        COM     TEM.            ;SET FLAG
9$:     BISB    DFSAVE,R0
        MOVB    R0,(R2)+        ;ACTUAL AND DIAG FCN
        ASR     ERBIT
        MOVB    ERBIT+1,R0
        MOVB    ENDB.(R0),R0    ;GET END BIT
        CLRB    ERBIT+1
        SUB     ERBIT,R0                ;MINUS PDP11 BIT = PDP10
        MOVB    R0,(R2)+                ;BIT NBR TO STACK
        MOV     R2,ERSP..
        BR      4$              ;RETURN TO TEST
10$:    MOV     ERSP..,R2               ;
        BIS     #BIT15,-2(R2)   ;SET CONTINUEW ON PREV ENTRY
        BR      9$
ENDB.:  .BYTE   35.,19.,3
.EVEN
CPXDAD:0                ;DATA ADDRESS STORAGE



;SEQ322

CMPSM.: MOV     (R5),R4 ;POINT TO TABLE
        CLR     R3
        SEC
11$:    ROL     R3              ;PICK UP NEXT BIT
1$:     TSTB    (R4)
        BMI     2$              ;DIAG FCN
        BITB    #100,(R4)+      ;DONE?
        BEQ     11$             ;BR IF NOT
        RTS     PC
2$:     INC     R4              ;BYPASS
        BR      1$              ;NEXT BYTE

;SEQ251

.REM    %
        ROUTINE TO REPORT BIT ERROR FOR TBIT PDP-10 BIT TEST
        %
BITERR: BNE     1$              ;FIND OUT BIT FLAVOR
        CLR     R0              ;WAS A ZERO
        BR      2$      
1$:     MOV     #200,R0         ;WAS A ONE
2$:     PUSH    <R1,R3>


        MOV     ERSP..,R3               ;GET ERR STACK POINTER
        MOV     #FT9,(R3)+              ;STORE FORMAT TYPE
        BISB    DFSAVE,R0               ;GET DIAG PN
        MOVB    R0,(R3)+                ;STACK BYTE
        MOVB    ERBIT,(R3)+             ;STACK BIT NBR IN LEFT
        MOV     R3,ERSP..               ;SAVE POINTER
        POP     <R3,R1>


        RTS     R5              ;RETURN


.SBTTL          COMPARE ROUTINES
.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON
OF 5-BYTES OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,MSK36R
        R2 = POINTER TO MASK (0S IMPLY TEST)
        R3 = POINTER TO EXPECTED DATA
        R4 = POINTER TO ACTUAL DATA

%
MSK36R: PUSH    <R1,R5>


        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #5,R0           ;LOOP COUNT
1$:     MOVB    (R3)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R2),R1         ;MASK IT
        MOVB    (R4)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R2)+,R5        ;MASK IT
        CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGT     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     3$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R2           ;RESOTRE MASK POINTER
        MOV     R2,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R4           ;RESTORE ACTUAL POINTER
        MOVB    (R4)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        SUB     #5,R3           ;RESTORE POINTER TO EXPECTED
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
3$:     POP     <R5,R1>


        RTS     R5              ;RETURN

FFLAG:  .WORD                   ;FAULT FLAG


;SEQ253

.REM    %
        36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).
USES MSK36R.
CALL IS:
        JSR     R5,MASK36
        ENTRY+2 = POINTER T MASK (OS IMPLY TEST)
        ENTRY+4 = POINTER TO EXPECTED DATA
        ENTRY+6 = POINTER TO ACTUAL DATA
%
MASK36: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     (R5)+,R4        ;ACTUAL POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM THE TEST
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN



;SEQ326

.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.
        (TRAINING PARAMETERS) USES MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDF
        ENTRY+2 = DIAGNOSTIC FUNCTION
        ENTRY+4 = POINTER TO MASK (0S IMPLY TEST)
        ENTRY+6 = POINTER TO EXPECTED DATA
%
MSKDF:  PUSH    <R2,R3,R4>



        MOV     (R5)+,R0        ;GET DIAGNOSTIC FUNCTION
        PUSH    R0

        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     R0

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;DIAG FN TO ERROR STACK
1$:     POP     <R4,R3,R2>


        RTS     R5              ;RETURN


.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.  USES
MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDFR
        R0      = DIAGNOSTIC FUNCTION
        R2      = POINTER TO MASK (OS IMPLY TEST)
        R3      = POINTER TO EXPECTED
%
MSKDFR: PUSH    <R4,R0>


        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     .DAT3,R4                ;DTE20 DATA POINTER
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     <R0,R4>

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;PUT DIAG FN ON ERROR STACK
1$:     RTS     R5              ;RETURN



;SEQ327

.REM    %
        16-BIT DATA COMPARE ROUTINE.  SETS THE C-BIT & LOADS
        THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASKED
        DIFFERENCE (ACTUAL -EXPECTED) IN R0.
        CALL IS:
        JSR     R5,MASK16
        CALL+2  = MASK (0S IMPLY TEST)
        CALL+4  = POINTER TO ACTUAL
        CALL+6  = POINTER TO EXPECTED
%
MASK16: PUSH    R1

        PUSH    (R5)+           ;MASK

        MOV     @(R5)+,R0       ;ACTUAL
        MOV     @(R5)+,R1       ;EXPECTED
        BIC     (SP),R0         ;MASK ACTUAL
        BIC     (SP)+,R1        ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        SUB     #6,R5           ;RESTORE ENTRY POINT
        MOV     (R5)+,(R1)+     ;MASK TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;EXPECTED TO ERROR STACK
        BR      MSK16F          ;CLEANUP & RETURN



;SEQ328

.REM    %
        16-BIT REGISTER DATA COMPARE ROUTINE.  SETS THE C-BIT &
        LOADS THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASK-
        ED DIFFERENCE (ACTUAL - EXPECTED) IN R0.
        CALL IS;
        JSR     R5,MSK16R
        R2 = MASK (0S IMPLY TEST)
        R3 = ACTUAL DATA
        R4 = EXPECTED DATA
%
MSK16R: PUSH    R1


        MOV     R3,R0           ;
        BIC     R2,R0           ;MASK ACTUAL
        MOV     R4,R1           ;
        BIC     R2,R1           ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        MOV     R2,(R1)+        ;MASK TO ERROR STACK
        MOV     R3,(R1)+        ;ACTUAL TO ERROR STACK
        MOV     R4,(R1)+        ;EXPECTED TO ERROR STACK
MSK16F: MOV     R1,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
MSK16E: POP     R1

        RTS     R5              ;RETURN


;SEQ329

.REM    %
        22-BIT ADDRESS VALUE COMPARE ROUTINE.
        (TRAILING PARAMETERS) USES CMP22R.
CALL IS:
        JSR     R5,CMP22
        ENTRY+2 = POINTER TO 3-BYTE ACTUAL
        ENTRY+4 = POINTER TO 3-BYTE EXPECTED
%
CMP22:  PUSH    <R2,R3>


        MOV     (R5)+,R2        ;GET ACTUAL POINTER
        MOV     (R5)+,R3        ;GET EXPECTED POINTER
        JSR     R5,CMP22R       ;DO COMPARE
        POP     <R3,R2>


        RTS     R5              ;RETURN


;SEQ330

.REM    %
        22-BIT ADDRESS VALUE COMPARE ROUTINE. COMPARES 22-BITS OF
ACTUAL DATA TO 3-BYTES OF EXPECTED DATA.  SETS THE C-BIT & LOADS THE
ERROR STACK IF MISCOMPARE.  INCREMENTS R2 & R3 BY 3.
CALL IS:
        JSR     R5,CMP22R
        R2=     POINTER TO ACTUAL DATA
        R3=     POINTER TO EXPECTED DATA
%
CMP22R: PUSH    R1

        MOV     #2,R0           ;LOOP COUNT-1
        CLRB    FFLAG           ;CLEAR ERROR FLAG
1$:     MOVB    (R2)+,R1        ;GET A BYTE OF ACTUAL
        TST     R0              ;LAST BYTE?
        BNE     2$              ;NO
        BIC     #177700,R1      ;YES, MASK UPPER BITS
2$:     CMPB    R1,(R3)+        ;COMPARE A BYTE
        BEQ     3$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF BAD
3$:     DEC     R0              ;DONE?
        BGE     1$              ;NO, LOOP AGAIN
        POP     R1

        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     4$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22,(R0)+     ;FORMAT TO ERROR STACK
        SUB     #3,R2           ;RESTORE ACTUAL POINTER 
        MOVB    (R2)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R2)+,(R0)+     ;
        MOVB    (R2)+,(R0)+     ;
        CLRB    (R0)+           ;CLEAR EXTRA BYTE
        SUB     #3,R3           ;RESTORE EXPECTED POINTER
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+     ;
        MOVB    (R3)+,(R0)+     ;
        CLRB    (R0)+           ;CLEAR EXTRA BYTE
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET ERROR FLAG
4$:     RTS     R5              ;RETURN


;SEQ331

.REM    %
SDFRD - ROUTINE TO SAVE DIAGNOSTIC FUNCTION & PERFORM A DIAG-
NOSTIC READ.
%
SDFRD:  MOV     (R5)+,R0        ;GET DIAG FN
SDFRDA: MOV     R0,DFSAVE       ;SAVE DIAG FN
        DFRD
        RTS     R5              ;RETURN
        ;PUTS DIAGNOSTIC FUNCTION IN RO ON ERROR STACK

FRERR:  PUSH    R5

        MOV     ERSP..,R5       ;GET ERROR STACK POINTER
        MOV     #FT0,(R5)+      ;FORMAT TO ERROR STACK
        MOV     R0,(R5)+        ;DIAG FN TO ERROR STACK
        MOV     R5,ERSP..       ;UPDATE ERROR STACK POINTER
        POP     R5


        RTS     R5              ;RETURN


;SEQ332

.SBTTL          36-BIT ERROR PARSER  06-AUG-75
.REM    %
RANGE - ROUTINE TO TEST THE ERROR STACK TO DETERMINE THE BIT RANGE
OF 36-BIT DATA PATH ERRORS.  THE CALL IS JSR R5,RANGE.  REGISTER
R3 MUST POINT TO THE FTM36 FORMAT ENTRY ON THE ERROR STACK.
RETURNS AN INDEX OF BIT POSITION, RANGES IN R0.  INDEXES ARE AS
FOLLOWS:
        0:      BITS 30-35
        2:      BITS 27-29
        4:      BITS 24-26
        6:      BITS 18-23
        10:     BITS 12-17
        12:     BITS 09-11
        14:     BITS 06-08
        16:     BITS 00-05
        20:     BOTH HALVES
        22:     LOWER HALF
        24:     UPPER HALF
%
RANGE:  REGSAV                  ;SAVE REGISTERS
        CMP     (R3)+,#FTM36    ;FORMAT CORRECT?
        BNE     2$              ;NO, FATAL ERROR
        CLR     R4              ;CLEAR INDEX
1$:     JSR     PC,RANCOM       ;COMPARE A BIT RANGE
        BNE     3$              ;MISMATCH FOUND
        INC     R4              ;NEXT BIT RANGE
        INC     R4              
        CMP     R4,#20          ;ALL DONE?
        BLT     1$              ;NO, ERROR STACK O.K.
2$:     FATAL                   ;ERROR STACK ERROR
3$:     TST     R4              ;BITS 30-35?
        BEQ     4$              ;YES, TEST LOWER HALF
        CMP     R4,#10          ;BITS 12-17?
        BNE     5$              ;NO,SET INDEX & RETURN
        MOV     R4,TEM.         ;SAVE INDEX
        MOV     #16,R4          ;UPPER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 0-5
        BEQ     6$              ;NOT UPPER HALF
        MOV     #24,TEM.        ;SET INDEX = UPPER HALF
        BR      6$              ;CLEANUP & RETURN
4$:     MOV     R4,TEM.         ;SAVE INDEX
        MOV     #6,R4           ;LOWER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 18-23
        BEQ     6$              ;NOT LOWER HALF
        MOV     #22,TEM.        ;SET INDEX = LOWER HALF
        MOV     #10,R4          ;BOTH HALVES TEST
        JSR     PC,RANCOM       ;CHK BITS 12-17
        BEQ     6$              ;LOWER HALF
        MOV     #20,TEM.        ;SET INDEX = BOTH HALVES
        BR      6$              ;CLEANUP & RETURN
5$:     MOV     R4,TEM.         ;GET INDEX
6$:     REGRST                  ;RESTORE REGISTERS
        MOV     TEM.,R0         ;GET INDEX
        RTS     R5              ;RETURN


;SEQ333

        ;SUBROUTINE TO COMPARE ACTUAL & EXPECTED FOR THE RANGE
        ;SPECIFIED FOR THE INDEX VALUE IN R4.

RANCOM: PUSH    R4

        MOV     BRCNT(R4),SPCNT ;GET SHIFT COUNT
        MOV     R3,R4           ;GET ERROR STACK POINTER
        INC     R4              ;POINT TO ACTUAL
        INC     R4              
        JSR     PC,RANPOS       ;GET MASK & POSITION ACTUAL
        PUSH    R0              ;SAVE SHIFTED ACTUAL

        JSR     PC,RANPOS       ;GET, MASK & POSITION EXPECTED
        POP     <R1,R4>         ;RESTORE ACTUAL & INDEX


        MOV     BRMASK(R4),R2   ;GET MASK
        BIC     R2,R0           ;MASK EXPECTED
        BIC     R2,R1           ;MASK ACTUAL
        CMP     R0,R1           ;COMPARE THEM
        RTS     PC              ;RETURN

;TAKES THE DATA POINTED TO BY R4, MASKS IT & RETURNS THE
;BIT RANGE DESIRED RIGHT JUSTIFIED IN R0.
RANPOS: MOV     (R3),R5         ;GET MASK POINTER
        CLR     R0              ;BITS 20-35
        JSR     PC,RANP0        ;GET & MASK 28-35
        JSR     PC,RANP0        ;GET & MASK 20-27
        CLR     R1              ;BITS 4-19
        JSR     PC,RANP1        ;GET & MASK 12-19
        JSR     PC,RANP1        ;GET & MASK 4-11
        CLR     R2              ;BITS 0-3
        BISB    (R4)+,R2        ;SET 0-3
        BICB    (R5),R2         ;MASAK 0-3
        MOV     SPCNT,R5                ;GET SHIFT COUNT
1$:     DEC     R5              ;SHIFT DONE?
        BLT     2$              ;YES, RETURN
        ASR     R2              ;NO, SHIFT 3 WORDS RIGHT
        ROR     R1              ;
        ROR     R0
        BR      1$              ;LOOP AGAIN
2$:     RTS     PC              ;DATA IN R0, RETURN


RANP0:  BISB    (R4)+,R0        ;SET A BYTE
        BICB    (R5)+,R0        ;POSITION IT
        SWAB    R0              ;POSITION IT
        RTS     PC

RANP1:  BISB    (R4)+,R1        ;SET A BYTE
        BICB    (R5)+,R1        ;MASK A BYTE
        SWAB    R1              ;POSITION IT
        RTS     PC


;SEQ334

        ;TABLE OF SHIFT COUNT TO RIGHT JUSTIFY BITS LISTED

BRCNT:  .WORD   0       ;30-35
        .WORD   6.      ;27-29
        .WORD   9.      ;24-26
        .WORD   12.     ;18-23
        .WORD   18.     ;12-17
        .WORD   24.     ;09-11
        .WORD   27.     ;06-08
        .WORD   30.     ;00-05

        ;TABLE OF BIT CLEAR MASKS FOR EACH BIT RANGE

BRMASK: .WORD   177700  ;30-35
        .WORD   177770  ;27-29
        .WORD   177770  ;24-26
        .WORD   177700  ;18-23
        .WORD   177700  ;12-17
        .WORD   177770  ;09-11
        .WORD    177770     ;06-08
        .WORD   177700  ;00-05


  

             



;SEQ335

.SBTTL          SCANOUT ROUTINES  1-MAR-76
.REM    %
        SUBROUTINE TO SET AN MBOX SCANOUT MASK.  THE MASK POINTER
IS THE TRAILING PARAMETER.  IF NO CACHE EXISTS IN THE MACHINE, THE
USER MASK TABLE IS MODIFIED TO ENSURE THAT THE FOLLOWING UNTERMINATED
MBOX SIGNALS ARE MASKED:
        
        CSH SEL LRU
        CSH USE HOLD
        CSH USE WR EN
        CSH VAL SEL ALL
        CSH     VAL SEL WR DATA
        CSH WR SEL ALL
        CSH WR WD 0-3 EN (SIGNALS)
        CSH WR WR DATA
        FORCE NO MATCH
        FORCE VALID MATCH 0-3 (SIGNALS)
%

SETMSK: MOV     (R5)+,MMASK             ;SAVE MASK POINTER
        TSTB    CSHOPT          ;CACHE INSTALLED?
        BNE     2$              ;YES RETURN
        PUSH    R1      

        MOV     #CSHMSK,R0      ;POINT TO CACHE SIGNAL MASK
        MOV     MMASK,R1                ;POINT TO USER MASK
1$:     BIS     (R0)+,(R1)+     ;SET BITS IN USER MASK
        CMP     R0,#CSHMSK+28.  ;DONE?
        BLE     1$              ;NO, CONITNUE MODIFICATION
        POP     R1

2$:     RTS     R5              ;RETURN

CSHMSK: .BYTE   000             ;UNUSED
        .BYTE   074             ;163 27-34

        .WORD   000740          ;160 20-35
        .BYTE   000             ;160 12-19
        .BYTE   000             ;164 27-34
        .WORD   000040          ;161 20-35
        .BYTE   000             ;161 12-19
        .BYTE   000             ;165 27-34
        .WORD   000000          ;162 20-35
        .BYTE   000             ;162 12-19
        .BYTE   000             ;166 27-34
        .WORD   000010  ;170 20-35
        .WORD   000010          ;171 20-35
        .WORD   000410          ;172 20-25
        .WORD   000000          ;173 20-35
        .WORD   000000          ;174 20-35
        .WORD   010000  ;175 20-35
        .WORD   000020          ;176 20-35
        .WORD   000020          ;177 20-35

 

;SEQ336

.REM    %
        CONTROLLED CLOCK SCANOUT ROUTINE.  SUPPORTS BUILDING &
COMPARING DIAGNOSTIC FUNCTION SNAPSHOTS IN ORDER TO DETERMINE
THE FIRST POINT OF DEPARTURE FROM A PROPER SEQUENCE OF EVENTS.
THE TABLE WHICH IDENTIFIES THE PROPER STATE OF THE MBOX AT THE
        END OF A SPECIFIED BURST OF CLOCKS IS CORE RESIDENT.  THE STATE
OF THE MBOX FOR INTERMEDIATE CLOCK TICKS IS MATINTAINED ON .A11
FORMAT FILES.  THE MACHINE IS STOPPED AT ONE MBOX CLOCK BEFORE
THE POINT OF ERROR DETECTION IF A TICK FILE EXISTS.
%

        OVRLAY=70000
MSCAN:
SCOUT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TABPTR    ;SAVE TABLE POINTER
        MOV     (R5)+,SCNEND    ;SAVE SCAN END POINT
        MOV     SCANWD,R0       ;GET SCAN CONTROL WORD
        BEQ     SCANIT          ;NORMAL SCAN
        MOV     (SP),SCSUB      ;SAVE SUBTEST
        BIT     #UPDATE,R0      ;
        BEQ     1$              ;
        JMP     UPASS           ;UPDATE IN PROGRESS
1$:     BIT     #BUILD,R0       ;
        BEQ     2$              ;
        JMP     GPASS           ;GENERATION IN PROGRESS
2$:     BIT     #CALTIC,R0      ;
        BNE     NOSCAN          ;CALCULATE BURST COUNT
        MOV     SCNEND,R0       ;GET END POINT
        BPL     CALBST          ;BURST SPECIFIED
        JSR     R5,FIND2        ;FIND EVENT
        BR      ENDCHK          ;TEST FOR ERROR

        ;NO SCAN ACTIVE

NOSCAN: MOV     SCNEND,R0       ;GET BURST COUNT
CALBST: JSR     PC,SCNSTP       ;GET TO END POINT
ENDCHK: BCS     TICERR          ;ERROR
        RTS     R5              ;RETURN

TICERR: ERRMSG  <EVENT NOT FOUND\>

        SEC     
        RTS     R5              ;ERROR RETURN


;SEQ337

        ;NORMAL SCAN

SCANIT: TST     SCERR   ;PREVIOUS ERROR?
        BEQ     DOMAIN  ;NO, DO MAIN SCAN
        CMP     SCERR,TSTNUM    ;THIS TEST?
        BNE     DOMAIN          ;NO, DO MAIN SCN
        CMP     (SP),SCSUB      ;THIS SUBTEST?
        BNE     DOMAIN          ;NO, DO MAIN SCAN
        BIT     #BIT2,@TABPTR   ;TICK FILE VALID?
        BNE     SCISOL          ;YES, USE IT
        MOV     SCNEND,R0       ;NO, GET TICK COUNT
        BR      TICKIT          ;DO TICKS

        ;MAIN SCANNER

DOMAIN: MOV     SCNEND,R0               ;GET SCAN END POINT
        BEQ     1$              ;NO TICKS
        JSR     PC,SCNSTP       ;GET TO END POINT
        BCS     TICERR          ;ERROR
1$:     MOV     TABPTR,R0       ;GET TABLE POINTER
        JSR     R5,SNAP         ;DO SNAPSHOT
        BCC     2$              ;O.K.
        BR      STICK           ;ERROR, START ISOLATION
2$:     RTS     R5              ;RETURN


MMASK:  .WORD  0                ;POINTER TO MBOX SCAN MASK



        ;START ISOLATION

STICK:  MOV     TSTNUM, SCERR   ;SAVE TEST #
        MOV     (SP),SCSUB     ;SAVE SUBTEST #
RESCAN: POP     R5              ;RESTORE R5

        MOV     TSTNUM,R4       ;GET TEST #
        JMP     RETEST          ;RERUN CURRENT TEST



;SEQ338

        ;RERUN RETURN POINT

SCISOL: TST     TICFLG  ;RERUN TO DO TICKS -1?
        BNE     1$              ;YES
        INC    TICFLG   ;NO, SET FLAG FOR NEXT TIME
        JSR     R5,TSCAN        ;SCAN TICK FILE
        ERRMSG  <TICK COUNT = >

        MOV     SCBRST,R0               ;
        ERRDEC                  ;
        ERRMSG  <, STOPPED @ TICK-1\>

        BR      STICK           ;RERUN AGAIN
1$:     CLR     TICFLG          ;CLEAR TICK-1 FLAG

        ;TICK TO ERROR POINT MIN7US ONE MBOX CLOCK

        MOV     SCBRST,R0               ;GET ERROR TICK COUINT
        DEC     R0              ;DECREMTN CLOCK COUNT
        BLE     NOTICK                  ;ANY TICKS TO DO?
TICKIT: JSR     R5,BRST1                ;YES, DO THEM
NOTICK: CLR     SCERR           ;CLEAR ISOLATION FLAG
        SEC                     ;SET ERROR FLAG
        RTS     R5              ;RETURN



TABPTR: .WORD   0               ;TABLE POINTER
SCNEND: .WORD   0               ;SCAN END POINT
SCOSIZ: .WORD   15.             ;TABLE SIZE
SCERR:  .WORD   0               ;SCANOUT ERROR FLAG
SCSUB:  .WORD   0               ;SUBTEST
SCFLAG: .WORD   0               ;
TICPTR: .WORD   0               ;OVERLAY SCAN POINTER
        SCBRST: .WORD   0               ;BURST COUNT
TICFLG: .WORD   0               ;FLAG TO TICK #-1


;SEQ339


        ;SNAPSHOT ROUTINE


SNAP:   JSR     R5,SAV.5                ;SAVE R1-R5
        MOV     R0,R5           ;TABLE POINTER TO R5
        CLRB    FFLAG   ;CLEAR SCANOUT ERROR FLAG
        MOV     SCFLAG,R1       ;
        JMP     @1$(R1) ;DO SNAPSHOT
1$:     .WORD   MSNAP           ;CALL MBOX SNAPSHOT
        ;MOBX SNAPSHOT COMPARE ROUTINE - MASKS BOTH ACTUAL & EXPECTED

MSNAP:  MOV     #MSIZE,SCOSIZ   ;SET TABLE SIZE
        MOV     MMASK,R2                ;GET MASK POINTER
        MOV     #160,R3         ;FIRST DIAG FN
        MOV     .DAT3,R4        ;POINTER TO .DAT3
        TST     (R5)+           ;POINT TO TABLE+2
        TST     R2              ;MASK?
        BEQ     M6062           ;NO
        TST     (R2)+           ;YES, POINT TO MASK TABLE +2

        ;COMPARE FOR MBOX FUNCTIONS 160-162

M6062:  MOV     R3,R0           ;CURRENT DIAG FN
        DFRD                    ;READ IT
        MOV     (R4),R0         ;GET DEXWD3
        MOV     @.DAT2,R1       ;GET DEXWD2
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        BIC     (R2),(R5)               ;MASK EXPECTED
        BIC     (R2)+,R0        ;MASK ACTUAL
        BICB    (R2),2(R5)      ;MASK EXPECTED
        BIC     (R2)+,R1        ;MASK ACTUAL
1$:     CMP     R0,(R5)+        ;COMPARE TO EXPECTED
        BEQ     2$              ;FIRST WORD O.K.
        INC     R5              ;ERROR,UPDATE POINTER
        BR      3$              ;
2$:     CMPB    R1,(R5)+        ;COMPARE NEXT BYTE
        BEQ     4$              ;O.K.
3$:     JSR     PC,SNERR3               ;LOAD ERROR STACK
4$:     INC     R5              ;UPDATE EXPECTED POINTER
        INC     R3              ;NEXT FUNCTION
        CMP     R3,#163         ;163 NEXT?
        BLT     M6062           ;NO, LOOP AGAIN
        MOV     #16,R0          ;
        SUB     R0,R5           ;BACK UP TO TABLE BASE
        TST     R2              ;MASK?
        BEQ     M6366           ;NO
        SUB     R0,R2           ;YES, BACK UP MASK TOO


;SEQ340

        ;COMPARE FOR MBOX FUNCTIONS 163-166

M6366:  MOV     R3,R0           ;CURRENT FUNCTION
        DFRD                    ;READ IT
        MOV     (R4),R0         ;GET ACTUAL
        ASR     R0              ;POSITION IT
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        INC     R2              ;UPDATE MASK POINTER
        BICB    (R2)+,R0        ;MASK ACTUAL
        TST     (R2)+           ;UPDATE MASK POINTER
1$:     INC     R5              ;UPDATE EXPECTED POINTER
        BICB    -3(R2),(R5)     ;MASK EXPECTED
        CMPB    R0,(R5)+        ;COMPARE BITS 27-34
        BEQ     2$              ;O.K.
        JSR     PC,SNERR1               ;ERROR, PUT ON ERROR STACK
        
2$:     INC     R3              ;NEXT FUNCTION
        CMP     R3,#167         ;167 NEXT6?
        BGE     3$              ;YES
        TST     (R5)+           ;NO, UPDATE EXPECTED POINTER
        BR      M6366           ;LOOP AGAIN
3$:     INC     R3              ;SKIP FN 167
        TST     R2              ;MASK?
        BEQ     M7077           ;NO
        TST     -(R2)           ;YES, BACKUP MASK POINTER

        ;COMPARE FOR MBOX FUNCTIONS 170-177

M7077:  MOV     R3,R0           ;CURRENT FUNCTION
        DFRD                    ;READ IT
        MOV     (R4),R0 ;GET DEXWD3
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        BIC     (R2),R0         ;MASK ACTUAL
        BIC     (R2)+,(R5)      ;MASK EXPECTED
1$:     CMP     R0,(R5)+                ;COMPARE TO EXPECTED
        BEQ     2$              ;O.K.
        JSR     PC,SNERR        ;LOAD ERROR STACK
2$:     INC     R3              ;NEXT FUNCTION
        CMP     R3,#177 ;LAST ONE DONE?
        BLE     M7077           ;NO, LOOP AGAIN
3$:     TSTB    FFLAG           ;ERROR?
        BEQ     4$              ;NO, COMPARE O.K.
        SEC                     ;YES  SET ERROR FLAG
4$:     JSR     R5,RST.5                ;RESTORE R1-R5
        RTS     R5              ;RETURN


;SEQ341

        ;1-WD FORMAT ERROR STACK STUFFER

SNERR:  JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        MOV     -2(R5),(R4)+    ;EXPECTED TO ERROR STACK
        MOV     R0,(R4)+        ;ACTUAL TO ERROR STACK
        BR      EREND           ;FINISH UP

        ;COMMON SNAPSHOT ERROR STACK CODE

ERSTRT: MOV     ERSP..,R4       ;GET ERROR STACK POINTER
        TSTB    FFLAG           ;FIRST ERROR?
        BNE     1$              ;NO
        MOV     ERSI..,R4       ;YES, RESET ERROR STACK
        COMB    FFLAG           ;SET FLAG
        MOV     #FT8,(R4)+      ;FORMAT TO ERROR STACK
        BR      2$              ;
1$:     BIC     #BIT15,@ERSS..  ;CLEAR THE END BITR
2$:     MOV     R4,ERSS..       ;SAVE FORMAT POINTER
        MOVB    SCOSIZ,(R4)+    ;FORMAT I.D. TO ERROR STACK
        MOVB    R3,(R4)+        ;DIAG FN. TO ERROR STACK
        RTS     PC              ;

        ;1-BYTE TO 1 WORD CONVERTER & ERROR STACK STUFFER

SNERR1: JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        CLR     R1              ;
        BISB    -1(R5),R1       ;GET EXPECTED
        ASL     R1              ;POSITION IT
        MOV     R1,(R4)+        ;TO ERROR STACK
        BIC     #177400,R0      ;
        ASL     R0              ;POSITION ACTUAL
        MOV     R0,(R4)+        ;TO ERROR STACK
        BR      EREND           ;FINISH UP

        ;3-BYTE FORMAT ERROR STACK STUFFER

SNERR3: JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        MOVB    -3(R5),(R4)+    ;EXPECTED TO ERROR STACK
        MOVB    -2(R5),(R4)+    ;
        MOVB    -1(R5),(R4)+    ;
        MOVB    R0,(R4)+                ;ACTUAL TO ERROR STACK
        SWAB    R0              ;
        MOVB    R0,(R4)+        ;
        MOVB    R1,(R4)+        ;
        
EREND:  BIS     #BIT15,@ERSS..  ;SET THE END BIT
        MOV     R4,ERSP..       ;RESTORE ERROR STACK POINTER
        MOV     .DAT3,R4                ;DEXWD POINTER TO R4
        RTS     PC              ;RETURN

ERSS..: .WORD   0               ;POINTER TO FORMAT WORD


;SEQ342

        ;TICK FILE SCANNER

TSCAN:  CMPB    TSTNUM,CONSOL-2 ;FILE LOADED?
        BNE     TLOAD           ;NO
        CMPB    SCSUB,CONSOL-1  ;
        BEQ     RSCAN           ;YES

        ;LOADS TICK FILE

TLOAD:  PMSG    <LE >           ;REQUEST PROGRAM LOAD

        JSR     R5,TICKID       ;GER FILENAME
        MOV     #-1,R0          ;COMMAND IN OUTPUT BUFFER
        JSR     PC,LODPRG               ;LOAD TIC FILE
        BCC     1$              ;FILE LOADED
        PMSG    <MOUNT >        ;ERROR

        JSR     R5,TICKID       ;GET FILENAME
        PMSG    <,  HC WHEN READY\>

        PRGHLT                  ;WAIT FOR ERROR CORRECTION
        BR      TLOAD           ;TRY AGAIN
1$:     MOVB    TSTNUM,CONSOL-2 ;SET FILE LOADED
        MOVB    SCSUB,CONSOL-1
        
RSCAN:  CLR     SCBRST          ;CLEAR TICK COUNT
        MOV     #OVRLAY,TICPTR  ;INITIALIZE TABLE POINTER
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        INC     SCBRST          ;COUNT TICK
        CMP     SCBRST,SCNEND   ;DONE?
        BGE     2$              ;YES, RETURN
        MOV     TICPTR,R0       ;GET TABLE POINTER
        JSR     R5,SNAP         ;NO, PERFORM SNAPSHOT
        BCS     2$              ;ERROR RETURN
        MOV     SCFLAG,R0       ;GET SNAPSHOT ID
        MOV     MCSIZE(R0),R0   ;GET TABLE SIZE
        ASL     R0              ;MULTIPLY BY 2
        ADD     R0,TICPTR       ;UPDATE TABLE POINTER
        BR      1$              ;LOOP AGAIN
2$:     RTS     R5              ;RETURN

MCSIZE: .WORD   MSIZE           ;MBOX TABLE SIZE PARAMETER


;SEQ343

      ;GET TO PROPER POINT FOR SCAN

SCNSTP: TST     R0              ;FIND OR BURST?
        BEQ     2$              ;NOTHING TO DO
        BMI     1$              ;STEP IF NEGATIVE
        JSR     R5,BRST1        ;BURST
        BR      2$              ;
1$:     JSR     R5,FIND2                ;FIND EVENT
        BCS     2$      ;ERROR,TIMEOUT
        MOV     R0,-2(R5)       ;O.K. SVE BURST
        MOV     R0,SCNEND       ;
2$:     RTS     PC              ;

        ;PUTS PROGRAM ID IN OUTPUT BUFFER

TICKID: MOVB    TESTAB+1,R0     ;
        PNTCHR                  ;USER PREFIX
        MOV     TSTNUM,R0       ;
        PNTDEC                  ;TEST #
        PNTBAK          ;DISCARD PERIOD
        PNTCI,'H                ;PROCESSOR TYPE TO BUFFER
        MOV     SCSUB,R0        ;
        PNTDEC                  ;SUBTEST #
        PMSG    <TIC>           ;TIC EXTENSION

        RTS     R5              ;RETURN


        ;SCAN CONTROL WORD

SCANWD: .WORD   0               ;ZERO FOR NORMAL SCANOUTS
                        ;DEFAULT NOW SET TO GENERATE
                                ;NO SCAN TABLES

;DHMCA MISSING CODE - TAKEN FROM DHKBA-A :   LINES 12153 THRU 12458, THE EQUIV OF DHMCA LINES 13114 THRU 13417.

                ;13114
NOTVAL=BIT15    ;115
UPDATE=BIT14    ;116
BUILD=BIT13     ;117
INTICK=BIT12    ;118
                ;119
CALTIC=BIT11    ;120
                ;121
                ;122            NOTE: CMASK AND LINES OF ASSOCIATED CODE HAVE BEEN REMOVED FROM THIS VERSION.
                ;123
;SCANWD:.WORD 100000    ;ZERO FOR NORMAL SCANOUTS       ;124    NOTE: LINE BEGUN WITH SEMICOLON TO AVOID DOUBLE DEF.
                        ;DEFAULT NOW SET TO GENERATE    ;125
                        ;NO SCAN TABLES                 ;126
                ;127
                ;128
                ;129
                ;130
UPASS:  MOVB    R0,R0   ;131    NOTE: ASSUMING THE FIRST R0. THE 2ND IS VERIFIED.
        JMP     @UPASS1(R0)     ;132
                        ;133
UPASS1: .WORD   GMAIN   ;134
UPASS2: .WORD   VSCAN   ;135
UPASS3: .WORD   USCAN   ;136
UPASS4: .WORD   VUPDT   ;137
                        ;138
                        ;139
                        ;140
                        ;141
GPASS:  MOVB    R0,R0   ;142    NOTE: ASSUMING THE FIRST R0. THE 2ND IS VERIFIED.
        JMP     @GPASS1(R0)     ;143
                        ;144
GPASS1: .WORD   GMAIN   ;145
GPASS2: .WORD   SCANIT  ;146
GPASS3: .WORD   GTICK   ;147
GPASS4: .WORD   VTICK   ;148
                        ;149
                        ;150
                        ;151
                        ;152
SCPASS:MOV      @#SCANWD,R0     ;153
        BEQ     2$      ;154
        MOVB    R0,R1   ;155
        INC     R0      ;156
        INC     R0      ;157
        BIT     #UPDATE,R0      ;158
        BEQ     1$              ;159
        JMP     @PASSU(R1)      ;160
1$:     BIT     #BUILD,R0       ;161
        BEQ     2$              ;162
        JMP     @PASSG(R1)      ;163


2$:     RTS     PC              ;13164
                                ;165
                                ;166
                                ;167
PASSU:  .WORD   PASS1           ;168
        .WORD   NPASS           ;169
        .WORD   NPASS           ;170
        .WORD   SCDONE          ;171
                                ;172
                                ;173
                                ;174
PASSG:  .WORD   PASS1           ;175
        .WORD   PASS2           ;176
        .WORD   NPASS           ;177
        .WORD   SCDONE          ;178
                                ;179
                                ;180
PASS1:  BIS     #NOTVAL,R0      ;181
        BR      NPASS           ;182
PASS2:  BIC     #NOTVAL,R0      ;183
        BIT     #INTICK,R0      ;184
        BNE     NPASS           ;185
SCDONE: CLR     R0              ;186
NPASS:  MOV     R0,@#SCANWD     ;187
        RTS     PC              ;188
                                ;189
                                ;190
                                ;191
GMAIN:  BIC     #BIT2,@TABPTR    ;192
        MOV     @#SCNEND,R0     ;193
        JSR     PC,@#SCNSTP     ;194
        BCC     1$              ;195
        JMP     @#TICERR        ;196
1$:     BIT     #NOTVAL,@#SCANWD;197
        BEQ     2$              ;198
        MOV     @#TABPTR,R0     ;199
        JSR     R5,GENTAB       ;200
        BIT     #UPDATE,@#SCANWD;201
        BEQ     2$              ;202
        CMP     @#SCNEND,#1     ;203
        BLE     2$              ;204
        BIS     #BIT2,@TABPTR   ;205
2$:     RTS     R5              ;206


                        ;13207
                        ;208
                        ;209
GTICK:  MOV     @#SCNEND,R0     ;210
        BEQ     7$              ;211
        JSR     R5,SAV.3        ;212
        CMP     R0,#1           ;213
        BEQ     5$              ;214
        MOV     #OVRLAY,R5      ;215
        MOV     #1,R4           ;216
        MOV     @#SCFLAG,R0     ;217
        MOV     MCSIZE(R0),R3   ;218 NOTE: THESE 3 OPERANDS FOR SURE
        ASL     R3      ;219
1$:     JSR      R5, STEP1   ;220
        CMP     R5,#CONSOL-20   ;221
        BLT     2$              ;222
        PMSG    <TEST >         ;223
        MOV     @#TSTNUM,R0     ;224
        PNTDEC                  ;225
        PMSG    <, SUBTEST >    ;226
        MOV     @#SCSUB,R0      ;227
        PNTDEC          ;228
        PMSG    < FILE TOO BIG\>  ;229
        MOV     @#SCNEND,R0     ;230
        SUB     R4,R0   ;231
        JSR     R5,BRST1        ;232
        BR      6$      ;233
2$:     INC     R4      ;234
        MOV     R5,R0   ;235
        JSR     R5,GENTAB       ;236
        ADD     R3,R5   ;237
        CMP     R4,@#SCNEND     ;238
        BLT     1$              ;239
                        ;240
                        ;241
                        ;242
3$:     JSR     R5,GETVER       ;243
        PMSG    <CD >           ;244
        JSR     R5,TICKID       ;245
        PMSG    < 70000,>       ;246
        MOV     R5,R0   ;247
        DEC     R0              ;248
        DEC     R0              ;249
        PNTOCS          ;250


        JSR     R5,PNTVER       ;13251
        PCRLF                   ;252
        MOV     #-1,R0          ;253
        PRGCMD                  ;254
        BCC     4$              ;255
        PMSG    <HC TO RETRY\>  ;256
        PRGHLT                  ;257
        BR      3$              ;258
4$:     BIT     #UPDATE,@#SCANWD ;259
        BNE     5$              ;260
        BIS     #BIT2,@TABPTR   ;261
5$:     JSR     R5,STEP1        ;262
6$:     JSR     R5,RST.3        ;263
7$:     RTS     R5              ;264
                                ;265
                                ;266
                                ;267
VSCAN:  JSR     R5,VTICK        ;268
        BIT     #BIT2,@TABPTR   ;269
        BEQ     1$              ;270
        MOV     @#TABPTR,R0     ;271
        JSR     R5,SNAP         ;272
        BCS     VALERR          ;273
1$:     RTS     R5              ;274
                                ;275
                                ;276
                                ;277
VTICK:  BIT     #BIT2,@TABPTR     ;278
        BNE     1$              ;279
        JMP     @#NOSCAN        ;280    
1$:     JSR     R5,@#TSCAN      ;281
        BCS     VALERR          ;282
        RTS     R5              ;283
                                ;284
VALERR: PFORCE                  ;285
        PMSG    <EBOX CAN'T EXECUT>
        MOV     @#SCBRST,R0     ;287
        PNTDEC                  ;288
        PCRLF                   ;289
        PNORML                  ;290
        MOV     @#ERTI..,R0     ;291
        MOV     @#ERSI..,@#ERTI.. ;292
        MOV     R0,@#ERSI..     ;293


        MOV     @#ERSP..,@#ERTP.. ;13294
        MOV     R0,@#ERSP..       ;295
        JSR     R5,SAV.5        ;296
        MOV     @#BRKPC,R3        ;297
        MOV     @#TSTNUM,R4       ;298
        MOV     @#SCSUB,R5        ;299
        JSR     PC,@#REPORT     ;300
        PCRLF                   ;301
        JSR     R5,@#RST.5      ;302
        BIC     #BIT2,@TABPTR   ;303
        MOV     @#SCNEND,R0     ;304
        SUB     @#SCBRST,R0     ;305
        BLE     1$              ;306
        JSR     R5,BRST1        ;307
1$:     RTS     R5              ;308
                                ;309
                                ;310
USCAN:  BIT     #BIT2,@TABPTR   ;311
        BEQ     1$              ;312
        JMP     NOSCAN          ;313
1$:     JSR     R5,GTICK        ;314
        MOV     @#TABPTR,R0     ;315
        JSR     R5,GENTAB       ;316
        RTS     R5              ;317
                                ;318
                                ;319
VUPDT:  BIT     #BIT2,@TABPTR   ;320
        BNE     1$              ;321
        CMP     @#SCNEND,#01    ;322
        BGT     2$              ;323
1$:     JMP     SCANIT          ;324
2$:     BIS     #BIT2,@TABPTR   ;325
        JMP     VSCAN           ;326
                                ;327
                                ;328
                                ;329
GENTAB: JSR     R5,SAV.5        ;330
        MOV     R0,R5           ;331
        MOV     @#SCFLAG,R3    ;332
        JMP     @MBUILD-2(R3)   ;333
                                ;334

        
        .WORD   MBUILD          ;133335
                                ;336
                                ;337
                                ;338
                                ;339
                                ;340
                                ;341
                                ;342
                                ;343
                                ;344
                                ;345
                                ;346
                                ;347
                               ;348
                                ;349
                                ;350
                                ;351
                                ;352
                                ;353
                                ;354
                                ;355
                                ;356
                                ;357
                                ;358
                                ;359
                                ;360
                                ;361
                                ;362
                                ;363
                                ;364
                                ;365
                                ;366
                                ;367
                                ;368
                                ;369
                                ;370
                                ;371
MBUILD: MOV     #160,R3         ;372
        MOV     @#.DAT3,R4      ;373
        TST     (R5)+           ;374

1$:     MOV     R3,R0           ;13375
        DFRD                    ;376
        MOV     (R4),R0         ;377
        MOV     @.DAT2,R1       ;378
        MOV     R0,(R5)+        ;379
        MOVB    R1,(R5)+        ;380
        INC     R5              ;381
        INC     R3              ;382
        CMP     R3,#163         ;383
        BLT     1$              ;384
2$:     MOV     #16,R0          ;385
        SUB     R0,R5           ;386
3$:     MOV     R3,R0           ;387
        DFRD                    ;388
        MOV     (R4),R0         ;389
        ASR     R0              ;390
        INC     R5              ;391
        MOVB    R0,(R5)+        ;392
        INC     R3              ;393
        CMP     R3,#167         ;394
        BGE     4$              ;395
        TST     (R5)+           ;396
        BR      3$              ;397
4$:     INC     R3              ;398
5$:     MOV     R3,R0           ;399
        DFRD                    ;400
        MOV     (R4),R0         ;401
        MOV  R0,(R5)+           ;402
        INC     R3              ;403
        CMP     R3,#177         ;404
        BLE     5$              ;405
                                ;406
                                ;407
                                ;408
                                ;409
                                ;410
        JSR     R5,RST.5        ;411
        RTS     R5              ;412
                                ;413
                                ;414
                                ;415
                                ;416


;SEQ344

.SBTTL          EBOX INTERFACE SNAPSHOT ROUTINES
.REM    %
        ROUTINE TO START AN INSTRUCTION AND CHECK EBOX/MBOX INTERFACE
SIGNALS AT CLK EBOX REQ TIME.
        %

STEREQ: MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,1$        ;GET INSTRUCTION POINTER
        JSR     R5,STEXCT       ;LOAD INTO AR, IN SYNC
1$:     0                       ;INSTR PTR GOES HERE
        JSR     R5,FIND1        ;GET TO CLK EBOX REQ
        S10.    102,32,1        ;TRAILING PARAMETER
        BCC     ESNAP           ;PROCEED IF OK
        ERRMSG  <EBOX CAN'T EXECUTE INSTRUCTION?\>

        TST     (R5)+           ;PASS POINTER
        SEC     
        RTS     R5              ;ERROR RETURN ONLY
;
;BRANCHES INTO ESNAP TO CHECK THE EBOX SIGNALS
;
.REM    %
ESNAP - ROUTINE TO SNAPSHOT EBOX/MBOX INTERFACE SIGNALS
        %

ESNAP:  PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;GET EXPECTED DATA TABLE PTR.
        MOV     EMASK,R3        ;GET MASK TEABL PTRE
        MOV     #ESNAPT,R4      ;ADDRESS OF DRIVE TABLE PTRS
        CLR     ESNERR          ;CLEAR ERROR MEMORY
1$:     MOV     (R2),2$         ;PASS DATA
        MOV     (R3)+,4$        ;GET MASK WORD
        MOV     (R4)+,3$        ;DRIVE TABLE ADDRESS
        BEQ     6$              ;ZERO IS END
        JSR     R5,CMPSG.       ;CHECK A GROUP OF SIGNALS
2$:     0
3$:     0
4$:     0
        BCC     5$              ;IF NO ERROR
        INC     ESNERR          ;REMEMBER ERROR
        
5$:     MOV     2$,(R2)+        ;RESTORE DATA IF GENERATING
        BR      1$              ;DO NEXT GROUP
6$:     CLC                     ;RESET ERROR FLAG
        TST     ESNERR          ;WAS ERROR?
        BEQ     7$              ;BR IF NOT
        SEC             ;SET ERROR FLAG
7$:     POP     <R4,R3,R2>


;SEQ345

        RTS     R5

ESNERR: 0                       ;ERROR SAVER
EMASK:  .WORD   0               ;MASK TABLE

        
;DRIVE TABLE
ESNAPT: .WORD   1$,2$,3$,0      ;THREE-PART TABLE

1$:     DF.     102

        BP.     <18,20,32>      ;MCL VMA READ, MCL PAGE TEST PRIVATE


                                ;CLK EBOX REQ
        DF.     103

        BP.     <18,20>         ;MCL VMA PAUSE, MCL VMA UPT


        DF.     104


        BP.     <18,19,20,23,35>        ;MCL VMA WRITE, MCLA VMA USER




                                ;MCL PAGE UEBR REF, MCL EBOX CACHE
                                ;CLK MBOX CYCLE
        DF.     105

        BP.     <20,23,35>      ;MCL PAGE ADDRESS COND, MCL EBOX MAY BE PAGED



                                ;CLK MBOX RESP SIM

        DF.     106


        BP.     20              ;MCL PAGE ILL ENTRY


        DF.     107


        BP.     <23,-31>                ;MCL EBOX MAP, CLR PAGE FAIL



2$:     DF.     110


        BP.     <1,6,7,9,10,11> ;APR SWEEP NUSY EN



;SEQ346


                                ;APR SBUS ERR IN, APR NXM ERRIN
                                ;APR MB PAR ERR IN, APR C DIR P ERR IN
                                ;APR S ADR P ERR IN
        DF.     115


        BP.     <11,12,13,14,16,17>     ;APR WR BAD ADR PAR




                                ;APR EBOX CCA, APR EBOX ERA
                                ;APR EBOX SBUS DIAG, APR EBOX LOAD REG
                                ;APR EBOX READ REG
        DF.     116

        BP.     <8,11,12,-13>   ;APR PT DIR WR, APR ANY EBOX ERR FLG



                                ;APR EBOX UBR, APR EN REFILL RAM WR
3$:     DF.     117

        BP.     <7,8,12>        ;APR WR PT SEL 1, APR PT WR



                                ;APR EBOX EBR

        DF.     130

        BP.     20              ;CON WR EVEN PAR DIR

        DF.     131

        BP.     <18,19,-21>     ;CON CACHE LOOK EN, CON CACHE LOAD EN



                                ;CON KL10 PAGING MODE


        .EVEN

.SBTTL          ERROR STACK COMPARE ROUTINES  22-SEP-75
.REM    %
        ROUTINES TO TEST THE ERROR STACK FOR THE PRESENCE OF DIAGNOSTIC
FUNCTION BIT ENTRIES OF FORMAT TYPE FT8 OR FT9.  SETS A BIT
IN A UML TABLE FOR EACH DIAGNOSTIC FUNCTION BIT FOUND TO CORRESPOND
TO A SPECIFIED LIST.  THE CALL IS JSR R5,CMP.E TO TEST ALL LIST
ENTRIES AND CMP.F TO SCAN FOR THE FIRST ERROR.  THE TRAILING
PARAMETER IS A POINTER TO A BYTE TABLE OF DIAGNOSTIC FUNCTIONS
AND BIT NUMBERS TO BE TESTED.  THE END OF THE TABLE IS DESIGNATED
BY SETTING BIT 7 OF THE LAST BYTE.  R0 MUST POINT TO THE ERROR
STACK FORMAT ENTRY OF FORMAT TYPE FT8 OR FT9.  THE C-BIT IS SET
AND A POINTER TO THE UML TABLE IS RETURNED IN R0 IF ANY MATCH IS
FOUND:  OTHERWISE R0 IS UNCHANGED.
%
CMP.E:  MOVB    #-1,EFLAG       ;SET ALL ERRORS FLAG
        BR      CMP.G           ;
CMP.F:  CLRB    EFLAG           ;CLEAR ALL ERRORS FLAG
        
CMP.G:  MOV     R0,DIF.         ;SAVE ERROR STACK POINTER
        MOV     (R5)+,TEM.      ;GET SPEC TABLE POINTER
        REGSAV
        MOV     TEM.,R4         ;GET SPEC TABLE POINTER
        CLRB    ISOFLG          ;CLEAR UML MATCH FLAG
        CLR     ISOUML          ;CLEAR UML TABLE
        CLR     ISOUML+2        ;
        CLR     ISOUML+4        ;
        CLR     ISOUML+6        ;
1$:     MOVB    (R4)+,R0        ;GET SPEC TABLE ENTRY
        BIT     #100,R0         ;DIAG. FN. OR BIT?
        BEQ     2$              ;BIT
        MOVB    R0,DFD8         ;SAVE FUNCTION
        BR      1$              ;GET BIT
2$:     BIC     #177600,R0      ;CLEAR END BIT
        CLRB    FT8DUN         ;CLEAR ERROR STACK DONE FLAG
        MOV     DIF.,R5         ;GET ERROR STACK POINTER
        CLR     FT9FLG          ;
        CMP     (R5)+,#FT8      ;FORMAT TYPE 8?
        BEQ     3$              ;YES
        MOV     #2,FT9FLG       ;
        CMP     -2(R5),#FT9     ;FORMAT TYPE 9?
        BEQ     3$              ;YES
        FATAL                   ;IMPROPER FORMAT



;SEQ258

3$:     MOV     FT9FLG,R1       ;GET FORMAT FLAG
        JSR     PC,@TSTERS(R1)  ;COMPARE AN ERROR STACK ENTRY
        BNE     4$              ;NO MATCH FOUND
        MOVB    FT8DF,R0        ;GET DIAGNOSTIC FUNCTION
        MOVB    R0,ISOFLG       ;SET UML FLAG
        SR      R0,2            ;DIVIDE DIAG. FN. BY 8


        BIC     #177761,R0      ;
        MOV     R0,DFD8         ;SAVE FOR SBOARD
        JSR     R5,SBOARD       ;SET PROPER BIT IN UML TABLE
                ISOUML          ;
        TSTB    EFLAG           ;ALL ERRORS?
        BNE     5$              ;YES, CONTINUE SCAN
        BR      6$              ;NO, CLEANUP & RETURN
4$:     TSTB    FT8DUN          ;DONE WITH STACK?
        BEQ     3$              ;NO, NEXT STACK ENTRY
5$:     TSTB    -1(R4)          ;DONE WITH SPEC TABLE?
        BPL     1$              ;NO, TRY NEXT
6$:     REGRST
        TSTB    ISOFLG          ;ANY FOUND?
        BEQ     7$              ;NO
        MOV     #ISOUML,R0      ;POINT TO UML TABLE
        SEC                     ;YES, SET C-BIT
7$:     RTS     R5              ;RETURN


;SEQ259

        ;COMPARE A FORMAT TYPE 8 ENTRY

ERSFT8: JSR     PC,GNSCT        ;GET ENTRY FROM ERROR STACK
        CMPB    DFD8,FT8DF      ;THIS DIAGNOSTIC  FUNCTION?
        BNE     6$              ;NO, RETURN
1$:     BITB    R3,(R1)         ;TEST EXPECTED = ACTUAL
        BEQ     2$
        BITB    R3,(R2)         ;
        BEQ     3$              ;NO, ERROR FOUND
        BR      4$              ;YES, MOVE ON
2$:     BITB    R3,(R2)         ;
        BEQ     4$              ;YES, MOVE ON
3$:     CMPB    R0,F8BTF        ;THIS BIT?
        BEQ     6$              ;YES, RETURN
4$:     ASR     R3              ;NEXT BIT
        BNE     5$              ;DONE WITH BYTE?
        BISB    #200,R3         ;YES, START NEXT
        DEC     R1              ;
        DEC     R2              ;
5$:     INC     F8BTF           ;INCREMENT BIT #
        CMPB    F8BTF,F8BTL    ;LAST BIT DONE?
        BLE     1$              ;NO, KEEP ON A PLUGGIN
6$:     RTS     PC              ;RETURN


        ;COMPARE A FT9 ENTRY

ERSFT9: MOVB    (R5)+,FT8DF     ;GET DIAG FN.
        BPL     1$              ;MAKE IT POSITIVE
        NEGB    FT8DF           ;
1$:     MOVB    (R5)+,F8BTF     ;GET BIT
        BMI     2$              ;DONE?
        INCB    FT8DUN          ;YES, SET FLAG & DO COMPARE
        BR      3$              ;
2$:     BICB    #BIT7,F8BTF     ;NO, CLEAR FLAG BIT
3$:     CMPB    DFD8,FT8DF      ;THIS DIAG FN.?
        BNE     4$              ;NO, RETURN
        CMPB    R0,F8BTF        ;COMPARE BITS
4$:     RTS     PC              ;RETURN

TSTERS:         ERSFT8          ;ENTRY POINT FOR FT8
                ERSFT9          ;ENTRY POINT FOR FT9
ISOFLG: .BYTE   0               ;UML TABLE SET FLAG
EFLAG:  .BYTE   0               ;ALL ERRORS FLAG
FT9FLG: .WORD   0               ;SET FOR FT9

DFSAVE: .WORD   0               ;LAST DIAG FN

ISOUML: .WORD   0,0,0,0         ;UML TABLE



;SEQ350

.SBTTL          CACHE REFILL TEST SUBROUTINES

.REM    %
RDRFIL
        READS THE CACHE REFILL AND USE RAM DIAGNOSTIC BITS AND
        ARRANGES THEM INTO TWO BYTES, RETURNING WITH R0 CON-
        TAINING A POINTER TO THE FIRST BYTE.  THE FIRST BYTE 
        CONTAINS THE 3-BIT REFILL RAM DATA RIGHT ADJUSTED.  THE
        SECOND BYTE CONTAINS THE 7-BIT REFILL RAM ADDRESS RIGHT-
        ADJUSTED.
        %
RDRFIL: CLR     RFLDAT
        CLR     RFTEMP
        PUSH    R2


        CLR     R2              ;DISPATCH INDEX
        MOV     #170,R0         ;FIRST DIAG FUNC
1$:     PUSH    R0

        DFRD
        POP     R0


        JSR     PC,@RDRFDS(R2)  ;DISPATCH TO STORE BIT(S)
        TST     (R2)+           ;UP INDEX
        INC     R0              ;NEXT D.F.
        CMP     R2,#16.
        BNE     1$              ;DO 8 READS
;NOW CONCATENATE LAST 2 ADDRESS BITS
        ASLB    RFLADR          ;MAKE ROOM
        ASLB    RFLADR
        BISB    RFTEMP,RFLADR   ;STUFF IN LRU'S
        POP     R2

        MOV     #RFLDAT,R0
        RTS     R5
RDRFDS: 2$,2$,3$,3$,4$,2$,2$,2$ ;PICKER-UPPERS

1$:     JSR     PC,RTST25               ;COPY BIT 25 TO C-BIT
        ROLB    RFTEMP
2$:     JSR     PC,RTST21       ;COPY BIT 21 TO C-BIT
        ROLB    RFLADR
        RTS     PC
3$:     JSR     PC,RTST25       ;COPY BIT 25 TO C-BIT
        ROLB    RFTEMP
4$:     JSR     PC,RTST21       ;COPY BIT 21 TO C-BIT
        ROLB    RFLDAT
        RTS     PC


RTST21: CLC
        BIT     #BIT14,@.DAT3   ;PICK UP BIT 21
        BEQ     1$
        SEC
1$:     RTS     PC
RTST25: CLC
        BIT     #BIT10,@.DAT3   ;PICK UP BIT 25
        BEQ     1$


;SEQ351

        SEC
1$:     RTS     PC

RFLDAT: .BYTE   0               ;REFILL RAM DATA
RFLADR: .BYTE   0               ;REFILL RAM ADDRESS
RFTEMP: 0                       ;LOC FOR PICKING UP LRU BITS


;SEQ352

.REM    %
        
RRFONW
        READS OLD AND NEW REFILL RAM DATA AND RETURNS A POINTER
        TO OLD AND NEW IN R1.  OLD AND NEW ARE EACH TWO BYTES
PRODUCED BY THE RDRFIL ROUTINE.  ROUTINE ASSUMES THAT
IT IS EXECUTING A WRITE REFILL RAM PROGRAM SET UP
        IN THE AC'S BEFORE CALLING THIS ROUTINE.
        %

RRFONW: BIS     #BIT15,RRFOLD           ;INDICATE EMPTINESS
        BIS     #BIT15,RRFNEW   
        FIND    <116,13,1>              ;APR EN REFILL RAM WR H
        BCS     99$                     ;PASS CONTROL ERROR
        FIND    <171,29,0>              ;CSH EBOX T1 L
        BCS     99$     
        RDRFL                   ;READ OLD STATE
        MOV     (R0),RRFOLD
        FIND    <170,29,0>              ;CSH EBOX T3 L
        BCS     99$             
        RDRFL                   ;GET NEW STATE
        MOV     (R0),RRFNEW
        CLC                     ;INDICATE SUCCESS
99$:    MOV     #RRFOLD,R1      ;PASS RESULT ADDRESS
        RTS     R5


RRFOLD: .WORD   0
RRFNEW: .WORD   0


;SEQ353

.REM    %
FAULTC - CACHE FAULT RETURN ROUTINE
%
FAULTC: MOV     #CMSGNB,R0      ;GET CACHE MSG POINTER
        ERRCOM  PNTAL           ;PUT IT ON ERROR STACK
        JMP     FAULT           ;RETURN TO DIACON



;FAULT CAHCE IDENTIFICATION MESSAGE
CMSGNB: .ASCII  %CACHE - %
CMSGN1: .WORD   0,0
MSCALL: MOV     CMSALL,CMSGN1
        MOV     CMSALL+2,CMSGN1+2
        RTS     PC
CMSALL: .ASCIZ  %ALL%


;SEQ354

.SBTTL          CACHE TEST ROUTINES
.REM    %
LDWRIT
        THE ROUTINE IS CALLED WITH TWO TRAILING ARGUMENTS.  THE
        FIRST IS A POINTER TO A 36-BIT DATA WORD AND THE SECOND
        IS A PDP10 ADDRESS (0-177777).  IT LOADS THE AC'S WITH:
                1/MOVEM 3,ADDR
                2/HALT
                3/DATA
%

LDWRIT: MOV     (R5)+,R0        ;GET DATA PTR
        MOV     #LDWDAT,R1      
1$:     MOVB    (R0)+,(R1)+     ;MOVE DATA
        CMP     R1,#LDWDAT+5
        BNE     1$
        MOV     (R5)+,LDWMOV    ;GET ADDRESS
        LOAD    1,LDWMOV,3      ;LOAD IT
BCC     2$
        ERRORA  LODERR          ;CODE FAILED TO LOAD
2$:     RTS     R5

LDWMOV: I10     MOVEM   3,,0


        I10     JRST    4,,1


LDWDAT: WD36    0,0,0



        
.EVEN


;SEQ355

.REM    %
        
CSHWRD  
        THIS ROUTINE WRITES A PAGE OF DATA, FILLING ONE WORD
        OF EACH QUADWORD IN THE PAGE WITH THE SUPPLIED DATA.
        TRAILING ARGUMENTS ARE A POINTER TO THE DESIRED 36-BIT
        DAA, THE PHYSICAL PAGE NUMBER, AND THE WORD NUMBER(0-3).
        %
CSHWRD: MOV     (R5)+,R0        ;GET DATA PTR
        MOV     #CSWDAT,R1
1$:     MOVB    (R0)+,(R1)+     ;MOVE DATA
        CMP     R1,#CSWDAT+5
        BNE     1$
        MOV     (R5)+,R0        ;GET PAGE NBR
        SWAB    R0
        ASL     R0
        CLRB    R0
        BIS     (R5)+,R0        ;GET WORD IN THERE
        MOV     R0,CSWMOV
        LOAD    1,CSWMOV,6
        BCC     15$
        ERRORA  LODERR          ;CODE FAILED TO LOAD
15$:    RUN     1
        BCC     2$              
        ERRORA  ERRP            ;PROGRAM TIMED OUT
2$:     RTS     R5              ;OK, RETURN

CSWMOV: I10     MOVEM   5,,0


        I10     ADDI    1,,4


        I10     SOJG    6,,1


        I10     JRST    4,,4


CSWDAT: WD36    0,0,0


        WD36    0,0,200


;SEQ356

.REM    %
        THIS ROUTINE WRITES TO CERTAIN CACHE ADDRESES FORMED
        BY FLOATING A ONE THROUGH ADDRESS BITS 27-33, WHILE
        BITS 34 AND 35 ARE COUNTED FOR EACH ADDRESS.
        THE TRAILING ARGUMENT IS THE PHYSICAL PAGE TO USE
        WHEN WRITING TO THE CACHE.
        %

DSTRBC: CLRB    DSTSET+1
        CLRB    DSTSET+2
        ASL     R0              ;POSITION PAGE
        BISB    R0,DSTSET+1
        SWAB    R0
        BISB    R0,DSTSET+2     ;PAGE PLUGGED IN
        LOAD    1,DSTCOD,11.
        BCC     5$
        ERRORA  LODERR          ;CODE FAILED TO LOAD
5$:     RUN     1               ;DO IT
        BCC     1$              
        ERRORA  ERRP            ;PROGRAM TIMEOUT
1$:     RTS     R5              

;THE FOLLOWING ROUTINE USES AC13 AS A PHYSICAL PAGE
;AND THE "Y" FIELD OF THE SETOM IN AC12 TO ADDRESS CERTAIN
;CHUNKS OF CACHE.  THRU THE MAGIC OF THE POWERFUL PDP10
;INSTRUCTION SET, WORDS 4,5,6,7,10,11,12,13,14,20,21,22,23,
;40,41,42,43,100,102,103,200,201,202,203, AND 400,401,402,403
;ARE MADE TO BE ADDRESSED.  ALL FOUR WORDS IN EACH
;CHUNK ARE ADDRESSED BECAUSE A DIFFERENT RAM CHIP IS USED
;TO HOLD VALID BITS FOR WORD 0 THAN FOR WORD 1, ETC. AND
;WE DO WANT TO TEST THEM ALL !
DSTCOD: I10     XCT     0,,12           ;EXTENDED ADDRESS


        I10     AOS     0,,12


        I10     TRNE    12,,3


        I10     JRST    0,,1


        I10     ADDI    12,,777777,12


;SEQ357


        I10     TRZ     12,,7


        I10     TRNN    12,,1000


        I10     JRST    0,,1


        I10     JRST    4,,11


        I10     SETOM   0,,4,13


DSTSET: WD36    0,0,0


        .EVEN

;SEQ260

.REM    %
CSHPAG
        WRITES ONE PAGE OF DATA.  TRAILING ARGUMENTS ARE A POINTER TO A
        36-BIT DATA WORD AND THE PHYSICAL
        PAGE NUMBER.
        %

CSHPAG: MOV     (R5)+,R0        ;GET DATA PTR
        MOV     #CPGDAT,R1
1$:     MOVB    (R0)+,(R1)+
        CMP     R1,#CPGDAT+5
        BNE     1$
        MOV     (R5)+,R0        ;GET PHYS PAGE
        ASL     R0
        MOVB    R0,CPGADR+1
        SWAB    R0
        MOVB    R0,CPGADR+2
        LOAD    1,CPGCOD,8.
        BCC     15$
        ERRORA  LODERR          ;CODE FAILED TO LOAD
15$:    RUN     1
        BCC     2$              
        ERRORA  ERRP            ;PROGRAM TIMEOUT
2$:     RTS     R5
CPGCOD: I10     XCT     0,,5    ;EXTENDED ADDRESS


        I10     AOS             0,,6


        I10     SOJG    10,,1


        I10     JRST    4,,1


        I10     MOVEM   7,,0,6


CPGADR: WD36    0,0,0


CPGDAT: WD36    0,0,0


;SEQ261

        WD36    0,0,1000


        .EVEN


        .SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #$TRAP,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   0               ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   1               ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN


;SEQ264

.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN


;SEQ266

SPCRST: MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/ LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES,SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT                  ;ENABLE CONDITIONS
       
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;NO
        JSR     R5,BRST1        ;YES,BUTST 34 TICKS
4$:     RTS     PC              ;RETURN


;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5


;SEQ268


.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT

.REM    %
SETPC
        THIS ROUTINE LOAD THE AR WITH A JRST TO THE ADDRESS
        SUPPLIED IN R0, SETS RUN AND CONTINUE.
        %
 
SETPC:  MOV     #RUNJRS,R0      ;POINT TO JRST
        MOV     (R5)+,(R0)      ;STUFF 16-BIT ADDRESS
        STEXCT  RUNJRS          ;SET UP JRST ADDRESS IN AR
        DFXCTT
        SETRUN                  ;SET RUN
        DFXCTT
        CONBUT                  ;PUSH CONTINUE
        RTS     R5

;SEQ272

.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        ERROR                   ;EBOX ERROR


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15




;SEQ283

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0



.REM    %
READ17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1

        MOV     #HDWEXA,R0       ;
        EXCT                    ;DO A SUB AC17 17
        MOV     #ZERO..,R0      ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1

        
        RTS     R5              ;RETURN


        
HDWEXA: I10     SUB AC17,,17


        .EVEN
EXAREA: WD36    0,0,0


        .EVEN

;SEQ287

.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;


;SEQ288


;SEQ289


;SEQ382

.SBTTL          SBUS DIAG SUBROUTINES
.REM    %
SBUSDG - THIS SUBROUTINE SETS UP AN SBUS DIAG OPERAND IN AC16 BY
INSERTING THE CONTROLLER ADDRESS IN THE 36-BIT WORD POINTED TO
BY R0, AN SBUS DIAG IS INITIATED & THE RESULT IS TRANSFERRED
TO THE DTE20.
%

SBUSDG: MOV     R5,BRKPC                ;SAVE PC
SBVUSD1:        PUSH    R1

        MOVB    TSTCON,R1               ;GET CONTROLLER ADR
        ROR     R1              ;0-3 TO R1
        MOVB    R1,4(R0)        ;TO SBUS OPERAND
        BICB    #BIT07,3(R0)    ;CLEAR CONTROLLER ADR 4
        BCC     SBUSD3          ;SET IT?
        BISB    #BIT07,3(R0)    ;YES
        BR      SBUSD3          ;
SBUSD2: MOV     R5,BRKPC        ;SAVE PC
        PUSH    R1              ;
SBUSD3: PUSH    R0
        DFXCTT          ;START THE CLOCK
                STRCLK          ;
        POP     R0              ;
        MOV     #ADAC16,R1              ;ADDRESS TO LOAD
        DPOS            ;DO DEPOSIT
        BCS     1$              ;ERROR
        MOV     #SBUSD,R0       ;DO SBUS DIAG
        JSR     R5,XQT1         ;
        BCS     1$              ;ERROR
        JSR     R5,READ17               ;GET AC178
1$:     POP             R1              ;RESTORE R1
        RTS     R5              ;RETURN
    
ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN


.SBTTL          CACHE REFILL SUBROUTINES
.REM    %
REFILL - ROUTINE TO LOAD ANY REFILL ALGORITHM.
%
REFILL: MOV     R5,BRKPC        ;SAVE PC
REF1:   MOV     (R5)+,$REFPT    ;SAVE TABLE ADDRESS
        REGSAV
        CLR     $RFCNT          ;THE 5-DIGIT COUNT
        CLR     $RFADR          ;THE RAM ADDRESS
        MOV     $REFPT,R4       ;PTR TO TABLE OF DATA
        MOV     #9.,R3          ;CNT GROUPS OF 14 LOCS

1$:     MOV     #REFI1,R5       ;POINT TO BLKO TABLE
        JSR     PC,$RFMAK       ;BUILD 14 BLKO'S
        JSR     R5,LOAD         ;LOAD AC'S
        .WORD   1
        .WORD   -15.
        .WORD   REFI1
        JSR     R5,RUNPR1       ;DO IT
        .WORD   1               ;STARTING ADDRESS
        DEC     R3      
        BNE     1$              ;CONTINUE

        MOV     #REFI2,R5       ;POINT TO LAST 2 BLKO'S
        JSR     PC,$RFMAK       ;BUILD LAST 2
        JSR     R5,LOAD         ;LOAD THEM
        .WORD   15
        .WORD   -3
        .WORD   REFI2
        JSR     R5,RUNPR1       ;DO IT
        .WORD   15              ;STARTING ADDRESS

        REGRST
        RTS     R5

$RFMAK: JSR     PC,$RFBYT       ;GET DATA DIGIT
        JSR     PC,$RFMOD       ;PUT DATA ADDRESS IN BLKO
        INC     $RFADR          ;UP RAM ADDRESS
        ADD     #5,R5           ;NEXT BLKO
        CMP     R5,#REFI2+5.
        BLE     $RFMAK          ;DO MORE
        RTS     PC


;SEQ290

$RFMOD: MOV     $RFADR,R0       ;GET RAM ADDR
        ASL     R0
        ASL     R0
        MOVB    R0,(R5)
        SWAB    R0
        MOVB    R0,1(R5)        ;PUT IN ADDRESS

        SWAB    R2              ;SWAP DATA
        ASR     R2
        BISB    R2,1(R5)        ;BIT 20
        SWAB    R2
        MOVB    R2,2(R5)        ;BITS 18,19
        RTS     PC

$RFBYT: TST     $RFCNT          ;NEED A WORD?
        BNE     1$              ;IF NOT
        MOV     (R4)+,R1        ;GET 5 DATA DIGITS
        ROL     R1              ;LEFT JUSTIFY
        MOV     #5,$RFCNT       ;SET COUNT

1$:     CLR     R2
        CLC
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2
        ROL     R1
        ROL     R2              ;NOW R2 HAS NEW DATUM
        DEC     $RFCNT          ;COUNT IT
        RTS     PC


$REFPT: .WORD   0               ;REFILL DATA TABLE PTR
$RFCNT: .WORD   0               ;DIGIT COUNTER
$RFADR: .WORD   0               ;REFILL RAM ADDRESS CTR


;SEQ291

REFI1:  .REPT   12.
        IO10    BLKO APR,,0
        .ENDR

























REFI2:  .REPT   2.
        IO10    BLKO APR,,0
        .ENDR






        I10     JRST 4,,17


        .EVEN


;SEQ292

.REM    %
CRRSTD - ROUTINE TO LOAD STANDARD REFILL CODE
%
CRRSTD: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,REF1
        .WORD   REFSTD          ;PTR TO STANDARD TABLE
        RTS     R5

;CACHE REFILL RAM DATA TABLE FOR STANDARD CACHE OPERATION

REFSTD: .WORD   01234
        .WORD   56731
        .WORD   23212
        .WORD   37127
        .WORD   11276
        .WORD   56755
        .WORD   67032
        .WORD   30223
        .WORD   01234
        .WORD   56707
        .WORD   77000
        .WORD   74666
        .WORD   44643
        .WORD   13311
        .WORD   13077
        .WORD   70007
        .WORD   01234
        .WORD   56745
        .WORD   57454
        .WORD   70122
        .WORD   01210
        .WORD   56605
        .WORD   60456
        .WORD   54564
        .WORD   01234
        .WORD   56700


;SEQ293

.REM    %
CRRONE - ROUTINE TO LOAD A CACHE USE ALGORITHM TO ACCESS ONLY ONE
CACHE.
%
CRRONE: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LDREF1       ;LOAD CODE
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   2               ;STARTING ADDRESS
        RTS     R5              ;RETURN

LDREF1: PUSH    R1

        ROR     R0              ;POSITION CACHE TO USE
        ROR     R1              ;
        BIC     #177774,R0      ;
        MOV     R0,USEADR+2     ;PUT IN INDEX WORD
        BIC     #77777,R1       ;
        MOV     R1,USEADR       ;
        POP     R1

        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -6
        .WORD   USEADR
        RTS     R5

USEADR: WD36    0,0,0

        IO10    BLKO APR,,0,1   ;LOAD AN ADDRESS

        I10     ADDI AC1,,4     ;NEXT ONE
    
        I10     TRNE AC1,,774   ;DONE?

        I10     JRST,,,2        ;NO, LOOP AGAIN

        I10     JRST,4,,2       ;YES, HALT


;SEQ294

.SBTTL          CACHE SWEEP ROUTINES
        
.REM    %
INVAL - INVALIDATES THE CACHE.
%
INVAL:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CSHSWP
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   1               ;STARTING ADDRESS
        RTS     R5              ;RETURN

CSHSWP: IO10    DATAI CCA,,0


        IO10    CONSZ APR,,200000

        I10     JRST,,,2


        I10     JRST,4,,1


;SEQ295

.SBTTL          MEMORY CONFIGURATION SAVE & RESTORE
;FIND A MEMORY THAT RESPONDS AND SAVE ITS BASE ADDRESS.  IF 
;NO MEMORY IS FOUND WITH FOUR CONSECUTIVE REFERENCES WITHIN THE
;FIRST 256K THEN AN ERROR RETURN IS GIVEN.

FNDM16: PUSH    R1

        MOV     (R5)+,R1        ;GET ADDRESS
        LOAD    1,FND16K,17     ;LOAD AC PRGM (AC1-17)
1$:     RUNBIG  1,20            ;RUN IT, LONG TIMEOUT
        BCC     2$
        ERRORA  ERRP            ;AC CODE HUNG UP - DO 'ALL' CMD
2$:     READ17                  ;GET BASE ADDR
        MOVB    1(R0),(R1)+     
        MOVB    2(R0),(R1)      ;SAVE BASE FOR USERS
        BITB    #BIT2,(R1)+     ;VALID?
        BEQ     3$              ;BR IF O.K.
        SEC                     ;SET ERROR FLAG
        BR      4$
3$:     CLC                     ;CLEAR ERROR FLAG
4$:     POP     R1

        RTS     R5


MCBASA: 0


;SEQ296

FND16K: IO10    CONO,PAG,,0     ;1--CLEAR CACHE, PAGING


        I10     MOVEM,16,,100,17;2--WRITE -1


        I10     CAME,16,,100,17 ;3--COMPARE IT


        I10     JRST,0,,11      ;4--NO COMPARE, NEXT 16K PLEASE


        I10     AOS,0,,17       ;5--INDEX THRU NEXT 3
        

        I10     TRZN,17,,4      ;6--DONE 4 CONSECUTIVE?


        I10     JRST,0,,2       ;7--DO MORE CONSECUTIVE


        I10     JRST,4,,10      ;10-FOUND 4 CONSEC. - HALT


        I10     TRZ,17,,3       ;11-CLEAR ADR 34,35


        I10     ADDI,17,,40000   ;12-GO TO NXT 16K ADR
        

        I10     TLNN,17,,1      ;13-SKIP IF NO MORE TO DO


        I10     JRST,0,,2       ;14-ELSE GO & TRY AGAIN


        I10     JRST,4,,15      ;15-HALT - NONE FOUND

        WD36    7777,7777,7777  ;16- -1 FOR COMPARISON

        WD36    0000,0000,0000  ;17-INITIAL PAGE INDEX



        .EVEN

;SEQ297

.REM    %
        SAVMCN SAVES THE EXISTING MEMORY CONFIGURATION.  THE CONFIGURATION IS
ASSUMED TO BE VALID.  FOR MF20S, ONLY A MAP OF CONFIGURED, USABLE CONTROLLERS
IS KEPT.  THIS MEANS THAT IF POWER IS SHUT OFF THE CONFIGURATION IS DESTROYED.
A C-BIT SET RETURN IS DONE ONLY IS 2 MF20S RESPOND TO ADDRESS 0.  
A VARIABLE (TCWRTO) IS SET TO THE NUMBER OF THE CONTROLLER RESPONDING
TO ADDRESS C (DMA20 IS ASSUMBED IF NO MA20/MB20/MF20 HAS THAT ADDRESS).
        %

NUMCON=5                ;CURRENT MAXIMUM NUMBER OF CORE MEMORY CONTROLLERS

SAVMCN: PUSH    R1              ;SAV REG


;-----HERE TO RECORD STATE OF MA20,MB20/DMA20 MEMORY.

        LOAD    1,GTMCNF,13     ;LOAD AC PRGM (AC1-13)
        MOV     #CONTAB,R1      ;PTR TO CONF TABLE SAVES TIME & SPACE
        RUN     1
        BCS     2$              ;AC ROUTINE HUNG
1$:     READ17                  ;GET FUNCTION 0 RESULT
        MOVB    3(R0),(R1)+     ;INTERLEAVE BITS TO TABLE
        CONTIN                  ;DO FUNCTION 1
        BCS     2$              ;AC ROUTINE HUNG
        READ17                  ;GET FUNCTION 1 RESULT
        MOVB    (R0)+,(R1)+     ;REQUEST ENABLE BITS TO TABLE
        BIC     #170317,-2(R1)  ;CLR JUNK FROM INT & R0 EN BITS
        MOVB    (R0)+,(R1)+     ;MOV ADR BOUNDS STUFF
        MOVB    (R0)+,(R1)+     ;DITTO
         
        BIC     #140003,-2(R1)  ;CLR JUNK BITS FROM ADR BOUNDS
        CONTIN                  ;NEXT FUNCTION 0
        BCC     3$
2$:     ERRORA  ERRP            ;AC ROUTINE HUNG?
3$:     CMP     R1,#CONTAB+<4*NUMCON>   ;DONE WITH ALL CONTRS YET?
        BLO     1$              ;NO...KEEP GOING


;SEQ298

;-----THIS CODE GOES AND GETS MF20 INFO: USABLE MF20 & DESELECTED-AT-0 MAPS.

        LOAD    0,GMFUMP,20     ;LD AC 0-17
        RUN     0               ;RUN THE AC PRGM
        BCS     2$              ;BR ON ERR
        READ17                  ;GET RESULT DATA
        MOV     (R0)+,R1        ;USABLE MF20 MAP TO R1 (BIT0=MF20 #10, ETC)
        MOV     (R0),R0         ;GET DESELECTED-AT-0 MAP INTO R0        
        MOV     R1,UMFMAP       ;SAV USABLE MF20 MAP

;-----FIND OUT WHICH MF20,IF ANY, RESPONDS TO ADDRESS 0.

        COM     R1              ;CALC UNUSABLE MF20 MAP
        BIS     R1,R0           ;CALC UNUSABLE .OR. DESEL-AT-O MAP
        COM     R0              ;CALC USABLE .AND. SEL-AT-0 MAP
        BEQ     5$              ;NO MF20 RESPONDS AT 0.. GO TRY FOR MA20/MB20
        MOV     #7,R1           ;INI MF20 # FOR SEARCH THRU MAP IN R0
4$:     INC     R1              ;NXT MF20
        CLC     
        ROR     R0              ;IS THIS MF20 USABLE & SELECTED-AT-0?
        BCC     4$              ;NO.. TRY NXT
        BNE     10$             ;YES BUT THERE IS ANOTHER TOO.. ERROR! C SET RET
        BR      9$              ;OK, JUST 1 MF RESPONDS TO 0.. GO SAV ITS #

;----HERE TO FIND OUT WHICH MA20/MB20, IF ANY, RESPONDS TO ADDRESS 0.  IF NONE
;DOES THEN WE ASSUME THAT THE DMA20 IS RESPONDING TO 0.

5$:     CLR     R1              ;INI TABLE SRCH NDX
6$:     BIT     #37700,CONTAB+2(R1)     ;IS CONTR LO ADR BOUND AT 0?
        BNE     7$              ;NO.  TRY NEXT MA/MB
        BIT     #4000,CONTAB(R1)        ;DOES CONTR RESP TO RQ 0?
        BEQ     7$              ;NO. TRY NXT MA/MB
        TSTB    CONTAB(R1)      ;IS CONTR TURNED ON (IE INTRL NOT 0)?
        BNE     8$              ;YES.  THIS IS THE ONE, GO RECORD ITS #
7$:     ADD     #4,R1           ;ELSE LOOK AT NXT MA20/MB20
        CMP     R1,#12.         ;TRIED THEM ALL?
        BLE     6$              ;NO, LOOP.  IF YES, JUST ASSUME DMA20.
8$:     ASR     R1              ;DIVIDE NDX BY 4 TO GET CONTR #
        ASR     R1              

;-----HERE TO SET THE CONTROLLER NUMBER WHICH RESPONDS TO 0 AND EXIT.

9$:     MOV     R1,TCWRT0       ;SAV # OF THE CONTROLLER WHICH RESPONDS TO 0
        CLC                     ;IND NO ERROR
10$:    POP     R1              ;GET BACK REG SAVED EARLIER

        RTS     R5              ;RETURN TO CALLER


;SEQ299

;-----THE CORE MEMORY CONFIGURATION TABLE. 2 BYTES AND A WORD PER CONTROLLER.
CONTAB: .REPT   NUMCON
        .BYTE   000             ;THE INTERLEAVE BITS (00II0000)
        .BYTE   000             ;THE WORD REQUEST ENABLE BITS (0000RRRR)
        .WORD   000000          ;THE ADR BOUNDS BITS (00SSSSLLLLUUUU00)
        .ENDM

TCWRT0: .WORD   0               ;NUMBER OF THE CONTR WHICH RESPONDS TO 0.  IF NO
                                ;MA20/MB20/MF20 IS AT 0, THEN WE ASSUME DMA20.


;SEQ300

;-----AC PROGRAM TO READ SBUS DIAGS FROM DIFFERENT CORE MEMORY CONTROLLERS
;SO THAT THE EXISTING CONFIGURATION CAN BE DETERMINED.

GTMCNF: I10     SETZM,0,,16     ;1--


        I10     IOR,16,,12      ;2--


        IO10    SBDIAG,,,16     ;3--


        I10     JRST,4,,5       ;4--
   
        I10     AOS,0,,16       ;5--


        IO10    SBDIAG,,,16     ;6--


        I10     JRST,4,,10      ;7--


        I10     ADD,12,,13      ;10-


        I10     JRST,0,,1       ;11-


        WD36    0100,0000,0000  ;12-


        WD36    0200,0000,0000  ;13-


;-----THIS AC PROGRAM CREATES 2 MAPS:  ONE WHICH SAYS WHICH MF20S ARE USABLE,
;AND ANOTHER SAYING WHICH MF20S ARE DESELECTED AT ADDRESS 0.  THE BITS IN THE
;MAPS CORRESPOND POSITIONALLY.  IF THE MF20 IS NOT USABLE THEN THE DESELECTED
;BIT IS MEANINGLESS.  THE PROGRAM IS HARDCODED TO LOOK AT CONTROLLERS 10-17.
;THE TWO MAPS ARE BUILT IN AC17.  THE "USABLE" MAP IS IN BITS 28-35, BIT 35
;IS FOR MF20 #10.  34 IS FOR #11, ETC.  THE OTHER MAP IS IN  BITS 12-19.  THESE
;BIT POSITIONS ARE USED TO ERASE WORK DONE BY THE DPD-11.  A USABLE CONTROLLER
;IS (1) AN MF20, (2) IN SOFTRWARE STATE 2 OR 3, AND (3) IS NOT DISABLED.

GMFUMP: I10     LSH,17,,1               ;0-<START> SHIFT CTL/OUTPUT WD PRIOR TO NXT MF20


        IO10    SBDIAG,,,15             ;1-DO FCN 1 TO GET MF20 STATUS


        I10     LSH,16,,777767          ;2-GET STATUS INFO INTO RHE OF AC16


;SEQ301

        I10     CAIN,16,,500001 ;3-SKIP IF -USABLE (-MF20,-SS 2/3, OR DISABLED)


        I10     IORI,17,,1      ;4-ELSE MARK CONTR AS USABLE
        

        I10     HRRI,15,,12     ;5-TURN FCN 1 INTO FCN 12 FOR ADRESP RAM RD


        IO10    SBDIAG,,,15     ;6-RD ADRESP RAM WD 0

        I10     TLNE,16,,10     ;7 - SKIP IF DESFL BIT IS 0

        I10     IORI,17,,2000000        ;10-ELSE SET DESEL BIT IN MAP TOO


        I10     SUB,15,,14      ;11-TURN FCN 12 INTO FCN 1, NXT CONTR #


        I10     JUMPL,17,,0     ;12-LP TIL ALL MF20S DONE (AC17 BIT 00 = 0)


        I10     JRST,4,,0       ;13-HALT WHEN DONE


        WD36    0200,0000,0011  ;14-SUB FROM SBDIAG WD TO GET FCN 1, NXT MF


        WD36    3600,0000,0001  ;15-FCN 1 SBDIAG FOR HIGHEST MF20.. MODIFIED


        WD36    0000,0000,0000  ;16-FCN 1 & 12 RESULT GOES HERE


        WD36    7760,0000,0000  ;17-LHF IS CONTROL # OF LPS.  MAPS BUILT HERE


        .EVEN


;SEQ302

.REM    %
        ROUTINE TO RESTORE A PREVIOUSLY SAVED MEMORY CONFIGURATION AND CLEAR
MEMFLG.  EACH TEST WHICH NEEDS MEMORY SHOULD CALL THIS ROUTINE.  IF A PREVIOUS
TEST HAS CALLED THIS ROUTINE, THEN A QUICK EXIT IS TAKEN.  IF MEMORY WAS NOT
AVAILABLE FOR SAVING THEN THIS ROUTINE PRINTS A MESSAGE AND EXITS.
        %


CMEMEN: TST     MEMFLG          ;WAS MEMORY OFF LINE?
        BEQ     2$              ;BR IF NOT.. DONT BOTHER WITH RESTORE
        CLR     MEMFLG          ;CLEAR THE FLAG
        RSTMBX                  ;CLEAR THE HDW DISABLE
        TST     IMEMCF          ;WAS THERE A MEMORY?
        BEQ     1$              ;NO.. PUNT RIGHT NOW
        JSR     R5,RSTMCN       ;ELSE ATTEMPT TO RESTORE MEM
        BCC     2$              ;BR IF RESTORE OK
1$:     PFORCE                  ;TELL USER OFF
        PMSG    <CAN'T PROCEED BEYOND TEST >

        MOV     TSTNUM,R0       ;GET TEST NBR
        DEC     R0              ;MAKE PREVIOUS
        PNTDEC
        PMSG    < WITHOUT MEMORY!\>

        ERREOP                  ;RETIRE
2$:     RTS     R5              ;RETURN


;SEQ303

.REM    %
        RSTMCN RESTORES THE MEMORY CONFIGURATION SVED BY SAVMCN.  ONLY DOES A
C-BIT SET RETURN IF MF20 CONFIGURATION WAS BLOWN BY POWER OFF AND WE DO NOT HAVE
A CORE MEMORY AT ADDRESS 0.
        %

RSTMCN: PUSH    <R3,R4,R5>      ;SAVE REGS


        
        LOAD    1,7$,3          ;LOAD THE AC PROGRAM (AC1-3)
        CLR     R5              ;INIT CONTROLLER NUMBER
        MOV     #CONTAB,R3      ;CONF TABLE PTR INIT
;-----SBUS DIAG FUNCTION 0 SETUP
1$:     MOV     #CNFWD0+3,R4    ;DIAG WD PTR SAVES TIME & SPACE
        MOVB    (R3)+,(R4)      ;INTERLEAVE BITS TO WORD
        BISB    (R3)+,(R4)      ;WD RQ BITS TO WORD
        PUSH    R5              ;SCRATCH CONTR # ON STACK

        ROR     (SP)            ;SPLIT CONTR # 4-1
        BCC     2$              ;BR IF EVEN CONTR
        BISB    #200,(R4)       ;ELSE SET ODD CONTR BIT IN WD
2$:     BISB    #100,(R4)+      ;SET CLR 0-5 BIT IN WD
        MOVB    (SP)+,(R4)      ;HI ORD 4 BITS OF CONTR # TO WD


;SEQ304

;-----SBUS DIAG FUNCTION 1 WORD SETUP
        TST     (R4)+           ;SKIP DIAG WD STUFF TO LEAVE ALONE
        MOV     (R3)+,(R4)      ;MOV ADR BOUNDS BITS TO WD
        BIS     #2,(R4)+        ;SET LOAD BOUNDS BIT IN WD
        MOV     R5,(R4)         ;CONTR # TO WORD
        SWAB    (R4)            ;POSIITON IT PROPERLY
        ASR     (R4)
;-----LOAD SBUS DIAG WORDS AND RUN PROGRAM
        DPOST,4,CNFWD0          ;AC4
        DPOST,6,CNFWD1          ;AC6
        RUN     1
        BCC     4$              
3$:     ERRORA  ERRP            ;AC PROGRAM DIDN'T HALT
;-----SELECT NEXT CORE MEMORY CONTROLLER OR GO ON TO MF20S.
4$:     INC     R5              ;BUMP CONTR #
        CMP     R5,#NUMCON      ;DONE YET?
        BLT     1$              ;NO...CONTINUE

;-----THIS SECTION REENABLES ANY MF20S WHICH EXISTED AND WERE USABLE WHEN
;SAVMCN WAS CALLED.

        LOAD    1,RSTMFP,16     ;LOAD THE AC PROGRAM
        RUN     1               ;RUN IT
        BCS     3$              ;BR ON ERROR
        DFPC                    ;GET THE HALTED PC
        TST     (R0)            ;PC 0 OR NOT 0?
        BEQ     5$              ;0.. NORMAL COMPLETION
        CMP     TCWRT0,#4       ;IS THE CONTR WHICH RESPONDS TO 0 A CORE MEM?
        BLE     5$              ;YES..WE STILL HAVE MEM AT 0
        SEC                     ;MF20S POWERED OFF.. CONFIG BLOWN
        BR      6$              ;EXIT WITH C-BIT SET
5$:     CLC
6$:     POP     <R5,R4,R3>      ;RESTORE REGS


        RTS     R5


;SEQ305

;-----AC PROGRAM TO DO SBDIAGS TO SET CORE MEM CONF.
        .ODD            ;FORCE EVEN ALLIGNMENT FOR CNFWD0
7$:     IO10    SBDIAG,,,4      ;1--DO SBUS DIAG FUNC 0


        IO10    SBDIAG,,,6      ;2--DO SBUS DIAG FUNC 1


        I10     JRST,4,,1       ;3--HALT


CNFWD0: WD36    0100,4000,0000  ;4--SBUS DIAG FUNCTION 0 WORD


                                ;5--
CNFWD1: WD36    0000,0000,1001  ;6--SBUS DIAG FUNCTION 1 WORD


                                ;7--

;-----THIS AC PROGRAM SCANS THRU THE MF20S AND REENABLES THOSE MF20S WHICH WERE
;ON AT THE TIME SAVMCN WAS CALLED.  SINCE IT TAKES SO MUCH DATA TO BRING UP AN
;MF20 AFTER POWER ON WE PUNT IF AN MF20 WHICH WAS ON IS NO LONGER ON, IE IT WAS
;POWERED OFF FOR SOME REASON.  THE MAP UMFMAP IS CREATED AND SVAED HERE BY
;SAVMCN.  AN MF20 WAS USABLE IF A MAP BIT IS SET.  BIT35=MF20#10.  34=#11, ETC.

        .EVEN                   ;FORCE UMFMAP TO EVEN BOUNDARY
                                ;0 - NOT USED
RSTMFP: IO10    SBDIAG,,,16     ;1-<START>DO FCN 1 TO GET STATE OF MF20


        I10     HRRI,16,,1201   ;2-CNG FCN 1 TO LD SS 2, NOT DISABLE


        I10     TRNN,15,,1      ;3-WAS THIS MF20 USABLE WHEN SAVMCN WAS RUN?


        I10     JRST,,,10       ;4--HERE IF NO.  DONT SET SS 2.


        I10     TRNN,17,,1000    ;5-SKIP IF MF20 AT SS 2 (IE NOT POWERED OFF)


        I10     JRST,4,,7       ;6-ELSE HALT.  MEM CONFIG BLOWN BY POWER OFF


        IO10    SBDIAG,,,16     ;7-ALL OK.  SET SS2, NOT DISABLED


        I10     ADD,16,,14      ;10-CNG SBDIAG WD BAK TO FCN 1 RD, NXT MF20


        I10     LSH,15,,777777   ;11-LOOK AT NXT CTL BIT


;SEQ306

        I10     JUMPN,15,,1     ;12-LOOP IF MORE MF20S TO DO


        I10     JRST,4,,0       ;13-ELSE HALT.. ALL DONE OK


        WD36    0177,7777,6600  ;14-CHANGES FCN 1 SET -DIS/SS2 TO FCN 1 RD, NXT


UMFMAP: WD36    0000,0000,0000  ;15-MAP OF USABLE MF20S (BIT35=10,BIT34=11,ETC)


        WD36    2000,0000,0001  ;16-FCN 1 RD SBDIAG WD, MF20 #10 FIRST


                                ;17-ECHO FROM FCN 1

        .EVEN


;SEQ401

.REM    %
INMBAS
        THIS ROUTINE IS USED TO MODIFY ADDRESSES BY INSERTING 
        THE BASE OF THE LOWEST CONFIGURED 16K MEMORY MODULE.
        IT IS CALLED WITH R0 POINTING TO THE INSTRUCTION OR
        ADDRESS TO BE SO MODIFIED.
        %

INMBAS: PUSH    R1

        MOV     RPAG,R1         ;GET RELATIVE PAGE
        ASL     R1
        ADD     @(R5)+,R1       ;OFFSET BY REAL MEMORY BASE 16K
        BICB    #376,1(R0)              ;STUFF 20-26
        BISB    R1,1(R0)
        SWAB    R1
        BICB    #3,2(R0)
        BICB    #374,R1         ;KEEP ONLY 18,19
        BISB    R1,2(R0)                ;STUFF 18,19
        POP     R1

        RTS     R5
RPAG:   0



.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

        .EVEN
$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
@'B