.TITLE  TMBOXC   PAGING DIAGNOSTIC TESTS
        .NLIST CND,BEX
        .LIST MC,MD,MEB
        DTEASB=1                ;ASSEMBLE DTE20 PARAMETERS.
        DTEDEF=1                
        KWASB=1                 ;ASSEMBLE CLOCK PARAMETERS.
        $MBOX=1                 ;ASSEMBLE MBOX ERROR REPORTS
        $OPSEL=1                ;ALLOW "/COMMANDS" FOR USE BY DIAGNOSTIC
        $DFTBP=4                ;DEFAULT BACKPLANE IS 4
        DEXWDS=.DAT3
        PXCT=XCT                ;PXCT INSTR IS XCT INSTR WITH NON-ZERO AC FIELD
        $CHTST=1                ;ASSEMBLE CHANNEL TEST SUBROUTINES
        ISAME=1                 ;SAME ISOLATION FOR KL10PV & KL10PA
        ESTSIZ=^D100
        UCODE=156               ;FREEZE MICRO-CODE VERSION
        EPT=3000                ;EXEC PAGE TABLE LOCATION
        .ENABL  ABS,AMA
$EBOX=1
$INMBAS=1
$ACNDR=1
$SAVMCN=1
DTETST=1
DHNAME=1
.DSABL GBL
        .=3000
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION
RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)
PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR
ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE
TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE
INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH
 
;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT
MCOMP=  104440
RCOMP=  104441
CRADRD= 104423
P36=    104431
PATCON= 104433
GRAB=   104420
SHOVE=  104417
 

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        INC     SP
        INC     SP
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFINITIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT NVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES


;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM

.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE

.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
.IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<.ASCIZ    %'$TXT'%>
        .LIST  SRC
          .WORD  TEXT
        .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
1$:     SWITCH                  ;GET SWITCH REG
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRINT SYMPTOM
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        JSR     PC,(R3)                 ;DO INITIALIZATION
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
          "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     CONSOL          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPEOUT AND HOW TO MAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FT3             ;12
        FTT     FT6             ;14
        FTT     FTNON           ;16 - FT8 NOT USED
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTNON           ;30 - FTMEM NOT USED
        FTT     FTPRM          ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

 
FT3T:   FTM.    <HEDFT3,IDFTAB,IBPTAB,IMSK08,IEXP08,ACTFT3>
 
.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %
FT6T:   FTM.    <ICRADR,ACT80,EXP80,DIFF80>

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %


.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %


.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
ACT36:  AC36
ACT80:  AC80
ACTFT3: ACTF3
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
DIFF80: DIF80
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXP80:  XP80
HEDFT3: HEDF3
IBPTAB: IBPTB
ICRADR: ICRAD
IEXP08: IXP08
IDFTAB: IDFTB
IMSK08: IMK36
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT


.SBTTL  REPORT HEADINGS
        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERCAD,<.ASCIZ %C-RAM ADDRESS: %>
        .LIT ERBTH,<.ASCIZ %INDEX%>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>

 
;SEQ123
 
.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER



;SEQ124


.REM    %
STACK ENTRY IS INDEX., ACTUAL DATA.  THERE MAY BE MORE
THAN ONE ENTRY - LAST IS FLAGGED WITH BIT 15=1.
(ROUTINE IS USED FOR EBOX TEST DCOMP ROUTINE ERRORS)
        %

ACTF3:  CLR     INX.            ;START AT ZEROTH ENTRY
        PCRLF
1$:     MOVB    1(R5),R3
        BIC     #177600,R3      
        MOV     R3,R0           ;PRINT THE INDEX
        PNTOCT
        PMSG    <_>             ;MAKE SURE IT GETS PRINTED
        PUSH    R3              ;SAVE INDEX

        SUB     INX.,R3
        POP     INX.

        ADD     R3,DGP.
        ADD     R3,BYP.
        ADD     R3,EXP.
        ADD     R3,MKP.
        MOVB    @DGP.,FT8DF
        BICB    #200,FT8DF      ;CLEAR GARBAGE
        MOV     #28.,R2
        MOVB    @BYP.,R1        ;GET BYTE PTR TO RIGHT BIT
        ROR     R1              ;0 OR 1 TO C-BIT
        BCC     2$              ;0 SAYS 20-35
        MOV     #12.,R2
2$:     ASR     R1              ;FLUSH EXTRA BIT
        SUB     R1,R2           ;GET LEFTMOST BIT NBR
        MOV     R2,R0
        ADD     #7,R0
        MOVB    R0,F8BTL        ;LAST BIT
        MOVB    R2,F8BTF                ;FIRST BIT
        CLR     R3
        BISB    #200,R3 ;LEFT BIT MASK
3$:     TSTB    F8BTF   
        BPL     4$              ;RIGHT IF BIT # POS
        ASR     R3              ;ELSE FIND
        INCB    F8BTF
        BR      3$
4$:     MOV     EXP.,R1        ;INSURE
        MOV     R5,R2           ;ACTUAL PTR
        BICB    @MKP.,(R1)      ;INSURE
        BICB    @MKP.,(R2)      ;ZEROES WHERE NO TEST
        JSR     PC,PRDBYT       ;TEST AND PRINT NAMES
        TST     (R5)+           ;LOOK FOR END
        BPL     1$              ;MORE TO REPORT
        RTS     PC              ;DONE - BACK TO SCAN


;SEQ125

.REM    %
STACK CONTAINS (11-BYTE) 80-BIT ACTUAAL DATA
        %
AC80:   MOV     R5,R2
        ADD     #11.,R5         ;AND PASS OVER DATA
        MOV     R2,ACP.         ;SAVE POINTER FOR DIF ROUTINE
        PCRLF
        MOV     #ERACT,R0       ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN

.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER


;SEQ128

.REM    %
COMPUTE AND TYPE 80-BIT XOR DIFFERENCE
        %

DIF80:  MOV     ACP.,R1 ;POINT TO ACTUAL

        MOV     #DIF.+12.,R2    ;POINT TO RESULT BUFFER
        MOV     EXP.,R3         ;POINT TO EXPECTED
        ADD     #12.,R1
        ADD     #12.,R3
;DO BYTEWISE XOR FROM BACK TO FRONT

1$:     MOVB    -(R1),R0        ;LOAD ACTUAL
        MOVB    -(R3),-(R2)     ;LOAD EXPECTED
        BICB    R0,(R2)         ;;-ACT .AND. EXP
        BICB    (R3),R0         ;ACT .AND. -EXP
        BISB    R0,(R2)         ;ACT .XOR. EXP
        CMP     #DIF.,R2                ;BACK TO START YET?
        BNE     1$
        PCRLF   
        MOV     #ERDSC,R0      ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN

 
;SEQ129

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER
;SEQ130

.REM    %
STACK CONTAINS (11-BYTE) 80-BIT DEXPECTED DATA
%
XP80:   MOV     R5,R2
        BGT     1$              ;IF PLUS, A REAL POINTER
        ROR     R2              ;SAVE 0 OR 1 BIT
        MOV     #ZMK.,R2        ;ASSUME ZEROES
        BCC     1$              ;BRANCH IF ZERO
        MOV     #ALL7,R2        ;NO - IT''S ONES

1$:     ADD     #11.,R5         ;PASS OVER STACK DATA
        MOV     R2,EXP.         ;SAVE FOR DIF ROUTINE
        PCRLF
        MOV     #ERCOR,R0               ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE, RETURN TO SCANNER


;SEQ131

.REM    %
PRINT BYTE TABLE ERROR FORMAT HEADER
        %

HEDF3:  PCRLF
        MOV     #ERBTH,R0
        PNTAL
        MOV     #ERSCT,R0
        PNTAL
        RTS     PC              ;GO BACK TO SCAN

 

.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN

;SEQ132


.REM    %
STACK HAS POINTER TO A C-RAM ADDRESS
        %
ICRAD:  PCRLF
        MOV     #ERCAD,R0       ;PRIT C-RAM ADDRESS HEADER
        PNTAL
        MOV     @(R5)+,R0       ;GET THE ADDRESS
        PNTOCT
        RTS     PC



.REM    %
EIGHT BIT BYTE EXPECTED DATA
        %

IXP08:  MOV     (R5)+,EXP.
        RTS     PC

.REM    %
STACK POINTS TO BASE OF DIAG FCN TABLE
        %

IDFTB:  MOV     (R5)+,DGP.      ;PICK UP BASE
        RTS     PC              ;BACK TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER

;SEQ144
;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;SEQ145

;BUFFER PACKING ROUTINE TO SUPPORT ACTF3

TYP08:  MOVB    #ASSP,-(R3)     ;SPACE AT RIGHT END
        MOV     #-8.,TEM.
        JSR     PC,BINPAK       ;DO THE BYTE
        MOVB    #ASSP,-(R3)     ;LEADING SPACES
        MOVB    #ASSP,-(R3)     ;2
        ADD     #2,SPCNT        ;FAKE IT
        RTS     PC

;ROUTINE TO TYPE 80-BIT DATA AS 5 16-BIT OCTAL WORDS.  THE
;ADDRESS OF A HEADER TO BE TYPED AT THE LEFT MARGIN IS SUPPLIED
;IN R0.  THE POINTER TO THE BACKWARDS 10-BYTE DATA IS IN
;R2.

TYP80:  PNTAL
        MOV     R2,R3           ;SAVE STARTING POINT
        ADD     #10.,R3         ;POINT TO END
        
1$:     MOVB    -(R3),R0        ;GET ODD BYTE
        SWAB    R0
        CLRB    R0
        BISB    -(R3),R0        ;GET EVEN BYTE
        PNTOCT
        MOV     #ASSP,R0        ;SPACE IT
        PNTCHR
        CMP     R3,R2           ;DONE YET?
        BNE     1$
        MOVB    10.(R3),R0
        PNTOCS          ;PRINT DISP FIELD
        RTS     PC              ;GO BACK TO SCAN

 
;SEQ146
;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT         ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        INX.:   .WORD   0
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138



;SEQ206


;SEQ204



;SEQ153

.SBTTL *PMAC*   PAGING DIAGNOSTIC MACRO DEFINITIONS

.SBTTL  **MACROS TO MANIPULATE 36 BIT DATA WORDS
.MACRO  $CLRWD LOC
        .IF NB LOC
        .IF DF,IGO
        .IFT
        CLRWRD          ;CLEAR 5 BYTES BEGINNING
        .IFF
        JSR     R5,$CLRWD
        .ENDC
        .WORD LOC               ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        .IF DF,IGO
        .IFT    
        CLRBUF                  ;CLEAR 36 BIT BUFFER
        .IFF
        JSR     R5,$CLRBF
        .ENDC
        .ENDC
        .ENDM

.MACRO  $SETWD  LOC
        .IF NB LOC
        .IF DF,IGO
        .IFT
        SETWRD                  ;SET ONES TO 36 BITS  BEGINNNING
        .IFF
        JSR     R5,$SETWD
        .ENDC
        .WORD LOC               ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        .IF DF,IGO
        .IFT
        SETBUF          ;1'S TO 36 BIT BUFFER
        .IFF
        JSR     R5,$SETBF
        .ENDC
        .ENDC
        .ENDM


;SEQ154

.MACRO  $ROLWD  LOC
        .IF NB LOC
        .IF DF,IGO
        .IFT
        ROLWRD          ;ROTATE 36-BIT BUFFER AT LOC
        .IFF
        JSR     R5,$ROLWD
        .ENDC
        .WORD LOC               ;LEFT ONE BIT
        .ENDC
        .IF B LOC
        .IF DF,IGO
        .IFT
        ROLBUF                  ;ROTATE 36-BIT BUFFER LEFT
        .IFF
        JSR     R5,$ROLBF
        .ENDC
        .ENDC
        .ENDM
.MACRO  $RORWD  LOC
        .IF NB LOC
        .IF     DF,IGO
        .IFT
        RORWRD                  ;ROTATE 36-BIT BUFFER AT LOC
        .IFF
        JSR     R5,$RORWD
        .ENDC
        .WORD   LOC             ;RIGHT ONE BIT
        .ENDC
        .IF B LOC
        .IF DF,IGO
        .IFT
        RORBUF                  ;ROTATE 36-BIT BUFFER RIGHT
        .IFF
        JSR     R5,$RORBF
        .ENDC
        .ENDC
        .ENDM


;SEQ155

.MACRO  $MOVWD  S,D
        .IF DF,IGO
        .IFT
        MOVWRD          ;MOVE 5 BYTES
        .IFF
        JSR     R5,$MOVWD
        .ENDC
        .WORD S         ;FROM S
        .WORD D         ;TO D
        .ENDM
.MACRO  $CLRMI  LOC
        .IF NB LOC
        CLRMIC          ;CLEAR 12-BYTE MICROWORD
        .WORD LOC               ;BUFFER STARTING AT LOC
        .ENDC
        .IF B LOC
        CLR$M           ;CLEAR MICRO--WORD BUFFER
        .ENDC
        .ENDM
.MACRO  $COMWD  LOC
        PUSH R0         ;SAVE R0
        MOV     LOC,R0          ;PASS ADDRESS OF 36 BIT BUFFER IN R0
        .IF DF,IGO
        .IFT
        COMWRD          ;TRAP TO ROUTINE TO COMPLIMENT BUDFFER
        .IFF
        JSR     R5,$COMWD
        .ENDC
        POP     R0              ;RESTORE REG
        .ENDM   $COMWD
.MACRO  $COMBF
        .IF DF,IGO
        .IFT
        COMBUF
        .IFF
        JSR     R5,$COMBF
        .ENDC
        .ENDM

;SEQ156

.SBTTL  **MACROS FOR DATA TEST & COMPARE
.MACRO  $MSK36  MSK,EXP,ACT

        .IF B MSK
        .IF DF,IGO
        .IFT
        M36             ;COMPARE 36 BITS @R2,MASKED BY@R3 WITH @RH
        .IFF
        JSR     R5,$MSK36
        .ENDC
        .ENDC
        .IF NB MSK
        .IF     DF,IGO
        .IFT
        M36T            ;COMPARE 36 BITS BEGINNING WITH
        .IFF
        JSR     R5,$MK36T
        .ENDC
        .WORD MSK               ;ACT TO EXPECTED DATA
        .WORD   EXP             ;;AT EXP MASKED BY MASK
        .WORD ACT               ;AT MSK SET C ON ERROR
        .ENDC
        .ENDM

.MACRO  $DCOMP  MSK,FUNC,BYT,EXP,ERMSG
        DCOMP                   ;DO BYTE TABLE COMPARE
        .WORD MSK               ;MASK TABLE STARTS AT MSK
        .WORD FUNC              ;FUNCTION TABLE AT FUNC
        .WORD BYT               ;BYTE TABLE AT BYT
        .WORD EXP               ;EXPTECTED DATA TABLE AT EXP
        .WORD ERMSG!BIT15               ;PRINT MSG AT ERMSG ON ERROR
        .ENDM
.MACRO  $MCOMP
        MCOMP           ;MODIFY DCOMP'S EXPECTED DATA
        .ENDM
.MACRO  $RCOMP
        RCOMP           ;RESTORE DCOMP'S EXPECTED DATA
        .ENDM
.MACRO  ERR23
        ERRCOM PNT23
        .ENDM ERR23


;SEQ157

.SBTTL  **MACROS FOR TEST PATTERN GENERATION
.MACRO  $PATBO LOC
        .IF NB LOC
        MOV     #LOC,R0 ;LOAD 1ST 12 BYTE TEST PATTERN
        P80             ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P80             ;GET 1ST 12BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PAT36  LOC
        .IF NB LOC
        MOV     #LOC,R0 ;LOAD 1ST 6 BYTE TEST PATTERN
        P36             ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P36                     ;GET 1ST 6 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PAT16  LOC
        .IF NB LOC
        MOV     #LOC,R0 ;LOAD 1ST 2 BYTE TEST PATTERN
        P16             ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P16                     ;GET 1ST 2 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM

.MACRO  $PATCO
        PATCON          ;GET NEXT TEST PATTERN TO BUFFER
        .ENDM


;SEQ158

.SBTTL  **MACROS FOR DATA STRUCTURE GENERATION
;BYPNT -- MACRO TO CREATE POINTER TO AN 8 BIT BYTE OF EBUS DATA

.MACRO  BYTPNT  N
        .RADIX 10
        .IIF GE, N-20,  .BYTE  <<35-N>*4>!^B00
        .IF     LT,N-20
        .IF     LT,N-4
        .BYTE   <<<35-32>-N>*4>!^B10
        .IFF
        .BYTE   <<<35-16>-N>*4>!^B01
        .ENDC
        .ENDC
        .IIF    GE, N-36,               .ERROR N ; IN A BYTE POINTER IS TOO LARGE
        .RADIX 8
        .ENDM
;WD18 -- MACRO TO TURN 18 BIT WORDS INTO INV BYTE FORMAT
        .MACRO  WD18    B18.23,B24.35
        .BYTE   B24.35&377,<<B18.23&17>*20>!<<B24.35&7400>/400>,<B18.23&60>/20
        .ENDM
;WD36   -- MACRO TO TURN 36 BIT WORDS INTO INV BYTE FORMAT
.MACRO  WD36    A,XB,C,ZETA
        .NLIST
        .IIF    B,ZETA,STAT36=0
        .IIF    NB,ZETA,ZETA
        .BYTE   <377&C>
        .BYTE   <<C&7400>/400>!<<XB&17>*20>
        .BYTE   <XB&7760>/20
        .BYTE   <A&377>
        .BYTE   <STAT36*20>!<<A&7400>/400>
        .LIST
        .ENDM


;SEQ159

.SBTTL  **MACROS FOR CLOCK CONTROL
.MACRO  EBURST  X
        MOV     #^D X*2,R0
        BURST
        .ENDM
.MACRO  MBURST  X
        MOV     #^D X,R0
        BURST
        .ENDM
.MACRO  $ARLO2  LOC
        MOV     #LOC,R0         ;LOAD THE AR (BUT NOT IR)
        .IF DF,IGO
        .IFT
        ARLOD2          ;WITH DATA AT LOCATION LOC
        .IFF
        JSR     R5,$ARLO2
        .ENDC
        .ENDM

;SEQ160
.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%
        .MACRO VMAC ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12>
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512>
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X11&3400>/^D256>
        BD50.4=<X6&77>
        .WORD   ADDR
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
        .EVEN
.EVEN
.LIST   SRC
        .ENDM   VMAC
        .MACRO UMAC ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D128>
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512>
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .WORD   ADDR
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
        .EVEN
.LIST   SRC
        .ENDM   UMAC

.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
ROT=    241
LSH=    242
EXCH=   250
BLT=    251
AOBJN=  253
JRST=   254
XCT=    256
MAP=    257
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
CAMN=   316
JUMP=   320
JUMPL=  321
JUMPE=  322
JUMPA=  324
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOJE=   342
AOJA=   344
AOS=    350
SOJE=   362
SOJA=   364
SOJGE=  365
SOJG=   367
SETZM=  402
SETZB=  403
ANDI=   405
XOR=    430
IOR=    434
IORI=   435
SETCAM= 452
SETCM=  460
SETO=   474
SETOM=  476
SETOB=  477
HRLI=   505
HLLZS=  513
HRLZI=  515
HRLOI=  525
HRRI=   541
HRRZI=  551
HRRZM=  552
HRRZS=  553
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TDNE=   612
TRZ=    620
TLZ=    621
TRZN=   626
TDZ=    630
TRC=    640
TRCE=   642
TLO=    661
TDO=    670
SBDIAG= 70050

.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM
.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM

;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.NLIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.LIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        RQ0=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ,HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36.
        .IIF NB,WID,W=WID
.IIF    NDF,TRAPS,      JSR     R5,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        .WORD 1
        .IIF NE <XXX-1>,                        .WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS        TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        .WORD   EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG,CLK
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD CLK
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   R5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD   CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
        NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDG,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS       JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN



;SEQ185


;SEQ134

.SBTTL          CHANNEL MACRO LIBRARY  02-FEB-76
.REM    \
        CHANNEL COMMAND WORD MACRO.  GENERATES
A CCW FROM THE FOLLOWING ARGUMENTS.
        CCW     OP              ADR,WC,E,R

OP=     CHLT FOR A 0 OP CODE
        CJMP FOR A 1 OP CODE
        CDTA FOR A 2 OP CODE
ADR=    ADDRESS FIELD
        WC=     WORD COUNT (OPTIONAL)
        E=      NONBLANK FOR END BIT
        R=      NONBLANK FOR REVERSE
\
.MACRO  CCW             OP,ADR,WC,END,REV
        CHLT=0
        CJMP=1
        CDTA=2
        .IIF    B,WC,W=0
        .IIF    NB,WC,W=WC
        .IIF    B,REV,R=0
        .IIF    NB,REV,R=1
        .IIF    B,END,E=0
        .IIF    NB,END,E=1
        ADH=0
        ADL=0
        .IRPC   AD,ADR
        .IIF    GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
        ADL=10*<ADL&7777>+AD
        .ENDM
.NLIST  SRC
        .BYTE   <ADL&377>,<<ADL/400>!<ADH*200&377>>,<<ADH/2&77>!<<W&3>*100>>
        .BYTE<<W&1774>/4>,<<<W&2000>/2000>!<R*2>!<E*4>!<OP*4>>
.LIST   SRC
.ENDM   CCW


;SEQ135

.REM    \
        CBUS DATA MACRO.  GENERATES A 36-BIT
OPERAND FOR PERFORMING A DIAGNOSTIC FUNCTION
TO SIMULATE CBUS REQUESTS.
\

.MACRO  CBUS    LST
        RST=200
        ST=100
        DON=20
        CTOM=10
        STR=4
        SLW=2
        FST=1
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE 0,0,<LOR&3>*100
          .BYTE <LOR>/4,0
.LIST   SRC
.ENDM   CBUS
.REM    \
        READ THE CCW CHA ADDRESS REGISTER AND RETURN A POINTER
TO THE 22-BIT VALUE IN R0
\
.MACRO  CCWRD
.IIF    NDF,TRAPS,      JSR     R5,CCWRD                ;GET CCW ADR
.IIF    DF,TRAPS,       TRAP    131             ;GET CCW ADR
.ENDM   CCWRD
.REM    \
        GENERATE A CALL TO SUBROUTINE WHICH GENERATES ENOUGH MBOX
CLOCKS TO PERFORM THE SPCIFIED NUMBER OF MEMORY REFERENCES.
\
.MACRO  MEMREF  N
.IIF    NDF,TRAPS       JSR     R5,MEMREF               ;ENGOUH MBOX CLOCKS
.IIF    DF,TRAPS        TRAP    147             ;ENOUGH MBOX CLOCKS
          .WORD N                       ;FOR THIS MANY MEM REFS
.ENDM   MEMREF


;SEQ136

.REM    \
        STOP CHANNEKL TIMING
\
.MACRO  STOPCH
.IIF    NDF,TRAPS,      JSR     R5,STOPCH               ;STOP CHANNEL TIMING
.IIF    DF,TRAPS        TRAP    142     ;STOP CHANNEL TIMING
.ENDM   STOPCH
.REM\
        RESTART CHANNEL TIMING
\
.MACRO  STARCH
.IIF    NDF,TRAPS,      JSR     R5,STARCH       ;RESTART CHANNEL TIMING
        
.IIF    DF,TRAPS,       TRAP    143             ;RESTART CHANNEL TIMING
.ENDM   STARCH
.REM    \
        SYNCHRONIZE MBOX WITH CHANNEL TIMING & RESTART CHANNEL
TIMING
\
.MACRO  CHSYNC
.IIF    NDF,TRAPS,      JSR     R5,CHSYNC               ;SYNC MBOX & RESTART CHANS
.IIF    DF,TRAPS,       TRAP    144     ;SYNC MBOX & RESTART CHANS
.ENDM   CHSYNC
.REM    \
        DO A CHANNEL READ
\
.MACRO  MEMRD
.IIF    NDF,TRAPS,      JSR     R5,MEMRD                ;DO CHAN READ
.IIF    DF,TRAPS,       TRAP    145     ;DO CHAN READ
.ENDM   MEMRD
.REM    \
        DO A CHANNEL WRITE
\
.MACRO  MEMWR
.IIF    NDF,TRAPS,      JSR     R5,MEMWR                ;DO CHAN WRITE
.IIF    DF,TRAPS        TRAP    146             ;DO CHAN WRITE
.ENDM   MEMWR


;SEQ137

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH PERFORMS THE
SETUP OF A COMMAND WORD AT EPT+3000+(4*CH).
\
.MACRO  SETEPT  CH,DTA
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL
        .ENDC
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R1         ;COMMAND WORD POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SETEPT               ;CONDITION EPT
.IIF    DF,TRAPS,       TRAP    132     ;CONDITION EPT
.ENDM   SETEPT
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH GETS
TO A POINT WHERE THE CBUS SELECT FOR A SPECIFIC 
CHANNEL IS TRUE.
\
.MACRO  CHSEL   CH
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CHSEL                ;GET TO CBUS SELECT
.IIF    DF,TRAPS,       TRAP    1133            ;GET TO CBUS SELECT
.ENDM   CHSEL
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
SIMULATES A CBUS COMMAND FOR A CHANNEL.
\
.MACRO  SIMBUS  CH,COM
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
        .IF     NB,COM
        .IFT
          MOV   #COM,R1 ;COMMAND POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SIMBUS       ;SIMULATE
.IIF    DF,TRAPS,       TRAP    134             ;SIMULATE COMMAND
.ENDM   SIMBUS


;SEQ138

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH TESTS FOR THE
OCCURENCE OF A MEMORY REFERENCE.  STEPS THE CLOCK ONCE.
\
.MACRO  MEMTST
.IIF    NDF,TRAPS,      JSR     R5,MEMTST       ;MEMREF?
.IIF    DF,TRAPS        TRAP    135             ;MEM REF?
.ENDM   MEMTST
.REM    \
        MACRO TO ASK FOR AND GET A CHANNEL #.
\
.MACRO  TTICH
.IIF    NDF,TRAPS,      JSR     R5,TTICH        ;GET CHANNEL #
        
.IIF    DF,TRAPS,       TRAP    136             ;GET CHANNEL #
.ENDM   TTICH

.REM    \
        MACRO TO SELECT A STARTING CHANNEL #.
\
.MACRO  CHSTRT
.IIF    NDF,TRAPS,      JSR     R5,CHSTRT       ;STARTING CHANNEL TO R4
.ENDM   CHSTRT
.REM    \
        MACRO TO UPDATE THE CHANNEL #
\
.MACRO  NEXTCH
.IIF    NDF,TRAPS,      JSR     R5,NEXTCH       ;NEXT CHANNEL TO R4
.ENDM   NEXTCH
.REM    \
        MACRO TOR EPORT CHANNEL # AND DETERMINE SUBTEST.
\
.MACRO  CHTYP
.IIF    NDF,TRPAS,      JSR     R5,CHTYP        ;TYPE CHANNEL
.IIF    DF,TRAPS,       TRAP    137             ;TYPE CHANNEL
.ENDM   CHTYP


;SEQ139

.REM    \
        CHANNEL FAULT CALLER.  PUTS THE CHANNEL IN R4 ON THE ERROR
STACK AND DETERMINES THE SUBTEST.  ACCEPTS THE SAME ARGUMENTS AS
THE DIACON FAULT MACRO.
\
.MACRO  CFAULT  ARG
          JSR   PC,CFAULT               ;SAVE CHAN # & FAULT RETURN
        .IIF    B,<ARG>         .WORD 0
        .IF     NB,<ARG>
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   CFAULT
.REM    \
        CALLER FOR A ROUTINE WHICH LOOKS FOR THE NEXT MEMORY
REFERENCE.  SETS THE C-BIT IF TIMEOUT.
\
.MACRO  TSTREF
.IIF    NDF,TRAPS,      JSR     R5,TSTREF       ;GET TO SBUS ADR HOLD
.IIF    DF,TRAPS.       TRAP    140             ;GET TO SBUS ADR HOLD
.ENDM   TSTREF

.REM    \
        MACRO TO TEST CHANNEL STATUS WORD 1.
\
.MACRO  STACOM  ST
.IIF    NDF,TRAPS,      JSR     R5,STACOM       ;TEST STATUS
.IIF    DF,TRAPS.       TRAP    141     ;TEST STATUS 1
          .WORD ST              ;EXPECTED STATUS POINTER
.ENDM
.REM    \
        MACRO TO TREST CHANNEL STATUS WORD 2.
\
.MACRO  STAT2   ST
.IIF    NDF,TRAPS.      JSR     R5,STAT2                ;TEST STATUS 2
.IIF    DF,TRAPS,       TRAP    150             ;TEST STATUS 2
          .WORD ST              ;ERXPECTED STATUS POINTER
.ENDM



;SEQ205

.SBTTL  *PTRAP* PAGING TRAP HANDLER AND TABLE
.REM    %
THIS TRAP HANDLER IS USED TO CALL PAGING SUBROUTINES IN A MANNER
EQUIVALENT TO "JSR R5, SUBROUTINE" CALL.  IT HAS THE ADVANTAGE THAT
IT CAN BE USED BY ISOLATION ROUTINES WHICH ARE NOT ASSEMBLED WITH THE
SUBROUTINES AND TAKES ONLY A SINGLE PDP-11 WORD PER CALL.  THE COST IS
SPEED.
%
PTRAP:  MOV     R5,PSAVE                ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC TO R5
        MOVB    -2(R5),R5       ;USE IT TO GET TRAP #
        ASL     R5              ;MULTIPLYT TRAP # BY 2
        MOV     $$CNT(R5),PLINK ;PUT TRAP VECTOER IN LINL ;PCATION
        POP     R5              ;RESTORE TRAP PC TO R5
        POP     PS              ;RESTORE CALLER STATUS
        PUSH    PSAVE           ;PUT R5 ON STACK (FOR RTS R5)
        JMP     @PLINK          ;DISPATCH
PSAVE:  .WORD   0               ;TEMPORARY STORAGE FOR R5
PLINK:  .WORD   0               ;STORAGE FOR LINK ADDRESS


;SEQ206

;YE OLDE TRAP TABLE:

$$CNT:  .WORD   $CLRWD  ;TRAP+0
        .WORD   $CLRBF
        .WORD   $SETWD
        .WORD   $SETBF
        .WORD   $ROLWD
        .WORD   $ROLBF
        .WORD   $RORWD
        .WORD   $RORBF
        .WORD   NOTRAP  ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLEMENTED
        .WORD   $MOVWD
        .WORD   .-1             ;HISTORICAL TRAP..TEMPORARY PDP11 HALT
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLEMENTED
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   $SHOVE
        .WORD   $GRAB           ;TRAP+20
        .WORD   $RUNCL
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   $CRADR
        .WORD   $ARLO2
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   NOTRAP          ;HISTORICAL TRAP..NO LONGER IMPLIMENTED
        .WORD   $PAT80          ;TRAP+30
        .WORD   $PAT36
        .WORD   $PAT16
        .WORD   $PATCO
        .WORD   PNTUML
        .WORD   $MSK36
        .WORD   $MK36T
        .WORD   $DCOMP
        .WORD   $MCOMP          ;TRAP+40
        .WORD   $RCOMP


;SEQ207

;DIAGNOSE INSTRUCTION OPCODES:
        PTWRDT = 104    ;BITS 34&35 EFFECTIVE ADDR=00
        PTREAD = 104            ;BITS 34&35
        PGFLAG = 104    ;BITS 34&35 EFFECTIVE ADDR=10
        PTDWRT = 104    ;BITS 34&35 EFFECTIVE ADDR=100
        PTOVER = 104    ;BITS 33,34&35 EFFECTIVE ADDR=101
        PTSPEC = 104    ;BITS 34 & 35 EFFECTIVE ADDR =3
        CONOPAG = 104   ;BIT 33 FOR EFFECTIVE ADDR OF 4
.SBTTL *PQUATE* TRAP, DIAGNOSTIC FUNCTION & BIT DEFINITIONS
;TRAP DEFINITIONS FOR SUBROUTINE CALLS:
        CLRWRD =        TRAP
        CLRBUF =        TRAP!1
        SETWRD =        TRAP!2
        SETBUF =        TRAP!3
        ROLWRD =        TRAP!4
        ROLBUF =        TRAP!5
        RORWRD =        TRAP!6
        RORBUF =        TRAP!7
        COMWRD =        TRAP!10
        COMBUF =        TRAP!11
        MOVWRD =        TRAP!12
        INCWRD =        TRAP!13
        


;SEQ208

        EBIT3=400
        EBIT4=200
        EBIT5=100
        EBIT6=40
        EBIT7=20
        EBIT8=10
        EBIT9=4
        EBIT10=2
        EBIT11=1
        EBIT12=4000
        EBIT13=2000
        EBIT14=1000
        EBIT15=400
        EBIT16=200
        EBIT17=100
        EBIT18=40
        EBIT19=2
        EBIT20=10
        EBIT21=4
        EBIT22=2
        EBIT23=1
        EBIT24=4000
        EBIT25=2000
        EBIT26=1000
        EBIT27=400
        EBIT28=200
        EBIT29=100
        EBIT30=40
        EBIT31=20
        EBIT32=10
        EBIT33=4
        EBIT34=2
        EBIT35=1


;SEQ209

.SBTTL  *MICRO-DIAGNOSTICS*KL10 MICRO-CODE SYMBOL TABLE
;NUMBER OF RAM WORDS
        RAMWRD = ^D33
;CRAM ADDRESS LABEL TABLE
        BIT17   = 2341
        COMPT   = 2342
        STXOR   = 2343
        USERBT  = 2345
        VMA17   = 2352
        EXECTR  = 2354
        XCTGO   = 2360
        MPTWRDT = 2360
        MPTREAD = 2361
        MPTDWRT = 2362
        MPTOVER = 2364
        MATCH   = 2367
;       2377    = 2377
        NOMTCH  = 2377
;       2370    = 2370
        OP00    = 2370
;       2371    = 2371
        OP01    = 2371
;       2372    = 2372
;       2373    = 2373
        NORMEND = 2373
;       2374    = 2374
        OP10    = 2374
;       2375    = 2375
        OP101   = 2375
;       2346    = 2346
        OSSUSR  = 2346
;       2357    = 2357
        DAMMIT  = 2357
;       2366    = 2366
        INTC21R = 2366
;       2376    = 2376
        CSH2IR  = 2376
;       2351    = 2351
;       2355    = 2355
;       2356    = 2356
;       2356    = 2356
;       1777    = 1777


;SEQ210

.SBTTL  *MICRO-DIAGNOSTICS*KL10 MICRO-CODE SYMBOL TABLE
;NUMBER OF RAM WORDS
        RAMWRD = ^D33
;CRAM ADDRESS LABEL TABLE
        EXECTR  = 2341
        CLRUSE  = 2342
        OP00B   = 2344
        OP01    = 2344
        ABORT   = 2347
        NORMEND = 2350
        SETSIG  = 2351
        XCTGO   = 2360
        MPTWRDT = 2360
        MPTWRDT = 2360
        MPTRREAD= 2361
        PAGFLG  = 2362
        PAGCTL  = 2363
        CONPAG  = 2364
        OP11P1  = 2365
        OP11    = 2367
;       2346    = 2346
        MBOXTM  = 2346
;       2370    = 2370
        MBOXT1  = 2370
;       2371    = 2371
        OP4     = 2371
;       2372    = 2372
;       2373    = 2373
        OPOD    = 2373
;       2374    = 2374
        OP00A   = 2374
;       2375    = 2375
;       2352    = 2352
        OP10    = 2352
;       2353    = 2353
;       2356    = 2356
;       2354    = 2354
;       2355    = 2355
;       1777    = 1777


;SEQ211
  

;TEST DISPATCH TABLE AND INITIALIZATION DISPATCH TABLE
TESTAB: .WORD   ^D8
        .WORD   NPAG01
        .WORD   NPAG02
        .WORD   NPAG03
        .WORD   NPAG04
        .WORD   NPAG05
        .WORD   NPAG06
        .WORD   NPAG07
        .WORD   NPAG08
INITAB: .WORD   ONCE
        .WORD   INIT01!BIT15
        .WORD   INIT02
        .WORD   INIT03
        .WORD   IPAG04!BIT15
        .WORD   IPAG05
        .WORD   IPAG06
        .WORD   IPAG07
        .WORD   IPAG08



;SEQ212

ONCE:
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TMBOXC\>
        PMSG    <PAGING HARDWARE DIAGNOSTIC     VER 1.0\>
        MOV     #PTRAP,34       ;SET VECTOR TO HANDLE TRAP CALLS
        MOV     #340,36         ;THIS PROCESSOR STATUS
        PUSH    #^D16           ;SET UP A SIXTEEN COJNTER
        DTEBAS                  ;GET DTE20 BASE ADDRESS
        MOV     R0,BASE20       ;SAVE DTE BAS ADDRESS
        MOV     R0,R1   ;TRANS ADDR TO R1
        MOV     #.DELAY,R0      ;GET FIRST BUFFER LOCATION FOR DTE ADDRESSES
1$:     MOV     R1,(R0)+        ;LOAD FIRST BUFFER LOC.
        CMPB    (R1)+,(R1)+     ;ADD TWO TO ;R1
        DEC     (SP)            ;DECREMENT COUNTER
        BGT     1$              ;BACK TILL FILLED ALL
        POP     R0              ;FIX STACK
        UCODE=156               ;DIAGB MICROCODE VER. 156 ONLY
        SM                      ;TRY TO START MICRO-CODE
        MOV     #APRID,R0       ;POINTER TO APR ID INSTER
        EXCT                    ;NOW EXECUTE IT..
        BCS     LOADUC  ;IF ERROR, GO LOAD MICRO-CODE
;OTHERWISE THE EXECUTE WORKED.
        EXAMT                   ;NOW EXAMINE RESULTS OF ID INSTR
        .WORD   17              ;AC TO EXAMINE
        .WORD   EWORD1          ;PLACE TO PUT RESULTS OF EXAM
        BCS     LOADUC          ;IF ERROR, RELOAD MIC-CODE
        MOV     EWORD1+2,R1     ;GET PIECE WITH MIC VERS INTO R1
        ASR     R1              ;JUSTIFY CORRECTLY
        ASR     R1
        BIC     #177000,R1      ;OFF TRASH
        CMP     R1,#UCODE       ;IF IT A GOOD VER???
        BEQ     MEMCF           ;BR IF YES
;NOW TAKE CARE OF LOADING MICRO-CODE
        
LOADUC: MOV     JUSLDD,R0       ;GET FLAG
        BEQ     2$              ;IF 0,PROG NOT UST LOADED
        CLRB    CONSOL-2        ;IF .NE. O,FORCE MICRO-CODE LOAD
2$:     JSR     PC,LODMIC       ;GO SEE IF MICRO-CODE NEEDED
MEMCF:  MRESET          ;RESET MACHINE
        MOV     SVLOAD,R0       ;CHECK IF BEEN HERE BEFORE
        BEQ     MEMNOW          ;BR IF YES..
        MOV     #1777,R0        ;DESIRED CRAM ADDRESS FOR PAGE FAILS
        RCRAM                   ;READ THAT LOCATION


;SEQ213

        MOV     #SV1777,R1      ;GET A 10 BYTE PDP11 BUFFER AREA ADDRESS
        PUSH    #^D10           ;PUSH A COUNT ONTO THE STACK
1$:     MOVB    (R0)+,(R1)+     ;MOV A BYTE TO THE BUFFER
        DEC     (SP)            ;DOWN THE COUNT
        BGT     1$              ;CONTINUE TILL DONE
        POP     R0              ;WHEN DONE, FIX STACK
        CLR     SVLOAD          ;CLR FLAG TO SAY BEEN HERE
        MEMNOW: SM              ;START MICRO-CODE
        JSR     PC,IMSAVE       ;FIND MEMORY AND SAVE CONFIG
        RTS     PC              ;ALL DONE
JUSLDD: .WORD   -1              ;IE. JUST LOADED FLAG = -1,,ELSE=0
BASE20: .WORD   0               ;STORAGE FOR DTE20 BASE ADDRESS
APRID:  WD36    7000 ,0000,0017 
SV1777: .BLKB   ^D10    ;BUFFER FOR SAVING MICRO WORD
        .EVEN
SVLOAD: .WORD   -1              ;FLAG TO SAY IF FILE JUST LOADED
;ERROR MESSAGES
SMFAIL: .ASCIZ  %\MICRO-CODE FAILS TO START%
LDFAIL: .ASCIZ  %\AC PROGRAM LOAD FAILS%
RUNFAL: .ASCIZ  %\AC PROGRAM RUN FAILURE%
        
EXMFAL: .ASCIZ %\DECSYSTEM10 EXAM AC FAILURE%
MHUNG:  .ASCIZ %\DIAGNOSTIC MICRO-CODE HUNG%
        
.EVEN


;SEQ214

.SBTTL  *INITIALIZATION: CACHE TO IR DATA LINE TEST
INIT01: BR      3$              ;IF LOOP AVOID MASSIVE LOAD
;IF NO LOOP, WILL ENTER INITIALIZATION ROUTINE HERE AND LOAD
;APPROPRIATE MICRO-CODE OVERLAY
2$:     JSR     R5,OVRLOD               ;NOW MUST LOAD MICRO-CODE OVER LAY
        .WORD   MCRST           ;ADDRESS OF MICRO-CODE ITSEL
        .WORD   PH1NUM          ;THIS MANY WORDS OF IT
3$:     $SETWD          ;AND SET IS INTO A PDP11 36 BIT BUFFER
        RTS     PC              ;AND ALL DONE


;SEQ215

.SBTTL  ****CACHE TO IR DATA LINE TEST
.REM    %
        THIS TEST CHECKS THE CACHE DATA LINE TO IR REGISTER
DATA PATH.  THE FIRST THING DONE IN THIS TEST IS TO EXECUTE
TWO DIAGNOSTIC FUNCTIONS.  THE FIRST DISABLES THE CACHE.
THE SECOND SELECTS THE "AR REGISTER" TO BE READ THRU THE
"MEM TO CACHE" MUX ON THE MB BOARD.  NEXT A TEST
PATTERN IS LOADED INTO THE AR.  AN MBOX CYCLE IS 
STARTED BY THE MICRO-CODE AND AT THE END OF THE
MBOX CYCLE(MBOX RESP IN TRUE). THE DATA FROM
THE AR, THRU THE "MEM TO CACHE" MUX. THRU THE
"CACHE DATA" BUFFER TO THE IR REGISTER, IS ACTUALLY
LOADED INTO THE IR.  THE PDP11 THEN READS THE IR
TO VERIFY THAT THE DATA TRANSFER HAS OCCURRED CORRECTLY
%
;       THIS CODE SIMPLY LOADS 36-BIT DATA
;TO THE AR.  ENOUGH CLOCKS ARE THEN GIVEN TO LOAD
;AND SAVE THE DATA IN THE BR AND ALSO LOAD THE
;DATA TO THE VMA WHERE IT WILL PREVENT "VMA AC REF"
;FROM BEING TRUE.
KLPMOD: WD36 0,6,0700
        .EVEN

C2IRNX:
NPAG01: MOV     #INIC2I,R0     ;MICRO-CODE START LOCATION
        WWADR                   ;TO DIAG ADDR REG, PLUS RESET
        ECLOK                   ;FIRST WORD TO C.R.
        $ARLO2  KLPMOD          ;ALSO SET KL PAG MODE
        DFXCTT                  ;EXECUTE DIAGNOSTIC FUNCTION
        ENIOJA          ;TO ENABLE PDP10 IR ENCODE
        DFXCTT                  ;EXECUTE DIAGNOSTIC FUNCTION
        DISIOJ          ;TO DISABLE SPECIAL IR DECODE
        DFWRTT          ;DIAGNOSTIC FUNCTION WRITE
        NCACH           ;BITS TO SET "CACHE DISABLE, & AR TO CACHE DATA"
        LDMBXA          ;DIAG FUNCTION TO SET-UP MBOX
;FIRST TEST PATTERN IS 777777,777777
        MOV     #C2IREX,R0      ;GET POINTER TO EXPECTED
        MOVB    EWORD1+4,(R0)+  ;SET EXPECTED +0
        MOVB    EWORD1+4,(R0)+  ;+1
        MOVB    EWORD1+3,(R0)+  ;+2
        MOVB    EWORD1+3,(R0)+  ;+3
        MOVB    EWORD1+2,(R0)+ ;+4
  
INIC2I= 002366

;SEQ216

C2IR:   INSYNC          ;COUNT SUBTESTS
        $ARLO2  EWORD1  ;DATA TO AR REGISTER
        MBURST  8.      ;EXECUTE MICRO-CODE
        JSR     R5,$DCOMP       ;DATA TEST AND COMPARE
        .WORD   C2IRMS;POINTER TO MASK TABLE
        .WORD   C2IRDF  ;POINTER TO DIAGNOSITC FUNCTION TABLE
        .WORD   C2IRBT          ;POINTER TO LIST OF YTE POINTERS
        .WORD   C2IREX          ;POINTER TO EXPECTED DATA
        .WORD   0               ;NO ERROR MESSAGE
;OK IF BACK TO HERE
        CMP     #1,R5           ;SUBTEST 1?
        BNE     1$              ;BR IF NO
        $CLRWD          ;SET ZEROS IN 36-BIT  BUFFER
        BR      C2IRNX          ;CONTINUE
1$:     CMP     #2,R5           ;SUBTEST 2?
        BNE     2$              ;BR IF NO
        MOV     #EWORD1,R0      ;IF HERE, GET READY TO GENERATE PATTERNS
        $PAT36
        BR      C2IRNX  ;CONTINUE
;ALL OTHER SUBTESTS NEED PATTERN CONTINUE
2$:     $PATCON
        TST     R0              ;SEE IF DONE ALL YET
        BNE     C2IRNX          ;BR IF NOT YET
        JMP     NORMAL          ;ELSE OUT


;SEQ217

;DCOMP TABLE OF MASKS
C2IRMS:.BYTE    361             ;+0
        .BYTE   376             ;+1
        .BYTE   7                       ;+2
        .BYTE   370             ;+3
        .BYTE   177             ;+4
;DCOMP  TABLE OF DIAGNOSTIC FUNCTIONS
C2IRDF: .BYTE   130             ;+0
        .BYTE   131             ;+1
        .BYTE   131             ;+2
        .BYTE   132             ;+3
        .BYTE   132+BIT7        ;+4
;DCOMP TABLE OF BYTE POINTERS
C2IRBT: BYTPNT  18              ;+0
        BYTPNT  12              ;+1
        BYTPNT  20              ;+2
        BYTPNT  16              ;+3
        BYTPNT  24              ;+4
;DCOMP  ERXPECTED VALUES HERE
C2IREX: .BYTE   0               ;+0
        .BYTE   0               ;+1
        .BYTE   0               ;+2
        .BYTE   0               ;+3
        .BYTE   0               ;+4
NCACH:  WD36 0,0,75             ;BITS TO DISABLE CACHE AND ENABLE AR
                                ;TO CACHE DATA LINES
        .EVEN


;SEQ218


.SBTTL  *INITIALIZATION: PAGE TABLE RAM TEST, FILL RAM CHIPS WITH 0S

;ROUTINE TO INITIALIZE THE PAGE TALE RAM WITH ZEROES, IN PREPARATION FOR
;THE PAGE TABLE RAM TEST..ROUTINE LOADS AC'S WITH SMALL ROUTINE WHICH
;ZEROES THE ENTIRE PAGE TABLER.
INIT02: MRESET          ;RESET THE MACHINE FOR STARTS.
        SM                      ;START THE MICRO-CODE RUNNING
;ALL OK..LOAD INIT PROGRAM & CONINUE INITIALIZATION
1$:     JSR     R5,LOAD         ;ATTEMPT TO LOAD PROGRAM
        .WORD   1               ;START LOAD AT AC ADDR 1
        .WORD   -9.             ;WILL LOAD 9 AC'S
        .WORD   CLRPT           ;POINTR TO FIRST INSTR. OF BLOCK
        BCC     2$
        ERRORA  LDFAIL  ;ERR PROGRAM WONT LOAD CORRECTLY
;ALL SET TO GO..NOW RUN THE PROGRAM
2$:     JSR     R5,RUNPRG               ;RUNT EH AC PROGRAM
        .WORD   1               ;BEGIN IT AT AC 1
        BCC     3$              ;CONTINUE
        ERRORA  RUNFAL          ;ERR IF PROG NEVER FINISHED
3$:     RTS     PC              ;ELSE ALL DONE!!
SMCMD:  .ASCIZ  %SM%            ;"START MICRO-CODE COMMAND.
;AC PROGRAM TO CLEAR ALL PAGE TABLE LOCATIONS
CLRPT:  IO10    CONO,PAG,,60000 ;/1-SET "KL10 PAGING" & "TRAP EN"
        I10     SETZB,14,,15    ;/2-CLR ACS TO HOLD PT ADR & DATA
        I10     PTWRDT,14,,,15  ;/3-WR OS TO P.T. LOCATION
        I10     PTDWRT,14,,2,15 ;/4-WR OS TO PAGE TABLE DIRECTORY
        I10     ADDI,15,,1000    ;/5-TO NXT PAGE TABLE LOCATION
        I10     CAME,15,,11     ;/6-DONE ALL YET??
        I10     JRST,,,3                ;/7-GHO BACK IF NOT YET
        I10     JRST,4,,10      ;/10-ELSE HALT IF ALL DONE



;SEQ219

        WD36    0,0100,0000     ;/11-END OF PTADDR DATA
.EVEN


;SEQ220

.SBTTL  ****PAGE TABLE RAM TEST-ADDRESSES 0-511,DATA  BITS & ADDRESSING
.REM    %
        THIS IS THE TEST FOR THE PAGE TABLE RAM (M8520-PAG1, PAG2, PAG5)
AND SERVES AS BOTH AN ADDRESS TEST AND DATA TEST.  THE TEST IS INTENDED
TO DETECT ANY DATA BITS STUCK EITHER "HI" OR "LO", AND TO DETECT ANY
ADDRESSING PROBLEMS, THIS INCLUDES THE ADDRESS PATH FROM THE VMA, TO THE
ADDRESS BIT BUFFERS (PAG5). TO THE PAGE TABLE RAMS THEMSELVES.
        THE TESTING ALGORITHM IS COMMONLY REFERRED TO AS
"GALLOPING WRITE-RECOVERY" AND THE ALGORITHM IS DESCRIBED AS FOLLOWS:
        WRITE 0'S TO LOCATION 0 <CELL A)
LOOP    WRITE 1'S TO LOCATION 1 (CELL B)
        VERIFY 0'S IN LOCATION 0 (CELL A)
        INCREMENT B, GO TO LOOP
        CONTINUE REPEATING ABOVE PROCESS UNITL B .EQ. LAST
        PAGE TABLE ADDRESS.
WHEN B=LAST PAGE TABLE ADDRESS, INCRFEMENT A, SET B=A AND
                START THE WHOLE PROCESS OVER AGAIN.  WHEN A=THE
                LAST PAGE TABLE ADDRESS START THE WHOLE PROCCESS OVER
                AGAIN, WRITING 1'S INSTEAD OF 0'S, AND 0'S INSTEAD OF ONES.

THE TEST WILL BE RUN IN 2 MAJOR PASSES..THE FIRST PASS WITH 0'S DISTURBING
A CELL UNDER TEST (C.U.T) CONTAINING 1'S.  THIS WILL RUN IN THE ACS, FOR EACH CELL
WITH NO INTERFERENCE FROM THE DPD11.  WHEN IT COMPELTES THE ACS WILL BE
RELOADED TO RUN THE SAME TEST ONLY USING 1'S TO DISTURB A C.U.T
HOLDING O'S
%
NPAG02:  
;THE MICRO-CODE SHOULD STILL BE RUNNING,S O WE WILL LOAD THE AC PROGRAM
;FOR THE FIRST PHASE AND GIVE IT A TRY..
        CLR     R4              ;CLEA R4 FOR USE AS A FLAG
        MOV     #ONES,XPECT     ;SET UP EXPECTED DATA FOR 1ST PASS
        MOV     #PTTST1,ACBLKP  ;POINT TO AC PROGRAM FOR 1ST PASS
        $CLRWD  EWORD2          ;CLEAR A 36-BIT BUFFER
LABEL1: JSR     R5,LOAD         ;BEGIN BY LOADING PROGRAM INTO ACS
        .WORD   0                       ;START IT AT AC0
        .WORD   -16.                    ;PROGRAM IS 16 WORDS LONG
ACBLKP: .WORD   PTTST1          ;POINTR TO FIRST INSTR. OF BLOCK
        BCC     LABEL2          ;BR IF PROGRAM LOADS OK
        ERRORA  LDFAIL          ;ELSE REPORT FAILUREE


;SEQ221

;NOW RUN THE TEST...PHASE 1
LABEL2: INSYNC                  ;COUNT SUBTESTS
        JSR     R5,RUNPRG       ;RUN THE AC PROGRAM
        .WORD   0               ;BEGIN IT AT ACO
        BCC     1$              ;BR IF EXECUTED PROPERLY
        ERRORA  RUNFAL          ;ELSE REPORT LOAD FAILURE
;FIRST SEE IF THE PROGRAM HALTED BECAUSE OF SUCCESSFUL
;FINISH, OR BAD DATA 
1$:     EXAMT                   ;EXAM AC 14
        .WORD   14              ;THIS TELLS EMT ITS AC14
        .WORD   100$            ;PLACE TO PUT THE RESULTS
        BCC     2$              ;EXAMINE WORKED OK
        ERRORA  EXMFAL          ;ERROR MESSAGE IF DIDNT WORK
2$:     MOV     #100$,R0        ;GET POINTER TO DATA
        TSTB    (R0)+           ;CHECK FIRST BYTE
        BNE     3$              ;BR IF NOT ZERO
        TSTB    (R0)+           ;CHECK SECOND BYTE
        BNE     3$              ;BR IF NOT ZERO
        TSTB    (R0)+           ;HIRD BYTE HAS THIS
        BNE     3$              ;BR IF BAD STUFF
        TSTB    (R0)+           ;CHECK FORTH BYTE
        BNE     3$              ;AND BR IF BAD
        TSTB    (R0)+           ;CHECK LAST BYTE
        BNE     3$              ;BR IF BAD
        BEQ     NEXTT           ;ELSE MUST BE GOOD
;IF HERE, CHECK FOR AN ERROR IN THE PAGE TABLE RAM.
;DO THIS BY EXAMINING AC 16 & CHECKING IT FOR ANY DISCREPANCY
        
;AC 16 CONTAINS THE ACTUAL RECEIVED DATA AND SHOULD BE ALL
        
;ONES FOR THIS PHASE OF THE TEST
3$:     EXAMT           ;EXAMINE LOC TO SEE IF ERR OR EOP TYPE HALT
        .WORD   16              ;TELL CONSOLE WHAT ADDRESS TO EXAMINE
        .WORD   EWORD1          ;TELL THE PLACE TO PUT THE RESULT
        BCC     4$              ;BR IF OK
        ERRORA  EXMFAL          ;ELSE REPORT EXAMINE FAILURE
100$:   WD36    0,0,0   ;PLACE TO STORE EXAMINE DATA
.EVEN


;SEQ222

;NOW CHECK RESULTS VERSUS EXPECTED DATA
4$:     JSR     R5,$MK36T       ;36-BIT DATA COMPARE ROUTINE
        .WORD   ERRMSK          ;PNTR TO ERROR MASK
XPECT:  .WORD  0               ;PNTR TO EXPECTED INSERTED HERE
        .WORD   EWORD1  ;PNTR TO ACTUAL RECEIVED HERE
        BCC     NEXTT           ;CONTINUE IF NO DISCREPANCY
;FALL HERE ON ERROR
        JSR     PC,FAULT                ;GO REPORT FOUND FAULT
        .WORD   BIT15!PASS1     ;ERR MESSAGE
PASS1:  .ASCIZ  %\PAGE TABLE RAMS FAIL WRITE DISTURB TEST%
.EVEN
;NOW TO UPDATE WHICH CELL IS UNDER TEST
NEXTT:  CLRB    EWORD2+4        ;CLEA UPPER BITS
        CLRB    EWORD2+3       ;OFF 36 IT BUFFER
        BICB    #374,EWORD2+2   ;BUT LEAVE BITS 18-35 AS R
        ADD     #1000,EWORD2    ;INCR TO NEXT PAGE TABLE ADR
        ADC     EWORD2+2        ;AND DONT LOSE CARRIES
        BITB    #4,EWORD2+2     ;SEE IF DONE ALL C.U.T.
        BNE     2$              ;BR IF DONE ALL..SEE IF NEED 2ND PASS
        JSR     R5,LOAD         ;NOT DONE..CONTINUE NEXT C.U.T., LOAD 2 ACCS
        .WORD   14              ;BEGIN AT AC 14..END AT AC15
        .WORD   2               ;TELL ROUTINE LOAD ONLY 2 ACS
        .WORD   ZERO            ;DATA FOR AC 14
        .WORD   EWORD2          ;DATA FOR AC 15
        BCC     1$              ;BR IF LOAD OK
10$:    ERRORA  LDFAIL          ;ELSE REPORT FAILURE
;NOW UPDATE PTWRT INSTRUCITON TO DO NEXT CELL UNDER TEST
1$:     BISB    XIN+4,EWORD2+4  ;SET BITS 0-3
        BISB    XIN+3,EWORD2+3  ;SET BITS 4-11
        BISB    XIN+2,EWORD2+2  ;SET BITS 12-17
        JSR     R5,LOAD         ;NOW LOAD THAT ONE AC
        .WORD   4               ;LOAD AC 4
        .WORD   1               ;TELL LOADER JUST ONE
        .WORD   EWORD2          ;SAY WHERE
        BCS     10$             ;REPORT ERROR IF NECESSARY
        BR      LABEL2          ;IF NO ERROR, CONTINUE
;CODE TO CHECK IF 2ND PASS IS NECESSARY.
2$:     COM     R4              ;CHECK "PASS" FLAG
        BNE     3$              ;BR IF 2ND PASS STILL TO GO
        NORSKP                  ;IT HERE, ALL DONE WITH TEST
;CODE TO SET UP MACHINE FOR 2ND PASS OF THE TEST
3$:     $CLRWD EWORD2          ;CLR PAGE TABLE ADDR DATA
        MOV     #PTTST2,ACBLKP  ;NEW AC INSTRUCTIONS TO BE LOADED


;SEQ223

        MOV     #ZERO,XPECT     ;SET EXPECTED DATA
        JMP     LABEL1          ;AND CONTINUE, GO MAKE 2ND PASS


;SEQ224

;BLOCK OF AC INSTRUCTIONS TO USE FOR FIRST PASS OF TEST
PTTST1: I10     PTWRDT,13,,,15  ;0-WRITE DATA TO "CELL UNDER TEST"
        I10     ADDI,14,,1000   ;1-INCREMENT OFFSET
        I10     HRRZS,,,14      ;/2-CLR LEFT HALF AC
        I10     JUMPE,14,,10    ;/3-IF 14=0, THEN DONE WITH THIS PASS
        
XIN:    I10     PTWRDT,12,,,14  ;/4-WRITE DISTURB TO PAGE TABLE CELL
        I10     PTREAD,16,,1,15 ;/5-VERIFYH "CELL UNDER TEST" STILL GOOD
        I10     TDO,16,,17      ;/6-FILL HOLES IN DATA CREATED BY MASK
        I10     CAME,16,,13             ;/7-SEE IF DATA AS EXPECTED
        I10     JRST,4,,10      ;.10-HALT IF DISCREPANCY
        I10     JRST,,,0        ;11-ELSE CONTINUE LOOP

        WD36    0,0,0           ;/12-0''S IS DATA FOR WRITE DISTURBING
        WD36    7777,7777,7777  ;/13-1'S DATA FOR "CELL UNDER TEST"
        WD36    0,0,0           ;/14-CURRENT ADDRESS OFFSET
        WD36    0,0,0           ;/15-CELL UNDER TEST
        WD36    0,0,0           ;/16-SCRATCH AC..
ERRMSK: WD36    6117,6000,0777  ;/17-MASK ONLY PAGE TABLE DATA COMES THRU


 


;SEQ225

;BLOCK OF AC INSTRUCITONS TO USE FOR SECOND PASS OF TEST, WHERE
;THE EXPECTED DATA IS ZEROES
PTTST2: I10     PTWRDT,13,,,15  ;/0-WRITE DATA TO "CELL UNDER TEST"
        I10     ADDI,14,,1000   ;/1-INCREMENT OFFSET
        I10     HRRZS,,,14      ;2-CLR AC LEFT HALF
        I10     JUMPE,14,,10    ;/3-IF 14=0, THEN DONW WITH THIS PASS
        I10     PTWRDT,12,,,14  ;4-WRITE DISTURB TO PAGE TABLE CELL

        I10     PTREAD,16,,1,15 ;5-VERIFY "CELL UNDER TEST" STILL GOOD
        I10     TDZ,16,,17      ;6-FILL HOLES IN DATA CREATED BY MASK
        I10     CAME,16,,13     ;7-SEE IF DATA AS EXPECTED
        I10     JRST,4,,10      ;10-HALT IF DISCREPANCY
        I10     JRST,,,0       ;11-ELSE CONTINUE LOOP
        WD36    7777,7777,7777  ;12-1'S IS DATA FOR WRITE DISBURBING
        WD36    0,0,0           ;13-0'S DATA FOR "CELL UNDER TEST"
        WD36    0,0,0           ;14-CURRENT ADDRESS OFFSET
        WD36    0,0,0           ;15-CELL UNDER TEST
        WD36    0,0,0           ;16-SCRATCH A0..
        WD36    6117,6000,0777  ;17-MASK, ONLY PAGE TABLE DATA COMES THRU
.EVEN



;SEQ226

.SBTTL *INITIALIZATION:  PAGE TABLE DIRECTORY, FILL RAM CHIPS WITH OS

;ROUTINE TO INITIALIZE THE PAGE TALE RAM WITH ZEROES, IN PREPARATION FOR
;THE PAGE TABLE RAM TEST..ROUTINE LOAD AC'S WITH SMALL ROUTINE WHICH
;ZEROES THE ENTIRE PAGE TABLE.

INIT03: MRESET                  ;RESET THE MACHINE FOR STARTS.
        SM                      ;START THE MICRFO-CODE

;ALL OK..LOAD INIT PROGRAM & CONTINUE INITIALIZATION
1$:     JSR     R5,LOAD         ;ATTEMPT TO LOAD PROGRAM
        .WORD   1               ;START LOAD AT AC ADDR 1
        .WORD   -10.            ;WILL LOAD 9 AC';S
        .WORD   CLRPTD          ;POINTR TO FIRST INSTR. OF BLOCK
        BCC     2$
        ERRORA  LDFAIL          ;ERR PROGRAM WONT LOAD CORRECTLY

;ALL SET TO GO..NOW RUN THE PROGRAM
2$:     JSR     R5,RUNPRG               ;RUN THE AC PROGRAM
        .WORD   1               ;BEGIN IT AT AC 1
        BCC     3$              ;CONTINUE
        ERRORA  RUNFAL          ;ERR IF PROG NEVER FINISHED
3$:     RTS     PC              ;ELSE ALL DONE!!

;AC PROGRAM TO CLEAR ALL PAGE TABLE LOCATIONS
CLRPTD: IO10    CONO,PAG,,60000 ;/1-SET "KL10 PAGING" & "TRAP EN"
        I10     SETZB,14,,15    ;/2-CLR ACS TO HOLD PT ADR & DATA
        I10     PTWRDT,12,,,15  ;/3-WR DATA TO P.T. LO9CATION
        I10     PTDWRT,14,,2,15 ;/4-WR TO PAGE TABLE DIRECTORY
        I10     ADDI,15,,1000   ;/5-TO NXT PAGE TABLE LOCATION
        I10     CAME,15,,11     ;/6-DONE ALL YET??
        I10     JRST,,,3        ;7/-GO BACK IF NOT YET
        I10     JRST,4,,10      ;/10-ELSE HALT IF ALL DONE


;SEQ227

        WD36    0,0100,0000     ;11-END OF PTADDR DATA
        WD36    5000,0050,0000  ;12-DATA FOR SETTING "PT ACCESS" & "PT WRITABLE"
        .EVEN


;SEQ228

.SBTTL  ****PAGE TABLE DIRECTORY RAM TEST- ADDRESSES 0-128,DATA BITS & ADDRESSING
.REM    %
        THIS IS THE TEST FOR THE PAGE TABLE DIRCTORY RAM (M8520-PAG3)
AND SERVES AS BOTH AN ADDRESS TEST AND DATA TEST.  THE TEST IS INTENDED
TO DETECT ANY DATA BITS STUCK EITHER "HI" OR "LO" AND TO DETECT ANY
ADDRESSING PROBLEMS.  THIS INCLUDES THE ADDRESS PATH FROM THE VMA, TO THE
ADDRESS BIT BUFFERS (PAG5), TO THE PAGE TABLE RAMS TEHMEMSELVES.
        THE TESTING ALGORITHM IS COMMONLY REFERRED TO AS
"GALLOPINBG WRITE-RECOVERY" AND THE ALGORITHM IS DESCRIBED AS FOLLOWS:
        WRITE 0'S TO LOCATION 0 (CELL A)
        
LOOP    WRITE 1'S TO LOCATION 1 (CELL B)
        VERIFY 0'S IN LOCATION 0 (CELL A)
        INCREMENT B. GO TO LOOP
        CONTINUE REPEATING ABOVE PROCESS UNTIL B .EQ. LAST
                PAGE TABLE ADDRESS.
        WHEN B=LAST PAGE TABLE ADDRESS, INCREMENT A, SET B=A AND
                START THE WHOLE PROCESS OVER AGAIN.  WHEN A=THE
                LAST PAGE TABLE ADDRESS START THE WHOLE PROCESS OVER
                AGAIN, WRITING 1'S INSTEAD OF 0'S, AND 0'S INSTEAD OF ONES.
THE TEST WILL BE RUN IN 2 MAJOR PASSES.. THE FIRST PASS WITH 0'S DISTURBING
A CELL UNDER TEST (C.U.T) CONTAINING 1'S. THIS WILL RUN IN THE ACS, FOR EACH CELL
WITH NO INTERFERENCE FROM THE DPD11.  WHEN IT COMPLETES, THE ACS WILL BE
RELEOADED TO RUN THE SAME TEST, ONLY USING 1'S TO DISTURB A C.U.T
HOLDING 0'S.
%
NPAG03: 
;THE MICRO-CODE SHOULD STILL BE RUNNING, SO WE WILL LOAD THE AC PROGRAM
;FOR THE FIRST PHASE AND GIVE IT A TRY...
        CLR     R4              ;CLEAR R4 FOR USE AS A FLAG
        MOV     #ZERO,XPECTD    ;SET UP EXPECTED
        $CLRWD  EWORD2          ;CLEAR A 36-BIT BUFFER
LABEL3: JSR     R5,LOAD         ;BEGIN BY LOADING PROGRAM INTO ACS
        .WORD   0               ;START IT AT AC0
        .WORD   -16.            ;PROGRAM IS 16 WORDS LONG
        .WORD   PTTST3          ;POINTER TO FIRST INSTR. OF BLOCK
        BCC     LABEL4          ;BR IF PROGRAMLOADS OK
        ERRORA  LDFAIL          ;ELSE REPORT FAILURE
        

;SEQ229

;NOW RUN THE TEST...PHASE 1
LABEL4: INSYNC                  ;COUNT SUBTESTS
                
        JSR     R5,RUNPRG       ;RUN THE AC PROGRAM
        .WORD   0               ;BEGIN IT AT ACO
        BCC     1$              ;BR IF EXECUTED PROPERLY
        ERRORA  RUNFAL          ;ELSE REPORT LOAD FAILURE
;IF HERE, CHECK FOR AN ERROR IN THE PAGE TABLE RAM.
;DO THIS BY EXAMINING AC16 & CHECKING IT FOR ANY DISCREPANCY.
;AC 16 CONTAINS THE ACTUAL RECEIVED DATA AND SHOULD BE ALL
;ONES FOR THIS PHASE OF THE TEST.
1$:     EXAMT                   ;EXAMINE LOC TO SEE IF ERR OR EOP TYPE HALT
        .WORD   16              ;TELL CONSOLE WHAT ADDRESS TO EXAMINE
        .WORD   EWORD1          ;TELL THE PLACE TO PUT THE RESULT
        BCC     2$              ;BR IF OK
        ERRORA  EXMFAL          ;ELSE REPORT EXAMINE FAILURE


;SEQ230

;NOW CHECK RESULTS VERSUS EXPECTED DATA
2$:     JSR     R5,$MK36T       ;36-BIT DATA COMPARE ROUTINE
        .WORD   ERDMSK          ;PNTR TO ERROR MASK
XPECTD: .WORD   0               ;PNTR TO TEXPECTED INSERTED HERE
        .WORD   EWORD1  ;PNTR TO ACTUAL RECEIVED HERE
        BCC     NEXTTD          ;CONTINUE IF NO DISCREPANCY
;FALL HERE ON ERROR
        JSR     PC,FAULT                ;GO REPORT FOUND FAULT
        .WORD   BIT15!PASS2     ;ERR MESSAGE
PASS2:  .ASCIZ  %PAGE TABLE DIRECORY RAMS FAIL WRITE DISTURB TEST%
        .EVEN


;SEQ231

;NOT TO UPDATE WHICH CELL IS UNDER TEST
NEXTTD: BICB    #3,EWORD2       ;CLEAR ANY OPCODES FROM BUFFER
        CLRB    EWORD2+4        ;GUARANTEE BITS 00-17
        CLRB    EWORD2+3        ;OF THE 36-BIT BUFFER
        BICB    #374,EWORD2+2   ;ARE CLEARED OUT
        ADD     #4000,EWORD2    ;INCR TO NEXT PAGE TABLE ADR
        ADC     EWORD2+2        ;AND DONT LOSE CARRIES
        BITB    #4,EWORD2+2     ;SEE IF DONE ALL C.U.T.
        BNE     1$              ;BI IF DONE ALL..SEE IF NEED 2ND PASS
        
10$:     JSR     R5,LOAD         ;NOT DONE..CONTINUE NEXT C.U.T.,LOAD 2 ACCS
        .WORD   14              ;BEGIN AT AC 14..END AT AC 15
        .WORD   2               ;TELL ROUTINE LOAD ONLY 2 ACS
        .WORD   ZERO            ;DATA FOR AC 14
        .WORD   EWORD2          ;DATA FOR AC 15
        BCC     20$             ;BR IF LOAD OK
15$:    ERRORA  LDFAIL          ;ELSE REORT FAILURE
        
20$:    BISB    DXIN+4,EWORD2+4;SET PART OF AN ISNTR TO BUFFER
        BISB    DXIN+3,EWORD2+3 ;SET MORE OF AN INSTR TO BUFDFER
        BISB    DXIN+2,EWORD2+2 ;AND SET EVEN MORE ON INSTR
        BISB    #2,EWORD2       ;SET OPCODE FOR "PTDWRT" INSTR
        JSR     R5,LOAD         ;NOW LOAD UP SOME ACS
        .WORD   4               ;WILL LOAD AC 4
        .WORD   1               ;TELL ROUTINE ONLY 1 AC TO LOAD
        .WORD   EWORD2          ;WHT TO LOAD INTO AC
        BCS     15$             ;BR TO REPORT AN ERROR IF ANY
        BR      LABEL4          ;ELSE CONTINUE A GOOD LOOP
;CODE TO CHECK IF 2ND PASS IS NECESSARY
1$:     COM     R4              ;CHECK "PASS" FLAG
        BNE     2$              ;BR IF 2ND PASS STILL TO GO
        NORMAL                  ;IF EHRE, ALL DONE WITH TEST.
;CODE TO SET UP MACHINE FOR 2ND PASS OF THE TEST
2$:     $CLRWD  EWORD2          ;CLR PAGE TABLE ADDR DATA
        JSR     R5,LOAD         ;FOR PASS2, CHANGE ONLY 2 ACS
        .WORD   12              ;LOAD AC 12 & AC 13
        .WORD   2               ;TELL ROUTINE ONLY 2 ACS
        .WORD   ZERO            ;OS DATA FOR WRITE DISTURB
        .WORD   DIRDAT  ;IS DATA FOR CELL UNDER TEST
        BCC     10$             ;CONTINUE IF NO ERRORS
        ERRORA  LDFAIL          ;ERROR IF BAD LOAD


;SEQ232

;BLOCK OF AC INSTRUCTIONS TO USE FOR FIRST PASS OF TEST
PTTST3: I10     PTDWRT,13,,2,15 ;-WRITE DATA TO "CELL UNDER TEST"
        I10     ADDI,14,,4000   ;1-INCREMENT OFSET
        I10     HRRZS,,,14      ;2-CLR LEFT HALF OF AC
        I10     JUMPE,14,,10    ;3-IF 14=0, THEN DOEN WITH THIS PASS
DXIN:   I10     PTDWRT,12,,2,14 ;4-WRITE DISTURB TO PAGE TABLE CELL
        I10     MOVE,16,,13     ;5-COPY EXPECTED DATA TO AC FOR "VERIFY"
        I10     PTDVER,16,,4,15 ;6-VERIFY "CELL UNDER TEST" STILL GOOD
        I10     TRNE,16,,17     ;7-FILL HOLES IN DATA CREATED BY MASK
        I10     JRST,4,,10      ;10-HALT IF DISCREPANCY
        I10     JRST,,,0        ;11-ELSE CONTINUE LOOP
 
PTDVER= 0104
 

        WD36    0,0,0           ;12-0'S IS DATA FOR WRITE DISTURBING
DIRDAT: WD36    0100,7700,0000  ;13-1'S DATA FOR "CELL UNDER TEST"
        WD36    0,0,0           ;14-CURRENT ADDRESS OFFSET
        WD36    0,0,0           ;15-CELL UNDER TEST
        WD36    0,0,0           ;16-SCRATCH AC..
        WD36    0000,0077,7777  ;17-MASK,ONLY PAGE TABLE DATA COMES THRU
ERDMSK: WD36    7777,7700,0000  ;ACTUAL MASK FOR ERROR REPORTING
.EVEN


;SEQ233

.SBTTL  *INITIALIZATION: PAGE FAIL, REFILL, HANDLE & ASSOCIATED CNTRL LOGIC
IPAG04: BR      1$              ;IF IN LOOP,M NO LOAD NECESSARY
        JSR     R5,OVRLOD       ;NOW MUST LOAD SECOND OVERLAY
        .WORD   MCRST2          ;LOCATION OF SECOND OVERLAY BUFFER
        .WORD   PH2NUM          ;THIS MANY WORDS TO LOAD
        SM                      ;START MICRO-CODE TO REFRESH MACHINE
        MOV     #-1,QUKFLG      ;NO LOOP SET FLG FOR LOAD
        JSR     R5,LOAD         ;LOAD AC PROGRAM FOR THIS TEST
        .WORD   0               ;START AT AC 0
        .WORD   -7.             ;LOAD THIS MANY WORDS
        .WORD   PAGPRG          ;PNTR TO AC CODE TO BE LOADED
        BR      2$              ;THATS ALL NEEDED TO INIT
1$:     SM                      ;START MICRO-CODE FOR A FRESH MACHINE
        CLR     QUKFLG          ;CLEAR FLAG TO SAY NO LOAD NEEDED
;NOW SET UP MBOX TO ALWAYS LOAD "EBUS REG"
2$:     DFWRTT         ;FUNCTION WRITE
        .WORD   LEREG           ;PNTR TO DATA TO FNC WRITE WITH
        .WORD   76              ;DIAG FCN TO LOAD WITH
;NOW SET UP EXPECTED DATA TABLE FOR DCOMP
        MOV     #CALEXP,R0      ;PNTRE FOR EXPECTED INTO R0
        PUSH    #6              ;SET UP A COUNTER
        MOV     #ICALEX,R1      ;GET PNTR TO STANDARD EXPECTED STATE
10$:    MOVB    (R1)+,(R0)+     ;SET A BYTE INTO THE TABLE
        DEC     (SP)            ;DOWN THE COUNT
        BGT     10$             ;BR BACK IF MORE TO DO
        POP     R0              ;ELSE CLEAN THE STACK & CONTINUE
        RTS     PC      ;THEN RETURN
QUKFLG: .WORD   0               ;THEN RETURN
LEREG:  WD36    0,0,1000        ;DATA TO SET "LOAD EBUS REG"
        .EVEN


;SEQ234

;SMALL AC PROGRAM LOADED AN  RUN IN THE ACS FOR THIS CONTROL
;LOGIC TEST
PAGPRG: IO10    DATAO,APR,,10   ;0-SET ADDRESS BREAK REGISTER WITH DATA
        I10     CONOPAG,11,,4  ;1-SET "CON TRAP EN"
        IO10    CONO,PI,,12     ;2-SET WR EVEN PARITY IF NECESSARY
        I10     PTWRDT,13,,,14  ;3-WRITE "AWPSC" BITS AS REQUIRED
        I10     CONOPAG,15,,4   ;4-SET "KL PAGING MODE" AS REQUIRED
        I10     PTSPEC,16,,3,17 ;5-EXECUTE SPECIAL MICRO-CODE
        I10     JRST,,,0                ;6-JUMP BACK TO BEGINNING TO MAINTAIN LOOP
        .EVEN
;TABLE OF VALUES FOR INITIALIZAING THE DCOMP TABLES
ICALEX: .BYTE   0               ;+0
        .BYTE   10              ;+1
        .BYTE   32              ;+"
        .BYTE   151             ;+3
        .BYTE   40              ;+4
        .BYTE   0               ;+5
        .EVEN


;SEQ235

.SBTTL PAGE FAIL,PAGE REFILL,PT HANDLE & CNTRL LOGIC
;TEST DESIGNED TO CHECK THE PAGE FAIL LOGIC PAGE REFILL LOGIC
;AND THE SIGNALS PRODUCING PT HANDLE..
NPAG04: MOV     #CMPN5,R2       ;SET UP NUMBER CHANGES PNT FOR MCOMP
        MOV     #CHNG5,R3       ;SET UP ACTUAL CHANGES PNTR FOR DCOMP
        TST     QUKFLG          ;BEGIN BY CHECKING FOR A LOOP

        BEQ     3$              ;IF CLR, LOOPING,AVOID DATA LOAD
        MOV     #DATLST,TSTDAT  ;IF NO LOOP, INITIALIZE DATA PNT
1$:     INSYNC                  ;COUNT SUBTESTS
        MOV     TSTDAT,100$             ;SET DATA PNT FOR THIS SUBTEST
;NOW LOAD UP THE DATA FOR THIS SUBTEST,INTO THE ACS
        JSR     R5,LOAD ;SUBROUTINE TO LOAD THE ACS
        .WORD   10              ;START LOADING AT AC 10
        .WORD   -8.             ;EIGHT WORDS TO LOAD
100$:   .WORD   0               ;PLACE TO PUT DATA PNTR FOR LOADING
        BCC     2$              ;BR IF OK
        ERRORA  LDFAIL          ;ELSE REPORT ERROR
2$:     STEXCT  JSTF0   ;EXECUTE A JRST TO LOC 0
        DFXCTT                  ;A FUNCTION EXECUTE
        STRCLK                  ;TO RESTART 10 CLOCK RUNNING
        MOV     #SI,R0  ;GET A COMMAND FOR KLDCP TO DO
        PRGCMD          ;NOW EXECUTE 5 SINGLE INSTRUCTIONS
        TENSP                   ;TELL KLDCP THAT PDP10 IS OFF!!!!
        DFXCTT                  ;DIAG DFUNC
        STPCLK                  ;MUST STOP KL CLOCK
        DFXCTT          ;NOW A DIAG FUNCTION
        SETRUN                  ;TO SET THE RUN FLOP
        DFXCTT                  ;ONE MORE DIAG FUNC
        CONBUT                  ;TELLING KL ITS OK TO CONTINUE
        JSR     R5,FIND         ;NOW GO FIND THE END OF THIS INSTR
        .WORD   170             ;DIAG FUNCTION TO DO
        .BYTE   00,100          ;POINTER TO "CSH EBOX T3"
        .WORD   0               ;EXPECT IT LO(TRUE)
        DFSCLK          ;ADDITIONAL CLOCK IS THE STATE WE WANT

        BR      4$              ;NOW CHECK CURRENT STATE


;SEQ236

;DATA LOADED OK. NOW EXECUTE THE PROGRAM
3$:     JSR     R5,RUNPRG       ;SUBROUTINE TO RN A PROGRAM
        .WORD   0               ;BEGIN PROGRAM AT AC0
        BCC     4$              ;BR IF RAN OK..
        ERRORA  RUNFAL          ;ELSE REPORT FAILED TO EXECUTE
;NOW PROCESSOR HAS STOPPED- CHECK STATE OF VARIOUS SIGNALS
4$:     MOV     #CALEXP,DCOMPX  ;TELL DCOMP WHERE TO MCOMP..
        MCOMP                   ;MODIFY EXPECTED DATA TABLE
;NOW CHECK THE CURRENT STAT OF THE MBOX
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   CALMSK          ;PNTR TO MASK TABLE
        .WORD   CALFNC          ;PNTR TO DIAG FUNCTION TABLE
        .WORD   CALBIT          ;PNTR TO "BIT PNTR" TABLE
        .WORD   CALEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   0               ;PNTR TO APPROPRIATE ERR MESSAGE
;NOW RESTORE EXPECTED DATA TO NORMAL STATE
        RCOMP

;NOW DO ADDITIONAL FIND AND A SECOND DCOMP..THIS CHECKS "PF HANDLE"
        MOVB    (R3)+,PFHEXP    ;SET EXPECTED FOR THIS SUBTEST
        INSYNC                  ;KEEP TRACKOF SUBTESTS


        JSR     R5,FIND         ;AND FIND NEXT MACHINE STATE
        .WORD   100             ;DIAG FUNCTION
        .BYTE   00,10           ;POINTER TO "CLK INSTR 1777"
        .WORD   1               ;EXPECTED STATE
        DFSCLK          ;ONE MORE CLOCK
        JSR     R5,$DCOMP       ;GO CHECK MACHINE
        .WORD   PFHMSK          ;PNTR TO MASK
        .WORD   PFHFNC          ;PNTR TO DIAG FUNC
        .WORD   PFHBIT          ;PNTR TO BYTE POINTER
        .WORD   PFHEXP          ;PNTR TO EXECTED
        .WORD   0               ;NO MESSAGE
        SM                      ;RESET MACHINE & GET MICRO-CODE ROLLING..
        DFWRTT                  ;TELL MBOX TO ALWAYS LOAD "ERG REG"
        .WORD   LEREG           ;DATA TO SET CORRECT BITS
        .WORD   76              ;DIAG FUNC TO DO IT
        ADD     #5*^D 8,TSTDAT  ;UPDATE STIMULUS DATA TABLE POINTER
        CMP     #^D12,R5        ;DONE ALL YET?
        BGE     1$              ;BR IF NOT YET
        NORMAL
TSTDAT: .WORD   0               ;LOCATION TO HOLD CURRENT STIMULI PNTR
JSTF0:  I10     JRST,,,0        ;INSTRUCTION TO JUMP TO AC 0


;SEQ237

        .EVEN
SI:     .ASCIZ  %SI,SI,SI,SI,SI%
        .EVEN


;SEQ238


;DCOMP TABLES TO BE USED FOR THIS TEST
CALFNC: .BYTE   167             ;+0
        .BYTE   171             ;+1
        .BYTE   174             ;+2
        .BYTE   176             ;+3
        .BYTE   177             ;+4
        .BYTE   167!BIT7        ;+5
;TABLE OF BYTE POINTERS
CALBIT: BYTPNT  7
        BYTPNT  27
        BYTPNT  27
        BYTPNT  29
        BYTPNT  27
        BYTPNT  8
;TABLE OF MASKS
CALMSK: .BYTE   1               ;+0
        .BYTE   363             ;+1
        .BYTE   345             ;+2
        .BYTE   226             ;+3
        .BYTE   327             ;+4
        .BYTE   376             ;+4
;TABLE OF EXPECTED DATA
CALEXP: .BYTE   0               ;+0
        .BYTE   10              ;+1
        .BYTE   32              ;+2
        .BYTE   151             ;+3
        .BYTE   40              ;+4
        .BYTE   0               ;+5
;DCOMP TABLES FOR SINGLE READ DCOMP
PFHFNC: .BYTE   144!BIT7        ;INDEX + 0
PFHBIT: BYTPNT  7               ;+0
PFHMSK: .BYTE   337             ;+0
PFHEXP: .BYTE   0               ;+0
        
.EVEN


;SEQ239

;TABLE OF NUMBERS OF CHANGES TO BE USED BY MCOMP
CMPN5:  .BYTE   2               ;SUBTEST 1
        .BYTE   5               ;ST 3
        .BYTE   5               ;ST 5
        .BYTE   5               ;ST 7
        .BYTE   3               ;ST 9
        .BYTE   3               ;ST 11
        .BYTE   2               ;ST 13
        .BYTE   5               ;ST 15
        .BYTE   1               ;ST 17
        .BYTE   5               ;ST 19
        .BYTE   5               ;ST 21
        .BYTE   2               ;ST 23
        .BYTE   5               ;ST 25
        .EVEN
;TABLE OF ACTUAL CHANGES TO BE USED BY THE MCOMP ROUTINE
CHNG5:  .BYTE   0               ;SUBTEST 1
        .BYTE   41              ;"PF HOLD 00-05"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   00              ;NOT "PF DISP 07" SUBTEST 2
        .BYTE   0               ;SUBTEST 3
        .BYTE   325             ;"PF HOLD 00-05"
        .BYTE   1
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2               
        .BYTE   12              ;"PAG FAIL HOLD"
        .BYTE   4               ;
        .BYTE   50              ;"PAGE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   00              ;"PF DISF 07"SUBTEST 4
        .BYTE   0               ;SUBTEST 5
        .BYTE   304             ;"PF HOLD 00-05"
        .BYTE   1               
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2               
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;"PAGE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;NOT "PF DISP 07"SUBTEST 6


;SEQ240

        .BYTE   0               ;SUBTEST 7
        .BYTE   237             ;"PF HOLD 00-05"
        .BYTE   1               
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;"PAGE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   40              ;"PF DISP 07"SUBTEST 8
        .BYTE   0               ;SUBTEST 9
        .BYTE   20              ;"PF HOLD 00-05"
        .BYTE   3
        .BYTE   150             ;REFILL T4
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;NOT "PF DISP 07" SUBTEST 10
        .BYTE   0               ;SUBTEST 11
        .BYTE   20              ;"PF HOLD 00-05"
        .BYTE   3
        .BYTE   150             ;"PAGE REFILL T4"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;NOT "PF DISP 07SUBTEST 12"


;SEQ241

        .BYTE   0               ;SUBTEST 13
        .BYTE   243             ;"PF HOLD 00-05"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;NOT "PF DISP 07"SUBTEST 14
        .BYTE   0               ;SUBTEST 15
        .BYTE   326             ;"PF HOLD 00-05"
        .BYTE   1
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;"PAGHE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;NOT 'PF DISP 07"SUBTEST 16
        .BYTE   0               ;SUBTEST 17
        .BYTE   56              ;"PF HOLD 00-05"
        .BYTE   0               ;NOT "PF DISP 07"SUBTEST 18
        .BYTE   0               ;SUBTEST 19
        .BYTE   54              ;"PF HOLD 00-05"
        .BYTE   1
        .BYTE   0               ;"PAG FAIL T2"
        .BYTE   2
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;"PAGE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   40              ;"PF DISP 07"SUBTEST 20


;SEQ242

        .BYTE   0               ;SUBTEST 21
        .BYTE   257             ;"PF HOLD 00-05"
        .BYTE   1
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;PAGE FAIL DLY
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   40              ;"PF DISP 07"SUBTEST 22
        .BYTE   0               ;SUBTEST 23
        .BYTE   267             ;'PF HOLD 00-05"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   0               ;"NOT PF DISP 07"SUBTEST 24
        .BYTE   0               ;SUBTEST 25
        .BYTE   105             ;"PH HOLD 00-05"
        .BYTE   1
        .BYTE   0               ;"PAGE FAIL T2"
        .BYTE   2
        .BYTE   12              ;"PAGE FAIL HOLD"
        .BYTE   4
        .BYTE   50              ;"PAGE FAIL DLY"
        .BYTE   5
        .BYTE   1               ;"PAGED REF"
        .BYTE   40              ;"PF DISP 07"SUBTEST 26
        .EVEN



;SEQ243

;LIST OF DATA REQUIRED TO BE RESIDENT IN THE ACS FOR THE
;EXECUTION OF THE INDIVIDUAL SUBTESTS
;;;NOTE: BIT4 IN THE AC13 DATA CONTROLS "PT PARODD"....
;;;IT IS A DONT CARE BIT IN THE TEST AND SETS UP AS FOLLOWS...
;;;AN EVEN NUMBER OF BITS IN THE HALF WORD IN AC13 CAUSES "PT PAR ODD" TRUE
;;;AN ODD NUMBER OF BIS IN THE HALF WORD IN AC13 CAUSES "PT PAR ODD" FALSE
;;;BIT 4 IS THE SWING BIT TO MAKE THE HALF WORD HAVE EVEN OR ODD NUM BITS
DATLST: WD36    0000,0077,7777  ;10-SUBTEST 1 - "DATA0" DATA FPR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    4200,0042,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(10001)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0000,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0040,0000,0000  ;/17-;BITS USED W 'AD FUNC' TO SET MCL BRD CONDITIONS
        WD36    0000,0000,0020  ;/10-;SUBTEST 3 - "DATA0" FOR ADDR BRK REG "ADRCON
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO ET WR ODD PAR
        WD36    4200,0042,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(10000)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0004,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0340,4000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 5  - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    4400,0044,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(10010)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0340,0000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 7 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    3600,0036,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(01110)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0340,0000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0200,0020  ;/10-;SUBTEST 9 - "DATA0" DATA FOR ADDR BRK REG"ADRCON T
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    5000,0050,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS = (10101)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0002,0000  ;/15-;"CONO PAG" DATA TO SET "-KL PAGING MODE","MAY BE P
        WD36    0000,0200,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0044,0000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS

;SEQ244


        WD36    0000,0077,7777  ;/10-;SUBTEST11 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA T SET WR ODD PAR
        WD36    5000,0050,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(10100)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDFR FOR ABOVE BITS
        WD36    0000,0002,0000  ;/15-;"CONO PAG" DATA TO SET "-KL PAGING MODE","MAY BE P
        WD36    0000,0200,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0040,0000,0000  ;/17-;BITS USED W 'AD FUNC' TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 13 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,00000,0000 ;/12-;"CONO PI" DATA TO SET WR EVEN PAR
        WD36    6200,0062,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(11011)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0004,0000  ;/15-;"CONO PAG" DATA TO SET :KL PAGING MODE", MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0100,4000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 15 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    6000,0060,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(11001)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0004,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0100,4000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 17 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR 'TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR EVEN PAR
        WD36    6400,0064,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(11011)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE"."MAY BE PA
        WD36    4000,0000,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0204,0000,0000  ;/17-;BITS USED  W "AD FUNC" TO SET MCL BRD CONDITIONS


;SEQ245

        WD36    0000,0077,7777  ;/10-;SUBTEST 19 - "DATAO" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA T SET WR ODD PAR
        WD36    4400,0044,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(10011)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0000,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0204,0000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 23 - "DATAO" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA T SET WR ODD PAR
        WD36    6600,0066,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(11011)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0304,0020,0000  ;/17-;BITS USD W 'AD FUNC' TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 23 - "DATAO" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET WR ODD PAR
        WD36    7200,0072,0000  ;/13-;DATA FOR PAGE TABLE "APWSC" BITS=(11100)
        WD36    4000,0020,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0002,0000  ;/15-;  "CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0020,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0300,0000,0000  ;/17-;BITS USED W 'AD FUNC" TO SET MCL BRD CONDITIONS
        WD36    0000,0077,7777  ;/10-;SUBTEST 25 - "DATA0" DATA FOR ADDR BRK REG
        WD36    0000,0006,0000  ;/11-;"CONO PAG" DATA FOR "TRAP EN"
        WD36    0000,0000,0000  ;/12-;"CONO PI" DATA TO SET ODD PAR
        WD36    4200,0042,0000  ;/13-;DATA FOR PATE TABLE "APWSC" BITS=(10001)
        WD36    0000,0000,0020  ;/14-;PAGE TABLE ADDR FOR ABOVE BITS
        WD36    0000,0006,0000  ;/15-;"CONO PAG" DATA TO SET "KL PAGING MODE","MAY BE PA
        WD36    0000,0000,0020  ;/16-;DATA FOR VMA DURING SUBTEST
        WD36    0240,0000,0000  ;/17-;BITS USED W "AD FUNC" TO SET MCL BRSD CONDITIONS
        .EVEN


;SEQ246

.SBTTL  *INITIALIZATION: PAGE TABLE PUBLIC BITS TO SCD FLAGS
IPAG05: SM                      ;START THE MICRO-CODE RUNNING
11$:    MOV     #50$,R1         ;GET PNTYR TO MASTER DCOMP LIST
        MOV     #PUBEXP,R2      ;GET EXPECTED LIST PLACE
        MOV     R2,DCOMPX       ;SET DCOMP INITIALIZER
        MOVB    (R1)+,(R2)+     ;SET INDEX + 1
        MOVB    (R1)+,(R2)+     ;INDEX + 2
        MOVB    (R1)+,(R2)+     ;INDEX +3
        MOVB    (R1)+,(R2)+     ;INDEX + 
        JSR     R5,LOAD         ;LOAD AC INIT PROGRAM
        .WORD   0               ;START AT AC 0
        .WORD   -9.             ;NINE INSTRUCTIONS
        .WORD   INIPH2          ;DATA TO LOAD STARTS HERE
        BCC     1$              ;CONTINUE IF ALL OK
        ERRORA  LDFAIL          ;REPORT ERR IF PROG WONT LOAD


;SEQ247

1$:     JSR     R5,RUNPRG       ;NOW RUN INIT PROGRAM
        .WORD   0               ;START AT AC 0
        BCC     2$              ;CONTINUE IF RUNS OK..
        ERRORA  RUNFAL          ;REPORT ERROR IF BAD RUN
2$:     DFXCTT          ;FUNCTION EXECUTE
        STPCLK                  ;TO STOP CLOK IF RUNNING
        DFXCTT                  ;FUNCTION EXECUTE
        CONBUT                  ;TO SET CONTINUE TO CPU
        DFXCTT                  ;FUNCTION EXECUTE
        SETRUN                  ;TO SET RUN FLOP TO ENABLE SINGLE STEPPING
        PUSH    #^D35           ;NEED A TIME-OUT COUNT..USE 35.
3$:     DFXCTT          ;FUNCTION EXECUTE
        SECLK           ;TO SINGLE STEP THE CLOCK

;UPDATE THE TIMEOUT COUNTER HERE.. SHOULD NEVER TAKE 35. TICS
;TO GET TO THE SPECIAL MICRO-CODE
        DEC     (SP)            ;DOWN THE COUNT
        BLE     4$              ;IF TIME OUT, GO REPORT ERROR
        MOV     #147,R0         ;DIAG FUNCTION TO READ CR ADDR BRD
        CRADRD                  ;NOW READ THE CRAM ADDRESS
        CMP     #PAGFLG,R0      ;SEE IF WHERE WE WANT TO BE YET
        BNE     3$              ;BR BACK IF NOT YET...
;FALL TO HERE IF GOT WHERE WE WANT
        POP     R0              ;FIX STACK
        RTS     PC
4$:     ERRORA  MHUNG
50$:    .BYTE   54              ;MR STATE OF SCA DBRD - INDEX + 0
        .BYTE   40              ;MR STATE OF SCAD BRD - INDEX + 1
        .BYTE   2               ;MR STATE OF SCAD BRD - INDEX + 2
        .BYTE   1               ;MR STATE OF SCAD BRD - INDEX + 3


;SEQ248

INIPH2: IO10    CONO,PAG,,60000 ;/0-SET KL MODE & TRAP EN
        I10     SETZB,14,,15            ;/1-CLR ACS FOR WORKSPACES
        I10     PTWRDT,14,,,15  ;/2-WRITE ZEROES TO EVEN LOC
        I10     ADDI,15,,1000   ;/3-PT ADDRESS 1 IS NEXT
        I10     PTWRDT,10,,,15  ;/4-WRITE SPECIAL DATA TO ODD LOC
        I10     JRST,,,6                ;/5-SIMPLE NO-OP
        I10     JRST,4,,7       ;/6-HALT WHEN DONE
        I10     PGFLAG,,,2      ;/7-OPCODE TO GET USTO SPECIAL M-CODE
        WD36    2000,0020,0000  ;/10-DATA TO SET "PT PUBLIC"
        
.EVEN

;SEQ249

.SBTTL PAGE TABLE PUBLIC BITS TO SCD FLAGS
.REM    %
        THIS TEST CHECKS 2 GATESA ON THE SCD BOARD. AS
THEY AFFECT THE TWO SCAD FLAGS "SCD PUBLIC" AND "SCD PRIVATE INSTR"
THE GATES THAT ARE CHECKED ARE GATES WHICH INCLUDE "SCD PRIVATE INSTR"
OR "SCD PUBLIC PAGE" AS INPUTS.  SEE MICRO-CODE LISTING FOR
MORE PRECISE TEST EXPLANATION

%
NPAG05: MOV     #SCDNUM,R2      ;NUMBER OF CHANGES PNTR TO R2
        MOV     #SCDMCP,R3      ;MCOMP CHANGES TABLE PNTR TO R3
        MOV     #SCDGO,R4       ;36-BIT TEST STIMULUS TABLE TO R4
        MOV     #LDCHK2,R0      ;DIAG FUNCTION TO LOAD SET "MBOX RESP SIM"
        MOV     #MRESP,R1               ;ADDRESS OF DATA BITS TO SET "MBOX RESP SIM"
        DFWRT                   ;EXECUTE DIAG FUNCTION TO SET HOSE FLAGS
1$:     INSYNC                  ;COUNT SUBTESTS
        MOV     R4,R0           ;GET ADDRESS OF 36-BIT STIMULUS PATTERN
        JSR     R5,$ARLO2       ;DATA TO AR
        ADD     #5,R4           ;UPDATE STIMULUS LIST POINTER
        MCOMP                   ;SET UP EXPECTED BYTES
        EBURST  5               ;EXECUTE MICRO-CODE
        JSR     R5,$DCOMP       ;CHECK RESULTS
        .WORD   PUBMSK          ;PNT TO MASKS LIST
        .WORD   PUBDF           ;PNT TO DIAG FUNCS
        .WORD   PUBBYT          ;PNT TO BYPNT'RS
        .WORD   PUBEXP          ;PNT TO EXPECTED
        .WORD   PUBERR!BIT15    ;ERR MESSAGE
        RCOMP
        CMP     #^D11,R5                ;DONE ALL?
        BGT     1$              ;BR BACK IF NO
        JMP     NORMAL          ;ELSE ALL DONE


;SEQ250

;LIST OF 36-BIT STIMULUS PATTERNS
SCDGO:  WD36 EBIT3!EBIT9,0,EBIT26        ;ST 1 - SET "PUBLIC"
        WD36    EBIT3!EBIT9,0,EBIT31     ;ST 2-  "PRIVATE" SHOULD SET
        WD36    EBIT3,0,EBIT31  ;ST 3 - "PUBLIC" SHOULD NOT CLEAR
        WD36    0,0,EBIT31              ;ST 4 - "PUBLIC" SHOULD CLEAR
        WD36 0,0,EBIT26                 ;ST 5 - "PUBLIC" SHOULD NOT SET
        WD36 EBIT3,0,EBIT31     ;ST 6 - "PUBLIC" SHOULD NOT SET
        WD36 EBIT9,0,EBIT31             ;ST 7 - "PUBLIC" SHOULD NOT SET
        WD36 EBIT7,0,EBIT31             ;ST 8 - "PUBLIC" SHOULD NOT CLEAR
        WD36 EBIT9,0,EBIT26             ;ST 9 - "PRIVATE' SHOULD NOT SET
        WD36 EBIT3,0,EBIT26     ;ST 10 - "PRIVATE" SHOULD NOT SET
        WD36 0,0,EBIT31         ;ST 11 - "PRIVATE" SHOULD NOT SET
MRESP:  WD36    0,0,0014                ;BITS TO SET "MBOX RESP SIM"
;LIST OF MASKS
PUBMSK: .BYTE   300             ;+0
        .BYTE   300             ;+1
        .BYTE   300             ;+2
        .BYTE   300             ;+3
;LIST OF DIAGNSTIC FUNCTIONS
PUBDF:  .BYTE    134             ;READ SCAD BOARD;+0
        .BYTE   135             ;SCAD;+1
        .BYTE   136             ;SCAD;+2
        .BYTE   137!BIT7        ;SCAD;+3
;LIST OF BYTPNTRS
PUBBYT: BYTPNT 7               ;+0
        BYTPNT  7               ;+1
        BYTPNT  7               ;+2
        BYTPNT  7               ;+3
;LIST OF NOMINAL EXPECTED DATA
PUBEXP: .BYTE   54              ;+0
        .BYTE   40              ;+1
        .BYTE   2               ;+2
        .BYTE   1               ;+3
PUBERR: .ASCIZ  %PROBLEM WITH PAGE TABLE "PUBLIC PAGE" TO SCD FLAGS\%


;SEQ251

;LIST OF NUMBER OF CHANGES PER SUBTEST, TO BE USED BY MCOMP
SCDNUM: .BYTE   2               ;#CHANGES-ST1
        .BYTE   1               ;ST 2
        .BYTE   1               ;ST 3
        .BYTE   2               ;ST 4
        .BYTE   3               ;ST 5
        .BYTE   2               ;ST 6
        .BYTE   2               ;ST 7
        .BYTE   1               ;ST 8
        .BYTE   2               ;ST 9
        .BYTE   2               ;ST 10
        .BYTE   1               ;ST 11

;LIST OF ACTUAL CHANGES USED BY MCOMP
SCDMCP: .BYTE   0               
        .BYTE   56              ;SUBTEST 1 - "SCD PUBLIC PAGE"
        .BYTE   1
        .BYTE   26              ;"SCD PUBLIC EN L", "SCD PUBLIC A","-PRIV INSTR","-PRIV
        .BYTE   1
        .BYTE   20              ;SUBTEST 2 - "SCD PRIVATE INSTR", "PRIVATE INSTR EN"
        .BYTE   1
        .BYTE   20              ;SUBTEST 3 - "SCD PUBLIC EN L", "SCD PUBLIC A"
        .BYTE   1
        .BYTE   50              ;SUBTEST 4 - "KERNAL MODE"
        .BYTE   2
        .BYTE   42              ;"KERNAL OR USER IOT"
        .BYTE   0
        .BYTE   56              ;SUBTEST 5 - "SCD PUBLIC PAGE"
        .BYTE   1
        .BYTE   50              ;"KERNAL MODE"
        .BYTE   2
        .BYTE   42              ;"KERNAL OR USER IOT"


;SEQ252

        .BYTE   1
        .BYTE   50              ;SUBTEST 6 - "KERNEL MODE"
        .BYTE   2
        .BYTE   42              ;SUBTEST 7 - "KERNEL MODE"
        .BYTE   1
        .BYTE   50
        .BYTE   2
        .BYTE   42              ;"KERNEL OR USER IOT"
        .BYTE   1
        .BYTE   26              ;SUBTEST 8 - "SCD PUBLIC EN L", "SCD PUBLIC A"
        .BYTE   0
        .BYTE   56              ;SUBTEST 9 - "SCD PUBLIC PAGE"
        .BYTE   1
        .BYTE   26              ;"SCD PUBLIC EN L", "SCD PUBLIC A", "-PRIV INSTR","-PRIV
        .BYTE   0
        .BYTE   56              ;SUBTEST 10 - "SCD PUBLIC PAGE"
        .BYTE   1
        .BYTE   26              ;"SCD PUBLIC EN L", "SCD PUBLIC A","-PRIV INSTR","-PRIV
        .BYTE   1
        .BYTE   26              ;SUBTEST 11 - "-PRIV INSTR","-PRIV INSTR EN"
        .EVEN


;SEQ253

.REM%
IPRONR: BITB    #FPRNO,INACTS(R5)       ;WANT TO PRINT PROC # ?
        BEQ     1$
        CLR     CSHOPT          ;CLEAR CACHE OPTION FLAG
        JSR     PC,RDAPRI       ;READ IT AND OPTION BIT
        PMSG    <PROC # >
        MOV     PROCID,R0       ;GET THE PROC. NO.
        BIC     #170000,R0
        PNTDEC                  ;PRINT IT
        PCRLF
1$:     RTS     PC
%
IMSAVE: FNDM16  MCBASA          ;SEARCH FOR MEM
        BCC     2$              ;BR IF FOUND
        PMSG    <CONFIGURE MEMORY THEN RELOAD THIS PROG\>
        PRGHLT
1$:     RTS     PC
2$:     SAVMCN          ;SAVE CONFIG 
        RTS     PC
IMRSTR: JSR     R5,RSTMCN               ;RESTORE CONFIG
1$:     RTS     PC
.REM    %
RDAPRI: RSTMBX
        XQT     APRID           ;READ PROCESSOR CONFIG
        BCC     1$              ;NO FAILURE
        CLR     CONSOL-2        ;RESTART LOOKS LIKE REPOWER
        ERROR   <APRID INSTRUCTION FAILED EXECUTION>
1$:     READ17                  ;GET IT
        MOV     (R0),PROCID             ;BITS 20-35
        BIT     #BIT0,2(R0)     ;TEST BIT 19
        BEQ     2$
        MVB     #-1,CSHOPT      ;SET OPTION FLAG
2$:     RTS     PC
APRID:  IO10     BLKI   APR,,17 ;READ JUMPERS
        .EVEN
%
        EBUSRG=167


;SEQ254

IMEMCF: -1              ;INDICATE HAVE MEMORY
ONCEFG: 0               ;ONCE ONLY FLAG, 0 FIRST TIME
MICVER: 0               ;TEMP UCODE VERS #
        PROCID: 0               ;TEMP PROC ID 20-35
        DEVFLG: .WORD   0               ;MEM CONTROLLER FLAG
        .EVEN
        EBUSRG=167


;SEQ255

.SBTTL  *INITIALIZATION: PAGING TESTS USING MEMORY & DOING "REFILLS"
;INITIALIZATION FOR PAGING TESTS INVOLVING MEMORY:
IPAG06: MOV     #1777,R0        ;GET PAGE FAIL ADDRESS OF MICROCODE
        MOV     #SV1777,R1      ;GET ADDRESS OF SAVED LOCATION
        WCRAM           ;RESTORE THE PAGE FAIL LOCATION
IPAG07: 
IPAG08: MOV     #MBXEXP,DCOMPX  ;SET DCOMPAND MCOMP PNTRS
        MOV     #INIEXP,R0      ;GET NOMINAL EXPECTED DATA FOR DCOMP TALES
        MOV     #34,R1          ;HOW MANY BYTES IN THAT TABLE
        MOV     #MBXEXP,R2      ;NOW PNTR TO ACTIVE EXPECTED DATA TABLE
10$:    MOVB    (R0)+,(R2)+     ;SET A BYTE INTO TABLE
        DEC     R1              ;DOWN THE COUNT
        BGT     10$             ;CONTINUE TILL DONE ALL
        CLR     PMAFLG          ;DISABLE PMA TO EBUS REG
        RSTMBX
        MOV     #0,SECMOD       ;CLEAR SECTION MODE
        MOV     #5000,EPTP      ;LOCATE EXEC PROC TAB
        MOV     #17000,UPTP     ;AND UER PROC TABLE
        MOV     #37,EAPWSC      ;SET OCNTROL BITS
        MOV     #36,UAPWSC      ;AND FOR USER
        CLR     PHYSEC          ;CORE IS SECTION ZERO
        CLR     VIRSEC          ;SO ARE REFS
        JSR     PC,WREPT
        JSR     PC,WRUPT        ;DO PROCESS TABLES
;BEST RESTORE MEM CONFIG FOR THESE TESTS
        SM                      ;BEST START MICRO-CODE FRESH
1$:     JSR     PC,IMRSTR       ;NOW GO RESTORE MEMORY CONFIGURATION
        RTS     PC
INIEXP: .BYTE   0               ;+0
        .BYTE   6               ;+1
        .BYTE   205             ;+2
        .BYTE   21              ;+3
        .BYTE   37              ;+4
        .BYTE   160             ;+5
        .BYTE   0               ;+6
        .BYTE   2               ;+7
        .BYTE   3               ;+10

        .BYTE   124             ;+11
        .BYTE   34              ;+12
        .BYTE   34              ;+13
        .BYTE   3               ;+14
        .BYTE   55              ;+15
        .BYTE   322             ;+16
        .BYTE   73              ;+17
 
        .BYTE   302             ;+20
        .BYTE   72              ;+21
        .BYTE   200             ;+22
        .BYTE   72              ;+23


;SEQ256

        .BYTE   322             ;+24
        .BYTE   73              ;+25
        .BYTE   264             ;+26
        .BYTE   52              ;+27
        .BYTE   345             ;+30
        .BYTE   72              ;+31
        .BYTE   365             ;+32
        .BYTE   62              ;+33
        .BYTE   305             ;+34
        .EVEN                   ;*****KEEP BYTE BOUNDARIES CLEAN


;SEQ257

.SBTTL  PAGED READ (PAGE O.K.) SEQUENCE
.REM    %
THIS TEST CHECKS THE SEQUENCING OF A PAGED READ FROM MEMORY BE STEPPING
THRU A MOVE 17,410123.  THE EXEC PAGE TABLE ENTRY HAS THE ACCESS, PUBLIC
WRITABLE, SOFTWARE, AND CACHE BITS ALL 'ON'.  A CONO PAG AT THE
BEGINNING OF THE TEST SETS THE EPT TO 5 AND CLEARS THE PAGING RAM
VALID BITS SO THAT A REFILL IS NEEDED.
SUBTEST 1 CHECKS TEH MBOX STATES AT REFILL T4, THE BEGINNNING OF THE
        PAGE REFILL CYCLE.

SUBTEST 2 CHECKS THE MBOX STATES AT THE EBOX TO FOLLOWING THE
        REFILL CYCLE, WHEN THE MOVE SHOULD BEGIN TO BE EXECUTED.

SUBTEST 3 CHECKS THE MBOX STATES AT THE STAT OF THE CORE READ CYCLE
        OF THE MOVE.
%
NPAG06: CLR     R5             ;CLEAR REG FOR SUBTEST COUNT
        MOV     #CMPN6,R2       ;GET PNTR TO MCOMP NUMBER CHANGES TABLE
        MOV     #CHNG6,R3       ;GET PNTR TO ACTUAL CHANGES DATA
        MOV     #410,R0 
        JSR     PC,PGTPRM       ;SET MODE FLAGS
        JSR     PC,WREPT
        JSR     PC,WRUPT
        JSR     PC,PGSTUP               ;SET UP AC CODE
        STEXCT  JSTF5           ;DO JRSTF TO THE READ
        DFXCTT
          SETRUN
        JSR     R5,FIND         ;GO FIND "CLK EBOX REQ"
        .WORD   102             ;READ CLOCK BOARD
        .BYTE   00,10           ;BIT FOR "CLK EBOX REQ"
        .WORD   1               ;EXPECT IT TRUE
INSYNC                  ;SUBTEST 1
        JSR     R5,FIND         ;GO FIND A SINGLE STEP
        .WORD   176             ;DIAG FUNCTION
        .BYTE   00,100          ;BIUT DESCRIPTOR
        .WORD   0               ;DESIRED STATE

;SEQ258

;NOW CHECK THE CURRENT STATE OF THE MBOX
        MCOMP                   ;MUST MODIFY EXPECTED AND THEN...
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   60$!BIT15       ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTOR TABLES TO NOMINAL STATE
.EVEN
1$:     INSYNC                  ;BEGIN SUBTEST 2
        JSR     R5,FIND         ;GO FIND SINGLE STEP
        .WORD   166             ;DIAG FUNCTION
        .BYTE   00,10           ;BIT DESCRIPTOR FOR "MEM START"
        .WORD   0               ;DESIRED STATE
;NOW CHECK THE CURRENT STATE OF THE MBOX
        MCOMP                   ;MUST MODIFY EXPECTED AND THEN..
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLEE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   61$!BIT15       ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE NOMINAL STATE OF TABLES


;SEQ259

2$:     JSR     R5,FIND         ;FIND ".NOT. CORE BUSY"
        .WORD   160             ;FUNCTIION TO READ MBOX
        .BYTE   2,20            ;BIT FOR ".NOT. CORE BUSY"
        .WORD   0               ;LOOK FOR TRUE
        INSYNC                  ;BEGIN SUBTEST 3
        JSR     R5,FIND         ;GO FIND A SINGLE STEP
        .WORD   176             ;DIAG FUNCTION
        .BYTE   01,10           ;BIT DESCRIPTOR FOR "CSH EBOX TO"
        .WORD   0               ;DESIRED STATE
;NOW CHECK THE CURRENT STATE OF THE MBOX
        MCOMP                   ;MUST MODIFY EXPECTED AND THEN..
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   62$!BIT15       ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE TABLES
3$:     INSYNC                  ;SUBTEST 4
        JSR     R5,FIND         ;GO FIND A SINGLE STEP
        .WORD   165             ;DIAG FUNCTION
        .BYTE   00,10          ;BIT DESCRIPTOR FOR "MEM START"
        .WORD   1               ;DESIRED STATE
;NOW CHECK CURRENT STATE OF MBOX
        MCOMP                   ;MUST MODIFY EXPECTED DATA & THEN...
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   63$!BIT15       ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE TABLES
4$:     NORMAL


;SEQ260

60$:    .ASCIZ  %PAGED READ, AT REFILL T4%
61$:    .ASCIZ  %PAGED READ, AT MEM START OF REFILL CYCLE%
        
62$:    .ASCIZ  %PAGED READ, AT EBOX T0 AFTER REFILL%
63$:    .ASCIZ  %PAGED READ, CORE CYCLE AFTER REFILL%
 
.EVEN

;TABLE OF NUMBER OF CHANGES PER SUBTEST
CMPN6:  .BYTE   6               ;SUBTEST 1
        .BYTE   6               ;ST 2
        .BYTE   7               ;ST 3
        .BYTE   20              ;ST 4
CHNG6:  .BYTE   21              ;SUBTEST 1
        .BYTE   73              ;"CSH USE HOLD"
        .BYTE   22
        .BYTE   300             ;"CSH EBOX REQ EN"
        .BYTE   25
        .BYTE   72              ;"CSH ADR PMA EN"
        .BYTE   26
        .BYTE   64              ;"CSH EBOX CYC B"
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-31
        .BYTE   32
        .BYTE   265     ;"PAGE REFILL"
        .BYTE   7               ;SUBTEST 2
        .BYTE   32              ;"MEM BUSU", "HOLD ERA"
        .BYTE   10
        .BYTE   4               ;"SBUS ADR HOLD","ANY SBUS RQ IN"
        .BYTE   14
        .BYTE   175             ;"MEM RD RQ","MEM RQ 0,1,2,3","MEM START"
        .BYTE   21
        .BYTE   71              ;"READY TO GO","USE HOLD"
        .BYTE   22
        .BYTE   202             ;"MEM RD RQ IN"
        .BYTE   26
        .BYTE   364             ;"CACHE IDLE"
        .BYTE   14              ;SUBTEST 3
        .BYTE   177             ;"MEM RD RQ B","MEM RQ 0,1,2,3"
        .BYTE   15
        .BYTE   15              ;"PAGE REFILL COMP"
        .BYTE   21
        .BYTE   70              ;"READY TO GO"
        .BYTE   25
        .BYTE   72              ;"ADR PMA EN"
        .BYTE   26
        .BYTE   164             ;"EBOX CYC B","CACHE IDLE"
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-33"
        .BYTE   31
        .BYTE   62              ;"EBOX TO"


;SEQ261

        .BYTE   0               ;SUBTEST 4
        .BYTE   20              ;"CORE BUSY"
        .BYTE   2
        .BYTE   204             ;"CSH DATA CLR DONE IN"
        .BYTE   7
        .BYTE   62              ;"MB IN SEL 4","MEM BUSY"
        .BYTE   10
        .BYTE   6               ;"SBUS ADR HOLD","ANY SBUS RQ IN"
        .BYTE   11
        .BYTE   114             ;"CSH VAL SEL ALL","CSH VAL WR DATA"
        .BYTE   12
        .BYTE   54              ;"MBC INH 1ST MB REQ","MEM TO C SEL EN"
        .BYTE   13
        .BYTE   36              ;"CORE RD IN PROG"
        .BYTE   14
        .BYTE   105             ;"MEM RD RQ B","MEM RQ 3","MEM START"
        .BYTE   15
        .BYTE   14              ;"PAGE REFILL COMP","DATA CLR DONE"
        .BYTE   17
        .BYTE   30              ;"FILL CACHE RD"
        .BYTE   21
        .BYTE   71              ;"READY TO GO","CSH USE HOLD"
        .BYTE   22
        .BYTE   202             ;M"MEM RD RQ IN"
        .BYTE   23
        .BYTE   32              ;"ONE WORD RD"
        .BYTE   24              
        .BYTE   320             ;"MEM TO C SEL"
        .BYTE   25
        .BYTE   32              ;"E CORE RD RQ","CSH ADR PMA EN"
        .BYTE   26
        .BYTE   166             ;"EBOX CYC B","CACHE IDLE","MEM TO C SEL 2"
        .EVEN

.SBTTL  REFILL AND PAGED ADDR TEST
.REM    %
        
THIS TEST CHECKS THE GENERATION OF REFILL ADDRESSES AND THE RESULTING
PAGED ADDRESS BY USING A MOVE 17,XXX123 INSTRUCTION.  XXX IS THE
PAGE NUMBER AND IS PICKED UP FROM AN INDEX REGISTER.  REFERENCES ARE
DONE IN EITHER KERNEL (EXEC) OR CONCEALED (USER) MODE DEPENDING
ON THE SUBTEST THE ADDRESS ARE CHECKED BY ENABLING THE EBUS
REGISTER TO BE LOADED FROM THE PMA LINES ON EVERY CLOCK AND READING
THAT REGISTER WITH A DIAGNOSTIC FUNCTION WHEN DESIRED.
THE EXEC AND USER PROCESS TABLES HAVE THE ACCESS, PUBLIC, WRITABLE,
AND SOFTWARE BITS ON AND THE EXEC TRABLE ALSO HAS THE CACHE
BIT ON. FOR NO PATRICULAR REASON.  IF AN ERROR OCCURS, THE TEST SETUP
IS FULLY DESCRIBED IN THE ERROR REPORT.

(THERE ARE 18 PATTERNS USED IN THIS TEST.)
SUBTESTS 1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52

        THESE ARE CHECKING THE ADDRESS TO BE SENT TO MEMORY FOR THE
        REFILL CYCLE.  THE ADDRESS IS CHECKAT AT CSH T2 TIME AND
        IS GENERATED BY THE PMA BOARD.

SUBTESTS 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53
        THESE CHECK FOR REFILL ERROR OR PAGE FAIL AT CSH EBOX T3
        AFTER THE REFILL CYCLE IS COMPLETE.  T HE PAGE FAIL CODE
        IS REPORTED IF AN ERROR OCCURS.  THE PAG BOARD IS THE SUSPECT!

SUBTESTS 3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54
        THESE CHECK AT CSH EBOX T3 FOR THE CORRECT PAGED ADDRESS
        GENERATED BY THE PAG AND PMA BOARDS TOGETHER.
        %
NPAG07: CLR     R5              ;CLEAR REG FOR SUBTEST COUNT
        CLR     R4              ;INITIAL TABLE INDEX
        CLR     VIRSEC          ;VIRTUAL SECTION ZERO
;SUBTEST LOOP
1$:     MOV     TP07T1(R4),R0   ;GET TEST PAGE
        MOV     #CMPN7,R2       ;GET PNTR TO NUMBR OF CHANGES TABLE
        MOV     #CHNG7,R3       ;PNTR TO ACTUAL CHANGES LIST
        JSR     PC,PGTPRM               ;SET MODE SWITCHES
        MOV     #-1,PMAFLG      ;ENABLE PMA TO EBUS REG
        RSTMBX
        JSR     PC,PGSTUP       ;SET UP THE AC CODE
        INSYNC                  ;SUBTEST 1
        STEXCT  JSTF5           ;START JRSTF TO EXEC OR USER
        DFXCTT
          SETRUN                ;SET RUN FLOP
        JSR     R5,FIND         ;FIND "CSH T2 L"


;SEQ263

        .WORD   176             ;FUNCTION TO READ THE MBOX
        .BYTE   01,2            ;BIT FOR "CSH T2 L"
        .WORD   0               ;LOOK FOR TRUE
        JSR     PC,GRFAP1       ;COMPUTE REFILL ADDR
        MOV     #EBUSRG,R0      ;GET A DIAG FUNCTION TO R0
        MOV     #EWORD1,R1      ;AND A PLACE TO STORE SOME DATA
        DFRDMV          ;READ THE DATA
        JSR     R5,$MK36T       ;NOW CHECK TO SEE IF AS EXPECTED
        .WORD   PAMASK          ;MASK
        .WORD   RFAEXP          ;EXPECTED DATA
        .WORD   EWORD1          ;ACTUAL RECEIVED
        BCC     3$
        JSR     PC,PREFTY               ;DESCRIBE CONDITIONS
        FAULT   <BAD PAGE REFILL ADDRESS>
3$:     INSYNC                  ;SUBTEST 2
        JSR     R5,FIND         ;FIND "CSH EBOX T3"
        .WORD   170             ;FUNCTION TO READ THE MBOX
        .BYTE   00,100          ;BIT FOR "CSH EBOX T3"
        .WORD   0               ;LOOK FOR FALSE
        BCS     99$
;       CMP.S   PGERR,3         ;TEST PF HOLD AND REFILL ERR
;NOW CHECK THE CURRENT STAT OF THE MBOX
        MCOMP                   ;MUST MODIFY EXPECTED DATA TABLE AND THEN...
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   0               ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE TABLES
        BCC     4$              ;BR IF OK
        MOV     #EBUSRG,R0      ;GET A DIAG FUNCTION TO R0
        MOV     #EWORD1,R1      ;AND A PLACE TO STORE SOME DATA
        DFRDMV          ;READ THE DATA
        JSR     R5,$MK36T       ;NOW CHECK TO SEE IF AS EXPECTED
        .WORD   PFCMSK          ;MASK
        .WORD   ZERO            ;EXPECTED DATA
        .WORD   EWORD1          ;ACTUAL RECEIVED
        JSR     PC,PREFTY
        FAULT   <REFILL FAILURE, PAGE FAIL CODE ABOVE>
4$:     JSR     PC,PGADC                ;COMPUTE PAGED ADDRESS
        INC     R5              ;SUBTEST 3.
        MOV     #EBUSRG,R0      ;GET A DIAG FUNCTION TO R0
        MOV     #EWORD1,R1      ;AND A PLACE TO STORE SOME DATA
        DFRDMV                  ;READ THE DATA
        JSR     R5,$MK36T       ;NOW CHECK O SEE IF AS EXPECTED

;SEQ264

        .WORD   PAMASK          ;MASK
        .WORD   RFAEXP          ;EXPECTED DATA
        .WORD   EWORD1          ;ACTUAL RECEIVED
        BCC     5$              ;BR IF OK
        JSR     PC,PREFTY       ;TELL HOW
        FAULT   <WRONG PAGED ADDRESS AFTER REFILL>
5$:     ADD     #2,R4           ;INCR INDEX
        CMP     R4,#<2*18.>     ;TEST FOR END
        BLT     6$
        NORMAL
6$:     JMP     1$
99$:    ERROR                   ;STEP10 ERROR, DO RG COMMAN

;SEQ265

;TEST DATA - PAGE NUMBERS
;SOURCE TABLE OF VIRTUALPAGES TO TEST.  BIT 15
;SET MEANS USER MODE TO THE SETUP ROUTINE.
TP07T1: 400                     ;SUBTEST 1,2,3 - KERNEL
        401                     ;SUBTEST 4,5,6 - KERNEL
        402                     ;SUBTEST 7,8,9 - KERNEL 
        404                     ;SUBTEST 10,11,12 - KERNEL
        410                     ;SUBTEST 13,14,15 - KERNEL
        420                     ;SUBTEST 16,17,18 - KERNEL
        440                     ;SUBTEST 19,20,21 - KERNEL
        500                     ;SUBTEST 22,23,24 - KERNEL
        600                     ;SUBTEST 25,26,27 - KERNEL
        777                     ;SUBTEST 28,29,30 - KERNEL
        343                     ;SUBTEST 31,32,33 - KERNEL, UPT REF
        375                     ;SUBTEST 34,35,36 - KERNEL, UPT REF
        100222                  ;SUBTEST 37,38,39 - CONCEALED
        100341                  ;SUBTEST 40,41,42 - CONCEALED
        100777                  ;SUBTEST 43,44,45 - CONCEALED
        140                     ;SUBTEST 46,47,48 - KERNEL
        240                     ;SUBTEST 49,50,51 - KERNEL
        300                     ;SUBTEST 52,53,54 - KERNEL

;EXPECTED REFILL ADDRESSES. WILL HAVE EITHER THE EPT OR
;UPT BASE ADDRESSES ADDED TO THEM.  BIT 15 SET MEANS UPT.
TP07T2: 200                     ;SUBTEST 1
        200                     ;SUBTEST 4
        200                     ;SUBTEST 7
        200                     ;SUBTEST 10
        204                     ;SUBTEST 13
        210                     ;SUBTEST 16
        220                     ;SUBTEST 19
        240                     ;SUBTEST 22
        300                     ;SUBTEST 25
        374                     ;SUBTEST 28
        100400                  ;SUBTEST 31
        100414                  ;SUBTEST 34
        100110                  ;SUBTEST 37
        100160                  ;SUBTEST 40
        100374                  ;SUBTEST 43
        660                     ;SUBTEST 46
        720                     ;SUBTEST 49
        740                     ;SUBTEST 52
;DO A JRSTF TO GET TO USER/EXEC MODE

JSTF5:  I10     JRST 2,1,5

.EVEN
RFAEXP: WD36    0,0,0
PAMASK: WD36    7777,6000,0     ;PAGED ADDRESS MASK


;SEQ266

PFCMSK: WD36    7,7777,7777     ;PAGE FAIL CODE MASK
.EVEN


;SEQ267

;TABLE OF NUMBER OF CHANGES FOR MCOMP ROUTINE
CMPN7:  .BYTE   14              ;SUBTEST 2,5,8,11,14,17,20,23,26,29
        .EVEN

                                ;32,35,39,41,44,47,50,53
;TABLE OF ACTUAL CHANGES FOR TEST
CHNG7:  .BYTE   10              ;SUBTEST 2-53 AS ABOVE
        .BYTE   2               ;"ANY SBUS RQ IN"
        .BYTE   11
        .BYTE   24              ;"B CHANGE COMING"
        .BYTE   12
        .BYTE   24                      ;"PHASE CHANGE COMING"
        .BYTE 15
                
        .BYTE   15                      ;"PAGE REFILL COMP"
        .BYTE   16              
        .BYTE   222                     ;"CSH EBOX T3 L"
        .BYTE   21
        .BYTE   71              ;"READY TO GO","CSH USE HOLD"
        .BYTE   22
        .BYTE   203                     ;"MEM RD RQ IN","RQ 3 IN"
        .BYTE   23
        .BYTE   32              ;"ONE WORD RD"
        .BYTE   24
        .BYTE   320                     ;"M TO C SEL 1"
        .BYTE   25
        .BYTE   32              ;"E CORE RD RQ","ADR PMA EN"
        .BYTE   26      
        .BYTE   166                     ;"EBOX CYC B" "CACHE IDLE","MEM TO C SEL 2"
        .BYTE   27
        .BYTE   53                      ;"MBOX GATE VMA 27-33"
        .EVEN


;SEQ268

;ROUTINE TO FORM EXPECTED PROCESS TABLE ADDRESS
GRFAP1: CLR     RFAEXP+2
        CLRB    RFAEXP+4
        MOV     TP07T2(R4),RFAEXP
        BMI     1$                      ;BR IF USER
2$:     ADD     EPTP,RFAEXP
        RTS     PC
1$:     BIC     #BIT15,RFAEXP   ;CLEAR USER BIT
        ADD     UPTP,RFAEXP     ;ADD UPT BASE ADR
        RTS     PC
;ROUTINE TO CHECK A PAGED ADDRESS
PGADC:  MOV     VIRPAG,R0
        TST     USRMOD
        BNE     2$              ;USER BRANCHES
        CMP     R0,#340
        BGE     11$
        ADD     #1000,R0
        BR      2$
11$:    CMP     R0,#400
        BLT     1$
        SUB     #400,R0
        BR      2$
1$:     ADD     #440,R0
2$::    MOVB    MVADDR,RFAEXP
        MOVB    MVADDR+1,RFAEXP+1
        BICB    #376,RFAEXP+1
        ASL     R0
        BISB    R0,RFAEXP+1
        SWAB    R0
        MOVB    R0,RFAEXP+2
        RTS     PC
;DRIVE TABLE FOR DIAG BIT CHECKS
PGERR:  DF.     177             ;PAGE REFILL ERROR L
        BP.     22
        DF.     174             ;PAGE FAIL HOLD L
        BP.     -23
.EVEN


;SEQ269

.SBTTL  PAGE O.K. LOGIC TEST
.REM    %
THIS TEST TRIES 11 PAGED OPERATIONS WHICH SHOULD NOT CAUSE A PAGE 
FAIL.  IT IS TESTING THE PAGE O.K. - PAGE FAIL LOGIC ON THE PAG BOARD
AND THE EBOX SIGNALS WHICH FEED TO IT.  EACH TEST IS PRECEDED BY A
CONO PAG SO A REFILL CYCLE WILL OCCUR.  OIN THE EVENT OF AN ERROR
THE TEST CONDITIONS ARE DESCRIBED IN THE TYPEOUT.
ALL THE PAGES USED WERE REFERENCED FOR READ3 IN TEST T.P06
SUBTEST:        1,3,5,7,9,11,13,15,17,19,21
        THESE CHECK AT REFILL T4 TO MAKE SURE A REFILL WAS STARTED.
SUBTEST 2,4,6,8,10,12,14,16,18,20,22
        THESE CHECK AT CSH EBOX T3 AFTER THE REFILL TO MAKE SURE
        NO PAGE FAIL HAS HAPPENED.
        %
NPAG08: CLR     R5              ;CLEAR A REG FOR SUBTEST COUNT
        CLR     R4              ;START TABLE INDEX
        MOV     #CMPN8,NMLOC8   ;GET PNTR TO NUMBER OF CHANGES TABLE
        MOV     #CHNG8,NMCH8    ;GET PNTR TO ACTUAL CHANGES
1$:     MOV     TP08T1(R4),R0   ;GET SUBTEST TABLE ENTRY
        MOV     NMLOC8,R2       ;GET CURRENT PNTR TO NUM OF CHNGES
        MOV     NMCH8,R3                ;GET CURRENT PNTR TO ACTUAL CHANGES
        JSR     PC,PGTPRM               ;SET UP MODE SWITCHES
        ADD     #20,R0          ;ADD ACCESS BIT
        MOV     R0,EAPWSC
        MOV     R0,UAPWSC
        RSTMBX
        JSR     PC,WREPT                ;DO AN EXEC UPT
        JSR     PC,WRUPT                ;MAKE A USER PT
        JSR     PC,PGSTUP               ;SET UP THE TEST CODE
        INSYNC                  ;SUBTEST 1.
        STEXCT  JSTF5           ;JRSTF TO USER OR EXEC MODE
        DFXCTT
          SETRUN

;SEQ270


        JSR     R5,FIND         ;FIND 'CSH EBOX T3"
        .WORD   170             ;FUNCTION TO READ THE MBOX
        .BYTE   00,100          ;BIT FOR 'CSH EBOX T3"
        .WORD   0               ;LOOK FOR FALSE
        DFSCLK
;       TENBIT  176,29          ;TEST PAGE REFILL T4
;NOW CHECK THE CURRENT STATE OF THE MBOX
        MCOMP           ;MODIFY EXPECTED DATA
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHECK STATUS
        .WORD   MBXMSK          ;PNTR TO MASK TABLE
        .WORD   MBXDF           ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   0               ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE TABLES
        BR      2$              ;BR IF OK
        JSR     PC,PREFTY       ;DESCRIBE SETUP
        FAULT
2$:     INSYNC                  ;SUBTEST 2.
        JSR     R5,FIND         ;FINED "CSH EBOX T3"
        .WORD   170             ;FUNCTION TO READ THE MBOX
        .BYTE   00,100          ;BIT FOR "CSH EBOX T3"
        .WORD   0               ;LOOK FOR FALSE
        BCS     99$             ;TROUBLE
;       CMP.S   PGERR,3         ;TEST REFILL ERR, PAGE FAIL


;SEQ271

;NOW CHECK THE CURRENT STATE OF THE MBOX
        MCOMP                   ;MODIFY EXPECTED DATA
        JSR     R5,$DCOMP       ;GO TO ROUTINE TO CHEK STATUS
        .WORD   MBXMSK          ;PNTR OT MASK TABLE
        .WORD   MBXDF                   ;PNTR TO DIAG FUNCTION TABLE
        .WORD   MBXBP           ;PNTR TO "BIT PNTR" TABLE
        .WORD   MBXEXP          ;PNTR TO EXPECTED MBOX STATE
        .WORD   0               ;PNTR TO APPROPRIATE ERR MESSAGE
        RCOMP                   ;RESTORE TABLES
        BR      6$
        JSR     PC,PREFTY               ;DESCRIBE SETUP
        FAULT   <AT EBOX T3 AFTER REFILL>
6$:     ADD     #2,R4
        CMP     R4,#<2*11.>
        BNE     7$
        NORMAL
7$:     CMP     #^D12,R5        ;SEE IF TIME TO CHANGE MCOMP PNTRS
        BGT     8$
;IF HERE MUST UPDATE PNTRS FOR MCOMP ROUTINE
        MOV     #CMP8A,NMLOC8   ;CHANGE NUMBER OF CHANGES
        MOV     #CHNG8A,NMCH8   ;CHANGE EXPECTED DATA PNTR
8$:     JMP     1$              ;DO ANOTHER SUBTEST
99$:    ERROR                   ;DO RG PRINT
NMLOC8: .WORD   0               ;PLACE TO HOLD MCOMP PNTRS
NMCH8:  .WORD   0               ;PLACE TO HOLD MCOPM PNTRS
;DRIVE TABLE FOR THE TEST.  RIGHT 3 DIGITS ARE THE PAGE NUMBER,
;OTHER BITS DESCRIBE TEST SETUP GIVEN IN COMMENTS.
;               MODE    OPER    PAGE TABLE PRIV.


;SEQ272

TP08T1: 410             ;KERNEL         READ    A ;ST 1,2
        300             ;KERNEL         READ    A ;ST 3,4
        100341          ;CONCEALED      READ    A ;ST 5,6
        20600           ;SUPERVIOSR     READ    A ;ST 7,8
        30343           ;SUPERVISOR     READ    A ;ST 9,10

        130777          ;PUBLIC         READ    A,P     ;ST 11,12
        4400            ;KERNEL         WRITE   A,W ;ST 13,14
        4140            ;KERNEL         WRITE   A,W ;ST 15,16
        104222          ;CONCEALED      WRITE   A,W ;ST 17,18
        34777           ;SUPERVISOR     WRITE   A,P,W ;ST 19,20
        134341          ;PUBLIC WRITEA,P,W ;ST 21,22

;TABLE OF MCOMP NUMBER OF CHANGES
CMPN8:  .BYTE   6               ;SUBTEST 1,3,5,7,9,11
        .BYTE   12              ;ST 2,4,6,8,10,12
CMP8A:  .BYTE   12              ;ST 13,15,17,19,21
        .BYTE   13              ;ST 14,16,18,19,20,22


;SEQ273

;ACTUAL CHANGES TABLES
CHNG8:  .BYTE   21              ;SUBTERST 1,3,5,7,9,11
        .BYTE   73              ;"CSH USE HOLD"
        .BYTE   22
        .BYTE   300             ;"CSH EBOX REQ EN"
        .BYTE   25
        .BYTE   72              ;"CSH ADR PMA EN"
        .BYTE   26
        .BYTE   64              ;"CSH EBOX CYC B"
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-33"
        .BYTE   32
        .BYTE   265             ;"PAGE REFILL T4"
        .BYTE   10              ;SUBTEST 2,4,6,8,10,12
        .BYTE   2               ;"ANY SBUS RQ IN"
        .BYTE   15
        .BYTE   15              ;"PAGE REFILL COMP"
        .BYTE   16
        .BYTE   222             ;"CSH EBOX T3"
        .BYTE   21      
        .BYTE   71              ;"READY TO GO" "USE HOLD"
        .BYTE   22
        .BYTE   202             ;"MEM RD RQ IN"
        .BYTE   23
        .BYTE   32              ;"ONE WORD RD"
        .BYTE   24
        .BYTE   320             ;"MEM TO C SEL 1"
        .BYTE   25
        .BYTE   32              ;"E CORE RD RQ","ADR PMA EN"
        .BYTE   26
        .BYTE   166             ;"EBOX CYC B","CACHE IDLE","MEM TO C SEL 2"
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-33"


;SEQ274

CHNG8A:         .BYTE   0               ;SUBTEST 13,15,17,19,21
        .BYTE   2               ;"MB PAR BIT IN"
        .BYTE   4
        .BYTE   77              ;"MB IN SEL 2"
        .BYTE   21
        .BYTE   73              ;"CSH USE HOLD"
        .BYTE   22
        .BYTE   300             ;"CSH EBOX REQ EN'
        .BYTE   24
        .BYTE   320             ;"MEM TO C SEL 1"
        .BYTE   25
        .BYTE   72              ;"CSH ADR PMA EN"
        .BYTE   26
        .BYTE   64              ;'CSH EBOX CYC B"
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-33"
        .BYTE   31
        .BYTE   73              ;"E CACHE WR CYC"
        .BYTE   32
        .BYTE   265             ;"PAG REFILL T4"
        .BYTE   0               ;ST 14,16,18,20,22
        .BYTE   2               ;"MB PAR BIT IN"
        .BYTE   4
        .BYTE   77              ;"MB IN SEL 2"
        .BYTE   15
        .BYTE   15              ;"PAGE REFILL COMP"
        .BYTE   16
        .BYTE   222             ;"EBOX T3"
        .BYTE   21
        .BYTE   71              ;"READY TO GO","CSH USE HOLD"
        .BYTE   24
        .BYTE   320             ;"MEM TO C SEL 1"
        .BYTE   25
        .BYTE   72              ;'CSH ADR PMA EN"
        .BYTE   26
        .BYTE   164             ;"EBOX CVYC B","CACHE IDLE'
        .BYTE   27
        .BYTE   53              ;"MBOX GATE VMA 27-33"
        .BYTE   30
        .BYTE   245             ;"ONE WORD WR TC"
        .BYTE   31
        .BYTE   73              ;"E CACHE WR CYC"
        .EVEN


;SEQ275

.SBTTL  PAGE TEST SUBROUTINES
;ERROR THING WHICH TRIES TO DESCRIBE WHAT WAS BEING
;ATTEMPTED WHEN AN ERROR OCCURRED IN PAGING TESTS
PREFTY: MOV     #PREFTT,R0
        TST     USRMOD
        BEQ     21$
        ADD     #4,R0
21$:    TST     PUBMOD
        BEQ     3$
        ADD     #2,R0
        
3$:     MOV     (R0),R0
        JSR     PC,(R0)         ;GO TYPE ERR MSG
4$:     ERRMSG  < MODE >
        TST     PGWRIT
        BNE     5$
        ERRMSG  <READ FROM>
        BR      6$
5$:     ERRMSG  <WRITE TO>
6$:     ERRMSG  < PAGE >
        MOV     VIRPAG,R0
        ERROCS
        ERCRLF
        ERRMSG  <EPT: >
        MOV     EPTP,R0
        ERROCS
        ERRMSG  <	UPT: >


;SEQ276

        MOV     UPTP,R0
        ERROCS
        ERCRLF
        ERRMSG  <EAPWSC: >
        MOV     EAPWSC,R0
        ERROCS
        ERRMSG  <	UAPWSC: >
        MOV     UAPWSC,R0
        ERROCS
        ERCRLF
        RTS     PC
        
PREFTT: .WORD   1$,2$,3$,4$
1$:     ERRMSG<KERNAL>
        RTS     PC
2$:     ERRMSG<SUPVSR>
        RTS     PC
3$:     ERRMSG<CONCLD>
        RTS     PC
4$:     ERRMSG<PUBLIC>



;SEQ277

        RTS     PC
.EVEN


;SEQ278

;ROUTINE TO SET UP MODE FLAGS BY PARSING A TABLE ENTRY PASSED 
;IN RO.  R9 IS RETURNED WITH THE PAGE TABLE ACCESS BITS RIGHT
;ADJUSTED.
PGTPRM: CLR     USRMOD          ;CLEAR FLAGS - USER
        CLR     PUBMOD          ;PUBLIC
        CLR     PGWRIT          ;WRITE OPERATION
        CLR     NOACCS          ;NO ACCESS
        TST     R0
        BPL     1$              ;EXEC MODE
        MOV     R0,USRMOD               ;SET USER FLAG
1$:     BIT     #BIT14,R0
        BEQ     2$              ;WANT VALID ENTRY OR DON'T CARE
        MOV     R0,NOACCS       ;NO ACCESS WANTED
2$:     BIT     #BIT13,R0

        BEQ     3$              ;KERNAL OR CONCEALED
        MOV     R0,PUBMOD               ;SUPERVISOR OR PUBLIC
3$:     BIT     #BIT11,R0
        BEQ     4$              ;DOING A READ
        MOV     R0,PGWRIT       ;DOING A WRITE
4$:     MOV     R0,VIRPAG
        BIC     #177000,VIRPAG  ;SAVE VIRTUAL PAGE
        SWAB    R0
        ASR     R0
        BIC     #177760,R0      ;SAVE APWSO BITS
        RTS     PC


;SEQ279

;ROUTINE TO SET UP THE PROCESSOR FOR PAGING TESTS.  DOES
;INITIALIZATION FOR DESIRED MODE AND ALSO LOADS INSTRUCTIONS
;TO BE EXECUTED DURING TEST.  AC5 IS A PC WORD THAT POINTS
;AT THE PAGE REFERENCE CAUSING INSTRUCTION
PGSTUP: MOV     EPTP,R0         ;GET EPT ADDRESS
        SWAB    R0
        ASR     R0              ;DIV BY 1000
        MOVB    R0,CNEPT                ;STUF INTO CONO
        BICB    #100,CNEPT+1    ;CLR SECTION MODE
        BICB    #3,CNEPT+2      ;CLEAR CACHE LOOK N LOA
        TST     PORTLF
        BEQ     11$
        MOVB    #14,PCWORD
        BR      1$
11$:    MOVB    #10,PCWORD      ;POINT AT MOVE INSTR
        TST     SECMOD          ;WANT SECTIO?
        BEQ     1$              ;BR IF NOT
        BISB    #100,CNEPT+1    ;SET SECTION MODE IN CONO
        MOVB    #12,PCWORD      ;AND PNT TO SXCT (MOVE)
1$:     MOV     UPTP,R0         ;GET UPT ADDR
        SWAB    R0
        ASR     R0              ;DIV BY 1000
        MOVB    R0,UBRDAT       ;PUT IN DATA0 DATA
        BICB    #120,PCWORD+3   ;CLR USER, PUBLIC BIT
        TST     USRMOD
        BEQ     2$              ;BR IF NOT USER
        BISB    #100,PCWORD+3   ;SET USER BIT
2$:     TST     PUBMOD
        BEQ     21$
        BISB    #20,PCWORD+3
        
21$:    CLRB    MVADDR+2
        BICB    #376,MVADDR+1   ;TO BE REFERENCED
        MOV     VIRSEC,R0
        SWAB    R0
        ASL     R0
        BIS     VIRPAG,R0
        ASL     R0
        BISB    R0,MVADDR+1
        SWAB    R0
        BISB    R0,MVADDR+2
        TST     PGWRIT          ;READ OR WRITE?
        BEQ     3$              ;READ
        BISB    #BIT0,PCWORD    ;ODD POINTS TO MOVEM OR SXCT[MOVEM]
        
3$:     LOAD    1,LPGSU,12.
        RUN     1
        RTS     PC


;SEQ280

        ;AC STUFF
LPGSU:  IO10    DATAO PAG,,4
CNEPT:  IO10    CONO PAG,,20000
        I10     JRST 0,,3
UBRDAT: WD36            1000,40,0
PCWORD: WD36    0,0,10
MVADDR: WD36    0,0,123
        WD36    0,0,0           ;NOT USED
        I10     MOVE    17,,,6
        I10     MOVEM   17,,,6
        I10     SXCT    0,,10
        I10     SXCT    0,,11
        I10     JRST    0,,340100       ;MAPS TO 1100
SXCT=   0106
.EVEN


;SEQ281

;BUILD AN EXEC PROCESS TABLE IN CORE
WREPT:  MOV     EAPWSC,R0       ;GET ACCESS CONTROL BITS
        SWAB    R0
        ASR     R0
        MOVB    R0,WREPDT+3
        SWAB    R0
        MOVB    R0,WREPDT+4
        SWAB    R0
        ASR     R0
        ASR     R0
        MOVB    R0,WREPDT+1
        SWAB    R0
        MOVB    R0,WREPDT+2
        MOV     EPTP,R0         ;GET PROC TABLE BASE ADR
        ADD     #200,R0
        MOVB    R0,WREADR
        SWAB    R0
        MOVB    R0,WREADR+1
        LOAD    1,WRERTN,9.
        RUNBIG  1,2             ;RUN PROGRAM
        RTS     PC


;SEQ282

WRERTN: I10     MOVEM 6,,,7
        I10     ADD     6,,11
        I10     AOS 0,,7
        I10     SOJG 10,,1
        I10     JRST 4,,5
WREPDT: WD36    0,0,1
WREADR: WD36    0,0,0
        WD36    0,0,560
        WD36    0,200,2
.EVEN


;SEQ283

;BUILD A USER PROCESS TABLE IN CORE
WRUPT:  MOV     UAPWSC,R0       ;GET ACCESS CONTROL BITS
        SWAB    R0
        ASR     R0
        MOVB    R0,WRUPDT+3
        SWAB    R0
        MOVB    R0,WRUPDT+4
        SWAB    R0
        ASR     R0
        ASR     R0
        MOVB    R0,WRUPDT+1
        SWAB    R0
        MOVB    R0,WRUPDT+2
        MOV     UPTP,R0 ;GET PROC TABLE BASE ADR
        MOVB    R0,WRUADR
        SWAB    R0
        MOVB    R0,WRUADR+1
        LOAD    1,WRURTN,9.
        RUNBIG  1,2
        RTS     PC


;SEQ284

WRURTN: I10     MOVEM 6,,,7
        I10     ADD 6,,11
        I10     AOS 0,,7
        I10     SOJG 10,,1
        I10     JRST 4,,5
WRUPDT: WD36    0,0,1
WRUADR: WD36    0,0,0
        WD36    0,0,420
        WD36    0,200,2
.EVEN


;SEQ285

PHYSEC: .WORD   0               ;SECTION NBR
XMHOLD: .WORD   -1              ;TRWEMP FOR WEX10
        CPATTN: .WORD   0
        CERCNT: .WORD   0
        CACHEN: .WORD   0
        NOACCS: 0                       ;REMEMBER NO PAGE TABLE ACCESS BIT
$PATAD: .WORD   0
SECMOD: .WORD   0               ;SECTION MODE FLAG, RESET
        EPTP:   .WORD   1000            ;EXEC PROCESS TABLE PTR
        UPTP:   .WORD   1000    ;USER PROCESS TABLE POINTER
EAPWSC: .WORD   37              ;EXEC ACCESS CONTROL BITS
UAPWSC: .WORD   36              ;USER ACCESS CONTROL BITS
        VIRPAG: .WORD   0               ;VIRTUAL PAGE IN USE
        VIRSEC: .WORD   0               ;VIERRUAL  SECTION IN USE
        PUBMOD: .WORD   0               ;PUBLIC MODE, FALSE
USRMOD: .WORD   0               ;USER MODE, RESET
        PGWRIT: .WORD   0               ;READ/WRITE FLAG, READ
PORTLF: .WORD   0               ;PORTAL TEST FLAG, FALES

;SEQ286

;WORD TRANSFER ROUTINE
WORDXF: MOV     #5,R1           ;LOOP COUNT
1$:     MOVB    (R0)+,(R2)+
        DEC     R1
        BGT     1$
        RTS     PC
;WRITE EVERY FOURTH WORD OF A PAGE
CSHWRD: MOV     (R5)+,R0        ;GET DATA PTE
        MOV     #CSWDAT,R1
1$:     MOVB    (R0)+,(R1)+     ;MOVE DATA
        CMP     R1,#CSWDAT+5
        BNE     1$
        MOV     (R5)+,R0        ;GET PAGE NBR
        SWAB    R0
        ASL     R0
        CLRB    R0
        BIS     (R5)+,R0        ;GET WORD IN THERE
        MOV     R0,CSWMOV
        LOAD    1,CSWMOV,6
        RUN     1
        BCC     2$
        ERROR   <PRGM HUNG?>
2$:     RTS     R5              ;OK,RETURN
CSWMOV: I10     MOVEM   5,,0
        I10     ADDI    1,,4
        I10     SOJG    6,,1
        I10     JRST    4,,4
CSWDAT: WD36    0,0,0
        WD36    0,0,200

;SEQ287

;WRITE ONE PAGE TO CACHE (OR MEM)
CSHPAG: MOV     (R5)+,R0        ;GET DATA PTR
        MOV     #CPGDAT,R1
1$:     MOVB    (R0)+,(R1)+
        CMP     R1,#CPGDAT+5
        BNE     1$
        MOV     (R5)+,R0        ;GET PHYS PAGE
        ASL     R0
        MOVB    R0,CPGADR+1
        SWAB    R0
        MOVB    R0,CPGADR+2
        LOAD    1,CPGCOD,8.
        RUN     1
        BCC     2$              
        ERROR   <PRGM HUNG?>
2$:     RTS     R5
CPGCOD: I10     SXCT    0,,5
        I10     AOS     0,,6
        I10     SOJG    10,,1
        I10     JRST    4,,1
        I10     MOVEM   7,,0,6
CPGADR: WD36    0,0,0
CPGDAT: WD36    0,0,0
        WD36    0,0,1000
.EVEN


;SEQ288

MASKP1: .BYTE   0               ;USED FOR STATUS BITS
        .BYTE   301             ;163    26-34
        .WORD   1743            ;160    20-35   PAG MB 18-35 PAR H
                                ;AND FORCE VALID MATCH 0,1,2,3
        .BYTE   346             ;160    12-19  MB PAR BIT IN
        .BYTE   1               ;164    26-34
        .WORD   21003           ;161    20-35   MBOX NXM ERR. CSH PAR BIT A
        .BYTE   376             ;161    12-19   MBOX ADR PAR ERR
                                ;CBUS PAR LEFT TE, MEM PAR IN,CSH PAR BIT
        .BYTE   341             ;165    26-34   CAM SEL 1,2
        .WORD   7013            ;162 20-35 MBOX MB PAR ERR
                                ;PAG MB 00-17 PAR, CSH PAR BIT B
        .BYTE   354             ;162 12-19 CBUS PAR RIGHT TE
                                ;CSH PAR BIT IN
        .BYTE   1               ;166    26-34
        .WORD   140000          ;170    20-35
        .WORD   140000          ;171    20-35
        .WORD   142000          ;172    20-35
        .WORD   142000          ;173    20-35
        .WORD   142020          ;174            20-35
        .WORD   142020          ;175    20-35
        .WORD   142010          ;176    20-35
        .WORD   142000          ;177    20-35


;SEQ289

.SBTTL DATA COMPARE:  MASTER DIAGNOSTIC FUNCTION TABLE
;MASTER MBOX DIAGNOSTIC FUNCTION TABLE FOR
;DCOMP CALLS
MBXDF:  .BYTE   160             ;+0
        .BYTE   160             ;+1
        .BYTE   160             ;+2
        .BYTE   161             ;+3
        .BYTE   161             ;+4
        .BYTE   161             ;+5
        .BYTE   162             ;+6
        .BYTE   162             ;+7
        .BYTE   162             ;+10
        .BYTE   163             ;+11
        .BYTE   164             ;+12
        .BYTE   165             ;+13
        .BYTE   166             ;+14
        .BYTE   170             ;+15
        .BYTE   170             ;+16
        .BYTE   171             ;+17
        .BYTE   171             ;+20
        .BYTE   172             ;+21
        .BYTE   172             ;+22
        .BYTE   173             ;+23
        .BYTE   173             ;+24
        .BYTE   174             ;+25
        .BYTE   174             ;+26
        .BYTE   175             ;+27
        .BYTE   175             ;+30
        .BYTE   176             ;+31
        .BYTE   176             ;+32
        .BYTE   177             ;+33
        .BYTE   177!BIT7        ;+34


;SEQ290

.SBTTL DATA COMPARE:    MASTER BYTE POINTER TABLE
;MASTER MBOX BYTE POINTER TABLE FOR DCOMP CALLS
MBXBP:  BYTPNT  19              ;+0
        BYTPNT  25              ;+1
        BYTPNT  33              ;+2
        BYTPNT  19              ;+3
        BYTPNT  25              ;+4
        BYTPNT  33              ;+5
        BYTPNT  19              ;+6
        BYTPNT  25              ;+7
        BYTPNT  33              ;+10
        BYTPNT  33              ;+11
        BYTPNT  33              ;+12
        BYTPNT  33              ;+13
        BYTPNT  33              ;+14
        BYTPNT  27              ;+15
        BYTPNT  35              ;+16
        BYTPNT  27              ;+17
        BYTPNT  35              ;+20
        BYTPNT  27              ;+21
        BYTPNT  35              ;+22
        BYTPNT  27              ;+23
        BYTPNT  35              ;+24
        BYTPNT  27              ;+25
        BYTPNT  35              ;+26
        BYTPNT  27              ;+27
        BYTPNT  35              ;+30
        BYTPNT  27              ;+31


;SEQ291

        BYTPNT  35              ;+32
        BYTPNT  27              ;+33
        BYTPNT  35              ;+34


;SEQ292

.SBTTL DATA COMPARE:    MASTER BYTE MASK TABLE
;MASTER MBOX MASK TABLE FOR MASKING MEANING LESS OR 
;RANDOM STATE SIGNALS FROM OUR DCOMP DATA COMPARE
MBXMSK:
;"CORE BUSY" "CHAN PAR ERR L","SH AR PAR ODD A","MB PAR BIT IN","CSH EN CSH DATA L"
        .BYTE   354             ;+0-FR160       ;12-19
;"MB IN SEL 1","NXM ACKN","CHAN COR BUSY","NXM ANY L","NXM 6,7 L","CHAN NXM ERR L"
        .BYTE   311             ;+1-FR160       ;18-25
;"PAG MB 18-35 PAR","FORCE VALID MATCH 0","FORCE VALID MATCH1","FORCE VALID MATCH 2"
;"FORCE VALID MATCH 3","WRITE OK","CSH ADR WR PULSE","CSH DATA CLR DONE IN L"
        .BYTE   200             ;+2-FR160       ;26-33
;"MBOX ADR PAR ERR L","CBUS PAR LEFT TE","MEM PAR IN","CSH PAR BIT","MEM TO C DIAG EN L"
        .BYTE   350             ;+3-FR161       ;12-19
;"MB IN SEL 2","MBZ1 RD-PSE-WR REF L","MBOX NXM ERR L","CHAN MEM REF L","MBOX SBUS ERR L
        .BYTE   300             ;+4-FR161       ;18-25
;"CSH PAR BIT A","CSH DATA CLR T1 L","CSH DATA CLR T2 L","CSH DATA CLR T3 L","CSH SEL LR
;"CSH VAL WR PUSLE","CSH WR WR PULSE","RQ HOLD FF"
        .BYTE   0               ;+5-FR161       ;26-33
;"CHAN ADR PAR ERR L","CBUS PAR RIGHT TE","CSH PAR BIT IN","CHAN READ L"
        .BYTE   373             ;+6-FR162       ;12-19
;MB IN SEL 4","MEM BUSY ","HOLD ERR L","NXM T2","M,BOX MB PAR ERR L","PAG MB 00-17 PAR"
        .BYTE   301             ;+7-FR162       ;18-25
;"CSH PAR BIT B","CACHE WR 00 A","CACHE WR 09 A","CACHE WR 18 A","CACHE WR 27 A"
;"SBUS ADR HOLD","A CHANGE COMING A L","ANY SBUS RQ IN L"
        .BYTE   2               ;+10-FR162      ;26-33
;"B CHANGE COMING L","CORE BUSY A"," CSH VAL SEL ALL","CSH VAL WR DATA","CSH WR SEL ALL"
        
;"CSH WR WR DATA","DATA VALID A OUT"
        .BYTE   300             ;+11-FR163      ;26-33
;"DATA VALID B OUT","MBC INH 1ST MB REQ","MEM TO C EN L","PHASE CHANGE COMING L"
;"ACKN PULSE L","CORE ADR 34","CORE ADR 35"
        .BYTE   213             ;+12-FR164      ;26-33
;XXXX,XXXX","CORE DATA VALID -1 L","CORE DATA VALID -2L","CORE DATA VALID L"
;"CORE RD IN PROG", XXXX
        .BYTE   341             ;+13-FR166      ;26-33
;"MEM RD RQ B","MEM RQ 0","MEM RQ 1","MEM RQ 2", "MEM RQ3",",MEM START L"
;"MEM WR RQ L"
        .BYTE   200             ;+14-FR166              ;26-33
;XXXX,XXXX,"PAGE REFILL COMP L","CACHE WR IN","MBOX PT DIR WR L"
;"CSH WR TEST L",XXXX,"CSH DATA CLR DONE L"
        .BYTE   202             ;+15-FR170      ;20-27


;SEQ293


;"CSH REFILL RAM WR L","CSH EBOX T3 L","CACHE BIT","CCA REQ L","CSH WR WD 2 EN","MB REQ
;"MBX MEM TO C EN L","RQ 1 IN"
        .BYTE   41              ;+16-FR170      ;28-35
;XXXX,XXXX,XXXX,"CSH WR DATA RDY L","PAGE FAIL T2 L","CSH EBOX LOAD REG"
;"CSH FILL CACHE RD L,XXXX "
        .BYTE   341             ;+17-FR171      ;20-27
;"MB WR RQ CLR NXT L","CSH EBOX T1 L","CACHE TO MB 34",XXXX,"CSH WR WD 3 EN"
;"MB SEL 1","MEM DIAG L,","RQ 2 IN"
        .BYTE   21              ;+20-FR171      ;28-35
;XXXX,XXXX,"CHAN WR CACHE L","CCA CYC DONEL","CHAN T4 L",XXXX
;READY TO GO A","CSH USE HOLD"
        .BYTE   304             ;+21-FR172      ;20-27
;"CSH CCA CYC L","CSH EBOX REQ EN L","CACHE TO MB 35",XXXX,"FORCE NO MATCH"
;"MB SEL 2","MEM RD RQ IN","R2 3 IN"
        .BYTE   31              ;+22-FR172      ;28-35
;XXXX,XXXX,"ONE WORD RD L","MBOX RESP L","RD PSE 2ND REQ EN L"
;XXXX,"CSH T1 L","WRITE BACK T1 A"
        .BYTE   304             ;+23-FR173      ;20-27
;"CSH CCA WRITEBACK L","CSH EBOX T2 L","CACHE TO MB DONE","CHAN WR CYCL","MEM DATA TO M
;"MB SEL HOLD","MEM TO C SEL 1","SBUS ADR 34"
        .BYTE   1               ;+24-FR173      ;28-35
;XXXX,XXXX,"E CORE RD RQ L","PAGE FAIL HOLD L","PAGE REFILL T9,13 L"
;XXXX,"CSH TO L","CSH ADR PMA EN"
        .BYTE   304             ;+25-FR174      ;20-27
;"CSH EBOX CYC B L","CACHE IDLE","CACHE TO MB T2 L","CSH CCA INVAL CSH","MB DATA CODE 1"
;"MBO HOLD IN","MEM TO C SEL 2","SBUS ADR 35"
        .BYTE   31              ;+26-FR174      ;28-35
;XXXX,XXXX,"CSH EBOX RETRY REQ L","CSH USE WR EN"
;"MB TEST PAR A IN L",XXXX,"CSH T3 L","MBOX GATE VMA 27-33"
        .BYTE   304             ;+27-FR175      ;20-27
;"CSH MB CYC L","ONE WORD WR TO L","CACHE TO MB T3 L","CSH CCA VAL CORE","MB DATA CODE 2
;"MB1 HOLD IN","MEM WR RQ IN","SBUS DIAG 3 L"
        .BYTE   30              ;+30-FR175      ;28-35
;XXXX,XXXX,"CCA INVAAL T4 L","PAGE REFILL T8 L","CSH EBOX TO L"
;XXXX,"CSH T2 L","E CACHE WR CYC"
        .BYTE   304             ;+31-FR176      ;20-27
;"CSH E WRITEBACK L","PAGE REFILL T4 L","CACHE TO MB T4 AL","CSH WR WD 0 EN"
;"MB PAR","MB2 HOLD IN","REFILL HOLD,","SBUS DIAG CYC L"
        .BYTE   0               ;+32-FR176      ;28-35
;XXXX,XXXX,"PAGE REFILL ERROR L","DATA DLY 1 L","P[AGE FAIL DIV"


;SEQ294

;XXXX,"PAGE REFILL T10 L"
        .BYTE   305             ;+33-FR177      ;28-35
;"RD PAUSE 2ND HALF","CSH EOX WR T4 L","CCA ALL PAGES CYC","CSH WR W 1 EN","MB REQ HOL
;"MB3 HOLD IN","RQ 0 IN","WRITEBACK T2 L"
        .BYTE   2               ;+34-FR177      ;28-35



;SEQ295

.SBTTL DATA COMPARE:    MASTER EXPECTED DATA TABLE
;MASTER MBOX EXPECTD DATA TABLE.  THIS TABLE IS THE EXPECTED
;STATE OF THE MBOX AFTER A RESET OF THE MBOX VIA THE
;PDP11 ROUTINE "RSTMBX"
MBXEXP: .BYTE   0               ;+0
        .BYTE   6               ;+1
        .BYTE   205             ;+2
        .BYTE   21              ;+3
        .BYTE   37              ;+4
        .BYTE   160             ;+5
        .BYTE   0               ;+6
        .BYTE   2               ;+7
        .BYTE   3               ;+10-
        .BYTE   124             ;+11
        .BYTE   34              ;+12
        .BYTE   34              ;+13
        .BYTE   3               ;+14
        .BYTE   55              ;+15
        .BYTE   322             ;+16
        .BYTE   73              ;+17
        .BYTE   302             ;+20
        .BYTE   72              ;+21
        .BYTE   200             ;+22
        .BYTE   72              ;+23
        .BYTE   322             ;+24
        .BYTE   73              ;+25
        .BYTE   264             ;+26
        .BYTE   52              ;+27
        .BYTE   345             ;+30
        .BYTE   72              ;+31
        .BYTE   365             ;+33
        .BYTE   62              ;+33
        .BYTE   305             ;+34
        .EVEN           ;********KEEP BYTE BOUNDARIES CLEAN



;SEQ296


.SBTTL *PAGSUB* PAGING DIAGNOSTIC SUBROUTINES
;*****A RETURN INSTRUCTION.. USED BY UNIMPLEMENTED TRAPS
NOTRAP: RTS     R5
;**********
.SBTTL  SUBROUTINES TO MANIPULATE 36-BIT WORDS IN 11 CORE
.REM    %
CLRWRD & CLRBUF -- SUBROUTINES TO CLEAR A 36-BIT WORD IN 11 CORE MEMORY
        CALL:   JSR     R5,$CLRWD
        .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
%
$CLRBF: MOV     #EWORD1,R0              ;ALTERNATE ENTRY FOR EWORD1
        BR      CLRW1
$CLRWD: MOV     (R5)+,R0
CLRW1:  .REPT   5
        CLRB    (R0)+
        .ENDR
        RTS     R5
.REM    %
SETWRD & SETBUF -- SUBROUTINES TO SET BITS IN A 36-BIT WORD IN 11 CORE
        CALL:   JSR     R5,$SETWD
        .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
%
$SETBF: MOV     #EWORD1,R0              ;ALTRNATE ENTRY
        BR      SETW1
$SETWD: MOV     (R5)+,R0        ;PICK UP AN ARGUMENT
SETW1:  .REPT   4
        MOVB    #377,(R0)+
        .ENDR
        MOVB    #17,(R0)+       ;ONLY 1ST FOUR BITS OF LAST BYTE
        RTS     R5


;SEQ297

.REM    %
ROLWRD & ROLBUF -- SUBROUTINES TO ROTATE LEFT A 36-BIT WORD (INV BYTE FORMAT) IN 11 CORE
        CALL:   JSR     R5,$ROLWD
        .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
%
$ROLBF: MOV     #EWORD1,R0      ;ALTERNATE ENTRY FOR EWORD1
        BR      ROLW1
$ROLWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
        
ROLW1:  PUSH    R1              ;GET A REGISTER
        MOV     #4,R1           ;LOOP COUNT = 4
        ASLB    (R0)+           ;SHIFT 1ST BYTE (SETS/CLEARS C)
        
1$:     ROLB    (R0)+           ;ROTATE NEXT BYTE (INCLUDING C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;LOOP TIL DONE
        BITB    #BIT4, -(R0)    ;DID A 1 SHIFT OUT OF SHORT BYTE?
        BEQ     2$              ;NO, SKIP
        SEC                     ;YES, SET CARRY
        ADCB    -4(R0)          ;SET LSB OF 1ST BYTE
2$:     POP     R1              ;DONE, RESTORE REG
        RTS     R5              ;RETURN
.REM    %
RORWRD & RORBUF -- SUBROUTINES TO ROTATE RIGHT A 36-BIT WORD (INV BYTE FORMAT) IN 11 COR
        CALL:   JSR     R5,$RORWD
        .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
%
$RORBF: MOV     #EWORD1,R0              ;ALT ENTRY FOR EWORD1
        BR      RORW1
$RORWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
RORW1:  PUSH    R1              ;GET A REGISTER
        MOV     #4,R1           ;LOOP 4 TIMES
        ADD     R1,R0           ;POINT AT LAST BYTE
        ASRB    (R0)            ;SHIFT LAST BYTE (SETS/CLEARS C)
        BICB    #BIT3,(R0)              ;CLEAR MSB OF 10 WORD (C NOT AFFECTED)
        
1$:     RORB    -(R0)           ;ROTATE THIS BYTE (INC C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;DO ALL
        BCC     2$              ;NO, GO AROUND
        BISB    #BIT3, 4(R0)    ;YES, SET MSB OF 10 WORD
2$:     POP     R1              ;RESTORE REG
        RTS     R5              ;RETURN


;SEQ298
.REM    %
MOVWRD -- SUBROUTINE TO MOVE A 36 BIT WORD FROM ONE
PLACE TO ANOTHER. CALL INCLUDES TRAILING PARAMETERS AS FOLLOWS:
        JSR     R5,$MOVWD
        .WORD   SOURCE ADDRESS
        .WORD   DESTINATION ADDRESS
%
$MOVWD: SHOVE                   ;SAVE REGISTERS
        MOV     (R5)+,R2        ;GET ADDRESS OF SOURCE
        MOV     (R5)+,R1        ;GET ADDRESS OF DESTINATION
        MOV     #5,R0           ;NEED FIVE BYTE MOVES
1$:     MOVB    (R2)+,(R1)+     ;TRANSFER
        DEC     R0              ;SEE IF DONE
        BGT     1$              ;BR IF NO
        GRAB                    ;IF DONE RESTORE REGISTERS
        RTS     R5              ;RETURN


;SEQ299

.REM    %
SHOVE -- SUBROUTINE TO SAVE REGS 1-4 ON THE STACK WITHOUT DISTUREBING R0 OR R5.
%
$SHOVE: POP     $$HOLD          ;GET R5 OFF STACK
        PUSH    <R4,R3,R2,R1>   ;SAVE THE REGISTERS
        PUSH    $$HOLD          ;PUT R5 BACK ON STACK
        RTS     R5              ;AND RETURN
$$HOLD: .WORD   0               ;SAVE LOCATION
.REM    %
GRAB -- SUBROUTINE TO RESTORE REGS 1-4 FROM THE STACK WITHOUT DISTURBING R0 OR R5.
%
$GRAB:  POP     $$HOLD          ;GET R5 OFF STACK.
        POP     <R1,R2,R3,R4>   ;PUT BACK REGISTERS.
        PUSH    $$HOLD          ;PUT R5 BACK N STACK.
        RTS     R5              ;AND RETURN.


;SEQ300

.SBTTL MSK36 -- SUBROUTINE TO MASK AND COMPARE 36-BIT DATA

.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPAR-
ISON OF 36-BITS OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,$MSK36
        R3 = POINTER TO MASK (0S IMPLY TEST)
        R4 = POINTER TO EXPECTED DATA
        R2 = POIINTER TO ACTUAL DATA
%
$MSK36: REGSAV          ;THE FAMOUS 10% FAILURE
        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #4,R0           ;LOOP COUNT
1$:     MOVB    (R4)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R3),R1         ;MASK IT
        MOVB    (R2)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R3)+,R5        ;MASK IT
        TST     R0              ;DOING LAST BYTE?
        BNE     6$              ;NO, GO AROUND
        BICB    #360,R5         ;YES, MASK OFF ABSENT BITS
        BICB    #360,R1         ;CLEAR EXPECTED TOO
6$:     CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGE     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     5$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R3           ;RESTORE MASK POINTER
        MOV     R3,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R2           ;RESTORE ACTUAL POINTER
        MOV     #5,R5           ;
3$:     MOVB    (R2)+,(R0)+     ;ACTUAL TO ERROR STACK
        DEC     R5              ;
        BGT     3$              ;
        SUB     #5,R4           ;RESTORE POINTER TO EXPECTED
        MOV     #5,R5           ;
4$:     MOVB    (R4)+,(R0)+     ;
        DEC     R5              ;
        BGT     4$              ;
        MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        REGRST                  ;REGISTERS
        SEC                     ;SET C-BIT
        RTS     R5              ;RETURN
5$:     REGRST
        CLC                     ;CLEAR DAMN C-BIT
        RTS     R5              ;RETURN
FFLAG:  0


;SEQ301

.REM    %
        36-BIT DATA COMPARE ROUTINE (TRALING PARAMETERS).
USES $MSK36.
CALL IS:
        JSR     R5,$MK36T
        ENTRY+2 = POINTER TO MASK (0S IMPLY TEST)
        ENTRY+4 = POINTER TO EXPECTED DATA
        ENTRY+6 = POINTER TO ACTUAL DATA
%
$MK36T: PUSH    <R3,R4,R2>
        MOV     (R5)+,R3                ;MASK POINTER
        MOV     (R5)+,R4                ;EXPECTED POINTER TO R4
        MOV     (R5)+,R2                ;ACTUAL POINTER TO R2
        JSR     R5,$MSK36               ;PERFORM THE TEST
        POP     <R2,R4,R3>
        RTS     R5              ;RETURN


;SEQ302

.SBTTL ARLOD2 -- SUBROUTINE TO LOAD AR WITHOUT AFFECTING IR
.REM    %
CALLING SEQUENCE
        MOV     #ADDR OF 36 BIT DATA R0
        JSR     R5,$ARLO2
KEEP IN MIND THAT THIS ROUTINE STEPS THE EBOX CLOCK ONE TIME
AND A NEW COMMAND GETS CLOCKED INTO THE CONTROL REGISTER
%
$ARLO2: PUSH    R1              ;SAVE R1
        MOV     R0,R1
        MOV     #LDAR,R0
        DFWRT                   ;THE DATA IS IN AR
        DFXCTT                  ;CLOCK THE MACINE
        SECLK
        POP     R1              ;RETRIEVE REGISTERS
        RTS     R5              ;AND GONE

;SEQ303

.SBTTL  FAMOUS DCOMP -- SUBROUTINE TO DO MULTIPLE MASKED BYTE COMPRES
.REM    %
ROUTINE TO COMPARE AND CHECK CONTROL BITS IN
RANDOM EBUS POSITIONS, REQUIRES 4 TABLES.  A BYTE TABLE 
OF DIAGNOSTIC FUNCTIONS, A BYTE TABLE OF EXPECTED DATA
A BYTE TABLE OF MASKS, AND A BYTE TABLE OF EBUS BIT POINTERS
WHICH SPECIFY THE BUS POSITION OF THE BYTE UNDER INSPECTION.
THERE IS AN ALTERNATE CALL ENTRY,"SDCOMP",WHICH PROVIDES FOR
CALLS FROM SUBROUTINES.
        CALL:   JSR     R5,$DCOMP
 
                .WORD   PMASK           ;ADDRESS OF 1ST MASK BYTE
                .WORD   PFUNC           ;ADDRESS OF 1ST DIAG FUNC BYTE
                .WORD   PBYTE           ;ADDRESS OF 1ST EBUS BYTE PTR BYTE
                .WORD   PEXP            ;ADDRESS OF 1ST EXPECTED DATA BYTE
                .WORD   PMSG!BIT15      ;ADDRESS OF ERROR MSG!INDIRECT FLAG
%
SDCOMP: MOV     2(SP),SUBSAV            ;SAVE SUBTEST NUMBER
        BR      DCOMP1
$DCOMP: MOV     (SP),SUBSAV             ;SAVE SUBTEST NUMBER
DCOMP1: REGSAV                  ;SAVE REGS ON STACK
        MOV     (R5)+,R1        ;GET STARTING ADDRESS OF MASK LIST
        MOV     (R5)+,R2                ;ADDRESS OF DIAG FCN LIST
        MOV     (R5)+,R3        ;ADDRESS OF BYTE POINTER LIST
        MOV     (R5)+,R4        ;ADDRESS OF EXPECTED DATA LIST
        MOV     R1,DCOMPM       ;SAVE INITIAL VALUE OF PTRS
        MOV     R2,DCOMPF
        MOV     R3,DCOMPB
        MOV     R4,DCOMPX
1$:     MOVB    (R2),R0         ;PUT DIAG FCN IN R0
        BIC     #177600,R0      ;BIC THE BANANA
        DFRD                    ;CALL TO READ EBUS
;BEGIN SECTION OF CODE THAT TURNS BYTE POINT INTO REAL DATA
        MOV     R1,-(SP)        ;SAVE R1 FOR AWHILE
        MOVB    (R3)+,R0        ;GET THE BYT EPOINTERS IN R0
        MOV     R0,R1           ;MAKE A SECOND COPY IN R1
        BIC     #177774,R0      ;GET DEXWD POINTER
        ASR     R1              ;MAKE R1 COPY WITH NO DEX PNT
        ASR     R1              ;TAKES TWO SHIFTS
        ASL     R0              ;ADDRESS NEEDS TO BE EVEN FOR WORDS
        ADD     .DAT3,R0                ;GET RIGHT DEXWD
        MOV     (R0)+,TEMP.
        BIT     R1,#BIT3                ;TEST CROSS BOUNDARY BIT
        BEQ     2$              ;BRANCH IF FULL BYTE IN DEXWD
        MOVB    (R0),TEMP.      
        SWAB    TEMP.   ;BECAUSE BYTE CROSSES DEX BOUNDARY
        BIC     #BIT3,R1        ;CLEAR CROSS BOUNDARY BIT
2$:     MOV     TEMP.,R5        ;PUT 16 EBUS BITS ION R5
        TST     R1              ;DO WE NEED TO SHIFT BITS
3$:     BEQ     4$              ;BR OUT IF NO, WITH BYTE IN R5
        ROR     R5              ;YES,SHIFT ONCE
        DEC     R1              ;DECREMENT COUNT
        BR      3$              ;LOOP


;SEQ304

        ;DESIRED 8 BITS OF EBUS ARE RIGHT JUSTIFIED IN R5
4$:     MOV     (SP)+,R1        ;REPLACE R1 FROM STACK
        BICB    (R1),R5         ;MASK THE BYTE IN R5
        MOVB    (R4)+,R0        ;PUT EXPECTED IN R0
        BICB    (R1)+,R0        ;MASK OUT BITS
        CMPB    R0,R5           ;COMPARE REAL VS. EXPECTED
        BNE     6$              ;BRANCH AWAY IF BAD COMPAE
5$:     BITB    (R2)+,#BIT7     ;SEE IF DONE WITH LIST
        BNE     8$              ;IS YES, BR TO DONE STUFF
        INC     IINDEX          ;OTHERWISE, INCREMENT TABLE INDEX
        BR      1$              ;GO TO NEXT LIST ELEMENT
;YOU'LL BRANCH HERE IF BAD DATA
6$:     MOV     ERSP..,R0       ;GET ERR STACK IF FIRST ERROR
        TST     ERRFG.          ;TEST IF THIS WAS FIRST ERROR
        BNE     7$              ;BRANCH IF NOT FIRST ERROR
        MOV     #FT3,(R0)+      ;LOAD STACK WITH ERROR FORMAT
        MOV     DCOMPF,(R0)+   ;LOAD BASE ADDR DIAG FCNS
        MOV     DCOMPB,(R0)+   ;LOAD BASE ADDR BYTE PNT
        MOV     DCOMPM, (R0)+   ;LOAD BASE ADDR MASKED DATA
        MOV     DCOMPX, (R0)+   ;LOAD BASE EXPECTED DATA
        MOV     R0,ERRFG.       ;SET ERR FLAG TO SAY ERROR
        ;NOW STACK TABLE INDEX AND ACTUAL RECEIVED DATA
7$:     MOVB    R5,IINDEX+1     ;PUT ACTUAL RECEIVED IN CORE
        MOV     IINDEX,(R0)     ;PUT INDEX AND DATA ON STACK
        SWAB    (R0)+           ;REARRANGE
        MOV     R0,ERSP..       ;TERMINATE ERR STACK GRACEFULLY
        BR      5$              ;GO BACK TO MAINLINE
        ;FINISH-UP CODE
8$:     CLR     IINDEX          ;RESET INDEX COUNT
        REGRST                  ;PUT BACK REGISTERS
        TST     ERRFG.          ;WERE THERE ANY ERRORS
        BEQ     9$              ;GO FINISH IF NONE
        MOV     ERSP..,R0       ;GET ERROR STACK PTR
        BIS     #BIT15,-(R0)    ;IF THERE WERE ERRORS
        CLR     ERRFG.          ;RESET ERROR FLAG
        MOV     (SP),R0 ;PUT SUBTEST # IN R0

        ADD     #10,R5          ;MAKE R5 POINT TO THE ERROR MSG
        MOV     R5,(SP)         ;SWAP RETURN ADR FOR PTR TO ERROR MSG
        MOV     SUBSAV,R5       ;REPORT SUBTEST NR TO EXEC
        JMP     FAULT           ;TAKE ERROR RETURN TO EXEC
9$:     CLR     ERRFG.          ;CLEAR ERROR FLAG
        ADD     #12,R5          ;GO AROUND ERROR MESSAGE
        RTS     R5              ;AND RETURN
IINDEX: 0
ERRFG.: 0
TEMP.:  0
DCOMPF: 0
DCOMPB: 0
DCOMPM: 0
DCOMPX: 0
SUBSAV: 0
 
FT3=0012
 
;SEQ305

.SBTTL  FAMOUS MCOMP -- SUBROUTINE TO MODIFY DCOMP'S TABLES
.REM    %
MCOMP MODIFIES ONE OR MORE OF THE ENTRIES IN A DCOMP BYTE
COMPARISON TABLE.  THE BASE ADDRESS OF THE DCOMP TABLE IS IN LOCATION
"DCOMPX" WHERE DCOMP STORES IT:  IF MCOMP IS USED BEFORE THE FIRST
DCOMP CALL, THE CALLING PROGRAM MUST STORE THIS ADDRESS.  THE CALL
IS MADE WITH R2 POINTING AT A LOCATION CONTAINING THE NUMBER
OF LOCATIONS TO CHANGE AND R3 POINTING TO THE FIRST ENTRY IN
A SPECIAL MCOMP CHANGE TABLE.

ENTRIES IN THE LATTER TABLE ARE "INDEX/"NEW DATA" PAIRS.
        FOR EXAMPLE: TO CHANGE THE 1ST BYTE IN A DCOMP TABLE
        TO -5 AND THE 3RD BYTE TO 55.  THE FOLLOWING CODE
        IS NEEDED:
        MOV     #TNUM,R2
        MOV     #TADR,R3
        JSR     R5,$MCOMP
TNUM:   .BYTE   2
TADR:   .BYTE   0               (NOTE THAT INDEX OF 1ST BYTE IS ))
        .BYTE   -5
        .BYTE   2
        .BYTE   55
NOTE THAT R2=TNUM+1 AND R3=TADR+4 AFTER THIS CALL.  HENCE MCOMP LISTS
MAY BE CHAINED.

MCOMP KEEPS A TABLE OF THE REPLACE DCOMP TABLE VALUES AT "RRSTOR"
(UP TO A MAXIMUM OF 11) AND CAN BE FOLLOWED BY AN RCOMP CALL TO
RESTORE THE DCOMP TABLE TO ITS PREVIOUS STATE.  SINCE REPEATED MCOMP
CALLS REUSE THIS TABLE.  VALUES RESTORED BY RCOMP WILL BE THOSE THAT
EXISTED BEFORE THE MOST RECENT MCOMP CALL.

%

;SEQ306

$MCOMP: PUSH    <R1,R4,R5>      ;SAVE REGISTERS

;R1=# OF CHANGES LEFT TO DO, R4 WILL HOLD ADR OF DCOMP TABLE
;ENTRY BEING MODIFIED & R5 POINTS AT STORAGE TABLE
        MOVB    (R2)+,R1        ;PUT # OF CHANGES TO BE MADE IN R1
        BEQ     2$              ;IF ZERO DO NOTHIN"
        MOV     #RRSTOR,R5      ;GET ADDR OF STORAGE TBL
1$:     MOVB    (R3)+,R4        ;INDEX INTO DCOMP GOES IN R4
        MOVB    R4,(R5)+        ;WRITE SAME INDEX TO STORAGE TBL
        ADD     DCOMPX,R4       ;MAKE EXPECTED DATA TBL ADR
        MOVB    (R4),(R5)+     ;SAVE DATA ABOUT TO CHANGE IN STORAGE TBL
        MOVB    (R3)+,(R4)      ;PUT NEW DATA INTO XPECT TBL
        DEC     R1              ;DECREMENT COUNT
        BNE     1$              ;LOOP IF MORE ELEMENTS
        MOVB    #377,(R5)      ;SET END OF STORAGE TBL FLAG
        INC     TATTLE          ;SET A FLAG FOR RCOMP
2$:     POP     <R5,R4,R1>      ;RESTORE REGISTERS
        RTS     R5              ;RETURN
TATTLE: .WORD   0               ;THE FAMOUS MCOMP/RCOMP FLAG


;SEQ307

.SBTTL  FAMOUS RCOMP ROUTINE
.REM    %
THE RCOMP ROUTINE IS T0 "RESTORE" DATA CHANGED BY MCOMP
ROUTINE.IT ONLY RESTORES THE EXPECTED TABLE AS IT APPEARED
BEFORE THE MOST RECENT MODIFICATION. CALL MCOMP#1; CALL MCOMP#2
CALL MCOMP#3;CALL MCOMP#4;CALL RCOMP.  THE XPECTED TABLE WILL
        
NOW LOOK AS IT DID AFTER MCOMP#3.

THERE MUST HAVE BEEN A NONZERO MCOMP CALL SINCE THE LAST RCOMP
CALL FOR RCOMP TO TAKE ANY ACTION.
CALL:   
        JSR     R5,$RCOMP
%
$RCOMP: TST     TATTLE          ;HAS MCOMP DONE AYTHING LATELY?
        BEQ     2$              ;NOPE,D ON'T DO NOTHIN'
        SHOVE                   ;YUP, SAVE REGISTERS
        MOV     #RRSTOR,R1      ;GET STORAGE TBL ADDR
1$:     MOVB    (R1)+,R2        ;MOVE INDEX TO R2(SHOULD NEVER BE NEG)
        ADD     DCOMPX,R2       ;INDEX INTO EXPECTED TABLE
        MOVB    (R1)+,(R2)      ;REPLACE DATA IN EXPECTED TBL
        TSTB    (R1)            ;SEE IF END OF REPLACEMENTS
        BPL     1$              ;LOOP BACK IF NOT
        COM     RRSTOR          ;IF END PUT DONE FLAG AT FIRST TBL LOC.
        CLR     TATTLE          ;AND CLEAR MCOMP'S FLAG.
        GRAB                    ;RESTORE REGISTERS
2$:     RTS     R5              ;RETURN
;MCOMP CAN HANDLE 23 CHANGES
RRSTOR: .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0 ,0,0
        .WORD   0,0,0
        .WORD   0,0,0

;SEQ308
.SBTTL  PATTY -- A SUBROUTINE TO GENERATE TEST PATTERNS
.REM    %
ROUTINE TO GENERATE A COMPLETE SET OF TEST PATTERNS FOR CHECKING AN
N-BIT WIDE DATA PATH FOR 1) NO BIT STUCK AT "0" OR "1", AND 2) NO
TWO BITS INTERACTING.

THREE INITIAL ENTRY POINTS ARE GIVEN FOR THE COMMON KL-10 DATA PATH
WIDTHS OF 80,36 AND 16 BITS.


PATTERNS ARE STORE IN INVERSE BYTE FORMAT BEGINNING AT THE LOCATION
POINTED TO BY R0 AT INITIAL ENTRY.  THE ROUTINE RETURNS THE PATTERNS
NUMBER IN R0.  IF ALL PATTERNS HVE BEEN DONE, IT RETURNS A 0 IN R0.
THE NUMBER OF PATTERNS GENERATED IS 14 FOR 80 BIT WIDTH, 12 FOR 36 BIT WIDTH
AND 8 FOR 16 BIT WIDTH.

THE PATTERNS PRODUCES ARE:
        1) 0001 0001 0001 ....
        2) 0010 0010 0010 ....
        3) 0100 0100 0100 ....
        4) 1000 1000 1000 ....
        50 BC BC BC BC ....
        6)      CB CB CB CB CB CB ....
        7) BB CC BB CC BB ....
        8) CC BB CC BB CC ....
        9) BB BB CC CC BB ....
      10)  CC CC BB BB CC ....
     11)   BB BB BB BB CC ....
        12) CC CC CC CC BB ....
        13) 16 B'S AND 4 C'S
        14) 16 C'S AND 4 B'S
                WHERE B = 0001 AND C = 1110
INITIAL CALL:   MOV     #PTR,R0         ;PUT ADR OF 1ST BYTE TO BE FILLED IN R0
                JSR     R5,$PAT80       ;FOR 11 BYTE PATTERNS
        OR      JSR     R5,$PAT36       ;FOR  5 BYTE PATTERNS
        OR      JSR     R5,$PAT16       ;FOR  2 BYTE PATTERNS

SUBSEQUENT CALLS:
                JSR     R5,$PATCO
%
;INITIAALIZATION ENTRY POINTS
        PNO=R2          ;NUMBER OF PATTERNS
        BNO=R0          ;NUMBERT OF BYTE
        BITPNT=R4               ;BIT POWER
        
        ;ENTRY CODE FOR MICRO RAM PATTERN
$PAT80: MOV     #^D10,BMAX      ;SET MAXIMUM WIDTH OF PATTERN
        MOV     #^D14,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY
        ;ENTRY CODE FOR 36 BIT PATERN
$PAT36: MOV     #4,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS


;SEQ309

        MOV     #^D12,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY
        ;ENTRY CODE FOR DRAM PATTERNS
$PAT16: MOV     #1,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS
        MOV     #^D8,PMAX       ;SET ACTUAL NUMBER OF PATTERNS
PATTY:  SHOVE           ;SAVE THE REGISTERS
        ADD     BMAX,R0         ;FORM PTR TO LAST BYTE
        MOV     R0,MULBUF       ;AND SAVE IN MULBUF
        MOVB    #21,PAT         ;PAT HAS BASIC PATTERN BYTE
        CLR     PNO             ;CLR R0, NUMBER OF PATTERNS GENERATED
        MOV     #1,BITPNT               ;SET THE BIT POINTER TO BIT0
PGENRE: MOVB    PAT,COMPAT      ;COMPAT WILL HAVE THE BASIC PATTERN
        COMB    COMPAT          ;BUT IN COMPLIMENTED FORM
NOCOMP: CLR     BNO             ;CLR NUMBER OF BYRTES DOEN
4$:     CMP     BMAX,BNO        ;IS BNO > BMAX??
        BMI     5$              ;BRANCH OUT OF LOOP IF YES
        CMP     #6,PNO          ;DOING FIRST 6 PATTERNS?
        BGT     2$              ;BRANCH IF YES
        BIT     BITPNT,BNO      ;OUTPUT PATTERN OR COMPLIMENT?
        BEQ     2$              ;BRANCH IF KEY BIT IN BNO0 IS CLEAR
;GADZOOKS, OUTPUT COMPLIMENT BYTE
        MOVB    COMPAT,@MULBUF
        BR      3$              ;AND CONTINUE
;GADZOOKS, OUTPUT REAL BYTE
2$:     MOVB    PAT,@MULBUF
3$:     DEC     MULBUF
        INC     BNO             ;INCREMENT BNO FOR NEXT BYTE
        BR      4$              ;AND LOOP BACK
;HERE IF DONE ONE OF THE MANY PATTERNS
5$:     INC     PNO             ;INCREMENT TO NEXT PATTERN
        MOV     R0,CORE0                ;SAVE THE CURRENT STAT OF REG'S
        MOV     R2,CORE2
        MOV     R4,CORE4
        ADD     BMAX,MULBUF
        INC     MULBUF          ;THERE WAS ONE EXTRA DEC - FIX IT UP
        MOV     PNO,MULBU1      ;SAVE PATTERN NUMBER FROM CLUTCHES OF GRAB
        GRAB
        MOV     MULBU1,R0               ;PUT PATTERN NUMBER IN R0 FOR RETURN
        RTS     R5
;YOU WILL REENTER HERE TO CONTINUE WIT ADDITIONAL PATTERNS
$PATCO: SHOVE
        MOV     CORE4,R4                ;GET MULPATS LAST STATE
        MOV     CORE2,R2
        MOV     CORE0,R0
        CMP     #3,PNO  ;IS PNO<4?
        BMI     8$              ;BRANCH IF NO
        ASLB    PAT             ;SHIFT PATTERN


;SEQ310

        JMP     PGENRE          ;AND REENTER THE LOOP
8$:     CMP     PNO,PMAX        ;DONE ALL PATTERNS?
        BHIS    9$              ;GADZOOKS, GET THE HECK OUTA HERE IF YE YES YES
;PATTERNS 5 - 8 NEED SPECIAL HANDLING...DIFFERENT STROKES FOR DIFFERENT FOLKS.
        CMP     #4,PNO  ;IS THIS PATTERN #5?
        BMI     10$
        MOVB    #36,PAT         ;LOAD PATTERN FOR #5
        JMP     PGENRE          ;AND GO BACK
10$:    CMP     #5,PNO          ;IS THIS PATTERN #6?
        BMI     11$             ;BRANCH IF NOT
        MOVB    #341,PAT        ;LOAD PATTERN FOR #6
        JMP     PGENRE          ;AND GO BACK
11$:    CMP     #6,PNO          ;IS THIS PATTERN #7?
        BMI     12$             ;BRANCH IF NOT
        MOV     #10756,PAT      ;SET PAT = 356, COMPAT = 21 FOR REST OF PATTERNS
12$:    SWAB    PAT             ;EXCHANGE PATTERN AND COMPLIMENT OF PATTERN
        CMP     #7,PNO          ;ARE WE DOING 7 AND 8
        BGE     NOCOMP          ;IF SO, TAKE A SHORT CUT
        BIT     #BIT0,PNO       ;TEST BIT 0 OF PNO, BR IF ODD
        BNE     PGENRE
        ASL     BITPNT          ;SHIFT BIT POINTER IF EVEN
        JMP     PGENRE          ;AND RETURN TO THE BIG LOOP
9$:     GRAB
        CLR     R0
        RTS     R5
BMAX:   0
PMAX:   0
PAT:    .BYTE   0
COMPAT: .BYTE   0
CORE0:  0
        CORE2:  0
CORE4:  0
MULBUF: 0
MULBU1: 0
.SBTTL  CRADRD: THE NEXT ADDRESS BOARD REGISTER READER
.REM    %
SUBROUTINE TO READ ONE OF 3 REGISTERS ON THE CRA BOARD AND RETURN
THE 11 BIT RESULT, RIGHT JUSTIFIED, IN REGISTER R0
FIRST PASS THE DESIRED REGISTER'S DIAGNOSTIC FUNCTION IN R0, THEN JSR.
        MOV     #DTAGECN,R0
        CRADRD
%
$CRADRD:        PUSH    <R1,R0>         ;SAVE SOME REGISTERS
        MOV     #EWORD1,R1      ;READ AND SAVE DATA AT EWORD1
DFRDMV                          ;FUNCTION HAS ALREADY IN R0
        MOVB    EWORD1+3,DSAVE  ;MUST SAVE CRA REGISTER


;SEQ311

        MOVB    EWORD1+4,DSAVE+1        ;00 THRU 04
        POP     R0              ;GET DIAG FCN BACK
        DEC     R0              ;DIAG FCN MUST BE LESS ONE FOR BITS 5-10
        MOV     #EWORD1,R1      ;BUT SECOND READ IN EWORD
        DFRDMV                  ;READ SECOND HALF CRA REGISTER
        ROLB    EWORD1+3                ;ALMOST JUSTIFY THE DATA (EBUS 0-5)
        ROLB    EWORD1+4                ;ON A BYTE BOUNDARY
        ROLB    EWORD1+3        ;FINISH JUSTIFYING THE DATA (EBUS 0-5)
        ROLB    EWORD1+4                ;ON A BYTE BOUNDARY (EWORD1+4)
        BICB    #174077,DSAVE   ;CLEAR A PLACE FOR REG BITS 5-10
        BISB    EWORD1+4,DSAVE  ;SET REG BITS 5-10
        MOV     DSAVE,R0                ;GET FINAL REGISTER RESULTS
        POP     <R1>            ;FIX STACK
        RTS     R5              ;ALL DONE


;SEQ312

    
.SBTTL ROUTINE TO GET PAGING MICRO-CODE INTO C-RAM
LODMIC: TSTB    CONSOL-2                ;POWER UP AND DOWN??
        BEQ     4$      ;BR IF YES & NEED TO LOAC MIC-CODE
3$:     RTS     PC
;HERE IF FILE NOT IN CORE
4$:     PFORCE
        PMSG<\MICRO-CODE IS LOADING\>
        PNORML
        MOV     #PCMD,R0        ;GET PROGRAM COMMAND
        PRGCMD                  ;CONSOL EXECUTE

        BCS     LODERR          ;ERROR IN LOADING FILE??
MICOK:  CLR     JUSLDD          ;OK TO SAY RAM CODE LOADED
        COMB    CONSOL-2        ;TELL CONSOL TOO
        RTS     PC              ;GET OUT
LODERR: PFORCE
        PMSG<\FILE: "DIAGB.RAM" NOT FOUND\LOAD MICRO-CODE & HC TO CONT.>
        PNORML
        PRGHLT
        BR      MICOK
PCMD:   .ASCII  %P %
FLNME:  .ASCIZ  %DIAGB.RAM%     ;PAGING MICRO-CODE FILENAME
        
.EVEN


;SEQ313

.SBTTL ROUTINE TO ISSUE WWADR,ONE ECLOCK & SET RUN FLOP FOR PI
.REM    %
THIS ROUTINE RECEIVES IN R0 THE DESIRED MICRO-CODE ADDRESS
THEN LOADS THAT ADDRESS, ISSUES RUN AND CONTINUE (FOR THE
BENEFIT OF THE PI BOARD) AND FINALLY ONE EBOX CLOCK TO SYNC THE
MICRO-CODE FOR THE BEGINNING OF THE NEXT PI SUBTEST
%
RUN.GO: WWADR           ;ADDRESS TO DIAG ADDR REG
        JSR     PC,NPIDIS               ;ROUTINE TO SET RUN & SET CONTINUE
        ECLOK           ;SINGLE CLOCK
        RTS     PC              ;OUT
;TINY ROUTINE TO ACTUALLY DO THE SETTING OF "RUN" & "CONTUNUE"
NPIDIS: DFXCTT          
        SETRUN          ;FUNCTION TO SET RUN FLOP
        DFXCTT
        CONBUT          ;FUNCTION TO SET CONTUNUE AND ENABLE "RUN" TO PI
        RTS     PC              ;OUT
;TRAP ROUTINE TO GIVE BURSTS OF CLOCKS.. THE FEATURE OF THIS ROUTINE
;IS THAT IF YOU GIVE A CLOCK COUNT GREATER THAN THE BURST ROUTINE WILL
;ACCEPT, THEN THIS ROUTINE BREAKS IT UP AND DOES THE BURSTING
;IN CHUNKS OF 255
$RUNCL: PUSH    R0              ;SAVE NUMBER OF TICS
1$:     SUB     #^D255,(SP)     ;BIG CLOCK CNT??
        BPL     2$              ;BR IF YES
;HERE IF NO
        BURST                   ;BURST THE CLOCK
        POP     R0              ;CLEAN STACK
        RTS     R5              ;AND OUT
2$:     MOV     #^D255,R0       ;BIG CNT..GET ALL 255 TICS TO R0
        BURST                   ;EXECUTE THEM
        MOV     (SP),R0 ;GET UPDATED CLOCK CNT TO R0
        BR      1$              ;AND BACK TO BEGINNING


;SEQ314

;ROUTINE TO LOAD A SEQUENCE OF CRAM LOATIONS WHERE THE CRAM
;DATA HAS BEEN ASSEMBLED WITH THE "UMAC" & "VMAC" MACROS
;PASS THE ROUTINE TWO TRAILING PARAMETERS.. FIRST POINTS TO THE
;CRAM BUFFER.. SECOND TELLS HOW MANY RAM WORDS TO LOAD.
;       JSR     R5,OVRLOD
;       .WORD   BUFF PNT        ;POINTER TO CRAM BUFF
;       .WORD   #WRDS           ;HOW MANY WORDS TO LOAD
OVRLOD: SHOVE                   ;SAVE REGISTERS
        MOV(R5)+,R1             ;GET THE POINTER TO THE BUFFER
        MOV     (R5)+,R2        ;GET NUBMER OF WORDS TO LOAD
1$:     MOV     (R1)+,R0        ;GET CRAM ADDRESS
        WCRAM                   ;WRITE THE DATA TO THE CRAM
        ADD     #^D12,R1        ;UPDATE PNTR PAST THE RAM DATA
        DEC     R2              ;AND DOWN THE COUNT
        BGT     1$              ;BR BACK TO CONTINUE
        GRAB                    ;RESTORE REGISTERS
        RTS     R5              ;AND RETURN


;SEQ315

;ROUTINE TO FIND CERTAIN KL10 MACHINE STATE
;THE ROUTINE IS PASSED A DIAGNOSTIC FUNCTION,
;AN EBUS BIT POSITION, AND A STATE(0 OR 1) AND WILL
;THEN BEGIN SINGLE STEPPING THE KL10 PROCESSOR UNTIL THE
;BIT SPECIFIED IN THAT DIAGNOSTIC FUNCTION, REACHES THE STATE
;SPECIFIED
;THE CALL IS:
;       JSR     R5,FIND
;       .WORD   DIAG FUNC
;       .WORD   DFBT#
;       .WORD   0 OR 1 FOR DESIRED STATE
FINDSS: MOV     #-1,FNDTYP              ;SET FLAG TO SAY SINGLE STEP
        CLR     TYMCNT          ;CLEAR TIMEOUT CNTR JUST IN CASE
        BR      KRATE           ;AND CONTINUE WITH CODE
FIND:   CLR     FNDTYP          ;CLEAR FLAG TO SAY FIND DAMN IT
        MOV     #1400,TYMCNT    ;SET TIMEOUT CNTR FOR FIND
KRATE:  SHOVE           ;SAVE REGISTERS
        MOV     (R5)+,R2        ;GET DIAG FCN TO REG R2
        CLR     R4              ;R4 - ALL 0S
        BISB    (R5),R4         ;SET DEXWD BIT PNTR INTO REG
        PUSH    (R5)+           ;AND SAVE IT ON THE STACK TOO
        SWAB    (SP)            ;NOW SWITCH DEXWD PNT WITH BIT MSK
        BIC     #177400,(SP)    ;CLEAR DEXWD PNT,LEAVE ONLY BIT MSK
        COM     (SP)            ;TURN MASK INTO A NET WITH 1 HOLE
        MOV     (R5)+,R3        ;NOW GET DESIRED BIT STATE
        NEG     R3              ;CHANGE A 0 INTO 0,A 1 INTO 177777
        BICB    (SP),R3         ;USE NET. GET BIT IN DESIRED STATE & POS.
        MOV     #FNBUF,R1       ;GET PLACE TO PUT DATA WE WILL READ
1$:     CLR     NOFND           ;CLEAR "NO FIND" FLAG
        MOV     R2,R0           ;DIAG FUNC TO REG R0
        DFRDMV          ;MAKE THE CALL
        BICB    (SP),FNBUF(R4)  ;CLEAR ALL BITS BUT SELECTED ONE
        CMPB    FNBUF(R4),R3    ;TEST READ BIT VS. DESIRED BIT
        BEQ     2$              ;BR IF FOUND WHAT WE WANTED
        MOV     #-1,NOFND      ;SET FLAG TO SAY "SIGNAL NOT FOUND"
        DFXCTT                  ;ELSE FUNCTION EXECUTE TO SINGLE STEP
        SSCLK                   ;A SINGLE MBOX CLOCK
        TST     FNDTYP          ;DECIDE WEATHER TO CONT., OR RETURN
        BNE     11$             ;IF =-1, THEN CONTINUE ON OUT OF THIS ROUTINE

;FALL TO HERE TO DECREMENT TIMEOUT COUNTER
        DEC     TYMCNT          ;DOWN THE COUNTER
        BLE     11$             ;BR TO EXIT CODE IF TIMER DONE
        BGT     1$              ;ELSE BACK TO CONTINUE THE LOOP
11$:    TST     NOFND           ;SEE IF ERROR FOUND ON THIS PASS
        BEQ     2$              ;IF OK, TAKE CLEAN EXIT
        SEC                     ;SET "C-BIT" TO INDICATE ERR.
        BR      3$              ;CLEAN STACK ON WAY OUT


;SEQ316

2$:     CLC                     ;CLEAR "C-BIT" TO INDICATE NO ERR
3$:     POP     R0              ;ALL DONE--CLEAN STACK
        GRAB                    ;RESTORE THE REGISTERS
        RTS     R5              ;AND RETURN, ALL WELL AND GOOD
NOFND:  .WORD   0               ;FLAG FOR SAVING ERR INDICATOR
FNDTYP: .WORD   0               ;FLAG FOR INDICATING FIND TYPE
TYMCNT: .WORD   0               ;COUNTER FOR TIMEOUT (IF NO FIND SIGNAL)
FNBUF:  WD36    0,0,0           ;TEMP. 36 BIT BUFFER
        .EVEN


;SEQ317


.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX CLOCK AFTER
CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE THIS SUBROUTINE TO PERFORM
MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE        
                BIT 1 = DRAM PARITY
                BIT2  = CRAM PARITY
                BIT 3 = FM PARITY
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT          ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC                ;SAVE PC
        JSR     PC,SPCRST               ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN
MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO FRG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITIONS
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0                   ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000
KLB24:  WD36    0,0,4000
KLB35:  WD36    0,0,1
        .EVEN
SPCRST: MRESET
        CLR     R0              ;CLEAR REG TO BE CRAM ADDR
        WWADR                   ;SET CRAM ADR TO ZERO
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES, SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?


;SEQ318


        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NON
        DFWRTT                  ;ENABLE CONDITIONS
                CLKWD           ;CONDITIONS
                46      ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     RTS     PC              ;RETURN


;SEQ319

.SBTTL          MEMORY CONFIGURATION SAVE & RESTORE
;FIND A MEMORY THAT RESPONDS AND SAVE ITS BASE ADDRESS.  IF
;NO MEMORY IS FOUND WITH FOUR CONSECUTIVE REFERENCES WITHIN THE
;FIRST 256K THEN AN ERROR RETURN IS GIVEN.
FNDM16: PUSH    R1
        MOV     (R5)+,R1       ;GET ADRESS
        LOAD    1,FND16K,17     ;LOAD AC PRGM (AC1 - 17)
        
1$:     RUNBIG  1,20            ;RUN IT, LONG TIMEOUT
        BCC     2$              ;AC CODE HUNG UP - DO ALL CMD
        ERRORA  ERRP            ;AC CODE HUNG UP - DO "ALL" COMMAND
2$:     READ17                  ;GET BASE ADDR
        MOVB    1(R0),(R1)+     
        MOVB    2(R0),(R1)      ;SAVE BASE FOR USERS
        BITB    #BIT2,(R1)+     ;VALID?
        BEQ     3$              ;BR IF O.K.
        SEC                     ;SET ERROR FLAG
        BR      4$
3$:     CLC                     ;CLEAR ERROR FLAG
4$:     POP     R1
        RTS     R5
MCBASA: 0
FND16K: IO10    CONO,PAG,,0     ;1--CLEAR CACHE, PAGING
        I10     MOVEM,16,,100,17        ;2--WRITE -1
        I10     CAME,16,,100,17 ;3--COMPARE IT
        I10     JRST 0,,11      ;4--NO COMPARE, NEXT 16K PLEASE
        I10     AOS,0,,17       ;5--INDEX THRU NEXT 3
        I10     TRZN,17,,4      ;6--DONE 4 CONSECUTIVE?
        I10     JRST,0,,2       ;7--DO MORE CONSECUTIVE


;SEQ320

        I10     JRST,4,,10      ;10-FOUND 4 CONSEC. - HALT
        I10     TRZ,17,,3       ;11-CLEAR ADR 34,35
        I10     ADDI,17,,40000  ;12-GO TO NXT 16K ADR
        I10     TLNN,17,,1      ;13-SKIP IF NO MORE TO DO
        I10     JRST,0,,2       ;14-ELSE GO & TRY AGAIN
        I10     JRST,4,,15              ;15-HALT - NONE FOUND
        WD36    7777,7777,7777  ;16- -1 FOR COMPARISON
        WD36    0000,0000,0000  ;17-INITIAL PAGE INDEX
ERRP:   .ASCIZ  %AC CODE HUNG. DO "ALL" CMD\%
        .EVEN


;SEQ321

.SBTTL          PROGRAM RUN ROUTINES
                
        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NOHALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE 
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.
.REM    %
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS  0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC                ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT               ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE
.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC                ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;# OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS
RUNJRS: I10     JRST 0,,0
        .EVEN
.REM    %
CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN 
THE TIMING INTERVAL SPECIFIED.
%
CONTIN:


;SEQ322

CON1:   MOV     #2,TIMINT               ;SET TIMING = 30 MS
CON2:   DFXCTT          ;SET RUN FLOP
                SETRUN          ;
        DFXCTT          ;PRESS CONTINUE
                CONBUT          ;
CON3:   CLKPRM                  ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$              ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0               ;GET DTE20 BASE
        
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
        
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     L11             ;YES, RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
CLKERC: BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP>
        BEQ     L10             ;NO, RUN TIMEOUT
        JSR     PC,CLKERR       ;GO TO CLK ERROR POINT
L10:    SEC             ;SET ERROR FLAG
        BR      L12
L11:    CLC                     ;KL HALTLED (NORMAL)
L12:    RTS     R5              ;RETURN
BRKPC:  .WORD   0


;SEQ323

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR: ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>
1$:     JSR     PC,ERRCLK               ;NERXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>
2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>
3$:     JSR     PC,ERRCLK               ;NEXT FUNCTION, 
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>
4$:     ERRMSG  <CALL PC = >
        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT          ;PRINT IT
        ERCRLF          ;CARRIAGE RETURN

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:   103           ;FIRST ONE IS 103


;SEQ324

        INC     ERRFCT          ;SETUP NEXT
        TBIT    30              ;TST PROPER CLK ERR
        RTS     PC              ;RETURN
ERBIT:  .WORD   0               

;SEQ325

.SBTTL          SPECIAL MICRO-CODE ROUTINES
.REM    %
RAMLOD - ROUTINE TO LOAD THE C-RAM WITH DATA POINTED TO BY THE
FIRST PARAMETER.  THE LOA STARTS AT C-RAM ADDRESS 0, AND IT
ENDS WITH THE C-RAM ADDRESS SPECIFIED BYT HE SECOND PARAMETER.
%
RAMLOD:       PUSH    <R1,R2,R3>
        MOV     (R5)+,R1        ;GET BUFFER POINTER
        MOV     (R5)+,R2        ;GET LAST C-RAM ADDRESS
        CLR     R3              ;FIRST C-RAM ADDRESS
1$:     MOV     R3,R0           ;CURRENT C-RAM ADDRESS
        WCRAM                   ;WRITE A C-RAM LOCATION
        ADD     #11.,R1         ;UPDATE BUFFER POINTER
        INC     R3              ;NEXT C-RAM ADDRESS
        CMP     R3,R2           ;DONE?
        BLE     1$              ;NO, LOAD NEXT LOCATION
        POP     <R3,R2,R1>
        RTS     R5              ;RETURN


;SEQ326

.SBTTL          AC LOADERS
.REM    %
ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORYT SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3
ARG1:   FIRST PDP10 ADDRESS TO LOAD.  ADDRESSES 1-17 ARE INTERPRETED
AS IN THE CURRENT AC BLOCK.

ARG2:   NJUMBWER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:   IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACJH PDP10 WORD TO BE LOADED.(I.E.,
THE WORDS ARE TO BE LOADED ARE SCATTERED IN PDP11 MEMORY.)
%
LOAD:   PUSH    R1
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        CLR     DEADR+2         ;CLER HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GETDESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET DATA BYTE POINTER
        TST     WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1
2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER
        DPOSVR                  ;DO DEPOSIT
        POP     R0              
        BCS     6$              ;DEPOSIT ERROR
        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ327

3$:     DEC     WDCNT           ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSIT
6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5                ;TO GET BACK O.K.
        SEC             ;SET ERROR FLAG AGAIN
7$:     POP     R1
        RTS     R5              ;DONE - RETURN
DEADR:  .BLKW    2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0


;SEQ328

.REM    %
        READ 17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1
        MOV     #HDWEXA,R0      ;
        EXCT                    ;DO A SUB AC17,17
        MOV     #ZERO,R0        ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRES
        DFRDMV          ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1
        RTS     R5              ;RETURN
HDWEXA: I10     SUB AC17,,17
        .EVEN
EXAREA: WD36    0,0,0
        .EVEN


;SEQ329

.SBTTL          EXECUTE ROUTINES
.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT          ;PRESS CONTINUE
          CONBUT
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SET THE
0-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC                ;SAVE PC
XQT1:   EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

;SEQ330

;-----SUBROUTINE TO SAVE THE EXISTING MEMORY CONFIGURATION.  THE NUMBER
;       OF CONTROLLERS PROCESSED DEPENDS ON THE VARIABLE 'NUMCON'.
;       CURRENTLY THERE ARE UP 5 MEMORY CONTROLLERS (2 OR 4 MA/MB20S
;       AND MAYBE A DMA20).  ASSOCIATED WITH EACH OF THESE CONTRS ARE 2
;       PDP11 WORDS TO SAVE THE CONFIGURATION.  IF NEW CONTROLLER TYPES
;       ARE DEFINED THIS ROUTINE WILL PROBABLY HAVE TO BE ALTERED.

NUMCON=5        ;CURRENT MAXIMUM NUMBER OF CONTROLLERS
SAVMCN: LOAD    1,GTMCNF,13     ;LOAD AC PRGM (AC1-13)
        PUSH    R1              ;SAVE REG
        MOV     #CONTAB,R1      ;PTR TO CONF TABLE SAVES TIME & SPACE
        RUN     1
        BCS     3$              ;AC ROUTINE HUNG
2$:     READ17                  ;GET FUNCTION 0 RESULT
        MOVB    3(R0),(R1)+     ;INTERLEAVE BITS TO TABLE
        CONTIN                  ;DO FUNCTION 1
        BCS     3$              ;AC ROUTINE HUNG
        READ17                  ;GET FUNCTION 1 RESULT
        MOVB    (R0)+,(R1)+     ;REQUEST ENABLE BITS TO TABLE
        BIC     #170317,-2(R1)  ;CLR JUNK FROM INT & RQ EN BITS
        MOVB    (R0)+,(R1)+     ;MOV ADR BOUNDS STUFF
        MOVB    (R0)+,(R1)+     ;DITTO
        BIC     #140003,-2(R1)  ;CLR JUNK BITS FROM ADR BOUNDS
        CONTIN                  ;NEXT FUNCTION 0
        BCC     4$
3$:     ERRORA  TIMERR          ;AC ROUTINE HUNG?
4$:     CMP     R1,#CONTAB+<4*NUMCON>   ;DONE WITH ALL CONTRS YET?
        BLO     2$              ;NO...KEEP GOING
        POP     R1              ;GET BACK REG SAVED EARLIER
        RTS     R5              ;RETURN TO CALLER
;-----THE CONFIGURATION TBLE. 2 BYTES AND A WORD PER CONTROLLER.
CONTAB: .REPT   NUMCON
        .BYTE   000             ;THE INTERLEAVE BITS (00II0000)
        .BYTE   000             ;THE WORD REQUEST ENABLE BITS (0000RRRR)
        .WORD   00000           ;THE ADR BOUNDS BITS (00SSSSLLLLUUUU00)
        .ENDM


;SEQ331


GTMCNF: I10     SETZM,0,,16     ;1--
        I10     IOR,16,,12      ;2--
        IO10    BLKO,PI,,16     ;3--
        I10     JRST,4,,5       ;4--
        I10     AOS,0,,16       ;5--
        IO10    BLKO,PI,,16     ;6--
        I10     JRST,4,,10              ;7--
        I10     ADD,12,,13              ;10--
        I10     JRST,0,,1       ;11-
        WD36    0100,0000,0000  ;12-
        WD36    0200,0000,0000  ;13-
        .EVEN


;SEQ332


;-----SUBROUTINE TO RESTORE THE MEMORY CONFIGURATION.  THIS SUBROUTINE
;       DOES EXACTLY THE OPPOSITE OF SAVMCN.
RSTMCN: PUSH    <R3,R4,R5>      ;SAVE REGS
        LOAD    1,20$,3         ;LOAD THE AC PROGRAM (AC1-3)
        CLR     R5              ;INIT CONTROLLER NUMBER
        MOV     #CONTAB,R3      ;CONF TABLE PTR INIT
;-----SBUS DIAG FUNCTION 0 SETUP
10$:    MOV     #CNFWD0+3,R4    ;DIAG WD PTR SAVES TIME & SPACE
        MOVB    (R3)+,(R4)      ;INTERLEAVE BITS TO WORD
        BISB    (R3)+,(R4)      ;WD RQ BITS TO WORD
        PUSH    R5              ;SCRATCH CONTR # ON STACK
        ROR     (SP)            ;SPLIT CONTR # 4-1
        BCC     1$              ;BR IF EVEN CONTR
        BISB    #200,(R4)       ;ELSE SET ODD CONTR BIT IN WD
1$:     BISB    #100,(R4)+      ;SET CLR 0-5 BIT OF CONTR # TO WD
        MOVB    (SP)+,(R4)      ;HI ORD 4 BITS OF CONTR # TO WD
;-----SBUS DATA FUNCTION 1 WORD SETUP
        TST     (R4)+           ;SKIP DIAG WD STUFF TO LEAVE ALONE
        MOV     (R3)+,(R4)      ;MOV ADR BOUNDS BIT TO WD
        BIS     #2,(R4)+        ;SET LOAD BOUNDS BIT IN WD
        MOV     R5,(R4)         ;CONTR # TO WORD
        SWAB    (R4)            ;POSITION IT PROPERLY
        ASR     (R4)
;-----LOAD SBUS DIAG WORDS AND RUN PROGRAM
        DPOST,4,CNFWD0  ;AC4
        DPOST,6,CNFWD1          ;AC6
        RUN     1
        BCC     2$              
        ERRORA  TIMERR          ;AC PROGRAM DIDN'T HALT
;-----SELECT NEXT CONTROLLER OR EXIT IF DONE
2$:     INC     R5              ;BUMP CONTR #
        CMP     R5,#NUMCON      ;DONE YET?
        BLT     10$             ;NO...CONTINUE
        POP     <R5,R4,R3>      ;RESTORE REGSM
        RTS     R5
;-----LITTLE AC PROGRAM TO DO SBUS DIAGS TO SET MEM CONF.
        .ODD                    ;FORCE EVEN ALIGNMENT FOR CNFWD0
20$:    IO10    BLKO,PI,,4              ;1--DO SBUS DIAG FUNC 0


;SEQ333


        IO10    BLKO,PI,,6      ;2--DO SBUS DIAG FUNC 1
        I10     JRST,4,,1               ;3--HALT
CNFWD0: WD36    0100,4000,0000  ;4--SBUS DIAG FUNCTION 0 WORD
        CNFWD1: WD36    0000,0000,1001  ;6--SBUS DIAG FUNCTION 1 WORD
TIMERR: .ASCIZ  %/MEM CONFIG AC PRGM HUNG/%
        .EVEN
        PH1NUM=^D  33
        PH2NUM=^D  33


;SEQ334

MCRST:
;PAGPB1,MCR[4,55]               MICRO 21(164    KL10 MICROCODE V234, MODIFIED FOR PAGING


;NPB.MIC        09:08 9-FEB-1977                DISPATCH RAM DEFINITIONS

                                                ;1106  ;SPECIAL MICRO-CODE FOR IMPLIMEN
                                                ;1107  ;USE BY THE PAGING DIAGNOSTIC..
                                                ;1108  ;PTWRDT AC,E(OPCODE 00)  ;WRITE D
                                                ;1109   ;                       ;AC CONT
                                                ;1110  ;                        ;E IS PA
                                                ;1111  ;PTREAD AC,E(OPCODE 01)   ;READ TH
                                                ;1112   ;                       ;AC RECE
                                                ;1113   ;                       ;E CONTA
                                                ;1114   ;PTDWRT AC.E(OPCODE 10) ;WRITE D
                                                ;1115   ;                       ;AC CONT
                                                ;1116  ;                        ;E CONTA
                                                ;1117   ;PTOVER AC E(OPCODE 100)        ;PAG TA
                                                ;1118   ;                       ;AC CONT
                                                ;1119   ;                       ;E CONTA
                                                ;1120   ;                       ;TE MATC
                                                ;1121   ;                       ;IF NO M
                                                ;1122   ;DISPATCHER TO DESIRED DIAGNOSE
                                                ;1123           SCAD/A.SCADA/#,#/32.,SC/
UMAC 2340,2354,0001,0000,0302,0000,0026,0040    ;1124           SPEC/SP MEM CYCLE
                                                ;1125
UMAC 2341,2352,3401,2000,0000,0000,4410,0000    ;1126  BIT17:  J/VMA17,SKIP/AR18,AD/OS,
                                                ;1127  COMPT:  AR/SH.SH/AR  SWAP
UMAC    2342,0001,0001,4000,0000,3000,0003,0000 ;1128           DISP/RETURN.J/1
                                                ;1129
                                                ;1130  ;COMMON SUBROUTINE FOR ALL INSTR
                                                ;1131   ;PAGE TABLE DIRECTORY.,. SUB ROUTI
                                                ;1132  ;TO CORRESPOND TO THE STATES OF
                                                ;1133   ;THAT THE MAIN INSTRUCTION CAN X
                                                ;1134   ;ADDRESS SUPPLIED IN THE INSTR
                                                ;1135   ;WILL ALWAYS ACCESS THE CORRECT
                                                ;1136   ;BE SCREWED BY THE PAGE TABLE X0
                                                ;1137   ;STXOR: BR/AR,  ;SAVE "E
                                                ;1138           FMADR/AC0,AD/B,ADB/F
UMAC 2343,2344,3200,2040,0000,0020,0024,0020    ;1139           SPEC/FLAG CTL,FLAG C



;SEQ335

UMAC 2344,2345,4031,0200,0000,0020,0034,0000    ;1141   DISP/BYTE.J/USERBT,AD/A+

                                                ;1142  =01
                                                ;1143  USERBT: AR/AD*.25.AD/B.ADB/BR*2.
                                                ;1144           SPEC/SP MEM CYCLE.SP
UMAC 2345,2341,3201,7000,0000,0000,0026,0110    ;1145           J/BIT17
                                                ;1146  =11
                                                ;1147   SC/SCAD,SCAD/A,SCADA/#.#
UMAC  2347,2350,3201,7000,0302,0000,0010,0200    ;1148   AR/AD*.25,AD/B,ADB/B

UMAC 2350,2341,0001,0000,0000,0000,0026,0220    ;1150           J/BIT17    ;AND CON
                                                ;1151  =0
                                                ;1152  VMA17:  AR/ARMM,ARMM/SCAD EXP,  :
                                                ;1153    SCAD/A+B,SCADA EN/OS
UMAC  2352,2342,0001,0000,2400,2000,0110,0000   ;1154           COND/LD AR0-8, J/COMP
                                                ;1155
                                                ;1156   SC/SCAD,SCAD/A+B,SCADB/5
UMAC 2353,2352,0001,0000,2302,0000,0010,0100     ;1157           J/VMA17
                                                ;1158
                                                ;1159  EXECTR:  J/XCTG0,DISP/SHO-3,SH/SH


;SEQ336

UMAC 2354,2360,0001,0000,0402,0040,0007,0000    ;1160           SC/SCAD,SCADA EN/0S,
                                                ;1161  =0000
                                                ;1162  SCTGO:
UMAC 2360,2370,3200,2000,0000,0020,0010,0000     ;1163  MPTWRDT:  ADB/FM,AD/B,AR/AD,FMADR
                                                ;1164  MPTREAD:  SPEC/SP MEM CYCLE
UMAC 2361,2371,0001,0000,0000,0000,0026,0110    ;1165           SP MEM/PT RD NO PG F
                                                ;1166
                                                ;1167
                                                ;1168  =0
                                                ;1169  MPTDWRT: J/STXOR,CALL/CALL.FIR
UMAC  2362,2343,3300,2000,0000,0020,0050,0000   ;1170           AR/AD,AD/OR,ADB/FM,F
                                                ;1171
                                                ;1172  ;RETURN FROM SUBROUTINE WILL FAL
                                                ;1173           AD/XOR,ADA/AR,ADB/BR.  :A
                                                ;1174  AD/XOR,ADA/AR, AB/BR.:A
                                                ;1175           VMA/AD,MEM/REG FUNC,
                                                ;1176           J/OP10.
UMAC 2363,2374,3102,0000,0000,0307,0010,0304    ;1177           MREG FNC/NO MEM ACCESS;
                                                ;1178
                                                ;1179   :OPCODE 100 IS PAGE TABLE DIRECT
                                                ;1180  MPTDVER: J/STXOR,CALL/CALL.
UMAC  2364, 2343,3300,2000,0000,0020,0050,0000  ;1181           AR/AD,AD/OPR,ADB/FM,F
                                                ;1182
                                                ;1183  :RETURN FROM SUBROUTINE WILL FAL


;SEQ337

                                                ;1184  ;REMAIN UNUSED.. THIS SAVES A JU
                                                ;1185           MEM/REG FUNC,VMA/AD,MREG
                                                ;1186           AD/XOR,ADA/AR,ADC/BR
UMAC 2365, 2375, 3102, 2000,0000,0307,0010,0304 ;1187   J/OP101,AR/AD ;AND F
                                                ;1188
                                                ;1189  ;OPCODES CONTIUED.....110,111
                                                ;1190  ;PAIRED SKIP LOCATIONS FOR DECID
                                                ;1191   ;DIRECTORY VERIFY HAS COME UP WI
                                                ;1192  =0111
                                                ;1193  MATCH:  AD/B,ADR/FM EMADR/ACO
                                                ;1194           COND/ARL IND,CLR/ARR
UMAC 2367,2373,3200,0000,0000,0020,0610,0012    ;1195           J/NORMEND
                                                ;1196
                                                ;1197  2377:
                                                ;1198  NOMTCH:  AR/AD,AD/1S,COND/ARL IND
UMAC 2377,2373,2301,2000,0000,0000,0610,0000    ;1199           J/NORMEND
                                                ;1200  :PTWRDT INSTRUCTION CONTINUED
                                                ;1201  2370:
                                                ;1202  OPOD:  COND/MBOX CTL,MBOX CTL/P
                                                ;1203           ADA/PC,AD/A+1,AR/AD,
UMAC 2370,0000,4031,2000,0000,0340,2310,0010    ;1204           J/0000
                                                ;1205
                                                ;1206  ;PTREAD INSTRUCTION CONTINUED
                                                ;1207  2371:
UMAC 2371,2372,0001,0000,0000,0007,0010,0100    ;1208  OP01:  MEM/REG FUNC,MREG FNC/RE
                                                ;1209  2372:
                                                ;1210   MEM/MB WAIT,COND/DIAG FU
UMAC 2372,2373,0001,3000,0000,0062,2010,0567    ;1211   DIAG FUNC/RD EBUS RE


;SEQ338

                                                ;1212  2373:
                                                ;1213  NORMEND:  FMADR/AC0, COND/FM WRIT


UMAC 2373, 2346, 4031,2000,0000,0320,1010,0000  ;1214           ADA/PC,VMA/AD,J/CFFU
                                                ;1215  2374:
                                                ;1216  OP10:  COND/MBOX CTL.MBOX CTL/P
                                                ;1217           AR/AD,AD/A+1,ADA/PC,
UMAC 2374,2346,4031,2000,0000,0340,2310,0020    ;1218           J/OFFUSER   ;AND BAC
                                                ;1219
                                                ;1220  2375:
                                                ;1221  OP101:  COND/MBOX CTL,MBOX CTL/5
                                                ;1222           ADB/FM,AD/B,FMADR/AC
UMAC 2375,0000,3200,0000,0000,0020,2310,0200    ;1223           J/0000
                                                ;1224  2346:
UMAC 2346,2357,0001,0000,0000,0000,0024,0000    ;1225   OFFUSR:  SPEC/FLAG CTL,K/DAMMIT
                                                ;1226   2357:
                                                ;1227   DAMMIT: CONO/ARL IND.CLR/ARL,AR/
UMAC 2357,0000,0001,2000,0000,0000,0610,0020   ;1228           J/0000
                                                ;1229  ;INITIALIZE THE VMA TO PREVENT A
                                                ;1230  ;ACTUAL MICRO-CODE USED FOR CACH
                                                ;1231  2366:
                                                ;1232  INIC2IR: COND/DIAG FUNC,AD/A,ADA
UMAC 2366,2376,3701,0000,0000,0360,2010,0416    ;1233        DIAG FUNC/CONO PAG,V


;SEQ339

                                                ;1234  2376:
                                                ;1235  CSH2IR: MEM/REG FUNC,MBEG FNC/RE
UMAC 2376,2351,3401,0000,0000,0007,1410,0504    ;1236           COND/LOAD IR,AD/OS  ;
UMAC 2351,2355,0001,0000,0000,0060,0010,0000    ;1237   2351:  TIME/5T
                                                ;1238  2355:  COND/LOAD IR,ADA/AR,AD/S
UMAC 2355,2356,2001,0000,0000,0060,1410,0000    ;1239           TIME/5T
UMAC 2356,2376,0001,0000,0000,0000,0010,0000    ;1240  2356:    TIME/2T,J/CSH2IR
                                                ;1241
                                                ;1242  ;AND NEW PAGE FAIL INSTR
UMAC 1777,2367,0001,0000,0000,0060,0004,0000    ;1243  1777:  J/MATCH,DISP/PG FAIL,TIM
                                                ;1244

;NUMBER OF MICRO WORDS USED:
;       D WORDS=0
;       U WORDS=33


;SEQ340


MCRST2:

;PAGPB2,MCR[4,55]       MICRO 21(164)           KL10 MICROCODE V234,MODIFIED FOR PAGEING
;NPB2,MIC       12:45 8-APR-1977                DISPATCH RAM DEFINITIONS
                                                ;1106  ;SPECIAL MICRO-CODE IMPLIMEN
                                                ;1107  ;USE BY THE PAGING DIAGNOSTIC..
                                                ;1108  ;PTWRDT AC, E(OPCODE 00)  ;WRITE D
                                                ;;1109  ;                       ;AC CONT
                                                ;1110  ;                        E IS PA
                                                ;1111  ;PTREAD AC,E(OPCODE 01)  ;READ TH
                                                ;1112  ;                        ;AC RECE
                                                        ;1113  L                ;E CONTA
                                                ;1114   ;PTDWRT AC,E(OPCODE 10)  ;WRITE 0
                                                ;1115  ;                        ;AC CONT
                                                ;1116  ;                        ;E CONTA
                                                ;1117  ;PTDVER AC,E(OPCODE 100) ;PAGE TA
                                                ;1118  ;                        ;AC CONR
                                                ;1119  ;                        ;E CONTA
                                                ;1120  ;                        ;IF MATC
                                                ;1121  ;                        ;IF NO M
                                                ;1122  
                                                ;1123
                                                ;1124
                                                ;1125  ;DISPATCHER TO DIESIRED DIAGNOSE
                                                ;1126           SCAD/A,SCADA/#,#/32.,SC/

UMAC  2340,2341,0001,0000,0302,0000,0026,0040   ;1127                   SPEC/SP MEM CYCLE
                                                ;1128
                                                ;1129  EXECTR:  J/XCTGO,DISP/SHO-3,SH/SH
UMAC  2341,2360,0001,0000,0402,0040,0007,0000   ;1130           SC/ACAD,SCADA EN/0S,
                                                ;1131
                                                ;1132  ;PTWRDT INSTRUCTION CONTINUED
                                                        ;1133
                                                ;1134  CLRUSE:  SPEC/SP MEM CYCLE,MEM/RE
UMAC 2342,0000,0001,0000,0000,0007,0026,0304    ;1135           MREG FNC/NO MEM ACCE
                                                ;1136  OP00B:  COND/MBOX CTL,MBOX CTL/P
                                                ;1137           ADA/PC,AD/A+1,AR/AD,
UMAC 2343,2342,4031,2000,0000,0340,2310,0020    ;1138           J.CLRUSE


;SEQ341

                                                ;1139
                                                ;1140  ;PTREAD INSTRUCTION CONTINUED
UMAC 2344,2345,0001,0000,0000,0007,0010,0100    ;1142
                                                ;1143
                                                ;1144           MEM/MB WAIT COND/DIAG FU
UMAC 2345,2350,0001,3000,0000,0062,2010,0567    ;1145           DIAG FUNC/RD EBUS RE
                                                ;1146
                                                ;1147



;SEQ342

;PAGPB2,MCR[4,55]               MICRO 21(164)   KL10 MICROCODE V234, MODIFIED FOR PAGING
;NPB2,MIC       12:45 8-APR-1977                DISPATCH RAM DEFINITIONS
                                                ;1148  ;THIS IS ONE OF A PAIR OF MICRO-
                                                ;1149  ;TO ON A PAGE FAIL, DEPENDING ON
                                                ;1150  =10011
                                                ;1151  ABORT:  MEM/REG VUNC,MREG FNC/NO
UMAC 2347,0000,4031,0000,0000,0327,0010,0304    ;1152           VMA/AD,AD/A+1,ADZ/PC
                                                ;1153
                                                ;1154
                                                ;1155   NORMEND:  FMADR/ACO,COND/FM WRIT
UMAC 2350,0000,4031,2000,0000,0320,1010,0000    ;1156   ADA/PC,VMA/AD,J/0000
                                                ;1157
                                                ;1158  SETSIG: COND/MBOX CTL,MBOX CTL/S
UMAC 2351,0000,0001,0000,0000,0000,2310,0200    ;1159           J/0000  ;IN ORD
                                                ;1160
                                                ;1161  ;THIS IS THE SECOND OF A PAIR OF
                                                ;1162  ;TO ON A PAGE FAIL, DEPENDING ON
                                                ;1163  =101111
                                                ;1164           MEM/REG FUNC,MREG FNC/NO
UMAC 2357,0000,4031,0000,0000,0327,0010,0304    ;1165           VMA/AD,AD/A+1,ADA/PC
                                                ;1166


;SEQ343

;PAGPB2,MCR[4,55]               MICRO 21(164)   KL10 MICROCODE V234, MODIFIED FOR PAGING
;NPB2,MIC       12:45 8-APR-1977                DISPATCH RAM DEFINITIONS
                                                ;1167  =0000
                                                ;1168  XCTGO"
                                                ;1169  MPTWRDT:  ADB/FM,AD/B/AR/AD,FMADR
UMAC 2360,2373,3200,2000,0000,0020,0024,0000    ;1170           SDPEC/FLAG CTL
UMAC 2361,2344,0001,0000,0000,0000,0026,0110    ;1172           SP MEM/PT RD NO PG F
                                                ;1173
UMAC 2362,2352,0000,0000,0000,0020,0010,0000   ;1174  PAGFLG: AR/AR,ADB/FM,J/OP10
                                                ;1175  ;PAGCTL INSTRUCTION
                                                ;1176  ;SPECIAL MICRO-CODED INSTRUCTION
                                                ;1177  ;FOR A CONYTROL LOGIC TEST.  CODE
                                                ;1178  ;STATUS ON THE MCL BOARD, SETS A
                                                ;1179  ;SUCH AS "ACCESS" "WRITABLE","SO
                                                ;1180  ;FINISHED UP BY FORCING A PAGE F
                                                ;1181  ;"PAGE REFILL","PF HANDLE","PAGE
                                                ;1182  ;CAN ALL BE READ...INSTRUCTION I
                                                ;1183  ;UNLESS YOU ARE IN A SCOPE LOOP
                                                ;1184  ;AT FULL SPEED, ABORTS CLEANLY A
                                                ;1185  ;HAS BEEN EXERCISED, AND THEN RE
                                                ;1186  ;WHEN YOU ENTER HERE. "ACO" HAS
                                                ;1187  ;AND THE INDEX REGISTER(XR=ARX14
                                                ;1188  ;PAGCTL:
UMAC 2363,2365,3202,0600,0000,0000,0010,0000    ;1189           AD/B,ARX/ADX,ADB/BR,J/OP
                                                ;1190
                                                ;1191  ;DISPATCH CODE FOR OPCODE 4... ":
                                                ;1192  CONPAG:
UMAC 2364,2371,3200,2000,0000,0020,0010,0000    ;1193           AR/AD,AD/B,ADB/FM,FMADR/


;SEQ344
                                                ;1194
                                                ;1195
                                                ;1196  ;BEGIN EXECUTE PORTION OF OPCODE
                                                ;1197  OP11P1: ADB/FM,FMADR,AC0,AR/AD,
UMAC 2365,2366,3200,2000,0000,0020,0010,0000    ;1198           AD/B
                                                ;1199
                                                ;1200           SH/AR,ARX.SH,ADB/FM,AD/B
                                                ;1201           AR/AD,MQ/MQM SEL,CON
UMAC 2366,2367,3200,2412,0000,1020,0710,0003    ;1202           MQ CTL/AD,J/OP11
                                                ;1203



;SEQ345

;PAGPB2,MCR[4,55]               MICRO 21(164)   KL10 MICROCODE V234, MODIFIED FOR PAGING
;NPB2.MIC       12:45 8-APR-1977                DISPATCH RAM DEFINITIONS
                                                ;1204  OP11:    SKIP/ADO,MEM/REG FUNC,VM
UMAC 2367,2376,3711,0000,0000,0327,5510,0204    ;1205           AD/A,ADA/ARX,MREG FN
                                                ;1206
                                                ;1207  =110
                                                ;1208  ;IF HERE NO "MCL UEBR REF# IS RE
                                                ;1209           MEM/AD FUNC,AD/A,ADA/AR,
UMAC 2376,2346,3701,0000,0000,0010,0026,0000    ;1210           SPEC/SP MEM CYCLE
                                                ;1211
                                                ;1212  =111
                                                ;1213  ;IF HERE, YES NEED "MCL UEBR REF
                                                ;1214           MEM/AD FUNC,AD/A,ADA/AR,
                                                ;1215           SPEC/SP MEM CYCLE.
                                                ;1216           SP MEM/PT RD NO PG F
UMAC 2377,2346,3701,0000,0000,0010,0026,0110    ;1217           J/MBOXTM
                                                ;1218  2346:
UMAC 2346,2370,0001,0000,0000,0000,0010,0000    ;1219  MBOXTM:  J/MBOXT1
                                                ;1220
                                                ;1221  2370:
UMAC 2370,2351,0001,0000,0000,0020,0010,0000    ;1222  MBOXT1:  J/SETSIG,TME/3T
                                                ;1223
                                                ;1224
                                                ;1225  ;EXECUTE CODEFOR THE CONO PAG 5
                                                ;1226  2371:
UMAC 2371,2372,3701,0000,0000,0060,2010,0416    ;1227  CP4:  COND/DIAG FUNC,DIAG FUNC


;SEQ346

                                                ;1228  2372:  AD/A+1,ADA/PC,VMA/AD,J/0
                                                ;1229           MEM/REG FUNC,MREG FN
UMAC 2372,0000,4031,2000,0000,0327,0010,0304    ;1230           AR/AD
                                                ;1231  2373:
                                                ;1232  OPOD:    AD/B,ADB/FM,SPEC/SP MEM
UMAC 2373,2374,3200,0002,0000,0020,5526,0000    ;1233           J/OPODA,FMADR/XR,SKI
                                                ;1234
                                                ;1235  2374:
UMAC 2374,2343,0001,0000,0000,0020,2310,0010    ;1236  OPODA:  COND/MBOX CTL,MBOX CTL/P
                                                ;1237  2375:
UMAC 2375,2374,0001,0000,0000,0000,0026,0200    ;1238           SPEC/SP MEM CYCLE, SP MEM
                                                ;1239
                                                ;12409


;SEQ347

;PAGPB2,MCR[4,55]               MICRO 21(164)   KL10 MICROCODE V234, MODIFIED FOR PAGING
;NPB2.MIC       12:45 8-APR-1977                PAGE TABLE PUBLIC BITS TO SCD FLAGS
                                                ;1241  .TOC   "PAGE TABLE PUBLIC BITS
                                                ;1242
                                                ;1243  ;THIS MICRO-CODE CHECKS THREE GA
                                                ;1244  ;AFFECT THE TWO SCAD FLAGS "SCD
                                                ;1245  ;THE GATES THAT ARE CHECKED ARE
                                                ;1246  ;"SCD PRIVATE INSTR" OR "SCD PUB
                                                ;1247  ;FIRST AN "AD FUNC" IS EXECUTED
                                                ;1248  ;AND/OR "PRIVATE INSTR" FLAGS AS
                                                ;1249  ;WITH AN ADDRESS WHICH WILL SELE   
                                                ;1250  ;CONTAINING "PT PUBLIC" TRUE(ODD
                                                ;1251  ;CODE SKIP IS EXECUTED IN ORDER
                                                ;1252  ;CODE SKIP IS EXECUTED IN ORDER
                                                ;1253  ;(IF AR BIT3=0) OR "CLK MB XFER"
                                                ;1254  ;THEN LOOPS BACK TO THE BEGINNING
                                                ;1255  ;TO CHECK THAT THE CORRECT FLAGS
                                                ;1256  2352:
                                                ;1257  OP10:    SPEC/FLAG CTL.FLAG CTL/L
UMAC 2352,2353,3701,0000,0000,0000,0024,0622    ;1258           AD/A,ADA/AR
                                                ;1259  2353:
UMAC 2353,2356,3701,0000,0000,0300,0010,0000    ;1260           VMA/AD,AD/A,ADA/AR
                                                ;1261  2356:
                                                ;1262           MEM/AD FUNC,AD/A,ADA/AR,
UMAC 2356,2354,3701,0000,0000,1050,0007,0000    ;1263           SH/AR,DISP/SHO-3
                                                ;1264  2354:
                                                ;1265           SPEC/FLAG CTL,FLAG CTL/P
UMAC 2354,2362,0001,0000,0000,0000,0024,0412    ;1266           J/PAGFLG
                                                ;1267
                                                ;1268  2355:
UMAC 2355,2362,0001,0000,0000,0002,0010,0000    ;1269           MEM/MB WAIT,J/PAGFLG


;SEQ348

                                                ;1270
                                                ;1271
                                                ;1272  ;SPECIAL MICRO WORD TO CAPTURE P
UMAC 1777,2347,0001,0000,0000,0060,0004,0000   ;1273  1777:    J/ABORT,DISP/PG FAIL,TIM

                                                ;1274

;NUMBER OF MICRO WORDS USED:
;       D WORDS =  0
;       U WORDS = 33


;SEQ349

.SBTTL *PSTOR* PAGING TEST STORAGE LOCATIONS
;STORAGE FOR DTE20 ADDRESS POINTERS
        .EVEN

.DELAY:  0      ;(XXX00)
.DAT3:   0      ;(XXX02)
.DAT2:  0       ;(XXX04)
.DAT1:  0       ;(XXX06)
.TENA1:  0      ;(XXX10)
.TENA2:  0      ;(XXX2)
.BC10:  0       ;(XXX16)
.BC11:   0      ;(XXX16)
.T10AD:  0       ;(XXX20)
.T11AD:  0       ;(XXX22)
.T10DT:  0       ;(XXX24)
.T11DT: 0       ;(XXX26)
.DIAG1:  0      ;(XXX30)
.DIAG2:  0       ;(XXX32)
.STDTE:  0      ;(XXX34)
.DIAG3:  0      ;(XXX36)
        .EVEN

;STORAGE FOR SOME 36-BIT WORDS AND THE CRAM ADDRESS WORD
ONES:   .WORD   -1,-1,-1        ;SOURCE OF ALL ONES
ZERO:   .WORD   0,0,0                   ;ZERO'ED 36-BIT WORD
EWORD1:  .WORD  0,0,0           ;A36-BIT WORD
DDRAM:
PATBUF:
EWORD2:  .WORD  0,0,0           ;ANOTHER ONE
TMPBE1: .WORD   0,0,0           ;TEMP. 36-BIT BUFFER
$MICRO: .WORD   0,0,0,0,0,0             ;STORGE FOR MICROWORD
$$CRAD:  0                      ;STORAGE FOR CRAM ADDRESS
DSAVE:  .WORD   0
$DDRMS:        .WORD   0               ;TEMP STORAGE LOC FOR "DRAM ROUTINES"


;SEQ350

;ASSIGN LITERAL AREA
$$LITT=.        ;START OF LITERAL AREA
$$FF=$$CLIT     ;FIRST FREE
.END    STARTA

 S@p&