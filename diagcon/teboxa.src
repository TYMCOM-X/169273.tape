;SEQ042

.TITLE  TEBOXA   EBOX TESTS PART 1

 
 
 
 
 
 
 
 
 
        .ENABL  ABS,AMA
        .=3000
 
 
 
 

 
   
 
   
        .LIST           MD,MC,MEB
        .NLIST          CND,BEX
        ESTSIZ=         ^D100
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20         ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM











































































































































































































































































































































































































.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE















































































































































































































































































































































































.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
 
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM
 
 
 
 
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
 
 
 
 

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
 
 
 
 


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
 
 
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
 
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
 
 
        JSR     PC,(R3)                 ;DO INITIALIZATION
 
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
                "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
 
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FT3             ;12
        FTT     FT6             ;14
        FTT     FTNON          ;16 -FT8 NOT USED
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTNON           ;30 - FTMEM INHIBITED
        FTT     FTPRM           ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %
FT3T:   FTM.    <HEDFT3,IDFTAB,IBPTAB,IMSK08,IEXP08,ACTFT3>

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
%

FT6T:   FTM.    <ICRADR,ACT80,EXP80,DIFF80>


.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

 

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

 

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACT80:  AC80
ACTFT3: ACTF3
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
DIFF80: DIF80
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXP80:  XP80
HEDFT3: HEDF3
IBPTAB: IBPTB
ICRADR: ICRAD
IEXP08: IXP08
IDFTAB: IDFTB
IMSK08: IMK36
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT    ERCAD,<.ASCIZ %C-RAM ADDRESS: %>
        .LIT    ERBTH,<.ASCIZ %INDEX%>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER



;SEQ087

.REM    %
STACK ENTRY IS INDEX,,ACTUAL DATA.  THERE MAY BE MORE THAN ONE ENTRY 
LAST IS FLAGGED WITH BIT 15=1.
(ROUTINE IS USED FOR EBOX TEST DCOMP ROUTINE ERRORS)
        %

ACTF3:  CLR     INX.            ;START AT ZEROTH ENTRY
        PCRLF
1$:     MOVB    1(R5),R3
        BIC     #177600,R3
        MOV     R3,R0           ;PRINT THE INDEX
        PNTOCT          
        PMSG    <_>             ;MAKE SURE IT GETS PRINTED
        PUSH    R3              ;SAVE INDEX

        SUB     INX.,R3
        POP     INX.

        ADD     R3,DGP.
        ADD     R3,BYP.
        ADD     R3,EXP.
        ADD     R3,MKP.
        MOVB    @DGP.,FT8DF
        BICB    #200,FT8DF      ;CLEAR GARBAGE
        MOV     #28.,R2
        MOVB    @BYP.,R1        ;GET BYTE PTR TO RIGHT BIT
        ROR     R1              ;0 OR 1 TO C-BIT
        BCC     2$              ;0 SAYS 20-35
        MOV     #12.,R2 
2$:     ASR     R1              ;FLUSH EXTRA BIT
        SUB     R1,R2           ;GET LEFTMOST BIT NBR
        MOV     R2,R0
        ADD     #7,R0
        MOVB    R0,F8BTL        ;LAST BIT
        MOVB    R2,F8BTF        ;FIRST BIT
        CLR     R3
        BISB    #200,R3         ;LEFT BIT MASK
3$:     TSTB    F8BTF           ;RIGHT IF BIT # POS
        BPL     4$
        ASR     R3              ;ELSE FIND
        INCB    F8BTF
        BR      3$
4$:     MOV     EXP.,R1         ;EXPECTED PTR
        MOV     R5,R2           ;ACTUAL PTR
        BICB    @MKP.,(R1)      ;INSURE
        BICB    @MKP.,(R2)      ;ZEROES WHERE NO TEST
        JSR     PC,PRDBYT       ;TEST AND PRINT NAMES
        TST     (R5)+           ;LOOK FOR END
        BPL     1$              ;MORE TO REPORT
        RTS     PC              ;DONE - BACK TO SCAN

;SEQ088

.REM    %
STACK CONTAINS (11-BYTE) 80-BIT ACTUAL DATA
        %
AC80:   MOV     R5,R2   
        ADD     #11.,R5         ;AND PASS OVER DATA
        MOV     R2,ACP.         ;SAVE POINTER FOR DIE ROUTINE
        PCRLF
        MOV     #ERACT,R0       ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN

.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER


;SEQ091

.REM    %
        COMPUTE AND TYPE 80-BIT XOR DIFFERENCE
        %
DIF80:  MOV     ACP.,R1         ;POINT TO ACTUAL
        MOV     #DIF.+12.,R2    ;POINT TO RESULT BUFFER
        MOV     EXP.,R3         ;POINT TO EXPECTED
        ADD     #12.,R1
        ADD     #12.,R3
;DO BYTEWISE XOR FROM BACK TO FRONT

1$:     MOVB    -(R1),R0        ;LOAD ACTUAL    
        MOVB    -(R3),-(R2)    ;LOAD EXPECTED
        BICB    R0,(R2)         ;-ACT .AND. EXP
        BICB    (R3),R0         ;ACT .AND. -EXP
        BISB    R0,(R2)         ;ACT .XOR. EXP
        CMP     #DIF.,R2        ;BACK TO START YET ?
        BNE     1$
        PCRLF
        MOV     #ERDSC,R0       ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN


.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER


.REM    %
STACK CONTAINS (11-BYTE) 80-BIT EXPECTED DATA
        %

XP80:   MOV     R5,R2
        BGT     1$              ;IF PLUS, A REAL POINTER
        ROR     R2              ;SAVE 0 OR 1 BIT
        MOV     #ZMK.,R2        ;ASSUME ZEROES
        BCC     1$              ;BRANCH IF ZERO
        MOV     #ALL7,R2        ;NO - IT'S ONES

1$:     ADD     #11.,R5         ;PASS OVER STACK DATA
        MOV     R2,EXP.         ;SAVE FOR DIF ROUTINE
        PCRLF
        MOV     #ERCOR,R0       ;POINT TO HEADER
        JMP     TYP80           ;GOT YPE, RETURN TO SCANNER


;SEQ094

.REM    %
PRINT BYTE TABLE ERROR FORMAT HEADER
        %
HEDF3:  PCRLF
        MOV     #ERBTH,R0
        PNTAL
        MOV     #ERSCT,R0
        PNTAL
        RTS     PC              ;GO BACK TO SCAN

.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN


;SEQ095

.REM    %
STACK HAS POINTER TO A C-RAM ADDRESS
        %
ICRAD:  PCRLF
        MOV     #ERCAD,R0       ;PRINT C-RAM ADDRESS HEADER
        PNTAL
        MOV     @(R5)+,R0       ;GET THE ADDRESS
        PNTOCT
        RTS     PC

.REM    %
EIGHTBIT BYTE EXPECTED DATA
        %

IXP08:  MOV     (R5)+,EXP.
        RTS     PC

.REM    %
STACK POINTS TO BASE OF DIAG FCN TABLE
        %
IDFTB:  MOV     (R5)+,DGP.      ;PICK UP BASE
        RTS     PC              ;BACK TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC


;BUFFER PACKING ROUTINE TO SUPPORT ACTF3

TYP08:  MOVB    #ASSP,-(R3)             ;SPACE AT RIGHT END
        MOV     #-8.,TEM.               
        JSR     PC,BINPAK               ;DO THE BYTE
        MOVB    #ASSP,-(R3)             ;LEADING SPACES
        MOVB    #ASSP,-(R3)             ;2
        ADD     #2,SPCNT         ;FAKE IT
        RTS     PC


;ROUTINE TO TYPE 80-BIT DATA AS 5 16-BIT OCTAL WORDS. THE
;ADDRESS OF A HEADER TO BE TYPED AT THE LEFT MARGIN IS SUPPLIED
;IN R0. THE POINTER TO THE BACKWARDS 10-BYTE DATA IS IN R2.


TYP80:  PNTAL
        MOV     R2,R3           ;SAVE STARTING POINT
        ADD     #10.,R3         ;POINT TO THE END
1$:     MOVB    -(R3),R0                ;GET ODD BYTE
        SWAB    R0
        CLRB    R0
        BISB    -(R3),R0                ;GET EVEN BYTE
        PNTOCT
        MOV     #ASSP,R0
        PNTCHR
        CMP     R3,R2           ;DONE YET?
        BNE     1$
        MOVB    10.(R3),R0
        PNTOCS                  ;PRINT DISP FIELD
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT        ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
INX.:    .WORD 0
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138



;SEQ116

.SBTTL  *EMAC*  EBOX DIAGNOSTIC MACRO DEFINITIONS
.MACRO  $CLRWD  LOC
        .IF NB LOC
        CLRWRD          ;CLEAR 5 BYTES BEGINNING
        .WORD LOC       ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        CLRBUF          ;CLEAR 36 BIT BUFFER
        .ENDC
        .ENDM
.MACRO  $SETWD  LOC
        .IF NB LOC
        SETWRD          ;SET ONES TO 36 BITS BEGINNING
        .WORD LOC       ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        SETBUF          ;1'S TO 36 BIT BUFFER
        .ENDC
        .ENDM
.MACRO  $ROLWD  LOC
        .IF NB LOC
        ROLWRD          ;ROTATE 36-BIT BUFFER AT LOC
        .WORD LOC               ;LEFT ONE BIT
        .ENDC
        .IF B LOC
        ROLBUF          ;ROTATE 36-BIT BUFFER LEFT
        .ENDC
        .ENDM
.MACRO  $RORWD  LOC
        .IF NB LOC
        RORWRD          ;ROTATE 36-0BIT BUFFER AT LOC
        .WORD LOC       ;RIGHT ONE BIT
        .ENDC
        .IF B LOC
        RORBUF          ;ROTATE 36-BIT BUFFER RIGHT
        .ENDC
        .ENDM

;SEQ117

.MACRO  $MOVWD  S,D
        MOVWRD          ;MOVE 5 BYTES

        .WORD S         ;FROM S
        .WORD D         ;TO D
        .ENDM
.MACRO  $COMWD
        COMBUF          ;PUT COMPLIMENT OF EWORD1 IN EWORD2
        .ENDM
.MACRO  $CLRMI  LOC
        .IF NB LOC
        CLRMIC          ;CLEAR 12-BYTE MICROWORD
        .WORD LOC       ;BUFFER STARTING AT LOC
        .ENDC
        .IF B LOC
        CLR$M           ;CLEAR MICRO-WORD BUFFER
        .ENDC
        .ENDM
.MACRO  $COMBF
        COMBUF          ;PUT COMPLIMENT OF EWORD1 INTO EWORD2
        .ENDM


;SEQ118

.MACRO  $ITAB   .TABLE,.DATA,.ITEMS
        .IF NB .TABLE
        MOV     #.TABLE,R1      ;R1 HAS ADDRESS OF DCOMP TABLE
        .ENDC
        .IF NB .DATA
        MOV     #.DATA, R2      ;R2 HAS ADDRESS OF DATA TO LOAD
        .ENDC
        .IF NB .ITEMS
        MOV     #.ITEMS, R3     ;R3 IS NUMBER (OCTAL) OF ENTRIES TO DO
        .ENDC
        JSR     PC,ITAB ;INITIALIZE DCOMP TABLE


.ENDM

;SEQ119

.MACRO  $AD     .AD,.ADA,.ADB
        .IF NB .AD
        ADT             ;LOAD $MICRO WITH AD = .AD
        .WORD .AD!<.ADA*BIT6>!<.ADB*BIT9>       ;.ADA AND ADB = .ADB
        .ENDC
        .IF B .AD
        AD              ;LOAD AD FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $AR     .ARM,.ARXM
        .IF NB .ARM
        ART             ;LOAD $MICRO WITH ARM = .ARM
        .WORD .ARM!<.ARXM*BIT3> ;AND ARSM = .ARXM
        .ENDC
        .IF B .ARM
        AR              ;LOAD AR FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $BR     BRLOAD,BRXLOD
        .IF NB BRLOAD
        BRT             ;LOAD $MICRO WITH BR LOAD = BRLOAD
        .WORD BRXLOD!<BRLOAD*BIT1>      ;AND BRX LOAD = BRXLOAD
        .ENDC
        .IF B BRLOAD
        BR              ;LOAD BR FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $COND   VAL
        .IF NB VAL
        CONDT           ;SET COND FIELD OF $MICRO
        .WORD   VAL     ;TO VAL
        .ENDC
        .IF B VAL
        COND            ;LOAD COND FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ120


.MACRO  $DISP   VAL
        .IF NB VAL
        DISPT           ;SET DISP FIELD OF $MICRO
        .WORD   VAL     ;TO VAL
        .ENDC
        .IF B VAL
        DISP            ;LOAD DISP FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $EACAL  VAL
        .IF NB VAL
        EACLT           ;SET EACALL FIELD
        .WORD VAL
        .ENDC
        .IF B VAL
        EACALL          ;LOAD EACALL FIELD OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $FE     VAL
        .IF NB VAL
        FET             ;SET FE LOAD = VAL
        .WORD   VAL     ;IN $MICRO
        .ENDC
        .IF B VAL
        FE              ;LOAD FE FIELD SOF $MICRO FROM R0
        .ENDC
        .ENDM

.MACRO  $FM     VAL
        .IF NB VAL
        FMT             ;SET FM ADR SEL FIELD
        .WORD VAL       ;OF $MICRO TO VAL
        .ENDC
        .IF B VAL
        FM              ;LOAD FM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ121

.MACRO  $J      VAL
        .IF NB VAL
        JT              ;SET THE J FIELD OF
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        J               ;LOAD J FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MEM    VAL
        .IF NB VAL
        MEMT            ;SET MEM FIELD OF
        .WORD   VAL     ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        MEM             ;LOAD MEM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MQ     VAL
        .IF NB VAL
        MQT             ;SET MQ SEL BIT IN $MICRO
        .WORD VAL               ;TO VAL
        .ENDC
        .IF B VAL
        MQ              ;LOAD MQ FIELDS OF $MICRO FROM R0
        .ENDC

        .ENDM


;SEQ122

.MACRO  $NUM    VAL
        .IF NB VAL
        NUMT            ;SET MAGIC # FIELD IN
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        NUM                     ;LOAD NUM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SC     VAL
        .IF NB VAL
        SCT             ;SET SCM SEL BIT IN
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        SC              ;LOAD SC FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SCAD   .SCAD,.SCADA,.SCADB
        .IF NB .SCAD
        SCADT           ;LOAD $MICRO WITH SCAD = .SCAD
        .WORD   .SCAD!<.SCADA*BIT3>!<.SCADB*BIT6>        ;SCADA = .SCADA AND ACADB = .SCADB
        .ENDC
        .IF B .SCAD
        SCAD            ;LOAD SCAD FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SH     VAL
        .IF NB VAL
        SHT             ;SET SH-ARMM SEL FIELD
        .WORD   VAL             ;IN $MICRO TO VAL
        .ENDC
        .IF B VAL
        SH              ;LOAD SH FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ123

.MACRO  $T      VAL
        .IF NB VAL
        TT              ;SET T FIELD IN $MICRO
        .WORD   VAL             ;TO VAL
        .ENDC
        .IF B VAL
        T               ;LOAD T FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $VMA    VAL
        .IF NB VAL
        VMAT            ;SET VMA SEL FIELD IN
        .WORD VAL                ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        VMA             ;LOAD VMA FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MWORD
        MWORD           ;LOAD CR FROM MICROWORD BUFFER
        .ENDM
.MACRO  $XBUF
        XCTBUF          ;LOAD CR FROM $MICRO & CLOCK
        .ENDM
.MACRO  $XBUF0
        XBUF0           ;CR FROM $MICRO, 0'S TO BUF & CR
        .ENDM


;SEQ124

.MACRO  $CHKMI  EXP,ERMSG
        CHKMIC          ;COMPARE 12-BYTE MICROWORD R0
        .WORD EXP               ;POINTS TO WITH EXPECTED DATA AT EXP

        .WORD ERMSG!BIT15       ;TYPE MSG AT ERMSG ON ERROR
        .ENDM
.MACRO  $MSK36  MSK,EXP,ACT
        .IF B MSK
        M36             ;COMPARE 36 BITS @R2,MASKED BY@R3 WITH @R4
        .ENDC
        .IF NB MSK
        M36T            ;COMPARE 36 BITS BEGINNING WITH
        .WORD MSK               ;ACT TO EXPECTED DATA
        .WORD EXP               ;AT EXP MASKED BY MASK
        .WORD ACT               ;AT MSK SET C ON EROR
        .ENDC
        .ENDM
.MACRO  $MICLD  NUM,CRAMAD,DATADR
        MICLD           ;WRITE N MICROWORDS TO THE
        .WORD   NUM     ;CRAM BEGINNING WITH CRAM
        .WORD CRAMAD            ;LOC CRAMAD FROM DATA AT DATADR
        .WORD DATADR
        .ENDM
.MACRO  $ACSET          VAL
        .IF NB VAL
        ACSTT           ;LOAD AND CHECK THE AC 

        .WORD VAL               ;REGISTRER WITH VAL
        .ENDC
        .IF     B       VAL
        ACSET           ;LOAD AC# WITH VALUE IN R0
        .ENDC
        .ENDM


;SEQ125


.MACRO  $ACREF  SWITCH
        .IF B SWITCH
        ACREF           ;IF R0=0, NO AC REFERENCES
        .ENDC
        .IF NB SWITCH
        .IF NZ SWITCH
        MOV  #-1,R0     ;CLEAR VMA TO ASSURE
        .ENDC
        .IF Z SWITCH
        CLR  R0         ;SET 1'S TO VMA TO PREVENT
        .ENDC
        ACREF           ;AC REFERENCES
        .ENDC
        .ENDM
.MACRO  $ARLO2  LOC
        MOV  #LOC,R0    ;LOAD THE AR (BUT NOT IR)
        ARLOD2          ;WITH DATA AT LOCATION LOC
        .ENDM

.MACRO  $DCOMP  MSK,FUNC,BYT,EXP,ERMSG
        DCOMP           ;DO BYTE TABLE COMPARE
        .WORD MSK               ;MASK TBLE STARTS AT MSK
        .WORD    FUNC   ;FUNCTION TABLE AT FUNC
        .WORD BYT       ;BYTE TABLE AT BYT
        .WORD EXP       ;EXPECTED DATA TABLE AT EXP
        .WORD ERMSG!BIT15       ;PRINT MSG AT ERMSG ON ERROR
        .ENDM
.MACRO  $MCOMP
        MCOMP           ;MODIFY DCOMP'S EXPECTED DATA
        .ENDM
.MACRO  $RCOMP
        RCOMP                   ;RESTORE DCOMPS EXPECTED DATA
        .ENDM


;SEQ126
.MACRO  $MEMRQ
        MEMREQ         ;CHANGE EXPECTED DATA FOR MEM REQ
        .ENDM

.MACRO  $NOMRQ
        NOMREQ          ;CHANGE EXPECTED DATA FOR NO MEM REQG
        .ENDM
.MACRO  $NOC0
        NOCON0          ;EXPECT "-CON COND EN 00-07" FALSE
        .ENDM


;SEQ127


.MACRO  $PAT80  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 12 BYTES TEST PATTERN
        P80                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P80                     ;GET 1ST 12 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PAT36  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 6 BYTE TEST PATTERN
        P36                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P36                     ;GET 1ST 6 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM

.MACRO  $PAT16  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 2 BYTE TEST PATTERN
        P16                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P16                     ;GET 1ST 2 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PATCO                  ;GET NEXT TEST PATTERN TO BUFFER
        PATCON
        .ENDM


;SEQ128

;BASKET -- MACRO TO FIX STACK & SUBTEST # FOR ERROR RETURN TO EXEC FROM A JSR R5 SUBROUT
.MACRO  BASKET
        MOV     (SP),R0         ;GET SUBTEST # &TEMP SAVE IT IN R0
        MOV     R5,(SP)         ;PUT PTR TO ERR MSG ON STACK
        MOV     R0,R5           ;PUT SUBTEST # IN R5
        JMP     FAULT           ;ERROR RETURN
        .ENDM
;BYPNT -- MACRO TO CREATE POINTER TO AN 8 BIT BYTE OF EBUS DATA
.MACRO  BYTPNT  N
        .RADIX 10
        .IIF    GE,N-20,        .BYTE   <<35-N>*4>!^B00
        .IF     LT,N-20
        .IF     LT, N-4
        .BYTE   <<<35-32>-N>*4>!^B10
        .IFF
        .BYTE   <<<35-16>-N>*4>!^B01
        .ENDC
        .ENDC
        .IIF    GE, N-36,       .ERROR N        ;IN A BYTE POINTER IS TOO LARGE
        .RADIX  8
        .ENDM
;WD18  --  MACRO TO TURN 18 BIT WORDS INTO INV BYTE FORMAT
        .MACRO          WD18    B18.23,B24.35

        .BYTE B24.35&377,<<B18.23&17>*20>!<<B24,35&7400>/400>,<B18.23&60>/20
        .ENDM
;WD36   -- MACRO TO TURN 36 BIT WORDS INTO INV BYTE FORMAT
.MACRO  WD36    A, XB, C,ZETA
        .NLIST
        .IIF    B,ZETA,STAT36=0
        .IIF    NB,ZETA,ZETA
        .BYTE <377&C>
        .BYTE   <<C&7400>/400>!<<XB&17>*20>
        .BYTE   <XB&7760>/20
        .BYTE   <A&377>
        .BYTE   <STAT36*20>!<<A&7400>/400>
        .LIST
        .ENDM


;SEQ129

.MACRO EXPECT  XX,XB,XC,XD,XE,XF,XG,XH
.NLIST
        XX
        XB
        XC
        XD
        XE
        XF
        XG
        XH
        .BYTE AR        ;AR REG INDEX
        .BYTE BR        ;BR REG INDEX
        .BYTE AD        ;AD REG INDEX
        .BYTE ARX       ;ARX REG INDEX
        .BYTE   BRX     ;BRX REG INDEX
        .BYTE   ADX     ;ADX REG INDEX
        .BYTE   MQ      ;MQ REG INDEX
        .BYTE   FM      ;FM REG INDEX
.LIST
        .ENDM
.MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7,X8
.NLIST
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D5
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8!<<X1&3400>/^D256>
        BDS0.4=<X6&37>
        .BYTE B72.79,B64.71,B56.63
        .BYTE B48.55,B40.47,B32.39
        .BYTE B24.31,B16.23,B08.15
        .BYTE B00.07,BDS0.4,0
.LIST
        .ENDM

;SEQ130

.MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7,X8
.NLIST
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>

        B64.71=<<3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D
        B40..47=<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D5
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&37>
        .BYTE B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4,0
.LIST
        .ENDM

        .MACRO          DRMPAT  A,B,J
        .NLIST          SRC
        .BYTE J&17,<A*10>!B,<J&360>/20
        .LIST SRC
        .ENDM

.MACRO DRMDISPATCH      A,B,J
        .NLIST  SRC
        .BYTE   J&17,<A*10>!B,<J&3760>/100
        .LIST SRC

.ENDM


;SEQ131


.MACRO  EXCRAD  D
        .BYTE   <D&3700>/100,D&77
        .ENDM
.MACRO  EBURST  X
        MOV     #X*2,R0
        BURST
        .ENDM
.MACRO  ARLODE  ADDR

        .IF NB ADDR
DFWRTT
        ADDR    ;ADDRESS OF DATA FOR THE AR
        LDAR    ;FUNCTION TO LOAD THE AR
        .ENDC
        .IF B ADDR
        MOV     #LDAR,R0        ;DIAG FUNCTION TO LOAD AR       DFWRT
        DFWRT
        .ENDC
        .ENDM
;CRA6DISP -- A MACRO TO CREATE A TABLE OF
        ;       C-RAM START ADDRESS
        ;       EBUS 36BIT DATA POINTERS
        ;       NUMBER OF CLOCK TICS
.MACRO  CRA6DISP        RAMST,DPNT,CLKTIC
        .WORD           RAMST!BIT15
        .BYTE   DPNT
        .BYTE   ^D CLKTIC
        .ENDM
;SEVERAL MACROS USED ONLY BU THE LAST DTE/PI ITNERFACE TEST
;EBOXON - MACRO TO RESET THE KL10 AND LEAVE THE EBOX RUNNING THE HALT LOOP
.MACRO  EBOXON
        MOV     #STARTM,R0      ;GET START ADDRESS OF MICRO-CODE
        WWADR                   ;SET ADRESS AND RESET THE KL10
        DFXCTT          ;NOW EXECUTE DIAGNOSTIC FUNCTION
        STRCLK                  ;TO START THE CLOCK FREE RUNNING
        .ENDM
;CONOPI - MACRO TO EXECUTE A CONO PI INSTR, THEN DROP EBOX TO HALT LOOP
.MACRO  CONO.PI  INSTR
        MOV     #CONO.PI!BIT15,R0       ;START ADDRESS OF CONO MICRO-CODE
        WWADR                   ;SET ADDRESS WITH NO RESET


;SEQ132


        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITIONAL EBOX CLOCK
        DFWRTT          ;DIAG FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO SEND DATA TO AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;CLOCK ON AGAIN
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;PLUS FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;CONO.DTE - MACRO TO EXECUTE CONO DTE,DATA

.MACRO  CONO.DTE                INSTR
        MOV     #DTE.I0!BIT15,R0        ;GET START ADDRESS OF CCNO/CONI MICRO-CODE
        WWADR           ;SET ADDRESS WITH NO RESET
        BICB    #3,INSTR+3      ;SET RIGHT OPCODE FOR "CONO"
        BICB    #200,INSTR+2    ;FIRST CLR OLD OPCODE BITS
        BISB    #2,INSTR+3
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCITONEXECUTE
        CECLK   ;CONDITIONAL EBOX CLK
        DFWRTT          ;FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO LOAD DATA TO THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;CLOCK ON AGAIN
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;CONI.DTE - MACRO TO EXECUTE A CONI DTE,DATA THEN RETURN EBOX TO HALT LOOP
.MACRO  CONI.DTE        INSTR
        MOV     #DTE.I0!BIT15,R0        ;GET START ADDRESS OF CONO/CONI MICRO-CODE
        WWADR           ;SET ADDRESS WITH NO RESET
        BICB    #3,INSTR+3      ;SET RIGHT OPCODE FOR "CONO"
        BICB    #200,INSTR+2    ;FIRST CLR OLD OPCODE BITS


;SEQ133

        BISB    #2,INSTR+3      ;AND NOW SET NEW OPCODE BITS
        BISB    #200,INSTR+2    ;FOR CONI TYPE IO INSTRUCTION
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITIONAL EBOX CLOCK
        DFWRT           ;FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO LOAD DATA TO THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;TO TURN THE CLOCK BACK ON
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;IDLE - MACRO TO PUT EBOX INTO A RUNNING IDLE LOOP, AWAITING AN INTERRUPT

.MACRO  IDLE
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;TO STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITION EBOX CLOCK
        DFWRTT          ;FIRST A FUNCTION WRITE
        ZERO            ;WITH ALL ZEROES
        LDAR            ;TO LOAD THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;TURN CLOCK BACK ON AGAIN
        MOV     #INTLP!BIT15,R0 ;GET START ADR FOR IDLE MICRO-CODE
        WWADR           ;AND SET IN EBOX WITH NO RESET
        DFXCTT          ;NOW FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE
        DFXCTT          ;AND FUNCITON EXECUTE
        SETRUN          ;TO SET "RUN"

        .ENDM


;SEQ134

.SBTTL *EQUATE* TRAP, DIAGNOSTIC FUNCTION & BIT DEFINITIONS
;TRAP DEFINITIONS FOR SUBROUTINE CALLS:

        CLRWRD =        TRAP
        SETWRD =        TRAP!1
        ROLWRD =        TRAP!2
        RORWRD  =       TRAP!3
        MOVWRD =        TRAP!4
        CLRMIC =        TRAP!5
        SHOVE =         TRAP!6
        GRAB =          TRAP!7
        AD =            TRAP!10
        AR =            TRAP!11
        BR      =       TRAP!12
        COND =          TRAP!13
        DISP =          TRAP!14
        FE =            TRAP!15
        FM      =       TRAP!16
        J       =       TRAP!17
        MEM     =       TRAP!20
        MQ      =       TRAP!21
        NUM     =       TRAP!22
        SC      =       TRAP!23
        SCAD =          TRAP!24
        SH      =       TRAP!25
        T       =       TRAP!26
        VMA     =       TRAP!27
        ADT     =       TRAP!30
        ART     =       TRAP!31
        BRT     =       TRAP!32
        CONDT   =       TRAP!33
        DISPT   =       TRAP!34
        FET     =       TRAP!35
        FMT     =       TRAP!36
        JT      =       TRAP!37
        MEMT    =       TRAP!40
        MQT     =       TRAP!41
        NUMT    =       TRAP!42
        SCT     =       TRAP!43
        SCADT   =       TRAP!44
        SHT     =       TRAP!45
        TT      =       TRAP!46
        VMAT    =       TRAP!47


;SEQ135

        MWORD   =       TRAP!50
        CHKMIC  =       TRAP!51
        M36     =       TRAP!52
        M36T    =       TRAP!53
        MICLD   =       TRAP!54
        ACSET   =       TRAP!55
        ACSTT   =       TRAP!56
        ARLOD2  =       TRAP!57
        DCOMP   =       TRAP!60
        MCOMP   =       TRAP!61
        RCOMP   =       TRAP!62
        P80     =       TRAP!63
        P36     =       TRAP!64
        P16     =       TRAP!65
        PATCON  =       TRAP!66
        CTLMCR  =       TRAP!67
        CTLCMP  =       TRAP!70
        ACREF   =       TRAP!71
        DATCOM  =       TRAP!72
        DATEVE  =       TRAP!73
        DATODD =        TRAP!74
        CLKMCR =        TRAP!75
        CLKCMP  =       TRAP!76
        IRMCR   =       TRAP!77
        IRCMP   =       TRAP!100
        CLEAR   =       TRAP!101
        CLRBUF  =       TRAP!102
        SETBUF  =       TRAP!103
        ROLBUF  =       TRAP!104
        RORBUF  =       TRAP!105
        CLR$M  =        TRAP!106
        FLGMCR  =       TRAP!107
        FLGCMP  =       TRAP!110
        COMBUF  =       TRAP!111
        SPARE   =       TRAP!112
        PI.CHK  =       TRAP!113
        MEMREQ  =       TRAP!114
        NOMEMR  =       TRAP!115
        NOCON0  =       TRAP!116
        XCTBUF  =       TRAP!117


;SEQ136

        XBUF0   =       TRAP!120
        STUFF   =       TRAP!121
        SCDMCR  =       TRAP!122
        SCDCMP  =       TRAP!123
        AR2SC   =       TRAP!124
        CA2SC  =        TRAP!125
        GETMIC  =       TRAP!126
        INCWRD  =       TRAP!127
        PARCHK  =       TRAP!130
        M.RESPSIM =     TRAP!131
        $PNTUML =       TRAP!132
        RUNCLK  =       TRAP!133
        CRMHLT  =       TRAP!134
        CRADRD  =       TRAP!135
        ECALT   =       TRAP!136
        EACALL  =       TRAP!137

;SEQ137

;DIAGNOSTIC FUNCTION & BIT DEFINITIONS:

;APR BOARD, M8539:
        EAPR    =       ^D13
        RAPR    =       110     ;USE DIAGNOSTIC FUNCTIONS 110-117.

;CLK BOARTD, M8526:
        ECLK    =       ^D35    ;READ CLK DATA ON EBUS BITS 30-35.
        RCLK    =       100     ;USE DIAGNOSTIC FUNCTIONS 100-107.
        LCLK    =       40      ;LOAD CLOCK REGISTERS WITH 40-47.

;CON BOARD, M8525:
        ECON    =       ^D24    ;READ CON DATA ON EBUS BITS 18-24.
        RCON    =       130     ;USE DIAGNOSTIC FUNCTIONS 130-157.
;CRAM BOARD, M8528:
        RCRM    =       140     ;USE DIAGNOSTIC FUNCTIONS 140-147.

;CTL BOARD, M8527:
        ECTL    =       ^D31    ;READ CTL DATA ON EBUS BITS 24-28.
        RCTL    =       100     ;USE DIATGNOSTIC FUNCTIONS 100-107.

;VMA BOARD, M8523:
        RVMA    =       150     ;USE DIAGNOSTIC FUNCTIONS 150-157


;SEQ138

;IR BOARD, M8522:
        EIR     =       ^D17    ;READ IR DATA ON EBUS BITS 12-17.
        RIR     =       130     ;USE DIAGNOSTIC FUNCTIONS 130-137.

;MCL BOARD, M8530:
        EMCL    =       ^D23    ;RED MCL DATA ON EBUS BITS 18-23.
        RMCL    =       100     ;USE DIAGNOSTIC FDUNCTIONS 100-107.

;NEXT ADDRESS BOARD, M8511:
        ECRA    =       ^D5     ;READ CRA DATA ON EBUS BITS 0-5.
        RCRA    =       140     ;USE DIAGNOSTIC FUNCTIONS 140-147.

;SCAD BOARD, M8524:
        RSCAD   =       130     ;USE DIAGNOSTIC FUNCTIOS 130-137.


;SEQ139

;A FEW CONVENTIONS

        SUBNR   =       R5
        BRXIS0  =       BIT0
        BR.IS0  =       BIT0
        NOCARE  =       377
        ARXST   =       BIT1
        NEW.SC  =       BIT2
        NEG1    =       177777
        ZOT     =       0
;EQUATES NECESSARY AS INDEX POINTERS FOR DATA PATH "EDPTST" ROUTINE
        .ZERO   =       0
        .ONES   =       2
        .PATN   =       4
        .PATN1  =       6
        .PATN2   =       10
        .PATN3  =       12
        .PATN4  =       14
        .PATN5  =       16
        .PATN6  =       20
        .PATN7  =       22

        RETURN  =       3       ;MICRO-CODE FOR "RETURN"
        EACAL   =       1       ;MICRO-CODE FOR "EACALL"
;SOME CLOCK COUNT EQUTES NECESSARY FOR THE PI BOARD TEST
        MHZRAT  =       32      ;FINAL CLOCK RATE FOR KL10
        DRPCYC  =       ^D3     ;M-CLKS NECESSARY FOR PI CYCLE TO DROP
                                ;AFTER A PI DISMISS
        PI4CNT  =       ^D17+DRPCYC     ;NO.CLOCKS TO INITIATE A LOAD/TEST
                                ;SEQUENCE ON THE PI BOARD
        FRCXFR  =       <^D8*MHZRAT>+1  ;NO. CLOCKS TO CAUSE "PI XFER FORCE"
                                ; TO SET
;EQUATES FOR CRA6 EBUS DATA POINTERS
        EDATAA=0
        EDATAB=2
        EDATAC=4
        EDATAD=6
        EDATAE=10
        EDATAF  =12
        EDATAG=14
        EDATAH=16
        EDATAI=20
        NOEDAT=377


;SEQ140


.SBTTL  *ETRAP*  EBOX TRAP HANDLER AND TABLE
.REM    %
THIS TRAP HANDLER IS USED TO CALL EBOX SUBROUTINES IN A MANNER
EQUIVALENT TO "JSR R5, SUBROUTINE" CALL.  IT HAS THE ADVANTAGE THAT
IT CAN BE USED BY ISOLATION ROUTINE SHWICH ARE NOT ASSEMBLED WITH THE
SUBROUTINES AND TAKES ONLY A SINGLE PDP-11 WORD PER CALL.  THE COST IS
SPEED.
%
ETRAP:  MOV     R5,ESAVE        ;SAVE R5
        MOV     (SP),R5 ;GET TRAP PC TO R5
        MOVB    -2(R5),R5       ;USE IT TO GET TRAP #
        ASL     R5              ;MULTIPLY TRAP # BY 2
        MOV     $$CNT(R5),ELINK ;PUT TRAP VECTOR IN LINK LOCATION
        POP     R5              ;RESTORE TRAP PC TO R5
        POP     PS              ;RESTORE CALLER'S STATUS
        PUSH    ESAVE           ;PUT R5 ON STACK (FOR RTS R5)
        JMP     @ELINK          ;DISPATCH
ESAVE:  .WORD   0               ;TEMPORARY STORAGE FOR R5
ELINK:  .WORD   0               ;STORAGE FOR LINK ADDRESS

;YE OLDE TRAP TABLE:

$$CNT:  .WORD   $CLRWD  ;TRAP +0
        .WORD   $SETWD
        .WORD   $ROLWD
        .WORD   $RORWD
        .WORD   $MOVWD
        .WORD   $CLRMI
        .WORD   $SHOVE
        .WORD   $GRAB
        .WORD   $AD             ;TRAP+10
        .WORD   $AR
        .WORD   $BR
        .WORD   $COND
        .WORD   $DISP
        .WORD   $FE
        .WORD   $FM
        .WORD   $J
        .WORD   $MEM            ;TRAP+20
        .WORD   $MQ
        .WORD   $NUM
        .WORD   $SC
        .WORD   $SCAD
        .WORD   $SH
        .WORD   $T
        .WORD   $VMA


;SEQ141

        .WORD   $ADT    ;TRAP +30
        .WORD   $ART
        .WORD   $BRT
        .WORD   $CONDT
        .WORD   $DISPT
        .WORD   $FET
        .WORD   $FMT
        .WORD   $JT
        .WORD   $MEMT   ;TRAP +40
        .WORD   $MQT
        .WORD   $NUMT
        .WORD   $SCT
        .WORD   $SCADT
        .WORD   $SHT
        .WORD   $TT
        .WORD   $VMAT
        .WORD   $MWORD  ;TRAP +50
        .WORD   $CHKMI
        .WORD   $MSK36
        .WORD   $MK36T
        .WORD   $MICLD
        .WORD   $ACSET
        .WORD   $ACSTT
        .WORD   $ARLO2
        .WORD   $DCOMP  ;TRAP +60
        .WORD   $MCOMP  
        .WORD   $RCOMP
        .WORD   $PAT80
        .WORD   $PAT36
        .WORD   $PAT16
        .WORD   $PATCO
        .WORD   $CTLMC
        .WORD   $CTLCM  ;TRAP +70
        .WORD   $ACREF
        .WORD   $DATCO
        .WORD   $DATEV
        .WORD   $DATOD
        .WORD   $CLKMC
        .WORD   $CLKCM
        .WORD   $IRMCR


;SEQ142

        .WORD   $IRCMP  ;TRAP +100
        .WORD   $CLEAR
        .WORD   $CLRBF
        .WORD   $SETBF
        .WORD   $ROLBF
        .WORD   $RORBF
        .WORD   $CLR$M
        .WORD   $FLGMC
        .WORD   $FLGCM  ;TRAP +110
        .WORD   $COMBF
        .WORD   $SPARE
        .WORD   $PI.CH
        .WORD   $MEMRQ
        .WORD   $NOMRQ
        .WORD   $NOC0
        .WORD   $XBUF
        .WORD   $XBUF0  ;TRAP +120
        .WORD   $STUFF
        .WORD   $SCDMC
        .WORD   $SCDCM
        .WORD   $AR2SC
        .WORD   $CA2SC
        .WORD   $GETMI
        .WORD   $SPARE  ;SPARE
        .WORD   $PARCH  ;TRAP +130
        .WORD   $SPARE
        .WORD   PNTUML
        .WORD   $RUNCL
        .WORD   $CRMHL
        .WORD   $CRADR
        .WORD   $EACLT
        .WORD   $EACAL

$SPARE: PMSG<TRAP TO UNUSED TRAP!\>
        JMP     NORMAL


 

;SEQ143

.SBTTL *ETAB1B* TEST DISPATCH TABLE

TESTAB: .BYTE   ^D43            ;THERE ARE 43 TESTS
        .BYTE   'E              ;ISOLATION ROUTINE PREFIX AND ENABLED
        .WORD   EBUS0           ;TEST 1:EBUS LINES STUCK HIGH OR LOW
        .WORD   ECLK0           ;TEST 2:CLLOCK BOARD INITIALIZATION
        .WORD   ECRAM0          ;TEST3:COMMAND REGISTER INITIALIZATION
        .WORD   ECTL0           ;TEST 4:CONTROL LOGIC INITIALIZATION
        .WORD   EFLAG0          ;TEST 5:FLAG LOCIG INITIALIZATION
        .WORD   ESCD0           ;TEST 6:10-BIT ARITHMETIC INITIALIZATION
        .WORD   PIZZA0          ;TEST 7:PI LOGIC INITIALIZATION
        .WORD   ECLK1           ;TEST 8:CLOCK BOARD CONTROL REGISTERS
        .WORD   ECLK2           ;TEST 9:SINGLE-STEP CLOCK MODES
        .WORD   ECLK3   ;TEST10-CLOCK BURST COUNTER
        .WORD   ECRAM1          ;TEST 11:DIAGNOSTIC CRAM ADDRESS REGISTER
        .WORD   ECRAM2          ;TEST12;CRAM DATA PATHS
        .WORD   ECRAM3          ;TEST13;CRAM ADDRESSING
        .WORD   ECRAM4          ;TEST 14:CRAM PARITY NETWORK
        .WORD   ECLK5           ;TEST 15:CLOCK DELAY (MICROCODE "T" FIELD)
        .WORD   EDRAM1          ;TEST 16:IR & DRAM ADDRESS REGISTERS (7XX OFF)
        .WORD   EDRAM2          ;TEST 17:DRAM I/0 AND JRST DECODING
        .WORD   EDRAM3          ;TEST 18:DRAM DATA PATHS
        .WORD   EDRAM4          ;TEST 19:DRAM ADDRESSING
        .WORD   EDRAM5          ;TEST 20:DRAM PARITY NETWORK
        .WORD   ECTL1           ;TEST 21:"DISP"FIELD, AR/ARX/MQ CONTROL LOGIC
        .WORD   ECTL2   ;TEST 22:ADXCRY LOGIC
        .WORD   ECON1           ;TEST 23:"COND" FIELD DECODING
        .WORD   ECON2           ;TEST 24:CONO APR,PI, PAG AND DATA0 LOGIC
        .WORD   ECON3           ;TEST 25:UCODE & PROCESSOR STATE REGISTERS
        .WORD   EAPR2           ;TEST 26:DECODING OF # FIELD WITH COND/EBUS AND MBOX CTL
        .WORD   EAPR3           ;TEST 27:PREVIOUS CONTEXT AND AC BLOCK REGISTERS
        .WORD   EAPR4           ;TEST 28:FM ADR LOGIC
        .WORD   EMCL1           ;TEST29:AD FUNCTION LOGIC, VMA HELD FLOPS, FLAGS_AD
        .WORD   EMCL2           ;TEST 30:"MEM" FIELD REQUEST STORAGE  SXCT/PXCT/VMA LOG
        .WORD   EMCL3           ;TEST 31:VMA CONTEXT STORAGE LOGIC
        .WORD   EAPR5           ;TEST 32:FM BLOCK SELECTION
        .WORD   EFLAG2          ;TEST 33:BASIC FLAG LOGIC
        .WORD   ECRA01          ;TEST 34:DISP RAM TO CONTROL REG, DISP ENABLES
        .WORD   ECRA02          ;TEST 35;DISPATCH CODES, 1,2,3,&6 +AREAD LOGIC
        .WORD   ECRA03          ;TEST 36:DISPATCH CODES 30,32,33 & 35 + NORM LOGIC
        .WORD   ECRA04          ;TEST 37:J-FIELD AND CRA LOG REGISTER - BURST SPEED
        .WORD   ECALL1          ;TEST 38:SBR RET BURST FWD ADDRESSING
        .WORD   ECALL2          ;TEST 39:SBR RET BURST REVERSE ADDRESSING
        .WORD   ECALL3          ;TEST 40:SBR RET BURST SBR RET 0-10
        .WORD   ECALL4          ;TEST 41:SBR RET RAM ADDRESSING TEST
        .WORD   ECALL5          ;TEST 42:SBR RET RELIABILITY TEST
        .WORD   EAPR6           ;TEST 43:BASIC FM EXTENDED TEST

;SEQ144
;INITIALIZATION ROUTINE DISPATCH TABLE.

INITAB: .WORD   ONCE            ;PRINT PROGRAM HEADER.
        .WORD   IEBUS0          ;TEST 1:EBUS0
        .WORD   ICLK0           ;TEST 2:ECLK0
        .WORD   ICRAM0          ;TEST 3:ECRAM0
        .WORD   ICTL0           ;TEST 4:ECTL0
        .WORD   IFLAG0          ;TEST 5:EFLAG0
        .WORD   ISCD0           ;TEST 6;ESCD0
        .WORD   IPIZZ0          ;TEST 7:PIZZA0
        .WORD   ICLK1           ;TEST 8:ECLK1
        .WORD   ICLK0           ;TEST 9:ECLK2
        .WORD   ICLK3           ;TEST 10:ECLK3
        .WORD   ICLK3           ;TEST 11:ECRAM1
        .WORD   IBUF0           ;TEST 12:ECRAM2
        .WORD   ICRAM1          ;TEST 13;ECRAM3
        .WORD   ICLK0           ;TEST 14:ECRAM4
        .WORD   ICLK3           ;TEST 15:ECLKS

;SEQ144

        .WORD   ICLK3   ;TEST 16:EDRAM1
        .WORD   IDRAM2  ;TEST 17:EDRAM2
        .WORD   IDRAM3  ;TEST 18:EDRAM3
        .WORD   IBUF0   ;TEST 19:EDRAM4
        .WORD   ICLK3   ;TEST 20:EDRAM5
        .WORD   ICTL1   ;TEST 21:ECTL1
        .WORD   ICTL1   ;TEST 22:ECTL2
        .WORD   ICTL1   ;TEST 23:ECON1
        .WORD   ICTL1   ;TEST 24:ECON2
        .WORD   ICTL1   ;TEST 25:ECON3
        .WORD   ICTL1   ;TEST 26:EAPR2
        .WORD   ICTL1   ;TEST 27:EAPR3
        .WORD   ICTL1   ;TEST 28:EAPR4
        .WORD   IMCL1   ;TEST 298:EMCL1
        .WORD   ICTL1   ;TEST 30:EMCL2
        .WORD   ICTL1   ;TEST 31:EMCL3
        .WORD   ICTL1   ;TEST 32:EAPR5
        .WORD   IFLAG1  ;TEST 33:EFLAG2
        .WORD   ICRA0   ;TEST 34:ECRA01
        .WORD   ICRA0   ;TEST 35:ECRA02
        .WORD   ICRA0   ;TEST 36:ECRA03
        .WORD   ICRA0   ;TEST 37:ECRA04
        .WORD   0       ;TEST 38:ECALL1
        .WORD   0       ;TEST 39:ECALL2
        .WORD   0       ;TEST 40:ECALL3
        .WORD   0       ;TEST 41:ECALL4
        .WORD   0       ;TEST 42:ECAL5
        .WORD   IAPR6   ;TEST 43:EAPR6



;SEQ145

.SBTTL *EINIT* INITIALIZATION COD
.SBTTL BRIEF EXPLANATION OF THIS DIAGNOSTIC

.REM    %
MOST OF THE TESTING DONE IN THIS DIAGNOSTIC IS DONE BY BEAMS OF BYTE
TABLE COMPARISONS MADE USING SUBROUTINE DCOMP.  THIS SUBROUTINE REP-
FORMS THE DIAGNOSTIC READS NECESSARY TO "FILL IN" THE TABLE VALUES,
COMPARES THESE AGAINST A LIST OF EXPECTED SIGNAL VALUES, MASKS OFF
COMPARES THESE AGAINST A LIST OF EXPECTED SIGNAL VALUES, MASKS OFF
"DONT CARE" SIGNALS, AND REPORTS ANY DISCREPANCIES.  THE NOMINAL VALUES
FOR THESE COMPARIOSN TABLES (USUALLY THE STATE OF THE LOGIC
FOLLOWING A MASTER RESET) ARE FILLED IN BY THE INITIALIZATION ROUTINES
BEFORE A TEST IS RUN.  THESE TABLES ARE LISTED, FOR CONVENIENCE.
INT HE SECTIONS FOLLOWING THIS EXPLANATION.

OFTEN THE COMPRIOSN IS DONE WITH THELOGIC IN SOME OTHER THAN NOMINAL
STATE.  ANOTHER SUBROUTINE, MCOMP, IS USED TO MODIFY SOME OF THE
EXPECTED DATA IN A BOARD'S DCOMP TABLE BEFORE THE COMPARIOSN IS MADE.
THEN AFTER A SUCCESSFUL COMPARIOSN, THE TABLES ARE RESTORED TO THEIR
NOMINAL STATES BY SUBROUTINE RCOMP.  FINALLY, EACH GROUP OF LOGIC IS SCANNED
BY A SUBROUTINE WHOSE NAME IS OF THE FORM "XXXMCR" (WHERE XXX IS A BOARD
OR GROUP ID) WHICH HAS THE SPECIFIC POINTERS TO THE MASK, FUNCITON EBUS
BIT AND EXPECTED DATA TABLES FOR DCOMP TO USE, THE ERROR MESSAGE TO TYPE,
AND CALLS TO MCOMP, DCOMP AND RCOMP.SEE THE LISTING OF THE SUBROUTINES
FOR MORE DETAILS OF SUBROUTINE OPERATION.

FULL 36-BIT WIDE AND MICROWORD COMPARES ARE ALSO USED.  USING SUBROUTINES
MSK36 AND CHKMIC.

ANOTHER SUBROUTINE, PATTY, IS USED TO GENERATE 16-, 36-, OR 80-BIT
TEST PATTERNS.  THE SUBROUTINE SUPPLIES JUST SUFFICIENT PATTERNS
TO COMPLETELY CHECK THAT THE BITS OF A REGISTER OR DATA PATH
CAN BE INDEPENDENTLY SET TO "0" AND "1" AND THAT NO TWO IBTS INTERACT

EACH TEST BEGINS WITH AN EXPLANATION OF WHAT LOGIC IT IS TESTING 9AND,
IN SOME CASES, HOW THE TESTING WILL BE DONE).  SEE THE LISTING
AT EACH TEST ENTRY FOR THIS IFORMATION.
%

;SEQ146

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE CLOCK BOARD
.REM    %

EBUS

BIT#    INDEX  0  (FR 100)*     INDEX  1  (FR 101)      INDEX  2  (FR102)

30      EBUS CLK        =, 0    BURST 32        = 0     ERROR STOP      = 0

31      SBUS CLK        = 0     BURST 16        = 0     -GO             = 1
32      INSTR 1777      = 0     BURST  8        = 0     EBOX REQ        = 0

33      BURST CNT 0     = 1     BURST 4         = 0     SYNC            =1
34      BURST 128       = 0     BURST 2 = 0     -PAGE FAIL EN   = 1

%
;SEQ147

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE CONTROL LOGIC

.REM    %
BIT#    INDEX  0  (FR 110)              INDEX 1 (FR111)

1       APR SWEEP BUSY EN       = 0
2               X                 X             X               X
3               X                  X            X               X
4               X                 X             X               X
5               X                 X             X               X
6       APR SBUS ERR IN         =  X    APR CURRENT BLOCK 4     =  0
7       APR NXM ERR IN          =  X    APR CURRENT BLOCK 2     =  0
8       APR I/O PF ERR IN         X     APR CURRENT BLOCK 1     =  0
9                                       APR PREV BLOCK 4        =  0

        INDEX  2  (FR 114)              INDEX 3  (FR 115)

2               X               X               X                 X
3               X                 X             X               X

4               X                 X             X                 X
5               X                 X             X                 X
6               X                 X             X                 X

7       APR MBOX CTL 03         = 0     APR MBOX CTL 06         = 0
8       APR FM BLOCK 4          = 0     -APR SET PAGE FAIL      = 1
9       APR FM BLOCK 2          = 0     APR EBUS RETURN         = 0

        INDEX  4  (FR 112)              INDEX  5  (FR 113)

6       APR SBUS ERR EN IN      = 0             X                 X
7       APR NXM ERR EN IN       = 0             X                 X
8       APR I/O PF ERR EN IN    = 0             X                 X
9       APR MB PAR ERR EB IN    = 0     APR FETCH COMP          = 0
10      APR C DIR P ERR EN IN   = 0     APR READ COMP           = 0

11      APR S ADR P ERR IN      = 0     APR WRITE COMP          = 0
12      APR PWR FAIL EN IN      = 0     APR USER COMP           = 0

13      APR SWEEP DONE EN IN    = 0             X                 X

        INDEX  6  (FR 116)              INDEX  7  (FR 117)

6               X               = X             X                 X
7       APR WR PT SEL 0         = 0     APR WR PT SEL 1         = 0

8       -APR PT DIR WR  = 1     -APR PT WR              = 1
9       -APR EBUS REQ           = 1     APR EBUS DEMAND         = 0
10      APR EBUS F01 F          = 0     APR EBOX SEND F02       = 0

11      APR ANY EBOX ERR FLG    =  0    -APR FM WRITE           = 0
12      APR EBOX UBR            = 0     APR EBOX EBR            = 0
13      APR EN REFILL RAM WR    =  X    APR EBOX SPARE          = 0
%


;SEQ148

.REM    %
BIT#    INDEX 10  (FR 110)              INDEX 11 (FR 111)*

9       APR MB PAR ERR IN       = X     
10      APR C DIR P ERR IN      = X     APR PREV BLOCK 2        = 0
11      APR S ADR P ERR IN      = X     APR PREV BLOCK 1        = 0
12      APR PWR FIL IN          = X     SH AR EXTENDED          = 0
13      APR SWEEP DONE IN       = X     APR FM EXTENDED         = X
14      APR APR INTERRUPT       = 0     APR AC + #09            = 0
15              X                X      APR AC + #10            = 0
16              X                X      APR AC + #11            = 0

17                                      APR AC + #12            = 0

        INDEX 12  (FR 114)              INDEX 13  (FR 115)

10      APR FM BLOCK 1          = 0     APR EBOX DISABLE CS     = 0
11      APR FM ADR 10           = 0     -APR WR BAD ADR PAR     = 1

12      APR FM ADR  4           = 0     APR EBOX CCA            = 0
13      APR FM ADR 2            = 0     APR EBOX ERA            = 0
14      APR FM ADR  1           = 0     APR EBOX SBUS DIAG      = 0

15      APR F02 EN              = 1     -MCL MEM/REG FUNC               = 1
16      APR FM 36               = X     -APR EBOX LOAD REG      = 1
17      APR FM ODD PARITY       = X     -APR EBOX READ REG      = 1

        INDEX  14  (FR 130)             INDEX 15 (FR 131)

17              X                 X             X                 X
18      CON WR EVEN PAR ADR      0      CON CACHE LOOK EN               = 0

19      CON WR EVEN PAR DATA    = 0     CON CACHE LOAD EN       = 0
20      CON WR EVEN PAR DIR     = 0             X                 X
21              X               X       -CON KI10 PAGING MODE   = 0

22              X                X      CON TRAP EN             = 0
23              X                X              X                X
24              X               X               X                 X

        INDEX 16  (FR 132)*             INDEX 17  (FR 133)

17              X                X              X                X
18      -CON COND EN 00-07      = 0     -CON SKIP EN 40-47      = 1

19      -CON COND/SEL VMA       = 1     CON COND/VMA_#  = 0
%
;SEQ149

.REM    %
BIT#    INDEX 20  (FR 134)              INDEX 21  (FR 135)

17              X               X               X               X
18      -CON SKIP EN 50-57      =X      CON DELAY REQ   = 0

19      CONCOND/LOAD VMA HELD = 0       -CON LOAD SPEC INSTR    = 1
20      CON SR 00               = 0     CON SR 01               = 0
21      CONNICOND TRAP EN       = 0     CON NICOND 07           = 0

22      CON LOAD ACCESS COND    = 0     -CON INSTR GO           = 1
23      CON UCODE STATE 01      = 0     CON UCODE STATE 03      = 3
24      -CON FM WRITE PAR       = 1     -CON MBOX WAIT          = 1

        INDEX 22  (FR 136)              INDEX 23  (FR 137)      

17              X                 X             X                 X
18      CON AR 36               = X     CON ARX 36              = X

19      -CON VMA SEL 2          = 1     -CON VMA SEL 1          = 1
20      CON SR 02               = 0     CON SR 03               = 1
21      CON NICOND 08           = 0     CON NICOND 09           = 1

22      CON LOAD DRAM           = 0     CON COND ADR 10         = 0
23      CON UCODE STATE 05      = 0     CON UCODE STATE 07      = 0
24      -CON FM XFER            = 1     -CON PI DISMISS         = 1

        INDEX 24  (FR 100)              INDEX 25  (FR 101)

16              X                 X             X                 X
17              X                 X             X                 X

18      VMA HELD OR PC 01       = 0     VMA HELD OR PC 07               = 0
19      VMA HELD OR PC 02       = 0     VMA HELD OR PC 08       = 0
20      VMA HELD OR PC 03        = 0    VMA HELD OR PC 09       = 0

21      VMA HELD OR PC 04       = 0     VMA HELD OR PC 10       = 0
22      VMA HELD OR PC 05       = 0     VMA HELD OR PC 11       = 0
23      VMA HELD OR PC 06       = 0     VMA HELD OR PC 12       = 0
        
        INDEX 26 (FR 102)               INDEX 27  (FR 103)*

16              X                X              X                X
17              X                X              X                 X

18      MCL VMA READ            = 0     MCL VMA PAUSE           = 0
19      MCL MEM/ARL IND         = 0     -MCL REQ EN             = 1
20      MCL PAGE TEST PRIVATE   = 0     MCL VMA UPT             = 0

21      MCL XR PREVIOUS         = 0     MCL VMA ADR ERR         = 0
22      MCL VMA AD              = 0     MCL VMA INC             = 0
23      MCL XR SHORT            = 1     MCL SHORT STACK         = 1
* = THIS BYTE DIFFERENT FOR MODEEL A AND B
%

;SEQ150

.REM    %
BIT#    INDEX 30  (FR104)               INDEX 31  (FR 105)

16              X                 X             X                 X
17              X                 X             X                 X

18      MCL VMA WRITE           =  0    MCL LOAD AR             = 0
19      MCL VMA USER            = 0     MCL VMA PUBLIC          = 0
20      MCL PAGE UEBR REF        = 0    MCL PAGE ADDRESS COND   = 0

21      -MCL VMAX EN            = 0     MCL VMAX SEL 2          = 0
22      -MCL LOAD VMA CONTEXT   = 1     MCL 23 BIT EA           = 0
23      -MCL EBOX CACHE         = 1     -MCL EBOX MAY BE PAGED   1

        INDEX 32  (FR 106)*             INDEX 33  (FR 107)*

16              X                X              X                X
17              X                X              X                X

18      MCL LOAD ARX            = 0     -MCL STORE AR           = 1
19      -MCL VMA PREVIOUS       = 1     -MCL VMA EXTENDED       = 0
20      MCL     PAGE ILL ENTRY  = 0     MCL VMA FETCXH          = 0

21      MCL VMAX SEL 1          = 0     =MCL VMA PAGED FETCH    = 1
22      MCL 18 BIT EA           = 0     MCL MBOX CYC REQ                = 0
23      MCL REG FUNC            = 0     -MCL EBOX MAP           = 1

        INDEX 34  (FR 100)              INDEX 35  (FR 101)

24      CTL SPEC/SCM ALT        = 0     CTL SPEC/CLR FPD        = 0
25      -CTL SPEC/SAVE FLAGS    = 1     -CTL SPEC MTR CTL       = 1

26      CTL ARL SEL 2           = 0     CTL ARL SEL 1           = 0
27      -CTL ARR LOAD A         = 1     -CTL ARR LOAD B         = 1
28      -CTL AR 00-08 LOAD      = 1     -CTL AR 09-17           = 1

29              X                X              X                X
20              X                X              X                X

        INDEX 36 (FR 102)               INDEX 37  (FR 103)*

24      CTL SPEC/GEN CRY 18     = 0     CTL SPEC/STACK UPDATE   = 0
25      CTL COND/AR_EXP         = 0     -CTL DISP RET           = X

26      CTL ARR SEL 2           = 0     CTL ARR SEL 1   = 0
27      CTL MQM SEL 2           = 0     CTL MQM SEL 1           = 0
28      CTL ARX         = 0     CTL ARL SEL 4           = 0

29              X                 X             X               X
30              X                 X             X                 X
31              X                 X             X                 X
* = THIS BYTE IS DIFFERENT FOR MODEL A AND B
%


;SEQ151


.REM    %

BIT#    INDEX 40  (FR 104)              INDEX 41  (FR 105)*


24      CTL SPEC/FLAG CTL       = 0     CTL SPEC/SP MEM CYCLE   = 0
25      -CTL LOAD PC            = 1     CTL ADX CRY 36          = 0

26      CTL ARXL SEL 2          = 0     -CTL ARXL SEL 1         = 1
27      CTL MQ SEL 2            = 1     CTL MQ SEL 1            = 1
28      CTL AR 00-11 CLR        = 0     CTL AR 12-17 CLR        = 0

29              X                 X             X                 X
30              X                 X             X                 X

        INDEX 42  (FR 106)              INDEX 43  (FR 107)*

24      CTL AD LONG             = 0             -CTL INH CRY 18 = 1
25      CTL ADX CRY 36 A        = 0     DIAG MEM RESET          = 0

26      CTL ARXR SEL 2          = 0     -CTL ARXR SEL 1         = 1
27      CTL MQM EN              = 0     -DIAG LOAD EBUS REG     = 1
28      CTL ARR CLR             = 0     -CTL SPEC CALL          = 1

29              X                 X             X                 X
30              X                 X             X                 X
31              X                 X             X                 X

* = THIS BYTE DIFFERENT FOR MODEL A AND B
%


;SEQ152

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE FLAG LOGIC (SCD BOARD)

.REM    %
        
BIT#    INDEX 0 (FR130)         INDEX 1 (FR131)         INDEX 2 (FR132)

2  SCD TRAP REQ 2 = 0           SCD OV          = 0     VMA HELD OR PC00 = 0
3  SCD TRAP CYC 2 = 0           SCD CRY0        = 0     SCD FOV         = 0


4  SCD TRAP CYC 1 = 0           SCD CRY1        = 0     SCD FXU         = 0
5  SCD TRAP REG 1 = 0   -AD CRY 01              = 1     -AD OVERFLOW 00 = 1
6  SCD FPD      = 0     SCD DIV CHK             = 0     -AD CRY -02     = 1


7       X        X              X                X              X                X
8       X         X             X                 X             X                 X
9       X         X             X                X              X                 X


BIT#    INDEX 3 (FR133)         INDEX 4  (FR134)                INDEX 5 (FR135)


2       SCDPCP  = 0             -SCD USER        1              -SCD PUBLIC EWN = 1
3       SCD LOAD FLAGS  = 0     SCD LEAVE USER  = 0                     SCD PUBLIC  = 0

4  -SCAD=0      = 0             -CON PI CYCLE =  1              SCD KERNEL MODE = 1


5       CLR PRI INSTR   = 0             -SCD USER EN    = 1             -SCD PRI INSTR  = 1
6  SCD NI COND 10       = 0     SCD PUBLIC PAGE = 0             -SCD PRI INSTR EN  = 0

7       X               X               X                X              X        X
8       X               X               X                X              X         X
9       X                X              X                 X             X        X


BIT#    INDEX (FR136)           INDEX 7 (FR137)

2  SCD KERNEL/UIOT = 1          SCD ADR BRK INH = 0

3  SCD TRAP MIX 32 = 0          SCD TRAP MIX 34 = 0

4  SCD TRAP MIX 33 = 0          SCD TRAP MIX 35 = 0

5  SCD USER IOT  = 0            SCD ADR BRK CYC = 0
6  -SCD USER IOT EN =1          SCD ADR BRK PRE = 0


7       X               X       -SCD TRAP CLEAR = 1
8       X               X               X               X
9       X               X               X               X

%

;SEQ153

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE 10-BIT ARITHMETIC LOGIC (SCD BOARD)

.REM    %

EBUS                            EBUS                    EBUS

BIT#  INDEX 0  (FR130)          BIT#  INDEX 1  (FR131)  BIT#  INDEX 2  (FR132)

07      SC 05 = 0               04      X               07      FE 05 = 0
08      SC 06 = 0               05      X               08      FE 06 = 0

09      SC 07 = 0               06      X               09      FE 07 = 0
10      SC 08 = 0               07      SC 00 = 0       10      FE 08 = 0
11      SC 09 = 0               08      SC 01 = 0               11      FE 09 = 0

12      X                       09      SC 02 = 0       12      X
13      X                       10      SC 03 = 0               13              X
14      X                       11      SC 04 = 0               14      X

EBUS                            EBUS                    EBUS



BIT#  INDEX 3  (FR133)          BIT#  INDEX 4  (FR120)  BIT#  INDEX 5  (FR120)

04      X                       05      AR 05 = 0               X
05      X                       06      AR 06 = 0               X

06      X                       07      AR 07 = 0               X
07      FE 00 = 0               08      AR 08 = 0       00      AR 00 = 0
08      FE 01 = 0               09      X               01      AR 01 = 0

09      FE 02 = 0               10      X               02      AR 02 = 0
10      FE 03 = 0               11      X               02      AR 03 = 0
11      FE 04 = 0               12      X               04


INDEX 6 (FR134) EBUS BIT # 04:  SC SIGN = 0  (RIGHT JUSTIFIED IN BYTE)
INDEX 7 (FR136) EBUST BIT #:  07:       SC .GE. 36 = 0  (SAME)
INDEX 10 (FR135) EBUS BIT# 07:FE SIGN   = 0  (SAME)
INDEX 11 (FR133) EBUS BIT# 07:  -SCAD=0 = 0  (SAME)

%


;SEQ154

.SBTTL NOMINAL EXPECTED DATA TABLE FOR DRAM TEST 2

.REM    %

EBUS                    EBUS                    EBUS
BIT#  INDEX 0 (FR130)  BIT#  INDEX 1 (FR131)    BIT#  INDEX 2 (FR132)

11      X       X       12      DR ADR 03 = 1   10      X               X
12      X       X       13      DR ADR 04 = 0   11      X               X

13      X       X       14      DR ADR O5 = 1   12      X               IR EN I/0 = 0
14      X       X       15      DR ADR 06 = 1   13      IR EN AC        = 0
15      DR ADR 00 = 0   16      DR ADR 07 = 0   14      IR AC 09 = 0

16      DR ADR 01 = 1   17      DR ADR 08 = 0   15      IR AC 10        = 1
17      DR ADR 02 = 0   18        X             16      IR AC 11        = 0
18      X               19      X       X       17      IR AC 12        = 0


EBUS                    EBUS                    EBUS

BIT#  INDEX 3 (FR133)   BIT#  INDEX 4 (FR134)   BIT#  INDEX 5 (FR135)

12      DRAM A 00 = X   12      X       X       10      X       X
13      DRAM A 01 = X   13      -IR JRST 0 = 1  11      X       X

14      DRAM A 02 = X   14      DRAM J 01 = 0   12      X       X
15      DRAM B 00 = X   15      DRAM J 02 = 1   13      X       X
16      DRAM B 01 = X   16      DRAM J 03 = 0   14      DRAM J 07 = 1

17      DRAM B 02 = X   17      DRAM J 04 = 1   15      DRAM J 08 = 1
18      X       X       18      X       X       16      DRAM J 09 = 1
19      X       X       19      X       X       17      DRAM J 10 = 0

EBUS
BIT#    INDEX 6 (FR136)

10      X       X
11      X       X

12      X       X
13      IR I/O LEGAL=0
14      X       X

15      X       X
16      X       X
17      X       X

%

;SEQ155

.SBTTL NOMINAL EXPECTED DATA TABLE FOR DRAM TEST 3

.REM    %

EBUS                    EBUS                    EBUS
BIT#    INDEX 0 (FR130) BIT#    INDEX 1(FR131)  BIT#    INDEX 2 (FR132)

11      X       X       13      DR ADR 03 = 1   10      X       X
12      X       X       13      DR ADR 04 = 0   11      X       X

13      X       X       14      DR ADR 05 = 1   12      IR EN I/O = 0
14      X       X       15      DR ADR 06 = 1   13      IR EN AC = 1
15      DR ADR 00 = 1   16      DR ADR 07 =1    14      IR AC 09 = 0

16      DR ADR 01 = 1   17      DR ADR 08 = 1   15      IR AC 10 = 0
17      DR ADR 02 = 1   18      X       X       16      IR AC 11 = 0
18      X       X       19      X       X       17      IR AC 12 = 0

EBUS                    EBUS                    EBUS
BIT#  INDEX 3 (FR133)   BIT#  INDEX 4 (FR134)   BIT#  INDEX 5 (FR135)

12      DRAM A 00 = 0   12      X       X       10      X       X
13      DRAM A 01 = 0   13      -IR JRST 0 = 1  11      X       X

14      DRAM A 02 = 0   14      DRAM J 01 = 0   12      X       X
15      DRAM B 00 = 0   15      DRAM J 02 = 0   13      X       X
16      DRAM B 01 = 0   16      DRAM J 03 = 0   14      DRAM J 07 = 0

17      DRAM B 02 = 0   17      DRAM J 04 = 0   15      DRAM J 08 = 0
18      X       X       18      X       X       16      DRAM J 09 = 0
19      X       X       19      X       X       17      DRAM J 10 = 0

EBUS
BIT#    INDEX 6 (FR136)

10      X       X
11      X       X
12      X       X

13      IR I/O LEGAL=1
14      X       X

15      X       X
16      X       X
17      X       X
%


;SEQ156

.SBTTL ONETIME INITIALIZATION CODE

;DEFINE THE HIGHEST ALLOWABLE CRAM ADDRESS:

        RAMTOP = ^D2047         ;HIGHEST CRAM ADDRESS = 2047

;TYPE PROGRAM NAME AND DO ANY ONETIME INITIALIZATION:

ONCE:   PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TEBOXA\>
        PMSG<KL-10 MODEL B>
        PMSG< CPU EBOX DIAGNOSTIC, PART >
        PMSG<1>
        PMSG< (>
        PMSG<TEB>
        PMSG<OXA>
        PMSG<)\>
        PMSG<	VERSION: >
        PMSG<1.0\>      ;VERSION FOR EBOXA


        MOV     #ETRAP,34               ;MAKE TRAPS COME TO EBOX
        MOV     #340,36         ;SET TRAP STATUS


;SEQ157

;NOW DON'T FORGET TO SETUP DTE20 POINTERS
        PUSH    #^D16           ;LOOP COUNT IS 16

        DTEBAS                  ;CALL FOR DTE20 BASE ADDRESS
        MOV     R0,R1           ;PUT DTE20 BASE ADDRESS INTO R1
        MOV     #.DELAY,R0      ;ADDRESS OF FRIST DTE20 POINTER
1$:     MOV     R1,(R0)+        ;DATA TO POINT
        CMPB    (R1)+,(R1)+     ;ADD TWO TO CONTENTS OF R1
        DEC     (SP)
        BGT     1$              ;CONTINUE IF NOT DONE YET
        POP     R0              ;CLEANUP STACK IF DONE

        RTS     PC


;SEQ158

.SBTTL INITIALIZATIOON ROUTINE ENTRY POINTS

.REM    %
        
BEGIN BOTH TEST'S INITIALIZATION BY ATTEMPTING TO CLEAR MOST STORAGE
ELEMENTS IN THE MACHINE.  THIS IS TO PREVENT THE XOR TESTER FROM FAILING
WHILE THE DIAGNOSTIC IW TESTING LOGIC NOT DIRECTLY RELATED
TO THE STORAGE ELEMENTS.  (THE XOR STILL "SEES" THE OUTPUTS EVEN IF
THEY ARE "DON'T CARES" TO THE TEST.)
%

IEBUS0: MOV     #777,$NOCHK     ;SERT "NO CHECK" INITIALIZATION FLAG
        JSR     PC,ZCRAM        ;ATTEMPT TO CLEAR CRAM
        JSR     PC,ZFMEX        ;AND FM EXTENDED AND FM 36 RAMS
        JSR     PC,ZDRAM        ;AND DRAM
        JSR     PC,ZMCL         ;AND VMA CONTEXT FLOPS ON MCL
        JSR     PC,ZSR          ;AND STATE REG ON CON
$ACSET  0                       ;CLEAR AC#
        $ACREF  1               ;AND VMA.
        DFWRTT                  ;TRY LOADING 1'S TO AR
        ONES                    ;TO TESTS MRESET'S POWER
        LDAR                    ;TO CLEAR THEM.

        JMP     IBUF0           ;CLEAR THE BUFFERS AND RETURN


;SEQ159

;INITIALIZATION FOR CLOCK LOGIC:

ICLK0:  $ITAB   TICK,CLKM0,10   ;LOAD MASK TABLE
        $ITAB   BONG, CLKD0,    ;LOAD NOMINAL DATA
        JMP     IBUF0           ;FINISH WITH CLEARS

ICLK1:  JSR     PC,ICLK0                ;DO ALL OF THE ABOVE
        MRESET                  ;DON'T DISABLE MBOX THIS TIME
        MOVB    #22,BONG+4              ;CHANGE EXPECTED
        RTS     PC              ;DONE

ICLK3:  JSR     PC,ZCRAM0       ;ATTEMPT TO CLEAR CRAM LOC 0
        JSR     PC,ZDRAM0               ;AND IR REGISTER
        JMP     ICLK0           ;AND DO CLOCK STUFF

CLKM0:  .BYTE   300             ;NOMINAL CLOCK TABLE MASK BYTES
        .BYTE   300
        .BYTE   300
        .BYTE   300
        .BYTE   300
        .BYTE   320
        .BYTE   320
        .BYTE   300

CLKD0:  .BYTE   4               ;NOMINAL CLOCK TABLE EXPECTED DATA
        .BYTE   0
        .BYTE   26
        .BYTE   24
        .BYTE   23
        .BYTE  23
        .BYTE   3
        .BYTE   43



;SEQ160

;INITIALIZATION FOR CRAM LOGIC:

;INITIALIZE THE COMMAND REGISTER TO ALL 1'S TO CHECK INITIALIZATION:

ICRAM0: CLR     R0              ;USE CRAM LOC 0
        MOV     #$MICRO,R1      ;USE MICROWORD BUFFER AS DATA
        MOV     R1,R2           ;SECOND COPY
        MOV     #6,R3           ;COUNT WORDS IN BUFFER

ZORCH:  MOV     #177777,(R2)+   ;SET 1'S TO A BUFFER WORD
        DEC     R3              ;COUNT
        BGT     ZORCH           ;KEEP TRUCKIN'

        WCRAM                   ;WRITE IT
        JMP     IBUF0           ;INITIALIZE BUFFERS AND RESET

;CLEAR ALL CRAM LOCATIONS FOR THE ADDRESSING TEST:

ICRAM1: JSR     PC,ZCRAM                ;CLEAR ALL CRAM LOCATIONS
        JMP     IBUF0           ;AND BUFFERS


;SEQ161

;INITIALIZATION FOR DRAM LOGIC:

IDRAM2: MOVB    #377,LION+3             ;MASK OUT A&B FIELD BITS.
        BICB    #BIT7,TIGER+2           ;LET DCOMP SCAN ALL 7 BYTES.
        $ITAB   COUGAR, DRAMD2, 7
        JMP     IBUF0           ;CLEAR BUFFERS

IDRAM3: MOVB    #3,LION+3               ;ALLOW A&B FIELD BITS
        $ITAB   COUGAR, DRAMD3,7        
        JMP     IBUF0           ;CLEAR BUFFERS

DRAMD2: .BYTE   4
        .BYTE   260
        .BYTE   40
        .BYTE   0
        .BYTE   124
        .BYTE   16
        .BYTE   0

DRAMD3: .BYTE   16
        .BYTE   374
        .BYTE   20
        .BYTE   0
        .BYTE   100
        .BYTE   0
        .BYTE   20


;SEQ162

.REM    %
THIS CODE SETS AL CONTROL LOGIC STORAGE ELEMENTS WHICH ARE CLEARED
BY RESET.  A RESET IS DONE AFTER EACH SET OPERATION TO ABORT POSSIBLE
PI OR MBOX CYCLES.  THE FOLLOWING STEPS ARE PERFOMED:

STEP    ACTION                  LOGIC AFFECTED

1       MEM/AD FUNC + AD 1-12   LOAD REQ EN REGS ON APR AND MCL
        SPEC/SP MEM CYCLE       LOAD VMA CONTEXT REGS ON MCL
        COND/SPEC INSTR + #777  LOAD SPEC INSTR REG,SET PI AND
                MEM CYCLE ON CON

2       CONO APR + EBUS 6-13,   SET ALL ERROR INTERRUPT FLOPS ON
                20 AND 23               SPR

3       CONO PI + EBUS 18-20    LOAD REG ON CON

4       CONO PAG + EBUS 18-22   LOAD REG ON CON

5       DATA0 +EBUS 9-12        LOAD COMP REG ON APR

6       LOAD PREV CONTEXT AND   LOAD REGS ON APR
        AC BLOCKS + EBUS 6-17

7       COND/EBOX STATE REG     LOAD EBOX STATE REG ON
                + #252          CON

8       COND/EBUS CTL + #467    LOAD EBUS CTL REG ON APR

9       COND/MBOX CTL + #47     LOAD MBOX CTL REG ON APR
%


;SEQ163

ICTL0:  JSR     PC,IBUF0                ;START WITH CLEAR BUFFERS
        COM     $NOCHK          ;DON'T FORGET INITIALIZATION FLAG
        MOV     #20,R1          ;COND FIELD BEGINS AT 20
        MOV     #MAGIC,R2       ;R2 PTS TO A MAGIC # TABLE
        CLR     R3              ;R3 WILL COUNT STEPS
$SETWD          ;SET 1'S TO 36-BIT BUFFER
        STUFF                   ;AND TO AR
        $MEM    10              ;SET "MEM/AD FUNC" TO BUFFER
        $DISP   26              ;AND "SPEC/SP MEM CY"
        $COND   15              ;AND ?COND/SPEC INSTR"
$NUM    777             ;AN ALL NUMBER FIELD BITS
        $AD     37,0,0          ;AND AD/AR
        $XBUF                   ;EXECUTE THE BUFFER
        JSR     PC,IBUF0                ;MRESET AND CLEAN BUFFERS



;SEQ164

WITCH:  COM     $NOCHK          ;NO CHECKING ON MICROWORD EXECUTES
        INC     R3              ;NEXT STEP...COUNT
        CMP     #5,R3           ;SEE IF TIME TO INCRTEMENT COND FIELD
        BLE     BROOM           ;BRAANCH IF NOT
        INC     R1              ;BUMP COND FIELD
        BR      BATS            ;AND SKIP AR LOADING
BROOM:  $SETWD                  ;LOAD 1'S TO 36-BIT BUFFER
        STUFF                   ;WRITE BUFFER TO AR
BATS:   MOV     (R2)+,R0        ;GET NEXT MAGIC #
        BLT     GHOST           ;GET OUT IF NEGATIVE

        $NUM                    ;OTHERWISE, WRITE # TO BUFFER
        MOV     R1,R0           ;GET CURRENT COND FIELD VALUE
        $COND                   ;WRITE IT TO BUFFER
        $XBUF                   ;EXECUTE BUFFER
        JSR     PC,IBUF0        ;MRESET AND CLEAR BUFFERS
        BR      WITCH           ;PETE AND REPEAT

GHOST:  DFXCTT          ;SET THE RUN FLOP
        SETRUN
        DFXCTT                  ;PUSH THE CONTINUE BUTTON
        CONBUT
        EBURST  3               ;GIVE 'EM TIME TO SET
        BR      ICTL1           ;DONE, NOW DO REGULAR TABLE INIT.
MAGIC:  .WORD   14              ;TABLE OF MAGIC NUMBERS TO USE
        .WORD   15
        .WORD   16
        .WORD   17
        .WORD   224
        .WORD   252
        .WORD   467
        .WORD   47
        .WORD   BIT15           ;STOP CODE


;SEQ165

;INITILIZE THE CONTROL LOGIC'S DCOMP TBLES. CLEAR STORAGE ELEMENTS

ICTL1:  MOVB    #110,CTLFUN             ;RESTORE 1ST BYT'S STUFF
        MOVB    #55,CTLBYT              ;SOMETIMES USED BY TEST FOR 
                                        ;OTHER THINGS...)
        $ITAB   CTLMSK, CTLM1, 44       ;LOAD NOMINAL MASK TABLE
        $ITAB   CTLDAT, CTLD1,          ;AND NOMINAL DATA
 
 
 

ICTLF:  JSR     PC,IBUF0                ;START WITH BUFFERS CLEAR
        MOV     #777,$NOCHK             ;SET THE "NO CHECK" INITIALIZATION FLAG
        JSR     PC,ZMCL         ;CLEAR VMA CONTEXT FLOPS ON MCL
        JSR     PC,ZSR          ;CLLEAR STATE REGISTER
        JSR     PC,ZCRAM0               ;CLEAR CRAM LOC 0
        JSR     PC,ZDRAM0               ;CLEAR IR AND AC FIELD
        $ACSET  0               ;CLEAR AC #
        $ACREF  1                       ;CLEAR VMA SO NO MEM REFGS
        JMP     IBUF0           ;CLEAR BUFFERS & DO RESET


;SEQ166

;CONTROL LOGIC'S MASK TABLE

CTLM1:  .BYTE   177             ;MASK FOR INDEX 0
        .BYTE   360             ;1
        .BYTE   370             ;2
        .BYTE   370             ;3
        .BYTE   0               ;4
        .BYTE   341             ;5
        .BYTE   201             ;6
        .BYTE   200             ;7

        .BYTE   373             ;10
        .BYTE   77              ;11B
        .BYTE   3               ;12
        .BYTE   0               ;13

        .BYTE   217             ;14
        .BYTE   223             ;15
        .BYTE   200             ;16B
        .BYTE   200             ;17

        .BYTE   200             ;20
        .BYTE   200             ;21
        .BYTE   300             ;22
        .BYTE   300             ;23
        .BYTE   300             ;24
        .BYTE   300             ;25
        .BYTE   301             ;26B
        .BYTE   301             ;27B
        .BYTE   300             ;30
        .BYTE   300             ;31
        .BYTE   300             ;32
        .BYTE   300             ;33
        .BYTE   7               ;34
        .BYTE   7               ;35
        .BYTE   7               ;36
        .BYTE   107             ;37B ("DISP RET" UNUSED..BREAKS XOR)

        .BYTE   7               ;40
        .BYTE   7               ;41
        .BYTE   7               ;42
        .BYTE   7               ;43


;SEQ167


;CONTROL LOGIC'S NOMINAL EXPECTED DATA TABLE:



CTLD1:  .BYTE   0               ;EXPECTED DATA FOR INDEX 0
        .BYTE   0               ;1
        .BYTE   0               ;2
        .BYTE   2               ;3

        .BYTE   0               ;4
        .BYTE   0               ;5
        .BYTE   60              ;6
        .BYTE   44              ;7
        .BYTE   0               ;10
        .BYTE   0               ;11
        .BYTE   4               ;12
        .BYTE   107             ;13
        .BYTE   0               ;14
        .BYTE   0               ;15
        .BYTE   74              ;16B
        .BYTE   113             ;17
.BYTE   101             ;20
        .BYTE   45              ;21
        .BYTE   41              ;22
        .BYTE   51              ;23
        .BYTE   0               ;24
        .BYTE   0               ;25
        .BYTE   0               ;26B
        .BYTE   20              ;27B

        .BYTE   3               ;30
        .BYTE   1               ;31
        .BYTE   20              ;32B
        .BYTE   65              ;33B
        .BYTE   130             ;34
        .BYTE   130             ;35
        .BYTE   0               ;36
        .BYTE   100             ;37
        .BYTE   120             ;40
        .BYTE   60              ;41B
        .BYTE   0               ;42
        .BYTE   270             ;43B


;SEQ168

;INITIALIZATION FOR FLAG LOGIC:

;SET ALL THE FLAGS TO TEST RESET:

IFLAG0:JSR      PC,IBUF0        ;START CLEAN
        COM     $NOCHK          ;NO CHECKING
        $SETWD          ;ONES TO THE BUFFER
        STUFF                   ;BUFFER TO THE AR
        $DISP   24              ;"SPEC/FLAG CTL" TO THE BUFFER
        $NUM    20              ;MAGIC # FOR "LOAD FLAGS"
        $XBUF                   ;EXECUTE & FALL INTO TABLE SET UP

IFLAG1: $ITAB   BLAM, FLGD1, 10 ;LOAD NOMINAL EXPECTED DATA
        JMP     IBUF0            ;ZERO BUFFERS, RESET, THEN OUT.

FLGD1:  .BYTE   0               ;INDEX 0
        .BYTE   20              ;1:  "-AD CRY 01"
        .BYTE   30              ;2:  "-AD OVERFLOW 00" & "-AD CRY -02"
        .BYTE   0               ;3
        .BYTE   260             ;4: "-USER","-PI CYCLE"&"-USER EN"
        .BYTE   240             ;5:  "-PUBLIC EN"&"KERNEL MODE"
        .BYTE   210             ;6:  "KERNEL OR UIOT"&"-USER IOT EN"
        .BYTE   4               ;7:  "-TRAP CLR"


;SEQ169

;INITIALIZATION FOR 10-BIT ARITHMETIC (SCAD0 LOGIC TESTS:

;FIRST SET ALL REGS TO 1'S:

ISCD0:  JSR     PC,IBUF0        ;CLEAR BUFFERS
        COM     $NOCHK          ;NO CHECKING

        $SCAD   6,3,3           ;SET SCAD/OR, SCADA/#, SCADB/#
        $SC     1               ;AND SC/SCAD
        $FE     1               ;AND FE/SCAD
        $NUM    777             ;SOME 1'S TO LOAD
        $XBUF                   ;DO IT & FALL INTO TABLE SET UP


ISCD1:  $ITAB    SCDDAT, SCAD1, 12               ;SET UP EXPECTED DATA
        JMP     IBUF0           ;GO CLEAR THINGS.

SCAD1:  .WORD   0,0,0,0,0       ;DATA IS ALL 0'S


;SEQ170

;INITIALIZATION FOR PI LOGIC:

IPIZZ0: MOVB    #234,PIZMSK+4   ;"HONOR INTERVAL" NOT RESETABLE
        MOVB    #357,PIZMSK+3   ;DON'T DETECT STUCK IR OR AD BITS
        MOVB    #PIZEXP,DCOMPX  ;SET DCOMP'S PTR FOR PI BOARD
        BISB    #BIT7,PIZFUN+10 ;SET END OF DCOMP
        JSR     PC,ZCRAM0       ;ZERO C-RAM LOC
        JSR     PC,ZDRAM0       ;AND DRAM LOC
        JMP     IBUF0           ;COMMN FINISH


;SEQ171

;INITIALIZE CONTROL LOGIC AND PC FLAG'S COMPARISON TABLES:

IMCL1:  JSR     PC,ICTL1                ;TAKE CARE OF CONTROL LOGIC FIRST.
        $ITAB   BLAM,MCLD1, 10  ;LAOD FLAG LOGIC EXPECTED DATA
        RTS     PC              ;DONE

MCLD1:  .BYTE   230             ;EXPECT TRAP REQ'S & FPD
        .BYTE   370             ;EXPECT OV, CRY'S & DIV CHK
        .BYTE   370             ;EXPECT PC00, FOV & FXU
        .BYTE   200             ;EXPECT PCP
        .BYTE   40              ;EXPECT -USER & -USEN EN
        .BYTE   130             ;EXPECT -PUB EN, PUB, KERNEL BUT NOT -PRI INST OR EN
        .BYTE   220             ;EXPECT KERN OR IOT, UIOT & -UIOT EN
        .BYTE   214             ;EPECT ADR BRK INH & ADR BRK PREVENT


;SEQ172

;INITIALIZATION FOR CONTROL RAM LOGIC:


ICRA0:  CLR     R0              ;ADDR 0 INTO DIAG ADDR REG
        WWADR                   ;WRITE IT ALONG WITH EBOX RESET
        $CLRMI                  ;CLEAR 80 BITS
        $DISP   21              ;ISSUE SUBROUTINE 'CALL"
        $BR     1,1             ;BR FROM AR AND BRX FROM ARX
        $COND   10              ;ISSUE "FM WRITE"
        $SCAD   0,4,0           ;ISSUE "SCADA/ZEROES"
        $SC     1               ;"LOAD SC"
        $FE     1               ;"LOAD FE"
        CLR     R0              
        MOV     #$MICRO,R1
 
        WCRAM                   ;WRITE WORD TO RAM
        DFXCTT
        STRCLK                  ;TURN ON CLOCK

        DFXCTT
        STPCLK          ;TURN OFF CLOCK

        CLR     ERRLVL          ;CLEAR MAGIC ERROR FLAG LOCATION
        JSR     PC,IBUF0        ;CLEAR BUFFERS
        JSR     PC,CLRSTK       ;CLEAR THE MICROCODE SUBROUTINE STACK
        JMP     ZDRAM0          ;CLEAR DRAM LOCATION 0


;SEQ173

.SBTTL SUBROUTINES USED TO DO VARIOUS INITIALIZATION TASKS

;SUBROUTINE TO CLEAR BUFFERS AND DO A RESET:

IBUF0:  $CLRMI                  ;CLEAR MICROWORD BUFFER
        $CLRMI  EWORD1          ;CLEAR BOTH 36-BIT BUFFERS
        MOV     #BIT15,$$CRAD   ;SET "NO RESET" ON $MWORD FLAG
        CLR     TATTLE          ;NO LEFT OVER MCOMPS
        CLEAR                   ;CLEAR MACVHINE 7 SET MBOX DIABLE
        CLR     $NOCHK          ;CLEAR "NO CHECK" INITIALIZATION FLAG
        RTS     PC              ;RETURN

;SUBROUTINE TO CLEAR ALL OF THE CRAM:

ZCRAM:  CLR     R0              ;STARTING WITH LOCATION 0,
        MOV     #RAMTOP+1,R1    ;CLEAR ALL LOCATIONS
        MICNUL                  ;OF THE CRAM.
        RTS     PC              ;AND RETURN.

;SUBROUTINE TO CLEAR THE DRAM, DRAM LATCHES, AND IR:

ZDRAM:  MOV     #ZERO,R1                ;USE ZERO DATA,
        MOV     #776,R2         ;AND STARTING AT THE HIGHEST EVEN ADR,
1$:     MOV     R2,R0           ;CLEAR EACH PAIR OF DRAM LOCATIONS
        WDRAM
        DEC     R2              ;THEN DECREMENT THE ADDRESS TO
        DEC     R2              ;THE NEXT LOWER EVEN ADDRESS
        BGE     1$              ;AND CONTINUE CLEARING UNTIL ALL HAVE BEEN DONE

        DFXCTT                  ;TNE STROBE THE 0'S TO THE
        DRLTCH          ;DRAM LATCHES
        RTS     PC              ;AND RETURN


;SEQ174


;SUBROUTINE TO ATTEMPT TO CLEAR CRAM LOC 0:

ZCRAM0: CLR     R0              ;CRAM LOCATION 0
        CLR     R1              ;ONE WORD
        MICNUL                  ;EMT TO DO IT
        RTS     PC              ;RETURN

;SUBROUTINE TO ATTEMPT TO CLEAR THE IR AND DRAM LOC 0:

ZDRAM0: MOV     #ZERO,R1
        CLR     R0
        WDRAM

        DFXCTT
        DRLTCH

        RTS     PC      ;RETURN


;SEQ175

;SUBROUTINE TO CLEAR VMA CONTEXT FLOPS ON MCL BOARD:

ZMCL:   MOV     #BIT15,$$CRAD   ;SET UP MICROWORD ADR + NO RESETS
        $COND   37              ;BRING UP "COND/LOAD VMA HELD"
        $XBUF                   ;LOAD CR FROM $MICRO & CLOCK
        RTS     PC              ;RETURN

;SUBROUTINE TO CLEAR STATE REG ON CON BOARD:

ZSR:    $COND   16              ;WRITE 'COND/SR_#" TO BUFFER
        $MWORD                  ;KADUNK!
        $COND   0               ;LEAVE BUFFER CLEAR
        $MWORD                  ;ONE MORECRACK
        RTS     PC              ;RETURN


;SEQ176

;SUBROUTINE TO LOAD UP DCOMP TABLES:
;R1 POINTS TO START OF TABLE TO BE LOADED
;R2 POINTS TO START OF DTA TO LOAD
;R3 IS THE NUMBER OF ENTRIED TO DO

;THERE IS A MACRO TO CALL THIS ROUTINE:
;       $ITAB   TABLE, DATA, ITEMS

ITAB:   SHOVE           ;SAVE REGISTERS
1$:     MOVB    (R2)+,(R1)+     ;LOAD A BYTE
        DEC     R3              ;COUNT
        BGT     1$              ;LOOP TILL DONE
        GRAB                    ;RESTORE REGISTERS
        RTS     PC              ;AND RETURN


;SEQ177

.SBTTL CLRSTK -- ROUTINE TO INITIALIZE THE SBR RET STACK TO ALL 0'S

;       THIS ROUTINE LOADS A ZERO IN EACH SBR RET STACK
;       LOCATION.  IT ALSO CLEARS THE DIAG REG AND PLACES
;       A MICRO INSTRUCTION IN CRAM LOCATION 0, THAT HAS
;       THE EA CALL BIT SET ASW ELL AS THE DISP FIELD
;       SET TO 10 (NOP).
;       IT USES SUBROUTINES IN ECRA/ECALL CODE.

CLRSTK: JSR     PC,ZCRAM0       ;CLEAR CRAM LOC 0
        JSR     PC,INITSX
        JSR     PC,ZEN5         ;;BUILD CALL,DISP,AND
                                ;J FIELDS
        CLR     R0              
        JSR     PC,ZENX         ;WRITE $MICRO TO LOC 0
        DFXCTT                  ;START CLOCK
        STRCLK
        DFXCTT                  ;STOP CLOCK
        STPCLK
        RTS     PC



;SEQ178

.SBTTL SUBROUTINE TO INITIALIZE THE APR FM EXTENDED AND APR FM 36 RAMS:

;THIS CODE WRITE A ZERO IN EACH OF 128 DECIMAL LOCATIONS IN BOTH THE
;APR FM EXTENDED RAM (1X128) AND THE APR FM 36 RAM (1X128).

IAPR6:
ZFMEX:  MOV     #EWORD1+3,R1    ;PTR TO BYTE WITH EBUS 4-11 IN BUFFER
        CLR     R3
        CLRB    CK777           ;CLEAR BLOCK # COUNTER
        CLRB    FMEX00          ;CLEAR WORD COUNTER
        CLRB    FMEX22          ;CONSTANT OF 0
        CLR     FMEX11          ;PASS COUNTER CLEAR TOO

HAYY:   ADD     #1,FMEX11       ;INCREMENT PASS COUNT
        CLEAR                   ;START FRESH
        CLRB    (R1)            ;CLER BITS 4-11 IN BUFFER
        MOVB    CK777,(R1)      ;SET UP EBUS 6-8
        ASLB    (R1)
        ASLB    (R1)
 
        ASLB    (R1)             ;LEFT ALLIGN BLOCK #
        STUFF                   ;LOAD AR FROM BUFFER
        $COND   20              ;SET COND DIAG
        $NUM    25              ;"LOAD AC BLOCK"
        $XBUF0                  ;EXECUTE TO SET AC BLOCKS

;       GET # VALUE FROM TABLE
        MOVB    R3,R0           ;GET NEXT # VALUE
        $NUM                    ;WRITE IT IN THE BUFFER
        INCB    R3              ;UPDATE INDE
        MOV     #7,R0           ;FM ADR TO SEL #'S OIMTO MIXER
                                ;WRITE IT IN BUFFERM
        $FM                     ;WRITE IT IN BUFFER
        CLRB    EWORD1+4                ;CLR BITS 0-3
        MOVB    FMEX22,EWORD1   ;LOAD BITS 28-35
        MOVB    FMEX22,EWORD1+1 ;LOAD BITS 20-27
        MOVB    FMEX22,EWORD1+2 ;LOAD BITS 12-19
        MOVB    FMEX22,EWORD1+3 ;LOAD BITS 4-11
        STUFF                   ;ACTUALLY LOAD AR NOW
        $COND   10              ;WRITE THE "FM WRITE FIELD"
        $XBUF                   ;NOW LOAD THE CR
        INCB    FMEX00          ;UPDATE FM WORD ADDRESS
        CMPB    #17,FMEX00      ;COMPARE


;SEQ179

        BGE     UNB11           ;DO ANOTHER WORD IN CURRENT BBLOCK
                                ;IF BRANCH IS TRUE.
        CLRB    FMEX00
        CLRB    R3
UNB11:  MOV     FMEX11,R0       ;PASS COUNT
        BIC     #177740,R0      ;MAKE MODUL0 32
        CMP     #0,R0           ;LOOK FOR 0 WHICH IS REALLY 32.
        BLT     HAYY            ;DONE INCREMENT BLOCK #
        BR      UNB33           ;NOW INCREMENT BLOCK #
UNB33:  INCB    CK777           ;ADD 1 TO BLOCK #
        CLRB    FMEX22  
        CMP     #10,CK777       ;HERE TO SEE IF WE HAVE DONE
                                ;128 WORDS.
        BGT     HAYY            ;LOOP IF NOT DONE ALL 128 WORDS
        RTS     PC              ;DONE!!

CK777:  .BYTE   0
FMEX00: .BYTE   0
FMEX11: .WORD   0
FMEX22: .BYTE   0

        .EVEN


;SEQ180

.SBTTL *EZRO*  INITIALIZATION TESTS

.SBTTL  TEST 1 (EBUSO): BASIC EBUS & DIAGNOSTIC FUNCTION BUS
.REM   %
THIS TEST ATTEMPTS TO CLEAR THE MACHINE AND RED ALL 0'S THEN ALL 1'S
ACROSS THE EBUS.
%

EBUS0:  PMSG    <STARTING INITIALIZATION TESTS\>        ;TYPE HEADER.
        INC     SUBNR           ;SUBTEST #1
        MOV     #EWORD1,R1      ;PTR TO DATA BUFFER
        MOV     #DPAR,R0
        DFRDMV                  ;READ THE AR INTO THE BUFFER.

        $MSK36  ZERO,ZERO,EWORD1        
        BCC     GOON            ;ERROR?
        JSR     PC,FAULT                ;YES, REPORT IT
        .WORD   0               ;ERROR MSG COMES FROM ISOLATION ROUTINE
GOON:   INC     SUBNR           ;SUBTEST #2
        MOV     #DPMQ,R0        
        DFRDMV          ;READ THE MQ INTO THE BUFFER.

        $MSK36  ZERO,ONES,EWORD1
        BCC     FINI            ;ERROR?
        JSR     PC,FAULT        ;YUP, REPORT IT.
        .WORD   0               ;AGAIN NO ERROR MSG HERE

FINI:   JMP     NORMAL          ;THAT'S ALL, FOLKS!


;SEQ181

.SBTTL TEST 2 (ECLK0):  CLOCK BOARD INITIALIZATION
.REM    %
THIS TESTS THAT THE DIAGNOSTICALLY READABLE SIGNALS ON THE CLOCK BOARD
ARE PROPERLY INITIALIZED BY A MRESET.  THIS TEST (AND THOSE CONCERNED
WITH CLOCK BOARD SIGNALS WHICH FOLLOW0 USES A MASTER COMPARISON SUB-
ROUTINE, CLKCMP, WHICH, IN TURN, USES SUBROUTINE DCOMP.  A TABLE OF
INITIALLY EXPECTED DATA FOR THE CLOCK BOARD APPEARS IN THE INITIAL-
IZATION FILE, EINIT1.P11
%
ECLK0:  CLKPRM          ;PASS COMPARE PTR TO SOURCE/RATE INFO
        CLKCMP                  ;COMPRE INITIAL STATE WITH EXPECTED


 

;SEQ182

.SBTTL TEST 3 (ECRAM0): COMMAND REGISTER INITIALIZATION

.REM    %
THIS TESTS THAT THE MICROCODE DATA REGISTER 9COMMAND REGISTER)
IS ZEROED AFTER A RESET.
%
ECRAM0:
        MOV     #1,R0           ;FOR MODEL B, YOU MUST EXPECT
        EACALL                  ;TO FIND THE CALL BIT SET
        MOV     #BIT15,R0       ;SET SIGN SO READ JUST RETURNS
        RCRAM                   ;CURRENT CR CONTENTS.

        CHKMIC                  ;COMPARE RESULT AGAINST
        .WORD   $MICRO          ;THE BUFFER (=ALL ZERO'S)
        .WORD   0               ;ERROR MSG FROM ISOLATION ROUTINE

        JMP     NORMAL          ;RETURN IF OK.


;SEQ183

.SBTTL TEST 4 (ECTL0): CONTROL BOARDS INITIALIZATION

.REM    %
THIS TESTS WHETHER THE APR, CON CTL AND MCL BOARD LOGIC ASSUMES ITS
EXPECTED STATE FOLLOWING A CLEAR.  THIS TEST (AND THE CONTROL LOGIC
TESTS WHICH FOLLOW) USES A MASTER COMPARISON SUBROUTINE, CTLCMP, WHICH
IN TURN USES SUBROUTINE DCOMP.  A TABLE SHOWING INITIAL EXPECTED DATA
AND MASKING MAY BE FOUND IN THE INITIALIZATION FILE, EINIT1,P11.
%
ECTL0:  CTLCMP          ;COMPARE INITIAL STATE WITH EXPECTED
        JMP     NORMAL          ;DONE, FI NO ERRORS




;SEQ184

.SBTTL TEST 5 (EFLAG0): FLAG LOGIC INITIALIATION

.REM    %
THIS TESTS THAT THE FLAG LOGIC ON THE SCD BOARD ASSUMES ITS
EXPECTED STATE FOLLOWING A CLEAR.  THIS TEST 9AND THE FLAG LOGIC
TESTS WHICH FOLLOW) USES A MASTER COMPARISON SUBROUTINE, FLGCMP,
WHICH IN TURN USES SUBROUTINE DCOMP.  A TABLE SHOWING INITIAL EXPECTED
DATA AND MASKING MAY BE FOUND IN THE INITIALIZATION FILE, EINIT1.P11.
%
EFLAG0: FLGCMP                  ;COMPARE
        JMP     NORMAL          ;DONE, IF NO ERRORS.


;SEQ185

.SBTTL TEST 6 (ESCD0):  10-BIT ARITHMETIC INITIALIZATTION
.REM    %
THIS TESTS THAT THE 10-BIT ARITHMETIC ON THE SCD STARTS OFF IN ITS
EXPECTED STATE FOLLOWING A CLEAR.  TABLES OF THESE VALUES MAY BE
FOUND IN THE INITIALIZATION RILE, EINIT1.P11.
%

ESCD0:  SCDCMP                  ;SEE IF SCAD SIGNALS CLEARED PROPERLY
        JMP     NORMAL          ;THAT'T IT, FOLKS!

.SBTTL TEST 7 (PIZZA0): PI BOARD RESET TEST

;THIS TEST SIMPLY PERFORMS A MASTER RESET OF THE KL10 AND THEN
;ISSUES ENOUGH CLOCKS WHICH WOULD NORMAALLY CYCLE THE PI BOARD.
;SINCE NO REQUSTS SHOULD BE PENDING, THE PI BOARD SHOULD NOT
;CYCLE.  IF THE PI BORD DOES APPEAR TO CYCLE IT OCULD BE THE
;"PIRO" FLOP STUCK, OR THE "EBUS PI00" LINE FROM THE DTE20 STUCK,
;OR THE "PI4, PI2, PI1" LINES STUCK.  EITHER WAY THE PROBLEM IS ISOLATED
;TO THE PI BOARD DTE20, OR TRANSLATOR BOARD.

PIZZA0: INC     R5              ;ONE SUBTEST
        CLEAR                   ;RESET THE KL10
        PI.CHK                  ;PI BOARD RESET SO FAR?
        INC     R5              ;TWO SUBTESTS
        MOV     #^D74,R0        ;NUMBER OF MACHINE CLOCKS TO GIVE
        BURST                   ;GIVE THE CLOCKS

        PI.CHK                  ;AND CHECK THE RESET STATE OF THE PI BOARD NOW
        JMP     NORMAL          ;ALL OK!


;SEQ186

.SBTTL  *ECORE* CLOCK, CRAM AND DRAM TESTS

.SBTTL TEST 8 (ECLK1): BASIC CLOCK CONTROL REGISTERS
ECLK1:  PMSG    <STARTING CLOCK TESTS\> ;SIGN IN, PLEASE.

.REM    %
THIS TESTS THE ABILITY OF THE CLOCK CONTROL REGISTERS ON CLK5 TO LOAD
AND HOLD DATA VIA THE "E" AND "DIAGNOSTIC" BUSES.  THE TEST "FLOATS" A 1
THROUGH THE VARIOUS CONTROL REGISTERS AT EACH POSSIBLE SOURCE/RATE
SELECTION.  THUS THE FACT THAT CLOCKS ARE PRODUCESD AT EACH SOURCE/RATE
COMBINATION (AS WELL AS THE APPEARANCE OF THE CORRECT REGISTER
BITS) IS CHECKED.
%

;LOAD POINTERS:
        MOV     #EWORD1,R1      ;PTR TO 36-BIT BUFFER.

        MOV     #SPRING,R4      ;PTR TO 1ST SOURCE/RATE BYTE.

;LOAD NEXT SOURCE/RATE TO TEST WITH:  (UPDATED SOURCE/RATE PTR IN R4)


ESCAPE: MOVB    (R4),(R1)       ;SOURCE/RATE BITS TO EBUS 32-35 IN BUFFER.
        MOV     #LDSEL,R0               ;DIAG FUNCTION TO LOAC REG TO R0.
        DFWRT                   ;EMT TO DO THE LOAD
        MOV     R4,-(SP)        ;SAVE UPDATED RATE TABLE PTR ON STACK

;AND LOAD REST OF THE POINTERS

        MOV#LEVER,R4            ;PTR TO 1ST DIAGNOSTIC LOAD FUNCTION IN R4.
        MOV     #FACE,R2        ;START OF MCOMP'S # CHANGES TABLE TO R2.
        MOV     #HANDS,R3               ;START OF MCOMP'S VALUE TABLE TO R3.


;SEQ187

;BACK TO HERE FOR EACH NEW DIAGNOSTIC LOAD FUNCTION (I.E. FOR EACH REGISTER).

WHEEL:  MOVB    #10,EWORD1      ;SET EBUS BIT 32 IN BUFFER.

;BACK TO HERE FOR EACH BIT CHECKED.

GEAR:   INSYNC                  ;NEW SUBTEST #.
        MOVB    (R4),R0         ;PUT DIAG FUNCTION IN R0 FOR CALL.
        DFWRT                   ;WRITE DATA TO REGISTER.

        MOV     (SP),R0         ;PTR TO CURRENT SOSURCE/RATE
        CLKMCR                  ;COMPARE BOARD'S STATE WITH EXPECTED.

        ASRB    (R1)            ;SHIFT EBUS DATA TO RIGHT.
        BNE     GEAR            ;WHEN DATA 'FALLS OF END", INNER LOOP DONE.
        MOVB    (R4)+,R0        ;DO ONE MORE WRITE TO CLEAR REGISTER.
        DFWRT                   ;EMT TO DO IT.

        TSTB    (R4)            ;SEE IF AT END OF FUNCTION TABLE.
        BGT     WHEEL           ;NOPE, DO THE NEXT ONE.
        MOV     (SP)+,R4         ;YUP, GETY RATE TABLE POINTER
        INC     R4              ;UPDATE THE SOURCE/RATE TABLE PTR
        TSTB    (R4)            ;NOW SEE IF MORE RATES TO TRY.
        BGT     ESCAPE          ;YUP, GO SWITCH RATES & TRY MORE.
        JMP     NORMAL          ;OTHERWISE RETURN TO EXEC.


;


;SEQ188

;HERE ARE THE SOURCE/RATE BYTES TO USE FOR THIS TEST:

SPRING: .BYTE   3               ;NORMAL OSC, SLOWEST RATE
        .BYTE   2               ;NORMAL OSC, RATE 2
        .BYTE   1               ;NORMAL OSC, RATE 1
        .BYTE   0               ;NORMAL OSC, FASTEST RATE
        .BYTE   4               ;FAST OSC, FASTEST RATE
        .BYTE   14              ;FAST OSC (POS 2), FASTEST RATE
        .BYTE   377             ;DONE MARK

;HERE ARE THE DIAGNOSTIC LOAD FUNCTIONS TO TEST:

LEVER:  .BYTE   LDBRR           ;BURST COUNTER, RIGHT HALF
        .BYTE   LDBRL           ;BURST COUNTER, LEFT HALF
        .BYTE   LDDIS           ;DISABLE BITS
        .BYTE   LDCHK1          ;PAR CHECK BITS
        .BYTE   LDCHK2          ;MISC BITS
        .BYTE   377             ;DONE MARK


;SEQ189

;HERE ARE THE MCOMP TABLES FOR THIS TEST:

FACE:   .BYTE   2               ;SUBTESTS #20N+1 WHERE N=0-5
        .BYTE   2               ;2
        .BYTE   2               ;3
        .BYTE   2               ;4
        .BYTE   1               ;5
        .BYTE   1               ;6
        .BYTE   2               ;7
        .BYTE   2               ;8
        .BYTE   0               ;9
        .BYTE   1               ;10
        .BYTE   1               ;11
        .BYTE   1               ;12
        .BYTE   1               ;13
        .BYTE   1               ;14
        .BYTE   1               ;15
        .BYTE   1               ;16
        .BYTE   1               ;17
        .BYTE   1               ;18
        .BYTE   1               ;19
        .BYTE   1               ;20

;NOTE;  SINCE SUBTEST NUMBERS SIMPLY CYCLE FOR OTHER SOURCE/RATE SETTINGS,
;ONLY THE FIRST SET ARE REFERENCED IN THIS TABLE.  SEE "FACE" TABLE
;FOR HIGHER TEST #'S.


;SEQ190

HANDS:  .BYTE   0               ;
        .BYTE   0               ;SUBTEST #1: "BURST CNT = 0"
        .BYTE   1
        .BYTE   10              ;"BURST 8"
        .BYTE   0
        .BYTE   0               ;SUBTEST #2: "BURST CNT = 0"
        .BYTE   1
        .BYTE   4               ;"BURST 4"
        .BYTE   0               
        .BYTE   0               ;SUBTEST #3: "BURST CNT = 0"
        .BYTE   1
        .BYTE   2               ;"BURST 2"
        .BYTE   0
        .BYTE   0               ;SUBTEST #4: "BURST CNT = 0"
        .BYTE   1               
        .BYTE   1               ;"BURST 1"
        .BYTE   0
        .BYTE   2               ;SUBTEST #5: "BURST CNT=0" & "BURST 128"

        .BYTE   0
        .BYTE   1               ;SUBTEST #6:  "BURST CNT=0" & "BURST 64"
        .BYTE   0
        .BYTE   0               ;SUBTEST #7: "BURST CNT =0"
        .BYTE   1
        .BYTE   40              ;"BURST 32"
        .BYTE   0               
        .BYTE   0               ;SUBTEST #8: "BURST CNT =0"
        .BYTE   1
        .BYTE   20              ;"BURST 16"
        .BYTE   5
        .BYTE   27              ;SUBTEST #10: "EBOX CRM DIS" &"SH AR PAR ODD"


;SEQ191

        .BYTE   6
        .BYTE   7               ;SUBTEST #11:  "EBOX EDP DIS"
        
        .BYTE   7
        .BYTE   47              ;SUBTEST #12: "EBOX CTL DIS"
        .BYTE   4
        .BYTE   20              ;SUBTEST#13: "-FM PAR CHECK"
        .BYTE   5
        .BYTE   31              ;SUBTEST #14:  "-CRAM PAR CHECK" & "SH AR PAR ODD"
        .BYTE   6
        .BYTE   1               ;SUBTEST #15:  "-DRAM PAR CHECK"
        .BYTE   7
        .BYTE   41              ;SUBTEST #16: "-FS CHECK"
        .BYTE   4
        .BYTE   23              ;SUBTEST #17: "MBOX CYCLE DIS"

        .BYTE   5               
        .BYTE   32              ;SUBTEST #18:  +-MBOX RESP SIM" & "SH AR PAR ODD"
        .BYTE   6
        .BYTE   12              ;SUBTEST #19: "-AR/ARX PAR CHECK"
        .BYTE   7
        .BYTE   42              ;SUBTEST #20: "-ERR STOP EN"

        .EVEN



;SEQ192

.SBTTL TEST 9 (ECLK2):  SINGLE-STEP CLOCK MODES

.REM    %
THIS TESTS THE ABILITY OF THE CLOCK BOARD TO GENERATE SINGLE 3- AND M-BOX
CLOCKS AND CONDITIONAL E-BOX CLOCKS AT EACH SOURCE/RATE COMBINATION.
ALSO TESTED AS ARE THE EBUS SBUS CLOCKS.
%
;LOAD POINTERS:

ECLK2:  MOV     #SPRING,R4              ;PTR TO SOURCE/RATE TABLE

;NOTE: R2, WHICH POINTS TO THE NUMBER OF MCOMP CHANGES TO MAKE FOR A SUBTEST, AND RE,
;POINTING TO THE CHANGE TABLE ITSELF, WILL BE LOADED IN THE SUBTEST LOOP.

;ENTER HERE TO IMPLEMENT THE NEW CLOCK RATE & SOURCE

NEWRAT: CLEAR
        MOV     #EWORD1,R1      ;SET DATA PTR

        MOVB    (R4),(R1)       ;NEW SOURCE RATE DATA TO BUFFER
        MOV     R4, -(SP)       ;SAVE UPDATED TABLE PTR
        MOVB    #LDSEL,R0       ;SET UP TO DO RATE SELECT REG LOAD.
        DFWRT                   ;EMT TO DO THE LOAD
        MOV     #FULIST,R1      ;POINT TO START OF DIAG. FUNCTION LIST WITH R1.
        MOV     #STATES,R4      ;POINT TO TABLE OF CLOCK BOARD STATES WITH R4.

NEWFU:  INSYNC                  ;NEW SUBTEST
        MOVB    (R1)+,R0        ;GET NEXT DIAG FUNCTION R0 R0.
        BLT     AHHSO           ;STOP CODE??

        DFXCT                   ;NO, EXECUTE IT.

        MOV     (R4)+,R2                ;LOAD APPROPRIATE MCOMP PTRS TO
        MOV     R2,R3           ;R2 & R3 FROM THE STATE TABLE
        INC     R3

        MOV     (SP),R0         ;PTR TO CURRENT SOURCE/RATE
        CLKMCR

        BR      NEWFU           ;KEEP TRUCKING

AHHSO:  MOV     (SP)+,R4        ;GET SOURCE/RATE PTR OFF STACK
        INC     R4              ;UPDATE IT
        TSTB    (R4)            ;SEE IF DONE
        BGT     NEWRAT          ;NO, DO MORE

        JMP     NORMAL          ;YUP, THIS CASE IS CLOSED.


;SEQ193

;HERE IS A TABLE OF DIAGNOSTIC FUNCTIONS TO DO FOR EACH SUBTEST.


FULIST: .BYTE   SSCLK           ;SUBTESTS #13N+2 WHERE N=0-3:   ;SINGLE STEP.
        .BYTE   SSCLK           ;SUBTEST #3:    SINGLE-STEP.
        .BYTE   SSCLK           ;SUBTEST #4:    SINGLE-STEP.
        .BYTE   SSCLK           ;SUBTEST #5:    SINGLE-STEP.
        .BYTE   SSCLK           ;SUBTEST #6:    SINGLE-STEP.
        .BYTE   SECLK           ;SUBTEST #7:    E-BOX SS.
        .BYTE   SECLK           ;SUBTEST #8:    E-BOX SS.
        .BYTE   SECLK           ;SUBTEST #9:    E-EBOX SS.
        .BYTE   CECLK             ;SUBTEST #10:   COND SS.
        .BYTE   SSCLK           ;SUBTEST #11:   SINGLE-STEP.
        .BYTE   CECLK           ;SUBTEST #12:   COND SS.
        .BYTE   SSCLK           ;SUBTEST #13:   SINGLE-STEP.
        .BYTE   377             ;STOP THE MUSIC

        .EVEN

;HERE IS A TABLE OF CLOCK BOARD STATES FOR EACH SUBTEST.  EACH ENTRY IS A
;POINTER TO ANOTHER TABLE WITH MCOMP DATA IN IT.

STATES: .WORD   STATE1          ;SUBTESTS #13N+2 WHERE N=0-5.
        .WORD   STATE2          ;SUBTEST #3.
        .WORD   STATE3          ;SUBTEST #4.
        .WORD   STATE4          ;SUBTEST #5.
        .WORD   STATE1          ;SUBTEST #6.
        .WORD   STATE5          ;SUBTEST #7.
        .WORD   STATE6          ;SUBTEST #8.
        .WORD   STATE5          ;SUBTEST #9.
        .WORD   STATE4          ;SUBTEST #10.
        .WORD   STATE1          ;SUBTEST #11.
        .WORD   STATE2          ;SUBTEST #12.
        .WORD   STATE3          ;SUBTEST #13.


;SEQ194

;HERE ARE THE REAL MCOMP TABLES.

STATE1: .BYTE   4               ;THERE ARE 4 CHANGES FOR STATE 1.

        .BYTE   0       
        .BYTE   44              ;"EBUS CLK"
        .BYTE   2
        .BYTE   22              ;"SYNC"
        .BYTE   3
        .BYTE   20              ;"-EBOX CLK"
        .BYTE   4
        .BYTE   27              ;"EBOX SOURCE" & "MBOX CYCLE DIS"


STATE2: .BYTE   1               ;THERE IS 1 CHANGE FOR STATE 2.
        .BYTE   0
        .BYTE   64              ;"EBUS CLK" & "SBUS CLK"

STATE3: .BYTE   4               ;THERE ARE 4 CHANGES FOR STATE 3.
        .BYTE   0
        .BYTE   24              ;"SBUS CLK"
        .BYTE   2               
        .BYTE   22              ;"SYNC"
        .BYTE   3
        .BYTE   20              ;"-EBOX CLK"
        .BYTE   4
        .BYTE   27              ;"EBOX SOURCE" & "MBOX CYCLE DIS"
STATE4: .BYTE   0               ;THERE ARE NO CHANGES FOR STATE 4.

STATE5: .BYTE   1               ;THERE IS ONE CHANGE FOR STATE 5
        .BYTE   4
        .BYTE   3               ;"-EBOX SS" & "MBOX CYCLE DIS"
STATE6: .BYTE   2               ;THERE ARE 2 CHANGES FOR STATE 6.
        .BYTE   0
        .BYTE   64              ;"EBUS CLK" & "SBUS CLK"
        .BYTE   4
        .BYTE   3               ;"-EBOX SS" & "MBOX CYCLE DIS"
        .EVEN

;SEQ195
.SBTTL TEST 10 (ECLK3): BURST COUNTER

.REM    %
THIS VERIFIES THAT THE BURST COUNTER DOWN COUNTS TO ZERO AT EACH SOURCE/RATE.
IT DOES NOT VERIFY THAT A CORRESPONDING NUMBER OF CLOCKS ARE PRODUCED
        
AS THIS WOULD REQUIRE MUCH OF THE UNTESTED EBOX LOGIC BE WORKING.  THIS TEST
USES A TABLE AND SUBROUTINE FROM ECLK1.
%
;LOAD POINTERS:

ECLK3:  MOV     #EWORD1,R1      ;PUT PTR TO 36-BIT BVUFFER ON STACK
        MOV     #SPRING,R4              ;R4 POINTS TO SOURCE/RATE BYTE TABLE.

;SET NEXT SOURCE/RTE TO TEST WITH:

VENUS:  CLEAR                   ;START WITH CLEAN MACHINE.
        INSYNC          ;NEW SUBTEST
        MOVB    (R4),(R1)       ;PUT NEXT SOURCE/RATE BYTE INTO BUFFER.
        MOV     #LDSEL,R0       ;DIAG. FUNC. TO LOAD REGISTER TO R0.
        DFWRT                   ;DO EMT TO LOAD REGISTER.

;LOAD THE BURST COUNTER FOR 254 MBOX CLOCKS (127 EBOX CLOCKS):

        MOVB    #17,(R1)        ;SET EBUS BITS 32-35 IN BUFFER.
        MOV     #LDBRL,R0       ;DIAG. FUNC. TO LOAD LEFT 4 COUNTER BITS.
        DFWRT                   ;DO HE LOAD EMT.

        DECB    (R1)            ;SET EBUS BITS 32-34 IN BUFFER.
        MOV     #LDBRR,R0       ;DIAG. FUNC. TO LOAD RIGHT 4 COUNTER BITS.
        DFWRT                   ;DO EMT.


;SEQ196

;READ THE LOADED BURST COUNTER:

        MOV     #SATURN,R2      ;RESET MCOMP'S #-OF-CHANGES PTR
        MOV     #URANUS,R3      ;AND MCOMP'S VALUE PTR

EARTH:  MOV     R4,R0           ;PTR FOR SOURCE/RATE DATE
        CLKMCR          ;DO THE COMPARE

        BIT     #1,SUBNR                ;DECIDE WHERE TO GO NEXT.
        BNE     MARS            ;ODD SUBTEST #'S SHOULD GO GIVE BURST.
        INC     R4              ;UPDATE SOURCE/R/ATE PTR
        TSTB    (R4)            ;EVEN ONES GO BACK AND
        BGT     VENUS           ;DO NEXT RATE..UNLESS DONE ALL
        JMP     NORMAL          ;IN WHICH CASE, RETURN TO DISPATCHER

;SET BURST AND VERIFY THAT COUNT WENT TO ZERO:

MARS:   DFXCTT                  ;LOOK OUT, STAND BACK!
        BRCLK

        INSYNC          ;NEW SUBTEST
        BR      EARTH           ;AND GO DO THE COMPARE.

;HERE ARE THE MCOMP TABLES.  THEY ARE REUSED FOR EACH SOURCE & RATE.

SATURN: .BYTE   2               ;ODD SUBTESTS GET 2 CHANGES.
        .BYTE   2               ;EVEN ONES, 2 CHANGES

URANUS: .BYTE   0               ;
        .BYTE   3               ;ODD SUBTESTS: BURST CNT=0, BURST 128 & BURST 64.
        .BYTE   1
        .BYTE   76              ;BURST 32 - BURST 2.

        .BYTE   0               
        .BYTE   64              ;EVEN SUBTESTS: EBUS CLK & SBUS CLK.
        .BYTE   3
        .BYTE   4               ;-BURST


;SEQ197

.SBTTL TEST 11 (ECRAM1):        DIAGNOSTIC CRAM ADDRESS REGISTER

ECRAM1: PMSG    <STARTING CRAM TESTS\>  ;PRINT IDENTIFICATION

.REM    %
        
THIS CHECKS THE PATH FROM THE EBUS TO THE DIAGNOSTIC CRAM ADDRESS REGISTER
SND BACK IT USES A SET OF 8 TEST PATTERNS GENERATED BY SUBROUTINE PATTY.
WHICH ARE SUFFICIENT TO PROVE THAT EACH BIT CAN INDEPENDENTLY
BE '1" AND "0".
%

;LOAD POINTERS:

        MOV     #PATBUF,R2      ;R2 POINTS TO 16-BIT PATTERN BUFFER
        MOV     #FLU,R3         ;R3 POINTS TO 1ST BYTE OF COMPARE TABLE

;GET FIRST 16-BIT PATTERN TO THE BUFFER:
        MOV     R2,R0           ;BUFFER ADDRESS TO R0
        $PAT16          
;LOAD THE DIAG CRAM ADR REG WITH 11 RIGHT MOST BITS OF TEST PATTERN

MUMPS:  INSYNC                  ;NEXT SUBTEST
        MOV     (R2),R0 ;PUT ADR PATTERN IN R0.
        WWADR                   ;EMT TO WRITE ADDRESS.

;READ THE DIAG CRAM ADR REG & COMPARE WITH TEST PATTERN:

        MOV     (R2),(R3)       ;PUT TEST PATTERN IN EXPECTED DATA TABLE.
        ASL     (R3)            ;SHIFT TWICE TO RIGHT JUSTIFY DATA FOR
        ASL     (R3)            ;ADR BITS 0-4 IN UPPER EXPECTED DATA BYTE.
        MOVB    (R2),(R3)       ;RESTORE LOWER BYTE (ADR BITS 5-10).

        DCOMP                   ;DO BYTE TABLE COMPARE
        .WORD   STREP           ;PTR TO MAKS TABLE
        .WORD   FEVER           ;PTR TO FUNCTION TABLE
        .WORD   ANEMIA          ;PTR TO BYTE TABLE
        .WORD   FLU             ;PTR TO EXPECTED DATA TABLE
        .WORD   0               ;NO ERR MSG FROM MAINLINE


;SEQ198

;GET NEXT TEST PATTERN:

        $PATCO
        TST     R0              ;LOOK AT PATTERN # RETURNED BY PATTY.
        BNE     MUMPS           ;CONTINUE TESTING IF NOT ZERO.

        JMP     NORMAL          ;OTHERWISE, RETURN TO DISPATCHER.

;COMPARISON TABLES FOR THIS TEST:

STREP:  .BYTE   300             ;RIGHT SIX BITS (ADR BITS 5-10).
        .BYTE   340             ;LEFT FIVE BITS (ADR BITS 0-4).

FEVER:  .BYTE   RCRA+4          ;READ ADR BITS 5-10.
        .BYTE   RCRA+5!BIT7     ;READ ADR BITS 0-4.

ANEMIA: BYTPNT  ECRA
        BYTPNT ECRA

FLU:    .WORD   0               ;EXPECTED DATA GHOES HERE.


;SEQ199

.SBTTL TEST 12 (ECRAM2):  CRAM DATA PATHS

.REM    %
THIS TEST CHECKS THAT EACH OF FIVE CRAM LOCATIONS (0,1,2,3,1024)
CAN BE LOADED AND READ BACK CORRECTLY.  FOURTEEN 11-BYTE TEST PATTERNS
FROM THE PATTERN GENERATION SUBROUTINE AE USED WITH EACH CRAM ADDRESS
TO VERIFY THAT EACH RAM CHIP CAN STORE A "1" AND A "0" AND THAT NO TWO
CHIPS INNTERACT.  THIS TEST ALSO CHECKS THAT THE EBUS WAS CORRECTLY
RECEIVED AND TRANSMITTED ON EACH CRAM (AND THE CRA) BOARD, THE
DIAGNOSTIC READ AND WRITE CRAM FUNCTIONS WORK, AND THE DATA HOLDING
REGISTER (COMMAND REGISTER) WORKS.
%
;INITIALIZE THINGS:

ECRAM2: MOV     #$MICRO,R1      ;R1 WILL POINT TO THE PATTERN.
        MOV     #$$CRAD,R2      ;R2 WILL POINT TO THE CRAM ADDRESS.
        CLR     (R2)            ;START WITH ADR 0.

;RETURN HERE FOR EACH NEW ADDRESS:

TARZAN: INSYNC                  ;EACH CHANGE OF CRAM ADR IS A NEW SUBTEST.
        MOV     R1,R0           ;COPY PTR TO PATTERN BUFFER TO R0
        $PAT80          

;RETURN HERE FOR EACH NEW TEST PATTERN:

JANE:   MOV     (R2),R0         ;COPY CRAM ADR TO R0
        WCRAM                   ;AND WRITE TEST PATTERN TO THAT LOC.

        MOV     (R2),R0         ;RESTORE ADR TO R0
        RCRAM                   ;AND READ THAT LOCATION.

        CHKMIC                  ;COMPARE MICROWORD POINTED TO BY R0
        .WORD   $MICRO          ;WITH THE ONE BEGINNING AT $MICRO
        .WORD   0               ;NO ERROR TYPEOUT HERE


;SEQ200

;IF NO ERROR, GET NEXT PATTERN AND DECIDE HOW TO PROCEED:

        $PATCO                  ;GET NEXT TEST PATTERN TO BUFFER
        TST     R0              ;DONE ALL 14?  (RETURNS 0 WHEN DONE).
        BNE     JANE            ;NOPE, GO DO THIS ONE.

        INC     (R2)            ;YUP, TIME TO CHANGE CRAM ADDRES.
        CMP     (R2),#4         ;DOING ONE OF 1ST FOUR ADDRESSES?
        BLT     TARZAN          ;YUP, GO ON YOUR WAY.
        BEQ     VINES           ;NOPE, SET LAST ADDRESS.

        JMP     NORMAL          ;OTHERWISE, DONE ALL, GO DISPATCH.

VINES:  MOV     #^D1024,(R2)    ;SET CRAM ADDRESS TO 1024
        BR      TARZAN          ;AND CONTINUE.


;SEQ201


.SBTTL TEST 13 (ECRAM3): CRAM ADDRESSING

.REM    %
THIS TEST CHECKS THE ADDRESSING OF ALL CRAM CHIPS AND THE ABIITY
OF EACH INDIVIDUAL CELL TO HOLD A 0 OR 1.  TO EGIN WITH, THE
ENTIRE CRAM HAS BEEN SET TO ALL 0 DATA BY THE INITIALIZATION
ROUTINE, "ICRAM1".  SUBTEST 1 READS LOCATION 0 TO SEE THAT IT IS
INDEED ALL 0'S, AND THEN WRITES ALL 1'S BACK INTO LOCATION 0.
IT THEN STEPS TO LOCATION 1, READS 0'S AND WRITES 1'S AND SO ON UNTIL
ALL LOCATIONS IN THE CRAM HAVE BEEN TESTED.  THIS DEMONSTRATES THAT
EACH CELL IN THE RAM CAN HOLD A 0 AND THAT THERE ARE NO ADDRESS
LINE FAULTS OF THE SORT WHERE WR8TING A LOCATION WITH 1'S CAUSES
SOME HIGHER LOCATION TO BE MODIFIED.  SUBTEST 2 GOES THE OTHER WAY
ROUND, READING 1'S FROM THE TOP OF THE CRAM AND WRITING 0'S DOWN TO
THE BOTTOM, CHECKING THAT EACH CELL HOLDS A 1 AND THAT NO ADDRESS
FAULTS PROPAGATE 0 DATA DOWNWARDS.  SUBTEST 3 BEGINS AT THE TOP,
READING 0'S AND WRITING 1'S AND SUBTEST 4 STARTS LOW AND READS 1'S
AND WRITES 0'S (LEAVING THE ENTIRE CRAM ONCE AGAIN CLEARED).
PROBLEMS CAN USUALLY BE LOCALIZED TO THE CHIP BY NOTING THE BIT
POSITION OF THE FAILING DATA.  SINCE THE TEST USES KLDCP RAM READS
AND WRITES, "EC" AND "DC" COMMANDS FROM THE CONSOLE CAN BE USED TO
VERIFY/TRACK DOWN DETECTED ADDRESSING PROBLEMS.
%


;INITIALIZE A POINTER.

ECRAM3: MOV     #$$CRAD,R2      ;R2 POINTS TO CURRENT CRAM ADDRESS


;USE EWORD1 + EWORD2 FOR ALL 0'S EXPECTED DATA:
        $CLRMI  EWORD1          ;CLEAR 80-BIT MICROWORD

;USE $MICRO TO HOLD ALL 1'S EXPECTED DATA:

        MOV     #$MICRO,R0      ;POINTS TO THE BUFFER
        MOV     #6,R1           ;DO 6 WORDS WORTH.
TAURUS: MOV     #-1,(R0)+       ;LOAD 1'S TO A WORD.
        DEC     R1              ;DOWN COUNT.
        BGT     TAURUS          ;LOOP.


;SEQ202

;FOR SUBTEST 1, BEGIN AT 0 AND EXPECT 0'S:

        INSYNC                  ;SUBTEST 1
        CLR     (R2)            ;START WITH CRAM LOCATION 0
        MOV     #EWORD1,GEMINI  ;EXPECT 0'S
        JSR     PC,LEO          ;DO SOMETHING READIN' 'N WRITIN'

;FOR SUBTEST 2, BEGIN AT RAMTOP AND EXPECT 1'S.

        INSYNC                  ;SUBTEST 2
        MOV     #RAMTOP,(R2)    ;START WITH HIGHEST CRAM ADDRESS
        MOV     #$MICRO,GEMINI  ;EXPECT 1'S
        JSR     PC,LEO          ;GO TEST 'EM

;FOR SUBTEST 3, BEGIN AT TOP AND EXPECT 0'S:

        INSYNC                  ;SUBTEST 3
        MOV     #RAMTOP,(R2)    ;START AT THE TOP
        MOV     #EWORD1,GEMINI  ;EXPECT 0'S
        JSR     PC,LEO          ;TEST SUMMOR

;FOR LAST SUBTEST, BEGIN AT 0 AND EXPECT 1'S"

        INSYNC                  ;SUBTEST 4
        CLR     (R2)            ;START AT 0
        MOV     #$MICRO,GEMINI  ;EXPECT 1'S
        JSR     PC,LEO          ;LAST TIME

        JMP     NORMAL          ;ALL OK


;SEQ203


;HERE IS THE ROUTINE FOR DOING READ-CHECK-WRITES.
;IT LOOKS AT THE SUBTEST NUMBER TO MAKE SOME DECISIONS:

LEO:    MOV     (R2),R0         ;PUT CURRENT CRAM ADR INTO R0
        RCRAM                   ;READ THAT LOCATION (DATA PTR TO R0)

        CHKMIC                  ;COMPARE READ DATA WITH EXPECTED
GEMINI: .WORD   0               ;PTR TO EXPECTED (FILLED IN BY MAINLINE)
        .WORD   0                       ;NO ERROR MSG - COMES FOR ISOLATION

        MOV     (R2),R0         ;RESTORE CURRENT CRAM ADR TO R0
        CLR     R1              ;TELL WRITE ROUTINES TO DO ONLY 1 LOC
        BIT     #1,R5           ;DOING EVEN OR ODD SUBTST?
        BEQ     CANCER          ;EVEN ONES GO AROUND

        MICFIL                  ;ODD SUBTESTS WRITE 1'S
        BR      PISCES          ;AND REJOING MAINSTREAM

CANCER: MICNUL                  ;EVEN SUBTESTS WRITE 0'S

PISCES: BIT     #2,R5           ;DOING SUBTEST 1 OR 4?
        BNE     ARIES           ;IF NO GO AROUND
        INC     (R2)            ;YES, INCREMENT CRAM ADR
        CMP     (R2),#RAMTOP    ;AND COMPARE WITH HIGHEST ADR
        BLE     LEO             ;DO MORE IF NOT THERE
        RTS     PC              ;OTHERWISE, RETURN

ARIES:  DEC     (R2)            ;SUBTESTS 1 & 4 DECREMENT CRAM ADR
        BGE     LEO             ;AND SEE IF ADR HAS GONE NEGATIVE
        RTS     PC              ;RETURN WHEN THAT HAPPENS...

;SEQ204

.SBTTL TEST 14 (ECRAM4):        CRAM PARITY NETWORK

.REM    %
THIS TEST CHECKS THE OPERATION OF THE CRAM PARITY NETWORK BY LOADING
FOUR TEST MICROWORDS.  THE OPERATION OF THE LOGIC ON THE CLOCK BOARD TO
FOUR TEST MICROWORDS.  THE OPERATION OF THE LOGIC ON THE LCOCK BOARD TO
STOP THE CLOCK ON A CRAM PARITY ERRROR IS ALSO CHECKED.

%
;INITIALIZE STUFF:

ECRAM4: $CLRWD  BASIL
        CLRB    BASIL+5         ;PLUS BYTE 6

        CLR     $$CRAD          ;CLEAR MICROWORD ADDRESS.

        MOV     #SALT,R1                ;PUT PTR TO STIMULUS TABLE IN R1.
        MOV     #PEPPER,R2      ;PUT MCOMP'S #-OF-CHANGES TABLE PTR IN R2.
        MOV     #NUTMEG,R3      ;PUT MCOMP'S BYTE TABLE PTR IN R3.
        MOV     #BASIL,DCOMPX   ;INITIALIZE DCOMPS'S EXPECTED DATA PTR.

;LOAD THE NEXT TEST PATTERN INTO $MICRO:

GARLIC: INSYNC                  ;EACH PATTERN IS A NEW SUBTEST.
        MOV     #$MICRO,R4      ;R4 POINTS TO START OF BUFFER.
        MOV     #10,R0          ;R0 WILL COUNT 8 MOVES.
CHIVE:  MOVB    (R1),(R4)+      ;LOAD 1ST 8 BYTES OF $MICRO WITH
        DEC     R0              ;FIRST TEST PATTERN BYTE.
        BNE     CHIVE

        INC     R1              ;BUMPT PTR TO NEXT PATTERN BYTE.
        MOVB    (R1)+,(R4)+     ;LOAD NEXT THREE TEST PATTERN BYTES
        MOVB    (R1)+,(R4)+     ;INTO $MICRO+10,$MICRO+11 AND
        MOVB    (R1)+,(R4)+     ;$MICRO+12.


;SEQ205

;WRITE $MICRO TO CRAM LOC 0, CLOCK IT TO COMMAND REG,
;AND CHECK PARITY NETWORK:

        $MWORD
        $MCOMP
        DCOMP                   ;DO A BYTE TABLE COMPARE
        .WORD   SAGE            ;PTR TO MASK TABLE
        .WORD   CLOVE           ;PTR TO FUNCTION TABLE
        .WORD   THYME           ;PTR TO BYTE TABLE
        .WORD   BASIL           ;PTR TO EXPECTED DATA TABLE
        .WORD   0               ;ERROR MSG FROM ISOLATION ROUTINE
        $RCOMP

        CMP     SUBNR,#4                ;SEE FI DONE ALL 4 TEST WORDS.
        BLT     GARLIC          ;NO, GO DO NEXT ONE.

;SEE IF BAD CRAM PARITY IS DETECTED ON CLOCK BOARD:

        INSYNC                  ;SUBTEST #5.
        CLEAR                   ;CLEAR THE MACHIE (LEAVE CR CLEARED)
        MOV     #EWORD1,R1      ;PUT PTR TO EBUS DATA WORD IN R1.

        MOV     #4,(R1)         ;SET EBUS BIT 33 IN BUFFER.
        MOV     #LDCHK1,R0      ;DIAG FN TO LOAD CLK PARITY CHK REG IN R0.
        DFWRT                   ;SET "CLK CRAM PAR CHECK" BIT

        DFXCTT                  ;SINGLE STEP THE EBOX CLOCK.
        .WORD   SECLK
        CLKPRM                  ;PTR TO SOURCE/RATE INFO
        CLKMCR                  ;COMPARE


;SEQ206

;SEE IF BAD CRAM PARITY STOPS THE CLOCK:

        INSYNC                  ;SUBTEST #6.
        MOVB    #11,(R1)        ;SET EBUS BITS 32 & 35 IN BUFFER.
        MOV     #LDCHK2,R0      ;LOAD "CLK ERR STOP EN" BIT.
        DFWRT                   ;& "MBOX CYCLE DIS"

;TEST BY TRYING TO SINGLE STEP EBOX CLOCK (SHOULD ONLY GET 1 MORE MBOX CLOCK):

        EBURST  5               ;TYRY TO ISSUE 5 EBOX CLOCKS
                CLKPRM
        CLKMCR

;MAKE SURE GOOD PARITY DOESN'T ALSO STOP 'ER:

        INSYNC                  ;SUBTEST #7.
        CLEAR                   ;CLEAR MACHINE

        MOV     #40,$MICRO      ;SET ONE CRAM BIT TO GIVE GOOD ODD
        $MWORD                  ;COMMAND REGISTER.
        MOV     #4,(R1) ;AGAIN SET "CLK CRAM PAR CHECK" BIT
        MOV     #LDCHK1,R0      ;WHICH WAS CLEARED BY MRESET.
        DFWRT
        MOV     #11,(R1)                ;AND RESTORE "CLK ERR STOP EN"
        MOV     #LDCHK2,R0
        DFWRT
        EBURST  5               ;GIVE 5 EBOX CLOCKS
        CLKPRM
        CLKMCR

        JMP     NORMAL          ;NO ERRORS, RETURN TO DISPATCHER.


;SEQ207

;TEST PATTERN BYTES:

SALT:   .BYTE   0               ;PATTERN #1: 0'S IN 1ST 8 BYTES.
        .BYTE   200             ;CRAM 08 SET.
        .BYTE   210             ;CRAM 04 & 00 SET.
        .BYTE   0               ;NO SIDP BITS SET.

        .BYTE   125             ;PATTERN #2: ALTERNATING 0/1 IN 11ST 8 BYTES.
        .BYTE   125             ;SAME FOR NEXT BYTE.
        .BYTE   135             ;SAME FOR CRAM 04 SET.
        .BYTE   125             ;SAME.
        .BYTE   377             ;PATTERN #3:  ALL 1'S IN 1ST 8 BYTES.
        .BYTE   177             ;SAME BUT CRAM 08 CLEAR.
        .BYTE   167             ;DSAME BUT CRAM 04 & 00 CLEAR.
        .BYTE   377             ;SAME.
        .WORD   0               ;PATTERN #4:  ALL 0'S.
        .WORD   0

;PARITY DCOMP TABLES:

SAGE:   .BYTE   372             ;LOOK AT EACH STAGE'S PAR & 1ST PAR BITS.
        .BYTE   372
        .BYTE   372
        .BYTE   372
        .BYTE   372
        .BYTE   177             ;READ ONLY THE DISP PAR BIT.

CLOVE:  .BYTE   RCRM+4          ;DIAGNOSTIC FUNCTION TO USE.
        .BYTE   RCRM+4
        .BYTE   RCRM+4
        .BYTE   RCRM+4
        .BYTE   RCRM+4
        .BYTE   RCRA+5!BIT7     ;THIS IS ACTUALLY ON CRA BOARD.

THYME:  BYTPNT  11              ;EBUS BYTES TO USE.
        BYTPNT  17
        BYTPNT  23
        BYTPNT  29
        BYTPNT  35
        BYTPNT  7

BASIL:  .BLKB   6               ;EXPECTED DATA GOES HERE.


;SEQ208

;PARITY MCOMP TABLES (SUBTEST'S 5 AND ABOVE ACT ON CLOCK BOARD DCOMP TABLES):

PEPPER: .BYTE   4               ;SUBTEST #1:  CHANGE 4 BYTES
        .BYTE   6               ;#2
        .BYTE   5               ;#3
        .BYTE   0               ;#4
        .BYTE   4               ;SUBTEST #5:  CHANGE 4 BYTES IN CLOCK TABLE
        .BYTE   5
        .BYTE   3


NUTMEG: .BYTE   0
        .BYTE   5               ;SUBTEST #1:  "CRAM PAR 1ST 00" & "CRAM PAR 00"
        .BYTE   1
        .BYTE   5               ;"CRAM PAR 1ST 04" & "CRAM PAR 04"
        .BYTE   2
        .BYTE   5               ;"CRAM PAR 1ST 08" & "CRAM PAR 08"
        .BYTE   4
        .BYTE   1               ;"CRAM PAR 16"

        .BYTE   0
        .BYTE 4          ;SUBTEST #2:  "CRAM PAR 1ST 00"
        .BYTE   1
        .BYTE   1               ;"CRAM PAR 04"
        .BYTE   2
        .BYTE   5               ;"CRAM PAR 1ST 08" & "CRAM PAR 08"
        .BYTE   3
        .BYTE   5               ;"CRAM PAR 1ST 12: & "CRAM PAR 12"
        .BYTE   4
        .BYTE   5               ;"CRAM PAR 1ST 16" & "CRAM PAR 16"
        .BYTE   5
        .BYTE   200             ;"CRA DISP PAR"

        .BYTE   0
        .BYTE   1               ;SUBTEST #3:  "CRAM PAR 00"
        .BYTE   1
        .BYTE   1               ;"CRAM PAR 04"
        .BYTE   3
        .BYTE   4               ;"CRAM PAR 1ST 12" & "CRAM PAR 12"
        .BYTE   4
        .BYTE   4               ;"CRAM PAR 1ST 16": & "CRAM PAR 16"
        .BYTE   5
        .BYTE   0               ;"CRA DISP PAR"


;SEQ209

        .BYTE   0
        .BYTE   64              ;SUBTEST #5:  "EBUS CLK" & "SBUS CLK"
        .BYTE   4
        .BYTE   43              ;"CRAM PAR ERR" & "-EBOX SS" & "MBOX CYCLE DIS"
        .BYTE   5
        .BYTE   21              ;"-CRAM PAR CHECK" & "SH AR APR ODD"
        .BYTE   7
        .BYTE   3               ;"-ERROR"

        .BYTE   2
        .BYTE   62              ;SUBTEST #6:  "ERROR STOP" & "SYNC"
        .BYTE   3
        .BYTE   0               ;"-EBOX CLK" & "-BURST"


        .BYTE   4
        .BYTE   67              ;"CRAM PAR ERR" & "EBOX SOURCE" & "MBOX CYCLE DIS"
        .BYTE   5
        .BYTE   21              ;"-CRAM PAR CHECK"&"SH AR APR ODD"
        .BYTE   7
        .BYTE   2               ;"-ERROR & "ERR STOP EN"

        .BYTE   3
        .BYTE   4               ;SUBTET #7:  "-BURST"
        .BYTE   5
        .BYTE   21              ;"-CRAM PAR CHECK"&"SH AR APR ODD"
        .BYTE   7
        .BYTE   42              ;"-ERR STOP EN"

        .EVEN


;SEQ210

.SBTTL TEST 15 (ECLK5): CLOCK DELAY (MICROCODE "T" FIELD).

.REM    %
THIS TESTS THE 31,62,93 AND 520 NAN0OSECOND DELAY LOGIC ON THE CLOCK BOARD.
THE "T" FIELD MICROCODE BITS AND THE "CON DELAY REQ" SIGNAL ARE ALSO CHECKED.
        
THE TEST ISSUES SINGLE MBOX CLOCKS AND COUNTS THE NUMBER BETWEEN EBOX
CLOCKS.  BOTH "TOO EARLY" AND "TOO LATE" EBOX CLOCKS CAUSE AN ERROR.
%
;INITIALIZE PTRS & CLEAR STUFF:

ECLK5:  MOV     #FOREST,R1      ;PTR TO DELAY VALUE TABLE
        MOV     #GROVE,R2               ;PTR TO MCOMP'S # TABLE.
        MOV     #COPSE,R3               ;PTR TO MCOMP'S BYTE TABLE
        MOVB    #377,TICK               ;MASK OFF BYTE WITH "EBUS & SBUS CLK"


;SEQ211

;HERE FOR EACH NEW DELAY VALUE:

TIMBER: CLEAR           ;CLEAR THE MACHINE.
        INSYNC                  ;NEW SUBTEST.
        CMP     SUBNR,#4        ;WHICH ONE?
        BEQ     STAND           ;THE LAST, GO SET UP FOR LONG DELAY./
        BLT     LUMBER          ;ONE OF FIRST THREE, GO SET "T" FIELD.
        JMP     NORMAL          ;DONE EM ALL

;HERE TO SET UP LONG EDLAY COUNTER FOR SUBTEST #4:

STAND:  $NUM 400                ;SET CRAM #0 BIT
        $COND   20              ;SET CON/DIAG FUNC
        
;HERE TO SET THE CORRECT T-FIELD VALUE:

LUMBER: MOVB    (R1)+,R0        ;GET T-FIELD VALUE FROM TABLE.
        $T                      ;PUT IT IN $MICRO

        $MWORD

;LOAD A COUNTER TO KEEP TRACK OF MBOX TICKS:

        MOVB    (R1)+,R4                ;FETCH EXPECTED TICKS TILL SYNC OFF TABLE.
        DFSCLK
        DEC     R4
        BR      LOGS            ;GO GIVE FIRST TICK WITHOUT A COMPARE.

;HERE FOR EACH MBOX CLOCK AFTER 1ST.

PLANKS: DEC     R4              ;COUNT FOR THE LAST TICK GIVEN
        BLE     CORD            ;TIMING OUT, LET MCOMP DO IT'S THING.

        MOV     #GROVE,R2       ;RESET MCOMP PTRS.
        MOV     #COPSE,R3       
CORD:   CLKPRM
        CLKMCR          ;DO THE COMPARE..


LOGS:   DFSCLK                  ;IF NO ERROR, STEP THE MBOX CLOCK.

        TST     R4              ;DECIDE WHERE TO LOOP TO.
        BGE     PLANKS          ;NOT TIMED OUT, KEEP COUNTING.


;SEQ212

        BR      TIMBER           ;TIMED OUT, GO SEE IF MORE TO DO.


;SEQ213


;MCOMP TABLES FOR CLOCK DELAY TEST:

GROVE:  .BYTE   1               ;TIMING, 1 CHANGE
        .BYTE   0               ;SYNC RETURNS, NO CHANGE
        .BYTE   3               ;CLOCK RETURNS, 3 CHANGES

COPSE:  .BYTE   2               ;TIMING:        "SYNC"
        .BYTE   22

        .BYTE   2
        .BYTE   22              ;TIMED OUT:  "SYNC"
        .BYTE   3
        .BYTE   20              ;"-EBOX CLK"
        .BYTE   4
        .BYTE   27              ;"EBOX SOURCE" & "MBOX CYCLE DIS"

;DELAY VAALUE TABLES:

FOREST: .BYTE   1               ;SUBTEST #3:  3 TICKS TO SYNC.
        .BYTE   3               ;T=01

        .BYTE   2               ;SUBTEST #4:  4 TICKS TO SYNC.
        .BYTE   4               ;T=10

        .BYTE   3               ;SUBTEST #5:  5 TICKS TO SYNC.
        .BYTE   5               ;T=11

        .BYTE   3               ;SUBTEST #4:  21 TICKS TO SYNC.
        .BYTE   21              ;T=11

        .EVEN
;SEQ214


.SBTTL TEST 16 (EDRAM1):  IR REGISTER/DRAM ADDRESS (I/O, JRST OFF)

EDRAM1: PMSG    <STARTING DRAM TESTS\>  ;PRINT TRACE

.REM    %
THIS TEST CHECKS THAT THE 13 BITS OF THE INSTRUCTION REGISTER CAN EACH
STORE 1'S AND 0'S AND THAT NO TWO BITS INTERACT.  THIS REGISTER IS READ BY
READING THE DRAM ADDRESS WITH "7XX" ADDRESSING TURNED OFF (BITS 0-8) AND
THE AC FIELD WITH AC DECODING TURNED ON (BITS 9-12)./  CONSEQUERNTLY THESE FEATURES
ARE ALSO CHECKED BY THIS TEST.  8 PATTERNS, GENERATED BY SUBROUTINE PATTY,
ARE USED.
%
;INITIALIZE AND SET A PTR:
        BISB    #BIT7,TIGER+2   ;MAKE DCOMP STOP AFTER 1ST 3 BYTES.
        MOV     #EWORD1,R1              ;PTR TO 36-BIT DATA BUFFER GOES IN R1.

;DISABLE I/O AND JRST DECODING, BUT ENABLE AC FIELD:

        DFXCTT                  ;TURN THEM BOTH ON.
        .WORD   ENIOJA
        DFXCTT                  ;TURN OFF I/O-JRST DECODING.
        .WORD   DISIOJ

;GET FIRST TEST PATTERN:

        MOV     R1,R0           ;PTR TO 36-BIT EBUS BUFFER IN R0 FOR CALL.
        $PAT36

;WRITE AN ADDRESS PATTERN TO THE IR:

ZEBRA:  INSYNC

        MOV     #LDAR,R0                ;SET UP AS FOR "LOAD ADR" FUNCTION
        DFWIR                   ;BUT "LOAD IR" EMT (R1 PTS AT DATA).
        DFXCTT                  ;LOAD AC FIELD FROM IR 09-12.

        .WORD   DRLTCH


;SEQ215

;COPY TEST PATTERN INTO PROPER PLACES IN EXPECTED DATA BYTES AND COMPARE:
        MOV     #COUGAR,R2      ;PICK UP PTR TO EXPECTD DATA.
        MOV     #EWORD1+4,R3    ;AND A PTR TO HIGH ORDER BYTE OF PATTERN.

        MOVB    (R3),(R2)+      ;COPY EBUS BITS 0-2 INTO 1ST XDATA BYTE.

        $RORWD
        MOVB    -(R3),(R2)+     ;THEN COPY EBUS BITS 3-8 INTO 2ND XDATA BYTE.
        $ROLWD
        $ROLWD
        MOVB    (R3),(R2)       ;AND COPY BITS 9-12 INTO 3RD XDATA BYTE.
        BICB    #360,(R2)       ;AND FILL IN CORRECT EXPECTED "EN I/O,
        BISB    #20,(R2)        ;JRST" AND "EN AC" BITS.
        IRCMP                   ;DO COMPARE

;GET NEXT PATTERN AND LOOP 'TIL DONE 8:
        $PATCO
        CMP     R0,#^D9         ;DO NEXT IF NOT.

        BLT     ZEBRA           ;DO NEXT IF NOT.

;MAKE SURE "HOLD IR" IS WORKING
        INSYNC
        MOV     #5,R4           ;COUNT BYTES IN R4
        MOV     R1,R0           ;POINTER TO LAST PATTERN INTO R0
HIPPO:  COMB    (R0)+           ;COMPLIMENT THE BYTE
        DEC     R4              ;DOWN THE COUNT
        BGT     HIPPO           ;LOOP UNTIL WHOLE PATTERN INVERTED
        MOV     #LDAR,R0        ;CHANGE AR(AD) BUT NOT IR
        DFWRT
        IRCMP                   ;SEE IF DATA HAS CHANGED
        JMP     NORMAL          ;BACK TO DISPATCHES IF SO.


;SEQ216

.SBTTL TEST 17 (EDRAM2):  DRAM ADDRESS - I/O AND JRST LOGIC

.REM    %
THIS TEST CHECKS THE LOGIC WHICH LOOKS FOR JRST (OP CODE 254), JRST 0,
AND 7XX INSTRUCTIONS AND ALTERS THE DRAM ADDRESS ACCORDINGLY, THE EFFECT
OF JRST INSTRUCTIONS ON THE DRAM J FIELD AND THE AC FIELD IS ALSO TESTED.
%
EDRAM2: MOV     #BROOK,R2       ;PTR TO MCOMP'S #-OF-CHANGES TABLE TO R2.
        MOV     #CREEK,R3               ;PTR TO MCOMP'S BYTE TABLE TO R3
        MOV     #STREAM,R4              ;PTR TO INPUT TABLE TO R4.

;GET 1ST BYTE OF INPUT PATTERN & SET I/O JRST AND AC DECODE MODES:

LAKE:   INSYNC          ;EACH PATTERN IS A NEW SUBTEST.
        MOV     #EWORD1+4,R1    ;PTR TO LAT BYTE OF 36-BIT BUFFER TO R1.
        MOVB    (R4)+,(R1)      ;FIRST BYTE OF PATTERN INTO BUFFER.

        DFXCTT                  ;TURN ON BOTH JRST AND AC DECODING
        .WORD   ENIOJA
        ASRB    (R1)            ;SEE IF ENABLE AC BIT IS SET IN PATTERN.
        BCS     POND            ;SKIP OVER NEXT IF IT WAS.
        DFXCTT                  ;IT WASN'T, CLEAR AC FIELD DECODE.
        .WORD   DISACF

POND:   ASRB    (R1)            ;HOW ABOUT THE I/O-JRST BIT?
        BCS     POOL            ;SKIP AROUND IF SET.
        DFXCTT                  ;OTHERWISE, CLEAR JRST DECODE.
        .WORD   DISIOJ



;SEQ217

;PUT REST OF PATTERN INTO BUFFER:

POOL:   MOVB    (R4)+,-(R1)      ;SECOND BYTE TO EWORD1+3
        MOVB    (R4)+,-(R1)     ;THIRD BYTE TO EWORD1+2

;LOAD THE IR FROM THE BUFFER:

        TST     -(R1)           ;FIRST FIX-UP PTR TO EWORD1.
        MOV     #LDAR,R0        ;SET UP AS FOR "LOAD AR" FUNCTION.
        DFWIR                   ;AND LOAD THE IR.

;WITH R1 STILL POINTING AT THE 36-BIT BUFFER, LOAD THE DRAM "J" FIELD:

        MOV     #LDRAM3,R0      ;LOAD J01-J04.
        DFWRT
        MOV     #LDRJEV,R0      ;LOAD J08-J10, EVEN ADDRESS.
        DFWRT
        MOV     #LDRJOD,R0      ;LOAD J07-10, ODD ADDRESS.
        DFWRT

;THEN LOAD THE DRAM LATCHES WITH THE J-FIELD DATA JUST WRITTEN:
        DFXCTT                  ;STROBE THE DRAM LATCHES
        .WORD   DRLTCH

;COMPARE DATA WITH EXPECTED:
        IRMCR

;SEE IF ALL DONE:

        CMP     #15,SUBNR               ;LAST SUBTEST?
        BGT     LAKE            ;NOPE, KEEP TRUCKIN'

        JMP     NORMAL          ;YUP, BACK TO DISPATCHER



;SEQ218

.REM    %
HERE ARE THE INPUT PATTERN BYTES TO TEST THE 7XX LOGIC:

THERE ARE THREE BYUTES FOR EACH PATTERN (SUBTEST)
WHOSE BITS HAVE THE FOLLOWING SIGNIFICANCE.

BIT #           BYTE #1         BYTE #          BYTE #

0               EN AC           IR11            ---
1               ENIOJ           IR10            ---
        


2               IR03            IR09            J04 AND J10
        
3               IR02            IR08            J03 AND J09
4               IR01            IR07            J02 AND J08
5               IR00            IR06            J01 AND J07
6               ---             IR05            ---
7               ---             IR04            IR12
%

STREAM: .BYTE   26              ;SUBTEST #1:  ENIOJ
        .BYTE   140             ;IR 1,3,5,6 & 12
        .BYTE   224
        .BYTE   33              ;SUBTEST #2:  ENIOJ & ENAC
        .BYTE   237             ;IR 1,2,4 & 7 -11
        .BYTE   30

        .BYTE   72              ;SUBTEST #3:  ENIOJ
        .BYTE   37              ;IR 0,1,2,7-11
        .BYTE   70

        .BYTE   6               ;SUBTEST #4:  ENIOJ
        .BYTE   140             ;IR 3,5 & 6
        .BYTE   4

        .BYTE   73              ;SUBTEST #5:  ENIOJ & ENAC
        .BYTE   0               ;IR 0,1,2 & 12
        .BYTE   270

;SEQ219

        .BYTE   26              ;SUBTEST #6:  ENIOJ
        .BYTE   147             ;IR 1,3,5,6,9,10 & 11

        .BYTE   24

        .BYTE   24              ;SUBTEST #7:  NEITHER
        .BYTE   140             ;IR 1,3,5 & 6
        .BYTE   24

        .BYTE   26              ;SUBTEST #8: ENIOJ
        .BYTE   140             ;IR 1,3,5 & 6
        .BYTE   24

        .BYTE   26              ;SUBTEST #9:  ENIOJ
        .BYTE   340             ;IR 1,3,4,5 & 6
        .BYTE   24
        .BYTE   26              ;SUBTEST #10:  ENIOJ
        .BYTE   40              ;IR 1,3,& 6
        .BYTE   24

        .BYTE   26              ;SUBTEST #11;  ENIOJ
        .BYTE   100             ;IR 1,3 & 5
        .BYTE   24

        .BYTE   23              ;SUBTEST #12: ENIOJ & ENAC
        .BYTE   140             ;IR 1,5, & 6
        .BYTE   20

        .BYTE   72              ;SUBTEST #13:  ENIOJ
        .BYTE   40              ;IR ,0,1,2 & 6
        .BYTE   70


;SEQ220

.REM    %
IN THIS TEST.  THE DCOMP BYTES ARE INITIALIZED AS FOLLOWS:

BIT # INDEX=0 INDEX=1 INDEX=2 INDEX=4 INDEX=5 INDEX=6

0       X       X       AC12=0  X       J10=0   X

1    ADR02=0    X       AC11=0  X       J09=1   X
2    ADR01=1 ADR08=0   AC10=0   J04=1   J08=1   X
3    ADR00=0  ADR07=0   AC09=0   J03=0  J07=1   X
4       X       ADR06=1  ENAC=0  J01=0  X       X
6       X       ADR04=0 X       -JRST0=1        X       X
7       X       ADR03=1 X       X       X       X       X

NOTE:   X=MASKED OFF.  BYTES 3 AND 7 ARE MASKED OFF ENTIRELY.
%

;HERE ARE THE MCOMP TABLES FOR THE 7XX TEST:

BROOK:  .BYTE   2               ;SUBTEST #1:  2 CHANGES
        .BYTE   5               ;2
        .BYTE   3               ;3
        .BYTE   3               ;4
        .BYTE   4               ;5
        .BYTE   1               ;6
        .BYTE   2               ;7
        .BYTE   2               ;8
        .BYTE   3               ;9
        .BYTE   2               ;10
        .BYTE   2               ;11
        .BYTE   4               ;12
        .BYTE   3               ;13

CREEK:  .BYTE   4               ;SUBTEST #1
        .BYTE   120
        .BYTE   5
        .BYTE   1

        .BYTE   0
        .BYTE   6               ;SUBTEST #2
        .BYTE   1
        .BYTE   114
        .BYTE   2
        .BYTE   76
        .BYTE   4
        .BYTE   130
        .BYTE   5
        .BYTE   6

        .BYTE   0
        .BYTE   16              ;SUBTEST #3
        .BYTE   1
        .BYTE   370
        .BYTE   4


;SEQ221

        .BYTE   170


;SEQ222

        .BYTE   0               
        .BYTE   0               ;SUBTEST #4
        .BYTE   4
        .BYTE   104
        .BYTE   5
        .BYTE   1

        .BYTE   0               
        .BYTE   16              ;SUBTEST #5
        .BYTE   1
        .BYTE   4
        .BYTE   2
        .BYTE   61
        .BYTE   4
        .BYTE   170

        .BYTE   4
        .BYTE   120             ;SUBTEST #6
        
        .BYTE   2
        .BYTE   0               ;SUBTET #7
        .BYTE   5
        .BYTE   5

        .BYTE   4
        .BYTE   20              ;SUBTEST #8
        .BYTE   5
        .BYTE   0

        .BYTE   1
        .BYTE   360             ;SUBTEST #9
        .BYTE   5
        .BYTE   5
        .BYTE   6
        .BYTE   20


;SEQ223

        .BYTE   1
        .BYTE   220             ;SUBTEST #10
        .BYTE   5
        .BYTE   5

        .BYTE   1
        .BYTE   240             ;SUBTEST #11
        .BYTE   5
        .BYTE   5

        .BYTE   1
        .BYTE   60              ;SUBTEST #12
        .BYTE   2
        .BYTE   60
        .BYTE   4
        .BYTE   120
        .BYTE   5
        .BYTE   4

        .BYTE   0
        .BYTE   16              ;SUBTEST #13
        .BYTE   1
        .BYTE   340
        .BYTE   4
        .BYTE   170

        .EVEN


;SEQ224

.SBTTL TEST 18 (EDRAM3):  DRAM DATA PATHS

.REM    %
THIS TEST CHECKS THAT EACH DRAM DATA CELL IN A PAIR OF ADJACENT LOCATIONS
(LOCATIONS 0 & 1 CHOSEN FOR CONVENISENCE0 CAN INDEPENDTLY STORE A "1" AND
A "0" AND THAT NO TWO CELLS INTERACT.  THE TEST USES 12 5-BYTE PATTERNS
GENERATED BY SDUBROUTIN PATTY.

%
;INITIALIZE THINGS:

EDRAM3: MOV     #EWORD1,R1      ;R1 GETS IT CUSTOMARY PTR TO 36-BIT DATA BUFFER.

;GET THE FIRST PATTERN FORM SUBROUTINE PATTY:

        MOV     R1,R0           ;PTR TO DATA BUFFER TO R0 GFOR CALL.
        $PAT36

;HERE FOR EACH NEW PATTERN :

CANOE:  INSYNC          ;NEW PATTERN = NEW SUBTEST.

;WRITE PATTERN TO DRAM:

        CLR     R0              ;USE ADDRESSES 0 & 1 (R1 POINTS TO DATA)
        WDRAM


;SEQ225

.REM%
HERE IS A MAP OF HOW THE 36-BITS OF PATTERN ARE USED TO FILL DRAM DATA BITS:



LOCATION        BIT#    EBUS BIT#       VALUE

EWORD1          0       35              DRAM J10 FOR EVEN ADDRESS.
                1       34              DRAM J09 FOR EVEN ADDRESS.
                2       33              DRAM JOB FOR EVEN ADDRESS.
                3       32              NOT USED FOR WRITE, DRAM J07 FROM ODD ADR ON READ.
                4       31              NOT USED (COMES BACK WITH COMPUTED PARITY ON READ).
                5       30              ;DRAM PAR FOR EVEN ADDRESS
                6       29              ;NOT USED
                7       28              NOT USED

EWORD1+1        0       27              DRAM B02 FOR EVEN ADDRESS
                1       26              DRAM B01 FOR EVEN ADDRESS
                2       25              DRAM B00 FOR EVEN ADDRESS
                3       24              DRAM A02 FOR EVEN ADDRESS
                4       23              DRAM A01 AFOR EVEN ADDRESS
                5       22              DRAM A00 FOR EVEN ADDRESS
                6       21              NOT USED
                7       20              NOT USED

EWORD1+2        0       19              DRAM J10 FOR ODD ADDRESS.
                1       18              DRAM J09 FOR ODD ADDRESS.
                2       17              DRAM J08 FOR ODD ADDRESS.
                3       16              DRAM J07 FOR BOTH ADDRESSES.
                4       15              NOT USED (COPMPUTED PARITY ON READ).
                5       14              DRAM PAR FOR ODD ADDRESS.
                6       13              NOT USED
                7               12              NOT USED

EWORD1+3        0       11              DRAM B02 FOR ODD ADDRESS.
                1       10              DRAM B01 FOR ODD ADDRESS.
                2       9               DRAM B00 FOR ODD ADDRESS.
                3       8               DRAM A02 FOR ODD ADDRESS.
                4       7               DRAM A01 FOR ODD ADDRESS.
                5       6               DRAM A00 FOR ODD ADDRESS.
                6       5               NOT USED
                7       4               NOT USED

EWORD1+4        0       3               DRAM J04 FOR BOTH ADDRESSES.
                1       2               DRAM J03 FOR BOTH ADDRESSES.
                2       1               DRAM JO2 FOR BOTH ADDRESSES.
                3       0               DRAM J01 FOR BOTH ADDRESSES.
        4-7                             NOT USED
%


;SEQ226


;CORRECT PATTERN FOR COMMON J07 BIT:

        MOV     #10,R0          ;BIT MASK FOR J7 BIT TO R0.
        BIC     R0,(R1)+        ;CLEAR BIT IN EVEN DATA & BUMP PTR TO ODD.
        MOV     (R1),R2         ;PUT WORD OCNTAINING J7 AS WRITTEN IN R2.
        COM     R0              ;INVERT MASK.
        BIC     R0,R2           ;USE IT TO CLEAR ALL BUT J7 BIT IN R2.
        BIS     R2,-(R1)        ;USE THAT TO SET J7 IN 1ST BYTE OF DATA.

;NOW READ BACK THE TWO LOATIONS AND DO A 36-BIT COMPRE:

        CLR     R0              ;READ LOCATIONS 0 & 1.
        RDRAM                   ;CALL RETURNS PTR TO DATA IN R0.
        MOV     R0,R2           ;PUT PTR TO DATA READ IN R2 FOR COMPARE CALL.
        MOV     #DMASK,R3       ;AND PTR TO MAK IN R3.
        MOV     R1,R4           ;AND PTR TO EXPECTED IN R4.
        $MSK36                  ;COMPARE (SETRS "C" ON ERROR)>

;SEE IF 36-BIT MASKED COMPARE FOUND AN ERROR & BAIL OUT IF IT DID:
        BCC     KAYAK           ;GO ON TO NEXT PATTERN IF NO ERROR.
        JSR     PC,FAULT        ;OTHERWISE, SCUTTLE THE SHIP
        .WORD   0               ;NO ERROR MSG FROM MAINLINE

;OTHERWISE GET NEXT PATTERN & GO ON:

KAYAK:  $PATCO
        TST     R0              ;DONE ALL?
        BNE     CANOE           ;NOPE, CONTINUE.

;SEQ227

;NOW MAKE SURE "HOLD DRAM" IS WORKING:
        INSYNC          
        MOV     #ZERO,R1        ;PT TO ALL ZERO DATA
        CLR     R0              ;USE LOCS 0 & 1
        WDRAM                   ;FILL THEM WITH ZEROES
        DFXCTT                  ;THEN STROBE DATA LATCHES
        .WORD   DRLTCH
        MOV     #ONES,R1                ;CHANGE THE IR TO ALL 1'S
        MOV     #LDAR,R0        ;SET UP LIKE LOAD THE AR
        DFWIR                   ;BUT REALLY LOAD IR
        DFXCTT                  ;ENABLE AC FIELD DECODE BUT NOT JRST
        .WORD   ENIOJA
        DFXCTT
        .WORD   DISIOJ

        MOV     #LDRAM2,R0      ;LOAD 1'S TO A&B FIELD OF LOC 777
        DFWRT
 
        MOV     #LDRAM3,R0              ;LOAD 1'S TO COMMON FIELD
        DFWRT
        MOV     #LDRJOD,R0      ;AND J FIELD
        DFWRT
        IRCMP                   ;SEE IF DATA IS TILL 0

        JMP     NORMAL          ;DONE BACK TO DISPATCHER
DMASK:  .BYTE   320             ;36-BIT DRAM MASK.
        .BYTE   300
        .BYTE   320
        .BYTE   300
        .BYTE   360

        .EVEN


;SEQ228

.SBTTL TEST 19 (EDRAM4):  DRAM ADDRESSING

.REM    %

THIS TEST CHECKS THE ADDRESS LINES TO ALL THE DRAM CHIPS BY FILLING THE
ENTIRE RAM WITH ZEROES, STEPPING THROUGH THE ADDRESSES ONE AT A TIME READING
ZEROES AND CHANGING TO ONES & THEN STEPPING THROUGH THE ADDRESSES IN THE
REVERSE ORDER READING ONES AND RESTORING ZEROES.  THIS LEAVES THE RAM
CLEARED AND COMPLETES THE VERIFICATION THAT EACH CELL IS UNIQUELY ADDRESSABLE
AND CAPABLE OF STORING BOTH A 1 AND A 0.  ADDRESS 254 READS IR BITS
9-12 IN PLACE OF J07-J10 (HARDWARE DOES TOO.)
%

;INITIALIZE THINGS:

EDRAM4: MOV     #ZERO,R1        ;PTR TO ALL ZERO DATA IN R1.
        MOV     #DMASK,R3       ;PTR TO MASK FOR DATA REA IN R3
        MOV     #EWORD1,R4      ;PTR TO EXPECTED DATA IN R4
        MOV     #776, -(SP)     ;CURRENT DRAM ADR ALWAYS ON STACK

;CLEAR ALL DRAM LOCATIONS:

        INSYNC          ;SUBTEST #1 WILL BE READING 0'S.

SKULL:  MOV     (SP),R0         ;PUT ADR INTO R0 FOR CALL (R1 PTR TO 0'S).
        WDRAM                   ;CLEAR EVEN & NEXT HIGHER ODD ADDRESS.
        DEC     (SP)            ;COUNT ADR DOWN BY TWO
        DEC     (SP)            ;TO NEXT EVEN ADDRESS.
        BGE     SKULL           ;LOOP BACK UNTIL DONE ALL 512(256 PAIRS).


;SEQ229

;READ 0'S AND WRITE 1'S, GOING FROM LOCATION 0 UP TO 776:

        CLR     (SP)            ;START WITH LOCATION 0.
        $CLRWD          ;EXPCT ALL 0'S
        MOV     #ONES,R1        ;NOW PT TO ALL 1'S DATA
SPINE:  MOV     (SP),R0 ;PUT DRAM ADR IN R0 FOR READ CALL.
        RDRAM           ;READ EVEN & NEXT HIGHER ADR.
        MOV     R0,R2           ;PUT RETURNED PTR TO DATA READ IN CCOMPARE CALL.
        $MSK36

        BCC     TIBIA           ;GO AROUND IF NO ERROR.

;HERE TO REPORT AN ADDRESSING ERROR.

FEMUR:  ERRMSG  <DRAM ADDRESSING PROBLEM @ LOCATION: >

        MOV     (SP)+,R0        ;GET DRAM ADDRESS BACK TO R0.
        ERROCT                  ;AND PRINT IT.
        JSR     PC,FAULT                ;BACK TO DISPATCHER WITH
        .WORD   0               ;NO FURTHER ERROR TYPEOUT.

;NOTE:  SEE DRAMS FOR BREAKDOWN OF BITS IN 36-BIT ERROR WORD.


;SEQ230

;HERE TO WRITE 1'S IF NO ERROR IN READING 0'S:

TIBIA:  MOV     (SP),R0         ;ADDRESS TO R0.
        WDRAM                   ;FILL EVEN & NEXT HIGHER ADR WITH 1'S.

        CMP     #776,(SP)       ;WAS THAT HIGHEST EVEN DRAM ADDRESS (776)?
        BLE     FIBULA          ;YES, GET OUT.
 
        INC     (SP)            ;NO, INCREMENT ADR BY 2 AND
        INC     (SP)
        BR      SPINE           ;LOOP BACK FOR NEXT LOACTION.

;NOW READ 1'S AND RESOTRE 0'S, GOING FROM LOCATION 776 BACK TO 0:

FIBULA: INSYNC          ;SUBTEST #2 IS READING 1'S.
        $SETWD                  ;SET EXP DATA TO ALL 1'S
        MOV     #ZERO,R1        ;WRITE DATA PTR BACK TO ALL 0'S
TARSUS: MOV     (SP),R0         ;PUT DRAM ADRESS IN R0 FOR READ.
        RDRAM                   ;READ EVEN & NEXT HIGHER ADDRESS.

        CMP     #254,(SP)       ;ARE WE AT "JRST" ADR??
        BNE     RIB             ;NOPE
        BICB    #17,(R4)                ;YES, CHANGE EXPECTED DATA
RIB:    MOV     R0,R2           ;PUT DATA PTR RETURNED INTO COMPARE CALL.
        $MSK36
        BCS     FEMUR           ;GO REPORT ERROR IF DETECTED.

;HERE IF NO ERROR DETECTED:

        MOVB    #-1,(R4)        ;BEST FIX EXP DATA JRST IN CASE
        MOV     (SP),R0         ;GET ADDRESS BACK TO R0.
        WDRAM                   ;CLEAR EVEN & NEXT HIGHER LOCATION.
        DEC     (SP)            ;COUNT ADDRESS DOWN BY 2
        DEC     (SP)            ;TO NEXT EVEN ADDRESS.
        BGE     TARSUS          ;LOOP UNTIL DONE.
        MOV     (SP)+,R0        ;CLEAN STACK
        JMP     NORMAL          ;THEN RETURN TO DISPATCHER.


;SEQ231

.SBTTL TEST 20 (EDRAM5):  DRAM PARITY NETWORK

.REM    %
THIS TEST CHECKS THE DRAM PARITY NETWORK WITH THREE TEST PATTERNS>  THE LOGIC
ON THE CLOCK BOARD TO STOP THE EBOX CLOCK ON A DRAM PARITY ERROR IS ALSO
CHECKED.
%
;INITIALIZE PTRS AND BUFFERS:

EDRAM5: MOV     #EWORD1,R1              ;PTR TO START OF 36-BIT BUFFER TO R1.
        MOV     #WAVE,R2                ;PTR TO TEST PATTERN TABLE TO R2.
        MOV     #EWORD1+3,R3    ;PTR TO BYTE WITH EBUS BITS 4-11 IN BUFFER.


;DISABLE AC AND 7XXX DECODING AND SET DRAM ADDRESS TO 1 (1ST ODD ADDRESS):
        DFXCTT                  ;DISABLE AC FIELD DECODING.
        .WORD   DISACF

        DFXCTT                  ;DISABLE JRST DECODING.
        .WORD   DISIOJ

        BISB    #10,(R3)        ;SET EBUS BIT 8 = LSB OF DRAM ADR.
        MOV     #LDAR,R0        ;SET UP TO LOAD THE AR AND 9WITH
        DFWIR                   ;BUFFER PTR IN R1) LOAD THE IR.


        CLRB    (R3)            ;LEAVE BUFFER CLEAN
        DEC     R3              ;AND LEAVE PTR TO BYTE WITH BITS 12-19.
        MOV     #LDAR,R0        ;ALSO LEAVE AR CLEAR.
        DFWRT


;SEQ232

;LOAD A TEST PATTERN TO THE RAM:

SEA:    INSYNC                  ;NEW SUBTEST.
        MOVB    (R2)+,(R3)      ;PUT 1ST BYTE OF PATTERN INTO BUFFER.
        MOV     #LDRAM2,R0      ;LOAD A & B FIELDS FROM BUFFER.
        DFWRT

        MOVB    (R2)+,(R3)      ;PUT 2ND BYTE OF PATTERN INTO BUFFER.
        MOV     #LDRJOD,R0      ;LOAD PAR AND J7 TO J10 FROM BUFFER.
        DFWRT
        MOVB    (R2)+,(R3)      ;PUT 3RD BYTE OF PATTERN INTO BUFFER.
        MOV     #LDRAM3,R0      ;LOAD J1-J4 FROM BUFFER.
        DFWRT
        DFXCTT                  ;STROBE DATA INTO DRAM LATCHES
        .WORD   DRLTCH

;CHECK THE RESULTING PARITY:

        MOVB    (R2)+,SHORE     ;SET EXPECTED PARITY FROM INPUT TABLE.

SEAPAR: DCOMP                   ;DO A BYTE TABLE COMPARE
        .WORD   COAST           ;PTR TO MASK TABLE
        .WORD   BEACH           ;PTR TO FUNCTION TABLE
        .WORD   HARBOR          ;PTRE TO BYTE TABLE
        .WORD   SHORE           ;PTER TO EXPECTED DATA TABLE
        .WORD   0               ;NO ERROR MSG UNTIL ISOLATION DONE
        CMP     #3,SUBNR                ;SEE IF MORE PATTERNS TO DO.
        BGT     SEA             ;YES, GO DO IT!

;SEE IF BAD PARITY DETECTED ON CLOCK BOARD:

        INSYNC                  ;SUBTEST #4
        MOV     #SURF,R2        ;LOAD SOME MCOMP TABLE PTRS.
        MOV     #COMBER,R3
        $CLRWD
        MOVB    #2,(R1)         ;SET "DRAM PAR CHECK" BIT ON CLK BOARD.
        MOV     #LDCHK1,R0      
        DFWRT
        DFXCTT                  ;SINGLE-STEP THE CLOCK TO SET ERROR FLOP.
        SECLK
        CLKPRM
        CLKMCR          ;DO THE CLOCK BOARD COMPARE.

;SEQ233

;SEE IF BAD DRAM PARITY STOPS THE CLOCK:

        INSYNC                  ;SUBTEST #5
        MOVB    #11,(R1)        ;SET EBUS BITS 32 & 35 IN BUFFER.
        MOV     #LDCHK2,R0      ;LOAD "CK ERR STOP EN" BIT.
        DFWRT

;TEST BY TRYING TO SINGLE STEP EBOX CLOCK (SHOULD ONLY GET  1 MORE MBOX CLOCK):
        EBURST  5               ;TRY TO GET 5 EBOX CLOCKS
        CLKPRM
        CLKMCR                  ;SEE THAT CLOCK IS WELL & TRULY HUNG.

;NMAKE SURE GOOD PARITY DOESN'T ALSO STOP THE CLOCK:

        INSYNC                  ;SUBTEST #6
        CLEAR                   ;CLEAR MACHINE (RESTART CLOCK)

        MOVB    #4,EWORD1+2         ;SET EBUS BIT 17 IN BUFFER
        MOV     #LDRAM3,R0      ;AND USE IT TO SET J4 (GIVING A
        DFWRT                   ;DRAM OUTPUT WITH ODD PARITY)
        DFXCTT                  ;STROBE DRAM LATCHES.
        .WORD   DRLTCH

        MOV     #LDCHK2,R0              ;AGAIN SET "CLK ERR STOP EN"
        DFWRT                   ;(GOT CLERED BY MRESET).
        ASL     (R1)            ;AND "DRAM PAR CHECK"
        MOV     #LDCHK1,R0
        DFWRT
        EBURST  5               ;CLOCK THE EBOX 5 TIMES
        CLKPRM          
        CLKMCR                  ;SEE THAT CLOCK DIDN'T HANG.

        JMP     NORMAL                  ;BACK TO DISPATCHER IF IT DIDN'T.


;SEQ234

.REM%

HERE IS THE INPUT PATTERN TABLE FOR THE DRAM PARITY TEST.  EACH PATTERN CONSISTS OF
THREE BYTES WHOSE BITS ARE DEFINED AS FOLLOWS:



BIT #           1ST BYTE                2ND BYTE                3RD BYTE

0                  0                       0                       0
1                  0                       0                       0
2               DRAM B02                DRAM J10                DRAM J04
3               DRAM B01                DRAM J09                DRAM J03
4               DRAM B00                DRAM J08                DRAM J02
        
5               DRAM A01                   0               0
6               DRAM A01                   0               0
7               DRAM A00                DRAM PAR                   0

NOTE:  A 4TH BYTE IN THE TABLE GIVES THE EXPECTED ODD PARITY FOR THE PATTERN.
%

WAVE:   .BYTE   170             ;SUBTEST #1:  A1,A2,B0 & B1
        .BYTE   254             ;PAR,J7,J9 & J10
        .BYTE   60              ;J2 & J3
        .BYTE   0               ;ODD PARITY IS FALSE.

        .BYTE   334             ;SUBTEST #2:  A0,A1,B0-B2
        .BYTE   230             ;PAR,J8 & J9
        .BYTE   54              ;J1,J3 & J4
        .BYTE   -1              ;ODD PARITY IS TRUE.

        .WORD   0               ;SUBTEST #3:  ALL BITS FALSE AND
        .WORD   0               ;ODD PARITY FALSE.

;HERE IS THE TINY DCOMP TABLE FOR THIS TEST:

COAST:  .BYTE   357             ;UST LOOK AT PARITY BIT.
BEACH:  .BYTE   RIR+5!BIT7      ;JSUT BYTE WITH PARITY IN IT.
HARBOR: BYTPNT  17              ;RIGHT JUSTIFY ON EBUS BIT 17.

SHORE:  .BLKB   1               ;EXPECTED DATA.



;SEQ235


;HERE ARE THE MCOMP TABLES FOR CLK BRD SIGNALS CHECKED IN SUBTESTS 4-6:

SURF:   .BYTE   5               ;SUBTEST #4:  5 CHANGES
        .BYTE   5
        .BYTE   4

COMBER: .BYTE   0       
        .BYTE   64              ;SUBTEST #4:  "EBUS CLK " & "SBUS CLK"
        .BYTE   3
        .BYTE   64              ;"DRAM PAR ERR"
        .BYTE   4
        .BYTE   3       ;"EBOX SS" & "MBOX CYCLE DIS"
        .BYTE   6
        .BYTE   1               ;"-DRAM PAR CHECK"
        .BYTE   7
        .BYTE   3               ;"-ERROR"
        .BYTE   2
        .BYTE   62              ;SUBTEST #5:  "ERROR STOP" & "SYNC"
        .BYTE   3
        .BYTE   40              ;"-BURST", "-EBOX CLK" & "DRAM PAR ERR"
        .BYTE   4
        .BYTE   27              ;"EBOX SOURCE" & "MBOX CYCLE DIS"
        .BYTE   6
        .BYTE   1               ;"-DRAM PAR CHECK"
        .BYTE   7       
        .BYTE   2               ;"-ERROR" & "-ERR STOP EN"

        .BYTE   0       
        .BYTE   64              ;SUBTEST #6:  "EBUS CLK" & "SBUS CLK"
        .BYTE   3       
        .BYTE   4               ;"-BURST"
        .BYTE   6
        .BYTE   1               ;"-DRAM PAR CHEC"
        .BYTE   7
        .BYTE   42              ;"-ERR STOP EN"

        .EVEN

;SEQ236

.SBTTL *ECONA* CONTROL LOGIC TESTS, FIRST PART

.SBTTL  TEST 21 (ECTL1):        "DISP" FIELD DECODING & AR, ARX&MQ CONTROL LOGIC

.REM    %
THIS TESTS THE DECODING OF THE "DISP" FIELD ON CTL1 AND
ALL OF THE LOGIC ON CTL2 FOR CONTROLLING THE AR, ARX & MQ MUXES.
%

ECTL1:  PMSG    <STARTING CONTROL LOGIC TESTS\>  ;PRINT TRACE

;INITIALIZE

        MOV     #EWORD1,R1              ;PTR TO 36-BIT BUFFER IN R1.
        MOV     #AMAZON,R2              ;PTR TO MCOMP # TABLE IN R2.
        MOV     #VOLGA,R3               ;PTR TO MCOMP VALUE TABLE IN R3.
        MOV     #THAMES,R4              ;PTR TO STIMULUS BYTE TABLE IN R4.
        MOV     #CTLMSK+26,R0   ;UNMASKK MCL XR SHORT AND
        BICB    #1,(R0)+        ;MCL SHORT STACK FOR THE
        BICB    #1,(R0)         ;MODEL B MACHINE.

;START MAIN LOOP:

SEINE:  INSYNC                  ;NEW SUBTEST - 25 IN LL
        CLEAR                   ;START FRESH EACH TIME
        MOV     R5,-(SP)        ;SAVE SUBTEST# ON STACK.
        MOVB    (R4),R5         ;GET 1ST CODED SET UP BYTE

;SET "MEM/ARL" IND" IF REQUIRED:

        CLR     R0              ;DEFAULT IS MEM FIELD CLEARED
        ASLB    R5              ;TEST MSB OF CODE BYTE.
        BCC     LOIRE           ;LEAVE "MEM" FIELD CLEARED IF BIT CLEAR

        
        INC     R0              ;"MEM/ARL IND" IS MEM=1 

LOIRE:  $MEM            ;WRITE MEM FIELD


;SEQ237


;SET MQ SELECT BIT IF REQUIRED.

        CLR     R0              ;SET E DEFAULT OF 0
        ASLB    R5              ;LOOK AT NEXT BIT IN CODE BYTE
        BCC     RHONE           ;LEAVE CLEAR I BIT IS CLEAR
        INC     R0              ;OTHERWISE, SET IT

RHONE:  $MQ             ;WRITE TO BUFFER

;SET ADCRY BIT IF REQUIRED:     
        CLR     R0              ;SET DEFAULT OF 0
        ASLB    R5              ;LOOK AT NEXT BIT IN CODE BYTE
        BCC     NILE            ;LEAVE CLEAR IF BIT IS CLEAR
        MOV     #40,R0          ;OTHERWISE SET AAD CRY BIT

NILE:   $AD                     ;WRITE AD FIELD

;SET BIT 18 OF THE ARX IF REQUIRED:

;NOTE:  MQ=1
        CLR     R0              ;SET DEFAULT OF 0
        ASLB    R5              ;LOOK AT NEXT BIT IN CODE BYTE
        BCC     STYX                    ;LEAVE CLEAR IF BIT IS CLEAR
        MOV     #3,R0           ;ELSE SET ARX FIELD TO 3(ARX GETS MQ)

STYX:   $AR                     ;WRITE ARX FIELD

;SET "COND" FIELD:

        MOVB    (R4)+,R0        ;GET FRESH COPY OF 1ST CODE BYTE
        BICB    #370,R0         ;(ONLY 3 BITS)
        $COND


;SEQ238

;NOW SET UP "DISP": FIELD AS REQUIRED:

        MOVB    (R4)+,R0        ;GET VALUE FROM TABLE
        $DISP                   ;WRITE IT TO BUFFER
        
;SET # FIELD:

        MOV     (R4)+,R0                ;GET NUMBER FIELD VALUE
        $NUM                    ;WRITE TO BUFFER.

;AND FINALLY DO AR FIELD:

        MOVB    -(R4),R0        ;GET LAST CODE BYTE.
        ASRB    R0              ;OFF A CRAM # BIT.

        $AR                     ;REST ARE AR SLECT BITS, WRITE THEM.

        TSTB    (R4)+           ;FIX UP CODE BYTE TABLE PTR.
        MOV     (SP)+,R5        ;GET SUBTEST # BACK TO R5.

        $MWORD                  ;CLOCK BUFFER TO CR.
        CTLMCR                  ;DO THE COMPARE.

        CMP     #^D25,SUBNR     ;DONE ALL 25 SUBTEWTS?
        BLE     TIGRIS                  ;IF YES, SKIP OVER JUMP BAKC.

        JMP     SEINE           ;NOPE, LOOP BA K AGAIN.

;SEQ239

;"WIGGLE" TWO BITS WE CNA SEE WHICH ARE CONTROLLED BY "DIAG LOAD FUNC 076"

TIGRIS: INSYNC                  ;SUBTEST #26.
        CLEAR                   ;CLEAR C.R.
        MOVB    #10,1(R1)                ;SET EBUS BIT 24 IN BUFFER.
        MOV     #76,R0          ;USE LOAD 076 FUNCTION.
        DFWRT                   ;TRY TO LOAD REG.

        CTLMCR                  ;"DIAG MEM REST" SHOULD OCME UP.

        INSYNC                  ;SUBTEST #27
        MOVB    #2,1(R1)        ;SET EBUS BIT 26 IN BUFFER.
        MOV     #76,R0          ;DO THE FUNCTION AGAIN.
        DFWRT
        CTLMCR                  ;"DIAG LOAD EBUS REG" SHOULD COME UP.

        INSYNC                  ;SUBTEST #28.
        CLRB    1(R1)           ;CLEAR BUFFER.
        MOV     #76,R0          ;DO THE FUNCTION.
        DFWRT
        CTLMCR                  ;NOTHIN SHOULD COME UP.

        INSYNC                  ;SUBTEST #29: SET MCL XR SHORT AND MCL
        CLEAR
        SETBUF                  ;SET ALL THE BITS IN EWORD1
        STUFF                   ;AND IN THE AR
        $VMA    3               ;SET BOTH VMA SELECT BITS
        $XBUF0          ;LOAD, EXECUTE AND THEN CLEAR CR
        CTLMCR                  ;DO COMPARE

        JMP     NORMAL          ;GOODBYE.


;SEQ240

.REM    %
HERE IS THE TABLE OF CODED STIMULUS BYTES.  THEY HAVE THE FOLLOWING SIGNIFICANCE:

BIT #           1ST BYTE                2ND BYTE                3RD BYTE         4TH BYTE


BIT #           1ST BYTE                2ND BYTE                3RD BYTE         4TH BYTE

7               MEM/ARLI                   0                    CRAM #01            0
6               MQ SEL                     0                    CRAM #02        ARXM SEL 4
5               CRAM AD CRY*               0                    CRAM #03         ARXM SEL 2
4       ARX18*                          DISP 00                 CRAM #04         ARXM SEL 1
3                  0                    DISP 01                 CRAM #05         ARM SEL 4
2               COND 03                 DISP 02                 CRAM #06         ARM SEL 2
1               COND 04                 DISP 03                 CRAM #07         ARM SEL 1
0                       COND 05         DISP 04                 CRAM #08         CRAM #00

        * = FOR MODEL B CPU ONLY
%

THAMES: .BYTE   047             ;SUBTEST #1: COND/REG CTL,CRAM ADCRY
        .BYTE   24              ;SPEC/FLAG CTL
        .WORD   00636           ;ARX=0,AR=0,#=36
        .BYTE   320             ;SUBRTEST #2:  M/ARLI,MQ,RX18
        .BYTE   11              ; SPEC/INH CRY 18
        .WORD   37167           ;ARX=3,AR=7, #=167

        .BYTE   346             ;SUBTEST #3:  COND/ARLI,M/ARLI MQ, CRAM ADCRYD
        .BYTE   20              ;SPEC/STACK UPDATE
        .WORD   53400           ;ARX=5, AR=3, #=400
        .BYTE   24              ;SUBTEST #4:  COND/ARCLR,ARX18
        .BYTE   23              ;DISP--
        .WORD   45503           ;ARX=4, AR=5, #=5032
        .BYTE   25              ;SUBTEST #5: COND/ARXCLR,ARX18
        .BYTE   15              ;SPEC/LOAD PC
        .WORD   02442           ;ARX=0, AR=2, #=-442
        .BYTE   243             ;SUBTEST #6:  COND/ARR LOAD,MQ,CRAM AD CRY
        .BYTE   36              ;DISP/EAMOD
        .WORD   50476           ;ARX=5, AR=0, #=476
        .BYTE   323             ;SUBTEST #7:  COND/ARR LOAD,MQ,M/ARLI,ARX18
        .BYTE   2               ;DISP/AREAD
        .WORD   40110           ;ARX=4,AR=0,#=110
        .BYTE   106             ;SUBTEST #8:  COND/ARLI,MB
        .BYTE   20              ;APEC/STACK UPDATE
        .WORD   03551                   ;ARX=0, AR=3, #=551


;SEQ241


        .BYTE   342             ;SUBTEST #9:  COND/ARLR LOAD,M/ARLI,MQ,CRAM AD CRY
        .BYTE   3               ;DISP/RETURN
        .WORD   77300           ;ARX=7, AR=7, #=300
        .BYTE   067             ;SUBTEST #10:  COND/REG CTL, CRAM AD CRY,ARX18
        .BYTE   25              ;SPEC/SAVE FLAGS
        .WORD   36027           ;ARX=3,AR=6,#=27

        .BYTE   321             ;SUBTEST #11:  COND/ARLL LOAD,M/ARLI,MQ,ARX18
        .BYTE   31              ;DISP/DIV
        .WORD   14150           ;ARX=1, AR=4, #=561

        .BYTE   326             ;SUBTEST #12: COND/ARLI,M/ARLI,MQ,ARX18
        .BYTE   2               ;DISP/AREAD
        .WORD   51561           ;ARX=5, AR=1, #=561

        .BYTE   22              ;SUBTEST #13:  COND/ARLR LOAD, ARX18
        .BYTE   36              ;DISP/EAMOD
        .WORD   00702           ;ARX=-0,AR=0, #=702
        .BYTE   344             ;SUBTEST #14:  COND/ARCLR,M/ARLI,MQ,CRAM AD CRY
        .BYTE   17              ;SPEC/GEN CRY 18
        .WORD   03620   ;ARX=0, AR=3, #=620

        .BYTE   1               ;SUBTEST #15:  COND/ARLL LOAD
        .BYTE   21              ;SPEC/SBR CALL
        .WORD   36557           ;ARX=3, AR=6, #=557


;SEQ242

        .BYTE   27              ;SUBTEST #16: COND/REG CTL,ARX18
        .BYTE   12              ;SPEC/MQ SHIFT
        .WORD   60302           ;ARX=6,AR=0,#=302

        .BYTE   323             ;SUBTEST#17: COND/ARR LOAD,M/ARLI,MQ,ARX18
        .BYTE   30              ;DISP/MUL
.WORD   15515           ;ARX=1,AR=0,#=515
        .BYTE   326             ;SUBTERST #18:  COND/ARLI,M/ARLI,MQ/ARX18
        .BYTE   35              ;DISP/NORM
        .WORD   40363           ;ARX=4, AR=0, #=363
        .BYTE   244             ;SUBTEST #19:  COND/ARCLR,M/ARLI,CRAM AD CRY
        .BYTE   27              ;SPEC/ADLONG
        .WORD   33175           ;ARX=3, AR=3, #=175

        .BYTE   266             ;SUBTEST #20:  COND/ARLI,MQ,ARX18,CRAM AD CRY
        .BYTE   13              ;SPEC/SCM ALT
        .WORD   74057           ;ARX=7, AR=4,#=57
        .BYTE   67              ;SUBTEST #21:  COND/REG CTL,ARX18,CRAM AD CRY
        .BYTE   26              ;SDPEC /SP MEM CYCLE
        .WORD   05172           ;ARX=0, AR=5, #=172
        .BYTE   7               ;SUBTEST #22:  COND/REG CTL
        .BYTE   22              ;SPEC/ARLI
        .WORD   11141           ;ARX=1, AR=1, #=141
        .BYTE   261             ;SUBTEST #23:  COND/ARLL LOAD,M/ARLI,ARX18,CRAM AD CRY
        .BYTE  14              ;SPEC/CLR FPD
        .WORD   11503           ;ARX=1, AR=1, #=503

        .BYTE   364             ;SUBTEST #24:  COND/ARCLR
        .BYTE   6               ;DISP/NICOND
        .WORD   40641           ;ARX=4, AR=0, #=641
        .BYTE   44              ;SUBTST #25:  COND/ARCLR
        .BYTE   2               ;DISP/AREAD
        .WORD   05746           ;ARX=0, AR=5, #=746


;SEQ243

;HERE IS MCOMP'S # OF CHANGES TABLE:


AMAZON: .BYTE   11              ;SUBTEST #1: NINE CHANGES
        .BYTE  12              ;2
        .BYTE   12              ;3
        .BYTE   12              ;4
        .BYTE   10              ;5
        .BYTE   12              ;6
        .BYTE   11              ;7
        .BYTE   12              ;8
        .BYTE   12              ;9
        .BYTE   12              ;10
        .BYTE   11              ;11
        .BYTE   12              ;12
        .BYTE   10              ;13
        .BYTE   12              ;14
        .BYTE   11              ;15
        .BYTE   11              ;16
        .BYTE   12              ;17
        .BYTE   11              ;18
        .BYTE   12              ;19
        .BYTE   12              ;20
        .BYTE   13              ;21
        .BYTE   11              ;22
        .BYTE   12              ;23
        .BYTE   13              ;24
        .BYTE   12              ;25
        .BYTE   4               ;26
        .BYTE   4               ;27
        .BYTE   3               ;28
        .BYTE   4               ;29


;SEQ244

;HERE IS MCOMP'S VALUE TABLE:

VOLGA:  .BYTE   26              
        .BYTE   1               ;SUBTEST #1: MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   120             ;-AR00L
        .BYTE   35      
        .BYTE   120             ;-AR09L
        .BYTE   36
        .BYTE   100             ;C/AREX
        .BYTE   40
        .BYTE   300             ;"CTL SPEC/FLAG CTL","-CTL MQ SEL2"
        .BYTE   41
        .BYTE   160             ;ADX CRY 36
        .BYTE   42
        .BYTE   100             ;ADX CRY 36 A
        .BYTE   43
        .BYTE   270             ;-ARXRS1
        .BYTE   27
        .BYTE   21              ;SUBTEST #2: MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   140             ;ARLS2,-AROOL,-ARRLA
        .BYTE   35
        .BYTE   140             ;ARLS1,-AR09L,-ARRLB
        .BYTE   36
        .BYTE   70              ;ARRS2,ARXLOD,MQMS2
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   150             ;AR00C,ARXLS2,MQS2
        .BYTE   41
        .BYTE   10              ;AR12C,-MQSEL1
        .BYTE    42
        .BYTE   60              ;ARXRS2,MQMEM
        .BYTE   43
        .BYTE   30              ;-INC18


;SEQ245

        .BYTE   27      
        .BYTE   21              ;SUBTEST #3: MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   110             ;-ARRLA
        .BYTE   35
        .BYTE   110             ;-ARRLB
        .BYTE   36
        .BYTE   250             ;"CTL GC18",ARRS2,ARXLOD
        .BYTE   37
        .BYTE   360             ;SPEC/;SUPD,ARRS1,MQMS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   100             ;MQS1
        .BYTE   42
        .BYTE   120             ;ADX CRY 36,MQMEM
        .BYTE   43
        .BYTE   220             ;-SPEC CALL,-ARXR SEL 1
        .BYTE   26

        .BYTE   1               ;SUBTEST #4: MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AROOL
        .BYTE   35
        .BYTE   40              ;-SPEC/MTR,ARS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   130             ;AR00C
        .BYTE   41
        .BYTE   70              ;AR12C
        .BYTE   42
        .BYTE   10              ;ARRCLR
        .BYTE   43
        .BYTE   270             ;-ARXRS1




;SEQ246

        .BYTE   26      
        .BYTE   1               ;SUBTEST #5:  MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   140             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   50              ;ARRS2,ARXLOD
        .BYTE   40
        .BYTE   20              ;-LOADP
        .BYTE   41
        .BYTE   60              ;ARXLS1
        .BYTE   43
        .BYTE   270             ;-ARXRS1

        .BYTE   27
        .BYTE   21              ;SUBTEST #6:  MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   140             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   110             ;ARL SEL 4
        .BYTE   40
        .BYTE   130             ;AR00C
        .BYTE   41
        .BYTE   130             ;AR12C,ADX CRY 36A, ARXL SEL 1
        .BYTE   42
        .BYTE   110             ;ADX CRY 36A, ARRCLR
        .BYTE   43
        .BYTE   220             ;-ARXR SEL 1,-SPEC/CALL

;SEQ247
        .BYTE   27
        .BYTE   21              ;SUBTEST #7: MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   140             ;-ARRLA,-ARL00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   70              ;ARRS2,ARXLOD,MQMS2
        .BYTE   40
        .BYTE  100             ;MQS2
        .BYTE   41
        .BYTE   40              ;MQS1
        .BYTE   42
        .BYTE   30              ;ARRCLR,MQMEM
        .BYTE   43
        .BYTE   270             ;-ARXS1
        .BYTE   26              
        .BYTE   1               ;SUBTEST #8:MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   100             ;-ARRLA,-ARL00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   270             ;GC18,ARRS2,ARXLOD,MQMS2
        .BYTE   37
        .BYTE   340             ;SPEC/SUPD,ARRS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   40              ;MQS1
        .BYTE   42
        .BYTE   30              ;ARRCLR,MQMEM
        .BYTE   43              
        .BYTE   60              ;-INC18,-SPEC/CALL

;SEQ248
        .BYTE   27
        .BYTE   21              ;SUBTEST #9: MCL SHORT STACK
        .BYTE  26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   70              ;ARRS2,ARXLOD,MQMS2
        .BYTE   37
        .BYTE   40              ;-DRET,ARRS1
        .BYTE   40
        .BYTE   140             ;ARXLS2,MQS2
        .BYTE   41
        .BYTE   100             ;MS1,ADXCRY 36,-ARXLSEL1
        .BYTE   42
        .BYTE   160             ;ARXRS2,MQMEM,ADXCRY 36A
        .BYTE   43
        .BYTE   230             ;-ARXRSEL1
        .BYTE   26
        .BYTE   1               ;SUBTEST #10:MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   40              ;-SPEC/SF,-ARRLA,-ARL00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   50              ;ARRS2,ARXLOD
        .BYTE   37
        .BYTE   110             ;ARLS4
        .BYTE   40
        .BYTE   140             ;ARXLS2,MQS2
        .BYTE   41
        .BYTE   100             ;MQS1,ADXCRY 36,-ARXLSEL 1
        .BYTE   42
        .BYTE   140             ;ARXRS2,ADXCRY 36A
        .BYTE   43
        .BYTE   30              ;-INC18,-ARXR SEL1


;SEQ249

        .BYTE   27
        .BYTE   21              ;SUBTEST #11:  MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCLXR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   110
        .BYTE   36
        .BYTE   30              ;ARXLOD,MQMS2
        .BYTE   40
        .BYTE   100             ;MQS2,-ARXL SEL2
        .BYTE   41
        .BYTE   0               ;MQS1,-ARXLS1
        .BYTE   42
        .BYTE   230             ;ADLONG,ARRCLR,MQMEM
        .BYTE   43
        .BYTE   230             ;-ARXRS1

        .BYTE   27
        .BYTE   21              ;SUBTEST #12:  MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   70              ;ARRS2,ARXLOD,MQMS2
        .BYTE   37
        .BYTE   140             ;ARRS1
        .BYTE   40
        .BYTE   110             ;MQS2,AR00C
        .BYTE   41
        .BYTE   10              ;AR12C,MQS1
        .BYTE   42
        .BYTE   20              ;MQMEM
        .BYTE   43
        .BYTE   220             ;ARXR SEL1,-SPEC/CALL


;SEQ250

        .BYTE   26              
        .BYTE   1               ;SUBTEST #13:MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34      
        .BYTE   160             ;ARL SEL2,AR00L
        .BYTE   35
        .BYTE   120             ;-AR09L,ARL SEL1
        .BYTE   41
        .BYTE   20              ;-ARXLS1
        .BYTE   43
        .BYTE   270             ;-SPEC/CALL,-ARXRS1
        .BYTE   40
        .BYTE   130             ;AR00C
        .BYTE   41
        .BYTE   70      ;AR12C

        .BYTE   27
        .BYTE   21              ;SUBTEST #14:MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
 
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   240             ;GC18,ARRS2
        .BYTE   37
        .BYTE   160             ;ARRS1,MQMS1
        .BYTE   40
        .BYTE   110             ;AR00C,MQS2
        .BYTE   41
        .BYTE   150             ;AR12C,ADCRY 36,MQS1
        .BYTE   42
        .BYTE   120             ;MQMEM,ADCRY 36A
        .BYTE   43
        .BYTE   260             ;-SPEC/CALL


;SEQ251









        .BYTE   26              
        .BYTE   1               ;SUBTEST #15:  MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   140             ;ARLS2,-ARRLA,-AR00L
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   50              ;ARRS2,ARXLOD
        .BYTE   37
        .BYTE   110             ;ARLS4
        .BYTE   40
        .BYTE   160             ;ARXLS2
        .BYTE   42
        .BYTE   40              ;ARXRS2
        .BYTE   43
        .BYTE   220


;SEQ252

        .BYTE   26              
        
        .BYTE   1               ;SUBTEST #16: MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   110             ;-ARRLA
        .BYTE   35
        .BYTE   100             ;-ARRLB,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   40
        .BYTE   140             ;ARXLS2,MQS1
        .BYTE   41
        .BYTE   40              ;-ARXLS1,MQS1
        .BYTE   42
        .BYTE   240             ;ADLONG,ARXRS2
        .BYTE   43
        .BYTE   270             ;-ARXRS1

        .BYTE   27
        .BYTE   21              ;;SUBTEST #17:MCL SHORT STACK
        .BYTE   26
                
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   30              ;ARXLOD,MQMS2
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   0          ;MQS1
        .BYTE   42
        .BYTE   230             ;ADLONG,ARRCLR,MQMEM
        .BYTE   43
        .BYTE   220             ;-ARXRSEL1,-SPEC/CALL


;SEQ253

        .BYTE   27              
        .BYTE   21              ;SUBTEST #18:MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   160             ;ARLS2,-AR00L
        .BYTE   35
        .BYTE   160             ;ARLS1,AR09L
        .BYTE   36
        .BYTE   30              ;ARXLOD,MQMS2
        .BYTE   40
        .BYTE   110             ;AR00C,MQS2
        .BYTE   41
        .BYTE   50              ;AR12C,-ARXLS1,MQS1
        .BYTE   42
        .BYTE   220             ;ADLONG,MQMEM
        .BYTE   43
        .BYTE   270             ;-ARXRS1
        .BYTE   27
        .BYTE   21              ;SUBTEST #19:MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   50              ;ARRS2,ARXLOD
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   150             ;AR00C,ARXLS2,MQS2
        .BYTE   41
        .BYTE   110             ;AR12C,MQS1
        .BYTE   42
        .BYTE   350             ;ADLONG,ARRCLR,ARXRS2,DXCRY 36A
        .BYTE   43
        .BYTE   230             ;-ARXRS1
;SEQ254

        .BYTE   27
        .BYTE   21              ;SUBTEST #20:  MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;MCL XR SHORT
        .BYTE   34
        .BYTE   340             ;SPEC/SALT,ARLS2,-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   110             ;ARLS4,MQMS1
        .BYTE   40
        .BYTE   160             ;ARXLS2,MQS2
        .BYTE   41
        .BYTE   120             ;ADXCRY 36,ARXSEL1
        .BYTE   42
        .BYTE   150             ;ARRCLR,ARXRS2,ADXCRY 36A
        .BYTE   43
        .BYTE   230
        .BYTE   26
        .BYTE   1               ;SUBTEST #21: MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   30
        .BYTE   005             ;-VMAX EN,-LOAD VMA CONTEXT
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-RRLB,-AR09L
        .BYTE   36
        .BYTE   100             ;C/AREX
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   360             ;SPEC/SMC,-ARXLS1,ADXCRY 36
        .BYTE   43
        .BYTE   270             ;-ARXRS1
        .BYTE   42
        .BYTE   100             ;ADXCRY 36A


;SEQ255

        .BYTE   26
        .BYTE   1               ;SUBTEST #22:MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR00L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   140             ;ARRS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   0               ;MQS1
        .BYTE   43
        .BYTE   230             ;ARXRSEL1

;SEQ255

        .BYTE   27
        .BYTE   21              ;SUBTEST #23:MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;M/ARLI,MCL XR SHORT
        .BYTE   34
        .BYTE   140             ;ARLS2,-ARRLA,-AR00L
        .BYTE   35
        .BYTE   340             ;SPEC/CFPD,ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   140             ;ARRS1
        .BYTE   40
        .BYTE   100             ;MQS2
        .BYTE   41
        .BYTE   100             ;MQS1
        .BYTE   43
        .BYTE   220             ;-SPEC/CALL,-ARXRSEL1
        .BYTE   42
        .BYTE   100             ;ADXCRY 36A

;SEQ256

        .BYTE   27              
        .BYTE   21              ;SUBTEST #24: MCL SHORT STACK
        .BYTE   26
        .BYTE   21              ;MCL XR SHORT
        .BYTE   34      
        .BYTE   120             ;-AR00L
        .BYTE   35
        .BYTE   160             ;ARLS1,-AR09L
        .BYTE   36
        .BYTE   10              ;ARXLOD
        .BYTE   37
        .BYTE   120             ;M1MS1
        .BYTE   40
        .BYTE   0               ;-LOADP,MQS2
        .BYTE   41
        .BYTE   140             ;-ARXLS1,MQS1
        .BYTE   42
        .BYTE    120             ;ADXCRY 36A, MQMEM
        .BYTE   43
        .BYTE   260             ;-SPEC/CALL
        .BYTE   21
        .BYTE   005             ;-LOAD SPEC INSTR
        .BYTE   26
        .BYTE   1               ;SUBTEST #25: MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   34
        .BYTE   100             ;-ARRLA,-AR00L
        .BYTE   35
        .BYTE   140             ;ARLS1,-ARRLB,-AR09L
        .BYTE   36
        .BYTE   40              ;ARRS2
        .BYTE   37
        .BYTE   150             ;ARLS4,ARRS1
        .BYTE   40
        .BYTE   130             ;AR00C
        .BYTE   41
        .BYTE   170             ;AR12C,ADXCRY 36
        .BYTE   42
        .BYTE   110             ;MQMEN,ADX CRY 36A
        .BYTE   43
        .BYTE   270             ;-ARXS1


;SEQ257

        .BYTE   26              
        .BYTE   1               ;SUBTEST#26: "MCL XR SHORT"
        .BYTE   27
        .BYTE   21              ;"MCL SHORT STACK"
        .BYTE   43
        .BYTE   370             ;"DIAG MEM RESET"
        .BYTE   41
        .BYTE   60              ;NOTHING!!
        .BYTE   26
        .BYTE   1               ;SUBTEST#27: "MCL XR SHORT"
        .BYTE   27
        .BYTE   21              ;"MCL SHORT STACK"
        .BYTE   43
        .BYTE   250             ;"-DIAG LOAD EBUS REG"
        .BYTE   41
        .BYTE   60              ;NOTHING!!
        .BYTE   26      
        .BYTE   1               ;SUBTEST#28:"MCL XR SHORT"
        .BYTE   27
        .BYTE   21              ;"MCL SHORT STACK"
        .BYTE   41
        .BYTE   60              ;NOTHING!!
        .BYTE   26
        .BYTE   1               ;SUBTEST #29:MCL XR SHORT
        .BYTE   27
        .BYTE   21              ;MCL SHORT STACK
        .BYTE   33
        .BYTE   45              ;-MCL VMA EXTENDED
        .BYTE   41
        .BYTE   60              ;-CTL ARXL SEL 1
.EVEN


;SEQ258

.SBTTL TEST 22 (ECTL2): ADXCRY LOGIC
        
.REM    %
THIS TEST CHECKS THE ADXCRY GATES ON CTL1 AND "PC+1 INH: ON CON4.
%

;INITIALIZE:
ECTL2:  MOV     #BLANCH,R2              ;MCOMP'S # TBLE PTR
        MOV     #SILVIA,R3              ;MCOMP'S BYTE TABLE PTR
        INSYNC                  ;SUBTEST #1
        $DISP   16              ;BRING UP "SPEC/XCRY AR0" IN BUFFER.
        $XBUF                   ;WRITE IT TO CR.

        CTLMCR                  ;NOTHING SHOULD BE UP YET.
        INSYNC                  ;SUBTEST #2
        $DISP   25              ;CHANGE TO "SPEC/SAVE FLAGS"
        $COND   15              ;SET "COND/S;EC INSTR" IN BUFFER.
        $NUM    100             ;AND CR #02 (TO GIVE PC+1 INH).
        $AD     40,0,0          ;ANMD AD CRY BIT
        $XBUF                   ;WRITE TO CR.
        CTLMCR                  ;ADXCRY SHOULD BE FALSE.


;SEQ259

        INSYNC                  ;SUBTEST #3.
        $COND   0               ;VCLEAR "COND/SPEC INSTR" (BUT LEAVE #)
        $AD     0,0,0           ;AND AD CRY
        MOVB    #10,EWORD1+4    ;SET SIGN BIT IN 36 BIT BUFFER.
        STUFF                   ;LOAD THE AR (SET AR00)
        $XBUF                   ;WRITE CR.
        
        CTLMCR                  ;COMPARE.

        INSYNC                  ;SDUBTEST #4.
        $DISP   16              ;CHANGE BACK TO SPED/XCRY AR0
        $COND   15              ;AND RESTORE "COPND/SPEC ISNTR"
        $XBUF                   ;WRITE BUFFER
        CTLMCR                  ;THISD TIME ADXCRY SHOULD BE TRUE.
        INSYNC                  ;SUBTEST #5
        $DISP   0               ;CLEAR DISP FIELD
        $NUM    0               ;AND # FIELD
        $AD     40,0,0          ;SET AD CRY
        $XBUF                   ;KADUNK!
        CTLMCR          ;SHOULD BE TRUE AGAIN
        JMP     NORMAL                  ;ALL DONE.


;SEQ260

;MCOMP TABLES:

BLANCH: .BYTE   0       ;SUBTEST #1:  NO CHANGES
        .BYTE   5       ;2
        .BYTE   3       ;3
        .BYTE   5       ;4
        .BYTE   4       ;5

SILVIA: .BYTE   16
        .BYTE   174     ;SUBTEST #2: "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   103             ;"CON PC+1 INH"
        .BYTE   21
        .BYTE   5               ;"-CON LOAD SPEC INSTR"
        .BYTE   34
        .BYTE   30              ;-"CTL SPEC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70              ;"-CTL INH CRY 18" (FROM S/FLG)

        .BYTE   17              
        .BYTE   103             ;SUBTEST #3:"-CON PC+1 INH"
        .BYTE   34
        .BYTE   30              ;"-CTL SPC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70      ;"-CVTL INH CRY 18" (FROM S/FLG)
        .BYTE   16
        .BYTE   174             ;SUBTEST #4:"-CON COND EN 00-07"
        .BYTE   17
        .BYTE   103             ;"-CON PC+1 INH"
        .BYTE   21
        .BYTE   5               ;"-CON LOAD SPEC INSTR"
        .BYTE   41
        .BYTE   160             ;"CTL ADX CRY 36"
        .BYTE   42
        .BYTE   100             ;"CTL ADX CRY 36A"
        .BYTE   16
        .BYTE 174                ;SUBTEST #5:"-CON COND EN 00-07"
        .BYTE   21
        .BYTE   5               ;"-CON LOAD SPEC INSTR"
        .BYTE   41
        .BYTE   160             ;"CTL ADX CRY 36"
        .BYTE   42
        .BYTE   100             ;"CTL ADX CRY 36A"
        .EVEN


;SEQ261

.SBTTL TEST  23 (ECON1):  "COND" FIELD DECODERS

.REM    %
THIS TESTS THE DECODERS ON CON1 AND VARIOUS GATES USING THE DECODED
SIGNALS ON THE CONTROL LOGIC BOARDS.  THE FOLLOWING DECODER SIGNALS ARE
NOT VERIFIED, AS THEY WILL BE CHECKED WITH THE LOGIC THEY CONTROL:  "COND/
AD FLAGS", "COND/PCF_#", "COND/FE SHRT","CONDEBOX STATE", "COND/
EBUS CTL", "CON SKIP EN 60-67", AND "CON SKIP EN 70-77".  THE FOUR SIGNALS
"COND/024"-"COND/027" ARE NOT TESTED BECAUSE THEY ARE NOT USED.
%
;INITIALIZE:

ECON1:  MOV     #TOM,R1         ;PTR TO STIMULUS TABLE GOES IN R1.
        MOV     #DICK,R2                ;PTR TO MCOMP'S # TABLE GOES IN R2
        MOV     #HARRY,R3               ;PTR TO MCOMP'S BYTE TABLE TO R3.
        $NOC0
;START MAIN LOOP HERE:

JOE:    INSYNC          ;NEW SUBTEST
        CLEAR                   ;CLEAR MACHINE
        $CLRMI          ;AND MICROWORD BUFFER
        CMP     SUBNR,#2        ;SEE IF DOING 1ST TWO SUBTESTS
        BGT     SAM             ;SKIP NEXT IF NOT
        $NUM    400             ;SET CR #00 FOR 1ST TWO SUBTESTS


SAM:    MOVB    (R1)+,R0        ;GET NEXT STIMULUS BYTE
        BGE     JACK            ;CONTINUE IF NOT STOP BYTE
        JMP     NORMAL          ;PTHERWISE, YOU'RE DONE-BACK TO DISPATCH
JACK:   $COND           ;USE STIMULUS BYTE TO SET "COND" FIELD
        $MWORD          ;WRITE MICROWORD TO CR
        CTLMCR          ;AND COMPARE RESULTING SIGNALS
        BR      JOE             ;LOOP, IF NO ERROR


;SEQ262

;HERE IS THE STIMULUS TABLE:  BYTES ARE "COND" FIELD VALUES:

TOM:    .BYTE   20              ;SUBTEST #1: "COND/DIAG FUNC"
        .BYTE   17              ;2: "COND/SEL VMA"
        .BYTE   33              ;3:"COND/VMA #"
        .BYTE   14              ;4:  "COND/LIRZ'
        .BYTE   40              ;5: "SKIP EN 40-47"
        .BYTE   10              ;6:  "COND/FM WRITE"
        .BYTE   15              ;7:"COND/SPEC INSTR"
        .BYTE   35              ;8:  "COND/VMA DEC"
        .BYTE   36              ;9: "COND/VMA INC"
        .BYTE   0               ;10: "COND EN 00-07"
        .BYTE   16              ;11:  "COND/SR #"
        .BYTE   20              ;12:  "COND/DIAG FUNC"
        .BYTE   23              ;13: "COND/MBOX CTL"
        .BYTE   34              ;14: "COND/VMA #"
        .BYTE   37              ;15: "COND/LOAD VMA HELD"
        .BYTE   50              ;16: "SKIP EN 50-57"
        .BYTE   377             ;STOP CODE

;HERE ARE MCOMP TABLES:

DICK:   .BYTE   1               ;SUBTEST #1: 1 CHANGE
        .BYTE   2               ;2
        .BYTE   1               ;3
        .BYTE   2               ;4
        .BYTE   1               ;5
        .BYTE   2               ;6
        .BYTE   1               ;7
        .BYTE   1               ;8
        .BYTE   1               ;9
        .BYTE   1               ;10
        .BYTE   1               ;11
        .BYTE   0               ;12 - NO CHANGES
        .BYTE   1               ;13
        .BYTE   1               ;14
        .BYTE   1               ;15
        .BYTE   1               ;16


;SEQ263

HARRY:  .BYTE   21
        .BYTE   145             ;SUBTEST #1:  "CON DELAY REQ"
        .BYTE   16
        .BYTE   134             ;SUBTEST #2:  "-CON COND/SEL VMA"
        .BYTE   25
        .BYTE   3               ;       "VMA HELD OR PC'S 11 & 12"
        .BYTE   17      
        .BYTE   153             ;SUBTEST #3:    "CON COND/VMA_#"
        .BYTE   16
        .BYTE   170             ;SUBTEST #4:  "-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   105             ;"CON LOAD ACCESS COND"
        .BYTE   17
        .BYTE   13              ;SUBTEST #5: "-CON SKIP EN 40-47"
        .BYTE   7
        .BYTE   40              ;SUBTEST #6:  "-APR FM WRITE"
        .BYTE   20
        .BYTE   100             ;"-CON FM WRTIE PAR"

        .BYTE   21
        .BYTE   5               ;SUBTEST #7: "-CON LOAD SPEC INSTR:
        .BYTE   22
        .BYTE   1               ;SUBTEST#8:"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;SUBTEST #9: "-CON VMA SEL 1"
        .BYTE   16
        .BYTE   74              ;SUBTEST #10: "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   105             ;SUBTEST #11:"CON LOAD ACCESS COND"
        .BYTE   16
        .BYTE   154             ;SUBTEST #13: "-CON COND/MBOX CTL" &"-CON COND EN 00-07
        .BYTE   17
        .BYTE   153     ;SUBTST #14:  "CON COND/VMA_#
        .BYTE   20
        .BYTE   141             ;SUBTEST #15:  "CON CON/LOAD VMA HELD"
        .BYTE   20
        .BYTE   1               ;SUBTEST #16: "-CON SKIP EN 50-57"
        .EVEN



;SEQ264

.SBTTL TEST 24 (ECON2)/EAPR1: CONO APR, PI, PAG AND DATAO LOGIC

.REM    %
THIS TEST EXERCISES THE FLIP-FLOPS WHICH ARE CONTROLLED BY THE "CON #
FUNC 01X" DECODING OF "CON COND/DIAG FUNC" AND THE MAGIC # FIELD.  THIS
INCLUDES THE DECODERS ON CON3. THE REGISTERS CONTROLLED YB CONO PI AND
CONO PAG ON CON3.  THE DATA0 APR REGISTER ON APR3 AND THE APR ERROR
INTERRUPT LOGIC ON APR1 AND APR2.  NOTE THAT ONLY THE INTERNAL CONTROL
OF THE ERROR FLOPS IS TESTED HERE; THE RESPONSE TO ACTUAL ERROR CONDITIONS
COMES MUCH LATER.
%

;INITIALIZE FOR 1ST 72 SUBTESTS (APR ERROR INTERRUPT LOGIC):

ECON2:  MOV     #EWORD1+3,R1    ;R1 PTS BITS 4-11 IN 36-BIT BUFFER
        MOV     #HAWAII,R2      ;R2 PYS TO MCOMP'S # TABLE.
        MOV     #FIJI,R3        ;R3 PTS TO MCOMPS VALUE TABLE.
        MOV     #EWORD1+1,R4    ;R4 PTS TO BITS 20-27 IN 36-BIT BUFFER
        MOVB    #170,CTLMSK     ;UNMASK TEH "ERROR IN" SIGNALS
        MOVB    #3,CTLMSK+10    ;FOR THIS TEST ONLY
        $COND   20              ;SET "COND/DIAG FUNC".
        $NUM    14              ;AND MAGIC # FOR "CONO APR"

;INITIALIZE 36-BIT BUFFER (NOTE THAT THIS BUFFER GETS ROTATED RIGHT TWO BITS BEFORE
;IT IS USED-BIT DESIGNATIONS IN COMMENTS REFER TO ACTUAL EBUS BIT #'S).
        MOVB    #BIT7,(R1)      ;AND SET EBUS BIT 6.

;CHANGE SOME EXPECTED DATA TO SAVE MCOMP BYTES:
        $NOC0           ;EXPECT "-CON COND EN 00-07" FALSE.


;SEQ265

;HERE FOR EACH NEW SUBTEST:

SAMOA:  INSYNC          ;NEW SUBTEST (#1 + 9N,N=0,1,2,3,4,5,6, & 7)
        CMP     #^D72,SUBNR     ;STILL DOING APR INTERRUPT TESTS?
        BLT     TONGA           ;NOPE, GO AROUND INTERRUPT STUFF.

;RESET AND THEN SET AN INTERRUPT FLOP AND 9WHERE APPROPRIATE) SET "ANY EBOX ERR FLG":

        MOV     R3,-(SP)        ;SAVE CURRENT VALUE OF MCOMP'S PTRS.
        MOV     R2,-(SP)
        CLEAR                   ;DOING INTERRUPTS, DO A MR.
        $MWORD                  ;WRITE THE BUFFER TO CR
        MOVB    #100,(R4)+      ;SET EBUS BIT 23 (FOR "CON SEL SET")
        CLRB    (R4)            ;NO "EN" OR "DIS"
        JSR     PC,HULA         ;SEE IF CORRECT INT COMES UP.

;REMOVE SET, CLOCK FLOP TO TEST HOLD:
        INSYNC          ;NEW SUBTEST (#2+9N).
        CLRB    -(R4)   ;CLEAR "CON SEL SET"
        MOV     (SP),R2         ;BACK UP MCOMP PTRS
        MOV     2(SP),R3        
        JSR     PC,HULA         ;SEE IF BIT STAYS SET.

;COMPLIMENT EBUS BITS 6-13 (ONES CONTROLLING INT. FLOPS) & TRY TO CLEAR:
        INSYNC                  ;NEW SUBTEST (#3+9N)
        COMB    (R1)            ;EVERY BIT BUT THE RIGHT ONE.
        MOVB    #200,(R4)               ;BRING UP EBUS BIT 22 ("CON SEL CLR")>
        MOV     (SP)+,R2        ;BACK UP MCOMP PTRS AGAIN
        MOV     (SP)+,R3        
        JSR     PC,HULA         ;SEE THAT BIT DOESN'T CLEAR.


;SEQ266

;COMPLIMENT BITS AGAIN & REALLY CLEAR:

        INSYNC          ;NEW SUBTEST (#4+9N).
        COMB    (R1)    ;BACK TO ONLY RIGHT BITS.
        JSR     PC,HULA         ;SEE THAT BIT DID CLEAR.

;SET AN INTERRUPT ENABLE FLOP:
        INSYNC                  ;NEW SUBTEST (#5+9N).

        CLRB    (R4)+           ;NO "SET" OR "CLR"
        MOVB    #2,(R4)         ;BRING UP EBUS BIT 20 ("CON SEL EN").
        MOV     R3,-(SP)        ;SAVE CURRENT MCOMP PTRS.
        MOV     R2,-(SP)
        JSR     PC,HULA         ;SEE IF ENABLE CAME UP.

;REMOVE SET, CLOCK & MAKE SURE DATA HOLDS:

        INSYNC                  ;NEW SUBTEST (#6+9N)
        CLRB    (R4)            ;NO ENABLE.
        MOV     (SP),R2 ;RESOTRE PTRS.
        MOV     2(SP),R3
        JSR     PC,HULA         ;SEE IF BIT STILL SET.

;TRY TO CLER WITH WRONG BITS:

        INSYNC          ;NEW SUBTEST (#7+9N).
        COMB    (R1)            ;COMPLIMENT BITS.
        MOVB    #1,(R4)         ;SET "CON SEL DIS".
        MOV     (SP)+,R2        ;RESET PTS
        MOV     (SP),R3 
        JSR     PC,HULA         ;BIT SHOULD STILL BE THERE.
;CLEAR WITH RIGHT BIT:

        INSYNC          ;NEW SUBTEST (#8+9N).
        COMB    (R1)            ;CORRECT BIT BACK.
        JSR     PC,HULA         ;THIS TIME IT SHOULD CLEAR.


;SEQ267

;SET AN INTERRUPT WITH AN ENABLE:

        INSYNC          ;NEW SUBTEST (#9+9N).
        MOVB    #2,(R4) ;SET BOTH SEL SET & SEL EN.
        MOVB    #100,-(R4)      
        MOV     (SP)+,R3        ;RESET PTR.
        JSR     PC,HULA         ;SEE WHAT'S WHAT/

;SHIFT EBUS BIT TO NEXT POSITION:
        RORB    (R1)            ;SHIFT BIT TO RIGHT.
        BR      SAMOA           ;DO MORE

;TEST REGISTER ON APR3 USING "DATAO APR" & EBUS BITS 9-12:

TONGA:  CLEAR           ;CLEAR REMAINS OF ERR INT TEST
        $NUM    17              ;CHANGE NUM FIELD TO "DATAO APR"
        $MWORD          ;WRITE NEW CR
        MOVB    #20, (R1)        ;SET EBUS BIT 9.

OAHU:   INSYNC          ;SUBTESTS 73-77.
        JSR     PC,HULA         ;SET AND CHECK A BIT.
        ASRB    (R1)            ;NEXT BIT.
        BNE     OAHU            ;LOOP TILL DONE.

;SEQ268

;TEST THAT "ALMOST" CONO SIGNALS DON'T SET ANY FLOPS:

        COMB    (R1)            ;SET EBUS BITS 6-13.
        MOV     #MAUI,R1                ;NOW USE R1 TO PT TO TABLE OF # VALUES
        CLEAR                   ;SUBTEST #78: DROP "COND/DIAG FUNC"
        $COND   0
        MOVB    (R1)+,R0        ;SET "COPNO APR" # FROM TABLE.
        $NUM
        $MWORD  
        JSR     PC,HULA         ;SEE IF ANY TAKES.
        $COND   20              ;RESTORE "COND/DIAG FUNC"
        MOV     #4,R4           ;SUE R4 TO COUNT.

HILO:   INSYNC          ;SUBTRESTS 79-82.
        MOVB    (R1)+,R0        ;GET NEXT # FIELD VALUE.
        $NUM                    ;WRITE IT TO BUFFER.
        $MWORD          
        JSR     PC,HULA         ;SEE WHAT'S COOKIN".
        DEC     R4              ;DOWN COUNT.
        BGT     HILO            ;LOOP.

;SEQ269

;TEST REGISTERS ON CON3 SET BY "CONO PI" & "CONO PAG":

        INSYNC                  ;SUBTEST #83.
        MOVB    (R1)+,R0        ;SET # FIELD FOR "CONO PI"
        $NUM
        $MWORD                  
        MOV     #EWORD1+1,R4    ;R4 PTS TO BUF
        CLRB    (R4)+           ;CLEAR SOME BITS
        MOVB    #10,(R4)        ;BUT SET BIT 18
        JSR     PC,HULA         ;CHECK FOR "WR EVEN PAR ADR"
        INSYNC                  ;SEBTEST #84.
        MOVB    #4,(R4)         ;SET EBUS BIT 19
        JSR     PC,HULA         ;TEST.

        INSYNC                  ;SUBTYEST #85.
        MOVB    #2,(R4)         ;AND SET BIT 20.
        JSR     PC,HULA         ;TEST.
        INSYNC                  ;SUBTEST #86.
        CLRB    (R4)            ;CLEAR EBUS BIT 20.
        JSR     PC,HULA         ;NOTHING SHOULD BE UP.
        MOVB    (R1),R0 ;SET "CONO PAG" MAGIC #.
        $NUM                    ;IN BUFFER
        $MWORD
        MOV     #5,R1           ;USE R1 TO COUNT NEXT 5 TESTS.
        $CLRWD          ;CLEAR OLD STUFF
        MOVB    #20,(R4)        ;SET EBUS BIT 17 IN BUFFER.


;SEQ270

ALOHA:  INSYNC                  ;SUBTESTS #87-91.
        $RORWD                  ;SLIDE EBUS BIT RIGHT ONE.
        JSR     PC,HULA         ;SET A BIT AND CHECK IT.
        DEC     R1              ;COUNT.
        BGT     ALOHA           ;LOOP TILL DONE BITS 0-4.

        JMP     NORMAL          ;FINALLY DONE!

;THIS IS A SUBROUTINE TO DO THE APR INTERRUPT LOGIC COMPARES.  IT 1) ROTATES
;THE EBUS DATA INTO POSITION, 2)LOADS THE AR WITH IT, 3)CLOCKS CR
;4)MODIFIES, COMPARES AND RESTORES THE CONTROL SIGNALS & 5)ROTATES THE
;EBUS BUFFER BACK TO WHERE IT STARTED.

HULA:   $RORWD                  ;ROTATE EBUS BUFFER RIGHT 2 BITS.
        $RORWD                  
        STUFF                   ;WRITE BUFFER TO THE AR.
        ECLOK           ;THIS CAUSED TROUBLE
        CTLMCR          ;MODIFY, COMPARE & RESOTRE DATA.

        $ROLWD          ;"UNROTATE" EBUS BUFFER
        $ROLWD
        RTS     PC              ;AND RETURN.

;TABLE OF MAGIC #'S.

MAUI:   .BYTE   14              ;SUBTEST #78: MAGIC # FOR "CON APR"
        .BYTE   114             ;79.
        .BYTE   54              ;80.
        .BYTE   34              ;81.
        .BYTE   4               ;82.
        .BYTE   15              ;83-84.  "CONO PI"
        .BYTE   16              ;87-91  "CONO PAG"


;SEQ271


;MCOMP'S # TABLE:

HAWAII: .BYTE   1               ;SUBTESTS #1,2 & 3:  1 CHANGE
        .BYTE   0               ;4
        .BYTE   1               ;5,6 & 7
        .BYTE   0               ;8
        .BYTE   3               ;9
        .BYTE   2               ;SUBTESTS #10,11 & 12
        .BYTE   0               ;13
        .BYTE   1               ;14,15 & 16
        .BYTE   0               ;17
        .BYTE   4               ;18
        .BYTE   1               ;SUBTESTS #19,20 & 21
        .BYTE   0               ;22
        .BYTE   1               ;23,24 & 25
        .BYTE   0               ;26
        .BYTE   3               ;27
        .BYTE   2               ;SUBTEST #28,29 & 30
        .BYTE   0               ;31
        .BYTE   1               ;32,33 & 34
        .BYTE   0               ;35
        .BYTE   3               ;36
        .BYTE   1               ;SUBTESTS, #37,38 & 39
        .BYTE   0               ;40
        .BYTE   1               ;41,42 & 43
        .BYTE   0               ;44
        .BYTE   2               ;45


;SEQ272

        .BYTE   2               ;SUBTEST #46,47 & 48
        .BYTE   0               ;49
        .BYTE   1               ;50,51 & 52
        .BYTE   0               ;53
        .BYTE   3               ;54
        .BYTE   1               ;SUBTESTS #55,56 & 57
        .BYTE   0               ;58
        .BYTE   1               ;59,60, & 61
        .BYTE   0               ;62
        .BYTE   2               ;63
        .BYTE   1               ;SUBTESTS #64,64 & 66
        .BYTE   0               ;67
        .BYTE   1               ;68,69 & 70
        .BYTE   0               ;71
        .BYTE   2               ;72
        .BYTE   1               ;73:  DATAO REG
        .BYTE   1               ;74
        .BYTE   1               ;75
        .BYTE   1               ;76
        .BYTE   0               ;77

        .BYTE   2               ;78:  NEAR MISS CONO'S
        .BYTE   0               ;79
        .BYTE   0               ;80
        .BYTE   0               ;81
        .BYTE   0               ;82

        .BYTE   2               ;83:  CONO PI REG
        .BYTE   1               ;84
        .BYTE   1               ;85
        .BYTE   0               ;86

        .BYTE   1               ;87  CONO PAG REG.
        .BYTE   1               ;88
        .BYTE   0               ;89
        .BYTE   1               ;90
        .BYTE   1               ;91


;SEQ273

;MCOMP'S VALUE TABLE:

FIJI:   .BYTE   0               
        .BYTE   4               ;SUBTESTS #1,2, & 3:  "APR SBUS ERR IN"
        .BYTE   4
        .BYTE   200             ;SUBTESTS #5-9:  "APR SBUS ERR EN IN"
        .BYTE   0
                .BYTE   4               ;SUBTEST#9: "APR SBUS ERR IN"
        .BYTE   10      
        .BYTE   4               ;"APR APR INTERRUPT"
        .BYTE   0
        .BYTE   2               ;SUBTESTS #10,11 & 12: "APR NXM ERR IN"
        .BYTE   6               
        .BYTE   64              ;"APR ANY EBOX ERR FLG"
        .BYTE   4
        .BYTE   100             ;SUBTESTS #14-18:"APR NXM ERR EN IN"
        .BYTE   0
        .BYTE   2               ;SUBTEST #18:  "APR NXM ERR IN"
        .BYTE   6
        .BYTE   64              ;"APR ANY EBOX ERR FLAG"
        .BYTE   10
        .BYTE   4               ;"APR APR INTERRUPT":

        .BYTE   0
        .BYTE   1               ;SUBTESTS #19,20 &21:  "APR I/O PF ERR IN"
        .BYTE   4
        .BYTE   40              ;SUBTESTS #23-27: "APR I/O PF ERR EN IN"
        .BYTE   0
        .BYTE   1               ;SUBTEST #27:  "APR I/O PF ER IN"
        .BYTE   10
        .BYTE   4               ;"APR APR INTERRUPT"
        .BYTE   10
        .BYTE   200             ;SUBTESTS #28,29 & 30:  "APR MB PAR ERR IN"
        .BYTE   6
        .BYTE   64              ;"APR NY EBOX EFRR FLG"



;SEQ274

        .BYTE   4
        .BYTE   20              ;SUBTESTS #32-36:  "APR MB PAR ERR EN IN"
        .BYTE   6
        .BYTE   64              ;SUBTEST #36: "APR ANY EBOX ERR FLG"
        .BYTE   10
        .BYTE   204             ;"APR MB PAR ERR IN" & "APR APR INTERRUPT"
        .BYTE   10
        .BYTE   100             ;SUBTESTS #37,38 & 39:  "APR C DIR P ERR IN"
        .BYTE   4
        .BYTE   10              ;SUBTESTS #41-45:  "APR C DIR P ERR EN IN"
        .BYTE   10
        .BYTE   104             ;SUBTEST #45:  "APR C DIR P ERR IN" & "APR APR INTERRUPT"
        .BYTE   10
        .BYTE   40              ;SUBTESTS #46,47 & 48:  "APR S ADR P ERR IN:
        .BYTE   6
        .BYTE   64              ;"APR ANY EBOX ERR FLG"
        .BYTE   4
        .BYTE   4               ;SUBTESTS #50-54: "APR S ADR P ERR EN IN"
        .BYTE   6
        .BYTE   64              ;SUBTESTS #54:  "APR ANY EBOXC ERR FLG"
        .BYTE   10              
        .BYTE   44              ;"APR S ADR P ERR IN" & "APR APR INTERRUPT"
        .BYTE   10
        .BYTE   20              ;SUBTESTS #55,56&57: "APR PWR FAIL IN"
        .BYTE   4
        .BYTE   2               ;SUBTESTS #59=-63:  "APR PWR FAIL EN IN"
        .BYTE  10
        .BYTE   24              ;SUBTEST #63:  "APR PWR FAIL IN " & "APR APR INTERRUPT"
        .BYTE   10
        .BYTE   10              ;SUBTESTS #64,65 & 66:  "APR SWEEP DONE IN"
        .BYTE   4
        .BYTE   1               ;SUBTESTS #68-72:  "APR SWEEP DONE EN IN"
        .BYTE   10
        .BYTE   14              ;SUBTEST #72:  "APR SWEEP DONE IN" & "APR APR INTERRUPT"


;SEQ275

        .BYTE   5               
        .BYTE   20              ;SUBTEST #73:  "APR FETCH COMP"

        .BYTE   5
        .BYTE   10              ;SUBTEST #74:  "APR READ COMP"
        .BYTE   5
        .BYTE   4               ;SUBTEST #75:  "APR WRITE COMP"
        
        .BYTE  5
        .BYTE   2               ;SUBTEST #76:  "APR USER COMP"
        .BYTE   16
        .BYTE   74              ;SUBTEST #78:  "-CON COND EN 00-07(TRUE)"
        .BYTE   21
        .BYTE   45              ;"CON DELAY REQ" (NOW ZERO)
        .BYTE   13
        .BYTE   7               ;SUBTEST #83:  "-APR WR BAD ADR PAR"
        .BYTE   14
        .BYTE   100             ;"CON WR EVEN PAR ADR"
        .BYTE   14
        .BYTE   40              ;SUBTEST #84:  "CON WR EVEN PAR DATA"
        .BYTE   14
        .BYTE   20              ;SUBTEST #85:  "CON WR EVEN PAR DIR2
        .BYTE   15
        .BYTE   100             ;SUBTEST #87:  "CON CACHE LOOK EN"
        .BYTE   15              
        .BYTE   40              ;SUBTEST #88:  "CON CACHE LOAD EN"
        .BYTE   15
        .BYTE   10              ;SUBTEST #90:  "-CON KI PAGING MODE"
        .BYTE   15
        .BYTE   4               ;SUBTEST #91:  "CON TRAP EN"
        .EVEN


;SEQ276

.SBTTL TEST 25 9ECON3):  UDOCE & PROCESSOR STATE REGISTERS

.REM    %
THIS TESTS THE MICROCODE AND PROCESSOR STATE REGISTERS ON THE
CON BOARD.
%

;INITIALIZE:

ECON3:  MOV     #BACH,R2                ;PTR TO MCOMP'S # TABLE.
        MOV     #MOZART,R3              ;PTR TO MCOMP'S BYTE TABLE.
        MOV     #400,R4         ;R4 HOLDS CURRENT # VALUE.

        $NOC0                   ;EXPECT "-CON COND EN 00-07" FLASE.

        $COND   21              ;SET "COND/EBOX STATE" IN BUFFER.
        
;TEST UCODE STATE REGISTER'S RESPONSE TO SLIDING # BIT:

LUDWIG: INSYNCQ         ;NEW SUBTEST (9 IN THIS LOOP)
        MOV     R4,R0           ;COPY CURRENT # BIT IN R0
        $NUM                    ;AND THEN GO TO BUFFER
        $XBUF                   ;EXECUTE BUFFER
        CTLMCR          ;SEE IF PROPER BIT CAME UP.
        ASR     R4              ;SHIFT # BIT DOWN.
        BNE     LUDWIG          ;KEEP TRUCKIN' UNTIL BIT FALLS OFF END.


;SEQ277

;TEST THAT REG CAN HOLD DATA:

        INSYNCY                 ;SUBTEST #10
        $NUM    252             ;SET ALL 4 BITS
        $XBUF0          ;EXECUTE AND CLEAR BUFFER
        ECLOK                   ;DATA SHOULD HOLD
        CTLMCR                  ;SEE IF IT DOES

;TEST SR RESPONSE:

        CLEAR                   ;GET RID OF OLD UCODE REG DATA

        MOVB    #105,CTLDAT+20  ;EXPECT "CON LOAD ACCESS COND"
        MOV     #WAGNER,R1      ;PTR TO TABLE OF # VALUES TO USE.
                $COND   16              ;WRITE "COND/SR #" TO BUFFER.


;SEQ278

HAYDN:  INSYNC                  ;NEW SUBTEST (7 IN THIS LOOP)
        MOVB    (R1),R0         ;GET # VALUE TO BE LOADED.
        $NUM                    ;WRITE IT TO BUDFFER.
        $XBUF                    ;EXECUTE BUFFER
        CTLMCR                  ;COMPARE
        TSTB    (R1)+           ;DID YOU JUST DO ZERO?
        BNE     HAYDN           ;IF NOT, DO MORE.

;TEST THAT REG CAN HOLD DATA:

        INSYNC          ;SUBTEST #18.
        $NUM    17              ;SET ALL 4 BITS
        $XBUF0          ;EXECUTE AND CLEAR BUFFER
        ECLOK                   ;DATA SHOULD HOLD
                
        CTLMCR                  ;DID IT?
        JMP     NORMAL          ;DONE!


;SEQ279

;HERE ARE SOME #'S TO USE WITH SR TEST:

WAGNER: .BYTE   10              ;SUBTEST #11: SET SR00
        .BYTE   4               ;12:  SR01
        .BYTE   2               ;13:  SR02
        .BYTE   40              ;14:  RECIRCULATE SR02
        .BYTE   1               ;15:  SR03
        .BYTE   20              ;16:  RECIRCULATE SR03
        .BYTE   0               ;17:  NOTHING SHOULD SET.

;MCOMP'S #-OF-CHANGES TABLE:

BACH:   .BYTE   0               ;SUBTEST #1:  NO CHANGES YET.
        .BYTE   1               ;2
        .BYTE   1               ;3
        .BYTE   1               ;4
        .BYTE   1               ;5
        .BYTE   1               ;6
        .BYTE   1               ;7
        .BYTE   1               ;8
        .BYTE   1               ;9
        .BYTE   5               ;10

        .BYTE   1               ;11
        .BYTE   1               ;12
        .BYTE   1               ;13
        .BYTE   1               ;14
        .BYTE   1               ;15
        .BYTE   1               ;16
        .BYTE   0               ;17 - NO CHANGES
        .BYTE   5               ;18


;SEQ280

;MCOMP'S VALUE TABLE:

MOZART: .BYTE   20
        .BYTE   103             ;SUBTEST #2:  UC01
        .BYTE   20              ;
        .BYTE   103             ;SUBTEST #3:  SAME
        .BYTE   21
        .BYTE   47              ;SUBTEST #4:  UC03
        .BYTE   21
        .BYTE   47              ;SUBTEST #5: SAME
        .BYTE   22
        .BYTE   43              ;SUBTEST #6:  UC05
        .BYTE   22
        .BYTE   43              ;SUBTEST #7:  SAME
        .BYTE   23
        .BYTE   53              ;SUBTEST #8:  UC07      
        .BYTE   23
        .BYTE   53              ;SUBTEST #9:  SAME
        .BYTE   16
        .BYTE   74              ;SUBTEST #10:  "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   103             ;       UC01
        .BYTE   21              ;
        .BYTE   47              ;       UC03
        .BYTE   22      
        .BYTE   43              ;       UC05
        .BYTE   23
        .BYTE   53              ;       UC07

;SEQ281

        .BYTE   20
        .BYTE   125             ;SUBTEST #11: SR00 & LOAD ACCESS COND
        .BYTE   21
        .BYTE   65              ;SUBTEST #12:  SR01
        .BYTE   22              
        .BYTE   61              ;SUBTEST #13:  SR02
        .BYTE   22
        .BYTE   61              ;SUBTEST #14:  SAME
        .BYTE   23
        .BYTE   71              ;SUBTEST #15:  SR03
        .BYTE   23
        .BYTE   71              ;SUBTEST #16:  SAME
        .BYTE   16
        .BYTE   74              ;SUBTEST #17:  "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   121             ;       SR00
        .BYTE 21
        .BYTE   65              ;       SR01
        .BYTE   22
        .BYTE   61              ;       SR02
        .BYTE   23
        .BYTE   71              ;       SR03

        .EVEN


;SEQ282

.SBTTL TEST 26 (EAPR2): EBUS CTL, MBOX CTL & REG FUNC WITH # FIELD DECODING

.REM    %
THIS TESTS THE EBUS CONTROL REGISTER ON APR3, THE MBOX CONTROL LOGIC ON APR5,
        
AND THE REGISTER FUNCTION DECODING ON APR6.  ALL THREE INVOLVE THE DECODING
OF A MICROCODE FUNCTION WITH THE MAGIC # FIELD.

%
;INITIALIZE PTRS:

EAPR2:  MOV     #BEER,R1        ;R1 PTS TO # TABLE
        MOV     #ALE,R2 ;R2 PTS MCOMP'S # TABLE
        MOV     #STOUT,R3       ;R3 PTS TO MCOMP'S BYTE TABLE

;START WITH MBOX CTL REGISTER AND FLOAT A "1" THROUGH # FIELD:
        MOV     #200,R4         ;R4 WILL JOLD THE CURRENT # VALUE

VODKA:  INSYNC                  ;NEW SUBTEST - 14 THIS LOOP
        CLEAR                   ;BEST START FRESH
        ASR     R4              ;NEXT # POSITION
        BEQ     RUM             ;EXIT WHEN BIT FALLS OFF END
        MOV     R4,R0           ;PUT # BIT IN R0 AND
        $NUM                    ;WRITE IT TO BUFFER.
        $COND   23              ;SET "COND/MBOX CTL" IN BUFFER
        $XBUF           ;EXECUTE BUFFER
        MOVB    #154,CTLDAT+16   ;EXPECT "-COND/MBOX CTL" (TRUE) & "COND EN 0-7"(FALSE)
        CTLMCR                  ;COMPARE
        INSYNC                  ;EVEN SUBTESTS TEST "HOLD"
        $CLRMI                  ;CLEAR BUFFER
        $XBUF                   ;LOAD BUFFER TO CR
        MOVB    #74,CTLDAT+16   ;RESTORE THE EXPECTED CHANGED ABOVE.
        CTLMCR                  ;COMPARE
        BR      VODKA           ;DO THE NEXT ONE


;SEQ283

;NOW DO EBUS CTL REGISTER USING # BYTES FROM THE TABLE.

GIN:    INSYNC                  ;SUBTESTS 15-26
RUM:    CLEAR           ;FRESHEN UP THE MACHINE
        CMP     #^D21,SUBNR     ;SET AC#4 AFTER SUBTEST #20
        BGT     SCOTCH          ;OTHERWISE LEAVE AC#=0.
        $ACSET  4               ;THIS IS TO CLEAR "-APR AC 10"
        MOVB    #40,CTLDAT+12   ;EXPECT IT, TOO.

SCOTCH: MOV     (R1)+,R0        ;GET NEXT # FIELD  VALUE.
        $NUM                    ;WRITE IT TO BUFFER.
        $COND   22              ;SET "CONT/EBUS CTL" IN BUFFER.
        $XBUF                   ;EXECUTE BUFFER
        $NOC0           ;EXPECT "-CON COND EN 00-07" FALSE

        CTLMCR                  ;COMPARE.
        CMP     #^D26,SUBNR     ;SEE IF DONE YET.
        BGT     GIN             ;LOOP IF NOT


;SEQ284

;NOW DO "HOLD" TEST ON THIS REGISTER:

        INSYNC                  ;SUBTEST #27
        $XBUF0                  ;CR FROM $MICRO, 0'S TO BUF & CR
        MOVB    #74,CTLDAT+16   ;NOW "-CON COND EN 00-07" IS TRUE.
        CTLMCR                  ;COMPARE

;NOW CHECK THE REG FUNC REGISTER ON APR6:

BRANDY: INSYNC                  ;SUBTESTS 28-39

        CLEAR                   ;FRESH START
        MOV     (R1)+,R0 ;GET # FIELD
        $NUM                    ;WRITE IT TO BUFFER.
        $MEM    7               ;SET "MEM/REG FUNC" IN BUFFER.
        $XBUF                   ;LOAD CR FROM $MICRO & CLOCK

        $MEMRQ                  ;EXPE T MEMORY REQUEST SIGNALS
        MOVB    #44,CTLDAT+21   ;AND 'CON MBXO WAIT" (DO TO M/REGF)
        MOVB    #5,CTLDAT+31            ;AND MCL VMAX SEL 2
        MOVB    #24,CTLDAT+32   ;AND "MCL VMAX SEL 1"
        CTLMCR                  ;COMPARE
        CMP     #^D39,SUBNR     ;SEE IF DONE.
        BGT     BRANDY          ;LOOP IF NOT.


;SEQ285

;MAKE SURE REG HOLDS:

        INSYNC                  ;SUBTEST #40
        $MEM    0               ;CLEAR "MEM/REG" FUNCH IN BUFFER
        $XBUF                   ;LOAD CR AND CLOCK IT
        CTLMCR                  ;COMPARE

;AND MAKE SURE REG RESPONDS TO REG FUNC:

        INSYNC                  ;SUBTEST #41
        CLEAR                   ;FRESH START
        $MEM    10              ;BRING UP "MEM/AD FUNC" TO (TO CAUSE REQ EN)
        $XBUF                   ;EXECUTE BUFFER
        CTLMCR                  ;COMPARE

        JMP     NORMAL          ;AND DONE.


;SEQ286

;MAGIC # TABLE:

BEER:   .WORD   400             ;SUBTEST #15;  CR#00
        .WORD   200             ;16: CR#01
        .WORD   100             ;17:  CR#02
        .WORD   40              ;18:  CR#03
        .WORD   20              ;19:  CR#04 (TURN ON LATCH)
        .WORD   30              ;20:  CR#04&5 (ON + SWITCH)
        .WORD   24              ;21:  CR#04&6
        .WORD   34              ;22:  CR#04,5&6
        .WORD   22              ;23:  CR#04&7
        .WORD   21              ;24:  CR#04&8
        .WORD   7               ;25:  CR#06&8 (NO HOLD)
        .WORD   667             ;26:  LIGHT 'EM ALL UP.

        .WORD   400             ;28:  CR#00
        .WORD   200             ;29:  CR#01
        .WORD   100             ;30:  CR#02
        .WORD   40              ;31:  CR#03
        .WORD   1               ;32:  CR#08
        .WORD   2               ;33: CR#07
        .WORD   3               ;34:  CR#07&08
        .WORD   4               ;35:  CR#06
        .WORD   5               ;36:  CR#06&8
        .WORD   6               ;37:  CR#06&7
        .WORD   7               ;38:  CR#06,7&8
        .WORD   747             ;39:  LIGHT 'EM UP.

;SEQ287

ALE:    .BYTE   1               ;SUBTEST #1 - SET
        .BYTE   1               ;2 - HOLD

        .BYTE   1               ;3
        .BYTE   1               ;4
        .BYTE   1               ;5
        .BYTE   0               ;6
        .BYTE   1               ;7
        .BYTE   0               ;8
        .BYTE  1               ;9
        .BYTE   1               ;10
        .BYTE   1               ;11
        .BYTE   1               ;12
        .BYTE   1               ;13
        .BYTE   1               ;14
        .BYTE   1               ;15
        .BYTE   1               ;16
        .BYTE   1               ;17
        .BYTE   1               ;18
        .BYTE   0               ;19
        .BYTE   2               ;20
        .BYTE   1               ;21
        .BYTE   1               ;22
        .BYTE   1               ;23
        .BYTE   1               ;24
        .BYTE   0               ;25
        .BYTE   4               ;26
        .BYTE   4               ;27


;SEQ288

        .BYTE   2               ;28
        .BYTE   1               ;29
        .BYTE   1               ;30
        .BYTE   2               ;31
        .BYTE   2               ;32B
        .BYTE   2               ;33
        .BYTE   2               ;34
        .BYTE   1               ;35
        .BYTE   2               ;36
        .BYTE   1               ;37B
        .BYTE   1               ;38
        .BYTE   3               ;39
        .BYTE   6               ;40
        .BYTE   4               ;41B


;SEQ289

;MCOMP'S BYTE TABLE:

STOUT:  .BYTE   0       
        .BYTE   1               ;SUBTEST #1:  "APR I/O PF ERR IN"
        .BYTE   0               
        .BYTE   1               ;SUBTEST #2:  "APR I/O PF ERR IN"
        .BYTE   2
        .BYTE   4               ;SUBTEST #3:  "APR MBOX CTL 03"
        .BYTE   2
        .BYTE   4               ;SUBTST #4:  "APR MBOX CTL 03"
        .BYTE   6
        .BYTE   20              ;SUBTEST #5:  "-APR PT DIR WR"
        .BYTE   7
        .BYTE   4               ;SUBTEST #7:  "-APR PT WR"
        .BYTE   3
        .BYTE   6               ;SUBTEST #9:  "APR MBOX CTL 06"
        .BYTE   3
        .BYTE   6               ;SUBTEST #10:  "APR MBOX CTL 06"
        .BYTE   6
        .BYTE   160             ;SUBTEST #11:  "APR WR PT SEL 0"
        .BYTE   6
        .BYTE   160             ;SUBTEST #12:  "APR WR PT SEL 0"
        .BYTE   7
        .BYTE   144             ;SUBTEST #13:  "APR WR PT SEL 1"

        .BYTE   7
        .BYTE   144             ;SUBTEST #14:  "APR WR PT SEL 1"


;SEQ290

        .BYTE   3
        .BYTE   3               ;SUBTEST #15:  "APR EBUS RETURN"

        .BYTE   6
        .BYTE   40              ;SUBTEST #16:  "-APR EBUS REQ"
        .BYTE   17
        .BYTE   133             ;SUBTEST #17:  "CON EBUS DEMAND"
        .BYTE   7
        .BYTE   64              ;SUBTEST #18:   "APR BUS DEMAND"
        .BYTE   6
        .BYTE   70              ;SUBTEST "APR EBUS F01
        .BYTE   7
        .BYTE   54              ;"APR EBOX SEND F02"
        .BYTE   13
        .BYTE   307             ;SUBTEST #21:  "APR EBOX DISABLE CS"
        .BYTE   13
        .BYTE   307             ;SUBTEST #22:  "APR EBOX DISABLE CS"
        .BYTE   6
        .BYTE   70              ;SUBTEST #23:  "APR EBOX F01"
        .BYTE   7
        .BYTE   54              ;SUBTEST #24:   "APR EBOX SEND F02"
        .BYTE   3
        .BYTE   3               ;SUBTEST #26:  "APR EBUS RETURN"
        .BYTE   6
        .BYTE   50              ;"-APR EBUS REQ" & "APR EBUS F01"
        .BYTE   7
        .BYTE   74              ;"APR EBUS DEMAND" & "APR EBOX SEND F02"
        .BYTE   13
        .BYTE   307             ;"APR EBOX DISABLE CS"
        .BYTE   3
        .BYTE   3               ;SUBTEST #27:  "APR EBUS RETURN"
        .BYTE   6
        .BYTE   50              ;"-APR EBUS REQ " & "APR EBUS F01"
        .BYTE   7
        .BYTE   74              ;"APR EBUS DEMAND" & "APR EBOX SEND F02"
        .BYTE   13
        .BYTE   307             ;"APR EBOX DISABLE CS"

;SEQ291

        .BYTE   13              
        .BYTE   103             ;SUBTEST #28:   "-APR MEM/REQ FUNC"
        .BYTE   32
        .BYTE   25              ;"MCL REG FUNC"
        .BYTE   13
        .BYTE   101             ;SUBTEST #29:  "-APR MEM/REG FUNC" & "APR EBOX LOA REG"
        .BYTE   13
        .BYTE   102             ;SUBTEST #30:REG FUNC & "-APR EBOX READ REG"
        .BYTE   13
        .BYTE   102             ;SUBTEST #31:  "-MCL MEM/REG FUNC"
        .BYTE   33
        .BYTE   66              ;"MCL MBOX CYC REQ" & "-MCL EBOX MAP"
        .BYTE   13
        .BYTE   103             ;SUBTEST #32:  M/REG F
        .BYTE   7
        .BYTE   45              ;"APR EBOX SPARE"
        .BYTE   6       

        .BYTE   62              ;SUBTEST #33: "APR EBOX UBR"
        .BYTE   13
        .BYTE   103
        .BYTE   7
        .BYTE   46              ;SUBTEST #34: "APR EBOX EBR"
        .BYTE   13
        .BYTE   103             ;M/RF
        .BYTE   13
        .BYTE   123             ;SUBTEST #35: M/RF & "APR EBOX ERA"
        .BYTE   6
        .BYTE   61              ;SUBTEST #36:  "APR EN REFILL RAM WR"
        .BYTE   13
        .BYTE   103             ;M/RF
        .BYTE   13
        .BYTE   143             ;SUBTEST #37: APR EBOX CCA

;SEQ292

        .BYTE   13
        .BYTE   113             ;SUBTEST #38: M/RF & "APR EBOX SBUS DIAG"
        .BYTE   13
        .BYTE   110             ;SUBTEST #39: SBUS, M/RF, LOAD & READ
        .BYTE   32
        .BYTE   25              ;"MCL REG FUNC"
        .BYTE   33
        .BYTE   66              ;"MCL MBOX CYC REQ" & "-MCL EBOX MAP"
        .BYTE   13
        .BYTE   114             ;SUBTEST #40:  SBUS, LOAD & READ
        .BYTE   21
        .BYTE   45              ;"-CON MBOX WAIT" (NO LONGER TRUE)
        .BYTE   27
        .BYTE   20              ;"-MCL REQ EN " (FALSE)
        .BYTE   32
        .BYTE   21              ;"MCL REG FUNC"
        .BYTE   31
        .BYTE   1               ;"MCL VMAX SEL 2" (NO LONGER TREUE)
        .BYTE   33
        .BYTE   64              ;"-MCL EOX MAP"
        .BYTE   21
        .BYTE   45              ;SUBTEST #41:  "-CON MBOX WAIT" (FALSE)
        .BYTE   26
        .BYTE   3
        .BYTE   30
        .BYTE   3               ;MCL VMA WRITE
        .BYTE   31
        .BYTE   5               ;MCL LOAD AR
        .EVEN


;SEQ293

.SBTTL TEST 27 (EAPR3):  PREVIOUS CONTEXT & AC BLOCK REGISTERS

.REM    %
THIS TEST CHECKS THE 'CON LOAD PREV CONTEXT' AND "CON LOAD AC BLLKS" LOGIC ON
CON3, THE PREVIOUS SECTION EEGISTER ON APR3, AND THE AC BLOCK REGISTERS ON
APR5.  THE FM BLOCK MIXER LOGIC IS COVERED IN THE NEXT TEST, EAPR4.
%

;INITIALIZE:

EAPR3:  MOV     #ROSE,R2                ;R2 PTS TO MCOMP;S TABLE
        MOV     #SHERRY,R3              ;R3 PTS TO MCOMP'S BYUTE TABLE.
        MOV     #MOSEL,R4               ;R4 PTS TO STIMULUS TABLE

;SET UP[ TO DO BOTH "LOAD PREV CONTEXT" AND "LOAD AC BLOCKS":

        $COND   20              ;SET "COND/DIAG FUNC" IN BUFFER
        $NOC0                   ;EXPECT "-CON COND EN 00-07" FALSE
        $NUM    224             ;(THE CR#01 WILL SET CWSX FOR EBUS BIT 12).
        $MWORD                  ;WRITE IT TO CR

;SET EBUS BIT 5 TO START:

        MOVB    #100,EWORD1+3   ;SET EBUS BIT 5 IN 36-BIT BUFFER.

;MAIN LOOP STARTS HERE:

PORT:   INSYNC                  ;SUBTESTS 1-12
        $RORWD          ;SHIFT 36-BIT BIFFER RIGHT ONE PLACE.
        STUFF                   ;LOAD AR FROM BUFFER
        ECLOK                   ;CLOCK THE REGISTERS
        CTLMCR                  ;COMPARE
        CMP     #^D12,SUBNR     ;SEE IF DONE
        BGT     PORT            ;LOOP IF NOT.


;SEQ294

;NOW SET ALL RELAVENT EBUS BITS & TRY "NEAR MISS" LOAD FUNCTIONS:

MEDOC:  INSYNC                  ;SUBTESTS 13=18
        CLEAR           ;START FRESH EACH TIME
        MOV     #37774,EWORD1+2 ;SET EBUS BITS 6-17 IN BUFFER
        CMP     #^D17,SUBNR             ;DOING LAST TWO SUBTESTS?
        BGT     LATOUR          ;IF NOT, LOAD AR WITH BUFFER AS IS
        BEQ     CLARET          ;IF DOING #17, SET EBUS BIT 18 FIRST
        $RORWD                  ;AND FOR #18, SET BOTH BITS 18 & 19

CLARET: $RORWD                  ;SLIDE EBUS BITS DOWN

LATOUR: STUFF                   ;LOAD THE AR FROM THE BUFFER

        MOVB    (R4)+,R0        ;GET NEXT # VAALUE
        BIC     #177400,R0      ;NO SIGN EXTENSION, PLEASE.
        $NUM                    ;WRITE IT TO BUFFER
        $XBUF                   ;EXECUTE BUFFER
        CTLMCR                  ;COMPARE
        CMP     #^D18,SUBNR             ;ALL DONE?
        BGT     MEDOC                   ;IF NO, LOOP.
        JMP     NORMAL          ;IF YES, EXIT


;SEQ295

;SOME #'S TO TRY:

MOSEL:  .BYTE   227             ;SUBTEST #13:  NO LOADS
        .BYTE   26              ;14: PREV CONTEXT BUT NOT WSX
        .BYTE   225             ;15:  JUST AC BLOCKS
        .BYTE   220             ;16:  NO LOADS
        .BYTE   223             ;17:  LOAD AC BLOCKS
        .BYTE   223             ;18: LOAD BOTH

;MCOMP'S # TABLE:

ROSE:   .BYTE   2               ;SUBTEST #1
        .BYTE   2               ;2
        .BYTE   2               ;3
        .BYTE   1               ;4
        .BYTE   1               ;5
        .BYTE   1               ;6
        .BYTE 1          ;7
        .BYTE   1               ;8
        .BYTE   1               ;9
        .BYTE   1               ;10
        .BYTE   1               ;11
        .BYTE   1               ;12
        .BYTE   0               ;13
        .BYTE   1               ;14
        .BYTE   4               ;15
        .BYTE   0               ;16
        .BYTE   4               ;17
        .BYTE   3               ;18


;SEQ296

;MCOMP'S BYTE TABLE:

SHERRY: .BYTE   1               
        .BYTE   10              ;SUBTEST #1:  "APR CURRENT BLOCK 4"
        .BYTE   2
        .BYTE   2               ;"APR FM BLOCK 4"

        .BYTE    1
        .BYTE   4               ;SUBTEST #2:  "APR CURRENT BLOCK 2"
        .BYTE   2
        .BYTE   1               ;"APR FM BLOCK 2"
        .BYTE   1
        .BYTE   2
        .BYTE   12
        .BYTE   204             ;"APR FM BLOCK 1"
        .BYTE   1
        .BYTE   1               ;SUBTEST 34:  "APR PREV BLOCK 4"

        .BYTE   11
        .BYTE   200             ;SUBTEST #5:  "APR PREV BLOCK 2"

        .BYTE   11
        .BYTE   100             ;SUBTEST #6:  "APR PREV BLOCK 1"

        .BYTE   11
        .BYTE   40              ;SUBTEST #7:  "APR CWSX"
        .BYTE   11
        .BYTE   20              ;SUBTEST #8:  "APR PREV SEC 13"
        .BYTE   11
        .BYTE   10              ;SUBTEST #9:  "APR PREV SEC 14"

        .BYTE   11
        .BYTE   4               ;SUBTEST #10:  "APR PREV SEC 15"

        .BYTE   11
        .BYTE   2               ;SUBTEST #11:  "APR PREV SEC 16"

        .BYTE   11
        .BYTE   1               ;SUBTEST #12:  "APR PREV SEC 17"

        .BYTE   11
        .BYTE   37              ;SUBTEST #14:  "APR PREV SEC 13-17"


;SEQ297

        .BYTE   1
        .BYTE   17              ;SUBTEST #15:  "APR CURRENT CLOCK 4-1" & PB4
        .BYTE   2
        .BYTE   3               ;"APR FM BLOCK 4 7 2"
        .BYTE   11
        .BYTE   300             ;"APR PREV BLOCK 2 & 1"
        .BYTE   12
        .BYTE   204             ;"APR FM BLOCK 1"

        .BYTE   1
        .BYTE   7               ;SUBTEST #17:  CB 2 & 1, PB4
 
        .BYTE   2
        .BYTE   1               ;FM B 2
        .BYTE   11
        .BYTE   300             ;PB 2 & 1
        .BYTE   12
        .BYTE   204             ;FM B 1

        .BYTE   1
        .BYTE   3               ;SUBTEST #18:  CB1 & PB4
        .BYTE   11
        .BYTE   377             ;PB2 & 1, CWSX, PS13-17
        .BYTE   12
        .BYTE   204             ;FM B 1

        .EVEN


;SEQ298

.SBTTL TEST 28 (EAPR4):  FAST MEMORY ADDRESS MIXER AND AC+1,2&3 LOGIC

.REM    %
        THIS TEST CHECKS THE LOGIC WHICH ADDS 1,2 OR 3 TO THE AC# AND THE FAST
MEMORY ADDRESS MIXER ON APR4.  THE MIXER INPUTS FROM ARZ 14-17 AND
VMA 32-35 ARE TESTED LATER AFTER THE DATA PATHS AND VMA HAVE BEEN CHECKED.
%

EAPR4:  MOV     #PARIS,R1               ;LOAD PTR TO STIMULUS TABLE.
        MOV     #BERN,R2                ;LOAD PTR TO MCOMP''S # T ABLE.
        MOV     #OSLO,R3               ;LOAD PTR TO MCOMP'S BYTE TABLE.

;BEGIN MAIN LOOP BY LOADING THE APPROPRIATE AC#.

LONDON: INSYNC                  ;NEW SUBTEST.
        CMP     SUBNR,#^D14     ;THERE ARE 145 OF THEM.
        BLE     ROME            ;DONE ALL?

        JMP     NORMAL          ;YES, RETURN TO EXEC,.

ROME:   CLEAR           ;NOT DONE, CLEAR THE MACHINE.
        MOVB    (R1),R0 ;GET NEXT STIMULUS BYTE.
        ASR     R0              ;RIGHT JUSTIFY THE
        ASR     R0              ;FOUR AC# FIELD
        ASR     R0              ;BITS
        ACSET                   ;WRITE & CHECK AC # FIELD

;NOW SET UP FAST MEMORY ADDRESS SELECT CRAM BITS.

LISBON: MOVB    (R1)+,R0        ;GET STIMULUS BYTE AGAIN.
        $FM                     ;WRITE FM SEL BITS INTO BUFFER


;SEQ299

;NOW SET UP MAGIC # FIELD FOR THOSE SUBTESTS REQUIRING NON-ZERO # FIELD.

VADUZ:  CLR     R0              ;START WITH A CLEAN SLATE.
        CMP     SUBNR,#4         ;ONLY 1ST 4 SUBTESTS GET 3'S.
        BGT     MADRID          ;REST GO AROUND.
        INC     R0              ;SET LSB 9CRAM #08) FOR 1-4.
        CMP     SUBNR,#3
        BLT     MADRID          ;LEAVE JKUST LSB SET FOR 1 AND 2.
        BEQ     BONN            ;SKIP OVER THE NEXT FOR 3.
        INC     R0              ;SUBTEST 4 NEEDS AN EXTRA POKEW.
BONN:   ADD     #15,R0          ;SET CRAM #05,6&7 FOR SUBTEST 3, #05-08 FOR 4.
        
MADRID: $NUM                    ;WRITE # FIELD IN MICROWORD BUFFER
DUBLIN: $MWORD          ;WRITE BJUFFER TO COMMAND REGISTER

;CHECK THE RESULT.
        CTLMCR          ;DO MODIFY, COMPARE & RESTORE
        DEC     R2              ;BACK UP MCOMP'S  # PTR
        BR      LONDON          ;DO MORE, IF NO ERRORS.

;STIMULUS TABLE.  BYTES LOOK LIKE THIS:
;BIT 7  NOT USED

;    6  AC09
;      5  AC10

;     4  AC11
;     3  AC12
;     2  CRAM FM ADR SEL 4
;     1  CRAM FM ADR SEL 1
;     0  CRAM FM ADR SEL 1

PARIS:  .BYTE   155             ;SUBTEST #1:  AC=15, SEL 4 & 1, #=1.
        .BYTE   6               ;2:  AC=0, SEL 4 & 2, #=1.
        .BYTE   76              ;3:  AC=7, SEL 4 & 2, #=16.
        .BYTE   7               ;4:  AC=0, ALL SELS, #=17.
        .BYTE   21              ;5:  AC=2, SEL 1.
        .BYTE   114             ;6:  AC=11, SEL 4.
        .BYTE   145             ;7:  AC=14, SEL 4 & 1./
        .BYTE   24              ;8:  AC=2, SEL 4.
        .BYTE   71              ;9:  AC=7:, SEL 1.
        .BYTE   170             ;10:  AC=17, NO SELS.
        .BYTE   31              ;11:  AC=3, SEL 1.
        .BYTE   61              ;12:  AC=6, SEL 1.
        .BYTE   64              ;13:  AC=6, SEL 4.
        .BYTE   7               ;14:  AC=0, SEL 7


;SEQ300


;MCOMP'S TABLES:


BERN:   .BYTE   1               ;ONE CHANGES FOR ALL SUBTESTS

OSLO:   .BYTE   12              
        .BYTE   4               ;SUBTEST #1:  F02 EN, FM ADR = 0
        .BYTE   12
        .BYTE   4               ;SUBTEST #2:  F02 EN, FM ADR = 0

        .BYTE   12
        .BYTE   74              ;SUBTEST #3:  F02, EN, FM ADR = 7

        .BYTE   12
        .BYTE   174             ;SUBTEST #4:  F02 EN, FM ADR = 17

        .BYTE   12
        .BYTE   30              ;SUBTEST #5:  FM ADR = 3

        .BYTE   12
        .BYTE   134             ;SUBTEST #6:  F02 EN, FM ADR = 13

        .BYTE   12
        .BYTE   170             ;SUBTEST #7:  FM ADR = 17

        .BYTE   12
        .BYTE   40              ;SUBTEST #8:  FM ADR = 4

        .BYTE   12
        .BYTE   104             ;SUBTEST #9:  F-02 EN, FM ADR = 10

        .BYTE   12
        .BYTE   174             ;SUBTEST #10:  F02 EN, FM ADR = 17

        .BYTE   12
        .BYTE   40              ;SUBTEST #11:  FM ADR = 4

        .BYTE   12
        .BYTE   74              ;SUBTEST #12:  F02 EN, FM ADR = 7

        .BYTE   12
        .BYTE   104             ;SUBTEST #13:  F02 EN, FM ADR = 10

        .BYTE   12
        .BYTE   4               ;SUBTEST #14:  F02 EN

        .EVEN


;SEQ301

.SBTTL TEST 29 (EMCL1)/EFLAG1:  AD FUNCITON LOGIC & VMA HELD FLOPS

.REM    %
THIS TEST USES "MEM/AD FUNC" AND AD BITS 0-12 TO INDEPENDENTLY SET EACH
OF THE PRICIPAL FLOPS ON THE MCL BOARD.  THESE FLOPS ARE USED, IN TURN TO
TEST VMA HELD REGISTER AND THE VMA HELD/PC FLAGS MUX.  ALSO, THE PC

FLAGS ARE SET AND CHECKED USING 'SCD LOAD FLAGS" AND AR BITS 0-12 TO
PROVIDE INTERFERENCE PATTERNS FOR TESTING THE VMA HELD/PC FLAGS MUX.
%
;INITIALIZE:
EMCL1: MOV     #COD,R2         ;R2 POINTS TO MCOMP'S # TABLE.
        MOV     #BASS,R3                ;R3 POINTS TO MCOMP'S VALUE TABLE.
        MOV     #EWORD1,R4      ;R4 POINTS TO 1ST 36-BIT BUFFER.

        INCB    (R4)            ;SET BIT 35 IN BUFFER
        $COMWD                  ;PUT COMPLIMENT IN 2ND 36-BIT BUFFER.

;CHANGE SOME EXPECTED DATA BYTES TO SAVE MCOMP WORDS:

        $MEMRQ          ;EXPECT MEM REQ SIGNALS
        MOVB    #44,CTLDAT+15   ;"CON CACHE LOAD EN" & "CON TRAP EN"
        MOVB    #260,CTLDAT+41  ;"SPEC/SP MEM CYCLE" TRUE

;MASK OFF MBOX GARBAGE
        BISB    #10,BIFF+4      ;NO MORE PUBLIC PAGE


;SEQ302

;START OF MAIN LOOP:


TROUT:  INSYNC          ;NEW SUBTEST - #1+5N (N=0 TO 12).
        CLEAR           ;FRESH START.

;BRING UP MCL FLOPS, ONE AT A TIME, USING AD FUNCTION & AD BITS 0-12.
;       ALSO DO A CONO PAG WITH EBUS BITS 19 & 22 SET.  THIS WILL CAUSE

;       "CON CAHCHE EN" & "CON TRAP EN" WHICH, IN TURN, CAUSE "MCL EBOX

;       "CACHE" AND "MCL EBOX MAY BE PAGED" TO BE NORMALLY "0" DESPITE
;       THE FACT THAT THEY ARE LOW TRUE SIGNALS.  THEY ARE EASIER TO
;       TEST THIS WAY.


        $RORWD                  ;NEXT AD BIT=SELECT NEXT FLOP TO SET.
        $RORWD  EWORD2          ;2ND BUFFER IS COMPLIMENT OF 1ST.

;SLIP IN EBUS BITS 19 & 22.

        MOV     #20000, (R4)+
        INCB    (R4)

        STUFF                   ;WRITE 1ST BUFFER AR.

;DO THE CONO PAG FIRST:

        $COND   20              ;"COND/DIAG FUNC"
        $NUM    16              ;# FOR CONO PAG
        $MWORD                  ;TO THE CR WITH IT

        $CLRMI                  ;LEAVE BUFFER CLEAN
        DECB    (R4)            ;AND THE 36-BIT BUFFER TOO
        CLR     -(R4)


;SEQ303

        $MEM    10              ;":MEM/AD FUNC? (GIVES "REG EN") TO BUFFER
        $DISP   26              ;AND "SPEC/SP MEM CYCLE" (GIVES "LOAD VMA CONTEXT")>
        $MWORD                  ;WRITE BUFFER TO CR.
        $CLRMI                  ;CLEAR THE FLOP ENABLES TO SEE IF DATA HOLDS.
        $COND   37      ;"COND/LOAD VMA HELD" TO BUFFER.
        $MWORD                  ;EXECUTE CR TO SET FFLOP, ENABLE TO CR.

;TRANSFER MCL FLOP DATA TO VMA HELD FLOPS & PREPARE TO SET ALL PC FLAGS BUT THE ONE
;WHICH IS CONTROLLED BY TEH AR BIT CURRENTLY SELECTED.  THUS AT THE "VMA HELD OR PC
;MUX'S", THE VMA HELD REGISTER HAS ONE BIT SET WHERE THE CORRESPONDING
;FLAG IS ZERO, AND ZEROES WHERE REST OF FLAGS AE SET.

        DFWRTT          ;WRITE 2ND BUFFER TO AR.
        .WORD   EWORD2
        .WORD   LDAR

        $COND   17              ;CLEAR "LOAD VMA HELD" & SET "COND/SEL VMA"
        $DISP   24              ;SRET 'SPEC/FLAG CTL" AND
        $NUM    20              ;CR #04 (FOR "SCD LOAD FLAGS") TO BUFFER
        $MWORD                  ;EXECUTE TO XFR DATA TO VMA HELD FLOPS.

;NOW CLOCK TO SET PC FLAGS AND LOA CR TO 1) CLEAR SELECTED MCL FLOP TO SEE
;IF VMA HELD FLOP HOLDS AND 2) CLEAR ENABLE TO FLAG FLOPS TO MAKE SURE THEY
;CAN HOLD DATA READ THE SELECTED 1ST BANK MCL FLOP & CORRESPONDING VMA HELD OR PC, FLOP


        $MEM    10              ;RESTORE "MEM/AD FUNC" TO BUFFER.M      $DISP   26  ;DROP "LOAD FLAGS"; SET "LOAD VMA CONTEXT"
        $DISP   26              ;DROP "LOAD FLAGS", SET "LOAD VMA CONTEXT"
        $NUM     0               ;NO #'S.
        $MWORD                  ;EXECUTE TO SET FLAGS & BRING UP ENABLES.

;SEQ304

;CHANGE MCOMP BYTES:

        MOVB    #134,CTLDAT+16  ;"-CON EN 0-7" F & "-CON/SEL VMA" T
        MOV     #CTLDAT+26,R0
        MOVB    #3,(R0)+        ;"MCL VMA_AD"
        INC     R0
        CLRB    (R0)+                   ;"-MCL LOAD VMA CONTEXT"
        MOVB    #4,(R0)+                ;"MCL VMA SEL 2"
        MOVB    #24,(R0)                ;MCL VMA SEL 1"
        CTLMCR                  ;REWAD CONTROL LOGIC.
        PUSH    <R2,R3>         ;SAVE MCOMP PTRS.

        INSYNC                  ;NEW SUBTEST - #2+5N
        FLGMCR                  ;READ FLAGS.
        POP     <R3,R2>         ;RESET MCOMP PTR TO USE AGAIN.

;CLOCK TO CLEAR FIRST RANK FLOP & SEE THAT VMA HELD & FLAG FLOPS HOLD:

        INSYNC                  ;NEW SUBTEST - 3+5N

        DFWRTT                  ;CLEAR AR.
        .WORD   ZERO
        .WORD   LDAR

        $MWORD                  ;CLOCK.


;SEQ305

;CHANGE MCOMP BYTES:
        MOV     #CTLDAT+26,R0   
        MOVB    #13,(R0)+       ;"VMA-AD" & " PAGE TEST PRIVATE"
        INC     R0
        MOVB    #20,(R0)+       ;"USER" & ";LOAD VMA CONTEXT"
        MOVB    #24,(R0)+       ;"PUBLIC" * "VMAX SEL 2"
        MOVB    #24,(R0)        ;"MCL VMA SEL 1"

        FLGMCR                  ;READ FLAGS.


        INSYNC                  ;NEW SUBTEST - #4+5N
        CTLMCR                  ;AND CONTROL LOGIC.

;NOW SWITCH MUX AND READ FLAGS THROUGH MUX.
        
        INSYNC                  ;NEW SUBTEST - #5+5N
        $COND   0
        $MWORD                  ;CHANGE CR

;CHANGE MCOMP BYTE:

        MOVB    #74,CTLDAT+16   ;"COND EN 0-7" T & "COND/SEL VMA" F
        CTLMCR                  ;READ CONTROL LOGIC

        TSTB    EWORD1+2        ;DID WE JUST DO BIT 12?
        BEQ     TROUT           ;NOPE, DO NEXT.
        JMP     NORMAL          ;YUP, ALL DOEN.


;SEQ306

;HERE IS MCOMP'S NUMBER OF BYTES TO CHANGE TABLE:

COD:    .BYTE   0               ;SUBTEST #1:  NO CHANGES IN CONTROL LOGIC
        .BYTE   3               ;SUBTEST #2&3:  3 CHANGES IN FLA LOGIC
        .BYTE   0               ;4-MCL
        .BYTE   2               ;5-MCL

        .BYTE   3               ;6-MCL
        .BYTE   1               ;7&8-FLG
        .BYTE   1               ;9-MCL
        .BYTE   2               ;10-MCL

        .BYTE   3               ;11-MCL
        .BYTE   1               ;12&13-FLG
        .BYTE   1               ;14-MCL
        .BYTE   2               ;15-MCL

        .BYTE   2               ;SUBTEST #16: MCL
        .BYTE   1               ;SUBTEST #17&18: FLG
        .BYTE   1               ;19-MCL
        .BYTE   2               ;20-MCL

        .BYTE   3               ;21-MCL
        .BYTE   1               ;22&23-FLG
        .BYTE   1               ;24-MCL
        .BYTE   2               ;25-MCL

        .BYTE   2               ;26-MCL
        .BYTE   2               ;27&28-FLG
        .BYTE   2               ;29-MCL
        .BYTE   3               ;30-MCL

        .BYTE   3               ;31-MCL
        .BYTE   1               ;32&33-FLG
        .BYTE   1               ;34-MCL
        .BYTE   2               ;35-MCL


;SEQ307

        .BYTE   2               ;36-MCL
        .BYTE   1               ;37&38-FLG
        .BYTE   3               ;39-MCL
        .BYTE   4               ;40-MCL

        .BYTE   2               ;41-MCL
        .BYTE   1               ;42&43 -FLG
        .BYTE   1               ;44-MCL
        .BYTE   2               ;45-MCL

        .BYTE   6               ;46-MCL
        .BYTE   1               ;47&48-FLG
        .BYTE   2               ;49-MCL
        .BYTE   2               ;50-MCL

        .BYTE   3               ;51-MCL
        .BYTE   1               ;52&53-FLG
        .BYTE   1               ;54-MCL
        .BYTE   2               ;55-MCL

        .BYTE   2               ;56-MCL
        .BYTE   1               ;57&58-FLG
        .BYTE   1               ;59-MCL
        .BYTE   2               ;60-MCL

        .BYTE   3               ;61-MCL
        .BYTE   1               ;62&63-FLG
        .BYTE   1               ;64-MCL
        .BYTE   2               ;65-MCL


;SEQ308

;HERE IS MCOMP'S VALUE TABLE:

BASS:   .BYTE   1               
        .BYTE   170             ;SUBTESTS #2&3: "SCD OV" (CLEAR)
        .BYTE   2
        .BYTE   170             ;"VMA HELD OR PC00" (CLEAR)
        .BYTE   3               
        .BYTE   0               ;"SCD PCP" (CLEAR)

        .BYTE   24
        .BYTE   77              ;SUBTEST #5:  ALL VMA HELD OR PC
        .BYTE   25
        .BYTE   77
        
        .BYTE   24
        .BYTE   40              ;SUBTEST #6:  "VMA HELD OR PC01"
        .BYTE   26
        .BYTE   43              ;"MCL VMA READ"&"MCL VMA_AD"
        .BYTE   31
        .BYTE   44              ;"MCL AR LOAD"&"MCL VMAX SEL 2"

        .BYTE   1
        .BYTE   270             ;SUBTESTS #7&8: "SCD CRY0" (CLEAR)

        .BYTE   24
        .BYTE   40              ;SUBTEST #9:  "VMA HELD OR PC01"

        .BYTE   24
        .BYTE   37              ;SUBTEST #10:  ALL VMA HELD SAVE 01
        .BYTE   25
        .BYTE   77

        .BYTE   24
        .BYTE   20              ;SUBTEST #11:  "VMA HELD OR PC02"
        .BYTE   26
        .BYTE   43              ;"MCL VMA READ"&"MCL VMA_AD"
        .BYTE   32
        .BYTE   64              ;"MCL LOAD ARX"

        .BYTE   1
        .BYTE   330             ;SUBTESTS #12&13:  "SCD CRY1" (CLEAR)

        .BYTE   24
        .BYTE   20              ;SUBTEST #14:  "VMA HELD OR PC02"

        .BYTE   24
        .BYTE   57              ;SUBTEST #15:  ALL VMA HELD SAVE 02
        .BYTE   25
        .BYTE   77


;SEQ309


        

        .BYTE   24
        .BYTE   10              ;SUBTEST #16:  "VMA HELD OR PC03"
        .BYTE   27
        .BYTE   40              ;"MCL VMA PAUSE"&"-MCL REQ EN"
        
        .BYTE   2
        .BYTE   270             ;SUBTESTS #17&18:  "SCD FOV" (CLEAR)

        .BYTE   24
        .BYTE   10              ;SUBTEST #19:  "VMA HELD OR PC03"

        .BYTE   24
        .BYTE   67              ;SUBTEST #20:  ALL VMA HELD SAVE 03
        .BYTE   25
        .BYTE   77

        .BYTE   24
        .BYTE   4               ;SUBTEST #21:  "VMA HELD OR PC04"
        .BYTE   30
        .BYTE   40              ;"MCL VMA WRITE"&"-MCL LOAD VMA CONTEXT"
        .BYTE   33
        .BYTE   27              ;"MCL STORE AR"

        .BYTE   0
        .BYTE   220             ;SUBTEST #22&23:  "SCD FPD"  (CLEAR)

        .BYTE   24
        .BYTE   4               ;SUBTEST #24:  "VMA HELD OR PC04"

        .BYTE   24
        .BYTE   73              ;SUBTEST #25:  ALL VMA HELD SAVE04
        .BYTE   25
        .BYTE   77

        .BYTE   24
        .BYTE   2               ;SUBTEST #26:  "VMA HELD OR PC05"
        .BYTE   30              
        .BYTE   20              ;"MCL VMA USER"&"-MCL LOAD VMA CONTEXT"
        
        .BYTE   4
        .BYTE   260             ;SUBTESTS #27&28:  "SCD USER&-USER EN" (CLEAR)
        .BYTE   6
        .BYTE   20              ;'SCD KERNEL OR USER IOT" (CLEAR)

        .BYTE   24
        .BYTE   2               ;SUBTEST #29:  "VMA HELD OR PC05"
        .BYTE   30
        .BYTE   0               ;"VMA USER" (FALSE)

        .BYTE   24
        .BYTE   75              ;SUBTEST #30:  ALL VMA HELD SAVE 05
        .BYTE   25
        .BYTE   77
        .BYTE   30


;SEQ310

        .BYTE   0               ;"VMA USER" (FALSE)


;SEQ311

        .BYTE   24
        .BYTE   1               ;SUBTEST #31:  "VMA HELD OR PC06"
        .BYTE   26
        .BYTE   13              ;"MCL PAGE TEST PRIVATE"
        .BYTE   31
        .BYTE   24              ;"MCL VMA PUBLIC"&"MCL VMAX SEL 2"

        .BYTE   6
        .BYTE   10              ;SUBTESTS #32&33:  "K OR UIOT","UIOT"&"-UIOT"&"-UIOT EN" (CLEAR

        .BYTE   24
        .BYTE   1               ;SUBTEST #34:  VMA HELD OR PC06

        .BYTE   24
        .BYTE   76              ;SUBTEST #35:  ALL VMA HELD SAVE 06
        .BYTE   25
        .BYTE   77

        .BYTE   25
        .BYTE   40              ;SUBTEST #36:  "VMA HELD OR PC07"
        .BYTE   32
        .BYTE   4               ;"-MCL VMA PREVIOUS"


        .BYTE   5               ;SUBTESTS #37&38: "PUBLIC"&"-PUB EN" (CL;EAR)
        .BYTE   200             ;AND "-PRIVATE INSTR"&"-PRI EN" (TRUE)

        .BYTE   25      
        .BYTE   40              ;SUBTEST #39:  "VMA HELD OR PC07"
        .BYTE    26
        .BYTE   3               ;"PAGE TEST PRIVATE"(CLR)
        .BYTE   31
        .BYTE   4               ;"VMA PUBLIC"(CLR)

        .BYTE   24
        .BYTE   77              ;SUBTEST #40:  ALL VMA HELD SAVE 07
        .BYTE   25
        .BYTE   37
        .BYTE   26
        .BYTE   3               ;"PAGE TEST PRIVATE"(CLR)
        .BYTE   31
        .BYTE   4               ;"VMA PUBLIC"(CLR)


;SEQ312

        .BYTE   25              
        .BYTE   20              ;SUBTEST #41:  "VMA HELD OR PC08"
        .BYTE   33
        .BYTE   47              ;"-MCL VMA EXTENDED"

        .BYTE   7               
        .BYTE   4               ;SUBTESTS #42&43:  "ADR BRK INH & PREVENT" (CLEAR)
        
        .BYTE   25
        .BYTE   20              ;SUBTEST #44:  "VMA HELD OR PC08"

        .BYTE   24
        .BYTE   77              ;SUBTEST #45:  ALL VMA HELD SAVE 08
        .BYTE   25
        .BYTE   57

        .BYTE   16
        .BYTE   130             ;SUBTEST #46:  "-CON LOAD IR"
        .BYTE   24
        .BYTE   20              ;"VMA HELD OR PC02"
        .BYTE   25
        .BYTE   10              ;"VMA HELD OR PC09"
        .BYTE   26
        .BYTE   43              ;"VMA READ"
        .BYTE   32
        .BYTE   64              ;"MCL LOAD ARX" (FROM FETCH)
        .BYTE   33
        .BYTE   73              ;"MCL VMA FETCH"&"MCL VMA PAGED FETCH"
        .BYTE   0               
        .BYTE   30              ;SUBTESTS #47&48: "SCD TRAP REQ 2" (CLEAR)

        .BYTE   24
        .BYTE   20              ;SUBTEST #49:  "VMA HELD OR PC02"
        .BYTE   25
        .BYTE   10              ;"VMA HELD OR PC09"

        .BYTE   24
        .BYTE   77              ;SUBTEST #50:  ALL VMA HELD SAVE 09
        .BYTE   25
        .BYTE   67


;SEQ313

        .BYTE   25
        .BYTE   4               ;SUBTEST #51:  "VMA HELD OR PC10"
        .BYTE   33
        .BYTE   66              ;"-MCL EBOX MAP"
        .BYTE   13
        .BYTE   106             ;"APR EBOX RED REG"

        .BYTE   0
        .BYTE   210             ;SUBTESTS #52&53:  "SCD TRAP REQ 1" (CLEAR)

        .BYTE   25
        .BYTE   4               ;SUBTEST #54:  "VMA HELD OR PC10"

        .BYTE   24
        .BYTE   77              ;SUBTEST #55:  ALL VMA HELD SAVE 10
        .BYTE   25
        .BYTE   73

        .BYTE   25
        .BYTE   2               ;SUBTEST #56:  "VMA HELD OR PC11"
        .BYTE   30
        .BYTE   1               ;"-MCL EBOX CACHE"&"-MCL LOAD VMA CONTEXT"

        .BYTE   2
        .BYTE   330             ;SUBTESTS #57&58: "SCD FXU" (CLEAR)

        .BYTE   25
        .BYTE   2               ;SUBTEST #59  "VMA HELD OR PC11"


        .BYTE   24
        .BYTE   77              ;SUBTEST #60:  ALL VMA HELD SAVE 11
        .BYTE   25
        .BYTE   75

        .BYTE   25
        .BYTE   1               ;SUBTEST #61:  "VMA HELD OR PC12"
        .BYTE   31
        .BYTE   5               ;"-MCL EBOX MAY BE PAGED "&"MCL VMAX SEL 2"
        .BYTE   32
        .BYTE   24              ;"MCL VMAX SEL 1"

        .BYTE   1
        .BYTE   360             ;SUBTESTS #62&63:  "SCD DIV CHK"

        .BYTE   25
        .BYTE   1               ;SUBTEST #64:  "VMA HELD OR PC12"

        .BYTE   24
        .BYTE   77              ;SUBTEST #65:  ALL VMA HELD SAVE 12
        .BYTE   25
        .BYTE   76


;SEQ314


.SBTTL TEST 30 (EMCL2):  MEMORY REQUEST ADDRESS MODE CONTROL LOGIC

.REM    %
THIS TEST CHECKS THE DECODING OF THE MICROCODE "MEM" FIELD (MCL1), THE MEMORY
REQUEST GENERATION LOGIC (MCL2&6), THE PXCT/VMAX EXTENSION LOGIC ON MCL4, THE
DRAM "A" FIELD DECODING ON MCL5.
IT USES 24 PATTERNS AND DEPENDS ON MANY PREVIOUSLY TESTED MACHINE FEATURES
(FOR EXAMPLE:  AC# & AC REFERENCE).
%

;INITIALIZE

EMCL2:  MOV     #EWORD1 ,R1     ;R1 POINTS TO 36-BIT DATA.
        MOV     #RED,R2         ;R2 POINTS TO MCOMP'S # TABLE
        MOV     #YELLOW,R3      ;R3 POINTS TO MCOMP'S BYTE TABLE
        MOV     #GREEN,R4               ;R4 POINTS TO THE STIMULUS TABLE

        $MEMRQ                  ;EXPECT MEMORY REQUEST SIGNALS

;START OF MAIN LOOP.

WHITE:  INSYNC                  ;NEW SUBTEST
        CMP     #^D25,SUBNR     ;SEE IF ALL 24 ARE DONE
        BGT     BLACK           ;IF NO, CONTINUE

        JMP     NORMAL          ;DONE...EXIT

;FIRST LOAD DRAM A&B FIELDS (DOES A MRESET):

BLACK:  MOVB    (R4),(R1)       ;PUT CODE BYTE DIRECTLY IN 36-BIT BUFFER.
        BIC     #177700,(R1)    ;OFF EXTRA BITS.
        SWAB    (R1)            ;PUT IN RIGHT BYTE
        MOV     (R1)+,(R1)+     ;SAME DATA TO EVEN AND ODD LOCS
        CLRB    (R1)            ;CLEAR COMMON J-FIELD BITS
        CMP     -(R1),-(R1)     ;RESET POINTER TO 1ST BYTE OF BUFFER
        CLR     R0              ;WRITE FRAM LOCS 0&1
        WDRAM                   ;EMT TO DO IT

;SEQ315

;NOW PREVENT OR ENABLE AC REFERENCES BY LOADING THE VMA 9DOES A CLEAR):

        MOV     R5,-(SP)        ;SAVE SUBTREST 3 ON STACK.
        MOVB    (R4)+,R5        ;GET THE 1ST CODE BYTE TO R5
        CLR     R0              ;DEFAULT WILL PREVENT AC REFS
        ASLB    R5              ;TEST LEFT MOST BIT
        BCC     BLUE            ;LEAVE R0 CLEARED IF BIT NOT SET.

        COM     R0              ;OTHERWISE, PUT 1'S IN IT TO GET AC REFS.

BLUE:   $ACREF                  ;LOAD VMA TO EXECUTE AC REF CONDITION


;SET CWSX BIT (FOR MODEL A CPU) IF REQURIED (IT IS CLEARED EACH
;SUBTEST BY THE 'CLEAR" IN "$ACREF"):

        ASLB    R5              ;TEST THE CWSX BIT
        BR      VIOLET          ;NEVER SET FOR MODEL B
        MOVB    #200,EWORD1+2   ;OTHERWISE, SET EBUS BIT 12 IN BUFFER
        STUFF                   ;AND WRITE IT TO THE AR.

        $NUM    226             ;BRING UP "LOAD PREVIOUS CONTEXT" IN
        $COND   20              ;BUFFER (#COND/DIAG FN AND #26).
        $XBUF0                  ;EXECUTE THE BUFFER TO SET CWSX


;SEQ316

;START LOADING ACCESS CONDITIN BY SETTING THE REQURIED AC#:
;(NOTE THAT THIS WILL STROBE DRAM LATCHES AND LEAVE $MICRO, EWORD1 & AR CLEARED)

VIOLET: MOVB    (R4),R0 ;GET NEXT CODE BYTE (WHICH HAS AC#)
        $ACSET                  ;(RIGHT JUSTIFIED IN IT) & WRITE AC#

;NOW SET # BITS FOR SXCT (MODEL A CPU) AND/OR PXCT:

        CLR     R0              ;BLEAR BOTH IS DEFAULT.
        MOVB    (R4)+,R5        ;FRESH COPY OF CODE BYTE TO R5
        ASLB    R5              ;TEST SXCT BIT
        BR      PURPLE          ;ALWAYS SKIP FOR MODEL B CPU

        BIS     #40,R0          ;SET CR#03 FOR SXCT IF IT IS

PURPLE: ASLB    R5              ;TEST PXCT BIT
        BCC     INDIGO          ;SKIP IF NOT SET

        BIS     #20,R0          ;SET CR#04 FOR PXCT IF IT IS

INDIGO: $NUM                    ;WRITE # FIELD FOR SXCT/PXCT
        $COND   15              ;BRING UP "COND/SPEC INSTR" TO LOAD
        $XBUF0                  ;EXECUTE BUFFER TO SET SXCT/PXCT CONDITION

;CLEAR THE CONDITIONS REGISTER AS A DEFAULT. (PINS 14,2,3 H, PIN 15 L)

        $COND   16              ;SET "COND/SR GETS #" TO LOAD REGISTER
        $XBUF0                  ;DO SO & LEAVE REGISTER CLEARED


;SEQ317

;START LOADING THE FINAL MICROWORD WITH "VMA SELECT" FIELD:

        CLR     R0              ;START WITH BOTH SELECTS=0
        ASLB    R5              ;TEST "VMA SEL 2" BIT
        BCC     BROWN           ;SKIP IF CLEAR

        INC     R0              ;OTHERWISE, SET "2" WEITH BIT IN R0
        INC     R0

BROWN:  ASLB    R5              ;TEST "VMA SEL 1" BIT
        BCC     MAUVE           ;SKIP IF CLEAR

        INC     R0              ;OTHERWISE, SET "1", WEIGHT BIT IN R0

MAUVE:  $VMA                    ;WRITE VAM FIELD TO BUFFER

;NEXT LOAD "SH-ARMM SEL FIELD" = 3:

        MOVB    (R4)+,R5        ;GET 3RD CODE BYTE
        ASR     R5              ;TEST NEXT BIT
        BCC     BIEGE           ;LEAVE FIELD ZERO IF NOT SET

        $SH     3               ;OTHERWISE SET TO 3 (SH-ARM SEL 1&2)

;NOW LOAD  "SH-ARMM SEL" FIELD = 1

BIEGE:  ASR     R5              ;TEST SH FIELD BIT
        BCC     GRAY            ;LEAVE FIELD ALONE IF BIT NOT SET

        $SH     1               ;OTHERWISE, SET "SH-ARMM SEL 1".


;SEQ318

;LOAD "DISP" FIELD:

GRAY:   ASR     R5              ;TEST FIRST DISP BIT
        BCC     OCHRE           ;SKIP IF CLEAR
        $DISP   26              ;SETY "SPEC/SP MEM CYCLE" IF SET

OCHRE:  ASR     R5              ;TEST SECOND DISP BIT
        BCC     COBALT          ;GO ON IF CLEAR
        $DISP   20              ;SET "SPEC/SEC HOLD" IF SET

;NOW LOAD "CONO FIELD:

COBALT: MOVB    PINK(R5),R0     ;GET THE VALUE FROM A DECODE TABLE
        $COND                   ;WTRITE IT TO BUFFER

;LOAD THE "MEM FIELD:

        MOVB    (R4),R0         ;GET 4TH CODE BYTE WHICH HAS MEM
        $MEM                    ;FIELD VALUE RIGHT JUSTIFIED IN IT

;FINALLY LOAD THE # FIELD, CLOCK & TEST:

        MOVB    (R4)+,R0        ;RECOPY CODE BYTE TO R0
        ASL     R0              ;SHIFT CR#00-03 BITS INTO PLACE
        BIC     #177037,R0      ;CLEAR OTHER BITS
        $NUM                    ;AND WRITE RESULT

        $XBUF                   ;EXECUTE BUFFER
        MOV     (SP)+,R5        ;RESTORE SUBTEST #
        CTLMCR                  ;AND COMPARE
        JMP     WHITE           ;IF NO ERRORS, LOOP BACK


;SEQ319

;HERE IS THE STIMULUS TABLE.  THE CODE BYTES HAVE THE FOLLOWING SIGNIFICANCE:


;BIT#   BYTE#1          BYTE#2          BYTE#3          BYTE#4

;0      0               AC12            SH-ARM SEL 1&2  MEM03
;1      DRAMB1          AC11            SH-ARM SEL 1    MEM02
        
;2      0               AC10            DISP CODE 1     MEM01
;3      DRAM A2         AC09            DISP CODE 0     MEM00
;4      DRAM A1         VMA SEL 1       COND CODE 2     CR#03
;5      DRAM A0         VMA SEL 2       COND CODE 1     CR#02
;6      CWSX (MODEL A)  PXCT            COND CODE 0     CR#01
;7      ACREF           SXCT (MODEL A)  0               CR#00

;FURTHERMORE, THE 'COND" AND "DISP" CODES ARE AS FOLLOWS:

;0      COND=0                  DISP=0
;1      COND=16 (COND/SR_#)     DISP=26 (SPEC/SP MEM CYCLE)
;2      COND=35 (COND/VMA DEC)  DISP=0
;3      COND=36 (COND/VMA INC)  DISP=0
;4      COND=14 (COND/LOAD IR)
;5      COND=10 (COND/FM WRITE)
;6      COND=0


;SEQ320

;STIMULUS TABLES:


GREEN:  .BYTE   202             ;SUBTEST#1:  DRAM A=0, B=2, ACREF
        .BYTE   311             ;VMA 0, AC#11, PXCT, SXCT (MODEL A)
        .BYTE   40              ;COND/VMA DEC
        .BYTE   144             ;MEM/AREAD, #=300

        .BYTE   360             ;SUBTEST#2:  DRAM A=6, B=0, CWSX (MODEL A), ACREF
        .BYTE   116             ;VMA 0, AC#16, PXCT
        .BYTE   20              ;COND/SR #
        .BYTE   255             ;MEM/RPW CYCLE, #=500


        .BYTE   62              ;SUBTEST#3:  DRAM A=6, B=2
        .BYTE   374             ;VMA 3, AC#14, PXCT, SXCT (MODEL A)
        .BYTE   166             ;SH-ARM SEL 1, SPEC/SP MEM CY
        .BYTE   365             ;MEM/B WRITE, #=740

        .BYTE   70              ;SUBTEST#4:  DRAM A=7, B=0
        .BYTE   147             ;VMA 2, AC#7, PXCT
        .BYTE   61              ;COND/VMA INC, SH-ARM SEL 1&2
        .BYTE   24              ;MEM/AREAD, #=40

        .BYTE   372             ;SUBTEST#5:  DRAM A=7, B-=2, CWSX (MODEL A), ACREF
        .BYTE 104                ;VMA 0, AC#4, PXCT
        .BYTE   121             ;COND/VMA DEC, SH-ARM SEL 1 & 2
        .BYTE   210             ;MEM/FA CALC. #=400


;SEQ321

        .BYTE   340             ;SUBTEST#6:  DRAM A=4, B=0, CWSX (MODEL A), ACREF
        .BYTE   175             ;VMA 3, AC#15, PXCT
        .BYTE   104             ;COND/LOAD IR, SPEC/SP MEM CY
        .BYTE   5               ;MEM/B WRITE

        .BYTE   212             ;SUBTEST#7:  DRAM A=1, B=2, ACREF
        .BYTE   44              ;VMA 2, AC#4
        .BYTE   141             ;SH-ARM SEL 1 & 2
        .BYTE   324             ;MEM/AREAD, #=640

        .BYTE   140             ;SUBTEST#8:  DRAM A=4, B=0, CWSX (MODEL A)
        .BYTE   163             ;VMA 3, AC#3, PXCT
        .BYTE   105             ;COND/LOAD IR, SPEC/SP MEM CY SH-ARM SEL 1 & 2
        .BYTE   67              ;MEM/REG FUNC, #=140

        .BYTE   222             ;SUBTEST#9:  DRAM A=B=2, ACREF
        .BYTE   34              ;VMA 1, AC#14
        .BYTE   2               ;SH-ARM SEL 1
        .BYTE   246             ;MEM/FETCH, #=500

        .BYTE   350             ;SUBTEST#10,DRAM A=5, B=0, CWSX (MODEL A) ACREF
        .BYTE   107             ;VMA 0, AC#7, PXCT
        .BYTE   140
        .BYTE   124             ;MEM/AREAD #=240

        .BYTE   50              ;SUBTEST#11:  DRAM A=5, B=0
        .BYTE   173             ;VMA 3, AC#13,PXCT
        .BYTE   21              ;COND/SR_#,SH-ARM SEL 1&2
        .BYTE   361             ;MEM/ARL IND, #=740

        .BYTE   202             ;SUBTEST#12:  DRAM A=0, B=2, ACREF
        .BYTE   220             ;VMA 1, AC#0, SXCT (MODEL A)
        .BYTE   61              ;COND/VMA INC, SH-ARM SEL 1&2
        .BYTE   77              ;MEM/UNCOND FETCH,#=10

        .BYTE   50              ;SUBTEST#13: DRAM A=5, B=0
        .BYTE   352             ;VMA 2, AC#12, PXCT, SXCT MODEL A)
        .BYTE   121             ;COND/FM WRITE, SH-ARM SEL 1&2
        .BYTE   31
        
        .BYTE   200             ;SUBTEST#14:  DRAM A=B=0,ACREF
        .BYTE   0               ;VMA 0, AC#0
        .BYTE   0
        .BYTE   16              ;MEM/WRITE


;SEQ322


        .BYTE   332             ;SUBTEST#15:  DRAM A=3, B=2, CWSX (MODEL A) ACREF
        .BYTE   251             ;VMA 2, AC#11,
        .BYTE   65              ;COND/VMA INC, SPEC/SP MEM CY,
        .BYTE   124             ;MEM/AREAD, #=240

        .BYTE   42              ;SUBTEST#16:  DRAM A=4, B=2
        .BYTE   360             ;VMA 3, AC#0, PXCT,SXCT (MODEL A)
        .BYTE   11              ;SH-ARM SEL 1 & 2
        .BYTE   144             ;MEM/AREAD, #=300

        .BYTE   140             ;SUBTEST#17:  DRAM A=4, B=0, CWSX (MODEL A)
        .BYTE   106             ;VMA 0, AC#6, PXCT
        .BYTE   102             ;COND/LOAD IR, SH-ARM SEL 1
        .BYTE   257             ;MEM/UNCOND FETCH, #=500

        .BYTE   0               ;SUBTEST#18:  DRAM A=B=0
        .BYTE   0               ;VMA 0, AC#0
        .BYTE   0
        .BYTE   307             ;MEM/REG FUNC, #=600

        .BYTE   0               ;DUBTEST#19:  DRAM A=B=0
        .BYTE   0               ;VMA 0, AC#0
        .BYTE   0
        .BYTE   11              ;MEM/EA CALC

        .BYTE   0               ;SUBTEST#20:  DRAM A=B=0
        .BYTE   0               ;VMA 09, AC#0
        .BYTE   0
        .BYTE   13              ;MEM/LOAD ARX

        .BYTE   0               ;SUBTEST#21:  DRAM A=B=0
        .BYTE   0               ;VMA 0, AC#0
        .BYTE   0
        .BYTE   12              ;MEM/LOAD AR

        .BYTE   32              ;SUBTEST#22:  DRAM A=3, B=2
        .BYTE   354             ;VMA 2, AC#14, PXCT, SXCT (MODEL A)
        .BYTE   101             ;COND/LOAD IR, SH-ARM SEL 1&2
        .BYTE   31              ;MEM/EA CALC, #=40

        .BYTE   0               ;SUBTEST#23:  DRAM A=B=0
        .BYTE   107             ;VMA 0, AC#7, PXCT
        .BYTE   100             ;COND/LOAD IR
        .BYTE   151             ;MEM/EA CALC, #=300

        .BYTE   100             ;SUBTEST#24:  DRAM A=B=0, CWSX (MODEL A)
        .BYTE   163             ;VMA 3, AC#3, PXCT
        .BYTE   20              ;COND/SR_#
        .BYTE   100             ;#=200


;SEQ323

;HERE IS THE "COND" FIELD DECODE TABLE:

PINK:   .BYTE   0               ;INDEX=0 MEANS COND=0
        .BYTE   16              ;1:  COND/SR #
        .BYTE   35              ;2:  COND/VMA DEC
        .BYTE   36              ;3:  COND/VMA INC
        .BYTE   14              ;4:  COND/LOAD IR
        .BYTE   10              ;5:  COND/FM WRITE
        .BYTE   0               ;6:  COND=0
        .BYTE   0               ;7:  COND 0

;HERE IS MCOMP'S # TABLE

RED:    .BYTE   15              ;SUBTEST#1
        .BYTE   10              ;2
        .BYTE   12              ;3
        .BYTE   12              ;4
        .BYTE   10              ;5
        .BYTE   15              ;6
        .BYTE   14
        .BYTE   15              ;9
        .BYTE   12              ;9
        .BYTE   10              ;10
        .BYTE   21              ;11
        .BYTE   13              ;12
        .BYTE   13              ;13
        .BYTE   6               ;14
        .BYTE   13              ;15
        .BYTE   12              ;16
        .BYTE   7               ;17
        .BYTE   4               ;18
        .BYTE   3               ;19
        .BYTE   4               ;20
        .BYTE 4          ;21
        .BYTE   11              ;22
        .BYTE   10              ;23
        .BYTE   14              ;24


;SEQ324


;HERE IS THE MCOMP BYTE TABLE:

YELLOW: .BYTE   12              
        .BYTE   114             ;SUBTEST #1:FM ADR 10 & 11
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   17
        .BYTE   113             ;-CON MEM CYCLE
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   26
        .BYTE   3               ;VMA_AD
        .BYTE   27              
        .BYTE   4               ;-REQ EN
        .BYTE   31
        .BYTE   13              ;MCL PAGE ADR, COND MCL 23 BIT EA
        .BYTE   32
        .BYTE   32              ;MCL PAGE ILL ENTRY, MCL 18 BIT EA
        .BYTE   33
        .BYTE   45              ;CYC REQ
        .BYTE   34
        .BYTE   120             ;-CTL AR 00-08 LOAD
        .BYTE   35
        .BYTE   120             ;-CTL AR 09-17 LOAD
        .BYTE   40
        .BYTE   130             ;CTL AR 00-11 CLR
        .BYTE   41
        .BYTE   70              ;CTL AR 12-17 CLR

        .BYTE   12
        .BYTE   164             ;SUBTEST #2:  FM ADR 10, 4 & 2
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   26
        .BYTE   45              ;VMA READ & XR PREVIOUS
        .BYTE   27
        .BYTE   40              ;VMA PAUSE & -PREV COND
        .BYTE   30
        .BYTE   43              ;VMA WRITE
        .BYTE   31
        .BYTE   41              ;LOAD AR & VXSEL2
        .BYTE   33
        .BYTE   47              ;MCL VMA EXTENDED


;SEQ325

        .BYTE   12
        .BYTE   140     ;SUBTEST#3:  FM ADR 10 & 4, F02 EN
        .BYTE   16
        .BYTE   70              ;-CON LOAD IR
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   47              ;VMA READ, XR PREV & VMA _ AD
        .BYTE   30
        .BYTE   45              ;VMA WRITE & -VMA EXT EN & -LOAD VMA CTX
        .BYTE   31
        .BYTE   5               ;VMAX SEL 2
        .BYTE   32              
        .BYTE   64              ;LOAD ARX
        .BYTE   33
        .BYTE   57              ;-STORE, -MCL VMA EXTENDED, VMA FETCH
        .BYTE   41
        .BYTE   260             ;SPEC/SP MEM CYCLE

        .BYTE   12
                
        .BYTE   74              ;SUBTEST #4:  FM ADR 4, 2 7 1
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   22              
        .BYTE   1               ;-VMA SE 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   43              ;VMA READ & VMA _ AD
        .BYTE   27
        .BYTE   45              ;VMA PAUSE, -PREV COND & PS TO ARMM
        .BYTE   30              
        .BYTE   41              ;VMA WRITE & -LOAD VMA CONTEXT
        .BYTE   31
        .BYTE   55              ;LOAD AR, PAGE ADR COND & VMAX SEL 2
        .BYTE   32
        .BYTE   14              ;-MCL VMA PREV, VMAX SEL 1 & P[AGE ILL ENTRY
        .BYTE   33
        .BYTE   47              ;-VMA EXT


;SEQ326

        .BYTE   7               
        .BYTE   40              ;SUBTEST #5:  -FM WRITE
        .BYTE   12
        .BYTE   40              ;F02 EN (FALSE) & FM ADR 4
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   20
        .BYTE   100             ;-FM WRITE PAR
        .BYTE   26
        .BYTE   3               ;VMA AD
        .BYTE   31
        .BYTE   5               ;VMAX SEL 2
        .BYTE   32              
        .BYTE   24              ;MCL VMAX SEL 1
        .BYTE   33      
        .BYTE   47              ;-VMA EXT

        .BYTE   12
        .BYTE   14              ;SDUBTEST #6:  FM ADR 1
        .BYTE   16
        .BYTE   170             ;-CON EN 00-07 & -LOAD IR
        .BYTE   17
        .BYTE   113             ;-MEM CYCLE
        .BYTE   20      
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   22
        .BYTE   5               ;-VMA SEL 2 & LOAD DRAM
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   7               ;XR PREV & VMA AD
        .BYTE   27
        .BYTE   24              ;-REQ EN
        .BYTE   30
        .BYTE   1               ;-LOAD VMA CONTEXT
        .BYTE   31
        .BYTE   15              ;VMAX SEL 2 & PAGE ADR COND
        .BYTE   32
        .BYTE   34              ;VMAX SEL 1 & PAGE ILL ENTRY
        .BYTE   33
        .BYTE   45              ;-VMA EXTENDED
        .BYTE   41
        .BYTE   260             ;SPEC/SP MEM CYCLE


;SEQ327

        .BYTE   12
        .BYTE   40              ;SUBTEST#7:  FM ADR & F02 EN
        .BYTE   16
        .BYTE   70              ;-LOAD IR
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
       
        .BYTE   41              ;VMA READ
        .BYTE   30
        .BYTE   1               ;-LOAD VMA CONTEXT
        .BYTE   32
        .BYTE   66              ;LOAD ARX, VMAX SEL 1 & 18 EA
        .BYTE   33
        .BYTE   77              ;VMA FETCH
        .BYTE   34
        .BYTE   120             ;-AR 0-8 LOAD (FROM 18 EA)
        .BYTE   35
        .BYTE   120             ;-AR 9-17 LOAD (FROM 18 EA)
        .BYTE   40              
        .BYTE   130             ;AR 0-11 CLR (FROM 18 A)
        .BYTE   41
        .BYTE   70              ;AR 12-17 CLR (FROM 18EA)

        .BYTE   12
        .BYTE   14              ;SUBTEST #8. FM ADR 1
        .BYTE   13
        .BYTE   102             ;-M/RF & -EBOX READ REG
        .BYTE   16
        .BYTE   170             ;-COND EN 00-07 & -LOAD IR
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   22
        .BYTE   5               ;-VMA SEL 2 & LOAD DRAM
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   3               ;VMA AD & ARMM12
        .BYTE   30
        .BYTE   5               ;-VMA EXT EN & -LOAD VMA CONTEXT
        .BYTE   31
        .BYTE   5               ;VMAX SEL 2
        .BYTE   32
        .BYTE   24              ;VMAX SEL 1
        .BYTE   33
        .BYTE   46              ;-EBOX MAP & -VMA EXT
        .BYTE   41
        .BYTE   260             ;SPEC/SP MEM CYCLE


;SEQ328

        .BYTE   12
        .BYTE   140             ;SUBTEST #9:  FM ADR 10 & 4, F02 EN (FALSE)
        .BYTE   16
        .BYTE   70              ;-LOAD IR
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   22
        .BYTE   40              ;-FM XFER
        .BYTE   26
        .BYTE   41              ;VMA READ
        .BYTE   32
        .BYTE   64              ;LOAD ARX
        .BYTE   33
        .BYTE   57              ;-VMA EXT & VMA FETCH
        .BYTE   36
        .BYTE   10              ;ARX LOAD
        .BYTE   40
        .BYTE   160             ;ARXLS2
        .BYTE   42
        .BYTE   40              ;ARXRS2

        .BYTE   12
        .BYTE   74              ;SUBTEST #10:  FM ADR 4,2 & 1
        .BYTE   26
        .BYTE   43              ;VMA READ,XRPREV & VMA AD
        .BYTE   31
        .BYTE   47              ;LOAD AR & VXSEL2 & 23 BIT EA
        .BYTE   33
        .BYTE   47              ;-VMA EXT
        .BYTE   34
        .BYTE   120             ;-AR 0-8 LOAD (FROM 18 EA)
        .BYTE   35
        .BYTE   120             ;-AR 9-17 LOAD (FROM 18 EA)
        .BYTE   40
        .BYTE   130             ;AR 0-11 CLR (FROM 18 EA)
        .BYTE   41
        .BYTE   60              ;AR 12-17 CLR (FROM 18 EA)


;SEQ329

        .BYTE   12
        .BYTE   130             ;SUBTREST #11:  F02 EN (F) & FM ADR 10, 2 & 1
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   17
        .BYTE   113             ;-MEM CYCLE
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   27              ;MEM/ARL IND, XR PREV, VMA AD
        .BYTE   27
        .BYTE   25              ;-REQ EN & VMA ADR ERR
        .BYTE   30
        .BYTE   1               ;-LOAD VMA CONTEXT
        .BYTE   31
        .BYTE   15              ;VXSEL 2 & PAGE ADR COND
        .BYTE   32
        .BYTE   34              ;VXSEL 1 & PAGE ILL ENTRY
        .BYTE   33
        .BYTE   45              ;CYC REQ & -VMA EXT
        .BYTE   34
        .BYTE   120             ;-AR 0-8 LOAD
        .BYTE   36
        .BYTE   10              ;ARX LOAD
        .BYTE   40
        .BYTE   100             ;MQ SEL 2
        .BYTE   41
        .BYTE   40              ;MQ SEL 1
        .BYTE   43
        .BYTE   260             ;-SPEC CALL


;SEQ330

        .BYTE   16
        .BYTE   170             ;SUBTEST #12:  -COND EN 00-07 & -LOAD IR
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   22
        .BYTE   0               ;-VMA SEL 2 & -FM XFER
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   41              ;VMA READ & VMA AD
        .BYTE   30
        .BYTE   1               ;-LOAD VMA CONTEXT
        .BYTE   32
        .BYTE   64              ;LOAD ARX & VXSEL1
        .BYTE   33
        .BYTE   77              ;VMA FETCH
        .BYTE   36
        .BYTE   10              ;CTL ARX LOAD
        .BYTE   40
        .BYTE   160             ;ARXLS2
        .BYTE   42
        .BYTE   40              ;ARXRS2

        .BYTE   7
        .BYTE   40              ;SUBTEST #13:  -FM WRITE
        .BYTE   12
        .BYTE   120             ;F02 EN (FALSE) & FM ADR 10 & 2
        .BYTE   16              ;
        .BYTE   174             ;-COND EN 00-07
        .BYTE   20
        .BYTE   100             ;-CON FM WRITE PAR
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   6               ;XR SHORT (FALSE), XR PREV & VMA AD
        .BYTE   30
        .BYTE   41              ;-LOAD VMA CONTEXT & VMA WRITE
        .BYTE   31
        .BYTE   5               ;VXSEL2
        .BYTE   32
        .BYTE   24              ;VXSEL1
        .BYTE   33
        .BYTE   7               ;-STORE AR & -VMA EXTENDED


;SEQ331

        .BYTE   7               
        .BYTE   40              ;SUBTEST#14: -0FM WRITE
        .BYTE   20              
        .BYTE   100             ;-CON FM WRITE PAR
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   22
        .BYTE   40              ;-FM MIXER
        .BYTE   30
        .BYTE   43              ;VMA WRITE
        .BYTE   33
        .BYTE   7               ;-STORE & -VMA EXT

        .BYTE   12
        .BYTE   114             ;SUBTEST #15:  FM ADR 10 & 1
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   22
        .BYTE  1
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   2               ;VMA_AD & XR SHORT (FALSE)
        .BYTE   27
        .BYTE   44              ;VMA PAUSE
        .BYTE   30
        .BYTE   65              ;VMA WQRITE, -VXE & -LVCTX & VMA USER
        .BYTE   31
        .BYTE   15              ;VXSEL2 & PAGE ADR COND
        .BYTE   32
        .BYTE   34              ;PAGE ILL ENTRY & VXSEL1
        .BYTE   33
        .BYTE   47              ;-VMA EXTENDED
        .BYTE   41
        .BYTE   260             ;SPEC/SP MEM CYCLE


;SEQ332

        .BYTE   22
        .BYTE   1               ;SUBTEST #16: -VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   42              ;VMA READ, VMA_AD & XR SHORT (FALSE)
        .BYTE   30
        .BYTE   1               ;-LOAD VMA CONTEXT
                
        .BYTE   31
        .BYTE   45              ;LOAD AR & VXSEL2
        .BYTE   32              
        .BYTE   24              ;VXSEL1
        .BYTE   33
        .BYTE   47              ;-VMA EXTENDED
        .BYTE   36
        .BYTE 200                ;SPEC/GEN CRY 18
        .BYTE   37
        .BYTE   300             ;SPEC/STACK UPDATE
        .BYTE   43
        .BYTE   70              ;-INH CRY 18

        .BYTE   16
        .BYTE   170             ;SUBTEST#17: -COND EN 00-07 & -LOAD IR
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   22
        .BYTE   45              ;LOAD DRAM
        .BYTE   26
        .BYTE   41              ;VMAREAD
        .BYTE   32
        .BYTE   64              ;LOAD ARX
        .BYTE   33
        .BYTE   57              ;-VMA EXT, VMA FETCH & CYC REQ

        .BYTE   13
        .BYTE   101             ;SUBTEST#18:  -M/RF & -EBOX LOAD REG
        .BYTE   21
        .BYTE   44              ;-MBOX WAIT
        .BYTE   31
        .BYTE   5               ;VXSEL2
        .BYTE   32
        .BYTE   25              ;REG FN


;SEQ333

        .BYTE   26
        .BYTE   2               ;SUBTEST #19:  VMA_AD & XR SHORT (FALSE)
        .BYTE   27
        .BYTE   0               ;SHORT STACK (FALSE)

        .BYTE   33
        .BYTE   47              ;CYC REQ (FALSE) & -VMA EXT

        .BYTE   21
        .BYTE   44              ;SUBTEST #20:  -MBOX WAIT
        .BYTE   26
        .BYTE   40              ;VMA READ
        .BYTE    32
        .BYTE   60              ;LOAD ARX
        .BYTE   33
        .BYTE   47              ;-VMA EXT

        .BYTE   21
        .BYTE   44              ;SUBTEST#21: -MBOX WAIT
        .BYTE   26
        .BYTE   40              ;VMA READ
        .BYTE   31              
        .BYTE   41              ;LOAD ADR
        .BYTE   33
        .BYTE   47              ;-VMA EXT

        .BYTE   16
        .BYTE   170             ;SUBTEST #22:  -COND EN 00-07 & -LOAD IR
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   22
        .BYTE   5               ;-VMA SEL2 & LOAD DRAM
        .BYTE  23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   6               ;XR SHORT (FALSE), XR PREV & VMA AD
        .BYTE   30
        .BYTE   41              ;-LOAD VMA CONTEXT & VMA WRITE
        .BYTE   31
        .BYTE   5               ;VXSEL2
        .BYTE   32
        .BYTE   24              ;VXSEL1
        .BYTE   33
        .BYTE   7               ;VMA FETCH


;SEQ334

        .BYTE   12
        .BYTE   14              ;SUBTEST#23;  FM ADR 1
        .BYTE   16
        .BYTE   170             ;-COND EN 00-07 & -LOAD IR
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   22      
        .BYTE   45      ;LOAD DRAM
        .BYTE   26
        .BYTE   46              ;VMA READ, VMA AD, XR PREV & XR SHORT
        .BYTE   27
        .BYTE   40              ;VMA PAUSE & SHORT STACK (FALSE)
        .BYTE   32
        .BYTE   60              ;LOAD ARX &VXSEL1
        .BYTE   33
        .BYTE   47

        .BYTE   12
        .BYTE   30              ;SUBTEST #24:  FM ADR 2&1, F02EN (FALSE)
        .BYTE   16
        .BYTE   174             ;-COND EN 00-07
        .BYTE   17
        .BYTE   113             ;-MEM CYCLE
        .BYTE   20
        .BYTE   105             ;LOAD ACCESS COND
        .BYTE   22
        .BYTE   1               ;-VMA SEL 2
        .BYTE   23
        .BYTE   11              ;-VMA SEL 1
        .BYTE   26
        .BYTE   2               ;VMA AD
        .BYTE   27              
        .BYTE   24              ;VMA ADR ERR & SHORT STACK (FALSE)
        .BYTE   30
        .BYTE   1               ;-LVCTX
        .BYTE   31
        .BYTE   15              ;VXSEL2 & PAGE ADR COND
        .BYTE   32
        .BYTE   34              ;VXSEL1 & PAGE ILL ENTRY
        .BYTE   33
        .BYTE   45              ;-VMA EXT

        .EVEN


;SEQ335

.SBTTL TEST 31 (EMCL3):  VMA CONTEXT  STORAGE LOGIC

.REM    %
        
THIS TEST TESTS THE FLOPS SET WITH "LOAD VMA CONTEXT" ON MCL2, 3 & 6 AND
THE USER EN & PUBLIC EN LOGIC ON MCL2
%
;INITIALIZE:
EMCL3: MOV     #EWORD1+3,R1    ;R1 PTR TO BITS 4-11 IN 36-BIT BUFFER
        MOV     #HAMMER,R2      ;R2 PTS TO MCOMP'S # TABLE.
        MOV#NAILS,R3            ;R3 PTS TO MCOMP'S BYTE TABLE.
        MOV     #SAW,R4         ;R4 PTS TO STIMULUS TABBLE.

        MOV     #-1,CTLMSK+24   ;DONT LOOK AT VMA HELD
;START MAIN LOOP BY SETTING PCP, USER, USER IOT & PUBLIC FLAGS TO REQURIED STATE:

DRILL:  INSYNC                  ;NEW SUBTEST
        CMP     #^D8,SUBNR      ;DONE ALL 8?

        BGE     BITS            ;NO, CONTINUE.

        JMP     NORMAL          ;YES, EXIT.


BITS:   CLEAR           ;START FRESH.
        MOVB    (R4),(R1)       ;PUT 1ST STIMULUS BYTE DIRECTLY IN BUFFER.
        BGE     ROUTER          ;IF MSB OF BYTE WAS SET, SET EBUS BIT 0
        MOVB    #10,EWORD1+4    ;IN BUFFER FOR "SCD PCP".

ROUTER: BICB    #217,(R1)       ;SAVE ONLY EBUS 5 (USER), 6 (UIOT) & 7(PUBLIC).
        STUFF           ;LOAD THE AR FROM THE BUFFER
        $DISP   24              ;SET 'SCD LOAD FLAGS" WITH "SPEC/FLAG CTL"
        $NUM    20              ;AND CR#04.
        $XBUF0                  ;EXECUTE BUFFER TO SET FLAGS


;SEQ336

;NOW SET "MCL KERNEL CYCLE" IOF REQUIRED:

        MOV     R5,-(SP)        ;SAVE SUBTEST # ON STACK.
        MOVB    (R4)+,R5        ;GET 1ST CODE BYTE TO R5
        ASR     R5              ;TEST THE KERNEL BIT.
        BCC     LATHE           ;SKIP IF IT IS NOT SET.

        $COND   15              ;OTHERWISE BRING UP "LOAD SPE CINSTER"
        $NUM    200             ;WITH "COND/SPEC ISNTR' & CR#01.

LATHE:  $XBUF0                  ;EXECUTE BUFFER TO SET KERNEL

;SET "CON CACHE LOAD EN" AND "CON TRAP EN" AS REQURIED:

        $CLRWD                  ;CLEAR 36-BIT BUFFER
        ASR     R5              ;TEST TRAP EN BIT.
        BCC     SANDER          ;SKIP IF CLEAR.
        MOVB    #40,EWORD1+1    ;SET EBUS BIT 22.

SANDER: ASR     R5              ;TEST CACHE LOAD BIT
        BCC     FILE            ;SKIP IF CLEAR.

        INCB    EWORD1+2        ;OTHERWISE SET EBUS BIT 19
FILE:   STUFF           ;LOAD THE AR FROM BUFFER.

        $COND   20              ;DO A CONO PAG (COND/DIAG FUNC
        $NUM    16              ;AND #16)
        $XBUF0                  ;CR FROM $MICRO, 0'S TO BUF 7 CR


;SEQ337

;NOW LOAD TEST MICROWORD INTO BUFFER:
        $CLRWD
        MOVB    (R4),(R1)       ;PUT 2ND STIMILUS BYTE IN BUFFER.
        BICB    #353,(R1)       ;KEEP ONLY EBUS BITS 7 & 9.

        STUFF                   ;LOAD THE AR FROM BUFFER.
        MOVB    (R4)+,R5        ;GET ANOTHER COPY OF CODE BYTE TO R5
        ASLB    R5              ;TEST MEM FIELD BIT.
        BCC     AWL             ;SET?
        $MEM 10          ;YES, SET "MEM/AD FUNC?

AWL:    ASLB    R5              ;NO, TEST DISP FIELD BIT.
        BCC     REAMER          ;SET?

        $DISP   26              ;YES, SET "SPEC/SP MEM CYCLE"

REAMER: ASLB    R5              ;NO, TEST VMA SEL FIELD BIT
        BCC     AUGER           ;SET?

        $VMA    1               ;YES, SET "VMA SEL 1".


;SEQ338

AUGER:  MOVB    (R4)+,R0        ;NO, GET # FIELD.
        BIC     #177400,R0      ;NO SIGN EXTENSION HOOEY.
        $NUM                    ;WRITE IT.
        $COND   17              ;;"COND/SEL VMA" TO NOT READ FLAGS THROUGH
        $XBUF                   ;ERXECUTE BUFFER
        MOV     (SP)+,R5        ;RESTORE SUBTEST #
        MOVB    #134,CTLDAT+16  ;EXPECT "-COND EN 0-7" E & "C/SELVMA"T
        CTLMCR                  ;DO COMPARE.
        $CLRWD          ;CLEAR BUFFERS
        $CLRMI          
        JMP     DRILL           ;LOOP BACK.


;SEQ339

.REM%
HERE IS THE STIMULUS TABLE.  BYTES HAVE THE FOLLOWING MEANNING:

BIT#    1ST BYTE                2ND BYTE                3RD BYTE
----    --------                --------                --------

  0     SET KERNEL CYCLE          0                     CR # 08
  1     SET TRAP EN               0                     CR # 07
  2     SET CACHE LOAD EN       SET AD 09                 0

  3       0                       0                     CR #05
  4     SET PUBLIC FLAG         SET AD 07               CR #04
5       SET USER IOT FLAG       SET VMA SEL 1             0


  6     SET USER FLAG           SET SPEC/SP MEMCY       CR # 02
  7     SET PCP FLAG            SET MEM/AD FUNC         CR # 01

%

SAW:    .BYTE   367             ;SUBTEST #1: PCP,USER,UIOT,PUB,CACHE,TRAP & KERN
        .BYTE   340             ;M/ADF, S/SMC, VSEL
        .BYTE   330

        .BYTE   321             ;SUBTEST #2:  PCP,USER,PUB KERN
        .BYTE   264             ;M/ADF, VSEL, AD07 & AD09
        .BYTE   330

        .BYTE   22              ;SUBTEST #3:  PUB, TRAP
        .BYTE   140             ;S/SMC,VSEL
        .BYTE   223

        .BYTE   204             ;SUBTEST #4:  PCP, CACHE
        .BYTE   360             ;M/ADF, S/SMC, VSEL, AD07
        .BYTE   20

        .BYTE   144             ;SUBTEST #5:  USER, UIOT & CACHE
        .BYTE   324             ;M/ADF, S/SMC, AD07, AD09
        .BYTE   112

        .BYTE   0               ;SUBTEST #6:
        .BYTE   0
        .BYTE   0

        .BYTE   43              ;SUBTEST #7:  UIOT, TRAP & KERN
        .BYTE   320             ;M/ADF, S/SMC, AD07
        .BYTE   212

        .BYTE   242             ;SUBTEST #8: PCP,UIOT, TRAP & KERN
        .BYTE   360             ;M/ADF,S/SMC,VSEL,AD07

        .BYTE   2


;SEQ340


;HERE IS MCOMP'S # TABLE:

HAMMER: .BYTE   13              ;SUBTEST #1
        .BYTE   12              ;2
        .BYTE   10              ;3
        .BYTE   13              ;4
        .BYTE   12              ;5
        .BYTE   0               ;6
        .BYTE   11              ;7
        .BYTE   13              ;8

;AND MCOMP'S BYTE TABLE:

NAILS:  .BYTE   15              ;SUBTEST #1:  "CON CACHE LOAD EN" & "CON TRAP EN"
        .BYTE   44
        .BYTE   17
        .BYTE   112             ;-CON MEM CYCLE"
        .BYTE   22              
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   26
        .BYTE   3               ;"MCL VMA GETS AD"
        .BYTE   27              
        .BYTE   0               ;"-MCL REQ EN" & SHORT STACK (FALSE)
        .BYTE   30
        .BYTE   10              ;"MCL PAGE  UEBR REF","-LOAD VMA CONTEXZT" & "-EBOX CAC
        .BYTE   31
        .BYTE   4               ;"-MCL EBOX MAY BE PAGED " & "MCL VMAX SEL 2"
        .BYTE   32      
        .BYTE   24              ;MCL VMAX SEL 1
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ" & -VMA PAGED FETCH
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"




;SEQ341

        .BYTE   16
        .BYTE   130             ;SUBTEST #2:  "-CON LOAD IR"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   26
        .BYTE   43              ;"MCL VMA READ" & "MCL VMA GETS AD"
        .BYTE   27
        .BYTE   0               ;"-MCL READ EN" & SHORT STACK (FALSE)
        .BYTE   30
        .BYTE   21              ;"MCL VMA USER" & "-MCL LOAD VMA CONTEXT"
        .BYTE   31
        .BYTE   25              ;"MCL VMA PUBLIC " & "MCL VMAX SEL 2"
        .BYTE   32
        .BYTE   44              ;"-MCL VMA PREV" & LOAD ARX"
        .BYTE   33
        .BYTE   77              ;"MCL MBOX CYC REQ" & VMA FETCH

        .BYTE   15
        .BYTE   4               ;SUBTEST #3:  "CON TRAP EN"
        .BYTE  22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   27
        .BYTE   30              ;"MCL VMA UPT"
        .BYTE   30
        .BYTE   31              ;"MCL VMA USER", PAGE UEBR REF" & LVCTX
        .BYTE   31
        .BYTE   21              ;"MCL VMA PUBLIC"
        .BYTE   32
        .BYTE   24              ;"VMAX SEL 1"
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"


;SEQ342

        .BYTE   15
        .BYTE   40              ;SUBTEST #4:  "CON CACHE LOAD EN"
        .BYTE   17
        .BYTE   112             ;;"-CON MEM CYCLE"
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   26
        .BYTE   3               ;"MCL VMA GETS AD"
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN" & SHROT STACK
        .BYTE   30
        .BYTE   0               ;"-MCL EBOX CACHE" & "-MCL LOAD VMA CONTEXT"
        .BYTE   31
        .BYTE   25              ;"MCL VMA PUGLIC" & "MCL VMAX SEL 2
        .BYTE   32
        .BYTE   4               ;"-MCL VMA PREVIOUS"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ" & -VMA PAGED FETCH
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"

        .BYTE   15
        .BYTE   42              ;SUBTEST #5:  "CON CACHE LOAD EN" & "MCL VMA GETS AD"
        .BYTE   16
        .BYTE   130             ;"-CON LOADIR" "-COND END-7" & "-COND/SEL VMA"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   26
        .BYTE   43              ;"MCL VMA READ" & "VMA GETS AD"
        .BYTE   27
        .BYTE   0       ;"-MCL REQ EN " & SHORT STACK
        .BYTE   30
        .BYTE   21              ;"-MCL LOAD VMA CONTEXT" & "VMA USER"
        .BYTE   31
        .BYTE   5               ;"MCL VMAX SEL 2"
        .BYTE   32
        .BYTE   44              ;"-MCL VMA PREV" & "LOAD ARX"
        .BYTE   33
        .BYTE   77              ;"MCL MBOX CYC REQ" & VMA FETCH
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"


;SEQ343

        .BYTE   15
        .BYTE   4               ;SUBTEST #7:  "CON TRAP EN"
        .BYTE   17              
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   26              
        .BYTE   3               ;"MCL VMA GET AD'
        .BYTE 27         
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   30
        .BYTE   21              ;"-MCL LOAD VMA CONTEXT" & "VMA USER"
        .BYTE   31
        .BYTE   4               ;"-MCL EBOX MAY BE PAGED" & "MCL VMAX SEL 2"
        .BYTE   32
        .BYTE   4               ;"-MCL VMA PREVIOUS"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ"
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"

        .BYTE   15
        .BYTE   4               ;SUBTEST #8:  "CON TRAP EN
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   22
        .BYTE   1              ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   26
        .BYTE   13              ;"MCL PAGE TEST PRIVATE" & "VMA GETS AD"
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN" & SHORT STACK
        .BYTE   30
        .BYTE   21              ;"-MCL LOAD VMA CONTEXT" & "VMA USER"
        .BYTE   31
        .BYTE   24              ;"MCL VMAX SEL 2, "MCL & MAY BE PAGED", & "VMA PUBLIC"
        .BYTE   32
        .BYTE   4               ;"-MCL VMA PREVIOUS"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYCLE REQ"
        .BYTE   41
        .BYTE   260             ;"CTL SPEC/SP MEM CYCLE"
        .EVEN


;SEQ344

.SBTTL TEST 32 (EAPR5):  FM BLOCK SELECTION

;THIS TEST CHECKS THE FM BLOCK, VMA BLOCK & XR BLOCK MIXERS AND THE
;VMA BLOCK REGISTER ON APR5.  IT USES SOME OF THE PXCT AND PREVIOUS
;ENABLE LOGIC ON THE MCL BOARD.
;IT ALSO CHECKS THE AC +<# LOGIC ON APR4 AND SH AR EXTENDED.

;INITIALIZE:

EAPR5:  MOV     #EWORD1+3,R1    ;PTR TO BYTE WITH EBUS 4-11 IN BUFFER
        MOV     #CHEVY,R2               ;PTR TO MCOMP'S # TABLE
        MOV     #FORD,R3                ;PTR TO MCOMP'S BYTE TABLE
        MOV     #CADDY,R4               ;PTR TO STIMULUS TABLE
        MOVB    #20,CTLMSK+11   ;UNMASK "SH AR EXTENDED"

;MAIN LOOP STARTS HERE:

ROLLS:  INSYNC                  ;SUBTESTS 1-20
        CLEAR                   ;START FRESH

;LOAD AC BLOCK REGISTERS, AD REQURIED:

        CLRB    (R1)            ;CLEAR BITS 4-11 BUFFER
        MOV     R2,-(SP)        ;SAVE MCOMP PTR TEMPORARILY
        MOVB    (R4)+,R2        ;GET NEXT CODED STIMULUS BYTE
        ASR     R2              ;IS PREV BLOCK BIT SET?
        BCC     DODGE           ;IF NO, LEAVE PB EBUS BITS CLEAR.

        BISB    #7,(R1)         ;YES, SET EBUS BITS 9-11 IN BUFFER.

DODGE:  ASR     R2              ;IS "CURRENT BLOCK" BIT SET?
        BCC     OLDS            ;IF NO, LEAVE CB EBUS BITS CLEAR.
        BISB    #70,(R1)        ;YES, SET EBUS BITS 6-8  IN BUFFER.

OLDS:   STUFF           ;LOAD THE AR FROM THE BUFFER.

        $COND   20              ;SET "COND/DIAG FUNC" & MAGIC # FOR
        $NUM    25              ;"LOAD AC BLOCKS".
        $XBUF0          ;EXECUTE TO SET/CLEAR AC BLOCKS.


;SEQ345

;SET XR PREV AND PREV EN, AS REQUIRED:
;START BY SETTING THE AC # FIELD TO BE USED TO SET A PXCT CONDITION:

        CLR     R0              ;IF NEITHER REQUIRED, WILL SET AC #0.
        ASR     R2              ;IS THE "XR PREVIOUS" BIT SET?
        BCC     BUICK           ;IF NO, GO AROUND.

        INC     R0              ;SET, BUMP TWICE SO PXCT 2 (AC11 BIT)
        INC     R0              ;WILL GET SET.

BUICK:  ASR     R2              ;HOW ABOUT THE "VMA PREV EN" BIT?
        BCC     STUDE           ;GO AROUND, IF CLEAR.

        INC     R0              ;SET BUMP OR PXCT 1 (AC12 BIT)

STUDE:  $ACSET          ;SHOULD SET AC # TO 0,1,2 OR 3.

        $COND 15                ;SET "COND/SPEC INSTR" & CR04
        $NUM    20              ;TO GIVE PXCT 0,1,2 OR 3.
        $MWORD                  ;WRITE TO CR.

        $COND   16              ;SET 'COND/SR #" & CR#00-02 TO
        $NUM    700             ;GET XR PREVIOUS AND/OR PREV COND.
        $XBUF0                  ;CLOCK ACCESS CONDITION REG


;SEQ346

;LOAD TEH VMA BLOCK REGISTER BY BRINGING UP :LOAD VMA CONTET:
        $VMA    3               ;THIS CAUSES LOAD (VMA SEL 1 & 2)
        $XBUF0                  ;EXECUTE BUFFER

;SEE IF #'S SHOULD BE SET:

        ASR     R2              ;CHECK # BIT
        BCC     MERC            ;GO AROUND IF CLEAR

        $NUM    160             ;SET, NEED CR#02, 3 & 4.

;SET PROPER FM ADDRESS FROM TABLE:

MERC:   MOV     R2,R0           ;REMAINING 3 CODE BITS ARE FM ADR.
        $FM                     ;WRITE THEM TO BUFFER.

        $XBUF                   ;AND BUFFER TO CR.

        MOV     (SP)+,R2        ;RESTORE MCOMP PTR

        CTLMCR                  ;COMPARE

        CMP     #^D20,SUBNR     ;SEE IF DONE
        BGT     ROLLS           ;LOOP IF NOT.


;SEQ347

;THESE SUBTESTS CHECK OUT THE ALU GIVING "AC+#" AND THE MUX POSITION
;FEEDING "AC+#" INTO "FM ADR" ON APR4.

        MOV     #VOLKS,R4       ;POINTER TO NEW STIMULUS TABLE

BENTLY: INSYNC                  ;SUBTESTS 21 TO 27
        CLEAR                   ;FRESH START

        MOV     (R4),R0 ;GET STIMULUS WORD
        ASR     R0              ;RIGHT JUSTIFY AC# IN LEFT BYTE
        SWAB    R0              ;MAKE IT RIGHT BYTE
        $ACSET                  ;SET AC NUMBER WITH IT

        MOV     (R4)+,R0        ;GET SECOND COPY OF STIMULUS WORD
        $NUM                    ;LOAD MAGIC # FROM LOWER 9 BITS
        $FM     6               ;SET FM ADR SEL TO 6
        $MWORD                  ;LOAD COMMAND REGISTER
        CTLMCR                  ;COMPARE
        CMP     #^D27,R5        ;DONE ALL SUBTESTS?
        BGT     BENTLY          ;LOOP IF NOT
        JMP     NORMAL          ;OTHERWISE...DONE


;SEQ348

;HERE IS THE STIMULUS TABLE FOR THE FM BLOCK MUX TEST.  THE BYTE ARE CODD AS FOLLOWS:

;BIT#   MEANING

;  0    SET PREV BLOCK = 7
;  1    SET CURRENT BLOCK = 7
        
;  2    SET "MCL XR PREVIOUS"
        

;  3    SET "MCL VMA PREV EN"
;  4    SET CR#02, 3 & 4
;  5    SET FM ADR SEL 1
;  6    SET FM ADR SEL 2
        
;  7    SET FM ADR SEL 4

;(IN ALL CASES, A BIT ON A "0" MEANS CLEAR THE CORRESPONDING SIGNALS.)

CADDY:  .BYTE   172             ;SUBTEST #1:  CB, VMA PV, #, FM ADR = 3
        .BYTE   112             ;2:  CB , VMA PV, FM ADR = 2
        .BYTE   106             ;3:  CB, XR PV, FM ADR = 2
        .BYTE   142             ;4:  CB, FM ADR = 3
        .BYTE   6               ;5:  BC, XR PV, FM ADR = 0
        .BYTE   305             ;6:  PB, XR PV, FM ADR = 6
        .BYTE   105             ;7:  PB, XR PV, FM ADR = 2
        .BYTE   42              ;8:  CB, FM ADR = 1
        .BYTE   151             ;9:  PB, VMA PV, FM ADR = 3
        .BYTE   202             ;10:  CB, FM ADR = 4
        .BYTE   242             ;11:  CB, FM ADR = 5
        .BYTE   302             ;12:  CB, FM ADR = 6
        .BYTE   360             ;13:  #, FM ADR = 7
        .BYTE   0               ;14:  FM ADR = 0
        .BYTE   40              ;15:  FM ADR = 1
        .BYTE   100             ;16:  FM ADR = 2
        .BYTE   140             ;17:  FM ADR = 3
        .BYTE   200             ;18:  FM ADR = 4
        .BYTE   240             ;19:  FM ADR = 5
        .BYTE   340             ;20: FM ADR = 7

;SEQ349

;THIS TABLE HAS MAGIC #'S AND AC#'S FOR TESTING THE AC+# LOGIC.
;ITS FORMAT IS AS FOLLOWS:

;               BIT#    MEANING

;                0      CRAM # 08
;                1      CRAM # 07
        
;                2      CRAM # 06

;                3      CRAM # 05
;               4       CRAM # 04
;               5       CRAM # 07

;                6      CRAM # 02
;                7      CRAM # 01
;                8      CRAM # 00

;                9      AC 12
;               10      AC 11
;               11      AC 10

;               12      AC 09
;            13-15      NOT USED

VOLKS:  .WORD   17224           ;SUBTEST #21:  AC = 17, # = 224
        .WORD   00267           ;22:    AC = 0, # = 267
        .WORD   05546           ;23:   AC  = 5, # = 546
        .WORD   14031           ;24:    AC = 14, # = 31
        .WORD   17201           ;25:    AC = 17, # = 201
        .WORD   13023           ;26:    AC = 13, # = 23
        .WORD   06016           ;27:    AC = 6, # = 16


;SEQ350

;HERE IS MCOMP'S # TABLE:

CHEVY:  .BYTE   5               ;SUBTEST #1
        .BYTE   7               ;2
        .BYTE   4               ;3
        .BYTE   3               ;4
        .BYTE   5               ;5
        .BYTE   4               ;6
        .BYTE   5               ;7
        .BYTE   3               ;8
        .BYTE   7               ;9
        .BYTE   3               ;10
        .BYTE   3               ;11
        .BYTE   3               ;12
        .BYTE   2               ;13
        .BYTE   0               ;14
        .BYTE   1               ;15
        .BYTE   0               ;16
        .BYTE   0               ;17
        .BYTE   1               ;18
        .BYTE   1               ;19
        .BYTE   0               ;20
        .BYTE   2               ;21
        .BYTE   2               ;22
        .BYTE   2               ;23
        .BYTE   2               ;24
        .BYTE   2               ;25
        .BYTE   2               ;26
        .BYTE   2               ;27
.EVEN


;SEQ351

;HERE IS MCOMP'S BYTE TABLE:

FORD:  
        .BYTE   1
        .BYTE   16              ;SUBTEST #1:  "CURRENT BLOCK 4,2 & 1"
        .BYTE   11
        .BYTE   42              ;APR AC+#11,SH AR EXTENDED
        .BYTE   27
        .BYTE   24              ;"MCL SHORT STACK" & "MCL VMA ADR ERR"
        .BYTE   32
        .BYTE   10              ;"-MCL VMA PREV"&"MCL PAGE ILL ENTRY"
        .BYTE   31
        .BYTE   11              ;PAGE ADDRESS COND

        .BYTE   1
        .BYTE   16              ;SUBTEST #2:  CURRENT BLOCK 4,2 & 1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   11
        .BYTE   41              ;APR AC+#12 SH AR EXTENDED
        .BYTE   12
        .BYTE   204             ;FM BLOCK 1
        .BYTE   27
        .BYTE   24              ;"MCL VMA ADR ERR"
        .BYTE   32
        .BYTE   10              ;"-MCL VMA PREV"&"MCL PAE ILL ENTRY"
        .BYTE   31
        .BYTE   11              ;PAGE ADDRESS COND

        .BYTE   1
        .BYTE   16              ;SUBTEST #3:  CURRENT BLOCK 4,2&1
        .BYTE   11
        .BYTE   2               ;APR AC+#11
        .BYTE   12
        .BYTE   0               ;"APR F02 EN" (FALSE)
        .BYTE   26
        .BYTE   5               ;"MCL XR PREVIOUS"


;SEQ352

        .BYTE   1
        .BYTE   16              ;SUBTEST #4:  CURRENT BLOCK 4, 2&1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   12
        .BYTE   204             ;FM BLOCK 1

        .BYTE   1
        .BYTE   16              ;SUBTEST#5:  CURRENT BLOCK 4, 2 & 1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 7 2
        .BYTE   11
        .BYTE   2               ;APR AC+#11
        .BYTE   12
        .BYTE   220             ;FM BLOCK 1, FM ADR 2 & "F02 EN" (FALSE)
        .BYTE   26
        .BYTE   5               ;"MCL XR PREVIOUS"

        .BYTE   1
        .BYTE   1               ;SUBTEST #6:  PREV BLOCK 4
        .BYTE   11
        .BYTE   302             ;PREV BLOCK 2 7 1 AND APR AC+#11
        .BYTE   12
        .BYTE   20              ;FM ADR 2 &"F02 EN" (FALSE)
        .BYTE   26
        .BYTE   5               ;"MCL XR PREVIOUS"

        .BYTE   1
        .BYTE   1               ;SUBTEST #7:  PREV BLOCK 4
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   11
        .BYTE   302             ;PREV BLOCK 2 & 1 AND APR AC+#11
        .BYTE   12
        .BYTE   200             ;FM BLOCK 1
        .BYTE   26
        .BYTE   5               ;"MCL XR PREVIOUS"

 
        .BYTE   1
        .BYTE   16              ;SUBTEST #8:  CURRENT BLOCK 4, 2 &1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   12
        .BYTE   214             ;FM BLOCK 1 & FM ADR 1


;SEQ353

        .BYTE   1
        .BYTE   1               ;SUBRTEST #9:  PREV BLOCK 4
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   11
        .BYTE   341             ;PREV BLOCK 2 & 1 AND APR AC+#12,SH AR EXTENDED
        .BYTE   12
        .BYTE   204            ;FM BLOCK 1
        .BYTE   27
        .BYTE   24              ;"-MCL PREV COND"
        .BYTE   32
        .BYTE   10              ;"-MCL VMA PREV"
        .BYTE   31
        .BYTE   11              ;PAGE ADDRESS COND

        .BYTE   1
        .BYTE   16              ;SUBTEST #10:  CURRENT BLOCK 4, 2 & 1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   12
        .BYTE   224             ;FM BLOCK 1 & FM ADR 2

        .BYTE   1
        .BYTE   16              ;SUBTEST #11:  CURRENT BLOCK 4, 2 & 1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 & 2
        .BYTE   12
        .BYTE   234             ;FM BLOCK 1 & FM ADR 1 & 2

        .BYTE   1
        .BYTE   16              ;SUBTEST #12:  CURRENT BLOCK 4, 2 & 1
        .BYTE   2
        .BYTE   3               ;FM BLOCK 4 7 2
        .BYTE   12      
        .BYTE   204             ;FM BLOCK 1

        .BYTE   2
        .BYTE   3               ;SUBTEST #13:  FM BLOCK 4 & 2
        .BYTE   12
        .BYTE   204             ;FM BLOCK 1

        .BYTE   12
        .BYTE  14              ;SUBTEST #15:: FM ADR 1

        .BYTE   12
        .BYTE   24              ;SUBTEST #18:  FM ADR 2

        .BYTE   12
        .BYTE   34              ;SUBTEST #19:  FM ADR 1 & 2



;SEQ354

        .BYTE   11
        .BYTE   52              ;SUBTEST #21:  AC+# 09 & 12
        .BYTE   12
        .BYTE   124             ;FM ADR 10 & 2
        
        .BYTE   11
        .BYTE   10              ;SUBTEST #22:  AC+# 09
        .BYTE   12
        .BYTE   104             ;FMA ADR 10

        .BYTE   11
        .BYTE   54              ;SUBTEST #23:  AC+# 09 & 10 SH AR EXTENDED
        .BYTE   12
        .BYTE   144             ;FM ADR 10 & 4

        .BYTE   11
        .BYTE   0               ;SUBTEST #24:  AC+# = 0
        .BYTE   12
        .BYTE   0

        .BYTE   11              
        .BYTE   57              ;SUBTEST #25:  AC+# 09,10,11 & 12 & SH AR EXTENDED
        .BYTE   12
        .BYTE   174             ;FM ADR 10,4,2,1

        .BYTE   11
        .BYTE   43              ;SUBTEST #26:  AC+# 11 & 12 SH AR EXTENDED
        .BYTE   12
        .BYTE   30              ;FM ADR 2 7 1 & F02 EN (FALSE)

        .BYTE   11
        .BYTE   6               ;SUBTEST #27:  AC+# 10 & 11
        .BYTE   12
        .BYTE   64              ;FM ADR 4 & 2


;SEQ355


.SBTTL TEST 33 (EFLAG2): PROCESSOR FLAGS

.REM    %
THIS CHECKS ALL OF THE PROCESSOR FLAG LOGIC ON SCD4 & 5 NOT ALREADY TESTED
IN EMCL1 EXCEPT SDOME GATING INVOLVING MBOX, SIGNALS FOR THE "PRIVATE
INSTRUCTION" FLAG AND THE ARITHMETIC OVERFLOW FLAGS (CHECKED IN EFLAG2).  THE TRAP MIXERS
%

;INITIALIZE:

EFLAG2: MOV     #EWORD1,R1              ;R1 PTS TO 36-BIT BUFFER.
        MOV     #PINE,R2                ;R2 PTS TO MCOMP'S # TABLE.
        MOV     #BIRCH, R3              ;R3 PTS TO MCOMP'S VALUE TABLE

;USE "PCF_#" AND NUMER BITS TO SET FLAGS ONE AT-A-TIME & SHIFT 1 THROUGH AR 32-35
;TO CHECK SCD TRAP MIX POSITIONS 0- & 3.

        MOV     #20,(R1)                ;SET EBUS BIT 31 IN BUFFER.
        MOV     #400,R4         ;R4 WILL HOLD CURRENT # VALUE.

OAK:    INSYNC          ;NEW SUBTEST (9 IN THIS LOOP).

        CLEAR                   ;CLEAR ALL FLAGS.

        MOV     R4,R0           ;GET CURRENT # BIT.
        $NUM                    ;WRITE IT TO BUFFER.
        $COND   11              ;SET "COND/PCF #" IN BUFFER.

        $MWORD                  ;BUFFER TO CR.


;SEQ356

;READ FLOATING 1 IN AR THROUGH TRAP MUX IN SUBTESTS 1-4         ;READ # BITS THEREAFTER:
        CMP     SUBNR,#4        ;DOING 1ST 4?
        BGT     BEECH           ;IF NOT, SKIP NEXT STUFF.
        ASRB    (R1)            ;SHIFT BIT TO LOAD INTO AR.

        $COND   33              ;SWITCH TRAP MUX TO READ AR BITS
        BR      SPRUCE          ;GO LOAD THE AR AND ALL THAT.

BEECH:  $SETWD                  ;CHANGE BUFFER TO LOAD AR WITH 1'S.

        $COND   30              ;SWITCH MUX TO READ # BITS.

SPRUCE: STUFF           ;LOAD THE AR FROM 36-BIT BUFFER.

        $MWORD          ;EXECUTE CR TO SET A FLAG.

        FLGMCR          ;DO A COMPARE.
        ASR     R4              ;UPDATE # AND DO NEXT.
        BNE     OAK             ;STOP WHEN 9 HAVE BEEN DONE.

;SET ALL # BITS & PI CYCLE (SHOULD BREAK PCF_#):

        INSYNC                  ;SUBTEST #10: NO FLAGS SHOULD SET
        CLEAR                   ;CLEAR FLAGS & AR
        $NUM    777             ;ALL # BITS.
        $COND   15              ;THIS IS "COND/SPEC INSTR " TO
        $MWORD                  ;BRING UP PI CYCLE
        $COND   11              ;RESTORE "COND/PCF_#"
        $XBUF0                  ;EXECUTE BUFFER
        FLGMCR          ;COMPARE


;SEQ357

;TEST THE TRAP FLAG LOGIC.
;BEGIN BY SETTING THE TRAP REQUESTS (AND ADR BRK INH) USING "LOAD FLAGS"
;WITH THE APPROPRIATE AR BITS SET AND THEN TRANSFERRING THE REQUESTS TO
;THE CYCLE FLOPS USING "CON TRAP"EN AND "DISP/NICOND".

        CLEAR                   ;FRESH START
        MOV     #EWORD1+3,R1    ;R1 NOW POINTS TO BITS 4-11 BUFFER
        MOV     #EWORD1+1,R4    ;R4 POINTS TO BITS 20-27 IN BUFFER
        INSYNC                  ;SUBTST #11:TRANSFER REQUESTS TO CYCLES

;FIRST SET THE REQUESTS:

        $CLRWD                  ;CLEAR THE 36-BIT BUFFER.
        MOVB    #16,(R1)        ;THEN SET BITS 8,9 & 10 IN IT.
        STUFF                   ;LOAD THE AR FROM THE BUFFER

        $DISP   24              ;SET "LOAD FLAGS" TO
        $NUM    20              ;THE BUFFER...
        $XBUF0                  ;AND SET THE FLAGS

;NOW  SET "CON  TRAP EN" WITH A CONO PAG:

        $CLRWD          ;CLEAR 36-BIT BUFFER
        MOVB    #40,(R4)        ;SET EBUS BIT 22 IN BUFFER
        STUFF                   ;AND IN THE AR

        $COND   20              ;SET "COND/DIAG FUNC" AND #
        $NUM    16              ;TO DO A "CONO PAG" TO SET
        $XBUF0          ;"CON TRAP EN".

;NOW DO "DISP/NICOND' TO SET CYCLE FLOPS:

        $DISP   6               ;"DISP/NICOND" TO BUFFER
        $XBUF0          ;AND EXECUTE IT
        FLGMCR          ;SEE THAT CYCLES SET & REQUESTS CLEARED


;SEQ358

;NOW TRANSFER BACK TOR EQUESTS WITH A "COND INSTR ABORT""

        INSYNC                  ;SUBTEST #12:  CYCLES TO REQUESTS
        $COND   15              ;BRING UP "INSTR ABORT" WITH "COND/
        $NUM    4               ;SPEC INSTR" AND CR#06.
        $XBUF0          ;DO IT.
        FLGMCR                  ;SEE THAT CYCLES CLEARED AND REQS SET
                                ;(NOTE: "SCD PRIVATE INSTR" AALSO CLEARED)

;SEQ358

;NOW CLEAR "CON TRAP EN" AND DO "DISP/NICOND" TO MAKE SURE TRAP CYCLE DON'T
;SET WITHOUT THE ENABLE BEING TRUE:(ADR BRK DOES, HOWEVER)
        INSYNC                  ;SUBTEST #13:NO TRANSFER WITOUT TRAPEN
        $CLRWD                  ;CLEAR THE 36-BIT BUFFER
        STUFF           ;AND THE AR.
        $COND   20              ;DO A CONO PAG TO CLEAR
        $NUM    16              ;"CON TRAP EN".
        $XBUF0
        $DISP   6               ;BRING UP "DISP/NICOND" AND
        $XBUF0                  ;EXECUTE IT.
        FLGMCR                  ;SEE THAT REQUESTS CLEARED & ONLY ADR BRK CYCLE


;SEQ359

;RESTORE "CON TRAP EN" AND DO ANOTHER "DISP/NICOND" TO MAKE SURE CYCLES
;DON'T SET WITHOUT REQUESTS:

        INSYNC                  ;SUBTEST #14:  NO CYCLES WITHOUT REQUESTRS
        MOVB    #40,(R4)        ;SET EBUS BIT 22 IN THE BUFFER AND
        STUFF                   ;LOAD THE AR FFOM THE BUFFER

        $COND   20              ;DO ANOTHER CONO PAG TO SET
        $NUM    16              ;"CON TRAP EN"
        $XBUF0
        $DISP   6               ;AND DO ANOTHER "DISP/NICOND"
        $XBUF0                  
        FLGMCR                  ;SEE THAT NOTHING SETS


;SEQ360

;TEST THE USER/UIOT/PUBLIC/PRI INSTR FLAG.  THESE SUBTESTS INVOLVE PRESETTING
;THE FLAGS TO A GIVEN STATE & THEN CAUSING AND VERIFYING A TRANSITION.

        MOV     #CEDAR,R4               ;R4 NOW POINTS TO THE STIMULUS TABLE

PECAN:  INSYNC                  ;SUBTESTS 15-20
        CLEAR                   ;START FRESH EACH TIME.
        $CLRMI
        $CLRWD

;SET UP TO PRESET FLAGS TO DESIRED STATE:

        MOVB    (R4),(R1)       ;PUT PRESET BITS INTO BUFFER
        BICB    #217,(R1)       ;ONLY AR BITS 5,6 & 7 ALLOWED
        STUFF                   ;LOAD AR FROM BUFFER

;SEEW IF NEED TO CLEAR "PRIVATE INSTR" FLAG SEPARATELY:

        BITB    #1,(R4)+        ;SEE IF BIT SET IN STIMULUS TALE
        BEQ     WILLOW          ;SKIP AROUND IF IT IS NOT

        $COND   15              ;OTHERWISE, BRING UP "COND INSTR ABORT"
        
WILLOW: $DISP   24              ;"SPEC/FLAG CTL" + CR#04 =
        $NUM    24              ;"LOAD FLAGS" (CR#06 IS USED FOR ABORT).
        $XBUF0                  ;SET FLAGS & LEAVE BUFFER CLEAR


;SEQ361

;NOW CHANGE AR BITS 5,6 & 7 TO VALUES NEEDED FOR THIS SUBTEST:

        MOVB    (R4),(R1)           ;PUT THIS TEST'S BITS INTO BUFFER.
        BICB    #217,(R1)       ;K OCK OFF ANY EXTRA BITS.
        STUFF                   ;LOAD AR FROM THE BUFFER.
;SET # AND DISP FIELDS FOR THIS SUBTEST:

        MOVB    (R4),R0         ;GET SECOND CODE BYTE.
        ASL     R0              ;THE # BITS ARE SHIFTED IN TABLE
        BIC     #177355,R0              ;ONLY # BITS 0,4 AND 7 ALLOWED.
        $NUM                    ;WRITE # FIELD TO BUFFER
        CLR     R0              ;CLEAN SLATE
        BITB    #2,(R4)+        ;SEE IF S/FCTL BIT IS SET.
        BEQ     WALNUT          ;CLEAR FIELD IF IT IS NOT
        MOV     #24,R0          ;SET "SPEC/FLAG CTL "

WALNUT: $DISP                   ;WRITE DISP FIELD TO BUFFER.
        $COND   32              ;SWITCH TRAP MUX.
        $MWORD                  ;AND BUFFER TO CR.
        FLGMCR                  ;COMPARE
        CMP     SUBNR,#^D20     ;SEE IF DONE
        BLT     PECAN   ;LOOP IF NOT.

;SEQ362

;TEST THAT "PI&SF: GIVES A "TCLR" AND "LEAVE USER":

        INSYNC                  ;SUBTEST #21
        CLEAR                   ;FRESH START
        $CLRMI                  ;CLEAR BUFFER TOO
;SET USER MODE (SDO THAT YOU CAN SEE "LEAVE"):

        MOVB    #100,(R1)       ;SET EBUS BIT 5 IN BUFFER
        STUFF                   ;AND IN AR
        $DISP   24              ;SET "LOAD FLAGS" IN BUFFER
        $NUM    20
        $XBUF0                  ;SET USER MODE & CLEAR BUFFER

;BRING UP PI CYCLE:

        $COND   15              ;SET "COND/SPEC INSTR" AND
        $NUM    400             ;CR#00 IN BUFFER
        $XBUF0          ;SET PI CYCLE

;FINALLY BRING UP "SPEC/SAVE FLAGS":

        $DISP   25              ;SET "SPEC/SAVE FLAGS" IN BUFFER
        $MWORD                  ;AND WRITE TO CR
        FLGMCR                  ;CHECK RESULT


;SEQ363


;NOW TEST THE "HIDDEN" PCP FLAG AND THE "VMA HELD OR PC00" LOGIC.  SOME
;STATES OF THIS LOGIC WERE ARLEADY TESTED IN EMCL1.  ALSO TEST TWO CLEAR
;INPUTS TO "FPD" WHICH WERE NOT PREVIOUSLY TESTED.


JOSHUA: INSYNC                  ;SUBTEST #22
        CLEAR                   ;FREST START
        $CLRMI          ;BUFFERS TOO
        $CLRWD

;LOAD "OV", "PCP" AND "FPD" FLAGS (AR00 BIT) WITH "JFCL" ON (ONLY "OV" & "FPD: SHOULD BE

        MOVB    #10,EWORD1+4    ;SET AR00 BIT IN 36-BIT BUFFER
        MOVB    #200,(R1)       ;AND AR04 BIT (FOR "FPD")
        STUFF                   ;AND WRITE BUFFER TO AR

        $DISP   24              ;BRING UP "SPEC/FLAG CTL" IN U-WORD BUFFER.
        $NUM    220             ;AND #'S TO GIVE "JFCL" & "LOAD FLAGS".
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;COMPARE.

;NOW DROP "JFCL" AND CLEAR FPD USING "SPEC/SAVE FLAGS" ("OV" & "PCP" RECIRCULATE):

        INSYNC                  ;SUBTEST #23
        $DISP   25              ;CHANGE "LOAD FLAGS" TO "SAVE FLAGS"
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;COMPARE


;SEQ364

;NOW SET BOTH "OV" & "PCP" (JFCL OFF), BRING UP JFCL & LOAD  "USER" & "FPD" (BUT NOT OV/P
;THE "PCP" FLAG SHOULD RECIRCULATE WHILE THE "OV" FLAG CLEARS (LOAD WITHOUT AR00).

        INSYNC                  ;SUBTEST #24.
        $DISP   24              ;RESTORE "LOAD FLAGS", BUT THIS TIME
        $NUM    20
        $XBUF0                  ;EXECUTE BUFFER
        CLRB    EWORD1+4        ;DROP AR00 BIT IN BUFFER.
        MOVB    #300,(R1)       ;SET AR04 & 05 FOR "FPD" & "USER"
        STUFF                   ;AND LOAD AR FROM BUFFER.
        $DISP   24              ;RESTORE "LOAD FLAGS" AGAIN
        $NUM    622             ;RESTORE "JFCL" (SO PCP RECIRCULTES)
        $XBUF                   ;NEW WORD TO CR
        $DISP   0               ;DROP "LOAD"
        $NUM    20              ;AND "JFCL"
        $MWORD                  ;LOAD CR & EXECUTE LAST CR.
        FLGMCR                  ;COMPARE.


;SEQ365

;FINALLY CLEAR "FPD" FROM "SPEC/CLR FPD: ("PCP" GETS CLEARED TOO BECAUSE JFCL"S OFF):
        INSYNC                  ;SUBTEST #25
        $DISP   14              ;SET "SPEC/CLR FPD: IN BUFFER.
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;COMPARE
        JMP     NORMAL          ;ALL DONE.


;SEQ366

;THIS TABLE IS USED BY THE USER FLAG TESTS (15-20)
;THERE ARE TWO BYTES PER SUBTEST, CODED AS FOLLOWS:

;BIT#   FIRST BYTE              ;SECOND BYTE

;  0    PRECLR PRI              ;SET CR#07
;  1       0                    SET SPEC/FLAG CTL
;  2       0                         0
;  3       0                    SET CR#04
;  4    PRESENT PUBLIC (CLR PRI)          AR07
;  5    PRESET UIOT                     Q AR06
;  6    PRESET USER                     AR05
;  7       0                    SET CR#00

CEDAR:  .BYTE   60              ;SUBTEST #15:  UIOT, PUBLIC (CLR PRI)
        .BYTE   312             ;AR05, S/FCTL, #=420

        .BYTE   40              ;SUTEST #16:  UIOT
        .BYTE   203             ;S/FCTL, #-402

        .BYTE   100             ;SUBTEST #17:  USER
        .BYTE   72              ;AR06,AR07,S/FCTL #=20

        .BYTE   160             ;SUBTEST #18:  USER, UIOT & PUBLIC (CLR PRI)
        .BYTE   0               ;#=0

        .BYTE   1               ;SUBTEST #19:  CLR PRI
        .BYTE   202             ;S/FCTL, #=400

        .BYTE   20              ;SBUTERST #20:  PUIBLIC (CLR PRI)
        .BYTE   252             ;S/FCTL,AR06, #=420


;SEQ367


;MCOMP # TABLE FOR FLAG LOGIC TEST:

PINE:   .BYTE   2               ;SUBTEST #1:  CHANGE 2 BYTES.
        .BYTE   2               ;2
        .BYTE   2               ;3
        .BYTE    2               ;4
        .BYTE   1               ;5
        .BYTE   2               ;6
        .BYTE   2               ;7
        .BYTE   1               ;8
        .BYTE   1               ;9
        .BYTE   2               ;10

        .BYTE   2               ;11
        .BYTE   3               ;12
        .BYTE   2               ;13
        .BYTE   1               ;14

        .BYTE   5               ;15
        .BYTE   1               ;16
        .BYTE   5               ;17
        .BYTE   4               ;18
        .BYTE   2               ;19
        .BYTE   4               ;20

        .BYTE   4               ;21

        .BYTE   6               ;22
        .BYTE  1               ;23
        .BYTE   5               ;24
        .BYTE   4               ;25


;SEQ368

;MCOMP BYTE TABLE FOR FLAG LOGIC REST:

BIRCH:  .BYTE   1               
        .BYTE   220             ;SUBTEST #1:  "SCD OV"
        .BYTE   6               
        .BYTE   310             ;"SCD TRAP MIX 32"

        .BYTE   2
        .BYTE   130             ;SUBTEST#2:  "SCD FOV"
        .BYTE   6
        .BYTE   250             ;"SCD TRAP MIX 33"

        .BYTE   0
        .BYTE   10              ;SUBTEST #3:  "SCD FPD"
        .BYTE   7               
        .BYTE   104             ;"SCD TRAP MIX 34"

        .BYTE   0
        .BYTE   200             ;SUBTEST #4:  "SCD TRAP REQ 2"
        .BYTE   7
        .BYTE   44              ;"SCD TRAP MIX 35"

        .BYTE   0
        .BYTE   20              ;SUBTEST #5:  "SCD TRAP REQ 1"

        .BYTE   2               
        .BYTE   70              ;SUBTEST #6:  "SCD FXU"
        .BYTE   6
        .BYTE   310             ;"SCD TRAP MIX 32"

        .BYTE   1
        .BYTE   30              ;SUBTEST#7:  "SCD DIV CHK"
        .BYTE   6               
        .BYTE   250             ;"SCD TRAP MIX 33"

;SEQ369

        .BYTE   7
        .BYTE   104             ;SUBTEST #8:  "SCD TRAP MIX 34"
        .BYTE   7
        .BYTE   44              ;SUBTEST #98:  "SCD TRAP MIX 35"
        .BYTE   4
        .BYTE   220             ;SUBTEST #10:  "-CON PI CYCLE"
        .BYTE   5
        .BYTE   270             ;"-SCD PRI INSTR & EN"
                                ;(CAUSED BY INSTR ABORT)

        .BYTE   0
        .BYTE   140             ;SUBTEST #11:  "SCD TRAP CYC 1 & 2"
        .BYTE   7
        .BYTE   34              ;"SCD ADR BRK CYC & PREVENT"

        .BYTE   0
        .BYTE   220             ;SUBTEST #12:  "SCD TRAP REQS 1 & 2"
        .BYTE   5
        .BYTE   270             ;"SCD PRIVATE INSTR & EN"
        .BYTE   7
        .BYTE   214             ;"SCD ADR BRK INH & PREVENT"

        .BYTE   5
        .BYTE   270             ;SUBTEST #13:  "SCD PRIVATE INSTR & EN"
        .BYTE   7
        .BYTE   34              ;"SCD ADR BRK CYC & PREVENT"

        .BYTE   5
        .BYTE   270             ;SUBTEST #14:  "SCD PRIVATE INSTR & EN"

        .BYTE   3
        .BYTE   100             ;SUBTEST #15:  "SCD LOAD FLAGS"
        .BYTE   4
        .BYTE   240             ;"-SCD USER EN"
        .BYTE   5
        .BYTE   330             ;PUB, KERN, -PRI & -PRI EN
        .BYTE   6
        .BYTE   30              ;KERNEL OR UIOT & UIOT
        .BYTE   7
        .BYTE   100             ;TRAP MIX 34 (PUBLIC) & -TRAP CLEAR

        .BYTE   6
        .BYTE   220             ;SUBTEST #16:  UIOT & -UIOT EN


;SEQ370

        .BYTE   3
        .BYTE   100             ;SUBTEST #17:  "SCD LOAD FLAGS"
        .BYTE   4
        .BYTE   160             ;"-SCD USER" & "SCD LEAVE USER"
        .BYTE   5
        .BYTE   10              ;"SCD KERNEL MODE" (FALSE), -PUB EN & -PRI EN
        .BYTE   6
        .BYTE   40              ;TM 33 (USER), KORIOT (FALSE) & UIOT EN
        .BYTE   7
        .BYTE   0               ;-TCLR

        .BYTE   4
        .BYTE   40              ;;SUBTEST #18: "-SCD USER" & "-SCD USER EN"
        .BYTE   5
        .BYTE   130             ;PUB, -PUB EN, KERN, -PRI & -PRI EN
        .BYTE   6
        .BYTE   260             ;TM 33 UIOT EN & UIOT
        .BYTE   7
        .BYTE   104             ;TM 34


;SEQ371

        .BYTE   4
        .BYTE   360             ;SUBTEST #19:  "SCD LEAVE USER"
        .BYTE   5
        .BYTE   270             ;-PRI & -PRI EN

        .BYTE   3
        .BYTE   100             ;SUBTEST #20:  "SCD LOAD FLAGS"
        .BYTE   5
        .BYTE   130             ;PUB, -PUB EN, ERN, -PRI & PRI EN
        .BYTE   6
        .BYTE   0               ;KORIOT & UIOT  EN
        .BYTE   7
        .BYTE   100             ;-TCLR & TM 34 (PUB)

        .BYTE   4
        .BYTE   120             ;SUBTEST #21:  -USER, LEAVE, PI CYCLE
        .BYTE   5
        .BYTE   200             ;KERNEL MODE (FALSE)
        .BYTE   6
        .BYTE   0               ;KORIOT & -UIOT EN
        .BYTE   7
        .BYTE   0               ;-TRAP CLEAR


;SEQ372

        .BYTE   0
        .BYTE   10              ;SUBTEST #22:  "SCD FPD"
        .BYTE   1               
        .BYTE   220             ;"SCD OV"
        .BYTE   2               ;
        .BYTE   230             ;"VMA HELD OR PC00"
        .BYTE   3
        .BYTE   100             ;"SCD LOAD FLAGS"
        .BYTE   4
        .BYTE   360             ;LEAVE
        .BYTE   7
        .BYTE   0               ;-TRAP CLEAR

        .BYTE   1
        .BYTE  220             ;SUBTEST #23:  "SCD OV"
        .BYTE   0
        .BYTE   10              ;SUBTEST #24:  "SCD FPD"
        .BYTE   3
        .BYTE   200             ;"SCD PCP"
        .BYTE   4
        .BYTE   40              ;"-USER & "-USER EN"
        .BYTE   5
        .BYTE   200             ;KERNEL MODE 9FALSE)
        .BYTE   6
        .BYTE   10              ;KORIOT (FALSE)
        .BYTE   3
        .BYTE   200             ;SUBTEST #25:  "SCD PCP"
        .BYTE   4
        .BYTE   40              ;"-USER" & "-USER EN"
        .BYTE   5

        .BYTE   200             ;KERNEL MODE
        .BYTE   6
        .BYTE   10              ;KORIOT  (FALSE)

        .EVEN


;SEQ373

.SBTTL  *ECRA*  NEXT ADDRESS BOARD TESTS

.SBTTL TEST 34 (ECRA01):  DISP RAM TO CONTROL REG, DISP ENABLES, DISP PARITY

.REM    %
        THIS TEST IS DESIGNED TO CHECK THE DISP FIELD OF THE C-RAM
        TO THE DISPATCH/SPEC FIELD OF THE CONTROL REGISTER.  IT TESTS
        ALL BITS OF THIS SECTION OF CONTROL REGISTER AND ALSO TERSTS
        THE DISP FIELD "ENABLE GATES".
        THE TEST BEGINS BY LOADING A FIVE BIT PATTERN INTO THE DISP
        FIELD OF THE C-RAM, THIS PATTERN(PATTERN LIST IS IN TABLE "DCRA01")
        IS THEN CLOCKED TO THE CONTROL REGISTER.  THE CONTROL REGISTER
        AND DISP ENABLE GATES ARE THEN READ BACK AND VERIFIED TO BE 
        CORRECT.
%

ECRA01: PMSG<STARTING NEXT ADDRESS TESTS\>      ;PROGRAM TRACE

        UTAH0:  JSR     PC,INITSR               ;CLEAR RESET - CALL BIT
        MOV     #DCRA01,R4      ;POINTER TO TEST AND EXPECTED DATA

;SEQ373


UTAH1:  INSYNC                  ;NEXT SUBTEST (SUBTESTS 1-6)
        MOVB    (R4)+,R0        ;PASS A TEST "DISP" PATTERN
        DISP                    ;LOAD "DISP" FIELD OF $MICRO (SEE DCRA01 TABLE)
        CLR     R0              ;AT C-RAM ADR 0
        MOV     #$MICRO,R1      ;WRITE THE DATA FROM
        WCRAM                   ;BUFFER "$MICRO" & MASTER RESET
 
        ECLOK                   ;PATTERN TO CONTROL REG
        JSR     PC,TCRA01               ;GO DO ACTUAL DATA COMPARES
;RETURN HERE IF DATA OK!

UTAH2:  CMP     R5,#6           ;LOOP HERE ONLY SIX TIMES
        BLT     UTAH1           ;GO BACK IF STILL LOOPING (I.E. SUBTEST 1-6)


;SEQ374


;FALL THRU FOR SUBTEST 7
;THIS SECTION OF THE TEST DFOES NOT ATTEMPT TO TEST THE DISP
;FIELD FROM THE RESET STATE, BUT INSTEAD TRIES TO "PRESET"
;THEW DISP FIELD AND THEN LOAD A TEST PATTERN WHICH IS
;CLOCKED INTO THE "PRESET" CONTROL REGISTER AND VERIFIED TO
;       BE CORRECT

UTAH3:  INSYNC                  ;NEXT SUBTEST 9SUBTEST 7-11)
        CLR     R2              ;CLEAR A FLIP-FLOP FLAG
        JSR     PC,INITSR               ;RESET DISP FIELD & CALL BIT

UTAH4:  MOVB    (R4)+,R0        ;PUT A "PRESET" OF "TEST" PATTERN IN DISP FIELD
        DISP                    ;LOAD "DISP" FIELD OF $MICRO (SEE DCRA01 TABLE)
        MOV     #100000,R0     ;SET "NORESET" & "C-RAM ADDRESS0"
        MOV     #$MICRO,R1      ;WRITE THE DATA FROM
        WCRAM                   ;BUFFER "$MICRO" TO C-RAM

        COM     R2              ;CHANGE THE FLIP-FLOP REG, IF = -1 DOING A PRESET
        BEQ     UTAH5           ;IF =0 DOING THE TEST PATTERN
        ECLOK
        JSR     PC,TCRA01
        BR      UTAH4

;IF HERE YOU HAVE ALREADY PRESET THE FLOPS AND ARE DOING THE ACTUAAL TEST
UTAH5:  DFXCTT                  ;MUST SET MRESET FLOP
        SETMR
        ECLOK                   ;TEST DATA TO CONTROL REG
        DFXCTT
        CLRMR                   ;DOWN WITH MR RESET
        JSR     PC,TCRA01               ;GO TEST RESULTS

UTAH6:  CMP     R5,#11          ;DONE ALL 13 SUBTESTS YET?
        BLT     UTAH3           ;BR BACK IF NO
        JMP     NORMAL         ;ALL OUT IF YES


;SEQ375

;THIS IS THE ROUTINE TO READ THE CRA BOARD AND COMPARE
;ACTUAL VERSUS EXPECTED RESULTS
TCRA01: MOVB    (R4)+,EXUTAH    ;EXPECTED TO DCOMP TABLE
        MOVB    (R4)+,EXUTAH+1  ;EXPECTED TO DCOMP TABLE
        MOVB    (R4)+,EXUTAH+2  ;EXPECTED TO DECOMP TABLE

        DCOMP
        .WORD   MXUTAH          ;TABLE OF MASKS
        .WORD   DFUTAH          ;TABLE OF DISAGNOSTIC FUNCTIONS
        .WORD   BPUTAH          ;TABLE OF BYE POINTERS
        .WORD   EXUTAH          ;TABLE OF EXPECTED DATA
        .WORD   0               ;ERROR MSG FROM ISOLATION
        RTS     PC

MXUTAH: .BYTE   340,317         ;MASKS FOR DCOMP READ 1 & 2
        .BYTE   337                     ;MASK FOR DECOMP READ 3
DFUTAH: .BYTE   RCRA+1,RCRA     ;DIAGNOSTIC FUNCTION  #1 & #2
        .BYTE   RCRA+3!BIT7     ;DIAG FUNCT #3
BPUTAH: BYTPNT  5               ;BYPOINTERS FOR READ 1

        BYTPNT  5               ;FOR RED 2
        BYTPNT  5               ;FOR READ 
EXUTAH: .BYTE   0,0             ;A PLACE FOR 2 BYTES OF EXPECTED DATA
        .BYTE  0                       ;A PLACE FOR 1 BYTE OF EXPECTED DATA
        .EVEN


;SEQ376

.REM    %
        HERE IS THE TEST DATA AND PRESET DATA TABLE FOR THIS TEST.
        IT IS ATTEMPTING TO TEST THE 3 SHIFT REGISTERS AND THE
        PARITY CHIP FOUND ON THE CONTROL RAM ADDRESS, BOARD, PRINT "XCRA3"
        THE COMMENTS FOUND WITH THTE DATA BELOW FOR EACH SUBTEST
        TEUS WHAT SHIFT REGISTER CONTROL FUNCTION SHOULD HAVE BEEN, WHAT THE
        INPUT DATA TO THE FLOPS SHOULD HAVE BEEN AND WHAT DATA WAS EXPECTED
        OUT.
POSSIBLE FAILUES:  THE SHIFT REGISTER DIPS, THE NAND GATES FEEDING THE SHIFT
        REGISTER DIP, THE DISP PARITY CHIP, CRA CLK LINE TO THE DIPS, OR
        THE MULTIPLEXERS (AND LINE TO THEM) FEEDING THE TEST DATA TO THE EBUS (PRINT XCR
        ALSO THE DIAG LINES ONTO THE CRA BOARD.
%

;***********************************************************************************
DCRA01:         ;DISP DATA      DISP EXPECTED   DISP ENABLES EXPECTED   REG FUNC
;***********************************************************************************

;SUBTEST 1,     NO PRESET
                .BYTE  0,           40,         10,     40              ;00 (LOA

;SUBTEST 2,     NO PRESET
                .BYTE   10,         10,         70,     40              ;00 (LOA

;SUBTEST 3,     NO PRESET
                .BYTE   20,         20,         70,     40              ;00 (LOAA

;SUBTEST 4,     NO PRESET
                .BYTE   30,        30,          60,     00              ;00 (LOA

;SUBTEST 5,     NO PRESET
                .BYTE   3,          3,          13,     40              ;00 (LOA

;SUBTEST 6,     NO PRESET
                .BYTE   4,          4,          34,     40              ;00 (LOA

;SUBTEST 7,     PRESET
                .BYTE   30,             30,     60,     00              ;00 (LOA
;               *TEST*-----THE SHIFT 3 IN FORCES "DISP RESET PARITY H"
                .BYTE   0,          20,         50,     00              ;00 (SHI

;SUBTEST 10,    PRESET
                .BYTE   7,          7,          37,     40              ;00 (LOA
                ;*TEST*
                .BYTE   0,          17,         32,     00              ;10 (SHI

;SUBTEST 11,    PRESET
                .BYTE   10,         10,         70,     40
                ;*TEST*-------THE SHIFT 3 IN FORCES "DISP RESET PARITY H"
                .BYTE   0,          20,         50,     00

;SEQ377

.SBTTL TEST 35 (ECRA02):  DISPATCH CODES 1,2,3 & 6 AND ALSO "AREAD" LOGIC

.REM    %
        THIS TEST CHECKS DISP FIELD DISPATCH CODES 1,2,3 & 6.  IT 
        ASSURES THAT WHEN THESE CODES ARE SELECTED.  THE APPROPRIATE
        DATA IS MULTIPLEXED INTO THE C-RAM ADDRESS.  FOR DISPATCH
        CODE 1, WE GET "D-RAM J".  FOR CODE 2, WE GET "AREAD".  FOR CODE 3
WE GET "SBR RET". AND FOR CODE 6 WE GET "CTL NICOND".  WHEN
        CHECKING CODE 2 AND "AREAD", THE TEST ALSO RUNS A SELECTION
        OF PATTERNS THRU THE AREAD NETWORK TO ASSURE THAT IT IS IN
        GOOD CONDITION.
        THE BASIC TEST PROCDURE IS TO LOAD THE DISP FIELD WITH

        DISPATCH CODE UNDER TEST.  NEXT THE D-RAM J FIELD IS LOADED 
WITH A TEST PATTERN (IF CHECKING CODE 1) OR THE COMPLIMENT OF THE
EXPECTED DATA.THE DIAGNOSTIC ADDRESS REGISTER IS ALSO LOADED WITH
        THE COMPLIMENT OF THE EXPECTED DATA.  FINALLY WE READ THE
        C-RAM ADDRESS TO BE SURE THE DISPATCH CODE IS SELECTING WHAT WE
        EXPECT.
%
ECRA02: MOV     #10,R3          ;NUMBER OF TIMES THRU BASIC LOOP = 6
        MOV     #DCRA02,R4              ;SET UP POINTER TO DATA


PENN1:  INSYNC                  ;NEXT SUBTEST (1-7)
        MOVB    (R4)+,R0        ;GET THE DISPATCH CODE UNDER TEST
        DISP                    ;AND PUT IN DISP FIELD OF $MICRO

        CLR     R0              ;RESET MACHINE AT DIAG ADR 0
        MOV     #$MICRO,R1      ;LOAD C-RAM WITH $MICRO BUFFER OF DATA
        WCRAM                   ;ALL WITH THIS EMT
        ECLOK

;NEXT LOAD THE D-RAM A,B & J FIELDS AT THE CURRENTLY ADDRESSED D-RAM LOCATION
        JSR     PC,GLOWRM               ;DATA TO DRAM WITH NO CLOCKING OF EBOX
        CLR     DLINKR


        MOV     #DLINKR,R0      ;GET POINTER TO DATA
        MOVB    -1(R4),1(R0)    ;GET UPPER HALF OF EXPECTED
        ASR     (R0)
        ASR     (R0)
        BISB    -3(R4),(R0)     ;GET LOWER HALF OF EXPECTED
        MOV     (R0),R0         ;GET EXPECTED AS A WORD
        COM     R0              ;COMPLIMENT EXPECTED
        BIS     #BIT15,R0       ;SAY NO RESET
        WWADR                   ;AND WRITE IT TO DIAG ADR REG


;SEQ378

;NOW READY TO TEST RESULTS OF THE DISPATCH CODE SELECTS
        MOVB    (R4)+,EXPENN    ;PASS EXPECTED J7-J10 TO DCOMP
        MOVB    (R4)+,EXPENN+1  ;PASS EXPECTED J1-J4 TO DCOMP

        DCOMP
        .WORD   MXPENN          ;TABLE OF MASKS
        .WORD   DFPENN          ;TABLE OF DIAGNOSTIC FUNCTIONS
        .WORD   BPPENN          ;TABLE OF BYTE POINTERS
        .WORD   EXPENN         ;TABLE OF EXPECTED DATA
        .WORD   0               ;ERROR MSG FROM ISOLATION

;TESTED OK IF GOT TO HERE
        DEC     R3              ;DOWN COUNT
        BGT     PENN1           ;BACK IF STILL STUBTESTS 1-10
        BLT     PENN5           ;BR OUT IFGREATER THAN SUBTEST 7

;FALL THROUGH TO HERE ON SUBTEST 11 ONLY -LOAD D-RAM J
;AND DIAG ADR REG WITH CMPLIMENT OF SBR RET REG -FIRST READ "SBR RET REG"

        JSR     PC,CLRSTK               ;CLEAR THE SBR STACK, CLR DIAG REG
        MOV     #RCRA+3,R0      ;DIAG FUNCTION FOR SBR RET REG
        CRADRD                  ;READ THE CRA BOARD -RESULT RETURNED IN R0
        BIC     #004000,R0      ;CLEAR OUT UNWANTED BIT (-CRA DISPEN 30-37)
        PUSH    R0              ;SAVE WHAT WAS READ

        MOVB    R0,PENN3+3      ;PUT J7-J10 IN "EXPECTED"
        ASL     R0
        ASL     R0
        SWAB    R0              ;NOW GET J1-J4
        MOVB    R0,PENN3+4      ;PUT IN PLACE FOR EXPECTED
        POP     R0              ;RESTORE FOR NEXT STEP

        COM     R0              ;NOW COMPLIMENT
        BIC     #176000,R0      ;CLEAR UNUSED PORTION
        MOVB    R0,PENN3        ;THIS CODE CREATES
        SWAB    R0              ;INTERFERENCE PATTERNS
        ASR     R0              ;TO BE LOADED INTO THE
        ASR     R0              ;DRAM
        MOVB    R0,PENN3+2      ;WHEN CHECKING THE SUBR RET REG
        BR      PENN1
PENN5:  JMP     NORMAL

MXPENN: .BYTE   340,300         ;MASKF FOR DF READ 1, AND 2
        DFPENN: .BYTE   RCRA+5,RCRA+4!BIT7      ;DIAG FUNCTIONS FOR READ 1 & 2

BPPENN: BYTPNT  5                       ;SEAD 1 BYTE POINTER
        BYTPNT  5               ;READ 2 BYTE POINTER
EXPENN: .BYTE   0,      0,              ;TWO SLOTS FOR EXPECTED DATA 9SEE DCRA02)


;SEQ379

.REM    %
        HERE IS THE TEST AND EXPECTED DATA FOR THIS TEST.
        IT IS ATTEMPTING TO CHECK THE SELECT LINES TO THE
        2 BY 4 MIXERS ON CONTROL RAM ADDRESS BOARD, PRINT "CRA1"
        AND THE 8 WAY MIXERS IN THE MIDDLE OF PRINT "CRA2"
        IT ALSO TESTS THE "AREAD" LOGIC, LEFT CENTER PRINT "CRA3"
POSSIBLE FAILURS:  THE PREVIOUSLY MENTIONED MIXERS.  SELECT LINES TO THESE
        MIXERS.  THE AREAD LOGIC (CRA3,LEFT CENTER).  BACKPLAN, FROM THE
        DRAM A,B OR J FIELD TO THIS BOARD.  BACKPLAN, FROM THE
        CTL NICOND      LINES TO THIS BOARD 9SUBTEST 7 ONLY).  THE DIAGNOSTIC MIXERS (CRA4,BOT
        OR THE DIAG LINES ONTO THIS BOARD.
%
DCRA02:

;SUBTEST 1
        .BYTE   1               ;DISPATCH CODE 1 (D-RAM J)
        DRMPAT  2,0,375         ;D-RAM ALL ONES (A=2 TURNS OFF D-RAM THRU AREAD)

        EXCRAD  1715            ;EXPECT CR-ADR

;SUBTEST 2
        .BYTE   1               ;DISPTCH CODE 1 (D-RAM J)
        DRMPAT  0,0,2           ;D-RAM ALL ZEROES (A=0 TURNS ON D-RAM THRU AREAD)
        EXCRAD  2               ;EXPECTED AT CR-ADR

;SUBTEST 3
        .BYTE   2               ;DISPATCH CODE 2 (AREAD)
        DRMPAT  1,0,20          ;AREAD AT CR-ADR
        EXCRAD  100             ;EXPECTED AT CR-ADR

;SUBTEST 4
        .BYTE   2               ;DISPATCH CODE 2 (AREAD)
        DRMPAT  0,0,357 ;AREAD LOGIC TEST

        EXCRAD  1617            ;EXPECTED AT CR-ADR


;SEQ380

;SUBTEST        5               ;DISPATCH CODE 2 (AEAD)
        .BYTE   2                       ;AREAD LOGIC TEST
        DRMPAT  7,0,30

        EXCRAD  7               ;EXPECTED AT CR-ADR

;SUBTEST        6
        .BYTE   2               ;DISPATCH CODE 2 (AREAD)
        DRMPAT  3,0,0           ;AREAD LOGIC TEST
        EXCRAD  3               ;EXPECTED AT CR-ADR

;SUBTEST 7
        .BYTE   10              ;DISPATCH CODE 10 ONLY C-RAM J FIELD ENABLED)
        DRMPAT  0,0,0           ;TWESTING ENABLE LINE
        EXCRAD  0               ;DIAG ADR(SET TO 1'S) MUST BE DISABLED

;SUBTEST 8
        .BYTE   6               ;DISPATCH CODE 6 (CTL NICOND)
        DRMPAT  0,0,377         ;NICOND RESET STATE =0'S.  DRAM ITNERFERENCE=1'S.
        EXCRAD   2               ;EXPECT NICOND RESET STATE SELECTED

;SUBTEST        9
        .BYTE   3               ;DISPTACH CODE 3 (SBR RET REGJ)
PENN3:  DRMPAT  0,0,0           ;IN LINE CODE FILLS IN AN INTERFERENCE PATTERN HERE

        EXCRAD  0               ;AND FILLS IN EXPECTED HERE
        .EVEN


;SEQ381


.SBTTL TEST 36 (ECRA03):  DISPATCH CODES 30,32,33 AND 35.  ALSO "NORM LOGIC

.REM    %
        THIS TEST IS DESIGNED TO CHECK THE CONTROL RAM ADDRESS BOARD
        DISPATCH CODES 30(MQ).  32(AR,BR,AD SIGNS), 33(D-RAM B, AND
35(NORM LOGIC).  IT  ALSO TESTS THE NORM LOGIC PRIORITY ENCODER FOUND
ON THE IR/DRAM BOARD.
THE BASIC TEST PROCEDURE IS TO LOAD THE DISPATCH CODE INTO THE
C-RAM.  IF WE ARE CHECKING DISPATCH CODE 33 WHICH REQUIRES D-RAM
DATA, WE WILL  CLOCK THE MICRO WORD JUST LOADED INTO THE C-RAM INTO
THE CONROL REGISTER THEN LOAD THE APPRPRIATE D-RAM DATA AND 
TEST THE C-RAM ADDRESS TO VERIFY THAT IT IS CORRECT.  IF THE SUBTEST
DOES NOT REQUIRE D-RAM DATA, THEN WE LOAD THE AR WITH TEST DATA
AND AT THE SAME TIME LOAD OUR C-RAM DISPATCH DATA TO THE CONTROL
REGISTER.  WE THEN TEST THE C-RAM ADDRESS FOR CORR3ECTNESS.
%
ECRA03: MOV     #DCRA03,R4      ;LOAD PTR TO TEST & EXPECTED DATA
        MOV     #4,R2           ;LOAD COUNTER FOR # OF D-RAM LOADS

SDAK1:INSYNC                    ;NEXT SUBTEST (1-21)
        MOVB    (R4)+,R0        ;GET DISPATCH CODE
        DISP                    ;TO $MICRO BUFFER
        CLR     R0              ;C-RAM ADDRESS 0
        MOV     #$MICRO,R1      ;WRITE BUFFER $MICRO
        WCRAM                   ;TO THE C-RAM

        DEC     R2              ;DOING A D-RAM LOAD?
        BMI     SDAK2           ;BRANCH IF NO

;HERE IF YES-DOING A D-RAM LOAD
        ECLOK                   ;PROPER C.R. CONTENTS
                                ;NEXT WRITE THE D-RAM DATA
        JSR     PC,GLOWRM               ;DATA TO DRAM WITH NO ECLOCKING
        BR      TCRA03          ;CONTINUE
;HERE IF NOT WRITING D-RAM, BUT YES-WRITING AR
SDAK2:  MOV     R4,R1           ;GET ADDRESS OF 36-BIT DATA FOR AR
        ARLODE                  ;WRITE AR AND CHECK TEST DISPATCH TO C.R.
        ECLOK                   ;LOAD C.R.
        ADD     #5,R4           ;UPDATE PAST WD36 DATA


;SEQ382

;TESTING ROUTINE
TCRA03: MOVB    (R4)+,EXSDAK    ;EXPECTED TO DCOMP TABLE
        MOVB    (R4)+,EXSDAK+1  ;EXPECTED TO DCOMP TABLE
        MOVB    #300,MXSDAK+1   ;SET UP MASK
        CMP     R5,#4           ;SUBTEST 4??
        BNE     SDAK3           ;BR IF NO
        MOVB    #302,MXSDAK+1   ;CHANGE MASK IF YES

SDAK3:  DCOMP
        .WORD   MXSDAK          ;TABLE OF MASKS
        .WORD   DFSDAK          ;TABLE OF DIAGNOSTIC FUNCTIONS
        .WORD   BPSDAK          ;TABLE OF BYTE POINTERS
        .WORD   EXSDAK          ;TABLE OF EXPECTED DATA
        .WORD   0               ;ERROR MSG FROM ISOLATION
        CMP     R5,#^D21                ;DONE ALL SUBTESTS??
        BLT     SDAK1           ;BACK TO LOOP
        JMP     NORMAL

MXSDAK: .BYTE   340,300         ;AMSKS FOR DCOMP READS 1&2
DFSDAK: .BYTE   RCRA+5,RCRA+4!BIT7      ;DIAGNOSTIC FUNCTION #1 & #2
BPSDAK: BYTPNT  5               ;BYTE POINTER FOR READ 1
        BYTPNT  5               ;BYTE POINTER FOR READ 2
EXSDAK: .BYTE   0,0             ;A PLACE FOR 2 BYTES OF EXPECTED


;SEQ383


.REM    %
        HERE IS THE TEST DATA (TO BE LOADED TO D-RAM OR AR) AND
        EXPECTED DATA FOR THIS TEST.  THE TEST IS ATTEMPTING TO
        VERIFY THE SELECT LINES AND SEVERAL DATA LINES FOR THE 3
        MIXERS ON PRINT "XCRA2", CENTER BOTTOM.  IT ALSO TESTS

        THE NORM LOGIC ON IR/DRAM PRINT IR3.  THIS INCLUDES
        THE TWO "OR" GATES FEEDING THE PRIORITY ENCODER INPUTS D2&D7.
POSSIBLE FAILURES:  SELEECT LINES TO THE 3 EIGHT-WAY MIXERS, PRINT XCRA2, BOTTOM CENTER
        DATA LINES FOR DISPATCH CODES SELECTED STUCK AT ONE OR ZERO (DISPATCH
        CODES 30,32,33,35).  BACKPLANE NORM LINES FROM IR3 TO CRA BOARD.
        BACKPLANE ENCODER ON IR3 OR EITHER OF THE "OR" GATES FEEDING THE
        "NORM" PRIORITY ENCODER.
%
DCRA03:
;SUBTEST 1
        .BYTE   20              ;DISPATCH CODE 20(30-37 DISABLED)
        DRMPAT  7,7,357         ;DRAM DATA ALL 1'S FOR INTERFERENCE

        EXCRAD  0               ;EXPECT ALL DISPATCHES DISABLED

;SUBTEST 2
        .BYTE   30              ;DISPATCH CODE 30(MQ34,35)
        DRMPAT  0,0,0           ;DRAM 0S
        EXCRAD  3               ;EXPECT MQ 34,MQ 35 COME THROUGH

;SUBTEST 3
        .BYTE   33              ;DISPATCH CODE 33(DRAM B)
        DRMPAT  0,7,0           ;SELECT "B' FIELD ALL 1'S
        EXCRAD  7               ;EXPECT "B" FIELD ONES TO BE SELECTED

;SUBTEST 4
        .BYTE   33              ;DISPATCH CODE 33(DRAM B)
        DRMPAT  0,0,0           ;SELECT "B" FIELD ZEROES

        EXCRAD  0               ;EXPECT 0'S SELECTED

;SUBTEST 5
        .BYTE   32
        WD36    4000,0000,0000  ;SET AR00 AND AD00
        EXCRAD  5               ;EXPECT THEM SELEECTED

;SUBTEST 6
        .BYTE   32              ;DISPATCH CODE 32 (AR,BR AD SIGNS)
        WD36    0,0,0           ;AR00 AND AD00 SET TO 0
        EXCRAD  0               ;EXPECT THEM SELECTED


;SEQ384

;SBUTEST 7
        .BYTE   35              ;DISPATCH CODE 35(NORM LOGIC)
        WD36    0,0,0           ;NORM LOGIC TEST
        EXCRAD  0               ;EXPECT


;SEQ385

;SUBTEST        8
        .BYTE   35              ;DISPATCH CODE 35 (NORM LOGIC)
        WD36    4002,0000,0000  ;NORM LOGIC TEST
        EXCRAD  1               ;EXPECT

;SUBTEST        9
        .BYTE   35              ;DISPATCH CODE 35(NORM LOGIC)
        WD36    0044,0000,0000  ;NORM LOGIC TEST
        EXCRAD  2               ;EXPECTED

;SUBTEST 10
        .BYTE   35              ;DISPATCH CODE 35(NORM LOGIC)
        WD36    2000,0000,0000  ;NORM LOGIC TEST
        EXCRAD  2               ;EXPECTED

;SUBTEST 11
        .BYTE   35              ;DISPATCH CODE 35(NORM LOGIC)
        WD36    022,0000,0000   ;NORM LOGIC TEST
        EXCRAD  3               ;EXPECTED

;SUBTEST 12
        .BYTE   35              ;DISPATCH CODE 35 NORM LOGIC
        WD36    0010,0000,0000  ;NORM LOGIC TEST
        EXCRAD  4               ;EXPECTED

;SUBTEST 13
        .BYTE   35              ;DISPATCH CODE 35(NORM LOGIC)
        WD36    0010,0000,0001  ;NORM LOGIC TEST
        EXCRAD  4               ;EXPECTED

;SUBTEST 16

;SUBTEST 14
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0006,0000,0000  ;NORM LOGIC TEST
        EXCRAD  5               ;EXPECTED

;SUBTEST 15
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0002,0000,0000  ;NORM LOGIC TEST
        EXCRAD  6               ;EXPECTED

;SUBTEST 16
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0002,0000,0002  ;NORM LOGIC TEST
        EXCRAD  6               ;EXPECTED


;SEQ386

;SUBTEST 17             
        .BYTE   35              ;DISPATCH CODE 35(NORM)

        WD36    0000,0000,0002  ;NORM LOGIC TEST
        EXCRAD  7               ;EXPECTED

;SUBTEST 18
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0000,0000,0100  ;NORM LOGIC TEST
        EXCRAD  7               ;EXPECTED

;SUBTEST 19
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0000,0001,0000  ;NORM LOGIC TEST
        EXCRAD  7               ;EXPECTED

;SUBTEST 20
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0000,0100,0000  ;NORM LOGIC TEST
        EXCRAD  7               ;EXPECTED

;SUBTEST 21
        .BYTE   35              ;DISPATCH CODE 35(NORM)
        WD36    0001,0000,0000  ;NORM LOGIC TEST
        EXCRAD  7               ;EXPECTED
        .EVEN


;SEQ387


.SBTTL TEST 37 (ECRA04):  J-FIELD AND CRA LOC REGISTER TEST..EXECUTED AT BURST SPEED

.REM    %
        THIS TEST IS DESIGNED TO CHECK THE CONTROL RAM ADDRESS BOARD
        J-FIELD TO CR ADR LINES AND TO TEST THE CR ADR TO CRA LOC
        REGISTER LKINES AND TO TEST THE CRA LOC REGISTER ITSELF.  ALL AT
        BURST SPEED (FULL SPEED AT THE CURRENTLY SELECTED CLOCKRAE USING THE
        BURST COUNTER)
        THE BASIC TEST PROCEDURE IS TO LOAD THE J-FIELD TEST OATTERN
        INTO THE J-FIELD OF C-RAM LOCATION ZERO, ALL OTHER BITS

        AT KLOCATION ZERO LEFT AT 0 (EXCEPT FOR A DISPATCH CODE = 10).
        THE C-RAM LOCATION WHICH WOULD BE ARESSED BY THE CURRENT TEST PATTERN IS

        THEN LOADED WITH ALL ONES.  NEXT WE SET
        THE CURRENT C-RAM ADDRESS TO ZERO.  FINALLY WE GIVE A
        BURST OF CLOCK TICS TO CAUSE 2 EBOX CLOCKS.  THIS SHOULD
        FORCE THE J-FIELD TEST PATTERN INTO THE CONTROL REGISTER
        (ON THE FIRST EBOX CLOCK). AND ON THE SECOND EBOC CLOCK THE
        ALL ONES RAM WORD SHOULD BE ADDRESSED AND LOADED INTO THE
        CONTROL REGISTER.  ALSO THE CRA LOC REGISTER SHOULD BE LOADED
        WITH THE J-FIELD TEST PATTERN.  NOW,    F THE CONTROL REGISTER
        IS NOT ALL ONES.  WE HAVE HAD A J-FIELD HARDWARE ERROR, IF THE CRA LOC
        IS NOT ALL ONES, WE HAVE HAD A J-FIELD HARDWARE FAILURE .
%
;FIRST CREAT AN 80-BIT EXPECTED OF ALL ONES

ECRA04: MOV     #^D12,R2                ;SET THIS MANY BYTES
        MOV     #EWORD1,R1              ;STARTING HERE
        MOV     #177777,R0              ;ALL ONES DATA
WIS0:   MOVB    R0,(R1)+        ;ROLL 'EM
        DEC     R2              ;COUNT EM
        BGT     WIS0                    ;LOOP 'EM
        MOV     #10,R0          ;PUT NO P IN DISPATCH FIELD OF $MICRO
        DISP
WIS1:   INSYNC                  ;NEXT SUBTEST (1-1280)
        MOV     R5,$$CRAD               ;TELL THE "CHECK MICRO" ROUTINE THE ADDRESS
        MOV     R5,R0           
        J                               ;AND NOW WRITE IT TO $MICRO BUFFER J-FIELD


;SEQ388


        MOV     #1,R1           ;WRITE ONE RAM WORD
        MOV     R5,R0           ;AT THIS RAM ADDRESS
        MICFIL                  ;ALL ONES
        CLR     R0              ;FINALLY, WRITE BUFFER $MICRO
        MOV     #$MICRO,R1      ;AT C-RAM ADDRESS 0
        WCRAM
        EBURST 2                ;GIVE BURST OF 2 EBOX CLOCKS
;NOW READY TO TEST CRA LOC REGISTER
        MOV     #RCRA+7,R0      ;GET DIAGNOSTIC FUNCTION FOR CRA LOC READ
        CRADRD                  ;READ THE CRA BOARD, RESULTS 11 BITS RIGHT JUSTIFIED IN
        CMP     R5,R0           ;DATA IN CRA LOC REGISTER OK?
        BEQ     WIS3            ;BR IF YES
        
;HERE IS CRA LOC REGISTER HAS BAD DATA
        PUSH    R0              ;SAVE CRA LOC DATA

        ERRMSG<\CRA LOC REGISTER CONTAINS BAD DATA>

        MOV     ERSP..,R2       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R2)+    ;FORMAT TYPE
        MOV     #174000,(R2)+   ;STACK MASK
        MOV     R0,(R2)+        ;STACK ACTUAL
        MOV     R5,(R2)+        ;STACK EXPECTED
        MOV     R2,ERSP..       ;RETURN ERROR STACK
        MOV     #177777,ERRLVL ;SET AN ERROR FLAG


;SEQ389

;WHEN HERE IT IS TIME TO CHECK THE CONTROL REGISTER TO SEE IF A BIT WAS
;DROPPED BY THE J-FIELD.  IF THE CRA LOC REGISTER JUST HAD BAD DATA
;THERE WAS TWO POSSIBILITIES.  ONE:  THE CRA LOC REGISTER IS BAD OR TWO: THE
;J-FIELD WAS BAD THRU THE CR ADR LINES WHICH INPUT THE CRA LOC REGISTER
;NOW READY TO CHECK
WIS3:   $SETWD                  ;EWORD1 MUST BE ALL ONES
        MOVB    #377,EWORD1+4   ;EWORD1 ALL ONES WAS MESSED UP BY CRADRD
        MOV     #100000,R0      ;RCRAM MUST READ CURRENT C.R. CONTENTS
        RCRAM                   ;R0 ALREADY HAS A MINUS SIGN TO READ ON C.R.

        CHKMIC                  ;R0 NOW CONTIAN DDRESS OF ACTUAL RECEIVED
        .WORD   EWORD1          ;ADDRESS OF EXPECTED
        .WORD   0               ;ERROR MSG FROM ISOLATION

;CAME BACK OK HERE--MUST CHECK IF EARLIER CRA LOC REGISTER FOUND ERROR
        TST     ERRLVL          ;ERR SET
        BEQ     WIS5            ;OR IF NO ERR
        JSR     PC,FAULT
        .WORD   0               ;ERROR MSG FROM ISOLATION

;WHERE IF WHOLE TEST WAS OK
WIS5:   MOV     #1,R1           ;ONE WORD
        MOV     R5,R0           ;MUST BE RETURNED TO
        MICNUL                  ;ITS ALL ZERO STATE 
        CMP     R5,#2377                ;DONE ALL SUBTESTS?
        BLT     WIS1            ;BR IF NO
        JMP     NORMAL          ;OUT IF YES


;SEQ390


.SBTTL TEST 38 (ECALL1):  MICROCODE SUBROUTINE STACK FORWRD SEQUENCING TEST

.REM    %

THIS TEST VERIFIES THAT THE DUAL SHIFT REGISTER WITH ITS
ASSOCIATED INPUT GATING CAN BE RESET TO A KNOWN STATE, AND THEN
SEQUENCED THRU ITS 15 DECIMAL PRESET STATES, BY PERFORMING A
SERIES OF CALLS (SEE PRINT CRA4).  FOR EACH CLL THE EBOX CLOCK
IS PUSHED HI, THE RESULT CHECKED, THEN PULSED LOW AND TEH RESULT
CHECKED.  THIS ASSURES THAT THE 4X2 MIXER (ON PRINT CRA40) DOES
NOT  MIS-SELECT AN ADDRESS.
%

ECALL:
ECALL1: PMSG    <STARTING MICROCODE SUBROUTINE STACK TESTING\>
        MOV     #SHI,R3         ;R3 POINTS TO 1ST BYTE OF COMPARE TABLE

;VERIFY THAT A MASTR RESET CAN INITIALIZE THE CRA STACK ADDRESS

;GENERATOR TO THE PROPER STATE AND VERIFY THAT BRINGUING THE EBOX
;CLOCK HIGH AND LOW WILL NOT SWITCH THE SELECT INPUT TO THE 4X2 MIXER
;FEEDING THE RAM LON LOGIC "CRA4".

        JSR     PC,INITSX               ;INITIALIZE CRAM REG,SBR RET LOGIC ETC.

        MOV     #IDO,R2         ;BASE ADDRESS OF EXPECTED DATA
        MOV     #1,R0           ;1 MBOX CLOCK
TAICHO: JSR     PC,TAICH2               ;DO DIAG READ AND CHECKING 9SUBTEST #1)
        BURST                   ;GIVE LEADING EDGE OF EBOX CLOCK
        MOV     #1,R0
        ADD     #2,R2           ;UPDATE TO NEXT PATTERN
        JSR     PC,TAICH2       ;DO DIAG READ AND CHECKING (SUBTEST #2)
        BURST                   ;GIVE TRAILING EDGE OF EBOX CLOCK
        JSR     PC,TAICH2               ;DO DIAG READ AND CHECKING (SUBTEST #3)


;SEQ391

;PERFORM REQUIRED CALLS TO TEST REST OF CRA STACK ADR 10,04,02,01.

TAICH1: MOV     #^D14,R1        ;COUNT FOR 13 DECIMAL ITERATIONS
        MOV     #EACAL,R4       ;PUT CALL FIELD VALUE IN R4
        JSR     PC,SEPAI        ;BUILD A TWO MICRO-INSTR LOOP
                                ;AND LOAD THE FIRST MICRO-INSTRUCTION (EACALL)

TAICH:  MOV     #1,R0           
        JSR     PC,TAICH2       ;PERFORM DIAG READ AND CHECKING (SUBTEST #4)

        BURST                   ;EXECUTE CALL MICRO-INSTRUCTION
        ADD     #2,R2           ;UPDATE TO NEXT PATTERN
        MOV     #1,R0
        JSR     PC,TAICH2               ;DO DIAG READ AND CHECKING 9SUBTEST #5)
        BURST
        DEC     R1              ;SUBTRACT 1 FROM COUNT
        TST     R1              ;SEE IF DOEN 13 DECIMAL ITERATIONS
        BNE     TAICH           ;BRANCH IF NO 9SUBTESTS #6-14)
        JMP     NORMAL         ;DO NEXT TEST (ECALL2)
TAICH2: MOV     (R2),(R3)       ;PUT TEST PATTERN IN EXPECTED DATA TABLE
TAICH3: PUSH    R0
        INSYNC
        ASL     (R3)            ;SHIFT TWICE TO ALLIGN DATA FOR CRA
        ASL     (R3)            ;STACK BITS 10,04,02,01 IN UPPER
                                ;EXPECTED DATA BYTE.
        CLRB    (R3)            ;CLEAR LOW BYTE

        DCOMP                   ;PERFORM BYTE COMPARE
        .WORD   ICHI            ;PTR TO MASK TABLE
        .WORD   NI              ;PTR TO FUNCTION TABLE
        .WORD   SAN             ;PTR TO BYTE TABLE
        .WORD   SHI+1           ;PTR TO EXPECTED DATA TABLE(BYTE)
        .WORD   0               ;NO ERROR MSG FROM MAIN LINE

        POP     R0              ;RESTORE R0
        RTS     PC              ;RETURN TO CALLER

;JUST GIVE THE CLOCK BURST TO PERFORM THE MICRO-CODE LOOP


;SEQ392

.SBTTL TEST 39 (ECALL2):  MICROCODE SUBROUTINE STACK RETURN SEQUENCING TEST

.REM    %
        THIS TEST VERIFIES THAT THE SAME LOGIC CAN BE SEQUENCED
BACK FROM ITS LAST PRESET ADDRESS, TO ITS STATE AFTER THE FIRST CALL
WAS PERFORMED IN TEST (ECALL1). E.G. FROM BCDE=1110,DEFG=1000, TO
BCDE=1111,DEFG=1100 (SEE PRINT CRA4).
        THE TEST PERFORMS A SERIES OF SUBROUTINE RETURNS TO VERIFY
THAT FOLLOWING A MAST ER RESET, THE PREVIUSLY SETUP STACK (ECALL1)
CAN BE 'POPPED" ONE LOCATION AT A TIME, THE CRA STACK ADDRESS GEN-
ERATOR IS SEQUENCED BACKWARD FROM THE RESET STATE, AND WE THAN
VERIFY THAT BRINGING THE EBOX CLOCK HI WILL NOT SWITCH THE SELECT
INPUT TO THE 4X2 MIXER FEEDING THE RAM ILLUSTRATED ON PRINT (CRA4).
SIMILARLY WE VERIFY THAT BRINGING THE EBOX CLOCK LOW WILL SWITCH
THE SELECT INPUT O THE 4X2 MIXER.
%

ECALL2: JSR     PC,INITSX               ;MRESET,CLR CRAM LOC 0, CLR DIAG REG
        MOV     #IDO,R2         ;PUT TABLE BASE ADDRESS IN R2
        MOV    #^D7,R1         ;
        MOV     #EACAL,R4
        JSR     PC,SEPAI                ;GIVE POPER # OF CLOCKS
TAIC3A: EBURST 2
        DEC     R1
        TST     R1              ;SEE IF DONE REQUIRED # OF CLOCKS
        BNE     TAIC3A          ;BRANCH IF NOT DONE

        CLR$M                   ;CLEAR 12-BYTE MICRO WORD IN PDP-11 CORE
        MOV     #$MICRO,R1      ;MOVE ADDRESS OF MICRO BUFFER INTO R1
        MOV     #1600,R0                ;THJIS IS THE ADDRESS WE WILL USE!
        BIS     #BIT15,R0       ;NO MRESET THOUGH...
        WCRAM                   ;NOW WRITE IT!
        ECLOK                   ;LOAD IT!
        JSR     PC,BOKEN7       ;WRITE MICRO WORD INTO PATTERN LOCATION
        ECLOK                   ;LOAD CRAM REGISTER WITH IT!
        MOV     #IDO+<<^D15>*2>,R2      ;NOW SETUP BURST AND CHECKING
        MOV     #SHI,R3
        MOV     #^D16,R1


;SEQ393

TAIC4A: MOV     #1,R0
        BURST
        MOV     #1,R0
        JSR     PC,TAICH2       ;(SUBTEST #1)
        BURST
        MOV     (R2),(R3)       
        BIC     #1400,(R3)      ;CLEAR OUT BITS 09-08!
        ASL     (R3)
        ASL     (R3)            ;SHIFT INTO POSITION
        MOV     #1,R0
        JSR     PC,TAICH3               ;PERFORM DIAG READ AND CHECKING 9SUBTEST #2)
        SUB     #2,R2           ;UPDATE TO NEXT PATTERN
        DEC     R1              ;SUBTERACT 1 FROM COUNT

        BNE     TAIC4A          ;BRANCH IF NO!  (SUBTESTS #3-14)
        JMP     NORMAL          ;GO TO NEXT TEST (ECALL3)

BOKEN7: MOV     #RETURN,R0              ;RETURN FIELD VALUE TO R0
        DISP            ;NOW PUT THE VALUE INTO $MICRO
        CLR     R0              
        $EACAL                  ;AND PUT A ZERO FOR EACALL INTO $MICRO
        CLR     R0
        J                       ;AND ALSO Z ERO FOR J INTO $MICRO
        MOV     (R2),R0 ;PUT THE PATTERN INTO R0
        BIS     #BIT15,R0       ;NO MRESET THOUGH...
        MOV     #$MICRO,R1      ;PUT ADDRESS OF $MICRO INTO R1
        WCRAM                   ;WRITE CONTENTS OF $MICRO @ R0
        RTS     PC              ;RETURN TO CALLER

;COMPARISON TABLES FOR THIS TEST

        ICHI:   .BYTE   360             ;LEFT FOUR BITS(CRA STACK 10,04,02,01)
        NI:     .BYTE   RCRA!BIT7       ;READ CRA STACK 10.04,02,01
        SAN:    BYTPNT  ECRA
        .EVEN
        
SHI:    .WORD   0               ;EXPECTED DATA GOES HERE



;SEQ394

;ADDRESS PATTERN PAIRS    B  C  D  E  F  G
;      15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
;------------------------------------------------------
;       0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0          THIS IS THE RESET STATE
;       --------------------------------------------------
;       0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  1  0  1  1  1  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  0  1  0  1  1  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  1  0  1  0  1  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  1  1  0  1  0  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  0  1  1  0  1  0  0  0  0  0
;       -------------------------------------------------
;       0  0  0  0  0  0  0  0  1  1  0  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  1  0  0  1  1  0  0  0  0  0
;       -----------------------------------------------
;       0  0  0  0  0  0  0  1  0  0  1  1  0  0  0 0
;       ------------------------------------------------
;       0  0  0  0  0  0  0  0  1  0  0  1  0  0  0  0
;       ------------------------------------------------
;       0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0
;       -------------------------------------------------
;       0  0  0  0  0  0  1  0  0  0  1  0  0  0  0  0
;       -------------------------------------------------
;       0  0  0  0  0  0  1  1  0  0  0  1  0  0  0  0
;       -------------------------------------------------
;       0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0
;       --------------------------------------------------


;THE ABOVE TABLE REPRESENTS THE BINARY INFORMATION CONTAINED IN THE
        
;TABLLABLED "IDO".EACH 16-BIT WORD REPRESENTS A DISCRETE STATE OF
;       THE STACK SEQUENCE ILLUSTRATED ON LOGIC PRINT "CRA4".KEY INFORMATION
;IS CONTAINED IN BITS 09-04 OF THE WORDS IN TABLE "IDO" [RIOR TO
;CALLING "DCOMP:,THE WORD IN THIS TABLE ISEXTRACTED AND THEN EITHER 1.)
;GIVEN TWO SHIFTS LEFT TO RIGHT JUSTIFY BITS 09-06 (BCDE) IN THE UPPER
;BYTE OF R3 (BITS 11-08), OR 2.) WHEN IT IS DESIRD TO OBTAIN BYTE (DEFG),
;FOUR SHIFTS LEFT ARE PERFORMED RIGHT JUSTIFYING BITS 09-04 IN THE UPPER
;BYTE OF R3 (BITS 11-08). IN THIS SECOND CASE, BITS 13-12 ARE CLEARED
;OUT, AS IS THE LOWER BYTE OF R3.  THE LOWER BYTE OF R3 IS CLEARED IN EITHER
;CASE.  WHEN THE "DCOMP" ROUTINE IS CALLED IT IS THE HIGH ORDER BYTE THAT
;IS USED TO COMPARE WITH THE ACTUAL DATA OBTAINED VIA THE DIAGNOSTIC
;READ FUNCTION.

;SEQ395

IDO:    .WORD   1600    ;VARIOUS CRA STACK ADDRESSING PATTERNS
        .WORD   1700
        .WORD   740
        .WORD   1360
        .WORD   560
        .WORD   1260
        .WORD   1520
        .WORD   640
        .WORD   320
        .WORD   1140
        .WORD   460
        .WORD   220
        .WORD   100
        .WORD   1040
        .WORD   1420
        .WORD   1600
        .WORD   1700    ;THIS IS A SPECIAL ONE USED IN
                        ;TEST 41 AND 42 ONLY

;SEQ396

.SBTTL TEST 40 (ECALL3):        MICROCODE SUBROUTINE STACK OUTPUT INTERFERENCE TEST

.REM    %
        IN THIS TEST A SEQUENCE OF 8 TEST PATTERNS GERNERATED BY
"PATTY" ARE PUSHED ONE AT A TIME ONTO THE STACK, AND EACH IS VERIFIED.
THESE PATTERNS ARE SUFFICIENT TO BERIFY THAT EACH OUTPUT OF THE SBR RET
BUFFER 9CRA SBR RET 00-10) CAN BE INDEPENDANTLY A LOGIC 1, A LOGIC 0, 
AND THAT NO OUTPUTS ARE TIED TOGETHER OR OTHERWISE INTERFERRRING.
%

ECALL3: JSR     PC,INITSR       ;INITIALIZE
        MOV     #PATBUF,R2      ;R2 POINTS TO 16-BIT PATTERN BUFFER
        MOV     #KUMITE,R3      ;R3 POINTS TO 1ST BYTE OF COMPARE TABLE

;GET FIRST 16-BIT PATTERN INTO THE BUFFER
                MOV     R2,R0
        $PAT16          ;HERE IS THE CALL.  IT RETURNS PATTERN IN R2.


;SEQ397

;LOAD THE SUBROUTINE STACK WITH 11 RIGHTMOST IBTS OF PATTERNS

TENSHO: MOV     #EACAL,R4
        JSR     PC,SEPAI                ;PERFORM THE CALL SEQUENCE

;JUST GIVE THE CLOCK BURST TO PERFORM THE MICRO--INSTRUCTION

TENSH1: JSR     PC,SEPA0        ;GIVE THE BURST

;NOW READ THE STACK AND COMPARE WITH TEST PATTERN IN DATA TABLRE

        MOV     (R2),(R3)       ;PUT TEST PATTERN IN EXPECTED DATA TABLE
        ASL     (R3)           ;SHIFT TWICE TO RIGHT JUSTIFY DATA
        ASL     (R3)            ;FOR SBR RET BITS 00-04 IN UPPER
                                ;EXPECTED DATA BYTE
        MOVB    (R2),(R3)       ;RESTORE BYTE (SBR RET 05-10)
        INSYNC                  ;NEW SUBTEST (FIRST TIME THRU THIS POINT IS SUBTEST #1)
        DCOMP                   ;DO BYTE TABLE COMPARE

        .WORD   SEIKEN          ;PTR TO MASK TABLE
        .WORD   KIHON           ;PTR TO FUNCTION TABLE
        .WORD   KATA            ;PTR TO BYTE TABLE
        .WORD   KUMITE          ;PTR TO EXPECTED DATA TABLE
        .WORD   0               ;NO ERROR MSG FROM MAIN LINE

;GET NEXT TEST PATTERN

        $PATCO
        TST     R0              ;LOOK AT PATTERN # RETURNED
        BNE     TENSHO          ;CONTINUE TESTING IF NOT ZERO 9SUBTESTS #2-8)
        JMP     NORMAL          ;DO NEXT TEST

;COMPARISON TABLES FOR THIS TEST

SEIKEN: .BYTE   300             ;RIGHT SIX BITS 9SBR RET 05-10)
        .BYTE   340             ;LEFT FIVE BITS (SBR RET 00-04)

KIHON:  .BYTE   RCRA+2          ;READ SBR RET BITS 05-10
        .BYTE   RCRA+3!BIT7     ;READ SBR RET BITS 00-04
KATA:   BYTPNT  ECRA
        BYTPNT  ECRA
        
KUMITE: .WORD           0               ;EXPECTED DATA GOES HERE


;SEQ398


;ROUTINE TO BUILD MICRO-COPDE LOOP FOR CALLING AND RETURNING
;ADDRESS PATTERN IS ALREADY IN R2 UPON ENTRY.

SEPAI:  PUSH    R0              ;SAVE R0

        PUSH    R1              ;SAVE R1

        CLR$M                   ;PUT ALL 0'S IN $MICRO
        CLR     R0
        MOV     #$MICRO,R1      ;PUT C-RAM BUFFER ADDRESS IN R1
        BIS     #BIT15,R0       ;NO MRESET FROM KLDCP!
        WCRAM                   ;WRITE TO C-RAM
        CLR     R0              ;CLEAR R0
        J                       ;BUILD JUMP TO CRAM LOC 0
        MOV     R4,R0           ;GET THE CALL OR RET FIELD VALUE
        CMP     #EACAL,R0       ;IS IT A CALL OR RET??
        BEQ     1$              ;BRANCH IF IT IS A CALL,
        DISP                    ;LOAD IT
        BR      2$
1$:     $EACAL                  ;LOAD THE CALL FIELD
        
2$:     MOV     (R2),R0 ;NOW GET CRAM ADDRESS TO BE CALLED
        MOV     #$MICRO,R1      ;ADDRESS OF C-RAM BUFFER
        BIS     #BIT15,R0
        WCRAM                   ;WRITE THE C-RAM



;SEQ399

;BELOW ARE THE TWO TYPES OF "TWO MICRO INSTRUCTION LOOPS" USED
;IN THESE FIRST TWO SUBTESTS.  LOCATION "ADR" IS SUPPLIED BY THE
;PROGRAM (VIA URA3), BUT IS OF NO SIGNIFICANCE TO THESE TESTS.  THE DISPATCH
;FIELD IS SET TO A RETURH, OR THE EACALL BIT IS SET AS APPROPRIATE.
;WHEN TESTING THE ABILITY OF THE CRA STACK ADDRESS GENERATOR
;ON LOGIC PRINT CRA4 TO SEQUENCE IN THE CALL DIRECTION.  THE
;ECALL FIELD IS SET TO THE CALL VALUE.  SIMILARLY WHEN
;TESTING THE ABILITY OF THE CRA STACK ADDRESS GENERATOR TO
;SEQUENCE IN THE RETURN DIRECTION, THE DISPATCH FIELD IS SET TO
;THE RETURN VALUE.

;                       ADR FIELD               DISP FIELD
;                       ------------------------------------
;ADR:                       0                       CALL
;                       ------------------------------------
;                           0                       DIAG
;                       -------------------------------------

;THIS IS THE FIRST TYPE OF TWO MICRO INSTRUCTION LOOP USED
;AFTER WRTING THE TWO WORDS IN THE C-RAM, AN EBOX CLOCK
;IS ISSUED.  THIS EBOX CLOCK LOADS THE CONTROL REGISTER WITH
;THE WORD AT LOCATION "ADR", NOW A RETURN IS MADE (RTS PC) TO THE CALLING PROGRAM.
;THE NEXT EBOX CLOCK OCCURRING EXECUTES THIS MICRO-INSTRUCTION
;AND LOADS THE MICRO INSTRUCTION CONTAINED IN LOCATION "O".
;FINALLY A THIRD EBOX CLOCK IN THE SEQUENCE EXECUTES THE
;MIRO INSTRUCTION IN LOC "0". THE DISPATCH FIELD OF THIS PARTICULAR MICRO-
;INSTRUCTION IS 0, THE :DIAG DISP FUNCTION".  THIS RESULTS IN
;LOADING THE MICRO-INSTRUCTRION AT LOCATION "ADR" ONCE AGAIN.
;NOTE: HOWEVER THAT ONLY ONE EBOX CLOCK IS GIVEN BY EH ROUTINE
;SEPAI:,LOADING THE MICRO-INSTRUCTION CONTAINED IN "ADR".



;                       ADR FIELD               DISPATCH FIELD
;                       ------------------------------------------
;ADR:                       0                       RET
;                       -------------------------------------------
;0:                         0                       DIAG
;                       ---------------------------------------
;THIS IS THE SECOND TYPE OF TWO MICRO-INSTRUCTION LOOP USED.  IT
;FUNCTIONS IN A SIMILAR MANNER TO THAT OF THE FIRST TWO
;MICRO- NSTRUCTION LOOP ALREADY EXPLAINED

;SEQ400

;NOW READY TO EXECUTE A BURST AND TEST SBR RET OUTPUTS.

        EBURST  1               ;GENERATE 1 EBOX CLOCK
        POP     R1              ;RESTORE R1
        POP     R0              ;RESTORE R0
        RTS     PC              ;RETURN TO CALLER

;GIVE ONE EBOX CLOCK.

SEPA0:  PUSH    R0              ;SAVE R0
        EBURST  1               ;GENERATE ONE EBOX CLOCK
        POP     R0              ;RESTORE R0
        RTS     PC              ;RETURN TO CALLER

;SEQ401

.SBTTL TEST 41 (ECALL4):  MICROCODE STACK ADDRESSING TEST
.REM    %
        THIS TEST IS AN ADDRESSING TEST PERFORMED AT BURST SPEED.
THE TEST IS PERFORMED IN TWO CONSECUTIVE PARTS.  IN THE FIRST PART
EACH OF THE 15 VALID STACK ADDRESSES IS WRITTEN INTO THE COR-
RESPONDING NUMERICAL ADDRESS ONE WORD AT A TIME, BUT EXCLUDING
ADDRESS 0.  ALL OTHER LOCATIONS ARE FILLED WITH THE ADDRESS COM-
PLEMENTED.  NEXT ALL LOCATIONS ARE CHECKED, TOGETHER WITH THEIR
CORRESPONDING CRA STACK ADDRESSES.
        IN THE SECOND PART, EACH OF THE VALID STACK ADDRESSES
IS WRITTEN WITH ITS ADDRESS COMPLEMENT, WHILE ALL OTHER
ADDRESSES ARE WRITTEN WITH THE UN-COMPLEMENTED ADDRESS. THEN ALL
LOCATIONS ARE CHECKED TOGETHER WTIH THEEIR CRA STOCK ADDRESS.
%


;SEQ402

ECALL4: MOV     #4,TSTFLG
ECAL4A: CLR     R3
        CLR     URCMPX
TORA0:  MOV     R3,LSTPTR       ;SAVE TABLE POINTER
TORA1:  JSR     PC,CLR1         ;CLEAR EACH E NTRY IN TABLE URA3
        JSR     PC,INU          ;BUILD THE LIST IN URA3
        CLR     R3
        JSR     PC,INITSX       ;MRESET, CLR CRAM LOC0 ,CLR DIA REG
TORAX:  JSR     PC,YAMA1A       ;BUILD EACALL, J AND DISP FIELDS IN URA3(R3)
        CMP     #34,R3
        BEQ     TORAQ           ;IF R3=34, SPECIAL CASE-GIVE 1 EBOX CLOCK
        JSR     PC,YAMA1B       ;IF R3<34,NORMAL CASE-GIVE 2 EBOX CLOCKS
TORAZ:  ADD     #2,R3           ;UPDATE INDEX
        CMP     #36,R3
        BEQ     TORAY           ;IF R3=36 OVER THE TOP...SO BACK UP INDEX
        BR      TORAX           ;IF R3<36, CONTINUE PROCESSING LIST
TORAY:  SUB     #2,R3
        MOV    #2,R4

        JSR     PC,YAMA2        ;GO "POP" EM AND CHECK "EM"

        MOV     LSTPTR,R3       ;GET OUT ORIGINAL LIST POINTER USED             
                                ;WHEN CALLING "INU".

        CMP     #36,R3          ;CHECK THE ALREADY UPDATED ALUE
        BEQ     TORA2           ;BRANCH OUT OF LOOP IF R3=36
        BR      TORA1           ;DO MORE ITEMS, NOT YET FINISHED

TORA2:  CMP    #5,TSTFLG       ;DONE SECOND PART?
        BEQ     TORA22          ;BRANCH IF DONE PART 1 AND PART 2
        MOV     #5,TSTFLG       ;NOW SET SECOND PART FLAG
        BR      ECAL4A          ;DO SECOND PART
TORA22: CLR     TSTFLG
        JMP     NORMAL          ;PERFORM NEXT SUBTESRT (ECALL5)

TORAQ:  EBURST  1
        BR      TORAZ           ;UPDATE INDEX AND CONTINUE PROCESSING LIST


;SEQ403

;BUILD REQUIRED TABLE FOR ADDRESS PATTERN CHEKCING ETC..........


INU:    MOV     LSTPTR,R3       ;GET LIST POINTER PREVISLY SAVED
        MOV     R3,URLOC        ;POSITION OF UNIQUE ADDRESS
                                ;IN TABLE URA3
        MOV     URCMPX,URCMP1   ;# OF ADDRESS PATTERS IN TABLE
                                ;URA3, THAT ARE AHEAD OF THE SINGLE
                                ;UNIQUE ADDRESS PATTERN IN THAT 
                                ;SAME TABLE

        CLR     R1
        CLR     R4              ;INITIALIZE POINTER

        MOV     #^D15,R0        ;COUNT OF 15 ENTRIES IN URA3
        
INU0:   CMP     #4,TSTFLG       ;ARE WE IN TEST (ECALL4) PART 1?
        BNE     1$              ;BRANCH IF NOT IN PART 1
        MOV     URA1(R3),URA3(R3)       ;MOVE THE ADDRESS INTO URA3(R3)
        BR      INU1
1$:     MOV     URA2(R3),URA3(R3)       ;TABLE REFERENCE FOR SECOND PART (ECALL4)


INU1:   MOV     URA3(R4),R2     ;NOW SCAN CURRENT ENTRY IN TABLE URA3
        BNE     INU2    ;BRANCH IF ENTRY IS NON-ZERO
INU1B:  CMP     #4,TSTFLG       ;ARE WE IN TEST 9ECALL4) PART 1?
        BNE     1$              ;BRANCH IF NOT IN TEST (ECALL4) PART 1
        MOV     URA2(R3),URA3(R4)      ;MOVE THE ADDRESS COMPLEMENT
                                ;INTO TABLE URA3(R4)
        BR      2$
1$:     MOV     URA1(R3),URA3(R4)       ;TABLE REFERENC EFOR SECOND PART (ECALL4)
2$:     ADD     #2,R4
        INC     R1                      ;NOW REALLY COUNT THE ADDRESSES FROM THIS POINT.
                                        ;PREVIOUS R1 WAS CLEARED AT "INU2":
INU1A:  DEC     R0              ;SUBTRACT ONE FROM THE COUNT
        BNE     INU1            ;BRANCH IF NOT DONE ALL ENTRIES
        BR      INU4            ;BRANCH IF FINISHED ENTIRE LIST
                                ;URA3 NOW CONTAINS 15 ADDRESS
                                ;PATTERNS
INU2:   CLR     R1
        ADD     #2,R4           ;ASKIP OVER ITEM ITS NON-XZERO
        BR      INU1A           ;DECREMENT COUNT AND CHECK ANOTHER
INU4:   MOV     LSTPTR,R3       ;GET LIST POINTER AGAIN
        ADD     #2,R3           ;UPDATE IT
        MOV     R3,LSTPTR       ;AND NOW PUT IT AWAY!   
        MOV    R1,URCMP2        ;# OF ADDRESS PATTERNS IN TABLE
                                ;URA3, THAT ARE AFTER THE SINGLE
                                ;UNIQUE ADDRESS IN THAT SAME
                                ;TABLE
        INC     URCMPX          ;UPDATE # OF ADDRESS COMPLEMENTS
        RTS     PC              ;RETURN TO CAALLER

                                
        JSR     PC,ZENX         ;FIXUP $MICRO AND THEN WRITE THE
                                ;MICRO INSTRUCTION AND DIAG ADDRESS
        ASL     R4
        ASL     R4              ;CONVERT INDEX TO REQURIED NUMBER
                                ;OF CLOCKS


;SEQ404

        MOV     R4,R0           ;AND PUT THE RESULT INTO R0
        BURST                           ;NOW GIVE THE BURST

ZEN4:   RTS     PC              ;RETURN TO CALLER


;SEQ405

;BUILDS THREE FIELDS:ECALL BIT(1),J=0,DISP=0

ZEN5:   MOV     #EACAL,R0
        $EACAL
        CLR     R0              ;J VALUE =0
        J
        MOV     #10,R0          ;#10=NOP
        DISP
        RTS     PC              ;RETURN TO CALLER

;SET BIT 15 IN R0, SO KLDCP WONT PERFORM A MRESET PRIOR TO WRITING
;THE WORD IN THE C-RAML  THIS ROUTINE WRITES THE CONTENTS OF LOCATION
;$MICRO IN TEH ADDRESS SUPPLIED IN R0, AND ALSO WRITES THIS WSAME

;ADDRESS N THE DIAGNOSTIC REGISTER.

ZENX:   BIS     #BIT15,R0       ;NO MRESET FROM KLDCP PLEASE!
        MOV     #$MICRO,R1              ;ADDRESS OF $MICRO BUFFER
        WCRAM                   ;WRITE IT!!
        RTS     PC             ;RETURN TO CALLER

;CLEAR 15 ENTRIES IN TABLE URA 3


        
CLR1:   CLR     R3              ;INIT INDEX TO 0
        MOV     #^D15,R4        ;COUNT OF 15 LOCATIONS TO CLEAR
CLR2:   CLR     URA3(R3)        ;CLEAR A WORD
        ADD     #2,R3           ;UPDATE THE INDEX
        DEC     R4              ;DECREMENT WORD OCUNT
        BNE     CLR2            ;BRANCH IF NOT DONE
        RTS     PC              ;RETURN TO CALLER


;SEQ406



;ROUTINE TO BUILD AND EXECUTE MICRO INSTRUCTIONS AS REQUIRED TO POP
;CURRENT CONTENTS OF TABLE URA3 OFF SBR RET STACK.  THIS IS DONE ONE (11-BIT)
;WORD AT A TIME. EACH WORD IS CHECKED AGAINST AN EXPECTED VALUE FOR
;THAT WORD.  FOR EACH SBR RET WORD READ AND CHECKED, ITS CRA STACK ADDRESS
;IS ALSO CHECKED.

BOKEN:  CLR     CKFLG1          ;CLEAR BOKEN 3 CHECK FLAG
        CLR     CKFLG2          ;CLEAR BOKEN 4 CHECK FAG
        MOV     #14,R3          ;INDEX TO LAST ENTRY INT ABLE URA3
        CLR     R4              ;INITIALIZE THIS INDEX
BLOOP1: JSR     PC,BOKEN5       ;BUILD MICRO INSTRUCTIN IN URA3(R4)
        ECLOK                   ;LOAD CRAM REG WITH IT!!
        MOV     URA3(R3),R2     ;OBTAIN THE PATTERN WHICH IS THE
                                ;NEXT ENTRY INT ABLE URA3
        PUSH    R3              ;SABE R3 SO NEXT ROUTINE WONT
                                ;CLOBBER IT
        MOV     #JU,R3          ;ADDRESS OF EXPECTED DATA
        JSR     PC,BOKEN1       ;PERFORM DIAG READ AND CHECKING
                                ;OF SBR RET 00-10 9SUBTEST #1)
        MOV     #SHI,R3         ;ADDRESS OF EXPECTED DATA
        JSR     PC,BOKEN2       ;PERFORM DIAG READ AND CHECKING
                                ;OF CRA STACK ADR 10,04,02,.01 (SUBTEST #2)

BLOOP2: JSR     PC,BOKEN5
        EBURST  1               ;EXECUTE THE FRETUR BURST
        POP     R3              ;GET INDEX BACK NOW

        SUB     #2,R4           ;UPDATE THIS INDEX TOO
        SUB     #2,R3           ;UPDATE INDEX!
        BNE     BLOOP1  ;PERFORM ANOTHER SET OF CHECKS
                                ;IF NON-ZERO 9SUBTESTS #3-15)
        RTS     PC             ;THATS ALL, RETURN TO CALLER


;SEQ407

;CHECKS SBR RET 00-10 AND IS CALLED WITH THE PATTERN IN R2,
;AND ADDRESS OF EXPECTD DATA IN R3.

BOKEN1: MOV     R2,(R3) ;PUT SBR RET 00-10 INTO (R3)
        ASL     (R3)
        ASL     (R3)            ;SHIFT TWICE TO RIGHT JUSTIFY
                                ;DATA FOR SBR RET BITS 0-4 IN UPPER
                                ;EXPECTED DATA BYTE
        MOVB    R2,(R3)         ;RESTORE LOWER BYTE 9BITS 5-10)

        INSYNC                  ;NEW SUBTEST
        DCOMP                   ;PERFORM TH BYTE COMPARE
        .WORD   GO              ;PTR TO MASK TABLE
        .WORD   ROKU            ;PTR TO FUNCTION TBLE
        .WORD   KU              ;PTR TO BYTE TABLE
        .WORD   JU              ;PTR TO EDPECTED DATA TABLE
        .WORD   0               ;NO ERR MSG FROM MAIN LINE

        RTS     PC              ;RETURN TO CALLER

;CHECKS CRA STACK BITS 10,04,02,01 AND IS CALLED WITH INDEX IN R4

BOKEN2: MOV     #IDO+<<^D15>*2>,R2      ;NEXT ENTRY
        ADD     R4,R2           ;LNOW ADD THE INDEX(0 THRU -14)
        MOV     (R2),(R3)
        BIC     #1400,(R3)      ;CLEAR OUT BITS 09-08
        ASL     (R3)
        ASL     (R3)            ;PARTIALLY ALLIGN BYTE
        JSR     PC,TAICH3
        RTS     PC              ;RETURN TO CALLER


;SEQ408

;BUILD A MICRO INSTRUCTION WITH THE DISP FIELD SBR RET, EACALL=0,J=0,AND
;WRITE IT IN THE ADDRESS TAKEN FROM URA3(R4).  BIT 15 IS SET TO A 1
;TO PREVENT KLDCP FROM GENERATING A MRESET PRIOR TO WRITING THE C-RAM.

BOKEN5: MOV     #RETURN,R0
        DISP
        CLR     R0
        $EACAL
        CLR     R0
        J
        MOV     URA3(R3),R0
        BIS     #BIT15,R0
        MOV     #$MICRO,R1
        WCRAM
        RTS     PC              ;RETURN TOC ALLER

;COMPARISON TABLESOFR THIS TEST


GO:     .BYTE   300             ;RIGHT SIX BITS (SBR RET 05-10)
        .BYTE   340             ;LEFT FIVE BITS (SBR RET 00-04)
ROKU:   .BYTE   RCRA+2  ;READ SBR RET BITS 05-10
        .BYTE   RCRA+3!BIT7            ;READ SBR RET BITS 00-04
KU:     BYTPNT  ECRA
        BYTPNT  ECRA
JU:     .WORD   0               ;EXPECTED DATA GOES HERE


;PARALLEL TABLES FOR CONSTRUCTING URA3
;URA1 CONTAINS UNCOMPLMENTED ADDRESS PATTERNS
;THESE CORRESPOND TO PARTICULAR STATES OF THE
;CRA STACK ADDRESS GENERATOR.

URA1:   .WORD   17
        .WORD   7       
        .WORD   13
        .WORD   5
        .WORD   12
        .WORD   15
        .WORD   6
        .WORD   3
        .WORD   11
        .WORD   4
        .WORD   2
        .WORD   1
        .WORD   10
        .WORD   14
        .WORD   16


;SEQ409

;URA2 CONTAINS COMPLEMENTS OF THE VALUES IN TABLE URA1 9IN RIGHT JUSTIFIED 11-BIT FORM)
;THESE CORRESPOND TO THE 1'S COMPLEMENT OF PARITCULAR STATES OF THE CRA STACK
;ADDRESS GENERATOR.

URA2:   .WORD   3760
        .WORD   3770
        .WORD   3764
        .WORD   3772
        .WORD   3765
        .WORD   3762
        .WORD   3771
        .WORD   3774
        .WORD   3766
        .WORD   3773
        .WORD   3775
        .WORD   3776
        .WORD   3767
        .WORD   3763
        .WORD   3761

URA3:   .BLKW   20

INITSX: MRESET          ;GIVE A MASTER RESET
        CLR$M           ;CLR 12-BYTE MICROWORD IN PDP-11 CORE
        CLR     R0
        MOV     #$MICRO,R1      ;PUT ADDRSS OF MICRO BUFFER IN R1
        BIS     #BIT15,R0       ;SET BIT 15 TO PREVENT KLDCP FROM GENREATING MRESET
        WCRAM                   ;WRITE I1!
        CLR     R0              ;CLEAR R0 AGAIN
        BIS     #BIT15,R0       ;NO "MRESET"
        WWADR                   ;WRITE TO DIAG REG
        RTS     PC              ;RETURN TO CALLER

INITSR: MRESET                  ;MASTER RESET MACHINE
        CLR$M
        CLR     R0
        MOV     #$MICRO,R1      ;PUT C-RAM BUFFER ADDRESS IN R1
        BIS     #BIT15,R0       ;NO MRSET
        WCRAM
        CLR     R0
        BIS     #BIT15,R0
        WWADR
        DFXCTT                  ;CLEAR THE RESET, CALL BIT
        .WORD   SECLK
        RTS     PC              ;RETURN TO CALLER


;SEQ410

.SBTTL TEST 42 9ECALL5):  MICROCODE SUBROUTINE STACK RELIABILITY TEST

.REM    %
THIS TEST IS A DATA RELIABILITY TEST WHICH WRITES AND READS
200 OCTAL (RANDOM) SETS OF SELECTED PATTERNS IN THE STACK AT BURST
SPEED.  THE CRA STACK ADDRESS FOR EACH ENTRY WRITTEN INTO THE STACK 
IS CHECKED TOO.
 %

ECALL5: JSR     PC,RSTTAB               ;RESTORE TEST TABLE
        MOV     #200,CKFLG1     
        MOV     #1,SEED ;SET UP RANDOM NUMBER SEED
YAMA:   JSR     PC,AGURU        ;BUILD TABLE IN URA3
        CLR     R3
        JSR     PC,INITSX               ;CLEAR MACHINE
YAMAY:  JSR     PC,YAMA1A
        CMP     #34,R3
        BEQ     YAMAQ
        JSR     PC,YAMA1B
YAMAZ:  ADD     #2,R3
        CMP     #36,R3
        BEQ     YAMA0           ;NOW DO DIAG READS AND CHECKING
        BR      YAMAY           ;CONTINUE TO PERFORM CALLS
YAMA0:  SUB     #2,R3           ;REDUCE R3 BY +2 TO POINT TO LAST
                                ;ENTRY PUSHED
        MOV     #2,R4
        JSR     PC,YAMA2
        DEC     CKFLG1          ;DONE ALL PATTERNS?
        BNE     YAMA            ;BRANCH IF NOT DONE ALL PATTERNS
        JSR     PC,RSTTAB               ;RESTORE ORIGINAL TABLE
        JMP     NORMAL          ;EXIT THIS TEST GROUP!!


;SEQ411

;ROUTINE TO FORM A TABLE OF PATTERNS DYNAMICALLY IN URA3
;IF AN ERROR OCCURS IN THE RELIABILITY TEST, AND
 ;THE STOP ON ERROR SWITCH WAS SET AT THE TIME OF THE ERROR:
;THEN SAVTAB THRU SAVTAB +32 OCTRAL CONTAINS THE CORRECT
;PATTERNS USED TO TEST THE STACK FOR THIS SUBTEST.
;**THE TABLE CAN BE FORCE PRINTED. TO CAUSE THIS ACTION
;LOCATION XPTABF MUST BE LOADED WITH A NON-ZERO VALUE**

AGURU:  CLR    R3              ;INITALIZE TABLE INDEX
        MOV     #^D15,R4        ;NUMBER OF TABLE ENTRIES
AGURU0: MOV     SEED,R0
        ADD     #143212,R0
        ROR     R0
        ADD     #012341,R1
        XOR     R0,R1
        ROL     R1
        ADD     R1,R0
        XOR     R0,SEED
        MOV     SEED,R0
        BIC     #174000,R0
        CMP     #0,R0
        BEQ     AGURU0
        MOV     R0,URA3(R3)     ;MOVE IN ENTRY TO BE USED THIS PASS
        ADD     #2,R3           ;UPDATE INDEX
        DEC     R4
        BNE     AGURU0  ;BRANCH IF NOT DONE ALL 15 ENTRIES
        RTS     PC              ;RETURN TO CALLER

SEED:   .WORD   0               ;SEED FOR RAMDOMIZER


;SEQ412


;ROUTINE TO POP TESTPATTERNS OFF STACK AND CHECK THEM TOGETHER WITH
;THEIR CRA STACK ADDRESS BITS.

YAMA2:  CLR$M
        MOV     #$MICRO,R1
        MOV     #3700,R0
        BIS     #BIT15,R0
        WCRAM
        ECLOK
        JSR     PC,BOKEN5
        MOV     URA3(R3),R2     ;GET ENTRY INTO POSITION
        ECLOK
        

YAMA2A: PUSH    R3              ;SAVE R3 FOR A WHILE
        MOV     #JU,R3          ;ADDRESS OF EXPECTED DATA
        JSR     PC,BOKEN1       ;(SUBTEST #1)
        MOV     #SHI,R3 ;ADDRESS OF EXPECTED DATA
        JSR     PC,BOKEN2               ;CHECK CRA SBR RET 10,04,02,01
        SUB     #2,R4   ;UPDATE INDEX TO IDO
        POP     R3              ;RESTORE R3
        SUB     #2,R3           ;UPDATE R3 TO NEXT WORD
        CMP     #0,R3   ;DONE?
        BEQ     YAMAX   ;BRANCH IF YES
        JSR     PC,BOKEN5
YLOOP1: EBURST  1               ;GIVE THE BURST
        MOV     URA3(R3),R2
        BR      YAMA2A          ;(SUBTESTS #2-15)...(SUBTESTS #2-50)

YAMAX:  RTS     PC              ;RETURN TO CALLER

YAMAQ:  EBURST 1                ;ONE BBOC CLOCK
        BR      YAMAZ

YAMA1A: JSR     PC,ZEN5         ;BUILD EACALL,J,AND DISP FIELDS
        MOV     URA3(R3),R0
        JSR     PC,ZENX         ;WRITE MICRO-INSTR AND DIAG ADDRESS
        RTS     PC              ;RETURN TO CALLER

YAMA1B: EBURST  2               ;GIVE THE BURST
        RTS     PC              ;RETURN TO CALLER


;SEQ413

;ROUTINE TO RESTORE TABLE UKE1 TO ITS ORIGINAL FORM


RSTTAB: CLR     R3              ;INITIALIZE INDEX
        MOV     #^D15,R4        ;NUMBER OF TBLE ENTRIES
RSTTB0: MOV     UKE2(R3),UKE1(R3)       ;REPLACE ENTRY
        ADD     #2,R3
        DEC     R4
        BNE     RSTTB0          ;DO ANOTHER ENTRY
        RTS     PC              ;RETURN TO CALLER

;VARIOUS TAGS USED IN THIS TEST GROUP

TSTFLG: .WORD   0
        
LSTPTR: .WORD   0
URLOC:  .WORD   0
URCMPX: .WORD   0
URCMP1: .WORD   0
URCMP2: .WORD   0
CKFLG1: .WORD   0
 
        
CKFLG2: .WORD   0


;TABLES USED FOR ECALL5 (DATA RELIABILITY TESTING)

UKE1:   .WORD   002041
        .WORD   002143
        .WORD   000102
        .WORD   000306
        .WORD   002347
        .WORD   002245
        .WORD   000204
        .WORD   000614
        .WORD   002655
        .WORD   002757
        .WORD   000716
        .WORD   000512
        .WORD   002553
        .WORD   002451
        .WORD   000410


UKE2:   .WORD   002041

        .WORD   002143
        .WORD   000102
        .WORD   000306
        .WORD   002347
        .WORD   002245
        .WORD   000204
        .WORD   000614
        .WORD   002655
        .WORD   002757
        .WORD   000716
        .WORD   000512
        .WORD   002553
        .WORD   002451


;SEQ414

        .WORD   000410

        .EVEN


;SEQ415


.SBTTL TEST 43 (EAPR6): FM EXTENDED TESTING

.REM    %
THIS TEST CHECKS THAT THE 1 X 128 FM EXTENDED RAM CAN BE WRITTEN WITH ALL ZEROS AND
ALL ONES.  IT USES SH AR EXTENDED AND COND FM WRITE, PREVIOUSLY TESTED.
%

;INITIALIZE:

EAPR6:  PMSG    <STARTING FM EXTENDED RAM TEST\>

        JSR     PC,ICTL1        ;INIT THE CTL BOARD
        MOV     #CTLMSK+1,R0    ;CHANGE SOME OF THE DEFAULT MASKS
        BISB    #16,(R0)+       ;DON'T LOOK AT APR CURRENT BLK 4,2,1
        BISB    #3,(R0)         ;NOR AT APR FM BLK 4,2
        MOV     #CTLMSK+11,R0
        BICB    #60,(R0)+       ;DO LOOK AT APR FM EXTENDED
        BISB    #200,(R0)       ;BUT DON'T LOOK AT APR FM BLK 1
        MOV     #EWORD1+3,R1    ;PTR TO BYTE WITH EBUS 4-11 IN BUFFER
        MOV     #DESIRE,R2      ;PTR TO MCOMPS # TABLE
        MOV     #YEAH,R3        ;PTR TO MCOMPS BYTE TABLE
        MOV     #DAY,R4         ;PTR TO STIMULUS TABLE
        PUSH    R3              ;PUT AWAY POINTER

        CLR     R3              ;AND CLEAR R3


;SEQ416

;MAIN LOOP SARTS HERE:

        CLRB    CK77            ;CLEAR FM ADDRESS COUNTER
        CLRB    FMEX0
        CLRB    FMEX1
        CLRB    FMEX2           ;HOLDS A CONSTANT

HAY:    INSYNC
        CLEAR                   ;START FRESH
        CLRB    (R1)            ;CLEAR BITS 4-11 IN BUFFER
        MOV     R5,-(SP)        ;SAVE R5 ON STACK
        CLR     R5
        MOVB    (R4),R5         ;GET NEXT CODED STIMULUS BYTE
        ASR     R5              ;IS "CURRENT BLOCK" BIT SET?
        BCC     END             ;IF NO, LEAVE CB EBUS BITS CLEAR
        MOVB    CK77,(R1)       ;YES, SET EBUS BITS 6-8
        ASLB    (R1)
        ASLB    (R1)
        ASLB    (R1)            ;LEFT ALLIGN BLOCK #

        STUFF                   ;LOAD THE AR FROM BUFFER

        $COND   20              ;SET COND/DIAG
        $NUM    25              ;"LOAD AC BLOCK"
        $XBUF0                  ;EXECUTE TO SET/CLEAR AC BLOCKS


;SEQ417

;SEE IF #'S SHOULD BE SET.

END:    ASR     R5              ;CHECK # BIT
        BCC     YARD            ;GO AROUND IF CLEAR

;GET CURRENT # VALUE FROM TABLE:

        MOVB    R3,R0           ;GET NEXT # VALUE
        $NUM                    ;WRITE IT IN THE BUFFER
        INCB    R3              ;UPDATE IT FOR NEXT TIME

;SET PROPER FM ADDRESS FROM TABLE

YARD:   MOV     R5,R0           ;NEXT FOUR CODE BITS ARE FM ADR.
        $FM                     ;AND WRITE THESE IN THE BUFFER

        ASR     R5
        ASR     R5
        ASR     R5              ;SHIFT OUT THE FM ADR SEL BITS

;NOW LOAD THE "AR"



        ASR     R5              ;CVHECK LOAD AR BIT
        BCC     BTU             ;GO AROUND IF CLEAR
        MOV     #EWORD1,R0      ;GET PTR TO BUFFER
        MOVB    FMEX2,(R0)+     ;LOAD BITS 28-35
        MOVB    FMEX2,(R0)+     ;LOAD BITS 20-27
        MOVB    FMEX2,(R0)+     ;LOAD BITS 12-;9
        MOVB    FMEX2,(R0)+     ;LOAD BITS 4-11
        CLRB    (R0)            ;CLEAR BITS 0-3

        DFXCTT
        .WORD   CECLK
        STUFF                   ;NOW ACTUALLY LOAD THE AR

BTU:    ASR     R5              ;CHECK COND BIT
        BCC     UNB             ;GO AROUIND IF CLEAR
        $COND   10              ;WRITE FM WRITE FIELD BITS
        $XBUF                   ;NOW TO LOAD THE WHOLE MESS INTO THE CR.
        DFXCTT          
        .WORD   SSCLK           ;SINGLE MBOX CLK TO ENABLE LOOKING
                        ;AT FM EXTENDED


;SEQ418

UNB:    MOV     (SP)+,R5        ;RESTORE SUBTEST #
        MOVB    R3,FMEX1        ;SAVE CURRENT INDEX
        POP     R3              ;GET OUT MCOMP PTR
        CTLMCR          ;COMPARE

        PUSH    R3              ;AND PUT IT BACK ON THE STACK

        MOVB    FMEX1,R3        ;RESTORE INDEX NOW WE WILL USE IT!
        INCB    FMEX0           ;UPDATE BLOCK WORD COUNT
        CMPB    #17,FMEX0       ;COMPARE
        BGE     UNB1            ;DO ANOTHER WORD IN CURRENT BLOCK
                                ;IF BRANCH IS TRUE
        MOVB    #177777,FMEX2   ;CONSTANT TO FORCE FM EXTENDED
        CLRB    FMEX0
        CLRB    R3              ;SET INDEX TO 0
        MOVB    R3,FMEX1                ;PUT AWAY A COPY FOR UNB3:
        MOV     #DAY,R4         ;INITIALIZE STIMULUS ADDRESS
UNB1:   MOV     SUBNR,R0
        BIC     #177740,R0      ;MAKE IT MODULO 32
        CMP     #0,R0   ;LOOK FOR 0 WHICH IS REALLY =- 32
        BLT     HAY             ;LOOP IF NOT DONE ALL SUB TESTS
        BR      UNB3
UNB2:   POP     R3              ;TO PUT THE STACK BACK IN ORDER!

        MOV     #CTLMSK+11,R0   ;ADDRESS OF MASK FOR INDEX (11)
        BISB    #60,(R0)        ;TURN OFF LOOKING AT BIT 13
        MOV     #CTLMSK+1,R0    
        BICB    #16,(R0)        ;ENABLLE LOOKING AT APR CURRENT BLK 4,2,1
        MOV     #CTLMSK+2,R0
        BICB    #3,(R0) ;ENABLE LOOK8ING AT APR FM BLK 4,2
        MOV     #CTLMSK+12,R0
        BICB    #200,(R0)       ;ENABLE LOOKING AT APR FM BLK 1
        JMP     NORMAL          ;EXIT

UNB3:   INCB    CK77            ;ADD 1 TO BLOCK 4
        CLRB    FMEX2           ;TO START FRESH WE DONT WANT ANY NON
                                ;ZERO VALUE IN FMEX2 SO CLEAR IT!
        MOV     #DESIRE,R2      ;INITIALIZE MCOMP PTRS
        POP     R3              ;WE DONT WNT THIS STUFF
        
        MOV     #YEAH,R3        ;INITIALIZE THIS PTR TOO
        PUSH    R3              ;SAVE THIS FOR LATER

        MOVB    FMEX1,R3        ;THIS PUTS 0 IN R3
        CMPB    #10,CK77                ;CHECK ERESULT
        BGT     HAY             ;LOOP IF NOT DONE AALL SUBTESTS
        BR      UNB2            ;DONE, SO ALL GONE!!

CK77:   .BYTE   0
FMEX0:  .BYTE   0
FMEX1:  .BYTE   0
        FMEX2:  .BYTE   0



;SEQ419

;HERE IS THE STIMULUS TABLE FOR FM EXTENDED TESTING.
;THE BYTES ARE CODED AS FOLLOWS:

;       BIT#            MEANING

;         0             SET CURRENT BLOCK #
;         1             SET CR #00-08
;         2             SET FM ADR SEL 1
;         3             SET FM ADR SEL 2
;         4             SET FM ADR SEL 4
;         5             SET FM ADR SET 10
;         6             SET LOAD AR
;         7             SET FM WRITE

DAY:    .BYTE   177             ;CURRENT BLOCK,CR#,FMADR=7,LOAD AR, FM WRITE
                                ;THIS STIMULUS BYTE IS USED 256 TIMES (EIGHT TIMES FOR
                                ;EACH SUBTEST). THERE ARE 32 SUBTESTS THUS:
                                ;(32 X 8 = 256)


;SEQ420

;HERE IS MCOMPS # TABLE:

DESIRE: .BYTE   3               ;SUBTEST #1
        .BYTE   4               ;2
        .BYTE   4               ;3
        .BYTE   4               ;4
        .BYTE   4               ;5
        .BYTE   4               ;6
        .BYTE   4               ;7
        .BYTE   4               ;8
        .BYTE   4               ;9
        .BYTE   4               ;10
        .BYTE   4               ;11
        .BYTE   4               ;12
        .BYTE   4               ;13
        .BYTE   4               ;14
        .BYTE   4               ;15
        .BYTE   4               ;16
        .BYTE   4               ;17
        .BYTE   5               ;18
        .BYTE   5               ;19
        .BYTE   5               ;20
        .BYTE   5               ;21
        .BYTE   5               ;22
        .BYTE   5               ;23
        .BYTE   5               ;24
        .BYTE   5               ;25
        .BYTE   5               ;26
        .BYTE   5               ;27
        .BYTE   5               ;28
        .BYTE   5               ;29
        .BYTE   5               ;30
        .BYTE   5               ;31
        .BYTE   5               ;32


;SEQ421

YEAH:   .BYTE   20              
        .BYTE   101             ;SUBTEST #1:
        .BYTE   16
        .BYTE  174             ;-CON COND EN 00-07
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #2:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   14              ;APR FM ADR 1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBRTEST #3:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   24              ;APR FM ADR 2
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #4"
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   34              ;APR FM ADR 2,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #5:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   44              ;APR FM ADR 4
        .BYTE   7       
        .BYTE   44
 


;SEQ422

        .BYTE   20
        .BYTE   101             ;SUBTEST #6:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   54              ;APR FM ADR 4,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #7:
        .BYTE  16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   64              ;APR FM ADR 4,2
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #8:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   74              ;APR FM ADR 4,2,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #9:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   104             ;APR FM ADR 10
        .BYTE   7
        .BYTE   44


;SEQ423


        .BYTE   20
        .BYTE   101             ;SUBTEST #10:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   114             ;APR FM ADR 10,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #11:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   124             ;APR FM ADR 10,2
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #12:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   134             ;APR FM ADR 10,2,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #13:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   144             ;APR FM ADR 10,4
        .BYTE   7
        .BYTE   44

        .BYTE   20              
        .BYTE   101             ;SUBTEST #14:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   154             ;APR FMA DR 10,4,1
        .BYTE   7
        .BYTE   44


;SEQ424

        .BYTE   20
        .BYTE   101             ;SUBTEST #15:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12

        .BYTE   164             ;APR FM ADR, 10,4,2
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUT5EST #16:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   174             ;APR FM ADR 10,4,2,1
        .BYTE   7
        .BYTE   44

        .BYTE   20
        .BYTE   101             ;SUBTEST #17:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED, APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #18:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   14              ;APR FM ADR 1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE 60                ;SH AR EXTENDED, APR FM EXTENDED


;SEQ425


        .BYTE   20
        .BYTE   101
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   24              ;APR FM ADR 2
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED, APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #20:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   34              ;APR FM ADR 2,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED, APR FM EXTENDED

        .BYTE    20
        .BYTE   101             ;SUBTEST #21:
        .BYTE   16
 
        .BYTE   174             ;-CON EOND EN 00-07
        .BYTE   12      
        .BYTE  44              ;APR FM ADR 4
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH ARE XTENDED, APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #22:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   54              ;APR FM ADR 4,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED, APR FM EXTENDED



;SEQ426

        .BYTE   20
        .BYTE   101             ;SUBTEST #23:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   64              ;APR FM ADR 4,2
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXZTENDED

        .BYTE   20
        .BYTE   101             ;SUBEST #24:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   74              ;APR FM ADR 4,2,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #25:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   104             ;APR FM ADR 10
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,, APR FM EXTENDED

;SEQ427

        .BYTE   20
        .BYTE   101             ;SUBTEST #26:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   114             ;APR FM ADR 10,1
        .BYTE   7
        .BYTE   44      
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED
        
        .BYTE   20
        .BYTE   101             ;SUBTEST #27:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   124             ;APR FM ADR 10,2
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #28:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   134             ;APR FM ADR 10,2,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #29:
        .BYTE 16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   144             ;APR FM ADR 10,4
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED


;SEQ428

        .BYTE   20
        .BYTE   101             ;SUBTEST #30:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   154             ;APR FM ADR 10,4,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENCED, APR F, EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #31:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   164             ;APR FM ADR 10,4,2
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED

        .BYTE   20
        .BYTE   101             ;SUBTEST #32:
        .BYTE   16
        .BYTE   174             ;-CON COND EN 00-07
        .BYTE   12
        .BYTE   174             ;APR FM ADR 10,4,2,1
        .BYTE   7
        .BYTE   44
        .BYTE   11
        .BYTE   60              ;SH AR EXTENDED,APR FM EXTENDED

        .EVEN


;SEQ429

.SBTTL *ESUB*  EBOX DIAGNOSTIC SUBROUTINES

.SBTTL SUBROUTINES TO MANIFULATE 36-BIT WORDS IN 11 CORE

;*****CLRWRD & CLRBUF -- SUBROUTINES TO CLEAR A 36-BIT WORD
;       CALL:   JSR     R5,$CLRWD
;               .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD

$CLRBF: MOV     #EWORD1,R0      ;ALTERNATE ENTRY FOR EWORD1
        BR      CLRW1
        
$CLRWD: MOV     (R5)+,R0
CLRW1:  .REPT   5
        CLRB    (R0)+
        .ENDR
        RTS     R5

;*****SETWRD & SETBUF -- SUBROUTINES TO SET BITS IN A 36-BIT WORD
;       CALL:   JSR     R5,$SETWD
;               .WORD   ADR             ;ADDRESS IF 1ST BYTE IOF WRD
$SETBF:        MOV     #EWORD1,R0      ;ALTERNATE ENTRY
        BR      SETW1

$SETWD: MOV     (R5)+,R0        ;PICK UP AN ARGUMENT
SETW1:  .REPT   4
        MOVB    #377,(R0)+
        .ENDR
        MOVB    #17,(R0)+               ;ONLY 1ST FOUR BITYS OF LAST BYTE
        RTS     R5


;SEQ430

;***ROLWRD & ROLBUF -- SUBROUTINES TO ROTATE LEFT A 36-BIT WORD
;       CALL:   JSR     R5,$ROLWD       
;       .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
$ROLBF: MOV     #EWORD1,R0      ;ALTERNATE ENTRY FOR EWORD1
        BR      ROLW1
        
$ROLWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
        
ROLW1:  PUSH    R1              ;GET A REGISTER

        MOV     #4,R1           ;LOOP COUNT = 4
        ASLB    (R0)+   ;SHJIFT 1ST BYTE (SETS/CLEARS C)
1$:     ROLB    (R0)+           ;ROTATE NEXT BYTE (INCLUDING C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;LOOP TIL DONE
        BITB    #BIT4,-(R0)     ;DID A 1 SHIFT OUT OF SHORT BYTE?
        BEQ     2$              ;NO, SKIP
        SEC                     ;YES, SET CARRY
        ADCB    -4(R0)          ;SET LSB OF 1ST BYTE
2$:     POP     R1              ;DONE, RESTORE REG

        RTS     R5              ;RETURN

;****RORWRD & RORBUF -- SUBROUTINES TO ROTATE RIGHT A 36-BIT WORD
;       CALL:   JSR     R5,$RORWD
;               .WORD           ADDRESS OF FIRST BYTE OF WORD
$RORBF: MOV     #EWORD1,R0      ;ALT ENTRY FOR EWORD1
        BR      RORW1

$RORWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
RORW1:  PUSH    R1              ;GET A REGISTER

        MOV     #4,R1           ;LOOP 4 TIMES
        ADD     R1,R0           ;POINT AT LAST BYTE
        ASRB    (R0)            ;SHIFT LAST BYTE (SETS/CLEARS C)
        BICB    #BIT3,(R0)      ;CLEAR MSB OF 10 WORD (C NOT AFFECTED)
1$:     RORB    -(R0)           ;ROTATE THIS BYTE (INC C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;DO ALL
        BCC     2$              ;NO, GO AROUND
        BISB    #BIT3,4(R0)     ;YES, SET MSB OF 10 WORD
2$:     POP     R1              ;RESTORE REG

        RTS     R5              ;RETURN



;SEQ431

;***MOVWRD -- SUBROUTINE TO MOVE A 36 BIT WORD FROM ONE
;PLACE TO ANOTHER.  CALL INCLUDES TRAILING PARAMETERS AS FOLLOWS:
;       JSR     R5,$MOVWD
;       .WORD   SOURCE ADDRESS
;       .WORD   DESTINATION ADDRESS

$MOVWD: SHOVE                   ;SAVE REGISTERS
        MOV     (R5)+,R2        ;GET ADDRESS OF SOURCE
        MOV     (R5)+,R1        ;GET ADDRESS OF DESTINATION
        MOV     #5,R0           ;NEED FIVE BYTE MOVES
1$:     MOVB    (R2)+,(R1)+     ;TRANSFER
        DEC     R0              ;SEE IF DONE
        BGT     1$              ;BR IF NO
        GRAB                    ;IF DONE RESTORE REGISTERS
        RTS     R5              ;RETURN

;***COMBUF -- SUBROUTINE TO WRITE THE 36-BIT COMPLIMENT
;OF EWORD1 TO EWORD2.
;       CALL:   JSR     R5,$COMBF

$COMBF: SHOVE
        MOV     #EWORD1,R1      ;R1 PTS TO 1ST BUFFER
        MOV     #EWORD2,R2      ;R2 TO 2ND
        MOV     #5,R3           ;R3 COUTNS BYTES

1$:     MOVB    (R1)+,R0        ;GET NEXT BYTE
        COMB    R0              ;COMPLIMENT IT
        MOVB    R0,(R2)+        ;PUT IT AWAY
        DEC    R3               ;DOWN THE COUNT
        BGT     1$              ;LOOP TIL DONE

        BICB    #360,-(R2)      ;SHAVE THE LAST BYTE
        GRAB                    ;BACK THE REGS
        RTS     R5              ;RETURN


;SEQ432

.SBTTL SUBROUTINES TO MANIPULATE 80-BIT MICROWORDS IN 11-CORE

;***CLRMIC & CLR$M -- SUBROUTINES TO CLEAR A 12-BYTE MICROWORD
;       CALL:   JSR     R5,$CLRMI       
                
;               .WORD   ADR             ;ADDRESS OF 1ST BYTE OF MICROWORD

$CLR$M: MOV     #$MICRO,R0      ;ALT ENTRY FOR $MICRO
        BR      CLRM1
$CLRMI: MOV     (R5)+,R0                ;PICK UP STARTING ADDRESS
        
CLRM1:  .REPT   6
        CLR     (R0)+
        .ENDR
        RTS     R5

;***GETMIC -- SUBROUTINE TO READ CRAM LOCATION INTO 80-BIT BUFFER
;       CALL:   MOV     #LOC,R0         ;R0 POINTS TO CRAM LOCTION TO READ
        
;               JSR     R5,$GETMI       ;CALL

$GETMI: PUSH    <R1,R2>                 ;SAVE TWO REGISTERS

        RCRAM                   ;READ THE CRAM
        MOV     #$MICRO,R1              ;PICK UP PTR TO BUFFER
        MOV     #12,R2          ;WILL COPY 12 BYTES
1$:     MOVB    (R0)+,(R1)+     ;COPY A BYTE INTO THE BUFFER
        DEC     R2              ;COUNT IT
        BGE     1$              ;LOOP TIL DONE
        POP     <R2,R1>         ;RETURN REGISTERS

        RTS     R5              ;AND RETURN


;SEQ433

.SBTTL SUBROUTINES TO DIDDLE THE PDP-11


;***ADDCB -- SUBROUTINE TO ADD A CONSTANT TO A BYTE
        
;       CALL:   JSR     R5,ADDCB
;               .WORD   CONST           ;CONTANT
;               .WORD   ADR             ;ADDRESS OF DESTINATION BYTE
ADDCB:  PUSH    R1              ;GET A REGISTER

        MOV     (R5)+,R0        ;PUT CONSTANT IN R0
        MOV     (R5)+,R1        ;PUT ADDRESS OF DESTINATION IN R1
        BIT     #BIT0,R1        ;IS DESTINATION ADR EVEN OR ODD?
        BEQ     1$              ;BRANCH IF EVEN
        SWAB    R0              ;ODD...FLIP CONTANT
        DEC     R1              ;MAKE DESTINATION ADR EVEN
1$:     ADD     R0,(R1)         ;ADD CONTANT TO WORD AT DESTINATION
        POP     R1              ;PUT BACK REGISTER

        RTS     R5              ;RETURN

;***CLEAR -- SUBROUTINE TO PRESERVE MBOX DISABLE ON RESET

$CLEAR: MRESET                  ;DO CONSOLE RESET
        MOV     R1,-(SP)        ;SAVE A REG
        MOV     #1$,R1          ;PTR TO ZEROES
        MOV     #LDCHK2,R0      ;LOAD SECOND REGISTER
        DFWRT

        MOV     (SP)+,R1        ;RESTORE REG
        RTS     R5              ;AND BACK
1$:     WD36    0,0,10          ;BIT TO SET "MBOX DISABLE"
.EVEN


;SEQ434


;***SHOVE -- SUBROUTINE TO SAVE REGS 1-4 ON THE STACK
;WITHOUT DISTURBING R0 OR R5.

$SHOVE: POP     $$HOLD          ;GET R5 OFF STACK

        PUSH    <R4,R3,R2,R1>   ;SAVE THE REGISTERS

        PUSH    $$HOLD          ;PUT R5 BACK ON STACK
        RTS     R5              ;AND RETURN

$$HOLD: .WORD   0               ;SAVE LOCATION

;***GRAB -- SUBROUTINE TO RESTORE REGS 1-4 FROM THE STACK
;WITHOUT DISTURBING R0 OR R5.

$GRAB:  POP     $$HOLD          ;GET R5 OFF STACK.

        POP     <R1,R2,R3,R4>   ;PUT BACK REGISTERS.

        PUSH    $$HOLD          ;PUT R5 BACK ON STACK.

        RTS     R5              ;AND RETURN.


;SEQ435

.SBTTL DIDDLY -- SUBROUTINE FOR LOADING CRAM FIELDS INTO $MICRO.

;THIS ROUTINE IS CALLED WITH UP TO 16 BITS OF RIGHT JUSTIFIED DATA IN R0
;WHICH ARE TO BE WRITTEN INTO ARBITRARY BIT POSITIONS IN THE 11-BYTE MICRO-
;WORD BUFFER, $MICRO, FOR LOADING INTO THE CRAM (E.G. USING $MWORD). THE BITS
;NEED NOT BE ADJACENT, NOR IN THE SAME BYTE IN $MICRO, AND ALL UNSPECIFIED BITS
;IN $MICRO ARE NOT DISTURBED BY THIS ROUTINE.  BIT LOADING IS OCNTROLLED
;BY TABLES INTERNAL TO THIS ROUTINE, WHICH ARE SELEDCCTRTED BY MEANS OF ENTRY
;POINT:
;

;EXAMPLE        CALL:
;               MOV     #37,R0  ;THIS CALL LOADS 37 INO THE AD

;               JSR     R5,$AD  ;CONTROL FIELD OF $MICRO.
;
;THE FOLLOWING FIELDS ARE SUPPORTED (NOTE ORDER OF BITS):
;
;       $AD     LOADS ADB SEL 2 & 1     ;ADA DIS,SEL2 & 1;AD CRY, AD BOOLE & AD SEL 8,4,2
;       $AR     LOADS ARXM SEL 4,2,&1 AN ARM SEL 4,2,&1.
;       $BR     ;LOADS BR LOAD & BRX LOAD
        
;       $COND   LOADS OCND 00-05.
;       $DISP   LOADS DISP 00-04.
;       $FE     LAODS FE LOAD
        
;       $EACALL LOADS THE CALL BIT ON MODEL B CPU'S
;       $FM     LOADS FM ADR SEL 4,2&1
;       $J      LOADS J00-J10.
;       $MEM    LOADS MEM 00-03
;       $MQ     LOADS MQ SEL
;       $NUM    LOADS #00-08
;       $SC     LOADS SCM SEL 2
        

;       $SCAD   LOADS SCADB SEL 2 & 1: SCADA DIS,SEL 2 & 1 AND SCAD 4,2 & 1.
        
;       $SH     LOADS SH-ARMM SEL 2 & 1
;       $T      LOADS T00 & T01
;       $VMA    LOADS VMA SEL 2 & 1
;THERE IS AN ALTERNATE CALL FOR EACH ENTRY WHICH ALLOWS THE ALUE OF
;THE FIELD TO BE WRITTEN TO BE PASSED AS AN IN-LINE TRAILING PARAMETER.
;THE CALLS ARE SIMJLAR TO THE ABOVE ONLY SUFFIXED BY A 'T'.  FOR EXAMPLE:
;
;               JSR     R5,$ADT
;               .WORD   37
;
;IS THE EQUIVALENT TO THE ABOVE REGISTER PARAMERTER CALL.


;SEQ436

;HERE BEGINS THE MEAT OF THIS ROUTINE.

DIDDLY: SHOVE                   ;SAVE REGISTERS R1-R4.
        MOV     10(SP),R1       ;TABLE BASE  ADDRESS GOES IN R1.
        CLR     DOODLY          ;CLEAR LAST BYTE FLAG

;       R1      POINTS AT CURRENT PLACE IN DIDDLY'S TABLE.
;       R2      POINTS AT BYTE IN $MICRO CURRENTLY BEING MODIFIED.
;       R3      HAS CURRENT BIT MASK FROM DIDDLY'S TABLE.
;       R4      COUNTS SHIFTS TO TELL WHEN A BYTE IS DONE.

;DO THIS LOOP UNTIL ALL BYTES HAVE BEEN MODIFIED ACCORDING TO THE GABLE.

SQUAT:  MOVB    (R1)+,R2                ;PUT NEXT INDEX INTO $MICRO IN R2.
        BGE     DIDLY0          ;LAST TABLE ENTRY MARKED WITH NEG INDEX.
        COM     DOODLY          ;SET LAST BYTE FLAG AND
        BIC     #177700,R2      ;FIX CODED INDEX

DIDLY0: ADD     #$MICRO,R2      ;ADD $MICRO BASE TO INDEX.
        MOVB    (R1)+,R3        ;GET NEXT MASK BYTE TO R3.
        MOV     #10,R4          ;R4 WILL COUNT ROTATES

;AROUND THIS LOOPE IGHT TIMES FOR EACH BUTE INT HE TABLE.

DIDLY1: ASRB    R3              ;SHIFT NEXT MASK BIT TO C.
        BCC     DIDLY2          ;WAS IT A 1?
        ASR     R0              ;YES, SHIFT NEXT INPUT BIT TO C.
        BR      DIDLY3          ;AND GO ROTATE INTO $MICRO

DIDLY2: BITB    #1,(R2)         ;NO, IS RH BIT OF $MICRO NOW SET.
        BEQ     DIDLY3          ;NO, GO ROTATE INTO $MICRO

        SEC                     ;YES, SET C TO AND
DIDLY3: RORB    (R2)            ;ROTATWE CONTENTS OF C INTO $MICRO BYTE.
        DEC     R4              ;COUNT SHIFTS.
        BNE     DIDLY1          ;LOOP TILL DONE WHOLE BYTE.

        TST     DOODLY          ;LAST TABLE ENTRY?
        BGE     SQUAT          ;NO, THEN SEE IF MORE TO DO.





        GRAB                    ;YES, RETURN REGISTERS BORROWEC.
        POP     R0              ;THROW AWAY TABLE BASE.

        RTS     R5              ;YOU ALL DONE, BOY!

DOODLY: 0               ;STORAGE FOR SQUAT


;SEQ437


;HERE ARE DIDDLY'S INTENAL TABLES:

$ADT:   MOV     (R5)+,R0        ;PICK UP TRAILING PARAMETER
$AD:    JSR     PC,DIDDLY       ;ENTER,PUSH THIS ADR, AND START
        .BYTE   7
        .BYTE   17              ;AD SEL 8,4,2,1

        .BYTE   6
        .BYTE   200             ;AD BOOLE
        .BYTE   0       
        .BYTE   40              ;AD CRY
        .BYTE   6
        .BYTE   160             ;ADA DIS,SEL 2 & 1
        .BYTE   5
        .BYTE   200             ;ADB SEL 1
        .BYTE   206     
        .BYTE   10              ;ADB SEL 2

$ART:   MOV     (R5)+,R0
$AR:    JSR     PC,DIDDLY
        .BYTE   1
        .BYTE   240             ;ARM SEL 2 & 1
        .BYTE   4
        .BYTE   4               ;ARM SEL 4
        .BYTE   1
        .BYTE   12              ;ARXM SEL 2 & 1
        .BYTE   205             
        .BYTE   10              ;ARXM SEL 4

$BRT:   MOV     (R5)+,R0
$BR:    JSR     PC,DIDDLY
        .BYTE   203
        .BYTE   12              ;BR & BRX LOAD

$CONDT: MOV     (R5)+,R0
$COND:  JSR     PC,DIDDLY
        .BYTE   2
        .BYTE   20              ;COND 5
        .BYTE   3
        .BYTE   5               ;COND 3 & 4
        .BYTE   207
        .BYTE   160             ;COND 0,1 & 2

$DISPT: MOV     (R5)+,R0
$DISP:  JSR     PC,DIDDLY
        .BYTE   212
        .BYTE   37              ;DISP 0-4


;SEQ438


$EACLT: MOV     (R5)+,R0
$EACAL: JSR     PC,DIDDLY
        .BYTE   212
        .BYTE   40              ;EA CALL

$FET:   MOV     (R5)+,R0
        
$FE:    JSR     PC,DIDDLY
        .BYTE   211
        .BYTE   10              ;FE LOAD

$FMT:   MOV     (R5)+,R0
$FM:    JSR    PC,DIDDLY
        .BYTE   202
        .BYTE   340             ;FM ADR 4,2, & 1

$JT:    MOV     (R5)+,R0
$J:     JSR     PC,DIDDLY
        .BYTE   10
        .BYTE   377             ;J3-10
        .BYTE   211
        .BYTE   7               ;J0-2

$MEMT:  MOV     (R5)+,R0
$MEM:   JSR     PC,DIDDLY
        .BYTE   203
        .BYTE   360             ;MEM 0-3

$MQT:   MOV     (R5)+,R0
$MQ:    JSR     PC,DIDDLY
        .BYTE   207
        .BYTE   200             ;MQ SEL

$NUMT:  MOV     (R5)+,R0
$NUM:   JSR     PC,DIDDLY
        .BYTE   5
        .BYTE   167             ;CRAM # 3-8
        .BYTE   206
        .BYTE  7               ;CRAM # 0-2


;SEQ439

$SCT:   MOV     (R5)+,R0
$SC:    JSR     PC,DIDDLY
                .BYTE   202     
        .BYTE   2               ;SCM SEL 2

$SCADT: MOV     (R5)+,R0
$SCAD:  JSR     PC,DIDDLY
        .BYTE  11
        .BYTE   160             ;SCAD 4,2 & 1
        .BYTE   4
        .BYTE   300
        .BYTE   11
        .BYTE   200             ;SCADA DIS
        .BYTE 2
        .BYTE   10              ;SCADB SEL 1
        .BYTE   204
        .BYTE   40              ;SCADB SEL 2

$SHT:   MOV     (R5)+,R0
$SH:    JSR     PC,DIDDLY
        .BYTE   204
        .BYTE   3               ;SH-ARMM SEL 2 & 1


$TT:    MOV     (R5)+,R0
$T:     JSR     PC,DIDDLY
        .BYTE   200
        .BYTE   12              ;T00 & T01

$VMAT:  MOV     (R5)+,R0
$VMA:   JSR     PC,DIDDLY
        .BYTE   0
        .BYTE   200             ;VMA SEL 1
        .BYTE   204
        .BYTE   10              ;VMA SEL 2


;SEQ440

.SBTTL MWORD, XBUF & XBUF0 -- SUBROUTINES TO LOAD/EXECUTE THE COMMAND REGISTER
;***MWORD--LOAD A MICROWORD TO THE COMMAND REGISTER FROM THE MICROWROD BUFFER
;AND VERIFY THAT IT GOT IN THE CR CORRECTLY.  IF FLAG $NOCHK IS NON-ZERO,
;INIDCATING THAT THE ROUTINE WAS CALLED FROM THE INITALIZATION CODE,
;THE VERIFICATION IS BYPASSED.  UNDER THESE CONDITIONS MWORD "ATTEMPTS" TO
;LOAD THE COMMAND REGISTER.

;THE MICROWORD TO BE WRITTEN IS IN THE 12-BYTE BUFFER AT $MICRO AND THE
;C-RAM LOCATION TO LOAD IS IN $$CRAD.  IF BIT 15 OF $$CRAD IS SET
;NO MASTER RESET IS DONE BY THE ROUTINE (USER SHOULD CLEAR "DISP" FIELD
;TO ASSURE DISPATCH ON DIAGNOSTIC ADDRESS REG).
;THE CONTENTS OF THE C-RAM LOCATION ARE LOST.
;
;               CALL:   JSR     R5,$MWORD

$MWORD: PUSH    R1              ;SAVE R1 ON STACK

        MOV     $$CRAD,R0               ;PUT ADR TO BE WRITTEN IN R0.
        MOV     #$MICRO,R1              ;PUT ADR TO DATA IN R1.
        WCRAM                   ;WRITIE THE CRAM

        DFXCTT                  ;SINGLE STEP CLOCK TO CLOCK
        .WORD   SECLK          ;CRAM DATA TO CR

        MOV     #-1,R0          ;SDET UP TOR ED THE COMMAND REG
        RCRAM                   ;DO IT

        POP     R1              ;RESTORE R1
        TST     $NOCHK          ;SEE IF THE :NO CHECKING" FLAG IS FLYING
        BNE     MWRTN           ;AND BYPASS CHECK IF IT IS

        JSR     R5,$CHKMI       ;COMAPRE COMMAND REG TO $MICRO
        .WORD   $MICRO          ;PTR TO EXPECTED DATA
        .WORD   MWERR!BIT15    ;PTR TO EROR MESSAGE

MWRTN:  RTS     R5              ;RETURN IF NO ERROR (OTHEWISE TAKE ERROR

MWERR:  .ASCIZ/CRAM VERIFICATION ERROR INTERNAL TO TEST!/
.EVEN


;SEQ441


;***XBUF--LOAD THE COMMAND REGISTER AND GIVE AN EBOX CLOCK TO EXECUTE IT.
;THIS ROUTINE DOES AN :MWORD" FOLLOWED BY AN "ECLOK".

$XBUF:  JSR     R5,$MWORD

        ECLOK
        RTS     R5

;***XBUF0--LOAD THE CR AND EXECUTE IT BY LOADING IT AGAIN WITH 0'S
;(LEAVE THE CR AND THE MICROWORD BUFFER, $MICRO,CLEARED).

$XBUF0: JSR     R5,$MWORD       ;WRITE $MICRO TO CR
        JSR     R5,$CLR$M       ;CLEAR $MICRO
        JSR     R5,$MWORD       ;EECTUE AND CLEAR THE CR

        RTS     R5


;SEQ442

.SBTTL CHKMIC  -- SUBROUTINE TO COMPARE MICROCODE WORDS.

;CALL:  MOV     #ACTUAL,R0      ;R0 POINTS TO 1ST BYTE OF ACTUAL DATA.
;       CHKMIC                  ;SUBROUTINE CALL.
;       .WORD   EXPECT          ;POINTER TO 1ST BYTE OF EXPECTED DATA.
;       .WORD   ERROR!BIT15     ;POINTER TO ERROR TEXT (+INDIRECT FLAG).
;
;THE DATA IS ASSUMED TO BE IN THE INVERTED BYTE FORMAT USED BY CONSOLE
;ROUTINES RCRAM AND WCRAM.  NOTE THAT RCRAM RETURNS WITH R0 POINTING TO
;THE ACTUAL DATA READ AS REQUESTED BY THIS ROUTINE.
;
;FOR PURPOSES OF ERROR REPORTING, THIS ROUTINE ASSUMES THAT THE MICROCODE
;WORD ADDRESSED BY BUFFER LOCATION $$CRAD WAS BEIN COMPARED.

$CHKMI: CLR     CHKFLG          ;CLEAR ERROR FLAG
        SHOVE                   ;SAVE REGISTERS 1-4 ON STACK.
        MOV     R5,-(SP)        ;SAVE RETURN POINTER ON STACK.
        MOV     (R5)+,R1        ;PUT PTR TO EXPECTED DATA IN R1.
        MOV     #CMASK,R2       ;PUT PTR TO NONEX.  BIT MASK IN R2.
        MOV     #^D11,R3        ;COUNT 11 BYTE COMPARES IN R3.
        MOV#CKACT,R4            ;PTR TO SAVED ACTUAL DATA
        MOV     #CKEXP,R5       ;PTR TO SAVED EXPECTED DATA

CHKM1:  MOVB    (R0)+,(R4)      ;GET A BYTE OF ACTUAL DATA.
        BICB    (R2),(R4)       ;MASK OUT UNUSED CRAM BITS.
        MOVB    (R1)+,(R5)      ;GET A BYTE OF EXPECTED DATA.
        BICB    (R2)+,(R5)      ;AND MASK IT.
        CMPB    (R4)+,(R5)+     ;ARE THEY EQUAL?
        BEQ     CHKM2           ;NO ERROR, SKIP AROUND.
        MOV     #-1,CHKFLG      ;SET ERROR FLAG
CHKM2:  DEC     R3              ;OTHERWISE, UPDATE BYTE COUNT
        BNE     CHKM1           ;AND LOOP.

        TST     CHKFLG          ;ANY ERRORS?
        BNE     CHKMER          ;YES, GO REPORT THEM


;SEQ443

;HERE IF NO ERRORS:

CHKM3:  MOV     (SP)+,R5        ;GET UNUPDATED RETURN PTR.
        CMP     (R5)+,(R5)+     ;UPDATE IT.
        GRAB                    ;RESTORE R1-R4.
        RTS     R5              ;AND RETURN

;AND HERE IF ERROR FOUND:

CHKMER: MOV     ERSP..,R0       ;GET PTR TP THE ERROR STACK .
        MOV     #FT6,(R0)+      ;PUSH FORMAT ID ON ERROR STACK.
        MOV     #$$CRAD,(R0)+   ;POUSH PTR TO CRAM ADR ON ERROR STACK.
        BIC     #BIT15,$$CRAD   ;GET RID OF SIGN BIT FOR ERROR REPORTER
        MOV     #CKACT,R1       ;PUT ACTUAL DATA PTR IN R1.
        MOV     #^D11,R2        ;COUNT OF 11 TO R2.
1$:     MOVB    (R1)+,(R0)+     ;PUSH ACTUAL DATA BYTE ONTO ERROR STACK.
        DEC     R2              ;DOWN COUNT.
        BNE     1$              ;AND LOOP TILL DONE ALL/
        MOV     #CKEXP,R1       ;PUT EXPECTED DATA PTR IN R1
        MOV     #^D11,R2        ;COUNT AGAIN.
2$:     MOVB    (R1)+,(R0)+      ;PUSH 11 BYTES OF EXPECTED DAT ONTO
        DEC     R2              ;THE ERROR STACK.
        BNE     2$
        MOV     R0,ERSP..       ;RETURN UPDATED ERROR STACK PTR.

;FIX UP STACK BEFORE TAKING ERROR EXIT:

        MOV     (SP)+,R5        ;GET RETURN PC
        TST     (R5)+           ;BUMP TO PT TO ERROR MSG
        GRAB            ;RESTORE REGISTERS 1-4.

        MOV     (SP),R0         ;GET BUMP TO PT TO ERROR MSG
        MOV     R5,(SP)         ;PUT PTR TO ERR MSG IN ITS PLACE ON STACK
        MOV     R0,R5           ;TRANSFER SUBTESTM# TO R5

        JMP     FAULT           ;AND TAKE ERROR EXIT.

;MASK TABLE:
CMASK:  .BYTE   125             ;MASK OUT EVERY ODD BIT IN 1ST
        .BYTE   125             ;TWO BYTES.
        .BYTE   5               ;JUST TWO IN 3RD BYTE.
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   300             ;LEFT 2 IN LAST BYTE.
.EVEN
CHKFLG: .WORD   0               ;STORGE FOR EROR FLAG

CKACT:  .BLKB   ^D11            ;STORAGE FOR ACTUAL
CKEXP:  .BLKB   ^D11            ;STORAGE FOR EXPECTED


;SEQ444

.SBTTL MSK36 -- SUBROUTINE TO MASK AND COMPARE 36-BIT DATA

;36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON OF
;36-BITS OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT & LOADS
;THE ERROR STACK IF MISCOMPARE.
;       CALL IS:
        
;               JSR     R5,$MSK36
;       R3 = POINTER TO MASK (0S IMPLYU TEST)
;       R4 = POINTER TO EXPECTED DATA
;'      R2 = POINTER TO ACTUAL DATA

$MSK36: REGSAV                  ;TE FAMOUS 10% FAILURE
        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #4,R0           ;LOOP COUNT
1$:     MOVB    (R4)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R3),R1         ;MASK IT
        MOVB    (R2)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R3)+,R5        ;MASK IT
        TST     R0              ;DOING LAST BYTE?
        BNE     6$              ;NO, GO AROUND
        BICB    #360,R5         ;YES, MASK OFF ABSENT BITS
        BICB    #360,R1         ;CLEAR EXPECTED TOO
6$:     CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGE     1$              ;NO,LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     5$              ;NO, COMPARE. O.K.
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R3           ;RESTORE MASK POINTER
        MOV     R3,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R2           ;RESTORE ACTUAL POINTER
        MOV     #5,R5           ;
3$:     MOVB    (R2)+,(R0)+     ;ACTUAL TO ERROR STACK
        DEC     R5              ;
        BGT     3$              ;
        SUB     #5,R4           ;RESTORE POINTER TO EXPECTED
        MOV     #5,R5           ;
4$:     MOVB    (R4)+,(R0)+     ;EXPECTED TO ERROR STACK
        DEC     R5
        BGT     4$              ;
        MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        REGRST                  ;REGISTERS
        SEC                     ;SET C-BIT
        RTS     R5              ;RETURN
5$:     REGRST          
        CLC                     ;CLEAR DAMN C-BIT
        RTS     R5              ;RETURN
FFLAG:  0


;SEQ445

;36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).  USES $MSK36.
;
;CALL IS:
;       JSR     R5,$MK36T
;       ENTRY+2 = POINTER TO MASK (0S IMPLY TEST)
;       ENTRY+4 = POINTER TO EXPECTED DATA
;       ENTRY +6        = POINTER TO ACTUAL DATA

$MK36T: PUSH    <R3,R4,R2>

        MOV     (R5)+,R3        ;MASK POINTER TO R3
        MOV     (R5)+,R4        ;EXPECTED POINTER TO R4
        MOV     (R5)+,R2        ;ACTUAL POINTER TO R2
        JSR     R5,$MSK36       ;PERFORM THE TEST
        POP     <R2,R4,R3>


        RTS     R5              ;RETURN


;SEQ446

.SBTTL MICLD -- ROUTINE TO WRITE SEVERAL MICRO WORDS PER CALL

;THIS IS A SUBROUTINE TO WRITE MICRO CODE WORDS INTO THE MICRO CODE RAM.
;       CALL:   JSR     R5,$MICLD
;               .WORD   NUM             ;NUMBER OF LOCATIONS TO BE WRITTEN

        
;               .WORD   START           ;STARTING CRAM ADDRESS
;               .WORD   PDATA           ;ADDRESS OF DATA TO BE WRITTEN (OR "ZERO" OR "ON
;WILL FILL THE SPECIFIED NUMBER OF ADDRESSES SEQUENTIAALLY,
;STARTING WITH "ACTUAL STARTING ADDRESS", WITH ALL "ZEROS"
;OR ALL "ONES", OR VAIRABLE DATA, AS POINTED TO BY "POINTER TO DATA"

$MICLD: SHOVE                   ;SAVE REGISTERS
        MOV     (R5)+,R4        ;GET NUIMBER OF ADDR TO BE LOADED
        MOV     (R5)+,R3        ;GET STARTING MICRO RAM ADDRESS
        MOV     (R5),R2         ;GET KEYWORD (OR DATA POINTER)
        BGT     1$              ;BR IF KEY > THAN ZERO

;LTHIS SECTION SETS UP FOR DOING ONES OR ZEROES
        MOV     #6,R0           ;NEED 5 WORD MOVES TO FILL DATA AREA
        MOV     #100$,R1        ;MOVE ADDR OF DATA AREA TO R1
3$:     MOV     (R5),(R1)+      ;MOVE DATA TO FIRST BYTE
        DEC     R0              ;DONE FIVE YET?
        BNE     3$              ;LOOP IF NOT
        MOV     #100$,R2;       ;SET DATA POINTER

;COMMON CODE TO SEND OUT MICRO RAM DATA
1$:     MOV     R2,R1           ;MOVE POINTER TO DATA FOR WCRAM CALL
        MOV     R3,R0   ;CRAM ADDR IN T0
        WCRAM                   ;ISSUE CALL
        DEC     R4              ;DONE REQUIRED NUMBER OF WORDS?
        BEQ     8$              ;BR IF YES

;NOT DOEN, READY NEXT C-RAM WRITE
        INC     R3              ;INCREMENT TO NEXT CRAM ADDR
        TST     (R5)            ;SEE IF NEED NEW DATA
        BLE     1$              ;BR IF CAN USE OLD ONES OR ZEROES

        ADD     #^D12,R2        ;NEW DATA
        BR      1$              ;CONTINUE WITH BIGLOOP


;END UP CODE
8$:     GRAB                    ;RESTORE REGISTERS
        TST     (R5)+           ;STEP OVER DAT APTR
        RTS     R5              ;RETURN

100$:   
        .WORD 0,0,0,0,0,0


;SEQ447


.SBTTL ACSET -- A SUBROUTINE TO SET AC # FIELD

;TIS A SUBORUTINE FOR SETTING AND CHECKING THE AC# FIELD.  IF THE
;"NO CHECK" FLAG IS SET -- INCIDATING THAT THIS ROUTINE IS BEING USED
;BY SOME INITIALIZATION CODE -- THE CHECKING IS BYPASSED AND THE
;ROUTIE SIMPLY "ATTEMPTS" TOSET THE AC#.

;IT USES (AND LEAVES CLEARED) A 36 BIT WORK AREA, EWORD1, AND THE 80 BIT
;
;       CALL:   JSR     R5,$ACSTT
;               .WORD   VALUE           ;AC#, RIGHT JUSTIFIED
;       OR:
;               MOV     #VALUE, R0      ;AC#
;               JSR     R5,$ACSET

$ACSTT: MOV     (R5)+,R0                ;PICK UP AC#

$ACSET: PUSH    <R1,R0>                 ;GET REG AND SAVE DATA

        $CLRWD                          ;CLEAR OUT WORK AREA
        POP     R0                      ;GET DATA ACK
        BIC     #177760,R0              ;MAKE SURE NO EXTRA BITS ALONG FORRIDE
        MOVB    R0,EWORD1+3             ;PUT AC # IN EBUS BITS 8-11
        BISB    #BIT4,R0                ;SET BIT FOR "AC EN" IN EXPECTED DATA
        MOVB    R0,ACDAT        ;PUT AC# INTO EXPECTED DATA
        $RORWD                  ;ROTATE RIGHT TO PUT AC # IN 9-12
        
        $CLRMI                          ;ZERO MICROWORD BUFFER
        MOV     #LDAR,R0                ;SET UP TO LOAD THE IR
        MOV     #EWORD1,R1              ;PTR TO DATA
        DFWIR                   ;EMT
        POP     R1              ;RESTORE REGISTER BORROWED


;SEQ448



        DFXCTT                  ;STROBE LATCHES TO SET AC#
        .WORD   DRLTCH
        CLRB    EWORD1+3        ;LEAVE WORK AREAS CLEARED
        DFWRTT                  ;LEAVE AR CLEAN
        .WORD   EWORD1
        .WORD   LDAR

        TST     $NOCHK          ;SEE IF THE "NO CHECK" FLAG IS ON
        BNE     ACRTN           ;BYPASS TESTING IF IT IS

        DCOMP                   ;CHECK THE RESULTS
        .WORD   ACMSK           ;PTR TO MASK
        .WORD   ACFUN           ;PTR TO FUNCTION
        .WORD   ACBYT           ;PTR TO BYTE
        .WORD   ACDAT           ;PTR TO EXPECTED DATA
        .WORD   ACERM!BIT15             ;PTR TO ERROR MSG


ACRTN:  RTS     R5              ;AND RETURN

ACMSK:  .BYTE   340             ;COMPARE ONLY LEAST 5 SIGNIFICANT BITS
ACFUN:  .BYTE   RIR+2!BIT7      ;DO AN IR READ, ":OR" IN STOP CODE
        
ACBYT:  BYTPNT  EIR             ;READ EBUS BITS 13-17

ACDAT:  .BYTE   0               ;EXPECTED DATA GOES HERE
ACERM:  .ASCIZ/AN ATTEMPT TO SET THE AC # FIELD HAS FAILED TO VERIFY!/
.EVEN


;SEQ449

.SBTTL ARLOD2 -- SUBROUTINE TO LOAD AR WITHOUT AFFECTING IR

;CALLING SEQUENCE
;       MOV     #ADDR OF 36 BIT DATA,R0
;       JSR     R5,$ARLO2
;KEEP IN MIND THAT THIS ROUTINE STEPS THE EBOX CLOCK ONE TIME
;AND A NEW COMMAND GETS CLOCKED INTO THE CONTROL REGISTER

$ARLO2: PUSH    R1              ;SAVE R1

        MOV     R0,R1
        MOV     #LDAR,R0
        DFWRT                   ;THE DATA IS IN AR

        DFXCTT                  ;CLOCK THE MACHINE
        SECLK

        POP     R1              ;RETRIEVE REGISTERS

        RTS     R5              ;AND GONE

;***HERE IS A SPECIALIZED SUBORUTINE TO LOAD THE AR FROM BUFFER EWORD1:

$STUFF: DFWRTT                  ;EMT TO LOAD THE AR
        .WORD   EWORD1          ;DATA POINTER
        .WORD   LDAR            ;FUNCTION
        RTS     R5              ;AND THAT IS ALL


;SEQ450

.SBTTL FAMOUS DCOMP -- SUBROUTINE TO DO MULTIPLE MASKED BYTE COMPARES

;ROUTINE TO COMPARE AND CHECK CONTROL BITS IN RANDOM EBUS POSITIONS.
;IT REQURIES 4 TABLES:  1) A BYTE TABLE OF DIAGNOSTIC FUNCTIONS, 2)
;A BYTE TABLE OF EXPECTED DATA, 3) A BYTE TABLE OF MASKS, AND 4) A BYTE
;TALBE FO EBUS BIT POINTERS, WHICH SPECIFY THE EUS POSITION OF THE
;BYTE UNDER INSPECTION.
;THERE IS AN ALTERNATE CALL ENTRY, "SDCOMP",WHICH PROVIDES FOR
;CALLS FROM SUBROUTINES
;       CALL:   JSR     R5,$DCOMP
;               .WORD   PMASK           ;ADDRESS OF 1ST MASK BYTE
;               .WORD   PUNC            ;ADDRESS OF 1 DIAG FUNC BYTE
        
;               .WORD   PBYTE           ;ADDRESS OF 1ST EBUS BYTE PTR BYTE
;               .WORD   PEXP            ;ADDRESS OF 1ST EXPECTED DATA BYTE
;               .WORD   PMSG!BIT15      ;ADDRESS OF ERROR MSG!INDRIECT FLAG

SDCOMP: MOV     2(SP),SUBSAV    ;SAVE SUBTEST NUMBER
                
        BR      DCOMP1
$DCOMP: MOV     (SP),SUBSAV     ;SAVE SUBTEST NUMBER
DCOMP1: REGSAV                  ;SAVE REGS ON STACK
        MOV     (R5)+,R1        ;GET STARTING ADDRESS OF MASK LIST
        MOV     (R5)+,R2        ;ADDRESS OF DIAG FCN LIST
        MOV     (R5)+,R3        ;ADDRESS OBY BYTE POINTER LIST
        MOV     (R5)+,R4        ;ADDRESS OF EXPECTED DATA LIST
        MOV     R1, DCOMPM      ;SAVE INITIAL VALUE OF PTRS
        MOV     R2,  DCOMPF
        MOV     R3,DCOMPB
        MOV     R4,DCOMPX
1$:     MOVB    (R2),R0         ;PUT DIAG FCN IN R0
        BIC     #177600,R0      ;BIC THE BANNANA
        DFRD                    ;CALL TO READ EBUS

;SEQ451

;BEGIN SECTION OF CODE THAT TURNS BYTE POINT INTO REAL DATA
        MOV     R1,-(SP)        ;SAVE R1 FR AWHILE
        MOVB    (R3)+,R0        ;GET THE BYTE PONTER IN R0
        MOV     R0,R1           ;MAKE A SECOND COPY IN R1
        BIC     #177774,R0      ;GET DEXWD POINTER
        ASR     R1              ;MAKE R1 COPY WITH NO DEX PNT
        ASR     R1              ;TAKES TWO SHIFTSS
        ASL     R0              ;ADDRESS NEEDS TO BE EVEN FOR WORDS
        ADD     .DAT3,R0        ;GET RIGHT DEXWD
        MOV     (R0)+,TEMP.
        BIT     R1,#BIT3        ;TEST CROSS BOUNDARY BIT
        BEQ     2$              ;BRANCH IF FULL BYTE IN DEXWD
        MOVB    (R0),TEMP.
        SWAB    TEMP.           ;BECAUSE BYTE CROSSES DEX BOUNDARY
        BIC     #BIT3,R1        ;CLEAR CROSS BOUNDARY BIT
2$:     MOV     TEMP.,R5        ;PUT 16 EBUS ITS IN R5
        TST     R1              ;DO WE NEED TO SHIFT BITS
3$:     BEQ     4$              ;BR OUT IF NO, WITH BYTE IN R5
        ROR     R5              ;YES, SHIFT ONCE
        DEC     R1             ;DECREMENT COUNT
        BR      3$              ;LOOP

;DESIRED 8 BITS OF EBUS ARE RIGHT JUSTIFIED IN R5

4$:     MOV     (SP)+,R1        ;REPLACE R1 FROM STACK
        BICB    (R1),R5 ;MASK THE BYTE IN R5
        MOVB    (R4)+,R0        ;PUT EXPECTD IN R0
        BICB    (R1)+,R0        ;MASK OUT BITS
        CMPB    R0,R5           ;COMPARE REAL VS. EXPECTED
        BNE     6$              ;BRANCH AWAY IF BAD COMPRE
5$:     BITB    (R2)+,#BIT7    ;SEE IF DONE WITH LIST
        BNE     8$              ;IS YES BR TO DONE STUFF
        INC     IINDEX          ;OTHERWISE, INCREMENT TABLE INDEX
        BR      1$              ;GO TO NEXT LIST ELEMENT

;YOU'LL BRANCH HERE IF BAD DATA

6$:     MOV     ERSP..,R0       ;GET ERR STACK IF FIRST ERROR
        TST     ERRFG.          ;TEST IF THIS WAS FIRST ERROR
        BNE     7$              ;BRANCH IF NOT FIRST ERROR
        MOV     #FT3,(R0)+      ;LOAD STACK WITH ERROR FORMAT
        MOV     DCOMPF,(R0)+    ;LOAD BASE ADDR DIAG FCNS
        MOV     DCOMPB,(R0)+    ;LOAD BASE ADDR BYT PNT
        MOV     DCOMPM,(R0)+    ;LOAD BASE ADDR MASKED DATA
        MOV     DCOMPX,(R0)+    ;LOAD BASE EXPECTED DATA
        MOV     R0,ERRFG.       ;SET ERR FLAG TO SAY ERROR


;SEQ452

;NOW STACK TABLE INDEX AND ACTUAL RECEIVED DATA

7$:     MOVB    R5,IINDEX+1     ;PUT ACTUAAL RECEIVED IN CORE
        MOV     IINDEX,(R0)     ;PUT INDEX AZND DDATA ON STACK
        SWAB    (R0)+           ;REARRANGE
        MOV     R0,ERSP..       ;TERMINATE ERR STACK GRACEFULLY
        BR      5$              ;GO BACK TO MAINLINE


;FINISH UP CCODE

8$:     CLR     IINDEX          ;RESET INDEX COUNT
        REGRST                  ;PUT BACK REGISTERS
        TST     ERRFG.          ;WERE THERE ANY ERRORS
        BEQ     9$              ;GO FINISH IF NONE
        MOV     ERSP..,R0       ;GET ERROR STACK PTR
        BIS     #BIT15,-(R0)    ;IF THERE WERE ERRORS
        CLR     ERRFG.          ;RESET ERROR FLAG
        MOV     (SP),R0 ;PUT SUBTEST # IN R0
        ADD     #10,R5          ;MAKE R5 PONT TO THE RRROR MSG
        MOV     R5,(SP)         ;SWAP RETURN ADR FOR PTR TO ERROR MSG
        MOV     SUBSAV,R5               ;EPORT SUBTEST NR TO EXEC
        JMP     FAULT           ;TAKE ERROR RETURN TO EXEC

9$:     CLR     ERRFG.          ;CLEAR ERROR FLAG
        ADD     #12,R5          ;GO AROUND ERROR MESSAGE
        RTS     R5              ;AND RETURN

IINDEX: 0
        
ERRFG.: 0
TEMP.:  0
DCOMPF: 0                       ;STORAGE FOR POINTERS
DCOMPB: 0
        
DCOMPM:  0
DCOMPX: 0
SUBSAV: 0


;SEQ453

.SBTTL FAMOUS MCOMP -- SUBROUTINE TO MODIFY DCOMP'S TABLES

;MCOMP MODIFIES ONE OR MORE OF THE ENTRIES IN A DCOMP BYTE
;COMPARISON TABLE.  TE BASE ADDRESS OF THE DCOMP TABLE IS IN LOCAITON
;"DCOMPX" WHERE DCOMP STORES IT; IF MCOMP IS USED BEFORE THE FIRST
;DCOMP CALL, THE CALLING PROGRAM MUST STORE THIS ADDRESS.  THE CALL
;IS MADE WITH R2 POINTING AT A LOCATION CONTAINING THE NUMBER
;OF LOCATIONS TO CHANGE AND R3 POINTING TO THE FIRST ENTRY ION
;A SPECIAL MCOMP CHANGE TABLE.
;
;ENTRIES IN THE LATTER TABLE ARE "INDEX":/"NEW DATA" [AIORS.
;       FOR EXAMPLE: TO CHANGE THE 1ST BYTE IN A DCCOMP TABLE
;       TRO -5 AND THE 3RD BYTE TO 55, THE FOLLOWING CODE
;       IS NEEDED:


        

;       MOV     #TNUM,R2
;       MOV     #TADR,R3
;       JSR     R5,$MCOMP
;               .
;               .
;TNUM:  .BYTE   2
;
;TADR:  .BYTE   0               (NOTE THAT INDEX OF 1ST BYTE IS 0)
;       .BYTE   -5
;       .BYTE   2
;       .BYTE   55
;
;NOTE THAT R2=TNUM+1 AND R3=TADR+4 AFTER THIS CALL.  HENCE MCOMP LISTS
;MAY BE "CHAINED".
;
;MCOMP KEEPS A TABLE OF THE REPLACED DCOMP TALBE VALUES AT "RRSTOR"
;(UP TO A MAXIMUM OF 11) AND CAN BE FOLLOWED BY AN RCOMP CALL TO
;RESTORE THE DCOMP TABLE OT ITS PREVIOUS STATE.  SINCE REPEATED MCOMP
;CALLS REUSE THIS TABLE, VALJES RESTORED BY RCOMP WILL BE THOSE THAT
;EXISTED BEFOE THE MOST RECENT MCOMP CALL.


;SEQ454

;HERE WE GO:

$MCOMP: PUSH    <R1,R4,R5>      ;SAVE REGISTERS

;R1=# OF CHANGES LEFT TO DO, R4 WILL HOLD ADR OF DCOMP TABLE
;ENTRY BEING MODIFIED & R5 POINTS AT STORAGE TABLE.

        MOVB    (R2)+,R1        ;PUT # OF CHANGES TO BE MADE IN R1
        BEQ     2$              ;IF ZERO,DO NOTHIN'
        MOV     #RRSTOR,R5      ;GET ADDR OF STORAGE TBL
1$:     MOVB    (R3)+,R4        ;INDEX INTO DCOMP GOES IN R4
        MOVB    R4,(R5)+        ;WRITE SAME INDEX TO STORAGE TBL
        ADD     DCOMPX,R4       ;MAKE EXPECTED DATATBL ADR
        MOVB    (R4),(R5)+      ;SAVE DATA ABOUT TO CHANGE IN STORAGE TBL
        MOVB    (R3)+,(R4)      ;PUT NEW DATA INTO XPECT TBL
        DEC     R1             ;DECREMENT COUNT
        BNE     1$              ;LOOP IF MORE ELEMENTS
        MOVB    #377,(R5)       ;SET END OF STORAGE TBL FLAG
        INC     TATTLE          ;SET A FLAG FOR RCOMP
2$:     POP     <R5,R4,R1>      ;RESTORE REGISTERS


        RTS     R5              ;RETURN


TATTLE: .WORD   0               ;THE FAMOUS MCOMP/RCOMP FLAG


;SEQ455

.SBTTL FAMOUS RCOMP ROUTINE
;THE RCOMP ROUTINE IS TO "RESTORE" DATA CHANGED BY MCOMP
;ROUTINE. IT ONLY RESTORES THE EXPECTED TABLE A IT APPEARED
;BEFORE THE MOST RECENT MODIFICATION. CALL MCOMP#1; CALL MCOMP#2
;CALL MCOMP#3;CALL MCOMP#4;CALL RCOMP.  THE XPECTED TALBE WILL
;NOW LOOK AS IT DID AFTER MCOMP#3.
;
;THERE MUST HAVE BEEN A NONZERO MCOMP CLL SINCE THE LAST RCOMP
;CALL FOR RCOMP TO TAKE ANY ACTION.
;
;CALL   ;
;       JSR     R5,$RCOMP
;
;


$RCOMP: TST     TATTLE          ;HAS MCOMP DONE ANYTHING LATELY?
        BEQ     2$              ;NOPE, DON'T DO NOTHIN'


        SHOVE                   ;YUP, SAVE REGISTERS
        MOV     #RRSTOR,R1      ;GET STORAGE TBL ADDR
1$:     MOVB    (R1)+,R2        ;MOVE INDEX TO R2(SHOULD NEVER BE NEG)
        ADD     DCOMPX,R2       ;INDEX XPECTED TABLE
        MOVB    (R1)+,(R2)      ;REPLACE DATA IN EXPECTED TBL
        TSTB    (R1)            ;SEE IF END OF REPLACEMENTS
        BPL     1$              ;LOOP BACK IF NOT
        COM     RRSTOR          ;IF END PUT DONE FLAG AT FIRST TBL LOC.
        CLR     TATTLE          ;AND CLEAR MCOMP'S FLAG.
        
        GRAB                    ;RESTORE REGISTERS
2$:     RTS     R5              ;RETURN

;MCOMP CAN HANDLE 23 CHANGES

RRSTOR: .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0


;SEQ456

.SBTTL PATTY -- A SUBROUTINE TO GENERATE TEST PATTERNS

;ROUTINE TO GENERATE A COMPLETE SET OF TEST PATTERNS FOR CHECKING AN
;N-BIT WIDE DATA PATH FOR 1) NO BIT STUCK AT "0" OR "1", AND 2) NO
;TWO BITS INTERACTING.
;
;THREE INITIAL ENTRY POINTS ARE GIVEN FOR COMMON KL-10 DATA PATH
;WIDTHS OF 80, 36, AND 16 BITS.
;
;PATTERNS ARE STORED IN INVERSE BYTE FORMAT BEGINNING AT THE LOCATION
;POINTED TO BY R0 AT INITIAL ENTRY.  THE ROUTINE RETURNS THE PATTERN
;NUMBER IN R0.  IF ALL PATTERNS HAVE BEEN DONE, IT RETURNS A 0 IN R0.
;
;THE NUMBER OF PATTERNS GENERTED IS 14 FOR 80 BIT WIDTH, 12 FOR 36 BIT WIDTH,
;AND 8 FOR 16 BIT WIDTH.
;
;THE PATTERNS PRODUCED ARE:
;       1) 0001 0001 0001 ....
;       2) 0010 0010 0010 ....
;       3) 0100 0100 0100 ....
;       4) 1000 1000 1000 ....
;       5) BC BC BC BC BC BC ....

;       6) CB CB CB CB CB CB ....
;       7) BB CC BB CC BB ....
;       8) CC BB CC BB CC ....
;       9)BB BB CC CC BB ....
;    10) CC CC BB BB CC ....
;     11) BB BB BB BB CC ....
;     12) CC CC CC CC BB ....
;       13) 16 B'S AND 4 C'S 
;    14) 16 C'S AND 4 B'S
;               WHERE B = 0001 AND C = 1110
;
;INITIAL CALL:  MOV     #PTR,R0         ;PUT ADR OF 1ST BYTE TO BE FILLED IN R0
;               JSR     R5,$PAT80       ;FOR 11 BYTE PATTERNS
;       OR      JSR     R5,$PAT36       ;FOR  5 BYTE PATTERNS
;       OR      JSR,$PAT16              ;FOR  2 BYTE PATTERNS
;
;SUBSEQUENT CALLS:
;               JSR     R5,$PATCO


;SEQ457

;INITIALIZATION ENTRY  POINTS
        PNO=R2          ;NUMBER OF PATTERNS
        BNO=R0          ;NUMBER OF BYTES
        BITPNT=R4       ;BIT POINTER


;ENTRY CODE FOR MICRO RAM PATTERN
$PAT80: MOV     #^D10,BMAX      ;SET MAXIMUMWIDTH OF PATTERN
        MOV     #^D14,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY
;ENTRY CODE FOR 36 BIT PATTERN
$PAT36: MOV     #4,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS
        MOV     #^D12,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY

;ENTRY CODE FOR DRAM PATTERNS

$PAT16: MOV     #1,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS
        MOV     #^D8,PMAX       ;SET ACTUAL NUMBER OF PATTERNS

PATTY:  SHOVE                   ;SAVE THE REGISTERS
        ADD     BMAX,R0         ;FORM PTR TO LAST YTE
        MOV     R0,MULBUF       ;AND SAVE IN MULBUF
        MOVB    #21,PAT         ;PAT HAS BASIC PATTERN BYTE
        CLR     PNO             ;CLR PN0,NUMBER OF PATTERNS GENERATED
        MOV     #1,BITPNT       ;SET THE BIT POINTER TO BIT0
PGENRE: MOVB    PAT,COMPAT      ;COMPAT WILL HAVE THE BASIC PATTERN
        COMB    COMPAT          ;BUT IN COMPLIMENTED FORM
NOCOMP: CLR     BNO             ;CLR NUMBER OF BYTES DONE
4$:     CMP     BMAX,BNO        ;IS BNO > BMAX??
        BMI     5$              ;BRANCH OUT OF LOOP IF YES
        CMP     #6,PNO          ;DOING FIRST 6 PATTERNS?
        BGT     2$              ;BRNACH IF YES
        BIT     BITPNT,BNO      ;OUTPUT PATTERN OR COMPLIMENT?
        BEQ     2$              ;BRQANCH IF KEY BIT IN BNO IS CLEAR

;GADZOOKS, OUTPUT COMPLIMENT BYTE!
        MOVB    COMPAT,@MULBUF
        BR      3$              ;AND CONTINUE
;GADZOOKS, OUTPUT REAL BYTE!
2$:     MOVB    PAT,@MULBUF
3$:     DEC     MULBUF  
        INC     BNO             ;INCREMENT BNO FOR NEXT BYTE
        BR      4$              ;AND LOOP BACK


;SEQ458

;HERE IF DONE ONE OF THE MANY PATTERNS

5$:     INC     PNO             ;INCREMENT TO NEXT PATTERN
        MOV     R0,CORE0        ;SAVE THE CURRENT STATE OF REG'S
        MOV     R2,CORE2
        MOV     R4,CORE4
        ADD     BMAX,MULBUF
        INC     MULBUF          ;THERE WAS ONE EXTRA DEC - FIX IT UP
        MOV     PNO,MULBU1      ;SAVE PATTERN NUMBER FROM CLUTCHES OF GRAB
        GRAB
        MOV     MULBU1,R0       ;PUT PATTERN NUMBER IN R0 FOR RETURN
        RTS     R5

;YOU WILL REENTER HERE TO CONTINUE WIT ADDITIONAL PATTERNS

$PATCO: SHOVE
        MOV     CORE4,R4                ;GET MULPATS LAST STATE
        MOV     CORE2,R2
        MOV     CORE0,R0
        CMP     #3,PNO          ;IS PNO<4??
        BMI     8$              ;BRANCH IF NO
        ASLB    PAT             ;SHIFT PATTERN
        JMP     PGENRE          ;AND REENTER THE LOOP

8$:     CMP     PNO,PMAX                ;DONE ALL PATTERNS?
        BHIS    9$              ;GADZOOKS, GET THE HECK OUT HERE IF YES


;SEQ459

;PATTERNS 5 - 8 NEED SPECIAL HANDLING...DIFFERENT STROKES FOR DIFFERENT FOLKS.
        CMP     #4,PNO          ;ISTHIS PATTERN #5?
        BMI     10$             ;BRANCH IF NOT
        MOVB    #36,PAT         ;LOAD PATTERN FOR #5
        JMP     PGENRE          ;AND GO BACK
10$:    CMP     #5,PNO          ;IS THIS PATTERN #6?
        BMI     11$             ;BRANCH IF NOT
        MOVB    #341,PAT        ;LOAD PATTERN FOR #6
        JMP     PGENRE          ;AND GO BACK
11$:    CMP     #6,PNO  ;IS THIS PATTERN #7?
        BMI     12$             ;BRANCH IF NOT
        MOV     #10756,PAT      ;SET PAT = 356, COMPAT = 21 FOR REST OF PATTERNS
12$:    SWAB    PAT             ;EXCHANGE PATTERN AND COMPLIMENT OF PATTERN
        CMP     #7,PNO          ;ARE WE DOING 7 AND 8

        BGE     NOCOMP          ;IF SO, TAKE A SHORT CUT
        BIT     #BIT0,PNO       ;TEST BIT 0 OF PNO, BR IF ODD
        BNE     PGENRE
        ASL     BITPNT          ;SHIFT BIT POINTER IF EVEN
        JMP     PGENRE          ;AND RETURN TO THE GIG LOOP

9$:     GRAB
        CLR     R0
        RTS     R5

;PLACES TO SQUIRREL AWAY STUFF:

BMAX:   0
PMAX:   0
PAT:    .BYTE   0
COMPAT: .BYTE   0
CORE0:  0
CORE2:  0
CORE4:  0
MULBUF: 0
MULBU1: 0


;SEQ460


.SBTTL SUBROUTINE FOR DOING MCOMP-DCOMP-RCOMP SEQUENCES
.SBTTL          CLKMCR -- CLOCK BOARD MODIFY-COMPARE-RESTORE

;THIS SUBROUTINE USED BY TEH CLOCK BOARD AND RAM BOARD TESTS, PERFORMS THE
;FOLLOWING SEQUENCE:
;       1) MODIFY THE CLOCK BOARD'S EXPECTED DATA TABLE AS SPECIFIED BY
;          R2 AND R3 USING MCOMP
;       2) FIXUP THE SOURCE & RATE BASED ON DATA POINTED TO BY R0
;       3) COMPARE USING DCOMP
;       4) RESTORE THE EXPECTED DATA TABLE USING RCOMP

;ON ENTRY:      R0 PTS TO SOURCE/RATE DATA IN EFFECT

;               R2 PTS TO # OF CHANGES TO MAKE
;               R3 PTS TO FIRST "NEW DATA/INDEX" ENTRY FOR MCOMP

;CALL:  CLKPRM          ;GET PTR TO SOURCE/RATE INFO FROM KLDCP IN R0
;       JSR     R5,$CLKMC

$CLKMC: MOV     #BONG,DCOMPX            ;SET THE COMP DATA PTR
        $MCOMP


;SEQ461

;SUBROUTINE TO READ THE STATE OF THE CLOCK BOARD USING DCOMP.

$CLKCM: SHOVE           ;SAVE REGS 1-4 ON STACK

;CORRECT MODIFIED DATA FOR SOURCE & RATE IN USE

        MOVB    (R0),R0 ;GET SOURCE/RATE IN R09
        MOV     #10,R1  ;SOURCE RAT BIT MASK TO R1
        MOV     #BONG+10,R2     ;PTR TO LAST EXPECTED DATA BYTE IN R2
        MOV     #4,R3           ;COUNT OF 4 TO R3

CHIME:  ASR     R0              ;SHIFT SOURCE/RATE BIT TO C
        BCS     COG             ;SKIP IF BIT IS SET
        BICB    R1,-(R2)        ;OTHERWISE, CLEAR CORRESPONDING BIT IN DATA
        BR      CASE
COG:    BISB    R1,-(R2)        ;SET, SO SET CORRESPONDING BIT IN DATA

CASE:   DEC     R3              ;DOWN COUNT
        BGT     CHIME           ;DO MORE
        GRAB                    ;DONE,R ESTORE REGISTERS
        JSR     R5,SDCOMP               ;BYTE TABLE COMPARE
        .WORD   TICK
        .WORD   TOCK
        .WORD   BING
        .WORD   BONG

$CLKEM: .WORD   0

        $RCOMP
        RTS     R5              


;SEQ462

;HERE ARE THE DCOMP TABLES FOR THE CLOCK BOARD:

TICK:   .BLKB   10              ;STORAGE FOR MASKS (FILLED IN BY ICLOCK)

TOCK:   .BYTE   RCLK            ;DIAGNOSTIC FUNCTIONS
        .BYTE   RCLK+1
        .BYTE   RCLK+2
        .BYTE   RCLK+3
        .BYTE   RCLK+4
        .BYTE   RCLK+5
        .BYTE   RCLK+6
        .BYTE   RCLK+7!BIT7

BING:   .REPT   10              ;EBUS BITS
        BYTPNT  ECLK
        .ENDR

BONG:   .BLKB   10              ;STORAGE FOR EXPECTED BYTES




;SEQ463

.SBTTL  CTLMCR -- CONTROL LOGIC MODIFY-COMPARE-RESTORE

;THIS SUBROUTINE, USED BY MOST OF THE CONTROL BOARD TESTS, PERFORMS THE
;FOLLOWING SEQUENCE:
;       1) MODIFY THE CONTROL BOARD EXPECTED DATA TABLE AS SPECIFIED BY
        ;  R2 & R3 USING MCOMP
;       2)DO A COMPARISON USING DCOMP AND THE COMMON CONTROL BOARD TABLES
;       3) RESTORE EXPECTED DATA TABLE TO PREVIOUS VALUES USING RCOMP
;
;ON ENTRY:  R2 POINTS TO THE NUMBER OF EXPECTED DATA TABLE CHANGES REQURIED
;           R3 POINTS TO THE FIRST MCOMP "NEW DATA/INDEX" PAIR
;
;       CALL:   JSR     R5,$CTLMC

$CTLMC: MOV     #CTLDAT,DCOMPX  ;SET CONTROL BOARDS EXPECTED DATA TABLE ADDRESS
        JSR     R5,$MCOMP       ;MODIFY EXPECTED DATA TABLE

;SUBROUTINE TO DO A MERE DCOMP WITH NOTHIN SEXY
$CTLCM: JSR     R5,SDCOMP               ;BYTE TABLE COMPARE
        .WORD   CTLMSK
        .WORD   CTLFUN
        .WORD   CTLBYT
        .WORD   CTLDAT
BOGEY:  .WORD   0

        JSR     R5,$RCOMP               ;RESTORE DATA
        RTS     R5              ;AND RETURN

;SEQ464

;HERE ARE THE DCOMP TABLES FOR THE CONTROL LOGIC:
CTLMSK: .BLKB   44              ;STORAGE FOR MASKS (FILLED IN BY ICON)

CTLFUN: .BYTE   RAPR            ;DIAGNOSTIC FUNCTION FOR INDEX 0
        .BYTE   RAPR+1          ;1
        .BYTE   RAPR+4          ;2

        .BYTE   RAPR+5          ;3
        .BYTE   RAPR+2          ;4
        .BYTE   RAPR+3          ;5
        .BYTE   RAPR+6          ;6
        .BYTE   RAPR+7          ;7
        .BYTE   RAPR            ;10
        .BYTE   RAPR+1          ;11
        .BYTE   RAPR+4          ;12
        .BYTE   RAPR+5          ;13

        .BYTE   RCON            ;14
        .BYTE   RCON+1          ;15
        .BYTE   RCON+2          ;16
        .BYTE   RCON+3          ;17
        .BYTE   RCON+4          ;20
        .BYTE   RCON+5          ;21
        .BYTE   RCON+6          ;22
        .BYTE   RCON+7          ;23

        .BYTE   RMCL            ;24
        .BYTE   RMCL+1          ;25
        .BYTE   RMCL+2          ;26
        .BYTE   RMCL+3          ;27
        .BYTE   RMCL+4          ;30
        .BYTE   RMCL+5          ;31
        .BYTE   RMCL+6          ;32
        .BYTE   RMCL+7          ;33

        .BYTE   RCTL            ;34
        .BYTE   RCTL+1          ;35
        .BYTE   RCTL+2          ;36
        .BYTE   RCTL+3          ;37
        .BYTE   RCTL+4          ;40
        .BYTE   RCTL+5          ;41
        .BYTE   RCTL+6          ;42
        .BYTE   RCTL+7!BIT7     ;43


;SEQ465

CTLBYT: BYTPNT  8       ;EBUS BYTE FOR INDEX 0
        BYTPNT  9               ;1
        BYTPNT  9       ;2
        BYTPNT  9       ;3

        BYTPNT  13      ;4
        BYTPNT  13      ;5
        BYTPNT  13      ;6
        BYTPNT  13      ;7
        BYTPNT  16      ;10
        BYTPNT  17      ;11
        BYTPNT  17      ;12
        BYTPNT  17      ;13



        .REPT   10      ;INDEXES 14-23
        BYTPNT  24
        .ENDR


;SEQ466

        .REPT   10              ;INDEXES 24-33
        BYTPNT  23
        .ENDR
 
 
 
 
 
 
 
 
 
        .REPT   10              ;INDEXES 34-43
        BYTPNT  31
        .ENDR
 
 
 
 
 
 
 
 
 

CTLDAT: .BLKB   44              ;STORAGE FOR EXPECTED DATA


 

;SEQ467

.SBTTL  *ROUTINES WHICH ALTER BYTES IN THE CONTROL LOGIC TABLES*

;CALLS: 
;       JSR     R5,$MEMRQ               ;EXPECT MEMORY REQUEST BYTES TRUE

;       JSR     R5,$NOMRQ               ;RESTORE TO NO MEMORY REQUEST STATUS

;       JSR     R5,$NOCO                ;EXPECT "-CON COND EN 00-07" FALSE

$MEMRQ: MOVB    #112,CTLDAT+17  ;EXPECT "-CON MEM CYCLE"TRUE
        CLRB    CTLDAT+27               ;EXPECT "-MCL REQ EN" TRUE
        MOVB    #67,CTLDAT+33           ;EXPTECT :MCL MBOX CYCLE REQ" TRUE
        RTS     R5              ;DONE, RETURN.

$NOMRQ: MOVB    #113,CTLDAT+17          ;EXPECT "-CON MEMCYCLE" FALSE
        MOVB    #20,CTLDAT+27           ;EXPECT "-MCL REQ EN" FALSE
        MOVB    #65,CTLDAT+33   ;EXPECT "MCL MBOX CYCLE REQ" FALSE
        RTS     R5              ;DONE,R ETURN


$NOC0:
        MOVB    #174,CTLDAT+16          ;EXPECT "-CON COND EN 00-07"FALSE
        RTS     R5              ;DONE, RETURN


;SEQ468

.SBTTL  IRMCR -- IR/DRAM BOARD MODIFY-COMPARE-0RESTORE

;THIS ROUTINE WORKS LIKE CTLMCR FOR THE IR/DRAM BOARD.

$IRMCR: MOV     #COUGAR,DCOMPX          ;SET DCOMP'S PTR TO IR BOARD
        $MCOMP

;SUBROUTINE TO COMPARE SIGNALS ON THE IR/DRAM BOARD:

$IRCMP: JSR     R5,SDCOMP               ;BYTE TABLE COMPARE
        .WORD   LION            ;MASK TABLE
        .WORD   TIGER           ;FUNCTION TABLE
        .WORD   RHINO           ;BYTE TABLE
        .WORD   COUGAR          ;EXPECTED
$IREM:  .WORD   0

        $RCOMP

        RTS     R5


;SEQ469

;DCOMP TABLES FOR IR/DRAM BOARD:

LION:   .BYTE   361             ;"NORM" BITS MASKED OFF.
        .BYTE   3               ;READ ALL BITS.
        .BYTE   300             ;READ ALL BITS.
        .BYTE   3               ;REALL BITS.
        .BYTE   203             ;READ ALL BUT "TEST SATISFIED".
        .BYTE   360             ;READ J FIELD BITS.
        .BYTE   357             ;READ JUST I/O LEGAL BIT.

TIGER:  .BYTE   RIR             ;DIAGNOSTIC FUNCTIONS TO USE.
        .BYTE   RIR+1
        .BYTE   RIR+2
        .BYTE   RIR+3
        .BYTE   RIR+4
        .BYTE   RIR+5
        .BYTE   RIR+6!BIT7

RHINO:  BYTPNT  18              ;EBUS BIT TO POSITION BYTE ON.
        BYTPNT  19              
        BYTPNT  17
        BYTPNT  19
        BYTPNT  19
        BYTPNT  17
        BYTPNT  17

COUGAR: .BLKB   7               ;STORAGE FOR EXPECTED DATA
        .EVEN


;SEQ470

.SBTTL  FLGMCR -- PC FLAG LOGIC MODIFY-COMPARE-RESTORE

;THIS ROUTINE WORKS LIKE CTLMCR FOR PC FLAG LOGIC ON SCD BOARD.

$FLGMC: MOV     #BLAM,DCOMPX    ;SET DCOMP'S PTR TO SCD BOARD.
        $MCOMP

;SUBROUTINE TO COMPARE PC FLAG SIGNALS ON SCD BOARD:

$FLGCM: JSR     R5,SDCOMP       ;BYTE TABLE COMPRE ROUTINE
        .WORD   BIFF            ;MASK TABLE
        .WORD   POW             ;FUNCTION TABLE
        .WORD   SOCK            ;BYTE TABLE
        .WORD   BLAM            ;EXPECTED DATA TABLE
$FLGEM: .WORD   0               ;ERROR MSG PTR GOES HERE

        $RCOMP
        RTS     R5              ;RETURN.


;SEQ471

;DCOMP TABLES FOR PC FLAGS:

BIFF:   .BYTE   7               ;MASKS
        .BYTE   7
        .BYTE   7
        .BYTE   7
        .BYTE   17
        .BYTE   7
        .BYTE   7
        .BYTE   3

POW:    .BYTE   RSCAD           ;DIAGNOSTIC FUNCTIONS
        .BYTE   RSCAD+1
        .BYTE   RSCAD+2
        .BYTE   RSCAD+3
        .BYTE   RSCAD+4
        .BYTE   RSCAD+5
        .BYTE   RSCAD+6
        .BYTE   RSCAD+7!BIT7

SOCK:   .REPT   10              ;EBUS BIT TO POSITION BYTE ON
        BYTPNT  9
        .ENDR

BLAM:   .BLKB   10

        .EVEN


;SEQ472

.SBTTL          SCDMCR -- SC LOGIC MODIFY-COMPARE-RESTORE

;THIS ROUTINE DOES A STANDARD COMPARISON OF THE SC AND FE REGISTERS,
;THE UPPER 8 BITS OF THE AR, AND A FEW OCNTROL SIGNALS AGAINST
;A MODIFIED EXPECTED DATA TABLE USING SUBROUTINES MCOMP,DCOMP,
;AND RCOMP.  IT IS SIMILAR TO CTLMCR AND REGISTER AND CALLING
;CONVENTIONS ARE THE SAME.

$SCDMC: MOV     #SCDDAT,DCOMPX  ;SET COMPARIOSN ROUTINE'S PTR TO SCD DATA
        JSR     R5,$MCOMP       ;MODIFY THE SCD'S EXPECTED DATA TABLE.

;ENTER HERE TO COMPARE AGAINST EXPECTED DATA WITHOUT MODIFICATION:

$SCDCM: JSR     R5,SDCOMP               ;DO THE COMPARIOSN USING DCOMP
        .WORD   SCDMSK          ;PTR TO MASK TABLE
        .WORD   SCDFUN          ;PTR TO DIAGNOSTIC FUNCTION TABLE
        .WORD   SCDBYT          ;PTR TO EBUS BYTE SELECTOR TABLE
        .WORD   SCDDAT          ;PTR TOE XPECTED DATA TABLE
$SCDEM: .WORD   0               ;SPACE FOR PTR TO ERROR MSG

        JSR     R5,$RCOMP       ;RESTORE EXPECTED DATA TABLE, IF MODIFIED.
        RTS     R5              ;RETURN

;THE 10-BIT ARITHMEITC DCOMP TABLES:


SCDMSK: .BYTE   7               ;READ SC05-SC09, LEFT JUSTIFIED
        .BYTE   340             ;READ SC00-SC04,RIGHT JUSTIFIED
        .BYTE   7               ;READFE05-FE09, LEFT JUSTIFIED
        .BYTE   340             ;READ FE-00-FE04, RIGHT JUSTIFIED
        .BYTE   17              ;READ AR05-AR08, LEFT JUSTIFIED
        .BYTE   340             ;READ AR00-AR04, RIGHT JUSTIFIED
        .BYTE   376             ;READ "SC SIGN", RIGHT JUSTIFIED
        .BYTE   376             ;READ "SC.GE.36", RIGHT JUSTIFIED
        .BYTE   376             ;READ "FE SIGN", RIGHT JUSTIFIED
        .BYTE   376             ;READ "-SCAD=0",RIGHT JUSTIFIED

SCDFUN: .BYTE    130             ;0: DIAGNOSTIC FUNCTIONS
        .BYTE   131             ;1
        .BYTE   132             ;2
        .BYTE   133             ;3
        .BYTE   120             ;4
        .BYTE   120             ;5
        .BYTE   134             ;6
        .BYTE   136             ;7
        .BYTE   135             ;10
        .BYTE   133!BIT7                ;11 (WITH STOP BIT SET)


;SEQ473

SCDBYT: BYTPNT  14              ;0:EBUS BYTE POINTERS
        BYTPNT  11              ;1
        BYTPNT  14              ;2
        BYTPNT  11              ;3
        BYTPNT  12              ;4
        BYTPNT  4               ;5
        BYTPNT  7               ;6
        BYTPNT  7               ;7
        BYTPNT  7               ;10
        BYTPNT  4               ;11

SCDDAT: .WORD   0,0,0,0,0       ;STORAGE FOR EXPECTED DATA
        .EVEN
.SBTTL          PI.CH -- PI BOARD MODIFY-COMPARE-RESTORE

$PI.CH: JSR     R5,SDCOMP       ;CALL FOR A COMPARE
        .WORD   PIZMSK ;MASK LIST
        .WORD   PIZFUN          ;DIAGNOSTIC FUNCTION LIST
        .WORD   PIZBYT          ;BYT POINTERS
        .WORD   PIZEXP          ;LIST OF EXPECTED
PIZZA.PI:       .WORD   0               ;ERROR MESSAGE
        RTS     R5              ;DONE

PIZFUN: .BYTE   100             ;+0
        .BYTE   100             ;+1
        .BYTE   101             ;+2
        .BYTE   102             ;+3
        .BYTE   103             ;+4
        .BYTE   136             ;+5
        .BYTE   137             ;+6
        .BYTE   110             ;+7
        .BYTE   137             ;+10
        .BYTE   116             ;+11
        .BYTE   117             ;+12

PIZBYT: BYTPNT  9               ;+0
        BYTPNT  17              ;+1
        BYTPNT  17              ;+2
        BYTPNT  17              ;+3
        BYTPNT  17              ;+4


;SEQ474

        BYTPNT  5               ;+5
        BYTPNT  6               ;+6
        BYTPNT  17              ;+7
        BYTPNT  23              ;+10
        BYTPNT  35              ;+11
        BYTPNT  23              ;+12
        

;SEQ475

PIZMSK: .BYTE   200             ;+0
        .BYTE   0               ;+1
        .BYTE   200             ;+2
        .BYTE   200             ;+3
        .BYTE   200             ;+4
        .BYTE   371             ;+5
        .BYTE   367             ;+6 PI1
        .BYTE   370             ;+7
        .BYTE   375             ;=10
        .BYTE   370             ;+11
        .BYTE   361             ;+12

PIZEXP: .BYTE   0               ;+0"PIH1-PIH7"
        .BYTE   0               ;+1 "PI ACTIVE" & "PI ON1-0N7"
        .BYTE   0               ;+2 "PI GEN1-GEN7"
        .BYTE   0               ;+3 "PI2,PI1,EBUS DEMAND, SEL PHY 8,4,2,1"
        .BYTE   20              ;+4 "TIMER DONE,PI GRAN,STATE HOLD,PI4, HONOR INTERNAL"
                                ;       "PI READY,EBUS REQ"
        .BYTE   0               ;+5 "SCAD MIXERS-PI4,PI2"
        .BYTE   0               ;+6 "SCAD MIXERS-PI1"
        .BYTE   0               ;+7 "APR PIA4,PIA2,PIA1"
        .BYTE   0               ;+10 "CON COND ADR 10--SELECTS CP GRANT & PI XFER"
        .BYTE   0               ;+11 "MTR PIA4, PIA2,PIA1"
        .BYTE   0               ;+12 "MTR VECTOR HONOR,MTR INC SEL2, INC SEL1"
        .EVEN

;SEQ476

.SBTTL          PARCH -- PARITY LOGIC MODIFY-COMPARE-RESTORE

;ROUTINE TO PERFORM AN MCOMP,DCOMP,THEN RCOMP CHECK OF
;ALL CONTROL SIGNALS RELEVANT TO THE PARITY CIRCUITRY IN THE
;EBOX.

$PARCH: $MCOMP                  ;FIRST, MODIFY EXPECTED DATA
        JSR     R5,SDCOMP       ;GO TO DCOMP TO DO THE OCMPARE
        .WORD   PARMSK          ;LIST OF MASKS
        .WORD   PARFUN          ;LIST OF DIAGNOSTIC FUNCTIONS
        .WORD   PARBYT          ;LIST OF BYTE POINTERS
        .WORD   PAREXP          ;LIST OF EXPECTED
$PARMS: .WORD   0               ;POINTER TO ERROR MESSAGE
        $RCOMP                  ;RESTORE TABLE
        RTS     R5              ;RETURN

PARFUN: .BYTE   130             ;+0
        .BYTE   104             ;+1
        .BYTE   106             ;+2
        .BYTE   105             ;+3
        .BYTE   114             ;+4
        .BYTE   107             ;+5
        .BYTE   134             ;+6
        .BYTE   136             ;+7
        .BYTE   137             ;+10
        .BYTE   132             ;+11
        .BYTE   133!BIT7        ;+12

PARBYT: BYTPNT  19              ;+0
        BYTPNT  35              ;+1
        BYTPNT  35              ;+2
        BYTPNT  35              ;+3
        BYTPNT  17              ;+4
        BYTPNT  35              ;+5
        BYTPNT  26              ;+6
        BYTPNT  25              ;+7
        BYTPNT  25              ;+10
        BYTPNT  29              ;+11
        BYTPNT  29              ;+12


;SEQ477

PARMSK: .BYTE   376             ;+0 - "WR EVEN PAR DATA H"
        .BYTE   375             ;+1-"CLK FM PAR CHECK L"
        .BYTE   356             ;+2-"ARX PAR ODD & CLK AR/ARX PAR CHECK L"
        .BYTE   317             ;+3-"CLK FM PAR ERR & AR PAR ODD"
        .BYTE   374             ;+4-"APR FM 36 & APR FM ODD PARITY"
        .BYTE   317             ;+5"CLK ERROR L & CLK PAGE FAIL"
        .BYTE   373             ;+6-"CON FM WRITE PAR L"
        .BYTE   175             ;+7-"CON AR 36 & CON FM XFER L"
        .BYTE   177             ;+10-"CON ARX 36"
        .BYTE   277             ;+11-"CON AR LOADED"
        .BYTE   277             ;+12-"CON ARX LOADED L"

;RESET & NORMAL STATE OF PARITY SIGNALS
PAREXP: .BYTE   0               ;+0
        .BYTE   2               ;+1
        .BYTE   1               ;+2
        .BYTE   0               ;+3
        .BYTE   0               ;+4
        .BYTE   40              ;+5
        .BYTE   4               ;+6
        .BYTE   2               ;+7
        .BYTE   0               ;+10
        .BYTE   0               ;+11
        .BYTE   100             ;+12

        .EVEN


;SEQ478

.SBTTL  AR2SC -- SUBROUTINE TO MAKE SC EXPECTED DATA

;THIS ROUTINE CHANGES THE EXPECTED DDATA IN THE SCD BOARD COMPARE
;TABLE (SCDDAT) FOR A TRANSFER FROM AR SHIFT (AR BIT 18 AND BIT
;28 TO 35).  THE INPUT DATA IS ASSUMED TO BE IN THE 36-BIT BUFFER,
;EWORD2, AND THE BYTES CONTAINING SC 0-9, SC SIGN AND SC.GE.36
;ARE MODIFIED.  BUFFER EWORD2 IS USED AND AN ALTERNATE ENTRY IS
;PROVIDED FOR ASSUMING THAT EWORD1 CONTAINS THE COMPLIMENT OF
;THE DESIRED DATA.

;CALL:  JSR     R5,$AR2SC       ;ALTER SC EXPECTED DATA (AR=EWORD1)
;OR:    JSR     R5,$CA2SC       ;ALTER SC EXPECTED DATA (AR=EWORD1)

$AR2SC: $MOVWD  EWORD1,EWORD2   ;COPY 1ST BUFFER TO 2ND
        BR      AR2ST           ;AND BEGIN.

$CA2SC: $COMWD          ;COPY COMPLIMENT OF 1ST BUFFER TO 2ND
AR2ST:  SHOVE                   ;SAVE REGISTERS

        MOV     #EWORD2,R1      ;R1 GETS PTR TO 36-BIT BUFFER (DATA).
        MOV     #SCDDAT,R2      ;R2 PTS TO SC BYTES IN EXPECTED TABLE.
        MOV     #SCDDAT+6,R3    ;R3 PTS TO SC SIGN BYTE IN TABLE.
        MOV     R2,R4           ;GET 2ND COPY OF SC DATA PTR.

        MOV     (R1)+,(R2)+     ;COPY AR BITS 20-35 INTO SC BYTES.
        CLRB    -(R2)           ;CLEAR UPPER BYTE OF EXPECTED DATA
        CLRB    (R3)            ;AND "SC SIGN" BYTE.
        BIT     #2,(R1)         ;SEE IF AR BIT 18 IS SET.
        BEQ     2$              ;LEAVE SC BITS ALONE IF NOT.

        COMB    (R2)            ;OTHERWISE, SET UPPER BYTE TO 1'S
        INCB    (R3)            ;AND SET SIGN BIT IN EXPECTED


;SEQ479

2$:     INC     R3              ;NOW POINT AT BYTE WITH "SC.GE.36"
        CLRB    (R3)            ;START WITH SC.GE.36 CCLEARED
        ASL     (R4)            ;SHIFT SC DATA SO THAT SC 0-3
        ASL     (R4)            ;AEE IN UPPER BYTE OF EXPECTED.
        TSTB    (R2)            ;SEE IF ANY OF THOSE BITS ARE SET.
        BNE     3$              ;GO SET SC.GE.36 IF SO.

        TSTB    (R4)            ;SEE IF SC4 IS SET.
        BGE     4$              ;LEAVE SC.GE.36 CLEARED IF NOT
        
        BITB    #160,(R4)       ;IF IT IS, SEE IF SC 5,6 OR 7 IS SET.
        BEQ     4$              ;LEAVE SC.GE.36 CLEARED IF NOT

3$:     INCB    (R3)            ;SET SC.GE.36.
4$:     ASL     (R4)            ;SHIFT AC DATA INTO ITS FINAL POSITION
        GRAB                    ;RESTORE REGISTERS
        RTS     R5              ;AND RETURN.


;SEQ480

.SBTTL $ACREF -- SUBROUTINE WHICH SETS OR CLEARS THE VMA

;IF SR0 IS 0 UPON ENTRY, AC REGS ARE PREVENTED. OTHERWISE THEY ARE
;ASSURED.

;       CALL:   CLR     R0              ;
        
;                       JSR     R5,$ACREF               ;PREVENT AC REFERENCES

;       OR:     MOV     #-1,R0
;               JSR     R5,$ACREF       ;ASSURE AC REFERENCES

;       NOTE:THIS ROUTINE LEAVES AR,CR, $MICRO, AND EWORD1 CLEARED.
;       (HENCETHIS IS A GOOD ROUTINE TO START OFF WITH.)

$ACREF: MOV     R1,-(SP)        ;SAVE R1
        MOV     R0,-(SP)        ;SAVE KEY
        MOV     #EWORD1,R1              ;PTR TO DATA
        CLEAR                   ;CLEAR MACHINE

        $CLRWD  EWORD1          ;CLEAR 36-BIT BUFFER
        $CLRMI  $MICRO          ;AND MICROWORD BUFFER

        TST     (SP)+           ;LOOK AT KEY
        BNE     ACRF1           ;GO AROUND IF NOT ZERO

        MOV     #-1,(R1)                ;ZERO, SET SOME BUFFER BUTS


;SEQ481

ACRF1:  MOV     #LDAR,R0        ;GET SET TO LOAD THE AR
        DFWRT                   ;DO IT

        $VMA    3               ;SET UP TO LOAD VMA/AD
        $AD     37,0,0          ;AD/A, ADA/AR
        $AR     3,0             ;AR/EBUS
        $MWORD                  ;WRITE BUFFER TO CR
        $CLRWD  EWORD1          ;RECLEAR BUFFERS
        $CLRMI  $MICRO  
        $MWORD                  ;CLOCK DATA TO VMA, AR/0, CR/0
        MOV     #LDAR,R0        ;LEAVE AR CLEARED
        DFWRT
        MOV     (SP)+,R1        ;RESTORE R1
        RTS     R5              ;RETURN


;SEQ482

.SBTTL CRADRD: THE NEXT ADDRESS BOARD REGISTER READER
;SUBROUTINE TO READ ONE OF 3 REGISTERS ON THE CRA BOARD AND RETURN
;THE 11 BIT RESULT, RIGHT JUSTIFIED, IN REGISTER R0
;FIRST PASS THE DESIRED REGISTER'S DIAGNOSTIC FUNCTION IN R0, THEN JSR.
;       MOV     #DIAGFCN,R0
;       CRADRD

$CRADRD:        PUSH    <R1,R0>         ;SAVE SOME REGISTERS

        MOV     #EWORD1,R1              ;READ AND SAVE DATA AT EWORD1
        DFRDMV          ;FUNCTION WAS ALREADY IN R0
        MOVB    EWORD1+3,DSAVE  ;MUST SAVE CRA REGISTER
        MOVB    EWORD1+4,DSAVE+1        ;00 THRU 04
        POP     R0              ;GET DIAG FCN BACK

        DEC     R0              ;DIAG FCN MUST BE LESS ONE FOR BITS 5-10
        MOV     #EWORD1,R1      ;PUT SECOND READ IN EWORD
        DFRDMV                  ;READ SECOND HALF CRA REGISTER

        ROLB    EWORD1+3        ;ALMOST JUSTIFY THE DATA (EBUS 0-5)
        ROLB    EWORD1+4        ;ON ABYTE BOUNDARY
        ROLB    EWORD1+3                ;FINISH JUSTIFYING THE DATA (EBUS 0-5)
        ROLB    EWORD1+4                ;ON A BYTE BOUNDARY (EWORD1+4)


        BICB    #174077,DSAVE   ;CLEAR A PLACE FOR REG BITS 5-10
        BISB    EWORD1+4,DSAVE  ;SET REG BITS 5-10

        MOV     DSAVE,R0                ;GET FINAL REGISTER RESULTS
        POP     <R1>            ;FIX STACK

        RTS     R5              ;ALL DONE


;SEQ483

.SBTTL DATCOM,DATODD, DATEVE -- SUBROUTINE TO WRITE DRAM DATA

$DATCOM:        MOV     #LDRAM3,R0      ;GET DIAG FUN TO WRITE COMMON
        ASL     R1              ;JUSTIFY DATA FOR THE EBUS
        ASL     R1              
        BR      CON2            ;GO WRITE IT

$DATODD:        MOV     #LDRAM2,$DDRMS  ;FUNCTION FOR J-FIELD A& B
        MOV     #LDRJOD,R0      ;FUNCTION FOR J-FIELD ODD
        BR      CON1            ;GO
$DATEVE:        MOV     #LDRAM1,$DDRMS  ;FUNCITON FOR J-FIELD A & B
        MOV     #LDRJEV,R0      ;FUNCTION J-FIELD EVEN
CON1:   ASL     R1              ;JUSTIFY FPIECE I'M
        ASL     R1              ;INTERESTED IN FOR J-DATA FIELDS
        PUSH    R1              ;SAVEW DATA TO BE SENT

        JSR     R5,CON2         ;WRITE J-DATA
        POP     R1             ;GET DATA AGAIN

        SWAB    R1              ;NOW I'VE GOT A & B
        MOV     $DDRMS,R0       ;GET CORRECT DIAG FUNCTION, & WRITE

CON2:   MOVB    R1,DDRAM+2      ;R1 ALWAYS HAS THE DATA
        MOV     #DDRAM,R1       ;I ALWAYS PUT IT IN DDRAM
        DFWRT
        RTS     R5              ;NOW WRITE


;SEQ484
.SBTTL GLOWRM -- ROUTINE TO LOAD THE DRAM FROM TABLE

;ROUTINE TOG ET DATA FROM A SIMPLE TABLE AND WRITE THAT
;DATA TO THE DRAM WITHOUT CLOCKING THE EBOX ND MUCKING THINGS UP

GLOWRM: MOVB    (R4)+,EWORD1    ;J7-10
        MOVB    (R4)+,EWORD1+1  ;A & B FIELDS
        MOV     EWORD1,R1       ;DATA TO EVEN
        DATEVE
        MOV     EWORD1,R1               ;DATA TO ODD
        DATODD
        MOVB    (R4)+,R1        ;DATA TO COMMON
        DATCOM
        DFXCTT
        DRLTCH
        RTS     PC

.SBTTL ERS16D -- SUBROUTINE TO STACK 16-BIT ERRORS

;SUBROUTINES TO STACK 16-BIT ERROR DATA ON THE ERROR STACK
;ROUTINE EXPECTS R3=ACTUAL MASK, R2 POINTS TO ACTUAL RECEIVED DATA
;AND R4 POINTS TO EXPECTED DATA.

ERS16D: MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;STACK FORMAT TYPE
        MOV     R3,(R0)+        ;STACK MASK
        MOV     (R2),(R0)+      ;STACK ACTUAL RECEIVED
        MOV     (R4),(R0)+      ;STACK EXPECTED
        MOV     R0,ERSP..       ;RETURN STAKC POINTER
        RTS     PC              ;DONE


;SEQ485

.SBTTL RDPSEC -- ROUTINE FOR READING PREVIOUS SECTION REG

;SPECIAL ROUTINE FOR REDING THE PREVIOUS SECTION REGISTER
;PLUS THE PCS SECTION 0 BIT.. DATA IS RETURNED IN R0 WITH 6 VITS
;RIGHT JUSTIFIED..PREV SEC 13-17 THE 5 RIGHT-MOST BITS
;AND PCS SECTION 0 IS THE SIXTH BIT..
;*              *               * PREV  * PREV  * PREV  * PREV  * PREV  *
;* MASKED BITS *-PCS SECTION 0* SEC 13* SEC 14* SEC 15* SEC 16* SEC 17*

;CALL:  JSR     PC,RDPSEC

RDPSEC: CLR     TVPSEC          ;CLEAR A TEMP CORE LOCATION
        PUSH    R1              ;AND SAVE REGISTER R1

        PUSH    #160            ;PUSH FIRST DAIG FUNC PLUS 1 ONTO STACK

        MOV     #152,R0         ;GET DIAG FUNC TO READ "PCS SECTIOON )"
        MOV     #2$,R1          ;PLACE TO PUT THE READ DATA

1$:     DFRDMV                  ;DO FUNCTION EAD OF VMA BOARD

        MOVB    2$+3,R0         ;GET BITS 4-11
        BIC     #177776,R0      ;LEAVE ONLY BIT 11
        ASL     TVPSEC          ;SHIFT ACCUMULATED DATA
        BIS     R0,TVPSEC       ;SAVE ADDITIONAL BIT OF DATA
        DEC     (SP)            ;ADVAN E TO NEXT DIAG FUNC
        MOV     (SP),R0 ;AND PUT IT INTO R0
        CMP     #152,R0         ;DONE ALL YET??
        BNE     1$              ;BACK IF NOT YET

;FALL TO HERE IF ALL DONE
        POP     R0              ;CLR DIAG FUNC FROM STACK

        POP     R1              ;RESTORE R1

        MOV     TVPSEC,R0               ;GET RESULTS TO R0
        RTS     PC              ;AND RETURN

2$:     WD36    0,0,0           ;TEMP STORAGE LOCATION
        .EVEN           ;STAY CLEAN
TVPSEC: .WORD   0               ;TEMP LCOATION TO BUILD PREV SEC DATA


;SEQ486

.SBTTL ROUTINE TO ISSUE WWADR, ONE ECLOCK & SET RUN FLOP FOR PI

;THIS ROUTINE RECEIVES IN R09 THE DESIRED MICRO-CODE ADDRESS
;THEN LOADS THAT ADDRESS, ISSUES RUN AND CONTINUE (FOR THE
;BENEFIT OF THE PI BOARD) AND FINALLY ONE EBOX CLOCK TO SYNC THE
;MICRO-WCODE FOR THE BEGINNING OF THE NEXT PI SUBTEST

RUN.GO: WWADR                   ;ADDRESS TO DIAG ADDR REG 
        JSR     PC,NPIDIS               ;ROUTINE TO SET RUN & SET OCNTINUE
        ECLOK           ;SINGLE CLOCK
        RTS     PC              ;OUT

;TINY ROUTINE TOT ACTUALLYD OT HE SETTING OF "RUN" & "CONTINUE"
NPIDIS: DFXCTT
        SETRUN          ;FUNCITON TO SET RUN FLOP
        DFXCTT
        CONBUT          ;FUNCTION TO SET CONTINUE AND ENABLE "RUN" TO PI
        RTS     PC              ;OUT

;TRAP ROUTIEN TO GIVE BURSTS OF CLOCK.. THE FEATURE OF THIS ROUTINE
;IS THAT IF YOU GIVE A CLOCK COUNT GREATER THAN THE BURST ROUTINE WILL
;ACCEPT, THEN TRHIS ROUTINE BREAKS IT UP AND DOES THE BURSTING
;IN CHUNKS OF 255
$RUNCL: PUSH    R0              ;SAVE NUMBER OF TICS

1$:     SUB     #^D255,(SP)     ;BIG CLOCK CNT??
        BPL     2$              ;BR IF YES

;HERE IF NO
        BURST                   ;BURST THE CLOCK
        POP     R0              ;CLEAN STACK

        RTS     R5              ;AND OUT

2$:     MOV     #^D255,R0               ;BIG CNT..GET ALL 255 TICS TO R0\
        BURST           ;EXECUTE THEM
        MOV     (SP),R0         ;GET UPDATED CLOCK CNT TO R0
        BR      1$              ;AND BACK TO BEGINNING


;SEQ487

;SUBROUTINE TO CHECK THE C-RAM ADDRESS AND VERIFY THAT
;THE MICRO-CDE HAS STOPPED WHRE I EXPECTED.
;CALL IS:
;       MOV     #EXPECTED CRAM ADDR,R0
;       CRMHL           ;TRAP TO ROUTINE
;**ERROR RETURNS "C-BIT" SET
;**ADDR MATHCES RETURNS "C-BIT" CLEAR
$CRMHLT:        PUSH    R0              ;SAVE EXPECTED CRAM ADDR
        MOV     #RCRA+7,R0      ;FUNCTION TO READ CRAM LOC REG
        CRADRD                  ;TRAP TO READ CRA BRD
        CMP     (SP),R0 ;CRAM ADDRESS AS EXPECTED?
        BEQ     1$              ;BR IF YES-OK

;FALL TO HERE IF ERROR
        MOV     R0,(SP)         ;PUT ACTUAL ON TOP OF STACK
        ERRMSG<\MICRO-DIAGNOSTIC HALT-CRAM ADDRESS >
        MOV     (SP),R0         ;ACTUAL BACK TO R0
        ERROCT                  ;NOW PRINT ADDRESS ITSELF
        POP     R0              ;CLEAN STACK
        SEC                     ;SET ERROR INDICATOR
        RTS     R5              ;RETURN

1$:     POP     R0              ;CLEAN STACK
        CLC                     ;SAY NO ERROR
        RTS     R5              ;RETURN


;SEQ488

.SBTTL *ESTOR* E-BOX TEST STORAGE LOCATIONS

;STORAGE FOR DTE20 ADDRESS POINTERS
        .EVEN
.DELAY: 0               ;(XXX00)
.DAT3:  0               ;(XXX02)
.DAT2:  0               ;(XXX04)
.DAT1:  0               ;(XXX06)
.TENA1: 0               ;(XXX10)
.TENA2: 0               ;(XXX12)
        
.BC10:  0               ;(XXX14)
.BC11:  0               ;(XXX16)
.T10AD: 0               ;(XXX20)
.T11AD: 0               ;(XXX22)
.T10DT: 0               ;(XXX24)
.T11DT: 0               ;(XXX26)
.DIAG1: 0               ;(XXX30)
.DIAG2: 0               ;(XXX32)
.STDTE: 0               ;(XXX34)
.DIAG3: 0               ;(XXX36)
                .EVEN

;STORAGEW FOER SOME 36-BIT WORDS AND THE CRAM ADDRESS WORD

ONES:   .WORD   -1,-1,-1        ;SOURCE OF ALL ONES WORD
ZERO:   .WORD   0,0,0           ;ZERO'ED 36-BIT WORD
        
EWORD1: .WORD   0,0,0           ;A 36-BIT WORD


DDRAM:
PATBUF:
ERRCNT:
LOAD12:
EWORD2: .WORD   0,0,0           ;ANOTHER ONE
$MICRO: .WORD   0,0,0,0,0,0     ;STORAGE FOR MICROWORD
$$CRAD: 0                       ;STORAGE FOR CRAM ADDRESS
$DDRMS:
DSAVE:                  ;TEMP DATA STORE
DLINKR: .WORD   0               ;LINK ADDRESS FOR SOME CRA TESTS
ERRLVL:
ALL4:
PASS2:  .WORD   0               ;FLAG FOR SECOND PASS STATUS
$NOCHK: .WORD                   ;"NO CHECKING" IONIIALIZATION FLAG

;ASSIGN LITERAL AREA


$$LITT=.        ;START OF LITERAL AREA

$$FF=$$CLIT     ;FIRST FREE


.END    START
 0a