;SEQ14

.TITLE  TEBOXB   EBOX DIAGNOSTIC TESTS PART 2

 
 
 
 
 
 
 
 
 
        .ENABL  ABS,AMA
        .=3000
DTEASB = 1
DTETST = 1
$EBOX =  1
$PART1 = 0
$MODB =  1
DHNAME = 1
$DEBUG = 0
 
   
        .LIST           MD,MC,MEB
        .NLIST          CND,BEX
        ESTSIZ=         ^D100
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16         ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM
















.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
 
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM
 
 
 
 
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
 
 
 
 

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
 
 
 
 


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
 
 
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
 
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
 
 
        JSR     PC,(R3)                 ;DO INITIALIZATION
 
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
                "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
 
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FT3             ;12
        FTT     FT6             ;14
        FTT     FTNON          ;16 -FT8 NOT USED
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTNON           ;30 - FTMEM INHIBITED
        FTT     FTPRM           ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %
FT3T:   FTM.    <HEDFT3,IDFTAB,IBPTAB,IMSK08,IEXP08,ACTFT3>

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
%

FT6T:   FTM.    <ICRADR,ACT80,EXP80,DIFF80>


.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

 

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

 

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACT80:  AC80
ACTFT3: ACTF3
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
DIFF80: DIF80
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXP80:  XP80
HEDFT3: HEDF3
IBPTAB: IBPTB
ICRADR: ICRAD
IEXP08: IXP08
IDFTAB: IDFTB
IMSK08: IMK36
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT    ERCAD,<.ASCIZ %C-RAM ADDRESS: %>
        .LIT    ERBTH,<.ASCIZ %INDEX%>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER



;SEQ087

.REM    %
STACK ENTRY IS INDEX,,ACTUAL DATA.  THERE MAY BE MORE THAN ONE ENTRY 
LAST IS FLAGGED WITH BIT 15=1.
(ROUTINE IS USED FOR EBOX TEST DCOMP ROUTINE ERRORS)
        %

ACTF3:  CLR     INX.            ;START AT ZEROTH ENTRY
        PCRLF
1$:     MOVB    1(R5),R3
        BIC     #177600,R3
        MOV     R3,R0           ;PRINT THE INDEX
        PNTOCT          
        PMSG    <_>             ;MAKE SURE IT GETS PRINTED
        PUSH    R3              ;SAVE INDEX

        SUB     INX.,R3
        POP     INX.

        ADD     R3,DGP.
        ADD     R3,BYP.
        ADD     R3,EXP.
        ADD     R3,MKP.
        MOVB    @DGP.,FT8DF
        BICB    #200,FT8DF      ;CLEAR GARBAGE
        MOV     #28.,R2
        MOVB    @BYP.,R1        ;GET BYTE PTR TO RIGHT BIT
        ROR     R1              ;0 OR 1 TO C-BIT
        BCC     2$              ;0 SAYS 20-35
        MOV     #12.,R2 
2$:     ASR     R1              ;FLUSH EXTRA BIT
        SUB     R1,R2           ;GET LEFTMOST BIT NBR
        MOV     R2,R0
        ADD     #7,R0
        MOVB    R0,F8BTL        ;LAST BIT
        MOVB    R2,F8BTF        ;FIRST BIT
        CLR     R3
        BISB    #200,R3         ;LEFT BIT MASK
3$:     TSTB    F8BTF           ;RIGHT IF BIT # POS
        BPL     4$
        ASR     R3              ;ELSE FIND
        INCB    F8BTF
        BR      3$
4$:     MOV     EXP.,R1         ;EXPECTED PTR
        MOV     R5,R2           ;ACTUAL PTR
        BICB    @MKP.,(R1)      ;INSURE
        BICB    @MKP.,(R2)      ;ZEROES WHERE NO TEST
        JSR     PC,PRDBYT       ;TEST AND PRINT NAMES
        TST     (R5)+           ;LOOK FOR END
        BPL     1$              ;MORE TO REPORT
        RTS     PC              ;DONE - BACK TO SCAN

;SEQ088

.REM    %
STACK CONTAINS (11-BYTE) 80-BIT ACTUAL DATA
        %
AC80:   MOV     R5,R2   
        ADD     #11.,R5         ;AND PASS OVER DATA
        MOV     R2,ACP.         ;SAVE POINTER FOR DIE ROUTINE
        PCRLF
        MOV     #ERACT,R0       ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN

.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER


;SEQ091

.REM    %
        COMPUTE AND TYPE 80-BIT XOR DIFFERENCE
        %
DIF80:  MOV     ACP.,R1         ;POINT TO ACTUAL
        MOV     #DIF.+12.,R2    ;POINT TO RESULT BUFFER
        MOV     EXP.,R3         ;POINT TO EXPECTED
        ADD     #12.,R1
        ADD     #12.,R3
;DO BYTEWISE XOR FROM BACK TO FRONT

1$:     MOVB    -(R1),R0        ;LOAD ACTUAL    
        MOVB    -(R3),-(R2)    ;LOAD EXPECTED
        BICB    R0,(R2)         ;-ACT .AND. EXP
        BICB    (R3),R0         ;ACT .AND. -EXP
        BISB    R0,(R2)         ;ACT .XOR. EXP
        CMP     #DIF.,R2        ;BACK TO START YET ?
        BNE     1$
        PCRLF
        MOV     #ERDSC,R0       ;POINT TO HEADER
        JMP     TYP80           ;GO TYPE AND RETURN TO SCAN


.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER


.REM    %
STACK CONTAINS (11-BYTE) 80-BIT EXPECTED DATA
        %

XP80:   MOV     R5,R2
        BGT     1$              ;IF PLUS, A REAL POINTER
        ROR     R2              ;SAVE 0 OR 1 BIT
        MOV     #ZMK.,R2        ;ASSUME ZEROES
        BCC     1$              ;BRANCH IF ZERO
        MOV     #ALL7,R2        ;NO - IT'S ONES

1$:     ADD     #11.,R5         ;PASS OVER STACK DATA
        MOV     R2,EXP.         ;SAVE FOR DIF ROUTINE
        PCRLF
        MOV     #ERCOR,R0       ;POINT TO HEADER
        JMP     TYP80           ;GOT YPE, RETURN TO SCANNER


;SEQ094

.REM    %
PRINT BYTE TABLE ERROR FORMAT HEADER
        %
HEDF3:  PCRLF
        MOV     #ERBTH,R0
        PNTAL
        MOV     #ERSCT,R0
        PNTAL
        RTS     PC              ;GO BACK TO SCAN

.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN


;SEQ095

.REM    %
STACK HAS POINTER TO A C-RAM ADDRESS
        %
ICRAD:  PCRLF
        MOV     #ERCAD,R0       ;PRINT C-RAM ADDRESS HEADER
        PNTAL
        MOV     @(R5)+,R0       ;GET THE ADDRESS
        PNTOCT
        RTS     PC

.REM    %
EIGHTBIT BYTE EXPECTED DATA
        %

IXP08:  MOV     (R5)+,EXP.
        RTS     PC

.REM    %
STACK POINTS TO BASE OF DIAG FCN TABLE
        %
IDFTB:  MOV     (R5)+,DGP.      ;PICK UP BASE
        RTS     PC              ;BACK TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC


;BUFFER PACKING ROUTINE TO SUPPORT ACTF3

TYP08:  MOVB    #ASSP,-(R3)             ;SPACE AT RIGHT END
        MOV     #-8.,TEM.               
        JSR     PC,BINPAK               ;DO THE BYTE
        MOVB    #ASSP,-(R3)             ;LEADING SPACES
        MOVB    #ASSP,-(R3)             ;2
        ADD     #2,SPCNT         ;FAKE IT
        RTS     PC


;ROUTINE TO TYPE 80-BIT DATA AS 5 16-BIT OCTAL WORDS. THE
;ADDRESS OF A HEADER TO BE TYPED AT THE LEFT MARGIN IS SUPPLIED
;IN R0. THE POINTER TO THE BACKWARDS 10-BYTE DATA IS IN R2.


TYP80:  PNTAL
        MOV     R2,R3           ;SAVE STARTING POINT
        ADD     #10.,R3         ;POINT TO THE END
1$:     MOVB    -(R3),R0                ;GET ODD BYTE
        SWAB    R0
        CLRB    R0
        BISB    -(R3),R0                ;GET EVEN BYTE
        PNTOCT
        MOV     #ASSP,R0
        PNTCHR
        CMP     R3,R2           ;DONE YET?
        BNE     1$
        MOVB    10.(R3),R0
        PNTOCS                  ;PRINT DISP FIELD
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT        ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
INX.:    .WORD 0
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138



;SEQ116

.SBTTL  *EMAC*  EBOX DIAGNOSTIC MACRO DEFINITIONS
.MACRO  $CLRWD  LOC
        .IF NB LOC
        CLRWRD          ;CLEAR 5 BYTES BEGINNING
        .WORD LOC       ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        CLRBUF          ;CLEAR 36 BIT BUFFER
        .ENDC
        .ENDM
.MACRO  $SETWD  LOC
        .IF NB LOC
        SETWRD          ;SET ONES TO 36 BITS BEGINNING
        .WORD LOC       ;WITH LOCATION LOC
        .ENDC
        .IF B LOC
        SETBUF          ;1'S TO 36 BIT BUFFER
        .ENDC
        .ENDM
.MACRO  $ROLWD  LOC
        .IF NB LOC
        ROLWRD          ;ROTATE 36-BIT BUFFER AT LOC
        .WORD LOC               ;LEFT ONE BIT
        .ENDC
        .IF B LOC
        ROLBUF          ;ROTATE 36-BIT BUFFER LEFT
        .ENDC
        .ENDM
.MACRO  $RORWD  LOC
        .IF NB LOC
        RORWRD          ;ROTATE 36-0BIT BUFFER AT LOC
        .WORD LOC       ;RIGHT ONE BIT
        .ENDC
        .IF B LOC
        RORBUF          ;ROTATE 36-BIT BUFFER RIGHT
        .ENDC
        .ENDM

;SEQ117

.MACRO  $MOVWD  S,D
        MOVWRD          ;MOVE 5 BYTES

        .WORD S         ;FROM S
        .WORD D         ;TO D
        .ENDM
.MACRO  $COMWD
        COMBUF          ;PUT COMPLIMENT OF EWORD1 IN EWORD2
        .ENDM
.MACRO  $CLRMI  LOC
        .IF NB LOC
        CLRMIC          ;CLEAR 12-BYTE MICROWORD
        .WORD LOC       ;BUFFER STARTING AT LOC
        .ENDC
        .IF B LOC
        CLR$M           ;CLEAR MICRO-WORD BUFFER
        .ENDC
        .ENDM
.MACRO  $COMBF
        COMBUF          ;PUT COMPLIMENT OF EWORD1 INTO EWORD2
        .ENDM


;SEQ118

.MACRO  $ITAB   .TABLE,.DATA,.ITEMS
        .IF NB .TABLE
        MOV     #.TABLE,R1      ;R1 HAS ADDRESS OF DCOMP TABLE
        .ENDC
        .IF NB .DATA
        MOV     #.DATA, R2      ;R2 HAS ADDRESS OF DATA TO LOAD
        .ENDC
        .IF NB .ITEMS
        MOV     #.ITEMS, R3     ;R3 IS NUMBER (OCTAL) OF ENTRIES TO DO
        .ENDC
        JSR     PC,ITAB ;INITIALIZE DCOMP TABLE


.ENDM

;SEQ119

.MACRO  $AD     .AD,.ADA,.ADB
        .IF NB .AD
        ADT             ;LOAD $MICRO WITH AD = .AD
        .WORD .AD!<.ADA*BIT6>!<.ADB*BIT9>       ;.ADA AND ADB = .ADB
        .ENDC
        .IF B .AD
        AD              ;LOAD AD FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $AR     .ARM,.ARXM
        .IF NB .ARM
        ART             ;LOAD $MICRO WITH ARM = .ARM
        .WORD .ARM!<.ARXM*BIT3> ;AND ARSM = .ARXM
        .ENDC
        .IF B .ARM
        AR              ;LOAD AR FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $BR     BRLOAD,BRXLOD
        .IF NB BRLOAD
        BRT             ;LOAD $MICRO WITH BR LOAD = BRLOAD
        .WORD BRXLOD!<BRLOAD*BIT1>      ;AND BRX LOAD = BRXLOAD
        .ENDC
        .IF B BRLOAD
        BR              ;LOAD BR FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $COND   VAL
        .IF NB VAL
        CONDT           ;SET COND FIELD OF $MICRO
        .WORD   VAL     ;TO VAL
        .ENDC
        .IF B VAL
        COND            ;LOAD COND FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ120


.MACRO  $DISP   VAL
        .IF NB VAL
        DISPT           ;SET DISP FIELD OF $MICRO
        .WORD   VAL     ;TO VAL
        .ENDC
        .IF B VAL
        DISP            ;LOAD DISP FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $EACAL  VAL
        .IF NB VAL
        EACLT           ;SET EACALL FIELD
        .WORD VAL
        .ENDC
        .IF B VAL
        EACALL          ;LOAD EACALL FIELD OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $FE     VAL
        .IF NB VAL
        FET             ;SET FE LOAD = VAL
        .WORD   VAL     ;IN $MICRO
        .ENDC
        .IF B VAL
        FE              ;LOAD FE FIELD SOF $MICRO FROM R0
        .ENDC
        .ENDM

.MACRO  $FM     VAL
        .IF NB VAL
        FMT             ;SET FM ADR SEL FIELD
        .WORD VAL       ;OF $MICRO TO VAL
        .ENDC
        .IF B VAL
        FM              ;LOAD FM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ121

.MACRO  $J      VAL
        .IF NB VAL
        JT              ;SET THE J FIELD OF
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        J               ;LOAD J FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MEM    VAL
        .IF NB VAL
        MEMT            ;SET MEM FIELD OF
        .WORD   VAL     ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        MEM             ;LOAD MEM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MQ     VAL
        .IF NB VAL
        MQT             ;SET MQ SEL BIT IN $MICRO
        .WORD VAL               ;TO VAL
        .ENDC
        .IF B VAL
        MQ              ;LOAD MQ FIELDS OF $MICRO FROM R0
        .ENDC

        .ENDM


;SEQ122

.MACRO  $NUM    VAL
        .IF NB VAL
        NUMT            ;SET MAGIC # FIELD IN
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        NUM                     ;LOAD NUM FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SC     VAL
        .IF NB VAL
        SCT             ;SET SCM SEL BIT IN
        .WORD   VAL             ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        SC              ;LOAD SC FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SCAD   .SCAD,.SCADA,.SCADB
        .IF NB .SCAD
        SCADT           ;LOAD $MICRO WITH SCAD = .SCAD
        .WORD   .SCAD!<.SCADA*BIT3>!<.SCADB*BIT6>        ;SCADA = .SCADA AND ACADB = .SCADB
        .ENDC
        .IF B .SCAD
        SCAD            ;LOAD SCAD FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $SH     VAL
        .IF NB VAL
        SHT             ;SET SH-ARMM SEL FIELD
        .WORD   VAL             ;IN $MICRO TO VAL
        .ENDC
        .IF B VAL
        SH              ;LOAD SH FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM


;SEQ123

.MACRO  $T      VAL
        .IF NB VAL
        TT              ;SET T FIELD IN $MICRO
        .WORD   VAL             ;TO VAL
        .ENDC
        .IF B VAL
        T               ;LOAD T FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $VMA    VAL
        .IF NB VAL
        VMAT            ;SET VMA SEL FIELD IN
        .WORD VAL                ;$MICRO TO VAL
        .ENDC
        .IF B VAL
        VMA             ;LOAD VMA FIELDS OF $MICRO FROM R0
        .ENDC
        .ENDM
.MACRO  $MWORD
        MWORD           ;LOAD CR FROM MICROWORD BUFFER
        .ENDM
.MACRO  $XBUF
        XCTBUF          ;LOAD CR FROM $MICRO & CLOCK
        .ENDM
.MACRO  $XBUF0
        XBUF0           ;CR FROM $MICRO, 0'S TO BUF & CR
        .ENDM


;SEQ124

.MACRO  $CHKMI  EXP,ERMSG
        CHKMIC          ;COMPARE 12-BYTE MICROWORD R0
        .WORD EXP               ;POINTS TO WITH EXPECTED DATA AT EXP

        .WORD ERMSG!BIT15       ;TYPE MSG AT ERMSG ON ERROR
        .ENDM
.MACRO  $MSK36  MSK,EXP,ACT
        .IF B MSK
        M36             ;COMPARE 36 BITS @R2,MASKED BY@R3 WITH @R4
        .ENDC
        .IF NB MSK
        M36T            ;COMPARE 36 BITS BEGINNING WITH
        .WORD MSK               ;ACT TO EXPECTED DATA
        .WORD EXP               ;AT EXP MASKED BY MASK
        .WORD ACT               ;AT MSK SET C ON EROR
        .ENDC
        .ENDM
.MACRO  $MICLD  NUM,CRAMAD,DATADR
        MICLD           ;WRITE N MICROWORDS TO THE
        .WORD   NUM     ;CRAM BEGINNING WITH CRAM
        .WORD CRAMAD            ;LOC CRAMAD FROM DATA AT DATADR
        .WORD DATADR
        .ENDM
.MACRO  $ACSET          VAL
        .IF NB VAL
        ACSTT           ;LOAD AND CHECK THE AC 

        .WORD VAL               ;REGISTRER WITH VAL
        .ENDC
        .IF     B       VAL
        ACSET           ;LOAD AC# WITH VALUE IN R0
        .ENDC
        .ENDM


;SEQ125


.MACRO  $ACREF  SWITCH
        .IF B SWITCH
        ACREF           ;IF R0=0, NO AC REFERENCES
        .ENDC
        .IF NB SWITCH
        .IF NZ SWITCH
        MOV  #-1,R0     ;CLEAR VMA TO ASSURE
        .ENDC
        .IF Z SWITCH
        CLR  R0         ;SET 1'S TO VMA TO PREVENT
        .ENDC
        ACREF           ;AC REFERENCES
        .ENDC
        .ENDM
.MACRO  $ARLO2  LOC
        MOV  #LOC,R0    ;LOAD THE AR (BUT NOT IR)
        ARLOD2          ;WITH DATA AT LOCATION LOC
        .ENDM

.MACRO  $DCOMP  MSK,FUNC,BYT,EXP,ERMSG
        DCOMP           ;DO BYTE TABLE COMPARE
        .WORD MSK               ;MASK TBLE STARTS AT MSK
        .WORD    FUNC   ;FUNCTION TABLE AT FUNC
        .WORD BYT       ;BYTE TABLE AT BYT
        .WORD EXP       ;EXPECTED DATA TABLE AT EXP
        .WORD ERMSG!BIT15       ;PRINT MSG AT ERMSG ON ERROR
        .ENDM
.MACRO  $MCOMP
        MCOMP           ;MODIFY DCOMP'S EXPECTED DATA
        .ENDM
.MACRO  $RCOMP
        RCOMP                   ;RESTORE DCOMPS EXPECTED DATA
        .ENDM


;SEQ126
.MACRO  $MEMRQ
        MEMREQ         ;CHANGE EXPECTED DATA FOR MEM REQ
        .ENDM

.MACRO  $NOMRQ
        NOMREQ          ;CHANGE EXPECTED DATA FOR NO MEM REQG
        .ENDM
.MACRO  $NOC0
        NOCON0          ;EXPECT "-CON COND EN 00-07" FALSE
        .ENDM


;SEQ127


.MACRO  $PAT80  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 12 BYTES TEST PATTERN
        P80                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P80                     ;GET 1ST 12 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PAT36  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 6 BYTE TEST PATTERN
        P36                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P36                     ;GET 1ST 6 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM

.MACRO  $PAT16  LOC
        .IF NB LOC
        MOV     #LOC,R0         ;LOAD 1ST 2 BYTE TEST PATTERN
        P16                     ;INTO BUFFER BEGINNING AT LOC
        .ENDC
        .IF B LOC
        P16                     ;GET 1ST 2 BYTE TEST PATTERN TO @R0
        .ENDC
        .ENDM
.MACRO  $PATCO                  ;GET NEXT TEST PATTERN TO BUFFER
        PATCON
        .ENDM


;SEQ128

;BASKET -- MACRO TO FIX STACK & SUBTEST # FOR ERROR RETURN TO EXEC FROM A JSR R5 SUBROUT
.MACRO  BASKET
        MOV     (SP),R0         ;GET SUBTEST # &TEMP SAVE IT IN R0
        MOV     R5,(SP)         ;PUT PTR TO ERR MSG ON STACK
        MOV     R0,R5           ;PUT SUBTEST # IN R5
        JMP     FAULT           ;ERROR RETURN
        .ENDM
;BYPNT -- MACRO TO CREATE POINTER TO AN 8 BIT BYTE OF EBUS DATA
.MACRO  BYTPNT  N
        .RADIX 10
        .IIF    GE,N-20,        .BYTE   <<35-N>*4>!^B00
        .IF     LT,N-20
        .IF     LT, N-4
        .BYTE   <<<35-32>-N>*4>!^B10
        .IFF
        .BYTE   <<<35-16>-N>*4>!^B01
        .ENDC
        .ENDC
        .IIF    GE, N-36,       .ERROR N        ;IN A BYTE POINTER IS TOO LARGE
        .RADIX  8
        .ENDM
;WD18  --  MACRO TO TURN 18 BIT WORDS INTO INV BYTE FORMAT
        .MACRO          WD18    B18.23,B24.35

        .BYTE B24.35&377,<<B18.23&17>*20>!<<B24.35&7400>/400>,<B18.23&60>/20
        .ENDM
;WD36   -- MACRO TO TURN 36 BIT WORDS INTO INV BYTE FORMAT
.MACRO  WD36    A, XB, C,ZETA
        .NLIST
        .IIF    B,ZETA,STAT36=0
        .IIF    NB,ZETA,ZETA
        .BYTE <377&C>
        .BYTE   <<C&7400>/400>!<<XB&17>*20>
        .BYTE   <XB&7760>/20
        .BYTE   <A&377>
        .BYTE   <STAT36*20>!<<A&7400>/400>
        .LIST
        .ENDM


;SEQ129

.MACRO EXPECT  XX,XB,XC,XD,XE,XF,XG,XH
.NLIST
        XX
        XB
        XC
        XD
        XE
        XF
        XG
        XH
        .BYTE AR        ;AR REG INDEX
        .BYTE BR        ;BR REG INDEX
        .BYTE AD        ;AD REG INDEX
        .BYTE ARX       ;ARX REG INDEX
        .BYTE   BRX     ;BRX REG INDEX
        .BYTE   ADX     ;ADX REG INDEX
        .BYTE   MQ      ;MQ REG INDEX
        .BYTE   FM      ;FM REG INDEX
.LIST
        .ENDM
.MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7,X8
.NLIST
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D5
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8!<<X1&3400>/^D256>
        BDS0.4=<X6&37>
        .BYTE B72.79,B64.71,B56.63
        .BYTE B48.55,B40.47,B32.39
        .BYTE B24.31,B16.23,B08.15
        .BYTE B00.07,BDS0.4,0
.LIST
        .ENDM

;SEQ130

.MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7,X8
.NLIST
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>

        B64.71=<<3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D
        B40..47=<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D5
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&37>
        .BYTE B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4,0
.LIST
        .ENDM

        .MACRO          DRMPAT  A,B,J
        .NLIST          SRC
        .BYTE J&17,<A*10>!B,<J&360>/20
        .LIST SRC
        .ENDM

.MACRO DRMDISPATCH      A,B,J
        .NLIST  SRC
        .BYTE   J&17,<A*10>!B,<J&3760>/100
        .LIST SRC

.ENDM


;SEQ131


.MACRO  EXCRAD  D
        .BYTE   <D&3700>/100,D&77
        .ENDM
.MACRO  EBURST  X
        MOV     #X*2,R0
        BURST
        .ENDM
.MACRO  ARLODE  ADDR

        .IF NB ADDR
DFWRTT
        ADDR    ;ADDRESS OF DATA FOR THE AR
        LDAR    ;FUNCTION TO LOAD THE AR
        .ENDC
        .IF B ADDR
        MOV     #LDAR,R0        ;DIAG FUNCTION TO LOAD AR       DFWRT
        DFWRT
        .ENDC
        .ENDM
;CRA6DISP -- A MACRO TO CREATE A TABLE OF
        ;       C-RAM START ADDRESS
        ;       EBUS 36BIT DATA POINTERS
        ;       NUMBER OF CLOCK TICS
.MACRO  CRA6DISP        RAMST,DPNT,CLKTIC
        .WORD           RAMST!BIT15
        .BYTE   DPNT
        .BYTE   ^D CLKTIC
        .ENDM
;SEVERAL MACROS USED ONLY BU THE LAST DTE/PI ITNERFACE TEST
;EBOXON - MACRO TO RESET THE KL10 AND LEAVE THE EBOX RUNNING THE HALT LOOP
.MACRO  EBOXON
        MOV     #STARTM,R0      ;GET START ADDRESS OF MICRO-CODE
        WWADR                   ;SET ADRESS AND RESET THE KL10
        DFXCTT          ;NOW EXECUTE DIAGNOSTIC FUNCTION
        STRCLK                  ;TO START THE CLOCK FREE RUNNING
        .ENDM
;CONOPI - MACRO TO EXECUTE A CONO PI INSTR, THEN DROP EBOX TO HALT LOOP
.MACRO  CONO.PI  INSTR
        MOV     #CONO.PI!BIT15,R0       ;START ADDRESS OF CONO MICRO-CODE
        WWADR                   ;SET ADDRESS WITH NO RESET


;SEQ132


        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITIONAL EBOX CLOCK
        DFWRTT          ;DIAG FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO SEND DATA TO AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;CLOCK ON AGAIN
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;PLUS FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;CONO.DTE - MACRO TO EXECUTE CONO DTE,DATA

.MACRO  CONO.DTE                INSTR
        MOV     #DTE.IO!BIT15,R0        ;GET START ADDRESS OF CCNO/CONI MICRO-CODE
        WWADR           ;SET ADDRESS WITH NO RESET
        BICB    #3,INSTR+3      ;SET RIGHT OPCODE FOR "CONO"
        BICB    #200,INSTR+2    ;FIRST CLR OLD OPCODE BITS
        BISB    #2,INSTR+3
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCITONEXECUTE
        CECLK   ;CONDITIONAL EBOX CLK
        DFWRTT          ;FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO LOAD DATA TO THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;CLOCK ON AGAIN
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;CONI.DTE - MACRO TO EXECUTE A CONI DTE,DATA THEN RETURN EBOX TO HALT LOOP
.MACRO  CONI.DTE        INSTR
        MOV     #DTE.IO!BIT15,R0        ;GET START ADDRESS OF CONO/CONI MICRO-CODE
        WWADR           ;SET ADDRESS WITH NO RESET
        BICB    #3,INSTR+3      ;SET RIGHT OPCODE FOR "CONO"
        BICB    #200,INSTR+2    ;FIRST CLR OLD OPCODE BITS


;SEQ133

        BISB    #2,INSTR+3      ;AND NOW SET NEW OPCODE BITS
        BISB    #200,INSTR+2    ;FOR CONI TYPE IO INSTRUCTION
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITIONAL EBOX CLOCK
        DFWRTT          ;FUNCTION WRITE
        INSTR           ;FROM THIS ADDRESS
        LDAR            ;TO LOAD DATA TO THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;TO TURN THE CLOCK BACK ON
        DFXCTT          ;FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE" BUTTON
        DFXCTT          ;FUNCTION EXECUTE
        SETRUN          ;TO SET "RUN"
        .ENDM

;IDLE - MACRO TO PUT EBOX INTO A RUNNING IDLE LOOP, AWAITING AN INTERRUPT

.MACRO  IDLE
        DFXCTT          ;FUNCTION EXECUTE
        STPCLK          ;TO STOP THE CLOCK
        DFXCTT          ;FUNCTION EXECUTE
        CECLK           ;CONDITION EBOX CLOCK
        DFWRTT          ;FIRST A FUNCTION WRITE
        ZERO            ;WITH ALL ZEROES
        LDAR            ;TO LOAD THE AR
        DFXCTT          ;FUNCTION EXECUTE
        STRCLK          ;TURN CLOCK BACK ON AGAIN
        MOV     #INTLP!BIT15,R0 ;GET START ADR FOR IDLE MICRO-CODE
        WWADR           ;AND SET IN EBOX WITH NO RESET
        DFXCTT          ;NOW FUNCTION EXECUTE
        CONBUT          ;TO SET "CONTINUE
        DFXCTT          ;AND FUNCITON EXECUTE
        SETRUN          ;TO SET "RUN"

        .ENDM


;SEQ134

.SBTTL *EQUATE* TRAP, DIAGNOSTIC FUNCTION & BIT DEFINITIONS
;TRAP DEFINITIONS FOR SUBROUTINE CALLS:

        CLRWRD =        TRAP
        SETWRD =        TRAP!1
        ROLWRD =        TRAP!2
        RORWRD  =       TRAP!3
        MOVWRD =        TRAP!4
        CLRMIC =        TRAP!5
        SHOVE =         TRAP!6
        GRAB =          TRAP!7
        AD =            TRAP!10
        AR =            TRAP!11
        BR      =       TRAP!12
        COND =          TRAP!13
        DISP =          TRAP!14
        FE =            TRAP!15
        FM      =       TRAP!16
        J       =       TRAP!17
        MEM     =       TRAP!20
        MQ      =       TRAP!21
        NUM     =       TRAP!22
        SC      =       TRAP!23
        SCAD =          TRAP!24
        SH      =       TRAP!25
        T       =       TRAP!26
        VMA     =       TRAP!27
        ADT     =       TRAP!30
        ART     =       TRAP!31
        BRT     =       TRAP!32
        CONDT   =       TRAP!33
        DISPT   =       TRAP!34
        FET     =       TRAP!35
        FMT     =       TRAP!36
        JT      =       TRAP!37
        MEMT    =       TRAP!40
        MQT     =       TRAP!41
        NUMT    =       TRAP!42
        SCT     =       TRAP!43
        SCADT   =       TRAP!44
        SHT     =       TRAP!45
        TT      =       TRAP!46
        VMAT    =       TRAP!47


;SEQ135

        MWORD   =       TRAP!50
        CHKMIC  =       TRAP!51
        M36     =       TRAP!52
        M36T    =       TRAP!53
        MICLD   =       TRAP!54
        ACSET   =       TRAP!55
        ACSTT   =       TRAP!56
        ARLOD2  =       TRAP!57
        DCOMP   =       TRAP!60
        MCOMP   =       TRAP!61
        RCOMP   =       TRAP!62
        P80     =       TRAP!63
        P36     =       TRAP!64
        P16     =       TRAP!65
        PATCON  =       TRAP!66
        CTLMCR  =       TRAP!67
        CTLCMP  =       TRAP!70
        ACREF   =       TRAP!71
        DATCOM  =       TRAP!72
        DATEVE  =       TRAP!73
        DATODD =        TRAP!74
        CLKMCR =        TRAP!75
        CLKCMP  =       TRAP!76
        IRMCR   =       TRAP!77
        IRCMP   =       TRAP!100
        CLEAR   =       TRAP!101
        CLRBUF  =       TRAP!102
        SETBUF  =       TRAP!103
        ROLBUF  =       TRAP!104
        RORBUF  =       TRAP!105
        CLR$M  =        TRAP!106
        FLGMCR  =       TRAP!107
        FLGCMP  =       TRAP!110
        COMBUF  =       TRAP!111
        SPARE   =       TRAP!112
        PI.CHK  =       TRAP!113
        MEMREQ  =       TRAP!114
        NOMEMR  =       TRAP!115
        NOCON0  =       TRAP!116
        XCTBUF  =       TRAP!117


;SEQ136

        XBUF0   =       TRAP!120
        STUFF   =       TRAP!121
        SCDMCR  =       TRAP!122
        SCDCMP  =       TRAP!123
        AR2SC   =       TRAP!124
        CA2SC  =        TRAP!125
        GETMIC  =       TRAP!126
        INCWRD  =       TRAP!127
        PARCHK  =       TRAP!130
        M.RESPSIM =     TRAP!131
        $PNTUML =       TRAP!132
        RUNCLK  =       TRAP!133
        CRMHLT  =       TRAP!134
        CRADRD  =       TRAP!135
        ECALT   =       TRAP!136
        EACALL  =       TRAP!137

;SEQ137

;DIAGNOSTIC FUNCTION & BIT DEFINITIONS:

;APR BOARD, M8539:
        EAPR    =       ^D13
        RAPR    =       110     ;USE DIAGNOSTIC FUNCTIONS 110-117.

;CLK BOARTD, M8526:
        ECLK    =       ^D35    ;READ CLK DATA ON EBUS BITS 30-35.
        RCLK    =       100     ;USE DIAGNOSTIC FUNCTIONS 100-107.
        LCLK    =       40      ;LOAD CLOCK REGISTERS WITH 40-47.

;CON BOARD, M8525:
        ECON    =       ^D24    ;READ CON DATA ON EBUS BITS 18-24.
        RCON    =       130     ;USE DIAGNOSTIC FUNCTIONS 130-157.
;CRAM BOARD, M8528:
        RCRM    =       140     ;USE DIAGNOSTIC FUNCTIONS 140-147.

;CTL BOARD, M8527:
        ECTL    =       ^D31    ;READ CTL DATA ON EBUS BITS 24-28.
        RCTL    =       100     ;USE DIATGNOSTIC FUNCTIONS 100-107.

;VMA BOARD, M8523:
        RVMA    =       150     ;USE DIAGNOSTIC FUNCTIONS 150-157


;SEQ138

;IR BOARD, M8522:
        EIR     =       ^D17    ;READ IR DATA ON EBUS BITS 12-17.
        RIR     =       130     ;USE DIAGNOSTIC FUNCTIONS 130-137.

;MCL BOARD, M8530:
        EMCL    =       ^D23    ;RED MCL DATA ON EBUS BITS 18-23.
        RMCL    =       100     ;USE DIAGNOSTIC FDUNCTIONS 100-107.

;NEXT ADDRESS BOARD, M8511:
        ECRA    =       ^D5     ;READ CRA DATA ON EBUS BITS 0-5.
        RCRA    =       140     ;USE DIAGNOSTIC FUNCTIONS 140-147.

;SCAD BOARD, M8524:
        RSCAD   =       130     ;USE DIAGNOSTIC FUNCTIOS 130-137.


;SEQ139

;A FEW CONVENTIONS

        SUBNR   =       R5
        BRXIS0  =       BIT0
        BR.IS0  =       BIT0
        NOCARE  =       377
        ARXST   =       BIT1
        NEW.SC  =       BIT2
        NEG1    =       177777
        ZOT     =       0
;EQUATES NECESSARY AS INDEX POINTERS FOR DATA PATH "EDPTST" ROUTINE
        .ZERO   =       0
        .ONES   =       2
        .PATN   =       4
        .PATN1  =       6
        .PATN2   =       10
        .PATN3  =       12
        .PATN4  =       14
        .PATN5  =       16
        .PATN6  =       20
        .PATN7  =       22

        RETURN  =       3       ;MICRO-CODE FOR "RETURN"
        EACAL   =       1       ;MICRO-CODE FOR "EACALL"
;SOME CLOCK COUNT EQUTES NECESSARY FOR THE PI BOARD TEST
        MHZRAT  =       32      ;FINAL CLOCK RATE FOR KL10
        DRPCYC  =       ^D3     ;M-CLKS NECESSARY FOR PI CYCLE TO DROP
                                ;AFTER A PI DISMISS
        PI4CNT  =       ^D17+DRPCYC     ;NO.CLOCKS TO INITIATE A LOAD/TEST
                                ;SEQUENCE ON THE PI BOARD
        FRCXFR  =       <^D8*MHZRAT>+1  ;NO. CLOCKS TO CAUSE "PI XFER FORCE"
                                ; TO SET
;EQUATES FOR CRA6 EBUS DATA POINTERS
        EDATAA=0
        EDATAB=2
        EDATAC=4
        EDATAD=6
        EDATAE=10
        EDATAF  =12
        EDATAG=14
        EDATAH=16
        EDATAI=20
        EDATAJ=22
        NOEDAT=377


;SEQ140


.SBTTL  *ETRAP*  EBOX TRAP HANDLER AND TABLE
.REM    %
THIS TRAP HANDLER IS USED TO CALL EBOX SUBROUTINES IN A MANNER
EQUIVALENT TO "JSR R5, SUBROUTINE" CALL.  IT HAS THE ADVANTAGE THAT
IT CAN BE USED BY ISOLATION ROUTINE SHWICH ARE NOT ASSEMBLED WITH THE
SUBROUTINES AND TAKES ONLY A SINGLE PDP-11 WORD PER CALL.  THE COST IS
SPEED.
%
ETRAP:  MOV     R5,ESAVE        ;SAVE R5
        MOV     (SP),R5 ;GET TRAP PC TO R5
        MOVB    -2(R5),R5       ;USE IT TO GET TRAP #
        ASL     R5              ;MULTIPLY TRAP # BY 2
        MOV     $$CNT(R5),ELINK ;PUT TRAP VECTOR IN LINK LOCATION
        POP     R5              ;RESTORE TRAP PC TO R5
        POP     PS              ;RESTORE CALLER'S STATUS
        PUSH    ESAVE           ;PUT R5 ON STACK (FOR RTS R5)
        JMP     @ELINK          ;DISPATCH
ESAVE:  .WORD   0               ;TEMPORARY STORAGE FOR R5
ELINK:  .WORD   0               ;STORAGE FOR LINK ADDRESS

;YE OLDE TRAP TABLE:

$$CNT:  .WORD   $CLRWD  ;TRAP +0
        .WORD   $SETWD
        .WORD   $ROLWD
        .WORD   $RORWD
        .WORD   $MOVWD
        .WORD   $CLRMI
        .WORD   $SHOVE
        .WORD   $GRAB
        .WORD   $AD             ;TRAP+10
        .WORD   $AR
        .WORD   $BR
        .WORD   $COND
        .WORD   $DISP
        .WORD   $FE
        .WORD   $FM
        .WORD   $J
        .WORD   $MEM            ;TRAP+20
        .WORD   $MQ
        .WORD   $NUM
        .WORD   $SC
        .WORD   $SCAD
        .WORD   $SH
        .WORD   $T
        .WORD   $VMA


;SEQ142

        .WORD   $ADT    ;TRAP +30
        .WORD   $ART
        .WORD   $BRT
        .WORD   $CONDT
        .WORD   $DISPT
        .WORD   $FET
        .WORD   $FMT
        .WORD   $JT
        .WORD   $MEMT   ;TRAP +40
        .WORD   $MQT
        .WORD   $NUMT
        .WORD   $SCT
        .WORD   $SCADT
        .WORD   $SHT
        .WORD   $TT
        .WORD   $VMAT
        .WORD   $MWORD  ;TRAP +50
        .WORD   $CHKMI
        .WORD   $MSK36
        .WORD   $MK36T
        .WORD   $MICLD
        .WORD   $ACSET
        .WORD   $ACSTT
        .WORD   $ARLO2
        .WORD   $DCOMP  ;TRAP +60
        .WORD   $MCOMP  
        .WORD   $RCOMP
        .WORD   $PAT80
        .WORD   $PAT36
        .WORD   $PAT16
        .WORD   $PATCO
        .WORD   $CTLMC
        .WORD   $CTLCM  ;TRAP +70
        .WORD   $ACREF
        .WORD   $DATCO
        .WORD   $DATEV
        .WORD   $DATOD
        .WORD   $SPARE  ;THIS TRAP UNUSED
        .WORD   $SPARE
        .WORD   $SPARE


;SEQ143

        .WORD   $SPARE
        .WORD   $CLEAR
        .WORD   $CLRBF
        .WORD   $SETBF
        .WORD   $ROLBF
        .WORD   $RORBF
        .WORD   $CLR$M
        .WORD   $FLGMC
        .WORD   $FLGCM  ;TRAP +110
        .WORD   $COMBF
        .WORD   $SPARE
        .WORD   $PI.CH
        .WORD   $MEMRQ
        .WORD   $NOMRQ
        .WORD   $NOC0
        .WORD   $XBUF
        .WORD   $XBUF0  ;TRAP +120
        .WORD   $STUFF
        .WORD   $SCDMC
        .WORD   $SCDCM
        .WORD   $AR2SC
        .WORD   $CA2SC
        .WORD   $GETMI
        .WORD   $INCWD
        .WORD   $PARCH  ;TRAP +130
        .WORD   $M.RES
        .WORD   PNTUML
        .WORD   $RUNCL
        .WORD   $CRMHL
        .WORD   $CRADR
        .WORD   $EACLT
        .WORD   $EACAL

$SPARE: PMSG<TRAP TO UNUSED TRAP!\>
        JMP     NORMAL


 


;SEQ144

.SBTTL  *ETAB2B* TEST DISPATCH TABLE

TESTAB: .BYTE   ^D39            ;THERE ARE 39 TESTS
        .BYTE   'F              ;ISOLATION ROUTINE PREFIX AND ENABLED
        .WORD   EEDP01          ;TEST 1:DATA PATH BASIC MUX SELECT
        .WORD   EEDP02      ;TEST 2:DATA PATH BASIC INTERFERENCE PATTERNS
        .WORD   ESCD1           ;TEST 3:SC REGISTER
        .WORD   EEDP03          ;TEST 4:SHIFTER BOARD TEST
        .WORD   EEDP04          ;TEST 5:DATA PATH ADDR ALU & CRY SKP
        .WORD   EDP4A           ;TEST 6:AD FLOATING 1S FOR "-AD=0"
        .WORD   EEDP05          ;TEST 7:FAST MEMORY BASIC INTERFERENCE
        .WORD   EEDP06          ;TEST 8:FAST MEMORY RAM ADDRESSING AND DATA TEST
        .WORD   EVMA01          ;TEST 9:VMA & ADDR BRK DATA AND INTERFERENCE
        .WORD   EVMA02          ;TEST 10:VMA & ADDR BRK MATCH (18-31) LOGIC
        .WORD   EVMA07          ;TEST 11:PC AND VMA HELD REGISTERS STATIC TEST
        .WORD   EVMA03          ;TEST 12:PC AND VMA HELD REGISTERS FULL SPEED TEST
        .WORD   EVMA04          ;TEST 13:VMA INC,DEC TEST       ;VMA ADDER ALU
        .WORD   EVMA05          ;TEST 14:VMA "AC REF" & "VMA SECTION 0" TEST
        .WORD   EVMA06          ;TEST 15:VMA PREV SECT REG,VMA IN MUX,ARMM 13-17
        .WORD   EVMA08          ;TEST 16:VMA LOCAL,LOCAL AC ADDR, & AC REF LOOSE ENDS
        .WORD   EMCL4           ;TEST 17:PAGE ILLEGAL ENTRY LOGIC
        .WORD  EFLAG3          ;TEST 18:ARITHMETIC OVERFLOW FLAGS
        .WORD   ETSAT1          ;TEST 19:TEST SATISFED LOGIC
        .WORD   ECON4           ;TEST 20:GO/START/RUN, I/O LEGAL AND COND ADR 10 LOGIC
        .WORD   ECLK6           ;TEST 21:CLOCK BOARD PAGE FAIL LOGIC
        .WORD   ECLK7           ;TEST 22:CLOCK BOARD SIMULATED MBOX RESPONSE LOGIC
        .WORD   ESCD2           ;TEST 23:BASIC 10-BIT DATA PATHS
        .WORD   ESCD3           ;TEST 24:SCAD AND ARMM MULTILEXERS
        .WORD   ESCD4           ;TEST 25:SC .GE. 36 LOGIC
        .WORD   ESCD5           ;TEST 26:10-BIT ADDER
        .WORD   PIZZA1          ;TEST 27:PI ON FLOPS, PI GEN FLOPS, PI ACTIVE
        .WORD   PIZZA2          ;TEST 28:LOAD-TEST RING COUNTER, EBUS REQ, EBUS PI GRANT
        .WORD   PIZZA3          ;TEST 29:PIR EN TO PIR FLOPS,PIR & PIH DECODERS&PI DISMI
        .WORD   PIZZA4          ;TEST 30: PI "TIM1-TIM7-COMP" RING CNTR,PI "TIMER DONE" C
        .WORD   PIZZA5          ;TEST 31:EBOX CNTRL OF PI.EBUS REQ,EBUS REL,DEMAND,HALTE
        .WORD   PIZZA6          ;TEST 32:PHYSICAL NUMBER FLOPS & PHYS NO. PIRORITY ENCOD
        .WORD   PIZZA7          ;TEST 33:APR PIA 094,02,01-APR PHY NO, & PIR EN
        .WORD   PIZZA8          ;TEST 34:MTR PIA 04,02,01-MTR PHY NO. & PIRO
        .WORD   EPAR1           ;TEST 35:APR FM 36 RAM CHIP ADDRESS & DATA TEST
        .WORD   EPAR2           ;TEST 36:AR&ARX PARITY CHAIN, CON AR & ARX 36 & CLK AR-A
        .WORD   EPAR3           ;TEST 37:AR&ARX PARITY PAGE FAIL,FM PARITY CHAIN, & FM P
        .WORD   ECRA06          ;TEST 38:MICRO-CODE SKIP CONDITIONS(COND 40-57) & DISPAT
        .WORD   PIDTE           ;TEST 39:EBUS PI00-PI07,DTE20 PIA ASSIGNMENTS,DTE20 API

;SEQ145

;INITIALIZATION ROUTINE DISPATCH TABLE.

INITAB: .WORD   ONCE    ;PRINT PROGRAM HEADER
        .WORD   IEDP1   ;TEST 1:EEDP01
        .WORD   EDPCOM  ;TEST 2: EEDP02
        .WORD   ISCD1   ;TEST 3:ESCD1
        .WORD   EDPCOM  ;TEST 4:EEDP03
        .WORD   IEDP4   ;TEST 5:EEDPO4
        .WORD   EDPCOM  ;TEST 6:EDP4A
        .WORD   EDPCOM  ;TEST 7:EEDP05
        .WORD   EDPCOM  ;TEST 8:EEDP06

        .WORD   EDPCOM  ;TEST 9:EVMA01
        .WORD   IVMA02  ;TEST 10:EVMA02
        .WORD   IVMA03  ;TEST 11:EVMA07
        .WORD   IVMA03  ;TEST 121:EVMA03
        .WORD   IVMA04  ;TEST 13:EVMA04
        .WORD   IBUF0   ;TEST 14: EVMA05
        .WORD   IBUF0   ;TEST 15:EVMA06
        .WORD   IVMA02          ;TEST 16:EVMA08
        .WORD   IMCL4   ;TEST 17:EMCL4
        .WORD   IFLAG0  ;TEST 18:EFLAG3
        .WORD   ITSAT   ;TEST 19:ETSAT1
        .WORD   ICTL1   ;TEST 20:ECON4
        .WORD   ICLK6   ;TEST 21:ECLK6
        .WORD   ICLK7   ;TEST 22:ECLK7
        .WORD   ISCD2   ;TEST 23:ESCD2
        .WORD   ISCD3   ;TEST 24:ESCD3
        .WORD   ISCD3   ;TEST 25:ESCD4
        .WORD   ISCD3   ;TEST 26:ESCD5
        .WORD   IPIZZ1  ;TEST 27:PIZZA1
        .WORD   IPIZZ1  ;TEST 28:PIZZA2
        .WORD   IPIZZ3  ;TEST 29:PIZZA3
        .WORD   IPIZZ1  ;TEST 30:PIZZA4
        .WORD   IPIZZ5  ;TEST 31:PIZZA5
        .WORD   IPIZZ1  ;TEST32:PIZZA6
        .WORD   IPIZZ7  ;TEST 33:PIZZA7
        .WORD   IPIZZ8  ;TEST 34:PIZZA8
        .WORD   PARCOM  ;TEST 35:EPAR1
        .WORD   PARCOM  ;TEST 36:EPAR2
        .WORD   PARCOM  ;TEST 37:EPAR3
        .WORD   ICRA6   ;TEST 38:ECRA06
        .WORD   PIDCOM  ;TEST 39:PIDTE


;SEQ146

.SBTTL EINIT* INITIALIZATION CODE

.SBTTL BRIEF EXPLANATION OF THIS DIAGNOSTIC

.REM    %

THIS PART OF THE EBOX DIAGNOSTIC USES IT S OWN SET OF MICROCODE WHICH IS
LOADED DIRECTLY INTO THE (NOW PROVEN) CRAM BY THE FIRST INITIALIZATION
ROUTINE.  ONE OF THE DATA PATH TESTS ALSO USES REGULAR DRAM DISPATCHES,
USING DRAM CODE WHICH IS LOADED INTO THE MACHINE BY THE CORRESPONDING
INITIALIZATION ROUTINE.  THUS IT IS IMPORTANT THAT THE BASIC MICRO-
PROCESSOR PART OF THE EBOX BE VERIFIED TGO BE WORKING CORRECTLY USING EBOX 1
(THE FIRST PART OF THIS DIAGNOSTIC) BEOFRE ATTEMPTING TO RUN THIS PART.
THE FILE CONTAINING THE SPECIALIZED MICROCODE IS EBOX.RAM.  REFER TO
ITS LISTING FOR DETAILS OF THE INDIVIDUAL MICROWORDS REFERNCED BY
THE ESTS IN THIS SECTION.

IN MOST CASES, THE TESTS ARE DESIGNED TO RUN THE MICROCODE AT BURST SPEED
SO THAT ANY TIMING-DEPENDENT PROBLEMS WILL SHOW UP.  THUS A TEST WHICH
COMPARES THE STATE OF SOME LOGIC AT SEVERAL SUCCESSIVE CLOCK TICKS WILL
BEGIN EACH SUBTEST WITH THE LOGIC IN ITS INITIALIZED STATE AND BURST
THE CLOCK ONE MORE TIME FOR EACH SUCCESSIVE SUBTEST.

THERE ARE ALSO SOME CONTROL LOGIC TESTS WHICH DEPEND ON VARIOUS DATA
PATHS OR LOGIC CHECKED BY THIS PART OF THE DIAGNOSTIC.  SOME OF
THESE USE BYTE COMPARISON TABLES ISMILAR TO THE ONES USED IN PART 1.
FOR CONVENIENCE, THE INITIAL STATES OF THE RELEVANT TABLES ARE REPEATED
HEREIN FOLLOWING THIS SECTION.  REFER TO THE LISTING FOR PART 1 FOR MORE
DETAIL.  ALSO SEE THE LISTING AT THE BEGINNING OF EACH TEST FOR THE MORE
DETAILED EXPLANATION OF ITS OPERATION.
%

;SEQ147


.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE CONTROL LOGIC

.REM    %
BIT#    INDEX  0  (FR 110)              INDEX 1 (FR111)

1       APR SWEEP BUSY EN       = 0
2               X                 X             X               X
3               X                  X            X               X
4               X                 X             X               X
5               X                 X             X               X
6       APR SBUS ERR IN         =  X    APR CURRENT BLOCK 4     =  0
7       APR NXM ERR IN          =  X    APR CURRENT BLOCK 2     =  0
8       APR I/O PF ERR IN         X     APR CURRENT BLOCK 1     =  0
9                                       APR PREV BLOCK 4        =  0

        INDEX  2  (FR 114)              INDEX 3  (FR 115)

2               X               X               X                 X
3               X                 X             X               X

4               X                 X             X                 X
5               X                 X             X                 X
6               X                 X             X                 X

7       APR MBOX CTL 03         = 0     APR MBOX CTL 06         = 0
8       APR FM BLOCK 4          = 0     -APR SET PAGE FAIL      = 1
9       APR FM BLOCK 2          = 0     APR EBUS RETURN         = 0

        INDEX  4  (FR 112)              INDEX  5  (FR 113)

6       APR SBUS ERR EN IN      = 0             X                 X
7       APR NXM ERR EN IN       = 0             X                 X
8       APR I/O PF ERR EN IN    = 0             X                 X
9       APR MB PAR ERR EB IN    = 0     APR FETCH COMP          = 0
10      APR C DIR P ERR EN IN   = 0     APR READ COMP           = 0

11      APR S ADR P ERR IN      = 0     APR WRITE COMP          = 0
12      APR PWR FAIL EN IN      = 0     APR USER COMP           = 0

13      APR SWEEP DONE EN IN    = 0             X                 X

        INDEX  6  (FR 116)              INDEX  7  (FR 117)

6               X               = X             X                 X
7       APR WR PT SEL 0         = 0     APR WR PT SEL 1         = 0

8       -APR PT DIR WR  = 1     -APR PT WR              = 1
9       -APR EBUS REQ           = 1     APR EBUS DEMAND         = 0
10      APR EBUS F01 F          = 0     APR EBOX SEND F02       = 0

11      APR ANY EBOX ERR FLG    =  0    -APR FM WRITE           = 0
12      APR EBOX UBR            = 0     APR EBOX EBR            = 0
13      APR EN REFILL RAM WR    =  X    APR EBOX SPARE          = 0
%


;SEQ148

.REM    %
BIT#    INDEX 10  (FR 110)              INDEX 11 (FR 111)*

9       APR MB PAR ERR IN       = X     
10      APR C DIR P ERR IN      = X     APR PREV BLOCK 2        = 0
11      APR S ADR P ERR IN      = X     APR PREV BLOCK 1        = 0
12      APR PWR FIL IN          = X     SH AR EXTENDED          = 0
13      APR SWEEP DONE IN       = X     APR FM EXTENDED         = X
14      APR APR INTERRUPT       = 0     APR AC + #09            = 0
15              X                X      APR AC + #10            = 0
16              X                X      APR AC + #11            = 0

17                                      APR AC + #12            = 0

        INDEX 12  (FR 114)              INDEX 13  (FR 115)

10      APR FM BLOCK 1          = 0     APR EBOX DISABLE CS     = 0
11      APR FM ADR 10           = 0     -APR WR BAD ADR PAR     = 1

12      APR FM ADR  4           = 0     APR EBOX CCA            = 0
13      APR FM ADR 2            = 0     APR EBOX ERA            = 0
14      APR FM ADR  1           = 0     APR EBOX SBUS DIAG      = 0

15      APR F02 EN              = 1     -MCL MEM/REG FUNC               = 1
16      APR FM 36               = X     -APR EBOX LOAD REG      = 1
17      APR FM ODD PARITY       = X     -APR EBOX READ REG      = 1

        INDEX  14  (FR 130)             INDEX 15 (FR 131)

17              X                 X             X                 X
18      CON WR EVEN PAR ADR      0      CON CACHE LOOK EN               = 0

19      CON WR EVEN PAR DATA    = 0     CON CACHE LOAD EN       = 0
20      CON WR EVEN PAR DIR     = 0             X                 X
21              X               X       -CON KI10 PAGING MODE   = 0

22              X                X      CON TRAP EN             = 0
23              X                X              X                X
24              X               X               X                 X

        INDEX 16  (FR 132)*             INDEX 17  (FR 133)

17              X                X              X                X
18      -CON COND EN 00-07      = 0     -CON SKIP EN 40-47      = 1

19      -CON COND/SEL VMA       = 1     CON COND/VMA_#  = 0
%
;SEQ149

.REM    %
BIT#    INDEX 20  (FR 134)              INDEX 21  (FR 135)

17              X               X               X               X
18      -CON SKIP EN 50-57      =X      CON DELAY REQ   = 0

19      CONCOND/LOAD VMA HELD = 0       -CON LOAD SPEC INSTR    = 1
20      CON SR 00               = 0     CON SR 01               = 0
21      CONNICOND TRAP EN       = 0     CON NICOND 07           = 0

22      CON LOAD ACCESS COND    = 0     -CON INSTR GO           = 1
23      CON UCODE STATE 01      = 0     CON UCODE STATE 03      = 3
24      -CON FM WRITE PAR       = 1     -CON MBOX WAIT          = 1

        INDEX 22  (FR 136)              INDEX 23  (FR 137)      

17              X                 X             X                 X
18      CON AR 36               = X     CON ARX 36              = X

19      -CON VMA SEL 2          = 1     -CON VMA SEL 1          = 1
20      CON SR 02               = 0     CON SR 03               = 1
21      CON NICOND 08           = 0     CON NICOND 09           = 1

22      CON LOAD DRAM           = 0     CON COND ADR 10         = 0
23      CON UCODE STATE 05      = 0     CON UCODE STATE 07      = 0
24      -CON FM XFER            = 1     -CON PI DISMISS         = 1

        INDEX 24  (FR 100)              INDEX 25  (FR 101)

16              X                 X             X                 X
17              X                 X             X                 X

18      VMA HELD OR PC 01       = 0     VMA HELD OR PC 07               = 0
19      VMA HELD OR PC 02       = 0     VMA HELD OR PC 08       = 0
20      VMA HELD OR PC 03        = 0    VMA HELD OR PC 09       = 0

21      VMA HELD OR PC 04       = 0     VMA HELD OR PC 10       = 0
22      VMA HELD OR PC 05       = 0     VMA HELD OR PC 11       = 0
23      VMA HELD OR PC 06       = 0     VMA HELD OR PC 12       = 0
        
        INDEX 26 (FR 102)               INDEX 27  (FR 103)*

16              X                X              X                X
17              X                X              X                 X

18      MCL VMA READ            = 0     MCL VMA PAUSE           = 0
19      MCL MEM/ARL IND         = 0     -MCL REQ EN             = 1
20      MCL PAGE TEST PRIVATE   = 0     MCL VMA UPT             = 0

21      MCL XR PREVIOUS         = 0     MCL VMA ADR ERR         = 0
22      MCL VMA AD              = 0     MCL VMA INC             = 0
23      MCL XR SHORT            = 1     MCL SHORT STACK         = 1
* = THIS BYTE DIFFERENT FOR MODEEL A AND B
%

;SEQ150

.REM    %
BIT#    INDEX 30  (FR104)               INDEX 31  (FR 105)

16              X                 X             X                 X
17              X                 X             X                 X

18      MCL VMA WRITE           =  0    MCL LOAD AR             = 0
19      MCL VMA USER            = 0     MCL VMA PUBLIC          = 0
20      MCL PAGE UEBR REF        = 0    MCL PAGE ADDRESS COND   = 0

21      -MCL VMAX EN            = 0     MCL VMAX SEL 2          = 0
22      -MCL LOAD VMA CONTEXT   = 1     MCL 23 BIT EA           = 0
23      -MCL EBOX CACHE         = 1     -MCL EBOX MAY BE PAGED   1

        INDEX 32  (FR 106)*             INDEX 33  (FR 107)*

16              X                X              X                X
17              X                X              X                X

18      MCL LOAD ARX            = 0     -MCL STORE AR           = 1
19      -MCL VMA PREVIOUS       = 1     -MCL VMA EXTENDED       = 0
20      MCL     PAGE ILL ENTRY  = 0     MCL VMA FETCXH          = 0

21      MCL VMAX SEL 1          = 0     =MCL VMA PAGED FETCH    = 1
22      MCL 18 BIT EA           = 0     MCL MBOX CYC REQ                = 0
23      MCL REG FUNC            = 0     -MCL EBOX MAP           = 1

        INDEX 34  (FR 100)              INDEX 35  (FR 101)

24      CTL SPEC/SCM ALT        = 0     CTL SPEC/CLR FPD        = 0
25      -CTL SPEC/SAVE FLAGS    = 1     -CTL SPEC MTR CTL       = 1

26      CTL ARL SEL 2           = 0     CTL ARL SEL 1           = 0
27      -CTL ARR LOAD A         = 1     -CTL ARR LOAD B         = 1
28      -CTL AR 00-08 LOAD      = 1     -CTL AR 09-17           = 1

29              X                X              X                X
20              X                X              X                X

        INDEX 36 (FR 102)               INDEX 37  (FR 103)*

24      CTL SPEC/GEN CRY 18     = 0     CTL SPEC/STACK UPDATE   = 0
25      CTL COND/AR_EXP         = 0     -CTL DISP RET           = X

26      CTL ARR SEL 2           = 0     CTL ARR SEL 1   = 0
27      CTL MQM SEL 2           = 0     CTL MQM SEL 1           = 0
28      CTL ARX         = 0     CTL ARL SEL 4           = 0

29              X                 X             X               X
30              X                 X             X                 X
31              X                 X             X                 X
* = THIS BYTE IS DIFFERENT FOR MODEL A AND B
%


;SEQ151


.REM    %

BIT#    INDEX 40  (FR 104)              INDEX 41  (FR 105)*


24      CTL SPEC/FLAG CTL       = 0     CTL SPEC/SP MEM CYCLE   = 0
25      -CTL LOAD PC            = 1     CTL ADX CRY 36          = 0

26      CTL ARXL SEL 2          = 0     -CTL ARXL SEL 1         = 1
27      CTL MQ SEL 2            = 1     CTL MQ SEL 1            = 1
28      CTL AR 00-11 CLR        = 0     CTL AR 12-17 CLR        = 0

29              X                 X             X                 X
30              X                 X             X                 X

        INDEX 42  (FR 106)              INDEX 43  (FR 107)*

24      CTL AD LONG             = 0             -CTL INH CRY 18 = 1
25      CTL ADX CRY 36 A        = 0     DIAG MEM RESET          = 0

26      CTL ARXR SEL 2          = 0     -CTL ARXR SEL 1         = 1
27      CTL MQM EN              = 0     -DIAG LOAD EBUS REG     = 1
28      CTL ARR CLR             = 0     -CTL SPEC CALL          = 1

29              X                 X             X                 X
30              X                 X             X                 X
31              X                 X             X                 X

* = THIS BYTE DIFFERENT FOR MODEL A AND B
%


;SEQ152

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE FLAG LOGIC (SCD BOARD)

.REM    %
        
BIT#    INDEX 0 (FR130)         INDEX 1 (FR131)         INDEX 2 (FR132)

2  SCD TRAP REQ 2 = 0           SCD OV          = 0     VMA HELD OR PC00 = 0
3  SCD TRAP CYC 2 = 0           SCD CRY0        = 0     SCD FOV         = 0


4  SCD TRAP CYC 1 = 0           SCD CRY1        = 0     SCD FXU         = 0
5  SCD TRAP REG 1 = 0   -AD CRY 01              = 1     -AD OVERFLOW 00 = 1
6  SCD FPD      = 0     SCD DIV CHK             = 0     -AD CRY -02     = 1


7       X        X              X                X              X                X
8       X         X             X                 X             X                 X
9       X         X             X                X              X                 X


BIT#    INDEX 3 (FR133)         INDEX 4  (FR134)                INDEX 5 (FR135)


2       SCDPCP  = 0             -SCD USER        1              -SCD PUBLIC EWN = 1
3       SCD LOAD FLAGS  = 0     SCD LEAVE USER  = 0                     SCD PUBLIC  = 0

4  -SCAD=0      = 0             -CON PI CYCLE =  1              SCD KERNEL MODE = 1


5       CLR PRI INSTR   = 0             -SCD USER EN    = 1             -SCD PRI INSTR  = 1
6  SCD NI COND 10       = 0     SCD PUBLIC PAGE = 0             -SCD PRI INSTR EN  = 0

7       X               X               X                X              X        X
8       X               X               X                X              X         X
9       X                X              X                 X             X        X


BIT#    INDEX (FR136)           INDEX 7 (FR137)

2  SCD KERNEL/UIOT = 1          SCD ADR BRK INH = 0

3  SCD TRAP MIX 32 = 0          SCD TRAP MIX 34 = 0

4  SCD TRAP MIX 33 = 0          SCD TRAP MIX 35 = 0

5  SCD USER IOT  = 0            SCD ADR BRK CYC = 0
6  -SCD USER IOT EN =1          SCD ADR BRK PRE = 0


7       X               X       -SCD TRAP CLEAR = 1
8       X               X               X               X
9       X               X               X               X

%

;SEQ153

.SBTTL NOMINAL EXPECTED DATA TABLE FOR THE 10-BIT ARITHMETIC LOGIC (SCD BOARD)

.REM    %

EBUS                            EBUS                    EBUS

BIT#  INDEX 0  (FR130)          BIT#  INDEX 1  (FR131)  BIT#  INDEX 2  (FR132)

07      SC 05 = 0               04      X               07      FE 05 = 0
08      SC 06 = 0               05      X               08      FE 06 = 0

09      SC 07 = 0               06      X               09      FE 07 = 0
10      SC 08 = 0               07      SC 00 = 0       10      FE 08 = 0
11      SC 09 = 0               08      SC 01 = 0               11      FE 09 = 0

12      X                       09      SC 02 = 0       12      X
13      X                       10      SC 03 = 0               13              X
14      X                       11      SC 04 = 0               14      X

EBUS                            EBUS                    EBUS



BIT#  INDEX 3  (FR133)          BIT#  INDEX 4  (FR120)  BIT#  INDEX 5  (FR120)

04      X                       05      AR 05 = 0               X
05      X                       06      AR 06 = 0               X

06      X                       07      AR 07 = 0               X
07      FE 00 = 0               08      AR 08 = 0       00      AR 00 = 0
08      FE 01 = 0               09      X               01      AR 01 = 0

09      FE 02 = 0               10      X               02      AR 02 = 0
10      FE 03 = 0               11      X               02      AR 03 = 0
11      FE 04 = 0               12      X               04


INDEX 6 (FR134) EBUS BIT # 04:  SC SIGN = 0  (RIGHT JUSTIFIED IN BYTE)
INDEX 7 (FR136) EBUST BIT #:  07:       SC .GE. 36 = 0  (SAME)
INDEX 10 (FR135) EBUS BIT# 07:FE SIGN   = 0  (SAME)
INDEX 11 (FR133) EBUS BIT# 07:  -SCAD=0 = 0  (SAME)

%


;SEQ154

.SBTTL NOMINAL EXPECTED DATA FOR ECLK6

.REM    %
                INDEX 0 (FR100) EBUS BIT #32 = 1 FOR CLK INSTR 1777

EBUS BIT#       INDEX 1 (FR102)         INDEX 2 (FR103)

        
  28               X            X               X               X
  29               X            X               X               X

30              CLK ERROR STOP  =0      CLK DRAM PAR ERR        =0

  31            -CLK GO         =1      -CLK BURST              =1
  32            CLK EBOX REQ    =-      CLK MB XFER             =0

  33            CLK SYNC                =1      -CLK EBOX       =1
  34            -CLK PAGE FAIL EN =1    CLK INSTR 1777          =0
  35    CLK FORCE 1777          =0      CLK 1777 EN             =0

                INDEX 3 (FR104)         INDEX 4 (FR107)

  28            --              X               --              X
  29            --              X               --              X

  30            CLK CRAM PAR ERR        =0      CLK PAGE FAIL   =0
  32            CLK SOURCE SEL 2 =X     CLK RATE SEL 1          =X

  33            CLK EBOX SOURCE  =0     CLK EBOX CRL DIS        =0
  34            -CLK FM PAR CHECK =1    -CLK FS CHECK   =1
  35            CLK MBOX CYCLE DIS=1    -CLK ERR STOP EN        =1

                INDEX 5 (FR145)         INDEX 6 (FR144)

                                X                               X
                                X                               X

   0                    --      X       CR ADR 05               =0
   1            CR ADR 00       =0      CR ADR 06               =0
   2            CR ADR 01       =0              CR ADR 07       =0

   3            CR ADR 02               =0      CR ADR 08               =0
   4            CR ADR 04       =0      CR ADR 09               =0
   5            CR ADR 04               =0              CR ADR 10       =0

                INDEX 7 (FR133) EBUS BIT #24 = 0 FOR -CON MEM CYCLE
                INDEX 10 (FR133) EBUS BIT # 5 = 0 FOR CON CLR PRI INSTR
                INDEX 11 (FR107) EBUS BIT #28 = 1 FOR -CTL SPEC CALL

%



;SEQ155

.SBTTL ONETIME INITIALIZATION CODE

;DEFINE THE HIGHEST ALLOWABLE CRAM ADDRESS:

        RAMTOP = ^D2047         ;HIGHEST CRAM ADDRESS = 2047

;TYPE PROGRAM NAME AND DO ANY ONETIME INITIALIZATION:

ONCE:   PMSG<TYMSHARE DIAGNOSTIC SYSTEM-TEBOXB\>
        PMSG<KL-10 MODEL B>
        PMSG< CPU EBOX DIAGNOSTIC, PART >
        PMSG<2>
        PMSG< (>
        PMSG<TEB>
        PMSG<OXB>
        PMSG<)\>
        PMSG<	VERSION: >
        PMSG<1.0\>      ;VERSION FOR EBOXB


        MOV     #ETRAP,34               ;MAKE TRAPS COME TO EBOX
        MOV     #340,36         ;SET TRAP STATUS


;SEQ157

;NOW DON'T FORGET TO SETUP DTE20 POINTERS
        PUSH    #^D16           ;LOOP COUNT IS 16

        DTEBAS                  ;CALL FOR DTE20 BASE ADDRESS
        MOV     R0,R1           ;PUT DTE20 BASE ADDRESS INTO R1
        MOV     #.DELAY,R0      ;ADDRESS OF FRIST DTE20 POINTER
1$:     MOV     R1,(R0)+        ;DATA TO POINT
        CMPB    (R1)+,(R1)+     ;ADD TWO TO CONTENTS OF R1
        DEC     (SP)
        BGT     1$              ;CONTINUE IF NOT DONE YET
        POP     R0              ;CLEANUP STACK IF DONE

        RTS     PC


;SEQ157

.SBTTL INITIALIZATION ROUTINE ENTRY POINTS

.REM    %
        
BEGIN BOTH TEST'S INITIALIZATION BY ATTEMPTING TO CLEAR MOST STORAGE
ELEMENTS IN THE MACHINE.  THIS IS TO PREVENT THE XOR TESTER FROM FAILING
WHILE THE DIAGNOSTIC IW TESTING LOGIC NOT DIRECTLY RELATED
TO THE STORAGE ELEMENTS.  (THE XOR STILL "SEES" THE OUTPUTS EVEN IF
THEY ARE "DON'T CARES" TO THE TEST.)
%

IEBUS0: MOV     #777,$NOCHK     ;SERT "NO CHECK" INITIALIZATION FLAG
        JSR     PC,ZFMEX        ;AND FM EXTENDED AND FM 36 RAMS
        JSR     PC,ZDRAM        ;AND DRAM
        JSR     PC,ZMCL         ;AND VMA CONTEXT FLOPS ON MCL
        JSR     PC,ZSR          ;AND STATE REG ON CON
        $ACSET  0               ;CLEAR AC#
        $ACREF  1               ;AND VMA.
        DFWRTT                  ;TRY LOADING 1'S TO AR
        ONES                    ;TO TESTS MRESET'S POWER
        LDAR                    ;TO CLEAR THEM.

        JMP     IBUF0           ;CLEAR THE BUFFERS AND RETURN



;SEQ157

;INITIALIZATION FOR DATA PATHS:

;BEGIN WITH THE BASIC STORAGE CLEARING INITIALIZATION OF EBOX1:

IEDP1:  JSR     PC,IEBUS0               ;CLEAR RAMS AND THINGS

;THEN LOAD THE MICROCODE INTO THE C-RAM
;SOME TEMPORARY EQUATES
        EMICNO=1                ;SWITCH SAYS DONT ASSEMBLE EBOX MICRO-CODE
                                ;JUST USE THE MICRO-CODE SYMBOL TALBE
        MOV     JUSLDD,R0               ;HAS FILE BEEN LOADED INTO MACHINE??
        BEQ     1$              ;BR IF YES, MICRO-CODE ALREADY IN
        CLRB    CONSOL-2        ;OTHERWISE, TELL LODMIC TO DO IT
1$:     JSR     PC,LODMIC               ;GO GET EBOX DIAGNOSTIC MICRO-CODE

        $MOVWD  NY1,PATN        ;SET EXPECTED
        $MOVWD  NY2,PATN1       ;MORE OF SAME
        $MOVWD  NY3,PATN2       ;DITTO
        $MOVWD  NY4,PATN3       ;AGAIN

;SEQ158

        $MOVWD  NY5,PATN4

;SPECIAL CODE FOR XORING M8511(CRA BOARD)
        TSTB    M8511X          ;IS SPECIAL CRA FEATURE TURNED ON??
        BEQ     EDPCOM          ;BR IF IT IS NOT

;FALL TO HERE ONLY IF "XORING" CRA BOARD(M8511)
        TSTB    M8511X+1        ;IS THIS THE FIRST PASS OF THE XOR??
        BNE     2$              ;BR IF NO.

;OTHERWISE PRINT A MESSAGE SAYING SO
        PMSG<\XOR-ING M8511..  SPECIAL INITIALIZATION\>
        COMB    M8511X+1        ;AND TURN OFF PRINTING THAT MESSAGE AGAIN
2$:     JSR     PC,ZCRAM                ;ZERO ALL C-RAM
        MOV     #PCMD,R0        ;GET MICRO LOADING COMMAND
        PRGCMD                  ;EXECUTE IT..LOAD MICRO CODE
        BCC     EDPCOM          ;NO ERROR, THEN CONTINUE
        JMP     LODERR          ;JUMP IF A LOAD ERROR


;SEQ159

;COMMON DATA PATH INITIALIZATION:

EDPCOM: JSR     PC,IBUF0                ;CLEAR ALL DPD11 CORE BUFFERS
        JSR     PC,XXVIRG               ;EXECUTE THE MICRO-CODE THAT CLEARS THE FM

DPATHC: $BR     1,1             ;LOAD BR & BRX
        $COND   10              ;SET FM WRITE
        CLR     R0              ;WRITE THIS TO CRAM ADDR 0
        MOV     #$MICRO,R1      ;LOAD THIS BUFFER
        WCRAM                   ;DO IT
        DFXCTT                  ;START THE BOX CLOCK
        STRCLK          
        DFXCTT                  ;AND STOP IT..DATA PATH NOW CLEAR
        STPCLK
        $CLRMIC                 ;INSURE THAT C-RAM LOCATION
        CLR     R0              ;ZERO IS LEFT
        MOV     #$MICRO,R1      ;WITH ALL ZERO DATA
        WCRAM
        RTS     PC

JUSLDD: .WORD   -1
NY1:    WD36    7777,7777,7776
NY2:    WD36    1777,7777,7777
NY3:    WD36    3777,7777,7776
NY4:    WD36    1737,3737,3737
NY5:    WD36    6367,6767,6767
NY6:    WD36    0000,0000,0001
NY7:    WD36    7777,7777,7774
NY8:    WD36    1313,1313,1313
        .EVEN
        M8511S = .              ;SAVE LOCATION COUNTER
        . = 70000-2             ;PUT NEXT DATUM AT END OF MY CORE
M8511X: .WORD   0               ;WORD FOR SPECIA XORING OF CRA BRD(M8511)
        . = M8511S              ;RESTORE LOCATION CNTR & CONT.
;INITIALIZATION FOR EDP4.  ROUTINE LOADS THE EVEN DRAM LOCATIONS
;FROM 2 TO 124 WITH DRAM DISPATCHES USED BY THE ADDER TEST.

IEDP4:  JSR     PC,EDPCOM               ;CLEAR BUFFERS
        MOV     #INCONN,R4      ;GET PTR TO LST OF DRAM DISPATCHES
        CLR     R5
1$:     INC     R5              ;START WITH A 1 (=DRAM ADR 2)
        CLR     R0              ;TELL SUBROUTINE TO RESET THE KL10
        JSR     PC,DRLDR                ;ROUTINE TOW RITE DRAM ADDRESS
        JSR     PC,GLOWRM               ;ROUTINE TO WRITE DRAM DATA
        CMP     R5,#^D48        ;WAS THAT THE LAST?
        BLT     1$              ;BR BACK IF NOT
        RTS     PC              ;ELSE, DONE.


;SEQ160

;INITIALIZATION FOR VMA TEST..
;SETS UP POINTER FOR DCOMP AND RCOMP TO USE
;THEN CLEARS STANDARD BUFFERS
IVMA02: MOV     #NEB04,DCOMPX   ;SET POINTER FOR DCOMP & RCOMP
        JMP     IBUF0           ;AND THEN CLEAR STANDARD BUFFERS

;INITIALIZATION FOR VMA LOGIC:
;THIS INITIALIZATION ROUTINE MUST CLEAR A 36-BIT BUFFER TO BE USED 
;FO@ EXPECTED DATA AND MUST ALSO ATTEMPT TO CLEAR THE PC AND
;ALL OF THE "SECTION" PARTS OF ADDRESSING REGISTERS (BITS 13-17)

IVMA03: MOV     #IMVMA3,R0      ;START ADDRESS OF INITIALIZING MICRO-CODE
        WWADR                   ;TO CR AFTER A MRESET
        ECLOK 
        MOV     #25,R0          
        BURST                   ;EXECUTWE ALL INITIALIZING RAM WORDS
        $CLRWD  PATN1           ;CLEAR 36 BITS
        RTS     PC

;INITIALIZATION FOR TEST VMA 4..THIS INIT REUTINE MUST REFRESH
;A  MICRO-CODE LOCATION WHICH IS DESTROYED BY HE RUNNING OF THE
;VMA4 TEST.

IVMA04: $CLRMI  $MICRO          ;CLEAR A C-RAMS WORTH OF BUFFER
        $J      M4.1VMA         ;KEEP THIS MICRO JUMP IN THE RAM WORD
        MOV     #M4.2VMA,R0     ;GET RAM WORD ADDRESS
        MOV     #$MICRO,R1      ;GET BUFFER CONTENTS
        WCRAM                   ;AND WRITE THE RAM WORD TO RTHE RAM
        JMP     IBUF0           ;NOW GO CLEAR DOMMON BUFFERS AND OUT


;SEQ161

;INITIALIZATION FOR ECLK6 (PAGE FAIL LOGIC)

ICLK6:  $ITAB   CPDAT,CLKD6,12  ;LOAD SPECIAL CCLOCK TABLE
        
        JMP     IBUF0           ;COMMON FINISH

CLKD6:  .BYTE   4               ;DATA TABLE
        .BYTE   26
        .BYTE   4
        .BYTE   23
        .BYTE   43      
        .BYTE   0
        .BYTE   0
                .BYTE   0
        .BYTE   0
        .BYTE   1

;INITIALIZATION FOR ECLK7 (SIMULATED MBOX RESPONSE LOGIC)

ICLK7:  $ITAB   LEAD,CLKD7,5    ;LOAD SPECIAL DATA TABLE
        JMP     IBUF0           ;COMMON FINISH

CLKD7:  .BYTE   0               ;"CLK MB XFER" FALSE
        .BYTE   0               ;"MCL MBOX CYCLE" FALSE
        .BYTE   1               ;"-CON MEM CCLE" FALSE
        .BYTE   1               ;"-CON MBOX WAIT" FALSE
        .BYTE   1               ;"-CON FM XFER" FALSE
        .BYTE   0               ;DUMMY BYTE TO MAKE THINGS COME OUT EVEN




;SEQ162

.REM    %
THIS CODE SETS ALL CONTROL LOGIC STORAGE ELEMENTS WHICH ARE CLEARED
BY RESET.  A RESET IS DONE AFTER EACH SET OPERATION TO ABORT POSSIBLE
PI OR MBOX CYCLES.  THE FOLLOWING STEPS ARE PERFOMED:

STEP    ACTION                  LOGIC AFFECTED

1       MEM/AD FUNC + AD 1-12   LOAD REQ EN REGS ON APR AND MCL
        SPEC/SP MEM CYCLE       LOAD VMA CONTEXT REGS ON MCL
        COND/SPEC INSTR + #777  LOAD SPEC INSTR REG,SET PI AND
                MEM CYCLE ON CON

2       CONO APR + EBUS 6-13,   SET ALL ERROR INTERRUPT FLOPS ON
                20 AND 23               SPR

3       CONO PI + EBUS 18-20    LOAD REG ON CON

4       CONO PAG + EBUS 18-22   LOAD REG ON CON

5       DATA0 +EBUS 9-12        LOAD COMP REG ON APR

6       LOAD PREV CONTEXT AND   LOAD REGS ON APR
        AC BLOCKS + EBUS 6-17

7       COND/EBOX STATE REG     LOAD EBOX STATE REG ON
                + #252          CON

8       COND/EBUS CTL + #467    LOAD EBUS CTL REG ON APR

9       COND/MBOX CTL + #47     LOAD MBOX CTL REG ON APR
%




;SEQ165

;INITILIZE THE CONTROL LOGIC'S DCOMP TBLES. CLEAR STORAGE ELEMENTS

ICTL1:  MOVB    #110,CTLFUN             ;RESTORE 1ST BYT'S STUFF
        MOVB    #55,CTLBYT              ;SOMETIMES USED BY TEST FOR 
                                        ;OTHER THINGS...)
        $ITAB   CTLMSK, CTLM1, 44       ;LOAD NOMINAL MASK TABLE
        $ITAB   CTLDAT, CTLD1,          ;AND NOMINAL DATA
 
 
 

ICTLF:  JSR     PC,IBUF0                ;START WITH BUFFERS CLEAR
        MOV     #777,$NOCHK             ;SET THE "NO CHECK" INITIALIZATION FLAG
        JSR     PC,ZMCL         ;CLEAR VMA CONTEXT FLOPS ON MCL
        JSR     PC,ZSR          ;CLLEAR STATE REGISTER
        JSR     PC,ZCRAM0               ;CLEAR CRAM LOC 0
        JSR     PC,ZDRAM0               ;CLEAR IR AND AC FIELD
        $ACSET  0               ;CLEAR AC #
        $ACREF  1                       ;CLEAR VMA SO NO MEM REFGS
        JMP     IBUF0           ;CLEAR BUFFERS & DO RESET


;SEQ166

;CONTROL LOGIC'S MASK TABLE

CTLM1:  .BYTE   177             ;MASK FOR INDEX 0
        .BYTE   360             ;1
        .BYTE   370             ;2
        .BYTE   370             ;3
        .BYTE   0               ;4
        .BYTE   341             ;5
        .BYTE   201             ;6
        .BYTE   200             ;7

        .BYTE   373             ;10
        .BYTE   77              ;11B
        .BYTE   3               ;12
        .BYTE   0               ;13

        .BYTE   217             ;14
        .BYTE   223             ;15
        .BYTE   200             ;16B
        .BYTE   200             ;17

        .BYTE   200             ;20
        .BYTE   200             ;21
        .BYTE   300             ;22
        .BYTE   300             ;23
        .BYTE   300             ;24
        .BYTE   300             ;25
        .BYTE   301             ;26B
        .BYTE   301             ;27B
        .BYTE   300             ;30
        .BYTE   300             ;31
        .BYTE   300             ;32
        .BYTE   300             ;33
        .BYTE   7               ;34
        .BYTE   7               ;35
        .BYTE   7               ;36
        .BYTE   107             ;37B ("DISP RET" UNUSED..BREAKS XOR)

        .BYTE   7               ;40
        .BYTE   7               ;41
        .BYTE   7               ;42
        .BYTE   7               ;43


;SEQ167


;CONTROL LOGIC'S NOMINAL EXPECTED DATA TABLE:



CTLD1:  .BYTE   0               ;EXPECTED DATA FOR INDEX 0
        .BYTE   0               ;1
        .BYTE   0               ;2
        .BYTE   2               ;3

        .BYTE   0               ;4
        .BYTE   0               ;5
        .BYTE   60              ;6
        .BYTE   44              ;7
        .BYTE   0               ;10
        .BYTE   0               ;11
        .BYTE   4               ;12
        .BYTE   107             ;13
        .BYTE   0               ;14
        .BYTE   0               ;15
        .BYTE   74              ;16B
        .BYTE   113             ;17
.BYTE   101             ;20
        .BYTE   45              ;21
        .BYTE   41              ;22
        .BYTE   51              ;23
        .BYTE   0               ;24
        .BYTE   0               ;25
        .BYTE   0               ;26B
        .BYTE   20              ;27B

        .BYTE   3               ;30
        .BYTE   1               ;31
        .BYTE   20              ;32B
        .BYTE   65              ;33B
        .BYTE   130             ;34
        .BYTE   130             ;35
        .BYTE   0               ;36
        .BYTE   100             ;37
        .BYTE   120             ;40
        .BYTE   60              ;41B
        .BYTE   0               ;42
        .BYTE   270             ;43B



;SEQ165

;INITIALIZATION FOR TEST EMCL4 (SPECIAL CONTROL LOGIC TABLE):

IMCL4:  MOVB    #110,CTLFUN     ;RESTORE FIRST DIAG FUNCTION
        MOVB    #55,CTLBYT      ;AND THE BYTE SPECIFICATION
        $ITAB   CTLMSK,CTLM1,44 ;LOAD NOMINAL MASKS
        $ITAB   CTLDAT,MCL4D,  ;AND SPECIAL DATA
        JMP     ICTLF   ;DO REST OF USUAL CONTROL STUFF

;SEQ166

;DATA TABLES FOR EMCL4.  CHANGES FROM NOMINAL ARE NOTED IN COMMENTS:

MCL4D:  .BYTE   0       ;0
        .BYTE   0       ;1
        .BYTE   0       ;2
        .BYTE   2       ;3
        .BYTE   0       ;4
        .BYTE   10      ;5: EXPECT "APR READ COMP"
        .BYTE   60      ;6
        .BYTE   44      ;7

        .BYTE   0       ;10
        .BYTE   0       ;11
        .BYTE   4       ;12
        .BYTE   107     ;13
        .BYTE   0       ;14
        .BYTE   0       ;15
        .BYTE   74      ;16B
        .BYTE   112     ;17: EXPECT "-CON MEM CYCLE"

        .BYTE   101     ;20
        .BYTE   45      ;21
        .BYTE   1       ;22: "-CON VMA SEL 2"
        .BYTE   11      ;23: "-CON VMA SEL 1"
        .BYTE   0       ;24
        .BYTE   0       ;25
        .BYTE   43      ;26B
        .BYTE   0       ;27B

        .BYTE   1       ;30:  "-MCL LOAD VMA CONTEXT"
        .BYTE   45      ;31: "MCL LOAD AR" & "MCL VMAX SEL 2"
        .BYTE   4       ;32: "-MCL VMA PREVIUS" & "MCL VMAX SEL 1"
        .BYTE   47      ;33B: "MCL MBOX CYC REQ"
                                ;& "-MCL VMA EXTENDED" (FROM AD/VMA)
        .BYTE   130     ;34
        .BYTE   130     ;35
        .BYTE   0       ;36
        .BYTE   100     ;37

        .BYTE   120     ;40
        .BYTE   60      ;41B
        .BYTE   0       ;42
        .BYTE   270     ;43B


;SEQ167

;INITIALIZATION FOR TEST ECON4 (SPECIAL CONTROL LOGIC TABLE):

ICON4:  JSR     PC,ICTL1                ;DO THE USUAL..
        MOVB    #367,CTLMSK             ;THEN INITIALIZE THE FIRST BYT EIN THE
        MOVB    #133,CTLFUN             ;CONTROL LOGI TABLES TO READ
        MOVB    #51,CTLBYT              ;"NICOND 10" ON SCD BOARD
        CLRB    CTLDAT          ;EXPECT "NICOND 10" FALSE
        RTS     PC              ;THEN DONE

;INITIALIZATION FOR TEST ETSAT1:

ITSAT:  JSR     PC,ICTL1        ;USUAL
        MOVB    #77,CTLMSK      ;THEN INIT THE FIRST BYTE IN THE
        MOVB    #134,CTLFUN     ;CONTORL LOGIC TABLES TO READ
        MOVB    #1,CTLBYT               ;TEST SATISFIED & "-IR JRST 0"
        CLRB    CTLDAT          ;EXPECT BOTH SIGNALS TO BE 0
        RTS     PC              ;DONE

 

;INITIALIZATION FOR FLAG LOGIC:

;SET ALL THE FLAGS TO TEST RESET:

IFLAG0:JSR      PC,IBUF0        ;START CLEAN
        COM     $NOCHK          ;NO CHECKING
        $SETWD          ;ONES TO THE BUFFER
        STUFF                   ;BUFFER TO THE AR
        $DISP   24              ;"SPEC/FLAG CTL" TO THE BUFFER
        $NUM    20              ;MAGIC # FOR "LOAD FLAGS"
        $XBUF                   ;EXECUTE & FALL INTO TABLE SET UP

IFLAG1: $ITAB   BLAM, FLGD1, 10 ;LOAD NOMINAL EXPECTED DATA
        JMP     IBUF0            ;ZERO BUFFERS, RESET, THEN OUT.

FLGD1:  .BYTE   0               ;INDEX 0
        .BYTE   20              ;1:  "-AD CRY 01"
        .BYTE   30              ;2:  "-AD OVERFLOW 00" & "-AD CRY -02"
        .BYTE   0               ;3
        .BYTE   260             ;4: "-USER","-PI CYCLE"&"-USER EN"
        .BYTE   240             ;5:  "-PUBLIC EN"&"KERNEL MODE"
        .BYTE   210             ;6:  "KERNEL OR UIOT"&"-USER IOT EN"
        .BYTE   4               ;7:  "-TRAP CLR"


;SEQ169

;INITIALIZATION FOR 10-BIT ARITHMETIC (SCAD0 LOGIC TESTS:

;FIRST SET ALL REGS TO 1'S:

ISCD0:  JSR     PC,IBUF0        ;CLEAR BUFFERS
        COM     $NOCHK          ;NO CHECKING

        $SCAD   6,3,3           ;SET SCAD/OR, SCADA/#, SCADB/#
        $SC     1               ;AND SC/SCAD
        $FE     1               ;AND FE/SCAD
        $NUM    777             ;SOME 1'S TO LOAD
        $XBUF                   ;DO IT & FALL INTO TABLE SET UP


ISCD1:  $ITAB    SCDDAT, SCAD1, 12               ;SET UP EXPECTED DATA
        JMP     IBUF0           ;GO CLEAR THINGS.

SCAD1:  .WORD   0,0,0,0,0       ;DATA IS ALL 0'S



;SEQ168

ISCD2:  JSR     PC,ISCD1        ;FIRST DO USUAL THING
        INCB    SCDDAT+7        ;SET "SC.GE.36" EXPECTED TRUE
        JMP     IBUF0           ;LEAVE WITH BUFFERS CLEAN

ISCD3:  JSR     PC,ISCD2        ;AGAIN DO THE USUAL
        INCB    SCDDAT+11       ;BUT EXPECT "-SCAD=0" FALSE
        JMP     IBUF0   ;LEAVE BY USUAL DOOR


;SEQ169


;INITIALIZATION FOR PI LOGIC:

;INITIALIZATION FOR PI TEST 1

IPIZZ1: BISB    #BIT7,PIZFUN+4  
        BICB    #BIT7,PIZFUN+10 ;INIT AFTER PI5 NEEDS THIS CLEANUP
        BICB    #BIT7,PIZFUN+6  ;INIT FOR PI 4 NEEDS CLEANS THIS UP
PIDCOM: JSR     PC,IBUF0                ;CLEAR PDP11 CORE BUFFERS
        MOV     #MPI2.1,R0      ;A MICRO START ADDRESS
        JSR     PC,RUN.GO

        $ARLO2  MONT08          ;DATA TO CAUSE A GEN CYUCLE OF PI BOAD
        DFXCTT                  ;START THE EBOX CLOCK
        STRCLK                  
        DFXCTT                  ;AND STOP IT,, PI SYSTEM SHOULD HAV ECYCLED
        STPCLK                  ;ENOUGH TO CLEAR ITSELF
        MOV     #PIZEXP,R0      ;GET TABLE ADDRESS
        MOV     R0,DCOMPX       ;SET UP DCOMP SO MCOMP KNOWS WHAT TO DO
        MOV     #13,R1          ;DO 11 TABLE LOCATIONS
1$:     CLRB    (R0)+           ;CLEAR A BYTE
        DEC     R1              ;DOWN COUNT
        BGT     1$              ;CONTINUE
        MOVB    #200,PIZMSK+3   ;RESET SEL PHY # EXPECTED MASK
        MOVB    #300,PIZMSK+4   ;RESET TIMER DONE MASK TO DEFAULT CASE
        MOVB    #371,PIZMSK+5;RESTORE MASKS
        MOVB    #367,PIZMSK+6   ;FOR THE SCAD PI4,PI2,PI1
        MOVB    #20,PIZEXP+4    ;EXPECT "STATE HOLD" ALWAYS TRUE
        RTS     PC              ;DONE

;INITIALIZATION FOR PI TEST 3..MAKES DCOMP TBLE 7 ENTRIES LONG
;INSTEAD OF THE 5 ENTRIES USED IN TESTS 1,2, & 4
IPIZZ3: BISB    #BIT7,PIZFUN+6  ;DO 7 DCOMP FUNCTIONS
        BICB    #BIT7,PIZFUN+4  ;UNDO OLD DCOMP COUNT OF 5 BYTE COMPZRRES
        JMP     PIDCOM          ;'CLEAR COMMON PI CORE

;INITIALIZATION FOR PI TEST 5 MAKES DCOMP TABLE 8 ENTRIES LONG
;WHICH MEANS DCOMP FOR PI WILL LOOOK AT "PI CP GRANT" & "PI XFER"
;VIA THE "CON COND ADR 10" MUX ON THE CON BOARD
IPIZZ5: BISB    #BIT7,PIZFUN+10 ;ENABLE LOOKINGAT "CON COND ADR10"
        BICB    #BIT7,PIZFUN+4  ;DISABLE OLD END OF DCOMP MARK
        JMP     PIDCOM          ;CLEAR COMMON CORE

IPIZZ7: BISB    #BIT7,PIZFUN+7  ;DCOMP NOW GOES TO INDEX 7
        BICB    #BIT7,PIZFUN+4  ;CLEAR PREVIOUS DCOMP INDEX
        JMP     PIDCOM          ;AND ON TO COMMON INIT


IPIZZ8:  BISB    #BIT7,PIZFUN+12 ;DCOMP GOES TO INDEX 12
        BICB    #BIT7,PIZFUN+7  ;CLEAR PREVIOUS DCOMP INDEX
        JMP     PIDCOM          ;TO COMMON INIT


;SEQ170

;INITIALIZATION FOR CONTROL RAM LOGIC:

;INITIALIZATION FOR TEST ECRA06..
;MUST SET UP DRAM LOCATION USED IN THE TEST
ICRA6:  MOV     #760/4,R5       ;BEGIN BY WRITING D-RAM DATA
        JSR     PC,DRLDR        ;TO A D-RAM LOCATION WHICH
        MOV     #IND05,R4       ;WAS UNUSED BY THE EDP ADDER
        JSR     PC,GLOWRM       ;TEST.R5 HAS DESIRED ADDRESS
        CLR     R5              ;DIVIDED BY 2.SUBTEST WILL USE
                                ;D-RAM ADDRESS 760/2
        JMP     EDPCOM          ;FINALLY, INITIALIZE THE DATA PATHS


;SEQ171

;INITIALIZATION FOR PARITY TEST:

PARCOM: JSR     PC,IBUF0                ;CLEAR PDP11 COMMON BUFFERS
        MOVB    #356,PARMSK+2   ;RESTORE A MASK
        MOV     #PARINI,R0      ;ADDRESS OF DEFAULT PARCHK EXPECTED DATA
        MOV     #PAREXP,R1      ;GET ADDRESS OF EXPECTE TABLE
        MOV     R1,DCOMPX       ;SET UP FOR MCOMP
        MOV     #13,R2          ;THIS MANY ITEMS
        
1$:     MOVB    (R0)+,(R1)+     ;PLACE THE DATA
        DEC     R2              ;DOWN COUNT
        BGT     1$              ;BACK TILL DONE
        JMP     DPATHC          ;AND INIT DATA PATH REGS.

PARINI: .BYTE   0,2,1           ;INITIAL STATE OF PARITY EXPECTED
        .BYTE   0,0,40
        .BYTE   4,2,0
        .BYTE   0,100
        .EVEN



;SEQ172

.SBTTL SUBROUTINES USED TO DO VARIOUS INITIALIZATION TASKS

;SUBROUTINE TO CLEAR BUFFERS AND DO A RESET:

IBUF0:  $CLRMI                  ;CLEAR MICROWORD BUFFER
        $CLRMI  EWORD1          ;CLEAR BOTH 36-BIT BUFFERS
        MOV     #BIT15,$$CRAD   ;SET "NO RESET" ON $MWORD FLAG
        CLR     TATTLE          ;NO LEFT OVER MCOMPS
        CLEAR                   ;CLEAR MACVHINE 7 SET MBOX DIABLE
        CLR     $NOCHK          ;CLEAR "NO CHECK" INITIALIZATION FLAG
        RTS     PC              ;RETURN

;SUBROUTINE TO CLEAR ALL OF THE CRAM:

ZCRAM:  CLR     R0              ;STARTING WITH LOCATION 0,
        MOV     #RAMTOP+1,R1    ;CLEAR ALL LOCATIONS
        MICNUL                  ;OF THE CRAM.
        RTS     PC              ;AND RETURN.

;SUBROUTINE TO CLEAR THE DRAM, DRAM LATCHES, AND IR:

ZDRAM:  MOV     #ZERO,R1                ;USE ZERO DATA,
        MOV     #776,R2         ;AND STARTING AT THE HIGHEST EVEN ADR,
1$:     MOV     R2,R0           ;CLEAR EACH PAIR OF DRAM LOCATIONS
        WDRAM
        DEC     R2              ;THEN DECREMENT THE ADDRESS TO
        DEC     R2              ;THE NEXT LOWER EVEN ADDRESS
        BGE     1$              ;AND CONTINUE CLEARING UNTIL ALL HAVE BEEN DONE

        DFXCTT                  ;TNE STROBE THE 0'S TO THE
        DRLTCH          ;DRAM LATCHES
        RTS     PC              ;AND RETURN


;SEQ174


;SUBROUTINE TO ATTEMPT TO CLEAR CRAM LOC 0:

ZCRAM0: CLR     R0              ;CRAM LOCATION 0
        CLR     R1              ;ONE WORD
        MICNUL                  ;EMT TO DO IT
        RTS     PC              ;RETURN

;SUBROUTINE TO ATTEMPT TO CLEAR THE IR AND DRAM LOC 0:

ZDRAM0: MOV     #ZERO,R1
        CLR     R0
        WDRAM

        DFXCTT
        DRLTCH

        RTS     PC      ;RETURN


;SEQ175

;SUBROUTINE TO CLEAR VMA CONTEXT FLOPS ON MCL BOARD:

ZMCL:   MOV     #BIT15,$$CRAD   ;SET UP MICROWORD ADR + NO RESETS
        $COND   37              ;BRING UP "COND/LOAD VMA HELD"
        $XBUF                   ;LOAD CR FROM $MICRO & CLOCK
        RTS     PC              ;RETURN

;SUBROUTINE TO CLEAR STATE REG ON CON BOARD:

ZSR:    $COND   16              ;WRITE 'COND/SR_#" TO BUFFER
        $MWORD                  ;KADUNK!
        $COND   0               ;LEAVE BUFFER CLEAR
        $MWORD                  ;ONE MORECRACK
        RTS     PC              ;RETURN


;SEQ176

;SUBROUTINE TO LOAD UP DCOMP TABLES:
;R1 POINTS TO START OF TABLE TO BE LOADED
;R2 POINTS TO START OF DTA TO LOAD
;R3 IS THE NUMBER OF ENTRIED TO DO

;THERE IS A MACRO TO CALL THIS ROUTINE:
;       $ITAB   TABLE, DATA, ITEMS

ITAB:   SHOVE           ;SAVE REGISTERS
1$:     MOVB    (R2)+,(R1)+     ;LOAD A BYTE
        DEC     R3              ;COUNT
        BGT     1$              ;LOOP TILL DONE
        GRAB                    ;RESTORE REGISTERS
        RTS     PC              ;AND RETURN




;SEQ178

.SBTTL SUBROUTINE TO INITIALIZE THE APR FM EXTENDED AND APR FM 36 RAMS:

;THIS CODE WRITE A ZERO IN EACH OF 128 DECIMAL LOCATIONS IN BOTH THE
;APR FM EXTENDED RAM (1X128) AND THE APR FM 36 RAM (1X128).

IAPR6:
ZFMEX:  MOV     #EWORD1+3,R1    ;PTR TO BYTE WITH EBUS 4-11 IN BUFFER
        CLR     R3
        CLRB    CK777           ;CLEAR BLOCK # COUNTER
        CLRB    FMEX00          ;CLEAR WORD COUNTER
        CLRB    FMEX22          ;CONSTANT OF 0
        CLR     FMEX11          ;PASS COUNTER CLEAR TOO

HAYY:   ADD     #1,FMEX11       ;INCREMENT PASS COUNT
        CLEAR                   ;START FRESH
        CLRB    (R1)            ;CLER BITS 4-11 IN BUFFER
        MOVB    CK777,(R1)      ;SET UP EBUS 6-8
        ASLB    (R1)
        ASLB    (R1)
 
        ASLB    (R1)             ;LEFT ALLIGN BLOCK #
        STUFF                   ;LOAD AR FROM BUFFER
        $COND   20              ;SET COND DIAG
        $NUM    25              ;"LOAD AC BLOCK"
        $XBUF0                  ;EXECUTE TO SET AC BLOCKS

;       GET # VALUE FROM TABLE
        MOVB    R3,R0           ;GET NEXT # VALUE
        $NUM                    ;WRITE IT IN THE BUFFER
        INCB    R3              ;UPDATE INDE
        MOV     #7,R0           ;FM ADR TO SEL #'S OIMTO MIXER
                                ;WRITE IT IN BUFFERM
        $FM                     ;WRITE IT IN BUFFER
        CLRB    EWORD1+4                ;CLR BITS 0-3
        MOVB    FMEX22,EWORD1   ;LOAD BITS 28-35
        MOVB    FMEX22,EWORD1+1 ;LOAD BITS 20-27
        MOVB    FMEX22,EWORD1+2 ;LOAD BITS 12-19
        MOVB    FMEX22,EWORD1+3 ;LOAD BITS 4-11
        STUFF                   ;ACTUALLY LOAD AR NOW
        $COND   10              ;WRITE THE "FM WRITE FIELD"
        $XBUF                   ;NOW LOAD THE CR
        INCB    FMEX00          ;UPDATE FM WORD ADDRESS
        CMPB    #17,FMEX00      ;COMPARE


;SEQ179

        BGE     UNB11           ;DO ANOTHER WORD IN CURRENT BBLOCK
                                ;IF BRANCH IS TRUE.
        CLRB    FMEX00
        CLRB    R3
UNB11:  MOV     FMEX11,R0       ;PASS COUNT
        BIC     #177740,R0      ;MAKE MODUL0 32
        CMP     #0,R0           ;LOOK FOR 0 WHICH IS REALLY 32.
        BLT     HAYY            ;DONE INCREMENT BLOCK #
        BR      UNB33           ;NOW INCREMENT BLOCK #
UNB33:  INCB    CK777           ;ADD 1 TO BLOCK #
        CLRB    FMEX22  
        CMP     #10,CK777       ;HERE TO SEE IF WE HAVE DONE
                                ;128 WORDS.
        BGT     HAYY            ;LOOP IF NOT DONE ALL 128 WORDS
        RTS     PC              ;DONE!!

CK777:  .BYTE   0
FMEX00: .BYTE   0
FMEX11: .WORD   0
FMEX22: .BYTE   0

        .EVEN




;SEQ178

.SBTTL  *EDP*   36-BIT DATA PATH TESTS

.SBTTL  TEST 1 (EEDP01): DATA PATHS BASIC MUX SELECT TEST
.REM    %
         IT IS THE PURPOSE OF THIS TEST TO VERIFY THAT ALL MIXERS
ON THE DATA PATH BOARD CAN INDEPENDENTLY SELECT ANY OF
THEIR INDIVIDUAL INPUTS, THAT NO MUX SELECT LINES ARE
STUCK EITHER HIHG OR LOW, AND THAT NONE OF THE MIXER OUTPUT
LINES ARE STUCK LOW.  THIS TEST ALSO VERIFYS THAT EACH 
REGISTER CAN HOLD ALL ONES AND ALL ZEROES.
THE TEST BEGINS BY RESETING THE EBOX AND THEN USES
THE MQ AS A SOURCE OF ONES (MQ RESET STATE=1S) AND
PASSES THESE ONES FROM ONE REGISTER TO ANOTHER.  REGISTERS
ARE CLEARED OF THEIR ONES TO ENSURE THAT IF A SELECT LINE FAILS,
THE CORRECT REGISTER WILL CONTAIN THE WRONG THING.
THE TEST BEGINS AT MICRO INSTRUCTION 1, BURSTS 1 ECLOCK &
TESTS THE REGISTERS.  SUBTEST TWO, BEGIN AT MICRO INSTRUCTION 1,
BURST 2 ECLOCKS, CHECK.  BEGIN AT 1, BURST 3, AND SO ON, UNTIL
WE HAVE EXECTURED THE COMPLETE SET OF TRANSFERS AT BURST
MODE
%
EEDP01: PMSG<STARTING DATA PATH TESTS\>


;SEQ179

        MOV     #ALA3,R4                ;GET POINT TO EXPECTE DATA

ALA1:   INSYNC                  ;NEXT SUBTEST
        MOV     #MIC1EDP,R0     ;BEGINNING C-RAM ADDRESS FOR
        WWADR                   ;THIS TEST,PLUS A RESET
        MOV     R5,R0           ;MOV #MBOX TKS TO BURST
        ASL     R0              ;MULTIPLY SUBTEST BY TWO = BURST COUNT
        BURST                   ;GIVE CORRECT NUMBER EBOX TOCS
        JSR     PC,EDPTST       ;GO TEST DATA PATH
        BCS     ALA2            ;BR IF ERRORS
        CMP     R5,#^D44                ;DONE ALL??
        BLT     ALA1            ;BR BACK IF NOT DONE
        JMP     NORMAL          ;OTHERWISE, NORMAL DONE
ALA2:   JSR     PC,FAULT
        .WORD   0               ;NO ERROR MESSAGE

;EXPECTED DATA FOR BASIC MUX SELECT TEST

ALA3:
;SUBTEST 1 - RESET TEST
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ONES,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 2 - ADA "10",AR "010", MQ "CLR"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ONES,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 3 - BR LOAD, AR "110"
        EXPECT AR=.ZERO,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 4 - ADB "010", ARX "010", BR LOAD
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SUBTEST 5 - BRX LOAD, ARX "010"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SUBTEST 6 - ADXB "10", ARX "110"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ONES,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SBUTEST 7 - ADA "01" , MQ "AD"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 8 - ARX "011"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;PATN  = 777777,,777776
;PATN1 = 177777,,777777

;PATN2 = 377777,,777776
;PATN3 = 173737,,373737
;PATN4 = 636767,,676767
;PATN5 = 000000,,000001
;PATN6 = 777777,,777774
;PATN7 = 131313,,131313


;SEQ180

;SUBTEST 9 - AR "110" ADXA "EN"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ONES,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ZERO,FM=.ZERO


;SUBTEST 10 - AR "101", ARX "011"       
        EXPECT AR=.ONES,BR=.ZERO,AD=.ONES,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 11 - ADA "00"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO


;SBUTEST 12 - MQ "SH", ADA & ADXA "DISABLE"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 13 - MQ "MQ"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 14 - SETUP FOR SUBTEST 15
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ONES,FM=.ZERO

;SBUTEST 15 - ARX "101"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 16 - ARX "000"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SUBTEST 17 - SETUP FOR SUBTEST 18
        EXPECT AR=.ONES,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 18 - AR "000"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 19 - AR "100"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 20 - SETUP FOR SUBTEST 21
        EXPECT AR=.ZERO,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.PATN,MQ=.ZERO,FM=.ZERO

;SBUTEST 21 - ADB "01"
        EXPECT AR=.ONES,BR=.ZERO,AD=.PATN5,ARX=.ZERO,BRX=.ONES,ADX=.PATN,MQ=.ZERO,FM=.ZERO

;PATN  = 777777,,777776
        
;PATN1 = 177777,,777777

;PATN2 = 377777,,777776
;PATN3 = 173737,,373737
;PATN4 = 636767,,676767
;PATN5 = 000000,,000001
;PATN6 = 777777,,777774
;PATN7 = 131313,,131313


;SEQ181

;SUBTEST 22 - ADXB "01"
        EXPECT AR=.PATN5,BR=.ONES,AD=.ZERO,ARX=.PATN,BRX=.ONES,ADX=.PATN,M1=.ZERO,FM=.ZERO

;SUBTEST 23 - ARX "111"
        EXPECT AR=.PATN5,BR=.ONES,AD=.ZERO,ARX=.PATN1,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 24 - SETUP FOR SUBTEST 25
        EXPECT AR=.ZERO,BR=.ONES,AD=.ONES,ARX=.PATN1,BRX=.ONES,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SUBTEST 25 - AR "111"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 26 - ARX "100"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 27 - MQ "*.25"

        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.PATN1,FM=.ZERO

;SUBTEST 28 - MQ "*2"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.PATN2,FM=.ZERO

;SUBTEST 29 - MQ "*.5"
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ONES,MQ=.PATN3,FM=.ZERO

;SUBTEST 30 - MQ "*.25"
        EXPECT AR=.ONES,BR=.ZERO,AD=.ONES,ARX=.ONES,BRX=.ZERO,ADX=.PATN6,MQ=.PATN4,FM=.ZERO

;SBUTEST 31 - ADXB "11" WITH ONES
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ONES,BRX=.ZERO,ADX=.ZERO,MQ=.PATN4,FM=.ZERO

;SUBTEST 32 - ADXB "01" WITH ZEROES
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SBUTEST 33 - ADXB "11" WITH ZEROS
        EXPECT AR=.ZERO,BR=.ZERO,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 34 - "AD TO EBUS" WITH ONES
        EXPECT AR=.ONES,BR=.ZERO,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO


;PATN  = 777777,,777776
;PATN1 = 177777,,777777
;PATN2 = 377777,,777776
;PATN3 = 173737,,373737
;PATN4 = 636767,,676767
;PATN5 = 000000,,000001
;PATN6 = 777777,,777774
;PATN7 = 131313,,131313


;SEQ182

;SUBTEST 35 - "AR MUX ENABLE"
        EXPECT AR=.ZERO,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ONES,MQ=.ZERO,FM=.ZERO

;SUBTEST 36 - "DISP/DIV" MQ SH LEFT 2ND TIME
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 37 - "MQ*.5"
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO


;SUBTEST 38 - "MQ*.5" 2ND TIME IN A ROW
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ZERO,FM=.ZERO

;SUBTEST 39 - "MQ LOADED FROM AD"
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 40 - "MQ*.5" SET-UP FOR SUBTEST 41
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=NOCARE,FM=.ZERO

;SUBTEST 41 - "MQ*.5" MQ SH LINE S@0
        EXPECT AR=.ONES,BR=.ONES,AD=.ONES,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.PATN7,FM=.ZERO


;SUBTEST 42 - MQ LOADED FORM AD - SET-UP FOR SUBTEST 44
        EXPECT AR=.ONES,BR=.ONES,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.ONES,FM=.ZERO

;SUBTEST 43 - MQ SH LEFT - SET-UP FOR SUBTEST 44
        EXPECT AR=.ONES,BR=.ONES,AD=.ZERO,ARX=.ZERO,BRX=.ONES,ADX=.ZERO,MQ=.PATN,FM=.ZERO

;SUBTEST 44 - MQ SH LEFT "SHIFT IN BIT" STUCK
        EXPECT AR=.ONES,BR=.ONES,AD=NOCARE,ARX=.ZERO,BRX=.ONES,ADX=NOCARE,MQ=.PATN6,FM=.ZERO

;PATN = 777777,,777776
;PATN1 = 177777,,777777
;PATN2 = 377777,,777776
;PATN3 = 173737,,373737
;PATN4 = 636767,,676767
;PATN5 = 000000,,000001
;PATN6 = 777777,,777774
;PATN7 = 131313,,131313



;SEQ183

.SBTTL  TEST 2 (EEDP02): DATA PATHS BASIC INTERFERENCE TEST

.REM    %
IT IS THE PURPOSE OF THIS TEST TO BERIFY THAT THE
OUTPUT OF ALL MIXERS AND REGISTERS ON THE DATA
BOARD HAVE INDEPENDENT LINES, I.E., THAT THE AR HAS 36
INDPENDENT LINES, THAT THE ADA HAS 36 INDEPENDENT LINES
AND SO ON, FOR ALL REGISTERS AN MIXERS.  THE TEST
RUNS IN BURST MODE AND FIRST LOADS THE AR WITH 
INTERFERENCE DATA.  NEXT, A BURST OF EBOX CLOCKS
IS GIVEN AND OUR INTEREFERENCE IS SENT 
ON THE FOLLOWING JOURNEY.
        FROM THE AR TO BR
        BR THRU ADB THRU AD TO ARX
ARX TO BRX
        BRX THRU ADXB THRU ADX TO AR
        AR THRU ADA THRU AD TO MQ
        MQ TO ARX
        ARX THRU ADXA THRU ADX TO AR
        DONE
%
EEDP02: MOV     #DEDP02,R4      ;GET ADDRESS OF EXPECTED DATA
        MOV     #PATN,R0        ;ADDRESS FOR INTERFERENCE PATTERN
        P36                     ;GET FIRST PATTERN

1$:     INSYNC                  ;SUBTEST 1-12 (12 INTERFERENCE PATTERNS)
        MOV     #MIC2EDP,R0     ;INITIAL RAM ADDRESS PLUS RESET
        WWADR           ;DO IT
        ECLOK                           ;INITIAL RAM WORD TO C.R.
        MOV     #PATN,R0                ;PTR TO 36 BIT DATA FOR AR LOAD
        ARLOD2                  ;LOLAD AR WITH CONTENTS
        EBURST  7               ;CLOCK THE EBOX 7 TIMES
        JSR     PC,EDPTST               ;TEST RESULT
BCS     2$
        SUB     #10,R4          ;RESET EXPECTED DATA POINTER

;SEQ184

;NEXT INTERFERENCE PATTERN IF MAKE IT TO HERE
        PATCON          ;GET NEXT NPATTERN
        TST     R0              ;DONE YET?
        BNE     1$              ;CONTINUE LOOP IN NOT
        JMP     NORMAL          ;DONE OTHERWISE
2$:     JSR     PC,FAULT                ;ERROR RETURN
        .WORD   0               ;NO ERROR MESSAGE
;EXPECTED DATA
DEDP02:
        EXPECT AR=.PATN,BR=.ZERO,AD=.PATN,ARX=.ZERO,BRX=.ZERO,ADX=.ZERO,MQ=.ZERO,FM=.ZERO


;SEQ185

.SBTTL TEST 3 (ESCD1):  SC REGISTER (SC FROM AR AND SC RECIRCULATION)

.REM    %
THIS TEST VERIFIES THAT EACH BIT OF THE SC REGISTER CAN STORE A "A" AND A "0"
AD THAT ALL BITS EXCEPT SC00 & SC01 ARE INDEPENDENT.  IT ALSO VERIFIES
THE PATH FEROM AR BITS 18 AND 28 TO 35 TO THE SC VIA THE SCM AND THE
RECIRCULATION PATH OF SC TO SC THROUGH THE SCM.  IT USES THE STANDARD
TEST PATTERNS OF SUBROUTINE PATTY AND BURSTED MICROCODE.  IT PROCEEDS THE RTEST
OF THE SC TESTS BECAUSE THE SC REGISTER MUST WORK FOR THE REMAINING DATA
PATH TESTS TO WORK.
REFER TO THE E-BOX DIAGNOSTIC MICROCODE LISTING AT CRAM LOCATION:
        START   =       SCM00
FOR DETAILS OF EACH MICROWORD.
%
;INITIALIZE SOME POINTERS:

ESCD1:  MOV     #EWORD1,R1      ;R1 PTS TO 36-BIT BUFFER.
        MOV     #SCDDAT+4,R4    ;R4 PTS TO AR'S EXPECTED DATA.
;START OF MAIN LOOP.  THERE ARE TWO SUBTESTS PER TEST PATTERN.  THE FIRST (ODD NUMBERD)
;SUBTEST CHECKS AR TO SC LOAD AND THE SECOND TESTS RECIRCULATION:

        MOV     R1,R0           ;GET FIRST TEST PATTERN TO THE BUFFER
        P36                     ;TRAP TO PATTERN GENERATION ROUTINE
        BR      DEUCE           ;AND BEGIN

ACE:    PATCON          ;GET NEXT PATTERN TO BUFFER (ODD SUBTESTS)
        BNE     DEUCE           ;THE SUBROUTINE RETURNS R0=0 WHEN DONE

        JMP     NORMAL          ;OTHERWISE, HIT THE SILK.

DEUCE:  INSYNC          ;NEW SUBTEST, 24 IN ALL.

;ALTER THE SC AND THE AR EXPECTED DATA TO MATCH THE TEST PATTERN IN EWORD1:

        AR2SC                   ;MODIFY THE SC'S EXPECTED DATA
        MOVB    EWORD1+3,(R4)+  ;PUT PAT BITS 4-11 IN AR 5-9 BYTE.
        MOVB    EWORD1+4,(R4)+  ;AND PAT BITS 0-3 IN AR 0-4 BYTE:

        ASL     -(R4)           ;SHIFT EXPECTED TO LINE BITS UP.
        COM     (R4)            ;AND COMPLIMENT.


;SEQ186

;SET MICROWORD ADDRESS TO SCD00 AND DO A MRESET:

        MOV     #SCM00,R0       ;ADDRESS
        WWADR                   ;EMT TO DO THE JLB.

        ECLOK                   ;LOAD THE CR BEFORE LOADING AR
        STUFF           ;LOAD THE AR FROM THE BUFFER.
;GIVE A SINGLE EBOX CLOCK IF ODD # SUBTEST, 2 IF EVEN AND THEN COMPARE:

        BIT     #1,SUBNR                ;SEE IF ODD SUBTST.
        BNE     CLUBS           ;BRANCH IF IT IS.

;HERE FOR EVEN SUBTESTS:
        EBURST  2               ;GIVE 2 EBOX CLOCKS.
        INCB    SCDDAT+11               ;EXPECT "-SCAD=0" FALSE
        SCDCMP                  ;COMPARE
        BR      ACE             ;AND GET NEXT PATTERN
;HERE FOR ODD SUBTESTS:

CLUBS:  EBURST  1               ;GIVE 1 EBOX CLOCK.
        CLRB    SCDDAT+11      ;EXPECT "-SCAD=0" TRUE
        SCDCMP                  ;COMPARE
        BR      DEUCE           ;AND TRY RRECIRCULATION TEST


;SEQ187

.SBTTL  TEST 4 (EEDP03):        SHIFTER BOARD TEST -- BURST SPEED

.REM    %
IT IS THE PURPOSE OF THIS TEST TO RUN 85 PATTERNS THRU THE
SHIFTER BOARD AND VERIFY THAT THE BOARD HAS NO ERRORS.  IT
RUNS AT BURST SPEED.
AT SINGLE STEP SPEED THE BR & BRX RESPECTIVELY, ARE LOADED
WITH TEST PATTERNS DESTINED FOR THE AR & ARX.  NEXT, AN
SC COUNT IS LOADED INTO THE AR.  THE BURST IS STARTED
AND THE MICRO-CODE DOES THE FOLLOWING: 1) AR (SC COUNT)
TO SC. 2) BR TO AR, AND BRX TO ARX.  3) SH (SHIGFT BOARD) TO
THE AR, ARX AND MQ.  THE MQ, AR AND ARX ARE VERIFIED TO
HAVE THE CORRECT DATA.
EXPECT ALL FAILURES IN THIS TEST TO BE ON EITHER
SHIFTER BOARD (M8510) OR BACKPLANE FROM AR OR ARX
TO SHIFTER BOARD
%
EEDP03: MOV     #SC.LST,SC.PNT  ;RESET LIST OF SC VALUES
        MOV     #MINN9,R4       ;SET POINTER TO EXPECTED
        MOV     #MINN10,R3      ;SET POINTER TO TEST DATA
        MOV     #MIC3EDP,R0     ;STARTING C-RAM ADDRESS
        WWADR                   ;WRITE ADDRESS AND RESET KL10
        ECLOK                   ;INITIAL RAM WORD TO C.R.
MINN1:  INSYNC                  ;COUNT THIS TEST NUMBER
        BITB    4(R3),#NEW.SC*20        ;NEW SHIFT COUNT??
        BEQ     1$              ;BR IF NO
        ADD     #1,SC.PNT       ;UPDATE POINT IF YES
1$:     MOV     R3,100$         ;GET AR TEST PATTERN FOR 36-BIT MOVE
        MOVWRD
100$:   .WORD   0               ;MOVE AR TEST DATA
        .WORD   PATN1           ;TO BUFFER "PATN1"
;NOW TEST A STATUS BIT & SEE IF ARX DATA IS IDENTICAL
        BITB    4(R3),#ARXST*20
        BNE     MINN2           ;BR IF ARX DATA SAME AS AR DATA
        ADD     #5,R3           ;OTHERWISE, INC TO NEXT 36 BIT DATA WORD
MINN2:  MOV     R3,100$         ;GET ARX TEST DATA FOR 36 BIT MWMOVE
        MOVWRD
100$:   .WORD   0               ;MOVE ARX TEST DATA
        .WORD   PATN            ;TO BUFFER "P[ATN"
        ADD     #5,R3           ;ADVANCE TO NEXT 36 BIT DATA

;SEQ188

;NEXT TASK IS TO GET A SHIFT COUNT VALUE

MINN3:  MOVB    @SC.PNT,R0              ;GET SC VALUE
        INC     R0              ;WAS IT NEG ONE
        BEQ     MINN4           ;END OF LIST IF YES     MOVB    @SC.PNT,SC.VAL  ;SET UP SC IF NOT END
        MOVB    @SC.PNT,SC.VAL
;NOW LOAD ALL OUR DATA INTO THE EBOX
MINN4:  $CLRWD
        MOV     SC.VAL,R0       ;RESET R0 TO CURRENT SC COUNT
        SUB     #^D36,R0        ;IS SC .GT. 36??
        BGT     6$              ;BR IF YES, PRESET SC .EQ.0
        MOVB    #177,EWORD1     ;OR IF SC .LE. 36,PRESET TO 177
6$:     $ARLO2  EWORD1          ;DATA ACROSS EBUS
        ECLOK                   ;DATA TO SC, PRESETTING IT
        $ARLO2  PATN
        ECLOK                   ;SET UP DATA JUST LOADED
        $ARLO2  PATN1
        MOV     SC.VAL,EWORD1           ;SC VALUE TO 36 BIT BUFFER
        ECLOK                   ;SET UP DATA JUST LOADED
        $ARLO2  EWORD1


;SEQ189

;DATA IS NOW IN THE EBOX
        EBURST  2               ;EXECUTE THE TEST


;SEQ190

;NOW BETTER CREATE THE EXPECTED DATA IN CORE BEFORE COMPARING EBOX

        TSTB    SC.VAL          ;WAS SHIFT COUNT ZERO
        BEQ     MINN5           ;READY TO COMPARE EBOX IF YES

;NEED TO CREATE EXPECTED IN CORE IF HERE
;CLOSE 7-BIT HOLE IN BYTE 0-3 OF WD36
        MOV     #4,R1           ;FOUR ROTATES PER BYTE
1$:     MOV     #5,R0           ;FIVE BYTES PER WD36
        MOV     #PATN,R2        ;THIS BUFFER TO ROTATE
2$:     ROLB    (R2)+           ;ROTATE LEFT 36 BITS
        DEC     R0
        BGT     2$
        DEC     R1              ;ROTATE 4 BITS WORTH
        BGT     1$

;       THIS CODE CAN E SPEEDE UP FOR SC .GT. 36 CASES
;72 BITS IN CORE ARE COUNTINUOUS, NOW SHIFT THEM SHIFT COUNT NUMBER
;OF TIMES TO CREAE EXPECTED DATA
        MOV     SC.VAL,R1
5$:     CMP     R1,#^D36        ;ALL SHIFTS MODULO 72
        BLT     3$              ;BR IF NO NEED TO ADJUST SHIFT COUNT
        MOV     #^D36,R1        ;OTHERWISE, SHIFT 36 TO GIVE ARX
3$:     MOV     #^D10,R0        ;10 SHIFTS PER 72 BITS
        MOV     #PATN,R2        ;LOCATION OF 72 BITS
4$:     ROLB    (R2)+
        DEC     R0
        BGT     4$
        DEC     R1              ;SHIFT SC NUMBER OF TIMES
        BGT     3$

;SEQ191

;GO CHECK DATA IN THE EBOX
MINN5:  JSR     PC,EDPTST
        BCS     MINN6           ;BR IF ERROR DETECTED
;RESET EXPECTED POINTER
        SUB     #10,R4
        CMP     #^D65,R5        ;INTO REPEATIN PATTERN SECTION?
        BGT     1$              ;BR IF NOT
        SUB     #^D10,R3         ;USE OLD PATTERN IF YES
;CHECK FOR END OF LOOP
        CMP     #^D70,R5         ;END OF TEST DATA?
        BLE     MINN7
1$:     MOV     SC.PNT,R0       ;GET SC VALUE POINTER
        MOVB    1(R0),R0        ;GET NEXT SC VALUE IN LIST
        INC     R0              ;WAS IT END OF LIST CODE?
        BNE     MINN1           ;IF NO, CONTINUE BIG LOOP
;IF YES, LAST SC COUNT TO TEST IS SC = 400
        MOV     #400,SC.VAL
        BR      MINN1
;ERROR EXIT
        
MINN6:  JSR     PC,FAULT
        .WORD   0
;SUBTESTS 71073
;SECOND PHASE OF TEST, NEW MICRO-CODE, DIFFERENT FROM BIG LOOP
MINN7:  ADD     #10,R4          ;UPDATE R4 TO NEXT EXPECTED
        MOV     #MIC3.1SH,R0    ;GET C-RAM ADDRESS
        WWADR                   ;ADDRESS TO EBOX PLUS RESET
        ECLOK                   ;FORWARD TO C.R.
MINN8:  INSYNC                  ;NEXT SUBTEST
        MOV     R3,100$         ;GET AR DATA TO CORE BUFFER
        MOVWRD
100$:   .WORD   0
        .WORD   PATN
        ADD     #5,R3           ;INCREMENT TO ARX
        MOV     R3,101$         ;GET ARX DATA TO CORE
        MOVWRD
101$:   .WORD   0
        .WORD   PATN1
        ADD     #5,R3           ;INCREMENT TO EXPECTED
        MOV     R3,102$         ;EXPECTED TO CORE
        MOVWRD
102$:   .WORD   0
        .WORD   PATN2
        ADD     #5,R3           ;INCREMENT TO DATA FOR NEXT TEST


;SEQ192

;LOAD DATA INTO THE EBOX
        ECLOK                   ;SET UP DATA JUST LOADED
        $ARLO2  PATN1           ;ARX DATA TO EBOX
        ECLOK                   ;SET UP DATA JUST LOADED
        $ARLO2  PATN            ;AR DATA TO EBOX
        EBURST  3               ;EXECUTE
        JSR     PC,EDPTST       ;CHECK EBOX
        BCS     MINN6           ;REPORT ERROR IF CARRM SET
        SUB     #10,R4          ;RESET EXPECTED POINTER
        CMP     #MINNYY,R3      ;TEST COMPLETE?
        BGT     MINN8           ;BACK FOR MORE
        JMP     NORMAL          ;ALL DONE

;SEQ193

SC.VAL: .WORD   0               ;CURRENT SC VALUE
SC.PNT: .WORD   SC.LST          ;POINTER TO LIST OF SC VALUES
SC.LST: .BYTE   0               ;SC COUNT = 0,(26 TESTS)
        .BYTE   1               ;SC COUNT = 1,(4 TESTS)
        .BYTE   2               ;SC COUNT = 2,(5 TESTS)
        .BYTE   3               ;SC COUNT = 3,(8 TESTS)
        .BYTE   4               ;SC COUNT = 4,(4 TESTS)
        .BYTE   ^D8             ;SC COUNT = 8,(5 TESTS)
        .BYTE   ^D12            ;SC COUNT = 12,(7 TESTS)
        .BYTE   ^D15            ;SC COUNT = 15, (2 TESTS)
        .BYTE   ^D16            ;SC COUNT = 16,(4 TESTS)
        .BYTE   ^D31            ;SC COUNT = 31,(2 TESTS)
        .BYTE   ^D32            ;SC COUNT = 32,(3 TESTS)
        .BYTE   ^D48            ;SC COUNT = 48,(5 TESTS)
        .BYTE   41              ;(1 TEST)
        .BYTE   36              ;(1 TEST)
        .BYTE   51              ;(1 TEST)
        .BYTE   200             ;(1 TEST)
        .BYTE   44              ;(1 TEST)
        .BYTE   60              ;(1 TEST)
        .BYTE   100             ;(1 TEST)
        .BYTE   377             ;END LIST MARKER
        .EVEN

;SEQ194

MINN9:
;FOR SUBTESTS 1-70      ,THIS IS THE EXPECTED DATA
        EXPECT  AR=.PATN1,BR=NOCARE,AD=NOCARE,ARX=.PATN1,BRX=NOCARE,ADX=NOCARE,MQ=.PATN1,FM=.ZERO

;FOR SUBTESTS 71-73     ,THIS IS EXPECTED
        EXPECT  AR=.PATN2,BR=.PATN,AD=.PATN2,ARX=.PATN2,BRX=.PATN1,ADX=.PATN2,MQ=.PATN2,FM=.ZERO

MINN10:
DEDP03:
        WD36    2104,2104,2104,STAT36=ARXST     ;ST1--SC=00
        WD36    4040,4040,4040,STAT36=ARXST     ;ST2
        WD36    0421,0421,0421,STAT36=ARXST     ;ST3
        WD36    1010,1010,1010,STAT36=ARXST     ;ST4
        WD36    0202,0202,0202,STAT36=ARXST     ;ST5

;SC = 00
        WD36    0360,0017,0000  ;6
        WD36    7400,0360,0017  
        WD36    7400,0000,7400  ;7
        WD36    0000,7400,0000  
        WD36    0000,7400,0360  ;8
        WD36    0017,0000,7400
        WD36    0017,0000,0017  ;9
        WD36    0000,0017,0000
        WD36    0000,0360,0000  ;10
        WD36    0360,0000,0360
        WD36    0000,0017,7760  ;11
        WD36    0000,7400,0017  
        WD36    7400,0360,0000  ;12
        WD36    7610,0000,0000
        WD36    7777,7400,0000  ;13
        WD36    0000,0000,0360
        WD36    0000,7400,0017  ;14
        WD36    0167,0000,0000

;SC=01
        WD36    4210,4210,4210,STAT36=ARXST!NEW.SC      ;ST15
        WD36    3146,3146,3146,STAT36=ARXST     ;16
        WD36    1042,1042,1042,STAT36=ARXST     ;17
        WD36    4631,4631,4631,STAT36=ARXST     ;18

;SC=02

        WD36    1463,1463,1463,STAT36=ARXST!NEW.SC      ;ST19
        WD36    0,0,0,STAT36=ARXST      ;ST20
        WD36    1042,1042,1042,STAT36=ARXST     ;ST21
        WD36    6314,6314,6314,STAT36=ARXST     ;ST22
        WD36    4210,4210,4210,STAT36=ARXST     ;ST23


;SEQ195

;SC=03

        WD36    0,0,0,STAT36=ARXST!NEW.SC        ;ST24
        WD36    0606,0606,0606,STAT36=ARXST     ;ST25
        WD36    0202,0202,0202,STAT36=ARXST     ;26

        WD36    4141,4141,4141,STAT36=ARXST     ;27
        WD36    4040,4040,4040,STAT36=ARXST     ;28
        WD36    3030,3030,3030,STAT36=ARXST     ;29
        WD36    1010,1010,1010,STAT36=ARXST     ;30
        WD36    7777,7777,7777,STAT36=ARXST     ;31

;SC=4
        WD36    7400,0360,0017,STAT36=NEW.SC    ;32
        WD36    0000,7400,0360
        WD36    0377,0017,7400  ;33
        WD36    7760,0377,0017
        WD36    0017,0000,7400  ;34
        WD36    0360,0017,0000
        WD36    7400,7760,0377  ;35
        WD36    0017,7400,7760

;SC=8
        WD36    0017,7400,7760,STAT36=NEW.SC    ;36
        WD36    0377,0017,7400
        WD36    0,0,0,STAT36=ARXST      ;37
        WD36    0017,0000,7400  ;38
        WD36    0360,0017,0000
        WD36    7760,0377,0017  ;39
        WD36    7400,7760,0377
        WD36    7400,0360,0017  ;40
        WD36    0000,7400,0360

;SC=12
        WD36    0,0,0,STAT36=ARXST!NEW.SC       ;41
        WD36    0000,7760,0000  ;42
        WD36    7760,0000,7760
        WD36    0000,0360,0000  ;43
        WD36    0360,0000,0360
        WD36    7400,0017,7400  ;44
        WD36    0017,7400,0017  
        WD36    7400,0000,7400  ;45
        WD36    0000,7400,0000
        WD36    0377,0000,0377  ;46
        WD36    0000,0377,0000
        WD36    0017,0000,0017  ;47
        WD36    0000,0017,0000

;SC=15
        WD36    7777,0777,7777,STAT36=ARXST!NEW.SC      ;48
        WD36    0000,7000,0000,STAT36=ARXST     ;49



;SEQ196

;SC=16
        WD36    0000,0000,0000,STAT36=NEW.SC    ;50
        WD36    0000,6370,4377
        WD36    0000,7400,0003  ;51
        WD36    0000,0077,7760
        WD36    0000,0017,7777  ;52
        WD36    7777,0000,0017
        WD36    7777,7400,0017  ;53
        WD36    7400,7777,7760


;SEQ197

;SC=31
        WD36    0000,0000,0340,STAT36=ARXST!NEW.SC      ;54
        WD36    7777,7777,7437,STAT36=ARXST     ;55

;SC=32
        WD36    0000,0000,0017  ,STAT36=NEW.SC  ;56
        WD36    7777,7777,7417
        WD36    0000,0000,0000  ;57

        WD36    0000,0000,0377
        WD36    0000,7400,0000  ;58
        WD36    7400,7777,7760

;SC=48
        WD36    0,0,0,STAT36=NEW.SC     ;59
        WD36    0000,7400,0360
        WD36    0000,7460,0017  ;60
        WD36    7400,0367,3417
        WD36    0000,0360,0014  ;61
        WD36    7777,6017,7760
        WD36    7777,7417,7760  ;62
        WD36    0000,0000,0017
        WD36    0000,0000,0017  ;63
        WD36    0000,7400,0360

;SC=41,36,51,200,44,60,100
        WD36    0000,0000,0017  ;64;65;66;67;68;69;70
        WD36    0000,7400,0360

;SH/AR
        WD36    0000,0000,0017  ;71
        WD36    0000,7400,0360
        WD36    0000,0000,0017

;SH/ARX
        WD36    0000,0000,0017  ;72
        WD36    0000,7400,0360
        WD36    0000,7400,0360

;SH/AR SWAP
        WD36    0000,0000,0017  ;73
        WD36    0000,7400,0360
        WD36    0000,1700,0000

MINNXX:
MINNYY: ;END OF DATA LIST MARKER
        .EVEN


;SEQ198

.SBTTL  TEST 5 (EEDP04): DATA PATH ADDER ALU & CARRY SKIP NETWORK TEST

.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK AND VERIFY THE CORRECT OPERATION
OF THE KL10 72 BIT ADDER, INCLUDING THE ASSOCIATED CARRY SKIP LOGIC(FOUND
ON THE IR/DRAM BOARD).  THE TESTES ARE DIVIDED INTO 3 GROUPS.  1) TESTS WHERE
ONLY THE ARX & BRX REQUIRE TEST PATTERNS AND ONLY THE ADX IS TESTED.  2)  TESTS
WHERE ONLY THE AR & BR REQUIRE TEST PATTERNS AND ONLY THE AD IS TESTED.
3) TESTS WH THE AR, BR ARX, & BRX ALL REQUIRE TEST PATTERNS AND BOTH
AD & ADX ARE TESTED, INCLUDING CARRYS FROM ADX TO AD.  THERE IS A
SEPARATE MICRO-CODE ROUTINE FOR EACH OF THESE 3 GROUPS.  AFTER THE CORRECT
TEST PATTERNS HAE BEEN LOAED TO THE AR, BR AND/OR ARX, BRX AT SINGLE
STEP SPEED, A BURST MODE CLOCK IS GIVEN TO ACTUALLY DO THE ADD TEST
AT FULL MACHINE SPEED.
%

EEDP04: MOV     #3,ALL4         ;INITIALIZE TEST GROUP
        MOV     #CONN13,R3      ;POINT TO TEST DATA
        MOV     #CONN12-10,R4   ;POINT TO EXPECTED 9BEFORE BEING UPDATED)
        MOV     #CONN10,R2      ;R2 POINTS TO "NO. TESTS PER GROUP"
        MOV     #CONN11-2,R1    ;R1 POINTS TO LIST OF CRAM START ADDRESSES
CONN1:  ADD     #10,R4          ;UPDATE EXPECTED POINTER
        TST     (R1)+           ;UPDATE POINT TO GET NEXT C-RAM ADR
        MOVB    (R2)+,-(SP)     ;SET GROUP LOOP COUNT ON TOP OF STACK
        BEQ     CONN7           ;IF CNT WAS ZERO, ALL DONE


;READY TO BEGIN ACTUAL TEST SETUP & EXECUTION
        DEC     ALL4            ;DOING ALL-4 REGISWTER TEST
        BGT     CONN2           ;IF GREATER THAN ZERO, NOT DOING ALL-4

;FALL TO HERE IF DOING ALL FOUR REGISTER LOAD
        MOV     #-1,ALL4
CONN14: JSR     PC,SETTST               ;INC SUBTEST # AND SET IR FROR DRAM DISPATCH
        MOV     #3,-(SP)        ;THREE PATTERNS TO EBOX
1$:     JSR     PC,CONNMV               ;LOAD DATA ACROSS EBUS TO AR
        ECLOK
        DEC     (SP)            ;DONE 4 YET?
        BGT     1$              ;CONTINUE IF NOT YET

        POP     R0              ;DONE, SO REPAIR STACK
        BR      CONN4           ;AND GO DO FOURTH PATTERN

;SEQ199

;THIS CODE EXECUTED WHEN NOT DOING 4 REGISTERS, WHEN ONLY TWO
;REGISTERS NEED TO BE LOADED
CONN2:  JSR     PC,SETTST               ;INC SUBTEST # & SET IR FOR DRAM DISPATCH
        BITB    #BR.IS0*20,4(R3)   ;TEST BR/BRX=0 STATUS
        BEQ     CONN3                   ;BR IF NOT BR/BRX=0
;HERE BR/BRX MUST EQUAL ZERO
        $ARLO2  ZERO
        ECLOK                   ;SET UP DATA JUST LOADED
        BR      CONN4           ;AND NOW GO LOAD AR/ARX
CONN3:  JSR     PC,CONNMV               ;MOVE BR/BRX DATA TO EBOX
        ECLOK                   ;READY FOR NEXT DATA
CONN4:  JSR     PC,CONNMV               ;MVOR AR/ARX DATA YTO EBOX
CONN5:  EBURST  3               ;BURST SPEED "TEST THE ADDER"
        DFXCTT                  ;FIX CLOCK IF NECESSARY
        CECLK                   ;WITH CONDITIONAL ECLOCK
        MOV     R3,100$
        MOVWRD
100$:   .WORD   0
        .WORD   PATN
        ADD     #5,R3
        TST     ALL4
        BGT     1$
        MOV     R3,101$
        MOVWRD
101$:   .WORD   0
        .WORD   PATN1
        ADD     #5,R3

1$:     JSR     PC,EDPTST               ;GO CHECK RESULTS
        BCC     2$              ;BR IF NO ERRORS
        POP     R0              ;MUST LEAVE STACK CLEAN AS WHISTLE
        JSR     PC,FAULT
        .WORD   0

2$:     MOVB    (R3)+,CONEXP    ;SET EXPECTED VALUE OF "AD CRY -02"
        JSR     R5,$DCOMP               ;CHECK ACTUAL VS. EXPECTED
        .WORD  CONMSK          ;MASK
        .WORD   CONFNC          ;DIAG FCN TO READ "SCD CRY0"
        .WORD   CONBYT          ;WHAT EBUS BIT TO READ
        .WORD   CONEXP          ;EPECTED DATA
        .WORD   0               ;NO MESSAGE


;SEQ200

CONN6:  SUB     #10,R4          ;KEEP PTR TO EXPECTED
        DECB    (SP)            ;DOWN GROUP COUNT
        BLE     1$              ;BR IF DONE THIS GROUP
        TST     ALL4            ;NOT DONE, ALL4 CASE?
        BMI     CONN14          ;BR IF YES
        BR      CONN2           ;BR IF NO
1$:     POP     R0              ;CLEAN STACK
        BR      CONN1           ;CONTINUE
CONN7:  POP     R0              ;FIX STACK
        JMP     NORMAL
;DATA BYTES FOR DCOMP CALL
CONMSK: .BYTE   367     ;CHECK EBUS BIT03 ONLY
CONFNC: .BYTE   131!BIT7
        CONBYT: BYTPNT  6
        
CONEXP: .BYTE   0               ;EXPECTED GOES HERE
        .EVEN



;SEQ201

CONNMV: MOV     R3,100$         ;MOVE TEST DATA FOR ARLODE
        MOVWRD
100$:   .WORD   0               ;SOURCE ADDRESS FOR "MOVWRD"
        .WORD   EWORD1          ;DESTINATION
        $ARLO2  EWORD1          ;WRITE TEST PATTERN TO EBOX
        ADD     #5,R3           ;INCREMENT R3 TO NEXT TEST PATTERN
        RTS     PC

.REM    %
LOCAL SUBROUTINE TO INCREMENT THE SUBTEST #. THEN USE THE UPDATED
SUBTEST # AS A DRAM ADDRESS WHICH WILL POINT TO THE CORRECT
D-RAM DISPATCH J-FIELD ADDRESS SO THAT THE PARTICULAR SUBTET
WE ARE EXECUTING WILL BE ABLE TO DO A D-RAM DISPATCH DIRECTLY UT OF 
THE MICRO-CODE. WWHHHHHEEEW!!
%
SETTST: INSYNC                  ;COUNT SUBTEST
        MOV     (R1),R0         ;GET STARTING MICRO ADDRESS FOR THIS TEST
DRLDR:  WWADR                   ;WRITE ADDRESS AND RESET MACHINE
        $CLRWD
        MOV     R5,R0           ;SUBTEST # TO REG 0
        SHIFTL                  ;MULT SUBTEST BY 2
        .WORD   4               ;THEN SHIFT TO CORRECT EBUS BIT POSITION
        MOVB    R0,EWORD1+3     ;IN ORDER TO LOAD THE AR, THEN IR
        SWAB    R0              ;DON'T FORGET
        MOVB    R0,EWORD1+4     ;HIGH ORDER BITS
        PUSH    R1              ;SAVE R1
        MOV     #EWORD1,R1              ;ADDRESS OF DATA FOR LOAD AR CALL
        MOV     #LDAR,R0                ;DIAG FUNCTION
        DFWRT                   ;LOAD
        DFXCTT                  ;LOAD DATA INTO THE IR
        IRLOAD
        DFXCTT                  ;STROBE DRAM DATA TO DRAM LATCHES
        DRLTCH
        ECLOK                   ;INITIAL C-RAM WORD TO C.R.
        POP     R1              ;RETRIEVE REGISTER
        RTS     PC              ;DONE
;SEQ202

.REM    %
LIST OF DRAM DISPATCHES TAKE BY THE SUBTESTS.  THESE DISPATCHES
ARE LOADED TO THE DRAM BY THE INITIALIZATION ROUTINE SO THAT THE
TEST IS ALL SET TO GO AT BURST SPEED
%
INCONN: DRMDISPATCH 0,0,F40             ;ST1 @DRAM ADR 2
        DRMDISPATCH 0,0,F40     ;ST2 @DRAM ADR 4
        DRMDISPATCH 0,0,F40     ;ST3 @DRAM ADR 6
        DRMDISPATCH 0,0,F40     ;ST4 @DRAM ADR 10
        DRMDISPATCH 0,0,F40     ;ST5 @DRAM ADR 12
        DRMDISPATCH 0,0,F22     ;ST6 @DRAM ADR 14
        DRMDISPATCH 0,0,F6LONG  ;ST7 @DRAM ADR 16
        DRMDISPATCH 0,0,F46LNG  ;ST8 @DRAM ADR 20
        DRMDISPATCH 0,0,F6LONG  ;ST9 @DRAM ADR 22
        DRMDISPATCH 0,0,F46LNG  ;ST10 @DRAM ADR 24
        DRMDISPATCH 0,0,F6      ;ST1 @DRAM ADR 26
        DRMDISPATCH 0,0,F46LNG  ;ST12 @DRAM ADR 30
        DRMDISPATCH 0,0,F6LONG  ;ST13 @DRAM ADR 32
        DRMDISPATCH 0,0,F51             ;ST14 @DRAM ADR 34
DRMDISPATCH 0,0,F40GEN          ;ST15 @DRAM ADR 36
DRMDISPATCH 0,0,F40GEN          ;ST16 @DRAM ADR 40
DRMDISPATCH 0,0,F40GEN          ;ST17 @DRAM ADR 42
DRMDISPATCH 0,0,F40GEN          ;ST18 @DRAM ADR 44
DRMDISPATCH 0,0,F40GEN          ;ST19 @DRAM ADR 46
DRMDISPATCH 0,0,F11             ;ST20 @DRAM ADR 50
DRMDISPATCH 0,0,F11             ;ST21 @DRAM ADR 52


;SEQ203

DRMDISPATCH 0,0,F11             ;ST22 @DRAM ADR 54
DRMDISPATCH 0,0,F11             ;ST23 @DRAM ADR 56
DRMDISPATCH 0,0,F0              ;ST24 @DRAM ADR 60
DRMDISPATCH 0,0,F40             ;ST25 @DRAM ADR 62
        
DRMDISPATCH 0,0,F21             ;ST26 @DRAM ADR 64
DRMDISPATCH 0,0,F11             ;ST27 @DRAM ADR 66
DRMDISPATCH 0,0,F11             ;ST28 @DRAM ADR 70
DRMDISPATCH 0,0,F11             ;ST29 @DRAM ADR 72
DRMDISPATCH 0,0,F40GEN          ;ST30 @DRAM ADR 74
DRMDISPATCH 0,0,F11             ;ST31 @DRAM ADR 76
DRMDISPATCH 0,0,F11             ;ST32 @DRAM ADR 100
DRMDISPATCH 0,0,F26             ;ST33 @DRAM ADR 102
DRMDISPATCH 0,0,F11             ;ST34 @DRAM ADR 104
DRMDISPATCH 0,0,F6LONG          ;ST35 @DRAM ADR 106
DRMDISPATCH 0,0,F6LONG          ;ST36 @DRAM ADR 110
DRMDISPATCH 0,0,F46GEN          ;ST37 @DRAM ADR 112
DRMDISPATCH 0,0,F6LONG          ;ST38 @DRAM ADR 114
DRMDISPATCH 0,0,F46LNG          ;ST39 @DRAM ADR 116
DRMDISPATCH 0,0,F6INH           ;ST40 @DRAM ADR 120
DRMDISPATCH 0,0,F6LONG          ;ST41 @DRAM ADR 122
DRMDISPATCH 0,0,F46LNG          ;ST42 @DRAM ADR 124
DRMDISPATCH 0,0,F6LONG          ;ST43 @DRAM ADR 126
DRMDISPATCH 0,0,F46LNG          ;ST44 @DRAM ADR 130
DRMDISPATCH 0,0,F6LONG           ;ST45 @DRAM ADR 132
DRMDISPATCH 0,0,F46LNG           ;ST46 @DRAM ADR 134
DRMDISPATCH 0,0,F46LNG          ;ST47 @DRAM ADR 136
DRMDISPATCH 0,0,F6LONG          ;ST48 @DRAM ADR 140


;SEQ204

;LIST OF # OF SUBTESTS PER TEST GROUP
CONN10: .BYTE   ^D13            ;NUMBER SUBTESTS IN GROUP 1 (ARX,BRX,ADX)
        .BYTE   ^D11            ;NUMBER SUBTESTS IN GROUP 2(AR,BR,AD)
        .BYTE   ^D24            ;NUMBER SUBTESTS IN GROUP 3(AD&ADX)
        .BYTE   0               ;END OF LIST BYTE
        .EVEN

;LIST OF C-RAM STARTING ADDRESSES FOR EACH TEST GROUP
CONN11: .WORD   MIC4EDP         ;C-RAM START FOR GROUP 1
        .WORD   MIC4.1AD                ;C-RAM START FOR GROUP 2
        .WORD   MIC4.2AD                ;C-RAM START FOR GROUP 3

;EXPECTED DATA FOR EACH GROUP (1,2,3 RESPECTIVELY)
CONN12: EXPECT AR=NOCARE,BR=NOCARE,AD=NOCARE,ARX=.PATN,BRX=NOCARE,ADX=NOCARE,MQ=.ONES,FM=NOCARE
        EXPECT AR=.PATN,BR=NOCARE,AD=NOCARE,ARX=NOCARE,BRX=NOCARE,ADX=NOCARE,MQ=.ONES,FM=NOCARE
        EXPECT AR=.PATN1,BR=NOCARE,AD=NOCARE,ARX=.PATN,BRX=NOCARE,ADX=NOCARE,MQ=.ONES,FM=NOCARE

;SEQ205
;TEST DATA LIST
CONN13: ;SUBTEST 1--ALU=40,A+1
        WD36 0,0,5677,STAT36=BRXIS0     ;BRX
        WD36 0,0,5700                   ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 2--ALU=40,A+1
        WD36 0,56,7777,STAT36=BRXIS0    ;ARX
        WD36 0,57,0             ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 3--ALU=40,A+1
        WD36 0,5677,7777,STAT36=BRXIS0  ;ARX
        WD36 0,5700,0000                ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 4--ALU=40,A+1
        WD36 56,7777,7777,STAT36=BRXIS0 ;ARX
        WD36 57,0,0             ;ADX
        .BYTE   0               ;AD CRY -02

;SUBTEST 5--ALU=40,A+1
        WD36 5677,7777,7777,STAT36=BRXIS0       ;ARX
        WD36 5700,0,0           ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 6--ALU=22,ORCA
        WD36 3737,3737,3737             ;BRX
        WD36 7777,7777,7777             ;ARX
        WD36 3737,3737,3737             ;ADX
        .BYTE   0               ;AD CRTY -02
;SUBTEST 7--ALU=6,A+B,AD LONG
        WD36 7373,7373,7373     ;BRX
        WD36 1010,1010,1010     ;ARX
        WD36 0404,0404,0403             ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 8--ALU=46,A+B+1,AD LONG
        WD36 7377,7373,3337     ;BRX
        WD36 0001,0101,1111     ;ARX
        WD36 7400,7474,4451     ;ADX
        .BYTE   0               ;AD RY -02
;SUBTEST 9--ALU=6,A+B,AD LONG
        WD36 7733,7773,7737             ;BRX
        WD36 0101,0100,0001     ;ARX
        WD36 0035,0073,7740     ;ADX
        .BYTE   0               ;AD CRY -02


;SEQ206

;SUBTEST 10--ALU=46,A+B+1,AD LONG
        WD36 7773,3773,7733     ;BRX
        WD36 0001,0100,0101     ;ARX
        WD36 7774,4074,0035     ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 11-ALU=6,A+B
        WD36 3373,3777,3773     ;BRX
        WD36 0011,0001,1111     ;ARX
        WD36 3404,4000,5104     ;ADX
        .BYTE   0               ;AD CRY -02
;SUBTEST 12--ALU=46,A+B+1,AD LONG
        WD36 7737,3373,7337     ;BRX
        WD36 0001,0011,0101     ;ARX
        WD36 7740,3404,7441     ;ADX
        .BYTE   0               ;AD CRY -02
 

;SUBTEST 13--SLU=6,A+B,AD LONG
        WD36 7777,7377,3377             ;BRX
        WD36 0,1111,0010        ;ARX
        WD36 0,0510,3407        ;ADX
        .BYTE   0               ;AD CRY -02


;SEQ207

;BEGINNING OF TEST GROUP TWO - TESTS WHERE
;ONLY THE AR AND BR AR LOADED WITH TEST PATTERNS

;SUBTEST 14--ALU=51,A-B
        WD36 0100,0100,0100     ;BR
        WD36 7700,7700,7700     ;AR
        WD36 7600,7600,7600     ;AD
        .BYTE   10              ;AD CRY -02 TRUE

;SUBTEST 15--ALU=40,A+1,GEN CRY 18
        WD36 0016,7700,1677,STAT36=BR.IS0       ;AR
        WD36 0017,0000,1700     ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 16--ALU=40,A+1,GEN CRY18
        WD36 1677,7716,7777,STAT36=BR.IS0       ;AR
        WD36    1700,0017,0000  ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 17--ALU=40,A+1,GEN CRY18
        WD36 0,5700,0057,STAT36=BR.IS0  ;AR
        WD36 0,6000,0060        ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 18--ALU=40,A+1,GEN CRY18
        WD36 0057,7700,5777,STAT36=BR.IS0       ;AR
        WD36 0060,0000,6000     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 19--ALU=40,A+1,GEN CRY18
        WD36 5777,7757,7777,STAT36=BR.IS0       ;AR
        WD36 6000,0060,0000     ;AD
        .BYTE   0               ;AD CRY -02


;SEQ208

;SUBTEST 20--ALU=11,A-B-1
        WD36 0,0,1500           ;BR
        WD36 0,0,3200           ;AR
        WD36 0,0,1477           ;AD
        .BYTE   10              ;AD CRY -02
;SUBTEST 21--ALU=11,A-B-1       
        WD36 0,15,0000          ;BR
        WD36 0,32,0000          ;AR
        WD36 0,14,7777          ;AD
        .BYTE   10              ;AD CRY -02

;SEQ209

;SUBTEST 22-ALU=11,A-B-1
        WD36 0,1500,0000        ;BR
        WD36 0,3200,0000        ;AR
        WD36 0,1477,7777        ;AD
        .BYTE   10              ;AD CRY -02
;SUBTEST 23--ALU=11,A-B-1
        WD36 15,0000,0000       ;BR
        WD36 32,0000,0000       ;AR
        WD36 14,7777,7777       ;AD
        .BYTE   10              ;AD CRY -02
;SUBTEST 24--ALU=0,A+XCRY
        WD36 0,0,0,STAT36=BR.IS0        ;AR
        WD36 0,0,0              ;AD
        .BYTE   0               ;AD CRY -02
;BEGINNING FOF TEST GROUP THREE- TEST WHERE
;THE AR,BR,ARX,AND BRX ARE LOADED WITH DATA
;IN ORDER TO TEST BOTH ADX & AD TOGETHER
;SUBTEST 25--ALU=40,A+1
        WD36 0,0,0              ;BRX
        WD36 0,0,56             ;ARX
        WD36 0202,0202,0202     ;BR
        WD36 7575,7575,7575     ;AR
        WD36 0,0,57             ;ADX
        WD36 7575,7575,7576     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 26--ALU=21,ORC
        WD36 2222,2222,2222     ;BRX
        WD36    2222,2222,2222  ;ARX
        WD36    2727,2727,2727  ;BR
        WD36 2727,2727,2727     ;AR
        WD36 5555,5555,5555     ;ADX
        WD36 5050,5050,5050     ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 27--ALU=11,A-B-1       
        WD36 0,0,0              ;BRX
        WD36 3737,3737,3737     ;ARX
        WD36 0001,0001,0000     ;BR
        WD36 0077,0077,0077     ;AR
        WD36 3737,3737,3736     ;ADX
        WD36 0076,0076,0076     ;AD
        .BYTE   10              ;AD CRY -02


;SEQ210


;SUBTEST 28--ALU=1,A-B-1
        WD36 7777,7777,7777     ;BRX
        WD36 4545,4545,4545     ;ARX
        WD36 7777,7777,7777     ;BR
        WD36 0101,0101,0101     ;AR
        WD36 4545,4545,4545     ;ADX
        WD36 0101,0101,0101     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 29--ALU=11,A-B-1
        WD36 0,0,0              ;BRX
        WD36 4040,4040,4040     ;ARX
        WD36 4040,4040,4040     ;BR
        WD36 4040,4040,4040     ;AR
        WD36 4040,4040,4037     ;ADX
        WD36 7777,7777,7777     ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 30--ALU=40,A+1,GEN CRY18
        WD36 0,0,0              ;BRX
        WD36 6767,6767,6767     ;ARX
        WD36 0,0,0              ;BR
        WD36 0,1600,0016        ;AR
        WD36 6767,6767,6770     ;ADX
        WD36 0,1700,0017        ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 31--ALU=11,A-B-1       
        WD36 7777,7777,7777     ;BRX
        WD36 3232,3232,3232     ;ARX
        WD36 1515,1515,1515     ;BR
        WD36 3232,3232,3232     ;AR
        WD36 3232,3232,3232     ;ADX
        WD36 1515,1515,1514     ;AD
        .BYTE   10              ;AD CRY -02

;SUBTEST 32--ALU=11,A-B-1
        WD36 2121,2121,2121     ;BRX
        WD36 1010,1010,1010     ;ARX
        WD36 1500,0000,0000     ;BR
        WD36 3200,0000,0000     ;AR
        WD36 6666,6666,6666     ;ADX
        WD36 1477,7777,7777     ;AD
        .BYTE   10              ;AD CRY -02 TRUE
;SUBTEST 33-ALU=26,EQV
        WD36 5454,5454,5454     ;BRX
        WD36 0101,0101,0101     ;ARX
        WD36 3131,3131,3131     ;BR
        WD36 2424,2424,2424     ;AR
        WD36 2222,2222,2222     ;ADX
        WD36 6262,6262,6262     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 34--ALU=11,A-B-1
        WD36 1212,1212,1212     ;BRX
        WD36 0505,0505,0505     ;ARX


;SEQ211


        WD36 4242,4242,4242     ;BR
        WD36 2020,2020,2020     ;AR
        WD36 7272,7272,7272     ;ADX
        WD36 5555,5555,5555     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 35--ALU=6,A+B,AD LONG
        WD36 7777,7777,7777     ;BRX
        WD36 0,0,0              ;ARX
        WD36 3737,3737,3737     ;BR
        WD36 4040,4040,4041     ;AR
        WD36 7777,7777,7777     ;ADX
        WD36 0,0,0              ;AD
        .BYTE   10              ;AD CRY -02 TRUE


;SEQ212

;SUBTEST 36--ALU=6,A+B,AD LONG
        WD36 3737,3737,3737     ;BRX
        WD36 0101,0101,0101     ;ARX
        WD36 3737,3737,3727     ;BR
        WD36 4040,4040,4041     ;AR
        WD36 4040,4040,4040     ;ADX
        WD36 7777,7777,7770     ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 37--ALU=46,A+B+1,GEN CRY18
        WD36 3373,7733,7373     ;BRX
        WD36 0101,0011,1000     ;ARX
        WD36 2737,2717,0737     ;BR
        WD36 2041,4001,0040     ;AR
        WD36 3474,7745,0374     ;ADX
        WD36 5000,7020,1000     ;AD
        .BYTE   0               ;AD CRY -02


;SEQ213

;SUBTEST 38--ALU=6,A+B,AD LONG
        WD36 7777,7777,7773     ;BRX
        WD36 0,0,1              ;ARX

        WD36 3727,2757,3727     ;BR
        WD36 4141,2140,4021     ;AR
        WD36 7777,7777,7774     ;ADX
        WD36 0070,5117,7750     ;AD
        .BYTE   10              ;AD CRY -02 TRUYE

;SUBTEST 39--ALU=46,A+B+1,AD LONG
        WD36 7733,7773,7733     ;BRX
        WD36 1111,0000,1100     ;ARX
        WD36 4737,2727,3727     ;BR
        WD36 4021,4141,4140     ;AR
        WD36 1044,7774,1034     ;ADX
        WD36 0760,7071  ,0070   ;AD
        .BYTE   10              ;AD CRY -02 TRUE

;SUBTEST 40--ALU=6,A+B,INH CRY18
        WD36 7373,7373,7373     ;BRX
        WD36 0101,0101,0101     ;ARX
WD36 3737,3737,3737             ;BR
        WD36 4141,4141,4141     ;AR
        WD36 7474,7474,7474     ;ADX
        WD36 0101,0001,0100     ;AD
        .BYTE   10              ;AD CRY -02 TRUE


;SEQ214

;SBUTEST 41--ALU=6,A+B,AD LONG
        WD36 7777,3337,7333     ;BRX
        WD36 0,0010,1000        ;ARX
        WD36 3757,2737,3727     ;BR
        WD36 2141,4041,4021     ;AR
        WD36 7777,3350,0333     ;ADX
        WD36 6120,7000,7750     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 42--ALU=46,A+B+1,AD LONG
        WD36 7777,7777,7777     ;BRX
        WD36 0,0,1              ;ARX
        WD36 3727,3727,4707     ;BR
        WD36 4021,2041,4001     ;AR
        WD36 0,0,1              ;ADX
        WD36 7750,5771,0711     ;AD
        .BYTE   0               ;AD CRY -02

;SUBTEST 43--ALU=6,A+B,AD LONG
        WD36 7373,7373,7373     ;BRX
        WD36 1010,1010,1010     ;ARX
        WD36 0,0,0              ;BR
        WD36 0,0,0              ;AR
        WD36 0404,0404,0403     ;ADX
        WD36 0,0,0001           ;AD
        .BYTE   0               ;AD CRY -02


;SEQ215

;SBUTEST 44--ALU=46,A+B+1,AD LONG
        WD36 7377,7373,3337     ;BRX
        WD36 0001,0101,1111     ;ARX
        WD36 2727,2727,2727     ;BR
        WD36 4141,4141,4141     ;AR
        WD36 7400,7474,4451     ;ADX
        WD36 7070,7070,7070     ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 45--ALU=6,A+B,AD LONG
        WD36 7733,7773,7737     ;BRX
        WD36 0101,0100,0001     ;ARX
        WD36 0,0,0              ;BR
        WD36 0,0,0              ;AR
        WD36 0035,0073,7740     ;ADX
        WD36 0,0,0001           ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 46--ALU=46,A+B+1,AD LONG
        WD36    7773,3773,7733  ;BR
        WD36 0001,0100,0101     ;ARX
        WD36 0,0,0              ;BR
        WD36 0,0,0              ;AR
        WD36 7774,4074,0035     ;ADX
        WD36 0,0,0              ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 47--ALU=46,A+B+1,AD LONG
        WD36 7737,3373,7337     ;BRX
        WD36 0001,0011,0101     ;ARX
        WD36 0,0,0              ;BR
        WD36 0,0,0              ;AR
        WD36 7740,3404,7441     ;ADX
        WD36 0,0,0              ;AD
        .BYTE   0               ;AD CRY -02
;SUBTEST 48--ALU=6,A+B,AD LONG
        WD36 7777,7377,3377     ;BRX
        WD36 0,1111,0010        ;ARX
        WD36 0,0,0              ;BR
        WD36 0,0,0              ;AR
        WD36 0,0510,3407        ;ADX
        WD36 0,0,0001           ;AD
        .BYTE   0               ;AD CRY -02
        
.EVEN


;SEQ216

.SBTTL TEST 6 (EDP4A):  "-AD=0" TEST USING FLOATING ONES DOWN THE AD
.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE "-AD=0" LOGIC
ON EACH OF THE EDP BOARDS.  THE TEST VERY SIMPLY FLOATS A
ONE DOWN THE AD. AD DOES A BURST OF CCLOCKS AND A SKIP
ON "-AD=0", IN ORDER TO INSURE THAT EACH A BIT INDIVUDUALLY
IS CAPABLE OF CAUSING THE CONDITION "-AD=0". FAILURES DURING THIS
TEST SHULD BE EASILY TRACED TO THE EDP BOARD WHICH CONTAINS
THE BIT UNDER TEST.
%
EDP4A:  $CLRWD  EWORD2          ;CLEAR 36-BIT BUFFER AT EWORD2
        INC     EWORD2          ;SET BIT 35
        MOV     #MIC4A,R0       ;SET CRAM START ADDRESS
        WWADR                   ;EMT TO ACTUALLY SET ADDRESS AND MR
        ECLOK                   ;FIRST WORD TO C.R.
CAL1:   INSYNC                  ;COUNT SUBTESTRS
        $ARLO2  EWORD2          ;DATA TO AR
        MOV     #7,R0           ;SEVEN TICS TO EXECUTE THE MICRO-CODE
        BURST                   ;NOW BURST THE CLOCK
        MOV     #MIC4A,R0                ;COMPARE FINAL CRAM ADDRESS TO EXPECTED
        CRMHLT                  ;SEE IF STOPPED AT RIGHT MICRO ADDRESS
        BCS     CAL2            ;BR ON BAD CRAM END ADDRESS

;ENDED OK--HERE IF FINISHED WHERE EXPECTED
        $ROLWD  EWORD2          ;FLOAT 1 RTO NEXT AD BIT POSITION
        CMP     #^D36,R5                ;SEE IF DONE ALL BITS
        BGT     CAL1            ;BACK IF NO
        JMP     NORMAL  ;OUT IF YES AND ALL OK
;HERE ON MICRO-CODE ERROR
CAL2:   MOV R0,R1               ;SAVE FINAL CRAM ADDRESS
        JSR     R5,$DCOMP       ;GO CHECK STATE OF "-AD=0"
        .WORD   CALMSK          ;ADDRESS OF MASK
        .WORD   CALDF           ;ADDRESS OF DIAG FCN

        .WORD   CALBYT          ;ADDRESS OF BYTE POINTER
        .WORD   CALEXP          ;ADDRESS OFE XPECTED LIST
        .WORD   0               ;NO ERROR MESSAGE POINTER


;SEQ217

;IF YOU RETURN TO MAINLINE, THEN "-AD=0" IS CURRENTLY OK, WHICH
;MEANS THAT "-AD=0" HAS A SPEED PROBLEM
        ERRMSG<\"-AD=0" HAS A SPEED PROBLEM. MICRO-CODE FAILS\>
        ERRMSG<A "SKIP/AD#0">
        JSR     PC,FAULT                ;REPORT ERROR
        .WORD   0               ;NO OTHER MESSAGE NECESSARY
CALMSK: .BYTE   376             ;MASK ALL BUT BIT12 OF 36-BIT WORD
CALDF:  .BYTE   136!BIT7           ;DIAG FCN TO READ -AD=0
CALBYT: BYTPNT  12                      ;READ STARTING AT BIT 12
CALEXP: .BYTE   1               ;ALWAYS EXPECT IT TRUE


;SEQ218

.SBTTL TEST 7 (EEDP05):  FAST MEMORY BASIC INTERFERENCE TEST--BURST SPEED
.REM    %
IT IS THE PURPOSE OF THIS TEST TO DETECT ANY INTERFERENCE
BETWEEN THE 36 DATA BITS COMING FROM THE FAST MEMORY RAMS
LOCATED ON THE DATA PATH BOARD.

THE TEST FIRST LOADS THE AR WITH THE CURRENT INTERFERENCE
PATTERN, THEN LOADS THAT PATTERN INTO THE CURRENTLY ADDRESSED
FAST MEMORY LOCATION.  THE OUTPUT OF THE FAST MEMORY IS THEN
CHECKED TO SEE THAT THERE IS NO INTERFEREBCE BETWEEN ANY OF
ITS BITS.
%
EEDP05: MOV     #MIC5ED,R0     ;MICRO-CODE START ADDRESS
        WWADR                   ;LOAD ADDRESS AND RESET EBOX
        $PAT36  PATN            ;GET FIRST INTERFERENCE
        ECLOK                   ;NOW CLOCK FIRST RAM WORD TO C.R.

ASKA1:  INSYNC                  ;KEEP TRACK OF SUBTEST
        MOV     #ASKA3,R4       ;GET POINT TO EXPECTED
        $ARLO2  PATN            ;INTERFERENCE PATTERN TO AR
        ECLOK                   ;SYNC THE EBOX
        EBURST  3               ;WRITE DATA TO FAST MEMORY

        JSR     PC,EDPTST               ;AND CHECK RESULTS
        BCC     ASKA2           ;BR IF NO ERROR
        JSR     PC,FAULT                ;ERROR WAS FOUND
        .WORD   0               ;NO ERROR MESSAGE

ASKA2:  PATCON                  ;NEXT INTERFERENCE
        TST     R0              ;CHECK AND SEE IF ALL DONE
        BNE     ASKA1           ;BR IF MORE PATTERNS LEFT
        JMP     NORMAL          ;OUT IF NONE

ASKA3:  EXPECT AR=.ZERO,BR=.PATN,AD=.PATN,ARX=.ZERO,BRX=NOCARE,ADX=.ZERO,MQ=.ONES,FM=.PATN


;SEQ219

.SBTTL  TEST 8 (EEDP06): FAST MEMORY RAM TEST
.REM    %
IT IS THE PURPOSE OF THIS TEST TO DETECT ANY FAST
MEMORY RAM ADDRESSING PROBLEMS, OR TO DETECT ANY
FAST MEMORY CELLS STUCK HIGH OR LOW.
THE TEST ALGORITHM CONSISTS OF THREE SEGMENTS:

1)FILL ALL RAM LOCATIONS WITH ZEROES
2)BEGIN AT BLOCK 0, ADDRESS ZERO, READ ALL ZEROES
        THERE, THEN WRITE ALL ONES THRE, INCRMENT
        TO THE NEXT ADDRESS.  IT SHOULD STILL BE
        ZEROES, NOW READ ZEROES THRE, THEN WRITE
        ONES, AND AGAIN INCREMENT TO THE NEXT
        ADDRESS, CONTINUE TO THE LAST ADDRESS AND BLOCK
        
3)THIS SEGMENT IS SIMILAR TO SEGMENT TWO.
        BEGIN AT TADDRESS BLOCK 7, ADDRESS 17.  READ
        ONES THRE, THEN WRITE ZEROES.  DECREMENT
        TO THE NEXT ADDRESS.  IT SHOULD STILL BE
        ONES.  NOW READ THE ONES, WRITE ZEROES
        AND DECREMENT AGAIN.  CONTINUE TO BLOCK 0,
        ADDRESS 00
THE TEST BEGINS BY LOADING 3 THIRTY-SIX BIT WORDS INTO SEVERAL
DATA PATH REGISTERS AT SINGLE STEP SPEED.  ONCE THE 4 REGISTERS
ARE INITIALIZED (BRX=41,,0)(BR=777757,,0)(AR=770000,,0)(MQ=770000,,0)
THE RESET OF THE TEST IS RUN IN THE MICRO-CODE AT FULL
MACHNE SPEED (CURRENT CONSOLE SELECTED CLOCK RATE).
NEXT, WE WAIT A FINIT AMOUNT OF TIME UNTIL THE MICRO-CODED
TEST SHOULD HAVE COMPLETED.  THEN STOP THE CLOCK AND EXAM
WHAT HALT LOOP THE TEST IS IN (I.E. THE "NORMAL TERMINATION")
HALT LOOP OR THE "ERROR HALT" HALT LOOP)
%
;SET STARTING ADDRESS OF MICRO-CODE FOR THIS TEST
XXVIRG:         MOV     #MIC6EDP,R0
        WWADR                   ;ADDRESS TO DIAG ADDR REG PLUS MRESET
        ECLOK

;SEQ220

;NOW SEND INITIALIZING DATA ACROSS EBUS TO DATA PATH REGISTERS
        $ARLO2  VIRG6           ;770000,,0 ACROSS EBS (INITIAL BLCK & FM ADR)
        ECLOK                   ;SHUFFLE

        $ARLO2  VIRG7           ;41,,0 ACROSS EBUS (VALUE TO INCREMENT BLK & FM ADR)
        ECLOK                   ;SHUFFLE DATA
        $ARLO2  VIRG8           ;777757,,0 (MASK LETS THROUGH BLK & FMADR)

;READY TO BURST
        DFXCTT                  ;TURN ON EBOX CLOCK
        STRCLK
1$:     ADD     #10,#0          ;WASTE ABOUT A SECOND REAL TIME
        BNE     1$
        DFXCTT
        STPCLK                  ;STOP CLOCK
        RTS     PC

;NOW CHECK CR-ADR FOR HALT LOOP STATE
EEDP06: JSR     PC,XXVIRG               ;EXECUTE THE TEST MICRO-CODE
        MOV     #FMOK5,R0       ;RAM HALT ADDRESS = "OK" HALT ADDRESS?
        CRMHLT                  ;SEE THAT STOPPED ON EXPECTED MICRO ADDRESS
        BCS     VIRG1           ;REPORT ERROR IF NO
        JMP     NORMAL          ;NORMAL RETURN IF YES


;SEQ221

.REM    %
ERROR PROCESSING
THERE ARE THREE LOCATIONS YOU COULD HAVE HALTED ATIN THIS MICRO LOOP.
1) HALT AT LOCATION "HALT00" IF THE RAM DID NOT PROPERLY FILL WITH
ZEROES (A STUCK-AT-ONE CONDITION). 2) HALT AT LOCATION "HALT20" IF
AN ADDRESS MULTIPLY SELECTS MORE THAN ONE RAM LOCATION.  3) HALT AT
LOCATION "HALT40" IF AN ADDRESS MULTIPLY SELECT MORE THAN ONE RAM
LOCATION IN ASCENDING DIRECTION.  OR PERHAPS A STUCK-AT-ZERO CHNDITION.
%
VIRG1:  PUSH    R0              ;SAVE HALT ADDRESS

;READ BACK FAILING BLOCK & REPORT IT
        ERRMSG<\FM BLOCK >      ;PRINT DESCRIPTIVE MESSAGE
        DFRDT           ;READ BLOCK INFORMATION
        RAPR+4  
        MOV     @.DAT2,R0       ;GET WORD THAT CONTAINS DESIRED INFO
        PUSH    R0              ;SAVE DESIRED INFO ON STACK
        SWAB    R0              ;SWITCH BYTES
        ASR     R0              ;RIGHT JUSTIFY CURRENT BLOCK
        BIC     #177770,R0      ;OFF TRASH
        ERROCT                  ;PRINT BLOCK


;SEQ222

;AND NEXT REPORT FMADR
        ERRMSG< --FM ADR >      ;DESCRIPTOR
        POP     R0              ;RETIREVE FM ADR INFO FROM STACK
        ASL     R0              ;JUSTIFY DESIRED
        ASL     R0              ;DATA ON ODD
        ASL     R0              ;BYTE BOUNDARY
        SWAB    R0              ;JUSTIFY ON RIGHT BOUNDARY
        BIC     #177760,R0      ;OFF TRASH
        ERROCT  
;FINALLY PRINT OUT APPROPRIATE DIAGNOSTIC MESSAGE WITH
;EXPECTED/CORRECT DATA THEN JUMP TO FAULT REPORT
        MOV     #EWORD1,R1      ;ADDRESS TO PUT ACTUAL DATA
        MOV     #DPAR,R0        ;READ FM, WHICH WAS CLOCKED INTO THE AR
        DFRDMV
        POP     R0              ;RETIREVE HALT ADDRESS
        CMP     #HALT00,R0      ;WAS IT PHASE I ERROR
        BNE     VIRG2           ;BR IF NOT
        MOV     #ZERO,R4        ;SET EXPECTED
        BR      VIRG4           ;CONTINUE


;SEQ223

VIRG2:  CMP     #HALT40,R0      ;WAS IT PHASE III ERROR
        BNE     VIRG3           ;BR IF NO
        MOV     #ONES,R4        ;SET EXPECTED
        BR      VIRG4           ;CONTINUE

VIRG3:  MOV     #ZERO,R4                ;SET EXPECTED
VIRG4:  MOV     ERSP..,R0       ;ERR STACK
        MOV     #FTM36,(R0)+    ;SET FORMAT TYPE
        MOV     #ZERO,(R0)+     ;SET MASK POINTER
                MOVB    (R1)+,(R0)+     ;FIVE MOVES TO SET ACTUAL
        MOVB    (R1)+,(R0)+             
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
        MOVB    (R4)+,(R0)+     ;FIVE MOVES TO SET EXPECTED
        MOVB(R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOV     R0,ERSP..       ;RETURN ERROR STACK
        MOV     R5,VIRG5        ;SET FINAL ERROR MESSAGE
        CLR     R5              ;AND NO SUBTEST TO REPORT
        JSR     PC,FAULT
VIRG5:  0                       ;ERR MESSAGE
VIRG6:  WD36    7700,0000,0000
VIRG7:  WD36    0000,4100,0000
        VIRG8:  WD36    7777,5700,0000
.EVEN

;SEQ224
.SBTTL *VMA*  VMA AND ADDRESS BREAK REGISTER TESTS
.SBTTL TEST 9 (EVMA01): VMA AND ADDRESS BREAK REGISTERS DATA & INTERFERENCE TEST

.REM    %
        
THIS TEST IS TRYING TO PROVE THAT THE VMA & ADDRESS BREAK
REGISTERS CAN BOTH HOLD ALL ONES, ALL ZEROES & THAT NO REGISTER
LINES INTERFERE WITH ONE ANOTHER.
THE AR IS FIRST LOADED WITH THE CURRENT TEST DATA.  NEXT,
THE STARTING ADDRESS OF THE MICROCODE FOR THIS TEST IS LOADED
AND FINALLY A BURST OF EBOX CLOCKS IS GIVEN. THE MICROCODE
THAT IS EXECUTED BYT HIS BURST SHOULD LOAD OUR TEST PATTERN
FROM THE AR, THRU THE AD, AND INTO THE VMA & ADR BRK
REGISTERS.  SINGLES DISCREPENCIES IMPLY BAD REGISTER BITS, MULTI DISCREPENCIES
IMPLY FAILURE OF THE REGISTERS TO LOAD PROPERLY.  DROPPED BITS OULD
INDICATE NO TERMINATOR.
%
EVMA01: PMSG<STARTING VMA TESTS\>
        CLR     ERRLVL
        MOV     #MIC1VMA,R0     ;MICRO CODE START ADDRESS FOR THIS TEST
        WWADR                   ;& RESET THE EBOX
        MOV     #EWORD1,R0      ;36 BIT TEST DATA BUFFER
        P36                     ;FILL IT WITH INTERFERENCE PATTERN
        ECLOK                   ;CLOCK MICRO INSTR TO C.R.
1$:     INSYNC                 ;SUBTEST #
        MOV     #EWORD1,R0      ;NOW GET THE TEST PATTERN
        ARLOD2                  ;AND WRITE IT TO THE AR.
        MOV     #25,R0          ;THESE MANY, MANY
        BURST                   ;TICS TO EXECUTE RAM CODE
        DFVMA                   ;READ VMA REGISTER
        JSR     R5,100$         ;GO CHECK RESULTS
        BCC     10$             ;BR IF NO ERROR FOUND
        ERRMSG<VMA ERROR DATA\>


;SEQ225


10$:    DFADB                   ;READ ADDRESS BREAK EGISTER
        JSR     R5,100$         ;GO CHECK RESULTS
        BCC     20$             ;BR IF NO ERROR FOUND
        ERRMSG<ADDR BRK ERROR DATA\>
20$:    TST     ERRLVL          ;ANY ERRORS DETECTED?
        BEQ     2$              ;CONTINUE IF NO (ERRLVL=0)
        JSR     PC,FAULT                ;OTHERWISE REPORT ERRORS
        .WORD   0               ;NO ERROR MESSAGE
2$:     PATCON          ;NEXT INTERFERENCE PATTERN
        TST     R0              ;DONE ALL INTERFERENCE?
        BNE     1$              ;NOT ALL
        JMP     NORMAL          ;DONE ALL
;ROUTINE WHICH MERELY CALLS MASK36 6O COMPARE VMA & ADDR BRK
;AGAINST WHAT WAS SENT.
100$:   MOV     R0,101$         ;SET ADDRESS OF ACTUAL
        M36T                    ;;MASK AND COMPARE
        .WORD   VMAM23          ;VMA23-BIT MASK
        .WORD   EWORD1          ;POINT TO EXPECTED
101$:   .WORD   0               ;FILLED IN POINT TO ACTUAL
        BCC     105$            ;IF "C" CLR, NO ERRORS
        INC     ERRLVL          ;THERE WAS AN ERROR
        SEC                     ;SET "C-BIT" FOR ERROR RETURN
105$:   RTS     R5
VMAM23: WD36    7777,4000,0000
.EVEN

;SEQ226

.SBTTL TEST 10 (EVMA02): VMA & ADDRESS BREAK MATCH LOGIC, BITS 18-35

.REM    %
THIS TEST IS TRYING TO BERIFY THE CORRECT OPERATION OF THE
VMA/ADDRESS BREAK MATCH LOGIC ON PRINT (VMA3), & THE VMA 18-31=0 LOGIC
BOTH REGIWTERS ARE LOADED WITH ALL ONES AND ALL ZEROES AND
VERIFIED TO MATCH, WHICH CHECKS THE LINES FOR STUCKS HI
AND LO, NEXT, THE ADDRESS BREAK REGISTER IS KEPT LOADED WITH
ZEROESD AND A SINGLE ONE IS FLOATED DOWN THE VAMA
REGISTER TO VERIFY THAT THE "XOR" GATES OPERATE CORRECTLY (ALSO CHECKING 18-31=0)
%
EVMA02: SETWRD                  ;CREATE 36 BITS OF ONES
        .WORD   EWORD1          ;AT EWORD1
        MOV     #MIC1VMA,R0     ;MICROCODE START ADDRESS FOR THIS TEST
        WWADR                   ;& RESET THE EBOX
        MOVB    #4,NEB04                ;ALWAYS EXPECT "MISC=0" & "LOCAL AC ADDR" TRUE
        MOVB    #24,NEB04+1     ;AND "AC REF" & "MATCH 13-35" FALSE

        M.RESPSIM                       ;FIX UP MBOX
        ECLOK                   ;INITIAL RAM WORD TO C.R.
        MOV     #NEB04,DCOMPX   ;TELL DCOMP WHERE TO FIND THE EXPECTED
        MOV     #NEB05,R2               ;SET NUMBER OF CHANGES PNTR
        MOV     #NEB06,R3       ;SET ACTUAL CHANGES PNTR

1$:     INSYNC                  ;SUBTEST
        CLRB    EWORD1+4        ;CLEAR UNUSED PIECEOF
        CLRB    EWORD1+3                ;36 BIT DATA TO PREVENT SPURIOUS
        BICB    #200,EWORD1+2   ;AD FUNCS IN THE MICRO-CODE
        MOV     #EWORD1,R0      ;ADDRESS OF DATA
        ARLOD2          ;LOADED TO THE AR.
        MOV     #25,R0
        BURST
        JSR     PC,100$         ;GO CHECK THE RESULTS WITH DCOMP CALL
        TST     EWORD1          ;FINISHED ALL ZEROES YET?
        BEQ     2$              ;BR IF YES
;IF HERE, NEED TO EXECUTE ALL ZEROES CASE TO VMA & ADR BRK
        CLRWRD                  ;SET 36 BITS TO ZEROES
        .WORD   EWORD1
        BR      1$              ;GO BACK AND TRY ALL ZEROES CASE
;IF HERE, NEED TO LOAD ONLY VMA & FLOAT A ONE
2$:     INC     EWORD1          ;SET BIT 35 OF 36 BIT DATA
        MOV     #MIC2VMA,R0     ;START ADDRESS OF 2ND HALF OF THIS TEST MICROCODE
        WWADR                   ;LOAD THIS ADDRESS & RESET EBOX
        ECLOK
        M.RESPSIM                               ;MAKE MBOX BEHAVE


;SEQ227

3$:     INSYNC                  ;SUBTEST
        MOV     #EWORD1,R0
        ARLOD2                  ;CLOCK DTA INTO THE AR
        EBURST  2               ;EXECUTE MICROCODE FOR THIS TEST
        JSR     PC,100$         ;GO CHECK "MATCH" AND "18-31=0"
        ROLWRD                  ;FLOAT THE ONE TO
        .WORD   EWORD1          ;NEXT BIT POSITION

5$:     CMP     #^D25,R5                ;DONE ALL SUBTEST YET?
        BGT     3$              ;BR BACK IF NO
        JMP     NORMAL          ;OUT IF YES

;IT CHECKS THE "VMA MATCH" SIGNAL, AND THE "VMA 18-31=0" SIGNAL
;SUBROUTINE TO PERFORM A DCOMPF OR US FOR THIS TEST

100$:   MCOMP                   ;MODIFY NOMINALE XPECTRED DATA
        DCOMP                   ;AND TEST THE MATCH & 18-31=0 LINES
        .WORD   NEB01           ;MASK TABLE FOR TWO COMPARES
        .WORD   NEB02           ;;DIAG FUNCTION TABLE FOR TWO COMPARES
        .WORD   NEB03           ;TABLE OF BYTE POINTERS
        .WORD   NEB04           ;TABLE OF EXPECTED DATA
        .WORD   0               ;NO POINTER TO ERRROR MESSAGE
        RCOMP                   ;RESTORE TABLE TO NOMNAL STATE
        RTS     PC              ;RETURN

NEB01:  .BYTE   353,353         ;MASK FOR "VMA MISC=0","LOCAL AC ADDR"
                        ;AND "VMA AC REF","VMA MATCH 13-35"
NEB02:  .BYTE   153,157!BIT7    ;DIAG FUNCTIONS TOR EAD VMA BOARD
NEB03:  BYTPNT  17              ;DATA ON EBUS BIT 13
        BYTPNT  17              ;DATA ON EBUS BIT 15
NEB04:  .BYTE  4,24            ;EXPECTED "MATCH" & "18-31=0"


;SEQ228

;NUMBER OF CHANGES TABLE
NEB05:  .BYTE   2               ;SUBTEST 1
        .BYTE   1       ;ST 2
        .BYTE   1       ;ST 3
        .BYTE   1       ;ST 4
        .BYTE   1               ;ST5
        .BYTE   1       ;ST 6
        .BYTE   1       ;ST7
        .BYTE   1       ;ST 8
        .BYTE   1       ;ST 9
        .BYTE   1       ;ST 10
        .BYTE   0       ;ST 11
        .BYTE   0       ;ST 12
        .BYTE   0       ;ST 13
        .BYTE   0       ;ST 14
        .BYTE   0       ;ST 15
        .BYTE   0       ;ST 16
        .BYTE   0       ;ST 17
        .BYTE   0       ;ST 18
        .BYTE   1       ;ST 19
        .BYTE   1       ;ST 20
        .BYTE   1       ;ST 21
        .BYTE   0       ;ST 22
        .BYTE   0       ;ST 23
        .BYTE   0       ;ST 24
        .BYTE   0       ;ST 25

;TABLE OF ACTUAL CHANGES
NEB06:  .BYTE   0       ;SUBTEST 1
        .BYTE   24      ;"-MISC=0","-LOCAL AC ADDR"
        .BYTE   1
        .BYTE   20      ;"MATCH 13-35"
        .BYTE   1       ;SUBTEST 2
        .BYTE   0       ;"VMA AC REF","MATCH 13-35"
        .BYTE   1       ;SUBTEST 3
        .BYTE   4       ;"VMA AC REF"
        .BYTE   1       ;SUBTEST 4
        .BYTE   4       ;"VMA AC REF"
        .BYTE   1       ;SUBTEST 5
        .BYTE   4       ;"VMA AC REF"
        .BYTE   1       ;SUBTEST 6
        .BYTE   4       ;"VMA AC REF"
        .BYTE   0       ;SUBTEST 7
        .BYTE   24      ;"-MISC=0"
        .BYTE   0       ;SUBTEST 8
        .BYTE   24      ;"-MISC=0"
        .BYTE   0       ;SUBTEST 9
        .BYTE    24      ;"-MISC=0"

;SEQ229

        .BYTE   0       ;SUBTEST 10
        .BYTE   24      ;"-MISC=0"
        .BYTE   0       ;SUBTEST 19
        .BYTE   24      ;"-MISC=0"
        .BYTE   0       ;SUBTEST 20
        .BYTE   24      ;"-MISC=0"
        .BYTE   1       ;SUBTEST 21
        .BYTE   4       ;"-VMA AC REF"

.EVEN


;SEQ230

.SBTTL TEST 11 (EVMA07):  "PC" & "VMA HELD" REGISTER TESTS - STATIC

.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE DIAGNOSTIC MULTIPLEXORS
THAT READ OUT THE CONTENTS OF THE PC AND VMA HELD REGISTERS.
THE TESTS SIMPLY LOADS OUR INTERFERENCE PATTERNS INTO FIRST THE
PC, THENR EADS THE PC, TRANSFERS THE PATTERN TO THE VMA HELD AND THEN
REPEATS THIS FOR ALL OF OUR INTERFERENCE PATTERNS
%
EVMA07: CLRBUF          ;CLEAR 36 BIT BUFFER
        MOV     #MIC7VMA,R0     ;C-RAM START ADDRESS
        WWADR                   ;RESET AND SET START ADDRESS
        ECLOK                   ;FIRST WORD TO C.R.


;SEQ231

HAW1:   INSYNC                  ;COUNT SUBTESTS
        $ARLO2  EWORD1          ;TEST DATA TO AR
        EBURST  2               ;EXECUTE THE "LOAD PC" MICRO-CODE
        DFPC                    ;READ THE PC
        MOV     R0,100$         ;SET PNTR TO ACTUAL
        M36T                    ;AND COMPARE ACTUAL VS. EXPECTED
        .WORD   PCMSK           ;PNT TO MASK
        .WORD   EWORD1          ;PNT TO EXPECTED
100$:   .WORD   0               ;PNT TO ACTUAL RECEIVED
        BCC     HAW2            ;BR IF D DATA OK
        JSR     PC,FAULT        ;OTHERWISE ERROR
        .WORD   0
HAW2:   INSYNC
        EBURST  2               ;EDECUTE THE "LOAD VMA HELD" MICR-CODE
        DFVMAH                  ;READ THE VMA HELD REGISTER
        MOV     R0,101$         ;SET PNTR TO ACTUAL
        M36T                    ;COMPARE ACTUAL VS. EXPECTED
        .WORD   VMHMSK          ;PNT TO MASK
        .WORD   EWORD1          ;PNT TO EXPECTED
101$:   .WORD   0               ;PNT TO ACTUAL RECEIVED
        BCC     HAW3            ;BRT IF OK
        JSR     PC,FAULT                ;OTHERWISE-ERROR
        .WORD   0


;SEQ232

HAW3:   CMP     #2,R5           ;START PATTERN GENERATE ON SUBTEST 1
        BLT     HAW4            ;BR IF PAST SUBTEST 1
        $PAT36  EWORD1          ;IF SUBTEST 1, GENERATE PATTERNS
        BR      HAW1            ;AND OCNTINUE
HAW4:   $PATCON                 ;NEXT PATTERN
        TST     R0              ;DONE ALL??
        BNE     HAW1            ;DR IF MORE TO DO
        JMP     NORMAL          ;OTHERWISE OUT
PCMSK:  
VMHMSK: WD36    7777,4000,000   ;MASK ALL CHAR BUT 13-35
        .EVEN


;SEQ233
.SBTTL TEST 12 (EVMA03):  "PC" & "VMA HELD" REGISTER TESTS - BURST SPEED

.REM    %
IT IS THE PURPOSE OF THIS TEST TO BERIFY THAT NEIGHTR THE
"PC" OR "VMA HELD" REGISTERS HAVE ANY BITS STUCK-AT-ONE OR
STUCK-AT-ZERO.  IT ALSO TESTS THAT EACH REGISTER'S BITS
DO NOT INTERFER WITH ANY OTHER BITS IN THAT REGISTER WE ALSO
TEST THE BACK PLANE LINES BETWEEN THE "PC OR VMA HELD2 MIXER
AND THE "ADA" MIXER ON THE DATA PATH BOARD.
THE MICRO CODE FOR THIS TEST BEGINS WITH OUR TEST DATA IN
THE AR.  AT BURST MODE WE THEN LOAD THE VMA THEN IMMEDIATELY
LOAD THE "VMA HELD" REGISTER.  THE MICRO-CODE THEN STEERS
THE PC THRU THE ADA INTO THE ARX.  NEXT WE STEER
THE VMA HELD REGISTER THRU THE ADA INTO THE AR.  FINALLY
WE LOAD THE PC FROM THE VMA.  THEN WE TEST THE
RESULTS BECAUSE OF OUR LOADING SEQUENCE THE AR SHOULD CONTAIN
THE CURRENT TEST PATTERN AS TRANSFERRED FROM THE VMA HELD REGISTER.
THE ARX SHOULD CONTAIN NOT THE CURRENT, BUT THE PREVIOUS
TEST PATTERN, WHICH WAS JUST TRANSFERRED FROM THE PC.  THIS WAY
THE PC & VMA HELD REGISTERS ALWAYS CONTAIN DIFFERENT PATTERNS WHICH ALSO
ENABLES US TO VERIFY THE "PC OR VMA HELD" MIXER.
%

EVMA03: MOV     #NHAM03+10,R4   ;SET UP EXPECTED DATA POINTER
        MOV     #MIC3VMA,R0     ;MICRO-CODE START ADDRESS
        WWADR                   ;RESET KL10 AND SET START ADDRESS
        $PAT36  PATN            ;GET FIRST TEST PATTERN INTO PATN
        ECLOK                   ;FIRST RAM WORD TO C.R.
NHAM01: SUB     #10,R4          ;RESET TO BEGINNING OF EXPECTED BYTES
        INSYNC                  ;COUNT SUBTESTS
        CLRB    PATN+4          ;ONLY NEED 23 BIT PATTERNS
        MOVB    #11,PATN+3      ;EXPECT "-EBOX CACHE H(BIT11)","VMA EXTENDED(BIT8)"
        BISB    #200,PATN+2     ;EXPECT "-EBOX MAY BE PAGED H(BIT12)"
        $ARLO2  PATN            ;LOAD TST PATTERN TO AR
        EBURST  4               ;EXECUTE THE TEST.
        JSR     PC,EDPTST               ;GO CHECK RESULTS
        BCC     NHAM02  ;BR IF NO ERROR
        JSR     PC,FAULT        ;REPORT ERROR
        .WORD   0               ;NO ERRMSG


;SEQ234

NHAM02: $MOVWD  PATN,PATN1      ;MAKE THIS TEST PATTERN A PREVIOUS PATTERN
        CLRB    PATN1+3         ;PC GETS ZEROES AT EBUS11 & 12
        BICB    #200,PATN1+2
        $PATCON                 ;AND GET A NEW CURRENT PATTERN
        TST     R0              ;DONE ALL TEST PATTERNS?
        BNE     NHAM01          ;NO, CONTINUE
        JMP     NORMAL          ;OK, ALL DONE

NHAM03: EXPECT AR=.PATN,BR=NOCARE,AD=NOCARE,ARX=.PATN1,BRX=NOCARE,ADX=NOCARE,MQ=.ONES,FM=NOCARE

;SEQ234


;SEQ235

.SBTTL TEST 13 (EVMA04): VMA REGISTER BINARYCOUNTER AND VVMA ADDER TESTS
.REM    %
THIS TEST HAS TWO PHASES.  THE FIRST CHECKS THE VMA REGISTER BINARY COUNTER
AND ITS ABILITY TO INCREMENT BY ONE AND DECREMENT BY ONE.  IT ATTEMPTS
TO INSURE THAT EACH BIT OF THE VMA REGISTER CAN "CARRY" INTO THENEXT BIT (VMA INC)
AND ALSO CAN "BORROW" FROM THE NEXT HIGHER ORDER BIT (VMA DEC). ALSO, THAT THE
CARRY FROM EACH 4-BIT CHIP IS CONNECTED AND OPERATING CORRECTLY.  IT EXTENDS
AN ALL ONES PATTERN ACROSS THE VMA TO BE SURE THAT A CARRY INTO A "NEXT
HIGHER" BIT ONLY CARRIES ONE BITS WORTH (I.E. THAT THE CARRY LINES INTERNAL
TO THE CHIP ARE NOT SHORTED)
PHASE TWO
THE SECOND PHASE OF THE TEST USES PATTERNS OUT OF THE PC AND THE
C-RAM NUMBER FIELD TO INSURE THAT THE VMA ADDER ALUS
HAVE NO FAULT, EITHER INTERNAL OR EXTERNAL TO THE CHIP.
%
EVMA04: CLRWRD                  ;CLEAR 36-BIT BUFFER
        .WORD   PATN            ;AT "PATN"
        MOV     #COLO13,R4      ;POINT TO EXPECTED
        MOV     #MIC4VMA,R0     ;STARTING MICRO CODE ADDRESS
        WWADR                   ;WRITE ADDRESS TO C-RAM
        ECLOK                   ;AND FIRST WORD TO CONTROL REGISTER
;SUBTESTS 1-23
COLO1:  $ROLWD  PATN            ;36 BITS ONE TO THE LEFT
        BISB    #1,PATN         ;SET LOW ORDER BIT TO ONE(IE, SHIFT IN A 1)
        BICB    #377,PATN+3     ;CLEAR "-EBOX CACHE" & "-EBOX MAY BE PAGED"
        $MOVWD  PATN,PATN1      ;COPY INTO PATN1
        INCWRD                  ;ADD ONE TO 36 BITS OF PATN1
        BICB    #200,PATN1+2    ;NO ADDITION INTO SECTION BIT 12
        INSYNC                  ;COUNT YOUR SUBTESTS
        $ARLO2  PATN            ;DATA ACROSS EBUS
        EBURST  5               ;EXECUTE THE TEST MICRO-CODE
        MOVB    #11,PATN+3      ;EXPECT "-EBOX CACHE H(BIT11)","VMA EXTENDED(BIT8)"
        BISB    #200,PATN+2     ;EXPECT "-EBOX MAY BE PAGED H(BIT12)"
        JSR     PC,EDPTST       ;TEST RESULTS
        BCC     COLO2           ;BR IF A-OK
        JSR     PC,FAULT        ;BR IF ERR
        .WORD   0               ;DETECTED
COLO2:  SUB     #10,R4  ;RESET TO THE CORRECT EXPECTED POINTER
        CMP     #^D23,R5        ;DONE ALL 23 ADDRESS BITS YET?
        BGT     COLO1           ;BR IF NOT YET


;SEQ236

.REM    %
THIS SECTION OF THE TEST CHECKS THE VMA-ADDR ALUS ON
VMA BOARD.  FIRST, A TEST PATTERN IS PLACED
IN THE PC REGISTER AND SECONDLY, A TEST PATTERN IS PLACED
IN THE C-RAM NUMBER FIELD.  THE OUTPUT OF THE VMA ADDER
IS THEN CLOCKED INTO THE VMA ITSELF AND VERIFIED TO BE
CORRECT, THIS TEST IS RUN AT BURST SPEED. SUBROUTINE
VMALUGO ASSUMES THAT DATA TO BE LOADED INTO THE PC
IS LOCATED IN BUFFER EWORD1..EXPECTED RESULT IS LOCATED IN
BUFFER PATN1..DESIRED VALUE FOR MICRO WORD NUMBER FIELD
IS POINTED TO BY REGISTER R4.

%
;SUBTESTS 24-41 PASS1, 42-59/PASS2
        $CLRWD  ;CLEAR 36-BIT BUFFER EWORD1
        CLR     PASS2           ;CLEAR A "WHICH PASS" FLAG
        MOV     #COLO10,R4      ;GET POINTER TO MAGIC NUMBER DATA
        MOV     #M4.2VMA,R0     ;MICRO-CODE "VMA ADDER GO" ADDRESS
.REM    %
GO TO ROUTINE WHICH READS CONTENTS OF RAM WORD SUPPLIED IN R0
AND MOVES THAT RAM WORD TO CORE VBUDFFER $MICRO. ONCE IN $MICRO, THE MAGIC
NUMBER FIELD OF THE WORD IS FILLED IN, AND IF NECESSARY, THE VMA AND
COND FIELDS OF THE RAM WORD ARE FILLED I.
%
        GETMIC          
        $VMA    2               ;SET "VMA/PC+1"
;EXTEND ONES ACROSS PC FOR THE VMA ADDER TEST
COLO3:  $ROLWD                  ;ROTATE LEFT THE BUFFER EWORD1
        BISB    #1,EWORD1
        $MOVWD  EWORD1,PATN1    ;SEND EXPECTED TO BUFFER PATN1
        INCWRD                  ;ADD A ONE TO DAA AT PATN1 TO CREATE EXPECTED


;SEQ237

.REM    %
ROUTINE "VMALUGO" IS A SUBROUTINE WHICH ACTUALLY EXECUTES THE TEST
OF THE VMA ALU ADDER.. THE ROUTINE LOADS THE DATA DESDTINED FOR THE PC
INTO THE AR..IT WRITES THE CONTENTS OF THE BUFFER $MICRO TO THE LOCATION
IN THE RAM FROM WHICH IT CAME.  IT GIVES THE KL10 A BURST OF CLOCKS TO
ACTUALLY EXECUTE THE TEST AND FINALLY CHECKS THE VMA RESULTANT DATA
TO INSURE THAT THE HARDWARE WORKED AND DID THE RIGHT THING
IF THE TEST PASSES, PROGRAM FLOW RETURNS MAINLINE.  IF IT FAILS THE
SUBROUTINE ITSELF GOES OFF TO REPORT THE ERROR
%
        JSR     PC,VMALUGO
        BITB    #2,EWORD1+2     ;ONE FLOATED ALL THE WAY DOWN PC??
        BEQ     COLO3           ;BR BACK IF NOT YET
        TST     PASS2           ;TIME TO FLOAT MAGIC NUMBER INSTEAD OF PC???
        BNE     COLO4           ;BR IF YES
        $CLRWD                  ;OTHERWISE, CLEAR EWORD1 TO START AGAIN
        INC     PASS2           ;SET THE PASS2 FLAG
        TST     (R4)+           ;ADD TWO TO R4
        BR      COLO3           ;SECOND PASS AT FLOATING
;SUBTESTS 60-77
COLO4:  TST     (R4)+           ;ADD TWO TO R4
        $CLRWD                  ;CLEAR 36-BIT BUFFER EWORD1
        MOV     #M4.2VMA,R0     ;MICRO-CODE ADDRESS OF CHANGINGNUMBERS
        GETMIC                  ;READ RAM WORD AND PUT IN BUFFER $MICRO
        $VMA    1               ;CHANGE "VMA/PC+1" TO NOTHING
        $COND   30              ;SET "SPEC/VMA #" IN THE RAM WORD
COLO5:  MOV     (R4),R0         ;SET EXPECTED
        MOVB    R0,PATN1                ;SET NUM BITS 01-08 IN EXPECTED DATA
        SWAB    R0
        MOVB    R0,PATN1+1      ;SET NUM BIT 00 TO EXPECTED
        JSR     PC,VMALUGO      ;EXECUTE THE TEST..RETURN IF DATA OK
        BIT     #400,(R4)+      ;DONE FLOATING ONES DOWN NUMBERS YET?
        BEQ     COLO5           ;BR IF NOT YET
        TST     PASS2           ;DONE NUMBERS TWICE??
        BEQ     COLO6           ;BR IF YES
        CLR     PASS2           ;IF NO, CLEAR FLAG & GO DO THEM AGAIN
        SUB     #22,R4          ;SET R4 TO THE BEGINNING OF FLOATING # VALUES
        $SETWD                  ;ALL ONES TO BUFFER EWORD1
        BR      COLO5           ;AND FLOAT THE NUMBERS FOR THE SECOND TIME


;SEQ238

;SUBTESTS 78-80
.REM    %
FINAL PHASE OF VMA ADDER TEST.  THIS TEST CHECKS THE
'MCL VMA INC" LINE INTO BIT 35 OF THE VMA ADDER ALU.
%

COLO6:  $CLRWD                  ;CLEAR BUFFER EWORD1
        MOVB    #2,EWORD1+1     ;SET UP A D-RAM B FIELD = 6
        CLR     R0              ;WRITE IN ADDRESS 0
        MOV     #EWORD1,R1              ;THE D-RAM DATA OF EWORD1
        WDRAM
        DFXCTT                  ;AND STROBE TEH DATA
        .WORD   DRLTCH          ;TO THE D-RAM LATCHES
        $COND   0               ;SET COND FIELD OF $MICRO TO 0
COLO7:  MOVB    (R4)+,R0        ;GET VALUE FOR MEM FIELD
        $MEM                    ;WRITE IT TO $MICRO
        MOVB    (R4)+,R0        ;GET FLAG WHICH SAYS PC=0 OR PC=1
        BEQ     COLO8           ;IF VALUE WAS 0, PC WILL BE 0
        $SETWD                  ;OTHERWISE PC VALUE WIL BE -1
        MOV     #EWORD1+5,R0    ;GET BUFFER ADDRESS
        BICB    #377,-(R0)      ;NO BITS ON EBUS 00-03
        BICB    #377,-(R0)      ;NO BITS ON EBUS 04-11
        BICB    #376,-(R0)      ;NO BITS ON EBUS 12-17
        $MOVWD  EWORD1,PATN1    ;SET EXPECTED
        BR      COLO9           ;GO TEST


;SEQ239

COLO8:  $CLRWD                  ;PC=0
        $CLRWD  PATN1           ;EXPECT ZEROES BACK
        TSTB    -2(R4)          ;WAS THERE A MEM FIELD VALUE??
        BEQ     COLO9           ;IF NOT GO TEST
        INCB    PATN1           ;IF YES, TESTING ":MCL VMA INC: SO EXPECT +1
COLO9:  JSR     PC,VMALUGO      ;GO TO TEST
        TST     (R4)+           ;ADD 2 TO REG4
        CMP     #^D75,R5        ;DONE ALL TESTS??
        BGT     COLO7           ;BACK IF NOT
        JMP     NORMAL          ;OUT IF YES
VMAM18: WD36 7777,7700,0000     ;18 BIT MASK
.EVEN


;SEQ240

VMALUGO:        MOV     (R4),R0         ;GET MGIC NUMBER
        $NUM                    ;AND WRITE TO BUFFER $MICRO
;NOW WRITE C-RAM WORD BACK INTO THE C-RAM
        MOV     #M4.2VMA,R0
        MOV     #$MICRO,R1
        WCRAM   
        INSYNC                  ;COUNT SUBTESTS
        MOV     #M4.1VMA,R0     ;GET TEST RAM CODE START ADDRESS
        WWADR                   ;WRITE THE START ADDRESS
        M.RESPSIM               ;SET MBOX RESP SIM
        ECLOK                   ;FIRST WORD TO C.R.
        $ARLO2  EWORD1          ;PC DATA TO EBOX
        EBURST  3               ;AND EXECUTE THE TESTS
        DFVMA                   ;READ THE CONTENTS OF THE VMA
        MOV     R0,1$           ;SET POINTER TO ACTUAL
        M36T                    ;36 BIT COMPARE
        .WORD   VMAM18          ;ONLY WE'LL COMPARE 18 BITS
        .WORD   PATN1           ;POINT TO EXPECTED
1$:     .WORD   0               ;POINT TO ACTUAL
        BCC     2$              ;BR AND CONTINUE IF TEST IS OK
        JSR     PC,FAULT
        .WORD   0               ;NO ERROR MESSAGE
2$:     RTS     PC              ;AND BACK TO MAINLINE


;SEQ241

;EXPECTED DATA FOR SUBTESTS 1-23

COLO13: EXPECT  AR=.PATN1,BR=NOCARE,AD=NOCARE,ARX=.PATN,BRX=NOCARE,ADX=NOCARE,MQ=NOCARE,FM=NOCARE
COLO10: .WORD   777             ;NUMBERS FIELD ST 24-41
        
        .WORD   0               ;DITTO.NUMBERS SUBTEST 42-59

        .WORD   1               ;ST 60,69
        .WORD   2               ;ST 61,70
        .WORD   4               ;ST 62,71
        .WORD   10              ;ST 63,72
        .WORD   20              ;ST 64,73
        .WORD   40              ;ST 65,74
        .WORD   100             ;ST 66,75
        .WORD   200             ;ST 67, 68
        .WORD   400             ;ST 63,77

;ST 78
        .BYTE   0               ;MEM FIELD
        .BYTE   -1              ;PC=1
        .WORD   0               ;NUMBERS

;ST 79
        .BYTE   0               ;MEM FIELD
        .BYTE   0               ;PC=0
        .WORD   777             ;NUMBERS

;ST 80
        .BYTE   6               ;MEM FIELD
        .BYTE   0               ;PC=0
        .WORD   200             ;NUMBERS
        .EVEN


;SEQ242

.SBTTL TEST 14 (EVMA05): VMA AC REF & VMA SECTION 0

.REM    %
THIS TEST VERIFYS THE CORRECT OPERATION OF THE "VMA AC REF" LOGIC
AND "VMA SECTION 0" GATE.  IT DOES THIS BY SETTING UP 10 PATTERNS
WHICH DRIVE THE "VMA AC REF" LOGIC.  THE PATTERN SET UP IS COMPLETELY
MICRO-CODED AND IS MERELY DRIVEN BY THE ELEVEN WHICH SELECTS THE
CORRECT MICRO-STARTING ADDRESS AND DATA PATTERN FOR THE VMA SECTION
  VMA   *   PAGE        *   VMA *   VMA *     VMA       *  VMA ***   EXPECT
18-31=0 *UEBR REF       * FETCH  *RD^WRT  *  EXTENDED   * 13-17 *** VMA AC REF
        
  1             0               0       1               1       0       *       T ST 1
  0             0               0       1               1       0       *       F ST 2
  1             1               0               1       1       0       *       F ST 3
  1             0               0       0               1       0       *       F ST 4
  1             0               0       1               0       37      *       T ST 5
  1             0               1       1               1       37      *       T ST 6
  1             0               0       1               1       20      *       F ST 7
  1             0               0       1               1       10      *       F ST 8
  1             0               0       1               1       4       *       F ST 9
  1             0               0       1               1       2       *       F ST 10
        
  1             0               0       1               1       1       *       T ST 11
%
EVMA05: MOV     #ILLI05,R3      ;GET POINT TO C-RAM ADDRESS & CLOCK COUNTS
        MOV     #ILLI06,R4      ;GET PONT TO EXPECTED DATA
        MOV     #200,ILLI04     ;SET INITIAL VMA SECTION VALUE FOR SUBTESTS 6-10

        MOV     #MIC5VMA,R0     ;START ADDRESS OF MICRO-CODE TO
        WWADR                   ;LOAD BR WITH BIT08
        ECLOK                   ;FIRST RAM WORD TO C.R.
        $ARLO2  ILLI07          ;36 BITS WITH ONLY BIT08 SET INTO AR
        ECLOK                   ;BIT08 JUST WENT INTO THE BR


;SEQ243

ILLI01: INSYNC                  ;COUNT SUBTESTS
        CLR     R0              ;GET THE CRAM START ADDRESS
        BISB    (R3)+,R0        ;FOR THIS SUBTEST INTO R0.
        WWADR                   ;WRITE ADDRESS AND RESET THE KL10
        M.RESPSIM               ;SET "MBOX RESP SIM"
        ECLOK                   ;FIRST WORD TO CONTROL REGISTER
        CLR     R0              ;GET NUMBER OF CLOCKS NEEDED TO
        BISB    (R3)+,R0        ;SET THE CONDITIONS FOR THIS TEST
        BURST
        JSR     PC,TVMA05       ;GO TEST "VMA AC REF" SIGNAL
        CMP     R5,#4           ;DONE SUBTEST 4 YET??
        BLT     ILLI01          ;BR IF NO
        $CLRWD                  ;CLEAR 36 BIT BUFFER


;SEQ244

;ON TO SUBTEST 5-11
ILLI4:  MOVB    #10,EWORD1+3    ;SET BIT 8 IN 36-BIT DATA
        MOVB    #174,EWORD1+2   ;SET A VALUE FOR VMA(13-17)
        CLR     R0              ;GET C-RAM ADDRESS FOR THIS SUBTEST
        BISB    (R3)+,R0        ;AND WRITE IT TO DIAG FOR REG
        WWADR                   ;AND RESET THE KL10
        ECLOK                   ;RAM WORD TO C.R.
                
        M.RESPSIM               ;SET "MBOX RESP SIM"
        CMP     R5,#5           ;IS SUBTEST 6 NEXT..
        BNE     ILLI02          ;BR IF NOT
        CLRB    EWORD1+3                ;EXECUTED ONLY AT SUBTEST 5

ILLI02: 
        BICB    #200,EWORD1+2
        $ARLO2  EWORD1          ;36 BITS TO AR
        INSYNC                  ;NEXT SUBTEST
        MOVB    (R3)+,R0        ;CLOCK COUNT TO R0
        BURST                   ;EXECUTE
        JSR     PC,TVMA05       ;CHECK RESULTS
        CMP     #5,R5           ;SUBTEST 5??
        BEQ     ILLI4           ;BR IF YES,,ALL ELSE FALL THRU
        CMP     R5,#6
        BNE     ILLI03          ;BR ALWAYS EXCEPT TEST 6

        TSTB    (R3)+           ;ADD 2 TO R3, THIS SETS UP CLK COUNT FOR ST6-10
ILLI03: 
        CLR     R0              ;GET C-RAM ADDRESS FOR THIS SUBTEST
        BISB    #VMAS7,R0       ;AND WRITE IT TO DIAG FOR REG
        WWADR                   ;AND RESET THE KL10
        ECLOK                   ;RAM WORD TO C.R.
        ECLOK
        M.RESPSIM               ;SET "MBOX RESP SIM"
        CLC                     ;CLR 'C" BIT
        RORB    ILLI04          ;SO YOU CAN SLIDE A ONE ACROSS THE VMA SECTION
        MOVB    ILLI04,EWORD1+2 
        TSTB    -(R3)           ;RESET BACK TOD ESIRED CLOCK COUNT
        CMP     R5,#^D10        ;BY THE WAY, DONE ALL TESTS??
        BLT     ILLI02          ;DO ANOTHER TEST
        JMP     NORMAL          ;NOW DONE

TVMA05: MOVB    (R4)+,ILLIXP    ;SET THE EXPECTED INTO CORE
        DCOMP                   ;DO BYTE TABLE COMPARE
        .WORD   ILLIMK           ;MASK TABLE AT ILLIMK
        .WORD   ILLIDF          ;DIAG FUNCT TABLE AT ILLIDF
        .WORD   ILLIBT          ;BYTE TABLE AT ILLIBT
        .WORD   ILLIXP          ;EXPECTED TABLE AT ILLIXP
        .WORD   0               ;ERROR MSG FROM THE ISOLATION ROUTINE
        RTS     PC


;SEQ245

;       MICRO START     NUM
        
;       LOCATIONS       TICS
ILLI04: .WORD   0               ;WORD FOR FLOATING A 1 DOWN VMA SECTION
ILLI05: .BYTE   VMAS1,  6       ;SUBTEST 1
        .BYTE   VMAS2,  10      ;SUBTEST 2
        .BYTE   VMAS3,  6       ;SUBTEST 3
        .BYTE   VMAS4,  4       ;SUBTEST 4
        .BYTE   VMAS5,  4       ;SUBTEST 5
        .BYTE   VMASF,  4       ;SUBTEST 6
        .BYTE   6               ;AND CLOCK COUNT SUBTEST 6-11
;EXPECT "VMA AC REF"
ILLI06: .BYTE   0               ;ST 1-TRUE
        .BYTE   1               ;ST 2-FALSE

        .BYTE   1               ;ST 3-FALSE
        .BYTE   1               ;ST 4-FALSE
        .BYTE   0               ;ST 5-TRUE
        .BYTE   0               ;ST 6-TRUE
        .BYTE   1               ;ST 7-FALSE
        .BYTE   1               ;ST 8-FALSE
        .BYTE   1               ;ST 9-FALSE
        .BYTE   1               ;ST 10-FALSE
        .BYTE   0               ;ST 11-TRUE

ILLI07: WD36    0010,0,0
        .EVEN

;DCOMP TABLES FOR THE COMPARESOF "VMA AC REF"
ILLIMK: .BYTE   376             ;ONLY LOOK AT BIT 13
        
ILLIDF: .BYTE   RVMA+7!BIT7     ;DIAG FUNCTION 157
ILLIBT: BYTPNT  13              ;READ EBUS 6-13
ILLIXP: .BYTE   0               ;PUT EXPECTED DATA HERE


;SEQ246
.SBTTL TEST 15 (EVMA06):  PREVIOUS SECTION REG, ARMM MUX, & VMA IN MUX

.REM    %
TIS THE PURPOSE OF THIS TEST TO CHECK THE INTERFERENCE THROUGH
AND THE SELECTABILITY OF THE ARMM MUX.  IF ALSO COMPLETELY
TESTS THE PREVIOUS SECTION REGISTER AND THE SELECT ABILITY OF THE
"VMA IN" MUX.  THE BASIC TEST SEQUENCE IS THIS:  1) LOAD TEST PATTERN
TO PREVIOUS SECTION REGISTER.  2) PREV SEC REGISTER THRU ARMM TO AR
3) PREV SEC THRU "VMA IN" TO THE VMA.  STOP AND VERIFY AR AND VMA
AND VERIFY THE VMA CONTENTS.  WE CONTINUE THIS LOOP TO FLOAT
A ONE DOWN THE PREVIOUS SECTION REGISTER-FINALLY, WE LOAD THE PREV
SEC ALL ONES, THEN READ THE PC OF ALL ZEROES THRU THE ARMM INTO
THE AR, TO VERIFY THE ARMM SELECT ABILITY.
%
EVMA06: MOV     #ARIZ06,R4      ;GET POINTER TO TEST DATA
        $ACSET  4               ;SET "APR AC 10"TOP SET UP PXCT COND
        MOV     #177603,R3      ;PUT A 16-BIT MASK IN R3
        MOV     #MIC6VMA,R0     ;GET MICRO-CODE START ADDRESS
        WWADR                   ;RESET KL10 AND SET START ADDRESS
        DFXCTT                  ;INITIAL MICRO-INSTRUCTION TO C.R.
        SECLK



;SEQ247

ARIZ01: INSYNC                  ;COUNT SUBTESTS
        MOV     (R4),EWORD1+2   ;SET TEST DATA IN 36-BIT BUFFER
        $ARLO2  EWORD1          ;36 BIT DATA TO AR
        MOV     #^D25,R0        ;THIS MANY CLOCKS
        BURST
        MOV     #EWORD1,R1      ;WHERE T O PUT 36-BIT ACTUAL
        MOV     #DPBR,R0        ;FUNCTION TO READ THE AR
        DFRDMV
        DFVMA           ;NOW READ VMA
        MOVB    2(R0),EWORD1    ;PUT ACTUAL IN LOW ORDER 16-BITS OF 36-BIT BUFFER
        MOV     #EWORD1,R2      ;PUT POINTER TO ACTUAL IN REGISTER-2
        BIC     R3,(R2)+
        BIC     R3,(R2)+
        CMP     (R4),-(R2)      ;TEST THE AR 13-17 DATA
        BEQ     1$              ;DATA OK
        ERRMSG<\VMA PREV SECT THRU ARMM>
        BR      ARIZ02          ;BR IF BAD
1$:     CMP     (R4),-(R2)      ;TEST VMA 13-17 DATA
        BEQ     11$             ;DATA OK
        ERRMSG<\VMA FROM VMA IN MUX>
        BR      ARIZ02          ;BR IF BAD
;FINAL DATA CHECK IS TO READ "VMA PREV SEC" VIA DIAGNOSTIC MUXS
;       ALSO TO CHECK THE "PCS SECTION 0" SIGNAL AS PRODUCED ON THE VMA
;BOARD, ANY ERROR DETECTE IN THIS SECTION OF THE TEST REPORTS
;ERRORS WITH THE DATA FORMAT AS FOLLOWS
;*              *               * PREV  * PREV  * PREV  * PREV  * PREV  *
;* MASKED BITS *-PCS SECTION 0* SEC 13* SEC 14* SEC 15* SEC 16* SEC 17*
11$:    MOV     R5,R0           ;COPY SUBTEST NUMBER TO WORK REG
        ASR     R0              ;DIVIDE BY 2 TO MAKE AN INDEX VALUE
        MOVB    ARIZ07(R0),-(SP)        ;& PUT EXPECTED ON TOP OF STACK
        JSR     PC,RDPSEC               ;NO READ PREV SEC REGISTER VAALUE
        CMP     (SP),R0 ;SEE IF DATA OK
        BNE     12$             ;BR IF DATA CHECKS OK
        POP     R0              ;NOW FIX THE STACK
        BR      2$              ;AND CONTINUE


;IF FALL TO HERE, WHAVE ERROR AND MUST REPORT IT
12$:    MOV     (SP)+,(R4)              ;PASS EXPECTED DATA TO SPECIAL ROUTINE


;SEQ248

        MOV     #177700,R3      ;PASS MASK TO SPECIAL ROUTINE
        MOV     R0,(R2)         ;PASS ACTUAL RECEIVED TO ROUTINE
        ERRMSG<PREV SECTION READ OR PCS SECTION 0 SIGNAL FAILS>
        BR      ARIZ02          ;AND GO TO THE FAULT CALL


;SEQ249

;ALL EVEN SUBTESTS CHECK THE CLEAR ABILITY OF THE VMA SECTION
;IF EHRE DATA IS OK.  NOW CLEAR VMA SECTION BY EXECUTING FINAL
;MICRO-INSTRUCTION FOR THIS TEST
2$:     INSYNC                  ;COIUNT SUBTESTS
        ECLOK                   ;EXECUTE RAM WORD TO CLEAR VMA SECTION
        DFVMA                   ;READ THE RESULTS
        CLR     R2              ;CLEAR A REG TO HOLD SECTION DATA IN
        BISB    2(R0),R2        ;SET ACTUAL SECTION DATA IN R2
        MOVB    R2,EWORD1               ;SET ACTUAL TO CORE FOR  ERROR REPORT
        BICB    #203,R2         ;MASK ONON SECTION BITS
        CMPB    ZERO,R2         ;CHECK RESULTANT DATA
        BEQ     ARIZ03          ;BR IF VMA SECTION CLEARED AND DATA OK.

;THE FOLLOWING SECTION IS FOR REPORTING ERRORS AT ONE OF
;THE TWO TESTS POINTS WHERE WE VERIFY THE CORRECT OPERATION
;OF THE VMA BOARD
        
        MOV     #ZERO,R4        ;SET EXPECTED FOR VMA CLEAR TEST
        MOV     #EWORD1,R2      ;POINTER TO A CTUAL GOES INTO R2
        ERRMSG<\VMA SECTION DID NOT CLEAR>

ARIZ02: JSR     PC,ERS16D               ;GO TO ROUTINE WHICH STACKS 16-BIT ERRORS
        JSR     PC,FAULT                ;REPORT ERROR
        .WORD   0               ;NO ERROR MESSAGE
ARIZ03: TST     (R4)+           ;UPDATE TEST DATA PNTR
        CMP     #^D12,R5                ;READ Y FOR FINAL AMM SELECT TEST?
        BGT     ARIZ01          ;CONTINUE IF NOT YET
        BLT     ARIZ04          ;BR IF IN ARMM SELECT TEST

;FALL TO HERE ONLY AT THE END OF SUBTEST 12
        MOV     #M6.1VMA!BIT15,R0       ;LOAD DIAG ADDR REG WITH NO RESET
        WWADR
        BR      ARIZ01          ;SET UP SUBTEST 13 & 14


;SEQ250

;THIS IS SUBTEST 15
ARIZ04: INSYNC                  ;COUNT SUBTESTS
        ECLOK                   ;EXECUTE ARMM SELECT TEST, SUBTEST 6
        MOV     #EWORD1,R1      ;WILL PUT CONTENTS OF AR A1 THIS 36-BIT BUFFER
        MOV     #DPAR,R0                ;FUNCTION TO READ AR
        DFRDMV                  ;DO IT
        BIC     R3,EWORD1+2      ;CLEAR ANY DON'T CARE BITS
        MOV     #ZERO,R4        ;POINTER T EXPECTED GOES IN R4
        CMP     (R4),EWORD1+2   ;DATA OK?
        BEQ     ARIZ05          ;OUT OIF OK
        MOV     #EWORD1+2,R2    ;POINTER TO ACTUAL RECEIVED
        BR      ARIZ02          ;REPORT ERROR
ARIZ05: JMP     NORMAL          ;OK, END

;LIST OF TEST PATTERNS FOR VMA6, PREV SECT REG, AND ARMM MIXER

ARIZ06: .WORD   1*4             ;SUBTEST 1
        .WORD   2*4             ;SUBTEST 3
        .WORD   4*4             ;SUBTEST 5
        .WORD   10*4            ;SUBTEST 7
        .WORD   20*4            ;SUBTEST 9
        .WORD   0               ;SUBTEST 11
        .WORD   37*4            ;SET UP FOR SUBTEST 13

;EXPECTED DATA FOR PREV SEC AND PCS SECTION 0
ARIZ07: .BYTE   41              ;SUBTEST 1
        .BYTE   42              ;SUBTEST 3
        .BYTE   44              ;SUBTEST 5
        .BYTE   50              ;SUBTEST 7
        .BYTE   60              ;SUBTEST 9
        .BYTE   00              ;SUBTEST 11
        .BYTE   77              ;SUBTEST 13
.EVEN


;SEQ251

.SBTTL TEST 16  (EVMA08):  RANDOM SIGNALS FROM VMA LOCAL,LOCAL AC ADDR, & AC REF

;FIVE SUBTESTS DESIGNED TO PICK UP SIGNALS AND GATRES LEFT UNTESTED BY
;PREVIOUS TESTS.  BASIC TEST ALGORITHM IS:
;LOAD THE AR WITH A 36-BIT STIMULUS PATTERN
;LOAD THAT 36-BIT DATA TO THE VMA
;INCREMENT THE VMA(FOR THE PURPOSE OF SETTING "VMA 12" WHERE NECESSARY)
        
;SET "VMA READ"
;SET "MCL VMA EXTENDED" AS DESIRED
;READ THE STATE OF THE VMA BOARD
;EACH 36-BIT STIMULUS DATUM IS FOLLOWED BY A SHORT DESCRIPTION
;OF WHICH GATE IN PARTICULAR IS BEING TESTED, AND WHICH SIGNAL IS IN
;A STATE PREVIOUSLY UNTESTED.

EVMA08: 
        MOV     #MAINE3,R2      ;GET PNTR TO MCOMP NUMBER OF CHANGES TABLE
        MOV     #MAINE4,R3      ;GET PNTR TO MCOMP ACTUAL CHANGES DATA
        MOV     #MAINE2,R4      ;GET PNTR TO 36-BIT STIMULUS DATA

MAINE1: MOV     #MIC8VMA,R0     ;MICRO-CODE START ADRESS
        WWADR                   ;TO DIAG ADDRESS REG.. ALSO RESET KL10
        ECLOK                   ;FIRST WORD TO C.R.
        INSYNC                  ;COIUNT SUBTESTS
        MOV     R4,R0           ;PNTR TO 36-BIT DATA INTO REG R0
        ARLOD2          ;DATA TO AR REGISTER IN KL10

        EBURST  3               ;BURST THE EBOX CLOCK TO EXECUTE MICRO-CODE

;NOW FOR EXPECTED DATA COMPARE CODE
        MCOMP                   ;FIRST CHANGE EXPECTED DATA
        DCOMP                   ;AND THEN GO COMPARE VS. ACTUAL
        .WORD   NEB01           ;PNTR TO MASK TABLE
        .WORD   NEB02           ;PNTR TO DIAG FUNCTIONS
        .WORD   NEB03           ;PNTR TO BYTE POINTERS
        .WORD   NEB04           ;PNTR TO EXPECTED BYTES
        .WORD   0               ;AND NO ERROR MESSAGE FROM HERE

        RCOMP                   ;IF RETURN OK, FIX MASTER TABLES
        ADD     #5,R4           ;UPDATE TO NEXT 36-BIT STIMULI
        CMP     #^D5,R5         ;SEE IF DONE ALL YET
        BGT     MAINE1          ;BR BACK IF NOT YET.
        JMP     NORMAL          ;ELSE JUMP NRMAL



;SEQ252

;LIST OF 36-BIT STIMULUS DATA
MAINE2:
        WD36    0000,3700,0360  ;ST 1-"LOCAL AC ADDR"("-MISC=0")
        WD36    0000,3717,7400  ;ST 2-"LOCAL AC ADDR"("-20-27=0")
        WD36    4000,3700,0000  ;ST 3-"AC REF"("-LOCAL")
        WD36    0000,3777,7777  ;ST 4-"MISC=0"("VMA 12 TRUE")
        WD36    0040,4000,0000  ;ST 5-"MISC=0"("MCL ADR ERR TRUE")

;MCOMP NUMBER OF CHANGES TABLE
MAINE3:
        .BYTE   1               ;SUBTEST 1
        .BYTE   0               ;ST 2
        .BYTE   2               ;ST 3
        .BYTE   2               ;ST 4
        .BYTE   2               ;ST 5

;MCOMP ACTUAL CHANGES TABLE
MAINE4:
        .BYTE   0               ;SUBTEST 1
        .BYTE   24              ;"-MISC=0"

        .BYTE   0               ;SUBTEST 3
        .BYTE   0               ;"-MISC=0","LOCAL AC ADDR"
        .BYTE   1
        .BYTE   4               ;"AC REF"

        .BYTE   0               ;SUBTEST 4
        .BYTE   24              ;"-MISC=0"
        .BYTE   1
        .BYTE   20              ;"VMA 13-35 MATCH"

        .BYTE   0               ;SUBTEST 5
        .BYTE   24              ;"-MISC=0"
        .BYTE   1
        .BYTE   24              ;"-VMA 13-35 MATCH"

.EVEN


;SEQ253

.SBTTL *ECONB* CONTROL LOGIC TESTS PART 2

.SBTTL TEST 17 (EMCL4): PAGE ILLEGAL ENTRY LOGIC

EMCL4:  PMSG    <STARTING CONTROL LOGIC TESTS\> ;PRINT TRACE.

.REM    %
THIS TESTS THE "PAGE ADDRESS COND" / "PAGE ILL ENTRY" LOGIC ON MCL3.  IT USES
THE VMA & ADR BRK REGISTERS ON THE VMA BOARD, THE "COMP" REGISTER ON ARP3.
AND THE LOGIC USED TO LOAD THEM.
%
;INITIALIZE:

        MOV     #EWORD1+2,R1    ;R1 POINTS INTO 36-BIT BUFFER.
        MOV     #PIANO,R2       ;R2 POINTS TO MCOMP'S # TABLE.
        MOV     #CELLO,R3       ;R3 POINTS TO MCOMP'S BYTE TABLE.
        MOV     #VIOLIN,R4              ;R4 POINTS TO STIMULUS TABLE.

;START MAIN LOOP:

DRUMS:  INSYNC                  ;NEW SUBTEST
        CMP     #^D11,SUBNR     ;DONE ALL 11?
        BGE     OBOE            ;IF NOT, CONTINUE
        JMP     NORMAL          ;DONE,R ETURN TO DISPATCHER

OBOE:   CLEAR                   ;START FRESH.
        $CLRMI                  ;BUFFERS TOO.
        $CLRWD          
        MOV     R5,-(SP)                ;SAVE SUBTEST # ON STACK.
        MOVB    (R4)+,R5        ;PUT 1ST CODED STIMULUS BYTE IN R5.


;SEQ254

;SET ADDRESS BREAK REGISTER BITS 13-20 TO FORCE :NO MATCH" AND "COMP" BITS AS REQUIRED:
        ASR     R5              ;TEST "NO MATCH" BIT.
        BCC     FLUTE           ;IS IT SET?
        BIS     #177400,R5      ;YES, SET LEFT HALT OF R5 TO 1'S.
FLUTE:  SWAB    R5              ;SWITCH HALVES OF R5.
        ASR     R5              ;SHIFT SO "COMP" BITS ARE IN PLACE,
        MOV     R5,(R1)         ;AND WRITE R5 TO BUFFER.
        STUFF                   ;WRITE BUFFER TO AR.
        $COND   20              ;DO A "DATAO APR" (COND/DIAG FUNC
        $NUM    17              ;AND # = 17).
        $XBUF0                  ;WRITE BUFFER TO CR AND CLOCK

;LOAD PUBLIC, PRIVATE INSTRUCTION & ADDRESS BREAK FLAGS AS REQUIRED:
        BIC     #163777,(R1)+   ;CEAR IRRELAVENT BITS FROM BUFFER.
        STUFF                   ;RTELOAD THE AR.
        $DISP   24              ;BRING UP "SCD LOAD FLAGS" WITH "SPEC/
        $NUM    20              ;FLAG CTL" AND CR # 04.
        $XBUF0                  ;EXECUTE THE BUFFER


;SEQ255

;SET "CON TRAP EN" TO GET "MCL EBOX PAGING EN", IF REQUIRED:

        BITB    #4,(R4)         ;SEE IF THE PAGING BIT IS SET.
        BEQ     WINDS           ;DO NOTHING IF IT'S NOT
        $CLRWD                  ;OTHERWISE, CLEAR 36-BIT BUFFER
        BISB    #40,EWORD1+1    ;AND SET EBUS BIT 22 IN IT.
        STUFF                   ;LOAD AR
        $COND   20              ;DO A "COPNO PAG" (COND/DIAG FUNC)
        $NUM    16              ;AND # = 16).
        $XBUF0                  ;EXECUTE IT TO SET TRAP EN

;USE "MEM/AD FUNC" WITH THE APPROPRIATE AD BITS TO CONTROL "VMA
;READ,WRITE,USER AND FETCH", "EBOX PAGING EN" AND "MAP OR REG FUNC".
;THE VMA SEL FIELD IS SET TO CAUSE "LOAD VMA CONTEXT" AND TO LOAD THE
;VMA TO CONTROL THE MATCH/NO MATCH CONDITION.  THE SECOND SET-UP BYTE
;CONTAINS THE INFORMATION FOR THESE SIGNALS.

WINDS:  MOVB    (R4)+,R5        ;GET NEXT SET UP BYTE
        $CLRWD                  ;ZERO THE 36-BIT BUFFER
        ASLB    R5              ;TEST VMA READ BIT.
        BCC     HARP            ;IS IT SET?
        MOVB    #4,(R1)         ;YES, SET EBUS BIT 1 (LOAD AR--GIVES VMA READ) IN BUFFER

HARP:   MOVB    R5,-(R1)        ;PUT REST OF VMA BITS INTO BUFFER.      
        BICB    #51,(R1)        ;CLEAR ALL BUT EBUS BITS 4,5,7,9 & 10.
        DEC     R1              ;ADJUST PTR FOR NEXT SUBTEST
        STUFF                   ;LOAD THE AR FROM THE BUFFER
        $MEM    10              ;SET "MEM/AD FUNC"
        $VMA    3               ;SET BOTH VMA SELECT BITS.
        $XBUF                   ;EXECUTE BUFFER
        MOV     (SP)+,R5        ;RESTORE SUBTEST # TO R5
        CTLMCR                  ;COMPARE.
        BR      DRUMS           ;AND GO BACK FOR MORE.


;SEQ256

.REM    %
HERE IS THE STIMULUS TABLE.  BYTES HAVE THE FOLLOWING MEANINGS:

BIT #   BYTE #1                         BYTE #2

  0     PREVENT VMA MATCH 13-35         SET MAP OR REG FUNC
  1     SET USER COMP                   SET VMA FETCH
  2     SET WRITE COMP                  SET EBOX PAGING EN
  3     SET READ COMP                     1 (ALWAYS SET VMA PREVIOUS
  4     SET FETCH COMP                    0
  5     SET ADR BRK FLAG                        SET VMA USER
  6     SET PUBLIC (CLR PRI INSTR)      SET VMA WRITE
  7             0                       SET LOAD AR FOR VMA READ

%
VIOLIN: .BYTE   110             ;SUBTEST #1:  READ COMP & PUBLIC
        .BYTE   210             ;VMA READ
        .BYTE  10              ;SUBTEST #2:  READ COMP
        .BYTE   312             ;VMA READ, WRITE & FETCH
        .BYTE   6               ;SUBTEST #3:  WRITE & USER COMP
        .BYTE   154             ;VMA WRITE & USER & PAGING ENABLE
        .BYTE   14              ;SUBTEST #4:  READ & WRITE COMP
        .BYTE   10
        .BYTE   110             ;SUBTEST #5:  READ COMP & PUBLIC
        .BYTE  211             ;VMA READ & MAP OR REG FUNC
        .BYTE   11              ;SUBTEST #6:  READ 7 NO MATCH
        .BYTE   210             ;VMA READ
        .BYTE   10              ;SUBTEST #7:  EAD COMP
        .BYTE   250             ;VMA READ & USER
        .BYTE   12              ;SUBTEST #8:  READ & USER COMP
        .BYTE   210             ;VMA READ
        .BYTE   20              ;SUBTEST  #9:  FETCH COMP
        .BYTE   12              ;VMA READ
        .BYTE   0               ;SUBTEST #10:
        .BYTE   210             ;VMA READ
        .BYTE   50              ;SUBTEST #11:  READ COMP & ADR BRK
        .BYTE   210             ;VMA READ


;SEQ257

;HERE ARE THE MCOMP TAB;LES FOR THIS TEST:

PIANO:  .BYTE   2               ;SUBTEST #1:  CHANGE 2 BYTES
        .BYTE   4               ;2B
        .BYTE   7               ;3B
        .BYTE   3               ;4
        .BYTE   3               ;5B
        .BYTE   0               ;6
        .BYTE   1               ;7
        .BYTE   1               ;8
        .BYTE   5               ;9B
        .BYTE   1               ;10
        .BYTE   1               ;11

CELLO:  .BYTE   25              
        .BYTE   40              ;SUBTEST #1:  "VMA HELD OR PC 07" (FROM PUBLIC)
        .BYTE   31
        .BYTE   55              ;"MCL PAGE ADDESS COND"

        .BYTE   16
        .BYTE   70              ;SUBTEST #2:  "-CON LOAD IR"
        .BYTE   30
        .BYTE   41              ;"MCL VMA WRITE"
        .BYTE   32              
        .BYTE   44              ;"MCL LOAD AR" (FROM FETCH EN)
        .BYTE   33
        .BYTE   57              ;"MCL VMA FETCH"

        .BYTE   5               
        .BYTE   6               ;SUBTEST #3:  APR READ COMP" (FALSE) &"APR WRITE & USER
        .BYTE   15
        .BYTE   4               ;"CON TRAP EN"
        .BYTE   26              ;
        .BYTE   3               ;"MCL VMA READ" (FALSE)
        .BYTE   30              
        .BYTE   61              ;"MCL VMA WRITE & USER"
        .BYTE   31
        .BYTE   14              ;"MCL PAGE ADDRESS COND" & "-MCL EBOX MAY BE PAGED"
        .BYTE   32
        .BYTE   14                      ;"MCL PAGE IOL;L ENTRY"
        .BYTE   33
        .BYTE   7               ;"-MCL STORE AR"

        .BYTE   5
        .BYTE   14              ;SUBTEST #4:  "APR WRITE COMP"
        .BYTE   26
        .BYTE   3               ;"MCL VMA READ" (FALSE)
        .BYTE   31
        .BYTE   5               ;"MCL LOAD AR" (FALSE)


;SEQ258

        .BYTE   13
        .BYTE   106             ;SUBTEST #5: "-APR EBOX READ REG" (FROM MAP)
        .BYTE   25
        .BYTE   40              ;"VMA HELD OR PC 07" (FROM PUBLIC)
        .BYTE   33
        .BYTE   46              ;"-MCL MAP OR REG FUNC"
        .BYTE   30
        .BYTE   21              ;SUBTEST #7:  "MCL VMA USER"
        .BYTE   5               
        .BYTE   12              ;SUBTERST #8:  "APR USER COMP" & RCOM,P (FALSE)
        .BYTE   5
        .BYTE   20              ;SUBTEST #9:  "APR FETCH COMP" & "APR READ COMP" (FALSE)
        .BYTE   16
        .BYTE   70              ;"-CON LOAD IR"
        .BYTE   31
        .BYTE   15              ;"MCL PAGE ADR COND"
        .BYTE   32
        .BYTE   44              ;"MCL LOAD ARX" (FROM FETCH)
        .BYTE   33
        .BYTE   57              ;"MCL VMA FETCH"
        .BYTE   5
        .BYTE   0               ;SUBTST #10:  "APR READ COMP" (FALSE)
        .BYTE   25
        .BYTE   20              ;SUBTEST #11:  "VMA HELD OR PC 08"  (FROM ADR BRK)
        .EVEN

        

;SEQ259

.SBTTL TEST18 (EFLAG3):  ARITHMETIC OVERFLOW FLAGS

.REM    %
THIS TEST CHECKS THE CARRY & OVERFLOW FLAGS ON SDCD4 WITH THE ASSOCIATED
GATES ON THE DATA PATH BOARDS.  NOTE THAT IT DEPENDS ON THE FOLLOWING
FUNCTIONS WORKING:  AD/A,AD/A+B,ADB/BR,SC/A,SC/A+B&SCADA&B/#.
%
;INITIALIZE:
        
EFLAG3: MOV     #COW,R2         ;MOCMP'S # TABLE PTR.
        MOV     #DUCK,R3                ;MCOMP'S BYTE TABLE PTR.

;NO FLAGS SET FOR AD=0.

        INSYNC                  ;SUBTEST #1.
        $AD     34,0,0          ;SET AD/0'S TO BUFFER.
        $BR     1,0             ;LOAD 0'S TO BR FOR NEXT TEST
        $COND   13              ;"COND/AD FLAGS" TO BUFFER.
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;SEE IF ANY TAKERS.

;ALSO SHOULD BE NO FLAGS SET FOR AD = NEGATIVE NUMBER:
;(AD=A+B, A HAS SIN BIT SET & B = 0)
        INSYNC                  ;SUBTEST #2.
        CLEAR                   ;JUST IN CASE ANY FLAGS GO SET BEFORE.
        MOVB    #10,EWORD1+4            ;SET SIGN BIT IN 36-BIT BUFFER
        STUFF                   ;WRITE BUFFER TO AR.
        $BR     0,0             ;BR TO HOLD 0'S
        $AD     6,0,2           ;SET AD/A+B,ADA/AR,ADB/BR IN BUFFER.
        $T      1               ;ADD S TAKE LONGER
        $XBUF                   ;WEXECUTE BUFFER
        FLGMCR                  ;NOW ANY TAKERS?


;SEQ260

;ADD AR TO AR SHIFTED LEFT TWICE TO SET AL FLAGS:

;       -2      -1      0       1       2

;AR:    1       1       1       0       0       
;AR*4:  1       0       0       0       0       

;A+B:   0       1       1       0       0               +AD CRY -02.
        INSYNC                  ;SUBTEST #3.
        CLEAR                   ;CLEAN SLATE.
        STUFF                   ;REINSTATE SIGN BIT IN AR
        $AD     6,0,3           ;SET AD/A+B,ADA/AR&ADB/AR*4.
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;THEY SHOULD BE SET NOW.
;DROP "COND/AD FLAG REPEAT:

        INSYNC                  ;SUBTEST #4.
        CLEAR                   ;GOODBYE.
        STUFF                   ;BUT BACK AR SIGN BIT.
        $COND   0               ;DROP "COND/AD FLAGS"
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;EH, SHAT'S UP DOC?

;SEQ261

;SET PI CYCLE AND REPEAT (SHOULD PREVENT "SCD SET AD FLAGS"):
        INSYNC                  ;SUBTEST #5.
        CLEAR
        STUFF                   ;RESTORE AR
        $COND   15              ;"COND/SPEC INSTR" &
        $NUM    400             ;CR #00 GIVE "SERT PI CYCLE:
        $MWORD                  ;BUFFER TO CR.
        $COND   13              ;"COND/AD FLAGS"
        $BR     1,0             ;SET BRS SIGN BIT FOR NEXT TEST
        $NUM    0               ;CLEAR CR #00
        $XBUF                   ;CLOCK PI CYCLE SET & BUFFER TO CR.
        FLGMCR  
;ADD TWO BIG NEGATIVE #'S TO CAUSE OVERFLW & CRYO:
;       -2      -1      0       1       2

;AR:    1       1       1       0       0       
;BR:    1       1       1       0       0

;A+B:   1       1       0       0       0               +AD CRY -02
        INSYNC                  ;SUBTST #6.
        CLEAR                   ;GET REID OF HANGERS-ON
        STUFF           ;AS USUAL
        $AD     6,0,2           ;SET AD/A+B,ADA/AR,ADB/BR.
        $XBUF                   ;EXECUTE BUFFER (-1 TO AR AND BR)
        ECLOK                   ;EXTRA CLOCK TO SET THE FLAGS
        FLGMCR                  ;LOOKEE SEE.


;SEQ262

;NO SCAD EEXP FLAGS FOR SC = 0:

        INSYNC                  ;SUBTEST #7.
        CLEAR                   ;OFF OLD GARBAGE
        $CLRMI                  ;CLEAR THE MICROWORD BUFFER
        $COND   7               ;"COND/REG CTL" + CR #05 =
        $NUM    10              ;"COND/AR EXP" & GIVES "SCD EXP TEST"
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;SEE WHO SETS.

;NOW BRING UP SCAD00 AND SCAD01:
        INSYNC                  ;SUBTEST #8.
        CLEAR                   ;CLEAR THE DECKS
        $NUM    410             ;BRING UP CR #00.
        $SCAD   0,3,0   ;SET SCAD/A & SCAD = 0
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;SEE HOW THEY RUN.

;SEQ263

;SAME BUT WITH PI CYCLE SET (SHOULD BREAK "SCD EXP TEST"):

        INSYNC                  ;SUBTEST #9.
        CLEAR                   ;RESET FLAGS

        $COND   15              ;BRING UP "COND/SPEC INSTR".
        $MWORD                  ;WRITE TO BUFFER
        $COND   7               ;RESTORE "COND/REG CTL"
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;COMPARE.
;SAME BUT WITHOUT CR #05 (SHOULD BREAK "SCD EXP TEST")"
        INSYNC                  ;SUBTEST #10
        CLEAR                   ;RESET FLAGS.
        $NUM    400             ;DROP #05
        $XBUF                   ;EXECUTE BUFFER
        FLGMCR                  ;ANYBODY HOME?
;SAME BUT DROP "COND/REG CTL":

        INSYNC                  ;SUBTEST #11
        CLEAR                   ;
        $NUM    410             ;RESTORE CR #05.
        $COND   0               ;DROP "COPND/REG CTL"
        $XBUF                   ;EXECUTE UFFER
        FLGMCR                  ;COMPARE.

;SEQ264


;NOW TRY TO BRING UP JUST SCAD01:

        INSYNC                  ;SUBTEST #12:

        CLEAR
$NUM    210             ;CHANGE CR #00 FOR CR #01.
        $COND   7               ;RESTORE "COND/REG CTL".
        $SCAD   2,3,3           ;SET SCA/A+B,SCADA?# & SCADB/#.
        $XBUF           ;EXECUTE BUFFER
        FLGMCR                  ;COMPARE.
        JMP     NORMAL          ;ALL DONE

;MCOMP'S # TABLE:

COW:    .BYTE   0               ;SUBTEST #1: NO  HNGES
        .BYTE   0               ;2
        .BYTE   3               ;3
        .BYTE   2               ;4
        .BYTE   3               ;5
        .BYTE   3               ;6
        .BYTE   0               ;7
        .BYTE   4               ;8
        .BYTE   2               ;9
        .BYTE   1               ;10
        .BYTE   1               ;11
        .BYTE   4               ;12

;MCOMP'S BYTE TABLE:
DUCK:   .BYTE   0               
        .BYTE   20              ;SUBTEST #3:  "SCD TRAP REQ 1"
        .BYTE   1
        .BYTE   340             ;"SCD OV","SCD CRY 0",SCD CRY 1" &M"-AD CRY 01"
        .BYTE   2
        .BYTE   0               ;"-AD OVERFLOW 00" & "-AD CRY 02"

        .BYTE   1               
        .BYTE   0               ;SUBTEST #4:  "-AD CRY 0"
        .BYTE   2
        .BYTE   0               ;"-AD OVERFLOW 00" & "-AD CRY -02"


;SEQ265


        .BYTE   1
        .BYTE   0               ;SUBTEST #5:  "-AD CRY 0"
        .BYTE   2
        .BYTE   0               ;"-AD OVERFLOW 00" & "-AD CRY-02"
        .BYTE   4
        .BYTE   220             ;"-CON PI CYCLE"
        .BYTE   0
        .BYTE   20              ;SUBTEST #6:  "SCD TRAREQ 1"
        .BYTE   1
        .BYTE   320             ;"SCD OV" & "SCD CRY 0"
        .BYTE   2
        .BYTE   0               ;"-AD OVERFLOW 00" & "-AD CRY 02"
        .BYTE   0
        .BYTE   20              ;SUBTEST #8:  "SCD TRAP REQ 1"
        .BYTE   1
        .BYTE   220             ;"SCD OV"
        .BYTE   2
        .BYTE   170             ;"SCD FOV" & "SCD FXU"
        .BYTE   3
        .BYTE   40              ;"-SCAD=0"
        .BYTE   3
        .BYTE   40              ;SUBTEST #9:  "-SCAD=0"
        .BYTE   4
        .BYTE   220             ;"-CON PI CYCLE"
        .BYTE   3               ;SUBTEST #10:   "-SCAD=0"
        .BYTE   40
        .BYTE   3
        .BYTE   40              ;SUBTEST #11:  "-SCAD=0"
        .BYTE   0
        .BYTE   20              ;SUBTEST #12:  "SCD TRAP REQ 1"
        .BYTE   1
        .BYTE   220             ;"SCD OV"
        .BYTE   2
        .BYTE   130             ;"SCD FOV"
        .BYTE   3
        .BYTE   40              ;"-SCAD=0"
        .EVEN


;SEQ266

.SBTTL TEST 19 (ETSAT1):  TEST SATISFIED LOGIC

.REM    %
THIS TEST CHECKS THE TEST SATISFIED LOGIC ON IR3 AND THE SKIP SATISFIED LOGIC
ON MCL 4 & 5.  IT DEPENDS ON THE IR/DRAM WORKING AND THE AD & AD CARRY LOGIC
WORKING.
%

;INITIALIZATION:

ETSAT1: MOV     #EWORD1,R1              ;R1 POINTS TO 36-BIT DATA BUFFER
        MOV     #CHERRY,R2              ;R2 POINTS TO MCOMPS # TABLE.
        MOV     #ORANGE,R3              ;R3 POINTS TO MCOMP'S BYTE TABLE
        MOV     #LEMON,R4              ;R4 POINTS TO THE STIMULUS TABLE

;CHANGE THE CONTRL BOARDSDCOMP TABLES TO INCLUDE "TEST SATISFIED" ON IR BOARD:
        MOVB    #77,CTLMSK              ;INDEX 09 WILL READ "TEST SATISFIED"
        MOVB    #134,CTLFUN     ;AND "-IR JRST 0" ON IR BOARD.
        MOVB    #1,CTLBYT               ;EBUS BIT 19
        MOVB    #0,CTLDAT               ;EXPECT -JRST0 TRUE

;INITIALIZE BR TO 0:
        $BR     1,0             ;LOAD BR FROM (CLEARED) AR
        $XBUF0          ;DO IT.
;LOAD THE DRA M B FIELD:

LIME:   INSYNC                  ;NEW SUBTEST
        CMP     #^D8,SUBNR              ;DONE ALL 8?
        BGE     APPLE           ;IF NOT, CONTOINUE.
        JMP     NORMAL          ;YES, EXCIT.

APPLE:  MOV     R1,R0           ;COPY PTR TO DATA BUFFER TO R0.
        MOVB    (R4),(R0)       ;PUT DRAM B-FIELD BITS DIRECTLY IN BUFFER.
        BIC     #177770,(R0)    ;CLEAR A & J FIELD BIT IN BUFFER.
        SWAB    (R0)            ;PUT B FIELS BITS IN CORRECT BYTE.
        MOV     (R0)+,(R0)+     ;COPY EVEN ADR DATA TO ODD ADR DATA WORD.
        CLRB    (R0)            ;CLEAR COMMON J-FIELD BITS.
        CLR     R0              ;LOAD DATA TO DRAM LOCATIONS 0 & 1
        WDRAM
        DFXCTT                  ;STROBE THE DRAM DATA LATCHES
        .WORD   DRLTCH


;SEQ267

;NOW SET IR FOR JRST0, IF REQUIRED:

        MOV     R5,-(SP)        ;SAVE SUBTEST # ON STACK.
        MOVB    (R4)+,R5                ;GET CODED SET UP BYTE
        $CLRWD                  ;CLEAR THE BUFFER
        ASLB    R5              ;TEST JRSTO BIT.
        BCC     PEAR            ;IF NOT SET, GO SEE ABOUT PI CYCLE
        MOV     R1,R0           ;IF SET, COPY DATA PTR TO R0.
        CLR     (R0)+           ;LOAD BUFFER WITH 25400.
        MOV     #60000,(R0)+
        MOVB    #5,(R0)

PEAR:   MOV     #LDAR,R0                ;AND LOAD THE IR WITH IT.
        DFWIR
;SET PI CYCLE, IF REQURIED:
        CLEAR                   ;RESET ANY RESIDUE PI CYCLES & SET MBOX DISABLE
        $CLRMI                  ;CLEAR MICROCODE BUFFER
        CLR     R0              ;R0 BETTER BE CLEARED
        ASLB    R5              ;TEST PI CYCLE BIT.
        BCC     PRUNE           ;GO AROUND IF CLEAR.
        BIS     #400 ,R0                ;SET # BIT FOR PI CYCLE
PRUNE:  $NUM                    ;WRITE # FIELD TO BUFFER
        $COND   15              ;LOAD 'COND/SPEC INSTR"
        $XBUF0          ;EXECUTE AND CLEAR BUFFER


;SEQ268

.REM    %
SET UP AD=0 AND AD CRY-02.  THE FOUR POSSIBLE STATES FOR THESE VARIABLES
ARE REALIZED AS FOLLOWS:

        AD NOT 0 & NO CARRY:    AD/A+B, A=-1, B=0       (CODE 010)
        AD NOT 0 & AD CR-02:    AD/A-B-1,  A=-1,  B=0   (CODE 00))
        AD IS 0 & NO CARRY:     AD/A+B, A=0, B=0        (C0DE 110)
        AD IS 0 & AD CRY-02:    AD/A+1, A=-1    (CODE 001)
%
        ASLB    R5              ;TEST FIRST AD CODE BIT
        BCC     PEACH           ;GO SET AR=-1 IF IT IS CLEAR.
        DFWRTT                  ;OTHERWISE, CLEAR AR
        .WORD   ZERO            ;DATA
        .WORD   LDAR            ;(FUNCTION)
        BR      GRAPE           ;SKIP NEXT.

PEACH:  DFWRTT                  ;SET AR=-1
        .WORD   ONES            ;(DATA)
        .WORD   LDAR            ;(FUNCTION)

GRAPE:  ASLB    R5              ;TEST NEXT AD CODE BIT.
        BCC     PLUM            ;GO EST LAST BIT IF THIS ONE CLEAR.
        $AD     6,0,2           ;OTHERWIDSE, SET AD/A+B,ADA/AR,ADB/BR
        BR      MANGO           ;AND EXIT.
PLUM:   ASLB    R5              ;TEST LAST AD CODE BIT.
        BCC     GUAVA           ;GO SET AD/A-1 IF CLEAR.
        $AD     40,0,2          ;OTHERWISE, SET AD/A+1
        BR      MANGO           ;AND EXIT.
GUAVA:  $AD     11,0,2          ;SET AD/A-B-1


;SEQ269

;NOW SET MAGIC# FIELD FROM TABLE:

MANGO:  MOVB    (R4),R0 ;GET 2ND SET UP BYTE TO R0.
        BIC     #177474,R0      ;CLEAR ALL BITS EXCEPT CR# 1,2,7,&8
        $NUM                    ;WRITE RESULT TO BUFFER
;SET MEM FIELD FROM TABLE, VMA SEL FIELD, AND DO THE COMPARE:
        CLR     R0              ;DEFAULT FOR MEM FIELD IS 0.
        BITB    #40,(R4)        ;TEST MEM/FETCH BIT.
        BEQ     PAPAYA          ;GO AEROUND IF CLEAR
        MOV     #6,R0           ;SET R0 FOR MEM/FETCH.
PAPAYA: BITB    #20,(R4)                ;TEST MEM/AREAD  BIT.
        BEQ     RAISIN          ;GO AROUND IF CLEAR
        MOV     #4,R0           ;OTHERWISE SET R0 FOR MEM/AREAD.
RAISIN: $MEM                    ;WRITE THE MEM FIELD TO BUFFER
        MOVB    (R4)+,R0        ;GET BYTE WITH VMA SEL BITS
        ASR     R0              ;PUT THEM IN POSITION
        ASR     R0
        $VMA                    ;SET VMA SELECT BITS.
        $MWORD                  ;LOAD BUFFER
        MOV     (SP)+,R5        ;GET SUBTEST # BACK.
        CTLMCR                  ;DO A COMPARE.
        BR      LIME            ;AND LOOP BACK IF NO ERRORS.


;SEQ270

.REM    %
HERE ARE THE BYTE TABLES FOR THIS TEST.  THE STIMULUS BYTES (TWO PER
SUBTEST) ARE CODED AS FOLLOWS:


BIT#    BYTE #1         BYTE #2

0       DRAM B2         CR #08
1       DRAM B1         CR #07
2       DRAM B0         SET VMA SEL 1
3       AD CODE 2*      SET VMA SEL 2
4       AD CODE 1*      SET MEM/AREAD
5       AD CODE 0*      SET MEM/FETCH
6       SET PI CYCLE    CR #02
7       SET JRST0       CR #01

*THE AD CODE BITS ARE FURTHER DECODED AS:

        CODE            MEANING

        010             AD NOT 0 AND NO CARRY
        000             AD NOT 0 AND AD CRY-02
        110             AD IS 0 AND NO CARRY
        001             AD IS 0 AND AD CRY-02

%
LEMON:  .BYTE   366             ;SUBTEST #1:  JSRT0, PI, AD IS 0, B=6
        .BYTE   111             ;VMA SEL = 2, #=101

        .BYTE   311             ;SUBTEST #2:  JRST0, PI, AD=0, AD CRY-02, B=1
        .BYTE   346             ;M,/FETCH, VMA SEL = 1, #=302
        .BYTE   306             ;SUBTEST #3:  JRST0, PI, AD CRY-02, B=6
        .BYTE   122             ;M/READ, VMA SEL = 0, #=102
        .BYTE   205             ;SUBTEST #4:  B=5, JRST0, AD CRY -02
        .BYTE   246             ;M/FETCH, VMA SEL = 1, #=202
        .BYTE   212             ;SUBTEST #5:  JRST0, AD CRY-02, AD=0, B=2
        .BYTE   211             ;VMA SEL = 2, #=201
        .BYTE   27              ;SUBTEST #6:  B=7
        .BYTE   224             ;M/READ, VMA SEL = 1, #=200
        .BYTE   311             ;SUBTEST #7:  JRST0,PI, AD=0, AD CRY-02, B=1
        .BYTE   347             ;M/FETCH, VMA SEL = 1, #=303
        .BYTE   116             ;SUBTEST #8:  PI,AD=0,AD CRY -02, B=6
        .BYTE   142             ;M/FETCH VMA SEL = 0, #=102


;SEQ271

CHERRY: .BYTE   6               ;SUBTEST #1B:  CHANGE 6 BYTES
        .BYTE   7               ;2
        .BYTE   13              ;3B
        .BYTE   7               ;4B
        .BYTE   7               ;5B
        .BYTE   14              ;6B
        .BYTE   10              ;7B
        .BYTE   6               ;8

ORANGE: .BYTE   0               
        .BYTE   200             ;SUBTEST #1:  "IR TEST SATISFIED"
        .BYTE   16
        .BYTE   75              ;"CON PI CYCLE"
        .BYTE   22              
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   1               ;"CON NICOND 09" FALSE) & "CON VMA SEL 1"
        .BYTE   30
        .BYTE   1               ;"-MCL LOAD VMA CONTEXT"
        .BYTE   32
        .BYTE   24              ;"MCL VMAX SEL 1"

        .BYTE   0
        .BYTE   200             ;SUBTEST #2:  "IR T SAT"
        .BYTE   16
        .BYTE   75              ;"CON PI CYCLE"
        .BYTE   23
        .BYTE   41              ;"CON NICOND 09"
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ"
        .BYTE   41
        .BYTE   160             ;"CTL ADX CRY 36"
        .BYTE   42              
        .BYTE   100             ;"CTL ADX CRY 36 A"


;SEQ272

        .BYTE   16              
        .BYTE   75              ;SUBTEST #3:  "CON PI CYCLE"
        .BYTE   23
        .BYTE   41              ;"CON NICOND 09" (FALSE)
        .BYTE   26
        .BYTE   3               ;"MCL VMA GETS AD"
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   31
        .BYTE   3               ;"MCL 23 BIUT EA"
        .BYTE   32
        .BYTE   22              ;"MCL 18 BIT EA"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ"
        .BYTE   34
        .BYTE   120             ;"-CTL AR 00-08 LOAD"
        .BYTE   35
        .BYTE   120             ;"-CTL AR 09-17 LOAD"
        .BYTE   40
        .BYTE   130             ;"CTL AR 00-11 CLR"
        .BYTE   41
        .BYTE   70              ;"CTL AR 12-17 CLR"

        .BYTE   0
        .BYTE   200             ;SUBTEST #4:  T SAT
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   27
        .BYTE   2               ;"-MCL REQ EN & MCL VMA INC"
        .BYTE   30              
        .BYTE   1               ;"-MCL LOAD VMA CONTEXT"
        .BYTE   32
        .BYTE   24              ;"MCL VMAX SEL 1"
        .BYTE   33
        .BYTE   67              ;"MCL MBOX CYC REQ"


;SEQ273

        .BYTE   0
        .BYTE   200             ;SUBTEST #5:  TEST SATISFIED
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   30
        .BYTE   1               ;"-MCL LOAD VMA CONTEXT"
        .BYTE   32
        .BYTE   24              ;"MCL VMAX SEL 1"
        .BYTE   41
        .BYTE   160             ;"CTL ADX CRY 36"
        .BYTE   42
        .BYTE   100             ;"CTL ADX CRY 36 A"

        .BYTE   0
        .BYTE   100             ;SUBTEST #6:  "-IR JRST0" (FALSE)
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   11              ;"-CON VMA SEL 1"
        .BYTE   26
        .BYTE   3               ;"MCL VMA GETS AD"
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   30
        .BYTE   1               ;"-MCL LOAD VMA CONTEXT"
        .BYTE   31              
        .BYTE   3               ;"MCL 23 BIT EA"
        .BYTE   32
        .BYTE   22              ;"MCL 18 BIT EA"
        .BYTE   34
        .BYTE   120             ;"-CTL AR 00-08 LOAD"
        .BYTE   35
        .BYTE   120             ;"-CTL AR 09-17 ;LOAD"
        .BYTE   40
        .BYTE   130             ;"CTL AR 00-11 CLR"
        .BYTE   41
        .BYTE   70              ;"CTL AR 12-17 CLR"


;SEQ274

        .BYTE   16
        .BYTE   75              ;SUBTEST #7:  "CON PI CYCLE"
        .BYTE   22
        .BYTE   1               ;"-CON VMA SEL 2"
        .BYTE   23
        .BYTE   1               ;"CON NICOND 09" (FALSE) & - CON VMA SEL1"
        .BYTE   27              
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   30
        .BYTE   1               ;"-MCL LOAD VMA CONTEXT"
        .BYTE   32
        .BYTE   24              ;"MCL VMAX SEL "
        .BYTE   41
        .BYTE   160             ;'CTL ADX CRY 36"
        .BYTE   42
        .BYTE   100             ;"CTL ADX CRY 36 A"

        .BYTE   0
        .BYTE   300             ;SUBTEST #8:  "IR TEST SAT & JRST0(FALSE)"
        .BYTE   16
        .BYTE   75              ;"CON PI CYCLE"
        .BYTE   23
        .BYTE   41              ;"CON NICOND 09" (FALSE)
        .BYTE   27
        .BYTE   0               ;"-MCL REQ EN"
        .BYTE   41              
        .BYTE   160             ;"CTL ADX CRY 36"
        .BYTE   42
        .BYTE   100             ;"CTL ADX CRY 36 A"

        .EVEN


;SEQ275

.SBTTL TEST 20 (ECON4): GO/START/RUN,I/O LEGAL, & COND ADR 10 LOGIC

.REM    %
THIS TEST CHECKS MOST OF THE LOGIC ON CON2.  IT REQURIES SOME FLAGS TO BE
WORKING, MCL VMA FETCH & VMA AC REF.  NOTE THAT THE DIAGNOSTIC FUNCTIONS:
"SET RUN", "CLR RUN" & "CONTINUE" (DECODED ON CON2) ARE ALSO TESTED HERE.
THE DTE STATUS BITS FOR EBOX HALTED & RUN ARE ALSO CHECKED.
%

;INITIALIZE:

ECON4:  MOV     #SNOW,R2        ;R2 POINTS TO MCOMP'S # TABLE.
        MOV     #RAIN,R3                ;R3 POINTS TO MCOMP'S BYTE TABLE.
        MOV     #HAIL,R4        ;R4 POINTS TO STIMULUS TABLE.

;BEGIN BY ENABLING OR DISABLING AC REFERENCES.
;(ROUTINE CLEARS BUFFERS, DOES RESET & SETS"VMA EXTENDED"):

STORMY: INSYNC                  ;NEW SUBTEST (THERE ARE 20 IN LOOP)
        CLR     R0              ;SET DEFAULT OF "NO AC REFS"
        TSTB    (R4)            ;ENABLE AC REFS?
        BGE     SLUSH           ;LEAVE R0 CLEAR TO PREVENT THEM.

        COM     R0              ;AND SET TO ALL 1'S TO ENABLE THEM.
SLUSH:  $ACREF                  ;LOAD VMA TO ASSURE DESIRED MODE.


;SEQ276

;NEXT LOAD IR TO SET OR CLEAR :"IR I/O LEGAL" (TRUE FOR IR03-IR06 TRUE):

        MOV     #LDAR,R0        ;SET R0 FOR LOAD AR/IR. 
        MOV     #ZERO,R1        ;SET R1 TO CLEAR IR (DEFAULT)
        BITB    #1,(R4)         ;IS "I/O LEGAL" BIT SET?
        BEQ     SLEET           ;LEAVE DEFAULT IF NOT.

        MOV     #ONES,R1                ;ELSE, SET R1 TO LOAD 1'S TO IR.

SLEET:  DFWIR                   ;DO THE DEED, LAD.

;NOW "CON TRAP EN" IF REQUIRED (CONO PAG WITH EBUS 22):

        MOV     #EWORD1,R1      ;R1 NOW POINTS TO 36-BIT BUFFER.
        BITB    #10,(R4)        ;IS "TRAP EN" BIT SET?
        BEQ     FOG             ;LEAVE BUFFER CLEAR IF NOT.
        MOV     #20000,(R1)     ;OTHERWISE SET EBUS BIT 22 IN BUFFER.

FOG:    STUFF           ;IN ANY CASE, LOAD AR FROM BUFFER

$COND   20              ;SET CONO PAG="COND/DIAG FUNC" AN
        $NUM    16              ;#16 IN BUFFER
        $XBUF0                  ;EXECUTE AND CLEAR BUFFER
        CLR     (R1)+           ;LEAVE BUFFER CLEAR (AND BUMP PTR).

;NOW LOAD FLAGS AS REQUIRED:

        MOVB    (R4)+,(R1)      ;PUT SET UP BYTE DIRECTLY IN BUFFER.
        SWAB    (R1)            ;REQUEST BITS (AD 5,6,7,9 & 10).
        BIC     #104777,(R1)    ;CLEAR OUT ALL BUT USER, UIOT, PUBLIC & TRAP
        STUFF                   ;LOAD THE AR FROM THE BUFFER.
        $DISP   24              ;BRING UP "LOAD FLAGS" WIOTH "SPEC/FLAG
        $NUM    20              ;CTL" AND CR#04.
        $XBUF0                  ;EXECUTE AND CLEAR BUFFER


;SEQ277

;SET "MCL VMA WRITE" (TO MAKE "VMA AC RFEF" TRUE WHEN NECESSARY) AND
;SET "MCL VMA FETCH" AS REQUIRED:

        MOV     #100000,(R1)    ;SET EBUS BIT #4 FOR "VMA WRITE"
        BITB    #2,(R4)         ;TEST VMA FETCH BIT.
        BEQ     SMOG            ;DON'T SET BIT #9 IF CLEAR
        BIS     #2000,(R1)      ;SET EBUS BIT 9 FOR FETCH

SMOG:   STUFF                   ;AND WRITE

        
        $MEM    10              ;SET "MEM/AD FUNC" IN BUFFER
        $XBUF0                  ;CR FROM $MICRO, 0'S TO BUF & CR

;NOW CLEAR THE BUFFER & AR:

        $CLRWD                  ;CLEAR THE BUFFER
        DFWRTT                  ;AND TG@ AR.
        .WORD   ZERO    ;DATA
        .WORD   LDAR            ;(FUNCTION)

;SET UCODE STATE 05 FOR SUBTEST #6 (ELSE CLEAR UCODE REG):

        CLR     R0              ;DEFALT MAGIC # = 0.
        CMP     #6,SUBNR                ;DOING 6?
        BNE     DUSTY           ;IF NOT, ZERO NUMBER FIELD.
        MOV     #5,R0           ;IF O, SET CRAM #05.

DUSTY:  $NUM                    ;LOAD NUMBER FIELD IN BUFFER
        $COND   21              ;SET "COND/EBOX STATE"
        $XBUF0                  ;EXECUTE AND CLEAR BUFFER



;SEQ278

;DO "DIAG CONTINUE" IF REQUIRED:

        BITB    #4,(R4)         ;TEST CONTINUE BIT.
        BEQ     HAZE            ;SKIP IF CLEAR.
        DFXCTT                  ;OTHERWISE, DO CONTINUE.
        .WORD   CONBUT

;LOAD THE MAGIC # FIELD:

HAZE:   MOVB    (R4)+,R0        ;PUT CODED SET-UP BYTE WITH # BITS IN R0
        BIC     #177406,R0      ;NO EXTRA BITS.
        ASL     R0              ;SHIFT TO GET BITS IN RIGHT POSITION
        $NUM                    ;AND WRITE # FIELD.

;SET UP "DISP" FIELD FROM FIRST TWO BITS OF LAST CODED SET UP BYTE:
        MOV     SUBNR,-(SP)     ;SAVE SUBTEST # ON STACK
        MOVB    (R4),R5         ;GET LAST CODY BYTE.
        CLR     R0              ;IF NO DISP BITS UP, CLEAR DISP FIELD.
        ASLB    R5              ;TEST FIRST BIT.
        BCC     MISTY           ;DON'T DO ANYTHING IF NOT SET

        MOVB    #24,R0          ;OTHERWISE, SET R0 FOR :SPEC/FLAG CTL"

MISTY:  ASLB    R5              ;TEST NEXT BIT.
        BCC     CLOUDY          ;SKIP IF CLEAR.
        MOVB    #25,R0          ;OTHERWISE, SET R0 FOR "SPEC/SAVE FLAGS"

CLOUDY: $DISP                   ;WRITE RESULTANT DISP FIELD VALUE TO BUF.



;SEQ279

;SET OR CLEAR RUN AS REQUIRED:

        ASLB    R5              ;TEST THE SET RUN BIT.
        BCC     WINDY           ;SKIP IF CLEAR.
        DFXCTT                  ;ELSE, DO A SET RUN EMT.
        .WORD   SETRUN
WINDY:  ASLB    R5              ;TEST THE CLEAR RUN BIT.
        BCC     BREEZY          ;SKIP IF CLEAR.

        DFXCTT                  ;OTHERWISE, DO A CLEAR RUN EMT.
        
        .WORD   CLRRUN

;BRING UP "LOAD SPEC INSTR" IF REQUIRED:

BREEZY: ASLB    R5              ;TEST SPEC INSTR BIT.
        BCC     NIPPY           ;SKIP IF CLEAR.

        $COND   15              ;OTHERWISE, BRING UP "COND/SPEC INSTR"

NIPPY:  $XBUF                   ;EXECUTE BUFFER
        ECLOK                   ;EXTRA CLOCK FOR :"RUN & "START"

;FINALLY SET COND FIELD TO SWITCH "COND ADR 10" MUX TO CORRECT POSITION:

        MOV     (SP)+,R5        ;RESTORE  SUBTEST # TO R5
        MOV     #70,R0          ;THE RIGHTMOST THREE BITS OF THE
        BISB    (R4)+,R0        ;THIRD CODED SET UP BYTE ARE THE THREE
        CMP     #^D11,SUBNR     ;LEAST SIGNIFICANT BITS OF THE "COND"
        BLE     MUGGY           ;FIELD. THE THREE MOST SIGNIFICANT BITS
                                ;OF THIS FIELD COME FROM THE SUBTEST #:
        BIC     #177710,R0      ;FOR THE 1ST TEN SUBTESTS IT'S 6X AND FOR
                                ;THE LAST TEN IT'S 7X.
MUGGY:  $COND                   ;WRITE RESULT TO BUFFER
        $MWORD                  ;AND TO CR

;NOW DO THE COMPARE:

        CTLMCR                  ;COMPARE
        CMP     #^D20,SUBNR     ;SEE IF DONE AALL 20 SUBTESTS IN LOOP.
        BLE     BITING          ;GO AROUND IF DONE.
        JMP     STORMY          ;NOPE, MORE TO DO.


;SEQ280

.REM    %
        
THE LAST PART OF THIS TEST CHECKS THE TIMING OF THE START AND RUN SYNCHRONIZING
LOGIC.  THIS IS, IT CHECKS THAT START & RUN TAKE 3 CLOCKS TO SET FROM THE ISSUING
OF THE (ASYNCHRONOUS) DIAGNOSTIC FUNCTION, THAT START REMAINS UP FOR ONLY
3 CLOCKS, AND THAT RUN STAYS SET FOR 3 CLOCKS AFTER THE CLEAR FUNCTION
HAS BEEN ISSUED.  START WITH A DIAGNOSTIC CONTINUE AND WATCH "START" (COND=71):

%

BITING: CLEAR                   ;START FRESH.
        $CLRMI                  ;CLEAR MICROWORC BUFFER.
        DFXCTT                  ;ISSUE DIAGNOSTIC CONTINUE
        .WORD   CONBUT         
        $COND   71              ;SWITCH MUX TO WATH "START"

CHILLY: INSYNC
        $MWORD                  ;GIVE CLOCK
        CTLMCR                  ;DO A COMPARE
        CMP     #^D26,SUBNR     ;SEE IF FINISHED WATCHING "START"
        BGT     CHILLY          ;LOOP IF NOT

;NOW DO A DIAGNOSTIC SET & CLEAR RUN WHILE MUX IS SWITCHED TO READ "RUN" (COND=72):

        DFXCTT                   ;DO A DIAGNOSTIC SET RUN.
        .WORD   SETRUN
        $COND   72              ;SWITCH MUX TO WATCH ":RUN".

RAW:    INSYNC                  ;SUBTESTS 27-33
        $MWORD                  ;GIVE CLOCK
        CTLMCR                  ;DO COMPARE

        CMP     #^D29,SUBNR     ;SEE IF IT IS TIME TO CLEAR RUN.
        BNE     ICY             ;GO AROUND IF NOT.
        DFXCTT                  ;DO DIAGNOSTIC CLEAR RUN AFTER #29.
        .WORD   CLRRUN

ICY:    CMP     #^D33,SUBNR             ;SEE IF ALL DONE.
        BGT     RAW             ;LOOP IF NOT.
        JMP     NORMAL          ;EXIT IF YES.


;SEQ281

.REM    %
HERE IS THE STIMULUS TABLE FOR THIS TEST.  BYTES ARE CODED AS FOLLOWS:

BIT#    BYTE 1          BYTE 2          BYTE 3
  0     SET I/O LEGAL   CR # 07         COND 05
  1     SET TRAP REQ 1  SET VMA FETCH   COND 04
  2     SET TRAP REQ 2  DO DIAG CONT    COND 03
  3     SET CON TRAP EN CR # 04         SET SPEC INSTR
  4     SET PUBLIC      CR # 03         DDO DIAG CLEAR RUN
  5     SET USER IOT    CR # 02         DO DIAG SET RUN
  6     SET USER        CR # 01         SET SPEC/SAVE FLGS
  7     ENABLE AC REF   CR # 00         SET SPEC/FLAG CTL

%

HAIL:   .BYTE   70              ;SUBTEST #1:  UIOT,PUB,TRAP EN
        .BYTE   267             ;#=542, CONT, VFETCH
        .BYTE   244             ;S/FCTL, SET RUN, COND=64
        .BYTE   276             ;SUBTEST #2:  ACREF, UIOT,PUB,TRAP,EN TR1&2
        .BYTE   57              ;#=122, CONT, VFETCH
        .BYTE   40              ;SET RUN, COND=60
        .BYTE   157             ;SUBTEST #3:  USER,UIOT,TRAP EN,TR1&2,I/O
        .BYTE   127             ;#=242, CONT, VFETCH
        .BYTE   76              ;SET RUN, CLEAR RUN, LOAD SPEC INSTR, COND=66

        .BYTE   370             ;SUBTEST 34:  ACREF,USER,UIOT,PUB,TRAPEN
        .BYTE   261             ;#=542
        .BYTE   17              ;LOAD SPEC INSTR, COND=67
        .BYTE   102             ;SUBTEST #5:  USER,TRAP REQ 1
        .BYTE   334             ;#=660, CONT
        .BYTE   242             ;S/FCTL, SET RUN, COND=62
        .BYTE   45              ;SUBTEST #6:  UIOT, T REQ 2, I/O LEGAL
        .BYTE   205             ;#=402, CONT
        .BYTE   243             ;S/FCTL,SET RUN, COND=63
        .BYTE   200             ;SUBTEST #7:  ACREF
        .BYTE   224             ;#=440, CONT
        .BYTE   211             ;S/FCTL, LOAD SPEC INSTR, COND=61
        .BYTE   150             ;SUBTEST #8:  USER,UIOT,TRAP EN
        .BYTE   230             ;#=460
        .BYTE   35              ;CLEAR RUN, LOAD SPEC INSTR, CCOND=65


;SEQ282

        .BYTE   376             ;SUBTEST #9:  ACREF,UER,UIOT,PUB,T,TR1&2
        .BYTE   57              ;#=122,CONT,VFETCH
        .BYTE   123             ;S/SFLG,CLEAR RUN, COND=63

        .BYTE   201             ;SUBTEST #10:  ACREF, I/O LEGAL
        .BYTE   145             ;#=302, CONT
.BYTE   30              ;CLEAR RUN, LOAD SPEC, INSTR, COND=60
        .BYTE   2               ;SUBTEST #11:  TRAP REQ 1
        .BYTE   224             ;#=440, CONT
        .BYTE   211             ;S/FCTL,LOAD SPEC INSTR,COND=71

        .BYTE   376             ;SUBTESAT #12:  ACREF,USER,UIOT,PUB,T,TR1&2
        .BYTE   43              ;#=102, VFETCH
        .BYTE   153             ;S/SFLAG,SET RUN, LSPIN, COND=73

        .BYTE   275             ;SUBTEST #13:  ACREF, UIOT, PUB,T,TR2 & I/O
        .BYTE   46              ;#=100 CONT & V FETCH
        .BYTE   154             ;S/SFLG,SET RUN, LSPIN, COND=74
        .BYTE   276             ;SUBTEST #14:  ACREF,UIOT,PUB,T,TR1&2
        .BYTE   15              ;#=22, CONT
        .BYTE   114             ;S/SFLG,LSPIN, COND=74

        .BYTE   320             ;SUBTEST #15:  ACREF,USER,PUB
        .BYTE   325             ;#=642,CONT
        .BYTE   236             ;S/FCTL, CLEAR RUN, LSPIN, COND=76

        .BYTE   13              ;SUBTEST #16:  TRAP EN,TREQ1 & I/O
        .BYTE   134                     ;#=260, CONT
        .BYTE   47              ;SET RUN, COND=77

        .BYTE   362             ;SUBTES #17:  ACREF,USER,UIOT,PUB,TREQ 1
        .BYTE   1               ;#=2
        .BYTE   111             ;S/SFLG, LSPIN, COND=71
                
        .BYTE   101             ;SUBTEST #18:  USER,I/O LEGAL
        .BYTE   37              ;#=62, CONT, VFETCH
        .BYTE   235             ;S/FCTL, CLEAR RUN, LSPIN, COND=75
        .BYTE   360             ;SUBTEST #19: ACREF, USER,UIOT, PUB
        .BYTE   117             ;#=2222,CONT, VFETCH
        .BYTE   42              ;SET RUN, COND=72

        .BYTE   106             ;SUBTEST #20: USER,TREQ1 & 2
        .BYTE   15              ;#=22 CONT
        .BYTE   133             ;S/SFLG, CLEAR RUN, LSPIN, COND=73


;SEQ283

;HERE IS MCOMP'S #-OF-CHANGES TABLE:

SNOW:   .BYTE   15              ;SUBTEST #1
        .BYTE   16              ;2
        .BYTE   13              ;3
        .BYTE   10              ;4
        .BYTE   11              ;5
        .BYTE   11              ;6
        .BYTE   6               ;7
        .BYTE   7               ;8
        .BYTE   15              ;9
        .BYTE   5               ;10
        .BYTE   7               ;11
        .BYTE   14              ;12
        .BYTE   17              ;13
        .BYTE   13              ;14
        .BYTE   10              ;15
        .BYTE   12              ;16
        .BYTE   11              ;17
        .BYTE   7               ;18
        .BYTE   14              ;19
        .BYTE   11              ;20
        .BYTE   3               ;21
        .BYTE   3               ;22
        .BYTE   2               ;23
        .BYTE   2               ;24
        .BYTE   2               ;25
        .BYTE   3               ;26
        .BYTE   2               ;27
        .BYTE   2               ;28
        .BYTE   3               ;29
        .BYTE   4               ;30
        .BYTE   4               ;31
        .BYTE   3               ;32
        .BYTE   2               ;33


;SEQ284

;HERE IS MCOMP'S INDEX/NEW BYTE VALUE TABLE:

RAIN:   .BYTE   15              
        .BYTE   4               ;SUBTEST #1:  "CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20              
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   23
        .BYTE   50              ;"-CON PI DISMISS"
        .BYTE   24
        .BYTE   1               ;"VMA HELD OR PC 06" (UIOT)
        .BYTE   25
        .BYTE   40              ;"VMA HELD OR PC 07": (PUB)
        .BYTE   26              
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32              
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"


;SEQ285

        .BYTE   0
        .BYTE   10              ;SUBTEST #2:  "SCD NICOND 10"
        .BYTE   15
        .BYTE   4               ;"CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21      
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   22
        .BYTE   51              ;"CON NICOND 08"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   1               ;"VMA HELD OR PC 06" (UIOT)
        .BYTE   25
        .BYTE   54              ;"VMA HELD OR PC'S" (PUB, TR 1 & 2)
        .BYTE   26
        .BYTE  41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"


;SEQ286

        .BYTE   15
        .BYTE   4               ;SUBTEST #3:  "CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   14              ;"VMA HELD" (TR 1 & 2)
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE    30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND ",C; VMA FETCH"

        .BYTE   15
        .BYTE   4               ;SUBTEST #4:  "CON TRAP EN"
        .BYTE   16
        .BYTE   175             ;"CON PI CYCLE" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   102             ;"-CON PC+1 INH" & "-CON MEM CYCLE"
        .BYTE   23
        .BYTE   45              ;"CON NICOND 09" & "CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   40              ;"VMA HELD " (PUB)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"


;SEQ287

        .BYTE   16
        .BYTE   174             ;SUBTEST #5:  "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   2               ;"VMA HELD" (USER)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"

        .BYTE   16
        .BYTE   174             ;SUBTEST #6:  "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   24
        .BYTE   1               ;"VMA HELD" (UIOT)
        .BYTE   25
        .BYTE   10              ;"VMA HELD" (TR2)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"


;SEQ288

        .BYTE   16
        .BYTE   175             ;SUBTEST #7: "CON PI CYCLE" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   23
        .BYTE   45              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"

        .BYTE   15
        .BYTE   4               ;SUBTEST #8:  "CON TRAP EN"
        .BYTE   16
        .BYTE   175             ;"CON PI CYCLE" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   23              
        .BYTE   45              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   30
        .BYTE   43              ;:MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STRE AR"

        .BYTE   15
        .BYTE   4               ;SUBTEST #9:  "CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   54              ;"VMA HELD" (PUB, TR1 & TR2)
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32              
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"
        .BYTE   34
        .BYTE   30
        .BYTE   43
        .BYTE   70              ;"-CTL INH CRY 18"


;SEQ289

        .BYTE   16
        .BYTE   174             ;SUBTEST #10:  "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   102             ;"-CON PC+1 INH" & "-CON MEM CYCLE"
        .BYTE   21
        .BYTE   41              ;"CON TRAP EN"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"

        .BYTE   16
        .BYTE   175             ;SUBTEST #11:  "CON PI CYCLE" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   23
        .BYTE   41              ;"CON NICOND 09"
        .BYTE   25
        .BYTE   4               ;"VMA HELD" (TREQ1)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"

        .BYTE   15
        .BYTE   4               ;SUBTEST #12:  "CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON  LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   102             ;"-CON PC+1 INH" & "-MEM CYCLE"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   54              ;"VMA HELD" (PUB, TR 1 & 2)
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30              
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL MA FETCH"
        .BYTE   34
        .BYTE   30              ;"-CTL SPEC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70              ;"-CTL INH CRY 18"


;SEQ290

        .BYTE   0               
        .BYTE   10              ;SUBTEST #13:  "SCD NICOND 10"
        .BYTE   15
        .BYTE   4               ;"CON TRAP EN"
        .BYTE   16
        .BYTE   170             ;"-CON LOAD IR" & "CON COND EN 00-07"
        .BYTE   17
        .BYTE   102             ;"-CON PC+1 INH" & "-MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON ICOND 07" & "-CON INSTR GO"
        .BYTE   22
        .BYTE   51              ;"CON NICOND 08"
        .BYTE   24
        .BYTE   1               ;"VMA HELD" (UIOT)
        .BYTE   25
        .BYTE   50              ;"VMA HELD" (PUB & TR2)
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"
        .BYTE   34
        .BYTE   30              ;"-CTL SPEC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70              ;"-CTL INH CRY 18"

        .BYTE   15
        .BYTE   4               ;SUBTEST #14:  "CON TRAP EN"
        .BYTE   16
        .BYTE   174             ;"-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO9"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   1               ;"VMA HELD" (UIOT)
        .BYTE   25
        .BYTE   54              ;"VMA HELD" (PUB, TR 1 & 2)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED " & "-MCL STORE AR"
        .BYTE   34
        .BYTE   30              ;"-CTL SPEC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70              ;"-CTL INH CRY 18"

;SEQ291

        .BYTE   16
        .BYTE   175             ;SUBTEST #15:  "CON PI CYCLE" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   23
        .BYTE   45              ;"CON NICOND 09" & "CON COND ADR 10"
        .BYTE   24
        .BYTE   2               ;"VMA HELD" (USER)
        .BYTE   25
        .BYTE   40              ;"VMA HELD" (PUB)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"
        .BYTE   0
        .BYTE   10              ;SUBTEST #16:  "SCD NICOND 120"
        .BYTE   15
        .BYTE   4
        .BYTE   16
        .BYTE   174             ;"-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   25
        .BYTE   4               ;"VMA HELD" (TR 1)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTEDED" & "-MCL STORE AR"


;SEQ292

        .BYTE   16
        .BYTE   174             ;SUBTEST #17:  "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   44              ;"VMA HELD" (PUB & TREQ1)
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE    33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   34              
        .BYTE   30              ;"-CTL SPEC/SAVE FLAGS"
        .BYTE   43
        .BYTE   70              ;"-CTL INHG CRY 18"

        .BYTE   16
        .BYTE   170             ;SUBTEST #18:  "-CON LOAD IR" & "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"
        .BYTE   40
        .BYTE   320             ;"CTL SPEC/FLAG CTL"


;SEQ293

        .BYTE   16
        .BYTE   170             ;SUBTEST #19: "-CON LOAD IR" & "-COIN COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   22
        .BYTE   51              ;"CON NICOND 08"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   24
        .BYTE   3               ;"VMA HELD" (USER & UIOT)
        .BYTE   25
        .BYTE   40              ;"VMA HELD" (PUB)
        .BYTE   26
        .BYTE   41              ;"MCL VMA READ"
        .BYTE   30
        .BYTE   43              ;"MCL VMA WRITE"
        .BYTE   32
        .BYTE   60              ;"MCL LOAD ARX"
        .BYTE   33
        .BYTE   55              ;"-MCL VMA EXT" AND "MCL VMA FETCH"

        .BYTE   16
        .BYTE   174             ;SUBTEST #20:  "-CON COND EN 00-07"
        .BYTE   17
        .BYTE   112             ;"-CON MEM CYCLE"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   24
        .BYTE   2               ;"VMA HELD: (USER)
        .BYTE   25              
        .BYTE   14              ;"VMA HELD" (TREQ1 & TREQ2)
        .BYTE   30
        .BYTE   43              ;MCL VMA WRITE"
        .BYTE   33
        .BYTE   5               ;"-VMA MCL EXTENDED" & "-MCL STORE AR"
        .BYTE   34              
        .BYTE   30              ;"-CTL SPEC/SAVE FLAGS"
        .BYTE   43              
        .BYTE   70              ;"-CTL INH CRY 18"


;SEQ294

        .BYTE   16
        .BYTE   174             ;SUBTEST #21:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23

        .BYTE   55              ;"-CON COND ADR 10"

        .BYTE   16
        .BYTE   174             ;SUBTEST #22:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"-CON COND ADR 10"
        .BYTE   16
        .BYTE   174             ;SUBTEST #23:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   16
        .BYTE   174             ;SUBTEST #24:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"

        .BYTE   16
        .BYTE   174             ;SUBTEST #25:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"

        .BYTE   16
        .BYTE   174             ;SUBTEST #26:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"-CON COND ADR 10"

        .BYTE   16
        .BYTE   174             ;SUBTEST #27:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"

        .BYTE   16
        .BYTE   174             ;SUBTEST #28:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"


;SEQ295

        .BYTE   16
        .BYTE   174             ;SUBTEST #29: "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"

        .BYTE   16
        .BYTE   174             ;SUBTEST #309:"-CON COND EN 00-07"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   16
        .BYTE   174             ;SUBTEST #31:  "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21              
        .BYTE   51              ;'CON NICOND 07" & "-CON INSTR GO"
        .BYTE   23
        .BYTE   55              ;"CON COND ADR 10"
        .BYTE   16
        .BYTE   174             ;SUBTEST #32:  "-CON COND EN 00-07"
        .BYTE   20
        .BYTE   111             ;"CON NICOND TRAP EN"
        .BYTE   21
        .BYTE   51              ;"CON NICOND 07" & "-CON INSTR GO"

        .BYTE   16
        .BYTE   174             ;SUBTEST #33:  "-CON COND EN 00-07"
        .BYTE   21
        .BYTE   41              ;"-CON INSTR GO"
        .EVEN


;SEQ296

.SBTTL  TEST 21 (ECLK6):  CLOCK BOARD PAGE FAIL LOGIC

.REM    %
THIS TEST FORCES A PAGE FAIL USING "APP SET PAGE FAIL" AND THEN CHECKS
THE SEQUENCING OF THE LOGIC ON CLK4 AND CLK3 (AND THE ADDRESSING ON THE
CRA BOARD).  IT RUNS AT BURST SPEED.  EACH SUBTEST BEGINS WITH THE LOGIC
RESET AND ISSUES A BURST OF MBOX CLOCKS WHICH IS ONE GREATER THAN THE
PREVIOUS SUBTEST'S BURST.  THUS THE PAGE FAIL SEQUENCE IS CHECKED CLOCK
TICK BY CLOCK TICK, BUT IS ALWAYS STEPPED AT MACHINE SPEED RATHER THAN
SINGLE STEP.
%

;INITIALIZE:

ECLK6:  MOV     #MIDGET,R2      ;PTR TO MCOMP'S #-OR-CHANGES TABLE TO R2.
        MOV     #SPRITE,R3      ;PTR TO MCOMP;S VALUE TABLE TO R3.
        MOV     #$$CRAD,R4      ;PTR TO MICROWORD ADDRESS

;LOAD;BEGIN MAIN LOOP HERE:

MGTC:   INSYNC                  ;NEW SUBTEST
        CMP     #^D9,SUBNR      ;DONE AALL 8?
        BGT     MGTD            ;IF NOT, CONTINUE.
        JMP     NORMAL          ;IF YES, EXIT

MGTD:   MOV     #CLKM00,R0      ;SET STARTING MICROCODE
        WWADR                   ;ADDRESS AND DO A RESET
        CLEAR                   ;DISABLE THE MBOX
        MOV     SUBNR,R0                ;THE SUBTEST # GIVES THE #-OF-M-BOX
                                ;CLOCKS TO GIBE.
        ADD     #2,R0           ;NEED TWO MORE CLOCK THAN SUBNR
        BURST
;DO THE COMPARE:
 

        MOV     #CPDAT,DCOMPX   ;PUT PTR TO PAGE FAIL EXPECTED DATA IN DCOMMP
        MCOMP                   ;MODIFY THE EXPECTED DATA

        DCOMP                   ;COMPARE USING TABLES AT END OF TEST.
        .WORD   CPMSK           ;PTR TO MASK TABLE
        .WORD   CPFUN           ;PTR TO DIAG FUNC TABLE
        .WORD   CPBYT           ;PTR TO EBUS BUYTE TABLE
        .WORD   CPDAT           ;PTR TO EXPECTED DATA TABLE
        .WORD   0               ;NO PYR TO ERROR MSG

        RCOMP                   ;RESTORE THE EXPECTED DATA TABLE.

        BR      MGTC            ;NO ERRORS, GO DO NEXT SUBTEST.


;SEQ297

;HERE ARE THE DCOMP COMPARISON TABLES FOR THIS TEST:

CPMSK:  .BYTE   367             ;0-READ ONLY "CLK INSTR 1777" (FR 100)
        .BYTE   300             ;1-READ ALL CLK BOARD FR 102 SIGNALS
        .BYTE   300             ;2-AND ALL FR 103 SIGNALS.
        .BYTE   310             ;3-DON'T READ "SOURCE SEL 2" (FR 104).
        .BYTE   310             ;4-NOR "RATE SEL 1" (FR 107)
        .BYTE   340             ;5-ONLY READ ADDRESS BITS ON CRA
        .BYTE   300             ;6-BOARD
        .BYTE   376             ;7-READ ONLY "-CON MEM CYCLE"
        .BYTE   376             ;10-READ ONLY "CO CLR PRI INSTR"
        .BYTE   376             ;11-READ ONLY "-CTL SPEC CALL"
CPFUN:  .BYTE   100             ;0-CLK
        .BYTE   102             ;1-CLK
        .BYTE   103             ;2-CLK
        .BYTE   104             ;3-CLK
        .BYTE   107             ;4-CLK
        .BYTE   145             ;5-CRA
        .BYTE   144             ;6-CRA
        .BYTE   133             ;7-CON
        .BYTE   133             ;10-SCD
        .BYTE   107!BIT7        ;11-CTL
CPBYT:  BYTPNT  35              ;0-READ EBUS BITS 28-35
        BYTPNT  35              ;1
        BYTPNT  35              ;2
        BYTPNT  35              ;3
        BYTPNT  35              ;4
        BYTPNT  5               ;5-READ EBUS BITS 0-5.
        BYTPNT  5               ;6
        BYTPNT  24              ;7-READ EBUS BITS 17-24.
        BYTPNT  5               ;10-READ EBUS BITS 0-5.
        BYTPNT  28              ;11-READ EBUS BITS 21-28.
CPDAT:  .BYTE   0               ;0-EXPECT "INSTR 1777" FALSE
        .BYTE   26              ;1-EXPECT "CLK SYNC" TRUE
        .BYTE   4               ;2-EXPECT "-BURST" TRUE, "CLK PAGE ERROR" FALSE
        .BYTE   23              ;3-EXPECT "MBOX CYCLE DIS" TRUE
        .BYTE   43              ;4-AL;; FALSE
        .BYTE   0               ;5-NEXT ADDRESS=0
        .BYTE   0               ;6
        .BYTE   0               ;7-EXPECT "-CON MEM CYCLE" TRUE
        .BYTE   0               ;10-EXPECT "CON CLR PRI INSTR" FALSE
        .BYTE   1               ;11-ERXPECT "-CTL SPEC CALL" FALSE


;SEQ298

;HERE IS THE MCOMP NUMBER -OF-CHANGES TABLES FOR THIS TEST:

MIDGET: .BYTE   5               ;SUBTEST #1:  CHANGE 5 BYTES
        .BYTE   3               ;2
        .BYTE   5               ;3
        .BYTE   5               ;4
        .BYTE   6               ;5
        .BYTE   4               ;6
        .BYTE   5               ;7
        .BYTE   2               ;8

;HERE IS THE MCOMP INDEX/NEW VALUE PAIRS TABLEA;

SPRITE: .BYTE   1
        .BYTE   22              ;SUBTEST #1:  "CLK SYNC"  (FALSE)
        .BYTE   2
        .BYTE   0               ;"-CLK EBOX CLK"
        .BYTE   3
        .BYTE   27              ;"CLK EBOX SOURCE"
        .BYTE   5       
        .BYTE   <<CLKM02>&1700>/100     ;CRRA ADR 10-4"
        .BYTE   6
        .BYTE   <<CLKM02>&77>   ;"CRA ADR 5-10"

        .BYTE   4
        .BYTE   63              ;SUBTEST #2:  "CLK PAGE FAIL"
        .BYTE   5
        .BYTE   <<CLKM02>&1700>/100     ;"CRA ADR 1-4"
        .BYTE   6
        .BYTE   <<CLKM02>&77>   ;"CRA ADR 5-10"

        .BYTE   1
        .BYTE   23              ;SUBTEST #3:  "CLK SYNC" (F) & :CLK FORCE 1777"
        .BYTE   2
        .BYTE   0               ;"-CLK EBOX LK"
        .BYTE   4
        .BYTE   63              ;"CLK PAGE FAIL"
        .BYTE   5
        .BYTE   17              ;"CRA ADR 1-4"
        .BYTE   6
        .BYTE   77              ;"CRA ADR 5-10"

        .BYTE   1
        .BYTE   27              ;SUBTEST #4:  "CLK FORCE 1777"
        .BYTE   2
        .BYTE   5               ;"CLK 1777EN"
        .BYTE   5
        .BYTE   17              ;"CRA ADR 1-4"
        .BYTE   6
        .BYTE   77              ;"CRA ADR 5-10"
        .BYTE   11
        .BYTE   0               ;"-CTL SPEC CALL" (FROM "CLK SBR CALL")


;SEQ299

        .BYTE   0       
        .BYTE   10              ;SUBTEST #5:  "INSTR 1777"
        .BYTE   1
        .BYTE   22              ;"CLK SYNC: (FALSE)
        .BYTE   2
        .BYTE   2               ;"-CLK EBOX CLK" & "CLK PAGE ERROR"
        .BYTE   6
        .BYTE   3               ;"CRA ADR 9&10" (FROM "CLK PF DISP")
        .BYTE   10
        .BYTE   1               ;"CON CLR PRIVATE INTR" (FM "INSTR 1777")
        .BYTE   11
        .BYTE   0               ;"-CTL SPEC CALL"(FROM "CLK SBR CALL")

        .BYTE   0
        .BYTE   10              ;SUBTEST #6:  "CLK INSTR 1777"
        .BYTE   2
        .BYTE   6               ;"CLK PAGE ERROR"
        .BYTE   6
        .BYTE   3               ;"CRA ADR 09 & 10"
        .BYTE   10
        .BYTE   1               ;"CON CLR PRIVATE INSTR"

        .BYTE   1
        .BYTE   22              ;SUBTEST #7:  "CLK SYNC" (F)
        .BYTE   2
        .BYTE   0               ;"-CLK EBOX CLK"
        .BYTE   3
        .BYTE   27              ;"CLK EBOX SOURCE"
        .BYTE   6
        .BYTE   3               ;"CRA ADR 09 & 10"
        .BYTE   7
        .BYTE   1               ;"CON MEM CYCLE"

        .BYTE   7
        .BYTE   1               ;SUBTEST #8:  "CON MEM CYCLE"
        .BYTE   6
        .BYTE   3               ;"CRA ADR 09 & 10"

        .EVEN


;SEQ300

.SBTTL TEST 22 (ECLK7):  SIMULATED MBOXRESPONSE

.REM    %
THIS TEST CHECKS THE MB WAIT AND MB XFER LOGIC ON THE CON AND CLK BOARDS.
THE TEST MAKES TWO SIMULATED MBOX CYCLES:  ONE AN AC REFERENCE AND
ONE NOT.

        %

;INITIALIZATION:

ECLK7:  MOV     #COPPER,R2              ;R2 POINTS TO MCOMP'S # TABLE
        MOV     #BRONZE,R3              ;R3 PTS TO MCOMP'S BYUTE TABLE.
        CLR     R4              ;R4 COUNTS CLOCKS
        MOVB    #10,EWORD1              ;SET BIT FOR ?MBOX CYCLE DIS" IN 1ST BUFFER
        MOVB    #14,EWORD2              ;SET BITS FOR MBOX CYCLE DIS" & "MBO9X RESP SIM" IN BUFF
        $ACREF  1               ;ENABLE AC REFS

;BEGIN LOOP HERE:

IRON:   INSYNC                  ;HERE FOR EACH NEW SUBTEST
        CMP     #^D17,SUBNR             ;SEE IF DONE
        BGE     STEEL           ;BRANCH IF NOT.
        JMP     NORMAL          ;EXIT IF NO ERRORS.

STEEL:  CMP     #^D9,SUBNR              ;SEE IF DONE WITH FIRST HALF.
        BNE     BRASS           ;BRANCH IF NOT CHANGE-OVER TIME.
        CLR     R4              ;ELSE CLEAR VURST COUNTER.
        $ACREF          0               ;PREVENT AC REFS.


;SEQ301

BRASS:  INC     R4              ;GIVE ONE MORE TICK EACH SUBTREST
        MOV     #CLKM10,R0              ;READ FIRST MICROWORD TO THE
        RCRAM           ;COMMAND REGISTER & RESET.

        DFWRTT                  ;TURN ON MBOX DISABLE
        EWORD1          ;DATA
        LDCHK2          ;FUNCTION

        MOV     R4,R1           ;GET READY TO BURST THE CLOCK.
        CMP     #4,R1           ;ARE WE PAST TIME TO DO "RESP SIM"
        BLE     SILVER          ;NO, GO GIVE BURSTS.
MOV     #4,R0           ;YES, GIBE BURST OF 4
        BURST

        DFWRTT                  ;THEN SET RESP SIM
        EWORD2          ;DATA PTR
        LDCHK2          ;CLOCK REG FUNCTION

        SUB     R1,#4           ;COMPUTE CLOCKS TO GO.

SILVER: MOV     R1,R0           ;GIVE BALANCE OF CLOCKS.
        BURST

        DCOMP                   ;DOI BYTE TABLE COMPARE
        .WORD   CHROME          ;MASK TABLE
        .WORD   TIN             ;FUNCTION TABLE
        .WORD   ZINK            ;BYTE TABLE
        .WORD   LEAD            ;EXPECTED DATA TABLE
        .WORD   0               ;NO ERROR MSG HERE

        BR      IRON            ;DO MORE.


;SEQ302

;SPECIAL DCOMP TABLES FOR THIS TEST:

CHROME: .BYTE   376             ;MASK ALL BUT "CLK MB XFER"
        .BYTE   376             ;MASK ALL BUT "MCL MBOX CYCLE REQ"
        .BYTE   376             ;MASK ALL BUR "-CON MEM CYCLE"
        .BYTE   376             ;MASK ALL BYT "-CON MBOX WAIT"
        .BYTE   376             ;MASK ALL BUT "-CON FM XFER"

TIN:    .BYTE   103             ;DIAGNOSTIC FUNCTIONS
        .BYTE   107
        .BYTE   133
        .BYTE   135
        .BYTE   136!BIT7

ZINK:   BYTPNT  32              ;EBUS BIT POINTER
        BYTPNT  22
        BYTPNT  24
        BYTPNT  24
        BYTPNT  24

LEAD:   .BLKB   5               ;STORAGE FOR EXPECTED DATA.

;HERE ARE THE MCOMP TABLE FOR THIS TEST:

COPPER: .BYTE   1               ;SUBTEST #1:  1 CHANGE
        .BYTE   1               ;2
        .BYTE   3               ;3
        .BYTE   3               ;4
        .BYTE   0               ;5
        .BYTE   0               ;6
        .BYTE   0               ;7
        .BYTE   0               ;8
        .BYTE   1               ;9
        .BYTE   1               ;10
        .BYTE   2               ;11
        .BYTE   2               ;12
        .BYTE   2               ;13
        .BYTE   3               ;14
        .BYTE   1               ;15
        .BYTE   1               ;16


;SEQ303

BRONZE: .BYTE   1
        .BYTE   1               ;SUBTEST #1:  "MCL MBOX CYCLE REQ"

        .BYTE   1
        .BYTE   1               ;SUBTEST #2:  "MCL MBOX CYCLE REQ"

        .BYTE   2
        .BYTE   0               ;SUBTEST #3:  "-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0
        .BYTE   4
        .BYTE   0               ;"-CON FM XFER"

        .BYTE   2
        .BYTE   0               ;SUBTEST #4:  "-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0               ;"-CON MBOX WAIT"
        .BYTE   4
        .BYTE   0               ;"-CON FM XFER"
        .BYTE   1
        .BYTE   1               ;SUBTEST #9:  "MCL MBOX CYCLE REQ

        .BYTE   1
        .BYTE   1               ;SUBTEST #10:  "MCL MBOX CYCLE REQ"

        .BYTE   2
        .BYTE   0               ;SUBTEST #11:  "-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0               ;"-CON MBOX WAIT"

        .BYTE   2
        .BYTE   0               ;SUBTEST #12:  "-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0               ;"-CON MBOX WAIT"

        .BYTE   2
        .BYTE   0               ;SUBTEST #13:  "-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0               ;"-CON MBOX WAIT"

        .BYTE   0
        .BYTE   1               ;SUBTEST #14:  "CLK MB XFER"
        .BYTE   2
        .BYTE   0               ;"-CON MEM CYCLE"
        .BYTE   3
        .BYTE   0               ;"-CON MBOX WAIT"

        .BYTE   0
        .BYTE   1               ;SUBTEST #15: "CLK MB XFER"

        .BYTE   0       
        .BYTE   1               ;SUBTEST #16:  "CLK MB XFER"

        .EVEN

;SEQ304
.SBTTL *ESCD*  10-BIT ARITHMETIC TESTS
.SBTTL TEST 23 (ESCD2):  BASIC 10-BIT DATA PATHS

ESCD2:  PMSG    <STARTING 10-BIT ARITHMETIC TESTS\>     ;PRINT TRACE

.REM    %
THIS TEST USES THE AR TO SC INPUT PATH TESTED IN ESCD1 TO SEND PATTERNS
OVER THE FOLLOWING 10-BIT ARITHMETIC DATA PATHS:  SC FROM SC VIA THE
SCAD (CHECKS 1ST POSITION ON SCADB MUX, SCAD PASSES "B" DATA ON "A+B" AND
3RD POSITION ON SCM MUX), FE FROM SCAD, FE RECIRCULATION AND SHIFT RIGHT,
SC FROM FE (2ND POSITION ON SCM MUX) AND AR (UPPER BITS) FROM SCAD VIA
ARMM (ARMM POSITIONS 3 & 4).  IT USES STANDARD TEST PATTERNS AND BURSTED
MICROCODE.

REFER TO THE E-BOX DIAGNOSTIC MICROCODE LISTING AT CRAM LOCATION:
        START   =       SCM00
        
FOR DETAILS OF EACH MICROWORD.

HERE TO LOAD A NEW TEST PATTERN.  THERE ARE FOUR SUBTESTS PER PATTERN.
THE FIRST TESTS FE AND AR FROM SC, THE SECOND SC AND FE FROM FE, THE
THIRD AR FROM FE AND FE SHIFT, AND THE FOIURTH AR FROM THE SC EXP FIELD.
%

        $PAT36  EWORD1          ;GET THE FIRST PATTERN TO BUFFER.
        BR      PACO            ;AND BEGIN

PANCHO: PATCON          ;GET NEXT PATTERN TO BUFFER
        BNE     PACO            ;CONTINUE IF MORE TO DO.

        JMP     NORMAL          ;BAIL OUT WHEN DONE.



;SEQ305

;R4 WILL KEEP TRACK OF HOW MANY CLOCKS TO GIVE:

PACO:   MOV     #2,R4           ;INITIALIZE BURST COUNT TO 2.

CARLOS: INC     R4              ;INCREMENT BURST COUNT.
        CMP     #7,R4           ;SEE IF TIME FOR NEW PATTERN.
        BLE     PANCHO          ;GO GET ONE & RESET BURST COUNT IF SO.

        INSYNC                  ;OTHERWISE, NEW SUBTEST (48 IN ALL).
        MOV     #SCM00,R0       ;RESET CRAM ADR TO SCM00 AND
        WWADR                   ;DO A MRESET.
        ECLOK                   ;LOAD FIRST MICROWORD BEFORE LOADING AR
        STUFF                   ;RELOAD PATTERN TO AR.

        MOV     R4,R0           ;COMPUT PROPER # OF M-BOX CLOCKS
        ASL     R0              ;TO GIVE (=TWICE # OF E-BOX CLOCKS).
        BURST                   ;AND GIVE THEM.


;SEQ306

.REM    %
SET UP THE EXPECTED DATA.  THE BASIC EXPECTED PATTERN WILL HAVE BIT 18 OF EWORD1
IN THE TWO MOST SIGNIFICANT BITS FOLLOWED BY BITS 18-35.  DENOTING THIS BY "PAT"
ITS COMPLIMENT BY -PAT AND A LEFT OR RIGHT SHIFT OF ONE POACE BY "PAT*2" AND "PAT/2"
RESPECTIVELY, THE EXPECTED DATA SHOULD LOOK AS FOLLOWS:


SUBTEST #       SC      FE      AR
  4N+1 -PAT     PAT     PAT*2 (BITS 0-8), -PAT (BITS 9-35)
  4N+2  PAT     PAT     -PAT*2 (BITS 0-8), -PAT (BITS 9-35)
  4N+3 -PAT     PAT/2   PAT*2 (BITS 0-8), -PAT (BITS 9-35)
  4N+4 -PAT     PAT/4   -PAT*16 (TOP 6 BITS), PAT (NEXT 3), -PAT (BITS 9-35)
%
;BEGIN BY USDING SUBROUTINE AR2SC TO SET UP SC & FE'S EXPECTED DATA:

        MOV     #SCDDAT,R1      ;R1 POINTS TO SC'S EXPECTED DATA
        MOV     #SCDDAT+2,R2    ;R2 POINTS TO FE'S EXPECTED DATA.
        MOV     #SCDDAT+10,R3   ;R3 POINTS TO FE SIGN BYTE IN EXPECTED

        MOVB    #1,SCDDAT+11    ;EXPECT "-SCAD=0" FALSE IN GENERAL

        CMP     #4,R4           ;IN ALL BUT THE 2ND COMPARE (BURST
        BNE     LUIS            ;COUNT=4), SC GETS COMPLIMENTED PATTERN.

        AR2SC                   ;FOR 2ND COMPARE, USE PATTERN IN EWORD1
        MOV     (R1),(R2)+      ;AND COPY RESULT TO FE'S EXPECTED
        MOVB    SCDDAT+6,(R3)   ;INCLUDING SIGN BIT
        BR      PABLO           ;SKIP OVER STUFF FOR 1ST, ERD & 4TH COMPARES.

LUIS:   CA2SC                   ;ALTERNATE CALL FOR COMPLIMENTED DATA
        MOV     (R1),(R2)               ;COPY RESULT TO FE'S DATA
        COM     (R2)+           ;BUT COMPLIMENT IT.
        MOVB    SCDDAT+6,(R3)   ;AND SAME FOR SIGN BIT.
        COMB    (R3)            ;INCLUDING COMPOIMENTING.


;SEQ307

;PUT AR'S EXPECTED DATA IN PLACE AND FIX UP VAIRATIONS FOR EACH COMPRE:

PABLO:  MOV     (R1),(R2)       ;COPY SC DATA TO AR DATA
        COM     (R2)            ;COMPLIMENT IT AND
        ASL     (R2)            ;SHIFT IT LEFT ONCE
        CMP     #5,R4           ;ALL DONE FOR FIRST 2 COMPARES.
        BGT     RAMON           ;GO DO THE COMPARE.

        BLT     PEDRO           ;GO DO MORE STUFF FOR 4TH COMPARE.

        ASR     -(R2)           ;SHIFT FE DATA RIGHT ONCE FOR 3RD
        BR      RAMON           ;COMPARE & GO DO THE COMPARE.

PEDRO:  ASR     -(R2)           ;SHIFT FE DATA RIGHT TWICE FOR 4TH
        ASR     (R2)+           ;COMPARE

        ASL     (R2)            ;SHIFT AR DATA LEFT 3 MORE TIMES
        ASL     (R2)            ;(FOR A TOTAL OF 4 TIMES OR SO
        ASL     (R2)            ;THAT AR00 = SC04).
        COM     (R2)            ;COMPLIMENT DATA AGAIN
        CLRB    SCDDAT+11       ;AND EXPECT "-SCAD=0" TRUE NOW

;THE FOLLOWING SETS AR06-08 = PATTERN 07-09 IN EXPECTED DATA.
        
        MOV     #160,R0         ;PUT BIT MASK IN R0.
        BISB    R0,(R2)         ;USE IT TO SET AR06-AR08 IN DATA.
        MOV     (R1),R3         ;COPY SC DATA TO R3
        ASL     R3              ;SHIFT IT ONCE.
        COM     R0              ;INVERT MASK.
        BIC     R0,R3           ;USE IT ON SHIFTED SC DATA (ONLY 7,8&9 REMAIN)
        BICB    R3,(R2)         ;FINALLY USE 1'S IN SC07-09TO CLEAR AR06-08.


;FINALLY, DO THE COMPARE AND LOOP BACK IF NO ERRORS:

RAMON:  SCDCMP                  ;COMPARE
        BR      CARLOS          ;AND GO BACK FOR MORE.


;SEQ308
.SBTTL TEST 24 (ESCD3):  SCAD AND ARMM MULTIPLEXERS
.REM    %
THIS TEST CHECKS THE SCADA, SCADB AND ARMM MIXERS.  THE TEST USES 2 BURSTED MICROWORDS
TO STEER AR AND # FIELD PATTERNS THROUGH THE MIXERS INTO THE AR, SC AND FE
REGISTERS.  THE FIRSTR MICROWORD IS LOADED SEPARATELY BY EACH SUBTEST BASED ON
THE STIMULYUS TABLE THE SECOND, WHICH IS THE SAME FOR ALL SUBTESTS SIMPLYU RECIRCULATES THE
REGISTER DATA AND IS THRERE TO SWITCH THE MIXERS TO CATCH ANY SLOW
PROPAGATING SIGNALS.  THE TEST ASSUMES THAT THE SCADDER CAN PASS "A" DATA (SCAD/A)
OR "B" DATA (SCAD/A+B, SCADA DISABLED).  THE ADDER IS CHECKED IN TEST ESCD5.
%
;CLEAR CRAM LOC 1 SO REGISTERS RECIRCULATE (DEFAULTS):

ESCD3:  MOV     #1,R0           ;CRAM LOC 1
        MOV     R0,R1           ;ONE WORD
        MICNUL                  ;CLEAR IT

;INITIALIZE PTRS:

        MOV     #PAWN,R4        ;R4 POINTS TO START OF STIMULUS TABLE
        MOV     #ROOK,R2        ;R2 POINTS TO MCOMP #-OF-CHANGES TABLE
        MOV     #BISHOP,R3      ;R3 POINTS TO MCOMP BYTE TABLE.

;BEGIN LOOP BY CLEARING MACHINE & CRAM ADDRESS:

CHECK:  INSYNC                  ;NEW SUBTEST
        CMP     #^D15,SUBNR     ;DONE ALL 15 PATTERNS"
        BGE     MATE            ;IF NOT, CONTINUE.
        JMP     NORMAL          ;OTHERWISE, PUSH OVER YOU KING.

MATE:   CLR     R0              ;CLEAR LOC 0 AND SET CRAM ADDR TO 0
        CLR     R1
        MICNUL                  ;AND DO A MASTER RESET

        ECLOK                   ;DO AN ANTI-BRUCKERT CLOCK

;LOAD THE NEXT PATTERN TO THE AR:

        MOVB    (R4)+,EWORD1+3  ;PUT FIRST TWO BYTES FROM STIMULUS
        MOVB    (R4),EWORD1+4   ;TABLE (CONTAINING AR0-11) DIRECTLY IN BUFFER
        STUFF                   ;AND WRITE BUFFER TO AR.


;SEQ309

;BEGIN LOAD MICROWORD BUFFER WITH WORD TO BE WRITTEN IN LOC 0.  START BY
;SETTING "COND/AR GETS EXP" ("COND/REG CTL" WITH CR#05) IF NEEDED.  NOTE THAT
;"CTL AR 00-08 LOAD" IS NECESSARY TO MAKE THE ARMM LOAD THE AR.  SO WHEN DOING
;A "COND/AR GETS EXP" NEED CR#00 WHICH GIVES "CTL REG CTL #00" AND, THEREBY,
;"CTL AR 00-08 LOAD".  OTHERWISE USE "COND/ARLL LOAD".

        MOV     #1,R0           ;DEFAULT IS "COND/ARLL LOAD' (COND=1)
        TSTB    (R4)            ;SEE IF 'COND/AR GETS EXP" BIT IS SET.
        BGE     KNIGHT          ;SET "COND/ARLL LOAD' IF NOT.

        MOV     #7,R0           ;OTHERWISE SET "CPOND/REG CTL".
KNIGHT: $COND                   ;WRITE SELECTED COND FIELD TO BUFFER.

;NOW SET "SH-ARMM SEL" BITS TO SWITCH ARMM TO CORRECT POSITION:
        MOVB    (R4)+,R0        ;GET 2ND STIMULUS BYTE WITH ARMM BITS.
        ASL     R0              ;SHIFT ARMM BITS INTO UPPER BYTE.
ASL     R0
        ASL     R0
        SWAB    R0              ;THE OLD SWITCHEROO.
        $SH                     ;WRITE SH-ARMM FIELD TO BUFFER

;NEXT COMES THE # FIELD.

        MOV     (R4)+,R0        ;GET NEXT TWO STIMULUS BYTES WITH #
        $NUM                    ;WRITE IT TO THE BUFFER.

;AND FINALLY THE SCAD FIELD:

        MOVB    -(R4),R0        ;GET SCAD FIELD BITS FROM LAST STIMULUS BYTE.
        BIC     #177401,R0      ;CLEAR SCAD 1 BIT (IT'S ALWAYS 0).
        INC     R4              ;TIDY UP THE PTR.
        $SCAD                   ;AND WRITE SCAD FIELD TO BUFFER

;NOW SET THE FIXED FIELDS IN THE BUFFER:
        $SC     1               ;SET SC/SCAD.

        $FE     1               ;SET FE/SCAD.

        $J      1               ;LOC 1 IS NEXT.


;SEQ310

;WRITE THE BUFFER TO CRAM LOC 0:

        PUSH    R1              ;SAVE R1 FROM KLDCP'S CLUTCHES.

        MOV     #BIT15,R0       ;LOC 0 (AND DON'T RESET)
        MOV     #$MICRO,R1      ;BUFFER HAS DATA
        WCRAM                   ;WRITE IT.
        POP     R1              ;RETRIEVE R1.

;BURST CLOCK AND DO A COMPARE:
        EBURST  2               ;GIVE 2 EBOX CLOCKS
        SCDMCR          ;AND COMPARE
        BR      CHECK           ;IF NO ERRORS, GO DO ANOTHER.

;HERE IS THE STIMULUS TABLE FOR THIS TEST.  BYTS HAVE THE FOLLOWING SIGNIFICANCE.
;BIT #   1ST BYTE       2ND BYTE        3RD BYTE        4TH BYTE

;  0      AR11            AR03            CR#08           CR#00
;  1      AR10            AR02            CR#07           SCAD 2
;  2      AR09            AR01            CR#06           SCAD 4
;  3      AR08            AR00            CR#05           SCADA SEL 1
;  4      AR07              0             CR#04           SCADA SEL 2
;  5              AR06  SH-ARMM SEL1      CR#03           SCADA DIS
;  6      AR05          SH-ARMM SEL2      CR#02           SCADB SEL 1
;  7      AR04          SET COND/REG CTL        CR#01             SCADB SEL 2


;SEQ311

PAWN:   .BYTE   3               ;SUBTEST #1:  AR=300300,,0
        .BYTE   106             ;SH-ARMM=2
        .BYTE   144             ;#=144
        .BYTE   120             ;SCAD/A, SCADA=2, SCADB=1

        .BYTE   345             ;SUBTEST #2:  AR=274500,,0
        .BYTE   105             ;SH-ARMM=2
        .BYTE   71              ;#=471
        .BYTE   331             ;SCAD/A, SCADA=3, ACADB=3

        .BYTE   275             ;SUBTEST #3:  AR=527500,,0
        .BYTE   52              ;SH-ARMM=1
        .BYTE   104             ;#=104
        .BYTE   362             ;SCAD/A+B, SCADA=2, DIS, SCADB=3

        .BYTE   277             ;SUBTEST #4;  AR=267700,,0
        .BYTE   145             ;SH-ARMM=3
        .BYTE   336             ;#=736
        .BYTE   121             ;SCAD/A, SCADA=2, SCADB=1

        .BYTE   365             ;SUBTEST #5:  AR=476500,,0
        .BYTE   151             ;SH-ARMM=3
        .BYTE   273             ;#=673
        .BYTE   353             ;SCAD/A+B, SCADA=1, DIS, SCADB=3
        .BYTE   154             ;SUBTEST #6:  AR=555400,,0
        .BYTE   253             ;SH-ARMM=1, COND/REG CTL
        .BYTE   344             ;#=744
        .BYTE   11              ;SCAD/A, SCADA=1, SCADB=0

        .BYTE   177             ;SUBTEST #7:  AR=417700,,0
        .BYTE   310             ;SH-ARMM=2, COND/REG CTL
        .BYTE   34              ;#=434
        .BYTE   163             ;SCAD/A+B, SCADA=2, DIS, SCADB=1

        .BYTE   370             ;SUBTEST #8:  777000,,0
        .BYTE   357             ;SH-ARMM=3, COND/REG CTL
        .BYTE   256             ;#=656
        .BYTE   263             ;SCAD/A+B, SCADA=2, DIS, SCADB=2

        .BYTE   344             ;SUBTEST #9:  AR=74400,,0
        .BYTE   201             ;SH-ARMM=0, COND?REG CTL
        .BYTE   373             ;#=773
        .BYTE   321             ;SCAD/A, SCADA=2, SCADB=3

        .BYTE   357             ;SUBTEST #10:  AR=635700,,0
        .BYTE   314             ;SH-ARMM=2, COND/REG CTL
        .BYTE   11              ;#=411
        .BYTE   11              ;SCAD/A, SCADA=1, SCADB=0

        .BYTE   347             ;SUBTEST #11:  AR=34700,,0
        .BYTE   100             ;SH-ARMM=2
        .BYTE   276             ;#=676
        .BYTE   331             ;SCADA/A, SCADA=3, SCADB=3


;SEQ312

        .BYTE   370             ;SUBTEST #12:  AR=637000,,0
        .BYTE   254             ;SH-ARMM=1, COND/REG CTL
        .BYTE   277             ;#=677
        .BYTE   163             ;SCAD/A+B, SCADA=2, DIS, SCADB=1

        .BYTE   321             ;SUBTEST #13:  AR=632100,,0
        .BYTE   154             ;SH-ARMM=3
        .BYTE   130             ;#=130
        .BYTE   330             ;SCAD/A, SCADA=3, SCADB=3

        .BYTE   102             ;SUBTEST #14:  AR=650200,,0
        .BYTE   215             ;SH-ARMM=0, COND/REG CTL
        .BYTE   206             ;#=606
        .BYTE   1               ;SCAD/A, SCADA=0, SCADB=0

        .BYTE   0               ;SUBTEST #15:  AR=0,,0
        .BYTE   300             ;SH-ARMM=2, COND/REG CTL
        .BYTE   10              ;#=400
        .BYTE   31              ;SCAD/A, SCADA=3, SCADB=0


;SEQ313

;HERE ARE THE MCOMP TABLES FOR THIS TEST:
ROOK:   .BYTE   3               ;SUBTEST #1:  3 CHANGES
        .BYTE   10              ;2
        .BYTE   6               ;3
        .BYTE   6               ;4
        .BYTE   6               ;5
        .BYTE   7               ;6B
        .BYTE   7               ;7B
        .BYTE   6               ;8
        .BYTE   7               ;9B
        .BYTE   7               ;10B
        .BYTE   10              ;11
        .BYTE   7               ;12B
        .BYTE   6               ;13
        .BYTE   4               ;14
        .BYTE   7               ;15

BISHOP: .BYTE   1                       
        .BYTE   6               ;SUBTEST #1:  SC=300
        .BYTE   3
        .BYTE   6               ;FE=300
        .BYTE   5               
        .BYTE   14              ;ARMM=300
        .BYTE   0               
        .BYTE   310             ;SUTEST #2:  SC=1471
        .BYTE   1
        .BYTE   31
        .BYTE   2
        .BYTE   310             ;FE=1471
        .BYTE   3
        .BYTE   31
        .BYTE   4
        .BYTE   220             ;ARMM=471
        .BYTE   5
        .BYTE   23

        .BYTE   6
        .BYTE   1               ;SC SIGN
        .BYTE   10
        .BYTE   1               ;FE SIGN


;SEQ314

        .BYTE   0               
        .BYTE   40              ;SUBTEST #3:  SC=104
        .BYTE   1
        .BYTE   2
        .BYTE   2
        .BYTE   40              ;FE=104
        .BYTE   3
        .BYTE   2
        .BYTE   4
        .BYTE   360             ;ARMM=777
        .BYTE   5
        .BYTE   37

        .BYTE   0
        .BYTE   270             ;SUBTEST #4:  SC=267
        .BYTE   1
        .BYTE   5
        .BYTE   2
        .BYTE   270             ;FE=267
        .BYTE   3
        .BYTE   5
        .BYTE   4
        .BYTE   360             ;ARMM=677
        .BYTE   5
        .BYTE   33

        .BYTE   0
        .BYTE   330             ;SUBTEST #5:  SC=673
        .BYTE   1
        .BYTE   15
        .BYTE   2
        .BYTE   330             ;FE=673
        .BYTE   3
        .BYTE   15
        .BYTE   4
        .BYTE   340             ;ARMM=736
        .BYTE   5
        .BYTE   35


;SEQ315

        .BYTE   0
        .BYTE   150             ;SUBTEST #6:  SC=55
        .BYTE   1
        .BYTE   1
        .BYTE   2               
        .BYTE   150             ;FE=55
        .BYTE   3
        .BYTE   1
        .BYTE   4
        .BYTE   360             ;ARMM=777
        .BYTE   5
        .BYTE   37
        .BYTE   7               
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE
        .BYTE   0       
        .BYTE   370             ;SUBTEST #7:  SC=77
        .BYTE   1
        .BYTE   1
        .BYTE   2
        .BYTE   370             ;FE=77
        .BYTE   3
        .BYTE   1
        .BYTE   4
        .BYTE   360             ;ARMM=477
        .BYTE   5       
        .BYTE   23
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE

        .BYTE   0
        .BYTE   370             ;SUBTEST#8:  SC=777
        .BYTE   1
        .BYTE   17
        .BYTE   2
        .BYTE   370             ;FE=777
        .BYTE   3
        .BYTE   17
        .BYTE   4       
        .BYTE   360             ;ARMM=777
        .BYTE   5
        .BYTE   37


;SEQ316
        .BYTE   0
        .BYTE   340             ;SUBTEST #9:  SC=74
        .BYTE   1
        .BYTE   1
        .BYTE   2
        .BYTE   340             ;FE=74
        .BYTE   3
        .BYTE   1
        .BYTE   4
        .BYTE   260             ;ARMM=773
        .BYTE   5
        .BYTE   37
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE
        .BYTE   0
        .BYTE   230             ;SUBTEST #10:  SC=63
        .BYTE   1
        .BYTE   1
        .BYTE  2
        .BYTE   230             ;FE=63
        .BYTE   3
        .BYTE   1
        .BYTE   4
        .BYTE   60              ;ARMM=463
        .BYTE   5
        .BYTE   23

        .BYTE   7
        .BYTE   0               ;SC ./GE. (REALLY 100) FALSE

        .BYTE   0
        .BYTE   360             ;SUBTEST#11:  SC=1676
        .BYTE   1
        .BYTE   35
        .BYTE   2
        .BYTE   360             ;FE=1676
        .BYTE   3
        .BYTE   35
        .BYTE   4
        .BYTE   340             ;ARMM=676
        .BYTE   5
        .BYTE   33
        .BYTE   6
        .BYTE   1               ;SC SIGN
        .BYTE   10
        .BYTE   1               ;FE SIGN


;SEQ317
        .BYTE   0
        .BYTE   300             ;SUBTEST#12:  SC=70
        .BYTE   1
        .BYTE   1
        .BYTE   2
        .BYTE   300             ;FE=70
        .BYTE    3
        .BYTE   1
        .BYTE   4
        .BYTE   360             ;ARMM=777
        .BYTE   5
        .BYTE   37
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE

        .BYTE   0
        .BYTE   300             ;SUBTEST#13:  SC=130
        .BYTE   1
        .BYTE   2
        .BYTE   2
        .BYTE   300             ;FE=130
        .BYTE   3
        .BYTE   2
        .BYTE   4
        .BYTE   40              ;ARMM=302
        .BYTE   5
        .BYTE   14
        
        .BYTE   4
        .BYTE   140             ;SUBTEST#14:  ARMM=606
        .BYTE   5
        .BYTE   30
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (FALSE)
        .BYTE   11              ;-SCAD=0 (TRUE)
        
        .BYTE   0
        
        .BYTE   0
        .BYTE   100             ;SUBTEST #15:  SC=1410
        .BYTE   1
        .BYTE   30
        .BYTE   2
        .BYTE   100             ;FE=1410
        .BYTE   3
        .BYTE   30
        .BYTE   4
        .BYTE   200             ;ARMM=10
        .BYTE   6
        .BYTE   1               ;SC SIGN
        .BYTE   10      
        .BYTE   1               ;FE SIGN

        .EVEN


;SEQ318

.SBTTL TEST 25 (ESCD4):  SC .GE. 36 LOGIC

.REM    %
THIS TEST CCKS THE SC .GE. 36 GATES ON SCD2.  IT USES 1 MICROWORD WHICH
LOADS THE MAGIC # FIELD THROUGH THE SCADB, SCAD AND ACM INTO THE SC. NINE
MAGIC # PATTERNS ARE USED.
%
;LOAD SOME POINTERS AND START BUILDING A MICROWORD IN LOC 0:

ESCD4:  MOV     #PORK,R1        ;R1 POINTS TO # TABLE
        MOV     #VEAL,R2        ;R2 POINTS TO MCOMP'S # OF CHANGES TABLE
        MOV     #LAMB,R3                ;R3 POINTS TO MCOMP'S VALUE TABLE

        $SCAD   2,4,3           ;SCAD/A+B, SCADA/DISABLED,SCADB/#
        $SC     1               ;SC/ACAD

;BEGIN MAIN LOOP HERE:

BEEF:   INSYNC                  ;NEW SUBTEST
        CMP     #^D9,SUBNR      ;DONE ALL 9?
        BGT     CALF            ;GO RIGHT ON FOR SUBTESTS 1-8

        BEQ     MUTTON          ;SUBTEST 9 GETS SPECIAL TREATMENT

        JMP     NORMAL          ;ANYTHING ELSE MEANS YOU'RE DONE.

;FOR SUBTEST#9, DO EXTRA MICROWORD TO LOAD THE FE FROM THE # AT SCADB.  THEN ADD FE TO #
;(THIS TO CAUSE THE MSB OF SC TO BE SET.  NOTE:  IF SC GETS WRONG VALUE, FAULT
;IS PROBABLY IN THE, AS YET UNTESTED, SCADDER.)

MUTTON: $FE     1               ;LOAD THE FE FROM # (VIA SCAD)
        $NUM    400             ;THE NUMBER TO USE IS 400
        $MWORD                  ;DO IT
        $SCAD   2,0,3           ;THIS TIME ADD FE TO # TO SET SC'S SIGN

;ALL SUBTEST COME HERE:

CALF:    MOVB   (R1)+,R0        ;GET NEXT MAGIC # FROM TABLE
        ASL     R0              ;SHIFT IT TO PUT IT IN CORRECT POSITION
        $NUM                    ;AND WRITE IT TO THE BUFFER
        $XBUF                   ;AND BUFFER TO CR+CLOCK SC.


;SEQ319

        SCDMCR                  ;COMPARE
        BR      BEEF            ;AND LOOP BACK.

;HERE IS THE STIMULUS TABLE OF MAGIC #'S FOR THIS TEST:

PORK:   .BYTE   20              ;SUBTEST#1:  #=40
        .BYTE   22              ;2:  #=44
        .BYTE   2               ;3:  #=4
        .BYTE   24              ;4:  #=50
        .BYTE   30              ;5:  #=60
        .BYTE   40              ;6:  #=100
        .BYTE   100             ;7:  #=200
        .BYTE   200             ;8:  #=400
        .BYTE   200             ;9:  #=400


;SEQ320

;HERE ARE THE MCOMP TABLES FOR THIS TEST:
VEAL:   .BYTE   2               ;SUBTEST#1:  2 CHANGES
        .BYTE   3               ;2B
        .BYTE   2               ;3
        .BYTE   3               ;4B
        .BYTE   3               ;5B
        .BYTE   1               ;6
        .BYTE   1               ;7
        .BYTE   1               ;8
        .BYTE   4               ;9

LAMB:   .BYTE   1               
        .BYTE   1               ;SUBTEST#1:  SC=40
        .BYTE   7
        .BYTE  0               ;SC .GE. 36 FALSE

        .BYTE   0
        .BYTE   40              ;SUBTEST#2:  SC=44
        .BYTE   1
        .BYTE   1
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE

        .BYTE   0
        .BYTE   40              ;SUBTEST#3:  SC=4
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 FALSE


;SEQ321

        .BYTE   0
        .BYTE   100             ;SUBTEST#4:  SC=50
        .BYTE   1
        .BYTE   1
        .BYTE   7
        .BYTE   0               ;SC .GE. 36 (REALLY 100) FALSE

        .BYTE   0
        .BYTE   200             ;SUBTEST#5:  SC=60
        .BYTE   1
        .BYTE   1
        .BYTE   7
        .BYTE   0               ;SC .GE. (REALLY 100) FALSE

        .BYTE   1
        .BYTE   2               ;SUBTEST#6:  SC=100

        .BYTE   1
        .BYTE   4               ;SUBTEST#7:  SC=200

        .BYTE   1
        .BYTE   10              ;SUBTEST#8:  SC-400

        .BYTE   1
        .BYTE   20              ;SUBTEST#9:  1000
        .BYTE   3
        .BYTE   20              ;FE=1000
        .BYTE   6
        .BYTE   1               ;SC SIGN
        .BYTE   10
        .BYTE   1               ;FE SIGN

        .EVEN


;SEQ322

.SBTTL TEST 26 (ESCD5):  SCADDER

.REM    %
THIS TEST CHECKS THE 10-BIT ADDER ON THE SCD BOARD.  IT LOADS THE SC AND
FE REGISTERS FROM THE MAGIC # FIELD.  PERFORMS AN ARITHMETIC ADDER FUNCTION
USING SC AND FE AS INPUTS AND STORES THE RESULT BACK IN THE SC AND FE.  AN
EXTRA MICROWORD IS PROVIDED WHICH SWITCHES THE ADDER MUXES TO CUT OFF
ANY SLOW PROPAGATING SIGNALS.  THE FIRST 3 MICROWORDS, FOUND IN THE
EBOX DIAGNOSTIC LISTING AT CRAM LOC:
        START5 =        SCM10
ARE MODIFIED ACCORDING TO THE STIMULUS TABLE'S DATA.  THE TEST RUNS AT
BURST SPEED.
%

;INITIALIZE POINTERS:

ESCD5:  MOV     #$MICRO,R1      ;PUT PTR TO MICROWORD BUFFER IN R1
        MOV     #STREET,R2              ;PUT PTRE TO MCOMP'S # TABLE IN R2
        MOV     #AVENUE,R3      ;PUT PTR TO MCOMP'S BYTE TABLE IN R3
        MOV     #DRIVE,R4               ;PUT PTR TO STIMULUS TABLE IN R4

;START MAIN LOOP BY FILLING IN THE # FIELD (TO LOAD THE FE) IN THE FIRST MICROWORD FROM
;THE STIMULUS TABLE:

ALLEY:  INSYNC                  ;NEW SUBTEST
        CMP     #^D13,SUBNR     ;DONE ALL 13?
        BGE     LANE            ;CONTINUE IF NOT
        JMP     NORMAL          ;DONE, FOLLOW THE YELLOW-BRICK ROAD.

LANE:   PUSH    R2              ;GET A REGISTER

        MOV     #SCM10,R2       ;PUT THE FIRST MICROWORD ADDRESS IN IT
        MOV     R2,R0           ;GET THE FIRST MICROWORD FROM THE
        GETMIC                  ;CRAM TO THE MICROWORD BUFFER

        MOV     (R4)+,R0        ;WRITE THE CORRECT # FIELD IN THE
        $NUM                    ;BUFFER FROM THE STIMULUS TABLE
        MOV     R2,R0           ;WRITE THE MDIFIED BACK
        WCRAM                   ;IN THE CRAM.


;SEQ323

;NOW PUT THE SECOND # (TO LOAD THE SC) INTO THE SECOND MICROWORD:

        INC     R2              ;NEXT CRAM ADDRESS
        MOV     R2,R0           ;GET NEXT MICROWORD INTO THE
        GETMIC                  ;BUFFER.

        MOV     (R4),R0         ;WRITE # FIELD IN THE BUFFER
        $NUM                    ;FROM THE STIMULUS TABLE

        MOV     R2,R0           ;PUT THE MICROWORD BACK INTO
        WCRAM                   ;THE CRAM

;AND MODIFY THE SCADDER FUNCTION FIELD IN THE THIRD MICROWORD:

        INC     R2              ;NEXT CRAM ADDRESS
        MOV     R2,R0           ;GET NEXT MICROWORD
        GETMIC

        MOV     (R4)+,R0                ;WRITE THE SCAD CONTROL FIELD IN
        SWAB    R0              ;THE BUFFER FROM THE TABLE
        ASR     R0
        BIC     #177770,R0      ;SCADA/FE & SCADB/SC ARE DEFAULTS (0).
        $SCAD
        MOV     R2,R0           ;PUT MICROWORD BACK INTO CRAM
        WCRAM                   ;AS MODIFIED.
        POP     R2              ;RESTORE MCOMP PTR TO R2

;RESET THE CRAM ADR, GIVE A BURST OF 5 EBOX CLOCKS AND COMPARE:

        MOV     #SCM10,R0       ;RESET CRAM ADR TO 1ST MICROWORD
        WWADR
        EBURST  5               ;CLOCK
        SCDMCR                  ;COMPARE
        BR      ALLEY           ;DO NEXT, IF NO ERRORS


;SEQ324

.REM%
HERE IS THE INPUT TABLE FOR THIS TEST.  EACH SUBTEST USES 2 WORDS AS FOLLOWS:

BIT#    WORD#1  WORD#2
;0      FE#08   SC#08
1       FE#07   SC#07
2       FE#06   SC#06

3       FE#05   SC#05
        
4       FE#04   SC#04
5       FE#03   SC#03

6       FE#02   SC#02
7       FE#01   SC#01
8       FE#00   SC#00

9       0       SCAD SEL 1
10      0       SCAD SEL 2
11      0       SCAD SEL 4

12      0       0
13      0       0
14      0       0

15      0       0
%

DRIVE:  .WORD   676     ;SUBTEST#1:  FE#=676
        .WORD   5110    ;SC#=110,SCAD/A-B

        .WORD   515     ;SUBTEST#2:  FE#=515
        .WORD   5666    ;SC#=666, SCAD/A-B

        .WORD   371     ;SUBTEST#3:  FE#=371
        .WORD   6161    ;SC#=161, SCAD/A OR B

        .WORD   27              ;SUBTEST#4:  FE#=27
        .WORD   2711    ;SC#=711, SCAD/A+B

        .WORD   146             ;SUBTEST#5: FE#=146
        .WORD   4607    ;SC#=607,SCAD/A+1

        .WORD   500     ;SUBTEST#6:  FE#=500
        .WORD   2137    ;SC#=137, SCAD/A+B

        .WORD   213     ;SUBTEST#7: FE#=213
        .WORD   4256    ;SC#=256,SCAD/A+1

        .WORD   110             ;SUBTEST#8: FE#=110
        .WORD   2654    ;SC#=654, SCAD/A+B


;SEQ325

        .WORD   167     ;SUBTEST#9:  FE#=167
        .WORD   5454            ;SC#K=454, SCAD/A-B

        .WORD   60      ;SUBTEST#10: FE#=60
        .WORD   7007            ;SC#=7, SCAD/AAND B
        .WORD   715     ;SUBTEST#11: FE#=715
        .WORD   4231    ;SC#=231, SCAD/A+1

        .WORD   536     ;SUBTEST#12: FE#=536
        .WORD   4271    ;SC#=271, SCAD/A+1

        .WORD   674     ;SUBTEST#13: FE#=674
        .WORD   5761    ;SC#=761, SCAD/A-B

;HERE ARE THE MCOMP TABLES FOR THE SCADDER TEST:

STREET: .BYTE   6       ;1
        .BYTE   6       ;2
        .BYTE   4       ;3
        .BYTE   4       ;4
        .BYTE   4       ;5
        .BYTE   6       ;6
        .BYTE   4       ;7
        .BYTE   6       ;8
        .BYTE   4       ;9
        .BYTE   1       ;10
        .BYTE   6       ;11
        .BYTE   6       ;12
        .BYTE   6       ;13

AVENUE: .BYTE   0       
        .BYTE   260     ;SUBTEST#1:  SC=1566
        .BYTE   1
        .BYTE   33
        .BYTE   2
        .BYTE   260     ;FE=1566
        .BYTE   3
        .BYTE   33
        .BYTE   6
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN



;SEQ326

        .BYTE   0
        .BYTE   270     ;SUBTEST#2: SC=1627
        .BYTE   1
        .BYTE   34
        .BYTE   2
        .BYTE   270     ;FE=1627
        .BYTE   3
        .BYTE   34
        .BYTE   6
        .BYTE   1               ;SC SIGN
        .BYTE   10
        .BYTE   1               ;FE SIGN

        .BYTE   0
        .BYTE   310     ;SUBTEST#3: SC=371
        .BYTE   1
        .BYTE   7
        .BYTE   2
        .BYTE   310     ;FE=371
        .BYTE   3
        .BYTE   7

        .BYTE   1
        .BYTE   37              ;SUBTEST#4: SC=1740
        .BYTE   3
        .BYTE   37              ;FE=1740
        .BYTE   6
        .BYTE   1
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .BYTE   0
        .BYTE   70      ;SUBTEST#5:  SC=147
        .BYTE   1
        .BYTE   3
        .BYTE   2
        .BYTE   70      ;FE=147
        .BYTE   3
        .BYTE   3


;SEQ327

        .BYTE   0
        .BYTE   370     ;SUBTEST#6: SC=1637
        .BYTE   1
        .BYTE   34
        .BYTE   2
        .BYTE   370     ;FE=1637
        .BYTE   3
        .BYTE   34
        .BYTE   6
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .BYTE   0
        .BYTE   140     ;SUBTEST#7: SC=214
        .BYTE   1
        .BYTE   4
        .BYTE   2
        .BYTE   140     ;FE=214
        .BYTE   3
        .BYTE   4

        .BYTE   0
        .BYTE   240     ;SUBTEST#8: SC=1764
        .BYTE   1
        .BYTE   37
        .BYTE   2
        .BYTE   240     ;FE=1764
        .BYTE   3
        .BYTE   37
        .BYTE   6
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .BYTE   0
        .BYTE   130     ;SUBTEST#9: SC=513

        .BYTE   1
        .BYTE   12
        .BYTE   2
        .BYTE   130     ;FE=513
        .BYTE   3
        .BYTE   12


;SEQ328

        .BYTE   7       
        .BYTE   0       ;SUBTEST#10: SC .GE. 36 (FALSE)

        .BYTE   0
        .BYTE   160     ;SUBTEST#11: SC=1716
        .BYTE   1
        .BYTE   36
        .BYTE   2
        .BYTE   160     ;FE=1716
        .BYTE   3
        .BYTE   36
        .BYTE   6
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .BYTE   0
        .BYTE   370     ;SUBTEST#12: SC=1537
        .BYTE   1
        .BYTE   32
        .BYTE   2
        .BYTE   370     ;FE=1537
        .BYTE   3
        .BYTE   32
        .BYTE   6
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .BYTE   0
        .BYTE   130     ;SUBTEST#13: SC=1713
        .BYTE   1
        .BYTE   36
        .BYTE   2
        .BYTE   130     ;FE=1713
        .BYTE   3
        .BYTE   36
        .BYTE   6       
        .BYTE   1       ;SC SIGN
        .BYTE   10
        .BYTE   1       ;FE SIGN

        .EVEN


;SEQ329

.SBTTL *PI*     PI BOARD TESTS
.SBTTL TEST 27(PIZZA1): PI "ON LEVEL" SET & CLR, "GEN LEVEL" SET & CLR, "ON, OFF, SYS

.REM    %
THIS TEST CHECKS THE ABILITY OF THE "PI ON LEVEL" FLOPS AND THE "PI GEN LEVEL"
FLOPS TO LOAD, HOLD, AND CLEAR.  ALSO THE "PI ACTIVE" FLOP AND THE ABILITY OF
"PI SYS CLR" TO CLEAR THE PI SYSTEM.
THE BASIC TEST SEQUENCE IS TO 1) SET ALL "PI ON  LEVELS". 2) INDIVIDUALLY
CLEAR EACH "PI ON LEVEL". 3) SET ALL "PI GEN LEVELS". 4) INDIVIDUALLY CLEAR
EACH "PI GEN LEVEL". 5) SET THE PI SYSTEM ACTIVE, CLEAR ACTIVE,
SET ALL "ON" AND "GEN" LEVEL FLOPS AND CLEAR ALL WITH A "PI SYS CLR".
%

PIZZA1: PMSG<STARTING PI TESTS\>

        MOV     #TEX05,R3       ;GET POINTER TO EBUS CONO DATA
        MOV     #TEX06,R4       ;GET POINTER TO CHANGING PI EXPECTED DATA
        
        INSYNC                  ;COUNT SUBTESTS
        CLEAR                   ;RESET THE KL10

        PI.CHK                  ;READ AND TEST PI FOR CORRECT RESET

;PI RESETS OK, ON TO HEART OF THIS TEST

        MOV     #MIC1PIZZA,R0   ;MICRO START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
;SET EXPECTED DATA TO EXPECTED DATA TABLE
TEX01:  MOVB    (R4)+,PIZEXP+1  ;"PI ON LEVEL"
        MOVB    (R4)+,PIZEXP+2  ;"PI GEN LEVEL"
        MOVB    #20,PIZEXP+4    ;"STATE HOLD" ONLY IS THE NORMAL CASE


;SEQ330

        INSYNC                  ;COUNT SUBTESTS
;SET UP TEST DATA FOR TRIP ACROSS THE EBUS
        MOVB    (R3)+,EWORD1+2  ;EBUS BITS 10-17
        MOVB    (R3)+,EWORD1+3  ;EBUS BITS 2-9
        $ROLWD  EWORD1          ;SET BITS TO CORRECT
        $ROLWD  EWORD1          ;EBUS POSITION

        CMP     #^D15,R5        ;SUBTEST 15 IS NEXT & ITS A SPECIAL CASE
        BNE     1$              ;BR IF NOT SUBTEST 15 COMING UP NEXT
        MOVB    #24,PIZEXP+4    ;IF ST 15,EXPECT "HONOR INTERNAL"TRUE
1$:     CMP     #^D23,R5        ;SETUP SUBTEST24 DURING SUBTEST 23
        BEQ     TEX02           ;BR AROUND "LOAD MIC1PIZZA" IF YES
        CMP     #^D21,R5        ;SETUP SUBTEST 22 DURING SUBTEST 21
        BNE     TEX03           ;GO DO "LOAD MIC1PIZZA" IF NOT SUBTEST 22 OR 24
TEX02:  MOV     #NOCONO!BIT15,R0        ;ON SUBTEST 22 & 24 DO "LOAD NOCONO"
        WWADR
        BR      TEX04            ;GO EXECUTE THE TEST
;"LOAD MIC1PIZZA"

TEX03:  MOV     #MIC1PIZZA!BIT15,R0     ;MICRO-CODE ADDRESS TO DO "CONO PI"
        WWADR

TEX04:  $ARLO2  EWORD1          ;EBUS DATA TO AR
        MOV     #^D23,R0        ;21 PI CLOCKS
        BURST                   ;TO DO "CONO PI"

        PI.CHK                  ;RESULTANT DATA CHECK

        TSTB    (R3)+           ;ADD 1 TO R3
        CMP     #^D25,R5        ;DONE ALL?
        BGT     TEX01           ;BR IF NO
        JMP     NORMAL          ;OUT IF YES


;SEQ331


;LIST OF EBOX CONO DATA

TEX05:  WD18    0,2000  ;SUBTEST 2 - "SET ON", ALL 0S
        WD18    0,2177  ;ST3 "SET ON" ALL 1S
        WD18    0,1100  ;ST 4 CLR LEVEL 1..ETC,ETC THRU ST 10
        WD18    0,1040  ;ST 5

        WD18    0,1020  ;ST 6
        WD18    0,1010  ;ST 7
        WD18    0,1004  ;ST 8
        WD18    0,1002  ;ST 9
        WD18    0,1001  ;ST 10
        WD18    0,4000  ;ST 11 "SET GEN" ALL 0S
        WD18    0,4177  ;ST 12 "SET GEN" ALL 1S
        WD18    2,0100  ;ST 13 CLR GEN 1 ...ETC ETC THRU ST 19
        WD18    2,0040  ;ST 14
        WD18    2,0020  ;ST 15
        WD18    2,0010  ;ST 16
        WD18    2,0004  ;ST 17
        WD18    2,0002  ;ST 18
        WD18    2,0001  ;ST 19
        WD18    0,0200  ;ST 20 SET "ACTIVE"
        WD18    0,0400  ;ST 21 CLR "ACTIVE"
        WD18    0,6377  ;ST 22 SET ALL,BUT "NO CONO" INHIBITS
        WD18    0,6377  ;ST 23 SET "ON", "GEN", & "ACTIVE",ALL 1S
        WD18    2,1777  ;ST 24 CLR ALL, BUT "NOCONO" INHIBITS
        WD18    1,000   ;ST 25 "PI SYS CLR"


;SEQ332

;BYTE TABLE OF CHANGES TO EXPECTED DATA FOR PI DCOMP
;CHANGES ARE IN PAIRS, THE FIRST IS INDEX+1 (PI ON), THE SECOND INDEX+2 (PI GEN)

TEX06:  .BYTE   0       ;ST 2
        .BYTE   0

        .BYTE   177     ;ST 3
        .BYTE   0

        .BYTE   77      ;ST 4
        .BYTE   0
        
        .BYTE   37      ;ST5
        .BYTE   0
        
        .BYTE   17      ;ST 6
        .BYTE   0

        .BYTE   7       ;ST 7
        .BYTE   0
        .BYTE   3       ;ST 8
        .BYTE   0
        .BYTE   1       ;ST 9
        .BYTE   0

        .BYTE   0       ;ST 10
        .BYTE   0

        .BYTE   0       ;ST 11
        .BYTE   0

        .BYTE   0       ;ST 12
        .BYTE   177

        .BYTE   0       ;ST 13
        .BYTE   77

        .BYTE   0       ;ST 14
        .BYTE   37

.REM    %
IF SUBTEST 15 FAILS BECAUSE "HONOR INTERNAL" IS LO, THEN
LOOK AT PRINT P15 AND CHECK THE LOGIC PRODUCING "P15 GEN INT".
WHEN "GEN LEVEL 4" IS THE HIGHEST PRIORITY AS IN THIS TEST, "GEN INT"
SHOULD BE TRUE AND SHOULD CAUSE HONOR INTERNAL
%

        .BYTE   0       ;ST 15
        .BYTE   17


;SEQ333

        .BYTE   0       ;ST 16
        .BYTE   7

        .BYTE   0       ;ST 17
        .BYTE   3

        .BYTE   0       ;ST 18
        .BYTE   1

        .BYTE   0       ;ST 19
        .BYTE   0

        .BYTE   200     ;ST 20
        .BYTE   0

        .BYTE   0       ;ST 21
        .BYTE   0

        .BYTE   0       ;ST 22
        .BYTE   0

        .BYTE   377     ;ST 23
        .BYTE   177

        .BYTE   377     ;ST 24
        .BYTE   177

        .BYTE   0       ;ST 25
        .BYTE   0
        .EVEN


;SEQ334

.SBTTL TEST 28 (PIZZA2): - CS LINES, LOAD/TEST RING COUNTER, "PI EBUS REQ" AND "EBUS PI"

.REM    %
THIS TEST IS DIVIDED INTO TWO SECTIONS.
THE FIRST SECTIONS TESTS THE "CS" LINES FOR EITHER STUCK CONDITION
AND FOR INTERFERENCE BETWEEN THE CS LINES.  IT DOES THIS BY
LOADING THE IR WITH INTERFERENCE PATTERNS, DUMPING THE IR
ONTO THE CS LINES, AND THEN READING THE CS LINES.
THE SECOND SECTION OF THE TEST CHECKS THE EBUS REQUEST LOGIC, THE
"EBUS PI GRANT" FLOP AND PARTIALLY CHECKS THE PI LOAD/TEST RING
COUNTER.  IT DOES THIS BY ISSUING "PI GEN" REQUESTS TO THE
PI BOARD, THEN BURSTING THE PI CLOCK PART WAY INTO THE REQUEST
CYCLE. THE PI BOARD IS THEN VERIFIED TO BE IN THE CORRECT STATE.
SEE THE EXPECT DATA TABLE FOR THE TEST PATTERNS USED IN THIS TEST.
%

PIZZA2: MOV     #KAN06,R4       ;PONT TO EXPECTED DATA BYTES
        MOV     #KAN05,R3       ;POINT TO NUMBER OF CLOCK TICS PER SUBTEST
                                ;AND ALSO RAM START ADDRESS FOR EACH SUBTEST
        MOV     #MIC2PI,R0      ;STARTING ADDRESS FOR TEST RAM CODE
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        MOVB    #4,EWORD1+3     ;GET SET TO FLOAT A ONE, IR03-IR09

KAN01:  INSYNC
        $ARLO2  EWORD1          ;LOAD THE AR (BUT NOT IR)
        EBURST  2               ;EXECUTE MICRO CODE TO LOAD THE IR.

        CMP     #^D8,R5         ;SUBTEST 8 SAYS ALL DONE THIS TEST PHASE
        BLE     1$              ;GO TO PHASE TWO
;SET UP EXPECTED DATA FOR THIS PARTICLAR SUBTEST
        MOVB    (R4)+,PIZEXP+3  ;DATA FOR CS05,CS06,CS00-CS03
        MOVB    (R4)+,PIZEXP+4  ;DATA FOR CS04

        PI.CHK                  ;LOOK AT EXPECTED PI BOARD RESULTS
        $ROLWD                  ;ROLL BIT TO THE LEFT ONE PLACE
        BR      KAN01           ;BACKWARDS IF NO


;SEQ335

;CONTINUE INTO SECTION TWO OF THIS TEST - THIS SECTION TESTS THE
;LOD/TEST RING COUNTER, "PI EBUS REQ", AND "EBUS PI GRANT" ALL ON THE PI BOARD
        ;AND PI PRINT "P15"

1$:     DEC     R5              ;DOWN SUBTEST NUMBER TO AVOID TOO MANY

KAN02:  INSYNC                  ;COUNT SUBTESTS
        MOV     (R3)+,R0        ;GET RAM ADDRESS FOR THIS SUBTEST
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        $ARLO2  KAN07           ;CONO DATA (SET ACTIVE AND GEN) TO EOX
        MOV     (R3)+,R0        ;GET BURST CLOCK COUNT FOR NUMBER MBOX TICS NEEDED
        BURST                   ;KL10 CLOCK GO

;NOW SET EXPECTED DATA FOR THIS TEST
        MOVB    (R4)+,PIZEXP+1  ;SET ACTIVE EXPECTED
        MOVB    (R4)+,PIZEXP+2  ;SET EXPECTED GEN LEVEL
        MOVB    (R4)+,PIZEXP+3  ;SET EXPECTED CONTROL SIGNALS
        MOVB    (R4)+,PIZEXP+4  ;SET EXPECTED FOR CONTROL AND TIMING SIGNALS


        CMP     #^D10,R5        ;SUBTEST 10??
        BEQ     KAN04           ;BR IF YES
KAN03:  PI.CHK                  ;TEST PI BOARD STATE
        CMP     #^D12,R5                ;DONE ALL SUBTESTS?
        BGT     KAN02           ;BR BACK IF NO
        JMP     NORMAL          ;OTHERWISE, ALL DONE

;SUBTEST 10 ONLY
KAN04:  PI.CHK                  ;TEST OK SO FAR

        DFXCTT          ;NOW SET "MR RESET"
        SETMR
        CLRB    PIZEXP+1        ;RESET CLEARS ACTIVE
        CLRB    PIZEXP+2        ;AND GEN
        MOVB    (R4)+,PIZEXP+4  ;EXPECT SHOULD CHANGE
        BR      KAN03           ;DO PI CHK AND BACK TO MAINLINE


;SEQ336

;C-RAM ADDRESSES & NUMBER OF CLOCK TICS FOR SUBTESTS 7-11

KAN05:  .WORD   MPI2.1          ;SUBTEST 8
        .WORD   ^D17+DRPCYC+^D5 ;5 PI TICS

        .WORD   MPI2.2          ;SUBTEST 9
        .WORD   ^D19+DRPCYC+^D7 ;7 PI TICS

        .WORD   MPI2.1          ;SUBTEST 10
        .WORD   ^D17+DRPCYC+^D4 ;4 PI TICS

        .WORD   MPI2.1          ;SUBTEST 11
        .WORD   ^D17+DRPCYC+^D2 ;2 PI TICS

        .WORD   MPI2.5          ;SUBTEST 12
        .WORD   ^D4+DRPCYC+^D5  ;5 PI TICS

;NOW EXPECTED BYTES FOR EACH SUBTEST.  FOR CS00-CS06 OR
;TO BE PLACED AT PIZEXP+2 (GEN LEVEL 5 UP) & PIZEXP+4 (PI CONTROL & TIMING CHANGES)
KAN06:  .BYTE   40              ;ST1 - CS06
        .BYTE   20              ;CS04 = 0

        .BYTE   100             ;ST2 - CS05
        .BYTE   20              ;CS04 = 0

        .BYTE   0               ;ST3 - CS=0
        .BYTE   30              ;CS04 = 1

        .BYTE   1               ;ST4 - CS03
        .BYTE   20              ;CS04 = 0

        .BYTE   2               ;ST5 - CS02
        .BYTE   20              ;CS04 = 0

        .BYTE   4               ;ST6 - CS01
        .BYTE   20              ;CS04 = 0

        .BYTE   10                      ;ST7 - CS00
        .BYTE   20              ;CS04 = 0


;SEQ337

;DONE WITH "CS" EXPECTED, NOW EXPECTED FOR TIMING & CONTROL LOGIC
        .BYTE   200             ;ACTIVE
        .BYTE   4               ;ST8 - GEN5
        .BYTE   56              ;PI1 & SEL PHY 8 IS TRUE ON RESET
        .BYTE   75              ;"EBUS REQ", "EBUS PI GRANT", "CS04" & HONOR INTERNAL

        .BYTE   200             ;ACTIVE
        .BYTE   4               ;ST9 - GEN5
        .BYTE   0               ;NO GRANT, NO CONROL SIGNALS
        .BYTE   24              ;NO "REQ" OR "GRANT", BUT HONOR INTERNAL

        .BYTE   200             ;ACTIVE
        .BYTE   4               ;ST10 -GEN5
        .BYTE   0               ;NO GRANT, NO CONTROL SIGNALS
        .BYTE   25              ;"EBUS REQ" & HONOR INTERNAL    
        .BYTE   20              ;"EBUS REQ" TURNS OFF WHEN RESET COMES UP & SO DOES HONO

        .BYTE   200             ;ACTIVE
        .BYTE   4               ;ST11 - GEN5
        .BYTE   0               ;NO GRANT, NO CONTROL SIGNALS
        .BYTE   24              ;NO "REQ", NO "GRANT" BUT HONOR INTERNAL

        .BYTE   0               ;NO ACTIVE
        .BYTE   0               ;ST12 - NO GEN
        .BYTE   0
        .BYTE   20              ;NO NOTHIN

KAN07:  WD36    42,0400,0000    ;SET PI GEN ON & PI ACTIVE & GEN LEVEL 5
        .EVEN


;SEQ338

.SBTTL TEST 29 (PIZZA3): PIR FLOPS, PIR EN, PI REQ SET, PIH FLOPS, PI CLRS, PIR/PIH PRI

.REM    %
THIS TEST EXERCISES AND CHECKS THE FOLLOWING PI BOARD LOGIC.  THE PIR1-PIR7
FLIP FLOPS.  THE PIR/PIH PRIORITY ENCODER PAIR.  PI REQ SET DECODER, PI CLR DECODER.
THE PIH1-PIH7 FLIP FLOPS AND THE PIR EN GATES.
THE BASIC TEST PROCEDURE IS:  1) SET PI CYCLE TO HOLD THE "LOAD/TEST" RING COUNTER
2) DO A CONO PI TO SET ONE OR SEVERAL GEN'S.  3) DROP PI CYCLE TO ENABLE THE "LOAD/TEST"
RING COUNTER TO ADVANCE.  THIS SHOULD LOAD THE PIR FLOPS.  4) STOP & READ THE STATE OF THE
PI BOARD TO SEE IF THE PIR'S SET.  5) SET PI CYCLE THEN DO A "SPEC/SAVE FLAGS" WHICH LOAD
THE PIH FLOPS VIA THE PIR EN GATES.  6) AGAIN READ THE STATE OF THE PI BOARD TO CHECK THAT
THE PIH FLOPS DID LOAD.  7) DO A "PI DISMISS" THEN VERIFY THAT THE HIGHEST LEVEL PIH WAS
%
PIZZA3: MOV     #WASH04,R4      ;GET POINT TO TEST GEN DATA
        MOV     #WASH06,R3      ;POINTER TO MCOMP CHANGES
        MOV     #WASH05,R2      ;POINTER TO MCOMP NUMBER OF CGHANGES

        MOVB    #200,PIZEXP+1   ;ALWAYS EXPECT "PI ACTIVE" ON
        MOVB    #42,EWORD1+3    ;SET EBUS BIT10, "CONO PI" WILL ALWAYS SET PI ACTIVE & GE

WASH01: INSYNC                  ;COUNT NUMBER OF SUBTESTS
        MOV     #MIC3PI,R0      ;MICRO-CODE STARTING ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
        MOVB    (R4)+,R0        ;GET BITS FOR SETTING APPROPRIATE GEN LEVELS THIS SUBTES
        ASL     R0              ;JUSTIFY GEN DATA BITS AT EBUS BIT 17
        ASL     R0
        BIS     R0,EWORD1+2     ;SET GEN BITS IN EBUS WORD
        $ARLO2  EWORD1          ;CONO DATA TO THE AR

        MOV     #^D25,R0        ;NEED 25 MBOX TICS FOR BURST
        BURST                   ;RUN THE KL10 MBOX CLOCK
        ADD     #4,R3           ;MCOMP MUST POINT TO CORRECT TABLE ENTRY
        $MCOMP                  ;CHANGE EXPECTED DATA FOR THIS SUBTEST
        PI.CHK                  ;READ & TEST THE PI BOARD
        $RCOMP                  ;RESTORE EXPECTED TO RESET STATE


;SEQ339

        INSYNC                  ;COUNT SUBTESTS
        EBURST  2               ;EXECUTE TWO MICRO WORDS IN ORDER TO SET PIH FLOPS.
        SUB     #12,R3          ;MCOMP POINTER BACKS UP FOR THE 2ND SUBTEST OF A TRIO
        $MCOMP                  ;CHANGE EXPECTED
        PI.CHK          ;READ & TES PI BOARD
        $RCOMP                  ;RESTORE DCOMP'S EXPECTED DATA

        INSYNC                  ;COUNT SUBTESTS
        ADD     #2,R3           ;UPDATE MCOMP ACTUAL CHANGES POINTER
        EBURST  2               ;EXECUTE MICRO CODE TO DISMISS PI HOLD AT HIGHEST LEVEL
        $MCOMP                  ;CHANGE EXPECTED
        PI.CHK                  ;READ & TEST PI BOARD
        $RCOMP                  ;RESTORE EXPECTED TO RESET STATE
        BIC     #774,EWORD1+2   ;CLEAR 36 BIT BUFFER OF GENS.
        SUB     #3,R2           ;NUMBER CHANGES PER 3 SUBTESTS IS IDENTICAL
        CMP     #^D21,R5        ;DONE WITH THIS SECTION OF TEST?
        BGT     WASH01          ;BR BACK & CONTINUE IF NO


;SEQ340

.REM    %
THIS BEGINS THE SECOND PHASE OF THE PI3 TEST, WHERE WE ARE CHECKING THE
DUAL PRIORITY ENCODERS THAT CHOOSE BETWEN PI REQUESTS AND PI HOLD LEVELS AND
DECIDES WHICH SHOULD BE PROCESSED FIRST
%

        BICB    #BIT7,PIZFUN+4          ;LET DCOMP DO MORE COMPARES
        BISB    #BIT7,PIZFUN+6          ;READ PI4,PI2,PI1 FROM SCAD BOARD
        ADD     #3,R2                   ;FIX MCOMP NUM OF CHANGES PTR
        MOV     #PI3.1A!BIT15,WASH4B    ;TESTS THAT USE PIH DISMISS NEED THIS

WASH02: INSYNC                  ;COUNT SUBTESTS
        CLEAR                   ;RESET THE KL10

        MOVB    (R4)+,R0        ;TEST DATA TO SET PI HOLD FLOPS
        JSR     PC,SETPIH               ;GO SET SEVERAL PI HOLD FLOPS
        MOV     #M3.1PI!BIT15,R0        ;START ADDRESS FOR THIS SECTION OF RAM CODE
        JSR     PC,RUN.GO               ;LOAD DIAG ADR REG 7 SET "RUN"

;THE PI HOLD FLOPS ARE NOW SET -- LOAD MOE "CONO" DATA IN ORDER TOI SET
;THE APPROPRIATE PI REQUEST FLOPS
        BIC     #774,EWORD1+2           ;CLEAR 36 BIT BUFFER GENS
        MOVB    (R4)+,R0                ;GET MORE GEN DATA
        ASL     R0              ;JUSTIFY DATA AT EBUS BIT17
        ASL     R0
        BIS     R0,EWORD1+2     ;READY TO SET GENS
        $ARLO2  WASH4A          ;CLEAR OLD LEFTOVER GENS
        JSR     PC,WASHGO               ;GO EXECUTE THE TESTS

        BIC     #774,EWORD1+2   ;CLEAR GEN BITS FROM THE 36 BIT BUFFER
        CMP     #^D27,R5                ;TIME FOR NEW MICRO-CODE DISPATCH
        BNE     1$                      ;BR IF NOT
        MOV     #PI3.1B!BIT15,WASH4B    ;GET NEW DISPATCH ADDR IF YES
1$:     CMP     #^D43,R5                ;DONE THIS SECTION OF TEST?
        BGT     WASH02          ;BACK IF MORE TO DO, FALL THRU IF DONE



;SEQ341

.REM    %
THE LAST 3 SUBTESTS ARE FINISHING THE LOGIC TEST FOR THE "PIR EN 1-7"
LOGIC.  THEY TEST THE 2-INPUT AND GATES THAT FEED THE "PIR EN" "OR" GATES.
%

        MOVB    #4,PIZEXP+5     ;SCAD TRAP MIX 32(PI4) DEFAULTS TRUE
WASH03: MOV     (R4)+,R0        ;NEED ANY PIH'S??
        JSR     PC,SETPIH       ;GO SET THEM IF YES
        MOV     #M3.1PI,R0      ;MICO-CODE START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIA D ADR RE & SET "RUN"

        $ARLO2  WASH4A          ;CONO  DATA TO CLEAR ALL PI GENE LEVELS CURRENTLY6 UP
        MOV     (R4)+,EWORD1+2  ;GET OCNO DATA TO SET ACTIVE OR GENS
        INSYNC                  ;COUNT SUBTESTS
        JSR     PC,WASHGO               ;GO EXECUTE THE TEST
        CMP     #^D46,R5        ;SUBTEST 46 DONE YET?
        BLT     WASH03          ;BACK IF NOT
        JMP     NORMAL          ;ALL DONE - ALL OK


;SEQ342
WASHGO: MOV     #^D19,R0        ;EXECUTE CONO TO CLEAR CURRENT GEN STATUS
        BURST                   ;EXECUTE IT NOW

        MOV     WASH4B,R0       ;NECESSARY DISPATCHING IN THE MICRO-CODE
        WWADR                   ;WRITE DISPATCH ADDR TO DIAG ADDR REG
        JSR     PC,NPIDIS       ;SET "RUN"
        $ARLO2  EWORD1          ;SET GENS FOR THIS TEST

        MOV     #^D28,R0        ;NOW EXECUTE ENOUGH MTICS TO
        BURST                   ;SET UP THE PROPER PI STRATE

        $MCOMP                  ;CHANGE EXPECTED
        PI.CHK                  ;CHECK THE PI BOARD
        $RCOMP                  ;RESTORE PI EXPECTED DATA
        RTS     PC              ;RETURN
;THIS IS A LIST OF BITS USED TO SET "GEN LEVELS" ON THE PI BOARD DURING THE
;PI BOARD TEST.  IN EACH BYTE, BIT6-BIT0 REPRESENT "SET GEN1-SET GEN7" RESPECTIVELY

WASH4B: .WORD   0               ;WORD OF STORAGE FOR DISP ADDR
WASH4A: WD36 0201,7700,0000     ;SET ALL GENS
WASH04: .BYTE   1               ;SUBTEST 1-3, GEN7,PIR7,PIH7,PI 7 CLR
        .BYTE   2               ;SUBTEST 4-6, GEN6,PIR6,PIH6,PI 6 CLR
        .BYTE   4               ;SUBTEST 7-9, GEN5,PIR5,PIH5,PI 5 CLR
        .BYTE   10              ;SUBTEST 10-12, GEN4,PIR4,PIH4,PI 4 CLR
        .BYTE   20              ;SUBTEST 13-15,GEN3,PIR3,PIH3,PI 3 CLR
        .BYTE   40              ;SUBTYEST 16-18, GEN2,PIR2,PIH2,PI 2 CLR
        .BYTE   100             ;SUBTEST 19-21, GEN1,PIR1,PIH1,PI 1 CLR

;THESE ADDITIONAL GEN PATTERNS CHECK THE "PI HOLD" PRIORITY ENCODER.
;IT ALSO CHECKS THE "PI4,PI2,PI1,PI REQ" PRIORITY ENCODERS.  A FAILURE DURING ONE OF
;THESE SUBTESTS INDICATE THAT ONE OF THE THREE PRIORITY ENCODERS IS BAD.

        .BYTE   3               ;SUBTEST 22, PIH6 & 7
        .BYTE   0               ;NO PIR'S

        .BYTE   6               ;SUBTEST 23, PIH5 & 6
        .BYTE   0               ;NO PIR'S

        .BYTE   30              ;SUBTEST 24, PIH3 & 4
        .BYTE   0               ;NO PIR'S

        .BYTE   102             ;SUBTEST 25, PIH1 & 6
        .BYTE   0               ;NO PIR'S

        .BYTE   44              ;SUBTEST 26, PIH2 & 5
        .BYTE   0               ;NO PIR'S

        .BYTE   11              ;SUBTEST 27, PIH4 & 7
        .BYTE   0               ;NO PIR'S


;SEQ343

;THEE PATTERNS ARE USED TO SET UP COMBINATIONS OF PI H9LD FLOPS AND
;PI REQ FLOPS IN ORDER TO TEST THE DUAL "PI4-PI2-PI1" PRIORITY ENCODERS


        .BYTE   63              ;SUBTEST 28 - PIH 2,3,6,7
        .BYTE   140             ;PIR 1,2
        
        .BYTE   3               ;SUBTEST 29 - PIH 6,7
        .BYTE   5               ;PIR 5,7

        .BYTE   1               ;SUBTEST 30 - PIH 7
        .BYTE   3               ;PIR 6,7

    

        .BYTE   33              ;SUBTEST 31 - PIH 3,4,6,7
        .BYTE   50              ;PIR 2,4

        .BYTE   4               ;SUBTEST 32 - PIH 5
        .BYTE   13              ;PIR 4,6,7

        .BYTE   6               ;SUBTEST 33 - PIH 5,6
        .BYTE   0               ;NO PIR

        .BYTE   133             ;SUBTEST 34 - PIH 1,3,4,6,7
        .BYTE   57              ;PIR 2,4,5,6,7

        .BYTE   3               ;SUBTEST 35 - PIH 6,7
        .BYTE   2               ;PIR 6

        .BYTE   1               ;SUBTEST 36 - PIH 7
        .BYTE   1               ;PIR 7

        .BYTE   20              ;SUBTEST 37 -PIH 3
        .BYTE   0               ;NO PIR

        .BYTE   40              ;SUBTEST 38 - PIH 2
        .BYTE   0               ;NO PIR

        .BYTE   1               ;SUBTEST 39 - PIH 7
        .BYTE   0               ;NO PIR
        .BYTE   2               ;SUBTEST 40 - PIH 6
        .BYTE   0               ;NO PIR

        .BYTE   56              ;SUBTEST 41 - PIH 2,4,5,6
        .BYTE   67              ;PIR 2,3,5,6,7

        .BYTE   23              ;SUBTEST 42 - PIH 3,6,7
        .BYTE   33              ;PIR 3,4,6,7

        .BYTE   17              ;SUBTEST 43 = PIH 4,5,6,7
        .BYTE   15              ;PIR 4,5,7


;SEQ344

.EVEN
;TEST DATA FOR SUBTEST 44
        .WORD   0               ;NO PIH
        .WORD   200*4           ;PI ACTIVE AND NO GENS

;TEST DATA FOR SUBTEST 45


        .WORD   0               ;PNO PIH
        .WORD   4577*4          ;BITS FOR GEN1-GEN7,NO ACTIVE

;TEST DATA FOR SUBTEST 46
        .WORD   177             ;PIH1-7
        .WORD   40000           ;BIT FOR CONO PI SYS CLEAR

;HERE IS THE TABLE FOR NUMBER OF MCOMP CHANGES FOR EACH SUBTEST

WASH05: .BYTE   3               ;SUBTEST 1,4,7,10,13,16,19
        .BYTE   4               ;ST 2,5,8,11,14,17,20
        .BYTE   4               ;ST 3,6,9,12,15,18,21

        .BYTE   3               ;ST 22
        .BYTE   2       ;ST 23
        .BYTE   2               ;ST 24
        .BYTE   2               ;ST 25
        .BYTE   3               ;ST 26
        .BYTE   3               ;ST 27
        .BYTE   5               ;ST 28
        .BYTE   6               ;ST 29

        .BYTE   5               ;ST 30
        .BYTE   5               ;ST 31
        .BYTE   5               ;ST 32
        .BYTE   3               ;ST 33
        .BYTE   3               ;ST 34
        .BYTE   4               ;ST 35
        .BYTE   5               ;ST 36
        .BYTE   3               ;ST 37
        .BYTE   2               ;ST 38
        .BYTE   3               ;ST 39

        .BYTE   2               ;ST 40
        .BYTE   4               ;ST 41
        .BYTE   5               ;ST 42
        .BYTE   4               ;ST 43
        .BYTE   0               ;ST 44
        .BYTE   2               ;ST 45
        .BYTE   1               ;ST 46


;SEQ345

;TABLE OF ACTUAL BYTE CHANGES FOR MCOMP

WASH06: .BYTE   0              
        .BYTE   1               ;SUBTEST 2 - PIH7
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL
        .BYTE   2
        .BYTE   1               ;SUBTEST 1,2,3 - PI GEN7
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   75              ;EBUS PI GRANT, PI4, EBUS REQ,HONOR INTERNAL
        .BYTE   0               ;SUBTEST 3 - PIH7 DISMISSED
        .BYTE   0
        .BYTE   2
        .BYTE   1               ;SUBTEST 1,2,3 - PI GEN7
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   0
        .BYTE   2               ;SUBTEST 5 - PIH6

        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4, HONOR INTERNAL
        .BYTE   2
        .BYTE   2               ;SUBTEST 4,5,6 - PI GEN6
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   75              ;EBUS PI GRANT, PI4, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0               ;SUBTEST 6 - PIH6 DISMISSED
        .BYTE   2
        .BYTE   2               ;SUBTEST 4,5,6 - PI GEN6
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL


;SEQ346


        .BYTE   0
        .BYTE   4               ;SUBTEST #8 - PIH5
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL
        .BYTE   2
        .BYTE   4               ;SUBTEST 7,8,9 - PI GEN5
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   75              ;EBUS PI GRANT, PI4, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0               ;SUBTEST 9 - PIH5 DISMISSED
        .BYTE   2
        .BYTE   4               ;SUBTEST 7,8,9 - PI GEN5
        .BYTE   3
        .BYTE   56              ;PI1

        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT, PI4, HONOR INTERNAL
        .BYTE   0
        .BYTE   10            ;SUBTEST 11 - PIH4
        .BYTE   4
        .BYTE   74              ;EBUS PI GRNT,PI4, HONOR INTERNAL
        .BYTE   2
        .BYTE   10              ;SUBTEST 10,11,12 - PI GEN4
        .BYTE   3
        .BYTE   16              ;NEITHER PI2 OR PI1

        .BYTE   4
        .BYTE   75              ;EBUS PI GRNT, PI4, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0               ;SUBTEST 12 - PIH4 DISMISSED
        .BYTE   2
        .BYTE   10              ;SUBTEST 10,11,12 - PI GEN4
        .BYTE   3
        .BYTE   16              ;NEITHER PI2 OR PI1
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL


;SEQ347
        
        .BYTE   0
        .BYTE   20              ;SUBTEST 13 - PIH3
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   2
        .BYTE   20              ;SUBTEST 13,14,15 PI GEN3
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   65              ;EBUS PI GRANT, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0       ;SUBTEST 15 - PIH3 DISMISSED
        .BYTE   2
        .BYTE   20              ;SUBTEST 13,14,15 PI GEN3
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   0
        .BYTE   40              ;SUBTEST 16 - PIH2
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   2
        .BYTE   40              ;SUBTEST 16,17,18 - PI GEN2
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   65              ;EBUS PI GRANT, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0               ;SUBTEST 18 - PIH2 DISMISSED
        .BYTE   2
        .BYTE   40              ;SUBTEST 16,17,18 - PI GEN2
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL

;SEQ348

        .BYTE   0
        .BYTE   100             ;SUBTEST 19 - PIH1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   2
        .BYTE   100             ;SUBTEST 19,20,21 - PI GEN1
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   65              ;EBUS PI GRANT, EBUS REQ,HONOR INTERNAL
        .BYTE   0
        .BYTE   0               ;SBUTEST 21 - PIH1 DISMISSED
        .BYTE   2
        .BYTE   100             ;SUBTEST 19,20,21 - PI GEN1
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL

        .BYTE   0
        .BYTE   1               ;SUBTEST 22 - PI H6 DISMISSED, PIH7 STAYS
        .BYTE   5
        .BYTE   6               ;SCAD PI4,PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        
        .BYTE   0
        .BYTE   2               ;SUBTEST 23 - PIH5 DISMISSED, PIH6 STAYS
        .BYTE   5
        .BYTE   6               ;SCAD PI4,PI2
        
        .BYTE   0
        .BYTE   10              ;SUBTEST 24 - PIH3 DISMISSED, PIH4 STAYS
        .BYTE   5
        .BYTE   4               ;SCAD PI4

        .BYTE   0
        .BYTE   2               ;SUBTEST 25 - PIH1 DISMISSED, PIH6 STAYS
        .BYTE   5
        .BYTE   6               ;SCAD PI4,PI2


;SEQ349

        .BYTE   0
        .BYTE   4               ;SUBTEST 26 - PIH2 DISMISSED, PIH5 STAYS
        .BYTE   5
        .BYTE   4               ;SCAD PI4
        .BYTE   6
        .BYTE   10              ;SCAD PI1

        .BYTE   0
        .BYTE   1               ;SUBTEST 27 - PIH4 DISMISSED, PIH7 STAYS
        .BYTE   5
        .BYTE   6               ;SCAD PI4,PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   0
        .BYTE   63              ;SUBTEST 28 - PIH 2,3,6, & 7
        .BYTE   2
        .BYTE   140             ;GEN1&2
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT & HONOR INTERNAL
        .BYTE   6
        .BYTE   10              ;SCAD PI1

        .BYTE   0
        .BYTE   3               ;SUBTEST 29 - PIH 6 & 7
        .BYTE   2
        .BYTE   5               ;PI GEN 5 & 7
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT, PI4, HONOR INTERNAL
        .BYTE   5
        .BYTE   4       ;SCAD TRAP MIX 32 (PI)
        .BYTE   6               
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)


;SEQ350

        .BYTE   0
        .BYTE   1               ;SUBTEST 30 - PIH7
        .BYTE   2
        .BYTE   3               ;PI GEN 6 & 7
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,K PI4, HONOR INTERNAL
        .BYTE   5
        .BYTE   6               ;SCAD TRAP MIX 32 & 33 (PI4, PI20

        .BYTE   0
        .BYTE   33              ;SUBTEST 31 - PIH 3,4,6 & 7
        .BYTE   2
        .BYTE   50              ;PI GEN 2 & 4
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   64              ;EBUS PI, GRANT, HONOR INTERNAL
        .BYTE   5       
        .BYTE   2               ;SCAD TRAP MIX 33 (PI2)


        .BYTE   0
        .BYTE   4               ;SUBTEST 32 - PIH5
        .BYTE   2
        .BYTE   13              ;PI GEN 4,6,7
        .BYTE   3
        .BYTE   16              ;SE PHY8 DEFAULT
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT, PI4,HONONR INTERNAL
        .BYTE   5
        .BYTE   4               ;SCAD TRAP MIX 32 (PI4)

        .BYTE   0
        .BYTE   6               ;SUBTEST 33 - PIH 5 & 6
        .BYTE   5
        .BYTE   4               ;SCAD TRAP MIX 32 (PI4)
        .BYTE   6
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)

        .BYTE   0
        .BYTE   133             ;SUBTEST 34 - PIH 1,3,4,6,7
        .BYTE   2
        .BYTE   57              ;PI GEN 2,4,5,6,7
        .BYTE   6
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)


;SEQ351


        .BYTE   0
        .BYTE   3               ;SUBTEST 35 - PIH 6 & 7
        .BYTE   2
        .BYTE   2               ;PI GEN6
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   6               ;SCAD TRAP MIX 32,33 (PI4, PI2)


        .BYTE   0
        .BYTE   1               ;SUBTEST 36 - PIH7
        .BYTE   2
        .BYTE   1               ;PI GEN7
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   6               ;SCAD TRAP MIX 32,33 (PI4, PI2)
        .BYTE   6
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)

        .BYTE   0
        .BYTE   20              ;SUBTEST 37 - PIH3
        .BYTE  5
        .BYTE   2               ;SCAD TRAP MIX 33 (PI2)
        .BYTE   6
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)

        .BYTE   0
        .BYTE   40              ;SUBTEST 38 - PIH2
        .BYTE   5
        .BYTE   2               ;SCAD TRAP MIX 33 (PI2)

        .BYTE   0
        .BYTE   1               ;SUBTEST 39 - PIH7
        .BYTE   5
        .BYTE   6               ;SCAD TRAP MIX, 32,33 (PI4, PI2)
        .BYTE   6
        .BYTE   10              ;SCAD TRAP MIX 34(PI1)


;SEQ352

        .BYTE   0
        .BYTE   2               ;SUBTEST 40 - PIH6
        .BYTE   5
        .BYTE   6               ;SCAD TRAP MIX 32,33(PI4,PI2)

        .BYTE   0
        .BYTE   56              ;SUBTEST 41 - PIH 2,4,5,6,
        .BYTE   2
        .BYTE   67              ;PI GEN 2,3,5,67
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   2               ;SCAD TRAP MIX 32 (PI2)
        .BYTE   0
        .BYTE   23              ;SUBTEST 42 - PIH 3,6,7
        .BYTE   2
        .BYTE   33              ;PI GEN 3,4,6,7
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   2               ;SCAD TRAP MIX 33 (PI2)
        .BYTE   6       
        .BYTE   10              ;SCAD TRAP MIX 34 (PI1)

        .BYTE   0
        .BYTE   17              ;SUBTEST 43 - PIH 4,5,67
        .BYTE   2
        .BYTE   15              ;PI GEN 4,5,7
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5       
        .BYTE   4               ;SCAD TRAP MIX 32 (PI4)

        .BYTE   1
        .BYTE   0               ;NO ACTIVE FOR THIS SUBTEST
        .BYTE   2
        .BYTE   177             ;SUBTEST 45 - PI GEN 1-7

        .BYTE   1
        .BYTE   0               ;SUBTEST 46 - PI ACTIVE CLEARED BY SYS CLR
.EVEN



;SEQ353

.SBTTL TEST 30 (PIZZA4): PI "TIM1-TIM7-PI COMP" RING CNTR & "TIMER DONE" CNTR

.REM    %
THE FOLLOWING TWO PI BOARD TESTS ARE POSSIBLY TWO OF THE MOST
CONFUSING AND DIFFICU.LT TESTS TO UNDERSTAND IN THE WHOLE EBOX
DIAGNOSTICL.  THE CONNECTION BETWEEN THE ERROR SYMPTOM PRINTED
ON THE TELETYPE AND THE ACTUAL HARDWARE FAULT CAUSING THE
SYMPTOM IS VERY DIFFICULT TO EXPLAIN EVEN WITH AN EXCELLENTUNDERSTANDING OF HOW THIS PART OF THE PI BOARD IS INTENDED TO
WORK.
        THIS TEST IS INTENDED TO CHECK TWO COUNTERS ON THE
PI BOARD.  1) THE PI "TIME STATE" COUNTER IS A PAIR OF SHIFT
REGISTERS ON PRINT "PI12" WHOSE 8 OUTPUTS ARE LABELLED: TIM1,
TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, COMP. AND 2) THE "TIOMER
DONE" COIUNTER WHICH CONSISTS OF 2 BINARY COUNTERS CONNECTED
SERIALLY AND WHOSE ONLY OUTPUT IS LABELLED "TIMER DONE".
        THESE TWO COUTNERS OPERATE INDEPENDENTLY, BUT MUST WORK
TOGETHER.  WHEN A CYCLE IS STARTED THE TIME STATE COUNTER GOES
TO TIME STATE "TIM1".  IT REMAINS STATIC, IN "TIM1" WHILE THE
"TIMER DONE" COUNTER BEGINS COUNTING.  AFTER "TIMER DONE" COUNTER
HAS COUNTED A SPECIFIE NUMBER OF MBOX TICKS, IT SETS THE FLOP
"TIMER DONE'.  THIS ACT TURNS THE TIME STATE COUNTER ON AND IT
ADVANCES FROM "TIM1" TO "TOIME".  AGAIN IT WAITS FOR "TIME DONE" TO
COUNT BEFORE IT CAN ADVANCE.  THIS TEST WILL OPERATE AS FOLLOWS:
IT WILL ISSUE ONE TOO FEW MTICS TO SET "TIM1". IT WILL VERIFY THAT
TIM1 DOES NOT COME UP.  IT WILL RESET THE PI BOARD AND ISSUE
EXACTLY ENOUGH TICS TO SET "TIM1" THEN VERIFYT HAT "TIM1"
DOES OCCUR.  NEXT, RESET THE PI BOARD, ISSUE ONE TOO FEW TICS TO
SET "TIM2".  VERIFY "TIM2" DOES NOT COME UP.  RESET, ISSUE EXACTLY
ENOUGH TICS TO SET "TIOM2".  VERIFY "TIM2" COMES UP.  RESET.
SAME PROCEDURE FOR "TIM3", "TIM4" "TIM5", "TIM6", & "TIM7"
        POSSIBLE FAULTS:  FAULTS IN THESE TWO COUNTERS CAN BE
ISOLATED TO THE PIB OARD, BUT THE LOGIC FAILURE ON THE BOARD
ITSELF IS DIFFICULT IF NOT IMPOSSIBLE TO CALL OUT WITH SOFTWARE.
ONLY BY PUTTING THE BOARD ON EXTENDER CAN THE PROBLEM BE FOUND
%


;SEQ354

PIZZA4: MOV     #200,PIZMSK+4   ;LOOK AT "PI TIMER DONE" THIS TEST
        MOV     #MICH4A,R1      ;GET POINTER TO CRAM START ADDRESSES
        MOV     #MICH05,R2      ;GET POINTER TO NUMBER OF CHANGES TABLE
        MOV     #MICH06,R3      ;GET POINTER TO ACTUAL BYTE TABLE OF CHANGES
        MOV     #MICH03,R4      ;POINTER TO LIST OF NECESSARY CLOCK COUNTS
        MOV     #21004,EWORD1+2 ;SET 36 BITS TO DO "GEN SET", "PI ACTIVE", "SET GEN LEVE
        MOVB    #1,PIZEXP+2     ;ALWAYS EXPECT "GEN7"
        MOVB    #200,PIZEXP+1   ;PI WILL ALWAYS BE ACTIVE
MICH01: INSYNC                  ;COUNT SUBTESTS

        MOV     (R1),R0         ;SET C-RAM START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
        $ARLO2  EWORD1          ;CONO PI DATA TO THE AR
        MOV     (R4)+,R0        ;SET NUMBER M-TICS TO BURST
        RUNCLK                  ;EBOX GOES FULL SPEED
        $MCOMP                  ;SET UP EXPECTED
        PI.CHK                  ;RESTORE EXPECTED
        $RCOMP                  ;RESTORE EXPECTED
        CMP     #^D16,R5                ;DONE ALL SUBTESTS?
        BGT     MICH01          ;BACK IF MORE TO DO

        BLT     MICH02          ;FORWARD IF DONE FIRST 16 SUBTESTS
        MOV     #21007,EWORD1+2 ;CHANGE AR/CONO PI DATA
        CLRB    PIZEXP+2                ;NO LONGER EXPECT GEN LEV 7
        BR      MICH01        ;NOW CONTINUE BIG LOOP


MICH02: CMP     #^D22,R5        ;DONE ALL YET
        BGT     MICH01          ;BR IF NOT YET
        JMP     NORMAL          ;OTHERWISE OUT


;SEQ355

;TABLE OF MBOX TICS NEEDED FOR EACH SUBTEST
        TR=^D4                  ;NUMBER OF TICS TO SET "TRANS RECEIVED" USING
                                ;THE PI XFER FORCE LOGIC
MICH03: .WORD   PI4CNT+^D5              ;SUBTEST 1-"TIM1" NEXT TIC
        .WORD   PI4CNT+^D6      ;ST 2-"TIM1"
        .WORD   PI4CNT+^D17     ;ST 3
        .WORD   PI4CNT+^D18     ;SUBTEST 4- "TIM2"
        .WORD   PI4CNT+^D41     ;ST 5
        .WORD   PI4CNT+^D42     ;SUBTEST 6-"TIM3"
        .WORD   PI4CNT+^D46      ;ST 7
        .WORD   PI4CNT+^D47     ;SUBTEST 8- "TIM4"
        .WORD   PI4CNT+^D58     ;ST 9
        .WORD   PI4CNT+^D59     ;SUBTEST 10- "TIM5"
        .WORD   PI4CNT+^D74     ;ST 11
        .WORD   PI4CNT+^D75     ;SUBTEST 12- "TIM6"
        .WORD   PI4CNT+^D76     ;SUBTEST 13- "TIM7"
        .WORD   PI4CNT+^D80     ;ST 14
        .WORD   PI4CNT+^D81     ;SUBTEST 15- "PI COMP"
        .WORD   PI4CNT+^D82     ;SUBTEST 16- "EBUS PI GRANT" DROPS

FRCXFR =        310             ;NUMBER OF M-BOX TICKS TO GIVE 7 ONE MHZ TICKS

MICH04: .WORD   PI4CNT+^D74+FRCXFR+^D25 ;ST17
        .WORD   PI4CNT+^D75+FRCXFR+^D25 ;SUBTEST 18- "TIM6"
        .WORD   PI4CNT+^D76+FRCXFR+^D25 ;SUBTEST 19- "TIM7"
        .WORD   PI4CNT+^D80+FRCXFR+^D25 ;ST20
        .WORD   PI4CNT+^D81+FRCXFR+^D25 ;SUBTEST 21- "PI COMP"
        .WORD   PI4CNT+^D82+FRCXFR+^D25 ;SUBTEST 22- "EBUX PI GRANT" DROPS

;LIST OF CRAM START ADDRESSES FOR VARIOUS SUBTESTS

MICH4A: .WORD   MIC4PI          ;SUBTESTS 1-22


;SEQ356

;TABLE FOR MCOMP NUMBER OF CHANGES

MICH05: .BYTE   2               ;ST 1
        .BYTE   2               ;ST 2
        .BYTE   2               ;ST 3
        .BYTE   2               ;ST 4
        .BYTE   2               ;ST 5
        .BYTE   2               ;ST 6
        .BYTE   2               ;ST 7
        .BYTE   2               ;ST 8
        .BYTE   2               ;ST 9
        .BYTE   2               ;ST 10
        .BYTE   2               ;ST 11
        .BYTE   2               ;ST 12
        .BYTE   2               ;ST 13
        .BYTE   2               ;ST 14
        .BYTE   2               ;ST 15
        .BYTE   1               ;ST 16
        .BYTE   2               ;ST 17
        .BYTE   2               ;ST 18
        .BYTE   2               ;ST 19
        .BYTE   2               ;ST 20
        .BYTE   2               ;ST 21
        .BYTE   1               ;ST 22


;SEQ357

;TABLE OF MCOMP ACTUAL BYTE CHANGES

MICH06: .BYTE   3               
        .BYTE   156             ;PI4,PI2
        .BYTE   4
        .BYTE   75              ;SUBTEST 1 -EBUS PI GRANT,PI4,HONOR INTERNAL,EBUS REQ

        .BYTE   3
        .BYTE   156             ;PI4,PI2
        .BYTE   4
        .BYTE   74              ;SBUTEST 2-EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   156             ;PI4,PI2
        .BYTE   4
        .BYTE   174             ;SUBTEST 3-"TIMER DONE",EBUS PI GRANT,PI4,HONOR ITNERNAL

        .BYTE   3
        .BYTE   176             ;SUBTEST 4-PI2,PI1, "EBUS DEMAND"
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   176             ;SUBTEST 5-PI2,PI1,"EBUS DEMAND"
        .BYTE   4
        .BYTE   174             ;TIMER DONE, EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 6-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 7-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   174             ;TIMER,DONE,EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTETST 8-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   74              ;EUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3       
        .BYTE   144             ;SUBTEST 9-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   174             ;TIMERDONE, EBUS PI GRANT, PI4,HONOR INTERNAL


;SEQ358

        .BYTE   3
        .BYTE   144             ;SUBTEST 10-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 11-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   174             ;TIMER DONE, EBUS PI GRANT,-PI4,HONOR INTERNAL
        .BYTE   3
        .BYTE   144             ;SUBTEST 12-PI2,PI1,SEL PHY4
        .BYTE   4        
        .BYTE   176             ;TIMER DONE,EBUS PI GRANT,PI4,READY,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 13-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT,PIR, HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 14-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   174             ;EBUS PI GRANT,PI4,HONOR INTERNAL

        .BYTE   3
        .BYTE   144             ;SUBTEST 15-PI2,PI1,SEL PHJY4
        .BYTE   4
        .BYTE   174             ;TIMER DONE,EBUS PI GRANT,PIR,HONOR INTERNAL

        .BYTE   4
        .BYTE   24              ;SUBTEST 16-"EBUS PI GRANT",PI4


;SEQ359

        .BYTE   3
        .BYTE   164             ;SUBTEST 17-PI2,PI1,EBUS DEMAND,SEL PHY4
        .BYTE   4
        .BYTE   170             ;TIMER DONE,EBUS PI GRANT-PI4

        .BYTE   3
        .BYTE   164             ;SUBTEST 18-PI2,PI1,EBUS DEMAND,SEL PHY4
        .BYTE   4
        .BYTE   172             ;TIMER DONE, EBUS PI GRANT,PI4,READY

        .BYTE   3
        .BYTE   144             ;SUBTEST 19-PI2,PI1,SEL PHY4

        .BYTE   4
        .BYTE   70              ;EBUS PI GRANT,PI4

        .BYTE   3
        .BYTE   144             ;SUBTEST 20-PI2,PI1,SDEL PHY4
        .BYTE   4
        .BYTE   170             ;EBUS PI GRANT,PI4

        .BYTE   3
        .BYTE   144             ;SUBTEST 21-PI2,PI1,SEL PHY4
        .BYTE   4
        .BYTE   170             ;ETIMER DONE, EBUS PI GRANT,PI4

        .BYTE   4               
        .BYTE   20              ;SUBTEST 22-"-EBUS PI GRANT",PI4
.EVEN


;SEQ360

.SBTTL PI4 FAILURE KEY-APPLY FAILING SUBTEST & FAILING BIT.  KEY NAMES SIGNALS

.REM    %
SUBTEST 1 - PI4 AND EBUS PI GRANT HAVE BEEN TESTED-ANY FAILURE IS UNKNOWN FLAKEY
        IF STATE HOLD HI, SUSPECT PI5 CYC START DID NOT SET
        IF HONOR INTERNAL LO, SUSPECT "PI5 GEN INT" XORING GATE FAILURE OR
        "PI5 GEN ON" PRIORITY ENCODER GATE

SUBTEST 2 - IF HONOR INTERNAL WORKED LAST SUBRTEST IT SHOULD WORK THIS ONE-ANYU FAILURE
        IF TIMER DONE LO, SUSPECT ANY LOGIC INTO INPUTS OF DUAL BIN CNTRE ON PRINT PI2

SUBTEST 3 - PI4 & EBUS PI GRANT, SEE SUBTEST 1
        IF TIMER DONE LO, SUSPECT ANY LOGIC INTO INPUTS OF DUAL BIN CNTR ON PRINT PI2

SUBTES 4 - PI4 & EBUS PI GRANT, SEE SUBTEST 1
        IF "EBUS DEMAND" ;LO, "TIM2" DID NOT COME UP

        IF "STATE HOLD:" LO, :TIMER DONE" DID NOT CLEAR, EITHER BIN CNTR LOADED
        INCORRECTLY OR NOT AT ALL

SUBTEST 5 - PI4,PI2,PI1,EBUS PI GRANT,FLAKEY
        IF EBUS DEMAND LO, "TIM2" WNET AWAY BEFORE IT SHOULD, BIN CNTR LOADED
        INCORRECTLY. IF STATE HOLD HI, FLAKEY

SUBTEST 6 - IF NONE OF THE FOLLOWING CAME UP, :SEL PHY8, SEL PHY4,SEL PHY2,SEL PHY1"
        THEN "TIM3" DID NOT COME UP AND THE PROBLEM IS IN THE TM1/TM2/TM3/TM4
        SHIFT REGISTER

        IF "SEL PHY4" NOT UP, BUT SOME COMBINATION OF SEL PHY8,SEL PHY2,SELPHY1 IS,
        THEN "TIM3" IS OK, BUT THE PRIORITY ENCODERS OF THE PHYSICAL NUMBER
        OR THE PHYSICAL NUMBER FLIP FLOPS HAVE THE PROBLEM.  THE TEST
        SHOULD HAVE LOADED PHYS NO.4, PHYS NO.8, & PHYS NO.15, THE PRIORITY
        ENCODER SHOULD SELECT "SEL PHY8=0,SELHY4=1,SELPHY2=0,SELPHY1=0
IF STATE HOLD LO PROBLEM IS SOMEWHERE IN STATE HOLD LOGIC, OR ELSE

SUBTEST 7 - IF THIS FAR, SEL PHY4 SHOULD NEVER GO AWAY.  IF IT DOES YOU HAVE A FLAKEY
        PROBLEM, EITHER A RAMDOM SIGNAL TIED TO "TIM3", WHICH CAUSES IT TO GO UP AND
        DOWN, OR ELSE A RANDOM PROBLEM IN THE TIM1/TIM2/TIM3/TIM4 SHIFT REGISTER
        HAS CAUSED TIM3 TO AGAIN BE ASSERTED
        IF NO TIMER DONE, BIN CNTR WAS LOADED INCORRECTLY-EXAMINE THE CIRCUITS ON
        THE INPUTS TO THE BIN CNTR

SUBTEST 8 - THIS SUBTEST SHOULD NOT FAIL.  ITS ONLY ACT IS TO ASSERT "TIM4" AND
        DROP "TIM3","TIM4" IS NOT USED IN THE LOGIC EXCEPT AS A SHIFT INPUT TO "TIOM5"
        THE ONLY CLUE WE WILL EVER HAVE OF "TIM4" STUCK LO, IS IF "TIM5" DOES NOT SET
        WHEN IT SHOULD.  ANY FAILURE IN THIS SUBTEST IS A FLAKEY.
.PAGE
SUBTEST 9 - THE ONLY REASONABLE FAILUE FOR THIS SUBTEST IS THAT "TIMER DONE"
        DID NOT COME UP, AND THAT WOULD BE DUE TO THE DUAL BIN CNTRS BEING
        LOADED INCORRECTLY.  ANY OTHER DFAILURE IS A FLAKEY.

SUBTEST 109 - PROBLEMS HERE ARE ONLY SEEN IN SUBTEST 11,IF TIMER DONE DOES NOT COME UP.
REASONABLE FAILURES:

                "TIM4" DID NOT COME UP IN SUBTST 8 (SEE SUBTEST 8 DESCRIPTION)
                THE SHIFT 0 IN INPUT OF TIM5/TIM6/TIM7/COMP SHIFT COUNTER
                SUFFERS FROM BROKEN ETCH


;SEQ361

                "TIM5" STUCK LO
                NO CLOCK TO TIM5/TIM6/TIM7/COMP SHIFT REGISTER

SUBTEST 11 - IF "TIMER DONE" NOT UP, THERE IS ONE POSSIBLE FAILURE.  1) BIN CNTR WA
                LOADED WITHT EH WRONG COUNT AT SUBTEST 10 TIME.

SUBTEST 12 - IF "READY" IS LO, DID NOT GET "TIM6", "TIM6" IS STUCK LO, "DISABLE RDY ON
        STUCK OR BAD, OR PROBLEM WITH "STATE HOLD":

SUBTEST 13 - "READY" IS HI FROM "TIM6" WE SHOULD HAVE "PI CYCLE" HI, SO IF "STATE HOLD"
        HI, CHECK PI CYCLE LINE INTO THE STATE HOLD LOGIC.

SUBTEST 14 - IF READY HI, THEN "TIM6" DID NOT GO AWAY INTO TIM7 AS IT SHOULD HAVE.
        LOOK AT STATE HOLD CIRCUITS OR "TIM5" STILL HI
        "TIMER DONE" SHOULD BE LO, AS WE JUST LOADED BIN CNTR

SUBTEST 15 - IF TIMER DONE WRONG, THEN BIN CNTR WAS LOADED WITH INCORRECT
        VALUE AT SUBTEST 14 TIME, CHECK :TIM6": INTO BIN CNGTR INPUTS

SUBTEST 16 - IF EBUS PI GRANT WRONG, THEN EIGHTER "COMP" IS TUCK LO9, OR DID NOT
        COME UP, OR "EBUS PI GRANT" FLIP FLOP ON PRINT P15 HAS A PROBLEM

SUBTEST 17 - IF THIS SUBTEST FAILS, "EBUS RETURN" AS CAUSED BY A
        DIAGNOSTIC FUNCTION READ(AND A CTL CONSOLE CONTROL) DID NOT
        CAUSE THE "TIMER DONE" BINARY COUNTER TO DO A LOAD OF ITS
        "TIM5" STATE

.PAGE
SUBTEST 18 - IF EBUS DEMAND LO, "TIM5" WENT AWAY FOR AN UNKNOWN REASON, ELSE HONOR
        INTERNAL CAME TRUE FOR AN EQUALLY UNKNOWN REASON
IF TIMER DONE NOT UP, THERE TWO POSSIBLE FAILURES.  1) BIN CNTR WAS
        LOADED WITH THE WRONG COUNT AT SUBTEST 10 TIME.
        2) PROBLEM WITH "TRAN REC" NETWORK.  EITHER SHIFT COUNTER E3
        IS BAD, OR GETTING NO CLOCKS OR SHIFT 3IN INPUT BAD OR THE
        EBUS XFER/HONOR INTERNAL GATE IS BAD
        
IF ALL PI CONTROL SIGNALS NOT UP, THEN "XFER FORCE" FLOP
        OR THE BIN CNTR AT ITS INPUT IS BAD
        OR METER BOARD "1 MHZ" JUMPERS ARE WRONG
        OR METEWR BOARD ECO #1347 IS BAD

SUBTEST 19 - IF "READY" IS LO, DID NOT GET "TIM6", EITHER "TIM6" STUCK LO, "DISABLE RDY
        STUCK OR BAD, OR PROBLEM WITH "STATE HOLD"
        IF "EBUS DEMAND" LO, PROBLEM IS FROM "TIOM6" LINE INTO EBUS DEMAND CIRCUITRY
        OTHER FAILURES ARE FLAKES.

SUBTEST 20 - SHOULD STILL HAVE EBUS DEMAND HI,VIA "TIM6" INPUT, ALSO
        "READY" IS HI FROM "TIM6" WE SHOULD HAVE "PI CYCLE" HI, SO IF "STATE HOLD"
        HI, CHECK PI CYCLE LINE INTO THE STATE HOLD LOGIC.

SUBTEST 21 - IF READY AND DEMAND HI, THE "TIM6" DID NOT GO AWAY INTO TIM7 AS IT SHOULD
        LOOK AT STATE HOLD CIRCUITS OR "TIM5" STILL HI
        "TIMER DONE" SHOULD BE LO, AS WE JUST LOADED BIN CNTR

SUBTEST 22 - IF TIMER DONE WRONG, THEN BIN CNTR WAS LOADED WITH INCORRECT
        VALUE AT SUBTEST 14 TIME, CHECK 'TIM6" INTO BIN CNTR INPUTS

SUBTEST 23 - IF EBUS PI GRANT WRONG, THEN EITHER "COMP" IX STUCK LO, OR DID NOT


;SEQ362

        COME UP, OR "EBUS PI GRANT" FLIP FLOP ON PRINT P15 HAS A PROBLEM
%


;SEQ363

.SBTTL TEST 32 (PIZZA5):  "STATE HOLD" LOGIC, "EBUS DEMAND"LOGIC, "OK ON HALT" DECODER

.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE COMBINATORIAL LOGIC THAT PREODUCES "STATE HOL
THE COMBINATORIAL LOGIC THAT PRODUCES "EBUS DEMAND", AND THE EBUS DATA LINES & OTHER PI
BOARD SIGNALS THAT ARE USED WITH THE DECODER THAT CAUSES "PI4 OK ON HALT"
THE BASIC TEST PROCEDURE IS TO SET UP MICRO-CODE WHICH WOULD NORMALLY TAKE
THE PI BOARD THROUGH ALL SEVEN TIME STATES.  THE MICRO-CODE ALSO INCLUDES
THE SPECIAL CONDITIONS UNDER TEST AND SETS THE APPROPRIATE FLOPS NEEDED FOR THE
SPECIFIC SUBTESTS (EXAMPLES INCLUDE:  "APR EBUS RETURN", "APR EBUS DEMAND", "CON EBOX HAL
"CON EBUS REL", & "APR EBUS REQ"). FINALLY, THE PDP11 CONTROLS THE NUMBER OF CLOCKS
GIVEN TO THE PI BOARD AND STOPS THE PI BOARD IN THE TIME STATE DESIRED, THEN
READS THE PI BOARD & VERIFIES THAT THE COMBINATORIAL LOGIC UNDER TEST IS WORKING.
%
PIZZA5: MOV     #NEV06,R4       ;GET POINT TO LIST C-RAM START ADDRESSES & CLOCK TICCS
        MOV     #NEV07,R2               ;GET POINT TO LIST OF # OF MCOMP CHANGES
        MOV     #NEV08,R3               ;GET POINT TO ACTUAL MCOMP CHANGES
        MOV     #200,PIZMSK+4           ;LOOK AT "PI TIMER DONE " THIS TEST
        MOVB    #377,PIZMSK+5           ;DONT READ SCAD PI4,PI2
        MOVB    #377,PIZMSK+6           ;OR SCAD PI1

NEV01:  INSYNC                          ;COUNT SUBTEST
        MOV     (R4)+,R0                ;GET NEXT C-RAM START ADDRESS
        JSR     PC,RUN.GO               ;LOAD DIAG ADR REG & SET "RUN"
        $ARLO2  NEV05           ;LOAD A SET "  GEN2" & SET "PI ACTIVE" TO THE AR

        MOV     (R4)+,R0                ;GET NUMBER OF MBOX CLOCKS NEEDED FOR THIS TEST
        BURST           ;BURST THE CLOCK

        MCOMP                   ;SET EXPECTED DATA
        PI.CHK                  ;COMPARE PI BOARD VERSUS EXPECTED
        RCOMP                   ;RESTORE EXPECTED TABLES

        CMP     #^D16,R5         ;DONE THIS SECTION OF TEST
        BGT     NEV01                   ;BR BACK IF NO

.REM    %
THE NEXT SECTION OF THIS TEST CHECKS THE "PI OK ON HALT" L;OGIC.
THE MICRO-CODE FOR THIS SUBTEST WORKS SIMILAR TO THE PRECEEDING SUBTESTS,
EXCEPT THAT DURING PI "TIM6", DATA IS BEING PUT INTO THE EBUS IN ORDER
TO CAUSE THE "PI OK ON HALT" DECODER, TO DECODE THE DESIRED FUNCTION.
FROM THE EBUS
%

        ADD     #10,R3          ;INIT ACTUAL CHANGES POINTER
        ADD     #1,R2           ;INIT NUMBER OF CHANGES POINTER
        MOVB    #217,PIZMSK+3   ;DONT LOOK AT PHYSICAL NUMBER SDELECTS
;THESE TESTRS CHECK "PI READY", "OK ON HALT" AND "STATE HOLD"

;"PI4 OK ON HALT H" SHOULD BRING UP STATE HOLD AND LOCK UP
;THE PI BOARD IN TIME STATE "TI M6"..IF THE LOGIC FAILS, THE PI CYCLE
;HAS ENOUGH CLOCKS TO COMPLETE ITSELF.

;SEQ364

;       IN SUBTEST 21, WE USE EBUS DATA BITS WHICH SHOULD NOT CAUSE
;"OK ON HALT" AND HENCE THE PI YCLE SHOULD COMPLETE ITSELF
NEV02:  INSYNC                  ;COUNT SUBTESTS
        SUB     #10,R3          ;RESET EXPECTED BYTES
        SUB     #1,R2           ;RESET NUMBER OF CHANGES
NEV03:  MOV     #M5.7PI,R0      ;THIS C-RAM START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        MOV     (R4)+,EWORD1+2  ;GET EBUS DATA FOR "OK ON HALT"
        $ARLO2  EWORD1          ;DATA TO AR
        ECLOK                   ;DATA TO BR
        $ARLO2  NEV05           ;AND NOW CONO PI DATA TO AR
        MOV     #^D21+^D82,R0   ;GET BASIC LCOCK COUNT
        BURST                   ;BURST THE CLOCK

        MCOMP                   ;SET EXPECTED DATA
        PI.CHK                  ;COMPARE PI BOARD VERSUS EXPECTED
        RCOMP                   ;DATA OK, RESTORE EXPECTED TABLES

NEV04:  CMP     #^D20,R5        ;MORE SUBTESTS?
        BGT     NEV02           ;BR BACK IF YES
        INSYNC                  ;SUBTEST 21
        CMP     #^D21,R5        ;ALL DONE YET?
        BGE     NEV03           ;BACK ONCE MORE IF NO

        JMP     NORMAL          ;OTHERWISE, ALL DONE

MONT08: NEV05:  WD36  0042,0160,0000


;SEQ365


;LIST OF C-RAM START ADDRESSES AND NUMBER OF CLOCK TICS
;FOR EACH SUBTEST

.EVEN
NEV06:  .WORD   MIC5PI          ;SUBTEST 1 - "CP GRANT" & "PI GRANT"
        .WORD   ^D20            ;M-CLKS
        .WORD   M5.0PI          ;SUBTEST 2
        .WORD   0
        .WORD   MIC5PI          ;SUBTEST 3
        .WORD   ^D20+^D8        ;GO 8 TICS INTO A PI REQ
        .WORD   MIC5PI          ;SUBTEST 4
        .WORD   ^D20+^D11       ;GO 11 TICS INTO REQ,CP GRANT IS GONE AWAY
        .WORD   M5.0PI          ;SUBTEST 5
        .WORD   0
        .WORD   M5.1PI          ;SUBTEST 6
        .WORD   ^D31    
        .WORD   M5.0PI          ;SUBTEST 7
        .WORD   0
        .WORD   M5.2PI          ;SUBTEST 8 - "EBUS DEMAND"
        .WORD   ^D28
        .WORD   M5.2PI          ;SUBTEST 9
        .WORD   ^D41+^D20       ;20 TICS GET TO "DROP PI CYCLE", 41 MORE TO TIM2
        .WORD   M5.3PI          ;SUBTEST 10
        .WORD   ^D59+^D20       ;20 TICS GET TO DROP PI CYCLE", 59 MORE GET TO TIM5
        .WORD   M5.4PI          ;SUBTEST 11 - "STATE HOLD"
        .WORD   ^D20+^D17       ;20 TICS GET TO "DROP PI CYCLE", 17 MORE GET TO "TIMER D"
        .WORD   M5.4PI          ;SUBTEST 12
        .WORD   ^D20+^D75       ;20 TICS "DROP PI CYCLE",75 MORE GO TO "TIM6"
        .WORD   M5.4PI          ;SUBTEST 13
        .WORD   ^D20+^D76       ;20 TICS "DROP PI CYCLE",76 MORE GO TO "TIM7"
        .WORD   M5.5PI          ;SUBTEST 14
        .WORD   ^D34            ;EBUS RETURN
        .WORD   M5.6PI          ;SUBTEST 15
        .WORD   ^D20+^D75       ;HALTED PREVENTS "PI READY"

        .WORD   M5.6PI          ;SUBTEST 16
        .WORD   ^D20+^D76       ;HALTED DOES NOT CAUSE STATE HOLD
;FIRST WORD IS EBUS DATA, USED TO DRIVE "OK ON HALT" DECODER
        .WORD   60000           ;SUBTEST 17 - "PI OK ON HALT" EBUS 04,05
        .WORD   100000          ;SUBTEST 18 --EBUS 03
        .WORD   120000          ;SUBTEST 19--EBUS 03,05
        .WORD   140000          ;SUTEST 20--EBUS 03,04
        .WORD   160000          ;SUBTEST 21--EBUS 03,04,05


;SEQ366

;TABLE FOR NUMBER OF MCOMP CHANGES
NEV07:  .BYTE   2               ;SUBTEST 1
        .BYTE   1               ;ST-2
        .BYTE   3               ;ST-3
        .BYTE   5               ;ST-4
        .BYTE   1               ;ST-5
        .BYTE   5               ;ST-6
        .BYTE   1               ;ST-7
        .BYTE   4               ;ST-8
        .BYTE   4               ;ST-9
        .BYTE   3               ;ST-10
        .BYTE   4               ;ST-11
        .BYTE   4               ;ST-12
        .BYTE   4               ;ST-13
        .BYTE   4               ;ST-14
        .BYTE   4               ;ST-15
        .BYTE   4               ;ST-16
        .BYTE   4               ;ST-17,18,19,20
        .BYTE   3               ;ST-21

;THE TABLE OF ACTUAL MCOMP BYTE CHANGES
NEV08:  .BYTE   1               ;"PI ACTIVTE"
        .BYTE   200             ;"PI ACTIVE"
        .BYTE   2               
        .BYTE   1               ;SUBTEST 1 - "GEN 7"

        .BYTE   10
        .BYTE   2               ;SUBTEST 2 - "-EBUS CP GRANT"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;SUBTEST 3- "GEN 7"
        .BYTE   4
        .BYTE   25              ;"EBUS REQ" & HONOR INTERNALL


;SEQ367

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;SUBTEST 4- "GEN 7"
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   74              ;HONOR INTERNAL
        .BYTE   10
        .BYTE   2               ;"-EBUS CP GRANT"

        .BYTE   10
        .BYTE   2               ;SUBTEST 5- "-EBUS CP GRANT"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;SUBTEST 6- "GEN 7"
        .BYTE   3
        .BYTE   156             ;"PI2,PI1"
        .BYTE   4
        .BYTE   74              ;"EBUS PI GRANT, PI4, HONOR INTERNAL"
        .BYTE   10
        .BYTE   2               ;"-EBUS CP GRANT"

        .BYTE   10
        .BYTE   2               ;"-EBUS CP GRANT"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;SUBTEST 8- "GEN 7"
        .BYTE   3
        .BYTE   176             ;PI2,PI1, "EBUS DEMAND"
        .BYTE   4
        .BYTE   74              ;"EBUS PI GRANT, PI4, HONOR INTERNAL"


;SEQ368


        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;SUBTEST 9- "GEN 7"
        .BYTE   3
        .BYTE   176             ;PI2,PI1, "EBUS DEMAND"
        .BYTE   4
        .BYTE   174             ;"TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL
        
        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   3
        .BYTE   176             ;SUBTEST 10- "PI2,PI1, EBUS DEMAND"
        .BYTE   4
        .BYTE   70              ;"EBUS PI GRANT, PI4"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 11- "PI2,PI1"
        .BYTE   4
        .BYTE   174             ;"TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 12- "PI2,PI1"
        .BYTE   4
        .BYTE   176             ;"TIMER DONE, EBUS PI GRANT, PI4, READY,HONOR INTERNAL"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 13- "PI2,PI1"
        .BYTE   4
        .BYTE   74              ;"EBUS PI GRANT, PI4, HONOR INTERNAL"


;SEQ369

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 14- "PI2,PI1"
        .BYTE   4
        .BYTE   74              ;"EBUS PI GRANT, PI4, HONOR INTERNAL"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 15- "PI2,PI1"
        .BYTE   4
        .BYTE   174             ;"TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   3
        .BYTE   156             ;SUBTEST 16- "PI2,PI1"
        .BYTE   4
        .BYTE   74              ;"EBUS PI GRANT, PI4, HONOR INTERNAL"

        .BYTE   2
        .BYTE   1               ;GEN 7
        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   3
        .BYTE   146             ;SUBTEST 17,18,19,20- "PI2,PI1"
        .BYTE   4
        .BYTE   174             ;"TIMR DONE, EBUS PI GRANT, PI4, HONOR INTERNAL:

        .BYTE   2
        .BYTE   1               ;GEN 7-SUBTEST 21
        .BYTE   1
        .BYTE   200             ;"PI ACTIVE
        .BYTE   4
        .BYTE   24              ;"HONOR INTERNAL:
        .EVEN

;SEQ370

.SBTTL TEST 32 (PIZZA6):  PHYSICAL NUMBER FLOPS, FROM EBUS 00-15 & PHYS. NO. PRIORITY EN
.REM    %
THIS TEST CHECKS THE 16 P-HYSICAL FLIP FLOPS ON PRINT PI2 AND ALSO
CHECKS THE DUAL PRIORITY ENCODERS WHICH TAKE THE PHYSICAL NUMBERS AND
PRODUCE THE ISGNALS "SEL PHY8", SEL PHY4, SEL PHY2, AND SEL PHY1". THE TEST
ALSO CHECKS THE "SEL PHY4X" TO EBUS BIT 7,8,9,10 MIXER ON PRINT PI5.
THE TEST USES THE MICRO-CODE WHICH RUNS THROUGH ALL 7 TIMING STATES OF THE PI BOARD.
THE PDP11 STOPS THE CLOCK DURING PI TIM3 AND EXAMINES THE STATES
OF THE PI BOARD TO ENSURE THAT THE CORRECT PHYSICAL NUMBERS
HAVE COME UP.  NEXT, THE TEST IS CONTINUED THROUGH TIM6, WITH THE AR
FUNCTION "AR/EBUS" AND AFTER TIM6, THE PDP11 AGAIN STOPS THE CLOCK   AND EXAMINES
THE PI BOARD & THE AR TO BE SURE THE CORRECT SIGNALS ARE BEING PUT ONTO
THE EBUS BY THE PI TO EBUS MIXER.
%
PIZZA6: MOVB    #1,PIZEXP+2     ;ALWAYS EXPECT "GEN 7"
        MOVB    #200,PIZEXP+1   ;ALWAYS EXPECT "PI ACTIVE"
        MOVB    #74,PIZEXP+4    ;ALWAYS EXPECT "EBUS PI GRANT, PI4, HONOR INTERNAL
        MOV     #MONT04,R4      ;GET POINTER TO EBUS DATA FOR PHYSICAL NUMBERS
        MOV     #MONT05+1,R2    ;GET POINTER TO MCOMP NUMBER OF CHANGES TABLE
        MOV     #MONT06,R3      ;GET POINTER TO MCOMP ACTUAO BYTE CHANGES

MONT01: INSYNC                  ;COUNT SUBTEST
        DEC     R2              ;R2 NEEDS TO ALWAYSD POINT TO A ".BYTE 1"
        MOV     #MIC6PI,R0      ;MICRO-CODE START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        MOV     #EWORD1+2,R0    ;GET ADDRESS OF 36 BIT BUFFER
        MOVB    (R4)+,(R0)+     ;MOVE THE 16 BITS
        MOVB    (R4)+,(R0)+     ;OF PHYSICAL NUMBER DATA

        MOVB    (R4)+,(R0)+     ;TO A 36 BIT BUFFER
        $ROLWD  EWORD1          ;JUSTIFY PHYSICAL NUMBER DATA
        $ROLWD  EWORD1          ;AT 26 BIT BUFFER DATA BIT 17
        $ARLO2  EWORD1          ;PHYSICAL NUMBER DATA TO AR
        ECLOK                   ;TRANSFER PHYSICAL NUMBER DATA TO BR


;SEQ371
        $ARLO2  MONT08          ;CONO PI GEN DATA TO AR
        MOV     #^D18+^D42+DRPCYC,R0    ;NUMBER OF MBOX CLOCKS TO EXECUTE THE MICRO-CODE
        BURST                   ;EECUTE THE TEST & LOAD PHYSICAKL NO. FLOPS

        MCOMP                   ;MODIFY EXPECTED DATA
        PI.CHK                  ;CHECK THE STATE OF THE PI BOARD
        RCOMP                   ;RESTORE EXPECTED DATA
        INSYNC                  ;CONTINUE TO TEST PHY6S. NUMBERS TO EBUS
        MOV     #^D39,R0        ;ADDITIONAL CLOCK TICS TO TAKE US TO "TIM6"
        BURST                   ;BURST CLOCK TO CONTINUE THE TEST

        MOVB    -1(R3),R0       ;GET EXPECTED "SEL PHYX" FROM MCOMP EXPECTED TABLE
        BICB    #360,R0         ;CLEAR UNUSED
        ASL     R0              ;SHIFT LEFT ONCE
        MOVB    R0,EWORD2+3     ;SET EXPECTED IN A 36 BIT BUFFER
        MOV     #EWORD1,R1      ;WHERE TO PUT THE 36 BIT AR DATA
        MOV     #DPAR,R0        ;DIAGFUNCTION TO READ THE AR
        DFRDMV                  ;RED THE AR & STORE AT EWORD1

        M36T                    ;;MASK AND COMPARE THE AR 36-BIT DATA
        .WORD   MONT07          ;36 BIT MASK
        .WORD   EWORD2          ;36 BIT EXPECTED
        .WORD   EWORD1          ;36 BIT ACTUAL

        BCC     MONT02          ;BR IOF ALL OK
        JSR     PC,FAULT                ;OTHERWISE REPORT ERROR
        .WORD   0               ;NO ERROR MESSAGE

MONT02: CMP     #^D48,R5        ;DONE ALL THIS SECTION OF TEST
        BGT     MONT01          ;BACK FOR MORE IF NO


;SEQ372

;DROP TO FINAL TWO SUBTEST IF DONE WITH FIRST 48

        INSYNC                  ;COUNT THE SUBTESTS
        $CLRWD                  ;CLEAR 36 BIT BUFFER EWORD1
        MOV     #20,EWORD1+2    ;SET DATA BIT 15

        MOV     #M6.2PI,R0      ;CRAM START ADDRESS, THIS TEST
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
        $ARLO2  EWORD1          ;PHYSICAL NUMBER 15 TO AR
        ECLOK                   ;NOW TO BR
        $ARLO2  MONT08          ;CONO PI GEN DATA TO AR
        MOV     #^D18+^D80,R0   ;NUMBER CLOCK TICS THIS SUBTEST
        BURST                   ;BURST THE CLOCK
        MOV     #EWORD1,R1      ;SET A PLACE TO STORE ACTUAL AR CONTENTS
        MOV     #DPAR,R0        ;DIAGNOSTIC FUNCTION TO READ AR
        DFRDMV                  ;READ THE AR AND SAVE THE RESULTAS

        M36T                    ;MASK & COMPARE AR DATA VERSUS EXPECTED
        .WORD  MONT07           ;MASK
        .WORD   ZERO            ;EXPECTED DATA
        .WORD   EWORD1          ;ACTUAL AR DATA

        BCC     MONT03          ;BR IF NO PROBLEM
        JSR     PC,FAULT                ;OTHERWISE, ERPORT ERROR
        .WORD   0               ;NO ERR MESSAGE

MONT03: INSYNC                  ;NEXT SUBTEST
        MOV     #4,R0           ;4 MORE PI CLK TICS
        BURST                   ;BURST THE CLOCK

        MCOMP                   ;MODIFY EXPECTED DATA
        PI.CHK                  ;CHECK THE PI BOARD
        RCOMP                   ;RESTORE EXPECTED

        JMP     NORMAL  ;ALL DONE


;SEQ373

;TABLE OF PHYSICAL NUMBER BITS TO SET FOR SUBTESTS 1-48
MONT04: WD18    00,0000         ;SUBTEST 1 & 2 - NO PHY NO.
        WD18    00,0004         ;ST 3 & 4 - PHY NO. 15
        WD18    00,2000         ;ST 5 & 6 - PHY NO. 7
        WD18    00,0140         ;ST 7 & 8 - PHY NO. 11 & 12
        WD18    06,0000         ;ST 9 & 10 - PHY NO. 3 & 4
        WD18    00,0030         ;ST 11 & 12 - PHY NO. 13 & 14
        WD18    00,0600         ;ST 13 & 14 - PHY NO. 9 & 10
        WD18    01,4000         ;ST 15 7 16 - PHY NO. 5 & 6
        WD18    30,0000         ;ST 17 & 18 - PHY NO. 1 & 2
        WD18    40,0000         ;ST 19 & 20 - PHY NO. 9
        WD18    00,1400         ;ST 21 & 22 - PHY NO. 8 & 9
        WD18    00,0010         ;ST 23 & 24 - PHY NO. 14
        WD18    00,0040         ;ST 25 & 26 - PHY NO. 12
        WD18    00,0200         ;ST 27 & 28 - PHY NO. 10
        WD18    00,4000         ;ST 29 & 30 - PHY NO. 6
        WD18    02,0000 ;ST 31 & 32 - PHY NO. 4
        WD18    10,0000         ;ST 33 & 34 - PHY NO. 2
        WD18    00,0014         ;ST 35 & 36 - PHY NO. 14 & 15
        WD18    00,0060         ;ST 37 & 38 - PHY NO. 12 & 13
        WD18    00,0300         ;ST 38 & 40 - PHY NO. 10 & 11
        WD18    00,6000         ;ST 41 & 42 - PHY NO. 6 & 7
        WD18    03,0000         ;ST 43 & 44 - PHY NO. 4 & 5
        WD18    60,0000         ;ST 45 & 46 - PHY NO. 0 & 1
        WD18    14,0000         ;ST 47 & 48 - PHYM NO. 2 & 3


;SEQ374

MONT05: .BYTE   1               ;NUMBER OF MCOMP CHANGES, SUBTEST 1-48
        .BYTE   2               ;SUBTEST 50

;TABLE OF ACTUAL MCOMP CHANGES
MONT06: .BYTE   3
        .BYTE   156             ;ST1 - PI2,PI1, SEL PHY8

        .BYTE   3
        .BYTE   157             ;ST3 - PI2,PI1, SEL PHY8, 4, 2, 1

        .BYTE   3
        .BYTE   147             ;ST 5 - PI2, PI1,. SEL PHY4, 2, 1

        .BYTE   3
        .BYTE   153             ;ST7 - PI2, PI1, SEL PHY 8, 2, 1

        .BYTE   3
        .BYTE   143             ;ST9 - PI2,PI1, SEL PHY 2, 1

        .BYTE   3
        .BYTE   155             ;ST11 - PI2,PI1, SEL PHY8, 4, 1

        .BYTE   3
        .BYTE   151             ;ST13 - PI2, PI1, SEL PHY 8, 1

        .BYTE   3
        .BYTE   145             ;ST 15 - PI2, PI1, SEL PHY4, 1

        .BYTE   3
        .BYTE   141             ;ST17 - PI2, PI1, SEL PHY1

        .BYTE   3
        .BYTE   140             ;ST19 - PI2, PI1

        .BYTE   3
        .BYTE   150             ;ST21 - PI2, PI1, SEL PHY8

        .BYTE   3
        .BYTE   156             ;ST23 - PI2, PI1, SEWL PHY8, 4, 2

        .BYTE   3
        .BYTE   154             ;ST25 - PI2, PI1, SEL PHY8, 4


;SEQ375

        .BYTE   3
        .BYTE   152             ;ST27 - PI2, PI1, SEL PHY 8, 2

        .BYTE   3
        .BYTE   146             ;ST29 - PI2, PI1, SEL PHY 4, 2
        
        .BYTE   3
        .BYTE   144             ;ST31 - PI2, PI1, SEL PHY4

        .BYTE   3
        .BYTE   142             ;ST33 - PI2, PI1, SEL PHY2

        .BYTE   3
        .BYTE   157             ;ST35 - PI2, PI1, SEL PHY 8, 4, 2

        .BYTE   3
        .BYTE   154             ;ST37- PI2, PI1, SEL PHY 8, 4

        .BYTE   3
        .BYTE   152             ;ST39 - PI2, PI1, SEL PHY 8, 2

        .BYTE   3
        .BYTE   146             ;ST41 - PI2, PI1, SEL PHY4, 2

        .BYTE   3
        .BYTE   144             ;ST43 - PI2, PI1, SEL PHY4

        .BYTE   3
        .BYTE   140             ;ST45 - PI2,PI1

        .BYTE   3
        .BYTE   142             ;ST47 - PI2, PI1, SEL PHY2

        .BYTE   3
        .BYTE   0               ;ST50 - PI2, PI1 "APR EBOX DISABLE CS" = NO SEL PHTY
        .BYTE   4
        .BYTE   60              ;APR EBOX DISABLE CS TURNS EVERYTHING OFF

MONT07:         WD36    7741,7777,7777  ;MASK OFF ALL BITS EXCEPT 7,8,9,10
        .EVEN


;SEQ376

.SBTTL TEST 33 (PIZZA7):  "APR PIA 04,02,01 APR PHY NO. & PIR EN"

        .REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE "APR PIA 04,02,01" FLOPS, WHICH
ARE SET BY THE "CONO APR", AND TO CHECK THE "APR PIA" DECODERS AND
TO CHECK THE OUTPUT OF THE "APR PIA" DECODER TO THE PI FREQUEST FLOPS.
THE TEST DOES THIS BY 1) SETTING ALL PI L;EVELS "ON" & "PI ACTIVE"
2) THEN SETTING THE 3-BIT "APR PIA" REGISTRER WITH 0(1-7 ON SUCCESSIVE SUBTESTS),
CYCLING THE PI BOATD TO "TIM3" AND CHECKING THE STATE 9F THE PI BOARD
FOR GOOD RESULTS.  THIS TEST ALSO CHECKS THE "PI2 APR REQUESTING"FLIP FLOP.
%

PIZZA7: MOV     #ARK04,R4       ;GET POINTER TO "CONO PI DATA
        MOV     #ARK08,R3       ;GET POINTER TO MCOMP CHANGES
        MOV     #ARK07,R2       ;GET POINTER TO MCOMP NUMBER OF CHANGES
        MOV     #ARK05,R1       ;GET POINTER TO APR PIA, O4,02,01

ARK01:  MOV     #MIC7PI,R0      ;POINTER TO C-RAM START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
        INSYNC                  ;NEXT SUBTEST

        BIC     #34,ARK03+2     ;CLEAR EBUS BITS 15,16,17
        BIS     (R1)+,ARK03+2   ;SET CONO APR DATA TO EWORD1
        $ARLO2  ARK03           ;AND LOAD THE DATA TO THE TEN
        ECLOK                   ;SEND THAT DATA TO BR
        MOV     R4,R0           ;GET ADDRESS OF CONO PI DATA TO R0
        ARLOD2                  ;AND LOAD THE DATA TO THE TEN

        MOV     #^D36+DRPCYC+^D42,R0    ;GET CLOCK TICS NEEDED FOR THIS TEST
        BURST                   ;RUN PI BOARD TO "TIM3"

        $MCOMP                  ;MODIFY EXPECTED
        PI.CHK                  ;CHECK PI EXPECTED
        $RCOMP                  ;RESTORE EXPECTED TABLE
        CMP     #^D21,R5        ;DONE ALL SUBTESTS WITH COMMON GEN DATA
        BLE     ARK02           ;BR IF YES


;SEQ377

        CMP     #ARK06,R1       ;DONE 8 PIA'S FOR THIS SECTION
        BGE     ARK01           ;BR IF NOT DONE ALL 7

;
;HERE ONLY IF DONE SUBTEST 1-7
;FROM HERE ON ALWAYS EXPECXT THE FOLLOWING:
        MOVB    #24,PIZEXP+4    ;HONOR INTERNAL (LEFT OVER FROM ST7)
        MOVB    #4,PIZEXP+5     ;SCAD TRAP MIX 32(PI4)
        SUB     #16,R1          ;DONE 7, RESET PIA POINTER
        ADD     #5,R4           ;UPDATE CONO PI DATA TO NEXCT
        BR      ARK01           ;BACK TO BEGINNING

ARK02:  CMP     #^D22,R5                ;REALLY DONE AALL SUBTESTS NOW
        BLE     1$              ;LAST SUBTEST IS NO PIA'S
        BR      ARK01           ;GO BACK TO LOOP
1$:     JMP     NORMAL

ARK03:  WD36    0000,4011,0000  ;CONO APR DATA, "SETS POWER FAIL"

ARK04:  WD36    0023,7700,0000  ;CONO PI DATA FOR TEST LOOPS - ACTIVE & ON

        

        WD36    0002,0000,0000  ;ACTIVE - NO ON LEVELS
        WD36    0021,7700,0000  ;NO ACTIVE - ALL LEVELS ON
        .EVEN

;LIST OF WORDS FOR SETTING CORRECT PIA'S

ARK05:  .WORD   1*4             ;PIA 01 - "PI01"
        .WORD   2*4             ;PIA 02 - "PI02"
        .WORD   3*4             ;PIA 02,01 - "PI03"
        .WORD   4*4             ;PIA 04 - "PI04"
        .WORD   5*4             ;PIA 04,01 - "PI05"
        .WORD   6*4             ;PIA 04,02 - "PI06"
ARK06:  .WORD   7*4             ;PIA 04,02,01 - "PI07"
        .WORD   0               ;NO PIA'S


;SEQ378

;MCOMPS NUMBER OF CHANGES TABLE

ARK07:  .BYTE   5               ;ST 1
        .BYTE   5               ;ST 2
        .BYTE   6               ;ST 3
        .BYTE   5               ;ST 4
        .BYTE   6               ;ST 5
        .BYTE   5               ;ST 6
        .BYTE   6               ;ST 7

        .BYTE   2               ;ST 8
        .BYTE   2               ;ST 9
        .BYTE   2                ;ST 10
        .BYTE   2               ;ST 11
        .BYTE   2               ;ST 12
        .BYTE   2               ;ST 13
        .BYTE   2               ;ST 14

        .BYTE   2               ;ST 15
        .BYTE   2               ;ST 16
        .BYTE   2               ;ST 17
        .BYTE   2               ;ST 18
        .BYTE   2               ;ST 19
        .BYTE   2               ;ST 20
        .BYTE   2               ;ST 21
        .BYTE   1               ;ST 22

;SEQ379

;MCOMP ACTUAL CHANGES TABLE

ARK08:  .BYTE   1               ;
        .BYTE   377             ;SUBTEST 1 - "PI ACTIVE", "ON1-0N7"
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   7               
        .BYTE   1               ;APR PIA1 01

        .BYTE   1
        .BYTE   377             ;SBUTEST 2 - "PI ACTIVE", "ON1-0N7"
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL
        .BYTE   5
        .BYTE   2               ;SCAD PI2
        .BYTE   7
        .BYTE   2               ;APR PIA 02

        .BYTE   1
        .BYTE   377             ;SUBTEST 3 - "PI ACTIVE", "ON1-0N7"
        .BYTE   3
        .BYTE   156             ;PI2, PI1
        .BYTE   4
        .BYTE   64              ;EBUS PI GRANT, HONOR INTERNAL

        .BYTE   5
        .BYTE   2               ;SCAD PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   7
        .BYTE   3               ;APR PIA 02,01

        .BYTE   1               
        .BYTE   377             ;SUBTEST 4 - "PI ACTIVE", "ON1-0N7"
        .BYTE   3
        .BYTE   16              ;SEL PHY8 IS NORMAL
        .BYTE   4
        .BYTE   74              ;PI4, EBUS PI GTRANT, HONOR INTERNAL
        .BYTE   5
        .BYTE   4               ;SCAD PI4
        .BYTE   7
        .BYTE   4               ;APR PI 04


;SEQ380


        .BYTE   1
        .BYTE   377             ;SUBTEST 5 - PI ACTIVE, "ON1-0N7"
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   74              ;PI4, EBUS GRANT, HONOR INNTERNAL
        .BYTE   5       
.BYTE   4               ;SCAD PI4
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   7
        .BYTE   5               ;APR PIA 04,01

        .BYTE   1               
        .BYTE   377             ;SUBTEST 6 - "PI ACTIVE", "ON1-0N7"
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   74              ;EBUS PI GRANT, PI4, HONOR INTERNAL
        .BYTE   5
        .BYTE   6               ;SCAD PI4,P[I2
        .BYTE   7
        .BYTE   6               ;APR PI4 04,02

        .BYTE   1
        .BYTE   377             ;SUBTEST 7 - PI ACTIVE, "ON1-0N7"
        .BYTE   3
        .BYTE   156             ;PI2, PI1
        .BYTE   4
        .BYTE   74              ;PI4,EBUS PI GRANT, HONOR INTERNAL
        .BYTE   5
        .BYTE   6               ;SCAD PI4, PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   7       
        .BYTE   7               ;APR PIA 04,02,01


;SEQ381

        .BYTE   1
        .BYTE   200             ;SUBTEST 8 - "PI ACTIVE"
        .BYTE   7       
        .BYTE   1               ;APR PIA 01

        .BYTE   1
        .BYTE   200             ;SUBTEST 9 - "PI ACTIVE"
        .BYTE   7
        .BYTE   2               ;APR PIA 02

        .BYTE   1
        .BYTE   200             ;SUBTEST 10 - "PI ACTIVE"
        .BYTE   7
        .BYTE   3               ;APR PIA 02,01

        .BYTE   1               

        .BYTE   200             ;SUBTEST 11 - "PI ACTIVE"
        .BYTE 7
        .BYTE   4               ;APR PIA 04
        .BYTE   1               
        .BYTE   200             ;SUBTEST 12 - "PI ACTIVE"
        .BYTE   7
        .BYTE   5               ;APR PIA 04,01

        .BYTE   1
        .BYTE   200             ;SUBTEST 13 - "PI ACTIVE"
        .BYTE   7
        .BYTE   6               ;APR PIA 04,02

        .BYTE   1
        .BYTE   200             ;SUBTEST 14 - "PI ACTIVE"
        .BYTE   7
        .BYTE   7               ;APR PIA 04,02,01

        .BYTE   1
        .BYTE   177             ;SUBTEST 15 - "ON1-ON7"
        .BYTE   7
        .BYTE   1               ;APR PIA 01

        .BYTE   1
        .BYTE   177             ;SUBTEST 16 - "ON1-ON7"
        .BYTE   7
        .BYTE   2               ;APR PIA 02


;SEQ382
        .BYTE   1
        .BYTE   177             ;SUBTEST 17 - "ON1-0N7"
        .BYTE   7
        .BYTE   3               ;APR PIA 02,01

        .BYTE   1
        .BYTE   177             ;SUBTEST 18 - "ON1-0N7"
        .BYTE   7
        .BYTE   4               ;APR PIA 04

        .BYTE   1
        .BYTE   177             ;SUBTEST 19 - "ON1-ON7"
        .BYTE   7       
        .BYTE   5               ;APR PIA 04,01

        .BYTE   1
        .BYTE   177             ;SUBTEST 20 - "ON1-ON7"
        .BYTE   7       
        .BYTE   6               ;APR PIA 04,02

        .BYTE   1
        .BYTE   177             ;SUBTEST 21 - "ON1-ON7"
        .BYTE   7
        .BYTE   7               ;APR PIA 04,02,01

        .BYTE   1
        .BYTE   177             ;SUBTEST 22 - "ON1-ON7"



;SEQ383

.SBTTL TEST 34 (PIZZA8):  MTR PIA 04, 02, 01, MTR PHY NO. & PIR0

.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE "MTR PIA 04, 02, 01" FLOPS, WHICH ARE
SET BY THE "CONO MTR" WHICH IS GENERATED ON THE MTR BOARD.  TO CHECK THE MTR
PIA DECODERS AND TO CHECK THE OUTPUT OF THE "MTR PIA" DECODERS TO THE PI
REQUEST FLOPS.  THE TEST ALSO CHECKS THE "DK20 REQUESTING" FLOP ON THE PI
BOARD.  THE TEST:  1) SETS ALL PIU LEVELS "ON" & "PI ACTIVE".  2) SETS THE "MTR PIA"
REGISTER WITH (1-7), THEN CYCLES THE PI BOARD TO "TIM3", WHICH SHOULD THEN

SET THE DK20 REQUESTING" FLOP.  THE CYCLING TO "TIM3' SHOULD ALSO SET A PI REQUEST.
        THE SECOND PHASE OF THE TEST CHECKS THE DTE20'S "PI REQ 0" LINE TO THE
PI BOARD.  IT TESTS THAT THE DTE20 CAN CAUSE A PIR EQUEST ON LEVEL 0.
%

PIZZA8: MOV     #DEL09,R3       ;GET POINTER TO MCOMP CHANGES
        MOV     #DEL08,R2       ;GET POINTER TO MCOMP NUMBER OF CHANGES
        MOV     #DEL07,R1               ;GET POINTER TO "MTR PIA" DATA
        MOV     #DEL06,R4       ;GET POINTER TO "CONO PI" DATA
        MOV     #DEL04,DEL04A   ;GET POINTER TO "CONO TIM" DATA

DEL01:  MOV     #MIC8PI,R0      ;C-RAM START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        INSYNC                  ;COUNTE SUBTESTS
        MOV     R4,R0           ;FINALLY, GET ADDRESS OF CONO PI DATA
        ARLOD2                  ;SEND TO EBOX
        MOV     #^D19,R0        ;EXECUTE CONO PI TO SET ACTIVE & PI LEVELS
        BURST                   ;CLOCK GO

DEL1A:  BICB    #34,DEL05+2     ;CLEAR EBUS BITS 15,16,17
        BISB    (R1)+,DEL05+2   ;SET "MTR PIA" DATA TO THE "CONO9 MTR" WORD
        MOV     DEL04A,R0       ;"CONO TIM" DATA TO AR TO INIT MTR BRD
        ARLOD2                  ;DATA ACROSS EBUS TO AR
        ECLOK                   ;CLOCK THAT DATA TO THE BR


;SEQ384

$ARLO2  DEL05           ;AND LOAD TO AR.
        MOV     #^D20+^D79+^D1+^D75,R0  ;EACH GROUP OF TICS DOES THE FOLLOWING:
                                ;20 TICS EXECUTES "CONO TIM"
                                ;79 TICS GIVES 2 "1 MHZ CLOCKS"
                                ;"2 TIMES MHZ RATE(29) + 21 TICS
                                ;1 TIC GIVE SSYNCRONIZING CLOCK TO MHZ CNTR
                                ;75 TICS GETS UT TO "TIM6"
        BURST                   ;AND GO

        $MCOMP                  ;MODIFY EXPECTED DATA
        PI.CHK                  ;CHECK EXPECTED PI DATA
        $RCOMP                  ;RESTORE ORIGINAL EXPECTED

        CMP     #^D4,R5         ;TIME FOR NEXT "CONO PI" DATUM
        BNE     DEL02           ;BR IF NO

        ADD     #5,R4           ;HEWRE IF YES, NEW CONO PI DATUM
;CONTINUE WITH THE TEST
DEL02:  CMP     #^D12,R5                ;TIME FOR PHASE 2 OF THE TEST
        BGT     DEL01           ;NOT YET, BACK TO THE BEGINNING
        MOV     #ZERO,DEL04A    ;SET "CONO TIM" DATA TO BE ZEROES
        CMP     #^D13,R5        ;NEXT SECTION OF CODE?
        BGT     DEL01           ;BR IF NOT YET


;SEQ385

;SECOND PHASE OF THIS TEST CHECKS THE PI REQUEST 0 FLOP AND THE
;"PI ON 0" GATE.
DEL2A:  ADD     #5,R4           ;NEED NEW CONO PI DATA FOR THIS TEST GROUP
        TSTB    (R1)+                   ;ADD ONE TO REG R1 TO SWITCH TO WORD DATA
DEL03:  MOV     #M8.1PI,R0      ;NEW MICRO-CODE
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"

        INSYNC                  ;COUNT THE SUBTESTS
        BIS     (R1),2(R4)      ;SET CORRECT GEN LEVELS THIS TEST
        MOV     R4,R0           ;GET DATA ADDRESS
        ARLOD2                  ;DATA TO  AR

        MOV     #^D28,R0        ;NUMBER OF CLOCK TICS FOR THIS TEST
        BURST                   ;CLOCK GO.
        $MCOMP                  ;MODIFY EXPECTED

        PI.CHK                  ;CHECK STATE OF PI BOARD
        $RCOMP                  ;RESTORE EXPECTED

        BIC     (R1)+,2(R4)     ;CLEAR PREVIOUS GEN AND UPDATE R1 FOR NEXT
        CMP     #^D16,R5        ;READY FOR LAST SUBTEST

        BGT     DEL03           ;STAY IN LOOP IF NOT


;SEQ386

;HERE FOR ONE LAST SUBTEST
        INSYNC                  ;COUNT A SUBTEST
        ADD     #5,R4           ;NEXT CONO NEEDED

        MOV     #M8.2PI,R0      ;MICRO-CODE START ADDRESS
        JSR     PC,RUN.GO       ;LOAD DIAG ADR REG & SET "RUN"
        MOV     R4,R0           ;GET ADDRESS OF CONO DATA
        ARLOD2                  ;DATA TO AR
        DFXCTT                  ;AND START THE CLOCK RUNNING
        STRCLK

;IT IS NOW NECESSARY TO STROKE THE DTE20 AND GET IT
;TO REQUEST AN INTERRUPT ON LEVEL 0.

        CLR     R0              ;USE REG 0

        MOV     R0,@.TENA1      ;BEGIN A DTE20 KL10 EXAMINE
        MOV     R0,@.TENA2      ;FINISH IT & CAUSE DTE20 TO ISSUE PIRO
        DFXCTT                  ;STOP THE KL10 CLOCK IN ORDETR TO
        STPCLK                  ;READ THE PI BOARD & SEE IF PIRO WAS GENERATED

$MCOMP          ;MODIFY EXPECTED
        PI.CHK                  ;CHECK STATE OF PI BOARD
        $RCOMP                  ;RESTORE ORIGINAL EXPECTED

        JMP     NORMAL          ;ALL DONE


;SEQ387

DEL04A: .WORD   0               ;ADDR OF CURRENT "CONO TIM" DATA
DEL04:  WD36 0000,0044,0000     ;DATA FOR "CONO TIM" TO ENABLE MTR INTERRUPTS
DEL05:  WD36 0020,0000,0000     ;DATA FOR ":CONO MTR". LOADS PI MTR PIA FLOPS & ENABLES M

;LIST OF "CONO PI" DATA FOR THE VARIOUS SUBTESTS
DEL06:  WD36 0002,0000,0000     ;CONO PI DATA TO SET PI ACTIVE
        WD36 0023,7700,0000     ;CONO PI DATA SETS PI ACTIVE & ALL LEVELS ON
        WD36 0042,0000,0000     ;CONO PI DATA SETS GEN LEVELS
        WD36    0211,7700,0000  ;CONO PI CLERS ALL LEVELS & ACTIVE

;LIST OF MTR PIA DATA FOR SETTING DIFFERENT PIA LEVELS
DEL07:  .BYTE   7*4             ;PIA 7 - ST1
        .BYTE   4*4             ;PIA 4 - ST2
        .BYTE   2*4             ;PIA 2 - ST3
        .BYTE   1*4             ;PIA 1 - ST4

        .BYTE   1*4             ;PI REQ LVL 1 - ST5
        .BYTE   2*4             ;PI REQ LVL 2 - ST6
        .BYTE   3*4             ;PI REQ LVL 3 - ST7
        .BYTE   4*4             ;PI REQ LVL 4 - ST8
        .BYTE   5*4             ;PI REQ LVL 5 - ST9
        .BYTE   6*4             ;PI REQ LVL 6 - ST10
        .BYTE   7*4             ;PI REQ LVL 7 - ST11
        .BYTE   0               ;PI REQ INH - ST12
        .BYTE   7*4             ;PI REQ WITH "-MTR VECTOR INTERRUPT"
        .EVEN
        .WORD   10*4            ;GEWN LVL 4 -ST14       ;REMEMBER TO KEEP EVEN # OF BYTES TO HE
        .WORD   40*4            ;GEN LVL 2 - ST15
        .WORD   100*4           ;GEN LVL 1 -ST16

;MCOMP NUMBER OF CHANGES TABLE
DEL08:  .BYTE   3               ;ST1
        .BYTE   3               ;ST 2
        .BYTE   3               ;ST 3
        .BYTE   3               ;ST 4
        .BYTE   6               ;ST 5
        .BYTE   6               ;ST 6
        .BYTE   7               ;ST 7
        .BYTE   6               ;ST 8
        .BYTE   7               ;ST 9
        .BYTE   6               ;ST 10
        .BYTE   7               ;ST 11
        .BYTE   3               ;ST 12
        .BYTE   4               ;ST 13
        .BYTE   4               ;ST 14
        .BYTE   4               ;ST 15
        .BYTE   4       ;ST 15
        .BYTE   1               ;ST 17



;SEQ388

;MCOMP ACTUAL CHANGES
DEL09:  .BYTE   1
        .BYTE   200             ;"PI ACTIVE"
        .BYTE   5
        .BYTE   4               ;SCD PI4 DEFAULTS WITH NO PI REQ
        .BYTE   11
        .BYTE   7               ;SUBTEST 1 - "MTR PIA 04, 02, 01"

        .BYTE   1      
        .BYTE   200             ;"PI ACTIVE"
        .BYTE   5
        .BYTE   4               ;SCD PI4 DEFAULTS WITH NO PI REQ
        .BYTE   11
        .BYTE   4               ;SDUBTEST 2 - "MTR PIA 04"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE"
        .BYTE   5
        .BYTE   4               ;SCD PI4 DEFAULTS WITH NO PI REQ
        .BYTE   11
        .BYTE   2               ;SUBTEST 3 - "MTR PIA 02"

        .BYTE   1
        .BYTE   200             ;"PI ACTIVE"
        .BYTE   5
        .BYTE   4               ;SCD PI4 DEFAULTS WITH NO PI REQ
        .BYTE   11
        .BYTE   1               ;SUBTEST 4 - "MTR PIA 01"

        .BYTE   1
        .BYTE   377             ;SUBTEST 5 - "ACTIVE & AL LEVELS "ON"
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   166             ;TIMER DONE, EBUS PI GRANT, HONOR INTERNAL, READY
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   11
        .BYTE   1               ;MTR PIA 01
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)


;SEQ389

        .BYTE   1       
        .BYTE   377             ;SUBTEST 6 - ":ACTIVE " & ALL LEVELS "ON"
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   166             ;TIMER DONE, EBUS PI GRANT, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   2               ;SCAD PI2
        .BYTE   11
        .BYTE   2               ;MTR PIA 02
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)

        .BYTE   1
        .BYTE   377             ;SUBTESAT - "ACTIVE" & LL LEVELS "ON"
        .BYTE   3
        .BYTE   156             ;PI2,PI1
        .BYTE   4
        .BYTE   166             ;TIMER DONE, EBUS PI GRANT, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   2               ;SCAD PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   11
        .BYTE   3               ;MTR PIA 02, 01
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)

        .BYTE   1
        .BYTE   377             ;SUBTEST 8 - "ACTIVE" & ALL LEVELS "OPN"
        .BYTE   3
        .BYTE   16              ;DEFAULT SEL PHY8
        .BYTE   4
        .BYTE   176             ;TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   4               ;SCAD PI4
        .BYTE   11
        .BYTE   4               ;MTR PIA 04
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)


;SEQ390

        .BYTE   1
        .BYTE   377             ;SUBTEST 9 - "ACTIVE" & ALL LEVELS "ON"
        .BYTE   3
        .BYTE   56              ;PI1
        .BYTE   4
        .BYTE   176             ;TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   4               ;SCAD PI4
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   11
        .BYTE   5               ;MTR PIA 04, 01
        .BYTE   12
        .BYTE   10              ;MTR VECTOR (PI3 MTR HONOR)

        .BYTE   1
        .BYTE   377             ;SUBTEST 10 - "ACTIVE" & ALL LEVELS "ON"
        .BYTE   3
        .BYTE   116             ;PI2
        .BYTE   4
        .BYTE   176             ;TIMER DONE, EBUS PI GRANT, PI4, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   6               ;SCAD PI4, PI2
        .BYTE   11
        .BYTE   6               ;MTR PIA 04,02
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)

        .BYTE   1
        .BYTE   377             ;SUBTEST 11 - "ACTIVE" & ALL LEVELS "ON"
        .BYTE   3
        .BYTE   156             ;PI2, PI1
        .BYTE   4
        .BYTE   176             ;TIMER DONE, PIE BUS GRANT, PI4, HONOR INTERNAL, READY
        .BYTE   5
        .BYTE   6               ;SCAD PI4, PI2
        .BYTE   6
        .BYTE   10              ;SCAD PI1
        .BYTE   11
        .BYTE   7               ;MTR PIA 04, 02 , 01
        .BYTE   12
        .BYTE   10              ;MTR VECTOR REQ (PI3 MTR HONOR)



;SEQ391

        .BYTE   1
        .BYTE   377             ;SUBTEST 12 - "ACTIVE" & ALL LEVELS "ON"
        .BYTE   4
        .BYTE   24              ;"HONOR INTERNAL"
        .BYTE   5
        .BYTE   4               ;SCAD TRAP MIX 32(PI4) DEFAULT

        .BYTE   1
        .BYTE   377             ;SUBTEST 13 - "ACTIVE" & ALL LEVELS "ON"
        .BYTE   4
        .BYTE   24              ;"HONOR INTERNAL"
        .BYTE   5
        .BYTE   4               ;SCAD TRAP MIX 32(PI4) DEFAULT
        .BYTE   11
        .BYTE   7               ;MTR PIA 04, 02, 01

        .BYTE   1
        .BYTE   200             ;SUBTEAST 14 - "ACTIVE"
        .BYTE   2
        .BYTE   10              ;GEN LEVEL 4
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   4               ;SCAD PI4
        .BYTE   1
        .BYTE   200             ;SUBTEST 15 - "ACTIVE"
        .BYTE   2
        .BYTE   40              ;GEN LEVEL 2
        .BYTE   4
        .BYTE   24              ;HONOR INTERNAL
        .BYTE   5
        .BYTE   2               ;SCAD PI2

        .BYTE   1
        .BYTE   200             ;SUBTEST 16 - "ACTIVE"
        .BYTE   2
        .BYTE   100             ;GEN LEVEL 1
        .BYTE   4
        .BYTE   24              ;HONOR ITNERNAL
        .BYTE   6
        .BYTE   10              ;SCAD PI1

         .BYTE  4
        .BYTE   25              ;SUBTEST 17 - "EBUS REQ" CAUSED BY A PIR0
.EVEN


;SEQ392

.SBTTL TEST 35 (EPAR1): PARITY TEST - APR FM 36 RAM CHIP ADDRESS & DATA TEST

.REM    %
THIS TEST IS DESIGNED TO TEST THE "APR FM 36" 128 X 1 RAM CHIP, BOTH
DATA AND ADDRESSING OPERATION.  FIRST WE ATTEMPT TO FILL EVERY RAM
LOCATION WITH A 0.  THIS PASS OF THE TEST WILL FIND ANY STUCK-AT-ONE
BITS, NEXT.  WE BEGIN AN ADDRESSING TEST.  WE READ THE ZERO IN LOCATION
ZERO TO INSURE IT HASN'T CHANGED.  THEN WRITE A ONE.  GO TO NEXT ADDRESS
VERIFY THE ZERO HAS NOT VEEN CHANGED, WRITE A ONE, THEN GIO TO NEXT
ADDRESS.  REPEAT THE SEQUENCE TO THE LAST RAM ADDRESS.  THE RAM
SHOULD NOW BE FULL OF ONES.  NOW WE WILL START AT THE LAST RAM
ADDRESS, VERIFY THAT THE ONE IS THERE AND THEN WRITE A ZERO.  DECREMENT
THE  LOCATION, VERIFY THE ONE, WRITE A ZERO.  DO THIS UNTIL THE WHOLE
RAM HAS BEEN REFILLED WITH ZEROES.  THIS LAST TREST PHASE MAY FAIL
BECAUSE OF EITHER ADDRESSING PROBLEMS, OR BITRS STUCK-AT-ZERO.
%
EPAR1:  MOVB    #1,EWORD1+2     ;TELL CONO PI TO SET "WR EVEN PAR DATA"
        MOV     #MPAR1,R0               ;MICRO-CODE START ADDRESS
        WWADR                   ;WRITE IT TO 10 AND RESET
        ECLOK                   ;FIRST WORD TO C.R.
        MOV     #ZERO,R2        ;MCOMP NUMBER OF CHANGES ALWAYS ZERO
        CLR     R1              ;A CLEARED R1 SAYS "FIRST PASS"
;*******REV 9 ECO SAYS EXPECT "FM WRITE PAR L" FALSE
        MOVB    #376,PARMSK+2   ;DONT LOOK AT ARX PARITY THIS TEST

KAREN1: CLR     R4              ;R4 WILL HAV EBLOCK & AC NUMBER
        MOV     #EWORD1,R0
        ARLOD2                  ;CONO PI DATA TO AR (TO SET "WR EVEN PAR DATA")
        MOV     #^D21,R0        ;NEED 18 CLOCKS TO DO THE CONO
        BURST

;NOW GO TO ROUTINE WHICH LOADS BLOCK & AC TO THE AR,
;EXECUTES THE TEST MICRO-CODE AND REDS THE KL10 FOR
;CORRECT RESULTS.


KAREN2: INSYNC                  ;COUNT SUBTESTS
        JSR     PC,SFMADR       ;ROUTINE TO SET FM ADDRESS
        ADD     #4,R4           ;ADVANCE TO NEXT AC
        BIT     #BIT6,R4        ;ALL AC'S DONE, TI E FOR NWEW BLOCK??
        BEQ     KAREN2          ;BR IF NOT YET

        BIC     #3777,R4        ;BACK TO AC ZERO
        ADD     #4000,R4        ;NEXT BLOCK
        BIT     #40000,R4       ;DONE ALL BLOCKS?
        BEQ     KAREN2          ;BR IF NOT YET


;SEQ393

;DONE ALL BLCOKS IF HERE, NOW SEE IF FIRST OR SECOND PASS
        TST     R1              ;IF R1=0,FIRST PASS
        BNE     KAREN3          ;BR IF WAS SECOND PASS

;IF HERE, JUST FINISHED FIRST PASS - NOW GET READY FOR SECCOND
        COM     R1              ;SET FLAG TO SAY FIRSRPASS DONE
        CLEAR                   ;RESET THE 10
        ECLOK
        CLR     EWORD1+2
        MOV     #EWORD1,R0      ;GET CONO PI DATA TO CLEAR "WR EVEN PAR DATA"
        CLRB    PAREXP          ;AND DONT EXPECT IT ON ANYMORE EITHER
        MOVB    #202,PAREXP+7   ;EXPECT "CON AR 36"
        MOVB    #20,PAREXP+3    ;EXPECT "SH AR PAR OODD"
        BR      KAREN1          ;GO MAK PASS TOW
;THIS SECTION OF TEST IS THE THIRD PHASE OF THE RAM TEST AND READS 1'S AND WRITES
;ZEROES TO THE RAM, STARTING AT THE REATEST RAM ADDRESS AND RUNNING TO ADDRESS 0.
KAREN3: CLEAR                   ;RESET
        ECLOK                   ;FIRST WORD TO C.R.
        CLR     R4              ;START FM ADR COUNT AT ZERO
        CLR     EWORD1+2        ;GET RID OF OLD FM ADDR DATA
        MOVB    #1,EWORD1+2     ;SET "WR EVEN PAR DATA" AGAIN
        MOVB    #1,PAREXP       ;AND EXPECT IT
        MOVB    #3,PAREXP+4     ;EXPECT "APR FM 36" & "FM ODD PARITY" ALWAYS ONE
        MOVB    #2,PAREXP+7     ;EXPECT NOT "CON AR 36"
        CLRB    PAREXP+3                ;AND NO MOARE "SH AR PAR ODD"
        MOV     #EWORD1,R0      ;ADDRESS OF EBUS DATA
        ARLOD2                  ;PUT IT IN AR
        MOV     #^D21,R0        ;AND ACTUALLY EXECUTE THE
        BURST                   ;MICRO-CODE TO SET IT
KAREN4: INSYNC                  ;COUNT SUBTESTS
        JSR     PC,CFMADR       ;ROUTINE TO SET COMPLIMENT OF FM ADDRESS

        ADD     #4,R4           ;NEXT AC
        BIT     #BIT6,R4        ;IF ALL AC'S DONE, NEW BLOCK
        BEQ     KAREN4          ;BR IF NOT YET

        BIC     #3777,R4        ;BACK TO AC ZERO
        ADD     #4000,R4                ;NEXT BLOCK
        BIT     #40000,R4       ;DDONE ALL BLOCKS?
        BEQ     KAREN4          ;BR IF NOT YET
        JMP     NORMAL          ;OUT IF YES


;SEQ394

;ENTRY POINT TO FM ADDRESS ROUTINE WHICH COMPLIMENTS REGISTER R4 AND USES
;THE COMPLIMENTED DATA AS THE ADDRESS FOR THE IMPEDING SUBTEST
CFMADR: PUSH    R4              ;SAVE R4 VALUE ON THE STACK

        COM     R4              ;COMPLIMENT THE PASSED FM ADDR
        BIC     #3,R4           ;CLEAR UNUSED BITS
        BR      BAKDOR          ;ENTER FM ADDRESS ROUTINE VIA BACKDOOR

;NON-COMPLIMENTING ENTRY POINT USES R4 AS IS
SFMADR: PUSH    R4              ;SAVE R4 ON STACK & GO

BAKDOR: MOV     R4,EWORD1+2     ;FM BLOCK 7 ADDRESS TO 36 BIT DATA BUFFER
        $ARLO2  EWORD1          ;BLOCK & ADDRESS DATA TO AR FOR PROCESSING
        MOV     #^D18,R0        ;18 CLOCKS EXECUTES THE MICRO-CODE
        BURST                   ;RUN THE CLOCK
        POP     R4              ;BRING BACK R4

        TST     R1              ;SEE IF INITIALIZING RAM TO ALL 0'S
        BNE     1$              ;IF NOT, CHECK STATE OF PARITY LOGIC
        MOV     #^D4,R0         ;CLOCK TICS TO FINISH MIC-CODE
        BURST                   ;EXECUTE THOSE CLOCKS
        DEC     R5              ;OTHERWISE.. DONT COIUNT SUBTESTS
        RTS     PC              ;DONT DO NOTHIN'
1$:     PARCHK                  ;GO CHECK ALL PERTINENT PARITY INFORMATION
        MOV     #^D4,R0         ;CLOCKS TO FINISH THE MICRO-CODE
        BURST                   ;EXECUTE
        DEC     R2              ;MCOMP # CHANGES ALAYS 0.
        RTS     PC              ;OUT OF HERE IS ALL OK


;SEQ395

.SBTTL TEST 36 (EPAR2):  AR & ARX PARITY CHAIN, CON AR & ARX PARITY BIT GENERATOR & CLK

 
.REM    %
IT IS THE PURPOSE OF THIS TEST TO CHECK THE AR/ARX PARITY CHAIN
LOCATED ON THE SHIFTER BOARD, THE "CON AR 36" LOGIC ON
THE CON BOARD WHICH IS USED TO GENERATE THE ODD PARITY BIT, AND
THE PARITY CHECKING LOGIC ON THE CLK BOARD WHICH STOPS THE CLOCK, OR CAUSES
A PAGE FAIL ON FM, AR, OR ARX BAD PARITY.
        THE TEST BEGINS BY SELECTING ONEFM LOCATION AND USING IT
THROUGHOUT THE ENTIRE TEST.  WE ATTEMPT TO SET THE FM 36 BIT TO A ONE OR
A ZERO AS THE TEST REQUIRES AND ON EACH SUBTEST WE CHECK THAT THE FM 36 BIT HAS INDEED
GONE TO A ONE OR ZERO.  IF IT HAS NOT THE FAILURE COULD BE IN THAT RAM CHIP.
        SUBTESTS 1-10 ARE LOADING UP TEST PATTERNS TO TEST
THE "CON AR 36" LOGIC AN THE  "CON ARX 36" LOGIC.  IN CONJUNCTIINW ITH THE FM 36 BIT
WE ARE ALSO SETTING AND CLEARING "-CON MBOX DATA?", "-CON FM DATA", "CON FM BIT 36"
"CON AR LOADED",:CON ARE FROM MEM", AND "CON ARX LOADED", ALL NECESSARY IN THE
;CON AR 36" AND "CON ARX 36" TEST PATTERNS.  IT IS POSSIBLE THAT "CSH PAR BIT A"
AND "CSH PAR BIT B" COULD CAUSE THESE SUBTESTES TO FAIL BECAUSE THE EBOX HAS
NO CONTROL OVER THESE BITS.  WE EXPECT THEM TO BE IN THEIR RESET STATE (LO).
        WHIULE SUBTESTS 1-10 ARE OCCURRING, WE ALSO LOAD THE AR AND ARX
REGISTERS WITH DATA, WHICH WHEN COMBINEDWITH "CON AR 36" AND "CON ARX 36" TEST
THE AR AND ARX PARITY CHAIN LOGIC FOUND ON THE SHIFTER BOARD.

        FINALLY, WE USE "CON AR LOADED" & "CON ARX LOADED" WITH "SH AR PAR ODD"
AND :SH ARX PAR ODD" TO TEST  THE "CLK PAGE FAIL" LOGIC.
%
EPAR2:  MOV     #NMEX02,R4      ;GET POINTER TO STIMULUS DATA FOR TEST PATTERNS
        MOV     #NMEX04,R2      ;GET POINTER TO MCOMP NUMBR OF CHANGES
        MOV     #NMEX05,R3      ;GET POINTER TO ACTUAL CHANGES TABLE
        MOV     #NMEX03,R1     ;POINT TO LIST OF AR & ARX PARITY PATTERNS

NMEX01: MOV     #MPAR2,R0       ;MICRO-CODE START ADDRESS
        WWADR                   ;WRITE IT TO DIAG ADDR REG
        INSYNC                  ;COUNT SUBTESTS
        M.RESPSIM               ;SET "MBOX RESP SIM"
        ECLOK                   ;FIRST WORD TO C.R.

        MOVB    (R4),R0         ;STIMULUS BYTE -- CHECK IF FM BIT=0 OR =1
        COM     R0
        BIC     #177776,R0      ;IF FM BIT=0, NEEDA 1 IN AR
        MOVB    R0,EWORD1       ;IF FM BIT=1, NEED A 0 IN AR

        $ARLO2  EWORD1          ;DATA TO AR
        ECLOK                   ;AND WRITE FM BIT 36 IN RAM
        CLRB    EWORD1          ;THAT DATA IS NOW CLEARED

;NEXT, NEED TO GET "WR EVEN PAR DATA" BIT FOR A CONO
        MOVB    (R4),R0         ;GET STIMULUS BYTE
        BIC     #177773,R0      ;CLEAR ALL BITS EXCEPT "WR EVEN PAR DATA"
        ASR     R0              ;JUSTIFY
        ASR     R0              ;CORRECTLY
        MOVB    R0,EWORD1+2     ;SET THE BIT IN THE 36 BIT BUFFER
        $ARLO2  EWORD1          ;CONO DATA TO AR


;SEQ396

        ECLOK                   ;AND A CLOCK TO EXECUTE IT
        CLRB    EWORD1+2        ;CLR OLD DATA
;NEXT BIT SAYS TO CAUSE "-MBOX DATA" (IF 1) OR "MBOX DATA" (IF 0)
        MOVB    (R4),R0         ;GET STIMULUS BYTE
        COM     R0              ;INVERT DATA
        BIC     #177775,R0      ;CLEAR ALL BITS EXCEPT "MBOX DATA" BIT
        MOVB    R0,EWORD1+1     ;SET THE BIT IN THE 36 BIT BUFFER
        $ARLO2  EWORD1          ;DATA TO AR
        ECLOK                   ;AND CLOCK TO VMA
        CLRB    EWORD1+1        ;CLR OLD DATA
;FINAL BIT IS FOR "AR FROM MEM"
        BITB    #10,(R4)+       ;TEST FOR "AR FROM MEM"
        BEQ     1$              ;BR IF UNNECESSARY

        MOV     #DPARX1!BIT15,R0        ;HERE IF NEED SET "AR LOADED"
        BR      2$              ;CONTINUE
1$:     MOV     #DPARX2!BIT15,R0        ;HERE IF "ARX LOADED"
        
2$:     WWADR

;NOW LAOD 36-BIT DATA PATTERNS INTO AR & ARX FOR AR & ARX PARITY TEST
        MOV     R1,R0           ;GET AR/ARX PARITY DATA
        ARLOD2          ;DATA TO AR

        MOV     #7,R0           ;AND EXECUTE RAM CODE TO SET "FM DATA", "MBOX DATA", ETC
        BURST                   ;CALL TO DO THE BURST

        PARCHK                  ;GO CHECK TEST RESULTS
        ADD     #^D5,R1         ;NEXT AR/ARX PARITY DATUM
        CMP     #^D10,R5        ;ALL DONE?
        BGT     NMEX01  ;BR BACK IF NO
        JMP     NORMAL          ;OUT IF YES

;SEQ397

.REM    %
        ****TEST PATTERNS USED IN THIS TEST****
        AR      +WR     -MBOX   FM
        FROM    EVEN    DATA H  BIT
        MEM     PAR     FM      36
        (TRUE)  DATA H  DATA L  H
        *****   *****   *****   *****
ST 1    0       0       1       1
ST 2    1       1       1       1
ST 3    1       0       1       1
ST 4    0       0       0       1
ST 5    0       0       1       0
ST 6    0       0       1       1       
ST 7    0       1       1       1
ST 8    1       0       0       1
ST 9    1       0       1       0
ST 10   0       1       1       1
%
;TABLE OF TEST PATTERN STIMULUS BYTES
NMEX02: .BYTE   3               ;ST 1
        .BYTE   17              ;ST 2
        .BYTE   13              ;ST 3
        .BYTE   1               ;ST 4
        .BYTE   2               ;ST 5
        .BYTE   3               ;ST 6
        .BYTE   7               ;ST 7
        .BYTE  11              ;ST 8
        .BYTE   12              ;ST 9
        .BYTE   7               ;ST 10

;TABLE OF AR/ARX 36 BIT PARITY CHAIN PATTERNS
NMEX03: WD36 1636,7756,5241     ;ST1-AR 36 T-ARX 36 T-ODD-T-T
        WD36 4071,4471,7374     ;ST2-AR 36 T-ARX 36 T-ODD-T-T
        WD36 6564,2524,6706     ;ST3-AR 36 T-ARX 36 T-ODD-F-F
        WD36 0,0,0              ;ST4-AR 36 T-ARX 36 F-ODD-T-F
        WD36 5647,3327,2135     ;ST5-AR 36 T-ARX 36 F-ODD-T-F
        WD36 3323,1603,4633     ;ST6-AR 36 T-ARX 36 T-ODD-F-F
        WD36 0,0,0              ;ST7-AR 36 F-ARX 36 T-ODD-F-T
        WD36    2515,6155,1472  ;ST8-AR 36 F-ARX 36 F-ODD-T-T
        WD36 7352,5272,3547     ;ST9-AR 36 F-ARX 36 F-ODD-T-T
        WD36 5647,3327,2135     ;ST10-AR36 F-ARX 36 T-ODD-F-T

;MCOMP NUMBER OF CHANGES TABLE
NMEX04: .BYTE   5               ;ST1
        .BYTE   7               ;T2
        .BYTE   4               ;ST3
        .BYTE   4               ;ST4
        .BYTE   3               ;ST5
        .BYTE   3               ;ST6
        .BYTE   4               ;ST7
        .BYTE   4               ;ST8
        .BYTE   4               ;ST9
        .BYTE   4               ;ST10


;SEQ398

;MCOMP ACTUAL CHANGES TABLE
NMEX05: .BYTE   2
        .BYTE   21              ;SUBTEST 1 - "ARX PAPR ODD
        .BYTE   3
        .BYTE   20              ;"AR PAR ODD"
        .BYTE   4       
        .BYTE   3               ;"APR FM 36" & "FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"
        .BYTE   10              
        .BYTE   200             ;"CON ARX 36"

        .BYTE   0
        .BYTE   1               ;SUBTEST 2 - "WR EVEN PAR DATA "
        .BYTE   2
        .BYTE   21              ;"ARX PAR ODD"
        .BYTE   3
        .BYTE   20              ;"AR PAR ODD"
        .BYTE   4
        .BYTE   3               ;"APR FM 36" & "FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"
        .BYTE   10
        .BYTE   200             ;"CON ARX 36"
        .BYTE   11
        .BYTE   100             ;"CON AR LOADED"
        .BYTE   4
        .BYTE   3               ;SUBTEST 3 - "APR FM 36" & "FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"
        .BYTE   10
        .BYTE   200             ;"CON ARX 36"
        .BYTE   11
        .BYTE   100             ;"CON AR LOADED"

        .BYTE   3
        .BYTE   20              ;SUBTEST 4 - "AR PAR ODD"
        .BYTE   4
        .BYTE   3               ;"APR FM 36" & "FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"
        .BYTE   12
        .BYTE   0               ;"CON ARX LOADED"


;SEQ399

        .BYTE   3
        .BYTE   20              ;SUBTEST 5 - "AR PAR ODD"
        .BYTE   4
        .BYTE   1               ;"FM ODD PARITY"
        .BYTE   7               
        .BYTE   202             ;"CON AR 36"

        .BYTE   4
        .BYTE   3               ;SUBTEST 6 - "APR FM 36" & "FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"
        .BYTE   10
        .BYTE   200             ;"CON ARX 36"
        .BYTE   0
        .BYTE   1               ;SUBTEST 7 - "WR EVEN PAR DATA"
        .BYTE   2
        .BYTE   21              ;"ARX PAR ODD"
        .BYTE   4
        .BYTE   3               ;"APR FM 36" & "FM ODD PARITY"
        .BYTE   10
        .BYTE   200             ;"CON ARX 36"

        .BYTE   2
        .BYTE   21              ;SUBTEST 8 - "ARX PAR ODD"
        .BYTE   3
        .BYTE   20              ;"AR PAR ODD"
        .BYTE   4
        .BYTE   3               ;"APR FM" & "FM ODD PARITY"
        .BYTE   11
        .BYTE   100             ;"CON AR LOADED"
        .BYTE   2
        .BYTE   21              ;SUBTEST 9 - "ARX PAR ODD"
        .BYTE   3
        .BYTE   20              ;:AR PAR ODD"
        .BYTE   4
        .BYTE   1               ;"FM ODD PARITY"
 
        .BYTE   11
        .BYTE   100             ;"CON AR LOADED"

        .BYTE   0
        .BYTE   1               ;SUBTEST 10 - "CON WR EVEN PAR DATA"
        .BYTE   2
        .BYTE   21      ;'ARX PAR ODD"
        .BYTE   4
        .BYTE   3               ;"APR FM 36" & "FM ODD PARITY"
        .BYTE   10
        .BYTE   200             ;"CON ARX 36"


;SEQ400

.SBTTL TEST 37 (EPAR3): AR(ARX) PARITY PAGE FAIL, FM PARITY CHAIN, FM PARITY ERR STOP

.REM    %
THIS T EST CHECKS THAT BAD AR PAITY OR BAD ARX PARITY CAUSES CLK PAGE FAILS
AND THAT THE RIGHT PAGE FAIL ADDRESS GOES TO THE OCNTROL RAM ADDRESS BOARD.
        IT ALSO CHECKS THE FM (FAST MEMORY) PARITY CHAIN WORKS AND ALSO THAT
BAD FAST MEMORY PARITY CAUSES A CLK ERROR STOP.
%
;ENTER PHASE OF THE TESTS WHERE WE CHECK THE FM PARITY
;CHAIN AND ALSO THE ABILITY OF BAD FM PARITY TO FORCE A
;CLK ERROR STOP
 
EPAR3:  MOV     #NJER05,R4      ;GET POINTER TO STIMUUS BYTE TABLE
        MOV     #NJER07,R2      ;GET POINTER TO MCOMP NUMBER OF CHANGES TABLE   
        MOV     #NJER08,R3      ;PNTR TO MCOMP ACTUAL CHANGES TABLE

        MOV     #MPAR3A,R0      ;MICRO START ADDRESS TO R0
        WWADR                   ;WRITE IT TO KL10 AND RESET

        MOV     #NJER06,R1      ;PNTR TO LIST OF TEST PATTERNS FOR FM PARITY CHAIN
NJER03: INSYNC                  ;COUNT SUBTESTS
        MRESET                  ;CAREFUL HERE.. MACHINE NEEDS 2 RESETS
        CLEAR                   ;RESET
        ECLOK                   ;FIRST WORD TO C.R.
        MOVB    (R4),R0 ;GET STIMULUS BYTE
        BIC     #177775,R0      ;ONLY KEEP ":WR EVEN PAR DATA" BI
        ASR     R0
        JSR     PC,NJER99       ;LOAD DATA TO AR AND EXECUTE CONO TO SET IT
        MOV     R1,R0           ;GET 36 BIT PARITY TEST PATTERN
        ARLOD2                  ;LOAD IT TO AR
        BITB    #BIT0,(R4)+     ;SEE IF NEED :"FM PARITY CHECK"
        BNE     NJER04          ;BR IF NEED
;HERE IF NEED FM PARITY SET
        $CLRWD                  ;CLEAN A 36-BIT BUFFER
        MOV     #10,EWORD1      ;SET THE "FM PAR CHECK" BIT
        DFWRTT                  ;AND SET THE CHECK ON IN THE KL10
        EWORD1                  ;DATRA WITH CORRECT (32) BIT SET
        LDCHK1                  ;DIAG FUNCTION TO WRITE

NJER04: MOV     #5,R0           ;EXECUTE THE MICRO CODE
        BURST                   ;PLUS HALF A CLOCK

        PARCHK                  ;AND CHECK THE STATE OF THE PARITY LOGIC

        ADD     #5,R1           ;NEXT FM PARITY DATUM
        CMP     #^D8,R5         ;ALL DONE?
        BGT     NJER03          ;BACK IF NO
        JMP     NORMAL          ;OUT IF YES


;SEQ401

NJER99: MOVB    R0,EWORD1+2     ;SET BITS IN 36-BIT BUFFER
        $ARLO2  EWORD1          ;DATA TO AR
        ECLOK                   ;PLUS A CLOCK
        RTS     PC              ;AND OUT

;SEQ402

NJER05: .BYTE   2               ;ST 1 - "WR EVEN PAR DATA"
        .BYTE   1               ;ST 2 - "FM PAR CHECK"
        .BYTE   2               ;ST 3 - "WR EVEN PAR DATA"
        .BYTE   1               ;ST 4 - "FM PAR CHECK"
        .BYTE   1               ;ST 5 - "FM PAR CHECK"
        .BYTE   1               ;ST 6 - "FM PAR CHECK"
        .BYTE   3               ;ST 7 - "WR EVEN PAR DATA", "FM PAR CHECK"
        .BYTE   3               ;ST 10 - "WR EVEN PAR DATA","FM PAR CHECK"

;LIST OF 36 BIT PARITY TEST PATTERNS FOR THE
;FAST MEMORYT PARITY CHAIN
NJER06: WD36 0000,0000,0000             ;ST 1 - "FM PAR ODD" FALSE
        WD36 6573,4716,3422     ;ST 2 - "FM PAR ODD" TRUE
        WD36 4716,3451,2273     ;ST 3 - "FM PAR ODD" FALSE
        WD36 3451,2165,7316     ;ST 4 - "FM PAR ODD" TRUE
        WD36 2265,7347,1651     ;ST 5 - "FM PAR ODD" TRUE
        WD36 7347, 1534, 5165   ;ST 6 - "FM PAR ODD" TRUE
        WD36 1634, 5222, 6547   ;ST 7 - "FM PAR ODD" FALSE
        WD36 5122, 6673, 4734   ;ST 10 - "FM PAR ODD" FALSE

.REM    %
;LIST OF MCOMP NUMBER OF CHANGES
        .BYTE   5               ;ST 1
        .BYTE   6               ;ST 2
        .BYTE   5               ;ST 3
        .BYTE   4               ;ST 4
        .BYTE   4               ;ST 5
        .BYTE   4               ;ST 6
%

NJER07: .BYTE   4               ;ST 1
        .BYTE   3               ;ST 2
        .BYTE   4               ;ST 3
        .BYTE   3               ;ST 4
        .BYTE   3               ;ST 5
        .BYTE   3               ;ST 6
        .BYTE   2               ;ST 7
        .BYTE   2               ;ST 10


;SEQ403

NJER08: .BYTE   0               
        .BYTE   1               ;SUBTEST 1 - "WR EVEN PAR DATA"
        .BYTE   1
        .BYTE   0               ;FM PAR CHECK
        .BYTE   3
        .BYTE   40              ;"CLK FM PAR ERR"
        .BYTE   5
        .BYTE   0               ;"CLK ERROR"

        .BYTE   3
        .BYTE   20              ;SUBTEST 2 - "SH AR PAR ODD"
        .BYTE   4
        .BYTE   1               ;"FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"

        .BYTE   0
        .BYTE   1               ;SUBTEST 3 - "WR EVEN PAR DATA"
        .BYTE   1
        .BYTE   0               ;"FM PAR CHECK"
        .BYTE   3
        .BYTE   40              ;"CLK FM PAR ERR"
        .BYTE   5
        .BYTE   0               ;"CLK ERROR"

        .BYTE   4
        .BYTE   3               ;SUBTEST 4 - "APR FM 36", "FM ODD PARITY"
        .BYTE   3
        .BYTE   20              ;"SH AR PAR ODD"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"

;SEQ404

        .BYTE   3
        .BYTE   20              ;SUBTEST 5 - "SH AR PAR ODD"
        .BYTE   4
        .BYTE   1               ;"FM ODD PARITY"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"

        .BYTE   4
        .BYTE   3               ;SUBTEST 6 -0 "APR FM 36", "FM ODD PARITY"
        .BYTE   3
        .BYTE   20              ;"SH AR PAR ODD"
        .BYTE   7
        .BYTE   202             ;"CON AR 36"

        .BYTE   4
        .BYTE   2               ;SUBTEST 7 - "APR FM 36"
        .BYTE   0
        .BYTE   1               ;"WR EVEN PAR DATA"

        .BYTE   4
        .BYTE   2               ;SUBTEST 10 - "APR FM 36"
        .BYTE   0
        .BYTE   1               ;"WR EVEN PAR DATA"


;SEQ405

.SBTTL TEST 38 (ECRA06):  MICRO-CODE SKIP CONDITIONS (COND 4057) AND DISPATCHES

.REM    %
THIS TEST CHECKS THE CONTRROL RAM ADDRESS BOARD "SKIP" CONDITIONS, COND
FUNCTIONS 40-57, AND ALSO PICKS UP SEVERAL MICRO-CODE DISPATCHES, THE
INDIVIDUAL INPUTS TO THE MULTIPLEXERS WHICH DO THE ACTUAL MICRO
CODE DISPATCHING.  EACH SUBTEST HAS ITS OWN MICRO-CODE WHICH SETS UP
THE DESIRED SKIP CONDITION OR DISPATCH CONDITION AND ENDS
WITH THE SKIP OR DISPATCH BEING MUOTIPLEXED ONTO THE C-RAM
ADDRESS LINE.  THE ACTUAL SKIP OR DISPATCH IS TAKEN,
AND THE C-RAM BITS WHICH SET UP THE SKIP OR DISPATCH ARE LEFT
BEHIND IN THE CONTROL RAM WHILE THE PDP11 EXAMINES THE C-RAM
LOC REGISTER TO BE SURE THE CORRECT DISPATCH OR SKIP WAS
TAKEN.
%
ECRA06: CLRB    EXIND           ;SET INITIAL EXPECTED DATA
        MOVB    #10,EXIND+1     ;FOR CR ADR 00-10
        MOV     #IND07,R2       ;PNTR TO NUMBER OF CHANGES LIST
        MOV     #IND08,R3       ;PNTR TO ACTUAL CHANGES LIST
        MOV     #IND06,R4       ;PNTR TO EXECUTE LIST, C-RAM ADDR, EBUS DATA, CLOCK TICS

IND01:  INSYNC                  ;COUNT SUBTESTS
        MOV     #M6.0CRA,R0
        WWADR
        ECLOK                           ;FIRST WORD TO C.R.
        MOV     (R4)+,R0        ;GET C-RAM START ADDRESS
        WWADR                   ;SET IT TO DIAG ADDR REG

        M.RESPSIM                       ;BE SURE TO SIMULATE MBOX
        DFXCTT                  ;FUNCTION
        CONBUT                  ;"CONTINUE" IN EBOX
        DFXCTT                  ;FUNCTION TO SET
        SETRUN          ;"RUN" IN THE EBOX

        MOVB    (R4)+,R0        ;GET INDEX TO EBUS TEST DATA
        BMI     IND02           ;IF INDEX-=-1, NO EBUS TEST DATA

        MOV     EBDATA(R0),R0   ;GET ADDRESS OF EBUS TEST DATA
        ARLOD2                  ;AND LOAD INTO AR
IND02:  MOVB    (R4)+,R0        ;GET NUMBER OF CLOCK TICS TO EXECUTE RAM CODE
        BEQ     IND03           ;IF = 0, DO NO CLOCK TICS
        BURST                   ;OTHERWISE, EXECUTE DESIRED NUMBER OF TICS


;SEQ406

IND03:  JSR     PC,IND99        ;NOW, MODIFY EXPECTED, COMPARE & RESTORE

        CMP     #^D81,R5        ;SUBTEST 81??
        BNE     1$              ;BR IF OT
        INC     R2              ;ON ST 81, UPDATE MCOMP PNTRS

1$:     CMP     #^D85,R5        ;SUBTEST 85??
        BNE     2$              ;BR IF NOT
        DEC     R2              ;IF YES, REPAIR MCOMP PNTRS

2$:     CMP     #^D93,R5        ;DONE, READY FOR 2 SPECIAL CASES?
        BGT     IND01           ;BACK IF NO

;ON TO 2 SPECIAL CASES - SUBTEST 94 & 95
        
IND04:  INSYNC          ;COUNT SUBTEST
        MOV     (R4)+,R0        ;C-RAM START ADDRESS
        WWADR                   ;SET IT IN DIAG ADR REG
        DFXCTT                  ;FUNCTION EXECUTE
        CONBUT                  ;SET "CONTINUE"

        CMP     #^D94,R5        ;NEED ANOTHER FUNCTION??      
        BGE     1$              ;BR IF NO
        DFXCTT                  ;FUNCTION EXECUTE
        SETRUN                  ;SET "RUN"

1$:     MOV     (R4)+,R0        ;NUMBER OF CLOCK TICS
        BURST                   ;EXECUTE THIS TEST

        JSR     PC,IND99                ;AND VERIFY RESULTS
        CMP     #^D95,R5        ;ALL -ALL DONE??
        BGT     IND04           ;BACK IF NO
        JMP     NORMAL          ;ALL DONE
IND05:  DRMDISPATCH     0,7,1777

        .EVEN


;SEQ407

;ROUTINE TO EXECUTE THE MCOMP, DCOMP & RCOMP
IND99:  MOV     #EXIND,DCOMPX   ;SET UP DCOMP TO MCOMP THE RIGHT PLACE
        $MCOMP
        JSR     R5,$DCOMP
        .WORD   MSKIND          ;MASK LIST
        .WORD   DFIND           ;DIAG FCN LIST
        .WORD   BYTIND          ;BYTPNTRS
        .WORD   EXIND           ;EXPECTED
        .WORD   0               ;NO ERR MSG

        $RCOMP
        DEC     R2              ;MCOMP # CHANGES ALWAYS = 1
        RTS     PC              ;ALL COMPARES OK

MSKIND: .BYTE   300,340         ;ONLY LOOK AT "05-10", & "00-04"
DFIND:  .BYTE   146,147!BIT7    ;READ "CRA LOC 5-10" & "00-04"
BYTIND: BYTPNT  5
        BYTPNT  5
EXIND:  .BYTE   0,10            ;EXPECTED FILLED IN BY MCOMP




;SEQ408

;TABLE OF C-RAM START ADDRESS FOR EACH TEST, PNTR TO REQUIRED
;EBUS DATA & NUMBER OF CLOCK TICS
IND06:  
        CRA6DISP        M6.1CRA,EDATAC,6        ;SUBTEST 1
        CRA6DISP        M6.2CRA,NOEDAT,10       ;ST 2
        CRA6DISP        M6.3CRA,EDATAA,4        ;ST 3
        CRA6DISP        M6.4CRA,EDATAA,4        ;ST 4
        CRA6DISP        M6.5CRA,EDATAA,6        ;ST 5
        CRA6DISP        M6.6CRA,EDATAA,4        ;ST 6
        CRA6DISP        M6.7CRA,EDATAA,6        ;ST 7
        CRA6DISP        M6.8CRA,EDATAA,8        ;ST 8
        CRA6DISP        M6.9CRA,EDATAA,6        ;ST 9
        CRA6DISP        M6.10CRA,EDATAA,8       ;ST 10
        CRA6DISP        M6.11CRA,EDATAA,6      ;ST 11
        CRA6DISP        M6.12CRA,EDATAA,8       ;ST 12


;SEQ409
        CRA6DISP        M6.13CRA,EDATAA,6       ;ST 13
        CRA6DISP        M6.14CRA,EDATAA,8       ;ST 14
        CRA6DISP        M6.15CRA,EDATAA,6       ;ST 15
        CRA6DISP        M6.16CRA,EDATAA,8       ;ST 16
        CRA6DISP        M6.17CRA,EDATAA,4       ;ST 17
        CRA6DISP        M6.18CRA,EDATAA,6       ;T 18
        CRA6DISP        M6.19CRA,NOEDAT,8       ;ST 19
        CRA6DISP        M6.20CRA,EDATAC,6       ;ST 20
        CRA6DISP        M6.21CRA,EDATAB,4       ;ST 21
        CRA6DISP        M6.22CRA,EDATAB,6       ;ST 22
        CRA6DISP        M6.23CRA,EDATAD,4       ;ST 23
        CRA6DISP        M6.24CRA,EDATAD,6       ;ST 24
        CRA6DISP        M6.25CRA,EDATAE,6       ;ST 25


;SEQ410

        CRA6DISP        M6.26CRA,EDATAE,8       ;ST 26
        CRA6DISP        M6.27CRA,EDATAC,6       ;ST 27
        CRA6DISP        M6.28CRA,EDATAI,8       ;ST 28
        CRA6DISP        M6.29CRA,NOEDAT,6       ;ST 29
        CRA6DISP        M6.30CRA,EDATAF,8       ;ST 30
        CRA6DISP        M6.31CRA,EDATAF,8       ;ST 31
        CRA6DISP        M6.32CRA,EDATAC,6       ;ST 32
        CRA6DISP        M6.33CRA,EDATAC,8       ;ST 33
        CRA6DISP        M6.34CRA,EDATAB,6       ;ST 34
        CRA6DISP        M6.35CRA,EDATAB,8       ;ST 35
        CRA6DISP        M6.36CRA,EDATAB,8       ;ST 36
        CRA6DISP        M6.37CRA,NOEDAT,6       ;ST 37
        CRA6DISP        M6.38CRA,EDATAB,8       ;ST 38


;SEQ411
        CRA6DISP        M6.39CRA,NOEDAT,6       ;ST 39
        CRA6DISP        M6.40CRA,EDATAB,6       ;ST 40
        CRA6DISP        M6.41CRA,EDATAB,8       ;ST 41
        CRA6DISP        M6.42CRA,EDATAB,6       ;ST 42
        CRA6DISP        M6.43CRA,EDATAB,8       ;ST 43
        CRA6DISP        M6.44CRA,EDATAC,12      ;ST 44
        CRA6DISP        M6.45CRA,EDATAC,12      ;ST 45
        CRA6DISP        M6.46CRA,EDATAB,6       ;ST 46
        CRA6DISP        M6.47CRA,EDATAB,8       ;ST 47
        CRA6DISP        M6.48CRA,NOEDAT,8       ;ST 48
        CRA6DISP        M6.49CRA,NOEDAT,12      ;ST 49
        CRA6DISP        M6.50CRA,NOEDAT,10      ;ST 50
        CRA6DISP        M6.51CRA,NOEDAT,12      ;ST 51


;SEQ412

        CRA6DISP        M6.52CRA,EDATAF,6       ;ST 52
        CRA6DISP        M6.53CRA,EDATAF,6       ;ST 53
        CRA6DISP        M6.54CRA,EDATAB,8       ;ST 54
        CRA6DISP        M6.55CRA,NOEDAT,12      ;ST 55
        CRA6DISP        M6.56CRA,EDATAA,8       ;ST 56
        CRA6DISP        M6.57CRA,EDATAA,8       ;ST 57
        CRA6DISP        M6.58CRA,EDATAH,32      ;ST 58
        CRA6DISP        M6.59CRA,EDATAH,36      ;ST 59
        CRA6DISP        M6.60CRA,EDATAE,6       ;ST 60
        CRA6DISP        M6.61CRA,EDATAG,8       ;ST 61
        CRA6DISP        M6.62CRA,EDATAG,8       ;ST 62
        CRA6DISP        M6.63CRA,EDATAG,8       ;ST 63
        CRA6DISP        M6.64CRA,EDATAG,8       ;ST 64


;SEQ413
        CRA6DISP        M6.65CRA,EDATAG,10      ;ST 65
        CRA6DISP        M6.66CRA,EDATAG,8       ;ST 66
        CRA6DISP        M6.67CRA,EDATAG,10      ;ST 67
        CRA6DISP        M6.68CRA,NOEDAT,8       ;ST 68
        CRA6DISP        M6.69CRA,EDATAG,6       ;ST 69
        CRA6DISP        M6.70CRA,EDATAG,12      ;ST 70
        CRA6DISP        M6.71CRA,NOEDAT,6       ;ST 71
        CRA6DISP        M6.72CRA,NOEDAT,8       ;ST 72
        CRA6DISP        M6.73CRA,EDATAG,12      ;ST 73
        CRA6DISP        M6.74CRA,NOEDAT,8       ;ST 74
        CRA6DISP        M6.75CRA,NOEDAT,8       ;ST 75
        CRA6DISP        M6.76CRA,EDATAE,12      ;ST 76
        CRA6DISP        M6.77CRA,NOEDAT,8       ;ST 77


;SEQ414

        CRA6DISP        M6.78CRA,EDATAH,6       ;ST 78
        CRA6DISP        M6.79CRA,EDATAJ,10      ;ST 79
        CRA6DISP        M6.80CRA,EDATAC,12      ;ST 80
        CRA6DISP        M6.81CRA,EDATAC,14      ;ST 81
        CRA6DISP        M6.82CRA,EDATAC,12      ;ST 82
        CRA6DISP        M6.83CRA,EDATAC,14      ;ST 83
        CRA6DISP        M6.84CRA,EDATAC,12      ;ST 84
        CRA6DISP        M6.85CRA,EDATAC,14      ;ST 85
        CRA6DISP        M6.86CRA,NOEDAT,12      ;ST 86
        CRA6DISP        M6.87CRA,NOEDAT,6       ;ST 87
        CRA6DISP        M6.88CRA,NOEDAT,6       ;ST 88
        CRA6DISP        M6.89CRA,NOEDAT,6       ;ST 89
        CRA6DISP        M6.90CRA,NOEDAT,6       ;ST 90
        CRA6DISP        M6.91CRA,NOEDAT,6       ;ST 91


;SEQ415

        CRA6DISP        M6.92CRA,NOEDAT,6       ;ST 92
        CRA6DISP        M6.93CRA,NOEDAT,6       ;ST 93
        .WORD   M6.94CRA,^D8                    ;ST 94
        .WORD   M6.95CRA,^D8                    ;ST 95


;SEQ416

;POINTERS TO EBUS DATA PATTERNS
EBDATA: .WORD   EBD.A           ;DATA WORD "A"
        .WORD   EBD.B           ;DATA WORD "B"
        .WORD   EBD.C           ;DATA WORD "C"
        .WORD   EBD.D           ;DATA WORD "D"
        .WORD   EBD.E           ;DATA WORD "E"
        .WORD   EBD.F           ;DATA WORD "F"
        .WORD   EBD.G           ;DATA WORD "G"
        .WORD   EBD.H           ;DATA WORD "H"
        .WORD   EBD.I           ;DATA WORD "I:
        .WORD   EBD.J           ;DATA WORD "J"

        
EBD.A:  WD36 4000,0000,0000     ;DATA BIT00
EBD.B:  WD36 0000,0040,0000     ;DATA BIT18M
EBD.C:  WD36 7600,3700,0000     ;ARX BITS & SH00-SH03 BITS
EBD.D:  WD36 0000,4000,0000     ;BIT12
EBD.E:  WD36 0004,2000,0000     ;BIT13,BIT9
EBD.F:  WD36 0007,4000,0000     ;BITS 9,10,11,12 FOR IR AC
EBD.G:  WD36 0120,0000,0000     ;BITS 5 & 7
EBD.H:  WD36 0004,0002,0000     ;BITS 9 & 22
EBD.I:  WD36 2000,0100,0000     ;BIT 1
EBD.J:  WD36 4000,3700,0000     ;BIT 0 PLUS SECTION 37

IND07:  .BYTE   1               ;MCOMP NUMBER OF CHANGES
        .BYTE   2               ;NUMBER OF CHANGES ST 82-85


;SEQ417

;MCOMP ACTUAL CHANGES ALWAYS CRA ADR BITS 7-10, JUST USE
;DIFFERENT INPUT PINS
IND08:  .BYTE   0
        .BYTE   17              ;SUBTEST 1 - "SH00-SH03" - DISP 07

        .BYTE   0
        .BYTE   0               ;ST 2 - "SH00-SH03" .EQ. 0 - DISP07

        .BYTE   0
        .BYTE   1               ;ST 3 - "AR00" - COND 45

        .BYTE   0
        .BYTE   0               ;ST 4 - "AD00" - COND 55

        .BYTE   0
        .BYTE   0               ;ST 5 - "AR00" - COND 45

        .BYTE   0
        .BYTE   1               ;ST 6 - "AD00" - COND 55

        .BYTE   0
        .BYTE   2               ;ST 7 - "BR00" - DISP 31

        .BYTE   0
        .BYTE   0               ;ST 8 - "BR00" .EQ. 0 - DISP 31

        .BYTE   0
        .BYTE   2               ;ST 9 - "BR00" - DISP 32

        .BYTE   0
        .BYTE   0               ;ST 10 - "BR00" .EQ. 0 - DISP 32


        .BYTE   0
        .BYTE   1               ;ST 11 - "BR00" - COND 42

        .BYTE   0
        .BYTE   0               ;ST  12 - "BR00" .EQ. 0 - COND42

        .BYTE   0
        .BYTE   1               ;ST 13 - "ARX00" - COND 43

        .BYTE   0
        .BYTE   0               ;ST 14 - "ARX00" .EQ. 0 - COND 43


        .BYTE   0
        .BYTE   1               ;ST 15 - "ADX00" - COND 53

        .BYTE   0
        .BYTE   0               ;ST 16 - "ADX00" .EQ. 0 - COND 53


;SEQ418

        .BYTE   0
        .BYTE   1               ;ST 17 - 'SH AR PAR ODD" - COND 14

        .BYTE  0
        .BYTE   0               ;ST 18 - "SH AR PAR ODD" .EQ. 0 - COND 41
        .BYTE   0
        .BYTE   17              ;ST 19 - "SR00-SR03" - DISP 05

        .BYTE   0
        .BYTE   0               ;ST 20 -"SR00-SR03" .EQ. 0 - DISP 05

        .BYTE   0
        .BYTE   1               ;ST 21 - "AR18" - COND 44

        .BYTE   0
        .BYTE   0               ;ST 22 - "AR18" .EQ. 0 - COND 44

        .BYTE   0
        .BYTE   2               ;ST 23 - "AR12" - DISP 34

        .BYTE   0
        .BYTE   0               ;ST 24 - "AR12" .EQ. 0 - DISP 34

        .BYTE   0
        .BYTE   16              ;ST 25 - "ARX 13" & "-CON LONG EN"

        .BYTE   0
        .BYTE   14              ;ST 26 - "ARX13" .EQ. 0 - DISP 36

        .BYTE   0
        .BYTE   17              ;ST 27 - "SH INDEXED" & "ARX 13" - DISP 36

        .BYTE   0
        .BYTE   0       ;ST 28 - "SH INDEXED" & "ARX13" BOTH FALSE - DISP 36

        .BYTE   0
        .BYTE   0               ;ST 29 - "-AD=0" FALSE - COND 56

        .BYTE   0
        .BYTE   0               ;ST 30 - "MCL EA TYPE 07,08,09,10" - DISP 37

        .BYTE   0
        .BYTE   0               ;ST 31 - "MCL EA TYPE 09,10" .EQ. 0 - DISP 37


;SEQ419

        .BYTE   0
        .BYTE   4               ;ST 32 - "SCD FPD" - DISP 34
        .BYTE   0
        .BYTE   0               ;ST 33 - "SCD FPD" .EQ. 0 - DISP 34

        .BYTE   0
        .BYTE   1               ;ST 34 - "SC SIGN" - COND 47
        
        .BYTE   0
        .BYTE   0               ;ST 35 - "SC SIGN" .EQ. 0 - COND 47

        .BYTE   0
        .BYTE   7               ;ST 36 - "FE SIGN" - DISP 30

        .BYTE   0
        .BYTE   3               ;ST 37 - "FE SIGN" .EQ. 0 - DISP 30MQ34,35=1

        .BYTE   0
        .BYTE   4               ;ST 38 - "FE SIGN" - DISP 31

        .BYTE   0
        .BYTE   0               ;ST 39 - "FE SIGN" .EQ. 0 - DISP 31

        .BYTE   0
        .BYTE   1               ;ST 40 - "SCAD SIGN" - COND 51

        .BYTE   0
        .BYTE   0               ;ST 41 - "SCAD SIGN" /EQ/ 0 - DISP 34
        .BYTE   0
        .BYTE   1               ;ST 42 - "SCAD SIGN" - DISP 34

        .BYTE   0
        .BYTE   0               ;ST 43 - "SCAD SIGN" .EQ. 0 DISP 34

        .BYTE   0
        .BYTE   1               ;ST 44 - "PC SECTION 0 TRUE" - COND 50

        .BYTE   0
        .BYTE   0               ;ST 45 - "PC SECTION 0" FALSE - COND 50

        .BYTE   0
        .BYTE   1               ;ST 46 - "-SCAD=0" - COND 52
        .BYTE   0
        .BYTE   0               ;ST 47 - "-SCAD=0" FALSE - COND 52


;SEQ420

        .BYTE   0
        .BYTE   1               ;ST 48 - "AD CRY -02" - DISP 31
        .BYTE   0
        .BYTE   0               ;ST 49 - "AD CRY -02" .EQ. - DISP 31

        .BYTE   0
        .BYTE   1               ;ST 50 - "AD CRY -02" - COND 54

        .BYTE   0
        .BYTE   0               ;ST 51 - "AD CRY -02" - COND 54

        .BYTE   0
        .BYTE   1               ;ST 52 - "IR AC=0" - COND 46

        .BYTE   0
        .BYTE   0               ;ST 53 - "IR AC=0" FALSE - COND 46
        .BYTE   0
        .BYTE   7               ;ST 54 - "NORM 8,9,10" - DISP 35


        .BYTE   0
        .BYTE   0               ;ST 55 - "NORM 8,9,10" FALSE - DISP 35

        .BYTE   0

        .BYTE   15              ;ST 56 - "AR","ARX" & "AD" SIGNS - DISP 32

        .BYTE   0
        .BYTE   2               ;ST 57 - "AR" & "AD" SIGNS = 0 - DISP 32

        .BYTE   0
        .BYTE   17              ;ST 58 - "NICOND" - DISP 06

        .BYTE   0
        .BYTE   0               ;ST 59 - "NICOND" FALSE - DISP 06

        .BYTE   0
        .BYTE   1               ;ST 60 - <"MCL VMA FETCH" - COND 60

        .BYTE   0
        .BYTE   0               ;ST 61 - "MCL VMA FETCH" FALSE - COND 60



;SEQ421

        .BYTE   0
        .BYTE   1               ;ST 62 - "CON KERNEL MODE" - COND 61

        .BYTE   0
        .BYTE   0               ;ST 63 - 'CON KERNEL MO9DE" FALSE - COIND 61

        .BYTE   0
        .BYTE   1               ;ST 64 - "SCD USER" - COND 62

        .BYTE   0
        .BYTE   0               ;ST 65 - "SCD USER" FALSE - COND 62

        .BYTE   0
        .BYTE   1               ;ST 66 - "SCD PUBLIC" -COND 63

        .BYTE   0
        .BYTE   0               ;ST 67 - "SCD PUBLIC" FALSE - COND 67

        .BYTE   0
        .BYTE   1               ;ST 68 - "CON PI CYCLE" - COND 65

        .BYTE   0
        .BYTE   0               ;ST 69 - "CON PI CYCLE" FALSE - COND 65

        .BYTE   0
        .BYTE   0               ;ST 70- - "-CON EBUS GRANT" - COND 66

        .BYTE   0
        .BYTE   1               ;ST 71 - "-CON EBUS GRANT" FALSE - COND 66

        .BYTE   0       
        .BYTE   1               ;ST 72 - "CON IO LEGAL" - COND 75

        .BYTE   0
        .BYTE   0               ;ST 73 - "CON IO LEGAL" FALSE - COND 73

        .BYTE   0
        .BYTE   1               ;ST 74 - "CON PXCT OR SXCT" - COPND 74

        .BYTE   0
        .BYTE   0               ;ST 75 - "CON PXCT OR SXCT" FALSE - COND 74

        .BYTE   0
        .BYTE   1               ;ST 76 - "VMA AC REF" - COND 76

        .BYTE   0
        .BYTE   0               ;ST 77 - "VMA AC REF" FALSE - COPND 76

        .BYTE   0
        .BYTE   1               ;ST 78 - "-LOCAL AC ADDR" FALSE - SKIP 57

        .BYTE   0
        .BYTE   0               ;ST 79 - "LOCAL AC ADDR" TRUE - SKIP 57

        .BYTE   0
        .BYTE   7               ;ST 80 - "DRAM B 0,1,2" - DISP 33


;SEQ422

        .BYTE   0
        .BYTE   0               ;ST 81 - "DRAM B 0,1,2" .EQ. 0 -D ISP 33


;SEQ423

        .BYTE   0
        .BYTE   17              ;ST 82 - "DRAM J" - DISP 01

        .BYTE   1
        .BYTE   17              ;"DRAM J"

        .BYTE   0
        .BYTE   0               ;ST 83 - "DRAM J" .EQ. 0 - DISP 01
        .BYTE   1
        .BYTE   10              ;"DRAM J" - = 0, CR ADR = 1000

        .BYTE   0
        .BYTE   17              ;ST 84 - "AREAD" - DISP 02
        .BYTE   1
        .BYTE   17              ;"AREAD"

        .BYTE   0
        .BYTE   0               ;ST 85 - "AREAD" - DISP 02
        .BYTE   1
        .BYTE   10              ;WITH "AREAD" .EQ. 0, CR ADDR = 1000

        .BYTE   0
        .BYTE   4               ;ST 86 - "MUL DONE" - DISP 30 - F

        .BYTE   0
        .BYTE   3               ;ST 87 - "MUL DONE" & "-FE SIGN" - DISP 30 - T

        .BYTE   0
        .BYTE   0               ;ST 88 - "MUL DONE" - DISP 34 - F

        .BYTE   0
        .BYTE   0               ;ST 89 - "MUL DONE" - DISP 32 - F
        .BYTE   0
        .BYTE   0               ;ST 90 - "MUL DONE" - DISP 31 - F

        .BYTE   0
        .BYTE   0               ;ST 91 - "MUL DONE" - DISP 10 - F

        .BYTE   0
        .BYTE   1               ;ST 92 - "-CON START" FALSE - COND 71

        .BYTE   0
        .BYTE   0               ;ST 93 - "CON RUN" FALSE - COND 72

        .BYTE   0
        .BYTE   0               ;ST 94 - "-CON START" - COND 71

        .BYTE   0
        .BYTE   1               ;ST 95 - "CON RUN" - COND 72

.EVEN


;SEQ424

.SBTTL TEST 39 (PIDTE): PI BOARD TO DTE20 INTERFACE TEST

.REM    %
        THIS TEST CHECKS THE BASIC LINES THAT CONNECT THE DTE20 TO
THE EBUS AND TO THE EBOX PI SYSTEM.  IT CHEKS THAT PI INTERRUPT LEVELS
CAN BE ASSIGNED TO THE DTE AND THAT THE DTE CAN ISSUE AN INTERRUPT TO
THE PI BOARD AT THE ASSIGNED LEVEL.  IT CHECKS THAT A "CONI DTE" READS
WHAT IT SHOULD, THAT A "CONO DTE" SETS WHAT IT SHOULD AND THAT THE BITS
A "CONO DTE" SETS, SHOW UP IN THE DTE20'S STATUS REGISTER.  IT CHECKS THAT
:KL10 HALT LOOP", "KL10 RUN FLOP", AND "EBOX CLK ERR STOP" ARE ALL
READABLE IN THE DTE20 REGISTER "DIAG1".  IT ALSO CHECKS THAT WHEN THE
DTE20 ISSUES AN INTERRUPT, THE CORRECT API FUNCTION TYPE IS SENT TO THE
EBOX.  I.E. CORRECT IOP FUNCTION TYPE IS SENT ON EBUS BITS 3-5,
CORRECT ADDRESS SPACE SPECIFICATION IS SENT ON EBUS BITS 0-2,
CORRECT QUALIFIER IS SENT ON BIT6 AND FINALLY THAT THE CORRECT
PHYSICAL NUMBER IS DECODED AND PUT ONTO EBUS BITS 7-10.  IT ALSO
CHECKS THE DTE20 DECODING OF THE CS LINES CS00-CS06 AND ENSURES THAT
THE PRIVILEGED DTE RESPONDS ONLY TO ITS OWN DEVICE CODE
%

PIDTE:  $CLRWD  CONODT          ;EMPTY ALL 36-BIT BUFFERS
        $CLRWD  CONIDT
        $CLRWD  CONOX
        DTEBAS                  ;GET BASE ADDRESS OF MASTER DTE
        SHIFTR                  ;SHIFT BASE ADDRESS
        DTESZS            ;RIGHT THIS MANY PLACES

        BIC     #177774,R0      ;CLEAR TRASH & YOUVE GOT DTE NUMBER
        MOV     R0,DTENUM       ;SAVE DTE NUMBER IN CORE
        ASL     R0              ;MAKE DTE # EVEN
        MOV     DTELST(R0),R3   ;GET ADDRESS OF DATA LIST FOR THIS DTE
        ASR     R0              ;MAKE R0 THE ACTUAL DTE # AGAIN
        PUSH    #10             ;INITIAL GUESS IS PHY # = 8

1$:     TST     R0              ;CHECK DTE #
        BEQ     2$              ;IF .EQ. 0, THEN PHY NUMBER ON STACK OK

        INC     (SP)            ;IF .NE. THEN PHY NUMBER ON STACK OK

        DEC     R0              ;DOWN .NE. 0..TRY NEXT PHY NUMBER
        BR      1$              ;AND CONTINUE
2$:     MOV     (SP)+,DTEPHY    ;AND SAVE THAT IN CORE


;SEQ425

;BEGIN SETTING UP FOR INITIAL TEST..
;       SUBTESTS 1-9
;THE FIRST TEST SEGMENT CONSISTS OF DOING "CONOS' TO THE DTE20,
;THEREBY SETTING PIA LEVELS IN THE DTE.  NEXT WE EXECUTE "CONI DTE'S" TO
;READ AND VERIFY THAT THE ATTEMPTED PIA LEVEL WAS ACTUALLY SET IN THE
;DTE20 AND THAT THE DTE20 SENDS THAT INFORMATION OUT ON A CONI REQUEST
;FROM THE PROCESSOR.
        $MOVWD  VERM90,CONIOM   ;SET UP INITIAL PROG.MASK
        MOVB    (R3)+,CONODT+3  ;SET DEVICE CODE INTO CONO INSTRUCTION
        MOVB    (R3)+,CONODT+4  ;SET ADDITIONAL DEVICE CODE BIT
        BISB    #16,CONODT+4    ;SET OPCODE TO 7XX INSTRUCTION

        MOVB    CONODT+3,CONIDT+3       ;CONI NEEDS SAME AS CONO
        MOVB    CONODT+4,CONIDT+4       ;EVEN SAME OPCODE

        $MOVWD  CONIDT,CONOX    ;NOW SET LEFT HALF OF EXPECTED DATA

        BICB    #377,CONOX+4    ;CLEAR IRRELEVANT PARTS OF
        BICB    #377,CONOX+3    ;OF THE 36-BIT BUFFER
        BICB    #374,CONOX+2    ;(I.E. CLEAR 0-17)
        MOV     #VERM06,R4      ;GET ADDRESS OF TEST/EXPECTED DATA LIST

        EBOXON                  ;START EBOX MICROCODE FREE RUNNING


;SEQ426

;AND BEGIN
VERM01: INSYNC                  ;COUNT SUBTEST

        MOVB    (R4)+,CONODT    ;SET PIA BITS INTO CONO WORD
        MOVB    (R4)+,CONOX     ;AND SET INTO EXPECTED DATA
        BICB    #200,CONOX      ;CLEAR SIGN BIT IN CASE IT WAS SET IN DATA

        CONO.DTE        CONODT  ;CONO DTE SETS THE PIA BITS


;SEQ427

        CONI.DTE        CONIDT          ;READ DTE'S STATUS INTO AR

        JSR     PC,IOFUNC                       ;READ AND CHECK RESULTS OF THE CONI
        BCC     1$                      ;BR IF DATA COMPARE OK

        JSR     PC,FAULT                        ;ELSE REPORT ERROR
        .WORD   0

1$:     TSTB    -1(R4)          ;ALL DONE??
        BPL     VERM01                  ;BR BACK IF NO


;SEQ428

;DONE FIRST SECTION OF TEST.. NOW ON TO TEST DTE'S ABILITY TO
;UNIQUELY DECODE THE CS LINES CS00-CS06
;       SUBTESTS 10-16
;IN THIS TEST A CONO DTE IS DONE TO SET THE DTE'S PIA LEVEL TO 7.
;NEXT, AN ALTERNATING SERIES OF CONO'S (WITH TEST PATTERN DEVICE CODES)
;IS EXECUTED, FOLLOWED BY CONI' TO THE DTE UNDER TEST, IN ORDER
;TO VERIFY THAT THE CONO  WITH BAD DEVICE CODE DOES NOT EFFECT THE
;DTE UNDER TEST END THAT THE PIA 7 SET UP IS STILL IN THE DTE
        MOVB    #37,CONODT              ;DATA FOR THE FIRST CONO TO SET PIAS 7
        CONO.DTE        CONODT          ;SET DTE PIA LEVEL = 7

        MOVB    #20,CONODT      ;FROM NOW ON, CONOS TRY TO SET PIA=0
        MOVB    #17,CONOX                       ;BUT WE ALWAYS EXPECT TO GET PIA=7


;SEQ429

VERM02: INSYNC                  ;COUNT SUBTEST
        MOVB    (R3)+,CONODT+3  ;SET DEVICE CODE TEST PATTERN
        MOVB    (R3)+,CONODT+4

        CONO.DTE        CONODT          ;CONO WITH TEST DEVICE CODE




;SEQ430

        CONI.DTE        CONIDT          ;CONI TO READ WHAT IN THE DTE

        JSR     PC,IOFUNC               ;READ AND CHECK RESULTS OF THE CONI
        BCC     1$              ;BR IF NO ERROR

        JSR     PC,FAULT                        ;ELSE-REPORT ERROR
        .WORD   0
1$:     TST     (R3)                    ;ALL DONE??

        BPL     VERM02          ;BR BACK IF MORE TO DO


;SEQ431

;THE NEXT PHASE OF THE TEST CHECK THAT THE DTE20 CAN INTERRUPT
;THE KL10 ON THE SEELECTED PI LEVEL AND ONLY ON THAT L;EVEL
;       SUBTESTS 17-;;
        MOV     #27,R2          ;GET INITIAAL DTE PIA LEVEL
        $CLRWD  CONOPI          ;CLEAR 36-BIT BUFFER
        $CLRWD  CONOX           ;CLEAR OUT EXPECTED BUFFER
        $MOVWD  ZERO,CONIOM     ;AND CHANGE MASK FOR TESTING RESULTS

        MOVB    (R3),CONODT+3   ;GET DTE20 DEVICE CODE
        MOVB    1(R3),CONODT+4  ;INTO ALL BIT POSITIONS
        BISB    #16,CONODT+4    ;SET OPCODE TO 7XX
VERM03: EBOXON                  ;START THE EBOX RUNNING

        INSYNC                          ;COUNT SUBTESTS
        MOV     #377*4,R0       ;GET CODE THAT TURNS ALL PI LEVELS ON
        MOVB    R0,CONOPI+2     ;SET IT INTO 36-BIT BUFFER
        SWAB    R0              ;GET THE RESET OF THE CODE
        MOVB    R0,CONOPI+3     ;AND SET IT FOR OCNO
        BISB    #20,CONOPI+3            ;AND SET CONO BIT FOR "TURN ON SELECTED
                                ;CHANNELS"
        MOVB    #200,CONOX+3            ;SET EXPECTED API FUNCTION CODE
        MOV     DTEPHY,R0       ;GET DTE'S PHYSICAL NUMBER
        ASL     R0              ;JUSTIFY IN EBUS POSITION
        BISB    R0,CONOX+3              ;AND SET INTO EXPECTED
        MOVB    R2,CONODT       ;NOW SET PIA LEVEL FOR DTE TO INTERRUPT ON
        BISB    #2,CONODT+1             ;SET H CLR "11 INTERRUPTING 10"

;SEQ432


CONO.DTE        CONODT          ;SET PIA LEVEL INTO DTE

        CONO.PI CONOPI          ;SET PI LEVELS IN THE PI SYSTEM

;SEQ433

        IDLE                    ;DROP EBOX INTO IDLE LOOP AWAITING INTERRUPT
        MOV     #INT10S,@.STDTE ;TELL 11 TO INTERRUPT THE 10


        JSR     PC,IOFUNC       ;GO READ & CHECK API FUNCTION SENT BY DTE
        BCC     1$              ;CONTINUE IF NO ERROR

        JSR     PC,FAULT        ;ELSE-REPORT ERROR
        .WORD   0

1$:     CLR     PASS2           ;CLR A FLAG TO KEEP TRACK OF 2 PASSES
        BICB    #20,CONOPI+3    ;CLEAR THE "TURN LEVELS ON" BIT IN CONO PI DATA
        BISB    #10,CONOPI+3    ;SET "TURN LEVELS OFF" BIT IN CONO PI DATA

;NOW GO DO CONO PI TO TURN OFF LEVELS WE TURNED ON LAST SUBTEST
        BR      11$             ;BR TO CODE WE WANT TO DO TWICE
10$:    INSYNC                  ;COUNT SUBTEST
        COM     PASS2           ;FLIP PASS2 FLAG TO SAY 1ST TIME DONE
        CLR     R0              ;CLEAR R0 SO WE CAN DO A BIT SET INTO IT
        BISB    (R4)+,R0        ;NEXT "PI ON" GROUP TO R0
        ASL     R0              ;JUSTIFY 11 BYTE DATA TO EBUSD BITS 17
        ASL     R0              ;IT TAKES 2 "ASLS"
        MOVB    R0,CONOPI+2     ;SET BITS IN 36-BIT BUFFER
        SWAB    R0
        MOVB    R0,CONOPI+3     ;SOME MORE OF THE BITS
        BISB    #20,CONOPI+3   ;AND "TURN ON SELECTED CHANNELS"
11$:    CONO.PI CONOPI          ;CHANGE SELECTED INTERRUPT CHANNELS ON

        TST     PASS2           ;NEED TTO GO BACK AGAIN??
        BEQ     10$             ;BR IF YES


;SEQ435

        $CLRWD  CONOX           ;RTHIS TIME EXPECT ALL ZEROES FROM INO INTERRUPT
        IDLE            ;EBOX IDLE TO WAIT FOR INTERRUPT


        MOV     #INT10S,@.STDTE ;TELL 11 TO INTERRUPT THE 10
                                ;SHOULD GET NO INTERRUPT. 10 CHANNEL DISABLED

        JSR     PC,IOFUNC               ;CHECK THAT GOT NO INTERRUPT

        BCC     2$              ;BRIF NO ERROR

        JSR     PC,FAULT                ;ELSE-REPORT ERROR
        .WORD   0

2$:     DEC     R2              ;DOWN COUNT PIA LEVEL UNDER TEST
        BIT     #7,R2           ;DOWN TO ZERO YET??
        BEQ     3$              ;YES.. THEN BRANCH
        JMP     VERM03          ;OTHERWISE, GO BACK & CONT WITH TEST

3$:


;SEQ436

 

;FALL THRU TO NEXT PHASE OF THE TEST.
;THIS PHASE OF THE TEST CHECKS THE API FUNCTIONS SENT TO THE
;EBOX BY THE DTE UNDER VARIOUS INTERRUPT MODES
        MOV     #VERM07,R4      ;GET TEST STIMULUS DATA
        EBOXON                  ;START EBOX FREE RUNING

VERM04: INSYNC                  ;CIOUNT SUBTESTS
        IDLE                    ;PUT EBOX INTO IDLE STATE-AWAITING INTERRUPT
        MOV     (R4)+,R0        ;GET NEXT DATUM
        BEQ     10$             ;IF .EQ. 0 DONT MESS WITH T011BC

        MOV     R0,@.T10AD      ;SET UP THE DTE 20 FOR A BYTE TRANS. INT
        MOV     R0,@.T11AD      ;SET UP THE DTE20 FOR A BYTE TRANS. INT
        MOV     R0,@.BC11       ;THIS MOVE STARTS DTE20 INT. SEQUENCE
9$:     ADD     #100,#0         ;AND DELAY TO LET DTE CYCLE
        BNE     9$
        TST     (R4)+           ;IF DOING TO 11 BC, MUST UPDATE DATA PNTRS
        TST     (R4)+           ;TWO WORDS WORTH
        BR      11$             ;NOW JMP AROUND "TEN AD" LOCS.
10$:    MOV     (R4)+,@.TENA1   ;SET ADDR SPACE & EX/DEP BITS IN DTE
        MOV      (R4)+,@.TENA2  ;EXECUTE PDP11 FUNCTION AND INTERRUPT THE 10
11$:    MOV     R4,100$         ;GET ADDRESS OF EXPETED DATA


;SEQ437

        MOVWRD                  ;TRAP TO MVOE 36 BITS FROM HERE TOTHERE
100$:   .WORD   0               ;SOURCE OF 36-BIT DATA
        .WORD   CONOX           ;PLACE TO MOVE IT TO

        MOV     DTEPHY,R0               ;ALSO SET DTES PHYSICAL # IN EXPECTED
        ASL     R0              ;JUSTIFY PHYSICAL # TO CORRECT EBUS BIT
        BISB    R0,CONOX+3      ;AND NOW SET INTO EXPECTED
        MOV     #DRESET,@.DIAG2 ;DTE WAS LEFT IN MIDDLE OF HANDSHAKE..
                        ;REWSET HIM OUT OF THE HANDSHAKE SEQUENCE
        JSR     PC,IOFUNC       ;GO READ ACTUAL & COMPARE AGAINST EXPECTED

        BCC     1$              ;BR IF NO ERRORS

        JSR     PC,FAULT                ;ELSE-REPORT AN ERROR
        .WORD   0

1$:     ADD     #6,R4   ;UPDATE PNTR TO NEXT TEST DATA
        CMP     #^D36,R5        ;ALL DONE THIS PHASE??
        BGT     VERM04          ;BR BACK IF NO


;SEQ438

;FALL THRU TO FINAL PHASE OF THIS TEST
;THIS PHASE OF THE TEST CHECKS THAT THE PDP11 & KL10 CAN
;INTERRUPT EACH, AND THAT STATUS BITS ARE CORRECTLY SET IN EACH
;OTHERS STATUS WORDS
        $MOVWD  VERM91,CONIOM   ;SET MASK FOR THESE SUBTESTS
;FIRST SET UP CONO & CONI WORDS

        MOV     #VERM08,R4      ;GET PNTR TO EXPECTED DATA
        MOVB    (R3),CONODT+3           ;SET DTRE20 DEVICE CODE
        MOVB    1(R3),CONODT+4  ;IN ALL BIT POSITIONS
        BISB    #16,CONODT+4    ;SET OPCODE 7 FOR IO INSTR.

        $MOVWD  CONODT,CONIDT   ;SAME DATA NEEDED FOR CONI
VERM05: INSYNC                  ;COUNT SUBTESTS
        MOVB    (R4),CONODT     ;SET DEVICE DATA FOR CONO BITS 28-35
        MOVB    1(R4),CONODT+1  ;BITS 20-27
        MOVB    2(R4),CONODT+2  ;BITS 12-19

        CONO.DTE        CONODT  ;EXECUTE CONO

        ADD     #5,R4           ;UPDATE PNTR TO PNT TO EXPECTED

        MOV     5(R4),@.STDTE   ;DATA TO DTE STATUS REG TO TRIGGER DTE ACTION


;SEQ439

;NOW WE'VE JUST HIT THE DTE20 FROM BOTH SIDES.. WITH A CONO DTE FROM THE
;TEN SIDE, AND A MOVE TO ITS STATUS REGISTER FROM THE 11 SIDE.  NOW WE
;WILL CHECK THE RESULTS OF WHAT WE'VE DONE WITH A CONI DTE FROM THE TEN
;SIDE AND A READ FROM THE DTE STATUS REGISTER FROM THE 11 SIDE
        MOV     R4,100$         ;GET ADDRESS OF EXPECTED DATA
        MOVWRD                  ;MVOE EXPECTED FROM LIST TO STANDARD PLACE
100$:   .WORD   0               ;EXPECTED ADDRESS IN THE LIST GOES HERE
        .WORD   CONOX           ;STANDARD CORE LOC FOR EXPECTED DATA

        CONI.DTE        CONIDT  ;READ DTE STATUS FROM THE TEN SIDE
        JSR     PC,IOFUNC       ;& CHECK RESULTS AGAINST EXPECTED
        BCC     1$              ;CONT IF DATA OK (IE. C-BIT CLEAR)

        JSR     PC,FAULT        ;BR TO ERR IF NOT
        .WORD   0


;SEQ440

;NOW CHECK DTE20 STATUS REGISTER
1$:     INSYNC                  ;COUNT ANOTHER SUBTEST
        ADD     #7,R4           ;UPDATE DATA PNTR TO EXPECTGED
        MOV     @.STDTE,R0      ;GET DTE STATUS
        BIC     #52100,R0       ;MASK UNKNOWN DTE BITS
        CMP     R0,(R4)                 ;DATA OK??
        BEQ     2$              ;BR IF YES

;HERE IF ERROR DETECTED
        MOV     #52100,R3       ;SET UP MASK TO BE REPORTED
        MOV     R0,EWORD2       ;SAVE ACTUAL DATA IN CORE
        MOV     #EWORD2,R2      ;R2 WILL POINT TO IT..R4 PNTS TO EXPECTED
        JSR     PC,ERS16D       ;GO TO STANDARD 16-BIT ERROR REPORTER
        JSR     PC,FAULT                ;AND NOW GO REPORT ERROR TO MONITOR
        .WORD   0

2$:     TST     (R4)+           ;UPDATE EXPECTED TO NEXT SUBTEST LIST
        CMP     #^D44,R5        ;DONE ALL SUBTESTS IN THIS PHASE YET??
        BGT     VERM05          ;BR BACK IF NO


;SEQ441
 

;FINALLY-- WE WILL CHECK THE READIBILITY OF KL10 STATUS OVER THE
;DTE20'S DS LINES
;"EBOX CLOCK ERROR STOP" - DS04
        
;"RUN FLOP" - DS05
;"EBOX HALTED" - DS06
        MOV     #EWORD2,R2      ;R2 WILL POINT TO ACTUAL RECEIVED DATA
                                ;R4 STILL POINTS TO EXPECTED
        MOV     #170777,R3      ;R3 CONTAINS MASK FOR DATA COMPARES

;SUBTEST 45
        INSYNC                  ;COUNT SUBTESTS
        MRESET                  ;RESET THE KL10.. CLEARS ALL STATUS
        MOV     @.DIAG1,(R2)    ;READ KL10 STATUS IN DTE'S DS LINES
        BIC     R3,(R2)         ;MASK UNDESIRED BITS
        CMP     (R4)+,(R2)      ;DATA OK??
        BNE     ERVERX          ;BR IF ERROR DETECTED

;SUBTEST 46 - "EBOX HALTED"
        INSYNC                  ;COUNT SUBTESTS
        MOV     #HALT.L,R0      ;GET START ADDR OF MICRO-CODE HALT LOOP
        WWADR                   ;SET IT N THE EBOX
        DFXCTT                  ;AND START EBOX FREE RUNNING IN HALT LOOP
        STRCLK                  ;FUNCTION TO START CLOCK
        
        MOV     @.DIAG1,(R2)    ;READ KL10 STATUS IN DTE'S DIAG1

        BIC     R3,(R2) ;MASK UNDESIRED BITS
        CMP     (R4)+,(R2)      ;DAT OK?
        BNE     ERVERX          ;BR IF ERROR DETECTED

 
  


;SEQ442

;SUBTEST 47 - "RUN FLOP"
;NOW PUT EBOX INTO IDLE LOOP, WITH RUN FLOP TRUE
        INSYNC                  ;COUNT SUBTESTS
        IDLE

        MOV     @.DIAG1,(R2)    ;MASK UNDESIRED BITS

        BIC     R3,(R2)         ;MASK UDNESIRED BITS
        CMP     (R4)+,(R2)      ;DATA OK??
        BNE     ERVERX           ;BR IF ERROR DETECTED


;SEQ443

;SUBTEST 48 - "CLK ERR STOP"
        INSYNC                  ;COUNT SUBTESTS
        MOV     #1,R1           ;NOW INTERESTED IN 1 C-RAM WORD
        CLR     R0              ;AT C-RAM ADDRESS ZERO
        MICNUL                  ;ZERO THE WORD AND GIVE IT BAD PARITY

        $CLRWD  EWORD1          ;CR A BUFFER
        MOVB    #7,EWORD1       ;BITS TO ENABLE "CRM", "DRM" PARITY CHECKS
                                ;"AR/ARX" PARITY CHK & CLK ERR STOP"
        DFWRTT                  ;NOW, FUNCTION WRITE TO SET
        EWORD1          ;CLOCK ERROR REGISTERS
        LDCHK1

        DFWRTT                  ;FUNCTION WRITE TO SET
        EWORD1                  ;"CLK ERR STOP EN"
        LDCHK2
                

        DFXCTT                  ;AND FUNCTION EXECUTE
        STRCLK                  ;TO START CLOCK
                                ;IT SHOULD IMMEDIATELY ERROR STOP
                                ;BECAUSE OD BAD RAM PRITY
        MOV     @.DIAG1,(R2)    ;READ KL10 STATUS IN DTE'S DS LINES
        BIC     R3,(R2)         ;MASK UNDESIRED BITS
        CMP     (R4)+,(R2)      ;DATA OK??
        BNE     ERVERX          ;BR IF ERROR DETECTED

;OTHERWISE ALL DONE
        JMP     NORMAL

;LOCAL SUBROUTINE TOS TACK AND REPORT ANY ERRORS
        

ERVERX: TST     -(R4)           ;BACK UP R4 TO PNT TO EXPECTED DATA
        JSR     PC,ERS16D       ;STACK TEST DATA ON ERROR STACK
        JSR     PC,FAULT        ;AND REPORT FAILURE
        .WORD   0


;SEQ444
;SUBROUTINE TO CHECK THE RESULTS OF CONIS AND INTERRUPTS
;BY READING THE CONTENTS OF THE AR AND COMPARING AGAINST THE
;EXPECTED DATA
IOFUNC: MOV     #DPAR,R0        ;DIAG FUNC TO READ THE AR
        MOV     #EWORD1,R1      ;PLACE TO PUT THE DATA READ
        DFRDMV          ;READ THE DATA

        M36T                    ;ROUTINE TO MASK AND COMPARE THE DATA
        CONIOM                  ;MASK ALWAYS EHRE
        CONOX                   ;EXPECTED ALWAYS HERE
        EWORD1                  ;ACTUAAL ALWAYS HERE

        RTS     PC              ;RETURN.. C-BIT HAS ERROR INDICATOR



;SEQ445


DTENUM: .WORD   0               ;NUMBER OF THE MASTER DTE(0-3)
DTEPHY: .WORD   0               ;PHYSICAL NUMBER ASSIGNED TO MASTER DTE(8-110

DTELST: .WORD   DTE0CS  ;LIST OF CS LINE PATERNS FOR DTE0
        .WORD   DTE1CS  ;LIST OF CS LINE PATTERNS FOR DTE1
        .WORD   DTE2CS  ;LIST OF CS LINE PATTERNS FOR DTE2
        .WORD   DTE3CS  ;LIST OF CS LINE PATTERNS FOR DTE3

DTE0CS: .WORD   200             ;READ DEVICE CODE FOR DTE0
        .WORD   204     ;FIRST CS LINE PATTERN FOR DTE0
        .WORD   220             ;SECOND PATTERN
        .WORD   300             ;ETC...
        .WORD   000
        .WORD   210
        .WORD   240
        .WORD   600
        .WORD   200!BIT15       ;REAL DVICE CODE FOR DTE0 PLUS END-OF LIST BIT

DTE1CS: .WORD   204     ;READ DEVICE CODE FOR DTE1
        .WORD   214             ;FIRST CS LINE PATTERN FOR DTE1
        .WORD   224             ;SECOND PATTERN
        .WORD   304             ;ETC...
        .WORD   004
        .WORD   244
        .WORD   604
        .WORD   200
        .WORD   204!BIT15       ;REAL DEVICE CODE FOR DTE1 PLUS END-OF-LIST BIT

DTE2CS:.WORD   210     ;REAL DEVICE CODE FOR DTE2
        .WORD   214             ;FIRST CS LINE PATTERN FOR DTE2
        .WORD   230             ;SECOND PATTERN
        .WORD   310             ;ETC...
        .WORD   010
        .WORD   250
        .WORD   610
        .WORD   200
        .WORD   210!BIT15       ;REAL DEVICE CODE FOR DTE2 PLUS END-OF-LIST BIT
DTE3CS: .WORD   214             ;READ DEVICE CODE FOR DTE3
        .WORD   234             ;FIRSTR CS LINE PATTERN FOR DTE3
        .WORD   314             ;SECOND PATTERN
        .WORD   014             ;ETC...
        .WORD   254
        .WORD   614
        .WORD   204
        .WORD   210
        .WORD   214!BIT15       ;READ DEVICE CODE FOR DTE3 PLUS END-OPF-LIST BIT

 


;SEQ446

CONODT: WD36    0,0,0   ;36 BIT BUFFER FOR CONO DATA
CONOX:  WD36    0,0,0   ;36 BIT BUFFER FOR CONI EXPECTED DATA
CONOPI:
CONIDT: WD36    0,0,0   ;36 BIT BUFFER FOR CONI DATA
 

CONIOM: WD36    0,0,0   ;PLACE FOR MASK
VERM90: WD36    7777,7777,7760
VERM91: WD36    7777,7700,0000
.EVEN

;LIST OF TEST DATA PATTERNS AND EXPECTED DATA
VERM06: .BYTE   37,17   ;TEST, EXPECTED DATA - SUBTEST 1
        .BYTE   36,16   ;ST 2
        .BYTE   35,15   ;ST 3
        .BYTE   34,14   ;ST 4
        .BYTE   33,13   ;ST 5
        .BYTE   32,12   ;ST 6
        .BYTE   31,11   ;ST 7
        .BYTE   30,10   ;ST 8
        .BYTE   20,0!BIT7       ;ST 9 WITH END-OF-LIST BIT

;LIST OF TEST DATA FOR EBUS PI00-EBUS PI07 INTERRUPT TEST
        .BYTE   376     ;ST 17 - LEVEL 7 OFF
        .BYTE   375     ;ST 19 - LEVEL 06 OFF
        .BYTE   373     ;ST 21 - LEVEL 5 OFF
        .BYTE   367     ;ST 23 - LEVEL 4 OFF
        .BYTE   357     ;ST 25 - LEVEL 3 OFF
        .BYTE   337     ;ST 27 - LEVEL 2 OFF
        .BYTE   277     ;ST 29 - LEVEL 1 OFF

.EVEN

;SEQ447

;DATA FOR FORCING DIFFERENT "API FUNCTION"      WORDS TO BE SENT
;TO THE KL10 ON INTERRUPT BY THE DTE20
VERM07:

;SUBTEST 31 - EXAMINE, ADDR SPACE = EPT,PRTOFF, 10 ADDR = 0
        .WORD   0               ;DATA FOR TO11BC
        .WORD   XEPT!PRTOFF     ;DATA FOR TENAD1
        .WORD   0               ;DATA FOR TENAD2
        WD36    0400,0,0        ;EXPECTED API FUNCTION
        .EVEN

;SUBTEST 32 - EXAMINE, ADDR SPACE=EXEC VIRTUAL,PROTON, 10 ADDR = -1
        .WORD   0               ;DATA FOR T011BC
        .WORD   EXVIRT!177      ;DATA FOR TENAD1
        .WORD   -1              ;DATA FOR TENAD2
        WD36    1440,3777,7777  ;EXPECTED API FUNCTION
        .EVEN

;SUBTEST 33 - DEPOSITY, ADDR SPACE=UPT,PRTOFF, 10 ADDR = 0
        .WORD   0               ;DTA FOR TO11BC
        .WORD   XUPT!DEP!PRTOFF ;DATA FOR TENAD1
        .WORD   0               ;DATA FOR TENAD2
        WD36    2500,0,0        ;EXPECTED API FUNCTION
        .EVEN

;SUBTEST 34 - DEPOSITY, ADDR SPACE= USER VIRTUAL,PROTON, 10 ADDR = -1
        .WORD   0               ;DATA FOR TO11BC
        .WORD   USEVIR!DEP!177  ;DATA FOR TENAD1
        .WORD   -1              ;DATA FOR TENAD2
        WD36    3540,3777,7777  ;EXPECTED API FUNCTION
        .EVEN

;SUBTEST 35 - DEPOSIT, ADDR SPACE = PHYSICAL PRTOFF, 10 ADDR = 0
        .WORD   0               ;DATA FOR TO11BC
        .WORD   PHYS!DEP!PRTOFF ;DATA FOR TENAD1
        .WORD   0               ;DATA FOR TENAD2
        WD36    4500,0,0        ;EXPECTED API FUNCTION
        .EVEN

;SUBTEST 36 - BYTE TRANSFER
        .WORD   7777            ;DATA FOR TO11BC
        .WORD   0               ;DATA FOR TENAD1
        .WORD   0               ;DATA FOR TENAD2
        WD36    0600,0,0        ;EXPECTED API FUNCTION
        .EVEN

;SEQ448

;FINAL PHASE OF TEST
;SUBTEST 37 - KL10 SETS DOORBELL TO THE 11.  EXPECT TO READ

;               "10 REQUESTING INTERRUPT" IN DPD11 STATUS WORD
VERM08: WD36    0,0002,1027     ;CONO DATA TO INTERRUPT THE 11
        WD36    0,0002,0007     ;EXPECTED DATA FOR CONI DTE
;SUBTEST 38
        .WORD   0               ;DATA TO SET IN DTE STATUS WORD
        .WORD   4004            ;DATA TO EXPECT IN DTE STATUS WORD

;SUBTEST 39 - PDP11 CLEARS THE "10 REQUESTING INTERRUPT FLAG", BIT
                
        
;               ":SHOUD CLEAR IN DTE STATUS & CONI DTE WORD
        WD36    0,0,27          ;NO DATA FOR CONO DTE
        WD36    0,0,7           ;EXPECTED DATA FOR CONI DTE
;SBUTEST 40
        .WORD   2000            ;DATA TO SET IN DTE STATUS WORD
        .WORD   4               ;DATA TO EXPECT IN DTE STATUS WORD

;SUBTEST 41- PDP11 SETS THE "11 REQUESTING INTERRUPT" FLAG, EXPECT
;               THAT FLAG TO SET IN DTE STATUS & CONI DTE STATUS
        WD36    0,0,27          ;NO DATA FOR CONO DTE
        WD36    0,0,1007        ;EXPECTED DATA FOR CONI DTE
;SUBTEST 42 
        .WORD   400             ;DAT TO SET IN DTE STATUS WORD
        .WORD   404             ;DATA TO EXPECT IN DTE STATUS WORD

;SUBTEST 43 - KL10 CLEARS "11 REQUESTING INTERRUPT" FLAG, EXPECT
;               FLAG TO CLEAR IN DTE STATUS & CONI DTE STATUS
        WD36    0,0,1027        ;CONO DTE DATA TO CLR FLAG
        WD36    0,0,7           ;EXPECTED CONI DATA
;SUBTEST 44
        .WORD   0               ;DATA TO SET IN  DTE STATUS WORD
        .WORD   4               ;DATA TO EXPECT IN DTE STATUS WORD

;SUBTEST 45
        .WORD   0               ;EXPECT "HALTED","RUN", & "ERR STOP" FALSE
        
;SUBTEST 46     
        .WORD   1000            ;EXPECT "HALTED" YRUE


;SUBTEST 47
        .WORD   2000            ;EXPECT "RUN FLOP" TRUE

;SUBTEST 48
        .WORD   4000            ;EXPECT "CLK ERR STOP" TRUE


;SEQ449

.SBTTL *ESUB*  EBOX DIAGNOSTIC SUBROUTINES

.SBTTL SUBROUTINES TO MANIFULATE 36-BIT WORDS IN 11 CORE

;*****CLRWRD & CLRBUF -- SUBROUTINES TO CLEAR A 36-BIT WORD
;       CALL:   JSR     R5,$CLRWD
;               .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD

$CLRBF: MOV     #EWORD1,R0      ;ALTERNATE ENTRY FOR EWORD1
        BR      CLRW1
        
$CLRWD: MOV     (R5)+,R0
CLRW1:  .REPT   5
        CLRB    (R0)+
        .ENDR
        RTS     R5

;*****SETWRD & SETBUF -- SUBROUTINES TO SET BITS IN A 36-BIT WORD
;       CALL:   JSR     R5,$SETWD
;               .WORD   ADR             ;ADDRESS IF 1ST BYTE IOF WRD
$SETBF:        MOV     #EWORD1,R0      ;ALTERNATE ENTRY
        BR      SETW1

$SETWD: MOV     (R5)+,R0        ;PICK UP AN ARGUMENT
SETW1:  .REPT   4
        MOVB    #377,(R0)+
        .ENDR
        MOVB    #17,(R0)+               ;ONLY 1ST FOUR BITYS OF LAST BYTE
        RTS     R5


;SEQ430

;***ROLWRD & ROLBUF -- SUBROUTINES TO ROTATE LEFT A 36-BIT WORD
;       CALL:   JSR     R5,$ROLWD       
;       .WORD   ADR             ;ADDRESS OF 1ST BYTE OF WORD
$ROLBF: MOV     #EWORD1,R0      ;ALTERNATE ENTRY FOR EWORD1
        BR      ROLW1
        
$ROLWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
        
ROLW1:  PUSH    R1              ;GET A REGISTER

        MOV     #4,R1           ;LOOP COUNT = 4
        ASLB    (R0)+   ;SHJIFT 1ST BYTE (SETS/CLEARS C)
1$:     ROLB    (R0)+           ;ROTATE NEXT BYTE (INCLUDING C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;LOOP TIL DONE
        BITB    #BIT4,-(R0)     ;DID A 1 SHIFT OUT OF SHORT BYTE?
        BEQ     2$              ;NO, SKIP
        SEC                     ;YES, SET CARRY
        ADCB    -4(R0)          ;SET LSB OF 1ST BYTE
2$:     POP     R1              ;DONE, RESTORE REG

        RTS     R5              ;RETURN

;****RORWRD & RORBUF -- SUBROUTINES TO ROTATE RIGHT A 36-BIT WORD
;       CALL:   JSR     R5,$RORWD
;               .WORD           ADDRESS OF FIRST BYTE OF WORD
$RORBF: MOV     #EWORD1,R0      ;ALT ENTRY FOR EWORD1
        BR      RORW1

$RORWD: MOV     (R5)+,R0        ;GET ADDRESS OF 1ST BYTE IN R0
RORW1:  PUSH    R1              ;GET A REGISTER

        MOV     #4,R1           ;LOOP 4 TIMES
        ADD     R1,R0           ;POINT AT LAST BYTE
        ASRB    (R0)            ;SHIFT LAST BYTE (SETS/CLEARS C)
        BICB    #BIT3,(R0)      ;CLEAR MSB OF 10 WORD (C NOT AFFECTED)
1$:     RORB    -(R0)           ;ROTATE THIS BYTE (INC C)
        DEC     R1              ;UPDATE LOOP COUNT
        BNE     1$              ;DO ALL
        BCC     2$              ;NO, GO AROUND
        BISB    #BIT3,4(R0)     ;YES, SET MSB OF 10 WORD
2$:     POP     R1              ;RESTORE REG

        RTS     R5              ;RETURN



;SEQ431

;***MOVWRD -- SUBROUTINE TO MOVE A 36 BIT WORD FROM ONE
;PLACE TO ANOTHER.  CALL INCLUDES TRAILING PARAMETERS AS FOLLOWS:
;       JSR     R5,$MOVWD
;       .WORD   SOURCE ADDRESS
;       .WORD   DESTINATION ADDRESS

$MOVWD: SHOVE                   ;SAVE REGISTERS
        MOV     (R5)+,R2        ;GET ADDRESS OF SOURCE
        MOV     (R5)+,R1        ;GET ADDRESS OF DESTINATION
        MOV     #5,R0           ;NEED FIVE BYTE MOVES
1$:     MOVB    (R2)+,(R1)+     ;TRANSFER
        DEC     R0              ;SEE IF DONE
        BGT     1$              ;BR IF NO
        GRAB                    ;IF DONE RESTORE REGISTERS
        RTS     R5              ;RETURN

;***COMBUF -- SUBROUTINE TO WRITE THE 36-BIT COMPLIMENT
;OF EWORD1 TO EWORD2.
;       CALL:   JSR     R5,$COMBF

$COMBF: SHOVE
        MOV     #EWORD1,R1      ;R1 PTS TO 1ST BUFFER
        MOV     #EWORD2,R2      ;R2 TO 2ND
        MOV     #5,R3           ;R3 COUTNS BYTES

1$:     MOVB    (R1)+,R0        ;GET NEXT BYTE
        COMB    R0              ;COMPLIMENT IT
        MOVB    R0,(R2)+        ;PUT IT AWAY
        DEC    R3               ;DOWN THE COUNT
        BGT     1$              ;LOOP TIL DONE

        BICB    #360,-(R2)      ;SHAVE THE LAST BYTE
        GRAB                    ;BACK THE REGS
        RTS     R5              ;RETURN
;SEQ452
 
 ;***INCWRD -- SUBROUTINE TO ADD 1 TO THE 36-BIT BUFFER "PATN1"
;       CALL:   JSR     R5, $INCWD
 
$INCWD: MOV     #PATN1, R0      ;GET ADDRESS OF 36 BITS
        SEC
        ADCB    (R0)+           ;ADD CARRY THRU THE 36 BITS
        ADCB    (R0)+           ;ADD CARRY THRU THE 36 BITS
        ADCB    (R0)+           ;ADD CARRY THRU THE 36 BITS
        ADCB    (R0)+           ;ADD CARRY THRU THE 36 BITS
        ADCB    (R0)+           ;ADD CARRY THRU THE 36 BITS
        RTS     R5              ;AND RETURN

;SEQ453

.SBTTL SUBROUTINES TO MANIPULATE 80-BIT MICROWORDS IN 11-CORE

;***CLRMIC & CLR$M -- SUBROUTINES TO CLEAR A 12-BYTE MICROWORD
;       CALL:   JSR     R5,$CLRMI       
                
;               .WORD   ADR             ;ADDRESS OF 1ST BYTE OF MICROWORD

$CLR$M: MOV     #$MICRO,R0      ;ALT ENTRY FOR $MICRO
        BR      CLRM1
$CLRMI: MOV     (R5)+,R0                ;PICK UP STARTING ADDRESS
        
CLRM1:  .REPT   6
        CLR     (R0)+
        .ENDR
        RTS     R5

;***GETMIC -- SUBROUTINE TO READ CRAM LOCATION INTO 80-BIT BUFFER
;       CALL:   MOV     #LOC,R0         ;R0 POINTS TO CRAM LOCTION TO READ
        
;               JSR     R5,$GETMI       ;CALL

$GETMI: PUSH    <R1,R2>                 ;SAVE TWO REGISTERS

        RCRAM                   ;READ THE CRAM
        MOV     #$MICRO,R1              ;PICK UP PTR TO BUFFER
        MOV     #12,R2          ;WILL COPY 12 BYTES
1$:     MOVB    (R0)+,(R1)+     ;COPY A BYTE INTO THE BUFFER
        DEC     R2              ;COUNT IT
        BGE     1$              ;LOOP TIL DONE
        POP     <R2,R1>         ;RETURN REGISTERS

        RTS     R5              ;AND RETURN



;SEQ454
 
.SBTTL SUBROUTINES TO DIDDLE THE PDP-11
 
;***M.RESPSIM -- ROUTINE TO SET "CLK MBOX RESP SIM"
 
$M.RES: PUSH    R1              ;SAVE REG 1
        MOV     #1$,R1          ;ADDR OF 36 BIT BUFFEER
        MOV     #LDCHK2,R0      ;DIAG FCN
        DFWRT
        POP     R1              ;RESTORE REG
        RTS     R5              ;AND DONE
1$:     WD36 0,0,14             ;BITS TO SET 'MBOX DISABLE "&" MBOX RESP IN'
.EVEN
 
;***CLEAR -- SUBROUTINE TO PRESERVE MBOX DISABLE ON RESET

$CLEAR: MRESET                  ;DO CONSOLE RESET
        MOV     R1,-(SP)        ;SAVE A REG
        MOV     #1$,R1          ;PTR TO ZEROES
        MOV     #LDCHK2,R0      ;LOAD SECOND REGISTER
        DFWRT

        MOV     (SP)+,R1        ;RESTORE REG
        RTS     R5              ;AND BACK
1$:     WD36    0,0,10          ;BIT TO SET "MBOX DISABLE"
.EVEN


;SEQ434


;***SHOVE -- SUBROUTINE TO SAVE REGS 1-4 ON THE STACK
;WITHOUT DISTURBING R0 OR R5.

$SHOVE: POP     $$HOLD          ;GET R5 OFF STACK

        PUSH    <R4,R3,R2,R1>   ;SAVE THE REGISTERS

        PUSH    $$HOLD          ;PUT R5 BACK ON STACK
        RTS     R5              ;AND RETURN

$$HOLD: .WORD   0               ;SAVE LOCATION

;***GRAB -- SUBROUTINE TO RESTORE REGS 1-4 FROM THE STACK
;WITHOUT DISTURBING R0 OR R5.

$GRAB:  POP     $$HOLD          ;GET R5 OFF STACK.

        POP     <R1,R2,R3,R4>   ;PUT BACK REGISTERS.

        PUSH    $$HOLD          ;PUT R5 BACK ON STACK.

        RTS     R5              ;AND RETURN.


;SEQ435

.SBTTL DIDDLY -- SUBROUTINE FOR LOADING CRAM FIELDS INTO $MICRO.

;THIS ROUTINE IS CALLED WITH UP TO 16 BITS OF RIGHT JUSTIFIED DATA IN R0
;WHICH ARE TO BE WRITTEN INTO ARBITRARY BIT POSITIONS IN THE 11-BYTE MICRO-
;WORD BUFFER, $MICRO, FOR LOADING INTO THE CRAM (E.G. USING $MWORD). THE BITS
;NEED NOT BE ADJACENT, NOR IN THE SAME BYTE IN $MICRO, AND ALL UNSPECIFIED BITS
;IN $MICRO ARE NOT DISTURBED BY THIS ROUTINE.  BIT LOADING IS OCNTROLLED
;BY TABLES INTERNAL TO THIS ROUTINE, WHICH ARE SELEDCCTRTED BY MEANS OF ENTRY
;POINT:
;

;EXAMPLE        CALL:
;               MOV     #37,R0  ;THIS CALL LOADS 37 INO THE AD

;               JSR     R5,$AD  ;CONTROL FIELD OF $MICRO.
;
;THE FOLLOWING FIELDS ARE SUPPORTED (NOTE ORDER OF BITS):
;
;       $AD     LOADS ADB SEL 2 & 1     ;ADA DIS,SEL2 & 1;AD CRY, AD BOOLE & AD SEL 8,4,2
;       $AR     LOADS ARXM SEL 4,2,&1 AN ARM SEL 4,2,&1.
;       $BR     ;LOADS BR LOAD & BRX LOAD
        
;       $COND   LOADS OCND 00-05.
;       $DISP   LOADS DISP 00-04.
;       $FE     LAODS FE LOAD
        
;       $EACALL LOADS THE CALL BIT ON MODEL B CPU'S
;       $FM     LOADS FM ADR SEL 4,2&1
;       $J      LOADS J00-J10.
;       $MEM    LOADS MEM 00-03
;       $MQ     LOADS MQ SEL
;       $NUM    LOADS #00-08
;       $SC     LOADS SCM SEL 2
        

;       $SCAD   LOADS SCADB SEL 2 & 1: SCADA DIS,SEL 2 & 1 AND SCAD 4,2 & 1.
        
;       $SH     LOADS SH-ARMM SEL 2 & 1
;       $T      LOADS T00 & T01
;       $VMA    LOADS VMA SEL 2 & 1
;THERE IS AN ALTERNATE CALL FOR EACH ENTRY WHICH ALLOWS THE ALUE OF
;THE FIELD TO BE WRITTEN TO BE PASSED AS AN IN-LINE TRAILING PARAMETER.
;THE CALLS ARE SIMJLAR TO THE ABOVE ONLY SUFFIXED BY A 'T'.  FOR EXAMPLE:
;
;               JSR     R5,$ADT
;               .WORD   37
;
;IS THE EQUIVALENT TO THE ABOVE REGISTER PARAMERTER CALL.


;SEQ436

;HERE BEGINS THE MEAT OF THIS ROUTINE.

DIDDLY: SHOVE                   ;SAVE REGISTERS R1-R4.
        MOV     10(SP),R1       ;TABLE BASE  ADDRESS GOES IN R1.
        CLR     DOODLY          ;CLEAR LAST BYTE FLAG

;       R1      POINTS AT CURRENT PLACE IN DIDDLY'S TABLE.
;       R2      POINTS AT BYTE IN $MICRO CURRENTLY BEING MODIFIED.
;       R3      HAS CURRENT BIT MASK FROM DIDDLY'S TABLE.
;       R4      COUNTS SHIFTS TO TELL WHEN A BYTE IS DONE.

;DO THIS LOOP UNTIL ALL BYTES HAVE BEEN MODIFIED ACCORDING TO THE GABLE.

SQUAT:  MOVB    (R1)+,R2                ;PUT NEXT INDEX INTO $MICRO IN R2.
        BGE     DIDLY0          ;LAST TABLE ENTRY MARKED WITH NEG INDEX.
        COM     DOODLY          ;SET LAST BYTE FLAG AND
        BIC     #177700,R2      ;FIX CODED INDEX

DIDLY0: ADD     #$MICRO,R2      ;ADD $MICRO BASE TO INDEX.
        MOVB    (R1)+,R3        ;GET NEXT MASK BYTE TO R3.
        MOV     #10,R4          ;R4 WILL COUNT ROTATES

;AROUND THIS LOOPE IGHT TIMES FOR EACH BUTE INT HE TABLE.

DIDLY1: ASRB    R3              ;SHIFT NEXT MASK BIT TO C.
        BCC     DIDLY2          ;WAS IT A 1?
        ASR     R0              ;YES, SHIFT NEXT INPUT BIT TO C.
        BR      DIDLY3          ;AND GO ROTATE INTO $MICRO

DIDLY2: BITB    #1,(R2)         ;NO, IS RH BIT OF $MICRO NOW SET.
        BEQ     DIDLY3          ;NO, GO ROTATE INTO $MICRO

        SEC                     ;YES, SET C TO AND
DIDLY3: RORB    (R2)            ;ROTATWE CONTENTS OF C INTO $MICRO BYTE.
        DEC     R4              ;COUNT SHIFTS.
        BNE     DIDLY1          ;LOOP TILL DONE WHOLE BYTE.

        TST     DOODLY          ;LAST TABLE ENTRY?
        BGE     SQUAT          ;NO, THEN SEE IF MORE TO DO.





        GRAB                    ;YES, RETURN REGISTERS BORROWEC.
        POP     R0              ;THROW AWAY TABLE BASE.

        RTS     R5              ;YOU ALL DONE, BOY!

DOODLY: 0               ;STORAGE FOR SQUAT


;SEQ437


;HERE ARE DIDDLY'S INTENAL TABLES:

$ADT:   MOV     (R5)+,R0        ;PICK UP TRAILING PARAMETER
$AD:    JSR     PC,DIDDLY       ;ENTER,PUSH THIS ADR, AND START
        .BYTE   7
        .BYTE   17              ;AD SEL 8,4,2,1

        .BYTE   6
        .BYTE   200             ;AD BOOLE
        .BYTE   0       
        .BYTE   40              ;AD CRY
        .BYTE   6
        .BYTE   160             ;ADA DIS,SEL 2 & 1
        .BYTE   5
        .BYTE   200             ;ADB SEL 1
        .BYTE   206     
        .BYTE   10              ;ADB SEL 2

$ART:   MOV     (R5)+,R0
$AR:    JSR     PC,DIDDLY
        .BYTE   1
        .BYTE   240             ;ARM SEL 2 & 1
        .BYTE   4
        .BYTE   4               ;ARM SEL 4
        .BYTE   1
        .BYTE   12              ;ARXM SEL 2 & 1
        .BYTE   205             
        .BYTE   10              ;ARXM SEL 4

$BRT:   MOV     (R5)+,R0
$BR:    JSR     PC,DIDDLY
        .BYTE   203
        .BYTE   12              ;BR & BRX LOAD

$CONDT: MOV     (R5)+,R0
$COND:  JSR     PC,DIDDLY
        .BYTE   2
        .BYTE   20              ;COND 5
        .BYTE   3
        .BYTE   5               ;COND 3 & 4
        .BYTE   207
        .BYTE   160             ;COND 0,1 & 2

$DISPT: MOV     (R5)+,R0
$DISP:  JSR     PC,DIDDLY
        .BYTE   212
        .BYTE   37              ;DISP 0-4


;SEQ438


$EACLT: MOV     (R5)+,R0
$EACAL: JSR     PC,DIDDLY
        .BYTE   212
        .BYTE   40              ;EA CALL

$FET:   MOV     (R5)+,R0
        
$FE:    JSR     PC,DIDDLY
        .BYTE   211
        .BYTE   10              ;FE LOAD

$FMT:   MOV     (R5)+,R0
$FM:    JSR    PC,DIDDLY
        .BYTE   202
        .BYTE   340             ;FM ADR 4,2, & 1

$JT:    MOV     (R5)+,R0
$J:     JSR     PC,DIDDLY
        .BYTE   10
        .BYTE   377             ;J3-10
        .BYTE   211
        .BYTE   7               ;J0-2

$MEMT:  MOV     (R5)+,R0
$MEM:   JSR     PC,DIDDLY
        .BYTE   203
        .BYTE   360             ;MEM 0-3

$MQT:   MOV     (R5)+,R0
$MQ:    JSR     PC,DIDDLY
        .BYTE   207
        .BYTE   200             ;MQ SEL

$NUMT:  MOV     (R5)+,R0
$NUM:   JSR     PC,DIDDLY
        .BYTE   5
        .BYTE   167             ;CRAM # 3-8
        .BYTE   206
        .BYTE  7               ;CRAM # 0-2


;SEQ439

$SCT:   MOV     (R5)+,R0
$SC:    JSR     PC,DIDDLY
                .BYTE   202     
        .BYTE   2               ;SCM SEL 2

$SCADT: MOV     (R5)+,R0
$SCAD:  JSR     PC,DIDDLY
        .BYTE  11
        .BYTE   160             ;SCAD 4,2 & 1
        .BYTE   4
        .BYTE   300
        .BYTE   11
        .BYTE   200             ;SCADA DIS
        .BYTE 2
        .BYTE   10              ;SCADB SEL 1
        .BYTE   204
        .BYTE   40              ;SCADB SEL 2

$SHT:   MOV     (R5)+,R0
$SH:    JSR     PC,DIDDLY
        .BYTE   204
        .BYTE   3               ;SH-ARMM SEL 2 & 1


$TT:    MOV     (R5)+,R0
$T:     JSR     PC,DIDDLY
        .BYTE   200
        .BYTE   12              ;T00 & T01

$VMAT:  MOV     (R5)+,R0
$VMA:   JSR     PC,DIDDLY
        .BYTE   0
        .BYTE   200             ;VMA SEL 1
        .BYTE   204
        .BYTE   10              ;VMA SEL 2


;SEQ440

.SBTTL MWORD, XBUF & XBUF0 -- SUBROUTINES TO LOAD/EXECUTE THE COMMAND REGISTER
;***MWORD--LOAD A MICROWORD TO THE COMMAND REGISTER FROM THE MICROWROD BUFFER
;AND VERIFY THAT IT GOT IN THE CR CORRECTLY.  IF FLAG $NOCHK IS NON-ZERO,
;INIDCATING THAT THE ROUTINE WAS CALLED FROM THE INITALIZATION CODE,
;THE VERIFICATION IS BYPASSED.  UNDER THESE CONDITIONS MWORD "ATTEMPTS" TO
;LOAD THE COMMAND REGISTER.

;THE MICROWORD TO BE WRITTEN IS IN THE 12-BYTE BUFFER AT $MICRO AND THE
;C-RAM LOCATION TO LOAD IS IN $$CRAD.  IF BIT 15 OF $$CRAD IS SET
;NO MASTER RESET IS DONE BY THE ROUTINE (USER SHOULD CLEAR "DISP" FIELD
;TO ASSURE DISPATCH ON DIAGNOSTIC ADDRESS REG).
;THE CONTENTS OF THE C-RAM LOCATION ARE LOST.
;
;               CALL:   JSR     R5,$MWORD

$MWORD: PUSH    R1              ;SAVE R1 ON STACK

        MOV     $$CRAD,R0               ;PUT ADR TO BE WRITTEN IN R0.
        MOV     #$MICRO,R1              ;PUT ADR TO DATA IN R1.
        WCRAM                   ;WRITIE THE CRAM

        DFXCTT                  ;SINGLE STEP CLOCK TO CLOCK
        .WORD   SECLK          ;CRAM DATA TO CR

        MOV     #-1,R0          ;SDET UP TOR ED THE COMMAND REG
        RCRAM                   ;DO IT

        POP     R1              ;RESTORE R1
        TST     $NOCHK          ;SEE IF THE :NO CHECKING" FLAG IS FLYING
        BNE     MWRTN           ;AND BYPASS CHECK IF IT IS

        JSR     R5,$CHKMI       ;COMAPRE COMMAND REG TO $MICRO
        .WORD   $MICRO          ;PTR TO EXPECTED DATA
        .WORD   MWERR!BIT15    ;PTR TO EROR MESSAGE

MWRTN:  RTS     R5              ;RETURN IF NO ERROR (OTHEWISE TAKE ERROR

MWERR:  .ASCIZ/CRAM VERIFICATION ERROR INTERNAL TO TEST!/
.EVEN


;SEQ441


;***XBUF--LOAD THE COMMAND REGISTER AND GIVE AN EBOX CLOCK TO EXECUTE IT.
;THIS ROUTINE DOES AN :MWORD" FOLLOWED BY AN "ECLOK".

$XBUF:  JSR     R5,$MWORD

        ECLOK
        RTS     R5

;***XBUF0--LOAD THE CR AND EXECUTE IT BY LOADING IT AGAIN WITH 0'S
;(LEAVE THE CR AND THE MICROWORD BUFFER, $MICRO,CLEARED).

$XBUF0: JSR     R5,$MWORD       ;WRITE $MICRO TO CR
        JSR     R5,$CLR$M       ;CLEAR $MICRO
        JSR     R5,$MWORD       ;EECTUE AND CLEAR THE CR

        RTS     R5


;SEQ442

.SBTTL CHKMIC  -- SUBROUTINE TO COMPARE MICROCODE WORDS.

;CALL:  MOV     #ACTUAL,R0      ;R0 POINTS TO 1ST BYTE OF ACTUAL DATA.
;       CHKMIC                  ;SUBROUTINE CALL.
;       .WORD   EXPECT          ;POINTER TO 1ST BYTE OF EXPECTED DATA.
;       .WORD   ERROR!BIT15     ;POINTER TO ERROR TEXT (+INDIRECT FLAG).
;
;THE DATA IS ASSUMED TO BE IN THE INVERTED BYTE FORMAT USED BY CONSOLE
;ROUTINES RCRAM AND WCRAM.  NOTE THAT RCRAM RETURNS WITH R0 POINTING TO
;THE ACTUAL DATA READ AS REQUESTED BY THIS ROUTINE.
;
;FOR PURPOSES OF ERROR REPORTING, THIS ROUTINE ASSUMES THAT THE MICROCODE
;WORD ADDRESSED BY BUFFER LOCATION $$CRAD WAS BEIN COMPARED.

$CHKMI: CLR     CHKFLG          ;CLEAR ERROR FLAG
        SHOVE                   ;SAVE REGISTERS 1-4 ON STACK.
        MOV     R5,-(SP)        ;SAVE RETURN POINTER ON STACK.
        MOV     (R5)+,R1        ;PUT PTR TO EXPECTED DATA IN R1.
        MOV     #CMASK,R2       ;PUT PTR TO NONEX.  BIT MASK IN R2.
        MOV     #^D11,R3        ;COUNT 11 BYTE COMPARES IN R3.
        MOV#CKACT,R4            ;PTR TO SAVED ACTUAL DATA
        MOV     #CKEXP,R5       ;PTR TO SAVED EXPECTED DATA

CHKM1:  MOVB    (R0)+,(R4)      ;GET A BYTE OF ACTUAL DATA.
        BICB    (R2),(R4)       ;MASK OUT UNUSED CRAM BITS.
        MOVB    (R1)+,(R5)      ;GET A BYTE OF EXPECTED DATA.
        BICB    (R2)+,(R5)      ;AND MASK IT.
        CMPB    (R4)+,(R5)+     ;ARE THEY EQUAL?
        BEQ     CHKM2           ;NO ERROR, SKIP AROUND.
        MOV     #-1,CHKFLG      ;SET ERROR FLAG
CHKM2:  DEC     R3              ;OTHERWISE, UPDATE BYTE COUNT
        BNE     CHKM1           ;AND LOOP.

        TST     CHKFLG          ;ANY ERRORS?
        BNE     CHKMER          ;YES, GO REPORT THEM


;SEQ443

;HERE IF NO ERRORS:

CHKM3:  MOV     (SP)+,R5        ;GET UNUPDATED RETURN PTR.
        CMP     (R5)+,(R5)+     ;UPDATE IT.
        GRAB                    ;RESTORE R1-R4.
        RTS     R5              ;AND RETURN

;AND HERE IF ERROR FOUND:

CHKMER: MOV     ERSP..,R0       ;GET PTR TP THE ERROR STACK .
        MOV     #FT6,(R0)+      ;PUSH FORMAT ID ON ERROR STACK.
        MOV     #$$CRAD,(R0)+   ;POUSH PTR TO CRAM ADR ON ERROR STACK.
        BIC     #BIT15,$$CRAD   ;GET RID OF SIGN BIT FOR ERROR REPORTER
        MOV     #CKACT,R1       ;PUT ACTUAL DATA PTR IN R1.
        MOV     #^D11,R2        ;COUNT OF 11 TO R2.
1$:     MOVB    (R1)+,(R0)+     ;PUSH ACTUAL DATA BYTE ONTO ERROR STACK.
        DEC     R2              ;DOWN COUNT.
        BNE     1$              ;AND LOOP TILL DONE ALL/
        MOV     #CKEXP,R1       ;PUT EXPECTED DATA PTR IN R1
        MOV     #^D11,R2        ;COUNT AGAIN.
2$:     MOVB    (R1)+,(R0)+      ;PUSH 11 BYTES OF EXPECTED DAT ONTO
        DEC     R2              ;THE ERROR STACK.
        BNE     2$
        MOV     R0,ERSP..       ;RETURN UPDATED ERROR STACK PTR.

;FIX UP STACK BEFORE TAKING ERROR EXIT:

        MOV     (SP)+,R5        ;GET RETURN PC
        TST     (R5)+           ;BUMP TO PT TO ERROR MSG
        GRAB            ;RESTORE REGISTERS 1-4.

        MOV     (SP),R0         ;GET BUMP TO PT TO ERROR MSG
        MOV     R5,(SP)         ;PUT PTR TO ERR MSG IN ITS PLACE ON STACK
        MOV     R0,R5           ;TRANSFER SUBTESTM# TO R5

        JMP     FAULT           ;AND TAKE ERROR EXIT.

;MASK TABLE:
CMASK:  .BYTE   125             ;MASK OUT EVERY ODD BIT IN 1ST
        .BYTE   125             ;TWO BYTES.
        .BYTE   5               ;JUST TWO IN 3RD BYTE.
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   300             ;LEFT 2 IN LAST BYTE.
.EVEN
CHKFLG: .WORD   0               ;STORGE FOR EROR FLAG

CKACT:  .BLKB   ^D11            ;STORAGE FOR ACTUAL
CKEXP:  .BLKB   ^D11            ;STORAGE FOR EXPECTED


;SEQ444

.SBTTL MSK36 -- SUBROUTINE TO MASK AND COMPARE 36-BIT DATA

;36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON OF
;36-BITS OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT & LOADS
;THE ERROR STACK IF MISCOMPARE.
;       CALL IS:
        
;               JSR     R5,$MSK36
;       R3 = POINTER TO MASK (0S IMPLYU TEST)
;       R4 = POINTER TO EXPECTED DATA
;'      R2 = POINTER TO ACTUAL DATA

$MSK36: REGSAV                  ;TE FAMOUS 10% FAILURE
        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #4,R0           ;LOOP COUNT
1$:     MOVB    (R4)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R3),R1         ;MASK IT
        MOVB    (R2)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R3)+,R5        ;MASK IT
        TST     R0              ;DOING LAST BYTE?
        BNE     6$              ;NO, GO AROUND
        BICB    #360,R5         ;YES, MASK OFF ABSENT BITS
        BICB    #360,R1         ;CLEAR EXPECTED TOO
6$:     CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGE     1$              ;NO,LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     5$              ;NO, COMPARE. O.K.
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R3           ;RESTORE MASK POINTER
        MOV     R3,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R2           ;RESTORE ACTUAL POINTER
        MOV     #5,R5           ;
3$:     MOVB    (R2)+,(R0)+     ;ACTUAL TO ERROR STACK
        DEC     R5              ;
        BGT     3$              ;
        SUB     #5,R4           ;RESTORE POINTER TO EXPECTED
        MOV     #5,R5           ;
4$:     MOVB    (R4)+,(R0)+     ;EXPECTED TO ERROR STACK
        DEC     R5
        BGT     4$              ;
        MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        REGRST                  ;REGISTERS
        SEC                     ;SET C-BIT
        RTS     R5              ;RETURN
5$:     REGRST          
        CLC                     ;CLEAR DAMN C-BIT
        RTS     R5              ;RETURN
FFLAG:  0


;SEQ445

;36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).  USES $MSK36.
;
;CALL IS:
;       JSR     R5,$MK36T
;       ENTRY+2 = POINTER TO MASK (0S IMPLY TEST)
;       ENTRY+4 = POINTER TO EXPECTED DATA
;       ENTRY +6        = POINTER TO ACTUAL DATA

$MK36T: PUSH    <R3,R4,R2>

        MOV     (R5)+,R3        ;MASK POINTER TO R3
        MOV     (R5)+,R4        ;EXPECTED POINTER TO R4
        MOV     (R5)+,R2        ;ACTUAL POINTER TO R2
        JSR     R5,$MSK36       ;PERFORM THE TEST
        POP     <R2,R4,R3>


        RTS     R5              ;RETURN


;SEQ446

.SBTTL MICLD -- ROUTINE TO WRITE SEVERAL MICRO WORDS PER CALL

;THIS IS A SUBROUTINE TO WRITE MICRO CODE WORDS INTO THE MICRO CODE RAM.
;       CALL:   JSR     R5,$MICLD
;               .WORD   NUM             ;NUMBER OF LOCATIONS TO BE WRITTEN

        
;               .WORD   START           ;STARTING CRAM ADDRESS
;               .WORD   PDATA           ;ADDRESS OF DATA TO BE WRITTEN (OR "ZERO" OR "ON
;WILL FILL THE SPECIFIED NUMBER OF ADDRESSES SEQUENTIAALLY,
;STARTING WITH "ACTUAL STARTING ADDRESS", WITH ALL "ZEROS"
;OR ALL "ONES", OR VAIRABLE DATA, AS POINTED TO BY "POINTER TO DATA"

$MICLD: SHOVE                   ;SAVE REGISTERS
        MOV     (R5)+,R4        ;GET NUIMBER OF ADDR TO BE LOADED
        MOV     (R5)+,R3        ;GET STARTING MICRO RAM ADDRESS
        MOV     (R5),R2         ;GET KEYWORD (OR DATA POINTER)
        BGT     1$              ;BR IF KEY > THAN ZERO

;LTHIS SECTION SETS UP FOR DOING ONES OR ZEROES
        MOV     #6,R0           ;NEED 5 WORD MOVES TO FILL DATA AREA
        MOV     #100$,R1        ;MOVE ADDR OF DATA AREA TO R1
3$:     MOV     (R5),(R1)+      ;MOVE DATA TO FIRST BYTE
        DEC     R0              ;DONE FIVE YET?
        BNE     3$              ;LOOP IF NOT
        MOV     #100$,R2;       ;SET DATA POINTER

;COMMON CODE TO SEND OUT MICRO RAM DATA
1$:     MOV     R2,R1           ;MOVE POINTER TO DATA FOR WCRAM CALL
        MOV     R3,R0   ;CRAM ADDR IN T0
        WCRAM                   ;ISSUE CALL
        DEC     R4              ;DONE REQUIRED NUMBER OF WORDS?
        BEQ     8$              ;BR IF YES

;NOT DOEN, READY NEXT C-RAM WRITE
        INC     R3              ;INCREMENT TO NEXT CRAM ADDR
        TST     (R5)            ;SEE IF NEED NEW DATA
        BLE     1$              ;BR IF CAN USE OLD ONES OR ZEROES

        ADD     #^D12,R2        ;NEW DATA
        BR      1$              ;CONTINUE WITH BIGLOOP


;END UP CODE
8$:     GRAB                    ;RESTORE REGISTERS
        TST     (R5)+           ;STEP OVER DAT APTR
        RTS     R5              ;RETURN

100$:   
        .WORD 0,0,0,0,0,0


;SEQ447


.SBTTL ACSET -- A SUBROUTINE TO SET AC # FIELD

;TIS A SUBORUTINE FOR SETTING AND CHECKING THE AC# FIELD.  IF THE
;"NO CHECK" FLAG IS SET -- INCIDATING THAT THIS ROUTINE IS BEING USED
;BY SOME INITIALIZATION CODE -- THE CHECKING IS BYPASSED AND THE
;ROUTIE SIMPLY "ATTEMPTS" TOSET THE AC#.

;IT USES (AND LEAVES CLEARED) A 36 BIT WORK AREA, EWORD1, AND THE 80 BIT
;
;       CALL:   JSR     R5,$ACSTT
;               .WORD   VALUE           ;AC#, RIGHT JUSTIFIED
;       OR:
;               MOV     #VALUE, R0      ;AC#
;               JSR     R5,$ACSET

$ACSTT: MOV     (R5)+,R0                ;PICK UP AC#

$ACSET: PUSH    <R1,R0>                 ;GET REG AND SAVE DATA

        $CLRWD                          ;CLEAR OUT WORK AREA
        POP     R0                      ;GET DATA ACK
        BIC     #177760,R0              ;MAKE SURE NO EXTRA BITS ALONG FORRIDE
        MOVB    R0,EWORD1+3             ;PUT AC # IN EBUS BITS 8-11
        BISB    #BIT4,R0                ;SET BIT FOR "AC EN" IN EXPECTED DATA
        MOVB    R0,ACDAT        ;PUT AC# INTO EXPECTED DATA
        $RORWD                  ;ROTATE RIGHT TO PUT AC # IN 9-12
        
        $CLRMI                          ;ZERO MICROWORD BUFFER
        MOV     #LDAR,R0                ;SET UP TO LOAD THE IR
        MOV     #EWORD1,R1              ;PTR TO DATA
        DFWIR                   ;EMT
        POP     R1              ;RESTORE REGISTER BORROWED


;SEQ448



        DFXCTT                  ;STROBE LATCHES TO SET AC#
        .WORD   DRLTCH
        CLRB    EWORD1+3        ;LEAVE WORK AREAS CLEARED
        DFWRTT                  ;LEAVE AR CLEAN
        .WORD   EWORD1
        .WORD   LDAR

        TST     $NOCHK          ;SEE IF THE "NO CHECK" FLAG IS ON
        BNE     ACRTN           ;BYPASS TESTING IF IT IS

        DCOMP                   ;CHECK THE RESULTS
        .WORD   ACMSK           ;PTR TO MASK
        .WORD   ACFUN           ;PTR TO FUNCTION
        .WORD   ACBYT           ;PTR TO BYTE
        .WORD   ACDAT           ;PTR TO EXPECTED DATA
        .WORD   ACERM!BIT15             ;PTR TO ERROR MSG


ACRTN:  RTS     R5              ;AND RETURN

ACMSK:  .BYTE   340             ;COMPARE ONLY LEAST 5 SIGNIFICANT BITS
ACFUN:  .BYTE   RIR+2!BIT7      ;DO AN IR READ, ":OR" IN STOP CODE
        
ACBYT:  BYTPNT  EIR             ;READ EBUS BITS 13-17

ACDAT:  .BYTE   0               ;EXPECTED DATA GOES HERE
ACERM:  .ASCIZ/AN ATTEMPT TO SET THE AC # FIELD HAS FAILED TO VERIFY!/
.EVEN


;SEQ449

.SBTTL ARLOD2 -- SUBROUTINE TO LOAD AR WITHOUT AFFECTING IR

;CALLING SEQUENCE
;       MOV     #ADDR OF 36 BIT DATA,R0
;       JSR     R5,$ARLO2
;KEEP IN MIND THAT THIS ROUTINE STEPS THE EBOX CLOCK ONE TIME
;AND A NEW COMMAND GETS CLOCKED INTO THE CONTROL REGISTER

$ARLO2: PUSH    R1              ;SAVE R1

        MOV     R0,R1
        MOV     #LDAR,R0
        DFWRT                   ;THE DATA IS IN AR

        DFXCTT                  ;CLOCK THE MACHINE
        SECLK

        POP     R1              ;RETRIEVE REGISTERS

        RTS     R5              ;AND GONE

;***HERE IS A SPECIALIZED SUBORUTINE TO LOAD THE AR FROM BUFFER EWORD1:

$STUFF: DFWRTT                  ;EMT TO LOAD THE AR
        .WORD   EWORD1          ;DATA POINTER
        .WORD   LDAR            ;FUNCTION
        RTS     R5              ;AND THAT IS ALL


;SEQ450

.SBTTL FAMOUS DCOMP -- SUBROUTINE TO DO MULTIPLE MASKED BYTE COMPARES

;ROUTINE TO COMPARE AND CHECK CONTROL BITS IN RANDOM EBUS POSITIONS.
;IT REQURIES 4 TABLES:  1) A BYTE TABLE OF DIAGNOSTIC FUNCTIONS, 2)
;A BYTE TABLE OF EXPECTED DATA, 3) A BYTE TABLE OF MASKS, AND 4) A BYTE
;TALBE FO EBUS BIT POINTERS, WHICH SPECIFY THE EUS POSITION OF THE
;BYTE UNDER INSPECTION.
;THERE IS AN ALTERNATE CALL ENTRY, "SDCOMP",WHICH PROVIDES FOR
;CALLS FROM SUBROUTINES
;       CALL:   JSR     R5,$DCOMP
;               .WORD   PMASK           ;ADDRESS OF 1ST MASK BYTE
;               .WORD   PUNC            ;ADDRESS OF 1 DIAG FUNC BYTE
        
;               .WORD   PBYTE           ;ADDRESS OF 1ST EBUS BYTE PTR BYTE
;               .WORD   PEXP            ;ADDRESS OF 1ST EXPECTED DATA BYTE
;               .WORD   PMSG!BIT15      ;ADDRESS OF ERROR MSG!INDRIECT FLAG

SDCOMP: MOV     2(SP),SUBSAV    ;SAVE SUBTEST NUMBER
                
        BR      DCOMP1
$DCOMP: MOV     (SP),SUBSAV     ;SAVE SUBTEST NUMBER
DCOMP1: REGSAV                  ;SAVE REGS ON STACK
        MOV     (R5)+,R1        ;GET STARTING ADDRESS OF MASK LIST
        MOV     (R5)+,R2        ;ADDRESS OF DIAG FCN LIST
        MOV     (R5)+,R3        ;ADDRESS OBY BYTE POINTER LIST
        MOV     (R5)+,R4        ;ADDRESS OF EXPECTED DATA LIST
        MOV     R1, DCOMPM      ;SAVE INITIAL VALUE OF PTRS
        MOV     R2,  DCOMPF
        MOV     R3,DCOMPB
        MOV     R4,DCOMPX
1$:     MOVB    (R2),R0         ;PUT DIAG FCN IN R0
        BIC     #177600,R0      ;BIC THE BANNANA
        DFRD                    ;CALL TO READ EBUS

;SEQ451

;BEGIN SECTION OF CODE THAT TURNS BYTE POINT INTO REAL DATA
        MOV     R1,-(SP)        ;SAVE R1 FR AWHILE
        MOVB    (R3)+,R0        ;GET THE BYTE PONTER IN R0
        MOV     R0,R1           ;MAKE A SECOND COPY IN R1
        BIC     #177774,R0      ;GET DEXWD POINTER
        ASR     R1              ;MAKE R1 COPY WITH NO DEX PNT
        ASR     R1              ;TAKES TWO SHIFTSS
        ASL     R0              ;ADDRESS NEEDS TO BE EVEN FOR WORDS
        ADD     .DAT3,R0        ;GET RIGHT DEXWD
        MOV     (R0)+,TEMP.
        BIT     R1,#BIT3        ;TEST CROSS BOUNDARY BIT
        BEQ     2$              ;BRANCH IF FULL BYTE IN DEXWD
        MOVB    (R0),TEMP.
        SWAB    TEMP.           ;BECAUSE BYTE CROSSES DEX BOUNDARY
        BIC     #BIT3,R1        ;CLEAR CROSS BOUNDARY BIT
2$:     MOV     TEMP.,R5        ;PUT 16 EBUS ITS IN R5
        TST     R1              ;DO WE NEED TO SHIFT BITS
3$:     BEQ     4$              ;BR OUT IF NO, WITH BYTE IN R5
        ROR     R5              ;YES, SHIFT ONCE
        DEC     R1             ;DECREMENT COUNT
        BR      3$              ;LOOP

;DESIRED 8 BITS OF EBUS ARE RIGHT JUSTIFIED IN R5

4$:     MOV     (SP)+,R1        ;REPLACE R1 FROM STACK
        BICB    (R1),R5 ;MASK THE BYTE IN R5
        MOVB    (R4)+,R0        ;PUT EXPECTD IN R0
        BICB    (R1)+,R0        ;MASK OUT BITS
        CMPB    R0,R5           ;COMPARE REAL VS. EXPECTED
        BNE     6$              ;BRANCH AWAY IF BAD COMPRE
5$:     BITB    (R2)+,#BIT7    ;SEE IF DONE WITH LIST
        BNE     8$              ;IS YES BR TO DONE STUFF
        INC     IINDEX          ;OTHERWISE, INCREMENT TABLE INDEX
        BR      1$              ;GO TO NEXT LIST ELEMENT

;YOU'LL BRANCH HERE IF BAD DATA

6$:     MOV     ERSP..,R0       ;GET ERR STACK IF FIRST ERROR
        TST     ERRFG.          ;TEST IF THIS WAS FIRST ERROR
        BNE     7$              ;BRANCH IF NOT FIRST ERROR
        MOV     #FT3,(R0)+      ;LOAD STACK WITH ERROR FORMAT
        MOV     DCOMPF,(R0)+    ;LOAD BASE ADDR DIAG FCNS
        MOV     DCOMPB,(R0)+    ;LOAD BASE ADDR BYT PNT
        MOV     DCOMPM,(R0)+    ;LOAD BASE ADDR MASKED DATA
        MOV     DCOMPX,(R0)+    ;LOAD BASE EXPECTED DATA
        MOV     R0,ERRFG.       ;SET ERR FLAG TO SAY ERROR


;SEQ452

;NOW STACK TABLE INDEX AND ACTUAL RECEIVED DATA

7$:     MOVB    R5,IINDEX+1     ;PUT ACTUAAL RECEIVED IN CORE
        MOV     IINDEX,(R0)     ;PUT INDEX AZND DDATA ON STACK
        SWAB    (R0)+           ;REARRANGE
        MOV     R0,ERSP..       ;TERMINATE ERR STACK GRACEFULLY
        BR      5$              ;GO BACK TO MAINLINE


;FINISH UP CCODE

8$:     CLR     IINDEX          ;RESET INDEX COUNT
        REGRST                  ;PUT BACK REGISTERS
        TST     ERRFG.          ;WERE THERE ANY ERRORS
        BEQ     9$              ;GO FINISH IF NONE
        MOV     ERSP..,R0       ;GET ERROR STACK PTR
        BIS     #BIT15,-(R0)    ;IF THERE WERE ERRORS
        CLR     ERRFG.          ;RESET ERROR FLAG
        MOV     (SP),R0 ;PUT SUBTEST # IN R0
        ADD     #10,R5          ;MAKE R5 PONT TO THE RRROR MSG
        MOV     R5,(SP)         ;SWAP RETURN ADR FOR PTR TO ERROR MSG
        MOV     SUBSAV,R5               ;EPORT SUBTEST NR TO EXEC
        JMP     FAULT           ;TAKE ERROR RETURN TO EXEC

9$:     CLR     ERRFG.          ;CLEAR ERROR FLAG
        ADD     #12,R5          ;GO AROUND ERROR MESSAGE
        RTS     R5              ;AND RETURN

IINDEX: 0
        
ERRFG.: 0
TEMP.:  0
DCOMPF: 0                       ;STORAGE FOR POINTERS
DCOMPB: 0
        
DCOMPM:  0
DCOMPX: 0
SUBSAV: 0


;SEQ453

.SBTTL FAMOUS MCOMP -- SUBROUTINE TO MODIFY DCOMP'S TABLES

;MCOMP MODIFIES ONE OR MORE OF THE ENTRIES IN A DCOMP BYTE
;COMPARISON TABLE.  TE BASE ADDRESS OF THE DCOMP TABLE IS IN LOCAITON
;"DCOMPX" WHERE DCOMP STORES IT; IF MCOMP IS USED BEFORE THE FIRST
;DCOMP CALL, THE CALLING PROGRAM MUST STORE THIS ADDRESS.  THE CALL
;IS MADE WITH R2 POINTING AT A LOCATION CONTAINING THE NUMBER
;OF LOCATIONS TO CHANGE AND R3 POINTING TO THE FIRST ENTRY ION
;A SPECIAL MCOMP CHANGE TABLE.
;
;ENTRIES IN THE LATTER TABLE ARE "INDEX":/"NEW DATA" [AIORS.
;       FOR EXAMPLE: TO CHANGE THE 1ST BYTE IN A DCCOMP TABLE
;       TRO -5 AND THE 3RD BYTE TO 55, THE FOLLOWING CODE
;       IS NEEDED:


        

;       MOV     #TNUM,R2
;       MOV     #TADR,R3
;       JSR     R5,$MCOMP
;               .
;               .
;TNUM:  .BYTE   2
;
;TADR:  .BYTE   0               (NOTE THAT INDEX OF 1ST BYTE IS 0)
;       .BYTE   -5
;       .BYTE   2
;       .BYTE   55
;
;NOTE THAT R2=TNUM+1 AND R3=TADR+4 AFTER THIS CALL.  HENCE MCOMP LISTS
;MAY BE "CHAINED".
;
;MCOMP KEEPS A TABLE OF THE REPLACED DCOMP TALBE VALUES AT "RRSTOR"
;(UP TO A MAXIMUM OF 11) AND CAN BE FOLLOWED BY AN RCOMP CALL TO
;RESTORE THE DCOMP TABLE OT ITS PREVIOUS STATE.  SINCE REPEATED MCOMP
;CALLS REUSE THIS TABLE, VALJES RESTORED BY RCOMP WILL BE THOSE THAT
;EXISTED BEFOE THE MOST RECENT MCOMP CALL.


;SEQ454

;HERE WE GO:

$MCOMP: PUSH    <R1,R4,R5>      ;SAVE REGISTERS

;R1=# OF CHANGES LEFT TO DO, R4 WILL HOLD ADR OF DCOMP TABLE
;ENTRY BEING MODIFIED & R5 POINTS AT STORAGE TABLE.

        MOVB    (R2)+,R1        ;PUT # OF CHANGES TO BE MADE IN R1
        BEQ     2$              ;IF ZERO,DO NOTHIN'
        MOV     #RRSTOR,R5      ;GET ADDR OF STORAGE TBL
1$:     MOVB    (R3)+,R4        ;INDEX INTO DCOMP GOES IN R4
        MOVB    R4,(R5)+        ;WRITE SAME INDEX TO STORAGE TBL
        ADD     DCOMPX,R4       ;MAKE EXPECTED DATATBL ADR
        MOVB    (R4),(R5)+      ;SAVE DATA ABOUT TO CHANGE IN STORAGE TBL
        MOVB    (R3)+,(R4)      ;PUT NEW DATA INTO XPECT TBL
        DEC     R1             ;DECREMENT COUNT
        BNE     1$              ;LOOP IF MORE ELEMENTS
        MOVB    #377,(R5)       ;SET END OF STORAGE TBL FLAG
        INC     TATTLE          ;SET A FLAG FOR RCOMP
2$:     POP     <R5,R4,R1>      ;RESTORE REGISTERS


        RTS     R5              ;RETURN


TATTLE: .WORD   0               ;THE FAMOUS MCOMP/RCOMP FLAG


;SEQ455

.SBTTL FAMOUS RCOMP ROUTINE
;THE RCOMP ROUTINE IS TO "RESTORE" DATA CHANGED BY MCOMP
;ROUTINE. IT ONLY RESTORES THE EXPECTED TABLE A IT APPEARED
;BEFORE THE MOST RECENT MODIFICATION. CALL MCOMP#1; CALL MCOMP#2
;CALL MCOMP#3;CALL MCOMP#4;CALL RCOMP.  THE XPECTED TALBE WILL
;NOW LOOK AS IT DID AFTER MCOMP#3.
;
;THERE MUST HAVE BEEN A NONZERO MCOMP CLL SINCE THE LAST RCOMP
;CALL FOR RCOMP TO TAKE ANY ACTION.
;
;CALL   ;
;       JSR     R5,$RCOMP
;
;


$RCOMP: TST     TATTLE          ;HAS MCOMP DONE ANYTHING LATELY?
        BEQ     2$              ;NOPE, DON'T DO NOTHIN'


        SHOVE                   ;YUP, SAVE REGISTERS
        MOV     #RRSTOR,R1      ;GET STORAGE TBL ADDR
1$:     MOVB    (R1)+,R2        ;MOVE INDEX TO R2(SHOULD NEVER BE NEG)
        ADD     DCOMPX,R2       ;INDEX XPECTED TABLE
        MOVB    (R1)+,(R2)      ;REPLACE DATA IN EXPECTED TBL
        TSTB    (R1)            ;SEE IF END OF REPLACEMENTS
        BPL     1$              ;LOOP BACK IF NOT
        COM     RRSTOR          ;IF END PUT DONE FLAG AT FIRST TBL LOC.
        CLR     TATTLE          ;AND CLEAR MCOMP'S FLAG.
        
        GRAB                    ;RESTORE REGISTERS
2$:     RTS     R5              ;RETURN

;MCOMP CAN HANDLE 23 CHANGES

RRSTOR: .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0
        .WORD   0,0,0


;SEQ456

.SBTTL PATTY -- A SUBROUTINE TO GENERATE TEST PATTERNS

;ROUTINE TO GENERATE A COMPLETE SET OF TEST PATTERNS FOR CHECKING AN
;N-BIT WIDE DATA PATH FOR 1) NO BIT STUCK AT "0" OR "1", AND 2) NO
;TWO BITS INTERACTING.
;
;THREE INITIAL ENTRY POINTS ARE GIVEN FOR COMMON KL-10 DATA PATH
;WIDTHS OF 80, 36, AND 16 BITS.
;
;PATTERNS ARE STORED IN INVERSE BYTE FORMAT BEGINNING AT THE LOCATION
;POINTED TO BY R0 AT INITIAL ENTRY.  THE ROUTINE RETURNS THE PATTERN
;NUMBER IN R0.  IF ALL PATTERNS HAVE BEEN DONE, IT RETURNS A 0 IN R0.
;
;THE NUMBER OF PATTERNS GENERTED IS 14 FOR 80 BIT WIDTH, 12 FOR 36 BIT WIDTH,
;AND 8 FOR 16 BIT WIDTH.
;
;THE PATTERNS PRODUCED ARE:
;       1) 0001 0001 0001 ....
;       2) 0010 0010 0010 ....
;       3) 0100 0100 0100 ....
;       4) 1000 1000 1000 ....
;       5) BC BC BC BC BC BC ....

;       6) CB CB CB CB CB CB ....
;       7) BB CC BB CC BB ....
;       8) CC BB CC BB CC ....
;       9)BB BB CC CC BB ....
;    10) CC CC BB BB CC ....
;     11) BB BB BB BB CC ....
;     12) CC CC CC CC BB ....
;       13) 16 B'S AND 4 C'S 
;    14) 16 C'S AND 4 B'S
;               WHERE B = 0001 AND C = 1110
;
;INITIAL CALL:  MOV     #PTR,R0         ;PUT ADR OF 1ST BYTE TO BE FILLED IN R0
;               JSR     R5,$PAT80       ;FOR 11 BYTE PATTERNS
;       OR      JSR     R5,$PAT36       ;FOR  5 BYTE PATTERNS
;       OR      JSR,$PAT16              ;FOR  2 BYTE PATTERNS
;
;SUBSEQUENT CALLS:
;               JSR     R5,$PATCO


;SEQ457

;INITIALIZATION ENTRY  POINTS
        PNO=R2          ;NUMBER OF PATTERNS
        BNO=R0          ;NUMBER OF BYTES
        BITPNT=R4       ;BIT POINTER


;ENTRY CODE FOR MICRO RAM PATTERN
$PAT80: MOV     #^D10,BMAX      ;SET MAXIMUMWIDTH OF PATTERN
        MOV     #^D14,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY
;ENTRY CODE FOR 36 BIT PATTERN
$PAT36: MOV     #4,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS
        MOV     #^D12,PMAX      ;SET ACTUAL NUMBER OF PATTERNS
        BR      PATTY

;ENTRY CODE FOR DRAM PATTERNS

$PAT16: MOV     #1,BMAX         ;SET MAXIMUM WIDTH OF PATTERNS
        MOV     #^D8,PMAX       ;SET ACTUAL NUMBER OF PATTERNS

PATTY:  SHOVE                   ;SAVE THE REGISTERS
        ADD     BMAX,R0         ;FORM PTR TO LAST YTE
        MOV     R0,MULBUF       ;AND SAVE IN MULBUF
        MOVB    #21,PAT         ;PAT HAS BASIC PATTERN BYTE
        CLR     PNO             ;CLR PN0,NUMBER OF PATTERNS GENERATED
        MOV     #1,BITPNT       ;SET THE BIT POINTER TO BIT0
PGENRE: MOVB    PAT,COMPAT      ;COMPAT WILL HAVE THE BASIC PATTERN
        COMB    COMPAT          ;BUT IN COMPLIMENTED FORM
NOCOMP: CLR     BNO             ;CLR NUMBER OF BYTES DONE
4$:     CMP     BMAX,BNO        ;IS BNO > BMAX??
        BMI     5$              ;BRANCH OUT OF LOOP IF YES
        CMP     #6,PNO          ;DOING FIRST 6 PATTERNS?
        BGT     2$              ;BRNACH IF YES
        BIT     BITPNT,BNO      ;OUTPUT PATTERN OR COMPLIMENT?
        BEQ     2$              ;BRQANCH IF KEY BIT IN BNO IS CLEAR

;GADZOOKS, OUTPUT COMPLIMENT BYTE!
        MOVB    COMPAT,@MULBUF
        BR      3$              ;AND CONTINUE
;GADZOOKS, OUTPUT REAL BYTE!
2$:     MOVB    PAT,@MULBUF
3$:     DEC     MULBUF  
        INC     BNO             ;INCREMENT BNO FOR NEXT BYTE
        BR      4$              ;AND LOOP BACK


;SEQ458

;HERE IF DONE ONE OF THE MANY PATTERNS

5$:     INC     PNO             ;INCREMENT TO NEXT PATTERN
        MOV     R0,CORE0        ;SAVE THE CURRENT STATE OF REG'S
        MOV     R2,CORE2
        MOV     R4,CORE4
        ADD     BMAX,MULBUF
        INC     MULBUF          ;THERE WAS ONE EXTRA DEC - FIX IT UP
        MOV     PNO,MULBU1      ;SAVE PATTERN NUMBER FROM CLUTCHES OF GRAB
        GRAB
        MOV     MULBU1,R0       ;PUT PATTERN NUMBER IN R0 FOR RETURN
        RTS     R5

;YOU WILL REENTER HERE TO CONTINUE WIT ADDITIONAL PATTERNS

$PATCO: SHOVE
        MOV     CORE4,R4                ;GET MULPATS LAST STATE
        MOV     CORE2,R2
        MOV     CORE0,R0
        CMP     #3,PNO          ;IS PNO<4??
        BMI     8$              ;BRANCH IF NO
        ASLB    PAT             ;SHIFT PATTERN
        JMP     PGENRE          ;AND REENTER THE LOOP

8$:     CMP     PNO,PMAX                ;DONE ALL PATTERNS?
        BHIS    9$              ;GADZOOKS, GET THE HECK OUT HERE IF YES


;SEQ459

;PATTERNS 5 - 8 NEED SPECIAL HANDLING...DIFFERENT STROKES FOR DIFFERENT FOLKS.
        CMP     #4,PNO          ;ISTHIS PATTERN #5?
        BMI     10$             ;BRANCH IF NOT
        MOVB    #36,PAT         ;LOAD PATTERN FOR #5
        JMP     PGENRE          ;AND GO BACK
10$:    CMP     #5,PNO          ;IS THIS PATTERN #6?
        BMI     11$             ;BRANCH IF NOT
        MOVB    #341,PAT        ;LOAD PATTERN FOR #6
        JMP     PGENRE          ;AND GO BACK
11$:    CMP     #6,PNO  ;IS THIS PATTERN #7?
        BMI     12$             ;BRANCH IF NOT
        MOV     #10756,PAT      ;SET PAT = 356, COMPAT = 21 FOR REST OF PATTERNS
12$:    SWAB    PAT             ;EXCHANGE PATTERN AND COMPLIMENT OF PATTERN
        CMP     #7,PNO          ;ARE WE DOING 7 AND 8

        BGE     NOCOMP          ;IF SO, TAKE A SHORT CUT
        BIT     #BIT0,PNO       ;TEST BIT 0 OF PNO, BR IF ODD
        BNE     PGENRE
        ASL     BITPNT          ;SHIFT BIT POINTER IF EVEN
        JMP     PGENRE          ;AND RETURN TO THE GIG LOOP

9$:     GRAB
        CLR     R0
        RTS     R5

;PLACES TO SQUIRREL AWAY STUFF:

BMAX:   0
PMAX:   0
PAT:    .BYTE   0
COMPAT: .BYTE   0
CORE0:  0
CORE2:  0
CORE4:  0
MULBUF: 0
MULBU1: 0






;SEQ481

.SBTTL  CTLMCR -- CONTROL LOGIC MODIFY-COMPARE-RESTORE

;THIS SUBROUTINE, USED BY MOST OF THE CONTROL BOARD TESTS, PERFORMS THE
;FOLLOWING SEQUENCE:
;       1) MODIFY THE CONTROL BOARD EXPECTED DATA TABLE AS SPECIFIED BY
        ;  R2 & R3 USING MCOMP
;       2)DO A COMPARISON USING DCOMP AND THE COMMON CONTROL BOARD TABLES
;       3) RESTORE EXPECTED DATA TABLE TO PREVIOUS VALUES USING RCOMP
;
;ON ENTRY:  R2 POINTS TO THE NUMBER OF EXPECTED DATA TABLE CHANGES REQURIED
;           R3 POINTS TO THE FIRST MCOMP "NEW DATA/INDEX" PAIR
;
;       CALL:   JSR     R5,$CTLMC

$CTLMC: MOV     #CTLDAT,DCOMPX  ;SET CONTROL BOARDS EXPECTED DATA TABLE ADDRESS
        JSR     R5,$MCOMP       ;MODIFY EXPECTED DATA TABLE

;SUBROUTINE TO DO A MERE DCOMP WITH NOTHIN SEXY
$CTLCM: JSR     R5,SDCOMP               ;BYTE TABLE COMPARE
        .WORD   CTLMSK
        .WORD   CTLFUN
        .WORD   CTLBYT
        .WORD   CTLDAT
BOGEY:  .WORD   0

        JSR     R5,$RCOMP               ;RESTORE DATA
        RTS     R5              ;AND RETURN

;SEQ464

;HERE ARE THE DCOMP TABLES FOR THE CONTROL LOGIC:
CTLMSK: .BLKB   44              ;STORAGE FOR MASKS (FILLED IN BY ICON)

CTLFUN: .BYTE   RAPR            ;DIAGNOSTIC FUNCTION FOR INDEX 0
        .BYTE   RAPR+1          ;1
        .BYTE   RAPR+4          ;2

        .BYTE   RAPR+5          ;3
        .BYTE   RAPR+2          ;4
        .BYTE   RAPR+3          ;5
        .BYTE   RAPR+6          ;6
        .BYTE   RAPR+7          ;7
        .BYTE   RAPR            ;10
        .BYTE   RAPR+1          ;11
        .BYTE   RAPR+4          ;12
        .BYTE   RAPR+5          ;13

        .BYTE   RCON            ;14
        .BYTE   RCON+1          ;15
        .BYTE   RCON+2          ;16
        .BYTE   RCON+3          ;17
        .BYTE   RCON+4          ;20
        .BYTE   RCON+5          ;21
        .BYTE   RCON+6          ;22
        .BYTE   RCON+7          ;23

        .BYTE   RMCL            ;24
        .BYTE   RMCL+1          ;25
        .BYTE   RMCL+2          ;26
        .BYTE   RMCL+3          ;27
        .BYTE   RMCL+4          ;30
        .BYTE   RMCL+5          ;31
        .BYTE   RMCL+6          ;32
        .BYTE   RMCL+7          ;33

        .BYTE   RCTL            ;34
        .BYTE   RCTL+1          ;35
        .BYTE   RCTL+2          ;36
        .BYTE   RCTL+3          ;37
        .BYTE   RCTL+4          ;40
        .BYTE   RCTL+5          ;41
        .BYTE   RCTL+6          ;42
        .BYTE   RCTL+7!BIT7     ;43


;SEQ465

CTLBYT: BYTPNT  8       ;EBUS BYTE FOR INDEX 0
        BYTPNT  9               ;1
        BYTPNT  9       ;2
        BYTPNT  9       ;3

        BYTPNT  13      ;4
        BYTPNT  13      ;5
        BYTPNT  13      ;6
        BYTPNT  13      ;7
        BYTPNT  16      ;10
        BYTPNT  17      ;11
        BYTPNT  17      ;12
        BYTPNT  17      ;13



        .REPT   10      ;INDEXES 14-23
        BYTPNT  24
        .ENDR


;SEQ466

        .REPT   10              ;INDEXES 24-33
        BYTPNT  23
        .ENDR
 
 
 
 
 
 
 
 
 
        .REPT   10              ;INDEXES 34-43
        BYTPNT  31
        .ENDR
 
 
 
 
 
 
 
 
 

CTLDAT: .BLKB   44              ;STORAGE FOR EXPECTED DATA


 

;SEQ467

.SBTTL  *ROUTINES WHICH ALTER BYTES IN THE CONTROL LOGIC TABLES*

;CALLS: 
;       JSR     R5,$MEMRQ               ;EXPECT MEMORY REQUEST BYTES TRUE

;       JSR     R5,$NOMRQ               ;RESTORE TO NO MEMORY REQUEST STATUS

;       JSR     R5,$NOCO                ;EXPECT "-CON COND EN 00-07" FALSE

$MEMRQ: MOVB    #112,CTLDAT+17  ;EXPECT "-CON MEM CYCLE"TRUE
        CLRB    CTLDAT+27               ;EXPECT "-MCL REQ EN" TRUE
        MOVB    #67,CTLDAT+33           ;EXPTECT :MCL MBOX CYCLE REQ" TRUE
        RTS     R5              ;DONE, RETURN.

$NOMRQ: MOVB    #113,CTLDAT+17          ;EXPECT "-CON MEMCYCLE" FALSE
        MOVB    #20,CTLDAT+27           ;EXPECT "-MCL REQ EN" FALSE
        MOVB    #65,CTLDAT+33   ;EXPECT "MCL MBOX CYCLE REQ" FALSE
        RTS     R5              ;DONE,R ETURN


$NOC0:
        MOVB    #174,CTLDAT+16          ;EXPECT "-CON COND EN 00-07"FALSE
        RTS     R5              ;DONE, RETURN




;SEQ486

.SBTTL          FLGMCR -- PC FLAG LOGIC MODIFY-COMPARE-RESTORE

;THIS ROUTINE WORKS LIKE CTLMCR FOR PC FLAG LOGIC ON SCD BOARD.

$FLGMC: MOV     #BLAM,DCOMPX    ;SET DCOMP'S PTR TO SCD BOARD.
        $MCOMP

;SUBROUTINE TO COMPARE PC FLAG SIGNALS ON SCD BOARD:

$FLGCM: JSR     R5,SDCOMP       ;BYTE TABLE COMPRE ROUTINE
        .WORD   BIFF            ;MASK TABLE
        .WORD   POW             ;FUNCTION TABLE
        .WORD   SOCK            ;BYTE TABLE
        .WORD   BLAM            ;EXPECTED DATA TABLE
$FLGEM: .WORD   0               ;ERROR MSG PTR GOES HERE

        $RCOMP
        RTS     R5              ;RETURN.


;SEQ471

;DCOMP TABLES FOR PC FLAGS:

BIFF:   .BYTE   7               ;MASKS
        .BYTE   7
        .BYTE   7
        .BYTE   7
        .BYTE   17
        .BYTE   7
        .BYTE   7
        .BYTE   3

POW:    .BYTE   RSCAD           ;DIAGNOSTIC FUNCTIONS
        .BYTE   RSCAD+1
        .BYTE   RSCAD+2
        .BYTE   RSCAD+3
        .BYTE   RSCAD+4
        .BYTE   RSCAD+5
        .BYTE   RSCAD+6
        .BYTE   RSCAD+7!BIT7

SOCK:   .REPT   10              ;EBUS BIT TO POSITION BYTE ON
        BYTPNT  9
        .ENDR

BLAM:   .BLKB   10

        .EVEN


;SEQ472

.SBTTL          SCDMCR -- SC LOGIC MODIFY-COMPARE-RESTORE

;THIS ROUTINE DOES A STANDARD COMPARISON OF THE SC AND FE REGISTERS,
;THE UPPER 8 BITS OF THE AR, AND A FEW OCNTROL SIGNALS AGAINST
;A MODIFIED EXPECTED DATA TABLE USING SUBROUTINES MCOMP,DCOMP,
;AND RCOMP.  IT IS SIMILAR TO CTLMCR AND REGISTER AND CALLING
;CONVENTIONS ARE THE SAME.

$SCDMC: MOV     #SCDDAT,DCOMPX  ;SET COMPARIOSN ROUTINE'S PTR TO SCD DATA
        JSR     R5,$MCOMP       ;MODIFY THE SCD'S EXPECTED DATA TABLE.

;ENTER HERE TO COMPARE AGAINST EXPECTED DATA WITHOUT MODIFICATION:

$SCDCM: JSR     R5,SDCOMP               ;DO THE COMPARIOSN USING DCOMP
        .WORD   SCDMSK          ;PTR TO MASK TABLE
        .WORD   SCDFUN          ;PTR TO DIAGNOSTIC FUNCTION TABLE
        .WORD   SCDBYT          ;PTR TO EBUS BYTE SELECTOR TABLE
        .WORD   SCDDAT          ;PTR TOE XPECTED DATA TABLE
$SCDEM: .WORD   0               ;SPACE FOR PTR TO ERROR MSG

        JSR     R5,$RCOMP       ;RESTORE EXPECTED DATA TABLE, IF MODIFIED.
        RTS     R5              ;RETURN

;THE 10-BIT ARITHMEITC DCOMP TABLES:


SCDMSK: .BYTE   7               ;READ SC05-SC09, LEFT JUSTIFIED
        .BYTE   340             ;READ SC00-SC04,RIGHT JUSTIFIED
        .BYTE   7               ;READFE05-FE09, LEFT JUSTIFIED
        .BYTE   340             ;READ FE-00-FE04, RIGHT JUSTIFIED
        .BYTE   17              ;READ AR05-AR08, LEFT JUSTIFIED
        .BYTE   340             ;READ AR00-AR04, RIGHT JUSTIFIED
        .BYTE   376             ;READ "SC SIGN", RIGHT JUSTIFIED
        .BYTE   376             ;READ "SC.GE.36", RIGHT JUSTIFIED
        .BYTE   376             ;READ "FE SIGN", RIGHT JUSTIFIED
        .BYTE   376             ;READ "-SCAD=0",RIGHT JUSTIFIED

SCDFUN: .BYTE    130             ;0: DIAGNOSTIC FUNCTIONS
        .BYTE   131             ;1
        .BYTE   132             ;2
        .BYTE   133             ;3
        .BYTE   120             ;4
        .BYTE   120             ;5
        .BYTE   134             ;6
        .BYTE   136             ;7
        .BYTE   135             ;10
        .BYTE   133!BIT7                ;11 (WITH STOP BIT SET)


;SEQ473

SCDBYT: BYTPNT  14              ;0:EBUS BYTE POINTERS
        BYTPNT  11              ;1
        BYTPNT  14              ;2
        BYTPNT  11              ;3
        BYTPNT  12              ;4
        BYTPNT  4               ;5
        BYTPNT  7               ;6
        BYTPNT  7               ;7
        BYTPNT  7               ;10
        BYTPNT  4               ;11

SCDDAT: .WORD   0,0,0,0,0       ;STORAGE FOR EXPECTED DATA
        .EVEN
.SBTTL          PI.CH -- PI BOARD MODIFY-COMPARE-RESTORE

$PI.CH: JSR     R5,SDCOMP       ;CALL FOR A COMPARE
        .WORD   PIZMSK ;MASK LIST
        .WORD   PIZFUN          ;DIAGNOSTIC FUNCTION LIST
        .WORD   PIZBYT          ;BYT POINTERS
        .WORD   PIZEXP          ;LIST OF EXPECTED
PIZZA.PI:       .WORD   0               ;ERROR MESSAGE
        RTS     R5              ;DONE

PIZFUN: .BYTE   100             ;+0
        .BYTE   100             ;+1
        .BYTE   101             ;+2
        .BYTE   102             ;+3
        .BYTE   103             ;+4
        .BYTE   136             ;+5
        .BYTE   137             ;+6
        .BYTE   110             ;+7
        .BYTE   137             ;+10
        .BYTE   116             ;+11
        .BYTE   117             ;+12

PIZBYT: BYTPNT  9               ;+0
        BYTPNT  17              ;+1
        BYTPNT  17              ;+2
        BYTPNT  17              ;+3
        BYTPNT  17              ;+4


;SEQ474

        BYTPNT  5               ;+5
        BYTPNT  6               ;+6
        BYTPNT  17              ;+7
        BYTPNT  23              ;+10
        BYTPNT  35              ;+11
        BYTPNT  23              ;+12
        

;SEQ475

PIZMSK: .BYTE   200             ;+0
        .BYTE   0               ;+1
        .BYTE   200             ;+2
        .BYTE   200             ;+3
        .BYTE   200             ;+4
        .BYTE   371             ;+5
        .BYTE   367             ;+6 PI1
        .BYTE   370             ;+7
        .BYTE   375             ;=10
        .BYTE   370             ;+11
        .BYTE   361             ;+12

PIZEXP: .BYTE   0               ;+0"PIH1-PIH7"
        .BYTE   0               ;+1 "PI ACTIVE" & "PI ON1-0N7"
        .BYTE   0               ;+2 "PI GEN1-GEN7"
        .BYTE   0               ;+3 "PI2,PI1,EBUS DEMAND, SEL PHY 8,4,2,1"
        .BYTE   20              ;+4 "TIMER DONE,PI GRAN,STATE HOLD,PI4, HONOR INTERNAL"
                                ;       "PI READY,EBUS REQ"
        .BYTE   0               ;+5 "SCAD MIXERS-PI4,PI2"
        .BYTE   0               ;+6 "SCAD MIXERS-PI1"
        .BYTE   0               ;+7 "APR PIA4,PIA2,PIA1"
        .BYTE   0               ;+10 "CON COND ADR 10--SELECTS CP GRANT & PI XFER"
        .BYTE   0               ;+11 "MTR PIA4, PIA2,PIA1"
        .BYTE   0               ;+12 "MTR VECTOR HONOR,MTR INC SEL2, INC SEL1"
        .EVEN

;SEQ476

.SBTTL          PARCH -- PARITY LOGIC MODIFY-COMPARE-RESTORE

;ROUTINE TO PERFORM AN MCOMP,DCOMP,THEN RCOMP CHECK OF
;ALL CONTROL SIGNALS RELEVANT TO THE PARITY CIRCUITRY IN THE
;EBOX.

$PARCH: $MCOMP                  ;FIRST, MODIFY EXPECTED DATA
        JSR     R5,SDCOMP       ;GO TO DCOMP TO DO THE OCMPARE
        .WORD   PARMSK          ;LIST OF MASKS
        .WORD   PARFUN          ;LIST OF DIAGNOSTIC FUNCTIONS
        .WORD   PARBYT          ;LIST OF BYTE POINTERS
        .WORD   PAREXP          ;LIST OF EXPECTED
$PARMS: .WORD   0               ;POINTER TO ERROR MESSAGE
        $RCOMP                  ;RESTORE TABLE
        RTS     R5              ;RETURN

PARFUN: .BYTE   130             ;+0
        .BYTE   104             ;+1
        .BYTE   106             ;+2
        .BYTE   105             ;+3
        .BYTE   114             ;+4
        .BYTE   107             ;+5
        .BYTE   134             ;+6
        .BYTE   136             ;+7
        .BYTE   137             ;+10
        .BYTE   132             ;+11
        .BYTE   133!BIT7        ;+12

PARBYT: BYTPNT  19              ;+0
        BYTPNT  35              ;+1
        BYTPNT  35              ;+2
        BYTPNT  35              ;+3
        BYTPNT  17              ;+4
        BYTPNT  35              ;+5
        BYTPNT  26              ;+6
        BYTPNT  25              ;+7
        BYTPNT  25              ;+10
        BYTPNT  29              ;+11
        BYTPNT  29              ;+12


;SEQ477

PARMSK: .BYTE   376             ;+0 - "WR EVEN PAR DATA H"
        .BYTE   375             ;+1-"CLK FM PAR CHECK L"
        .BYTE   356             ;+2-"ARX PAR ODD & CLK AR/ARX PAR CHECK L"
        .BYTE   317             ;+3-"CLK FM PAR ERR & AR PAR ODD"
        .BYTE   374             ;+4-"APR FM 36 & APR FM ODD PARITY"
        .BYTE   317             ;+5"CLK ERROR L & CLK PAGE FAIL"
        .BYTE   373             ;+6-"CON FM WRITE PAR L"
        .BYTE   175             ;+7-"CON AR 36 & CON FM XFER L"
        .BYTE   177             ;+10-"CON ARX 36"
        .BYTE   277             ;+11-"CON AR LOADED"
        .BYTE   277             ;+12-"CON ARX LOADED L"

;RESET & NORMAL STATE OF PARITY SIGNALS
PAREXP: .BYTE   0               ;+0
        .BYTE   2               ;+1
        .BYTE   1               ;+2
        .BYTE   0               ;+3
        .BYTE   0               ;+4
        .BYTE   40              ;+5
        .BYTE   4               ;+6
        .BYTE   2               ;+7
        .BYTE   0               ;+10
        .BYTE   0               ;+11
        .BYTE   100             ;+12

        .EVEN


;SEQ478

.SBTTL  AR2SC -- SUBROUTINE TO MAKE SC EXPECTED DATA

;THIS ROUTINE CHANGES THE EXPECTED DDATA IN THE SCD BOARD COMPARE
;TABLE (SCDDAT) FOR A TRANSFER FROM AR SHIFT (AR BIT 18 AND BIT
;28 TO 35).  THE INPUT DATA IS ASSUMED TO BE IN THE 36-BIT BUFFER,
;EWORD2, AND THE BYTES CONTAINING SC 0-9, SC SIGN AND SC.GE.36
;ARE MODIFIED.  BUFFER EWORD2 IS USED AND AN ALTERNATE ENTRY IS
;PROVIDED FOR ASSUMING THAT EWORD1 CONTAINS THE COMPLIMENT OF
;THE DESIRED DATA.

;CALL:  JSR     R5,$AR2SC       ;ALTER SC EXPECTED DATA (AR=EWORD1)
;OR:    JSR     R5,$CA2SC       ;ALTER SC EXPECTED DATA (AR=EWORD1)

$AR2SC: $MOVWD  EWORD1,EWORD2   ;COPY 1ST BUFFER TO 2ND
        BR      AR2ST           ;AND BEGIN.

$CA2SC: $COMWD          ;COPY COMPLIMENT OF 1ST BUFFER TO 2ND
AR2ST:  SHOVE                   ;SAVE REGISTERS

        MOV     #EWORD2,R1      ;R1 GETS PTR TO 36-BIT BUFFER (DATA).
        MOV     #SCDDAT,R2      ;R2 PTS TO SC BYTES IN EXPECTED TABLE.
        MOV     #SCDDAT+6,R3    ;R3 PTS TO SC SIGN BYTE IN TABLE.
        MOV     R2,R4           ;GET 2ND COPY OF SC DATA PTR.

        MOV     (R1)+,(R2)+     ;COPY AR BITS 20-35 INTO SC BYTES.
        CLRB    -(R2)           ;CLEAR UPPER BYTE OF EXPECTED DATA
        CLRB    (R3)            ;AND "SC SIGN" BYTE.
        BIT     #2,(R1)         ;SEE IF AR BIT 18 IS SET.
        BEQ     2$              ;LEAVE SC BITS ALONE IF NOT.

        COMB    (R2)            ;OTHERWISE, SET UPPER BYTE TO 1'S
        INCB    (R3)            ;AND SET SIGN BIT IN EXPECTED


;SEQ479

2$:     INC     R3              ;NOW POINT AT BYTE WITH "SC.GE.36"
        CLRB    (R3)            ;START WITH SC.GE.36 CCLEARED
        ASL     (R4)            ;SHIFT SC DATA SO THAT SC 0-3
        ASL     (R4)            ;AEE IN UPPER BYTE OF EXPECTED.
        TSTB    (R2)            ;SEE IF ANY OF THOSE BITS ARE SET.
        BNE     3$              ;GO SET SC.GE.36 IF SO.

        TSTB    (R4)            ;SEE IF SC4 IS SET.
        BGE     4$              ;LEAVE SC.GE.36 CLEARED IF NOT
        
        BITB    #160,(R4)       ;IF IT IS, SEE IF SC 5,6 OR 7 IS SET.
        BEQ     4$              ;LEAVE SC.GE.36 CLEARED IF NOT

3$:     INCB    (R3)            ;SET SC.GE.36.
4$:     ASL     (R4)            ;SHIFT AC DATA INTO ITS FINAL POSITION
        GRAB                    ;RESTORE REGISTERS
        RTS     R5              ;AND RETURN.


;SEQ480

.SBTTL $ACREF -- SUBROUTINE WHICH SETS OR CLEARS THE VMA

;IF SR0 IS 0 UPON ENTRY, AC REGS ARE PREVENTED. OTHERWISE THEY ARE
;ASSURED.

;       CALL:   CLR     R0              ;
        
;                       JSR     R5,$ACREF               ;PREVENT AC REFERENCES

;       OR:     MOV     #-1,R0
;               JSR     R5,$ACREF       ;ASSURE AC REFERENCES

;       NOTE:THIS ROUTINE LEAVES AR,CR, $MICRO, AND EWORD1 CLEARED.
;       (HENCETHIS IS A GOOD ROUTINE TO START OFF WITH.)

$ACREF: MOV     R1,-(SP)        ;SAVE R1
        MOV     R0,-(SP)        ;SAVE KEY
        MOV     #EWORD1,R1              ;PTR TO DATA
        CLEAR                   ;CLEAR MACHINE

        $CLRWD  EWORD1          ;CLEAR 36-BIT BUFFER
        $CLRMI  $MICRO          ;AND MICROWORD BUFFER

        TST     (SP)+           ;LOOK AT KEY
        BNE     ACRF1           ;GO AROUND IF NOT ZERO

        MOV     #-1,(R1)                ;ZERO, SET SOME BUFFER BUTS


;SEQ481

ACRF1:  MOV     #LDAR,R0        ;GET SET TO LOAD THE AR
        DFWRT                   ;DO IT

        $VMA    3               ;SET UP TO LOAD VMA/AD
        $AD     37,0,0          ;AD/A, ADA/AR
        $AR     3,0             ;AR/EBUS
        $MWORD                  ;WRITE BUFFER TO CR
        $CLRWD  EWORD1          ;RECLEAR BUFFERS
        $CLRMI  $MICRO  
        $MWORD                  ;CLOCK DATA TO VMA, AR/0, CR/0
        MOV     #LDAR,R0        ;LEAVE AR CLEARED
        DFWRT
        MOV     (SP)+,R1        ;RESTORE R1
        RTS     R5              ;RETURN


;SEQ482

.SBTTL CRADRD: THE NEXT ADDRESS BOARD REGISTER READER
;SUBROUTINE TO READ ONE OF 3 REGISTERS ON THE CRA BOARD AND RETURN
;THE 11 BIT RESULT, RIGHT JUSTIFIED, IN REGISTER R0
;FIRST PASS THE DESIRED REGISTER'S DIAGNOSTIC FUNCTION IN R0, THEN JSR.
;       MOV     #DIAGFCN,R0
;       CRADRD

$CRADRD:        PUSH    <R1,R0>         ;SAVE SOME REGISTERS

        MOV     #EWORD1,R1              ;READ AND SAVE DATA AT EWORD1
        DFRDMV          ;FUNCTION WAS ALREADY IN R0
        MOVB    EWORD1+3,DSAVE  ;MUST SAVE CRA REGISTER
        MOVB    EWORD1+4,DSAVE+1        ;00 THRU 04
        POP     R0              ;GET DIAG FCN BACK

        DEC     R0              ;DIAG FCN MUST BE LESS ONE FOR BITS 5-10
        MOV     #EWORD1,R1      ;PUT SECOND READ IN EWORD
        DFRDMV                  ;READ SECOND HALF CRA REGISTER

        ROLB    EWORD1+3        ;ALMOST JUSTIFY THE DATA (EBUS 0-5)
        ROLB    EWORD1+4        ;ON ABYTE BOUNDARY
        ROLB    EWORD1+3                ;FINISH JUSTIFYING THE DATA (EBUS 0-5)
        ROLB    EWORD1+4                ;ON A BYTE BOUNDARY (EWORD1+4)


        BICB    #174077,DSAVE   ;CLEAR A PLACE FOR REG BITS 5-10
        BISB    EWORD1+4,DSAVE  ;SET REG BITS 5-10

        MOV     DSAVE,R0                ;GET FINAL REGISTER RESULTS
        POP     <R1>            ;FIX STACK

        RTS     R5              ;ALL DONE


;SEQ483

.SBTTL DATCOM,DATODD, DATEVE -- SUBROUTINE TO WRITE DRAM DATA

$DATCOM:        MOV     #LDRAM3,R0      ;GET DIAG FUN TO WRITE COMMON
        ASL     R1              ;JUSTIFY DATA FOR THE EBUS
        ASL     R1              
        BR      CON2            ;GO WRITE IT

$DATODD:        MOV     #LDRAM2,$DDRMS  ;FUNCTION FOR J-FIELD A& B
        MOV     #LDRJOD,R0      ;FUNCTION FOR J-FIELD ODD
        BR      CON1            ;GO
$DATEVE:        MOV     #LDRAM1,$DDRMS  ;FUNCITON FOR J-FIELD A & B
        MOV     #LDRJEV,R0      ;FUNCTION J-FIELD EVEN
CON1:   ASL     R1              ;JUSTIFY FPIECE I'M
        ASL     R1              ;INTERESTED IN FOR J-DATA FIELDS
        PUSH    R1              ;SAVEW DATA TO BE SENT

        JSR     R5,CON2         ;WRITE J-DATA
        POP     R1             ;GET DATA AGAIN

        SWAB    R1              ;NOW I'VE GOT A & B
        MOV     $DDRMS,R0       ;GET CORRECT DIAG FUNCTION, & WRITE

CON2:   MOVB    R1,DDRAM+2      ;R1 ALWAYS HAS THE DATA
        MOV     #DDRAM,R1       ;I ALWAYS PUT IT IN DDRAM
        DFWRT
        RTS     R5              ;NOW WRITE


;SEQ484
.SBTTL GLOWRM -- ROUTINE TO LOAD THE DRAM FROM TABLE

;ROUTINE TOG ET DATA FROM A SIMPLE TABLE AND WRITE THAT
;DATA TO THE DRAM WITHOUT CLOCKING THE EBOX ND MUCKING THINGS UP

GLOWRM: MOVB    (R4)+,EWORD1    ;J7-10
        MOVB    (R4)+,EWORD1+1  ;A & B FIELDS
        MOV     EWORD1,R1       ;DATA TO EVEN
        DATEVE
        MOV     EWORD1,R1               ;DATA TO ODD
        DATODD
        MOVB    (R4)+,R1        ;DATA TO COMMON
        DATCOM
        DFXCTT
        DRLTCH
        RTS     PC

.SBTTL ERS16D -- SUBROUTINE TO STACK 16-BIT ERRORS

;SUBROUTINES TO STACK 16-BIT ERROR DATA ON THE ERROR STACK
;ROUTINE EXPECTS R3=ACTUAL MASK, R2 POINTS TO ACTUAL RECEIVED DATA
;AND R4 POINTS TO EXPECTED DATA.

ERS16D: MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;STACK FORMAT TYPE
        MOV     R3,(R0)+        ;STACK MASK
        MOV     (R2),(R0)+      ;STACK ACTUAL RECEIVED
        MOV     (R4),(R0)+      ;STACK EXPECTED
        MOV     R0,ERSP..       ;RETURN STAKC POINTER
        RTS     PC              ;DONE


;SEQ485

.SBTTL RDPSEC -- ROUTINE FOR READING PREVIOUS SECTION REG

;SPECIAL ROUTINE FOR REDING THE PREVIOUS SECTION REGISTER
;PLUS THE PCS SECTION 0 BIT.. DATA IS RETURNED IN R0 WITH 6 VITS
;RIGHT JUSTIFIED..PREV SEC 13-17 THE 5 RIGHT-MOST BITS
;AND PCS SECTION 0 IS THE SIXTH BIT..
;*              *               * PREV  * PREV  * PREV  * PREV  * PREV  *
;* MASKED BITS *-PCS SECTION 0* SEC 13* SEC 14* SEC 15* SEC 16* SEC 17*

;CALL:  JSR     PC,RDPSEC

RDPSEC: CLR     TVPSEC          ;CLEAR A TEMP CORE LOCATION
        PUSH    R1              ;AND SAVE REGISTER R1

        PUSH    #160            ;PUSH FIRST DAIG FUNC PLUS 1 ONTO STACK

        MOV     #152,R0         ;GET DIAG FUNC TO READ "PCS SECTIOON )"
        MOV     #2$,R1          ;PLACE TO PUT THE READ DATA

1$:     DFRDMV                  ;DO FUNCTION EAD OF VMA BOARD

        MOVB    2$+3,R0         ;GET BITS 4-11
        BIC     #177776,R0      ;LEAVE ONLY BIT 11
        ASL     TVPSEC          ;SHIFT ACCUMULATED DATA
        BIS     R0,TVPSEC       ;SAVE ADDITIONAL BIT OF DATA
        DEC     (SP)            ;ADVAN E TO NEXT DIAG FUNC
        MOV     (SP),R0 ;AND PUT IT INTO R0
        CMP     #152,R0         ;DONE ALL YET??
        BNE     1$              ;BACK IF NOT YET

;FALL TO HERE IF ALL DONE
        POP     R0              ;CLR DIAG FUNC FROM STACK

        POP     R1              ;RESTORE R1

        MOV     TVPSEC,R0               ;GET RESULTS TO R0
        RTS     PC              ;AND RETURN

2$:     WD36    0,0,0           ;TEMP STORAGE LOCATION
        .EVEN           ;STAY CLEAN
TVPSEC: .WORD   0               ;TEMP LCOATION TO BUILD PREV SEC DATA

;SEQ502

.SBTTL EDPTST --  ROUTINE TO PERFORM DATA PATH TESTING

EDPTST: PUSH    <R5,R1>         ;SAVE R5,R1

        CLR     R5              ;OUT WITH THE BAD
        CLR     ERRCNT          ;NO ERRORS YET
        BR      3$              ;CONT

;BASIC LOOP TO GET EXPECTED DATA AND DO A COMPARE

2$:     TSTB    EDPLST-1(R5)    ;TEST AND QUIT IF ITS NEGATIVWE
        BPL     3$              ;IF PLUS

;YOU HAD ALL COMPARES OK IF HERE

        POP     <R1,R5>         ;GIVE REGS BACK

        MOV     ERRCNT,R0
        BEQ     1$

        SEC
        RTS     PC
1$:     CLC
        RTS     PC              ;RETRN MAINLINE
3$:     INC     R5              ;UPDATE DIAG FCN LIST PTR
        MOVB    (R4)+,R0        ;GET THE INDEX INTO EXPECTED ATA
        BMI     2$              ;IF IT WAS NEGATIVE, NO COMPARE
        MOV     EDPINX(R0),100$;PUT ACTUAL POINT TO EXPECTED IN R0


;SEQ503

;NOW READ THE DATA


        CLR     R0
        BISB    EDPLST-1(R5),R0 ;GET DIAG FUNCTION
        MOV     #EWORD1,R1      ;STORE IT HERE
        DFRDMV                  ;READ AND PUT IT THERE NOW

        M36T                    ;COMPARE RESULTS WITH EXPECTED
        .WORD   ZERO
100$:   .WORD   0               ;EXPECTED ADDRESS GOES HERE
        .WORD   EWORD1          ;ADDRESS OF ACTUAAL
        BCC     2$              ;CONTINUE IF NO ERROR

;ERROR REPORTING
        PUSH    R5
        DEC     R5              ;MAKE R5 INDEX COUNT FROM 0
        ASL     R5              ;INDEX BY WORD
        MOV     REGNAM(R5),R0   ;GET PTR TO REG NAME

;WE MUST FIRST ISSUE A MESSAGE TO INDICATE WHICH REGISTER FAILED

        JSR     PC,(R0)         ;GO PRINT BAD REGISTER NAME
        ERRMSG  < CONTAINS BAD DATA\\>  ;PLUS THIS MESSAGE
 

        INC     ERRCNT          ;REMEMBER # OF ERRORS
        POP     R5              ;RETRIEVE CORRECT R5

        BR      2$              ;AND CHECK THE OTHER REEGISTERS


;SEQ504

EDPLST: .BYTE   DPAR            ;FUNCTION TO READ AR
        .BYTE   DPBR            ;FUNCTION TO READ BR
        .BYTE   DPAD            ;FUNCTION TO READ AD
        .BYTE   DPARX           ;FUNCTION TO READ ARX
        .BYTE   DPBRX           ;FUNCTION TO READ BRX
        .BYTE   DPADX           ;FUNCTION TO READ ADX
        .BYTE   DPMQ            ;FUNCTION TO READ MQ
        .BYTE   DPFM!BIT7               ;FUNCTION TOR EAD FM
        .EVEN

EDPINX: .WORD   ZERO            ;ADDRESS OF 36 BITRS OF 0'S
        .WORD   ONES            ;ADDRESS OF 36 BITS OF 1'S
        .WORD   PATN            ;ADDRESS OF PATTERN 0
        .WORD   PATN1           ;ADDRESS OF PATTERN 1
        .WORD   PATN2           ;ADDRESS OF PATTERN 2
        .WORD   PATN3           ;ADDRESS OF PATTERN 3
        .WORD   PATN4           ;ADDRESS OF PATTERN 4
        .WORD   NY6             ;ADDRESS OF PATTERN 5
        .WORD   NY7             ;ADDRESS OF PATTERN 6
        .WORD   NY8             ;ADDRESS OF PATTERN 7

;LIST OF POINTERS TO REGISTER NAMES:

REGNAM: .WORD   DP.AR
        .WORD   DP.BR
        .WORD   DP.AD
        .WORD   DP.ARX
        .WORD   DP.BRX
        .WORD   DP.ADX
        .WORD   DP.MQ
        .WORD   DP.FM


;SEQ505


DP.AR:
EDPERR: ERRMSG<AR>              ;AR ERROR MESSAGE
        RTS     PC
DP.BR:  ERRMSG<BR>              ;BR ERROR MESSAGE
        RTS     PC
DP.AD:  ERRMSG<AD>              ;AD ERROR MESSAGE
        RTS     PC
DP.ARX: ERRMSG<ARX>             ;ARX ERROR MESSAGE
        RTS     PC              
DP.BRX: ERRMSG<BRX>             ;BRX ERROR MESSAGE
        RTS     PC
DP.ADX: ERRMSG<ADX>             ;ADX ERROR MESSAGE
        RTS     PC
DP.MQ:  ERRMSG<MQ>              ;MQ ERROE MESSAGE
        RTS     PC
DP.FM:  ERRMSG<FM>              ;FM ERROR MESSAGE
        RTS     PC
PATN:   .BLKB   5               ;PATTER 0
PATN1:  .BLKB   5               ;PATTERN 1
PATN2:  .BLKB   5               ;PATTERN 2
PATN3:  .BLKB   5               ;PATTERN 3
PATN4:  .BLKB   5               ;PATTERN 4
.EVEN


;SEQ506

.SBTTL ROUTINE TO GET EBOX MICRO-CODE INTO C-RAM

LODMIC: TSTB    CONSOL-2                ;POWER UP AND DOWN??
        BEQ     4$              ;BR IF YES & NEED TO LOAD MIC-CODE
3$:     RTS     PC

;HERE IF FILE NOT IN CORE

4$:     PFORCE
        PMSG<\EBOX DIAGNOSTIC MICRO-CODE IS LOADING\>
        PNORML
        MOV     #PCMD,R0        ;GET PROGRAM COMMAND
        PRGCMD                  ;CONSOLE EXECUTE
        BCS     LODERR          ;ERROR IN LOADING FILE??
        CLR     JUSLDD          ;OK TO SAY RAM CODE LOADED
        COMB    CONSOL-2        ;TELL CONSOL TOO
        RTS     PC              ;GET OUT
LODERR:        PFORCE
        PMSG<\FILE: "EBOX>
 
        PMSG<B>

        PMSG<.RAM" NOT FOUND\TEST ABORTS..EBOX MICRO-CODE NOT LOADED\>
        PNORML
        JMP     CONSOL
PCMD:   .ASCII  %P %
FLNME:
        .ASCIZ  %EBOXB.RAM%             ;EBOX MICRO-CODE FILENAME
.EVEN


;SEQ507

.SBTTL SETPIH -- ROUTINE TO SET SEVERAL PIH FLOPS ON THE PI BOARD

;ROUTINE RECEIVES THE PIH'S TO BE SET, PASSD TO IT IN R0
;THE BITS IN R0 DIRECTLY CORRESPOND TO PIH1-2-3-4-5-6-7.
;ROUTINE RETURNS MAINLINE WITH THE CURRENT C.R.
;CONTAINING A "DISP/DIAG" SO THAT THE MAINLINE CODE ONLY
;NEEDS TO LOAD THE DIAG ADDRESS REG(WITHOUT A MASTER REST)
;AND THEN CONTIUE CLOCKING THE MACHINE

SETPIH: PUSH    <R1,R0>         ;SAVE REGS

        MOV     #M3SUB1,R0      ;SET START ADDRESS OF
        WWADR                   ;OF PIH SETTING MICRO-CODE
        JSR     PC,NPIDIS       ;SET RUN FOR "NO PI DISABLE"
        $CLRWD  EWORD2         ;CLEAR A 36-BIT BUFFER AREA
        MOVB    #42,EWORD2+3   ;SET BITS FOR "GEN ON" & "ACTIVE"
        MOV     #1,R1           ;SET A BIT FOR "BIT TESTING"

1$:     BITB    R1,(SP)         ;NEED PIH7??(6-1)?
        BEQ     2$              ;BR IF NO

        MOV     R1,R0           ;IF YES...
        ASL     R0              ;MUST SET CORRECT PI GEN BITS
        ASL     R0              ;WHICH SET CORRECT PIH BITS
        BIS     R0,EWORD2+2     ;NOW SET THE BITS IN THE 36-BIT BUFFER
        ECLOK                   ;PUT FIRST MIC=-WORD INTO C.R.
        $ARLO2  EWORD2          ;CCONO DATA WHICH WILL GEN REQUIRED PI LVL
        MOV     #^D25,R0        ;ENOUGH CLOCKS TO SET THE DESIRED PIH
        BURST                   ;BURST THE CLOCK

2$:     ROLB    R1              ;ROTATE BIT TESTING BIT
        BPL     1$              ;BR IF NOT FINISHED TESTING ALL BIT POSITIONS
        POP     <R0,R1>         ;OTHERWISE DONE.. RESTORE REGS

        RTS     PC



;SEQ508

.SBTTL ROUTINE TO ISSUE WWADR, ONE ECLOCK & SET RUN FLOP FOR PI

;THIS ROUTINE RECEIVES IN R09 THE DESIRED MICRO-CODE ADDRESS
;THEN LOADS THAT ADDRESS, ISSUES RUN AND CONTINUE (FOR THE
;BENEFIT OF THE PI BOARD) AND FINALLY ONE EBOX CLOCK TO SYNC THE
;MICRO-WCODE FOR THE BEGINNING OF THE NEXT PI SUBTEST

RUN.GO: WWADR                   ;ADDRESS TO DIAG ADDR REG 
        JSR     PC,NPIDIS               ;ROUTINE TO SET RUN & SET OCNTINUE
        ECLOK           ;SINGLE CLOCK
        RTS     PC              ;OUT

;TINY ROUTINE TOT ACTUALLYD OT HE SETTING OF "RUN" & "CONTINUE"
NPIDIS: DFXCTT
        SETRUN          ;FUNCITON TO SET RUN FLOP
        DFXCTT
        CONBUT          ;FUNCTION TO SET CONTINUE AND ENABLE "RUN" TO PI
        RTS     PC              ;OUT

;TRAP ROUTIEN TO GIVE BURSTS OF CLOCK.. THE FEATURE OF THIS ROUTINE
;IS THAT IF YOU GIVE A CLOCK COUNT GREATER THAN THE BURST ROUTINE WILL
;ACCEPT, THEN TRHIS ROUTINE BREAKS IT UP AND DOES THE BURSTING
;IN CHUNKS OF 255
$RUNCL: PUSH    R0              ;SAVE NUMBER OF TICS

1$:     SUB     #^D255,(SP)     ;BIG CLOCK CNT??
        BPL     2$              ;BR IF YES

;HERE IF NO
        BURST                   ;BURST THE CLOCK
        POP     R0              ;CLEAN STACK

        RTS     R5              ;AND OUT

2$:     MOV     #^D255,R0               ;BIG CNT..GET ALL 255 TICS TO R0\
        BURST           ;EXECUTE THEM
        MOV     (SP),R0         ;GET UPDATED CLOCK CNT TO R0
        BR      1$              ;AND BACK TO BEGINNING


;SEQ487

;SUBROUTINE TO CHECK THE C-RAM ADDRESS AND VERIFY THAT
;THE MICRO-CDE HAS STOPPED WHRE I EXPECTED.
;CALL IS:
;       MOV     #EXPECTED CRAM ADDR,R0
;       CRMHL           ;TRAP TO ROUTINE
;**ERROR RETURNS "C-BIT" SET
;**ADDR MATHCES RETURNS "C-BIT" CLEAR
$CRMHLT:        PUSH    R0              ;SAVE EXPECTED CRAM ADDR
        MOV     #RCRA+7,R0      ;FUNCTION TO READ CRAM LOC REG
        CRADRD                  ;TRAP TO READ CRA BRD
        CMP     (SP),R0 ;CRAM ADDRESS AS EXPECTED?
        BEQ     1$              ;BR IF YES-OK

;FALL TO HERE IF ERROR
        MOV     R0,(SP)         ;PUT ACTUAL ON TOP OF STACK
        ERRMSG<\MICRO-DIAGNOSTIC HALT-CRAM ADDRESS >
        MOV     (SP),R0         ;ACTUAL BACK TO R0
        ERROCT                  ;NOW PRINT ADDRESS ITSELF
        POP     R0              ;CLEAN STACK
        SEC                     ;SET ERROR INDICATOR
        RTS     R5              ;RETURN

1$:     POP     R0              ;CLEAN STACK
        CLC                     ;SAY NO ERROR
        RTS     R5              ;RETURN

;SEQ510

.SBTTL *MICEB* DIAGNOSTIC MICRO-CODE SMBOL TABLE
;NUMBER OF RAM WORDS
        RAMWRD = ^D761

;CRAM ADDRESS LABEL TABLE
;       0000            = 0000
        EMPTY           = 0000
;       0001            = 0001
        NUL001          = 0001
;       0002            = 0002
        NUL002          = 0002
        
;       0003            = 0003
        TRAP03          = 0004
;       0004            = 0004
        NUL004          = 0004
;       0005            = 0005
        NUL005          =0005
;       0006            = 0006
        NUL006  = 0006
;       0007            = 0007
        NUL007          = 0007
;       0010            = 0010
        NUL010          =0010
;       137             = 0137
        MIC1EDP         = 0012
        MIC2EDP         = 0117
        MIC3EDP = 0127
        MIC3.1SH                = 0141
        MIC3.2SH        = 0150
        MIC3.3SH        = 0157
        MIC4EDP         = 0166
        MIC4.1AD                = 0172
        MIC4.2AD        = 0174
        F40             = 0200
        F21             = 0201
        F11             =0202
        F51             = 0203
        F40GEN          = 0204
        F26             = 0205
        F0              = 0206
        F22             = 0207
        F6LONG          = 0210
        F46GEN          =0211
        F46LNG          = 0212
        F6INH           = 0213
        F6              = 0214
        NULTIC          = 0217
        FEND            = 0220
        DISPATCHER      = 0221
        GO              = 0222
        MIC4A           = 0223
        HAT4A           = 0014
        MIC5EDP         = 0226
        MIC6EDP         = 0233
        FM1             = 0241
        LBFM            = 0020

;SEQ511

        HALT00          = 0021
        LBFM2           = 0245
        FM0K1           = 0024
        FM2             = 0246
        FM3             = 0247
        LPFM            = 0030
        HALT20          = 0031
        LPFM2           = 0252
        FMOK3           = 0034
        FM4             = 0255
        FM5             = 0256
        LQFM            = 0040
        HALT40          = 0041
        LQFM2           = 0262
        FMOK5           = 0044
        MIC1VMA         = 0267
        MIC2VMA         = 0273
        IMVMA3          = 0276
        MIC3VMA         = 0301
        MIC4VMA         = 0306
        M4.1VMA         = 0314
        M4.2VMA         = 0317
        MIC5VMA         = 0320
        VMAS1           = 0322
        VMAS2           = 0325
        VMAS3           = 0331
        VMAS4           = 0334
        VMAS7           = 0336
        VMAS5           = 0336
        VMASF           = 0341
        VMAS5.10                = 0344
        MIC6VMA         = 0350
        M6.1VMA         = 0357
        MIC8VMA         = 0360
        SUPTST          = 0016
        MIC7VMA         = 0363
        MIC1PIZZA       = 0370
        NOCONO          = 0375
        MIC2PI          = 402
        MPI2.1          = 0405
        MPI2.2          = 0410
        MPI2.5          = 0414
        CLRPIC          = 0420
        JSELF           = 0421
        MIC3PI          = 0422
        M3.1PI          = 0434
        PI3.1A          =0444
        PI3.1B          = 0445
        PI3.1C          =0446
        M3SUB1          = 0447
        MIC4PI          = 0456
        MPI4.1          = 0467
        MIC5PI          = 0470
        M5.0PI          = 0476
        M5.1PI          =0500
        M5.2PI          = 0507


;SEQ512


        M5.3PI          = 0516
        M5.4PI          = 0524
        M5.5PI          = 0532
        M5.5SF          = 0540
        M5.6PI          = 0541
        M5.7PI          = 0550
        M5.8PI          = 0562
        MIC6PI          = 0563
        M6.1PI          = 0577
        M6.2PI          = 0600
        MIC7PI          = 0624
        MIC8PI          = 0633
        M8.0PI          = 0640
        M8.1PI          = 0644
        M8.2PI          = 0650
        CLKM00          = 0655
        CLKM01          = 0656
        CLKM02          = 0657
;       1777            = 1777
        CLKM10          = 0660
        CLKM11          = 0661
        SCM00           = 0662
        SCM01           = 0663
        SCM02           = 0664
        SCM03           = 0665
        SCM04           = 0666
        SCM05           = 0667
        SCM10           = 0670
        SCM11           =0671
        SCM12           =0672
        SCM13           =0673
        MPAR1           =0674
        MPAR1A          = 0700
        MPAR2           = 0704
        DPARX1          = 0714
        DPARX2          = 0715
        PAR2GO          = 0716
        MPAR3           = 0720
        DPARY1          = 0724
        DPARY2          = 0725
        PAR3GO          = 0726
        MPAR3A          = 0730
;       1000            = 1000
;       1001            = 1001
;       1002            = 1002
;       1003            =1003
;       1004            = 1004
;       1005            = 1005
;       1006            = 1006
;       1007            = 1007
;       1010            = 1010
;       1011            = 1011
;       1012            = 1012
;       1013            = 1013
;       1014            = 1014
;       1015            = 1015


;SEQ513

;       1016            = 1016
;       1017            = 1017
        M6.0CRA         = 0736
        M6.1CRA         = 0740
        M6.2CRA         = 0740
        M6.3CRA         = 0741
        M6.4CRA         = 0742
        M6.5CRA         = 0743
        M6.6CRA         = 0745
        M6.7CRA         = 0746
        M6.8CRA         =0750
        M6.9CRA         = 0753
        M6.10CRA        = 0755
        M6.11CRA        = 0760
        M6.12CRA        = 0762
        M6.13CRA        = 0765
        M6.14CRA        = 0767
        M6.15CRA        = 0772
        M6.16CRA        = 0774
        M6.17CRA        = 0777
        M6.18CRA        = 1020
        M6.19CRA        = 1022
        M6.20CRA        = 1024
        M6.21CRA        = 1026
        M6.22CRA        = 1027
        M6.23CRA        = 1031
        M6.24CRA        = 1032
        M6.25CRA        = 1034
        M6.27CRA        = 1034
        M6.26CRA        = 1036
        M6.28CRA        = 1041

        M6.29CRA        = 1044
        M6.30CRA        = 1045
        M6.31CRA        = 1050
        M6.32CRA        = 1053
        M6.33CRA        = 1055
        M6.34CRA        = 1060
        M6.35CRA        = 1062
        M6.36CRA        = 1065
        M6.37CRA        = 1070
        M6.38CRA        = 1071
        M6.39CRA        = 1074
        M6.40CRA        = 1075
        M6.41CRA        = 1077
        M6.42CRA        = 1102
        M6.43CRA        = 1104
        M6.44CRA        = 1107
        M6.45CRA        = 1113
        M6.46CRA        = 1117
        M6.47CRA        = 1121
        M6.48CRA        = 1124
        M6.49CRA        = 1126
        M6.50CRA        = 1131
        M6.51CRA        = 1133
        M6.52CRA        = 1136
        M6.53CRA        = 1140

;SEQ514

        M6.54CRA        = 1142
        M6.55CRA        = 1144
        M6.56CRA        = 1147
        M6.57CRA        = 1152
        M6.58CRA        = 1155
        M6.59CRA        = 1165
        M6.60CRA        = 1177
        M6.61CRA        = 1201
        M6.62CRA        = 1204
        M6.63CRA        = 1207
        M6.64CRA        = 1212
        M6.65CRA        = 1215
        M6.66CRA        = 1221
        M6.67CRA        = 1224
        M6.68CRA        = 1230
        M6.69CRA        = 1232
        M6.70CRA        = 1234
        M6.71CRA        = 1240
        M6.72CRA         = 1241
        M6.73CRA        = 1243
        M6.74CRA        = 1247
        M6.75CRA        = 1251
        M6.76CRA        = 1253
        M6.77CRA        = 1260
        M6.78CRA        = 1262
        M6.79CRA        = 1264
        M6.80CRA        = 1270
        M6.81CRA        = 1275
        M6.82CRA        = 1303

        M6.83CRA        = 1310
        M6.84CRA        = 1316
        M6.85CRA        = 1323
        M6.86CRA        = 1331
        M6.87CRA        = 1335
        M6.88CRA        = 1336
        M6.89CRA        = 1337
        M6.90CRA        = 1340
        M6.91CRA        = 1341
        M6.92CRA        = 1342
        M6.93CRA        = 1343
        M6.94CRA        = 1344
        M6.95CRA        = 1347
        HALT.L          = 1352
        STARTM      = 0052
        CONO.PI         = 1355
        DTE.IO          = 1356
        GRANTL          = 1361
        GRANTW          = 0054
        SETCSFCN        = 1362
        EBUSW           = 0056
        WXFER           = 0057
        RELEBUS         = 1364
        INTLP   = 1365
        INTWAIT         = 0060


;SEQ488

.SBTTL *ESTOR* E-BOX TEST STORAGE LOCATIONS

;STORAGE FOR DTE20 ADDRESS POINTERS
        .EVEN
.DELAY: 0               ;(XXX00)
.DAT3:  0               ;(XXX02)
.DAT2:  0               ;(XXX04)
.DAT1:  0               ;(XXX06)
.TENA1: 0               ;(XXX10)
.TENA2: 0               ;(XXX12)
        
.BC10:  0               ;(XXX14)
.BC11:  0               ;(XXX16)
.T10AD: 0               ;(XXX20)
.T11AD: 0               ;(XXX22)
.T10DT: 0               ;(XXX24)
.T11DT: 0               ;(XXX26)
.DIAG1: 0               ;(XXX30)
.DIAG2: 0               ;(XXX32)
.STDTE: 0               ;(XXX34)
.DIAG3: 0               ;(XXX36)
                .EVEN

;STORAGEW FOER SOME 36-BIT WORDS AND THE CRAM ADDRESS WORD

ONES:   .WORD   -1,-1,-1        ;SOURCE OF ALL ONES WORD
ZERO:   .WORD   0,0,0           ;ZERO'ED 36-BIT WORD
        
EWORD1: .WORD   0,0,0           ;A 36-BIT WORD


DDRAM:
PATBUF:
ERRCNT:
LOAD12:
EWORD2: .WORD   0,0,0           ;ANOTHER ONE
$MICRO: .WORD   0,0,0,0,0,0     ;STORAGE FOR MICROWORD
$$CRAD: 0                       ;STORAGE FOR CRAM ADDRESS
$DDRMS:
DSAVE:                  ;TEMP DATA STORE
DLINKR: .WORD   0               ;LINK ADDRESS FOR SOME CRA TESTS
ERRLVL:
ALL4:
PASS2:  .WORD   0               ;FLAG FOR SECOND PASS STATUS
$NOCHK: .WORD                   ;"NO CHECKING" IONIIALIZATION FLAG

;ASSIGN LITERAL AREA


$$LITT=.        ;START OF LITERAL AREA

$$FF=$$CLIT     ;FIRST FREE


.END    START
    26