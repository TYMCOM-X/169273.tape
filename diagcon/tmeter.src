
.TITLE  TMETER  KL10/20 MODEL B METER BOARD DIAGNOSTIC, VER 1.0


        .LIST   MC,MD,MEB
        .NLIST  BEX,CND

        $OPSEL=1                ;ALLOW"/COMMANDS" FOR USE BY DIAGNOSTIC
        $MBOX=1         ;FOR MBOX DIAGNOSTICS
        $LOAD=1 
        $MSK36R=1
        DTEASB=1                ;ASSEMBLE DTE20 DEFS
        DTEDEF=1                
        KWASB=1         ;ASSEMBLE CLOCK PARAMETERS
  
        DEXWDS=.DAT3    
        .ENABL  ABS,AMA
        .=3000
PXCT=   256

   
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFINITIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10         ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
.NLIST  SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
.LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-100000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM











































































































































































































































































































































































































.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE











































































































































































































































































































































































.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
MOVN=   210
LSH=    242
BLT=    251
AOBJN=  253
JRST=   254
JFCL=   255
XCT=    256
MAP=    257
JSP=    265
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
CAMN=   316
JUMPL=  321
JUMPLE= 323
JUMPA=  324
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOS=    350
SOJE=   362
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
IOR=    434
IORI=   435
SETCA=  450
SETCAM= 452
SETOM=  476
HRLI=   505
HLLZS=  513
HRLZI=  515
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TRZ=    620
TRZN=   626
TRC=    640
TRCE=   642


.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM

.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM


;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.LIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.NLIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        R00=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ.HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36.
        .IIF NB,WID,W=WID
.IIF    NDF,TRAPS,      JSR     R5,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        ;WORD 1
        .IIF NE <XXX-1>,                        ;.WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        S10.    EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG,CLK
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD CLK
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   P5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR,R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE,<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
        S10.    CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
.IIF    NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDF,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS,      JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN


.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-MAR-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        TTIBRK                  ;GET LAST CHARACTER TYPED
        CMP     R0,#'/                  ;SWITCH SPECIFIED?
        BNE     1$                      ;NO
        JSR     PC,USERSW                       ;YES,GO TO USER SWITCH ROUTINE
1$:     SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        MOV     #DIACOM,COMRET          ;SET COMMAND RETURN
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        CMP     R0,#'/                  ;SLASH?
        BNE     NOPSEL                  ;NO
        JSR     PC,USERSW               ;YES,GO DO USER SWITCH ROUTINE
        BR      DIACOM                  ;BACK TO COMMAND MODE
NOPSEL: MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                          ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRIONT SYMPTOM
        .BYTE   'F,'B           ;FB - SET FUNCTION BREAKPOINT
        .BYTE   'F,'C           ;FC - FUNCTION BREAK CONTINUE
        .BYTE   'C,'B           ;CB - CLEAR FUNCTION BREAKPOINT
        .BYTE   'R,'G           ;RG - PRINT FN BREAK REGISTERS
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
        .WORD   FB..
        .WORD   FC..
        .WORD   CB..
        .WORD   RG..

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    </	PROGRAM DEFINED SWITCHES\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
        PMSG    <FB	SET FUNCTION BREAKPOINT\>
        PMSG    <FC	FUNCTION BREAK CONTINUE\>
        PMSG    <CB	CLEAR FUNCTION BREAK\>
        PMSG    <RG	PRINT BREAK REGISTERS\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        JSR     PC,USRHLP       ;PRINT USER HELP INFORMATION
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

































.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKPOINTS DURING INITIALIZATION
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKS DURING INITIALIZATION
        JSR     PC,(R3)                 ;DO INITIALIZATION
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        PNTCI
                "DH
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR REPORTING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  16-MAR-77
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     CONSOL          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN
  
  
.SBTTL          ERROR REPORTER          22-DEC-76
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        ESTSIZ=100      ;ERR STACK SIZE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPOUT AND HOW TO MSAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FT8             ;16
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTMEM           ;30
        FTT     FTPRM           ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

FT8T:FTM.        <HEDSCT,ENTSCT>

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

FTMEMT:FTM.     <HEDMRQ,ACTMRQ,EXPMRQ>

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACTMRQ:ACMRQ
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
ENTSCT:ENSCT
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXPMRQ:XPMRQ
HEDMRQ:HDMRQ
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT


.SBTTL          REPORT HEADINGS

        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>
        .LIT ERMRQ,<.ASCIZ %         RQ0 RQ1 RQ2 RQ3 RD  WR  SBUS ADR\%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER
.REM    %
        PRINT ACTUAL MEMORY RQ'S AND 22-BIT ADDRESS
        %
ACMRQ:  $PMSG,ERACT             ;PRINT MESSAGE
MRQCOM: JSR     PC,TYPRQS       ;TYPE REQUEST BITS
        MOV     R5,R0   
        ADD     #3,R5           ;SKIP OVER INFO
        PNT22                   ;SBUS ADR IN OCTAL
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER




.REM    %
        
STACK HAS ONE OR MORE ENTRIES TO REPORT SCANOUT ERRORS.
WORD1:DIAG FN,,SIZE ((CHAN OR MBOX TABLE ID)
        NEXT 2 OR 3 BYTES:EXPECTED DATA
        NEXT 2 OR 3 BYTES :ACTUAL DATA
        WHETHER 2 OR 3 BYTES IS DETERMINED BY SIZE AND DIAG FN, WHICH
        ALSO DETERMINES THE E-BUS BIT NUMBER CORRESPONDENCE.
        %

ENSCT:  CLRB    FT8DUN          ;CLR DONE FLAG
1$:     JSR     PC,GNSCT                ;GET ONE ENTRY FROM ERROR STACK

;NOW TEST ALL THE BITS IN THIS ENTRY AND PRINT DIFFERENCES
        JSR     PC,PRDBYT
        TSTB    FT8DUN          ;LAST ENTRY?
        BEQ     1$              ;NO, DO IT AGAIN
        RTS     PC              ;RETURN TO SCANNER



;SET UP AN ENTRY FOR REPORTING
GNSCT:  MOVB    (R5)+,FT8SIZ            ;GET SIZE PARAM
        MOVB    (R5)+,FT8DF             ;GET DIAG FCN
        BPL     2$              ;BR IF NO LAST ENTRY FLAG
        INCB    FT8DUN          ;SET DONE FLAG
        BICB    #200,FT8DF      ;AND CLEAN DF BUFFER
2$:     CLR     R3              ;INIT INDEX
        CMPB    FT8SIZ,#CSIZE   ;CHANNEL?
        BEQ     3$              ;BR IF SO
        INC     R3              ;NEXT INDEX
        CMPB    FT8DF,#163      ;FIND WHICH MBOX GROUP
        BLT     3$              
        INC     R3              ;2-BYTE GROUP
3$:     ASL     R3              ;MAKE WORD INDEX
        ADD     F8SIZT(R3),R5   ;POINT BEYOND EXPECTED
        MOV     R5,R1           ;MAKE EXPECTED PTR
        DEC     R1
        ADD     F8SIZT(R3),R5   ;POINT BEYOND ACTUAL
        MOV     R5,R2           ;MAKE ACTUAL PTR
        DEC     R2
        MOV     F8BITT(R3),F8BTF        ;GET # OF FIRST, LAST BITS
        MOV     F8MSKT(R3),R3   ;GET IRST BIT MASK
        RTS     PC              ;RETURN


;SEQ119

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
        PRINT EXPECTED DATA, MEM RQ AND 22-BIT ADDRESS
        %
XPMRQ:  $PMSG,ERCOR     ;PRINT MESSAGE
        JMP     MRQCOM  ;TYPE BITS, ADDRESS



.REM    %
REPORT MEMORY REQUESTS AND 22-BIT SBUS ADDRESS.
PRINT HEADER LINE
        %
HDMRQ:  $PMSG,ERMRQ     ;PRINT MESSAGE
        RTS     PC



.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE MEMORY REQUESTS AND READ/WRITE BITS

TYPRQS: MOV     #6,R2   ;BIT COUNT
        MOVB    (R5)+,R1        ;GET BIT WORD
        SWAB    R1              ;POSITION TO SHF INTO SGN
        PSPACE                  ;SPACE 1
1$:     MOV     #'0,R0          ;ASSUME A ZERO
        TST     R1              ;
        BPL     2$              ;BR IF ZERO
        MOV     #'1,R0          ;ITS A ONE
2$:     PNTCHR
        PSPACE,PSPACE,PSPACE    ;SPACE3
        ROL     R1              ;NEXT BIT
        DEC     R2              ;COUNT
        BGT     1$              ;DO MORE
        RTS     PC


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT        ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15

;SEQ195

.SBTTL  *DHKCA*   F. DATA DUMPER JAB29857   17-SEP-76   EDIT#20
;---- F. IS A SERIES OF SUBROUTINES AND A DISPATCHER TO CALL THEM
;       THE SUBROUTINES SIMPLIFY THE DUMPING OF INFORAMTION TO THE
;       CTY. F. WORKS IN 2 MODES: DUMP MODE, WHEREIN TYPOUT GOES
;       DIRECTLY TO CTY, AND FAULT MODE, WHERE TYPOUT IS DUMPED ON THE
        





;       ERR STACK OF DIACON.
;----DUMP MODE IS CALLED AS FOLLOWS:
;       JSR     PC,F.DMP
;       .WORD   CMD.WD.LST.ADR
;       NXT.INSTR
;----FAULT MODE IS CALLED SIMILARLY:
;       JSR     PC,F.FLT
;       .WORD   CMD.WD.LST.ADR
;       .ASCIZ  %STD FAULT MSG FOR DIACON%
;----NOTE THAT FAULT MODE DOES NOT RETURN, BUT JUMPS DIRECTLY TO FAULT.
;----THE COMMAND WORD LIST IS POINTED TO BY THE WORD FOLLOWING THE
;       JSR IN BOTH CASES.  THE COMMAND WORD LIST IS A SERIES OF WORDS
;       (AND MAYBE .ASCIZ STRINGS) WHICH DIRECTS THE ACTION OF THE
;       DISPATCHER.  THE LAST WORD MUST BEW F.END, TO STOP THE DISPATCHER



.MACRO  XFAULT  .C,.M
        .IF     B,<.M>

          FAULT <.C>
        .IFF
          JSR   PC,F.FLT
        .IF     B,.C
          .WORD F.END
        .IFF
          .WORD .C
        .ENDC
          .ASCIZ        %.M%
          .EVEN
        .ENDC
        .ENDM   XFAULT


;SEQ196

;----THE COMMAND WORDS ARE AS FOLLOWS:


;LOWER  UPPER   SYMBOL  DESCRIPTION OF ACTION TAKEN
; ----- -----   ------ ---------------------------------------------------------
;000000 000017  -NONE-  PRINTS THE NUMBER AND CONTENTS OF A LK10
;                       ACCUMULATOR.  WARNING:  DOES AN SM TO SUPPORT
;                       EXAMINES, & ZAPS THE DTE20 DATA EXCH WORD.
;000020 000177  -NONE-  DOES AND PRINTS THE RESULT OF A DIAG. FUNC.
;                       READ WITH THE DFRD #.  ONY FUNCTIONS 20 THRU
;                       177 MAY BE READ.  WARNING:  CLOBBERS CURRENT
;                       DTE20 DATAEXCHN WORD.
;000200 077777  -NONE-  PRINTS THE ADDRESS AND CONTENTS OF A WORD IN
;                       PDP11 MEMORY.
;100000 100007  F.R?    PRINTS THE NUMBER AND CONTENTS OF THE SPEC-
;                       IFIED (BY ?) PDP11 REGISTER.
;100010 100017  F.NR?   PRINTS THE NAME AND CONTENTS OF THE SPECIFIED
;                       PDP11 REGISTER.  THE .ASCIZ NAME MUST FOLLOW
;                       THE CMD WORD IN THE CMD WORD LIST.
;100020         F.ALLR  PRINTS ALL OF THE PDP11 REGISTERS, AS THEY
;                       WERE JUST BEFORE THE CALLING JSR.
;100021         -NONE-  CURRENTLY UNDEFINED.  DOES THE SAME AS F.DTE20,
;                       DESCRIBED BELOW.
;100022         F.DTE2  PRINTS THE CURRENT CONTENTS (WITH A NAME) OF
;                       THE DTE20 DATA EXCHANGE WORDS.
;100023         F.TOS   PRINTS THE TOP FIVE WORDS OF THE DPD11 STACK 
;                       AS THEY WERE JUST BEFORE THE CALLING JSR.

;100024         F.ASCI  PRINTS THE .ASCIZ STRING FOLLOWING THIS CMD
;                       WORD FROM THE CMD WORD LIST.  CRLF NOT AUTOMATIC.


;100025         F.INDI  TAKES THE NEXT WORD FROM THE CMD WORD LIST
;                       AND USES IT AS THE ADDRESS F THE CONTIN-
;                               UATION OF THE CMD WORD LIST.
;100026         F.NOP   THIS DOES ABSOLUTELY NOTHING.  IT IS USED TO
;                               ;FUNCTIONALLY DELETE A CMD WD LIST ENTRY.
;100027         F.END   THE ONLY  REQUIRED CMD.  CAUSES TERMINATION OF
;                       SUBROUTINE F., AND RETURN OR JUMP TO 'FAULT'.
;100030 100037  F.16R?  PRINTS THE PDP11 MEMORY WORD POINTED TO BY
;                       THE SPECIFIED PDP11 REGISTER.
;100040 100047  F.36R?  PRINTS THE KL10 WORD IN PDP11 MEMORY POINTED TO
;                       BY THE SPECIFIED PDP11 REGISTER.
;100050 100057  F.16N?  PRINTS THE NAME AND CONTENTS OF A PDP 11 MEMORY
;                       WORD POINTED TO BY THE SPECIFIED REGISTER.

;                       REQUIRES .ASCIZ NAME IN THE CMD WORD LIST.
;100060 100067  F.36N?  PRINTS THE NAME AND CONTENTS OF A KL10 WORD IN
;                       PDP11 MEMORY WHICH IS POINTED TO BY THE 
;                       SPECIFIED PDP11 REGISTER.  NEEDS .ASCIZ NAME IN
;                       THE CMD WORD LIST.
;100070 100177  -NONE-  CURRENTLY NOT DEFINED.  DOES THE SAME AS THE
;                       FUNCTION BELOW.
;100200 177777  <ADR>!BIT15     PRINTS A KL10 WORD FROM THE SPECIFIED
;                               PDP 11 MEMORY ADDRESS.  FIRST PRINTING
;                               THE PDP11 MEMORY ADDRESS.

;KCA.MSG

                                ;8089
;NOTE: TIL ;8050 IS RECONSTRUCTED CODE  ;8090
.NLIST                          ;91
                                ;92
                                ;93
F.ALLR=100020                   ;94
F.DTE2=100022                   ;95
F.TOS=100023                    ;96
F.ASCI=100024                   ;97
F.INDI=100025                   ;98
F.NOP=100026                    ;99
F.END=100027                    ;100
F.R0=100000                     ;101
F.R1=100001                     ;102
F.R2=100002                     ;103
F.R3=100003                     ;104
F.R4=100004                     ;105
F.R5=100005                     ;106
F.R6=100006                     ;107
F.R7=100007                     ;108
F.NR0=100010                    ;109
F.NR1=100011                    ;110
F.NR2=100012                    ;111
F.NR3=100013                    ;112
F.NR4=100014                    ;113
F.NR5=100015                    ;114
F.NR6=100016                    ;115
F.NR7=100017                    ;116
F.16R0=100030                   ;117
F.16R1=100031                   ;118
F.16R2=100032                   ;119
F.16R3=100033                   ;120
F.16R4=100034                   ;8121
F.16R5=100035                   ;122
F.16R6=100036                   ;123
F.16R7=100037                   ;124
F.36R0=100040                   ;125
F.36R1=100041                   ;126
F.36R2=100042                   ;127
F.36R3=100043                   ;128
F.36R4=100044                   ;129
F.36R5=100045                   ;130
F.36R6=100046                   ;131
F.36R7=100047                   ;132
F.16N0=100050                   ;133
F.16N1=100051                   ;134
F.16N2=100052                   ;135
F.16N3=100053                   ;136
F.16N4=100054                   ;137
F.16N5=100055                   ;138
F.16N6=100056                   ;139
F.16N7=100057                   ;140
F.36N0=100060                   ;141
F.36N1=100061                   ;142
F.36N2=100062                   ;143
F.36N3=100063                   ;144
F.36N4=100064                   ;145
F.36N5=100065                   ;146
F.36N6=100066                   ;147
F.36N7=100067                   ;148
.LIST                           ;149
                                ;150
                                ;151



;SEQ197

;----A FEW MORE DEFINITIONS AND VARIABLES:
        OUT=004545      ;A JSR R5,-(R5) USED TO CALL F.UOS
OUT0=004515     ;A JSR R5,(R5) USED TO CALL F.UOS2
OUTS=004414     ;A JSR R4,(R4) USED TO CALL F.OSS
F.BUFR: .BLKW   15.             ;ENUF MEM TO HOLD SIX 36 BIT KL10 WORDS

;----ENTRY SECTION...SAV REGISTERS, ETC
F.FLT:  CLR     F.UOS2+2        ;MODE=0...PUT OUTPUT ON ERR STK
        BR      F.COM
F.DMP:  INC     F.UOS2+2        ;MODE NOT=0...PRINT OUTPUT DIRECTLY
F.COM:  PUSH    <R0,R1,R2,R3,R4,R5>     ;SAVE R0-R5






        TST     -(SP)   ;"PUSH" R6 TO STK
        MOV     R6,(SP) 
        ADD     #20,(SP)        ;COR TO REFLECT VALUE BEFORE CALL
        PUSH    16(SP)          ;R7 (PC) TO STK, TOO


        MOV     #F.UOS2,R5      ;PTR SAVE TIME & SPACE
        MOV     #F.BP,R4        ;PTR SAVE TIME & SPACE
        MOV     #F.BUFR,(R4)+   ;INIT BUFFER PTR
        MOV     @(SP),R2        ;GET WORD LIST ADR TO R2
        OUT,PCRLF               ;PRINT INITIAL CR,LF
;----SECTION TO SCAN THRU WORD LIST, FIND & INIT APPROPRIATE SUBROUTINE
1$:     MOV     #10$-2,R1       ;INIT TAB SRCH PTR
        MOV     (R2)+,R3        ;GET WORD FROM WORD LIST
2$:     TST     (R1)+   ;MOV TAB PTR TO CMD WORD
        CMP     R3,(R1)+        ;IS THIS THE ONE? (R1 NOW PTS TO SUBR ADR)
        BHI     2$              ;NO...LOOP TIL FND
        BIC     #BIT15,R3       ;NOW CLR HI ORD BIT OF CMD WORD
        MOV     (R1),R1 ;SUBR ADR TO R1 (& TEST IT TOO)
        BGE     3$              ;BR IF HI ORD ADR BIT NOT SET
;----HI ORD BIT MEANS PICK UP THE PDP11 REG VALUE FIRST
        BIS     #177770,R3      ;CALC DISP BACK UP STK TO REG
        MOV     R3,F.RGN0+2     ;ALSO SAV REG #
        COM     R3
        ASL     R3
        ADD     SP,R3           ;NOW CALC ADR ON STK
        MOV     (R3),R3         ;& PUT REG VALUE IN R3
;----SECTION TO HANDLE REQUIREMENTS OF ROUTINE WHOSE BIT0 IS SET
3$:     BIT     #BIT0,R1        ;BIT 0 SET?
        BEQ     5$              ;NO
        MOV     R2,R0           ;STR ADR TO R0
        OUT0,PNTAL
4$:     TSTB    (R2)+           ;SCAN FOR END OF STRING
        BNE     4$              ;LOOP UNTIL FND
        INC     R2              ;FORCE WORD ALLIGNMENT
        BIC     #BIT0,R2
;----SECTION TO CALL APPROPRIATE SUBROUTINE
5$:     BIC     #BIT15!BIT0,R1  ;CLR IND BITS IN ADR


;SEQ198

        JSR     PC,(R1)         ;CALL ROUTINE
        OUT,PCRLF               ;PRINT CR,LF UPON RE
        BR      1$              ;GET NXT CMD FROM WORD LST & DO IT

;SEQ199

;----COMMAND SEARCH AND DISPATCH TABLE
10$:    17,F.AC                 ;PRINT A KL10 ACCUMULATOR
        177,F.DFRD              ;DIAG FUNCTION READ (20-117 ONLY)
        77777,F.MEM             ;PRINT A PDP11 MEM WORD
        F.R7,F.RN!BIT15         ;PRINT A PDP11 REGISTER
        F.NR7,F.NRN!BIT15!BIT0  ;PRINT A NAMED PDP11 REG
        F.ALLR,F.ALR            ;PRINT ALL PDP11 REGS
        F.DTE2,F.DTE            ;PRINT THE CURRENT CONTENTS OF DTE20
        F.TOS,F.TOST            ;PRINT THE TOP 5 WORDS OF THE PDP11 STK
        F.ASCI,F.ASCZ!BIT0      ;.ASCIZ STRING FROM CMD WD LST
        F.INDI,F.INDR           ;INDIRECT CMD WORD LST
        F.NOP,F.ASCZ            ;DO NOTHING
        F.END,F.ENDD            ;CMD TO TERMINATE EXECUTION OF F.
        F.16R7,F.16RN!BIT15     ;PDP11 WD PTD TO BY R?
        F.36R7,F.36RN!BIT15     ;KL10 WD PTD TO BY R?
        F.16N7,F.MEMD!BIT15!BIT0        ;NAMED PDP 11 WD PTD TO BY R?
        F.36N7,F.P36C!BIT15!BIT0        ;NAMED KL10 WD PTD TO BY R?
        177777,F.ACM            ;KL10 WD IN SPECIFIED PDP11 WORDS

;-----F.EXIT SUBROUTINE ...CLEANS UP, RETURNS OR CALLS FAULT.
F.ENDD: ADD     #6,SP           ;RET PC, OLD PC, OLD SP OFF THE STK
        POP     <R5,R4,R3,R2,R1,R0>     ;RESTORE REGS R0-R5
        ADD     #2,(SP)         ;BYPASS CMD WORD LIST PTR
        TST     F.UOS2+2        ;FAULT OR DUMP MODE?
        BNE     F.RPC           ;BR DUMP MODE...RET TO CALLER
        JMP     FAULT

;-----THE ULTIMATE OUTPUT SUBROUTINE.  EVERYTHING WHICH GETS
;       PRINTED COMES THRU HERE.  ON ENTRY R5 POINTS TO THE EMT,
;       R3=ADDR/DATA.
F.UOS:  MOV     R3,R0           ;PUT DATA/ADR IN R0 TO BE USED
F.UOS2: TST     #000000         ;FAULT OR DUMP MODE?  (TO BE SUPPLIED)
        BNE     1$              ;DUMP MODE, SIMPLY RET & EXEC EMT
        MOV     (R5)+,20$       ;ELSE PUT EMT & R0 ON ERR STK
        JSR     R5,$ERPNT
20$:    .WORD   000000          ;EMT
1$:     MOV     #F.UOS2,(SP)    ;REPAIR DAMAGE DONE BY -(R5) CALL
        RTS     R5              ;DONE ...RETURN

;-----SECTION TO PRINT STRING POINTED TO BY R5 UPON CALL
F.BP:   000000                  ;BUFFER PTR...INITD ON ENTRY
F.OSS:  MOV     R4,R0           ;STR ADR TO R0
        OUT0,PNTAL
1$:             BIT     #177400,(R4)+   ;SRCH FOR AND BYPS EO STR
        BNE     1$              ;LOOP UNTIL END FOUND
        RTS     R4

;-----SUBROUTINE TO PRINT'(R?/??????)='

 

;SEQ200


F.11RA: OUTS,'(         ;PRINT '('
        JSR     PC,F.RN ;PRINT 'R?/??????'
        OUT,    PNTBAK          ;BACK UP OUTPUT PTR 1 BYTE
        OUTS,")=,0              ;PRINT ')='
F.RPC:  RTS     PC              


;SEQ201

;----SUBROUTINE TO PRINT THE CONTENTS OF PDP11 REGISTER
F.RN:   OUTS,'R         ;PRINT 'R'
F.RGN0: MOV     #000000,R0      ;PRINT REGISTER# (TO BE SUPPLIED)
        OUT0,PNTNBR     
F.NRN:  OUTS,'/         ;PRINT '/'
        OUT,PNTOCT              ;PRINT REG VALUE
        RTS     PC

;----SUBROUTINE TO PRINT ALL OF THE PDP11 REGISTERS
F.ALR:  MOV     #177770,F.RGN0+2        ;REG # & CNT
        MOV     4(SP),R1        ;GET OLD SP (PTS TO OLD TOS)
        TST     -(R1)           ;BYPS RET PC
1$:     MOV     -(R1),R3        ;REG CONTENTS TO R3
        JSR     PC,F.RN         ;PRINT R?/??????
        INC     F.RGN0+2        ;NEXT REG #
        BLT     1$              ;BR IF -DONE YET
        RTS     PC


;----SUBROUTINE TO DO A DFRD AND PRINT THE RESULT
F.DFRD: OUTS,"FR,0              ;PRINT 'FR'
        OUT,PNTOCS              ;PRINT DFRD #
        MOV     R3,R0           ;DFRD # TO R0
        DFRD                    ;DO DIAG FUNC READ
        BR      F.DTEC  ;GET DATA FROM DTE20 & PRINT

;----SUBROUTINE TO PRINT A KL10 ACCUMULATOR
F.AC:   SM                      ;ENABLE EXAMINE/DEPOSIT
        OUTS," A,'C     ;PRINT ' AC'
        OUT,PNTOCS              ;PRINT AC #
        CLR     -(SP)           ;CREATE 22 BIT ADR ON STK
        MOV     R3,-(SP)
        MOV     SP,R0           ;PTR TO 22 BIT ADR
        EXAM                    ;EXAMINE THE AC
        CMP     (SP)+,(SP)+     ;DEL ADR FROM STK
        BR      F.DTED

;----SUBROUTINE TO PRINT THE CURRENT DTE20 WORD.
F.DTE:  OUTS                    ;PRINT 'DTE20'
        .ASCIZ          %DTE20%
F.DTEC: MOV .DAT3,R0            ;DTE DEXWDS FOR ADR TO R3
F.DTED: MOV     -(R4),R1        ;GET BUFFER PTR
        MOV     R1,R3           ;ADR TO WHERE EXPECTED BY 'OUT'
        MOVB    (R0)+,(R1)+     ;PRESERVE DTE DATA IN BUFFER
        MOVB    (R0)+,(R1)+     ;SO THAT THE DTE MAY BE USED AGAIN
        MOVB    (R0)+,(R1)+     
        MOVB    (R0)+,(R1)+
        MOVB    (R0)+,(R1)+
        MOV     R1,(R4)+        ;PUT BAK BUFFER PTR
        BR      F.P36C          ;PRINT KL10 WD


;SEQ202

;----SUBROUTINE TO PRINT A KL10 WORD FROM PDP11 MEMORY.
F.ACM:  OUT,PNTOCS              ;PRINT THE ADDRESS
F.P36C: OUTS,'/         ;PRINT '/'
F.P36D: OUT,PNT36               ;PRINT THE 36 BIT WORD
        RTS     PC

;----SUBROUTINE TO PRINT A PDP11 WORD POINTED TO BY A REGISTER
F.16RN: JSR     PC,F.11RA       ;PRINT REG#/CONTENTS
        BR      F.MEMC          ;PRINT CONTENTS OF THE MEM WORD

;-----SUBROUTINE TO PRINT A KL10 WORD IN PDP11 MEM, POINTED TO BY
;       A PDP11 REGISTER.
F.36RN: JSR     PC,F.11RA               ;PRINT REG#/CONTENTS
        BR      F.P36D          ;PRINT THE 36 BIT WORD


;----SUBROUTINE TO PRINT A PDP11 MEM LOCATION, 16 BIT ORMAT
F.MEM:  OUT,PNTOCS              ;PRINT ADR
F.MEMD: OUTS,'/         ;PRINT '/'
F.MEMC: BIC     #BIT0,R3                ;FORCE AN EVEN ADR
        MOV     (R3)+,R0        ;GET MEM WORD TO R0
        OUT0,PNTOCT
        RTS     PC

;----SUBROUTINE TO PRINT THE TOP 5 WORDS OF THE PDP11 STACK.
F.TOST: MOV     4(SP),R3                ;GET OLD TOS ADR
        OUTS                    ;PRINT 'TOP OF STACK'
        .ASCIZ  %TOP OF STACK %
        MOV     #4,R1           ;INIT CNTR
        JSR     PC,F.MEM        ;PRINT ADR/MEM-CONTENTS
1$:     JSR     PC,F.MEMC       ;PRINT NEXT WD
        CMP     R3,#STACK       ;AT BOTTOM OF STK?
                BHI     2$              ;IF YES. QUIT NOW
        DEC     R1              ;COUNT DOWN
        BGT     1$              ;LOOP TIL DONE
2$:     RTS     PC

;----SUBROUTINE TO DO AN INDIRECT TO A NEW CMD WORD LIST.
F.INDR: MOV     (R2),R2         ;NEXT WD BECOMES ADR OF NEW LIST
F.ASCZ:         ADD     #4,(SP)         ;DONT DO AUTO CRLF ON RETURN
        RTS     PC


;SEQ203

.SBTTL  METER BOARD (M8538) DIAG. JAB29857    22-MAR-77
  
.REM    %
        INITAB AND TESTAB FOR METER BOARD TESTS
%

INITAB: .WORD   I.0     ;DO ONE TIME INIT
        .WORD   000000  ;01-NO INIT FOR METER BOARD TEST#1
        .WORD   I.2             ;2-INIT FOR METER BOARD TEST #2
        .WORD   I.3             ;3-INIT FOR METER BOARD TEST#3
        .WORD   I.4             ;4-INIT FOR METER BOARD TEST#4
        .WORD   I.5             ;5-INIT FOR METER BOARD TEST#5

        .WORD   I.6             ;6-INIT FOR METER BOARD TEST#6
        .WORD   I.7             ;7-INIT FOR METER BOARD TEST#7
        .WORD   I.8             ;8-INIT FOR METER BOARD TEST#8
        .WORD   I.9             ;9-INIT FOR METER BOARD TEST#9
        .WORD   I.10    ;10-INIT FOR METER BOARD TEST#10
        .WORD   I.11            ;11-INIT FOR METER BOARD TEST#11
        .WORD   I.12    ;12-INIT FOR METER BOARD TEST#12
        .WORD   I.13            ;13-INIT FOR METER BOARD TEST#13
        .WORD   I.14!BIT15      ;;14-INIT FOR METER BOARD TEST#14
        .WORD   I.15            ;15-INIT FOR METER BOARD TEST#15
        .WORD   I.16            ;16-INIT FOR METER BOARD TEST#16
        .WORD   I.17            ;17-INIT FOR METER BOARD TEST#17
        .WORD   I.18            ;18-INIT FOR METER BOARD        TEST#18
        .WORD   I.19            ;19-INIT FOR METER BOARD TEST#19
        .WORD   I.20            ;20-INIT FOR METER BOARD TEST#20
        .WORD   I.21            ;;21-INIT FOR METER BOARD TEST#21
        .WORD   000000  ;22-NO INIT FOR METER BOARD TEST#22
        .WORD   I.23!BIT15      ;23-INIT FOR METER BOARD TEST#23
        .WORD   I.24            ;24-INIT FOR METER BOARD TEST#24
        .WORD   I.25            ;25-INIT FOR METER BOARD TEST#25
        .WORD   I.26!BIT15      ;26-INIT FOR METER BOARD TEST#26
        .WORD   I.27!BIT15      ;27-INIT FOR METER BOARD TEST#27
MTRNOT=<.-INITAB>/2-1   ;TRUE NUMBER OF TESTS
        .WORD   ENDPAS          ;28-END GENERATION PASS CONTROL


;SEQ204

 TESTAB:        .BYTE   MTRNOT          ;NUMBER OF TESTS AS OF THE MOMENT
        .BYTE   'D!BIT7         ;ISOLATION ROUTINE IDENTIFIER
        .WORD   T.1             ;01-QUICK MASTER RESET TEST
        .WORD   T.2             ;2-PERIOD REGISTER DATA PATH TEST
        .WORD   T.3             ;3-TIME BASE ON/OFF TEST
        .WORD   T.4             ;4-TIME BASE MR TEST
        .WORD   T.5             ;5-CONO MTR CLR-TIME-BASE BIT TEST
        .WORD   T.6             ;6-TIME BASE COUNT/READ TEST
        .WORD   T.7                     ;7-INTERVAL TIMER ON/OFF TEST
        .WORD   T.8             ;8-INTERVAL TIMER MR TEST
        .WORD   T.9             ;9-CONO TIM CLR-INTRVL-TIMER BIT TEST
        .WORD   T.10            ;10-INTERVAL TIMER P.I.A. DATA PATH CHECK
        .WORD   T.11            ;11-INTRVL TIMER DONE/OVRFLW/VECTOR INTRP TEST
        .WORD   T.12            ;12-COUNT/READ TEST FOR THE INTERVAL TIMER
        .WORD   T.13            ;13-ACCOUNTING FLOPS DATA PATH TEST
        .WORD   T.14            ;14-ACCOUNTING FLOP LOGIC TEST
        .WORD   T.15            ;15-EBOX ACCOUNTING MR TEST
        .WORD   T.16            ;16-EBOX ACCOUNTING COUNT/READ TEST
        .WORD   T.17            ;17-MBOX (CACHE) ACCOUNTING MR TEST
        .WORD   T.18            ;18-MBOX ACCOUNTING COUNT/READ TEST
        .WORD   T.19            ;19-PERF, ANALYSIS EVENT/DURATION TEST
        .WORD   T.20            ;20-PERFORMANCE ANALYSIS MR TEST
        .WORD   T.21            ;21-CLR-PA-CNTR- BIT TEST
        .WORD   T.22            ;22-PERF. ANALYSIS COUNT/READ TEST
        .WORD   T.23            ;23-PERF ANALYSIS PI TEST
        .WORD   T.24            ;24-PERF ANALYSIS USER/EXEC  MODE TEST
        .WORD   T.25            ;25-PERF ANALYSIS PROBE TEST
        .WORD   T.26            ;26-PERF ANALYSIS CACHE LOGIC TEST
        .WORD   T.27            ;27-(DATAI,BLKI)(TIM,MTR) INSTR FUNCTIONAL TEST
        .WORD   000000          ;28-NO TEST


;SEQ205

.REM    %
        METER BOARD BIT DEFINITIONS AND SCRATCH AREAS
        %


                                ;METER BOARD DIAG READ FUNC NUMBERS

MBDFTB=110      ;TIME BASE COUNTER
MBDFPA=111      ;PERFORMANCE ANALYSIS COUNTER
        MBDFEA=112      ;EBOX ACCOUNTING COUNTER
        MBDFMA=113      ;MBOX (CACHE) ACCOUNTING COUNTER
        MBDFIT=114              ;INTERVAL TIMER COUNTER
        MBDFPR=115      ;INTERVAL TIMER PERIOD REGISTER & CONTROL BITS
MBDFAD=116      ;ACCOUNTING & TIME BASE STATUS BITS
MBDFSR=117      ;METER BOARD SERVICE REQUEST BITS

CIT=BIT1        ;CLEAR INTERVAL TIMER
TIMON=BIT14             ;INTERVAL TIMER ON      MBDFPR
CLRDON=BIT13    ;CLEAR INTERVAL TIMER DONE
        
TIMDON=BIT13    ;INTERVAL TIMER DONE    MBDFPR
TIMOVR=BIT12    ;INTERVAL TIMER OVERFLOW        MBDFPR

LAC=BIT1        ;LOAD ACCOUNTING CONTROL BITS
PIACTE=BIT14    ;ACCOUNT EXEC MODE, PI IN PROG  MBDFAD
EXACTE=BIT13    ;ACCOUNT EXEC MODE, PI LEVEL 0  MBDFAD
ACCTON=BIT12    ;ACCOUNTING ON  MBDFAD

TBOFF=BIT11     ;TURN TIME BASE OFF
TBON=BIT10      ;TURN TIME BASE ON      M5DFAD
TBCLR=BIT9      ;CLEAR THE TIME BASE

MBVRQ=BIT15     ;BECTOR INTERRUPT REQUEST BIT   MBDFSR
MBIS2=BIT14     ;MTR INCR SEL 2 MBDFSR
MBIS1=BIT13     ;MTR INCR SEL 1 MBDFSR
NMCM=BIT10      ; -MTR CONO MTR H       MBDFSR

EPT=3000        ;EPI TO PAGE 3 FOR THESE DIAGNOSTICS
        
UPT=5000        ;UPT TO PAGE 5
EPTTB=511+EPT   ;LO ORDER WORD OF TIME BASE AREA IN THE EPT
EPTPA=513+EPT   ;LO ORDER WORD OF THE PERF. ANALYSIS AREA IN THE EPT
EPTITV=514+EPT  ;INTERVAL TIMER INTERRUPT VECTOR IN THE EPT
UPTMA=507+UPT   ;LO ORDER WORD OOF MBOX ACCTGH IN A UPT PAGE
UPTEA=505+UPT   ;LO ORDER WORD OF EBOX ACCTG IN A UPT PAGE

TIM=20          ;METER BOARD DEVICE NUMBER
MTR=24          ;METER BOARD DEVICE NUMBER

SCRT22: .WORD   0,0     ;SCRATCH AREA FOR 22 BIT QUANTITIES
PRSCRT: .WORD   0,0,0   ;SCRATCH FOR BITS 20-35 ONLY IN 36 BIT WORD
SCRT36: .WORD   0,0,0   ;SCRATCH AREA FOR 36 BIT QUANTITIES

MBEX1:  F.ASCIZ
        .ASCIZ  %METER BOARD (M8538):%
        .EVEN
        F.END


;SEQ206

        .SBTTL          METER BOARD MACROS AND SUBROUTINES

.REM    %
        MACRO FOR SUBROUTINE 'COTIM' BELOW
        %
.MACRO  COTIM   $H,$L,$P
        .IF     B,$P
        .IFT
          JSR   R5,COTIM        ;DO CONO TIM...R0 NOT USED
        .IFF
          JSR   R5,COTIMP       ;DO CONO TIM...R0 OR'ED INTO 20-35

        .ENDC

        .IF     EQ,$H

        .IFT
          $L            ;BITS 21 TO 35 OF CNO
        .IFF
        $L!BIT15        ;BITS 21-35 OF CONO...BIT 18 ON, TOO
        .ENDC
        .ENDM   COTIM

.REM    %
        SUBROUTINE TO FORMAT AND DO A CONO TIM,E.
*** WARNING *** TO SAVE PDP11 MEM, THE BITS OF THE PARAM WORD ARE
        NOT THE SAME AS IN THE ACTUAL CONO.  IF MORE BITS ARE DEFINED,
        IT WILL BE NECESSARY TO REWORK THE SUBROUTINE AND CALLING
        MACRO DEF.  THE CALLS NEED NOT BE CHANGED AT SOURCE LEVEL.
        METHOD OF CALL IS VIA A MACRO:
        COTIM   BITS18&19,BITS20-35.
        ON ENTRY AT COTIMP, R0 IS OR'ED INTO THE RESULTING CONO INSTR.
        (BITS 20-35).  R0 IS DESTROYED.
%

COTIM:  CLR     R0              ;NULLS THE OR FUNCTION
COTIMP: PUSH    R1

        MOV     (R5),R1         ;GET PARAM
        BIS     R0,R1   
        BIC     #110000,R1      ;ZAP CURRENTLY UNDEF BITS
        MOV     #COTIMI+2,R0    ;PTR SAVES SPACE & TIME
COCOM:  BIC     #177,(R0)       ;CLR KL10 BITS 12-19
        BIT     #BIT15,(R5)+    ;CURRENTLY, KL10 BIT 18 PDP11 BIT IS
        BEQ     1$              ;BR ON NO NEED TO SET IT
        BIS     #BIT1,(R0)      ;ELSE SET KL10 IT 18 IN CONO
1$:     MOV     R1,-(R0)        ;PUT BITS 20-35 INTO CONO
        XQT                     ;DO THE CONO
        POP     R1


        RTS     R5              ;RETURN
COTIMI: IO10    CONO,TIM,,000000 ;E FIELD SUPPLIED AT RUN TIME

        .EVEN


;SEQ207

.REM    %
        MACRO FOR SUBROUTINE 'COMTR', BELOW.  SEE COTIM FOR DETAILS.
        %
.MACRO  COMTR   $H,$L,$P
        .IF     B,$P
        .IFT
          JSR   R5,COMTR        ;DO CONO MTR...R0 NOT USED
        .IFF
          JSR   R5,COMTRP       ;DO CONO MTR...R0 OR'ED INTO 20-35
        .ENDC
        .IF     EQ,$H
        .IFT
          $L            ;BITS 21 TO 35 OF CONO
        .IFF
          $L!BIT15      ;BITS 21-35 OF CONO...BIT 18 ON, T00
        .ENDC
        .ENDM   COMTR

.REM    %
        SUBROUTINE TO FORMAT AND DO A CONO MTR,E.
        *** WARNING *** SEE COTIM FOR CAUTIONS
        %
COMTR:  CLR     R0              ;NULLS THE OR FUNCTION
COMTRP: PUSH    R1              

        MOV     (R5),R1         ;GET PARAM
        BIS     R0,R1   
        BIC     #100770,R1      ;ZAP CURRENTLY UNDEF BITS
        MOV     #1$+2,R0        ;PTR SAVES SPACE & TIME
        BR      COCOM           ;GO TO COTIM TO FINISH UP
1$:     IO10    CONO,MTR,,000000 ;E FIELD SUPPLIED AT RUN TIME


        .EVEN


;SEQ208

.REM    %
        SUBROUTINE TO SET INTERVAL TIMER OVERFLOW FLOP
        %
STOVRF: COTIM   CIT,TIMON+7777  ;START IT, MAX PERIOD
        LOADAC  3,1$            ;LOAD AC PRGM  (AC0 & 1)
        RUNBIG  AC0,4           ;START & LET RUN FOR A WHILE
        RTS     R5              ;DONE...RETURN
1$:     IO10    CONO,TIM,,40000 ;0--LEAVE TIMER ON, PERIOD 0


        I10     JRST,,,1                ;1--LOOP



.REM    %
        SUBROUTINE TO DO A DIAGNOSTIC READ FOR ONE OF THE METER BOARD
        COUNTERS, AND TO RETURN IT IN R2.  THE TRAILING PARAM FOR
        THIS SUBROUTINE MUST BE THE PROPER DIAG. FUNC. NUMBER.
        %
RDMTR5: MOV     RDMTRX,R0       ;GET PREV DFRD#
        BR      RDMTR3          ;GO & READ
RDMTR4: MOVB    (R5)+,R0        ;FIRST OF 2 DFRD'S
        JSR     R5,RDMTR2       ;DO DO IT
        MOV     R2,R1           ;AVE RESULT IN R1
        MOVB    (R5)+,R0        ;NEXT DFRD
        BR      RDMTR2          ;GO DO IT & RET
RDMTR:  MOV     (R5)+,R0        ;GET DIAG FUNC #
RDMTR2: MOV     R0,RDMTRX       ;SAVE OUR DFRD #
        
RDMTR3: DFRD                    ;DO THE READ
RDMTRA: MOV     -1,R2           ;METER INFO TO R2 (ADR TO BE SUPPLIED)
        RTS     R5              
RDMTRX: 000000                   ;PREVIOUS DFRD #


;SEQ209

.REM    %
        SUBROUTINE TO SET UP FOR 'SINGLE STEP' EXECUTION OF AN AC PROGRAM.
        REQUIRES INITIAL PC AS A TRAILING PARAMETER.
        %
SUSSPM: MRESET                  ;ENTRY PT WHERE AN MR IS REQUIRED FIRST
SUSSP:  MOV     (R5)+,RUNJRS    ;MOVE INIT PC TO A JRST INSTR
SUSSP2: STEXCT  RUNJRS          ;JRST TO AR,CONBUT
        DFXCTT,SETRUN           ;ALSO, SET 'RUN' SO AC PRGM CAN RUN
        RTS     R5              ;RET TO CALLER TO STEP THRU PRGM

.REM    %
        SUBROUTINE TO START THE AC PRGM, AND JUST LET IT RUN.
        %
STRTKL: MOV     (R5)+,RUNJRS    ;SET UP JRST
        JSR     R5 ,STOPKL      ;STOP THE KL
        JSR     R5,SUSSP2
        DFXCTT,STRCLK           ;START THE CLK
        RTS     R5





;SEQ210

.REM    %
        SUBROUTINE TO STOP THE KL10 COMPLETELY.
        %
STOPKL: TENSP                   ;ATTEMPT TO STOP IN THE HALT LOOP
        DFXCTT,STPCLK           ;STOP THE MBOX CLOCK
        DFXCTT,CECLK            ;BRING THE EBOX CLOCK DOWN
        RTS     R5              ;DONE...RETURN


.REM    %
        SUBROUTINE TO START EXECUTION OF AN INSTRUCTION FROM A KNOWN
        HALTLOOP LOCATION.  THIS MEANS THAT IT WILL TAKE A FIXED NUMBER
        OF MBOX CLKS TO ARRIVE AT ANY GIVEN POINT IN THE INSTRUCTION.
        %
MSTEX:  SM                      ;MR, PI CLR, IO BUS CLR, HALTLOOP
        MRESET                  ;STOP CLK, BRING DOWN EBOX CLK
MSTEX2: PUSH    <R2,R3>


        DTEBAS                  ;GET DTE 20 BASE ADR
        MOV     R0,R2           ;SAVE IT
        CLR     R3              ;MBOX CLK CNTR
1$:     STEP                    ;DO 1 MBOX CLK
        INC     R3              ;CNT IT
        BIT     #HALTLP,DIAG1(R2)       ;IN HALT LOOP YET?
        BNE     3$              ;IF YES, GO & CHK CNT
        CMP     R3,#1000        ;TOO MANY CLKS?
        BLE     1$              ;NO...TRY AGAIN
ISEMSG=.        
        
2$:     ERROR   <INSTR START ERR\>

3$:     CMP     R3,(R5)+        ;SAME CNT AS LAST TIME?
        BEQ     4$              ;YES...OK
        TST     -(R5)           ;WAS THERE A LAST TIME?
        BGE     2$              ;IF YES, ERR...CNT NOT SAME
        MOV     R3,(R5)+        ;ELSE SAV CNT
4$:     DFXCTT,CECLK            ;BRING EBOX CLK DWN
        MOV     (R5)+,5$        ;INSTR ADR TO DFWRTT P.L.
        DFWRTT
5$:     000000,LDAR             ;LOAD INSTR TO AR
        DFXCTT,CONBUT           ;PRESS CONTINUE
        POP     <R3,R2>


        RTS     R5


;SEQ211

.REM    %
        SUBROUTINE TO SET UP THE EPT AND UPT BOTH ON PAGE 3.  SETS
        SCRT22 TO POINT TO THE APPROPRIATE WORD AS DEFINED BY THE
        TRAILING PARAMETER.  CHECKS FOR ERRORS.
        %
SETPTW: SM                      ;INIT EVERYTHING
        LOADAC  077000,2$       ;LOAD ACS 11-16
        RUN     11              ;RUN IT
        JSR     PC,CHKP         ;MAKE SURE PROGRAM HALTED
        EXAMT,AC17,SCRT36       ;GET CONI PAG RESULTS
        JSR     PC,CHKED
        CMPB    (R0),#EPT/1000  ;ON PAG 3 OK>
        BNE     1$              ;DIE IF NOT
        ACNDR   AC16            ;GET UPT PAGE #
        CMPB    (R0),#UPT/1000  ;SHD BE PAGE 5
        BNE     1$              ;DIE IF NOT
        MOV     (R5)+,SCRT22    ;SET WORD ADR
        RTS     R5
1$:     PFORCE
        ERROR   <EPT/UPT SETUP ERROR\>

2$:     IO10    CONO,PAG,,3     ;11-EPT ON MEM PAGE 3


        IO10    CONI,PAG,,17    ;12-GET DATA FOR VERIFY


        IO10    DATAO,PAG,,16   ;13-UPT TO PAGE 5


        IO10    DATAI,PAG,,16   ;14-GET DATA FOR VERIFY


        I10     JRST,4,,15      ;15-DONE


        WD36    1000,0040,0005  ;16-FOR DATA0 PAG


        .EVEN


;SEQ212

.REM    %
        SUBROUTINE TO SET THE PROCESS TABLE WORDS FOR THE CURRENT
        COUNTER TO KNOWN VALUES.
        %
CLRPT:  DFXCTT,STRCLK           ;MAKE SURE CLK IS RUNNING FOR DEPOSIT
        MOV     SCRT22,R0       ;SET ADDRESSES INTO DEPOSIT PL'S
        MOV     R0,1$+2
        DEC     R0
        MOV     R0,2$+2
1$:     DPOSVT,000000,3$        ;SET LO ORD PT WD
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        
2$:     DPOSVT,000000,ZERO..    ;SET HI ORD WD
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        RTS     R5              ;DONE...RETURN
3$:     WD36    3770,0000,0000

        .EVEN

;SEQ213
        .SBTTL          METER BOARD "FAST COUNT" SUBROUTINE

.REM    %
        SUBROUTINE TO STEP THE CLOCK AS QUICKLY AS POSSIBLE TO INCREMENT
        A COUNTER TO A DESIRED VALUE.
        FSTCNT REQUIRES 4 PARAMETERS.  FIRST, THE TRAILING PARAMETERS:
          N     N IS A NO. SUCH THAT (DESIRED COUNT) - N IS THE COUNT AT
                        
                WHICH THE SUBROUTINE SWITCHES FROM BURST TO SINGLE
                STEP MODE.  THIS IS DONE TO SAVE REAL TIME.
        DFRD#   THE NUMBER OF THE DFRD NEEDED TO READ THE COUNTER.
        BV      THE DESIRED BURST COUNT FOR STEPPING THE COUNTER
                QUICKLY TO THE POINT WHERE 'N' TAKES OVER.
        NEXT, THE DESIRED COUNT IS EXPECTED IN R0.  FINALLY, THE
        TERMINAL (FINAL) BURST COUNT SHOULD BE POINTED TO BY THE
                ADDRESS CONTAINED IN 'BCLA'.
        %
FSTCNT: PUSH    <R2,R3,R4,R0>   ;SAVE R2-, PUSH DESIRED CNT ON STK




        MOV     R0,R4           ;CALC HI SPEED LIMITING COUNT
        SUB     (R5)+,R4        
        MOV     (R5)+,RDMTRX    ;GET DFRD # FOR USE
        MOV     (R5)+,4$        ;MOVE THE BURST CNT TO PL
        JSR     R5,RDMTR5       ;READ COUNTER
        
;----SECTION TO DECIDE WHAT'S GOING ON.
1$:     MOV     R2,R3           ;SO WE CAN CHK IF CNTR IS CNTG
        CMP     R2,R4           ;SHD WE STOP BURSTING & START STEPPING?
        BLT     3$              ;NO
;----SECTION TO DECIDE WHETHER TO DO FINAL BURST, OR STEP; AND DO THE
;       BURST IF THAT IS THE CASE.
        CLR     R4              ;COUNT=0 IN CASE WE SHD STEP
        MOV     @BCLA,R0        ;GET TERM BURST CNT
        BLT     7$              ;NOT DEFD YET...GO DO IT BY STEPPING
        DEC     R0              ;WE WANT TO CHK THE FINAL TICK
        BLE     2$              ;SKIP BRST IF CNT.LE.0
        JSR     R5,BRST1        ;BURST FOR THE CNT IN R0
2$:     JSR     R5,RDMTR5       ;RD THE CNTR
        INC     R2              ;SHD BE = DESIRED-1
        CMP     R2,(SP)         ;OK?
        BNE     5$              ;NO...C-BIT SET RET
        STEP                    ;ONE MORE TICK
        JSR     R5,RDMTR5       ;CONTR SHD NOW = DESIRED CNT
        CMP     R2,(SP)         ;IS IT?
        BNE     5$              ;NO...C-BIT SET EXIT
        BR      8$              ;ELSE NORM EXIT


;SEQ214

;----SECTION FOR BURSTING & VERIFYING THAT WE ARE COUNTING.
;NOTE:  BURST COUNT SHOULD BE BIG ENOUGH TO FORCE AT LEAST 1
;       COUNTER TICK AND SHOULD BE A LARGE PRIME # OF THE FORM
;       BRSTCNT=128*I+127       WHERE I IS 0,1,2
3$:     JSR     R5,BRST         ;DO BURST UNDER CONTROL OF DIACON
4$:     000000          ;BURST CNT GVN @ RUN TIM
        JSR     R5,RDMTR5       ;GET CNTR
        CMP     R2,R3           ;IS CNTR, IN FACT, CNTG?
        BGT     1$              ;YES...CONT
5$:     SEC                     ;SET C-BIT FOR ERR RE
        BR      9$              
        
;----SECTION TO STEP SLOWLY UNTIL CNTR REACHES DESIRED VALUE
6$:     STEP                    ;DO A SINGLE MBOX CLOCK
        INC     R4              ;UP THE CNT FOR BURSTING THE NXT TIME
        JSR     R5,RDMTR5       ;& GET COUNTER TO R2
7$:     CMP     R2,(SP)         ;HAVE WE REACHED THE DESIRED CNT?
        BLT     6$              ;NO...GO STEP CLK AGAIN
        BGT     5$              ;SOMEHOW PASSED CNT IN 1 TICK...ERR
        MOV     R4,@BCLA        ;SAV BURST CNT FOR NXT TIME
;----EXIT SECTION
8$:     CLC                     ;CLR C-BIT FOR NORMAL RET
9$:     POP     <R0,R4,R3,R2>   ;RESTORE REGS

        RTS     R5


;SEQ215

        .SBTTL          METER BOARD COUNT/READ SUBROUTINE

.REM    %
        METER BOARD (M8538) COUNT/READ SUBROUTINE.  THIS TEST VERIFIES
        THE COUNTING FUNCTION OF THE 8538.  ALSO CHECKED IS THE SERVICE
        REQUEST AND COUNTER CLEAR FUNCTION.  CALLED VIA JSR R4,MCNTRD.
        THIS SUBROUTINE DOES NOT RETURN TO CALLER.  INSTEAD, IT
        JUMPS DIRECTLY TO NORMAL.
        %
.REM    %
        THE IN-LINE PARAMETERS ARE:
        .WORD   DFRD#           ;00-PROPER DIAG. FUNC. READ NUMBER
        .WORD   SUB1            ;02-ADDRESS OF SUBRTN WHICH MAKES COUNTER COUNT
        .WORD   INCRESEL        ;04-PROPER "INCR SEL" VALUE FOR COUNTER
        .WORD   TXTADR          ;06-POINTER TO ASCIZ COUNTER NAME
        .WORD   BCLA            ;10-BURST COUNT LIST ADDRESS

        OTHER PARAMETERS ARE:
        1-THE 22 BIT ADDRESS WHICH POINTS TO THE PROPER EPT/UPT WORD
                IS EXPECTED IN THE AREA 'SCRT22'.
        2-THE EPT/UPT WORD IS ASSUMED EQUAL TO 0 ON ENTRY
        3-ON ENTRY AT MCTRD2, THE VALUE WHICH THE INITIAL CNT SHOULD
                BE IS ASSUMED IN R1.  MCNTRD DEFAULTS TO 1.
        %

;----REGISTER USAGE IS:
;       R0      SCRATCH...ALSO PASSES PARAM TO SUB1
;       R1      SCRATCH
;       R2      RECEIVES THE RESULT OF A DFRD
;       R3      PATTERN TABLE POINTER
;       R4      POINTS TO PARAM LIST
;       R5      SUBTEST NUMBER

MCNTRD: MOV     #1,R1           ;WHAT THE CNTR SHD BE
MCTRD2: MOV     #MBDPP,R3       ;INIT TABLE PTR
        MOV     10(R4),BCLA     ;INIT BURST CNT ADR WORD
        MOV     (R4),RDMTRX     ;GET DFRD # FOR USE
        JSR     R5,RDMTR5       ;GET OUT CNTR VAL **** SUBTEST 1 ****
        TST     R2              ;CNTR SHD HAVE POS VALUE IN IT
        BGT     1$              ;IT DOES...OK
        JSR     PC,MCRFLT       ;ELSE FAULT...CNTR -CNTG
        .WORD   1               ;SUB-SUBTEST # 1
        .ASCIZ  %CNTR DOESNT COUNT%
1$:     CMP     R2,R1           ;S IT WHAT IT SHD BE?
        BEQ     2$              ;YES..OK
        JSR     PC,MCRFLT       ;ELSE FAULT...CNTR NOT SET UP CORRECTLY
        .WORD   2               ;SUB-SUBTEST # 2
        .ASCIZ  %CNTR INIT PROBLEM%


;SEQ216

;----MAIN LOOP:  TELL CNTR TO CNT UP TO NEXT PTRN, THEN CHK & REPEAT
2$:     INSYNC                  ; **** SUBTESTS 2-10 ****
        MOV     (R3),R0 
        SUB     R2,R0   
        JSR     R5,@2(R4)       ;CALL SUBRTN TO COUNT (SUB1)
        JSR     R5,RDMTR5       ;GET CNTR VAL
        CMP     (R3)+,R2        ;IS IT WHAT IT SHLD BE?
        BEQ     3$              ;YES...VERY GOOD
        PUSH    R4              ;SAVE PL ADR

        MOV     -(R3),R4        ;ELSE FAULT...SET UP FOR MSK16R
        MOV     R2,R3
        CLR     R2
        MSK16R                  ;PUT ERR JUNK ON STK
        ERRCOM  PCRLF
        POP     R4              ;RSTR PL ADR

        JSR     PC,MCRFLT
        .WORD   1               ;SUB-SUBTEST # 1
        .ASCIZ  %CNTR/MUX FAILURE%
        .EVEN
3$:     CMP     R3,#MBDPP2      ;ANY MORE PTRNS?
        BLOS    2$              ;YES
;----CNTR WORKS OK...NOW CHECK THE FUNCTIONS WHICH COME AFTER REACHING
;       THE MAXIMUM COUNT.
;----FIRST, SEE IF CNTR BIT 02 SETS & PROPER 'INCR SELS' COME UP.
        INSYNC                  ; **** SUBTEST 11 ****
        MOV     (R4),R0         ;CALC PROPER FUNCTION FOR 'EVENT'
        SWAB    R0      
        BIS     #100+<15.*4>+0,R0       ;CNTR BIT 02 GOES HI
        JSR     R5,DSOBAC       ;STEP OR BURST TO THAT EVENT
        BCC     4$              ;BR IF HAPPENED ON TIME
        JSR     PC,MCRFLT
        .WORD   1               ;SUB-SUBTEST # 1
        .ASCIZ  %CNTR/MUX ERR, HI ORD BIT -SET/SET TOO SOON%
        .EVEN
4$:     JSR     R5,RDMTR                ;GET MORE INFOR (THE INCR SEL BITS)
        MBDFSR
        BIC     #17777,R2       ; **** TEMP FIX TIL ECO INSTALLED ****
        CMP     4(R4),R2        ;PROPER INCR SEL(S) SET?
        BEQ     5$              ;YES..OK
        JSR     PC,MCRFLT
        .WORD   2               ;SUB-SUBTEST # 2
        .ASCIZ  %BAD INCR SEL(S)%


;SEQ217

;----NOW CHECK TO SEE IF CNTR IS RESET, & EPT/UPT WORD IS UPDATED.
5$:     INSYNC                  ; **** SUBTEST 12 ****
        MOV     (R4),R0         ;GET DFRD #
        SWAB    R0              ;CONSTRUCT PARAM FOR 'EVENT'
        BIS     #000!<17*4>!0,R0        ;HI ORD CNTR BIT GOES TO 0
        JSR     R5,DSOBAC       ;STEP CLK AGAIN SO EXAMINES WORK
        JSR     R5,RDMTR5
        DFXCTT,STRCLK           ;START CLK AGAIN SO EXAMINES WORK
MCRCON=.                        ;TEST#18 (MBOX ACCT'G CNT/RD) COMES HERE TO
                        ;FINISH. **** SUBTEST 9 FOR TEST#18 ****
        MOV     #SCRT22,R0
        EXAM                    ;ALSO GET MORE INFO...CHK EPT/UPT WORD
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        
        TST     2(R0)           ;WAS EPT/UPT WORD UPDATED?
        BGE     9$              ;YES
        TST     R2              ;ELSE FAULT...WHAT KIND?
        BGE     6$              ;BR IF CNTR CLRD..UCODE ERR
        JSR     PC,MCRFLT
        .WORD   1               ;SUB-SUBTEST # 1
        .ASCIZ  % NO CNTR SERV REQ%
6$:     MOV     #"LO,8$ ;SET ERR MSG
        MSKDAT  ZERO..,11$       ;CHK LO ORD WD
7$:     JSR     PC,MCRFLT
        .WORD   2               ;SUB-SUBTEST # 2
        .ASCII  %UCODE/EBOX ERR, EPT/UPT %
8$:     .ASCIZ  %HI WD -UPDATED%
        .EVEN
9$:     DEC     SCRT22          ;PT TO HI ORD WD
        MOV     #SCRT22,R0      ;LOOK AT IT
        EXAM
        JSR     PC,CHKED        ;CH EXAM/DPOS
        INC     SCRT22          ;MAKE SCRT22 THE WAY IT WAS FOR LOPS
        MOV     #"HI,8$         ;SET ERR MSG
        MSKDAT  MBONE,ZERO..    ;CHK HI ORD WD
        BCS     7$              ;BR IF BAD
        TST     R2              ;EPT/UPT UPDATED...WAS CNTR CLRD TOO?
        BGE     10$             ;YES...MARVELOUS...ALL DONE
        JSR     PC,MCRFLT       ;ELSE FAULT
        .WORD   3               ;SUB-SUBTEST # 3
        .ASCIZ  %CNTR NOT CLEARED ON SERVICE REQUEST%
10$:    SM                      ;TO LEAVE MACHINE IN KNOWN STATE
        TST     (SP)+           ;RST STK PTR
        NORMAL                  ;NORMAL TEST COMPLETION


;SEQ218

11$:    WD36    0000,0077,0000  ;MASK FOR CHKG MTR BD LO PT WD


MBONE:  WD36    0000,0000,0001


;----THE FOLLOWING PATTERNS ARE COURTESY OF DALE COOK.  THE LAST ONE
;       SERVES TO PREPARE THE COUNTER FOR THE FINAL TESTS.
MBDPP:  .WORD   04210,10421,10756,17036,21042,42104,60741,67021
MBDPP2: .WORD   77777


;----METER BOARD COUNT/READ TEST FAULT SUBROUTINE.  VIA JSR PC
MCRFLT: MOV     @(SP),R0        ;GET SUB-SUBTEST #
        PWTES                   ;SAV ON ERR STK
        ERRMSG  <METER (M8538): >       ;DEVICE NAME


        MOV     6(R4),R0        ;COUNTER NAME ADR TO ERR STK
        ERRCOM  PNTAL
        MOV     (SP),R0         ;FAULT TYPE TO ERR STK
        TST     (R0)+           ;BUMP ADR TO PASS SUB-SUBTEST #
        ERRCOM  PNTAL
        ERRCOM  PCRLF

        ERRMSG  <TRUE FAULT PC=>

        POP     R0

        SUB     #6,R0           ;UPDATE PC VALUE
        ERRCOM  PNTOCT          ;TO ERR STK
        FAULT                   ;TO DIACON


;SEQ219

        .SBTTL          METER BOARD ONE TIME INIT
.REM    %
        ONE TIME INIT FOR THE METER BOARD DIAGNOSTICS
        %
I.0:    PFORCE
;-----PRINT TITLE
        SWITCH                  ;GET SWITCHES
        BIT     #CHAIN,R0               ;IS CHAIN MODE SWITCH ON?
        BNE     1$              ;IF YES, SKIP TITLE PRINT
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TMETER\METER (M8538) DIAGNOSTIC >

        PNTVER                  ;OUTPUT VERSION.REVLEVEL
        PMSG    <       \SWITCHES:>

        SWITCH,PNTOCT,PCRLF
;-----SECTION TO LOAD OR VERIFY EXISTING MICROCODE.
1$:     JSR     R5,INITM        ;INIT THE SUBROUTINES
        MOV     .DAT3,RDMTRA+2  ;INIT THE RDMTR SUBRTN DFRD ADR
        CLR     R2              ;ZAP UCODE LOADED SWTCH
2$:     SM                      ;TRY A SM
        BCC     4$              ;BR IF OK
        TST     R2              ;ELSE ERR...DID WE LOAD UCODE?
        BEQ     3$              ;BR IF NO...GO LOAD & RETRY
        ERROR   <MICRO-CODE START ERROR.\>


3$:     MOV     #17$,R0         ;ELSE LOAD UCODE VIA A PROGRAM CMD
        PRGCMD
        BCS     8$              ;BR IF CMD NOT SUCCESSFUL
        INC     R2              ;IND WE LOADED UCODE
        BR      2$              ;GO RETRY UCODE
4$:     XQT     16$             ;DO APRID INSTR
        BCC     5$              ;BR IF SUCCESSFUL
        TST     R2              ;DID WE LOAD UCODE?
        BEQ     3$              ;NO...GO LOAD IT & RETRY
        ERROR   <APR ID INSTRUCTION ERROR.\>

5$:     EXAMT,AC17,SCRT36       ;GET APRID RESULTS
        BCC     6$              ;BR IF EXAMINE OK
        TST     R2              ;ELSE DID WE LOAD UCODE?
        BEQ     3$              ;NO...GO LOAD IT
        ERROR   <CANNOT EXAMINE AC.\>

6$:     MOV     SCRT36+2,R0     ;EXTRACT UCODE VERSION #
        SR      R0,2


;SEQ220

        BIC     #177000,R0
        CMP     R0,UCODE        ;IS THIS THE CORRECT MICRO-CODE VERSION?
        BEQ     9$              ;YES...CONTINUE
        TST     SCANWD          ;IN GENERATION PASS?
        BNE     9$              ;YES...IGNORE MISCOMPARE
7$:     TST     R2              ;DID WE LOAD UCODE?
        BEQ     3$              ;BR IF NO... GO LOAD IT
8$:     PMSG    <LOAD MICRO-CODE VERSION _>

        MOV     UCODE,R0
        PNTOCS  
        PMSG    < AND RESTART DIAGNOSTIC.\>

        PRGHLT
9$:     MOV     R0,CONSOL-2     ;SAV UCODE VERS #
;-----MAKE SURE MEMORY IS PRESENT & CONFIGURED
        DPOSVT,20,MBACTM        ;TRY A DEPOSITY TO MAKE SURE THAT...
                        ;...MEMORY IS CONFIGURED.
        BCC     10$             ;BR IF IT IS
        PMSG    <CONFIGURE MEMORY & RESTART\>

        PRGHLT
;-----SET UP THE CACHE IF PRESENT & DESIRED
10$:    MOV     #-1,CSHFLG      ;TAKE CARE OF THE CACHE SITUATION
        JSR     R5,RSTMBX       ;RESET MBOX, SET CACHE LOOK/LOAD
        DFRDT,170               ;DO WE HAVE CACHE?
        TBIT    30


        BEQ     11$             ;BR IF NO
        SWITCH                  ;WE HAVE CACHE...DOES OPR WANT TO USE?
        BIT     #INHCSH,R0
        BEQ     12$             ;BR IF YES
11$:    CLR     CSHFLG          ;ELSE SHUT OFF CACHE FLAG
        SM                      ;CLEAR OUT MACHINE
        BR      13$             ;EXIT
12$:    CRRONE  0               ;ENABLE JUST CACHE BANK 0
        XQT     CSHALW          ;SET CACHE LOOK/LOAD
        INVAL                   ;INVALIDATE CACHE CONTENTS
;-----SECTION TO PRINT ALL THE REST OF THE TITLE JUNK.
13$:    SWITCH                  ;GET SWITCHES AGAIN
        BIT     #CHAIN,R0       ;CHAIN MODE SET?
        BNE     15$             ;IF YES, DONT PRINT THIS JUNK
        PMSG    <UCODE VERSION >


;SEQ221

        MOV     CONSOL-2,R0
        BIC     #177400,R0
        PNTOCS
        PNTCI,", 
        TST     CSHFLG          ;CACHE OR NO CACHE?
        BNE     14$             ;CACHE
        PMSG    <NO >
14$:    PMSG    <CACHE, CLOCK RATE >


        CLKPRM
        MOV     (R0),R0
        BIC     #177774,R0
        PNTNBR
        PMSG    <, PROCESSOR ID #>

        MOV     SCRT36,R0
        BIC     #170000,R0
        PNTDEC
        PCRLF
15$:    PNORML
        RTS     PC
16$:    WD36    7000,0000,0017  ;APRID AC17


17$:    .ASCIZ  %P DIAGB.RAM%   ;MODEL B DIAGNOSTIC UCODE
        .EVEN
UCODE:  156                     ;ACCEPTED VERSION OF MICROCODE


;SEQ222

        .SBTTL          COMMAND PARSER FOR / TYPE CMDS TO DIAGNOSTIC

.REM    %
THE COMMANDS CURRENTLY RECOGNIZED ARE:
/P              DO A ROUTINE TO AID IN PATCHING THE DIAGNOSTIC.

TERMINATING THE LAST INPUT TO A COMMAND WITH AN ALTMOD (ESCAPE) CAUSES
THE DIAGNOSTIC TO BE STARTED IMMEDIATELY.
        %
;-----GET THGE COMMAND LETTER(S)        & GO TO THE CORRECT ROUTINE.
USERSW: TTICHR                  ;GET THE FIRST CHAR
        CMP     R0,#'P          ;PATCHCMD?
        BEQ     2$              ;YES...DO IT
;-----COMMAND NOT RECOGNIZED.
        PMSG    <\?\>           ;SEN ERR MSG

        TTPINI                  ;RESET I/0
        RTS     PC              ;RETURN TO DIACON
;-----SECTION FOR P COMMAND.
$$PATCH=1                       ;FORCE ASEMBLY OF PATCH ROUTINE
2$:     JSR     R5,PATCH        ;CALL PPATCHER ROUTINE
;       BR      FDCB            ;EXIT GRACEFULLY
;-----SECTION TO EXIT TO DIACON OR THE DIAGNOSTIC.
FDCB:   TTBACK                  ;COME HERE AFTER NUMERIC PARAMS
FDC:    TTICHR                  ;HERE AFTER NON-NUMERIC PARAMS
        CMP     R0,#ALTMOD      ;CMD TERMINATED WITH ALTMODE?
        BEQ     1$              ;YES...GO START DIAGNOSTIC
        RTS     PC                      ;ELSE JUST RETURN TO DIACON CMD PARSE
1$:     POP     R0              ;DEL RET ADR FROM STK

        JMP     MX..            ;GO START DIAGNOSTIC
;-----HELP COMMAND EXTENSION.
USRHLP: PMSG    <\/P	PATCH DIAGNOSTIC\>

        RTS     PC


;SEQ223


        .SBTTL          QUICK MR TEST FOR METER BOARD

.REM    %
        METER BOARD TEST#1 IS A QUICK MASTER RESET TEST USED TO
        VERIFY THAT EVERYTHING ON THE BOARD IS CLEAR SO THAT THE
        REST OF THE TESTS MAY RUN.

        %

T.1:    SM                      ;MR. IOBUS & PI CLR, STRCLK
        TDELAY                  ;WAIT FOR ANYTHING TO HAPPEN (SHOULDN'T)
        MOV     #MBDFTB,R1      ;DFRD # INIT
        MOV     #5$,R3          ;EXPECTED VALUE PTR
1$:     MOV     R1,R0           ;DFRD # TO PARAM REG
        JSR     R5,RDMTR3       ;DFRD 20-35 TO R2 (METER INFO)
        CMP     R2,(R3)+        ;SAME AS EXP VAL?
        BEQ     4$              ;BR IF SAME...OK
        MOV     -(R3),R3        ;EXPD TO R3
        XFAULT  3$,<MR FAILURE> ;DUMP ERR INFO & PUNT
                
        
3$:     F.NR1
        .ASCIZ  %DFRD NUMBER%
        F.NR2
        .ASCIZ  %DFRD BITS 20-35 ARE%
        F.NR3
        .ASCIZ  %BUT SHOULD BE%
        F.INDI,MBEX1
4$:     INC     R1              ;NXT DFRD #
        CMP     R1,#MBDFSR      ;DONE?
        BLE     1$              ;BR IF NOT
        NORMAL                  ;ELSE TEST PASSES

5$:     .WORD   1,0,0,0,0,0,0,2000      ;METER DFRD EXPD VALUES


;SEQ224



;SEQ225

        .SBTTL          PERIOD REGISTER DATA PATH TEST
.REM    %
        METER BOARD TEST#2 CHECKS THE DATA PATH:  EBUS, EBUS LATCHES,
        PERIOD REGISTER, & 1/8 MUX TO EBUS.
        %
;-----INIT FOR TEST#2 JUST TRIES TO SET ALL BITS IN THE PATH.
I.2:    SM                      ;RESET THE MACHINE
        COTIM   0,7777
        RTS     PC
;-----METER BOARD TEST#2
T.2:    INSYNC                  ; **** SUBTEST 1 ****
        CLR     R0              ;PATTERN OF ZEROS
        JSR     R4,3$           ;DO LOCAL DIRTYWORK SUBROUTINE
        INSYNC                  ; ***** SUBTEST 2 *****
        MOV             #7777,R0                ;ALL ONES PATTERN
        JSR     R4,3$           ;LOCAL DIRTYWORK SUBROUTINE
        SBINI   12.             ;INIT SLIDING BIT PTRN GENERATOR
1$:     SB                      ;GET PTRN
        BCC     2$              ;BR IF MORE PTRNS
        NORMAL                  ;ELSE DONE
2$:     MOV     (R0),R0         ;PLACE IN R0 FOR COTIMP
        INSYNC                  ; **** SUBTESTS 3-26 *****
        JSR     R4,3$           ;DO LOCAL DIRTY WORK SUBROUTINE
        BR      1$              ;LOOP TIL PTRNS EXAUSTED
;----LOCAL DIRTWORK SUBROUTINE...SETS PR THEN CHECKS IT.
3$:     MOV     R0,PRSCRT       ;FOR MSKDAT
        COTIM   0,0,P           ;OR R0 IN, THEN DO AS ABOVE
        MSKDF   MBDFPR,PRSCRT,5$        ;CHK
        BCC     4$              ;LOOP IF NO ERR
        XFAULT  MBEX1,<PER REG PATRN CHK FAILED>
4$:     RTS     R4              ;RET
5$:     WD36    7777,7777,0000


        .EVEN


;SEQ226



;SEQ227

        .SBTTL          METER BOARD TIME BASE CLOCK TESTS
.REM    %
        METER BOARD TEST#3 CHECKS THE ON/OFF FUNCTION OF  TIME BASE
        %
I.3:    JSR     R5,SETPTW       ;INIT EPT/UPT
          EPTTB         ;SCRT22 PTS     TO THE TIM BASE WD
        RTS     PC
;-----METER BOARD TEST#3
T.3:    INSYNC                  ; **** SUBTEST 1 ****
        COMTR   0,TBON          ;TRY TO TURN IT ON
        JSR     R5,RDMTR4       ;DO THE FOLLOWING 2 DFRDS
        .BYTE   MBDFTB,MBDFAD
        BIT     #TBON,R2        ;CHK ECHO TO SEE IF ON
        BNE     1$              ;BR ON
        XFAULT  MBEX1,<CANT TURN ON TIME BASE>
1$:     INSYNC                  ; **** SUBTEST 2 ****
        COMTR   0,TBOFF         ;TURN TIME BASE OFF
        MOV     R1,R3           ;SAV CNTR VALUE
        JSR     R5,RDMTR4       ;DO THE FOLLOWING 2 DFRDS
        .BYTE   MBDFTB,MBDFAD
         BIT    #TBON,R2        ;IS IT REALLY OFF?
        BEQ     2$              ;YES...OK
        XFAULT  MBEX1,<CANT TURN OFF TIME BASE, CONO-MTR>

2$:     INC     R5              ; **** SUBTEST 3 ****
        CMP     R1,R3           ;WAS CNTR RUNNING WHEN ON?
        BNE     3$              ;YES
        XFAULT  MBEX1,<TIME BASE DOESNT RUN WHEN ON>



;SEQ228

3$:     INSYNC                  ; **** SUBTEST 4 ****
        TDELAY                  ;WAIT
        JSR     R5,RDMTR        ;GET IT AGAIN
        .WORD   MBDFTB
        CMP     R2,R1           ;HAS IT CHANGED?
        BEQ     4$              ;NO...GREAT
        XFAULT  MBEX1,<TIME BASE RUNS WHEN OFF>
4$:     NORMAL



;SEQ229



;SEQ230

.REM    %
        METER BOARD TEST#4 & TEST#5 CHECK CLEARING FUNCTIONS FOR THE
        TIME BASE COUNTER.
        %
I.4:    JSR     R5,MSTEX        ;STRT INSTR TO RUN TIM BASE FROM MR
          .WORD 23,TBCLRI       
        MOV     #1$,BCLA        ;ADR OF BRST CNT LST
        MOV     #77777,R0       ;DESIRED COUNT
        JSR     R5,FSTCNT       ;COUNT UP TO DESIRED VALUE
          .WORD 16.,MBDFTB,577
        RTS     PC              ;INIT DONE
1$:     .WORD   424             ;BURST COUNT

.REM    %
        METER BOARD TEST#4 CHECKS MASTER RESET
        %
T.4:    INSYNC                  ; **** SUBTEST ****
        MRESET
        JSR     R5,RDMTR        ;GET TIME BASE STATUS
        MBDFAD
        BIT     #TBON,R2        ;IS IT STILL ON?
        BEQ     X.1             ;NO..OK
        PWTES   #1              ;PARAM WD TO ERR STK
        XFAULT  MBEX1,<MR, TIME BASE STILL ON>


;SEQ231




;SEQ232

;*****NOTE**** - SEQ232 MICROFICHE IS BLANK.M

;SEQ233

;-----INIT CONSISS OF CLEARING THE EPT WORD FOR THE TIME BASE, AND
;       PUTTING A POSITIVE VALUE INTO THE TIME BASE TO BE CLEARED.
I.5:    COMTR   0,TBON          ;TURN ON THE TIME BASE
        RTS     PC              ;START TEST WHILE IT COUNTS

.REM    %
        METER BOARD TEST#5 CHECKS THE CLEAR-TIME-BASE FUNCTION  
        %
T.5:    INSYNC                  ; ***** SUBTEST 1 *****
        COMTR   0,TBOFF+TBCLR   ;SHUT OFF TIME BASE & CLEAR IT

X.1:    JSR     R5,RDMTR        ;DIAG READ TO GET TIME BASE COUNTER
        .WORD   MBDFTB
        CMP     R2,#1           ;TIME BASE IS?
        BEQ     1$              ;CLEARED TO 1...OK
        PWTES   #2              ;PARAM WD TO ERR STK
        XFAULT  MBEX1,<TIME BASE CNTR -CLEARED>
1$:     NORMAL 


;SEQ234



;SEQ235

.REM    %
        METER BOARD TEST#6 CHECKS THE FUNCTION OF THE TIME BASE CNTR.
        %
I.6:    JSR     R5,CLRPT                ;CLEAR THE LO ORD EPT WORD
        RTS     PC                      ;INIT DONE
;-----METER BOARD TEST#6
T.6:    INSYNC                          ; **** SUBTEST 1 ****
        JSR     R5,MSTEX                ;SET UP EXEC OF CONO MTR
        23,TBCLRI               ;CNT MR-HALTLOOP, PTR TO INSTR
        FIND    <MBDFTB,34.,1>          ;STEP TIL CNTR=2, THIS SYNCS THE...
        
                                ;...COUNTER & CLK DIVIDER
        BCS     10$             ;BR IF COUNTER NOT WORKING AT ALL
        FIND    <MBDFTB,35.,1>  ;STEP TIL CNTR=3, THE NUMBER OF MBOX CLK
                                ;...TICKS IS NOW IN R0.
        BCS     10$             ;UNLESS IT DIDN'T WORK AT ALL
        CMP     R0,#30.         ;THIRTY CLOCK TICKS PER "MICROSECOND"?
        BEQ     6$              ;YES...OK
        CMP     R0,#25.         ;25????
        BNE     10$             ;NO...CNTR NO TWORKING AT ALL
        XFAULT  MBEX1,<CLOCK DIVIDER JUMPER IS PROBABLY UPSIDE-DOWN>
10$:    XFAULT  MBEX1,<CLK DIVIDER OR TIME BASE CLK NOT WORKING>
6$:     MOV     #3,R1           ;WHAT THE CNT SHD BE
              
        JSR     R4,MCTRD2       ;DO THE COUNT/READ TEST
        .WORD   MBDFTB,3$,0,5$,2$       ;PARAMS
2$:     .WORD   36,74           ;BURST COUNT LIST
;-----'SUB1' FOR COUNT/READ
3$:     PUSH    R0              ;SAV INCREMENTAL CNT

4$:     MOV     #30.,R0 ;BRST CNT FOR 1 USEC TICK
          
        JSR     R5,BRST1                ;TICK OFF 1 USEC
        DEC     (SP)            ;LOOP UNTIL INCRMNTL VNT EXPIRES
        BGT     4$              
        TST     (SP)+           ;RST SP
        RTS     R5              ;RET


5$:     .ASCIZ  %TIME BASE %
TBCLRI: IO10    CONO,MTR,,3000  ;TBON+TBCLR


        .EVEN


;SEQ236




;SEQ238

        .SBTTL          METER BOARD INTERVAL TIMER TESTS
.REM    %
        METER BOARD TEST#7 CHECKS THE ON/OFF FUNCTION OF THE INTERVAL
        TIMER.  IT ALSO CHECKS TTHAT THE TIMER DOESN'T RUN WHEN OFF.
        %
;-----INIT FOR TEST#7 JUST CLEARS OUT EVERYTHING.
I.7:    MRESET
        RTS     PC
;-----METER BOARD TEST#7
T.7:    INSYNC                  ; **** SUBTEST 1 ****
        COTIM   0,TIMON+7777    ;TURN ON, MAX PERIOD.  GET ECHO
        JSR     R5,RDMTR4               ;DO THE FOLLOWING 2 DFRDS
        .BYTE   MBDFIT,MBDFPR
        BIT     #TIMON,R2               ;IS IT ON?
        BNE     1$              ;YES...OK
        XFAULT  MBEX1,<CAN'T TURN ON INTRVL TIMER>
1$:     INSYNC                  ; **** SUBTEST 2 ****
        TDELAY                  ;WAIT A WHILE
        JSR     R5,RDMTR                ;GET CUR I.T. VALUE
        MBDFIT
        CMP     R2,R1           ;IS THE CUR CNTR DIF FROM PREV?
        BNE     2$              ;YESM, CNTR RUNS WHEN ON...VERY GOOD
        XFAULT  MBEX1,<INTRVL TIMER DOESNT RUN WHEN ON>
2$:     INSYNC                  ; **** SUBTEST 3 ****
        COTIM   0,7777          ;SHUT OFF TIMER
        JSR     R5,RDMTR4               ;DO THE FOOLLOWING 2 DFRDS
        .BYTE   MBDFIT,MBDFPR
        BIT     #TIMON,R2               ;IS TIMER OFF?
        BEQ     3$              ;YES...OK
        XFAULT  MBEX1,<CAN'T TURN OFF INTRVL TIMER>


;SEQ239

3$:     TDELAY                  ;WAIT TO SEE IOF TIMER STILL RUNNING
        INSYNC                  ; **** SUBTEST 4 ****
        JSR     R5,RDMTR        ;GET CUR I.T. VALUE
          MBDFIT
        CMP     R2,R1           ;HAS CNTR CHANGED?
        BEQ     4$              ;NO, TEHREFORE IS REALLY OFF
        XFAULT  MBEX1,<INTRVL TIMER RUNS WHEN OFF>
4$:     NORMAL



;SEQ240




;SEQ241

.REM    %
        METER BOARD TEST#8 CHECKS THE MASTER RESET WITH RESPECT TO
        THE INTERVAL TIMER.
        %
;-----INIT TEST#8 ...SET EVERYTHING MR IS SUPPOSED TO RESET.
I.8:    JSR     R5,STOVRF       ;SET TIMER DONE & OVRFLW
; ********** THIS SECTIONS NEEDS WORK **********
I.9:    COTIM   CIT,TIMON+7777  ;SET PERIOD REG & TIMER ON
        TDELAY                  ;WAIT FOR COUNT TO ACCUMULATE
        RTS     PC

;-----METER BOARD TEST#8
T.8:    INSYNC                  ; **** SUBTEST 1 ****
        MRESET                  ;TRY THE RESET
        MSKDF   MBDFIT,ZERO..,B1835C
        ROR     R2              ;SAV STATUS OF MASK OPERATION
        MSKDF   MBDFPR,ZERO..,B1835C
        BCS     1$              ;ERR FND IF C-BIT SET
        ROL     R2              ;GET BACK STATUS OF FIRST MSKDF
        BCC     X.2             ;BR IF NO ERR THERE EITHER
1$:     XFAULT  MBEX1,<INTRVL TIM, MR FAILED>
X.2:    NORMAL
B1835C: WD36    7777,7700,0000  ;BITS 18-35 CLR...GIVES RH OF DFRD


        .EVEN



;SEQ242



;SEQ243

;*****NOTE**** - SEQ243 MICROFICHE IS BLANK.


;SEQ244

.REM    %
        METER BOARD TEST#9 CHECKS THE FUNCTION OF THE CLEAR-INTERVAL-
        TIMER BIT OF THE CONO TIM INSTRUCTION.
        %
T.9:    INSYNC                  ; **** SUBTEST 1 ****
        COTIM   CIT,7777        ;TRY TO CLR THE INTRVL TIMER
        MSKDF   MBDFIT,ZERO..,B1835C    ;CHECK
        BCC     X.2             ;BR IF OK
        XFAULT  MBEX1,<CLR-INTRVL-TIMER BIT FAILED>


;SEQ245



;SEQ246

.REM    %
        METER BOARD TEST#10 CHECKS THE DATA PATH FOR THE INTERVAL TIMER
        PRIORITY INTERRUPT ASSIGNMENT.
        %
;-----INITIALIZATION JUST SETS THE PATH TO ZERO
I.10:   COMTR   0,0
        RTS     PC
;-----METER BOARD TEST#10
T.10:   MOV     #7,R2           ;INIT PIA #
1$:     MOV     R2,PRSCRT       ;FOR MSKDAT
        INSYNC                  ; ***** SUBTESTS 1-8 *****
        MOV     R2,R0           ;FOR COMTRP
        COMTR   0,0,P   ;P CAUSE OR 'ING OF R0 & BITS 20-35
        MSKDF   MBDFAD,PRSCRT,3$                ;CHK THE PIA VS WHAT IT SHD B
        BCC     2$              ;BR  NO ERR
        XFAULT  MBEX1,<INTRVL TIMER PIA DATA PATH ERR>
2$:     DEC     R2              ;MORE TO GO?
        BGE     1$              ;YES
        NORMAL
3$:     WD36    7777,7777,7770


        .EVEN



;SEQ247



;SEQ248

.REM    %
        METER BOARD TEST#11 CHECKS THE INTERVAL TIMER WITH RESPECT TO
        THE DONE & OVERFLOW FLOPS. AND THE ABILITY TO CLEAR THEM.  IT
        ALSO CHECKS THE ABILITY OF THE TIMER TO CAUSE A VECTOR INTERRUPT
        INITIALIZATION CONSISTS OF SETTING UP THE EPT, AND LOADING A
        PROGRAM WHICH WILL ALLOW THE VECTOR INTERRUPT TO OCCUR.
        %
I.11:   JSR     R5,SETPTW               ;SET UP EPT/UPT
        EPTITV                  ;SCRT22 POINTS TO THE VECT INTR WORD
        MOV     SCRT22,1$               ;PUT THE ADR INTO THE MOVEM INSTR
        LOAD    AC11,1$,6               ;LOAD THE AC PRGM
        RTS     PC
1$:     I10     MOVEM,16,,000000 ;11-PUT JSP INTO TIMER TRAP WD


        IO10    CONO,PI,,1377           ;12-PI SYS ON, ALL CHANS OFF


        IO10    CONO,MTR,,1             ;13-TIMER ON PI CHAN 1


        IO10    CONO,PI,,2100           ;14-PI CHAN 1 ON




CIPI:   IO10    CONI,PI,,17     ;15-PI STATUS TO AC17


        I10     JSP,10,,15              ;16-LOOP


;-----METER BOARD TEST#11
T.11:   INSYNC                  ; ***** SUBTEST 1 *****
        JSR     R5,STOVRF       ;DO INSTRS TO SET DONE & OVRFLW
        JSR     R5,RDMTR                ;GET TIMER STATUS
        MBDFPR
        BIT     #TIMOVR,R2      ;OVERFLOW SET?
        BNE     1$              ;YES..OK
        XFAULT  MBEX1,<TIMER-OVRFLW CANT BE SET>
1$:     INC     R5              ; ***** SUBTEST 2 *****
        BIT     #TIMDON,R2      ;DONE SET?
        BNE     2$              ;YES...OK
        XFAULT  MBEX1,<TIMER-DONE -SET ON OVRFLW>


;SEQ249

2$:     INSYNC                  ; **** SUBTEST 3 ****
        COTIM   CIT,TIMON+7777  ;FORCE COMPARATOR MISMATCH
        JSR     R5,RDMTR5       ;GET PR & STATUS BITS
        BIT     #TIMDON,R2      ;CHK RESULT...DONE STILLL SET?
        BNE     3$              ;YES...OK
        XFAULT  MBEX1,<TIMER-DONE RST BY -MATCH>
3$:     INSYNC                  ;**** SUBTEST 4 ****
        JSR     R5,STRTKL       ;START AC PRGM
        AC11
        EXAMT,AC17,SCRT36       ;GET AC17 (CONI PI DATA)
        BIT     #BIT14,(R0)     ;PI IN PROGRESS ON CHAN 1?
        BNE     4$              ;YES...OK
        XFAULT  6$,<TIMER-DONE, NO PI IN PRGRS>
4$:     INSYNC                  ; **** SUBTEST 5 ****
        COTIM   0,CLRDON        ;OFF THE TIMER, CLR DONE
        JSR     R5,RDMTR5       ;GET PR & STATUS BITS
        BIT     #TIMDON+TIMOVR,R2       ;DONE/OVRFLW STILL SET?
        BEQ     5$              ;NO...FANTASTIC
        XFAULT  MBEX1,<CONO TIM,CLRDON; DONE/OVRFLW -RST>
5$:     NORMAL
6$:     F.36N0                  ;DUMP PI DATA
        .ASCIZ  /CONI PI WORD/
        .EVEN
        F.INDI,MBEX1



;SEQ250


;SEQ251


.REM    %
        METER BOARD TEST#12 IS THE COUNT READ TEST FOR THE INTERVAL TIMER.
        INITILIZATION JUST CLEARS UP THE PI SYSTEM FROM THE LAST TEST.
        %
I.16:                   ;INIT SAME AS FOR TEST#12
        
I.12:   SM              ;MR, I0 BUS RST, PI CLR
        RTS     PC              


;-----METER BOARD TEST#12
        
T.12:   MOV     #MBDPP,R3       ;INIT PTRN PTR
        MOV     #6$,BCLA        ;INIT TERMNL BURST CNT ADR
1$:     MOV     (R3),R0         ;PTRN TO CONO TIM
        BIC     #170000,R0      ;SHUT OFF TRASH
        BIS     #TIMON+CLRDON,R0        ;MAKE SURE CLRDON & TIMER-ON BITS SET
        MOV     R0,7$           ;SET UP CONO TIM
        INSYNC                  ; **** SUBTEST 4N+1 *****  (N=0,8)
        JSR     R5,MSTEX        ;INIT EXEC OF CONO
        .WORD   23,7$           ;CNT MR-HALTLOOP,PTR TO CONO
        SOBAC   <MBDFIT,35.,1>,530        ;STEP TIL CNTR=1, IE BIT0 COMES UP
        BCC     2$              ;BR IF EVENT HAPPENED WHEN EXPECTED
        XFAULT  8$,<INTRVL TIMER INIT/CNTR/MUX ERR>
;-----STEP COUNTER UP TO PATTERN DESIRED
2$:     INC     R5              ; **** SUBTESTS 4N+2 *****
        MOV     (R3)+,R0        ;DESIRED CNT TO R0 FOR 'FSTCNT'
        BIC     #170000,R0      ;SHUT OFF JUNK
        JSR     R5,FSTCNT       ;MAKE IT CNT
         99.,MBDFIT,24749.
        BCC     3$              ;BR IF CNTD PROPERLY
        XFAULT  8$,<INTRVL-TIMER CNTR/MUX ERR>
;-----MAKE SURE DONE COMES UP
3$:     INSYNC                  ; **** SUBTESTS 4N+3 *****
        SOBAC   <MBDFPR,22.,1>,36         ;STEP OR BRST&CHK TIL DONE
        BCC     4$              ;BR IF DONE CAME UP PROPERLY
        XFAULT  MBEX1,<TIMER-DONE -SET ON MATCH>



;SEQ252

;-----CHECK FOR OVERFLOW SET
4$:     INC     R5              ; ***** SUBTESTS 4N+4 *****
        JSR     R5,RDMTR
         MBDFPR
        BIT     #TIMOVR,R2      ;OVRFLW SET?  (MIGHT BE ON PTRN=7777)
        BEQ     5$              ;NO...OK
        XFAULT  MBEX1,<TIMER-OVRFLW SET ON DONE>
5$:     ADD     #2,BCLA         ;#2,BCLA        ;BUMP ADR OF TERM BURST CNT
        CMP     R3,#MBDPP2      ;MORE PTRNS?
        BLOS    1$              ;YES...GO AGAIN
        NORMAL
6$:     .WORD   026242          ;Brb
        .WORD   016271          ;Ary
        .WORD   057133          ;Ey[
        .WORD   046355          ;Dsm
        .WORD   035236          ;Cj^
        .WORD   012673          ;AV
        .WORD   047437          ;D _
        .WORD   036661          ;Cvq
        .WORD   036213          ;CrK
7$:     IO10    CONO,TIM,,400000        ;CONO TIM,CIT+TIMON+CLRDON+PTRN


        .EVEN
        
8$:     MBDFIT,F.INDI,MBEX1


;SEQ253



;SEQ254

        .SBTTL          METER BOARD ACCOUNTING LOGIC TESTS
.REM    %
        METER BOARD TEST#13 CHECKS THE DATA PATH THRU THE ACCOUNTING FLOPS
        %
;-----INITIALIZATION JUST SETS THE PATH TO 0
I.13:   JSR     R5,SETPTW               ;SET UP EPT/UPT
        UPTEA                   ;SCRT22 PTS TO EBOX ACCTG WD IN UPT
        RTS     PC
;-----METERBOARD TEST#13
T.13:   MOV     #PIACTE+EXACTE+ACCTON,R3        ;BITS INCLUDED IN CHK
1$:     INSYNC                  ; **** SUBTESTS 1-8 ****
        MOV     R3,PRSCRT       ;FOR MSKDAT
        MOV     R3,R0           ;FOR COMTRP
        COMTR   LAC,0,P         ;P FORCES OR OF R0 & CONO 20-35
        MSKDF   MBDFAD,PRSCRT,MBACTM    ;CHK
        BCC     2$              ;BR OK
        XFAULT  MBEX1,<ACCT FLOPS DATA PATH FAILURE>
2$:     SUB     #ACCTON,R3              ;SUB LST SIGNIF BIT FOR NXT PTRN
        BGE     1$              ;LOOP UNTIL DONE
        NORMAL


;SEQ255

                



;SEQ256

.REM    %
        METER BOARD TEST#14 TESTS THE ACCOUNTING FLOP LOGIC.
        METER BOARD TEST#14 INITIALIZATION LOADS THE "PI IN PROGRESS"
        AC PRGM (NOT ON LOOPS), AND DOES A SM TO CLEAN THINGS UP.
        THE TEST ITSELF IS TABLE DRIVEN (SEE BELOW).  THE TABLE
        BYTES DIRECT THE AC PROGRAM TO SET UP THE DESIRED MACHINE STATE 
        TO TEST THE DESIRED COMBINATION OF THE ACCOUNTING CONTROL BITS.
        %
I.23:                   ;SAME FOR TEST#23
I.14:   RTS     PC              ;LOOP ENTRY PT...SKP LOAD
LPIIP:  LOADAC  67777,PIIPRG    ;LOAD AC PRGM.  (AC0-16 LESS 14)
        RTS     PC


;SEQ257

;-----AC PROGRAM TO SET PI 1-7 IN PROGRESS.  REQUIRES PI LEVEL IN
;       AC 17 BEFORE EXECUTION.  A 0 RESULTS IN A NO PI CONDITION.
PIIPRG: I10     MOVEI,14,,3042  ;0-SET UP AOBJN CNTR/PTR


        I10     HRLI,14,,777762 ;1-


        I10     MOVEM,13,,0,14  ;2-SET UP LOC 40+2N IN EPT, PAGE 3


        I10     AOBJN, 14,,2    ;3-LOOP UNTIL DONE


        IO10    CONO,PI,,10000  ;4-CLR PI SYS


        IO10    CONO,PI,,2377;5-PI SYS ON, CHANS 1-7 ON


        I10     JUMPLE,17,,13   ;6-AC17.LE.0 MEANS A NO-PI STATE


        I10     MOVEI,14,,200   ;7-ELSE SET UP CHAN BIT FOR CONO


        I10     MOVN,17,,17     ;10-


        I10     LSH,14,,0,17    ;11-


        IO10    CONO,PI,,4000,14        ;12-REQ INT ON GVN CHAN...SHD OCCUR IMM


PIIPG2: I10     JSP,14,,13      ;13-LOOP

                        ;14-WORK REGISTER
;-----SMALL AC PRGM TO SET USER MODE
UMACPR: I10     JRST,2,,0,16    ;15-JUMP & RSTR FLAGS


        WD36    0100,0000,0013  ;16-FLAGS=USER MODE, PC=13


                        ;17-DESIRED PI LEVEL GOES HERE


        .EVEN


;SEQ258

;-----METER BOARD TEST#14
T.14:   MOV     #13$,R4         ;INIT DRIVER BYTE LIST PTR
        MOV     #AC0,3$ ;INIT PC=0 ONLY FOR FIRST SUBTEST
;-----EXTRACT MACHINE CONDITIONS FROM DIRVER BYTE, AND SET THE
;       MACHINE INTO THOSE CONDITIONS.  FIRST SET THE PROPER PI LEVEL.
1$:     SM                      ;CLR OUT MACHINE
        MOV     #3,12$          ;INIT PI LEVEL DECREMENTER
        MOVB    (R4),R0         ;SET UP R0 FOR COMTRP
        BNE     20$             ;IF BYTE NOT 0, MORE TO DO
        NORMAL                  ;ELSE ALL DONE
20$:    SWAB    R0
        BIC     #-<ACCTON+EXACTE+PIACTE+1>,R0
        COMTR   LAC,0,P         ;SET REQUIRED ACCTG CNTL BITS
        MOVB    (R4),PRSCRT     ;SET UP PARAM FOR AC PRGM
        BIC     #177770,PRSCRT
2$:     DPOSVT,AC17,PRSCRT      ;LOAD AC PRGM PARAM TO AC17
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        JSR     R5,STRTKL       ;START AC PRGM
3$:     000000                  ;INIT PC=0 OR 4 (TO BE SUPPLIED)
        MOV     #AC4,3$         ;SET INIT PC TO NEW VALUE
;-----NOW SET USER MODE IF REQUIRED BY DRIVER BYTE.
        BITB    #BIT3,(R4)      ;IS THIS A USER MODE TEST?
        BEQ     4$              ;BR IF NO
        JSR     R5,STRTKL        ;& START IT
        AC15
;-----SECTION TO CHECK FOR COUNTER VALUE CHANGE
4$:     CLKPRM                  ;GET CLOCK RATE
        BIT     #2,(R0)         ;CR 2 OR 3?
        BEQ     5$              ;BR IF NO
        TDELAY,TDELAY           ;ELSE WAIT A WHILE FOR KL
5$:     INSYNC                  ; ***** ALL SUBTESTS *****
        JSR     R5,RDMTR4               ;RD EBOX CNTR TWICE
        .BYTE   MBDFEA,MBDFEA
        SUB     R1,R2           ;CALC DIF IN CNTS
        MOV     R2,R1           ;CNT DIF TO R1
        BNE     8$              ;BR IF EITHER CHNGD, ACCTG EN
;-----COUNTER NOT CHANGED SECTION
          TSTB  (R4)            ;NO CHNG...SHD THERE HAVE BEEN?
        BGE     9$              ;NO...OK


;SEQ259

;-----ERR SECTION
6$:     CMP     R5,#2           ;SUBTEST 2?
        BNE     14$             ;NO...SKIP THIS ADDITIONAL CHECK
        JSR     R5,RDMTR                ;GET MBOX ACCTG CNT
        MBDFMA
        PUSH    R2              ;SAVE ITS VALUE

        XQT     MEMREF          ;DO A MEM REFERENCE
        JSR     R5,RDMTR5       ;GET CNTR AGAIN
        SUB     (SP)+,R2                ;CALC COUNT DIFFERENCE
        BEQ     14$             ;NO DIFFERENCE...ACCT LOGIC NOT WORKING
        XFAULT  MBEX1,<EBOX ACCTG CNTR DOESN'T COUNT WHEN ENABLED>
14$:    XQT     CIPI            ;DO CONI PI,17
        MOVB    (R4),R0         ;SAV DRIVER BYTE FOR ISOLATION ROUTINE
        PWTES                   ;PARAM WD TO ERR STK
        XFAULT  7$,<ACCOUNTING LOGIC ERR>
7$:     MBDFAD,F.NR1            ;ERR DATA DUMP CNTL LIST
        .ASCII  %EBOX CNTR CHANGE%
        0,F.ASCIZ
        .ASCIZ  %CONI PI DATA %
        AC17,F.INDI,MBEX1
;-----CNTR CHANGED SECTION
8$:     TSTB    (R4)            ;CNTR CHANGED...SHD IT HAV?
        BGE     6$              ;NO...ERR
;-----END OF LOOP SECTION
9$:     BITB    #BIT3,(R4)              ;USER MODE TEST?
        BNE     10$             ;YES...SKIP ITERATION OF PI LEVELS
        SUB     12$,PRSCRT      ;GO THRU PI LEVELS 7,4,2,1
        BLT     10$             ;ON NEGATIVE PI LEVEL, DO NXT DRIVER
        DEC     12$             ;DEC PI LEVEL DECREMENTER
        BGE     2$              ;LOOP IF MORE PI LEVELS TO DO
10$:    TSTB    (R4)+           ;MOVE DRIVER BYTE PTR
        JMP     1$              ;LOOP
12$:    .WORD   0               ;PI LEVEL DECREMENTER


;SEQ260

.REM    %
        DRIVER BYTE FORMAT:
        XABCUPPP                WHERE:
        X=1     MEANS CNTRS SHOULD BE CHANGING

        A,B,C ARE PIACTE, EXACTE, & ACCTON, RESPECTIVELY
        U=1     (BIT3)  MEANS USER MODE TEST
        PPP     IS THE PI LEVEL DESIRED (000 MEANS NO-PI)

        (SEE LISTING FOR DRIVER BYTE CONTENTS)
        %

13$:    ;-----THE DRIVER BYTE LIST:

;BYTE VALUE     SUBTEST CHANGE? COMMENTS

;-------------  ------- ------- ----------------------------------------
.BYTE   010;    1       NO      CNT TEST, NO ENBS SET, NO-PI, USER MODE

.BYTE   360;    2       YES     CNT TEST, ALL ENBS SET, NO PI
.BYTE   370;    3       YES     CNT TEST, ALL ENBS SET, NO-PI, USER MODE
.BYTE   367;    4-7     YES     CNT TEST, ALL ENBS SET, PI IP 7,4,2,1
        
.BYTE   140;    8       NO      ON/OFF TEST, ACCTON OFF, OTHERS ON, NO PI
.BYTE   067;    9-12    NO      EXACTE TEST, PIACTE OFF, OTHERS ON PI 7,4,2,1
.BYTE   260;    13      YES     EXACTE TEST, SAME ENBS, NO-PI
.BYTE   327;    14-17   YES     PIACTE TEST, EXACTE OFF, OTHERS ON PI 7,4,2,1
.BYTE   120;    18      NO      PIACTE TEST, SAME ENBS, NO PI IN PROG.
        
.BYTE   237;    19      YES     USER MODE TEST, ONLY ACCTON ON, PI 7
.BYTE   230;    20      YES     ;USER MODE TEST, SAME ENABLES, NO-PI
.BYTE   000;    END
        .EVEN


;SEQ261



;SEQ262

        .SBTTL          METER BOARD EBOX USE COUNTER TESTS
.REM    %
        METER BOARD TEST#15 TESTS THE MR FUNCTION OF THE EBOX COUNTER,
        AND THAT IT ISN'T COUNTING MBOX WAITS.
        %
I.15:   LOADAC  77000,2$                ;LOAD AC PRGM (AC11-16)
        JSR     PC,CHKP
        JSR     R5,SUSSPM       ;SET UP FOR SINGLE STEP EXEC
        AC15                    ;INIT PC=15
        MOV     #77777,R0       ;DESIRED COUNT
        MOV     #1$,BCLA
        JSR     R5,FSTCNT       ;COUNT TO DESIRED VALUE
        .WORD   301,MBDFEA,577
        RTS     PC
1$:     .WORD   134
        
2$:     IO10    CONO,MTR,,470000        ;11-TURN ON ACCTG


        I10     MOVE,0,,0       ;12-DO A MOVE FROM AC


        IO10    CONO,MTR,,400000        ;13-TURN OFF ACCTH


        I10     JRST,4,,14      ;14-HALT


        IO10    CONO,MTR,,470000        ;15-TURN ON ALL ACCTG EN BITS


        I10     JUMPA,,,16              ;16-JUST LOOP SO ACCTGH IS ENABLED


;-----METER BOARD TEST#15
T.15:   INSYNC                  ; ***** SUBTEST 1 *****
        MRESET                  ;ATTEMPT THE MASTER RESET
        JSR     R5,RDMTR        ;GET COUNTER CONTENTS
        MBDFEA
        TST     R2              ;WAS CNTR CLEARED?
        BEQ     1$              ;YES..OK
        PWTES   #1              ;PARAM WD TO ERR STK
        XFAULT  MBEX1,<MR, EBOX CNTR -CLR>
1$:     PWTES   #2              ;PARAM WD TO ERR STK


;SEQ263

        MSKDF   MBDFAD,ZERO..,MBACTM    ;CHK
        BCC     2$              ;BR IF OK
        XFAULT  MBEX1,<MR DIDNT CLR ACCT BITS>
        
2$:     INSYNC                  ; **** SUBTEST 2 ****
        RUN     AC11            ;RUN PRGM TO CNT EBOX CLKS IN AC REF
        JSR     PC,CHKP
        JSR     R5,RDMTR5       ;GET COUNTER CONTENTS
        MOV     R2,R1           ;SAVE OUR COUNT
        DPOST,AC12,MEMREF               ;SUBSTITUTE MEM REF FOR AC REF
        JSR     PC,CHKED
        RUN     AC11            ;RESTART PROGRAM
        JSR     PC,CHKP
        JSR     R5,RDMTR5       ;GET NEW COUNTER VALUE
        SUB     R1,R2           ;CORRECT SECOND COUNTER VALUE
        MOV     R2,R3           ;CALC DIF BETWEEN VALUES
        SUB     R1,R3
        BGE     20$             ;IF POS LEAVE ALONE
        NEG     R3              ;ELSE MAKE POSITIVE
20$:    CMP     R3,#4           ;DIF >4?
        BLE     12$             ;NO...OK
        XFAULT  MBEX1,<EBOX COUNTER RUNS DURING MBOX REFERENCES>
12$:    NORMAL



;SEQ264



;SEQ265

.REM    %
        METER BOARD  TEST#16 IS THE COUNT/READ TEST FOR THE EBOX
        ACCOUNTING COUNTER.  AC PROGRAM LOADED BY I.15.
        %
T.16:   JSR     R5,CLRPT        ;CLR THE LO ORD EBOX WD IN THE UPT
        INSYNC                  ; **** SUBTEST 1 ****
        
        JSR     R5,SUSSPM               ;SET UP FOR SINGLE STEP EXEC
        AC15                    ;INIT PC=15
        SOBAC   <MBDFEA,35.,1>,65         ;STEP TIL CNTR=1 (LO ORD BIT SET)
        JSR     R4,MCNTRD
        .WORD   MBDFEA,3$,MBIS2,2$,1$
1$:     .WORD   000231          ; BY
        .WORD   000235          ; B]
        .WORD   000073          ;
        .WORD   000160          ; Ap
        .WORD   000215          ; BM
        .WORD   000361          ; Cq
        .WORD   000341          ; Ca
        .WORD   000160          ; Ap
        .WORD   000563          ; Es
        .WORD   000002          ;  B
        .WORD   000070          ;  x
2$:     .ASCIZ  %EBOX ACCTG %
;-----'SUB1' FOR MCNTRD EBOX.
3$:     MOV     (R3),R0         ;DESIRED CNT TO R0
        JSR     R5,FSTCNT       ;CNT UP TO IT
        301,MBDFEA,577          ;LIMITING CNT, DFRD#, BRST CNT
        BCS     4$              ;DONT UPDT ADR IF CNTR DIDNT WORK
        ADD     #2,BCLA         ;ELSE PT TO NXT BURST CNT
4$:     RTS     R5              ;RETURN TO COUNT/READ TEST


;SEQ266



;SEQ268

        .SBTTL          METER BOARD MBOX (CACHE) COUNTER TESTS

.REM    %
        METER BOARD TEST#17 CHECKS THE MR FUNCTION OF THE MBOX (CACHE)
        ACCOUNTING METER OF THE M8538 BOARD.
        %
;-----INITIALIZATION CONSISTS OF SETTING UP THE UPT WORD, LOADING
;       THE AC PRGM, AND PUTTING AN ALL ONES VALUE IN THE COUNTER
I.17:   JSR     R5,SETPTW       ;SET UP PROCESS TABLES
        UPTMA                   ;ADR WD POINTS TO LO ORD UPT MA WD
        LOADAC  76,MCPRG        ;LOAD AC PRGM 9AC1-5)
        DPOST,AC17,1$           ;LOAD DESIRED COUNT
        RUNBIG  AC1,4           ;RUN PRGM TO SET COUNT
        JSR     PC,CHKP         ;MAKE SURE IT FINISHED
        RTS     PC              ;INIT DONE
1$:     WD36    0000,0007,7703  ;COUNT TO AS CLOSE AS WE DARE GET



        .EVEN


;-----METER BOARD TEST#17
T.17:   INSYNC                  ; **** SUBTEST 1 ****
        MRESET                  ;TRY MR
        MSKDF   MBDFMA,ZERO..,2$        ;CHK FOR ZERO
        BCC     1$              ;IT IS...OK
        XFAULT  MBEX1,<MR DIDNT CLR MBOX (CACHE) ACCT CNTR>
1$:     NORMAL
2$:     WD36    7777,7760,0000  ;LOOKS ONLY AT COUNTER

MBACTM: WD36    7777,7770,7777  ;LOOKS ONLY AT ACCTG BITS
                
        .EVEN

;SEQ269


;SEQ270

.REM    %
        METER BOARD TEST TO CHECK THE ABILITY OF THE MBOX 9CACHE)       
        COUNTER TO FUNCTION PROPERLY.  ALSO CHECKS THE MUX INPUTS.
        %
;-----METER BOARD TEST#18 INIT CLEARS THE MBOX ACCTG PROCESS TABLE
;       WORDS AND LOADS AN AC PROGRAM.
I.18:   SM                      ;CLR THE MACHINE
        JSR     R5,CLRPT        ;CLR THE PROCESS TABLE WORDS
        LOADAC  76,MCPRG        ;LOAD AC1 TO 5
        RTS     PC              ;INIT DONE
MCPRG:  IO10    CONO,MTR,,470000        ;1--TURN ON ACCTG BITS


MEMREF: I10     MOVE,0,,20      ;2--FORCE A MEM REF


        I10     SOJG,17,,2      ;3--LOOP ON COUNT SUPPLIED IN AC17


        IO10    CONO,MTR,,400000        ;4--TURN ACCTGH OFF


        I10     JRST,4,,1               ;5--HALT


        .EVEN
;-----METER BOARD TEST#18 CHECKS THE MBOX ACCOUNTING COUNTER.  THE
;       PECULIAR NATURE OF THIS COUNTER MEANS THAT WHILE IT IS RUNNING,
;       THE EBOX COUNTER MUST ALSO BE ON & CAUSING MEM REFS, WHICH MAKE
;       THE MBOX COUNTER COUNTER EVEN MORE.  THEREFORE EXACT COUNTS MAY
;       BE IMPOSSIBLE, SO COUNTS WITHIN A RANGE ARE ACCEPTED.
;       THE MICRO-CODE WILL EVENTUALLY FIX THIS.
T.18:   MOV     #MBDPP,R3               ;INIT PTRN TABLE PTR
        CLR     R2              ;EXPECTED CNT IN CNTR AFTER MR
1$:     MOV     (R3),PRSCRT     ;CALC # CNTS NEC TO REACY NEXT PATTERN
        SUB     R2,PRSCRT
        DPOST,AC17,PRSCRT       ;PUT CNT IN AC 17 FOR PRGM
        JSR     PC,CHKED
        INSYNC                  ; **** SUBTESTS 1-9 ****
        RUN     AC1             ;START PRGM
        JSR     PC,CHKP         ;MAKE SURE IT HALTED
        JSR     R5,RDMTR                ;GET COUNTER
        MBDFMA
        CMP     R3,#MBDPP2      ;ON LAST PTRN?
        BHIS    4$              ;YES...GO TO NXT PART OF TEST


;SEQ271

        CMP     R2,(R3)+        ;CNTR >= DESIRED PTRN?
        BEQ     1$              ;EXACTLY EQUAL, SKP REST OF CHK
        BGT     2$              ;GREATER...CHK SOME MORE
        JSR     R5,7$           ;ELSE DUMP ERR DATA
        XFAULT  8$,<MBOX ACCTG CNTR MISSED COUNTS>
2$:     MOV     R2,R0           ;COUNTER WITHIN TOLERANCE?
        SUB     -2(R3),R0       
        CMP     R0,#4
        BLE     1$              ;BR IF WITHIN TOLERANCE...OK
3$:     JSR     R5,7$           ;ELSE DUMP ERR JUNK
        XFAULT  8$,<MBOX ACCTG CNTR GETTING EXTRA COUNTS>
4$:     CMP     R2,#77777       ;CNTR AT MAX VALUE PERCHANCE?
        BNE     5$              ;NO CONTINUE
        RUN     AC1             ;FORCE 1 MORE MEM REF
        JSR     PC,CHKP
        JSR     R5,RDMTR5       ;GET COUNTER VALUE
5$:     JSR     R4,MCRCON       ;CONTINUE THIS TEST AS SUBTEST 9...
                                ;IN THE COUNT/READ SUBROUTINE.
6$:     0,0,0,6$                ;DUMMY PARAM LIST
7$:     MOV     R2,R0           ;CNTR VALUE TO ERR STK FOR ISOLATION
        PWTES                   ;PARAM WD TO ERR STK
        MOV     -(R3),R0        ;EXPECTED VAL TO ERR STK FOR ISO RTN
        PWTES   
        RTS     R5
8$:     F.NR2                   ;OUTPUT DATA CMD LIST
        .ASCIZ  /COUNTER VALUE/
        F.16N3
        .ASCIZ  /EXPECTED VALUE/
        .EVEN
        F.INDI,MBEX1


;SEQ272



;SEQ274

        .SBTTL          METER BOARD PERFORMANCE ANALYSIS COUNTER TESTS

.REM    %
        MACROS AND SUBROUTINES FOR PERFORMANCE ANALYSIS COUNTER TESTS.
        %
.MACRO  PAE     I,J,K,X
          JSR   R5,SLPAET       ;SET UP INSTR TO SET ENABLES
          WD36  I,J,K           ;PA CNTL WD
        .IF     B,X
          .BYTE 0               ;JUST INIT INSTR, DONT DO IT
        .IFF
          .BYTE 177             ;INIT AND START INSTRUCTION
        .ENDC
        .ENDM   PAE

SLPAET: MOV     R5,1$+4         ;WD36 ADR TO PL FOR DPOSVT
        ADD     #5,R5           ;BYPASS WD36
1$:     DPOSVT,AC17,000000      ;PUT ENABLES WD IN AC17
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        STEXCT  BOTIM           ;INIT EXEC OF BLKO TIM,17
        TSTB    (R5)+           ;SHD WE DO THE BLKO YET?
        BEQ     2$              ;NO
        DFXCTT,STRCLK           ;ELSE START THE CLK
2$:     RTS     R5              ;DONE...RETURN

;-----SUBROUTINE TO READ PA CNTR TWICE TO SEE IF IT IS COUNTING.
PACT:   JSR     R5,RDMTR4               ;READ PA CNTR TWICE
        .BYTE   MBDFPA,MBDFPA
        CMP     R1,R2           ;COMPARE COUNTS
        RTS     R5


;SEQ275

.REM    %
        METER BOARD TEST#19 CHECKS OUT THE EVENT/DURATION BIT OF THE
        PERF COUNTER ENABLES, AND MAKES SURE THAT OTHER IGNORES
        CAN ALL BE SET AND ARE FUNCTIONAL.
        %
;-----METER BOARD TEST#19
I.19:   JSR     R5,SETPTW               ;SETS UP EPT/UPT & PUTS ADR IN SCRT22
        EPTPA
        SM
        RTS     PC
T.19:   INSYNC                  ; **** SUBTEST 1 ****
        PAE     0015,0277,7200,EXEC     ;SET ALL IGNORES, DURATION MODE
        JSR     R5,RDMTR4       ;RD PA CNTR TWICE, SHD CHNG
        .BYTE   MBDFPA,MBDFPA
        SUB     R1,R2           ;CNT MUST DIFFER BY OTHER THAN 1,0
        BEQ     1$              ;DIFFERS BY 0...ERR
        DEC     R2              ;DOES IT DIFFER BY OTHER THAN 1?
        BNE     2$              ;YES...OK
1$:     XFAULT  MBEX1,<PA CNTR DOESNT RUN W/ALL IGNS SET, DUR MODE>
2$:     INSYNC                  ; **** SUBTEST 2 ****
        PAE     0015,0277,7300,EXEC     ;SET ALL IGNORES, EVENT MODE
        JSR     R5,RDMTR4       ;RD PA CNTR TWICE, SHD NOT BE CHANGING
        .BYTE   MBDFPA,MBDFPA
        CMP     R1,R2           ;IS IT CHANGING?
        BEQ     3$              ;NO...VERY GOOD...E MODE BIT CAN SET/CLR
        XFAULT  MBEX1,<PA CNTR RUNS, ALL IGNS SET, EVNT MODE>
3$:     NORMAL


;SEQ276




;SEQ277

.REM    %
        METER BOARD TEST#20 & TEST#21 CHECK THE CLEARING FUNCTION OF THE
        PERFORMANCE ANALYSIS COUNTER.
        %
I.20:   LOAD    15,BOTIM,3      ;LOAD FIRST P.A. AC PRGM
        JSR     R5,SUSSPM       ;SET UP FOR SINGLE STEP EXEC
        15                      ;INIT PC=15
        MOV     #77777,R0       ;DESIRED COUNT
        MOV     #1$,BCLA        ;INIT BRST-CNT-LST ADR
        JSR     R5,FSTCNT       ;MAKE COUNTER COUNT
          .WORD 301,MBDFPA,577
        RTS     PC
1$:     .WORD   200             ;BURST COUNT
X.4:    WD36    0000, 0000,0040 ;17-CLR-PA-CNTR BIT FOR BLKO TIM
BOTIM:  IO10    BLKO,TIM,,17    ;15-SET ALL IGNORES

        I10     JUMPA,,,16              ;16-KL10 LOOPS WHILE COUNTER CNTS


        WD36    0015,0277,7200  ;17-SEE SPEC FOR BIT MEANINGS



;SEQ278

.REM    %
        METER BOARD TEST#20 CHECKS THE MR FUNCTION OF THE PA CNTR.
        %
T.20:   INSYNC                  ; **** SUBTEST 1 ****
        MRESET
        JSR     R5,RDMTR        ;SEE WHAT HAPPEND
          MBDFPA
        TST     R2              ;COUNTER WAS?
        BEQ     1$              ;ZERO...OK
        XFAULT  MBEX1,<MR DIDNT CLR PA CNT>
        
1$:     BRST    100.
        JSR     R5,RDMTR5
        TST     R2              ;CNTR STILL RUNNING?
        BEQ     2$              ;NO...OK
        XFAULT  MBEX1,<PA CNTR RUNS AFTER MR>
2$:     NORMAL


;SEQ279



;SEQ280

.REM    %
        METER BOARD TEST#21 CHECKS THE FUNCTION OF THE CLR-PA-CNTR BIT
        OF THE BLKO TIM INSTRUCTION.
        %
;-----TEST INIT MEARLY PUTS A NON ZERO VALUE INTO THE COUNTER.
I.21:   SM                      ;CLR THE MACHINE
        LOADAC  160000,BOTIM    ;LOAD AC PRGM (AC15-17)
          
        JSR     R5,STRTKL       ;START 10 & LET IT RUN TO GEN CNT
        AC15
        RTS     PC

;-----METER BOARD TEST#21
T.21:   DPOSVT,AC17,X.4 ;PUT WD INTO AC17 FOR BLKO
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        INSYNC                  ; **** SUBTEST 1 ****
        XQT     BOTIM           ;DO THE BLKO TIM
        JSR     R5,RDMTR        ;GET RESULTS
        MBDFPA
        TST     R2              ;COUNTER CLEARED?
        BEQ     1$              ;YES..OK
        XFAULT  MBEX1,<BLKO TIM, CLR-PA-CNTR BIT DIDNT WORK>
1$:     NORMAL


;SEQ281



;SEQ282

.REM    %
        METER BOARD TEST#22 IS THE COUNT/READ TEST FOR THE
        PERFORMANCE ANALYSIS COUNTER.
        %
T.22:   LOAD    15,3$,3         ;LOAD AC PRGM
        JSR     R5,CLRPT        ;CLR THE LO ORD PA WD IN THE EPT
        INSYNC                  ; **** SUBTEST 1 ****
        JSR     R5,SUSSPM       ;SET UP FOR SINGLE STEP EXEC
         15                     ;INIT PC=15
        SOBAC  <MBDFPA*400+100+0+0>,131      ;STEP TIL PA CNTR=1 (LO ORD BIT=1)
        JSR     R4,MCNTRD
        .WORD   MBDFPA,1$,MBIS1,4$,2$
;-----SUB1 AND SUB2 FOR MCNTRD
1$:     ASL     R0              ;DOUBLE PA CNT IS MBOX CLK CNT
        JSR     R5,BRST1        ;GO DO BURST
        RTS     R5
;-----CONSTANTS, ETC.
        
2$:     .WORD   2,71  
3$:     IO10    BLKO,TIM,,17    ;15-SET ALL PA IGNORES, CLR CNTR, DUR.
        I10     JUMPA,,,16      ;16-KL10 SITS & LOOPS
        WD36    0015,0277,7240  ;17-SEE DK20 SPEC FOR BIT MEANINGS
        
4$:     .ASCIZ  %PERF ANALYSIS %
        .EVEN


;SEQ283



;SEQ285

.REM    %
        METER BOARD TEST#23 CHECKS THE PI LEVEL INPUTS AND ENABLES
        FOR THE PERFORMANCE ANALYSIS COUNTER.  THE OUTER LOOP CYCLES
        THROUGH PI LEVELS 7-1, 0 (VIA AN EXAMINE), AND NO-PI. DURING
        EACH OF THESE LEVELS ALL PI LEVEL ENABLES ARE SET, ONE AT A 
        TIME TO CHECK OUT THE SELECT CIRCUITRY.
        INITIALIZATION IS THE SAME AS FOR I.14.
        %
T.23:   MOV     #7,PRSCRT       ;INIT PI LEVEL #
;-----TOP OF OUTER LOOP.  SET UP PI LEVELLEVEL #
1$:     SM                      ;MR...PI SYS CLR...I0 BUS RST
        DPOSVT,AC17,PRSCRT      ;PI LEV PARAM TO AC17
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        JSR     R5,STRTKL       ;START AC PRGM TO SET PI LEVEL
        AC0
2$:     MOV     #1,R3           ;PATTERN FOR PA ENABLES WD...PI SEC.
        MOV     #8.,R4          ;LOOP CNT
;-----TOP OF INNER LOOP.  CALCULATE PI PERF. ANALYSIS ENABLES.
3$:     BIC     #3776,10$               ;SET PI ENABLES IN PA ENABLES WD
        ASL     R3      
        BIS     R3,10$
        DPOSVT,AC17,9$          ;ENABLES WD TO AC17
        INSYNC                  ; **** ALL UBTESTS (1-81) ****
        CMP     R5,#64. ;SUBTEST 64 (PI LEV 0, NO-PI ENABLED)
        BEQ     8$              ;IF YES SKP TEST BECAUSE ITS DOOMED TO
                                ;FAILURE DUE TO THE NATURE OF THE BEAST.
;-----SET PERF ANALYSIS ENABLES.
        XQT     BOTIM           ;LOAD ENABLES TO METER BOARD
        JSR     R5,RDMTR                ;READ PA COUNTER
        MBDFPA
        MOV     R2,R1           ;SAV COUNTER VALUE
        TST     PRSCRT          ;WHAT PI LEVEL?
        BNE     4$              ;VE ID NO ZERO
        EXAMT,AC0,SCRT36        ;ELSE FORCE PI LEV O BY DOING AN EXAMINE
;-----DETERMINE IF A PA COUNTER SHOULD BE RUNNING OR NOT, AND IF IT IS.
4$:     JSR     R5,RDMTR5       ;READ METER A SECOND TIME
        TST     PRSCRT          ;IN NO-PI LEVEL?
        BGE     5$              ;BR IF NO
        CMP     R4,#8.          ;IS NO-PI ENABLED?
        BNE     7$              ;BR IF NO...CNTR SHD NOT BE CHNGG
        BR      6$              ;ELSE COUNTR SHD B CHNGG...CHECK
5$:     CMP     R4,PRSCRT               ;IF NOT NO-PI, CHECK FOR LEV-ENB MATCH
        BNE     7$              ;;ENB & LEV DONT MATCH...CHK FOR NO CHNG
                
6$:     CMP     R1,R2           ;ELSE CHK TO SEE IF IT IS
        BNE     8$              ;IT IS...OK
        BR      11$             ;ELSE SEND ERROR

7$:     CMP     R1,R2           ;CNTR SHD -BE CHNGG...IS IT?
        BEQ     8$              ;NO...OK
        BR      13$             ;ELSE SEND ERROR


;SEQ286

;-----END OF INNER AND OUTER LOOPS.
8$:     DEC     R4              ;END OF INENR LOOP      
        BGE     3$              ;BR IF MORE TO GO
        DEC     PRSCRT          ;END OF OUTER LOOP
        CMP     PRSCRT,#-1      ;WHAT PI LEVEL ARE WE GOING TO ?
        BGE     1$              ;BR IF GOING TO 7 THRU 0
        BEQ     2$              ;BR IF GOING TO NO-PI LEVEL
        NORMAL                  ;ELSE DON
        .ODD
9$:     .BYTE   240             ;PA ENABLE WD FOR PI LEVEL TESTS
10$:    .WORD   4000,15
;-----ERROR DATA DUMPER FOR TEST#23
11$:    XQT     CIPI            ;ELSE ERR...GET CONI PI DATA TO AC17
        XFAULT  12$,<PA CNTR DOESNT RUN>
12$:    F.ASCIZ
        .ASCIZ  %PA ENABLES WORD %
        .EVEN
        BIT15!9$,F.ASCIZ
        .ASCIZ  %CONI PI DATA %
        .EVEN
        AC17,F.INDI,MBEX1
13$:    XQT     CIPI            ;CONI PI DATA TO AC17
        XFAULT  12$,<PA CNTR RUNS>


;SEQ287



;SEQ288

;NOTE*****SEQ288 MICROFICHE IS BLANK.


;SEQ289

.REM    %
        METER BOARD TEST#24 IS THE PERFORMANCE ANALYSIS COUNTER
        USER/EXEC MODE TEST.
        %


I.25:                           ;SAME AS BELOW
I.24:   SM                      ;INIT THE MACHINE
        LOADAC  64000,PIIPG2    ;LOAD AC PRGM(AC13,15,16)
        RTS     PC              ;INIT DONE


;-----METER BOARD TEST#24
T.24:   INSYNC                  ;****SUBTEST 1 ****
        PAE     0015,0277,7040,X        ;EXEC MODE ENABLED, EXEC MODE
        JSR     R5,PACT         ;IS CNTR CNTG?
        BNE     1$              ;YES...OK
        XFAULT  MBEX1,<PA CNTR, EXEC MODE ENB, EXEC MODE, NO CNT>
1$:     INSYNC                  ; ****SUBTEST 2*****
        PAE     0015,0277,7440,X        ;EXEC MODE, USER MODE EN
        JSR     R5,PACT         ;IS CNTR CNTG?
        BEQ     2$              ;NO...OK
        XFAULT  MBEX1,<PA CNTR, USER MODE ENB, EXEC MODE, COUNTS>

2$:     INSYNC                  ; *****SUBTEST 3*****
        JSR     R5,STRTKL               ;PUT MACHINE IS USER MODE
        AC15
        JSR     R5,PACT         ;IS CNTR RUNG?
        BNE     3$              ;YES...OK
        XFAULT  MBEX1,<PA CNTR, USER MODE ENB, USER MODE,  NOT CNTG>
3$:     SM                      ;RESET EVERYTHING
        NORMAL                  ;DONE


;SEQ290




;SEQ291

.REM    %
        METER BOARD TEST#25 CHECKS THE PERF ANALYSIS COUNTER INPUT
        AND ENABLES FOR THE 'PROBE'.
        %
;-----DETERMINE IF TEST SHOULD BE DONE (AS IT REQUIRES MANUAL IN-
;       TERVENTION). AND INSTRUCT OPERATOR AS TO WHAT TO DO.
T.25:   TSTB    XMODE           ;XOR TESTER ON?
        BNE     9$              ;YES...SKIP THIS TEST
1$:     TST     #000000         ;THIS TEST ALREADY DONE?
        BNE     9$              ;IF YES, SKIP IT
        SWITCH                  ;DONT DO THIS TEST IN CHAIN MODE
        BIT     #CHAIN,R0               ;CHAIIN MODE SET?
        BNE     9$              ;YES...SKIP TEST
        BIT     #OPRSEL,R0      ;OPERATOR SELECT SW SET?
        BEQ     9$              ;NO...SKIP TEST
        TST     SCANWD          ;IN GENERATION PASS?
        BNE     3$              ;YES...DONT SET TESTED FLAG
        INC     1$+2            ;ELSE MARK TEST AS DONE
3$:     PFORCE                  ;FORCE PRINTING
        PMSG    <METER BOARD PROBE TEST? (Y,N) _>
        TTILIN                  ;WAIT FOR ANSWER
        BCS     8$              ;IF NO RESPONSE, ASSUME 'NO' ANSWER
        TTIYES                  ;YES?
        BCS     3$              ;BR ON GARBAGE ANSWER
        BMI     9$              ;ON 'NO' ANSWER, SKIP THIS TEST
        PMSG    <JUMPER METER BOARD PIN CA1 TO CU2.  <CR> WHEN DONE._>
        TTILNW                  ;WAIT FOR CRLF

;-----DO THE TEST...THE TEST WORKS BY TOGGLING 'SCD USER L' WHICH
;       HAS BEENB MANUALLY CONNECTED TO THE PROBE INPUT.
4$:     MOV     #"HI,6$+22      ;SET ERR MSG
        INSYNC                  ; **** SUBTEST 1 ****

PAE     0014,0277,7240,X        ;PROBEW HI TEST


;SEQ292

        JSR     R5,PACT         ;IS CNTR CHANGING?
        BNE     7$              ;YES...OK
5$:     CLR     T.25+2          ;CLR ONCE-ONLY FLAG ON ERR
6$:     XFAULT  PACMSG,<PROBE INPUT ??/ENABLE ERR>      ;?? TO BE SUPPLIED
7$:     INSYNC                  ; **** SUIBTEST 2 ****
        PAE     0016,0277,7240,X        ;PROBE LOW ENABLED BUT HI TEST
        JSR     R5,PACT         ;IS CNTR RUNNING?
        BNE     5$              ;YES...ERR
        MOV     #"LO,6$+22      ;SET ERR MSG
        INSYNC                  ;****SUBTEST 3 ****
        JSR     R5,STRTKL               ;PUT KL IN USER MODE, BRINGING PROBE
        AC15                    ;INPUT LOW AS IT IS ATTACHED TO
        JSR     R5,PACT         ;IS CNTR CNTG?
        BEQ     5$              ;NO...ERR
        TSTB    XMODE                   ;XOR ON?
        BNE     9$              ;BR IF YES...DONT TELL HIM TO REMOVE J.
        PMSG    <REMOVE JUMPER>
8$:     PCRLF
9$:     PNORML
        NORMAL
PACMSG: F.ASCIZ
        .ASCIZ  %PA ENABLES WORD %
        .EVEN
         AC17,F.INDI,MBEX1


;SEQ293



;SEQ294

.REM    %
        PERFORMANCE ANALYSIS COUNTER CACHE INPUTS TEST.
        %
;-----TEST INIT LOADS THE AC PRGM INITS THE MACHINE & CACHE.
I.26:   BR      1$              ;SKIP INIT ON LOOPS
        SM                      ;CLR THE MACHINE
        DPOST,20,T26.20         ;JRST . TO MEM LOC 20
        JSR     PC,CHKED
        XQT     CSHALW          ;TURN ON CACHE
        JSR     PC,CHKX         ;CHK EXECUTE RESULT
        INVAL                   ;INVALIDATE ALL OF CACHE
        LOADAC  177776,2$       ;LOAD AC PRGM (AC1-17)
1$:     RTS     PC              ;INIT DONE


;SEQ295

2$:     WD36    0015,3477,7340  ;1-CACHE REF PA ENB, EVNT, CLR PA CNTR
        WD36    0015,5477,7340  ;2-FILL CACHE RD ENB, EVNT, CLR PA CNTR
        WD36    0015,6477,7340  ;3-CACHE W WRBAK ENB, EVNT, CLR PA CNTR
        WD36    0015,7077,7340  ;4-CACHE SWEEP WRBAK ENB, EVNT, CLR CNTR
        IO10    BLKO,TIM,,1     ;5-SET PA ENABLES, CLR CNTR
        I10     MOVEM,0,,1774   ;6-MOVE TO PAGE 1 FORCING CACHE REF
        I10     JRST,4,,10      ;7-HALT FOR NOW
        IO10    BLKO,TIM,,2     ;10-SET PA ENABLES
        I10     MOVE,0,,770     ;11-FORCE CACHE FILL READ (FROM PG 0)
        I10     JRST,4,,13      ;12-STOP
        IO10    BLKO,TIM,,3     ;13-LOAD PA ENABLES
        I10     MOVEM,0,,774    ;14-WR LAST LINE OF PG 0, FORCE E WRTBK
        I10     JRST,4,,16      ;15-STOP
        
        IO10    BLKO,TIM,,4     ;16-SET PA ENABLES
        WD36    7017,4000,0000  ;17-SWEEP CACHE PAGE 0 (SWPU0)
T26.20: I10     JRST,,,20       ;20-LOOP IN MEM ENBG 'EBOX WAITING'
        .EVEN


;SEQ296

;-----METER BOARD TEST#26
T.26:   TST     CSHFLG          ;IS CACHE ENABLED & PRESENT?
        BNE     1$              ;IF YES, DO TEST
        NORMAL                  ;ELSE THIS TEST DONE
;-----CACHE REF SUBTESTS.
1$:     INSYNC                  ; **** SUBTEST 1 ****
        JSR     R5,SUSSP        ;SET UP AC PRGM FOR SINGLE STEP EXEC
        AC5                     ;INITIAL PC

        SOBAC   <135,24.,0>,26       ;WAIT FOR 'CON MBOX WAIT L' TO BE SET
        BCC     2$              ;BR IF FOUND
        XFAULT  MBEX1,<'CON MBOX WAIT L' NOT FOUND DURING MEM CYC>
2$:     JSR     R4,5$           ; **** SUBTEST 2 ****
;-----CACHE FILL READ SUBTESTS
        JSR     R5,SUSSP        ;SET UP PRGM FOR SINGLE STEP EXEC
        AC10                    ;INIT PC
        INSYNC                  ; **** SUBTEST 3 ****
        SOBAC   <171,26.,0>,160      ;STEP TO 'CSH' FILL CACHE RD L'
        BCS     3$              ;BR IF SGNAL NOT FOUND
        CMP.S   T26T2,33      ;CHECK STATE OF CACHE LOGIC
        BCC     4$              ;BR IF CACHE LOGIC OK
3$:     XFAULT  MBEX1,<ERR IN CACHE LOGIC STATE DURING METER TEST>
4$:     JSR     R4,5$           ; **** SUBTEST 4 ****


;SEQ297

;-----EBOX WRITEBACK SUBTESTS
        JSR     R5,SUSSP        ;SET UP SINGLE STEP PROGRAM EXEC
        AC13                    ;INIT PC
        INSYNC                  ; **** SUBTEST 5 ****
        SOBAC   <176,28.,0>,163      ;STEP TO 'CSH'E WRITEBACK L'
        BCS     3$              ;BR IF SIG NOT FND...ERR
        CMP.S   T26T2,171       ;CHK STATE OF CACHE LOGIC
        BCS     3$              ;BR IF CACHE SCREWED UP
        JSR     R4,5$           ; **** SUBTEST 6 ****
;-----CACHE CCA WRITEBACK TESTS.
        JSR     R5,SUSSP        ;SET PROGRAM TO RUN IN SINGLE STEP MODE
        AC16                    ;INIT PC
        INSYNC                  ; **** SUBTEST 7 ****
        SOBAC   <173,28.,0>,175      ;STEP TO 'CSH CCA WRITEBACK L'
        BCS     3$              ;ERR IF SIGNAL FNOT FOUND
        CMP.S   T26T2,147   ;CHK STATE OF CACHE LOGIC
        BCS     3$              ;BR ON ERR
        INSYNC                  ; **** SUBTEST 8 ****
        DFXCTT,STRCLK           ;CONTINUE THE AC PRGM
        JSR     R5,HWAIT        ;WAIT FOR "HALT"
        2                       ;FOR 22/60 SECOND AT CRO
        JSR     R4,6$           ;CONTINUE W/SUBTEST
        NORMAL                  ;ALL DONE!!!!!


;SEQ298

;-----LOCAL DIRTYWORK SUBROUTINE.  DOES INSYNC, CONTINUES AC PRGM.
;       CHECKS FOR HALT, THEN CHECKS CONTENTS  OF PA COUNTER.
5$:     INSYNC                  ;NXT SUBTEST
        DFXCTT,STRCLK           ;CONTINUE AC PRGM
        JSR     R5,HWAIT        ;WAIT FOR HALT
        1                       ;FOR 1/60 SECOND MAX AT CRO
        JSR     PC,CHKP         ;CHK FOR HALT
6$:     JSR     R5,RDMTR        ;READ PA CNTR
        MBDFPA
        CMP     R2,#1           ;COUNT EXACTLY 1?
        BNE     7$              ;BR IF NOT...ERROR
        RTS     R4              
7$:     MOV     R2,R0           ;COUNT TO ERR STK
        PWTES
        POP     R4              ;GET BACK SUBTEST #
        XFAULT  MBEX1,<ERROR IN METER PA CACHE LOGIC>
;-----TABLE OF SIGNALS TO CHECK IN THIS TEST.
T26T2:  DF.     174             ;E CORE RD RQ L
        BP.     22.
        DF.     171             ;CSH FILL CACHE RD L
        BP.     26.
        DF.     172             ;CSH CCA CYC L
        BP.     28.
        DF.     173             ;CSH CCA WRITEBACK L
        BP.     28.
        DF.     174             ;CSH EBOX CYC B L
        BP.     28.
        DF.     176             ;CSH E WRITEBACK L
        BP.     28.
        DF.     174             ;CACHE IDLE L
        BP.     -29.            ; - INDICATES END


;SEQ299



;SEQ301

        .SBTTL          METER BOARD MISCELLANEOUS TESTS
.REM    %
        METER BOARD TEST#27 IS THE FUNCTIONAL TEST OF THE INSTRUCTIONS
        WHICH ARE USED TO ACCESS THE 4 SIXTEEN BIT COUNTERS, IE, THE
        COMBINATIONS OF (DATAI, BLKI)*(TIM,MTR).
        %
;-----INITIALIZATION CONSISTS OF LOADING AN AC PROGRAM.  THE FUNCTION OF
;       THE PRGM IS TO LOAD SOME ARBITRARY VALUE INTO THE 4 COUNTERS.
;       THEN A LIST OF EXPECTED VALUES FOR THE 4 INSTRUCTIONS IS
;       GENERATED ONCE IN THE INITIALIZATION TO MAKE THE TEST FASTER.
I.27:   BR      4$              ;ON LOOPS, SKIP THE INITIALIZATION
        SM                      ;RE-INIT THE MACHINE
        JSR     R5,SETPTW       ;SET UP PT ADR'S
         EPTTB                  ;DUMMY ARG
        LOAD    AC7,5$,9.       ;LOAD THE AC PROGRAM
        RUN     AC7             ;RUN THE AC PRGM TO SET UP CNTS
        JSR     PC,CHKP         ;MAKE SURE PROGRAM HALTED
;-----NOW RETRIEVE THE CNTR VALUES VIA DFRD, MODIFY AND SAVE THEM FOR
;       THE ACTUAL TEST.
        MOV     #DBFTT,R3       ;SAVE AREA ADR
        MOV     #MBDFTB,R1      ;FIRST DFRD #
1$:     MOV     R1,R0           ;DFRD # TO PARAM REG
        JSR     R5,RDMTR2       ;GET CNTR VALUE TO R2
        DEC     R2              ;DO EQUIV OF EXPECTED ARITHMETIC
        CLR     R0              ;SHIFT 4 PLACES
        CLC
        ROR     R2
        ROR     R0
        ROR     R2
        ROR     R0
        ROR     R2
        ROR     R0
        ROR     R2
        ROR     R0
        MOVB    R0,(R3)+        ;NOW SAVE 36BIT WD OF EXPECTED VALUE
        SWAB    R0
        MOVB    R0,(R3)+
        MOVB    R2,(R3)+
        SWAB    R2
        MOVB    R2,(R3)+
        CLRB    (R3)+
        INC     R1              ;NXT DFRD # FOR NXT CNTR
        CMP     R1,#MBDFMA      ;DONE?
        BLE     1$              ;BR IF NO...ELSE GO INIT MTR BD PT AREAS


;SEQ302

;-----NOW INIT THE METER BOARD PROCESS TABLE AREAS TO KNOWN VALUES. 
;       THE ALGORITHM MAKES USE OF THE FACT THAT THE AREAS IN THE EPT &
;       UPT ARE ADJACENT AS FAR AS INTRA-PAGE ADDRESS IS CONCERNED.
;-----THE INITIAL KNOWN PT VALUES ARE:  HI/0 LO/377777770000
        MOV     #UPTEA-1,R1     ;INIT KL DESTINATION ADR
        MOV     #ZERO..,R2      ;ADR OF INITIAL DATA
        MOV     #ZERO..-B0123S,R3       ;INITIAL DATA ADR TOGGLE VALUE
2$:     MOV     R1,3$+2         ;SET UP DPOSVT KL ADR
        MOV     R2,3$+4         ;NOW PDP11 INITIAL DATA ADR
3$:     DPOSVT,000000,000000    ;MOVE INITAL DATA TO KL
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        SUB     R3,R2           ;PT TO OTHER INITIAL DATA FOR  NXT TIME
        NEG     R3              ;TOGGLE FOR TIME AFTER THAT
        INC     R1              ;NXT KL ADR
        BIT     #3,R1           ;LAST MB ADR IN THE CURRENT PT?
        BNE     2$              ;BR IF NO
        ADD     #EPT-UPT,R1     ;ELSE SWITCH FROM UPT TO EPT
        CMP     R1,#EPTTB-1     ;IN THE EPT?
        BEQ     2$              ;YES...LOOP
4$:     RTS     PC              ;INIT DONE
;-----THE  AC PROGRAM FOR METER BOARD TEST#27
5$:     IO10    CONO,MTR,,473000        ;7--TIME, EBOX, MBOX ON
        IO10    BLKO,TIM,,17    ;10-PERF ON
        I10     MOVE,0,,20      ;11-MAKE MBOX CNTR CNT
        I10     SOJG,16,,11     ;12-LOOP TIL CNT=0
        IO10    BLKO,TIM,,16    ;13-PERF OFF
        IO10    CONO,MTR,,404000        ;14-TIME, EBOX, MBOX OFF
        I10     JRST,4,,15      ;15-DONE
        WD36    0000,0000,0101  ;16-CNT FOR MEM READS
        WD36    0015,0277,7240  ;17-ENABLE DURATION MODE FOR PERF CNTR
B0123S: WD36    3777,7777,0000  ;CNT SHD OVRFLW TO HI WD
DBFTT:  .BLKB   20.             ;EWXPCTD CNTRS STORED HERE ON TEST INIT
        .EVEN


         







        


        
        
        

        

;SEQ303

.REM    %
        METER BOARD TEST#27,    ORDER OF TEST:

SUBTEST         INSTRUCTION     COUNTER                 DFRD NO.
-------         -----------     --------------------    ----------
   1            DATAI TIME      TIME BASE COUNTER          110
   2            BLKI TIM        PERFORMANCE ANALYSIS       111
   3            DATAI MTR       EBOX ACCTG. COUNTER        112
   4    BLKI MTR                MBOX ACCTG. COUNTER        113

        %
T.27:   MOV     #8$,R3          ;INIT INSTR PTR
        MOV     #DBFTT,R2       ;EXPECTED VALUE PTR
1$:     INSYNC                  ; ***** SUBTESTS 1-4 *****
        MOV     R3,R0           ;INSTR ADR TO PARAM REG
        ADD     #5,R3           ;PT TO NXT INSTR
        XQT                     ;DO INSTR
        EXAMT,AC1,SCRT36        ;GET HI ORD RESULT WD
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        MSKDAT  MBONE,ZERO..    ;CHK HI ORD WD (SHD B 1)
        ROR     R4              ;SAVE C-BIT
        BGT     2$              ;BR IF C-BIT WAS CLR
        ERRMSG  <HI ORDER WD\>  ;ELSE SEND ERR MSG
2$:     MOV     R2,3$           ;MOV XPECTD VAL ADR TO MSKDAT PL
        ADD     #5,R2           ;PT TO NXT XPECTD VAL
        EXAMT,AC2,SCRT36                ;GET LO ORD WD
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        JSR     R5,MSKDAT       ;CHK VALUE
        ZERO..                  ;MASK ADR
3$:     000000                  ;EXPECTED VAL ADR TO BE SUPPLIED
        BCC     6$              ;BR IF OK
        ERRMSG  <LO ORDER WD\>


;SEQ304

4$:     MOV     R5,R0           ;CALC ERR MSG ADR
        ASL     R0
        ASL     R0
        ASL     R0
        ADD     #7$-8.,R0       
        MOV     #5$,R1          ;INIT OUTPUT MSG PTR
        MOV     (R0)+,(R1)+     ;SET UP ERR MSG
        MOV     (R0)+,(R1)+      
        TST     (R1)+           ;SKIP 'I '
        MOV     (R0)+,(R1)+     
        MOV     (R0)+,(R1)+
        JSR     PC,F.FLT        ;GO TO ERR MSG ROUTINE
        MBEX1
        
5$:     .ASCIZ  %????I ????UCODE/EBOX ERR%
        .EVEN
6$:     ROL     R4              ;WAS HI ORD WD OK?
        BCS     4$              ;IF NOT, OUTPUT ERR MSG
        CMP     R5,#4           ;DONE WITH ALL SUBTESTS?
        BLT     1$              ;BR IF NO
        NORMAL                  ;ELSE DONE

7$:     .ASCII  %DATATIM  BLKTIM DATAMTR  BLKMTR %
8$:     IO10    DATAI,TIM,,1    ;TIME BASE WD PAIR TO AC1&AC2
        IO10    BLKI,TIM,,1     ;PERF CNT TO AC1&2
        IO10    DATAI,MTR,,1    ;EBOX CNT TO AC1&2
        IO10    BLKI,MTR,,1     ;MBOX CNT TO AC1&2
        .EVEN


;SEQ305



;SEQ306

;-----END OF GENERATION PASS ROUTINE
ENDPAS: CLR     SCANWD          ;CLR PASS CONTROL WD
        MOVB    #MTRNOT,TESTAB  ;SET CORRECT # OF TESTS TO TESTAB
        PMSG    <DHKCA GENERATION PASS COMPLETED W/ UCODE VER >
        MOV     CONSOL-2,R0     ;GET UCODE VERSION
        MOV     R0,UCODE        ;SAVE FOR FUTURE REFERENCE
        PNTOCS,PCRLF            ;PRINT IT
        GETVER          ;GERT PRGRM VERSION NUMBER
        PMSG    <CD DHKCA 3000,>        ;SET UP CMD FOR EXEC
        MOV     $$FF,R0
        PNTOCS
        PNTVER
        PCRLF
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD                  ;DUMP THIS PROGRAM
        BCC     1$              ;BR IF DUMP OK
        PMSG    <PROGRAM DUMP ERROR\>


1$:     PRGHLT




;SEQ307

.SBTTL  *MBOX*  MBOX TEST SUBROUTINE LIBRARY  18-OCT-76
.REM    %
        TRAP HANDLER.  EMULATES AN R5 CALLING CONVENTION.
%
$TRAP:  MOV     R5,$SAVE        ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC
        MOVB    -2(R5),R5       ;GET TRAP #
        CMP     R5,#130         ;VALID TRAP?
        BLE     1$              ;YES
        CLR     R5              ;NO,UNDEFINED
1$:     ASL     R5              ;MULTIPLY BY 2
        MOV     $TRBAS(R5),$LINK        ;GET ENTRY POINT
        POP     R5              ;TRAP PC TO R5

        PUSH    #2$

        RTT                     ;RESTORE USER STATUS
2$:     PUSH    $SAVE           ;ORIGINAL R5 TO STACK

        JMP     @$LINK          ;CALL PROGRAM

$LINK:  .WORD   0               ;TRAP LINKAGE SCRATCH
$SAVE:  .WORD   0               ;R5 FOR CALLING CONVENTION

$UNDEF: PMSG    <UNDEF. TRAP AT PC >
     

        MOV     R5,R0
        DEC     R0              ;
        DEC     R0              ;
        PNTOCS                  ;PRINT TRAP LOCATION
        POP     R5              ;RESTORE R5

        FATAL


;SEQ308

$TRBAS: .WORD   $UNDEF  ;ILLEGAL TRAP
        .WORD   CMPS.   ;TRAP 1
        .WORD   CMPSR.  ;TRAP 2
        .WORD   $UNDEF  ;TRAP 3 RESERVED
        .WORD   SAV.3   ;TRAP 4
        .WORD   RST.3   ;TRAP 5
        .WORD   SAV.5   ;TRAP 6
        .WORD   RST.5   ;TRAP 7
        .WORD   RUNPRG  ;TRAP 10
        .WORD   CONTIN  ;TRAP 11
        .WORD   RUNBIG  ;TRAP 12
        .WORD   STEP    ;TRAP 13
        .WORD   FIND    ;TRAP 14
        .WORD   EVENT   ;TRAP 15
        .WORD   STEP10  ;TRAP 16
        .WORD   STPCON  ;TRAP 17
        .WORD   BRST    ;TRAP 20
        .WORD   $UNDEF  ;TRAP 21 RESERVED
        .WORD   MSK16R  ;TRAP 22 
        .WORD   $UNDEF  ;TRAP 23 RESERVED
        .WORD   $UNDEF  ;TRAP 24 RESERVED
        .WORD   MSKDAT  ;TRAP 25
        .WORD   MSKDF   ;TRAP 26
        .WORD   MSKDFR  ;TRAP 27
        .WORD   $UNDEF  ;TRAP 30 RESERVED
        .WORD   $UNDEF  ;TRAP 31 RESERVED
        .WORD   RANGE   ;TRAP 32
        .WORD   $UNDEF  ;TRAP 33 RESERVED
        .WORD   $UNDEF  ;TRAP 34 RESERVED
        .WORD   $UNDEF  ;TRAP 35 RESERVED
        .WORD   $UNDEF  ;TRAP 36 RESERVED
        .WORD   LOAD    ;TRAP 37
        .WORD   ACNDR   ;TRAP 40
        .WORD   $UNDEF  ;TRAP 41 RESERVED
        .WORD   SBINI   ;TRAP 42
        .WORD   SB      ;TRAP 43
        .WORD   $UNDEF  ;TRAP 44 RESERVED
        .WORD   $UNDEF  ;TRAP 45 RESERVED
        .WORD   STEXCT  ;TRAP 46
        .WORD   XQT     ;TRAP 47
        .WORD   MEMRST  ;TRAP 50     
        .WORD   RSTMBX  ;TRAP 51
        .WORD   $UNDEF  ;TRAP 52 RESERVED
        .WORD   $UNDEF  ;TRAP 53 RESERVED
        .WORD   $UNDEF  ;TRAP 54 RESERVED
        .WORD   $UNDEF  ;TRAP 55 RESERVED
        .WORD   $UNDEF  ;TRAP 56 RESERVED
        .WORD   $UNDEF  ;TRAP 57 RESERVED
        .WORD   $UNDEF  ;TRAP 60 RESERVED
        .WORD   $UNDEF  ;TRAP 61 RESERVED
        .WORD   $UNDEF  ;TRAP 62 RESERVED
        .WORD   CRRONE  ;TRAP 63
        .WORD   INVAL   ;TRAP 64


;SEQ313

        .WORD   $UNDEF  ;TRAP 65 RESERVED
        .WORD   $UNDEF  ;TRAP 66 RESERVED
        .WORD   $UNDEF  ;TRAP 67 RESERVED
        .WORD   $UNDEF  ;TRAP 70 RESERVED
        .WORD   $UNDEF  ;TRAP 71 RESERVED
        .WORD   SOBAC   ;TRAP 72
        .WORD   $UNDEF  ;TRAP 73 RESERVED
        .WORD   PNTUML  ;TRAP 74
        .WORD   CMP.E   ;TRAP 75
        .WORD   CMP.F   ;TRAP 76
        .WORD   $UNDEF  ;TRAP 77 RESERVED
        .WORD   $UNDEF  ;TRAP 100 RESERVED
        .WORD   $UNDEF  ;TRAP 101 RESERVED
        .WORD   $UNDEF  ;TRAP 102 RESERVED
        .WORD   $UNDEF  ;TRAP 103 RESERVED
        .WORD   $UNDEF  ;TRAP 104 RESERVED
        .WORD   $UNDEF  ;TRAP 105 RESERVED
        .WORD   $UNDEF  ;TRAP 106 RESERVED
        .WORD   $UNDEF  ;TRAP 107 RESERVED
        .WORD   $UNDEF  ;TRAP 110 RESERVED
        .WORD   $UNDEF  ;TRAP 111 RESERVED
        .WORD   $UNDEF  ;TRAP 112 RESERVED
        .WORD   $UNDEF  ;TRAP 113 RESERVED
        .WORD   $UNDEF  ;TRAP 114 RESERVED
        .WORD   BACKPL  ;TRAP 115
        .WORD   CMPSG.  ;TRAP 116
        .WORD   $UNDEF  ;TRAP 117 RESERVED
        .WORD   $UNDEF  ;TRAP 120 RESERVED
        .WORD   $UNDEF  ;TRAP 121 RESERVED
        .WORD   $UNDEF  ;TRAP 122 RESERVED
        .WORD   $UNDEF ;TRAP 123 RESERVED
        .WORD   $UNDEF  ;TRAP 124 RESERVED
        .WORD   PNTID   ;TRAP 125
        .WORD   GETVER  ;TRAP 126
        .WORD   PNTVER  ;TRAP 127
        .WORD   $UNDEF  ;TRAP 130 RESERVED



.REM    %
        SUBROUTINE TO MAKE SURE THAT EXAM/DEPOSIT, EXECUTE, OR PROGRAM
RUN FINISHED UP CORRECTLY.  CHECKS C-BIT.  RETURNS IF CLEAR, ELSE DOES
ERROR WITH MESSAGE DEPENDING ON ENTRY POINT (CHKED, CHKX, OR CHKP).
        %
CHKED:  BCS     1$              ;BR IF ANY ERROR(S)
        RTS     PC              ;ELSE RETURN TO CALLER
1$:     MOV     #ERRED,R0       ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CCODE
CHKX:   BCS     1$              ;BR IF ERR BIT SET
        RTS     PC              ;ELSE RETURN
        
1$:     MOV     #ERRX,R0        ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKP:   BCS     1$              ;BR IF CARRY SET...ERR
        RTS     PC              ;ELSE RET
1$:     MOV     #ERRP,R0        ;POINT TO ERROR MESSAFE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKCOM:ERRCOM   PNTAL           ;PRINT ERROR MESSAGE
        ERRMSG  <\REAL ERROR PC: >

        POP     R0              ;GET REAL ERR PC

        SUB     #4,R0           ;ADJ
        ERRCOM  PNTOCT          ;PRINT IT
        TST     R5              ;CHK SUBTEST # FOR REASONABLE VAALUE
        BLE     1$              ; .LE. 0... NG
        CMP     R5,#3000
        BGT     1$              ;NG
        ERRMSG  <  SUBTEST: >

        MOV     R5,R0           ;SUBTEST # TO PARAM REG
        ERRCOM  PNTDEC          ;PRINT IT
1$:     ERROR

        ERRED:  .ASCIZ  %EXAMINE/DEPOSIT ERROR%
        ERRX:   .ASCIZ  %INSTRUCTION EXECUTE ERROR%
        ERRP:   .ASCIZ  %PROGRAM DIDN'T HALT%
        .EVEN



;SEQ311

.REM    %
        SUBROUTINE TO PLACE A PARAMETER WORD ON THE ERROR STACK.  THIS
        WORD IS IGNORED BY THE ERROR REPORTER, BUT MAY BE USED BY THE
        ISOLATION ROUTINE.  THE WORD IS PASSED TO THIS ROUTINE IN R0.
        %
PWTES:  PUSH    R0              ;SAVE PARAM WD
        MOV     ERSP..,R0       ;GET PTR TO ERR STK
        MOV     #FTPRM,(R0)+    ;PARAM WD FORMAT MARKER TO ERR STK
        POP     (R0)+           ;MOVE PARAM WD TO ERR STK
        MOV     R0,ERSP..       ;UPDATE ERR STK PTR
        RTS     R5              ;RET TO CALLER

;SEQ319

.REM    %
ROUTINES TO GET AND COMPARE A PSEUDO-STATUS WORD REGISTER
TO AN EXPECTED VALUE.  BOTH ARE MASKED BEFORE A COMPARISN.
CMPS.  IS CALLED BY JSR R5,CMPS.
                 .WORD <EXPECTED DATA>
                .WORD <ADDRESS OF SPEC TABLE>
                .WORD   <MASK USED WITH BIC>

CMPSR.  IS THE SAME EXCEPT THAT IN PLACE OF EXPECTED DATA
IS A MOV R'N',R1 WHERE N IS A REGISTER 1-4 THAT POINTS
AT THE EXPECTED DATA (PRESUMABLY IN A TABLE).

UPON RETURN FROM EITHER ROUTINE, THE "C-BIT" IS A ONE IF A
MISTMATCH WAD DETECTED.  THE ACTUAL DATA IS RETURNED IN R0, MASKED 

ERRORS CAUSE AN ERROR STACK ENTRY OF TYPE 'FT9'. AS MANY
WORDS ARE PUT ON THE STACK AS THERE ARE BVITS IN ERROR.  THE
LAS ENTRY HAS A ZERO SIGN BIT.
  
CMPSG. ENTRY ONLY:
   
ON A DIAGNOSTIC GENERATION PASS (SCANWD=X2X000), THE EXPECTED
DATA WILL BE CORRECTED AND NO ERRORS FLAGGED.
%

CMPSG.: BIT     #NOTVAL,SCANWD  ;TABLE VALID?
        BEQ     CMPS.           ;YES, DO COMPARE
        MOV     R5,CPXDAD       ;SAVE EXPECTED DATA ADDRESS
        BR      CMPS.1          ;JOIN COMMON CODE

CMPS.:CLR       CPXDAD          ;NO DATA GENERATION!
CMPS.1: PUSH    R1

        MOV     (R5)+,R1        ;GET EXPECTED DATA
        BR      CMPSC.          ;DO COMMON OPERATION

CMPSR.: CLR     CPXDAD          ;NO DATA GENERATION
        PUSH    R1


        MOV     (R5)+,1$        ;GET DATA GETTER
1$:     MOV     R1,R1           ;**PROTO - REPLACED DURING EXECUTION


;SEQ320

CMPSC.: PUSH    <R2,R3,R4>



        JSR     PC,CMPSM.       ;SET UP BIT SELECT MASK
        MOV     (R5)+,R4                ;POINT AT TABLE
        CLR     TEM.            ;FIRST ERROR FLAG
1$:     MOVB    (R4),R0         ;GET NEXT CONTROL BYTE
        BMI     3$              ;GO DO DIAG READ
        BIT     R3,(R5)         ;ENABLED?
        BNE     4$              ;NO, GET NEXT BYTE
        MOV     R0,R2           ;COPY BIT PTR
        BIC     #174,R0         ;PRESERVE WORD BITS
        ASL     R0              ;MULT BY 2
        MOVB    R0,ERBIT+1
        ADD     .DAT3,R0        ;R3 NOW POINTS TO DEXWD
        CLC
        BIC     #177703,R2      ;SAVE BIT # FIELD
        ROR     R2              ;POSITION TO SELECT WORD
        MOVB    R2,ERBIT
        BIT     R3,R1           ;TEST EXPCTED
        BNE     5$              ;IT A ONE
        BIT     MTBL(R2),(R0)   ;TEST THE DIAG BIT
        BEQ     4$              ;WAS IT A ZERO?
        MOV     #200,R0
        BR      8$              ;ERROR IS H NOT L


;SEQ321

;REQUEST A READ OF THIS DIAGNOSTIC MUX
;
3$:     BIC     #177600,R0      ;CLEAN OUT SIGN BITS
        MOV     R0,DFSAVE
        DFRD
        TSTB    (R4)+           ;BUMP SPEC PTR
        BR      1$              ;AND RETURN TO COMMON CODE
4$:     CLC
        ROR     R3
        BITB    #100,(R4)+
        BEQ     1$              ;DO ANOTHER
        POP     <R4,R3,R2,R1>   ;DONE




        TST     (R5)+
        CLC                     ;CLEAR ERROR FLAG
        TST     TEM.
        BEQ     41$             ;IF NO ERROR
        SEC                     ;SET ERROR FLAG
41$:    RTS     R5
5$:     BIT     MTBL(R2),(R0)
        BNE     4$              ;H IS OK
        CLR     R0
8$:     TST     CPXDAD          ;GENERATE EXPECTED?
        BEQ     81$             ;BR IF NOT
        BIS     R3,@CPXDAD      ;SET EXPECTED DATA
        TST     R0      ;REALLY WANT TO SET?
        BNE     4$              ;YES, WE DID
        BIC     R3,@CPXDAD      ;NO, MAKE EXPECTED AERO
        BR      4$              ;CONTINUE TESTING
81$:    TST     TEM.            ;FIRST ERROR?
        BNE     10$             ;BR IF NOT
        MOV     ERSP..,R2
        MOV     #FT9,(R2)+
        COM     TEM.            ;SET FLAG
9$:     BISB    DFSAVE,R0
        MOVB    R0,(R2)+        ;ACTUAL AND DIAG FCN
        ASR     ERBIT
        MOVB    ERBIT+1,R0
        MOVB    ENDB.(R0),R0    ;GET END BIT
        CLRB    ERBIT+1
        SUB     ERBIT,R0                ;MINUS PDP11 BIT = PDP10
        MOVB    R0,(R2)+                ;BIT NBR TO STACK
        MOV     R2,ERSP..
        BR      4$              ;RETURN TO TEST
10$:    MOV     ERSP..,R2               ;
        BIS     #BIT15,-2(R2)   ;SET CONTINUEW ON PREV ENTRY
        BR      9$
ENDB.:  .BYTE   35.,19.,3
.EVEN
CPXDAD:0                ;DATA ADDRESS STORAGE



;SEQ322

CMPSM.: MOV     (R5),R4 ;POINT TO TABLE
        CLR     R3
        SEC
11$:    ROL     R3              ;PICK UP NEXT BIT
1$:     TSTB    (R4)
        BMI     2$              ;DIAG FCN
        BITB    #100,(R4)+      ;DONE?
        BEQ     11$             ;BR IF NOT
        RTS     PC
2$:     INC     R4              ;BYPASS
        BR      1$              ;NEXT BYTE

        NOTVAL=BIT15            ;TABLE INVALID INDICATOR
SCANWD: .WORD   0               ;ZERO FOR NORMAL USE
  
;SEQ316

.REM    %
        ROUTINE TO REPORT BIT ERROR FOR TBIT PDP-10 BIT TEST
        %
BITERR: BNE     1$              ;FIND OUT BIT FLAVOR
        CLR     R0              ;WAS A ZERO
        BR      2$      
1$:     MOV     #200,R0         ;WAS A ONE
2$:     PUSH    <R1,R3>


        MOV     ERSP..,R3               ;GET ERR STACK POINTER
        MOV     #FT9,(R3)+              ;STORE FORMAT TYPE
        BISB    DFSAVE,R0               ;GET DIAG PN
        MOVB    R0,(R3)+                ;STACK BYTE
        MOVB    ERBIT,(R3)+             ;STACK BIT NBR IN LEFT
        MOV     R3,ERSP..               ;SAVE POINTER
        POP     <R3,R1>


        RTS     R5              ;RETURN


.SBTTL          COMPARE ROUTINES
.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON
OF 5-BYTES OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,MSK36R
        R2 = POINTER TO MASK (0S IMPLY TEST)
        R3 = POINTER TO EXPECTED DATA
        R4 = POINTER TO ACTUAL DATA

%
MSK36R: PUSH    <R1,R5>


        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #5,R0           ;LOOP COUNT
1$:     MOVB    (R3)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R2),R1         ;MASK IT
        MOVB    (R4)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R2)+,R5        ;MASK IT
        CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGT     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     3$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R2           ;RESOTRE MASK POINTER
        MOV     R2,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R4           ;RESTORE ACTUAL POINTER
        MOVB    (R4)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        SUB     #5,R3           ;RESTORE POINTER TO EXPECTED
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
3$:     POP     <R5,R1>


        RTS     R5              ;RETURN

FFLAG:  .WORD   0               ;FAULT FLAG


;SEQ318

.REM    %
        36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).
USES MSK36R.
CALL IS:
        JSR     R5,MSKDAT
        ENTRY+2 = POINTER TO MASK 
        ENTRY +4 = POINTER TO EXPECTED DATA
%
MSKDAT: PUSH    <R2,R3,R4>
        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;DO COMPARISON
        POP     <R4,R3,R2>
        RTS     R5              ;RETURN


;SEQ319

.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.
        (TRAINING PARAMETERS) USES MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDF
        ENTRY+2 = DIAGNOSTIC FUNCTION
        ENTRY+4 = POINTER TO MASK (0S IMPLY TEST)
        ENTRY+6 = POINTER TO EXPECTED DATA
%
MSKDF:  PUSH    <R2,R3,R4>



        MOV     (R5)+,R0        ;GET DIAGNOSTIC FUNCTION
        PUSH    R0

        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     R0

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;DIAG FN TO ERROR STACK
1$:     POP     <R4,R3,R2>


        RTS     R5              ;RETURN


.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.  USES
MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDFR
        R0      = DIAGNOSTIC FUNCTION
        R2      = POINTER TO MASK (OS IMPLY TEST)
        R3      = POINTER TO EXPECTED
%
MSKDFR: PUSH    <R4,R0>


        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     .DAT3,R4                ;DTE20 DATA POINTER
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     <R0,R4>

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;PUT DIAG FN ON ERROR STACK
1$:     RTS     R5              ;RETURN



;SEQ327

.REM    %
        16-BIT DATA COMPARE ROUTINE.  SETS THE C-BIT & LOADS
        THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASKED
        DIFFERENCE (ACTUAL -EXPECTED) IN R0.
        CALL IS:
        JSR     R5,MASK16
        CALL+2  = MASK (0S IMPLY TEST)
        CALL+4  = POINTER TO ACTUAL
        CALL+6  = POINTER TO EXPECTED
%
MASK16: PUSH    R1

        PUSH    (R5)+           ;MASK

        MOV     @(R5)+,R0       ;ACTUAL
        MOV     @(R5)+,R1       ;EXPECTED
        BIC     (SP),R0         ;MASK ACTUAL
        BIC     (SP)+,R1        ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        SUB     #6,R5           ;RESTORE ENTRY POINT
        MOV     (R5)+,(R1)+     ;MASK TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;EXPECTED TO ERROR STACK
        BR      MSK16F          ;CLEANUP & RETURN



;SEQ328

.REM    %
        16-BIT REGISTER DATA COMPARE ROUTINE.  SETS THE C-BIT &
        LOADS THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASK-
        ED DIFFERENCE (ACTUAL - EXPECTED) IN R0.
        CALL IS;
        JSR     R5,MSK16R
        R2 = MASK (0S IMPLY TEST)
        R3 = ACTUAL DATA
        R4 = EXPECTED DATA
%
MSK16R: PUSH    R1


        MOV     R3,R0           ;
        BIC     R2,R0           ;MASK ACTUAL
        MOV     R4,R1           ;
        BIC     R2,R1           ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        MOV     R2,(R1)+        ;MASK TO ERROR STACK
        MOV     R3,(R1)+        ;ACTUAL TO ERROR STACK
        MOV     R4,(R1)+        ;EXPECTED TO ERROR STACK
MSK16F: MOV     R1,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
MSK16E: POP     R1

        RTS     R5              ;RETURN

        ;PUTS DIAGNOSTIC FUNCTION IN R0 ON ERROR STACK
FRERR:  PUSH    R5

        MOV     ERSP..,R5       ;GET ERROR STACK POINTER
        MOV     #FT0,(R5)+      ;FORMAT TO ERROR STACK
        MOV     R0,(R5)+        ;DIAG FN TO ERROR STACK
        MOV     R5,ERSP..       ;UPDATE ERROR STACK POINTER
        POP     R5


        RTS     R5              ;RETURN


;SEQ332

.SBTTL          36-BIT ERROR PARSER  06-AUG-75
.REM    %
RANGE - ROUTINE TO TEST THE ERROR STACK TO DETERMINE THE BIT RANGE
OF 36-BIT DATA PATH ERRORS.  THE CALL IS JSR R5,RANGE.  REGISTER
R3 MUST POINT TO THE FTM36 FORMAT ENTRY ON THE ERROR STACK.
RETURNS AN INDEX OF BIT POSITION, RANGES IN R0.  INDEXES ARE AS
FOLLOWS:
        0:      BITS 30-35
        2:      BITS 27-29
        4:      BITS 24-26
        6:      BITS 18-23
        10:     BITS 12-17
        12:     BITS 09-11
        14:     BITS 06-08
        16:     BITS 00-05
        20:     BOTH HALVES
        22:     LOWER HALF
        24:     UPPER HALF
%
RANGE:  REGSAV                  ;SAVE REGISTERS
        CMP     (R3)+,#FTM36    ;FORMAT CORRECT?
        BNE     2$              ;NO, FATAL ERROR
        CLR     R4              ;CLEAR INDEX
1$:     JSR     PC,RANCOM       ;COMPARE A BIT RANGE
        BNE     3$              ;MISMATCH FOUND
        INC     R4              ;NEXT BIT RANGE
        INC     R4              
        CMP     R4,#20          ;ALL DONE?
        BLT     1$              ;NO, ERROR STACK O.K.
2$:     FATAL                   ;ERROR STACK ERROR
3$:     TST     R4              ;BITS 30-35?
        BEQ     4$              ;YES, TEST LOWER HALF
        CMP     R4,#10          ;BITS 12-17?
        BNE     5$              ;NO,SET INDEX & RETURN
        MOV     R4,TEM.         ;SAVE INDEX
        MOV     #16,R4          ;UPPER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 0-5
        BEQ     6$              ;NOT UPPER HALF
        MOV     #24,TEM.        ;SET INDEX = UPPER HALF
        BR      6$              ;CLEANUP & RETURN
4$:     MOV     R4,TEM.         ;SAVE INDEX
        MOV     #6,R4           ;LOWER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 18-23
        BEQ     6$              ;NOT LOWER HALF
        MOV     #22,TEM.        ;SET INDEX = LOWER HALF
        MOV     #10,R4          ;BOTH HALVES TEST
        JSR     PC,RANCOM       ;CHK BITS 12-17
        BEQ     6$              ;LOWER HALF
        MOV     #20,TEM.        ;SET INDEX = BOTH HALVES
        BR      6$              ;CLEANUP & RETURN
5$:     MOV     R4,TEM.         ;GET INDEX
6$:     REGRST                  ;RESTORE REGISTERS
        MOV     TEM.,R0         ;GET INDEX
        RTS     R5              ;RETURN


;SEQ333

        ;SUBROUTINE TO COMPARE ACTUAL & EXPECTED FOR THE RANGE
        ;SPECIFIED FOR THE INDEX VALUE IN R4.

RANCOM: PUSH    R4

        MOV     BRCNT(R4),SPCNT ;GET SHIFT COUNT
        MOV     R3,R4           ;GET ERROR STACK POINTER
        INC     R4              ;POINT TO ACTUAL
        INC     R4              
        JSR     PC,RANPOS       ;GET MASK & POSITION ACTUAL
        PUSH    R0              ;SAVE SHIFTED ACTUAL

        JSR     PC,RANPOS       ;GET, MASK & POSITION EXPECTED
        POP     <R1,R4>         ;RESTORE ACTUAL & INDEX


        MOV     BRMASK(R4),R2   ;GET MASK
        BIC     R2,R0           ;MASK EXPECTED
        BIC     R2,R1           ;MASK ACTUAL
        CMP     R0,R1           ;COMPARE THEM
        RTS     PC              ;RETURN

;TAKES THE DATA POINTED TO BY R4, MASKS IT & RETURNS THE
;BIT RANGE DESIRED RIGHT JUSTIFIED IN R0.
RANPOS: MOV     (R3),R5         ;GET MASK POINTER
        CLR     R0              ;BITS 20-35
        JSR     PC,RANP0        ;GET & MASK 28-35
        JSR     PC,RANP0        ;GET & MASK 20-27
        CLR     R1              ;BITS 4-19
        JSR     PC,RANP1        ;GET & MASK 12-19
        JSR     PC,RANP1        ;GET & MASK 4-11
        CLR     R2              ;BITS 0-3
        BISB    (R4)+,R2        ;SET 0-3
        BICB    (R5),R2         ;MASAK 0-3
        MOV     SPCNT,R5                ;GET SHIFT COUNT
1$:     DEC     R5              ;SHIFT DONE?
        BLT     2$              ;YES, RETURN
        ASR     R2              ;NO, SHIFT 3 WORDS RIGHT
        ROR     R1              ;
        ROR     R0
        BR      1$              ;LOOP AGAIN
2$:     RTS     PC              ;DATA IN R0, RETURN


RANP0:  BISB    (R4)+,R0        ;SET A BYTE
        BICB    (R5)+,R0        ;POSITION IT
        SWAB    R0              ;POSITION IT
        RTS     PC

RANP1:  BISB    (R4)+,R1        ;SET A BYTE
        BICB    (R5)+,R1        ;MASK A BYTE
        SWAB    R1              ;POSITION IT
        RTS     PC


;SEQ334

        ;TABLE OF SHIFT COUNT TO RIGHT JUSTIFY BITS LISTED

BRCNT:  .WORD   0       ;30-35
        .WORD   6.      ;27-29
        .WORD   9.      ;24-26
        .WORD   12.     ;18-23
        .WORD   18.     ;12-17
        .WORD   24.     ;09-11
        .WORD   27.     ;06-08
        .WORD   30.     ;00-05

        ;TABLE OF BIT CLEAR MASKS FOR EACH BIT RANGE

BRMASK: .WORD   177700  ;30-35
        .WORD   177770  ;27-29
        .WORD   177770  ;24-26
        .WORD   177700  ;18-23
        .WORD   177700  ;12-17
        .WORD   177770  ;09-11
        .WORD    177770     ;06-08
        .WORD   177700  ;00-05


.SBTTL          ERROR STACK COMPARE ROUTINES  22-SEP-75
.REM    %
        ROUTINES TO TEST THE ERROR STACK FOR THE PRESENCE OF DIAGNOSTIC
FUNCTION BIT ENTRIES OF FORMAT TYPE FT8 OR FT9.  SETS A BIT
IN A UML TABLE FOR EACH DIAGNOSTIC FUNCTION BIT FOUND TO CORRESPOND
TO A SPECIFIED LIST.  THE CALL IS JSR R5,CMP.E TO TEST ALL LIST
ENTRIES AND CMP.F TO SCAN FOR THE FIRST ERROR.  THE TRAILING
PARAMETER IS A POINTER TO A BYTE TABLE OF DIAGNOSTIC FUNCTIONS
AND BIT NUMBERS TO BE TESTED.  THE END OF THE TABLE IS DESIGNATED
BY SETTING BIT 7 OF THE LAST BYTE.  R0 MUST POINT TO THE ERROR
STACK FORMAT ENTRY OF FORMAT TYPE FT8 OR FT9.  THE C-BIT IS SET
AND A POINTER TO THE UML TABLE IS RETURNED IN R0 IF ANY MATCH IS
FOUND:  OTHERWISE R0 IS UNCHANGED.
%
CMP.E:  MOVB    #-1,EFLAG       ;SET ALL ERRORS FLAG
        BR      CMP.G           ;
CMP.F:  CLRB    EFLAG           ;CLEAR ALL ERRORS FLAG
        
CMP.G:  MOV     R0,DIF.         ;SAVE ERROR STACK POINTER
        MOV     (R5)+,TEM.      ;GET SPEC TABLE POINTER
        REGSAV
        MOV     TEM.,R4         ;GET SPEC TABLE POINTER
        CLRB    ISOFLG          ;CLEAR UML MATCH FLAG
        CLR     ISOUML          ;CLEAR UML TABLE
        CLR     ISOUML+2        ;
        CLR     ISOUML+4        ;
        CLR     ISOUML+6        ;
1$:     MOVB    (R4)+,R0        ;GET SPEC TABLE ENTRY
        BIT     #100,R0         ;DIAG. FN. OR BIT?
        BEQ     2$              ;BIT
        MOVB    R0,DFD8         ;SAVE FUNCTION
        BR      1$              ;GET BIT
2$:     BIC     #177600,R0      ;CLEAR END BIT
        CLRB    FT8DUN         ;CLEAR ERROR STACK DONE FLAG
        MOV     DIF.,R5         ;GET ERROR STACK POINTER
        CLR     FT9FLG          ;
        CMP     (R5)+,#FT8      ;FORMAT TYPE 8?
        BEQ     3$              ;YES
        MOV     #2,FT9FLG       ;
        CMP     -2(R5),#FT9     ;FORMAT TYPE 9?
        BEQ     3$              ;YES
        FATAL                   ;IMPROPER FORMAT



;SEQ258

3$:     MOV     FT9FLG,R1       ;GET FORMAT FLAG
        JSR     PC,@TSTERS(R1)  ;COMPARE AN ERROR STACK ENTRY
        BNE     4$              ;NO MATCH FOUND
        MOVB    FT8DF,R0        ;GET DIAGNOSTIC FUNCTION
        MOVB    R0,ISOFLG       ;SET UML FLAG
        SR      R0,2            ;DIVIDE DIAG. FN. BY 8


        BIC     #177761,R0      ;
        MOV     R0,DFD8         ;SAVE FOR SBOARD
        JSR     R5,SBOARD       ;SET PROPER BIT IN UML TABLE
                ISOUML          ;
        TSTB    EFLAG           ;ALL ERRORS?
        BNE     5$              ;YES, CONTINUE SCAN
        BR      6$              ;NO, CLEANUP & RETURN
4$:     TSTB    FT8DUN          ;DONE WITH STACK?
        BEQ     3$              ;NO, NEXT STACK ENTRY
5$:     TSTB    -1(R4)          ;DONE WITH SPEC TABLE?
        BPL     1$              ;NO, TRY NEXT
6$:     REGRST
        TSTB    ISOFLG          ;ANY FOUND?
        BEQ     7$              ;NO
        MOV     #ISOUML,R0      ;POINT TO UML TABLE
        SEC                     ;YES, SET C-BIT
7$:     RTS     R5              ;RETURN


;SEQ259

        ;COMPARE A FORMAT TYPE 8 ENTRY

ERSFT8: JSR     PC,GNSCT        ;GET ENTRY FROM ERROR STACK
        CMPB    DFD8,FT8DF      ;THIS DIAGNOSTIC  FUNCTION?
        BNE     6$              ;NO, RETURN
1$:     BITB    R3,(R1)         ;TEST EXPECTED = ACTUAL
        BEQ     2$
        BITB    R3,(R2)         ;
        BEQ     3$              ;NO, ERROR FOUND
        BR      4$              ;YES, MOVE ON
2$:     BITB    R3,(R2)         ;
        BEQ     4$              ;YES, MOVE ON
3$:     CMPB    R0,F8BTF        ;THIS BIT?
        BEQ     6$              ;YES, RETURN
4$:     ASR     R3              ;NEXT BIT
        BNE     5$              ;DONE WITH BYTE?
        BISB    #200,R3         ;YES, START NEXT
        DEC     R1              ;
        DEC     R2              ;
5$:     INC     F8BTF           ;INCREMENT BIT #
        CMPB    F8BTF,F8BTL    ;LAST BIT DONE?
        BLE     1$              ;NO, KEEP ON A PLUGGIN
6$:     RTS     PC              ;RETURN


        ;COMPARE A FT9 ENTRY

ERSFT9: MOVB    (R5)+,FT8DF     ;GET DIAG FN.
        BPL     1$              ;MAKE IT POSITIVE
        NEGB    FT8DF           ;
1$:     MOVB    (R5)+,F8BTF     ;GET BIT
        BMI     2$              ;DONE?
        INCB    FT8DUN          ;YES, SET FLAG & DO COMPARE
        BR      3$              ;
2$:     BICB    #BIT7,F8BTF     ;NO, CLEAR FLAG BIT
3$:     CMPB    DFD8,FT8DF      ;THIS DIAG FN.?
        BNE     4$              ;NO, RETURN
        CMPB    R0,F8BTF        ;COMPARE BITS
4$:     RTS     PC              ;RETURN

TSTERS:         ERSFT8          ;ENTRY POINT FOR FT8
                ERSFT9          ;ENTRY POINT FOR FT9
ISOFLG: .BYTE   0               ;UML TABLE SET FLAG
EFLAG:  .BYTE   0               ;ALL ERRORS FLAG
FT9FLG: .WORD   0               ;SET FOR FT9

DFSAVE: .WORD   0               ;LAST DIAG FN

ISOUML: .WORD   0,0,0,0         ;UML TABLE



.SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #$TRAP,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   0               ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   1               ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN

.SBTTL          PROGRAM PATCHER JAB29857        09-SEP-76  EDIT#11

;-----THIS IS A SMALL SUBROUTINE TO AID IN THE PATCHING OF PROGRAM.
;       IT IS STARTED VIA A KLDCP 'SE<ADR>' COMMAND.  FIRST IT ASKS FOR
;       ADDITIONS TO THE PATCH AREA, THEREAFTER IT REQUESTS AN ADR.
;       ANY NON-NUMERIC INPUT TERMINATES THE CURRENT ADR CHAIN.
$PATCH: JSR     R5,PATCH        ;<START HERE FOR SE<ADR> TYPE START>
        PRGHLT
        BR      $PATCH          ;LOOP ON 'HC' COMMAND
PATCH:  MOV     #$$FF,R3        ;PTR SAVES A WORD
        MOV     (R3),R1         ;POINT THE ADR REG AT THE PATCH AREA
        CLR     R2              ;IND ERR MSG NOT SENT
        INC     R1              ;MAKE SURE IT'S AN EVEN ADR
        BR      10$             ; (BR TO BIC SAVES A WORD)
1$:     CMP     R1,#70000       ;IN OVERLAY AREA?
        BLO     2$              ;BR IF NO
        TST     R2              ;HAVE WE SENT MESSAGE?
        BNE     2$              ;BR IF YES...DONT RESEND IT
        PMSG    <WARNING: IN OVERLAY AREA\>

        INC     R2              ;INDICATE ERR MSG SENT
2$:     MOV     R1,R0           ;GET & PRINT <ADR>/<CONTENTS>
        PNTOCT,PNTBAK,PSLASH
        MOV     (R1),R0
        PNTOCT
        PMSG    <   _>

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     4$              ;BR ON NON-NUMBER...END OF INPUT
3$:     MOV     R0,(R1)+        ;PUT DATA IN MEMORY
        CMP     R1,(R3)         ;SHD WE SAV UPDATED ADR?
        BLOS    1$              ;NO
        MOV     R1,(R3)         ;SAV UPDATED ADR
        BR      1$              ;LOOP FOR NEXT DATA WORD
4$:     CLR     R2              ;INDICATE MUST REPRINT ERR MSG IF NEC.
        PMSG    <ADDRESS: _>

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     9$              ;BR ON NON-NUMBER...END OF INPUT
5$:     MOV     R0,R1           ;MOVE ADR TO ADR REG
10$:    BIC     #BIT0,R1        ;FORCE TO EVEN ADR
        BR      1$              ;GO GET DATA INPUT
8$:     PMSG    <?\>            ;PRINT ERR INDICATOR

7$:     TTILNW,TTISDL           ;WAIT FOR INPUT, BYPASS JUNK
        BCS     9$              ;BR ON NO INPUT
        TTIOCT                  ;GET NUMBER
        BCS     8$              ;BR ON BAD #
9$:     RTS     R5              ;RETURN



;SEQ264

.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN


;SEQ266

SPCRST: MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/ LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES,SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT                  ;ENABLE CONDITIONS
       
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;NO
        JSR     R5,BRST1        ;YES,BUTST 34 TICKS
4$:     RTS     PC              ;RETURN


;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5


;SEQ268


.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT


.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        ERROR                   ;EBOX ERROR


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15


;SEQ348

.SBTTL          PATTERN GENERATOR
.REM    %
        
-----SLIDING BIT PATTERN SUBROUTINE JAB29857 20-DEC-74 EDIT#15
-----THESE TWO SUBROUTINES GENERATE ALL BIT PATTERNS NECESSARY TO TEST
        AN N-BIT WORD.  SBINI IS CALLED TO INITIALIZE SB.  SB WHEN
        CALLED RETURNS THE FOLLOWING PATTERNS, ONE FOR EACH CALL:
N SLIDING 0 PATTERNS, THEN N SLIDING 1 PATTERNS.
        REGISTER 0 POINTS TO THE PATTERN ON RETURN.

-----SBINI IS THE INITIALIZATION SUBRTN.  HE IS CALLED WITH A JSR R5.
        THE ONE TRAILING PARAMETER IS THE WIDTH (N BITS) OF THE PATTERN
        TO BE GENERATED.
%
SBINI:  MOV     (R5)+,R0        ;PICK UP THE PTRN SIZ
        MOV     R0,SBACSK               ;SAV IT FOR ACSKIP KLUDGE
        BGT     1$              ;BR IF GT 0 (NO ADJ NEC)
        BEQ     5$              ;PTRNS OF 0 WIDTH ARE A NO-NO
        NEG     R0              ;ELSE MAKE IT POS
1$:     CMP     #36.,R0
        BGE     4$
5$:     FATAL           ;PTRNS OF GT 36 BITS NOT ALLOWED
4$:     PUSH    R1
;-----SECTION TO CALC TRANSITION BYTE ADR
        MOV     #SBPAT-1,R1
2$:     INC     R1
        SUB     #8.,R0
        BGT     2$              ;LUD
        MOV     R1,SBFADR       ;SAV TRANSITION BYTE ADR
;-----SEC TO CREATE TRANSITION BYTE BIT PTRNS
        MOV     #377,R1
        SEC
3$:     ROR     R1
        CLC             
        INC     R0
        BLE     3$              ;LUD
        MOV     R1,SBSM         ;SAV 0 SLIDE STARTUP BIT PTRN
        MOVB    SBSM+1,SBFILL   ;SAV 0 SLIDE FILL BIT
        MOVB    #-1,SBCNTL      ;RST CNTL BYTE
        BR      SBEXIT          ;OUTA HERE
;-----DATA RETURN SUBROUTINE: RO<0 FOR SLIDING 0, >0 FOR SLIDING 1.  R1
;       HAS THE CURRENT PATTERN #.
SBD:    MOV     #61,R0  ;ASCII 1, SIGN BIT OFF, FOR SLIDING 1 PTRN
        TST     SBSM    ;SLIDING 1 OR 0?
        BEQ     1$              ;BR 1
        MOV     #100060,R0      ;ASCII 0, SIGN BIT ON, FOR SLIDING 0 PTRN
1$:     MOVB    SBCNTL,R1               ;PTRN # (1 TO N) INTO R1
        RTS     R5              ;RETURN


;SEQ349

;-----PATTERN GENERATION SUBROUTINE.  EXPECTS THAT SBINI HAS BEEN
;       CALLED.  RETURNS WITH R0 POINTING TO NEW PATTERN.  PATTTERN
;       MUST NOT BE MODIFIED OUTSIDE OF THIS SUBROUTINE. SB RETURNS
;       WITH THE CARRY SET WHEN CALLED AFTER THE LAST PATTERN HAS BEEN
;       GENERATED
SB:     PUSH    R1

1$:     MOV     #SBPAT+6,R0             ;EVERYONE NEEDS THIS PNTR
        INCB    SBCNTL          ;NEXT FUNC
        BGT     20$             ;SLIDE EXISTING PATTERN
;----SECTION TO CREATE INITIAL SLIDING 1 OR 0 PATTERN.  SLIDE 0 FIRST
        CLR     R1              ;INITY A SRC OF 0'S
10$:    MOVB    R1,-(R0)        ;PUT IN FILL BYUTE

        CMP     R0,SBFADR       ;IS THIS THE TRANSITION BYTE?
        BNE     12$             ;NO
        TST     SBSM            ;IS NEW PTRN SLIDING 1 OR 0?
        BNE     13$             ;BR SLIDING 0
        MOVB    SBFILL,(R0)     ;ELSE FOR SLIDING 1, PUT IN THE 1
        BR      12$
13$:    MOVB    SBSM,(R0)               ;FOR SLIDING 0, PUT IN 0 & TRAILING 1'S
        COM     R1              ;FILL WITH 1'S FROM NOW ON
12$:    CMP     R0,#SBPAT       ;PTRN DONE?
        BGT     10$             ;NO--LUD
        INCB    SBCNTL  ;IND OLD PTRN, CUR # IS 1
        BR      25$             ;EXIT WITH C-BIT CLEAR
;-----EXISTING PATTERN SHIFT SECTION.
20$:    ASR     -(R0)           ;START SHIFT (0 INTO MSBYTE)
        ROR     -(R0)
        ROR     -(R0)   ;THIS LAST SHIFT SETS C-BIT FOR LATER USE
        MOV     #SBSM,R1        ;PTR SAVES SPACE & TIME
        BCS     21$             ;BR IF 1 SHIFTED OUT
;-----SECTION FOR 0 SHIFTED OUT
        TST     (R1)            ;0 OR 1 SLIDE?
        BEQ     22$             ;BR 1 SLIDE
        CLR     (R1)+           ;0 SLIDE DONE...SET UP FOR 1 SLIDE
        MOVB    #-1,(R1)        ;ZAP SBCNTL
        BR      1$              ;CALC NEW PTRN FOR SLIDING 1
;-----AC SKIP PATTERN KLUDGE:  DONT ADDRESS THE AC'S IF N WAS LT 0
22$:    CMP     #10,(R0)        ;IS IT TIME FOR THE KLUDGE?
        BNE     25$             ;NO
        TST     SBACSK          ;WAS THE KLUDGE DESIRED?
        BGE     25$             ;NO
        BR      23$             ;DO KLUDGE---SET HI ORD BIT
;-----SECTION FOR 1 SHIFTED OUT OF THE PATTERN
21$:    TST     (R1)            ;0 OR 1 SLIDE?
        BNE     23$             ;BR 0 SLIDE
        SEC                     ;IF 1 CAME OUT & ARE IN 1 SLIDE
        BR      SBEXIT          ;THEN WE ARE DONE...IND THIS FACT
23$:    BISB    SBFILL,@-(R1)   ;SET HI ORD PTRN BIT ON 0 SLIDE/KLUDGE


;SEQ350

;-----EXIT SECTION.
25$:    CLC             ;CLEAR C-BIT FOR NOT DONE RET
SBEXIT: POP     R1              ;RSTR R1
        RTS     R5              ;& RETURN
;-----DATA SECTION FOR SBINI AND SB.
SBFADR: .WORD   0               ;ADDR OF TRANSITION BYTE IN PTRN
SBSM:   .WORD   0               ;LESSER 1 BITS & CNTL
SBCNTL: .BYTE   0               ;CONTROL AND PTRN #
        
SBFILL: .BYTE   0               ;HI ORD BIT OF PTRN
;NOTE: THE ABOVE 4 LINE MUST STAY AS THEY ARE
SBACSK: .WORD   0               ;AC SKIP INDICATOR
SBPAT:  .WORD   0,0,0   ;THE PTRN GOES HERE, R0 PNTS HERE ON EXIT




.REM    %
        
-----JAB29857 19-FEB-75  SUBROUTINE TO PERFORM THE SAME FUNCTION
        AS "STPCON" WITH THE EXCEPTION THAT, HAVING ONCE
        ESTABLISHED THE BURST COUNT, IT MAKES SURE THAT THE EVENT
        OCCURS AGAIN AT THE END OF THE BURST ON SUBSEQUENT CALLS.
%

SOBAC:  MOV     R5,BRKPC                ;SAV PC FOR FUNC. BRKPT.
SOBAC1: MOV     (R5)+,R0        ;GET BURST CNT
        BLT     1$              ;BR ON NO BURST CNT YET
        DEC     R0              ;BURST FOR 1 CLK LESS THAN CNT
        JSR     R5,BRST1        ;BURST
        MOV     (R5)+,R0        ;FUNCTION TO RO FOR 'EVENT1'
        JSR     R5,EVENT1       ;CLK & TEST FOR OCCURENCE OF EVENT
        RTS     R5              ;RET W/ C-BIT: CLR=FOUND, SET=NOT FOUND
1$:     MOV     (R5)+,R0        ;GET FUNCTION FOR 'FIND'
        JSR     R5,FIND2        ;STEP UNTIL EVENT OCCURS
        BCS     2$              ;IF EVENT DIDNT OCCUR, DONT SAV BRST CNT
        MOV     R0,-4(R5)       ;ELSE SAV BRST CNT FOR FUTURE USE
2$:     RTS     R5              ;RET W/C-BIT SET/CLR AS ABOVE

.REM    %
        
-----A DYNAMIC-DATA CALLER FOR SOBAC.  DOES THE SAME THING, EXCEPT
        THAT IT SHUFFLES DATA PASSED AND RETURNED.  BURST COUNTS ARE
        ASSUMED IN A LIST POINTED TO BY BCLA.  UPDATES COUNT IN LIST
        AND ADDRESS IN BCLA IF SOBAC WAS SUCCESSFUL.
%
SOBACF: MOV     (R5)+,R0        ;ENTRY FOR STATIC FUNC #
DSOBAC: MOV     R5,BRKPC        ;SAV PC FOR FUNC BRK PNT
        MOV     R0,2$           ;MOV FUNC TO PARAM LST
        MOV     @BCLA,1$        ;MOV BURST CNT TO PARAM LIST
        JSR     R5,SOBAC1       ;GO AND DO SOBAC
1$:      000000                 ;BURST CNT TO BE SUPPLIED
2$:      000000                 ;FUNCTION TO BE SUPPLIED
          BCS   3$              ;ON FAILURE, DONT UPDATE ANYTHING
        MOV     BCLA,R0         ;SAV BURST CNT & UPDATED ADR...
        MOV     1$,(R0)+        ;W/0 MODFG C-BIT
        MOV     R0,BCLA
3$:     RTS     R5

BCLA:   .WORD   -1              ;BURST COUNT LIST ADDRESS

;SEQ283

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0



                

.REM    %
ACNDR - ROUTINE TO PERFORM A NON-DESTRUCTIVEW READ OF AN AC OR
A LIMITED AMOUNT OF MEMORY.  ADDRESS TO READ IN R0.  RETURNS
POINTER TO DATA IN R0.
%
ACNDR:  MOV     R0,ACADR        ;ADDRESS TO BUFFER
        DFXCTT                  ;START THE COCK
                STRCLK
        MOV     #ACADR,R0       ;BUFFER POINTER TO R0
        EXAM                    ;DO EXAMINE
        RTS     R5              ;RETURN

ACADR:  .WORD   0,0             ;STORAGE FOR AC ADDRESS


.REM    %
        SUBROUTINE TO PERFORM A "RANDOM" LOAD OF THE KL10 AC'S.  EDIT#4
        METHOD OF CALL IS AS FOLLOWS:
        JSR     R5,ACLOAD
        .WORD   ACMASK,11-ADR
-----OR-----
        JSR     R5,ACSCAT
        .WORD   ACMASK,ADR1,ADR2,...,ADRN
        -----WHERE-----
        ACMASK SPECIFIES WHICH KL10 AC'S ARE TO BE LOADED: BIT 0 SET
        MEANS ACO GETS LOADED, ETC.
        A CALL TO ACLOAD SAYS THAT THE KL10 WORDS ARE CONTIGUOUS WITHIN
        PDP11 MEMORY, STARTING AT "11-ADR".
        A CALL TO ACSCAT SAYS THAT THE KL10 WORDS ARE SCATTERED IN PDP11
        MEMORY. AND ARE POINTED TO BY ADR1, ADR2, ETC., ON ADR/WORD.
        THE C-BIT IS CLEAR UPON RETURN FOR SUCCESSFUL COMPLETION.
        %

ACLOAD: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        MOV     (R5)+,R2        ;ADR OF LOAD STRING TO R2
        BR      ACLDCM          ;GO TO COMMON ROUTINE
ACSCAT: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        CLR     R2              ;INDICATE SCATTERED LOAD WORDS
ACLDCM: CLR     3$+2            ;SET KL10 ADR=AC0, CLR C-BIT
        DFXCTT,STRCLK           ;MAKE SURE CLOCK IS RUNNING
1$:     ROR     R1              ;MOV MASK BIT TO C-BIT
        BCC     4$              ;BR IF THIS AC IS NOT BE BE LOADED
        MOV     R2,3$+4         ;MOV PDP11 ADR TO DPOST ADR LIST
        BEQ     2$              ;BR IF NOT CORRECT ADR
        ADD     #5,R2           ;ELSE PT TO KL WD FOR NXT TIME
        BR      3$              ;GO DO THE DPOSIT
2$:     MOV     (R5)+,3$+4      ;FOR SCATTERED LOAD, MOV NXT ADR
3$:     DPOST,000000,000000     ;DEPOSIT (KL ADR & PDP11 ADR TO BE SUP.)
        BCC     4$              ;BR IF NO ERROR ON DEPOSIT
        ERRMSG  <REAL ERR PC=>

        MOV     R5,R0           ;RETURN PC TO PARAM REG
        ERRCOM  PNTOCT          ;RET PC TO ERR SKT
        ERROR   <AC PROGRAM LOAD ERR>

4$:     INC     3$+2            ;NXT KL ADR
        TST     R1              ;ANY MORE AC'S TO BE LOADED?


;SEQ286

        BGT     1$              ;BR IF YES
        POP     <R2,R1>         ;RESTORE REGS


        RTS     R5


.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;


    
ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN




;SEQ293

.REM    %
CRRONE - ROUTINE TO LOAD A CACHE USE ALGORITHM TO ACCESS ONLY ONE
CACHE.
%
CRRONE: MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LDREF1       ;LOAD CODE
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   2               ;STARTING ADDRESS
        RTS     R5              ;RETURN

LDREF1: PUSH    R1

        ROR     R0              ;POSITION CACHE TO USE
        ROR     R1              ;
        BIC     #177774,R0      ;
        MOV     R0,USEADR+2     ;PUT IN INDEX WORD
        BIC     #77777,R1       ;
        MOV     R1,USEADR       ;
        POP     R1

        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -6
        .WORD   USEADR
        RTS     R5

USEADR: WD36    0,0,0

        IO10    BLKO APR,,0,1   ;LOAD AN ADDRESS

        I10     ADDI AC1,,4     ;NEXT ONE
    
        I10     TRNE AC1,,774   ;DONE?

        I10     JRST,,,2        ;NO, LOOP AGAIN

        I10     JRST,4,,2       ;YES, HALT


;SEQ294

.SBTTL          CACHE SWEEP ROUTINES
        
.REM    %
INVAL - INVALIDATES THE CACHE.
%
INVAL:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CSHSWP
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   1               ;STARTING ADDRESS
        RTS     R5              ;RETURN

CSHSWP: IO10    DATAI CCA,,0


        IO10    CONSZ APR,,200000

        I10     JRST,,,2


        I10     JRST,4,,1





.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
     HQ